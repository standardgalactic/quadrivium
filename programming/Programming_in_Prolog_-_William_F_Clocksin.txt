

W. F. Clocksin 
C. S. Mellish 
Programming 
• In 
Prolog 
Springer-Verlag 
Berlin Heidelberg New York 1981 

William F. Clocksin 
Department of Engineering Science, University of Oxford 
Parks Road 
Oxford OX1 3PJ / England 
Christopher S. Mellish 
Department of Artificial Intelligence, University of Edinburgh 
Hope Park Square, Meadow Lane 
Edinburgh EH8 9NW / Scotland 
ISBN-13: 978-3-540-11046-0 
e-ISBN-13: 978-3-642-96661-3 
DOl: 10.1007/978-3-642-96661-3 
Library of Congress Cataloging in Publication Data. Clocksin, W. F. 
(William F.), 1955- Programming in Prolog. Bibliography: p. Includes 
index. 1. Prolog (Computer program language) I. Mellish, Christopher S., 
1954-. II. Title. 0A76.73.P356C57. 001.64'24. 81-14459 
ISBN-13: 978-3-540-11046-0 (New York) AACR2 
This work is subject to copyright. All rights are reserved, whether the 
whole or part of the material is concerned, specifically those of 
translation, reprinting, re-use of illustrations, broadcastings, repro-
duction by photocopying machine or similar means, and storage in 
data banks. Under § 54 of the German Copyright Law where copies 
are made for other than private use, a fee is payable to "Verwertungs-
gesellschaft Wort", Munich. 
© Springer-Verlag Berlin Heidelberg 1981 
2146/3140-543210 

Preface 
The computer programming language Prolog is quickly gaining popularity throughout the 
world. 
Since Its beginnings around 1970. Prolog has been chosen by many programmers 
for applications of symbolic computation. including: 
D 
relational databases 
D 
mathematical logic 
D 
abstract problem solving 
D 
understanding natural language 
D 
architectural design 
D 
symbolic equation solving 
D 
biochemical structure analysis 
D 
many areas of artificial Intelligence 
Until now. there has been no textbook with the aim of teaching Prolog as a practical 
programming language. 
It Is perhaps a tribute to Prolog that so many people have been 
motivated to learn It by referring to the necessarily concise reference manuals. a few published 
papers. and by the orally transmitted 'folklore' of the modern computing community. 
However. 
as Prolog is beginning to be Introduced to large numbers of undergraduate and postgraduate 
students. many of our colleagues have expressed a great need for a tutorial guide to learning 
Prolog. 
We hope this little book will go some way towards meeting this need. 
Many newcomers to Prolog find that the task of writing a Prolog program Is not like 
specifying an algorithm in the same way as In a conventional programming language. 
Instead. 
the Prolog programmer asks more what formal relationships and objects occur In his problem. 
and what relationships are "true" about the desired solution. 
So. Prolog can be viewed as 
a descriptive language as well as a prescriptive one. The Prolog approach Is rather to describe 
known facts and relationships about a prOblem. than to prescribe the sequence of steps taken 
by a computer to solve the problem. 
When a computer Is programmed In Prolog. the actual 
way the computer carries out the computation is specified partly by the logical declarative 
semantics of Prolog. partly by what new facts Prolog can 'Infer' from the given ones, and 
only partly by explicit control information supplied by the programmer. 
Prolog Is a practical and efficient implementation of many aspects of 'Intelligent' program 

VI 
execution. such as non-determinism. parallelism. and pattern-directed procedure call. 
Prolog 
provides a uniform data structure. called the term, out of which all data. as well as Prolog 
programs. are constructed. A Prolog program consists of a set of clauses. where each clause 
Is either a fact about the given Information or a rule about how the solution may relate to 
or be 'Inferred' from the given facts. 
Thus. Prolog can be seen as a first step towards the 
ultimate goal of programming In log/c. 
In this book we will not be concerned greatly with 
the wider Implications of logic programming or with why Prolog Is not the ultimate logic 
programming language. 
Instead. we will be concerned with showing how useful programs can 
be written using the Prolog systems that exist today. 
This book can serve several purposes. 
The aim of this book Is not to teach the art 
of programming as such. 
We feel that programming cannot be learned simply by reading 
a book or by listening to a lecturer. 
You've got to do programming to learn It. 
We hope 
that beginners without a mathematical background can learn Prolog from this book. although 
In this case we would recommend that the beginner is taught by a programmer who knows 
Prolog. as part of a course that Introduces the student to programming as such. It Is assumed 
that the beginner can obtain the use of a computer that has a Prolog system Installed. and 
that he has been Instructed In the use of a computer terminal. 
The experienced programmer 
should not require extra assistance. but he also should not dismay at our efforts to restrain 
mathematical affectation. We have used draft versions of this book to teach university graduates 
who did little mathematics as schoolchildren. and who specialised in philosophy and psychology 
whilst at university. 
In our experience. novice programmers find that Prolog programs seem to be 
more 
comprehensible than equivalent programs In conventional languages. However. the same people 
tend not to appreciate the limitations that conventional languages place on their use of 
computing resources. 
On the other hand. the programmer experienced in conventional 
languages Is better prepared to deal with abstract concepts such as variables and control 
flow. 
But. In spite of his prior experience. he may find Prolog difficult to adapt to. and he 
may need a lot Of convincing before he considers Prolog a useful programming tool. Of course, 
we know of many highly experienced programmers who have taken up Prolog with much 
enthusiasm. 
However. the aim of this book Is not to convert. but to teach. 
Like 
most other programming 
languages. Prolog exists In 
a number of different 
Implementations. each with Its own semantic and syntactic peculiarities. 
In this book we have 
adopted a ·core Prolog". and all of our examples conform to a standard version that 
corresponds to the Implementations. developed mainly at Edinburgh. for four different computer 
systems: 
the DECsystem-10 running TOPS-10. the DEC PDP-ll running Unix. the DEC LSI-ll 
running RT-ll. and the ICL 2980 running EMAS. 
The Implementations for the DEC computers 
are probably the most wldespead. 
All the examples In this book will run on all four of the 
Implementations. 
In the appendices. we list some of the existing Prolog Implementations. 
Indicating how they diverge from the standard. 
The reader will appreciate that most of the 

VII 
deviations are of a purely cosmetic nature. 
This' book was designed to be read sequentially. although It will prove helpful to read 
Chapter 8 at the time the reader begins to write Prolog programs consisting of more than 
about ten clauses. 
Furthermore. It Is wise to read the appropriate appendix that describes 
the particular Implementation of Prolog. 
Appendices tell how to enter clauses. what debugging 
facilities are available. and other practical matters. 
It shouldn't hurt to browse through the 
book. but do take care not to skip over the earlier chapters. 
Each chapter Is divided Into several sections. and we advise the 
reader to attempt the 
exercises that are at the end of many sections. The solutions to some of the exercises appear 
at the end of the book. 
Chapter 1 Is a tutorial Introduction that Is Intended to give the reader 
a "feel" for what Is required to program In Prolog. 
The fundamental Ideas of Prolog are 
Introduced. and the reader Is advised to study them carefully. 
Chapter 2 presents a more 
complete discussion of points that are Introduced In Chapter 1. 
Chapter 3 deals with data 
structures and derives some small example programs. 
Chapter 4 treats the subject of 
backtracking In more detail. and Introduces the "cut" symbol. which Is used to control 
backtracking. Chapter 5 Introduces the facilities that are available for Input and output. Chapter 
6 describes each built-In predicate In the standard "core" of Prolog. 
Chapter 7 Is a potpourri 
of example programs collected from many sources. together with an explanation of how they 
are written. 
Chapter 8 offers some advice on debugging Prolog programs. and provides an 
alternative model of control flow. Chapter 9 Introduces the Grammar Rule syntax. and examines 
the design decisions for some aspects of analysing natural language by using Grammar Rules. 
Chapter 10 describes the relation of Prolog to Its origins In mathematical theorem proving 
and logic programming. Chapter 11 specifies a number of projects on which Interested readers 
may wish to practise their programming ability. 
We express our gratitude to our teachers who have Influenced the way we think about 
programming: 
Rod Burstall. Peter Scott Langston. and Robin Popplestone. 
We thank those 
friends who have collaborated In the development of Prolog as a practical and useful 
programming tOOl. and who encouraged us In the preparation of this book: 
Alan Bundy. 
Lawrence Byrd. Robert Kowalski. Fernando Pereira. and David Warren. 
In particular. Lawrence 
Byrd supported the development of this book from Its Inception by suggesting programs. 
exercises. some of the projects listed In Chapter 11. and many Ideas. 
We also thank our 
friends who contributed to this book by providing helpful comments and advice on earlier drafts 
of this book: Jon Cunningham. Richard O·Keefe. Helen Pain. Fernando Pereira. Gordon Plotkin. 
Robert Rae. Peter Ross. Maxwell Shorter. Aaron Sloman and David Warren. 
In this regard. 
W.F.C. especially thanks his postgraduate students of the School of Eplstemlcs. and of the 
Department of Artificial Intelligence. who were compelled to be the subjects of many experiments 
In teaching programming. 
For our examples. we have been free In adapting and developing 
programs from the general Prolog folklore. 
We apologise to anyone who feels slighted or 

VIII 
plagerlsed by this. 
This book was prepared while the authors were employed at the Department of Artificial 
Intelligence. University of Edinburgh. 
We thank Jim Howe. Head of the Department. who 
provided the necessary opportunities and facilities with which to carry out this project. 
Edinburgh, Scotland 
June, 1981 
W.F.C. 
C.S.M. 

Table of Contents 
Chapter 
1. 
Tutorial Introduction .............................. 1 
Gives the student a "feel" for what It Is like to program In Prolog. 
Introduces 
objects. relationships. facts. rules. variables. 
1.1 
Facts 
1.2 
Questions 
1.3 
Variables 
1.4 
Conjuctions 
1.5 
Rules 
1.6 
Summary and Exercises 
Chapter 
2. 
A Closer Look . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 
More detailed presentation of Prolog syntax and. data structures. 
2.1 
Syntax 
2.2 
Characters 
2.3 
Operators 
2.4 
Equality 
2.5 
Arithmetic 
2.6 
Summary of Satisfying Goals 
Chapter 
3. 
Using Data Structures ............................ 39 
Representing objects and relationships by using "trees" and "/Ists". 
Developing 
several example Prolog programs. 
3.1 
Structures and Trees 
3.2 
Lists 
3.3 
Membership of a List 

x 
3.4 
Example: 
Changing a Sentence Into Another 
3.5 
Example: 
Comparing Alphabetic Order 
3.6 
Example: 
A Parts Inventory 
Chapter 
4. 
Backtracking and "Cut" 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 
How a set of clauses generates a set of solutions. 
Using "cut" to modify the 
control sequence of running Prolog programs. 
4.1 
Generating Multiple Solutions 
4.2 
The "Cut" 
4.3 
Common Uses of the "Cut" 
4.4 
Problems with 'Cut' 
Chapter 
5. 
Input and Output ............................... 79 
Facilities 
available 
for 
the 
Input 
and 
output 
of 
characters 
and 
structures. 
Developing a program to read sentences from the user and represent the sentence 
as a list of words, which can be used 
with the Grammar Rules of Chapter 9. 
5.1 
Reading and Writing Characters 
5.2 
Reading and Writing Terms 
5.3 
Reading English Sentences 
5.4 
Using Files 
5.5 
Declaring Operators 
Chapter 
6. 
Built-In Predicates .............................. 94 
Definition of the "core" built-In predicates, with sensible examples of how each 
one Is used. 
By this point, the reader should be able to read reasonably complex 
programs, and should therefore be able to absorb the built-in predicates by seeing 
them in use. 
6.1 
Entering New Clauses 
6.2 
Success and Failure 
6.3 
Classifying Terms 
6.4 
Treating Clauses as Terms 
6.5 
Looking at the Structure of Terms 
6.6 
Affecting Backtracking 
6.7 
Creating Complex Goals 
6.8 
F.quallty 

6.9 
Basic Input and Output 
6.10 Handling Files 
6.11 Evaluating Arithmetic Expressions 
6.12 Comparing Numbers 
6.13 Watching Prolog at Work 
XI 
Chapter 
7. 
More Example Programs ........................... 130 
Many example programs are given, covering a wide range of Interests. 
New 
examples 
include list processing, 
set operations, 
symbolic 
differentiation 
and 
simplification of formulae. 
7.1 
A Sorted-Tree Dictionary 
7.2 
Searching A Maze 
7.3 
Towers of Hanoi 
7.4 
Improved Parts Inventory 
7.5 
List Processing 
7.6 
Representing and Manipulating Sets 
7.7 
Sorting 
7.8 
Assert and Retract: 
Random. Gensym. Flndall 
7.9 
Searching Graphs 
7.10 Sift the Two's and Sift the Three's 
7.11 Symbolic Differentiation 
7.12 Mapping and Transforming Trees 
Chapter 
8. 
Debugging Prolog Programs ......................... 164 
By this point, the reader will be able to write reasonable programs, and so the 
problem of debugging will be relevant. 
Flow of control model, hints about common 
bugs, techniques of debugging. 
8.1 
Layout of Prolog Programs 
8.2 
Common Errors 
8.3 
Another Control Flow Model 
8.4 
Using Spy Points and Tracing 
8.5 
Fixing Bugs 
Chapter 
9. 
Using Grammar Rules ............................ 187 
Applications of existing techniques. 
Using Grammar Rules. 
Examining the design 
decisions for some aspects of analysing natural language with Grammar Rules. 

XII 
9.1 
The Parsing Problem 
9.2 
Representing the Parsing Problem in Prolog 
9.3 
The Grammar Rule Notation 
9.4 
Adding Extra Arguments 
9.5 
Adding Extra Tests 
9.6 
Summary 
Chapter 
10. 
The Relation of Prolog to Logic ...................... 207 
Predicate Calculus, clausal form, resolution theorem proving, logic programming. 
10.1 
Brief Introduction to Predicate Calculus 
10.2 
Clausal Form 
10.3 
A Notation for Clauses 
10.4 
Resolution and Proving Theorems 
10.5 
Horn Clauses 
10.6 
Prolog 
10.7 
Prolog and Logic Programming 
Chapter 11. 
Projects In Prolog .............................. 228 
Appendices 
A selection of suggested exercises, projects, and problems. 
11.1 
Easler Projects 
11.2 
Advanced Projects 
A. 
B. 
C. 
D. 
E. 
F. 
G. 
H. 
I. 
Answers to Selected Exercises . 
Clausal Form -- Prolog Programs 
The ASCII Code 
Different Versions of Prolog 
The DECsystem-l0 Prolog System 
The PDP-ll Unix Prolog System 
The LSI-ll RT-ll Prolog System 
The ICL 2980 EMAS Prolog System 
Other Prolog Systems 
235 
240 
245 
247 
250 
259 
266 
273 
274 
index ....................................... 275 

Chapter 1. Tutorial Introduction 
Prolog is a computer programming language that Is used for solving problems that Involve 
objects and the relationships between objects. 
In this chapter we shall show the essential 
elements of the language In real programs. but without becoming diverted by details. formal 
rules. and exceptions. 
At this point. we are not trying to be complete or precise. 
We want 
to bring you quickly to the point where you can write useful programs. so to do that we must 
concentrate on the basics: 
facts. questions. variables. conjunctions. and rules. 
Other features 
of Prolog. such as lists and recursion. will be treated In later chapters. 
We use Prolog when we wish the computer to solve problems that can be expressed 
In the form of objects and their relationships. 
For example. when we say "John owns the 
book". we are declaring that a relationship. ownership. exists between one object "John" and 
another individual object "the book". 
Furthermore. the relationship has a specific order: 
John 
owns the book. but the book doesn't own Johnl 
When we ask the question "Does John own 
the book?". we are trying to find out about a relationship. 
Some relationships don't always mention all the objects that are Involved. 
For example. 
when we say "The jewel is valuable". we mean that there Is a relationship. called "being 
valuable". which Involves a Jewel. 
We did not mention who finds the jewel valuable. or why. 
It all depends on what you want to say. 
In Prolog. when you will be programming the computer 
about relationships like these. the amount of detail you provide also depends on what you 
want the computer to accomplish. 
There Is one more point of philosophy to mention. then we will begin programming. 
We are all familiar with using rules to describe relationships between objects. 
For example. 
the rule "Two people are sisters if they are both female and have the same parents" tells 
us something about what it means to be sisters. 
It also tells us how to find out If two people 
are sisters: 
simply check to see If they are both female and have the same parents. 
What 
Is Important to notice about rules Is that they are usually oversimplified. but they are acceptable 
as definitions. 
After all. one cannot expect a definition to tell us everything about something. 
For example. most people would agree there is much more to "being sisters" In real life than 
the above rule Implies. 
However. when we are solving a particular problem. we need to 

2 
concentrate on just those rules that help to solve the problem. 
So. we ought to consider 
an Imaginary and simplified definition If It Is sufficient for our purposes. 
Computer programming in Prolog consists of: 
o 
declaring some facts about objects and their relationships. 
o 
defining rules about objects and their relationships. and 
o 
asking questions about objects and their relationships. 
For example. suppose we told Prolog our rule about sisters. 
We could then ask the question 
whether Mary and Jane are sisters. 
Prolog would search through what we told It about Mary 
and Jane. and come back with the answer "yes" or 'no". depending on what we told It earlier. 
So. we can consider Prolog as a storehouse of facts and rules. and It uses the facts and 
rules to answer questions. 
Programming In Prolog consists of supplying all these facts and 
rules. 
The Prolog system enables a computer to be used as a storehouse of facts and rules. 
and it provides ways to make Inferences from one fact to another. 
Prolog Is a conversational language. which means that you and the computer carry out 
a kind of conversation. 
Assume that you are seated at a computer terminal and have asked 
to use Prolog. 
The computer terminal you use has a keyboard and a display. 
You use the 
keyboard to type characters Into the computer. and the computer uses the display (either a 
screen or paper) to type results back to you. 
Prolog will walt for you to type In the facts 
and rules that pertain to the problem you want to solve. 
Then, If you ask the right kind 
of questions, Prolog will work out the answers and show them on the display. 
We will now Introduce each of the fundamentals of Prolog one by one. 
Don't worry 
about not having the complete story about each feature of Prolog straight away. 
There will 
be complete summaries and more examples worked out In later chapters. 
1.1 
Facts 
We first discuss facts about objects. 
Suppose we want to tell Prolog the fact that "John 
likes Mary". 
This fact consists of two objects. called "Mary" and "John". and a relationship. 
called "likes". 
In Prolog. we need to write facts In a standard form. like this': 
likes(john,mary). 
The following things are important: 

3 
o 
The names of all relationships and objects. must begin with a lower-case letter. 
For 
example. likes, john, ma.:r:y. 
o 
The relationship Is written first, and the objects are written separated by commas. 
and the objects are enclosed by a pair of round brackets. 
o 
The full stop character • .' must come at the end of a fact. 
When defining relationships between objects using facts. you should pay attention to what order 
the objects are written between the round brackets. 
In fact. the order is arbitrary. but we 
must decide on some order and be consistent about it. 
For example. In the above fact. we 
have put the 'Iiker' as the first of the two objects in round brackets. and we have put the 
object that Is liked In the second slot. 
So. the fact likes( john,ma.:r:y) is not the same thing 
as likes(ma.:r:y.john). 
The first fact says that John likes Mary. and the second fact says 
that Mary likes John. according to our current arbitrary convention. 
If we want to say that 
Mary likes John. then we must explicitly say so: 
likes(mary.john). 
Look at the following examples of facts. together with possible explanations In English: 
valuable( gold) . 
female( jane). 
owns( john. gold). 
father(john,mary). 
"gold is valuable" 
"Jane is female" 
"John owns gold" 
"John is the father of Mary" 
Each time a name Is used. the name refers to a particular individual object. 
Because of 
our familiarity with English. It Is fairly clear that the names john and jane refer to Individuals. 
But. In some other facts. we have used the name gold, and it is not necessarily obvious 
what It means. 
When using names. we must decide on how to Interpret the name. 
For 
example. the name gold could refer to an object. 
In this case we think of the object as 
some particular lump of gold that we denote by the name gold. 
And when we say In Prolog 
valuable( gold), we would mean that this particular lump of gold. which we have named gold, 
Is valuable. 
On the oth~r hand. we could interpret the name gold to mean "the mineral gold". 
and when we say valuable( gold), we would mean that the minerai gold is valuable. 
So. 
there Is more than one way to Interpret a name. and it Is you, the programmer. who decides 
on the Interpretation. There should be no problem as long as you interpret names consistently. 
By the way. In the above facts we have Interpreted gold to be 'the mineral gold'. but another 
interpretation could have been chosen. 
The Prolog facts would look the same. 
It is important 
to bring out the distinctions between different interpretations early. so that we are quite certain 
what names mean. 

4 
Now for some terminology. The names of the objects that are enclosed within the round 
brackets In each fact are called the arguments. 
Note: computer programmers use the word 
argument' In a technical sense which bears none of the common connotations of dispute. 
debate. discussion. theme. or topic. 
The name of the relationship. which comes just before 
the round brackets. Is called the predicate. 
So. va1uab~e Is a predicate having one argument. 
and J.iltes Is a predicate having two arguments. 
The names of the objects and relationships are completely arbitrary. 
Instead of a rule 
such as J.ilteS(john,mary), we could just as well represent this as a(h,e), and remember 
that a means "likes". b means "John". and e means "Mary". 
However. we normally select 
names that help us to remember what they represent. 
So. we must decide In advance what 
our names mean. and what the order of arguments shall be. 
Thereafter we must remain 
consistent. 
It does not matter to Prolog how many arguments are Involved In a relationship. 
If we 
want to define a predicate called pay, where we mention two players and a game they play 
with each other. we need three arguments. 
Here are two exam pies of this: 
p~ay(john.mary,footha~~). 
play(jane,jim,hadminton). 
It also does not matter to Prolog If we declare facts that are not true In the real world. 
We could write king(jobn,france) to declare that "John Is the king of France" (being king 
Is a relationship). In the real world this Is obviously false. especially because France abOlished 
the Monarchy sometime around 1792. 
But Prolog does not know. and does not care. 
Facts 
In Prolog simply allow you to express arbitrary relationships between objects. 
In Prolog. a collection of facts is called a database. 
We will use the term "database" 
whenever we have collected together some facts (and later. rules) that are used to solve a 
particular problem. 
1.2 
Questions 
Once we have some facts. we can ask some questions about them. In Prolog. a question 
looks just like a fact. except that we put a special symbol before it. 
The special symbol 
consists of a question mark and a hyphen. 
Consider the question: 
1- owns(mary,book). 
If we Interpret mary to mean "Mary" and 
book to mean some particular book. this Is like 
asking "Does Mary ·own the book?". or "Is it a fact that Mary owns the book?" We are not 

5 
asking whether she owns all books, or books in general. 
When a question Is asked of Prolog, it will search through the database you typed In 
before, 
It looks for facts that match the fact In the question. 
Two facts match if their 
predicates are the same (spelt the same way). and If their corresponding arguments each 
are the same. 
If Prolog finds a fact that matches the question, Prolog will respond yes. 
If no such fact exists In the database. Prolog will respond no. 
The response from Prolog 
is printed on on the display of your computer terminal on the line just below your question. 
Consider the following database: 
likes( joe, fish) • 
likes(joe,marY). 
likes(mary,book). 
likes ( john,book). 
If we typed in all those facts to the Prolog system, we could ask the following questions. 
and Prolog would give the answers on the line just after the question: 
?- likes(joe,money). 
no 
1- likes(mary,joe). 
no 
?- likes(mary,book). 
yes 
?- king(john,france). 
no 
The answers to the first three questions should be clear to you. 
Prolog also answered 
"no· to the question of whether John was the king of France. 
This Is because there were 
no facts about royal relationships in the list of four likes relationships above. 
In Prolog. 
the answer "no· is used to mean "not as far as I know". 
It is important to remember that 
"no" Is not the same as "definitely not". 
For example. suppose a database about some famous 
Greeks contains only the following three facts: 
human( socrates) . 
human(aristotle). 
athenian(socrates). 
We could ask some questions: 
?- athenian(socrates). 
yes 
?- athenian(aristotle). 
no 
?- greek(socrates). 
no 

6 
Although It may be true that Aristotle lived In Athens. we cannot 'prove" it simply from the 
facts shown In the database. 
Furthermore. although It Is shown In the database that Socrates 
Is an Athenian. this does not "prove" he Is a Greek unless more Information is in the database. 
So. when Prolog answers "no" to a question. it means "not provable". 
In the above database. both John and Mary like the same object. 
We know they like 
the same object because the same name. book, appears in both facts. 
The facts and questions we have discussed so far are not particularly interesting. 
All 
we can do Is get back the same Information we put In. 
It would be more useful to ask 
questions like "What objects does Mary like?" This is what variables are for. 
1.3 
Variables 
If you want to find out what things that John likes. it is tiresome to have to ask "Does 
John like books?". "Does John like Mary?'. and so forth. with Prolog giving a yes-or-no answer 
each time. 
It is more sensible to ask Prolog to tell you something that he likes. 
We could 
phrase a question of this form as. "Does John like X?". 
When we ask a question. we do 
not know what the object is that X could stand for. 
We would like Prolog to tell us what 
the possibilities are. 
In Prolog we can not only name particular objects. but we can also 
use names like X to stand for objects to be determined by Prolog. 
Names of this second 
kind are called variables. 
When Prolog uses a variable. the variable can be either Instantiated 
or unlnstantiated. 
A variable is instantiated when there Is an object that the variable stands 
for. 
A variable Is unlnstantlated when what the variable stands for Is not yet known. 
Prolog 
can distinguish variables from names of particular objects because any name beginning with 
a capital letter is taken to be a variable. 
When Prolog Is asked a question containing a variable. Prolog searchs through all Its 
facts to find an object that the variable could stand for. 
So when we ask "Does John like 
X?'. Prolog searches through all of its facts to find things that John likes. 
A variable. such as X. does not name a particular object In Itself. but It can be used 
to stand for objects that we cannot name. 
For example. we cannot name "something that 
John likes" as an object. so Prolog adopts a way of saying this. 
Instead of asking a question 
like: 
?- likes( john, "something that john likes"). 
Prolog lets us use variables. like this: 
?- likes(john,X). 

Variables can have longer names If we wish. 
This question Is acceptable to Prolog: 
?- likes(john,Somethingthatjohnlikes). 
Why? 
Because a variable can be any name that begins with a capital letter. 
Consider the following database of facts. followed by a question: 
likes(john,flowers). 
likes(john,mary). 
likes(paul,mary). 
?- likes(john,X). 
7 
The question asks "Is there something that John likes?". 
When asked the question. Prolog 
will respond: 
X=flowers 
and then walt for further instructions. which we will talk about shortly. 
How does this work? 
When Prolog is asked this question. the variable is uninstantiated. 
Prolog searches though 
the database. looking for a fact that matches the question. 
Now If an unlnstantlated variable 
appears as an argument. Prolog will allow that argument to match any other argument In the 
same position In the fact. 
What happens here is that Prolog searches for any fact where 
the predicate is likes, and the first argument Is john. 
The second argument in this case 
may be anything. because the question was asked with an unlnstantlated variable as the second 
argument. When such a fact Is found. then the variable X now stands for the second argument 
In the fact. whatever it may be. 
Prolog searches through the database in the order It was 
typed in (or top-to-bottom on the printed page) so the fact likes( john, flowers) is found 
first. 
Variable X now stands for the object flowers. 
Or. we say that X Is Instantiated to 
flowers. 
Prolog now marks the place in the database where a match Is found. 
The 
place-marker is used for reasons we discuss shortly. 
Once Prolog finds a fact that matches a question. It prints out the objects that the 
variables now stand for. 
In this case. the only variable was X. and it matched the object 
flowers. 
Now Prolog waits for further instructions. as we said above. If you type the computer 
terminal's RETURN key. meaning you are satisfied with just one answer. then Prolog will stop 
searching for more. If instead you type the semicolon (followed by RETURN>' Prolog will resume 
its search through the database as before, starting from where it left the' place-marker. 
When 
Prolog begins seaching from a place-marker. instead of from the beginning of the database, 
we say that Prolog is attempting to re-satisfy the question. 
Suppose in response to Prolog's first answer (X=flowers) we asked it to carryon (by 
typing semicolon). 
This means we want to satisfy the question in another way: 
we want 
to find another object that X could stand for. 
This means that Prolog must 'forget' that X 

8 
stands for flowers; and resume searching with X unlnstantlated again. 
Because we are 
searching for an alternatve solution. the search Is continued from the place-marker. 
The 
next matching fact found Is liltes(john,mary). 
The variable X Is now instantiated to mary, 
and Prolog puts a place-marker at the fact likes (john,mary). 
Prolog will print ·x=mary·. and 
walt for further commands. 
If we relentlessly type another semicolon. Prolog will continue 
the search. 
In this example there is nothing more that John likes. 
So. Prolog will stop Its 
search. and allow us to ask more questions or declare more facts. 
What happens if. given the same facts above. we ask the question: 
?-liltes(X,mary). 
This question asks "Is there an Object that likes Mary?" By now you should see that the objects 
In the example that like Mary are john and paul. 
Again. if we wanted to see all of them. 
we would type ";" after Prolog types out each one of the answers: 
?- liltes(X,mary). 
X=john; 
X=paul; 
no 
, .4 
Conjunctions 
(our question) 
(first answer. 
We type ";" in reply) 
(second answer. 
Again we type ";") 
(no more answers.) 
Suppose we wish to answer questions about more complicated relationships. like: 
"Do John and Mary like each other?" 
One way to do this would be first to ask if John likes Mary. and If Prolog tell us yes. then 
we ask if Mary likes John. 
So. this problem consists of two separate goals that we have 
to satisfy. 
Because a combination like this is frequently used by Prolog programmers. there 
is a special notation for It. 
Suppose we have the following database: 
likes(mary,food). 
likes(mary,wine). 
liltes(john,wine). 
likes(john,mary). 
We want to ask if John and Mary like each other. 
To do this. 'we ask "Does John like Mary 
and does Mary like John?" The "and" expresses that fact that we are interested in the 
con/unction of the two goals -- we want to satisfy them both one after the other. We represent 
this by putting a comma between the goals: 
?- liltes(john,mary), likes(mary,john). 

9 
The comma Is pronounced "and". and it serves to separate any number of different goals 
that have to be satisfied In order to answer a question. When a sequence of goals (separated 
by commas) Is given to Prolog. Prolog attempts to satisfy each goal In turn by searching 
for a matching goal in the database. 
All goals have to be satisfied in order for the sequence 
to be satisfied. 
Using the above list of facts. what should Prolog print out? 
The answer 
15 "no". 
It 15 a fact that John likes Mary. so the first goal 15 true. 
However. the second 
goal is not true. since there Is nowhere in the list of facts where likes(mary,john) occurs. 
Since we wanted to know If they both liked each other. the whole question 15 answered "no'. 
Conjunctions and the use of variables can be combined to ask quite Interesting questions. 
Now that we know that it cannot be shown that John and Mary like each other. we ask: 
"Is there anything that John and Mary both like?" 
This question also consists of two goals: 
o 
First. find out if there is some X that Mary likes. 
o 
Then. find out if John likes whatever X Is. 
In Prolog the two goals would be put in a conjunction like this: 
1- likes(mary,X), likes(john,X). 
Prolog answers the question by attempting to satisfy the first goal. 
If the first goal is In 
the database. then Prolog will mark the place In the database. and attempt to satisfy the second 
goal. 
If the second goal is satisfied. then Prolog marks that goa/'s place In the database. 
and we have found a solution that satisfies both goals. 
It Is most important to remember 
that each goal keeps its own place-marker. 
If. however. the second goal 15 not satisfied. 
then Prolog will attempt to re-satlsfy the previous goal (in this case the first goaD. 
Remember 
that Prolog searches the database completely for each goal. 
If a fact In the database happens 
to match. satisfying the goal. then Prolog will mark the place in the database In case it has 
to re-satlsfy the goal at a later time. 
But when a goal needs to be re-satlsfied. Prolog will 
begin the search from the goal's own place-marker. rather than from the start of the database. 
Our above question "Is anything liked by Mary also liked by John" Illustrates an example of 
this "backtracking" behaviour In the following way: 
1. The database is searched for the first goal. As the second argument (X) 15 unlnstantlated. 
It may match anything. 
The first such matching fact In our above database Is 
likes(mary,food). So. now X Is Instantiated to food everywhere In the question where 
X appears. 
Prolog marks the place in the database where it found the fact. so it 
can return to this point In case It needs to resatlsfy the goal. 
Furthermore. we need 
to remember that X became Instantiated here. 50 Prolog can 'forget' X if we need 

10 
to re-satlsfy this goal. 
2. 
Now. the database is searched for 1i1tes( john, food). 
This Is because the next goal 
is 1i1tes( john,X), and X stands for food. 
As you can see. no such fact exists. so 
the goal fails. 
Now when a goal falls. we must try to re-satisfy the previous goal. 
so Prolog attempts to re-satisfy 1i1tes(mary,x), but this time starting from the place 
that was marked in the database. 
But first we need to make X un Instantiated once 
more. so X may 
match against anything. 
3. 
The marked place Is 1i1tes(mary,food), so Prolog begins searching from after that 
fact. 
Because we have not reached the end of the database yet. we have not exhausted 
the possibilities of what Mary likes. and the next matching fact is 1i1tes(mary,wine). 
The variable X is now instantiated to wine, and Prolog marks the place in case It 
must re-satisfy what Mary likes. 
4. 
As before. Prolog now tries the second goal. searching this time for 1i1tes( john, wine). 
Prolog is not trying to re-satisfy this goal. 
It is entering the goal again (from the 
left-hand side. as It werel. so it must start seachlng from the beginning of the database. 
After not too much searching. the matching fact Is found. and Prolog notifies you. 
Since this goal was satisfied. Prolog also marks its place in the database. In case 
you want to re-satisfy the goal. 
There Is a place-marker in the database for each 
goal that Prolog is attempting to satisfy. 
5. 
At this point. both goals have been satisfied. 
Variable X stands for the name wine. 
The first goal has a place-marker In the database at the fact 1i1tes(mary,wine), and 
the second goal has a place-marker in the database at the fact 1i1tes( john, wine). 
As with any other question. as soon as Prolog finds one answer. it stops and walts for further 
instructions. 
If we type a semicolon. Prolog will search for more things that both John and 
Mary like. 
We know now that this amounts to re-satisfying both goals starting from the 
place-markers that they left behind. 
To sum up. we can imagine a conjuctlon of goals to be arranged from left to right. 
separated by commas. 
Each goal may have a left-hand neighbour and a right-hand neighbour. 
Clearly. the left-most goal does not have a left-hand neighbour. and the right-most goal does 
not have a right-hand neighbour. 
When handling a conjunction of goals. Prolog attempts to 
satisfy each goal In turn. working from left to right. 
If a goal becomes satisfied (or sated 
perhaps?). Prolog leaves a place-marker in the database that is associated with the goal. 
Think of this as drawing an arrow from the goal to the place in the database where the solution 
is. 
Furthermore. any variables previously uninstantiated might now be instantiated. 
This 
happened above at Step 1. 
If a variable becomes instantiated. all occurrences of the variable 
in the question become instantiated. 
Prolog then attempts to satisfy the goal's right-hand 
neighbour. starting from the top of the database. 
As each goal in turn becomes satisfied. 

11 
It leaves behind a place-marker In the database (draws another arrow from the goal to the 
matching fact>. In case the goal needs to be re-satlsfled at a later time. 
Any time a goal 
falls (cannot find a matching fact>. Prolog 
goes back and attempts to re-satiSfy its left-hand 
neighbour. starting from Its place-marker. 
Furthermore. Prolog must first ·uninstantlate" any 
variables that became Instantiated at this goal. 
In other worcis. Prolog must "undo" all the 
variables when It resatlsfies a goal. 
If each goal. upon being entered from Its right. cannot 
be re-satlsfied. then the failures will cause Prolog to gradually creep to the left as each goal 
falls. 
If the first goal (the left-most goaD falls. then It does not have a left-hand neighbour 
that It can attempt to re-satlsfy. 
In this case. the entire conjunction falls. 
This behaviour. 
where Prolog repeatedly attempts to satisfy and resatisfy goals In a conjunction. Is called 
backtracking. 
Backtracking Is summarised in the next chapter. and is given a more complete 
and sophisticated treatment in Chapter 4. 
When following the examples. you may find it helpful to write. below each variable In 
a goal. the object that has been Instantiated by the success of the goal. 
You should also 
write in an arrow from the goal to its place-marker In the database. 
An example of this 
pencll-and-paper aid is shown here at several different times during the evaluation of the 

12 
above example. 
DATABASE 
GOALS 
~ikeS(mary,food)~ 
?-
~ikes(mary,X), 
~ikes(mary,wine). 
~-----
~ -
~ikes( john,X). 
~ 
~ikes(john,wine). 
food 
food 
~ikes(john,mary). 
1. 
The first goa~ succeeds. 
2. 
X is instantiated to 'food'. 
3. 
Next, attempt to satisfy the second goa~: 
~ikes(mary,food)~ 
?-
~ikes(mary,X), likes(john,X). 
~ikes( mary ,wine). 
~------- ~~----
~ -
~ikes(john,wine). 
food 
food 
likeS(jOhn,mary)~ 
4. 
5. 
The second goa~ fails. 
Next, backtrack: 
forget previous value 
of X, and attempt to re-satisfy first goa~. 
likes(mary, food). 
?-
~ikes(mary,X), likes(john,X). 
likes(mary,wine) __ 
.~--____________ ~~;; ------ t -
~ 
~ikes(john,wine). 
wine 
wine 
likes(john,mary). 
6. 
The first goa~ succeeds again. 
7. 
X is instantiated to 'wine'. 
8. 
Next, attempt to satisfy the second goa~: 
~ikes(mary,food). 
?-
~ikes(mary,X), likes(john,X). 
~ikes(mary,wine )A 
~ ;7-----9
t 
---- t -
likes( john, wine ) ......... ----___ 
-
_ 
Wl.ne 
Wl.ne 
likes(john,mary). 
9. 
The second goa~ succeeds. 
10. 
Pro~og notifies you of success, and waits 
for a reply. 

13 
Throughout this book we will attempt to show where backtracking occurs In the examples. 
and what effect It has In solving the problems. 
Backtracking Is so Important that the whole 
of Chapter 4 Is devoted to It. 
Exerclse.!J..;. Continue the pencll-and-paper simulation of the example given above. assuming 
that you have Just typed a semicolon ';' to Initiate backtracking In order to find out If John 
and Mary both like anything else. 
1.5 
Rules 
Suppose we wanted to state the "fact that John likes all people. 
One way to do this 
would be to write down separate facts. like this: 
1ikes(john,alfred). 
1ikes( john ,bertrand ). 
1ikes(john,char1es). 
1ikes(john,david). 
for every person In our database. This could become tedious. especially If there are hundreds 
of people In our Prolog program. 
Another way to say that John likes all people Is to say. 
·John likes any object provided It Is a person.' 
This fact Is In the form of a rule about what John likes. Instead of listing all the people 
John likes. 
In a world where John could like every person. the rule Is much more compact 
than a list of facts. 
In Prolog. rules are used when you want to say that a fact depends on a group of other 
facts. 
In English. we can use the word "If" to express a rule. 
For example. 
I use an umbrella If there Is rain. 
John buys the wine If It Is less expensive than the beer. 
Rules are also used to express definitions. for example: 
or 
·X Is a bird If: 
X Is an animal. and 
X has feathers.' 
·X Is a sister of Y If: 

14 
X Is female, and 
X and Y have the same parents." 
In the above English definitions. we have used variables X and Y. 
It is important to 
remember that a variable stands for the same object whenever it occurs in a rule. 
Otherwise 
we would be violating the spirit of the definition. 
For example. we could not show that Fred 
is a bird because Fido is an animal and Mary has feathers. 
The same principle of consistent 
Interpretation of variables is true also for rules in Prolog. 
A rule is a general statement about objects and their relationships. 
For example. not 
only could we say that Fred is a bird if Fred is an animal and Fred has feathers. but we 
could also say that Bertram is a bird if Bertram is an animal and Bertram has feathers. 
So. we can allow a variable to stand for a different object in each different use of the rule. 
Within a use of a rule. of course. variables are interpreted consistently as pointed out above. 
Let us consider several examples. beginning with a rule using one variable and a 
conjunction. 
"John likes anyone who likes wine" 
or. in other words. 
"John likes something If It likes wine" 
or. with variables. 
"John likes X If X likes wine." 
In Prolog. a rule consists of a head and a body. 
The head and body are connected by 
the symbol ":-". which is made up of a colon and a hyphen. 
The ":-" is pronounced "if". 
The above exam pie written in Prolog is: 
1ikes(john,X) :- 1ikes(X,wine). 
Notice that rules also are ended with a dot. 
The head of this rule Is 1ikes( john,X). 
The 
head of the rule describes what fact the rule Is Intended to define. 
The body. In this case 
1ikes(X,wine), describes the conjunction of goals that must be satisfied. one after the other. 
for the head to be true. 
For example. we can make John more choosy about whom he likes. 
simply by adding more goals onto the body. separated by commas: 
1ikes(john,X) :- 1ikes(X,wine), 1ikes(X, food). 

15 
or. in words. 
"John likes anyone who likes wine and food." 
Or. suppose John likes any female who likes wine: 
likes(john,X) :- female(X), likes(X,wine). 
Whenever we look at a Prolog rule. we should take notice of where the variables are. 
In the above rule. the variable X is used three times. 
Whenever X becomes instantiated to 
some object. all X's are instantiated within the scope of X. 
For some particular use of a 
rule. the scope of X Is the whole rule. including the head. and extending to the dot "" at 
the end of the rule. 
So. in the above rule. if X happens to be Instantiated to mazy, then 
Prolog will try to satisfy the goals female(mazy) and likes(mazy,wine). 
Next. as an example of a rule that uses more than one variable. consider a database 
consisting of facts about some of the family of Queen Victoria. 
We shall use the predicate 
parents having three arguments such that: 
parents(X,Y,Z) 
means 
"The parents of X are Y and Z." 
with Y being the mother, and 
with Z being the father. 
We shall also use the predicates female and mal.e in the obvious way. One part of the database 
might look like this: 
male( albert: ) . 
male( edward) . 
female( alice) . 
female(victoria). 
parents(edward,victoria,albert:). 
parents(alice,victoria,albert:). 
Now we shall use the rule about "sister of" described earlier. 
The rule defines the predicate 
Sister_of, having two arguments so that sister_of(X,Y) Is true if X is a sister of Y. 
Notice 
that we have used the underscore character "_" in the predicate name. 
Although we have 
not given the complete rules for how to construct names. It is permitted to include underscores 
in a name. and we shall summarise the rules in the next chapter. 
Now X is a sister of 
Y if: 

16 
[] 
X Is female. 
[] 
X has mother M and father F. and 
[] 
Y has the same mother and father as X does. 
This can be written as the following Prolog rule. 
sister_of(X,Y) :-
female(X), 
parents(X,M,F), 
parents(Y,M,F). 
We use the variable names M and F to Indicate "mother" and "father" (and not "male" and 
"female". which Is a different Interpretatlonl>. 
Notice that we are using variables that do not 
appear In the head of the rule. 
These variables. M and F. are treated In the same way 
as any other variable. 
When Prolog uses the rule. variables M and F will Initially be 
unlnstantlated. so they will match against anything when It becomes time to satisfy the goal 
parent(X,M,P). 
However. as soon as they are Instantiated. then al/ the M's and F's In this 
use of the rule will become Instantiated. 
The following example should help to explain how 
these variables are used. 
Let us ask the question: 
?- sister_of(alice,edward). 
When asked this question given the above database and rule for sister_of, Prolog proceeds 
as follows: 
1. 
First. the question matches the head of the only siste~of rule above. so X In the 
rule becom.es Instantiated to alice and Y Instantiated to edward. 
The place marker 
for the question Is put against this rule. 
Now Prolog attempts to satisfy the three 
goals In the body. one by one. 
2. 
The first goal Is femal.e( alice) because X was Instantiated to al.ice In the previous 
step. 
This goal Is true from the list of facts. so the goal succeeds. 
As It succeeds. 
Prolog marks the goal's place In the database (the third entry In the database>. 
No 
new variables were Instantiated. so no other note Is made. 
Prolog now attempts to 
satisfy the next goal. 
3. 
Now Prolog searches for parents(alice,M,p), where M and F will match against any 
arguments 
because 
they 
are 
unlnstantlated. 
A 
matching 
fact 
Is 
parents(alice,victoria,alhert), so the goal succeeds. 
Prolog marks the goal's 
place In the database (sixth down from the top>. and records that M became Instantiated 

17 
to victoria. and F to allJert:. (You may write these under the goal In the rule If 
you like). 
Prolog now attempts to satisfy the next goal. 
4. 
Now Prolog searches for pa:cents( edwa%d. victoria. allJert:) because Y Is known as 
edwa%d from the question. and M and F were known to stand for victoria and allJert: 
from the previous goal. 
The goal succeeds. because a matching fact Is found (fifth 
down from the top). 
Since It Is the last goal In the conjunction. the entire goal 
succeeds. and the fact sist:e~of(a1ice.edwa%d) Is established as true. 
answers ·yes·. 
Prolog 
Suppose we want to know If Alice Is the sister of anyone. 
The appropriate question 
In Prolog Is 
?- sister_of(alice,X). 
For this question. Prolog proceeds as follows: 
1. 
The question matches the head of the only sist:e~of rule. 
Variable X In the rule 
becomes Instantiated to a1ice. 
As variable X In the question Is unlnstantlated. then 
variable Y In the rule will also be unlnstantlated. 
However. these two variables now 
become ·shared·. As soon as one of the variables becomes Instantiated to an object. 
the other variable becomes instantiated to the same object. At the moment. of course. 
they are unlnstantlated. 
2. 
The first goal Is femal.e(alice), which succeeds as before. 
3. 
The 
second 
goal 
Is 
pa:cents( alice ,II. P). 
and 
It 
matches 
against 
pa:cents(alice.victoria.allJert:). 
Variables M and F are now known. 
4. 
As Y Is not yet known. the third goal Is parents(Y,victoria.allJert:), and It matches 
against parents(edwa%d,vict:oria.allJert:). 
Variable Y Is now known as edwa%d. 
5. 
Since all goals succeed. the entire rule succeeds. with X known as alice <given In 
the question). and Y as edwa%d. 
Since Y (In the rule) Is ·shared· with X (In the 
question). X (In the question) Is also Instantiated to edwa%d. 
Prolog prints ·X=edward·. 
As usual. Prolog walts for you to tell It If you want to find all the solutions to the question. 
As It turns out. this question has more than one solution. 
How Prolog finds the remaining 
solutionIs] Is set as an exercise at the end of this chapter. 
As we have seen thus far. there are two ways to give Prolog Information about a given 

18 
predicate such as likes. 
We can provide both facts and rules. 
In general. a predicate 
will be defined by a mixture of facts and rules. 
These are called the clauses for a predicate. 
We shall use the word clause whenever we refer to either a fact or a rule. 
As a further example. this time not dealing with monarchs. consider the rule: 
"A person may steal something if the person Is a thief and he likes the thing 
and the thing Is valuable." 
In Prolog. this Is written: 
may_steal(P,T) :- thief(P), likes(P,T), valuable(T). 
Here we are using the predicate may_steal, which has two variables P and T to represent 
·some person P may steal thing T" This rule depends on clauses for thief, likes, and 
valuable. 
These could be represented either as facts or rules, whatever is most appropriate. 
For example, consider the following Prolog database, which has been made up from clauses 
discussed earlier. 
We have added some line numbers enclosed between 
/~".~/ brackets. 
This Is how we write a comment In Prolog. 
Comments are Ignored by Prolog, but we may 
add them to our programs for convenience. 
In the discussion that follows, we will refer to 
the line number comments. 
/*1*/ 
/*2*/ 
/*3*/ 
/*4*/ 
/*5*/ 
thief( john). 
1ikes(mary,food). 
likes(mary,wine). 
likes(john,X) :- likes(X,wine). 
may_stea1(X, Y) :- thief(X), likes(X, Y). 
Notice that the definition of likes has three separate clauses: two facts, and a rule. 
To 
Prolog, there Is no real difference. 
The only thing is that when a search is made throught 
the database to satisfy a goal. then a rule will cause further searches to be made to satisfy 
its own subgoals. 
A fact does not have subgoals, so it succeeds or fails immediately. 
For 
example, let us follow what happens when the question 
"What may John steal?" 
is asked. 
First. this question translates into Prolog as: 
?- may_steal(john,X). 
To answer this question, Prolog searches as follows: 
1. 
First, PrOlog searches in the database for a clause about may_steal, and finds one 
In the form of a rule at line /~5~/. 
Prolog marks the place in the database. 
Since 
it Is a rule, Its goals must be satisfied to establish whether It is true. so the X In 
the rule Is Instantiated to john from the question. 
Again we find that we have to 

19 
match two un Instantiated variables ()( In the question and Y In the rule). so they will 
'share'. 
Go back to the the sisi:er....of(X, Y) examples If you are not sure what this 
means. 
The goals of a rule must succeed for the rule to succeed: the first goal. 
thief( john), Is now searched for. 
2. 
The goal succeeds. since t:h1ef( john) Is In the database Olne /'",'"n. 
Prolog marks 
the place in the database. and no variables have newly become Instantiated. 
Prolog 
then attempts to satisfy the second goal on line /'"5*/. 
Since X stili stands for john, 
Prolog now searches for likes( john, Y). 
Notice that Y Is stili Instantiated at this 
point. 
S. 
The goal 1il1:es(john,y) matches with the head of the rule In line /'"4'"/. 
The Y In 
the goal 'shares' with the X In the head. and both remain unlnstantlated. 
To satisfy 
this rule. 1il1:es(X,Wine) Is now searched for. 
4. 
The goal succeeds. because It matches with 1il1:es(mary,Wine), the fact on line /'"S'"/. 
So. X now stands for mary. 
5. 
Since the goal on line /*4*/ succeeds. the whole 
rule succeeds. 
The fact 
1il1:es( john,mary) Is established from line /*4*/ because Y In line /'"5'"/ shares with 
X; 
It Is also Instantiated to mary. 
6. 
Line /'"5*/ now succeeds. with Y Instantiated to mary. 
As Y was shared with the second 
argument of the original question. X In the question Is now Instantiated to mary. 
The reasoning behind establishing that John may steal Mary Is: 
In order to steal somethIng. fIrst John must be a thief. 
From line /"1 "/. this 
Is a fact. 
Next. John must like the thing. 
From line /"4"/. we see that John 
likes anything that likes wine. 
From line /"3"/. we see that Mary likes wine. 
Therefore. John likes Mary. 
Therefore. both conditions for stealing something 
can be satisfied. so John may steal Mary. 
Notice that the fact on line /'"2*/. that Mary likes food. Is Irrelevant to this particular question. 
because It was never needed. 
In this example we have repeatedly used the variables X and Y In different clauses. 
For example. In the may_stea1 rule. X stands for the object that can st.eal something. 
But 
In the 1il1:es rule. X stands for the object that Is liked. 
In order for this program to make 
sense. Prolog must be able to tell that X stands for two different things in different clauses. 
Remember that knowing the scope of a variable can resolve any confusion. 

20 
1.8 
Summary and Exercises 
At this point we have covered most of the basic core of Prolog. 
In particular. we have 
looked at 
a 
Asserting facts about objects. 
a 
Asking questions about the facts. 
a 
Using variables and what their scopes are. 
a 
The conjunction as a way of saying "and". 
a 
Representing relationships In the form of rules. 
a 
An Introduction to backtracking. 
With this small number of building blocks. It Is possible to write useful programs for 
manipulating simple databases. and It would probably be a good Idea if you did so by working 
out the exercises below. 
To see how to use this book. you should read the Preface If you have not already done 
so. 
Also. when you begin to write programs for a Prolog system that Is available to you. 
you should consult the appropriate Appendix to see what a sample programming session looks 
like. 
After you have this much of Prolog under your control. you should carry on Into the 
next chapter. which makes clear some of the points we did not mention In this chapter. 
Also. we will show how to work with numbers In Prolog. 
The features covered In the next 
few chapters are where the expressiveness and convenience of Prolog become apparent. 
ExerCise 1.2: 
When the sister_of rule Is applied to the database of part of Queen Vlctorla's 
family discussed previously. more than one answer can be obtained. 
Explain how all the 
answers can be obtained. and what they are. 
Exercise g 
This exercise has been Inspired by one on Robert Kowalski's book LogiC for 
Problem Solving, published by North Holland In 1979. 
Suppose someone has already written 
Prolog clauses that define the following relationships: 
father(X,Y) 
mother(X,Y) 
male(X) 
female(X) 
parent(X,Y) 
diff(X,Y) 
/* x is the father of Y */ 
/* X is the mother of Y */ 
/* X is male */ 
/* X is female */ 
/* X is a parent of Y */ 
/* X and Y are different */ 
The problem Is to write Prolog rules for the following relationships: 
is_mother( X) 
is_father(X) 
/* X is a mother */ 
/* X is a father */ 

21 
is_son(X) 
/* x is a son */ 
sister_oft X, Y) 
/* X is a sister of Y */ 
granpa....of(X,Y) 
/* X is a grandfather of Y */ 
sibling(X,Y) 
/* X is a sibling of Y */ 
For example. we could write a rule for aunt, provided we were supplied with (or wrote) rules 
for female, sibling, and parent. 
aunt(X, Y) :-
female(X), 
sibling( X, Z), 
parent(Z,Y). 
This could also be written: 
aunt{X,Y) :-
sister_of(X,Z), parent(Z,Y). 
provided that we wrote the sister_of rule. 
Exerclse.1.1;. 
Using the sister_of rule defined In the text. explain why It is possible for 
some object to be her own sister. 
How would you change the rule if you did not want this 
property? 
Assume that the predicate diff of Exercise 1.3 Is already defined. 

Chapter 2. A Closer Look 
In this chapter we provide a more complete discussion of the parts of Prolog that were 
Introduced In the previous chapter. 
Prolog provides tools for structuring data as well as 
structuring the order In which attempts are made to satisfy goals. 
Structuring data Involves 
knowing the syntax by which we can denote data. 
Structuring the order In which goals are 
solved Involves knowing about backtracking. 
2.1 
Syntax 
The syntax of a language describes how we are allowed to fit words together. In English. 
the syntax of the sentence "I see a zebra" is correct. but the syntax of "zebra see I a" is 
not correct. 
In the first chapter. we did not discuss the syntax of Prolog explicitly. but we 
simply showed what some parts of Prolog looked like. 
Here we will summarise the syntax 
of those parts of Prolog we have seen thus far. 
Prolog programs are built from terms. 
A term is either a constant, a variable, or a 
structure. 
We saw each of these terms in the previous chapter. but we did not know them 
by these names. 
Each term Is written as a sequence of characters. 
Characters are divided 
Into four categories as follows: 
ABCDEFGHIJKLMNOPQRSTUVWXYZ 
abcdefghijklmnopqrstuvwxyz 
012 3 456 7 8 9 
+ - * / \ ~ < ) = ' • : . ? @ # $ & 
The first row consists of upper-case letters. 
The second row consists of lower-case letters. 
The third row consists of digits. 
The fourth row consists of symbols. 
Each kind of term. 
whether it is a constant. variable. or structure. has different rules for how characters are 
strung together to form its name. 
Now we shall summarise each kind of term. 

23 
Constants 
Constants are thought of a naming specific objects or specific relationships. 
There are 
two kinds of constants: atoms, and integers. 
Examples of atoms are the names that were 
given In the last chapter: 
likes mary 
john book wine 
owns 
jewels ca.n..steal 
The special symbols that Prolog uses to denote questions (?-) and rules ( :-) are also atoms. 
There are two kinds of atoms: those made up of letters and digits. and those made up from 
symbols. 
The first kind must normally begin with a lower-case letter. as did all the ones 
we saw In the previous chapter. 
Those atoms made from symbols normally are made up 
from only symbols. 
Sometimes It may be necessary to havti an atom beginning with a capital 
letter or a digit. 
If an atom Is enclosed In single quotes ('). then the atom may have any 
characters In Its name. 
Finally. the special underline character C) may be Inserted In the 
middle of an atom to Improve legibility. 
The ,following are further examples of atoms: 
a 
void 
'geo7:ge-smith' 
--, 
george_smith 
ieh2304 
The following are not examples of atoms: 
2304ieh 
george-smith 
Void 
_alpha 
Integers, the other kind of constant. are used to represent numbers. so that arithmetic 
operations can be carried out. 
We have not discussed how to do arithmetic In Prolog. but 
this will be Introduced later In this chapter. 
Integers are whole numbers consisting only of 
digits and may not contain a decimal point. 
In this book. only fairly small positive integers 
will be used. for example: 
o 
1 
999 
512 
8192 
14765 
6224 
Prolog Is available on several different computers. and depending on what computer you use. 
you may not be able to use large numbers or negative numbers. 
However. In this book we 
will only give examples that will work on any Prolog you are likely to find. 
It Is safe to say 
that you will be allowed to use any Integer ranging from 0 to 16383. 
Depending on what 
computer you use. you may be allowed to use larger numbers or negative numbers. but we 
will not depend on them here. 
It Is perhaps surprising that the applications for which Prolog 

24 
Is useful tend not to demand the ability to calculate with very large Integers. fractions. or 
negative numbers. 
However. as Prolog Is an extensible language. the resourceful programmer 
can add predicates to define such features without too much difficulty. 
For example. some 
Prolog systems provide library programs that define operations on rational numbers and 
numbers of arbitrary precision. 
Variables 
The second kind of term used In Prolog Is the variable. Variables look like atoms. except 
they begin with a capital letter or an underline sign "_". 
A variable should be thought of 
as standing for some object that we may not be able to name. 
This corresponds to the 
use of a pronoun In English. 
In the example Prolog clauses we have seen so far. we have 
used variables with names like X. Y. and Z. 
However. the names can be as long as you 
like. for example: 
Answer 
Input 
GrossJay 
_3Jl1inQJnice 
Sometimes one needs to use a variable. but Its name will never be used. 
For example. If 
we want to find out If anyone likes John. but we do not need to know just who. we can use 
the anonymous variable. The anonymous variable Is a single underline character. Our example 
Is written In Prolog as: 
Several anonymous variables In the same clause need not be given consistent Interpretations. 
This Is a characteristic peculiar to the anonymous variable. 
It Is used to save having to 
dream up different variable names when they will not be used elsewhere In the clause. 
Structures 
The third kind of term with which Prolog programs are written is the 
structure. 
A 
structure is a single object which consists of a collection of other objects. called components. 
The components are grouped together Into a single structure for convenience In handling them. 
One example of a structure In real life is an index card for a library book. 
The Index 
card will contain several components: the author's name. the title of the book. the date when 
It was published. the location where It can be found In the library. and so forth. 
Some of 
the components can be broken down Into further components. For example. the author's name 
consists of some initials and a surname. 
Structures help to organise the data in a program because they permit a group of related 

25 
Information to be treated as a single object (a library card> Instead of as separate entities. 
The way that you decompose data into components depends on what problem you want to 
solve. and later on we will give advice on how to do this. 
Structures are also useful when there Is a common kind of object, of which many may 
exist. 
Books. for example. 
In Chapter 1 we discussed the fact 
owns(john,book). 
to denote that John owns some particular book. 
If we later said owns(mary,book), this means 
that Mary owns the same object that John owns. because It has the same name. 
There Is 
no other way of telling objects apart. except by their name. 
We could say: 
owns(john,wuthering_heights). 
owns ( mary, lOOby_di.ck). 
to specify more carefully what books John and Mary own. 
However. In large programs. It 
may become confusing to have many different constants with no context to tell what they mean. 
Someone reading this Prolog program may not know that 
we meant wutherin9-heights to 
be the name of the book written by the author Emily Bronte who flourished In Yorkshire. England 
during the 19th Century. 
Perhaps they will think that John has named his pet rabbit 
·wuthering_heights·. say. 
Structures can help to provide this context. 
A structure is written In Prolog by specifying Its functor, and its components. 
The 
components are enclosed In round brackets and separated by commas. 
The functor Is written 
just before the opening round bracket. 
Consider the following fact, that John owns the book 
called Wuthering Heights. by Emily Bronte: 
owns(john,book(wuthering_heights,bronte». 
Inside the owns fact we have a structure by the name of book, which has two components. 
a title and an author. 
Since the book structure appears inside the fact as one of the fact's 
arguments. it Is acting as an object. taking part in a relationship. 
If we like. we can also 
have another structure for the author's name. because there were three Bronte writers: 
owns(john,book(wutheri.ng_heights,author(emily,bronte»). 
Structures may participate in the process of question-answering using variables. 
For 
example. we may ask if John owns any book by the Bronte sisters: 
?- owns(john,book(X,author(Y,bronte»). 
If this is true. X will then be instantiated to the title that was found. and Y will be Instantiated 

26 
to the first name of the author. 
Or. we may not need to use the variables. so we can use 
anonymous ones: 
1- owns(john,book(_,author(_,bronte»). 
Remember that the anonymous variables do not "share" with each other. 
We could Improve the book structure by adding another argument Indicating which copy 
the book was. 
For example. a third argument. where we would Insert an Integer. would provide 
a way of uniquely Identifying a book: 
owns(john,book(ulysses,author(james,joyce),3129». 
or. 
John owns the 3,129th copy of Ulysses, by James Joyce. 
If you have guessed that the syntax for structures Is the same as for Prolog facts. you 
are correct. 
A predicate (used In facts and rules) Is actually the functor of a structure. 
The arguments of a fact or rule are actually the components of a structure. 
There are many 
advantages to representing Prolog programs themselves as structures. 
It Is not Important to 
know why just now. but do keep In mind that all parts of Prolog. even Prolog programs 
themselves. are made up of constants. variables. and structures. 
2.2 
Characters 
All of the constants that we have discussed In the previous sections were built up from 
strings of characters. 
Although each kind of constant (atom. Integer. variable) has special 
rules about what characters may make up Its name. It Is helpful to know what all the characters 
are that Prolog recognises. 
This Is because a character can be treated as an Item of data 
In Its own right. Now that we know about Integers. It Is appropriate to describe how characters 
are represented. 
It Is most common to use "Input" and "output" operations on characters; 
this will be discussed In Chapter 5. 
Prolog 
recognises 
two 
kinds 
of characters: 
printing 
characters 
and 
non-printing 
characters. 
Printing characters cause a mark to appear on your computer terminal's display. 
Non-printing characters do not cause a mark to appear. but cause an action to be carried 
out. 
Such actions Include printing a blank space. beginning new lines of text. and perhaps 
ringing a beJI. 
The following are all the printing characters that can be used: 
ABCDEFGHIJKLMNOPQRSTUVWXYZ 

27 
abc d e f 9 h i 
j kIm n 0 p q r stu v w x y z 
o 1 2 3 456 7 B 9 
"#$%&'() 
_ 
_ 
A 
I \ } ] { [ _ • @ + ; * : < > • 
• ? I 
You should recognise these as a more complete set than the one given at the beginning 
of this chapter. 
Some of the characters have special meanings. 
For example. the round 
brackets are used to enclose the components of a structure. 
However. we shall see In later 
chapters that all the characters may be treated as Information by Prolog programs. 
Characters 
may be printed. read from the keyboard. compared. and take part in arithmetic operations. 
Characters are actually treated as small integers between 0 and 127. 
Each character 
has an Integer associated with It. called Its ASCII code. 
The term "ASCII" means "American 
Standard Code for Information Interchange". and it is the code which is used by many 
computers and computer languages In the world. 
The ASCII code has several advantages. 
as can be seen by the chart In Appendix A. 
The letters are arranged in alphabetical order. 
so comparing alphabetic order of characters means simply comparing ASCII codes using the 
relational operators described later In this chapter. 
The printing characters all have ASCII 
codes that are greater than 32. 
Although the ASCII code may not seem useful at the moment. the next places we mention 
it are In Section 3.2 and 3.5. 
2.3 
Operators 
Sometimes It Is convenient to write some functors as operators. 
This Is a form of syntax 
that makes some structures easier to read. 
For example. arithmetic operations are commonly 
written as operators. 
When we write the arithmetic expression "x+y*z". we call the "piuS sign" 
and the "multiply sign" operators. 
If we had to write the arithmetic expression "x+y*z' In the 
normal way for structures. it would look like this: 
+(x,*(y.z». 
The operators are sometimes easier to use. however. because we have grown accustomed 
to using them in arithmetic expreSSions ever since our schooldays. 
Also. the structure form 
requires that round brackets be placed around the functor's arguments. which may seem 
awkward at times. 
First we need to know how to "read" arithmetic expressions that have operators In them. 
To do this. we need to know three things about each operator: Its position, Its precedence, 
and Its associativity. 
In this section we will describe how to use Prolog operators with these 
three things In mind. but we will not go into very much detail at this point. 
Although many 

28 
different kinds of operators can be made up. we will deal only with simple operators for addition. 
subtraction. multiplication. and division. 
The reason for doing this Is to make It possible to 
use Prolog rather like a simple pocket calculator. 
The syntax of operators is somewhat freer than that of functors. 
First. the syntax depends 
on the position of the operator. 
Operators like pius (+).mlnus (-). multiply (*). and divide 
(/) are written between their arguments. so we call them infix operators. 
It Is also possible 
to put operators before their arguments. as In "-x+y". where the minus sign before the x means 
"negative x". 
Operators that come before their arguments are called prefix operators. 
Finally. 
some operators may come after lhelr argument. 
For example. the factorial operator. used 
by mathematicians. comes after the number you want to find the factorial of. 
In mathematical 
notation. the factorial of x is written "xl". where the exclamation sign Is the factorial operator. 
Operators that are written after their. arguments are called postfix operators. 
So. the position 
of an operator tells where It Is written with relationship to its arguments. 
It turns out that 
the operators that we will use in the next section are all infix operators. 
Now precedence. 
When we see x+y*z. we know that we multiply y by z first. then add 
x. 
This Is because we were taught In school that mutipllcations and divisions are done before 
additions and subtractions. except where brackets are used for grouping. 
On the other hand. 
the structure form 
+( x, *( y, z ) ) 
makes explicit the rule that the multiplication Is done before the addition. 
This Is because 
the * structure Is an argument of the + structure. so if we actually wanted the computer to 
carry out the calculation. the * has to be carried out first In order for + to know what Its 
arguments are. 
So when using operators. we need rules that tell us the order In which 
operations are carried out. 
This Is what precedence tells us about. 
The precedence of an operator Is used to Indicate which operation Is carried out first. 
Each operator that is used in Prolog has a precedence class associated with it. 
The 
precedence class Is an integer which depends on the particular version of Prolog you are 
using. 
However. it is always true that an operator with a higher precedence has a precedence 
class which Is closer to 1. 
If precedence classes range from 1 to 255. then an operator 
in the first precedence class is carried out first. before operators belonging to the 129th (say) 
precedence class. 
In 
Prolog the multiplication and division operators are In a higher 
precedence class than addition and subtraction. so the expression "a-b/c' means "divide b 
by c first. then subtract the result from a". or. with round brackets. 'a-(b/c)". 
Similarly. the 
expression "x+y/b-c" means "(x+(y/b»-c". 
In the structure forms. these two expressions would 
have to appear as 
-(a,/(b,c» 

29 
and 
-( +(x,f(y,b»,c). 
so decide for yourself which you prefer. 
The exact association of operators to precedence 
classes is not important at the moment, but it is worth remembering the relative order in 
which operations are carried out. 
Finally, consider how different operators associate. 
How they associate comes to our 
attention when we have several operators of the same precedence. 
When we see the 
expression "8/2/2", does this mean "(812)/2" or "8/(2/2)"? 
In the first case, the answer Is 
2, and in the second case, 8. 
To be able to distinguish between these two cases, we must 
be able to tell whether an operator is 
left associative or right associative. 
A left associative 
operator must have the same or lower precedence operations on the left. and lower precedence 
operations on the right. 
For exampie, all the arithmetic operations (add. subtract, multiply. 
and divide) are left associative. 
This means that expressions like "8/4/4" are treated as 
"(814)/4". 
Also, "5+8/2/2" means "5+«812>12)". 
In practice, people tend to use round brackets for expressions that may be difficult to 
understand because of the precedence and associativity rules. 
In this book we will also try 
to make it as clear as possible by using lots of round brackets, but it is still important to 
know the syntax rules for operators so your understanding of operators is complete. 
Remember that a structure made up of arithmetic operators is like any other structure. 
No arithmetic is actually carried out until commanded by the 
'is' predicate described in 
Section 2.6. 
2.4 
Equality 
One noteworthy predicate is equality, which is an infix operator written as -
When an 
attempt is made to satisfy the goal X - Y (pronounced "X equals Y'), Prolog attempts to match 
X and Y. and the goai succeeds if it can do so. 
We can think of this act as trying to make 
X and Y equal. 
The equality predicate is built-in, which means that it is already defined 
in the Proiog system. 
The equality predicate works as though it were defined by the following 
fact: 
X = X. 
To see why this is, consider some clause containing some variable X, such as 
carnivore(X) ,- has_claws(X), eats(x,meat). 
Although the variable X occurs three times, if anyone of the occurrences becomes instantiated 

30 
to some object. then all of the X's will Instantly become Instantiated to the same object. 
Within the use of some clause. X always equals X. and the equality operator also can denote 
this by the fact X - X. 
Given a goal of the form X-Y, where X and Yare any two terms which are permitted 
to contain unlnstantlated variables. the rules for deciding whether X and Yare equal are as 
follows: 
o 
If X Is an unlnstantlated variable and If Y Is any object. then X and Yare equal. 
As a side-effect. X will be Instantiated to whatever Y Is. 
For example, the question 
1- rides( clergyman, bicycle) = X. 
succeeds, and X Is Instantiated to rides( clergyman, bicycle ). 
o 
Integers and atoms are always equal to themselves. 
For example, the following goals 
have the behaviour shown: 
policeman = policeman 
paper = pencil 
1066 
1066 
1206 = 1583 
/* succeeds */ 
/* fails */ 
/* succeeds */ 
/* fails */ 
o 
Two structures are equal If they have the same functor and number of arguments, 
and all the corresponding arguments are equal. 
For example, the following goal 
succeeds, and causes X to be Instantiated to bicycle, 
rides( clergyman, bicycle) = rides( clergyman, X) 
Structures can be "nested" one inside another to any depth. 
If such nested structures 
are tested for equality, the test may take more time to carry out, because there Is 
more structure to test. 
The following goal 
a(b,C,d(e,F,g(b,i,J») = a(B,c,d(E,f,g(H,i,j») 
would succeed. and cause B to be instantiated to b, C to C, E to e. F to f. H to 
h. and J to j. 
What happens when we attempt to make two unlnstantlated variables equal? 
This is just a 
special case of the first rule above. 
The goal succeeds, and the two variables share. 
If 
two variables share. then whenever one of them becomes instantiated to some term, the other 
one automatically Is instantiated to the same term. 
So. In the following rule, the second 

31 
argument will be Instantiated to whatever the first argument Is: 
do_nothing(X,Y) ,-
X=Y. 
Such a goal would always succeed If either argument Is unlnstantiated. 
An easier way to 
write such a rule is to take advantage of the fact that a variable equals Itself. and write: 
do_nothing(X,X). 
Prolog also provides a predicate '\=' called 'not equal'. 
The goal x \= Y succeeds If x 
= Y fails. and it falls If x = Y succeeds. 
So. x \= Y means "X cannot be made equal to 
yo. 
Exercise g 
Say whether the following goals would succeed. and which variables. If any. 
would be Instantiated to what values: 
pilots(A,london) = pilots(london,paris) 
point(X,Y,Z) = point(Xl,YI,Zl) 
letter(C) = word(letter) 
noun(alpha) = alpha 
'vicar' = vicar 
2.5 
Arithmetic 
Many people use computers to do operations on numbers. 
Arithmetic operations are 
useful for comparing numbers and for calculating results. 
In this section we will see examples 
of each kind. 
First. consider comparing numbers. Given two numbers. we can tell whether one number 
Is equal to the other, or less than the other, or greater than the other. 
Prolog provides certain 
"built-In" predicates, In the form of infix operators. for comparing numbers. 
The predicates 
'=' and' \=' as discussed In Section 2.4 can be used for comparing numbers. The arguments 
could be variables intantlated to integers. or they could be integers written as constants. 
In addition. the goal A < B succeeds If A Is less than B. and the goal A ) B succeeds If 
A Is greater than B. 
There are several other operators for comparing numbers, and we can 
summarise all of them here: 
X=Y 
(X and Y stand for the same number) 
X \= Y 
(X and Y stand for different numbers) 
X < Y 
(X is less than Y) 
X > Y 
(X is greater than Y) 
X =< Y 
(X is either less than or equal to Y) 
X >= Y 
(X is either greater than or equal to Y) 

32 
As these comparison operators are predicates, one might think it possible to write a 
Prolog fact as follows, 
2 > 3. 
in order to assert that 2 is actually greater than 3. A fact like this one is perfectly well-formed 
Prolog. 
However, Prolog will not allow further facts to be added to predicates that are "built 
in" to Prolog. This prevents you from changing the meaning of built-in predicates in unexpected 
ways. 
In Chapter 6 we shall describe all of the built-in predicates. including all those we 
have met thus far. 
As a first example of using numbers, suppose we have a database of the reigns of the 
Sovereign Princes of Wales in the 9th and 10th Centuries. 
true if the prince named X reigned from year Y to year Z. 
looks like this: 
reigns(rhodri,844,B7B). 
reigns(anarawd,87B,916). 
reigns(hywel-dda,916,950). 
reigns(1ago_~idwa1,950,979). 
reigns(hywel-ab_ieuaf,979,9B5). 
reigns(cadwa11on,9B5,9B6). 
reigns(maredudd,986,999). 
The predicate reigns(X,y,Z) Is 
The list of facts in the database 
Now suppose we want to ask who was on the Welsh throne during a particular year. 
We 
could define a rule, which given a name and a date, would search the database. and compare 
the given date aginst the dates of the reign. 
Let us define the predicate prince(x, Y), which 
is true if the prince named X was on the throne during year Y: 
·X was a prince during year Y If: 
X reigned between year8 A and B. and 
Y 18 between A and B. Inclu8Ive.· 
Now the first goal will be satisfied by using the reigns database above. 
The second goal 
is satisfied if Y is A. or B. or lies between them. 
You can test if Y lies between A and 
B by testing if Y >= A and if Y =( B. 
Translating all this into Prolog. we obtain: 
prince(X, Y) ,-
reignS( x, A, B ) , 
Y >= A, 
Y =< B. 
Here are some questions one might ask. with the answers that Prolog gives: 
1- prince(cadwa11on,9B6). 
yes 
1- prince(rhodri,1979). 

no 
1- prince{X,900). 
X=anarawd 
yes 
1- prince{X,979). 
X=lago_ab_idwal; 
X=hywe:Lab_ieuaf 
yes 
33 
Notice the use of variables in the latter examples. Make sure you know how Prolog's searching 
mechanism allows questions like these to be answered. 
Arithmetic can also be used for calculating. 
For example. If we know the population 
and ground area of a country, we can calculate the population density of the country. 
The 
population density tells us how crowded the country would be If all the people were evenly 
spread throughout the country. 
Consider the following database about the population and area 
of various countries In 1976. 
We will use the predicate pop to represent the relationship 
between a country and its population. 
Nowadays, the populations of countries are generally 
quite large numbers. 
Depending on what computer you use, Prolog may not be able to use 
such large numbers. 
So, we will represent population figures In millions: pop{X, Y) means 
the population of country X Is about "Y million" people. 
The predicate area will denote the 
relationship between a country and its area (in millions of square miles): 
pop{ usa, 203 ) . 
pop{india,548). 
pop{ china, 800) • 
pop{brazil,l08). 
area{usa,3). 
area{ india,l ). 
area{ china, 4) . 
area{brazil, 3). 
Now to find the population density of a country, we must use the rule that the density Is 
the population divided by the area. 
This can be represented as the predicate density{X, Y), 
where X Is a country and Y Is the population density of that country. 
A Prolog rule for this 
Is: 
density{X, Y) ,-
pop{X,P), 
area{X,A), 
Y is PIA. 
The rule Is read as follows: 
"The population density of country X is Y, if: 
The population of X Is P, and 
The area of X is A, and 
Y is calculated by dividing P by A. 

34 
This rule uses the divide operator (f). which was Introduced In the previous section. 
The 
divide operation Is actually 'Integer division'. which gives only the Integer part of the quotient 
of the result. If you need to know the remainder as well. the mod operator (meaning 'modulus') 
Is used. 
The expression A mod B gives. for Integers A and B. the remainder when A Is divided 
by B. 
The is operator Is new. 
The is operator Is an Infix operator. which takes an unknown 
variable on the left. and an arithmetic expression on the right. 
In the above example. Y Is 
unknown when the is Is encountered. and It Is up to the is to evaluate the expression. and 
let Y stand for the value. 
This means that the values of all the variables on the right of 
an is must be known. 
We need to use the is operator In order to tell Prolog to evaluate the arithmetic 
expression. 
Remember that something like 
PIA 
where P and A stand for Integers. Is Just an ordinary Prolog structure like 
author(emdly,bronte). 
With arithmetic expressions. there is a special operation that can be applied to the structure: 
that of actually carrying out the bits of arithmetic and calculating the result. 
This Is called 
evaluating the arithmetic expression. Clearly we cannot evaluate structures such as the author 
one. because author Is not defined here as an arithmetic operation. 
So. we have to tell 
Prolog when we want it to attempt to evaluate a structure. 
This is what the predicate • is' 
Is for. 
Getting back to the population density example. It Is not hard now to see that typical 
questions and their answers are: 
?- density(china,X). 
X=200 
?- density(turkey,X). 
no 
In the first question. the X=200 Is Prolog's answer. meaning 200 people per square mile. 
The second question failed. because the population of Turkey could not be found In the 
database. 
Depending on what computer you use. various arithmetic operators can be used on the 

right-hand side of the is operator. 
All Prolog systems. however. will have: 
X+y 
X-y 
x ,.. y 
X/Y 
x mod Y 
(the sum of X and Y) 
(the difference of X and Y) 
(the product of X and Y) 
(the quotient of X and Y) 
(the remainder of X divided by Y) 
35 
This list together with the above list of comparison operators should tell you nearly all you 
need for doing simple arithmetic problems. 
Of course. Prolog Is mainly Intended for 
non-numerical purposes. so arithmetic facilities are not as Important as In other computer 
languages. 
2.6 
Summary of Satl8fylng Goal8 
Prolog performs a task In response to a que8tion from the programmer (you). A question 
provides a con/unction of goal8 to be 8atl8fled. 
Prolog uses the known claU8es to satisfy 
the goals. 
A fact can cause a goal to be satisfied Immediately. whereas a rule can only 
reduce the task to that of satisfying a conjunction of subgoal8. 
However. a clause can only 
be used If It matche8 the goal under consideration. If a goal cannot be satisfied. backtracking 
will be Initiated. Backtracking consists of reviewing what has been done. attempting to re-satlsfy 
the goals by finding an alternative way to satisfying them. 
Furthermore. If you are not content 
with an answer to your question. you can Initiate backtracking yourself by typing a semicolon 
when Prolog Informs you of a solution. 
2.6.1 
Successful satisfaction Q! .!!. conjunction Q! goals 
Prolog attempts to satisfy the goals In a conjunction. whether they appear In a rule body 
or In a question. In order from left to right. 
This means that Prolog will not attempt to satisfy 
a goal until Its neighbour on the left has been satisfied. 
And. when It has been satisfied. 
Prolog will attempt to satisfy Its neighbour on the right. 
In the following example. we shall 
show the sequence of events that leads to the satisfaction of a sister.-of predicate. 
We 
shall not list the entire database that is used. but assume that Prolog finds certain facts and 
rules when It requires them. 
Consider the following rule: 
sister_of(X,y) :- female(X), parent(X,M,F), parent(Y,M,F). 
and the question 
?- sister_of(mary,john). 
Assume that Prolog uses the above rule. Now Prolog will need to satisfy the following sequence 

36 
of subgoals: 
female ( mary) 
parent(mary,M,F) 
parent(john,M,F) 
Let us look In detail at the second of these. 
Prolog will attempt to satisfy it when the first 
goal has been satisfied. 
Then. when the second goal is satisfied. Prolog will attempt to satisfy 
the third goal. 
We can illustrate this "flow of satisfaction" by means of an arrow: 
~male<'mary~arent(mary'M'F)~arent(jOhn'M'~ 
'\./ 
(goa~ becomes~tisfied) 
~ 
'--" 
Satisfying a goal involves searching the database for a matching clause. then marking the 
place In the database. and then attempting to satisfy any subgoais. 
Let us show the operation 
of marking a place in the database by the letter M. 
Let us also assume that PrOlog finds 
the rule: 
parent(C,M,F) ,- mother(C,M), father(C,F). 
Then we have: 
/ 
Assuming that the mother and father goals succeed because of clauses In the database. 
a more complete Illustration (with variable values written in) is: 
~ ~ ~ 
I 
female(mary) 
parent(mary, ann, fred) 
parent(john,ann, fred) 
\./ 
;.Lmary,=[ b:----
~ / 
~) ) 
(no subgoals) 
~o subgoals) 
V 
'-./ 
This shows the general pattern of how Prolog attempts to satisfy goals In a case where the 
conjunction of goals succeeds. Prolog attempts to satisfy a goal when the goal's left neighbour 
is finished. or. if it has no left neighbour. when the appropriate rule has been chosen and 
marked. 
A goal reports Its successful satisfaction to its right-hand neighbour. or. If It has 

37 
no right-hand neighbour. to the goal that caused the rule to be used. 
2.6.2 
Consideration Q! goals ill backtracking 
When a failure is generated (because all the alternative clauses for a goal have been tried. 
or because you type a semicolon). the "flow of satisfaction" passes back along the way it 
has come. 
When it comes to an 'M' (In our Illustrations). Prolog attempts to re-satlsfy the 
appropriate goal by finding an alternative clause. 
First. It makes uninstantiated all variables 
that had been instantiated in the course of satisfying the goal. 
Then. it searches on in the 
database from where the placemarker was put. 
If it finds another matching possibility. it marks 
the place. and things continue as in Section 2.6.1 above. 
Note that work on any goals to 
the "right" of this (even if such goals were tackled under the previous alternative) will always 
start from scratch. 
Prolog will try to satisfy. and not to re-satisfy them. 
If no other matching 
possiblity can be found. the goal falls. and Prolog works its way back until it comes to another 
·M·. 
In our example. if the goal parente john, ann, fred) failed. Prolog would first go back 
to the following (notice the resetting of the variable F): 
,,~ 
........... 
"" 
female(mary) 
parent(mary,ann,F) 
parente john,ann;F) 
'-./ 
(M~ 
~.... • •••••••••• 
( 
r 
" 
.... 
mother( mary, ann ) 
father( mary, F) 
(~V 
(~~ ...... : 
If this goal could not be re-satisfied. Prolog would go· back to: 
.' • eo 
" 
". 
parent(john,M;F) 
• eo 
• 
female(mary) 
~ 
parent(mary,M,F) 
) 
'., 
(M) 
••••••• 
( 
I' ". 
-.... e. 
mo\her(~: ~) 
• ~a,~~er( ::'F) 
(~M)" 
",' 
I '  
•••• 
" 
•
•• 
0 
. . 
... 
and so on. We can see from these examples the general pattern of how goals are reconsidered 
in backtracking. 
When a goal fails. it reports failure to its left neighbour. 
If it has no left 
neighbour. It reports to the goal that caused its rule to be used. 
2.6.3 
Matching 
The rules for deciding whether a goal matches the head of a use of a clause are as follows. 
Note that in the use of a clause. all variables are Initially unlnstantiated. 

38 
C 
An unlnstantlated variable will match any object. 
As a result. that object will be what 
the variable stands for. 
C 
Otherwise, an Integer or atom will match only Itself. 
c 
Otherwise, a structure will match another structure with the same functor and number 
of arguments, and all the corresponding arguments must match. 
A noteworthy case In matching Is one In which two unlnstantlated variables are matched 
together. 
In this case, we say that these variables share. 
Two sharing variables are such 
that as soon as one Is Instantiated, so Is the other (with the same value). 
If you have noticed a similarity between matching and making arguments equal (Section 
2.4), then you are correct. 
This Is because the -
predicate attempts to make Its arguments 
equal by matching them. 
Now we can bring together what we have discussed about operators, arithmetic, and 
matching. 
Suppose the following facts are In the database: 
sum(5). 
sum(3). 
sum(x+Y). 
Consider the question 
1- sum(2+3). 
Now. which one of the facts above will match with the question? 
If you think It Is the first 
one. then you should go back and read about structures and operators. 
In the question the 
argument of the sum structure 15 a structure having the plus sign as Its functor, and having 
the 2 and 3 as Its components. 
In fact. the goal shown will match with the third fact. 
Instantiating X to 2. and Y to 3. 
On the other hand, If we actually wanted to compute a sum, we would use the is operator. 
We would write 
1- X is 2+3. 
or, just for fun. we could define a predicate add that relates two Integers with their sum: 
add(X,Y,Z) 1- Z is X+Y. 
In this definition. X and Y must be Instantiated. and Z must be unlnstantlated. 

Chapter 3. Using Data Structures 
The Shorter Oxford English Dictionary defines the word "recursion" In the following way: 
RECURSION. [Now rare or obs. 1616]. 
A backward movement. return. 
This definition is cryptic and perhaps outdated. 
Recursion is now a very popular and powerful 
technique in the world of non-numerical programming. 
It is used In two ways. 
It can be 
used to describe structures that have other structures as components. 
It can also be used 
to describe programs that need to satisfy a copy of themselves before they themselves can 
succeed. Sometimes. beginners view recursion with some suspicion. because. how is It possible 
for some relationship to be defined in terms of itself? 
In Prolog. recursion is the normal 
and natural way of viewing data structures and programs. 
We hope that the theme of this 
chapter. recursion. will be made explicit In a comfortable and unobtrusive way. 
3. 1 
Structures and Trees 
It Is usually easier to understand the form of a complicated structure if we write it as 
a tree, In which each functor is a root. and the components are branches. 
Each branch 
points to another structure. so we can have structures within structures. 
It is customary to 
write a tree diagram with the root at the top. and the branches at the bottom. like this: 
parents(charles,elizabeth,philip) 
parents 
/ 
\ 
charles I 
\ 
\ 
elizabeth 
\ 

40 
a+b*c (or +(a,*(b,c» 
+ 
/ \ 
a 
* 
/ \ 
b 
c 
boOk(mOby_didk,author(herman,melville» 
book 
/\ 
/ 
\ 
moby_dick 
author 
/\ 
/ 
\ 
herman 
melville 
Notice that the last two structures have trees of the same shape. although the roots and 
branches are different. 
Before going further. you should make sure that you can write tree 
diagrams for each of the structures you have seen In the previous chapters. 
Suppose we are given the sentence 'John likes Mary'. and we need to represent the 
syntax of the sentence. 
A very simple syntax for English Is that a sentence consists of a 
noun followed by a verb phrase. 
Additionally. a verb phrase consists of a verb and another 
noun. 
This relationship between parts of a sentence can be described by a structure: 
sentence(noun.verb_phrase(verb.noun». which has a tree like this: 
sentence 
/\ 
/ 
\ 
noun 
verb-phrase 
/\ 
/ 
\ 
verb 
noun 
If we take our sentence ('John likes Mary'). and Insert the words of the sentence Into the 
arguments of the noun and verb functors In the structure. we obtain: 
sentence(noun(john),verb-Phrase(verb(likes),noun(mary») 
sentence 
/\ 
/ 
\ 
noun 
verb-phrase 
/ 
/\ 
/ 
/ 
\ 
john 
verb 
/ 
/ 
likes 
noun 
\ 
\ 
mary 
This shows how we can use Prolog structures to represent the syntax of a very simple English 

41 
sentence. 
In general. If we know the parts of speech of words In a sentence. It Is possible 
to write a Prolog structure that makes explicit the relationships between different words In 
a sentence. 
This Is an Interesting topic In Its own right. and later on we shall return to 
the question of how we can use Prolog to make the computer ·understand" some simple English 
sentences. 
3.2 
Liata 
The /1st Is. a very common data structure In non-numeric programming. 
The list Is an 
ordered sequence of elements that can have any length. 
Ordered means that the order of 
the elements In the sequence matters. 
any other terms. including other lists. 
The elements of a list may be atoms. structures. or 
These properties are helpful when we cannot predict 
In advance how big a list should be. and what Information It should contain. 
Furthermore. 
lists can represent practicaliy any kind of structure that one may wish to use In symbolic 
computation. 
Lists are widely used to represent parse trees. grammars. city maps. computer 
programs. and mathematical entities such as graphs. formulae. and functions. 
There Is a 
programming language called LISP. in which the only data structures available are the constant 
and the list. 
However. in Prolog. the list Is simply one particular kind of structure. 
Lists can be represented as a special kind of tree. 
A list Is either an empty /1st, having 
no elements. or It Is a structure that has two components: the head and tall. 
The end of 
a list Is customarily represented as a tall that Is set to the empty list. 
The empty list Is 
written as [], which Is an opening square bracket followed by a closing square bracket. 
The head and tall of a list are components of the functor named '.', which Is the dot. 
Thus. the list consisting of one element 'a' Is: 
(a, []) 
and Its tree looks like this: 
/ 
\ 
a 
[] 
Also. the list consisting of the atoms a. b. and c could be written 
.(a, .(b, .(c,[]») 
/ 
\ 
a 
/ 
\ 
b 
/ \ 
c 
[] 

42 
The dot functor happens to be defined as an operator. so It Is permissible to write the above 
two list expressions as a.[) and a.(b.(c.(]». The second one could be written as a.b.c.[) because 
the dot operator Is' right-associative. 
Lists are an ordered sequence. so the list a.b Is different 
from the list b.a. 
Some people like to write the tree diagram of a list with the tree "growing" from left 
to right. and with the "branches" hanging down. 
The above list looks like this In a vine 
diagram: 
.--.-.---[] 
I 
I 
I 
abc 
In this vine diagram. the head component of the dot functor hangs down. and the tall component 
grows to the right. 
The end of the list Is clearly marked by the last tail component being 
the empty list. 
The main advantage of the vine diagram for lists Is that It can be written 
rlght-to-Ieft on a piece of paper. 
The vine diagram may be suitable for writing lists on paper when we need to see the 
structure of a list. but such diagrams are not used for writing lists Into a Prolog program. 
As the dot notation is often awkward for writing complicated lists. there Is another syntax that 
can be used for writing lists In a Prolog program. 
This list notation consists of the elements 
of the list separated by commas. and the whole list Is enclosed In square brackets. 
For 
example. the above lists can be written In the list notation as [a] and [a.b.c]. 
It Is useful 
for lists to contain other lists and variables. 
For example. the following lists are legal In 
Prolog: 
[ ] 
[a,b,c,[d,e,f],g] 
[a, Vl,b, [X, Y]] 
Variables within lists are treated the same as variables In any other structure. 
They can 
become instantiated at any time. so judicious use of variables can provide a way to put 'holes' 
in lists' that can be filled with data at a later time. 
To show the structure of lists within lists. the vine diagram for the previous list Is: 
.--.-.---.-[] 
I 
I 
I 
I 
a 
Vl 
b 
.--.-[] 
I 
I 
X 
Y 
It Is easy to see by this diagram that each horizontal "level" of the vine Is a list having a 
certain number of elements. 
The top level Is a list having four elements. one of which Is 

43 
a list. 
The second level. having two elements. Is the fourth element of the top level list. 
Lists are manipulated by splitting them up Into a head and a tail. 
The head of a list 
Is the first argument of the '.' functor that Is used to construct lists. 
Notice that we speak 
of the "head" of a rule as well as the "head" of a list. 
These two things are different. and 
although they are both called "heads" by historical accident. It Is easy enough to understand 
which "head" one Is talking about at a particular time. The tall of a list is the second argument 
of the "." functor. 
When a list appears In the square bracket notation. the head of the list 
Is the first element of the list. 
The tall of the list Is a lIat that consists of every element 
except the first. 
The following ·examples show some heads and tails: 
list 
head 
tail 
[a,b,c,d] 
a 
[b,c,d] 
[a] 
a 
[] 
[] 
(fails) 
( fails) 
[[the,cat] ,sat] 
[the,cat] 
[sat] 
[the,cat] 
the 
[cat] 
[the, [cat, sat]] 
the 
[[cat, sat] ] 
[the, [cat, sat] ,down] 
the 
[[cat, sat] ,down] 
[X+Y,x+y] 
X+Y 
[x+y] 
Notice that the empty list has neither a head nor a tail. 
In the last example. the "+" operator 
Is used as a functor for the structures +(X, Y) and +(x,y). 
Because a common operation with lists Is to split a list Into Its head and tail. there 
Is a special notation In Prolog to represent "the list with head X and tail Y·. 
This Is written 
[XIY], where the symbol separating the X and Y Is the vertical bar. 
A pattern of this form 
will Instantiate X to the head of a list. and Y to the tali of the list. as In the following example: 
p([1,2,3]). 
p([the,cat,sat,[on,the,mat]]). 
1- p( [XIY]). 
X=1 
Y"[2,3] 
X=the Y-[cat, sat, [on,the,mat]] 
X=[the,mat] 
More examples of the list syntax. showing how various lists match. ar~ as follows: 

44 
[X,y,Z] 
[cat] 
[X,YIZ] 
[[the,Y] IZ] 
[X,YIZ,W] 
[golden IT] 
[vale, horse] 
[whiteIQ] 
(matches with) 
[john, likes, fish] 
[XIY] 
[mary, likes, wine] 
(instantiating variables) 
x = john 
Y = likes 
Z = fi.sh 
x = cat 
Y = [] 
x = mary 
Y 
likes 
Z = [wine] 
[[X,hare],[is here]] 
x = the 
Y = hare 
(is incorrect syntax) 
[golden,norfol.k] 
[horse,X] 
[Plhorse] 
Z = [[ is,here]] 
T = [norfol.k] 
(fails) 
P = white 
Q = horse 
As the last example shows, lists do not always have to end in the empty list. 
The list 
[whitelhorse] denotes a list that has head 'white' and tail 'horse', 
There is one final use for list syntax -- representing strings. 
Occasionally one needs 
strings of characters for printing or reading text such as English sentences. 
If a string of 
characters is enclosed in double quotes, the string is represented as a list of integer codes 
that represent the characters. 
The codes are taken from what is known as the "ASCII code", 
which is given in the Appendix. 
For example, the string 
"system-
is changed by Prolog into the list 
[115,121,115,116,101,109]. 
3.3 Membership of a list 
Suppose we have some list, where X stands for its head, and Y stands for its tail. 
Recall that we may write this list as [X1Yl. 
The list might contain, for example, names of 
those horses sired by Coriander who all won horseraces in Great Britian in the year 1927: 
[currag~tip, music_star, park_mill, portland]. 

45 
Now suppose we want to find out if a given horse is In the list. 
The way we do this In 
Prolog Is to find out whether the horse Is the same as the head of the list: 
If It Is. we 
succeed. 
If It Is not. then we check to see If the horse is In the tail of the list. 
This means 
checking the head of the tail next time. 
And the head of that tail after that. 
If we come 
to the end of the list. which will be the empty list. we must fail: the horse is not in the 
list. 
To write this in Prolog. we must first recognise that there Is a relationship between an 
object. and a list it might appear In. 
This relationship. called membership. is a common 
enough concept In our everyday lives. 
We talk about people being members of clubs. and 
so forth. 
We shall write a predicate member(X,Y) which Is true If the object that X stands 
for is a member of the list that Y stands for. 
There are two conditions to check. 
First. 
it is a fact that X will be a member of Y. if X Is the same as the head of Y. 
In Prolog. 
this fact Is: 
member(X, [XI_l). 
or 
"X is a member of the list if X is the same as the head of the list" 
Notice that we use the anonymous variable ._. to stand for the tail of the list. This Is because 
we do not use the tall for anything In this particular fact. 
Notice that this rule also could 
have been written as: 
member(X,[YI_l) :- X = Y. 
By this time you should understand why we can take a shortcut by using X In two places 
In the shorter version of the rule. 
The second. and last. rule says that X Is a member of a list providing it is in the tail. 
Y. of that list. 
And. what better way to find out If X Is in the tail of the list. than to use 
member Itselfl 
This is the essence of recursion. 
In Prolog: 
member(X,[_IY]) :- member(X,Y). 
or 
"X Is a member of the list if X is a member of the tail of the list" 
Notice that we have used the anonymous variable '_'. because we do not care to have any 
variable standing for the head of the list. 
The two rules together define the membership 
predicate. and tell Prolog how to search a list from beginning to end. looking for an Item 
In the list. 
The most important point to remember. when encountering a recursively defined 

46 
predicate, Is to look for the boundary conditions and the recursive case. 
There are actually 
two boundary conditions for the member predicate, 
Either the object we are looking for Is 
In the list, or It Isn't In the list. 
The first boundary condition of member Is recognised by 
the first clause. which will cause the search though the list to be stopped If the first argument 
of member matches the head of the second argument. 
The second boundary condition occurs 
when the the second argument of member Is the empty list. 
How are we assured that the 
boundary conditions will ever be satisfied? 
We must look at the recursive case, the second 
rule of member. 
Notice that each time member attempts to satisfy Itself. the goal Is given 
a shorter list. 'The tall of a list is always a shorter list than the original one. 
Eventually, 
one of two things will happen: either the first member rule will match. or member will be given 
a list of length O. the empty list. as its second argument. When either of these things happens, 
the ·recurrence· of member goals will come to an end. 
The first boundary condition Is 
recognised by a fact. which does not cause any further subgoals to be considered. The second 
boundary condition Is not recognised by any member rule. so member will fall. 
In Prolog: 
lDember(X, [XI_). 
member(X,[_IY) 
:- member(X,Y). 
?- member(d,[a,b,c,d,e,f,g). 
yes 
?- member(2,[3,a,4,f). 
no 
Suppose we asked the question 
?- member(clygate,[curraghLtip,music_star,par~ll,portland). 
The second member rule would matCh. as clygate does not match curragh_tip. 
Variable Y 
becomes instantiated to [music_star, park_mill. portland], and the next goal is to see If clygate 
Is a member of that. 
The second rule matches again, and the tall Is taken again. 
The 
goal becomes member( clygate, [par~ll,portland] ). 
This process recurs until we reach 
the goal where X is clygate and Y Is [portland]. 
The second rule matches once more, and 
now Y becomes the tall of [portland], which is the empty list, and the next goal becomes 
member( clygate, [) ). No rule in the database matches this, so the goal falls, and the question 
is false. 
It is most Important to remember that each time that member uses Its second clause 
to attempt to satisfy member, Prolog treats each recurrence of the member goal as a different 
·copy·. This prevents the variables in one use of a clause from being confused with variables 
in another use of a clause. 

47 
As the membership predicate Is so useful. we shall use It In many places In the remainder 
of this book. 
The member predicate Is also Important because It Is one of the smallest useful 
examples of a predicate that Is recur81ve -- that Is. the definition of member contains goals 
that can only be satisfied by member Itself. 
Recursive definitions are frequently found In Prolog 
programs. and they are no different than any other type of definition. 
However. you must 
be careful that you do not write "circular" definitions. for example: 
parent(X,Y) :- child(Y,X). 
child(A,B) :- parent(B,A). 
In this example. to satisfy parent, we set up child as a goal. 
However. the definition for 
child uses only parent as a goal. 
You should be able to see that asking a question about 
parent or child would lead to an endless loop In which Prolog would never Infer anything 
new. and that the loop would never terminate. 
One Important problem to look out for In recursive definitions Is that of left recur810n. 
This arises when a rule causes the invocation of a goal that is essentially equivant to the 
original goal that caused the rule to be used. 
Thus If we defined: 
person(x) :- person(Y), mother(X,Y). 
person( adam) • 
and asked 
?- person(X)., 
Prolog would first use the rule. and generate the subgoal person(Y). 
In trying to satisfy 
this. It would again pick the rule first. and generate yet another equivalent goal. 
And so 
it would go on and on. until it ran out of space. 
Of course. if it had a chance to backtrack. 
It would find the fact about Adam and start producing solutions. 
The trouble Is. that In order 
to backtrack. Prolog has to have failed after trying the first possibility. 
In this case. the task 
that it finds is infinitely long. and so It never gets a chance to succeed or fall. 
So the 
moral Is: 
Don't a88ume that, IU8t becau8e you have provided all the relevant fact8 and 
rule8, Prolog will alwaY8 find them. 
You mU8t bear In mind when you write 
Prolog program8 how Prolog 8earche8 through the databa8e and what varlable8 
will be In8tantiated when one of your rule8 18 u8ed. 
In this example. the simple solution is just to put the fact before the rule. instead of after 
It. In fact. as a general heuristic. it is a good idea to put facts before rules whenever possible. 
Sometimes putting the rules In a particular order will work if they are used to solve goals 
of one form but will not if goals of another form are generated. Consider the following definition 
of islist(X), in which the predicate islist succeeds if X is a list ending in the empty list: 
islist( [AlB]) :- islist(B). 

48 
iSlist([]). 
If we use these rules to answer questions like: 
1- islist([a,b,c,d]). 
1- islist([]). 
1- islist(f(l,2,3». 
then the definition will work fine. 
But when we ask: 
?- iSlist(X). 
the program will loop. 
A better definition of iBlist that Is not susceptable to loops Is provided by the following 
two facts: 
iSlist([]). 
islist( [_1_]). 
3.4 
Example: 
Changing a Sentence Into another 
Let us consider a Prolog program In which we type an English sentence and Prolog 
replies with another sentence that Is an altered version of the one we typed In. 
This program 
for "talking back" to the programmer might produce a dialogue like this: 
You. 
Prolog: 
You. 
Prolog: 
you are a computer 
i am not a computer 
do you speak french 
no i speak german 
Although this dialogue may seem like a forced but sensible conversation. It Is very easy to 
write a computer program to carry out Its "part" of the dialogue simply by following these 
steps: 
1. 
Accept a sentence that Is typed In by the programmer. 
2. 
If there are any 'you"s In the sentence. change them. to "I"s. 
3. 
Likewise. change any "are"s to "am not"s. 
4. 
Change "french" to "german" 
5. 
Change "do" to "no". 

49 
When applied to carefully chosen sentences. such as those In the above dialogue. this scheme 
will produce a sensible altered sentence. 
However. It does not work on every sentence. for 
example: 
You: 
Prolog: 
i do like you 
i no like i 
Once a simple program Is written. It can be modified later to cope with sentences like this 
that produce awkward output. 
A Prolog program to change one sentence Into another can be written as follows. 
First. 
we need to recognise that there Is a relationship between the original sentence and the altered 
sentence. 
So. we need to define a Prolog predicate. called alter, such that alter(X,Y) 
means that sentence X can be altered to give sentence Y. 
It Is convenient for X and Y to 
be lists. with 
atoms standing for the words. so sentences can 
be written 
like this: 
[this,is,a,sentence]. 
Once alter Is defined. we could ask Prolog a question of the form 
1- altere [do,you,know, french] ,X). 
and Prolog would reply 
X=[no,i,know,german]. 
Don't be concerned yet that the Input and output sentences are not tidy. and do not look 
like normal sentences. 
In later chapters we will discuss ways of typing In and printing out 
structures In a way that Is easy to read. 
For the moment we will only worry about changing 
one list Into another. 
Since alter deals with lists. the first fact about alter needs to deal with what happens 
if the list Is empty. 
In this case. we will say that an empty list is altered into an empty 
list: 
alter( [], []). 
Or. in words. "It Is a fact that altering the empty list gives the empty list." If the reason for 
treating the empty list Is not apparent now. It should be clearer later. 
Next. we need to recognise that the main job of alter Is to: 
1. 
Change the head of the Input list Into another word. and let the head of the output 
list stand for that word. 
2. 
"alter" the tall of the Input list. and let the tall of the output list stand for the altered 

50 
tall. 
S. 
If we have reached the end of the Input list. then there Is nothing more to go onto 
the output list. so we can terminate the output list with an empty list ([]). 
Translated Into words that are closer to Prolog: 
"altering a list with head H and tall T gives a list with head 
X and tall Y If: 
changing word H gives word X. and 
altering the list T gives the list yo. 
Now we need to say what Is meant by "changing" one word Into another. 
This can be done 
by having a database of facts In which change( x, Y) means word X can be changed Into word 
Y. 
At the end of the database we need a "catchall" fact. because If a word Is not changed 
Into another word It needs to be changed Into Itself. 
If the reason for a "catchall" Is not 
apparent now. It should be clearer after we explain how the program works. 
The relevant 
fact Is change(X,X), which means word X Is changed Into Itself. 
A database to handle the 
changes listed above Is: 
change( you, i). 
change( are, [am, not]). 
change(french,german). 
change( do, no ) . 
change(X,x). 
/* this is the "catchall" */ 
Notice that we have treated the phrase "am not" as a list. so that It occupies only one argument 
of the fact. 
Now we can translate the pseudo-Prolog text above Into pure Prolog. remembering the 
notation [AIBl for "the list with head A and tall BO. 
We get something like this: 
alter( [ ], [ ] ) • 
alter([HIT],[XIY]) :-
change(H,X), 
alter(T,Y). 
The first rule In this procedure checks for an empty list. 
The same rule also checks for 
the end of the list as well. 
Why? 
Consider this worked example: 
1- alter([you,are,a,computer],Z). 
This question would match with the main alter rule. making variable H stand for 'you'. and 
variable T stand for [are,a,computer]. 
Next. the goal change(you,x) would succeed. setting 
X to stand for the word 'I'. 
As X Is the head of the output list (In the goal of 
alter), 

51 
the first word In the output list Is 'I'. 
Next. the goal al.ter( [are,a,computer],Y) would use 
the same rule. 
The word 'are' Is changed Into the list [am,not] by the database, and another 
a1ter goal Is generated -- a1ter( [a,computer],Y). 
The fact change(a,x) is searched for. 
but as there Is no change fact with 'a' as Its first argument. the catchall fact at the bottom 
of the database succeeds. changing 'a' Into 'a'. 
The a1ter rule Is called for once again, 
with 'computer' as the head of the input list. and the empty list as the tail of the input list. 
As previously. change( computer, X) matches against the catchall. 
Finally. a1ter Is called with 
the empty list: which matches against the very first al.ter rule. 
The result Is the empty list. 
which ends the sentence (remember that 
a list ends with an empty tall). 
Finally, Prolog 
answers the question by responding 
Z=[i,[am,not],a,computer] 
Notice that the phrase [am.not) appears In the list exactly as It was Inserted. 
The reasons for adding the fact al.ter( [], []) and the catchall fact change(X,x) should 
now be clear. 
These facts are often Included In a program when it Is desirable to check 
for boundary conditions. 
It should be clear from the explanation above that boundary conditions 
occur when the Input list becomes the empty list. and when all of the change facts have been 
searched through. 
In both of these boundary conditions. we wish certain actions to be 
performed. 
When the input list becomes the empty list. we wish to terminate the output list 
(by putting an empty list at Its end). 
When all the change facts have been searched though 
without the given word being changed into another word. we wish to keep the word unchanged 
(by changing it Into Itself). 
3.5 
Example; 
Comparing Alphabetic Order 
As we saw in Chapter 2. there are predicates provided to compare Integers. to see If. 
say. one Integer is greater than another. 
In applications dealing with words. such as using 
dictionaries. It is helpful to have a predicate to compare words for alphabetic order. Depending 
on which computer you are using. the built-In operators for comparing Integers also compare 
the alphabetic order of atoms. 
However. In case the version of Prolog you are using does 
not. and also for tutorial reasons. we shall write a predicate that compares alphabetic order 
of atoms. 
Consider a predicate we shall name aless. 
When a1ess(X, Y) Is' used as a goal. It 
will succeed If X and Y stand for atoms. and X is alphabetically less than Y. 
So. 
a1ess(avocado, c1ergyman) would succeed. and a1ess(windmi11, motorcar) would fail. 
Also. 
a1ess(picture,picture) should 
fail. 
When 
comparing 
two 
words. 
we 
compare 
them 
letter-by-Ietter and. for each comparison. determine which of the fallowing conditions Is at 

52 
hand: 
(1) 
We could reach the end of the first word without reaching the end of the second 
word. 
This happens when we try aless(book, bookbinder). 
In this case. 
a1ess 
must succeed. 
(2) 
We could find that the character In the first word was alphabetically less than the 
corresponding 
character 
In 
the 
second 
word. 
For 
example, 
with 
aless(el.ephant:,pencil), The 'e' of elephant Is alphabetically less than the 'P' of 
pencil. 
In this case. al.ess succeeds. 
(3) 
We could find that the character In the first word was alphabetically equal to the 
corresponding character In the second word. 
In this case. we need to try a1ess on 
the remaining characters In both words. 
For example. given aless( l.azy, l.eat:her), 
the 'I' Is the same at the beginning of both arguments. so we would need to try 
al.ess(azy,eat:her). 
(4) 
We could find that we reach the end of the first and second words at the same time. 
This would happen If we tried aless(appl.e,appl.e). 
In this case, al.ess must fall, 
because the two words are the same. 
(5) 
We could run out of characters In the second word before running out of characters 
In the first word. such as In al.ess( alphabet:ic,al.p). 
In this case, aless must fall. 
Once we have discovered the above conditions, It Is a fairly simple task to translate 
them Into Prolog. 
We shall represent words as lists of characters (small Integers), so there 
must be a way to convert a PrOlog atom Into a list of characters. 
This Is the purpose of 
the bUilt-In predicate 
name. 
The goal name(x, Y) succeeds when the atom Instantiated for 
X consists of the list of character codes (the ASCII codes) Instantiated for Y. 
Refer to Chapter 
2 for an explanation of ASCII codes. 
If one of the arguments is unlnstantlated, then Prolog 
will attempt to Instantiate it by creating the appropriate structure. 
So. we can use 
name 
to convert from words Into the list of characters. 
For example. knowing that the ASCII code 
for 'a' Is 97. 'I' Is 108 and 'p' Is 112, the fOllowing questions could be asked of n~1 
1- name(X,[97,l.08,1.1.2]), 
x = al.p 
1- name(al.p,X). 
x -
[97,1.0e,1.1.2] 

53 
A first attempt at aless Is 
aless(X,Y) :- name(X,L), name(Y,M), alessx(L,M). 
we have simply converted the words Into lists using name, and used a predicate (not defined 
yet> for checking the lists for alphabetic order. 
Now we need to define al.essx, using the 
set of conditions above. 
The first condition is true when the first argument is the empty 
list. and the second argument is any non-empty list: 
alessx([],[_I_])· 
The second condition is translated as: 
alessx([XI_],[YI_]) :- X < Y. 
Remember that the arguments of alessx are lists of numbers. so it is permitted to compare 
them using the "(" functor. 
The third condition Is translated as: 
alessx([AIX],[BIY]) :-
A = B, alessx(X,Y). 
Finally. the last two conditions are what make the predicate fail. so if we do not supply any 
matching facts or rules. then the searching mechanism will fail any goal for which those 
conditions hold. 
Gathering the rules together. 
aless(X,Y) :- name(X,L), name(Y,M), alessx(L,M). 
alessx([],[_I_])· 
alessx([XI_],[YI_]) 
alessx([PIQ],[RIS]) 
x < Y. 
P = R, alessx(Q,S). 
Notice that the third rule could be written more conveniently as: 
alessx( [HIX], [HIY]) :-
alessx(X,Y). 
In the above examples. some variables are renamed simply to emphasise that the names do 
not matter except within the scope of the same rule. 
Exercise g 
Work out what clause you need to add to this definition so that it succeeds 
when the two words are equal. 
This would create a predicate that checks If the first argument 
Is alphabetically less than. or equal to the second argument. 
Hint: look at condition (4) above. 
and insert a clause to handle It. 
Exercise 3.2: 
Why does the first rule of alessx have [_I_]? 
Why is Ll insuffiCient for the 

54 
purpose? 
3.6 
Example; 
A Pam Inventory 
Suppose we work In a bicycle factory. where It Is necessary to keep an Inventory of 
bicycle parts. 
If we want to build a bicycle. we need to know how many parts to draw from 
the supplies. 
Each part of the bicycle may have sub-parts. for example each wheel has some 
spokes. a rim. and a hub. 
Furthermore. the hub can consist of an axle and gears. 
Let 
us consider a tree-structured database that will enable us to ask questions about how many 
of each part Is required to build a part of a bicycle. 
Later. we shall see that the same 
data structures and programs enable us to manipulate not only parts of bicycles. but parts 
of sentences as weill 
There are two kinds of parts that we use to build our bicycle. 
These are assemblies 
and basic parts. 
Each assembly consists of a quantity of basic parts. such as the wheel 
consisting of several spokes. a rim. and a hub. 
Basic parts are not made up of any smaller 
parts -- they simply combine with other basic parts to form assemblies. 
We can represent basic parts simply as facts. as follows: 
basicpart( rim) . 
basicpart(rearframe). 
basicpart(gears). 
basicpart( nut) . 
basicpart( spoke). 
basicpart(handles). 
basicpart(bolt) . 
basicpart( fork) • 
Naturally. this is not a complete list of the basic parts required for a bicycle. but It shOWS 
the general Idea. Next. an assembly can be represented as the name of the assembly followed 
by a list of the basic parts. and the quantity of parts required. 
For example. the following 
fact represents that a "bike" Is an assembly made up of two wheels and a frame: 
assembly(bike,[quant(wheel,2), quant(frame,1)]). 
The quant structure Is used to associate a part with how many of the parts are required. 
The database of assemblies required for our simplified bicycle Is: 
assembly(bike, [quant(wheel,2), quant(frame,1)]). 
assembly(wheel, [quant(spoke,20), quant(rim,l), quant(hub,1)]). 
assembly( frame, [quant( rear frame ,1), quant( front frame ,,1)] ) . 
assembly(frontframe,[quant(fork,1),quant(handles,1)]). 
assembly(hub,[quant(gearS,1),quant(axle,1)]). 
assembly(axle,[quant(bolt,1),quant(nut,2)]). 
Notice that this particular set of clauses does not perfectly describe a bicycle. 
We have not 
distinguished between the front hub and the rear hub -- both have gearsl 
The chain and 
pedals are missing. and there Is no place for the rider to sit. 
Also. there Is no Indication 

55 
of how to fit the parts together. 
This simply lists a few of the parts required, and the number 
of each. 
Now we are ready to write the program that, given a part, will list all the basic parts 
required to construct It. 
If the part we want to construct Is a basic part, then nothing more 
Is required. 
However, If we want to construct an assembly, then we need to apply the same 
process to each part making up the assembly. 
Let us define a predicate partsof(X, Y), where 
X Is the name of a part and Y Is the list of basic parts that are required to construct X, 
In our first version of this program, we shall Ignore how many of each kind of part are required 
to form assemblies. 
A better program will be presented In Chapter 7. 
The boundary condition occurs when X Is a basic part, 
In this case, we simply return 
X In a list: 
partsof(X,[X) 
:- basicpart(X). 
The next condition is if X Is an assembly. 
In this case, we need to find out If there Is a 
matching assembl.y fact In the database, and If so, to use partsof on each member of the 
list of sub-parts. 
We shall use a predicate called partsofl.ist to handle this second task. 
partsof(X,P) :-
assembl.y( x, subparts), 
partsofl.ist(Subparts,P). 
Now partsofl.ist takes a list of quant structures (see the assembl.y database above), and 
finds the partsof of the first component of the quant structure. 
The second component of 
quant, the actual quantity of parts required, will be Ignored for now. 
After calling Itself to 
get the partsof for the tall of the list, partsofl.ist must glue the lists together with append 
(described below): 
partsofl.ist([quant(X,N) I Tail.) , Total.) 
:-
partsof(X,Headparts), 
partsofl.ist(Tail.,Tail.parts), 
append(Headparts,Tail.parts,Total.). 
Notice that N, the number of parts required, Is not used. It could be replaced by an anonymous 
variable. 
The list processing predicate append Is used to join two lists together to form another, 
new, list. 
For example, It is true that 
append([a,b,c),[3,2,l.],[a,b,c,3,2,l.). 
It is defined as follows: 
append( [] ,L,L). 

56 
append([XILl],L2,[XIL3]) ,- append(L1,L2,L3). 
The boundary condition Is when the first list Is the empty list. 
In this case. any list appended 
to the empty list Is the same list. 
Otherwise. the following points show the principles of the 
second rule: 
1. 
The first element of the first list (X) will always be the first element of the third list. 
2. 
The tall of the first list (L 1) will always have the second argument (L2) appended 
to It to form the tall (LS) of the third argument. 
S. 
You actually have to use append to do the appending mentioned In point (21. 
4. 
As we are continually taking the head from the remainder of the first argument. It 
will gradually be reduced to the empty list. so the boundary condition will occur. 
We will refer to append In later examples. so It Is worth getting to know It now. 
In 
later chapters we will discuss various properties of the append predicate. 
The list which Is constructed by partsof will not contain Information about how many 
parts are required. and 
duplicate parts may appear In the list. In Chapter 7. we shall present 
an Improved version of this program that handles these deficiencies. 
There are two Insights that Indicate how partsof can be used to generate English 
sentences. 
First. sentences can be decomposed Into hierarchical structures: a sentence has 
parts noun_phrase and verb_phrase. a noun_phrase has parts determiner and noun. and so 
forth. 
So. any simple grammar can be expressed In terms of ·parts·. 
Second. partsof1ist 
always looks at the elements of Its first argument from left to right. and Its result Is appended 
together In left-to-rlght order. 
These two properties of partsof show that we can use the 
same framework to generate sentences from a grammar. 
We can continue to use the quant 
structure. but remember Its second argument does not mean anything. 
A typical ·assembly· 
for a grammar might look like this: 
assemb1y(sentence,[quant(noun-phrase,_), quant(verb-phrase,_)]). 
assemb1y(noun-phrase, [quant(determiner,_), quant(noun,_)]). 
assembly(determiner, [quant(the,_)]). 
assembly(noun, [quant(clergyman,_)]). 
assembly(noun, [quant(motorcar,_)]). 
And the words In the lexicon would be defined as basic parts: 
basicpart:( the) • 

basicpart(clergyman). 
basicpart(motorcar). 
67 
At this point you may wish to rewrite partsoflist to handle grammars. 
The QUant 
structure could be discarded If you like. 
You should provide a reasonable grammar and a 
vocabulary. 
Satisfy yourself that this modified program will produce all possible grammatical 
sentences from the grammar and vocabulary you provide. 
As always. Prolog will stop at each 
solution. and walt for you to type a semicolon to tell It to backtrack to the next solution. 
This Is certainly not the last word on processing English language In this book. 
The 
whole of Chapter 9 Is devoted to a more sophisticated treatment of analysing English language 
In Prolog. 

Chapter 4. Backtracking and "Cut" 
Let us summarise what we learned In Chapters 1 and 2 about what can happen to a 
goal: 
1. 
An attempt can be made to satisfy a goal. 
When we satisfy a goal. we search the 
database from the top. 
Two things can happen: 
(a) 
A matching fact (or rule head) can be found. 
In this case. we say the goal 
has been matched. 
We mark the place In the database. and Instantiate any 
previously unlnstantlated variables that have matched. 
If we matched against 
a rule. we shall first have to attempt to satisfy the rule. 
If the goal succeeds. 
we then attempt to satisfy the next goal on the right. 
(b) 
No matching fact (or rule head) can be found. 
In this case. we say the goal 
has failed. 
We then attempt to fe-satisfy the next goal on the left. 
This 
Is what we mean by 'going back' to a previous goal. 
2. 
We can attempt to fe-satisfy a goal. 
In this case. we must return to unlnstantlated 
any variables that became Instantiated when this goal was previously satisfied. 
This 
Is what we mean by 'undoing' all the work previously done by this goal. 
Next. we 
resume searching the database. but we begin the search from where the goal's 
place-marker was previously put. 
As before. this new 'backtracked' goal may either 
succeed or fall. and either step (a) and (b) above would occur. 
This chapter will look at backtracking In more detail. 
It will also look at a special 
mechanism that can be used In Prolog programs -- the 'cut'. 
The cut allows you to tell 
Prolog which previous choices It need not consider again. 

59 
4.1 
Generating Multiple Solutlona 
The simplest way a set of facts can allow multiple solutions to a question is when there 
are several facts that will match against the question. 
For Instance. If we have the following 
facts In which father(X,y) means that the father of X is Y: 
father(mary,george). 
father(john,george). 
father(sue,harry). 
father(george,edward). 
The question 
1- father(X, Y). 
will have several possible answers. 
If we prompt with a semicolon. Prolog will give us the 
following: 
X=mary, Y=qeorge; 
X-john, Y=george; 
X=sue, Y-harry; 
x=george, Y_dward 
It finds these answers by searching through the database to find the facts and rule about 
father In the order in which they were given. 
Prolog is not particularly clever about this 
-- it does not remember anything about what it has shown before. 
So If we ask 
1- father(_,X). 
(for which X is X a father?) 
we will get: 
x=qeorge; 
X=george; 
X=harry; 
x-edward 
with george repeated twice because George is the father of both Mary and John. 
If Prolog 
has two ways of showing the same thing. it treats them as two different solutions. 
Backtracking happens in exactly the same way if the alternatives are embedded more 
deeply In the processing. 
For example. one rule in a definition of 'one of the children of 
X Is Y· might be 
child(X,Y) ,- father(Y,X). 

60 
Then. the question 
1- child{X,Y). 
would give 
X=george, Y=mary; 
X=george, Y=john; 
X=harry, Y=sue; 
X=edward, Y=george 
Because father{Y,X) has four solutions. so. does child(X, Y). 
Moreover. the solutions are 
generated In the same order. All that Is different is that the order of the arguments Is different. 
as Is specified In the definition of child. 
Similarly. If we defined 
father{ X) : - father<-, X) . 
("father(X)" meaning that X is a father) then the question 
1- father{ X ) . 
would evoke: 
X=george; 
X=george; 
X=harry; 
X=edward 
If we mix facts and rules. the alternatives follow again in the order In which things are 
presented. 
Thus we might define: 
person( adam) . 
person{X) :- mother(X,Y). 
person(eve). 
mother(cain,eve). 
mother(abel,eve). 
mother{jabal,adah). 
mother(tubalcain,zillah). 
(Adam is a person. anything Is a person if it has a mother. and Eve Is a person. 
Also. 
various people have various mothers). 
In this case. if we asked the question 
1- person{ X) . 
the answers would be: 
X=adam; 
X=cain; 

X=jabal; 
X=tubalcain; 
X=eve 
61 
Let us look now at a more interesting case -- where there are two goals each of which 
has several solutions. 
Let us Imagine we are planning a party and want to speculate about 
who might dance with whom. 
We can start writing a program as follows: 
possible--pair( x, Y) ,- boy( X), girl( Y) • 
boy( john). 
boy( marmaduke) . 
boy( bertram) • 
boy( charles) • 
girl( griselda). 
girl(ermintrude). 
girl(brunhilde). 
<This Is not yet a perfectly balanced part yD. 
This program says that X and Y form a possible 
pair If X Is a boy and Y Is a girl. 
Now let's see what possible pairs there are: 
1- possible--pair(X,Y). 
X 
john, Y 
X 
john, Y 
X 
john, Y 
X 
marmaduke, 
griselda; 
ermintrude; 
brunhilde; 
Y 
griselda; 
Y = ermintrude; 
X 
marmaduke, Y = brunhilde; 
X= marmaduke, 
X = bertram, Y 
griselda; 
X = bertram, 
X = bertram, 
X= charles, 
X= charles, 
X = charles, 
Y 
Y 
Y 
Y 
Y 
ermintrude; 
brunhilde; 
= griselda; 
ermintrude; 
= brunhilde 
You should make sure that you understand why Prolog produces the solutions In this order. 
First of all. It satisfies the goal boy(X), finding John, the first boy. 
Then It satisfies girl(Y), 
finding Griselda. the first girl. 
At this point. we ask for another solution by causing a failure. 
Prolog attempts to resatlsfy what It did last. which Is the girl goal within the satisfaction 
of the possible....Pilir goal. 
It finds the alternative girl Ermlntrude. and so the second solution 
is John and Ermlntrude. 
Similarly. It generates John and Brunhilde as the third solution. 
The next time it tries to resatisly girl(Y), Prolog finds that Its placemarker Is at the end 
of the database. and so the goal fails. 
Now it tries to resatlsfy boy(X). 
The placemarker 
for this was placed at the first fact lor boy, and so the next solution found is the second 
boy (Marmaduke). 
Now that it has resallsfled this goal. Prolog looks to see what Is next 
--
it must now satisfy girl(Y) from the start again. 
So it finds Griselda. the first girl. 
The next three solutions now Involve Marmaduke and the three girls. 
Next time we ask for 
an alternative. the girl goal cannot be resatisfied again. 
So another boy Is found. and the 

62 
search through girls starts again from scratch. 
And so on. 
Eventually. the girl. goal falls 
and there are also no more solutions to the boy goal either. 
So the program can find no 
more pairs. 
These examples are all very simple. 
They Just Involve the specification of many facts 
or the use of rules to access those facts. 
Because of this. they can only generate a finite 
number of possible solutions. 
Sometimes we might want to generate an Infinite number of 
possibilities --
not because we want to consider them all. but because we may not know 
In advance how many we need. 
In this case. we need a definition that Is recursive, that 
Is. a definition that directly or Indirectly appeals to Itself. 
Consider the following definition 
of what It is to be an Integer (where by 'Integer' we mean a whole number not less than 
0>. 
The goal is_integer(R) will succeed providing N is Instantiated to an Integer. 
If N Is 
not Instantiated at the time the goal Is considered. then an is_integer(R) will cause an integer 
to be chosen. and N will be Instantiated to It: 
is_integer( 0 ) • 
/'" 1 "'/ 
/'" 2 "'/ is_integer(X) ,- is_integer(Y), X is Y+l. 
If we ask the question 
?- is_integer( X) . 
we will get as the possible answers all the Integers In ascending order CO. 1. 2. 3 ... ,). one 
at a time. Each time we force backtracking to occur (perhaps by typing semicolon). is_integer 
will succeed with Its argument Instantiated to a new Integer. 
So this short definition generates 
an Infinite number of answers (actually. only as many as will fit into the computer). 
Why? 
Here is the sequence of events that leads to the first three solutions: 
First solution: 
~Goal is_integer(X) 
Succeeds with x-o 
Second solution: 
r Goal is_integer(x) 
I X here is X in use of 
I 
~Goal is_integer(Y) 
I 
Succeeds with Y-O 
I 
Goal X is Y+l 
I 
Succeeds with X-l 
L Succeeds with X=l 
Third solution: 
r Goal is_integer(X) 
I X here is X in use of 
-
decided to use fact 1 
-
decided to use rule 2 
rule 
-
decided to use fact 1 
-
used built-in definition 
-
decided to use rule 2 
rule 

I 
r Goal is_integer(Y) 
-
decided to use rule 2 
I 
I Y here is X in use of rule 
I 
I 
"'Goal is_integer(Y) 
-
decided to use fact l. 
I 
I 
Succeeds with y=o 
I 
I 
Goal. X is Y+l. 
-
used buil.t-in definition 
I 
I 
Succeeds with X=l. 
I 
L Succeeds with Y=l. 
I 
Goal. X is Y+l. 
I 
Succeeds with X-2 
L Succeeds with X=2 
63 
and so on. 
At each stage, the point marked with a ' .... Is where 
another choice will be 
made when backtracking occurs next. 
So It Is only the things after the ..... that change from 
one solution to the next. 
If we miss out the variables. the choices Involved can ,be conveniently 
displayed In a tree. If we use fact 1 to solve an is_integer goal. no more goals are generated. 
However. If we use fact 2, another is_integer goal Is created. and we then have to make 
the same choice for that. 
According to the sequences of choices we make, different final 
answers are produced. 
/----1 
\ 
/ 
\ 
fact l. 
rule 2 
(leads to answer X=O) 
I 
I 
/---?---\ 
/ 
\ 
fact l. 
rule 2 
(leads to answer X=l.) 
I 
I 
I 
/-----1----\ 
/ 
\ 
fact l. 
(leads to answer X=2) 
rule 2 
I 
Initially, we have a choice between fact 1 and rule 2 to answer the question. 
If we choose 
fact 1. no more choices have to be made. and we get X=O. 
Otherwise we choose rule 2 
and have a choice how to satisfy the goal it introduces. 
If we choose fact 1, we end up 
with the answer X=l; otherwise we use rule 2 and must again choose how to satisfy the subgoal 
produced. 
And so on. 
At each stage, the first thing Prolog does Is to pick fact 1. 
Only 
on backtracking does It undo the last choice. 
Each time It does this, It goes back to where 
It last chose fact 1, and Instead chooses rule 2. 
Once It has decided to use rule 2, a new 
subgoal is Introduced, 
Fact 1 Is the first possibility for satisfying It. 
Most Prolog rules will give rise to alternative solutions If they are used for goals that 

64 
contain a lot of uninstantlated variables. 
For Instance. the relation of membership of a list: 
member(X, [XL]). 
member(X, [_IY]) :- member(X, Y). 
will generate alternatives. 
If we ask 
?- member( a,x). 
(notice X in the question 
Is 
uninstantlatedl then the successive values of X will 
be 
partially-defined lists where 'a' Is the first. second. third, ... member. 
See If you can see 
why this Is. 
A further result of allowing this definition of member to backtrack Is that the 
question 
member(a,[a,b,r,a,c,a,d,a,b,r,a]). 
actually can succeed five times Clearly, there are some applications of member where we only 
need it to succeed once. if at all. and then discard the other four choices. 
We can tell 
Prolog to discard choices In this way by using the ·cut". 
4.2 
The ·Cut· 
This section looks at a special mechanism that can be used In Prolog programs --
the "cut". 
The 'cut" allows you to tell Prolog which previous choices it need not consider 
again when it backtracks though the chain of satisfied goals. 
There are two reasons why 
it may be Important to do this: 
o 
your program will operate faster because it will not waste time attempting to satisfy 
goals that you can tell beforehand will never contribute to a solution; 
o 
your program may occupy less of the computer's memory space because more 
economical use of memory can be made if backtracking points do not have to be 
recorded for later examination. 
In some cases. including a "cut" may mean the difference between a program that will run 
and a program that will not. 
Syntactically, a use of 'cut" in a rule looks just like the appearance of a goal which 
has the predicate 
and no arguments. 
As a goal. this succeeds immediately and cannot 
be resatlsfled. 
However. It also has side-effects which alter the way backtracking works 
afterwards. 
The effect Is to remove the place markers for certain goals so that they cannot 
be resatisfled. 
Let us see how this works In an example. 
The following Is part of a program 
to construct a 'plan' for building a house in London. 
The 'plan' will be a list of structures 

65 
representing the actions to be performed. 
There are two main possibilities -- one can get 
an outside builder to do the job or one can do the building oneself. 
In the first case. the 
first action to be performed Is to contact the builder. 
The builder mentioned In the 'plan' 
can be either a builder who Is located In London. or just any builder. 
/* 1 */ 
/* 2 */ 
/* 3 */ 
i* 4 */ 
/* 5 */ 
/* 6 */ 
/* 28 */ 
/* 29 */ 
/* 30 */ 
/* 50 */ 
house_build(Plan) :-
outside~uild(Plan). 
house~uild(Plan) :- build(self,Plan). 
outside_build([contact(B)IPlanl]) :-
builder(B), loc(B,london), I, 
build(B,Planl) . 
outside~uild([contact(B)IPlanl]) 
builder(B), build(B,Planl). 
builder( 'Rousseau & Co'). 
builder( '0 Morgan'). 
loc( 'Eiffel Tower',paris). 
loc( 'Rousseau & CO',paris). 
loc( '0 Morgan',london). 
build(Builder,Plan) 
Let us see what Is the effect of the cut if we ask the question ?- house~uil.d(X). 
Let us 
look at the chronological sequence of events that will have taken place shortly after the 'cut' 
goal Is satisfied. 
Up to this stage. a small amount of backtracking will have taken place 
In the process of finding a builder who Is located In London. 
In summary. house~uil.d(X) 
attempts to satisfy outside~uild(Plan) (clause 1) causing clause 3 to be Investigated. 
The 
first builder found is Rousseau & Co .. but loc(B,l.ondon) fails because Rousseau & Co. are 
located in Paris (clause 29). 
An attempt is made to re-satisfy buil.der(B), and it succeeds. 
finding D. 
Morgan. 
The l.oc(B,l.ondon) goal now succeeds. because Morgan Is located In 
London (clause 30l. The next goal is the ·cut". The cut succeeds, but the effect is to "freeze" 
all of the decisions made since clause 3 was entered. 
Here Is a trace of the goals satisfied 
so far, with the "frozen" goals indicated. 
For the sake of simplicity. we have not Indicated 
all the variable values: 
Goal house_build(X) 
-
decided to use rule 1 
+---
Goal outSide_build 
Goal builder(B) 
F 1- decided to use rule 3 
R 1- decided to use fact 6 
Succeeds 
0 1 
Goal loc( '0 Morgan',london)Z 1- decided to use fact 30 
Succeeds 
E 1 
Goal 1 
N 1-
built-in definition 
Succeeds 
+-------
Goal build( '0 Morgan' ,Planl) 
-
decided to use rule 50 

66 
The effect of the "cut" In the outsideJluild rule (clause 3) Is to commit the system to every 
decision It has made since it chose that rule. 
It does this by removing the place markers 
from the goals between the outsideJluild goal and the cut goal. 
Thus. any attempt to 
re-satisfy these goals will fall. 
If backtracking subsequently takes place (because the build 
goal 
falls). 
the 
system 
will 
not 
consider 
alternative 
solutions 
for 
the 
goals loc( 'D 
Morgan' ,london) or builder(B). 
Neither will It consider the second rule for outsideJluild, 
because the choice of the rule that the cut appears In Is included in those frozen by the 
cut. 
The effect of the cut In this example is to say: 
If, given your first choice of a builder located in London, it is not possible to 
create a plan tor that builder to build the house, abandon the Idea of getting 
an outside builder at all. 
In this example. the "freezing effect" of the cut went back as far as the outsideJluild goal. 
This is called the parent goal of the cut goal. because it was the goal that caused the use 
of the rule containing the cut. 
The formal definition of the effect of the cut symbol Is as 
follows: 
When a cut is encountered as a goal. the system thereupon becomes committed 
to all choices made since the parent goal was invoked. 
All other alternatives 
are discarded. 
Hence an attempt to resatisty any goal between the parent goal 
and the cut ('[') goal will fail. 
There are several ways of describing what has happened to the choices that are affected 
by a cut. 
One can say that the choices are cut or frozen. that the system commits Itself 
to the choices made or that the alternatives are discarded. 
One can also look at the cut 
symbol as being rather like a fence that separates goals. 
In this conjunction of goals, 
foo;- a, b, c, I, d, e, f. 
Prolog will quite happily backtrack among goals a. b. and c. until the success of c causes 
the "fence" to be crossed to the right to reach goal d. 
Then. backtracking can occur among 
d. e, and 1. perhaps satisfying the entire conjunction several times. 
However. if d fails, causing 
the "fence" to be crossed to the left. then no attempt will be made to resatisfy goal c: 
the 
entire conjunction of goals will fail. and the goal foo will also fall. 
One further note before we go on to see more examples of the cut in use. 
We have 
said that if the cut appears in some rule and the cut goal Is satisfied then Prolog becomes 
committed to all choices made Since the parent goal was invoked. 
This means that the choice 
of that rule. and all other choices made since then. become fixed. 
We will see later that 
it is possible to provide alternatives within a single rule using the built-in predicate ; ("or·). 
The chOices Introduced by this facility are affected In exactly the same way. 
That Is. when 
a cut goal is satisfied. all ·or" choices that have been made since the rule was chosen are 

67 
fixed. 
4.3 
Common USN of the Cut 
We can divide the common uses of 'cut' Into three main areas: 
[] 
The first concerns places where we want to tell the Prolog system that It has found 
the right rule for a particular goal. 
Here. the cut says 'If you get this far. you have 
picked the correct rule for this goal'. 
[] 
The second concerns places where we want to tell the Prolog system to fall a particular 
goal Immediately without trying for alternative solutions. 
Here. we use the cut In 
conjunction with the fai1 predicate to say 'If you get to here. you should stop trying 
to satisfy this goal'. 
[] 
The third concerns places where we want to terminate the generation of alternative 
solutions through backtracking. 
Here. the cut says 'If you get to here. you have found 
the only solution to this problem. and there Is no point In ever looking for alternatives'. 
We will now look at some examples of these three uses. 
You should bear In mind. however. 
that the cut has a single meaning In all these applications. 
The division Into three main 
areas of use is purely for tutorial reasons. and to show what kinds of reasons you might 
have for putting cuts Into your programs. 
4.3.1 Confirming the Choice .Q! .!! Rule 
Very often In a Prolog program. we wish to associate several clauses with the same 
predicate. 
One clause will be appropriate if the arguments are of one form. another will 
be appropriate If the arguments are of another form. and so on. 
Often we can specify which 
rule should be used for a given goal by providing patterns in the rule heads that will only 
match goals of the right types. 
However. this may not always be possible. 
If we cannot 
tell in advance what forms the arguments may take. or if we cannot specify an exhaustive 
set of patterns. we may have to compromise. 
This means giving rules for some specIfic 
argument types and then giving a 'catchall' rule at the end for everything else. As an example 
of this. consider the following program. The rules define the predicate sUllLto such that giving 
Prolog the goal sUllLto(N,X) with N having an integer value. causes X to be Instantiated to 
the sum of the numbers from 1 to N. 
Thus. for Instance. It produces the following: 
1- SUIlLtO(S,X). 
x = lSI 
no 

68 
because 1+2+3+4+5 Is 15. 
Here Is the program. 
SUI!Lto( 1, 1) ,- I. 
SUl!Lto(N,Res) ,-
Nl is N-l, 
SUl!Lto(NI,ReSI), 
Res is Resl+N. 
This Is a recursive definition. 
The Idea Is that the boundary condition occurs when the first 
number is 1. 
In that case, the answer Is also 1. 
The second clause introduces a recursive 
slDILto goal. 
However. the first number of the new goal is one less than the original one. 
The new goal that this goal will invoke will have its first argument one less again. 
And so 
on until the boundary condition Is reached. 
Since the first arguments are always getting less. 
the boundary condition must be reached eventually (assuming that the original goal has a 
first argument not less than 1), and the program will terminate. 
The Interesting thing about this program is how we have handled the two cases -- when 
the number is 1. and when it is something else. 
When we defined predicates that talked 
about lists. it was easy to specify the two cases that would normally arise -- when the list 
was [] and when it was of the form [A:Bl. 
With numbers. things are not so easy. because 
we cannot specify a pattern that will only match an integer not equal to 1. 
The solution 
adopted in this example is to provide a pattern for the '1' case and Just to leave a variable 
to match against anything else. 
We know from the way Prolog searches through the database 
that it will try to match the number against 1 first and will only try the second rule if this 
falls. 
So the second rule should only be used for numbers not equal to 1. 
However. this 
Is not the whole story. 
If Prolog ever backtracks and comes to reconsider the choice of 
rule when applied to the number 1. it will find that the second rule is applicable. 
As far 
as it can see. both rules provide alternatives for the goal sUllLtO( I,X). 
We must tell it that 
on no account is the second rule ever to be tried if the number is 1. 
One way of doing 
this is to put a "cut" In the first rule (as shown). 
This tells Prolog that. once it has got 
this far In the first rule. it must never remake the deCision about which rule to use for the 
sUllLto goal. 
It will only get this far if the number is in fact 1. 
Let us see what this looks like In terms of the chronology of the goals. 
If we call 
sUllLtO( I,X). in the context: 
go ,- sUl!Lto(I,X), foo(apples), 
?- go, 

69 
and the goal foo( apples) falls, then at the point of failure we will have: 
Goal go 
- decided to use 1st rule 
+--------------------
Goal SllltLto( 1,X) 
- decided to use 1st rule 
Goal ! 
FROZEN 
- used built-in definition 
Succeeds 
(with X=l) 
+--
Goal foo(apples) 
- used some other clauses 
FAIL!!! 
When Prolog tries to resatisfy the goals in reverse order, it will find that two of the goals 
cannot be resatisfled because any choices are frozen. 
Hence It will correctly avoid trying 
alternative ways of satisfying SUJILto( 1,X). 
Exercise g 
What happens if the "cut" Is left out here and backtracking gets round to 
reconsidering the SUJILto goal? 
What alternative results, If any, are produced, and why? 
The last example showed how "cut" can be used to make Prolog behave sensibly when 
we cannot distinguish between all the possible cases by specifying patterns in the heads of 
the rules. 
A more usual situation In which we cannot specify patterns to decide which rule 
to use arises when we want to provide extra conditions, in the form of Prolog goals, which 
will decide on the appropriate rule. 
Consider the following alternative form of the above 
example: 
SUll\...to(N,l) 
sUll\...to(N,R) 
N =< 1, I. 
Nl is N-l, SllltLto(Nl,Rl), R is Rl+N. 
In this case. we say that the first rule is the one to choose if the number provided is less 
than or equal to one. 
This is slightly better than the previous formulation. because it means 
that the program produces an answer (rather than running on indefinitely) if the first argument 
Is given as 0 or a negative number. 
If the condition is true. the result 
can be produced 
immediately. and no more recursive goals are necessary. 
Only if the condition is not true 
do we want ever to try the second rule. 
We must tell Prolog that once it has proved N 
= ( 1. It must never reconsider the choice about what rule to choose. 
This Is what the cut 
does. 
It is a general principle that uses of cut to tell Prolog when it has picked the only correct 
rule can be replaced by uses of not. 
This is a Prolog built-in predicate. which means that 
its definition is already provided when you start your Prolog session. 
So you can use it In 
your own programs without having to write down a definition each time (built-in predicates 
are described more fully in Chapter 6). not is defined In such a way that the goal not(X) 
succeeds only if X. when seen as a Prolog goal, falls. 
So not(X) means that X is not 
satisfiable as a Prolog goal. 
As an example of replacing cuts with uses of not, the two 

70 
pOssibilities given for the SUJlLto definition can be rewritten as: 
SUJILtO(l,l). 
SUJlLto(N,R) ,- not(N-1), N1 is N-1, SUJlLto(N1,Rl), R is N1+Rl. 
SUJlLtO(N,l) ,- N =< 1. 
SUJlLto(N,R) :- not(N=<l), N1 is.N-1, SUJlLto(N1,Rl), R is N1+Rl. 
In fact. Prolog provides suitable evaluable predicates to substitute for both of these uses. 
For example. we can replace not(R-1.) by R\-1., and not(R-<l.) by R~l. 
In general. we will 
not be able to do this with all the conditions we dream up. 
It Is good programming style to replace cuts by the use of not. 
This Is because 
programs containing cuts are In general harder to read than programs not containing them. 
If one can localise all occurrences of cut to Inside the definition of not, then the program 
will be easier to understand. 
However. the definition of not Involves trying to show that the 
goal It Is given can be satisfied. 
Therefore. if we have a program of the general form: 
A :- B, C. 
A :- not(B), D. 
Prolog may well end up trying to satisfy B twice. 
It will have to try and satisfy B when It 
looks at the first rule. 
Also. If it ever backtracks and considers the second rule. it will have 
to try and satisfy B again to see if not(8) can be satisfied. 
This duplication could be very 
ineffiCient if the condition B was rather complicated. 
This would not be the case if instead 
we had: 
A :- B, I, C. 
A ,- D. 
So one must sometimes weigh up the advantages of a clear program against those of a program 
that will run quickly. 
The discussion of efficiency ieads us to our last example of the cut 
being used to fix the choice of a rule. 
Consider the definition of append: 
append( [] ,X,X). 
append([AIB],C,[AID]) :- append(B,C,D). 
If we are always using append for the case where we have two known lists and want to know 
what list consists of the first appended onto the front of the second. we may feel that It is 
Inefficient that 
when 
backtracking 
gets 
to 
reconsider 
how to 
deal 
with 
a 
goal 
like 
append([],[a,b,c,d],X) it must try to use the second rule. even though the attempt Is bound 
to fail. 
We know in this context that if the first list is [] then the first rule Is the only correct 
one. and this information can be given to Prolog by a use of the cut. 
In general. Prolog 
Implementations will be able to make better use of the available storage if they are told things 
like this than if they have to keep a record of apparent choices that are not really there. 

71 
So we could rewrite our definition as: 
append( [J,X,X) ,- I. 
append( [AlB] ,C, [AID]) ,- append(B,C,D). 
Assuming our restricted use of append, this does not affect at all which solutions the program 
finds. 
It only Increases the space and time efficiency to some extent. 
In exchange for this. 
we are liable to find that other kinds of uses of append will no longer work as expected. 
as Is shown In Section 4.4. 
4.3.2 The 'cut-fall" Combination 
In the second major application area. the cut Is used In conjunction with the built-In 
fail. predicate. fail. Is another 'built-In predicate. like not:. 
It has no arguments. which means 
that the the success of the goal fail. does not depend on what any variables stand for. 
Indeed. fail. Is defined In such a way that as a goal It always falls and causes backtracking 
to take place. 
This Is just like what happens if we try to satisfy a goal for a predicate with 
no facts or rules. 
When fail. Is encountered afler a cut. the normal backtracking behaviour 
will be altered by the effect of the cut. 
In fact. the particular combination ·cut-fall' turns 
out to be quite useful In practice. 
Let us consider how we might use this combination in a program to calculate how much 
tax somebody should pay. 
One thing we might want to know Is whether the person Is an 
'average taxpayer" -- In this case. the calculations might be quite simple and not have to 
involve considering lots of special cases. 
Let us define a predicate average_taxpayer where 
average_taxpayer(X) means that X Is an average taxpayer. 
For Instance. Fred Bloggs. who 
Is married with 2 children and works In a bicycle factory. might be considered quite average. 
However. the managing director of an 011 company may be earning too much. and a pensioner 
may be earning too little for the same kinds of tax calculations to be appropriate. 
We should 
start by considering a possible special case. 
It may be thaI special tax laws apply to somebody 
who Is a native of another country. because he may have obligations to that country as well. 
Therefore. however average he may be In other respects. a foreigner will not be classed as 
an average taxpayer. 
We can start writing rules about this as follows: 
average_taxpayer(X) ,- foreigner(X), fail.. 
average_taxpayer(X) ,-
In this extract. which Is not correct, the first rule attempts to say "If X Is a foreigner then 
the goal average_taxpayer(X) should fall". 
The second rule Is to apply the general criterion 
for being an everage taxpayer for the cases when X Is not a foreigner. 
The trouble Is that 
If we asked the question: 
1- average_taxpayer(widsl.ewip). 

72 
about some foreigner called Widslewip the first rule would match and the fo:r:eigner goal would 
succeed. 
Next. the fail. goal would initiate backtracking. 
In attempting to resatisfy the 
average_tupa.yer goal. Prolog would find the second rule and start applying the general 
criterion to Widselwip. 
Now it Is quite likely that he would pass the test. in which case the 
question would incorrectly be answered ·yes·. So our first rule has been completely Ineffective 
in rejecting our friend as an average taxpayer. 
Why is this? 
The answer is that during 
backtracking Prolog tries to resatisfy every goal that has succeeded. 
So in particular it will 
investigate alternative ways of satisfying average_talIpayer(widsl.ewip) In order to stop Prolog 
finding alternatives for this. we need to ·cut" the choice (freeze the decision) before failing. 
We can do this by inserting a cut before the fail. goal. 
A slightly more comprehensive 
definition of average_tupayer Incorporating this change. is given below: 
average_taxpayer(X) ,-
foreigner(X), I, fail.. 
average_taxpayer(x) ,-
spouse(X,Y), gross_income(Y,Inc), Inc> 3000, I, fail.. 
average_taxpayer(X) ,- gross_income(X,Inc), 2000 < Inc, 20000 > Inc. 
gross_income(X,Y) ,-
receives-pension(X,P), 
P < 5000, I, fail.. 
gross_income(x,y) ,-
gross_sal.ary(X,Z), 
investment_income(x,W), 
Y is Z+W. 
investment_income(X,Y) 1-
Note the use in this program of several other ·cut-fail" combinations. 
In the second rule 
for averaglLtupa.yer we say that the attempt to show that someone is an average taxpayer 
can be abandoned if we can show that that person's spouse earns more than a certain amount. 
Also, in the definition of the predicate gross_income we say (in the first rule) that if somebody 
receives a pension that is below a certain amount then, whatever their other circumstances, 
we will consider them not to have any gross income at all. 
An interesting application of the ·cut-fail" combination is in the definition of the predicate 
not. Most Proiog implementations provide this already defined. but it is interesting to consider 
how we can provide rules for it. 
We require that the goal not(P), where P stands for another 
goal, succeeds if and only if the goal P falls. 
This is not exactly in accord with our intuitive 
notion of ·not true· -- it is not always safe to assume that something is not true if we are 
unable to prove it. 
However, here is the definition: 
not(p) ,- cal.l.(P), I, fail.. 
not(p). 
The definition of not involves invoking the argument P as a goal. using the evaluable predicate 
ca1l.. 
Predicate cal.l. simpiy treats its argument as a goal and attempts to satisfy it. 
We 
want the first rule to be applicable if P can be shown. and the second to be applicable 

73 
otherwise. 
So we say that if Prolog can satisfy ca1l.(P) It should thereupon abandon satisfying 
the not goal. 
The other possibility is that Prolog cannot show ca1l.(P). 
In this case. It 
never gets to the cut. 
Because the ca1l.(P) goal failed. backtracking takes place. and Prolog 
finds the second rule. 
Hence the goal not(P) will succeed when P Is n9t provable. 
As with the first use of "cut", we can replace uses of "cut-fail" with uses of not. 
This 
Involves rather more reorganisation of the program than before, but does not Introduce the 
same inefficiency. 
If we were to rewrite our average_taxpayer program, It would start off 
something like: 
average_taxpayer(x) ,-
not( foreigner(X», 
not«spouse(x,Y),gross_income(Y,Inc),Inc>3000», 
gross_income(X,Incl), ... 
Note that In this example, we have to enclose a whole conjunction of goals inside the not. 
In order to show unambiguously that the commas join the goals into a conjunction (rather 
than separating multiple not arguments). we have enclosed the not argument in an extra set 
of brackets. 
4.3.3 Terminating .l! "generate and test" 
Now we come to look at the last major use of "cut" In Prolog, programs -- to terminate 
a "generate and test" sequence. 
Very often a program will have parts that conform to the 
following general model. 
There will be a sequence of goals that can succeed In many ways, 
and which generates many possible solutions on backtracking. 
After this, there are goals 
that check whether a solution generated Is acceptable for some purpose. 
If these goals fall, 
backtracking 
will 
lead 
to 
another 
solution 
being 
proposed. 
This 
will 
be 
tested 
for 
appropriateness, and so on. 
This process will stop when either an acceptable solution is 
generated (success), or when no more solutions can be found (failure). 
We can call the 
goals that are yielding all the alternatives the "generator" and those that check whether a 
solution is acceptable the "tester". 
Let us consider an exampl~ of this. 
The following might 
be part of a program to play "Noughts and Crosses" ("Tic-Tac-Toe"). 
The program uses 
the built-In predicates var and arg, which are fully discussed in Chapter 6. 
forced_move(Board,Sq) ,-
aline(squares), 
threatening(squares,Board,Sq), I. 
aline([1,2,3]). 
aline( [4,5,6]). 
aline([7,8,9]). 
aline([1,4,7]). 
aline( [2, 5 ,8] ) . 
aline([3,6,9]). 
aline([1,5,9]). 
aline( [3,5,7]). 

74 
threatening([X,Y,Z),B,X) 1- empty(X,B), orosS(Y,B), orOSS(Z,B). 
threatening([X,Y,Z),B,Y) :- empty(Y,B), oroSS(X,B), oroSS(Z,B). 
threatening([X,Y,Z),B,Z) :- empty(Z,B), orOSS(X,B), oroSS(Y,B). 
empty(sq,Board) 1-
arg(sq,Board,Va~), var(Va~). 
oross(sq,Board) :-
arg(sq,Board,Va~), nonvar(Va~), Va~ = x. 
nought(sq,Board) :-
arg(sq,Board,Va~), nonvar(Va~), Va~ = o. 
In case you haven't come across this game. it involves two players taking turns to occupy 
squares on a 3x3 board. 
One player occupies them with pieces marked "0". and the other 
one with pieces marked "x". 
The object of the game is to get three of one's own pieces 
in a (vertical. horizontal or diagonal> line before the other player does. 
We can number the 
nine squares on the board as below: 
4 I 5 
6 
7 
8 
9 
The program is assumed to be looking at the game from the point of view of the player who 
puts 'o"s on the board. 
The predicate foroec1.JDove is used to answer the question "Am I 
forced to put a piece in a particular position?" This will be the case if the "0" player cannot 
immediately win (we do not deal with this here). but the "x" is threatening to win on his next 
move. 
For instance. in the position: 
x 
o 
x 
o 
x 
the "0· player is forced to play in square 4. because if he does not. his opponent will be 
able to fill the line 1-4-7 in his next turn. 
The program works by trying to find a line. two 
of whose squares are occupied by crosses. and the other of which is empty. 
If it can. then 
the player is forced to move into the empty square. 
In the clause for foroed.....move. the goal 
aline(squares) 
serves as a "generator" of possible lines. This goal can succeed in many ways -- with Squares 
instantiated as one of the possible lists of square numbers that represent lines. 
Once a 
possible line has been suggested. It is necessary to see whether the opponent is threatening 
to claim this line. 
This is the purpose of the "tester" goal: 
threatening(squares,Board,sq) 

75 
In this goal. the variable Board Is supposed to hold a representation of the current state of 
the board -- what squares are occupied by what pieces -- and the variable sq becomes 
Instantiated to the number of the square where the "0· player Is forced to play (assuming 
the goal succeeds). 
The basiC idea of the program Is very simple -- a1ine proposes a line, and then 
threatening looks to see whether that line Is threatening. 
If so, the original fo=e<t..move 
goal succeeds. 
Otherwise, backtracking occurs and a1ine comes up with another possible 
line. 
Now this is tested also, and maybe backtracking occurs again. 
If we get to the point 
when a1ine can generate no more lines. then the forceQ....move goal will correctly fail (there 
Is no forced move). 
Now consider what happens if this program, as part of a larger system, 
successfully finds a forced move. 
Sq will become Instantiated to the number of the square 
where the move should be. and this information will be used somewhere else In the program. 
Suppose that somewhere later a failure occurs, and Prolog eventually tries to resatlsfy the 
force<t..move goal. 
Then a1ine will start producing more possible lines to be checked. 
This 
makes no sense, because It cannot possibly be useful to find alternative forced moves. 
If 
we have found one of them, then we canl')ot do anything better than carry it out -- failure 
to do so would guarantee losing the game. 
Most of the time, there will be no alternative 
anyway, and forceQ....move will search through all the untried lines In vain, before itself failing. 
However. In the case of forced moves, we know that even If there Is an alternative solution, 
it cannot be of any use In a context where a failure occurred in spite of the first solution. 
We can prevent Prolog from wasting time searching for different forced moves by putting a 
"cut" at the end of the clause. 
This has the effect of freezing the last successful a1ine 
solution. 
Including the "cut" amounts to saying "when I look for forced moves. it Is only the 
first solution that Is important". 
From the point of view of understanding this use of "cut", it is only necessary to consider 
the overall structure of this program. 
However, some of the details are also of interest. 
The program assumes the board to be represented by a structure with nine components. 
Each component represents what is occupying the square of the appropriate number. 
Thus 
at any time the value for square 4 can be obtained by looking at the fourth argument of 
the current board structure (we use the built-in predicate arg for this). 
The value Is an 
uninstantiated variable if the square Is unoccupied: otherwise it is one of the atoms 0 
and 
x. 
We use var and nonvar to determine whether the square is occupied or not. 
Let us look at another example of a program that works by a "generate and test" method. 
We came across the Idea of "Integer division" in Section 2.5. 
Most Prolog systems provide 
this facility automatically, but here is a program for integer division that only uses addition 
and multiplication. 
divide(Nl,N2,Result) ,-
is_integer(Result), 
Productl is Result*N2, 

76 
Product2 is (Result+l)*N2, 
Product1 =< N1, Product2 > N1, I. 
This rule uses the predicate is_integer (as defined before) to generate the number Resu1t 
which Is the result of "dividing" Hl. by H2. 
SO, for Instance, the result of dividing 27 by 6 
Is 4, because 
4 .. 6 Is less than or equal to 27. and 5 .. 6 Is greater than 27 
The rule uses is_integer as a "generator", and the rest of the goals provide the appropriate 
"tester". 
Now 
we 
know 
In 
advance 
that, 
given 
specific 
values 
of Ill. 
and 
112, 
divide(IIl.,1I2.Resu1t) can only succeed for one possible value for Resul.t. 
For although 
is_integer can generate Infinitely many candidates, only one will ever get past the tests. 
We can Indicate this knowledge by putting a cut at the end of the rule. 
This says that If 
we ever successfully generate a Resul.t that passes the tests for being the result of the division. 
we need never try any more. 
In particular, we need never reconsider any of the choices 
that were Involved In looking for rules for divide, is_integer and so on. 
We have found 
the only solution, and there Is no pOint In ever looking for another. 
If we did not put In 
the cut here, any backtracking would eventually start finding alternatives for is_integer again. 
So we would carry on generating possible values for Resul.t again. None of these other values 
would be the correct result of the division, and so we would continue generating Indefinitely. 
4.4 
Problems with ·cut" 
We have already seen that we must sometimes take Into account the way Prolog searches 
the database and what state of Instantiation our goals will have In deciding the order In which 
to write the clauses of a Prolog program. 
The problem with introducing cuts is that we have 
to be even more certain of exactly how the rules of the program are to be used. For, whereas 
a cut when a rule Is used one way can be harmless or even beneficiaL the very same cut 
can cause strange behaviour If the rule Is suddenly used In another way. Consider the modified 
append from the last section: 
append( [] ,X,X) ,- I. 
append( [AlB] ,e, [AID]) ,- append(B.e,D). 
When we are considering goals like: 
append([a,b,c],[d,e].X) 
and 
append([a,b,c].X,Y) 
the cut Is quite appropriate. 
If the first argument of the goal already has a value, then all 

77 
the cut does is to reaffirm that only the first rule will be relevant If the value Is O. 
However. 
consider what happens if we have the goal 
append(X,Y,[a,b,c) 
This goal will match the head of the first rule. giving: 
X=[), Y=[a,b,c) 
but now the cut Is encountered. 
This will freeze all the choices we have made. and so If 
we ask for another solution. the answer will be 
no 
even though there actually are other solutions to the question. 
Here Is another interesting example of what can happen If a rule containing a cut Is 
used In an unexpected way. 
Let us define a predicate numbe~oL.parents, which can express 
Information about how many parents somebody has. 
We can define It as follows: 
number_of-parents(adam,O) ,- I. 
number_of-parents(eve,o) ,- I. 
number_of_parents(X,2). 
That Is. the number of parents Is 0 for Adam and Eve. but 2 for everybody else. 
Now If 
we are always using our definition of number_oL.parents to find the number of parents of 
given people. this Is fine. 
We will get 
?- number_of-parents(eve,X). 
x=o; 
no 
?- number_of-parents(john,X). 
X=2; 
no 
and so on. as required. 
The cut Is necessary to prevent backtracking ever reaching the third 
rule if the person Is Adam or Eve. 
However. consider what will happen If we use the same 
rules to verify whether given people have given numbers of parents. 
All Is well. except that 
we get: 
?- number_of-parents(eve,2). 
yes 
You should work out for yourself why this happens -- It Is simply a consequence of the way 

78 
Prolog searches through the database. 
Our Implementation of "otherwise" with a cut simply 
does not work properly any more. 
There are two possible modifications we could make to 
recover from this: 
or 
number_of...,parents( adam, N) ,- I, N-O. 
number_of...,parentS(eve,N) ,- I, N=O. 
number_o~arentS(X,2). 
number_of...,parents(adam,O). 
number_o~arents(eve,o). 
number_o~nts(X,2) ,- X\-adam, X\=eve. 
Of course. these will stili not work properly If we give goals like 
expecting backtracking to enumerate all the possibilities. 
So the moral Is: 
If you Introduce cuts to obtain correct behaviour when the goals are of one form, 
there Is no guarantee that anything sensible will happen If goals of another form 
start appearing. 
It follows that It Is only possible to use the cut reliably If you 
have a clear polley about how your rules are going to be used. 
If you change 
this polley, all the uses of cut must be reviewed. 

Chapter 5. Input and Output 
Thus far. the only means we have seen of providing information to a Prolog program 
has been by asking questions of the Prolog system. 
Also. the only method of finding out 
what a variable stands for at some point in the satisfaction of a goal has been by asking 
a question In such a way that Prolog will print out the answer In the ·X = (answer)· form. 
Much of the time. such direct Interaction with questions Is all that is required to ensure that 
a program is working properly. 
However. for many occasions It Is useful to write a Prolog 
program that initiates a conversation with you by itself. 
For example. suppose you have a 
database of world events In the 16th Century. arranged as facts containing dates and headlines. 
To start with. dates can be represented as integers. and headlines can be represented as 
lists of atoms. 
We shall have to enclose some of the atoms in single quotes because they 
begin with an upper-case letter. and we should not want them to be interpreted as variables: 
event(1505, ['Euclid', translated, into, 'Latin']). 
event(1510, ['Reuchlin-Pfefferkorn', controversy, begins]). 
event(1523, ['Christian', 'II', flees, from, 'Denmark']). 
Now if we wish to know about a particular date. we could ask a question as follows: 
1- event( 1505, X) . 
and Prolog would print the reply 
X=[Euclid,translated,into,Latin]. 
Representing the history headlines as lists of atoms confers the advantage that ·searches· 
can be made to find out the date when certain key events happened. 
For example. consider 
the predicate we shall define. called when. 
The goal when(X, Y) succeeds if X is mentioned 
in year Y according to our history headlines: 
when(X,Y) :- event(y,Z), member(X,Z). 
1- when( 'Denmark' ,D). 

80 
D -
~523 
One disadvantage of using lists of atoms is that they are awkward to type in. especially if 
atoms begin with an upper-case letter. 
Another possibility. which has advantages and 
disadvantages of its own. is to represent history headlines as lists of characters. 
From a 
previous chapter we know that lists of characters can be represented as being between double 
quotes: 
event(~5~~, "Luther visits Rome"). 
event(~52~, "Henry VIII is made Defender of the Paith"). 
event( ~524, "Vasco da Gama dies"). 
event(~529, "Berquin burnt at Paris"). 
event(~540, "Reopening of war with Turks"). 
This is easier to type in. but consider asking the question 
?-
event(~524,X). 
If you try this. Prolog will print out an Incomprehensible list of ASCII codes corresponding 
to the characters in the string to which X is instantiatedl 
Although the list of characters 
is easy to type in. the question-and-answer sequence is not sufficient to print out a legible 
answer. 
It would be more convenient. instead of asking Prolog questions of this form. to write 
a program that first asks what date you want to know about. and then prints out the appropriate 
headline on the computer terminal's display. 
Headlines could then be represented In any 
way desired. 
In order to do these kinds of tasks. Prolog makes available some built-in 
predicates that print out their arguments on your computer terminal's display. 
There are also 
predicates that walt for you to type In text from the computer terminal's keyboard. and 
Instantiate a variable to whatever you typed In. 
In this way. your program can Interact with 
you. accepting Input from you. and printing output to you. 
When a program walts for you 
to type some Input from you. we say that it Is reading the input. 
Likewise. when a program 
is printing some output to you. we say it Is writing the output. 
In this chapter we describe 
various methods for reading and writing. 
One of our examples will be printing headlines from 
the history database. and we conclude with a program that accepts normal sentences and 
converts them into a list of constants that can be processed by other programs. 
This 
conversion program. called read....in, can be used as a 'building block' with which to create 
programs that analyse English language. 
Such analysis programs are discussed In later 
chapters. especially Chapter 9. 

81 
5.1 
Reading and Writing Terms 
Perhaps the most useful way to print some term on the computer terminal's display Is 
to use the predicate write. 
If X Is Instantiated to a term, then the goal write(X) will cause 
the term to be printed out on the display. If X is not instantiated. a uniquely numbered variable 
(such as '_253') will be printed. 
However. If two variables are ·sharlng" within the same 
argument of write then they will have the same number. 
The write predicate cannot be 
re-satisfled. 
It only succeeds once. and It falls If an attempt is made to re-satisfy It. 
Why 
would It not be a good idea to use write to write out the historical headline In our example 
above? 
Remember that a string is actually represented as a list of character codes. 
If we 
were to write out such a list. it would be printed as a sequence of Integers. separated by 
commas. and enclosed In square bracketsl 
There are two more predicates to Introduce. and then we will see our first example using 
write. 
The built-in predicate nl is used to force all succeeding output to be printed on 
the next line of the display. 
The name "nl" means "new line". 
Like write, nl succeeds 
only once. 
Next. the built-in predicate tab is used to print a number of blank spaces across 
the display screen. 
The goal tab(X) succeeds only once. and it causes the cursor on the 
display to move to the right by X space characters. 
It Is assumed that X is Instantiated to 
an integer. 
The name tab is perhaps a poorly chosen name. because it does not actually 
have anything to do with the "tab stops" on a standard typewriter or on the display of a 
computer terminal. 
When printing lists. It Is helpful for the items of a list to be printed In a way that Is 
easy to understand. 
Lists that contain 'other "nested" lists are especially difficult to read, 
especially when there are structures Inside as well. 
We shall define a predicate pp such 
that the goal pp(X, Y) prints out the list eto which X is Instantiated) In a helpful way. 
The 
name "Pp" means "pretty print". 
The second argument Is explained later. 
Each author of 
a pretty-print program has his own style of making lists more legible. 
Just for simplicity. 
we shall adopt a method where the elements of a list are printed In a vertical column. 
If 
the element Is Itself a list. Its elements are printed In a column which is shifted over to the 
right. 
This Is essentially a "vine diagram" (Chapter 3) on Its side. 
For example, the list 
[1,2,3] is pretty-printed as 
1 
2 
3 
and the list [1.2.[3.41.5.6] is printed as 
1 
2 

82 
5 
6 
3 
4 
Notice that we have decided to remove the separating commas and the square brackets. 
If the element of a list Is a structure. we will treat It as though It Is an atom. 
This way 
we do not have to "get Inside" structures to pretty-print their contents. 
The fOllowing program 
Implements the pretty-print method we have specified: 
pp([HIT],I):-
I, J is I+3, pp(H,J), PPX(T,J), nl. 
pp(X,I) :- tab(I), write(X), nl. 
ppX( [],_). 
Ppx([HIT],I) :- pp(H,I), ppx(T,I). 
Here we see the second argument of pp revealed as a column counter. 
The "top level" goal 
for printing a list might look like 
... , pp(L,O), ... 
which Initialises the column counter to O. 
The first clause of pp handles the special case: 
If the first argument Is a list. 
If so. we have to set up a new column by Increasing the 
column counter by some amount (3 here). 
Next. we need to "pretty print" the head of the 
list. because It might be a list Itself. 
Next. we need to print each element of the tall of 
the list all In the same column. 
This Is what ppx does. 
And. ppx needs to pp each element 
In case It Is a list. 
The second clause of pp matches If we wish to pretty-print something 
that Is not a list. 
We simply Indent to the specified column. use write to print the term. 
and print a new line. 
The first clause of pp also needs to terminate each list with a new 
line. hence the nl there. 
Notice that we have put the special case for pp before the catchall boundary condition. 
If we had put the second clause before the first one. then a list in the first argument of 
the goal would match with the X In the head of the rule. 
The result would be to simply 
write the whole list. without benefit of pretty-printing. So. we want the list case to be checked 
for first. 
This Is why we put the first clause before the second one. 
The second one Is 
used as a "catchall" rule. 
Another way to do this would be to put the boundary condition 
first. and include In its body a goal that falls If the first argument Is a list: 
pp(X,I) :- not(is_list(X», tab(I), write(X), nl. 
pp([HIT],I) :-
J is I+3, pp(H,J), ppX(T,J), nl. 
/* ppx as above */ 
is_list([]). 
is_list( [_1_]). 
We needed to define the appropriate predicate is_list such that the goal is_list(X) succeeds 

83 
If X Is a list. 
The first fact specifies that the empty list Is a list. 
The second fact specifies 
that a structure that has a head and a tall Is a list. 
let us consider the event facts from the beginning of this chapter. 
Given one of the 
history headlines represented as a list of atoms. we can use write to print out each atom. 
with a space In between each atom. 
Consider the predicate pbh (for "print history headline"): 
pbh( []) :- nL 
pbh( [HIT]) ,- write(H), tab( ~), phh(T). 
So. the following question would print out any history headline that mentions "England": 
?- event( _, L ), member(' Eng~and' ,L), pbh( L ) • 
Notice the use of backtracking to search the database. 
Everytlme the me.ber goal falls. an 
attempt Is made to re-satlsfy event, which causes the entire database to be searched 
top-to-bottom for events that mention the atom 'England'. 
The predicate write is clever about how It prints a term. because It takes Into account 
what operator declarations have been made. 
For Instance. If we have declared an atom as 
an Infix operator. a term with this atom as functor and two arguments will be printed out 
with the atom between the two arguments. 
There Is another predicate that behaves In exactly 
the same way as write, except that It Ignores any operator declarations that have been made. 
This predicate Is called disp~y. 
The difference between write and disp~y Is Illustrated 
by the following: 
?- write(a+b*e*e), n~, disp~ay(a+b*e*e), n~. 
a+b*e*e 
+( a, *( *(b,e ),e» 
yes 
Notice how disp~y has treated the atoms + and * just like any other atoms for printing out 
this term. 
We do not usually want to see our structures printed out In this way. because 
having operators usually helps us to read program output as well as prepare program Input. 
However. sometimes. If we are not quite sure about the precedences of our operators. using 
disp~ay can be quite helpful. 
The predicate read will read the next term that you type In from the computer termlnal's 
keyboard. 
The term must be followed by a dot (.) and a non-printing character such as 
a space or a RETURN. 
If X Is unlnstantlated. the goal read(X) will cause the next term to 
be read. and X to be Instantiated to the term. 
As with the other InpuVoutput predicates we 

84 
have encountered thus far. read only succeeds once. 
If Its argument Is Instantiated at the 
time it Is used as a goal. then the next term will be read. and matched with the argument 
given to read. 
The goal will succeed or fail. depending on the success of the match. 
Using 
read. and phh as defined above. we can write a Prolog program to print the 
historical headlines from the event database as follows: 
hello ,-
phh(['What', date, do, you, 'desire? ' ), 
read(D), 
event(D,S ), 
phh( S). 
We have defined a predicate hello. having no arguments. 
When we ask the question 
?- hello. 
Prolog will print: 
What date do you desire? 
and wait for a response. 
Suppose we type in: 
1523. 
Notice that we need to type in the dot after 1523. This is because the read predicate demands 
that a dot appear. 
Also. we must type in a RETURN. as usual. to inform the computer that 
we are finished with that line of text. 
Prolog will respond: 
Christian II flees from Denmark 
Notice also that the first clause of the body of hello uses phh, even though it is not intended 
to print a history headline. 
This simply shows that phh suffices also to print any list of atoms. 
no matter where that list came from. 
6.2 
Reading and Writing Character. 
The smallest entity that 'can be written and read is the character. 
As we have seen 
thus far. characters are treated as small Integers corresponding to the ASCII code for the 
character. 
Prolog has several built-in predicates for reading and writing characters. 
If X is Instantiated to a character (an ASCII code). it will be printed when Prolog 

85 
encounters the goal put(X). The predicate put always succeeds. and It cannot be re-satisfied 
(It falls when an attempt Is made to re-satlsfy It>. 
As a 'side effect'. put prints its argument 
as a character on your terminal's display. 
For example. we can print the word "hello" in 
a rather awkward way by: 
?- put(l04),put(lOl),put(l08),put(l08),put(lll). 
hello 
The result of this conjunction of goals Is that Prolog prints the characters h. e. I. I. and 
o. printing them out under the question as shown above. 
We have already seen that it Is 
possible to start printing at the beginning of the next line by using the nl predicate. which 
has no arguments. 
What nl actually does Is to print some control characters that cause 
the cursor on your computer terminal's display to move to the beginning of the next line. 
The question 
?- put(l04),put(105),nl,put(l16),put(l04),put(101),put(ll4),put(101). 
would cause the following to be printed: 
hi 
there 
Another goal we have seen is tab(X), which prints X spaces (ASCII code 32). 
Of course. 
X must be instantiated to an integer. 
Notice that tab (X) could have been defined as: 
tab(O) :- J. 
tab(N) :- put(32), Mis N-l, tab(M). 
We are now able to define a predicate that we shall call printstrinq. 
If we instantiate 
X to a list of character codes (a string). printstrinq(X) will print It out using put for each 
element of the list. 
As in all such programs. the boundary condition is the empty list. 
This 
Is what we will use to terminate the recursion. 
Otherwise. we simply use put to print the 
head of the list. and use printstrinq to print the tail of the list: 
printstring([). 
printstring([HiT) 
:- put(H), printstring(T). 
1- printstring("Charles V abdicates at Brussels"). 
Charles V abdicates at Brussels 
If we choose to represent a history headline as a string. rather than a list of atoms. such 
a definition will suffice to print the strings in the event database above. 

86 
Reading. 
Characters may be read from the keyboard by using the goals getO(X) and get(X). 
These goals always succeed If their argument Is un Instantiated. and they also cannot be 
re-satlsfled. 
When they are used. they make the computer walt until some characters have 
been typed by you. 
They are slightly different because getO(X) will Instantiate X to the very 
next character that Is typed. no matter what It Is. 
On the other hand. get:(X) will skip all 
non-printing characters. and Instantiate X to the first printing character. As we said In Chapter 
2. a printing character Is one that makes a mark on the computer termlnal's display. 
If X Is already Instantiated, then the goal get:(X) will skip all non-printing characters 
and compare the next printing character with whatever X Is Instantiated to. The goal succeeds 
or falls depending on the outcome of the test. 
The goal get:O(X) compares the next character 
for equality. and succeeds or falls. 
The next section shows some examples of reading characters. An Important consideration 
Is what happens when we need to backtrack over a get goal. 
6.3 
Reading English Sentences 
We now present the program that reads In a sentence typed at the terminal and converts 
It to a list of Prolog atoms. 
The program defines the predicate read.....in with one argument. 
The program must know when one word of the Input ends and the next begins. 
In order 
to know this. It assumes that a word consists of any number of letters. digits. and special 
characters. 
Letters and digits are the same as those discussed In Section 2.1. and we will 
consider the single quote (') and the hyphen (-) to be special characters. Also. the characters 
, ; 
: 1 I . 
are taken to form words on their own. 
Any other characters just mark space between words. 
The sentence Is deemed to have finished when one of the words .. I. or ? appears. Upper-case 
letters are automatically converted to lower-case. so that the same word always gives rise 
to the same atom. As a result of this definition. the program will produce question and answer 
sequences like: 
1- read.....in( S ) • 
'!'he man, who is very rich, saw John's watch. 
s - [the,man,·,·,Who,is,very,rich,saw,·johnt's·,watch,'.'] 
We have actually Inserted extra single-quote characters In this to make It clear what the atoms 
are. 

87 
The program uses the predicate geto to read In characters from the terminal. The trouble 
with geto Is that. once a character has been read from the terminal by It. that character 
has "gone for ever". and no other gato goal or attempt to resatlsfy a geto goal will ever 
get hold of that character again. 
So we must avoid ever backtracking over a use of ge1:0 
If we want to avoid "losing" the character It reads In. 
For Instance. the following program 
to read In characters and print them out again. converting 'a's to 'b's (character codes 97 
to code 98) will not work: 
go :- do_a.....cbaracter, go. 
do_a.....cbaracter :- geto(x), X=97 , I, put(98). 
do_a.....cbaracter :- geto(x), put(X). 
This Is not a particularly good program anyway. because It will run for ever. However. consider 
the effect of attempting to satisfy the do_a.....character goal. 
If the first do_a.....character rule 
reads In an X which Is not 97. backtracking then causes the second rule to be tried Instead. 
However. the getO(X} goal In the second rule will cause X to be Instantiated to the next 
character after the one already found. 
This Is because the satisfaction of the original gato 
goal was an Irreversible process. 
So this program would actually fall to print out all the 
characters. 
It would even sometimes print out a's. 
How does our relULin program cope with the problem of backtracking over Input? 
The 
answer Is that we must design it In such a way that It always reads one character ahead. 
and makes tests on a character Inside a different rule to the one where It was read. 
When 
a character is found somewhere and cannot be used at that point. It Is passed back to the 
rules that will be able to use It. 
Hence. our predicate to do with reading a single word. 
readword, actually has three arguments. 
The first Is for the character that was found by 
whichever rule last satisfied a geto goal but could not find a use for the character. 
The 
second Is for the Prolog atom that will be constructed for the word. 
The last argument Is 
for the first character that Is read after the word. 
In order to see where a word ends. It 
Is necessary to read up to the next character after It. 
This character must be passed back. 
because It might provide the valuable first character of another word. 
Here. then Is the program: 
/* Read in a sentence */ 
rea~in([WIWs]) :- geto(c), readword(C,W,C~), restsent(W,C~,Ws). 
/* Given a word and the character after it, read in the 
rest of the sentence */ 
restsent(W,_,[]) :-
~astword(W), I. 
restsent(W,C,[~IWs]) :-
readword(C,W~,C~), restsent(~,C~,Ws). 
/* Read in a sing~e word, given an initia~ character, 
and remembering what character came after the word */ 

88 
readword(C,W,C1) ,- single_character(C), I, name(W,[C), getO(C1). 
readword(C,W,C2) ,-
i~word(C,NeWC), I, 
getO(C1 ), 
restword(C1,Cs,C2), 
name(W,[NeWCICs). 
readword(C,W,C2) ,- getO(C1), readword(C1,W,C2). 
restword(C,[NeWClcs),C2) ,-
i~word(C,NeWC), I, 
getO(C1 ), 
restword(C1,Cs,C2). 
restword(C,[),C). 
/* These characters form words on their own */ 
single_character(44). 
single_character(59). 
single_character(58). 
single_character(63). 
single_character(33). 
single_character(46). 
/* , */ 
/* 
*/ 
/* 
*/ 
/* ? */ 
/* 
*/ 
/* 
*/ 
/* These characters can appear within a word */ 
/* The second i~word clause converts characters to lower-case */ 
i~word(C,C) 
C>96, C<123. 
i~word(C,L) ,- C>64, C<91, L is C+32. 
i~word(C,C) ,- C>47, C<58. 
i~word( 39, 39). 
i~word( 45, 45 ) . 
/* These words terminate a sentence */ 
1astword( , . ' ) . 
lastword('I'). 
lastword( , ? ' ) • 
/* a b .. z */ 
/* A B •• z */ 
/* 1 2 .. 9 */ 
/* 
*/ 
/* 
*/ 
Exercise g 
Explain what each variable in the above program Is used for. 
Exercise 5.2: 
Write a program to read in characters indefinitely, printing them out again with 
'a's changed to 'b's. 
5.4 
Reading and Writing Flies 
The predicates previously discussed in this chapter were used only for reading from or 
writing to your computer terminal, but they are actually more general than that. 
The Prolog 
system recognises a current Input stream, from which all input is read. 
All output Is written 
to the current output stream. 
The computer terminal's keyboard Is normally the current Input 
stream, and the terminal's display is normally the current output stream. 
Often it is useful 
to read or write 'lies, which are sequences of characters on a secondary storage medium. 
The particular medium depends on your particular computer installation, but nowadays we 

89 
usually read and write flies that are stored on magnetic discs. 
It Is assumed that each file 
has a filename that we use to Identify It. 
In order for this section to be understandable. 
you should be familiar with the conventions for organising and naming flies at your computer 
Installation. 
In Prolog. filenames are represented as atoms. but we cannot rule out the 
possibility of further Installation-dependent restrictions on the syntax of filenames. 
Flies have a certain length. 
That Is. they contain a certain quantity of characters. 
At the end of a file. there Is a special marker. called the end of file marker. 
We did not 
discuss the end of file marker previously. because It Is more usual to encounter the end 
of file marker on a file than on a computer terminal. 
If a program Is reading from a file. 
the end of file marker can be detected whether the program Is reading terms or characters. 
If a getO(X) encounters the end of a file. X will be Instantiated to a control character. normally 
the one with ASCII code 26. 
If read(X) encounters the end of a file. X will be Instantiated 
to some special term that depends on your particular Prolog system. 
If an attempt Is made 
to read beyond the end of a file. an error Is generated. 
There Is a built-In file called user. 
Reading this file causes Input to come from your 
computer termlnal's keyboard. and writing to this file will cause characters to be written on 
the display. This Is the normal mode of operation. When Input Is from the computer terminal's 
keyboard. an end of file can be generated by typing the end-of-flle control character <ASCII 
code 26. or control-Z>. 
This will make 'geto and read behave as though the end of a file 
has been encountered. 
Terms and characters can be written to flies by using exactly the same predicates as 
discussed earlier. The only difference Is that when we wish to write to a file. we must change 
the current output stream to be the file Instead of the computer termlnal's display. The current 
output stream Is changed by using the tel.1 predicate. 
If X Is Instantiated to a filename. 
which must be an atom. the goal tell(X) switches the current output stream so that any 
writing (done by write, put, and so forth) will be done to the file. Instead of to the computer 
termlnal's display. 
The tell(X) goal succeeds only once (It cannot be resatlsfled). 
Also. 
when Prolog backtracks over a tell goal. It does not reset the current output to what It was 
previously. 
As well as changing what Prolog considers to be the current output stream. tell 
also performs other operations In certain situations. 
The first time that we satisfy tell(X) 
for a particular X. Prolog assumes that we want to start a new file with that name. 
Therefore 
If X Is Instantiated to an atom that names a file that already exists. then any characters already 
In the file will be removed. 
On the other hand. If X Is Instantiated to an atom that does 
not name any existing file. then a file with that name will be created. 
In either ·case. the 
file Is now considered open (for output>. 
This means that subsequent writing to the file will 
add characters at the end of the file until we say explicitly that the file Is complete (until 
we close the file). 
At that point. If we try to write to It again. Prolog will assume that we 
want to write a new version as before. 
If we try to satisfy tell(X) when X is not instantiated. 

90 
or Is Instantiated to an object other than a filename. then an error occurs. 
The specific 
behaviour taken by the Prolog system when an error occurs depends on the particular 
Implementation of Prolog you are using. 
The predicate tel.ling Is used to find out the name of the file that Is the current output 
stream. 
The goal tel.l.ing(X) succeeds when X Is Instantiated to the name of the current 
output file. 
As you might expect. If X Is unlnstantlated. then t:el.ling will Instantiate It to 
the atom that makes the goal succeed. 
When all writing to a file has been completed. the predicate tol.d will end the file and 
close It (for output). 
Also. It will cause the current output to revert to the computer termlnal's 
display. 
So. a typical sequence Of goals to write some characters on a file would be: 
••• , tell(fred), writ:e(X), told, ••• 
If the current output stream Is switched without using t:ol.d on the previous file. the previous 
file will not be closed. but It Is stili available for writing. 
This allows you to write to a file 
at several different times. as In this example: 
••• , t:ell(X), writ:e(A), t:ell(user), write(B), tell(X), write(C), told. 
The predicates that Prolog makes available for switching the current Input stream are 
analogues of those discussed above. 
The goal see(X) switches the current Input stream to 
the filename specified. 
As with tel.l., the goal cannot be resatlsfied. and the operation Is 
not undone on backtracking. The first time we satisfy see(X) for some file X. that file becomes 
open (for Input). and we start at the beginning of the file. 
Subsequent Input continues from 
where It last left off. until we explicitly close the file. 
After that point. a new attempt to read 
from the file will open It and start from the beginning as before. 
The current Input stream 
can be discovered by satisfying seeing(X), and the current Input stream may be switched 
back to the computer termlnal's keyboard by seen, which also closes the file. 
Consulting 
Reading and writing flies Is most helpful when our programs deal with more terms than 
we care to type In by hand each time we want to put them In the database. 
In Prolog. 
files are used mainly to store programs. 
If we have the text of a Prolog program In a file. 
we can read all of the clauses In the file. and put them Into the database by using the predicate 
consul.t. 
When X Is instantiated to the name of a file. the goal consul.t(X) will read Prolog 
clauses and goals from the file. 
Most Implementations of Prolog have a special notation for 
consul.t:, which allows a list of flies to be consulted. one after another. 
If a list of atoms 

91 
is given as a Prolog question. then Prolog will consult each file in the list. 
An example of 
this notation is: 
1- [filel, mapper, expert]. 
This behaves as though Prolog were executing a goal consultal.l(X), were X is the list that 
we give the question. and where CODsultall might be defined as follows: 
consultall([]). 
consultall([HIT]) 1- consult(H), consultall(T). 
However. the shorthand list notation reduces effort. and this is especially important when one 
considers that the very first act that the practising Prolog programmer does is to consult 
a list of files to make available his favourite predicates. 
The consult predicate automatically 
stops reading clauses when the end of the file is encountered. 
Section 6.1 describes consult in more detail. 
5.5 
Declaring Operators 
Operators are considered in this 'input and output" chapter because operators provide 
syntactic convenience when reading or writing terms. 
There is no other reason for having 
operators. 
Let us first briefiy review Section 2.3. and then tell how operators are declared. 
The Prolog syntax provides for operators. each having three properties: a position, 
precedence, and associativity. 
The position can be Infix. postfix. or prefix (an operator with 
two arguments can go between them: an operator with one argument can go after or before 
It). 
The precedence is an integer whose range depends on the actual Prolog implementation. 
but we shall assume a range from 1 to 255. 
The precedence is used to disambiguate 
expressions where the syntax of the terms is not made explicit through the use of brackets. 
The associativity is to disambiguate expressions in which there are two operators in the 
expression that have the same precedence. 
In Prolog. we associate a special atom with an 
operator. which specifies its positlo!') and associativity. 
The possible specifiers for Infix 
operators are: 
xfx 
xfy 
yfx 
yfy 
To understand these specifiers. it helps to see them as "pictures" of pOSsible uses of the 
operators. 
In the pictures. the letter "f· represents the operator and 'x' and 'y' represent 
arguments. 
So in all of the above. the operator must appear between two arguments -- that 
is. it is an Infix operator. 
In accordance with this convention. 
fx 
fy 

92 
are two specifiers for prefix operators (the operator comes before Its one argument>. 
Also. 
xf 
yf 
are possible specifiers for postfix operators. 
You may be wondering why there are two letters 
available for Indicating arguments. 
The choice of 'x's and 'y's In these positions enables 
associativity Information to be conveyed. 
Assuming that there are no brackets. a 'y' says 
that the argument can contain operators of the same or lower precedence than this operator. 
On the other hand. an 'x' says that any operators In the argument must have a strictly lower 
precedence than this operator. 
Consider what this means for the operator +, defined as yfX. 
If we look at 
a + b + 0 
there are two possible Interpretations: 
(a + b) + 0 
a + (b + 0) 
The second of these Is ruled out. because It requires the argument after the first + to contain 
an operator of the same precedence (another +). 
This contradicts the presence of an 'x' 
after the 'f' of the specifier. 
Thus. In particular. an operator declared yfX Is left associative. 
Similarly. an operator 
declared xfy Is right associative. 
If we know the desired associativity of an Infix operator 
we are declaring. this means that the specifier Is uniquely determined. 
Note that the meanings of 'x' and .y' (In terms of what other operators can appear 
unbracketed In the relevant position) are the same In all the other cases as well. 
This means 
that. for Instance. the sequence 
not not a 
Is legal syntactically if not Is declared as fy, but Is Illegal If It Is declared a. 
In Prolog. If we wish to declare that an operator with a given position. precedence. and 
associativity Is to be recognised when terms are read and written. we use the built-In predicate 
op. 
If Rame Is the desired operator (the atom that we want to be an operator). Preo the 
precedence (an Integer within the appropriate range). and Spec the position/associativity 
specifier (one of the above atoms). then the operator Is declared by providing the following 
goal: 
?- op(Preo,speo,Name). 

93 
If the operator declaration Is legal. then the goal will succeed. 
As an example of declaring operators. the following is a complete list of declarations 
for the "core" operators discussed in this book. 
Particular implementations of Prolog may 
have slightly different operators as "standard" ones. and the precedences may be scaled to 
fit within another range. 
However. the order of operators within the precedence hierarchy 
is normally conventional. 
?-op(255,xfx,' ,-'). 
?-op(255,fx,'?-'). 
?-op(254,xfy,';' ). 
?-op(253,xfy,','). 
?-op(250,fx,spy). 
?-op(250,fx,nospy). 
?-op( 60, fx,not). 
?-op(51,xfy,'.' ). 
?-op(40,xfx, is). 
?-op( 40,xfx, '-•• ' ). 
?-op( 40,xfx,=). 
?-op(40,xfx, \=). 
?-op( 40,xfx, <). 
?-op(40,xfx,-<). 
?-op( 40,xfx, >=). 
?-op(40,xfx,». 
?-op(40,xfx,=-). 
?-op(40,xfx,\--). 
?-op( 31, yfx, - ) • 
?-op( 31,yfx,+). 
?-op( 21, yfx, / ) • 
?-op( 21,yfx,"). 
?-op(11,xfx,mod). 

Chapter 6. Built-In Predicates 
In this chapter. we introduce some of the "built-in" predicates that a Prolog system might 
provide. 
What do we mean when we say that a predicate is "built-in"? 
We mean that the 
predicate's definition is provided in advance by the Prolog system. Instead of by your own 
clauses. 
Built-In predicates may provide facilities that cannot be obtained by definitions In 
pure Prolog. 
Or they may provide convenient facilities just to save each programmer from 
having to define them himself. We have actually already come across some built-in predicates 
-- the predicates for reading and writing discussed In Chapter 5. 
Also. the "cut" could be 
regarded as a built-In predicate. 
The input/output predicates illustrate the fact that a built-in predicate may have "side 
effects·. 
That is. satisfying a goal involving it may cause changes apart from the instantiation 
of the arguments. 
This. of course. cannot occur with a predicate defined In pure Prolog. 
Another important fact about built-in predicates is that they may expect particular sorts of 
arguments. 
For instance. consider the predicate <. defined so that X < Y succeeds if the 
number X is less than the number Y. 
Such a relation cannot be defined in Prolog without 
some "outside help" that knows something about numbers. 
So < is provided as a built-In 
predicate. and its definition involves the use of some underlying machine operation for testing 
the comparative size of numbers (represented as binary patterns. or whatever). 
What should 
happen If we introduce a "less than" goal where X is an atom. or even if both X and Yare 
uninstantlated? 
The definition in terms of the machine will simply not apply. 
So we must 
stipulate that x < Y is only a sensible goal If both X and Yare Instantiated to numbers when 
an attempt Is made to satisfy it. 
What will happen If this condition is not met will depend 
on the individual Prolog implementation. 
One possibility is that the goal will simply fail. 
The 
other possibility is that an error message will be printed out. and the system wiil take some 
appropriate action (like abandoning trying to answ,er the current question). 
6.1 Entering new Clauses 
When you write a Prolog program. you will want to tell the system what clauses to use. 
as well as ask questions about them. 
You may want to type in new clauses at the terminal. 

95 
or to tell Prolog to take clauses from a file that you have prepared in advance. 
In fact. 
these two operations look the same from Prolog's point of view. because the terminal Is seen 
as just another file. with name user. 
There are two basic built-In predicates for reading 
in new clauses. consul.t and reconsul.t. 
In addition. there Is a convenient notation for when 
you want to read in clauses from more then one file -- the list notation. If you are Interested. 
simple definitions in Prolog of consul.t and reconsul.t are actually given in Section 6.4. 
consul.t(X) 
The built-in predicate consul.t is meant for those situations when you want the clauses 
In some file (or to be typed at the terminal> to augment those already in the database. 
The 
argument must be an atom giving the name of the file the clauses are to be taken from. 
What characters constitute a legal file name will. of course. depend on your particular computer. 
Examples of possible consul.t goals for various computers are: 
?- consult(myfile). 
?- consul.t( '/us/qris/pl/chat'). 
?- consult( 'lib:iorout.pl.'). 
When it has to satisfy a consul.t goal, Prolog reads through the file, adding the clauses It 
finds at the end of the database. 
As a result, the new clauses will appear after any already 
existing clauses for the same predicates. 
If a question is found in the file, this will be treated 
just like an ordinary question, except that the answer will not be printed out. 
It does not 
usually make sense to interleave questions with new clauses in a file, except to do things 
like declare new operators and print out helpful messages. 
reconsult(X) 
The predicate reconsul.t Is just like consul.t, except that the clauses read In are taken 
to supersede any existing clauses for the same predicate. 
Because of this, reconsul.t Is 
appropriate for correcting programming mistakes. 
If you read In several files of clauses and 
then discover that there is a mistake in one clause, you may be able to correct it without 
having to read In all the flies again. 
To do this, you just have to reconsul.t a file containing 
a correct set of clauses for the predicate in question. 
You can give the corrected clauses 
by either typing them at the terminal (reconsul.t( user» or by editing a file without exiting 
from Prolog (only possible in some implementations) and then reconsult -Ing that file. 
Of 
course, typing in revised clauses at the terminal will alter what Prolog sees in the database, 
but it will not change the file that the original. faulty, clauses came froml 
To see how consul.t and reconsul.t work in practice, here is an example Prolog session 
Involving their use. 
The session starts with the programmer having no clauses in the database. 
?- append([a,b,c,d),[e),X). 

96 
no 
?- consult(user). 
append([AIB],C,[AID]) ,- append(A,C,D). 
append( [] ,X,X). 
reverse( [ ]. [ ] ). 
reverse([AIB],C) ,- reverse(B,D), append(D,[A],C). 
/* the end of file character (control-Z) is typed here */ 
yes 
?- reverse([a,b,c,d,e],X). 
no 
?- append([a,b,c,d,e],[f],X). 
no 
?- append([],[a,b,c],X). 
x =,[a,b,c] 
yes 
?- reconsult(user). 
append( [AlB] ,C, [AID]) ,- append( B,C,D). 
/* the end of file character (control-Z) is typed here */ 
yes 
?-
revers~( [a,b,c,d],X). 
no 
?- consult(user). 
append( [] ,X,X). 
/* the end of file character (control-~) is typed here */ 
yes 
?- reverse([a,b,c,d,e],X). 
x = [e,d,c,b,a] 
yes 
In this session. the programmer starts by entering clauses for the predicates append and 
reverse from the terminal. 
Of course. he could have typed these Into a file first and then 
told Prolog to 'consult" that file. but for an example of this small size that might not have 
been worthwhile. 
Unfortunately. there Is a mistake in the first clause for append -- the goal 
contaIns an A where It should have a B. 
This mistake Is revealed when the system cannot 
answer his reverse and append questions. 
Somehow he realises that his definition of append 
Is wrong (in a real session. this would probably happen after use was made of the debugging 
aids described in Chapter 8). 
So he decides to supersede his existing definition with a new 
one. using reconsult. 
Unfortunately. In the new definition. he forgets to specify the boundary 

97 
condition (the [] case). 
So the program stili does not work. 
At this point. the original 
two-clause definition of append has been replaced by a new one-clause definition. which Is 
still not complete. 
The programmer sees what he has done.- and can rectify the situation 
by simply adding a new clause to the existing definition. 
This Is achieved with another use 
of consult. 
The program now works. 
The List Notation 
Prolog provides a special notation that makes It more convenient to specify consult and 
reconsult goals. especially when you want Prolog to look at more than one file. 
The notation 
Involves simply putting the fiie names (as Prolog atoms) Into a list. and giving that list as 
a goal to be satisfied. 
If you want a file to be consult -ed. you put the name Into the 
list as It Is. and if you want a file to be reconsult -ed. you precede the name with a '-' 
sign. 
Thus the question: 
1- [filel,-file2,'fred.I',-'bill.2']. 
is exactly equivalent to the longer version: 
1- consult(filel), reconsult(file2), consult( 'fred.I'), 
reconsult( 'bill.2'). 
The list notation Is purely a notational convenience. and does not offer any any extra facilities 
over and above those provided by consult and reconsult. 
Some Prolog Implementations 
may use a different sign than '-' In the list notation. but the effect is the same. 
6.2 
Success and Failure 
In the normal course of executing a Prolog program. a goal succeeds when it can be 
satisfied. and it falls when there is no way to satisfy It. 
There are two predicates that make 
it more convenient to specify when a goal succeeds or falls. 
These are the true and the 
fail predicates. 
This goal always succeeds. 
It is not actually necessary. as clauses and goals can be 
reordered or recombined to obviate any use of true. 
However. It exists for convenience. 
This goal always falls. 
There are two places where It is helpful. 
One place is the 
'cut fall" combination. which was described in Section 4.3. 
A conjunction of goals of the 

98 
form 
••• , I, fail.. 
Is used to say "If execution proceeds to this point. then one can abandon attempting to satisfy 
this goal." The conjunction fails. due to the fail., and the parent goal fails because of the 
cut. 
Another place to use fail. Is where you explicitly want another goal to backtrack through 
ail solutions. 
You may want to print out all the solutions. 
For Instance. 
?- event(x,y), phh(Y), fail.. 
would print out ail the events in the database of Section 5.1. using event and phh (and would 
then fall). 
See the definition of J:etractal.l. In Section 6.4 for another use of fail.. 
6.3 
ClaB8lfyfng Terms 
If we wish to define predicates which will be used with a wide variety of argument types. 
it is useful to be able to distinguish in the definition what should be done for each possible 
type. 
At the crudest level. we might wish a different clause to apply if an argument is an 
Integer than if the argument is an atom. Or we might want one clause to apply if the argument 
Is instantiated and another if it is not. 
The following predicates allow the programmer to 
put these extra conditions in his clauses. 
The goal var(X) succeeds if X is currently an uninstantiated variable. Here is an example 
of this predicate in use. 
The following program. which uses the reacLin predicate defined 
In Chapter 5. reads In English sentences typed at the terminal and assembles a list of all 
the words that are used (represented as Prolog atoms). In such a way that each one appears 
only once In the list. 
To do this. it keeps a structure that is like an ordinary list. except 
that it ends In an unlnstantiated variable. Instead of n. 
When a word comes along that is 
not In the list. the variable at the end is made to stand for a piece of list that contains 
the new word and ends in a new un instantiated variable. 
If a sentence typed in consists 
of a single word followed by a question mark (eg ·person?"). the program answers 'yes' or 
·no". according to whether the word has been encountered before. and does not record the 
word. 
go ,- readsentences(_). 
readsentences(List) ,-
reacLin( sent), 
continue_from(Sent,List). 

continue_from( [bye,'.' ),_) ,- I. 
continue_from( [Word, .? ) , List) ,- I, 
answer_in(Word,List), 
readsentences(List). 
continue_from(Sent,List) ,-
al1-members(Sent,List), 
readsentences(List). 
al1-members([),_). 
al1-members([WordIWords),List) ,-
member(Word,List), 
al1-members( Words, List) • 
member(X, [XI_). 
member( X, [_I List) 
,- member( X, List) • 
answer_in(W,List) ,-
really_in(W,List), I, 
write(yes), nl. 
answer_in(_,_) ,-
write(no), nl. 
really_in(W,List) ,- var(List), I, fail. 
really_in(W, [WI_). 
really_in(W,[_IList) 
,- really_in(W,List). 
99 
The Interesting things In this example are the use of member and the definition of really_in. 
The Idea Is that when an attempt Is made to satisfy the goal member(Word,List) (with Word 
standing for a word and List standing for the variable-terminated list). the goal will succeed. 
Moreover. If the word Is already In the list. the list will be unchanged. 
Otherwise. the list 
will afterwards have the word ·tacked onto· Its end. 
This Is an unusual use of member. 
The Idea is that we are giving it a list that is only partially defined (it ends with an uninstantiated 
variable). 
In order to satisfy the goal. Prolog can either find the word in the part of the 
list that is known. or it can instantiate the end of the list to a list with the word as a member. 
If the word is not already there. the transition. in terms of ·vine diagrams·. is from something 
like: 
.---.---.---.X (uninstantiated variable) 
I 
1 
1 
1 
john 
went 
home 
to 
to 
.---.---.---.---. 
Y (uninstantiated variable) 
1 
I 
I 
1 
I 
john 
went 
home 
to 
bed 
with X instantiated to: 
• ---y (uninstantiated variable) 
1 
bed 

100 
Now for the predicate rea11y_in. 
We have seen that If we use member to see if something 
Is In a list that ends with an uninstantiated variable. the goal will always succeed. Instantiating 
the list as necessary. 
So we need a special way of seeing If something is really In the 
list. 
So reall.y_in Is just like member, except that it will never further Instantiate the list. 
It does this by first of all checking whether It has reached the end of the list 
if so. it 
can fall immediately. 
To check whether it has reached the end. It uses var. 
nonvar(X) 
The goal nonvar(X) succeeds If X Is not currently an un Instantiated variable. 
The 
predicate nonvar is therefore the opposite of var. 
Indeed. it could be defined in Prolog by: 
nonvar( X) : - var( X ) , I, fail. 
nonvar(_) . 
The goal atom(x) succeeds if X currentiy stands for a Prolog atom. 
As a result. the 
following behaviour takes place: 
1- atom( 23 ) . 
no 
?- atom( apples) . 
yes 
1- atom( '/us/qris/pl.123&'). 
yes 
1- atom("this is a string"). 
no 
1- atom(X). 
no 
1- atom(book(bronte,w_h,X». 
no 
integer(X) 
The goal integer(X) succeeds If X currentiy stands for an Integer (a whole number), 
We can use this predicate In the definition of a simple simplifier for arithmetic expressions. 
Let us assume that we are presented with an expression containing numbers. "unknowns· <like 

101 
'x' and 'y') and additions of these. 
We can represent the numbers by Prolog Integers, the 
unknowns by Prolog atoms and the sum of two expressions by a use of the functor + (with 
two arguments). 
Let us also assume that the sum has been "flattened" so that the nesting 
of subexpressions within expressions Is well behaved. 
Thus we might be presented with: 
x + 1 + y + 23 + 3 + x + 4 
(Assuming that + Is left associative, this is really «(x+l)+y)+23) .. .l One form of simplification 
that could be performed on such an expression would Involve all the numbers being added 
together and the result being put at the front. 
This would yield: 
31 + x + y + x 
from the above example. 
Here is the definition of a predicate simpl.ify which will carry out 
this simplification. 
simplify(Expr,Expr1) ,-
simp1(Expr,0,Expr1). 
simp1(Expr+A,N,Expr1) ,-
integer( A) , I, 
N1 is N+A, 
simp1(Expr,N1,Expr1). 
simp1(Expr+A,N,Expr1+A) ,-
atom(A), I, 
simp1(Expr,N,Expr1). 
simp1(Rest,N,N1) ,-
integer(Rest), I, 
N1 is Rest+N. 
simp1(Rest,o,Rest) ,- I. 
simp1(Rest,N,N+Rest). 
The definition of simpl.ify makes use of another predicate simp1. 
This has an extra argument 
-- for the "running total" of all the numbers found so far in the expression. 
The program 
works Its way recursively down the expression, considering each of the things added up In 
turn. 
If it Is an integer, it is just added on to the running total (clause 1>: otherwise It Is 
put onto the result expression (clause 2). 
When the last thing In the expression is encountered 
(last three clauses) there are three possibilities. 
If the last item is an integer, the result 
(of simplifying this part of the expression) Is just the sum of It and the running total. 
Otherwise, 
If the running total is 0, the result Is Just the last item. 
Otherwise, the result Is the expression 
formed by the addition of the running total to the last Item. 
atomic(X) 
The goal atomic(X) succeeds If X currently stands for either an Integer or an atom. 
atomic can be defined in terms of atom and integer by 
atomic(X) ,- atom(X). 
atomic( X) ,- integer( X) . 

102 
6.4 Treating Clau888 as Terms 
Prolog allows the programmer to examine and alter his program (the clauses that are 
used to satisfy his goals). 
This Is particularly straightforward. because a clause can be seen 
as just an ordinary Prolog structure. 
Therefore Prolog provides "built-In" predicates to allow 
the programmer to: 
o 
Construct a structure representing a clause In the database. 
o 
Add a clause. represented by a given structure. to the database. 
o 
Remove a clause. represented by a given structure. from the database. 
Most operations that Involve retrieving Information from the database. changing It and adding 
the result to the database can be performed by the use of these predicates. together with 
the normal Prolog operations of constructing and decomposing structures. 
In addition to the 
examples given here. Section 7.B shows some of the uses one can make of predicates to 
add and remove clauses. 
Before we look at the relevant built-In predicates. It Is Important to see just how a Prolog 
clause can be seen as a structure. 
For a simple fact. the structure Is just the predicate 
with the arguments. 
That Is. something like 
likes(john,X) 
can be seen as an ordinary structure. with functor likes (with two arguments) and arguments 
john and x. 
A rule. on the other hand. can be seen as a structure whose main functor 
Is ' :-' (with two arguments). This functor Is declared as an Infix operator. The first argument 
Is the head of the clause. and the second Is the body. 
Thus 
likes(john,X) ,- likes(X,wine) 
is really just 
, :-' (likes( john,X),likes(X,wine» 
a perfectly normal structure. 
Finally. when there Is more than one goal In a rule. the 
goals are considered bound together by the functor ',' (with two arguments). 
This Is also 
declared as an Infix operator. 
Thus 
grandparent(X,Z) :- parent(X,Y), parent(Y,Z) 

103 
is "really· just 
',-'(grandparent(X,Z), ','(parent(X,Y),parent(Y,Z» 
Here now are the predicates that enable the programmer to examine and alter his clauses. 
Ustinq(A) 
Satisfying a goal of the form l.isting(A), where A is instantiated to an atom, causes 
all the clauses with the atom as predicate to be written out, as Prolog terms, on the current 
output file. 
This is how you check up on what clauses you currently have for some predicate. 
The exact format of the output will depend on your Prolog Implementation. 
Notice that you 
will see all the clauses with that atom as predicate, regardless of how many arguments it 
has. 
Using l.isting can help you discover a mistake in your program. 
For instance, in 
the following example session, the programmer discovers that he has not defined reverse 
properly. 
?- [test]. 
test consulted 
yes 
?- reverse([a,b,c,d],X). 
no 
?- listing(reverse). 
reverse([],[]). 
reverse([_44i_45],_38) 
yes 
,- reverse(_45,_47), 
appenDC47, £-44]'_38). 
The listing of the reverse clauses reveals that the atom append was mis-spelled in the 
program. 
cl.ause( X, Y) 
Satisfying a goal of the form c1ause(X, Y) causes X and Y to be matched with the head 
and body of an existing clause in the database. 
When an attempt is made to satisfy the 
goal. X must be Instantiated enough so that the main predicate of the clause is known. 
If 
there are no clauses for the predicate, the goal just fails. 
If there is more than one clause 
that matches, Prolog will pick the first one. 
In this case, if an attempt is made to resatisfy 
the goal. the other matching clauses will be picked, one at a time. 

104 
Notice that. whereas cliwse always has an argument for the body of a clause. not every 
clause actually has a body. 
If a clause does not have a body Cit Is a fact>. It Is considered 
to have the dummy body true. 
By providing X's and V's that are more or less Instantiated. 
you can look for either all the clauses for a given predicate and number of arguments. or 
all the ones that match some pattern. 
Thus. for Instance: 
append( [] .X.X). 
append([AIB].C.[AID]) :- append(B.c.D). 
?- clause(append(A.B.C).Y). 
A - []. B z _23. C = _23. Y - true; 
A -
[_231_24]. B - _25. C -
[_231_26]. Y = append(_24._25._26); 
no 
We can use cliwse to define a version of the listing predicate. 
Let us define listl. In 
such a way that. If we try to satisfy a goal l.istJ.(X) then all the clauses whose heads match 
X will be printed out. 
Since the definition of listl.(X) will Involve using cl.ause with X as 
Its first argument. we will have to stipulate that X Is sufficiently Instantiated that the main 
predicate Is known. 
Here. now. Is the definition of llBtl.. 
listl.(X) :- clause(X.Y). output_clause(x.Y). write('.'). nl. fail. 
listl.(X). 
output_clause(X.true) :- I. write(X). 
output_clause(x.Y) :- write«X :- Y». 
When an attempt Is made to satisfy a goal listl.(X). the first clause causes a search for 
a clause whose head matches X. 
If one Is found. that clause Is printed out and then a 
failure Is generated. 
Backtracking will reach the cliwse goal and find another clause. If there 
Is one. 
This will be printed out. a failure will be generated and backtracking will look for 
another clause. 
And so on. 
When there are no more clauses to be found. the cl.ause goal 
will not be able to be resatlsfled again. and so will fall. 
At this point. the second clause 
for listl. will be chosen. and so the goal will succeed. As a "side effect". all the appropriate 
clauses will have been printed out. 
The definition of output;...cliwse says how the clauses 
will be printed. 
It looks for the special case of the body true and In this case just writes 
out the head. 
Otherwise. it writes out the head and the body. put together with the functor 
1-. 
Notice the use of the "cut" here -- to say that the first rule Is the only valid possibility 
If the bOdy is true. 
Because this example relies on backtracking. the cut Is essential here. 
The built-In predicate cliwse can also be used to write a Prolog interpreter in Prolog. 
That is. we can define what it is to run a Prolog program by something which is Itself a 
Prolog program. 
Here is the definition of the predicate call.. in such a way that call.(X) 
succeeds as a goal exactly when X succeeds as a goal. 
In fact. call. is a built-In predicate 
(Section 6.7). and is not defined this way at all. 
call(true) :- I. 

call«Gl,G2» 
,- /, call(Gl), call(G2). 
call(Goal) ,- clause(Goal,Goals), call(Goals). 
105 
The first two clauses deal with the special cases of the goal true (which Is what clause 
considers to be the "body' of a fact) and a goal which Is a conjunction. 
The last clause 
covers a simple goal. 
The procedure Is to find a clause whose head matches It (there may 
be a choice here) and then call the goals In the body of that clause. 
Note that the above 
definition will not cope with programs using built-In predicates. because such predicates do 
not have clauses In the usual sense. 
asserta(X), assertz(X) 
The two built-in predicates asserta and assertz allow one to add new clauses to the 
database. 
The two predicates act in exactly the same way. except that asserta adds a clause 
at the beginning of the database. whereas assertz adds a clause at the end C'a' Is the first 
letter of the alphabet. and 'z' is the last). In a goal asserta(X), X must be already instantiated 
to something representing a clause; indeed. as for clause, it must be sufficiently instantiated 
that the main predicate can be established. 
It is Important to stress that the action of adding 
a clause to the database is not undone when backtracking takes place. 
Therefore. once we 
have used asserta or assertz to add a new clause. that clause will only be removed If we 
explicitly say so (using retract, discussed below). 
Let us see an example of one of these predicates in action. 
There follows a definition 
of the predicate consult. 
Of course. consult is provided as a built-in predicate in most 
Prolog systems. 
Nevertheless. It Is interesting to see how we could define It In Prolog If 
we wished to. 
consult(File) ,-
seeing( Input), 
see(File ), 
repeat, 
read( Term), 
process( Term) , 
seen, 
see( Input), /. 
process(Term) ,-
en~of_file_mark(Term), /. 
process« 1- Q» 
,- /, call( Q), I, fail. 
process(Clause) ,- assertz(Clause), fail. 
There are several Interesting points about this definition. apart from the use of assertz. 
Firstly. the goal seeing(Input) and Its partner see(Input) are just to ensure that. however 
the definition of consult is used. the current input file will not be different afterwards from 
what it was before. 
Secondly. we have used the predicate en~o:Lfile..,Jllilrk without defining 
It. e~o:Lfile..,Jllilrk(X) Is supposed to succeed only If X Is what would be the result of a 
read that encountered the end of a file (see Section 5.4). 
Different Prolog implementations 
have different terms to represent "end of file". and so the predicate en~o:Lfile_mark would 

106 
have to be defined differently for different implementations. 
One possible definition would be: 
The point of the definition of process Is to cause an appropriate action to be taken for each 
term read from the input file. 
The definition is such that it only succeeds when the term 
is actually the end of file mark. 
Otherwise a failure occurs after the appropriate action and 
backtracking goes back to the repeat goal. 
Note the importance of the "cut" at the end 
of the consu1t definition. 
This cuts out the choice Introduced by the repeat, and hence 
allows backtracking to go back further than the original consu1t choice. 
A final point --
if a term read from the file represents a question (second clause for process) an attempt 
is made to satisfy the appropriate goal using the ca11 built-In predicate (Section 6.7). 
retract(X) 
The built-in predicate retract enables a program to remove clauses from the database. 
The predicate takes a single argument. representing a term that the clause Is to match. 
The term must be sufficiently instantiated tnat the predicate of the clause can be determined 
(as for asserta, c1ause, etc). 
When an attempt is made to satisfy a goal retract(x), X 
is matched with the first clause in the database that it can be matched with. and that clause 
is removed. 
When an attempt is made to resatlsfy the goal. Prolog searches on from that 
clause. looking for another one that will match. 
If It finds one. the same thing happens as 
before. If an attempt is made to resatlsfy it again. the search continues for another appropriate 
ciause. 
And so on. 
Note that. once a clause has been removed it is never reinstated. even 
when backtracking tries to resatlsfy the retract goal. 
If at any time the search cannot find 
any more matching clauses. the goal falls. 
Because the argument X is matched with a clause as it is removed. it is possibie to 
see exactly which clause has been removed. even if X originally stood for something with 
lots of uninstantiated variables In it. 
So one can use retract to duplicate the function of 
c1ause, in the case that one wants to remove the clause after finding It. 
This Is how It 
Is used in the definition of gensym (Section 7.8). 
As an exampie of the use of retract, here Is the definition of a useful predicate called 
retracta11. 
When the goal retracta11(X) is satisfied. all the clauses whose heads match 
X are removed from the database. 
Because the definition uses retract, X cannot be 
uninstantiated. for otherwise the predicate of the clause couid not be determined. 
In the 
definition. we must deal with the two cases of a clause whose head matches X -- a clause 
with no body (a fact) and a clause with a body (a rule). We have to provide different arguments 
to retract in order to get at these two types of clauses. 
The definition uses the fact that. 
If we allow a retract goal to backtrack. eventually all the clauses matching the argument 

will be removed. 
retractall(X) ,- retract(X), fail. 
retractall(X) ,- retract«X,-Y», fail. 
retractall( _ ) • 
107 
As an example of the predicate retractall in use. here is a definition In Prolog of 
the predicate reconsult. 
The meaning of reconsult Is essentially the same as that of 
consult, except that any clauses read are taken to supersede existing clauses for the same 
predicate. rather than add to them (see Section 6.1). 
reconsult(File) ,-
retractall(done(_», 
seeing( Old), 
see(File), 
repeat, 
read( Term) , 
try(Term), 
seen, 
see(Old), I. 
try(X) ,- enCLoCfile_mark(X), I. 
try(?-Goals) ,- I, call(Goals), I, fail. 
try( Clause) ,-
head(Clause,Head), 
record_done(Head), assertz(Clause), fail. 
record_done(Hd) ,- done(Hd), I. 
record_done(Hd) ,-
functor(Hd,Func,Num), 
functor(Proc,Func,Num), 
asserta(done(Proc», 
retractall(Proc), I. 
head«A,-B),A) 
I. 
head(A,A) . 
This definition actually looks very similar to what we had for consult, with try taking the 
place of the predicate process. 
The main difference is the use In the definition of 
recorCLdone. 
The Idea behind this Is that. when the first clause for a given predicate appears 
in a file. all the existing clauses for that predicate must be removed before the new one 
Is added. 
We must not remove clauses when later ones for that predicate appear. because 
then we will be removing clauses that have just been read In. 
How can we tell whether a 
clause Is the first one In the file for Its predicate? 
The answer is that we keep a record 
in the database of which predicates we have so far found clauses for in the file. 
This Is 
done through the predicate done. 
When the first clause for a predicate. for Instance foo 
with two arguments. appears. the existing clauses are removed. and the new clause Is added 
to the database. 
In addition. the fact 
done( foo( _,_) ). 

108 
Is added. 
When a later clause for the predicate appears. we will be able to see that the 
old clauses have already been removed. and so we can avoid accidentally removing new 
clauses. 
It Is Important for the definition that we don't add something like: 
done( foo( a,x». 
because then the argument of done will not necessarily match the head of an Incoming clause 
for foo. 
The pair of goals: 
... , functor(Hd,Func,Num), functor(Proc,Func,Num), 
have the effect of making Proc stand for a structure with the same functor as the head Hd. 
but with variables as Its arguments (see Section 6.5). 
Exercise g 
Write a version of 1istl that displays the clauses in a nicer format. using 
indentation and multiple lines. rather than just all squashed onto one line. 
6.5 Creating and Acce88lng Components of General Structures 
Normally when we want to talk about a structure of a certain kind in a 
Prolog program. 
we do so by just "mentioning" such a structure. For Instance. consider the following definition 
of the predicate eva1uate. 
evaluate(A+B,ReS) ,-
evaluate(A,Resl), 
evaluate(B,Res2), 
ReS is Resl+ReS2. 
evaluate(A-B,Res) ,-
evaluate(A,ReSl), 
evaluate(B,Res2), 
Res' is Resl+Res2. 
evaluate(A,A) ,-
integer( A) . 
If we give Prolog a goal for the predicate evaluate, with the first argument Instantiated to 
an expression made up of integers and '+'s and '-·s. it will instantiate the second argument 
to the number obtained by evaluating the expression. 
Thus we will get interactions like: 
?- evaluate(3+(2-4)+S-6,X). 
x = 0 
In this definition. we knew that there were only two possible types of structure (apart from 
numbers) that might appear In the first argument posltio.n. 
So we just mentioned them in 
separate clauses for the predicate. If we wanted to allow another kind of structure. for instance 
with the functor * with two arguments.' we could just add another clause. 
For this program. 

109 
we can always anticipate exactly what structures will appear. 
However. this will not always 
be the case. 
What would happen if we wanted to write a program that took ~ny structure 
as Its first argument and displayed It on the terminal. as In the following example? 
?- output(mother(fred,mary». 
the mother of fred is mary 
yes 
?- output(difference(6,2,4». 
the difference of 6 and 2 is 4 
yes 
?- output(a+(b+c». 
the + of a is (b+c) 
yes 
?- output([a,b,c]). 
the • of a is [b,c] 
yes 
In case the pattern of these examples 15 not yet clear. the purpose of output Is to produce 
output in the fOllowing format: 
the functor of a/l arguments but one is last argument 
That Is. the functor of the argument is displayed after the word 'the'. 
Then comes the word 
·of'. followed by all the arguments but one (separated by the word 'and'). 
Finally come the 
word '15' and the last argument. 
It 15 not clear from the examples what should happen when 
the structure has fewer than 2 arguments. 
But that need not bother us for now. The Important 
point Is that we want this program to work whatever kind of structure (with at least two 
components) we give it. 
One possibility. of course. is to provide a clause for every functor 
we can possibly think of. 
But this Is a task that we will never finish. because there are 
Infinitely many of theml 
The way to write this kind of program 15 to use built-in predicates 
that perform operations on general structures. 
We will now describe some of these -- the 
predicates functor, arg and '= •• '. We will also describe a predicate that works on general 
atoms. the predicate name. 
functor(T,F,IJ) 
The predicate functor is defined In such a way that functor(T,F,IJ) means HT Is a 
structure with functor F and arlty (number of arguments) N". 
It can be used In basically 
two ways. 
In the first way. T is already Instantiated. 
The goal falls If T Is not an atom 
or a structure. 
If T Is an atom or structure. F Is matched with the functor and N Is matched 
with the number giving the arlty (number of arguments) of the functor. Note that In this context. 
an atom is considered to be like a structure with arlty O. 
Here are some examples of goals 

110 
involving functor: 
?- functor( f( a,b, g( Z) ),F ,N). 
Z = _23, F = f, N = 3 
?- functor(a+b,F,N). 
F = +, N = 2 
?- functor([a,b,c],F,N). 
F=.,N=2 
?- functor(apple,F,N). 
F = apple, N = 0 
?- functor( [a,b,c],' .' ,3). 
no 
?- functor([a,b,c],a,Z). 
no 
In fact. 
functor is just what we need for the first part of the definition of output. 
One 
of the first things that the clauses for output must do Is cause the functor of the argument 
to be found and printed out. 
As we will see, the definition starts out: 
output(S) :- functor(S,Fn,_), 
write( 'the'), write(Fn), ... 
Before we can give the rest of the definition. we need to show how the arguments of a general 
structure can be obtained. 
This is what the predicate arg, described in the next section. 
is for. 
Before we go on to iook at arg, we should consider the second possible use for functor. 
This occurs when the first argument of the goai (T) is uninstantiated. 
in this case, both 
of the others must be instantiated --
specifying a functor and a number of arguments 
respectlveiy. A goal of this form will aiways succeed. and as a result T will become instantiated 
to a structure with the functor and number of arguments provided. 
So this is a way of creating 
general structures. given a specification in terms of a functor and its number of arguments. 
The arguments of such a structure created by functor are uninstantiated variables. 
Hence 
the structure will match any other structure with the same functor and number of arguments. 
We can use this facility to make an improved version of a predicate defined in the last section. 
We defined the predicate listl in such a way that goals for It would cause the clauses for 
given predicates to be displayed on the terminal. As we remarked there. this facility is actually 
already provided more conveniently by the built-in predicate listing. 
The trouble with listl 
Is that we had to specify a predicate by giving a structure with the right functor and variables 
as its arguments. 
Thus to get the clauses for sentence with 14 arguments. we would have 

111 
laboriously to type: 
1- listl(sentence(_,_,_,_,_,_,_,_,_,_,_,_,_,_». 
Now that we know about functor, we can use It to create this structure for us. 
We can 
now define a new predicate list2 (this time with two arguments). as follows: 
list2(Functor,Arity) ,- functor(struct,Functor,Arity), listl(struct). 
Now we Just need to specify the functor and the number of arguments. 
We can achieve the 
effect of the last question by simply: 
?- list2(sentence,14). 
This saves a lot of typlngl 
A common use of functor to create a structure Is when we wish to make a ·copy· 
of an existing structure with new variables as the arguments of the principal functor. 
We 
can encapsulate this use In the definition of a predicate copy, as follows: 
copy(Old,New) ,-
functor(Old,F,N), 
functor(New,F,N). 
Here. two functor goals occur adjacently. 
If the copy goal has the first argument Instantiated 
and the second uninstantlated. then the following will happen. 
The first functor goal will 
Involve the first possible use of the predicate (because the first argument will be Instantiated). 
Hence F and N will become instantiated to the functor and number of arguments of this existing 
structure. 
The second functor goal uses the predicate In the second way. 
This time the 
first argument is unlnstantiated. and the Information In F and N Is used to construct the 
structure New. 
This Is a structure Involving the same functor and number of arguments as 
Old. but with variables as Its components. 
Thus we would get Interactions like: 
?- copy(sentence(np(n(john»,v(eats»,X). 
We used a combination of functor goals in this way In the definition of reconsul.t In Section 
6.1. 
arq(I!I,T,A) 
The predicate arg must always be used with Its first two arguments Instantiated. 
It Is 
used to get hold of a particular argument of a structure. 
The first argument of arg specifies 
the number of the argument required. 
The second specifies the structure that the argument 

112 
is to be found inside. 
Prolog finds the appropriate argument and then tries to match it with 
the third arg 
argument. 
Thus arg(H,T,A) succeeds if the Nth argument of T is A. 
Let 
us look at some goals involving argo 
?- arg(2,re1ated(john,mother(jane»,X). 
x = mother( jane) 
?- arg( 1,a+(b+c) ,X). 
X = a 
?- arg(2,[a,b,c],X). 
X = [b,c] 
?- arg( 1, a+(b+c),b). 
no 
Now that we have Introduced arg, we can provide the compiete definition of our predicate 
output: 
output(S) :- functor(S,Fn,_), 
write('the '), write(Fn), write(' of '), 
output_a11_but_one(S), write(' is '), 
output_1ast_arg(s), n1. 
output_a11_but_one(s) :- functor(S,_,O), I. 
output_a11_but_one(s) :- functor(S,_,Ar), 
N is Ar-1, o_args(l,N,S). 
0_args(N1,N2,_) :- N1>N2, I. 
0_args(N1,N1,S) :- I, arg(N1,S,A), write(A). 
0_args(N1,N2,S) :- arg(N1,S,A), write(A), 
write(' and '), N3 is N1+1, 0_args(N3,N2,S). 
output_1ast_arg(S) 
functor(S,F,N), 
(N=O; (arg(N,S,A),write(A»), I. 
Let us look at another exampie where functor and arg are used together. 
We use 
them to define the relation of substitution. 
This enables us to see what a term will look 
like If all occurrences in It of a second term are substituted by another term. 
We introduce 
a predicate substitute with four arguments. 
The first two specify what is to be substituted 
for what. 
The second two give the term inside which substitution will take place and the 
term that will result after the substitution. 
We can read substitute(A,B,C,D) as saying "the 
result of substituting A for B Inside C is 0". 
Thus: 
?- substitute(john,mary,father(mary),x). 
X = father(john) 
?- substitute(b,a,[a,b,c,d,e],X). 

x - [b,b,e,d,e] 
Here Is the definition of substitute. 
substitute(New, Old, old, New) 1- I. 
substitute(New,old,Val,Val) 1- atomie(Val), I. 
substitute(New,old,Val,Newval) 1-
functor(Val,Fn,N), 
functor(NeWVal,Fn,N), 
subst_args(N,New,Old,Val,NeWVal). 
subst_args(O,_,_,_,_) :- I. 
subst_args(N,New,Old,Val,NeWVal) 1-
arg(N,Val,OldArg), 
arg(N,Newval,NewArg), 
substitute(New,Old,OldArg,NewArg), 
Nl. is N-l., 
subst_args(Nl.,New,old,val,NeWVal). 
113 
Again. we use functor and azg In the definition of substitute because we do not know 
In advance what structures will be given. 
Nevertheless. we want to be able to look down 
Into the arguments. whatever structures they are. 
Sometimes we will want to use functor and arg when' the possible structures are known. 
This Is because there may be so many arguments that It Is Inconvenient to specify them every 
time. 
Consider an example where we use structures to represent books. 
We might have 
a component for the title. the author. the publisher. the date of publication. and so on. 
Let 
us say that the resulting structures have 14 components. 
We might write the 
following useful 
definitions: 
title(hook(T,_,_,_,_,_,_,_,_,_,_,_,_,_),T). 
author(hook(_,A,_,_,_,_,_,_,_,_,_,_,_,_),A). 
In fact. we can write these much more compactly as: 
is_a-book(X) ,- funetor(X,hook,1.4). 
titl.e(X,T) ,- is_a-book(X), arg(l.,X,T). 
autbor(X,A) ,- is_a....hook(X), arg(2,X,T). 

114 
functor and arg provide one way of creating and accessing arguments of general 
structures. 
The predicate = •• (pronounced "univ· for historical reasons) provides an alternative 
way, which 15 useful if you want to obtain the arguments of a structure all together, or if 
you want to construct a structure, given a list of arguments. 
x =.. 
L means "L 15 the list 
consisting of the functor of X followed by the arguments of X·. 
Such a goal can be used 
In two ways, In the same way that a functor goal can. 
If X Is Instantiated, Prolog creates 
the appropriate list and tries to match it with L. 
Alternatively, If X Is unlnstantiated, the list 
will be used to construct an appropriate structure for X to stand for. 
In this case, the head 
of L must be an atom (it will become the functor of Xl. 
Here are some examples of = •• 
goals: 
?- foo(a,b,c) 
x, 
x = [foo,a,b,c] 
?- append( [AlB] ,e, [AID]) =" 
L. 
A = _2, B = _3, e = _4, D = _5, 
L = [append, [_21_3] ,_4, [_21_5]] 
?- [a,b,c,d] = .. L. 
L = ['.',a,[b,c,d]]. 
?- (a+b) =.. 
L. 
L = [+,a,b]. 
?- (a+b) =" 
[+,X,Y]. 
x = a, Y = b, 
?- [a,b,c,d] = .. [XIY]. 
x = ',', Y = [a,[b,c,d]] 
?- X =., [a,b,c,d]. 
x = a(b,c,d). 
?- X = .. [append, [a,b], [c], [a,b,c]]. 
X = append([a,b],[c],[a,b,c]) 
Here is another definition of substitute, using = •• 
substitute(New,Old,old,New) ,- I. 
substitute(New,Old,val,Val) ,- atomic(Val), I. 
substitute(New,Old,Val,NewVal) 
Val =,. [FnIArgs], 
subst_args(New,Old,Args,NeWArgs), 
NewVal =,. [FnINewArgs]. 

subst_args(_,_,[],[]) :- I. 
subst_args(New,Old,[ArgIArgs],[NeWArgINeWArgs]) :-
substitute(New,Old,Arg,NewArg), 
subst_args(New,Old,Args,NewArgs). 
name(A,L) 
115 
Whereas functor, arg and = •• are for creating and accessing general structures, the 
predicate IUDIe is for dealing with general atoms. name relates an atom to the list of characters 
(ASCII codes) that make It up. 
This can be used either to find the characters for a given 
atom. or to find the atom that has some given characters. name(A,L) means that "the 
characters for the atom A are the list L". 
If the argument A Is instantiated. Prolog creates 
the list of characters and tries to match them with L. 
Otherwise Prolog uses the list L to 
make an atom for A to stand for. 
Example uses of name are as follows: 
?- name(apple,X). 
x = [97,112,112,108,100] 
?- name(X,[97,112,l12,108,100]). 
x = apple 
?- name( apple, "apple"). 
yes 
?- name( apple, "pear" ) . 
no 
As an example of IUDIe in use. let us assume that we are representing English words as atoms. 
We might want to capture the relationship between a noun in its singular and plural forms. 
One way to do this would be to write a clause for each noun: 
plura~form(aardvark,aardvarks). 
plura~form(abacus,abacuses). 
plura~form(abattoir,abattoirs). 
plural_form(zygote,zygotes). 
This would be very laborious and time consuming. 
It is much better to provide a general 
rule for plural forms. and just specify the exceptions separately. 
We can do this by using 
the name predicate'. thus: 
plural-forme abacus, abacuses) 
I . 

118 
this. the above definitions should be rewritten as: 
new_get(x) :- repeat, geto(x). 
get(x) :- new_get(X), X.32, I. 
(Note that this definition will stili only work If we attempt to satisfy get(X) with X unlnstantlated) 
Because of the problem of backtracking over repeat choices. everything using __ get should 
be responsible for cutting out the choice as soon as the character generated Is satisfactory 
for Its purposes. 
In particular. the following definition of a predicate to type out the contents 
of a file needs the cut so that once the end of file has been reached (taken to be character 
code 26 here). backtracking never causes an attempt to read more characters. 
type(File) ,- see(File), tell(user), 
new_get(X), put(X), 
X-26 , I, seen. 
6.7 
Creatll/fl Complex Goals 
In rules and questions of the form X ,- Y or 1- Y, the term appearing as Y may consist 
of a single goal. or a conjunction of goals. or a disjunction of goals. 
Furthermore. It Is 
possible to have variables as goals. and to satisfy a goal when the goal actually falls by using 
nat. The predicates described In this section provide ways to specify more complicated ways 
of expressing goals. 
~.L! 
The .,. operator specifies a conjunction of goals. 
This operator was Introduced In Chapter 
1. 
Where X and Yare goals. the goal x, Y succeeds If X succeeds and If Y succeeds. 
If X succeeds and then Y falls. then an attempt Is made to re-satlsfy X. 
If X falis. then 
the entire conjunction falls. 
This Is the essence of backtracking. 
The operator , Is left 
associative. which means that 
x, Y, Z 
means 
(X , Y) , Z 
~L ! 

117 
Consider the built-In predicate geto. which Is described In Chapter 5. 
If Prolog comes 
across a goal getO(X) It takes this as an Instruction to look at the next character (letter. 
digit. space or whatever) that has been Input to the system and to try and match the integer 
representation of this character with whatever value X has. 
If It will match. the goal succeeds; 
otherwise It falls. 
There Is no choice Involved -- geto always only considers the character 
which comes next at the time It is Invoked. 
The next time a goal Involving geto Is Invoked. 
It will find the character after this. but again there will be no choice. 
We can define a new 
predicate n __ get as follows: 
new_get(x) :- repeat. geto(x). 
The predicate n __ get has the property that it generates the values of all the next characters 
(in the right order) one by one as its alternative solutions. 
Why is this? 
When we first call 
n __ get(x). the subgoal repeat succeeds and the subgoal geto(x) succeeds with the value 
of the next character associated with X. 
When we backtrack. the last place where there was 
a choice Is In the satisfaction of repeat. 
So Prolog forgets everything It has done since 
then and succeeds in establishing repeat in another way. 
It now has to look at the subgoal 
getO(X) again. 
By now. the "next character" Is the one after what we last saw. and so X 
ends up with the second character as its value. 
We can use our definition of n __ get to define another useful predicate. 
The predicate 
get Is normally provided as a built-in predicate in Prolog systems. 
When Prolog finds a 
goal get(X). It treats this as an Instruction to read characters until It finds the next proper 
printing character (not a space. newline or whatever). 
It then tries to match the Integer 
representation of this character with X. 
We can write an approximate definition of get as 
follows: 
get(x) ,- new_get(x), X>32. 
To understand this definition. one must realise that the printing characters all have Integer 
values above 32. whereas the others all have values 32 or less. 
What happens when we 
try to satisfy get(x)? 
First of all. n __ get(X) matches X against the next character coming 
In. 
If the value is less than or equal to 32. the next goal will fall. and n __ get will have 
to generate the next character as the next possible solution. 
This will then be compared 
to 32. and so on. 
Eventually. n __ get will find a printing character. the comparison will 
succeed. and the value of this character will be returned as the result of get. 
Exercise 6.2: The above definition of get will not necessarily work if we invoke the goal get(X) 
when X is already instantiated. 
Why Is this? 
One trouble with repeat Is that It always has a choice to redo when backtracking 
reconsiders It. 
So backtracking will never be able to reconsider choices made earlier than 
the last call of repeat unless we manage to cut out the choice In some way. 
Because of 

118 
this. the above definitions should be rewritten as: 
new_get(x) 1- repeat, geto(x). 
get(x) ,- new_get(x), X.32, I. 
(Note that this definition will stili only work If we attempt to satisfy get(X) with X unlnstantlated) 
Because of the problem of backtracking over repeat choices. everything using __ get should 
be responsible for cutting out the choice as soon as the character generated Is satisfactory 
for Its purposes. 
In particular. the following definition of a predicate to type out the contents 
of a file needs the cut so that once the end of file has been reached (taken to be character 
code 26 here). backtracking never causes an attempt to read more characters. 
type(File) 1- see(File), tell(user), 
new_get(x), put(X), 
X-26 , I, seen. 
6.7 
Creating Complu Goal. 
In rules and questions of the form x ,- Y or ?- Y, the term appearing as Y may consist 
of a single goal. or a conjunction of goals. or a disjunction of goals. 
Furthermore. It Is 
possible to have variables as goals. and to satisfy a goal when the goal actually falls by using 
not. The predicates described In this section provide ways to specify more complicated ways 
of expressing goals. 
;!!;L! 
The .,. operator specifies a conjunction of goals. 
This operator was Introduced In Chapter 
1. 
Where X and Yare goals. the goal x, Y succeeds If X succeeds and If Y succeeds. 
If X succeeds and then Y falls. then an attempt Is made to re-satlsfy X. 
If X fails. then 
the entire conjunction falls. 
This Is the essence of backtracking. 
The operator , Is left 
associative. which means that 
x, Y, Z 
means 
(X , Y) , Z 

119 
The ';' operator specifies a disjunction of goals <X or Y>. 
When X and Yare goals. the 
goal x;y succeeds If X succeeds or If Y succeeds. 
If X falls. then an attempt Is made to 
satisfy Y. 
If Y then falls. the entire disjunction falls. 
We can use the J operator to express 
alternatives within the same rule. 
For Instance. let us say that something Is a person If It 
Is either Adam or Eve. or If It has a mother. 
We can express this In a single rule as follows: 
person( X) : -
(X=adam; 
X_ve; DIOi:her( x, y» . 
In this rule. we have actually specified three alternatives. 
However. as far as Prolog Is 
concerned. this breaks down Into two alternatives. one of which Itself Introduces two alternatives. 
Because J Is declared as a right associative (rly) operator. the goal In the clause Is actually 
the same as: 
';'( X-adam, '/'(x-eve,DIOi:her(X,Y» 
) 
So the first possibility Is that X Is Adam. 
The second possibility Involves the two alternatives 
that X Is Eve or X has a mother. 
We can put disjunctions anywhere where we can put any other kind of goal In Prolog. 
However. It Is advisable to add extra brackets to avoid confusion about how the operators 
; and , Interact. 
We can usually replace a use of disjunction with a use of several facts 
and rules. possibly Involving the definition of an extra predicate. 
For Instance. the above 
example Is exactly equivalent to: 
person( adam) • 
person( eve) • 
person(X) :- DIOi:her(X,Y). 
The effect of a 'cut' Includes 'freezing' any choices made because of disjunctions since the 
rule was matched (Chapter 4). 
Because of this. there are some cases where a program 
with 'cuts' cannot be translated Into one without disjunctions. 
However. in general you are 
not recommended to use ; excessively. 
Refer to Chapter 8 for warnings on how injudicious 
use of ';' may lead to programs that are difficult to understand. 
caU(X) 
It is assumed that X is instantiated to a term that can be interpreted as a goal. 
The cau(X) 
goal succeeds if an attempt to satisfy X succeeds. The cal.I goal falls If an attempt to satisfy 
X fails. 
At first sight. this predicate may seem redundant. because one might ask why the 
argument of cal.I shouldn't simply appear by itself as a goal? 
For Instance. the goal 
••• I 
cal.l( member( a, X», ... 

120 
can always be replaced by 
••• , meiDber(a,X), ••• 
However. If we are constructing goals by using the '-•• ' operator or Its friends. then It Is 
possible to call goals that have a functor that Is unknown at the time you type In your program. 
In the definition of coDSUl.t In Section 6.4. for Instance. we want to be able to treat any term 
read after a ?- as a goal. 
Assuming that P. X. and Yare Instantiated to a functor and 
arguments appropriately. cal.l can be used as follows: 
Z = •. [P,X,Y], ca11(Z), ... 
The above line can be thought of as a way of expressing the following sort of call. which 
Is not correct syntax In the standard version of Prolog we are using In this book: 
••• , P(X,Y), ••• 
However. some versions of Prolog do permit the use of variable functors In goals. 
It Is assumed that X Is Instantiated to a term that can be Interpreted as a goal. 
The not 
goal succeeds If an attempt to satisfy X falls. 
The not goal falls If an attempt to satisfy 
X succeeds. 
In this way. not Is rather like cal.l, except that the success or failure of the 
argument. Interpreted as a goal. Is reversed. 
What Is the difference between the following two questions? 
/'" 1 "'/ 
?- member(X,[a,b,c]), write(X). 
/'" 2 "'/ 
?- not(not(meiDber(X,[a,b,c]»), write(X). 
One might be tempted to say that there Is 
no difference. because In 
question 
2. 
meaber(X,[a,b,c) 
succeeds. 
so 
not(not(.eBber(X,[a,b,c)) succeeds. 
not(.eBber(x, [a,b,c)) 
falls. 
and 
so 
This Is partly right. 
However. the first question 
would cause the atom 'a' to be written. and the second goal would cause an unlnstantlated 
variable to be written. 
This Is what happens when an attempt Is made to satisfy the first 
goal of the second question above: 
1. 
The member goal succeeds. Instantiating x to a. 
2. 
An attempt Is made to satisfy the first not goal. and It falls because the.eBber goal. 
Its argument. succeeded. 
Now remember that when a goal falls. any variables that 
became Instantiated. such as X In the example. must now "forget" what they stood 

121 
fOr. 
Hence X becomes un Instantiated. 
3. 
An attempt is made to satisfy the second not goal. and it succeeds. because Its 
argument (not(lDIDIber ••• » failed. 
X is stili uninstantlated. 
4. 
An attempt Is made to satisfy the write goal. with X uninstantiated. 
The uninstantiated 
variable. as described in Section 6.9. is printed in a special way. 
6.8 Equality 
This section deals briefiy with the various built-in predicates for testing and making things 
equal in Prolog. 
When Prolog encounters a goal x = Y it attempts to make X and Y equal by matching 
them together. 
if it can match them. the goal succeeds (and X and Y may have become 
more instantiated). 
Otherwise the goal falls. 
A fuller discussion of this predicate is given 
in Section 2.4. 
The \= predicate is the opposite of the = predicate In terms of success and failure. 
That is. x \= Y succeeds if x = Y falls. and vice versa. 
if the goal x \= Y succeeds (X and 
Y could not be matched). the instantiation of X and Y will not have been changed at all. 
if \= happened not to be a built-in predicate. we could define it in Prolog. thus: 
X \= Y ,- X=Y, I, fail. 
X \= Y. 
The predicate = 
represents a much stricter equality test than -. 
That is. If 
x -
Y 
ever succeeds then x = Y does as weil. 
On the other hand. this is not so the other way 
round. 
The way that = 
is more strict Is by the way it considers variables. 
The = predicate 
will consider an uninstantiated variable to be equai to anything. because it will match anything. 
On the other hand. = 
will oniy consider an uninstantiated variable to be equal to another 
unlnstantlated variable that Is already sharing with It. 
Otherwise the test will fall. 
So we get 
the following behaviour: 
1- X = 
Y. 

122 
no 
?- X == X. 
?- X=Y, X=Y. 
?- append([AiB),C) == append(X,Y). 
no 
?- append([AIB),C) == append([AIB),C). 
Here is a little program that makes use of the == predicate. The Idea Is that the computer 
has a model of a tiny world. eg the objects on a table top. 
It has 10 descriptions of objects. 
but It does not know how many different objects there really are. 
Thus. for instance. 'the 
object on the far left" may be describing the same thing as "the red object". 
This program 
Is to help organise the knowledge about what descriptions refer to the same object. 
It carries 
out a "conversation' with the programmer. who tells it which descriptions are "equal" and can 
also ask It questions. 
Here is a sample conversation: 
?- converse. 
1 = 3. 
ok 
2 = 8. 
ok 
6 = 4. 
ok 
2 = 10. 
ok 
10 = 4. 
ok 
7 = 3. 
ok 
?- 6 
2. 
yes 
?- 7 
1. 
yes 
?- 3 
3. 
no 
The first six Inputs from the programmer state "equalities" between descriptions. 
Thus. 1 -
3 means that description 1 refers to the same object as description 3. 
The last three inputs 
ask questions. 
The program can show that 6 = 2 because 6 = 4, 4 = 10 and 10 = 2. 
Here 

Is the program. 
converse ;-
functor(W,world,10), 
proceed( W) • 
proceed(W) ,-
read( Command) , 
answer(Command,W), 
proceed( W) . 
answer(Nl=N2,W) ,-
NI=<II, N2=<II, I, 
arg(NI,W,Var), 
arg( N2, W, Var), 
wri te( ok), nl. 
answer«?-NI=N2),W) ,-
NI=<ll, N2=<II, I, 
arg(NI, W, VI), 
arg(N2, W, V2), 
say_equal(VI,V2). 
answer(other,W) ,-
write( 'eh?'), nl. 
say_equal(Vl,V2) ,-
VI-~V2, I, write(yes), nl. 
say_equal(VI,V2) ,- write(no), nl. 
123 
The program knows the descriptions by the numbers 1 to 10. and it represents the world 
by a structure with 10 components, one component corresponding to each description. 
In 
its model at any stage, each argument of the worl.d functor is an un instantiated variable. 
If two descriptions are found to refer to the same object, the two corresponding variables 
are matched together (the built-in predicate arg is used to access the appropriate component>. 
In order to tell whether two descriptions are "equal", the program just has to test whether 
the two variables share, using =. 
The properties of sharing are just like those of equality 
(for instance, if A shares with Band B shares with C then A shares with C). 
Therefore 
the program will automatically know about "equalities· that follow from what It has been told. 
This predicate 
is to 
= 
as \= is to =. 
That Is, a goai involving It succeeds exactly 
when the same goal for -
would fail. and vice versa. 
Again, we could imagine it defined 
in Prolog, thus: 
X \= Y ,- X = 
Y, I, fail. 
X \== Y. 

124 
6.9 
Input and Output 
The predicates made available for reading and writing characters and terms were desclbed 
In Chapter 5. 
Here we summarise each one. 
geto(x) 
This goal succeeds If X can be matched with the next character encountered on the 
current input stream. geto succeeds only once (it cannot be re-satlsfledl. 
The operation of 
moving to the next character Is not undone on backtracking. because there Is no way to put 
a character back onto the current Input stream. 
This goal succeeds if X can be matched with the next printing character encountered 
on the current input stream. 
Printing characters have an ASCII code that Is greater than 
32. 
Any non-printing characters are skipped. get succeeds only once 
(it cannot be 
re-satlsfledl. 
The operation of get, is not undone on backtracking. because there Is no way 
to put a character back onto the current input stream. 
skipeX) 
This goal reads and skips over characters from the current input stream until a character 
is found that matches with X. skip succeeds only once. 
read(X) 
This goal reads the next term from the current input stream and matches it with X. read 
succeeds only once. 
The term must be followed by a dot O. which does not become a 
part of the term. and at least one non-printing character. The dot Is removed from the current 
input stream. 
This goal writes the integer X as a character on the current output stream. put succeeds 
only once. 
An error occurs if X is not instantiated. 
Writes a control sequence to the current output stream that causes a "new line". 
On 
a computer display. all characters after the use of n1 appear on the next line of the page. 
nl. succeeds only once. 

125 
Writes a quantity of X ·space" characters to the current output stream. 
An error occurs 
If X Is not instantiated. tab succeeds only once. 
writeeX) 
This goal writes the term X to the current output stream. write succeeds only once. 
Any unlnstantiated variables in X are written as uniquely numbered variables beginning with 
an underscore. such as '_239'. 
Sharing variables within the same argument to write have 
the same number when they are printed out. 
The predicate write takes account of current 
operator declarations when It prints a term. 
Thus an Infix operator will be printed out between 
its arguments. for Instance. 
displayeX) 
The predicate display works in exactly the same way as write, except that It ignores 
any operator declarations. 
When display is used. any structure is printed out with the functor 
first and the arguments in brackets afterwards. 
op(X,Y,Z) 
This goal declares an operator having precedence X. position/associativity Y. and name 
Z. 
The position/associativity specification is taken from the following set of atoms: 
fx fy xi yf xfx xfy yfx yfy 
If the operator declaration is legal. then op will succeed. 
See Section 5.5 for more details. 
6.10 
Handling Files 
The predicates that Prolog makes available for altering the current input and current 
output streams were introduced in Chapter 5. 
Here we summarise each one. 
This goal opens file X. if it is not already open. and defines the current input stream 
to originate from file X. 
An error occurs if X is not instantiated. or If X names a file that 
does not exist. 

126 
seeinq(x) 
This goal succeeds If the name of the current input stream matches with X, and falls 
otherwise. 
This goal closes the current Input stream, and defines the current Input stream to be 
the user's ,Computer terminal's keyboard. 
This goal opens file X, If It Is not already open, and defines the current output stream 
to write Into the file. 
An error occurs if X Is not Instantiated. 
The first time tell Is used 
on a file not already open, If X names a file that does not exist. then a file of that name 
Is created. 
Otherwise, If X names a file that exists, then the previous contents of the file 
are destroyed. 
tellinq(X) 
This goal succeeds If X matches with the name of the current output stream, and falls 
otherwise. 
This goal closes the current output stream, causing an end-of-file marker to be written 
on the file. 
The .current input stream reverts to the user's computer terminal's display, 
6.11 
Evaluating Arithmetic Expressions 
Arithmetic was first discussed In Section 2.5. 
Here we summarise the use of the is 
operator, and what operators are available for constructing arithmetic expressions. 
Y must be instantiated to a structure that can be Interpreted as an arithmetic expression 
as described in Section 2.4. 
First, the structure instantiated for Y Is evaluated to give an 
Integer, called the result. 
If X is uninstantlated, then X becomes Instantiated to the result. 
and the is succeeds. 
If X Is already Instantiated, then X and the result are compared for 
equality. and the is succeeds or fails on the basis of the test. 
The operators that can be 
used to make up the structure on the right-hand side of an is are as follows: 

127 
~±x 
The addition operator. an Infix operator of precedence 31. 
When evaluated by is, Its 
result Is the numerical sum of Its two arguments. 
The arguments must be Instantiated to 
structures that evaluate to Integers. 
~=X 
The subtraction operator. an Infix operator of precedence 31. 
When evaluated by is, 
Its result Is the numerical difference of Its two arguments. The arguments must be Instantiated 
to structures that evaluate to Integers. 
The multiplication operator. an Infix operator of precedence 21. 
When evaluated by is, 
Its result Is the numerical product of Its two arguments. 
The arguments must be Instantiated 
to structures that evaluate to Integers. 
The Integer division operator. an Infix operator of precedence 21. 
When evaluated by 
is, Its result is the numerical quotient of Its two arguments. 
The arguments must be 
Instantiated to structures that evaluate to Integers. 
The Integer remainder operator of precedence 11. 
When evaluated by is, Its result 
Is the Integer remainder that 15 g"enerated when X 15 divided by Y. 
The arguments must be 
Instantiated to structures that evaluate to Integers. 
8.12 
Comparing Numbers 
Six predicates are provided for comparing numbers. These predicates were first presented 
In Section 2.5 when we discussed arithmetic. 
Each predicate 15 an Infix operator having two 
arguments. and having a precedence of 40. 
The equality operator. described In Section 6.8. also succeeds when two Integer 
arguments are the same. 

128 
The Inequality operator of Section 6.8 also holds for integers. succeeding when the two 
arguments are not the same integer. 
The less than operator succeeds when the left-hand integer argument is less than the 
right-hand integer argument. 
Both arguments must be Instantiated. 
The greater than operator succeeds when the left-hand integer argument Is greater than 
the right-hand integer argument. 
Both arguments must be Instantiated. or an error occurs. 
The greater than or equal to operator succeeds when the left-hand integer argument 
is greater than or equal to the right-hand integer argument. 
Both arguments must be 
Instantiated. 
The less than or equal to operator succeeds when the left-hand argument is less than 
or equal to the right-hand argument. 
Both arguments must be Instantiated. 
Notice that the 
predicate is spelled as =< rather than <=, so that <= is free to be used as an operator that 
looks like an arrow. 
6.13 Watching Prolog at Work 
This section describes the built-in predicates that enable you to watch your program 
as it runs. 
We will only describe the built-in predicates here. and refer you to Chapter 8 
for a more detailed discussion of debugging and tracing. 
The effect of satisfying the goal trace is to turn on exhaustive tracing. 
This means 
that afterwards you will get to see every goal that your program generates at each of the 
four main ports. 

129 
notrace 
The effect of the goal notrace Is to stop exhaustive tracing from now on. 
However. 
any tracing due to the presence of spy points will continue. 
The predicate spy Is used when you want to pay special attention to goals Involving 
some specific predicates. 
You do this by setting spy points on them. 
The predicate is defined 
as a prefix operator. and so you do not need to put brackets round the argument. 
The 
argument can be any of the following: 
o 
An atom. 
In this case. a spy point Is put on all predicates with this atom. however 
many arguments are used. 
Thus If we had clauses for sort with both two and three 
arguments. the goal spy sort would cause spy points to be set on both sets of clauses. 
o 
A structure with a single numerical argument. 
This specifies a predicate with the 
functor of the structure and the number of arguments given in the argument. 
Thus 
spy sort( 2) would cause spy points to be set on goals for the predicate sort with 
two arguments. 
o 
A list. 
In this case. the list must be terminated with [], and each element of the 
list must Itself be an allowable argument to spy. 
PrOlog will put spy points In all 
the places specified In the list. Thus spy [sort( 2 ),append(3)] would cause spy points 
to be set on sort with two arguments and append with three. 
debugginq 
The built-in predicate debugging allows you to see which spy points you currently have 
set. 
The list of spy points is printed out as a side-effect of the goal debugging being satisfied. 
nodebuq 
The goal nodebug causes all your current spy points to be removed. 
Like spy, nospy is a prefix operator. nospy is more selective than nodebug, because 
you can specify exactly which spy points you wish to have removed. 
You do this by providing 
an 
argument 
in 
exactly 
the 
same 
form 
as 
for 
spy. 
Thus 
the 
goal 
nospy 
[reverse(2),append(3)] will remove any spy points on reverse with two arguments and append 
with three arguments. 

Chapter 7. More Example Programs 
Each section of this chapter deals with a particular application of Prolog programming. 
We suggest that you read all of the sections In this chapter. 
Do not be concerned If you 
do not understand the purpose of a program because you are not acquainted with the particular 
application. 
For example. only those readers who have been Introduced to Calculus will 
appreciate the value of symbolic differentiation. 
Read it anyway. because the program for 
finding symbolic derivatives demonstrates how to use pattern matching to transform one kind 
of structure (an arithmetic expression> into another one. 
What is Important Is to gain an 
understanding of programming teChniques' available to the Prolog programmer. regardless of 
the particular application. 
We hope that we have included enough applications to satisfy most tastes. 
Naturally. 
all of the applications deal with areas that suit Prolog's way of representing the world. 
You 
will not find how to calculate the flow of heat through a square metal pipe, for example. 
It is possible to solve such problems using Prolog, but the expressiveness and power of Prolog 
is not shown to advantage on problems which are essentially repetitious calculations over arrays 
of numbers. 
We would like to be able to discuss large Prolog programs, such as those that 
are 
used 
by 
Artificial 
Intelligence 
researchers 
for 
understanding 
natural 
language. 
Unfortunately. the aims of a book like this one preclude discussion of programs that are longer 
than a page of text and which would appeal only to a specialised audience. 
7.1 
A Sorted Tree Dictionary 
Suppose we wish to make associations between items of information. and retrieve them 
when required. 
For example. an ordinary dictionary associates a word with Its definition. and 
a foreign language dictionary associates a word in one language with a word in another 
language. 
We have already seen one way to make a dictionary: 
with facts. 
If we wanted 
to make an index of the performance of horses in the British Isles during the year 1938. 
we could simply define facts winnings(X, Y) where X is the name of the horse. and Y is the 
number of guineas (a unit of currency> won by the horse. 
The following database of facts 
could serve as part Of such an index: 
winnings(abaris,582). 
winnings(careful,~7). 

winnings(jinglin9-silver, 300). 
winnings(maloja, 356). 
131 
If we wanted to find out how much was won by mal.oja, we would simply ask the right question. 
and Prolog would give us the answer: 
1- winnings(maloja,X). 
X-356 
Remember that when Prolog searches through a database to find a matching fact. It 
starts at the top of the database and works Its way down. 
This means that If our dictionary 
database Is arranged In alphabetical order. as Is the one above. then Prolog will take a short 
amount of time to find the winnings for ahl.aze, and It will take longer to find the winnings 
for zoltan. 
Although Prolog can look through Its database much faster than you could look 
through a printed Index. It Is silly to search the Index from beginning to end If we know that 
the horse we are looking for Is at the end. 
Also. although Prolog has been designed to 
search Its database quickly. It Is not always as fast as we would wish. 
Depending on how 
large your Index Is. and depending on how much Information you have stored about each 
horse. Prolog might take an uncomfortably long amount of time to search the Index. 
For these reasons and others. computer scientists have devoted much effort Into finding 
good ways to store Information such as Indices and dictionaries. 
Prolog Itself uses some 
of these methods to store Its own facts and rules. but It Is sometimes helpful to use these 
methods In our programs. 
We describe one such method for representing a dictionary. called 
the sorted tree. 
The sorted tree Is both an efficient way of using a dictionary. and a 
demonstration of how lists of structures are helpful. 
A sorted tree consists of some structures called nodes. where there Is one node for 
each entry In the dictionary. 
Each node has four components. 
It contains the two associated 
Items of Information. rather like winnings, above. 
One of these Items. called the key, Is 
the one whose name determines Its place In the dictionary (the name of the horse In our 
example). 
The other Is used to store any other Information about the object Involved (the 
winnings In our example). 
In addition. each node contains a tall (like the tall of a list) to 
a node containing a key whose name Is alphabetically less than the name of the key In the 
node Itself. 
Furthermore. the node contains another tail. to a node whose name Is 
alphabetically greater than the key In the node. 
Let us use a structure called W(B,W,L,G) 
(w Is short for "winnings") where H Is the name of a horse (an atom) used as the key. W 
Is the amount of guineas won (an Integer). L Is a structure with a horse whose name Is 
less than H's. and G Is a structure with a horse whose name Is greater than H·s. 
If there 
are no structures for Land G. we will leave them unlnstantlated. Given a small set of horses. 

132 
the structure might look like this when written as a tree: 
w(massinga, 858, 
). 
w(braemar, 385, 
/ 
/ 
/ 
/ 
\ 
/ 
\ 
/ 
\ 
w(adela, 588, _ , _ ) 
w(panorama, 158, ,_) 
/ 
/ 
/ 
w(nettleweed, 579, _ , _ 
Represented as a structure in Prolog. and indented so as not to be too wide to fit on the 
page. this would look like: 
w(massinga,858, 
w(braemar,385, 
w(adela,588,_,_), 
) . 
-), 
w(panorama, 158 , 
w(nettleweed, 579,_,_) 
-) 
Now given a structure like this. we wish to "look up" names of horses In the structure to 
find out how many guineas they won during 1938. 
The structure would have the format 
W(B,W,L,G) as above. 
The boundary condition is when the name of the horse we are looking 
for Is H. 
In this case. we have succeeded and need not try any alternatives. 
Otherwise. 
we must use aless, defined in Chapter 3. to decide which "branch" of the tree. L or G. 
to "look up" recursively. 
We use these principles to define the predicate lookup, for which 
lookup(B,S,G) means that horse H. when "looked up· In Index S (a W structure). won G 
guineas: 
lookup(H, w(H,G,_,_), G) ,- I. 
lookup(B, w(H1,_,Before,_), G) 
aless( H, HI), 
lookup(H,Before,G). 
lookup(H, w(H1,_,_,After), G) 
not(aless(H,H1», 
lookup(H,After,G). 
If we use this predicate to search a sorted tree. in general we examine fewer horses than 
if we arranged them in a single list. and searched that from start to finish. 
There is a suprising and interesting property of this lookup procedure: 
If we look for 
the name of a horse which is not in the structure. then whatever Information we supplied 
about the horse when we used lookup as a goal will be instantiated In the structure when 
lookup returns from its recursion. 
In other words. the Interpretation of lookup In this question 
1- lookup(ruby_vintage,s,x). 

Is 
Construct a structure, instantiated to S, such that ruby_vintage Is 'palred" with 
X. 
133 
So. lookup is Inserting new components in a partially specified structure. 
We can therefore 
use lookup repeatedly to create a dictionary. 
For instance. 
1- lookup(abaris,X,582), lookup(maloja,X,356). 
would Instantiate X to be a sorted tree with two entries. 
The actual means by which lookup 
functions for both storing and retrieving components takes advantage of what you should know 
already about Prolog. so we urge you to work this out by yourself. 
Hint: 
when lookup(H,S,G) 
is used in a conjunction of goals. the "changes" made to S only hold over the scope of S. 
ExerCise L..!!. 
Experiment with the lookup predicate to determine what difference it makes 
to Insert Items in the dictionary in a different order each time. 
For example. what does the 
dictionary tree look like when entries have been Inserted In the order: massinga, braemar, 
nettleweed, panorama? 
In the order: adela, braemar', nettleweed, massinga? 
7.2 
Searching a Maze 
It Is a dark and stormy night. 
As you drive down a lonely country road. your car breaks 
down. and you stop In front of a splendid palace. 
You go to the door. find It open. and 
begin looking for a telephone. 
How do you searCh the palace without getting lost. and know 
that you have searched every room? 
Also. what Is the shortest path to the telephone? 
It 
is just for such emergencies that maze-searching methods have been devised. 
In many computer programs. such as those for searching mazes. it is useful to keep 
lists of information. and search the list if some information is needed at a later time. 
For 
example. if we decide to search the palace for a telephone. we might need to keep a list 
of the room numbers visited so far. so we don't go round In circles visiting the same rooms 
over and over again. 
What we do is to write down the room numbers visited on a piece 
of paper. 
Before entering a room. we check to see If Its number is on our piece of paper. 
If it is. we ignore the room. since we must have been to it previously. 
If the room number 
Is not on the paper. we write down the number. and enter the room. 
And so on until we 
find the telephone. 
There are some refinements to be made to this method. and we will 
do so later when we discuss graph searChing. 
But first. let's write down the steps in order. 
so we know what problems there are to solve: 
1. 
Go to the door of any room. 
2. 
If the room number is on our list. ignore the room and go to Step 1. 
If there are 

134 
no rooms in sight. than "backtrack" through the room we went through previously. 
to see if there are any other rooms near It. 
3. 
Otherwise. add the room number to our list. 
4. 
Look in the room for a telephone. 
5. 
If there is no telephone. go to Step 1. 
Otherwise we stop. and our list has the path 
that we took to come to the correct room. 
We shall assume that room numbers are constants. but it does not matter whether they 
are integers or atoms. 
First. we can solve the problem of how to look up room numbers 
on the piece of paper by using the ...mer predicate defined in Section 3.3. 
Now we can 
get on with the problem of searching the maze. 
Let us consider a small example. where 
we are given the floor plan of a house. with letters labelling the different rooms. like this: 
+---.------------+--------------+ 
I 
I 
I 
+------+----
I 
I 
£ 
I 
+--
I 
d 
e 
--+ 
I 
9 
I 
I +--._----+ 
c 
b 
---+ 
t 
a <-
Notice that gaps in the walls are meant to represent doors. and that room "a" is simply a 
representation of the space outside the house. 
There are doors from rooms a to b. from 
c to d. from f to e. and so forth. 
The facts about where there are doors can be represented 
as Prolog facts: 
d(a,b). 
d(b,e). 
d(b,c). 
d(d,e). 
d( c,d). 
d(e,£). 
d( 9,e). 
Notice that the information about doors is not redundant. 
For example. although we have 
said that there is a door between room g and room e. we have not said that there is a 
door between room e and room g: 
we have not asserted d(e,g). To get around this problem 
of representing two-way doors. we could write a duplicate d fact for each door. reversing 

135 
the arguments. 
Or. we could make the program recognise that each door fact can be 
interpreted in two ways. 
This is the alternative that we choose in the program that follows. 
To go from one room to another. we must recognise one of two cases: 
o 
we are in the room we want to go to. or 
o 
we· have to pass through a door. and recognise these cases again (recursively). 
Consider the goal go(X, Y,T), which succeeds if it is possible to go from room X to room 
Y. 
The third argument T is our piece of paper that we carry. that has a "trail" of the room 
numbers that we have visited 50 far. 
The boundary condition for going from room X to room Y is if we are already at room 
Y (X Is Y). 
This is represented as the clause: 
go(X,X,T) . 
Otherwise we choose some adjoining room. call it Z. and see :1 we have been to it before. 
If we haven'\. then we "go" from Z to Y. adding Z to our list. 
All of this is represented 
as the following clause: 
gO(X,Y,T) :- d(X,Z), not(member(Z,T», go(Z,Y,[ZIT). 
To "go" from X to Y, not passing though the rooms on T, find a door from X 
to anywhere (2), ensure that Z is not already on the list, and "go" from Z to 
Y, using the list T with Z added to it. 
There are three ways that failures can occur in the use of this rule. 
First. if there is no 
door from X to anywhere. 
Second. if the door we choose 15 on the list. 
Third. if we cannot 
"go" to the Z we chose because It fails deeper in the recursion. 
If the first goal d(X,Z) 
fails. then it will cause any use of go to fail. 
At the "top level" (not a recursive call). this 
means that there is no path from X to 't. 
At lower levels. it simply means we must backtrack 
to find a different door. 
The program as stated treats each door as a "one-way" door. 
If we assume that having 
a door from room a to room b is just the same as having a door from room b to room 
a. then we must make this explicit. as indicated above. 
Instead of supplying a duplicate fact 
for each d fact but with the arguments reversed. there are two ways to put this information 
in the program. 
The most obvious way is to add another rule: 
go(X,X,T). 
go(X,Y,T) :- d(X,Z), not(member(Z,T», go(Z,Y,[ZIT). 
go(X,Y,T) :- d(Z,X), not(member(Z,T», go(Z,Y,[ZIT». 

136 
Or. the semicolon operator (meaning "or") can be used: 
go(X,X,T). 
go(X,Y,T) ,- (d(X,Z) I d(Z,X», not(member(Z,T», go(Z,y,[ZIT]). 
Now for finding the telephone. 
Consider the goal hasphone(%) which succeeds If room 
X has a telephone. 
If we want to say that room g has a telephone. we simply write our 
database with hasphone(g) In It. 
Supposing we start at room a. the question we ask to find 
the path to the telephone Is: 
1- go(a,x,[]), hasphone(X). 
Initialising the third argument to the empty list means that we start with a "clean piece of 
paper". 
This can be changed to provide variety: the question ·flnd the telephone without 
entering rooms d and f· would be expressed In Prolog as 
1- go(a,_,[d,f]). 
In Section 7.9 we will describe some general graph searching procedures. Including some 
attempts at finding the shortest path through a graph. 
ExerCise 7.2: 
Annotate the above program so that It will print messages such as "entering 
room Y" and "found telephone In room Y" with the appropriate room numbers filled In. 
Exercise 7.S: 
Can alternate paths be found by this program? 
If so. where do you put the 
"cut· goal to prevent more than one path from being found? 
Exercise 7.4: 
What determines the order In which rooms are searched? 
7.3 
The Towers of Hanoi 
The "Towers of Hanoi" Is a game played with three poles and a set of discs. 
The 
discs are graded In diameter. and fit onto the poles by means of a hole cut through the 
centre of each disc. 
Initially all the discs are on the left-hand pole. as shown here: 

137 
The object of the game Is to move all of the discs onto the centre pole. 
The right-hand 
pole can be used as a 'spare' pole. a temporary resting place for discs. 
Each time a disc 
Is moved from one pole to another. two constraints must be observed: only the top disc on 
a pole can be moved. and no disc may be placed on top of a smaller one. 
Many people who play this game never actually discover the quite simple strategy which 
will correctly play the Towers of Hanoi game with three poles and N discs. 
To save you 
the effort of finding It. we reveal It here: 
o 
The boundary condition occurs when there are no discs on the source (the left-hand) 
pole. 
o 
Move N-l discs from the source pole to the spare pole (the right-hand one). using 
the destination as a spare. 
Notice that this Is a recursive move. 
o 
Move a single disc from the source pole to the destination pole. 
At this point our 
program will print a message Informing us of the move. 
o 
Finally. move N-l discs from the spare to the destination. using the source as the 
spare. 
The Prolog program that Implements this strategy Is defined as follows. 
We define a 
predicate hanoi having one argument. such that hanoi(lI) means to print out the sequence 
of moves when N discs are on the source pole. 
Of the two lIIOVe clauses. the first one Is 
the boundary condition as described above. and the second clause Implements the recursive 
cases. 
The predicate .ova has four arguments. 
The first argument Is the number of discs 
to be moved. 
The other three represent the poles which are the source. destination and 
spare for moving the discs. 
The predicate info:nl uses write to print out the names of the 
poles that are Involved In moving a disc. 
hanoi(N) ,- move(N,left,centre,right). 
move(o,_,_,_) ,- 1. 
move(N,A,B,C) ,-
M is N-1, 
move(M,A,C,B), 
inform(A,B), 
move(M,C,B,A) . 
inform(X,Y) ,- write([move,a,disc,from,the,X,pole,to,the,Y,pole]), nl. 

138 
7.4 
Improved Parts Inventory 
In Chapter 3 we discussed a program for printing a list of parts required in constructing 
an assembly when given an inventory of parts. 
In the Improved program described in this 
section, we take into account how many of each part Is required. by accumulating the quantities 
of parts required as we descend from assemblies to their constituents. 
The improved program 
also handles duplicates properly: the co11ect procedure removes duplicates, while summing 
up the quantities of each part required. before the answer is printed out. 
The structure of the Inventory database is identical to that described In Chapter 3. 
An 
assembly is represented as a list of structures of the form quant(x, Y), where X is the name 
of some part (a basic part or an assembly), and Y is the quantity of such parts needed, 
Each predicate Of the modified program, together with a description of Its purpose, Is 
listed here: 
part1ist(A): prints out a list of all of the basic parts required, and the quantities of each, 
for the construction of assembly A. 
partsof(H,X,P): 
P is a list of structures quant(Part,Hum.) giving the part name Part and 
the quantity Hum. of each required for the construction of N X's. 
N is an integer and X is 
an atom which Is the name of some part. 
partsof1ist(H,S,P): 
P is a list of structures quant(Part,Hum) as above, required for the 
construction of the sum of all the members of the list S, given that N such lists are required. 
N is an integer, S is a list of quant structures. 
co11ect(P,A): 
P and A are lists of quant structures. 
A is a list with the same members 
of P except that there are no duplicate parts, and for any duplicates In p, the quantity of 
that part in A is the sum of all the corresponding quantities in P. 
We use co11ect to collect 
several descriptions of collections of like parts. 
For instance, "3 screws, 4 cushions and 
4 screws· is collected to form "7 screws and 4 cushions". 
co11ectrest(X,H,L,O,R): 
Land 0 are lists of quant structures. 
0 is the list of all the 
members of L except for those which have X as their part. 
X is an atom which is the name 
of some part. 
N is the sum of all the quantities of X in list L added to M. 
M is an integer 
that Is used to accumulate the quantity of X's in L and Is passed down to each call of 
co11ectrest. 
At the end of the recursion, which is caught by the boundary condition, M 
is returned as N. 
printpart1ist(P): 
P Is a list of quant structures, printed one structure per line of output. 
The put(9) prints the ASCII code 9, which Is a horizontal tab motion. 

append Is what we have seen many times before. 
The complete Prolog program Is as follows: 
partlist(T) ,- partsof(l,T,P), collect(p,Q), printpartlist(Q). 
partsof(N,X,P) :- assembly(X,S), partsoflist(N,S,P). 
partsof(N,X,[quant(X,N)]) :- basicpart(X). 
partsoflist(_,[],[]). 
partsoflist( N, [quant( X,Num) I L] ,T) 
M is N * Num, 
partsof(M,X,Xparts), 
partsoflist(N,L,Restparts), 
append(Xparts,Restparts,T). 
collect([],[]). 
collect([quant(X,N)IR],[quant(X,Ntotal)IR2]) 
collectrest(X,N,R,o,Ntotal), 
collect( 0, R2 ) . 
collectrest(_,N,[],[],N). 
collectrest(X,N,[quant(X,Num)IRest],Others,Ntotal) :-
I, 
M is N + Num, 
collectrest(X,M,Rest,others,Ntotal). 
collectrest(X,N,[otherIRest],[otherIOthers],Ntotal) 
collectrest(X,N,Rest,others,Ntotal). 
printpartlist([]). 
printpartlist([quant(X,N)IR]) :-
tab(4), write(N), put(9),write(X),nl,printpartlist(R). 
7.5 
Ust Processing 
139 
In this section we shall describe some basic predicates that are useful for manipulating 
lists. 
Because Prolog makes arbitrary data structures available to you. lists may not take 
on the omnipresent rOle that they do in other computer languages such as LISP and POP-2. 
Whether or not your programs will make use of lists. it is always important to understand 
how the predicates defined in this section work. because they employ principles that can be 
applied to manipulating any kind of data structure. 
Finding the last element of a list: the goal last(X,L) succeeds if element X Is the last element 
of list L. 
The boundary condition is when there is only one element in L. 
The first rule 
checks for this. 
The usual kind of recursive case forms the second rule. 
last( x, [X] ) . 
last(x,[_IY]) :- last(X,Y). 
?- last(X,[talk,of,the,town]). 
X=town 

140 
Checking for consecutive elements: the goal nextto( X, Y, L) succeeds if elements X and Yare 
consecutive elements of list L. 
Due to the way variables work, either X, or y, or both could 
be uninstantlated when an attempt is made to satisfy the goal. 
The first clause, which checks 
for the boundary condition, must also assume that there are more elements in the list after 
X and Y. 
This is why the anonymous variable appears, holding down the tail of the list. 
nextto(X, Y, [X, YI_]). 
nextto(X,Y,[_IZ]) :- nextto(x,Y,Z). 
Appending lists; 
We have seen this example before, but more explanation will not hurt. 
The 
goal append(x, Y, Z) succeeds when Z is a list constructed by appending Y to the end of X. 
For example. 
?- append([a,b,c],[d,e,f],Q). 
Q=[a,b,c,d,e,f] 
It is defined as follows: 
append( [ ] , L, L ) . 
append([xILl],L2,[XIL3]) :- append(Ll,L2,L3). 
The boundary condition occurs when the first argument is the empty list. 
This is because 
appending the empty list to a list does not change the list. 
Furthermore, we wili gradually 
approach the boundary condition because each recursion of append removes an element from 
the head of the first argument. 
The following points illustrate the principle of the second 
rule: 
o 
The first element of the first list (X) wili always be the first element of the third list. 
o 
The tail of the first list (Ll) will always have the second argument (L2) appended to 
it to form the tail (L3) of the third argument. 
o 
The best way to accomplish the appending described in the previous point is to use 
append itself! 
o 
As we are removing the head from the first argument, it will be gradually reduced 
to the empty list. and then the boundary condition will succeed. 
Notice that any two of the arguments of append can be instantiated, and append will instantiate 
the third argument to the appropriate result. 
This property, which we might call "reversible 
programming". is true of many of the predicates defined in this chapter. 
Because of the 

141 
flexibility of append, we can actually define several other predicates In terms of It: 
last(El,List) ,- append(_, [El],List). 
next_to(El1,E12,List) ,- appendC-, [El1,E121_], List). 
member(El,List) ,- append(_, [E11_] ,List). 
Reversing a /1st: the goal rev(L,H) succeeds if the result of reversing the order of elements 
in list L is list M. 
The program uses a standard technique. where we reverse a list by 
appending its head to the reverse of Its tall. 
And. what better way to reverse the tall than 
to use rev I 
The boundary condition Is when the first argument Is reduced to the empty 
list. in which case the result Is also the empty list. 
rev( [ ] , [ ] ). 
rev( [HIT] ,L) ,- rev( T, Z), append( Z, [H] ,L). 
Notice that we have enclosed H In square brackets In the second argument of append. 
This 
Is because H was selected as the head of the first argument. and the head of a list Is not 
necessarily a list. 
Of course. the tali of a list Is always a list. 
For a more efficient 
Implementation of rev, we can Incorporate the appending Into the clauses for rev: 
rev2(Ll,L2) ,- revzap( Ll, [] ,L2). 
revzap([XIL],L2,L3) ,- revzap(L,[xIL2],L3). 
revzap( [ ] ,L, L). 
The second argument of revzap Is used to hold the "answer so far·. 
Whenever a new piece 
of the answer is discovered. the "answer so far" passed to the rest of the program Is the 
old one combined with the new piece of Information. 
At the end. the last "answer so far" 
Is passed back to be the answer In the original goal. 
A similar technique Is used In the 
definition of integer_name In Section 7.8 
Deleting one element: the goal efface(X,Y,z) removes the first occurrence of element X from 
list Y. giving a new "effaced" list Z. 
If there Is no such element X In the list Y. the predicate 
falls. 
The boundary condition Is when we have found the element. 
Otherwise. we recur on 
the tail of Y. 
efface(A, [AIL],L) :- I. 
efface(A,[BIL],[BIMJ) :- efface(A,L,M). 
It Is easy to add a clause so that the predicate d,Oes not fall when the second argument 
becomes reduced to the empty list. 
The new clause. which recognises a new boundary 
condition. Is efface(_, [], []). 
Deleting al/ occurrences of an element: the goal delete(X,Ll,L2) constructs a list L2 by 

142 
deleting all the elements X from list L 1. 
The boundary condition Is when L 1 Is the empty 
list. meaning that we have recurred down the entire length of the list. 
Otherwise. If X Is 
In the list. then the result is the tall of the list. and we delete from that as well. 
The final 
case is If we have seen something other than X In the second argument -- we simply recur. 
delete(_, [], []). 
delete(X,[xIL],M) ,- I, delete(X,L,M). 
delete(X,[YIL1],[YIL2]) ,- delete(X,Ll,L2). 
Substitution: this is quite similar to de1ete, except Instead of deleting a desired element. we 
substitute some other element in its place. 
The goal subst(X,L,A,M) will construct a new 
list M made up from elements of list L. except that any occurrences of X will be replaced 
by A. 
There are three cases. 
The first one is the boundary condition. exactly as for de1ete. 
The second one is In case an X Is found In the second argument. and the third Is In case 
something other than X is found. 
subst(_,[],_,[]). 
subst(X,[XIL],A,[AIM]) 
subst(X,[YIL],A,[YIM]) 
I, subst(X,L,A,M). 
subst(X,L,A,M) • 
Subllsts: list X Is a subllst of list Y If every item In X also appears In Y. consecutively. and 
In the same order. 
The following goal would succeed: 
sublist( [of~, the, club] , [meetings,of,the,club, shall,be,called] ). 
The sub1ist program requires two predicates: 
one to find a matching first element. and one 
to ensure that the remainder of the first argument matches element-far-element with the 
remainder of the second argument: 
sublist([XIL],[XIM]) ,- prefix(L,M), I. 
sublist(L, [_1M] 
sublist(L,M). 
prefix( [] ,_). 
prefix([XIL],[XIM]) ,- prefix(L,M). 
Mapping: a powerful technique Is the ability to convert one list Into another list by applying 
some function to each element of the first list. using the successive results as the successive 
members of the second list. Our program In Chapter 3 for changing one sentence Into another 
is an example of mapping. 
We say that we are "mapping one sentence into another". 
Mapping Is so useful that it justifies a section of its own. 
Furthermore. becase lists 
In Prolog are simply special cases of structures. we will postpone discussion of mapping lists 
until the section on mapping structures. which Is later in this chapter. 
Mapping appears In 

143 
other guises also. 
Section 7.11. on symbolic differentiation. describes a way to map arithmetic 
expression onto other ones. 
7.6 
Representing and Manipulating Sets 
The set is one of the most important data structures used in Mathematics. and operations 
with sets find some applications in computer programming as well. 
A set Is a collection of 
elements. rather like a list. but it· does not make sense to ask 'where" or "how many times· 
something is an element of a set. 
Thus. the set !l.2.3} Is the same as the set !l.2.3.1l. 
because all that matters Is whether a given Item is an element of the set or not. 
Sets may 
also have other sets as members. 
The most fundamental operation on a set is to determine 
whether some element Is a member of some given set. 
It should come as no suprlse that a convenient representation for sets is as lists. 
A 
list can contain arbitrary elements including other lists. and it Is possible to define a 
membership predicate over lists. 
However. when we represent a set as a list. we will arrange 
that the list only has one element for each thing that belongs to the set. 
Dealing with lists 
without duplicated elements simplifies some operations like removing elements. 
So we will 
deal only with lists without duplicates. 
The predicates described In this section expect and 
maintain this property. 
It is usual to define the following operations over sets -- we shall include the usual 
mathematical notation for those who are accustomed to it: 
set membership: 
X € Y 
X Is a member of some set Y if X Is one of the elements of Y. 
Example: a € (c.a.t) 
subset: 
X S Y 
Set X Is a subset of set Y If every element of X Is also an element of Y. 
Y may contain 
some elements that X does not. 
Example: 
(x.r.u) S (p.q.r.s.t.u.v.w.x.y.z) 
disJoint: 
X S Y 
Set X is disjoint from set Y if no element of X Is a member of Y. 
Example: 
(c.a.t) S (d.o.g) 
Intersection: 
X n Y 
The intersection of sets X and Y Is the set containing those elements which are members 
of X and which are members of Y. 
Example: 
(r.a.p.i.d) n (p.i.c.t.u.r.e) 
(r.i.p) 

144 
union: 
X U Y 
The union of sets X and Y Is the set consisting of members from X. or Y. or both. 
Example: (a.b.c) U (c.d.e) 
(a.b.c.d.e) 
These are the basic operations that are normally used to manipulate sets. 
We can now 
write Prolog programs to implement each one. 
The first basic operation. membership. Is the 
same member predicate that we have seen several time before. 
However. the definition of 
member that we use does not contain the ·cut" symbol In the boundary case so that we can 
generate successive elements of the list by backtracking: 
member(X, [XL]). 
member( X, [_ I Y)) ,- member( X, Y). 
Next. a predicate subset for which subset(X, Y) will succeed If X is a subset of Y. 
The second fact In the definition embodies the mathematical notion that the empty set Is a 
subset of every set. 
In Prolog. this notion turns into a way of checking the boundary condition 
on the first argument. since we recur on its tall: 
subset([AlxJ,Y) ,- member(A,Y), subset(X,Y). 
subset( [ ] , Y) . 
Next. a predicate diSjoint, for which the goal disjoint(X, Y) will succeed If X Is disjoint 
from Y. 
Here is where It is important to take advantage of the behaviour of member as defined 
above. 
Notice we have given not a conjunction of goals In this example. 
In the first goal. 
because Z is uninstantiated. member will cause a member of X to be chosen. When backtracking 
occurs (because member(Z,Y) fails). then the first goal will choose another member of X. 
This is a spendid example of what some people call "non-deterministic· programming: 
disjoint(X,y) 
not« 
member(Z,X), member(Z,Y) ». 
Next. the most complicated example. intersection. 
The goal intersection(X, Y, Z) will 
succeed If the Intersection of X and Y is Z. 
Here Is where we have to assume that the 
lists contain no duplicated elements. 
intersection([],X,[]). 
intersection([XIR],Y,[XIZ] 
member( x, Y), 
I, 
intersection(R,Y,Z). 
intersection([XIR],Y,Z) 
intersection(R,Y,Z). 
Finally. union. 
The goal union(X,Y,Z) will succeed if the union of X and Y Is Z. 

145 
Notice that union looks rather like an arranged marriage between intersection and append: 
union( [] ,X,X). 
union([XIR],Y,Z) ,- member(X,Y), I, union(R,Y,Z). 
union( [XIR], Y, [XI Z]) ,- union(R, Y, Z). 
This completes our repertoire of set-processing predicates. Although sets may not feature 
In the kind of programming you Intend to do. It Is worthwhile to study these examples to obtain 
a clear understanding of how you can make recursion and backtracking work for you. 
7.7 
Soltlng 
Sometimes It Is helpful to sort a list of elements Into order. 
If the elements of the 
list are Integers. we can use the '<' operator to decide whether two Integers are In order. 
The list [1.2.31 Is sorted Into order because the Qredlcate '<' succeeds for each consecutive 
pair of Integers In the list. 
If the elements are atoms. we can use a1ess as discussed In 
Chapter 3. 
The list [a1pha,beta,galBil] is sorted Into order because the predicate a1ess 
succeeds for each consecutive pair of atoms In the list. 
In Section 7.9 we shall use the 
sorting predicates developed In this section to ·score· the possible paths to take though a 
maze In order to find the shortest path. 
Computer scientists have developed many techniques for sorting a list Into order 'when 
given some predicate that tells us whether consecutive elements are In order. 
We will show 
Prolog programs for four such sorting methods: naive sort. Insertion sort. bubble sort. and 
Quicksort. 
Each program will use a predicate order which can be replaced by '<' or a1ess 
or any other predicate you desire. depending on what kind of structure you are sorting. 
We 
assume that the goal order(X, Y) will succeed If objects X and Yare In the desired order. 
that Is. If X Is less than Y In some sense. 
One way of sorting numbers Into ascending order is first to generate some permutation 
of the numbers. and then test to see If the resulting list of numbers Is In ascending order. 
If they are not. then we generate some other permutation of the numbers. 
This method Is 
known as the naive sort. 
sort(L~,L2) ,- permutation(L~,L2), sorted(L2), I. 
permutation(L,[HIT]) ,-
append(V, [HIU],L), 
append(V, U, W), 
permutation(W,T). 
permutation([],[]). 
sorted(L) ,- sorted(O,L). 
sorted(_, []). 

146 
sorted(N,[BIT]) :- order(N,B), sorted(B,T). 
The predicate append is defined as before. 
In this program, the predicates have the following 
meanings. sort(LJ.,L2) means that L2 
is the list which is the sorted version of Ll. 
pe:nllltation(LJ.,L2) means that L2 is a list consisting of all the elements of list Ll in one 
of the many possible orders 
-- this Is a "generator", in the terminology of Section 
4.3. 
Predicate sorted(L) means that the numbers in the list are sorted into increasing order --
this is a "tester". 
The goal of finding the sorted version of a list consists in generating a permutation 
of the elements and testing to see if it is sorted. 
If It is, we have found the unique answer. 
Otherwise we must carryon generating permutations. This Is not a very efficient way of sorting 
a list. 
In the Insertion sort method, each Item of the list Is considered one at a time, and 
each item Is inserted Into a new list in the appropriate position. 
If you play card games, 
then you probably use this method when you sort your hand, picking up one card at a time. 
The goal insort(X, Y) succeeds when list Y is a sorted version of list X. 
Eacl1 element is 
removed from the head of the list and p~ssed to insori:x, which inserts the element in the 
list and returns the modified list: 
insort([ ] ,[ ] ) • 
insort([XIL],M) :- insort(L,N), insortx(X,N,M). 
insortx(X,[AIL],[AIM]) :- order(A,X), I, insortx(X,L,M). 
insortx(X,L,[XIL]). 
A convenient way to obtain a more general-purpose insertion sorting predicate is to use the 
ordering predicate as an argument of insort. 
We use the '-•• ' predicate as discussed 
In Chapter 6: 
insort( [], [] ,_). 
insort([XIL],M,O) :- insort(L,N,O), insortx(X,N,M,O). 
insortx(X, [AIL], [AIM] ,0) :-
P - •• [O,A,X], 
call(P), 
I, 
insortx(X,L,M,O). 
insortx(X,L, [XIL] ,0). 
Then we can use goals like insort(A,B,' <') and insort(A,B,a1ess) without requiring a 
predicate named order. 
This technique can be applied to the remainder of the sorting 
algorithms in this section. 
The bubble sort checks the list to see if two adjacent elements are out of order. 
If 
so, then they are exchanged. This process is repeated until no more exchanges are necessary. 

147 
Whereas the Insertion sort makes elements "sink" down to the appropriate level. the bubble 
sort is so named because It makes elements "float" up to the appropriate level. 
busort(L,5) :-
append(X, [A,B IY] ,L), 
order(B,A), 
append(X, [B,AIY] ,M), 
busort(M,5) . 
busort( L, L). 
append( [] ,L,L). 
append([HIT],L,[HIV]) :- append(T,L,V). 
Notice that the append predicate Is the same as we have seen before. and that In this example 
It must be able to backtrack on each solution found. 
Hence. a "cut" does not appear In 
the first clause. 
This Is another example of what some people call "non-deterministic' 
programming. because we are using append to select. In an undetermined way. members of 
list L. 
It Is the responsibility of append to ensure that the set of selection from L Is complete. 
Quicksort, a more sophisticated sorting method due to CAR. Hoare. is suitable for sorting 
large lists. 
To implement Quicksort In Prolog we first need to split a list consisting of head 
H and tail T Into two lists Land M such that 
o 
all the elements of L are less than or equal to H 
o 
all the elements of M are greater than H. and 
o 
the order of elements within Land M is the same as in [HIT]. 
Once we have split the list. we Quicksort each list (this is the recursive part). and append 
M onto the back of L. 
The goal split(B,T,L,K) splits the list [HIT] Into Land M as described 
above: 
split(H,[AIX],[AIY],Z) 
split(H,[AIX],Y,[AIZ]) 
split(_, [], [], [] ). 
The Quicksort program Is now: 
quisort([HIT],5) :-
split(H,T,A,B), 
quisort( A, Al ) , 
quisort(B,Bl ), 
append(Al,[HIBl] ,5). 
order(A,H), split(H,X,Y,Z). 
:- order(H,A), split(H,X,Y,Z). 
It is also possible to build the append into the sorting program. giving the alternative predicate: 
qUisortx([HIT],5,X) :-
split(H,T,A,B), 

148 
quisortx(A,S,[HIY]), 
quisortX(B, Y,X). 
quisortx([],X,X). 
In this case the third argument Is used as a temporary work area. and It will be filled with 
the empty list when quisortz is used as a goal. 
More Information on sorting can be found In Volume 3 (Sorting and Searching) of The 
Art of Computer Programming by Donald Knuth. published In 1973 by Addison-Wesley. 
Hoare's 
Quicksort method Is described In his paper In Computer Journal 5 (1962), pages 10 to 15. 
Exercise 7.5: 
Verify that. when given a known list as Ll. penautation( Ll., L2) will generate 
all the permutations of L 1 (once each) as the alternative values of L2. 
In what order are 
the solutions generated? 
ExerCise 7.6: 
Quicksort works best on large lists because it converges to a solution more 
rapidly. 
However. the amount of work done at each recurrence of qsort is more than the 
other methods. because It must use sp1it. 
So. perhaps when sorting small lists. then qsort's 
recursive calls could be replaced by calls to some other sorting method. say Insertion sort. 
Develop a "hybrid" sorting program that uses Quicksort to sort the large partitions (the lists 
made by the sp1it predicate). but switches to another sorting method when the size of the 
partition becomes sufficiently low that the Insertion sort can be used. 
Hint: 
since sp1it 
has to look at every element of the list anyway. then It can be used to compute the length 
of a list. 
7.8 Aue" and Retract; 
Random, Gena"", Flnda". 
In all of the programs discussed so far. we have used the database only to store facts 
and rules that define predicates. It Is possible to use the database to store ordinary structures. 
such as the structures that are constructed as a program executes. 
Until now. we have been 
passing such structures from one predicate to another by using arguments. 
However. a good 
reason for storing Information In the database. rather than passing It around through arguments. 
Is that sometimes a piece of Information may be needed by many parts of a program. and 
that the alternative would Involve something like one or two extra arguments to most predicates. 
In this section we describe three predicates that take advantage of the database for storing 
structures that have a lifetime that extends further than Is convenient for using variables. 
The three programs are ~, 
which generates a pseudorandomly chosen Integer each time 
It Is called: findal.1, which generates a list of all the structures that make a given predicate 
succeed. and g8nsya, which generates atoms with unique names. 
The goal rllllda.{R,.) Instantiates N to a randomly chosen Integer between 1 and R. 

149 
The method of choosing a random Integer is to use a congruential method. using a "seed" 
that Is Initialised to an arbitrary Integer. 
Each time a random integer Is desired. the answer 
Is computed using the existing seed. and a new seed is determined. and stored until the 
next time that a random Integer is desired. 
We use the database to store the seed between 
calls to randOli. 
After the seed is used. we retract the old Information about its structure. 
Then. the new seed is computed. and new Information Is asserted. 
The initial seed Is simply 
a fact in the database. with functor seed having one component. the integer value of the seed. 
seed(l.3). 
random(R,N) 
seed( 5), 
N is (5 mod R) + l., 
retract(seed(5», 
New5eed is (l.25 * 5 + l.) mod 4096, 
asserta(seed(New5eed», I. 
We can take advantage of the semantics of retract to simplify the definition of random In 
the following way: 
random(R,N) ,-
retract(seed(5», 
N is (5 mod R)+l., 
New5eed is (l.25*5+l.) mod 4096, 
asserta(seed(New5eed», I. 
To print out a lot of random numbers between 1 and 1 O. all that is required is: 
1- repeat, random(l.O,X), write(X), nl, fail. 
Prolog will. of course. never finish answering this question. 
The predicate gensya provides a way of generating new Prolog atoms. 
If we have a 
program that Is assimilating Information about the world (perhaps by understanding English 
sentences about it>. we have the problem of dealing with the situation when a new. object 
Is discovered. 
A natural way to represent an object Is with a Prolog atom. 
If the object 
has not been encounted before. we must ensure that the atom we assign to it does not 
accidentally coincide with the one representing some other object. 
That Is. we require the 
ability to generate a new atom. 
We might as well require that the atom have some mnemonic 
significance as well. so that we can understand the program's output. 
If we were representing 
students. say. a reasonable solution would be to name the first student studentl., the second 
student2, the third student3, and so on. 
Then if in addition we had to represent teachers. 
we could pick atoms teacherl., teacher2, teacher3 and so on to represent them. 
The function of gensya is to generate new atoms from given roots (like student and 

150 
teacher). 
For each root, it remembers what number was last used, so that next time it 
is asked to generate an atom from that root It can guarantee that it will be different from 
the ones generated before. 
Thus, the first time the question: 
1- gensym(student,X). 
is asked, the answer is 
x - studentl 
The next time, the answer will be 
x - student2 
and so on. Note that these different solutions are not generated on backtracking (gen&ylll(%,Y) 
can never be resatisfied), but are generated by subsequent goals involving the predicate. 
The definition of gensya makes use of the subsidiary predicate currenLnum. 
It is by 
putting facts about currenLnum into the database (and also by removing facts that are no 
longer applicable) that gensya keeps track of which number to use next with a given root. 
current_nUll(Root,RUIl) means that the last number used with root Root was RUIl. 
That is, 
the last atom generated for this root had the characters derived from Root followed by those 
derived from RUIl. 
The normai course of action when Prolog tries to satisfy a gensym goal 
is that the last currenLnum fact about the given root is removed from the database, 1 is 
added to the number invoived and a new current_num fact is added to repiace it. 
Meanwhile, 
the new number is used as the basis for generating an atom. 
It is very convenient to keep 
the currenLoum information in the database. 
The only alternative would be to have every 
predicate directly or indirectiy involved in a genS}'lll carry the information about current numbers 
in extra arguments. 
The last few clauses of this program define the predicate integeLname, which is used 
to derive a list of characters from a number. 
The atoms created by gensya are made up 
by using the built-in name predicate to make an atom whose characters consist of the 
characters of the root foliowed by the characters of the number. Some Prolog implementations 
use a version of the name predicate which will perform the functions of integer_name, but 
it is quite instructive to see how it can be defined in Prolog. 
One fact that is used implicitly 
in the definition is that the ASCII character codes for the digits 0, 1, 2, etc are 48, 49, 50, 
etc in that order. 
Therefore, in order to convert from a number less than 10 to its character, 
one only has to add 48. 
To get the list of characters for a number greater than 9 is more 
complex. 
We can easily get hold of the iast digit of a number, because this is simply the 
remainder on division by 10 (the number mod 10). 
It is therefore easy to generate the 
characters of a number in reverse order -- we just keep on finding the last digit, getting 
hold of the rest of the number (the result of integer division by 10). finding its last digit. 

and so on. 
The Prolog definition of this would be: 
reverse_chars(N,[C]) ,- N<10, I, C is N+48. 
reverse_chars(N,[CICs]) ,-
C is (N mod 10) + 48, 
N1 is N/10. 
reverse_charS(N1,CS). 
151 
To get the characters In the right order. we adopt a neat trick. We Introduce an extra argument 
to the pre,dlcate. expressing the list of characters generated 80 far. 
Using this argument. 
we can find the characters In reverse order. as above. but put together the list In the right 
order. 
This works as follows. 
Assume we have the number 123. 
We start with the "list 
built so far" D. 
First. the number 3 Is discovered and converted Into the character code 
51. 
We then Invoke a recursive int8ge:z:....name goal. to find the characters of 12. 
The "list 
so far" given to this goal Is made up of the character generated put on the front of the 
original "!1st so far" --
It Is the Ust [511. 
The second integer_name goal generates the 
character 50 (for the 2) and tries to satisfy integerJlUl8 again. this time with the number 
1 and the "Ust so far" [50.511. 
This final goal succeeds and. because the number was less 
than 10. gives the answer [49.50.511. 
This answer Is passed up through the arguments of 
the various intege:z:....na.e goals and forms the answer of the original question -- what are 
the characters corresponding to 123? 
Here. now. Is the program. 
/* create a new atom starting with a root provided and 
finishing with a unique number */ 
gensym(Root,Atom) :-
get_num( Root, Num) , 
name( Root, Name1 ) , 
integer_name(Num,Name2), 
append(Name1,Name2,Name), 
name(Atom,Name). 
get_num(Root,Num) :-
/* this root encountered before */ 
retract(current_num(Root,Num1», I, 
Num is Num1+1, 
asserta(current_num(Root,Num». 
/* first time for this root */ 
get_num(Root,1) :- asserta(current_num(Root,1». 
/* Convert from an integer to a list of characters */ 
integer_name(1nt,List) :- integer_name(1nt,[],List). 
integer_name(1,Sofar,[CISofar]) :-
1<10, I, C is 1+4e. 
integer_name(I,Sofar,List) :-
Tophalf is 1/10, 
Bothalf is 1 mod 10, 
C is Bothalf+48, 
integer_name(Tophalf, [CISofar] ,List). 

152 
In some applications it Is helpful to determine all of the terms that satisfy some predicate. 
For exam pie. we might want to make a list of all of the Children of Adam and Eve using 
the parents predicate of Chapter 1 (and assuming we had a database of parents facts). 
For this we could use a predicate called findal.l., which we shall define below. 
The goal 
findal.l.(X,G,L) constructs a list L consisting of all of the objects X such that the goal G 
is satisfied. 
G is an ordinary structure. except that findal.l. treats it as a Prolog goal. 
Also. 
X will appear somewhere inside G. 
So. G can be instantiated to a Prolog goal of arbitrary 
complexity. 
Here is how we could find out all the children of Adam and Eve: 
?- findal.l.(X, parents(X,eve,adam), L). 
The variable L would be instantiated to a list of all of the X's that satisfy parents(X, eve, adam) • 
All that findal.l. needs to do is to repeatedly attempt to satisfy its second argument. and 
each time it succeeds it shouid take whatever X is instantiated to. and put it in the database. 
When the attempt to satisfy the second argument finally falls. then we go back and collect 
all of the X's that we put into the database. The resulting list is returned as the third argument. 
If the attempt to satisfy the second argument never succeeds. then the third argument will 
be instantiated to the empty list. To put Items into the database. we use the asserta predicate, 
which inserts structures before those that have the same functor. 
To put an item X in the 
database. we supply it as a component of the functor called found. 
The Prolog clauses for 
findal.l. are as follows: 
findal.l(X,G,_) ,-
asserta(found(mark», 
call(G), 
asserta( found( X) ), 
faiL 
findall(_,_,L) ,- col.l.ect_found([],M), I, L = M. 
collect_found(S,L) ,- getnext(X), I, col.lect_found([XIS],L). 
col.lect_found(L,L). 
getnext(X) ,- retract(found(X», I, X \== mark. 
The findal.l. predicate first adds a special marker to the facts for found, in the form of a 
structure with functor found and component mark This special marker serves to mark the place 
in the database before which all of the X's satisfying G in this use of findal.l. will be asserted. 
Next. an attempt is made to satisfy G. and each time It succeeds. then X is inserted in the 
database by supplying it as a component to the found functor. 
The fail. forces backtracking 
to occur. attempting to re-satisfy G (asserta only succeeds once). 
When G finally falls. 
backtracking will force the first findal.l. clause to fail. and an attempt will be made to satisfy 
the second one. 
The second ciause calls col.l.ect_l.ist to retract each found structure back 
out of the database. inserting its component in a list. 
The col.l.ect_l.ist predicate puts each 
element into a variabie that holds the "list so far". the trick revealed when explaining gensym. 

153 
above. 
As soon as the component mark Is encountered. getnext falls. so the second clause 
of col.l.ect:...found Is satisfied. which shares Its second argument <the result) with Its first (the 
collected list). 
Notice that the presence of the found(mark) in the database indicates a particular use 
of findall.. 
This means that findal.l. can be used recursively -- any occurrence of findal.l. 
used within the second argument of another findal.l. will be treated correctly. 
In Section 7.9 we develop a program that uses findal.l. to construct a list of all of the 
descendants of a node In a graph. 
This is used to implement a breadth-first graph searching 
program. 
Exercise 7.7: 
Write a Prolog program that defines the predicate randOllLPick, for which the 
goal randOllLPick(L,E) instantiates E to a randomly chosen element of list L. 
Hint: 
Use 
the random number generator and define a predicate that returns the Nth element of a list. 
Exercise 7.8: 
Given the goal findal.1(X,G,L), what happens when there are uninstantiated 
variables not sharing with X in G? 
7.9 
Searching Graphs 
Graphs are networks of nodes connected by arcs. 
For example. a map ceon be seen 
as a graph. in which the nodes are villages and the arcs are roads connecting the villages. 
If you want to find the shortest Journey between two villages. you have to solve the problem 
of finding the shortest path between nodes of a graph. 
The easiest way to represent a graph Is by using a database of facts to represent the 
arcs between nodes of a graph. 
For example. the graph conSisting of the following pattern 
of nodes and arcs can be represented as facts as shown: 
a---b 
I 
I 
------ c 
d -
e ------ £ ---------+ 
I 
I 
g 
h 
a(g,h). 
a(a,e). 
a(g,d). 
a(a,b). 
a(e,d). 
a(b,£). 
a(h,£). 
a(b,c). 
a(e,£). 
a(£,c). 
So to go from node g to node a. we could take the path g.d.e.a or g.h.f.e.a or even 
g.d.e.f.c.b.a. 
If we had a directed graph. then the predicate a would be Interpreted such 
that a(x, Y) means that there Is an arc from X to Y. but not necessarily from Y to X. 
In 
this section. we shall assume that all graphs are undirected -- that Is. they do not contain 
any 'one-way streets". This is the same assumption as we made in Section 7.2 when searching 

154 
the maze. 
The easiest program for searching a graph represented as above Is the following: 
go(X,X). 
go(X, Y) 
(a(x, Z );a( Z,X», go( z, Y). 
Unfortunately. is is possible for this program to get into a loop. 
This is why. as before we 
use list T to keep a "trail" of the nodes we have visited at any particular recurrence of the 
predicate: 
go(X,X,T). 
go(X, Y,T) ,- (a(X, Z);a( Z,X», not(member( Z,T», gO( Z, Y, [Z IT)). 
This program. developed In Section 7.2. does what is called a "depth first" search. because 
at first only one of the neighbours of a node in the graph is considered. The other neighbours 
are ignored until later failure causes backtracking to the node so another neighbour can be 
considered. 
A "neighbours first" search occurs when a program considers all of the immediate 
neighbours of a node. and then chooses one of the neighbours to search. 
This is different 
from a "breadth-first" search. which we discuss later. We can Implement neighbour-first search 
by using finda11 to obtain all of the immediate neighbours of a node. 
Next. we use a function 
to apply the search predicate to each of the neighbours. 
To make the program 
ea~ier to 
read. we shall define a predicate good node that avoids the "one-way" street problem. and 
checks if we have visited the node before. 
The goal goodnode(X,Y,T) will succeed only if 
there is a arc from X to Y or Y to X. and if Y Is not already a member of T. 
goodnode(X,Y,T) ,- (a(x,y) 
a(Y,X», not(member(Y,T». 
go(X,X,_). 
go(X,Y,T) ,-
finda11(Z, goodnode(X,Z,T), 0), 
go_a11(0, Y,T). 
go_all( [H 1-], Y, T) ,- go( H, Y, [HI T». 
go_all( [_IL], Y,T) 
go_all(L, Y,T). 
The first go clause checks for the boundary condition. when we wish to go to the node where 
we already are. 
The second go(X,Y,T) clause first finds all of the immediate neighbours 
that pass the goodnode test. and then puts them all into list D. 
The next goal searches via 
one of these neighbours. 
The predicate go_a11 is designed to fail when it reaches the end 
of the list of nodes to search. 
Notice that we must not put in a clause go_a11([],_,_), 
because this would cause go_a11 to succeed when It has finished with Its list. 
The reason 
we make go_a11 fall is so that it 
can cause backtracking to occur either if there are no 
neighbours or if we have run out of neighbours to examine. 
The go_a11 predicate has two 
clauses. 
The first one applies go to the head of the list. and the second one recursively 

155 
applies 9O_a11. to the tail of the list in the way to which we are accustomed. 
Suppose we have what is called a "labelled' graph. where each arc has some item of 
information associated with It. 
In a road map. for example. each road could have associated 
with It the distance between the villages that the road connects. 
A simple addition to the 
database can represent labelled graphs -- we simply add a third argument. 
Now. the fact 
a(X,Y,Z) means that there Is an arc from X to Y with "label" Z. 
Let's use road maps again. 
The following database represents a road map of towns In Northern England. 
The distances 
given are In units of miles: 
a(neweastl.e,earlisle,58}. 
a(earlisle,penrith,23}. 
a(darlington,neweastle,40}. 
a(penrith,darlington,52}. 
a(workington,earlisle,33}. 
a(workington,penrith,39}. 
Now that there are distances involved In traversing the map. it becomes Interesting to see 
If we can write a program that could find the shortest path between two towns. 
We shall 
use a strategy called 'best first search". 
In fact. a best-first program will not necessarily 
find the shortest path. but let's see what It does for us In this case. 
Now that we have 
a neighbour-first search strategy. all we have to do is to sort the list of Immediate neighbours 
so that the nearest neighbour Is searched first. 
The list of neighbours must contain not only 
the name of a neighbour (a town name). but also a distance. 
For convenience we can 
represent the neighbour list as a list of structures of the form dese(X, Y}, were X Is the name 
of a town to try. and Y is how far away it is from our current position. 
A best-first search 
program. which sorts the neighbour list before trying each neighbour is: 
go(X,X,_}. 
go(X,Y,T} :-
findall(dese(Z,Dist}, goodnode(X,Z,Dist,T}, D}, 
insort(D,D1}, 
go_all( D1, Y ,T}. 
goodnode(X,Y,D,T} ,- ( a(X,Y,D) ; a(Y,X,D} }, not(member(Y,T}}. 
go_all( [dese(H,_}I_],Y,T} ,- go(H,Y, [HIT]}. 
go_al.l( [_IL], Y,T} ,- go_all(L, Y ,T}. 
insort([HIT],S} :- insort(T,L}, plugin(H,L,S}. 
insort([],[]}. 
plugin(dese(Town,Dist},[dese(Town2,Dist2}IT],[dese(Town2,Dist2}IL]} 
Dist2 ( Dist, 
1, 
pl.ugin(dese(Town,Dist),T,L}. 
plugin(X,L,[XIL]}. 
The resulting program Is pretty much the same as before. except that we have accounted 
for the neighbour list having dese structures in it. 
We have also added a version of the 
Insertion sort predicate that was discussed In Section 7.7. 
Since the program always searches 

156 
routes starting from the nearest neighbour first. we might expect the first route found always 
to be the shortest one. 
However. when applied to the database of Northern England above. 
we find that this "best first" strategy finds the WOf8t path between Worklngton and Newcastle. 
Why? 
The neighbours of Worklngton are Carlisle (33 miles) and Penrlth (39 miles). so the 
next move Is to Carlisle. 
For Carlisle we can go to Newcastle (58) or Penrlth (23). so It 
chooses Penrlth. 
From Penrlth we can go back to Worklngton (discarded by goodnode) or 
to Darlington (52). 
We must go to Darlington. and then on to Newcastle (40). 
The total 
journey Is, 33+23+52+40 = 148 mlies, 
From looking at a map (or at the database given above>. the best journey Is to go from 
Worklngton to Carlisle to Newcastle. for a total of 91 miles, 
The "best first" strategy falls 
to find this route first. because It Is "short sighted" enough to Immediately choose the nearest 
neighbour. regardless of how far off course the neighbour Is from the goal, 
However. 
'best-flrst" does not always perform this poorly, 
An aternatlve method for searching graphs Is the "breadth first" strategy. 
This Involves 
keeping a list of all the alternative nodes that have to be followed. not just the neighbours 
of a single node. 
Here Is a program for a "breadth first" search of an unlabelled graph. 
The program does not check for loops In the path by using a "trail" list. but It finds a solution 
If there Is one to be found. 
go(X,y) ,- gol.([X],Y). 
gOl.(L,D) ,- member(D,L), I. 
gol.(L,D) ,- go2(L,[],M), gOl.(M,D). 
go2( [] ,L,L) ,- I. 
go2( [NINs],Sf,L) ,-
findall.(D,( a(N,D);a(D,N) ),Ds), 
addon(DS,Sf,Sfl.), 
go2(Ns,Sfl.,L). 
addon( [] ,L,L). 
addon([NINs],L,M) ,- member(N,L), I, addon(Ns,L,M). 
addon( [NINs] ,L,M) ,- addon(Ns, [NIL] ,M). 
Exercise 7,9: Modify the above programs so that the database Is searched for all paths between 
two given towns. and the total distance for each path Is printed out. 
Information about how to search graphs using more effective heuristics than "best first" 
Is available In books on Artificial Intelligence, 
For example: 
Problem Solving Method8 In 
Artificial Intelligence, 
by Nils Nilsson. published In 1971 
by McGraw-HIli; and Artificial 
Intelligence, by Patrick Winston. published In 1977 by Addison-Wesley, 

7.10 
Sift tile Two's and Sift the Three's 
Sift the Two's and sift the Three's; 
The Sieve of Erastosthenes. 
When the multiples sublime, 
The numbers that remain are Prime. 
Anon. 
157 
A prime number is a number that has no whole number divisors except 1 and itself. 
For instance. the number 5 is prime. but the number 15 is not. because it has the whole 
number 3 as a divisor. 
If you want to generate prime numbers. then one of the best ways 
is called the Sieve of Erastosthenes. 
This method for sifting for primes up to the integer 
N works as follows: 
1. 
Put all the numbers between 2 and N into the "sieve". 
2. 
Select and remove the smallest number remaining in the sieve. 
3. 
Include this number in the primes. 
4. 
Step though the sieve. removing all multiples of this number. 
5. 
If the sieve is not empty. repeat steps 2 through 5. 
To translate these rules into Prolog. we define a predicate integers to generate a list of 
integers. a predicate sift to examine each element of the sieve. and a predicate remove 
to create a new sieve by removing multiples of the selected number from the sieve. 
This 
new sieve is passed back to sift. 
The predicate priaes is the top-level goal such that 
priDms(lII,L) instantiates L to the list of primes lying in the range from 1 to N inclusive: 
primes(Limit,PS) :- integers(2,Limit,IS), sift(Is,Ps). 
integers(Low,High,[LowIRest]) :-
Low =< High, I, Mis Low+1. integers(M,High.Rest). 
integers(_,_.[]). 
sift( [] , [ ]) • 
sift([IIIs],[IIPs]) :- remove(I,Is.New). sift(New.Ps). 
remove(P,[],[]). 
remove(P.[IIIs],[IINis]) ,-
not(O is I mod Pl. 
I. 
remove(P,Is,Nis). 
remove(P,[IIIs],Nis) ,- 0 is I mod p. I. remove(p,Is,Nis). 

158 
Continuing In this arithmetical vein, here are Prolog programs for the recursive formulation 
of Euclid's algorithms for finding the greatest common divisor and the least common multiple 
of a pair of Integers. 
The goal gcd( J:,J,lt) succeeds when the greatest common divisor of 
I and J is K. 
The goal 1cm(J:,J,lt) succeeds when the least common multiple of I and J 
Is K: 
ged{ 1,0, I ). 
ged{I,J,K) ,- R is I mod J, ged{J,R,K). 
lcm{I,J,K) ,- ged{I,J,R), K is {I*J)/R. 
Notice that due to the way of computing remainders, these predicates are not 'reversible' 
-- variables I and J must be Instantiated in order for the predicates to work. 
Exercise 7.10: 
The three numbers X, Y and Z are said to form a Pythagorean triple if the 
square of Z is equai to the sum of the squares of X and Y (Z'"Z = XXX + y*y). 
Write a 
program to generate Pythagorean triples, that Is, define a predicate pythag such that asking 
?- pythag{X,Y,Z). 
and asking for alternative solutions gives us as many different Pythagorean triples (X, y, Z) 
as we desire. 
Hint: 
Make use of predicates like is_integer of Chapter 4. 
7.11 
Symbolic Differentiation 
in mathematics, symbolic differentiation Is an operation that converts an arithmetic 
expression into another arithmetic expression called the derivative. 
Suppose U and V stand 
for arithmetic expressions (such as 2· x+y): x stands for a variable in an expression: and c 
stands for a constant (such as 2). 
The derivative of U with respect to x is written as dU/dx, 
and it is defined recursively by applying the following 
conversion rules to the expression U. 
The two boundary conditions come first, and the arrow Is read as "Is converted to": 
dc/dx 
.... 
0 
dx/dx 
.... 
1 
d{-U)/dx 
.... 
-(dU/dx) 
d{U+V)/dx 
.... 
dU/dx + dV/dx 
d(U-V)/dx 
.... 
dU/dx - dV/dx 
d(c'U)/dx 
.... e' dU/dx 
d(U'V)/dx 
.... 
U 
dV/dx + V • dU/dx 
d(U/V)/dx 
.... 
d(U·v-1)/dx 

159 
c-l 
U 
• dU/dx 
This set of conversion rules is easily translated to Prolog, because we can represent 
arithmetic expressions as structures, and use operators as the functors of the structures. 
We can also take advantage of the pattern-matching that occurs when a goal matches against 
the head of a rule. 
Let us consider a goal d(E,X,P) that succeeds when the derivative of 
expression E with respect to constant X Is the expression F. 
Although the +, -, *. and / 
operators have built-in declarations, we shall have to declare a • operator, where X·Y is read 
as "X to the power Y", and a unary -
operator. where -X means "negative X". 
Operator 
declarations are used simply to make the syntax of expressions easier to read. 
For example, 
the following questions might be asked of d after it is defined: 
1- d(x+l,x,X). 
x = 1+0 
1- d(x*x-2,x,X). 
x = x*I+I*x-O 
Notice that simply transforming one expression into another using the rules does not necessarily 
render the result in a simplified form. but a simplifier can be written as a separate task (Section 
7.12). The differentiation program consists of the extra operator declarations pius a line-By-line 
translation of the above conversion rules into Prolog clauses: 
1- op(10,yfx,A). 
1- ope 9, fx, - ) • 
d(X,X,I) :- I. 
d(C,X,O) :- atomic(C). 
d(-U,X,-A) :- d(U,X,A). 
d(U+V,X,A+B) :- d(U,X,A), d(V,X,B). 
d(U-V,X,A-B) :- d(U,X,A), d(V,X,B). 
d(C*U,X,C*A) :- atomic(C), C \= x, d(U,X,A), I. 
d(U*V,X,B*U+A*V) :- d(U,X,A), d(V,X,B). 
d(UjV,X,A) :- d(U*VA( -1),X,A). 
d(UAV,X,V*W*UA(V-l» 
:- atomic(V), C \= x, d(U,X,W). 
d(log(U),X,A*UA(-I» :- d(U,X,A). 
Notice the two places where the cuts occur. 
The first cut ensures that a the derivative of 
a variable with respect to Itself matches only with the first clause. eliminating the second clause 
as a possibility. 
Secondly. there are two clauses for multiplication, the first one dealing with 
a special case. 
If the special case succeeds. the general case must be eliminated as a 
pOssibility. 
As pointed out above. the solutions generated by this program are far from simplified. 
For example. any occurrence of x*1 may as weil be written as x, and any occurrence of. 

160 
for example X*l.+l.*z-O may as well be written as 2"'X The next section describes an algebraic 
simplifier that can be used to simplify arithmetic expressions Is very much the same way as 
the derivatives were derived above. 
7.12 
Mapping Structurn and Tree Transformation 
If we copy a structure component-by-component to form a new structure. we say that 
we are mapping one structure Into another. 
It Is usual to make a slight modification to each 
component as we copy It. as was done when we changed one sentence Into another sentence 
In Chapter 3. 
In that example. sometimes we wanted to copy a word In the sentence exactly 
as It appeared In the original sentence. and sometimes we wanted the new copy to be a 
changed word. 
We used the following program to map the first argument of alter Into Its 
second argument: 
alter([],[]). 
alter([AIB],[CID]) :- change(A,C), alter(B,D). 
Since mapping Is such a general-purpose operation. we can define a predicate maplist such 
that the goal maplist(P,L,II) succeeds by applying the predicate P to each element of a 
list L to form a new list M. We assume that P has two arguments. such that the first argument 
Is the "Input" element. and the second argument Is the modified element to be Inserted Into 
M: 
maplist(_,[],[]). 
maplist(p,[XIL]'[YIM]) ,-
Q - •• [P,X,Y], 
ca11(Q). 
maplist(P,L,M). 
There are several points to note about this definition. 
First. the definition consists of a 
boundary condition (the first clause) and a general recursive case (the second clause). 
The 
second clause uses the '-•• ' operator. pronounced "unlv". to form a goal from the given 
predicate (P). the Input element 00. and the variable that P Is assumed to Instantiate to form 
the modified element ro. 
Next. an attempt Is made to satisfy a. which will result In Y being 
Instantiated. forming the head of the second argument to this call of maplist. 
Finally. the 
recursive call maps the tall into the tall. 
The predicate alter can be replaced by using maplist. Assuming that change Is defined 
as In Chapter 3. maplist would be used as follows: 
1- maplist(change,[you,are,a,computer],Z). 
Z=[i,[am,not],a,computer] 

161 
A simplification of .aplist results In appllst, which simply applies some predicate. 
assumed to have one argument. to each member of a list. 
No new list Is created: 
applist( _, [ ] ) • 
applist(P,[XIL]) ,-
12 - •• [P,X], 
ca11(Q), 
applist( P, L) • 
Notice that the predicate printstring of Chapter 5 could have been replaced by a goal of 
the form applist(put,L), where L Is the string to be printed. 
Mapping Is not restricted to lists. but can be defined for any kind Of structure. 
For 
example. consider arithmetic expressions made up of functors such as ,. and +. each having 
two arguments. 
Suppose we wanted to map one expression Into another. removing all 
multiplications by 1 In the process. 
One way to describe this algebraic simplification would 
be to define a fact s(Op,La,Ra,Ans) which means that If we have an expression consisting 
of an operator Op with a left argument La and right argument Ra. then a simplified form 
Is the expression Ans. 
The facts for removing multiplications by 1 would look like this. with 
two facts accounting for the commutativity of multiplication: 
s(*,X,l.,X). 
s(*,l.,X,X). 
So. given an expression of the form 1*X, this table of simplifications could tell us to map 
it into whatever X is. 
Let us see how we can use this in a program. 
To simplify an expression E using such a table of simplification rules. we need to first 
simplify the left-hand argument of E. then simplify the right-hand argument of E. and then 
see if E is in our table. 
If it is. we make the new expression whatever the table indicates. 
Since we recursiveiy simplify the sub-components of E. E will be in a simplified state when 
it is time to see if it is in the table. 
At the 'Ieaves' of the expression tree there are integers 
or atoms. 
These are simplified into themselves. 
As above. we can use '-•• ' to separate 
E into its functor and components: 
Simp(E,E) ,- atomic(E), I. 
simp(E,F) ,-
E = •• [Op, La, Ra], 
simp(La,X), 
simp(Ra,y), 
s(Op,X,Y,F). 
So. SUlp maps expression E into expression F. using the facts found in a simplification table. 
What happens if no simplification can be made? 
To prevent s(Op,X,y,p) failing. we must 
have a 'catchall' rule at the end of each operator's part of the simplification table. 
The 
following simplification table Includes rules for addition and multiplication. and shows the 

162 
catchall rule for each operator Included: 
s( +,X,O,X). 
s(+,o,X,X). 
s( +,X, Y,X+Y). 
s(*,_,O,O). 
s( * ,0,X, 0). 
S(*,l.,X,X). 
S(*,X,l.,X). 
S( * ,x, Y,X*Y). 
/* catchal.l for + */ 
/* catchall for * */ 
With the 'catchall' rules present. there Is now a choice of how to simplify some expressions. 
For instance. with 3+0, we can either use the first fact. or we can employ the 'catchall' for 
+. 
Because of the way the facts are ordered. Prolog will always try the special case rules 
before the 'catchall's. 
Thus the first solution to simp will always be a true simplification (If 
there Is one). 
However. alternative solutions will not be In the simplest possible form. 
Another simplification used In computer-aided algebra Is known as constant folding. 
The expression 3'"4+a can have the constants 3 and 4 'folded' to form the expression 12+a. 
The folding rules can be added to the appropriate parts of the simplification table above. 
The rule for addition Is 
s(+,X,Y,Z) 1- integer(X), integer(Y), Z is X+Y. 
The rules for the other arithmetic operations are similar. 
In commutative operations such as multiplication and addition. the simplifications described 
above may have different effects on expressions that are written differently but are algebraically 
equivalent. For example. If a folding rule Is available for multiplication. then the simp predicate 
will faithfully map 2'"3'"a Into 6'"a. but a'"2'"3 or 2'"a'"3 will be mapped Into themselves. 
To 
see why this Is. think about what the expressions look like as trees: 
2*3*a ~ 
* 
a*2*3 
/ \ 
* 
a 
/ \ 
2 
3 
* 
/ \ 
,. 
3 
/ \ 
a 
2 
The first tree can have Its bottom-most multiplication folded from 2*3 Into 6. but the second 
tree has no sub-tree that can be 'folded. 
Because multiplication Is commutative. adding the 

163 
following rule to the table will suffice for this particular case: 
s(*,X*Y,W,X*Z) :- integer(Y), integer(W), Z is Y~. 
A more general algebra system can be constructed simply be adding more s clauses. Instead 
of adding more "programming" to SDip. 

Chapter 8. Debugging Prolog Programs 
By this point you will have used and modified many of the example programs described 
earlier. and you will have written programs of your own. 
The problem of what to do when 
your program does not behave as expected is now relevant. 
Problems with programs are 
known as 'bugs'. and the process of removing bugs from programs is known as "debugging'. 
We believe that a convenient approach to programming is what could be described as 
'preventative programming'. 
To paraphrase an old proverb. an ounce of careful programming 
Is worth a pound of debugging. 
In this chapter we shall attempt to describe some techniques 
for debugging. but we shall start with a discussion of how to try to prevent bugs from infesting 
your programs. 
We realise that such a problem is unsolved in general. but we simply wish 
to convey some informal techniques that have helped other Prolog programmers. 
As with any creative aCtivity. be it musical composition. literature. or architecture. 
computer programming offers a multitude of methods for expressing how to represent and 
manipulate the objects and relationships that are found In a particular problem. 
In general. 
there will be a number of ways to represent or manipulate some' item of information in a 
program. 
Every time the programmer decides to use one of the ways in the program. we 
say that the programmer has made a design decision. 
Novices faced with the task of making design decisions for the first time often feel 
confused. 
An understanding of the choices available will help them. and it is important for 
a tutor to explain programming techniques in general. 
This is because the art of making 
design deCisions in programming is a discipline in its own right. 
We attempted to give the 
flavour of this problem in Section 1.1 when we discussed the different ways to interpret ciauses. 
This is a matter of representing objects and relationships. 
Also. in Section 7.7 the problem 
also became apparent when we described three different ways to sort a list Of objects. 
This 
is a matter of different ways to manipulate objects and reiationships. 
We hope that this book provides help about making design decisions in two ways. 
First. 
by containing a number of example programs. it should convey some idea of the solutions 
that practising programmers have obtained. 
Second. this chapter should provide some advice 
and direction that is specific to Prolog. 

165 
8.1 
La~ng out ~nPft8 
Assuming that the programmer has decided how to represent and manipulate the objects 
and relationships In the problem. the next step Is to ensure that the layout and syntax of 
the program Is clear and easily read. 
The collection of clauses for a given predicate Is 
called a procedure. 
In the examples In this book. you may have noticed that each clause 
In a procedure has started on a new line. and there Is one blank line between procedures. 
For example. one way to define the set equality predicate (representing sets as lists) Is to 
use three predicates. each of which Is defined by a twO-line procedure: 
eqset(X,X) ,- I. 
eqset(x,Y) ,- eqlist(X,Y). 
eqlist([],[]). 
eq11st([XILl],L2) ,- de1ete(X,L2,L3), eq11st(L1,L3). 
de1ete(X, [XIY], Y). 
de1ete(x,[YIL1],[YIL2]) ,- de1ete(X,L1,L2). 
This Is not necessarily the best definition of set equality. but It points out how to layout 
procedures. Notice that the clauses for each procedure are grouped together. and procedures 
are separated by a blank line. 
Notice also that the body of each rule Is short enough to 
fit on one line. 
Another convention that Is adopted by many Prolog programmers Is to write 
each clause on a single line If the entire clause will fit on a line. 
Otherwise. write the head 
of the clause and the ':-' on the first line, and write each goal of a conjunction Indented 
on a separate line. 
For example, a program to generate all permutations of a list: 
permute( [ ] , [] ) • 
permute(L,[HIT]) ,-
append(V, [HIU] ,L), 
append(V,U,W), 
permute(W,T). 
The definition uses a backtracking append, so that another permutation Y is generated from 
X each ti,:"e an attempt is made to re-satisfy permute(x, Y). 
What we should notice here 
is the way the conjuncts in the second clause are laid out on the page. 
The main point Is to decide on consistent conventions. whatever the conventions may 
be. In general. It Is wise to add comments. to group terms appropriately. to use round brackets 
when in doubt about operator precedences. and to use plenty of white space (spaces and 
blan"k lines) In consistent ways. 
Comments should indicate how the arguments of a structure 
(or clause) are interpreted: what order they come in. and what data structures (constants or 
structures) are expected" to fill each argument. 
Also. It Is wise to write comments on the 
way that variables are expected to become instantiated as the clause becomes satisfied. 
For more global organisation of the program. It is helpful to divide the program into 

166 
reasonably self-contained parts. for example. where all of the list processing procedures would 
appear In the same file. 
A Prolog procedure that uses more than about five to ten rules 
may be hard to read. so consider whether It can be broken up naturally by the definition 
of some subsidiary predicates. 
If a program uses many facts. such as the simplification rules 
In Section 7.12. then all of the facts should belong together In the. same file. 
A lot of facts 
Is generally easier to read than a lot of rules. and although even a few rules may be difficult 
to understand. many pages of a particular fact can be understood because the semantics 
of facts are less complex. 
Another Issue that affects the ease In which Prolog programs can be read Is the use 
of semicolon ("or") and exclamation ("cut"). The problems with over-using "cut" were Introduced 
In Chapter 4. You should always consider whether It may be worthwhile avoiding a , by defining 
extra clauses. 
For Instance. the following program: 
nospy(X) :-
chedk(X,Functor,Arity,A), I, 
( spypoint(_,Functor,A), I, 
( deny(spypoint(Head,FUnctor,Arity),_), 
makespy( Head, Body) , 
deny(Head,Body), 
write( 'Spy-point on '), prterm(FUnctor,Arity), 
write(' removed.'), n1, 
fail 
), 
I. 
true 
write('The~e is no spy-point on '), 
write(X), put(46), nl 
is much harder to understand than: 
nospy(X) :-
chedk(X,Functor,Arity,A), I, 
try_remove(X,Functor,Arity,A). 
try_remove(_,Functor,Arity,A) :-
spypoint(_,Functor,A), I, 
remove_spy(Functor,Arity,A). 
try_remove(X,_,_,_) :-
write('There is no spy-point on '), 
write(X), put(46), n1, I. 
remove_spy(FUnctor,Arity,A) :-
deny(spypoint(Head,Functor,Arity),_), 
makespy(Head,Body), 
deny(Head,Body), 
write('Spy-point on '), prterm(Functor,Arity), 
write(' removed.'), nl, fai1. 
remove_spy(_,_,_). 
which does exactly the same thing. 
When you really do want to use "or". It is helpful to 
arrange the conjunction of goals so that the "or" stands out from the rest of the goals. and 

167 
to place brackets around the goals so that the scope of the "or" Is made explicit. 
Throughout the book. we have emphasised the Importance of thinking of many problems 
In terms of boundary conditions together with a general rule. 
Whenever possible. we write 
boundary conditions before all the other clauses of a procedure. 
This makes It easy to see 
what the boundary conditions are. and also provides some measure of protection against 
circular definitions. However. there are some cases where It Is desirable to place the boundary 
condition after the other clauses of a procedure. 
Obviously. "catchall" rules. as seen several 
times previously. need to be placed at the end of the procedure. 
When reading a Prolog procedure. It Is helpful to look each time for the following key 
properties of the procedure. 
o 
Look at how each predicate and variable In the procedure Is spelled. 
Mis-spelling 
Is a common mistake. 
o 
Look for the number of arguments of each functor that Is mentioned In the procedure. 
Ensure If the number of arguments (and their order) Is consistent with your design 
decisions. 
o 
Locate all of the operators In the clauses. and determine their precedence. associativity. 
and where their arguments are. 
You can determine this from operator declarations 
and the presence of brackets. 
When In doubt. add extra brackets. 
Also. to check 
whether an operator behaves In the way you expect. try printing out some sample 
terms using displ.ay. 
o 
Notice the scope of each variable. and locate all the like-named variables within the 
scope. 
Notice which variables will "share" when one of them becomes Instantiated. 
Notice whether variables In the head of the clause appear In the body of the clause. 
o 
Try to determine what variables are Instantiated or unlnstantlated at the time the clause 
will be used. 
o 
Locate the clause(s) that constitute the boundary condltion(s). 
Determine whether all 
the conceivable boundary conditions have been accounted for. 
Once you can "dissect" a procedure In this way. your understanding of the procedure will 
Improve. 

168 
8.2 
Common Errors 
In this section we list a number of problems that both beginning and experienced Prolog 
programmers encounter. 
The problems fall into two categories: 
errors of syntax, and errors 
of control flow. 
Once the programmer has decided what program to write, and how to lay it out on the 
printed page (or terminal display screen), there is the f,lroblem of getting the program into 
a file or typing it straight into the top level of a Prolog system. The main problem encountered 
here is ensuring that the syntax of the program is correct. 
Here we list a number of common 
syntactic errors. 
If these errors are not detected by the programmer, Prolog may provide 
an error message when an attempt Is made to consu1t the program. 
o 
A common syntax error Is forgetting to add the dot ',' at the end of a clause. 
A 
dot must also always follow any term that is read by the read predicate. 
You must 
also leave at least one ·white space" character after the dot. 
So beware of ending 
a disc file with the dot of the last clause -- make sure that there is a 'return' at 
the very end. 
o 
Some special characters belong in pairs. 
There are the round brackets '(' and ')' 
for bracketing terms and clauses, the square brackets T and T for the list notation. 
and the curly brackets '{' and 'J' for the grammar rule notation (Chapter 9). 
Also, 
the double quote (") for denoting strings, and the single quote (') for atoms, belong 
in pairs. 
The composite brackets 'I'" and '''I' surround comments. 
Ensure that there 
are neither too few or too many of each kind of bracket. 
o 
Beware of mis-spelled words, especially the names of built-in predicates. 
These can 
cause unexpected failures. because mis-spelled predicates are unlikely to match with 
any clauses In the database. Or, they may unexpectedly match with clauses that happen 
to have the same name as the mis-spelled one. 
o 
Operators are another source of possible errors. 
Use round brackets when In doubt. 
to make the associativity of an operator explicit. 
Use disp1ay to experiment with the 
operators you have defined. 
o 
The list notation: 
beginners may have difficulty with the following questions: 
How do [a,b,c] and [XIYl match? (X Is Instantiated to a, and Y Is instantiated to (b,c]). 
Do [a] and [XIYl match? (Yes. 
X Is Instantiated to a, and Y is instantiated to OJ. 
Do [] and [XlV] match? (no). 
Is [X,YIZ] meaningful? (yes). 
Is [XIY.Zl meaningful? (no>. 
Is [Xl[YIZlJ meaningful? (Yes, it Is the same as (X, YIZ]). 
How do [a,b] and [AlB] match? (A is instantiated to a, and B is instantiated to (bl). 

169 
Is there more than one way to match them? (No. never). 
When dealing with lists. or any other structure for that matter. it is important to stress the 
helpfulness of the ·tree diagrams" that we introduced in Chapter 2. 
Even if you are certain that a program is free from syntax errors. the program can stili 
exhibit unexpected behaviour when an attempt is made to satisfy goals in the program. 
Typical 
symptoms are a program which seems to run without stopping (an ·infinite loop"). the response 
no appearing unexpectedly. or variables being instantiated to unexpected terms. 
Usuai sources 
of errors are: 
o 
Circular definitions, which were mentioned in Chapter 3. 
o 
Not enough boundary conditions, or some other underspecification of the problem. 
o 
Useless procedures that redefine built-in predicates. 
o 
Supplying the wrong number of arguments to a functor. 
This is not considered a 
syntax problem because the number of arguments of a functor depends on what the 
functor is used for. 
o 
Unexpectedly reaching the end of a file when using the read predicate. 
Beware of the following fallacies about the nature of backtracking: 
o 
Fallacy: 
One of the reasons for backtracking is so that Prolog can return to a previous 
match and do it again in some other way. 
Fact: 
When Prolog searches the database 
in an attempt to match a goal against something in the database (a fact or the head 
of a rule), the match either succeeds or fails. 
Prolog does not backtrack to a "match" 
and try to match another way. because there is only one way to match a particular 
goal with a particular clause in the database. 
o 
Fallacy: 
The list notation [XiYl can match against any segment of a list. and can 
take apart lists in several different ways. 
The behaviour of append(X, Y, [a,b, c,d] ) 
is due to this. 
Fact: 
In [XiYl, X matches only the head of a list. and Y matches 
only the tail. 

170 
8.3. Another ConlTol Flow Model 
There are different ways of looking at the method by which Prolog attempts to satisfy 
goals. 
We have dealt with some of these in Chapters 1. 2. and 4. 
Another way of looking 
at the 'flow of satisfaction' is the box model. due to our colleague Lawrence Byrd. 
This 
section describes the box model. which is an aid to debugging. 
You should be familiar with 
the box model before you start to use the Prolog debugging facilities. 
When the trace facility is used. the Prolog system prints out 
information about the 
sequence of goals in order to show where the program has reached in Its execution. 
However. 
in order to understand what is happening. it is important to understand when and why the 
goals are printed. 
In a conventional programming language. the key pOints of interest are 
the entries to and exits from functions. 
But Prolog is a non-determinate language. and this 
introduces the complexities of backtracking. 
Not only are clauses entered and exited. but 
backtracking can suddenly reactivate them in order to generate an alternative solution. 
Furthermore. the cut symbol 'I' Indicates what goals are committed to having only one solution. 
One of the major confusions that novice programmers face is what actually occurs when a 
goal fails and the system suddenly starts backtracking. 
We hope this has been adequately 
explained in the previous chapters. 
However. the previous chapters discussed not only control 
flow. but also how variables are instantiated. how goals match against clause heads In the 
database. and how subgoals are satisfied. 
The box model only makes explicit the control 
flow through clauses. which Is what the trace facility displays. 
Let us look at an example Prolog procedure. seen surrounded by a box: 
CALL +-
--> 
descendant(X,Y) :-
FAIL 
offspring( X. Y) . 
descendant(X,Z) :-
offspring(X, Y), 
descendant( Y • Z) • 
---+ EXIT 
1 
--> 
1 
1 
1 
1 
1 
1 REDO 
--, _________________ 1 -, 
This simple example derives descendants of a person. provided that there are offspring facts 
in the database. such as 
offsprinq(abraham,ishmael). 
offsprinq(abraham, isaac). 
offsprinq(isaac,esau). 
In the box. the first clause states that Y is a descendant of X If Y is an offspring of 

171 
X. and the second clause states that Z Is a descendant X If Y Is an offspring of X and If 
Z Is a descendant of Y. 
In the diagram we have drawn a box around the whole procedure 
and added some labelled arrows which Indicate the control flow In and out of the box. 
There 
are four such arrows which we shall look at In turn. 
CALL. 
This arrow represents the Initial Invocation of the procedure. 
When an attempt Is 
made to satisfy a goal of the form descendant(X,y), control passes through the CALL port 
of the descendant box with the Intention of matching a component clause and then satisfying 
any subgoals In the body of that clause. 
Notice that this Is Independent of whether such 
a match Is possible -- the box Is CALLed. and then such matters are worried about. Textually 
we can Imagine moving our finger to the code for descendant when meeting a call to 
descendant: In some other part of the code. 
EXIT. 
This arrow represents a successful return from the procedure. 
This occurs when the 
Initial goal has been matched with one of the component clauses and any subgoals have been 
satisfied. 
Control now passes out of the EXIT port of the descendant: box. 
Textually we stop 
following the code for descendant: and go back to the place we came from. 
REDO. (meaning "do again") This arrow Indicates that a subsequent goal has failed and that 
the system Is backtracking In an attempt to find alternatives to previous solutions. 
Control 
passes through the REDO port of the descendant: hox. An attempt will now be made to resatlsfy 
one of the component subgoals In the body of the clause that last succeeded: or. If that 
falls. to match the original goal with an alternative clause and then try to satisfy any subgoals 
In the body of this new clause. 
Textually we follow the code backwards up the way we came 
looking for new ways of succeeding. possibly dropping down on to another clause and following 
that If necessary. 
FAIL. 
This arrow represents a failure of the Initial goal. which might occur If no clause Is 
matched. or If subgoals are never satisfied. or If any solution produced Is always rejected 
by later processing. 
Control now passes out of the FAIL port of the descendant: box and 
the system continues to backtrack. 
Textually we move our finger back to the code which 
called this procedure and keep moving backwards up the code looking for alternative matches. 
In terms of this model. the Information we get about the procedure box Is only the control 
flow through these four ports. 
This means that at this level we are not concerned with which 
clause matches. and how any subgoals are satisfied. but rather we only wish to know the 
Initial goal and th? final outcome. 
However. It can be seen that whenever we are trying to 
satisfy subgoals. what we are actually doing Is passing through the ports of their respective 
boxes. 
If we were to follow this. then we would have complete Information about the control 
flow Inside the descendant procedure box. 
We shall go on to consider an example. but first 
we should point out that the box we have drawn round the procedure should really be seen 
as an Invocation box. 
That Is to say. we will have a different box for each different Invocation 
of the procedure (each time we try to satisfy descendant:(X,y) for some X and Y>. 
Obviously. 

172 
with something like a recursive procedure, we are going to have lots of different CALLs and 
EXITs In the control flow but these will be for different Invocations. 
Since this might get 
confusing we shall give each Invocation box a unique integer Identifier. 
Furthermore, since 
each Invocation of a clause means that all the variables In the clause will be new ones, we 
have given each use of a variable a unique name formed by appending an Integer to the 
original variable name. 
Let us now take a look at an example. 
We shall use the descendant procedure we 
have been looking at and we shall follow the control flow through all of the ports of this 
procedure and of the offspring procedure. 
First let us reproduce the program within boxes: 
+---------------------------------------+ 
~L 1 
EnT 
---) 1 descendant(X,Y) ,-
(---
FAIL 
+------------+ 
--) 
1 --) 
I offspring( x, Y) I 
(-- 1 
1 (--
+--------------+ 
descendant(X,Z) ,-
+-------------+ 
+----------+ 
--) 1 
--) 
1-) 
I offspring(X,Y) 1 
1 descendant(Y,Z) 1 
(--
(-- 1 
1 (--
+-------------+ 
+----------+ 
+--------------------------------------+ 
+------------------------+ 
CALL 
1 EXIT 
---) 
1 ---) 
(---
FAIL 
offspring(abraham,ishmael) 
offspring(abraham,isaac) 
offspring(isaac,esau) 
offspring(isaac,jacob) 
+------------------------+ 
(--
REDO 
-) 
(--
REDO 
It Is important that you try to follow the trace we are about to look at by physically tracing 
along the arrows entering and leaving the above boxes. 
This will show how It Is possible 
to follow the execution in terms of up-and-down movement in the program text. 
Backtracking 
Is followed by moving your finger back up the code; every goal you meet can be seen as 
a REDO in the trace. 
If this goal can be resatlsfied then we come out at the EXIT port 
and travel down the text as normal. trying again to satisfy all the following goals. 
If the goal 
fails then we come out at the FAIL port and keep going backwards looking for another 
alternative. 
The fact that we are following all the previously executed goals back the way 
we came. means that it is very easy to see where another alternative Is found. 

173 
To begin this example. we shall ask the following question: 
?- descendant:( abraham,lINS), 
fai~. 
The first goal In the question Is followed by a f~. This purpose of this Is to force all 
possible backtracking behaviour out of the descendant: procedure. 
The command as a whole 
can therefore never succeed. 
However. the point of this trace Is to observe the execution 
flow Induced by the failure of the second goal (the f~). We begin with the question. which 
Is enclosed In a box as the other goals are: 
-> 
->-) 
?-
descendant:(abraham,lINs) 
fai~ 
(-
(-
(-
Control first passes through the CALL port of the descendant: box. 
This Is Invocation number 
1. 
(~) CALL: descendant:( abraham,lINs) 
(2) CALL: offspring( abraham,lINS) 
We have matched the first clause of the descendant: procedure and this results In the control 
flow passing through the CALL port of offspring. 
( 2) EXIT: offspring( abraham, ishmae~) 
Immediate success on the first clause. and control passes out through the EXIT port. 
(1) EXIT: descendant:( abraham, ishmae~) 
And thus we have satisfied the first descendant: clause. 
(3) CALL: faH 
(3) FAIL: faH 
(1) REDO: descendant:( abraham, ishmae~) 
Then we try to satisfy fai~, and. as might be expected. this succeeds. causing failure. 
Control 
passes out of the FAIL port of f~ and we are now backtracking. moving In the opposite 
direction from before. looking for alternatives. 
When we REDO descendant: we are In exactly 
the same place as when we left except for the direction of movement. 
Hence the Instantiation 
state of the goal. 
If you wish to know the original state of the goal. then look back to the 
CALL port corresponding to this Invocation number. 
( 2) REDO: offspring( abraham, ishmae~) 
( 2) EXIT: offspring( abraham, isaac) 

174 
We REDO offspring and drop down onto the next clause thus producing an alternative solution. 
( ~) EXIT: descendant( abraham, isaac) 
( 4) CALL: 
fai.~ 
( 4) FAIL: 
fai.~ 
( ~) REDO: descendant( abraham, isaac) 
Again. fail causes us to reject this solution and to start backtracking. 
Notice that this was 
a completely new invocation of f~. 
( 2) REDO: offspring( abraham, isaac) 
(2) FAIL: offspring( abraham,ANS) 
This time. offspring cannot offer us another match and so we continue backtracking with 
control passing out through the FAIL port. 
( 5) CALL: offspring( abraham, Y) 
What has happened here is that we have dropped down onto the second descendant clause 
and this is a completely new offspring invocation corresponding to the first subgoal. 
(5) EXIT: offspring( abraham, isbmae~) 
(6) CALL: descendant( isbmael,ANS) 
This provides a solution with which we now recursively call descendant. 
This gives us a 
I new Invocation of descendant. 
(7) CALL: offspring(isbmae~,ANS) 
(7) FAIL: offspring(isbmae~,ANS) 
(8) CALL: offspring(isbmae~,Y2) 
(8) FAIL: offspring(isbmae~,Y2) 
(6) FAIL: descendant( isbmae~,ANS) 
Ishmael has no offspring (In this example). and so the offspring subgoals In both descendant 
clauses fall. thus failing the descendant goal. 
( 5) REDO: offspring( abraham, ishmae~) 
Back we go for an alternative. 
( 5) EXIT: offspring( abraham, isaac) 
(9) CALL: descendant(isaac,ANS) 
(~o) CALL: offspring(isaac,ANS) 
(~o) EXIT: offspring(isaac,esau) 
We get a new Invocation of descendant and the offspring subgoal succeeds. 
(9) EXIT, descendant(isaac,esau) 
( ~) EXIT: descendant( abraham, esau ) 
( 11) CALL: 
fai.~ 

( 11.) PAIL I fail 
( 1) REDO I descendant( isaac, esau ) 
( 9) REDO: descendant( isaac, esau ) 
175 
This provides a final solution to the Initial question. but the fail forces backtracking again 
and so back we come along the REDO paths. 
(10) REDO: offspring(isaac,esau) 
(10) EXIT: offspring(isaac,jacOb) 
(9) EXIT: descendant(isaac,jacob) 
(1) EXIT I descendant( abraham, jacob) 
The offspring subgoal has another alternative which produces another result for the Initial 
descendant goal. 
As can be seen. this Is Abraham's last possible descendant. however there 
Is a certain amount of work left to be done. 
Let us continue to follow the control flow as 
It backtracks unsuccessfully back to the beginning. 
( 12) CALL: fail 
(12) PAIL: fail 
( 1) REDO: descendant( abraham, jacob) 
(9) REDO. descendant(isaac,jacob) 
(10) REDO. offspring(isaac,jacob) 
(10) PAIL: offspring(isaac,ANS) 
(13) CALL: offspring(isaac,Y3) 
We are now trying the second clause for descendant. 
(13) EXIT: offspring(isaac,esau) 
(14) CALL: descendant(esau,ANS) 
Recur again. 
(15) CALL: offspring(esau,ANS) 
(15) PAIL: offspring(esau,ANS) 
(16) CALL: offspring(esau,Y4) 
(16) PAIL: offspring(esau,Y4) 
(14) PAIL: descendant(esau,ANS) 
(13) REDO: offspring(isaac,esau) 
(13) EXIT: offspring(isaac,jacob) 
(17) CALL: descendant( jacob,ANS) 
Try jacob. 
(18) CALL. offspring(jacob,ANS) 
(18) PAIL. offspring(jacob,ANS) 
(19) CALL. offspring(jacob,Y5) 
(19) FAIL. offspring(jacob,Y5) 
(17) FAIL: descendant(jacob,ANS) 
(13) REDO: offspring(isaac,jacOb) 
(13) FAIL: offspring(isaaC,Y3) 
(9) FAIL: descendant(isaac,ANS) 
(1) PAIL: descendant( abraham,ANS) 
no 

176 
And that's the end of that. 
We hope that this exhaustive example has provided an 
understanding of the control flow Involved In the execution of a Prolog program. 
You should 
have noticed that for any Invocation there Is always only one CALL and FAIL. although there 
may be arbitrarily many REDOs and corresponding EXITs. 
It Is the Initial call which Introduces 
the Invocation and It Is here that we first see the new Invocation numbers. In the next section 
this model Is used to show how the behaviour of a more complicated example -- append 
-- can be traced. 
If you followed the steps above by tracing along the arrows linking the boxes In the 
code then you will have a good Idea of the sense In which this Is a 'textual processor' model 
of Prolog.· 
The execution of the program can be directly followed In the program text. 
Exercise II In the above model. no mention Is made of how the cut goal 'I' Is handled. 
Extend the model to account for the action of cut. 
8.4 Tracing and Spy PolnfB 
When you find that your program doesn't work (because It generates an error. Just says 
'no' or produces the wrong answer). you will want to find out quickly where the mistakes 
are so that you can correct them. 
This section describes a set of built-In predicates that 
allow you to 'watch' your program running. 
Using these. you can give your program the 
same task again. and watch to see where It starts going wrong. 
What you will see Is how 
the program progresses through the ports of the box model. In the same way as we saw 
how descendent behaved In the last section. The exact facilities that the debugging predicates 
provide will depend on the particular Prolog implementation. but the following should give some 
guide about the sorts of options. so that you can make sense of what your system provides. 
In any case. you are strongly advised to consult the documentation for your Prolog system 
before you start using these facilities. 
The basiC principle behind tracing and spy points Is that the programmer is Informed 
about the satisfaction of certain goals that arise In the running of his program. 
The 
programmer can decide. first. what goals he wishes to be informed about. and second. how 
much he wants to Interact with their satisfaction. 
The first decision Involves deciding what 
combination of exhaustive tracing and spy points he will use. 
B.asicaily. exhaustive tracing 
Involves Information being given about aI/ goals. and spy points enable the programmer to 
get only Information about certain predicates that he has specified. 
However. these options 
can be mixed in various ways. 
Section 6.13 outlines the relevant built-In predicates that are 
of use here. 
To set a spy point on a predicate. we use predicate spy (and to remove a 
spy point. we use nospy). 
To start exhaustive tracing. we use trace (and to turn it Off. 

177 
we use notrace ). 
The second decision Involves deciding on the level of leashing· that Is to be used. 
In 
unleashed tracing. Information about the goals Is displayed on the terminal and the program 
keeps on running. 
In leashed traCing. as well as the Information being displayed. the 
programmer Is asked at each point what he wishes to do. 
He can then specify changes 
In the level of tracing. alterations fr.om the normal flow of the program and various other 
options. 
Your Prolog system may provide an Independent choice of leashed or unleashed 
tracing at each of the four ports for a goal: 
C 
When an attempt Is first made to satisfy the goal --
when the goal Is encountered 
for the first time (the CALL port>. 
C 
When the goal has successfully been satisfied (the EXIT port>. 
C 
When an attempt Is about to be made to resatlsfy the goal (the REDO port>. and 
C 
When the goal Is about to fall. because all attempts to resatlsfy It have failed (the 
FAIL port>. 
For Instance. a reasonable choice would be to specify that CALL and REDO ports are leashed 
and EXIT and FAIL ports are unleashed. 
We gave a more detailed description of these four 
stages of the satisfaction of goals In Section 8.S. 
Now let us consider the Information that Is given to you at a port of a goal you are 
Interested In. 
First of all. the goal Itself Is shown. together with an Indication of which port 
Is Involved 
and perhaps an Invocation number. 
If tracing at this port Is u'"!leashed. this 
Is all that Is provided. 
Otherwise. Prolog will also ask you to specify one of a set of options 
about what should be done next. 
A session with exhaustive. unleashed tracing would look 
something like: 
1- [user]. 
append( [ ] , Y , Y ) • 
append([AIB],C,[AID]) :- append(B,C,D). 
/* type the end of file character here */ 
yes 
1- append([a],[b],X). 
CALL append([a],[b],_43) 
CALL append([],[b],_103) 
EXIT append( [], [b], [b» 
EXIT append([a],[b],[a,b]) 
x -
[a,b]1 

178 
REDO append([a],[b],[a,b]) 
REDO append([],[b],[b]) 
PAIL append([],[b],_~03) 
PAIL append([a] , [b],_43) 
no 
?- append(X,Y, [a]). 
~ 
append(_37,_38,[a]) 
EXIT append([],[a],[a]) 
X - [], Y -
[a]; 
REDO append([],[a],[a]) 
~ 
append(_93,_38,[]) 
EXIT append([],[],[]) 
EXIT append([a],[],[a]) 
X -
[a], Y -
[]; 
REDO append([a],[],[a]) 
REDO append([],[],[]) 
FAIL append(_93,_38,[]) 
PAIL append(_37,_38, [a]) 
no 
Here. all four ports of all goals are being shown on the terminal. 
However. the programmer 
Is not given any chance to make the program pause at any point. change the amount of 
tracing half way through or affect the way it runs In any other way. 
These facilities are what 
leashed tracing provides. 
Before we go on to discuss leashed tracing. we should make some remarks about how 
Prolog shows your goals when you are tracing. 
Now. actually the way your goals are shown 
by the tracing facilities Is not necessarily the same as If they were output using write. 
This Is because you are allowed to provide your own special purpose definitions for showing 
the goals In your program. 
You can use this facility to output some of the common structures 
used In your program in ways that are clearer or more concise than write would normally 
produce. 
The way the facility works Is as follows. 
The standard way of printing your goals 
Is actually by using the built-In predicate print, with one argument. print works as If It Is 
defined as follows: 
print(X) ,- portray(X), I. 
print(X) ,- write(X). 
Now. the predicate portray Is not a built-In predicate. and so you can provide clauses for 
It yourself. 
If your clauses allow the goal portray(X) to be satisfied for one of your goals 
X. then It will be assumed that that provides all the necessary output. 
Otherwise. the goal 
will be output using write Instead. 
So If for some reason you did not want to ever see 

179 
the third arguments of append goals. you could make sure of this by providing the clause: 
portray(append(A,B,C» ,-
write( 'append('), write(A), write(','), 
write(B), write( ','), 
write( '<foo»'). 
Whenever a goal X involving append occurs. this clause will cause the goal portray(X) to 
succeed. and so It will provide the only output. 
For a goal Involving any other predicate. 
portray(x) will fall. and X will be output using write. If the above clause was In the database. 
part of the above example session would look like the following: 
1- append( [a], [b] ,X). 
CALL append([a],[b],<foo» 
CALL append([],[b],<foo» 
EXIT append([],[b],<foo» 
EXIT append([a],[b], <foo» 
X = [a,b]; 
REDO append([a],[b],<foo» 
REDO append([],[b],<foo» 
FAIL append([],[b],<foo» 
FAIL append([a],[b],<foo» 
no 
Now for a discussion of leashed tracing. 
If you have specified leashed tracing at some 
port you will be asked to specify what should be done next when such a port is reached. 
This will look something like the following at the terminal: 
1- append( [a], [b] ,X). 
CALL append([a], [b],_43) ? 
The program stops after typing out the '7'. 
You are now supposed to reply by specifying 
one of a set of possible options. 
If the option you specify Involves the program continuing 
as usual. It will then run on as far as the next leashed port for a predicate being traced. 
and again ask you. with something like: 
CALL append([],[b],_103) ? 
One of the options is likely be to cause a list of available options to be displayed at the 
terminal. 
Here are some of the options that may be available: 
Examining the goal 
The first set of options involve looking at the goal in various ways. 
As we have seen. 

180 
the standard Is for a goal to be shown using print. which gives your portray clauses a 
chance to show things In a special way. 
However. you may start to have doubts about the 
correctness of your portray clauses. or Just want to see a goal written In the normal way 
for a change. 
Hence Prolog will allow you to either write or disp1ay the current goal as 
a possible option. 
In this case. the program will not run any further. but you will be asked 
for another option that will specify how the program should continue. 
A typical Interaction 
might be: 
?- append( [a]. [b] .X). 
CALL append([a].[b],<foo» 
? write 
CALL append([a],[b),_103) ? 
Usually you will only want to use write as an alternative way of looking at a goal. 
You might 
want to use disp1ay when the goal Involves many operators. and you have forgotten what 
their various precedences are. 
In such a case. disp1ay will enable you to see the nesting 
of functors unambiguously. 
Examining the Ancestors 
The ancestors of a goal are those goals to which Its satisfaction will eventually contribute. 
Thus every goal has an ancestor which Is one of the goals In the original question --
the 
one that It Is helping to satisfy. 
Also. whenever a rule is used. each of the goals Introduced 
by the rule body has as an ancestor the goal that matched the rule head. 
Let us look at 
some examples of ancestors. Consider the following simple program to reverse a list (described 
in Section 7.5): 
rev( [ ) , [ ] ) . 
rev( [HIT] ,L) ,- reveT, Z), append( Z, [H] ,L). 
append( [] ,X,X). 
append([AIB),C,[AIDJ) ,- append(B,C,D). 
If we ask the initial question: 
?- rev([a,b,c,d],X). 
(A) 
then. because of the second clause. there will be two subgoals to satisfy. 
Each of these 
has the goal In the question as Its Immediate ancestor. 
The subgoals are: 
rev( [b,c,d] ,Z) 
append( Z, [a] ,X) 
(B) 
(C) 
Since the second clause will be used again to satisfy (S). again two subgoals will be Introduced. 
rev( [c,d], Zl) 
append( Zl, [a] ,Z) 
(D) 
(E) 

181 
These will have as their ancestors goals (A) and (B). 
Note that goal (C) Is not an ancestor 
of these. because they are only contributing Immediately to the satisfaction of (B). which 
contributes to the satisfaction of (A). 
Goals (0) and (E) are not contributing In any way to 
the satisfaction of (C). 
When the satisfaction of this question has progressed fairly far. a 
goal of the form: 
append( [c], [b], Y) 
will appear. 
At this stage. the goal and Its ancestors might be displayed as follows: 
(1) rev([a,b,c,d],_49) 
(2) rev([b,c,d],[dl_SO]) 
(3) append([d,c],[b],[dl_Sl]) 
(4) append([c],[b],_S2) 
(Goal A) 
(Goal B) 
Before you read any further. you should make sure that you understand why these are all 
ancestors of the goal. and why there are not any more ancestors. 
There Is one peculiarity 
with the way the ancestors are shown 
here. which may be reflected In your Prolog system. 
There are two possible ways of printing out an ancestor 
as It was when an attempt was 
first made to satisfy It. or as it stands now. with any variables as they are now Instantiated. 
Here we have adopted the second course. 
When the goal (B) was first encountered. the 
second argument of rev was unlnstantlated. 
However. that argument Is shown with a value 
in the ancestor list. 
This is because by now the variable that was In that position has become 
Instantiated -- by now we have found out that the first element of the reverse of [b.c.d) Is 
d. 
By looking at the ancestors of the current goal. you can get a fair Idea what your program 
Is up to. and why Is Is doing what It Is. 
One of the options that a Prolog system may provide 
at a leashed port of a goal is for some of the current ancestors to be printed out. 
So If 
your program seems to be spending a lot of time somewhere and you suspect that It may 
be In a loop. a good strategy is to interrupt the execution. turn on full tracing and then take 
a look at the ancestors to see where you are. 
Another set of options that may be available at a leashed port concerns changing how 
much tracing is going on. 
Some of the more coarse controls that you can exercise are: 
o 
Removing all spy points. 
This has the same effect as Invoking the goal 
nodebuq 
(Section 6.13). 
o 
Turning exhaustive tracing off. 
This has the same effect as Invoking the goal notrace 

182 
(Section 6.13) 
[J 
Turning exhaustive tracing on. 
This has the same effect as invoking the goal trace 
(Section 6.13). 
With all of these. your program will subsequently carryon running until it reaches a goal 
that you wish to trace. given your new conditions. 
Depending on what version of Prolog you 
use. more local controls of tracing may be available. 
These help you to quickly get over 
bits of the program's execution that are of little interest. so that you can concentrate on where 
the bugs seem to be. 
Possible options here are: 
[J 
("creep") Carry on with the program. doing exhaustive tracing. until you are prompted 
again (at the next leashed port>. 
[J 
("skip") Carry on with the program. and produce no trace messages at all until a 
port of the current goal is next arrived at. 
[J 
("leap") Carry on with the program. producing no trace messages until either a spy 
point is reached or a port of the current goal is arrived at. 
The first of these is what you will want to use if you want to follow the program closely at 
this point. 
The second is for when you are not worried about how a certain goal is satisfied. 
and just want to move on quickly to what happens afterwards. 
The third is for when there 
m'.ly be a lot of uninteresting work going on in the satisfaction of a goal. but somewhere 
in the middle a goal that is of interest (which has a spy point> will occur. 
Hence you want 
to ignore everything until either that spy point is reached or (If the program is faulty) if the 
current goal succeeds or fails without ever reaching the spy point. 
Here is an example of 
the use of 'creep' and ·skip·. 
Let us assume that there is a bug in the naive sort program 
given in Section 7.7. but that we are confident that our program to generate permutations 
Is all right. 
If you remember. the definition of sort started as follows: 
sort(X,Y) ,- permutation(X,Y), sorted(Y), I. 
We can use the 'skip' option to avoid having to look at the gory details of how peJ:llUtation 
works. and produce a trace that starts as follows: 
CALL sort([3,6,2,9,20),_45) ? creep 
CALL permutation([3,6,2,9,20),_45) ? skip 
EXIT permutation([3,6,2,9,20),[3,6,2,9,20) 
? creep 
CALL sorted([3,6,2,9,20) 
? creep 
CALL sorted(0,[3,6,2,9,20) 
? creep 
CALL 0<3 ? 

183 
Altering the satisfaction Q! the goal 
The following options enable you to alter how your program works. 
You can use these 
to repeat things that you want to look at In more detail. avoid choices which you know to 
be Irrelevant and force the program to consider choices that It might not otherwise find. 
These can greatly speed up debugging. because they mean that you can subject the difficult 
parts of the program to repeated scrutiny without having to run the whole thing again. 
[J 
"retry". 
If you specify the option "retry" at a port of some goal. Prolog will go back 
to where It was when It originally came to the CALL port. 
Everything will be exactly 
as It was when the goal was first encountered (except for any additions to the database 
that may have been made). 
Hence you can look at what happens In the satisfaction 
of the goal once again. 
A common technique is to combine the use of the "retry" 
and "skip" options. 
If you are not sure whether a bug occurs in the satisfaction of 
some goal. you can "skip" over its satisfaction to start with. 
This means that you 
will not have to wade through lots of output about a goal that Is satisfied completely 
correctly. 
If there is a bug. and the goal either falls or produces the wrong result. 
you can afterwards use the "retry" option to go back and look more closely. 
[J 
"or". 
If you are at the EXIT port of a goal. you can ask for alternatives (like when 
you type ';' to ask for alternative answers to a question). 
So if you know that the 
first answer found will not allow the rest of the program to succeed. you can 
Immediately ask for another solution to be found. 
This means that you will be able 
to get quicker to the part of the program that has the bug. 
The alternative would 
be to have to watch the eventual failure after the first alternative was found. 
[J 
"fall". 
This is mainly to be used at the CALL port of a goal. 
If you know that the 
goal is going to fall eventually. and the goal is of no Interest to you. you can cause 
it to fall immediately by using this option. 
Here Is an example of these options being used to alter the satisfaction of a question: 
?- member(X,[a,b,c]), member(X,[b,d,e]). 
CALL member(_44,[a,b,c]) ? creep 
EXIT member(a,[a,b,c]) ? or 
REDO member(a,[a,b,c]) ? creep 
CALL member(_44,[b,c]) ? fail 
FAIL member(_44, [b,c]) ? creep 
FAIL member(_44,[a,b,c]) ? retry 
CALL member(_44,[a,b,c]) ? creep 
EXIT member(a,[a,b,c]) ? creep 
CALL member(a,[d,c,e) 
? fail 
FAIL member(a,[d,c,e) 
? creep 
REDO member(a,[a,b,c) 
? creep 
CALL member(_44,[b,c) 
? creep 

184 
EXIT member(b, [b,c]) ? or 
REDO member(b, [b,c]) ? creep 
CALL member(_44,[c]) ? fail 
FAIL member(_44, [c]) ? retry 
CALL member(_44, [c]) ? creep 
EXIT member( c, [c]) ? creep 
EXIT member(c,[b,c]) ? creep 
EXIT member(c,[a,b,c]) ? creep 
CALL member(c, [d,c,e]) ? creep 
CALL member(c,[c,e]) ? creep 
EXIT member(c,[c,e]) ? creep 
EXIT member(c,[d,c,e]) ? or 
REDO member(c,[d,c,e])? creep 
REDO member(c, [c,e]) ? creep 
CALL member( c, [e]) ? creep 
CALL member( c, [ ]) ? creep 
FAIL member( c, [ ]) ? creep 
FAIL member(c,[e]) ? creep 
FAIL member(c,[c,e]) ? retry 
CALL member( c, [c, e]) ? creep 
EXIT member( c, [c, e]) ? creep 
EXIT member(c,[d,c,e]) ? creep 
Other options that may be open to you at a leashed port are: 
[] 
"break". 
This causes the current execution to be suspended and a new copy of 
the Prolog Interpreter to be made available to you. 
You can use this to ask questions 
about what clauses you have. to set spy points. or anything else that you want. 
When 
you exit from the Interpreter (by typing the end-of-file character). your previous program 
will be resumed. 
[] 
"abort". 
This causes all your current running programs to be abandoned. and you 
get "thrown back" to the Prolog Interpreter. ready to give the next question. 
[] 
"halt". 
This causes you to leave Prolog completely. 
You might want to use this 
as soon as you discover a bug. because you want to edit a file that contains the 
bug-ridden program. 
Summary 
In conclusion. then. there are three things to think about when you start to look at your 
program as It runs: 
1. 
Which goals do you want to look at? 
If you look at everything (use exhaustive tracing 
with trace >. you may become overwhelmed by the amount of Information that appears 

185 
on your terminal. 
On the other hand. If you just look at what happens to a few 
predicates (setting spy points with spy >. you may miss where the program Is going 
wrong. 
The best solution Is probably a compromise. with careful use of spy points 
to narrow down the search. and then exhaustive tracing at the end to Isolate the bug. 
2. 
How much do you want to control the program's progress from the terminal? 
If you 
have all ports unleashed. you will have no control at all over the program. which will 
rapidly run past the faulty bits before you can notice and look in more detail. 
On 
the other hand. if you have all ports leashed. you will get thoroughly fed up telling 
the program to keep going at each port. 
3. 
Do you want to provide special output facilities for your goals? 
This will be useful 
If some of the goals will contain huge structures of little Interest. which will only distract 
from the arguments that you are really interested in. 
In this case. you can provide 
a portray facility that suppresses this information. 
8.5 Fixing Bugs 
When you have watched your faulty program working and discovered something wrong 
with It. you will want to fix the bug and try the program again. 
Assuming that your program 
is of a reasonable size. you will already have it stored In disc flies. 
At this point. you will 
need to use an editor program to change what is In those flies. 
There are two possibilities 
now: 
o 
Your Prolog system may allow you to use an editor and then return to Prolog with 
exactly the same database as before. 
You may be able to do this directly. by using 
an appropriate built-in predicate. 
Alternatively. Prolog may allow you to save the 
current state of the database In a special file and then restore it again later. 
You 
then save your current state. exit from Prolog. change your program. run Prolog again 
and restore the previous database state. 
Having returned to where you were before. 
but with one or more program flies changed. all you need to do Is reconsult these 
flies to supersede the old definitions with new ones. 
o 
If your Prolog system does not allow you to return to a previous state after using 
an editor. after changing your program flies you will have to run Prolog and consult 
all your program flies from scratch. 
You can make this process easier by having 
a single file containing commands to Prolog to consult all the flies of your program. 
You can then read in the whole program by just asking Prolog to consult the first 
file. 
For Instance. if you asked Prolog to consult a file containing: 
?- [filel,file2,file3]. 

186 
?- [file4,file5,file6]. 
then as a result each of filel., ••• file6 will be read In. 
In some circumstances. the change to your program may seem so minimal that you 
can enter It from the terminal. by a consul.t(user) or reconsul.t(user). 
However. you should 
beware of doing this too often. 
If you are not careful. you will forget all the little changes 
you have made this way and run across the same bugs when you run your program In a 
later session. Also. since you will want eventually to Incorporate the changes Into your program 
flies. It Is rather a waste to have to type them In at the terminal as well. 
So do not be 
tempted Into entering clauses from the terminal by the prospect of getting the program to 
work quickly. 
When you are making changes to a program. exercise the same care that you take when 
you write the first version of a program. 
Make sure that what you add Is stili compatible 
with your conventions about which variables should be Instantiated when and what arguments 
are used for what purposes. 
Above all. take the opportunity to look over the program again 
-- there may after all be some other mistakes In It I 

Chapter 9. Using Grammar Rules 
9.1 
The Parsing Problem 
Sentences In a language like English are much more than just arbitrary sequences of 
words. 
We cannot string together any set of words and make a reasonable sentence. 
At 
the very least, the result must conform to what we consider to be grammatical. 
A grammar for a language Is a set of rules for specifying what sequences of words 
are acceptable as sentences of that language. It specifies how the words must group together 
Into phrases and what orderings of these phrases are allowed. 
Given a grammar for a 
language, we can look at any sequence of words and see whether It meets the criteria for 
being an acceptable sentence. 
If the sequence Is Indeed acceptable, the process of verifying 
this will have established what the natural groups of words are and how they are put together 
-- that Is, It will have established something of the underlying structure of the sentence. 
A particularly simple kind of grammar Is known as a 'context free' grammar. 
Rather 
than give a formal definition of what such a thing Is, we will Illustrate It by means of a simple 
example. 
The following might be the start of a grammar of English sentences: 
sentence --> noun-phrase, verb-phrase. 
noun-phrase --> determiner, noun. 
verb-phrase --> verb, noun-phrase. 
verb-phrase --> verb. 
determiner --> [the]. 
noun --> [app1e]. 
noun --> [man]. 
verb --> [eats]. 
verb --> [sings]. 
The grammar consists of a set of rules, here shown one to a line. 
Each rule specifies a 
form that a certain kind of phrase can take. 
The first rule says that a sentence consists 
of a phrase called a 'noun_phrase' followed by a phrase called a 'verb_phrase'. 
These two 

188 
phrases are what are commonly known as the 'subject' and 'predicate' of the sentence: 
sentence 
/\ 
/ 
\ 
/ 
\ 
/ 
\ 
noun....phrase 
I 
verb-phrase 
I 
I 
I 
the man 
eats the app1e 
To see what a rule In a context free grammar means, read '--)' as saying .... can take the 
form: .... and ': as saying •... followed by.... 
Thus the first rule can be read as: 
A 'sentence' can take the form; 
a 'noun-phrase' followed by a 'verb-phrase' 
This Is all very well. but what Is a 'noun_phrase' and what is a 'verb_phrase'? 
How are 
we to recognise such things and to know what constitute grammatical forms for them? 
The 
second, third and fourth rules of the grammar go on to answer these questions. For instance. 
A 'noun-phrase' can take the form; 
a 'determiner' followed by a 'noun' 
Informally. a noun phrase is a group of words that names a thing (or things). 
Such a phrase 
contains a word. the 'noun'. 
which gives the main class that the thing belongs to. 
Thus 
·the man" names a man. ·the program· names a program and so on. 
Also. according to 
this grammar. the noun is preceded by a phrase called a 'determiner': 
noun....phrase 
/\ 
/ 
\ 
/ 
\ 
/ 
\ 
determiner 
noun 
the 
man 
Similarly. the internal structure for a 'verb_phrase' is described by the rules. 
Notice that 
there are two rules for what a 'verb_phrase' is - this is because there are two possible forms. 
A 'verb_phrase' can contain a 'noun_phrase'. as in ·the man eats the apple·. or it need 
not. as in ·the man sings·. 
What are the other rules in the grammar for? 
These say how some phrases can be 
made up in terms of actual words. rather than in terms of smaller phrases. 
The things Inside 

square brackets name actual words of the language. so that the rule: 
determiner --, [the]. 
can be read as: 
a 'determiner' can take the form: 
the word "the" 
189 
Now that we have got through the whole of the grammar. we can begin to see what 
sequences of words are actually grammatical sentences according to it. 
This Is a very simple 
grammar and needs extending In many ways. especially as It will only accept sentences formed 
out of five different words. 
If we wish to investigate whether a given sequence of words Is 
actually a sentence according to these criteria, we need to apply the first rule to ask. 
does the sequence decompose into two phrases, 
such that the first is an 
acceptable noun""phrase and the second Is a valid verb""phrase? 
Then order to test whether the first phrase Is a noun phrase. we need to apply the second 
rule. asking. 
"does It decompose Into a determiner followed by a noun?" 
and so on. 
At the end. if we succeed. we will have looked at all the phrases and sub-phrases 
of the sentence. as specified by the grammar. and will have established a structure like. for 
Instance: 
sentence 
I \ 
I 
\ 
I 
nOUl'L.Phrase 
I \ 
I 
\ 
determiner noun 
verb-phrase 
I \ 
I 
\ 
verb 
noul'L.Phrase 
I \ 
I 
the 
man 
eats 
I 
\ 
I 
\ 
determiner 
noun 
the 
apple 
This diagram showing the phrase structure of the sentence Is called a parse tree for the 
sentence. 
We have seen how having a grammar for a language means that we can construct parse 
trees to show the structure of sentences of the language. 
The problem of constructing a 

190 
parse tree for a sentence. given a grammar. Is what we call the parsing problem. 
A computer 
program that constructs parse trees for sentences of a language we shall call a parser. 
This chapter will Illustrate how the parsing problem can be formulated In Prolog. and 
will Introduce the Prolog grammar rule formalism. which makes It rather more convenient to 
write parsers in Prolog. 
The Ideas are not confined to applications concerned with the syntax 
of natural languages. 
Indeed. the same techniques apply to any problem where we are 
presented with an ordered sequence of items that seem to fall Into natural groups and where 
the arrangement of these groups can be specified by a set of rules. 
However. for the sake 
of simplicity the rest of the chapter will concentrate on the problem of parsing English 
sentences and the generalisation to other fields will be left to you. 
9.2 
Repr_nting the Parsing Problem in Prolog 
The primary structure that we are talking about In discussing the parsing problem is 
the sequence of words whose structure Is to be determined. 
We expect to be able to isolate 
subsequences of this structure as being various phrases accepted by the grammar. and to 
show in the end that the whole sequence Is acceptable as a phrase of type ·sentence·. 
Since 
a standard way of representing a sequence Is as a list. we will represent the Input to the 
parser as a Prolog list. 
What about the representation of the words themselves? 
For the 
moment. there seems to be no point in giving the words Internal structure -- all we want 
to do is compare words with one another. 
Hence Is seems reasonable to represent them 
as Prolog atoms. 
Let us develop a program to see If a given sequence of words Is a sentence according 
to the grammar shown above. 
In order to do this. it will have to establish the underlying 
structure of the sentences It Is given. 
We will later on consider how to develop a program 
that remembers this structure and displays It to us. but for now It will be easier If we Ignore 
this extra complexity. 
Since the program involves testing to see If something Is a sentence. 
let us define a predicate sentence. 
The predicate will only need one argument -- we will 
give it a meaning as follows: 
sentence (X) means that; 
X is a sequence of words forming a grammatical sentence. 
So we anticipate asking questions like: 
?- sentence([the,man,eats,the,apple). 
This will succeed if "the man eats the apple" Is a sentence and fail otherwise. 
It Is rather unfortunate that we have to speCify sentences artificially by giving lists Of 
Prolog atoms. 
For a more serious application. we would probably want to be able to type 

191 
English sentences at the terminal In the normal way. 
In Chapter 5. we saw how a predicate 
read....-in can be defined so that we can convert a sentence typed In to a list of Prolog atoms. 
We could obviously build this Into our parser to allow a more natural means of communication 
with the program's user. 
However, we will Ignore these ·cosmetlc· matters for now and 
concentrate on the real problem of parsing. 
What Is involved in testing to see whether a sequence of words Is a sentence? 
Well. 
according to the first rule of the grammar. the task decomposes Into finding a noun_phrase 
at the beginning of the sequence and then finding a verb_phrase In what Is left. 
At the 
end of this. we should have used up exactly the words of the sequence. no more and no 
less. Let us introduce Let us introduce the predicates noun..,pbrase and verb-.pbrase to express 
the properties of being a noun_phrase or verb_phrase. so that: 
noun-phrase (X) means that; 
sequence· X is a noun-phrase. 
verb-phrase (X) means that; 
sequence X is a verb-phrase. 
The we can put together a definition of sentence In terms of these predicates. 
A sequence 
X Is a sentence if it decomposes into two subsequences Y and Z. Y is a noun_phrase and 
Z Is a verb_phrase. 
Since we are representing sequences as lists. we already have available 
the predicate append for dealing with one list decomposing into two others. 
So we can write: 
sentence(x) ,- append(Y,Z,X), noun-'phrase(Y), verb-'phrase(Z). 
Similarly. 
noun..,phrase(X) 
verb-'phrase( X) 
verb-'phrase( X) 
append(Y,Z,X), determiner(Y), noun(Z). 
append(Y,Z,X), verb(Y), noun..,phrase(Z). 
verb(X) . 
Notice that the two rules for verb...,Pbrase give rise to two clauses for our predicate. 
corresponding to the two ways of verifying that a sequence is a verb_phrase. 
Finally. we can easily deal with the rules that introduce words: 
determiner([the]). 
noun( [apple] ) . 
noun( [man] ) . 
verb( [eats] ) . 
verb( [sings]). 
So our program is complete. 
Indeed. this program will successfully tell us which sequences 
of words are sentences according to the grammar. 
However. before we consider the task 

192 
complete. we should have a look at what actually happens when we ask questions about some 
example sequences. 
Consider Just the sentence clause: 
sentence(x) ,- append(Y,Z,X), noun-phrase(Y), verb-phrase(Z). 
and a question: 
?- sentence([the,man,eats,the,apple]). 
Variable X In the rule will be Instantiated (to [the.man.eats.the.apple)). but Y and Z will be 
unlnstantlated. so the goal will generate a possible pair of values for Y and Z such that when 
Z Is appended to Y the result Is X. 
On backtracking. It will generate all the possible pairs. 
one at a time. 
The noun....phrase goal will only succeed If the value for Y actually Is an 
acceptable noun_phrase. 
Otherwise It will fall and append will have to propose another value. 
So the flow of control for the first part of the execution will be something like: 
1. 
The goal Is sentence( [the,man,eats,the,appl.e». 
2. 
Decompose the list Into two lists Y and Z. 
The fOllowing decompositions are possible: 
Y 
[]. 
Z = [the.man.eats.the.apple] 
Y 
[the]. 
Z = [man.eats.the.apple] 
Y 
[the. man]. 
Z = [eats.the.apple] 
Y 
[the.man.eats]. 
Z = [the.apple] 
Y 
[the.man.eats.the]. 
Z = [apple] 
Y 
[the.man.eats.the.apple]. 
Z = [] 
3. 
Choose a possibility for Y and Z from the above list of possibilities. and see If Y 
is a noun_phrase. 
That Is. try and satisfy noun-phrase(Y). 
4. 
If Y Is a noun_phrase. then succeed (and look for a verb_phrasel. 
Otherwise. go back 
to Step 3 and try another possibility. 
There seems to be a lot of unnecessary searching in this approach -- the goal append(Y,Z,X) 
ends up generating a large number of solutions. most of which are useless from the point 
of view of Identifying noun phrases. 
There must be a more directed way of getting to the 
solution. 
As our grammar stands. a noun_phrase must have precisely two words In It. and 
so we might think of using this fact to avoid searching among possible decompositions of 
the sequence. 
The trouble Is that this state of affairs, may not stay true if we change the 
grammar. 
Even a small change In the rules for determiner could affect the possible lengths 
of noun_phrases and hence affect the way in which the presence of noun_phrases would be 
tested. 
In designing the program It would be nice to retain some modularity. 
If we wish 
to change one clause. it should not necessarily have ramifications for the whole program. 

193 
So. the heuristic about the length of noun phrases Is too specific to be built Into the 
program. 
Nevertheless. we can see It as a specific case of a general principle. 
If we wish 
to select a subsequence that is a noun_phrase. then we can look at the properties of 
noun_phrases to restrict what kinds of sequences are actually proposed. 
If the noun_phrase 
definition Is liable to change. we cannot do this. unless we hand over the whole responsibility 
to the noun_phrase clauses. 
Since It Is the noun_phrase clauses that express what the 
properties of noun_phrases are. why not expect them to decide how much of the sequence 
Is to be looked at? 
Let us require the noun_phrase clauses to decide how much of the 
sequence Is to be consumed. and what Is to be left for the verb_phrase definition to work 
on. 
This discussion leads us to consider a new definition for the noun_phrase predicate. 
this time Involving two arguments: 
noun-phrase (X, Y) Is true If: 
there is a noun phrase at the beginning of sequence X and 
the part of the sequence left after the noun-phrase Is Y. 
So we might expect things like: 
1- noun-phrase([the,man,eats,the,apple],[eats,the,apple]). 
?_ noun-Phrase([the,apple,sings],[sings]). 
to be questions that should succeed. 
We must now revise the definition of noun...phrase to 
reflect this change of meaning. 
In doing this. we must resolve how the sequence taken up 
by a noun_phrase decomposes into a sequence taken up by a determiner followed by a 
sequence taken up by a noun. 
We can again delegate the problem of how much of the 
sequence is taken up to the clauses for the embedded phrases. giving the following: 
noun...phrase(X,Y) :- determiner(X,Z), noun(Z,Y). 
So a noun_Jihrase exists at the beginning of sequence X If we can find a determiner at the 
front of X. leaving behind Z. and we can then find a noun at the front of Z. 
The amount 
of the sequence left behind by the whole noun_phrase Is the same as that left behind after 
the noun. 
Expressed dlagramatlcally: 
[the,man,eats,the, apple] 
I 
x 
I 
I ___ 
Z 
I 
I __ 
Y 
I 
In order for this to work. we will have to adopt a similar convention with determiner and 
noun as we did with noun...phrase. 
This clause tells us how the problem of finding a sequence that Is a noun_phrase 
decomposes Into finding subsequences that Is a determiner followed by one which Is a noun. 

194 
Similarly. the problem of finding a sentence decomposes Into finding a noun_phrase followed 
by a verb_phrase. This Is all very abstract. None of this tells us how many words are actually 
consumed In the determiner. noun_phrase or sentence. 
The Information must be built up 
from our version of the rules that actually Introduce English words. 
We can again express 
these as Prolog clauses. but this time we need to add an extra argument. to give for example: 
determdner([theIX),X). 
This rule expresses the fact that one can find a determiner at the front of a sequence beginning 
with the word 'the'. 
Moreover. the determiner only takes up the first word of the sequence. 
and leaves the rest behind. 
In fact. we can add an extra argument to every predicate that recognises a kind of phrase. 
to express how that kind of phrase 'uses up' some of the words of a sequence and leaves 
the rest. 
In particular. for consistency. It would be sensible to do this with the sentence 
predicate. 
How does the initial goal that we give to the program look now? 
We must decide 
on what two arguments to give to sentence In the question. 
The arguments Indicate the 
sequence that It starts from and the sequence It Is to leave behind. 
The first of these Is 
obviously the same as the argument we gave to sentence before. 
Moreover. since we want 
to find a sentence that occupies the whole of the sequence. we want there to be nothing 
left after the sentence has been found. 
We want only the empty sequence to be left. 
Hence 
we must give the program a goal like: 
?- sentence([the,man,eats,the,apple),[). 
Let us now see how the complete grammar looks after we have rewritten It with the 
above discussion In mind: 
sentence(So,S) :- noun-phrase(SO,Sl), verb-phrase(Sl,S). 
noun-phrase(So,s) :- determdner(SO,Sl), noun(Sl,S). 
verb-phrase(So,S) :- verb(SO,S). 
verb-phrase(SO,S) :- verb(SO,Sl), noun-phrase(Sl,S). 
determiner([theIS),S). 
noun([manIS],S). 
noun([appleIS),S). 
verb([eatsIS],S). 
verb([singsIS],S). 
So we now have a more efficient version of our program to recognise sentences accepted 
by the grammar. It Is a pity. though. that the code looks more messy than that of the previous 
version 
All the extra arguments seem to clutter It up unnecessarily. 
We will now see how 

195 
to cope with this problem. 
9.3 
The Grammar Rule Notation 
The Prolog grammar rule notation was developed as an aid to people writing parsers 
using the techniques we have Just described. 
The notation makes the code easier to read. 
because It suppresses Information that is not Interesting. Because the notation Is more conCise 
than ordinary Prolog. there is also less chance of making silly typing mistakes If you use 
grammar rules for writing your parsers. 
Although the grammar rule notation is self-contained. It Is Important to realise that It 
Is only a shorthand for ordinary Prolog code. 
You can use grammar rules either because 
your Prolog system already knows about them. or because there Is a library package that 
enables you to use a special form of consu1t. In either case. the way that the system handles 
grammar rules is to specifically recognise them when they are input and then translate them 
into ordinary Prolog. 
So your grammar rules end up as ordinary Prolog clauses. although 
naturally looking a bit different from what you typed In. 
The actual notation Is built around the notation for context-free grammars that we 
introduced at the beginning of this chapter. 
In fact. if the grammar as presented there 
(reproduced below) were given to Prolog. It would be translated Into clauses exactly the same 
as what we ended up with as the final version of the parsing program: 
sentence --> nou"-phrase, verb-phrase. 
nou"-phrase --> determiner, noun. 
verb-phrase --> verb. 
verb-phrase --> verb, nou"-phrase. 
determiner --> [the]. 
noun -> [man]. 
noun -> [app1e]. 
verb -> [eats]. 
verb --> [sings]. 
The actual grammar rules are Prolog structures. with main functor '--)'. which is declared 
as an infix operator. 
All the Prolog system has to do is check whether a term read in (In 
a consu1t or similar) has this functor. and if so translate it Into a proper clause. 
What is involved in this translation? 
First of all. every atom that names a kind of phrase 
must be translated into a predicate with two arguments -- for the sequence provided and 
the sequence left behind. as in our program. 
Second. whenever a grammar rule mentions 
phrases coming one after another. it must be arranged that that the arguments reflect the 

196 
fact that what is left behind by one phrase forms the Input to the next. 
Finally. whenever 
a grammar rule mentions that a phrase can be realised as a sequence of subphrases. the 
arguments must express 
the fact that the amount of words consumed by the whole phrase 
Is the same as the total consumed by the subphrases mentioned on the right of the --). 
These criteria ensure. for instance. that: 
sentence --) noun-phrase, verb-phrase. 
translates into: 
sentence(so,S) :- noun-phrase(SO,Sl), verb-phrase(Sl,S). 
or. In English. 
There is a sentence between SO and 5 If there Is a noun phrase between SO 
and 51. and if there Is a verb phrase between 51 and S. 
Finally. the system has to know how to translate those rules that Introduce actual words. 
This involves inserting the words Into the lists forming the arguments of the predicates. so 
that. for Instance. 
determiner --) [the]. 
translates into: 
determiner([theIS],S). 
Once we have expressed our parsing program as grammar rules. how do we specify 
the goals that we want It to work at? 
Since we now know how grammar rules translate Into 
ordinary Prolog. we can express our goals In Prolog. adding the extra arguments ourselves. 
The first argument to add is the list of words that is to be looked at. and the second is 
the list that Is going to be left. which Is normally the empty list. []. 
So. we can specify 
goals like: 
?- sentence([the,man,eats,the,apple],[]). 
?- noun-phrase([the,man,sings],X). 
As an alternative. some Prolog Implementations provide an evaluable predicate phrase which 
simply adds the extra arguments for you. 
The predicate phrase Is defined by: 
phrase (P. U Is true If; 
list L can be parsed as a phrase of type P. 

197 
So we could replace the first of the above goals by the alternative: 
?- phrase(sentence,[the,man,eats,the,apple]). 
Note that the definition of phrase Involves the whole list being parsed. with the empty list 
being left. 
Therefore we could not replace the second goal above by a use of phrase. 
If your Prolog implementation does not provide phrase already defined. you can easily 
provide a clause for it. as follows: 
phrase(P,L) ,- Goal = .• [P,L,[]], call(Goal). 
Note. however. that this definition will not be adequate when we consider more general grammar 
rules In the next section. 
Exercise g 
You 
may wish to define in 
Prolog 
a procedure translate, such 
that 
translate(X, Y) Is true if X is a grammar rule (of the kind we have encountered In this section) 
and Y is the term representing the corresponding Prolog clause. This Is quite a hard exercise. 
Procedures that are much like translate are provided by the Prolog system. either built-In 
or as library programs. but it may help you to understand what translation process is involved 
If you actually write translate. 
9.4 
Adding Extra Arguments 
The grammar rules we have come across so far are only of a fairly restricted kind. 
In this section we will consider one useful extension. which allows phrase types to have extra 
arguments. 
This "extension" is still part of the standard grammar rule facility that Prolog 
provides. 
We have seen how an occurrence of a phrase type in a grammar rule translates to 
the use of a Prolog predicate with two extra arguments. 
So the rules we have seen so far 
give rise to a lot of two-argument predicates. 
Now Prolog predicates can have any number 
of arguments. and we may sometimes want to have extra arguments used in our parsers. 
apart from the ones dealing with the consumption of the input sequence. 
The grammar rule 
notation supports this. 
Let us look at an example where extra arguments may be useful. 
Consider the problem 
of "number agreement" between the subject and verb of a sentence. 
Sequences like 
*The boys eats the apple. 
*The boy eat the apple. 
are not grammatical English sentences. even though they might be allowed by a simple 

198 
extension of our grammar. 
The reason they are not grammatical Is that If the subject of 
a sentence is singular then the sentence must also use the singular form of the verb. Similarly. 
if the subject Is plural. the plural form of the verb must be used. 
We could express this 
In grammar rules by saying that there are two kinds of sentences. singular_sentences and 
pluraLsentences. 
A singulacsentence must start with a slngular_noun_phrase. which must 
have a singular_noun. and so on. 
We would end up with a set of rules like the following: 
sentence --> singular_sentence. 
sentence --> pluraL-sentence. 
nou"-phrase --> singular_nou"-phrase. 
nou"-phrase --> pluraL-nou"-phrase. 
singular_sentence --> singular_nou"-phrase, singular_verb-phrase. 
singular_nou"-phrase --> singular_determiner, singular_noun. 
singular_verb-phrase --> singular_verb, nou"-phrase. 
singular_verb-phrase --> singular_verb. 
singular_determiner --> [the]. 
singular_noun --> [boy]. 
singular_verb --> [eats]. 
and also a whole lot of rules for plural phrases. 
This is not very elegant. and obscures 
the fact that singular and plural sentences have a lot of structure In common. 
A better way 
Is to associate an extra argument with phrase types. according to whether they are singular 
or plural. 
Thus sentence( singul.ar) names a phrase which is a singular sentence and. In 
general. sentence(X) a sentence of plurality X. 
The rules about number agreement then 
amount to consistency conditions on the values of these arguments. The plurality of the subject 
noun_phrase must be the same as that of the verb_phrase. and so on. 
Rewriting the grammar 
In this way. we get: 
sentence --> sentence(X). 
sentence(x) --> nou"-phrase(X), verb-phrase(X). 
nou"-phrase(X) --> determiner(X), noun(X). 
verb-phrase(X) --> verb(X). 
verb-phrase(X) --> verb(X), nou"-phrase(Y). 
noun(singular) --> [boy]. 
noun(plural) --> [boys]. 
determiner(_) --> [the]. 
verb(singular) --> [eats]. 
verb(plural) --> [eat]. 
Note the way In which we can specify the plurality of "the". 
This word could Introduce a 

199 
singular or a plural phrase. and so Its plurality Is compatible with anything. 
Also note that 
in the second rule for verb_phrase the naming of the variables expresses the fact that the 
plurality of a verb_phrase (the thing that must agree with the subject) is taken from that of 
the verb. and not that of the object. if there is one. 
We can introduce arguments to express other important information as well as number 
agreement. For Instance. we can use them to keep a record of constituents that have appeared 
outside their "normal" position. and hence deal with the phenomena that linguists put under 
the heading "movement". 
Or we can use them to record Items of semantic significance --
to say how the meaning of a phrase is composed of the meanings of the subphrases. 
We 
will not investigate these any more here. although Section 9.6 gives a simple example of 
incorporating semantics into the parser. 
However. one thing should be noted here. 
linguists 
may be interested to know that once we Introduce extra arguments into grammar rules. we 
cannot guarantee that the language defined by the grammar is stili context-free. although It 
often will be. 
An important use of extra arguments is to return a parse tree as a result of the analysis. 
In Chapter 3 we saw how trees can be represented as Prolog structures. and we will now 
make use of that In extending the parser to make a parse tree. 
Parse trees are helpful 
because they provide a structural representation of a sentence. 
It Is more convenient to write 
programs that process this structural representation in a way analogous to processing the 
arithmetic formulae and lists in Chapter 7. 
The new program. given a grammatical sentence 
like: 
The man eats the apple. 
will generate a structure like: 
sentence( 
noulLPhrase( 
determiner( the) , 
noun(man) 
) , 
verb-phrase( 
verb( eats), 
noun_phrase ( 
) 
determiner( the), 
noun( apple) 
as a result. 
In order to make It do this. we only need to add an extra argument to each 
predicate. saying how the tree for a whole phrase Is constructed from the trees of the various 
sub-phrases. 
Thus we can change the first rule to: 
sentence(X,sentence(NP,VP» --, noulLPhrase(X,NP), verb-phrase(X,VP). 

200 
This says that If we can· find a sequence constituting a noun_phrase. with parse tree NP. 
followed by a sequence constituting a verb_phrase. with parse tree VP. then we have found 
a sequence constituting a complete sentence. and the parse tree for that sentence Is 
seni:ence(I!IP,VP). 
Or. In more procedural terms. to parse a sentence one must find a 
noun_phrase followed by a verb_phrase. and then combine the parse trees of these two 
constituents. using the functor sentence to make the tree for the sentence. 
Note that the 
·x· arguments are Just the number agreement arguments used earlier. and that the decision 
to put the tree generating arguments after rather then before them was arbitrary. 
If you have 
any difficulty understanding this extension. It helps to see that this Is all Just a shorthand 
for an ordinary Prolog clause: 
sentence(X,sentence(IIP,VP),SO,S) ,-
noun-phrase(X,IIP,SO,S~), 
verb-phrase(X,vp,s~,S). 
where SO. S1 and S stand for parts of the Input sequence. 
We can Introduce tree-bUilding 
arguments throughout the grammar In a routine way. 
Here Is an excerpt from what Is produced 
If we do this (number agreement arguments being left out for clarity>: 
sentence( sentence( lIP , VP » -> noun-phrase( lIP ), verb-phrase( VP ) • 
verb-phrase( verb-phrase( v» -> verb( V) • 
noun(noun(man» -> [man]. 
verb(verb(eats» -> [eats]. 
The translation mechanism needed to deal with grammar rules with extra arguments Is 
a simple extension of the one described before. 
Previously a new predicate was created for 
each phrase type. with two arguments to express how the Input sequence was consumed. 
Now It Is necessary to create a predicate with two more arguments than are mentioned In 
the grammar rules. By convention. these two extra arguments are added as the last arguments 
of the predicate (although this may vary between Prolog systems>. 
Thus the grammar rule: 
sentence(X) -> noun-phrase(X), verb-phrase(X). 
translates Into: 
sentence(X,So,S) -> noun-phrase(X,so,S~), verb-phrase(x.s~,S). 
When we want to Invoke goals Involving grammar rules from the top levei of the Interpreter 
or from ordinary Prolog rules. we must explicitly add the extra arguments. 
Thus appropriate 
goals Involving this definition of sentence would be: 
1- sentence(X,[a,clergyman,eats,a,cake],[]). 
1- sentence(X,[every,bird,sings,and,pigs,can,fly],L). 

201 
Exercise 9.2: 
Write a new version of phrase that allows grammar rules with extra arguments. 
so that one can provide goals like: 
1- phrase(sentence(X),[the,man,sings]). 
9.5 
Adding Extra Teata 
So far In our parser. everything mentioned In the grammar rules has had to do with 
how the Input sequence Is consumed. 
Every Item In the rules has had something to do with 
those two extra argument positions that are added by the grammar rule translator. 
So every 
goal In the resulting Prolog clause has been Involved with consuming some" amount of the 
Input. 
Sometimes we may want to specify Prolog goals that are not of this type. and the 
grammar rule formalism allows us to do this. 
The convention Is that any goals enclosed 
Inside curly brackets I .... } are to be left unchanged by the translator. 
Let us look at some examples of where It would be beneficial to use this facility --
In Improving the "dictionary" of the parser. that Is. the parser's knowledge about words of 
the language. 
Firstly. consider the overhead Involved In Introducing a new word Into the program with 
both sets of extra arguments. 
If we wished to add the new noun 'banana'. for Instance. we 
would have to add at least the rule: 
noun(singular,noun(banana» 
--> [banana]. 
which amounts to: 
noun(singular,noun(banana),[bananaIS],S). 
In ordinary Prolog. 
This Is a lot of Information to specify for each noun. especially when 
we know that every noun will only occupy one word and will give rise to a small tree with 
the functor noun. 
A much more economical way would be to express the common Information 
about all nouns In one place and the Information about particular words somewhere else. 
We can do this by mixing grammar rules with ordinary Prolog. 
We express the general 
Information about how nouns fit Into larger phrases by a grammar rule. and then the Information 
about what words are nouns In ordinary clauses. 
The solution that results looks like: 
noun(S,noun(N» 
--> [N], (is_noun(N,S)} • 
where the normal predicate iSJloun expresses which words are nouns and whether they are 

202 
singular or plural: 
is_noun(banana,singular). 
is_noun(bananas,plural). 
is_noun(man,singular). 
Let us look carefully at what this grammar rule means. 
It says that a phrase of type noun 
can take the form of any single word N (a variable Is specified in the list> subject to a 
restriction. 
The restriction Is that N must be In our is_noun collection. with some plurality 
S. 
In this case. the plurality of the phrase is also S. and the parse tree produced consists 
just of the word N underneath the node noun. 
Why does the goal is_noun(II',S) have to 
be put inside curly brackets? 
Because It expresses a relationship that has nothing to do 
with the input sequence. 
If we were to leave out the curly brackets. it would be translated 
to something like is_noun(II',S,Sl,S2), which would never match our clauses for Is_noun. 
Putting It Inside the curly brackets stops the translation mechanism from changing It. so that 
our rule will be correctly translated to: 
noun(S,noun(N), [Nlseq],seq) ,- is_noun(N,S). 
In spite of this change. our treatment of Individual words Is stili not very elegant. 
The 
trouble with this technique Is that we will have to have to write two is_noun clauses for every 
new noun that is Introduced -- one for the singular form. and one for the plural form. 
This 
Is unnecessary. because for most nouns the singular and plural forms are related by a simple 
rule: 
If X Is the singular form of a noun, then the word formed by adding an 's' on 
the end of X ;s the plural form of that noun. 
We can use this rule about the form of nouns to revise our definition of noun. 
The revisions 
will give a new set of conditions that the word N must satisfy In order to be a noun. 
Because 
these conditions are about the Internal structure of the word. and do not have anything to 
do with the consumption of the input sequence. they will appear within curly brackets. 
We 
are representing English words as Prolog atoms. and so considerations about how words 
decompose Into letters translate Into considerations about the characters that go to make up 
the appropriate atoms. 
So we will need to use the predicate name In our definition. 
The 
amended rule looks as follows: 
noun(plural,noun(RootN» 
--> [11'], 
((name(N,Plname), append(Singname,"s",Plname), 
name(RootN,Singname), is_noun(RootN,singular»} 
Of course. this expresses a general rule about plurals that Is not always true (for Instance. 

203 
the plural of "fly" Is not "flys"). 
We will stili have to express the exceptions In an exhaustive 
way. 
Notice that the double-quote notation Is used to represent the character's' as a member 
of a list. 
We need now only specify isJlC)UJl clauses for the singular forms of regular nouns. 
Note that under the above definition the Item Inserted Into the. parse tree will be the "root" 
noun, rather than the Inflected form. 
This may be useful for subsequent processing of the 
tree. 
Note also the syntax of curly brackets. 
This may differ slightly between different Prolog 
Implementations. but the safest thing is to surround multiple goals inside curly brackets with 
an extra pair of round brackets and to leave a space between any curly bracket and the 
final '.'. 
As well as knowing about curly brackets. most Prolog grammar rule translators will know 
about certain other goals that are not to be translated normally. 
Thus it is not normally 
necessary to enclose 'I's or disjunctions (';') of goals involving the Input sequence inside 
curly brackets. 
9.6 
Summary 
We will now summarise the syntax of grammar rules as described so far. 
We will then 
indicate some of the possible extensions to the basic system and some of the interesting 
ways that grammar rules can be used. 
The best way to describe the syntax of grammar 
rules Is by grammar rules themselves. 
So here is an informal definition. 
Note that it is 
not completely rigorous. because it neglects the influence of operator precedences on the 
syntax. 
grammar_rule -) grammar_head, [' -) , ], grammar-.body. 
grammar_head -) non-terminal. 
grammar_head -) non-terminal, [','], terminal. 
grammarJx>dy -) grammar....body, [','], grammar....body. 
grammar...,body -) grammar-.body, [';'], grammar-.body. 
grammar...,body -) gr8DDl\ar-.body_item. 
grammar-.body_item -) [' J']. 
grammar_body_item -) ['{'], prolo~goals, ['J']. 
grammar...,body_item -) non-terminal. 
grammar...,body_item -) terminal. 
This leaves several items undefined. 
Here are definitions of them in English. 
A non_terminal Indicates a kind of phrase that may occupy part of the Input 
sequence. 
It takes the form of a Prolog structure, where the functor names the 
category of the phrase and the arguments give extra Information, like the number 
class, the meaning. etc. 
A terminal 
sequence. 
determinate 
against the 
Indicates a number of words that may occupy part of the Input 
It takes the form of a Prolog list (which may be a or a list of any 
length). 
The Items of the list are Prolog Items that are to match 
words as they appear In the order given. 

204 
Prolog..,.goals are any Prolog goals. 
They can be used to express extra tests and 
actions that constrain the possible analysIs paths taken and Indicate how complex 
results are built up from simpler ones. 
When translated in Prolog. prolog..,.goals are left unchanged and nonJermlnals have two extra 
arguments inserted after the ones that appear explicitly. corresponding to the sequence provided 
to and the sequence left behind by the phrase. 
Terminals appear within the extra arguments 
of the non_termInals. 
When a predicate defined by grammar rules is invoked at the top level 
of the interpreter or by an ordinary Prolog rule. the two extra arguments must be provided 
explicitly. 
The second rule for gr~ad in the above mentions a kind of grammar rule that 
we have not met before. 
Up to now. our terminals and non-terminals have only been defined 
In terms of how they consume the input sequence. 
Sometimes we might like to define things 
that insert items into the input sequence (for other rules to find). 
For instance. we might 
like to analyse an imperative sentence like: 
Eat your supper. 
as if there were an extra word ·you· inserted: 
You eat your supper. 
It would then have a nice noun_phrase/verb_phrase structure. which conforms to our existing 
ideas about the structure of sentences. 
We can do this by having a grammar that looks 
in part like: 
sentence --) imperative, noun-phrase, verb-phrase. 
imperative, [you] --) []. 
imperative --) []. 
There is only one rule here that deserves mention. 
The first rule for imperative actually 
translates to: 
imperative(L,[youIL]). 
So this involves a sequence being returned that is longer than the one originally provided. 
In general. the left-hand side of a grammar rule can consist of a non-terminal separated 
from a list of words by a comma. 
The meaning of this is that in the parsing the words 
are inserted into the input sequence after the goals on the right-hand side have had their 
chance to consume words from it. 
Exercise 9.3: 
The definition given for grammar rules. even if made complete. would not 

205 
constitute a useful parser. given a sequence of tokens as Its Input. 
Why? 
Finally. we present an example (taken from Pereira and Warren's paper In the journal 
Artificial Intelligence Volume 13) of grammar rules used to obtain the meaning of sentences 
directly. without an Intermediate parse tree. 
The following rules translate from (a restricted 
number of) English sentences Into a representation of their meaning In Predicate Calculus. 
For a description of Predicate Calculus and our notation for It. the reader Is referred to Chapter 
10. 
As an example of the program at work. the meaning obtained for "every man loves a 
woman" Is the structure: 
all(X,(man(X) -> exists(Y,(woman(Y)&loves(X,Y»») 
Here are the grammar rules: 
1- op(100,xfy,&). 
1- op(150,xfy,-». 
sentence(P) --> noun-phrase(X,Pl,P), verb-phrase(X,Pl). 
noun-phrase(X,Pl,P) --> 
determiner(X,P2,Pl,P), noun(X,P3), 
rel-clause(X,P3,P2). 
noun-phrase(X,P,P) --> proper_noun(X). 
verb-phrase(X,P) --> trans_verb(X,Y,Pl), noun-phrase(Y,Pl,P). 
verb-phrase(X,P) --> intrans_verb(X,P). 
rel-clause(X,Pl,(Pl&P2» --> [that], verb-phrase(X,P2). 
rel-clause(_,P,P) --> []. 
determiner(X,Pl,P2, all(X,(Pl->P2») --> [every]. 
determiner(X,Pl,P2, exists(X,(Pl&P2») --> [a]. 
noun(X,man(X» --) [man]. 
noun(x,woman(X» 
--> [woman]. 
proper_noun(john) --) [john]. 
trans_verb(X,Y,loves(X,Y» --> [loves]. 
intrans_verb(X,lives(X» --> [lives]. 
In this program. arguments are used to build up structures representing the meanings of 
phrases. 
For each phrase. it is the last argument that actually specifies the meaning of that 
phrase. 
However. the meaning of a a phrase may depend on several other factors. given 
in the other arguments. 
For instance. the verb 'lives' gives rise to a proposition of the form 
·lIves(X)·. where 'X' is something standing for the person who lives. 
The meaning of 'IIves' 
cannot specify in advance what 'X' will be -- the meaning has to be applied to some specific 
object in order to be useful. 
The context in which the verb is used will determine what this 
object is. 
So the definition just says that. for any X. when the verb is applied to X. the 
meaning is ·lives(X)'. A word like 'every' is much more complicated. In this case. the meaning 

206 
has to be applied to a variable and two propositions containing that variable. 
The result Is 
something that says that, If substituting an object for the variable In the first proposition yields 
something true then substituting that same object for the variable in the second proposition 
will also yield something true. 
Exercise 9.4: 
Read and understand this program. 
Try running the program. giving It goals 
like 
?- sentence(X,[every,man,loves,a,woman],[]). 
What meaning does the program generate for the sentence "every man that lives loves a 
woman". "every man that loves a woman lives"? 
The sentence "Every man loves a woman" 
Is actually ambiguous -- there could either be a single woman that every man loves. or there 
could be a (possibly) different woman that each man loves. 
Does the program produce the 
two possible meanings as alternative solutions? 
If not, why not? 
What simple assumption 
has been made about how the meanings of sentences are built up? 

Chapter 10. The Relation of Prolog to Logic 
The programming language Prolog was invented by Alain Colmerauer around about 1970. 
It was a first attempt at the design of a language that would enable a programmer to specify 
his tasks In logic. rather than In terms of conventional programming constructs about what 
the machine should do when. 
This motivation explains the name of the programming language. 
for "Prolog" stands for Programming In logic. 
In this book. we have emphasised mainly how one can use Prolog as a tool for doing 
practical tasks. and we have not talked about the ways in which Prolog Is a step towards 
the ultimate goal of a "logic programming" system. 
In this chapter. we intend to redress 
this imbalance somewhat by considering briefly how Prolog Is related to logic and to what 
extent Prolog programming Is really like "programming In logic". 
10. 1 Brief Introduction to Predicate Calculus 
If we wish to discuss how Prolog Is related to logic. we must first of all establish what 
we mean by "logic". 
Logic was originally devised as a way of representing the form of 
arguments. so that It would be possible to check in a formal way whether or not they were 
valid. 
Thus we can use logic to express propositions. the relations between propositions and 
how one can validly Infer some propositions from others. 
The particular form of logic that 
we will be talking about here Is called the Predicate Calculus. 
We will only be able to say 
a few words about it here. 
For a more detailed treatment. you can consult Introduction to 
Mathematical Logic by E. 
Mendelson. published in 1964 by Van Nostrand Reinhold. or any 
of the other books that deal with Symbolic Logic. 
Another text that may be of Interest Is 
Symbolic Logic and Mechanical Theorem Proving. by Chin Liang Chang and Richard Char-Tung 
Lee. published in 1973 by Academic Press. 
If we wish to express propositions about the world. we must be able to describe the 
objects that are involved In them. 
In Predicate Calculus. we represent objects by terms. 
A term Is of one of the following forms: 

208 
C 
A constant symbol. 
This Is a symbol that stands for a single Individual or concept. 
We can think of this as a Prolog atom. and we will use the Prolog syntax. 
So appl.el., 
agatha, and peace are constant symbols. 
C 
A variable symbol. 
This Is a symbol that we may want to stand for different Individuals 
at different times. 
Variables are really only Introduced In conjunction with quantifiers. 
which are discussed below. 
We can think of them as Prolog variables and will use 
the Prolog syntax. 
Thus x, 1Ian, and Greek are variable symbols. 
C 
A compound term. 
A compou",;1 term consists of a function symbol, together with 
an ordered set of terms as Its arguments. 
The idea Is that the compound term 
represents some Individual that depends on the individuals represented by the 
arguments. 
The function symbol represents how the first depends on the second. 
For Instance. we could have a function symbol standing for the notion of "distance" 
and two arguments. 
In this case. the compound term stands for the distance between 
the objects represented by the arguments. 
We can think of a compound term as 
a Prolog structure with the function symbol as the functor. 
We will write Predicate 
Calculus compound terms using the Prolog syntax. so that. for Instance. Wife(henzy) 
might mean Henry's wife. distance(poiDt1,X), might mean the distance between some 
particular point and some other place to be specified. and c1asses(~,clayaft:er(.» 
might mean the classes that Mary teaches on the day after some day W to be specified. 
Thus In Predicate Calculus the ways of representing objects are just like the ways available 
In Prolog. 
In order to express propositions about objects we must be' able to express relationships 
between objects. 
We do this with predicate symbols. 
An atomic proposition consists of a 
predicate symbol. together with an ordered set of terms as Its arguments. 
This is just like 
the kind of thing that can appear as a Prolog goal. 
So. for example. the fOllowing are atomic 
propositions: htman(~), owns(X,doIlkey(X», l.iJtes(IIan,wine). 
In Prolog. a structure can 
appear either as a goal or as an argument to another structure or both. 
This Is not the 
case In Predicate Calculus. where a rigid separation Is made between function symbols. which 
are functors that are used to construct arguments. and predicate symbols, which are functors 
that are used to construct propositions. 
Out of atomic propositions. we can make compound propositions In various ways. 
It 
Is here that we begin to find things that do not have direct analogues in Prolog. 
There are 
several ways In which we can make more complicated propositions out of simpler ones. 
First. 
we can use the logical connectlve8. 
These are ways of expreSSing the familiar notions "not". 
"and". "or". "Implies" and "Is equivalent to". 
The following summarises the connectives and 
their meanings. 
In this summary. a and /J are meant to represent any propositions. 
We 
give both the traditional Predicate Calculus syntax and the syntax that will be used here. 

connective 
pc Syntax 
------
----
Negation 
a 
conjunction 
(lAP 
Disjunction 
aVp 
Implication 
a::Jp 
Equivalence 
a=p 
Our Syntax 
-a 
a & 13 
a # 13 
a -) 13 
a <-) 13 
Meaning 
"not a" 
"a and plI 
"a or p" 
"a implies 13" 
"a is equivalent to P" 
209 
Thus. for example. mane fred) # woman( fred) could be used to represent the proposition that 
Fred Is a man or Fred is a woman. mane john) -) humane john) might represent the proposition 
that John's being a man implies his being human (If John Is a man then he Is human). 
The notions of Implication and equivalence are sometimes a little hard to grasp at first. 
We 
say that a implies P If. whenever a Is true so Is p. 
We say that a Is equivalent to P If 
a Is true In exactly those Circumstances when 13 Is true. 
In fact. these notions can be defined 
In terms of "and". 'or' and 'not". for: 
a -) P 
a <-) 13 
means the same as 
(-a) # P 
means the same as 
(a & P) # (-a & -P) 
(and also (a -) (3) & (P -) a» 
So far. we have not made It clear what it means when variables appear Inside a 
proposition. 
In fact. the meaning Is only defined when such variables are Introduced by 
quantifiers. 
Quantifiers provide a means of talking about sets of Individuals and what Is true 
of them. 
Predicate Calculus provides two quantifiers. 
If a represents any variable and IT 
any proposition. we can summarise them as follows: 
pc syntax 
Our Syntax 
Meaning 
Va.IT 
Sa.IT 
aH(a,IT) 
exists( a, IT) 
"IT is true whatever a stands for" 
"there is something that a can 
stand for, such that IT is true" 
The first of these is called the universal quantifier because It talks about everything In the 
Universe (for all a • .. .l. 
The second is called the existential quantifier because It talks about 
the existence of some objectCs) (there exists a such that .. .l. 
As examples of uses of the 
quantifiers. for Instance. all(X, man{x) -) human(X) ) means that. whatever X we choose. 
if X is a man then X Is a human. 
We can read It as "for all X. if X Is a man then X is 
a human" or. In English. simply "every man Is human'. 
Similarly. exists(Z, father(john,Z) 
& fema.l.e{ Z) ) means that there Is something that Z can stand for such that John Is the 
father of Z and Z Is female. 
We can read It as 'there exists a Z such that John Is the 
father of Z and Z Is female' or. In English. simply "John has a daughter". 
Here are some more complicated Predicate Calculus formulae for your amusement: 
all(X, animal(X) -) exists(Y,motherof(X,Y» 
) 

210 
"every animal has a mother" 
all(X, pcformula(X) <-, (atomicformula(X) # compoundformula(X» 
"something is a Predicate Calculus formula if, and only if, 
it is an atomic formula or a compound formula" 
10.2 CI.uaal Form 
As we saw In the last section. Predicate Calculus formulae expressed In terms of -, 
<Implication) and <-, (equivalence) can be rewritten 'In terms of & (conjunction) •• (disjunction) 
and -
(negation). 
In fact. there are many more Identities of this form. and we would not 
sacrifice any expressive power If we were to completely avoid using ., -', <-, and 
exists(X,P), for Instance. 
As a result of the redundancy. there are many ways of writing 
down the same proposition. If we wish to carry out formal manipulations on Predicate Calculus 
formulae. this turns out to be very inconvenient. 
It would be much nicer If everything we 
wanted to say could only be expressed In one way. 
So we will now consider how a Predicate 
Calculus proposition can be translated into a special form. clausal form, where there are less 
ways of saying the same thing. 
In fact. It will turn out that a Predicate Calculus proposition 
in clausal form is very much like a set of Prolog clauses. 
So an investigation of clausal 
form is essential for an understanding of the relation between Prolog and logic. 
In Appendix 
B. we present briefly a Prolog program which will automatically translate a Predicate Calculus 
formula into clausal form. 
The conversion of a Predicate Calculus formula into normal form has six main stages. 
We have based this particular formulation heavily on a description given by Martin Davis in 
the Proceedings of a Symposium In Applied Mathematics <American Mathematical Society. 
1963). 
Stage 1 = Removing Implications 
We start by replacing occurrences of -, and <-, in accordance with the definitions given 
in Section 10.1. 
As a result of this definition. we would expect: 
all(X,man(X)-'human(X» 
to be transformed to: 
all(X, -man(X) # human(X» 
Stage g = Moving negation inwards 

211 
This stage Is Involved with cases where -
Is applied to a formula that Is not atomic. 
If such a case Is detected. an appropriate rewrite Is made. 
Thus. for Instance. 
-(human(caesar) & living(caesar» 
Is transformed to 
-human(caesar) # -living(caesar) 
and 
-all(Y,person(Y» 
Is transformed to: 
exists(Y,-person(Y» 
The validity of this stage results from the following Identities: 
-(a & P) 
means the same as 
-(a # P) 
means the same as 
-exists(a,rr) means the same as 
-all(a,rr) 
means the same as 
(-a) # (-P) 
(-a) & (-P) 
all( a, -rr) 
exists( a, -rr) 
After Stage 2. negation will only appear In our formulae applied directly to atomic formulae. 
We call an atomic formula. or an atomic formula preceded by a -
a literal. 
The next few 
stages will treat literals as single Items. and the significance of which literals are negated 
will only be Important at the end. 
Stage ~ = Skolemlslng 
The next stage Involves removing the existential quantifiers. 
This Is done by Introducing 
new constant symbols. Sko/em constants. In the place of the variables Introduced by the 
existential quantifiers. 
Instead of saying that there exists an object with a certain set of 
properties. one can create a name for one such object and simply say that It has the properties. 
This Is the motivation behind introducing Skolem constants. 
Skolemlsing does more damage 
to the logical properties of a formula than the other transformations we discuss. 
Nevertheless. 
It has the following Important property. 
There is an Interpretation for the symbols of a formula 
that makes the formula true If and only If there Is an Interpretation for the Skolemlsed version 
of the formula. 
For our purposes. this form of equivalence is enough. 
Thus. for example. 
exists(X, female(X) & motherof(X,eve) 
Is changed by Skolemisation to 
female(gl) & motherof(gl,eve) 

212 
where gl. Is some new constant not used elsewhere. gl represents some female whose mother 
Is Eve. 
It Is Important that we use a different symbol from any used previously. because 
the exiBts(_,_) proposition Is not saying that some particular person Is Eve's daughter. but 
only that there Is such a person. 
It may turn out that gl. will correspond to the same person 
as some other constant symbol. but that Is extra Information that Is not conveyed by this 
proposition. 
When there are universal quantifiers In a formula. Skolemlsation Is not quite so simple. 
For Instance. If we Skolemlsed 
al.l(X, human(X) -) exists(Y,motherof(X,Y» 
("every human has a mother") to 
al.l(X, human(X) -) motherof(X,g2) 
we would be saying that every human has the .same mother -- the thing denoted by g2. 
When there are variables Introduced by universal quantifiers. Skolemlsatlon must Instead 
Introduce function symbols. to express how what exists depend.s on what the variables are 
chosen to stand for. 
Thus the above example should Skolemlse to 
al.l(X, human(X) -) motherof(X,g2(X» 
) 
In this case. the function symbol g2 corresponds to the function In the world that. given any 
person. returns as Its value the mother of that person. 
Here now Is the Prolog definition 
of Skolemlsatlon. 
Stage ~ = Moving universal quantifiers outwards 
This stage Is very simple. 
We just move any universal quantifiers to the outside of the 
formula. 
This does not affect the meaning. 
As an example. 
al.l(X, man(X) -) all(Y,woman(Y)-)l.ikes(X,Y» 
) 
Is transformed to 
al.l(X,all(Y, man(X) -) (woman(Y)-)l.ikes(X,Y» 
» 
Since every variable In the formula Is now Introduced by a universal quantifier at the outside 
of the formula. the quantifiers themselves no longer provide any extra Information. 
So we 
can abbreviate the formula by simply leaving the quantifiers out. 
We just need to remember 
that every variable Is Introduced by an Implicit quantifier that we have left out. 
Thus we can 

213 
now represent: 
all(X,alive(X) # dead(X» 
& all(Y,likes(mary,Y) # impure(Y» 
as: 
(alive(x) # dead(x» 
& likes(mary,y) # impure(y) 
The formula means that. whatever X and Y we choose. either X Is alive or X Is dead. and 
either Mary likes Y or Y Is Impure. 
Stage ~ = Distributing .& • .Q.l!!!! I 
At this stage. our original Predicate Calculus formula has changed a lot. 
We no longer 
have any explicit quantifiers. and the only connectives left are & and • (apart from where 
negation comes Inside a literal>. 
We now put this In a special normal form. conjunctive normal 
form, where conjunctions no longer appear inside disjunctions. Thus we can convert the whole 
formula Into a bundle of &'S, where the things joined together are either literals or literals 
joined by "s. 
To do this. we make use of the two Identities: 
(A & B) # C 
A # (B & C) 
is equivalent to 
is equivalent to 
(A # C) & (B # C) 
(A # B) & (A # C) 
As an example of what happens. the formula: 
holiday(X) # (work(chris,X) & (angry(chris) # sad(chris») 
(FOr every X. either X Is a holiday or both Chris works on X and Chris Is angry or sad) 
Is equivalent to: 
(holiday(X) # work(chris,X» 
& (holiday(X) # (angry(chris) # sad(chris») 
(For every X. first. X Is a holiday or Chris works on X. and second. either X Is a holiday 
or Chris Is angry or sad). 
The formula we have now Is In general made up of a collection of &'S relating things 
which are either literals or composed of literals by "s. 
Let us look first at the top level 
of this. not looking In detail at the "s. 
We might have something like: 
(A & B) & (C & (0 & E» 
where A. B. C. D. E perhaps represent complex propositions. but have no &'S In them. 
Now 

214 
all this nesting of structure Is unnecessary. because all the propositions 
(A & B) & (C & (0 & E» 
A & «B & C) & (0 & E» 
(A & B) & «C & 0) & E) 
mean the same thing. 
Although structurally the formulae are different. they have the same 
meaning. 
This Is because. If I assert that some set of propositions are all true. then It does 
not matter how I group them together when I do so. 
It does not matter. for Instance. whether 
I say 'A Is true. and so are Band C' or 'A and B are true. and so is CO. 
So the bracketing 
is unnecessary to the meaning. 
We can just say (informally): 
A & B & C & 0 & E 
Secondly. the order in which we write these formulae also does not matter. 
It does not matter 
whether I say 'A Is true and so is B' or 'B Is true and so Is A' -- they both mean the 
same. 
Finally. we do not really need to specify the &'8 between the formulae. because we 
know in advance that the top level of the formula Is made up with &'8. 
So. really. we can 
be much more concise about the Import of the formula we are given just by saying that It 
consists of the collection (A. B. C. O. E) (Implicitly conjoined). 
By calling this a collection. 
we are saying that the order does not matter -- the collection (A. B. C. O. E) is exactly 
the same as (B. A. C. E. OJ. (E. O. B. C. AJ. and so on. 
The formulae that end up In 
this collection. when we convert a formula to Clausal form. are called clauses. 
So any 
Predicate Calculus formula Is equivalent (In some sense) to a collection of clauses. 
Let us now look In more detail at what these clauses are actually like. 
We said that 
they are made up of literals joined together by disjunctions. 
So In general a clause will 
be something like: 
«V # W) # X) # (Y # Z) 
where V. W. X. Y and Z are literals. 
Now we can do the same trick that we played with 
the top level of the formula. 
Once again the bracketing is irrelevant to the meaning. and 
the order Is also unimportant. 
So we can simply say that the clause Is the collection of 
literals (V. W. X. Y. Z) (implicitly disjoined). 
Now our original formula has reached clausal form. 
Moreover the rules used for this 
have not altered whether there Is an Interpretation that makes It true or not. 
The clausal 
form consists of a collection of clauses. each of which is a collection of literals. 
A literal 
Is either an atomic formula or a negated atomic formula. 
This form Is quite concise. since 
we have left out things like Implicit conjunctions. disjunctions and universal quantifiers .. We 
must obviously remember the conventions about where these have been missed out when we 

215 
look to see what something In clausal form means. 
Let us look at some formulae (as they would be produced by stage 5) to see what they 
look like in clausal form. 
First of all. the example used before: 
(holiday(X) # work(chris,X» 
& (holiday(X) # (angry(chris) # sad(chris») 
This gives rise to two clauses. 
The first contains the literals: 
holiday(X), work(chris,X) 
and the second contains the literals: 
holiday(X), angry(chris), sad(chris) 
As another example. the formula: 
(person(adam) & person(eve» 
& «person(X) # -mother(X,Y» 
# -person(Y» 
gives rise to three clauses. 
Two of them contain one literal each. 
person(adam) 
and 
person( eve) 
The other one has three literals: 
person(X), -mother(X,Y), -person(Y) 
To bring this section to a close. let us just consider one more example. and the various 
stages as it is translated into clausal form. 
We start with the formula: 
all(X, all(Y,person(Y)->respect(Y,X» 
-> king(X» 
which says that. if everybody respects somebody then that person is a king (For every X. 
if every Y that Is a person respects X. then X is a king). 
When we remove implications (stage 
1) we get: 
all(X, -(all(Y,-person(Y)#respects(Y,X») # king(X» 
Moving negation inwards (stage 2) leads us to: 
all(X, exists(Y,person(Y) & -respects(Y,X» 
# king(X» 

216 
Next. Skolemising (stage 3) translates this to: 
all(X, (person( fl(X» 
& -respects( fl(X),X» 
It king(X» 
where n is a Skolem function. 
Now comes the stage of removing universal quantifiers (stage 
4). which leads to: 
(persoil( fl(X» 
& -respects( fl(X),X» 
fI: king(X) 
We now put this into conjunctive normal form (stage 5). where conjunctions do not appear 
within disjunctions. thus: 
(person( fl(X» It king(X» & (-respects( fl(X),X) fI: king(X» 
This amounts (stage 6) to two clauses. 
The first has the two literals: 
person( fl( X) ) 
king(X) 
and the second has the literals: 
-respects( fl(X),X) 
king(X) 
10.3 
A Notation for ClaulJelJ 
We clearly need a way of writing something down in clausal form. and this is what we 
will now present. 
First of ali. something in clausal form is a collection of clauses. 
As good 
a convention as any Is to write down the clauses one after the other. remembering that the 
order is actually irreievant. 
Within a clause there is a collection of literals. some negated 
and some not negated. 
We will adopt the convention of writing the unnegated literals first 
and the negated ones second. 
The two groups will be separated by the sign ':-'. 
The 
unnegated literals will be written separated by ';'s (remembering. of course. that the order 
is not important). and the negated literals will be written without their -. 8 and separated by 
• .'s. 
Finally. a clause will be terminated by a full stop. 
In this notation. a clause with negated 
literals K. L. .... and unnegated literais A. B. ... would come out like: 
A; 
B; ...... :- X; L, ........ 
Although we have introduced our convention for writing out ciauses as something arbitrary. 
it actually has some mnemonic significance. 
if we write a ciause including the disjunctions. 
with the negated IIterais separated from the unnegated ones. it will look something like: 
(A fI: B fI: ••• ) fI: (-X fI: -L fI: ••• ) 

217 
which Is equivalent to: 
(A # B # ..• ) # "(K & L & ... ) 
which Is equivalent to: 
(K & L & ••• ) -) (A # B # ••• ) 
If we then write ': for 'and'. ';' for 'or' and ':-' for 'Is Implied by' (following the Prolog 
convention). the clause naturally comes out as: 
A; 
BI ..• :- K, L, ... . 
Given these conventions. the formula about Adam and Eve: 
(person(adam) & person(eve» 
& 
«person(x) # "mother(X,Y» 
# "person(Y» 
comes out as: 
person(adam) ,-
• 
person( eve) ,-
person( X) ,- mother( X, Y), person( Y) . 
This Is beginning to look rather familiar. 
This really looks Just like a Prolog definition for 
what it Is to be a person. 
However. other formulae give rise to more puzzling things. 
The 
example about holidays ends up as: 
holiday(X); work(chris,X) ,-
holiday(X); angry(chris); sad(chris) 
which does not so obviously correspond to something In Prolog. 
We will see why this Is 
in a later section. 
In Appendix B. we present a Prolog program to print out clauses In this special notation. 
Written according to our convention. the clauses produced at the end of the last section come 
out as: 
person( fl(X»; king(X) ,-
. 
king(X) ,- respects(fl(X),X). 

218 
10.4 Resolution and Proving Theorems 
Now that we have got a way of putting our Predicate Calculus formulae Into a nice tidy 
form. we should consider what we can do with them. 
An obvious thing to Investigate. when 
we have a collection of propositions. is whether anything interesting follows from those 
propositions. 
That Is. It Is Interesting to Investigate what consequences they have. 
We shall 
call those propositions that we are taking as true for the sake of argument our axioms or 
hypotheses. and those propositions that we find to follow from them our theorems. 
This Is 
consistent with the terminology used to describe one view of Mathematics -- a view which 
sees the work of a mathematician as Involving the derivation of more and more interesting 
theorems from some exact axlomatisation of what sets and numbers are. 
In this section. we 
will look briefly at the activity of deriving Interesting consequences from our given propositions. 
that is. we will look at the activity of theorem proving. 
There was a great deal of activity in the 1960's as people began to investigate the 
possibility that digital computers could be programmed to automatically prove theorems. 
It 
was this area of scientific endeavour. which is still progressing healthily. that gave rise to 
the Ideas behind Prolog. 
One of the fundamental breakthroughs made at this time was the 
discovery of the resolution principle by J. 
Alan Robinson. and Its application to mechanical 
theorem proving. 
Resolution is a rule of inference -- that Is. It tells us how one proposition 
can follow from others. 
Using the resolution principle. we can prove theorems in a purely 
mechanical way from our axioms. 
We only have to decide which propositions to apply it to. 
and valid conclusions will be produced automatically. 
Resolution is designed to work with formulae in clausal form. 
Given two clauses related 
in an appropriate way. It will generate a new clause that Is a consequence of them. 
The 
basiC Idea is that if the same atomic formula appears both on the left hand side of one clause 
and the right hand side of another. then the clause obtained by fitting together the two clauses. 
missing out the duplicated formula. follows from them. 
For example: 
From: 
sad(chris); angry(chris) :- workday(today), raining(today). 
and: 
unpleasant(chris) 
angry(chris), tired(chris). 
follows: 
sad(chris); unpleasant(chris) :-
workday(today), raining(today), tired(chris). 
In English. if today Is a workday and It is raining. then Chris Is sad or angry. 
Also. If Chris 

219 
Is angry and tired. he Is unpleasant. 
Therefore. If today Is a workday. It Is raining and Chris 
Is tired. then Chris Is sad or unpleasant. 
In fact. we have over-simplified In two ways here. 
Firstly. things are actually more 
complicated when the clauses contain variables. 
Now the two atomic formulae do not have 
to be Identical -- they only have to "match". 
Also. the clause that follows from the first 
two is obtained from the two fitted together (with the duplicated formula removed) by an extra 
operation. 
This operation involves "instantiating" the variables just enough so that the two 
matching formulae are identical. 
In PrOlog terms. if we had the two clauses as structures 
and matched together the appropriate substructures. the result of fitting them together 
afterwards would be the representation of the new clause. 
Our second simplification Is that 
In general resolution one is allowed to match several literals on a right hand side against 
several on a left hand side. 
Here. we will only consider examples where one literal is chosen 
from each clause. 
Let us look at one example of resolution involving variables: 
(1) person( fl(X»; king(X) ,-
. 
(2) 
king(Y) ,- respects( U(Y), Y). 
( 3) 
respects( Z, john) ,- person( Z). 
The first two of these are what we obtained as the clausal form of our formula saying "if 
every person respects somebody then that person Is a king". 
We have renamed the variables 
for ease of explanation. 
The third expresses the proposition that every person likes John. 
Resolving (2) with (3) (matching the two respects literals), gives us: 
(4) king(john) ,- person(fl(john». 
eY In (2) matched with 'john' In (3) and Z In (3) matched with 'tleY)' In (2». 
We can now 
resolve (1) with (4), to give: 
( 5 ) 
king( john); king( john) ,-
. 
This is equivalent to the fact that John is a king. 
In the formal definition of resolution, the process of "matching" that we have referred 
to Informally Is called unification. 
Intuitively, a set of atomic formulae are unifiable if, as 
Prolog structures, they can be matched together. 
Actually, we will see in a later section 
that the matching In most Prolog implementations is not exactly the same as unification, 
How can we use resolution to try and prove a specific thing? 
One possibility Is that 
we can keep on applying resolution steps to our hypotheses and look to see if what we want 
appears. 
Unfortunately. we cannot guarantee that this will happen, even if the proposition 

220 
we are Interested In really does follow from the hypotheses. In the above example. for Instance. 
there is no way of deriving the simple clause kinq(jobn) from the clauses given. even though 
It Is clearly a consequence. 
So must we conclude that resolution Is not powerful enough 
for what we want? 
Fortunately. the answer is ·no·. for we can rephrase our aims in such 
a way that resolution Is guaranteed to be able to solve our problem If It Is possible. 
The Important formal property that Resolution has Is that of being refutation complete. 
This means that. If a set of clauses are inconsistent then Resolution will be able to derive 
from them the empty clause: 
Also. since Resolution Is correct, it will only be able to derive the empty clause In this 
circumstance. 
A set of formulae Is inconsistent if there Is no possible interpretation for the 
predicates. constant symbols and function symbols that makes them simultaneously express 
true propositions. 
The empty clause Is the logical expression of falsity --
It represents a 
proposition that cannot possibly be true. 
So Resolution can be guaranteed to tell us when 
our formulae are inconsistent by deriving this clear expression of contradiction. 
How can these particular properties of resolution help us? 
Well. It Is a fact that 
If the formulae [A" 
A2,... 
An' are consistent, 
formula a is a consequence of formulae (A" 
A2 , 
exactly when the formulae (A" 
A2,... 
An' -aF 
are inconsistent. 
A' 
n 
So. if our hypotheses are consistent. we just need to add to them the clauses for the negation 
of what we want to prove. 
Resolution will derive the empty clause exactly when the proposition 
follows from the hypotheses. 
We call the clauses that we add to the hypotheses the goal 
statements. 
Note that the goal statements do not look In any way different from the hypotheses 
-- all of them are just clauses. 
So. If we are presented with a set of clauses 
A n 
and are told that the task is to show them to be inconsistent. we cannot actually tell whether 
this Is in order to show that: 
-A, follows from A2, A3, 
A n 
or 
-A 2 follows from At' A3, 
A n 
or 
-A3 follows from At' A2, 
A 
etc. 
n 
It is a matter of emphasis which statements we actually consider to be the goal statements. 

221 
because in a Resolution system all these tasks are equivalent. 
In our example about John being king. it is easy to see how we can obtain the empty 
clause if we add the goal statement: 
(6) ,- king(john). 
(this is the clause for -kingqohn». 
We saw before how the clause 
(5) king(john); king(john) ,-
• 
was derived from the hypotheses. Resolving (5) with (6) (matching either of the atomic formulae 
in (5». we obtain: 
(7) king(john) ,-
• 
Finally. resolving (6) with (7) gives us: 
,- . 
So resolution has shown that as a consequence John is a king. 
The completeness of Resolution is a nice' mathematical property. 
It means that If some 
fact follows from our hypotheses. we should be able to prove its truth (by showing the 
inconsistency of its negation and the hypotheses) using Resolution. 
However. when we say 
that Resolution will be able to derive the empty clause. we mean that there is a sequence 
of Resolution steps. each involving axioms or clauses derived in previous steps. which ends 
in the production of a clause with no literals. 
The only trouble is to find the sequence of 
steps. 
For. although Resolution tells us how to derive a consequence from two clauses. It 
does not tell us either how to decide which clauses to look at next or which literals to "match". 
Usually. if we have a large number of hypotheses. there will be many possibilities for each. 
Moreover. each time we derive a new clause. It too becomes a candidate to take part in 
further resolutions. 
Most of the possibilities will be irrelevant for the task at hand. and If 
we are not careful we may spend so much time on Irrelevances that we will never find the 
solution path. 
Many refinements of the original resolution principle have been proposed. to address 
these Issues. 
The next section considers some of these. 

222 
10.5 
Horn Clauses 
We will look now at refinements designed for resolution when all the clauses are of 
a certain kind -- when they are Horn clauses. 
A Horn clause is a clause with at most one 
unnegated literal. 
It turns out that. If we are using a clausal theorem prover to determine 
the values of computable functions, It Is only strictly necessary to use Horn clauses. 
Because 
resolution with Horn clauses Is also relatively simple, they are an obvious choice as the basis 
of a theorem prover which provides a practical programming system. 
Let us consider briefly 
what Resolution theorem proving looks like if we restrict ourselves to Horn Clauses. 
Firstly, there are obviously two kinds of Horn Clauses -- those with one unnegated literal 
and those with none. 
Let us call these two types headed and headless Horn Clauses. 
The 
two types are exemplified by the following examples (remember that we write the unnegated 
literals on the left hand side of the ':-'): 
bachelor(X) ,- male(X), unmarried(X). 
,- bachelor( X ) . 
In fact, when we consider sets of Horn Clauses <Including goal statements). we need only 
consider those sets where all but one of the clauses are headed. That Is, any soluble problem 
(theorem-proving task) that can be expressed In Horn Clauses can be expressed In such a 
way that: 
o 
There Is one headless clause 
o 
All the rest of the clauses are headed 
Since it Is arbitrary how we decide which clauses are actually the goals, we can decide to 
view the headless clause as the goal and the other clauses as the hypotheses. 
This has 
a certain naturalness. 
Why do we only have to consider collections of Horn Clauses that conform to this pattern? 
First, It Is easy to see that at least one headless clause must be present for a problem to 
be soluble. This Is because the result of resolving two headed Horn Clauses Is Itself a headed 
Horn Clause. 
So, If all the clauses are headed, we will only be able to derive other headed 
clauses. 
Since the empty clause Is not headed, we will not be able to derive it. 
The second 
claim --
that only one headless clause Is needed --
Is slightly more difficult to justify. 
However, It turns out that. if there are several headless clauses among our axioms, any 
Resolution proof of a new clause can be converted into a proof using at most one of them. 
Therefore, If the empty clause follows from the axioms the It follows from the headed ones 
together with at most one of the headless ones. 

223 
10.6 
Prolog 
Let us now summarise how Prolog fits Into this scheme of things. 
As we saw before. 
some of our formulae turned Into clauses that looked remarkably like Prolog clauses. whereas 
others looked somewhat peculiar. 
Those that turned Into Prolog-like clauses were. In fact. 
those whose translation was Into Horn clauses. 
When we write a Horn clause according to 
our conventions. at most· one atomiC formula appears on the left of the ':-'. 
In general. 
clauses may have several such formulae (these correspond to the literals which are unnegated 
atomiC formulae). 
In Prolog. we can express directly only the Horn clauses. 
The clauses 
of a Prolog program correspond to headed Horn clauses In a certain kind of theorem prover. 
What In Prolog corresponds to the goal statement? 
Quite' simply. the Prolog question: 
1- Al., A2, ••• 
An. 
corresponds exactly to the headless Horn Clause: 
,- Al., A2, ••• 
An. 
We saw in the last section that. for any problem we want to solve with Horn Clauses. It suffices 
to have exactly one headless clause. 
This corresponds to the situation In Prolog. where all 
the clauses of the ·program" are headed and only one (headless) goal Is considered at any 
one time. 
A Prolog system Is based on a resolution theorem prover for Horn clauses. The particular 
strategy that It uses Is a form of linear Input resolution. 
When this strategy is used. the 
choice of what to resolve with what at any time Is restricted as follows. 
We start with the 
goal statement and resolve It with one of the hypotheses to give a new clause. 
Then we 
resolve that with one of the hypotheses to give another new clause. 
Then we resolve that 
with one of the hypotheses. and so on. 
At each stage. we resolve the clause last obtained 
with one of the original hypotheses. 
At no point do we either use a clause that has been 
derived previously or resolve together two of the hypotheses. 
In Prolog terms. we can see 
the latest derived clause as the conjunction of goals yet to be satisfied. 
This starts off as 
the question. and hopefully ends up as the empty clause. 
At each stage. we find a clause 
whose head matches one of the goals. Instantiate variables as necessary. remove the goal 
that matched and then add the body of the Instantiated clause to the goals to be satisfied. 
Thus. for Instance. we can go from: 
,- mother(john,X), mother(X,Y). 
and 
mother(U,V) ,- parent(U,V), female(v). 

224 
to: 
:- parent(john,X), fema1e(X), mother(X,Y). 
In fact. Prolog's proof strategy Is even more restricted than general linear Input resolution. 
In this example. we decided to match the first of the literals In the goal clause. but we could 
equally well have matched the second. 
In Prolog. the literal to be matched Is always selected 
In the same way -- It Is always the first one In the goal clause. This makes Prolog's strategy 
a kind of SL resolution. 
In addition, the new goals derived from the use of a clause are 
placed at the front of the goal clause -- this just means that Prolog finishes satisfying a 
subgoal before It goes on to try anything else. 
So much for what happens when Prolog has decided what clause to match against the 
first goal. But how does It organise the Investigation of alternative clauses to satisfy the same 
goal? 
Basically, Prolog adopts a depth-first strategy, rather than a breadth-first one. 
This 
means that It only considers one alternative at a time. following up the Implications under 
the assumption that the choice Is correct. 
For each goal. It chooses the clauses In a fixed 
order. and It only comes to consider the later ones If all the earlier ones have failed to 
lead to solutions. 
The alternative strategy would be one where the system kept track of 
alternative solution paths simultaneously. 
It would then move around from one alternative to 
another. following It up for a short time and then going on to something else. 
This latter. 
breadth-first. strategy has the advantage that. if a solution exists, It will be found. 
The Prolog 
depth-first strategy can get Into 'Ioops" and hence never follow up some of the alternatives. 
On the other hand. it is much simpler and less space-consuming to Implement on a 
conventional computer. 
Finally. a note about how Prolog matching sometimes differs from the unification used 
In Resolution. 
Most Prolog systems will allow you to satisfy goals like: 
equa1(X,X). 
1- equa1( foo(Y), Y). 
that Is. they will allow you to match a term against a subterm of Itself. 
In this example. 
foo(Y) Is matched against Y, which appears within It. 
As a result. Y will stand for foo(Y), 
which Is foo(foo(Y» (because of what Y stands for). which Is £oo(£oo(£oo(Y»), and so 
on. 
So Y ends up standing for some kind of Infinite structure. 
Note that. whereas they may 
allow you to construct something like this. most Prolog systems will not be able to write It 
out at the end. 
According to the formal definition of Unification. this kind of "Infinite term" 
should never come to exist. 
So Prolog does not act correctly as a Resolution theorem prover 
In this respect. 
In order to make It do so. we would have to add a check that a variable 
cannot be Instantiated to something containing Itself. 
Such a check. an occur check, would 
be straightforward to Implement. but would slow down the execution of Prolog programs 
considerably. 
Since It would only affect very few programs. most Implementors have simply 

225 
left It out. 
10.7 
Prolog and LogIc ProgrammIng 
In the last few se,ctlons. we have seen how Prolog Is based on the Idea of a theorem 
prover. 
As a result of this. we can see that our programs are rather like our hypotheses 
about the world. and our questions are rather like theorems that we would like to have proved. 
So programming in Prolog is not so much like telling the computer what to do when. but 
rather like telling it what is true and asking it to try and draw conclusions. 
The idea that 
programming should be like this is an appealing one. and has led many people to investigate 
the notion of logic programming, that is. programming In logic as a practical possibility. 
This 
is supposed to contrast with using a conventional programming language like FORTRAN or 
LISP. where one specifies tasks much more clearly in terms of what the computer should 
do and when it should do it. 
The advantages of logic programming should be that computer 
programs are easier to read. 
For they will not be ciuttered up with details about how things 
are to be done -- they will be more like specifications of what a solution will look like. 
Moreover. if a program is rather like a specification of what it 
is supposed to achieve, it 
should be relatively easy. just by looking at it (or. perhaps. by some automatic means) to 
check that it really does do what is required. 
In summary. the advantages of a logic 
programming language would result from programs having a declarative semantiCS as well as 
a procedural one. 
We would know what a program computes. rather than how It computes 
It. 
We will not be able to look at iogic programming in general here. 
The Interested reader 
is referred to R. 
Kowalski's book 
Logic for Problem Solving published by North Holland in 
1979. 
Let us briefly look at Prolog as a candidate logic programming language. and see how 
well it shapes up. 
First. it is clear that some Prolog programs do represent logical truths 
about the worid. 
If we write: 
mother(X,Y) ,- parent(X,Y), female(Y). 
we can see this as saying what it is to be a mother <It is to be a female parent>. 
So this 
clause expresses a proposition that we are hypothesising to be true. as well as saying how 
to show that somebody is a mother. 
Similarly. the clauses: 
append( [] ,X,X). 
append( [AlB] ,C, [AID]) ,- append(B,C,D). 
say what it is for one list to be appended at the front of another. 
If the empty list is put 
on the front of some list X. then the result is just X. 
On the other hand. if a non-empty 
list is appended on the front of a list. then the head of the result is the same as the head 
of the list being put on the front. 
Also. the tall of the result Is the same list as would be 
obtained by appending the tall of the first list onto the front of the second. 
These clauses 

226 
can definitely be seen as expressing what Is true about the append relation. as well as (perhaps) 
how one should actually set about appending two lists together. 
So much for some Prolog programs. but what possible logical meaning can we give to 
clauses like these? 
memberl(X,List) :- var(List), I, fail. 
memberl(X, [XI_]). 
memberl(X,[_IList]) :- memberl(X,List). 
print(O) :- I. 
print(N) :- write(N), Nl is N-l, print(Nl). 
noun(N) :-
name(N,Namel), append(Name2, [115],Namel), 
name(RootN,Name2), noun(RootN). 
implies(Assum,Concl) 
asserta( Assum), 
call( Concl), 
retract( Concl ) . 
The problem comes with all those "built-In" predicates that we use in our Prolog programs. 
Something like var(List) does not say anything about lists or membership. but refers to a 
state of affairs (some variable being un instantiated) that may hold at some time during the 
proof. 
The "cut" similarly says something about the proof of a proposition (which choices 
may be ignored>. rather than about the proposition Itself. 
These two "predicates" can be 
regarded as ways of expressing control Information about how the proof Is to be carried out. 
Similarly. something like write(N) does not have any Interesting logical properties. but 
presupposes that the proof will have reached a certain state (with N Instantiated) and Initiates 
a communication with the programmer at his terminal. name(N,Namel.) is saying something about 
the Internal structure of what. in Predicate Calculus. would be an indivisible symbol. 
In Prolog. 
we can convert symbols to character strings. convert structures to lists and convert structures 
to clauses. 
These operations violate the simple seit-contained nature of Predicate Calculus 
propositions. 
In the last example. the use of asserta, means that the rule Is talking about 
adding something to the set of axioms. 
In logic. each fact or rule states an Independent 
truth. independent of what other facts and rules there may be. 
Here we have a rule that 
violates that principle. 
Also. if we use this rule. we will be in a position of having a different 
set of axioms at different times of the proof! 
Finally. the fact that the rule envisages Conel 
being used as a goal means that a logical variable is being allowed to stand for a proposition 
appearing In an axiom. 
This Is not something that Could be expressed In Predicate Calculus 
at all. 
Given these examples. we can see that some Prolog programs can only be understood 
In terms of what happens when and how they tell the system what to do. 
As an extreme 
case. the program for gensym given in Chapter 7 can hardly be given any declarative 

227 
Interpretation at all. 
So does It make sense to regard Prolog as a logic programming language at all? 
Can 
we really expect any of the advantages of logic programming to apply to our Prolog programs? 
The answer to both these questions Is ·yes·. and the reason Is that. by adopting an appropriate 
programming style. we can stili get some advantages out of the relation of Prolog to logic. 
The key Is to decompose our programs Into parts. confining the use of the non-logical 
operations to within a small set of clauses. 
As an example. we saw In Chapter 4 how some 
uses of the 'cut' could be replaced with uses of not. 
As a result of such replacements. 
a program containing a number of 'cuts' can be reduced to one with the ·cut' only used 
once (In the definition of not). 
Use of the predicate not, even though It does not capture 
exactly the logical '-'. enables one to recapture part of the underlying logical meaning of 
a program. 
Similarly. confining the use of the predicates asserta and retract: to within the 
definitions of a small number of predicates (such as g8nsya and findal.l.) results In a program 
that Is clearer overall than one where these predicates are used freely In all sorts of contexts. 
The ultimate goal of a logic programming language has not. then. been achieved with 
Prolog. 
Nevertheless. Prolog provides a pr.actlcal programming system that has some of the 
advantages of clarity and declaratlveness that a logic programming language would offer. 
Meanwhile the work goes on to develop Improved versions of Prolog that are truer to the 
logic than what we currently have available. 
Among the highest priorities Of workers In this 
area Is to develop a practical system that does no~ need the "cut" and has a version of not 
that exactly corresponds to the logical notion of negation. 

Chapter 11. Projects in Prolog 
This chapter contains a list of projects that you may wish to undertake In order to exercise 
your programming ability. 
Some of the projects are easy. but some may be appropriate as 
"term projects" as a part of a course in Prolog. 
The easier projects should be used to 
supplement the exercises In the previous chapters. 
The projects are in no particular order. 
although those in Section 11.2 are more open ended and ambitious. and will require some 
knowledge or background reading In various areas of artificial intelligence and computer 
science. 
A few of the projects assume knowledge about some particular field of study. so 
If you are not a mathematical physicist. do not feel discouraged if you cannot write a program 
to differentiate three dimensional vector fields. 
A collection of Prolog programs is published in the report "How to solve it with Prolog". 
edited by H Coelho. J C Cotta. and L M Pereira. 
The report Is distributed by the Laboratorlo 
Naclonal de Engenharla Civil. In Lisbon. Portugal. 
It contains over a hundred small examples. 
problems. and exercises In area such as deductive reasoning over databases. natural language. 
symbolic equation solving. and so forth. 
The report is not intended to be tutorial in nature. 
and so the Prolog programs In it are presented with limited explanatory accompaniment. 
11.1 
Easier Projects 
1. 
Define a predicate to "flatten" a list by constructing a list containing no lists as elements. 
but containing all of the atoms of the original list. 
For example. the following goal 
would succeed: 
flatten([a,[b,c),[[d),[),e)), [a,b,c,d,e). 
2. 
Write a program to calculate the interval in days between two dates expressed in the 
form Day--'MOnth, assuming they refer to the same year which Is not a leap year. 

229 
Notice that '-' is simply an Infix operator. 
For example, the following goal would 
succeed: 
interval(3-march, 7-april, 35). 
3. 
In Chapter 7 sufficient Information is given to construct programs to differentiate and 
simplify arithmetic expressions. 
Extend these programs so they will handle expressions 
containing trigonometric functions, and if you desire, differential geometry operators 
such as div, grad. and curl. 
4. 
Write a program to produce the negation of a propositional expression. 
Propositional 
expressions are built up from atoms, the unary functor not, and binary functors and, 
or, and imp1ies. Provide suitable operator declarations for the functors. The negated 
expression should be in simplest form, where not is only applied to atoms. 
For 
example, the negation of 
p implies (q and not r) 
should be 
p and (not q or r), 
5. 
A concordance is a listing of words that occur in a text. listed in alphabetical order 
together with the number of times each word appears in the text. 
Write a program 
to produce a concordance from a list of words represented as Prolog strings. 
Recall 
that strings are lists of ASCII codes. 
6. 
Write a program that understands simple English sentences having the following forms: 
is a ___ ' 
A ___ is a ___ ' 
Is ___ a ___ ? 
The program should give an appropriate response <yes, no, ok. unknown>. on the basis 
of the sentences previously given. 
For example. 
John is a man. 
ok 
A man is a person. 
ok 
Is John a person? 
yes 
Is Mary a person? 
unknown 

230 
Each sentence should be translated into a Prolog clause. which is then asserted or 
executed as appropriate. 
Thus. the translations of the preceding examples are: 
man(john). 
person(X) ,- man(X). 
?- person( john) • 
?- person(mary). 
Use grammar rules if you find them appropriate. The top clause to control the dialogue 
might be: 
talk ,-
repeat, 
read( sentence) , 
parse(sentence,Clause), 
respon~to(Clause), 
Clause - stop. 
7. 
The alpha-beta (a-/J) algorithm is a method for searching game trees that is mentioned 
in many books on artificial intelligence programming. 
Implement the a-/J algorithm 
in Prolog. 
8. 
The N-queens problem is also widely discussed in programming texts. 
Implement a 
program to find all the ways of placing 4 queens on a 4><4 chessboard so that no 
queen attacks another. One way is to write a permutation generator. which then checks 
each permutation to ensure that it places the queens correctly. 
9. 
Write a program that rewrites propositional expressions (Problem 4). replacing all 
occurrences of and, or, iJlpl.ies, and not by the single operator nand. 
The functor 
nand is defined by the following equivalence: 
a nand /J 
'" 
note a and /J) 
nand has the following truth table: 
o 
l. 
o 
l. 
l. 
l. 
l. 
0 
10. 
One way of representing the positive whole numbers is as Prolog terms involving the 
integer 0 and the functor s with one argument. 
Thus. we represent 0 by itself. 1 
by s(O), 2 by s(s(O» and so on (each number is represented by the functor s applied 

231 
to the representation of the number one less), 
Write definitions of the standard 
arithmetic operations addition. multiplication and subtraction. given this representation 
of numbers, For Instance. you should define a predicate plus that exhibits the following 
behaviour: 
?- pl.uS(S(S(O»,S(S(S(O»),X). 
x = S(S(S(S(S(O)}») 
(2+3=5), 
For subtraction. you will have to Introduce a convention for when the result 
of the operation Is not a positive whole number, 
Also define the predicate "less than", 
What arguments need to be instantiated for your definitions to work? 
What happens 
In the other cases? 
How does this compare with the standard Prolog arithmetiC 
operations? 
Try defining some more complicated arithmetic operations. like integer 
division and square root. 
11.2 
Advanced Projects 
Although the projects in this section may seem open ended. all of them have been 
implemented in Prolog by various programmers around the world. 
Some of them are 
straightforward enhancements to programs discussed earlier. and some of them are completely 
new. and depend on knowledge of the artificial intelligence literature or computer science. 
1. 
Given a map that describes roads that connect towns. write a progam that plans a 
route between two towns. giving a timetable of expected travel. 
The map data could 
include mileage. road conditions. gradients. availability of fuel along various roads. 
2, 
Only integer arithmetic operations are built into current Prolog systems. Write a package 
of programs to support arithmetic over rational numbers. represented either as fractions 
or as mantissa and exponent. 
3. 
Write procedures to invert and multiply matrices. 
4. 
Compiling a high-level computer language into a low-level language can be viewed 
as the successive transformation of syntax trees. Write such a compiler. first compiling 
arithmetic expressions, 
Then add control syntax (like If, .. then ... else), 
The syntax of 
the assembly output is not crucial for this purpose, 
For example. the arithmetic 
expression x+1 could be "simplified" into the assembly language statement inc x, where 
inc is declared as a unary operator. 
The problem of register allocation can be 
postponed by assuming that the code compiles into a form suitable for execution by 

232 
a stack machine (O-address machine). 
5. 
Devise a representation for complex board games such as Chess or Go. and understand 
how the pattern matching capabilities of Prolog might be used to implement strategies 
for these games. 
6. 
Devise a formalism for expressing sets of axioms. say from Group Theory. Euclidean 
Geometry. Denotational Semantics. and 
Investlga~e the problem of writing a theorem 
prover for these domains. 
7. 
An interpreter for Prolog clauses can be written In Prolog. 
Write an Interpreter that 
Implements different semantics for Prolog execution. such as more flexible execution 
order (instead of left-to-rlght). perhaps using an "agenda" or scheduling mechanism. 
8. 
Consult the artificial intelligence literature on the area of generating plans to solve 
problems. and Implement a plan generator. 
9. 
Express In Prolog the problem of Interpreting a line drawing In terms of some underlying 
scene. 
Features 
of the 
picture 
can 
be 
labelled 
with 
variables 
representing 
corresponding features of the scene. 
The picture then corresponds to a set of 
constraints these variables must satisfy. 
10. 
Write a program. using Grammar Rules. to parse sentences of the form: 
Fred saw John. 
Mary was seen by John. 
Fred told Mary to see John. 
John was believed to have been seen by Fred 
Was John believed to have told Mary to see Fred? 
11. 
A production system. used In artificial intelligence research. Is a sequence of rules 
of the form "If situation then action". 
It has become fashionable within the artificial 
intelligence field to write "expert knowledge" in terms of production rules. 
For example. 
the following sentences are typical of those used In actual production systems that 
have been Implemented: 
Pharmacology: 
If agent X is a 
quaternary ammonium salt and an 
anti-a rhythmic, and agent Y is a salicylate, then X and Y will Interact 
to produce increased absorption by ion pair formation. 
Playing chess: 
If the black king can move adjacent to the black knight 
and the distance from the white king to the knight is greater than one 
square, then the knight is safe. 
Medicine: 
If the site of the culture is blood, and the gram stain of the 
organism Is negative, and the morphology of the organism Is a rod, and 
the patient Is a compromised host, then there Is a 60% chance that the 

233 
organism is Pseudomonas aeruginosa. 
Write a Prolog program to Interpret a set of production rules. 
Consider some domain 
such as identifying plants or animals from identifying characteristics. 
For example. 
a rule from botany would read: 
If a plant has a square stem. paired leaves. two-lipped hooded flowers. 
and fruit consisting of four tiny nuts enclosed In the calyx. 
then it 
belongs to the family Labiatae. 
So. If the program asked the question "Does the flower have a square stem?". then 
we would rule out the possibility that it belongs to the family Lablatea by answering 
"no·. 
12. 
Write a program to translate some corpus of English sentences into Predicate Calculus. 
13. 
Write a program to prove theorems in Predicate Calculus. 
14. 
Write a program to act as a simulated psychiatrist that makes a reply based on key 
words In the input. rather like the program in Chapter 3 that changed keywords in 
a sentence into other words. 
A typical dialogue might be (computer's responses in 
italics): 
What is your problem? 
This is too much work. 
What else do you regard as too much work? 
Writing letters. 
I see. 
Please continue. 
Also washing my mother's car. 
Tell me more about your family. 
Why should I? 
Why should you what? 
Here the appropriate key words were "this is". "mother". and "why". 
The lack of 
appropriate keyword evoked the response "I see. 
Please continue". 
15. 
Write a program that parses sentences about happenings in an office building. such 
as "Smith will be In his office at 3 pm for a meeting". You might wish to use Grammar 
Rules to capture the "business English" language. 
The program should then print 
out a "summary" of the sentence telling who. what. where. and when; 
such as follows: 
who: smith 
where: office 

234 
when. 3 pm 
what. meeting 
The summary could be represented as assertions In the database. so that questions 
could be asked: 
Where Is Smith at 3 pm? 
where: office 
what: meeting 
16. 
Write a natural language Interface to the filing system of your computer to answer 
questions such as: 
How many flies does David own? 
Does Chris share PROG.MAC with David? 
When did Bill change the file VIDEO.C? 
The program must be able to Interrogate various parts of the filing system such as 
ownership and dates. 

235 
Append;x A 
Answers to se1ected Exercises 
We Include here suggested answers to some of the exercises that appear In the text. 
With 
most programming exercises. there Is rarely a single correct answer. and you may well have 
a good answer that looks different from what we suggest. 
In any case. you should always 
try out your program on your local Prolog system. to see whether It really works. 
Even If 
you have written a correct program that Is different. It may stili be Instructive to spend some 
time looking at an alternative approach to the same problem. 
Exercise J.g 
Here are possible definitions of the family relationships. 
is~ther(Mum) ,- mother(Mum,Chi1d). 
is_father(Dad) ,- father(Dad,Chi1d). 
is_son(Son) ,- parent(Par,Son), ma1e(Son). 
is_sister(Sis,Pers) ,-
parente Par, Sis), 
parent(Par,Pers), 
fema1e( Sis), 
diff( sis, Pers ) • 
gran~of(Gpa,X) ,- parent(Par,X), father(Gpa,Par). 
sib1ing(S1,S2) ,- parent(Par,S1), parent(Par,S2), diff(S1,S2). 
Note that we must use the predicate diff In the definition of is.-sister and sib:Ling. 
This 
prevents the system thinking that somebody can be a sister or sibling of themselves. 
You 
will not be able to define diff at this stage. 
Exercise 5.2 
The following program reads In characters (from the current Input file) Indefinitely. printing 
them out again with 'a's changed to 'b's. 
go ,- repeat, geto(c), deal-with(C), fai1. 
deal-with(97) ,- t, put(98). 

236 
dea1-with(X) :- put(X). 
The 'cut" In the first deal..-with rule Is essential (why?). 97 and 98 are the ASCII codes for 
'a' and 'b' respectively. 
Exercise 6.2 
Why will the following definition of get not work if we have a get goai with an instantiated 
argument? 
get(X) :- new_get(x), X>32. 
new_get(X) :- repeat, geto(x). 
Let's assume that we give Proiog the goal get( 97) (is the next printing character an 'a'?) 
when the very next character is in fact a 'b'. To satisfy get(97), we try to satisfy new_get(97). 
The repeat goal succeeds. but then the goai geto( 97) falls (the next character is not an 
'a'). 
Now backtracking occurs. 
The geto goal cannot be resatisfied. but the repeat one 
can be. 
So repeat succeeds again. and an attempt is made to satisfy geto( 97) again. 
This time. of course. the next character will be the one after the 'b'. 
if this is not an 'a', 
the goal will fall and repeat will succeed again. 
Then the next character will be looked at. 
And so on. 
What is actually happening is that the program is reading more and more 
characters until it finally finds one that matches with the argument. 
This is not what get 
was supposed to do. 
A good definition of get, which gets over this problem and also contains 
a 'cut" to remove the repeat choice. follows: 
get(X) :- repeat, getO(Y), 32<Y, I, X=Y. 
Exercise 7.10 
Here is a program that generates 'Pythagorean" triples: 
pythag(X,Y,Z) :-
intriple(X,Y,z), 
Sumsq is x*x + Y*Y, 
Sumsq is z*z. 
intriple(X,Y,Z) :-
is_integer( Sum) , 
minus(sum,X,Suml), 
minus( Suml, Y, Z). 
minus(sum,sum,O). 
minus(Sum,01,02) :-
Sum>o, 
SumJ. is Sum-1, 
minus(SumJ.,01,D3), 
D2 is 03+1. 

is_integer( 0 ) • 
is_integer(N) :-
is_integer( Nl ) , 
N is Nl+l. 
237 
The program uses the predicate intriple to generate possible triples of Integers IX. Y. Z). 
It then checks to see whether this triple really Is a Pythagorean triple. The definition of Intrlple 
has to guarantee that a/l triples of Integers will eventually be generated. It first of all generates 
an Integer that Is the sum of X. Y and Z. 
Then It uses a non-deterministic subtraction 
predicate. lllinus, to generate values of X. Y and Z from that. 
Exercise II 
Here Is the program for translating a simple grammar rule Into Prolog. 
It Is assumed 
here that the rule contains no phrase types with extra arguments. no goals Inside curly brackets 
and no disjunctions or cuts. 
?- op{255,xfx,--». 
translate{{Pl-->P2),{Gl:-G2» ,-
left_han~side{Pl,SO,S,Gl), 
right_han~side{P2,SO,S,G2). 
left_han~side{PO,So,S,G) ,-
nonvar{ po ) , 
tag{po,SO,S,G) • 
right_han~side«Pl,P2),SO,S,G) ,- I, 
right_han~side{Pl,SO,Sl,Gl), 
right_han~side{P2,Sl,S,G2), 
and{Gl,G2,G) . 
right_han~side(P,SO,s,true) ,-
islist{ P ) , I, 
append{P,S,SO) • 
right_han~side{P,SO,S,G) ,-
tag{P ,SO,S,G). 
tag{P, SO,S,G) ,-
atom{P), 
G= •• [P,SO,S]. 
and{ true,G,G) ,- I. 
and{G,true,G) ,- I. 
and{Gl,G2,(Gl,G2». 
islist{[]) ,- I. 
islist{ [-1_]). 
append{ [AlB] ,C, [AID]) ,- append{B,C,D). 
append{ [] ,X,X). 
In this program. variables beginning with ·P" stand for phrase descriptions (atoms. or lists 
of words) In grammar rules. 
Variables beginning with "G" stand for Prolog goals. 
Variables 
beginning with "S" stand for arguments of the Prolog goals (which represent sequences of 

238 
words). 
In case you are Interested, there follows a program that will handle the more general 
cases of grammar rule translation. 
One way In which a Prolog system can handle grammar 
rules Is to have a modified version of consul.t, In which a clause of the form A -> B Is 
transl.ate 'd before It Is added to the database. 
?- op(251,fx,{). 
?- op(250,xf,». 
?- op(255,xfx,-». 
transl.ate« pO->QO), (P: -Q» 
:-
left_han~side(PO,So,S,P), 
right_han~side(Qo,so,S,Q1), 
flatten( 121,12 ) . 
left_han~side«NT,Ts),SO,S,P) :- I, 
nonvar( NT), 
islist(Ts), 
tag(NT,SO,Sl,P), 
append(Ts,SO,S1). 
left_han~side(NT,SO,S,P) :-
nonvar( NT ) , 
tag(NT,SO,S,P) . 
right_han~side«Xl,X2),SO,S,P) :- I, 
right_han~side(Xl,SO,S1,P1), 
right_han~side(X2,S1,S,P2), 
and(P1,P2,P) . 
right_han~side«Xl;X2),SO,S,(P1;P2» :- I, 
or(Xl,SO,S,P1), 
or(X2,SO,S,P2) . 
right_han~side( {P},S,S,P) ,- I. 
right_han~side( I,S,S,I) ,- I. 
right_han~side(Ts,So,S,true) :-
is1ist( TS), I, 
append(Ts,S,SO) . 
right_han~side(X,SO,S,P) :-
tag(X,So,S,P). 
or(X,So,S,P) :-
right_han~side(X,SOa,s,Pa), 
var(soa), soa 
S, I, SO=SOa, P-Pa; 
P=(so=soa,Pa) ). 
tag(X,So,S,P) :-
X= .. [FIA], 
append(A, [SO, S] ,AX), 
P= .. [FlAX]. 
and( true,P ,P) :- I. 
and(P,true,P) :- I. 
and(P ,12, (P ,12». 
fl.atten(A,A) :- var(A), I. 
fl.atten( (A,B),C) :- I, 
flatten1(A,C,R), 
flatten( B, R) . 
fl.atten( A,A). 
fl.atten1(A,(A,R),R) :- var(A), I. 
flatten1«A,B),C,R) :- I, 

flattenl(A,C,Rl), 
flattenl(B,Rl,R). 
flattenl(A, (A,R),R). 
isHst( [ ) 
: -
I. 
islist([_I_) • 
append([AIB),C,[AID) 
append( [) ,X,X). 
Exercise 9.2 
append(B,C,D) . 
The definition of the general version of phrase is as fo11ows: 
phrase(Ptype,Words) :-
Ptype = .. [PredIArgs), 
append(Args, [Words,[)) ,NewargS), 
Goal = .• [PredINewargs), 
call( Goal) . 
where append is defined as in Section 3.6. 
239 

240 
Clausal Form - Prolog Programs 
As promised In Chapter 10. we will Illustrate the process of converting a formula to clausal 
form by showing fragments of a Prolog program for doing this. 
The top level of the program 
Is as follows: 
translate( X) :-
implout( x, Xl. ) , 
/* stage 1 */ 
negin(Xl.,X2), 
/* stage 2 */ 
skolem(X2,X3,[]), 
/* stage 3 */ 
univout(X3,X4), 
/* stage 4 */ 
conjn(X4,XS ), 
/* stage 5 */ 
clausify(X5,Clauses,[]), 
/* stage 6 */ 
pclauses(Clauses). 
/* Print out clauses */ 
This defines a predicate translate, such that If we give Prolog the goal translate(X), with 
X standing for a Predicate Calculus formula. the program will print out the formula's 
representation as clauses. 
In the program. we will represent Predicate Calculus formulae as 
Prolog structures. as we have Indicated before. 
However. we will deviate from the previous 
descriptions In representing Predicate Calculus variables by Prolog atoms. as this makes certain 
manipulations easier. We can distinguish Predicate Calculus variables from constants by having 
some convention for their names. 
For Instance. we could say that variable names always 
begin with one of the letters ·x'. 'y'. and 'z'. 
In fact, In the program we will not need to 
know about this convention because variables are always introduced by quantifiers and hence 
are easy to detect. Only in reading the program's output will It be important for the programmer 
to remember which names were Predicate Calculus variables and which were constants. 
First. we will need the following operator declarations for the connectives: 
?- ope 30, fx, - ) . 
?- op(lOO,xfy,#). 
?- op(lOO,xfy,&). 
?- op(150,xfy,-». 
?- ope 150,xfy, (-». 
It is Important to note how we have defined these. 
In particular. -
has a lower precedence 
than " and &. 
To start with. we must make an Important assumption. 
The assumption Is 
that the variables have been renamed as necessary. so that the same variable Is never 
Introduced by more than one quantifier In the formula at hand. 
This is to prevent accidental 

241 
name clashes In what follows. 
The actual programming technique we use to Implement the conversion to clausal form 
Is tree transformation. as discussed In Sections 7.11 and 7.12. 
By representing the logical 
connectives as functors. Predicate Calculus formulae become structures that can be depicted 
as trees. 
Each of the six main stages of conversion Into clausal form Is a tree transformation 
that maps an input tree onto an output tree. 
Stage 1 = Removing Implications 
We define a predicate iaplout: such that iaplout:(X, Y) means that Y is the formula 
derived from X by removing implications. 
implout«P <-> Q).«PI & Ql) # (-PI & -Ql») 1- I, 
implout(P.Pl), implout(Q,Ql). 
implout«P -> Q),(-Pl # Ql» 
,- I, 
implout(P,Pl), implout(Q,Ql). 
implout(all(X,P),all(X,Pl.» ,- I, 
implout( P, PI). 
implout(exists(X,P),exists(X,Pl» 
1- I, 
implout( P ,PI) • 
implout« P & Q), (Pl. & Ql.» ,- I, 
implout(P,Pl.), implout(Q,Ql.). 
implout«P # Q), (Pl. # Ql.» ,- I, 
implout(P,Pl), implout(Q,Ql.). 
implout( (-P), (-PI» ,- I, 
implout(P,Pl) . 
implout(P,P). 
Stage g = Moving Negation Inwards 
We need to define two predicates here -- negin and neg. negin(X,Y) means that Y 
is the formula derived by applying the 'negatlon inwards' transformation to the whole of X. 
This is the main thing we will ask questions about. neg(x, Y) means that Y Is the formula 
derived by applying the transformation to the formula "X. 
With both of these. we assume 
that stage 1 has been carried out. and that we hence do not need to deal with -) and <-). 
negin«-P),Pl) ,- I, neg(P,Pl). 
negin(all(X,P),all(X,Pl.» ,- I, negin(P,PI). 
negin(exists(X,P),exists(X,Pl.» ,- I, negin(P,PI). 
negin«P & Q)i(Pl. & Ql.» 
,- I, negin(P,Pl.), negin(Q,Ql.). 
negin«P # Q),(PI # Ql.» 
,- I, negin(P,Pl.), negin(Q,Ql.). 
negin(P ,P). 
neg«-p),pl.) ,- I, negin(P,PI). 
neg(all(X,P),exists(X,Pl.» ,- I, neg(P,Pl.). 
neg( exists( X, P), al.l( X, Pl.» ,- I, neg( P, Pl.) • 
neg«p & Q),(Pl. # Ql.» 
1- I, neg(P,Pl.), neg(Q,Ql.). 
neg«P # Q),(PI & Ql.» 
,- I, neg(P,Pl.), neg(Q,Ql.). 
ned( P, (-P». 

242 
Stage ~ -
Skolemlslng 
The predicate sJtol_ has three arguments: 
corresponding to the original formula. the 
transformed formula and the list of variables that have been Introduced so far by universal 
quantifiers. 
skolem(all(X,P),all(X,P1),Vars) :- I, skolem(P,P1,[XIVars]). 
skolem(exists(X,P),P2,Vars) :- I, 
gensym( f,F), Sk= .• [Flvars], 
subst(X,Sk,P,P1), 
sko1em(P1,P2,Vars). 
skolem« P # Q), (P1 # Q1), vars) : -
I, 
skolem(P,P1,Vars), skolem(Q,Q1,Vars). 
skolem« P & Q), (P1 & Q1), Vars) : -
I, 
sko1em(P,P1,Vars), skolem(Q,Q1,VarS). 
skolem(P ,P ,_). 
This definition makes use of two new predicates. gensym must be defined such that the goal 
gensym(x, Y) causes Y to be Instantiated to a new atom built up from the atom X and a number. 
This is used to generate Skolem constants that have not been used before. 
As an example. 
we would expect the question 
?- gensym( f,F). 
to yield the answer F - n 
the first time we ask It. F -
f2 the second time. and so on. 
The predicate gensya Is defined In Section 7.S. 
The second new predicate that Is mentioned 
Is subst. 
We require subst(Vl.,V2,F1,F2) to be true if the result of substituting V2 for Vl 
every time It appears In the formula Fl Is F2. 
The definition of this Is left as an exercise 
for the reader. but It Is similar to predicates defined In Sections 7.S and 6.S. 
Stage .1 -
Moving Universal Quantifiers Outwards 
After this point. of course. it will be necessary to be able to tell which Prolog atoms 
represent Predicate Calculus variables and which represent Predicate Calculus constants. 
We 
will no longer have the convenient rule that the variables are precisely those symbols Introduced 
by quantifiers. 
Here Is the program for moving out and removing the universal quantifiers: 
univout(all(X,P),P1) :- I, univout(P,P1). 
univout«P & Q),(P1 & Q1» :- I, 
univout(P,P1), univout(Q,Q1). 
univout«P # Q),(P1 It Q1» :- I, 
univout(P,P1), univout(Q,Q1). 
univout(P ,P). 
These rules define the predicate univout so that univout(X, Y) means that the version of 

243 
X with universal quantifiers moved out is Y. 
It should be noted that our definition of univout assumes that this operation will only 
be applied after the first three stages are already complete. 
Hence it makes no allowance 
for Implications or exi,stential quantifiers in the formula. 
Stage ~ = Distributing I 
over I 
The actual program to put a formula Into conjunctive normal form is rather more 
complicated than the last one. 
When it comes across something like (P It Q), where P and 
o are any formulae. it must first of all put P and 0 into conjunctive normal forms. P1 and 
01 say. and only then look to see if the formula as a whole is suitable for translation by 
one of the equivalences. 
The process must happen in this order. because it may happen 
that neither of P and 0 has & at the top level. but one of P1 and 01 does. 
Here Is the 
program: 
conjn«P # Q),R) :- I, 
conjn{P,P1), conjn{Q,Q1), 
conjn1{{P1 # Q1),R). 
conjn«P & Q),{P1 & Q1» :- I, 
conjn{P,P1), conjn{Q,Q1). 
conjn(P,P). 
conjn1{«P & Q) # R),{P1 & Q1» :- I, 
conjn{{p # Q),P1), conjn{{Q # R),Q1). 
conjn1«P # (Q & R»,{P1 & Q1» :- I, 
conjn«P # Q),P1), conjn«P # R),Q1). 
conjn1{P,P). 
Here. now. is the last part of our program to put a formula in clausal form. 
We define 
first of all the predicate cl.ausify, which involves building up an internal representation of 
a collection of clauses. 
The collection is represented as a list. where each clause is 
represented as a structure cl.(A,B). 
In such a structure. A is the list of literals that are 
not negated. and B is the list of literals that are negated (but without their· 's l. cl.ausify 
has three arguments. 
The first is for the formula. as delivered by stage S. 
The second 
and third are for defining the list of clauses. cl.ausify builds a list terminating in a variable. 
instead of [], and returns this variable through the third argument. 
It is then possible for 
other rules to add things to the end of the list by instantiating the variable. 
One feature 
built into the program checks that the same atomic formula does not appear both negated 
and unnegated within the same clause. 
If this happens. the ciause is not added to the list. 
because such a clause is trivially true and contributes nothing. 
Also. it is checked that the 

244 
same literal does not appear twice within a clause. 
claus1fy«P & Q),Cl.,C2) ,- I, 
claus1fy(p,Cl.,C3), cl.ausify(Q,C3,C2). 
claus1fy(p,[cl.(A,B)ICs],Cs) ,- inclause(p,A,[],B,[]), I. 
clausify(_,C,C) • 
incl.ause«p • Q),A,AJ.,B,Bl.) ,- I, 
incl.auSe(P,A2,AJ.,B2,Bl.), incl.ause(Q,A,A2,B,B2). 
inclause« ·P),A,A,Bl.,B) ,- I, 
natin(P,A), putin(P,B,Bl.). 
inclause(p,AJ.,A,B,B) 1-
not1n(P ,B), putin(P ,A,AJ.). 
notin(X, [XI_]) ,- I, fail. 
notin(X,[_IL]) ,- I, natin(X,L). 
natin(X,[]). 
putin(X, [], [X]) :- I. 
putin(X, [XIL] ,L) :- I. 
putin(X,[YIL],[YILJ.]) :- putin(X,L,LJ.). 
In the previous section. we defined a predicate clausify which built up a representation 
for a Predicate Calculus formula in clausal form. 
We will now define a predicate pclauses 
which causes a formula represented in this way to be displayed according to our notation. 
pclauses([]) :- I, nl, nl. 
pclauses([cl(A,B)ICs]) ,- pclause(A,B), nl, pclauses(cs). 
pclause(L,[]) 1- I, pdisj(L), write('.'). 
pclause([],L) ,- I, write(',- '), pconj(L), write('.'). 
pclause(LJ.,L2) ,- pdisj(LJ.), write(' ,- '), pconj(L2), write('.'). 
pd1sj([L]) 1- I, write(L). 
pdisj([LILs]) :- write(L), write('; '), pd1sj(Ls). 
pconj([L]) :- I, write(L). 
pconj([LILS]) ,- write(L), wr1te(', '), pconj(Ls). 

245 
The ASCII Code 
The following chart associates each printing character with the small Integer that Is used to 
represent the character In Prolog strings and for InpuVoutput predicates. 
For non-printing 
characters, only those characters that have an effect on the Prolog system are listed. 
Most 
non-printing characters are typed by holding down the CONTROL key and striking an appropriate 
key. 
The host operating system may assign special Interpretations to some control characters 
for the purpose of editing Input from computer terminals. 
For example, DEL Is sometimes 
used to erase the last character typed, Control-u might be used to delete lines of Input. and 
so forth. 
These are not listed here, as they depend on a particular computer Installation. 
Non-Printing Characters 
A Prolog system may require two non-printing characters to be typed by the user. The Interrupt 
character Is used to cause a running program to be Interrupted temporarily for debugging 
purposes. 
The end-of-file character Is used to denote the end of 
the file user (Chapter 
5). The normal assignments are shown below, although these may be changed to suit Individual 
computer Installations. 
ASCII code 
How Typed 
Effect 
-----
-----
3 
Control c 
Prolog temporarily stops the current 
program, and requests an action to be 
performed. 
26 
Control z 
Marks the end of the 'user' file 

246 
ASCII Code Character 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48-57 
58 
59 
60 
61 
62 
63 
64 
65-90 
91 
92 
93 
94 
95 
96 
97-122 
123 
124 
125 
126 
# 
$ 
'" 
& 
( 
) 
" 
+ 
/ 
0-9 
? 
@ 
A-Z 
[ 
\ 
] 
a-z 
Printing Characters 
Description 
exc1amation mark. the "cut" symbo1 
doub1e quote. 
delimits strings 
sharp sign 
currency symbol 
percent 
ampersand 
single quote. 
delimits arbitrary atoms 
round bracket. 
for grouping and structures 
closing round bracket 
asterisk. 
denotes multiplication in 'is' goals 
plus. 
denotes addition in 'is' goals 
comma. denotes conjunction of goals, and 
separates arguments 
hyphen. 
denotes subtraction in 'is' goals 
dot. 
ends clauses, denotes list constructor functor 
stroke. 
denotes division in 'is' goals 
digits 0 through 9 
colon 
semicolon. 
denotes disjunction of goals 
less than. integer "less than" in 'is' goals 
equals. denotes equality predicate 
greater than. 
integer "greater than" in 'is' goals 
question mark 
'at' sign 
upper-case A through Z 
square bracket. 
denotes list construction 
backs lash 
closing square bracket 
caret (or up-arrow) 
underscore. denotes anonymous variable 
accent 
lower-case a through z 
curly bracket. 
used in Grammar Rule notation 
vertical bar. 
used in list notation 
closing curly bracket 
tilde 

247 
~;XD 
Different Versions of Prolog 
Prolog Is by now available In many different versions In many different places. 
The 
differences that exist are due partly to the different kinds of computers available at the various 
computer Installations. 
No two kinds of computer make It equally easy to write all kinds of 
programs. and this Is reflected In the facilities that the various Prolog Implementors have got 
around to providing. 
Even if two Installations have the same kind of computer. they may stili 
run different operating systems on them. 
The operating system Is the program In overall 
control of the computer. with tasks such as ensuring that the available resources are divided 
fairly between the different people who want to use the computer. 
Some operating systems 
allow the programmer to use a wide range of the facilities supported by the computer. whereas 
others are more restrictive. 
This leads again to differences between Prolog systems. 
Finally. 
the people who actually construct Prolog systems often have differing Ideas about what features 
are aesthetically pleasing and what facilities are most needed. 
As a result. no two Prolog 
systems are completely alike. 
This situation Is unlikely to change very quickly. because new 
Ideas and Improvements for Prolog Implementation are constantly being thought up. 
In this book. we have presented a version of Prolog that does not correspond exactly 
to any existing system. 
Rather. It Is supposed to represent a 'core" Prolog that will have 
a lot In common with any system you might encounter. 
If you have mastered the Ideas of 
this book. you should not have too much difficulty adapting to any Prolog system that comes 
along. 
The syntax and some of the built-In predicates may be confusingly different. but 
underneath will be the same basic Prolog that has been described here. 
The best way to get to know about your own Prolog system is to read the user's manual 
that Is provided with It. 
This may well be somewhat terse and summary. but If you have 
a basic grounding In the language. It should not be too hard to work out how the system 
differs from what you know. 
This appendix mentions a few points that are worth looking out 
for. and also goes Into more detail about two particular Prolog systems that are fairly 
widespread. 
However. we would like to emphasise the fact that many of the current Prolog 
systems are slowly changing. and there Is really no substitute for looking at an up-to-date 
manual for your Installation. 

248 
General PoInts to LDok Out For 
Here are some of the things that are most likely to differ between Prolog Implementations. 
1. 
Syntax. 
Everybody has his own Idea about what forms of syntax are most natural and 
pleasing. 
Fortunately. the syntax of Prolog Is quite simple. and so there Is not much 
scope for variation. 
One matter of dispute Is how one should distinguish variables 
from atoms. 
Here we bave used names beginning with capital letters for variables 
and names beginning with small letters for atoms. 
In addition. we have allowed atoms 
consisting of sequences of symbols like ••••• ,' and '='. 
Some Prolog systems have 
adopted the reverse convention .as regards capital and small letters (variables begin 
with small letters). 
Others distinguish variable names by starting them with a special 
Character. like '_PERSON' or ··PERSON·. 
This Is convenient for a system that does 
not distinguish between capital and small letters. 
Another area where there Is- scope 
for variation Is In the notation for clauses -- how Is the head separated from the 
body. and how are the goals In the body separated? 
Also. how are questions 
distinguished? 
It may just be a matter of some other symbols Instead of ':-'. ..' and 
'?-'. 
Or It may be more complicated. 
In one early system. the head and the goals 
of a clause were placed one after another. with a '+' In front of the head and a 
'-' In front of each of the goals. 
In summary. you may find clauses that look like 
any of the following. or are different again: 
uncle(X,Z) :- parent(X,Y), brother(Y.Z). 
Uncle(x,z) <- Parent(x,y) & Brother(y,z). 
+UNCLE(*X,*Z) -PARENT(*X,*Y) -B~*Y,*Z). 
( (UNCLE Xl X3) (PARENT Xl X2) (BRO'l'BER X2 X3» 
uncle(X,Z). parent(X,y), brother(Y,Z). 
2. 
Arbitrary bounds on some numbers. 
Because of the way different computers organise 
their storage. It may be difficult for the Prolog Implementor to allow certain things 
to grow to unlimited size. 
Some things that are liable to vary from computer to 
computer are the maximum size of Prolog Integers. whether floating-point numbers 
are available. the maximum number of arguments that a functor can have. the maximum 
number of characters In an atom. the maximum number of clauses a predicate can 
have. and so on. 
3. 
Environmental features. 
Because of the differences between different operating systems. 
some Prolog systems may allow you to Interrupt your program while it is running. 
edit a disc file without losing the current state of your Prolog session. maintain several 

249 
simultaneously running Prolog programs. receive Input from or send output to special 
devices. 
However. none of these can necessarily be provided In all systems. and 
so you can expect to find some variation here. As well as determining which of these 
facilities are available. the operating system of your computer will most likely attach 
special Importance to certain characters that you type In. 
For Instance. the character 
that you type to mark an "end of file" at the end of a ooIl8U1t:(uaer) will vary between 
Installations. 
Other characters may be Interpreted as requests for Information about 
the status of the machine or as requests to change characters already typed. 
Such 
features are not part of the Prolog system that you use. but are nevertheless Important 
when you decide to actually use the system. 
4. 
The option of compilation. 
Most Prolog systems work by storing your clauses In a 
form that Is close to the original textual form. When a ciause Is used. such a system 
has to Inspect the clause and decide what to do according to what form It has. 
Such a system Is called an Interpreter. Another possibility Is for the system to translate 
from your clauses Into -Instructions that can be directly executed by the machine. 
Such a system Is called a complier. 
Using a complier. you have the advantage that 
your program Is run directly. rather than having to go through an Interpretation process. 
Hence you might expect your program to run ·qulcker. 
On the other hand. since the 
textual form Is normally no longer available with a complier. you might expect not 
to have the same Information available when you are debugging (for Instance. you 
may not be able to ask for a listing of your clauses). 
In some systems. you may 
have the choice between compiling and Interpreting your clauses. 
In this case. you 
must carefully weigh up what advantages each has to offer. 
5. 
Particular built-In predicates. 
Whereas the basic flow of control may work Just the 
same In most Prolog systems. the special built-In predicates will almost always differ. 
Sometimes It will simply be that extra predicates are provided for facilities that are 
easy to provide on a particular computer (as In point 3). 
Sometimes the same basic 
facilities may be provided by predicates that have slightly different effects. For Instance. 
It would be sufficient for a Prolog system to provide either functor and IlJ:9 or - ••• 
This Is because the first two can be defined In terms of the last one and vice versa. 
You may have to work out how to use the facilities provided to mimic those that you 
are used to working with. 
Some Prolog systems may provide libraries of useful 
programs. providing optional facilities In addition to the built-In predicates. 
For 
Instance. grammar rules may be provided as part of the basic system. or It may be 
possible to load In a Prolog program from a library that will provide these facilities. 
6. Debugging facilities. It Is stili a matter for research to determine what debugging facilities 
are most suitable for Prolog. Meanwhile different systems present different conceptions 
of what features are needed. 
It Is hoped that our general Introduction of Chapter 
8 will equip the reader to cope with whatever he finds. 

250 
AJ1lIendix E 
The DECsystem-l0 Prolog system 
In this appendix, we describe briefly the Prolog system implemented for the DECsystem-10 
machine by Warren, Pereira and Pereira. 
We will mention only the points where there are 
significant differences from the "core" Prolog we have presented. 
The version discussed is 
Version 3 -- other versions will, of course, differ in various ways. 
We first show what a 
session with DECsystem-10 Prolog looks like, and then go into more detail about how this 
system differs from our ·core" Prolog. 
Example Session 
Here Is what an example programming session with DECsystem-10 Prolog is like. 
In 
this exam pie, we show exactly what appears on the terminal in the session. 
We also make 
various extra comments about what Is happening. 
Here Is the example session: 
We start at the monitor level of the TOPS-10 operating system. and we ask it to run Prolog . 
. r prolog 
Prolog-l0 version 3.3 
copyright (C) 1981 by D. 
Warren, F. 
Pereira and L. 
Byrd 
I ?- likes(X,Y). 
no 
The header information is. of course. liable to change slightly between different versions of 
the system. 
The characters "j 7-
• were printed by Prolog as a ·prompt". 
This tells us 
that it expects a question at this point. 
We have asked a question. and the answer was "no·. 
Not surprising. since there are no facts in the database yet. 
Now we assume that there 
Is a file ·test.pl'. and we consult it: 
I ?- [·test.pl']. 
test.pl consulted 
58 words 
0.01 sec. 
yes 
To make Prolog read In clauses from a file. we give it a question consisting of the file name 

251 
(as a Prolog atom) In list brackets. 
Here we have a file of clauses about people liking one 
another. 
I 1- 1ikes( john,bertrand). 
no 
I 1- 1ikes(john,albert). 
no 
Just asking a few questions about who likes whom. 
Prolog cannot satisfy any of these. 
I 1- 1isting(1ikes). 
1ikes(john,a1fred). 
1ikes(a1fred, john). 
1ikes(bertrand, john). 
1ikes( david ,bertrand ). 
1ikes(john,_1) ,-
1ikes(_1,bertrand) • 
yes 
To find out what clauses we have for a predicate. we ask a question about the special built-In 
predicate l.isting. 
This particular question causes Prolog to print out all our clauses for 
1ikes. 
Note that Prolog writes out unlnstantlated variables as an underline followed by a 
number. 
The clause at the end of the database was written In the file as: llkes( john,X) 
,- 11kes(X,bertrand). 
I 1- 1ikes(john,X). 
X a a1fred I 
x - david I 
no 
Here we have asked for alternative solutions to the question. by typing ,., and 'return'. 
There 
were two possible solutions. and then PrOlog could find no more. 
I 1- 1ikes(X,Y). 
x = john, 
Y - a1fred I 
x - a1fred, 
Y - john I 
x - bertrand, 
Y -
john I 
x - david, 
Y - bertrand 
x - john, 

252 
Y - david I 
no 
This time. each solution Involves seeing what two variables are Instantiated to. 
Again. we 
ask for alternatives by typing ';' and 'return' until there are no more solutions. 
I 1- [user]. 
Now we ask Prolog to read In clauses from the special file user. 
This causes clauses to 
be read In from the terminal. 
These clauses will be added at the end of the database. 
When It Is reading clauses (rather than questions). Prolog prompts with ": " rather than "I 
7- ". 
I likes( timothy ,bertrand). 
I 
user consulted 
10 words 
yes 
0.03 sec. 
We told Prolog to stop reading clauses after the first one by typing 'Z (control-and-z) at 
that point. 
We could have typed In several facts and rules before typing ·Z. 
Now Prolog 
has finished with that question and Is expecting another question again. 
I 1- likes(john,X). 
x - alfred I 
x - david I 
x - timothy I 
no 
Again. we ask for alternatives. 
Note that the new clause has lead to a new solution that 
was not present when we asked this question before. 
I 1- likes(bertrand,Y). 
Y -
john 
yes 
This Just Illustrates the other way we can deal with alternatives. 
Here. we Just typed 'return' 
after the first answer. 
This causes the question to succeed. and Prolog Is now waiting for 
another question again. 
I 1- core 
heap 
global 
local 
36864 (7680 lo-seg + 29184 hi-seg) 
2560 -
1573 in use + 
987 free 
1177 -
16 in use + 
1161 free 
1024 -
16 in use + 
1008 free 

253 
trail 
511 -
o in use + 
511 free 
Q.36 sec. runtime 
In response to the last ": ?- ". we typed ·Z <control-and-Z>. to Indicate that we were finished. 
Prolog printed out some statistical information. and now we are back with the TOPS-10 monitor. 
A complete record of this session has been recorded on the file 'prolog.log' in your main 
directory. 
The syntax of DECsystem-10 Prolog is essentially as we have described. 
In fact. it is 
slightly less restrictive about valid atoms and variables than the rules we have given. . Every 
example in this book should be valid according to DECsystem-10 Prolog syntax. 
One important 
point should be made about operators with high precedences. Because ': Is itself an operator. 
it is stipulated that to avoid ambiguity all terms written with operators with the same or higher 
precedence must be enclosed in brackets. 
This ensures that. for instance. 
foo(a,b,c) 
can only be interpreted as a structure with functor foo of three arguments. and not as. for 
Instance. something equivalent to 
foo(a,', '(b,c» 
or 
foo(', '(a,', '(b,c») 
if we wanted to write this last term. we could do It with 
foo«a,b,c» 
The rule about operators of high precedence only affects a few operators like ':-' and 
It does mean that something like: 
?- retract(parent(A,B) ,- father(A,B». 
is syntactically Incorrect in DECsystem-10 Prolog. 
We need to supply an extra pair of brackets 
to make It legal. 
DECsystem-10 Prolog provides an alternative syntax. In case you are using a terminal 
or an operating system that does not provide small letters as well as capital letters. 
In this 
syntax. variables are distinguished from atoms by starting with the character '_'. 
A built-In 
predicate 'NOLC' Is provided to cause Prolog to start using these alternative conventions. 

254 
The predicate 'LC' enables you to switch back to the normal rules. 
Finally, a small point. 
The functor ',' (with two arguments) Is not predefined as an 
operator In DECsystem-10 Prolog. You can define It yourself if you wish, but this Is unnecessary 
If you always use the special list notation for lists. 
Arbitrary Bounds 
DECsystem-10 Prolog does not provide many arbitrary bounds that you are likely to 
encounter in practice. 
Operator precedences must be between 1 and 1200. 
Prolog Integers 
must be In the range -131072 to 131071, although the evaluation of integer expressions is 
able to deal with Intermediate results that are larger than this. Real numbers are not provided. 
Environmental Features 
DECsystem-10 Prolog provides the very useful facility of loggIng. 
In the normal case, 
during a Prolog session. the system makes a copy of (most 00 what appears on your computer 
terminal In a disc file cailed 'prolog.log'. 
After you have finished, you can look at this file 
and see exactly what happened In the session. 
The 'prolog.log' file provides a useful record 
of what your program did when and what changes you made In the course of running It. 
Built-In predicates are provided for turning the logging facility on and off, In case you do 
not want It to operate all the time. 
It Is possible to Interrupt a running program In DECsystem-10 Prolog by typing the 
character 'C (control-and-C). 
The system prompts you for an action to be performed. 
The 
options Include 'break'. 'continue' (carryon with the program). 'exit' (from Prolog>' 'trace' 
and 'notrace'. 
The last two options Involve continuing with the program after the amount 
of tracing has been altered. 
The 'break' option suspends the execution of your current 
program. and gives you a new ·copy· of the Prolog system to Interact with. 
When you exit 
the 'break'. your program will continue running. 
The Dec System-10 'end of file' character is 'Z (control-and-Z>. 
Typing this causes 
an exit from Prolog. the end of a 'break' or the end Of a 'consult'. according to what situation 
you are in. 
The built-in predicate read matches its argument with the atom encLo:(..fil.e 
If it encounters an end of file. 
DECsystem-10 Prolog provides various facilities to help you save time reading In your 
programs again and again. 
It Is possible to store the ·state· of the Prolog system. including 
its current database. In a disc file In such a way that the state can be ·restored" much faster 
than It would take to read in the program and get it to the same state. 
Also. DECsystem-10 
Prolog will automatically read any· Input you may have in a file 'prolog.ini' at the beginning 

255 
of a session before taking input from the terminal. 
If an error occurs when you are running DECsystem-10 Prolog, the system prints out 
a message to tell you what has gone wrong. 
Most kinds of error will then cause a simple 
failure of the goals that caused them, and 50 your program will carryon running. 
Some 
errors are, however, more serious, and the system will abandon all currently running programs 
and ask you for the next question. 
Compilation 
DECsystem-10 Prolog provides the option of selectively compiling some of your clauses. 
This can increase space and time efficiency considerably. 
A built-In predicate provides a 
facility like consu1t, except that the clauses of the file are compiled, not Interpreted. 
Efficiency 
of compiled cia uses can be increased by the use of mode declarations, which allow you to 
specify how the clauses will be used On terms of which arguments will be instantiated at which 
times). 
There are some restrictions on which clauses are suitable for compilation. 
It is also 
necessary to make certain other declarations to the system in order that it can properly function 
with a mixture of complied and Interpreted clauses. 
Differences !D. built-in predicates 
DECsystem-10 Prolog provides all the built-In predicates we have discussed, and will 
also deal correctly with grammar rules encountered inside a normal consu1t. 
Here are some 
of the differences from the descriptions we have given: 
The predicate disp1ay. 
The effect of this predicate is always to print its argument on 
the terminal. not to the current output as we described. 
In our description of arithmetic expressions, we stated that an arithmetic expression Is only 
"evaluated" when it appears as the second argument of is. In all other circumstances, 
a structure like '2+3' just stands for itself. 
This is not the case in DECsystem-10 
Prolog, where various other predicates also "evaluate" integer expressions appearing 
as arguments. 
predicate put. 
Examples of this are the relational operators <, -<, etc. and the 
Hence the following sequence will work in DECsystem-10 Prolog, but 
produce an error or a failure In our "core" Prolog: 
1- 2+4 < 12*(2+B), 
yes 
As an extra twist a structure which is a list consisting of a single number is considered 
to be an arithmetic expression with the same value as the number. 
Hence in 

256 
OECsystem-10 Prolog: 
?- X is [25}. 
X -
25 
yes 
Because of this combination of features. the output of single characters can be 
specified In a mnemonic way. for Instance: 
?- put("a"), put("b"). 
ah 
yes 
(remember that "a" Is the list consisting solely of the character code for the first 
letter of the alphabet In Its lower case form). 
Syntax of negation. 
There Is no predicate named not, but the prefix operator \+ Is used 
Instead. 
There Is no "not equals" predicate \- • 
Variables as goals. 
This Is really a matter of syntax. rather than anything else. 
We have 
seen how It Is possible to Invoke the goal corresponding to what a Prolog variable 
stands for by using the predicate ca1l.. 
OECsystem-10 Prolog provides an alternatlye 
way of doing the same thing. 
Instead of putting a goal like 
••• , oa11(X), ••. 
In a clause. It Is possible to just put the variable on Its own as a goal: 
... , x, ... 
It Is stili possible to use the call. version. and Indeed the system converts any goal 
X to a goal call.(%) when It uses asserta or assertz on a clause. 
Arguments to E8tract:. 
In OECsystem-10 Prolog. because of difficulties aSSOCiated with 
variables as goals. there are some differences about how bodies of clauses must be 
specified In goals for E8tract:. 
The problem Is that when we ask: 
?- retraot«mother(A,B) ,- C». 
we might be asking Prolog to remove a clause specifically like: 
mother(A,B) ,- c. 
with a variable as a goal In the body. or we might be asking It to remove a clause 

257 
for .ather with any body, like for Instance: 
mother(X,Y) ,- parent(X,Y), female(Y). 
To remove the possibility of ambiguity In these cases, DECsystem-10 Prolog always 
starts by replacing unlnstantlated variables standing for single or multiple goals In 
retract: arguments by structures using call.. 
So the question: 
?- retract«mother(A,B):-C». 
Is actually treated like: 
?- retract«mother(A,B).-call(C»). 
If we wanted to remove the first clause for .ather regardless of Its body, we could 
specify Instead: 
?- clause(mother(A,B),C), retract«mother(A,B):-C». 
In this case, the previous clause goal results In C becoming sufficiently Instantiated 
to escape the transformation. 
Extra built-In predicates 
As well as the built-In predicates we have described, DECsystem-10 Prolog provides a 
multitude of other facilities, Including: 
A "conditional" form. 
It Is possible to provide goals that look like the following: 
... , (likes(john,X) -> wooden(X); plastic(X», .•. 
The Idea of such a complex goal Is that If the "condition" before the -> succeeds 
then the goal after the -> Is Invoked: otherwise the third goal Is Invoked. 
Any of 
the goals can themselves be Prolog goals. 
The conditional works exactly as If It were 
defined In DECsystem-10 Prolog as follows: 
?- op(1050,xfy,-». 
?- op(llOO,xfy, ';'). 
(X -> Y; 
(X -> Y; 
Z) :- call(X), I, call(Y). 
Z) : - call( Z ) • 
An "Indexed" database. 
This allows you to "associate" Information In the database with 
particular values. rather than having to use the standard Prolog retrieval mechanisms. 

258 
For instance. if you wanted to store information about the ages of hundreds of people. 
the standard technique would be to have hundreds of clauses for a predicate like age. 
But then when you wanted to find out a particular person's age. Prolog would have 
to searCh through ali of these until it found the right one. 
The trouble is that 
information is normally aSSOCiated with predicates. and so there can be a lot of search 
when a predicate has many clauses. 
The indexed database would allow you to 
aSSOCiate information in a more direct way with particular names. 
The ability to access ancestors. 
We discussed the notion of ancestor goals In the chapter 
on debugging. 
DECsystem-10 Prolog provides built-In predicates that allow you to 
access ancestors from within a· Prolog program. 
Statistical information. 
DECsystem-10 Prolog provides built-in predicates that enable you 
to find out how fast your program is running and how much space it occupies. 
Debugging Facilities 
DECsystem-10 Prolog provides debugging facilities along the lines we have described. 
In addition to the built-in predicates mentioned. there is a predicate that enables you to affect 
which ports are leashed during tracing. 
References 
User's Guide to DECsystem-10 Prolog. by L M Pereira. F Pereira. and D Warren. 1979. 
Laboratorlo Nacional de Engenharia Civil. Lisbon. Portugal. 
Aiso available as DAJ Occa81.:maJ Paper 15. Department of Artificial Intelligence. University of 
Edinburgh. Edinburgh. Scotland. 
A Guide to Version 3 of DEC-10 Prolog and Prolog Debugging Facilities. by L Byrd. F Pereira. 
and D Warren. 1980. 
DAI Occa81onal Paper 19. Department of Artificial Intelligence. University 
of Edinburgh. Edinburgh. Scotland. 

259 
The PDP-~~ UNIX Pro~og System 
We will now describe some of the features of the Prolog system developed for the DEC PDP-ll 
machine (running under the UNIX operating system) by C. 
Mellish. 
Our description applies 
to version NUl. 
We first of all show what a session with UNIX Prolog looks like, before going 
into details about how the system differs from our "core" Prolog. 
Example Session 
Here is what an example programming session with UNIX Prolog Is like. 
In this example. 
we show exactly what appears on the terminal in the session. We start by typing to the ·Shell". 
We ask the system to run Proiog. 
'Is prolog 
PROLOG Version NU7.~ 
1- likes(X,Y). 
no 
The characters "7-
" were printed by Prolog as a "prompt". 
This tells us that it expects 
a question at this point. 
We have asked a question. and the answer was "no". 
Not surprising. 
since there are no facts In the database yet. 
We assume that the file '/us/qrls/test' appears 
in the fllesystem, and we consult It: 
1- ['/us/qris/test']. 
/us/qris/test consulted 
yes 
To make Prolog read In clauses from a file. we give it a question consisting of the file name 
(as a Prolog atom) In list brackets. 
Here we have a file of clauses about people liking one 
another. 
?- likes(john,bertrand). 
no 

260 
1- likes(john,albert). 
no 
Just asking a few questions about who likes whom. 
Prolog cannot satisfy any of these. 
?- listing(likes). 
likes(john,alfred). 
likes(alfred,john). 
likes(bertrand,john). 
likes(david,bertrand). 
l.ikes( john,_45) 
likes(_45,bertrand). 
yes 
To find out what clauses we have for a predicate. we ask a question about the special built-In 
predicate listing. 
This particular question causes Prolog' to print out all our clauses for 
likes. 
Note that Prolog writes out unlnstantlated variables as an underline followed by a 
number. 
The clause at the end of the database was written in the file as: 1ilces( john,X) 
,- likes(X,bertrand). 
?- likes(john,X). 
** (top) PROVED 
likes(john,alfred)? I 
*w (top) PROVED 
likes(john,david)?; 
no 
Here we have asked for alternative solutions to the question. by typing '.' and 'return'. 
There 
were two possible solutions. and then Prolog could find no more. 
?- likes( x, Y) . 
** (top) PROVED 
likes(john,alfred) ? 
** (top) PROVED 
likes(alfred,john) ? 
** (top) PROVED 
likes(bertrand,john) ? 
** (top) PROVED 
likes(david,bertrand) ? 
; 
** (top) PROVED 
likes(john,david) ? ; 
no 

261 
This time, each solution Involves seeing what two variables are Instantiated to. 
Again, we 
ask tor alternatives by typing ';' and 'return' until there are no more solutions. 
?- [user]. 
Now we ask Prolog to read In clauses from the special file user. 
This causes clauses to 
be read In from the terminal. 
These clauses will be added at the end of the database. 
When It Is reading clauses (rather than questions). Prolog dispenses with the "1- " prompt. 
likes(timothy,bertrand). 
user consulted 
yes 
We told Prolog to stop reading clauses after the first one by typing the UNIX end-ot-flle 
character. which Is ·Z (control-and-z) for most UNIX versions. We could have typed In several 
facts and rules before typing the end-of-flle character. 
Now Prolog has finished with that 
question and Is expecting another question again. 
1- likes(john,X). 
** (top) PROVED I likes(john,alfred) ? I 
** (top) PROVED I likes(john,david) 1 I 
** (top) PROVED I likes(john,timothy) 1 I 
no 
Again, we ask for alternatives. 
Note that the new clause has lead to a new solution that 
was not present when we asked this question before. 
1- likes(bertrand,Y). 
** (top) PROVED I likes(bertrand,john) ? 
yes 
This Just Illustrates the other way we can deal with alternatives. 
Here. we Just typed 'return' 
after the first answer. 
This causes the question to succeed, and Prolog Is now waiting tor 
another question again. 
?-
End of PROLOG execution 
In response to the last "1- " we typed the end-ot-tlle character (·Z tor most UNIXes) to 

262 
Indicate that we were finished. 
Now we are back with the 'shell" again. 
As In DeclO Prolog. the PDP-ll UNIX system Is slightly more flexible than the rules 
we have given about what are valid atoms and variables. 
Operator declarations In UNIX Prolog are somewhat restricted. 
Firstly. any atom can 
only be declared as an operator In one way. 
If multiple declarations are made. only the 
latest one has any effect. 
Secondly. the only permissible operator types are: 
fx, xf, yfx, xfy 
The rule for using these Is simple -
use &:: for a prefix operator. xf for a postfix operator. 
and either xfy or yfx for an Infix operator. according to whether It Is right or left associative. 
This Prolog system will actually allow certain syntactic forms that are theoretically Illegal. If 
they are unambiguous. 
For Instance. If not: are &:: operators. then 
not not a. 
Is unambiguously read as 
note note a». 
even though In theory It Is not possible for the argument of not: to be a term with the same 
precedence. 
Arbitrary Bounds 
The PDP-ll machine Is relatively restricted as regards the amount of memory that a 
program can access. 
As a result. the UNIX Prolog system has had to be very careful about 
how Information Is stored. 
There are many arbitrary bounds that arise because of this. 
The number of distinct atoms that a Prolog program can use Is restricted to 1024 In 
the UNIX system. 
Of these. some are already taken up by the system before your program 
Is read In. 
In practice. this limit seems to only affect programs that maintain large databases 
of facts. 
An atom can also have no more than 253 characters. 
A functor cannot have an 
arlty greater than 15. 
Prolog Integers are restricted to the range 0 to 16383. 
Arithmetic 
on these takes place modulo 16384. 
Operator precedences must be between 0 and 255. 
Finally. the system will only write terms to a 'depth' of 20. 
Subterms of the write 
argument that are deeper than this are simply written out as '-'. 
This helps you to avoid 
getting unmanageable amounts of Information If you accidentally ask Prolog to print out a 
rather large structure. The 'depth' of a subterm of the write argument Is computed as follows. 

263 
The "top level" of the argument -- either the argument itself (If it Is atomic) or the argument 
excluding its components (if it is a structure) -- has depth O. 
If the write argument is a 
structure. then the "top levels" of Its components have depth 1. 
The "top levels" of their 
components have depth 2. and so on. 
The only exception Is that the "top levels" of all the 
elements of a list have the same depth as the first one. 
Environmental 
The UNIX Prolog system allows you to interrupt a Prolog program while it is running. 
The appropriate character to type is the UNIX "interrupt" character. which is • C (control-and-C) 
in most versions. 
When you interrupt a program. you are offered the possibilities of 'abort', 
'break'. 'continue' (carryon with the program), 'exit' (from Prolog>' 'notrace' and 'trace'. 
These last two options involve continuing with the program after the tracing has been suitably 
aitered. 
The 'abort' option involves abandoning all running programs and going back to ask 
for the next question. 
The 'break' involves suspending the current program and giving you 
a new "copy" of the Prolog interpreter to interact with. When the 'break' is exited. your program 
continues running. 
The UNiX Prolog allows you to use various facilities provided by that operating system. 
These include the ability to set up several programs (not necessarily all Prolog programs) 
that run simultaneously and communicate through devices called "pipes". 
Also UNIX Prolog 
allows you to leave Prolog temporarily, interact with the operating system (to perhaps edit 
a disc file) and then resume exactly where you left off. 
If you have several Prolog programs 
running at once. the effect of the "interrupt" character will changed for all the programs except 
the one that you started with. 
When you type this character, all the programs except the 
first will Immediateiy abandon running any programs and revert to asking for the next question. 
The first one will prompt you for an option. as usual. 
An extra facility Is that If you type 
the UNIX "quit" character (possibly·' --
control-and-\) all your Prolog programs will 
Immediately finish and you will find yourself talking to the operating system ·shell" again. 
The character to type to Indicate "end of file" is the UNIX end-of-file character. which 
Is • Z (control-and-Z) for most versions of UNIX. 
This is the character you type to finish 
a consult(user), to exit from a break or to leave Prolog. 
However. whatever character marks 
an "end of file" as far as the operating system Is concerned. Prolog will always convert It 
to ASCII code 26 (.Z>. 
This means that your Prolog programs that need to detect "end of 
file" should look for 'Z in any case. The system Is also set up so that read finds the structure: 
1- end 
If an end of file Is encountered. 
There Is a slight complication In UNIX Prolog that arises from the fact that UNIX allows 
you to run programs that receive their primary input from and send their primary output to 

264 
things apart from your terminal. 
Thus. for Instance. you can run Prolog with clauses and 
questions already prepared In a disc file. or you can send all the output to a disc file. 
In UNIX Prolog. a distinction Is made between the special file user, which refers to the UNIX 
standard Input and output flies. whatever they are. and the special file tty, which always refers 
to your terminal. 
The "top level Interpreter" can tell whether user Is using your terminal for 
both input and output. 
If not. it Is slightly less "chatty" than It would otherwise be. 
When an error Is encountered In the UNIX Prolog system. first of all a message Is printed 
on your terminal to tell you what has happened. 
After that. one of three possible things 
can happen. 
If It Is a syntax error (the predicate read could not Interpret the Input properly). 
Prolog prints out the best It could make of the Input and then causes a fail. of the read 
goal. 
If this happens during a CODBul.t, or at the top level. Prolog just goes on to read 
what comes next. 
Most other errors cause a break to occur. 
If you exit from the break 
normally (by typing "end of file"). your program will behave as If the goal with the error just 
failed. 
As another option. you can. of course cause an abort. 
The final possibility. which 
only happens with a few kinds of errors. Is that an abort takes place Immediately. 
Compilation 
The PDP-ll UNIX Prolog system does not offer the possibility of compilation. 
It provides 
only a Prolog Interpreter. 
Particular Built-In Predicates 
The UNIX Prolog system does not provide grammar rules automatically. However. It allows 
you to load programs from a "Prolog library". which Includes a grammar rule package. 
Here 
are some other bits and pieces that are worth looking out for: 
The list notation for CODBul.t and recoDBUl.t. 
In this notation. you must precede a file 
name with '$' ( not '-') If you want to recoDBul.t It. 
Thus. for Instance. the following 
two goals are equivalent: 
?- [myfile,$fred,'ajfoo']. 
?- consult(myfile), reconsult(fred), consult('ajfoo'). 
A "backtrace" faCility. 
This facility enables you to look at the ancestors of the current 
goal. 
You can also use it when Inside a break after an error. 
It Is quite useful 
In such a situation. because It gives you some Idea of the context In which the error 
occurred. 
This facility Is provided by the built-In predicate : backtrace. 

265 
Debugging Facilities 
The UNIX Prolog system Is not as elegant at answering questions as we have suggested 
Prolog systems usually are. 
Instead of printing out the values of variables In a format as 
In: 
1- likes(X, Y). 
x - _251, Y - apples 
It prints out Instead the whole of the successful goal: 
1- likes(X, Y). 
** (top) PROVED : likes(_25l,apples) 
and then asks Is you are Interested In alternative solutions (In the normal way). 
What about other debugging facilities? In the UNIX Prolog system. there Is an exhaustive 
unleashed tracing facility and also the possibility of setting spypolnts. 
These two facilities 
are 
essentially Independent. 
Because the 
exhaustive 
tracing 
Is 
unleashed. 
you 
are 
recommended to use spypolnts extensively. 
In this way. you can avoid getting overwhelmed 
by the exhaustive tracing (by turning It on only at carefully selected places). 
You can also 
make better use of the options like 'retry' and 'skip' If you have lots of spypolnts (because 
you can only use them at spypolnts. 
References 
The Unix Prolog System. by W Clocksln and C Mellish. 1979. 
Software Report 5, Department 
of Artificial Intelligence. University of Edinburgh. Edinburgh. Scotland. 

266 
The LSI-11 RT-11 Prolog System 
We will now describe some of the features of the Prolog system developed for the DEC LSI-ll 
machine (running the RT-ll operating system) by R. Fisher. The system runs on the LSI-1l/23 
and any other LSI-ll with the EIS option Installed. 
Because this system was translated from 
the PDP-ll system of the last appendix. the two systems are very similar In most places. 
Our description applies to version NR7. 
We first of all show what a session with LSI-ll Prolog 
looks like. before going Into details about how the system differs from our "core" Prolog. 
Example Session 
Here Is what an example programming session with LSI-ll Prolog Is like. In this example. 
we show exactly what appears on the terminal In the session. We start by typing to the RT-ll 
monitor. 
We ask the system to run Prolog . 
. RU PROLOG 
PROLOG Version NR7.1 
1- likes(X, Y). 
no 
The characters "1-
" were printed by Prolog as a "prompt". 
This tells us that It expects 
a question at this point. We have asked a question. and the answer was "no". Not surprising. 
since there are no facts In the database yet. 
We assume that the file TEST. TXT appears 
on the QX1: directory. and we consult It: 
1- ['QX1:TEST']. 
DK1:TEST consulted 
yes 
To make Prolog read In clauses from a file. we give It a question consisting of the file name 
(as a Prolog atom) In list brackets. 
The system assumes an extension .TXT for the file. 

267 
Here we have a file of clauses about people liking one another. 
?- likes(john,bertrand). 
no 
?- likes(john,albert). 
no 
Just asking a few questions about who likes whom. 
Prolog cannot satisfy any of these. 
?- listing(likes). 
likes(john,alfred). 
likes(alfred,john). 
likes(bertrand,john). 
likes(david,bertrand). 
likes( john,_45) 
,- likes(_45,bertrand). 
yes 
To find out what clauses we have for a predicate. we ask a question about the special built-In 
predicate listing. This particular question causes Prolog to print out all our clauses for likes. 
Note that Prolog writes out unlnstantlated variables as an underline followed by a number. 
The clause at the end of the database was written In the file as: likes( john,X) :-
likes( x, bertrand ). 
?- likes(john,X). 
** (top) PROVED 
likes(john,alfred)?; 
** (top) PROVED 
likes(john,david)?; 
no 
Here we have asked for alternative solutions to the question, by typing '.' and 'return'. 
There 
were two possible solutions, and then Prolog could find no more. 
?- likes(X,Y). 
** (top) PROVED 
likes(john,alfred)? 
** (top) PROVED 
likes(alfred,john)?; 
** (top) PROVED 
likes(bertrand,john)? 

268 
** (top) PROVED 
likes(david,bertrand)? 1 
** (top) PROVED 
likes(john,david)?; 
no 
This time, each solution Involves seeing what two variables are Instantiated to, 
Again, we 
ask for alternatives by typing ';' and 'return' until there are no more solutions. 
?- [user], 
Now we ask Prolog to read In clauses from the special file user. 
This causes clauses to 
be read in from the terminal. 
These clauses will be added at the end of the database. 
When It Is reading clauses (rather than questions>, Prolog does not make the "7- • prompt. 
likes( timothy ,bertrand), 
user consulted 
yes 
We told Prolog to stop reading clauses after the first one by typing 'Z (control-and-Z) at 
that point. 
We could have typed in several facts and rules before typing ·Z. 
Now Prolog 
has finished with that question and is expecting another question again. 
?- likes(john,X). 
** (top) PROVED 
likes(john,alfred)?; 
** (top) PROVED 
likes(john,david)? 
** (top) PROVED 
likes( john, timothy) ? 
no 
Again, we ask for alternatives. 
Note that the new clause has lead to a new solution that 
was not present when we asked this question before. 
?- likes(bertrand,Y). 
** (top) PROVED: likes(bertrand,john) ? 
yes 
This Just illustrates the other way we can deal with alternatives. 
Here, we Just typed 'return' 
after the first answer. 
This causes the question to succeed, and Prolog is now waiting for 
another question again. 
?-
End of PROLOG execution 

269 
In response to the last "7- ". we typed ·Z (control-and-Z>. to Indicate that we were finished. 
Now we are back with the RT-ll monitor again. 
As In DeclO Prolog. the RT-ll system Is slightly more flexible than the rules we have 
given about what are valid atoms and variables. 
Operator declarations in RT-Il Prolog are somewhat restricted. 
Firstly. any atom can 
only be declared as an operator In one way. 
If multiple declarations are made. only the 
latest one has any effect. 
Secondly. the only permissible operator types are: 
fx, xf, yfx, xfy 
The rule for using these is simple -
use f:z: for a prefix operator. xf for a postfix operator. 
and either xfy or yf:B: for an infix operator. according to whether It is right or left associative. 
This Prolog system will actually allow certain syntactic forms that are theoretically Illegal. If 
they are unambiguous. 
For Instance. If not are f:z: operators. then 
not not a. 
is unambiguously read as 
note note a». 
even though In theory it is not possible for the argument of not to be a term with the same 
precedence. 
Arbitrary Bounds 
The LSI-ll machine Is relatively restricted as regards the amount of memory that a 
program can access. 
As a result. the RT-ll Prolog system has had to be very careful about 
how Information Is stored. 
There are many arbitrary bounds that arise because of this. 
The number of distinct atoms that a Prolog program can use is restricted to 1024 in 
the RT-ll system. 
Of these. some are already taken up by the system before your program 
Is read In. 
In practice. this limit seems to only affect programs that maintain large databases 
of facts. 
An atom can also have no more than 253 characters. 
A functor cannot have an 
arity greater than 15. 
Prolog integers are restricted to the range 0 to 16383. 
Arithmetic 
on these takes place modulo 16384. 
Operator precedences must be between 0 and 255. 
Finally. the system will only write terms to a "depth" of 20. 
Subterms of the write 

270 
argument that are deeper than this are simply written out as •••. 
This helps you to avoid 
getting unmanageable amounts of information if you accidentally ask Prolog to print out a 
rather large structure. The ·depth· of a subterm of the write argument Is computed as follows. 
The ·top level· of the argument -- either the argument itself (If It Is atomic) or the argument 
excluding its components (If It is a structure) -- has depth O. 
If the write argument is a 
structure. then the ·top levels· of Its components have depth 1. 
The ·top levels· of their 
components have depth 2. and so on. 
The only exception Is that the ·top levels· of all the 
elements of a list have the same depth as the first one. 
Environmental 
The RT -11 Prolog system allows you to interrupt a Prolog program while it is running. 
The appropriate character to type is ·C (control-and-C). and it must be typed twice In quick 
succession in accordance with RT -11 conventions. 
When you interrupt a program, you are 
offered the possibilities of 'abort', 'break', 'continue' (carry on with the program), 'exit' (from 
Prolog). 'notrace' and 'trace'. 
These last two options involve continuing with the program 
after the tracing has been suitably altered. The 'abort' option involves abandoning all running 
programs and reverting to asking you for the next question. 
The 'break' option suspends 
the current program and gives you a new ·copy· of the Prolog interpreter to interact with. 
When you exit the 'break'. your program will continue running. 
The RT-11 Prolog system provides optional facilities for drawing pictures on the display 
screen of the Terak 8510 personal computer. These Include facilities for drawing points, lines, 
and regions, moving the cursor and activating the available display. 
The character to type to Indicate ·end of file· Is ·Z (control-and-z) for RT-11 Prolog. 
This is the character you type to finish a consu1t(user), to exit from a break or to leave 
Prolog. 
If an end-of-flle is encountered by read, it finds the structure: 
1- end. 
When an error is encountered in the RT-ll Prolog system, first of all a message is 
printed on your terminal to tell you what has happened. 
After that, one of three possible 
things can happen. 
If it is a syntax error <the predicate read could not interpret the input 
properly), Prolog prints out the best It could make of the input and then causes a fai1 of 
the read goal. 
If this happens during a consu1t, or at the top level, Prolog just goes on 
to read what comes next. 
Most other errors cause a break to occur. 
If you exit from the 
break normally (by typing ·end of file·), your program will behave as if the goal with the error 
just failed. 
As another option. you can. of course cause an abort. 
The final possibility. 
which only happens with a few kinds of errors. is that an abort takes piace immediately. 

271 
Compilation 
The RT -11 system does not offer the possibility of compilation. 
It provides only a Prolog 
Interpreter. 
Particular Built-In Predicates 
The RT-ll Prolog system does not provide grammar rules automatically. 
However, the 
system should be distributed together with a Prolog program that you can run to get access 
to grammar rules. 
Here are some other bits and pieces that are worth looking out for: 
The list notation for consu1t and reconsu1t. 
In this notation, you must precede a file 
name with '$' ( not '-') If you want to reconsu1t It. 
Thus, for Instance, the following 
two goals are equivalent: 
7- [myfile,$fred,'dk1:foo'], 
7- consult(myfile), reconsult(fred), consult('dk1:foo'). 
A "backtrace" facility.' 
This facility enables you to look at the ancestors of the current 
goal. 
You can also use It when Inside a break after an error. 
It Is quite useful 
In such a situation, because It gives you some Idea of the context In which the error 
occurred. 
This facility Is provided through the built-in predicate ana (standing for 
"ancestors"). 
Debugging Facilities 
The RT-11 Prolog system Is not as elegant at answering questions as we have suggested 
Prolog systems usually are. 
Instead of printing out the values of variables In a format as 
In: 
7- likes ( X, Y). 
x = _251, Y = apples 
It prints out Instead the whole of the successful goal: 
7- likes( X, Y) . 
** (top) PROVED: likes(_251,apples) 
and then asks Is you are Interested In alternative solutions (in the normal way). 

272 
What about other debugging facilities? In the RT-ll Prolog system, there Is an exhaustive 
unleashed tracing facility and also the possibility of setting spypolnts. 
These two facilities 
are 
essentially Independent. 
Because the 
exhaustive 
tracing 
Is 
unleashed, 
you 
are 
recommended to use spypolnts extensively. 
In this way, you can avoid getting overwhelmed 
by the exhaustive tracing (by turning It on only at carefully selected places). 
You can also 
make better use of the options like 'retry' and 'skip' If you have lots of spypolnts (because 
you can only use them at spypolnts, 
Reference 
The RT-11 Prolog System, by W Clocksln, C Mellish, and R Fisher, 1980. 
Software Report 
5a (revIsed), Department of Artificial Intelligence. University of Edinburgh, Edinburgh, Scotland. 

273 
The 2980 EMAS Prolog system 
A version of Prolog has been Implemented by Luis Damas for the Edinburgh Regional Computing 
Centre's ICL 2980 machine. running under the EMAS operating system. 
Unfortunately. at the 
time of going to press we do not have detailed Information about this Prolog system. 
However. 
we understand that It provides facilities very close to the ·core· Prolog presented In this book. 
The EMAS Prolog system is modelled on DECsystem-10 Prolog. but provides no facilities for 
compilation. 
We suggest that you consult Appendix E to see approximately what a session 
with EMAS Prolog looks like. 

274 
other Prol.og Systems 
There are many other Prolog systems available around the world. 
It Is Impossible to list them 
all here. 
Some Prolog systems available have been derived from the Edinburgh systems 
described In previous appendices. and most Prolog systems in the world owe their parentage 
to the original Marseille interpreter. 
In the other appendices we have concentrated on those 
systems conforming most closely to the "core" Prolog described in this book. 
In this appendix. 
we have listed a representative sample of Prolog systems drawn from around the world. 
We 
apologise to other Prolog implementors if we have not given their systems the attention they 
deserve. 
References 
PROLOG -- Manuel de Reference et d·Utllisation. by P Roussel. 1975. 
Groupe d'intelligence 
Artificielle. UER de Luminy. Universite d' Aix-Marsellle II 
An Implementation of Prolog. by G M Roberts. 1977. 
Department of Computer Science. 
University of Waterloo. Canada 
PROLOG Reference Manual. P Szeredi and I Futo. 1977 (In Hungarian). 
Szamologep vux 
(5-130> 
An Interpreter for Predicate Logic Programs. by M Bruynooghe. 1976. 
Afdellng Toegepaste 
Wiskunde en Programmatie. Katholieke Univ.. Belgium. 
Control FaCilities of IC-PROLOG. by K L Clark and F G McCabe. 1979. in Expert Systems In 
the Microelectronic Age (ed 0 Michie). Edinburgh University Press. 

Index 
Note: 
In this Index. where there are multiple entries for an Item. we have asterlsked the page 
numbers for the major entries. 
For built-In predicates. these are the entries In Chapter 6. 
'1' .... 
'+' 
'/' 
............................................. 
64.116 
.35.127" 
.35.127" 
· .. 118 
.35.127" 
.34.127" 
............................................ 
128".136 
'(' ............................................. 
31.128" 
'=' 
'- . 
-.. 
'=<' 
'>' . 
')=' 
'=' 
'\=' 
.29.31.121".127 
· .. 114 
.31.128" 
· .. 121 
.31.128" 
.31.128" 
· .. 128 
.31.121" 
'\==' ............................................. 
123" 
'{ ... }' 
abort (traCing) 
'aless' 
'alter' . 
.201 
.184 
.51 
.50 
ancestor ............................................ 
180 
anonymous variable ..................................... .24 
'append' 
.55.70.140 
• appllst' 
. 
. . .161 
'arg' 
.73.111" 
argument ............................................ 
4 
arithmetic ......................................... 
31.126 
• asserta' 
.105 
• assem' 
.105 
associativity 
.27.91 

276 
'atom' 
atom 
.100* 
•• 28 
'atomiC' ......••...•..................•..•......•... 
101 
backtracking 
body (of rule) 
boundary condition 
box model 
break (traCing) 
built-In predicate 
'call' 
catchall 
'change' 
character (non-printing) 
character (printing) 
character 
circular definition 
clausal form 
'clause' 
clause 
component 
conjunction 
conjunctive normal form 
connective (logical) 
constant 
'consult' 
creep (traCing) 
current Input stream . 
current output stream 
cut ......... . 
.11.85.58 
.14 
.46 
.170 
.184 
....•. 
94 
.72.104.119* 
.50 
.50 
.26 
.26 
.22.26.84 
...• 
47 
.210 
.108 
.18.102 
.•. 25 
.8.118* 
.218 
.208 
.22.28 
.90.95*.105.185 
....... 182 
.88 
.88 
.64.116 
database ......... . 
. ...... 
4 
'debugging' .. 
design deCision 
dictionary 
differentiation (symbolic) 
digit 
..... . 
disjunction 
'display' . 
.129 
.164 
.180 
.158 
.................................... 
22 
· •. 119 
.88.125* 
empty list 
. .....................................• 
41 
, end_oCflle_mark' 
equality 
errors . 
fact 
· .• 105 
.29.121* 
· .. 168 
. .... 2 

277 
'fall' ... . . . . . . . . . . . .. .................. 
.71,97."104.107 
fall (tracing) ........... .................. 
. . . . . . . .183 
file .......•....................................... 
88 
'flndall' 
.152 
'functor' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .109 
functor 
. 
. .25 
generator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .73 
'gensym' ........................................... 
149 
'get' 
.86.117 ,124" 
'getO' 
.86.117.124" 
goal ....... 
' ........................................ 
8 
grammar rule 
.195 
halt (tracing) ........................................ .184 
head (of list) 
. .43 
head (of rule) ......................................... 
14 
heat flow 
.130 
Horn clause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .222 
Infix .... 
.28 
Input .............................................. 
80 
Instantiated ...........................................8 
'Integer' ............................................ 
100 
Integer ............................................. 
23 
Integer division 
Interpreter . 
'Is' 
.34.127" 
. .. 104 
.34.126" 
'Is_Integer' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .62 
leap (traCing) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .182 
left associative 
.29 
left recursion 
list (as goal) 
list 
'Ustlng' ..... . 
logic ....... . 
logic programming 
'mapllst' 
mapping ..... . 
match .. . 
.... 
47 
... 97 
.41.139 
.103 
.207 
.225 
.160 
.160 
.... 
5.58 
'member' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .44.64.99 
'mod' 
. 
.34,127" 
'name' 
.53.115" 
'ni' 
.81.124* 
'nodebug' .......................................... 
129" 

278 
'nonvar' 
.100 
'nospy' 
.129 
'not' 
. 
. ....................................... 
70.72.120* 
'notrace' 
. . .129 
'op' 
. . 
.92.125* 
operator ... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .27.91.125* 
or (tracing) .......... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .183 
output 
.80 
parent goal 
parse tree 
parsing 
.66 
.189 
.197 
position 
.27.91 
postfix ............................................. 
28 
precedence 
Predicate Calculus 
predicate 
prefix 
pretty print 
prime number 
procedure 
'put' ... 
quantifier 
question 
'random' 
'read' . 
:read_ln' 
reading . 
'reconsult' 
recursion 
'repeat' 
re-satlsfy 
Resolution principle 
'retract' 
. 
'retractail' 
retry (tracing) 
right associative 
rule . 
.27.91 
.. 207 
.. .4 
.28 
.81 
.157 
.165 
.85.124* 
.209 
. .4 
.148 
.83.124* 
.86 
.80 
.95*.107.185 
...... 
39 
.105.116* 
.7.35.58 
.218 
.106 
.106 
.183 
.29 
.13 
satisfy ........................................... 
7.35.58 
scope ........................................... 
15.167 
search (best-first) 
search (breadth-first) 
search (depth-first) . 
.155 
.156 
.154 

search (maze) 
search (neighbour-first) 
'see' 
'seeing' •••...•.. 
'seen' 
set 
share 
simplification 
'skip' ..•... 
skip (traCing) .. 
Skolem constant 
Skolemising 
sorting 
'spy' .... 
spy point 
279 
.133 
.154 
.90.105.125* 
. ..•.•.•.. 
90.105.126* 
..•.••• 90.126* 
......... 
143 
.17.38.121.125*.167 
..•. 101.161 
.124 
.182 
.211 
.211 
.145 
.129 
.129.176 
string •....••...•..••.•...•.•...•...•....•....•.••.. 
44 
structure . . . . • • . . . • • . . • . • . • . • . . . . . • . . . • • . . . • . . • . • . . .22.24 
subgoal ............•.......................•..•••..• 
35 
substitution ..............•...•......•.......•..... .112.142 
syntax 
....•.............•.....•......•.•......... 
22 
'tab' ...••......•....•..•.••.•........•......•. 
81.85.125* 
tall (of list) .....................................'.... .43 
'tell' . . 
.88.126* 
'telling' 
term 
..•...•...•..•..................•....•.. 
90.126* 
.. 22 
tester . 
. •......•.........•....•..•....•.•...... 
73 
theorem proving 
.•.• 218 
'tOld' ................•......................... .90.126* 
'trace' ..............................•........... 
170.128* 
tracing .....••..••..• 
176 
tree (sorted) 
tree (transformation) 
tree .... 
.130 
.160 
.• 39 
'true' ....••..........•.....•..••...........•.•..... 
97 
unification ...•.......•................... ' .......•..•. 
219 
uninstantiated ..........................................6 
'user' . 
• ... 89 
'var' 
. ..................................... .. 73 .. 98* 
variable .....•....••.......•...........•...•..•.. .6.22.24 
vine diagram . . . . . . . . . • . . . . . • . • . . . . . • . . . . • • • . . • . • . . . . . .42 
'write' ...•...••..••..•.•••.•.•..•••...•...•.....• 
81.125* 
writing ...•••..••..••.....•.....•.•......•..•..•..•. 
80 

Springer-Verlag 
Berlin 
Heidelberg 
New York 
W.E. Riddle, R E. Fairley 
Software 
Development Tools 
1980. 26 figures. VIII, 280 pages 
ISBN 3-540-10326-0 
Contents: introduction. - Needs. - Experien-
ces. - Development Support Systems. - Pro-
cedural Description Techniques. - Non-Pro-
cedural Description Techniques. - Analysis 
Tools. - Summary. - Bibliography and Refer-
ences. - List of Attendees. 
This book contains the papers presented at 
the "Software Development Tools" workshop 
held at Pingree Park, Colorado, in May, 1979. 
Also included are reports on the discussions 
generated by presentation of the papers . 
. Among the topics covered are: the need for 
tools, experiences with tools, integration of 
tools to form homogeneous environments, 
procedural and non-procedural notations, and 
testing and verification tools. 
The papers and discussions describe: pro-
blems facing toolsmiths; the need for experi-
mental evaluation of tools; the general pro-
blems of fitting tools together to provide 
development support systems, and the general 
applicability of analysis tools in the preimple-
mentation phases of software development 
The text provides a well-rounded picture of 
the current state of software development 
tools. Numerous short term and long term 
research topics are suggested. 

