this is the return of procedural
programming I'm Richard Feldman so back
in the 1990s at my hometown I used to go
to Borders Books and Music a lot anyone
ever been to a borders I really think
okay ton of people wow um so uh I would
you know walk around and this is sort of
before the internet like we didn't have
the internet in my house nobody I knew
had the internet my dad had like the
internet at work at his at the
University a little bit it was mostly
for email um so the main way that I
learned about new programming things was
from books and I remember walking around
this borders and I would see all these
books about this hot new super hyped
thing object-oriented programming see
books like this head first
object-oriented analysis and design
sometimes you'd see exciting new
releases of object-oriented languages
like Java 1.1 um you would sometimes see
object-oriented programming books at
different demographics um there was just
just just this overwhelming tital wave
of hype and excitement around
object-oriented programming it was so
clear that this was the future that the
old sort of procedural programming way
was the thing of the past and the thing
of the future was O so I remember like
walking around borders and thinking this
and this kind of stuck in my mind I got
into industry I you know became a
professional programmer did a lot of
object-oriented programming so imagine
my surprise and imagine my my sort of
telling my past self about ET a couple
years ago 2019 here's Andrew Kelly
talking talking about the zig
programming language which he created
one of several new upand cominging
low-level programming languages and he's
talking about hey we're trying to make a
better C we're not trying to be like C++
we're actually intentionally making this
new programming language not
objectoriented and zig's not the only
one you also see like rust not an
object-oriented language very very
popular getting a lot more popular Odin
Jai these are two other low-level
systems level programming languages
really of the last like 10 15 years the
only like low-level language in that
group that right here being talked about
that is objectoriented is carbon which
is a language that's explicitly designed
to be a C++ successor and have C++
interupt so they kind of couldn't get
away from it this is a really Far Cry
from what I remember of like o being
like the obvious future the thing that
everybody was going to be
doing um so we're talking about here
procedural programming so the thing that
came before oo and in this talk I'm be
talking about to what extent is it
coming back um so procedural programming
is not objectoriented it's also not
functional so procedural is an
imperative Paradigm it's not really
concerned with mutation or side effect
or the lack thereof and it's also not
new it is the thing that we had before
object-oriented programming and it's
sort of starting to see a Resurgence so
partly it's in these new languages but
also it's just in existing mainstream
procedural languages getting used more
so stack Overflow has been running this
survey for the past six plus years about
which programming scripting markup
languages have you personally used in
the last 12 months and we can see some
interesting Trends in here here's sort
of the raw data but just some highlights
so among object-oriented languages in
this survey people saying you I've used
this in the past 12 months typescript
and cin huge increase massive increases
in typescript this is probably not news
to anyone in here um if you're in the
Android development World especially you
probably have heard about cotland just
being this absolutely huge thing there
um Python and C++ both saw a 50%
increase over the past uh six years
which is a big deal because they were
already super high in terms of usage um
I'm assuming that AI has a big part of
this so both Python and C++ seeing a lot
of use in AI it's a lot more work being
done in AI these days also python seeing
a lot more work in data science that's
been sort of an upward Trend and C++
also games and more and more games have
been getting developed compared to like
the 1990s for example um C Java
JavaScript kind of no change but they're
already sort of on top so it's like it's
a moving up is is really noteworthy when
you have that much usage already um then
they also saw some decreases like Swift
and Objective C 30 to 50% decrease there
in terms of like pop in terms of how
many people said they they'd use them um
in the past 12 months uh PHP Ruby a
Scala I can think of various
explanations for these things like Swift
and Objective C just maybe a smaller
percentage of people are doing iOS
development that's pretty much where
Swift and Objective C are uh being used
also a lot of objective c is being moved
to Swift intentionally um PHP and Ruby
like rails is less popular Ruby's
popularity in terms of like worldwide
usage has been pretty coupled with rails
so if fewer people are doing rails
people doing Ruby um PHP has become more
of a niche thing that's kind of used for
like WordPress and Drupal and not nearly
as much like General websites as it used
to be and Scala I think uh its decrease
would be explained in large part by the
increase in cotland because one of of
the three different ways that people use
Scala is sort of as like Java Plus+ or
I've heard the joke being Java without
semicolons and cotlin also uh you know
offer some of that same sort of java but
sort of uh you know taken in in a
slightly different and maybe arguably
improved Direction okay what all
procedural languages because they're
also certainly some long-standing
mainstream procedural languages what do
their Trends look like we'll see seen
like a 30% increase over the past six um
years so part of that could be explained
by C++ I I bet there's some double
counting there where a lot of people who
are saying I'm doing C++ are also
answering yes I've done C in the last 12
months um go 100% increase I don't have
a double counting explanation there it's
just like seems like a lot of people uh
you know seem to be liking go
anecdotally at this conference I've had
three different conversations with
random people in the last couple days um
and two out of the three said they're
adopting go at work and I think that's
just because people like go and maybe
it's because they got generics now I
don't know but one way or another go
seems to be increasing in popularity and
it's just not an object-oriented
language it's procedural programming and
then of course rust uh I gave rust %
increase but that's actually being
generous because uh 6 years ago Russ
wasn't even on the chart like it was
kind of zero so you could say it's an
Infinity per increase but that doesn't
seem reasonable so to be generous to the
other languages we'll just cap it at a
th% but point being Russ went from
essentially not being on the chart six
years ago to now it's like 10% of
respondents said that they use Russ in
the past 12 months so absolutely massive
increase no classes no objects and any
of these languages no subclasses no
inheritance just procedural programming
and so since we saw sort of a mix of up
and down in the O side and all of the
mainstream procedural languages or at
least all the ones on this survey um
have have seen some form of increase
putting those two together that means
that in the last six years at least
among stack stack Overflow survey
respondents object-oriented programming
lost ground to procedural like some of
them went down none of the procedural
ones went down they all went up what's
going on here I thought oh was supposed
to be the future forever um so this is
what we want to talk about today is is
why is it that procedural programming is
becoming proportionately more popular
now to be clear o still rules the roost
to it's still the most popular Paradigm
on the planet for sure by a healthy
margin the question is about the trend
why is it becoming more popular why is
it sort of coming back even though it's
the thing that came before O So outline
of the talk the first and largest
section is going to be talking about
differences in features between the
procedural paradigms and oo paradigms is
going to break it down into sort of two
different categories of oo little bit
shorter section differences in style
between the two and then the shortest
section of all is going to be at the end
uh so sort of what changed what is it
that sort of putting all these things
together changed to make procedural
programming start come back so we'll
start with differences and features and
just to sort of set the scope of what
we're talking about for this talk I'm
just going to focus on the paradigms of
procedural and mostly objectoriented and
just kind of briefly mentioned
functional this is mostly talk about
imperative programming so I've talked a
lot about functional programming in the
past but this talk is not about that um
so also not going to get into other
paradigms like logic programming it's
really just kind of going to be
procedural and objectoriented and and
their differences okay so thinking about
sort of like what's the essence of the
Paradigm so a language Paradigm is in a
lot of cases about some combination of
language features and also the style in
which you use it we're going to start
off by talking about the features so the
procedural sort of like feature set and
style I guess is uh the introduction of
the idea of using procedures over go-tos
so if you look at the hardware like the
hardware doesn't have a concept of
procedures this is a new paradigm that
we sort of invented on top of the of the
hardware and having this sort of
abstraction of the idea of a procedure
built in terms of essentially go-tos
like conditional jumps and
non-conditional jumps um and this like
concept of the stack and things like
that uh so it's basically just the idea
of hey what if we our programs into
procedures this has become a rather
popular idea basically every all
programming does this now you could be
forgiven for thinking what do you mean
Paradigm that's just programming uh
because this is a paradigm that is
really really stuck around um functional
would be sort of like procedural with
restrictions I guess you could say it's
sort of like let's take procedural and
then uh also try to avoid mutation and
side effects um object-oriented a little
bit trickier to Define so let's sort of
talk about that um so another uh past ET
speaker Alan K gave a keynote Len K is
the person who coined the term
objectoriented and he uh he coined this
term at the University of Utah in uh so
at first in 1966 he sort of described
what his influences were when he was
doing objectoriented programming as he
later called it um he talked about
simula so we'll talk about simula a
little bit later so simula was the first
language that introduced the concept of
objects and classes it started off as a
DSL for uh describing simulations that
was like its purpose as a language and
then in the second edition of simula
they decided you know what we think this
is actually a good idea and people
should try to use this style of program
programming for things other than
simulations and that was when they
introduced the the terminology of
objects and classes um in that second
edition of simula whereas before they Ed
like systems and procedures or something
like that processes um so Alan K was
inspired by that he also was inspired by
the design for the arpanet or the
internet as we now know it um we'll
definitely see that he really thought
about objects as essentially kind of
like little tiny servers and finally my
background of biology and Mathematics
which had to do with like metaphors for
how cells communicate and Mathematics in
terms of like algebras of how things are
organized um and he he used this term he
said I thought of an architecture for
programming we're going to contrast this
with other sort of schools of oo that
don't really think about it as much of
as architecture as he did um probably in
1967 when someone asked me what I was
doing and I said it's objectoriented
programming and it stuck that's what
people use to describe this the style of
programming and other styles that he
doesn't think count okay so uh later in
2003 Alan K said sort of by means of
clarification to me object-oriented
programming means only
the following messaging we'll talk about
what that means local retention and
protection and hiding of State process I
think he means encapsulation by this I
don't know what else he could mean by
this but let's assume he means
encapsulation and extreme late binding
of all things we'll also talk about that
he says it can be done in small talk and
in lisp I got to admit I heard that and
it kind of threw me for a loop because a
I don't really think of lisp as an
objectoriented language in the sense
that like it's what a lot of people call
the first functional language and also
Lis explicitly added like there's like
the common uh lisp object system like
that was like a separate thing later and
if it was already objectoriented why
would you need to add an object system
later also they don't use the term
objects or classes or anything like that
in lisp I don't know but apparently to
Alan K this is an example of a language
like one of the two languages that can
do it and then he goes on to say
something that was even more confusing
to me which is there are possibly other
systems in which this is possible but
I'm not aware of them now we said this
in 2003 at which point Objective C and
Ruby had been around for like multiple
decades uh so I'm not really sure I
guess Ruby less than one decade it was
1995 but they been around for a long
time and both of these languages are doe
messaging encapsulation and extreme late
binding so not really sure what he was
talking about there um regardless let's
talk about what messaging means because
this is maybe not something that you
might think of in terms of object
oriented programming it's certainly not
something I thought of back in in the
90s so messaging is essentially in the
object-oriented context what Alan K is
talking about is the idea that calling a
method on an object means sending a
message to that object like you've got
some piece of information you're sending
it to the object the object receives it
and then decides what to do with it so
really the the object sort of decides
when like in real time at runtime when
it gets this message what am I going to
do just based on looking at the message
and looking at like the current my state
my the state of the world all those
types of different things essentially
just like what an HTTP server does if
you got a web server and it receives a
request it can decide on the Fly what to
do with that including nothing it can
say not found and it can change its
answer about not found all the time at
runtime at real time um this is exactly
Alan Kay's concept of uh of what objects
were and in fact he's talked at length
in in different uh contexts about how he
sort of saw each object as sort of like
a tiny computer or like a tiny server
and the the idea of objectoriented
programming to him was this recursive
design idea where everything was it was
like computers all the way
down um Ruby explicitly in includes this
idea of messaging so if you look up the
official Ruby documentation about what
calling methods is it says calling a
method sends a message to an object so
it can perform some work and it's got
like an example of the syntax my object
My Method it says this sends the My
Method message to my object and if you
included arguments in that those will
also be part of the message that gets
sent to the object so yukihiro Matsumoto
AKA mats was very directly influenced by
Small Talk um when he developed Ruby and
he wanted to include this idea of
messaging in it okay so he also
mentioned uh late binding extreme late
binding in all things um if you're not
familiar with that idea this is
essentially the idea that like the list
of methods and object supports and what
they can do can change in any way at
runtime this is kind of an extension or
like an implication of the message idea
essentially like you're getting a
message in and you can decide hey like
right there on the Fly do I support this
method do I have it what arguments is
accept what what are their types you can
decide that as late as you want you can
change them on the Fly you can say every
30 seconds I completely scramble what
methods I support and I delete half of
them and then I add new ones you can do
that all all that this is a really
critical thing to Alan Kay like this is
an important part to him if you're not
doing that if you don't support that and
do like extreme late binding in all
things it's not object-oriented
programming so in other words when you
see some syntax like this that that's
what it's supposed to be doing you
should have no idea at compile time what
that is possibly going to do if it's
going to do anything if it's supported
any of that stuff now interesting
implication of this is that this is
completely at odds with static type
checking static type checking is where
you say at compile time not at runtime
I've got an exact list of all all the
methods that are supported I will check
them I will give you a red squiggle in
your editor if any of them are not
supported at compile time um and they
shouldn't change at runtime if you want
to be able to type check them if you do
want to change them at runtime fine but
now we're outside the world static type
check
now I mentioned this because there's
been a pretty strong trend of increase
in the use of static type checking which
is really at odds with this idea of
extreme late binding of all things so we
have small talk which is influenced by
descended from simula um we have
Objective C in 1985 so uh similar 1960s
or late 50s um Small Talk 1972 yeah 1972
because it was the same year C came out
um and then Objective C 1985 Brad Cox
creates this language and it's basically
like he starts with c and he wanted to
add some productivity features to it he
just read about simula and bite magazine
sorry um um small talk and bite magazine
and uh and he says you know what I'm
going to try and add some small talk
features to C and he ended up calling
that Objective C he included the message
passing idea the late binding idea all
that good stuff um so if you look at
actually like even modern Objective C
documentations this is from Apple
because the way Objective C ended up
being used in practice essentially was
exclusively uh as kind of an apple thing
um but like they have this this method
you know message sends sends a message
with a simple return value to an
instance of a class AKA and object so
this this idea of messaging persists
today although again for some reason
Alan K doesn't think Objective C counts
as o but lisp does anyway um now python
despite uh being a language that a lot
of people would consider object-oriented
didn't do those things it was not uh
like GTO van rossom was not influenced
at least not like really influenced
strongly by small talk but rather he had
he had personally used simula and had a
good experience with it and he wanted to
incorporate simula into this language or
simula ideas maybe like class and
objects into this language he was
creating called python so he did but he
didn't include the messaging idea that
was like kind of the Alan K small talk
thing and this is like one of the first
examples we'll see of object-oriented
languages or languages we think of as
object-oriented that didn't fit Alan K's
definition at all they didn't do
messaging certainly did the late binding
thing but but not messaging at all um
Ruby was actually so again Yuki hero
Matsumoto AKA Mets created Ruby and he
was aware of python at the time and he
specifically wanted in the design of
Ruby to make a scripting language that
was more object oriented than Python and
what he meant by that is essentially
more like small talk like it actually
included the idea of messaging like we
saw um there's another language that uh
how many people have heard of
self uh one two okay so not a lot um so
self uh you don't worry you'll you'll
recognize the language that uh that ends
up being descended from self so self was
this programming language that descended
from Small Talk um they wrote this the
authors wrote this paper about it self
the power of Simplicity unlike Small
Talk self includes neither classes nor
or variables variables meaning like uh
members instead steal has adopted a
prototype metaphor for object creation
how many people have heard of prototypal
inheritance okay a lot more a lot more
um how many people have heard of the
most popular prototypal inheritance
language
JavaScript hey all right cool so um so
this is kind of self's legacy is that it
inspired javascript's original
inheritance system um I'm using
javascript's original like 1995 logo for
there for uh for reasons that'll become
apparent later um uh you might know
JavaScript by its more modern logo which
looks like
this
uh yeah so the whole late binding thing
and not static type checking uh yeah
there's that Trend um so basically uh
self was sort of an inspiration for
JavaScript but even before we got
typescript and sort of the the move away
from extreme late binding and all things
and towards uh static type checking we
did see some other Trends around like
self's idea of prototypal inheritance
namely that like es6 JavaScript
introduces classes and sort of becomes
the sort of preferred official way to do
uh inheritance and oop and JavaScript
over the The prototypal Inheritance idea
still supported but it's really like
when you read tutorials and stuff A lot
of times people talk about kind of the
new shiny es6 classes way and the reason
they added that is just pretty much the
rest of the world except for JavaScript
is doing class-based inheritance and it
seems like the prototypal inheritance
idea maybe it was cool at the time but
it doesn't really seem to have stuck
around it seems like it's it's kind of
going to end with JavaScript um you can
look at Dart as another example of this
so Dart is a language is like very very
directly in offshoot of JavaScript but
they didn't even bother to include the
prototypal inheritance thing they just
used class-based inheritance so this is
one of several ideas that we're going to
see in this talk of sort of branches of
oop that you know they got tried out
they were mainstream they had their
their you know their their time in the
Sun and now people are just moving away
from them and for one reason or another
there could be a lot of different
factors to to do with that um but the
idea just doesn't kind of seem to have
stuck as much as some of these others
have um also we've seen kind of a move
away from messaging so saw that like
Ruby and Objective C explicitly included
messaging in their designs well
objective C's successor language Swift
uh which was you know developed at Apple
with the express purpose of being like
let's do this for iOS development and
and Coco and all that um instead of
objective c sort of the the modern um
alternative doesn't even include
messaging except as a specifically as a
way to do backwards compatibility with
old Objective C code um similarly Ruby
you've got sort an off offshoot of Ruby
called Crystal which is uh you could
draw some parallels to Dart but not not
perfect parallels but um it's it's
basically like a very very Ruby language
that explicitly uses static type
checking and static dispatch so it has
it sort of really walks away from the
idea of extreme late binding of all
things um also we noted that you know
back in the stack Overflow survey that
uh Ruby and Objective C were two of the
languages that had the most decrease of
all the object-oriented languages in
that list um over the past six years in
usage so I again I think that's mostly
because of rails and because of Swift um
not necessarily because of Any you know
problems in the Ruby language or or
objective c but it is worth noting that
again the industry seems to be moving
away from this idea of messaging um and
also like I said moving away from the
idea of late binding all of these
languages down here python Ruby Crystal
Swift typescript either they have type
checking baked in or in the case of like
Python and Ruby they've now added
official language extensions so that you
can add type checking so it's really not
looking good for Alan K's sort of vision
of you know what he considers to be oop
um so you know he said this only op me
means only messaging okay encapsulation
definitely still here definitely still a
thing um but as far as messaging extreme
late binding of all things really
doesn't seem like that's kind of like
the future um in fact I don't want to
say that it's dead but it really it
seems to be well past its peak at this
point in terms of
popularity Okay so we've seen some
differences in features here so the
Allen K style of object-oriented
programming messaging and late binding
um procedural programming in contrast is
kind of just I don't know nah don't
don't do that like it's it's not really
like procedurals like ah here's what we
do instead of that it's it's just sort
of like I don't know we just just don't
don't do messaging and late binding
right that that was sort of what came
before um and so when I say that
procedural programming is you know
rising and popularity it's not so much
that people like oh here's this shiny
new way of doing things it's more just
like actually maybe we'll just not do
that and go back to the old way before
we did those things I guess if you could
call it a feature and sort of like
express it in a more positive way it
would be like procedur is more about
just like plain old functions and plain
old data being passed around between
them um okay now of course there there's
another whole branch of oop uh which is
is probably what most people myself
included uh think of more in terms of
oop which this is not the person who
coined the term uh this is BJ strip um
does anyone uh know what he's most
famous
for okay yes that is of course the
language I'm about to talk about next um
so drip was uh he had used simula in the
past and then he had also used C and he
decided to put them together in a
language that he called C with classes
which I assume was what everyone was
thinking
of anyone heard of SE with
classes I see a couple hands has anyone
heard of SE with classes they didn't
hear about it from
me okay one cool one and a
half um right so I didn't have a logo
for SE with classes um because it was
kind of a short-lived language um but I
made one up uh SE with classes um but
basically like SE with classes
essentially was kind of what the name
says it's like he took the C programming
language and he just added classes to it
he also as a bonus added uh static type
checking or like stronger static type
checking to it so already he's like the
polar oppos of Alan K's vision for op um
but essentially what what he found this
is like kind of an interesting case
study was with see with classes he he
described it as a medium success meaning
that like yeah you know it worked it
like did the thing it I added objects to
and classes to see um the problem was
that it was like kind of just a bunch of
his friends using it and it wasn't
really gaining widespread adoption and
he considered this a problem because he
didn't really want to keep maintaining
it if it was just going to be this kind
of like little medium success um and so
what he ended up doing was he decided
Well I don't want to shut it down cuz
that's just going to like hurt all my
friends and I also want to keep
maintaining it on my own I bet if I add
a bunch of other other features on top
of the object-oriented stuff maybe more
people will find it useful and then they
can help me maintain it um so he did and
then he decided to rename it from C with
classes to C++ how many people here have
heard of C++ hey it's like JavaScript
again cool all right so uh yes this
became slightly more popular um now
what's interesting about this is that it
is it's a little subtle distinction but
it's worth noting that if you just took
C which is already a very popular
language and you added just classes to
it the oop stuff that wasn't enough for
it to be popular he had to add all the
other non oop stuff before it got
popular which kind of tells us something
about was it the oop part that caused
C++ to get popular well obviously not
because when he added that it was C with
classes which nobody heard of the the
thing that got caused C++ to get popular
was that other stuff that he added on
top of it because before that when it
just had the oop stuff it it wasn't
popular and yet I remember the '90s
thinking oh yeah op is Big just look at
C++ and these kind of got conflated like
like that was the causal relationship
there but we did the experiment and the
experiment was like actually if you just
add op see it doesn't get popular and
it's like the same guy even so at any
rate um C++ quite a popular language um
Alan K not a fan he uh in 1997 he said I
made up the term object oriented and I
can tell you that I did not have C++ in
mind fair enough uh be that as it may I
mean as we've seen it seems like this is
sort of the family of oo that ended up
taking over whether or not the
originator of the term uh is happy about
that uh how it end up happening so one
of the most famous languages that uh
sort of is descended from C++ and in
fact was explicitly designed to appeal
to C++ programmers is Java I've
carefully organized this slide so that
you can see the Java logo next to
another logo which uh you know remember
JavaScript from 1995 um a little bit of
a backstory there JavaScript was
originally supposed to be scheme like a
functional programming uh language
dialect functional programming lisp no
less that was what Brendan Ike had was
planning on developing at Mozilla for um
the their use in the in the browser the
Netscape browser and essentially uh Java
comes out there's this huge like
literally multiple hundreds of millions
of dollars of marketing from Sun
microsof systems just for Java the
programming language so hype was real um
Mozilla says do you see this hype
machine that's coming put Java in the
name and like make the logo be Java make
the syntax look like ja just Java IFI
what you're doing and Brendon I's like
all right I guess uh so so yeah it it
sort of became JavaScript it was
originally called livescript um and uh
and the rest is history um uh PHP
another offshoot of C++ like uh you
Rasmus lorf um also Danish uh was uh so
doing C+ programming and doing web
programming and felt that it was like
kind of too clunky to try do web
programming in C++ and ended up
inventing PHP um later on C ended up uh
being sort of Microsoft's kind of like
version of java that had some
differences and things like that um but
this whole family of languages really
comes from sort of BW strips version of
C++ where he just wasn't interested in
messaging uh he wasn't interested in in
extreme late binding of all things in
fact he was quite into static typeing
and as we've seen with kind of the the
trends of these things this sort of
seems to be the version of oop that ends
up being being uh most widely used in
industry um he gave a talk called the
design of C++ where he sort of talked
about like his motivations and stuff
it's like from like the 1980s or
something um and he highlights some of
his goals with with this was with C with
classes originally but um those goals
you know persisted through C++ he talks
about like program organization was the
first thing he was sort of like you know
Dennis Richie did a good job creating a
c it had a lot of stuff but it doesn't
really tell you how to organize your
programs um he also talked about wanting
to maintain C's runtime efficiency
availability and portability
interoperability like he didn't want to
sacrifice those things the program
organization was the thing that he he he
said he was concerned with that's like
what he was really all about and when I
talk to people about things that they
like about o this is one of the things
that really commonly comes up um so Alan
K was like I had this vision for like an
architecture of programming strew up
more about program organization and the
thing that he uh ended up sort of
popularizing and that I hear a lot of
people say they like about opop is the
idea of combining actions on data types
like you you organize them in the same
place you've got your class and then
it's got a bunch of you know pieces of
information then you've got methods on
that class it's a really natural way to
sort of like couple these two things
together and in fact even in modern
programming languages that are not
objectoriented like functional languages
procedural languages tend they tend to
use modules for encapsulation rather
than classes but you really commonly see
this this same sort of organizational
strategy um so Evan chipi who made the
elm programming language he used to have
this this saying that I I really liked
and found useful in Elm um which was
talking about he said like you know
usually a good module is built around a
particular data type like you'll have
one type and that usually will be the
same name the name of the type type is
like the same name as the module and the
module will expose that type and you
have a bunch of functions in that module
that you know work on that uh that data
type um crucially this is more of a
convention in the modules world like in
the in the classes world it's like very
strong it's a very strong default it's
very strong cultural thing if you just
got modules and not classes you can
still do it that way but it's not as
strongly encouraged as it was in um in
C++ and in all the object-oriented
languages that followed it very strong
organizational culture around classes um
another thing that I've heard a lot of
is the pillars of oop so this is
something that comes up a lot in op
teaching it's interesting there seems to
be a bit of a disconnect because when I
look at early beginner object-oriented
tutorials and stuff this is super
commonly talked about when I talk to
people in Industry they're like oh yeah
the pillars they're uh I think I've
heard of that it's uh does anyone anyone
here know what the the pillars are off
hand yeah right like it's not it's not
you can't just like rattle them off um
so so here's what you see if if you look
up like you know what are the pillars or
the principles of oop you always see
these four um or sometimes only three
but abstraction encapsulation
polymorphism and inheritance um so uh
let's kind of like go through these a
little bit um and by the way these are
like kind of a state of values not
unique benefits as we will see in a
second um these are sort of things you
know I wasn't quite sure what the word
pillars meant but my conclusion after
talking to various different people
about this um is essentially that these
are these are not claiming these are
uniquely oo benefits because they're
really not but rather that like these
are sort of values like if you're doing
oop these are things that you should
value so abstraction kind of the idea of
like the general idea of like don't
depend on implementation details just
depend on sort of an abstraction of an
idea of something um rather than the
specific like here or the actual shape
of this these bits and bites in memory
um encapsulation is sort of preventing
depending on implementation details so
you have like a public private split and
you're not allowed to depend on the
private details you're only allowed to
depend on what's publicly exposed um
polymorphism is essentially again about
implementation it's where the
implementation of something abstract is
determined by its type um practically
every modern language has these they
might call them different things but
like you know abstraction what language
doesn't have that um encapsulation
sometimes you might hear that called
modularity but again what language
doesn't have modules with like public
and private stuff you know some things
are exposed some things aren't
polymorphism again basically every
language has that you know go just got
generics AKA parametric polymorphism go
doesn't have classes but you know you
don't need classes to have polymorphism
um which kind of leaves us with
inheritance uh which is I would say
something that is pretty uniquely oo
like you don't find inheritance in like
functional languages or not necessarily
unless they're like sort of hybrid o FP
um you don't necessarily find in
procedural languages um especially not
implementation inheritance which to be
fair there's interface inheritance
there's implementation inheritance but
really the the one the sort of um oop
Centric that you really only find in oop
is implementation inheritance so when
I'm talking about inheritance here I'm
talking about implementation inheritance
um implementation inheritance is
essentially hierarchical code sharing um
I would contrast that with composition
which is sort of non-h hierarchical code
sharing and of course we've all heard
that uh the recommendation in the op
world is to prefer composition over
inheritance which is the thing that
basically every language can do let's
get a little bit more specific about
what that means so we can kind of see
why people might prefer that um so why
prefer composition over implementation
inheritance so um shout out to Martin uh
Snider he gave me this uh this really
concise example of of why people uh come
up with this rule um let's say you have
a class and it's got three methods and
they sort of call each other and I'm
making a subass of that and I override
one of those three methods the other two
are still calling that method that I
overrode and the problem is that if I
didn't realize that those other two
methods were calling the one that I
overrode I might have just broken them
like accidentally I didn't I didn't even
know they were doing that like because I
don't really have a night way to see
that they were doing that it's not
really part of the semantics of the
language it's just a thing that can
happen um this is potentially a source
of bugs it's like I end up you know
causing a bug in my program because I
accidentally over rrow the behavior of
superclass completely unintentionally
this is a downside of uh implementation
inheritance now in contrast the the
composition approach is basically where
saying okay well instead of using
subclassing to override the method um to
add new functionality I mean why is it
that I'm subclassing well it's because I
want all the behavior of the parent you
know I want access to all that behavior
but I want to do some other things that
are different what I can do instead of
that is I can essentially well okay I'll
just make a new class which has the
original thing as a member of that class
so now I can still access all of its
functionality but I'm not changing any
of I'm not overwriting anything uh in it
all of its methods are still there still
intact there's no chance of me causing
that bug that I just described if I do
it in that style but of course once
you're doing this it's like well that's
just nested structs and C you know every
every programming language could do that
functional procedural Etc so at this
point we're we're not really talking
about like sort of a strength of O
arguably this could you could say that
the fact that implementation U uh
inheritance is a is a downside of oop
the fact that it's like the foot gun is
there when it's recommended to do this
other less error prone thing
instead okay so going back to the idea
of like the essence of the Paradigm um
procedural you know use procedures over
go-tos functional like procedural but
with the added caveat of avoiding
mutation side effects and then we're
going to break down oop into two
categories for Allen K this is messaging
and extreme late binding of all things
and for a y STW strip it's hierarchical
code sharing uh through implementation
inheritance which is kind of disfavored
in FA in favor of composition okay so
there ends the longest section of the
talk um the differences in features now
let's talk about the differences in
style between object-oriented and
procedural programming so it's pretty
hard to find uh like someone actually
saying here is how to do the procedural
programming style um not quite the same
level of hype as the objectoriented
style um you know even this many years
later um the the best thing I've been
able to find is this YouTube video that
has 2 million views which is you know
not an entire bookshelf worth at at
Borders but uh you know that's a lot of
views for programming talk so um in this
talk he he definitely talks about like
this is we're talking procedural and
imperative so this is not a talk about
like functional programming style but he
does talk about sort of what he sees as
the essence of the procedural style
which is something that does have things
in common with the functional style
namely that he says look this is about
let data just be data and let actions
just be actions that's the essence of
the procedural style so not doing this
hierarchical organization of classes and
subclasses just data and procedures that
operate on that data that's kind of it
and put them in modules if you want to
have encapsulation um so he goes through
four different examples in that talk um
of essentially taking objectoriented
code and then without changing the
language rewriting it into what he sees
as like the procedural Style version of
that um so one of these that he uh he
did he took an example from Sandy Mets
one of her talks so Sandy Mets awesome
human being just lovely delightful
person also complete Authority when
comes to object-oriented style like
absolutely legend in the community um
and uh so you know this is code that I
think is is definitely fair to say is
like representative of good
object-oriented code um so in that talk
she sort of refactors some code that has
some problems and ends up with this uh
this has three classes FTP downloader
patent job and config and nine total
methods and the refactored version um
has no classes five total procedures and
they're all named after verbs I
mentioned the verbs thing because uh
there's this blog post by Steve Yi um
called execution in the Kingdom of nouns
that the the author of that talk
referenced in that talk and this is a
talk mostly about sorry this is a blog
post mostly about Java um Steve writes
classes are really the only modeling
tool Java provides you so whenever a new
idea occurs to you you have to sculpt it
or wrap it or smash at it until it
becomes a thing even if it began life as
an action a process or any other non-
thing concept um so in other words you
might look back at this and say like
okay why do we need a thing called FTP
downloader couldn't we just write a
procedure that says download over FTP
that type of thing why do we need a
patent job why don't we just have a
function that says you know process the
patent um he goes on to say I've really
come around to what Pearl folks were
telling me eight or nine years ago Dude
not everything is an object um fair
enough that that's there's there's
definitely something uh something to
that idea even though I distinctly
remember back in the 90s the first time
I heard about Java and i' had been doing
um C++ before that I thinking like oh
everything's an object that's really
nice and consistent I like that but much
later I kind of came to appreciate this
perspective too where it's like okay
maybe I I would like to have you know
the less of the I what I have is a
hammer and everything starts to look
like a nail so this idea of like nouns
and verbs like you see in the
object-oriented version you have a class
called FTP downloader in the procedural
rewrite he just says yeah we're not
going to have FTP downloader we're just
going to have FTP download file that's
just a procedure that downloads the file
over FTP instead of a patent job class
he just says we're have two uh
procedures process pth patent and parse
patent and then config okay fair enough
that that makes sense because that is
just a piece of data um he didn't make a
separate class for that because you know
in Ruby you don't have to but point
being that this is sort of much more
verb oriented the noun oriented because
he decided that was just the better fit
for what they were doing in this in this
case um now this idea of hierarchical
classification of like classes and
subclasses and you know implementations
uh inheritance is not unique to oop for
sure I mean hierarchical classification
you find all over the place for example
in math so this is like the numeric
hierarchy in lisp which okay maybe
according to alen K that subject Orient
but I think most people would say that's
either functional or procedural uh there
just is a hierarchy here you look at hll
you can of see again further
mathematical hierarchy of monads and
applicatives and foldables and funter
and stuff like that again like
hierarchies definitely appear in
programming language it's not like
hierarchy is only an O thing but you do
see a lot more hierarchy in oop than you
do in procedural or functional how many
people have gone through an
objectoriented programming tutorial
where you saw something like this like
dog inherits from animal uh you know
inherits from vehicle uh you know
bicycle does too yeah okay so this is a
really common thing you don't really see
this in tutorials for procedural
programming or functional programming
this idea of hierarchy is really kind of
essential to especially the buan strip
School of of C++ based o that just kind
of isn't there for procedural or
functional Styles um this is the uh the
the sort of class hierarchy um inside
Ruby for all sorts of different things
in the standard library and you can see
that like for example just within uh
errors we have like um float domain
error which is a sub class of range
error which is a subass of standard
error which is a subass of exception
which is a subass of object now there is
one way you can organize errors you can
certainly say like this is a that is a
that is a that but it's not the only way
to do it um again in Java we see here's
like the the standard Library this is a
mix of interface inheritance and
implementation inheritance if I just
kind of zoom in on Treet at the bottom
here um this is this has an equivalent
in in Rust so in Russ this would be a b
tree set in the standard collections
package um tree set inherits in Java
from sorted set which inherits from set
which inherits from collection inherits
from iterable whereas in Rust you have
these things called traits and there's
just a flat list of them so you still do
have a bunch of different things that
you can do with a a b Tre set it's just
that there isn't this hierarchical
description it's just that's just not
the focus and Russ because Russ isn't
object-oriented um all of these things
that I just talked about are examples of
abstract types this is a particular type
of abstraction so interface for example
in Java this is an example of abstract
types so I'm saying hey a shape I'm not
telling you anything about how the shape
is in memory all I'm telling you is if
you give me a shape whatever that means
it has some method on it called area I
can ask it what its area is it's going
to give me back an integer see the same
thing in go even though go is not
object-oriented says you can have an
interface about shape just like yeah all
I know about this thing is if I ask it
for its area it gives me like an integer
same thing in Russ except now it's
called a trait instead of interface but
same basic idea I I got this thing
called a shape if I ask it its area it
gives me back an integer and in has
school as well with type classes you
know it's different syntax different
name the thing all these are just
examples of abstract types rather than
concrete types so concrete type might be
for example a uh like a rectangle that's
you know got a particular implementation
of area that's specific to rectangles or
triangle that it's got a particular
implementation of area that's specific
to how it works in triangles um so again
it's this fundamental idea of if I have
a shape all I know about is I can ask
for its area and get back an integer now
these are all in statically type checked
languages I can't quite say as much if
I've got a dynamically typed language
like python so in Python again this this
looks a little bit different so I say
class shape and then deaf area and then
the the Convention as as far as I've
been told I'm not actually a
professional py python programmer and
have most python I've done is helping
other people with their python homework
um but apparently this is the style is
that you define the class and then you
say you raise a not implemented error by
default and the idea is that if you want
to make a concrete class uh like
rectangle then you would say okay uh I'm
going to define the area to actually do
something like the actual implementation
of the area of a rectangle which is the
width times the height okay you can do
something similar in JavaScript but you
can do it with prototypal inheritance
like we talked about so I'm again using
the 1995 JavaScript logo um so
prototypal inheritance version looks
like this got function shape I don't
know why they use function for that but
that's how it works shape. prototype.
area equals and then you define
essentially the implementation to
initially just you know throw an
exception and then you can overwrite
that for a particular like rectangle
prototype um where you implement it as
you know width times height just like
before and then you can say answer
equals rex. area now another thing you
can do in JavaScript is you can do this
in a completely not object-oriented
style if you want and get exactly the
same sort of data abstraction at the end
of the day so here's how that might look
you might say w equals and this is just
like an anonymous object I'm not
defining any classes I'm not doing any
prototype of stuff here area is a field
on the record or the object that is a
Anonymous function that just says return
rec. width time re. height so what is re
here well this is just from the outer
scope this is just an example of a
closure that's capturing something
outside of its scope essentially inside
a function in JavaScript I'm allowed to
refer to variables that were defined
outside the uh the object or the
function including you know things that
are ultimately getting defined uh like
right now in the middle of this thing so
this is a a way that I can write some
JavaScript implementation that will let
me call answer equals rec. area exactly
like before and it's going to do the
same thing except that I didn't use
classes I didn't use prototypes at all
so this is an example of just a
different style of achieving the same
data abstraction so again I could do the
same thing but make it be a triangle so
now instead of Rec do area it's Tri area
and base times height over two instead
of width times height totally fine and
then I could use the fact that I'm
allowed to do both of these to
generalize this and make use of that
abstraction and write a function that
just says hey I'm just taking in a shape
I haven't even defined what a shape is I
didn't write down the word shape with a
capital S anywhere in here there's no
interface there's no class there's no uh
prototype it's just I just wrote a
function wrote a function here wrote a
function here and now I can call shape.
area without knowing whether I'm going
to be getting rectangle style uh withd
time
or triangle style base time height over
two both of those are going to work
because I've abstracted over shape like
this and I did it without doing any o
stuff this is just another style you can
use um I could even take that a step
further and say well let's suppose I
don't have this language feature of
being able to refer to things uh outside
the function maybe I'm writing C for
example which doesn't have that feature
well I can I can make it a little bit
less convenient I can say I'll just take
an explicit argument rather than
referring to that one and then say
whatever that argument is base times
height and now when I call it I have to
do shape. area passing in shape which
looks weird but I can do it like it
works i' I've achieved the same level of
abstraction by doing this I still have
the ca the situation where I don't know
anything about the shape other than it's
got an area method I can still call that
and get either base times height over
two or WID times height depending on
whether I was given a rectangle or a
triangle all of that sort of fundamental
abstraction stuff still works it's
really just a question of how convenient
it was or wasn't and this is a really
important theme of what Paradigm does
and doesn't get you it's not so much
about getting you something that you
couldn't possibly do before it's really
about how well supported that is so we
can see you know we have just seen lots
of different ways to accept abstract
data in a function or a method so
interfaces traits type classes closures
non-closure functions or even you know
if you in C you could go as far as
function pointers all of these are ways
to achieve the idea of abstract types
and uh passing abstract data between
functions they just have different
ergonomics trade-offs and different
stylistic trade-offs so putting all that
together language paradigms are less
about what styles programming are
possible come on they're altering
complete languages right that means
anything's kind of equally possible it's
really just about how well those styles
are supported and also what styles the
ecosystem Embraces like if you're doing
that last style I showed where you're
calling like shape. area passing in
shape nobody else in the JavaScript
ecosystem is doing it that way that's
kind of weird similarly if you're trying
to do that sort of like kind of
overloading style in C probably not
going to find too many people doing that
unless it's you know they're they're
trying to do something very specific so
really putting all this together
regardless of what features are present
in the language you can choose to do
things in a different style that does or
doesn't necessarily work well with those
features it's really kind of a question
of how well supported are you going to
be in that how you know how good are the
ergonomics going to be of that style
that you're choosing to write in and
what's the ecosystem like around that
okay so the procedural style to wrap all
this up I'm claiming is programming with
less hierarchy organizing code into just
plain old dat data and procedures and
essentially just using modules from
modularity instead of classes for
encapsulation because they get you the
same public private thing okay so which
brings us all to the uh the shortest
part of the talk what changed putting
all this stuff together so walking
around in borders I'm seeing all these
great looking books about
object-oriented programming and now you
know I think back on that time a couple
decades later and I just have this sense
of having spent time with O and Industry
and remembering all of these sort of
promises of like this is going to make
things so much better it's going to be
like an a really good answer to
complexity programs are going to be a
lot less brittle and stuff and I just
feel this sort of sense of
disillusionment like it was really
exciting back at the time but now kind
of the shine is worn off it it doesn't
feel like this exciting new thing that's
going to solve a lot of problems I
mainly think about a lot of a term I've
heard a lot when talking to people about
this talk is people say like broken
promises or not living up to the hype um
I mean you know I think about a book
like clean Cod it's like man who who
doesn't want clean code I don't want
dirty code I want clean code and then
you think well okay you know that's
that's an exciting promise but then then
you think about like well uml diagrams I
don't know was that an improvement over
procedural programming uh yikes that was
okay maybe not and you think about like
abstract Singleton proxy Factory being
like was that was that like that's okay
I mean is that a step forward I don't
know so now that we've sort of gotten
well past the sort of honeymoon phase of
O and the like excitement phase and kind
of started to see like some of the
excesses or things where things went too
far there's this reasonable and sort of
natural reaction to kind of go back and
revisit like was this the right
direction in the first place and in a
lot of cases a lot of things about o
were likable are nice and you know
there's there's plenty of good reasons
that o languages continue to be widely
used it's not like everyone's like throw
it all out but there's also plenty of
reason to understand why people could
say yeah you know what I don't know I
don't know if it was worth it I I I I I
kind of want to take a step back and
maybe revisit some of the earlier things
especially now that we've got a lot of
modern conveniences like modules that
are mainstream that weren't back in the
days before oop came out um a lot of
people are looking at code like this and
saying yeah I mean I could put this in
three classes named after nouns and have
you know nine total methods or I could
just have like five procedures named
after verbs I don't know I really
missing out on a lot is is this code
really going to be brittle and hard to
maintain cuz at a baseline it seems like
there's less code there it's not doing
as much it seems easier to follow I mean
I hear you what you're saying in a lot
of cases you know oop thought leaders
and things like that about you know oh
as your code base gets really really big
you're going to want this stuff but then
a lot of us have had experience working
in large oop code bases and thinking I
still had those problems I just had all
this other stuff in addition to those
problems so yeah disillusionment it's
common thing that I hear when I talk to
people about this topic um especially
when you consider like well if I want to
do stuff like abstraction polymorphism
you know things like that encapsulation
there's just lots of ways to do that I
can get encapsulation from modules we've
seen lots of different ways to accept
abstract data it's not like classes and
subclasses and interfaces the only way
to do that um composition over
inheritance kind of makes sense and if
that's what I'm going to be doing anyway
do I need inheritance is just kind of
this thing that I'm supposed to avoid
but in a lot of cases the libraries I'm
using are using it anyway so I kind of
can't avoid it is that is that a pro um
are we really still doing messaging
extreme late binding of all things or is
that kind of like well you know it's
cool that that was the vision but that's
just not what people are doing in the op
World anyway so putting all these things
together it it starts to feel not like
the end of the era is now but maybe like
we're kind of heading towards the end of
an era maybe we're past the peak of oop
and there's a reason that procedural is
coming back which is just that people
are saying yeah I don't know I I think
maybe things were a little bit better
and a little bit simpler uh in the old
days and I think that is sort of a trend
and it's it's why we're starting to see
new programming languages saying
explicitly yeah you know what we're just
we're just not going to do that we're
we're going to explicitly need
procedural um we're not going to go in
the C++ direction we're going to say you
know start with c and then try to fix
some of the problems and you can see
analogies with that in other languages
not just low level system languages
granted a lot of that is you know going
in a functional programming Direction
but it's the same kind of idea it's
saying like let's do less hierarchy
let's just have plain old functions and
data and we think that that's just going
to make our lives better it's
understandable so what changed well
essentially to put all this stuff
together many of object-oriented
programming selling points are today
just common place in other paradigms and
many of its other signature features
like inheritance message passing late
binding have fallen out of favor in
favor of things like static type
checking just not doing messaging and uh
and doing composition over inheritance
so putting all this together it's sort
of like well if you're going to be in
the inher uh imperative World procedural
programming today offers a lot of common
selling points without the disfavored
stuff so if if you're sort of on board
with this idea of hey what if I just
want to let data just be data let
actions just be actions so maybe you can
understand why we're starting to see
return of procedural
programming thanks very
much hi awesome talk thanks so much just
a really quick question uh there's a
kind of cynical view that like more
class-based programming languages kind
of force you into one style I'm thinking
Java in particular whereas you have much
more freedom which means people can kind
of do whatever they want and you don't
have like a unified style guide unless
you enforce those patterns could you
maybe speak to that a little bit with
this kind of like move to a new paradigm
yes the question is like there's
somewhat of a cynical view that you
could look at and you could say like you
know Java especially you gave the
example of um sort of forces you into
this like hierarchical style and and
like you know noun based programming and
so forth whereas other paradigms like
procedural and functional give you more
freedom to explore I think I don't know
if that's necessarily cynical I think
you could you could very easily look at
that as a good thing or a bad thing like
in some sense like I said a lot of the
things like when I talked to people
about this topic that that come up are
people saying you know what I really
liked about oop is it was really clear
how to organize my program is like
around classes and you do lose that if
you say we're just going to have modules
that don't really sort of uh give you
that really strong push to being like
I'm going to collocate my my data with
the you know the operations that that
work on it um so I would say it's
accurate in the sense that like
certainly Java does very strongly push
you in that direction I remember
thinking it's really cool in Java like
when I when I first used it that like
everything is an object except for
Primitives that actually really bothered
me that like int was like not an object
and I heard it wasn't Ruby I was like
cool um but at the same time it was also
weird that like you know before you had
like public static void main you had to
put that in a class and I was like huh
it's like it's where the program starts
what why why am I making a noun out of
this it just felt weird um and it still
feels weird so I see there's pros and
cons to that um I don't know that it's
like you know all upside or all downside
there at least that's my perspective
yeah
it's so weird to me that still water
comes in a can because I I feel like I'm
like oh yeah time to hit the sauce after
that talk so speaking just for myself
oop was all about tying together the
data with the methods that work on the
data um and I think that that idea has
persisted so if you look at rust you
have a struct and then you have an imple
if you have go you can Define functions
with a receiver that just looking at
your code looks like you're working with
objects comments totally yeah so so you
know the idea of like coupling data and
you know the operations that work on it
especially like into a namespace
especially with like public and private
I think that that like has turned out to
be kind of a good idea um the
interesting thing though is the question
it's to me the interesting thing is the
question of hey do you have to do it
that way or do you make that like a
convention that's sort of opt in and
maybe you can also have modules that
that don't do that or maybe operate on
multiple data types at once um and then
B the question of okay let's say that
you have organize your code that way
what does that imply like you you gave
the example like rust traits and like
impul like even even if you're not using
traits you can still like have an imple
just to get the sort of method looking
syntax um which I personally do in Russ
code all the time um but then the
question becomes well what are the
implications of doing that and in rust's
case if you're not using a trait the
implications are really just kind of
syntax it just looks kind of method um
and also there's like some type
conveniences you don't have to like
repeat the type in as many places you
can just say self and that just is
whatever the type of the original thing
was um but what you're not getting is
you're not opting into like inheritance
you're not saying oh well now people can
subclass this or you know I I might be
subclassing someone else and overriding
things that whole part of it is sort of
gone and that does seem to be something
that's a pretty bright line between the
like object-oriented languages and the
procedural and functional languages is
whether or not sort of coupling data to
uh the functions that operate on it
involves subclassing and overwriting
like
that but I think the fundamental idea is
like yeah it's a good way to organize
things think that's uncontroversial at
this point and also credit to op for
popularizing that I think other
questions okay thanks very much
