okay so today we are joined right here
by Uncle Bob the Robert Martin himself
how you doing I'm well thank you why
don't you give like a kind of an
introduction to who you are so anyone
that doesn't know they can get to know
you oh heavens um yes I'm Uncle bobber
I'm Bob Martin some people call me Uncle
Bob I've been a programmer for um 50
some odd years uh written all kinds of
code in Assembly Language and c and
Fortran and cobal and and uh C++ and
Java and nowadays I work in closure
that's the language I enjoy uh you may
know me also as the author of uh clean
code and a whole bunch of other books um
over the years so that's who I am you
also signed the original agile Manifesto
2003 February 131 February 2001 yes
that's true we were all there together
yep 17 us
I just have to ask how did you get to
closure because I I did read that
article where you talked about closure
and all that and I think that's how we
had our first introduction is me reading
that article which I just find closure
to be such a bizarre language jump from
uh from I guess the more like uh will we
call it Enterprise Java style
programming yeah so um yeah it took a
lot of therapy to get the closure um
somebody gave me a book recommendation
20 years ago and the book was uh the
structure and interpretation of computer
programs uh an old book right out of the
80s and I I got the book I think I got
it on eBay um and it was a secondhand
book I stuck it on my shelf I didn't
read it for a while and then one day I
started just thumbing through it and the
book just captivated me it was like one
of those moments when like oh my god
what the hell am I reading here and
what's the name of the book again can
you say the name one more time the
structure and interpretation of computer
programs which you can get for free
nowadays it's sip. org I think okay I
don't think I've ever read that oh yeah
well you can Google it you can get it
for free you can also see all the old
lectures by abson and susman they're all
online and you know 1980s guys drawing
parentheses on the
Blackboard very very fun fun stuff to do
but the book um just catalyzed me it
energized me I thought well this is
interesting and of course the language
was lisp or it was scheme right a lisp
derivative and I thought okay I had for
30 years thought I'm never going to
learn lisp I don't want to learn lisp it
sounds like a dumb language no I'm
currently on that team and I'm I'm
crossing my 20 year mark so I'm
close Okay so I read that book and it
changed my mind and I thought okay I I
got to get a list and I just happened to
bump into closure I I had known Rich
hickey off and on for for long years cuz
he used to debate on the
C++ uh news groups back when there were
news groups uh and I saw his work on
closure and I thought I'm gonna get this
language I'm gonna didd around with it
and this was probably n uh
2010 uh and I just fell in love with the
language it was just wonderful uh and
I've been using it ever
since wow okay yeah what is like
just because I I'm I'm I'm fairly kind
of stuck in my SE look language ways I
generally don't I I just we were having
a talk earlier that I think one of the
reasons why functional style languages
are largely unsuccessful is because
their syntax is stupid is what I was
saying when I say stupid I mean that the
average person who's had 10 years of
programming that looks at functional
syntax they're they're just like
incapable of just even reading it to
begin with it's just so Divergent from
what is like kind of the Zee to
programming and so
how was how was that transition because
that is that that's clearly a weird you
you fell in love with it was there like
a hard period was there a time where
you're just like why am I doing this to
myself so the the syntax of lisp and
therefore closure is so absurdly simple
that there is no syntax uh barrier to
cross and there there's almost no syntax
to the language so the most startling
thing when you get into it most
startling thing is you're asking
yourself where where are all the handles
how do I control this language where's
the class keyword where's the type
keywords where are all these keywords
and the answer to that is there aren't
any and all you really have are a couple
of very very simple gestures uh which by
the way makes the language
remarkably expressive the less syntax
the more
semantics as it turns out so um is that
good or
bad both okay it's both good and bad
it's a it's a double-edged sword uh
although I I air on the semantic side I
like the expressivity uh if you've ever
done any
fourth I have not done four another one
of these languages that has almost no
syntax small talk another language that
has almost no syntax there are a few
languages like that and they become very
expressive because you're not
constrained by this big syntax Iron
Curtain that drags around you all the
time yeah but you have freedom to kill
yourself so so that does that mean
because I've heard this stated before
and and I I don't quite understand it
because I don't have the experience with
lisp to actually like really concretely
understand this besides for you know a
square uh on a Blackboard that uh every
kind of lisp program is almost its own
unique language onto
itself is that does that kind of follow
up with because you can kind of Define
everything yourself CU there is no real
um there is no real syntax as you said
and so people kind of really create
their own structures in every kind of
unique way and so when you go from one
to another you have this like you kind
of have to adopt the person's mentality
who wrote it this is generally true of
every language right when you're when
you're a programmer what you're really
doing is you're inventing another
language to express your problem in in
in lisp the the syntax is so sparse that
all you're doing is inventing another
language to express your problem in
without the constraints of the language
syntax the uh the language also has a
number of features that make it very
easy features is not the right word um
affordances is a better word that make
it very easy to uh add facilities to
what appears to be the
language I'm being obtuse on purpose but
but there's no other way to say
that okay okay I I think I I think I
understand what you're trying to say if
if I were to resay that it sounds like
you're trying to say
that the language allows you to make
things that look like it's a part of the
language that's correct and not
something you've created thus this whole
idea of you kind of invent your own
every list program is its own language
onto itself is partially in some sense
true yes that's certain certainly
true I I again I'll say also that every
every programming language does that but
it's most pronounced in a language like
BL okay so how do you how do you
reconcile because I you know you may
have heard of clean code how how do you
reconcile some of the approaches that
are suggested in there with a language
like closure because it sounds like
closure is much more Wild West and has
very few
constraints um so you have to be more
disciplined in closure there's you
because you can go off the deep end
really fast uh but the the clean code
book is all about discipline so the the
ideas in the clean code book move very
well over into closure there's not
there's no real friction there okay I
like to keep my functions nice and small
I like to keep my names expressive I
like to keep my modules relatively small
all of that is very easy to do
in does does it have a concept of
interface
yes it does uh you can have polymorphic
interfaces there's like three different
ways to do that uh since closure rides
on top of the Java stack you can
actually create Java interfaces that a
Java program can call uh although you're
doing it all in closure and you can also
call Java interfaces from closure so the
the interoperability between the closure
language and the Java stack is almost
perfect not quite almost
yeah okay that makes sense I mean a lot
of the jvm languages you can kind of
call between uh we did a lot of groovy
you may be familiar with that y that
idea we'll call it an idea um we I did a
lot of groovy at one point and it's uh I
mean you can call Java functions really
easy you know a lot of concurrent hash
maps and all that
but it was an experience nonetheless
kind of working between jvm languages
can sometimes be fantastic and sometimes
be a huge
pain so all right so you you're you've
been off in the closure land and all
that and you know there's a lot a lot of
neerish languages go um and rust I think
are probably the two most big kind of
splashy new languages if you will call
it new and splashy uh that a lot of
people have been kind of very excited
about H how does clean code intersect
those two
languages uh I don't know a lot about
rust I've only kind of looked at it
cursorily um go I'm a little more
familiar with I've done a little bit of
work in go
I mean go is essentially C with a couple
of widgets uh attached onto it and and
uh very easy to do clean codish like
things in in any language that's derived
from C and any of the C style languages
clean code is real easy to to work with
um in fact I'm not sure there's any
language that you could not apply clean
code to except maybe
Cobalt well Cobalt is very very unique
onto itself i' I've I've only done
probably like 10 hours of Cal it's uh
it's very very tricky people are also
saying is this
true is Pearl is Pearl also is Pearl
also clean
coatable
uh probably not that's okay
that's I actually have I have a I have a
friend that may or may not be in this
chat whose mother programs Pearl
fulltime wow I know no that's I didn't
even know that was a position I didn't
even know that was
possible permanent Pearl programmer
permanent Pro Pearl programmer the the
triple P all right so let's get kind of
into some more the the fun stuff so the
general goal here today is that I'm not
trying to make this into some sort of
debate I think debates largely tend to I
mean the purpose of a debate in my head
is that you try to make the crowd think
like you and not necessarily come to any
sort of agreement or understanding of
one another's argument as much it is to
try to defeat the other person if that
makes sense um and so I want this to
kind of be more of like how do you think
about things and then I'm going to try
to represent as best I can maybe
Twitter's General thought process
twitch's General thought process which
by the way could be very room
temperature IQ uh for for you to kind of
talk back and forth with does does that
sound good sure that sounds fine all
right so I the I I think for me the most
important question to ask is that in the
last about I'd say in the about 15ish
Years cuz when I went to college and
when I started going to college clean
code the gang of four this kind of this
kind of we also had Java as our primary
language of uh of learning programming
with was a very like important part when
I would go into interviews it was always
like all right tell me the you know tell
me the design patterns that you know can
you explain this in you know in these
terms right solid was brought up a lot
all that kind of stuff but then as time
has gone on it feels like that's no
longer talked about uh I I really don't
ever hear the term design pattern ever
discussed among anybody uh what kind of
what kind of has caused this shift and
do you think it's a it's a direct
shifting away from something like clean
code or is it just a nomenclature change
among
people what has caused the shift is what
has caused that shift in the last 50
years the same it's the same effect and
and the effect is that the demand for
programmers is so large that the number
number of programmers in the world
doubles every five years or so and
there's no way to keep up with a um a a
a way of thought when you've got a
doubling of the number of people pouring
in right so you might have some thought
leaders from 30 years ago who had some
really good ideas those ideas have been
swept aside by the wave of people just
pouring in and it's very very difficult
to maintain any kind
of um consistent mode of thought when
you're in that kind of demographic
Deluge yeah that makes perfect
sense one of the things I try to do is
yell out enough so that people remember
some of these things and bring them back
into the present so that they can look
at them and go oh there are these things
called design patterns gee I didn't know
anything about that well maybe I had to
read something about that by the way you
know the design patterns book is
probably the most important book written
in the last 30 years and it's been swept
away by this wave of incoming people uh
do do you think that a lot of modern
software can have the same benefit with
these design patterns uh because I I'll
I'll tell you like personally I I pretty
much am a strategy pattern guy right I
think the strategy pattern really is the
basis of all patterns right I mean it's
pretty much that is life is strategy
that's pretty much just use an face um
do you think that much beyond that
knowledge and the Builder pattern that
there is a lot of usefulness still to
continue to like dive into these
patterns oh there's a ton of usefulness
to it because the purpose of a design
pattern is to have a name on a structure
so I can say to you well I think we
ought to use the visitor pattern here
and if you know what that pattern is
which you're right it's just a bunch of
strategies but if you know what that
pattern is then that structure snaps
into your mind and you and I can have an
intelligent discussion about it and we
can have a a a discussion of the of the
pros and cons or if you're sitting there
reading code and you see oh this is the
XYZ decorator and you happen to know the
decorator pattern then the structure
snaps into your brain and you don't have
to work it out by reading the code
perfectly right that's the whole point
of design patterns to say a way to take
one notch up on the level of abstraction
so that you can look at things in the
code and identify them without having to
go line by line by line by
line yes okay no I mean it's a very good
answer because you know we often have a
lot of data structures or algorithms if
I say hey this is a general tree you
already know what a general tree is
right you don't have I don't have to
explain to it that you have zero or more
children right like that's just not a
thought process we have to have so
therefore you could make the argument
that if we know what a builder pattern
is and I say hey let's use the Builder
pattern you and I are both probably
thinking something that's very very
close to the same thing it may be
slightly different but for the most part
at least close to the same thing okay so
I I think that's actually a pretty
reasonable argument for design patterns
um but one thing can I say it this way
that a lot of times what I see is that
when people kind of are really into this
because remember Netflix was a ja a
large Java shop was there for a long
time and so there was a lot of patterns
uh I I I often find people reaching
first first for a pattern and an
abstraction before the problem is ever
solved what do you think about that
because I know you're you're very into
the design first and then program kind
of approach you said that in Casey's um
gosh you said that in Casey's here let
me bring up your exact quote sorry I I
did do like a little I I did try to at
least read one thing right um You said
you said it was the latter zalot who
thought it was better to LEAP into code
without any forethought and that was
kind of like there was some context to
that of course but the the general idea
is that some people or your suggested
ways to like kind of design all things
and you kind of create the abstractions
and think about the structure of your
code before you start
coding is that correct am I am I am I
correct on that one um yes with caveats
but yes
okay a lot of like modern or at least
what I would call Modern thinking at
least like the go way of thinking is
that you kind of Almost Do somewhat of
the opposite that you don't reach for
abstraction first you actually try to
get the thing itself first out and you
allow the abstractions to more naturally
percolate or manifest themselves H how
how can you kind of resolve those two
School of thoughts no I don't think
there's a resolution there so so the way
I work is that I will I will do the most
concrete thing first I will think about
the problem you know I'll and and you
know the amount of thinking I do is an
hour maybe okay and you know maybe I'll
scratch a little design on a whiteboard
or something or a piece of paper I'll
think about it and then I will then I
will enter it if the problem is large
enough then I will do that and then I go
right for the most concrete thing I can
and then I I have the problem force me
to become
abstract as I'm adding more and more
code it starts to get harder and harder
to add that code without adding an
abstraction of some kind and so I let
the code force that abstraction upon me
and I continue that process and
typically you want up with an awful lot
of abstractions once you follow that
process do you ever knowing like let's
say that you have like I don't I it's
hard to always to come up with these
examples kind of off the top of your
head but you have something that you
could easily see into a series of if
statements or switch statements like
right you have a message type that
you're going to be handed it's a string
and the first one is just message and
then the next one you know there will be
more but there might not be many how do
you determine when to abstract vers is
when to go you know what if there's
three hardcoded strings I'm fine with
that like when when do you make this
decision
um for me it's a kind of feel thing as
I'm working in the code I look at it and
I I get this itchy feeling in in some
part of my face or gut and I think oh
man that's going to kill me later on uh
and at some point that's overwhelming
and then I make the abstraction but a a
switch statement with two cases three
cases probably not going to get upset
about okay is there do you have a number
that you put on it or is it really just
only feel like can can five be too many
like is there ever too
many well I I think yes you can say a
thousand is too many but um agreed yeah
there's no there's no hard number
because it all depends on the context
right if I'm if I'm putting together a
program uh for a demonstration that I'm
doing and I'm going to throw it away I'm
not I'm just not going to worry about it
very much on the other hand if it's if
it's for a client and the client has a
long Lifetime and they're expecting to
make you know a lot of changes to it
then I'm G to be a lot more
careful okay have you ever have you ever
had a situation let's kind of keep on
going with this whole message thing
right you're coming up with some sort of
custom protocol that's going to have a
various set of commands have you ever
reached for abstraction first and then
regretted it in my younger
days it's it's a hard lesson to learn
right you because abstractions are
beautiful and they're enticing and you
want to do them and it looks so Grand
and uh after a while you learn
well abstractions come at a cost and you
will pay that cost as soon as you use
the abstraction uh and it will not pay
you back unless there is some reason to
have that abstraction there so in my
younger days I did a lot of that but uh
having become old and jaded I try to
stay as concrete as I can until I'm
forced out of the concrete
world you know that's it's it's funny
it's funny you should say that because I
I often you know I we have enough people
hanging around here I don't know where
we're at right now let's just grab a
quick number 3,400 people currently
watching and I often I often see kind of
it's very hard to tell somebody a lot of
these rules that I've kind of come up
with like why do I approach software in
this kind of specific method and a lot
of it just comes from the fact that
exactly what you said which is well one
time I tried to make a game and I had
seven layers of inheritance you want to
guess how much I hated that experience
yeah I I really did hate that experience
because not all burgers are
cheeseburgers and eventually you're just
like I just need a whole new burger
archetype you know like it just it just
you just lose it and you kind of have to
go through this experience a bunch of
times before you kind of have like a a
general feel of software and based on
the things you're saying you're actually
not really far either from the go
philosophy like it is good to sit down
and kind of think about what um you know
kind of what you want to build here I
generally I I generally don't feel like
I have to think hard in the sense that
whenever I give a problem I just know
the structure I want it to be and that
is usually good for what I know what the
inputs should be which obviously all
good all good plans die at first Contact
right like they never they never go past
that and so it's like oh I was totally
wrong about like eight of my assumptions
I guess I have to redo all these things
um have you ever been into the uml days
like was there a point in your career
where you were like big in the uml and
oh yes
absolutely
mind okay about this cuz I was so heavy
into it that's where like all my seven
layers and all these things came from
was that I was umling and dotting and
compos it you know I was really into it
oh yeah yeah yeah yeah yeah now me too
and I still use uml from time to time
I'll draw some diagrams on a board I
know how to do it uh but that was a uh
that was a time when we thought that we
could capture software in a very
abstract way and the goal was for
highlevel analysts to draw these
diagrams and we wouldn't even need
programmers we could generate the code
from those diagrams that was complet
ridiculous failure I I I I may or may
not have generated some code from uml at
one point in my lifetime there were many
tools there were many tools that could
do it and and there's you can do it in
intellig today you can draw a uml
diagram and it'll generate code for you
but who cares you don't want to generate
code from a diagram that that has been
tried so many times and it has failed
every time it's like it's always the
wrong solution unless you have an
extremely constrained
environment yeah that that actually
makes a lot of sense I feel like if you
are purely working in a black box you
effectively can engineer that solution
out because it like everything is known
there's there there is no questions
right like I had a I had something I had
to build a long time ago for a little
bit of a satellite that had 256 bits
it's like you know what I could test
every possible pattern or there's 256
possibilities it was eight bits it's
like I could test every single
possibility and we can actually Design
This to the 100% there is no you know
like there is no possibilities that we
won't be prepared for but that's kind of
where I lost my uml mojo is after that
cuz I realized that as kept going I kept
designing these things and then again
first contact with the Enemy and my
diagram was completely wrong and I spent
so much time on the diagram oh yeah yeah
that's that's always a problem and back
in those days we used to think that this
is before agile before the agile
Movement we used to think that you
should spend weeks and weeks on those
diagrams get the diagrams right first
and then the code will just pour out
well that never worked yeah I spent six
months on one and it did it made it uh
it made it three hours into programming
before I realized that I made a program
so slow for a supercomputer it couldn't
run on a supercomputer and I was just
like were we smoking man it was bad six
months to be destroyed in three days or
three hours um okay well speaking of
agile that's that's pretty a a pretty
kind of a Hot Topic here um how do you
feel because you obviously signed the
original you're one of the signatories
or whatever they call whatever word they
use there of the original agile
Manifesto yes how do you feel like the
last what is it 23 years have gone since
the since the agile Manifesto has come
out I wrote an entire book describing my
feelings about that topic it's called
clean agile um I'm the old fuddy duddy
who's yelling at the young kids to get
off his lawn right the uh the agile the
agile message has gotten so badly
twisted and and torqued and perverted uh
that I I wrote that book to try and
reboot the whole thing say well nope
that's not what we were saying you know
what we were saying is something else
agile was a small
idea for helping small teams do small
things it was not the overarching
pattern of software development that was
to dominate the
world it was just a way to get six or
seven guys to be able to work well
together okay so what what made it fall
apart then
I can tell you that exactly um how long
do you
have I have to help my wife move in uh
26 minutes okay well this won't take
that long um one of us decided that we
wanted a scrum Advocate uh Ken schweber
decided that he wanted to teach a course
called the certified scrum Master course
and he came to me and he said hey Bob
can I borrow one of your offices so that
I one of your classrooms so that I can
teach this and I said yeah go ahead Ken
that's fine and he taught the very first
certified scrum Master course and the
and the idea just took off everybody
wanted to be a certified scrum Master
not one programmer wanted to be a
certified scrum master all the project
managers wanted it they wanted that
little checkbox on their resume and the
project managers flooded into the field
they flooded into agile they took over
the message they took over the
conferences they took over everything
and they literally pushed the
programmers out and adob became a
project management idea and the
programmers looked around like you know
they were left on the desert island and
looked around like well how the hell did
we wind up on this island and why are
they sailing away in our
ship that's what happened to
Agile so so what is the because I I
often make this joke which is agile's a
lot like communism you know people just
keep not trying it correctly um what is
what is the correct way to
Agile oh gee um it's a real simple idea
right uh do things in really short
sequences measure how much you get done
in every sequence use that measurement
to project an end date and tell
everybody that's kind of it we could go
into you know lower level details if you
want but that's pretty much it do things
in real short short segments like one
week long right measure how much you get
done
project that out with an end date and
then tell everybody hey that's the end
date that we look like we're seeing and
generally that date is so terrifying
that people are like oh maybe we've
got to do something about this early
enough to actually get something
done okay
um so so there there's so proper agile
has no dictates on how the team
accomplishes or even the timelines or
the weeks days that are used to measure
these short Cycles shall we call them
Sprints yeah in scrum they're called
Sprints the there are
individual um implementations of agile
so there's extreme programming there's
scrum there's FDD there's dsdm there's a
whole bunch of these processes that are
more do sounded like drugs more than
anything else are we sure we're on the
same
topic I'm pretty sure one of those is
the dream drug I've heard about
it yeah well
I think a lot of them are dream drugs
but but um uh they are more defined
agile is not agile is just this
framework that says hey you know do it
up do it in short cycles for CH sake and
and that's kind of it uh now I I happen
to be an extreme programming a fiction a
I like the disciplines of extreme
programming so you can you and I could
have discussions on things like PA
programming and test driven development
and refactoring and simple design and
things like that where we could get into
a lot more
detail but that's just an extension on
top of
agile okay I I mean I like this topic a
lot we don't have a ton of time so I
don't want to I don't want to linger
here too long but I mean to me that this
Mo M oh my goodness this mostly makes
sense in the sense that as far as I can
tell I think Netflix is one of the best
uh executors of agile in the sense that
no two teams operated the same every
team was independent to choose their
process how much process how much
process they wanted what is their Cycles
how are they making promises how are
they interfacing with other teams like
everyone was their own kind of tower
onto themselves and it largely worked
for quite some time obviously as things
kept growing things you know there's
always friction no matter which way you
choose we always said we choose people
over process which I think is the right
kind of way to go about things I think
that is very agile uh in in sense but
it's kind of good to understand kind of
how the breakdown effectively happened
and it makes sense that um if agile is
not applied on the individual basis it
will it becomes well just becomes a
series of meetings and all that how do
you convince like a company that they're
doing agile wrong and that you should
leave it up to individual teams and
individual teams should make their
choices because that inevitably suggests
chaos right like there is a level of
chaos to that that you cannot control if
two teams decide two different release
cadences yep
yeah where agile breaks down is when
people try to put an overarching
envelope around the outside and then
demand certain behaviors across the
board just was never designed for that
so so how do you convince someone that
they shouldn't do that right because
that's that's largely how agile is kind
of practiced today is that it's like
everybody it's you know standups five
days a week for everybody you know we do
this we do this we do this like how do
how do you say no no no no let those
three people make their own
determination let those five over there
make their own determination and then
they will figure out how to talk to each
other like how do you convince
management of said of that that because
that sounds like the wild west sounds
like
chaos so I do that by writing books and
yelling at people and things like that
but but how would how would someone do
that if they were trying to introduce
agile into a an organization yeah how to
introduce agile into an organization
with scrum shall we say oh okay yeah how
do you bring scrum into an organization
so that always sorry say it again the
inverse that it has scrum the kind of
the ridiculous you're like now let's
introduce agile let's how do we
introduce the actual concept into this
place how do we undo the scrum poison
um I don't know how you do that I don't
know how you how you convince people to
behave in a different way uh my whole
career for the last 30 years has been in
trying to convince people to behave in a
different way and I've had uh some
moderate amount of success just by
yelling loud and Publishing a lot uh but
when I get into an individual company
it's very very difficult what what will
happen to me is that I will wind up
leaving that company with one or two
people who kind of got the light bulb on
their head and then they leave they
leave the company they go somewhere
else that might not be the best um
selling for your Contracting at all be
like by the way if you bring me in you
lose some
employees well I don't do that anymore I
don't do any of that stuff
anymore to say that yeah all right all
right I want to get to the the the
things that I think are more probably
exciting for me so I have a I have a
really dumb rule of thumb when it comes
to programming and it's it's a personal
rule right which is that whenever I see
columns exceed 80 I generally think what
am I doing here now I I don't have a
problem with columns exceeding 80 it's
just kind of like a general heart
mentality that when I've done that I
kind of look back and go man I probably
have a bunch of like maybe I have a
nested function in here maybe I have two
four Loops that are nested I've just
I've done something here that's probably
slightly unusual to get out this far
unless if I'm of course programming Java
or C++ then it's you know then you have
to extend that line to a new new
position um you have one which is you
don't like functions Beyond four to six
lines you know like that's your kind of
smell how did you arrive to
that because I I I have I have a few
question questions on this so how did
you get there so first of all on the
linewidth side I don't set that at 80 I
set it at 120 I did a statistical
analysis on that and found that that if
you go beyond 120 you're outside of the
vast majority of programs ever written
yeah yeah again mine mine is completely
irrational so I'm not saying that you
have to have rationality described this
is just my feeling punch card width so
that's
rational 80 columns we've been living
with that for uh 50 60 70 years now yeah
um uh function width function height
right the number of lines in a function
I don't really have a limit there um I
have said a number of times that I like
four or five or six I think that's a
good size for a function if I ever get a
function that's 10 lines long it's not
like I'm gonna throw it out it's like oh
it's 10 lines long wonder why and then I
continue on um I like them to be small
and the reason I like them to be small
is that if a function does more than one
thing and I can pull the two things
apart and give them individual names I
find that to be more readable that's
that's the bottom line that's the only
reason would the inverse could you say
this kind of an inverse which is the
more functions you have to go through to
understand what is happening also the
more contextual overhead you have to
have cuz I can imagine if I had to have
20 lines on screen that kind of describe
a few step process I can kind of keep
that in my head cuz I don't even have to
like use an LSP I don't have to use
anything to jump to these definitions
they're just like right there in my head
but if you're always splitting these
functions up it can also be difficult to
be like okay what does this function do
okay well this function is broken into
two more functions what do those two
functions do okay now understand those
two let's undo that one let's undo that
one let's go to the next one okay now we
got to go you know you kind of
effectively build a tree in your head of
what is happening H how do you prevent
that type of explosion with that type of
rule so I don't prevent that type of
explosion if if if that happens to me
there's a single keystroke which will
just pop those functions back in right
the inline refactoring so in intellig I
can just go you know control all then
control all then control all then and it
puts that whole function back together
and I can read it so if I find myself in
that situation then it's easy for me to
undo it I also then realized that I had
partitioned it incorrectly because if I
find myself that situation it's because
I did not put those functions apart
correctly I did not give them the right
names so that's a test for me right I
can undo it and then redo it in a
different way that maybe flows a little
better the fear that you will drown
underneath a sea of little tiny
functions is not a very good fear what
you want to do is State what each
function does give it a nice name so
that when you see a function and you
read it you understand what it's doing
without having to read the next function
down if you can get that goal if you can
get it so that you can read a function
and not have to understand the next
three functions down you've gained a big
leg up on the problem of understanding
what a system
does yeah I I feel like that's true if
mutation is low in the sense that if you
have a complex enough problem right like
if you write let's just say any new
modern UI framework and you're in in the
driver's seat and you have to sit down
there and you have to do the actual
writing of the framework right that
would be uh understanding what a
function does simply by its name could
become excessively difficult if you've
ever read through any of the source
codes anything like that even though you
can kind of understand it you kind of
have to read the code to First really
understand what these names mean and so
that's always been kind of one of my my
my problems because what what what I
personally find happening is that I have
a lot of these smaller functions and you
have a lot of this and then you go to
code review and code review is really
where I think a lot of these weaknesses
kind of show up cuz I can't look at the
code without clicking around hopping to
different files hopping to different
locations trying to gain it in my head
because it's like the code was written
to be LSP navigatable but
not
reviewable if that makes sense yeah I
understand I understand the fear and I
understand the experience you know I've
experienced that as well you you get
badly partition code and you're leaping
all over the place and you don't know
where anything is and you can't keep
anything in your head because you're
constantly going here and you're
constantly going there but that is a
smell that's a symptom that's not that
doesn't follow from the the process of
breaking things down into well
structured bits and giving them nice
names you can break things down into
little bits and giving them nice names
without forcing that jumping around and
that's part of the part of the uh part
of the discipline of clean code you
don't want to create those those uh
nests of Leaping
around okay if you you've looked in the
book you've seen that I like to order
the functions in the order that they
were called so inside of a class I will
say well here's the main function and
then below that are the ones that that
guy called and Below those those are the
ones that that guy called so that you
can read down in a single single scan
and stop at the point where you say oh I
think I understand everything I don't
need to read the rest
I don't get that last part that sounds
very difficult but I but I difficult yes
yes that's why I'm just like man I don't
know if I could I don't know if I could
do that uh I I generally have a a
different a slightly different ordering
but I'll grant that to you I put the
most complicated usually at the bottom
the Least Complicated at the top uh the
Least Complicated are easy to kind of
zip through where's the most complicated
tends to be very meaty and Slow Rolling
um okay okay I just wanted to get get
that out because I always have a hard
time kind of reconciling how how those
work and how they work in principle it
what it really sounds like to me is that
what you're trying to say is that you
need the program for 20 years bite your
shoot yourself in the foot a lot of
times and then a lot of these things
make more sense cuz I mean I'm not
trying to put words in your mouth but
that's generally the advice I tend to
give which is that you have to shoot
yourself in the foot a 100 times before
you realize how you shot yourself in the
foot and then you don't shoot yourself
in the foot as
often the way I like to to say it is
that I I like to be polite to the next
person
coming right so any kind of code that
forces someone to puzzle it out or leap
around is rude it's rude code and I
don't like my code to be rude I want it
to be
polite do you think that there I mean
isn't some level of code you have to
jump around you have to puzzle it out
because I'm not sure if names can always
convey the context because often the
difficulty isn't in some sense the names
though naming is very hard it's in the
state change and the state change can
really only be discovered by not just
what the function's name is but by
understanding why the state changes and
how that affects the next said calls
isn't there always going to be some
level of like sorry I mean that's for
that's why we both agree on the low
comment thing I think comments are
largely
useless accidental and essential
complexity there's an essential
complexity you cannot get rid of then
there's a bunch of of accidental
complexity that programmers add to it
that they didn't have to and you know my
goal is to eliminate to reduce The
Accidental complexity to as close to
zero as you can get
it
okay I like to Rite a nice a nice 100%
accidental complexity line it just feels
good job security
um all right all right how about how
about tdd so I've I I've been I've gone
back and forth on tdd you're a very tdd
fell
right it is a discipline that I um value
okay um let me tell you my T my tdd
success story when I was a when I was a
young fella uh long long time ago uh we
had this app uh at a company called Web
filings now known as worka in which we
had the original flash app in which
people who are doing 10ks and 10 Q's
public quarterly reports would do all
their editing along with a spreadsheet
you could link values and all that
update your spreadsheet boom it flows
through all your documents all your
documents are now up to date with your
spreadsheets pretty nice and so you
could do a comment on a spot and then
someone could review it change all of
that and we also had an iPad so I was in
charge of the iPad the iPad you could
zoom and do all that that was some fun
Matrix equations for zooming and doing
all that because there was no zooming
this was just a web app and a canvas and
so we just you know we invented our own
math there and so we did all that it was
a lot of fun um but if you touch the
screen I need to be able to start a
comment by you touching and dragging so
that's kind of like a fun unique problem
to kind of have and the thing is is that
that has to line up with the original
doc so it's like okay well I know a lot
of this information I know where every
character starts because we did our own
handrolled kerning cuz kerning had to be
identical to the flash app as it is in
the iPad app which is an impossible
Problem by the way so you have to just
infent your own kerning and write every
single letter and so that's what we did
we handrolled all of our own kerning and
so I knew where every letter started I
knew where every everything about every
page and so therefore I could write my
own like test before I ever even started
because I'm like we need a search
algorithm that when I press this it
behaves this way this goes in this comes
out I know everything about the problem
it was a perfect what I'd consider a
perfect tdd
problem but I've never had that again
okay H how my my my big problem that I
see with tdd or at least how I feel
about it is that I only know so much and
most of the time I don't get the
information that I need it's like hey
let's do something we've never done
before I don't even know what the enemy
looks like yet why would I want to write
a test
first so as a yeah the way I do tdd is
about one line at a time you know I will
write a test and it's a very small test
it's maybe one line or two lines and it
will fail and then I will write a line
of production code to make it pass this
is so far below the idea of gosh I don't
know what this code's going to do
because I clearly do know what it's
going to do that I can very easily write
a test for that code in essence what I
am doing is I am practicing Double Entry
bookkeeping for every line of code I
write I write a complimentary line of
code that checks that I wrote the right
line of code
just the way accountants do with
entering numbers into spreadsheets right
okay I'm going to enter a transaction
over here I better enter the the the
complimentary one over here and make
sure the balance sheet is still zero
that's that's what test driven
development is it's double entry
bookkeeping it is a way for me on a
minute by minute basis to be sure that I
have not done something so globally
stupid that it'll cost me three hours of
debugging
time well I guess the the followup is is
why not write so this is generally how I
do it I think you said you watched the
stream for a little bit earlier so you
saw me where I developed the Tower
Defense the chat aggregator and then
after I kind of I like this structure I
kind of like what I have here then I go
and I go okay let's I'm going to now
test this to make sure it's correct like
right I never I am not a fan of of of
trying to run code to see if it's
correct in the sense that like I'm going
to now fire up the whole program to make
sure I've written this few lines
correctly because that is just like such
a nightmare testing cycle that I always
do reach for unit test pretty quickly as
a as a means to drive correctness and
implementation not as a means to develop
the thing right so it's kind of like
where the fundamental distraction comes
from is that if I were to start off with
a test it kind of almost feels like I've
kind of kind of already pigeon hold
myself into what I want to do when it's
like well maybe I don't want to do it
this way maybe I don't even know how I
want to interface with it yet and so do
you ever find yourself writing some test
code writing some code realizing oh okay
I can't even do it that way then going
back to your test code then
reformulating your test code and then
going back and reformulating this and
kind of doing this back and forth on
it sure that happens all the time so why
not just start with your base
implementation
first there's another another reason
that I want I'm very curious by the way
I'm not trying to like fight you on this
I'm super curious on this no no no it's
fine fine honest questions I know we
talked about honest questions all right
so
um uh there's another reason that I want
that that test or those Suite of tests I
want to come up with a suite of tests
that when it passes I feel comfortable
to
deploy I don't want to have to go
through a long burins period you know
where you you get the system running for
a month and everybody kind of stares at
it and wonders if it's going to crash
you know I don't want to go through that
I don't want to go through a long manual
QA process with the a bunch of guys in
India banging away on it I don't want to
go through that I want to I want to cut
that off as much as I can so I'll have a
suite of tests that I can run and if
that Suite of test is covering almost
every line of code in the system I have
a high degree of confidence that I can
take that code and move it closer to
deployment I have worked on systems
where that passing Suite of tests was
deployment we would just deploy it right
then and and if you're going to do that
you better have a real high degree of
confidence in those tests so because of
that I use this discipline to keep keep
the number of tests high and and every
line of code is somehow
covered more or less now there's a whole
bunch of exceptions to that there's a
whole bunch of places where that just
doesn't work a whole bunch I shouldn't
say a whole bunch there's a number of
places where that doesn't work but where
it does work it's a discipline that I
like to follow it it makes me feel very
safe so I I kind of have like a
different I guess view on testing which
is that I can only test the things I
know
about meaning that I I actually have
zero confidence every time all the test
pass green I have zero confidence that
there's not bugs in it right like I just
I'm just like there's probably bugs like
I just simply don't know what I don't
know and so even though all things are
green I'm highly confident I've screwed
something up
and so that's kind of always been my
general approach which is that's I mean
this is probably where or the reason why
I write my base implementation first and
then come back with the test because I I
already know what I know and I'm not
going to I'm not going to catch anything
unless if I've just programmed wrong and
the things that I already know would
break they
break so how so so so why does it this I
mean so you say this 100 line you know
this 100 effectively you're you're
broaching the subject of 100% code
coverage and I largely think 100% code
coverage is a lie I don't think there
should be even a number on it um why why
do you try to test every line try try to
test it first of all I agree with you I
don't want to number on it uh any kind
of number you put on that is is a lie uh
but I think that you're also you're
always shooting ASM totically towards
100% uh and I do that because I want
that test Suite that I can trust I have
lived in that world where the test Suite
was so good that I could trust it and de
employ and what that also allows is for
me to fearlessly
refactor if I need to change the design
of the system and I've got a suite of
tests that I really trust I can rip that
system to shreds I can tear it apart in
a in a period of two or three hours just
making sure that the tests all all
continue to pass change the design rip
things out move things around change
this change that tests all still pass
and I'm running those tests all the time
to make sure they still pass and I can I
can uh have absolute control over the
code that way and I use the word
absolute it's never absolute but I I
have a high degree of control over the
code if I have a suite of tests that I
can trust so I have lived in the world
the other world I have lived in the
world where the suite of tests can't be
trusted right and there's no point in
running them it's like okay the test
passed so what I know there's bugs in
there that's what I want to avoid that's
what I want to avoid I don't want to
live in that world now I'm working on a
project right now half the system is has
a suite of tests that I can trust and
half the system doesn't and I I have a
nice division between those two parts
happens to be the gooey right that I
can't test properly and then the rest of
the processing code that I can and I
have one way of dealing with the code
that's under test and I have another way
of dealing with the code that's
not okay and so there's there's a lot of
things that I want to talk about within
all of all of that there's just so many
of them right
um all right so I guess the first thing
is that we you did talk a lot about
refactoring refactoring confidently um I
guess that really dictates the type of
test you're writing then right that must
mean you don't test individual functions
you test only contracts and is the
assumption that when you refactor the
contract doesn't
change yes so that this is something you
learn over a long period of time when
you're doing test driven development you
have to write your tests in such a way
that they don't couple to the
implementation and that first of all
that takes a very long long time and
then once you do learn it it takes a
long time to learn and then once you do
learn it you realize that you're only
applying the exact same principles that
you apply to all the code you've ever
written before right because anytime you
can touch a system in one place and it
breaks in many you've got a design
problem that's the that's the definition
of a design problem touch it here breaks
in 10 other places over there well
that's also true of tests if I touch it
here and it breaks 10 10 or 20 tests
I've got a design
problem so you internalize a
developer well so you have a
requirements change how many tests
should break if the requirements change
and the answer is
one if you can get there it's not always
easy to get there but if you can get
there it should be one how many modules
should you have to modify when there's a
requirements change one if you can get
there that's kind of the goal of design
you want to focus change on individual
modules so
that when a change occurs one module is
effective if you can pull that off and
it's not easy to pull that off but
that's only assuming that every module
has one dependency right you could have
many things depend on one
thing yes yeah yes and if a module has
many incoming dependencies that's a
problem and if a module has many
outgoing dependencies that's a problem
and you can't eliminate them
all but you can control that you can
minimize that and get some kind of some
kind of um discipline around the number
of dependencies between modules that's I
wrote another book about that called
clean architecture but don't you by but
but that if you do that you also
introduce natural abstraction that
doesn't technically need to be there cuz
now you're just abstracting to specific
interfaces just putting a man in the
middle I I am putting a barrier across
an axis of
change so yes it the the interfaces that
you would put in there the abstractions
that you would put in there are not
strictly necessary for the behavior of
the system but they vastly increase the
ability to modify the system they keep
it easy to make a change here without
affecting something here
all right all right I I I tend not to I
I'm very Pro or I'm very pro- anti-
abstraction I'm not sure I probably
should just say anti- abstraction I try
to very minimally abstract my code when
possible all right so that we began this
by saying you know I don't put
abstractions in unless the need is there
but the need is there if I've got a
change here and it's affecting a bunch
of stuff over there then I'll put an
instraction I don't know I think
sometimes requirement changes are big
enough to just warrant that right like
if someone changes your fundamental data
type a lot of things require that data
type it's just by by its very nature
must change the only way you can do that
is if you can predict the future and I
have proven to myself I am a shitty
future
predictor and and that's true yeah then
I just have to make the same number of
changes it's just propagated through 10
places that eventually get to the tips
now you just have one changes eight
times as opposed to one change that is
eight oopsy daisies
you're always going to get bit by that
we always get bit by that that doesn't
mean that you can't mitigate it and by
the way also when you get bit by that
you have the opportunity then to make
sure you don't get bit by it again
because the most likely thing to change
is the thing that's been changing
already so if you can if you can catch
it early because somebody made a change
and you can put in a protection for that
change then when they change that thing
again and they will you'll have a
production built
in maybe I'll give you a maybe on that
one I'm gonna give you maybe I'll give
you
5050 okay 5050 I'll take that so hold we
got to go back to a little bit of
testing uh when it comes to when it
comes to testing and you try you know
your goal as you say is ASM totically
reaching 100% why why why does it matter
that you cover every line of
code because I want a test Suite that I
can trust I know but not all Cod is is
code worth
testing all yes all code is worth
testing because any any error any any
code that is in error can cause
catastrophic results so yes all code is
worth testing but not all code is worth
testing
directly I don't mind indirect tests you
know for example I don't write tests for
my Getters and Setters that's stupid
right but I do write tests for the
functions that call the Getters and
setters
all right so I have a general rule of
thumb which is that if I can't get the
implementation right first try I test it
okay and so that leaves some level of
code always untested because I have a
got the implementation right the first
time because some things are really easy
sum an
array say that again some things are
really easy some things are really easy
sum an array like in JavaScript you have
to sum an array right would write a test
for summing an array I wouldn't I
wouldn't write one either right and so I
have kind of like a set of I have a
general rule of thumb which is that if
I'm doing something that is Trivial in a
function I just don't test it so yeah
Kent Beck used to say only test the
things that could possibly break yeah
that's what I mean that's one reason why
I do like uh uh erors as values
languages is because they kind of force
you to think about the places in which
things break uncomfortably so but
nonetheless they do that's why I've
always been a very sus of the jvm is cuz
it's kind of just like you don't have to
handle it if you don't want to and it's
just like well maybe we do want to
handle it or at least think about it
should be inconvenient when there's an
error okay you don't think so um I'm not
a big fan of multiple return types um
like go does that I don't like the comma
separated returns I think that
complicates things uh so I I prefer to
throw exceptions in languages that allow
exceptions to be thrown
yeah but but then you have you have a
whole control flow problem then cuz now
you have to you you necessarily skip a
whole bunch of lines and you may even
skip out of your function right like
state becomes very unknown if you don't
have every line that has an error
considers the
error so I mean that's also true when
you return when you return error codes
if you return an error code from the
middle of a function you may not know
the state of how that function left
things by by the necessity you do
because you actually chose okay I got an
error I will now have to return from
this error like you've made that choice
at that point yes you have and and if I
throw an exception I've I've chosen to
throw the exception at that point but
you don't know where Point yeah I know
but that but that's the problem is that
if you caught it three functions up you
now have many many layers well some you
know come on so you know you've worked
at places with at least three functions
up it's like if you JavaScript they
throw go everywhere doesn't necessarily
mean it's a good idea um but you know I
like the exception model myself because
I don't like to throw long distances you
know I throw up to the next function so
it's very much like an error code except
that it's caught in a different way so
you do like SS's values is what you're
saying you just like two ways to return
values because that's what it sounds
like if you do if you do do a try catch
every single time by the necessity you
have multiple return values you just
have multiple return channels
okay I'm I'm happy with that okay okay
hey that's fine hey look at that Common
Ground all right who would have guessed
who would have guessed all right well I
guess I don't think we'll probably ever
see eye to eye on uh on unit testing
fully or test driven development though
I mean I I like I said I've used it once
where I really understood the problem
and it was it was absolutely absolutely
fantastic for sure
um but what do you prefer when it comes
to testing are you do you drive more
towards integration level like where do
you choose your level is higher better
or is lower better or is there any rule
that you can
say so the the I I'll just go back to
Kent Beck statement I I will test
anything that could possibly break uh I
like to pose my tests as uh abstract
tests the wrong word uh General tests
against a family of functions rather
than a test against every individual
function I like IND direct testing I
want to make sure every line is covered
but the tests themselves are written at
a slightly higher level but not so high
that they're called integration tests
they're still unit tests they're just
testing a slightly larger unit than a
single
function okay do you think there's value
in integration testing yes absolutely
how much effort put
in it depends on the complexity and the
size of the system unit test are opic
you know when you're writing unit test
you're thinking of one thing when you're
doing integration testing you're
thinking about a number of things you've
got a bunch of balls you're juggling in
the air uh so they can be very useful
but they should not be testing business
rules integration tests should be
testing integration they should be
testing the choreography and the the
flow of data through the units as
opposed to individual business rules
it's a waste when you do individual
business rules in integration tests
okay I I I I guess I'm slightly confused
by that um isn't the output of any
integration test a series of business
rules aren't you testing like a
summation of business
rules um so my my goal in an integration
test is not to make sure that all the
business rules work I may have to test a
business rule in order to test the data
flows but if the data flows work in an
integration test I'm not going to go
through every one of the business rules
that use those same data
flows okay
okay I've got unit
test okay so you you just do more like
does the system continue to operate I
asked for a piece of data it did return
this type out we're good enough is that
kind of what you're trying to say well
yes a little more detailed than that I
want to know that the the processes got
started properly the data flow channels
got open properly that the right kind of
data went across them so I might be
putting in um special little widgets to
test those kinds of things I might stick
in some extra fixture code that will
look at the flows of data across those
points integration tests are very
technical you know that's the kind of
thing a system architect does they
trying to Plum out the way the whole
system
functions how do you feel about Golden F
I see I see that a lot in integration
tests like a bunch of uh golden files
being used like I start up our system it
goes off and it talks to the DB it does
all these things and then I expect this
exact like shape of output how do you
feel about that kind of the golden I
guess they call them golden testing yeah
it's a move of desperation uh you don't
have enough insight into the system so
the only thing you can look at is the
output and you don't know what's going
on
inside uh and so okay well geez it
seemed to print the report fine I guess
the system's okay well if it's a
complicated system that's not a very um
comforting
approach why
not because you're only testing a very
small subset of the behaviors that
you're trying to test if you've got two
or three golden standards out there and
you you run the tests and all the golden
standards work you have not hit the
conditions that the golden standards
didn't cover and you don't even know
what those conditions are yeah so you
get a false sense of security now if
that's all you got okay that's all you
got but uh I would not start a system uh
and and with the goal of testing it with
golden
standards golden standards are um the
least effective way of of keeping a
system under control in my opinion other
than just not that all I mean can't you
make that exact same argument for every
smaller set of tests because in some
sense a unit test is a really a snapshot
test just in the snapshot just happens
to be really
tiny well yes the snapshot's tiny the
number of moving Parts is
innumerable uh and then you made the
point earlier you know if you've only
got eight bits you only got 256
possibilities and you can completely
flesh that out now I can't completely
flesh out the behavior of the system but
I can look at an individual function or
an individual small family of functions
and be relatively certain that the
behavior of those functions is well
covered am I 100% certain no am I
relatively certain to a high degree yes
golden standard doesn't give you that
because the golden standard is way too
far out at the at the user
interface there's too much stuff going
on in there from from my point of view
and and in a complicated
system okay well unfortunately I do have
to uh go as someone said chat my wife is
going to be angry at me I may be 15
minutes late um I do appreciate having
you on here and talk about these things
the goal again today was just to have
it's so that you can kind of explain
your positions and I hopefully did a
good enough job kind of representing
what I I would say your average Twitter
arguments were because I I've read a lot
of the tweets and they all are just like
for lights and you're just like well
actually and so I wanted to make sure
that that was close
enough thank you I had a good time
appreciate you yeah no this was a lot of
fun I I I did like some of your takes I
do like the uh you know the abstract
when necessary start more concrete I I
do think those are good things and and
most of all I I think that um the
hardest part about software isn't that
there's a bunch of design patterns you
have to memorize there isn't some sort
of like nomenclature that you and I have
about you know we have our own set of
special words in software development
and which is very weird to use around
your non-software development friends
which I'm sure you've experienced you
know you just don't throw the word
integration testing around with them
they're was this guy talking about um
but at the end of the day I feel like
experience is always going to be the
best teacher and it kind of like for me
the only way I understand my principles
is simply because I've just made bad
decisions and I'm just trying to make
less bad decisions as time has gone on
and so maybe one day I will be sitting
in your shoes telling all the kids to
start doing tdd and I'll be like dang it
how did this happen how did I get
here oh my God I'm Uncle Bob now I know
now Uncle Prime happen to Next Gen next
gen I'm like Saved by the Bell Next
Generation this is going to be terrible
um all right so you get the last word
any anything you want to tell to the
people watching things you want them to
consider books you want to sh you you
you name it you get to
do oh heavens
um the most important thing I think
is is keep on learning um read like CRA
read things you don't agree with get a
broad a broad understanding remember the
story I told about the structure and
interpretation of computer programs that
was a book I expected not to agree with
and it changed my life so just keep that
up in mind right a broad mind read a
bunch of junk constantly learn uh and in
20 or 30 years you know things could be
good
hopefully all right that's good that's
that's fantastic anything else do you
have any books or anything that you want
to throw out there any courses whatever
you have no no I don't do courses and
stuff like that anymore I pretty much
stick to my writing and and my
programming of of stuff that I do um
there's a book that I uh is in
production at the moment uh which is um
a history of ancient programmers you
know starting with people like Grace
Hopper and and uh John bakas and edar
dyren a book that I'm I I had a lot of
fun writing I don't know how many people
will read it I hope people will but I
had a ton of fun writing that book do
you DOD when you're wri
book do I do tdd when I'm writing a book
no I do
not there's no automated tests I can run
you know do reread it a lot but that's
not quite the
same all right well it sounds like you
have manual testing somewhere in this
pipeline we should fix this now okay hey
did you hear there's this it was in
ancient Rome you might not I mean I I
don't when you said the word ancient
then you mentioned people from the 50s
it sounds like you might not have I I
believe the first programmer ever I I
tried to look this up several times and
I could never find it I watched it on a
special once he did a play in a box
where there was a spindle that had wires
attached to it and as it spun it would
drop and then it would rotate the other
direction then it would drop and rotate
the other direction effectively doing
binary programming two about 2,000 years
ago and it would make entire things move
around based on this like onoff sequence
and so technically considered like the
first actual
programmer just cool you know I only
heard about a third of that because the
network decided to cut out right about
then oh that's too bad don't worry we
we'll leave it for another time maybe
I'll find the uh maybe I'll find I'll
find the reference and toss it to
you okay all right well you have no
words hurts a little all right you have
a good one Uncle Bob this was great
thank you for coming
on thank you appreciate it had a good
good time all right take care
