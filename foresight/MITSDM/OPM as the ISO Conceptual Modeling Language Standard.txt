Hello, and welcome to the MIT System Design and Management
Program.
Oh, shoot.
I didn't even meet myself.
Hi.
Hi.
Hi again.
Good morning, afternoon, or evening, whatever the case may be.
Welcome to the MIT System Design and Management Program.
System Thinking Webinar Series, my name is Lois Slavin.
I'm the communications director and the host for this session.
It gives us great pleasure to host Doug Dory today, and with that, I will turn it over
to him with just one note.
There will be time for Q&A within this hour.
If you have any questions, please enter them directly into the chat window and address
them to everyone.
I will read them aloud, and Professor Dory will then answer them.
Also, you will be sent a link to the recording of the webinar and to the presentation slides,
and with that, Professor Doug Dory.
Hello, everybody.
I'm going to talk about the maturation of model-based systems engineering and the focus
on OPM and C-SML.
OPM is going to be the ESO Conceptual Modeling Language Standard, and the C-SML is already
a standard.
As engineers, we know that any engineering discipline has their own language which they
express themselves.
For example, mechanical engineers have machine drawings, civil engineers have floor maps,
electronics engineers have their own set of drawings, and software engineers have models
such as UML.
How about and what about systems engineers?
What language do they speak?
It turns out that what is required is a graphical, maybe also textual, formal language for conveying
systems, architectures, and designs in a conceptual, straightforward, and clear, and unambiguous
way.
It turns out that systems engineers, as of a few years back, do have a couple of languages.
One of them is C-SML, Systems Modeling Language, which has been the standard of OMG Object Management
Group since 2007.
There is also Object Process Methodology, OPM, which is in the process of becoming ISO standard
since 2009.
There is also a book that was published in 2002, previous publications date back to 1995.
Why do we need conceptual modeling to begin with?
There are several good reasons.
One is that we want to construct a mental picture of the system we are aiming to build,
design, architect.
We want to anchor one's understanding in formalisms that can be visual and or textual.
There are two things that are required for dual channel processing, that is, the brain
processes information both visually and verbally, and if we can do it in parallel, that is even
better.
We want to design systems using nonverbal means, graphical, visual, convert acid knowledge
to explicit one, because many people have their knowledge, but they don't express it
explicitly.
Of course, we want to communicate the concepts that we have in mind to others very clearly
and unambiguously.
One key concept or term for our discussion is ontology.
So ontology, for our purpose, let's define it as a set of concepts for describing a domain.
Domain can be industry, banking, military, healthcare, and systems within this domain.
This has been in use for quite a long time.
We define a universal ontology as a set of concepts for describing the universal systems
within it, which is domain-independent.
It is not geared towards any specific domain.
Therefore, it is called universal.
What we want to really do is have ontological grounding of model-based systems engineering.
That is, we want to have a justification of what building blocks we are going to use in
our modeling language, not just start using anything.
To this end, we will try to determine the minimal set of concepts, which is required
to model the universe and systems in it.
This will be our ontology, a minimal ontology that is required and sufficient to describe
the universe and systems in it.
In order to do it in an appealing and engaging way, what I'm going to do is start with a series
of questions as Socrates used to do 2,500 years ago, but since it's a webinar and unfortunately
I can't get your immediate answers, I will just wait a while and then give the answer
myself.
Of course, you will be able to ask questions later on.
The first fundamental question is, what are the things that exist in the universe?
What do we call them?
The answer is objects are the things that exist or might exist.
We can think of them as things that might exist or exist in fact.
The next one is, what are the things that happen in the universe?
The answer is that processes happen or might happen, but we have to also remember that
processes cannot happen in vacuum, they happen to something.
The follow-up question is, what are the things to which processes happen?
The answer is that processes happen to objects.
The things that happen happen to the things that exist.
If this is so, what do processes do to objects?
The answer is that they transform, processes transform objects.
Next we can ask, what does it mean to transform?
What does it mean for a process to transform an object?
Transforming of an object by a process means one of three possible things.
The process can create an object, the process can destroy or consume an object, and the
process can affect an object.
Creating, which is equivalent to generating and destroying, are quite straightforward,
but what does affecting mean?
What does it mean for a process to affect an object?
A process affects an object by changing its state.
Here we introduce, in addition to objects and processes, a third term, which is state,
and objects therefore must be stateful.
In other words, they must have states.
We are talking about not just objects, but stateful objects and processes that transform
them.
Let's shift gears for a while and ask another key question that we will need to use later
on.
What are the two complementary aspects from which any system can be viewed?
Two important, two key aspects.
The two key aspects are structure and behavior.
Structure is a static aspect.
It answers the question, what is the system made of?
What are the parts?
How are they related?
The second aspect, the complementary aspect, is the behavior.
It's the dynamic aspect.
It answers the question, how does the system change over time?
What happens to the system and to the objects in it?
In addition, there is a third aspect that is only relevant to a man-made system.
What is it?
Well, the function, or the utilitarian, the subjective aspect, answers the question, why
is the system built?
For whom?
Who is the beneficiary?
Who benefits from operating the system?
This question has meaning only in the context of man-made systems, but much less so in natural
occurring systems.
What is the basic idea behind conceptual modeling?
We have the conceived reality as we sense it.
We engage with the world through our senses, and we conceive some view of the reality.
We see things, we hear things.
Here is an aircraft, airplane, a bus, here is a person feeling gas.
The airplane is modeled by a symbol, a rectangle in which aircraft is written, a bus similarly
is modeled by a symbol for the bus, an object.
These are two objects.
The third one, however, is different.
We see something happening, not just an object existing, but we see a process.
Before this, let us see what the common between aircraft and buses.
Aircraft is a vehicle and bus is also a vehicle, so we see that we can start, see how we can
generalize things which is part of the conceptual modeling, generalization, specialization is
an important relation, structural relation between things, be they objects or processes.
Now looking at this process, this thing, this process is modeled by an ellipse because
it's a process and not an object.
We call it gas feeling, and it's a process, and it affects, as you should recall, an object.
Any process must transform an object.
In our case, the transformation is effect, and the gas feeling affects the car.
How does it affect the car?
It changes its state from being empty of gasoline to being full with gasoline.
And just as we did with the objects, we can generalize gas feeling as being a special
case of energy replenishing process.
If this was an electric car, we would charge it with electricity rather than feeling gas,
and that would be another kind or type of energy replenishing.
So we see that there is quite an analogy between objects and processes.
So just as objects can be generalized, so can processes be generalized.
So using graphical symbols, the model expresses relations between things that are objects and
processes.
These are things in our model, and the relations among them.
Currently, the relations are simply written along the arrows, but they have, as we will
see, certain better symbols.
So I'm now going to introduce something new, which I call the object process theorem.
This theorem states the following.
Stateful objects, processes, and relations among them constitute a necessary and sufficient
universal ontology.
In other words, or a corollary to this, is that using stateful objects, processes, and
relations among them, it is possible to model systems in various domains and at any level
of complexity.
So it's a pretty ambitious statement or theorem, and I want to try to prove it now with you.
So there are two parts.
We say that it's necessary and sufficient.
So we have to show that stateful objects and processes, first, are necessary to specify
the two system aspects, because as we said, these are the two aspects, the structural
and the procedural aspect, we need to be able to specify them.
So specifying the structural static system aspect requires stateful objects and relations
among them, because we want to show what is out there, what the system is made of.
In order to specify the procedural or dynamic system aspect, we need processes and relations
between them and the objects that they transform.
So it's necessary to have both stateful objects and processes as well as relations among them.
So we have the proof of the necessity.
Now we want to prove that they are sufficient.
So stateful objects and processes are sufficient to specify anything in any system.
Why is that correct?
Anything that exists can be specified in terms of stateful objects and relations among them.
Anything that happens to an object can be specified in terms of processes and relations
between these processes and the objects that they transform.
So sufficiency is also proven and this is actually the end of the proof.
So what we take of this is that it is enough to model any system at any level of complexity
and in any domain using stateful objects and processes that transform them along with relations
among them.
So what are the keys to good conceptual modeling?
First of all, because objects and processes are key to modeling, we have to be able to
tell them apart.
Telling processes and objects apart is the first key to good conceptual modeling.
Then we want to model the objects and processes concurrently because the world is really such
that or systems are such that structure and behavior are tightly intertwined and trying
to separate that does not make a lot of sense, at least not in the beginning.
We want to see how the structure and behavior are connected to each other.
Then we want to be able to manage the complexity of systems.
Systems are inherently complex and we do this through abstraction and refinement mechanisms.
Finally, if possible, we want to utilize dual channel processing in order to take advantage
of our brain processing capabilities of both graphics and text concurrently.
Several years ago, Jeff Estefan, in 2008, published as part of the INCOSSE task force,
a survey of the leading model-based systems engineering methodologies and there were six
of them.
You can see the list here, two of them are from IBM, telelogic, rational, there is INCOSSE
object-oriented systems engineering method, Vitec, JPL state analysis and OPM was also
one of them.
Some of you might wonder why system L was not surveyed and the answer is that system
L is a language but it is not a methodology so it is not included in this survey.
In OPM, in object process methodology, we talk about things which are categorized into
objects, stateful objects and processes that transform the objects.
These are the symbols as we have seen them.
An object is defined as a thing that exists or might exist physically or informatically
and the process is a thing that transforms one or more objects.
Processes transform means either generates or consumes or affects, changes the state
of an object.
Here is how this is expressed both graphically and textually.
Processes transform objects by one option is consuming them.
Here is an example of a process manufacturing which consumes raw material as it operates
and the sentence that we see at the bottom is automatically generated by software called
OPCAT which anyone can download for free.
I am going to give you the link soon.
Sure, they call it VR out, it's clear in items, that type of thing, what floor do they use your
want?
Okay.
The second way.
Yes, VR out items.
If I look at the rack, yes, we don't have this kind of work theory, what's good?
Every floor has it, because they told me when I was a kid, we had some VR out items that
were interlocking.
Excuse me, please make sure you're muting yourselves, we hear a woman say hello.
Okay, so that's what we know.
I remember when the back of the window was like, I wouldn't say between a two-year-old
lady, whatever.
Sorry about that.
They were near the window, with the back of the door, with windows.
And I remember, so what's on the 8th floor then, what are the labels in 8th floor?
Power?
What does that mean?
What does that mean?
Okay, I'll try to continue.
Okay, thank you, honey.
Right here.
Okay, hopefully this will not happen again.
So second way of transforming processes by objects is creating them.
So here we see manufacturing creating the product.
So you see another sentence was added here, manufacturing yields product, and that's the
same error except it goes from the process to the object, whereas the previous one went
from the object to the process.
And the third option for processes to transform objects is by changing the state.
So in this example, we have a process testing which changes products from a state of being
pre-tested to a state of being tested, and that translates to a couple of sentences.
Product can be pre-tested or tested, and testing the process changes products.
The object from pre-tested to tested.
Again, all of these sentences are generated automatically on the fly in response to the
input by the modeler, by the system architect or designer.
So again, the two things that OPM has or deals or uses for modeling are objects and processes
and all the rest are relations between things.
For example, these pair of arrows are called input output link pair from the input state
pre-tested in this case to the output state testing.
So I want to show you a more realistic system.
We all have experience with baggage handling and sometimes it also gets lost.
So here is a model of baggage handling, which is the main process that you see in this diagram.
And we see the objects revolving around it, which are the passenger, the baggage, the baggage
location, which is an attribute of the baggage, the airport, and the airline.
These are the major objects that are involved in this process.
So the system's function is really this main process in the system diagram, the top level
diagram, which is this one.
This, by the way, is the graphic user interface of OPCA, the software that I mentioned.
And one of the guidelines in the OPM methodology is to start the modeling with depicting the
function of the system, what the system does to benefit one or more users, beneficiaries.
So in this case, it's baggage handling.
Processes should end with ING to give the feeling of something happening.
The beneficiary in this case is the passenger and the operand, the thing that the baggage
handling operates on is the baggage.
The attribute of the baggage is the location, which needs to be changed from origin, the
original, the initial state, to the destination, the final state.
All this is expressed textually here at the bottom with what we call object process language,
or OPL for short.
These are the attribute values, origin and destination.
This whole thing is called the object process diagram, or OPD for short.
And the text at the bottom is object process language, or OPL, which, as I said, is generated
automatically on the fly to interpret textually what is expressed by the model graphically
at the top.
On the left, you can see a hierarchy of object process diagrams because now that we have
modeled the top level and we see what the system is all about and what its main function
is, we can elaborate by zooming into the baggage handling and show that it is comprised of lower
level processes.
I can show it to you later on as we go if we have time.
One thing that OPN does is to unify the three aspects that we mentioned, the functional
aspect, why the system is built, what is the utility who benefits from it, the structure
of the system, what is the system made of, and the behavior of the system, the dynamic
aspect talking about how the system changes over time.
These three aspects are expressed b-modally, that is, both in graphics and equivalent text,
that is generated automatically, all in a single model.
We don't need to have several types of diagrams.
It's always object process diagrams at different levels of depth.
We zoom into the baggage handling which was only a single ellipse in the previous top
level diagram.
Here we see sub-processes of these baggage handling processes which are origin, baggage
handling, destination, baggage handling, baggage claiming, and lost and found baggage handling.
They are arranged from top to bottom vertically in the order that they happen.
This is the timeline which goes from the top of the in-zoom process ellipse to its bottom.
This is how time can be managed in an OPN model.
Again, around we see the objects that are involved.
Airports specializes into origin airport and destination airport.
The airline is comprised, among other things, of lost and found desk which is engaged in
the lost and found baggage handling.
The baggage has a location which, in addition to having the states of origin and destination,
now we can see that it also can be aboard the aircraft or someplace else which we don't
want to have, but this happened.
This is, for example, a condition for having the lost and found baggage handling sub-process
execute.
We've talked about the universality of the object process ontology or, in other words,
the claim which I hope proved that stateful objects and processes are sufficient for
modeling complex systems in any domain and at any level of complexity.
In order to support this empirically, I want to show you something from a totally different
domain which is molecular biology.
Baggage handling and molecular biology have in common the fact that they can both be
modeled using stateful objects and processes.
A little digression to molecular biology, we all know that biological systems, organisms
are highly complex.
They have organs that are made of cells and each cell has many, many thousands of biological
pathways, each comprised of many hundreds or thousands of biological reactions and all
this is happening in a tiny cell which is a whole world in its own.
In order to, and many, many thousands of researchers in biology are trying to unravel these
mechanisms and this is what molecular biology is all about.
We have, a couple of years ago, actually more than that, some five years ago we started with
the idea that OPM can be very effective in modeling biological systems and collaborating
with Professor Mordechai Hoder from the Faculty of Medicine and Judith Somek who just finished
graduating and has a PhD around this subject.
We have developed conceptual model-based systems biology approach in which we use OPM to model
complex biological systems and what we did in this particular work is to look at a set
of about 40 papers related to the messenger RNA transcription cycle and we modeled it
in a very detailed level.
Excuse me.
Okay.
Oh, maybe I think I, by mistake I clicked, I clicked and I got to,
yeah, this is the link that I get.
Okay, I think I'm okay now.
Actually, click, okay, I know what I need to do.
OK, so in conceptual model-based systems biology, we start with research papers and
papers, and experimental findings that we can find in the literature, which most of all
of it is actually currently online, and we construct a conceptual model which looks something
like this.
This is one of many, could be tens or hundreds of object process diagrams that are interrelated
and have the object which are molecules of various types and sizes and molecular complexes
such as genes and all kinds of hormones, and anything that is involved in these processes.
And because the in silico computational model which represents the experimental knowledge
which is gathered from natural language papers that are available online.
We have the ability, which I haven't mentioned yet, to execute to stimulate the model, so
we don't only look at a static model of objects and processes and relations among them.
We have the ability, and this is a screenshot of the simulation of this particular object
process diagram.
What we see here is that the process called via denulation, the one at the top, is currently
executing and is changing the states, which are the brown ones, of particular objects
from one state to another.
The next process to be executed will be this one and then this one, and then we will move
to another.
On the left you can see some small part of the hierarchy of the object process diagrams
that are part of this system.
And then, having done the simulation, executing the simulation, we can compare the outcomes
of this simulation with the experimental findings that we can find in the literature.
Obviously, there will be knowledge gaps because not everything is known, at least in the system
that we have been working on.
And so by modeling, we stumble upon knowledge gaps that we can at least determine what they
are.
And so we verify that the in-silical computer simulations are compatible with the experimental
results, and when they are not, we define knowledge gaps and what needs to be done in
order to close these gaps.
So this is a research cycle that goes on.
And the next stage is that we add new biological conjecture, one or more.
Maybe one at a time is a better approach.
And so we do some perturbation of the model according to what we think might be the case.
And again, execute the model and check the results experimentally in vivo, in vitro,
wet lab experiments.
This is the part of the biologists in order to verify that the results, according to the
conjecture, really is in line with the findings in the lab.
And so that is a very good indication that our conjecture is indeed true.
In reality, what our experience has been that it is not enough to have just one, it's a
very long iterative process of refining the model further and further in order for it
to meet when executed the biological findings.
So it's an interplay between the in-cylical and the in-vivo, in-vitro experimentation
in order to get them all in sync.
So we evaluate the conjecture, we find knowledge gaps, we design and do new wet lab experiments
and we iterate this until we have all of the facts in line.
And that's what there is another paper that has been accepted, will be published soon,
which is a follow-up on the paper that I showed you.
So as I mentioned already, OPM has since 2009 been in the process of becoming an ISO standard.
So Paris, France in 2009 was the first meeting of the ISO group that in which the study group
was established to explore OPM for modeling standards.
And then there was a meeting in Tokyo and in Florida in 2012 and in Israel in 2012 in
Haifa, Frankfurt, Germany last year and this year, just last month, in Beijing, China,
the resolution was to submit the draft as a PIS, publicly available specification.
And this is a major step toward becoming an ISO standard.
So it's now being voted.
Okay, I have mentioned C-SML as the current standard of OMG and indeed the comparison of
the key features of C-SML and OPM is in order.
So one prominent difference is the number of diagram times.
I already mentioned that OPM has just one kind of diagram, which is object process diagram.
C-SML has nine types of diagrams.
About half of them are structural and the other half is procedural.
C-SML is graphical, so the modality is graphics.
OPM, as I have shown, has graphics and text modalities, so it's bimodal.
The theoretical foundation of C-SML is UML.
In fact, C-SML is defined as a profile of UML with some extensions and OPM is built on
the foundations that I discussed earlier, which is a minimal universal ontology of stateful
objects and processes that transform them.
However, we have felt that it might be valuable to look for synergies and value of combining
OPM and C-SML.
So in a work done and published in 2011 in Systems Engineering Journal, we developed an
algorithm in supporting software to implement conversion or generation of C-SML views of
the different diagram types from the single OPM model.
And we evaluated the results through an experiment with students, 78 students, to test the quality
of the automatically generated diagrams, the C-SML diagrams, and how they impact the comprehension
of the systems that are modeled with them.
So the result, which I will elaborate soon, is that the addition of certain auto-generated
C-SML views to the OPM system model increased the compilation of the system by the students.
There is a challenge of mapping OPM to C-SML because the mapping is one to many.
So as a prominent example, a process in OPM can be mapped in C-SML to a use case, in a
use case diagram to an operation of a block, in a block definition diagram to action in
an activity diagram to state transition trigger or activity inside the state in state machine
diagram or as a message in a sequence diagram.
So all these concepts are actually some variation of a process with nuances and indeed the challenge
is to make this transition to make sense as much as possible.
So we did this and here is a couple of examples.
This is an object process diagram of some level at the ABS braking system, which is in zoomed
and we want to show a use case example.
So this is what we get from the conversion.
Here is the driver, which is here too, and there is an ABS braking use case, which includes
the braking, which you can see here.
Here is an example of converting another object process diagram from the same system
to an activity diagram.
This is the resulting activity diagram.
Again, you can see signal converting is the sub-process here, it is here and signal processing
is here and so on.
Here you have a decision point, which is equivalent to what is happening here.
Next finally, an example of a state machine from another OPD.
We have states of an order, which is ordered, paid and supplied, and you can see here the
order is ordered, paid and supplied.
So this is the focus on states, so obviously it has only states and some processes on the
transitions.
So the evaluation of our experiment with the 78 students, what we examined is the comprehension
of the system modeled in OPM, with and without the addition of the automatically generated
system and diagrams, and we also wanted to find whether there were any errors and inconsistency,
because this was the first time that we used this conversion system.
So we used two systems, divided the students into two groups.
There was a dishwasher system and a city scanner, and you can see how the layout of the experiment
was.
One group got OPM only of the dishwasher and OPM plus system of the city scanner and vice-versa,
and this cancelled any possible biases and learning that might interfere with the results.
We asked them eight comprehension questions, and we also asked them to find errors and
inconsistencies among the different diagrams.
And here you can see the results, which clearly and unambiguously in a significant way show
that there is an improvement between the scores for those who use the OPM only model and those
who got the enhancement with the C-SML model, the C-SML views that were automatically generated
from the OPM.
So no human added information to the C-SML models.
Still you see that there is a very significant improvement in the scores of the students
who had the opportunity or were provided with the C-SML interpretation of the OPM model.
The conversion was good because we didn't find true positive errors or inconsistencies
between the OPM model and the C-SML models.
Moreover, we asked the students to say whether the C-SML diagrams helped them, and indeed
the 74%, 58 of those 78, indicated that it did help them, and we even have a breakdown
by the types of diagrams.
So block definition diagram was the most helpful, 46, 47% and state machine and activity almost
the same because it makes sense because they're really pretty similar and the news case was
the least helpful.
So to summarize the comparison, in this study we have seen that OPM and C-SML take different
approaches in realizing the goal of general purpose system conceptual modeling.
OPM was especially good for idea generation and rapid prototyping at the early architecting
and design stages whereas C-SML is more appropriate when detailed views are required and this
happens usually during later stages of the detailed design.
So we see that each language has benefits and drawbacks and neither is by all means better
than the other.
So there is a large potential for synergy in using both a language in some combination
and this study can give hints or directions as to how this should be done.
Okay, so I'd like to go to the more general summary before we have the Q&A session and
so the takeouts that I would really be happy if you could take with you, first of all,
the stateful objects, processes that transform them and relations among them.
These three things constitute the universal ontology and that means that we can use them
to model systems in a variety of domains, maybe even in any domain.
And OPM uses exactly this ontology and therefore it is fit for modeling complex systems in
a large variety of domains and at any level of complexity.
Also using both graphics and text, the B model presentation appeals to what we call quote
unquote both sides of the brain.
The visual channel and the verbal auditory channel, they complement each other.
Some people are better than others in one and others are better in the other.
So each one can find whatever is best for him and complement with the other modality.
OPM is in the process of becoming ISO standard, it's got a number, 19-450.
CML has been the OMG standard for systems engineering since 2007 and what we saw an indication
of in the experiment is that using OPM in the early system architecting stages and system
L at later stages can in a synergistic manner improve modeling quality and the comprehension
of systems and therefore this is something that should really be looked in very seriously.
Some resources, there is this book with a link to it and there is also a website of
our enterprise systems modeling laboratory where you can find papers, software to download,
presentations, projects and many other things that are related to OPM.
Okay.
Thank you very much.
We have a number of questions here.
The first is two part and it is by Sebastian Herzig and the first part is you mentioned
that stateful objects, processes and relations are sufficient and necessary to describe systems.
Is there a base set of relationships such as some sort of a base vocabulary or are these
very much domain specific?
Okay.
Thank you.
This is an excellent question.
So yes, there is a basic set of what we call fundamental structural relations and procedural
relations.
The structural relations that are deemed fundamental and this is also part of the standard and
is found in the book, aggregation participation or in simpler words, whole part relation.
Then there is a generalization specialization or the either relation as it is perhaps more
known for which is a relation between a general thing and a specific thing that inherits from
it and then there is a classification instantiation relation, the relation between a class of things
which can be an object or a process and instances of that thing and exhibition characterization
relation which is a relation between a thing and its features and features are attributes
and operations that characterize that thing.
So these are structural relations.
We also have a general relation which can be user defined.
As far as procedural relations go, we have as you saw already, we have seen generation
or result link which is the graphical expression of the result relation, the consumption relation
between an object and a process and there is a state transition relation.
These are the main ones.
We have also conditional and event relations but these are more advanced concepts that
I didn't have time to even mention here.
The next question from Sebastian is, can and if so, how are constraints or generally requirements
captured in OPM?
Yes.
Okay.
Again, a very good question.
One of the really nice features about OPM is that using this approach in methodology,
you can start with a requirements model that is not just a bunch of textual requirements
that have number and title and text but you can using either the requirement, textual
requirement document or starting right away by modeling hand with hand or shoulder to
shoulder width between the customer and the provider to have a solution neutral requirements
model of what the system is supposed to be doing and then that will be the basis for
elaborating it by one or more options which will be solution specific and then you can
also compare the alternatives by various means and select the best alternative and continue
with detailed modeling with that alternative.
The next questions are from John Clark.
First is a statement, function and behavior are the same thing.
Second is the Baptist would enter the originating airport and arrive at the destination airport
correct and third, a human body is a non-man-made system.
Right?
Right.
Okay.
So even though the first statement is declared as a statement, I want to argue with it.
I know that many people confuse or mix behavior with function.
Function is and behavior are not exactly the same.
They are similar because most of the time function is associated with behavior but function at
least the way I view it and I define it is something that brings value to some user to
some beneficiary whereas behavior is just a neutral concept of something changes being
generated or consumed and this is how we define the difference between function and behavior.
Indeed, most of the functions entail some behavior of the system but not any behavior
as a functional objective.
So what was the second one?
Okay, there was, sorry, I move on to the next question.
The baggage would enter the originating airport and arrive at the destination airport correct
and then the- Yeah, well, the origin, the objective is to change the state of the location
of the baggage from the origin airport to the destination airport but what we really
are interested here is not just the sunny day scenario but mostly what happens when
things go wrong for some reason and we have a very detailed model of what happens to the
baggage when it is not routed the way it should be.
Sir?
A human body is a non-man-made system, correct?
Correct.
Yeah.
Okay.
The argument about it.
Is that a question or?
Okay, what is the next one?
Okay, from Mark Houllier, how would you handle the time aspect in description of concurrent,
i.e. non-sequential processes?
So as I mentioned, the timeline in an OPM diagram goes from the top of the diagram to
the bottom when you look inside an in-zoom process and so if you want to express two
or more processes or sub-processes that have to start concurrently, you simply draw them
more or less at the same height and the system, the software understands even with some leeway
that they should start concurrently.
Okay.
Next question from John Clark again, OPM is an abstraction of CIS ML, correct?
Not quite.
What I've shown is that OPM has been, first of all, the origins of OPM as I mentioned
in 1993 and the first paper was published in 1995, that is at least a decade or more
before CIS ML or even UML were conceived and an OPM is founded on ontological notions
of stateful objects and processes that transform them.
It comes from a different angle or a train of thought than CIS ML.
CIS ML is the way that CIS ML was conceived is to build upon the achievement of UML as
a software modeling language and tweaking it and converting it into a language that would
be applicable and usable for general systems rather than software systems.
So it's a totally different approach.
Okay.
From Daniel Yao, did you also test the students on CIS ML diagrams with no OPM model?
Oh, that's exactly what my wife told me yesterday.
What they should have done in this experiment.
We didn't do this.
This is something left to be done.
Okay.
From John Clark again, is this ML, is CIS ML helps the understanding of OPM?
Why do we need OPM?
What does OPM add?
Okay.
So OPM, like I said, is very easy to learn, is very easy to understand.
You can start modeling within 30 minutes of being exposed to it.
Whereas in CIS ML and UML, for that matter, you have to really spend a lot of time and
the learning curve is long and much more tedious in order to start being able to produce a
meaningful model.
Moreover, there are very little, if any, guidelines with CIS ML and UML of what diagram to start
with when to move to another type of diagram, when to return to this.
What types of diagram to use for what purposes and how they are interconnected.
It's a much more heavy overload on the modeler's mind to be able to keep, to juggle with the
different types of diagrams and get a clear and intact, complete picture, coherent picture
of the system with these many types of diagrams.
With OPM, it is much easier.
From Lars Olaf Kilstrom, having spent a significant amount of time both using CIS ML as well as
ontology development, I feel that this approach has benefits based on works with ontology.
I was wondering if you have looked at the Ideas Foundation ontology.
The reason for the Ideas question is that several concepts discussed in this presentation
also appear as part of the Ideas Foundation.
I'm not familiar with the Ideas Foundation.
I'll be happy to look at it.
As you indicated, there are synergies or commonalities, and I guess that would be beneficial.
From Jose Luis Fernandez, what about constraints?
How do you deal with something similar to CIS ML parametric diagram?
I didn't have time to mention it, but you can specify quantities and constraints again
by using objects with values, objects which are attributes of other objects or processes
with values, and constrain the behavior such that only if some parameter is within certain
values, a process will happen.
That is all done using objects and stateful objects and processes and links between them.
Is the converter from OPM to CIS ML available in OpCat?
It's a separate module, but we can try to make it available.
Yes, it was part of a research project.
This would be the last question.
There are several more, and I'd like to inform the audience that there will be a follow-up
email with links to the webinar recording and the slides, as well as to Professor Dorey's
email, so you can feel free to contact him directly if you'd like to discuss anything
you've heard here.
The last question is from Oswaldo Arias.
Is the OPM book available in digital format, if so, on which websites?
Thanks for the question.
This particular book, although I asked for it, at that time, a decade ago, it wasn't
very customary, but there is hopefully the next book.
Well, not hopefully.
I know that the next book includes a digital form.
When will that be coming out?
Hopefully in six months.
Excellent.
We'll be happy to send you a link to the website where you can get a digital version after
the book is available.
I'd like to thank everyone for attending.
I'd like to thank Professor Dorey as well.
I have to say this has been one of the more popular webinars in terms of questions from
the audience.
It's wonderful to see people so engaged.
Our next webinar will be two weeks from today.
We have Mona Vernon, an SDM alum who works at Thompson Reuters, who will be speaking.
The topic will be announced later this week.
With that, thank you again for attending and thank you again, Professor Dorey.
Thank you very much for your attention and interest.
I look forward to interacting with you.
Bye-bye.
Thank you.
I can't get it to stop.
