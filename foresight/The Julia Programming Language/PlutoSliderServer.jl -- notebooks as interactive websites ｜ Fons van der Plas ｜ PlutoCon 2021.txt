Hi, everyone. Welcome to PlutoCon. My name is Fonds and I'm Pluto's main developer,
and my main motivation for working on Pluto is education. I think that computation is an extremely
powerful tool in education, and we have to make it easier for teachers to use it in their class.
So that's why I was really excited to work on a project during the development of Pluto.
During the fall semester of 2021, I worked with the Julia Lab on teaching the course
computational thinking, where we tried to teach mathematics by showing the computation instead
of first showing the mathematics and then the computation. We had lots of cool, famous celebrities
teaching the lectures, and that was awesome. The lecture materials is really high quality.
And for example, we had lectures like this one where it's kind of a shockingly effective way
to do that. So I'm going to get a high level view of how this algorithm. So you have three
blue and brown using Pluto notebooks to show the computations that go behind these mathematics.
So this was really exciting. And for the next semester, the spring 21 semester,
we wanted to do something new, which is all of the notebooks that the lecturers use,
we automatically turn them into the website, and they become like a book, like an online book
about computational thinking. And this used to be difficult in Pluto, automatically exporting
in the book to a web page, because you needed a web browser to generate those files. But now,
over the past months, we kind of changed the internals of Pluto to be able to
take a state object, which can be generated just by Julia, which contains all of the notebook
state, the inputs, the outputs, et cetera, and load that in as if it's connected to the real
server. And so that's our new website. So for a new website, every page is a Pluto notebook.
So here we're in chapter 1.1. And you see that this is Pluto. And actually this window on the right,
it's the real Pluto editor. It's not just an export. The only thing we did was we hired the bar
at the top with the Pluto logo, and we disabled the buttons. So that was the first thing,
automatically using GitHub Action to generate a website out of these notebooks.
And so we really believe in learning by doing, and we want the students to run the code to do
the experiments, and discover these things for themselves. The problem was that in the fall
semester, students had to install Julia down with Pluto, and then get the notebook from
my GitHub. And it was a long process. And I think we lost a lot of students in that process. So
they would see the video, get excited, but then be demotivated by having to install all of these
things. So the next thing I worked on was to add a button here, which is a binder button. So my
binder is a non-profit organization that can run scientific notebooks in the clouds.
They're really great. And we managed to get a Pluto kernel working there, though normally it
just runs Jupiter notebooks. And so it can connect in the background. So when I click,
it will start loading a binder kernel in the background. And when it connects,
it can hold swap the backend. So it will go from a static file to a live binder session,
which is awesome. The problem is, as you can see, it's still loading. It takes quite a while
at these two minutes. And this is mostly because we're using Julia. So when it connects, it will
need to start Julia on everything for the first time, install the packages that we're using in
this notebook. So yeah, it's still not quite to the point where you see some kind of cool simulation
and you start playing with it and discovering things.
We worked on Pluto Slider server, which is a web server that you can deploy for your website
that will take all the bind inputs and make them work directly on the website
without having to wait for any kernel to start. So for example, right now, I'm on the website.
And let's see, there's a slider here. And I can move these sliders and you see that this
pixel changes instantly. It even works with webcams. So here's a webcam input. And when I take a picture,
you see that using Julia codes without JavaScript or anything like this,
I can turn that into a kaleidoscope image. Okay, so let's recap for the website. We have three
things. First one is we have a static notebook preview for every new book on the repository
and it generated by GitHub action. So whenever we push to the repository, a new static preview for
that notebook is generated. Second, we have the Pluto Slider server, all sliders, buttons,
everything works directly on the website. And then finally, because Pluto can switch backends
dynamically, we can connect to a binder session in the background.
So how can you make sliders and buttons work directly on the website? So the first thought
might be we run just one Pluto server and every visitor connects to the website.
As an example, notebook for today's demonstrations, I have this. I have a slider for dogs,
slider for cats. And here I combined the two into a single text, works like this.
And then I have text fields. And it says I like whatever you typed in. And so if everyone would
be connected to the same Pluto instance, then everybody's sliders would be connected. And you
would see each other's inputs and you would see each other's outputs. So that's not what we want.
Okay, so the next thought might be for every person who connects, we start up their own Pluto
server. But that will take too long. And that's the problem we're trying to avoid in the first place.
Okay, so we want to try to get all visitors to use the same Pluto process without the
synchronization issues. So what exactly are the problems? So the first one obviously is that
all visitors can now edit the notebook, even though they're just visiting your website.
The solution is quite simple. We disable the editing, and then nobody can edit the notebook.
All right, next, the inputs are linked. So that means that sliders get each other's values.
Also quite simple, we disable this feature, and then it's not a problem anymore.
So the only one that remains is that outputs are linked. And to demonstrate this,
let me show you what it looks like when you disable these two features.
Okay, so if we disable editing, and we disable synchronized sliders,
then you essentially have the first version of Pluto Slider Server.
And right now you see two clients connected to the same website. So the slider is not
synchronized, and you see that it's working. But if I now move the first slider on the right,
you see that it's now telling me that I have nine dogs and seven cats, even though my slider is
out one. And the reason is the slider server, which is running the notebook, there, cats is
still set to seven, because that's the most recently set bond value. And to understand this
problem, how do bonds normally work in Pluto? So whenever a bond is set, it sends a message to
the server, just saying, for example, if you move the dog slider, dogs is now five. Then the Pluto
server responds with the things that changed after running the cell. So it says cell three is now
five dogs and one cat. Then you set cats to nine, and it says five dogs and nine cats.
You set dogs to four, it says four dogs and nine cats. And now you set dogs to five again,
and you get five dogs and nine cats. The problem here, which is what we were experiencing,
is that this is stateful. So this request bind dogs to five gives a different response than
this request. So in both requests, I'm saying dogs is five, but depending on the things that
happened before it, you get a different response. And so this is the problem. This is what we need
to avoid. So the next thing I tried was whenever you move one slider, we tell the server the
values of all bonds, like as a single collection, and it will run all of them at the same time.
Okay, so this is great. And it actually worked quite well. But then you get some new problems.
A notebook that we come in like we had in the course was a couple of sliders and a plot,
and then a couple of sliders and a plot. And they're all just like one slider controlling one plot.
But with a strategy like this, it means that changing any one of those inputs
will send all inputs, then run all of the plots and send all of them back to the visitor.
So it took more time and it was using more network than we needed. So here comes graph theory.
Instead of sending everything, we use like proofs analysis to figure out just the variables
that we need to send. And in this notebook, you can see that when I'm changing dogs,
the cells that will run is just this one cell, and it doesn't depend on the favorite foods.
And so we create a bond connections graph, which you can see if you open the JavaScript console
on a website like this. The first thing it will print is the bond connections. And for each bound
variable, it gives a list of other bound variables that could affect any of the
things that depend on it. So when I am changing dogs, I should also send cats because they have
an output in common. And you see that favorite foods is disconnected from that other graph.
And so this works really well. But it's still different from the way Pluto normally works.
And it can still happen that your notebook, when you're running in Pluto, it works really well
and it's super fast. But then on Slider server, it's like more naive. And it's sending more
bond values than you think. And it's running more code than you think. Good example is if you have
one camera input, and then two sliders to select a pixel from that camera input.
In Pluto, you just take your webcam picture once and it's sent to the server. And then
after that, it's just the slider values. But with this slider server, every time you move a slider,
it's also resending the picture of your face because there could be two people visiting the
website at the same time with different faces. So that's a problem. I have some ideas, but maybe
you have some ideas. So this is a problem. I have some ideas on how we can improve. Maybe we can
somehow reuse the previous workspace in case nobody else is visiting at the same time.
And then also maybe we can give better debugging, make it easier for people to
understand how their notebook is connected and help them figure out the best way to disconnect
a bunch of variables. And I'm curious to hear what you think.
Now, because we managed to make these requests stateless,
Paniottis had a very good idea, which is first of all, instead of a web socket connection,
each bond request is an HTTP request. So that means that we don't need to worry about the
web socket breaking down and you're closing and opening your laptop and the connection is lost.
It only makes a request when you move a slider. So that makes things a lot easier,
and you can do things like custom routing, etc. The second thing is now we can cache requests.
So because each, like I say, the notebook state is completely described by your notebook file
and your bond values, that's exactly what we put in a URL. So the HTTP request is a GET to
slash state request slash and then the hash of the notebook file. So the notebook file changes,
the hash changes, and then the base 64 encoded bond values. So together, this URL will always give
back the same response, which is like the state update to show the new cell outputs. And so we
can cache it. So we set the cache headers of these requests. And so you can see this in action on the
computational thinking website. When I first moved this slider, it takes it a while because it's
computing like everything needed to do it. And then like I keep moving this and every time there's
a little bit of lag also because I'm in Europe and the server is in the US. But then now if I go back,
let's see the two was new. So now if I go back, you see that it's cached. So these go instantly.
So first of all, it's cached in my browser. So now I can move this and get new value super fast.
But the second thing, you can also cache it on like your DNS. So Cloudflare, for example,
which means that someone else who's also in Berlin will get these first values a lot faster now.
And then the other thing, which is also possible is to do like a cache on your server itself. So if
you have an engine X router, you can have it also cache results. Right. So to do, we want to make sure
that like the difference between writing a Pluto notebook and having it run on a Pluto
site server is as small as possible. We might need to create some new debugging tools so that you
better understand the differences. So the second thing is that we need to make the deployment easier.
So we do have a Docker file, but we should really make like a simple step by step plan.
But still deploying like a Docker container can be difficult. And we're happy to say that Julia
computing will be helping us with this. And hopefully in the future, it will be really easy
for everyone to just turn the notebooks into static websites. But with live sliders and an easy way to
like run that notebook directly in your browser. All right. That was it. Any questions? Let me know.
All right. That was amazing. I think it's so cool that you can publish your websites now
or your Pluto notebooks interactively. There were a couple of questions. The first
from Michael is, are there any plans to pre-compile notebook code for faster startups?
Yeah. So that's something we definitely played with a lot, but it's quite difficult.
So first of all, one thing is like if you change the notebook and it redeploys, you just want to be done as quickly as possible.
So then it doesn't make sense to first pre-compile and then from that pre-compile system it.
But if you deploy a notebook a number of times without changing your dependencies, for example,
there's a big benefit in not specifically pre-compiling a sys image, although that does
have a benefit, but just getting the environment instantiated so that plots is already downloaded
on the server where you deploy. So yeah, we're experimenting. It's difficult, but hopefully
we'll get there and we're happy with your contribution, of course.
So another question. What are a couple of ways that someone might go about hosting
their own slider server Pluto notebook? Right now it's a bit tricky and I know of
one other project. They're using it. They're actually presenting tomorrow
and they did it just by looking at the GitHub repository for the MIT course.
So that's computationalthinking.mit.edu. And if you look at the source code, you'll find the docker
file. And if you know a bit about docker files, then you should be able to deploy it.
But soon I will write like a one, two, three step plan of how you can do it.
And it should be easier. Yeah. And like I mentioned, Julia computing
at the end of the last talk today, they will present their integration that they're doing
with Pluto. And in the near future, you should be able to do this directly like on JuliaHub.com.
That's fantastic. I think at this point we'll be moving on to our next talk by Benjamin.
Thank you so much, Vans. All right. We'll start in a bit.
