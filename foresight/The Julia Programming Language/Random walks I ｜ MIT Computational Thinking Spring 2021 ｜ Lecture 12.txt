So, hi everybody, welcome back to another class in spring 2021 18S191 6S083 Computational Thinking at MIT.
So today we're going to talk about random walks.
We've been talking quite a lot about different kinds of ways of thinking about randomness and modeling that in the computer and this is a particularly interesting.
In my opinion, I like this subject a lot and it's very useful to model many situations in engineering, science, finance, etc.
So I'd like to start off by, you know, let's think about so what is a random walk and then why is it useful.
So let's just start off by visualizing a random walk.
So here I've got a particle and it's living in two dimensions and it's just going to jump at each step to a neighboring site.
So it can move up, left, right, or down on this grid that you can see.
And so as I move this slider, we're going to see that dynamics happening.
So there it moved up, then it chose to move down, then it choose to move down again, left, etc.
So basically at every step it chooses one of the four directions with uniform probability equally likely.
Okay, so that was just 10 steps. What if I take more steps?
So now I'll just take 100 steps instead and it does something like this.
Okay, so it just literally is dancing around at random.
Now let's increase the number of steps a bit and now it looks more like this.
So you can see that it's still, you can still see the kind of graininess of moving on this lattice or grid.
You know, it's starting to look, you've almost lost that graininess actually.
And if I increase the number of steps, you know, but I'm still plotting it kind of within the same window, same sized window,
then actually you can basically no longer see that it's actually moving on a grid and it's just moving around at random.
So now let's look at another system that's actually completely different,
which is a lot of hard disks bouncing off each other.
So just a minute, let me get that set up.
So, so can you see this visualization now?
Yep, and we see your slack tip.
Yeah, sorry about that.
Okay, let me close that.
So, okay, so here we have just a large number of hard disks, and we're going to put them in to, to move.
So each of these disks, you can think of as a molecule moving around.
So this is really a visualization of a gas of the molecules in the air in your room, or, or in a fluid moving around.
And each of them is following Newton's law.
So it's just basically moving in a straight line until it meets another disk and then it collides with that disk and bounces off in a way that conserves energy.
So I'm going to actually label those disks.
And I'm going to follow one in particular, and I'm just going to draw its trajectory as it's moving around and bouncing off these disks.
Let's speed that up a bit.
This is all in real time.
And then I'm actually going to, so you can see that, yeah, in the, this dynamics is being generated by this particle being buffeted by being moved around by these other disks.
Now I'm just going to turn those other disks off, and we'll just look at that particle doing its thing.
And if you did not know that that, what the underlying dynamics was, you would say, oh, that particle is just moving at random.
So what is the origin of randomness in, you know, physical systems, at least, it's actually that we have all of this other stuff going on in the system, and we don't know about it.
And so that's effectively, you know, giving us something that looks random, at least.
So this is basically, you can, you would, you would think that this particle was jumping around at random choosing random directions at each step.
And so, you know, this trajectory actually looks a lot like the other trajectory that I already drew.
I think that this, I feel like that's the path that I'm forced on when I get off the subway during rush hour.
Yeah, exactly.
So, so this kind of process, random walks is, you know, is, so this is, as I said, a random walk is jumping at random.
And what I'm saying is that actually we can find behavior that looks like that in many, many systems, physical systems, the stock price or let's just go and look at the Apple stock price.
For example, whichever stock price.
I'm just going to do a Google search for Apple stock.
I'm going to look at sort of one year's worth of stock date stock prices, and you can think that this is some kind of random walk as well.
So, of course, it's not completely random because you know the start of this, this year it was just drifting upwards with some randomness on top so it's not doing exactly the same thing as we're modeling.
And so the question is, well, can you actually predict that particular piece of the motion and you know people make and lose billions of dollars a day doing that.
Okay, so let's go back to, it's so difficult to keep track of where windows end up.
Sorry.
Did you want to review what Julia concepts we're going to learn today.
Yes, good.
If I can find window that would be helpful.
Meanwhile, we could look at the Apple stock price over the past year.
But I just completely lost where the actual window is.
My kids keep telling me I have way too many tabs open on my yes, that is always my problem but I mean I had it all carefully planned and then you know, it all starts going on.
Okay, this seems to be it.
You had it and then it disappeared.
No, that's not the right one.
I'll just mention while you're looking that when I was an undergraduate.
Almost everybody was reading this book called a random walk down Wall Street I think it's still maybe a very popular book.
So, in case you were wondering whether random walks were relevant to stock prices that that book kind of said that everything was basically a random walk.
So basically, we're going to look at how we can, you know, implement random walks, and that's going to involve various different concepts.
So when we want to generate a random walk, we want to do just left and right.
So there are various ways we can implement that and we want to actually compare them maybe to see which is going to be the most performant the most fastest solution in Julia to do that.
So we're going to use this package for benchmark tools, which is a very nice provides a very nice interface to just quickly benchmark a small piece of code called a micro benchmark.
And we're going to plot several random walk trajectories. And so, in order to do that we want to have a loop and inside the loop we want to plot over and over again, and sort of adds on to a the same, the same plot different trajectories.
So if you've actually tried that in doing you'll realize that that's not actually there's some trick to it.
So we'll discuss that we'll talk about a very important concept which is generic programming.
So I want to write the same a single piece of code which is generate a random walk trajectory and then I want to run it for different types of random walks.
This is very similar to what we did last lecture where we had different random variable types, which we can sample from.
And we're going to look at.
So when we create those random walk objects we want to either we want to we need to change their values somehow so we could do that by by changing what's inside them or by creating new new ones.
So that's the concept of mutability versus immutability.
And then we want to run a function with a type as a parameter and so we'll have introduced the Julia word where and see how that works.
And we'll need vectors or vectors, which is, you know, we'll have a vector or that will be evolving in time.
And so we need to store all of the time evolution of all of those vectors inside something and that something is going to be another thing.
And we'll talk about aliasing of memory which is when two different names point to the same place in memory, and the cum sum function, which is for cumulative sums.
Okay, so we've seen the motivation. So, so this this this two dimensional random walk is so by the way, later on we're going to talk about discrete versus continuous so you can see that as I increase the number of steps.
I'm actually, you know, you're sort of losing the as I said losing the fact that we're living on a discrete measure or grid or lattice, you're losing that information or losing that fact.
So in some sense we're converging to some kind of random process which doesn't know that there's a grid there and it's just taking little steps of different sizes in different directions.
And that's actually called Brownian motion. So the original physical, the physical discovery by Brown in 1827 and pollen grains moving around under in a microscope at seemingly at random.
That that that that physical processes called Brownian motion and then mathematicians have developed this, this theory of these processes where you take this limit, the limit of the size of these grid cells to zero and you get this sort of random process that is has also been named Brownian motion or the
linear process.
So, so, so we've already talked about a couple of examples of where random walks are useful stock prices. You can think about pollutants getting dispersed in the air if the air is calm, then you have some molecules living in the air and and they'll they have some sort of random motion, because
they're moving into air molecules effectively and they'll gradually spread out and this diffusion process is important at the microscopic level.
And you can also think about in a very different context about neutral genes that are neither good nor bad, how they spread through a population that some kind of diffusion process.
In the simplest way we could model this kind of random motion in space so we have something that's moving in time and in space now. So we haven't really had that before. We just had, you know, we modeled radioactive decay or recovery of individuals, they just had a state that was on or off.
So now we actually have a state, sort of internal variable for each object that is a position in space that can change, you know, all the time and arbitrage can become arbitrarily big in an either positive or negative.
And so this is a very different situation you have really two variables space and time.
Let's look at the simplest possible version which is called literally simple random walk where we just take values plus or minus one at each step on on the on the real line so we're basically living on the integers.
So you say that we start at zero and each a particle jump left with probability a half and right with probability one half at each step.
Okay, so before you were moving in two dimensions that was your space. Yeah, now your space is just one dimensional restart.
That's right. Yeah, we're simplifying down to the simplest possible situation. And so we're just jumping left or right so that's almost the same as the Bernoulli random variable that we've been looking at, except the Bernoulli random
variable takes the value zero or one. And now we want values minus one or one. And we want to generate those randomly with equal probability.
So I've got a heads that might go right and it tells me to go left.
So there are various ways we could generate those random value. So I just did a few of them here, and I put them into different step functions.
So here I'm defining the first step function, I can literally just take Rand of the tuple minus one and one. And as we've seen, you know, ran when it's given a collection will choose one of these objects one of these items with equal probability
And so I chose a tuple here with these parent round parentheses instead of square brackets, because with if I had square brackets I would be creating an array at each step, and that actually is a very is actually quite expensive because you need to allocate memory, whereas
the tuple, in some sense does not allocate memory.
Can you add a step five and do that and we could see it.
Step five is Rand of the array with square brackets minus one and one.
Okay, so then now what we want to do is test how fast is each of these functions. Now each of these functions is going to run in nano seconds is super fast.
We have fast computers these days.
I actually get a decent measure of the time what I want to do is run these functions zillions of times, let's say a million times each or something that will take less than a second to run.
And so I would need to write a little piece of code that ran these functions and calculate at the time and divide it and took the mean and whatever.
And so that has already all been done for us in this benchmark tools dot jl package.
I remember just functions that somebody has written. It's just a collection of functions and one of the functions or actually a macro, it's called at the time so be for benchmark and time.
And so it's literally at, you know, it's literally, what is the benchmark time. And so I just give it a piece of Julia code and it will run this Julia code, lots of times, and take some kind of statistics of it and report that back.
Now for a second and just like, I always have to think this through like a millisecond is one one thousandth of a second, right a microsecond is a millionth.
Yeah, so seconds is like a one billionth of a second. Yeah.
One billionth in the in the American interpretation.
That sure seems like a very small unit of time.
Yeah, it's very, very fast. Yeah, if you think about it, you know, computers, like this laptop is something like has a two gigahertz processor what does that mean giga is 10 to the plus nine.
And so that means it's doing two times 10 to the plus nine operations per second and so each operation takes about one, 10 to the minus nine seconds in other words one nanosecond.
And this reporting are actually in the on the order of six nanoseconds. So it's, it's doing is thinking about six.
I don't know clock cycles or something I'm not an expert on this check maybe Charles can can help us out to do to do this ran of minus one one so somehow it's it's doing some calculation which we haven't gone into in the course about how do you generate
randomness, and then it's just picking one of these using that source of randomness.
There's a little little coin flippers inside there's somebody with a little little a little person with quite inside flipping.
That's right.
So, so this is in order, you know, these four functions and I added this fifth one and see how well that does.
So this is one of these are the results. So this is step one step two step two step four step five. And so you can see that. Okay, firstly step five is just really super so much lower it's like.
So you can also see that when I run it again, you know these times are not that stable it's actually very difficult to do these benchmarks in an accurate way because the times are so fast.
When I run this calculation is competing with all the other processes that are going on at the same time in my computer like broadcasting over zoom. And so that's going to affect the times a lot but but so this is just going to give us a general kind of idea.
And what we can see is basically, I mean this this array one I claimed that it was very slow and now we're actually seeing that oh yeah it's ridiculously slow right is like five, say, roughly five times slower than the than the others, or even more.
Whereas the others are sort of all the same order magnitude but this this the sign of brand and is kind of a bit slower than the other ones and then the other ones are more or less the same speed.
Let's run it again. And excuse me.
So we can see that okay the time changed a bit but basically, yeah, it's actually difficult to say between the first three which of them is the best because they kind of change order, each time you run so that basically I would say they're roughly the same speed.
And then the fourth one is definitely, you know, say something like 40% slower, and then the last one is just just orders of magnitude slow and order of magnitude slow.
Okay, so, so what are we actually doing here so you know for example this one ran less than 0.5 we know that that generates true or false with probability 0.5.
And then we're using that as if it were an integer value we're multiplying it by two that gives me either zero or two with probability a half each and then I'm subtracting one and that gives me minus one or one.
So you can see that, you know, you might want to, and there's random ball that literally generates a random Boolean values are true or false. So you can see that that is, you know, roughly the same speed as doing this.
So who knows exactly, you can go and check exactly what what's what's going on, you know, under the hood by looking at the source code.
And of course, you know out of all of these options, which is the easiest to read. It's this one. And so I would actually definitely prefer that just because, because we see that it's roughly the same speed and the code just looks so much easier to understand.
Okay, but but you know, definitely this is a good message to to to realize that if we can avoid making arrays with square brackets we should and one way is to just make tuples instead.
And yeah, okay.
So now let's that's just one step. So now we want to simulate a random walk in one dimension. So we want to do lots of these steps one after another. And we're going to call that the trajectory of a random walk.
So this is a position that's called walk one the that just literally does that so it'll take a number of steps and, and then we'll start off somewhere let's say zero, stop at position zero is an integer.
We'll store that position in some vector of all of the positions, which are called X is. So this is a vector with which starts off with just this one entry.
And then I'll loop through the end steps of my walk, and I'll add the result of a step. I'm calling the function step remember to call the function we need these parentheses if you don't put the parentheses.
It's just that the object that is the function step one.
I'm putting that onto the current value of X and I'm adding, you know, I'm accumulating, I'm like, putting that at the end of the X's array and time accumulating the values of X as I go along.
And that then I'm returning that vector. And so if I just do sort of X is equals walk one D of 10.
And that's going to be the coordinates of my random walk as it moves along. And if I run it again of course I'll get different ones they can go negative etc. And so as usual, you know humans are bad at looking at these numbers and so let's plot them.
So here is a plot of 10 trajectories of 100 steps each of those random walks and I'm just going to run it a few times and we can see that oh yeah those start to look like stock prices right.
So these are 10 different stocks and they all started off at the same price but because of the market effects etc they're all doing different things.
And if I just increase the number of stock of stocks or random walks to 10 to 100 sorry, you can see that something interesting starts to happen which is that we get a kind of shape, some kind of shape that's spreading out at some rate.
And then we move along in time. So time is on the x axis.
Let's just add that.
I didn't work, so I forgot the exclamation mark.
There we go. So that's as we move along in time. This is the position in space right so let's add a Y label which is position in space as sort of. So I've been thinking about it as you know the X position in space.
Sorry.
So, you know we're literally each of these is moving along, but there's threading out to some of them are, you know, by time 100 some of them are actually around zero again, but some of them have already got out to position 20, but none of them has got anywhere
like example position 100. Why is that because to get to position 100 that's possible, but they would have to move left or right at right at each time step.
And at each time set that has a probability on one half and so the probability that they'll actually reach position 100 is one half to the power 100 which is a tiny number that will never see.
So there's lots of interesting theorems about you know how far does this cloud actually spread out right so I can just run it for a bit longer 1000 steps, about 1000 walkers that wasn't what I meant.
But anyway that's 1000 walkers and you can see that okay the shape starts to take starts to take shape. And so you can actually again ask well what happens if I just took more and more and more walkers what the shape be, and you can start to ask a theorem about that and that's related to the central limit there
and that's what I mean. You know if you think about yeah. Okay, but what I wanted to do was actually take longer trajectories.
You see, of course we can add sliders to do this. And, you know, we get something like that and you can see that there's some concentration around the middle and then there's fewer around the edges, etc and you can ask.
Well, as I said, well what's the sort of function that describes how far we are away in this theorem called the law of the iterated logarithm that does.
So that's great, but that's only a one dimension. Well, you know we started off in two dimensions. So, now let's think about how we could simulate a random walk in two dimensions.
So what do we need to change. So if we look at this walk 1D function, it's very, it's, it's pretty specific to 1D, or is it. So what what is specific to 1D. So the initialization is specific to 1D.
So I said it started at the number zero.
This is not specific to 1D if I have a if I have an extra represents the position this will make a vector of objects of that type whatever that type is this is using Julia's, you know, I haven't said anything about types explicitly in this function.
But then step one is also specific to 1D because that was you know that we designed to do a step in one dimension.
So nothing else is basically not specific to 1D. And so what we want to do is turn this code into something that is generic. In other words that the same piece of code will work for any random walker that does anything.
So, for example, it could, you know, jump. It doesn't even have to live in the integers it could jump a distance that was a number distributed uniformly between minus one and one a real number.
And then it would live, you know, on the real numbers.
You mean you don't have to copy and paste code for every new situation and edit it a little bit.
Yeah, so, okay, that's a good idea. So let's copy and paste this code and, you know, make it walk 2D and then we would have to go and change this. Oh, I'm going to start at sort of the vector zero zero something.
And then, oh, but now I want to do 3D. So now I'm going to copy and paste that code again. And then, oh, no, now I decided that I want to, you know, do something extra inside this walk 1D function.
And now I'm going to have to copy it again in 2D and 3D. And that just gets, you know, I've spent too much of my life doing things like that, what I didn't understand software and software design software engineering.
And it's really nasty. So I mean, I think that's such an easy temptation. I mean, I think you've all done it.
Yeah, so I mean, to some extent, I would say that, you know, I always say if you're, if you need to do something twice, you know, just copy and paste. But as soon as you find yourself doing it a third time, you need to think, Oh, is there some way that I can rewrite my code so that the computer automates this thing that I'm trying to manually automate
So let's try and think about that. So I want to write a function that I'll call trajectory that works for any random walk.
So one way of doing that, that is not in the current version of the notebook is the following. So let's call this function step instead of step one.
And instead of x equals zero. Let's make make this into I actually want to modify this version of the function is like a new version of the function. I'll just call it walk of and I'm going to say x equals initialize
and x plus equals step. So if I do that, then if I try and run this function cause it won't work because it doesn't actually know what the initialize and step functions are. So let's just write those. So initialize equals zero and step equals ran of my minus one one.
So once I've done once I've written those functions are initialize when I was I've written those functions now that code works right so I have at least replaced the sort of explicit call in this function with with a with another function.
And now how can I actually make this generic how can I what what does that mean it means I need to be able to tell Julia.
Which initialize function and which step function I actually want to use. How can I do that. So, although I've defined these functions, just now.
Well, what I could do is actually, I want to be able to replace these functions with different function names right so I want to actually.
Let's do a 2d version of this so initialize 2d equals. Let's just use vectors for now for simplicity step 2d. So it's a vector zero zero it's going to start at the origin in two dimensions and now step 2d is going to choose a random direction in two dimensions so we could do that like this
So I'm going to choose a random two dimensional thing, but okay so it looks like what I have to do is copy and paste this code, call it walk 2d, change this to initialize 2d changes to step 2d and then that'll all work that's great.
I can now call my walk 2d function with 10 steps and doesn't work because I needed ran of the vector of those vectors right so that's the first time I think that we've seen a vector containing vectors.
Right so you can see that there's a vector and what is inside is the things that are separated with commas and the things that are separated with commas are vectors right so if I actually.
I could call that directions equals this vector.
But I need it to be a vector of the vectors and then what is the type of directions.
If you faster have to have a tuple of directions like you showed us before.
Say that again.
Why not a tuple of directions like you showed up.
Why not a tuple of directions that's a great idea.
You claimed that with faster so yeah I could do that yeah but I mean the fact that I'm actually using these arrays is already going to be slow so it doesn't actually matter.
I see it's already polluted by the inside so the already polluted because every time what I'm doing is creating a new array of one of these.
Is that true.
Yeah I think so.
So you can see that what is this type of this thing is a vector of vectors so by the way I'm using Julia 1.6 which I don't think we said has actually now been released a couple of weeks ago maybe one week ago.
So now you can just download Julia 1.6 and that has this nice new printing that it's a vector of vector and it's telling me that that's just an alias and another name for array of array with one dimension which is you know harder to read.
This is one easier to read.
This is a vector of vectors.
Okay.
And by the way, in order to have better performance I can also make this constant, which means constant.
And that that just makes things faster and if you use global variables which you actually really show.
Maybe I should say a word about switching to 1.6.
I think in previous years, although you want to type version info somewhere.
I think in previous years, I would never have recommended switching in the middle of the semester, it would be a recipe for disaster, but I am, you know, a little bit fingers crossed but 99.99% confident that it would actually cause you no trouble whatsoever.
Hopefully yes.
So yeah, if you this capital, this word version in capital letters, this is a feature of Julia, which tells you which Julia version you are using.
And that is a list that gives you this was designed to 1.6 but that is actually a string, right, because it's in quotes, and you see this little V in front of the string that's a non standard string little literal just like we saw a couple of times ago.
So it's a special sort of string object in Julia that represents a version number for a package.
I always type version info.
There's a function called version info.
This is a function, and that will tell you all kinds of you need it with terminal to mention about your function except that you need with terminal.
You should print it out, rather than printing it on the terminal where you launched Pluto from it's now going to record that information and put it here.
So you can see which platform I'm on which Julia version I'm using and all kinds of express stuff that you probably don't really want to know about.
Okay.
So now I can put ran of the vector directions or the two pull if you prefer.
And it will, you know, so step to be when I call it.
This is the nice thing about having an interactive environment I can just check does my function actually work. I'm just going to run it a few times, and it's returning a random direction it seems to be working fine.
Okay, so now I should be able to call my walk 2D function and there it is walk 2D does a two dimensional random walk right so it starts at zero zero moves to minus one zero moves back to zero zero etc and it's sort of gradually moving on average sort of away from zero.
So now I want to do my walk 3D and I'm going to have to rewrite this function yet again, so that's not that's no good. So what do we want to do, we want to actually make a generic walk walk function which uses an initialized function that I special that I specify and a step function that I
specify. And the way I can do that is actually to pass those functions as arguments to my walk function. So I can do this initialize comma step. And now when I call initialize inside this function it will realize oh initialize that must be referring to this argument that I'm passing into walk and and it's treating it as a function is going to call that function.
So when I do define this walk function.
I'm now going to have a walk function where I'm going to pass in initialize, which is this. Let's call it initialize 1D.
What was that?
I've totally lost track of where my functions are.
Don't even see it now.
Anyway, whatever, so I can pass in the initialize 2D function and the step 2D function and 10 and it will do a walk in two dimensions. If I passed in initialize and step which are the 1D versions, it does a walk in one dimension.
So let's just put that on a different line.
Okay, so that's the 2D version. There's the 1D version. So I've written a piece of code which is totally generic. It works with any initialize function and any step function provided this operation is actually allowed, right?
So I have to have a step function that returns an object which I can add to the current value of the of the object X. And that's why I actually used vectors in, you know, the directions vector, because if I had used tuples inside the directions
vector, I would be trying to add two tuples together. And that does not work. So one, two plus three, four is not, is actually not defined. I cannot add tuples and base two. I can add them with dot plus.
And so I can actually change this to be dot plus equals step and then it would work if I put tuples in there.
Okay.
So you might like that version and I kind of like it, but there's still, there's still something missing, right? If you think back to last lecture, what is missing? Well, I cannot actually talk about, oh, I have a two dimensional random walker.
So where in my code is there a two dimensional random walker? Well, it's, it's encoded in the fact that the position of the random walker is a vector, and the initialize function returns a vector and the step function returns a vector of the same type.
But it's all sort of delocalizes spread throughout my program.
So what I want to do is concentrate all of that information into an object, which is eight called a 2D random walker. So that's what we need to do.
So how can we do that? We follow a similar idea to what we did with random variables last time. In fact, this is very related to random variables. These things are sort of random variables.
Sort of more general kind of random variables.
Okay, so let's make it more general. So we want to make a random walker object. So we know how to do that now. Struct walker 1D.
So that's going to be my one dimensional random walker. It has a position, which is going to be an integer and a 64 bit integer. And what I'm going to do is just like last time we made abstract and abstract type which was random variable I'm going to make an abstract type which is
Walker. And I'm going to assume that any walker has something inside called position.
So I'm going to assume that in general walkers will have a something an attribute or a field called pause for position.
And then I'm going to make a function position, which which acts on any object of this abstract type walker so this is supposed to tell me what is the current position of any kind of random walker.
And the answer is what is going to extract the field pause from my object called little W.
And then how do I do a step of a 1D walker. Again, I'm just going to generate a random number from those positions. And so, you know, so I can generate a walker 1D by, I can create one by just calling the constructor.
So let's suppose it starts at zero, but it might not right I mean I could have it start the 10 instead that's okay I can do that. And of course I could make a constructor that does takes zero arguments and fills in the position as zero.
And then I can can just begin there, and then it works. Hopefully.
Yes, and then I can instead make just walker 1D with nothing inside and it will put the put in the zero for me. And then I can see okay well now how do I step that walker.
And then W is going to return just how the walker needs to jump. And so what is missing in this prescription is, well how do I update the value right how do I change the value of walker.
How do I change this position. And so let's try the most natural thing which is w dot pause equals what right okay or equals minus one in this case right because it's jumping left.
And I'm going to try that and it gives me an error and and says me that an immutable structure type walker 1D cannot be modified.
So that's, so when I when I use the word struct, it creates an immutable object, which means unmodifiable I cannot actually change the values that live inside the object.
And so it seems a bit pointless because, you know, then I can't do dynamics of a walker so why did I know.
I made it mutable by writing mutable struct walker 1D and then I would have been able to change it so let's just try that so let's make a mutable struct called a mutable walker.
So if I make a walker called w2, which is mutable.
And I make his value zero now I can reach inside and sort of manipulate its internal organs and changes value to minus one, and it moved.
Okay, so that is definitely one possible approach you could use. That's often the approach we've used previous in previous years.
I would like to show the opposite version where we actually do not do that and we make a new object at each moment right so how can I update this, I can't really update it but what I can do is say okay, so I have my immutable walker walker 1D object.
I cannot change the value that's inside that walker 1D object that's living in memory somewhere or maybe it isn't even stored in memory that's the advantage of using the one advantage of using immutable struct is that you might not even need to store them in memory they could just sort of live in the CPUs of sort of registers or something.
So how can I change the value of w I can just make a new walker 1D object with a new value and assign it to the same variables w although include I can't actually do that in a different cell.
So I can do it. I have to do it in the same place that I, you know I can make for a new walker object w3 with that that that very, that very.
That's a slight disadvantage of using this approach with computing.
Okay, so what I want to do is now. So that's that's the approach I'm going to use. I can actually create a new object of the same type with a new value inside.
This seems like it must be expensive computationally but actually it is not this whole operation will just be sort of compiled away and it will disappear and you'll just effectively the actual code will just literally modify the value of this position.
So now we need a new function which is update. So that's what's going to update the, you know, it takes in a walker of type which I call w capital w so little w is the walker object capital w is the walker type.
And it takes a step value. And what it's going to do is calculate the current position of w add the step to it.
And then look what is it doing it's taking this type w and calling it with this argument and so it's actually creating a new object of the same type w with the new value.
So that's exactly what I just did with his walker view one one day of one. But in order to do that it needs access to this type w. And so that's why I use this Julia syntax which is where.
So what is w here w is kind of another parameters or another variable if you like.
But it's a type parameter. So what I need to say is this I need to I'm telling it w is a type that's because it's a type annotation here colon colon w that means w must be a capital w must be a type.
But I want to actually restrict that type to say oh that type w has to be a subtype of walker, but actually it can be any subtype of walker and that's basically what this where it means.
So there's a lot of moving parts and I don't know I could get a bit confused, looking at this. So, could we break this down a little bit like, in the context of this lecture, what, what, what capital W's are you talking about here.
You had walkers and steps and all sorts of things.
Yeah, is sort of like Walker 1D, the Walker 1D object type, the Walker 1D type, or the Walker 2D type.
Okay, so could I see this working and being updated on both those types.
So I have a Walker 1D type, and I want to update this I'm going to pass in w and I'm going to pass in the way, the step that I want it to take.
What does it return it which is a new type of Walker 1D.
Sorry new objects of type Walker 1D with a new value, but this is a new object it did not modify w.
Let me let me say that back slowly to see if I've got it. You've got this w which is a Walker 1D at zero. You do update.
And now all of a sudden I have a Walker 1D at minus one. If I updated that again what would happen.
So the point is that I'm not currently not changing the value assigned so you can think of a variable name as kind of an arrow that points to a particular piece of location in memory.
So what I'm saying is when I'm doing this I'm not actually modifying the value that w is pointing to.
Yeah I see that w is still at zero.
It's still pointing to the same thing that it was before. What I have done is created a new object somewhere else in memory, conceptually at least, and some, you know, that new object has a new correct value.
And so now what I want to do, I would like to do w equals the result of updating w. And I want to make w point to that new object instead.
But I can't do that in Pluto.
That's a Pluto problem, right? That's a Pluto.
If you're in the repl you could do it.
Yeah, if I were, exactly, if I were.
But what I can do is I can do that within a function.
So let's do write a function.
Wait, wait, wait, I'm not ready for a function.
So your examples make me think this only works on Walker 1D.
Right, so let's do it with Walker 2D. So let's call w 2D a Walker 2D with position minus one minus one.
Let me make it 0 0 to be analogous to the other one.
Sure, 0 0.
That doesn't work. Why doesn't that work?
Oh, I haven't, I haven't defined Walker 2D yet.
Oh, that's a problem.
So how can we define Walker 2D? So I decided to actually define it in a different way. So I could have defined it with a vector.
I could have just used the same idea, right?
I have steps that's going to return a vector.
And I just add the current version of step to this version of Walker 2D.
But I wanted to illustrate a point. And so I didn't do it like that.
All right, so you could go Walker 2D of left brand 0 comma 0 right brand.
Yeah.
By just deleting the brackets.
Exactly. So that makes a Walker 2D. And now I want to update that Walker 2D.
And now I'm going to update it with a vector minus one minus one.
That makes a new Walker 2D object where it has modified both of these arguments.
So, so, so the interesting thing that you're pointing out is that if you update a Walker 1D, a Walker 1D comes back, you update a Walker 2D, a Walker 2D comes back.
That's right.
Sorry.
That's sort of magical that, that, I mean, or maybe it's obvious that that's what it ought to do.
But if you go back to your update syntax, we could see exactly where that happens that that that there's W this capital W in the middle of all this is a variable type.
I mean, you've illustrated it with a Walker 1D and Walker 2D.
So, yeah, so that the function sort of calls the constructor of the type W to make a new object of that type.
That seems as powerful as it is difficult to remember how to use.
It is powerful. Yeah, I, you know, when I was writing this, I was thinking, well, how can I actually make this work? And this is, this is the way that I think you have to do it to make this work with that.
And that's because we're using immutable objects. If you use mutable objects, you could just reach in and change the value and that's actually much easier to do.
And so,
Why don't you do that?
Yeah, okay, so.
No, no, what, why, why are you choosing not to do that in your own implementation?
Often, yeah, because people.
Yeah, that's a good question.
There's, there's a lot of people who like, who prefer to have functions that do not modify the objects that they're acting on, because that's actually harder to reason about.
You can just have what you can call a function and it might modify something and you don't even realize that it's modifying that and that's actually hard to debug.
And maybe it's difficult to parallelize or maybe it's difficult to etc.
And so that actually, you know, there's this whole world of functional programming where the idea is you want to minimize the side effect.
When you modify an object, it's called a side effect.
Whereas, so what we're doing here is creating a new object and that's sort of much more, that's much easier to analyze from a computer science point of view.
So if we have mutable objects, you could have just written something like this, we're going to use update bang.
So this is a different function, it has a different function name, we have this bang on the on top.
And that is a convention in Julia that we are modified that that's actually sort of, you know, a Julia program writer signaling to other people using their program that this function is special because it is modifying the object.
Right, so this will be a sort of w mutable as has to be a mutable walking out.
And now we don't need that type anymore because we're not going to create an object of the new type.
What are we going to do, we're going to say, let's just make this a function to make it clearer. We're going to say, I'm going to reach inside w mutable, I'm going to modify its position as its current position.
We're going to do that. Let's just say, what sort of current current position equals w mutable dot pause.
And I'm going to say new position current pause equals w mutable dot pause new position is current position, plus the step that I'm trying to do.
And then I'm going to say, okay, now update mutable objects position reaching inside is and modifying its internal organs that's the way I like to think of it equals the new position.
And then that's all it doesn't even return anything or doesn't need to return anything.
And so that's, that's easier to understand, but it's harder to analyze the program so it's actually, you know, it's actually, it's often, it's often recommended that in Julia you try to avoid these mutable objects you can always avoid them.
And you might get, you know, easier code to write.
So we use mutable mutability mutable objects. You can see that yeah we don't have to go through this, this weird thing with this this type, which we're going to use to create any objects etc.
So it's definitely conceptually easier but, but it's actually people prefer to write it in the other way to know if Charles wants to say anything about that.
We're almost out of time.
So how can we now use that all to write this trajectory function. So a trajectory needs a walker again. So let's add this.
So I'm passing in w of type capital W again and I'm specifying that capital W has to be a subtype of walker so this is only going to work for sub types of Walker, you might actually remove that restriction.
So then a is the number of steps that I want. So the first thing I do is calculate where is doubly right now by calling this position function that's often called a getter function, because it gets, you know, a value that belongs to the object.
I don't love that name.
And then I'm going to do my loop. And so I'm going to calculate just like I just did basically the current position. I'm going to update.
And then I'm going to see this is where I'm reassigning reassigning the value, reassigning the variable w to a new object.
So this update is actually creating a new object of that type.
It does not have a bang. It's making a new object of the type with the current w and the step function applied to that doubly.
And then I add that to position. So this is actually a version of that walk function. So I call it walk before now I'm calling it trajectory sorry, maybe we can call that walk as well.
And this is not going to be a walk.
So that is now I'm passing in a walker 1D object. And what it's doing is at each step is creating a new walker 1D object. And then, but I'm only accumulating the vector of their positions over time.
So there is the vector of their positions of these walker 1D objects.
So the idea is that this walk function is now totally generic. I don't need to pass in the functions initializing step. This function step here is what I spent I specify for each new walker type that I introduced.
So for example, here's a 2D walker, as I said, with x and y separated instead of an in vector. So what is the position of the walker I'm actually returning it decided to return a tuple.
So what does step do it returns this vector, just like we did before. But now, how do I update. Well, update now has to know about exactly the represent the internal representation of position and the internal representation of step, and I chose these two
representations to make a point, which is that now I have a specialized version of update, a specialized version of position actually, because before I said that Oh, the position of any walker object, any, any, any object or any type of walker is just going to extract the
pause field, the fields called pause from the object. But now I don't have a, I chose not to have a pause field for this purpose. And so I actually make a specialized method that only works for walker 2D, where it returns something else, which is the vector of these two variables that are stored inside.
And then, so that's an example where I'm sort of telling Julia how to specialize the these functions that I'm using in my generic code, just for this particular type.
And then, now I need an update function to because the update is special to because I have these two different representations, the, the representation is two values and the representation is a vector. So here I, you know, how do I change the X coordinate I add the first component of the step
dot X, and the same in Y, and, and I return my new walker 2D. And so when I do that, it all works. And so that's an example. I think it's a good example of generic programming where, you know, this function doesn't change all that I change is I specify, you know, each of these functions that I need for my walker object for the new type of
walker object. And I can basically do the internal representation representation however I want. And this function still just works.
Exactly.
I know it's a bit intricate, you know, it would, if we really wanted to just simulate a two dimensional random walker we don't need to go through all of this.
And we could have just copied the walk one D function and made a very simple walk to the function instead. But I think this is very illustrative of how you actually go about really building up more complicated pieces of software.
Okay, so unfortunately we're out of time so there's a little couple of more more topics that are very interesting that we can do next time.
Okay, thanks everybody. So see you on Tuesday.
Monday. Sorry. See you on Monday.
It's Monday. Yep. It's April next Monday.
Okay.
Bye.
