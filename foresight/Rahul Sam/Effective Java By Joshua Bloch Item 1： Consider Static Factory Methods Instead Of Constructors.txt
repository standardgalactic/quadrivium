Hey everyone, welcome to this video series called Textbook to Code, where I take computer science
and software engineering textbooks and sort of expand on them and convert them to code and discuss
them, kind of like what one would do in a tutorial in university. Now, if you're new to this channel,
I generally make videos on philosophy, but I realized my other great love, other than philosophy,
is computer science and software engineering. So I was thinking, why not do the same thing with
that field too? And as the title suggests, the first book I'll be covering is Effective Java by
Joshua Block. Certainly the best Java book I've read, even though I'm still trying to grok certain
concepts on it. It was recommended to me by my CTO and my current company, and he's been a Java
programmer for, I don't know, ever since the internet. That was a joke, by the way. I know Java
was created after the internet. He's been a Java programmer for a long time, and he said that this
was a really good book to read, not really for beginners, but more for intermediate Java developers.
I consider myself still a beginner to intermediate. So I don't really know
at what level I should get into this book. However, I do believe really the way it's structured,
anyone can jump into it if you have a basic understanding of programming. So Effective
Java contains about, I believe, 90 items, which means this video series will encompass 90 items.
And afterwards, I'm hoping to get to this book, which probably is going to be next year, because it
takes a long time to make these videos. The Headfirst Design Patterns by O'Reilly, which I've just
started on, and it's brilliant. I'm so grateful for all these authors who just don't take so much
time to educate and help upcoming learning software engineers like myself, who generally
aren't the most intelligent programming wizards out there. Saying that, though, as per usual with
my normal videos, if you do follow this channel, you know that I tend to make a lot of provisos or
caveats. And the first proviso is this is not a tutorial. And that's really important, because
the last thing I want to do is to propagate false information or teach something that's wrong.
And, you know, to make this a video series of misinformation to use a very politically loaded
term. I'm not a teacher, not an expert. I've only been a Java programmer really hands on for about
two years. I'm still learning myself. I'd like to think of this video series and all the videos
in this channel, as a matter of fact, as more of a blind, leading the blind kind of experiment,
let's say, where I am also naive and ignorant about these topics. So it's just more of a
exploratory disquisition, let's say. I'm just trying to see what this particular concept is.
I'm trying to break that down, which means I will inevitably make mistakes. No question about it. So
please point them out. Leave those out in the comment section below. I'm sure there are much
more advanced competent Java programmers who will point out some of my flaws. And when I say a blind
leading the blind, I don't mean I'm leading anyone else in that sense. The point I'm trying to make
is that let's try to collectively work on this. And again, the best example I can use or the best
analogy I can use is what one would typically do in a university tutorial where you work with the
tutor and the other students to solve a particular problem. And of course, since this is a programming
video, engineering video, all the code that I used to expand on the first item, I shall have it on
my GitHub account. I'll leave a link down below. You could go download it and play around with it
yourself. On that note, let's jump into it. We'll start with item one. So this is from
chapter two, creating and destroying objects. I'm not going to cover chapter one because it's
essentially just an introduction. And the same way that I gave caveats in this video,
Joshua Block himself gives a couple of a few caveats on what this book is about.
Just in context, Joshua Block is is brilliant. He he was, I think he created or he was a big part
of the Java collections framework. He's a distinguished engineer at Google, I believe.
So he's been a part of the Java JVM community for a long time. And I suddenly look up to him
and I really enjoy just even watching some of his talks on YouTube. But this book, this book
really opened my mind into the power of the Java language. And in fact, OOP principles in general.
So again, as I said, chapter two is creating and destroying objects. And the first item
we're going to cover is let me zoom in a bit because I don't want this to not be visible.
The first item we're going to cover is consider static factory methods instead of constructors.
So when I read this item, the moment the first time I read this chapter,
oh, sorry, this item, my question was, what is a static factory method?
And and in simple the very textbook answer would be, it's a static method that returns an instance
of a class. Now, don't worry, I've got the code base right here, we're going to jump into all of
these things in much more detail a bit later. But I think it's sort of important at a high level to
get the terms right and get them all in order just to help out thinking. Look, I'm just going to say
my thinking, I'm not going to pretend as if this is a collective thing. It's initially me making a
video. And then eventually, hopefully it can be a collective thing in the comment section down below.
And you know, not a Benet, this is not the same as the factory method design pattern.
Even though I'm not going to lie, it maybe this is my lack of understanding of the design pattern.
I see many similarities between what the static factor method does and then the design pattern.
So perhaps that's why it's called a static factor method. So let's take a look at the keywords,
first of all. So when we say a static factor method, and let me give you a quick example,
in fact. So here we have the big integer class and a static factor method here would be
that right there, public static, big integer, the probable prime method, for instance,
is a static factor method. Which means we got a question that I asked myself was, what is static?
And I took down a few notes. Of course, the word static means a lot in software engineering.
And my notes said that the word static ensures that a member belongs to a specific class. So again,
in the example of this big integer class, this member belongs, this member has in this method
belongs to this specific class. Therefore, only one instance of the member exists, regardless of
the number of objects of the class created. So it doesn't matter how many instances of the big
integer class is created. But there's only going to be one instance of this method,
because this this method, the probable prime method belongs to this big integer class,
there won't be multiple objects of that being created. And a static member is shared amongst
all objects. So because it belongs to a certain class, any any other, let's say, client that
uses this class and creates an instance of this class with the new keyword, just shares
that specific object, pardon me, not all the objects, I think I'm a spoke there,
more the static member, I think it's better to think of it that way. So of course, I'll get into
all of these stuff in detail a bit later. So of course, that means that when you want to use this
method, the probable prime method, one doesn't have to create an object of the class, you know,
use the new keyword, the way it's done in Java, it just makes things easier.
Also, and another caveat here, my understanding of Java memory management is very, very high
level. I know it's a very deep topic. It goes all the way into the depth of what computer science is
and engineering in general. So I have a very, very superficial understanding of it. But my
understanding is that static content, so any, it could be a class, a variable, a method,
doesn't matter, will be stored in a in a place called the dynamic meta space. This is a JVM,
will will store it in a place called the dynamic meta space, which I've learned to replace something
called the permanent generation since Java 8. So all these static members live in the dynamic
meta space. Now, here's, this is an important point that we're going to get to in this video.
I've, I've, I've got a whole bunch of resources and study material that I used as I was creating
this video and studying this book. So for each item, all the, what's the word, supplementary
reading material and studying resources, which I have a whole list here, just articles,
blog posts, videos, whatnot. I shall leave them down below in the description. I really think it's,
it's super useful, along with the book, along with each item, reading those supplementary articles,
it gives, at least for myself, it gave a really good understanding of what Joshua Block is talking
about in each item, especially given that he, he expects the readers of this book to be
quite proficient in Java. So if you're sort of a, in an intermediary level like me, these, these
background articles help. And on Java memory management, a very grokable, easy, easy to
understand video that I watched was by Naveen Automation Labs. I thought he explained it quite
well. He's a great pedagogy, great teacher. It made a lot of sense to me. And then I read
this article about what the meta space is in particular, because since we're talking about
the keyword static. So along with the word static, the other sort of keyword of these methods is
factory. And here's where I said before, it seems a bit similar to the factory method design pattern.
And maybe, maybe it's because it does follow certain aspects of the
creation and design pattern, even though there's no direct relation. In fact, in the book,
it says here, there's, oh yeah, it says here, note that a static factory method is not the same
as the factory method pattern from the design patterns. I feel terrible now when I looked at
the book, I realized that I've highlighted certain things, as you can see, these bits from the book
I wanted to read out and I didn't do it in the beginning of this item. So I'm going to do that
right now. I'm so sorry if this is chaotic and a bit messy. Please forgive me. I'm still
trying to figure out how all of this works and how to expand on these matters. So I'm going to read
this is a mess. I'm so sorry. I'm going to read the introduction to the item now,
which I was supposed to do in the beginning of the video, but I only realized that now.
So here's what Joshua Block says. The traditional way for a class to allow a client to obtain an
instance is to provide a public constructor is another technique that should be a part of every
programmer's toolkit. A class can provide a public static factory method. There we go.
Which is simply a static method that returns an instance of the class. I'm glad I read that
because I should have started with that bit because it's too confusing if not. Anyway,
getting back to the the factory keyword. So what this also does is it allows to encapsulate the
object creation process because if you do notice and we'll get into this again, the constructors are
private. So clients cannot access the constructors and create objects as they wish. In many ways,
is in fact one of the advantages which we'll get to again later of using static factory methods.
The class can decide when to create new instances of the class and it's not that a new object is
created for every invocation when a competition is required. So therefore, I don't know if this
makes sense, but I think it's because it resembles certain creational design pattern.
Let's say elements, the word factory is used to describe them.
So now let's get to the why the advantages. What's the justification? Why is Joshua Block telling us
to use static factory methods instead of constructors? How one would typically do the first one
Joshua Block talked about is that unlike constructors, static factory methods have names. They
tell it to the client or they indicate to the client what this method's doing. The example he's
used is in the big integer class. Now he said here, the constructor, which is this, which I've taken
down here. So in fact, maybe I should go to the code itself without just showing it off notion.
If you go to the big integer class, here we have the, all right, sorry, it's a really big class.
I have to go through the code. The constructor here, which is the constructor for the big integer
class. In fact, on the comments that even says here constructs a randomly generated positive
big integer, there's probably a prime with the specified bit length. But it also says here,
it is recommended that the probable prime method is used in preference to this constructor,
unless there is a compelling need to specify a certainty. Correct. So what this does is it just
returns a big integer, which could be a probable prime. But this is just a constructor. It's just
the name of the class. It doesn't really, to me as a client using this, doesn't tell me what this
does, which is why it's better using the static factory method, the public static big, big integer
probable, probable prime conference. I would right there where when I met me, a client is using it
as I've used it right here. I clearly know what this method is doing. It makes the code clean.
And of course, a class can only have a single constructor with a given signature. You can't
have, at least in Java, I don't know about other programming languages, but I don't think so.
One can't have multiple constructors for a class. I assume maybe I'm wrong there, but that's at
least my understanding. And then a very basic question to ask is, what's the purpose of a
constructor? The purpose of a constructor really is, as the name suggests, to construct a class,
as it's said in the Oracle docs, a constructor is used in the creation of an object that is an
instance of a class. Typically, it performs operations required to initialize the class
before methods are invoked or fields accessed. Constructors are never inherited. So for me,
at least as a client, using the probable prime method makes more sense. He says, because a class
can only have a single constructor with a given signature, programmers have been known to get
around this restriction by providing to constructors whose parameters, whose parameter lists differ
only in the order of their parameter types, so method overloading. This is a really bad idea.
The use of such an API will never be able to remember which constructor is which and will
end up calling the wrong one by mistake. People reading code that uses these constructors will
know what the code does without referring to the class documentation. Because they have names,
as in static factory methods, we don't have this restriction. And when I was reading this paragraph,
I had a bit of a grin because in the project that I'm currently working on, which is a huge
enterprise, massive Java project, I think we've got 40 odd microservices. I see this happen all
the time. We, you know, a lot of legacy code, we've done a lot of method overloading. And sometimes
when as a client, I'm using a certain class, or even if I'm instantiating a class, I'm not even
sure which method, which parameters to pass into the method, because it's been overloaded so much
that it's hard to work on as a client. Whereas with the big integer class, I exactly know what I'm
doing here, just using the problem prime method. So the second justification or advantage is that
static factory methods, as I sort of said many times already, do not require object creation
each time they're involved. It's one of the biggest advantages, in my opinion,
that this allows immutable classes for sure. It's also similar to the fly weight design pattern. Now
I put this note here, just because I want to kind of put into the notes everything that's in the book.
I have no idea at the moment what the fly weight design pattern is. I haven't done any further study
into that. So hopefully, when I do, I'll probably revisit this and leave a comment explaining what
it is from my point of view. The example that we can use here is in fact, this little method
method that I created, it's an example from the book, which was this method right here. It's this
simple method that I created called value off. It's an example from the book. So if I want to
use this method, and this method is in this class called manipulate strings, I don't have to create
an instance of the class. Let me demonstrate. So for instance, if I go here, and if I want to print
out something, let's just say value off, and we go manipulate strings dot value off, I'm going to
pass a true there. And then I run that, you will see it'll just print true. Okay, sorry for the
useless method. And as you saw there, I didn't use a new keyword. There were no objects being
created. I simply accessed the method via the class, because that method's owned by the class,
so to speak. Then another advantage of not having to create objects is, and it took me a while to
grok this concept, because I had to do a bit of stack overflowing to use a term that we all love
as soft engineers. It makes classes instance controlled. So it says here in the book,
the ability of static factory methods to return the same object from repeated invocations allow
classes to maintain strict control over what instances exist at any time. Let's try to understand
this. So firstly, just keep in mind this makes a class singleton and non instantiable. So essentially
singleton means it at a given time only one object of that class can exist, whatever the class might
be, if we follow that pattern. And I really only understood this thanks to Joshim Sao who posted
a really good answer on Stack Overflow. I shall leave a link to this down below of what this
concept means and how using static factory methods makes classes singleton and immutable.
So to get this concept first, let's see what Joshua Block is saying. He's saying that
yeah, it allows immutable value classes as I repeated multiple times already. And then it says
to make the guarantee that no two equal instances exist as in A equals B. So class A equals B only
if it's equal in this sense as in this equals sign means that the values in the objects are compared
the double equal sign is a reference or memory location of objects in the heap. So as I said,
thanks to Joshim Sao, I think I got what this meant. It gives complete control to the class as to
when instances of this class will be created. Now here's the example that he has used. So I did have
it here. I'll zoom into that. One of the methods here is deprecated. So you can't clearly as you
can see here in the docs, it says that it's marked for removal because we don't really create new
instances of the Boolean class anymore. Now I'm going to comment that out for now. And see here,
if I print this, we're getting a true and false despite the first one because we're looking at
the value in the object, we're getting a true but here in the reference comparison or in the memory,
we're getting a false. Now personally for me, this was okay. I got what he meant conceptually,
but really what I did was this. I created another small class called fooba. As you can see, I made
the constructor private. So it's inaccessible to any client. And then what I did was I created a
static factory method called construct fooba. If you can clearly see here what I'm doing is
I'm returning a new instance of the fooba class. But in the method body, I have an F condition.
And I say only if the number is greater than five, is it allowed to create a new instance of this
class. Now, yes, one could say you could do this in a constructor too, but doing it in a static
factory method makes more sense due to the previous advantage we spoke about, the fact that we can
use the name in the method. So you probably see here, I'm going to comment this out again.
Now I'm using the construct fooba method and I'm passing initially I'm passing the number seven.
And then if I run that, it's if I zoom in here, there you go. That's the that's the object that
that was passed through. So it returned a new object of the fooba class. But that's because
seven is greater than five. But if I like pass two, it's an R. So this is this is what
Joshua Block means by it's it's it gives classes complete control as to when instances of that
class will be created. On that point, I would also say just to just to keep in mind that enum types
provide this guarantee by the way. So if you do this comparison that I did before between different
classes or between different types, you'd see it follows a pattern with enum types.
The third point is, or the third justification or why so to speak is, unlike constructors, static
factory methods can return an object of any subtype of their return type. This again, a bit like the
instance control bit, it took a bit of time for me to understand what it meant. So let's see what
we mean here. The best example to use is certainly my favorite Java framework, the collections framework
is to demonstrate what an interface interface based framework is. So the first thing you'll notice is
if you go to the collections framework, I mean the class, sorry, if you go to the public class
collections, it's constructed as private. So you can't instantiate it. And then if we take a look at
this little bit of code that I put in, I'm creating a array list. I'm creating, in fact,
two array lists, a source and target list of string type, and I'm adding values into it.
And then in the collections class, I'm using this static factory method right here. And
what that does is it returns, let me just read the documentation is much easier because they put it in
much better terms with brevity, returns the starting position of the last occurrence of the
specified target list within the specified source list or a negative one, if there is no such occurrence.
So here we have the source list, here we have the target list. And what I'm trying to see is I'm
trying to find the first occurrence of this value of the target list in this case. So as you can see,
this CDE, which is the, let's call it the sub list for the old intents and purposes,
it starts at the index number two, zero, one, two. And if you print that out, it returns that here.
Now, that's, that's besides the point. But the important point here for over here is that
the collections class is returning a type of index of integer. It's returning a subtype,
as it says here, is that unlike constructors, they can return an object of any subtype of their
return type. So it's returning an integer subtype, which is different to the type of the
collections class. And then of course, he expounds on the matter, he says, this technique
lends itself to interface-based frameworks, where interfaces provide natural return types
for static factory methods. And of course, a good example of that is the collections framework. This
class itself just going through it would prove that. Then he says, prior to Java 8, interfaces
couldn't have static methods. By convention, static factory methods for an interface named type
were put in a non-instantiable companion class named types. So these kind of methods
had to be moved to a separate class. And then, as I said, he says, for example, the Java
collections framework has 45 utility implementations of this, of its interfaces, providing unmodifiable
collections, synchronized collections, and the like. Nearly all of these implementations are
exported via static factory methods in one non-instantiable class, namely this right here,
Java utility collections. Furthermore, using such a static factory method requires the client,
which is me in this case, to refer to the return object by interface. That's what I'm doing right
here. Interface rather than the implementation class, which is generally good practice. The
fourth advantage is that the class of the return object can vary from call to call as a function
of the input parameters. And the example he's used in the book is that in the enumset class.
So let's take a look at that. What I've done here is, oh, by the way, the example I've used is,
thanks to Bill Dung, I know that every Java developer out there uses this website as
reference, but I know that all of us struggle to pronounce this word right here. I think it's
pronounced Bill Dung. It's the best outside of the Java Oracle docs itself. It's, in my opinion,
the best resource out there. So courtesy of Bill Dung for this example. So to get back to this,
what does Joshua Block mean by the return object or the class or the type of the return object can
vary from call to call, depending on the input of the function. So I'm using the static factor
method, none of here, which is a part of the enumset class. And I'm passing a enum into it,
which is this enum I created called color, which is contains about a bunch of colors.
And then it returns a enumset. Now, what changes here? So what changes here really
is this. In this method, you could probably see, it extends to generic. That's fine.
Well, not that's fine. It has to be a generic because the types have to differ.
So of course, if it's null, it'll throw a class class exception. However, you see this, the
returning object, there are two types of objects that are being returned here. If the length of
the enum pass, so the enum, but I'm passing colors here, if the length of this is greater than or
greater than or equal to, sorry, less than or equal to 64, it'll pass a new instance or a new object
of the regular enumset class. So if I run this code now, you'll probably see here, I'm printing
out the class name of the return enumset. The class name is regular enumset. It's in fact a
subclass, pardon me, or a subtype to be more accurate. If you look here clearly, it's of a
different type. It's not the type of enumset. Now, what happens here though is if the past enum is
greater than 64, it returns a different type called a jumbo enumset. So it's this flexibility
that using a static factory method gives us. So to reiterate, depending on what the input is to
this method, a different type can be returned. It'll vary purely based on the input. And then
Joshua Bock says that clients need to know, no care about the class of the object, they get back
from the factory. They care that only it is some subclass of the enumset. Correct. As far as I'm
concerned, when I was using the none of method, all I wanted it to be was of the type enumset.
I didn't care what subtype it was or what subclass it was. And that moves to the final
justification as to why one should use static factory methods as per recent by Joshua Block.
And I got to say, if you can already see from this video, I'm even struggling a bit to explain
myself and properly articulate my understanding of these concepts. Perhaps that's my own lack of
communication, lack of the ability to articulate myself, but also it's because I'm still dealing
with issues and trying to make sense of it in my own mind. This one right here, the fifth point,
it took me about a week to write the script. The fifth point, I spent four days on it because
it did take a bit of understanding of the JDBC framework to see what Joshua Block is talking
about here. The fifth point he tries to make is that the class of the return object need not exist
when the class containing the method is written. So let me reread that. The class of the return
object, whatever the method invocation returns, need not exist when the class containing the
method is written. Now, firstly, he says such flexible static factory methods form the basis
of service provider frameworks. I was a bit embarrassed because I've used JDBC quite a lot,
but I didn't know that it was a service provider framework. I didn't know that that's what it was
called until I read this book. And it's kind of funny how, by the way, I just want to make this
point here. The great thing about reading such books is that all these different libraries,
like all the frameworks like the collections framework or JDBC API that we use in our day-to-day
job that we really don't think too much about, we start really appreciating the engineering and
the kind of the craft of them once we understand the reasoning and the principles behind how they
were built. So this is a good example of how JDBC is a, sorry, my mind threw a blank there,
a service provider framework. So I find it a bit hard to understand the point
Joshua was making using the JDBC framework. However, just to get the ideas of what it is,
I put together this bit of code here. And as I read before, it's got the provider registration
and the service interface. So in the startup code here, the driver manager dot, sorry, the
registered driver, this bit here is the provider registration and driver is the service provider
interface. And then if we go here to connection again, connection is the service interface
and driver manager dot get connection is the service access API. So essentially what I'm
trying to demonstrate here is the different components of what the service provider framework
encompasses. And as you clearly saw, I had a terrible job at explaining how this relates to
our item in using static factory methods, which is why I found a much simpler example
on second of a flow where we have this right here. This was by Bruno Reyes and I thought he
explained it much better. So he says here, with this code, your library doesn't need to know
about the implementations of the service. Users of your library would have to set a system property
containing the name of the implementation they want to use, which is if we go down here,
this static factor method here, which is stored in this class will just give us a new instance.
As in, I don't care if this class was created or if it exists or not, all I'm expecting is because
I'm getting it through the through the contract between the interface that I'm getting a
instance of the my service class. That's it. Gosh, I think I butchered that. So again, to reiterate,
this static factor method for name is going to provide an instance of some class, which is
the class right here. In this case, it's the driver class. And that's all I care about. I just wanted
to come off this type. I'm doing a typecast here. And that's all I really care about. And that's
because of this contract that I have with the interface, essentially. Okay, this is why I said
that this isn't a tutorial, because that fifth item is something that I'm still struggling with.
And I swear, I try to make sense of it through the JDBC framework, but it's still it was a bit
hard for me to really grok. And then I found this answer on Stack Overflow, which I thought was
done much better. But look, if any of you know a better way of explaining it, please do leave it
down in the comment section, I would be very grateful for that, because that's certainly one
advantage from this item that's still I don't I don't still fully get. So having discussed all
the advantages or justifications, a proposal, using static factor methods, let's now get to the
limitations. The limitations aren't really much. So it makes a lot of sense to use them in most
places, unless there's an exception, let's say. The first one is that classes cannot be subclass
without public or protected constructors. On the note, just before I get to demonstrating what this
means, there's a good resource, sort of, I guess, an answer on Stack Overflow that I found, which
discusses why constructors are needed for subclassing. And I thought it was quite good. So I'll leave
a link to this in the description down below too, if you want to go give it a read. But simply,
it's very easy to show. So here I have a class called main. And then I have one class, which is
another another class called animal with constructor. So if I go to that right here,
here we have the public class. And we have a public constructor, as you can see here,
now I can easily go to the main class and type extends animal.
There we go. And it simply extends that class. However, now I have another class without a
constructor. In fact, I've made the constructor private. So it's not accessible by the by the
subclasses. And if this tries to extend this, and it raised wrong, it says here,
there is no default constructor available in the superclass. So and also if I try to create
an instance of this, we get the same error. What's funny here, though, is of course,
Joshua Block says, and I'll read this out. Arguably, this can be a blessing in disguise,
because it encourages programmers to use composition instead of inheritance.
Exactly. I don't have to extend that class. I can use one of the most fundamental OOP
design principles to try and favor composition over inheritance. The second limitation is that
he says, I don't even really know what he means here, that it's hard for programmers to find that
these methods are hard to allocate. I'm not sure if that really applies anymore, because with,
for instance, I use IntelliJ with really powerful exhaustive ideas like IntelliJ,
all I got to do is hit command and click on the method and boom, I'm there. I've got the docs,
everything I need. So I wouldn't say it's hard for programmers to find. Nevertheless,
he does state that. So I'm sure there's a good reason for it. And then what he says is because
some of these static factor methods are hard for them to find that he's going to
enumerate a few of them and list down some commonly used static factor methods.
So I thought I'd do the same. And once again, all of this code is going to be on get up. So if you
want to take a look at some of these methods, just click the link down below and you'll have
access to it. So the first one is a from method, which does a, it's essentially a type conversion
method. So it's quite easy to understand really what we have here is we have a type of instance,
and we pass it to, to, to the date. And from, from that instance, we get a type of date. So
it does a type conversion. If I run that code, you'll see that that instance type was converted
to a date type. And then it printed it down here. The second one is a aggregation method.
What this does is similar to a previous example that I use, is it takes this enum list. So I've
got a enum, uh, cold rank here, Jack, Queen, King. And then it just gives us a set, an enum set of,
of this enum right here. So if I do print that out,
you can see here it's printing that set under face cards. So it makes sense to call it an
aggregation method. Cause what it does is it takes all these different items in an enum,
enum class, and then aggregates them and returns a type of enum set. And then we have the big integer
value of, which again, this is the same thing. It's a type conversion method. Uh, and he says,
yeah, it's a verbose alternative to, to from and off. So in this example, you could probably see
I'm passing into this method, uh, something of type integer, and it returns something of type
big integer. So it does that type conversion there. The next example is, uh, it's sort of like
I've created a quasi demo for this get instance methods. Essentially what it does is that it's
described, uh, it returns an instance that is described by its parameters, if any, but cannot,
but cannot be said to have the same value. So the example here would be, I've got this void method
called method three, and this stack walker class here is getting an instance of the, uh, class,
this class that invocates this method. So here is, this is in the stack walker demo class.
And as you can see, if I go up here, there's an instance, uh, oh, that was a mistake. I should
have, I wonder, I should have made that a static method. I don't know why I, let me correct that
right now. Public static. That is good because it shouldn't be a, sorry, that was a confusion.
The actual static factory method was this in the stack walker class to get instance class.
This is what happens when I work on these things way back and I record the video on a separate day.
Sometimes even I forget why I did what I did, but just to get back to this. So I've created
the stack walker demo class and I've created an instance of it right here, which is boom.
And I'm accessing this method through the object or the instance of that class.
And what this is really is, it just prints out the caller class. So the stack walker
dot get instance, as you can see here, it prints, it gives us a reference to the class that invoked
this method. So method three was, method three was invoked by this class here,
the common static factory methods class. So if I print this out, you'll see here,
it tells us, huh, this was the class that invoked this method and it's using the get instance
static factory method. And the next example is quite similar. The new instance method will
guarantee that every invocation of it will return a instance of the string dot class here, the class
that I've specified here. So I'm passing an array and then I'm also passing the type of the class
here. In fact, let me just go to that method. It takes these parameters as shown here, it takes the
yes, the component type, the type of the class, it's a generic, and then the length of the array.
That's what this does. And if I print that out here, it just prints out the type of the class
you can see here. It's just a string class that I've passed through. And then the get type static
factory methods are similar to the example, not this example, the previous one with the stack
walker demo class that we, with the get instance demo there. What this does is it returns a different
type, essentially. So if you look at this here, I'm getting a path, I've got a file that I've
created. And if I go to the files class, it's of type files, obviously. And then this get files
to static factory method returns a different type. It returns a type of file store, despite being
in the class files. And if you look at the method, you'll see, I'll zoom in there again,
the get file store, it's in a separate abstract class called get file store. Pardon me, it's in
a separate abstract class called file store. So it's not in the files class. And similarly,
the buffered reader does the same thing, but instead of getting a new instance, it creates a
new instance. So if you go to the buffered reader, which again is in the files class,
if you go to the static factory method, it is returning a new instance of,
whoa, that's a bit weird. Oh, of course, of buffered reader. There we go. And of course,
similarly, the new type, this is the same thing, but instead of getting an instance,
it'll return a new instance. So if you go to the new buffered reader static factory method, which is
in the files class, by the way, as you can see here, it returns a new instance of buffered reader.
Again, it's a different type or to what what files is, or it's in a different class, let's say.
And finally, really, all the other stuff won't even that useful because, well, they are useful,
but I think most of us use this, the generics, which is in the collections, things like less
area lists, which I'm in the collections framework. And what this does is it returns a new vector
of a given type. So for instance, I've created this enum called complaint, and I can create a list
of that type and add stuff into it, essentially. And if you want to see, it's going to print all
that stuff. All these examples that I've used was sort of in the book, and I repurposed them
just for me to understand. But really, from all the static factory methods I went through,
I think the ones we use mostly are the ones in the Java collections framework. Nevertheless,
it's important to enumerate all of them. And in summary, Joshua Block says, static
factor methods and public constructors both have their uses, and it pays to understand their
relative metrics. Often, static factor methods are preferable. So avoid the reflex to provide
public constructors without first considering static factories.
That was much harder than I thought. I have to admit, I thought I could sort of go through my
thought process, but you know, any programmer would understand that sometimes we don't even
know what we do, what we do, we just type and things just happen. That's fascinating, isn't
it? In any case, I hope you enjoyed the video. I hope you found it informative. I certainly,
as I said in the proviso middle, I'm sure I've made a lot of mistakes, so please do point them out.
In some sense, selfishly speaking, for my own learning, but also so that I don't
mislead anyone and provide false information. I've already started working on the next item.
I'm still rereading that item and starting the different examples. The second item is
consider a builder when faced with many constructor parameters. I shall hopefully get to that soon,
but at least for now, I hope you enjoyed this item and I'll see you in the next one. Cheers.
