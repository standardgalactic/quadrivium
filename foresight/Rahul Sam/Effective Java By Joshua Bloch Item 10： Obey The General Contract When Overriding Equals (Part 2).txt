Hey, everyone, welcome to part two of item 10, obey the general contract when overriding
equals of Joshua Bloch's effective Java. Needless to say, please do watch part one to
make sense of this item, because it's just a follow on from from part one. And I'll be
working down this item into multiple parts, because it's quite long. But without further
ado, let's get started, because this is quite a long part. So in the previous part, we discussed
when it's appropriate or warranted to not override the equals method. Generally, it's always a good
idea to override the equals method. However, there are certain instances where it's not required.
And we discussed that in part one. And in part two, today, we're primarily going to focus on
when is it appropriate to override the equals method. And afterwards, kind of kind of gonna,
we're gonna go into detail as to what the general contract is. So firstly, I propose when it's
appropriate to override the equals method, Joshua Bloch states, it's appropriate when a class has
a notion of logical equality that differs from mere object identity, and a superclass has not
already overridden equals. So we did discuss what logical equality was in the previous part.
But for all intents and purposes, as a Java programmer, what we care about is
in logical equality, a programmer doesn't care about the memory reference or the
the quality of the object per se, but rather the content or the value of an object.
The easiest way to put that is by looking at classes such as string or integer, where if we
take, in fact, string, string objects are immutable. So there's only one object of this type that exists
in memory and everything else will point to that. So in this context, when it comes to logical
equality, what we care about really isn't the object per se, whatever the data of that object is,
however, the value of the object. So we should only care about this bit here. And that means
it's logical equality. So if you have string s, and then we also have, let's say,
that was a mistake,
a string b, let's say, both these strings, s and b, have logical equality because the content is the
same. So these classes have a notion of logical equality. And then he states, not only is overriding
the equals method necessary to satisfy programmer expectations, it enables instances to serve as
map keys or set elements with predictable, desirable behavior. And then he adds an ancillary point
saying that enums or enum objects are an exception to this value class heuristic,
I coined that term value class heuristic, he doesn't really use that term. But I feel like
to understand the concept of logical equality, apropos Java programming, that is a good heuristic
to keep in mind. So enums, though, are an exception. That's what he states. And just to get some
formalities out of the way, let's say, according to the Java language specifications 8.9,
here's how an enum is defined. An enum type has no instances other than those defined by its enum
constants. It is a compile time error to attempt to explicitly instantiate an enum type. The final
clone method in enum ensures that enum constants can never be cloned. And the special treatment
by the serialization mechanism ensures that duplicate, duplicate instances are never created
as a result of deserialization. Reflective instantiation of so that's from the Java
Reflections API. Reflective instantiation of enum types is prohibited. By the way, what that API,
the Reflections API does is it changes the structure of classes on runtime. It is not something
a normal Java programmer would do. It's mostly used by framework designers. So I've never used
the Reflections API, but it's just good to keep good to keep in mind what it does. Anyway, getting
back to the definition, sorry for interrupting it. Reflective instantiations of enum types is
prohibited. Together, these four things ensure that no instances of an enum type exist beyond
those defined by the enum constants. And again, attending to our point, it's for these classes,
so enums, logical equality is the same as object identity. So objects equals method functions as
logical equals method. What that would mean really is, if let's say this S and B were enums,
if the objects were identical, we could say for all intents and purposes, there's also logical
equality. So here's a small demo. Let's take a look at it that I put together. So I have two enums
here. Day and day two both have days of a week. Now, if I do run this, it's going to print false
because there's no logical equality in this case because there's no object identity. However,
let's say I create two instances of day. Day dot, was it Monday? Yeah. And then I'll also create
another day two with the same thing, with the same day. You'll see here, if I print this out,
if I do compare these two objects, it'll print true because the logical equality here
equates to the object identity. So I'll just go day one,
day two. I'll comment that out. You'll see a true being printed now.
That's it. So the object identity equates to the logical equality. And that makes sense.
So reiterating that point, so the idea really settles in our mind,
overriding the equals method is required or is appropriate when logical equality
differs to object identity. Now, I accept the enums class, of course. Whenever we know that
object identity is not equate to logical equality, override the equals method. And that gets us to
the general contract when overriding the equals method. And that's what we're going to discuss
for the rest of this part. And in fact, the next part too. And there's a lot to get into here.
All right, before we get to the properties that define this general contract, I need to skip ahead
a bit and read a caveat that Joshua Block has put in. Because in fact, I wish you would have put
that bit earlier before getting to the properties because the caveat is a good starting point
in understanding these properties. Because it's really important that we don't ignore them.
They can be a bit overwhelming to understand. Nevertheless, ignoring them isn't the solution.
It's enduring through and assisting and trying to make sense of them and implementing them in our
code. So here's a caveat Joshua Block has put in. Unless you are mathematically inclined,
this might look a bit scary. So what he means by that is the properties that he listed down or
enumerated. But do not ignore it. So don't ignore these properties. If you violate it, you may well
find that your program behaves radically or crashes. It can be very, very difficult to pin down
the source of the failure. To paraphrase John Donne, is that how you pronounce his surname?
D-O-N-N-E. John Donne, probably. No class is an island. Instances of one class are frequently passed
to another. Many classes, including all collections classes, depend on the objects passed to them
obeying the equals contract. Just on that point, there's a really interesting kind of philosophy
in object-oriented programming. And I think even Alan Kay, the inventor of OOP, he makes this idea
that I'm going to get a book. I was reading this book by Sandy Metz, which is a book on
object-oriented design, but using Ruby. And what she states in this book is that it's better to
conceptualize object-oriented programming more as message-oriented programming. And even Alan
Kay, I believe, said in one of his talks that he wished that people emphasize the importance of
messages between objects than objects themselves, which is the point that Joshua Blocks making here,
all these contracts, all these properties that define these contracts that we ought to respect
and take into account when writing code, they're more about the messages and how objects communicate
with each other. Therefore, it requires a bit of a change of mindset. In any case, I don't want to
get too carried away, but I thought that was an important point to add on to what we're discussing
here. So given that we've got that caveat slash warning out of the way, let's get to the specifications
for the contract. The equals method implements an equivalence relation. It has these properties.
So there are six properties, sorry, five properties. And in this part, we're going to discuss three of
them, especially because symmetry, sorry, not symmetry, transitivity is quite a loan property
and there's a lot to discuss there. So, and then in part three, we'll discuss consistency and
non-nullity. However, that's later on. Let's stay on track here. So what is
equivalence relation? And what does it mean to have equivalence relation between two sets?
Look, Joshua Bloch puts it best. Here's what he states. Lucy speaking, so this is pertaining
to equivalence relation, which the equals method implements. It's an operator that partitions a
set of elements into subsets whose elements are deemed equal to one another. These subsets are
known as equivalence classes. For an equals method to be useful, all of the elements in such
equivalence class must be interchangeable from the perspective of the user. Sorry about that
background noise. It gets so annoyed by this because I live in a very quiet neighborhood,
but every time I record a bloody video, there's some noise outside. In any case,
so what he means by for an equals method to be useful, all of the elements in each
equals class must be interchangeable from the perspective of the user means again,
going back to the string, from the perspective of the user, both these objects have logical
equality and that's what necessitates equivalence relation. Saying that, let's get to the first
item or the the first property that pertains to the general contract. Oh gosh, man.
The noise is not ending. Is that a leaf blower or lawn mower? What the hell is it?
Okay, part and parcel of living in a suburb. Hey, look, I look, I'm not complaining though,
it's way better than the city. Ah, it ended. No, it didn't. I'm just gonna wait till it ends.
I think it ended. Back to it. So, reflexivity. Ah, he's starting. Dude, the guy's trolling me.
The guy's trolling me. You know what? I can't, I can't do this. We're just gonna keep going.
I apologize about the background noise. So, starting off with the first property, reflexes.
See, I got distracted. Reflexivity. Okay, what does that mean? What does reflexivity mean? I've
got to be really flexible here right now. So, that means for any non-null reference,
value x should equate to x. So, it's saying that an object x should be equal to itself,
which kind of seems self-evident. So, if we have a x equals x, it must return true.
Which is why, which is why Joshua Bloch states, the first requirement, say, is merely that an
object must be equal to itself. It's hard to imagine violating this one unintentionally.
If you were to violate it and then add an instance of your class to a collection,
the contains method might well say that the collection didn't contain the instance that
you just added. So, let's take a look at a quick demo, because obviously code makes more sense
than theory, even though we are, I personally always like starting with theory, because it
really helps to start high level. Where is this? So, if we go to reflexivity,
it's really simple as this. So, I have a list of strings here, and what we're doing is we're
adding the word Java into that list. So, it's a set, let's say, it's a string, and if you run this,
it'll return true, because we're just checking if this set, this list, contains, using the
contains method that's in the, using the, sorry, I bit my tongue, using the contains method in the
object class. It's checking if Java exists in that list, and obviously it does. That's pretty much
what reflexivity is. So, the next, if I have a hard word for me to pronounce. So, the next one is
symmetry. So, symmetry states, again, for any non-null reference values x and y, so we have
two objects in this case, x equals y must return true, if and only if y equals x returns true.
So, again, going back to, I'm going to demo it in a bit, but going back to this here,
s, s and b, so string s, so string s, if we take this,
equals b. This should return true only if b dot equals s returns true.
So, that's what symmetry is. And before we get to the demo, let's just read out this bit,
just should look at stated. The second requirement says that any two objects
must agree on whether they are equal. Unlike the first requirement, it's not hard to imagine
violating this one unintentionally. So, we have this class here called case and sensitive string,
and it's an attempt to implement a case and sensitive string class. In the class, what we have is we
have a private final string s variable. We have the constructor, which in this case just
checks if the object is non-null, if it is null, it returns a chosen error, and then it sets that
value in our private field here in the class. And then we have the equals method that we have
overridden, which breaks symmetry. So, firstly, I'll show the one, but the problem, I'll show
the wrong way to do it. And then we also have another equals method written
below here, which is the proper way to do it. And that'll fix the issue. So, let's take a look at
this equals method that we've overridden. So, we have two if conditions here in the equals method.
In the first one, what we're checking is if this object v pass is an instance of the case
in sensitive class. So, that's what we're checking here using the instance of method. And if it is,
then it'll just return true if that. So, firstly, we cast that object into case in sensitive string.
If it is an instance of that, let's say a subclass of that, then we cast it to become a
case in sensitive string. And then we compare it to our string field really that we defined here
in line number 15. And if it is equals in that case, we return true. And that's fine. That's
going to work. But then we're trying to go one step further and attempting to make this interoperable
with a string class. So, again, the same way we're checking if this past object is an instance of
the string class. And then we are saying return true if it's equal to a string. And we just cast
it accordingly. And this is what breaks the symmetry. And I'll show you what that means.
And of course, this line here, if it doesn't meet all these conditions, it'll return false.
So, in the public static void main, what I have is I have an instance of
case in sensitive string. And then I have another normal string instance. What we're doing initially
is we're checking if this case in sensitive string is equal to s. And that will return
true as expected because we're passing the word Polish here, the string Polish, and the string
itself has Polish. And even though the first letter is uppercase, and here it's not uppercase,
it's lowercase, it doesn't matter because this equality, what we're doing, the logical equality,
what we care about is for it to be case in sensitive. We don't care about the case.
But here, this is where the symmetry is violated. Because we are attempting in I equals method
for this to be interoperable with normal strings, we're doing the comparison the other way around
instead of comparing sys with s, we're comparing s with sys, and this returns false. Furthermore,
if we add this string, I don't want to call it a string because it's a case in sensitive string,
into a list of type case in sensitive string, it's a bit of a mouthful. And be printed, we
expect this to return true, but it doesn't, it returns false. So that again demonstrates the
violation of symmetry because the contains method uses the concept of logical equality,
and we don't have logical equality here. So if I do run this, you'll see it'll return true false
false. Right there. So this is the problem. Now, before I get to the fix, let me read out
to put it a bit more formally and cleanly what Joshua Bloch has stated. He states,
as expected, so he's referring to this bit here, as expected, sys dot equals s returns true.
The problem is that while the equals method in case in case in sensitive string
knows about ordinary strings, the equals method in string is oblivious to case in sensitive strings.
So that is the equals method that we're going to use here in this slide that we use.
Therefore s dot equals says returns false. So he's referring to that bit here now where it
returns false. A clear violation of symmetry, suppose you put a case in sensitive string into
a collection. So that's where moving on to the next bit here, which we again see that it's
returning false. And this is a bit difficult to understand because here's what Joshua Bloch
states on the contains method. Now, I was under the, well, I guess my assumption is right. My
assumption was that because this violates the equals contract and the idea of logical equality
and the contains method use ensures that objects that it gets respect this contract.
It acts accordingly. Therefore why it's printing false here or it's returning false here.
But here's what Joshua Bloch states. And I think my assumption is at least quasi accurate.
What does list dot contains s return at this point? And then he says, who knows? In the current
open JDK implementation, it happens to return false. So that's what we saw here. The third
false is by this list dot contains. But that's just an implementation artifact. In another
implementation, it could just as easily return true or throw a runtime exception.
Once you violated the equals contract, you simply don't know how other objects will behave
when confronted with your object. To eliminate the problem, merely remove the ill-conceived
attempt to interoperate with string from the equals method. I shouldn't have read that part yet.
I'll read that again, but that's how we fix the problem. So I'm going to read that bit again,
though. Once you violated the equals contract, you simply don't know how other objects will behave
when confronted with your object. This goes back to the idea I touched on a bit before by
Sandy Metz on the book I was referring to, the Ruby book, that it's probably the best way to
think about OOP is in the context of messages and how objects interact with each other over
objects because objects aren't an island as we read from John Dunn. So that's what happens here.
The contains method makes a lot of assumptions and those assumptions are wrong because, well,
the assumptions aren't really wrong, but we've made a mistake in our object.
Therefore, it breaks things. There's no logical equality. Now, getting back to how we fix this,
as I did read that line, which I shall reread, it's simply ensuring that we don't
try and attempt for the case in sensitive string objects to interoperate with string objects.
And the way we do that is, I'm going to comment out this equals method because we can't have
two equals method in the same class equals methods in the same class, unless it's overloaded.
And then I'm going to get the other equals method, which doesn't attempt to override.
Oops.
Doesn't attempt to not override to interoperate with strings. It simply checks if it's an
instance of case in sensitive string and then casts the case in sensitive string and just
the normal equals ignoring the case. So now, if I run this bit here,
you'll see I'm going to comment out these lines because they're, in fact, actually, no, maybe
what I should do is I'm going to go and run the whole thing. And now the first three are printing
faults and we expect it to print faults. We want it to because we don't want any interoperability
with strings. And then in the second one, we're checking if it's equals and we're seeing if sys
equals this new string we've created, again, Polish. And then we're checking if sys equals
the other way around. We're checking for the symmetry. So you can see here in line number 53,
it's uppercase p. And in line number, oh, that's a mistake, actually. That should have been lower case.
Now, we can truly demonstrate the point. So if it's lower case here, line number 37,
it's still ignoring that and printing true in these two lines. So line number 54, 55,
correlate to these second true statements. I hope that made sense. So rereading what
Joshua Bloch wrote, to eliminate the problem, merely remove the ill-conceived attempt to
interoperate with string from the equals method. And now we move to the longest property from
all the ones that Joshua Bloch has enumerated. And I had to take a smaller break just to
refresh myself because this property is four or five pages. So there's a bit to go through.
But let's get started. You know, the only way to get started is to get started. Wow, brilliant,
brilliant. So what does this transitivity property states? Some of these words are a bit
hard to pronounce. It's not going to lie. It states transitivity states, for any non-null reference,
values x, y and z, if x equals y returns true and y equals z returns true, then x equals z
must also return true. Or simply it's that if we have three objects with the content being
same, three string objects, let's say, they should all print true when compared to each other.
Simple as that because we require the logical equality there. Now, before we get to the demos
and we demonstrate how this can go wrong and how to fix it, and even in fact some inherent
flaws with Java and object-oriented programming, we got to get some theory out of the way.
So should I read this out first? Let me think. Okay, I'll first read out a bit of like an
introduction to this property from the book. Here's what Joshua Block states.
Transportation pertaining to transitivity. If one object is equal to a second and the
second object is equal to a third, then the first object must be equal to the third as we
showed here. But as I said before we continue, let's get some theory out of the way. So
something important to understand for this property is the Liskov substitution principle.
The Liskov substitution principle is probably popularized by Robert C. Martin and his solid
design principles. And of course, Barbara Liskov. Is that her name? I believe that's her name.
Barbara Liskov. Yes, she is the scientist who invented this principle and made the contribution
into the field of computer science. Here's how Robert C. Martin summarizes the Liskov
substitution principle. Subtypes must be substitutable for their base types. And of course,
I've got an example here that I use strategy PD to generate, to demo this principle simply. And then
a bit more formally, let's say a bit more mathematical definition, Barbara Liskov defines
it like this, which she did in 1988. If for each object O1 of type S, there's an object O2 of type
T such that for all programs P defined in terms of T, the behavior of P is such of P is unchanged
when O1 is substituted for O2, then S is a subtype of T. So another way of putting it is that if S
is a subtype of T, then the behavior of O1 can be substituted for the behavior of O2, which are two
objects. An example of that would be, again, generated by strategy PD. Thank you. Open AI
and strategy PD, not to anthropomorphize it, but nevertheless, thank you. We have a class animal
with a public void move method, and then we have a subclass. We subclass the animal class by dog,
dog extends animal. And then we define a method that makes the animal move. So the subclass has
a method called make animal move, which takes a object of type animal of the, that's not the sub,
that's a subtype, not the, sorry, that's the supertype. And then this method, in fact, this
method should be inside the, that was, I made it, it's not my fault, it's strategy PD's fault.
If we put it in there, so it probably exists inside the dog class, and we create a new dog object,
and then this method make animal move can take in an animal typed object too, because it respects
the list called substitution principle or it owed to, because dog is a subtype of the supertype
animal. It's quite straightforward, actually. And I think the best way to think about it is how
Robert C. Martin put said subtypes must be substitutable for their base types. So now let's
get to the demo that Joshua Block has used in the book. There are many classes to go through,
but let's start off with the point class. So here's what Joshua Block states. Consider the case
of a subclass that adds a new value component to its superclass. In other words, the subclass
adds a piece of information that affects the equals comparison. What we have here is this
public class. This class is going to be the superclass that we're going to use. It's a concrete
class. Keep that in mind, because the idea or the juxtaposition of a concrete class with a
abstract class, that's something we're going to catch on later on in this part. So we have the
concrete class point, which is simply an immutable two dimensional integer point class. We've got x
and y privately defined, we have constructor, and then you have an equals method, which just the
equality. Similar to what we discussed in the previous example with symmetry, checks if it's
an instance, and then returns true if there's equality. Now let's suppose that we want to
enhance the ability of the point class. Therefore, we subclass it and we have this color point class
that extends the point class, and it attempts to add a value component to point. In this case, it's
the value component of color. We want the points to also have color. Now what would
this class look like? Or more importantly, what would the equals method look like for the color
point class? That is a subclass of point. In this case, we have a normal constructor. We have line
number 14 that invokes the constructor in the superclass. That's what this super keyword does,
and we can do that for x and y, those coordinates. But here, since we're introducing this value
component, we want to initialize the color component to when constructing the object.
But then we come to the equals method that clearly violates the symmetry of the
symmetry principle or the symmetry properties. Well, for starters, of course, we can't use the
equals method from the superclass because the superclass did not even have a color field.
Therefore, it would break the idea of logical equality if we just inherit that method. Therefore,
we need to override the equals method in the subclass color point. But in this equals method,
it violates symmetry because, yes, we're invoking the equals method in the superclass,
and then we're even doing a check for the color point equality here by casting
that object the color point type. Because if it is an instance, in that case,
oh, yes, because if it's not an instance, it'll return false. But it's a one-way comparison. So
if you look at the implementation or a client using it, and if I run this, you'll see the
first comparison will return true because that's fine. We're comparing point and we're passing
the color point object, that's okay. But the second one will return false because in this case,
we are typing or we are passing the supertype object. So it's a clear violation of symmetry.
And that's why Joshua Bloch states, the problem with this method and what he means by this method
is this implementation of the overrides method we have here is that you might get
different results when comparing a point to a color point and vice versa.
The former comparison ignores color while the latter comparison always returns false
because the type of the argument is incorrect. So what he means by the former comparison ignores
color is that in this ampersand, the end statement here, that's the former comparison
where it's simply invoking the equals method in the superclass and it's doing a basic equality test.
But in that equality test, we are ignoring color completely. So it'll return true if it is an object
of proper type. And that, again, doesn't give us what we want. It breaks logical equality.
And in the second one, the problem is it'll never even get to the second one because we check if
this object is an instance of color point. And if it's not, it'll always return false.
Therefore, whenever we pass anything that's not of type color point, it'll return false.
And that also violates not only symmetry, but even the less substitution principle.
So then we're trying to fix this. What we're trying to fix this is we're trying to
resolve this issue with violating symmetry. And that fix also unfortunately doesn't work
because it violates the transitivity property and we shall see what that fix looks like.
So by trying to fix the issue with symmetry, we unfortunately violate transitivity.
In this case, in this new equals method that we overrode, we in fact are considering objects that
are of a different type to color point. We're checking if initially if it's a normal point,
if it's a normal point, we're doing a color blind comparison. Great. And if it's a color
point, then like the previous one, we consider color and then do a comparison. And
absolutely if it's not an instance of either point or color point, it'll just return false.
So in this case, symmetry ticked. However, unfortunately, as we shall see from the
implementation, it does violate transitivity. So in this comparison, we have three objects.
We have two color point objects and a point object. So in the P1 equals P2 comparison,
that's fine. It returns true. Also in the P2 equals P3 comparison, that also returns true.
However, then comes the transitivity issue in the P1 equals P3 comparison, it returns false.
I totally got the wrong. I read that as if that's what was expected. In fact,
that was not what's expected because there's no logical equality there. We're trying to compare
P1 with P2 and it's returning true. It should return false because obviously P1 has that added
value component of color and P2 doesn't have that. So that's wrong. It shouldn't return true.
And it shouldn't in the second comparison, where we compare again, a point and a color point,
it's returning true again, it shouldn't. And okay, the third one's fine because the third one,
it's doing a proper comparison between P1 and P3, which are both type of color point.
And it's returning false, which is expected because the color is different. That's okay,
but these two are a problem. So which is why Joshua Bloch states,
this approach just provides symmetry, but at the expense. So I don't think I read the previous bit.
So just to add on to what he was saying about the override method, he says, this method here,
he says, you might try to fix the problem by having color point or equals ignore color
when doing mixed comparisons. And that's what we're doing in this condition here,
where we're doing a color blind comparison by using the instance of method. So even a point
can be passed on to this object of type point. And then he continues, now, so what we discussed
here before, now P1 equals P2 when P2 equals P3 returns true, where it shouldn't, while P1 equals
P3 returns false, a clear violation of transitivity. The first two comparisons are color blind,
while the third takes color into account, and that shouldn't be the case. So what do we do here?
We've got this huge object oriented predicament, or for us programmers, even a existential crisis,
what are we going to do? What's the solution? He says, it turns out that this is a fundamental
problem of equivalence relations in object oriented languages. This is kind of what I said before.
There's no way to extend an insensiable, insensiable class and add a value component
while preserving the equals contract. The problem again, the big problem is in our design, where
we may point a concrete class. And we shall see why it should have been made a abstract class instead.
But later, sorry, I'm getting a bit carried away. Let's stay on track. Again, re-reading that point
because it's important. There's no way to extend an insensiable class, insensiable class and add
a value component while preserving the equals contract, unless you're willing to forego the
benefits of object oriented abstraction. And then Joshua Block states that we might try to circumvent
this issue in a bit of a sly way by trying to use Java's reflexive API or reflections API. In any
case, it's changing the class on runtime, which is what I tried to demonstrate with the second
equals method, which we think would work. So if I do, whoops, I shouldn't have clicked that.
If I do look at this equals method, I'll comment this out.
We're using the dot get class method from the Reflections API. Okay, before we get to that,
let me quickly read out some theory. What is get class in Java? Again, according to chat GPT,
here's what get class is. In Java, the get class method is a method of the object class that
returns the runtime class of an object. Correct. It returns an object of type class, which is a
class in the Java reflection API that represents a class or interface in the Java programming
language. This in fact is very accurate, which is amazing because if you look at the Oracle docs
and whatnot, chat GPT puts it in a more simpler way to understand. An example would be here,
if we have this employee class or the employee object of type employee, if we go and they have
another class, which we get, we get the class of employee and save it. We don't even really have
to do this. We could just go employee dot get class really. We could just skip this step and go
employee dot get class dot get name. And then return the name of the class. And that's done runtime
by getting the type of the object. So we're trying to circumvent this issue by using the Reflections
API, where we're saying only if it's a type of the implementation of that object. So we're checking
the class of the object we pass on to the equals method, and then we're checking the class of the
current object's runtime. So we're comparing two objects here, the object of this class,
the broader class, and then the object we are passing on to the equals method,
and then we're doing the comparison. Unfortunately, this is not going to work,
because it violates the less-carved substitution principle and breaks logical equality, which is
why Joshua Block states, this effect has the effect of equating objects only if they have
the same implementation class. So which is why we're checking here for the type of the implementation
class. This may not seem so bad, but the consequences are unacceptable. An instance of a subclass
of point is still a point. So an instance of point, for example, like call point is still a point,
and it should work with this equals method, but it doesn't. And it still needs to function as one,
but it fails to do so if you take this approach. Now let's take a look at an example where we're
trying to tell whether a point is on the unit circle. Here's an example. So what this counterpoint
test is trying to do is to see if this is a point. This point class is a point on a unit circle.
We're creating a set of type point, and we're adding some points into it. And then we have this
public static Boolean, which returns a true false, that checks if this point is a point on a circle.
And we're doing that by returning true if whatever point that we pass on to this method
is contained in this set, the unit circle set. Initially here, it'll print true. It'll print
true because it's of type point. But because our point class, we use the reflections API and used
get class. When we pass something, a subtype of kind of point, which again, if it did respect
or follow the less curve substitution principle, it should still print true because it's still
a type of point and it should behave as such. It'll print false, unfortunately. There we go.
In the second one, it's printing false. And this is a clear violation of the principle.
Therefore, using get class and the reflections API is still not the way to circumvent this issue
with object oriented languages. So again, I know we discussed the less curve
substitution principle before, but in the book Joshua Block states the less curve
substitution principle says that any important property of a type should also hold for all its
subtypes so that any method written for the type should work equally well on its subtypes.
And this is the formal statement of our earlier claim that a subclass of point, such as counterpoint,
is still a point and must act as one. Now let's take a look at the problem with this. I mean,
let's take a look at not the problem with the less curve substitution principle, but the problem
with not following this principle. So we have this trivial class here that really does nothing.
It doesn't really add a value component. It simply keeps track of how many instances of,
of, it's called counterpoint, which keeps track of how many instances of point are created. If you
don't know an atomic integer is a thread safe counter, a variable which you can increase.
So simply every time an instance of counterpoint is created, we also we're invoking even the
the super class, the point in this case, and then we can get account of how many instances of
point were created because of this atomic counter. So again, counterpoint is a subtype of point.
Apologies, I demoed this bit a bit earlier before, and I think I used the word color
point by mistake. I think I should have said counterpoint. It's just both counterpoint and
color point are subtypes of point. But as you saw before, it also returned faults,
because we've got a problem with, we haven't got a problem with, sorry, I was going to say we've
got a problem with the, with the contains method. The contains method exactly behaves the way it's
supposed to, but we have a, we have a violation of the less curve substitution principle, which
is why it's training faults. Again, I apologize if I confused you by stating color point, I meant
to say counterpoint, which is this class that this is a, this is a useless class really. It just
invokes the constructor in the superclass point and then keeps track of how many
objects of point have been created. But why, so the question of course is why do we get this
second false here, despite counterpoint being a subtype of point, it is because of this.
Because most collections, so set is a collection here of type point, including the hash set that
we used here by the own unit circle method, use the equals method to test for containment.
And no kind of point instance is equal, equal to any point. And why is that? That is because,
as I said before, we're using get class here. And if, if counterpoint is not of type point,
we aren't gonna, it's going to return faults. So therefore, that's why we get a false here too,
which the, sorry, it's a wrong one. We get a false here too, which the contains method uses the
equals method in the object, in the point object. And that's why Joshua Bloch states, if however,
you use a proper instance of base equals method on point, the same onion cycles circle method
works fine when presented with a counterpoint instance. And let's take a look at that.
So on point, instead of using this equals method that uses get class, if we go back to the previous
one that uses instance of, because instance of does consider even subtypes. And if we run this
again, we'll get two truths. So in that case, it's behaving as expected. So unfortunately,
there's no way getting around this, we should all give up programming. And just quit quit because
life is meaningless. Everything is futile. I'm kidding. I'm kidding. I'm kidding. Life is meaningless
and everything is futile. But in true Nietzschean essence, we ought to create our own meaning,
which is why we're going to use the good old object oriented principle and favor
composition over inheritance to circumvent this issue with which is inherent to object
oriented languages. So let's take a look at this example, a class color point where we don't do
any kind of extension or any kind of inheritance, we're in fact using composition. So in this new
color point, which don't get this confused to the one that we use for inheritance, as you can see
from the package, this is in a separate package called composition. But in this new color point that
uses composition, we have a instance of point defined. And we have an instance of color, which
this is a enum, by the way, that holds some some colors. And we have these two instances defined.
And then in our constructor, we have a new instance of point being created. And we assign that,
of course, to the private private field in our class, we do the same thing with color,
new instance. Sorry, in this case, we don't create a new instance of color, we expect the client to
pass us a proper object of type color. And then we return the point of this color point, just
this again, what the client expects. And then the equals method, because we is in composition,
it's not an issue, we just check if it's an instance of color point. And then we do the
casting accordingly, if it is an instance of color point, the object we pass onto the equals method,
then we do a proper comparison, where we do both the comparison between
between the type point of color point, because this we get from
here. And also a comparison between color. So the color has to be true, and the point has to be
true. And if they both are fulfilled by the double ampersand and operator, it returns true.
And that solves a problem. So if you look at this test class, for instance, I'm going to run this
test class, I've done something really ugly here. In one file, I've defined two classes,
you should never do that. In fact, there's one item where Joshua Block talks about that later on.
It's bad programming etiquette. So in the counterpoint test, again, I've screwed this up,
it should be color point test. This is a bit confusing, I apologize. In the color point test,
we've similarly have a hash set that we've created of type point. And then we're doing
the same thing we did in the previous test, we're checking if the point we pass contains
this object P in this hash set. And then if you run this, the difference here though is firstly,
if I run this, you'll see they both print true. That's because we're using composition.
And what it does is though, when we are adding it, when we're adding a new color point, we do use
this additional method saying add this, however, as a point though. So that changes things because
now we're saying it's still, we're still adding something of type color point, but we're using
this method here, which adds as a point. And it returns that point that we've defined here,
which is what we do in the constructor. And even though we still have this value color
in this private field here, which we can use. So that's how we circumvent the issue.
Interestingly, Joshua Bloch states that there has been historical errors where, for instance,
in the date and the SQL timestamp classes, so in the utilities and the SQL packages,
they've made the mistake of use having implementations of the equals method
that violate symmetry and that this causes erratic behavior. And he says the equals
implementation for timestamp does violate symmetry and can cause erratic behavior if
timestamp and date objects are used in the same collection or otherwise intermixed.
This behavior of the timestamp class was a mistake and should not be emulated. So again,
it's because of the inherent drawback in object oriented languages, these kind of mistakes happen.
However, in many circumstances, using composition over inheritance, the way we
showed in the composition-paste color point class is a way of getting around that.
And then we get to the interesting idea or the interesting notion of using an abstract class
instead of a superclass. And simply, the reason we can add value components to a subclass of an
abstract class is that you can't instantiate an abstract class. So that really solves a lot of
the problems we have with using the concrete point superclass. So in this case, we have an
abstract class shape, which has two protected values, so x and y, and we have a constructor,
and then we have two concrete subclasses that extend the shape class. And we've got circle and
rectangle, where's the other one? Yeah, circle and rectangle, where in the circle one, we are
adding a radius, and in the rectangle one, we are adding length and width. And in the constructor,
of course, we are invoking the constructor of the superclass, which is shape. The issue is
quite straightforward. We can create a concrete object of this concrete class rectangle. However,
if you try to, that's a typo, try to instantiate the shape class, it says you get a compile time
error, say you can't instantiate abstract shape classes, which is why this is a way to get around
this issue, where Joshua Bloch states, when adding a value component, note that you can add a value
component to a subclass of an abstract class without violating the equals contract. This is
important for this sort of class hierarchies that you get by following the advice in item 23,
preferred class hierarchies to tack classes. I'm not going to go into too much detail on that,
because we're going to be covering item 23 next year. And then he says, for example,
he could have an abstract class, so what I pretty much described here, I'll just read it out again.
For example, he could have an abstract class shape with no value components, a subclass circle,
that adds a radius field and a subclass rectangle that adds a length and width fields.
Problem of the sort shown earlier won't occur so long as it is impossible to create a super
class instance directly. That's it. That is the property of transitivity as to how we try and
follow it to ensure that we follow the, or we abide by the general contract of the equals method,
and even discussing the inherent problems with OP languages. But saying that, there are also two
other properties that we need to follow, which is consistency and non-nullity. There are a lot
more shorter than this one, but I'm quite tired. So we're going to cover that in part three.
But I hope this made sense. I was from my best to get this across. I found this quite interesting,
though. I really enjoyed this transitivity bit. So I shall see you in the next one.
Thanks for watching, and I hope you gain some value from it. Cheers.
