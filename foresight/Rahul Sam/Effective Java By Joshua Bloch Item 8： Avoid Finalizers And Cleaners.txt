Hey everyone, welcome to yet another episode of my video series on Joshua Block's Effective Java,
where I take the items that he has enumerated in this book and expound on them, trying to make
sense of them. And hopefully, as I do that, you can gain some value from it too. You can
hopefully learn something from it. That at least is one reason that I put out these videos
out in the public. Without further ado, let me get started. This is certainly one of the longest
items that I had to go through and probably going to be the longest video of this series as of yet.
In fact, I was thinking if I should break this down into two videos because the video might be
too long. In any case, let's get started with the proviso. I've been doing this proviso slash
instruction in every single video. So if you have been following along, please do skip this bit to
save your time. The first point in the proviso is of course, and it's a very important point,
this is not a tutorial. I'm not a teacher, nor am I an expert. Therefore, don't think of what I say
as gospel's truth. In fact, when I do make mistakes, I'll try and correct them down
during the comment section. And as I've said in the second point, think of this as the blind,
leading the blind. This is purely an exploratory disposition. I'm trying to figure something
out publicly and in a very, let's say, what's what I'm looking for. I'd say thinking out loud,
trying to make sense of these items, not just in the videos itself, but even preparing for them
as I post questions on Stack Overflow, as I try to involve the community. I feel like hopefully,
you know, I'm adding some value into the programming community, the Java community,
by asking certain questions pertaining to this book, as I'm trying to learn, which is why I call
it an exploratory disposition. It's a collective endeavor. And as I did touch on a bit before,
I will inevitably make mistakes. So please point them out, not just for my sake, perhaps even more
for the sake of the viewers, because I certainly don't want to mislead them by sharing any misinformation
to use a politically overloaded term. And of course, as this is a programming video series,
all the code is available on GitHub, not just mine, but even Joshua Bloch's public repository
where he's published the code that he's used for this book. Saying all that, let us get started
with item number eight, which, as I said, is a long one. There are a few concepts that I had to
sort of think about and muse and reflect for a bit to get my head around. But it was a very
interesting item as I found all the items in this book. And especially if you're a Java fan, like
myself, for all, even though I don't program in Java in my day job anymore, Java is my first love
venue. Never forget your first one, isn't it? I'm sorry, that was pathetic, but I can't help myself.
Okay, item number eight, avoid finalizers and cleaners. And we're still in chapter two,
creating and destroying objects. And again, as I said, all the code available on my GitHub repo,
links down below in the description. And I've kind of added like this, another caveat here.
This item does have a lot of theory. So before we get into the code, which of course I have
right here, before we get into any of this code, I think it's important to get through some theory.
Just in general, I prefer doing that to get a conceptual understanding. But specifically this
item, I think has a lot more theory. So as I normally do, let's look at some keywords here.
Avoid finalizers and cleaners. What the hell are finalizers and cleaners? Full disclosure,
I've never used a finalizer nor a cleaner. A cleaner, yes, but I've never used a finalizer
in my day job when I used to do a lot more hands-on Java programming. But here are a few
definitions that I found on finalizers. In fact, they're from Baildang, my favorite Java
learning blog slash website. And then of course, the Oracle docs. So finalizers, the,
sorry, I had to think about that just for a bit. I didn't want to mindlessly read out the definition.
Essentially, I mean, finalizers is simply a method we're talking about, which is in the
object class, which the, in the class hierarchy in Java, the object class is right at the top. So
everything is a subclass of object Java, FII. The finalize method for all intents and purposes
is what we call the finalizer. Even though finalizers is more like a mechanism. And Baildang states
finalizers get involved when JVM figures out that this particular instance should be garbage collected.
So when the JVM understands that a certain object or an instance of a class is ready to be
garbage collected, it can be involved, this finalized method. Such a finalizer may perform
any operations, including bringing the object back to life. That bit, full disclosure, I don't
understand. I didn't really go into detail as to what it means bringing the object back to life.
Perhaps it's referring to the object later again in the code and then, you know,
allocating memory to it. But even in the item, Joshua Block hasn't really got into what that
means. This is just a definition from Baildang. The main purpose of a finalizer is, however,
to release resources used by objects before they're removed from memory. A finalizer can work as a
primary mechanism for cleanup operations or as a safety net when other methods fail.
So at a very high level, just a good bit of start is to think of finalizers being related to
memory management and garbage collection. It's not something particularly done by the JVM.
Programmers could do it too, explicitly. But of course, a caveat is we should in fact avoid
using finalizers and cleaners. That is the caveat here. So even though it's possible,
doesn't mean we should do it. So again, to repeat the point, think of finalizers as something that
relates to memory management and garbage collection and ensuring that any unreferenced
objects are cleaned and that resources are freed up. And then another definition again from the
Oracle docs this time is, as I said, finalize is part of the object class. If you go take a look
at the docs, it'll even state, if only my internet loads, it'll even state the finalize method is
there. As you can see there, it'll say they're called by the garbage collector on an object
when garbage collection determines that there are no more references to the object.
The general contract of finalize is that it is invoked if and when the Java virtual machine
has determined that there's no longer any means by which this object can be accessed by any thread
that has not yet died, except as a result of an action taken by the finalization of some other
object or class which is ready to be finalized. So, okay, effectively this means when the object is
not going to be used, we need to free up that resource and get that memory back to be used
for something else. That's what finalize is. But, again, we shouldn't use them. That's the point
Joshua Book is trying to make. Okay, so the first keyword finalize is we've got a very high level
conceptual understanding of what it is. Let's take a look at what cleaners are, which is kind of like
an evolution of finalizers and is perhaps a bit safer to use, even though that too should try and
be avoided ideally. Once again from the, so cleaner is in fact, let me open it up. It's an interface.
Sorry. Sorry, I meant to say cleaner is a subclass of object. I was thinking of auto-closable,
which is an interface. We'll talk about that later on. And the definitions for the cleaner is,
again, by the Oracle docs. Cleaner manages a set of object references and corresponding cleaning
actions. Cleaning actions are registered to run after the cleaner is notified that the object has
become phantom reachable. So what is phantom reachable? I did discuss this in the previous
item, item number seven. I'm not going to go into too much detail, because you could just
watch that video. But phantom reachable is when an object has no strong soft or weak references,
but at least one phantom reference. So this kind of has to do with how the JVM algorithms,
or how garbage collection algorithms, decide if a certain object has to be, or can be garbage
collected. So basically, strong objects can never be garbage collected. And then it's sort of the,
there's like a cascading effect, not a cascading effect, there's like a triaging process where
it goes from strong, soft, weak, and then the lowest one is a phantom reference.
Read this document by Bialdown, which goes into detail, of course, linked to this in the
description too, for more context. I'm not going to go into detail because it's sort of out of
scope for this item. And as I've said here, these delineate when objects can be garbage
collected. That's what phantom references do. And with cleaners, cleaners are used when an object
has become phantom reachable. That's how it relates. And then another definition from
inside Java by Roger Riggs is, unlike a finalizer, a cleanup function holds the state needed for
cleanup separately from the object because we want the object to be reclaimed as soon as it is
unreachable. When it states, when it states reclaiming an object, what that really means is
freeing up memory. So we can use it for something else. The cleanup function must be able to work
independently from the object. It's correct. It should be able to run on a separate thread for
instance. And that does happen. We shall see an example. If there are any references to the object
from the cleanup function, it would still be reachable and could not be reclaimed.
Any state needed for the cleanup must be encapsulated in the cleanup function.
What does that mean? I believe what this means is, when the cleanup does take place, so a quick
peek in the code, let's say the cleanup happens. Let's say this close method. This is a bit different.
Ignore all this. But the state of an object should be local to the state of an object.
When the cleanup is taking place. I believe that's what it means. It's encapsulated within this
method. Ignore all this, but it's a really sub-art context, but we shall get this code a bit later.
Okay, now we get to the items, what Joshua Block has stated in the item in the book. And the first
thing is, the first thing we need to do is, we need to take a look at the state of an object.
And the first thing is, he's kind of talking to C++ programmers.
And a point he wants to make salient and very clear is that finalizers or cleaners are not
the same as destructors in C++. Now, obviously, because C++, I'm not a C++ programmer in any way,
I've probably written like 10 lines of C++ code in my life, probably a bit more than that.
I did do a unit, a data structure and a patterns unit back in uni, which was a, which was in C++.
And obviously, so because C++ doesn't have automatic memory management or garbage cleaning,
we need to do it ourselves, the programmer. So I believe it's done through destructors.
Take what I say with a great assault. Maybe they'd rather us do it. But one way it is done in C++,
probably the most popular way is using destructors and Joshua Block and once we make it clear
that cleaners and finalizers are not the same as destructors. And here's what he states.
Finalizers are unpredictable, often dangerous and generally unnecessary. I shall also discuss
that bit about them being unpredictable or non-deterministic as to why that's a huge
risk when programming as we go into the item. And then he states, as of Java 9,
this is an important point, finalizers have been deprecated, but they are still being used by the
Java libraries. The Java 9 replacement for finalizers is cleaners. Cleaners are less dangerous
than finalizers, but still unpredictable, slow and generally unnecessary. So this, which is why
we should be avoiding avoiding old finalizers and cleaners. So despite having the caveat that
finalizers and cleaners aren't the same as destructors, he states, or he continues,
C++ destructors are also used to reclaim other non-memory resources. In Java,
a try with resources or try finally block is used for this purpose. And then he continues,
one shortcoming of finalizers and cleaners is that there's no guarantee they'll be executed
promptly. Yes, before I read that, I need to go through the notes that I took down.
So I had to go through the code base a bit and read up again, because I wrote this a while back
and I've forgotten some bits as to how it's all going to come together. In fact,
by my struggle to demo this, to demonstrate this problem, is in many ways the point
Joshua Block is trying to make that it is non-deterministic. I can't exactly show the problem
with finalizers because due to it's, it's not deterministic. And in programming, you'd expect
code to be deterministic and causal. The big problem with using cleaners and finalizers is
firstly that we aren't sure when the garbage collection will take place. We don't, we aren't
sure when the, when GC will run and JVM can do it, which will be anytime it wants. Even though
it is possible, as I will show in a bit, for us to explicitly run a GC or a garbage collection
cycle, it is not, it's ill-advised. One shouldn't, one shouldn't do this. There are many other side
effects that can affect the program. And it's possible that the finalizer thread, so the thread
where the closing of the objects taking place can be of low priority that can lead to an
out-of-memory error. Because some other threads would run, take up all the memory and when this
thread runs, that can throw an out-of-memory error. Even, and then there's again another caveat that
cleaners in fact do run in the background. And the garbage collection is controlled by the class
itself. The class owns that garbage collection. However, there still is a problem of it not
being, of it not running promptly. Sorry, I made a mistake there. The garbage collection doesn't
have, sorry, the class doesn't have control of the garbage collection, but it has control of its
own threads, which we shall see because we use a runnable interface. And nevertheless, it still
does not guarantee the promptness. And due to the non-determinism in both cleaners and finalizers.
Now I'll quickly show what the hell finalizer even is, because there isn't really a proper example
given in the book. I found an example courtesy of Byle Dunn. But before I show the code base,
let's go through some something a bit more, let's say, clear. And I try to be a bit more
explicit as to what Joshua Block has written here, because I think I didn't do a good job at
explaining that. Here's what he states. One shortcoming of finalizers and cleaners is that
there is no guarantee they'll be executed promptly. It can take arbitrarily a little
between the time that an object becomes unreachable and the time its finalizers or cleaners run.
This means that you should never do anything time critical in a finalizer or cleaner.
The promptness with which finalizes and cleaners executed is primarily a function of the garbage
collection algorithm, which varies widely across implementations.
So what does that mean? The thing is, even after the finalizer runs, a GC still has to run in the
background, clear up resources, clear up memory. But before we get to the idea of the promptness,
let's take a look at what the hell a finalizer even is. So I was going through this example,
as I said, courtesy of Violet Dung, and let me try to open up that
article if I could find it. This one right here.
It was this article that he wrote, and he's just given a background as to what finalizers are.
Even though in the article S it goes, it does say why you shouldn't use it. It talks about
why we should take care of garbage collection, because JVM knows better, in fact.
And I have this class called Finalizable, and I have an instance, a buffered read instance.
And then the constructor, what I'm doing is reading a file, getting an input stream, and then
saving a new buffered read instance in this private variable of declared,
class variable of declared here. And it does specify from the specified class part,
from some nature quotes. And here we have a method called ReadFirstLine, which reads from the first
line. So if this works as expected, it should read without music, life would be a mistake
by Mr. Nietzsche, and I very much agree. And then once we have this instance created, we need to
clean it. We need to finalize it. And here's where, sorry, we need to close it, apologies.
And here's where the problem occurs. Now, once we have this reader, the buffered instance reader,
which we declared here, it's used, we do the reading, whatever, and then it's used,
and then we're done with it. We need to use a finalized method, which, as you can see,
is deprecated. The IntelliJ does specify that, that is deprecated.
It needs to be closed, which implies that the method was called, and it has to clean up the
resource. So in this finalize method, it'll close the resource. And now when I run the unit test,
you will say it'll say closed buffered reader in the finalizer. If not, it'll just throw an error.
If I go to the unit test that I wrote,
and if I run this, you can see it's printing that line here. I could probably zoom into that
a little bit. Closed buffer reader in the finalizer. Really, that's what a finalizer does,
even though we shouldn't use it. And yeah, over here, you can go through the code later on.
I'm just checking if it's printing the first line. That's not pertinent to the point I'm trying to
make. And then this is important, though, because the GC is rather arbitrary. Well, it's not arbitrary,
but we don't have really control of when garbage collection will take place. The JVM does that.
We're using a system.gc, but it shouldn't be invoked this explicitly. This is not something we should
do, again, due to its non-deterministic behavior. So you probably can see it's like a theme that's
going to be in this whole item. The big problem with cleaners and finalizers is non-determinism,
and it's the fact that it's tardy. It's tardiness that's not prompt, which is why Joshua Block states,
as we continue, tardy finalization is not just a theoretical problem. Providing a finalizer
for a class can arbitrarily delay reclamation of its instances. And that's a problem.
The language specification makes no guarantees, sorry, I'll read that again.
The language specification makes no guarantees as to which thread will execute finalizers as there is
no portable way to prevent this sort of problem other than to refrain from using finalizers.
And then, of course, as I stated, unlike finalizers, we still can use cleaners. Cleaners
aren't deprecated yet. And they would give us control of the thread, of the class that's using it.
But still, ultimately, the garbage collection, we still have no control. The JVM has control,
which is probably why we should avoid using cleaners too. As he states here, as a consequence,
you should never depend on a finalizer or cleaner to update persistence state. That's correct if
it's like a database connection or something that requires persistence. For example, depending on
a finalizer or cleaner to release a persistent lock on a shared resource such as a database is a
good way to bring your entire distributed system to a grinding halt. Oh, that is something you
certainly don't need. Programming is easy. It's really easy. It only gets complicated once it
becomes distributed programming and when concurrency gets involved. And that's why I have a beautiful
gift of my favorite actress, Margaret Robbie, probably the most beautiful woman in the world,
after a certain other woman that I'm currently in love with. But we shall not talk about that.
Don't be seduced. That's the point I'm trying to make. Do not be seduced by Margaret Robbie,
nor be seduced by the methods system.gc or system.run finalization. So, which is why,
just to go back to the unit as before, I said it here, one shouldn't do this. This is a bad move.
This, try and prevent, try and, yeah, try and prevent using system.gc in your code,
again, due to its non-determinism, because both of these, the garbage collection and
what runs the finalization method makes no guarantee that they'll actually get executed.
And in fact, these two methods run finalize their own exit, which are two other methods
that can be, that pertains to finalizes have been deprecated because they aren't safe.
Another red flag, especially if you're an API designer and aren't all programmers
designing APIs these days, is that finalizes ignore uncaught exceptions and doesn't notify the client
what the hell is going on if you do use a finalizer and there's a corrupt object. So, for instance,
let's say we have an object in corrupt state due to the non-deterministic arbitrary behavior of
a finalizer. Let's say we have an object that isn't fully cleaned up or an object that shouldn't be
accessed by another thread. When the object crashes, this thread will not be terminated by a finalizer,
whereas a JVM would certainly do that. It would make sure that if a thread crashes,
if some competition goes wrong somewhere and some error is thrown, it's physically clear and explicit
to a user of an API and it would be terminated and cleaned up.
This is a problem because if you do use finalizer, it'll allow objects in a corrupt state to be
accessed by a client of an API, which is why, again, he states, another problem with finalizes is that
an uncaught exception thrown during finalization is ignored and finalization of that object terminates.
Uncaught exceptions can leave other objects in a corrupt state,
but when an object is left in a corrupt state and an exception is thrown,
generally you'd see that exception in the stack trace. With finalizers, there wouldn't be that and,
in fact, he says it won't even print a warning. But, however, with cleaners, it's on an issue because
with cleaners, the library or a class for all intents and purposes using a cleaner has control
of its thread, so the class itself can throw this exception. So it's a bit safer than using finalizers
even though the item as a whole states avoid both. The other issue is performance penalty.
Finalizers inhibit efficient garbage collection because we are trying to manoeuvre do the
garbage collection instead of letting the JVM do it. And even though cleaners are still faster
than finalizers, it's still slower than using the auto-closable interface, which we shall get to
in the item, later on in the item. So the other problem is, of course, yes, performance penalty,
and that's why Dr. Block states there's severe performance penalty for using finalizers and
cleaners. It is about 50 times slower to create and destroy objects with finalizers. This is
primarily because finalizers inhibit efficient garbage collection. And then we get to probably
one of the biggest issues with using finalizers and cleaners, and it's that it does leave our
program vulnerable to malicious code and security attacks. This point, despite being an important
point, I found it a bit difficult to understand, especially because I couldn't get what he meant
by having a malicious subclass. But this is what I meant, but I'm trying to collectively learn here.
I did post a question on Stack Overflow, and I got some really good answers. And then finally,
Holga, great blog. I'm assuming it's a blog. The person answered the question, and it was,
I think it was somewhat clear. It did make sense. So all credit goes to Holga. I'll leave an answer
to this question down below in the description, where he explains how finalizers, in fact,
do create security problems. And before I read what Dr. Block has stated, let's go through
some code and understand what this issue is, practically. So firstly, I've written this
class called Finalizer Attack Example, and that also has an inner class. This inner class, in fact,
is what is supposed to do the cleaning up. So it's got this check call method, which is kind of
like a Boolean, which is just like a security check that verifies where that calls this,
has permissions, let's say. That's a bad way of putting it. But just for all the intents and purposes
think that all callers are invalid for our demo. And then we have this method, which does some
critical action. That's it's really important. So I forgot to mention that since the inner class
is static, that won't allow the JVM to garbage collect this resource. And then we have this
malicious subclass that extends the resource class. So this is where the issue lies. This resource
class, once it was used, should have died on the vine, as Dr. Block would state in this item.
It should have got garbage collected, and no one should have access to it to that object.
However, because we know that the finalized method can be accessed via the object superclass of resource
class. And then the fact that the malicious subclass extends the resource class, all it's
got to do is override the finalized method and invoke it. And the moment it's invoked,
this object, which is probably a corrupt object now is resurrected. And that gives this malicious
subclass access to this critical action method, which probably could do something like access
the database or do something that could potentially calm your application and its uses.
So which is why when I run this code, you'll see in the public static word main function.
Initially, oh, I've added this thread here with the GC. This helps to kind of demonstrate the
non-domestic behavior. I'll just show you that too. Initially, in the try statement,
it creates a new object. And when it does, it'll say because it ran a couple of times,
it would initially say I wouldn't get hands on a resource class. So okay, that's a bit confusing.
I can see I shall first get rid of the sleeping of the thread and try running it again.
When I don't make the thread sleep, it will throw a security exception.
It'll catch that there's an issue here by the check holder and then throw the security exception.
But the important point here is finalizes aren't deterministic. It's a problem. So if we do get
the thread some few minutes, two seconds to sleep, then what you'll see when you run it is
it's printing that look where it's saying, see, I got hands on this object, which is it's printing
that from the finalize method, which was a subclass, well, not subclass, which was inherited
from the resource class. And then because we got access to this object, you can probably see here
you can probably see here what it's printing out is in fact this this object, but then also
it has access to the critical action method, which ideally, which not ideally, but which
actually the malicious subclass shouldn't have access to because once again, it should have died on
the vine. I hope that makes sense. I think I got it. So I was trying to, when I asked a question
on Stack Overflow, here's what I said. I'll read out this bit of the chapter, but then I said,
in like a very systematic way, my understanding is that finalizes are not deterministic,
a malicious subclass can run its finalize method on a particular constructed,
corrupted superclass object, which is what we are doing right here by extending the resource
class. Moving the corrupt objects reference to a static field doesn't let the GCM garbage collect,
not GCM, JVM, I should fix that. So because it's static, it can't be garbage collected.
The attacker can use this object that should have died on the vine and do as they will,
pass the security flow. So this is the problem with the use of finalizes. I hope that makes sense.
I'm asking that question more from myself if I really understood that,
but I think I did, but I think I did. At least I'm going to tell myself how to feel better.
Now that I've kind of demoed that, even though I admit that was a rather pathetic demo,
let's try and get to what Joshua Block has stated here. Please forgive me. I'm trying my best to
demo it here, but because he really hasn't given tangible implementations and examples,
I'm trying my best to see if I could find code and write code and connect it to what he's trying to
say here, given that I haven't really used finalizes before ever in my programming life.
But anyway, let's see if what he's stating here makes a bit more sense.
Finalizes have a serious security problem. They open your class up to finalize their attacks.
The idea behind a finalize attack is simple. If an exception is thrown from a constructor,
or it's serialization equivalence, so that would be the constructor, for instance, of let's say this
class. The finalize of a malicious subclass can run on the partially constructed object that
should have died on the vine. So that was this subclass that extended it. This finalizer can
record a reference to the object in a static field, preventing it from being garbage collected.
Just a point here. You probably noticed I didn't
stole the reference to this resource class anywhere in any static field or didn't really hold the
reference in the subclass. The reason for that was because Holger, the answer that I got, said
something like this. He said your description is basically correct, but over complicating things.
I'm not surprised there. I tend to do that quite a lot. There's no need to store something in a
static variable as soon as the finalize method is invoked. The object is already just resurrected
as invoking a method on an object implies invoking code with access to the object. That really did
make a lot of sense to me because that's exactly what we're doing here in this override method,
in the subclass. Storing the object reference in a variable is a way to expand the lifetime
beyond the execution of the finalize method. But this is not necessary. But this is not a
necessary thing for the attack. Also, instead of using a static variable, the attacker could also
make the subclass and inner class and store the reference in the still reachable outer object.
So the following program is already enough to demonstrate the issue. So that's the program
that I showed to you before, which it's Holger's code. In fact, I just kind of repurposed it and
made it a bit more presentable, which is why I haven't done what Joshua Blocker stated here.
Once the malinformed object has been recorded, it is a simple matter to invoke arbitrary methods
on this object that should have never been allowed to exist in the first place. So that is the
arbitrary method, which was critical action that I did invoke.
Throwing an exception from a constructor should be sufficient to prevent an object
from coming into existence in the presence of finalizes. Unfortunately, it is not. And then he
states, which is kind of what I was, I tried to demo here, to protect non-final classes from
finalizer attacks, write a final finalize method that does nothing. That's exactly what we can do
here. So what you'll see is we have the resource class. And then because the resource class itself
obviously has the finalize method, if we create a final protected void finalize, you'll see that
it'll throw an error. You can't subclass it because, sorry, you can't override it because
this class that inherits that, that subclasses resource class, now can't override it. And that
never really solved the problem here. That's one way of protecting ourselves against the finalize
method. But the better way is to not use it in the first place. And that, of course, begs the
question, given that Joshua Block and the broader Java community, the experts are so adamant as to
why one shouldn't use finalizers or cleaners, what is the alternative? What should we use instead?
And that's what Joshua Block states here, to use the autoclosable interface. Before I get to
what I've written down and taken notes of and kind of try to demo what autoclosable is, let's
first go through the definition because that'll set a foundation, let's say.
So what should you do instead of writing a finalizer or cleaner for a class whose objects
encapsulate resources that require termination, such as files or threads, just have your class
implement autoclosable and require its clients to invoke the close method on each instance,
when it is no longer needed, typically using try with resources to ensure termination,
even in the face of exceptions. So the point on try with resources is in fact the next item.
So I shall go into detail as to what try with resources do in the next video.
So definition of autoclosable, which enforces encapsulation by Oracle docs is an object that
may hold resources such as files or socket handles until it is closed. The close method
of an autoclosable object is called automatically when exiting a try with resources block for
which the object has been declared in the resource specification header. This construction ensures
prompt release avoiding resource exhaustion, avoiding resource exhaustion, exceptions,
and errors that may otherwise occur. So let's take a look at a demo. Let's see
what at how autoclosable has to be used. Also, there's another caveat he's added here that it's
important that when an object has been closed that we should keep track of how if the instance has
been closed and we shouldn't rely on the client to do that. It was a bit hard to find a good
demo of what this meant. So I did ask a question on Stack Overflow on that too. I asked how to
keep track if an instance has been closed with Java autoclosable. I even got a negative
download on that question because I realized it's actually quite simple as to how to do that.
I just got a thought about it a bit more without being lazy. But nevertheless, I did find an answer
and I did post it here. So firstly, the demo, the demo on autoclosable is this. Again, courtesy of
Baldang. So we have a demo class which implements autoclosable. And then we have another buffered
read instance like the previous one we were going through for the final finalizable class,
a similar concept. In fact, the exact class that I've repurposed for this demo.
And this here, this Boolean is in fact what does that bit I asked here. It's what keeps track if
this instance of, in this case, the demo class has been closed. So when in the constructor,
the same way we are accessing a file, reading off the file, creating a new, using a resource reader,
and then we're reading the first line, similar thing doing, and we're checking if we can read
the first line. And here there's something extra added. We're checking if this resource,
so that is reader, has been closed. I think I made a mistake. I said that what this does in line number
13 was keep track of if demo class instance has been closed. That is wrong. I apologize.
What this keeps track of is if the buffered reader instance has been closed. And that's what we're
checking in the read first line method. And if it is closed, we can't access it. So it should
throw a illegal state exception. And that's what we're doing here. And then we override the closed
method, which is the method in the auto-closable interface. That method right there. And in the
class itself, we do the closing. We close that resource. And then, of course, we set the flag
to true because now it has been closed. And if not, it'll throw an IO exception, in this case,
because it's a buffered reader. So if we go to the unit test, you could see if I'm going to run it,
it did pass because all it's going to do is read the line. But of course, if we try to access the
resource, read the instance, and it was closed, it would have thrown an error. The test did pass
because it's just checking if the line, if this line is this. Oh, I should show the log here, in
fact. It's printing this log here, closed buffered reader in the closed method and flag changed to
true. So that is this right here. Where is it? I've got so many classes opened up. Oh, yeah.
That's printing this bit here, closed buffered read instance, and it's printing the flag, which is
true in this case. So that's really, it's quite straightforward, the auto-closable bit and even
how it keeps track of how it closes it. I was over-complicating in my head and I was thinking
there's some way to do it. In fact, it's tabooly. So despite being told not to use them, and we
probably will never have to use them for normal average Java programmers like myself,
what really are they useful for? What are they good for? Caviar there, of course, is that as of
Java 18 finalizes are in fact deprecated and will be entirely removed in the future. So we'll never
use finalizes, but let's say cleaners. What are they really useful for? Firstly, it's for them to
act as a safety net. And let's try to understand what that means. One use of Java cleaners,
I'm going to stop saying finalizes because it's deprecated, is that one use of that is
to act as a safety net in case the owner of a resource neglects to close its, to call its
closed method. Well, there's no guarantee that the cleaner or finalizer will run promptly or at all.
It is better to free the resource later than never if the client fails to do so. If you're
considering writing such a safety net finalizer, think long and hard about whether the protection
is worth the cost. So the way I see it, it's just an extra check one adds when writing an API or a
class just as a safety net. By overriding that finalize method, we could ensure that any of the
resources that should have been closed, sorry, not ensure, we could hope that any of the resources
that should have been closed or were closed because of the finalize method, even though
it's not a domestic. So that's, it's a trade off one has to make and think about carefully.
And then the second use is using it with native peers. What is native peer?
As the simplest way to think about it is that native peers are objects that aren't owned by the
JVM. They're sort of like a platform specific objects that the JVM runs on, the virtual machine
runs on. It could be CEO C++ objects and the JVM can't garbage collect them. And that's why they're
called native peers, even though they call peers because the objects still have dependencies on
them. But the JVM has no control of these objects in memory. It's quite interesting. I really didn't
know much about it. But of course, I found this pretty simple stucco flow answer, which can explain
that it said that a native object is not programmed only in Java, but is a, but in a platform specific
language, typically CEO assembler, even memory allocated by this code cannot be disposed by the
garbage collection by GC. Therefore, you may need to clean it in a finalizer. The native peer is
the native part of a Java object. So I'll leave an answer to this question in the description.
And that's what I wrote out here by the user Andres on stucco overflow. Thanks for that.
And Joshua Block states, a second legitimate use of cleaners concerns objects with native
peers. A native peer is a native non Java object. That's an important point to which a normal object
delegates via native methods. Because a native peer is not a normal object, the garbage collector
doesn't know about it and can't reclaim it when the Java peer is reclaimed.
A cleaner or finalizer may be an appropriate vehicle for this task, assuming the performance
is acceptable and the native peer holds no critical resources.
Saying that finally, we, we in fact get to some actual code in this item, because the other code
I showed was code that I wrote and I kind of use from other people. And that is this room class,
which demonstrates the concept of it being a safety net by implementing auto closeable. Yeah.
So the class is called room. And I do appreciate that pun there because the room must be cleaned
before being reclaimed. I like that. I appreciate that. And it implements, as I said, auto closeable.
It's got a private static final cleaner, which cleans. And this in a class,
which implements runnable is what holds the resources required by cleaner to clean the room.
So this in a class is in fact what does the cleaning in a separate thread in the background
of this broader class. So what you can see is we're simply registering the cleanable instance
with with with the state, which is a variable we hold here in line number 34 and register it.
We assign it. And after that, the number of junk piles should be set to zero. And the way that happens
is the close method, which is what we override from the auto closeable interface that will invoke
the run method, which is inclinable. So once we register it with the with the with the object
itself and then the state. So this refers to the current object and then in the state of the room
that we pass into the uh, we pass the we invoke the clean method of the of the cleanable instance.
And the clean method, what that does is it triggers the run method that sets the number
of junk piles to zero. So every time before it's reclaimed, it has to clean all the resources. Now
I didn't I think I don't think I did a good job at explaining that. It's a bit difficult to explain
because I I lack the verbal visual city and a deep understanding of how cleaner works. Therefore,
probably what I'll do is I'll go through Joshua Bloch's description or sorry, his elucidation
and then I shall refer to the code as I read them out and kind of learn it live, let's say,
which is exactly what I'm doing in this video series. The the room class implements auto close
book that I showed here. The fact that it's automatic cleaning safety net uses a cleaner is
merely an implementation detail. Unlike finalizes cleaners do not pollute across this public API.
That's correct, which is why it's a bit hard to see at first because I'm using it as a client.
The static nested state class holds the resources that are required by the cleaner to clean the room.
So that is the static nested state class. Also, to understand how nested classes work, just go and
read these docs in Oracle. It's pretty simple. It's it's a it's an inner class. I'll leave a link to
that in the description. It's got access to all the properties of the outer class in this case.
And then and then he continues. And then he continues in this case, it is simply the number of junk
piles field, which we need to clean up, which you shall see we're going to be doing this integer value,
which represents the amount of mess in the room. Yep. State implements runnable. So you can see
here it's going to implement runnable because we need to run this in the background. And its run
method is called at most once. So this method, which we're overriding is called at most once and
that is this one method is from runnable because we're running a new thread by the cleanable that
we get when we register a state instance with our cleaner in the room's constructor. So that that bit
here is done right here in the cleanable, which is what I said that we're doing the registering
as we create this new state by passing the number of junk files, junk piles, sorry. And that's what
we're passing onto this and doing the registering, which is what invokes that run method eventually.
The call to the run method will be triggered by one of two things. Usually it is triggered by
call to room's close method, calling cleanable's clean method. So that's the close method,
which we have overridden here of the out-of-class room. If the client fails to call the close
method by the time a room instance is eligible for garbage collection, the cleaner will hopefully
call state's run method. So that's what he meant by a safety net because if the client doesn't
call the close method and clean up that resource or clear up that resource,
then we expect this run method to run, hopefully.
It is critical that a state instance does not refer to the room instance. That's important and we
shall see why. If it did, it would create a circularity that would prevent the room instance
from becoming eligible for garbage collection and from being automatically cleaned. Yes,
because for it to be eligible for garbage collection, we have to make sure that there
aren't any references to that object in memory. Therefore, state must be a static nested class
because non-static nested classes contain references to the end-closing instances,
which is why exactly we've declared this static and I said to do some reading on nested classes
as to how the difference between non-static and static in the Oracle docs.
And then we shall take a look at how this class is used. So if we take a look at, let's say,
teenage up, we're doing some garbage collection manually, explicitly, but we should not depend
on this behavior. So if I go run this and run this, in fact, first let's take a look at adult,
sorry, where we're using a tri-width resource. So the room's cleanest used only as a safety net.
If clients surround all room incantations with tri-width resource blocks, automatic
cleaning will never be required. So as you can see here, I'm not, or just your block in this
case isn't doing any explicit garbage collection because we've used it with a tri-width resource
block. And if I run this, you will see it says goodbye, but also says cleaning the room. So the
object's created and it prints goodbye. But afterwards, this cleaning the room along comes from
this run method here, which we've all written and written. And that also means that the number
of chunk passes zero. So in fact, if you want to print out the number of chunk pass just to,
just to make sure that we know what's going on
and run that again, you will see it's going to print zero.
Yeah, there we go. It printed zero. That's what we expected. But then if you go take a look at the
teenager's room and if you run it, it will not run it unfortunately. Oh, it did, but it's kind of
so I'm going to try it again. I'm going to keep trying it until it does not run it. Oh, actually,
sorry. If I comment the garbage collection, because I had that uncommented, it should have
been commented out. Now it shouldn't run it. You see that it just printed our piece out,
but there was no cleaning done. And then when I do the garbage collection explicitly,
now it's going to print cleaning room. And that's what we expect. And that was though,
that cleaning room was imprinted from the previous line.
Sorry, it was printed off the previous line, of course, because it ran the run method, but
because we did do the garbage collection, that doesn't exist anymore. The memory was cleared.
And that's virtually it. That's kind of the utilities of using auto-closable and how it's
got to be used and why it's preferred over, let's say, using a final asset, for example. And then
just to conclude that point and of that demo, Joshua Block states, you might expect it to print
piece out, followed by cleaning room. But on my machine, it never prints cleaning room. It just
exits, which is kind of, well, that was before we did do the explicit garbage collection.
This is the unpredictability we spoke of earlier. The cleaner spec says, the behavior of a cleaner
during system.exit is implementation specific. No guarantees are made relating to whether
cleaning actions are invoked or not. While the spec does not say it, the same holds true
for normal program exit. On my machine, which is what we did here, adding the line system.gc
to teenagers main method is enough to make it print cleaning room prior to exiting. The reason we
didn't see that log here in line number 30 is because the moment it cleaned the room and cleared
out the resources, it exited and it doesn't really exist in memory anymore. So I repeat that point
again, on my machine, adding the line system.gc to teenagers main method is enough to make it print
cleaning room prior to exit. But there's no guarantee that you'll see the same behavior on
your machine, which is exactly why Joshua Bock states here to test the behavior. But note that
you must not depend on this behavior. Again, not to be on that horse, but the biggest problem is
the non-determinism. And we don't want that in programming. We want things to be logical and
deterministic as script programmers. And in summary, he states, don't use cleaners or in
releases prior to Java 9 finalizes, except as a safety net or to terminate non-critical native
resources. Even then, be aware the indeterminacy and performance consequences. That's it. That
was item number eight, avoid finalizes and cleaners. I hope I did a good job at demoing
certain parts of it. As you all know with these tutorials, the best way to understand it is to
after watching them or while watching them goes through the code base, because that's the best
way to grok these concepts. But nevertheless, I hope my efforts were worth it. I will try and
keep enduring and getting through this whole book because I'm really enjoying it. I'm learning a lot,
but also I want to kind of get into the habit of putting out these videos
in a certain schedule, let's say, at least once every two weeks.
But thanks a lot for watching. I hope you gained some value from it and learned something.
I'll see you in the next item. Cheers.
