Thanks very much for having me.
Yes, so today's talk is going to be the value of values.
And I'd like to start by pulling the room.
How many people are in IT or an IT-related field?
This is great.
The key is to start with an easy question after the party.
So what does that stand for?
It stands for information technology.
And one of the themes of this talk is going to be keeping in mind what information means
and what we're actually trying to accomplish.
And looking at the tools and technologies we're using and seeing if they are actually suitable
for accomplishing what we're trying to do.
So we'll start with that key word, because the technology part, I think, is straightforward.
And we'll look at information.
And of course, we'll start with the definition.
Everybody knows this is my stick, right?
If you're going to do a talk, you just pick a word, then you go look it up in the dictionary.
And you're rolling.
And it's a cheap trick, but it's actually quite useful because
there's a lot of the history of human thought sort of boiled down into language.
So if you look at the word information, it's based on the word inform.
And inform actually means to convey knowledge via facts,
to shape your mind or to shape someone else's mind by communicating facts to them.
That's what it means to inform.
And the key word I think in here, again, which is going to be a theme of this talk, is the word facts.
Because we're going to try to give more precise meaning to that and see
if our information technology actually manipulates information.
Because that's what information is.
Information is those facts that are used to inform.
And not anything else, not any of the artifacts we use to represent it.
So start again with what is a fact?
Now this is not the dictionary definition.
So a fact is a place where information is stored.
And there's a place for every piece of information.
And every fact has a set of operations, like definitely get and maybe set.
And although maybe if set doesn't have the right controls for the fact,
there might be other kinds of operations that would control that.
And then that's essential, right, that operations control how facts can change.
And then when we want to communicate about facts, all we need to do is convey their locations.
Right?
How many people are uncomfortable right now?
I am. I can't even keep a straight face with this slide.
Are you kidding me?
This is not right.
This is very, very wrong.
If my partner Stu Holloway is in the audience, he probably almost had a heart attack.
Well, this slide is up.
This is not what a fact is.
And yet a lot about that description is similar to what our programs do.
So let's dig in to the word place.
And a place means a particular portion of space.
And space is another word that's very interesting and is going to come up later.
The key word here is particular and portion.
And the delimiting nature of this, the same, this other definition has that same characteristic, right?
An area used for a particular purpose, you know, a specific area.
And we're really comfortable with the notion of place, right?
Because we have two critical places.
We're constantly manipulating with our programs.
One is memory.
And the other is, you know, the disk.
And they very much co-align with place, right?
They are places.
You know, there's only so much memory in the particular justice and memory.
And there's only so much disk space.
And there are sectors on the disk.
And these are all places.
They're subdivisions of the universe.
You know, there's only so much in the universe that's on my hard drive.
There's only so much in the universe that's in the memory of my computer.
So, I mean, I want to look at what we are calling information systems now.
Because we're building information systems.
And in memory, we're building them out of mutable objects.
But mutable objects are actually abstractions of places, right?
They don't actually have meaning other than that.
They're little barricades we've set up in front of memory
so that we don't have to directly manipulate memory addresses anymore.
So, the subtraction, that is an object that sort of helps us manipulate that place, you know, without too much craziness.
And a key characteristic here is that objects have methods, right?
They have those operations we talked about before that facts really don't have.
Objects critically have them.
They're operationally defined.
And we use them to provide a layer of abstraction over the places that our program uses.
And the same thing happens in storage, right?
We again have, you know, tables and documents and records and these higher level notions
that fundamentally are born of the desire to, again, abstract away the details of that fact that we're working with a place.
But the abstraction isn't really a first-class abstraction other than to hide place from our programs.
Actually, it isn't a sound abstraction above that.
And one of the ways you can tell that it's a place-oriented abstraction is this update,
the same notion of going to a particular part of the universe and manipulating it.
So, these are what we're building information systems on right now.
And I think we may have some difficulty seeing how that's correct.
So, I have a new label for this. It's called PLOP.
And PLOP is place-oriented programming.
That's what most of us have done for most of our careers and most of us continue to do.
And it's characterized by a very basic operation, which is new information replaces the old information.
It's that simple.
If that's happening, you're doing place-oriented programming.
It doesn't matter if it's in memory. It doesn't matter if it's on disk.
If new information replaces the old, you're doing place-oriented programming.
And it doesn't matter if your implementation technology is not actually doing that directly.
So, I don't care if you're using MVCC or an append-only database.
The logical result is that new information replaces the old.
That's an in-place system, even if, you know, for efficiency, it depends on the disk.
If in the end it can only give you the most recent piece of information, that is a place-oriented system.
It doesn't matter if it's actually going back to the same disk sector.
And there's a very good reason why we were doing place-oriented programming decades ago.
The first computers were really tiny.
They had incredibly limited memories, very, very small disks if they had any disks at all.
And so we had to do place-oriented programming.
There was no way to get a computer to do anything useful unless we took the tiny amount of memory that we had
and completely mapped out the role of every place in terms of, you know, defined our program
in terms of the role of every place of memory in helping our program accomplish what we were supposed to accomplish.
Guy Steele gave a talk in the most recent couple of years where he had this great anecdote about, you know,
the worst program he had ever written and he held up a card showing what it was.
And then he described the computer on which it ran, which had, you know, 4,000 words of memory
and how, you know, there was this map of that memory and this part here was this dispatch table
and then there was some code here, but sometimes you could cram data into it.
Then there was this other jump table and then some data structures.
And every program knew exactly where in memory those portions were and directly used the addresses.
And that's how you had to do it.
And then we got bigger memories and we said, ah, we don't really want a program with addresses anymore.
And so we added some stuff.
But the basis for the way we computed was still that, right?
We're still just trying to do that, but probably not deal with the hassles of knowing addresses directly.
You know, we use some indirection there.
The problem is that those constraints, the constraints Guy Steele and the early pioneers of computing
faced before him, they're gone.
Computers just in the time I've been using them are a million times more capacious in memory and disk
than when I started, which was after he started.
But we're still doing place-oriented programming.
I think we definitely need to consider why that is.
So one reason that always gets brought up right away is that there's this efficiency to manipulating places.
And that's definitely true.
And I'm not opposed to that.
I've bashed as many bits as the next person.
And I know how much fun that is, and I know how fast that can be.
And I think that there still is a role for that, and there will always be a role for that.
And one way to talk about when that's appropriate is to have a notion of this birthing process,
a point in time when you're starting to create a new value, and we'll talk more precisely about values in a minute.
And in setting up that value, you need to manipulate memory, for instance.
You need to manipulate places.
That's completely okay.
I would never advocate languages that didn't let you, for instance, manipulate the contents of an array,
because during this process, you need to be able to do that in order to write efficient programs.
But this birthing process is a window that ends, and it ends whenever the thing that you've made
is going to become visible to any other part of your program.
At that point, it's become a fact. It's become perceptible.
And then you have to stop doing place-oriented programming.
Because as we'll see, it's not a fit for the models we're trying to build.
So this use of place to create values or the use of place to represent values under the hood
is an implementation detail.
Of course, we have to use places.
Computers have memory and they have disks.
But what's important is that our program is not about places.
It's information technology.
It's not technology technology.
We've taken abstractions of the technology and raised them up to being what the program is about,
and that's an error.
There was a reason why we had to do it, but we don't anymore.
So two words that I think are very, very important are memory and records.
We have to remember these words had meanings before we started to try to emulate them with tiny computers.
We used these words for millennia prior to that.
We've not only co-opted them, but I think that we're starting to believe our own myths about what memory and records are.
They are what our programs say they are as opposed to what they really are.
Real memory is a cognitive abstraction over how our brains work,
and some of the characteristics about it that are really interesting are the fact that it's associative.
If your friend gets a new phone number, it doesn't go into your brain and find the phone number neurons for your friend,
and overwrite them with the new phone number.
That's not how memory works.
You get the new phone number, it's some novelty and your brain accommodates it and what was there before.
So it's associative to some connection between my friend and the phone number and those numbers,
but it's also open.
It's not a place.
Your friend's phone number is not a place in your brain.
And memory is about that, activity, acquiring your friend's phone number when he changes it.
And then records, record keeping existed before we had computers, records are enduring.
People didn't go back to their parchment and scrubbed them out when there were new facts,
and they didn't go back to their stone tablets and pave them over with concrete and then re-etched them.
They just wrote new pieces of paper and carved new stones.
They're enduring, so we keep them around, and they're accreting.
If you have new information in the old record keeping systems, you added it to what you had already.
You didn't go and erase it.
So these are critical notions.
We actually do pretend that our systems do this work,
but to the extent that we're using memory records the way we've come accustomed to, we're not actually.
So the point of this talk is that values have many advantages over this place-oriented programming,
and I'm going to talk about values in many different ways in order to try to give you a better idea
of the many kinds of meanings it can have for programming.
In particular, though, I want you to focus not only on values in memory and functional programming,
wherever you think of when somebody says you should program with values,
but also our use of values in communicating across processes and our use of values inside storage systems
because there are many architectural advantages to values that go beyond the parochial notion that a program might have.
The other point of this talk is you already know this stuff.
You were all made uncomfortable by that first slide.
Your activities show that you know this stuff.
The only thing that sort of counteracts the fact that you know this stuff is the fact that you continue to choose some of you
technologies that don't implement what you know to be true, and there may be many reasons for that.
But the most important point of this talk is that place itself has no role in an information model.
It is only an implementation detail.
If you elevate place to be a first-class thing in your information model, it is only an information model.
It's pretend it's not actually doing its job.
So let's dig into the word value.
This is a particularly tricky word, and the title of the talk is a little bit tricky.
The value of value seems to imply two meanings of the word value.
The first one is relative worth.
The value of values is how do you estimate the worth of something is a notion of value.
And then we have what's probably the clearest mapping to programming of the word value,
which is a particular magnitude or numeric value or an amount.
And this is 42.
This is the one we can really hang on to.
Everybody understands 42 is a value.
But it ends up that these two definitions are not different when you take this third definition to account,
which is precise meaning or significance.
Because what ends up happening is all notions of value are about being able to directly perceive something
and compare it to something else.
And we'll see that that allows us to have a broad notion of value,
which will not only cover 42, but other things that we encounter.
So what else might we encounter?
Strings. Are strings values?
How many things strings are values?
How many things strings are not values?
It ends up that the answer to this question is a question.
It depends on your programming language.
Are strings immutable in your programming language?
If they are, then strings are values.
If they're not, then they're not.
And how many people work in a language where strings are mutable?
How many people have ever worked in a language where strings are mutable?
How many people worked in a language where strings are mutable,
and now they're not in the language they're working now?
There have to be some people who've programmed in C and then Java.
Of people who have programming languages that had mutable strings and then ones that didn't,
how many people want to go back to mutable strings?
Wow. Do you work with other people?
It's really tricky, right?
Because we've sort of accepted, at least in Java.
How many people work in Java here?
So in Java, we sort of accepted string as a value.
We've moved on from 42.
We said, oh no, this composite thing that has a bunch of different parts,
a string, could be a value.
And it ends up that it is.
If it's immutable, it now taps into that definition of value we saw before.
Because by being immutable, we can go and take a string value
and run another string value and say, are they the same?
Do they have the same magnitude?
Are they talking about the same thing?
Are they expressing the same specific meaning?
All those definitions of values apply to something that's not mutable.
So that relative worth thing kicks in.
And I don't think anybody whose program with both wants to go back.
I'm not actually sure I believe you.
But by and large, this is something that we've accepted.
So if you want to expand the notion of value up and talk about programming values,
we're going to have some characteristics we really care about.
The first and unconditional one is that they be immutable.
We're going to see as things become mutable,
our ability to do any of the things we say we can do with information and values disappears.
On the other hand, another important characteristic of values is that they don't need methods.
Now I'm not saying that values can't have methods.
I'm not saying you can't have an object in your programming language that has the role of a value
and meets the criteria for values and has methods.
I'm not saying that that's not allowed.
But the important thing about values is that they don't need to have methods.
They're not operationally defined.
If I can convey a value to you somehow and I've forgotten to give you any code,
you can use it because semantically the value is accessible.
And so that's the other critical thing.
It must be immutable and it must be semantically transparent.
There can't be any operational interface over a value that tries to encapsulate
what it means or your ability to do equality on it.
You might have additional methods.
You might have two upper on a string.
That's just sort of object-oriented goofiness, but it's harmless in this case.
The important thing though is you can't have a value where only on Tuesdays
by calling this method and that method, can you see what it's about?
They have to be semantically transparent.
And it's okay, again, to have abstractions.
In particular, when you start talking about composites and collections as values,
you'll often have an abstract definition of that.
But that abstract definition satisfies the other two critical properties.
It is immutable and it's semantically transparent.
The abstraction is not trying to get in the way of you seeing what it is
and seeing all of what it is.
It may just be hiding the storage part.
So let's go through some properties of values and how they compare to places.
The number one properties values can be shared.
And they can be shared freely.
And that the way you share them is just by aliasing them.
Because you know that they're immutable.
If you ever encounter a value, you can just start using it.
And it's funny because people talk about functional programming
and higher order functions and all of this stuff.
And concurrency and other advantages.
But when someone actually goes from not using a functional programming language
to using one, one of the deepest pleasing benefits they have is this one.
Is the fact that when you program with values, you can share pervasively
and you never need to think or worry for one fraction of a second.
You can't mess anyone else up and they can't mess you up.
All values are freely shareable.
If you've never done it before, it will change the way you program forever.
It really makes a big difference.
One of the things that also happens, especially when your values are implemented
with persistent data structures, is that incremental change is cheap.
So it's quite common to say, somebody gives you this big thing
and you're like, I love that big thing except for the first thing.
I'd like to have that big thing except for the first thing.
And that ends up being completely straightforward to A do and inexpensive to do.
So that's really great.
If we compare that to programming with places, what happens?
Defensive copy. How many of you have heard the term defensive copy?
Why do we need to defend ourselves from ourselves?
This is really not a great phrase to be using every day.
Cloning, another nasty notion, and locks.
These are all things that are either part of or in the way of sharing
when you're programming with places.
Reproducible results are another fantastic benefit of values
because operations on values are stable.
You do them over and over again. They never give you a different answer.
This is really a great benefit when you're doing testing, obviously,
because if you want to say it still works,
hopefully you have code that is reproducible in the first place.
And you actually spend a fair amount of time with place-oriented programming
making that sentence true, that the test actually, when run twice,
should return the same result.
If you're programming with values, that's not even a question.
Debugging is also critically different when your program programs with values,
especially when your architecture is based around values.
So some customer has a problem in the field,
and you have a value-oriented program.
You can say, obtain the value from your database and the query you're running
and email them to me.
Just the value that was the input to the process and just the process,
the query, those two things.
And I can reproduce here over email versus what?
How many people have ever tried to set up a database and a running process
that emulates a customer failure?
That is not a party, right?
Not fun. Not fun.
And that's the problem with places, right?
You have this sort of global state that you have to reproduce
in order to debug a field problem.
That's very, very tough.
Another advantage of values is that they're easy to fabricate.
Anything can create a value.
Any programming language can make a value.
You may have written it in this, and then later you need to have somebody
who uses different languages drive it to see if it's working.
So for testing, it's really fantastic that you can fabricate inputs to test programs
using any technology.
You don't have to sort of get the class library that has the right classes
and interfaces related to the GOOK that you used in your program.
It's like your program takes data.
You now can write another program that can produce data to test it.
And also for simulation purposes.
So when you start raising your testing up to the next level
and you're trying to drive your program to different kinds of situations,
all you need to do is algorithmic generation of data
to get a variety of simulation points for your program.
If your program can only get into a particular state
by a series of interactions through objects,
how are you going to algorithmically drive that program to different kinds of test cases?
It's a huge problem.
It's just a mess.
Whereas if you can just algorithmically generate data, you're done.
And again, it goes to this point about places.
With places, you have to emulate an operational interface.
That's a ton more work.
And also when you want to drive it,
you have to drive it through the operational interface instead of with data.
Imperativeness.
We love it, right?
And values are in the way.
That's a feature.
That's not a negative aspect.
They just refuse to help you do this.
And I think that once you start using languages that make values the default,
you feel frustrated initially about this.
But in the end, it's a tremendous benefit
because imperative code is just more complex.
As used to it as you may be, it's more complex.
And the problem with places is they force you to do this.
It's the exact opposite, right?
Values thwart you and places force you to write imperatively
and therefore in a more complex way.
Starting to lift the game a little bit out of your local view,
which might be, you know, I'm in Java and I'm doing this.
I have these interfaces that have this class model and blah, blah, blah.
A great thing about values is language independence, right?
If you ever want to pretend you're a polyglot shop,
you're going to immediately face a challenge, right?
With all your interface-driven, object-driven designs,
which is you can have them all over in your Java program,
but then, you know, your Python program or your JavaScript program,
it doesn't know how to talk about that stuff, has no means of doing it.
And immediately you're going to face this pressure to move away from that.
And towards what?
Towards values is where you're going to end up.
They are the tool for polyglot programming.
They are the tool that gives you this independence in language.
Because places are defined by language constructs, you're stuck.
You're really stuck.
You don't have a definition independent of your language
that you can use as a basis.
And sure, you know, you can build proxies.
You can automatically build, you know,
soap interfaces to your objects and remote your objects
and generate, you know, matching objects in different languages.
But that's just a ton of effort.
That's not really adding any value.
So this language independence actually falls out of a bigger property of values,
which is that they're generic, right?
We can get representations in any language, as we said.
But the other thing is that there are very few values, you know, in the general sense, right?
Once you start talking with values, you don't end up with a lot of specificity, right?
There's a logical notion of a list.
There's a logical notion of a map and a logical notion of a set, right?
And strings and numbers or whatever.
But you can probably exhaust what you need to use in the value space
with fewer than 20 of these things.
Whereas how many people can build, you know, a system with 20 Java classes?
Just 20.
No large system, right?
As the system gets larger, how many more classes do you need?
More and more and more and more and more.
Just they keep going on and on and on.
And that's because operational interfaces are specific, right?
That generates a ton more code.
And it actually is a counter argument to the promise of object-oriented programming,
one of the promises.
One of the promises was reuse, right?
That's the big lie of object-oriented programming.
Every new thing you have to do, you write a new class.
Where is the reuse in that?
There's none, right?
The other thing is you're sort of breaking away from the job you're trying to do, right?
If you're trying to represent information, you need to represent facts.
You need to have values in order to have things be comparable, right?
If I have a person class and you have a person class in their own namespaces,
and they have name, address, and email, and name, address, and email,
what can we do with those two things?
Nothing.
Even though they're semantically identical, they use the same names,
and they use the same names for the fields, they're completely not interoperable.
Even if they all had public getters, they're sort of complying with the accessibility part.
The specificity that you added killed your reuse.
And again, getting more in the large, or looking towards programming in the large,
values make the best interface.
This is actually one of the biggest problems, I think, we have right now.
When we're working in the small, we're going to have this new thing.
We start with a monolithic design, but within that design, it's not monolithic.
We have a subsystem for this, and a subsystem for that, and a subsystem for this.
That's all great.
And then it's like, oh, you know what?
That's getting too big for this box.
I want to move this out of that box to this other box.
And when I do that, I think there's a different programming language that would make that easier,
or it's going to be shipped to another team that works in a different programming language.
So we're going to do this other thing.
If you have a value-based interface, you can do that move.
If you've programmed with data-driven interfaces, you can do that move.
You can port that code, or you can write new code that interoperates in a different language,
because it's data-driven.
Another critical thing you can do if you have a value-oriented interface is you can enqueue it.
So even if you stay in process, a lot of times one of the architectural needs you have is,
you know what? I'm calling this and calling that and calling that.
And I need to buffer.
I need to do some more management of things, or maybe I want to get some more concurrency in play, right?
And therefore, I'd like to enqueue those calls.
So I want to set up a queue, so now I have this flow and maybe get some pipelining in my program.
If you've called a specific interface, just call a specific interface and call a specific interface.
And then you want to pipeline that? What can you do? You're stuck, right?
Because you've got to go and build, like, proxies that look like your objects that then have a queue inside
that then spit out on the other end, another thing that looks like what it was talking to,
and then, if I haven't forbid, it was bidirectional.
You're just totally toast.
But if you had a data-driven interface, like this guy was calling that guy, but he was just passing data,
if you want to stick a queue in the middle of that, that's straightforward to do,
because you can put values on queues.
So in contrast, if you're doing place-oriented programming, your stuff is application-specific.
Your stuff may be language-specific, and it may be coupled to your program flow.
Architecturally, you're dramatically limited.
And this is a big deal, because you desperately need to be able to take your small programs
and make them large programs, and take your one-machine programs and make them end-machine programs.
If you can't start with an end-machine program, you're not forced into this.
But the thing is, we know this.
Because when we program in the large, we don't pretend we have objects.
We don't create operational interfaces.
We don't chat.
We don't use Corba anymore.
That's dead.
That lost for good reasons.
When we actually start out building a more distributed system, we program with data all the time.
We already know how to do this.
We use data on the wire.
We use restful interfaces.
Everything is different in the large.
Why are we still doing this arcane, goofy, memory abstraction-oriented stuff in the small?
It doesn't match the large.
It's not going to help us make our programs bigger, and there's no benefits to it.
As soon as we look at our programs in the broader sense, we don't do this.
We don't make the same choices in the large.
We're still making them in the small.
I think it's just because we're comfortable with our programming languages.
Another key advantage of values is that they aggregate.
In particular, values aggregate to values.
If I have five values, and I put those five values in a value list, that resulting thing is a value.
In particular, everything I've said about values accrues to that composite.
That composite thing has all the advantages of a value that all the value parts of it have.
It's transparent.
It's transmissible.
All the characteristics are great.
You can contrast that with programming with places.
If you have a bunch of objects, mutable objects, and you combine them into a bigger thing,
what properties does it have that you can understand?
Even if you really understood all the sub-components, what properties does the composite have?
None.
You have to start from zero again, defining the operational interface of the aggregate.
Even if you had very carefully defined cloning and copying and locking policies for each part,
as soon as you combine them together, you're toast.
None of those things work.
You now no longer have a copying policy, no longer have a cloning policy,
no longer have a locking policy on the aggregate.
So nothing composes with places.
That's a big negative.
So now I'd really like to start broadening the notion of what we're talking about when we're talking about values
to outside one process, to talk about them in the large and in the small.
I'll still mention the others.
And talk about a few what I'll call extended value propositions.
Using values as a mechanism to convey things and to perceive things.
Using values as a mechanism for memory.
How values will reduce coordination.
How they provide location flexibility.
And finally, how they're essential to making programs that support decision making,
which is our job in IT.
So we have conveyance.
Conveyance means to send something to somebody else.
So this is sending.
In the small, with values, it's really straightforward.
If I give you any reference to the value, I'm done conveying it to you.
I've conveyed.
It's extremely cheap.
And again, as we saw before, it's worry free.
Imagine, though, that you want to try to do conveyance with places.
So you have this mutable object and you put it on a cue.
And later somebody's going to consume that cue.
What actually have you communicated to that person?
Nothing.
You don't know.
I mean, you put it on the cue now.
It's just a reference to a thing that could change.
Whatever your intent was in conveying it, it's not captured by that mutable thing on a cue.
So conveying places is extremely difficult thing to do.
We waste a ton of time.
I mean, everybody's thinking about places that, you know, I do these things,
but I spend a huge amount of work trying to do them.
You have to try to clone it or something like that.
You have to turn it into a value, essentially.
Now look at conveyance in the large.
Again, here, I think we figured this out.
Values rule on the wire.
We don't really do anything other than values on the wire now.
HTTP, really, all distributed programming puts values on the wire.
We don't set up multiple objects with tiny little interfaces
and chat across the wires.
We just don't do it.
People imagine that, right?
When they first tried, you know, objects were like all the rage,
they were like, oh, distributed objects,
because that's all we can think about,
and so we'll think about it broadly.
But it was an utter complete total failure.
And we're done with it.
Again, in the large, we understand this.
So that's sort of the wire part.
And then in databases, we have the same problem, right?
If I give you the primary key of a record in the database,
if I send that to you over a queue,
what have I actually communicated to you?
Nothing, right?
Because what you're going to see depends on when you look that thing up,
just like with objects before.
Putting an object on a queue,
sending something to the primary key of something,
what's behind that stuff is places.
You actually haven't conveyed anything specific.
In other words, you haven't conveyed information.
All right, perception.
It's the flip side, right?
I know there's something out in the universe,
and I want to see it.
I want to perceive it.
And the word perception is an interesting word.
It really means sort of to take it in the entirety of something.
And it's very important, right?
Because you need to take things in the entirety
of a position from before.
So in the small, again, it's really straightforward.
If you're programming with values, right,
if I can reach your value, however,
you pass it to me or it's in the collection that I can see,
if I can reach it, I can see it.
I can perceive it.
My part of the program can capture that value,
because I know it's never going to change.
So as soon as I can reach it, I've acquired it.
Places, it's amazing how difficult this activity is.
How can you perceive a mutable object
that has more than one getter?
What's the way you do it?
How do you do it?
We're all object-oriented programmers at one point in time.
Who knows how to do this?
Who could say right now how to do this?
No one can, right?
Yeah, you can't.
Yeah, either.
Stu is like...
He cannot.
I know he can't, from personal experience.
No, you can't do this because you need this other thing, right?
You need the recipe for doing this.
And the recipe is something everybody has to make up
over and over and over again, right?
The copying recipe, the locking recipe, the cloning recipe.
We've got to make this stuff up,
because the thing could change, right?
And we have multiple independent operational interfaces
to the parts.
We can't actually perceive the whole.
Can't do it without help, without these recipes.
And again, we know those recipes don't aggregate.
Same thing.
In the large, on the wire, right?
We do not go and chat with an operational interface to a thing
and grab its pieces.
I mean, just imagine doing that.
Imagine if HTTP, you know, in order to get a web page,
you had to say, get the header, get the cookies,
get to this, get to that, get the other thing,
get the title, get the first segment, get this div,
get that div, blah, blah, blah, right?
Forget about the communication overhead.
You couldn't actually know that the end of all that communication
was the page that anybody ever wrote at one point in time
that was something that somebody looked at and said,
yeah, that is what I intended.
That is the value of the page right now,
because the operational interface is in the way of you
perceiving the entirety of the thing.
And we don't do that, right?
We don't do that on the web.
You ask for the page, you get the whole page.
You get the entire value.
It's a little bit trickier with databases.
Many databases will give you the ability to capture
the, as a value, some subsection of what they have
in a coherent way.
But beyond that, they either can't
or they require a transaction to do that.
We'll talk about that in a second.
All right, so what about memory, right?
It's very important for our programs and for the users
of our programs that our programs remember things
at various points in time.
So what does it mean to remember something?
In the small, again, there's really nothing to it, right?
Remembering is aliasing.
If I can touch the value, I can remember it.
I can keep a copy of that indefinitely, right?
With places, I'm really in trouble.
I'm back to that copy problem.
I need to copy it if I want to remember it,
because I know it's mutable lifetime
is going to take it to different values.
So I need to be able to copy it if I can.
In the large, the same thing comes about, right?
How many people remember the early days of the web?
First, it was all static pages, right?
It was great. You go to the page, you get the static page.
Maybe people updated it or whatever, right?
Then people had websites that were based around programs.
They're like, oh, cool, I can generate pages.
This is awesome, right?
Who around that time period of the web,
when that was first possible, ever said,
oh, I'm researching this thing.
I'm going to bookmark all these things I encountered
that are interesting and relevant to what I'm doing.
And then went back to those bookmarks a month later.
To find that absolutely none of them pointed to the thing
that you were looking at before.
And then you actually had remembered nothing, right?
Eventually we figured this out, and we have these conventions
about permalinks and things like that.
But again, if you don't have something like that,
you don't actually have a memory system.
You only have places out there.
And it's the same problem happens with the database, right?
If I don't remember something in a database,
how am I going to do that?
Because people are saying, I'm talking about databases
and databases that lose track of things.
We don't. We only add stuff to our database.
But you're doing it yourself then, right?
You're doing it yourself.
You're saying, I have this place-oriented thing.
I'm not going to use it in that way.
I'm going to maintain time myself,
and I'm going to keep new values myself.
And you can do that, right?
How many people have ever written a system
that made a new record for every new piece of data
and kept timestamps on those records?
Right?
How many people wrote the now query for that?
Yeah.
And is that fun?
That is not fun.
How many people are trying to make that now query fast?
Not fun.
Very, very difficult.
So you don't want to do it yourself there.
Reduced coordination is another critical benefit of values.
Right?
In the small, when you're programming with values,
there's not a question about this.
It's not a question to answer.
It's a question that doesn't come up.
It's a question about values.
Right?
And the problem we saw about places exist here.
The lock policies don't aggregate.
We have to lock, and we can't combine those policies.
In the large, this is another big problem, right,
for databases.
When you have a place-oriented database,
if you want to read consistently,
you have to read in a transaction.
You have to go to the database server
and hold up the world to some degree
in order to see something coherent.
It's really a coordination problem.
It's an architectural problem.
It's a throughput problem.
And it's a scaling problem.
This is a big architectural disadvantage
of place-oriented programming.
And I think it really highlights
one of the big, you know, wrongness here.
In addition, even if you think,
you know, all right, I know I have to do read transactions,
this is one of the things that's most frequently gotten wrong.
Right?
People just don't understand read committed
or how read committed is combined
or how independent reads in a batch file work.
I mean, how many people think the programmers
in their shop actually don't know how that stuff works?
Yeah.
They don't. They really don't.
Okay.
So, another key benefit of values
is location flexibility, right?
In the small, again, with values,
there's actually no need for more than one location
because aliasing covers every case we've seen so far.
Memory, perception, conveyance,
it's all covered by the fact
that you only need one copy.
On the flip side, with place-oriented programming,
there's very specialness
to that master copy.
If I want to know the value,
I've got to manipulate that master copy
and coordinate with everybody about doing that,
which means where that is starts to matter to me.
In the large, again,
we really do this
and we really care about it, right?
We've incorporated those things
in the HTTP protocol and whatnot
so that we can do caching.
We can say, this expires, this value
is stable and, therefore,
you don't need to come to me every time
to figure out what it is.
You can go to this cache over here, right?
You can go to this content distribution network
over there.
We saw already...
Well, one of the interesting things
about content distribution networks is
why don't we have CDNs for databases?
Why do they make sense for webpages
but not databases?
That doesn't make any sense to me.
The other thing we saw
is that database interfaces are movable inherently, right?
I don't really care where you are.
We're going to communicate data.
I don't care what language you're implemented in
or if you move around
or if I have to redirect to get to you or things like that.
So, again, I think we understand this in the large
except in the data storage
but definitely in the communication protocols.
So,
now the big point.
Facts, the things we said
are the source of information.
Our values by all the definitions
I've given and have all the benefits we've said.
They're not places.
Right?
But don't facts change, right?
Didn't my friend get a new email address?
Didn't that change the fact
of his email address?
No.
It did not. There's now a new fact
which is today,
your friend's email address is this.
It did not change the fact that yesterday
your friend's email address was that.
They don't change.
And this goes down to the very core
of what fact means.
A fact means something that happened.
Something that existed.
That's what fact means.
It doesn't mean the slot
where you keep your friend's email address.
Right?
We all laughed at that slide earlier.
But it's true.
This is what a fact is.
And the roots of the word fact
actually go all the way back to Latin
where it was a past participle
that said something done.
Factum. Something that done.
Something that happened.
So this is really critical if we want to build
information systems, right?
Because information is based around facts.
And facts doesn't mean just the most recent facts.
Right?
We know knowledge is derived from facts.
We compare facts to each other.
We combine them.
We make decisions about that.
But one of the critical things we do all the time
is we compare facts from different time points.
Right?
Imagine if you only knew
the present
value of every fact
that's relevant to you.
You only knew the present value of everything.
What kind
of decision-making power would you have
compared to knowing something about time?
It would be dramatically reduced.
I don't know if anybody saw the film
Memento or whatever.
If you had a limited window of time
or if you only knew the present,
you actually can't make decisions.
It's like built into our brains.
If your programs are serving humans,
it is built into our brains to delta
now with before.
That's how we make decisions.
So building systems that only keep the most recent values
of things, those are not information systems.
Right?
So you can't update a fact.
There's no such thing as updating a fact.
A fact is not a place that...
you can't do that any more than you can change the past.
So now let's revisit information systems.
What should they be?
They should be about facts.
They should be completely about maintaining
manipulating facts.
They should be about giving our users leverage
over facts.
Helping them make decisions
based upon the facts that the system
is maintaining on their behalf.
That means that our system should be
value-oriented.
They should not be place-oriented.
We have to stop using
process constructs for information.
I'm not trying to bash objects
universally.
You can go home and do that.
But
the very few places where they're appropriate
are more process-oriented
places.
And their use for
information is actually
an idea bereft of merit.
There is not one
good component
of using mutable objects for information.
It's just wrong.
So,
we know this is wrong,
because we're decision-makers.
We all do stuff all the time.
We know what it takes to support our own decision-making
process.
And it's information.
We build systems. We run shops.
We have stuff we have to accomplish.
We're like mini-businesses.
Programming shop is like a mini-business.
It has stuff it has to accomplish.
It has successes and goals and objectives.
We try to spot trends and rates in things,
especially in our own systems.
We often need to aggregate things.
This is what decision-making is about.
Both in the large and in the small,
and for businesses and for programmers.
And a lot of this decision-making
requires a time component.
So,
let's look at
programmer IT.
Because we also use computers to support our own decision-making
process, don't we?
What kind of systems do we give ourselves?
What kind of information systems do we
give ourselves?
Well, one big one is source control.
Anybody keep their source control
in a directory, right,
where, you know, when somebody edits the file,
they save it into the directory over the one that's there.
Update in place.
How many people do update in place source control?
No.
We don't do that.
How many people store the stuff in source control
with no dates on the edits?
No timestamps?
We keep track of time.
How do people throw away their old source code?
No.
We don't do that.
Why would we do that?
We couldn't make decisions about what was happening
in our business, in our programming business,
right?
We would be crippled by that.
What's another critical thing that we keep track of?
We run our programs,
and we keep track of what our programs do
in logs,
right?
Is our program working?
Is it working well? Is it using memory well?
Does it have good performance?
If there was a problem, what went wrong?
All this decision making we need to do
is our little programming business, right?
Our logs update in place?
Anybody want to use a log system
that only keeps track of the last latency?
Or the last time somebody communicated
with a particular endpoint?
Anybody want to do that?
No.
No, they are not update in place.
Nobody has no time stamps in it?
No.
We keep time stamps. Of course we do.
How are we supposed to make decisions
without time stamps and without keeping track
of everything that happened?
Because we want the facts when we need to make decisions.
This is our IT, right?
Anybody want to have the ability
for somebody to go back to an old version
of a source file and change the old version
in place?
Or change logs in place?
Edit logs?
Any value in that?
No.
Our IT systems are not like this.
So,
let's talk about big data.
It's my contention that a certain portion
and quite possibly a very large portion
of big data, the hot new topic,
the big thing
is this.
It's businesses saying to programmers,
I like your database better than the one you gave me.
Because your database has everything in it.
The one that you gave me,
it only remembers the last thing, right?
I can't track trends.
I can't see latencies.
I can't see where everybody was on the site.
I can't make the same kinds of decisions that you can.
I want to mine your logs
to get out business critical information.
Because that's the only place that it exists.
Because you're not keeping your own database this way.
These logs have everything.
They have time on them.
They're huge, rich sources
of decision making power.
They're all filled with stuff
we're not putting in the database
for some reason.
And I think it's actually quite embarrassing.
I think that IT right now
is in a very reactive place here.
Business has discovered
the value that was in our logs.
Our logs were just like for ourselves.
We could see if our programs were working.
But they happen to keep track of
where everybody clicked,
how long things took,
what the flow was between events
that happened, including stuff that happened
that in the database ended up overwriting old stuff.
That's all in these logs.
But really,
mining logs?
Flat files?
We know better than that.
We have technology that's better than flat files.
Anybody really happy that their logs
are in flat files in the end?
Obviously, it's efficient
to sort of append on them.
But in the end, you struggle right after that
to try to get leverage
over that data.
Because we know flat files are not great.
One of the advantages programmers gave to businesses
was the invention of databases,
the invention of indexes and trees
and these other data structures
that really let people leverage information.
We're not actually putting
this critical information
into a leverageable place right now.
And it's co-mingled with a bunch of crap
that's not actually useful to the business,
like latencies
and things that were really to communicate with us.
This is mixed
in the logs of stuff about
seeing if the system is working okay
and actual activity against the business.
If you could pull out this part
and put it in a leverageable store,
your businesses will be a lot happier
and that's where we're going to end up.
Big data is forcing us to do that.
But you should all look at the deep reasons
why this is happening.
They have to do with the fact that we've built
better information systems for ourselves
than we've delivered to our business customers.
So I think we're entering the space age.
And the space age is the age
where we have
access to space from our programs.
We said place was a portion of space.
Space
is the unlimited expanse
in which all things
exist and all events occur.
And this definition of space,
I mean it goes all the way back
to the roots for spatial
and the Latin there.
It's always incorporated
both
place and time.
The notion of space has always encompassed
both place and time. They're connected together
quite significantly.
Are we in the space age?
Are we programming now with space?
I think we are.
We had virtual memory
which really took us a level away
from the actual addresses.
Then we had GC
which meant more was
transparently available. Whenever I needed more
I could get it.
Guess what? If your program runs indefinitely
long and calls new and new
never fails, your program
is running in space
not in a place. It's running
in space.
If S3 never fills
up or
if you can always go to the store and buy another hard drive
and stick it in your array
live,
you're programming with space.
There's no place there. There's no limit.
There's no delimiting that.
That's space.
What does this mean?
It means that we can take a different
approach to the way we do things. We're
going to say we are building information
systems. Those systems should be maintaining
facts and that new facts
require new space
and we have space.
This is the end
or this should call for an end
to place oriented programming.
If you
can afford to do this
why would you do anything else?
What's a really good reason
for doing something else?
And guess what?
You can afford to do this. You already can afford it.
You're already running programs that call new
indefinitely and don't fail
and you have access to S3
or things like it.
There will be garbage. There will be
different characteristics to our use
of space, especially storage
that are very analogous
to what we saw when we
enabled space and memory.
The whole notion of garbage collection
is going to happen in storage.
If you have a grip on that
you have no problems understanding
a space orientation
with storage.
So, to summarize
for some reason
we continue to use
place oriented programming
both languages and databases.
We even make new ones.
It's actually the saddest
thing is the fact that we continue
to make new languages
and new databases
that still emulate
the decisions that were made
when computers were tiny
and we needed to program in a place
as opposed to in space.
This is not a no-SQL versus
old-SQL. There are older systems
that maintain time correctly
and most no-SQL and new-SQL
things are still place oriented.
It's not about old and new.
It's about place oriented or not.
The rationale for doing this is gone.
I don't think anyone
could deny the benefits
that I just enumerated for values.
In fact, by your actions
especially in your own IT
services for yourself
you're demonstrating
you know this value proposition.
We recognize this.
So we need to start making
information systems
that are really about facts.
That are really about
information. I think the demand
is clear. This big data
explosion is saying,
businesses are saying, I demand
to know everything that happened.
I demand not to lose track
of the facts. These things are important to me.
They're important to the decisions my business makes.
And they're soon going to say
why the hell is that
only exist in a log?
Why are you sticking it there?
You have indexes and databases
and things like that you can use for this.
I'll leave you with this.
Thanks very much.
