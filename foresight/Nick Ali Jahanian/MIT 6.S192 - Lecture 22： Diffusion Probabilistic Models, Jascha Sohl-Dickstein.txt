This meeting is being recorded.
Hello, everyone. Welcome to your course, AI for Art, Aesthetics, and Creativity.
Today we have a very special speaker, Joshua Soldiksten, who is a Senior Research Scientist
at Google Brain, and he is one of the pioneers of diffusion models and deep learning.
At least in the, as far as I can see in the literature for the area of deep learning,
but he can tell me more and correct, tell us more and correct us.
So let's ask Joshua to, if you would like to share a little more about his interest and what he inspires him, and then start from there.
Great. Yeah, so I wasn't prepared for the interest question, but I've done a lot of different things.
I mean, most in the science, but I worked on the Mars rovers after graduation, and then I went into the PhD in biophysics, and then I did computational neuroscience,
and then I worked in the computational neuroscience lab, and then I started doing machine learning.
And so I don't know if there's like any single coherent thread, except that I'm chasing things that I think are really, really cool.
And I will say I get like an amazing sense of satisfaction from figuring things out that like no one has ever figured out before.
And I think that might be one of my driving motivations.
And so I think creating something new is maybe one of the most satisfying parts I feel about science, and maybe something else, something that you also feel if you're like creating art.
Cool. So thanks for the invitation for being here. I hope this will be a fun talk.
I'm going to tell you about diffusion probabilistic models, especially I'm going to tell you about content from these two papers in the lower right.
Ali already said this a few times, but pretty please interrupt me with questions through the talk. It's like so good to get feedback from the audience from giving a remote talk.
I also actually left time in the talk for questions. So if you don't ask any questions, then we're going to end up comfortably early.
Cool.
So before I dive in at all, I just want to start by calling out my collaborators, especially Eric and Eru and Surya on the 2015 paper and Abhishek, Ben, Dirk, Stefano and Yang on the 2021 paper.
Maybe a particular call out to Yang Song, who was the first author on the most recent ICLR paper and did like an absolutely incredible job, as well as to maybe Ben Pool, who was Yang's primary mentor, and also deserves an outsize share of the credit.
I'm going to spend most of this talk diving into the nuts and bolts of this class of models.
Since this is an AI plus creativity class though I wanted to just start by sharing some of the ways this kind of model is already being used to create art.
Maybe the first of these is there is this group of artists on Twitter, and I suppose probably in real life too, using classic techniques called guided diffusion to generate amazing images conditioned on textual pumps.
And so here we see two different examples of this. Here we see the prompt is a surreal album cover depicting a boost of eternal dread, hashtag pixel art.
And actually putting things in pixel art in the prompt tends to make it the model produced images that might be more likely to appear with that hashtag, and so that's actually part of the prompt.
And you get some images that could be interpreted as a boost of eternal dread, or on the right you prompt is a snowstorm in Los Angeles, and you are able to produce some images that are like the models imagining what a snowstorm might look like in Los Angeles.
And at least to my eyes I'm surprised and impressed by the quality of the results they can get in this way.
The second of these maybe more creative uses that I'm aware of is work that uses diffusion to turn very rough sketches into high quality images.
So here in the top you can see some rough sketches of a few different scenes, and then in the bottom you can see the fusion process running to turn those rough sketches into detailed imagined scenes.
So I also think that this is a pretty cool example of the potential for creative use of this class of models.
Okay, so shared some creative uses of diffusion models, but structure for the rest of the talk is going to look something like this.
I am going to provide some physical intuition for what we're going to be doing.
Then I'm going to work to make that physical intuition more mathematically precise.
Then I'll show how we can generate samples from the model, and then I'll tell you about some surprising connections between diffusion processes and neural ODS, which you may or may not have already heard about.
And then I'll show how we can sample and evaluate conditional distributions.
At a super high level, we're going to use diffusion to destroy any structure in our training data.
Then we're going to carefully characterize this destruction of structure, and we're going to reverse time, and we're going to run the destructive process backwards to build a generative model of the data.
Training a model to reverse time maybe sounds a little bit crazy, but there may be two observations we can make that highlight its causability.
The first of these observations is that we can use diffusion to destroy the structure in our data distribution.
Here I want you to imagine, and this is going to be very much trying to ground this on my physical intuition, which if you have a physics background you might like, otherwise I apologize.
Here I want you to imagine that the density of dye molecules represents a probability density, and our goal here is to learn this probability density.
This is typically a very challenging thing to do.
But even if we can't build a model of the structure in our data distribution directly, what we can do is we can map our data distribution to a much simpler distribution that we can model.
So in this physical example, if we allow diffusion to continue long enough, then eventually the dye molecule would be evenly distributed in the jar, and we'd have a uniform distribution.
It's maybe not immediately clear that this is helpful, but what if we could reverse time and run this process backwards? What if we could start at a uniform distribution and generate the data distribution?
In physics, this is overwhelmingly unlikely to happen spontaneously.
Liquids don't spontaneously unmix any more than a shattered glass will spontaneously reassemble, but we can maybe use machine learning to do it.
And to see our first clue as to why this might be possible, let's zoom in on a small volume of fluid here.
So Q super exciting keynote zoom effect.
So the first clue that time reversal might be possible is that although there's this concept of macroscopic irreversibility where the reverse trajectory is overwhelmingly less probable than the forward trajectory from the microscopic perspective.
The picture is completely different and is symmetric.
So here we've zoomed in and now each bright spec corresponds to a single dye molecule undergoing diffusion.
And if we were in person, I'd ask you whether this video was like being played forwards or backwards, but I'm just going to tell you that this video is being played backwards in time.
And here I'll flip it around.
And now it's the same video, but it's being played forwards in time.
And you can see that despite like flipping the arrow of time, the motion of the dye molecules, the behavior of the dye molecules looks looks completely identical and make that more concrete.
The diffusion kernel has the same functional form both both forwards and backwards in in time.
So at every time step, the next time molecule position is drawn from a very small Gaussian centered around its current position and more generally depending on situation might also be be a drift run.
This is really great for us, because it means that if our forward diffusion process was a sequence of small Gaussians, then our reverse diffusion process is also going to be a sequence of small Gaussians.
And I'm showing this in continuous state space. I'm not going to talk about it today, but you can do the same thing for like diffusion over binary variables.
All right, this is probably a good time to pause for questions for a question and also barking dog, which you may or may not be able to hear.
Yes, you can definitely hear the dog.
Cool.
So just to maybe do a summary slide away, I told you we're going to use the fusion process to destroy all the structure in the data.
And then we're going to learn the reversal of this diffusion process.
And learning the reversal of this fusion process is going to end up being requiring estimating a function for the mean and covariance of each step of the process.
And that reverse diffusion process is going to form our model of the data.
So maybe just to illustrate what this means for real data, we might start with data points corresponding to images on the left.
And running diffusion on these data points will correspond to mixing in more and more and more random noise to the images.
And after some amount of time will be left, we'll erase all the structure and we'll just be left with a color of noise.
In the right image, we see a 1D example. Here the x-axis is time and we are diffusing a 1D bimodal distribution into a 1D Gaussian.
And we're going to learn the time reversal of this process. We'll be able to generate data samples by running the diffusion process that starts at noise and ends at the data distribution.
And here we see this go through the images where a noise sample corresponds just a color noise image and ends up as a sampled image.
And on the right you can see this for the simple 1D distribution.
Okay, so I've just tried to provide intuition for what is going to happen and I'm about to dive into a bunch of math.
So this is an excellent time to pause and poll for questions if anyone has anything they want to ask about.
Maybe I can ask a question. If you could please go to the previous slide.
In order to understand a little more of this slide. So you are saying you are sort of introducing noise in 1D. Does it mean that you are showing the noise that over time you're adding to each pixel?
Yeah, so maybe something that's implicit in the slide which I should describe explicitly.
So here on the right pane we're showing the evolution of samples in like a 1D distribution.
So in the left in the right pane just like in the left pane there are four samples and they're evolving in 1D.
If you take an image you can think of an image as being like a really long vector of length like number of pixels times number of colors.
So if you have like a thousand by a thousand image with three colors then it will be like a vector of length like three million.
And so then what we're doing is we're doing the same thing we're doing on the right but we're doing it in this like three million dimensional space instead of this like one dimensional space.
So like you can think of that image as being a point in this three million dimensional space and we're just diffusing the image like through the space.
And if you look at what that looks like that looks like noise being mixed into the image as you like take the image and like diffuse each of its coordinates by this process.
Perfect, thank you so much.
Thank you for the question.
Yeah, so so making this a little bit more mathematical.
We're going to start with samples from a data distribution Q of X zero.
So Q of X zero might for instance be like the distribution over natural images so it might be many many many examples of images.
And for every forward diffusion step, we are going to decay the slide sample slightly towards the origin and add a small amount of Gaussian noise.
And this this corresponds to diffusion in a quadratic well or harmonic well. And if you run this for enough steps, then at the end we're going to end up with an identity covariance Gaussian distribution centered at at the origin.
So this is going to be our forward diffusion process, which is going to take your sample X zero and destroy all destruction your sample X zero until by X capital T, you just have like a random noise vector.
And here once again illustrating this we're going to start with a whole bunch of points. And here you've seen a one day example and like a three million D example and here's like a 2D example.
Here we're taking a bunch of points that originally have some like structure and we're mixing diffusing them until they have no structure left.
Now for the reverse process, we're going to start at the identity covariance Gaussian.
And because we know that the reverse process is the same functional form as the board process.
We know that the reverse distribution of trajectories can match the forward distribution. If we also make it a sequence of small Gaussians.
And so here we have to do is we have to learn the mean and the covariance of these Gaussians.
And so if we find the right functions f mu and sigma and you make our step size small enough.
Then then after running like big T steps of the reverse diffusion process will end up back at our data distribution.
F mu and sigma here are going to be like super complicated functions. These are these are like the outputs of like state of the art neural networks.
But what's nice about this is we've like transformed the problem of building a density model into the problem of learning functions for the mean and the covariance of a sequence of Gaussians.
You can see in a second that this is basically going to be a supervised regression problem.
You can see this this illustrated. So you start with a noise sample and your general process is going to like run a diffusion process which which turns that noise sample into into samples of the data.
Here's just illustrating the same thing with like a cartoon panel.
Ah, the well that we ended up at I called it a quadratic well. That's that's to respond to a to a question in the chat.
Or or in physics sometimes they call it a harmonic well.
So basically if you run if you run diffusion diffusion and energy landscape, which is a quadratic, then then the particles rather than just like drifting away to infinity will like will like, you know, diffuse and drift, but they'll kind of stay roughly around the origin because the quadratic energy landscape likes
pulse them back in.
Okay, so this is going to be the mathematical high water part our watermark probably.
So how do we train these things. We're going to do it using using a variational bound that's essentially identical to that in in hierarchical days.
So the probability that the generative model assigns to a data point can be found by integrating over all trajectories that end at that data point.
This integral is intractable to compute, but we can borrow a technique called called an important sampling to to
multiply and divide by the probability of the four diffusion trajectory, which which is Q of x one the capital T given X zero
P X zero is now an expectation over the ratio of the four in reverse trajectory probabilities averaged over for trajectories.
We want to train our model by maximizing the log likelihood of the data under the model.
And this this corresponds to taking the average over the data distribution Q X zero.
This up after the data distribution Q X zero of the log of P X zero and here I just substituted in this form up here into the log of P X zero.
Intervals inside logs are pain in the ass.
So we use Jensen's inequality to lower bound the log likelihood and and bring the integral outside the log.
If the forward and reverse distributions over trajectories exactly overlap.
So if the P and Q distributions describe exactly the same trajectory, then distribution of trajectories in this lower bound becomes becomes type.
This everything we've just done is also equivalent to writing down the variational bound for like a very, very, very deep variational encoder.
We're each time step here corresponds to a layer of the variational encoder.
And and where the inference distribution Q is fixed and we're only learning the general distribution P.
Yeah, Q is the the, let me go back a second.
Q is the forward diffusion process Q is the distribution over over X at every time step that starts from your data and injects a little bit of Gaussian noise at every time step until until you get to the model.
I'm sorry until you get to the prior until you get to like the isotropic Gaussian.
Okay, where worry.
So, if we do a little bit more algebra on this.
You can rearrange this into a some over kale divergences between the, the posterior from the forward trajectory, which is that first term inside the kale.
And the reverse trajectory, which is that second term inside inside the kale.
And this is just a sum over this across across every time step. And the beautiful thing about this is that both of these distributions are Gaussian.
The second one is Gaussian because like the entire forward diffusion process conditioned on the data sample is Gaussian. And so this is just a conditional distribution of that big joint Gaussian distribution, which is also a Gaussian.
And the second one is Gaussian, because we know it has the same functional form, the reverse process of the same functional form and supported process. And just as reminder, this is the functional form of the reverse diffusion process.
So we can write down our training objective. And our training objective is to minimize an expectation over training data and over time steps of this kale divergence between the forward posterior and reverse distribution for a single for a single step.
And the kale divergence between two oceans has a super simple functional form, which basically just reduces to to regression.
So, so we've transformed our like unstructured unsupervised learning problem into into a supervised regression problem. And, and we know how to, we know how to solve those.
So this is the hardest part in the whole talk. So I'm going to pause here for like, like 15 seconds.
Could you give a short refresher on the kale distance.
The kale distance between two distributions is a information theoretic measurement of how similar the two distributions are to each other.
It has some some nice properties.
One of those properties is
So one interpretation of the kale between like Q and P is it tells you how many bits it would, how many, how inefficient, how many bits you would lose if you tried to describe distribution P, but thought it was distribution Q.
So it tells you like by how many bits your model is like an efficient inefficient.
It also is like closely connected to log likelihood in that if you take the kale divergence between the data distribution, the model distribution. This is equal to
a constant minus the log likelihood of the model.
But I think just in general you should think of KL as being a measure of distance between two probability distributions.
So you mentioned the, I guess, beautiful property of the kale distance of two Gaussians can simplify the problem. So what if, you know, there'll be let's say a different type of noise, then I guess it wouldn't necessarily simplify.
Yeah, yeah, if you had if you had different types of noise, you would, depending on type of noise you very likely would not be able to just like analytically write down the form, you would still be able to optimize it.
You would just have to use
the thing that you can do analytically here is we can marginalize over over X of t minus one
in in this expression and this this I haven't I haven't written down the order of this but but the reason that the calibrating two Gaussians is really nice is because you've been just like marginalized out the X t minus one and that gives you a much lower variance estimate
of the loss in the radium. If you use a different form for the noise, then you would probably have to sample X of t minus one, and that would probably be a much higher variance estimate for for your learning signal, but but you could probably
still do it.
And something like heavy tail noise might be might be really interesting.
There's a question for why we do KLQP instead of KLPQ.
So,
in general, we tend to do KL from the data to the model.
And the reason for that is probably because of the connection between KL divergence and log likelihood.
What we're often interested in is the log probability of the data points under model, and that means you have to take an expectation over over the data. So you want to like average over your training data of the difference between the two.
I think also, it can be very difficult to compute the other way around, because we don't know what the log like we're trying to fit the log probability of the training data.
And if you flip the KL around, then you have terms that look like samples from the model of the log of the data distribution, and we don't know how to evaluate those in general, which is another reason that we usually go from from Q to P using our formulation
here.
Yeah, so this optimization process, or at least the specific loss that we get depends on us having defined the noise like we chose the noise right like we we chose that the noise is is a bunch of like small Gaussian
perturbations. And, and that's what makes the specific form possible is if you use this for your noise than the entire forward trajectory. So like Q of X of one to X capital T given X zero is just one big joint Gaussian, and a lot of things become easier once once your entire forward
trajectory is one big joint Gaussian.
Cool. Alright, so now I'm going to connect this to stochastic differential equations.
So I just presented this in in discrete time.
But if we take the step sizes to be smaller and smaller and smaller, then we can turn this discrete diffusion process into a limiting stochastic differential equation.
It turns out to be extremely useful and to have some some very nice properties as as before, we're going to gradually mix noise into our data distribution until it turns into Gaussian.
And, and as I just said, this is the continuous time limit of the discrete diffusion process I saw the moment ago.
So here our data distribution is P sub zero. This is a slight change in notation, not a big one.
And P sub T is the intermediate distribution from running this stochastic process for a time interval T, and then P capital T is the final final distribution which should look like just noise.
So and little T here is between zero and big T. And so an SDE is a generalization of ordinary differential equations.
And so we can write it down like this. And here the green term is what you would normally have in an ODE.
And it governs the deterministic properties of the stochastic process select the drift.
And the red term is the noise that the red term controls like the stochastic fluctuations of the process.
So here you should think of DW as being infinitesimal Gaussian noise or like Brownian motion.
So we've now replaced the forward process with its continuous time limit, which is stochastic differential equation.
And we can do the same thing with the reverse process.
One really surprising aspect of stochastic differential equations is that given their equation forward of time and given the marginal distribution PT at time T,
the time reversal of the SDE has a very simple analytic form.
In reverse SDE, here DT is going to be an infinitesimal negative time step.
And DT is going to be an infinitesimal negative time step.
And DW is still Brownian motion or DW is still Brownian motion or like little Gaussian perturbations.
And if we know the gradient of log PFT with respect to X, then that's all the information we need to like define the reverse SDE, the time reversal of the SDE.
And here the gradient of log PFT is the quantity which is often known as the score function.
And so we can train an approximation S of theta to this score function.
And the way in which you train this is using the continuous time limit of the same variational down to the log likelihood I showed like in the previous section.
So basically you can train this thing exactly the same way that you train the discrete time version.
There's also connection to denoising score matching, but I don't think it really matters here.
You can train this using the same way.
So okay, so this is just the continuous time limit of the discrete time diffusion for that version before.
And maybe the thing that's really neat about it is we can now link these like drift terms that we were estimating to this thing called a score function,
which is like a simple and known property of the distribution PFT.
Okay, and so now we've defined the model two different ways.
And we've talked about how to train the model.
So let's talk about how to sample.
And then let's look at some some pretty samples.
So after training our model, I mean the sweet timer score base, I'm going to show you a score base here.
So score base, we generate samples by, by just numerically integrating the reverse SD.
So, so mind you, we've approximated grading of log PFT with our function s.
And you can use any off the shelf SD integrator to solve this.
The simplest of these is, is called the Euler-Mariama solver.
And this is just the, the discrete time discretization of this SD, which actually maps us back to the discrete time diffusion process,
where at every, at every time step, you like change X, you change your sample by that looks like this term times a finite changing T.
And then you add a little noise with variance proportional to delta T.
And you just run this over and over and over again, until you get back a sample.
So this is, this is the, maybe the most naive discretization of the SD.
Okay.
If you maybe went at the sample generation procedure the right way, then, then we're actually training and generating samples with a neural network, which is like thousands of layers deep, where each layer is like a time step into the diffusion process.
And, and so this can be interpreted as like an extraordinarily deep general model.
If you squint that at a slightly different length, then we're proposing a general model, which has like thousands of times the compute cost of most general models, which is maybe not quite as exciting as saying thousands of layers deep.
But, but it will turn out there are ways to make, to make the sampling process more efficient.
And I'm going to show you one of them in the talk.
Okay, so, so what can you do with this thing?
Well, here are some example samples.
These are samples from a diffusion model that we built trained on celebe HQ.
These are 1024 by 1024 images.
I don't know how high resolution they are after after some to me, these are like in this English full from from real human beings.
So, so, so we've like crossed over the uncanny valley.
So, numerically, this class of models currently beats autoregressive models.
In terms of log likelihood where autoregressive models were the winners. This is not my work. This is a paper of dirt King was in Tim Solomon's.
They also began in terms of like at by the inception score on some data sets. So, for instance, image that five full by five fall, again, not my work.
So these things seem to be remarkably good generative models of images.
They also enable you to do some cool things that you can't do with with other other techniques.
Let me actually just to time this.
Should I expect to end sharply attend or should I expect to take them extra like.
Yeah, take your time.
You know, as much as you would like because typically we end this course, even after you are done with your lecture, we may stay a little more and chat about things.
Okay, cool. I will not take forever, but I will I will not try to do to the last last slides in four minutes as well.
I'm actually it's probably really good time for me to pause for a second and see if there are any questions. So,
Okay, I'm going to keep on going. I'm going to tell you about these stuff.
One really cool thing is that any SD can be transformed into a corresponding ordinary differential equations non stochastic differential equation.
Without changing the marginal distributions pt of x, that is, there is an ODE, which has the same distribution over x at all times t.
And so this corresponding ODE would allow us to sample from the same distribution starting from the same prior distribution.
But by solving ODE instead of an SD, this is this is here is what the ODE looks like.
We show the SDH trajectories in red, and the ODE trajectories in, in white, and they both the SD and the ODE are starting from the same points.
And you can see that the SD is a stochastic trajectory that converts the starting distribution final distribution easy the ODE.
Similarly, trace has the same marginal distribution at every time point, so it starts from the same distribution, and then it ends up the same distribution, but it does this in a deterministic way.
Given the SDE, the corresponding ODE, this is just the general general relationship between SDEs and ODE's.
Given the SDE, the corresponding ODE, like once again only depends on the score function of pt, for which we already learned, we've already learned the estimator for the score functions.
So, so this is just S of, S of theta. So, if we want to generate samples, we can generate samples by integrating this ODE instead of by integrating the SDE.
This kind of blew my, so Yang is the one who realized you could do this, and this kind of completely blew my mind when he shared that we could do this.
So, so I hope, I hope at least some fraction of you are similarly like scandalized that you can turn SDEs and ODE's like this.
So, the question is, are there benefits to modeling with an SDE if there is an ODE equivalent, and the, the two parts to, to the answer.
Part number one is the SDE formulation is what allows us to train it. So, so we have to at least like conceptually go through, through SDE space in order to train it.
Part number two is that we're training this function S theta to match the score function, but in practice, this function S of theta probably does not correspond to the gradient of any well defined like log probability distribution.
Like if we were to train S of theta perfectly, then we would have S of theta is equal to like gradient of X of log P of t, but in actuality S of theta, it's just like a vector.
And it probably is not a vector that actually corresponds to the gradient of the log probability.
And, and because of that inconsistency in the definition of S of theta, you actually get slightly different distributions if you integrate the ODE and integrate the SDE.
And visually, if you integrate the SDE, the samples tend to look just a tiny bit better.
But, but I think we don't, we don't fully understand why, but the, the reason distributions are a little bit different is because we're violating this assumption that like S of theta is actually the, the gradient of, of the log marginal density.
Okay, so we have this ODE. If you've heard of neural ODE, you can think of this as being like a specific example of a neural ODE, because like S of theta is a super complicated neural network.
What's really cool is once you have an ODE, you can use just like off the shelf ODE solvers to, to generate samples and like ODE solvers are like really remarkably good.
I didn't, I didn't realize quite how good they were in that they can like just off the shelf ones can just like generate like a few million dimensional like samples from a super high dimensional ODE.
So here, for instance, is the samples you get from running the an adaptive ODE sampler with a different allowed number of samples.
And you can see that after maybe like 86 this samples from the ODE solvers, so allowing the ODE solver to evaluate the, the ODE equation at like 86 time points.
You get what's a pretty high quality image, whereas it takes like thousands for, for the SDE.
The other thing you can do with ODE is you can compute an exact log probability for four data points, which means that you can get exactly like this.
We can, I can show you a table of performance.
Our numbers are bold. This table is now like almost a year old because our paper is now almost a year old.
But, but take home message is this class of techniques works like surprising the well both in terms of log likelihood and in terms of measures of perceptual performance like like FID.
And I want to tell you about one more thing before, before I break, but maybe this is another good place to pause for a second.
If there are any questions about the ODE.
Okay, cool. Let me tell you about one more thing, which may actually be one of the most relevant things if you want to use this class of models for, for like creative applications, which is that there is a very well motivated way to control generation under under this class of models.
So, just to back up a second.
At training time, we return our data sample X zero by running our SDE and we get a noise sample.
We want to perform control generation at test time.
So we want to be given, we're going to be given a control signal, which I'm going to know is why here.
So, for instance, why might be a class label.
And so the forward diffusion process will then perturb a conditional data sample X zero given why to complete noise.
And by reversing this procedure.
We should be able to start from isotropic Gaussian noise ball and obtain a sample X zero given why the reverse time procedure condition and why can be given by the following conditional reverse time SDE.
So here, all we've done is we've just replaced the score function of PT with the score function of PT of X, given why.
So this is nice.
But at first sight, this seems like you have to train a whole bunch of like an entirely new model, because the conditional distribution is function of T is unknown.
But what we can do is we can apply basis rule to this.
So the first term is just the unconditional score function.
And is what we like already spent the rest of the talk talking about how to train exactly the same as what we were training before.
The second term can be trained completely separately.
From the score base model, or even sometimes can just be like written down in in close form using using the main knowledge.
And so, and so the product of these two terms plus the constant is equal to to the log P of T of X given why.
And I'm sorry, because these are logs, I should have said that some of these two terms.
This is just this. This is just base rule applied to PT of X given why.
And so, this is a particularly cool capability, because it's not something you can do at test time for like gams or VES or autoregressive models or any of these.
Here we can train a ginormous like unsupervised model images, and then we can train a little classifier like PT of Y given X later.
And we can use that little classifier to like guide our image generation.
So one example of this is here we have a here we're making PT we're making why the actual class.
And so we can use this to do like post hoc sampling of CFR 10 images that come from the class bird on the left or come from the class deer on the right.
You can also do this for in painting.
So here, why is the part of the image that you know, and you want to generate the entire image like conditioned on the part of the image that you actually know.
And so here are the first column is the true image, the ground truth image.
The second column, we've thrown away all but the part of the image that you can actually see.
So you've thrown away all we've thrown away the surround or the center.
And then in the remaining columns, we're showing independent samples of in painting all the missing content in in these images.
And you can see that an off the shelf diffusion model not trained to do in painting can can still do a good job in painting.
You can also see that there's like diversity in the images that it generates.
It doesn't generate same bedroom over and over and over again it generates like a sequence of plausible in paintings of missing information.
We can do this for colorization.
So we can take an image we can make grayscale and then we can infer infer the colors.
Cool.
This also let me just actually jump way back to being talking again.
This is also the same technique essentially that's used to generate these these art examples.
So they're rather than using some pt of y given X as a guiding signal.
They're using the output of like the clip classifier as the guiding signal and they're like multiply by some scalar.
But but they are guiding the diffusion generation in the same way as as I just showed.
And then using it to create novel artistic creations.
Cool. Okay, so to summarize.
I have shown you a general model based on diffusion processes.
We first corrupt data to a known noise distribution using diffusion.
And then we learn the time reversal of this diffusion process in either discrete or continuous time.
And we can then generate samples by drawing a random noise vector and simulating the reverse diffusion process.
There are some advantages of our framework.
First, image quality is super duper high.
Second, there's equivalence to neural OVs or flow models, which allows us to do things like like exact likelihood computation.
I didn't get a chance to talk about this, but but I actually talked about it very briefly before before the talk proper, but
our encoding is also uniquely identifiable, meaning that every well trained model will have identical latent codes for identical input data points.
This is either a positive or negative depending on how you look at it, but it is a unique property of this class of models.
And finally, we can do controllable generation without without retraining the model.
Examples like include like class conditional generation.
Including some of LA clip guided diffusion measure at the beginning.
Yeah.
Okay, that's what I got. Thank you so much for listening.
Thank you so much. This was awesome.
Really helpful.
Seems that this controllable generation is really cool because once you have the sort of probability of X and then you can.
So that is sort of task agnostic in a way and then whatever task you want, learn it and then use that sort of backbone that you have already trained will learn from the data.
This is, this is really cool.
And then I think that this fact that you can identify encoding or do the reverse process is also very cool because there is a great deal of how to, for instance, take my image and then map it to the latent space of again, so that I can modify it.
Yeah.
People have been trying to train inverters.
They are getting better and better, but it seems that in this case, the inverter comes for free.
Yeah, yeah.
That's very cool. So are there questions?
I think more on a high level. I mean, what, I guess, having a physics background clearly probably helped come with an idea that is, let's say, kind of, I mean, yeah, based on physical intuition, but it's so different from I guess the GAN architecture.
So like, in terms of more like human creativity, like how do we have to look more into the nature to find more inspiration for those, maybe even other models that or other paradigms or what is your suggestion for people who are interested in this field?
Yeah, you mean like in machine learning, how do you come up with creative different ideas?
Yeah.
Yeah, I mean, so definitely, I mean, I'm biased on my own background, so my answer is going to be be like me, which is not really a good answer. But no, one thing I do think is really actually good, though, is I think it's good to have, I think it's good to have a background, which is not the straight machine learning background.
I think having exposure to ideas and having a novel perspective like definitely helps.
I think probably even more important than that is like talking with and collaborating with people with different ideas than you. Like whatever your background is, if you can like work on a team and work closely and talk closely with people that have a very different background, then you're going to come up with ideas that no one else is going to come up with.
And so I think, yeah.
Very cool. I think there are questions on the chat.
Yeah, I just say, yeah, I think I just saw that as well.
Okay, so one question is like just out of curiosity, what happens if the initial input X zero is out of distribution. And so before the fusion process, the process that takes X zero and turns it in the noise is a is a fixed process.
So it will take an action. Maybe let me open up for a second.
So, um,
Yeah, so just to be the
Good thing.
Okay, so the forward process is is a fixed process. So any sample X zero on the left here is going to get turned into a sample from an unimole calcium.
And I should I should one subtle to cure which is pretty important is that every sample on the left gets mapped to the entire distribution on the right.
So if you were to start from the same same sample on the left over and over and over again and run the diffusion process again, like every time you ran the diffusion process, you would get a different trajectory, and you would get a different sample on the right.
So the forward process maps every single like possible input sample to the entire like PT like like isotropic calcium prior sample.
And the reverse is also true. If you start with a sample on the right and you run the SD then you will get a sample from your model of the distribution.
But if you run if you were to start from the same sample on the right over and over and over again. Every time you did that you get a different sample from your distribution.
And so every sample from the prior is actually also mapped to the entire distribution.
And so it's not like there, unless you're using OD formalism, there's not like the one to one correspondence between the image space and the latent space.
And so and so you would turn X zero into the same sample from the same latent distribution and then when you came back to the image, you wouldn't know anything X zero anymore.
There's another question here. Is it possible to work with multiple classes within one diffusion probabilistic model.
And I mean the answer is, so you can train your diffusion model on any distribution that you want to train on, I guess, so so I think the answer is yes, I think, I think the more precise answer would depend on exactly what you wanted to do.
But, but there's no reason that multiple classes should be harder than one class.
Okay, great.
Maybe I can stop there recording here and if there are more questions, you can ask.
