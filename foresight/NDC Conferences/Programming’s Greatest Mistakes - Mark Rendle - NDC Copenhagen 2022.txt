It's wonderful to be here. Has everyone had a fantastic week? Yes. Excellent. Glad to
hear it. I would just like before I start to say thank you to Jacob and Kirstie and Steiner
and Henriette and all the volunteers, the people in the green t-shirts who've been
sort of marshalling the rooms and gathering the feedback and everything. There's a lot of work
that goes into these conferences. So can we have a round of applause for all the people who make
this happen? So I'm going to finish things off. You're all tired. It's been a long week. You've
got loads of information to process. And so I'm just going to basically share some very silly
stuff. There may accidentally be some lessons in there that you can learn. I apologize.
But this is all about some mistakes and the kind of mistakes that are made by software
developers and engineers. Before I start content warning, there is going to be swearing. I am going
to say, fuck, quite a lot just in the next segment, but it is relevant to the plot. So that
is justified. What I am not going to be talking about in this talk, because it's light hearted,
it's designed to make you laugh, I'm not going to be talking about any situations where software
errors have actually killed people. But software errors have killed people. So yeah, but there's
none of that in here. This is all just, it basically cost a lot of money for the most part
or cost me my job in what some cases. So yeah. And this is me. This was one of my biggest mistakes.
I worked for a software company and this was when I was in my 20s. I was young. I was arrogant. I
thought I was like a 10x developer and hot shit and all that sort of stuff. And I worked at this
company and also in my defense before we get into this, I was already spiraling into what would
eventually become a full on nervous breakdown. So I wasn't necessarily thinking straight.
Our company, we sold event management software and membership software and it was very complicated
and you could build these huge complicated queries across the database and you could save
those queries into a file so you could load them again the next day. And those files had a med
extension. I can't even remember what it stood for. But we called them med files. And we released
an update to the software and it corrupted. When you saved the med file, it corrupted it. And so
the support people came to me and they said, and I quote, Mark, the med files are fucked.
Can you write something to unfuck the med files? And so I went into Visual Studio and I did file
new project. And it said, what's the project name? And I went, oh, unfuck. And so I created this
little Windows application, Windows forms application and it displayed a dialog box
and it said, choose file to unfuck. And you clicked a button and it went off and you
browsed and you chose your file and then it had a button that said unfuck now.
And then it ran it through its thing. It did its thing. And then it displayed a message box
that said, med file successfully unfucked. Close. And it worked. Well, I thought it worked. But
you know, support had a bunch of support or also QA. It was that kind of company.
And so I gave the application which was called unfuck.exe to the support person who had reported
this to me and I went, can you test this out and make sure it works and then we can clean it up
and send it to the customer. I don't know if he tested it. I can't imagine that he did
because then without coming back to me, he shipped it to the customer.
And they ran it. And yeah, it doesn't look particularly. These are the kinds of customers
who are paying you half a million pounds a year on a sort of support subscription basis.
And we send them a file called unfuck.exe that says your file has been unfucked.
And at the time, I was in such a bad place mentally. I blamed the support guy for this
because I obviously got hauled across the coals for this. And I blamed the support guy for shipping
the thing. Whereas obviously it was actually my fault. I should never have created a program called
unfuck.exe. That was just not a good idea. It's okay to swear in comments as long as you're never
going to open source things, but don't actually put unfuck. On a slightly related note, by the way,
when I, very early in my career, did anyone, any Windows 3.1 veterans in the room? So Windows 3.1,
it was a file called win.com. And every message and every piece of text that could be displayed in
Windows was embedded in win.com just as text. And if you used a hex editor, you could open it up.
Interesting trivia. The phrase general protection fault has one more character than the phrase
Mongolian clusterfuck. And so if you put two spaces in the middle, you can edit someone's
win.com file and then you can run away. And then the next time that happens, they will get a message
box that says a Mongolian clusterfuck has occurred, which has caused your application to terminate.
One of the worst things about Windows 11 is you can't do that anymore.
Okay, let's talk about Y2K. Everyone knows about Y2K. That was probably one of the
biggest mistakes in software. But it wasn't that we let that happen in the first place. It was
really to do with how slow we were in fixing it. Because what you have to understand about the people
who wrote the code that then caused the Y2K problem was that this is what data was stored on
at the time, punch cards. So every column on there is basically a byte of information. And so those
extra two digits on the year would have been an extra two columns on there. Multiply that by
a million bank customers and a hundred million transactions a day. And those extra two columns
add up to a lot of extra punch cards and memory in those days. This was what memory looked like
in those days. This isn't under a microscope. This is just a photograph. That is core memory.
And it's lots of magnetic poles. And through each pole, two pieces of wire have been passed.
These were made by usually women with microscopes and needles. Memory in the 1950s was knitted.
And core memory cost about a dollar a bit. So a byte of memory would cost you eight dollars.
You think that means a kilobyte of memory would cost you eight thousand dollars.
So memory was really at a premium. And this is also incidentally why Unix still says core dump
to this day. It's because it was the core memory that was being dumped. And of course in those days
it was just a kilobyte. And it was quite easy to read through. So early programming languages like
COBOL, they didn't think in bytes. They thought in bits. And so this is the definition for a date
variable. And we say this is a string type variable. But the nine means it's a number character. And
so it can only be naught to nine or some of the other like hyphen and comma and dot and things
like that. So that would fit in six bits instead of eight bits, which meant you saved a couple of
dollars every time you were putting one of these things into memory. So it was quite reasonable
to shorten the date and only use the sort of decade and the year. This is, I've forgotten his name,
Bob Beamer. And Bob Beamer in 1954 was the guy going, I realize we have to do this, but as soon
as memory becomes cheaper, we really should change that to a pick eight, pick nine eight, because
this is going to cause a problem. 1954, he said that. In 1964, he started saying it with a little
bit more emphasis. In 1974, he started shouting about it. In 1984, he was giving talks at conferences
going, guys, we really, really need to fix this. In 1994, after Bob Beamer had retired, we actually
started work on fixing it. And by that time, all this software had carried on you. So you wrote
new bits of this software and you carried on using that. And so the effort to stop the Y2K bug
from happening was ridiculous. And it took an awful lot of people, an awful lot of time. But
we did it. And then the year 2000 came. And there were very few big computer crashes and no aeroplanes
fell out of the sky and all this other stuff. And the whole of the rest of the world went, well,
that Y2K thing was a lot of nonsense, wasn't it? What a fuss. And people like me who'd rewritten
COBOL systems in Informix 4GL to fix this went, no, you're welcome. Yeah, it's like, yeah, no,
it's thanks to me, your hospital still works. But no, Bob Beamer died in 2004. So we did actually
get to see the problem being fixed. But the estimated cost of fixing the Y2K bug goes from
some people say $300 million, some people say $800, no, $300 billion. Some people say $800
billion. So let's put it somewhere in the middle, we'll say it cost half a trillion dollars to fix
the Y2K bug. And you'd think we'd learn from that and we wouldn't set ourselves up for any other
Y2K bugs, particularly if you're like one of the biggest software engineering companies in the
world, you wouldn't put something into, say, your flagship email server that was going to break at a
no, no, no, no, Microsoft, this happened this year. A thing that Microsoft was storing in an
integer ticked over. I don't know what exactly what the number was. But suddenly we couldn't
convert this number to a long, because it was too big, and exchange servers all over the world,
including Office 365 just choked and died. And Microsoft had to hurriedly roll out a fix for
that. In the year 2038, there's the apocalypse is coming. Unix still stores the system date and
time as the number of seconds since January the 1st, 1970, in a signed 32-bit integer.
And that's going to crash in 2038. And you'd think, well, that's an easy fix. Change it to a 64-bit
integer. But no, they've patched it with an extra bit. So now they've got a 33-bit integer, which
kicks the can down the road until like the year 42 something. But you know, Linux going to Linux.
My favorite one of these, though, is the dog 38 bug that the Kennel Club of the United States of
America have. So the Kennel Club, your dogs are categorized by their pedigree breed. And then your
dog has a name. And it's one of those big, long show names. Like I have a pedigree dog and her,
I can't remember her show name. It's got something, sugar, cookie, something, something.
And so if they already have a dog with that name, which is obviously, you know, big country,
300 million people, lots of dogs, it happens. And so they number them. And so, yeah, one,
two, three, four, five, six, blah, blah, 37. And if you go to had a dog and there are already 37
dogs of that breed with that name, and so this is dog number 38, it crashes because it can't
write the number into the database. See if you can anyone guess how they're writing the number
into the database that would cause 37 and all the numbers up to 37 to be okay. And 38 suddenly
crashes. Roman numerals, they store the Roman numerals in a char six field. And every number up
to 38. So 38 is XXXV37, sorry, is XXXVII. All the numbers before that fit in fine,
but 38 is XXXVII. And this one, I really don't understand, it's going to the database,
change it to a char eight, or God forbid, an integer. And just format. Someone just went,
I can't write the algorithm to format a number as Roman numerals. Let's just store it as Roman
numerals. So yeah, that's fun. I would like to thank Stand Up Maths on YouTube, great channel,
and I found that one on there as I was writing this talk. So that was interesting.
A lot of this actually comes down to one of our biggest mistakes in programming, which is just
enterprise programming generally, enterprise software. It's just, you know, the processes and
the procedures and the waterfall and the project planning five years in advance and all this sort
of stuff. And it causes problems. And you can see the kinds of problems that it causes. So yes,
enterprise, a business plan or project, especially one that is difficult or may fail or lose money.
And everything in enterprise development is based around this. It's nothing to do with building
good software. It's nothing to do with working efficiently. It's all to do with covering your
ass so that when the thing goes wrong at the end of the day, you still get paid because you can
prove it was somebody else's fault, which is why you get agile development posters that look like
this. This is the scaled agile framework for enterprise. This is the simplified version.
There are worse versions than this. And you get things like this, autoscrum 1.1,
which is Accentures. This is still claiming to be agile. This is Accentures agile framework
that they use. And somewhere in there, we have a program backlog. We have a sprint right down
there. There's a daily scrum. And I think they've allocated some time for people to write code.
But I'm not sure.
People have probably seen this. This is Deloitte's agile landscape, version 3. The terrifying thing
with this is that this and this are just single dots on this. And we wonder why so many enterprise
projects fail. Quick story about enterprise. I was hired by one of the national agencies,
the Quangos, as we call them, quasi-autonomous non-governmental agency organization in the UK.
They had an API endpoint, only had one thing, and it just returned a list of the amount of
energy that was being used in the UK right at that second. And that is very useful information.
If you're investing in energy futures, you want to watch those patterns. And so people just kept
hitting it and hitting it and hitting it. It didn't have IP throttling. It didn't have any
accounts or anything like that. It was an anonymous endpoint and you hit it. And it did a
quite complicated database query against an Oracle database. And did people put a thread
dot sleep 10 or a task dot delay 10 in between? No, no, no, no. No, they just get it, hit it again,
hit it again. They had this running on one 32-bit server. It was written in .NET 2.0. I had been
brought in to look at this in 2014. And yeah, it was 32-bit .NET, so it didn't have much memory.
The Oracle database was also 32-bit running on an old server. The servers had been there since
like 2005, so they were well past their death time. And yeah, they said, can you take a look at this
code and tell me what's wrong with it and tell us how to fix it? And I went, I could just fix it.
And they went, no, no, no, no. Don't fix it. We give you two weeks to write a 20-page document
telling us how to fix it. And so I took it back to the office and I loaded it into Visual Studio
and Resharper actually started crying and then uninstalled itself and went, no, you're on your own.
Just don't. And basically, I don't do planning. I don't do documentation. I don't do that sort
of thing. I'm getting better at it now as I get older and more responsible. But back in those days,
I was kind of like, I'll fix it and then I'll just write down what I did to fix it. And actually,
the main thing I did to fix it was where they said var connection equals Oracle database connection,
new Oracle DB connection, I just added using because they weren't disposing their database
connections. So it crashed every 20 minutes because they exhausted memory and the app pool had to
recycle. And so I managed to write 20 pages on why using statements are important,
sent it back to them, didn't hear anything from them for nine months, and then they came back to me
and they said, can you come in for a meeting to discuss your findings? And I'm kind of like,
you haven't done it yet? So I go up and my boss goes up and he's charging them £2,000 from me
to be there for the day. Lord knows what he charged for him to be there for the day. I'm
guessing about £5,000. We get there. There's 10 IBM consultants sitting around this table. And I
know that IBM consultants are about £10,000 a day. So this is a £100,000 meeting that's happening
right here. And I go, look, I can give you the code. I've brought it on a USB. If you want the
fixed version of the code, it's here. And I would recommend running it on in 64-bit on a server
that isn't 10 years old, but this will probably still work even if you don't do that. And they
went, yes, we can't just go in willy-nilly and fix it and put it on new servers. This is a critical
system. Yes, it's a critical system that crashes every 20 minutes and is costing you an absolute
fortune. Just buy a new server. Just put it on a new server and it will be better. Give it 64 bits
and give it like 16 gigs of RAM and it will run smoother. Well, we can't just, you know, that has
to go through a whole process. And I'm like, this meeting is costing £100,000. And for £100,000,
you could buy a data center and run this thing on a server farm and it would be fine. And my boss
went, no, why don't you go outside and get some fresh air? And so I go out and I wait by his car
and he's kind of like, oh, I'm in so much trouble. I'm going to get sacked again. And I'm smoking a
cigarette because I smoked at the time. And he comes out and I'm like, I'm really, really, really
and he went, no, don't worry about it. I don't want to fuck off. We don't need that shit. He said,
okay, this was a fun one. So problems in software, they're easy to fix. So you ship some software
that doesn't work and they are, it doesn't work. And you go, here's a new version of the software.
Intel managed to get a software bug into their processor. So the Pentium chip was the first
Intel processor that actually had a floating point unit built into it. Before that, we had the 486
and there was a 487 co-processor that did floating point, but Intel had combined it into the actual
chip itself. And the Pentium floating point unit accelerated floating point operations. There you
go. That's what it looked like. So what is 4,195,835 divided by 3,145,727? It's one
.33382. Except according to the Intel Pentium's floating point accelerator, it's 1.33374.
And there were a few instances where this would go wrong and people noticed and Intel went, okay,
if you can prove that you are actually affected by this bug, we will just send you a new Intel
Pentium processor where it is fixed. And then so many people came up with these torturous,
this is why it's not working for me, which were largely to do with Microsoft Excel.
And so Intel ended up going, fine, just if you've bought a Pentium, we'll send you another Pentium.
And that ended up costing Intel $475 million to fix. I'm not sure anything like it's happened
since I would imagine they probably run every possible floating point calculation
as part of their unit tests. Null. This is quite famous. Null. And we actually have a fairly easy
value to assign to Null because Tony Haw, who was the guy who invented Null, has called it his
billion dollar mistake. So Tony Haw, he's a British computer scientist, hugely respected,
he's like a knight or a KBE or something of the British Empire. And he was working on Algold W.
And Algold W was the first programming language that introduced the concept of records, what we
think of as like classes or structs or whatever. And so you had a record that was a person which
had these things in here. And so when you've got records, you need references to where that
record is held because now it's a collection of data stored on a heap. And so you can see here,
person has a reference to another person, which is their father, mother, youngest offspring or
elder sibling. And so where you've got references, what do you do if there is no father, mother,
youngest offspring or elder sibling? And so Tony Haw went, well, we'll just call that Null.
And so we say if P equals Null, then M. Otherwise, if M equals Null, then P. Otherwise,
do something with P and M and we'll return that back. And at the time, that probably seemed
perfectly reasonable. But ever since then, hands up who has not ever had a Null reference exception
in .NET or Java or any language they've ever programmed in or JavaScript undefined does not
have a method index of or whatever it is JavaScript says. So yes, and Tony Haw calls that is
billion dollar mistake and will quite happily tell you all about it. There's a video on YouTube
of him doing a one hour talk at a conference about how Null happened and why it was a bad idea.
Hartford Center. Sometimes software problems actually cause other problems in the real world.
So the Hartford Center was built in the 1970s. It was one of the first buildings that was designed
using a software CAD package, a computer aided design package. And back in those days, there
was no auto CAD. There weren't these high level things. A CAD package, the engineer and architect
using it would actually program in the algorithms, the formulas for the stresses on various beams
and all this sort of thing. And they built the Hartford Center and it was fine. But the Hartford
Center, I think it's in Connecticut or somewhere in the United States, it snows. It snows a lot
and the Hartford Center was fine until one night it snowed a lot and this happened.
Fortunately, no one was in the building at the time. There had been a concert and everybody
had left the building about four hours before this actually happened. And the problem was that
they put in the calculations for the beams on how much the stresses on them were going to be.
But what they didn't account for is that the roof is slanted like this and you people in Scandinavia
you'll know what happens to snow when it lands on a roof. It kind of evenly distributes itself
like this and then it warms up a bit and it goes boom. And they hadn't accounted for the horizontal
tolerances on these beams. And so it did that and a beam sheared sideways and then that beam
sheared sideways and then the entire roof collapsed just because of one error in programming a CAD
package. That cost them 90 million dollars to put a new roof on the Hartford Center. That's not too
bad. This one's fun. Night capital. I like this one because night capital are a hedge fund and
they don't like hedge funds. Although if you work for a hedge fund and you need some consultancy,
I will happily come and consult for you and my rates are very reasonable by hedge fund standards.
Certainly compared to night capital. What you have to understand about hedge funds is the stock
market, the first stock market was created by the Dutch East India Company. They needed to raise money
to build ships to go to India to steal stuff and bring it back to Europe to sell it. And so the way
they did this was they said we'll sell shares in the expedition and then we go and we steal the
stuff and we bring it back here and then we sell it and then how you get your percentage of our
profits that we make from doing that. And then other people went that's a brilliant way to raise
money to start a company. I'm going to do that as well. And then 400 years later somehow that had
turned into highly optimized programs running in dark pools trading with each other at microsecond
levels skimming fractions of a fraction of a cent off the top of the transaction to try and
make rich people richer while the rest of us got poorer. And this is what night capital were doing.
And in 1996, this was all happening in these things called dark pools. So the hedge funds
and the investment banks and everything created their own sort of shadowy stock markets where
they could do this. And the New York stock exchange went we are missing out on so much
commission. We're going to create our own light pool. And so they did and they called it the
retail liquidity program. And so everybody had to scramble to get their algorithms and their
programs that were running in the dark pools to run on the New York stock exchanges retail
liquidity program. And so night capital basically copied and pasted a bunch of code around the
place and dragged in some modules and all this sort of stuff and threw it into this new retail
liquidity program with about two weeks notice. And it went in there and it started running.
And within four minutes, it had spent a billion dollars. And when they deployed it, it was running
on eight servers and the deployment rolled out, but it only worked on seven of the servers.
And the eighth server continued running this old code that was the buggy code. And so they went,
oh, no, it's spending too much money. A failsafe that was supposed to trigger wasn't working because
it came from a different system and the flag wasn't getting set and whatever was going on.
And they went, well, it must be that this new code has got a bug in it. So we'll roll it back.
And they said, copy the code from the eighth server onto the other seven servers, that'll fix it.
By 28 minutes past nine on the morning that this thing went live, their algorithm had spent seven
billion dollars. And night capital didn't have seven billion dollars. And the rule is you have to
settle within 48 hours. And so they had to essentially bail themselves out. So they sold
all their positions, this entire seven billion dollars worth of positions to Goldman Sachs
for $450 million. $440 million. So, yeah. And then the following year, they were acquired in a
hostile takeover by Goldman Sachs, who kind of went, yeah, you really shouldn't be allowed to do things.
That's fun. I like it when hedge funds lose money. How are we doing? Halfway through, good stuff.
So, bugs in space. Like it pigs in space from the Muppets, but bugs in space.
There have been lots of bugs in space and bugs in space are difficult because you can't sort of
attach, you can't go, how is this going to work in space? I know I'll go into space with my laptop
and set a break. You can't do that. Laptops don't do well in space for a start. So, yeah.
So just a few of these. Mariner 1. This was one of NASA's very first missions. And the computers
in those very, very basic. And so programming was taking mathematical formula and turning them
into machine code. I don't think there was even assembly language, really, for these guys. And
they would take the mathematical formula and literally go, okay, so that would be this and
this and this. And this is what Mariner 1 would have looked like if it had ever made it to space.
But it didn't. And it wasn't the programmer's fault. It was the mathematician's fault. He gave
the programmer a formula that had an R in it. And it should have been the R on the left with a hyphen
over the top of it. And what the hyphen means is smoothed over a period of time. So it's going to
spike up here and down here and down here. But what you want is kind of the average over the
previous 20 samples of whatever this is. But he just left out the hyphen. And so they used R.
And so if you've got a value where it's supposed to be zero and kind of plus one or minus one is
probably okay. Plus two minus two is probably okay. But plus eight is a very bad idea indeed.
And you're not smooth. So eight and then back down to zero and then minus eight and back up to zero.
It's probably okay. That's probably normal. But they thought what they were getting was the average
smoothing. And so when it came through as eight, the guy in mission control went bang and hit the
button that blew up the rocket on purpose. So yeah. If anyone was in Martin Thwaites'
talk on open telemetry or any talks about tracing or metrics or anything like that,
it's really important to make sure that the data, your telemetry data is accurate.
And that you're getting out the number that you think you're getting out. Because otherwise you
blow up your spaceship. And then you have to build another one for $18 million in 1960s money,
which is closer to $80 million today. You think actually the Mariner 1 mission
is credited, that missing hyphen, is credited with the creation, the inspiration of software
engineering as a discipline. That was the point at which people went, hey, maybe we should do
like what those engineers do when they build bridges. And you know, bridges have collapsed and
stuff. But that was when we kind of started applying engineering principles to building
software, which did not save the Mars climate orbiter, which had a similar experience. Although
it did get most of the way to Mars, to be fair, the rocket took off, it got it into orbit, it set
its engines going, and it got to Mars. And then it crashed into Mars, crashed into the surface of
Mars at a very, very high velocity. And there's still a scar that you can see from one of the
other orbiters that went up there. And the reason for this is incredibly simple. It's because Americans
are stupid. And Americans insist on using inches instead of centimeters. Now, NASA are not stupid.
NASA use centimeters for everything. Actually, they use millimeters for everything. So NASA is
like millimeter scale stuff. So they don't say a centimeter, they say 10 millimeters, because
they work with the European Space Agency, they work with Roscosmos, they work with the Chinese,
they work with space agencies all over the world. They work with suppliers all over the world.
You have to be using the same units. And everyone on the Mars orbiter mission was using the same
units. Everyone was using millimeters and centimeters, except Lockheed Martin. Lockheed
Martin were using inches. So to give you a visual idea, if this is me at five centimeters tall,
then this is me at five inches tall. It's quite a big difference. Inches are not centimeters.
And so when the Mars climate orbiter arrived at Mars, its planned trajectory was that it
should have gone into orbit at 226 kilometers above the surface of Mars. And what it actually did
was go into orbit 57 kilometers above the surface of Mars, which meant it got caught in Mars' gravity
and smashed into it. So yes, units are important. So one of the good things about F-Sharp is the
whole units of measure thing. Can we get that in C-Sharp 12 or something, Mads? You're copying
everything else from F-Sharp. So awesome having in the room to say that.
It's not just NASA though. So yes, 327 million pounds, dollars for the Mars climate orbiter,
plus the 18 months that it takes the thing to get to Mars. And then kind of going,
that didn't work. Should we build another one? Yeah.
But the French, the European Space Agency has problems with their own. This is the Ariane 5 launch.
And this is the first ever launch of Ariane 5, and it was a mission called Cluster. It had four
European Space Agency satellites on it. And the tests had all gone perfectly. The
the pressure testing and everything. And then it took off and it soared majestically
into the sky. And then some code that they had copied and pasted from the Ariane 4 control
software, tried to write a 64-bit floating point number into a 16-bit integer variable.
And this caused the boosters on one side to adjust their vertical, their horizontal thrust
a lot. And so the boosters split off the rocket and that happened. And yeah, this was
spectacular. There's actually, there's a talk kind of similar to this one by Kevlin Henney,
where he goes into a lot more detail and he has the code and it's on YouTube. So you can track
that down if you want to know exactly what happened there. But basically they had seven
variables that controlled the flight path to get into orbit. And four of them were guarded.
So if you try to write the wrong type of data into them, you wouldn't be able to.
The one there that caused that, that wasn't guarded because guarding a variable
uses quite a lot of something and they didn't think they could spare it. And so yes,
spectacular. Ariane 5 though, I mean, you know, since then Ariane 5 has been an absolute work
course and it's put so much stuff into orbit. And it's going to have to keep doing it for quite
a while because Ariane 6 has just been delayed again. Enterprise. Half a billion dollars,
the Ariane 5 disaster. That's kind of probably exaggerated. But yeah, it's sort of including
missed missions and people saying, oh no, you're not launching our satellites. We're going to take
these to NASA. You can sort off. So yes. The big rewrite. This was me. This is another one of
my mistakes. Same company with the MedFile Unfucka actually. We had a product that was written in a
language called Gupta SQL Windows and it was dying. And I was, can we rewrite it in .NET?
Please. I've just, I've got this new .NET thing. It's brilliant. Can we rewrite? And they said,
yeah, all right. And so I started rewriting the entire application as a Windows Forms application.
And they had four people working on the old application and me working on the new one.
And so they were adding features and doing all that. And I was trying to catch up to them.
But I was, I was getting there and it was okay. And then 2005, 2006 came along and Microsoft
released WPF. And it was new and improved. And I was, oh no, it's a new thing. Windows Forms is
dead. WPF is so much better and the binding works better and the design is lovely and all this sort
of stuff. It's a shiny thing. I want the shiny thing. And so I decided that I was going to throw
out all the Windows Forms code and, and replace it with WPF. And that did actually cause me to
have a nervous breakdown and take six months off work. And then when I got back to work,
they did a performance review and they gave me a five, which was the worst you could get.
And I went, why? And they said, well, you just took six months off.
So yes, new and improved. Do not just go, ah, shiny thing and rewrite everything
because you think it looks cool. Probably it only cost them a hundred thousand pounds in terms of
what they'd paid me to achieve, precisely nothing. But it did also cost me my sanity.
And the main sort of thing I got out of it is I know not to do that again.
Recursion. This is just a little bugbearer of mine. I happen to read something about
recursion and how recursion is a better pattern than loops. And I just, it's a lie, effectively.
Recursion is loops. It's just a different way of doing it. So if you recurse in a normal application,
you will end up getting a stack overflow error because things go round and round in circles.
And every time it pushes something onto the stack until there's no room left on the stack.
And so to avoid this, there is a thing called tail call elimination where the compiler recognizes
that that's what you're doing and eliminates that tail call and makes something happen in a different
way. So to avoid this stack overflow exception, so if you look at this, this will eventually
cause a stack overflow because this is 32-bit.net. x86.net framework doesn't do tail call
elimination. And so the jit just produces this code here, which calls countdown and calls countdown.
So if you call this with a big enough number, like in 32.max value, you will get a stack overflow
exception. With the 64-bit jit, they introduce tail call elimination. And so that produces this
code. And you can see that L0014 jump L0007. So every time someone goes, all recursion is a
far superior and computer science-y and functionally way of doing loops, point out to them that that's
a go-to. And I can prove it's a go-to because there's the same code written with a go-to
and yeah, look, there you go. We've got jump short L double. It's a little bit different,
but it's one less instruction than the recursion version. And we do our jump short L07
at the end there. And yeah, so recursion can go jump in a leak as far as I'm concerned.
I would like to thank Andrei Shekin, AshMind on Twitter for sharplab.io. If you've never seen
sharplab.io and you do C-sharp development, it's brilliant. You paste some C-sharp code into it.
It'll show you the C-sharp compilers sort of the C-sharp that it generates for your properties
and async methods and the state machine and all this sort of stuff. It'll show you the IL that's
generated and then it'll show you the actual machine code that's generated by the JIT. It's
fantastic. JavaScript. Any JavaScript fans in the room? I'm about to upset anybody because this
really was. It was a mistake. That was one of the biggest ones. And the thing is it was Netscape
version 2. And somebody stuck their head around Brendan Eich's door and went, Brendan,
can you knock up a quick language that we can stick in the next version of our browser
so that when you put the mouse over an image, we can change it to a different image?
All right, cheers. How long? A week. Cool. And so a week later, Brendan goes back with scheme,
basically, because if you need to implement a programming language in a week, then you write
a Lisp because they're the easiest programming language to implement. So we went, hey, we've
got scheme to run in the browser. And they went, oh, no, no, nobody does Lisp anymore. No, we don't
like all those parentheses. You know what's really hot at the moment is that Java thing. Why don't
you make it look more like Java? And so rather than sort of patch the holes and the problems
and everything else, Brendan made his scheme look like Java, which involves changing prefix
operators to infix operators and that sort of stuff. And the other thing was they wanted it to
be possible so that the kind of people who were just hand coding HTML and creating personal home
pages could hand code some JavaScript to achieve these effects. And so they put all sorts of things
in there to try and help these developers. Like if you said if this thing is equal, equal to this
thing, and there were two different types, then JavaScript would go, well, what if I made them
the same type and then that would work, wouldn't it? Yeah, yeah, that would work. And we ended up
with this absolute abomination of language. But the biggest problem of all is that it's shipped
and then people started using it. And they can't, you can't fix it. You can't fix double equals
in JavaScript. So we have triple equals and bang double equals. And apart from anything else,
that's wrong. So it's just, it should be bang triple equals. Or I don't know. But anyway,
I just think if someone poked their head around Brendan Eich's door and said, hey, Brendan, can
you create the language that will be used for 90% of all programming over the next 50 years and run
on everything from SpaceX shuttles to the internet, to watches, to smartphones, to everything else,
how long? Brendan would probably have said, oh, two weeks. What's a smartphone?
So yes, here are some JavaScripty things. An empty array equals not an empty array.
According to type coercion, no idea why that is, but those two things are the same.
I think it's that empty array becomes object, which is not null, therefore, it's true. And not
empty array, it coerces the array to zero, which is the size of the array, and then knots it so it
becomes true. So that's true equals true equals true. Who can spot what's wrong with this line of
code or why it does what it does? So in the middle here, plus, plus. So because JavaScript does
type coercion, what it's actually trying to do here is B plus A plus, and then we've got this
plus floating here, and it goes, well, I'm already here. So this must mean plus A. So we're doing
the positive value of A. I'll try and coerce A to a number so that I can, oh, no, it's not a number,
so it becomes nan. Type of nan, incidentally, is number. So not a number is a number.
And then we add the other ray onto it, and so B plus A plus plus A plus A is banana,
because, of course, it is. And Douglas Cropford wrote a book called JavaScript, The Good Parts.
Have you ever seen the photograph of JavaScript, The Good Parts next to JavaScript, The Definitive
Guide? That's quite a pot. I took that photograph, and I put that on Twitter, and this was like back
in 2012 or something, and it got 45,000 likes, and I was, yeah, I'm famous. But yes, the difference
between JavaScript, The Good Parts and JavaScript, The Definitive Guide is basically the DOM.
It's the document object model that is the bad parts of JavaScript, according to Douglas Cropford.
And he's kind of got a point, because document.all, which is all the elements in the document,
is an instance of object. But if you do type of document.all, it tells you it's undefined. So
you go, all right, does document.all equal, equal, equal undefined? And it says, no, it doesn't.
And you go, does document.all equal, equal, equal null? And you go, no, it doesn't equal that,
either. You go, well, if you type coercive, does it equal, equal null? And the DOM goes, yeah,
yeah, it does. And they can't fix it. There is code in the world that relies on that behavior.
And so Java, I mean, I don't know what the cost of JavaScript is, but the fun we have with it is
priceless. And yeah, I'm just quite down with that. So I would like to have some honorable
mentions here. Heartbleed, that popped up a few years ago. This was a serious bug in OpenSSL,
which essentially rendered the whole thing completely vulnerable to attack. And of course,
OpenSSL is used by everybody, Google, Microsoft, Amazon, Facebook, Apple, everybody uses OpenSSL.
How could this be allowed to happen? And the XKCD cartoon of the entire modern infrastructure of
the world, and a random open source project somebody in Nebraska has been factlessly maintaining
since 1996. That was OpenSSL. It was just like this one guy who was maintaining this thing,
that multi-trillion dollar companies were relying on, and there was a bug in it. And none of them
had thought to kind of give this guy's code a read or check it out or anything like that.
And then this year, we had Log4j. Because it turns out that one of the things you can put into
Log4j is, hey, log this. Log this call to another service. And while you're logging this call to
another service, pass it some information. Again, Martin's thing earlier on about baggage. And Log4j
so you could put something into a text field, and then Log4j would log what you'd put into
that text field, except it was a URI that said execute a Java enterprise bean. There's that
word enterprise again, on this other server. And just pass it all the data that we've got
attached to this log while we're at it. And there is not a single Java application in the world
that is not using Log4j. So that was fun. And then they fixed that one. I mean, that wasn't in
Java. It was in a library that every Java application uses, but it wasn't in Java itself.
So Java looked okay for literally two weeks. And then somebody looked at Java's actual in the box
ECDSA implementation. So ECDSA is a very complicated algorithm, and it involves three numbers.
And one number is the result of a sum. And the other two numbers, if you multiply the first
number by the second number, then it should equal the third number. And so that was fine.
But it turns out that you pass these three numbers along with your ECDSA token. This might be
a JSON web token or a SAML token, something that you've encrypted using the ECDSA algorithm.
And if you pass it in, and so you've got the numbers, I think they were P, R, and Q, P, and R.
And so it's like P times R equals Q. And so if you set Q to zero and R to zero, then it did P times
Q. And does that equal zero? Yes, it does. And so literally, just by sending a malformed ECDSA
signature with these two values set to zero, you could get Java to go, yeah, that's fine.
That was in the actual, that's like the base class library. That was in the JDK,
but that one came along. That was fun. So we've seen some fun examples. We've seen some very,
very expensive examples. I would like to finish off with one example where we basically got lucky
that, yeah, programmers make all these mistakes. We're fallible, and we're sort of hubristic,
and we're arrogant, and we do stupid things. Fortunately, the rest of the world knows that,
and they don't trust us as far as they could spit a rat. And so the Soviet early warning system
in 1985 was switched on and almost immediately reported that America had launched
five missiles against the USSR. It hadn't. What the image recognition software running on,
I don't even know what kind of computers the Soviet Union had in 1985. I'm guessing they
probably involved rocks and bits of elastic, but you know, it wasn't great. But when they've
launched five, it was actually the sunlight glinting off clouds, but that was incorrectly
identified as the rocket trail from intercontinental ballistic missiles. And this man, Stanislav Petrov,
Lieutenant Colonel Stanislav Petrov, on the 26th of September, sorry, 1983, not 1985,
was told that five missiles were inbound to the Soviet Union from the United States,
and he should immediately launch the Soviet Union's response. He should immediately launch
what turned out to be all four of their intercontinental ballistic missiles. And if he had
done that, then the American early warning system would have seen those, and America
would have launched all the Minutemen missiles that Eisenhower had built, because he thought that
the Russians had 4,000 ICBMs, they didn't, they had four, but he thought they had 4,000. So America
had 5,000, and they would have launched all of them. And that would have been game over humanity,
most life on this planet. And then in another 50,000 years, maybe there'd be a building here
with a software conference with highly evolved cockroaches talking about programming's greatest
mistakes. But Stanislav Petrov said, nah, don't believe that. I'm not launching missiles based
on what a computer says, it can go stuff itself. And so we did not get World War Three on September
26, 1983, because there was a human between the computer and the missile launch system.
And thank God for that, because that very nearly cost all known life in the universe.
And that's how serious some of this stuff is. So yeah, think about that as you go back to work
tomorrow or next week, and maybe just be a little bit more careful. Thank you very much for listening
to me. And I will see you next time.
