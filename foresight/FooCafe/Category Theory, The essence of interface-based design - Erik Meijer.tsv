start	end	text
0	21840	What we're going to do tonight is to celebrate, of course, the three-year anniversary of Foucafé.
21840	29240	And also we're going to give a tribute to Joachim Lambeck, who is a kind of category
29240	34840	theorist that kind of made the connection between the lambda calculus and category theory.
34840	39560	And, funnily, his name kind of, you know, has the same prefix as the lambda calculus.
39560	41400	That isn't that a coincidence.
41400	42840	I don't know.
42840	51200	But anyway, so just in the spirit of deliberate and continuous learning, you know, like, who
51200	54360	here uses Java 8?
54360	55360	A few people.
55360	59120	Who here uses Java 6?
59120	60760	A few people as well.
60760	68880	So it has taken, like, many, many years before Java 6 became Java 8 and added lambdas.
68880	76440	Now if the language designers would have practiced deliberate and continuous learning, it would
76440	81720	have happened, like, you know, decades ago, because all this knowledge was already developed
81720	84960	by people like Lambeck.
84960	90600	And tonight I'm going to tell you the tricks how you, as a developer, can tap into the
90600	97440	brains of mathematicians and kind of steal their ideas such that, you know, you can become
97440	102400	a better developer and then go to your boss and ask for more money, because you're an
102400	104400	awesome developer.
104400	106200	All right.
106200	109360	Let's get started.
109360	111280	Oops.
111280	117000	So one of my guilty pleasures is I read language specifications.
117000	122120	So some of you kind of, you know, might read novels or newspapers, maybe.
122120	124200	I read language specifications.
124200	126640	And for a while I was collecting them.
126640	132840	I had a whole bunch of, you know, going all the way back to, you know, the early Lisp,
132840	136160	1.0 manual, Pascal, everything.
136160	140640	So whenever there was a new language, I would read the language manual.
140640	149880	So I read all of them, Visual Basic, C-Sharp, ECMAScript, Swift, Dart, you name it.
149880	155840	But there's one language specification that even for me was too strong.
155840	158200	It was impossible to read.
158200	163840	And that language specification is Java 8.
163840	171320	Now I don't know, anyone, has anyone here ever looked at the Java language specification?
171320	172560	Okay.
172560	174120	Did you fall asleep immediately?
174120	176480	I mean, you open up this thing and you fall asleep.
176480	180960	I mean, it's like, try it, you know, some, you know, and you kind of cannot sleep at
180960	181960	night.
181960	182960	Your kind of mind is wandering.
182960	184600	Just open that thing up.
184600	188720	It will work better than any pill.
188720	190760	And this one in particular is really weird.
190760	195960	So when Java 8 came out, and there's this kind of weird thing with method references,
195960	199680	so I thought, I really want to understand this.
199680	204400	So I started to read the language pack.
204400	209360	It doesn't, my goodness, it's just way too complicated.
209360	212360	So what do I do?
212360	219600	When something is complicated, I'm always listening to this guy.
219600	224480	This is Leslie Lamport, and he won the Turing Award last year.
224480	225480	Okay.
225480	229440	Well, if you win the Turing Award, well, that means something.
229440	236920	And one of the kind of advice that Lamport gives us is that we should kind of do more
236920	237920	math.
237920	239360	We should use more math.
239360	244160	If you're like a mechanical engineer, you build, or like a civil engineer, you build
244160	248000	a bridge or something, you use math, okay?
248000	251000	If you're a chemist, you use math.
251000	255680	But we as computer scientists seem to be afraid of mathematics.
255680	260800	And what Lamport says, and what I will tell you, is you shouldn't be afraid.
260800	269480	And I think a lot of people here, I don't know, maybe, you know, in Sweden, it's different.
269480	273640	You're not afraid of math, you know, you, instead of language specifications, you read
273640	277120	like books on calculus before you go to bed, I'm pretty sure.
278120	284480	Typically, when I meet developers, they are kind of afraid of mathematics.
284480	288640	And I think there's several reasons for that, and those are good reasons.
288640	294720	First of all, mathematics, most textbooks are really bad.
294720	299480	The notation is weird, it doesn't even type check, you know, if you're trying to kind
299480	304600	of, you know, look at it, it doesn't work.
304600	309320	The lingo is weird, they have all their own terms.
309320	313240	They often, you kind of end up in a rabbit hole, you know, you want to kind of know a
313240	318960	little bit, and before you know it, you know, you're kind of, you know, deep into all kind
318960	324000	of Greek symbols and other dirty pictures.
324000	331120	And last but not least, often mathematics is taught in a bottom up way, okay?
331120	336000	So you cannot say, I need to solve a particular problem, and I need a piece of mathematics
336000	337000	for that.
337000	339600	No, instead, they start bottom up.
339600	345440	So you have to first know a whole bunch of mathematics before, finally, you can apply
345440	347200	it to your problem.
347200	353320	Whereas with computing, we typically teach the other way around.
353320	356240	Who here has a computer science degree?
356240	359640	Okay, I would say about half.
359640	365880	So the other people don't have a computer science degree, they still know how to program,
365880	372800	but they didn't start by studying, you know, big O, they didn't start to study touring
372800	373800	machines.
373800	378040	No, they just opened up an editor and started to hack.
378040	380680	They did it top down.
380680	385520	And of course, at some point, you will feel that maybe you need a little bit more theory,
385520	388920	but programming is typically taught top down.
388920	395960	So you don't start with all the theory, but no, you start by solving a particular problem,
395960	396960	and then you go down.
396960	400240	Let me give you a really good example of that.
400240	402240	Linear algebra.
402240	407880	When most people teach linear algebra, they talk about matrices and then you have to multiply
407880	413760	matrices and then you have to kind of do all kind of mechanical, stupid things.
413760	416400	And then you use it to do graphics.
416400	422440	But you know, instead of kind of knowing why you do it, you're kind of manipulating this
422440	424960	kind of low level representation.
424960	433160	Now if you know that a matrix, an m by n matrix is really the representation of a linear function
433160	439360	from a sequence of numbers of length n to a sequence of numbers of length m.
439360	443120	And matrix multiplication is function composition.
443120	448560	So really, when you're doing matrix manipulations, you're doing assembly language programming.
448560	452920	This is completely nonsense that we as humans have to do that.
452920	459240	If instead they would teach linear algebra as a restricted form of functional programming
459240	464600	with some special functions that are linear, which means that they have nice properties,
464600	465840	everything would be easy.
465840	470840	But these are the stupid mathematicians that are too smart for their own sake and they
470840	473160	teach it bottom up.
473160	476200	And then in the end, you know, we scratch our heads.
476200	479760	I scratch my head way too often.
479760	482600	And then we ask ourselves, why is this useful?
482600	483600	All right.
483600	486000	So linear algebra is really easy.
486000	489200	It's just functional programming with linear functions.
489200	493800	Matrix multiplication is function composition done.
493800	495920	Same is true with category theory.
495920	501720	If you look at category theory, it looks scary, just like linear algebra, but it's really
501720	502720	easy.
502720	506280	So let's start looking at that.
506280	511760	So mathematicians often call, this is kind of weird, right?
511760	516200	Mathematicians that give us linear algebra, they look at category theory and say this
516200	519600	is abstract nonsense.
519600	526160	And the reason that they say it's abstract nonsense is because in category theory, proofs
526160	530280	are done in a very abstract way.
530280	533200	So it's, look at what it says here.
533200	541400	It's the study of the general form of mathematical theories without regard to their content.
541400	545960	What that means is that all intuition is taken away.
545960	551520	And you look at the pure, you know, pure general form.
551520	559000	Well, as programmers, we recognize that because whenever we do, whenever we program against
559000	562640	an interface, that's exactly what we're doing.
562640	567280	We're programming against a thing without regard to their content.
567280	570200	We're not programming against a concrete type.
570200	573120	We're programming against the abstract interface.
573120	578680	And then there can be many concrete types that we can plug in, but the program is still
578680	580680	the same.
580680	585680	The other thing that's interesting is that here they talk about proofs.
585680	590960	So you build your proof on these kind of general theories.
590960	595280	Well, there's a very, very interesting thing.
595280	597920	It's called the Curry-Howard isomorphism.
597920	601080	People heard about the Curry-Howard isomorphism.
601080	603960	It's one of the most beautiful ideas I've ever seen.
603960	611520	So Curry-Howard isomorphism says that a type is a theorem and the program is the proof
611520	613800	for that theorem.
613800	619920	Now what means that whenever we're kind of writing code, we're really proving theorems.
619920	622160	So we are like mathematicians.
622160	627880	Or you can say, mathematicians are really developers, that program really, really slow.
628000	636600	It takes them like two decades to kind of write a small proof.
636600	640360	But this Curry-Howard isomorphism is really beautiful.
640360	644400	I don't have time today to talk about it.
644400	651640	But if you take that a little bit further, that's what I'm going to do here is that you
651640	656720	define your theorems in terms of these abstract structures.
656720	661360	And then you write your code in terms of them, so you do your proofs in terms of them.
661360	664600	And so let's continue with that.
664600	671560	And as I said, this is really not foreign to, for us developers, because we do this all
671560	672560	the time.
672560	675040	We do this when we program against interfaces.
675040	678040	We do this when we use design patterns.
678040	683360	I'm pretty sure that most people have that book on their bookshelves.
683360	686360	And I'm also sure that nobody has ever read it.
686400	689760	Because when you read it, you get the feeling, what's going on?
689760	693440	This is all kind of, you know, how did the mathematicians say this?
693440	699520	This is without regard to any actual content, because these design patterns are very abstract
699520	702920	and you can instantiate them for specific purposes.
702920	707320	But that's the beauty of design patterns, because now you can talk about concepts in
707320	715080	a very abstract way, without kind of, you know, being tied to a very concrete implementation.
715800	716800	Okay?
716800	723280	So that's, already I give you a couple of tricks, how to think like a mathematician
723280	725520	and profit from that.
725520	729640	Now, what is category theory?
729640	733560	Well, category theory is embarrassingly simple.
733560	737000	It has two, well, three concepts.
737000	744920	First of all, there's a notion of a category, but a category consists of objects and morphisms.
745920	750200	Now, as I said, mathematicians are weird people.
750200	751760	They use strange lingo.
751760	755120	So let's translate this into programming terminology.
755120	761000	So a category is really a programming language, okay?
761000	764280	And a programming language has types, okay?
764280	770720	Like in Java, there's types, Boolean strings, lists, those are the types.
770720	776360	And then there are morphisms, well, that's just a fancy word for static method.
776360	785960	So morphism from A to B is just a static method that takes a argument of type A and
785960	793080	where there's a value of type B, or equivalently, you can say it's a property.
793080	798600	Now you can ask yourself, well, if you're saying that we're doing programming, why do
798600	801480	I use static methods?
801480	803120	Because we also have instance methods.
803120	805080	Well, we'll come back to that later.
805080	811160	So the whole point of this talk is to kind of, you know, fix this and make this precise.
811160	820080	So mix this notion precise that morphisms in a category are just static methods.
820080	821400	Now look at this.
821400	823280	This is, again, mathematicians.
823280	825560	I told you they're slow programmers.
825560	828840	So here's an example of a programming language.
828840	833200	It's a programming language that has three types, A, B, and C.
833200	836840	So it's like characters, integers, and Booleans.
836840	838480	That's it.
838480	843120	And then, well, if you have three types, then you can define some functions between them.
843120	848760	So for example, I can go from Booleans to characters, and I can have a function from
848760	851440	characters to characters.
851440	858320	Now for these mathematicians, this is so special that they give this language a name, and it's
858320	860440	called bold three.
860440	861440	Okay.
861440	868480	Now imagine if you want to draw this kind of picture for Java, you know, it wouldn't fit,
868480	873400	you know, you would need all the walls here, and, you know, maybe the whole city with graffiti
873400	874400	like this.
874400	875400	Maybe it would look quite nice.
875400	876680	It's like an art project.
876680	878120	But this is kind of mathematicians.
878120	884160	So they are kind of proud that they understand this programming language with three types.
884160	885160	Okay.
885160	893280	Now, of course, once you have types, you can create other types.
893280	899040	And everybody these days seem to want to have tuples.
899040	903400	And Java doesn't have tuples, but there's many libraries that provide tuples.
903400	906760	Anybody here does Android programming?
906760	911560	A few people not so few, what are you Windows phone, maybe?
911560	912560	No.
912560	918080	But if you do Android programming, you know, you know, and even if you don't, this might
918080	926400	be interesting to know, is that in the Android library, there is a type for tuples.
926400	931720	That's so important that even on your Android phone, you need tuples.
931720	940360	And here is some category theory that defines what tuples are in Mathematician speak.
940360	945080	Now you will ask yourself, oh my goodness, where's my beer?
945080	947360	The next beer, this looks kind of horrible.
947360	948360	Okay.
948360	954280	There's like all kind of weird stuff, commuting diagrams, canonical stuff.
954280	956200	I don't even understand this.
956200	966160	So let's take this Greek and let's try to translate this into a language that we all
966160	967160	understand.
967160	968160	Okay.
968160	975520	So here's the first sentence of that definition of tuples.
975520	981960	And it says, let's see be a category with some objects X1 and X2.
981960	991160	Well, as I said, a category corresponds to a programming language and a object corresponds
991160	992160	to a type.
992160	999320	Now, often people confuse objects and instances and whatever.
999320	1000520	So let's not be confused.
1000520	1003880	So that's why I call them types and types have instances.
1003880	1008320	And whether you want to call the instances objects or the type objects, I don't care.
1008320	1010200	So that's why I call them types.
1010200	1014720	And also then it doesn't clash with the objects in the category.
1014720	1015720	Okay.
1015720	1020280	Now, what can I do when I have two types?
1020280	1023120	Well, I can form a tuple.
1023120	1024840	They don't call it tuples.
1024840	1026920	They call it a product.
1026920	1027920	Okay.
1027920	1032280	So they are going to take these two types, X1 and X2.
1032280	1037840	They're going to create a new type X, which, you know, they can also write as X1 cross
1037840	1044360	X2 and then blah, blah satisfies a universal property, blah, blah, blah, blah, blah, blah.
1044360	1046360	Do you understand this?
1046360	1047360	No.
1047360	1048360	Yes.
1048360	1049360	Good.
1049360	1059560	There's one person that understands it, great.
1059560	1065840	So let's go and drill down a little bit into this.
1065840	1070760	Because I think this picture says, said it much better.
1070760	1079800	So if I have a tuple or a product, I have two functions that I can use to project the values
1079800	1080800	out of this tuple.
1080800	1086000	So I can select the first element and I can select the second one.
1086000	1090040	Now you can ask yourself, why do they start counting at one?
1090040	1094080	Because we as developers always, now our index is zero.
1094080	1099080	And again, these are mathematicians, they don't, they probably never done C programming
1099080	1100080	or whatever.
1100080	1102960	So they can start their counting by one.
1102960	1109400	Anyway, so this is the kind of thing, but then there's all the rest of this.
1109400	1116200	And what we see here is, well, how on earth do you get an instance of a tuple?
1116200	1120720	Well, you need a constructor or a factory function.
1120720	1123240	These mathematicians are not stupid, right?
1123240	1127840	They know that when you create a type, when you have a type, you all you have to have
1127840	1129640	a way to create it.
1129640	1136120	We call it constructor, well, they have here some function that kind of allows you to kind
1136120	1138840	of create a tuple.
1138840	1146440	And then they say, well, if you have such a function, which you create from two morphisms,
1146440	1151640	then if you kind of start with a value here, you apply that to this function.
1151640	1158360	Now you get this guy, that must be the same as kind of projecting the first value or applying
1158360	1159360	this function.
1159360	1162200	So it all must kind of commute.
1162200	1165800	And that looks quite nice in that diagram.
1165800	1171840	Now if you don't like diagram, then you can translate it into equations, whatever you
1171840	1174760	find easier to read.
1174760	1180040	Now, except for this gentleman over there, what's your name?
1181040	1188560	Oh, I cannot pronounce that, but generic, good.
1188560	1194760	Mr. Generic over there, he understands this.
1194760	1200400	But that's kind of, you know, for the rest of us, you know, whose brains are the size
1200400	1208680	of peanuts or smaller, let's kind of continue to put this into our language.
1208680	1215120	So if we go on with this translation, we say that a type A comma B is a product of A and
1215120	1219480	B or a tuple of A and B, if it satisfies blah, blah, blah.
1219480	1227960	There exist two properties underscore one and underscore two that return an A and a B respectively.
1227960	1231800	Any Scala programmers here?
1231800	1233800	You recognize this?
1233800	1236760	Yeah, look at this, I see a smile.
1236760	1237760	Yep.
1237840	1243600	This is Scala, you can project the first and second element, but then there's also, if
1243600	1248800	you have two methods, the factory function for this thing takes two methods and it gives
1248800	1255240	you a function that given a C returns this pair of A and B, and it does that by kind
1255240	1259560	of applying that C to F and G respectively.
1259560	1266040	So this is a little bit different than in Scala because the constructor function behaves
1266040	1267120	a little bit different.
1267120	1272880	But we can, from this, we can create a normal constructor function too.
1272880	1284400	Okay, let's go look at this commuting diagram and it's kind of the same.
1284400	1292560	Now as I said, if you look at Scala, I don't know, I think this mathematics is actually
1292560	1293560	clearer and shorter.
1293560	1299560	Because look at this, trade, blah, blah, blah, extends, blah, blah, blah, abstract
1299560	1303280	this, abstract that, curly open, curly close.
1303280	1308440	Now you see why these mathematicians have their strange lingo because maybe we have editors
1308440	1314640	and we have autocomplete, but look at how many characters we need to write down kind
1314640	1318520	of something simple like this, okay?
1318520	1329360	But here is you see that this is the definition in Scala of a product and I think this is,
1329360	1332960	now you can ask yourself what the heck are those pluses there?
1332960	1339760	Am I going to kind of, I don't know, is this unary plus or no, no, no, that's co and contravariance.
1339760	1346160	But that's way too complicated, but this is actually the way that products are defined
1346160	1356080	in Scala, but what Scala doesn't have is this operator to construct a product.
1356080	1364680	Now the reason why Martin cannot do that is because if you would do that, you already
1364680	1371560	need the notion of functions as objects and that was the whole point of this presentation
1371560	1379520	to figure out, you know, how can we make these morphisms into first class things, okay?
1379520	1386880	So really, you know, if we look at this simple example where we took the idea of tuples and
1386880	1392720	we have seen how the mathematicians do it and we do it, it's really the same except
1392720	1399160	that the mathematicians apply a little bit more rigor, they use weird notation, but the
1399160	1405440	nice thing that they do, that we never do is when they define a type, they talk about
1405440	1410640	properties of the type, what properties should a product have?
1410640	1418480	Because if you look at this definition in Scala, right, from here it says nowhere that
1418480	1426040	when you create a tuple out of two values and you project from that tuple the first
1426040	1430640	value that you actually get the value that you put in there, right?
1430640	1436880	Nothing says this here because it can return null for both sides and it's still kind of
1436880	1440320	according to this type definition a valid implementation of tuple.
1440320	1445840	Of course, you would not accept that, but the type itself doesn't say anything.
1445840	1451040	So if you're a smart programmer and somebody gives you this trait and you have to implement
1451040	1456760	it, you can just return null in both cases, nobody can complain.
1456760	1461600	If they file a bug, you immediately file the bug back and say you didn't specify this
1461600	1463480	thing properly, okay?
1463480	1465280	This is another tip, okay?
1465280	1473420	You just return null, your colleagues complain, you just say sorry, you know, specify it better.
1473420	1478440	And then you can go have a drink, a beer, kind of go to another meeting, put that on
1478440	1487120	your resume, get even more money, look at this, all right, good.
1487120	1496960	So and here is the, you know, again, a slightly different way to do this function.
1496960	1501720	I'm going to skip this for lack of time.
1501720	1508420	Now Mr. Generic here says, oh, I knew this already, but this is old stuff, right?
1508420	1517700	Here is John McCarthy, the inventor of Lisp, and he says, well, come on, I could define
1517700	1522280	all this stuff with top polls and so on in 1960.
1522280	1528820	And then Church, Mr. Alonso Church, who invented the Lambda calculus, he did this already in
1528820	1531300	1928.
1531300	1538700	Now look, this guy here came up with this in 1928.
1538700	1544900	If you read the papers from Church, he was doing this kind of tuples.
1544900	1552540	In Java 8, it's 2015, last time I checked, there are still no proper tuples in the language.
1552540	1560740	Look at this, I don't even know, it's like 2015 minus, that's nearly a century, okay?
1560740	1565340	And we still don't, this thing still doesn't, we are, and why is that?
1565340	1571020	Because we are afraid of these mathematicians, whereas we should steal their ideas and profit
1571020	1573380	from them, okay?
1573380	1575620	That's really kind of my message today.
1575620	1580740	These people are smart, look at this size of this brain here, you know, if I put my
1580740	1587540	head next to it, it's like 10 times the size, we should leverage that.
1587540	1590140	But what do we do instead?
1590140	1596300	Well first of all, we are proud that, you know, we don't do theory.
1596300	1602900	So if you look at C-Sharp, C-Sharp has delegates, and it's like we don't need any of this theory,
1602900	1604820	we have delegates.
1604820	1607860	But where, you know, where does these delegates come from?
1607860	1608860	What are their properties?
1608860	1609860	We don't know.
1609860	1614700	And then, I don't know if anybody's old enough, probably most of you were not born yet, but
1614700	1620500	when C-Sharp came out, there was a little fight between C-Sharp and Java, where the
1620500	1626540	Java folks said, we don't need any of this lambdas or delegate stuff because we have
1626540	1628660	virtual methods.
1628660	1633700	And so this is another lesson, never say never, okay?
1633700	1638620	Because I think, because they didn't want to lose face for the longest time, Java could
1638620	1647260	not add lambdas because, you know, James Gosling said in public that lambdas are unnecessary.
1647260	1650140	So then you're not going to kind of turn around and add them.
1650140	1651140	No.
1651140	1655380	So first of all, he had to kind of retire, kind of join Google, join whatever company
1655380	1656380	is now at.
1656380	1659300	I think he's doing self-driving cars at Stanford.
1659300	1667580	And finally, they could put delegates lambdas into Java.
1667580	1673060	But the other thing is also, you should not kind of downplay and be arrogant and downplay
1673060	1674060	theory.
1674060	1675060	Okay?
1675060	1677740	You should always stay humble and hungry.
1677740	1680260	You always want to learn.
1680260	1685060	If these mathematicians come up with something, you know, but you better have a look at it
1685060	1687900	because maybe it's something that you can use.
1687900	1689500	All right.
1689500	1694940	But then you can say, come on, Eric, what are you talking about?
1694940	1702660	Customers and categories represent mathematical objects, whereas we as developers, we deal
1702660	1710220	with objects that represents real-world things, okay, like customers and orders and all kind
1710220	1716900	of other boring things that we have to do in our day jobs and rather not do, okay?
1716900	1722340	But that's also not true because most of our programs that we like to write when we don't
1722340	1724260	have to do customers and orders.
1724260	1730180	Our data structures, list, trees, those don't represent real-world objects.
1730180	1732140	I've never seen a list.
1732140	1738180	I've seen trees in the real world, but they're not like the trees that I have in my code,
1738180	1739180	right?
1739180	1747100	And maybe lists a little bit, although, you know, the lists that I have on my refrigerator
1747100	1748860	never get garbage collected.
1748860	1753260	They never get finished, whereas the lists in my computer always kind of, you know, end
1753260	1754980	up kind of disappearing.
1754980	1765580	So, all right, but anyway, so I think that this whole idea that objects represent real-world
1765580	1772500	things is nonsense because most objects that we deal with in programming don't represent
1772500	1776020	real-world objects.
1776020	1782100	And the other thing is that what we can learn, so what we can learn from these mathematicians
1782100	1787740	is that we should be more careful in formalizing the things that we deal with.
1787740	1795820	For example, if we write code in Java, we deal with methods, but these methods themselves,
1795820	1800700	you know, we don't have an object that represents them.
1800700	1801700	Is that true?
1802140	1807660	Well, that's what we're after, but I'll say something more about it later.
1807660	1812660	But the other thing that we can learn from the mathematicians is that we should also
1812660	1817780	be more careful that when we define a type that we think about the properties, because
1817780	1824220	otherwise some smart-ass colleagues of you can always return null and then claim that
1824220	1830860	this is a proper implementation, because you have not specified with that type what the
1830860	1833140	properties are, okay?
1833140	1840660	And the good thing is that we don't have like weird terminology, although if you use UML
1840660	1844940	and all that stuff, I guess there's plenty of craziness there.
1844940	1852700	Now, this is, I'm a big fan of Bertrand Meyer, he's not related because his last name is
1852700	1859860	with a Y and mine is with IJ, but he has a great saying where he says that, you know,
1859860	1864380	objects don't really represent real-world things because you're always kind of removed.
1864380	1869660	Even if you have a person object, it doesn't really represent a person because it's something
1869660	1873860	in the memory of your computer that represents a person.
1873860	1879500	So you're all kind of ready twice removed from reality, okay?
1879500	1886540	So let's just forget about that and just look at objects in programming as formal things
1886540	1890300	just like mathematical objects.
1890300	1896820	All right, now I've been talking about programming, I thought this was about category theory.
1896820	1906140	Now, the thing before we go there is we do have a way to talk about methods as objects
1906140	1909460	and that is with reflection, okay?
1909460	1913700	Because if you do reflection in Java, you can kind of, you know, go to a type, get this
1913700	1917500	method and you can even invoke that method using reflection.
1917500	1923340	Now, reflection, if you think about it, is super complex because it's a program that
1923340	1926060	can reason about itself.
1926060	1929060	Most of us are not even able to reason about ourselves.
1929060	1934900	You know, when we're acting foolishly in public after we've been kind of, you know, partying,
1934900	1935900	are we reflecting?
1935900	1938140	No, typically not.
1938140	1941220	Or maybe we do sometimes.
1941580	1948660	But code, it's amazing that we can write code that kind of reflects about itself and the
1948660	1953020	mathematicians cannot do that.
1953020	1959860	But reflection is kind of a cop out because with reflection, we're not really kind of
1959860	1964420	having an object that represents a method because it's kind of, you know, in the kind
1964420	1967580	of dream world of reflection.
1967580	1973060	And what we're trying to do here with lambdas or with methods references, we're trying
1973060	1979340	to represent methods as normal objects, not as reflective objects.
1979340	1983900	Oh, my goodness.
1983900	1984900	This has to come.
1984900	1985900	Okay.
1985900	1989700	Dave Thomas, small talk, everybody knows Dave Thomas.
1989700	1990700	Okay.
1990700	1991700	Small talk guy.
1991700	1996460	Of course, what do small talk people say?
1996460	2001620	And I was a young boy and we read a small talk was still popular.
2001620	2004420	That was a long time ago.
2004420	2009500	We already had blocks that blocks are things that represent methods.
2009500	2015060	And that's quite remarkable because if you look at small talk, that is very much as the
2015060	2020900	flavor, this anthropomorphic flavor where objects represent real world things where
2020900	2022700	you send messages to it.
2022700	2030180	But still, they already knew that they had to represent methods as objects themselves.
2030180	2031580	Okay.
2031580	2032860	But don't worry.
2032860	2036180	I won't talk about small talk.
2036180	2042740	And the reason is that in small talk, like what we saw here in mathematics, array indexes
2042740	2050700	start with one, which as a Dutch person is unacceptable because the big extra as told
2050700	2054020	us that indexes should start at zero.
2054020	2056620	And you know the reason why?
2056620	2060100	Because when he is kind of, you know, that's why I'm kind of doing this papers.
2060100	2063420	The first paper, there are zero papers here.
2063420	2065740	So that's why it's zero.
2065740	2068540	And now the second paper, now it's two.
2068540	2073100	So you see that's how he can because he always wrote his, his papers by hand.
2073100	2076940	And so he counted like how many papers were already there.
2077340	2077940	Okay.
2077940	2081660	So now you know why you should be counting that with zero.
2081660	2084660	Okay.
2084660	2095460	Now let's kind of talk about why we are really here is how do we represent methods as objects?
2095460	2099940	And again, category theorists have a fancy word for that.
2099940	2102500	They call it exponentials.
2102500	2106140	And then you can ask yourself, why do they call it exponentials?
2106140	2109460	Why don't they call it lambdas or anything normal?
2109460	2116380	Like in TypeScript, you know, arrow functions or, I don't know, blocks.
2116380	2119620	Well, there's actually a good reason.
2119620	2125220	But if we look at this, I don't know, I see people already except for Mr.
2125220	2127460	Generic here.
2127460	2130740	He's like, oh yes, yeah.
2130740	2133060	This is like, you know, beautiful.
2133060	2134020	This is beautiful.
2134020	2138820	For the rest of us, it looks a little bit like, look at this.
2138820	2141740	There's even now two diagrams here.
2141740	2142020	Okay.
2142020	2143220	But I see a lambda.
2143220	2144060	Can you see that here?
2144060	2147260	It's like, you know, the font is not so sharp, but there's a lambda.
2147260	2149620	So we're in the right direction.
2149620	2152940	So let's decode the Greek and let's zoom in.
2152940	2158180	So it says, let's see be a category with binary products.
2158180	2163300	So that's the reason why we started out with tuples because in order to do functions,
2163300	2164580	we need them.
2164580	2168860	That was a little bit of the foresight of me.
2168860	2177620	And let Y and CB objects, the exponential object, Z to the power of Y.
2177620	2178580	Oh my goodness.
2178580	2179940	Why?
2179940	2185780	This is why they're called exponentials because they write it as an exponent.
2185780	2190260	It's defined, blah, blah, blah, and then there's a new word, functor.
2190260	2196900	Oh, I thought that we were ready because I kind of cheated by doing these products first.
2196900	2199980	But now we kind of have another hurdle here.
2199980	2203620	I have to explain to you what functors are.
2203620	2214300	But first, let me kind of explain a little bit why this notation of exponentials makes sense.
2214300	2219540	And the reason is that if I have a function from a type,
2219580	2228420	Y to a type Z, that there are Z to the power of Y possible functions.
2228420	2236380	Okay, so if I have two types, Y and Z, and I take all the functions from Y to Z,
2236380	2239620	then there are Z to the power of Y of them.
2239620	2241620	Now, how can I remember that?
2241620	2244260	Okay, I see somebody here puzzled.
2244260	2247180	Okay, now let's do the simplest case.
2247180	2253340	Let's say that Y, so this is a function from Y to Z.
2253340	2258780	So now let's take Y to be unit, okay, or void.
2258780	2260580	So there's only one value.
2260580	2265060	And let take Z be booleans, true and false.
2265060	2270060	So how many functions are there from void to boolean?
2270060	2270940	Only two.
2270940	2275780	I can go from void to true and from void to false.
2275780	2282820	Okay, now how many functions are there from booleans to unit?
2282820	2288060	Well, there's only one that maps true to unit and false to unit.
2288060	2291180	Okay, those are mathematical functions.
2291180	2297780	Now you can say in Java, how many functions are there from bool to unit?
2297780	2298540	How many?
2298540	2305140	Because I can do print line, you know, of that boolean and that returns unit.
2305140	2312300	I can kind of, you know, send it with an HTTP request to whatever, get it back.
2312300	2313620	That's another function.
2313620	2316100	I can do reflection over the boolean.
2316100	2317980	So there's many functions.
2317980	2325980	And this is why in Java, a method, so I'm a little bit lying because a method,
2325980	2332060	you know, of bool to unit is not really a function because there can be side effects.
2332060	2338620	There's a lot of context that's hidden in Java that you can use as a programmer to kind
2338620	2344940	of cheat and don't show that, you know, that doesn't show up in the signature.
2344940	2349540	Now, if you're, I don't know if there's any kind of, you know, fundamentalist functional
2349540	2355180	programmers here, people that, crazy people that like Haskell and no Haskell programmers
2355180	2357500	here, there's one Haskell programmer.
2357500	2358780	Now he's smiling.
2358780	2359980	He says, yeah, look at that.
2359980	2361580	And Haskell, this is true.
2361580	2364580	No, then your crappy Java, right?
2364580	2369540	Because in Haskell, Haskell functions are really mathematical functions.
2369540	2371940	So everything is explicit.
2371940	2376300	But you know, that's why, you know, what is your name?
2376300	2383340	Oh, my goodness, even, even more complicated than Mr. generic.
2383340	2387380	Let me call you Mr. H. Mr. H there.
2387380	2392020	This code is like probably 10 times longer than the Java code.
2392020	2396420	By the time he's kind of done all his monads and whatever.
2396420	2402700	So, you know, again, maybe it's good to have him as a colleague, because then you can,
2402700	2406700	you know, you can learn from him and then write all this code implicitly.
2406700	2411260	And then he will say, oh, but I can do now my kind of monad transformer with the state
2411260	2414500	monad and the maybe monad and the list monad.
2414500	2418900	And by the time he has figured out how to compose all these monads, you're already here
2418900	2423900	at Foucafé listening to your next talk that you can put on your resume.
2423900	2425780	And you get ahead.
2425780	2427500	Isn't that great?
2427500	2428500	Okay.
2428500	2429500	Good.
2429500	2434980	Let's translate this into normal language.
2434980	2440540	Let L be a language that supports tuples, okay?
2440540	2442700	That's already a big step.
2442700	2448980	And let's assume that Java has tuples and let A and B types in the language, a function
2448980	2455620	A, arrow B, I'm just using normal notation now, can be defined as a factory method from
2455620	2456620	the functor.
2456620	2457620	Okay.
2457620	2465060	So, we're nearly there, but now I have to explain what a functor is because I've removed
2465060	2470900	all the Greek and I say there's a factory method for functions.
2470900	2476660	But in order to do that, I need to know what a functor is.
2476660	2478980	Now what is a functor?
2478980	2484420	And again, this is why most of us hate mathematics so much because I warned you that you often
2484420	2487120	go into the rabbit hole, okay?
2487120	2492380	And now we're going into the rabbit hole a little bit because when you look up functor
2492380	2495580	on Wikipedia, it's even more Greek.
2495580	2497580	Oh my goodness.
2497580	2500420	Ah, does it ever stop?
2500420	2504780	Well, let's look at it and it's not that bad.
2504780	2509100	Let C be a category, a functor, blah, blah, blah, blah, blah, blah, blah, blah, blah.
2509100	2510100	Okay.
2510100	2513380	Let's translate this into normal English.
2513380	2520140	And now we certainly understand it because since Java 6 and it was it, when did Java
2520140	2521140	get generics?
2521140	2523140	Was it Java 5?
2523140	2524140	Wow.
2524140	2525140	Look at that.
2525140	2528700	That's a long time ago.
2528700	2532620	The way they did it, yes.
2532620	2543620	So here a functor is a generic type that associates with each type A, a new type, C of A. So list
2543620	2551740	of T is a functor because I can instantiate it with another type, say int, sorry, integer
2551740	2556820	because generics in Java suck that you can only instantiate them with reference types
2556820	2559900	and not with base types.
2559900	2561140	But yes.
2561140	2571500	And then on that type, there must be a function map that goes from C of A to C of B. Now think
2571500	2573700	about this.
2573700	2575500	What does this thing do?
2575500	2581860	It says that if I go, if I can go, say from integers to string, because I have two string,
2581860	2586300	right, that goes from integers, from integers to string.
2586300	2592220	Now if I have a list of integers, I must be able to kind of, you know, do two string
2592220	2595000	on every element of that list.
2595000	2601620	And that's all what this thing is saying, that if I can go from int to string, then
2601620	2608860	I must go from list of int, oh sorry, list of int to list of string.
2608860	2612100	That is, that's quite reasonable, right?
2612100	2616780	And when we define generics, so again, here's a trick.
2616780	2624980	Whenever your colleague defines a generic type, probably they don't specify that this
2624980	2630420	should hold, that if you have, if you instantiate that generic type with one type, you instantiate
2630420	2634020	with another that you have to be able to go between them.
2634020	2637100	Well, they should have a map function.
2637100	2642900	Now the thing with this map function is that it should have some properties too.
2642900	2648260	Say that, you know, I'm going from list of int to list of int.
2648260	2650380	Well, how do I do that?
2650380	2654260	By doing the identity function, I'm doing nothing on each element.
2654260	2657580	So that should be delivered the same value, right?
2657580	2659380	That is kind of reasonable.
2659380	2668100	The other thing is that if I do a map and then another map, that must be the same as
2668100	2673500	doing the map with these functions combined, okay?
2673500	2679180	And this is like an optimization trick, because instead of taking a list of int, going into
2679180	2684140	a list of string, and then say taking the length of the string, so now getting a list
2684140	2690620	of int again, I don't have to build that intermediate list, because then I can just map this function
2690620	2691980	over that list.
2691980	2699460	So these category theorists also are efficiency freaks, because they say that this map must
2699460	2704380	have these properties so that they can optimize their code, okay?
2704380	2712660	So a functor is just a generic function that has a map operator.
2712660	2721460	Now, in normal Java generics, most functions, most types, most generic types, don't come
2721460	2722460	with a map.
2722460	2729580	Finally, in Java 8, when they introduce streams, streams have a map function.
2729580	2732740	You can go check now.
2732740	2736820	If you Google Java 8 streams, you will see there's a map function.
2736820	2747620	So finally, after like decades and decades, sorry, 20 years of Java and finally, you know,
2747620	2752700	they have map, whereas if they would have listened to the mathematicians, when they
2752700	2758620	designed generics, that should have been built in, because, you know, that gives you again,
2758620	2763660	that is this thing where, you know, a type doesn't come by itself, it comes with properties
2763660	2765900	that it should satisfy.
2765900	2769060	Okay, hey, great.
2769060	2775500	Now we know what a functor is.
2775500	2784940	Now the other thing, if there's category theorists here in the room, I have to be a little bit
2784940	2791100	careful, because what I said is a category was a programming language, and a functor
2791100	2795860	is really something that kind of goes between two categories.
2795860	2801180	So a functor can go between two programming languages.
2801180	2812700	For example, if you have a Java array and a small talk array, then one starts indexing
2812700	2819100	at zero, the other start indexing at one, and now say that I have a method on arrays
2819100	2826820	that sums up the values, when I go from Java to small talk, I have to adjust that sum function
2826820	2829340	to start kind of indexing at one.
2829340	2832180	Okay, that's another example of a functor.
2832180	2835020	But for today, we're only looking at endo functors.
2835020	2837780	Ah, doesn't that sound cool?
2837780	2842740	Endo functors, but an endo functor just means that it stays within one language, it doesn't
2842740	2846060	go between two languages.
2846380	2850420	Okay, good.
2850420	2855460	So this is the Greek decoded.
2855460	2864420	Now I've cheated a little bit already, because in here, you will see when I defined map,
2864420	2871780	I already used the fact that I have a function that I can pass into map.
2871780	2876740	But before Java 8, you couldn't do that, right?
2876740	2881220	Because there were no functional, there were no lambdas, so you could not even define map.
2881220	2887780	So we had to wait until Java 8 in order to have functions such that we can define map.
2887780	2892660	But we're not there yet, because we were trying to kind of come up with how do I represent
2892660	2897140	methods as first-class objects, how do I do lambdas?
2897140	2908380	Okay, and lambdas reminds me, Eric, yes, that's what exponentials are for.
2908380	2910460	Okay, let's go there.
2910460	2913700	Okay, here was the Greek.
2913700	2922020	Okay, blah, blah, blah, there's this object, there's a morphism, eval, blah, blah, blah.
2922020	2929580	Okay, now then this diagram has to commute, and there we see our lambdas, so we're getting
2929580	2930580	close.
2930580	2937740	So let's turn this into reality.
2937740	2944260	And of course, church, or this is Haskell B. Curry, will say, oh, but this is currying
2944260	2945260	in Haskell.
2945260	2950700	If you look here, you know, what this is doing here, this is called eval, blah, blah, blah.
2950700	2958500	It's just currying, and Mr. H has seen this already, and he thought, yeah, when did I
2958500	2963620	start doing Haskell in 1986, when did Haskell want to come out?
2963620	2969140	I already did currying, and all you Java guys can only do it in Java 8.
2969140	2972340	And most of you, oh, most of you were on Java 8.
2972340	2976540	This is very progressive, because I know a lot of companies that are still doing Java
2976540	2979020	6 most of the time.
2979380	2986180	Okay, now here's, you're not Danish, I'm going to go to insult you.
2986180	3000340	But here is Mr. C++, and he's a smart guy, because in 1979, somewhere, you know, you
3000340	3006500	can find that on the web, he explained that there are no instance methods, okay?
3006500	3011860	An instance method is just a static method that takes the dispointer as an additional
3011860	3012860	argument.
3012860	3017700	As I remembered it in the beginning, I said, we're only looking at morphisms as static
3017700	3018700	methods.
3018700	3021460	I'm going to ignore instance methods.
3021460	3023700	It's because Bjarne told me so.
3023700	3028700	Bjarne told me it's safe to ignore instance methods.
3028700	3039580	So an instance method is just a morphism from the tuple of the disk parameter and the other
3039580	3041700	parameter and returns a value.
3041700	3044900	Okay, so that's where the tuples come in.
3044900	3047420	And guess what?
3047420	3050500	Even C++ is lambdas these days.
3050500	3052340	Isn't this amazing?
3052340	3058700	Here I don't think there's any kind of programming languages out there anymore that we all use
3058700	3061220	that don't have lambdas.
3061220	3065700	But it took many, many decades, and why is that?
3065700	3068140	Because we didn't listen to the mathematicians.
3068140	3075020	All right, now it might be the case that in C++ that Bjarne says, you know, there are
3075020	3077620	no instance methods.
3077620	3087260	But let's check what Java has to say.
3087260	3093660	So if you want to have an even more boring document than the Java language specification,
3093660	3098980	you should read the Java virtual machine specification, okay?
3098980	3106820	But in the Java virtual machine specification, if you browse around a little bit and it says,
3106820	3115300	when you call a class method or an instance method here, local variable zero, they start
3115300	3123540	to count at zero, good boys, okay, is always passed to an object that represents the instance,
3123540	3125100	okay?
3125100	3130860	And the subsequent parameters are passed in subsequent local variables starting at one.
3130860	3135740	So also in Java, there are no instance methods.
3135740	3143440	It's just a static method where the first parameter with index zero is the disk, okay?
3143440	3149300	So we can simply forget about instance methods.
3149300	3154660	Now of course, there are a little bit things that I kind of put under the carpet.
3154660	3159660	There's no carpet here, but you know, imagine there was a carpet, it's things like inheritance
3159660	3160940	and so on.
3160940	3169020	So inheritance is an interesting thing because inheritance is quite useful, although some
3169020	3173880	crazy people say we shouldn't use inheritance, we should use composition.
3173880	3180860	If you have any colleagues that say that, make them look bad and have them fired because
3180860	3185940	they are making your life miserable because inheritance is a good thing.
3185940	3191940	But the thing with inheritance is that usually it's explained in terms of the implementation.
3191940	3195260	You start to talk about V tables and whatever.
3195260	3200540	And the reason is because inheritance is a dirty implementation trick to make it easier
3200540	3209580	to reuse code and to model inheritance mathematically is not easy and people write PhD thesis about
3209580	3210580	that.
3210580	3216940	William Cook, maybe you know him, wrote his PhD thesis about the semantics of inheritance.
3216940	3220940	So I'm not going to talk about that today, okay?
3220940	3230180	But let's continue decoding the Greek and now we are somewhere where we can understand
3230180	3231180	what's going on.
3231180	3240780	So to remind you, here's the category theory with the strange notation with the kind of
3240780	3245100	exponentials and there was this lambda, blah, blah, blah.
3245100	3250020	I didn't even bother to kind of go through that because you know, everybody would fall
3250020	3258020	asleep after a few hot dogs and hamburgers, but now we are something that we can understand.
3258020	3269380	So here, a function type here together with a method apply is a function, we call that
3269380	3272140	a function type.
3272140	3281260	If given any type A and a method M that takes an argument of type B and returns a C, defined
3281260	3289860	on A and remember that if I have a method that's defined on A, it's really that M has
3289860	3296580	type A as the first argument and B as the second argument, okay?
3296580	3303060	Now what we can do is there's a factory method that takes an A and that factory method looks
3303060	3312420	like colon, colon, M and it returns a function from B to C and that function object itself
3312420	3320260	has an apply method such that when I apply that to B, that is the same as calling M on
3320260	3327860	A and passing it B and then here I just cast to C so that you can show that it's the same,
3327860	3328860	okay?
3329860	3335420	Anybody here has used method reference in Java, if you use IntelliJ, it will tell you
3335420	3336420	all the time, right?
3336420	3341420	You write something and it says, I can refactor this into a method reference, do you use that?
3341420	3344580	Anybody here uses IntelliJ?
3344580	3346580	What is your name?
3346580	3347580	Paul?
3347580	3354540	Ah, finally a name I can pronounce, Paul, do you ever use refactor change into method
3354540	3355540	reference?
3355540	3361020	Yes, and do you recognize this kind of double colon crazy thing?
3361020	3367700	So you have been using exponential objects, did you realize that?
3367700	3373460	So now you can go to your boss and say in full cafe, I learned that I'm freaking using
3373460	3380500	exponential objects from category tier in my coding, I need a raise because that son
3380500	3386580	of a bitch next to me has no clue what they're doing, they're still using whatever virtual
3386580	3396300	methods but I know exponential objects, good, but it's amazing.
3396300	3405260	Function references, method references in Java are exactly the same as exponential objects
3405260	3413540	in category tier because the only thing I've done here is translate the Greek into Java
3413540	3415700	code, right?
3415700	3419540	So why did it take so long?
3419540	3426580	They could have sat down, done the same thing as I did, came up with this, said, hey, dude,
3426580	3430380	let's hire somebody to implement this in the compiler and we're done.
3431140	3438260	Okay, but I must say I find this pretty amazing because I'm 100% sure that the Java language
3438260	3448740	designers had no idea of category theory but yet they came up with exactly the same solution.
3448740	3451020	That is the amazing thing, okay?
3451020	3459140	So it must be some universal truth here because otherwise you would not two completely independent
3459140	3465940	people, one from theory, one from practice, come up with the same idea.
3465940	3472460	So if you look at here, if I have a method reference and I call the apply method on that
3472460	3480180	with argument of type B, that is the same as calling the method M on A, passing it B.
3480180	3482660	That is how method references work.
3482660	3486900	This is how category tier works, this is how exponential objects work.
3487900	3491380	I mean, this is a miracle.
3491380	3499780	I don't know about you, but when I discovered this, I don't know, I drank a whole bottle
3499780	3502300	of this stuff.
3502300	3509460	I don't know what this is, this is rum, I drank a neighbor, you know, that's kind of
3509460	3513220	the Dutch vodka, okay?
3513220	3516180	But this is great.
3516180	3524260	Now you can say, great, we now know that method references are exponential objects, okay?
3524260	3529300	So tomorrow when you go back to work, you're saying, let's do some kind of, let's introduce
3529300	3532100	some exponentials and IntelliJ can help us with that.
3532100	3535020	No, don't say that, you kind of use that.
3535020	3541180	But here's Eric Meyer and he has not mentioned the M word yet.
3541180	3544380	I have not mentioned monads yet.
3544380	3552260	So I'm going to do a little bit, yes, now I have, before as well.
3552260	3557900	When I was talking about Haskell, yes, that's true, but that was more like a joke.
3557900	3562500	Okay, now let's look at this thing.
3562500	3570780	So if you look at this exponential object, blah, blah, blah, there's a right adjoint
3570780	3572620	and there's home sets.
3572620	3575900	Now home sets have nothing to do with fish eggs.
3575900	3581140	I don't know, is that the same in Swedish, home in Dutch, that's kind of the eggs of
3581140	3583860	a fish, like caviar.
3583860	3587100	This has nothing to do with caviar, okay?
3587100	3594940	It just says that if I have a function from x to y to z, that is kind of isomorphic to
3594940	3599540	having a function that takes x and y and returns z, okay?
3599540	3605900	So this is really saying that you can curry and uncurry and go in two directions, okay?
3605900	3614260	And a home set, home A, B is just a fancy way of saying all morphisms from A to B,
3614260	3615260	okay?
3615260	3618580	So this is just a fancy thing.
3618580	3625220	And the method, the magic of method references is really what it's saying, right?
3625220	3632740	It's saying that, you know, there's an isomorphism between the lambda expression B arrow A, method
3632740	3638620	reference B and this method call here.
3638620	3644420	So there's nothing kind of really fancy about this.
3644420	3648500	And then, you know, we can kind of talk about adjoints because that was the other thing
3648500	3649500	in there.
3649500	3655700	For an adjoint, I have to have two functors and in our case, it's this.
3655700	3661240	And to really prove that I'm not talking nonsense, you know, here's some real code that actually
3661240	3665660	executes if you use Scala.
3665660	3673140	But now, here's the thing, that if you have two of these adjoint functors and these are
3673140	3679660	the conversions between them, that gives rise to a monad.
3679660	3687420	So we came from exponential objects, there came this notion of adjoint functors.
3687420	3690180	And once you have adjoint functors, you get monads.
3690180	3692460	So there's no escape from the monads.
3692460	3699540	So in the end, everybody will be like Mr. H, because, you know, now that Java 8 has
3699540	3704180	exponentials, the next thing it will have are monads.
3704180	3707180	Because that's what category theory predicts.
3707180	3713940	And I went through this real quick, but I tell you, 10 years from now, 20 years from
3713940	3719260	now, this will be the case.
3719260	3725580	Java will have monads, because monads are related to adjunctions and adjunctions come
3725580	3728500	from exponentials.
3728500	3737620	Now the funny thing is that the state monad comes from this adjunction there, but that's
3737620	3740300	a topic for a different talk.
3740300	3749980	So here's the next thing, when you have a lot of beer tonight, this will be your next
3749980	3753220	tattoo, okay?
3753220	3758380	So category theory here directly corresponds to Java.
3758380	3763980	And if this is a little bit too dark for you, what about this one?
3763980	3765940	This one looks cute, right?
3765940	3776300	And I made a special deal with Liz's tattoo parlor, where if you show your Foucaffé t-shirt,
3776300	3787140	you will get a discount on any of those two tattoos.
3787140	3787980	Thank you very much.
