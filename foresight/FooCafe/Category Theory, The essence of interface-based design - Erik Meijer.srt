1
00:00:00,000 --> 00:00:21,840
What we're going to do tonight is to celebrate, of course, the three-year anniversary of Foucafé.

2
00:00:21,840 --> 00:00:29,240
And also we're going to give a tribute to Joachim Lambeck, who is a kind of category

3
00:00:29,240 --> 00:00:34,840
theorist that kind of made the connection between the lambda calculus and category theory.

4
00:00:34,840 --> 00:00:39,560
And, funnily, his name kind of, you know, has the same prefix as the lambda calculus.

5
00:00:39,560 --> 00:00:41,400
That isn't that a coincidence.

6
00:00:41,400 --> 00:00:42,840
I don't know.

7
00:00:42,840 --> 00:00:51,200
But anyway, so just in the spirit of deliberate and continuous learning, you know, like, who

8
00:00:51,200 --> 00:00:54,360
here uses Java 8?

9
00:00:54,360 --> 00:00:55,360
A few people.

10
00:00:55,360 --> 00:00:59,120
Who here uses Java 6?

11
00:00:59,120 --> 00:01:00,760
A few people as well.

12
00:01:00,760 --> 00:01:08,880
So it has taken, like, many, many years before Java 6 became Java 8 and added lambdas.

13
00:01:08,880 --> 00:01:16,440
Now if the language designers would have practiced deliberate and continuous learning, it would

14
00:01:16,440 --> 00:01:21,720
have happened, like, you know, decades ago, because all this knowledge was already developed

15
00:01:21,720 --> 00:01:24,960
by people like Lambeck.

16
00:01:24,960 --> 00:01:30,600
And tonight I'm going to tell you the tricks how you, as a developer, can tap into the

17
00:01:30,600 --> 00:01:37,440
brains of mathematicians and kind of steal their ideas such that, you know, you can become

18
00:01:37,440 --> 00:01:42,400
a better developer and then go to your boss and ask for more money, because you're an

19
00:01:42,400 --> 00:01:44,400
awesome developer.

20
00:01:44,400 --> 00:01:46,200
All right.

21
00:01:46,200 --> 00:01:49,360
Let's get started.

22
00:01:49,360 --> 00:01:51,280
Oops.

23
00:01:51,280 --> 00:01:57,000
So one of my guilty pleasures is I read language specifications.

24
00:01:57,000 --> 00:02:02,120
So some of you kind of, you know, might read novels or newspapers, maybe.

25
00:02:02,120 --> 00:02:04,200
I read language specifications.

26
00:02:04,200 --> 00:02:06,640
And for a while I was collecting them.

27
00:02:06,640 --> 00:02:12,840
I had a whole bunch of, you know, going all the way back to, you know, the early Lisp,

28
00:02:12,840 --> 00:02:16,160
1.0 manual, Pascal, everything.

29
00:02:16,160 --> 00:02:20,640
So whenever there was a new language, I would read the language manual.

30
00:02:20,640 --> 00:02:29,880
So I read all of them, Visual Basic, C-Sharp, ECMAScript, Swift, Dart, you name it.

31
00:02:29,880 --> 00:02:35,840
But there's one language specification that even for me was too strong.

32
00:02:35,840 --> 00:02:38,200
It was impossible to read.

33
00:02:38,200 --> 00:02:43,840
And that language specification is Java 8.

34
00:02:43,840 --> 00:02:51,320
Now I don't know, anyone, has anyone here ever looked at the Java language specification?

35
00:02:51,320 --> 00:02:52,560
Okay.

36
00:02:52,560 --> 00:02:54,120
Did you fall asleep immediately?

37
00:02:54,120 --> 00:02:56,480
I mean, you open up this thing and you fall asleep.

38
00:02:56,480 --> 00:03:00,960
I mean, it's like, try it, you know, some, you know, and you kind of cannot sleep at

39
00:03:00,960 --> 00:03:01,960
night.

40
00:03:01,960 --> 00:03:02,960
Your kind of mind is wandering.

41
00:03:02,960 --> 00:03:04,600
Just open that thing up.

42
00:03:04,600 --> 00:03:08,720
It will work better than any pill.

43
00:03:08,720 --> 00:03:10,760
And this one in particular is really weird.

44
00:03:10,760 --> 00:03:15,960
So when Java 8 came out, and there's this kind of weird thing with method references,

45
00:03:15,960 --> 00:03:19,680
so I thought, I really want to understand this.

46
00:03:19,680 --> 00:03:24,400
So I started to read the language pack.

47
00:03:24,400 --> 00:03:29,360
It doesn't, my goodness, it's just way too complicated.

48
00:03:29,360 --> 00:03:32,360
So what do I do?

49
00:03:32,360 --> 00:03:39,600
When something is complicated, I'm always listening to this guy.

50
00:03:39,600 --> 00:03:44,480
This is Leslie Lamport, and he won the Turing Award last year.

51
00:03:44,480 --> 00:03:45,480
Okay.

52
00:03:45,480 --> 00:03:49,440
Well, if you win the Turing Award, well, that means something.

53
00:03:49,440 --> 00:03:56,920
And one of the kind of advice that Lamport gives us is that we should kind of do more

54
00:03:56,920 --> 00:03:57,920
math.

55
00:03:57,920 --> 00:03:59,360
We should use more math.

56
00:03:59,360 --> 00:04:04,160
If you're like a mechanical engineer, you build, or like a civil engineer, you build

57
00:04:04,160 --> 00:04:08,000
a bridge or something, you use math, okay?

58
00:04:08,000 --> 00:04:11,000
If you're a chemist, you use math.

59
00:04:11,000 --> 00:04:15,680
But we as computer scientists seem to be afraid of mathematics.

60
00:04:15,680 --> 00:04:20,800
And what Lamport says, and what I will tell you, is you shouldn't be afraid.

61
00:04:20,800 --> 00:04:29,480
And I think a lot of people here, I don't know, maybe, you know, in Sweden, it's different.

62
00:04:29,480 --> 00:04:33,640
You're not afraid of math, you know, you, instead of language specifications, you read

63
00:04:33,640 --> 00:04:37,120
like books on calculus before you go to bed, I'm pretty sure.

64
00:04:38,120 --> 00:04:44,480
Typically, when I meet developers, they are kind of afraid of mathematics.

65
00:04:44,480 --> 00:04:48,640
And I think there's several reasons for that, and those are good reasons.

66
00:04:48,640 --> 00:04:54,720
First of all, mathematics, most textbooks are really bad.

67
00:04:54,720 --> 00:04:59,480
The notation is weird, it doesn't even type check, you know, if you're trying to kind

68
00:04:59,480 --> 00:05:04,600
of, you know, look at it, it doesn't work.

69
00:05:04,600 --> 00:05:09,320
The lingo is weird, they have all their own terms.

70
00:05:09,320 --> 00:05:13,240
They often, you kind of end up in a rabbit hole, you know, you want to kind of know a

71
00:05:13,240 --> 00:05:18,960
little bit, and before you know it, you know, you're kind of, you know, deep into all kind

72
00:05:18,960 --> 00:05:24,000
of Greek symbols and other dirty pictures.

73
00:05:24,000 --> 00:05:31,120
And last but not least, often mathematics is taught in a bottom up way, okay?

74
00:05:31,120 --> 00:05:36,000
So you cannot say, I need to solve a particular problem, and I need a piece of mathematics

75
00:05:36,000 --> 00:05:37,000
for that.

76
00:05:37,000 --> 00:05:39,600
No, instead, they start bottom up.

77
00:05:39,600 --> 00:05:45,440
So you have to first know a whole bunch of mathematics before, finally, you can apply

78
00:05:45,440 --> 00:05:47,200
it to your problem.

79
00:05:47,200 --> 00:05:53,320
Whereas with computing, we typically teach the other way around.

80
00:05:53,320 --> 00:05:56,240
Who here has a computer science degree?

81
00:05:56,240 --> 00:05:59,640
Okay, I would say about half.

82
00:05:59,640 --> 00:06:05,880
So the other people don't have a computer science degree, they still know how to program,

83
00:06:05,880 --> 00:06:12,800
but they didn't start by studying, you know, big O, they didn't start to study touring

84
00:06:12,800 --> 00:06:13,800
machines.

85
00:06:13,800 --> 00:06:18,040
No, they just opened up an editor and started to hack.

86
00:06:18,040 --> 00:06:20,680
They did it top down.

87
00:06:20,680 --> 00:06:25,520
And of course, at some point, you will feel that maybe you need a little bit more theory,

88
00:06:25,520 --> 00:06:28,920
but programming is typically taught top down.

89
00:06:28,920 --> 00:06:35,960
So you don't start with all the theory, but no, you start by solving a particular problem,

90
00:06:35,960 --> 00:06:36,960
and then you go down.

91
00:06:36,960 --> 00:06:40,240
Let me give you a really good example of that.

92
00:06:40,240 --> 00:06:42,240
Linear algebra.

93
00:06:42,240 --> 00:06:47,880
When most people teach linear algebra, they talk about matrices and then you have to multiply

94
00:06:47,880 --> 00:06:53,760
matrices and then you have to kind of do all kind of mechanical, stupid things.

95
00:06:53,760 --> 00:06:56,400
And then you use it to do graphics.

96
00:06:56,400 --> 00:07:02,440
But you know, instead of kind of knowing why you do it, you're kind of manipulating this

97
00:07:02,440 --> 00:07:04,960
kind of low level representation.

98
00:07:04,960 --> 00:07:13,160
Now if you know that a matrix, an m by n matrix is really the representation of a linear function

99
00:07:13,160 --> 00:07:19,360
from a sequence of numbers of length n to a sequence of numbers of length m.

100
00:07:19,360 --> 00:07:23,120
And matrix multiplication is function composition.

101
00:07:23,120 --> 00:07:28,560
So really, when you're doing matrix manipulations, you're doing assembly language programming.

102
00:07:28,560 --> 00:07:32,920
This is completely nonsense that we as humans have to do that.

103
00:07:32,920 --> 00:07:39,240
If instead they would teach linear algebra as a restricted form of functional programming

104
00:07:39,240 --> 00:07:44,600
with some special functions that are linear, which means that they have nice properties,

105
00:07:44,600 --> 00:07:45,840
everything would be easy.

106
00:07:45,840 --> 00:07:50,840
But these are the stupid mathematicians that are too smart for their own sake and they

107
00:07:50,840 --> 00:07:53,160
teach it bottom up.

108
00:07:53,160 --> 00:07:56,200
And then in the end, you know, we scratch our heads.

109
00:07:56,200 --> 00:07:59,760
I scratch my head way too often.

110
00:07:59,760 --> 00:08:02,600
And then we ask ourselves, why is this useful?

111
00:08:02,600 --> 00:08:03,600
All right.

112
00:08:03,600 --> 00:08:06,000
So linear algebra is really easy.

113
00:08:06,000 --> 00:08:09,200
It's just functional programming with linear functions.

114
00:08:09,200 --> 00:08:13,800
Matrix multiplication is function composition done.

115
00:08:13,800 --> 00:08:15,920
Same is true with category theory.

116
00:08:15,920 --> 00:08:21,720
If you look at category theory, it looks scary, just like linear algebra, but it's really

117
00:08:21,720 --> 00:08:22,720
easy.

118
00:08:22,720 --> 00:08:26,280
So let's start looking at that.

119
00:08:26,280 --> 00:08:31,760
So mathematicians often call, this is kind of weird, right?

120
00:08:31,760 --> 00:08:36,200
Mathematicians that give us linear algebra, they look at category theory and say this

121
00:08:36,200 --> 00:08:39,600
is abstract nonsense.

122
00:08:39,600 --> 00:08:46,160
And the reason that they say it's abstract nonsense is because in category theory, proofs

123
00:08:46,160 --> 00:08:50,280
are done in a very abstract way.

124
00:08:50,280 --> 00:08:53,200
So it's, look at what it says here.

125
00:08:53,200 --> 00:09:01,400
It's the study of the general form of mathematical theories without regard to their content.

126
00:09:01,400 --> 00:09:05,960
What that means is that all intuition is taken away.

127
00:09:05,960 --> 00:09:11,520
And you look at the pure, you know, pure general form.

128
00:09:11,520 --> 00:09:19,000
Well, as programmers, we recognize that because whenever we do, whenever we program against

129
00:09:19,000 --> 00:09:22,640
an interface, that's exactly what we're doing.

130
00:09:22,640 --> 00:09:27,280
We're programming against a thing without regard to their content.

131
00:09:27,280 --> 00:09:30,200
We're not programming against a concrete type.

132
00:09:30,200 --> 00:09:33,120
We're programming against the abstract interface.

133
00:09:33,120 --> 00:09:38,680
And then there can be many concrete types that we can plug in, but the program is still

134
00:09:38,680 --> 00:09:40,680
the same.

135
00:09:40,680 --> 00:09:45,680
The other thing that's interesting is that here they talk about proofs.

136
00:09:45,680 --> 00:09:50,960
So you build your proof on these kind of general theories.

137
00:09:50,960 --> 00:09:55,280
Well, there's a very, very interesting thing.

138
00:09:55,280 --> 00:09:57,920
It's called the Curry-Howard isomorphism.

139
00:09:57,920 --> 00:10:01,080
People heard about the Curry-Howard isomorphism.

140
00:10:01,080 --> 00:10:03,960
It's one of the most beautiful ideas I've ever seen.

141
00:10:03,960 --> 00:10:11,520
So Curry-Howard isomorphism says that a type is a theorem and the program is the proof

142
00:10:11,520 --> 00:10:13,800
for that theorem.

143
00:10:13,800 --> 00:10:19,920
Now what means that whenever we're kind of writing code, we're really proving theorems.

144
00:10:19,920 --> 00:10:22,160
So we are like mathematicians.

145
00:10:22,160 --> 00:10:27,880
Or you can say, mathematicians are really developers, that program really, really slow.

146
00:10:28,000 --> 00:10:36,600
It takes them like two decades to kind of write a small proof.

147
00:10:36,600 --> 00:10:40,360
But this Curry-Howard isomorphism is really beautiful.

148
00:10:40,360 --> 00:10:44,400
I don't have time today to talk about it.

149
00:10:44,400 --> 00:10:51,640
But if you take that a little bit further, that's what I'm going to do here is that you

150
00:10:51,640 --> 00:10:56,720
define your theorems in terms of these abstract structures.

151
00:10:56,720 --> 00:11:01,360
And then you write your code in terms of them, so you do your proofs in terms of them.

152
00:11:01,360 --> 00:11:04,600
And so let's continue with that.

153
00:11:04,600 --> 00:11:11,560
And as I said, this is really not foreign to, for us developers, because we do this all

154
00:11:11,560 --> 00:11:12,560
the time.

155
00:11:12,560 --> 00:11:15,040
We do this when we program against interfaces.

156
00:11:15,040 --> 00:11:18,040
We do this when we use design patterns.

157
00:11:18,040 --> 00:11:23,360
I'm pretty sure that most people have that book on their bookshelves.

158
00:11:23,360 --> 00:11:26,360
And I'm also sure that nobody has ever read it.

159
00:11:26,400 --> 00:11:29,760
Because when you read it, you get the feeling, what's going on?

160
00:11:29,760 --> 00:11:33,440
This is all kind of, you know, how did the mathematicians say this?

161
00:11:33,440 --> 00:11:39,520
This is without regard to any actual content, because these design patterns are very abstract

162
00:11:39,520 --> 00:11:42,920
and you can instantiate them for specific purposes.

163
00:11:42,920 --> 00:11:47,320
But that's the beauty of design patterns, because now you can talk about concepts in

164
00:11:47,320 --> 00:11:55,080
a very abstract way, without kind of, you know, being tied to a very concrete implementation.

165
00:11:55,800 --> 00:11:56,800
Okay?

166
00:11:56,800 --> 00:12:03,280
So that's, already I give you a couple of tricks, how to think like a mathematician

167
00:12:03,280 --> 00:12:05,520
and profit from that.

168
00:12:05,520 --> 00:12:09,640
Now, what is category theory?

169
00:12:09,640 --> 00:12:13,560
Well, category theory is embarrassingly simple.

170
00:12:13,560 --> 00:12:17,000
It has two, well, three concepts.

171
00:12:17,000 --> 00:12:24,920
First of all, there's a notion of a category, but a category consists of objects and morphisms.

172
00:12:25,920 --> 00:12:30,200
Now, as I said, mathematicians are weird people.

173
00:12:30,200 --> 00:12:31,760
They use strange lingo.

174
00:12:31,760 --> 00:12:35,120
So let's translate this into programming terminology.

175
00:12:35,120 --> 00:12:41,000
So a category is really a programming language, okay?

176
00:12:41,000 --> 00:12:44,280
And a programming language has types, okay?

177
00:12:44,280 --> 00:12:50,720
Like in Java, there's types, Boolean strings, lists, those are the types.

178
00:12:50,720 --> 00:12:56,360
And then there are morphisms, well, that's just a fancy word for static method.

179
00:12:56,360 --> 00:13:05,960
So morphism from A to B is just a static method that takes a argument of type A and

180
00:13:05,960 --> 00:13:13,080
where there's a value of type B, or equivalently, you can say it's a property.

181
00:13:13,080 --> 00:13:18,600
Now you can ask yourself, well, if you're saying that we're doing programming, why do

182
00:13:18,600 --> 00:13:21,480
I use static methods?

183
00:13:21,480 --> 00:13:23,120
Because we also have instance methods.

184
00:13:23,120 --> 00:13:25,080
Well, we'll come back to that later.

185
00:13:25,080 --> 00:13:31,160
So the whole point of this talk is to kind of, you know, fix this and make this precise.

186
00:13:31,160 --> 00:13:40,080
So mix this notion precise that morphisms in a category are just static methods.

187
00:13:40,080 --> 00:13:41,400
Now look at this.

188
00:13:41,400 --> 00:13:43,280
This is, again, mathematicians.

189
00:13:43,280 --> 00:13:45,560
I told you they're slow programmers.

190
00:13:45,560 --> 00:13:48,840
So here's an example of a programming language.

191
00:13:48,840 --> 00:13:53,200
It's a programming language that has three types, A, B, and C.

192
00:13:53,200 --> 00:13:56,840
So it's like characters, integers, and Booleans.

193
00:13:56,840 --> 00:13:58,480
That's it.

194
00:13:58,480 --> 00:14:03,120
And then, well, if you have three types, then you can define some functions between them.

195
00:14:03,120 --> 00:14:08,760
So for example, I can go from Booleans to characters, and I can have a function from

196
00:14:08,760 --> 00:14:11,440
characters to characters.

197
00:14:11,440 --> 00:14:18,320
Now for these mathematicians, this is so special that they give this language a name, and it's

198
00:14:18,320 --> 00:14:20,440
called bold three.

199
00:14:20,440 --> 00:14:21,440
Okay.

200
00:14:21,440 --> 00:14:28,480
Now imagine if you want to draw this kind of picture for Java, you know, it wouldn't fit,

201
00:14:28,480 --> 00:14:33,400
you know, you would need all the walls here, and, you know, maybe the whole city with graffiti

202
00:14:33,400 --> 00:14:34,400
like this.

203
00:14:34,400 --> 00:14:35,400
Maybe it would look quite nice.

204
00:14:35,400 --> 00:14:36,680
It's like an art project.

205
00:14:36,680 --> 00:14:38,120
But this is kind of mathematicians.

206
00:14:38,120 --> 00:14:44,160
So they are kind of proud that they understand this programming language with three types.

207
00:14:44,160 --> 00:14:45,160
Okay.

208
00:14:45,160 --> 00:14:53,280
Now, of course, once you have types, you can create other types.

209
00:14:53,280 --> 00:14:59,040
And everybody these days seem to want to have tuples.

210
00:14:59,040 --> 00:15:03,400
And Java doesn't have tuples, but there's many libraries that provide tuples.

211
00:15:03,400 --> 00:15:06,760
Anybody here does Android programming?

212
00:15:06,760 --> 00:15:11,560
A few people not so few, what are you Windows phone, maybe?

213
00:15:11,560 --> 00:15:12,560
No.

214
00:15:12,560 --> 00:15:18,080
But if you do Android programming, you know, you know, and even if you don't, this might

215
00:15:18,080 --> 00:15:26,400
be interesting to know, is that in the Android library, there is a type for tuples.

216
00:15:26,400 --> 00:15:31,720
That's so important that even on your Android phone, you need tuples.

217
00:15:31,720 --> 00:15:40,360
And here is some category theory that defines what tuples are in Mathematician speak.

218
00:15:40,360 --> 00:15:45,080
Now you will ask yourself, oh my goodness, where's my beer?

219
00:15:45,080 --> 00:15:47,360
The next beer, this looks kind of horrible.

220
00:15:47,360 --> 00:15:48,360
Okay.

221
00:15:48,360 --> 00:15:54,280
There's like all kind of weird stuff, commuting diagrams, canonical stuff.

222
00:15:54,280 --> 00:15:56,200
I don't even understand this.

223
00:15:56,200 --> 00:16:06,160
So let's take this Greek and let's try to translate this into a language that we all

224
00:16:06,160 --> 00:16:07,160
understand.

225
00:16:07,160 --> 00:16:08,160
Okay.

226
00:16:08,160 --> 00:16:15,520
So here's the first sentence of that definition of tuples.

227
00:16:15,520 --> 00:16:21,960
And it says, let's see be a category with some objects X1 and X2.

228
00:16:21,960 --> 00:16:31,160
Well, as I said, a category corresponds to a programming language and a object corresponds

229
00:16:31,160 --> 00:16:32,160
to a type.

230
00:16:32,160 --> 00:16:39,320
Now, often people confuse objects and instances and whatever.

231
00:16:39,320 --> 00:16:40,520
So let's not be confused.

232
00:16:40,520 --> 00:16:43,880
So that's why I call them types and types have instances.

233
00:16:43,880 --> 00:16:48,320
And whether you want to call the instances objects or the type objects, I don't care.

234
00:16:48,320 --> 00:16:50,200
So that's why I call them types.

235
00:16:50,200 --> 00:16:54,720
And also then it doesn't clash with the objects in the category.

236
00:16:54,720 --> 00:16:55,720
Okay.

237
00:16:55,720 --> 00:17:00,280
Now, what can I do when I have two types?

238
00:17:00,280 --> 00:17:03,120
Well, I can form a tuple.

239
00:17:03,120 --> 00:17:04,840
They don't call it tuples.

240
00:17:04,840 --> 00:17:06,920
They call it a product.

241
00:17:06,920 --> 00:17:07,920
Okay.

242
00:17:07,920 --> 00:17:12,280
So they are going to take these two types, X1 and X2.

243
00:17:12,280 --> 00:17:17,840
They're going to create a new type X, which, you know, they can also write as X1 cross

244
00:17:17,840 --> 00:17:24,360
X2 and then blah, blah satisfies a universal property, blah, blah, blah, blah, blah, blah.

245
00:17:24,360 --> 00:17:26,360
Do you understand this?

246
00:17:26,360 --> 00:17:27,360
No.

247
00:17:27,360 --> 00:17:28,360
Yes.

248
00:17:28,360 --> 00:17:29,360
Good.

249
00:17:29,360 --> 00:17:39,560
There's one person that understands it, great.

250
00:17:39,560 --> 00:17:45,840
So let's go and drill down a little bit into this.

251
00:17:45,840 --> 00:17:50,760
Because I think this picture says, said it much better.

252
00:17:50,760 --> 00:17:59,800
So if I have a tuple or a product, I have two functions that I can use to project the values

253
00:17:59,800 --> 00:18:00,800
out of this tuple.

254
00:18:00,800 --> 00:18:06,000
So I can select the first element and I can select the second one.

255
00:18:06,000 --> 00:18:10,040
Now you can ask yourself, why do they start counting at one?

256
00:18:10,040 --> 00:18:14,080
Because we as developers always, now our index is zero.

257
00:18:14,080 --> 00:18:19,080
And again, these are mathematicians, they don't, they probably never done C programming

258
00:18:19,080 --> 00:18:20,080
or whatever.

259
00:18:20,080 --> 00:18:22,960
So they can start their counting by one.

260
00:18:22,960 --> 00:18:29,400
Anyway, so this is the kind of thing, but then there's all the rest of this.

261
00:18:29,400 --> 00:18:36,200
And what we see here is, well, how on earth do you get an instance of a tuple?

262
00:18:36,200 --> 00:18:40,720
Well, you need a constructor or a factory function.

263
00:18:40,720 --> 00:18:43,240
These mathematicians are not stupid, right?

264
00:18:43,240 --> 00:18:47,840
They know that when you create a type, when you have a type, you all you have to have

265
00:18:47,840 --> 00:18:49,640
a way to create it.

266
00:18:49,640 --> 00:18:56,120
We call it constructor, well, they have here some function that kind of allows you to kind

267
00:18:56,120 --> 00:18:58,840
of create a tuple.

268
00:18:58,840 --> 00:19:06,440
And then they say, well, if you have such a function, which you create from two morphisms,

269
00:19:06,440 --> 00:19:11,640
then if you kind of start with a value here, you apply that to this function.

270
00:19:11,640 --> 00:19:18,360
Now you get this guy, that must be the same as kind of projecting the first value or applying

271
00:19:18,360 --> 00:19:19,360
this function.

272
00:19:19,360 --> 00:19:22,200
So it all must kind of commute.

273
00:19:22,200 --> 00:19:25,800
And that looks quite nice in that diagram.

274
00:19:25,800 --> 00:19:31,840
Now if you don't like diagram, then you can translate it into equations, whatever you

275
00:19:31,840 --> 00:19:34,760
find easier to read.

276
00:19:34,760 --> 00:19:40,040
Now, except for this gentleman over there, what's your name?

277
00:19:41,040 --> 00:19:48,560
Oh, I cannot pronounce that, but generic, good.

278
00:19:48,560 --> 00:19:54,760
Mr. Generic over there, he understands this.

279
00:19:54,760 --> 00:20:00,400
But that's kind of, you know, for the rest of us, you know, whose brains are the size

280
00:20:00,400 --> 00:20:08,680
of peanuts or smaller, let's kind of continue to put this into our language.

281
00:20:08,680 --> 00:20:15,120
So if we go on with this translation, we say that a type A comma B is a product of A and

282
00:20:15,120 --> 00:20:19,480
B or a tuple of A and B, if it satisfies blah, blah, blah.

283
00:20:19,480 --> 00:20:27,960
There exist two properties underscore one and underscore two that return an A and a B respectively.

284
00:20:27,960 --> 00:20:31,800
Any Scala programmers here?

285
00:20:31,800 --> 00:20:33,800
You recognize this?

286
00:20:33,800 --> 00:20:36,760
Yeah, look at this, I see a smile.

287
00:20:36,760 --> 00:20:37,760
Yep.

288
00:20:37,840 --> 00:20:43,600
This is Scala, you can project the first and second element, but then there's also, if

289
00:20:43,600 --> 00:20:48,800
you have two methods, the factory function for this thing takes two methods and it gives

290
00:20:48,800 --> 00:20:55,240
you a function that given a C returns this pair of A and B, and it does that by kind

291
00:20:55,240 --> 00:20:59,560
of applying that C to F and G respectively.

292
00:20:59,560 --> 00:21:06,040
So this is a little bit different than in Scala because the constructor function behaves

293
00:21:06,040 --> 00:21:07,120
a little bit different.

294
00:21:07,120 --> 00:21:12,880
But we can, from this, we can create a normal constructor function too.

295
00:21:12,880 --> 00:21:24,400
Okay, let's go look at this commuting diagram and it's kind of the same.

296
00:21:24,400 --> 00:21:32,560
Now as I said, if you look at Scala, I don't know, I think this mathematics is actually

297
00:21:32,560 --> 00:21:33,560
clearer and shorter.

298
00:21:33,560 --> 00:21:39,560
Because look at this, trade, blah, blah, blah, extends, blah, blah, blah, abstract

299
00:21:39,560 --> 00:21:43,280
this, abstract that, curly open, curly close.

300
00:21:43,280 --> 00:21:48,440
Now you see why these mathematicians have their strange lingo because maybe we have editors

301
00:21:48,440 --> 00:21:54,640
and we have autocomplete, but look at how many characters we need to write down kind

302
00:21:54,640 --> 00:21:58,520
of something simple like this, okay?

303
00:21:58,520 --> 00:22:09,360
But here is you see that this is the definition in Scala of a product and I think this is,

304
00:22:09,360 --> 00:22:12,960
now you can ask yourself what the heck are those pluses there?

305
00:22:12,960 --> 00:22:19,760
Am I going to kind of, I don't know, is this unary plus or no, no, no, that's co and contravariance.

306
00:22:19,760 --> 00:22:26,160
But that's way too complicated, but this is actually the way that products are defined

307
00:22:26,160 --> 00:22:36,080
in Scala, but what Scala doesn't have is this operator to construct a product.

308
00:22:36,080 --> 00:22:44,680
Now the reason why Martin cannot do that is because if you would do that, you already

309
00:22:44,680 --> 00:22:51,560
need the notion of functions as objects and that was the whole point of this presentation

310
00:22:51,560 --> 00:22:59,520
to figure out, you know, how can we make these morphisms into first class things, okay?

311
00:22:59,520 --> 00:23:06,880
So really, you know, if we look at this simple example where we took the idea of tuples and

312
00:23:06,880 --> 00:23:12,720
we have seen how the mathematicians do it and we do it, it's really the same except

313
00:23:12,720 --> 00:23:19,160
that the mathematicians apply a little bit more rigor, they use weird notation, but the

314
00:23:19,160 --> 00:23:25,440
nice thing that they do, that we never do is when they define a type, they talk about

315
00:23:25,440 --> 00:23:30,640
properties of the type, what properties should a product have?

316
00:23:30,640 --> 00:23:38,480
Because if you look at this definition in Scala, right, from here it says nowhere that

317
00:23:38,480 --> 00:23:46,040
when you create a tuple out of two values and you project from that tuple the first

318
00:23:46,040 --> 00:23:50,640
value that you actually get the value that you put in there, right?

319
00:23:50,640 --> 00:23:56,880
Nothing says this here because it can return null for both sides and it's still kind of

320
00:23:56,880 --> 00:24:00,320
according to this type definition a valid implementation of tuple.

321
00:24:00,320 --> 00:24:05,840
Of course, you would not accept that, but the type itself doesn't say anything.

322
00:24:05,840 --> 00:24:11,040
So if you're a smart programmer and somebody gives you this trait and you have to implement

323
00:24:11,040 --> 00:24:16,760
it, you can just return null in both cases, nobody can complain.

324
00:24:16,760 --> 00:24:21,600
If they file a bug, you immediately file the bug back and say you didn't specify this

325
00:24:21,600 --> 00:24:23,480
thing properly, okay?

326
00:24:23,480 --> 00:24:25,280
This is another tip, okay?

327
00:24:25,280 --> 00:24:33,420
You just return null, your colleagues complain, you just say sorry, you know, specify it better.

328
00:24:33,420 --> 00:24:38,440
And then you can go have a drink, a beer, kind of go to another meeting, put that on

329
00:24:38,440 --> 00:24:47,120
your resume, get even more money, look at this, all right, good.

330
00:24:47,120 --> 00:24:56,960
So and here is the, you know, again, a slightly different way to do this function.

331
00:24:56,960 --> 00:25:01,720
I'm going to skip this for lack of time.

332
00:25:01,720 --> 00:25:08,420
Now Mr. Generic here says, oh, I knew this already, but this is old stuff, right?

333
00:25:08,420 --> 00:25:17,700
Here is John McCarthy, the inventor of Lisp, and he says, well, come on, I could define

334
00:25:17,700 --> 00:25:22,280
all this stuff with top polls and so on in 1960.

335
00:25:22,280 --> 00:25:28,820
And then Church, Mr. Alonso Church, who invented the Lambda calculus, he did this already in

336
00:25:28,820 --> 00:25:31,300
1928.

337
00:25:31,300 --> 00:25:38,700
Now look, this guy here came up with this in 1928.

338
00:25:38,700 --> 00:25:44,900
If you read the papers from Church, he was doing this kind of tuples.

339
00:25:44,900 --> 00:25:52,540
In Java 8, it's 2015, last time I checked, there are still no proper tuples in the language.

340
00:25:52,540 --> 00:26:00,740
Look at this, I don't even know, it's like 2015 minus, that's nearly a century, okay?

341
00:26:00,740 --> 00:26:05,340
And we still don't, this thing still doesn't, we are, and why is that?

342
00:26:05,340 --> 00:26:11,020
Because we are afraid of these mathematicians, whereas we should steal their ideas and profit

343
00:26:11,020 --> 00:26:13,380
from them, okay?

344
00:26:13,380 --> 00:26:15,620
That's really kind of my message today.

345
00:26:15,620 --> 00:26:20,740
These people are smart, look at this size of this brain here, you know, if I put my

346
00:26:20,740 --> 00:26:27,540
head next to it, it's like 10 times the size, we should leverage that.

347
00:26:27,540 --> 00:26:30,140
But what do we do instead?

348
00:26:30,140 --> 00:26:36,300
Well first of all, we are proud that, you know, we don't do theory.

349
00:26:36,300 --> 00:26:42,900
So if you look at C-Sharp, C-Sharp has delegates, and it's like we don't need any of this theory,

350
00:26:42,900 --> 00:26:44,820
we have delegates.

351
00:26:44,820 --> 00:26:47,860
But where, you know, where does these delegates come from?

352
00:26:47,860 --> 00:26:48,860
What are their properties?

353
00:26:48,860 --> 00:26:49,860
We don't know.

354
00:26:49,860 --> 00:26:54,700
And then, I don't know if anybody's old enough, probably most of you were not born yet, but

355
00:26:54,700 --> 00:27:00,500
when C-Sharp came out, there was a little fight between C-Sharp and Java, where the

356
00:27:00,500 --> 00:27:06,540
Java folks said, we don't need any of this lambdas or delegate stuff because we have

357
00:27:06,540 --> 00:27:08,660
virtual methods.

358
00:27:08,660 --> 00:27:13,700
And so this is another lesson, never say never, okay?

359
00:27:13,700 --> 00:27:18,620
Because I think, because they didn't want to lose face for the longest time, Java could

360
00:27:18,620 --> 00:27:27,260
not add lambdas because, you know, James Gosling said in public that lambdas are unnecessary.

361
00:27:27,260 --> 00:27:30,140
So then you're not going to kind of turn around and add them.

362
00:27:30,140 --> 00:27:31,140
No.

363
00:27:31,140 --> 00:27:35,380
So first of all, he had to kind of retire, kind of join Google, join whatever company

364
00:27:35,380 --> 00:27:36,380
is now at.

365
00:27:36,380 --> 00:27:39,300
I think he's doing self-driving cars at Stanford.

366
00:27:39,300 --> 00:27:47,580
And finally, they could put delegates lambdas into Java.

367
00:27:47,580 --> 00:27:53,060
But the other thing is also, you should not kind of downplay and be arrogant and downplay

368
00:27:53,060 --> 00:27:54,060
theory.

369
00:27:54,060 --> 00:27:55,060
Okay?

370
00:27:55,060 --> 00:27:57,740
You should always stay humble and hungry.

371
00:27:57,740 --> 00:28:00,260
You always want to learn.

372
00:28:00,260 --> 00:28:05,060
If these mathematicians come up with something, you know, but you better have a look at it

373
00:28:05,060 --> 00:28:07,900
because maybe it's something that you can use.

374
00:28:07,900 --> 00:28:09,500
All right.

375
00:28:09,500 --> 00:28:14,940
But then you can say, come on, Eric, what are you talking about?

376
00:28:14,940 --> 00:28:22,660
Customers and categories represent mathematical objects, whereas we as developers, we deal

377
00:28:22,660 --> 00:28:30,220
with objects that represents real-world things, okay, like customers and orders and all kind

378
00:28:30,220 --> 00:28:36,900
of other boring things that we have to do in our day jobs and rather not do, okay?

379
00:28:36,900 --> 00:28:42,340
But that's also not true because most of our programs that we like to write when we don't

380
00:28:42,340 --> 00:28:44,260
have to do customers and orders.

381
00:28:44,260 --> 00:28:50,180
Our data structures, list, trees, those don't represent real-world objects.

382
00:28:50,180 --> 00:28:52,140
I've never seen a list.

383
00:28:52,140 --> 00:28:58,180
I've seen trees in the real world, but they're not like the trees that I have in my code,

384
00:28:58,180 --> 00:28:59,180
right?

385
00:28:59,180 --> 00:29:07,100
And maybe lists a little bit, although, you know, the lists that I have on my refrigerator

386
00:29:07,100 --> 00:29:08,860
never get garbage collected.

387
00:29:08,860 --> 00:29:13,260
They never get finished, whereas the lists in my computer always kind of, you know, end

388
00:29:13,260 --> 00:29:14,980
up kind of disappearing.

389
00:29:14,980 --> 00:29:25,580
So, all right, but anyway, so I think that this whole idea that objects represent real-world

390
00:29:25,580 --> 00:29:32,500
things is nonsense because most objects that we deal with in programming don't represent

391
00:29:32,500 --> 00:29:36,020
real-world objects.

392
00:29:36,020 --> 00:29:42,100
And the other thing is that what we can learn, so what we can learn from these mathematicians

393
00:29:42,100 --> 00:29:47,740
is that we should be more careful in formalizing the things that we deal with.

394
00:29:47,740 --> 00:29:55,820
For example, if we write code in Java, we deal with methods, but these methods themselves,

395
00:29:55,820 --> 00:30:00,700
you know, we don't have an object that represents them.

396
00:30:00,700 --> 00:30:01,700
Is that true?

397
00:30:02,140 --> 00:30:07,660
Well, that's what we're after, but I'll say something more about it later.

398
00:30:07,660 --> 00:30:12,660
But the other thing that we can learn from the mathematicians is that we should also

399
00:30:12,660 --> 00:30:17,780
be more careful that when we define a type that we think about the properties, because

400
00:30:17,780 --> 00:30:24,220
otherwise some smart-ass colleagues of you can always return null and then claim that

401
00:30:24,220 --> 00:30:30,860
this is a proper implementation, because you have not specified with that type what the

402
00:30:30,860 --> 00:30:33,140
properties are, okay?

403
00:30:33,140 --> 00:30:40,660
And the good thing is that we don't have like weird terminology, although if you use UML

404
00:30:40,660 --> 00:30:44,940
and all that stuff, I guess there's plenty of craziness there.

405
00:30:44,940 --> 00:30:52,700
Now, this is, I'm a big fan of Bertrand Meyer, he's not related because his last name is

406
00:30:52,700 --> 00:30:59,860
with a Y and mine is with IJ, but he has a great saying where he says that, you know,

407
00:30:59,860 --> 00:31:04,380
objects don't really represent real-world things because you're always kind of removed.

408
00:31:04,380 --> 00:31:09,660
Even if you have a person object, it doesn't really represent a person because it's something

409
00:31:09,660 --> 00:31:13,860
in the memory of your computer that represents a person.

410
00:31:13,860 --> 00:31:19,500
So you're all kind of ready twice removed from reality, okay?

411
00:31:19,500 --> 00:31:26,540
So let's just forget about that and just look at objects in programming as formal things

412
00:31:26,540 --> 00:31:30,300
just like mathematical objects.

413
00:31:30,300 --> 00:31:36,820
All right, now I've been talking about programming, I thought this was about category theory.

414
00:31:36,820 --> 00:31:46,140
Now, the thing before we go there is we do have a way to talk about methods as objects

415
00:31:46,140 --> 00:31:49,460
and that is with reflection, okay?

416
00:31:49,460 --> 00:31:53,700
Because if you do reflection in Java, you can kind of, you know, go to a type, get this

417
00:31:53,700 --> 00:31:57,500
method and you can even invoke that method using reflection.

418
00:31:57,500 --> 00:32:03,340
Now, reflection, if you think about it, is super complex because it's a program that

419
00:32:03,340 --> 00:32:06,060
can reason about itself.

420
00:32:06,060 --> 00:32:09,060
Most of us are not even able to reason about ourselves.

421
00:32:09,060 --> 00:32:14,900
You know, when we're acting foolishly in public after we've been kind of, you know, partying,

422
00:32:14,900 --> 00:32:15,900
are we reflecting?

423
00:32:15,900 --> 00:32:18,140
No, typically not.

424
00:32:18,140 --> 00:32:21,220
Or maybe we do sometimes.

425
00:32:21,580 --> 00:32:28,660
But code, it's amazing that we can write code that kind of reflects about itself and the

426
00:32:28,660 --> 00:32:33,020
mathematicians cannot do that.

427
00:32:33,020 --> 00:32:39,860
But reflection is kind of a cop out because with reflection, we're not really kind of

428
00:32:39,860 --> 00:32:44,420
having an object that represents a method because it's kind of, you know, in the kind

429
00:32:44,420 --> 00:32:47,580
of dream world of reflection.

430
00:32:47,580 --> 00:32:53,060
And what we're trying to do here with lambdas or with methods references, we're trying

431
00:32:53,060 --> 00:32:59,340
to represent methods as normal objects, not as reflective objects.

432
00:32:59,340 --> 00:33:03,900
Oh, my goodness.

433
00:33:03,900 --> 00:33:04,900
This has to come.

434
00:33:04,900 --> 00:33:05,900
Okay.

435
00:33:05,900 --> 00:33:09,700
Dave Thomas, small talk, everybody knows Dave Thomas.

436
00:33:09,700 --> 00:33:10,700
Okay.

437
00:33:10,700 --> 00:33:11,700
Small talk guy.

438
00:33:11,700 --> 00:33:16,460
Of course, what do small talk people say?

439
00:33:16,460 --> 00:33:21,620
And I was a young boy and we read a small talk was still popular.

440
00:33:21,620 --> 00:33:24,420
That was a long time ago.

441
00:33:24,420 --> 00:33:29,500
We already had blocks that blocks are things that represent methods.

442
00:33:29,500 --> 00:33:35,060
And that's quite remarkable because if you look at small talk, that is very much as the

443
00:33:35,060 --> 00:33:40,900
flavor, this anthropomorphic flavor where objects represent real world things where

444
00:33:40,900 --> 00:33:42,700
you send messages to it.

445
00:33:42,700 --> 00:33:50,180
But still, they already knew that they had to represent methods as objects themselves.

446
00:33:50,180 --> 00:33:51,580
Okay.

447
00:33:51,580 --> 00:33:52,860
But don't worry.

448
00:33:52,860 --> 00:33:56,180
I won't talk about small talk.

449
00:33:56,180 --> 00:34:02,740
And the reason is that in small talk, like what we saw here in mathematics, array indexes

450
00:34:02,740 --> 00:34:10,700
start with one, which as a Dutch person is unacceptable because the big extra as told

451
00:34:10,700 --> 00:34:14,020
us that indexes should start at zero.

452
00:34:14,020 --> 00:34:16,620
And you know the reason why?

453
00:34:16,620 --> 00:34:20,100
Because when he is kind of, you know, that's why I'm kind of doing this papers.

454
00:34:20,100 --> 00:34:23,420
The first paper, there are zero papers here.

455
00:34:23,420 --> 00:34:25,740
So that's why it's zero.

456
00:34:25,740 --> 00:34:28,540
And now the second paper, now it's two.

457
00:34:28,540 --> 00:34:33,100
So you see that's how he can because he always wrote his, his papers by hand.

458
00:34:33,100 --> 00:34:36,940
And so he counted like how many papers were already there.

459
00:34:37,340 --> 00:34:37,940
Okay.

460
00:34:37,940 --> 00:34:41,660
So now you know why you should be counting that with zero.

461
00:34:41,660 --> 00:34:44,660
Okay.

462
00:34:44,660 --> 00:34:55,460
Now let's kind of talk about why we are really here is how do we represent methods as objects?

463
00:34:55,460 --> 00:34:59,940
And again, category theorists have a fancy word for that.

464
00:34:59,940 --> 00:35:02,500
They call it exponentials.

465
00:35:02,500 --> 00:35:06,140
And then you can ask yourself, why do they call it exponentials?

466
00:35:06,140 --> 00:35:09,460
Why don't they call it lambdas or anything normal?

467
00:35:09,460 --> 00:35:16,380
Like in TypeScript, you know, arrow functions or, I don't know, blocks.

468
00:35:16,380 --> 00:35:19,620
Well, there's actually a good reason.

469
00:35:19,620 --> 00:35:25,220
But if we look at this, I don't know, I see people already except for Mr.

470
00:35:25,220 --> 00:35:27,460
Generic here.

471
00:35:27,460 --> 00:35:30,740
He's like, oh yes, yeah.

472
00:35:30,740 --> 00:35:33,060
This is like, you know, beautiful.

473
00:35:33,060 --> 00:35:34,020
This is beautiful.

474
00:35:34,020 --> 00:35:38,820
For the rest of us, it looks a little bit like, look at this.

475
00:35:38,820 --> 00:35:41,740
There's even now two diagrams here.

476
00:35:41,740 --> 00:35:42,020
Okay.

477
00:35:42,020 --> 00:35:43,220
But I see a lambda.

478
00:35:43,220 --> 00:35:44,060
Can you see that here?

479
00:35:44,060 --> 00:35:47,260
It's like, you know, the font is not so sharp, but there's a lambda.

480
00:35:47,260 --> 00:35:49,620
So we're in the right direction.

481
00:35:49,620 --> 00:35:52,940
So let's decode the Greek and let's zoom in.

482
00:35:52,940 --> 00:35:58,180
So it says, let's see be a category with binary products.

483
00:35:58,180 --> 00:36:03,300
So that's the reason why we started out with tuples because in order to do functions,

484
00:36:03,300 --> 00:36:04,580
we need them.

485
00:36:04,580 --> 00:36:08,860
That was a little bit of the foresight of me.

486
00:36:08,860 --> 00:36:17,620
And let Y and CB objects, the exponential object, Z to the power of Y.

487
00:36:17,620 --> 00:36:18,580
Oh my goodness.

488
00:36:18,580 --> 00:36:19,940
Why?

489
00:36:19,940 --> 00:36:25,780
This is why they're called exponentials because they write it as an exponent.

490
00:36:25,780 --> 00:36:30,260
It's defined, blah, blah, blah, and then there's a new word, functor.

491
00:36:30,260 --> 00:36:36,900
Oh, I thought that we were ready because I kind of cheated by doing these products first.

492
00:36:36,900 --> 00:36:39,980
But now we kind of have another hurdle here.

493
00:36:39,980 --> 00:36:43,620
I have to explain to you what functors are.

494
00:36:43,620 --> 00:36:54,300
But first, let me kind of explain a little bit why this notation of exponentials makes sense.

495
00:36:54,300 --> 00:36:59,540
And the reason is that if I have a function from a type,

496
00:36:59,580 --> 00:37:08,420
Y to a type Z, that there are Z to the power of Y possible functions.

497
00:37:08,420 --> 00:37:16,380
Okay, so if I have two types, Y and Z, and I take all the functions from Y to Z,

498
00:37:16,380 --> 00:37:19,620
then there are Z to the power of Y of them.

499
00:37:19,620 --> 00:37:21,620
Now, how can I remember that?

500
00:37:21,620 --> 00:37:24,260
Okay, I see somebody here puzzled.

501
00:37:24,260 --> 00:37:27,180
Okay, now let's do the simplest case.

502
00:37:27,180 --> 00:37:33,340
Let's say that Y, so this is a function from Y to Z.

503
00:37:33,340 --> 00:37:38,780
So now let's take Y to be unit, okay, or void.

504
00:37:38,780 --> 00:37:40,580
So there's only one value.

505
00:37:40,580 --> 00:37:45,060
And let take Z be booleans, true and false.

506
00:37:45,060 --> 00:37:50,060
So how many functions are there from void to boolean?

507
00:37:50,060 --> 00:37:50,940
Only two.

508
00:37:50,940 --> 00:37:55,780
I can go from void to true and from void to false.

509
00:37:55,780 --> 00:38:02,820
Okay, now how many functions are there from booleans to unit?

510
00:38:02,820 --> 00:38:08,060
Well, there's only one that maps true to unit and false to unit.

511
00:38:08,060 --> 00:38:11,180
Okay, those are mathematical functions.

512
00:38:11,180 --> 00:38:17,780
Now you can say in Java, how many functions are there from bool to unit?

513
00:38:17,780 --> 00:38:18,540
How many?

514
00:38:18,540 --> 00:38:25,140
Because I can do print line, you know, of that boolean and that returns unit.

515
00:38:25,140 --> 00:38:32,300
I can kind of, you know, send it with an HTTP request to whatever, get it back.

516
00:38:32,300 --> 00:38:33,620
That's another function.

517
00:38:33,620 --> 00:38:36,100
I can do reflection over the boolean.

518
00:38:36,100 --> 00:38:37,980
So there's many functions.

519
00:38:37,980 --> 00:38:45,980
And this is why in Java, a method, so I'm a little bit lying because a method,

520
00:38:45,980 --> 00:38:52,060
you know, of bool to unit is not really a function because there can be side effects.

521
00:38:52,060 --> 00:38:58,620
There's a lot of context that's hidden in Java that you can use as a programmer to kind

522
00:38:58,620 --> 00:39:04,940
of cheat and don't show that, you know, that doesn't show up in the signature.

523
00:39:04,940 --> 00:39:09,540
Now, if you're, I don't know if there's any kind of, you know, fundamentalist functional

524
00:39:09,540 --> 00:39:15,180
programmers here, people that, crazy people that like Haskell and no Haskell programmers

525
00:39:15,180 --> 00:39:17,500
here, there's one Haskell programmer.

526
00:39:17,500 --> 00:39:18,780
Now he's smiling.

527
00:39:18,780 --> 00:39:19,980
He says, yeah, look at that.

528
00:39:19,980 --> 00:39:21,580
And Haskell, this is true.

529
00:39:21,580 --> 00:39:24,580
No, then your crappy Java, right?

530
00:39:24,580 --> 00:39:29,540
Because in Haskell, Haskell functions are really mathematical functions.

531
00:39:29,540 --> 00:39:31,940
So everything is explicit.

532
00:39:31,940 --> 00:39:36,300
But you know, that's why, you know, what is your name?

533
00:39:36,300 --> 00:39:43,340
Oh, my goodness, even, even more complicated than Mr. generic.

534
00:39:43,340 --> 00:39:47,380
Let me call you Mr. H. Mr. H there.

535
00:39:47,380 --> 00:39:52,020
This code is like probably 10 times longer than the Java code.

536
00:39:52,020 --> 00:39:56,420
By the time he's kind of done all his monads and whatever.

537
00:39:56,420 --> 00:40:02,700
So, you know, again, maybe it's good to have him as a colleague, because then you can,

538
00:40:02,700 --> 00:40:06,700
you know, you can learn from him and then write all this code implicitly.

539
00:40:06,700 --> 00:40:11,260
And then he will say, oh, but I can do now my kind of monad transformer with the state

540
00:40:11,260 --> 00:40:14,500
monad and the maybe monad and the list monad.

541
00:40:14,500 --> 00:40:18,900
And by the time he has figured out how to compose all these monads, you're already here

542
00:40:18,900 --> 00:40:23,900
at Foucafé listening to your next talk that you can put on your resume.

543
00:40:23,900 --> 00:40:25,780
And you get ahead.

544
00:40:25,780 --> 00:40:27,500
Isn't that great?

545
00:40:27,500 --> 00:40:28,500
Okay.

546
00:40:28,500 --> 00:40:29,500
Good.

547
00:40:29,500 --> 00:40:34,980
Let's translate this into normal language.

548
00:40:34,980 --> 00:40:40,540
Let L be a language that supports tuples, okay?

549
00:40:40,540 --> 00:40:42,700
That's already a big step.

550
00:40:42,700 --> 00:40:48,980
And let's assume that Java has tuples and let A and B types in the language, a function

551
00:40:48,980 --> 00:40:55,620
A, arrow B, I'm just using normal notation now, can be defined as a factory method from

552
00:40:55,620 --> 00:40:56,620
the functor.

553
00:40:56,620 --> 00:40:57,620
Okay.

554
00:40:57,620 --> 00:41:05,060
So, we're nearly there, but now I have to explain what a functor is because I've removed

555
00:41:05,060 --> 00:41:10,900
all the Greek and I say there's a factory method for functions.

556
00:41:10,900 --> 00:41:16,660
But in order to do that, I need to know what a functor is.

557
00:41:16,660 --> 00:41:18,980
Now what is a functor?

558
00:41:18,980 --> 00:41:24,420
And again, this is why most of us hate mathematics so much because I warned you that you often

559
00:41:24,420 --> 00:41:27,120
go into the rabbit hole, okay?

560
00:41:27,120 --> 00:41:32,380
And now we're going into the rabbit hole a little bit because when you look up functor

561
00:41:32,380 --> 00:41:35,580
on Wikipedia, it's even more Greek.

562
00:41:35,580 --> 00:41:37,580
Oh my goodness.

563
00:41:37,580 --> 00:41:40,420
Ah, does it ever stop?

564
00:41:40,420 --> 00:41:44,780
Well, let's look at it and it's not that bad.

565
00:41:44,780 --> 00:41:49,100
Let C be a category, a functor, blah, blah, blah, blah, blah, blah, blah, blah, blah.

566
00:41:49,100 --> 00:41:50,100
Okay.

567
00:41:50,100 --> 00:41:53,380
Let's translate this into normal English.

568
00:41:53,380 --> 00:42:00,140
And now we certainly understand it because since Java 6 and it was it, when did Java

569
00:42:00,140 --> 00:42:01,140
get generics?

570
00:42:01,140 --> 00:42:03,140
Was it Java 5?

571
00:42:03,140 --> 00:42:04,140
Wow.

572
00:42:04,140 --> 00:42:05,140
Look at that.

573
00:42:05,140 --> 00:42:08,700
That's a long time ago.

574
00:42:08,700 --> 00:42:12,620
The way they did it, yes.

575
00:42:12,620 --> 00:42:23,620
So here a functor is a generic type that associates with each type A, a new type, C of A. So list

576
00:42:23,620 --> 00:42:31,740
of T is a functor because I can instantiate it with another type, say int, sorry, integer

577
00:42:31,740 --> 00:42:36,820
because generics in Java suck that you can only instantiate them with reference types

578
00:42:36,820 --> 00:42:39,900
and not with base types.

579
00:42:39,900 --> 00:42:41,140
But yes.

580
00:42:41,140 --> 00:42:51,500
And then on that type, there must be a function map that goes from C of A to C of B. Now think

581
00:42:51,500 --> 00:42:53,700
about this.

582
00:42:53,700 --> 00:42:55,500
What does this thing do?

583
00:42:55,500 --> 00:43:01,860
It says that if I go, if I can go, say from integers to string, because I have two string,

584
00:43:01,860 --> 00:43:06,300
right, that goes from integers, from integers to string.

585
00:43:06,300 --> 00:43:12,220
Now if I have a list of integers, I must be able to kind of, you know, do two string

586
00:43:12,220 --> 00:43:15,000
on every element of that list.

587
00:43:15,000 --> 00:43:21,620
And that's all what this thing is saying, that if I can go from int to string, then

588
00:43:21,620 --> 00:43:28,860
I must go from list of int, oh sorry, list of int to list of string.

589
00:43:28,860 --> 00:43:32,100
That is, that's quite reasonable, right?

590
00:43:32,100 --> 00:43:36,780
And when we define generics, so again, here's a trick.

591
00:43:36,780 --> 00:43:44,980
Whenever your colleague defines a generic type, probably they don't specify that this

592
00:43:44,980 --> 00:43:50,420
should hold, that if you have, if you instantiate that generic type with one type, you instantiate

593
00:43:50,420 --> 00:43:54,020
with another that you have to be able to go between them.

594
00:43:54,020 --> 00:43:57,100
Well, they should have a map function.

595
00:43:57,100 --> 00:44:02,900
Now the thing with this map function is that it should have some properties too.

596
00:44:02,900 --> 00:44:08,260
Say that, you know, I'm going from list of int to list of int.

597
00:44:08,260 --> 00:44:10,380
Well, how do I do that?

598
00:44:10,380 --> 00:44:14,260
By doing the identity function, I'm doing nothing on each element.

599
00:44:14,260 --> 00:44:17,580
So that should be delivered the same value, right?

600
00:44:17,580 --> 00:44:19,380
That is kind of reasonable.

601
00:44:19,380 --> 00:44:28,100
The other thing is that if I do a map and then another map, that must be the same as

602
00:44:28,100 --> 00:44:33,500
doing the map with these functions combined, okay?

603
00:44:33,500 --> 00:44:39,180
And this is like an optimization trick, because instead of taking a list of int, going into

604
00:44:39,180 --> 00:44:44,140
a list of string, and then say taking the length of the string, so now getting a list

605
00:44:44,140 --> 00:44:50,620
of int again, I don't have to build that intermediate list, because then I can just map this function

606
00:44:50,620 --> 00:44:51,980
over that list.

607
00:44:51,980 --> 00:44:59,460
So these category theorists also are efficiency freaks, because they say that this map must

608
00:44:59,460 --> 00:45:04,380
have these properties so that they can optimize their code, okay?

609
00:45:04,380 --> 00:45:12,660
So a functor is just a generic function that has a map operator.

610
00:45:12,660 --> 00:45:21,460
Now, in normal Java generics, most functions, most types, most generic types, don't come

611
00:45:21,460 --> 00:45:22,460
with a map.

612
00:45:22,460 --> 00:45:29,580
Finally, in Java 8, when they introduce streams, streams have a map function.

613
00:45:29,580 --> 00:45:32,740
You can go check now.

614
00:45:32,740 --> 00:45:36,820
If you Google Java 8 streams, you will see there's a map function.

615
00:45:36,820 --> 00:45:47,620
So finally, after like decades and decades, sorry, 20 years of Java and finally, you know,

616
00:45:47,620 --> 00:45:52,700
they have map, whereas if they would have listened to the mathematicians, when they

617
00:45:52,700 --> 00:45:58,620
designed generics, that should have been built in, because, you know, that gives you again,

618
00:45:58,620 --> 00:46:03,660
that is this thing where, you know, a type doesn't come by itself, it comes with properties

619
00:46:03,660 --> 00:46:05,900
that it should satisfy.

620
00:46:05,900 --> 00:46:09,060
Okay, hey, great.

621
00:46:09,060 --> 00:46:15,500
Now we know what a functor is.

622
00:46:15,500 --> 00:46:24,940
Now the other thing, if there's category theorists here in the room, I have to be a little bit

623
00:46:24,940 --> 00:46:31,100
careful, because what I said is a category was a programming language, and a functor

624
00:46:31,100 --> 00:46:35,860
is really something that kind of goes between two categories.

625
00:46:35,860 --> 00:46:41,180
So a functor can go between two programming languages.

626
00:46:41,180 --> 00:46:52,700
For example, if you have a Java array and a small talk array, then one starts indexing

627
00:46:52,700 --> 00:46:59,100
at zero, the other start indexing at one, and now say that I have a method on arrays

628
00:46:59,100 --> 00:47:06,820
that sums up the values, when I go from Java to small talk, I have to adjust that sum function

629
00:47:06,820 --> 00:47:09,340
to start kind of indexing at one.

630
00:47:09,340 --> 00:47:12,180
Okay, that's another example of a functor.

631
00:47:12,180 --> 00:47:15,020
But for today, we're only looking at endo functors.

632
00:47:15,020 --> 00:47:17,780
Ah, doesn't that sound cool?

633
00:47:17,780 --> 00:47:22,740
Endo functors, but an endo functor just means that it stays within one language, it doesn't

634
00:47:22,740 --> 00:47:26,060
go between two languages.

635
00:47:26,380 --> 00:47:30,420
Okay, good.

636
00:47:30,420 --> 00:47:35,460
So this is the Greek decoded.

637
00:47:35,460 --> 00:47:44,420
Now I've cheated a little bit already, because in here, you will see when I defined map,

638
00:47:44,420 --> 00:47:51,780
I already used the fact that I have a function that I can pass into map.

639
00:47:51,780 --> 00:47:56,740
But before Java 8, you couldn't do that, right?

640
00:47:56,740 --> 00:48:01,220
Because there were no functional, there were no lambdas, so you could not even define map.

641
00:48:01,220 --> 00:48:07,780
So we had to wait until Java 8 in order to have functions such that we can define map.

642
00:48:07,780 --> 00:48:12,660
But we're not there yet, because we were trying to kind of come up with how do I represent

643
00:48:12,660 --> 00:48:17,140
methods as first-class objects, how do I do lambdas?

644
00:48:17,140 --> 00:48:28,380
Okay, and lambdas reminds me, Eric, yes, that's what exponentials are for.

645
00:48:28,380 --> 00:48:30,460
Okay, let's go there.

646
00:48:30,460 --> 00:48:33,700
Okay, here was the Greek.

647
00:48:33,700 --> 00:48:42,020
Okay, blah, blah, blah, there's this object, there's a morphism, eval, blah, blah, blah.

648
00:48:42,020 --> 00:48:49,580
Okay, now then this diagram has to commute, and there we see our lambdas, so we're getting

649
00:48:49,580 --> 00:48:50,580
close.

650
00:48:50,580 --> 00:48:57,740
So let's turn this into reality.

651
00:48:57,740 --> 00:49:04,260
And of course, church, or this is Haskell B. Curry, will say, oh, but this is currying

652
00:49:04,260 --> 00:49:05,260
in Haskell.

653
00:49:05,260 --> 00:49:10,700
If you look here, you know, what this is doing here, this is called eval, blah, blah, blah.

654
00:49:10,700 --> 00:49:18,500
It's just currying, and Mr. H has seen this already, and he thought, yeah, when did I

655
00:49:18,500 --> 00:49:23,620
start doing Haskell in 1986, when did Haskell want to come out?

656
00:49:23,620 --> 00:49:29,140
I already did currying, and all you Java guys can only do it in Java 8.

657
00:49:29,140 --> 00:49:32,340
And most of you, oh, most of you were on Java 8.

658
00:49:32,340 --> 00:49:36,540
This is very progressive, because I know a lot of companies that are still doing Java

659
00:49:36,540 --> 00:49:39,020
6 most of the time.

660
00:49:39,380 --> 00:49:46,180
Okay, now here's, you're not Danish, I'm going to go to insult you.

661
00:49:46,180 --> 00:50:00,340
But here is Mr. C++, and he's a smart guy, because in 1979, somewhere, you know, you

662
00:50:00,340 --> 00:50:06,500
can find that on the web, he explained that there are no instance methods, okay?

663
00:50:06,500 --> 00:50:11,860
An instance method is just a static method that takes the dispointer as an additional

664
00:50:11,860 --> 00:50:12,860
argument.

665
00:50:12,860 --> 00:50:17,700
As I remembered it in the beginning, I said, we're only looking at morphisms as static

666
00:50:17,700 --> 00:50:18,700
methods.

667
00:50:18,700 --> 00:50:21,460
I'm going to ignore instance methods.

668
00:50:21,460 --> 00:50:23,700
It's because Bjarne told me so.

669
00:50:23,700 --> 00:50:28,700
Bjarne told me it's safe to ignore instance methods.

670
00:50:28,700 --> 00:50:39,580
So an instance method is just a morphism from the tuple of the disk parameter and the other

671
00:50:39,580 --> 00:50:41,700
parameter and returns a value.

672
00:50:41,700 --> 00:50:44,900
Okay, so that's where the tuples come in.

673
00:50:44,900 --> 00:50:47,420
And guess what?

674
00:50:47,420 --> 00:50:50,500
Even C++ is lambdas these days.

675
00:50:50,500 --> 00:50:52,340
Isn't this amazing?

676
00:50:52,340 --> 00:50:58,700
Here I don't think there's any kind of programming languages out there anymore that we all use

677
00:50:58,700 --> 00:51:01,220
that don't have lambdas.

678
00:51:01,220 --> 00:51:05,700
But it took many, many decades, and why is that?

679
00:51:05,700 --> 00:51:08,140
Because we didn't listen to the mathematicians.

680
00:51:08,140 --> 00:51:15,020
All right, now it might be the case that in C++ that Bjarne says, you know, there are

681
00:51:15,020 --> 00:51:17,620
no instance methods.

682
00:51:17,620 --> 00:51:27,260
But let's check what Java has to say.

683
00:51:27,260 --> 00:51:33,660
So if you want to have an even more boring document than the Java language specification,

684
00:51:33,660 --> 00:51:38,980
you should read the Java virtual machine specification, okay?

685
00:51:38,980 --> 00:51:46,820
But in the Java virtual machine specification, if you browse around a little bit and it says,

686
00:51:46,820 --> 00:51:55,300
when you call a class method or an instance method here, local variable zero, they start

687
00:51:55,300 --> 00:52:03,540
to count at zero, good boys, okay, is always passed to an object that represents the instance,

688
00:52:03,540 --> 00:52:05,100
okay?

689
00:52:05,100 --> 00:52:10,860
And the subsequent parameters are passed in subsequent local variables starting at one.

690
00:52:10,860 --> 00:52:15,740
So also in Java, there are no instance methods.

691
00:52:15,740 --> 00:52:23,440
It's just a static method where the first parameter with index zero is the disk, okay?

692
00:52:23,440 --> 00:52:29,300
So we can simply forget about instance methods.

693
00:52:29,300 --> 00:52:34,660
Now of course, there are a little bit things that I kind of put under the carpet.

694
00:52:34,660 --> 00:52:39,660
There's no carpet here, but you know, imagine there was a carpet, it's things like inheritance

695
00:52:39,660 --> 00:52:40,940
and so on.

696
00:52:40,940 --> 00:52:49,020
So inheritance is an interesting thing because inheritance is quite useful, although some

697
00:52:49,020 --> 00:52:53,880
crazy people say we shouldn't use inheritance, we should use composition.

698
00:52:53,880 --> 00:53:00,860
If you have any colleagues that say that, make them look bad and have them fired because

699
00:53:00,860 --> 00:53:05,940
they are making your life miserable because inheritance is a good thing.

700
00:53:05,940 --> 00:53:11,940
But the thing with inheritance is that usually it's explained in terms of the implementation.

701
00:53:11,940 --> 00:53:15,260
You start to talk about V tables and whatever.

702
00:53:15,260 --> 00:53:20,540
And the reason is because inheritance is a dirty implementation trick to make it easier

703
00:53:20,540 --> 00:53:29,580
to reuse code and to model inheritance mathematically is not easy and people write PhD thesis about

704
00:53:29,580 --> 00:53:30,580
that.

705
00:53:30,580 --> 00:53:36,940
William Cook, maybe you know him, wrote his PhD thesis about the semantics of inheritance.

706
00:53:36,940 --> 00:53:40,940
So I'm not going to talk about that today, okay?

707
00:53:40,940 --> 00:53:50,180
But let's continue decoding the Greek and now we are somewhere where we can understand

708
00:53:50,180 --> 00:53:51,180
what's going on.

709
00:53:51,180 --> 00:54:00,780
So to remind you, here's the category theory with the strange notation with the kind of

710
00:54:00,780 --> 00:54:05,100
exponentials and there was this lambda, blah, blah, blah.

711
00:54:05,100 --> 00:54:10,020
I didn't even bother to kind of go through that because you know, everybody would fall

712
00:54:10,020 --> 00:54:18,020
asleep after a few hot dogs and hamburgers, but now we are something that we can understand.

713
00:54:18,020 --> 00:54:29,380
So here, a function type here together with a method apply is a function, we call that

714
00:54:29,380 --> 00:54:32,140
a function type.

715
00:54:32,140 --> 00:54:41,260
If given any type A and a method M that takes an argument of type B and returns a C, defined

716
00:54:41,260 --> 00:54:49,860
on A and remember that if I have a method that's defined on A, it's really that M has

717
00:54:49,860 --> 00:54:56,580
type A as the first argument and B as the second argument, okay?

718
00:54:56,580 --> 00:55:03,060
Now what we can do is there's a factory method that takes an A and that factory method looks

719
00:55:03,060 --> 00:55:12,420
like colon, colon, M and it returns a function from B to C and that function object itself

720
00:55:12,420 --> 00:55:20,260
has an apply method such that when I apply that to B, that is the same as calling M on

721
00:55:20,260 --> 00:55:27,860
A and passing it B and then here I just cast to C so that you can show that it's the same,

722
00:55:27,860 --> 00:55:28,860
okay?

723
00:55:29,860 --> 00:55:35,420
Anybody here has used method reference in Java, if you use IntelliJ, it will tell you

724
00:55:35,420 --> 00:55:36,420
all the time, right?

725
00:55:36,420 --> 00:55:41,420
You write something and it says, I can refactor this into a method reference, do you use that?

726
00:55:41,420 --> 00:55:44,580
Anybody here uses IntelliJ?

727
00:55:44,580 --> 00:55:46,580
What is your name?

728
00:55:46,580 --> 00:55:47,580
Paul?

729
00:55:47,580 --> 00:55:54,540
Ah, finally a name I can pronounce, Paul, do you ever use refactor change into method

730
00:55:54,540 --> 00:55:55,540
reference?

731
00:55:55,540 --> 00:56:01,020
Yes, and do you recognize this kind of double colon crazy thing?

732
00:56:01,020 --> 00:56:07,700
So you have been using exponential objects, did you realize that?

733
00:56:07,700 --> 00:56:13,460
So now you can go to your boss and say in full cafe, I learned that I'm freaking using

734
00:56:13,460 --> 00:56:20,500
exponential objects from category tier in my coding, I need a raise because that son

735
00:56:20,500 --> 00:56:26,580
of a bitch next to me has no clue what they're doing, they're still using whatever virtual

736
00:56:26,580 --> 00:56:36,300
methods but I know exponential objects, good, but it's amazing.

737
00:56:36,300 --> 00:56:45,260
Function references, method references in Java are exactly the same as exponential objects

738
00:56:45,260 --> 00:56:53,540
in category tier because the only thing I've done here is translate the Greek into Java

739
00:56:53,540 --> 00:56:55,700
code, right?

740
00:56:55,700 --> 00:56:59,540
So why did it take so long?

741
00:56:59,540 --> 00:57:06,580
They could have sat down, done the same thing as I did, came up with this, said, hey, dude,

742
00:57:06,580 --> 00:57:10,380
let's hire somebody to implement this in the compiler and we're done.

743
00:57:11,140 --> 00:57:18,260
Okay, but I must say I find this pretty amazing because I'm 100% sure that the Java language

744
00:57:18,260 --> 00:57:28,740
designers had no idea of category theory but yet they came up with exactly the same solution.

745
00:57:28,740 --> 00:57:31,020
That is the amazing thing, okay?

746
00:57:31,020 --> 00:57:39,140
So it must be some universal truth here because otherwise you would not two completely independent

747
00:57:39,140 --> 00:57:45,940
people, one from theory, one from practice, come up with the same idea.

748
00:57:45,940 --> 00:57:52,460
So if you look at here, if I have a method reference and I call the apply method on that

749
00:57:52,460 --> 00:58:00,180
with argument of type B, that is the same as calling the method M on A, passing it B.

750
00:58:00,180 --> 00:58:02,660
That is how method references work.

751
00:58:02,660 --> 00:58:06,900
This is how category tier works, this is how exponential objects work.

752
00:58:07,900 --> 00:58:11,380
I mean, this is a miracle.

753
00:58:11,380 --> 00:58:19,780
I don't know about you, but when I discovered this, I don't know, I drank a whole bottle

754
00:58:19,780 --> 00:58:22,300
of this stuff.

755
00:58:22,300 --> 00:58:29,460
I don't know what this is, this is rum, I drank a neighbor, you know, that's kind of

756
00:58:29,460 --> 00:58:33,220
the Dutch vodka, okay?

757
00:58:33,220 --> 00:58:36,180
But this is great.

758
00:58:36,180 --> 00:58:44,260
Now you can say, great, we now know that method references are exponential objects, okay?

759
00:58:44,260 --> 00:58:49,300
So tomorrow when you go back to work, you're saying, let's do some kind of, let's introduce

760
00:58:49,300 --> 00:58:52,100
some exponentials and IntelliJ can help us with that.

761
00:58:52,100 --> 00:58:55,020
No, don't say that, you kind of use that.

762
00:58:55,020 --> 00:59:01,180
But here's Eric Meyer and he has not mentioned the M word yet.

763
00:59:01,180 --> 00:59:04,380
I have not mentioned monads yet.

764
00:59:04,380 --> 00:59:12,260
So I'm going to do a little bit, yes, now I have, before as well.

765
00:59:12,260 --> 00:59:17,900
When I was talking about Haskell, yes, that's true, but that was more like a joke.

766
00:59:17,900 --> 00:59:22,500
Okay, now let's look at this thing.

767
00:59:22,500 --> 00:59:30,780
So if you look at this exponential object, blah, blah, blah, there's a right adjoint

768
00:59:30,780 --> 00:59:32,620
and there's home sets.

769
00:59:32,620 --> 00:59:35,900
Now home sets have nothing to do with fish eggs.

770
00:59:35,900 --> 00:59:41,140
I don't know, is that the same in Swedish, home in Dutch, that's kind of the eggs of

771
00:59:41,140 --> 00:59:43,860
a fish, like caviar.

772
00:59:43,860 --> 00:59:47,100
This has nothing to do with caviar, okay?

773
00:59:47,100 --> 00:59:54,940
It just says that if I have a function from x to y to z, that is kind of isomorphic to

774
00:59:54,940 --> 00:59:59,540
having a function that takes x and y and returns z, okay?

775
00:59:59,540 --> 01:00:05,900
So this is really saying that you can curry and uncurry and go in two directions, okay?

776
01:00:05,900 --> 01:00:14,260
And a home set, home A, B is just a fancy way of saying all morphisms from A to B,

777
01:00:14,260 --> 01:00:15,260
okay?

778
01:00:15,260 --> 01:00:18,580
So this is just a fancy thing.

779
01:00:18,580 --> 01:00:25,220
And the method, the magic of method references is really what it's saying, right?

780
01:00:25,220 --> 01:00:32,740
It's saying that, you know, there's an isomorphism between the lambda expression B arrow A, method

781
01:00:32,740 --> 01:00:38,620
reference B and this method call here.

782
01:00:38,620 --> 01:00:44,420
So there's nothing kind of really fancy about this.

783
01:00:44,420 --> 01:00:48,500
And then, you know, we can kind of talk about adjoints because that was the other thing

784
01:00:48,500 --> 01:00:49,500
in there.

785
01:00:49,500 --> 01:00:55,700
For an adjoint, I have to have two functors and in our case, it's this.

786
01:00:55,700 --> 01:01:01,240
And to really prove that I'm not talking nonsense, you know, here's some real code that actually

787
01:01:01,240 --> 01:01:05,660
executes if you use Scala.

788
01:01:05,660 --> 01:01:13,140
But now, here's the thing, that if you have two of these adjoint functors and these are

789
01:01:13,140 --> 01:01:19,660
the conversions between them, that gives rise to a monad.

790
01:01:19,660 --> 01:01:27,420
So we came from exponential objects, there came this notion of adjoint functors.

791
01:01:27,420 --> 01:01:30,180
And once you have adjoint functors, you get monads.

792
01:01:30,180 --> 01:01:32,460
So there's no escape from the monads.

793
01:01:32,460 --> 01:01:39,540
So in the end, everybody will be like Mr. H, because, you know, now that Java 8 has

794
01:01:39,540 --> 01:01:44,180
exponentials, the next thing it will have are monads.

795
01:01:44,180 --> 01:01:47,180
Because that's what category theory predicts.

796
01:01:47,180 --> 01:01:53,940
And I went through this real quick, but I tell you, 10 years from now, 20 years from

797
01:01:53,940 --> 01:01:59,260
now, this will be the case.

798
01:01:59,260 --> 01:02:05,580
Java will have monads, because monads are related to adjunctions and adjunctions come

799
01:02:05,580 --> 01:02:08,500
from exponentials.

800
01:02:08,500 --> 01:02:17,620
Now the funny thing is that the state monad comes from this adjunction there, but that's

801
01:02:17,620 --> 01:02:20,300
a topic for a different talk.

802
01:02:20,300 --> 01:02:29,980
So here's the next thing, when you have a lot of beer tonight, this will be your next

803
01:02:29,980 --> 01:02:33,220
tattoo, okay?

804
01:02:33,220 --> 01:02:38,380
So category theory here directly corresponds to Java.

805
01:02:38,380 --> 01:02:43,980
And if this is a little bit too dark for you, what about this one?

806
01:02:43,980 --> 01:02:45,940
This one looks cute, right?

807
01:02:45,940 --> 01:02:56,300
And I made a special deal with Liz's tattoo parlor, where if you show your Foucaffé t-shirt,

808
01:02:56,300 --> 01:03:07,140
you will get a discount on any of those two tattoos.

809
01:03:07,140 --> 01:03:07,980
Thank you very much.

