WEBVTT

00:00.000 --> 00:21.840
What we're going to do tonight is to celebrate, of course, the three-year anniversary of Foucafé.

00:21.840 --> 00:29.240
And also we're going to give a tribute to Joachim Lambeck, who is a kind of category

00:29.240 --> 00:34.840
theorist that kind of made the connection between the lambda calculus and category theory.

00:34.840 --> 00:39.560
And, funnily, his name kind of, you know, has the same prefix as the lambda calculus.

00:39.560 --> 00:41.400
That isn't that a coincidence.

00:41.400 --> 00:42.840
I don't know.

00:42.840 --> 00:51.200
But anyway, so just in the spirit of deliberate and continuous learning, you know, like, who

00:51.200 --> 00:54.360
here uses Java 8?

00:54.360 --> 00:55.360
A few people.

00:55.360 --> 00:59.120
Who here uses Java 6?

00:59.120 --> 01:00.760
A few people as well.

01:00.760 --> 01:08.880
So it has taken, like, many, many years before Java 6 became Java 8 and added lambdas.

01:08.880 --> 01:16.440
Now if the language designers would have practiced deliberate and continuous learning, it would

01:16.440 --> 01:21.720
have happened, like, you know, decades ago, because all this knowledge was already developed

01:21.720 --> 01:24.960
by people like Lambeck.

01:24.960 --> 01:30.600
And tonight I'm going to tell you the tricks how you, as a developer, can tap into the

01:30.600 --> 01:37.440
brains of mathematicians and kind of steal their ideas such that, you know, you can become

01:37.440 --> 01:42.400
a better developer and then go to your boss and ask for more money, because you're an

01:42.400 --> 01:44.400
awesome developer.

01:44.400 --> 01:46.200
All right.

01:46.200 --> 01:49.360
Let's get started.

01:49.360 --> 01:51.280
Oops.

01:51.280 --> 01:57.000
So one of my guilty pleasures is I read language specifications.

01:57.000 --> 02:02.120
So some of you kind of, you know, might read novels or newspapers, maybe.

02:02.120 --> 02:04.200
I read language specifications.

02:04.200 --> 02:06.640
And for a while I was collecting them.

02:06.640 --> 02:12.840
I had a whole bunch of, you know, going all the way back to, you know, the early Lisp,

02:12.840 --> 02:16.160
1.0 manual, Pascal, everything.

02:16.160 --> 02:20.640
So whenever there was a new language, I would read the language manual.

02:20.640 --> 02:29.880
So I read all of them, Visual Basic, C-Sharp, ECMAScript, Swift, Dart, you name it.

02:29.880 --> 02:35.840
But there's one language specification that even for me was too strong.

02:35.840 --> 02:38.200
It was impossible to read.

02:38.200 --> 02:43.840
And that language specification is Java 8.

02:43.840 --> 02:51.320
Now I don't know, anyone, has anyone here ever looked at the Java language specification?

02:51.320 --> 02:52.560
Okay.

02:52.560 --> 02:54.120
Did you fall asleep immediately?

02:54.120 --> 02:56.480
I mean, you open up this thing and you fall asleep.

02:56.480 --> 03:00.960
I mean, it's like, try it, you know, some, you know, and you kind of cannot sleep at

03:00.960 --> 03:01.960
night.

03:01.960 --> 03:02.960
Your kind of mind is wandering.

03:02.960 --> 03:04.600
Just open that thing up.

03:04.600 --> 03:08.720
It will work better than any pill.

03:08.720 --> 03:10.760
And this one in particular is really weird.

03:10.760 --> 03:15.960
So when Java 8 came out, and there's this kind of weird thing with method references,

03:15.960 --> 03:19.680
so I thought, I really want to understand this.

03:19.680 --> 03:24.400
So I started to read the language pack.

03:24.400 --> 03:29.360
It doesn't, my goodness, it's just way too complicated.

03:29.360 --> 03:32.360
So what do I do?

03:32.360 --> 03:39.600
When something is complicated, I'm always listening to this guy.

03:39.600 --> 03:44.480
This is Leslie Lamport, and he won the Turing Award last year.

03:44.480 --> 03:45.480
Okay.

03:45.480 --> 03:49.440
Well, if you win the Turing Award, well, that means something.

03:49.440 --> 03:56.920
And one of the kind of advice that Lamport gives us is that we should kind of do more

03:56.920 --> 03:57.920
math.

03:57.920 --> 03:59.360
We should use more math.

03:59.360 --> 04:04.160
If you're like a mechanical engineer, you build, or like a civil engineer, you build

04:04.160 --> 04:08.000
a bridge or something, you use math, okay?

04:08.000 --> 04:11.000
If you're a chemist, you use math.

04:11.000 --> 04:15.680
But we as computer scientists seem to be afraid of mathematics.

04:15.680 --> 04:20.800
And what Lamport says, and what I will tell you, is you shouldn't be afraid.

04:20.800 --> 04:29.480
And I think a lot of people here, I don't know, maybe, you know, in Sweden, it's different.

04:29.480 --> 04:33.640
You're not afraid of math, you know, you, instead of language specifications, you read

04:33.640 --> 04:37.120
like books on calculus before you go to bed, I'm pretty sure.

04:38.120 --> 04:44.480
Typically, when I meet developers, they are kind of afraid of mathematics.

04:44.480 --> 04:48.640
And I think there's several reasons for that, and those are good reasons.

04:48.640 --> 04:54.720
First of all, mathematics, most textbooks are really bad.

04:54.720 --> 04:59.480
The notation is weird, it doesn't even type check, you know, if you're trying to kind

04:59.480 --> 05:04.600
of, you know, look at it, it doesn't work.

05:04.600 --> 05:09.320
The lingo is weird, they have all their own terms.

05:09.320 --> 05:13.240
They often, you kind of end up in a rabbit hole, you know, you want to kind of know a

05:13.240 --> 05:18.960
little bit, and before you know it, you know, you're kind of, you know, deep into all kind

05:18.960 --> 05:24.000
of Greek symbols and other dirty pictures.

05:24.000 --> 05:31.120
And last but not least, often mathematics is taught in a bottom up way, okay?

05:31.120 --> 05:36.000
So you cannot say, I need to solve a particular problem, and I need a piece of mathematics

05:36.000 --> 05:37.000
for that.

05:37.000 --> 05:39.600
No, instead, they start bottom up.

05:39.600 --> 05:45.440
So you have to first know a whole bunch of mathematics before, finally, you can apply

05:45.440 --> 05:47.200
it to your problem.

05:47.200 --> 05:53.320
Whereas with computing, we typically teach the other way around.

05:53.320 --> 05:56.240
Who here has a computer science degree?

05:56.240 --> 05:59.640
Okay, I would say about half.

05:59.640 --> 06:05.880
So the other people don't have a computer science degree, they still know how to program,

06:05.880 --> 06:12.800
but they didn't start by studying, you know, big O, they didn't start to study touring

06:12.800 --> 06:13.800
machines.

06:13.800 --> 06:18.040
No, they just opened up an editor and started to hack.

06:18.040 --> 06:20.680
They did it top down.

06:20.680 --> 06:25.520
And of course, at some point, you will feel that maybe you need a little bit more theory,

06:25.520 --> 06:28.920
but programming is typically taught top down.

06:28.920 --> 06:35.960
So you don't start with all the theory, but no, you start by solving a particular problem,

06:35.960 --> 06:36.960
and then you go down.

06:36.960 --> 06:40.240
Let me give you a really good example of that.

06:40.240 --> 06:42.240
Linear algebra.

06:42.240 --> 06:47.880
When most people teach linear algebra, they talk about matrices and then you have to multiply

06:47.880 --> 06:53.760
matrices and then you have to kind of do all kind of mechanical, stupid things.

06:53.760 --> 06:56.400
And then you use it to do graphics.

06:56.400 --> 07:02.440
But you know, instead of kind of knowing why you do it, you're kind of manipulating this

07:02.440 --> 07:04.960
kind of low level representation.

07:04.960 --> 07:13.160
Now if you know that a matrix, an m by n matrix is really the representation of a linear function

07:13.160 --> 07:19.360
from a sequence of numbers of length n to a sequence of numbers of length m.

07:19.360 --> 07:23.120
And matrix multiplication is function composition.

07:23.120 --> 07:28.560
So really, when you're doing matrix manipulations, you're doing assembly language programming.

07:28.560 --> 07:32.920
This is completely nonsense that we as humans have to do that.

07:32.920 --> 07:39.240
If instead they would teach linear algebra as a restricted form of functional programming

07:39.240 --> 07:44.600
with some special functions that are linear, which means that they have nice properties,

07:44.600 --> 07:45.840
everything would be easy.

07:45.840 --> 07:50.840
But these are the stupid mathematicians that are too smart for their own sake and they

07:50.840 --> 07:53.160
teach it bottom up.

07:53.160 --> 07:56.200
And then in the end, you know, we scratch our heads.

07:56.200 --> 07:59.760
I scratch my head way too often.

07:59.760 --> 08:02.600
And then we ask ourselves, why is this useful?

08:02.600 --> 08:03.600
All right.

08:03.600 --> 08:06.000
So linear algebra is really easy.

08:06.000 --> 08:09.200
It's just functional programming with linear functions.

08:09.200 --> 08:13.800
Matrix multiplication is function composition done.

08:13.800 --> 08:15.920
Same is true with category theory.

08:15.920 --> 08:21.720
If you look at category theory, it looks scary, just like linear algebra, but it's really

08:21.720 --> 08:22.720
easy.

08:22.720 --> 08:26.280
So let's start looking at that.

08:26.280 --> 08:31.760
So mathematicians often call, this is kind of weird, right?

08:31.760 --> 08:36.200
Mathematicians that give us linear algebra, they look at category theory and say this

08:36.200 --> 08:39.600
is abstract nonsense.

08:39.600 --> 08:46.160
And the reason that they say it's abstract nonsense is because in category theory, proofs

08:46.160 --> 08:50.280
are done in a very abstract way.

08:50.280 --> 08:53.200
So it's, look at what it says here.

08:53.200 --> 09:01.400
It's the study of the general form of mathematical theories without regard to their content.

09:01.400 --> 09:05.960
What that means is that all intuition is taken away.

09:05.960 --> 09:11.520
And you look at the pure, you know, pure general form.

09:11.520 --> 09:19.000
Well, as programmers, we recognize that because whenever we do, whenever we program against

09:19.000 --> 09:22.640
an interface, that's exactly what we're doing.

09:22.640 --> 09:27.280
We're programming against a thing without regard to their content.

09:27.280 --> 09:30.200
We're not programming against a concrete type.

09:30.200 --> 09:33.120
We're programming against the abstract interface.

09:33.120 --> 09:38.680
And then there can be many concrete types that we can plug in, but the program is still

09:38.680 --> 09:40.680
the same.

09:40.680 --> 09:45.680
The other thing that's interesting is that here they talk about proofs.

09:45.680 --> 09:50.960
So you build your proof on these kind of general theories.

09:50.960 --> 09:55.280
Well, there's a very, very interesting thing.

09:55.280 --> 09:57.920
It's called the Curry-Howard isomorphism.

09:57.920 --> 10:01.080
People heard about the Curry-Howard isomorphism.

10:01.080 --> 10:03.960
It's one of the most beautiful ideas I've ever seen.

10:03.960 --> 10:11.520
So Curry-Howard isomorphism says that a type is a theorem and the program is the proof

10:11.520 --> 10:13.800
for that theorem.

10:13.800 --> 10:19.920
Now what means that whenever we're kind of writing code, we're really proving theorems.

10:19.920 --> 10:22.160
So we are like mathematicians.

10:22.160 --> 10:27.880
Or you can say, mathematicians are really developers, that program really, really slow.

10:28.000 --> 10:36.600
It takes them like two decades to kind of write a small proof.

10:36.600 --> 10:40.360
But this Curry-Howard isomorphism is really beautiful.

10:40.360 --> 10:44.400
I don't have time today to talk about it.

10:44.400 --> 10:51.640
But if you take that a little bit further, that's what I'm going to do here is that you

10:51.640 --> 10:56.720
define your theorems in terms of these abstract structures.

10:56.720 --> 11:01.360
And then you write your code in terms of them, so you do your proofs in terms of them.

11:01.360 --> 11:04.600
And so let's continue with that.

11:04.600 --> 11:11.560
And as I said, this is really not foreign to, for us developers, because we do this all

11:11.560 --> 11:12.560
the time.

11:12.560 --> 11:15.040
We do this when we program against interfaces.

11:15.040 --> 11:18.040
We do this when we use design patterns.

11:18.040 --> 11:23.360
I'm pretty sure that most people have that book on their bookshelves.

11:23.360 --> 11:26.360
And I'm also sure that nobody has ever read it.

11:26.400 --> 11:29.760
Because when you read it, you get the feeling, what's going on?

11:29.760 --> 11:33.440
This is all kind of, you know, how did the mathematicians say this?

11:33.440 --> 11:39.520
This is without regard to any actual content, because these design patterns are very abstract

11:39.520 --> 11:42.920
and you can instantiate them for specific purposes.

11:42.920 --> 11:47.320
But that's the beauty of design patterns, because now you can talk about concepts in

11:47.320 --> 11:55.080
a very abstract way, without kind of, you know, being tied to a very concrete implementation.

11:55.800 --> 11:56.800
Okay?

11:56.800 --> 12:03.280
So that's, already I give you a couple of tricks, how to think like a mathematician

12:03.280 --> 12:05.520
and profit from that.

12:05.520 --> 12:09.640
Now, what is category theory?

12:09.640 --> 12:13.560
Well, category theory is embarrassingly simple.

12:13.560 --> 12:17.000
It has two, well, three concepts.

12:17.000 --> 12:24.920
First of all, there's a notion of a category, but a category consists of objects and morphisms.

12:25.920 --> 12:30.200
Now, as I said, mathematicians are weird people.

12:30.200 --> 12:31.760
They use strange lingo.

12:31.760 --> 12:35.120
So let's translate this into programming terminology.

12:35.120 --> 12:41.000
So a category is really a programming language, okay?

12:41.000 --> 12:44.280
And a programming language has types, okay?

12:44.280 --> 12:50.720
Like in Java, there's types, Boolean strings, lists, those are the types.

12:50.720 --> 12:56.360
And then there are morphisms, well, that's just a fancy word for static method.

12:56.360 --> 13:05.960
So morphism from A to B is just a static method that takes a argument of type A and

13:05.960 --> 13:13.080
where there's a value of type B, or equivalently, you can say it's a property.

13:13.080 --> 13:18.600
Now you can ask yourself, well, if you're saying that we're doing programming, why do

13:18.600 --> 13:21.480
I use static methods?

13:21.480 --> 13:23.120
Because we also have instance methods.

13:23.120 --> 13:25.080
Well, we'll come back to that later.

13:25.080 --> 13:31.160
So the whole point of this talk is to kind of, you know, fix this and make this precise.

13:31.160 --> 13:40.080
So mix this notion precise that morphisms in a category are just static methods.

13:40.080 --> 13:41.400
Now look at this.

13:41.400 --> 13:43.280
This is, again, mathematicians.

13:43.280 --> 13:45.560
I told you they're slow programmers.

13:45.560 --> 13:48.840
So here's an example of a programming language.

13:48.840 --> 13:53.200
It's a programming language that has three types, A, B, and C.

13:53.200 --> 13:56.840
So it's like characters, integers, and Booleans.

13:56.840 --> 13:58.480
That's it.

13:58.480 --> 14:03.120
And then, well, if you have three types, then you can define some functions between them.

14:03.120 --> 14:08.760
So for example, I can go from Booleans to characters, and I can have a function from

14:08.760 --> 14:11.440
characters to characters.

14:11.440 --> 14:18.320
Now for these mathematicians, this is so special that they give this language a name, and it's

14:18.320 --> 14:20.440
called bold three.

14:20.440 --> 14:21.440
Okay.

14:21.440 --> 14:28.480
Now imagine if you want to draw this kind of picture for Java, you know, it wouldn't fit,

14:28.480 --> 14:33.400
you know, you would need all the walls here, and, you know, maybe the whole city with graffiti

14:33.400 --> 14:34.400
like this.

14:34.400 --> 14:35.400
Maybe it would look quite nice.

14:35.400 --> 14:36.680
It's like an art project.

14:36.680 --> 14:38.120
But this is kind of mathematicians.

14:38.120 --> 14:44.160
So they are kind of proud that they understand this programming language with three types.

14:44.160 --> 14:45.160
Okay.

14:45.160 --> 14:53.280
Now, of course, once you have types, you can create other types.

14:53.280 --> 14:59.040
And everybody these days seem to want to have tuples.

14:59.040 --> 15:03.400
And Java doesn't have tuples, but there's many libraries that provide tuples.

15:03.400 --> 15:06.760
Anybody here does Android programming?

15:06.760 --> 15:11.560
A few people not so few, what are you Windows phone, maybe?

15:11.560 --> 15:12.560
No.

15:12.560 --> 15:18.080
But if you do Android programming, you know, you know, and even if you don't, this might

15:18.080 --> 15:26.400
be interesting to know, is that in the Android library, there is a type for tuples.

15:26.400 --> 15:31.720
That's so important that even on your Android phone, you need tuples.

15:31.720 --> 15:40.360
And here is some category theory that defines what tuples are in Mathematician speak.

15:40.360 --> 15:45.080
Now you will ask yourself, oh my goodness, where's my beer?

15:45.080 --> 15:47.360
The next beer, this looks kind of horrible.

15:47.360 --> 15:48.360
Okay.

15:48.360 --> 15:54.280
There's like all kind of weird stuff, commuting diagrams, canonical stuff.

15:54.280 --> 15:56.200
I don't even understand this.

15:56.200 --> 16:06.160
So let's take this Greek and let's try to translate this into a language that we all

16:06.160 --> 16:07.160
understand.

16:07.160 --> 16:08.160
Okay.

16:08.160 --> 16:15.520
So here's the first sentence of that definition of tuples.

16:15.520 --> 16:21.960
And it says, let's see be a category with some objects X1 and X2.

16:21.960 --> 16:31.160
Well, as I said, a category corresponds to a programming language and a object corresponds

16:31.160 --> 16:32.160
to a type.

16:32.160 --> 16:39.320
Now, often people confuse objects and instances and whatever.

16:39.320 --> 16:40.520
So let's not be confused.

16:40.520 --> 16:43.880
So that's why I call them types and types have instances.

16:43.880 --> 16:48.320
And whether you want to call the instances objects or the type objects, I don't care.

16:48.320 --> 16:50.200
So that's why I call them types.

16:50.200 --> 16:54.720
And also then it doesn't clash with the objects in the category.

16:54.720 --> 16:55.720
Okay.

16:55.720 --> 17:00.280
Now, what can I do when I have two types?

17:00.280 --> 17:03.120
Well, I can form a tuple.

17:03.120 --> 17:04.840
They don't call it tuples.

17:04.840 --> 17:06.920
They call it a product.

17:06.920 --> 17:07.920
Okay.

17:07.920 --> 17:12.280
So they are going to take these two types, X1 and X2.

17:12.280 --> 17:17.840
They're going to create a new type X, which, you know, they can also write as X1 cross

17:17.840 --> 17:24.360
X2 and then blah, blah satisfies a universal property, blah, blah, blah, blah, blah, blah.

17:24.360 --> 17:26.360
Do you understand this?

17:26.360 --> 17:27.360
No.

17:27.360 --> 17:28.360
Yes.

17:28.360 --> 17:29.360
Good.

17:29.360 --> 17:39.560
There's one person that understands it, great.

17:39.560 --> 17:45.840
So let's go and drill down a little bit into this.

17:45.840 --> 17:50.760
Because I think this picture says, said it much better.

17:50.760 --> 17:59.800
So if I have a tuple or a product, I have two functions that I can use to project the values

17:59.800 --> 18:00.800
out of this tuple.

18:00.800 --> 18:06.000
So I can select the first element and I can select the second one.

18:06.000 --> 18:10.040
Now you can ask yourself, why do they start counting at one?

18:10.040 --> 18:14.080
Because we as developers always, now our index is zero.

18:14.080 --> 18:19.080
And again, these are mathematicians, they don't, they probably never done C programming

18:19.080 --> 18:20.080
or whatever.

18:20.080 --> 18:22.960
So they can start their counting by one.

18:22.960 --> 18:29.400
Anyway, so this is the kind of thing, but then there's all the rest of this.

18:29.400 --> 18:36.200
And what we see here is, well, how on earth do you get an instance of a tuple?

18:36.200 --> 18:40.720
Well, you need a constructor or a factory function.

18:40.720 --> 18:43.240
These mathematicians are not stupid, right?

18:43.240 --> 18:47.840
They know that when you create a type, when you have a type, you all you have to have

18:47.840 --> 18:49.640
a way to create it.

18:49.640 --> 18:56.120
We call it constructor, well, they have here some function that kind of allows you to kind

18:56.120 --> 18:58.840
of create a tuple.

18:58.840 --> 19:06.440
And then they say, well, if you have such a function, which you create from two morphisms,

19:06.440 --> 19:11.640
then if you kind of start with a value here, you apply that to this function.

19:11.640 --> 19:18.360
Now you get this guy, that must be the same as kind of projecting the first value or applying

19:18.360 --> 19:19.360
this function.

19:19.360 --> 19:22.200
So it all must kind of commute.

19:22.200 --> 19:25.800
And that looks quite nice in that diagram.

19:25.800 --> 19:31.840
Now if you don't like diagram, then you can translate it into equations, whatever you

19:31.840 --> 19:34.760
find easier to read.

19:34.760 --> 19:40.040
Now, except for this gentleman over there, what's your name?

19:41.040 --> 19:48.560
Oh, I cannot pronounce that, but generic, good.

19:48.560 --> 19:54.760
Mr. Generic over there, he understands this.

19:54.760 --> 20:00.400
But that's kind of, you know, for the rest of us, you know, whose brains are the size

20:00.400 --> 20:08.680
of peanuts or smaller, let's kind of continue to put this into our language.

20:08.680 --> 20:15.120
So if we go on with this translation, we say that a type A comma B is a product of A and

20:15.120 --> 20:19.480
B or a tuple of A and B, if it satisfies blah, blah, blah.

20:19.480 --> 20:27.960
There exist two properties underscore one and underscore two that return an A and a B respectively.

20:27.960 --> 20:31.800
Any Scala programmers here?

20:31.800 --> 20:33.800
You recognize this?

20:33.800 --> 20:36.760
Yeah, look at this, I see a smile.

20:36.760 --> 20:37.760
Yep.

20:37.840 --> 20:43.600
This is Scala, you can project the first and second element, but then there's also, if

20:43.600 --> 20:48.800
you have two methods, the factory function for this thing takes two methods and it gives

20:48.800 --> 20:55.240
you a function that given a C returns this pair of A and B, and it does that by kind

20:55.240 --> 20:59.560
of applying that C to F and G respectively.

20:59.560 --> 21:06.040
So this is a little bit different than in Scala because the constructor function behaves

21:06.040 --> 21:07.120
a little bit different.

21:07.120 --> 21:12.880
But we can, from this, we can create a normal constructor function too.

21:12.880 --> 21:24.400
Okay, let's go look at this commuting diagram and it's kind of the same.

21:24.400 --> 21:32.560
Now as I said, if you look at Scala, I don't know, I think this mathematics is actually

21:32.560 --> 21:33.560
clearer and shorter.

21:33.560 --> 21:39.560
Because look at this, trade, blah, blah, blah, extends, blah, blah, blah, abstract

21:39.560 --> 21:43.280
this, abstract that, curly open, curly close.

21:43.280 --> 21:48.440
Now you see why these mathematicians have their strange lingo because maybe we have editors

21:48.440 --> 21:54.640
and we have autocomplete, but look at how many characters we need to write down kind

21:54.640 --> 21:58.520
of something simple like this, okay?

21:58.520 --> 22:09.360
But here is you see that this is the definition in Scala of a product and I think this is,

22:09.360 --> 22:12.960
now you can ask yourself what the heck are those pluses there?

22:12.960 --> 22:19.760
Am I going to kind of, I don't know, is this unary plus or no, no, no, that's co and contravariance.

22:19.760 --> 22:26.160
But that's way too complicated, but this is actually the way that products are defined

22:26.160 --> 22:36.080
in Scala, but what Scala doesn't have is this operator to construct a product.

22:36.080 --> 22:44.680
Now the reason why Martin cannot do that is because if you would do that, you already

22:44.680 --> 22:51.560
need the notion of functions as objects and that was the whole point of this presentation

22:51.560 --> 22:59.520
to figure out, you know, how can we make these morphisms into first class things, okay?

22:59.520 --> 23:06.880
So really, you know, if we look at this simple example where we took the idea of tuples and

23:06.880 --> 23:12.720
we have seen how the mathematicians do it and we do it, it's really the same except

23:12.720 --> 23:19.160
that the mathematicians apply a little bit more rigor, they use weird notation, but the

23:19.160 --> 23:25.440
nice thing that they do, that we never do is when they define a type, they talk about

23:25.440 --> 23:30.640
properties of the type, what properties should a product have?

23:30.640 --> 23:38.480
Because if you look at this definition in Scala, right, from here it says nowhere that

23:38.480 --> 23:46.040
when you create a tuple out of two values and you project from that tuple the first

23:46.040 --> 23:50.640
value that you actually get the value that you put in there, right?

23:50.640 --> 23:56.880
Nothing says this here because it can return null for both sides and it's still kind of

23:56.880 --> 24:00.320
according to this type definition a valid implementation of tuple.

24:00.320 --> 24:05.840
Of course, you would not accept that, but the type itself doesn't say anything.

24:05.840 --> 24:11.040
So if you're a smart programmer and somebody gives you this trait and you have to implement

24:11.040 --> 24:16.760
it, you can just return null in both cases, nobody can complain.

24:16.760 --> 24:21.600
If they file a bug, you immediately file the bug back and say you didn't specify this

24:21.600 --> 24:23.480
thing properly, okay?

24:23.480 --> 24:25.280
This is another tip, okay?

24:25.280 --> 24:33.420
You just return null, your colleagues complain, you just say sorry, you know, specify it better.

24:33.420 --> 24:38.440
And then you can go have a drink, a beer, kind of go to another meeting, put that on

24:38.440 --> 24:47.120
your resume, get even more money, look at this, all right, good.

24:47.120 --> 24:56.960
So and here is the, you know, again, a slightly different way to do this function.

24:56.960 --> 25:01.720
I'm going to skip this for lack of time.

25:01.720 --> 25:08.420
Now Mr. Generic here says, oh, I knew this already, but this is old stuff, right?

25:08.420 --> 25:17.700
Here is John McCarthy, the inventor of Lisp, and he says, well, come on, I could define

25:17.700 --> 25:22.280
all this stuff with top polls and so on in 1960.

25:22.280 --> 25:28.820
And then Church, Mr. Alonso Church, who invented the Lambda calculus, he did this already in

25:28.820 --> 25:31.300
1928.

25:31.300 --> 25:38.700
Now look, this guy here came up with this in 1928.

25:38.700 --> 25:44.900
If you read the papers from Church, he was doing this kind of tuples.

25:44.900 --> 25:52.540
In Java 8, it's 2015, last time I checked, there are still no proper tuples in the language.

25:52.540 --> 26:00.740
Look at this, I don't even know, it's like 2015 minus, that's nearly a century, okay?

26:00.740 --> 26:05.340
And we still don't, this thing still doesn't, we are, and why is that?

26:05.340 --> 26:11.020
Because we are afraid of these mathematicians, whereas we should steal their ideas and profit

26:11.020 --> 26:13.380
from them, okay?

26:13.380 --> 26:15.620
That's really kind of my message today.

26:15.620 --> 26:20.740
These people are smart, look at this size of this brain here, you know, if I put my

26:20.740 --> 26:27.540
head next to it, it's like 10 times the size, we should leverage that.

26:27.540 --> 26:30.140
But what do we do instead?

26:30.140 --> 26:36.300
Well first of all, we are proud that, you know, we don't do theory.

26:36.300 --> 26:42.900
So if you look at C-Sharp, C-Sharp has delegates, and it's like we don't need any of this theory,

26:42.900 --> 26:44.820
we have delegates.

26:44.820 --> 26:47.860
But where, you know, where does these delegates come from?

26:47.860 --> 26:48.860
What are their properties?

26:48.860 --> 26:49.860
We don't know.

26:49.860 --> 26:54.700
And then, I don't know if anybody's old enough, probably most of you were not born yet, but

26:54.700 --> 27:00.500
when C-Sharp came out, there was a little fight between C-Sharp and Java, where the

27:00.500 --> 27:06.540
Java folks said, we don't need any of this lambdas or delegate stuff because we have

27:06.540 --> 27:08.660
virtual methods.

27:08.660 --> 27:13.700
And so this is another lesson, never say never, okay?

27:13.700 --> 27:18.620
Because I think, because they didn't want to lose face for the longest time, Java could

27:18.620 --> 27:27.260
not add lambdas because, you know, James Gosling said in public that lambdas are unnecessary.

27:27.260 --> 27:30.140
So then you're not going to kind of turn around and add them.

27:30.140 --> 27:31.140
No.

27:31.140 --> 27:35.380
So first of all, he had to kind of retire, kind of join Google, join whatever company

27:35.380 --> 27:36.380
is now at.

27:36.380 --> 27:39.300
I think he's doing self-driving cars at Stanford.

27:39.300 --> 27:47.580
And finally, they could put delegates lambdas into Java.

27:47.580 --> 27:53.060
But the other thing is also, you should not kind of downplay and be arrogant and downplay

27:53.060 --> 27:54.060
theory.

27:54.060 --> 27:55.060
Okay?

27:55.060 --> 27:57.740
You should always stay humble and hungry.

27:57.740 --> 28:00.260
You always want to learn.

28:00.260 --> 28:05.060
If these mathematicians come up with something, you know, but you better have a look at it

28:05.060 --> 28:07.900
because maybe it's something that you can use.

28:07.900 --> 28:09.500
All right.

28:09.500 --> 28:14.940
But then you can say, come on, Eric, what are you talking about?

28:14.940 --> 28:22.660
Customers and categories represent mathematical objects, whereas we as developers, we deal

28:22.660 --> 28:30.220
with objects that represents real-world things, okay, like customers and orders and all kind

28:30.220 --> 28:36.900
of other boring things that we have to do in our day jobs and rather not do, okay?

28:36.900 --> 28:42.340
But that's also not true because most of our programs that we like to write when we don't

28:42.340 --> 28:44.260
have to do customers and orders.

28:44.260 --> 28:50.180
Our data structures, list, trees, those don't represent real-world objects.

28:50.180 --> 28:52.140
I've never seen a list.

28:52.140 --> 28:58.180
I've seen trees in the real world, but they're not like the trees that I have in my code,

28:58.180 --> 28:59.180
right?

28:59.180 --> 29:07.100
And maybe lists a little bit, although, you know, the lists that I have on my refrigerator

29:07.100 --> 29:08.860
never get garbage collected.

29:08.860 --> 29:13.260
They never get finished, whereas the lists in my computer always kind of, you know, end

29:13.260 --> 29:14.980
up kind of disappearing.

29:14.980 --> 29:25.580
So, all right, but anyway, so I think that this whole idea that objects represent real-world

29:25.580 --> 29:32.500
things is nonsense because most objects that we deal with in programming don't represent

29:32.500 --> 29:36.020
real-world objects.

29:36.020 --> 29:42.100
And the other thing is that what we can learn, so what we can learn from these mathematicians

29:42.100 --> 29:47.740
is that we should be more careful in formalizing the things that we deal with.

29:47.740 --> 29:55.820
For example, if we write code in Java, we deal with methods, but these methods themselves,

29:55.820 --> 30:00.700
you know, we don't have an object that represents them.

30:00.700 --> 30:01.700
Is that true?

30:02.140 --> 30:07.660
Well, that's what we're after, but I'll say something more about it later.

30:07.660 --> 30:12.660
But the other thing that we can learn from the mathematicians is that we should also

30:12.660 --> 30:17.780
be more careful that when we define a type that we think about the properties, because

30:17.780 --> 30:24.220
otherwise some smart-ass colleagues of you can always return null and then claim that

30:24.220 --> 30:30.860
this is a proper implementation, because you have not specified with that type what the

30:30.860 --> 30:33.140
properties are, okay?

30:33.140 --> 30:40.660
And the good thing is that we don't have like weird terminology, although if you use UML

30:40.660 --> 30:44.940
and all that stuff, I guess there's plenty of craziness there.

30:44.940 --> 30:52.700
Now, this is, I'm a big fan of Bertrand Meyer, he's not related because his last name is

30:52.700 --> 30:59.860
with a Y and mine is with IJ, but he has a great saying where he says that, you know,

30:59.860 --> 31:04.380
objects don't really represent real-world things because you're always kind of removed.

31:04.380 --> 31:09.660
Even if you have a person object, it doesn't really represent a person because it's something

31:09.660 --> 31:13.860
in the memory of your computer that represents a person.

31:13.860 --> 31:19.500
So you're all kind of ready twice removed from reality, okay?

31:19.500 --> 31:26.540
So let's just forget about that and just look at objects in programming as formal things

31:26.540 --> 31:30.300
just like mathematical objects.

31:30.300 --> 31:36.820
All right, now I've been talking about programming, I thought this was about category theory.

31:36.820 --> 31:46.140
Now, the thing before we go there is we do have a way to talk about methods as objects

31:46.140 --> 31:49.460
and that is with reflection, okay?

31:49.460 --> 31:53.700
Because if you do reflection in Java, you can kind of, you know, go to a type, get this

31:53.700 --> 31:57.500
method and you can even invoke that method using reflection.

31:57.500 --> 32:03.340
Now, reflection, if you think about it, is super complex because it's a program that

32:03.340 --> 32:06.060
can reason about itself.

32:06.060 --> 32:09.060
Most of us are not even able to reason about ourselves.

32:09.060 --> 32:14.900
You know, when we're acting foolishly in public after we've been kind of, you know, partying,

32:14.900 --> 32:15.900
are we reflecting?

32:15.900 --> 32:18.140
No, typically not.

32:18.140 --> 32:21.220
Or maybe we do sometimes.

32:21.580 --> 32:28.660
But code, it's amazing that we can write code that kind of reflects about itself and the

32:28.660 --> 32:33.020
mathematicians cannot do that.

32:33.020 --> 32:39.860
But reflection is kind of a cop out because with reflection, we're not really kind of

32:39.860 --> 32:44.420
having an object that represents a method because it's kind of, you know, in the kind

32:44.420 --> 32:47.580
of dream world of reflection.

32:47.580 --> 32:53.060
And what we're trying to do here with lambdas or with methods references, we're trying

32:53.060 --> 32:59.340
to represent methods as normal objects, not as reflective objects.

32:59.340 --> 33:03.900
Oh, my goodness.

33:03.900 --> 33:04.900
This has to come.

33:04.900 --> 33:05.900
Okay.

33:05.900 --> 33:09.700
Dave Thomas, small talk, everybody knows Dave Thomas.

33:09.700 --> 33:10.700
Okay.

33:10.700 --> 33:11.700
Small talk guy.

33:11.700 --> 33:16.460
Of course, what do small talk people say?

33:16.460 --> 33:21.620
And I was a young boy and we read a small talk was still popular.

33:21.620 --> 33:24.420
That was a long time ago.

33:24.420 --> 33:29.500
We already had blocks that blocks are things that represent methods.

33:29.500 --> 33:35.060
And that's quite remarkable because if you look at small talk, that is very much as the

33:35.060 --> 33:40.900
flavor, this anthropomorphic flavor where objects represent real world things where

33:40.900 --> 33:42.700
you send messages to it.

33:42.700 --> 33:50.180
But still, they already knew that they had to represent methods as objects themselves.

33:50.180 --> 33:51.580
Okay.

33:51.580 --> 33:52.860
But don't worry.

33:52.860 --> 33:56.180
I won't talk about small talk.

33:56.180 --> 34:02.740
And the reason is that in small talk, like what we saw here in mathematics, array indexes

34:02.740 --> 34:10.700
start with one, which as a Dutch person is unacceptable because the big extra as told

34:10.700 --> 34:14.020
us that indexes should start at zero.

34:14.020 --> 34:16.620
And you know the reason why?

34:16.620 --> 34:20.100
Because when he is kind of, you know, that's why I'm kind of doing this papers.

34:20.100 --> 34:23.420
The first paper, there are zero papers here.

34:23.420 --> 34:25.740
So that's why it's zero.

34:25.740 --> 34:28.540
And now the second paper, now it's two.

34:28.540 --> 34:33.100
So you see that's how he can because he always wrote his, his papers by hand.

34:33.100 --> 34:36.940
And so he counted like how many papers were already there.

34:37.340 --> 34:37.940
Okay.

34:37.940 --> 34:41.660
So now you know why you should be counting that with zero.

34:41.660 --> 34:44.660
Okay.

34:44.660 --> 34:55.460
Now let's kind of talk about why we are really here is how do we represent methods as objects?

34:55.460 --> 34:59.940
And again, category theorists have a fancy word for that.

34:59.940 --> 35:02.500
They call it exponentials.

35:02.500 --> 35:06.140
And then you can ask yourself, why do they call it exponentials?

35:06.140 --> 35:09.460
Why don't they call it lambdas or anything normal?

35:09.460 --> 35:16.380
Like in TypeScript, you know, arrow functions or, I don't know, blocks.

35:16.380 --> 35:19.620
Well, there's actually a good reason.

35:19.620 --> 35:25.220
But if we look at this, I don't know, I see people already except for Mr.

35:25.220 --> 35:27.460
Generic here.

35:27.460 --> 35:30.740
He's like, oh yes, yeah.

35:30.740 --> 35:33.060
This is like, you know, beautiful.

35:33.060 --> 35:34.020
This is beautiful.

35:34.020 --> 35:38.820
For the rest of us, it looks a little bit like, look at this.

35:38.820 --> 35:41.740
There's even now two diagrams here.

35:41.740 --> 35:42.020
Okay.

35:42.020 --> 35:43.220
But I see a lambda.

35:43.220 --> 35:44.060
Can you see that here?

35:44.060 --> 35:47.260
It's like, you know, the font is not so sharp, but there's a lambda.

35:47.260 --> 35:49.620
So we're in the right direction.

35:49.620 --> 35:52.940
So let's decode the Greek and let's zoom in.

35:52.940 --> 35:58.180
So it says, let's see be a category with binary products.

35:58.180 --> 36:03.300
So that's the reason why we started out with tuples because in order to do functions,

36:03.300 --> 36:04.580
we need them.

36:04.580 --> 36:08.860
That was a little bit of the foresight of me.

36:08.860 --> 36:17.620
And let Y and CB objects, the exponential object, Z to the power of Y.

36:17.620 --> 36:18.580
Oh my goodness.

36:18.580 --> 36:19.940
Why?

36:19.940 --> 36:25.780
This is why they're called exponentials because they write it as an exponent.

36:25.780 --> 36:30.260
It's defined, blah, blah, blah, and then there's a new word, functor.

36:30.260 --> 36:36.900
Oh, I thought that we were ready because I kind of cheated by doing these products first.

36:36.900 --> 36:39.980
But now we kind of have another hurdle here.

36:39.980 --> 36:43.620
I have to explain to you what functors are.

36:43.620 --> 36:54.300
But first, let me kind of explain a little bit why this notation of exponentials makes sense.

36:54.300 --> 36:59.540
And the reason is that if I have a function from a type,

36:59.580 --> 37:08.420
Y to a type Z, that there are Z to the power of Y possible functions.

37:08.420 --> 37:16.380
Okay, so if I have two types, Y and Z, and I take all the functions from Y to Z,

37:16.380 --> 37:19.620
then there are Z to the power of Y of them.

37:19.620 --> 37:21.620
Now, how can I remember that?

37:21.620 --> 37:24.260
Okay, I see somebody here puzzled.

37:24.260 --> 37:27.180
Okay, now let's do the simplest case.

37:27.180 --> 37:33.340
Let's say that Y, so this is a function from Y to Z.

37:33.340 --> 37:38.780
So now let's take Y to be unit, okay, or void.

37:38.780 --> 37:40.580
So there's only one value.

37:40.580 --> 37:45.060
And let take Z be booleans, true and false.

37:45.060 --> 37:50.060
So how many functions are there from void to boolean?

37:50.060 --> 37:50.940
Only two.

37:50.940 --> 37:55.780
I can go from void to true and from void to false.

37:55.780 --> 38:02.820
Okay, now how many functions are there from booleans to unit?

38:02.820 --> 38:08.060
Well, there's only one that maps true to unit and false to unit.

38:08.060 --> 38:11.180
Okay, those are mathematical functions.

38:11.180 --> 38:17.780
Now you can say in Java, how many functions are there from bool to unit?

38:17.780 --> 38:18.540
How many?

38:18.540 --> 38:25.140
Because I can do print line, you know, of that boolean and that returns unit.

38:25.140 --> 38:32.300
I can kind of, you know, send it with an HTTP request to whatever, get it back.

38:32.300 --> 38:33.620
That's another function.

38:33.620 --> 38:36.100
I can do reflection over the boolean.

38:36.100 --> 38:37.980
So there's many functions.

38:37.980 --> 38:45.980
And this is why in Java, a method, so I'm a little bit lying because a method,

38:45.980 --> 38:52.060
you know, of bool to unit is not really a function because there can be side effects.

38:52.060 --> 38:58.620
There's a lot of context that's hidden in Java that you can use as a programmer to kind

38:58.620 --> 39:04.940
of cheat and don't show that, you know, that doesn't show up in the signature.

39:04.940 --> 39:09.540
Now, if you're, I don't know if there's any kind of, you know, fundamentalist functional

39:09.540 --> 39:15.180
programmers here, people that, crazy people that like Haskell and no Haskell programmers

39:15.180 --> 39:17.500
here, there's one Haskell programmer.

39:17.500 --> 39:18.780
Now he's smiling.

39:18.780 --> 39:19.980
He says, yeah, look at that.

39:19.980 --> 39:21.580
And Haskell, this is true.

39:21.580 --> 39:24.580
No, then your crappy Java, right?

39:24.580 --> 39:29.540
Because in Haskell, Haskell functions are really mathematical functions.

39:29.540 --> 39:31.940
So everything is explicit.

39:31.940 --> 39:36.300
But you know, that's why, you know, what is your name?

39:36.300 --> 39:43.340
Oh, my goodness, even, even more complicated than Mr. generic.

39:43.340 --> 39:47.380
Let me call you Mr. H. Mr. H there.

39:47.380 --> 39:52.020
This code is like probably 10 times longer than the Java code.

39:52.020 --> 39:56.420
By the time he's kind of done all his monads and whatever.

39:56.420 --> 40:02.700
So, you know, again, maybe it's good to have him as a colleague, because then you can,

40:02.700 --> 40:06.700
you know, you can learn from him and then write all this code implicitly.

40:06.700 --> 40:11.260
And then he will say, oh, but I can do now my kind of monad transformer with the state

40:11.260 --> 40:14.500
monad and the maybe monad and the list monad.

40:14.500 --> 40:18.900
And by the time he has figured out how to compose all these monads, you're already here

40:18.900 --> 40:23.900
at Foucafé listening to your next talk that you can put on your resume.

40:23.900 --> 40:25.780
And you get ahead.

40:25.780 --> 40:27.500
Isn't that great?

40:27.500 --> 40:28.500
Okay.

40:28.500 --> 40:29.500
Good.

40:29.500 --> 40:34.980
Let's translate this into normal language.

40:34.980 --> 40:40.540
Let L be a language that supports tuples, okay?

40:40.540 --> 40:42.700
That's already a big step.

40:42.700 --> 40:48.980
And let's assume that Java has tuples and let A and B types in the language, a function

40:48.980 --> 40:55.620
A, arrow B, I'm just using normal notation now, can be defined as a factory method from

40:55.620 --> 40:56.620
the functor.

40:56.620 --> 40:57.620
Okay.

40:57.620 --> 41:05.060
So, we're nearly there, but now I have to explain what a functor is because I've removed

41:05.060 --> 41:10.900
all the Greek and I say there's a factory method for functions.

41:10.900 --> 41:16.660
But in order to do that, I need to know what a functor is.

41:16.660 --> 41:18.980
Now what is a functor?

41:18.980 --> 41:24.420
And again, this is why most of us hate mathematics so much because I warned you that you often

41:24.420 --> 41:27.120
go into the rabbit hole, okay?

41:27.120 --> 41:32.380
And now we're going into the rabbit hole a little bit because when you look up functor

41:32.380 --> 41:35.580
on Wikipedia, it's even more Greek.

41:35.580 --> 41:37.580
Oh my goodness.

41:37.580 --> 41:40.420
Ah, does it ever stop?

41:40.420 --> 41:44.780
Well, let's look at it and it's not that bad.

41:44.780 --> 41:49.100
Let C be a category, a functor, blah, blah, blah, blah, blah, blah, blah, blah, blah.

41:49.100 --> 41:50.100
Okay.

41:50.100 --> 41:53.380
Let's translate this into normal English.

41:53.380 --> 42:00.140
And now we certainly understand it because since Java 6 and it was it, when did Java

42:00.140 --> 42:01.140
get generics?

42:01.140 --> 42:03.140
Was it Java 5?

42:03.140 --> 42:04.140
Wow.

42:04.140 --> 42:05.140
Look at that.

42:05.140 --> 42:08.700
That's a long time ago.

42:08.700 --> 42:12.620
The way they did it, yes.

42:12.620 --> 42:23.620
So here a functor is a generic type that associates with each type A, a new type, C of A. So list

42:23.620 --> 42:31.740
of T is a functor because I can instantiate it with another type, say int, sorry, integer

42:31.740 --> 42:36.820
because generics in Java suck that you can only instantiate them with reference types

42:36.820 --> 42:39.900
and not with base types.

42:39.900 --> 42:41.140
But yes.

42:41.140 --> 42:51.500
And then on that type, there must be a function map that goes from C of A to C of B. Now think

42:51.500 --> 42:53.700
about this.

42:53.700 --> 42:55.500
What does this thing do?

42:55.500 --> 43:01.860
It says that if I go, if I can go, say from integers to string, because I have two string,

43:01.860 --> 43:06.300
right, that goes from integers, from integers to string.

43:06.300 --> 43:12.220
Now if I have a list of integers, I must be able to kind of, you know, do two string

43:12.220 --> 43:15.000
on every element of that list.

43:15.000 --> 43:21.620
And that's all what this thing is saying, that if I can go from int to string, then

43:21.620 --> 43:28.860
I must go from list of int, oh sorry, list of int to list of string.

43:28.860 --> 43:32.100
That is, that's quite reasonable, right?

43:32.100 --> 43:36.780
And when we define generics, so again, here's a trick.

43:36.780 --> 43:44.980
Whenever your colleague defines a generic type, probably they don't specify that this

43:44.980 --> 43:50.420
should hold, that if you have, if you instantiate that generic type with one type, you instantiate

43:50.420 --> 43:54.020
with another that you have to be able to go between them.

43:54.020 --> 43:57.100
Well, they should have a map function.

43:57.100 --> 44:02.900
Now the thing with this map function is that it should have some properties too.

44:02.900 --> 44:08.260
Say that, you know, I'm going from list of int to list of int.

44:08.260 --> 44:10.380
Well, how do I do that?

44:10.380 --> 44:14.260
By doing the identity function, I'm doing nothing on each element.

44:14.260 --> 44:17.580
So that should be delivered the same value, right?

44:17.580 --> 44:19.380
That is kind of reasonable.

44:19.380 --> 44:28.100
The other thing is that if I do a map and then another map, that must be the same as

44:28.100 --> 44:33.500
doing the map with these functions combined, okay?

44:33.500 --> 44:39.180
And this is like an optimization trick, because instead of taking a list of int, going into

44:39.180 --> 44:44.140
a list of string, and then say taking the length of the string, so now getting a list

44:44.140 --> 44:50.620
of int again, I don't have to build that intermediate list, because then I can just map this function

44:50.620 --> 44:51.980
over that list.

44:51.980 --> 44:59.460
So these category theorists also are efficiency freaks, because they say that this map must

44:59.460 --> 45:04.380
have these properties so that they can optimize their code, okay?

45:04.380 --> 45:12.660
So a functor is just a generic function that has a map operator.

45:12.660 --> 45:21.460
Now, in normal Java generics, most functions, most types, most generic types, don't come

45:21.460 --> 45:22.460
with a map.

45:22.460 --> 45:29.580
Finally, in Java 8, when they introduce streams, streams have a map function.

45:29.580 --> 45:32.740
You can go check now.

45:32.740 --> 45:36.820
If you Google Java 8 streams, you will see there's a map function.

45:36.820 --> 45:47.620
So finally, after like decades and decades, sorry, 20 years of Java and finally, you know,

45:47.620 --> 45:52.700
they have map, whereas if they would have listened to the mathematicians, when they

45:52.700 --> 45:58.620
designed generics, that should have been built in, because, you know, that gives you again,

45:58.620 --> 46:03.660
that is this thing where, you know, a type doesn't come by itself, it comes with properties

46:03.660 --> 46:05.900
that it should satisfy.

46:05.900 --> 46:09.060
Okay, hey, great.

46:09.060 --> 46:15.500
Now we know what a functor is.

46:15.500 --> 46:24.940
Now the other thing, if there's category theorists here in the room, I have to be a little bit

46:24.940 --> 46:31.100
careful, because what I said is a category was a programming language, and a functor

46:31.100 --> 46:35.860
is really something that kind of goes between two categories.

46:35.860 --> 46:41.180
So a functor can go between two programming languages.

46:41.180 --> 46:52.700
For example, if you have a Java array and a small talk array, then one starts indexing

46:52.700 --> 46:59.100
at zero, the other start indexing at one, and now say that I have a method on arrays

46:59.100 --> 47:06.820
that sums up the values, when I go from Java to small talk, I have to adjust that sum function

47:06.820 --> 47:09.340
to start kind of indexing at one.

47:09.340 --> 47:12.180
Okay, that's another example of a functor.

47:12.180 --> 47:15.020
But for today, we're only looking at endo functors.

47:15.020 --> 47:17.780
Ah, doesn't that sound cool?

47:17.780 --> 47:22.740
Endo functors, but an endo functor just means that it stays within one language, it doesn't

47:22.740 --> 47:26.060
go between two languages.

47:26.380 --> 47:30.420
Okay, good.

47:30.420 --> 47:35.460
So this is the Greek decoded.

47:35.460 --> 47:44.420
Now I've cheated a little bit already, because in here, you will see when I defined map,

47:44.420 --> 47:51.780
I already used the fact that I have a function that I can pass into map.

47:51.780 --> 47:56.740
But before Java 8, you couldn't do that, right?

47:56.740 --> 48:01.220
Because there were no functional, there were no lambdas, so you could not even define map.

48:01.220 --> 48:07.780
So we had to wait until Java 8 in order to have functions such that we can define map.

48:07.780 --> 48:12.660
But we're not there yet, because we were trying to kind of come up with how do I represent

48:12.660 --> 48:17.140
methods as first-class objects, how do I do lambdas?

48:17.140 --> 48:28.380
Okay, and lambdas reminds me, Eric, yes, that's what exponentials are for.

48:28.380 --> 48:30.460
Okay, let's go there.

48:30.460 --> 48:33.700
Okay, here was the Greek.

48:33.700 --> 48:42.020
Okay, blah, blah, blah, there's this object, there's a morphism, eval, blah, blah, blah.

48:42.020 --> 48:49.580
Okay, now then this diagram has to commute, and there we see our lambdas, so we're getting

48:49.580 --> 48:50.580
close.

48:50.580 --> 48:57.740
So let's turn this into reality.

48:57.740 --> 49:04.260
And of course, church, or this is Haskell B. Curry, will say, oh, but this is currying

49:04.260 --> 49:05.260
in Haskell.

49:05.260 --> 49:10.700
If you look here, you know, what this is doing here, this is called eval, blah, blah, blah.

49:10.700 --> 49:18.500
It's just currying, and Mr. H has seen this already, and he thought, yeah, when did I

49:18.500 --> 49:23.620
start doing Haskell in 1986, when did Haskell want to come out?

49:23.620 --> 49:29.140
I already did currying, and all you Java guys can only do it in Java 8.

49:29.140 --> 49:32.340
And most of you, oh, most of you were on Java 8.

49:32.340 --> 49:36.540
This is very progressive, because I know a lot of companies that are still doing Java

49:36.540 --> 49:39.020
6 most of the time.

49:39.380 --> 49:46.180
Okay, now here's, you're not Danish, I'm going to go to insult you.

49:46.180 --> 50:00.340
But here is Mr. C++, and he's a smart guy, because in 1979, somewhere, you know, you

50:00.340 --> 50:06.500
can find that on the web, he explained that there are no instance methods, okay?

50:06.500 --> 50:11.860
An instance method is just a static method that takes the dispointer as an additional

50:11.860 --> 50:12.860
argument.

50:12.860 --> 50:17.700
As I remembered it in the beginning, I said, we're only looking at morphisms as static

50:17.700 --> 50:18.700
methods.

50:18.700 --> 50:21.460
I'm going to ignore instance methods.

50:21.460 --> 50:23.700
It's because Bjarne told me so.

50:23.700 --> 50:28.700
Bjarne told me it's safe to ignore instance methods.

50:28.700 --> 50:39.580
So an instance method is just a morphism from the tuple of the disk parameter and the other

50:39.580 --> 50:41.700
parameter and returns a value.

50:41.700 --> 50:44.900
Okay, so that's where the tuples come in.

50:44.900 --> 50:47.420
And guess what?

50:47.420 --> 50:50.500
Even C++ is lambdas these days.

50:50.500 --> 50:52.340
Isn't this amazing?

50:52.340 --> 50:58.700
Here I don't think there's any kind of programming languages out there anymore that we all use

50:58.700 --> 51:01.220
that don't have lambdas.

51:01.220 --> 51:05.700
But it took many, many decades, and why is that?

51:05.700 --> 51:08.140
Because we didn't listen to the mathematicians.

51:08.140 --> 51:15.020
All right, now it might be the case that in C++ that Bjarne says, you know, there are

51:15.020 --> 51:17.620
no instance methods.

51:17.620 --> 51:27.260
But let's check what Java has to say.

51:27.260 --> 51:33.660
So if you want to have an even more boring document than the Java language specification,

51:33.660 --> 51:38.980
you should read the Java virtual machine specification, okay?

51:38.980 --> 51:46.820
But in the Java virtual machine specification, if you browse around a little bit and it says,

51:46.820 --> 51:55.300
when you call a class method or an instance method here, local variable zero, they start

51:55.300 --> 52:03.540
to count at zero, good boys, okay, is always passed to an object that represents the instance,

52:03.540 --> 52:05.100
okay?

52:05.100 --> 52:10.860
And the subsequent parameters are passed in subsequent local variables starting at one.

52:10.860 --> 52:15.740
So also in Java, there are no instance methods.

52:15.740 --> 52:23.440
It's just a static method where the first parameter with index zero is the disk, okay?

52:23.440 --> 52:29.300
So we can simply forget about instance methods.

52:29.300 --> 52:34.660
Now of course, there are a little bit things that I kind of put under the carpet.

52:34.660 --> 52:39.660
There's no carpet here, but you know, imagine there was a carpet, it's things like inheritance

52:39.660 --> 52:40.940
and so on.

52:40.940 --> 52:49.020
So inheritance is an interesting thing because inheritance is quite useful, although some

52:49.020 --> 52:53.880
crazy people say we shouldn't use inheritance, we should use composition.

52:53.880 --> 53:00.860
If you have any colleagues that say that, make them look bad and have them fired because

53:00.860 --> 53:05.940
they are making your life miserable because inheritance is a good thing.

53:05.940 --> 53:11.940
But the thing with inheritance is that usually it's explained in terms of the implementation.

53:11.940 --> 53:15.260
You start to talk about V tables and whatever.

53:15.260 --> 53:20.540
And the reason is because inheritance is a dirty implementation trick to make it easier

53:20.540 --> 53:29.580
to reuse code and to model inheritance mathematically is not easy and people write PhD thesis about

53:29.580 --> 53:30.580
that.

53:30.580 --> 53:36.940
William Cook, maybe you know him, wrote his PhD thesis about the semantics of inheritance.

53:36.940 --> 53:40.940
So I'm not going to talk about that today, okay?

53:40.940 --> 53:50.180
But let's continue decoding the Greek and now we are somewhere where we can understand

53:50.180 --> 53:51.180
what's going on.

53:51.180 --> 54:00.780
So to remind you, here's the category theory with the strange notation with the kind of

54:00.780 --> 54:05.100
exponentials and there was this lambda, blah, blah, blah.

54:05.100 --> 54:10.020
I didn't even bother to kind of go through that because you know, everybody would fall

54:10.020 --> 54:18.020
asleep after a few hot dogs and hamburgers, but now we are something that we can understand.

54:18.020 --> 54:29.380
So here, a function type here together with a method apply is a function, we call that

54:29.380 --> 54:32.140
a function type.

54:32.140 --> 54:41.260
If given any type A and a method M that takes an argument of type B and returns a C, defined

54:41.260 --> 54:49.860
on A and remember that if I have a method that's defined on A, it's really that M has

54:49.860 --> 54:56.580
type A as the first argument and B as the second argument, okay?

54:56.580 --> 55:03.060
Now what we can do is there's a factory method that takes an A and that factory method looks

55:03.060 --> 55:12.420
like colon, colon, M and it returns a function from B to C and that function object itself

55:12.420 --> 55:20.260
has an apply method such that when I apply that to B, that is the same as calling M on

55:20.260 --> 55:27.860
A and passing it B and then here I just cast to C so that you can show that it's the same,

55:27.860 --> 55:28.860
okay?

55:29.860 --> 55:35.420
Anybody here has used method reference in Java, if you use IntelliJ, it will tell you

55:35.420 --> 55:36.420
all the time, right?

55:36.420 --> 55:41.420
You write something and it says, I can refactor this into a method reference, do you use that?

55:41.420 --> 55:44.580
Anybody here uses IntelliJ?

55:44.580 --> 55:46.580
What is your name?

55:46.580 --> 55:47.580
Paul?

55:47.580 --> 55:54.540
Ah, finally a name I can pronounce, Paul, do you ever use refactor change into method

55:54.540 --> 55:55.540
reference?

55:55.540 --> 56:01.020
Yes, and do you recognize this kind of double colon crazy thing?

56:01.020 --> 56:07.700
So you have been using exponential objects, did you realize that?

56:07.700 --> 56:13.460
So now you can go to your boss and say in full cafe, I learned that I'm freaking using

56:13.460 --> 56:20.500
exponential objects from category tier in my coding, I need a raise because that son

56:20.500 --> 56:26.580
of a bitch next to me has no clue what they're doing, they're still using whatever virtual

56:26.580 --> 56:36.300
methods but I know exponential objects, good, but it's amazing.

56:36.300 --> 56:45.260
Function references, method references in Java are exactly the same as exponential objects

56:45.260 --> 56:53.540
in category tier because the only thing I've done here is translate the Greek into Java

56:53.540 --> 56:55.700
code, right?

56:55.700 --> 56:59.540
So why did it take so long?

56:59.540 --> 57:06.580
They could have sat down, done the same thing as I did, came up with this, said, hey, dude,

57:06.580 --> 57:10.380
let's hire somebody to implement this in the compiler and we're done.

57:11.140 --> 57:18.260
Okay, but I must say I find this pretty amazing because I'm 100% sure that the Java language

57:18.260 --> 57:28.740
designers had no idea of category theory but yet they came up with exactly the same solution.

57:28.740 --> 57:31.020
That is the amazing thing, okay?

57:31.020 --> 57:39.140
So it must be some universal truth here because otherwise you would not two completely independent

57:39.140 --> 57:45.940
people, one from theory, one from practice, come up with the same idea.

57:45.940 --> 57:52.460
So if you look at here, if I have a method reference and I call the apply method on that

57:52.460 --> 58:00.180
with argument of type B, that is the same as calling the method M on A, passing it B.

58:00.180 --> 58:02.660
That is how method references work.

58:02.660 --> 58:06.900
This is how category tier works, this is how exponential objects work.

58:07.900 --> 58:11.380
I mean, this is a miracle.

58:11.380 --> 58:19.780
I don't know about you, but when I discovered this, I don't know, I drank a whole bottle

58:19.780 --> 58:22.300
of this stuff.

58:22.300 --> 58:29.460
I don't know what this is, this is rum, I drank a neighbor, you know, that's kind of

58:29.460 --> 58:33.220
the Dutch vodka, okay?

58:33.220 --> 58:36.180
But this is great.

58:36.180 --> 58:44.260
Now you can say, great, we now know that method references are exponential objects, okay?

58:44.260 --> 58:49.300
So tomorrow when you go back to work, you're saying, let's do some kind of, let's introduce

58:49.300 --> 58:52.100
some exponentials and IntelliJ can help us with that.

58:52.100 --> 58:55.020
No, don't say that, you kind of use that.

58:55.020 --> 59:01.180
But here's Eric Meyer and he has not mentioned the M word yet.

59:01.180 --> 59:04.380
I have not mentioned monads yet.

59:04.380 --> 59:12.260
So I'm going to do a little bit, yes, now I have, before as well.

59:12.260 --> 59:17.900
When I was talking about Haskell, yes, that's true, but that was more like a joke.

59:17.900 --> 59:22.500
Okay, now let's look at this thing.

59:22.500 --> 59:30.780
So if you look at this exponential object, blah, blah, blah, there's a right adjoint

59:30.780 --> 59:32.620
and there's home sets.

59:32.620 --> 59:35.900
Now home sets have nothing to do with fish eggs.

59:35.900 --> 59:41.140
I don't know, is that the same in Swedish, home in Dutch, that's kind of the eggs of

59:41.140 --> 59:43.860
a fish, like caviar.

59:43.860 --> 59:47.100
This has nothing to do with caviar, okay?

59:47.100 --> 59:54.940
It just says that if I have a function from x to y to z, that is kind of isomorphic to

59:54.940 --> 59:59.540
having a function that takes x and y and returns z, okay?

59:59.540 --> 01:00:05.900
So this is really saying that you can curry and uncurry and go in two directions, okay?

01:00:05.900 --> 01:00:14.260
And a home set, home A, B is just a fancy way of saying all morphisms from A to B,

01:00:14.260 --> 01:00:15.260
okay?

01:00:15.260 --> 01:00:18.580
So this is just a fancy thing.

01:00:18.580 --> 01:00:25.220
And the method, the magic of method references is really what it's saying, right?

01:00:25.220 --> 01:00:32.740
It's saying that, you know, there's an isomorphism between the lambda expression B arrow A, method

01:00:32.740 --> 01:00:38.620
reference B and this method call here.

01:00:38.620 --> 01:00:44.420
So there's nothing kind of really fancy about this.

01:00:44.420 --> 01:00:48.500
And then, you know, we can kind of talk about adjoints because that was the other thing

01:00:48.500 --> 01:00:49.500
in there.

01:00:49.500 --> 01:00:55.700
For an adjoint, I have to have two functors and in our case, it's this.

01:00:55.700 --> 01:01:01.240
And to really prove that I'm not talking nonsense, you know, here's some real code that actually

01:01:01.240 --> 01:01:05.660
executes if you use Scala.

01:01:05.660 --> 01:01:13.140
But now, here's the thing, that if you have two of these adjoint functors and these are

01:01:13.140 --> 01:01:19.660
the conversions between them, that gives rise to a monad.

01:01:19.660 --> 01:01:27.420
So we came from exponential objects, there came this notion of adjoint functors.

01:01:27.420 --> 01:01:30.180
And once you have adjoint functors, you get monads.

01:01:30.180 --> 01:01:32.460
So there's no escape from the monads.

01:01:32.460 --> 01:01:39.540
So in the end, everybody will be like Mr. H, because, you know, now that Java 8 has

01:01:39.540 --> 01:01:44.180
exponentials, the next thing it will have are monads.

01:01:44.180 --> 01:01:47.180
Because that's what category theory predicts.

01:01:47.180 --> 01:01:53.940
And I went through this real quick, but I tell you, 10 years from now, 20 years from

01:01:53.940 --> 01:01:59.260
now, this will be the case.

01:01:59.260 --> 01:02:05.580
Java will have monads, because monads are related to adjunctions and adjunctions come

01:02:05.580 --> 01:02:08.500
from exponentials.

01:02:08.500 --> 01:02:17.620
Now the funny thing is that the state monad comes from this adjunction there, but that's

01:02:17.620 --> 01:02:20.300
a topic for a different talk.

01:02:20.300 --> 01:02:29.980
So here's the next thing, when you have a lot of beer tonight, this will be your next

01:02:29.980 --> 01:02:33.220
tattoo, okay?

01:02:33.220 --> 01:02:38.380
So category theory here directly corresponds to Java.

01:02:38.380 --> 01:02:43.980
And if this is a little bit too dark for you, what about this one?

01:02:43.980 --> 01:02:45.940
This one looks cute, right?

01:02:45.940 --> 01:02:56.300
And I made a special deal with Liz's tattoo parlor, where if you show your Foucaffé t-shirt,

01:02:56.300 --> 01:03:07.140
you will get a discount on any of those two tattoos.

01:03:07.140 --> 01:03:07.980
Thank you very much.

