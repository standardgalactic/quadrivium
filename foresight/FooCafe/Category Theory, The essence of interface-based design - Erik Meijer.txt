What we're going to do tonight is to celebrate, of course, the three-year anniversary of Foucafé.
And also we're going to give a tribute to Joachim Lambeck, who is a kind of category
theorist that kind of made the connection between the lambda calculus and category theory.
And, funnily, his name kind of, you know, has the same prefix as the lambda calculus.
That isn't that a coincidence.
I don't know.
But anyway, so just in the spirit of deliberate and continuous learning, you know, like, who
here uses Java 8?
A few people.
Who here uses Java 6?
A few people as well.
So it has taken, like, many, many years before Java 6 became Java 8 and added lambdas.
Now if the language designers would have practiced deliberate and continuous learning, it would
have happened, like, you know, decades ago, because all this knowledge was already developed
by people like Lambeck.
And tonight I'm going to tell you the tricks how you, as a developer, can tap into the
brains of mathematicians and kind of steal their ideas such that, you know, you can become
a better developer and then go to your boss and ask for more money, because you're an
awesome developer.
All right.
Let's get started.
Oops.
So one of my guilty pleasures is I read language specifications.
So some of you kind of, you know, might read novels or newspapers, maybe.
I read language specifications.
And for a while I was collecting them.
I had a whole bunch of, you know, going all the way back to, you know, the early Lisp,
1.0 manual, Pascal, everything.
So whenever there was a new language, I would read the language manual.
So I read all of them, Visual Basic, C-Sharp, ECMAScript, Swift, Dart, you name it.
But there's one language specification that even for me was too strong.
It was impossible to read.
And that language specification is Java 8.
Now I don't know, anyone, has anyone here ever looked at the Java language specification?
Okay.
Did you fall asleep immediately?
I mean, you open up this thing and you fall asleep.
I mean, it's like, try it, you know, some, you know, and you kind of cannot sleep at
night.
Your kind of mind is wandering.
Just open that thing up.
It will work better than any pill.
And this one in particular is really weird.
So when Java 8 came out, and there's this kind of weird thing with method references,
so I thought, I really want to understand this.
So I started to read the language pack.
It doesn't, my goodness, it's just way too complicated.
So what do I do?
When something is complicated, I'm always listening to this guy.
This is Leslie Lamport, and he won the Turing Award last year.
Okay.
Well, if you win the Turing Award, well, that means something.
And one of the kind of advice that Lamport gives us is that we should kind of do more
math.
We should use more math.
If you're like a mechanical engineer, you build, or like a civil engineer, you build
a bridge or something, you use math, okay?
If you're a chemist, you use math.
But we as computer scientists seem to be afraid of mathematics.
And what Lamport says, and what I will tell you, is you shouldn't be afraid.
And I think a lot of people here, I don't know, maybe, you know, in Sweden, it's different.
You're not afraid of math, you know, you, instead of language specifications, you read
like books on calculus before you go to bed, I'm pretty sure.
Typically, when I meet developers, they are kind of afraid of mathematics.
And I think there's several reasons for that, and those are good reasons.
First of all, mathematics, most textbooks are really bad.
The notation is weird, it doesn't even type check, you know, if you're trying to kind
of, you know, look at it, it doesn't work.
The lingo is weird, they have all their own terms.
They often, you kind of end up in a rabbit hole, you know, you want to kind of know a
little bit, and before you know it, you know, you're kind of, you know, deep into all kind
of Greek symbols and other dirty pictures.
And last but not least, often mathematics is taught in a bottom up way, okay?
So you cannot say, I need to solve a particular problem, and I need a piece of mathematics
for that.
No, instead, they start bottom up.
So you have to first know a whole bunch of mathematics before, finally, you can apply
it to your problem.
Whereas with computing, we typically teach the other way around.
Who here has a computer science degree?
Okay, I would say about half.
So the other people don't have a computer science degree, they still know how to program,
but they didn't start by studying, you know, big O, they didn't start to study touring
machines.
No, they just opened up an editor and started to hack.
They did it top down.
And of course, at some point, you will feel that maybe you need a little bit more theory,
but programming is typically taught top down.
So you don't start with all the theory, but no, you start by solving a particular problem,
and then you go down.
Let me give you a really good example of that.
Linear algebra.
When most people teach linear algebra, they talk about matrices and then you have to multiply
matrices and then you have to kind of do all kind of mechanical, stupid things.
And then you use it to do graphics.
But you know, instead of kind of knowing why you do it, you're kind of manipulating this
kind of low level representation.
Now if you know that a matrix, an m by n matrix is really the representation of a linear function
from a sequence of numbers of length n to a sequence of numbers of length m.
And matrix multiplication is function composition.
So really, when you're doing matrix manipulations, you're doing assembly language programming.
This is completely nonsense that we as humans have to do that.
If instead they would teach linear algebra as a restricted form of functional programming
with some special functions that are linear, which means that they have nice properties,
everything would be easy.
But these are the stupid mathematicians that are too smart for their own sake and they
teach it bottom up.
And then in the end, you know, we scratch our heads.
I scratch my head way too often.
And then we ask ourselves, why is this useful?
All right.
So linear algebra is really easy.
It's just functional programming with linear functions.
Matrix multiplication is function composition done.
Same is true with category theory.
If you look at category theory, it looks scary, just like linear algebra, but it's really
easy.
So let's start looking at that.
So mathematicians often call, this is kind of weird, right?
Mathematicians that give us linear algebra, they look at category theory and say this
is abstract nonsense.
And the reason that they say it's abstract nonsense is because in category theory, proofs
are done in a very abstract way.
So it's, look at what it says here.
It's the study of the general form of mathematical theories without regard to their content.
What that means is that all intuition is taken away.
And you look at the pure, you know, pure general form.
Well, as programmers, we recognize that because whenever we do, whenever we program against
an interface, that's exactly what we're doing.
We're programming against a thing without regard to their content.
We're not programming against a concrete type.
We're programming against the abstract interface.
And then there can be many concrete types that we can plug in, but the program is still
the same.
The other thing that's interesting is that here they talk about proofs.
So you build your proof on these kind of general theories.
Well, there's a very, very interesting thing.
It's called the Curry-Howard isomorphism.
People heard about the Curry-Howard isomorphism.
It's one of the most beautiful ideas I've ever seen.
So Curry-Howard isomorphism says that a type is a theorem and the program is the proof
for that theorem.
Now what means that whenever we're kind of writing code, we're really proving theorems.
So we are like mathematicians.
Or you can say, mathematicians are really developers, that program really, really slow.
It takes them like two decades to kind of write a small proof.
But this Curry-Howard isomorphism is really beautiful.
I don't have time today to talk about it.
But if you take that a little bit further, that's what I'm going to do here is that you
define your theorems in terms of these abstract structures.
And then you write your code in terms of them, so you do your proofs in terms of them.
And so let's continue with that.
And as I said, this is really not foreign to, for us developers, because we do this all
the time.
We do this when we program against interfaces.
We do this when we use design patterns.
I'm pretty sure that most people have that book on their bookshelves.
And I'm also sure that nobody has ever read it.
Because when you read it, you get the feeling, what's going on?
This is all kind of, you know, how did the mathematicians say this?
This is without regard to any actual content, because these design patterns are very abstract
and you can instantiate them for specific purposes.
But that's the beauty of design patterns, because now you can talk about concepts in
a very abstract way, without kind of, you know, being tied to a very concrete implementation.
Okay?
So that's, already I give you a couple of tricks, how to think like a mathematician
and profit from that.
Now, what is category theory?
Well, category theory is embarrassingly simple.
It has two, well, three concepts.
First of all, there's a notion of a category, but a category consists of objects and morphisms.
Now, as I said, mathematicians are weird people.
They use strange lingo.
So let's translate this into programming terminology.
So a category is really a programming language, okay?
And a programming language has types, okay?
Like in Java, there's types, Boolean strings, lists, those are the types.
And then there are morphisms, well, that's just a fancy word for static method.
So morphism from A to B is just a static method that takes a argument of type A and
where there's a value of type B, or equivalently, you can say it's a property.
Now you can ask yourself, well, if you're saying that we're doing programming, why do
I use static methods?
Because we also have instance methods.
Well, we'll come back to that later.
So the whole point of this talk is to kind of, you know, fix this and make this precise.
So mix this notion precise that morphisms in a category are just static methods.
Now look at this.
This is, again, mathematicians.
I told you they're slow programmers.
So here's an example of a programming language.
It's a programming language that has three types, A, B, and C.
So it's like characters, integers, and Booleans.
That's it.
And then, well, if you have three types, then you can define some functions between them.
So for example, I can go from Booleans to characters, and I can have a function from
characters to characters.
Now for these mathematicians, this is so special that they give this language a name, and it's
called bold three.
Okay.
Now imagine if you want to draw this kind of picture for Java, you know, it wouldn't fit,
you know, you would need all the walls here, and, you know, maybe the whole city with graffiti
like this.
Maybe it would look quite nice.
It's like an art project.
But this is kind of mathematicians.
So they are kind of proud that they understand this programming language with three types.
Okay.
Now, of course, once you have types, you can create other types.
And everybody these days seem to want to have tuples.
And Java doesn't have tuples, but there's many libraries that provide tuples.
Anybody here does Android programming?
A few people not so few, what are you Windows phone, maybe?
No.
But if you do Android programming, you know, you know, and even if you don't, this might
be interesting to know, is that in the Android library, there is a type for tuples.
That's so important that even on your Android phone, you need tuples.
And here is some category theory that defines what tuples are in Mathematician speak.
Now you will ask yourself, oh my goodness, where's my beer?
The next beer, this looks kind of horrible.
Okay.
There's like all kind of weird stuff, commuting diagrams, canonical stuff.
I don't even understand this.
So let's take this Greek and let's try to translate this into a language that we all
understand.
Okay.
So here's the first sentence of that definition of tuples.
And it says, let's see be a category with some objects X1 and X2.
Well, as I said, a category corresponds to a programming language and a object corresponds
to a type.
Now, often people confuse objects and instances and whatever.
So let's not be confused.
So that's why I call them types and types have instances.
And whether you want to call the instances objects or the type objects, I don't care.
So that's why I call them types.
And also then it doesn't clash with the objects in the category.
Okay.
Now, what can I do when I have two types?
Well, I can form a tuple.
They don't call it tuples.
They call it a product.
Okay.
So they are going to take these two types, X1 and X2.
They're going to create a new type X, which, you know, they can also write as X1 cross
X2 and then blah, blah satisfies a universal property, blah, blah, blah, blah, blah, blah.
Do you understand this?
No.
Yes.
Good.
There's one person that understands it, great.
So let's go and drill down a little bit into this.
Because I think this picture says, said it much better.
So if I have a tuple or a product, I have two functions that I can use to project the values
out of this tuple.
So I can select the first element and I can select the second one.
Now you can ask yourself, why do they start counting at one?
Because we as developers always, now our index is zero.
And again, these are mathematicians, they don't, they probably never done C programming
or whatever.
So they can start their counting by one.
Anyway, so this is the kind of thing, but then there's all the rest of this.
And what we see here is, well, how on earth do you get an instance of a tuple?
Well, you need a constructor or a factory function.
These mathematicians are not stupid, right?
They know that when you create a type, when you have a type, you all you have to have
a way to create it.
We call it constructor, well, they have here some function that kind of allows you to kind
of create a tuple.
And then they say, well, if you have such a function, which you create from two morphisms,
then if you kind of start with a value here, you apply that to this function.
Now you get this guy, that must be the same as kind of projecting the first value or applying
this function.
So it all must kind of commute.
And that looks quite nice in that diagram.
Now if you don't like diagram, then you can translate it into equations, whatever you
find easier to read.
Now, except for this gentleman over there, what's your name?
Oh, I cannot pronounce that, but generic, good.
Mr. Generic over there, he understands this.
But that's kind of, you know, for the rest of us, you know, whose brains are the size
of peanuts or smaller, let's kind of continue to put this into our language.
So if we go on with this translation, we say that a type A comma B is a product of A and
B or a tuple of A and B, if it satisfies blah, blah, blah.
There exist two properties underscore one and underscore two that return an A and a B respectively.
Any Scala programmers here?
You recognize this?
Yeah, look at this, I see a smile.
Yep.
This is Scala, you can project the first and second element, but then there's also, if
you have two methods, the factory function for this thing takes two methods and it gives
you a function that given a C returns this pair of A and B, and it does that by kind
of applying that C to F and G respectively.
So this is a little bit different than in Scala because the constructor function behaves
a little bit different.
But we can, from this, we can create a normal constructor function too.
Okay, let's go look at this commuting diagram and it's kind of the same.
Now as I said, if you look at Scala, I don't know, I think this mathematics is actually
clearer and shorter.
Because look at this, trade, blah, blah, blah, extends, blah, blah, blah, abstract
this, abstract that, curly open, curly close.
Now you see why these mathematicians have their strange lingo because maybe we have editors
and we have autocomplete, but look at how many characters we need to write down kind
of something simple like this, okay?
But here is you see that this is the definition in Scala of a product and I think this is,
now you can ask yourself what the heck are those pluses there?
Am I going to kind of, I don't know, is this unary plus or no, no, no, that's co and contravariance.
But that's way too complicated, but this is actually the way that products are defined
in Scala, but what Scala doesn't have is this operator to construct a product.
Now the reason why Martin cannot do that is because if you would do that, you already
need the notion of functions as objects and that was the whole point of this presentation
to figure out, you know, how can we make these morphisms into first class things, okay?
So really, you know, if we look at this simple example where we took the idea of tuples and
we have seen how the mathematicians do it and we do it, it's really the same except
that the mathematicians apply a little bit more rigor, they use weird notation, but the
nice thing that they do, that we never do is when they define a type, they talk about
properties of the type, what properties should a product have?
Because if you look at this definition in Scala, right, from here it says nowhere that
when you create a tuple out of two values and you project from that tuple the first
value that you actually get the value that you put in there, right?
Nothing says this here because it can return null for both sides and it's still kind of
according to this type definition a valid implementation of tuple.
Of course, you would not accept that, but the type itself doesn't say anything.
So if you're a smart programmer and somebody gives you this trait and you have to implement
it, you can just return null in both cases, nobody can complain.
If they file a bug, you immediately file the bug back and say you didn't specify this
thing properly, okay?
This is another tip, okay?
You just return null, your colleagues complain, you just say sorry, you know, specify it better.
And then you can go have a drink, a beer, kind of go to another meeting, put that on
your resume, get even more money, look at this, all right, good.
So and here is the, you know, again, a slightly different way to do this function.
I'm going to skip this for lack of time.
Now Mr. Generic here says, oh, I knew this already, but this is old stuff, right?
Here is John McCarthy, the inventor of Lisp, and he says, well, come on, I could define
all this stuff with top polls and so on in 1960.
And then Church, Mr. Alonso Church, who invented the Lambda calculus, he did this already in
1928.
Now look, this guy here came up with this in 1928.
If you read the papers from Church, he was doing this kind of tuples.
In Java 8, it's 2015, last time I checked, there are still no proper tuples in the language.
Look at this, I don't even know, it's like 2015 minus, that's nearly a century, okay?
And we still don't, this thing still doesn't, we are, and why is that?
Because we are afraid of these mathematicians, whereas we should steal their ideas and profit
from them, okay?
That's really kind of my message today.
These people are smart, look at this size of this brain here, you know, if I put my
head next to it, it's like 10 times the size, we should leverage that.
But what do we do instead?
Well first of all, we are proud that, you know, we don't do theory.
So if you look at C-Sharp, C-Sharp has delegates, and it's like we don't need any of this theory,
we have delegates.
But where, you know, where does these delegates come from?
What are their properties?
We don't know.
And then, I don't know if anybody's old enough, probably most of you were not born yet, but
when C-Sharp came out, there was a little fight between C-Sharp and Java, where the
Java folks said, we don't need any of this lambdas or delegate stuff because we have
virtual methods.
And so this is another lesson, never say never, okay?
Because I think, because they didn't want to lose face for the longest time, Java could
not add lambdas because, you know, James Gosling said in public that lambdas are unnecessary.
So then you're not going to kind of turn around and add them.
No.
So first of all, he had to kind of retire, kind of join Google, join whatever company
is now at.
I think he's doing self-driving cars at Stanford.
And finally, they could put delegates lambdas into Java.
But the other thing is also, you should not kind of downplay and be arrogant and downplay
theory.
Okay?
You should always stay humble and hungry.
You always want to learn.
If these mathematicians come up with something, you know, but you better have a look at it
because maybe it's something that you can use.
All right.
But then you can say, come on, Eric, what are you talking about?
Customers and categories represent mathematical objects, whereas we as developers, we deal
with objects that represents real-world things, okay, like customers and orders and all kind
of other boring things that we have to do in our day jobs and rather not do, okay?
But that's also not true because most of our programs that we like to write when we don't
have to do customers and orders.
Our data structures, list, trees, those don't represent real-world objects.
I've never seen a list.
I've seen trees in the real world, but they're not like the trees that I have in my code,
right?
And maybe lists a little bit, although, you know, the lists that I have on my refrigerator
never get garbage collected.
They never get finished, whereas the lists in my computer always kind of, you know, end
up kind of disappearing.
So, all right, but anyway, so I think that this whole idea that objects represent real-world
things is nonsense because most objects that we deal with in programming don't represent
real-world objects.
And the other thing is that what we can learn, so what we can learn from these mathematicians
is that we should be more careful in formalizing the things that we deal with.
For example, if we write code in Java, we deal with methods, but these methods themselves,
you know, we don't have an object that represents them.
Is that true?
Well, that's what we're after, but I'll say something more about it later.
But the other thing that we can learn from the mathematicians is that we should also
be more careful that when we define a type that we think about the properties, because
otherwise some smart-ass colleagues of you can always return null and then claim that
this is a proper implementation, because you have not specified with that type what the
properties are, okay?
And the good thing is that we don't have like weird terminology, although if you use UML
and all that stuff, I guess there's plenty of craziness there.
Now, this is, I'm a big fan of Bertrand Meyer, he's not related because his last name is
with a Y and mine is with IJ, but he has a great saying where he says that, you know,
objects don't really represent real-world things because you're always kind of removed.
Even if you have a person object, it doesn't really represent a person because it's something
in the memory of your computer that represents a person.
So you're all kind of ready twice removed from reality, okay?
So let's just forget about that and just look at objects in programming as formal things
just like mathematical objects.
All right, now I've been talking about programming, I thought this was about category theory.
Now, the thing before we go there is we do have a way to talk about methods as objects
and that is with reflection, okay?
Because if you do reflection in Java, you can kind of, you know, go to a type, get this
method and you can even invoke that method using reflection.
Now, reflection, if you think about it, is super complex because it's a program that
can reason about itself.
Most of us are not even able to reason about ourselves.
You know, when we're acting foolishly in public after we've been kind of, you know, partying,
are we reflecting?
No, typically not.
Or maybe we do sometimes.
But code, it's amazing that we can write code that kind of reflects about itself and the
mathematicians cannot do that.
But reflection is kind of a cop out because with reflection, we're not really kind of
having an object that represents a method because it's kind of, you know, in the kind
of dream world of reflection.
And what we're trying to do here with lambdas or with methods references, we're trying
to represent methods as normal objects, not as reflective objects.
Oh, my goodness.
This has to come.
Okay.
Dave Thomas, small talk, everybody knows Dave Thomas.
Okay.
Small talk guy.
Of course, what do small talk people say?
And I was a young boy and we read a small talk was still popular.
That was a long time ago.
We already had blocks that blocks are things that represent methods.
And that's quite remarkable because if you look at small talk, that is very much as the
flavor, this anthropomorphic flavor where objects represent real world things where
you send messages to it.
But still, they already knew that they had to represent methods as objects themselves.
Okay.
But don't worry.
I won't talk about small talk.
And the reason is that in small talk, like what we saw here in mathematics, array indexes
start with one, which as a Dutch person is unacceptable because the big extra as told
us that indexes should start at zero.
And you know the reason why?
Because when he is kind of, you know, that's why I'm kind of doing this papers.
The first paper, there are zero papers here.
So that's why it's zero.
And now the second paper, now it's two.
So you see that's how he can because he always wrote his, his papers by hand.
And so he counted like how many papers were already there.
Okay.
So now you know why you should be counting that with zero.
Okay.
Now let's kind of talk about why we are really here is how do we represent methods as objects?
And again, category theorists have a fancy word for that.
They call it exponentials.
And then you can ask yourself, why do they call it exponentials?
Why don't they call it lambdas or anything normal?
Like in TypeScript, you know, arrow functions or, I don't know, blocks.
Well, there's actually a good reason.
But if we look at this, I don't know, I see people already except for Mr.
Generic here.
He's like, oh yes, yeah.
This is like, you know, beautiful.
This is beautiful.
For the rest of us, it looks a little bit like, look at this.
There's even now two diagrams here.
Okay.
But I see a lambda.
Can you see that here?
It's like, you know, the font is not so sharp, but there's a lambda.
So we're in the right direction.
So let's decode the Greek and let's zoom in.
So it says, let's see be a category with binary products.
So that's the reason why we started out with tuples because in order to do functions,
we need them.
That was a little bit of the foresight of me.
And let Y and CB objects, the exponential object, Z to the power of Y.
Oh my goodness.
Why?
This is why they're called exponentials because they write it as an exponent.
It's defined, blah, blah, blah, and then there's a new word, functor.
Oh, I thought that we were ready because I kind of cheated by doing these products first.
But now we kind of have another hurdle here.
I have to explain to you what functors are.
But first, let me kind of explain a little bit why this notation of exponentials makes sense.
And the reason is that if I have a function from a type,
Y to a type Z, that there are Z to the power of Y possible functions.
Okay, so if I have two types, Y and Z, and I take all the functions from Y to Z,
then there are Z to the power of Y of them.
Now, how can I remember that?
Okay, I see somebody here puzzled.
Okay, now let's do the simplest case.
Let's say that Y, so this is a function from Y to Z.
So now let's take Y to be unit, okay, or void.
So there's only one value.
And let take Z be booleans, true and false.
So how many functions are there from void to boolean?
Only two.
I can go from void to true and from void to false.
Okay, now how many functions are there from booleans to unit?
Well, there's only one that maps true to unit and false to unit.
Okay, those are mathematical functions.
Now you can say in Java, how many functions are there from bool to unit?
How many?
Because I can do print line, you know, of that boolean and that returns unit.
I can kind of, you know, send it with an HTTP request to whatever, get it back.
That's another function.
I can do reflection over the boolean.
So there's many functions.
And this is why in Java, a method, so I'm a little bit lying because a method,
you know, of bool to unit is not really a function because there can be side effects.
There's a lot of context that's hidden in Java that you can use as a programmer to kind
of cheat and don't show that, you know, that doesn't show up in the signature.
Now, if you're, I don't know if there's any kind of, you know, fundamentalist functional
programmers here, people that, crazy people that like Haskell and no Haskell programmers
here, there's one Haskell programmer.
Now he's smiling.
He says, yeah, look at that.
And Haskell, this is true.
No, then your crappy Java, right?
Because in Haskell, Haskell functions are really mathematical functions.
So everything is explicit.
But you know, that's why, you know, what is your name?
Oh, my goodness, even, even more complicated than Mr. generic.
Let me call you Mr. H. Mr. H there.
This code is like probably 10 times longer than the Java code.
By the time he's kind of done all his monads and whatever.
So, you know, again, maybe it's good to have him as a colleague, because then you can,
you know, you can learn from him and then write all this code implicitly.
And then he will say, oh, but I can do now my kind of monad transformer with the state
monad and the maybe monad and the list monad.
And by the time he has figured out how to compose all these monads, you're already here
at Foucafé listening to your next talk that you can put on your resume.
And you get ahead.
Isn't that great?
Okay.
Good.
Let's translate this into normal language.
Let L be a language that supports tuples, okay?
That's already a big step.
And let's assume that Java has tuples and let A and B types in the language, a function
A, arrow B, I'm just using normal notation now, can be defined as a factory method from
the functor.
Okay.
So, we're nearly there, but now I have to explain what a functor is because I've removed
all the Greek and I say there's a factory method for functions.
But in order to do that, I need to know what a functor is.
Now what is a functor?
And again, this is why most of us hate mathematics so much because I warned you that you often
go into the rabbit hole, okay?
And now we're going into the rabbit hole a little bit because when you look up functor
on Wikipedia, it's even more Greek.
Oh my goodness.
Ah, does it ever stop?
Well, let's look at it and it's not that bad.
Let C be a category, a functor, blah, blah, blah, blah, blah, blah, blah, blah, blah.
Okay.
Let's translate this into normal English.
And now we certainly understand it because since Java 6 and it was it, when did Java
get generics?
Was it Java 5?
Wow.
Look at that.
That's a long time ago.
The way they did it, yes.
So here a functor is a generic type that associates with each type A, a new type, C of A. So list
of T is a functor because I can instantiate it with another type, say int, sorry, integer
because generics in Java suck that you can only instantiate them with reference types
and not with base types.
But yes.
And then on that type, there must be a function map that goes from C of A to C of B. Now think
about this.
What does this thing do?
It says that if I go, if I can go, say from integers to string, because I have two string,
right, that goes from integers, from integers to string.
Now if I have a list of integers, I must be able to kind of, you know, do two string
on every element of that list.
And that's all what this thing is saying, that if I can go from int to string, then
I must go from list of int, oh sorry, list of int to list of string.
That is, that's quite reasonable, right?
And when we define generics, so again, here's a trick.
Whenever your colleague defines a generic type, probably they don't specify that this
should hold, that if you have, if you instantiate that generic type with one type, you instantiate
with another that you have to be able to go between them.
Well, they should have a map function.
Now the thing with this map function is that it should have some properties too.
Say that, you know, I'm going from list of int to list of int.
Well, how do I do that?
By doing the identity function, I'm doing nothing on each element.
So that should be delivered the same value, right?
That is kind of reasonable.
The other thing is that if I do a map and then another map, that must be the same as
doing the map with these functions combined, okay?
And this is like an optimization trick, because instead of taking a list of int, going into
a list of string, and then say taking the length of the string, so now getting a list
of int again, I don't have to build that intermediate list, because then I can just map this function
over that list.
So these category theorists also are efficiency freaks, because they say that this map must
have these properties so that they can optimize their code, okay?
So a functor is just a generic function that has a map operator.
Now, in normal Java generics, most functions, most types, most generic types, don't come
with a map.
Finally, in Java 8, when they introduce streams, streams have a map function.
You can go check now.
If you Google Java 8 streams, you will see there's a map function.
So finally, after like decades and decades, sorry, 20 years of Java and finally, you know,
they have map, whereas if they would have listened to the mathematicians, when they
designed generics, that should have been built in, because, you know, that gives you again,
that is this thing where, you know, a type doesn't come by itself, it comes with properties
that it should satisfy.
Okay, hey, great.
Now we know what a functor is.
Now the other thing, if there's category theorists here in the room, I have to be a little bit
careful, because what I said is a category was a programming language, and a functor
is really something that kind of goes between two categories.
So a functor can go between two programming languages.
For example, if you have a Java array and a small talk array, then one starts indexing
at zero, the other start indexing at one, and now say that I have a method on arrays
that sums up the values, when I go from Java to small talk, I have to adjust that sum function
to start kind of indexing at one.
Okay, that's another example of a functor.
But for today, we're only looking at endo functors.
Ah, doesn't that sound cool?
Endo functors, but an endo functor just means that it stays within one language, it doesn't
go between two languages.
Okay, good.
So this is the Greek decoded.
Now I've cheated a little bit already, because in here, you will see when I defined map,
I already used the fact that I have a function that I can pass into map.
But before Java 8, you couldn't do that, right?
Because there were no functional, there were no lambdas, so you could not even define map.
So we had to wait until Java 8 in order to have functions such that we can define map.
But we're not there yet, because we were trying to kind of come up with how do I represent
methods as first-class objects, how do I do lambdas?
Okay, and lambdas reminds me, Eric, yes, that's what exponentials are for.
Okay, let's go there.
Okay, here was the Greek.
Okay, blah, blah, blah, there's this object, there's a morphism, eval, blah, blah, blah.
Okay, now then this diagram has to commute, and there we see our lambdas, so we're getting
close.
So let's turn this into reality.
And of course, church, or this is Haskell B. Curry, will say, oh, but this is currying
in Haskell.
If you look here, you know, what this is doing here, this is called eval, blah, blah, blah.
It's just currying, and Mr. H has seen this already, and he thought, yeah, when did I
start doing Haskell in 1986, when did Haskell want to come out?
I already did currying, and all you Java guys can only do it in Java 8.
And most of you, oh, most of you were on Java 8.
This is very progressive, because I know a lot of companies that are still doing Java
6 most of the time.
Okay, now here's, you're not Danish, I'm going to go to insult you.
But here is Mr. C++, and he's a smart guy, because in 1979, somewhere, you know, you
can find that on the web, he explained that there are no instance methods, okay?
An instance method is just a static method that takes the dispointer as an additional
argument.
As I remembered it in the beginning, I said, we're only looking at morphisms as static
methods.
I'm going to ignore instance methods.
It's because Bjarne told me so.
Bjarne told me it's safe to ignore instance methods.
So an instance method is just a morphism from the tuple of the disk parameter and the other
parameter and returns a value.
Okay, so that's where the tuples come in.
And guess what?
Even C++ is lambdas these days.
Isn't this amazing?
Here I don't think there's any kind of programming languages out there anymore that we all use
that don't have lambdas.
But it took many, many decades, and why is that?
Because we didn't listen to the mathematicians.
All right, now it might be the case that in C++ that Bjarne says, you know, there are
no instance methods.
But let's check what Java has to say.
So if you want to have an even more boring document than the Java language specification,
you should read the Java virtual machine specification, okay?
But in the Java virtual machine specification, if you browse around a little bit and it says,
when you call a class method or an instance method here, local variable zero, they start
to count at zero, good boys, okay, is always passed to an object that represents the instance,
okay?
And the subsequent parameters are passed in subsequent local variables starting at one.
So also in Java, there are no instance methods.
It's just a static method where the first parameter with index zero is the disk, okay?
So we can simply forget about instance methods.
Now of course, there are a little bit things that I kind of put under the carpet.
There's no carpet here, but you know, imagine there was a carpet, it's things like inheritance
and so on.
So inheritance is an interesting thing because inheritance is quite useful, although some
crazy people say we shouldn't use inheritance, we should use composition.
If you have any colleagues that say that, make them look bad and have them fired because
they are making your life miserable because inheritance is a good thing.
But the thing with inheritance is that usually it's explained in terms of the implementation.
You start to talk about V tables and whatever.
And the reason is because inheritance is a dirty implementation trick to make it easier
to reuse code and to model inheritance mathematically is not easy and people write PhD thesis about
that.
William Cook, maybe you know him, wrote his PhD thesis about the semantics of inheritance.
So I'm not going to talk about that today, okay?
But let's continue decoding the Greek and now we are somewhere where we can understand
what's going on.
So to remind you, here's the category theory with the strange notation with the kind of
exponentials and there was this lambda, blah, blah, blah.
I didn't even bother to kind of go through that because you know, everybody would fall
asleep after a few hot dogs and hamburgers, but now we are something that we can understand.
So here, a function type here together with a method apply is a function, we call that
a function type.
If given any type A and a method M that takes an argument of type B and returns a C, defined
on A and remember that if I have a method that's defined on A, it's really that M has
type A as the first argument and B as the second argument, okay?
Now what we can do is there's a factory method that takes an A and that factory method looks
like colon, colon, M and it returns a function from B to C and that function object itself
has an apply method such that when I apply that to B, that is the same as calling M on
A and passing it B and then here I just cast to C so that you can show that it's the same,
okay?
Anybody here has used method reference in Java, if you use IntelliJ, it will tell you
all the time, right?
You write something and it says, I can refactor this into a method reference, do you use that?
Anybody here uses IntelliJ?
What is your name?
Paul?
Ah, finally a name I can pronounce, Paul, do you ever use refactor change into method
reference?
Yes, and do you recognize this kind of double colon crazy thing?
So you have been using exponential objects, did you realize that?
So now you can go to your boss and say in full cafe, I learned that I'm freaking using
exponential objects from category tier in my coding, I need a raise because that son
of a bitch next to me has no clue what they're doing, they're still using whatever virtual
methods but I know exponential objects, good, but it's amazing.
Function references, method references in Java are exactly the same as exponential objects
in category tier because the only thing I've done here is translate the Greek into Java
code, right?
So why did it take so long?
They could have sat down, done the same thing as I did, came up with this, said, hey, dude,
let's hire somebody to implement this in the compiler and we're done.
Okay, but I must say I find this pretty amazing because I'm 100% sure that the Java language
designers had no idea of category theory but yet they came up with exactly the same solution.
That is the amazing thing, okay?
So it must be some universal truth here because otherwise you would not two completely independent
people, one from theory, one from practice, come up with the same idea.
So if you look at here, if I have a method reference and I call the apply method on that
with argument of type B, that is the same as calling the method M on A, passing it B.
That is how method references work.
This is how category tier works, this is how exponential objects work.
I mean, this is a miracle.
I don't know about you, but when I discovered this, I don't know, I drank a whole bottle
of this stuff.
I don't know what this is, this is rum, I drank a neighbor, you know, that's kind of
the Dutch vodka, okay?
But this is great.
Now you can say, great, we now know that method references are exponential objects, okay?
So tomorrow when you go back to work, you're saying, let's do some kind of, let's introduce
some exponentials and IntelliJ can help us with that.
No, don't say that, you kind of use that.
But here's Eric Meyer and he has not mentioned the M word yet.
I have not mentioned monads yet.
So I'm going to do a little bit, yes, now I have, before as well.
When I was talking about Haskell, yes, that's true, but that was more like a joke.
Okay, now let's look at this thing.
So if you look at this exponential object, blah, blah, blah, there's a right adjoint
and there's home sets.
Now home sets have nothing to do with fish eggs.
I don't know, is that the same in Swedish, home in Dutch, that's kind of the eggs of
a fish, like caviar.
This has nothing to do with caviar, okay?
It just says that if I have a function from x to y to z, that is kind of isomorphic to
having a function that takes x and y and returns z, okay?
So this is really saying that you can curry and uncurry and go in two directions, okay?
And a home set, home A, B is just a fancy way of saying all morphisms from A to B,
okay?
So this is just a fancy thing.
And the method, the magic of method references is really what it's saying, right?
It's saying that, you know, there's an isomorphism between the lambda expression B arrow A, method
reference B and this method call here.
So there's nothing kind of really fancy about this.
And then, you know, we can kind of talk about adjoints because that was the other thing
in there.
For an adjoint, I have to have two functors and in our case, it's this.
And to really prove that I'm not talking nonsense, you know, here's some real code that actually
executes if you use Scala.
But now, here's the thing, that if you have two of these adjoint functors and these are
the conversions between them, that gives rise to a monad.
So we came from exponential objects, there came this notion of adjoint functors.
And once you have adjoint functors, you get monads.
So there's no escape from the monads.
So in the end, everybody will be like Mr. H, because, you know, now that Java 8 has
exponentials, the next thing it will have are monads.
Because that's what category theory predicts.
And I went through this real quick, but I tell you, 10 years from now, 20 years from
now, this will be the case.
Java will have monads, because monads are related to adjunctions and adjunctions come
from exponentials.
Now the funny thing is that the state monad comes from this adjunction there, but that's
a topic for a different talk.
So here's the next thing, when you have a lot of beer tonight, this will be your next
tattoo, okay?
So category theory here directly corresponds to Java.
And if this is a little bit too dark for you, what about this one?
This one looks cute, right?
And I made a special deal with Liz's tattoo parlor, where if you show your Foucaffé t-shirt,
you will get a discount on any of those two tattoos.
Thank you very much.
