Hi. I'm Max. You might remember me from such classics as the General Assembly Web Development
Immersive Program, their SQL boot camp. I'm a tech industry wanderer. I've done a little
bit of everything. I've been programming for countless millennia around 20 years, I think.
I have gone from writing code for Fortune 500s and independent game developers to more recently
education, classroom teaching, project management. I love them. It's not easy to use. I love them
anyway. The goals of this talk are not to hate on plugins or get people to stop using them.
The goals of this talk are to increase the understanding of them and to offer options,
because if you don't know something's out there, then how do you know if you should even look
into it? I firmly believe that understanding our tools is one of the most important and
kind of overlooked priorities for a lot of technology, not just development, but life in
general. Understanding the thing that you're working with, it does a lot. I think that especially
nowadays, with the emphasis on these fast boot camps that get you into the world in three months
or two weeks, it can be really easy to lose track of what it is you're actually trying to do and
figure out. I think that if you find a balance between, sure, get a plugin going, let it do
stuff for you, don't worry about it, and take a little while to dive in to your tool that you
already have, which is Vim and look around and figure out what's going on, that's where you
really get into powerful programming and incredibly fast and efficient work, and that's good for
everybody. Here's what we're going to go through. Just one more note before I dive in on how to
follow along. This is a terminal screen, which will remain on screen for hopefully the entire talk.
I'm using a little terminal window manager sort of thing called Tmux, and what you're seeing down
here, you can just think of this as like a tab list. If this one's dark, that means I'm on this tab,
if this one's dark, that means I'm in the tab where I've configured my Vim especially, and here's
where I have a vanilla Vim. I'm going to be switching back and forth a lot, and the reason I'll be,
I'm going to show how to configure Vim to do the stuff that plugins can do, what it looks like
when you haven't done that, and what it looks like once you have configured it.
And I have also built these slides out of a VMRC file. I've never presented this way before,
but it seemed kind of cool. So if we're lucky, it'll completely fall apart, and you'll get to see me
wing it. Okay. Yes, good looking out. So first, I'm going to be talking about fuzzy file search.
This is a really cool one that requires very little configuration and lets you go really,
really fast. There are several plugins for this like command T, command P, fuzzy find.
They all do pretty similar stuff, but you can get a surprising amount of mileage out of just Vim.
After that, I'll do tag jumping. Tags, if you're not familiar with the concept,
is like anything that's important to your programming language. So if you make a class
called abstract, then abstract is a tag. And if you use it someplace else,
you might want to be able to jump to it really quickly without having to dive down and figure
out exactly what file it's in. There are plugins for this too. I forget all of their names,
but Vim can do it out of the box. Almost. Next, autocomplete, everyone's favorites.
There's plenty of options for autocomplete in Vim. Many of these situations, I actually have come to
use plugins instead. Let's see. For file browsing, even I use a nerd tree now and I don't use a lot
of plugins, but autocomplete is one of those things where I see a ton of plugins for. And it
just surprises me because Vim can do so much just by itself. So that'll be a really fun one.
After that, I will do file browsing with Vim's cantankerous but functional built-in file browser
called NetRW. We'll go into snippets, which will be a pretty quick one. And finally, if we have
some time, I'll talk about build integration, which is when you want to run your tests and get
immediate output or be able to jump between all the errors that happen, Vim can do that too. It's
quite cool. Okay. So before I get started, does anyone have any questions about anything on the
list? Anything super surprising to you? Cool. I always like to check. So this is again in the
form of a VimRC file. In practice, you can go to the GitHub repo and just copy paste the lines
that you're interested in to yours. These are the only global configuration changes necessary to
make this stuff work. No compatible. Just tells Vim to not bother pretending to be its predecessor
Vi V. I don't know how you're supposed to pronounce the one without the N. But Vi's super old and
by default Vim tries to act like it because it assumes that you've been doing this for 50 years
and you fear change. Sorry if I just offended anybody. Sorry, not sorry. So after that,
just syntax enabled to allow some nice colors on the screen for us. And finally,
file type plugin on, kind of cheating a little bit. The feature that's built into Vim that uses
for file browsing, technically, it's a plugin, but it comes with Vim. So I kind of don't think
of it as one. You could probably have a really long debate on that, but I'm not going to do that.
So first, let's talk about finding files.
Now, the interesting thing about this is
there is no Vim feature that's called like fuzzy file finder. It's kind of just this accident of
various other features that it has bumping into each other in just the right ways
that you can do all the things that I'm about to do. And it all starts with this one humble option.
If you're not familiar with Vim configuration syntax or Vim in general, I'm just going to do a
really quick like one sentence pitch on it. Set is a command that changes a built in configuration
variable such as path. And plus equals means append it to the existing value of path because
there's a default. And two stars means something very important. Now, one of the things I'm going
to be doing occasionally in this talk is jumping to the Vim help system, which is actually one of the
most complex, but really thorough and nicely built help systems that I think exists. You can
read pretty much anything by you can figure out pretty much anything by reading through these.
A lot of the stuff that I'm going to show today are things that I found just by stumbling on them
in the documentation. I mean, it's kind of a shame that you have to read the documentation for fun
to figure some of this stuff out. But hey, that's why I'm giving the talk. So this is a list of
directories which will be searched when using any of these commands. So these are all file related
commands. And down deep in the depths of this documentation, they actually explain what star
star does. But I'm having trouble remembering where it is. So I'm just going to tell you what it does.
Star star tells it to when you look for a file, search through every sub directory and search
through every sub directory of every sub directory. And so this is what my folder structure looks like
right now. So this is a project that I have had in the back burner for a while. Let's say a little
a text based game, the server side. And I have this deeply nested file here like tcp.rb.
And I'm going to be running Vim in this folder. There are a lot of tips and tricks and tweaks
that suggest adding something to your configuration so that your current folder follows whichever
file you're looking at. Like if you're looking at tcp.rb, then Vim's folder gets switched here.
But I never do that. Because if you leave your Vim's active directory at the root of your project,
then it can do these special recursive searches, such as with the star star on your path, and it
can reach into all different files and folders that you have. So I'm going to show you what that
looks like. First, if I go to my vanilla Vim instance, and I try to find that file, say find tcp.rb.
Oh, I guess I loaded in the real one. Sorry. There we go.
Oh, that's not how you do it anymore. Okay, screw the vanilla one.
So you'll have to trust that that doesn't work if you don't set the path.
But I'm going to do a little sanity check and make sure that the variable looks the way I expect.
So we can see here are all the defaults. Mysteriously, someone added nothing a couple
times. But here's the two asterisks that I put in. Ah, software. So here's the thing. Not only can I
find tcp.rb, can I please just like get it to do the thing? There we go. Find tcp.rb. So I just
jumped immediately to that file, even though it was not in my current working directory.
What's great about this as well is if I say find tcp and tab, it will complete that for me.
So once again, that's tcp tab. It found it way down in the folder structure.
You can also use basic pattern recognition like star cp. I think this should work. There you go.
So if you want to make it fuzzy, you just put a star. You can put at the beginning or the end,
and you're good to go. So hopefully this is a nice start to sort of the big splash of using
Vim without plugins. This does, I'm not crazy, right? This is like most of what a lot of fuzzy
finders do, right? Okay. I think it's really cool that Vim can just do that. It's sort of a shame
that it's, I mean, I don't understand really why it's not default behavior, because that's really
useful, but who knows? The other thing I changed was this thing called wild menu. And basically,
when you look for a file and it has several, there's several different things that could match.
Like let's say I just want to look for all the RB files. So I'm going to say find star.rb.
Now when I hit tab, it's actually going to put all of the possible RB files it can find.
And I can just sort through them with shift tab and tab. And I can just pick the one that I want.
So you can configure this wild menu thing a number of different ways, but just by activating it by
default, you get that neat little menu thing here. And that gives you just pretty much like a biggest
bang for your buck, I think, in terms of fuzzy file finding compared to those plugins.
One other thing to consider, if you already have a file open, and that means essentially
in Vim, if you've ever opened the file, you can type this command ls and it will give you a list of
what Vim calls buffers, which are basically just files it's holding in memory that you may or may
not be currently looking at. So if I open up another file, for example, what's a good file?
I'll open up world.rb. That sounds pretty interesting. So I have these two files open now,
and if I type ls, here they both are. The important thing about this is that if you
already have a file open like this, you can jump to it just by typing colon b space and typing in
a unique subset of its file name. So I can just say btcp. I don't have to hit tab. I don't have to
do anything. But if you give the b command a what's the what's the programary term a substring
that is unique to one of the files you have opened, it will just jump to it right away.
And if it's not unique, it'll tell you more than one match. And in that case, you can just do the
tab complete thing and it will scroll through suggestions for you. So between find and the
buffer command, b is short for buffer, you can do a whole lot with navigation without really needing
any other dependencies. And that's super cool. Any questions about this one? Yeah?
So the question was, is there a way to ignore certain files or file types?
That's a great question. Off the top of my head, I don't know. I bet that somewhere in the bowels
of the find man page, it might explain. Good question, though. Any others before I move on?
Yep. And then you? Is the tab always showing you a full recursive search or is it so that when
you tap through that? I'm not sure what you're asking just yet. To open the file, opening the
file is all the recursive if you give the star star? Yes. So the question was, is the find always
recursive and the star star is in the actual path variable. So like, I don't have to type it in again
ever. The only time I might type an asterisk is going to be if I want to find some file that I
have open or some file that I haven't opened yet, based on part of its name. So like, if I wanted
to open up a spec, then I might say star spec. But this asterisk and these two asterisks are
doing very different things. This one is very specific to like this one search that I'm running
right now. I'm saying find any file that ends with spec and hitting tab there, that'll scroll
through. And this search is always recursive because of those two asterisks. Yeah. So the path
command configures how all the file-based commands work. There is, but you'd have to probably mess
with the path variable, or you would have to specifically type it into your search. So I might
say find, let's see, what folder was that in? I might say find lib tella star.rb. And so now
I've explicitly told this search to say only show me things in that folder. Does that answer your
question? Yes. Awesome. And I think there was one more. Possibly. Yeah, partially addressed, but just to
start, you're only going too deep. Too many folders deep? Yeah. Yeah. If you do have a
ton of folders, then you might find a slowdown. But I think you'd probably have to have quite a
few because I've used this on some pretty hairy projects and it's only the like 20-year-olds,
20 million line code base situations where it actually starts to chug. So it's pretty
impressively fast in my experience. Is that what you were thinking about? Yeah. Okay. I think I saw
some other questions possibly, but I do want to keep moving along. If we have time at the end,
I'll be happy to cover some more, though. Okay. Oh, that's not where I have my slides.
So next up is tag jumping. This one requires an extra tool called c-tags.
So once again, a tag is any interesting word or a collection of alpha numerics that you might want
to navigate to or find quickly. If I'm moving through my code base like this, and let's see,
what's a good tag that I defined myself?
Oh, this is all deep stuff that has no dependency that I made. All right, here we go.
So let's say I'm looking through my code base and I see this thing called exit,
and I want to know what that is. Where is it defined? What does it do? What's the source code?
If you are unable to jump and navigate by tags, then there isn't really an easy way of doing this,
besides like changing over to your terminal and grepping for it or using some kind of IDE feature.
The tool that I'm going to be using is called c-tags. It, I think, exists by default on every
modern GNU Linux system. You have to brew install it or find it some other way on OSX.
If anyone is unfamiliar with brew or home brew, just let me know afterwards and I'll help you get
set up. The exclamation point causes this to run as a shell command. So I'm asking Vim, when I type
in make tags, just pretend I type this into the console. So for the sake of simplicity, I'm going
to type it into the console myself. So c-tags dash capital R, which means recursive. This is
effectively the c-tags version of that star star. It just means drill down into all possible folders
and dot. And in classic Unixy style, no news means good news. If I look at LS now, I have a
file that was not there before called tags. And it is a super fugly confusing list of
stuff that it found. But here's what it lets you do. Now that there's a file called tags in the
current directory, Vim is configured to automatically look at that specific file name. At least I think
that's the default. Okay, so this is its list of places to look for tags. Basically, it wants to
be able to track down your source code or any reference that you use anywhere. But the one
that we're interested in now is dot tags, because that's for the current code base. And what I'm
going to do now is hit control right square bracket. And it jumped immediately. You know, I used to have
a thing. Well, that's right. I emptied out the rc file, so now it's not displaying the name of the
file at the bottom. That kind of sucks. Let's cheat and I think this is how you get the current
file name. Yes, I can't believe I got that in the first try. I'm so happy. I always have to look
up what expands does. So now we're in world.rb. Where were we a second ago? I don't know. Okay,
so we didn't jump to a different file, not that exciting, but it did automatically bring us to
the definition of that tag. And you I'm sure can trust that it would do that if I, you know,
type that on something a different file. The other interesting thing is
if you have an ambiguous tag, a tag that's defined in more than one place,
Vim still has your back, you can prepend that command with G. G is like the weird filler
prefix. All the commands that do something slightly different
have a G in front of them. It's really weird. But if I say, so if I do a control right bracket,
it brings me to this exact line. You can see my cursor jump. And it's kind of saying, okay,
if you want to find initialize, it's right there. But if I prepend that key press with G,
I get a list of every instance of initialize being defined in my entire code base,
which is super cool. Yes. Yeah. And you can configure this to look just at the code base
I'm using now across my entire computer. If you're truly devoted, I haven't stayed up late
enough to do this yet, but you could conceivably configure it to know exactly which version of
Ruby you're using and which bundle you're using and how to look at exactly the docs for the gem
that you want. Man, that'd be cool. Someone please write a plugin for that. So yeah, in this case,
I could just pick one of the numbers and say, oh, this one's in. They're all in the world.
My code base is very boring. There we go. I want to jump to the TCP server so I can just say seven.
Can I just say seven? There we go. Type number. And now I'm at the initialize method way over
in my TCP file. So super cool. Not a lot of configuration required. Chances are C tags will
be a little ornery depending on how your system is set up. I think that sometime in the distant past,
I set some kind of RC file that made it easy to run and just use that one flag, but hopefully
it'll work out of the box for you too. It's a pretty neat program. And Vim just knows how to
read those files. So you can do quite a lot. The only other thing to cover on this is that you
can actually jump back through the tags. So if you go on a, if you go on a hunt, if you're drilling
down layer by layer and trying to figure out exactly what's going on. So let me give you an
example here. So tell it at RB. If I say, okay, I guess I want to start with this world file,
and then I'm going to go down and I'm learning about the code base. And, you know, I don't know
what exit is. So I'm going to go check that out. And then I don't know what a destination is. So
I'm going to see if that was defined anywhere. Okay, it wasn't. But if you do this, you can
actually hit control T. And every time you press it, it will jump back by one more tag. And it
looks like it discarded my first jump, which is unfortunate at bottom of tag step. But if you
have any experience at all with like big, big code bases that have like millions of dependencies
deep, the control T features are really nice one, because you can start someplace, drill down and
figure out what code is doing the thing that you want to understand, and then just hammer on control
T until you get back to where you started. Very, very convenient. Okay, any questions about this one?
Yeah? That's a great question. I don't have to top my head. I bet it does by now. I bet someone's
written some like C tags, CSS plugin. That one actually might be easy to figure out. I think you
can just say, C tags list languages. So it's in there somewhere. I bet someone out there has done
it, though. If they haven't, someone probably should. That sounds really convenient. Any other
questions about? What are we on tag jumping? I have a very unscientific method for that,
which is, I just leave it until I try to jump to a tag, and it goes someplace I didn't expect,
and I go back and rebuild the tags, which actually isn't so bad because it will see tags actually
knows how to progressively update a file, and it will go through and remove non existent tags and
add new ones without you having to mess around with it. So that's actually a surprisingly doable
approach. The other way I've seen is to just bind it to your right command. So every time you save a
file, it just updates the tags and then saves the file. But that, I don't know. For some reason,
I've just never felt good about that one. Just my spidey sense tingling. I have no idea if it's
actually onto something. Good question, though. Other questions before we move on? Cool. All
right, let's see. Where are we in our sequence here? Okay, so let's do autocomplete, and then we
can take a break for pizza and hanging out, and then we'll finish out the rest of the night,
if that sounds good to everybody. Whoops. I disrupted the delicate balance of movement
commands and scroll control. Pay no attention to the margin behind the curtain.
Okay, so autocomplete, this is another one with possibly over 600
scrillion plugins devoted to it. Some of them are very, very cool. The key commands for some of
these things are a little weird, but you can also get a lot of functionality out of it.
So autocomplete at this point is already configured. It automatically reads from your tags
file if one exists, and even if it doesn't, it will automatically check out the file that you're in,
and it has some language-specific configuration that allows it to follow dependency chains. So
when Vim is looking at a Ruby file, someone actually sat down and wrote code so that it
reads the requires at the top, and it'll try and find those files. So the autocomplete functionality
in Vim without any special configuration at all is already pretty nice, and it's extremely configurable
if you decide to start using it that way. Very simplest by default is just ctrl-n.
So if I'm typing something here and I want to do something with the contents variable,
I can say at con and hit ctrl-n, and it's going to automatically look through, and so here are all
the things that are happening inside this file. If it finds something outside the file, tell me
which file it comes from. This menu, I think this is pretty close to what it looks like out of the
box. You might have to tweak it to make the font a little more legible, something like that, but
this menu is something that you can pretty much just start using right away, and the only hot key
you need to use that is just ctrl-n, and to go backwards you can use ctrl-p. So this one is very
convenient. Ctrl-p is previous in the list, so ctrl-n and ctrl-p to go back.
Oh yeah. Oh cool, yeah. Oh wait, that's really interesting. It reverses the order. That's neat.
I like that, TIL. So there are a couple of other ways to autocomplete. All of the default bindings
begin with ctrl-x. I have no idea why, but some of them are pretty cool. You can restrict it to
this specific file only by using ctrl-x, ctrl-n. So if I say con, ctrl-x, ctrl-n, now you can see
I only have those three options from this file, and if you look at the help for this, there is a
smorgasbord of different ways you can mess with this stuff. You can complete keywords in the
current file, the dictionary, the source, keywords in the current included files, tags, filings,
anything you could possibly want. I don't remember even half of these. The coolest ones I think are
these four, ctrl-n, which is the default. It just sucks in everything according to the complete
option, which is very nice and configurable, and you should totally take a look and tweak it.
The other one being ctrl-n for just this file, and two of the other very specific ones are
file names, which is a total lifesaver sometimes. So I can say lib, tele, ctrl-x, ctrl-f. Now I can
just insert the name of the file from that folder. All I had to do was type the folder, because remember,
I know Vim is in my project root. So Vim is here. So if I say lib slash tele, then Vim knows it's
supposed to look inside that folder. So this is a very straightforward way of working with files.
This has saved me so much time and command tabbing and copy pasting, and how do I get the stupid
file name, because Vim has its own little file finder right in the insert mode. Very, very cool.
Could you put in an absolute path? I bet, yeah. I don't think I've actually tried that one, but
let's just do a slash and see what happens. There you go. Yeah, so you could do this,
right, and you can just keep saying ctrl-x, ctrl-f until you find something. So yeah, wow.
Oh, so there's probably a better way of doing this, but the way that I end up doing it all the time
is lib ctrl-x, ctrl-f, and then when I find the one I want, I just hit ctrl-x, ctrl-f again.
Yeah, I have to imagine there's a better way of doing that, but I've just never had the like
five minutes where I was like, I feel like looking up that particular piece of information right now.
So yeah, that one's awesome. And finally, of course, there's a tag only completion. So I can
start with ctrl-r and say ctrl-x, ctrl-right bracket, which is the same thing that you hit
to jump to tags. So that's actually kind of a mercifully consistent interface. But that'll
complete room there. I can say c-o, and if I say ctrl-x, ctrl-right bracket, it's only going to
complete to connect because that's the only tag in the entire code base that it found that started
with those letters. So very configurable and handy completion options in VIM. This is another one
where there are so many plugins and I'm just like, I can't figure out what it does that VIM can't do.
But the price is kind of high. I had to read a lot of documentation to figure this stuff out.
Hopefully, this is making it a bit easier and accessible for everyone here,
because it's a shame to miss out on a feature like that. Okay, before we jump into our mid-talk
break, does anyone have questions about autocompletion or lingering questions about previous topics?
Just to admit that you said that autocompletion would actually be like a fire state in the ruby.
Does it also work with quality cell rubies in the room, but with like node, with like import?
It totally depends on how much monster energy drink the node guys have had recently. Yeah,
like if someone happens to have made that work in the past, yeah. I don't do enough
node to know off the top of my head, but like I bet by now it probably does. Or there's like
someone's random GitHub repo where it'll probably make it work, you know. Yeah. All right, other
questions? Yeah? You know, I think the only way that I know how to do that is to just keep
hammering until you get back to the original. Escape? Does escape work? No, wait, yes. Okay,
escape does work. But it took you out of insert, did it? Yeah, it did. Well, it's a pricey edit.
Yeah, it sucks. Wait, can I do control C maybe? I think it gives you time. That always gives me
every time I like... Yeah, that's a... Yeah, so yeah, here's the extra credit bonus for the day.
If someone can find in the docs how to get out of it without exiting insert mode. Yeah, that's
surprising that that's not more widely known. I'm surprised I didn't know that actually. That's
a great question. If you'd enter, it just goes to the next line, I think. Control P and you go back
to the left option. Well, it selects it and then puts an enter in. Can you type in after I find
something? Yeah. Oh, then actually, that does get you out of it. But you can't bail on it entirely
because it'll just leave you with whatever you had. So if I just hit space here, which is nice
when you want that one. All right, good question. I think there was one there. Yeah?
Does find support regular expressions? I don't know off the top of my head. I know that it
supports the... What's that weird term? The bash globbing with the asterisks? That's what that's
called, right? Globbing with the... Yeah, okay. I don't know if it does regXs though. There is a
way to plug Vim's file find into the Unix find and grep commands, which is beyond the scope of this
because I haven't done it recently, but I don't know if find does it out of the box. Good question,
though. Anyone else? Cool. Let's take a short, I don't know, 15, 20 minute break and then we'll
dive back into it. That's so cool. I'm just, I just love that. Look at that. That's awesome.
Okay. So, sorry, we just had to take a minute and find a new toy to play with.
Look how cool that is. That's great. I'm gonna do that. I'm gonna try to do that instead of
gesturing. I find it much less gratifying than gesturing, but it's probably easier for anyone
who watches the video. So, if anyone's curious, that is the command forward slash find the cursor
feature on iterm. I often lose mine. Welcome back everyone. I hope the pizza is sitting well for
you. I enjoyed mine. Let's dive right back in to file browsing. So, this one's kind of cheating
because technically NetRW, which is the file browser that I'm going to use, is a plugin,
but it comes with Vim by default. So, I'm just going to pretend that I'm not telling you how to
do things that other plugins do with this plugin. So, the thing is NetRW is,
it's effectively built in, right? Like you get it for free. That's kind of the point.
It's not super configurable. It's not super intuitive, but you get it for free, and that's great.
So, these are some, excuse me, these are some options that I have personally ended up using
over time. They're not necessary for using NetRW, except for this one, which hides the
horrendous banner that takes up half the screen. Once you have done this, though, you can simply
say edit and provide the name of a folder. So, I'm going to say edit dot, and now I have a file
browser, and I can expand and contract folders. It even has some nifty stuff, like different colors
for folders and executable files. You can do all kinds of crazy stuff in here, and I actually
have not explored many of the features of NetRW. You can do things like attach to a remote file
system through SSH. You can mark files the same way you would by, like, control clicking
in Finder, but I'm not going to show you to do either of those things, because I have no idea
how to do it. I just know that you can. All I really do is just use it to browse through
file hierarchies visually, and you can open up things in a visual split. You can open things,
that's with V. You can open things in a tab with T. It does all the basic things you would
generally expect a file browser to do. You just don't have to configure it that much or
install anything to do it, which is very, very nice. I'm not even sure if I had other detailed
notes on this, because it's kind of straightforward once you know that it's there. Yes, so you can
look at the help file NetRW Browse Maps, and that will show you a list of all the different things
that are mapped by default. As you can see, it's kind of a lot. You can do things like
moving around. You can navigate up a directory. You can hide specific things. You can create
directories. It's actually pretty full-featured. This is the one where I have never, ever blamed
someone for using a plugin to do this kind of thing, because NetRW is cool. It does a lot of
these things, but I have just never really figured out how you're supposed to remember the
commands and how they fit together. I recommend playing with this just in case your file navigation
needs are simple, and you just don't need another plugin anymore. Be aware that if this is just too
ridiculous where it's just like, look at all the things it does, how do you do them in a sane,
efficient way? I don't know. I'll figure it out. There's value in good documentation, and most of
them has it. NetRW doesn't as much. Sorry if the NetRW documenter ever watches this video.
Don't mean to throw any shade. Please write better documentation.
That's my second sorry, not sorry of the talk. This is pretty cool. I'm not going to spend too
much time messing with it, because there's just so much else to talk about. Let's face it, once
you've seen a file browser, you've kind of seen all of them, except that 3D1 from Jurassic Park.
That was cool. Any questions about this one? All right. Thank God. I'm not sure if I,
that looks like I have the right size. Yeah, cool. Okay. This next one's also somewhat straightforward.
This requires no outside tools whatsoever. Let's say I want to make an empty HTML document.
I'm going to show you how this one works before I explain why it works. Let's close all this
nonsense here. Now, suppose I'm going to add a template to this file and say
some template equals stabby thing HTML. HTML will end here. Now, I want an empty HTML template in
here. What's the developer to do? Standard solutions would be plug-in managers or snippet
managers. I might write it by hand, which I did for about five years until I just couldn't take it
anymore. You could copy paste from something. What I do is this. I say comma. Can I do that
thing where it shows the command I'm typing? Show command? Yes. You can see what I'm typing
down there. I know it's kind of fast and not super useful, but it's better than nothing.
I'm going to say comma HTML. On the L, it's going to just blast this basic HTML template in there,
and it's actually going to position my cursor in the title fields, too. Super convenient.
How did I do this? It is a total mess, but it works really well. Let's look at this-a-here
Vim command. Just a moment ago, I was telling you, don't necessarily bother with an RW. It's
really big and complex and hard to figure out. This is also complex, apparently far more than it
needs to be, probably, but I actually do recommend figuring this part out and using this because
this is so much easier and straightforward compared to snippet managers once you know
what the hell is going on. That's why I'm going to take a moment to explain this as carefully and
kindly as I can, both for you and me, because I wrote this and I'm not exactly proud of it,
but I also kind of am. Let's look at what it does. This part here is just the basic mapping.
The no-remap part is telling Vim, don't let any of these commands invoke themselves. If I use,
if I map something that's like J, using no-remap will make sure that it doesn't clobber or
re-envoke the original use of J. It's pretty much just used for paranoia here. I very much
doubt there's ever going to be a built-in feature that is called comma HTML. Comma HTML, comma is
really an arbitrary character that I picked to prefix this weird normal mode command. By the way,
that's what the N at the very beginning of this means. Ooh, single character highlight. That N
stands for normal, because this is a mapping which will apply only in normal mode. What this means
is when I type comma HTML, some people use backslash. This is often referred to as a leader
character. After this comes the effect of the mapping. Just as a small foundation explanation,
if you haven't written your own mapping before, if you've ever seen this kind of thing, you can
change any key in Vim to do anything you want. It's wonderful. It's horrible. You never know
if you sit down on someone else's Vim what's going to happen when you hit any key. Any key could do
literally anything. Yeah, if that doesn't just fill your heart with a thrill and terror, then don't
use Vim. What this is doing here is this is saying remap. Map is just the term for
this thing should be connected to this thing. This series of keystrokes should result in this
being automatically typed. What this means is when I type comma HTML, it will be as if I was
sitting at the keyboard myself and typing this long string of nonsense in. What does this mean?
Well, it is a invocation of the read command. The read command does thankfully what it sounds
like. It just reads from a file into the current Vim buffer. I'm going to really slowly show that
in action because it's important to understand the difference between the read command and how
we usually use Vim. What I'm going to do is go to my Vim window here and let's see. I want to look
at a list of current files. I just want to read from some file to prove this works. Let's read
from the tags file. I'm literally just going to say colon read tags. I'm going to tab complete.
I always do this just out of paranoia in case I'm typoing something or there's not a file where
I expected it to be. When I do this, it's just going to take the contents of the tag file and
blast it into the middle of this file. Read is a very straightforward but powerful command.
It just means take whatever I put on the side of this and yank it into the file that I'm working
with right now. The negative one changes the line by one. If I didn't have that, the cursor would
move when I enter the snippet. Notice I'm on this line here and when I say comma HTML,
there are no extra lines added except this one at the very bottom which I think is actually
part of the template for some reason. That's just a little tiny tweak. This is the important part.
In my home directory, I have a vim folder of course and inside there, I have this file called
.skeleton.html. I'm going to use the gf command which opens a file into the cursor to jump to that.
This is it. This is the exact contents that I just pulled in by typing the snippet. We're looking at
three different files now. I have my skeleton.html file which is deep within my .files.
We're looking at the actual vim configuration file. This is what you would put into your actual
vim rc. We're looking at the file that I have been working with where I can now say comma
HTML and pull the thing in there. The gibberish at the end, excuse me, the complex and carefully
designed string of characters. Here's the thing to know about vim mappings. I'm going to do my
absolute best to explain why this works because if I can explain it right and if you can carry with
you, you can just have superpowers in vim because this is so cool. If you can get it to work. When
I put this colon in the mapping, what I'm doing is I'm essentially telling it to change modes.
This is a normal mode mapping. In normal mode, if I hit control F, I'm going to go back and forth.
If I hit I, I'm going to enter insert mode. When I hit colon, I've actually changed modes. I'm no
longer in normal mode. I'm in command mode. Vim keeps really careful track of this because the
keys have to do something different. In command mode, if I type I, I don't want to enter insert
mode, which is what would happen if I was in normal mode. I want to type an I. The colon is
actually like enter command mode. That's what that means. The cr here, this is the special vim
specific key code for the enter key, also known as return. The cr is short for, I think, carriage
return, which believe it or not is a holdover from typewriters. I'm pretty sure. Yes, it is.
Yeah. As well as the QWERTY layout itself. Ah, technology. It moves so fast sometimes.
But so what the cr in this mapping will do is it literally will type. In fact, here's, I'm just
going to do this. I'm going to remove this for a moment. And I'm going to reload my vim.
So I'm going to run that again. But remember, what I did here is I took away everything from
the end of the HTML file and beyond. So I took away the cr. So now when I type comma HTML,
look what happens. It just leaves it there as if I had typed it into command mode.
So what that means is the cr is the mapping way of doing this, which is pretty neat.
Once you hit enter in command mode, you're back in normal mode, which means I can type normal mode
commands into the mapping again. What does 3JWF write bracket A do? Well, let's do it ourselves.
3J. What the hell was the next thing? WF open bracket A. It positions the cursor exactly
in the middle of the title brackets, just for convenience, you know. So clearly, you don't
have to do that part if you're making your own snippets. This is really the important part here.
Being able to just type in something short and instantly get the contents of a file back
into whatever you're working with. And this is really nice because you can just have an
entire folder of snippets and what are they? They're plain text files. You can refer to them by name.
You could also modify something like this to figure out what the file name and directory is
based on the name. I might even do that when I get home because I just thought of that now. Why
don't I do that yet? So the interface of a snippet manager, I think, is probably the most important
part, which is why, again, I'm not saying replace your snippet manager with this. But just knowing
that this is out there is probably a nice way to keep in mind all the different things you can do
if the snippet manager that you are using or that you're thinking about using just doesn't do one
thing that you were hoping for. This is a very, right, it's like one line of code. You create the
file separately. You keep track of them however you want. And you essentially can just have a folder
of snippets that are usable whenever. And I think that's pretty rad. Also, hopefully, this was a
useful overview of how to do some cool mapping stuff. I have never, I think, written a mapping
correctly on the first try. I think maybe it's hard-coded where just every mapping will fail the
first time you write it. I can't figure it out. I always have to do trial and error. So don't feel
bad if this doesn't make sense or if you sit down and try this and it doesn't work because
that's, it'd be weird if it worked on the first try for you. That's what I'm trying to say.
These things are, this part, I think, is a real premature optimization in a sense. But this stuff
is cool. If you can figure out the whole colon goes into command mode, CR sends the command
automatically, then you're rolling and you can pretty much automate whatever you'd like. So this
is a very nice thing to have in your pocket, as you can see. Now, you can take over the world
with much fewer keystrokes because that's always super important. Yes?
Yeah, probably. Yeah. Yeah, so that, if anyone didn't hear that question,
it was just, could I just have done a forward slash search? Probably.
For some reason, I just like using the word commands. I don't know. They feel really cool to
me. It's like five words. That's awesome. How can a computer know what a word is? That's great.
I don't know. It blows my mind, sometimes, usually. Oh, I guess, were there any questions
about this first? Yeah? A lot of the snippet managers, they do, I guess, they're kind of
how common it should be. Like, say, I type D in Ruby, I type D, yeah. And, you know,
I hit like control K, then it gives me a template for a method definition.
Yes? Can you leverage this to accomplish that?
So, great question. So, that question was, certain snippet managers or even just editors
will set you up to type in an entire method, as soon as you say DEF, and the answer is absolutely yes.
There is actually, I think it's called abbreviations, possibly, is the name of the feature,
where it can pay attention to the stuff you're typing in insert mode, and when it sees you type
a certain pattern, then it can run a command. So, I think it's like you can do exactly that,
it's just that it's VIM, so it doesn't do all that out of the box, you have to, you know,
open up your VMRC and figure out, you know, exactly what it looks like and how you want it to work,
unless you get lucky and someone else happens to have it in theirs. I think, actually, in my VMRC
is something like that for Python, where it takes essentially all of the names of the variables that
you pass into the initializer and turns them into the like, at manager equals manager, at this equals
whatever, because I hate typing those things out. No, because it's just my little janky VMRC script.
But, you know, I have affection for it as a result, so good question. Any other questions
on snippets, if you can call these that? Can I do? Awesome. Okay, so this last one is probably
one of the more interesting ones. It's, I think that the build integration plugins today
are very strong and you should use them instead of this, because the support for this ebbs and
flows, I think, with like the time of day recently. But I'm going to show it to you anyway, because
it's really cool and I am selfishly hoping that someone will sit down and reteach Vim how to work
with this stuff, or actually, in this case, reteach RSpec how to output in a VIM readable format. It
used to be able to do that and it doesn't anymore, I guess, because same as all the rest of this
stuff. People just kind of forget that VIM does that. So what I'm going to do here is a three-step
process, because I have this window running here where I can say bundle exec RSpec, and when I do
that, I'm going to have my documentation style output in this particular carefully curated
series of tests. I have two that are currently failing, but VIM can't read this. We need to add
something that will allow them to do that. And through some careful googling, I stumbled on a
blog post from one Philip Bradley who has a simple Ruby class called Quick Fix Formatter,
which you can pass to RSpec, and it will change the way that RSpec outputs errors. So when I run RSpec,
I can say format documentation, which is what gives us the stuff we just saw. I can do the classic
progress, which shows you the dots, which have been scrolled off, I think. Yeah, so you can do the
dot approach. Or I can pass it this special Quick Fix Formatter. And the exact way that I plugged
this into RSpec is that I literally just copy pasted it from that guy's blog post into my
spechelper.rb. I think the ethical way of doing this would be to give it its own file and include
that, but whatever. I just wanted to get it done. I don't have time to make things work better. I
got work to do. So if I do this, it just outputs the errors. And it uses this sort of three-part
format where it's like, here's the file, and here is the line number on which the error happened,
and here's the actual error message itself. This is the classic Vim Quick Fix Format, which came
from, I think, the way that the original C compiler allowed output for some of its own error messages.
The thing is, when I do this, if I have it set up this way, I can mess with this weird
secret option. It's not really secret, but I've never seen it used anywhere, called Make Perg,
which I am hoping is short for Make Program. And I can do this strangely necessary backslash
escape thing on the spaces. Don't ask me why it needs that on this one option. I have no idea.
But I can essentially just give it the same command that I was just typing into
my command line window. And now, when I run Vim's built-in Make Command, let's do this here.
Let's pretend I'm actually editing some real code so I can say find TCP. There we go. So if I say
Make now, I can see the output from that command. But when I get back into Vim, I have this line
here that says one of two, because what Vim did is it read that output and it detected that there
were two lines and that it was in valid quick fix format. And it figured out that these are the
two messages. So here is that actual text message, which describes the error. And it will just bring
me directly to where it exploded. And I can actually use the commands CN and CP for next and previous
to navigate through all of my test failures. I can even say CL for a list.
And the final command that I always use for this is CC, which lets you jump to a specific one,
kind of useless since we only have two, but I can type CC2 and it will jump directly to that error.
So this is another one of those things where the plugins will do such an awesome job. They'll open
up your tests in a separate window and allow you to view them side by side and all the nice bells
and whistles. But if you just want to get some basic functionality like this, this is all you need.
Plug this one weird thing into your RSpec, plug this one weird thing into Vim,
and suddenly it can understand your test output, which is very handy. This kind of thing has
absolutely saved me tons of time, because honestly, like, I have a short attention span. When I run
something like this, the, like, six months that it takes me to be like, what line is this even the
right, like, is it that, I don't, 17? Does that mean there's 17 errors? I have no, like, it's too
much for me. I'm lazy and I have ADHD and just, I want to just be able to say, you know, next one,
show me the next error, jump right to it. This is super cool. And if this looks like the kind of
thing that will help you out, then I certainly hope this also works when you plug it into your
MMRC, as that is never quite a guarantee. All right, that's all I got for this one. I think that
might be, is that our last big, yeah, okay, so let's, let's do some questions on this, if there
are any, and then, yeah.
Oh, yeah.
Yeah, it's, it's one of those things where like, if you're lucky, it works out of the box.
If not, it could take you anywhere from one day to one year to stumble on just the right
series of incantations and configuration variables. So for anyone who didn't hear, the question is
recovering file. Oh, man. All right, well, it looks like you got something.
Why?
I'm sorry you had to see that.
It's not even submitting yet. How long does it take to get, get out of here.
It's ridiculous.
They're like, oh, God, that's the Vim Teamux. If your geolocation is a New York City bug,
I've seen stranger bugs. So, sorry, before we were so surprisingly redirected there,
the question was refresh my memory. Copy-pasting. Yes. So the question was,
copy-pasting, how do? The question was much more nicely phrased than that.
If it works, if it works out of the box, you can use the plus register. If you're not familiar
with Vim registers, there's more than one clipboard. There's the default register, which if I just say
dd to delete the line, it goes into the default register, also called the double quote register.
If I select a different register using the double quote command, I can say delete this into
register A. And then I can say delete this into register B. And then I can say paste from A,
paste from B, we're having a great time. But there are some very special use registers,
one of which is the plus register. I think that it's the plus and the asterisk register,
which connect to the system clipboard. So I don't know if it works out of the box on mine right
now. Let's see if it does. Yeah, double quote plus double Y. So did that work? Let's see if it worked.
Command V. Yeah, see? So I copied from my Vim into the system clipboard. That's cool.
I'm not going to talk about how much time I may or may not have spent making that work.
Next month, I'll just do an entire hour long talk of how to make your system clipboard work on
various different systems. This is one of those things where it's like it shouldn't be hard. It
really just should not be difficult. But no matter how many times I get fed up and I'm like,
I'm like a big cool software developer, I could figure out how to actually make this work. It's
ridiculous. And then like six hours later, I'm just drenched in sweat and I'm miserable. And I'm
like, it's so hard. And it's one of those real talk moments where they're like, why doesn't this
work? And you're just like, look, I'm sorry. It shouldn't be this way, but it is. It's software
development. I'm so sorry. But you just cannot copy paste right now. So yeah, I wish I had a one
line answer for that one. But if someone else stumbles on it, please let me know. Because I
would love to spread that knowledge. All right, excellent question. Anyone else? Yeah?
Is there a way to do templates like you're doing a shell script and it just knows like
like, like if I did a snippet thing, but it would use environment variables and stuff,
you just fill it in. Yeah, there's got to be a way I couldn't tell you off the top of my head.
I might almost just like run an external bash script and read that in. Because you can do that.
It's just a question of like keeping track of all those moving parts, you know, I think that's
really one of the toughest parts of them is just that it has a lot of subsystems that do a lot of
different things. That's a good question, though. If anyone didn't hear that question was just,
could you do templates with environment variables and filling things in and I'm positive you could,
but I wouldn't know off the top of my head. It probably would look a little bit like the
thing that I did with the HTML. Yeah. So are there any plugins that you use? Yes. I actually am
going to talk about that, but I'm going to leave that for the end. Excellent question. Anyone else?
Cool. All right. So before my closing outro, that's what that's called, right? I just wanted to talk
for a quick second about two very important things. Important thing number one. This is mostly
tangential this talk, but it's really not because everyone who uses Vim should do this all the time.
Use the help system. Use the help system. Use the help system. It's so good. It is so strong.
Incredibly configurable. Not even configurable. I'm going to show you what I'm talking about.
If I want to know what the control N key does, either out of curiosity or because I know that
it's related somehow to what I want to do, there are key codes for all the different special characters
that you can use. The most common one is control and its character code is the upper carrot. Yes.
If I just say help control N, it's going to show me what control N does in normal mode.
So it counts N lines downward. Okay, cool. But what if I want to see what it does in a different
mode? You can do that also. You can say help I underscore, which means show me what the following
command does in insert mode control N. Now find next match for words. So this is the
autocomplete keyword that we used before. What does it do in command mode when I'm typing here in
the command line C underscore control N. So you can look up any command in any mode just by prefixing
it with that mode number, mode letter underscore. The other most useful thing that I know of is
help grep. It does exactly what it says in the tin. It greps or searches through
every help document it can find. So I can just say help grep windows. And it will find every
single, it found 587 matches for windows. And I can use that exact same quick fix list from
before CN, CPCL to just look through every instance of the regular expression windows
in the entire manual. So if you can even think of a vague phrase that might have something to do
with what you're trying to figure out, then you can use help grep to jump there or find
any possible instance of it. If you want to just browse this stuff, just type in colon help and
hit enter. And this is such a nice and friendly man page compared to a lot of what you'll see
elsewhere. It just shows you most of the stuff that I just went over down here. And it will tell
you how to navigate, how to jump through, how to jump back, how to get help on specific things.
It shows you all the mode keys. So just if there's like one thing that you ever just
individually take the time to peruse, let it be the main help screen, because it will make you
so much faster all the rest of the time. You won't even have to Google anymore, unless you're
dealing with something real hairy. So that's super important thing number one.
You don't have questions about this or just like want to scream out loud. Wow, that's awesome.
I do that all the time. Yeah.
I usually read it. It crashed again. The crash gatherer crashed. All right.
We're into the bonus now. So, you know, online viewers will just have to deal. I'm very sorry.
Really? So the question was, what's the best way to view this stuff? I think that one's probably
up to personal preference. I don't mind looking at stuff in a terminal screen. And I really like
being able to do, for example, so I can say, oh, I want to jump to this. And I can use the
actual tag feature control right bracket and jump to help summary. And if I want to help on
something else, and it says you can see user guide topics in this file, and I can just jump to that
file. If I'm done reading, I can jump back with control. Oh, so now I'm back to the first file
where I started. That's really cool. It's just not as fast to do that on a web browser, just because,
you know, you'll have to find the link to click with the mouse. And I don't know that kind of
stuff adds up for me, or at least it feels like it does. But if it's easier for you to read this
stuff in a browser or I don't know, print it out and highlight it like a book, I kind of want to
do that now. You should do that because the important thing isn't like that you do it exactly the
way I'm doing it. But just like, give yourself access to the docs. There's so much good stuff in
there. Reading through the docs is how I found all of this stuff. Some of it I had to really
search for. But some of it I just stumbled on. I was like, wait, it just does this? That's awesome.
What? And if you give yourself as many opportunities as you can manage to have moments like that,
your journey through them will really benefit from that because there's an awful lot just hiding
right under the surface to be found, I think. Very good question. Others? Yeah?
X mode? Why?
X mode. Which one is that? Is that X mode? I forget what in the world X mode is for.
I mean, it's kind of like, oh, God.
Lord, give me the strength. It's there to keep you on your toes, I guess. In case you felt like
you'd achieved a state of flow, there's X mode. I can remember a single time
when I did something with X mode, but I cannot remember what in the world it was I did or why.
So I got nothing.
All right. Yeah, so it does something. Not one of my favorite modes, I have to say.
I'm not using my default MRC, but I'm pretty sure I've done that finally in my main one.
Okay, other questions? These are fantastic questions, by the way. Cool. All right.
Important thing number two, plugins to use. So I do, in fact, use plugins.
Let's see if I open my regular MRC. Is it going to be legible here? Let's find out.
That's all right. So my MRC is huge. It's like 10 years old now.
I alternate between, like much of the material in this talk, I alternate between being super proud
and slightly embarrassed by it. The plugins I do use, I use Vundal not because I have any
particular attachment to it, because it was the first thing that I stumbled on and I haven't had
any issues with it. What I will do is I have this sort of section of my MRC where I give every
single plug in its own little fold where I can add multiple plugins that are related or
add some configuration that's plugin specific. But if you look down my list of plugins that I use,
they're all extremely specific. They're all pretty small, with the exception I think maybe of
Nerdtree, which is the file browser that I do use. But this is like Vim Elixir, Vim Teamux, Vim Ruby
Heredoc syntax. That's literally so that I can open up a whatever.rb file and say HTML equals this
and then put HTML in there and it will highlight it correctly. That's the entire purpose of that
plugin. So it's really small. I forget if that's a plugin that I wrote. I have no idea.
I don't know, let's find out, is it? No, thank you Joker 1007. It's really cool. You can just
add other things. If I put Hamel, it'll highlight Hamel. That's so neat. So really, they're all
pretty low here. They're all pretty small here. Obviously, I use all of Tim Pope's plugins.
You may be the first humans of the me to lay eyes on that particular line. I'm kind of proud of
that one. But I use his surround thing so you can do the change from single double quotes,
like that kind of nonsense. Tim Pope makes a lot of really nice, small, targeted plugins that
make Vim a little bit more of a joy to use. But yeah, I mean, that's pretty much what I do for
plugins. If I am doing something and I just need a tweak where it's like, okay, it's not syntax
highlighting mustache and handlebars, or I want to be able to correctly indent coffee script.
Sorry, no, that's React files. There's a plugin for that. So I try to keep them pretty small.
That's basically how I use plugins. Like I said before, I do use, where's the big one?
There it is. I do use NerdTree, which I have configured a little bit. But that's, I think,
the only like big plugin that I use. I've used a few others over time, but I don't know. None of
them have really stuck. I'm not even like, super happy with NerdTree. I mean, it's awesome. Like,
I don't think that I could make a better NerdTree than NerdTree. But like, it's, I'm just very,
I'm very dependency ever when it comes to my tool set. And one of the reasons that I tried to stay
as neutral as possible for most of this talk is because I know I'm biased towards like, don't
use plugins, but you should. So I don't use many of them, but I use Vim pretty idiosyncratically,
even for Vim users. So don't look at this and feel like you have to make sure that there are no
plugins longer than like 500 lines or something like, don't worry about it. If a plugin makes your
life easier, use it for sure. I think, yeah, that was my second other important thing, right?
Let's have anything else here. Yeah, all right. So unless there are questions,
all right, that's that's all I got. Thank you so much for joining me. This was a pleasure.
Let me go through my little outro here. I have the slides available on GitHub.
I also also just for convenience, I put the Ruby quick fix format or there in case you're
interested. I mostly post kitten pictures and complain about things on Twitter. If that's your
kind of thing. I'm also taking on clients and students and possibly looking for full-time work.
So if you know anybody who needs a tutor to learn Ruby or Vim or Python or web development,
if you need someone to do internal training, or if you're just looking for a dev or PM,
get in touch, we can chat. Worst case scenario, we get to have lunch and hang out and that's
always fun. But that's all I got. Thank you again so much. Thanks very much.
