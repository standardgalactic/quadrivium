My name is Freya. I have been in the industry professionally for about like nine years at
this point, maybe 10 years. I also used to be part of Future Games. I was in the class of 2010.
I've been teaching a Future Games since like after two years after that, I started teaching a Future
Games as well. I did mostly like C sharp courses and math courses, as well as some guest lectures.
Otherwise, like professionally, I made a plugin a long time ago for Unity called Shader Forge.
So it was basically a node-based shader editor for Unity, which didn't exist at the time.
There was one that was like outdated, but it wasn't maintained. And the person who
worked on it was hired by Unity. And then they kind of started working on, you know,
Shader Graph internally, which took a very long time, luckily for me, because then I could make
Shader Forge. So I sold Shader Forge on the Asset Store, which made like enough money to be
two full-time salaries pretty much. So me and another student at Future Games, we started a studio.
So we started an indie game studio called Neat Corporation. So at Neat Corporation, we kind of
started out wanting to make our own like very specific indie game. But then at GDC, we were
sort of, we sort of like bumped into Valve right as they were releasing their HTC Vive headset.
So we got kind of inspired by VR as soon as that kind of happened. So as that exploded, the whole
VR scene, we got to be there like at the very, very beginning when everything started like growing,
which was really cool. And also made us realize how like going to GDC and just talking to industry
people can lead you down so many paths. And like just that connection with people is so important
if you want to like make connections in the industry, start new opportunities and whatnot.
And all it takes is kind of like, you have to try to be available for all of these things.
Anyway, that was the story of Necorp, how we sort of started Necorp and started working on the game
called Budget Cuts. So that was our first kind of flagship release title. One thing that I just
need to mention before we get started in terms of like my approach to teaching, like my goal is
that I'm here to help you learn, right? That's kind of it. So you usually get a lot of questions
along the lines of like, you know, do I have to do this assignment? And so forth. The short answer
is yes, because you're going to have Chris there do all the grading and all that stuff.
But the long answer is that I personally, I don't care what assignments you do or don't do or
anything like that. My goal is that you should learn the things that you want to learn, right?
And I'm here to help you do that. But I do want to stress that it is important though,
like what kind of standard you're setting, not only for yourself in terms of like what goals
you have and what you want to learn and how you learn, but also how that reflects on you in the
eyes of your fellow students, right? Or even in the eyes of me, right? If people around you notice
that you are someone who is like doesn't do any assignments or like show up late for every lecture,
then I think a lot of people like are going to think of you as that person that's always late
and doesn't like deliver or whatever. And you're all going to be in the industry soon, right?
Like if you think about my classmates, pretty much all of them are in the industry now. So,
you know, I will remember people who were kind of like not great. So like, it's important to kind
of like be a good person and be like kind of project the image of you that you want others to see
once you're in the industry, right? So I think it's important for like from that, from that point of
view to actually do do assignments and whatnot to at least be the person who did the assignments,
right? But then again, personally, I don't care that much. I just want you to be able to learn
the things you want to learn, right? If you hate math, you don't think it's going to be useful,
then sure, feel free to not do anything, right? But I think it would be detrimental for you,
especially if you want to do a lot of coding. What will the assignments look like? The assignments
will be mostly to do some mathematical thing in Unity. It's not going to be very Unity-centric.
Unity is mostly going to be there as our like platform and rendering engine. So it could be
things like I would do the math for the spread of bullets in a shotgun or whatever, like that kind
of stuff. So they're going to be pretty short. I intend to do like more than like one assignment
per day. So you can have like three tier assignments, like one easy, one medium, one harder task. And
then you can sort of do however many you want, I think, depending on how Krister wants to grade
this. I'm just going to send the like answers to Krister and he's going to work on the grading
and stuff. I usually like having a tiered like assignment thing, because it tends to be more
flexible. And you can sort of do things step by step, which I like. All right. Another very important
thing, please ask questions. There are no stupid questions. I think it's like one of the most
detrimental things for you to do is to like you have a question in your head or something I said
was unclear. Please ask that question that you have in your mind. It's so important. Because like
usually when people like almost every time someone says, this might be a stupid question, but
they ask a really good question. So please keep that in mind. Ask questions. Don't be afraid to ask
questions. Asking questions doesn't mean that you're stupid. It means that you're actually smart,
because you actually want to learn the thing and want to understand the thing that you are
observing and trying to pick up, right? But of course, try to stay on topic like don't go like
too far off. We're gonna have a lot of breaks. So we're probably we can do like, you know,
random Q&A stuff during breaks if you want. Okay. Oh, obviously, sometimes like some people can get
very stuck on one thing. In that case, if like one person gets very stuck on something, then we can
probably like talk about that after the lecture to like clarify any anything. In case it like takes
too long to like try to hash that out. All right. Any questions so far? Sorry, we haven't like started
the actual lecture. I've just been rambling about random stuff. Will there be any linear algebra?
I believe so. Yes. I mean, yes, we're going to talk a lot about vectors, dot products,
crotch products, all that stuff, and matrices too. All right. So
let's see shuffling around my notes. Oh, if you want to, we could look over some of the things
you're going to see in math papers. I don't know if you want to like have some tool sets for like
being able to parse papers. I could plan that plan that in probably not for today, but some of the
other days, because we do have I do have a bunch of like time that I haven't like planned in because
usually things take longer than you expect. Sometimes they're way shorter and so forth.
All right. So I first want to talk a little bit about like why I think math is cool. I think math
sort of has this bad reputation because I think a lot of in a lot of cases it's taught as kind of
just the boring thing you have to do in school that has to do with numbers. And you have to like,
I don't know, it seems very esoteric. And the most common question that students ask is like,
when am I ever going to use this in my life? Right? Like, when do I need the cosine? You know,
like that that is extremely common for people to to feel like that and when it comes to math.
But I feel like game development is sort of one of the like one of these strongest cases where
math is just like extremely useful, like absolutely everywhere in in doing game development, not
only like in terms of gameplay code, but also like a lot of it is in like rendering and all of that
stuff, right? But I think the the problem with teaching math in general is that I feel like
people who teach math are sometimes like excited about math, but they don't really they kind of
presume that other people are already excited about math. And then they don't really like show it in
an exciting or interesting or visual way. So then it just becomes this esoteric thing where
you have to charge through a bunch of numbers. And it's just boring, right? So I think that's
a that's a shame. I feel like mathematics is incredibly fundamental. It's like one of the
most fundamental fields of study that we have. And like, they're like, it kind of doesn't matter
where you are in space, like you could be an alien species somewhere, you could be like,
absolutely anywhere, it doesn't matter, doesn't have to be on earth doesn't have to be this society,
you can have other numbers of dimensions, but math is still gonna exist, right? It's gonna be called
something else numbers are gonna be presented in a different way, people are gonna use different
symbols, but math in and of itself is gonna exist. Because math is like, it's the like the study of
quantity. It's a study of space, it's study of structure, it's a study of change. And it's kind
of hard to imagine a universe where any of these things just don't exist. Like, what does it even
mean to have a like, what does it even mean to have a universe that doesn't have quantity as a
concept, right? And I think that's really cool. It's gets kind of this like field of study where
you can sort of co discover things, like, you know, the the circle constants, like pi and tau,
e, the golden ratio, like all of these things are probably discovered in other societies,
presuming they exist, even though we're entirely disconnected from each other, just because it's
this study of the very fundamentals of kind of structure and change and that type of stuff.
Yeah. And so, so for me, I feel like the, it kind of underpins like physics, it underpins chemistry,
biology, none of these things would really exist without math working as well as it does and being
applied to these fields, right? It's similar to philosophy. I feel like philosophy underpins
everything in like social sciences, it underpins morality, ethics, politics, philosophy sort of
the groundwork for all of those things. And that's kind of why I also like philosophy. But I think
it's really cool that this is so fundamental. And that's why I think math is cool. They're also
like, you of course can't like apply it to absolutely everything. Because usually people
say stuff like math is universal language. But you know, it's kind of not universally applicable
to every situation out there. Anyway, so that's all well and good. But I'm already,
I'm already interested in math, and you might not be. So I feel like we should go into the like
practicalities of what it actually means to use math in, in games. And how everything works.
Also think people overestimate how much math you need to know to do cool shit. You can get so far
with a few basic principles in some time. Yes. I keep saying that you don't need to know that
much math to do game development. If you want to like make an engine, you need more. But if you
just want to do gameplay coding, or even shader coding to some extent, you don't need that much
math. So I'm going to go through most of the like, the very essentials of game development math.
Like, even things like derivatives or integrals, they are kind of rare in game development.
Even though they're very fundamental in teaching math in game dev, you don't have them very often.
Like, mostly if you're doing some very like, very math heavy rendering stuff, that's when you
start running into, especially integrals. But otherwise, like generally, like linear algebra
is like most of, most of game dev math, understanding derivatives and integrals is really useful for
anything related to implementing physics. Yeah. So there's the idea of what a derivative is,
is really important. But you don't really need to know how to derive equations, right? So like,
generally in game dev, unless again, you're coding a game engine, you're going to be using
existing physics packages, you're generally going to do things on a per frame basis. So like,
the understanding of it is really important. But to actually derive equations, isn't that
important? Sometimes you will run into it. But I don't think I think I might have run into it
like once or twice throughout my career. But yeah, understanding it in terms of like, yeah,
like you mentioned, like time dot delta time, that we're going to go through because that's
really important. But in terms of like actually deriving equations, they don't really do that
much. So I feel like there, there is a concept that is talked about very early on in your math
course. And usually it's referred to as the number line. So you can imagine this, like one
dimensional space, we can just move along this one line, right? And in the center, we can put
the number zero, right? And then you can sort of imagine a space where these numbers are
kind of put along this whole line, right? All right, so we have one, two, three, so all integers
are on these little notches. All right, cool. So this is the number line. It's like, I think it was
like usually this is mentioned very early on in your math courses. And then it's kind of like
forgotten. But I think it's an extremely useful place to be. Because it very like beautifully
illustrates kind of the continuity of numbers and like where the integers are and so forth, right?
I hope I got these numbers right. I feel like I'm going to make so many weird mistakes. So
all right, this is correct, right? Okay, cool. So we have zero in the center. And then one, two,
three, four, five. So we have our positive numbers on this side and negative numbers on this side.
And this continues to positive infinity. This continues to negative infinity, right? So this
is a useful way of thinking about it, because you can have numbers that are between the integers,
right? So these whole numbers are integers. And then between those, you can have decimal numbers,
right? So you have 0.5 here. So that's halfway between zero and one and so forth, right? Okay,
so, so now one thing that's very important, whenever you're working with math, especially in
game dev is not to really think about numbers in terms of just being in numbers. Because numbers
is only there to represent something else, right? So, so then you can ask like, okay, what is this
number? What is it like? What is it? What is it a substitute for, right? And what is it representing?
So usually, if we have a number, let's say we have number two, and we can mark it with a dot there.
So, so what does two mean here? Well, we could interpret it in many different ways. Two could be,
it could be a position, right? Maybe this is the position along this line, in which case,
this is going to be a coordinate system, right? Where every number says the position
on this one dimension, right? So we could call this the one x axis, right? So this could be
interpreted as a position. We could also interpret it as a vector, right? It could be an arrow,
usually going from zero, because vectors don't really have your roots of quote unquote, the arrow,
they only have a single point, right? So this is a vector, it just has the value two, right?
And because it's one dimensional, we can only, we can only have vectors that point either to the
right or to the left, right? So we can interpret two as a vector, we can can do another number,
let's put three here. And then this is another vector, we can do another vector for negative one,
right? So this is sort of a one dimensional interpretation of vectors. But then we can ask
like a lot of questions about these, right? We can ask how, let's do another vector actually,
let's do negative three. Okay, so usually when you work with vectors, you work with a lot of concepts
in terms of like length and direction and that kind of stuff. And usually you kind of start doing
that once you go to two dimensions. But all of these things exist in one dimension two,
this is not exclusive to like two dimensions and above, right? So if you look at these vectors
right here, what is the length of these vectors? Well, this one that's pointing to two,
this one has a length of two, right? The this one has a length of three. But if you go to these,
these also have a positive length, because the lengths are always positive, right? This has
a length of one. This one has a length of three as well. So yeah, so this is basically a just a
one dimensional interpretation of what vector length is, right? Also, I didn't draw these
exactly the same size. But you know what, that's okay, you get the idea, I hope. All right, so
what about direction? What is the direction of these vectors? Well, if you think about direction in
one dimension, usually directions have a length of one. So in one dimension, you can only have
directions that are either negative one or one. Sometimes that's usually called a sine. When
you're working in one dimension, usually it's called a sine, sine of x. So usually this is the
like one dimensional direction, right? Basically, it's only positive one or negative one. There are
some like exceptions if x is zero. If x is zero, then it kind of depends on the implementation.
In some cases, it's going to throw an error. In some cases, it's just going to return one
and so forth. But usually it'll either return zero, one or an error when you pass in a zero.
Anyway, so the sine of these numbers is the direction it's pointing pretty much. And if you
want to get the length of these, actually, maybe I should keep the sine of x is basically the direction.
So this is either negative one or one. Mostly random rambles in the student chat.
No questions yet. So zero vector has no direction. Yes, it's sort of like depends on your implement
or like implementation and interpretation of like what it's used for. Like in some cases,
it is useful to interpret the sine of x to be one. Because quite often the you use the direction
to multiply something to like sort of change the direction and the scale it by some value.
And sometimes when the value you're checking the sine of is zero, sometimes you want it to be one.
But generally, it depends on generally depends on like the case, right? But again,
the like purely mathematically, a zero vector doesn't have a direction, as far as I'm concerned.
Alright, so so this is kind of the direction of a one dimensional vector. It's usually called
sine. Again, for one dimensions, these are sometimes called scalar, scalar values and so
forth. Then again, the the length we talked about, like the length of these vectors, because the
actual values of the vectors, like the value of this one is negative three, right? But the length
of it is three. So so to get the length of a number, you basically just you get what's called
the absolute value, which is just a fancy way of saying, if it's negative, make it positive,
like that's it. So so the absolute value usually abs in your math libraries. That's the that's the
length. Sometimes called magnitude, but I feel like I'm the only person in the world that calls
abs for scalars magnitude. But I think it's funny, if sine x can only return one number when it
is a float, it does return a float, we are not talking about two dimensional vectors yet,
we're only talking about one dimensional values, which is floats or a scalar or a single value.
So we're not we haven't gone into two dimensional or three dimensional vectors yet.
Can you sign a 2d vector? What if the vector has one negative value and one positive? So
so generally, the the general case of a sine is that it gets the direction of the vector.
The the sign of a two dimensional vector would would would be itself a vector, right,
because it's a it's a two dimensional direction. What we're going to get into 2d vectors,
I just want to start out with one dimensional stuff. But I think it's kind of neat that you
can have a one dimensional interpretation that is still vector based. So so we're still just on
the number line, we we don't have any two dimensional vectors here. Right, so then we can
ask a lot of questions, like what does it mean to let's say we'll ask some question like,
what is the what is the distance between what's the distance between one and three? Like,
what does that question mean? Well, generally, a distance would be we want to get this length
here between these two numbers. So that would be a way to get the distance, right?
So so if you want to do if you want to get the distance between these two numbers, then
generally, you would, you would have the two numbers represented as like, well, we could
represent them as just letters, right? So in this case, we want to do three minus one.
And then that gives us two, right? So then we get the distance between these two numbers. So so
usually, doing like subtracting is usually it can be interpreted as getting the difference
between two values, right? So so if we want to get the the distance between these two values,
generally, you do one minus the other. But if you like flip the order of these, if you do one
minus three, you're going to get negative two, right? So so in this case, we actually want to
we want to make sure that we get the length and the magnitude of this, right?
Because if we do three minus one, what that gives us is that we basically take this vector,
this is three, right? Because it lines up here, this is the one dimensional vector representing
the value three. And then we want to subtract the vector one, and the vector one is this vector,
right? And the way to kind of interpret subtraction is that you can sort of take this arrow,
and you can subtract it as in you flip the direction of the arrow, and then you get a new
value that stops here, right? And that's going to be an arrow that goes here. And this is the
value two, right? All right. So but then again, this is order dependent, this presumes we have
the three before the one, otherwise, we're going to get negative two. So if you ask the question,
what is the distance between these two values? If you say negative two, that's going to be
a bit of a weird answer. Depending on the implementation, there are some cases where
you want to get what's called a signed distance. And again, signed distance is referring to the
fact that it can be either negative or positive. But generally, distance values are always positive.
Same thing with area, if you want to get like the the area of some polygon, then the area is
considered to also always be positive, except if you want a signed area. So a signed area just
means that it can be either negative or positive. So you're probably going to hear a lot about
like stuff like signed distance fields, which is a term that has kind of exploded for the past
few months. It's just a fancy way of saying you have a field of distance values that can also
be negative. All right, so if we want to get the actual true distance between these two things,
as in the positive distance, we would need to get the magnitude of this, right? So
that would be the absolute value, right? So so generally, this is the way to get the distance
between two values, or more generally, if we want to generalize this, we can say that the
let's see,
the distance between, let's say we have values a and b, we're still only talking about float values
or scalars, one dimensional numbers. So if we want to get the distance between a and b,
all we need to do is do the absolute value, as in the length of the difference between a and b.
So now we have the difference between a and b, and then we get the length of that.
And then we got the distance value. Okay, everything clear so far,
also realized I haven't talked about addition, that might be a good thing.
Addition is probably good to know. So if we want to do three plus one,
let me just erase things, it's a little messy.
Let's say we want to do three plus one, then in a one dimensional interpretation of vectors,
then this is three, right? And then we can have a another vector, this is one.
So if you want to do three plus one, one way of interpreting that is that
it's kind of like taking the vector and kind of just adding it on top of the other vector.
So now we have three and then plus one. And the final vector we get out of this as sort of the
result of this equation is this vector going all the way here, which is the value of four.
So that's kind of like how addition works. Previously we did subtraction when we wanted
to know the difference between these two, in which case instead of adding this to the top,
we negated and then add it, right? Or just subtract it, right?
Yeah, so then doing that we ended up with a vector adds two, right? Because three minus one is two.
As far as I know, I'm bad at doing math like I mentioned before, I might be wrong.
Okay, cool. Any questions so far? Sorry for the like weird one dimensional vectors,
but right now we're only talking about scalars. We haven't gone two dimensional yet.
Yeah, so so far we've learned that three minus one is two. That's how well this math course is going.
What's the difference between length and magnitude? Nothing.
It's the same thing. Three plus one equals four. That's true, we did learn that too.
Yeah. This is Thor, the void, how?
Buddy, you don't have to use your claws.
Oh, I missed a question. Will we go deeper into quaternions later on in this course? No,
we're, I'm going to talk about how to use rotations, but I'm not going to talk about
how quaternions work internally, because that's not relevant. You don't need to know that in
order to make games, because we're not going to be engine coders. We're going to make games,
right? So I'm not going to go into like how to write a quaternion class, but I'm going to talk
about how to use Unity's quaternion class, how to apply rotation, how to think about rotations,
what they are, and so forth. What's the difference between quaternions and rotors?
Mostly an interpretation difference, as far as I know. So let's see. There are a few things we
haven't talked about yet. So we've talked about some of the operators you can do. You can do the
sign will get you the quote-unquote direction of a one-dimensional vector or a value,
which is either just negative one or one. Abs will get you the magnitude of a vector,
which means that if you have a vector or a value of negative four, abs of that abs of negative four
is four, right? It just makes negative values positive. In terms of one-dimensional vectors
or floating point values or scalars, right? It's a little different for two-dimensional
vectors, and we're going to get to that. And then we have the distance. As you get the difference
between two values, it could be like we had before, three minus one or yeah, three minus one. So that
will be two. If it's negative two or whatever, then abs will make sure that it's positive,
and that's the way to get the distance between two values. So if we want to get the distance
between negative two and two, like we want to get this distance, then we can just do that
formula up there, right? And then it will work out. We talked a little bit about adding and
subtracting as well. But the next thing that we should talk about is like what does it mean to
multiply a value, right? So usually the way that I like to think about it is that when you're adding
something, addition is an offset. Addition is to move something or increase something by some
amount, right? So I usually think of addition as an offset and multiplying as a scale. So we can
scale something by multiplying something by some other value, right? So let's say we have the number
two, right? We have the number two, and then we want to multiply it by some other value. Let's
say we multiply it by two. So if we multiply that by two, what this means is that it's going to be
twice as long. So that's going to go from being on two to being on four. So the result of that is four,
right? So what that means is that because we have multiplied by two, the length of this vector is
going to be twice as long, right? Because again, if you do abs of this one and like check the length
or the magnitude, it's now going to be twice as long as I was before. And this relationship holds
for any other vectors too. It's not just for scale our values or one dimensional values. Okay.
So and then we can do, we can do other examples. So we can do two multiplied by 0.5. So this is
basically half a length, right? So 0.5 is 50%. So what we're going to do if we multiply two by
0.5 is that it's going to be half as long, right? So that's going to have a value of one,
because two multiplied by 0.5 gives us one. And the same thing is, it's the same thing when it
comes to dividing, right? So this is the same thing as doing two, two divided by two. So multiplying
and divide are kind of the two sides of the same coin, just like, so for instance, let's say we have
a plus b. And then we have a minus b. So if you think about these, these two situations,
like having a like subtraction, all that is, is kind of like you're adding a negative number.
So so another way of interpreting this is that instead of looking at it like this,
we could just say that this is the same thing as a plus a negated version of b, right? And negation
is not the same thing as subtraction, right? So this flips the sign of it. A negation means that
if it's positive, it's going to be negative. If it's negative, it's going to be positive. So
like addition is generally kind of like, or subtraction is sort of a special case of addition,
right? Actually, let's do, no, let's do multiply. So a multiplied by b, and then we have a divided
by b, right? So, so in this case, this is sort of also a special case of multiply, right? So
in this case, it's actually a multiplied by the reciprocal of b. As a reciprocal is basically
one divided by, by the value. So these two are the same thing, right? So so you can sort of think
of addition and multiplication as the core things that you do, where when you're doing subtraction
or division, it's kind of like a special case, where you're kind of multiplying by the reciprocal
of something. Or in this case, you are adding the, the inverse of something, right? Anyway,
sorry, that was a bit of a tangent. Anyway, I just think that's kind of cool. Probably not
super relevant to know. But usually the point is, you can kind of convert between these two,
you can, you can translate a multiply to a divide if you want to, or divide into a multiply.
Yeah. Okay. That's a big word. What's a big word? A lot of this meowing in the background,
had to bless our chat for their authority mode. That's a great emote. Thank you so much, Marcus.
Oh, reciprocal. Yeah. Oh, sometimes it's called one over as well. But yeah, like sometimes there
are actually cases where instead of dividing multiplying can be like slightly faster in
terms of like computationally, but usually that goes into the category like unnecessary
micro optimization. I guess it depends on what you're doing. But yeah. Okay.
Cool. Let's see. Are we, I think we think we might be ready to move into two dimensions.
So let's erase a bunch of things. Don't need that. These are kind of weird.
Why are these numbers marks? Why do those numbers matter? It's a little unfair, actually.
Can you explain Quake Engine's inverse square root at some point?
What part of it? I don't, I'm not super familiar with the actual maths of it.
But as far as I know, it was like, it was an approximation of doing the inverse square root
of something. And we used like kind of weird bit shenanigans that sort of only works with
certain representations of numbers in binary. But yeah, I don't, I don't know too much of
the history behind it, except what I just said, basically.
But I'm sure there's a Wikipedia article or something you can go to.
Okay. We've talked about one dimensional numbers. One dimensional or one dimensional
vectors are usually not called one dimensional vectors. Usually people just call them scalars.
People call them floating point values and programming or decimal values.
So I've sort of approached this in a non-conventional way. So don't call things one
dimensional vectors because you're going to confuse people. But the only reason I approach
it this way is because all of these functions have direct analogies to the higher dimension
vectors. So let's go to two dimensions. Let's just enter another world or something like that.
So usually when we talk about, when we talk about dimensions, usually we have axes, right?
Currently, we've only had one axis, like it's the x axis. Usually this is the number line.
We only have the one axis where we have all the numbers, right? And if we want to represent
a position here, all we need is one number, right? And we also need to not lock alpha on the layers.
Anyway, okay. So basically if you want to represent a position on the number line, all you need is
one number because there's only one dimension. So what we're now going to do is that we are
going to add a dimension to this. So first off, when we work in multiple dimensions,
it's really useful to use colors. So usually when working in 2D or 3D space,
usually we use the colors red, green and blue. So the x axis is, I'm using the eraser. There we go.
x axis is usually red. And there's a neat little, little shorthand if you want to like remember
which one is which. So usually you have x and y and z. So these directly correspond to, you know,
RGB, right? So if you want to remember like what axis is what color, then they follow RGB.
Like RGB is usually the color, color space we use and they directly correspond to the colors of the
axes that we have in our, or the each dimension axes, basis vectors, whatever like term you want to
use, they correspond to this. So like if you open up Unity, the colors of the gizmo is going to
match this, right? If you see a red axis, you know that that's going to be the x axis, right?
So it'll look something like this. There we go. It's something that like, I don't know,
it's weird how many people have not realized that. It's like, it's one of those things that's
obvious once you learn it. But before that, it's like really not obvious for some reason.
But yeah, someone in Twitch chat said left handed. The reason it's left handed is because we
are going to talk about Unity. And Unity is left handed. And Unreal is also left handed,
although Unreal is z up. But yeah, anyway, so that's why it's left handed. So I'm sorry for any like
actual professional mathematicians, because math is usually right handed, which is kind of kind of
not great. But whatever, it's okay. I'm also left handed. I'm glad you figured out your chirality,
right? All right, so we're going to add another dimension. So so far, we've just had one dimension.
And we also need to close this document because Photoshop decided to lock the document, which
it sometimes does when I'm using the tablet. Right. So we're just going to we're just going to
take this axis and copy it and rotate it. There we go. Oh, if you're like very familiar with math,
this is probably painfully slow. And I apologize, but I do want to make sure that everybody feels
very covered and know what we're talking about throughout this entire course.
So sorry if it's a little a little too basic, but that's okay. I hope that's okay. All right.
So let's see. The number line still works the same way. We still have not like,
it's still a number line, we just have two of them, right? So now we have one,
two, three, four, five, negative one, negative two. Okay. So now, instead of a one dimensional space,
which was the number line, we now have a two dimensional space. So generally, when you add
a dimension to something, the dimension is always perpendicular to the the other dimensions.
So or the other axes. So so whenever you're looking at something like this, then actually,
it's not always perpendicular. But if you want to have like an orthographic space, which you usually
work in, then all of the axes will be orthographic to each other. So they're they always meet at a
right angle. Again, there are exceptions. If you're working with like projection matrices or
whatever, then but whatever, that's irrelevant now. Sorry, I'm going into unnecessarily weird details.
All right. So now we have a two dimensional space. So you know how we previously
marked a point where, you know, we would say that some place is three, right, in terms of position,
right? When we are working in two dimensions, instead of every point on the number line,
being a single number, a point in two dimensional space is two numbers. So there are a lot of like
different ways you can like write vector notation. Usually in mathematics, their notation is really
garbage and terrible. So I'm just going to sort of do whatever because math hasn't hasn't worked this
out yet. So usually I just do parentheses when I want to like mark a vector. So so let's say we
have we want to get a position in this 2d space. Let's say we mark this point right here. Just like
we did before, we could draw an arrow representing the position. And if you want to draw a position
or a vector vectors, vectors kind of always originate from zero, because vectors don't have a
root and a tip, they only have a tip. So like where you put the vector is only for like visualization
purposes or interpretation purposes. This is really important if you want to like,
know the distinction between like a vector and a point in a direction, which we're going to get
into. So now we have a point. So this is a point we can represent as a vector to. And now if we
want to like type the coordinates of this one, it would be two on the x axis. And it would be one
on the y axis. So so basically what this means is that each of these are called components. And
these components of this vector correspond to each of these two number lines. So this is the x
component. And this is the y component of this vector, right? In unity, this type would be called a
vector to because it's a two dimensional vector. There we go vector to. So so this is how you
would sort of write it in code, you would do new vector to and then you have a two dimensional
vector, right? Okay, so this, these are the coordinates for this point, right? All right.
So so now if we look back at everything we talked about before,
we can start doing a lot of operations with these that works exactly the same way in two dimensions.
So so let's start with addition. Let's see you want to add something, right?
So let's say we want to lock the Photoshop document again, and then reopen it.
All right, so let's say we want to add something to this.
Let's call this something. Let's call it a
or maybe I don't know if we should do a lowercase. Let's do a lowercase. Why not?
Oh, discord just said 170 new messages in the student chat.
Hope not. No, we're fine. Okay, thanks discord.
All right, so we have the vector a the vector a has these values, right?
And then we want to add to this. So again, when we were adding numbers, we we sort of had one,
a one dimensional vector plus another one dimensional vector, right? If we want to add two
dimensional vectors, you would kind of get some number here, some number here, plus some number
here, some number here, right? Because you have x and y coordinates, right? So you would have x, y,
x, y, if you want to add two two dimensional vectors together, right? Okay, so let's let's
pick another vector. Let's say we want to do the vector here. So what are the coordinates of this
vector? There we go a question for class. How would we write the coordinates of this vector? It's
always really awkward when you ask the class for like questions, because it's usually obvious. And
then like, some people don't really want to answer anyway. And it's like, it's we are not going to
do this again, this was a mistake. Okay, negative one one, exactly. Because it's it's if we look at
the x axis here, this position on the x axis, lands on negative one, just like this position on the
x axis, landed at two, right? So now we're the coordinates of this one, it's going to be negative
one on the x axis. And then on the the y axis, it's going to land at one, just like the other one,
this one was also at one on the y axis, right? Cool. So this is the vector that we're working with.
So let's say we want to add these together. Adding vectors together is you kind of do it
exactly the same way as you would do with scalars or one dimensional vectors, but you do it for
each component separately. And Jesus Christ Photoshop does not want to cooperate today.
So one way to think about this visually is that, you know, how we sort of imagine taking an arrow
and putting it on the tip of the other arrow when adding? Well, we can do the same thing with this
one. And we can kind of take this arrow and put it on the tip over here. So that will give us this
arrow, right? I don't know how to draw straight lines. There we go. So we're going to draw straight
lines. There we go. So now we've moved this one over here, right? And what we end up with is that,
oh, this is called B, by the way. There we go, vector B. So we have a here, and then we're adding B
here. So where do we end up? Well, this is the point where we end up, right? Because we add this
vector, add this vector, this is where we end up. So what we what we get in the end is this vector
right here. Let's do it in different color, because I got a little confusing.
We end up with this vector. So this vector, the yellow one is a plus B, right?
And you can sort of one thing that's nice about looking at it this way, is that if you have some
value like a plus B, this is actually equal to B plus a. This might seem like it's kind of trivial
that well, of course, that's the case, right? Well, why would it not be? But remember that that's
not the case for like, if you have a minus B, that's not equal to B minus a, right? So it's not
always the case that if you flip the values, you get the same result, right? So it's really
important to keep in mind when things are, I always forget if it's commutative or which one is which.
There are terms for this. Anyway, so if we look at this, if we think about what we did here,
we have the vector a at the bottom, and then we added B to a, right? Because we added B here.
So if we just look at the geometric interpretation of this, we should get the same point if we do
B plus a, right? So if we try that, then we have the vector B. So now instead of moving B over here,
we can move a over here, right? So if we put a here, we end up at the same point.
It's the it's the same result, regardless of what order we do this in, right? Commutative. Okay,
people are confirming that it's called commutative. Good. Okay. Anyway, sometimes that's a useful term
to know. Like, it's the same thing for for scalars, a multiplied by B, it's the same thing as B
multiplied by a, but that doesn't always apply. In some cases, multiplication is not commutative.
So for instance, if you're working with matrices or quaternions, then multiplying those
is different depending on the order that you do it in. I think matrices are non commutative.
All right. Any questions so far? Is this clear how things work with something a little weird,
wonky? Then I guess you just ask questions at any time. I'm always up for answering questions.
So that's sort of how addition works, right? If we talk about, let's say subtraction,
let's see, I should probably undo a bunch of arrows.
All right. So as Steve is saying in the chat that I'm not supposed to read,
subtraction is addition in the wrong direction.
So just like we took one arrow, put it at the tip of the other arrow, subtraction is,
again, like we talked about before, subtraction is the same thing as addition, but we negate
one of them, right? And negate in this case, well, we were thinking about like one-dimensional
numbers before, right? We have a value of two, and then when negated, we're going to get negative two,
right? And if we have negative two and negate that, we're going to get two.
So negation is basically, we flip the arrow to the other side around the origin.
So in two dimensions, it's exactly the same thing. We could do it like per component,
we could think about like, what does it mean to negate the x-axis? Well, if we negate the,
or we've negated the y-component of this one, we're going to get this vector, and then we negate
the x-component, which used to be two, and then it's going to flip to negative two, right?
But an easier way of thinking about it is you just flip the arrow to point in the opposite
direction, right? So if we negate this vector, then we're going to get this vector, right?
Which is the same thing as just negating these individually. So we could just copy those,
move them over, and then there are negative one and negative two, right?
So now, if we want to, if we want to subtract something, if we wanted to b minus a,
then then we add these two vectors, or we do this one minus this one, right? So if we do
b minus a, then we basically take this vector, and we add this vector,
and then that's going to land us over here, right? And then if we did this in the opposite
direction, if we flipped it, because remember, when we did addition, flipping them had the,
gave the same result, right? But in this case, it won't, right? If we do, so this point right here,
this is b minus a, right? If we do a minus b, then we would, we can imagine a, and then we
subtract this vector, and that would get us over here, right? So over here, we have a minus b.
So here we can see that subtracting is not commutative. If we flip the order,
we're going to get different results, right? Okay, so if we do b minus a, in this case,
we're going to get this vector right here. So this yellow line going all the way here.
So one thing that is, that is really, really important and crucial to know about doing
subtraction between vectors is that this vector right here is the difference between,
between the two points, right? So, so this yellow vector is the same vector
as this yellow vector, right? We've just moved it to a different place. So if we want to know,
like, what is the, again, the difference between the points a and the point b, then
that gives us this result, which in this case, this would be a 2D vector still,
but the y component happens to be zero, right? So on the x-axis, we have negative 3,
and on the y-axis, we have zero. So that's what, that's the, that's the difference between,
that's b minus a, right? And if you want, you can still do, do this component wise. If you want
to do b minus a, you could do negative 1 minus 2 gives us 3, right? You can do 1 minus 1,
gives us zero. So you could do it component wise as well. Okay. So with subtraction, they become
each other's inverse values then. Not really, I guess it depends on what you mean by the inverse
values. And they also don't become the distance from one to the other. The distance is a separate
concept because the distance is a scalar. But if you subtract two vectors, you're going to get
another vector, right? So the vector is a difference between a and b, right? So this is b minus a,
and this again is a vector, right? We're going to talk about distance soon, right? So all we're
doing here is we're doing b minus a, right? Better described as an offset. Technically,
it's called a displacement, or usually a displacement is used when it's like over time,
I think. But yeah, anyway, so it's important to remember that this vector, the way we want
to interpret this, if this is the difference between b and a, is that this is not a position,
right? Now, vectors don't inherently have a property that makes them a position or makes
them a direction or makes them a quote unquote vector. But we need to interpret things, right?
And that is super important to know what each vector represents, right? So if we have this
vector, negative three and zero, it's more helpful to visualize it as an arrow between a and b.
But the actual values is negative three and zero on the y-axis, right? So it's really important to
interpret this in the correct way. And also, when you're writing code,
make sure that you're actually clear about what this is, right? If you want to keep this vector
for something, call it b to a, or call it the difference between something or the delta or
whatever. But if you just have a vector, then you're not entirely sure, like, should we interpret
this as a position? Should we interpret it as a position relative to a, which we are in this case?
And so forth, right? Yeah, so this is like a very crucial concept. It's very important.
Once we're getting into using different spaces. So when you're doing a lot of things in GameDive,
the difference between local space, world space, and all of that stuff is really important.
So you need to keep track of like, you know, if you have a vector like this on its own,
this one doesn't say if this is in local space, if it's in world space, if it's relative to some
other point, or like how this is used, right? So always be like very careful, like how you
name your variables when it comes to this. So like the, so this is something that I hate math for.
Math is so bad at this math notation, generally is really garbage, because they like, there's
so much stuff that's very implicit and like notationally ambiguous. But in code, we can
actually name variables, we can make functions that are very clear what they're doing. So in code,
you can be very explicit. And I think that's really good, because math is unreadable sometimes.
Yeah, in math, you would have things like, well, if you have V,
then you need to restart document again and Photoshop. Thanks Photoshop.
So sometimes you will have papers. This is an actual case, by the way, where like,
V means one thing. This is bold, but then you have a non bold V, that means a different thing.
And then you have a cursive V, that means something else, like, this is bad, like,
don't do this. I hate it, that like math papers actually do this kind of garbage. So like,
you will run into this, especially if you're like, reading shader papers or whatever,
that kind of stuff is really frustrating. Yeah, so so math notation usually rely on these types
of things. And it's really annoying. But in code, be explicit, be very like clear with what everything
is. Have variable names that make sense and so forth, right? Yeah, and then you would have
things like, Oh, if it's bold, this is a vector. But we don't draw the vector arrow, because we're
just going to presume that people are know, know that this is a vector now. And if it's cursive,
it's a scalar value, this is a component of the vector, whatever, it's frustrating. Anyway,
stuff like this is why I don't call myself a mathematician, because I kind of hate math
notation. And I also don't know much math outside of GameDive. Oh, speaking of which,
if there's ever something where you are like, when is this going to be useful? Or what is the
point of this? Ask, just ask. Everything I'm going to talk about is useful for game development.
None of this is going to be like esoteric, unusual, just bad things, right? So don't be afraid to ask,
like, when am I going to use this? Or can I order fries with trigonometry or that type of stuff,
right? Just feel free to ask questions. In my experience, vector math is probably 50% of
gameplay programming. Yes, pretty much. Like it's like, again, people ask me many times, like,
do I need to know a lot of math to do game development? I'm just like, no, not really,
you need like vector math, trigonometry, matrices help. And then you need to know how to manipulate
values, like remapping ranges, doing oscillation, that kind of stuff. But usually, it's, you don't
need that much. Anyway, I'm going to take a picture of this and send it to the students in case people
want to keep this beautiful piece of art. What does orthogonal mean? That they are 90 degrees
off of each other. Have you ever worked in non Euclidean geometry or altered space in
any of the games that you've made? Not really. No, I guess there are like, there are matters
of like, interpretation, right? I mean, if you want to call polar coordinates non Euclidean,
then yes. But usually outside of that, no, I haven't done a lot of that. Mostly because I like,
I don't know, it's like, seems like it might be fun, like experimentally, but I don't think I'm
going to actually like, make a game out of it. But it seems like it might be fun to like, try those
things.
The most interesting math problem I had in Game Dev is trying to forecast the path of certain
projectiles. That is a thing we're going to talk about, like ballistic trajectories for
a game dev math course. This is a vector. It's like two numbers stacked together,
twitch at Lawrence transform. Yeah. Yeah. Last time I did a math course on Twitch,
there was someone who was like an actual mathematician. And every time I brought up a concept,
they would like bring up the incredibly esoteric, like really complicated, generalized concept in
math with like really complicated words. And I'm like, this is not the time. I don't even know
what those things are. Jill, I'm not going to be able to explain, I don't know, lie groups and
algebraic rings to students. It's amazing how people can understand esoteric concepts in math
but not regular social norms kind of yet. Well, but they are separate skills. So, you know,
that's how it goes. Okay, so we talked about these things, right? We talked about the sign
of a value, talked about the, the length or the magnitude of a value, talked about the
distance between two values. All of these concepts also generalize to 2d and any other
numbers of dimensions you want to use. So it works for 2d, 3d, 45d, however many dimensions
your game is in, right? Okay, so, so let's, let's, let's see what these would mean in 2d, right?
So let's bring back some vector. Let's see. See we do this one, you know, drawing straight lines
is one of the hardest things in art. There we go, nailed it. All right, so now we have a vector.
Cool. So the components of this vector, again, we can look at the the axes here for the x and the
y components. And then we can see that the x component is three. So this would be three.
And the y component is two. Cool. So now we have our vector. Also didn't really
want to draw all of this. All right, so now we have a two dimensional vector again,
two values, one for the x axis, and one for the y axis. All right, so we talked about the,
the, the sign of the, of the value, right? So if we have, if we have a negative five,
for instance, the sign of this is going to be a negative one. The sign of a value like two is
going to be one. So, so basically, what this kind of represents is, because again, we are on the
number line, right? And we have zero somewhere. So what the sign kind of is, is that it can only
be either one or negative one. So turn to think of if I should call these these unit vectors,
one dimensional unit vectors, which is a little bit of a curse term. But if you talk about unit
vectors, that means that you have a vector that has a length of one, and both of these have a
length of one, right? So, so what this means is that the, when we do the sign of something,
we get the direction, right? We get the direction for if it's, if it's going on the negative
direction on the axis, or we get the direction pointing in the positive direction of this axis,
right? So what, what the sign kind of what it really does is that it gives us a direction,
usually direction vector. Okay, so what does that mean? In this case, well, we talked about,
I mentioned unit vectors. So a unit vector is a vector that has a length of one,
which both of these have, right? Even though they're one dimensional vectors,
they do both have a length of one, because this distance right here is one. This distance right
here is also one, right? So one way of representing something that has the same distance is usually
using circles. But in one dimension, we can't really do circles. So let's go to two dimensions.
So now that we have two dimensions, basically, oh God, I need to draw a circle.
Drawing circles is hard. You know what? There are tools for this. Let's do a, let's cheat.
There we go. What a beautiful circle. Okay, is that visible on stream or is it too faint?
I think it's, it's good, right? Okay, so so all the, all the vectors that are pointing towards
the boundary of the circle. So if you have a vector pointing here, then this has a length of one,
right? This vector also has a length of one. If you just measure the length along this arrow,
it's one. So what this means is that all the vectors that end up on the
boundary of the circles are all unit vectors, right? So when we talk about unit vectors,
quite often they're referred to as directions. So directions are always unit vectors.
So, so if we want to know the direction of this one, all we were doing is that we're kind of
making it the length of one. So, so this vector right here is the direction of this vector,
right? And what, what this is called the process of making a vector the length of one is called
normalization. So normalization.
Eyes were inconsistent. There we go. So the process of making a vector normalized or the
length of one is normalization. So this vector right here is the normalized version of this
vector. And this concept is also very important. Like this is super, super useful in so many
different ways. Yeah, this is, this is like ubiquitous whenever you're dealing with,
you know, dealing with vector math in terms of positions of objects, the relation to each other,
the direction to some other objects and so forth, right? All right, so let's erase this confusing
arrow. So, so this is a normalized vector, right? So, so that is the direction, right?
In one dimension, the vector could only have two states, right? It could either be negative one,
or it could be one, right? These are the only two states that are valid for a normalized one
dimensional vector, right? But for a two dimensional vector, we have an infinite number of points,
right? This circle can can fit so many points, the slaps roof of circle, there's something.
So like any of these vectors would be a normalized vector and all of them have a length of one,
right? Yeah, so so normalized vectors means that it has a length of one, that that's kind of it.
So when you talk about normalizing vectors, so let's say this whole vector is called V.
If you want to normalize it and math notation, you will usually see it with two vertical bars
like this. So this usually means the, well, actually, this could be the length of it. Sorry,
if you have V, and then a little hat on top of it, this is a normalized vector. If you have bars on
the side, that's usually the length of it. Sometimes you'll see two bars on the side because
nothing is consistent and everything is garbage. But yeah, so usually, this would be the direction
and this would be the length or magnitude, same word. All right, so this is just the math
notation garbage. I'm pretty sure this is correct. I don't, I feel like I have to relearn it every
time I read a math paper. So so we might wonder like how do you get a normalized vector, right?
How do you go from V to the normalized version of V or the direction of V? Kind of use those
like interchangeably, right? So this little vector down here would be the normalized version of V
with a little hat on top. But basically the direction of V. Okay, so we're going to talk
about how to normalize a vector. So I didn't quite get the normalization. So basically,
if you have any vector, pick up any points on over here, then you're just going to be a line
from zero, right? And if you want to normalize this vector, what that means is that you make
the length of one. So what you get out of it is a vector pointing in the same direction,
but it's got a length of one, right? So it used to be this old vector. But if you normalize it,
it's going to shrink down into a length of one. Or if you pick a vector that is that is a length
that's smaller than one, this vector is going to normalize into being longer all the way out here.
So so basically, you can sort of consider it to be a way from going from a point to an arrow that
represents the direction to that point. Yeah, when do you usually need to normalize a vector?
So the concept of a direction is really important. So so say you have say you have an object that is
over here. Let's say maybe this is an enemy, like at this location. And then you want to know that
maybe the player is at zero. And you want to know what is the direction that you need to move in
order to move towards the enemy. So if you are dealing with like physics or something, and you
want to add the vector to move toward the enemy, then usually you want to move at it like a fixed
rate in terms of speed, right? So what you usually do then is you normalize the vector between the
player and the enemy. And then you have a normalized vector, which again, that's a direction usually
in terms of terminology. And then once you have a normalized vector, if you multiply that by
your speed, or some value that represents how much you want to move in that direction,
you can guarantee that that's going to be in, you know, meters per second, or that that distance
is going to be in meters, because the length is one, right? So that means that you get consistent
movement in in space. And what's the difference between you do is normalize method and normalized.
Yeah, the dot normalize will modify the original one, whereas the other one returns a vector.
Okay, did that make sense? So basically, pick any point normalizing it means you get the direction
to that point. And a direction in this case, I'm using the word direction to be interchangeable
with a vector with a length of one, right? But it's still pointing towards that point, right?
Like I mentioned before, one of one of the powers, the powerful things about having normalized
vectors is that, let's see if I can undo a bunch of things. So so if you have a direction like this,
you can multiply a vector with a scalar as in a a single value. So if you have a vector, again,
usually when people say vector that mean multiple components rather than one. But if you have a
two dimensional vector, you can multiply that by two, for instance, or like some some number.
But if you have the normalized vector, so let's say we have our our vector that's normalized,
it's the same thing as this one. And then we we multiply that by a value of two, let's pick two.
What that means is that the new vector we are getting out of this, that is going to be
the direction along V right here. But the length of it is going to be two. So this is kind of what
is absolutely like extremely useful about normalized vectors. Because if you want to move
like you like two units towards something, then having a normalized vector means that you can get
a position that's exactly like some number away from some point. So if you normalize a vector
multiplied by a distance, then you're going to make the length of that vector the value you're
multiplying it with. And it might seem like that's not that's kind of trivial. But that's not the case
with this vector, right? If you multiply this by two, then at the length of it is going to be
like all the way over here, right? So the length of this is definitely not two, right? It's way
longer. So so this is why normalized vectors are extremely useful. Because of the fact that the
length is one, if we multiply it by some scalar, the length is going to be that scalar, right?
Yeah. So that's something that's useful when it comes to this. So like I mentioned before,
it's useful in physics, for instance. So if you have the normalized vector, then if you want to
move something along this vector, then well, what you can do then is that you could have a time
multiplied by your speed, for instance. So time multiplied by speed. So now we're just
multiplying all of these together. So what that means that if time is a value that is ticking
in seconds, when you start the game, time goes from zero to whatever the current second is,
then you're going to have an object that moves along this vector at the speed you give here.
We're going to go into more physics stuff later. But so this is just one of the really,
really powerful things about having normalized vectors, right? Can you show an example in Unity?
Yeah, sure. Do people want to see examples of this? Show examples in Unreal? Nope. I think showing
it in practice is really, really good because you're going to work in Unity. So why not?
All right, let's nuke some objects. There we go. Let's go 2D because we're not into 3D yet.
That's great. Will the game crash if it runs for more seconds than the float 32-bit limit?
You're going to have to run the game a very long time. It's not going to crash. It's just
that your equations are going to get a hitch and a weird thing that's going to happen once it goes
over the limit. I don't think it's going to crash. You're just going to have very weird behavior
as soon as you hit that point. Okay, let's see.
All right.
I probably should have done code examples earlier actually because, again, I like keeping things
very pragmatic and practical. Okay, let's just do some of the things we've done here,
just to show how it works. I usually really like using onDragismos because you can see it in the
editor. You can very easily draw lines and whatnot. So onDragismos is a special function
in Unity that is called in the editor, and you could optionally enable it in the game view as
well, where you can draw lines and whatever. So you can do stuff like gismos, draw line,
and then you can supply some positions, right? So we do
something like that. Then we go back to Unity. We now draw a beautiful tiny little white line,
right? Cool. Oh, wow. I wonder if there's a vector
graphics package you can get. Okay, so draw line, just a very simple one. But we probably want to
be able to supply some other points. I do have to wrap onDragismos and if Unity Editor. I'm pretty
sure that's going to get stripped for our builds, but I could be wrong. Sometimes you use methods in
there that are only in the editor namespaces and whatnot. But if you use handles, for instance,
but gismos, it ignores that, I'm pretty sure. Yeah, I'm pretty sure you don't need to strip it.
It's not going to, maybe the code in here will be part of the assembly. I'm not sure,
but at the very least, it's not going to get called regardless.
Okay. All right, so we probably want to be able to pass a vector into this or a
point or whatever, right? So instead of just hard coding in here, we can add a property.
Or in my case, I'm just going to pass in a transform because it's easier to move it around.
Let's call it point transform. Let's make a new game object.
Actually, because since we're drawing all of this in world space, we can just use this transform.
All right, let's pass point into there.
All right. So now we were drawing a line between zero and this transform, right?
So now we're basically just taking the position of this transform and we're drawing a line to it,
right? So again, we can think of this as the two normal lines we had where this is the origin,
and then we have the x-axis and the y-axis right here.
Oh, you couldn't hear the discord?
You should have been. It might have been a lower volume.
All right. So now we have the points, right? So now let's say we want to get the direction
to this point because we have been talking a lot about directions, right? So let's get that.
So direction to points. So in this case, because it's originating from zero,
and we just want the direction to this arrow, then all we need to do is normalize that point,
right? And Unity has a bunch of built-in functions. You can do point dot normalized,
and that's going to return a normalized version of this point, right?
So, yeah. So now we have the direction to the point. And again, I'm using the word direction to
mean a vector of length one, which is sometimes also called unit vector, normalized vector.
Like it has a bunch of terms, but usually when I use the word direction, I mean a normalized vector,
just to clarify. Okay. So if we draw that instead, and then go back to Unity,
now this line always has a length of one, right? It doesn't matter how far away the transform is,
but the length of it is also one, even if it's shorter or longer, it's going to normalize it to
always be unit length. So now it's sort of tracing the outline of what's called the unit circle.
So the unit circle is just all the points of the vectors that have a length of one. So it's
this circle right here, right? So now we have a direction, right? What have you said that transformed
to zero? So probably now it gets very sad because the, I'm pretty sure normalized, it looks like
it's just returning a zero vector. So now that the quote-unquote direction that this returns is
going to be zero. So it's trying to draw a point from, or a line from zero to zero. So speaking
about that, this is a very good case where when you have something like this, this is actually
division by zero, like technically, we're going to get into how to calculate the length or how
to calculate the normalized vector it's later. But this is actually division by zero. And something
that is kind of beautiful in mathematics is that anytime you are dividing by zero, I think this
is like so mind-blowing, but like every time you're dividing by zero in some equation, that is kind
of the math talking back to you, saying that like, hey, this is a weird case, you need to handle this
case, something is happening here, and you need to think about what do you actually want to happen
in this case? Because it's kind of telling you that there is a degenerate case or a case that
you cannot calculate, because division by zero is undefined. So whenever you have an equation
where there is a divide line, think about if the denominator can ever be zero. If it can be zero,
figure out what that means, right? Like when would this be zero? Anyway, okay, so now we're
just drawing the normalized version of this vector. Do you have a course that you don't need? No, but
I have my YouTube channel, which is free, so you don't have to be afraid. Right, cool. Okay, so let's
talk about the length, because we've sort of mentioned the length a lot when it comes to
normalizing things. We probably should have talked about length before normalization, but you know
what, that's okay. All right, so let's talk about length. How do you get the length of the vector,
right? I might be skipping ahead, but when you say the vector two dot normalized divides by zero,
where does it do that? You're sort of skipping ahead, I'll get to that. But technically,
unity's vector two dot normalized handles that case and just returns a zero vector,
instead of, you know, crapping out and not knowing what to do. You could sort of make a
normalized function that just throws an exception, which might be useful. But unity's normalized
just kind of just returns a zero vector. Oh, a zero vector is just a vector with components at zero.
So all of the components are zero, sometimes called a zero vector. Yeah, okay. So we talked
about normalization, but not how to calculate it, like how do you normalize the vector? Like,
how do you go from this to whatever the heck these coordinates are, right?
All right, so if there is, I don't know if we should use this vector, let's do another vector.
Let's do this one.
What a vector, it's a little curved, but pretend it's not. All right, so let's see, what is this,
what is this vector? So we have x coordinate, we have negative two, y coordinate, we have three,
right? So this is our vector. So now I want to know the length of this, like how do we do that?
So now this is going to get into the hacking Pythagorean theorem, right? Because if you think
about it, if you want to get the length of this, you can sort of imagine a triangle here. And this
is a right angle triangle. And this is something that is taught in math class. So if you remember
how to get the length of the hypotenuse, then you know how to get the length of a vector, right?
So so basically what we need to do then is we take the x component, square that,
and then we add the y component and square that. And then we take the square root of all of this.
There we go. That's the Pythagorean theorem. That's how you get the the hypotenuse of a right
angle triangle, right? But this is this is how you get the length of a vector, right? Is that
clear by the way? We haven't talked about like exponents or what it means for something to be
squared or talked about square roots, but I'm guessing we don't need to talk about that or
but if not, let me know we can talk about it. Okay, so so this is basically how you get the
length of a vector. All right, that's it, I think. So now we've been talking about we talked about
for one dimensional numbers, and we had abs instead of something else. But the generalized
concepts, you usually write it like this for any other vectors, you can add more components inside
of the square root, you can add, you know, z q or z squared, and then you have the length of a
three dimensional vector. So, so it's the same thing, like regardless of how many dimensions
we have, right? And this actually holds even for one dimensional vector. So, you know, we talked
about one dimensional vectors, where you can use the abs function, which is basically just if it's
negative, make it positive. But you can do this for one dimensional vectors too. So if you have
the square root, and let's say we have the the the one component of negative five, for instance.
So, all right, so let's just do the equation for that, right? We do the square root of five
squared. So that's five, five times five, right? Which is 25, I think, I don't know, pretty sure.
So that's 25, right? Oh, actually, sorry, not five times five, a negative five times negative five.
If you multiply two negative numbers, then it's going to be positive in the end, because the
sign sort of cancel out, right? So we get positive 25. And then when we do the square root of that,
by convention, square roots technically have two results, but we're not going to get into that.
So technically, this then returns five, because the square root of 25 is five, the equal sign
is incorrect. Yes, because this is the length of that, sorry, length of negative five, then just
ends up being five, because that's what the square root then returns, right? So yeah. So it's just
kind of like the same equation works for any vectors. Now in practice, when you want to get the
length of, you know, want to get the length of a weight, are you getting notification sounds?
I think I'm just getting it locally. So so when you want to get the length of a vector for one
dimensional vectors or just scalar values, usually use abs, you don't actually do the
full equation. But for anything, like any dimensions about that, you generally use the
Pythagorean theorem. Okay. So this works for for two dimensional vectors too.
Oh, actually didn't. Sorry, legs. You know, I actually have a cold right now. So this is like
canonically kind of more accurate, but sorry. Sometimes my backwards writing doesn't work.
Okay, cool. So now we have that, right? Now we can actually do that math. So
so if we want to get the length of this one, we can just just do that, right? So that's negative
two times negative two, plus three times three. And then we do the square root of that.
This is not a good looking square. Where's my good color? There we go. So then we can just run
these numbers, right? So all right, we do square negative two times negative two, pretty sure that's
four. So it's going to be four plus three times three, that would be nine. So four plus nine,
which is, oh, God, that's 13, I think. Look, again, I'm really bad at doing math in my head.
Pretty sure that's 13. All right, so it's no longer really tied to the x or y axis. I guess
we can make it blue or something. So that becomes 13. And then we want to calculate that. So that's
when you pull out the calculator. And you type 13, and then you do the square root of that. And it
turns out it's 3.6 something, right? So this is approximately equal to 3.6. Sorry, maybe we will
do it in blue. Why not? Cool. So that's how you get the length. So now what this value represents
is the length of this right here, right? The full length of this vector turns out to be
3.6 something something, right? So now we know the length of it, right? Cool. That's how we do it.
If you want to get the, like, if you want to do this in practice, you almost never write this
formula yourself. And so if you go to Unity, if you want to get the length of the points or the
vector, again, length is a scalar, it's just a single value. So the length of this one would be
point dot magnitude, because again, magnitude and length, same thing.
Yeah. So this is how you get the length. Sometimes it can be useful to calculate the
length manually, because sometimes you want both the length and the normalized vector,
and in that case, calculating things manually can be really useful. Cool. Everything clear so far.
How to get the length of a vector. So now we've just talked about how to get the length,
but not how to get the direction or sign and not how to get the distance. Okay, let's do the
distance. So the distance, now that we know how to get the length of something. Now, if we get the
difference vector or the displacement between two vectors, let's say we want to get this vector
between these two right here, then this vector, this would be, we don't have names for these,
let's call it A and V, there we go. So in this case, this vector right here would be A minus V,
A minus V. So now we have the difference between these two points. So if we want to get the length
or the distance between these two vectors, all we need to do is get the length of this vector,
because if we know how to get the length of this, then we now know the distance between
these two points. And in this case, it also doesn't actually matter if we do V minus A or
A minus V, because if we're just interested in the distance, the distance is always positive,
so it doesn't matter which order we do this in. So if you want to get the distance between
two points, previously we did the absolute value because that's how we did the distance in
one dimension. Actually, we didn't, we never call it length. Anyway, so this is how you do the length,
so we can basically just replace this by calling it length instead, right?
So now we have the, now we can get the length of this one, and the way to get the length
is this one right here, right? There we go.
Cool. All right, so basically, this is how you get the length. If you want to get the
distance between two points, then you subtract the points, one subtracted by the other,
and then you get the length of that vector, and then you get a distance.
So there is a slight difference in terms of interpretation between distance and length.
As a distance, usually is between two points, and length is usually the length of one point,
or the length of the vector that represents that one point. So when we want to get the
distance between this point and this point, we first subtract them from each other to get
the difference vector, and then we check the length of that difference vector. All right, so now
we have a way of getting the length, we have a way of getting the distance,
have we clarified that the resulting blue vector is still centered on the origin?
We talked about that, yeah, like vectors don't have a root and a tip, it's only the vector data
itself, right? So we talked about that when we talked about subtraction, that if you want to
draw it at its origin, it would be this vector, right? Length, magnitude is of the vector,
distance is between two vectors, generally, yeah. So when you talk about distance,
that's a special case where you want to know how long is the vector that is the displacement
between these two points, basically. So when you talk about distance, again, distance has an input
of two points usually, and then you get the difference of those two points and get the
length of that. If you want to know the length of something, it's just one input, right? So that's
just the length of one vector. Yeah, of course, there are built-in helpers for this, you don't
have to do it manually. So if you want to know the distance between two points, you can use vector
two dot distance from A to B, or DB null, I guess. So this would give you the distance,
but you can do it the other way around, too. You could do
A minus B dot magnitude, for instance. This would also give you the distance,
it's the same thing, right? Or you could do the manual way, if you want to,
of doing A minus B, like A dot X minus B dot X, and then you square that,
and then you add the same thing, but for the white component,
and then you do the square root of all of that. So this is the same thing. This is also a way you
can get the magnitude, or the distance between two points, right? Yeah, just different levels
of abstraction, I guess. How to apply it in practice? Well, we could make two points.
All right, let's make A green, B red.
Now we have two points, right? What a good pair of points.
Okay, let's say you want to know the distance between these two, right? First,
we need the actual points, because we only have transforms here. So it would be, oh, I need to
probably assign them in the inspector. Dude, there we go. So now we have, let's say we just
just call them A, so that's going to be A, transform dot position, then we do the same thing for
B. So now we have the two points, A and B, and again, we can draw lines to make sure that this
is working. Right, I'm not using my library. Gizmos, draw line from A to B. There we go,
cool. So now there should be a line between these two points, so we can move them around. We now have,
yeah, what a good line, right? But we want to know the distance of that. So if we want to know
the distance, I guess we can print it in the inspector or something. So if we want to know
the distance, then again, we can use everything we typed here, right? So we can do vector two dot
distance. And now we should set this value right here. It might be hard to see it in the inspector,
but there's a little value there. There's updating. Now it's 0.45. Now it's 1.9 and so far. So now we
actually have the distance right there. Yeah, so that's how you use it in practice. And again,
the distance value is going to be exactly the same thing if we do A minus V dot magnitude.
So we can compile this. It's going to work. And yeah, still have the same distance. Any other
questions before lunch? Any thoughts? How to make a game like Angry Birds? I can't answer that. That's
a very long question and a whole production pipeline. Start doing things. That's how we make
games. Generally speaking, no one's going to get mad at you for doing A minus V dot magnitude
instead of vector two dot distance. I don't think so. I mean, the first one might be slightly more
esoteric because you sort of need to know the underlying math for that to be readable. But I
think the, I mean, most people should know about that. It's a very important concept. Like vector
two dot distance, the nice thing about using that one is that you're being very explicit that you
literally want the distance between two points. If you use the A minus V dot magnitude, it's a
little unclear, like you get the length of the difference between these two. But like, are we
going to, is that interpreted as a distance? Maybe these aren't points. Maybe this is something else.
So, you know, sometimes it's useful to like use the one that literally says distance,
because it's very clear that you kind of want a distance, right? And conversely, if you don't want,
if you want to do the same math as this, but it's not a distance value, then using vector two dot
distance is likely going to be more confusing than useful, right? So it kind of depends on the
context. I personally really like doing, like being explicit and clear with my code. Hugo,
you're spoiling it. I haven't gotten to that yet. But yeah, actually, let's use, let's use, we can
just talk about that. But that's the last thing before lunch. Okay, so we talked about the,
we have this line right here, right? The, the one that's pointing in the direction of the,
this transform, right? So what this one is that is the normalized version of that point,
like this is, this is the only thing we've done there. So, so the way to calculate a normalized
point. So instead of just doing dot normalized, we can do the point, and then we divide it by the
length of that point, right? So point dot magnitude. So this is how you normalize a vector. So by
dividing it by the length, the, the length becomes one, right? Yeah. So, so that's how you normalize
a vector. I previously talked about the fact that there was a degenerate case, where you're
dividing by zero. And if you look at this equation, you can probably tell what the, what the degenerate
case is, right? Because point stop magnitude can be zero. So what that means is that point is at zero.
So if you have a point that's at zero, and your goal is that you want to get the direction
that this point has from the origin. But if the magnitude is zero, then you're dividing by zero.
So now, again, math is telling you that something is messed up, and you need to think about what you
actually want to do here. So what this means is that you're trying to figure out a direction
of a vector that doesn't have a direction, it's zero, it doesn't point anywhere, right?
So, so usually in these cases, you need to figure out, okay, what do I do to handle this
special case? If it's at zero, do we want to fall back to just using zero? Do we want to check if
the length is zero and then not draw it or not execute some piece of code? Usually it's, it's
really like, every time you see a division operator, really useful to think about if the
denominator can ever be zero, if it can, then that means that you have an interesting case to solve.
Yeah. All right, I think that's it for lunch. Yeah, we're going to talk about the square
magnitude stuff that you're talking about in the, like after the break. And yes, doing square
magnitude is faster. Yes. I think there are some intricacies of like, the property call itself has
some weird overhead. But if you manually do the square magnitude, it's like way faster than
actually doing magnitude. So I've heard. But that's not for mathematical reasons. That's for silly
overhead reasons. Actually, we should do a, we should do a lunch break. Okay, I'm just,
there's no audio in the lunch break room. So, so yeah, I'm just going to place an image here.
See you soon. See you after lunch. Look at that little boy sleeping in the goblet. These are
peaceful little cat now. Where were we? Oh, we just covered how to actually normalize vectors,
how to do that, right? Not just in terms of what it is, how to do it using Unity's helper,
but how to actually do it yourself, right? Okay. What's the state of things?
So we have our code and we were just showing directions, right? Okay. All right. So, so here's,
here's a short little exercise that we can think about together. So, so for instance,
now we have these two points, right? Previously, when we looked at direction here,
this is the direction of the point itself in world space, right? Like this one is,
it's just a line drawn from zero in the world, and then out to one distance away from the center
in the direction of this point that we move around, right? So,
but yeah, so let's say we wanted to draw the direction between these two points. Let's say
we want to do direction from, from A to B. So, so let's do that. Let's just figure out how to do
that, right? So, we're going to ignore the center points. Let's just hide those. Let's forget all
about this. Let's, let's forget about this too. Forget about everything. You have learned nothing
so far. Okay. So now we are drawing a line between A and B, right? So now should just keep this line.
So now the goal is that we want the direction from A, the green point to B, the red point.
So, so we want that arrow, right? So, so how do we get a direction between two points? Well,
the first thing we need to do is to get the difference between these two points, right?
So if we take one point and subtract it by the other, we get the vector going from one to the
other, right? So that's something we talked about earlier. Like the, we have the two points here,
both of these, sorry, my desk layout is not in tablet mode. So we have this point and we have
this point. And then we want to get the direction between these two points. But first, in order
to get the direction, we need this blue vector right here, right? So all we need to do is subtract
one from the other. The order in which we do the subtraction will change the direction that the
arrow is pointing, right? So usually, you can go either way, depending on how you do the subtraction.
So, so generally, it's kind of annoying that if you have, if you have two points, like you have
A and you have B, and you want to get the direction from A to B, the way you do that is B minus A.
And it's kind of annoying that this is the order that you do it, because it feels like you kind
of want to have the A first. But I kind of just have this mental model of you always have to like
flip them if you want to get from A to B. So, yeah, so it's always like the, the two points
minus the from points. So then from this to this in terms of like direction.
Okay, so that's all we need to do to get that vector, right? So let's let's do that vector. So
that's going to be called A to B. And that's going to be B minus A. So now we have the vector going
from A to B, right? All right. So now that we have that vector, what happens if we draw that one?
Well, we can try it out, right, draw it from zero to that vector. So now we're just going to
visualize the raw vector, right? So if we do that, it's now going to draw at the origin,
right? Because the vector itself doesn't have a root of the arrow, right? So it doesn't really care
about the location where we did this calculation. But it is getting the correct vector, like this
is the vector going from, from A to B, right? So so what we need to do now is that we just need
the direction, right? So we don't want the actual full vector, we want this to have a length of one.
So if we want a direction vector, we would need to normalize this, right? So so let's make the
direction. So A to B direction. So then we can do A to B dot normalized. And then we can draw
the direction. So now this one is always going to have a length of one. So it doesn't matter
how far apart they are. But we do have the direction, right? We can move either of these
points and the direction is still going to be correct. Okay, so far so good. But now we, we
probably want to draw this one at the correct location, because it's kind of confusing that it's
down here, like the direction is correct. But the visualization of this vector is kind of offset.
We kind of want to see it here, right? Like we want to see it go from the green point to the red
point. Okay, so, so we need to move this vector, we also need to hide this line, because that line
is going to be covering up a bunch of stuff that we want to see. So let's first hide that line.
And then we want to move this vector. So draw line is you supply two points in it, right?
And the first point is A, because we want to originate this line from A. So we can just pass the
point A into that one. And then in order to make the this be relative to A, all we have to do is
add A, because then we're going to move it up by this vector going from zero to A, right? Because
that's what A is. The coordinate of A is a vector going from zero to A. So, so then we can do A plus
that direction. And then we recompile. It's not going to point toward the red point, right? And
so now you can start to see like, you can imagine these being units in a game, right? And you
need to point towards some target or whatever. And you need that direction somehow, then this is,
this is a way you can do that, right? Yeah. Although the this part is only for drawing purposes,
you already have the direction here. The only reason we had to do the A and A plus the direction
is to draw it at that location, right? But the direction itself is already done, because directions,
in terms of interpretation, direct directions should not be like, they don't really have a
position. It's just a direction, right? Yeah. Okay, did that make sense so far? If it didn't
have A plus, it would point to the location based on zero. Yeah, if this is just zero, or the, sorry,
a zero vector. Oh, it didn't. It was sad about that. If we just set this to vector two dot zero,
we remove that one, then it's going to be positioned at the origin, but it's going to have
the correct direction, right? So, so the direction is correct here.
Yeah, so, so kind of usually the, you only need this direction usually don't have to move it there,
we're only doing that for visualizing what's going on.
Okay, why are you doing A plus? Because we want to draw at that location, right?
So, so if we don't do a plus, it's going to draw the vector going from zero in the origin of the
world to the direction that the vector is pointing, right? But in our case, we want to draw it at the
location where it's relevant, right? So again, if we just do this, vector three dot zero,
recompile. So now it's going to be at the origin of the world, just at zero. So now we're kind of
showing the raw data of this vector. But in terms of like visualizing it, it's kind of like
annoying that it's at the origin, because if these things are very far away,
then we don't even see the origin, even though the direction here is correct. This is the direction
going from A to B, right? So, so the direction is correct. But just visualizing it, we need to
supply two points to draw it, right? With when we're using draw line. So, yeah. Oh, yeah, there is
also a draw ray one, if you want to use it, although I tend to not use that one. But yeah, so, so the,
the A here is just to offset everything so that it's positioned here instead, right? So, yeah.
So, so all we need to do to make this one positioned at A is that we add A. So zero plus A and A plus
A to B direction. And this is unnecessary. So we can just remove that. And then we have A
to A plus A to B direction. And then we get the, the two points, right? So what A plus A to B
direction is, is the point here. It's the end of this line right here. So that's what the second
point is. And this is where the first point is. So what this gives us is this point, which again,
goes from the origin all the way out to this tip, because depending on if we want to interpret it
as a vector or as a point, we can visualize it in different ways, right? But that's what that
returns. It gives us that point right there. What happens if you do draw line A, A to B direction?
I mean, it's just going to be confusing. There's no like, interpretation that that makes it,
that makes it useful sort of. Yeah, so there's not really much point of doing that. Although,
it is very common to sometimes forget to do things correctly. So sometimes you will see issues like
this, where you're kind of just confused about what's happening, right? Because this doesn't,
this doesn't look like a direction at all. This is, this does not have a length of one, right?
Yeah. Because then what we're doing is essentially, this point is originating at the correct location.
But this one would still be, if we didn't have A plus, it would still draw the end point at the
origin. So we need to move both the origin of the line and the endpoint of the line by A, right?
So that it's relative to A. Yeah, you're offsetting both end points or the starting point and the
endpoint with A. All right. So now, now we have a way of getting the direction between these two,
right? Let's see, there have been a few more things we talked about. So one of the more
useful things about directions is that we can very explicitly position things a fixed
distance along that line that is very easy to write. So, so let's say you have some, some float
value. Let's make it a range, actually, from zero to four. Let's call it offset. It's fine.
All right. So now we have a value called offset. Don't need AB distance anymore.
Okay. So let's say we want to draw a point between these two points. We want to want to draw it
along the line that goes here, right? And we want to set the distance away from the player.
So now we're going to call that offset. And we can do xmas.drawSphere. So just drawing little points.
So we want to draw that one at the location. So just to make sure that this works, we can try,
let's draw at the midpoint between these two. So if you want to get the midpoint or the average
of two points, as you would do with any other numbers, you do the same thing with vectors.
You add them together, and then you divide by the number of entries you have. So A plus B
divided by two gives you the average point of these two coordinates, right?
All right. So then we also need a radius. You can just make something pretty small.
Actually, that's being a bit more explicit. So midpoints equals that. There we go.
So now we want to draw a sphere at the midpoint between these two points.
All right. So we've got this gray little sphere, and it is right between these two points. Okay.
So now we've got this thing that we can draw. But we don't want to draw it at the midpoint.
So we want to draw it a fixed distance from the starting point toward the end point.
So if we want to do that, like I mentioned before, the fact that this direction is normalized
means that if we multiply it by some value, we know that the length of the resulting vector
is going to be that value. That's not true if it's not normalized. So this is kind of the
really, really powerful things about direction vectors, or unit vectors, normalized vectors,
same thing. It's the same word. Wait, different words, same concept.
So we have the direction here, and then we want to get a point along that, right?
So we can do atb direction, multiply that by our offset. So offset is the parameter that we can
tweak for the distance along this line. So let's call it offset vector. So now,
there we go. Sorry. So now we have the vector that is offset that it's going to move from this one
toward the red one. Now, same thing as before. If we just draw this one, it's again, this offset
vector is relative to the starting point. So if we just draw this vector, it's going to be drawn
at zero in world space, right? So we probably want to move that one. So we want to make sure
that it's relative to a, just for drawing purposes, right? So we add a to offset vector,
and then we can go back to unity. And now we can see that we have this sphere, and it's exactly one
one unit away from the starting point. And we can change this offset. So we set it to zero,
it's zero units. And we set it to two, it's exactly two units away. And unlike the midpoint
that we got before, this one doesn't like squash and stretch, it's always the exact same distance
away from the player, right? So what is the point of this? What's the use of this? Well,
if you imagine this offset being a time value, then we just created a projectile, right? This
thing is just moving at a fixed velocity, right? So now all of a sudden, we just have a very simple
formula, where if we increase offset over time, we have the flight path of, you know, an object in
motion. And all we've done is basically take the direction, multiply by the distance. And that's
it. If you increase the distance over time, then you have a moving object that's moving along that
direction vector, right? Okay, did that make sense? Anything that any questions or things that were
not very clear? Such a good way of explaining it. I wish I had this lecture three years ago,
you should be a teacher or something. I should be a teacher, you know,
if only I was a teacher. Yeah, okay. So yeah, so now that this is very much a,
like, this is very, very central and very core to working with vectors in in games. And the concept
of a normalized vector or a direction is super crucial to have a have a good understanding of.
I'm probably going to make that a very central part of all of the,
like, all of the assignments that you're getting, because this is extremely core.
Okay, let's see, where are we in the schedule? Oh, right.
Okay, maybe we should make more than one script, just to make sure that we're not
like cluttering this whole thing. I forgot my hotkey for disabling objects. There we go.
Let's make another script, just to like show more examples of like, why is this useful?
So let's say we want to make a radial trigger, like we have a trigger, and we want something
to happen by the distance to that thing, right? So let's create it there.
And then some objects, we can test the code.
Maybe this is a player. Maybe it's an enemy. Who knows?
All right. So we have an object now, and we have our trigger that is just nothing right now.
So let's go back to on drug is most again, because it's useful for just testing things very quickly.
There we go.
Okay. So let's see, well, what do we want to do in this trigger? For instance,
we might want to set a radius on this one, right? Like what is the threshold at which we want to
want this trigger to activate, right? So let's make another range from zero to four.
And then this is going to be the radius, and we default to one.
And then we probably want to draw this so that we can actually see what the radius is.
This is, by the way, something I talk about a lot when I have my tool dev courses on draw gizmos
to just visualize things like radius and whatnot. Super important and really good for level
designers so that they can actually see what the range is of everything, right? Otherwise,
everything is kind of like difficult to parse. All right, so let's draw this. We can do that with
gizmos, dot draw. Let's see, there are many functions here. We can do a draw wire sphere,
for instance. So wire is wireframe. Okay, I don't know. I think handles has a wire disk.
Maybe we should use that one instead. Okay. One thing to note, though, whenever you're using
handles, handles is in the editor namespace. So if you want to ship a game and you're using
handles in on draw gizmos, you have to make sure that you compile that out, right? So in this case,
if you're so soon as you're using handles, always make sure that you compile out the
code, right? Otherwise, you're going to get builders and that makes people sad.
Okay, so we're doing handles. Let's draw a disk. We want to draw this at the location of this trigger,
right? That's the wrong using. That is true. There we go. Unity editor is the one that should be
wrapped. All right, so we want to draw this wire disk. And let's see. We need a center point. So
the center point is going to be the location of this trigger, right? So it's going to be a transformed
opposition. Actually, let's abstract this a little bit more. So we have the origin of the trigger.
So that is just transformed opposition. So we're going to draw that there.
Normal. Okay, we need to supply a normal for the disk. We haven't really talked about 3D
vectors yet. We're going to get to that later and what normals are in general. But quickly,
if you imagine you have a plane, like not an airplane, just the physical plane,
then the normal is the direction that is pointing out from that plane. So my finger right now is
the normal of the plane of my hand, right? So that's the normal direction.
Or it's, there we go. Now we have a better, better normal direction, although
usually Z is the normal for surface. So the blue vector there is the normal of my hand.
So in order to draw a disk, what that means is that the normal of a disk makes the disk lie in
the plane of my hand if we supply the blue vector as the normal to this, right? But we're in 2D,
right? So in our case, our coordinate system
kind of looks like this, right? So we just need to supply the blue vector, which is the Z axis in
world space. So in this case, we're in 2D, we can just tip over our water bottles. So we can just
do vector three dot forward. This is equivalent to doing new vector three zero zero one. So this
is just a direction vector that is pointing in the Z axis, right? All right. And then then we have
the radius. So we want this radius to be the same as the radius of this trigger, right? Jesus Christ,
all of you want to have that my gizmo. I only have two and I hand made them. So I don't know how to
like sell them. Yeah. Anyway, so now now we've supplied a normal to this disk, we have a radius
and an origin. So now we should be able to see a wireframe ring around this trigger. Cool.
So now we, we cannot tweak the radius, right? We can change the radius and the ring will change
size. We can move this around and everything is working as expected, right? Okay, I 3D printed my gizmos
and then I painted them. That was my process. That's about it. Yeah, these, I have two.
They're very useful, especially when you get to talking about cross products. It's super good.
Do you have the schematics? I just made the 3D model at some point. I don't know.
It might actually be at my work computer at Necorp, but I could just remake the model or
whatever. It's not a very complicated model to make. All right. So now the question is,
how do we actually get the, like how do we know if we are inside of this trigger or outside of
this trigger, right? So now all of a sudden we have a math problem that goes through all of the
concepts we've been talking about, right? So we have, we have a point, this is going to be a player
or an enemy or anything else, right? And then we have the point that is the center of the
circular trigger. All right. So how do we solve this? Does anyone have any ideas in chat about
how to, how to do this? What are we going to do? Move it? All we need to, all we want to know
is whether or not this point is inside or outside the trigger. How do we know that? It's a Boolean
state, something we can put in an if statement, right? Check the distance between the two objects.
Yes. Okay. We have the distance. What do we then do? If it's greater than the radius, it's outside.
Yeah. Exactly. Physics dot overlap, that works for physics objects, but right now we're not using
any physics objects or colliders. All right. Cool. So let's do this again. How do we check
the distance between these two points? Well, we have the origin and then we have the object
position. Let's call it object position. That's object transform dot position. Okay. So now we
need to know the distance between these two. So distance equals, we can do vector two dot distance
between object position and the origin. So now we have a value for how far away is this object
from the trigger, right? But now we also need to know the state of whether or not it's inside or
outside the radius of the trigger, right? That's kind of what we're interested in.
Okay. So we'll have the distance and the radius. So all we need to do then is to, we can make a
Boolean state. So let's call it is inside. And the only case where this is inside is if the distance
is less than the radius of the trigger, right? So if the distance is less than the radius,
then it's inside. You can do less than or equal to implementation dependence depends on how you
want to do this. Yeah. So now we have a state for whether or not it's inside. And let's set the color
of the ring to be red if it's outside and green if it's inside. So handle stock color
is inside. And if it's inside, we want to do color dot green, green,
otherwise call it a red. So red outside, green inside.
And transform has not been assigned. So now we have a bunch of null refs,
because this is not serialized. So let's serialize it.
All right. Still null. There we go. Cool.
All right. So it's green. Move it outside. It's red. And it seems to be able to check this distance,
right? So as usual, you need to test things, make sure you can change the radius and it still works.
It seems like this. This is working. Was everything clear how this was set up?
Why it works and everything? Oh, what's the vector 001 needed for? Yeah, that's just because the
disk function is meant to be able to draw in 3D space. So this is just our way of telling it to,
we just want to draw on the xy plane, right? Because we set the normal of the disk to be on
the z axis, which means that the disk is going to traverse on the xy plane, right?
Why not use vector three forward? I mean, if I were to write this code, when I'm working on
something, I would write vector three forward, just for like, educational purposes, talking about
what like what this is, what it means, vector three forward is a little bit unclear, when I'm
teaching what vector threes are. So in this case, I just type vector three, because it's made things
a bit more clear in terms of what the underlying data is, right? But yeah, that's that was the only
reason. Yeah, but otherwise, this is equivalent to vector three forward, it's the same value, right?
The only reason that I that I sometimes don't do it is because transform dot forward is very much
not the same thing as vector three dot forward. So you need to like, keep in mind, what you mean
when you type the dot forward, and sometimes you can like, confuse the two. So yeah, so sometimes,
I think it's good to just, you know, write the whole vector out to clarify that this is just a
just a vector on its own, one more thing. So we talked about, we talked about how to get the
length of a vector, right? And if you recall, this is how you get the length of a vector, right?
So you have an x component of a vector, you square that, and then you add the y component
squared, and you take the square root out of that. It was the Pythagorean theorem that we
talked about earlier, that whenever you have a right angle triangle, you can get the length of
the hypotenuse using that formula, right, which is equivalent to asking what the length of a vector
is, right? Okay, so we got this, this formula, and we can use this to calculate the exact length
of a vector. If you're doing like, if this is in some sort of for loop, and also this person
Twitch chat is really annoying, can we just time out this person? There we go. Great. So, okay, so
if we can, we can use this distance value to check a threshold, just like we did here, right?
So if we, we can check if it's less than some value or greater than some value, right?
So if you are doing some code that is like iterating over 600 objects or whatever.
So in that case, then you might want to optimize this, because if you're doing a distance check,
like every frame across 600 objects, or maybe even more. So, so in that case, you might want to,
you might want to optimize it, right? And there is a very nice way you can optimize
distance checks when you're doing stuff like this. So, so one thing that is probably good to know is
that square roots are not like super expensive, but they're a little bit more expensive than like
multiplying. They're a little bit more expensive than adding or subtracting. So it's sometimes
good to keep in mind that the square root itself has a cost to it. So again, when you're doing
four loops over many objects in an update loop or something, that's when it really matters, right?
Otherwise, don't micro optimize this all the time, because it's going to make your code unreadable. So
don't do this all the time. I'm just like bringing this up as an optimization tip when you have like
very heavy, many distance checks and whatnot, right? So, so if we want to make this cheaper,
we could actually get rid of the square root, we could just nuke it, just remove it, and then we
can see what happens, right? Okay, so previously we were checking the distance, right? This distance
in and of itself contains the square root. So this one is doing the whole square root check, right?
But we can do this manually. So, so let's first get the displacement difference vector.
We can call it trigger. Actually, let's call it displacement. There we go. Now we're going to
use esoteric terms. So the displacement here is that we subtract one from the other, right? So
this is the vector going from the origin of the trigger to the, to the object that we're checking
the distance to, right? So that's the vector going from the center to this one, right?
All right, so that gives us the displacement vector. Now, now we want to calculate the
length of this, right? So we want to get the length of this, we could do displacement of magnitude.
But if we want to do this manually, just to like clarify the math involved in this.
So, so the length or this technically the distance, maybe we could call it this distance.
There we go, comment that out. Or just dist, there we go. All right, so we're going to get the
distance between these two points, right? And the way we do that is get the length of the
displacement vector, right? So we do the x components. And we square that as in multiplied by
itself. Usually, if you want to square something, multiplying it by itself like this is usually
faster than using like a floating point power function. So if you do like displacement dot x
to the power of two, in some cases, this is going to be way slower than just multiplying it by itself,
right? So that's a useful thing to know. So, so displacement dot x times displacement dot x.
What did we just type? Well, we just did this part, right? The x squared. All right. So now we
do the same thing for y squared. So we add displacement dot y multiplied by displacement
dot y. So now we did this part right here with the y components. And then finally,
we do the square root of the whole thing. All right, so math dot square root of all of this.
So we got the distance. And now I'm pretty sure everything should work the same way it did before,
unless all of my math is wrong. All right, seems to work. So nothing's changed so far. So now all
we've done is basically replace unity's distance function with the math underlying all of that.
Stuff, right? Okay, so what we're now going to do is the, the optimization part. So we talked about
how you can actually remove the square root and still make the math work out so that we can do a
threshold check. Because again, we're only checking a threshold. All we're interested in is, is it
less than or greater than some value, right? So in that case, we can remove the square root.
So what does this mean then? Well, now this is not the actual distance. But this is the
distance squared, as in the distance multiplied by itself. So usually it's good to like,
note that with like sq is usually what I use whenever something is squared, right?
But now the, the distance squared is not the actual distance, right?
Oh, if you want the like actual algebra involved in this, sorry, should probably,
should probably write that down. So x squared, if you want to get x out of this,
then if you take the square root, if you take square root of x squared, these are going to
cancel out and you just get x in the end. So like the, the square root and reason something
to the power of two, they're kind of like opposites of each other, right? So technically,
square roots are, it's just x to the power of 0.5. We just, we just usually write it out as the
square root symbol. Anyway, so basically they can cancel out and whatnot. So if we take the square
root of x and raise that to the power of two, then we get x. So same thing between these two.
Okay. So, so basically, when we get the distance here, where we remove this square root, we actually
have the, the squared distance, not the actual distance. Because if we want to get the actual
distance, we need to do the square root on it first. All right. So so now we have this weird,
weird squared distance value. So now this one is going to be incorrect, right? Because we just
removed a piece of the math, where we just removed a piece of the math that happens to work in this
case. And this is again, important to check for or to test your code, right? The reason it works
here is because our radius is one. If we set radius to 0.5, then now you can see that the
threshold is incorrect. It marks it as inside here. And the same thing if we make the, if we make this
larger than one, then it's, it's counts as outside already here, but I really shouldn't do that,
right? So the way to do this is that we're using the squared value here. But the radius we're
comparing to is the actual distance. But what we can do is that we can take the radius and square
that. So now both of these are squared. So if we square the radius, we're comparing the square
distance with a squared radius. And now if we go back to unity and recompile, this is now correct.
And everything is like working exactly the way we want to. But we managed to optimize away the
square root. Like we're not actually using a square root anymore. All we're doing is one more
multiply instead of the square root, which is much faster in many, many cases. So if you, again,
if you're doing very performant sensitive code, you can get rid of that square root.
Now it's a little annoying to have to type all of this. So there are built-in functions for this.
So instead of like typing all of this manually, you can get the displacement vector and do squared
magnitude. So this is built into unity. So you can just do square magnitude. And now you have the,
well, the squared magnitude of the distance between these two. And there is also, actually,
is there, is there a, there's no square distance. Okay, well, anyway, this is sort of the square
distance, then we were just doing the displacement vector manually, and then we'll get the square
magnitude of that displacement vector, right? Anyway, so this is a neat little optimization you
can do. But one thing that's very important, this only works if you're only checking a threshold.
If you need the exact distance, you have to do the square root, because we are no longer calculating
the distance over working with this is wonky space that is not linear, right? Actually, let's
okay, I can show you the quick little example. Oh, decimals.com slash calculator. This is an
incredibly useful tool. We're going to use this a few times throughout the course. It's good,
you should use it. Anytime you want to graph something. All right, so, so let's say we have
our distance, let's say that's x. So if we interpret this along the x axis, so now we have
a value representing the distance as we go further away, right? And obviously,
it's just going to be, it's just going to be one, it's a diagonal that just goes up there.
But if you do x squared, then you can see that, but wait, are you? What?
Oh, no. I'm sorry.
Okay. All right. So like I mentioned, this only works for thresholds. If you want to know the
exact distance, then you want the red value here, not the blue value, because this is not a distance
value. But if you take any points, like if you, if you say at here, we have one coordinate, and
then we have another one here. We want to know if you're to the left or to the right of this value,
that's going to be true, regardless of which of these two curves you're using. This is a little
esoteric if you're not like accustomed to reading curves. But basically, if you want to check if
something is less than or greater than something else, which is exactly what we're doing here,
we're only checking if it's less than or greater than something. In that case, you can just use
the squared versions, because the comparison is true, regardless of if you have the square root
or not. That's why we can do this optimization, but only when checking thresholds, because the
blue line is not an actual distance, it's a square distance. That was a long thing. Any,
any questions so far? How do you calculate the normal of the plane? Is it the rotation then?
So the, it depends on how the plane is defined. It really depends. If it's a two dimensional plane,
then if you want to calculate the normal of that plane,
like say the, say your plane is defined by the red arrow here, and this is 2D, then the normal is
just going to be, it's just going to be the red arrow rotated 90 degrees, right? And that's it.
And then if you imagine the plane extending it to infinity along the red axis, right? Then you can
just rotate the direction of that plane to get the normal. But then again, the thing is whenever
you have a mathematical plane, the normal is usually built in to the plane itself. So you can
usually get that normal out of just the representation of the plane that you have. But it really depends
on like, what is your plane defined by? Like a mathematical plane works in one way. If you have
an actual 3D mesh, then things work in different ways, right? Because now you have triangles and
maybe colliders that you need to like, I don't know, raycast against or whatever. Now, so that
works differently than like purely mathematical planes. Okay, so the last thing we're going to
talk about now, before we end today's thing, we are going to talk about the dot product. So,
swoosh, I think we might need to clean up this whole thing. Okay, there we go. What a good,
good circle. Let's make a new layer. Let's draw some lines.
Now, okay, so this is, this is going to get very close to trigonometry, but we're not going to
have time to talk about trigonometry today. So instead, we're just going to talk about the dot
product. So the dot product, when you're talking about multiplying vectors together,
generally, that is an ambiguous statement. So when you talk about multiplying two vectors,
there are many, many different ways that we can like approach that, like what do you mean by
multiplying kind of the most straightforward one is that, let's say you have two vectors, you have
vector a, and again, the vectors are their components, you have the x component, and then
you have the y component of a vector, right? Or if it's a 3D vector, you also have a z component.
All right, so what does it mean to multiply two vectors? So if we do a multiplied by b,
if you just write this sign here, just this little dot, usually that means that you're doing the dot
product between vector a and vector b. And the dot product is actually a very specific type of
multiplication. When you talk about multiplying vectors, there are like, there's the dot products,
there's the cross products. And I do believe the wedge product, where the wedge product is very
close to what the cross product does. But anyway, so there are different ways of multiplying them,
and knowing which one you want to do is really important. There's also component wise multiplication,
where you kind of take, so there is, there's the component wise multiplication, where
you kind of multiply these numbers together. And then you get a third vector out of that,
that is the, you know, this x multiplied by this x gives you some value here. And the same thing
with the y component, but then it gets some value here. This is actually one of the least common
multiplication methods. This is almost only used when you want to scale things on like a non uniform
scale or whatever. So, so this is usually called component wise multiplication. Unity has it in
the form of vector two dot scale or vector three dot scale. Yeah, so so this is usually a very
specialized form of multiplication. That's that's not always very this is not used very much actually,
except for scaling. Okay, anyway, so let's talk about the dot products. Now, the way that I usually
like to approach the dot product, like there are many approaches, some people like to go
through trigonometry to talk about it. But I like to think about things geometrically,
because that makes sense to me in many, many ways. All right, so we have our unit circle.
So by unit circle, I mean that the radius of the circle is one. So any vectors
that is pointing to, to the edge here has a length of one, right? So
if you have, let's see, let's put two vectors here, we have one vector there,
and another vector here. Actually, let's use separate colors, because that's going to be useful.
So we have a vector here, let's call it a,
and another vector. Actually, let's do, let's do this one. There we go. Perfect. And B.
So now if you have, now we have two vectors, right? We have vector A, and we have vector B.
And then we can ask what happens if we take the dot product of these two vectors,
because the dot product has two inputs that has two vectors as input.
Usually in math libraries and whatnot, it's just called dot.
So let's write that down. The dot product between A and B.
There we go. Okay, so the dot product, what is the dot product?
Geometrically, you can think of the dot product as projecting one vector onto another vector.
So if you look at, if you look at B here, for instance, if we do the dot product between A
and B, what we're going to get is actually, if you can think of B flattening onto A,
perpendicularly, what the dot product gives you is this length right here. So sometimes,
sometimes the dot product is referred to as a scalar projection because of this reason. It's
called scalar because the result of the dot product is not a vector. The result is just a
numerical value. So the dot product between B and A here would be, well, the whole thing is one,
so this is less than half. So I guess this is like 0.4 or something. So it's approximately
0.4 in this case. Okay, so you can sort of think of it as projecting one vector onto another.
Now, there are some caveats. For this to work, A has to be normalized. This one has to be a length
of one. You can, you can change the length of B. So if you say make B this vector, now the length
of B is not one, but the scalar projection is still going to be the projected distance along here.
Right? So in this case, it's going to be like 0.8 or whatever. Okay, so that's what the, that's a
very like simple way of like visualizing what the dot product does. It projects vectors onto each
other. And in this case, if you reverse the order of A and B, you actually get the same results. So
this one, it doesn't matter what direction you do this in. Because again, if you do this the other
way around, then we're going to do a 90 degree projection onto B. And that gives us this distance
right here. And that is also 0.4, right? So it doesn't matter what direction we do this in.
All right, so you can swap those. It doesn't matter. We still get like a valid value out of that,
right? All right. So that's what the, that's what the dot product does. One thing to note, though,
is that the dot product can be negative. So it's a little bit misleading to call it a distance.
So for instance, if we have this vector as our B, then what's going to happen is that it's going
to project against the kind of the infinite line here, right? So in this case, it will be the same
thing. It would project against the the other vector like this 90 degree angle. And then you
would get again, you would get this distance, but in this case, it's going to be negative.
So you can sort of think of this as a signed distance in this case, right? So this is a negative
0.4. So here's a very useful way of thinking about this. Now, if you look at A here, and you look at
the values we have, we have 0.4, we have negative 0.4, it's one over here. And if we were to do the
dot product where they're completely opposite of each other, we would get a value of negative one,
right? And you know how we've talked about the number line before, right? If you think about it,
B projected onto A is kind of a way of getting a number on the number line of A, right? So you can
sort of extend A and consider that to be a number line, right? Sort of like this. So when you project
it onto that, you kind of get the coordinate along the direction of the axis of A. So this is kind of
a very nice way of just converting something to some other coordinate system. And this is actually
used if you want to do space transformation, which we're going to talk about next time.
This is used for that, for instance. Okay, where do you use dot? I'll get into that very soon.
First, I'm just going to talk about how you do the dot product, like how do you calculate the
dot product between two vectors? It is very simple. It's like surprisingly simple for something that
is incredibly useful. So the dot product between vector A and vector B, this looks like it's not
equals. So the way to get the dot products, well, the actual practical way is that you
use the dot product function in your vector library. But if you want to do it manually,
you would do A dot x as in the x component of the A vector. And then you multiply that by
B dot x. And then you add a dot y, and then multiply that by B dot y. That's it. It's very
straightforward. Multiply the x components, and then add the multiplied y components. There's not
much more to it. So that's how you get the dot product between two vectors. Now, again, this
projection example is only valid if one or both of your vectors are normalized. It doesn't quite
work out if none of them are normalized, because then it doesn't really project, because then it
projects and scales that distance. So it's good to keep in mind that the projection interpretation
mostly holds if you're doing, if one of them is normalized. So again, the number line example
kind of presumes that A is normalized, because then you're kind of getting the B coordinate
along the vector of A. Okay, another useful way of looking at it is that, let me erase some things.
I'm erasing too much. Why did I draw these on the same layer? It's fine. Everything's fine. Oh,
yeah, like someone is mentioning the square magnitude. This also happens to be the way that
you get the square magnitude of something. So if you do the dot product between A and A,
and then you do the square root of this, you have a distance function. This is mathematically
equivalent to getting the distance or the length of vector A. So it's kind of a shorthand to do
that. And if you use the same vectors for both inputs for the dot product. Okay. So here's another
way to interpret the dot product. So the dot product can also be used to kind of figure out
how close are these vectors to each other. So if you think about A here,
and you have your vector B, when you project this one, you're going to get a value that is very
close to one. This is going to be like 0.999, whatever. If they are exactly equal, as in the
vectors are the same, and they're both normalized, the dot product is going to give you one.
So if we can kind of think about what happens when you rotate this vector around,
if B is pointing here, we're going to get a lower value in the projection, right? Because it's moving
toward the center now. So this is going to be 0.6 or something. And then when you kind of imagine
keep rotating this one, if it's perfectly perpendicular, like this, as in it's 90 degrees
off of A, then the dot product is going to be zero. And this is really, really crucial. So this
is important to know. So if we track what the values are, then it's going to be one over here.
Let's do one. Somewhere here, it's going to be 0.5, right?
Somewhere here, it's going to be like 0.8 or whatever, and so forth. And because we're projecting
this onto A, there's also symmetry in this, where we would have 0.8 over here as well.
And if we go perpendicular in the other direction, this would also be zero. This also projects to
zero. It's 90 degrees off. It's going to project towards this, and it's zero again. So we get back
to zero. And then we can continue to the other side. If they're completely opposite, then you get
a value of negative one. And then you have values in between here. So you know, you would have 0.5
here, and 0.5 somewhere here, right? So what does this mean? This means that if you have two
normalized vectors, and these are, and you're comparing two vectors, what you are getting
is kind of an approximation for how close they are to pointing in the same direction, right?
So in this case, I'm just talking about normalized vectors. Both of these are normalized. So if one
of them is not normalized, then these values are not going to be interpreted exactly the same way.
But the sign of this still holds. So what you can notice now is that all of the values on this side
are negative. All of the values on this side are positive, right? So one thing that the dot
product is very useful for is, is this vector pointing towards something? Or is it pointing
away from something, right? Because now if we consider the green arrow to be the direction
a player is looking, and the red arrow is the direction to an enemy or something,
then we can tell if the player is looking away from the enemy by doing the dot product, right?
If the, if the player is looking in this direction, well, oh, this should be negative, sorry.
Then this is a negative value, right? Because all of these are negative. Sorry, I forgot to do
negative for these. Yeah, so all of these are negative values, all of these are positive values.
So now if we do the dot product between the player direction, and the enemy direction,
it's going to be negative here, because it's projecting here, got the distance here,
and that's negative. So this is super, super useful. I do have an animation for this too.
Not that animation. It's the wrong one.
So here's an example. This is basically what I've just been talking about now.
You have two vectors, if they point in the same direction, you have a value of one.
If they point directly perpendicular to each other, it's a value of zero. If they point completely
in opposite direction, it's a value of negative one. And that's kind of it. So again, this is only
when you have two normalized vectors. If one of them is not normalized, the positive and negative
those rules still apply. In that case, they don't have to be normalized. But for these values to
be exactly one and negative one when pointing in opposite directions, they have to be normalized.
Can I calculate the second vector if I only have the first vector on a dot product?
Well, it would be ambiguous, because you would have two results, not one. But I believe it's
possible. Is there any point having one vector larger? Yes, if you don't want to check the,
if you're not interested in checking, like, are they facing the same direction or some other
direction? Sometimes you want or very often, actually, the vector is shorter or longer than
a normalized vector. So this vector projected onto this one. Sometimes this distance is still
interesting. And it's very often interesting as well. So let me be a bit more practical,
because we've been talking about like esoteric things. And let's let's think about
what this can be useful for, right? Let's see, maybe I should
move. Do I move that? Or do I keep it? Angle is implied by the dot product? No,
angle is we're not talking about angles, angles of spoilers. We're gonna get into angles as soon
as we talk about trigonometry. But right now, we're just doing vectors. Okay, here's an actual
example from the game that I'm working on. So let's see, you you happen to have a game that
has a surface of all things. So let's see, guess we can give it some some direction. There we go,
three is soft and good. I don't know how to make this continuous. There we go. Cool. Okay, so we
have a surface. We have a point on the surface. It's solid underneath here. So you can just
pretend that this is solid. And you have air here. Now we quickly mentioned, or we briefly
mentioned the normals, or what a normal is of a surface. And again, a normal is a something that
is pointing directly out from some surface. So like the blue vector here is normal to the palm of
my hand, right? The other two vectors are tangent to my hand, they're not normal, right? So pointing
directly out from some surface, that's the normal. So let's let's let's visualize some normals. So if
you have this surface, again, the normals point directly out from the surface. So the normals
along this surface would like kind of continue like this, right? And then you get a vector like
that, and so forth, you imagine these have a length of one. So these are the normals of the surface.
So let's think about this point in particular. And let's draw the normal. The normal is going
to be very large, because our circle is very large. So this is the normal.
Let's call that N. Now we have the normal of the surface. So here was a problem that I had.
When I was working on a game, back in the days, if you have a surface, and then you have an object
for some simplicity sake, let's say we have a have a sphere or a ball or whatever. And this
object is moving at some speed, and it's going to hit the this ground and then bounce off of it,
right? Okay, cool. It can bounce off of this surface. Now you want to play an audio clip.
So let's say you you want to play some audio clip. There we go. That's my audio clip symbol.
Because you have an impact sound, you want to make a clunk sound when the ball hits the ground
or something. And now the question is, what is the volume of this sound? Like how loud should this be?
How would you solve this problem? So now we're getting into like, trying to figure out, okay,
if we are moving very quickly, then obviously we want it to be louder than if it's not moving
quickly, right? If it's moving very slowly hits the surface, then we might not even want to play
a sound, right? Okay, so let's just think about this some more. So so maybe volume
is just the speed of the object, right? Cool. All right, we got the volume equal speed.
But consider this case, if you erase these, all right, so we have this ball,
let's say we throw this one down, straight down at some speed, let's say it's 10 meters per second.
And then we have another ball that's at a very low angle, and it's going to hit the ground
at the same speed. So we want this one to be louder than this one, right? Because obviously,
this one is going to make a very hard impact on the surface. Whereas this one, it's not going to
make a very hard impact. Like it's going to mostly going to grace the ground and then do a little
bounce, right? So now we have this issue of like, well, it's not just based on speed, we have to do
something else, right? Okay, so what can we do? So what we can do is that we can use the normal
of the surface to figure out how quickly is it moving toward the surface? Because that's the
key thing that we need to know, right? So so let's let's bring out the normal again.
So the normal represents the direction of the surface, right? And what can we then do? Well,
we can think of these arrows here as our velocity vectors, we're going to get into more physics
later. But you can sort of represent velocity as a vector. So basically, each component like x says
how quickly you're moving along the x axis, and y is how quickly you're moving along the y axis.
So okay, so how do so how does the dot product come into this? Well, what we can do then is that
if you imagine this normal here, we have the velocity vector here, and then we can project this
onto this line, right? And again, the dot product gives us the projected distance here.
And then we can do the same thing here, right? We take this one, do the dot products,
and now we get this distance right here. So even though I guess pretend this arrow is as long as
this one. But the point is that now, using this normal, we can get speed in this direction,
rather than speed overall, right, like getting the getting the length of the velocity vector
is your overall speed. But it doesn't say what the speed is in the direction of the surface,
right? But that's what we're interested in. If you're moving directly toward the surface,
it should be really loud. If you're moving really fast, but you're not really hitting the surface
fast, you're kind of moving fast just tangentially, then we don't want it to be loud. So in this case,
every time you have some object that is hitting some surface, you know, this object is flying
onto the surface, then we can just do the math. If the if this is the velocity, we project this onto
onto the normal vector. And then we get a magnitude here for how loud this should be,
right? Okay, so let's try a different direction. Another ball that's flying in this direction.
Well, if we do that, then we're going to get a vector like this. And when we project this one,
it's not as loud, right? Because now we're only using this span right here. And this is much
shorter and a much smaller volume. So, so what we're getting is the direct or the the the speed
along a specific axis. So we get the speed along the normal, that's what we're getting
when we do the dot product between, you know, the velocity vector of the object and the normal of
the surface. Yeah, so long story short, you need the dot product, basically. Yeah, so so that's
that's one use case. So that's what I've used dot product for. For instance, there are millions of
use cases for the product. But this is just one of them. Yeah, do both of these vector need to
be normalized before using the dot product? No. So specifically here, it's very important that the
normal is normalized, and that the velocity vector is not normalized. Because we do want to
the longer the velocity vector is, the faster this object is moving, right? So if you imagine the one
that's moving downwards, that's this velocity vector, if it's moving faster, we want it to be
louder, right? So that would still project onto this line here. And then we get this value here.
So we still want it to be louder. So we don't want to normalize the velocity vector. We do want to
normalize the the normal vector, though. Otherwise, we're not going to get things that are in meters
per second anymore. And it's not going to be a correctly projected speed along an axis, right?
Can you post that image here? Yes. All right, let me just complete this because I kind of left
this incomplete. Okay, so so better way is something along lines of volume equals the dot product
between the velocity and the normal. There's some caveats here. So if you remember how the
dot product works, these values are going to be negative. So you have to like make sure that
they're positive, you might want to multiply them to change the overall loudness or whatever.
Yeah, but if but but again, the dot product product is a scalar. If it's negative and you
don't want it to be negative, then you can just do the do the absolute value of that, right?
So getting the absolute value of this would get you get you some volume.
But the core concept is that with the with the dot product, you get a projected
projected velocity along some axis. In this case, the axis was the normal of the surface, right?
Um, was that clear, by the way? Yes, I can post that image in the discard.
Actually, let me write some notes to make sure.
It's a little misleading to say speed, because speed is generally not signed,
it's pretty much always positive. So I'm going to put that in quotation marks.
Oh, people are talking about the cosine. Yes, the dot product has a very intimate relationship
with the cosine, but we haven't done trigonometry yet. So we're going to do trigonometry later.
Um, okay. Yeah, let's let's post this in your discard.
Geez, when people are skipping ahead of your math class and spoiling the
what's going to happen in the next chapter. Yeah, I can just show you another example of the dot
product. If you want to see in game this time. So here's another use case for the dot product.
So I'm working on this game. This is called flowstorm. So right now, the another thing that I
used the dot product for was the pitch of the thruster of this rocket, right? So if you listen
to the rocket here, you can hear that the pitch is changing depending on what's happening.
Right? You can hear that it increases in pitch. Okay, so so far, no dot products, right? If you
move fast, we increase the pitch. If you move slowly, the pitch is lower. It's sort of the same
thing with sliding. Like you can hear the pitch change depending on if you're moving quickly or
slowly. All right. So the thing that I'm using the dot product for is that if you are accelerating
and you're turning the rocket left and right, actually, let me zoom in. Then the pitch is
going to be different. It's not just based on speed. So if you listen to this while watching the rocket.
Like even if I'm moving, sometimes when I turn the rocket, the acceleration or the pitch goes down
again, even though I'm moving fast, right? Yeah. So basically, what I have done is that
actually, let's go to the level editor instead, because there's more space.
No, level editor is currently broken. That's okay. We can have no little reps in the console.
So if you listen to the rocket now, we're moving faster and faster sideways, but then I look up.
You can hear that every time I turn, where the rocket is not perpendicular to the velocity vector,
the audio will now change pitch. Because what I'm really interested in is
how quickly is the rocket moving in the direction you're pointing? That's the crucial thing here.
So in this case, what I'm doing is that instead of a normal direction, I have the direction of my
rocket, right? So I have this vector right here. This is the direction. And then I have the velocity,
right? The actual velocity vector for how quickly you're moving in that direction, right?
So the actual velocity could go in either direction, right? It could be in this direction.
It could be along this. It could be opposite towards it, right?
Yeah. So that way, I can get the speed in the direction of the rocket, and then I can use
that to change the pitch of the rocket. So that's kind of it. That's basically,
like, just depends on how you're moving and then project that along the direction of the rocket.
And then what I get is, what is the, how much are you moving along this direction? And that's it.
That's how I got the pitch there. Sounds like it's the absolute value of the dot product? Yes.
So that's, that's kind of it. Do I use the dot product for something else? I do use it for the
impact sounds. Just like I mentioned before, this is the game where I did the impact sounds.
So when you hit the surface, there are little sounds that play. That one is based on the dot
product, just like we talked about. Yeah. Otherwise, there are many, like, placeholder sounds,
like when you crash, that's a placeholder sound. So there's a lot, a lot of stuff that I haven't
done in this game. But, but yeah, otherwise that's how it works.
Peter.
Oh, someone asked about the lighting in this? No, the, the lighting is not the
Unity's built-in one. I wrote my own custom lighting system. Here's some lighting buffers,
if you're curious about how my lighting system works. The first lighting buffer is kind of
self-explanatory. The, the other three are a little less altering. Oh, I also use a dot product for
the water physics. So underwater, I kind of want you to be able to turn the rocket and that would
also change the direction of the rocket. Again, you do stuff with the dot product
and the direction you're moving versus the direction you're pointing. And that way,
you can make the rocket sort of behave as if you have drag underwater, right?
Yeah. Otherwise, I think that's it, unless you have more questions. Now I'm going to try to
figure out what assignments to give you. Yeah, I'm just going to, I'm just going to have a
slow Q&A thing while I figure out the assignments. All right, I got two out of
maybe three, four assignments. I haven't decided on how many yet. Be gentle. I mean,
we've mostly gone through a lot of like fundamentals right now. So I'm not going to do
something like super advanced. What do these assignments do? I have no idea. I think
Krister is going to do all of the, all of the assignment stuff. He's also going to be correcting
them. So I'm just going to do the, I'm just going to make assignments and then Krister can decide
that everything else. And also Krister is going to be doing the, he's going to do the grading
and whatnot. Okay, there we go. Assignment one is now ready. I'm going to reveal all the assignments
as soon as I'm done writing them. Oh, I just, assignment two has a thing we didn't talk about
today. Isn't that spicy? I presume all of you know what transform.forward means or transform.write
because those are going to be irrelevant. But I presume you've done that already because
you've been using Unity for a while. You don't have to be a student to see them. I will show
them as soon as I'm done writing them. I'm just jotting down notes now for the assignments. I'm
going to draw more specifically. I know you can't see right now. I'm going to draw what the assignments
are going to be. A lot of these concepts are probably going to be very easy if you like rewatch
the stream and whatnot. So like, it's mostly about I want you to get some practice in actually doing
the assignments and practically writing code that does the things we've been talking about,
because that usually helps you like solidify what we've been talking about. So like, try not to
copy code from each other unless you really, really have to. So like, try to see if you can do it on
your own at first, because that's kind of a better way to make sure that you've learned the things
you need to learn. Otherwise, of course, look things up if you need to. But it's always good to
make sure that you actually know what you're typing. If you're not sure what you are doing when you
type vector to dot dot, like you should know what is happening when you do that, which you might not
if you just copy someone else's code, right? Because again, my goal is for you to learn what
these things are. I don't care if you do the assignment, or don't do the assignment or copy
code. I don't care. But I want you to learn. I want you to learn the things that are important to
you. But then again, I'm not going to do the grades Krista probably carries if you copy
or cheat or whatever. And if you do them at all. Okay, all right, I got the assignments. I'm here.
Here we go. I'm going to draw these so that it's like very clear what they're doing. And I'm going
to post both the pictures and the text for it. Assignment
number one. Yeah, I don't I think the the assigned the date for these assignments
is probably going to be much later. As in, you don't have to do them tomorrow. If you do them
tomorrow, that's going to be good because then I'm going to cover these assignments at some
points. And so it's probably good if you done them before that. If you want to like maximize
your learning. But if you're stressed, then this is I mean, don't don't stress yourself out. Okay.
Cool. First assignment.
And create
the radial trigger. So this is the thing we made on stream. We had a trigger that had some radius,
right? There we go. It's got a radius. And then we want to detect whether or not a point
is inside or outside, right, based on this trigger. And the trigger should be able to be
anywhere. You need to be able to move the trigger around, you need to be able to change the radius.
And it should still be able to detect whether or not this point is inside or outside, right?
So, so that's all you need to do really, like it's
inside versus outside. And you can do all of this is on drug in on drug gizmos,
you don't have to make like an actual update loop or whatever, just do the dude and on drug gizmos.
The point is, I want you to like, try this out yourself and make sure that you've actually like,
you can do the concepts that we've been talking about, right? So recreate the radial trigger is
the first assignment. Can it be moved and seen only? Yes, you don't have to animate anything. It
doesn't have to be in play mode, just the same way we did it on stream, just like make sure that
you know the mathematical concepts. But like, you don't have to involve like physics or rigid
bodies or gameplay or anything like that, just to make sure that like, you have the idea of
detecting whether or not something is closer to something or not, right?
Yeah. So that's one way of doing it. Or that's the first assignment. So assignment number two.
So previously, we, the radial trigger, kind of check like, you know, are you inside of a trigger
or outside of a trigger, right? And that is based on the radius. But now I want you to make another
trigger. I feel like I had a name for this. Actually, I just renamed it. There we go. That's
rebellious I am. So the next one is that I want you to make a look at trigger. Okay. So basically,
you have a similar thing here, you have a, actually, let's name this player. There we go.
Player objects. Another player. Cool. So then we want a look at trigger. So in this case,
if you have the trigger at some point, and then the player is looking in some direction,
we want to be able to detect if you are looking toward this trigger or not, right?
So that's what this one is for. So if you are looking at this trigger, you want it to be true.
If you're looking away from it, you want it to be false, right? So this one should also,
you know, this one has a radius that you can modify to set the threshold of this.
The look at trigger should also have a threshold
from zero to one. So let me move this down because I need to clarify a few things.
All right. So threshold from zero to one. And if the threshold is one, that means
it's going to be very strict. Probably impossibly so, because you're probably never in practice
because of like floating point imposition. All right. So one is super strict. And this is a
floating point value. You can set it to 0.5 and everything. All right. And then we, if it's set
to zero, that means that, so perpendicular or closer means you're at it. There we go.
So this is the threshold. So you should be able to, if this is set to one,
you have to look like exactly at the thing. And it's going to count as triggered only if you
look exactly at it. Because of floating point precision, that's going to be like pretty much
impossible, never going to happen. But if you set it to like 0.5, it should allow you to look a little
bit away and still count as looking at this thing. But then as soon as you are looking away from it,
like this, that should not count as looking at it. So basically, this threshold should set how
sensitive it is. If it's a one, it's hypersensitive, you need to look exactly at the point. If it's
zero, it's not very sensitive at all. If you look in this direction, it's going to count as looking
at the thing. Yeah, that's about it for number two. Oh, and to clarify, we haven't talked about
angles yet. So this doesn't involve angles. None of this is angle bakes. This is still just vectors.
All right. And let's do the third one. Still just vectors. Yeah, angles don't exist.
You've never heard of angles. This one is smaller. Okay, heck, I'm trying to figure out how to draw
this one without spoiling the solution, because this is kind of difficult. So this is the one
we're going sort of toward concepts we haven't talked about yet. But that's a little teaser
thing or something. So let's say this is the origin of the world, like this is 0, 0.
And then you have an object in Unity that has some, some orientation, right? So usually Unity,
you would have this gizmo that looks something like this. And then you would have the z axis
pointing sort of toward the camera. And then let's say you have a point. There we go.
Okay, and then you have this object. Let's call it object. So this one is I want you
to make a transform function to transform world to local and local to world. Cool. Okay. So the
goal is I want you to have a transform in the scene that has some rotation and a position.
And I want you to write a function that can transform this point either into local space of
this object, or from local space of this object to world space. We haven't talked about spaces yet.
So that's why this one is a little bit of a curveball. But I'm sure you sort of understand
the concept of what it means for something to be local space and world space. So that's what I
want you to do. And you're not allowed to use Unity's transform functions in order to transform
this point. You're not allowed to use matrices, you're not allowed to use transform dot transform
points, not allowed to use those, those don't exist anymore. So, so you need to do this using
vector math and dot products. That's what you need to do, right? Yeah, you can still use transform
writes transform dot up to just get vectors and whatnot. But you're not allowed to use
the transform functions. No, you don't need to use quaternions. This is possible using only the
things that we have talked about. Oh, yeah, this is 2d only, we don't need to care about 3d yet.
So yeah, 2d only. I don't know where to fit that in. I don't think I get the goal of this. You need
to be able to transform a point from world space to local space, which means that you need to
figure out where a point is. So if you look at this point, for instance, I'm good, this is really
hard to explain what that's spoiling the whole thing. If you look at this point here, if you
consider the coordinate of this one in world space, well, it's this vector, right? And then you have
an x coordinate, you have a y coordinate and so forth. But making a transform function means
that you should be able to take this point in world space and transform it to this space.
As in, I want it to be relative to this object. So now I want the x coordinate and the vector and
everything to be based on the local space of this thing right here, right? Yeah, and it should
take rotation into account. So it's not just position, you can ignore scale. Scale doesn't
matter. But it has to take rotation into account. And you can do this using only the concepts that
we've been talking about. You don't have to do anything outside of that. In fact, you're not
allowed to use matrices or the transform dot transform point functions. You need to do this
with vector math and dot products. And if I move the point to the position, it would be under the
new parents facility, move point being world space, you mostly just need to get the coordinates.
How you like make it in the scene or how you move them around doesn't really matter.
You just need to be able to get those coordinates. But how you visualize that or whatever is a
separate thing, you need to be able to get a point relative to a different space.
Yeah. So what I mean by that is that if you ignore these lines that I used to draw,
you just need the coordinates of this one. If you like pretend that, whoops, pretend that the
this right here is world space or whatever, because that's kind of what you do, right?
But yeah, basically, you want to get this point relative to this space. That's it. And also the
other way around. Oh, and just parenting objects and getting their location kind of like defeats the
purpose of it. And the reason I call this a curveball is because we haven't talked about
space transformation yet. That's the only reason otherwise the the ways to do this only talks
about everything we've been that you only need stuff we've been talking about earlier. Yeah.
You can use transform dot forward, transform dot forward, transform dot right, transform dot up,
you're allowed to use those. You're just not allowed to use the space transformation functions.
Because the whole idea is that you need to like, do the space transformation yourself.
Okay, all right. I think that's it. Those are the three assignments. Oh, yeah. If you want to join
like my discord for my streaming shenanigans, feel free to hop into discord. We're like a
bunch of game developers, a lot of us are under the LGBT umbrella. So it's sort of like a Venn
diagram overlapping those two things. So feel free to feel free to join discord. Let's see,
I'll post this in the math channel that seems appropriate for the transform from world to
local. Is it okay to use a child object for output? Oh, if you just wanted to like test
your code to see if it works, sure. But like you could do it. If you want just like using gizmos,
so you don't have to like use actual objects or whatever. Okay, my voice is dead. I need to stop
talking. And I need to stop streaming. But thank you all so much for joining. I hope this was
useful and that this has helped you learn something or get a refresher on things or I don't know,
hope it was useful.
