Hello everyone, and welcome to another episode of Coding Adventures.
Today, I'd like to dive into the world of fluid simulations.
So to begin with, let's draw a circle.
Very nice.
This circle represents a tiny bit of water, or whatever fluid we want to imagine, and
it's going to move around in response to various forces.
For instance, gravity is probably a good place to start.
So back in the code, I'll add in a gravity variable, and let's also keep track of the
particle's position and velocity.
Each time step, we'll then want it to be accelerated downward by gravity, and to then
move according to its new velocity.
Let's take a look.
Okay, not bad, but it is falling off the screen, which is a bit annoying, so I've added a
tiny function that just checks if the particle has moved outside of a box, and if so, we
shove it back into the box, and send it bouncing off in the opposite direction.
I'd actually also like to multiply the velocity by some collision-dumping factor between
0 and 1 here, so that we can control how much energy it loses with each bounce.
Alright, so we can set up our little bounding box, and turn on the gravity again, and off
we go bouncing.
By the way, I've also made it so that we can control the display size of the particle
here.
Okay, let's then also try out our collision-dumping setting, and we can see the particle now bounces
low and low each time until it comes to a stop.
Believe it or not though, one particle is not enough particles to simulate a fluid,
so I've quickly upgraded our position and velocity variables to instead store a whole
array of positions and velocities, which we can then loop over and just do the same
update as before to each of them.
I've also created a simple function that runs at the beginning to set up the particles
in a little grid arrangement, just so that they're not all on top of one another.
So let's make a bunch of particles, and I'll quickly tweak the size and spacing over here
to something more reasonable, and then we can let this run.
Okay, there's a pretty clear problem though, which is that the particles are all just collapsing
on top of one another, so I guess we need some sort of force to push them apart.
I'm curious to learn how this is typically handled in the fluid simulation world, so
I'm going to do some reading.
I found a bunch of intriguing particle-based fluid papers, and I've just spent the last
few hours trying to work my way through those.
Honestly, most of the maths has gone well over my head, as it often does, but the broad
ideas at least are encouragingly simple, so I think my goal for today is not to try and
make some amazingly accurate simulation, but just to build a rough starting point from
which we can delve deeper into the maths and physics in the future, when I'm hopefully
a little bit smarter.
Anyway, the first step to fixing that overlapping particle problem we were having is to be able
to estimate the density of our fluid at any point.
So I've just scattered our particles around randomly for this example, and of course since
we're imagining that this represents some kind of fluid, in reality there should be
way more particles in this, but we're always going to be limited by what our computers
can handle, so to approximate reality, we can just cheat a little bit by blurring or
smoothing out the few that we have, so that it appears more as a continuous field than
a bunch of individual points.
This simple idea is the basis of smoothed particle hydrodynamics, a technique introduced
back in the 70s to help solve astrophysics problems and further our understanding of
the universe, which today we'll be using for the equally lofty goal of making some
little pixels go splash splash for our amusement.
Alright, so to see how we're going to calculate this sort of density field we have here, let's
zoom in on a single particle and define a smoothing radius, which gives us this circle
of influence around the particle, where it will have maximum influence at the centre,
falling off to no influence at all at the outer edge.
Let's draw a little graph of this behaviour, so on the x-axis we'll have the distance
from the centre of the particle, and because negative distance doesn't make a huge amount
of sense, I'll just make the left side of the graph be a mirror of the positive side.
Then the y-axis will represent the influence of the particle at any given distance, and
let's say for now that our smoothing radius is just 1.
So a simple simple function we could use would be something like this, just subtracting
the distance from the radius and clamping it to never go below zero, and here's what
that gives us.
This is not very smooth though, so we could take that straight line and qubit for example,
which will ease it out as it approaches zero.
Another option if we wanted to be smooth at the start as well, would be to also square
the radius and distance before subtracting them, and here's how that comes out.
Obviously we could also try different powers or different functions altogether, I think
it's mostly a case of just playing around and seeing what works best.
But let's go with this one for now.
So I've used that to write this little density function, which takes in the point we want
to find the density at, and then for each particle it gets the distance to that sample
point, which determines how much influence the particle has at that location, and then
it simply increases the density by the particle's mass, multiplied by the influence value.
And the mass I've just defined to always be one for simplicity.
So let's test this quickly with an evenly spaced grid of particles, and I'll just try
sampling the density at the centre here, with a radius of 0.5 for example.
Now at the moment the density is coming to about 0.48, but if we squish the particles
closer together, we can see that the density value goes up, which makes sense, and if we
move them further apart, it goes down of course.
But what about if we increase the smoothing radius?
Well, our density value has just shut up through the roof, which is very concerning, because
making the radius bigger should only make the result more blurry, which for this uniform
grid of particles should actually have no effect on the density at all.
So let's think about this a bit.
For each particle we are calculating an influence value, which we could draw as a height, and
here we can of course see the shape of our smoothing function emerge.
Now we're effectively just adding all these heights together to create our density value,
but it's kind of helpful to note that if we were to first also multiply the heights
by the width and breadth of these little boxes I've drawn here, what we'd actually
be doing is estimating the volume of the smoothing function.
So with that in mind, I think it's reasonable to say that if we want the density to stay
the same as we change the smoothing radius, then what we'll need to do is make sure that
the volume of our smoothing function remains the same when we change the smoothing radius.
That means we're going to need to calculate its volume, or make Wolfram calculated for
us at any rate, and that is come out to pi times the smoothing radius to the power h
divided by 4.
We can then just go back to our smoothing function and calculate the volume in here,
and then simply divide the output by the volume, which means that now the new volume of the
function will always be 1.
Let's quickly make sure this is working, so the density is 187 at the moment, and now
if we change the smoothing radius that should stay the same, which it does.
Of course if we make the radius too small, the results will get a little dodgy since
there just aren't enough particles, but apart from that we now have a nice way of determining
the density at any point, with whatever smoothing radius we choose to use.
Ok, so let's return to our random arrangement of particles, and we can now properly visualize
the density values here as we increase the smoothing radius.
Now we're claiming that this represents a fluid, so one would probably assume it's
a guess at the moment, because we have all these regions with different densities.
But I'm more interested in simulating liquids today, which in practical terms are incompressible,
meaning their molecules are packed together as tightly as they can be, and so we'd expect
the density to be the same everywhere.
For our simulation to behave at least somewhat like a liquid then, we're going to need
to rapidly correct these density differences by moving particles from areas of high density
towards areas of low density.
So we need to figure out how to calculate that, but I started to get a bit confused at
this point while I was doing my research, so I'd like to take a step back for a moment
and just play around a bit with an abstract example to try and wrap my head around some
stuff first, and then we'll come back and apply what we've learnt to our actual problem.
So here's a simple little function that takes in a point in 2D space and outputs a single
value, which looks like this.
And what it represents is nothing at all, it's just a made up function that we're
going to try and represent with particles to hopefully gain a better understanding of
this whole smooth particle business we're working with today.
So I've now added some code that spawns in a bunch of particles at random positions,
and each of these just looks up the value of the example function at its location and
stores that in this vaguely named particle properties array.
Now we're going to pretend that we no longer have access to that example function for whatever
reason, so we only know the values at the particle positions, and our first goal is
to simply approximate the missing values.
To do that, we'll use the same smoothing idea from when we calculated the density
earlier.
So I've made this little calculate property function that takes in a point in space, loops
over all the particles, and just adds up the values of their properties multiplied by the
smoothing function, since again that just tells us how much influence the particle has
at the current point, and then also multiplied by the mass, since that effectively scales
how much influence the particles have.
Let's see how that comes out, so here's the original function again just for reference,
and here's our approximation.
Obviously, the shape isn't perfect, but we could simply use more particles to improve
that.
What's more concerning though is that the values are clearly being greatly exaggerated.
Now we could try to correct this by reducing the particle mass, but that just reveals a
deeper problem, which is that the values are being particularly exaggerated in regions
of high particle density, since obviously more values are being added together there
than in regions of low density.
So to fix that, all we actually need to do is calculate the density at each particle,
using the function we wrote earlier of course, and then divide each particle's contribution
by its density.
Now our approximated result looks like this, without needing to make any adjustments to
the mass, which is a whole lot better, and it's reasonably close to the original function.
So what we've arrived at here is actually one of the core equations of this whole technique,
which says that to calculate some property a at any position x, we just need to loop
over all the particles and add together the value of that property that's stored in
each particle, multiplied by the particle's mass, divided by its density, and finally
multiplied by the smoothing function, given the distance between the particle and the
sample point.
What's interesting to note here is, say that the property we want to calculate with
this equation is the particle's density.
In that case, we replace a with the density, which then cancels out with the density over
here, leaving us with just mass times the smoothing function, which is exactly what
we came up with in the beginning, so that bit of math seems to check out at least.
Okay, that's nice and all, but what we're more interested in right now than calculating
the value of a property at any point, is calculating in which direction it's most
rapidly changing, since that's essential to our problem of correcting the density in
our fluid.
So I've started writing this little calculate gradient function to do that, and all this
does is define a tiny step size, and then figure out how much the value changes if we
take that tiny step along the x and y axes, using the calculate property function we just
wrote.
And the estimated gradient is just those two changes, each divided by the size of the step
that we talk.
Let's try it out, so I've drawn in some little arrows to visualize the gradients
at different points, and just visually it looks like these are all correctly pointing
along the direction where the values are most rapidly increasing.
So that's great.
What's less great is that it's taking almost 20 seconds to calculate all of these, which
is ridiculously slow.
Unfortunately though, there is a more efficient approach.
Imagine we have just a single particle, and I'll draw on the smoothing radius here as
well, and we're trying to calculate the gradient of whatever property at this point
over here.
Well, first of all, the direction in which that property will most rapidly be increasing
is either directly towards the particle, or directly away from it if the property is negative,
so that's easy enough.
The gradient doesn't only tell us the direction though, but also how fast the property is
changing, and that depends purely on our smoothing function.
At the current distance, we can see that the smoothing function isn't very steep, which
means that the property will be changing quite slowly over here, whereas of course if our
sample point was over here for example, then it would be changing a lot more rapidly.
So after struggling to remember how basic calculus works for a few minutes, I finally
figured out the equation for the slope of the smoothing function, which I've just
translated into code over here.
And that means that we can now easily look up the slope value at any distance.
So let's return to our fast attempt at the gradient function, and I'll delete the old
code and replace it with our CalculateProperty code, since that's almost exactly what
we need, except since we want to know the gradient now, we'll multiply not by the
smoothing function, but by the slope of the smoothing function, and then also by the direction
towards the current particle.
By summing up all these individual gradients, we should logically get the overall gradient.
Then if we return to our little visualization and just run it again, it should look exactly
the same as before.
Which it doesn't, I guess I got the direction back to front, so I'll just stick a minus
sign in there quickly.
I come from the trial and error school of mathematics, but now it does look the same
as before.
This optimization has taken us from 20 seconds down to about 5, which is still uselessly
slow, but headed in the right direction at least.
Okay, I've just been having another look at our gradient function, and we definitely
need to stop calling CalculateDensity all the time.
I somehow forgot already that that's also looping over all the particles.
No wonder this is so slow.
So what we can do is just create an array of density values, and then pre-calculate those
for each particle, so that we can just use those cached values in our gradient function.
That brings our computation time down from 5 seconds to 18 milliseconds.
I probably should have started with that.
Anyway, it's still not fantastic, but it's at least usable for now.
So let's return at last to our little density test over here, and see if we can apply this
gradient stuff to make the density be the same everywhere.
So in the code, I've defined a target density that we want to aim for, along with a pressure
multiplier, which is just how strongly we're going to push the particles to try and reach
that density.
Then I've also added this little function for converting the density to a kind of pressure
value, and this just looks at how far away the density is from what we want it to be,
and then multiplies that by the pressure multiplier.
From what I understand, this isn't really a super realistic way to calculate pressures
in a liquid, it more so describes the behavior of gases, but it still seems to be a popular
choice for its simplicity, so let's stick with it for now at least.
I would like to quickly visualize these values, so I've set up three different colors over
here, one for the regions where it's negative, just meaning that the density is lower than
we want it to be, another for where the value is positive, meaning of course that the density
is higher than we want it to be, and finally one for the boundary between them, where the
density is just right.
I'll also change the particle color to black, so that it stands out a bit better here.
Okay, so let's finally get these particles moving along the pressure gradient, and for
that we can just use the gradient function we wrote, which I'll rename to calculate
pressure force, and then the property we're interested in here is of course the pressure,
so let's substitute in our little pressure calculation.
Then our simulation update loop now looks like this, we still have the gravity, position,
and collision stuff from before, but I've added in the density caching we decided to
do.
We still need to actually apply the pressure forces here though, so I'll make another
loop quickly to calculate those for each of the particles, and then we know that force
equals mass times acceleration, so acceleration is force over mass.
So my first thought was to just calculate the acceleration like this, but actually we're
thinking about the movement of tiny volumes of fluid here, and density is the mass per
volume, so it's in fact the density that we want to use instead.
Alright, all that's left then is to just increase the particles of velocity by this
acceleration, and we can finally try it out.
This has been a long time coming, so let's get a little drumroll going.
Ah, the curse of the drumroll continues.
Okay, the positions are all not a number I see, so most likely we're dividing by
zero somewhere.
Oh, of course, we're being given the position of a particle here, but then we're also
looping over all the particles and finding the distance between the two.
And that's where everything's going wrong.
I guess what I'll do is just have this function take in the particle index instead of the
position, and that way we can very easily just skip over the case where the two particles
are the same.
Okay, I just need to fix this up quickly, and I suppose it is technically possible for
two different particles to be in the same position, so if that edge case occurs, let's
just pick a random direction then.
Alright, let's try this out again.
Well, at least everything hasn't blinked out of existence, but the particles are getting
more dense, which is the opposite of what we want.
I guess I need to stick another minus sign in there somewhere.
Let's see if this works now at the third time.
Okay, that'sâ€¦ that was looking promising for a moment there, for a brief instant I
thought it was working.
But there's still a lot more red areas than I'm hoping to see.
Ideally, the whole screen should turn white, since that represents our target density.
So to try and figure out what's going on, I want to see what happens if, instead of
adding the acceleration to the velocity, we just assign it directly, so we're removing
any inertia from the particles, they're just purely moving based on the current pressure
force.
Okay, if we run this now, nothing happens, but that's fine, we aren't accumulating
velocity anymore, so I guess we just need to turn the pressure multiplier up really
high.
Alright, that looks interesting.
I am a bit surprised by how close together some of these particles are, although they
seem to gradually be pushing each other apart.
And I actually remember one of the papers mentioning this potential problem with the
smoothing function we're using, since its slope becomes very shallow as the distance
becomes small, meaning that our pressure force will also be small when the particles are
close together.
That seems odd, so let's maybe ditch this nice smooth curve for the spiky version instead,
since of course the slope of this one just gets steeper towards zero.
So I had to do the volume and derivative calculations again, but ended up with these
two functions here.
Plugging those in, we can see our little map looks just ever so slightly different, and
then I'm going to turn up the pressure multiplier again now, and see what happens.
Okay, that's looking a lot better actually.
The question now though is what does it look like if we put the acceleration back to how
it's supposed to be.
So I've changed it back, and I'm going to try running this again.
Let's maybe try increasing the pressure multiplier a bit, so that the particles can react more
quickly.
That's looking reasonably good I think, although maybe I'm imagining this, but it
seems to be getting worse over time.
Okay, I'm definitely not imagining it.
So another thing we need to think about is Newton's third law of motion.
Every force has an equal and opposite reaction force.
So when we're adding on this pressure force between the current particle and some other
particle, we want to make sure that the other particle experiences the same force, just in
the other direction.
I've seen a bunch of different suggestions on how to actually do this, but a nice simple
version is to calculate this shared pressure, which is literally just the average of the
pressure values calculated at both particles.
So let's try that out quickly, and I'll just increase the pressure multiplier again.
And this does seem to have made a pretty big difference.
I guess maybe that Newton guy was onto something.
Now we're only dealing with a few hundred particles at the moment, which is not very
many, so let's ramp this up to a few thousand instead.
And this is running at 5 frames per second.
So we'd better start optimizing.
And by far the most critical place to do that is when we're calculating the densities
and pressure forces, we should rarely avoid looping over all the particles that lie outside
of the smoothing radius, since those don't contribute anything, and they're slowing
us down immensely.
To do this, we're going to need to chop space up into a grid, and we'll choose the size
of the grid cells to be the same as our smoothing radius, since that means, if we imagine there's
a bunch of particles on here, that means that to find the particles inside of the smoothing
radius, we only need to consider the 3x3 grid of cells around the center of our circle.
And in that way of course, we cut out a huge amount of unnecessary work.
Now to actually implement this, we could say that each cell has its own list that grows
or shrinks to hold however many particles are currently inside of it.
But we're probably going to want to convert the whole simulation to a compute shader at
some point to run on the GPU, and there we need to be able to specify ahead of time how
much memory we're going to use.
So I'd like to experiment with a different GPU friendly approach, which I've been reading
about in this paper here.
I'm going to modify it very slightly though, so that we don't need to know the dimensions
of the grid ahead of time, meaning that particles can travel anywhere in the world, and it'll
still work.
So what we'll do is create a single array with at least as many entries as we have particles,
so here it has 10 entries, meaning in this case we could have at most 10 particles.
Then for each of these particles, we're going to calculate the coordinate of the cell that
it's in.
So for example particle 0, which happens to be this one over here, is in the cell 2,0.
We need to turn that coordinate into a single number to make it easy to work with though,
so we can just do something like multiply the x and y by two different prime numbers,
and then add them together to get some arbitrary hash value.
We can then wrap that around the length of the array so that it becomes a valid index,
3 in this case, and let's call that our cell key, not to be confused with the seal people.
So since this was point 0, we'll store the cell key over here at index 0 in the array.
And the next point, it turns out, has a key of 6, and so we'll record that in the next
place.
And so on and so forth for all of the particles that we have.
Now we want the points that share a cell to be next to one another in this array, so that
we can efficiently loop over them.
Of course if they're in the same cell, they're going to have the same cell key, so we can
simply sort the list based on those keys to do that.
And now we can easily see from this array that particles 2, 5 and 7 are all together
in the same cell, particle 0 is in a cell all by itself, and so on.
Anyway, let's call this array our spatial lookup, because that sounds nice and fancy,
and then the final thing we need to do is create a second array of start indices, which
looks like this.
To understand this second array, let's just do a quick example.
So say we want to know which points are in this cell over here.
We would first calculate the cell's key like before, which is 9 in this case.
And then we'd proceed to look up the 9th element in the array of start indices, which
is this last one over here, the number 6.
That lets us know that we need to head over to index 6 in the spatial lookup, in order
to find the first entry with the cell key that we're interested in.
We can then simply loop over all of those to get the indices of the particles that are
in that cell.
Unfortunately it is possible for different cells to end up mapping to the same key,
which would mess with these results, but we're anyway going to need to do distance checks
to see which points are actually inside the smoothing radius, and so that'll get rid
of any mistakes.
Obviously, having to check extra particles from some other random cell that just happens
to have the same key does waste time, but that's what we get for trying to implement
an infinite grid with a sadly non-infinite amount of memory.
Anyway, turning this concept into code didn't go as smoothly as it possibly could have,
but after a bit of frustration, here's what I finally ended up with.
We have a function for updating the lookup whenever the points have moved, and this just
calculates the cell key for every particle, and records that along with the particle index.
The array is then sorted based on those keys, and lastly the start indices are calculated,
simply by testing if each key is the same as the key that came before it, because if
not then it must be the first occurrence of that key, and we can record its index as the
start index.
Here are the little helper functions, by the way, for calculating the cell coordinate,
hash, and key.
Then finally there's the function that allows us to actually find all of the points within
the radius of some given sample point.
This works as we've seen by just looping over the 3x3 block of cells around that sample
point, and calculating each of their keys.
Each key is then used to look up the start index for that cell, so we can loop over all
the points in the cell, and of course once we reach a point that has a different key,
we just exit out of the loop.
All that remains then is to do a quick distance check to make sure the point is actually inside
the circle, and then we can do whatever we want with it.
Trying this out now, we've gone from barely 5 frames per second up to 120, so there was
a reasonable success, but I'd be a lot happier about it if our simulation wasn't in total
chaos over here.
One clunky way I found to improve this is to simply start off with a really low pressure
multiplier.
This way the particles don't have such a huge initial burst of acceleration, and they
can spread out a little, and then we just gradually increase the multiplier, and it
seems to work a bit better at least.
That's not really a usable solution though, so I've just been implementing an IGRI
read about where we basically predict what the next position of each particle is going
to be, simply based on the current velocity, and use those predicted positions when calculating
the densities and pressure forces.
I guess this could help the particles to better react to upcoming situations, and maybe compensate
a bit for the fact that time is obviously not continuous in a computer simulation, but
rather broken up into discrete steps.
Okay, let's try it out.
I honestly don't see it making a big difference though.
Never mind, it's actually making a pretty massive difference I'd say.
Well, that's a nice surprise.
Also fun, I've quickly gone into the particle rendering code I have here, and just set it
up so that we can visualise the speed of the particles with a colour.
Then here's a little gradient I made for that, so the slowest particles will appear
blue, fading to red for the fastest particles.
I also added in some simple controls for things like pausing the simulation, stepping through
frame by frame, and resetting it.
Alright, I've been playing around with this some more, and one thing I've noticed
is that it behaves very inconsistently at different simulation frame rates.
Here's a little grid of simulations I set up to observe this problem, so we're going
from 60 simulation steps per second on the top left, to almost 1000 steps per second
on the bottom right.
And as we can see here, if the number of steps is higher, meaning the time step is smaller,
and so we're predicting less fine to the future, the particles take longer to settle
down.
So even though this feels a bit wrong to me, I'm going to try just removing the delta
time here, and use a constant look ahead factor instead.
Let's then run the same comparison again, and interestingly it is actually behaving
a lot more consistently now.
Well okay, I guess we'll go with that then.
Now I think it'd be fun if we could interact with the particles in some way, so I've written
this little function that basically just pulls nearby particles in towards the mouse, or
pushes them away if the input strength is negative, which is controlled by left or right
clicking.
So let's give it a shot, I'm going to start by pushing these particles outwards,
and then let's try slicing through the fluid.
Alright, I feel like this is slowly starting to get somewhere.
Clearly, we haven't really succeeded in our goal of making this fluid incompressible,
it's certainly compressing and expanding all over the place, but the density does even
out over time, so that's something at least, and we can look into fancier methods to try
and solve this better in the future.
Anyway, now that this seems to be somewhat working at any rate, I think it's time we
brought gravity back into the mix.
So I'll reset this quickly, and let's bring in our settings window.
I feel like the density could maybe be set a bit higher, so I'll turn that up, and then
let's get the simulation going again.
Okay, I guess that's a little too high now.
So, I'll dial that setting back down a bit.
Then, let's turn on the gravity.
Wait, that's upside down, let me make it go the other way instead.
The particles are quite wild at the moment, so I'll also increase the pressure multiplier
to try and drain them in a little.
Okay, let's try picking up a ball of water.
And dropping it back in.
Splash.
This is actually working surprisingly well I'd say, I mean I realise I've been droning
on for over half an hour already, but all that we've really done is made a bunch of
points that don't like to be too close together, but not too far apart either.
And while this is obviously far from being super realistic or anything, I think it's
still quite fascinating that this fluid-like behaviour has already arisen from just the
few little things we've implemented.
Anyway, let's see if we can still improve this at least a little bit more today, and
perhaps even venture into the third dimension.
So a few issues are jumping out to me at the moment.
For example, there's the fact that the particles are really tightly squeezed together along
the edges here, and that's causing a gap between the rest of the particles since they're
trying to get away from that overly dense region.
And a similar effect seems to be happening along the surface of the fluid as well.
Another thing is that when we have fast-moving particles, such as when starting up the simulation
for instance, the fluid seems to be overly chaotic.
For example, if we zoom in on a single frame here, we can see from these colours how the
velocities are all over the place, even between nearby regions.
For this last problem at least, I think it'd be a good idea to try and add a bit of friction
between the particles in the fluid, more commonly known as viscosity.
So let's actually take a moment to look at the famous Navier-Stokes equations for incompressible
fluid flow, which underpin everything that we've been doing.
First of all, this equation here just says that the density of the fluid must remain
the same everywhere, and I mean, we're trying.
Then the other equation tells us that each tiny little volume of fluid is accelerated
down the pressure gradient, and that it responds to external forces such as gravity and mice
in our case, so we've done both of those terms.
But then this slightly scary looking term here is the viscosity, and essentially what
it does is cause the velocities of nearby regions of fluid to become blurred together.
Now we could implement it this way, but for today at least, I actually want to go with
a different approach I've seen that seems much simpler, but still achieves the same
sort of thing.
So I've added this little function here, which just takes in the index of a particle,
and loops over all the other particles within the smoothing radius.
For each of those, it then calculates the difference between the velocities of the two
particles, and adds that on to the viscosity force, meaning that over time, each particle's
velocity will become more like its neighbors, and nearby neighbors have more influence as
usual, which is done using this viscosity kernel, for which I've just repurposed that
function that we were originally using for the pressure force.
Okay, let's try it out.
Oh, my settings have been reset, so we're back to no gravity at the moment, but let's
see what that looks like.
Currently, our viscosity is at zero, so let's turn it up, I'm not sure what a good value
would be, let's just try 5 maybe.
Nope, definitely not, that looks very strange.
My guess is that the viscosity is just way too high at the moment, and so some of these
particles are almost exactly matching one another in velocity, and that's causing
them to clump together weirdly.
So let's reduce it to maybe 0.5 instead, and see how that goes.
Okay, this is looking pretty good actually.
We can see how the particle velocities are more smoothed out, and so we no longer have
those few particles with super high velocities shooting off on their own.
I want to see how this looks with gravity enabled again, so I've set up a quick comparison
here with a range of different viscosity values, and let's see how it goes.
I think the one on the top right looked best to me, but let's see that again quickly.
And I'll freeze it here actually, because this gives us a nice view of the increasingly
smoothed out results we get with this new artificial viscosity term.
Obviously, we don't want to smooth out too much detail though, so I'm going to keep
that value pretty low.
Okay, now I'm not quite sure yet how to tackle that boundary problem I mentioned earlier,
so I'm going to just ignore that for now, and instead work on something else that's
bothering me.
If we lift up a bunch of water, and then let it go, we can see how it quickly splits up
into these little droplets of just a few particles each, which looks a little strange.
We could get rid of this behaviour by simply clamping the pressure values that they can't
go below zero, meaning that the particles won't pull each other together anymore.
So let's try that out.
But now the particles are just raining down individually, which doesn't look right either.
I guess allowing that negative pressure was giving us a very crude kind of surface tension
effect, and so I think until we implement a more accurate version of that in a future
video perhaps, we should probably hang on to it.
So I'm going to undo that change, and instead I want to try an interesting workaround one
of the papers suggested, which is to simply have a second pressure force, purely for pushing
apart particles that get too close together.
So this is the shape of the smoothing function we're using for our density calculation at
the moment, and what the paper recommends is to use another, even spikier version, to
calculate what they call the near density.
From this near density, we calculate the near pressure, simply by multiplying it by some
constant, meaning that this will be a purely repulsive force.
So let's try it out quickly, and just for fun, I'm going to see what happens if we
make the near pressure multiplier negative.
Okay, they just collapse in on one another, which makes sense, so let's then try a positive
value.
And now I want to try picking up a ball of fluid again, and dropping it.
And as we can see, this time it's able to hold its shape a lot better, since the particles
are no longer getting pulled into those tiny clusters we saw before.
So I think we've succeeded in improving the fluid a bit with these last two changes,
although I'm certainly not entirely happy with how it's behaving yet.
For example, something that bothers me quite a lot is how it often appears to sort of bounce
more like a jelly than a liquid.
This is happening pretty much all the time, but we can see a dramatic example if I just
let the fluid come to a rest, and then change the target density for example.
Now we could get less jiggly results simply by increasing the pressure multiplier, which
is often called the stiffness constant by the way.
So here I've set up a little test where it has a value of 1000, and if I change the
density now, we can see that it does settle down a lot more quickly.
But that doesn't come for free though, because the greater the forces in our fluid are, the
more simulation steps we need to run per frame to avoid things devolving into chaos.
For example, if I just lower the number of steps here slightly, we can see that already
we're on the brink of pandemonium.
Anyway, I'm sure we'll learn about ways to overcome, or at least improve this problem
in the future, but for right now what I'd like to do is finally convert the whole simulation
to a computer shader, so that we can run it on the GPU, which excels at doing loads
of tiny tasks in parallel, which should be a perfect fit for our particle calculations.
I doubt that'll take very long, so I'll see you in a minute.
Ok, I kept finding new and creative ways to mess everything up, but this finally seems
to be running properly in a computer shader.
I'll still need to test the performance with more particles of course, but just glancing
at the FPS counter looks promising so far, hovering at around 500 frames per second.
By far the trickiest part was translating just one line of code, the array.sort from our
neighbourhood search.
I ended up spending quite a while trying to figure out how to implement a parallel sorting
algorithm called bitonic merge sort to replace it.
In particular, I was trying to generate this pattern of lines, and generalize it for any
number of inputs.
The inputs here are represented by the horizontal lines, and we have 16 of them in this case,
meaning that this network can sort 16 values.
Let's actually assign a random value to each input, so we can see how this goes.
Then each of these little vertical lines represents a pair of inputs that we're going to compare,
and potentially swap around.
So to start with, we're going to look at each of the 8 pairs that we have over here,
and let's say we want to sort from high to low, so in the first pair we have 5 on top
and 3 on the bottom, which we're happy with, so that can stay unchanged.
In the next pair though, we can see 7 on top and 8 on the bottom, so the bottom is a higher
number which is not ok, and we'll need to swap them around.
So we can look at all these pairs in parallel, figure out which need to be swapped, and then
swap them.
Of course this alone is unlikely to sort the list, so once that's done we'll need
to continue to the next stage.
Here the pairs are arranged a little differently, but the operation is still exactly the same.
We can see this first pair has 5 on top, 7 on the bottom, so it will need to swap, as
will this pair with 3 on top and 8 on the bottom, and so on.
This pattern has been carefully devised by some clever person, such that following it
will do all the comparisons required to guarantee that the result is fully sorted by the end.
For anyone interested, I'll quickly show the implementation I came up with, so this
part runs on the CPU and is responsible for simply looping through each of those patterns,
and telling the GPU to sort the pairs.
And then here's the code that actually does that pairwise sorting, so it starts by just
figuring out which pair of numbers it's actually looking at, and then it compares
them to see if they need to be swapped, and if they do, it of course swaps them.
Alright, I've been doing some testing with different amounts of particles, so here is
100 particles for example, and I think it's kind of cute watching these little droplets
wobble about.
Then after that I tried 100,000 particles, but my computer was not happy about that,
so there's definitely a lot of room left for optimization.
Here's a test with about 40,000 particles though, which seems to be running okay, although
I'll have to fine tune the settings of course, because at the moment there are some weird
tendrils shooting out of the liquid, and I really don't know why.
Or perhaps we could call this a speculative simulation of how liquids might behave on an
alien planet.
The settings are definitely quite finicky at the moment though, so that's something
else I want to improve.
Here's another little test I've set up by the way, and this one has an obstacle over
here with a gap beneath it, because I just want to see if this simulation is able to
keep the height of the liquid the same on both sides.
So I'm just going to start bucketing some of this liquid over to the other end here,
and then let's grab another blob, and another, and then let's just wait a bit for this to
settle down, but already we can see the height gradually leveling out.
So even though our simulation is far from being super realistic, it's nice to say at
least that it's not entirely unrealistic either.
Okay, now as always there's so much more I still want to do, but to end with for today,
let's see if we can get this working in the third dimension.
This basically just means replacing a bunch of float 2s with float 3s in the compute shader,
as well as updating the scaling factors of the various smoothing functions and their
and making sure our neighborhood search is aware of this brand new dimension as well,
of course.
I've also updated the collision function to work in 3D, and I tweaked it to account
for the bounding box being moved or rotated as well as scaled, simply by transforming
the points and velocities to its local coordinate system, then resolving those the same as before,
and then finally transforming them back into world coordinates.
My first attempt at running this did not go particularly well, but after some trial
and error with the settings I managed to get this rather goopy looking result, and with
a few more tweaks from there I was finally able to get something that I was reasonably
happy with.
So let's just play around with this a bit, I'm going to try squeezing it together,
and what's nice about how we implemented the neighborhood search stuff, is that we
aren't constrained to any predetermined bounds, so we can stretch this out however much we
want as well, and it should still work.
Those little waves were looking quite nice I think, so let's actually smush this together
again, and then try that out once more.
Now another thing to add to my list of a million things I want to improve is how the
fluid is actually rendered.
These little balls are good for seeing what's going on of course, but it would be nice to
make it actually look more fluid like, and I guess some sort of ray matching is probably
a good way to approach that, but we'll have to see.
So let me actually make a quick note here of my sort of wish list for this project.
I want the simulation to be more stable and performant so that we can have many more particles,
and I'd like the parameters to be less finicky so it's easier to get good results, and also
for the particles to behave better along the boundaries, because it looks really odd at
the moment.
Another thing that'll be really nice is to be able to do stuff like put little boats
or rubber ducks in the water, and just watch them bob about.
Then finally of course there's the rendering stuff I just mentioned as well.
So plenty of work for the future, but until then I hope you've enjoyed following along
with the process so far.
Okay, that's all for today, let me know if you have any suggestions for this project
or for anything else you'd like to see.
Alright, thanks for watching and goodbye.
