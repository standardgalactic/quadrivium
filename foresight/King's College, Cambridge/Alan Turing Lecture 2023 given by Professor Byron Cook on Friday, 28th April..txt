Hello. Welcome everyone to the sixth annual Turing lecture. This lecture series is a part
of a broader effort at Kings called the Alan Turing at Kings Initiative. And this is an
initiative to raise funds for studentships, fellowships, and other academic endeavors.
These lectures are essentially all of them are focused on topics that somehow relate
legacy of Alan Turing. And today's talk is going to be about what computer scientists
like to call formal methods. And this means applying logic and mathematics to the reasoning
about the correctness of programs basically, or building tools to help people do that kind of
thing. And our speaker Byron Cook is a professor at UCL and a vice president and distinguished
scientist at Amazon. And Byron has been sort of at the cutting edge of actually applying formal
methods in the real world. So the work he did, for example, at Intel very early on when Intel
was having problems with chip design, I don't know if you remember the Pentium bug, but that certainly
stimulated a lot of effort to use formal methods in proving the design of circuits
correct. Byron then went on to Microsoft where he developed a lot of verification tools that were
essentially solving the problems that Turing proved were unsolvable. And it turns out many of
them are solvable in practice. And that sort of that work got rid of the blue screen. Remember
the blue screen of death from Microsoft? Well, that work pretty much got rid of that blue screen
of death. And then from there, Byron went on to Amazon where he really spearheaded the formation
of formal methods groups at Amazon. And today Byron tells me there are over 600 people at Amazon
working on formal methods, and over 20 groups doing that kind of thing. So apparently this kind
of work touches every aspect of Amazon's development and rollout of their services. And I just want
to say that when I did my PhD in kind of in this area back in the 80s, this was considered like
kind of crazy stuff that no one would ever use, that was too impractical, it was focused on toy
problems. No one is ever going to use this stuff. And I think for me, it's very satisfying to see
what someone like Byron is doing now, like actually bringing these ideas and technologies
into the real world, making real impact with them. So I'd like to introduce Byron.
So we finally figured it out. And it's a huge honor for me to be invited and to be associated with
Alan Turing and Kings. I hope you all read the abstract and know what you've signed yourself
up for. So I'm going to tell you, I'm going to attempt to tell you something rather technical,
but I've promised to aim it at a general audience, and I think I'm going to fail horribly,
but let's have a good time together. So we'll see if that works. As I was preparing this talk,
I'm like, oh, what have I done to myself? But I think this talk brings something for everyone.
So I think that the technical people in the space will enjoy pieces of it. And then those of you
who don't come from the space, I hope you'll take away something from it. That's interesting to you.
So this talk takes a needle and thread through a bunch of characters that are Cambridge based.
I was really excited to be invited to give this talk because it's a very Cambridge story.
There's a King's story. So there's some characters that were King's people. Frank Ramsey is a really
interesting character. I mean, he's a lot less well known than Turing, but also very, very important.
King's person, sort of the boy of wonder actually born in Cambridge, born just on the other side of
Jesus' dream at the locked bridge, the house when you cross the locked bridge. He was born there.
And then because father was at Muddlin, and then he was here. And I think he worked with this chap
quite a bit. And then, unfortunately, he died. I read his new biography about him. And from what
I can work out from the biography, he died from a disease he caught by swimming in the camp. So
you need to be comfortable. And then Alan Turing, I don't think I need to introduce.
There's another character, which is the spinning beach ball on the top left, just above Frank
Ramsey. And so some of you may be familiar with this concept. So I'm going to give you a bit of
IT advice. So if you take nothing else away from this talk, you can take this. When you see that,
what you need to do is you need to go into the force quit applications of your Mac, find the
program, and kill it. And hopefully that will take care of it, though it might be there's an
infant. So then what's happening here is there's an infinite loop in one of your programs, and
it's causing it to hang. Hopefully it's not in the operating system, because now you're really
in trouble. But if it's in, but if it's in the, but if it's in like a Chrome or Outlook or something
like that, you'll kill it, you'll lose your data. But you know, that's, that's how it goes. And if
you use Windows, this is kind of what it looks like in a similar situation. If you use a phone,
this is what it would like to look like. But I believe the phones are designed that after a certain,
quite short amount of time, they just reboot the phone. So the Mac, luckily, doesn't reboot itself
every time that it gets stuck in an infinite loop. But the phones, I think, are designed to
just, just reboot. So you may, and you may not even notice the way that the phones are assigned.
But we also have this problem. So it turns out that our bodies get, there's little infinite loops
sometimes that we find very unpleasant. So this is skin cancer. And it turns out that skin cancer
is, in a sense, the, the, the regulatory mechanisms in your, in your body to maintain
cell growth and death. And so skin cancer is your bug, is your body kind of going into one of these
states. Okay. So the quest is to build tools that can talk now about what's going to happen in the
future. So we want to, we want to build a tool that takes a program and says things that usually
have the word eventually in them. So, hey, you know, like, when I press this button,
does do the rockets eventually launch? Or, or, or when, you know, like, if I ask this question,
will I eventually get the answer? Or if, or if I model disease as a, as a, as a system, and then
I want to like make a change to characterize the change, I think that we should make for, for, for
medicine. Now does the system eventually do the thing I wanted to do? Does the, does the, does the
cell growth stop and, and, and, and, and we, we reach homeostasis. So that's, that's the kind
of things we want to do. And we want to do this without actually running the system. We want to
take the system and reason about it. Because we may not have the whole whole of the entire system.
And also we don't want to like interact with the world, but we don't actually want to launch the
rockets to learn the law, rockets will be launched. We want to ask, you know, in some theoretical world
where we launch the rockets. Okay, so just a bit of bookkeeping. I know myself, and I'm going to use
all these words to mean the same thing. So I just, just, just to take a moment, the halting problem,
the question of program termination, finding infinite loops and talking about systems that,
like trying to show that systems don't hang. It's all the same thing. So when you hear me talk,
say, in one breath, I'm saying program termination and, you know, three breaths later, I'm talking
about the halting problem. It's all the same thing. This is, this is again for the, for the
non-technical people on the crowd. Okay, so what is program termination? So for those of you who
know what program termination is and know what programs are, bear with me for a moment. We're
going to take a one-minute tutorial on programs and program termination, but also this program will
show up from time to time. So, so it's sort of worth it to everybody. So here's a program. I'm sort
of assuming a few of you are in the, I know at least one or two people in the room don't, don't
know how to program because they're my family. And, and so what this, this is a program written
in Python, a language called Python. And what happens in this program is the first thing it
does is it says, this is a, a while loop. So it says, Hey, is in greater than one? If, if so,
go here, do what it says, come back and then ask again. Is in greater than one? Okay, go here,
do what it says, come back, ask again. And the idea is, is that this code here is modifying in
and the, and, and one would hope that eventually the code that's modifying in would make in be
that not greater than one, in which case now the loop would terminate. Okay, so that's the idea.
So this is a computer program. That's a while loop. Sometimes while loops, you want them to run
forever. For example, like you're, you want your actual computer to run forever, but inside the
computer, inside that loop is often some code that you really want to terminate. And that way
you can get back to the start of the loop. So often systems are written with one big while loop
that you want to run forever. And then code inside the while loop you want to terminate. And that
code may look something like this. Okay, that was your one minute tutorial. This is a really
interesting program. So this is a wicked little program actually. So this is called the Colatz
conjecture. And no one knows if this program terminates. And what I mean by that is,
so a program is, we would say it guarantees termination if for all possible values of in.
So in here actually could range over all mathematical integers. And so for all possible
values of in, does this program guarantee to exit? No one knows the answer to that question.
So program guarantee termination, if you know that's true for all possible, no one knows.
And this is, there's some really great quotes here. So I wonder if this has a pointer.
Yeah. So this is called the Colatz conjecture, but it's also called the three and plus one
problem. It has some great names, whereas it, the Hellstone numerals, the Thwaites conjecture.
And then look at this great, great quote here that from Paul Orteff. Mathematics may not be ready
for such problems. It's extraordinarily difficult, completely out of reach for present day mathematics.
Look at that innocent little program. Okay, now as an aside, my colleague in Amazon,
Marine Hula is so close to solving this puzzle. It's agonizing. I was really hoping I could say
today, oh, and by the way, at Amazon, we solved it mic drop, but, but alas, I wasn't, alas, I wasn't
able to. So he has this really, really fascinating paper that's very, very insightful, that combined
some really beautiful, it's just, it's such a beautiful paper. So they're really making some
serious headway on this problem that I'm very excited about. Anyways, and, and back to Cambridge,
back to Cambridge. So, so there's another really interesting character that's, that's, that's,
that's, so, so, Frank Ramsey was the Kings, Alan Turing was the Kings, and Byron Cook,
oh, you know, cycled by Kings. For, for six years, I cycled by Kings, and I cycled
by Kings on my way to Microsoft Research, which at the time was that in West Cambridge,
now it's by the station. And when I cycled to, to, to, to, to Microsoft Research,
a lot of my work was with these two jobs. So this is Andre Rybolchenko, who is my intern,
and then a longtime collaborator, he's actually later joined Microsoft Research, and then Andres
Podolski, who is his PhD student. And, and what happened was that I decided to move, I'll tell
you part of the story, I moved to Cambridge. And when I moved to Cambridge, a bunch of people who
were in Europe, you know, I moved, you can probably hear, I'm American. So when I moved
to Cambridge, a bunch of people who are in Europe were like, oh, wow, cool, we should work together.
And these, and these were one of the, one of the, one of the sets of people who do that.
And so I did this work with them that was really explosive. And so I ended up the, all the, all
these other people were like, wow, that's super cool. We should like, there were like possible ways
that we can solve other problems that were related. So I ended up working with a whole network of
people. And it was really a very, very exciting time. And many of these people spent much of their
time in Cambridge. And there were, of course, many scientific papers. And they all used theories
from Ramsey and Turing. So that's, that's, that is what we're going to talk about today.
Okay, let's start at the beginning. So, and here I'm going to, I'm going to do a little bit of
guesswork. So I, so I don't know if you know that there's this, the Greeks, the ancient Greeks had
this like, calculating device, right, that would, that would, that would predict eclipses, for example.
Meanwhile, they're also doing proofs, right? They have, they, they, they, the Pythagorean
theorem, you know, there's all this work kind of in the, the Greek empire. So it must be,
and here I'm just guessing, it must be that someone in town, sorry, some, someone in town
thought, hey, could we get the device to prove theorems for us, right? It's just, it's inescapable
that that's true. So I would believe that that must be when, you know, our, our people, our ancestors
first said, machines, mathematics, let's put them together, right? But what, what I do know is that
from the, from the, is that Leibniz explicitly asked us, right? So, and we calculate the truth
of any mathematical statement. That's the sort of fundamental thing we want to do. And so here's
what this would look like kind of in our modern world. So imagine on your phone, you have some
magic AI app, and you could ask it simple questions like, hey, is there a number between,
this is an easy one, is there a number between 10 and 20? Yes, there is, 11, try that, okay.
Is the Colatz conjecture valid, right? And, and the, and the idea is that the answer produced
must be correct. That's the game we're playing. That's, that's what Leibniz suggested. And that's
what, you know, we're going to talk about much of today. And, and maybe it's not an acceptable
answer. You can't say maybe in this sort of, in this, in this purest Leibniz world, and you can't
run forever trying to, as well, give me, give me some time. And I'm going to go off and compute
forever and just never come back, come back with an answer. No, that's not allowed either.
You have to answer the question, and you have to answer it in a finite amount of time. That's the
rules of the game. Today, we would call this automated reasoning. So if you look at like my
title, or like the groups that we have, the groups in Amazon, all these like 20 teams are called,
you know, identity automated reasoning team, or crypto automated reasoning team, storage
automated reasoning team. So automated reasoning is what we do. And practically, there's a few
people from the crowd, you're all laughing, because you, you, you know, that we've kind of given up
on requiring you can't say maybe or time, or time out from time to time, right? So we're
practical people and we're like, eh, sometimes we don't know the answer, right? But, but, but the
purists didn't think that. So in this, this paper, paper book by Hilbert and Ackerman named it,
the decision problem. And I'm not going to try and pronounce the German, right? But it's,
it's called the decision problem. And this, this was came out in 1928. And this got everyone in
the mathematics logic world very, very excited. So back here in Cambridge, both Ramsey and Turing
were like, Oh, the decision problem, that's super cool. Can you automate reasoning about mathematical
logic and mathematics, such that you always get an answer, you know, super cool, super cool problem
for them. And they, and they, and they both did some interesting works. And now we're going to talk
about that. So Ramsey had this, had this very nice paper right before he died, unfortunately.
And he didn't prove or disprove the possibility of there being a general solution to the decision
problem. But he, but he did something else instead. And so what I'm going to, I'm going to, I'm going
to, we're just going to take a moment to introduce a little bit of visual notation. So there's an
idea of a graph. Graphs have nodes, graphs have edges, edges are the arrows. And the idea is you
can go from A to B if there's an arrow. Okay, that's a graph. That's a sort of fundamental
concept that you see in computer science and mathematics. And what we could do is we could
color the edges. So I could color some of them red, some of them blue, some of them green.
And then what Ramsey did is he has this really, really amazing result that's about
monochromatic subgraphs. So here's, here's, here's a monochromatic subgraph. It's, it's like the
original graph, but with only the red arrows. And there's sort of different flavors to the Ramsey
theorems, or there's a sort of Ramsey theorem is kind of a family of statements. But what's really
amazing about it is he says, if, if your graph is infinite, I can't, I can't show you an infinite
graph on this finite screen, but imagine it's infinite. If you have an infinite graph, and a
couple of other conditions are met that I don't really want to tell you about, because they
knows to turn into a math lecture, then, then there exists an infinite monochromatic subgraph.
And that's going to turn out to be a very, very powerful tool for us. So take this graph,
if it's infinite, it's also complete for those of you who know what that means, but it doesn't matter.
And, and the number of colors is finite, then there's going to be an infinite
monochromatic subgraph. Okay, remember that. Meanwhile, Alan Turing read this paper
by Kurt Gertl that was the start of the argument as to why there could be no solution to the
decision problem. And what he did was he wrote this paper that he's, you know, famous for,
I mean, it was, if you saw the exhibit today, you saw his copy of the paper. And, and I mean,
I think this is, this is probably the most studied theoretical science, theoretical computer science,
I mean, basically started theoretical computer science. So this is like absolutely fundamental
paper. And so he's, I'm going to, I'm going to frame this in terms of graphs. But he basically,
you know, you know, I don't want to overstate this too much, but you can basically invent the idea of
like the, the, the, the idea of what computation is, like, I mean, people were doing computation
before and we had machines, but, but essentially he's like, he talked about that in terms of,
he combined that to mathematics, let's say. And again, we can think of like a Turing machine,
you can think of as a graph where it's like, what are the possible transitions between,
between, between a Turing machine. So I'm going to, I'm going to explain this with my phone.
So by the way, the iPhone is like so much more powerful than anything he probably could have
possible imagined, right? So it's a really, really, it's a super computer in your, in your,
in your, in your pocket. And so, so here's me and my phone, I open up my email, I write reply,
and then, and then I hit send. Okay. And then, and then in the sort of Turing view,
each state of each configuration of my iPhone is a state, and then you have transitions between
the states. So I can go from me opening it, seeing Tim's mail, saying my reply, hitting send, that,
that's, that's a progression. And that, and that states, states and configurations. Okay,
that's a little, that was a little bit of background. Let's look at this program. Remember
this one? I've added, by the way, the, the line numbers. So you could have a state of the system
where the value of n is 20, and the location is location one. So we're at this line of the program,
and n is equal to 20. And then we can transition to the value of n being 20, and the location being
20. Okay, get it? Okay. So what he said was, is that we know that there will be, always be programs
for which we can't answer the basic question of termination. So it's, it's what we say is, it's,
it's undecidable, right? So I, the answer is no, we cannot calculate the truth of any mathematical
statement. Because if you could, the, the, the question of program termination is one of those
mathematical things. And he sort of linked up the idea of computer programs to what's computable,
to mathematics, and then said, well, this thing can't be solved and the, and he bridged the gap
over to the mathematical side. Super cool result. leaves us in a bit of a lurch, though, in terms of
like he sort of identified a sort of Achilles heel of computers. And so I'll, I'll, I'll illustrate
that by what was stressing me out in 2003. So here's a list from Microsoft.com, sorry,
and the I'm going to poke on Microsoft a little bit now that work at Amazon of, of, of device
drivers that you could download. And you could put these in these, you could put these into your
machine. And each of these device drivers is backed by source code. And the problem is that
there may be device drivers out there for which we can't answer the termination question. And boy,
when a device driver goes into an infinite loop, we're in a world of hurt, like that is a really
bad situation. Because now like you, your, all your programs are going to start hanging, like
that this can be, this can be a very, very bad situation. We don't want that to happen.
So non-terminating device drivers hang your computer and hang them often in quite bad ways.
But what's not so known, who knows about raise your hand if you know the paper, checking a
large routine by all in turn. One hand, that's staggering. Really, you don't know this paper.
People, people in automated reasoning in, in, in Amazon, pull up your hand if you don't, if you,
if you work for Amazon and you don't know this paper. That's interesting. Okay. Great. Well,
you're going to know about the paper. I think this is one of the most interesting papers there is.
This, this comes from 1949. He totally tells us how to do our job. It's amazing. So, so he gives
a very clear instruction for how to prove a program terminating. 1949, I think. And so I'm,
now I'm going to put a few words in Ellen Turing's mouth. So he doesn't quite say this, but he says,
but basically between the, read between the lines, what Ellen Turing is really saying is,
in practical cases, we can answer the termination question. And then furthermore, in cases where
we can't, we just return maybe, what's the big deal? Right? Like, it's like, yeah, yeah, yeah,
I proved the halting problem undecidable, get over it. Like, life moves on. Now we need to do
practical stuff. We have computers. Remember the war, like computers are cool. Let's, let's, let's,
let's do good things here. And so to think about this, think about like British Airways, right?
On time arrival is not guaranteed. But, and I know you're probably all winging about British
Airways right now, but they're pretty good. Like you, you do often arrive most of the time, right?
You arrive, you arrive, you get on time arrival often enough that you think, I'll fly again.
So, so, so they're, they're not horrible. So the real, the real thing that they need to do is just
to make on time arrival frequent enough to make the airline useful to their customers.
And it's the same with, with Termination Prover. So if you're building a tool to analyze termination
of program, so long as the tool answers often enough with the right answer, then, then you're
going to use it even if you're, even if you know from time to time, it's not, it's not, it's not,
it's not going to give you, it's, it's, it's not going to be able to answer it. And, but, you know,
the answers need to be correct. Yes or no answers need to be correct.
Okay. So in 2004, what, what Andreas and Andre, and I, oh, sorry, I want to say something else.
This paper on the left, the Turing's famous paper,
has kind of been a buzzkill in, in the, in the IT industry. It's, people do not, what's the,
the thing is you do an improv, you don't say no, you say yes and right. So there's a whole lot of
people who didn't study improv apparently in the IT industry. And so if ever you have some idea,
like, oh, I know we could do X, Y and Z, someone's going to be like, that's the whole thing problem,
you can't do that. And oh, I feel shame. Sorry, I suggested it. Let's not solve the problem at all.
Sorry. And that's, that happens a lot. I mean, I've seen that personally a bunch of times that
you hear that a lot. So this is like the most abused theoretical results in computer science that
because it's the halting problem, don't even try, you know, like life is too hard.
But very, very, very few people in 2004 thought it was, it was practical, even in my own field.
Like, you would talk, you would talk to people on my own field. The vast majority of people would
be like, but it's undecidable. But it's like, yeah, but so is the state space reachability problem
for infinite state systems. But they did, oh, yeah, forgot about that. So, but, but with,
with the exception of some brave souls. So there were a few brave souls that were, that were trying
to solve this problem. But the problem for them is that their tools all solved this only for
little tiny programs, like little eight-line programs, seven-line programs. So they, and they
didn't have sort of any of the actual features you'd see in real programs like pointers and
concurrency or any of that. So they were fun. They're super fun, but they weren't actually going
to solve anything. And so that's, that's where Terminator steps in. So this is a tool that Andre
and Andreas and I wrote. And by the way, if you're Cambridge people, do you know this ride?
Have you seen this? I don't know if they have this anymore. So this is at least when I lived here
in the mid-summer, common every summer, they would truck in these rides, right? And so then
this was one of the rides. So I was looking through my photos for this talk, and there's so many
photos of me in front of the Terminator ride because I did Terminator. Okay. So, so what we did
is we, is we looked at this, the Turing paper and had a good read, right? So what we realized was,
is that, hey, there's actually two parts. And I'm going to tell you about that. So there's two
parts to solve and you can still solve them with independent bits. And then, and then, and then,
and then you're done. So now I've put up a paper, I put up three paragraphs from a paper that's 74
years old, that's referring to a figure that's not included in the screenshot. So we're not going
to make it very far through this paragraph clearly. And it's written in language no one would know.
But I just draw your attention to the first line. I move over here so I can see it.
In order to assist the checker, the checker is the person doing the proof or the tool.
The programmer should make assertions about the various states that the machine,
that's the program, can reach. And the reach is a really interesting bit. So,
so imagine that these states are unreachable. Imagine these states are reachable. But that
turns out there's no path over here. And here's a little infinite loop. Here's a what is that six
states that could be repeated forever over and over and over again. So imagine this is my iPhone,
so I have six configurations of my iPhone and they're just going around and around and around
between those configurations. But it doesn't matter because it's unreachable. So there's tons
of termination bugs in your phone, tons of termination bugs in your computer that are never
going to be triggered. You're never actually going to experience them because they're unreachable.
And that first three paragraphs is all about that. It's just about reachability.
So, yeah, kind of, I think I upset that. So we were like, okay,
turns out I worked on reachability. So we know how to do this, right? So let's,
let's, so what, what, what, why was I working on reachability? So now we're going to take a
little, a little psych, we're going to move over to Seattle for a few moments. So it turned out in
2003 that 85% of crashes in Windows XP were due to device drivers. And that was a big business
problem for, for Microsoft at the time. So what we built over in Seattle area was a real world
automated reasoning tool called static driver verifier in the research community. It was called
SLAM, but for device driver writers, they knew it as static driver verifier. And what it was designed
to do was to show error states reachable or unreachable. And so if you, this is the blue
screen of death, you actually, you actually refer to that. This is the new blue screen of death,
by the way, which you don't see very often these days. But this is what you get when your machine
is like, sorry, lost all your data too bad, it sucks to be you. And this is what you would
see on a Mac. And this is what you would see on a really old Mac. And so the question is,
and I've sort of put this on purpose, is this line there or not? And remember these states,
these state spaces are typically infinite. You can't just walk them explicitly. You have to like,
you have to abstract infinite sets and do all kinds of trickery. But yes, we're trying to
figure out, are things unreachable or are they reachable? And so there was a whole bunch of
work that we did over in Seattle area. And I was involved in that. And Andrew Herbert,
who's in the room here, I was visiting Cambridge and he was like, why don't you leave Seattle and
come to Cambridge? The environment is great here and you'll have a good time. But I'm like, great,
let's do it. So we, with eight weeks difference between that conversation, five weeks difference,
my wife says, between that conversation and moving, I came, joined Microsoft Research,
started chatting to these guys and said, let's work on the termination proving. So the point
I'm making is that this problem was actually already pretty much solved. So it's just a question
of reachability. So the red part is actually about, okay, now we've found a reachable state. How do
we know that that reachable state doesn't lead to an non-terminating execution? And all the green
bit is just about how do you show that states are unreachable? Okay, so let's look at this one.
This one's fascinating. We're going to spend a little more time with this one.
Finally, the checker has to verify that the process comes to an end. That just, I'm translating,
that just means, okay, now we're going to prove termination. Again, he,
you know, he or she should be assisted by the programmer giving a further definite assertion
to be verified. So the point that he, what this he really in our, in our lingo today would be the
prover, the tool. And so this may take the form of a quantity, which is asserted to decrease
continuously and vanish. I'm going to translate all this, by the way, don't panic, and vanish
when the machine stops to the, to the pure mathematician is natural to give an ordinal
number. Don't, doesn't matter what that is. If you don't know, it doesn't matter. I love this line.
A less-hybrid form of the same thing would be two to the 80 times n minus r plus two to the 40 times
r minus, what is that, s plus k. Pretty cool, huh? Let me translate that. Can we find a function?
I'll call it a, based on the, on the state, based on the variables of the, of the state,
that will choose only positive, but also decreasing numbers. Okay. So imagine, let's look at my phone.
I took a screenshot when I was writing this talk. I had seven Slack messages at the time, unread.
So maybe the function is the number of Slack messages. One possible, it's not going to work
very well, but another one, maybe be the amount of free space left on my phone. That's a little
more reasonable. And then imagine we took a, a transition from this state to this state. I don't
know, like who knows what, internally, you can't see it, but it made some transition. Maybe the
amount of space, a free space has decreased, probably quite likely, right? Because of it,
because the phone's actually doing little logs and all kinds, like it's always sort of using a
little bit of more and more and more disk space, not disk, but you see what I mean. Whereas the
number of Slack messages, well, we can see it stayed the same. So I had seven before, seven
before, seven now. So that's not a good one. So this number didn't go down. So remember that the
point, the point we're trying to make is we want to find a function, a function, some function F,
that on every, that I'll always say this in a moment, that it finds decreasing, but positive
numbers. And so what do we, what would we do with that? Oh, I think maybe, okay. And yeah. So
here, for example, let's write a little function for this guy.
Maybe what we do is we say, oh, well, let's do in minus the location. So we were at, in this value
of 20, location is one. So maybe it's in minus X is 19. So it's just this number minus that number.
And then the next one is 18 because I've now subtracted two. Okay. So that's a positive
number and it's gone down. So that's possible. I mean, it's not going to work because no one
knows that the program terminates, but that would be a plausible starting point as you begin your
journey into this world. So the thing that we need to hold is whenever we take a transition
from one state to another state or configuration to another configuration, and we have that function
F and we map, the greater than needs to hold. So and if you, if you, if you say the pre-state is S,
and then we apply F to S, and then we say the post-state is T, and we apply F to T, you need
greater than to hold. And that's a condition that's required. So the idea of how to prove
termination, and this is Turing's idea is find a function, think about it for a bit. Then if this
condition holds for all possible transitions of your system, this holds, you're done. You've
now proved termination. Okay. Right. So if you turn your head, you can see it. 19 is greater than 18.
So now, why does this hold? So imagine a non-terminating execution. Again, this is infinite,
so I can't, I can't show it to you on the screen, but here's the first few states.
Now just begin applying this function. Oh, and by the way, we have the function. I already said that.
And this condition holds. Now let's just begin applying it. And I'm making these numbers up,
but imagine the first one's 30. We've got to choose 29 after that because it has to go down,
27, 25, et cetera, et cetera, et cetera. We're going to run out of room. It has to be positive also.
So now we're out of space. So I said, imagine we have an infinite execution, but we have
a function F that's positive and decreasing. It turns out you can't have both, right?
Right. And too far. You can't have both. You can't, you can't have a non-terminating execution
and this function. You can only have one of the other, i.e., if you want to prove termination,
find one of these, and you'll know that you don't have a non-terminating execution.
Or if you have a non-terminating execution, you can't have one of these. It's a, it's a, it's a,
there doesn't exist. If the program doesn't terminate, there cannot exist a function that
meets those conditions. And so the trick is to find the F, right? And so Turing found the posh
one and then he found the less posh one. Okay, I've kind of said already that. So now, so now
the thing that we wanted to do was to automate this. And so, so consider any reachable state
and, you know, maybe those states on my phone. And imagine we found an F, then it turns out
it's super hard to find a single F. Like, like, and this is kind of why these tools from before
weren't working, because they were trying to find single F. And why is it hard? Because you're going
to find an F that's going to pick out all these values. I'm naming these values. So A needs to be
less, greater than B, A needs to be greater than C, C needs to be greater than D, D needs to be
greater than F and E, and F and E need, both need to be greater than G. So you're, you're like solving
all these things all at once. And if you have a 10 million line program, it's just, it's going
to be impossible. You're not, you're not going to be able to do it. And so, so what we figured out
was that you could use these tools for finding proofs of toy programs. And you can find multiple
ranking functions. It's going to turn out there's one thing we're going to need to do and Ramsey's
going to solve it for us. That's going to be the punchline Ramsey's going to solve of course.
So imagine we could find one termination argument, G for this transition, and another
termination argument for, for here. We can, we can color them. So here's, I'm just going to
make my life a little bit easier. So notice, notice I've colored this transition green because I have
the green function. And here I've, I've colored it red because I have the red function. Okay.
I'm preparing for Ramsey. The problem right now is that this isn't a valid termination argument.
And the reason is, is because I have two functions, you could imagine them alternating,
and there's just no reason for the numbers to go down. So if I have two termination arguments,
it's not valid because I just alternate them. There's no reason I know, I can't know, I can't
alternate them. So, so I haven't, I haven't proved termination yet. But what we can do is we can
borrow some techniques from these papers. And now I'm going to do a construction and just believe
me. Okay. Because we don't want this to turn into a 30 minute graph theory course. Okay.
There's this idea of transitive closure. And it's really neat. And the graphs are really
amazingly, they have so many edges, it's an unbelievable, but it's a construction, you can do
it. And, and, and now what we can do is we can, and this is, and imagine this is infinite because
we're saying, oh, maybe this program doesn't terminate. And so now what we can do is we can
take the monochromatic Ramsey subgraph. For those of you who signed up for this talk,
this is kind of the worst slide, right? Sorry. That who don't know, who don't know
math and logic and that kind of thing. So we can take the monochromatic Ramsey, say that when
you go home, right? You, you, how was the, hey honey, how was the talk is like monochromatic subgraphs.
And, and, and now we can pull this trick again. So we'll, we'll, we'll do like trying, we'll say,
okay, imagine non, non-terminating, non-terminating execution, but from the monochromatic subgraphs.
So it's only the green edges. So those were only the edges where we had one function and we did
this, we did this construction and you're just going to have to believe me that sort of added a
bunch more transitions. And this is, this is a valuable thing to do. And, and, you know, ask me
later and drinks and I'll explain it to you more. The more you get drinks into me, the more I'll
explain it to you. And, and again, we, now we get to say, oh, look, you know, now it's only one
function. So we know it's going down. So voila, right? We've, we've now, we, we, we have this
thing that Turing was saying. We need, we need to find a quantity, which is asserted to decrease
continuously and will vanish when the machine, machine stops and we did it. And it was Ramsey's
theorem that helps us do it. So the payload is the summary is Ramsey's theorem. Let's us use
many simple functions rather than a, rather than a single Turing style complex one. Okay.
How am I doing for time, by the way? Does anyone keep track? Okay, 15 more minutes, but I might
run long. I don't know. There was a Q and A afterwards. So I might eat into that. Okay. So
this, that, that's the basis of Terminator. So there was this, this paper that said,
hey, everyone, we have a termination prover that works for actual programs, like programs that
people care about, device drivers. And it worked really nicely. So it, so it, so here, you know,
here, remember, I showed you this code a little bit earlier. This is a device driver code. It's
actually from the mouse. It's a piece of the mouse device driver. And, you know, it has bugs. So
one of the developers agreed. Yeah, that's a bug. And then we, and then we had a bunch of papers.
What were these papers doing? A lot of these papers were chipping away at this maybe problem,
or the, the tool Terminator itself is running forever problem. So we were able to prove some
device drivers terminating. We also found some real bugs, but then there was a whole bunch of
maybes and spinning forever. And then these papers kind of chipped away at them.
Other papers generalize Terminator. So for example, these folks together with me
generalized it. So it's, you really could say anything that had the word eventually, like, you
know, when we could ask, when, whenever this program opens a file, does it eventually close it?
And that's eventually, right? So things like that. Another thing we did. So it turns out that
a lot of programs are what we call concurrent. So you might have two copies of the program,
both operating over that variable in at the same time. And proving those programs terminating
is harder. So it turns out device drivers kind of a very special flavor. And we were able to do
something. But then the question is, can we generalize to more programs? And the answer was yes.
So then Jasmine, who's in the audience, made the following reference. Hey, Byron, she worked with
me. Well, she worked in the Microsoft research. And then after this statement, she worked with me.
So Terminator looks like something we need in the analysis of biological models.
So that was this skin cancer comment I mentioned. So then a collective of us,
including a designer from the Royal College of Arts, essentially an anthropologist,
a couple of computer scientists, and Jasmine, and others who are biologists.
The idea here is that you have your skin cells and you have genes. And there's like the genes are
talking to the other neighbor genes. And they're all as a family trying to say, hey,
we should only have, what is it, five layers of skin? Six layers? Six layers? I don't remember.
But let's keep it that number. Let's not have a whole bunch more because that's bad for our
bodies. And let's not have a whole bunch less. That's also bad news for us. And so this paper
allowed us to analyze that. So we were able to build models of various kinds of disease and then
answer questions like, hey, if we modified the model, would you get homeostasis? And the one
really neat thing about it is this tool was designed such that biologists could use it and it
had a notation very similar to what they use in their day-to-day life. And so you can use the
tool still today. It's called Biomodal Analyzer. And there's been some amazing results. And Jasmine
in her lab down at UCL now has gone on to do amazing results. And many of them found in part
with the use of this tool. Another thing I did is I got really tired of using the, so there was
these kind of formulas that we were writing that came up quite a bit. And I found that notation
kind of limiting. So Talba Auerbach, who's a friend and an artist, began working with me on new
symbols. So here's Talba in my Cambridge Microsoft Research Office trying to invent new
mathematical symbols. And if you know LaTeXa, we ended, David Reinfert, who is the guy in the
photo, implemented these new symbols in MetaFont. And we came up with something I like quite a bit.
So it's this operation. So this is the lifting of a relation, happens to be greater than, with
respect to f. And that allowed us to talk about this in a much nicer way. So this is the thing
you've seen before. And now I can say this really nicely. I can say the transition relation, this
is the graph, is a subrelation of the lifting of greater than with respect to f. And so this
showed up a lot in talks and so on at the time. And so if you know, if you don't know math and
logic, just close your eyes for a second. But if you do, then I'm going to explain what the
meaning of this is. So the lifting of the relation with respect to f is the set of pairs of states,
s and t, such that if you apply f to s and apply f to t, greater than holds, or the relation holds.
So she's a really famous artist, and there's always articles about her. But amazingly,
Terminator was in Vogue magazine. My greatest moment. Okay. And then, sort of one final
point I wanted to make. So it turns out that the layout of data structures is just unbelievably
crucial when trying to prove termination of realistic programs. And so here is a data
structure of kind of typical data structure you would see in a device driver. And I'm just
going to kind of walk you through this a little bit to get the idea. So device driver might come
here and then it come here. And now it's sort of walking this data structure. It's called the
list, right? So it's going, there's these arrows which saying it's a link to the next and the next
and the next. And here it's going back to where it was before. And if the device driver somehow gets
confused and doesn't realize it's already seen this, we're in a world of trouble. Because now
what it's going to do is it's going to just spin on this thing forever. And so what's the termination
argument? So here I've put a little picture of a post-it note in an effort to say, oh yeah,
remember this. Okay. So imagine we've been here and we've left a post-it note saying,
remember this, don't forget this. And we've gone here and we've gone here and we've gone here.
What's the termination argument? Well, there's actually two list segments. There's the part we
haven't viewed before. And there's the part that we have viewed before. And what's the size of this?
Well, it's two nodes. And the size we haven't seen yet is two nodes. And so when we go another link,
now it's three to one. And so this is where we're going to get the termination argument, right?
We can take a transition from some state to some other state and look, it went from two
to one. And that's going to be, you know, the function we're typically going to use is the
number of links back to the node that's the head of the list. So there you go. So we're mapping.
And so the termination arguments are kind of like that. So this paper sort of recognizes,
this is with Peter Ahern and his postdoc and his PhD student, for example, Josh Burdine and myself.
And then after that, we're like, hey, let's keep working together. This is pretty cool. So then I
joined this thing with gang, I guess, called the East London Massive, that that was a collective of
people interested in reasoning about data structures. And so Josh, who was his PhD student and postdoc
and Samin, who was his ex PhD, had graduated and was a PhD student and I here ended up building
this tool called Slayer, which reasoned about shapes on behalf of the termination purpose.
We'd run this ahead of time. And that was very, very powerful. And it was also very powerful
because it turns out that many of these 85% of crashes were actually shape oriented. The device
driver would come in, it would modify that list, not leave it in a good state. And then the device
driver would come back in, start walking that list, it wouldn't be in a good state. And then
horrible things would happen. And so it turned out this is a whole other research area, basically
driven by determination, proving a whole bunch of different papers, some of them related to
determination, some of them not. But that's, you know, invite me back. I'll tell you all about
that. But here's an amazing thing that happened. So, so, so, so be who's in the audience. And I'm
also married to for past 27 years, or I can't remember now, sorry. And Peter, that's this chat,
they started a company that made a Slayer like tool. And, and they sold it to Facebook. And you
can still use it today. So it's called FB infer now, that you can go to this FB infer website and
find out how to use it. And, and, and that really got me to thinking, like, maybe it's time to leave
the research lab and go take things into product really, really into production at a level that,
that, that we had, that we hadn't seen before. So, so now that we sort of realized that almost
any mathematical statement, you know, maybe as we get closer and closer and closer to that,
this becomes more and more commercially relevant. And so that's kind of where I wanted to take
things. So this was the old Terminator website. Terminator is now dead. This website's gone.
You have to go to the way back machine to find it. But what it did was pretty interesting. It
inspired a new class of tools. There's a whole bunch of termination provers now that you could use.
There's whole sessions at conferences on termination. There's a pretty healthy
international termination prover competition.
Everyone can, like, a lot of people know that termination is impossible, but now it's a much,
it's a much more nuanced situation, right? Now, most people in my field at least know
that termination is possible, but you can prove termination programs and sort of a practical
thing that can be done. But also, I think that we made pretty mean, I mean, this vogue thing is
obviously a joke. I mean, I mean, it was real, but obviously that made no material impact on the
IT community. But I think that the articles in Wired, and Economist, and Financial Times, and
Science did, and this great Sinin the Terminator article of the Scientific American. So I think
that these helped the IT community understand that termination isn't like a death sentence.
Okay, so that's the end of my Cambridge story. As I said, yeah, so I mean, I said goodbye to MSR.
I've gone on to Amazon. That's three talks. I can tell you all about that, and I'll tell you
about that at drinks if you want to know more about it. But I've tried not to talk about the
Amazon work because that's all I do all these days. So I just, I thought it'd be fun to come here
and tell you this Ramsey Turing story, and I hope you had fun. So with that, I'll
gavel this to a close, and I'm happy to take questions.
Well, thank you for that wonderful talk. Let's have some questions. And we have a microphone to
go around. So first question. Byron, great talk, fantastic talk. Thank you. Maybe it's a relief
that you didn't mention artificial intelligence because it's so much in the in both these days.
But I suppose I would have asked about that. I mean, obviously Turing was famous for that,
but I mean, how do you see maybe today's developments in artificial intelligence having an
impact on the kind of, you know, automated reasoning that you're talking about?
Yeah, I'm very excited about so the in the automated reasoning sometimes is a really terrible
name for it because it's rather not automated, right? Like there's there's a lot of tools,
there's tools like Lean, Paul Light, Isabelle, you know, I can name a whole bunch of tools,
and they require a human to sit there and poke it to make it do the right thing.
You ultimately get a proof that it's the checks, the checking is automating, but the finding is
not. And those tools are rather more powerful in theory than the fully automated tools because
the automated tools, because the problem is undecidable, cut a bunch of corners about what
they can prove. So they can prove a much more limited set of things, whereas a super genius
sitting together with one of these tools that are not automated, as automated can do incredible
things. So all of your proofs of like the four color theorem, the Kepler conjecture, you know,
that have been done with with with these tools have required a human. And so what we're seeing right
now is that the generative AI chat GPT style tools are able to do these. So that's a really
amazing time. So what they can because they're training on all the past proofs. And all the
tools and these tools are super hard to use. But guess what, all the people who were making them
able to use wrote papers about it, and provided scripts and the scripts are on GitHub and the
tools have trained on that. So now they're able to say, you know, like, hey, you know,
find me a proof and haul light of XYZ. And they're not terrible. So I so I think that's a really
amazing thing. So making the tools easier. The other the observation that I'll just sort of
put on the table there is that when LLMs lie to you, that's incorrectness. And guess what we know
how to do, right? There's there's there's statements that are incorrect. And, and, and,
and, you know, it's not escaped the notice of the community that that's something we could
potentially solve. So but that's, that's, you know, that's a whole new area.
There's a question there.
Any, any thoughts on why you explain how you took the Frank, Frank Ramsey staff and the
Turing staff, and you put it together and you move forward for a subset of the problems?
Any thoughts why Turing didn't do that himself, given that, presumably, they, they knew each
of them pretty well and charged each other intellectually? Yeah, so so as so the part where
I said, believe me, this graph, you know, we can do this thing. And then the graph got really
colorful. That would be very hard to do manually. So the paper would have been pages and pages and
pages of calculations, which computers are really good at and humans are horrible at.
So I think what, what, so the single ranking function, you just need a really smart,
insightful person to be like, Oh, I got it. I was in the shower and I realized this is it,
where, but, but in terms of automation, it's really hard to know even where to start. Whereas
this, this other approach is much more automatable. So I think that's probably, probably the reason.
We have another question there.
Thank you for the talk. So for all those twos for automated reasoning, I'm guessing those twos
are not formally verified. My question is, do you think there's any value in actually formally
verifying their correctness? Or do you think there's, it's just too much work to do so?
There are some tools that are formally verified. And what a lot of the tools do today is produce
a proof that can be audited independently. So for example, a lot, a lot of these tools boil
down to a class of tools called SAT or SMT solvers, propositional satisfiability, or, or
satisfiability of propositional logic together with other theories like arithmetic, you name it,
strings, arrays, undertropper functions. And the solvers today can produce proofs that can
be audited independently by a tool like HallLite, Lean, et cetera. And let's, let's say that we
believe HallLite. It's very small, kind of eyes have looked at it and they're like, okay, we're
going to believe that. Then these tools that are, that are doing really pretty harrowing
high performance computing to try and find the proofs, ultimately produce a proof that can
be checked with a simple thing. That's pretty believable. So yeah, so that's something that
we've pushed on really. I don't want to talk about Amazon too much today because it's like,
that's all I ever do nowadays. But at Amazon, that's something we've pushed on very, very hard.
It's actually producing auditable proofs as opposed to just some magic tool that some smart
person wrote and you just have to believe it. We have a question over here.
So it's a two-part question. You mentioned British Airways and you said that could they arrive
on time enough or frequently enough to be useful? You didn't say anything about them arriving with
a luggage. I don't suppose there's any kind of mathematics. I'm not going to take that one.
But the second thing was to think about classes of mathematical problems that may not be
where you can anticipate or hypothesize that a solution or an algorithm could exist.
So the example I was thinking of while you were talking was the traveling salesman
where, and I imagine that Amazon must have thought about this for a while, getting the
in the course you're trying to deliver, where the presumption is that an algorithm could be
found, but that actually proving it within a finite time is, or at least up to now,
hasn't been possible. There's something solved and I'm not aware of it.
Is there an extension from the kind of approach that you were taking there to prove
termination to actually tackling those class problems? Maybe try to come up with a definitive
yes, there is definitely, we can now state that there will be a finite algorithm,
even if we can't actually find it within a finite time, or even to help us to find it.
Oh yeah, I probably not quite going to answer your question, but a couple of thoughts. One of
the interesting things about Ramsey's theorem is it says you have this
arrow and graph and there exists a monochromatic subgraph, but it doesn't show it to you, so
it's not constructive. And so if you use some of these techniques, you can't actually see
the termination argument, you just know it exists. But I think your question was rooted more in a
little bit about can we synthesize or convince ourselves that algorithms exist when we don't
know what this specific algorithm is there. We surmise they do, but we can't definitively,
or at least we couldn't definitively prove it. Yes, so I think so, I mean that like,
if goal box conjecture is proved likely, it's via these methods where you don't,
like the proof is kind of non-constructive in some sense. I imagine so often non-constructive
proofs are easier than constructive proofs. So yeah, so I think that the harder part will
actually be to find the witness. We have another question in the back there.
So Byron, I'm sure you're aware there were two schools of computer science in Cambridge in the
post-war years, cheering, because there's mathematical sophistication, mostly programmed
in binary on the Manchester Malt 1 and the Pylor Ace, because he could use his mathematical
sophistication to kind of reason about the algorithms and convince himself they were correct.
So the fact that notation was a very unproductive way of writing software didn't bother him.
The engineering philosophy that kind of came from people like Wilks and other colleges in
Cambridge just down the road was give the users a symbolic notation to seduce them into the idea
that programming actually is really very easy and you could just write stuff and it would be fine.
Yeah. Kind of the symbolic world of one because we have programming languages and the effort in
programming languages has been to design languages in which you can't make mistakes,
yet you can still write useful stuff. So my kind of question is now we have the kind of tools you're
talking about. Do we need to continue investing in improving programming languages or can we just use
scruffy languages and rely on the tools like yours to prove our software is correct?
So yeah, all programming languages are scruffy, but I've never quite managed to find the perfect one.
Couple of observations there. So one observation is I think Rust is this incredible language.
And so I spent a lot of time trying to get people working on very low level system
code to adopt tools that we had that could prove memory safety of those programs.
And it was really tough learning. And then one day Rust comes along and they're all like
without me even prompting them like, oh, I started learning Rust. And Rust has a very
sophisticated prover in it, but they came for the speed. So because Rust could be faster,
they're like, I'll learn these tools, but also it was super well done that the developers of
Rust talk about ergonomics, like the ergonomics of developing and Rust is really important to them.
And I think that's been very, very powerful. So one could prove, you know, just like there's
turning completeness of you can express all programs in Rust or C or Askel or Prolog.
There's, there's sort of, you know, you can prove the same things in a lot of these systems,
but I think that Rust's ergonomics are much nicer than some of the tools like in C where you then
try and prove, prove memory safety. That's my first observation. Second observation is there's
this fascinating blog post by Ranjit Jhalla where he shows that you can take a program
in an imperative language and prove it using horror triple style reasoning. And you have,
sorry, everyone, just bear with me for a second. You have a horror triples of quantifiers and,
and, and then you just slam the, you apply these SMT solvers with quantifier support and it's,
it's so hard and it's so compute expensive. Or you could write the same program in liquid Haskell
and there's no quantifiers. You can prove the same property and it's because Hindley Milner
is somehow resolving the quantifiers for you and it's very, very low power, very easy, very
predictable. You don't make a change to your code over here and suddenly the proof stops going through.
So, so I think that there's a lot to be said for the ergonomics of the language and the IDE and
the experience, particularly developing in cloud, you know, I'm talking about Amazon, but if you're
developing programs in cloud, the ergonomics of how do you develop that and understand the program
such that you don't have to like SSH over to some other machine to find out what the machine
that's stated in, I think are very, very important. So, so I think that automated reasoning,
programming languages and the sort of software development experience go really hand in hand
and there's some very powerful experiences we can have now that we couldn't have before.
Great. Other questions?
Okay. I think it's time to thank Byron for a wonderful talk. And I believe though there are
going to be refreshments out in the chat window room again. Okay. Thank you all.
