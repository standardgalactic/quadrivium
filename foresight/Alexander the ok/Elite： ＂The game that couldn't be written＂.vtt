WEBVTT

00:00.000 --> 00:14.080
Let's go back to 1984 in the UK.

00:14.080 --> 00:19.880
In a few short years, home computers have gone from practically non-existent to commonplace.

00:19.880 --> 00:24.760
Almost every child in the country has access to a BBC microcomputer at school, and the

00:24.760 --> 00:28.160
ZX Spectrum is topping out Christmas wish lists.

00:28.160 --> 00:33.240
And despite a crash in the video games market in the USA, games are still flying off the

00:33.240 --> 00:34.240
shelves here.

00:34.240 --> 00:39.840
While there's plenty choice, almost every game available to play at home is some variation

00:39.840 --> 00:40.840
of the same thing.

00:40.840 --> 00:46.240
A 10 minute tops arcade style run at a high score.

00:46.240 --> 00:52.240
Longer form strategy and adventure games do exist, largely in the form of text adventures,

00:52.240 --> 00:57.560
sometimes with accompanying imagery, but not with real time graphics, and certainly not

00:57.560 --> 00:59.920
in an open world.

00:59.920 --> 01:05.120
Home computers are more popular than consoles in the UK, and let's be honest, many of the

01:05.120 --> 01:10.920
games on these look, well, take a look for yourself.

01:10.920 --> 01:15.440
As for 3D graphics, the choices are even more limited.

01:15.440 --> 01:22.120
Every 3D game on the market is either not actually 3D, or is not really a game.

01:22.120 --> 01:29.720
There are a few flight simulators, technically impressive for the day, but not exactly immersive.

01:29.720 --> 01:37.040
Sublogix FS1 Flight Simulator was arguably the first full 3D game created for the home,

01:37.040 --> 01:38.680
and it looks like this.

01:38.680 --> 01:42.760
Doesn't this gameplay look fun?

01:42.760 --> 01:48.720
And the frame rate, let's just say, it has a frame rate.

01:48.720 --> 01:54.960
Microsoft Flight Simulator 2 has just released, but that requires a $5,000 IBM PC to play,

01:54.960 --> 01:59.480
and no one had one of those outside the office.

01:59.480 --> 02:04.480
Arcade cabinets with more specialized hardware have taken a step into 3D gaming, but I can't

02:04.480 --> 02:12.160
find a single example of a true 3D game that isn't a flight simulator prior to 1984.

02:12.160 --> 02:17.800
Battle zones are competitor, but movement and object tracking is restricted to two axes,

02:17.800 --> 02:21.520
a sort of pseudo 3D game.

02:21.520 --> 02:27.400
And there are a few other on-rails shooters, limited in scope, and always a slave to the

02:27.400 --> 02:30.120
high score.

02:30.120 --> 02:34.720
The best-selling games at the moment are Pac-Man and Space Invaders.

02:34.720 --> 02:38.280
You probably remember them looking like this.

02:38.280 --> 02:41.360
Problem is, those are the arcade versions.

02:41.360 --> 02:48.880
If you wanted to play them at home on your Atari 2600, this is what they looked like.

02:48.880 --> 02:51.640
Then Elite was released.

02:51.640 --> 03:08.960
Elite looked like this.

03:08.960 --> 03:12.680
It changed gaming in Europe overnight.

03:12.680 --> 03:15.080
It was an open universe game.

03:15.080 --> 03:20.320
No high score, no restrictions, and full, true 3D graphics.

03:20.320 --> 03:27.760
A procedurally generated universe, a backstory in the form of a novella, pirates, trading,

03:27.760 --> 03:34.240
asteroid mining, an economy, and you could play it at home or at school.

03:34.240 --> 03:38.920
Non-European viewers are unlikely to be familiar with the impact Elite had on gaming and computing.

03:38.920 --> 03:46.640
But here in the UK, the 20th of September 1984, was the day computer games became a

03:46.640 --> 04:03.920
serious business.

04:03.920 --> 04:08.160
This is a story I've been obsessed with since I was a teenager.

04:08.160 --> 04:12.880
It shaped my life personally, and there is a direct path between some of the innovations

04:12.880 --> 04:17.480
made by Elite's creators and my professional work today.

04:17.480 --> 04:22.320
This may come as a surprise to some subscribers, but I previously worked in the computer games

04:22.320 --> 04:23.720
industry.

04:23.720 --> 04:28.760
Not for very long, but my first role as a data scientist after quitting engineering

04:28.760 --> 04:32.280
was for a UK-based games developer in Dundee.

04:32.280 --> 04:37.040
I even learned Unity and coded up a couple of games myself during this period.

04:37.040 --> 04:42.520
Of course, I wouldn't use Unity now after recent events.

04:42.520 --> 04:45.840
The story of Elite's creation is already told on YouTube.

04:45.840 --> 04:50.800
However, I'm not going to focus too much on the history and the individuals.

04:50.800 --> 04:55.240
Instead, I'd like to dive into some of the technical details on how the game was even

04:55.240 --> 04:59.320
possible and how some of its major challenges were tackled.

04:59.320 --> 05:03.960
And I promise, absolutely zero programming knowledge is necessary to understand what

05:03.960 --> 05:06.640
I'll be discussing.

05:06.640 --> 05:13.440
Before we get into the full story, I'd like to make a quick political disclaimer.

05:13.440 --> 05:16.740
Elite is very much a British success story.

05:16.740 --> 05:22.040
It was a rare case of government, industry, the academic sector, and even state-funded

05:22.040 --> 05:27.040
media inadvertently working together to produce something amazing.

05:27.040 --> 05:32.160
The government at the time, however, was one of the most contentious in UK history.

05:32.160 --> 05:33.520
The Thatcher government.

05:34.080 --> 05:39.000
Now, I try to adopt a policy on this channel of not getting bogged down in politics, but

05:39.000 --> 05:41.800
also not skirting around them.

05:41.800 --> 05:45.480
I don't see it as my role to tell viewers what to think politically.

05:45.480 --> 05:51.120
So, let's just say that sometimes bad governments do good things, and sometimes good governments

05:51.120 --> 05:53.000
do bad things.

05:53.000 --> 05:56.520
And it's up to you to decide if that applies here.

05:56.520 --> 06:07.960
Let's take a look at the machine Elite was originally coded on and created for.

06:07.960 --> 06:11.440
This is the BBC Micro.

06:11.440 --> 06:15.520
This video was a good excuse for me to finally get one.

06:15.520 --> 06:19.720
Of course, I got hold of a broken one to bring back to life.

06:19.720 --> 06:24.640
When dealing with technology that's older than me, I always feel to be worthy.

06:24.640 --> 06:27.280
I have to fix it first.

06:27.280 --> 06:30.800
I'll overlay some footage of the restoration here.

06:30.800 --> 06:36.200
In fact, mine came with a cassette recorder, with a copy of Elite ready to go.

06:36.200 --> 06:41.960
Yes, I could have just bought an SD card reader, but loading a game from a cassette tape was

06:41.960 --> 06:47.280
one of those little things I just had to experience.

06:47.280 --> 06:52.800
In the late 1970s, the UK was staring a disaster in the face.

06:52.800 --> 06:57.440
Over in the US, the development of cheap microcontrollers had, in the space of a couple

06:57.440 --> 07:03.240
of years, transformed computers from cabinet-sized mainframes that cost tens or even hundreds

07:03.240 --> 07:11.520
of thousands of dollars to the likes of the Apple II, the TRS-80 and the Commodore PET.

07:11.520 --> 07:16.360
Government and businesses in the US, and in Japan, and even other Western European countries

07:16.360 --> 07:18.920
were quickly embracing the change.

07:18.920 --> 07:24.640
In a small but dedicated portion of their population were becoming proficient in computing,

07:24.640 --> 07:28.920
be it at home or in the workplace.

07:28.920 --> 07:33.120
The UK was emerging from a financial crisis.

07:33.120 --> 07:36.480
When isn't the UK in a financial crisis?

07:36.480 --> 07:41.080
Traditional manufacturing industries such as mining, steelworking and shipbuilding were

07:41.080 --> 07:43.600
either dying or dead.

07:43.600 --> 07:46.120
No one was thinking about computers.

07:46.480 --> 07:51.520
Likewise, the government was preoccupied with all of the above.

07:51.520 --> 07:55.800
An unlikely contender resolved to address the issue before it was too late.

07:55.800 --> 08:02.840
The UK's state-funded, but not state-controlled, broadcaster, the BBC.

08:02.840 --> 08:07.120
The BBC acted fast and they acted decisively.

08:07.120 --> 08:11.720
The Compute Alliteracy Project was to be a collection of TV and radio series intended

08:11.720 --> 08:19.000
to teach the nation that computers weren't scary, obscure or just for nerds.

08:19.000 --> 08:24.520
A tender was put out for a computer model to be adopted by the BBC for these broadcasts

08:24.520 --> 08:30.760
and crucially it was to be adopted by schools too, with the government subsidising half

08:30.760 --> 08:35.320
of the cost of every computer purchased by a school.

08:35.320 --> 08:39.960
By this point, Clive Sinclair had released the ZX81.

08:39.960 --> 08:47.040
This was an absolute bare-bones computer, but it was cheap, incredibly cheap.

08:47.040 --> 08:51.680
And for that reason, I'll never knock it as many others do these days.

08:51.680 --> 08:58.360
For less than £200 in 2023 money, a family could have a fully functioning 8-bit computer

08:58.360 --> 09:00.360
at home.

09:00.360 --> 09:04.880
Sinclair put it forward to the BBC for consideration, but was rejected.

09:04.880 --> 09:08.280
It didn't come close to their specifications.

09:08.280 --> 09:15.000
In what seems like a rare case of due consideration, the BBC required a surprisingly capable system

09:15.000 --> 09:20.840
with network capability, full colour graphics and expansion capability.

09:20.840 --> 09:27.880
Acorn Compute has rushed out a prototype for the BBC in four days.

09:27.880 --> 09:29.960
This resistor here?

09:29.960 --> 09:33.120
That simulates an engineer's finger on the board.

09:33.120 --> 09:35.440
The system wouldn't boot without it.

09:35.440 --> 09:39.680
And no one really knows what purpose it serves to this day.

09:39.680 --> 09:44.320
Despite its whirlwind conception, Acorn's prototype was the only system that met the

09:44.320 --> 09:46.280
BBC's specifications.

09:46.280 --> 09:52.680
It exceeded some, with blisteringly fast RAM for the day, and a frankly wonderful potential

09:52.680 --> 09:54.800
for expansion.

09:54.800 --> 10:03.200
The BBC Micro Model B used a MOS 6502 CPU clocked at 2GHz, and it pushed it to its limits given

10:03.200 --> 10:05.560
the Micro's IO capability.

10:05.560 --> 10:11.680
32KB of RAM was available, along with an operating system that included a modified version of

10:11.680 --> 10:15.640
BASIC, known as BBC BASIC.

10:15.640 --> 10:18.760
BASIC was the programming language of the time.

10:18.760 --> 10:22.120
In fact, the Micro boots straight into it.

10:22.120 --> 10:27.640
Uniquely, assembly code can be inserted in line with BASIC commands.

10:27.640 --> 10:32.880
If you're not familiar with assembly, don't worry, we'll get there soon.

10:33.560 --> 10:38.160
The BASIC capability was provided via Acorn's proprietary Econet, and the capability for

10:38.160 --> 10:43.680
a second co-processor was even provided via the tube interface.

10:43.680 --> 10:49.360
This can even be used today to connect a Raspberry Pi, something I will definitely be doing in

10:49.360 --> 10:51.880
the future.

10:51.880 --> 10:57.960
The BBC Micro isn't a looker, but that large form factor makes it easy to add expansion

10:57.960 --> 11:02.160
boards, just four screws to undo it and you're in.

11:02.160 --> 11:06.480
There are plenty of empty ROM sockets for you to add more functionality.

11:06.480 --> 11:08.520
And I have to mention the keyboard.

11:08.520 --> 11:13.040
The Micro has a really nice mechanical keyboard.

11:13.040 --> 11:15.480
Apparently that contributed significantly to the cost.

11:15.480 --> 11:19.680
Right, okay, this is me back again three weeks after saying that.

11:19.680 --> 11:24.160
Totally unscripted here by the way, and I've just spent an hour tapping away on that keyboard.

11:24.160 --> 11:29.920
Yeah, it's very well built in that like a school child isn't going to destroy it.

11:29.920 --> 11:31.920
It's a very slow keyboard though.

11:31.920 --> 11:34.600
I don't know if I'd say it's a fantastic keyboard now.

11:34.600 --> 11:37.840
Right, okay, back to three weeks ago Alex.

11:37.840 --> 11:40.880
And indeed the Micro was not cheap.

11:40.880 --> 11:45.360
About £1,600 in 2023 money.

11:45.360 --> 11:50.280
Though I will note that was about the same cost as a Commodore 64, which is probably

11:50.280 --> 11:53.680
the closest equivalent machine on the US market.

11:53.680 --> 11:59.720
Yet, and this seems unbelievable today, the government still agreed to subsidise this

11:59.720 --> 12:02.240
cost to schools.

12:02.240 --> 12:08.040
By the end of the computer literacy project, 85% of UK primary and almost every secondary

12:08.040 --> 12:11.880
school had at least one BBC Micro.

12:11.880 --> 12:17.120
Almost every child in the country had free access to a good computer and free tuition

12:17.120 --> 12:22.680
via the BBC, a project that seems almost too good to be true today, and probably the reason

12:22.680 --> 12:28.920
why anyone born between about 1970 and 2000 in the UK seems to be perfectly proficient

12:28.920 --> 12:35.720
with a computer.

12:35.720 --> 12:37.880
Now let's look at the game itself.

12:37.880 --> 12:41.920
Elite is an open world space exploration game.

12:41.920 --> 12:48.080
We begin docked at Lavais station with 100 credits, 3 missiles, a pulse laser and a Cobra

12:48.080 --> 12:50.680
Mark 3 spacecraft.

12:50.680 --> 12:55.720
Leaving the station, we make a hyperspace jump to another system of our choice.

12:55.720 --> 12:59.760
Every system has a summary screen denoting the government type and system wealth and

12:59.760 --> 13:02.360
major industry.

13:02.360 --> 13:06.960
Until we can afford to better equip our ship, novice players must now make a mad dash to

13:06.960 --> 13:11.640
the system planet, where they'll find it's respective space station.

13:11.640 --> 13:13.300
Time to dock.

13:13.300 --> 13:19.640
This is notoriously difficult, though I'm not really sure why, here's how to do it.

13:19.640 --> 13:24.760
Just ignore the manual and go in at half speed.

13:24.760 --> 13:28.980
Every system has different commodity prices, and we're able to make a profit by trading

13:28.980 --> 13:31.560
between appropriate systems.

13:31.560 --> 13:35.880
This is a surprisingly involved process, so keep a notebook handy.

13:35.880 --> 13:39.360
And probably don't trade anything illegal for now unless you want the galactic police

13:39.360 --> 13:42.200
on your case.

13:42.200 --> 13:44.600
Of course it's rarely this simple.

13:44.600 --> 13:50.840
If you've warped into an anarchic system, get ready to be constantly harassed by pirates.

13:50.840 --> 13:55.960
Even in the safest systems, it's rare to make a clean run to the home planet.

13:55.960 --> 13:59.600
Later in the game, when we're better equipped, we can make a profit by bounty hunting these

13:59.600 --> 14:01.200
pirates.

14:01.200 --> 14:04.000
But for now, better get saving for that beam laser.

14:04.000 --> 14:06.760
Oh and there are Tharguides too.

14:06.760 --> 14:11.040
Those are aliens with tough flying saucers that spawn drones, and they're equipped with

14:11.040 --> 14:15.200
electronic countermeasures so they'll render your missiles useless.

14:15.200 --> 14:17.560
And that's the essence of it really.

14:17.560 --> 14:22.680
It was a complete step change in computer games in 1984.

14:22.680 --> 14:27.200
Short of the flight simulators I mentioned earlier, which as I said I would only loosely

14:27.200 --> 14:34.200
define as games, there was nothing else with true 3D graphics available on an arcade machine,

14:34.200 --> 14:36.960
let alone a home computer.

14:36.960 --> 14:42.720
The universe of 8 galaxies, each consisting of 256 stars, along with their descriptions,

14:42.720 --> 14:47.160
market prices and system characteristics, was procedurally generated.

14:48.160 --> 14:53.680
The closest the game has to a high score is the player ranking, starting at harmless

14:53.680 --> 14:58.320
and eventually reaching elite for only the most dedicated players.

14:58.320 --> 15:03.000
You can be a trader, a bounty hunter, a pirate, an asteroid miner, or some combination of

15:03.000 --> 15:05.000
all of these.

15:05.000 --> 15:09.280
Truly an open world game with infinite choice and potential.

15:09.280 --> 15:13.960
Sophie Wilson called it the program that couldn't have been written, and Steve Furber said it

15:13.960 --> 15:17.480
had the BBC design team staggered.

15:17.480 --> 15:19.920
Who are Sophie Wilson and Steve Furber?

15:19.920 --> 15:27.600
Oh, they're just the pair that built the BBC Micro prototype in four days.

15:27.600 --> 15:32.440
In what's now regarded as one of the greatest programming feats of all time, Elite was created

15:32.440 --> 15:37.320
over the course of two years by Ian Bell and David Braben.

15:37.320 --> 15:42.720
Both met while studying at Cambridge, though it seemed almost unfathomable for such a complex

15:42.760 --> 15:45.760
game to be created by just two individuals.

15:45.760 --> 15:49.920
This was actually unusual in UK development at the time.

15:49.920 --> 15:55.280
Almost every game published in the UK prior to Elite had been coded by sole developers.

15:55.280 --> 16:00.840
The UK games industry consisted almost exclusively of bedroom coders, sending in cassettes to

16:00.840 --> 16:05.440
various small publishers, hopefully in exchange for a few hundred pounds and some bragging

16:05.440 --> 16:07.560
rights.

16:07.560 --> 16:12.680
When Bell approached Acornsoft, the software wing of Acorn computers, it was clear they'd

16:12.680 --> 16:16.320
created something that had never been seen before.

16:16.320 --> 16:21.400
Acornsoft therefore not only agreed to publish, but also decided to stage the first major

16:21.400 --> 16:25.000
and highly publicised release of a game in the UK.

16:25.000 --> 16:29.720
They ran TV adverts and hired out a theme park for the launch.

16:29.720 --> 16:36.720
This seems trivial now, but this was completely unheard of in 1984.

16:36.720 --> 16:42.280
As I showed in the intro, Elite completely eclipsed any competition.

16:42.280 --> 16:47.640
Just immediately it became a national sensation, eventually selling over 100,000 copies for

16:47.640 --> 16:53.000
the BBC Micro and 600,000 across all platforms.

16:53.000 --> 17:02.000
Braben and Bell became celebrities who effectively jumpstarted the UK gaming industry.

17:03.240 --> 17:08.360
To build a universe in a 1980s computer, we must first do a deep dive into the hardware

17:08.360 --> 17:10.720
available at the time.

17:11.560 --> 17:16.440
To understand the code, it's necessary to understand the hardware first.

17:16.440 --> 17:20.640
There are far more comprehensive sources available in the description, so I'll keep it as brief

17:20.640 --> 17:22.360
as possible.

17:22.360 --> 17:28.200
By the end of this chapter, you'll understand how a CPU works.

17:28.200 --> 17:32.880
The BBC Micro was similar in architecture to rival machines of the time, using the same

17:32.880 --> 17:38.040
processor as the Apple II, Commodore 64 and the Atari 2600.

17:38.040 --> 17:44.920
That processor was the Moss 6502, a chip ubiquitous with the 1980s, and the driving force between

17:44.920 --> 17:47.920
the home computing revolution.

17:47.920 --> 17:54.080
The 6502 is able to receive and transmit 8 bits of data in a single cycle.

17:54.080 --> 17:59.960
Data in this case may refer to actual data moving to or from the CPU, or it may refer

17:59.960 --> 18:01.760
to commands.

18:01.760 --> 18:07.160
Each command the CPU is capable of carrying out is encodable as an 8-bit string.

18:07.160 --> 18:10.560
We'll see some examples later.

18:10.560 --> 18:19.000
This 8-bit or 1-byte data bus is why we refer to the 6502 as an 8-bit processor.

18:19.000 --> 18:23.680
In addition to the data bus is a 16-bit address bus.

18:23.680 --> 18:29.480
This is used to address individual locations, or addresses, in memory.

18:29.480 --> 18:34.520
Let's simplify the layout and see how this is achieved.

18:34.520 --> 18:39.720
To write a byte of data to memory, the CPU sends the chosen 16-bit address to the memory

18:39.720 --> 18:41.760
on the address bus.

18:41.760 --> 18:46.320
The byte of data to be stored is then sent down the data bus, and the memory ICs are

18:46.320 --> 18:49.760
configured to store that byte at the given location.

18:49.760 --> 18:54.320
Likewise, sending an address down the bus results in the byte stored at that address

18:54.320 --> 18:57.160
being returned to the CPU.

18:57.160 --> 19:01.960
Now let's have a look at the memory in the BBC Micro specifically.

19:01.960 --> 19:09.120
If we imagine zooming in on it, we can imagine every addressable byte being stored in sequence.

19:09.120 --> 19:12.040
Each address holds a single byte.

19:12.040 --> 19:18.280
As addresses are 16 bits in length, the maximum possible address is 2 to the power of 16,

19:18.280 --> 19:24.960
which equals 65,536 bytes in total, or 64 kilobytes.

19:24.960 --> 19:29.280
And indeed, the Micro had 64 kilobytes of memory available.

19:29.640 --> 19:33.840
However, 32 kilobytes of this is read-only.

19:33.840 --> 19:39.320
It contained the operating system itself, and is therefore not writable.

19:39.320 --> 19:45.640
The other 32 kilobytes is the RAM, and is the sum total space available to hold programs

19:45.640 --> 19:48.080
and any stored variables.

19:48.080 --> 19:52.200
However, not all of this is usable as such.

19:52.200 --> 19:57.240
When I began studying the architecture, one of the first questions I asked was,

19:57.240 --> 19:59.520
but where is the video memory?

19:59.520 --> 20:03.520
Which sort of shows how clueless I was.

20:03.520 --> 20:09.320
Every time we send a frame to display on the screen, that frame must be stored somewhere.

20:09.320 --> 20:16.720
I hadn't anticipated that back in the 1980s, this somewhere, or frame buffer, as we call it,

20:16.720 --> 20:19.440
also lived in main memory.

20:19.440 --> 20:24.160
Every location on the screen maps to a location in memory.

20:24.160 --> 20:29.280
Change the value of a byte in the frame buffer, and the corresponding pixel, or set of pixels,

20:29.280 --> 20:32.160
on the screen will also change.

20:32.160 --> 20:34.520
We'll go into more detail later.

20:34.520 --> 20:41.080
But in the case of Elite, 7,936 bytes were reserved as the frame buffer,

20:41.080 --> 20:46.360
used solely for storing the values for physical pixels to be drawn on screen.

20:46.360 --> 20:52.600
This area of memory is read by a collection of chips referred to as the Vidproc, or video processor,

20:52.600 --> 21:00.320
responsible for translating the byte value at each memory location to a physical pixel on screen.

21:00.320 --> 21:02.120
We're still not done.

21:02.120 --> 21:07.800
The first 3,584 bytes of memory are allocated to workspaces,

21:07.800 --> 21:13.760
which are, loosely speaking, areas that may be used to store variables, but not code.

21:13.760 --> 21:16.960
Let's take a closer look.

21:16.960 --> 21:21.800
Memory is actually split into 256 byte pages.

21:21.840 --> 21:29.240
The first is the zero page, and may be used to store variables that require fast access by the CPU.

21:29.240 --> 21:35.600
As zero page addresses can be defined in just 8 bits, the CPU is able to access them more quickly,

21:35.600 --> 21:39.560
and they were used extensively in Elite's source code.

21:39.560 --> 21:41.600
Next is the stack.

21:41.600 --> 21:44.960
This is another temporary storage area for variables.

21:44.960 --> 21:48.120
The stack operates on a first in, first out basis.

21:48.120 --> 21:55.800
Pushing a byte to the stack means that byte will be the first retrieved when subsequently calling from the stack.

21:55.800 --> 22:02.680
Most of the remaining space here is allocated to other workspaces that can be used to store temporary variables.

22:02.680 --> 22:07.560
However, one kilobyte is available as the language workspace.

22:07.560 --> 22:13.320
This isn't usable for code storage, but it could be used to store text expressions.

22:13.320 --> 22:16.800
And this was most certainly used by Bell and Braben.

22:16.800 --> 22:24.560
These expressions are persistent and defined in the source code, so they very much form part of it.

22:24.560 --> 22:31.280
The remaining 21,248 bytes of memory are available to store our program.

22:31.280 --> 22:40.000
So this gives a total of 21,248 bytes of program memory and 1,024 bytes in the language workspace.

22:40.000 --> 22:46.880
By my reckoning, that's a total of 22,272 bytes available.

22:46.880 --> 22:53.640
Reading around some other sources, the actual memory available was actually 21,952.

22:53.640 --> 22:56.200
Perhaps I missed a page somewhere.

22:56.200 --> 23:04.280
Either way, that's less than 22 kilobytes to fit an entire Open World 3D universe.

23:04.280 --> 23:07.680
And Elite fit within that 22 kilobytes.

23:07.680 --> 23:09.840
It's not very much.

23:09.880 --> 23:16.120
To add some context, if I go to PC Partpicker and look at a £1,600 PC,

23:16.120 --> 23:19.720
which is about the cost of a BBC Micro in today's money,

23:19.720 --> 23:25.000
we come up with something with an AMD Ryzen 7 CPU.

23:25.000 --> 23:29.080
Obviously, Elite would fit into the main memory millions of times over.

23:29.080 --> 23:32.400
But modern systems don't just use standard RAM.

23:32.400 --> 23:38.560
CPUs incorporate relatively tiny amounts of extremely high-speed memory on the chip itself.

23:38.560 --> 23:40.480
This is called the cache.

23:40.480 --> 23:44.480
Would 22 kilobytes fit on a modern CPU cache?

23:44.480 --> 23:48.160
The question is barely worth asking.

23:48.160 --> 23:51.240
We have to zoom in to the individual compute cores.

23:51.240 --> 23:53.640
The Ryzen 7 has eight of them.

23:53.640 --> 23:56.880
Each has its own dedicated Level 2 cache.

23:56.880 --> 24:00.040
It's still not even worth asking the question at that point.

24:00.040 --> 24:04.280
We have to go inside each core to the Level 1 cache,

24:04.280 --> 24:07.240
the fastest memory available in the system.

24:07.280 --> 24:09.760
The 64 kilobytes per core.

24:09.760 --> 24:14.760
So Elite would fit inside each core of a modern processor twice.

24:14.760 --> 24:21.200
In fact, it had also sit inside the Level 1 cache of every compute module of the GPU.

24:21.200 --> 24:25.520
And it had fit inside the controller chip for the SSD as well.

24:25.520 --> 24:29.760
It's genuinely difficult to find a place Elite wouldn't fit.

24:29.760 --> 24:31.760
So we get the point.

24:31.760 --> 24:35.760
Braben and Bell were severely constrained when it came to memory.

24:35.760 --> 24:40.360
And that's probably the most discussed limitation they were able to overcome.

24:40.360 --> 24:45.280
But I'd argue they were similarly, if not more limited, when it came to compute.

24:45.280 --> 24:49.280
Just recall the frame rate on those early flight simulators.

24:49.280 --> 24:54.280
Let's take a look at how the 6502 worked.

24:54.280 --> 24:57.360
We see our data and address buses.

24:57.360 --> 24:59.360
I'm going to include the memory here.

24:59.360 --> 25:01.360
Obviously it wasn't inside the chip,

25:01.360 --> 25:06.360
but showing it connected to the buses makes this section much easier to understand.

25:06.360 --> 25:09.360
CPUs contain registers.

25:09.360 --> 25:12.360
These are simply storage cells,

25:12.360 --> 25:15.360
able to hold a single piece of data.

25:15.360 --> 25:21.360
The 6502 has a one 16-bit register, the program counter.

25:21.360 --> 25:26.360
This holds the address of the current byte in memory that's currently being read.

25:26.360 --> 25:32.360
This may be thought of as the current position within the program being executed.

25:32.360 --> 25:38.360
Next to the index registers, there are two of them, referred to X and Y.

25:38.360 --> 25:41.360
They're both 8 bits in size.

25:41.360 --> 25:49.360
In addition to holding a single byte value, they can be incremented or decremented by one throughout the use of appropriate commands.

25:49.360 --> 25:53.360
This makes these registers useful as loop counters.

25:53.360 --> 25:57.360
The accumulator is another 8-bit register.

25:57.360 --> 26:03.360
Any arithmetic operations must be carried out using the value stored in the accumulator.

26:03.360 --> 26:08.360
For this reason, the accumulator is connected directly to the arithmetic logic unit.

26:08.360 --> 26:14.360
This is a collection of logic gates able to perform basic arithmetic operations.

26:14.360 --> 26:19.360
The value from the accumulator is fed in, along with a second value from the data bus,

26:19.360 --> 26:22.360
and the ALU performs the required operation.

26:22.360 --> 26:28.360
In the case of the 6502, the ALU is able to add and subtract 2 8-bit numbers,

26:28.360 --> 26:35.360
along with a few bitwise operations, specifically OR and bit shifts and bit rotations.

26:35.360 --> 26:43.360
That's it. The 6502 is only able to perform very simple arithmetic and logical operations.

26:43.360 --> 26:49.360
And remember, we can only operate on 8 bits. It can only count up to 255.

26:50.360 --> 26:56.360
The result from these operations is stored back in the accumulator.

26:56.360 --> 27:04.360
The status register is an 8-bit register, where each bit signifies a result from the last executed operation.

27:04.360 --> 27:13.360
For example, if an addition is performed and the resulting value is above 255, i.e. not storable in the accumulator,

27:13.360 --> 27:21.360
the 8 least significant bits will still be stored in the accumulator, and the carry flag will be set to high.

27:21.360 --> 27:31.360
In addition to the carry flag, the other bits flag 0 value, interrupt disable, decimal mode, break, overflow, and negative value.

27:31.360 --> 27:38.360
We won't worry too much about these for now, but know that they can be used to trigger branches in a program.

27:38.360 --> 27:44.360
Remember that second page of memory that formed the stack? It's represented here.

27:44.360 --> 27:51.360
The final register is the stack pointer, which stores the address of the highest populated location in the stack.

27:51.360 --> 27:57.360
We won't be directly referring to it again, I've just included it to be complete.

27:57.360 --> 28:09.360
And that's all we have to work with. By today's standards incredibly simple, but still a fully functioning CPU, with less than 4,000 transistors.

28:09.360 --> 28:14.360
There are three main families of commands that the 6502 is able to execute.

28:14.360 --> 28:22.360
Commands, or instructions as they're referred to more correctly, are represented by three-letter operation codes.

28:22.360 --> 28:27.360
Physically, each is just a byte sent down the address bus.

28:27.360 --> 28:33.360
The first family is instructions that move data to or from the registers and memory.

28:33.360 --> 28:38.360
Let's see what happens when we run the store accumulator instruction.

28:38.360 --> 28:43.360
This simply stores the value currently in the accumulator to memory.

28:43.360 --> 28:48.360
First, the desired address to store the value at is sent to memory via the address bus.

28:48.360 --> 28:53.360
Then the 8-bit value in the accumulator is sent to memory via the data bus.

28:53.360 --> 29:00.360
I'll leave it visible for now so we can imagine a byte of memory at a given address.

29:00.360 --> 29:08.360
We could then load this value into the X register using the LDX instruction, or loadX.

29:08.360 --> 29:13.360
The address is sent via the address bus, and the value is copied to the X register.

29:14.360 --> 29:20.360
With similar commands, we can send data between all available registers and memory.

29:20.360 --> 29:24.360
The next family are the arithmetic commands.

29:24.360 --> 29:29.360
AddWithCarrie adds a value from memory to the current accumulator value.

29:29.360 --> 29:36.360
Here the memory address is sent via the address bus, and the byte in memory is sent to the ALU.

29:36.360 --> 29:42.360
The value currently in the accumulator is also sent to the ALU, where the two are added.

29:42.360 --> 29:46.360
The result is stored in the accumulator.

29:46.360 --> 29:48.360
Remember the carry flag.

29:48.360 --> 29:54.360
If the resulting value is greater than 255, the carry flag is set to 1.

29:54.360 --> 30:00.360
But for now, let's assume there's no carry so the flag remains at 0.

30:00.360 --> 30:06.360
And that leads us to the final family of instructions, branches and jumps.

30:06.360 --> 30:13.360
The branch on carry clear causes a jump to a different location of our program if the carry flag is 0.

30:13.360 --> 30:15.360
Here's how it works.

30:15.360 --> 30:24.360
The carry flag is checked, and if it's 0, the address to which we want to jump is passed into the program counter.

30:24.360 --> 30:31.360
Remember addresses are 16 bits, so two separate bytes must be passed down the data bus to achieve this.

30:31.360 --> 30:35.360
This means the next address will be that of the jump location.

30:35.360 --> 30:39.360
This is how we implement if statements.

30:39.360 --> 30:41.360
And finally a jump itself.

30:41.360 --> 30:49.360
The JSR, or jump to subroutine instruction, is a direct instruction to jump somewhere else in the program.

30:49.360 --> 30:54.360
When we execute it, the current program address is pushed to the stack.

30:54.360 --> 31:00.360
This allows us to subsequently return to the current location by pulling from the stack.

31:00.360 --> 31:06.360
The new program location is then passed into the program counter via the data bus.

31:06.360 --> 31:08.360
And that's everything.

31:08.360 --> 31:15.360
We can move 8 bit values, do simple arithmetic on them and jump to different places in our code.

31:15.360 --> 31:17.360
That is it.

31:17.360 --> 31:29.360
Let's have a look at my attempt to turn these simple instructions into something on screen.

31:30.360 --> 31:36.360
The three families of operation codes discussed collectively form the 6502 assembly language.

31:36.360 --> 31:43.360
Almost all programming today is done with higher level languages, where we don't need to worry about physical hardware so much.

31:43.360 --> 31:49.360
Even in the 1980s, most coding was done using the likes of BASIC, C and FORTRAN.

31:49.360 --> 31:54.360
However, high level languages require considerably higher memory usage.

31:54.360 --> 32:01.360
And they must be compiled to assembly, resulting in less efficient use of the CPU and therefore slower running.

32:01.360 --> 32:05.360
Elite, therefore, was programmed in assembly.

32:05.360 --> 32:14.360
I decided the only way I could possibly do Elite justice and make an actually informative video was to learn 6502 assembly.

32:14.360 --> 32:21.360
And, well, let's just say my 10 years of programming experience were almost useless.

32:21.360 --> 32:28.360
I set myself the challenge of creating anything in 3D on the micro, but using assembly only.

32:28.360 --> 32:35.360
I'm happy to say I managed to achieve this, but it took longer than producing any other part of this video.

32:35.360 --> 32:39.360
So, enough tiptoeing around, let's see the final result.

32:39.360 --> 32:42.360
Prepare to be underwhelmed.

32:42.360 --> 32:46.360
So, yeah, that took me 5 days.

32:46.360 --> 32:52.360
It uses lookup tables to plot the positions of the vertices in 3D space.

32:52.360 --> 32:56.360
The tables are called from a subroutine which draws a single line.

32:56.360 --> 33:04.360
The appropriate value from each table is retrieved by using the values in the Y register, which increments every time a line is drawn.

33:04.360 --> 33:11.360
It's tiny because I cheated and used an inbuilt line drawing routine from the operating system.

33:11.360 --> 33:17.360
But that divides the screen into 1200 by 1200 points.

33:17.360 --> 33:21.360
But we can only count to 256 with this 8-bit system.

33:21.360 --> 33:30.360
And I definitely wasn't going to go and get my head around dealing with that, so I just made the whole thing 250 by 250 units in size.

33:30.360 --> 33:38.360
It flickers like mad too, but that's true of Elite as well, so I don't feel too bad about that part.

33:38.360 --> 33:48.360
Okay, now let's go and see how to code in 6502 assembly properly.

33:48.360 --> 33:52.360
Elite was initially released on both tape and disc versions.

33:52.360 --> 33:58.360
The tape version is the 22 kilobytes one, as it had to fit entirely within memory.

33:58.360 --> 34:01.360
Loading from a tape during gameplay is not really possible.

34:01.360 --> 34:07.360
The disc version has a few more features, like additional ships, and you can only do asteroid mining in that version.

34:07.360 --> 34:11.360
As these could be loaded in from the disc while the player was docked.

34:11.360 --> 34:15.360
The code itself for the two versions is essentially the same.

34:15.360 --> 34:19.360
The disc version just contains some more stored variables.

34:19.360 --> 34:27.360
And in case you're wondering, a tape version was absolutely necessary if ACONsoft wanted to actually sell any copies to the home market.

34:27.360 --> 34:34.360
Back in 1984, a disc drive in the UK cost as much as the BBC Micro itself.

34:34.360 --> 34:43.360
Although the memory constraints not as tight when loading from disc, the limited compute capability of the 6502 was still a huge challenge.

34:43.360 --> 34:47.360
Just recall the one frame per second flight simulator I showed earlier.

34:47.360 --> 34:51.360
For every frame in flight, every vertex on screen needs calculating.

34:51.360 --> 34:54.360
Every line between them must be calculated.

34:54.360 --> 34:57.360
An individual pixel is inserted into screen memory.

34:58.360 --> 35:04.360
The 6502 in the BBC Micro operated at 2 MHz, or 2 million cycles per second.

35:04.360 --> 35:14.360
This sounds like a lot at first, but as we go through some examples, we'll get a taste of how many individual operations need to be carried out to draw a single frame.

35:14.360 --> 35:21.360
Bear in mind, every assembly instruction requires two CPU cycles at absolute minimum.

35:21.360 --> 35:26.360
The subroutine for just drawing a single pixel requires 20 operations.

35:26.360 --> 35:32.360
And that's after all the necessary calculations have been performed to decide where to even draw that pixel.

35:32.360 --> 35:37.360
So for a full screen, it's easy to see how cycles are eaten up quickly.

35:37.360 --> 35:42.360
The code for Elite is essentially one large script of 6502 instructions.

35:42.360 --> 35:51.360
Trying to understand any of this is daunting at first, but it becomes much more manageable when we understand that it consists of a main gameplay loop.

35:51.360 --> 35:58.360
Depending on the current state of play, this loop calls upon individual subroutines as and when necessary.

35:58.360 --> 36:04.360
Each subroutine performs a simple task, such as drawing a line or updating the player's kill count.

36:04.360 --> 36:12.360
So the code is very much modular, and understanding individual modules allows us to build up to something bigger.

36:12.360 --> 36:15.360
The full source code for Elite is available on GitHub.

36:16.360 --> 36:23.360
When I set out to make this video, I was going to go through the main flow of the code and broadly explain how the main features are implemented.

36:23.360 --> 36:27.360
However, it turns out someone's already done all the work for me.

36:27.360 --> 36:35.360
Mark Mokson annotated every line of the original code and has a frankly incredible website which breaks down every element of it.

36:35.360 --> 36:41.360
It also includes many deep dive articles on some of the technical details of the code.

36:41.360 --> 36:43.360
This left me with a problem, however.

36:43.360 --> 36:49.360
I wasn't going to just regurgitate Mark's Herculean work here and try and take credit.

36:49.360 --> 36:58.360
So instead, this section of the video will walk through some choice examples and show how the code maps back to the 6502 itself.

36:58.360 --> 37:02.360
And I'll show some of my own visuals to make everything easier to understand.

37:02.360 --> 37:15.360
Remember how just under a quarter of the available memory was dedicated to storing pixel values to draw on the screen?

37:15.360 --> 37:17.360
Let's talk more about that.

37:17.360 --> 37:26.360
Drawing graphics on the BBC Micro is typically done at a resolution of 320 by 256, and eight colors are available.

37:26.360 --> 37:31.360
So every pixel would require three bits of memory to store its color value.

37:31.360 --> 37:36.360
That's because there are eight possible three-bit numbers, one for each color.

37:36.360 --> 37:43.360
So to store a frame at this resolution, we require 320 by 256 by three bits.

37:43.360 --> 37:50.360
That comes to 30 kilobytes just for the frame buffer, essentially leaving no room for our program.

37:50.360 --> 37:52.360
Oh dear.

37:52.360 --> 37:56.360
Okay, so we have two options to reduce the frame buffer.

37:56.360 --> 38:00.360
The first is to reduce the number of bits per pixel.

38:00.360 --> 38:05.360
Let's just represent each pixel with a single bit, one or zero.

38:05.360 --> 38:09.360
That reduces our frame buffer to 10 kilobytes, not bad.

38:09.360 --> 38:16.360
But with only a binary option for each pixel, that means we're limited to just black and white.

38:16.360 --> 38:21.360
The second option is to reduce the number of pixels to plot in the first place.

38:21.360 --> 38:28.360
By reducing our resolution to 160 by 256 and using say four colors only,

38:28.360 --> 38:32.360
we'd also reduce the frame buffer to about 10 kilobytes.

38:32.360 --> 38:37.360
So it looks like we'd have to choose between either high resolution or color.

38:37.360 --> 38:40.360
We can't have both.

38:40.360 --> 38:42.360
Or can we?

38:42.360 --> 38:44.360
Look closer.

38:44.360 --> 38:48.360
The combat viewing elite has high resolution but no color.

38:48.360 --> 38:52.360
The dashboard is in color but at low resolution.

38:52.360 --> 38:55.360
This was elite's first unique innovation.

38:55.360 --> 39:00.360
Before any pixels are plotted on an individual frame, a timer's started.

39:00.360 --> 39:03.360
We know the number of pixels to plot in high resolution.

39:03.360 --> 39:07.360
And we know the rate at which these pixels are plotted to the screen.

39:07.360 --> 39:11.360
It's one megahertz for the BBC Micro.

39:11.360 --> 39:16.360
So a timer is set to trigger after all the high res pixels have been plotted.

39:16.360 --> 39:21.360
The top half of the screen is drawn in the aforementioned high resolution.

39:21.360 --> 39:28.360
The timer then triggers an interrupt, which calls a subroutine, to switch to the lower resolution mode.

39:28.360 --> 39:36.360
This is achieved by switching registers in the video processing chip to convert it to low resolution for drawing the dashboard.

39:36.360 --> 39:40.360
And that's achievable through some assembly commands.

39:40.360 --> 39:46.360
As far as I can tell, this was the first game ever to use this split screen configuration.

39:46.360 --> 39:50.360
And it was definitely the first to do so on a BBC Micro.

39:51.360 --> 39:56.360
The end result is 7,936 bytes reserved for the frame buffer,

39:56.360 --> 40:00.360
leaving just enough room for the actual program.

40:00.360 --> 40:04.360
And a game that looks both sharp, yet colorful.

40:04.360 --> 40:07.360
Something not seen on a home computer before.

40:11.360 --> 40:16.360
Now let's take a look at a more obvious feature, the 3D graphics themselves.

40:16.360 --> 40:23.360
One reason they looked so good was that Elite was the first game playable at home to feature hidden line removal.

40:23.360 --> 40:29.360
Unlike earlier wireframe graphics, which themselves were barely existent in games at the time.

40:29.360 --> 40:33.360
If an edge on an object is obscured, it's not shown.

40:33.360 --> 40:36.360
This was a tricky problem to solve at the time.

40:36.360 --> 40:42.360
It still caused John Carmack a headache nearly 10 years later when optimizing Doom.

40:42.360 --> 40:46.360
In the case of Elite, the solution implemented was quite simple in concept,

40:46.360 --> 40:51.360
but required some clever design to be executed in acceptable speed.

40:51.360 --> 40:55.360
We start by looking at how objects are stored.

40:55.360 --> 40:59.360
The final few pages of memory are used to store the ship's blueprints.

40:59.360 --> 41:02.360
These are a series of lookup tables.

41:02.360 --> 41:08.360
The first table is a number of basic attributes, such as max speed and laser power.

41:08.360 --> 41:12.360
The second table for each ship is the vertices.

41:12.360 --> 41:17.360
This defines the position of each vertex relative to the center of the ship.

41:17.360 --> 41:23.360
I've seen it written before that blueprints contained only half a ship, with the other half generated on the fly.

41:23.360 --> 41:25.360
However, this is not true.

41:25.360 --> 41:30.360
We see the full vertex count for every ship when we look at the source code.

41:30.360 --> 41:32.360
Next is a table of edges.

41:32.360 --> 41:35.360
This is a list of plotable edges for the ship.

41:35.360 --> 41:40.360
Each defined by its starting and ending vertices and adjoining faces.

41:40.360 --> 41:46.360
The edge and vertex tables contain all the necessary data to plot a wireframe ship.

41:46.360 --> 41:53.360
However, in order to perform hidden line removal, the positions of the faces need to somehow be characterized.

41:53.360 --> 41:57.360
So, the final table for each ship is a list of faces.

41:57.360 --> 42:01.360
But how are these faces defined?

42:01.360 --> 42:05.360
Each one is characterized by what's called its normal vector.

42:05.360 --> 42:08.360
Let me explain what this looks like.

42:08.360 --> 42:13.360
Imagine drawing a line from the ship's center to the facing question.

42:13.360 --> 42:20.360
Now, the aim here is to draw this line so that it intersects the face at a 90-degree angle.

42:20.360 --> 42:26.360
Looking at a Tharguide ship as an example, this is easy enough to do for this face.

42:26.360 --> 42:28.360
But how about this one?

42:28.360 --> 42:33.360
We can imagine extending the face until a solution is found.

42:33.360 --> 42:43.360
These vectors are defined by three values, the x, y and z distance from the origin to the point of intersection on this extended face.

42:43.360 --> 42:52.360
Bell and Braben pre-computed these x, y, z distances and saved them in the face lookup table for every object in the game.

42:52.360 --> 42:56.360
Now, let's put the player's ship in our scene.

42:56.360 --> 43:00.360
This face here should be visible to the player.

43:00.360 --> 43:07.360
We know the position of the enemy ship relative to the player, so let's add the vector in for that too.

43:07.360 --> 43:13.360
Finally, the main flight loop calculates the rotation of every object in the scene.

43:13.360 --> 43:20.360
This is defined by three more vectors, one for each axis. Let's add those too.

43:20.360 --> 43:27.360
And with that, we have everything we need to remove the hidden lines, or I should say hidden faces.

43:27.360 --> 43:33.360
Rather than considering lines individually, faces as a whole are checked.

43:33.360 --> 43:36.360
First, we need to know the line of sight to the face.

43:36.360 --> 43:42.360
We can do that by summing the object's position vector and the face normal vector.

43:42.360 --> 43:49.360
Visually, vector addition works like this, so we now have a line of sight vector to our face.

43:50.360 --> 43:54.360
Every object in Elite was designed to be exclusively convex,

43:54.360 --> 44:01.360
so if a face's normal vector is pointing away from us, we know that face must be obscured.

44:01.360 --> 44:07.360
Or more formally, the angle between the normal vector and line of sight vector

44:07.360 --> 44:14.360
must be greater than 90 degrees for a face to be hidden, so we can perform this simple calculation.

44:14.360 --> 44:18.360
This is known as the dot product between the two vectors.

44:18.360 --> 44:23.360
Dot products are used all the time in 3D computation because they're very simple to calculate.

44:23.360 --> 44:27.360
Indeed, here's the subroutine Bell and Braben wrote,

44:27.360 --> 44:33.360
Crucially, a negative dot product denotes two vectors that are less than 90 degrees apart,

44:33.360 --> 44:38.360
and a positive one denotes two that are greater than 90 degrees apart.

44:38.360 --> 44:41.360
So, we calculate this dot product for our faces,

44:41.360 --> 44:49.360
and only plot edges associated with faces where the line of sight to the face normal dot product is less than one.

44:49.360 --> 44:52.360
Now, there is one minor step I missed out.

44:52.360 --> 44:58.360
In reality, face normal vectors are relative to the orientation of the ship to be plotted,

44:58.360 --> 45:04.360
so the player's x, y, z coordinates need to be translated to the ship's local coordinate system.

45:04.360 --> 45:08.360
This is done by modifying our line of sight vector as shown here,

45:08.360 --> 45:10.360
but the end result's the same.

45:10.360 --> 45:14.360
Faces are only plotted when the dot product is negative.

45:14.360 --> 45:20.360
See Mark Moxon's Deep Dive article for more details on this step if you need convincing why this is necessary.

45:27.360 --> 45:33.360
These three numbers and this simple formula define elite's entire universe.

45:33.360 --> 45:40.360
It's sometimes stated that the universe is randomly generated, but it's a little bit more elegant than that.

45:40.360 --> 45:43.360
It is in fact procedurally generated.

45:43.360 --> 45:46.360
That means the same universe is created every time.

45:46.360 --> 45:53.360
Elite wasn't the first game to feature procedural generation, but it was the first to apply it on such a scale.

45:53.360 --> 45:56.360
Let's see how those three numbers define a system.

45:56.360 --> 45:59.360
These numbers are referred to as seeds.

45:59.360 --> 46:03.360
Each is expressed as a 16-bit binary value.

46:03.360 --> 46:07.360
Now, different bits within each form parameters for the system.

46:07.360 --> 46:12.360
Two entire bytes define the coordinates of the system in the galaxy.

46:12.360 --> 46:18.360
These two bits define the system tech level, and these two define the prosperity level.

46:18.360 --> 46:25.360
They're used to bias a pseudo randomly generated number to decide the prices of commodities at the system.

46:25.360 --> 46:28.360
These three define the system's government type.

46:28.360 --> 46:38.360
In a similar manner to the economic variables, the value stored here increases or decreases the likelihood of encountering pirates at the system.

46:38.360 --> 46:41.360
And these three define the distance to the planet.

46:41.360 --> 46:46.360
All other system attributes are similarly defined with the remaining bits.

46:46.360 --> 46:50.360
The three numbers on screen define the first system plotted.

46:50.360 --> 46:54.360
Then, that deceptively simple formula is applied.

46:54.360 --> 47:00.360
We add the three values, append the result to our list, and discard the first value.

47:00.360 --> 47:04.360
And that gives us the three seed values for the next galaxy.

47:04.360 --> 47:11.360
The process is repeated 255 times to give a galaxy of 256 stars.

47:11.360 --> 47:17.360
If the result is greater than 16 bits in length, we just take the carry value and continue on.

47:17.360 --> 47:23.360
And the process itself is repeated a further 7 times to give a total of 8 galaxies.

47:23.360 --> 47:25.360
And that's all there is to it.

47:32.360 --> 47:35.360
The final feature I'd like to go through is the radar.

47:35.360 --> 47:38.360
This has an almost legendary status.

47:38.360 --> 47:42.360
It was the final few lines of code written before Elite was released.

47:42.360 --> 47:46.360
Braben had to convince Aconsoft to add it in last minute.

47:46.360 --> 47:50.360
But it completely changes the nature of the combat sequences.

47:50.360 --> 47:56.360
It's quite funny watching videos of novices playing and not even realising the radar's there.

47:56.360 --> 48:00.360
They hear the sound of being shot at but don't know where it's coming from

48:00.360 --> 48:04.360
and kind of flail around pitching and rolling randomly.

48:04.360 --> 48:11.360
But once they realise the radar's there and how it works, it completely changes how they handle combat.

48:11.360 --> 48:13.360
It's simple to use.

48:13.360 --> 48:18.360
Objects within range of the player are shown as sticks with a little flag at the end.

48:18.360 --> 48:22.360
A stick behind the player represents an object behind them.

48:22.360 --> 48:25.360
And one in front is an object in front of them.

48:25.360 --> 48:29.360
Likewise a stick extending upwards mean the object is above the player

48:29.360 --> 48:32.360
and downwards means it's below them.

48:32.360 --> 48:37.360
So the radar provides a full representation of the 3D space around the player

48:37.360 --> 48:40.360
and can be understood at a glance.

48:40.360 --> 48:42.360
Genius!

48:42.360 --> 48:44.360
I'll go into full depth for this one.

48:44.360 --> 48:49.360
We've made it this far so let's go crazy and get my 6502 model on screen.

48:49.360 --> 48:53.360
The scan subroutine performs this task.

48:53.360 --> 49:00.360
Let's figure out how it draws a single dot representing another ship in the correct position on screen.

49:00.360 --> 49:05.360
Every object within range of the player's ship has a ship type variable.

49:05.360 --> 49:12.360
For the current ship, this variable along with the ship data is moved into the 0 page workspace for fast access.

49:12.360 --> 49:16.360
Therefore saving clock cycles.

49:16.360 --> 49:21.360
We load that object's ID from the workspace and into the accumulator.

49:21.360 --> 49:27.360
Objects such as planets and suns are designed to have their most significant bits set to 1 in the ID.

49:27.360 --> 49:30.360
And this sets the minus flag to 1.

49:30.360 --> 49:37.360
So a break if minus command causes us to return from the subroutine and not plot that object.

49:37.360 --> 49:46.360
For plot of the objects, the hex representation of the plot color, which is green for ships, is loaded into the x register.

49:46.360 --> 49:51.360
The color green is represented by ff in hex.

49:51.360 --> 49:56.360
This color variable is then stored in the workspace.

49:56.360 --> 50:02.360
The ship data in the workspace contains x, y and z coordinate values.

50:02.360 --> 50:07.360
Each is two bytes and represents the ship's position relative to the player.

50:07.360 --> 50:18.360
We load the most significant byte of the x coordinate into the accumulator and perform a logical or on the respective bytes from the y and z coordinates.

50:18.360 --> 50:27.360
One more logical and is performed on the result using the binary value 11000000.

50:27.360 --> 50:36.360
If the result is zero, the two most significant bits of all coordinate values are zero and the ship is in plotting range.

50:36.360 --> 50:39.360
So branch on not zero.

50:39.360 --> 50:44.360
A positive result here would return from the subroutine.

50:44.360 --> 50:49.360
Let's assume the ship is within plotting range.

50:49.360 --> 51:00.360
To convert a ship's world x position to an x coordinate on screen, i.e. on the scanner, we add 123 to the most significant byte of the x position.

51:00.360 --> 51:06.360
We don't need to go through why that is here, but let's just take it at face value.

51:07.360 --> 51:15.360
Assuming x is positive, we simply load the ship's high x byte into the accumulator and add 123.

51:15.360 --> 51:22.360
The resulting value is stored in location x1 in the zero page workspace.

51:22.360 --> 51:30.360
A similar process is carried out for the y coordinate, saving it in location y1 in the zero page workspace.

51:31.360 --> 51:39.360
Finally, an existing subroutine is called to draw a double length dot at the coordinates x1, y1.

51:39.360 --> 51:48.360
I definitely won't go into details of how this works, but in summary, it loads x1 and y1 into the accumulator and x register,

51:48.360 --> 51:53.360
converts the coordinate values into the correct locations in screen memory,

51:53.360 --> 51:58.360
and performs an exclusive OR operation on these locations.

51:58.360 --> 52:07.360
If nothing was plotted there before, the exclusive OR operation populates the pixel at the correct memory location with the color value we previously stored.

52:07.360 --> 52:11.360
Actually, let's take a second to think about that.

52:11.360 --> 52:20.360
When writing pixel values to the frame buffer, Elite's source code always uses an exclusive OR instead of just writing the value directly.

52:20.360 --> 52:27.360
Let's consider writing a single pixel and see what would happen if we just wrote the new value directly.

52:27.360 --> 52:31.360
The bottom row of this truth table is the important one here.

52:31.360 --> 52:33.360
Imagine us building up our frame.

52:33.360 --> 52:36.360
We may first add in the object for the star,

52:36.360 --> 52:44.360
but then adding all the lines for the spacecraft would just draw white lines in front of a white star, rendering the spacecraft invisible.

52:44.360 --> 52:48.360
Here's the truth table for the exclusive OR pixel right.

52:48.360 --> 52:52.360
Now a white on white pixel flips to black.

52:52.360 --> 52:55.360
So spacecraft are visible in front of white objects.

52:55.360 --> 52:57.360
They look like this.

52:57.360 --> 53:01.360
It doesn't even matter what order the objects are written to the frame buffering.

53:01.360 --> 53:07.360
Or if only part of the object occludes the star, this will always work.

53:07.360 --> 53:11.360
At the expense of a single instruction when writing pixel values,

53:11.360 --> 53:15.360
Braben and Bell never needed to worry about objects disappearing in front of stars.

53:15.360 --> 53:18.360
It was all handled automatically.

53:18.360 --> 53:21.360
Even with me skipping over how Y coordinates are calculated,

53:21.360 --> 53:24.360
how screen memory locations are determined,

53:24.360 --> 53:28.360
and how the stick from the object on the scanner is drawn,

53:28.360 --> 53:33.360
that was still a lot to go through just to get a single dot on screen.

53:33.360 --> 53:36.360
But that's how the source code was built up in general,

53:36.360 --> 53:39.360
by taking individual tasks,

53:39.360 --> 53:41.360
breaking them down into simple problems,

53:41.360 --> 53:46.360
and figuring out how to implement the solutions in assembly.

53:46.360 --> 53:49.360
Each solution was translated into a subroutine,

53:49.360 --> 53:53.360
and meticulously optimised to save memory and compute.

53:53.360 --> 53:59.360
No single subroutine is particularly complex or difficult to understand,

53:59.360 --> 54:08.360
but they combine to create an entire universe.

54:08.360 --> 54:13.360
It's difficult to quantify the effect Elite had on the computing sector as a whole.

54:13.360 --> 54:17.360
Every British software developer I've spoke to that went to school in the 1980s

54:17.360 --> 54:20.360
cites Elite as a reason they got into computing.

54:20.360 --> 54:23.360
Being able to code the game on the same machine you could play it on

54:23.360 --> 54:26.360
probably had something to do with that.

54:26.360 --> 54:28.360
Though I was born too late for Elite's release,

54:28.360 --> 54:31.360
we had a copy on our Acorn Archimedes at home.

54:31.360 --> 54:33.360
I liked it.

54:33.360 --> 54:37.360
I was told it was a big deal, but I didn't really understand why, because I was 8.

54:37.360 --> 54:41.360
A couple of years later, I realised the game was nearly 15 years old,

54:41.360 --> 54:45.360
which completely blew me away at the time.

54:45.360 --> 54:47.360
In the years following Elite's success,

54:47.360 --> 54:51.360
Bell gradually distanced himself from the gaming industry.

54:51.360 --> 54:55.360
I've heard he grew to dislike the proliferation of violent video games,

54:55.360 --> 54:57.360
something I can't really relate to,

54:57.360 --> 55:01.360
since I grew up with the likes of Doom, Half-Life and BioShock.

55:01.360 --> 55:07.360
His personal website is a quirky record of what the World Wide Web looked like in the 1990s.

55:07.360 --> 55:10.360
It also contains the source code for Elite,

55:11.360 --> 55:15.360
that did cause a bit of a legal kerfuffle between himself and Braben,

55:15.360 --> 55:18.360
but I understand the two have been back on speaking terms for years now,

55:18.360 --> 55:20.360
so that's nice.

55:20.360 --> 55:22.360
Braben on the other hand,

55:22.360 --> 55:25.360
he used the success of Elite to found Frontier Games,

55:25.360 --> 55:28.360
which remains a major UK developer to this day.

55:28.360 --> 55:32.360
In fact, he only stepped down as CEO in 2022.

55:32.360 --> 55:37.360
In 2014, Frontier released a modern day adaptation of Elite.

55:37.360 --> 55:39.360
Elite Dangerous.

55:39.360 --> 55:41.360
Backed by what was, at the time,

55:41.360 --> 55:44.360
the largest ever crowdfunding campaign in the UK.

55:44.360 --> 55:46.360
And it's amazing.

55:46.360 --> 55:49.360
A one-to-one scale map of the Milky Way,

55:49.360 --> 55:52.360
with 400 billion star systems to explore.

55:54.360 --> 55:56.360
Prior to that, in 2008,

55:56.360 --> 55:59.360
he became one of the co-founders of the Raspberry Pi Foundation,

55:59.360 --> 56:03.360
who went on to completely revolutionise access to cheap compute hardware,

56:03.360 --> 56:06.360
and spawned a new generation of hobbyists.

56:06.360 --> 56:08.360
I'm one of them.

56:08.360 --> 56:12.360
I pre-ordered my first Pi on the day they were announced.

56:12.360 --> 56:14.360
I was on an oil rig at the time,

56:14.360 --> 56:17.360
and though I'd been employed for less than a year,

56:17.360 --> 56:20.360
I was already looking for a way out of that industry.

56:20.360 --> 56:22.360
I learned how to navigate a Linux system,

56:22.360 --> 56:24.360
run distributed compute,

56:24.360 --> 56:28.360
and even how to containerise applications thanks to the Raspberry Pi.

56:32.360 --> 56:36.360
Elite was ported to every major platform it could viably run on.

56:36.360 --> 56:39.360
Of course, making it accessible to cheaper systems,

56:39.360 --> 56:41.360
such as the ZX Spectrum and Acorn Electron,

56:41.360 --> 56:44.360
played a huge part in the game's record sales.

56:44.360 --> 56:48.360
Perhaps most astonishing is the NES port.

56:48.360 --> 56:51.360
That's right, you could play Elite on the NES,

56:51.360 --> 56:55.360
a machine designed entirely not for 3D vector graphics.

56:55.360 --> 56:58.360
In fact, I've done just that.

56:58.360 --> 57:00.360
Back when I was at university,

57:00.360 --> 57:02.360
I owned an NES for retro gaming,

57:02.360 --> 57:04.360
and I had a copy of Elite.

57:04.360 --> 57:08.360
To be honest, it was the only game I used to play on the thing.

57:08.360 --> 57:12.360
An upgraded version was also released for MS-DOS,

57:12.360 --> 57:14.360
known as Elite Plus,

57:14.360 --> 57:18.360
coded entirely by another legendary UK gaming figure,

57:18.360 --> 57:19.360
Chris Sawyer.

57:19.360 --> 57:21.360
If you don't know that name,

57:21.360 --> 57:24.360
just keep an eye out on the outro sequence.

57:24.360 --> 57:28.360
Elite marked the end of the dominance of the arcade shooter.

57:28.360 --> 57:30.360
Less than one year after its release,

57:30.360 --> 57:33.360
the NES was debuted in the US and Europe,

57:33.360 --> 57:35.360
though most games for this platform

57:35.360 --> 57:37.360
didn't match Elite's level of complexity.

57:37.360 --> 57:39.360
Even relatively accessible titles,

57:39.360 --> 57:41.360
such as Super Mario Brothers and Zelda,

57:41.360 --> 57:43.360
provided a much richer experience

57:43.360 --> 57:46.360
than had been previously available.

57:46.360 --> 57:48.360
In retrospect, it really feels like

57:48.360 --> 57:50.360
Bell and Braben opened the floodgates

57:50.360 --> 57:54.360
by demonstrating what was possible with 8-bit hardware.

57:54.360 --> 57:57.360
Though they had pushed that hardware to its limits,

57:57.360 --> 58:00.360
and we'd have to wait until the 1990s

58:00.360 --> 58:02.360
and the rise of 32-bit systems

58:02.360 --> 58:06.360
to see an explosion in 3D rendering technology.

58:06.360 --> 58:09.360
By then, most major games were no longer produced

58:09.360 --> 58:11.360
by solitary bedroom coders,

58:11.360 --> 58:13.360
but by large studios,

58:13.360 --> 58:16.360
with large design and advertising budgets to match.

58:16.360 --> 58:18.360
By the end of the 1990s,

58:18.360 --> 58:20.360
another hardware wall was hit.

58:20.360 --> 58:22.360
Back in 1984,

58:22.360 --> 58:24.360
Elite required real-time calculation

58:24.360 --> 58:27.360
and plotting of several to dozens of polygons

58:27.360 --> 58:29.360
on screen at a given time.

58:29.360 --> 58:31.360
But by now, the polygon count

58:31.360 --> 58:33.360
that was demanded by designers

58:33.360 --> 58:36.360
was outpacing improvements in CPU speed.

58:36.360 --> 58:38.360
A new approach was needed.

58:38.360 --> 58:40.360
Wouldn't it be nice to calculate the positions

58:40.360 --> 58:42.360
of all these polygons in parallel?

58:42.360 --> 58:45.360
Thus, the GPU was born.

58:45.360 --> 58:47.360
Why use one very fast processor

58:47.360 --> 58:50.360
when you can use many slow ones at once?

58:50.360 --> 58:52.360
About 10 years later,

58:52.360 --> 58:55.360
something very unusual happened.

58:55.360 --> 58:58.360
Typically, new technologies start out relatively expensive

58:58.360 --> 59:01.360
and are only used experimentally,

59:01.360 --> 59:04.360
and then by commercial or government organizations,

59:04.360 --> 59:07.360
before becoming cheap enough to sell to consumers.

59:07.360 --> 59:10.360
But the opposite happened with GPUs.

59:10.360 --> 59:14.360
A new field was rapidly growing in the late 2000s,

59:14.360 --> 59:16.360
data science.

59:16.360 --> 59:18.360
It was realised that the computations

59:18.360 --> 59:20.360
necessary to train neural networks

59:20.360 --> 59:22.360
are similar in principle to those used

59:22.360 --> 59:25.360
to calculate polygons for 3D rendering.

59:25.360 --> 59:27.360
Data scientists realised that in some cases,

59:27.360 --> 59:29.360
cheap off-the-shelf gaming GPUs

59:29.360 --> 59:32.360
outperformed supercomputers.

59:32.360 --> 59:36.360
I first used a GPU to train up an algorithm in 2015,

59:36.360 --> 59:39.360
and now it's something I do on a daily basis.

59:39.360 --> 59:41.360
The algorithm that recommended this video to you

59:41.360 --> 59:44.360
was trained in a cluster of GPUs.

59:44.360 --> 59:47.360
The implications of large-scale deployment

59:47.360 --> 59:49.360
of advanced machine learning algorithms

59:49.360 --> 59:51.360
are not yet fully understood,

59:51.360 --> 59:53.360
and we would have got there without Elite,

59:53.360 --> 59:56.360
but I think it's fair to say we'd have got there slower.

59:57.360 --> 59:59.360
But back to gaming.

59:59.360 --> 01:00:02.360
UK gaming specifically.

01:00:02.360 --> 01:00:05.360
Elite was our breakout game, if you will.

01:00:05.360 --> 01:00:07.360
In the four decades that have followed,

01:00:07.360 --> 01:00:10.360
the UK gaming industry has birthed some of the most influential

01:00:10.360 --> 01:00:13.360
and best-selling games of all time,

01:00:13.360 --> 01:00:16.360
and they continue to do so.

01:00:16.360 --> 01:00:18.360
And not just huge developers, either.

01:00:18.360 --> 01:00:21.360
With the rise of accessible gaming engines,

01:00:21.360 --> 01:00:24.360
such as Unity, Unreal, and now Godot,

01:00:24.360 --> 01:00:26.360
it's again possible for small teams,

01:00:26.360 --> 01:00:29.360
and even individuals, to design, write,

01:00:29.360 --> 01:00:32.360
and publish great games.

01:00:32.360 --> 01:00:35.360
Bell and Braben set out to make a great game,

01:00:35.360 --> 01:00:38.360
but they also fostered an entire industry.

01:01:54.360 --> 01:01:57.360
Thank you.

