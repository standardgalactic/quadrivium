Let's go back to 1984 in the UK.
In a few short years, home computers have gone from practically non-existent to commonplace.
Almost every child in the country has access to a BBC microcomputer at school, and the
ZX Spectrum is topping out Christmas wish lists.
And despite a crash in the video games market in the USA, games are still flying off the
shelves here.
While there's plenty choice, almost every game available to play at home is some variation
of the same thing.
A 10 minute tops arcade style run at a high score.
Longer form strategy and adventure games do exist, largely in the form of text adventures,
sometimes with accompanying imagery, but not with real time graphics, and certainly not
in an open world.
Home computers are more popular than consoles in the UK, and let's be honest, many of the
games on these look, well, take a look for yourself.
As for 3D graphics, the choices are even more limited.
Every 3D game on the market is either not actually 3D, or is not really a game.
There are a few flight simulators, technically impressive for the day, but not exactly immersive.
Sublogix FS1 Flight Simulator was arguably the first full 3D game created for the home,
and it looks like this.
Doesn't this gameplay look fun?
And the frame rate, let's just say, it has a frame rate.
Microsoft Flight Simulator 2 has just released, but that requires a $5,000 IBM PC to play,
and no one had one of those outside the office.
Arcade cabinets with more specialized hardware have taken a step into 3D gaming, but I can't
find a single example of a true 3D game that isn't a flight simulator prior to 1984.
Battle zones are competitor, but movement and object tracking is restricted to two axes,
a sort of pseudo 3D game.
And there are a few other on-rails shooters, limited in scope, and always a slave to the
high score.
The best-selling games at the moment are Pac-Man and Space Invaders.
You probably remember them looking like this.
Problem is, those are the arcade versions.
If you wanted to play them at home on your Atari 2600, this is what they looked like.
Then Elite was released.
Elite looked like this.
It changed gaming in Europe overnight.
It was an open universe game.
No high score, no restrictions, and full, true 3D graphics.
A procedurally generated universe, a backstory in the form of a novella, pirates, trading,
asteroid mining, an economy, and you could play it at home or at school.
Non-European viewers are unlikely to be familiar with the impact Elite had on gaming and computing.
But here in the UK, the 20th of September 1984, was the day computer games became a
serious business.
This is a story I've been obsessed with since I was a teenager.
It shaped my life personally, and there is a direct path between some of the innovations
made by Elite's creators and my professional work today.
This may come as a surprise to some subscribers, but I previously worked in the computer games
industry.
Not for very long, but my first role as a data scientist after quitting engineering
was for a UK-based games developer in Dundee.
I even learned Unity and coded up a couple of games myself during this period.
Of course, I wouldn't use Unity now after recent events.
The story of Elite's creation is already told on YouTube.
However, I'm not going to focus too much on the history and the individuals.
Instead, I'd like to dive into some of the technical details on how the game was even
possible and how some of its major challenges were tackled.
And I promise, absolutely zero programming knowledge is necessary to understand what
I'll be discussing.
Before we get into the full story, I'd like to make a quick political disclaimer.
Elite is very much a British success story.
It was a rare case of government, industry, the academic sector, and even state-funded
media inadvertently working together to produce something amazing.
The government at the time, however, was one of the most contentious in UK history.
The Thatcher government.
Now, I try to adopt a policy on this channel of not getting bogged down in politics, but
also not skirting around them.
I don't see it as my role to tell viewers what to think politically.
So, let's just say that sometimes bad governments do good things, and sometimes good governments
do bad things.
And it's up to you to decide if that applies here.
Let's take a look at the machine Elite was originally coded on and created for.
This is the BBC Micro.
This video was a good excuse for me to finally get one.
Of course, I got hold of a broken one to bring back to life.
When dealing with technology that's older than me, I always feel to be worthy.
I have to fix it first.
I'll overlay some footage of the restoration here.
In fact, mine came with a cassette recorder, with a copy of Elite ready to go.
Yes, I could have just bought an SD card reader, but loading a game from a cassette tape was
one of those little things I just had to experience.
In the late 1970s, the UK was staring a disaster in the face.
Over in the US, the development of cheap microcontrollers had, in the space of a couple
of years, transformed computers from cabinet-sized mainframes that cost tens or even hundreds
of thousands of dollars to the likes of the Apple II, the TRS-80 and the Commodore PET.
Government and businesses in the US, and in Japan, and even other Western European countries
were quickly embracing the change.
In a small but dedicated portion of their population were becoming proficient in computing,
be it at home or in the workplace.
The UK was emerging from a financial crisis.
When isn't the UK in a financial crisis?
Traditional manufacturing industries such as mining, steelworking and shipbuilding were
either dying or dead.
No one was thinking about computers.
Likewise, the government was preoccupied with all of the above.
An unlikely contender resolved to address the issue before it was too late.
The UK's state-funded, but not state-controlled, broadcaster, the BBC.
The BBC acted fast and they acted decisively.
The Compute Alliteracy Project was to be a collection of TV and radio series intended
to teach the nation that computers weren't scary, obscure or just for nerds.
A tender was put out for a computer model to be adopted by the BBC for these broadcasts
and crucially it was to be adopted by schools too, with the government subsidising half
of the cost of every computer purchased by a school.
By this point, Clive Sinclair had released the ZX81.
This was an absolute bare-bones computer, but it was cheap, incredibly cheap.
And for that reason, I'll never knock it as many others do these days.
For less than £200 in 2023 money, a family could have a fully functioning 8-bit computer
at home.
Sinclair put it forward to the BBC for consideration, but was rejected.
It didn't come close to their specifications.
In what seems like a rare case of due consideration, the BBC required a surprisingly capable system
with network capability, full colour graphics and expansion capability.
Acorn Compute has rushed out a prototype for the BBC in four days.
This resistor here?
That simulates an engineer's finger on the board.
The system wouldn't boot without it.
And no one really knows what purpose it serves to this day.
Despite its whirlwind conception, Acorn's prototype was the only system that met the
BBC's specifications.
It exceeded some, with blisteringly fast RAM for the day, and a frankly wonderful potential
for expansion.
The BBC Micro Model B used a MOS 6502 CPU clocked at 2GHz, and it pushed it to its limits given
the Micro's IO capability.
32KB of RAM was available, along with an operating system that included a modified version of
BASIC, known as BBC BASIC.
BASIC was the programming language of the time.
In fact, the Micro boots straight into it.
Uniquely, assembly code can be inserted in line with BASIC commands.
If you're not familiar with assembly, don't worry, we'll get there soon.
The BASIC capability was provided via Acorn's proprietary Econet, and the capability for
a second co-processor was even provided via the tube interface.
This can even be used today to connect a Raspberry Pi, something I will definitely be doing in
the future.
The BBC Micro isn't a looker, but that large form factor makes it easy to add expansion
boards, just four screws to undo it and you're in.
There are plenty of empty ROM sockets for you to add more functionality.
And I have to mention the keyboard.
The Micro has a really nice mechanical keyboard.
Apparently that contributed significantly to the cost.
Right, okay, this is me back again three weeks after saying that.
Totally unscripted here by the way, and I've just spent an hour tapping away on that keyboard.
Yeah, it's very well built in that like a school child isn't going to destroy it.
It's a very slow keyboard though.
I don't know if I'd say it's a fantastic keyboard now.
Right, okay, back to three weeks ago Alex.
And indeed the Micro was not cheap.
About £1,600 in 2023 money.
Though I will note that was about the same cost as a Commodore 64, which is probably
the closest equivalent machine on the US market.
Yet, and this seems unbelievable today, the government still agreed to subsidise this
cost to schools.
By the end of the computer literacy project, 85% of UK primary and almost every secondary
school had at least one BBC Micro.
Almost every child in the country had free access to a good computer and free tuition
via the BBC, a project that seems almost too good to be true today, and probably the reason
why anyone born between about 1970 and 2000 in the UK seems to be perfectly proficient
with a computer.
Now let's look at the game itself.
Elite is an open world space exploration game.
We begin docked at Lavais station with 100 credits, 3 missiles, a pulse laser and a Cobra
Mark 3 spacecraft.
Leaving the station, we make a hyperspace jump to another system of our choice.
Every system has a summary screen denoting the government type and system wealth and
major industry.
Until we can afford to better equip our ship, novice players must now make a mad dash to
the system planet, where they'll find it's respective space station.
Time to dock.
This is notoriously difficult, though I'm not really sure why, here's how to do it.
Just ignore the manual and go in at half speed.
Every system has different commodity prices, and we're able to make a profit by trading
between appropriate systems.
This is a surprisingly involved process, so keep a notebook handy.
And probably don't trade anything illegal for now unless you want the galactic police
on your case.
Of course it's rarely this simple.
If you've warped into an anarchic system, get ready to be constantly harassed by pirates.
Even in the safest systems, it's rare to make a clean run to the home planet.
Later in the game, when we're better equipped, we can make a profit by bounty hunting these
pirates.
But for now, better get saving for that beam laser.
Oh and there are Tharguides too.
Those are aliens with tough flying saucers that spawn drones, and they're equipped with
electronic countermeasures so they'll render your missiles useless.
And that's the essence of it really.
It was a complete step change in computer games in 1984.
Short of the flight simulators I mentioned earlier, which as I said I would only loosely
define as games, there was nothing else with true 3D graphics available on an arcade machine,
let alone a home computer.
The universe of 8 galaxies, each consisting of 256 stars, along with their descriptions,
market prices and system characteristics, was procedurally generated.
The closest the game has to a high score is the player ranking, starting at harmless
and eventually reaching elite for only the most dedicated players.
You can be a trader, a bounty hunter, a pirate, an asteroid miner, or some combination of
all of these.
Truly an open world game with infinite choice and potential.
Sophie Wilson called it the program that couldn't have been written, and Steve Furber said it
had the BBC design team staggered.
Who are Sophie Wilson and Steve Furber?
Oh, they're just the pair that built the BBC Micro prototype in four days.
In what's now regarded as one of the greatest programming feats of all time, Elite was created
over the course of two years by Ian Bell and David Braben.
Both met while studying at Cambridge, though it seemed almost unfathomable for such a complex
game to be created by just two individuals.
This was actually unusual in UK development at the time.
Almost every game published in the UK prior to Elite had been coded by sole developers.
The UK games industry consisted almost exclusively of bedroom coders, sending in cassettes to
various small publishers, hopefully in exchange for a few hundred pounds and some bragging
rights.
When Bell approached Acornsoft, the software wing of Acorn computers, it was clear they'd
created something that had never been seen before.
Acornsoft therefore not only agreed to publish, but also decided to stage the first major
and highly publicised release of a game in the UK.
They ran TV adverts and hired out a theme park for the launch.
This seems trivial now, but this was completely unheard of in 1984.
As I showed in the intro, Elite completely eclipsed any competition.
Just immediately it became a national sensation, eventually selling over 100,000 copies for
the BBC Micro and 600,000 across all platforms.
Braben and Bell became celebrities who effectively jumpstarted the UK gaming industry.
To build a universe in a 1980s computer, we must first do a deep dive into the hardware
available at the time.
To understand the code, it's necessary to understand the hardware first.
There are far more comprehensive sources available in the description, so I'll keep it as brief
as possible.
By the end of this chapter, you'll understand how a CPU works.
The BBC Micro was similar in architecture to rival machines of the time, using the same
processor as the Apple II, Commodore 64 and the Atari 2600.
That processor was the Moss 6502, a chip ubiquitous with the 1980s, and the driving force between
the home computing revolution.
The 6502 is able to receive and transmit 8 bits of data in a single cycle.
Data in this case may refer to actual data moving to or from the CPU, or it may refer
to commands.
Each command the CPU is capable of carrying out is encodable as an 8-bit string.
We'll see some examples later.
This 8-bit or 1-byte data bus is why we refer to the 6502 as an 8-bit processor.
In addition to the data bus is a 16-bit address bus.
This is used to address individual locations, or addresses, in memory.
Let's simplify the layout and see how this is achieved.
To write a byte of data to memory, the CPU sends the chosen 16-bit address to the memory
on the address bus.
The byte of data to be stored is then sent down the data bus, and the memory ICs are
configured to store that byte at the given location.
Likewise, sending an address down the bus results in the byte stored at that address
being returned to the CPU.
Now let's have a look at the memory in the BBC Micro specifically.
If we imagine zooming in on it, we can imagine every addressable byte being stored in sequence.
Each address holds a single byte.
As addresses are 16 bits in length, the maximum possible address is 2 to the power of 16,
which equals 65,536 bytes in total, or 64 kilobytes.
And indeed, the Micro had 64 kilobytes of memory available.
However, 32 kilobytes of this is read-only.
It contained the operating system itself, and is therefore not writable.
The other 32 kilobytes is the RAM, and is the sum total space available to hold programs
and any stored variables.
However, not all of this is usable as such.
When I began studying the architecture, one of the first questions I asked was,
but where is the video memory?
Which sort of shows how clueless I was.
Every time we send a frame to display on the screen, that frame must be stored somewhere.
I hadn't anticipated that back in the 1980s, this somewhere, or frame buffer, as we call it,
also lived in main memory.
Every location on the screen maps to a location in memory.
Change the value of a byte in the frame buffer, and the corresponding pixel, or set of pixels,
on the screen will also change.
We'll go into more detail later.
But in the case of Elite, 7,936 bytes were reserved as the frame buffer,
used solely for storing the values for physical pixels to be drawn on screen.
This area of memory is read by a collection of chips referred to as the Vidproc, or video processor,
responsible for translating the byte value at each memory location to a physical pixel on screen.
We're still not done.
The first 3,584 bytes of memory are allocated to workspaces,
which are, loosely speaking, areas that may be used to store variables, but not code.
Let's take a closer look.
Memory is actually split into 256 byte pages.
The first is the zero page, and may be used to store variables that require fast access by the CPU.
As zero page addresses can be defined in just 8 bits, the CPU is able to access them more quickly,
and they were used extensively in Elite's source code.
Next is the stack.
This is another temporary storage area for variables.
The stack operates on a first in, first out basis.
Pushing a byte to the stack means that byte will be the first retrieved when subsequently calling from the stack.
Most of the remaining space here is allocated to other workspaces that can be used to store temporary variables.
However, one kilobyte is available as the language workspace.
This isn't usable for code storage, but it could be used to store text expressions.
And this was most certainly used by Bell and Braben.
These expressions are persistent and defined in the source code, so they very much form part of it.
The remaining 21,248 bytes of memory are available to store our program.
So this gives a total of 21,248 bytes of program memory and 1,024 bytes in the language workspace.
By my reckoning, that's a total of 22,272 bytes available.
Reading around some other sources, the actual memory available was actually 21,952.
Perhaps I missed a page somewhere.
Either way, that's less than 22 kilobytes to fit an entire Open World 3D universe.
And Elite fit within that 22 kilobytes.
It's not very much.
To add some context, if I go to PC Partpicker and look at a £1,600 PC,
which is about the cost of a BBC Micro in today's money,
we come up with something with an AMD Ryzen 7 CPU.
Obviously, Elite would fit into the main memory millions of times over.
But modern systems don't just use standard RAM.
CPUs incorporate relatively tiny amounts of extremely high-speed memory on the chip itself.
This is called the cache.
Would 22 kilobytes fit on a modern CPU cache?
The question is barely worth asking.
We have to zoom in to the individual compute cores.
The Ryzen 7 has eight of them.
Each has its own dedicated Level 2 cache.
It's still not even worth asking the question at that point.
We have to go inside each core to the Level 1 cache,
the fastest memory available in the system.
The 64 kilobytes per core.
So Elite would fit inside each core of a modern processor twice.
In fact, it had also sit inside the Level 1 cache of every compute module of the GPU.
And it had fit inside the controller chip for the SSD as well.
It's genuinely difficult to find a place Elite wouldn't fit.
So we get the point.
Braben and Bell were severely constrained when it came to memory.
And that's probably the most discussed limitation they were able to overcome.
But I'd argue they were similarly, if not more limited, when it came to compute.
Just recall the frame rate on those early flight simulators.
Let's take a look at how the 6502 worked.
We see our data and address buses.
I'm going to include the memory here.
Obviously it wasn't inside the chip,
but showing it connected to the buses makes this section much easier to understand.
CPUs contain registers.
These are simply storage cells,
able to hold a single piece of data.
The 6502 has a one 16-bit register, the program counter.
This holds the address of the current byte in memory that's currently being read.
This may be thought of as the current position within the program being executed.
Next to the index registers, there are two of them, referred to X and Y.
They're both 8 bits in size.
In addition to holding a single byte value, they can be incremented or decremented by one throughout the use of appropriate commands.
This makes these registers useful as loop counters.
The accumulator is another 8-bit register.
Any arithmetic operations must be carried out using the value stored in the accumulator.
For this reason, the accumulator is connected directly to the arithmetic logic unit.
This is a collection of logic gates able to perform basic arithmetic operations.
The value from the accumulator is fed in, along with a second value from the data bus,
and the ALU performs the required operation.
In the case of the 6502, the ALU is able to add and subtract 2 8-bit numbers,
along with a few bitwise operations, specifically OR and bit shifts and bit rotations.
That's it. The 6502 is only able to perform very simple arithmetic and logical operations.
And remember, we can only operate on 8 bits. It can only count up to 255.
The result from these operations is stored back in the accumulator.
The status register is an 8-bit register, where each bit signifies a result from the last executed operation.
For example, if an addition is performed and the resulting value is above 255, i.e. not storable in the accumulator,
the 8 least significant bits will still be stored in the accumulator, and the carry flag will be set to high.
In addition to the carry flag, the other bits flag 0 value, interrupt disable, decimal mode, break, overflow, and negative value.
We won't worry too much about these for now, but know that they can be used to trigger branches in a program.
Remember that second page of memory that formed the stack? It's represented here.
The final register is the stack pointer, which stores the address of the highest populated location in the stack.
We won't be directly referring to it again, I've just included it to be complete.
And that's all we have to work with. By today's standards incredibly simple, but still a fully functioning CPU, with less than 4,000 transistors.
There are three main families of commands that the 6502 is able to execute.
Commands, or instructions as they're referred to more correctly, are represented by three-letter operation codes.
Physically, each is just a byte sent down the address bus.
The first family is instructions that move data to or from the registers and memory.
Let's see what happens when we run the store accumulator instruction.
This simply stores the value currently in the accumulator to memory.
First, the desired address to store the value at is sent to memory via the address bus.
Then the 8-bit value in the accumulator is sent to memory via the data bus.
I'll leave it visible for now so we can imagine a byte of memory at a given address.
We could then load this value into the X register using the LDX instruction, or loadX.
The address is sent via the address bus, and the value is copied to the X register.
With similar commands, we can send data between all available registers and memory.
The next family are the arithmetic commands.
AddWithCarrie adds a value from memory to the current accumulator value.
Here the memory address is sent via the address bus, and the byte in memory is sent to the ALU.
The value currently in the accumulator is also sent to the ALU, where the two are added.
The result is stored in the accumulator.
Remember the carry flag.
If the resulting value is greater than 255, the carry flag is set to 1.
But for now, let's assume there's no carry so the flag remains at 0.
And that leads us to the final family of instructions, branches and jumps.
The branch on carry clear causes a jump to a different location of our program if the carry flag is 0.
Here's how it works.
The carry flag is checked, and if it's 0, the address to which we want to jump is passed into the program counter.
Remember addresses are 16 bits, so two separate bytes must be passed down the data bus to achieve this.
This means the next address will be that of the jump location.
This is how we implement if statements.
And finally a jump itself.
The JSR, or jump to subroutine instruction, is a direct instruction to jump somewhere else in the program.
When we execute it, the current program address is pushed to the stack.
This allows us to subsequently return to the current location by pulling from the stack.
The new program location is then passed into the program counter via the data bus.
And that's everything.
We can move 8 bit values, do simple arithmetic on them and jump to different places in our code.
That is it.
Let's have a look at my attempt to turn these simple instructions into something on screen.
The three families of operation codes discussed collectively form the 6502 assembly language.
Almost all programming today is done with higher level languages, where we don't need to worry about physical hardware so much.
Even in the 1980s, most coding was done using the likes of BASIC, C and FORTRAN.
However, high level languages require considerably higher memory usage.
And they must be compiled to assembly, resulting in less efficient use of the CPU and therefore slower running.
Elite, therefore, was programmed in assembly.
I decided the only way I could possibly do Elite justice and make an actually informative video was to learn 6502 assembly.
And, well, let's just say my 10 years of programming experience were almost useless.
I set myself the challenge of creating anything in 3D on the micro, but using assembly only.
I'm happy to say I managed to achieve this, but it took longer than producing any other part of this video.
So, enough tiptoeing around, let's see the final result.
Prepare to be underwhelmed.
So, yeah, that took me 5 days.
It uses lookup tables to plot the positions of the vertices in 3D space.
The tables are called from a subroutine which draws a single line.
The appropriate value from each table is retrieved by using the values in the Y register, which increments every time a line is drawn.
It's tiny because I cheated and used an inbuilt line drawing routine from the operating system.
But that divides the screen into 1200 by 1200 points.
But we can only count to 256 with this 8-bit system.
And I definitely wasn't going to go and get my head around dealing with that, so I just made the whole thing 250 by 250 units in size.
It flickers like mad too, but that's true of Elite as well, so I don't feel too bad about that part.
Okay, now let's go and see how to code in 6502 assembly properly.
Elite was initially released on both tape and disc versions.
The tape version is the 22 kilobytes one, as it had to fit entirely within memory.
Loading from a tape during gameplay is not really possible.
The disc version has a few more features, like additional ships, and you can only do asteroid mining in that version.
As these could be loaded in from the disc while the player was docked.
The code itself for the two versions is essentially the same.
The disc version just contains some more stored variables.
And in case you're wondering, a tape version was absolutely necessary if ACONsoft wanted to actually sell any copies to the home market.
Back in 1984, a disc drive in the UK cost as much as the BBC Micro itself.
Although the memory constraints not as tight when loading from disc, the limited compute capability of the 6502 was still a huge challenge.
Just recall the one frame per second flight simulator I showed earlier.
For every frame in flight, every vertex on screen needs calculating.
Every line between them must be calculated.
An individual pixel is inserted into screen memory.
The 6502 in the BBC Micro operated at 2 MHz, or 2 million cycles per second.
This sounds like a lot at first, but as we go through some examples, we'll get a taste of how many individual operations need to be carried out to draw a single frame.
Bear in mind, every assembly instruction requires two CPU cycles at absolute minimum.
The subroutine for just drawing a single pixel requires 20 operations.
And that's after all the necessary calculations have been performed to decide where to even draw that pixel.
So for a full screen, it's easy to see how cycles are eaten up quickly.
The code for Elite is essentially one large script of 6502 instructions.
Trying to understand any of this is daunting at first, but it becomes much more manageable when we understand that it consists of a main gameplay loop.
Depending on the current state of play, this loop calls upon individual subroutines as and when necessary.
Each subroutine performs a simple task, such as drawing a line or updating the player's kill count.
So the code is very much modular, and understanding individual modules allows us to build up to something bigger.
The full source code for Elite is available on GitHub.
When I set out to make this video, I was going to go through the main flow of the code and broadly explain how the main features are implemented.
However, it turns out someone's already done all the work for me.
Mark Mokson annotated every line of the original code and has a frankly incredible website which breaks down every element of it.
It also includes many deep dive articles on some of the technical details of the code.
This left me with a problem, however.
I wasn't going to just regurgitate Mark's Herculean work here and try and take credit.
So instead, this section of the video will walk through some choice examples and show how the code maps back to the 6502 itself.
And I'll show some of my own visuals to make everything easier to understand.
Remember how just under a quarter of the available memory was dedicated to storing pixel values to draw on the screen?
Let's talk more about that.
Drawing graphics on the BBC Micro is typically done at a resolution of 320 by 256, and eight colors are available.
So every pixel would require three bits of memory to store its color value.
That's because there are eight possible three-bit numbers, one for each color.
So to store a frame at this resolution, we require 320 by 256 by three bits.
That comes to 30 kilobytes just for the frame buffer, essentially leaving no room for our program.
Oh dear.
Okay, so we have two options to reduce the frame buffer.
The first is to reduce the number of bits per pixel.
Let's just represent each pixel with a single bit, one or zero.
That reduces our frame buffer to 10 kilobytes, not bad.
But with only a binary option for each pixel, that means we're limited to just black and white.
The second option is to reduce the number of pixels to plot in the first place.
By reducing our resolution to 160 by 256 and using say four colors only,
we'd also reduce the frame buffer to about 10 kilobytes.
So it looks like we'd have to choose between either high resolution or color.
We can't have both.
Or can we?
Look closer.
The combat viewing elite has high resolution but no color.
The dashboard is in color but at low resolution.
This was elite's first unique innovation.
Before any pixels are plotted on an individual frame, a timer's started.
We know the number of pixels to plot in high resolution.
And we know the rate at which these pixels are plotted to the screen.
It's one megahertz for the BBC Micro.
So a timer is set to trigger after all the high res pixels have been plotted.
The top half of the screen is drawn in the aforementioned high resolution.
The timer then triggers an interrupt, which calls a subroutine, to switch to the lower resolution mode.
This is achieved by switching registers in the video processing chip to convert it to low resolution for drawing the dashboard.
And that's achievable through some assembly commands.
As far as I can tell, this was the first game ever to use this split screen configuration.
And it was definitely the first to do so on a BBC Micro.
The end result is 7,936 bytes reserved for the frame buffer,
leaving just enough room for the actual program.
And a game that looks both sharp, yet colorful.
Something not seen on a home computer before.
Now let's take a look at a more obvious feature, the 3D graphics themselves.
One reason they looked so good was that Elite was the first game playable at home to feature hidden line removal.
Unlike earlier wireframe graphics, which themselves were barely existent in games at the time.
If an edge on an object is obscured, it's not shown.
This was a tricky problem to solve at the time.
It still caused John Carmack a headache nearly 10 years later when optimizing Doom.
In the case of Elite, the solution implemented was quite simple in concept,
but required some clever design to be executed in acceptable speed.
We start by looking at how objects are stored.
The final few pages of memory are used to store the ship's blueprints.
These are a series of lookup tables.
The first table is a number of basic attributes, such as max speed and laser power.
The second table for each ship is the vertices.
This defines the position of each vertex relative to the center of the ship.
I've seen it written before that blueprints contained only half a ship, with the other half generated on the fly.
However, this is not true.
We see the full vertex count for every ship when we look at the source code.
Next is a table of edges.
This is a list of plotable edges for the ship.
Each defined by its starting and ending vertices and adjoining faces.
The edge and vertex tables contain all the necessary data to plot a wireframe ship.
However, in order to perform hidden line removal, the positions of the faces need to somehow be characterized.
So, the final table for each ship is a list of faces.
But how are these faces defined?
Each one is characterized by what's called its normal vector.
Let me explain what this looks like.
Imagine drawing a line from the ship's center to the facing question.
Now, the aim here is to draw this line so that it intersects the face at a 90-degree angle.
Looking at a Tharguide ship as an example, this is easy enough to do for this face.
But how about this one?
We can imagine extending the face until a solution is found.
These vectors are defined by three values, the x, y and z distance from the origin to the point of intersection on this extended face.
Bell and Braben pre-computed these x, y, z distances and saved them in the face lookup table for every object in the game.
Now, let's put the player's ship in our scene.
This face here should be visible to the player.
We know the position of the enemy ship relative to the player, so let's add the vector in for that too.
Finally, the main flight loop calculates the rotation of every object in the scene.
This is defined by three more vectors, one for each axis. Let's add those too.
And with that, we have everything we need to remove the hidden lines, or I should say hidden faces.
Rather than considering lines individually, faces as a whole are checked.
First, we need to know the line of sight to the face.
We can do that by summing the object's position vector and the face normal vector.
Visually, vector addition works like this, so we now have a line of sight vector to our face.
Every object in Elite was designed to be exclusively convex,
so if a face's normal vector is pointing away from us, we know that face must be obscured.
Or more formally, the angle between the normal vector and line of sight vector
must be greater than 90 degrees for a face to be hidden, so we can perform this simple calculation.
This is known as the dot product between the two vectors.
Dot products are used all the time in 3D computation because they're very simple to calculate.
Indeed, here's the subroutine Bell and Braben wrote,
Crucially, a negative dot product denotes two vectors that are less than 90 degrees apart,
and a positive one denotes two that are greater than 90 degrees apart.
So, we calculate this dot product for our faces,
and only plot edges associated with faces where the line of sight to the face normal dot product is less than one.
Now, there is one minor step I missed out.
In reality, face normal vectors are relative to the orientation of the ship to be plotted,
so the player's x, y, z coordinates need to be translated to the ship's local coordinate system.
This is done by modifying our line of sight vector as shown here,
but the end result's the same.
Faces are only plotted when the dot product is negative.
See Mark Moxon's Deep Dive article for more details on this step if you need convincing why this is necessary.
These three numbers and this simple formula define elite's entire universe.
It's sometimes stated that the universe is randomly generated, but it's a little bit more elegant than that.
It is in fact procedurally generated.
That means the same universe is created every time.
Elite wasn't the first game to feature procedural generation, but it was the first to apply it on such a scale.
Let's see how those three numbers define a system.
These numbers are referred to as seeds.
Each is expressed as a 16-bit binary value.
Now, different bits within each form parameters for the system.
Two entire bytes define the coordinates of the system in the galaxy.
These two bits define the system tech level, and these two define the prosperity level.
They're used to bias a pseudo randomly generated number to decide the prices of commodities at the system.
These three define the system's government type.
In a similar manner to the economic variables, the value stored here increases or decreases the likelihood of encountering pirates at the system.
And these three define the distance to the planet.
All other system attributes are similarly defined with the remaining bits.
The three numbers on screen define the first system plotted.
Then, that deceptively simple formula is applied.
We add the three values, append the result to our list, and discard the first value.
And that gives us the three seed values for the next galaxy.
The process is repeated 255 times to give a galaxy of 256 stars.
If the result is greater than 16 bits in length, we just take the carry value and continue on.
And the process itself is repeated a further 7 times to give a total of 8 galaxies.
And that's all there is to it.
The final feature I'd like to go through is the radar.
This has an almost legendary status.
It was the final few lines of code written before Elite was released.
Braben had to convince Aconsoft to add it in last minute.
But it completely changes the nature of the combat sequences.
It's quite funny watching videos of novices playing and not even realising the radar's there.
They hear the sound of being shot at but don't know where it's coming from
and kind of flail around pitching and rolling randomly.
But once they realise the radar's there and how it works, it completely changes how they handle combat.
It's simple to use.
Objects within range of the player are shown as sticks with a little flag at the end.
A stick behind the player represents an object behind them.
And one in front is an object in front of them.
Likewise a stick extending upwards mean the object is above the player
and downwards means it's below them.
So the radar provides a full representation of the 3D space around the player
and can be understood at a glance.
Genius!
I'll go into full depth for this one.
We've made it this far so let's go crazy and get my 6502 model on screen.
The scan subroutine performs this task.
Let's figure out how it draws a single dot representing another ship in the correct position on screen.
Every object within range of the player's ship has a ship type variable.
For the current ship, this variable along with the ship data is moved into the 0 page workspace for fast access.
Therefore saving clock cycles.
We load that object's ID from the workspace and into the accumulator.
Objects such as planets and suns are designed to have their most significant bits set to 1 in the ID.
And this sets the minus flag to 1.
So a break if minus command causes us to return from the subroutine and not plot that object.
For plot of the objects, the hex representation of the plot color, which is green for ships, is loaded into the x register.
The color green is represented by ff in hex.
This color variable is then stored in the workspace.
The ship data in the workspace contains x, y and z coordinate values.
Each is two bytes and represents the ship's position relative to the player.
We load the most significant byte of the x coordinate into the accumulator and perform a logical or on the respective bytes from the y and z coordinates.
One more logical and is performed on the result using the binary value 11000000.
If the result is zero, the two most significant bits of all coordinate values are zero and the ship is in plotting range.
So branch on not zero.
A positive result here would return from the subroutine.
Let's assume the ship is within plotting range.
To convert a ship's world x position to an x coordinate on screen, i.e. on the scanner, we add 123 to the most significant byte of the x position.
We don't need to go through why that is here, but let's just take it at face value.
Assuming x is positive, we simply load the ship's high x byte into the accumulator and add 123.
The resulting value is stored in location x1 in the zero page workspace.
A similar process is carried out for the y coordinate, saving it in location y1 in the zero page workspace.
Finally, an existing subroutine is called to draw a double length dot at the coordinates x1, y1.
I definitely won't go into details of how this works, but in summary, it loads x1 and y1 into the accumulator and x register,
converts the coordinate values into the correct locations in screen memory,
and performs an exclusive OR operation on these locations.
If nothing was plotted there before, the exclusive OR operation populates the pixel at the correct memory location with the color value we previously stored.
Actually, let's take a second to think about that.
When writing pixel values to the frame buffer, Elite's source code always uses an exclusive OR instead of just writing the value directly.
Let's consider writing a single pixel and see what would happen if we just wrote the new value directly.
The bottom row of this truth table is the important one here.
Imagine us building up our frame.
We may first add in the object for the star,
but then adding all the lines for the spacecraft would just draw white lines in front of a white star, rendering the spacecraft invisible.
Here's the truth table for the exclusive OR pixel right.
Now a white on white pixel flips to black.
So spacecraft are visible in front of white objects.
They look like this.
It doesn't even matter what order the objects are written to the frame buffering.
Or if only part of the object occludes the star, this will always work.
At the expense of a single instruction when writing pixel values,
Braben and Bell never needed to worry about objects disappearing in front of stars.
It was all handled automatically.
Even with me skipping over how Y coordinates are calculated,
how screen memory locations are determined,
and how the stick from the object on the scanner is drawn,
that was still a lot to go through just to get a single dot on screen.
But that's how the source code was built up in general,
by taking individual tasks,
breaking them down into simple problems,
and figuring out how to implement the solutions in assembly.
Each solution was translated into a subroutine,
and meticulously optimised to save memory and compute.
No single subroutine is particularly complex or difficult to understand,
but they combine to create an entire universe.
It's difficult to quantify the effect Elite had on the computing sector as a whole.
Every British software developer I've spoke to that went to school in the 1980s
cites Elite as a reason they got into computing.
Being able to code the game on the same machine you could play it on
probably had something to do with that.
Though I was born too late for Elite's release,
we had a copy on our Acorn Archimedes at home.
I liked it.
I was told it was a big deal, but I didn't really understand why, because I was 8.
A couple of years later, I realised the game was nearly 15 years old,
which completely blew me away at the time.
In the years following Elite's success,
Bell gradually distanced himself from the gaming industry.
I've heard he grew to dislike the proliferation of violent video games,
something I can't really relate to,
since I grew up with the likes of Doom, Half-Life and BioShock.
His personal website is a quirky record of what the World Wide Web looked like in the 1990s.
It also contains the source code for Elite,
that did cause a bit of a legal kerfuffle between himself and Braben,
but I understand the two have been back on speaking terms for years now,
so that's nice.
Braben on the other hand,
he used the success of Elite to found Frontier Games,
which remains a major UK developer to this day.
In fact, he only stepped down as CEO in 2022.
In 2014, Frontier released a modern day adaptation of Elite.
Elite Dangerous.
Backed by what was, at the time,
the largest ever crowdfunding campaign in the UK.
And it's amazing.
A one-to-one scale map of the Milky Way,
with 400 billion star systems to explore.
Prior to that, in 2008,
he became one of the co-founders of the Raspberry Pi Foundation,
who went on to completely revolutionise access to cheap compute hardware,
and spawned a new generation of hobbyists.
I'm one of them.
I pre-ordered my first Pi on the day they were announced.
I was on an oil rig at the time,
and though I'd been employed for less than a year,
I was already looking for a way out of that industry.
I learned how to navigate a Linux system,
run distributed compute,
and even how to containerise applications thanks to the Raspberry Pi.
Elite was ported to every major platform it could viably run on.
Of course, making it accessible to cheaper systems,
such as the ZX Spectrum and Acorn Electron,
played a huge part in the game's record sales.
Perhaps most astonishing is the NES port.
That's right, you could play Elite on the NES,
a machine designed entirely not for 3D vector graphics.
In fact, I've done just that.
Back when I was at university,
I owned an NES for retro gaming,
and I had a copy of Elite.
To be honest, it was the only game I used to play on the thing.
An upgraded version was also released for MS-DOS,
known as Elite Plus,
coded entirely by another legendary UK gaming figure,
Chris Sawyer.
If you don't know that name,
just keep an eye out on the outro sequence.
Elite marked the end of the dominance of the arcade shooter.
Less than one year after its release,
the NES was debuted in the US and Europe,
though most games for this platform
didn't match Elite's level of complexity.
Even relatively accessible titles,
such as Super Mario Brothers and Zelda,
provided a much richer experience
than had been previously available.
In retrospect, it really feels like
Bell and Braben opened the floodgates
by demonstrating what was possible with 8-bit hardware.
Though they had pushed that hardware to its limits,
and we'd have to wait until the 1990s
and the rise of 32-bit systems
to see an explosion in 3D rendering technology.
By then, most major games were no longer produced
by solitary bedroom coders,
but by large studios,
with large design and advertising budgets to match.
By the end of the 1990s,
another hardware wall was hit.
Back in 1984,
Elite required real-time calculation
and plotting of several to dozens of polygons
on screen at a given time.
But by now, the polygon count
that was demanded by designers
was outpacing improvements in CPU speed.
A new approach was needed.
Wouldn't it be nice to calculate the positions
of all these polygons in parallel?
Thus, the GPU was born.
Why use one very fast processor
when you can use many slow ones at once?
About 10 years later,
something very unusual happened.
Typically, new technologies start out relatively expensive
and are only used experimentally,
and then by commercial or government organizations,
before becoming cheap enough to sell to consumers.
But the opposite happened with GPUs.
A new field was rapidly growing in the late 2000s,
data science.
It was realised that the computations
necessary to train neural networks
are similar in principle to those used
to calculate polygons for 3D rendering.
Data scientists realised that in some cases,
cheap off-the-shelf gaming GPUs
outperformed supercomputers.
I first used a GPU to train up an algorithm in 2015,
and now it's something I do on a daily basis.
The algorithm that recommended this video to you
was trained in a cluster of GPUs.
The implications of large-scale deployment
of advanced machine learning algorithms
are not yet fully understood,
and we would have got there without Elite,
but I think it's fair to say we'd have got there slower.
But back to gaming.
UK gaming specifically.
Elite was our breakout game, if you will.
In the four decades that have followed,
the UK gaming industry has birthed some of the most influential
and best-selling games of all time,
and they continue to do so.
And not just huge developers, either.
With the rise of accessible gaming engines,
such as Unity, Unreal, and now Godot,
it's again possible for small teams,
and even individuals, to design, write,
and publish great games.
Bell and Braben set out to make a great game,
but they also fostered an entire industry.
Thank you.
