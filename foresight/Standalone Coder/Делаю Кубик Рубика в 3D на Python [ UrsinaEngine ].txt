Привет, мир!
В 1974 году, венгерский архитектор Рубика изобретает игрушку-головоломку, которая становится всемирно известной под названием «Кубик Рубика».
Эта головоломка стала наиболее продаваемой игрушкой на планете.
И с момента изобретения разошлась по миру почти в полмиллиарда единиц.
И сегодня мы рассмотрим основные моменты по созданию этой головоломки,
а также разберем как создать Кубик Рубика при помощи языка Python,
и для этого главным инструментом станет функционал и возможности.
Очень простого 3D-движка – Урсина.
Итак, приступим.
И чтобы установить движок Урсина, то в терминале запустим команду, представленную на экране.
После установки импортируем этот движок и напишем класс основного приложения,
точно так же как делали в сюжете про создание змейки на движке Урсина.
И пока что сделаем два метода для загрузки игры и для обработки событий нажатия клавиш,
ну и конечно же создадим экземпляр приложения, запуск которого активируем через мететран.
А для лучшего восприятия информации, создадим объекты окружения,
сделаем плоскость которая будет расположена на 5 единиц ниже начала мировой системы координат,
а на эту плоскость наложим текстуру которая идет в комплекте движка.
Также в начале координат поместим большого размера сферу,
на которую наложим подобранную текстуру неба,
то есть мы будем находиться внутри сферы наблюдая небесный купол.
И для лучшей наглядности, поместим трехмерную модель левосторонней системы координат на то место,
где начинается мировая система счета для этого движка.
Ну и для полной свободы действий, задействуем камеру которая управляется при помощи мышки.
И если посмотреть на то что у нас вышло, то мы видим что получился достаточно оживленный каркас приложения,
в котором при приятном окружении можем наблюдать начало мировой системы координат,
что в свою очередь поможет более лучше понять работу с трехмерным пространством.
Но чтобы двигаться дальше, то необходимо создать модель одного маленького кубика,
так сказать структурной единицы.
И проще всего будет работать с кубом, размеры сторон которого равны одному,
а его центр должен находиться в начале локальной системы координат.
Также нам важна карта текстура такого кубика,
которую мы самостоятельно разукрасим при помощи любого растрового редактора.
И при этом будем придерживаться классической раскраски грани для нашего кубика.
И тогда, отдельными атрибутами сделаем пути для новой модели куба его текстуры,
и чтобы проверить его отображение, то создадим один экземпляр объекта
используя созданную модель текстуру.
И как можно видеть, у нас появилась рукотворная структурная единица,
при помощи которой сделаем целый кубик рубика.
Но в начале координат мы поместим совершенно другой объект,
это будет так называемый родитель.
Он будет самым главным кубиком при помощи которого будет работать весь механизм кубика рубика.
Так вот, и нашему объекту укажем, что он будет потомком родительского кубика,
и расположим его слева от родителя.
А для более очевидной работы механизма наследования,
сделаем вращение родителя на 90 градусов вокруг оси Х,
и вращаться родитель будет по нажатию левой клавиши мыши.
Теперь посмотрим как это работает.
И перед нами в центре мировой системы отчета находится родитель,
у него шахматная текстура, а сбоку от него, его потомок.
И при нажатии левой клавиши мыши происходит вращение родителя,
а если посмотреть на движение потомка, он полностью повторяет те же движения,
то есть так же вращается вокруг оси Х,
и думает тут становится очевиден весь принцип работы механизма кубика рубика,
и этим механизмом будет управлять только один кубик родитель.
Но не все так просто как кажется, нам же надо крутить только определенную сторону кубика рубика,
и поэтому в зависимости от стороны вращения необходимо перекреплять потомков.
И давайте на этом же примере посмотрим что происходит во время смена родителя.
На клавишу W будем обкреплять родителя, то есть родителем будет мировая сцена,
а на клавишу S, заново сделаем родителем центральный куб.
И если посмотреть на эту ситуацию, то вначале потомок вращается как и положено,
но когда производим смену родителя, то потомок возвращается в то место где был изначально.
А при назначении родителем снова центральный куб, то он перемещается в то место,
если бы он вращался все это время с прежним родителем.
Это неприятная вещь происходит потому, что координаты куба потомка относительно родителя не меняются,
а остаются всегда прежними, и поэтому при смене родителей он возвращается обратно.
И чтобы решить эту головоломку, то необходимо перед сменой родителя
забрать мировые координаты потомка в отдельные переменные, а после смены, назначить эти координаты позиции потомка.
Но и в то же время нужно обнулить значение вращения центрального куба,
чтобы потомок начинал вращаться с ним с того же положения.
И теперь если посмотрим на процесс смена родителей, то видим что потомок остается в том же положении куда и пришел,
а также впоследствии новой смена родителя, он продолжает свое вращение как и предполагалось для него.
Итак, теперь можно продолжать создание кубика-рубика, и создадим для начала его левую и нижнюю стороны.
Для этого уберем лишние элементы управления и создадим метод, в котором определим позиции выбранных сторон.
Позиции кубиков в каждой стороне очень легко создать при помощи циклов,
и наряду с этим координаты кубиков будут находиться в такой структуре данных как множество.
Вызвав этот метод, то вычислиться позиции кубиков для каждой из сторон,
и теперь можно пройтись по этим координатам и создать нужные нам объекты.
Ну и посмотрим, и сейчас можем наблюдать всего треть кубика,
но пока что оставим его в таком виде для лучшего понимания происходящего.
А для дальнейшей реализации понадобится словарь, ключами которого будут названия сторон куба,
а значениями станут очевидные оси вращения для каждой стороны.
Также нужен будет словарь для определения всех позиций кубиков по каждой стороне,
и в добавок введем переменные для обозначения времени анимации поворота сторон.
Далее напишем отдельный метод для смена родителя,
от центрального кубика к мировой сцене.
Здесь пройдемся по всем потомкам, и у кого родитель является центральным кубиком,
запишем их мировые координаты,
сменим родители на мировую сцену и присвоим позиции потомка его мировые координаты,
а в конце приравняем к нулю значения вращения центрального кубика.
А при помощи следующего метода будем осуществлять поворот необходимой стороны кубика-рубика,
в этом методе по передаваемому названию стороны,
определим координаты всех кубиков для данной стороны,
также получим значение оси вокруг которой надо сделать поворот.
Здесь же и будем вызывать метод по сменю предка на мировую сцену.
И проходясь по всем кубикам, нам нужны будут кубики для текущей стороны,
где назначим родителям центральный кубик и при помощи удобной функции,
явал, вызовем код внутри себя по запуску анимации поворота вокруг нужной оси.
И добавим управление при котором при нажатии клавиши А,
будем поворачивать левую сторону, а при нажатии на С, повернем нижнюю.
Если мы посмотрим как в текущей ситуации работает механизм,
то очевидно что никаких проблем с правильной реализацией его работы нет.
И в данный момент это достаточно любопытный вид внутренности кубика-рубика,
при котором можем наблюдать, как при каждом повороте центральный кубик
моментально принимает начальное положение без вращения,
а также видно как составляющие кубики перемещаются по этим двум сторонам.
И теперь можно собрать полный кубик-рубика,
для этого добавим недостающие координаты кубиков для оставших со сторон.
При этом объединение множеств таких координат,
позволит избавиться от дублирующих позиций для маленьких кубиков.
А далее добавим, пока что экспериментальное управление,
для вращения всех сторон кубика при помощи шести клавиш.
Также больше не понадобится модель системы координат,
а родителям будет пустый объект без модели,
так как он будет находиться в центре и не будет виден.
К тому же добавим недостающие стороны в словарь
для определения координат кубиков для нужной стороны.
И в результате получаем кубик-рубика,
в котором можно вращать любую сторону,
и выглядит все вполне достойно,
но есть один существенный недостаток.
Если мы будем нажимать на клавишу быстрее,
чем происходит анимация вращения стороны,
то кубик просто-напросто весь сломается.
Чтобы исправить такое недоразумение,
то создадим триггер для разрешения очередного поворота стороны.
Напишем метод при помощи которого будем менять логическое значение триггера.
И как только начинает вращаться какая-нибудь сторона,
то присваиваем ему ложное значение,
и это значение станет истинным только в том случае,
когда закончится вся анимация поворота.
Ну и конечно же, состояние этого триггера
будем проверять при нажатии очередной клавиши.
И вот при таком раскладе,
можно нажимать на клавиша с любой частоту
и при этом с кубиком ничего странного не происходит.
И казалось бы на таком шаге можно завершать этот сюжет,
но то управление которое реализовано в данный момент
мне крайне не нравится,
потому что при поворотах камеры
полностью теряешься в расположении сторон куба.
Поэтому сделаем более интуитивное управление
и управлять поворотами будем только при помощи мышки.
Сделаем два режима.
Режим обзор и режим взаимодействия,
а переключение между ними будет нажать и на колесика мыши.
Для этого создаем логическую перемену,
а также объект вывода текста на экран о том,
какой сейчас режим,
и понадобится отдельный метод,
в котором меняем логическое состояние переменной режима игры,
и на основании этого значения выводим сообщение.
Исследовательно в управлении,
вызываем этот метод при нажатии средней клавиши мыши.
И как можете видеть внизу экрана,
отображаемый текст изменяется
при каждом нажатии на колесика мыши,
а теперь можно и переходить к дальнейшей разработке управления.
Итак, сделаем метод при помощи которого создадим
так называемые сенсоры,
это будут трехмерные модели,
покрывающие каждую сторону кубика-рубика.
Отличительной особенностью станет то,
что у них будет активирован коллайдер,
то есть движок будет их брать в расчет
для вычисления столкновений по их форме,
а также у них будет задан параметры имени.
В нашем случае он будет обозначать каждую сторону кубика-рубика,
и для примера, посмотрим как будет выглядеть сенсор для левой стороны.
Но такие сенсоры не будем отображать,
так как у объектов есть такой параметр как видимость,
то есть движок производит все и расчеты с объектом,
но в то же время объект не выводится на экран.
И чтобы создать адекватное управление,
то такие объекты должны располагаться таким образом,
чтобы они не накладывались друг на друга,
то есть надо сделать небольшой зазор в их расположении.
И важным шагом остается переделать управление.
Мы проверим что происходит нажатие левой или правой клавиш мыши,
при этом переменные режима игры.
Тригеры действий должны быть истинными.
Далее мы получим название у всех объектов,
которых задан параметр обработки коллизий,
и те названия которые совпадают с названиями сторон куба.
Будем передавать метод вращения сторон.
Для текущего случая боковые стороны будут поворачиваться по нажатию левой кнопки,
а верхняя или нижняя сторона, по нажатию правой кнопки мыши.
И теперь можно сказать что все готово.
Получили кубик рубика который можно управлять при помощи одной мышки,
переключаясь между режимами.
Получили возможность вращаться стороны куба из нужного положения обзора,
а на самом деле управление, это выбор вкуса.
Так что реализовать свое видение управления не составит особого труда.
Но это еще не все.
Мне захотелось добавить немного интерактива,
и давайте сделаем так, чтобы изначально кубик рубика находился в другом исходном состоянии.
А для выполнения такой задачи,
нам понадобится второй метод для вращения сторон,
но только в нем не будет анимации, и в котором для исполнения команды,
воспользуемся не менее удобной функцией, экзекют,
и будет метод случайного исходного состояния,
в котором надо задать количество и случайных вращений нашему кубу,
а стороны вращений будем случайно выбирать,
из имеющихся ключей словаря для осей вращения.
И таким образом, получаем кубик рубика,
в котором стороны повернуты на указанное количество раз.
Так что кто увлекает с этой головоломкой,
то можете усложнять себе задачу увеличивая такой параметр.
И в целом хочется отметить,
что примененные здесь принцип родителя и потомка,
можно использовать в любом движке для работы с трехмерной графикой.
В общем пишите свои комментарии,
и бейте в колокол, чтобы не пропустить следующий выпуск.
А ваш палец вверх, как всегда,
будет мотиваций на создание нового сюжета.
И всем успехов, всем пока!
