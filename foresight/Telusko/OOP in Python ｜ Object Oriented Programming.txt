Now, till this point, we have seen the language fundamentals of Python, right?
We have seen variables, how to pass a variable to a function, we have seen function, right?
How to define function, how to call a function, and then we moved towards module and now
we know how to create different files.
Now, once we have talked about the language fundamentals, let's move towards the concepts.
Now, one of the concepts which is very important is, oops, which is object oriented programming.
Now, one of the unique selling point of Python, you know, why Python is so famous because of this thing.
Python supports all different programming paradigm, you know, it supports functional programming,
it supports object oriented programming, and it also works with procedure oriented programming.
Now, we have talked about procedure, right?
What is procedure now is, whenever you work with Python, we define functions, right?
We call a function from a function.
So if you want to create a software, you will break down your project into small, small part,
and those modules, small modules will be functions.
Now, Python is also functional programming.
So functional programming basically means if you can achieve a certain task, implementing functions
as a mathematical functions where you will not manipulate a data, which is instead of changing data,
you will still accomplish a task.
One of the ways you can pass a function to a function, you know, we have seen this, again,
we have a very deep concept of functional programming, we'll talk about that later.
But time being, procedures and functions, which is something we have already done, for example, lambdas.
Now, we are going for a concept of ops.
Now, which is very famous in the industry, you know, so if you are working on big softwares,
enterprise projects, you need to think everything in a format of objects.
Now, you might be thinking why objects, we were happy with functions, right?
Now, see, even from start itself, I was I'm talking about objects, right?
Maybe in some programming, I said, OK, this is an object in teachers, an object.
But then we were skipping that part.
What is object and why it's so important?
See, ultimately, if we talk about programming world, what we do is we try to solve a real world issue
with the help of a virtual world solution, right?
So example, programming softwares, everything is virtual world.
Now, in real world, we all use objects, right?
Example, if I want to record this video, I need a camera, right?
If I want to call someone, I need a phone.
If you want to type a code, you need a laptop, right?
So for everything, you need object.
So in real world, everything is object, in fact, persons, right?
Example, if I have a company, if I want some work to be done, of course, I need employees, right?
And for me, every employee is an object, right?
So an employee object is using a laptop object.
So some employee object needs a AC object, right?
So that's how things work.
Everything is an object.
Even humans, we treat them as object.
Now, what object will have?
Object will have two things.
Every object will have certain attributes and every object will have certain behavior.
Now, when I say attribute, you can imagine them as data, or you can say properties.
Example, my height is one attribute, my age is one attribute, my name is one attribute.
The company I work for is one attribute, right?
Everything is those things that attribute.
And then comes my behavior.
I'm talking, I'm walking, I'm dancing.
All these are behavior, right?
So our actions defines our behavior.
And then we have attributes, which we know.
In other terms, you can say, as an object, I know something.
As an object, I do something, right?
So I do something based on something which I know, right?
So this is object.
Object will have something where you can store data and object will have some behavior.
Now, this data, which we normally use, those are variables, right?
We have same variables.
So if you want to store something, an object, we need to define variables.
If you want to define the behavior, we need to use methods.
Oh, that's something new now.
What is method?
We have done with functions, right?
So functions in object-oriented programming, they're called as methods.
Right?
It's just so simple.
We have done all those stuff.
The only change we have now is we need to think in an object term.
See, object-oriented programming is not just about different syntax.
It's also about the way you think.
So now, if you want to achieve anything in programming, you need to think about objects.
So the moment you say you have a complex problem, think about the object,
think about multiple objects, and how can you connect them, right?
Because in OOPS, we have so many concepts.
One of the concepts is object, which we are going to see now.
We have a concept of classes.
We have a concept of encapsulation, abstraction, polymorphism.
I know weird words, right?
But don't worry, we will be covering everything in detail in the subsequent tutorials.
So there's one thing which is important to discuss here.
About classes, because we have an object and we have a concept of class.
It doesn't matter which language you work on, maybe Java, C++, or C sharp,
whichever whatever language which uses OOPS concept, you know,
we always use this thing, which is object and class together.
But why?
Why they are so important?
Of course, objects are important because whatever you want to do can be done
with the help of object.
But why class is important?
Now, think about this.
When you see an object in real world, for example, this camera, a fan, or a clock,
right, all these things are manufactured, right?
So in some factory, they have been manufactured.
Or maybe you can talk about a phone.
Now, look at this phone.
This is Motorola G3.
OK, now it's not the only phone available here, right?
So a lot of people, they have this phone.
So that means we don't have one object of Moto G3.
We have thousands or millions of objects.
I'm using any number here.
So imagine we have five million of this type of phones, which is Moto G3.
Now, of course, someone must have designed it, right?
And all these phones have been manufactured somewhere.
Maybe maybe you can say all these phones are made in China.
OK, so we have a factory in China who is producing all this phone.
But then Motorola says it is their phone, right?
Of course, we don't say this is a China phone.
We say this is a Motorola phone.
Or we don't say, let's say the manufacturing is in India.
We don't say it's an Indian phone.
We say it's a Motorola phone.
Why?
Because manufacturing is not important.
You can manufacture stuff anywhere.
What is important is where it has been designed.
OK, so this is designed by Motorola.
But even if you talk about this phone, this has been designed once.
And then they have manufactured multiple times.
And that design in programming or in, oops, we say class.
So in a class, you will write a design of the object.
Imagine there's some factory in your machine who will create these objects.
OK, so you have to provide a design so that you will get the object.
So that means class is a design and objects.
They are real stuff, right?
They are real entities, you can say.
Or you can use another term called as instance.
So you can imagine this is an instance of a class.
That's awesome, right?
So point to remember class is a design or you can call them as blueprint.
So if you have a class, you can manufacture thousands of billions of these devices.
So that's about class and object.
In the last video, we have talked about the theory of objects and a class, right?
So of course, before creating an object, you need to create a class, right?
Because class is a design for the object.
And if you don't have a design, how can you build something?
In fact, even before building a tower, you need to create a blueprint of it, right?
And that's the same case here.
So if you want an object, you need to create a class.
So what I'm talking about is, you know, let's say I want to work with computers.
So I'm a person.
I want to work with a computer.
So of course, I want an object of a computer, right?
So let's say I'm a programmer and of course I want to work with a computer.
So I will say comp one.
So this is my computer.
But see, the thing is, till this point, we have worked with integers.
We have worked with float string.
Now, all those are inbuilt types, right?
We don't have any type as computer.
So of course, we need to create our own type.
So we have to get our own class for it.
So if you want to use a computer, you need to define a class here.
So how do we define a class?
The way we define a function is by saying def and function name.
The way we define a class is using a class keyword.
So we have to say class and this class will, of course, have a name.
In this case, I will use a name as computer.
OK, now this is how you define a class.
You have to specify a colon.
Now, after colon, this is your suite, right?
So this is where you will mention your stuff.
Now, what stuff we can put in a class?
Two things. The first thing is the attributes.
The second one is the behavior.
Oh, now, when you say attribute, it is your variables.
OK, the way you create variables.
And the next thing we'll be having here is behavior, which is methods.
What is methods functions?
You know, the functions which we are using from a long time,
but here we call them as methods.
So next time when you are calling a function,
but that function is a part of a class instead of calling them as functions,
we have to say methods, right?
OK, now let's define some methods here.
Now, what I'm talking about, let me get a method here.
I will say def.
I will say config because every machine has a configuration, right?
So I will say config.
We got that self keyword that that's weird.
What is self because I'm not typing it.
OK, so I mean, the moment I say bracket, it says self.
We'll talk about that self later.
But time being, let's keep it there.
You can imagine we don't have any self there.
OK, for time being, imagine we don't have anything like self.
OK, and here we'll say we got a complete class
and then we got a config method or you can say function,
but try to move from that function term to method term.
Right, so we got a method here, which is config.
And here I'm printing the config of this machine.
And I want to say, hey, this is i5 machine with 16 GB RAM,
and it has one data point hudder.
Now, this is very common config now, which we find nowadays, right?
And that's what I'm doing here.
So we got a class computer.
We got a method in that example here.
I'm saying comp one is the object of computer.
But we cannot simply do that, right?
We cannot simply say comp one because no one will understand
what this comp one is.
Example, if I say there's a variable a, what is a type of this variable?
Right now, since in Python, we don't have to
statically mention the type of it.
So what we can do is when you say a equal to 5,
now the type of a becomes integer, right?
If I say a is 5.5, the type of a becomes float.
If I assign a value of string type, if I say 8,
even if that 8 is number, we are putting that in single code, right?
That becomes a string.
What about comp one?
Comp one here, don't have a type.
We have to mention, hey, this comp one is an object of computer.
In that case, you will say equal to computer.
And you have to give this round brackets.
Now, if you are coming from another, you know,
from different programming background like Java, C sharp,
we have a concept of constructor, right?
So these are constructed there.
So this will give you the object of computer.
Now, how do I know that?
If you remember in one of the video, we have talked about a type function, right?
So you can use type function here.
So I will say print.
I will define type, print the type of con one.
Let's see what happens, what it gives you.
So if I run this code, it says, hey, this is a class.
Okay, now we have a different keyword class.
And this belongs to a computer.
That's important.
Okay.
So it gives you the module name.
The module name is main because we are running this code from here.
And then we have a class for this computer.
Now, if you remember, when we work with string as well,
string gives the same thing.
So if I print the type of a, it also says the same thing.
Can you see that?
It says class str, right?
So we are using this concept from a long time,
but this is where we are defining it now.
So string str is also a class, the same way computers are class.
The difference is str is an in-built class.
Computer is our class.
Okay.
That's how you define it.
So you say class, computer, and then we have def config.
In fact, there's one more thing.
If you remember, when we worked with integers,
we have also said that integers are also object.
Let's try it here.
I will say x equal to nine.
And let me print the type of x.
Can you see that?
When I print the type of x, it says class int.
So even this integer, this x, is an object of integer now, right?
So everything is object in Python, right?
So there are some in-built objects,
and there are some objects which we create.
And the way you create your own class is by saying class,
computer, whatever class name.
Make sure that you don't use in-built class name,
because it will give you error, right?
Or maybe you might face some bugs.
So we have, so in a class, we are defining a function config,
and then, oh, not function.
Method front config, and then we are printing just a statement.
Now, question arise, how will you call it?
So let me remove this, all this extra stuff which we are doing.
So we got a class, we got the object.
I want to call that config.
Now, what do you think?
How will you do it?
So normally, when you have a function,
you mentioned the function name, right?
Here in this case, it is config.
But you are getting an error.
Why error?
So if I go back here, it says unresolved reference,
or that's weird.
Why it is giving you unresolved?
Because of course, normally, till this point,
we were mentioning the function as it is, right, open.
But now, we have written that function or a method inside a class.
So in order to access that, we have to mention the class name.
And the class name here is computer.
So we have to say computer.config, important.
So steps, remember the steps.
You have to mention the computer class, which is class name,
and then you have to say config.
So let me repeat, if you want to use a method,
we have to mention a class name first, which is,
I mean, it belongs to computer, and then you have to mention config.
And if I run this code, oh, we got an error.
But why?
See, think about this.
One class can have multiple objects, right?
One object, two object, five objects,
maybe billions of objects, right?
In this case, we are using only one object, which is comp1.
The thing is, this config function or a method
will change its behavior based on the object, right?
Because different objects have a different behavior,
because depending upon what they know,
they have a different behavior.
See, in this case, I'm not depending on any data, right?
But maybe there's a chance that this config
will depend upon some data, and every object
will have its own data, right?
Again, we'll talk about that later.
But every object is different, right?
If I'm calling config, for which object I'm doing that?
So if I say, hey, walk, but whom am I supposed to say walk?
So I have to mention, hey, Ravi, walk.
Hey, Mukesh, walk.
Hey, Kiran, walk.
So I have to mention the names as well, right?
In the same way, when I say computer config,
you have to also mention for which object you're talking about.
And I'm talking about comp1.
So I'm saying, hey, I want the config for comp1.
Now, luckily, we have only one object here,
so there's no confusion.
But let's say if you have thousands of objects,
you have to mention the object name as well.
So we are doing comp1 here.
So if I run this code now,
oh, it works.
You can see that we got the output.
So we are calling config, and we are passing comp1.
And this comp1 is a parameter, right?
It's an argument.
So when you call config, you're passing this comp1
as the argument, and it is going in self.
So what is this self?
Self is the object which you're passing.
Again, this thing will get more clear
once you see further videos, right?
So this is a complex concept
if you are learning UPS for the first time.
But step by step, everything will go inside your brain, okay?
So this is the first layer.
Again, in the next video,
we'll talk about some more layers to it.
We'll add more layers,
and then I will make sure that you'll get everything about it.
Okay, let's create some more objects, okay?
So I will say comp2 is equal to computer, right?
So we got comp1, we got comp2.
So in total, we have two objects,
which is comp1 and comp2.
But we have only one class, which is computer.
If I want to call config for comp2,
what you will do?
You will say computer.config,
and this time you're saying,
hey, I want to call config for comp2.
So in the first instance, I'm saying,
Mukesh, walk, right?
Or I will say, hey, human, walk.
In background, I'm passing Mukesh.
I will say, hey, human, walk.
In background, I'm passing Ravi, right?
In the same way here, I'm saying,
hey, computer, show me a configuration,
and I'm talking about comp1.
Hey, computer, I want your configuration for comp2.
So if I run this code, you can see
we are getting same data,
because at this point, we are not changing data
for different objects.
We can do that later.
So this is one way, right?
If you want to call config, we have another way.
If you think about this, this looks good, right?
This looks clean, because we are saying,
hey, config method belongs to computer,
and then we have to pass the object name, which is comp1.
But there is one more way.
What you can do is you can mention comp1.config.
Now, in this case, you are using the object itself
to call the function.
So you're saying comp1.config.
But the question is, we are not passing it, right?
For example, let's do it for comp2 as well.
I will say comp2.config,
and you can see this time,
I'm not passing anything inside config, and still it works.
So you can see the output, it works.
We got four times the same data,
because the first two is because of these lines,
and the second, next two is because of this line, right?
But why is it working?
It's because this is another behavior of it.
So when you say comp1.config, you are calling config.
See, we are specifying which class it is, right?
So comp1 belongs to computer.
So now we know config belongs to computer.
The moment you say comp1.config,
when you're calling it behind the scene,
this config will take comp1 as a parameter.
So behind the scene, config will take that comp1 as an argument,
and it will pass that in self, okay?
So in most of the code, you will see this type of syntax,
not this one.
But I have done this just to explain you
how this syntax linked like, okay?
So how this exactly works,
but normally we use this syntax.
The second one.
And that's why whatever we have done till now,
example, if I work with a variable of n size,
if I say a equal to five, and if I say a dot,
so whatever function we use here,
example, I want to know the bit length.
Now in this thing, you can see if I say control space,
you know, you can actually see the documentation
by clicking on this control and click on the function name.
So press control and click on the function name.
You can see it takes to the function,
it says bit length self.
So as a definition, it is accepting self,
but when you're passing it,
when you're calling bit length, we're not passing it.
So this a is an object, right?
It goes as a parameter.
So self is the object which you're passing.
We'll discuss more about that once we start with variables
and then attributes, all the stuff.
But time being, this is how you create a class
and that's how you create an object.
Now in the last video,
we have talked about oops concept, right?
We have seen what is object and a class.
Let's explore it more.
Now if you remember, when we talked about objects,
object will be having two stuff, right?
One is it will be having some attributes
and it will also have a behavior.
Now when you say attributes, those are variables, right?
We can create variables.
And behavior is your methods
and then methods are almost same as functions,
but in oops, we call them as methods, right?
Now here, we have to work with methods, right?
We have not worked with variables yet.
So what I will do is just to demonstrate that,
let me just remove this thing here
because we know that we can call config
using the object itself
or we can call it with the help of class
by passing the object.
Now syntactically, we normally go for the second one
which is calling the method from the object.
It makes much more sense, right?
So we'll remove that part.
And so once we got the object,
let's remove this A as well just to clean that stuff here.
Now what I will do is I want to have certain variables.
Now when I say variables, what I want to do is,
I want to have two variables,
one which defines the type of CPU I'm working with
and the amount of RAM I have.
Example, if you talk about any computer,
these two are very important, right?
The CPU which you are using and a RAM,
maybe 8GB RAM or 16GB RAM.
And in terms of CPU, we have let's say i3, i5, i7
or maybe some AMD series.
Okay, we have different parameters as well,
but just to keep it simple,
let's only focus on two things,
CPU and RAM capacity.
Now when you say we have two variables,
where do you find that?
So we can use a special method
which is available in a class.
Now when I say special, you know, right?
So the moment you say special,
we have talked about special variable
which is underscore underscore name
in the same way we have special method
which is init.
And when I say special,
it will be having underscores as well.
So let's define that.
So we'll say def underscore underscore init.
You can see that we are getting suggestions as well.
And the moment I say enter,
you can see we have the function name or the method name
as init and we are passing self.
Now see, self is not something
which I'm typing that is coming automatically.
So it's compulsory to have those argument, okay,
which is self.
And in here, we can do something.
Normally we use init to initialize the variables, okay?
And that's what the name itself init initialize, right?
Now if you are coming from C, C++ or Java background,
we use constructor, right?
So you can imagine this is our constructor,
but then it is init method.
The advantage here is normally,
see, if you want to work with config,
you are supposed to call config, okay?
So it's compulsory for you to call config.
Otherwise it will not get executed.
The idea behind init is,
it will be getting called automatically.
Example, if I go back here and let's say,
I want to print something and I will print in init.
So you can see I have defined a function called init
and not calling it, okay?
So anywhere in the code, I'm not calling init.
I'm calling config because I want to execute it.
The moment I run this code,
you can see it prints in init
and that way it prints two times.
Now why two times?
Because for every object, it will get called once.
So you can see in total, I'm getting two objects.
One is com one, one second is com two.
So we got two objects and it will call init two times.
So this is the object creation.
So when you say computer bracket, it will instantiate.
It will call init for you.
Now I want to pass some arguments, okay?
I want to pass CPU and RAM.
So in the constructor itself, you can pass that.
So in the computer bracket itself, you can pass it.
So I can say I have a CPU here, which is let's say i5
and the amount of RAM we have is 16 GB.
The second computer we have, let's say,
reason three and the amount of RAM we have, let's say 8 GB.
So we have two computers with two different CPUs, right?
And now how to accept these values?
So of course you have to pass these values here, right?
So you have to say self comma, you have to pass two values.
You have to accept these two values.
So you have to say CPU comma RAM, okay?
That's how you accept it.
Now I know your question.
Your question is we are passing two parameters, right?
Or we are passing two arguments.
One is CPU and second is RAM.
And we are accepting the arguments here.
So the thing is, you are actually passing three arguments here.
Remember, we are also passing comp one.
The moment you say computer in the back end,
you are passing that comp one by default.
The same thing happened with config, right?
When we call config, we are not passing self or the object itself.
But it gets passed automatically.
The same way, when you say computer by passing two parameters,
you're actually passing three.
The first one is the object itself.
The second one, the value, the first value here and then RAM.
Okay, that makes sense.
But will it work?
So the thing is, every object need to have a value
because this is just an argument now.
So CPU and RAM is just an argument.
If you want it to be a part of your object,
you need to say, because see,
we have to assign this value to an object, right?
And the object here is self, right?
So you have to say self dot.
That's right, right?
So this comp one, this is our object, right?
So we have to say self dot CPU is equal to CPU.
Again, there's no compulsion that you should be having same name.
You can have a different name.
That's fine.
So you will say self dot RAM is equal to RAM.
So whatever value you're passing here,
which is I5 goes to the CPU as an argument.
It will be assigned to the object, which is self.
So the self, you can imagine now.
So in the background, you can see we have two objects here.
So in total, we've got two objects.
Each object will have its own variables.
Okay, it will have its own CPU.
It will have its own RAM.
And then whatever value you pass in the arguments,
it will be assigned to those objects.
Okay, so we have two objects, two different values.
And now in the config, instead of printing this stuff,
I will say CPU comma RAM.
That's what we do.
Oh, we got an error.
What's wrong here?
So the thing is, this CPU is not a local variable, right?
This CPU belongs to an object.
And how do we refer to object?
It's very simple.
You have to use self, right?
That's why you are passing it.
So you have to say self dot CPU.
And here as well, you have to say self dot RAM.
And that's the idea behind passing this self, right?
We are passing self so that you can use it to fetch the values.
So you can imagine your methods and your data works together.
And we have a name for this concept.
Again, we'll talk about that name later.
It's a surprise.
But we are binding our data with every method.
So one object will have its own methods and its own variables, right?
So they are working together.
And now let's run this code and let's see what happens.
So the moment you run this code, you can see it says,
config is i5-16 and config is raisin-3-8.
So that's the idea.
That's how you create a variable.
So every object will have its own values.
That's amazing.
In the last video, we have talked about OOPS concept, right?
We have talked about objects.
We have talked about classes.
And then somewhere we have talked about init, right?
In this video, we'll focus on two concepts.
One is constructor and self.
But hold on.
We have seen self before, right?
But let's try to expand more of it, okay?
Because self is something which is very easy to understand.
At the same time, it is a bit confusing, okay?
So we'll try to get that.
And then we also talk about constructor.
Now in the last video, we have talked about init, right?
Now init is actually a constructor.
But why this course constructor?
We'll see that here.
And why this is so important?
So what we'll do is let's remove this thing.
And let's see a computer class again.
Let's go back to computer class.
So this is a class, right?
And of course, every class will have an object, right?
As we mentioned, we have a concept of a design, right?
So this computer class is a design.
And then we need to create an object of it.
So what I will do is I will say C1 is equal to computer.
Now this computer here is an object, right?
I mean, this C1 is an object.
Or you can say C1 is referring to the object.
So what happens, you know, in your system,
we have a special memory called as heap memory.
Now inside this heap memory, you will get all the objects, right?
Example, the moment you say you want an object now,
if you remember, we have talked about integers, string,
everything is object in Python, right?
Now in this scenario, here, this object will take some space
in your heap memory.
Now, every space will have some address, right?
We have talked about ID function, remember?
So we can use an ID function here and we can print the value of C1.
So we can print the address.
So of course, this object is created somewhere
and we need to print the address as well.
And the way you can print the address is by saying,
print, I want to print the address of C1.
Let's do that.
Oh, we are getting an error.
Now, if you remember, we have talked about this stuff.
So I'm keeping this class empty, right?
We cannot do that.
So let's write pass because I have not mentioned anything
in the class here.
So let's write pass.
Let's run this code now.
And you can see we got the output as 155 with the number, right?
Now, this is an address, okay?
So this is the address of that memory.
Now, what happens if I create another object?
Let's say if I say C2 equal to computer,
now we are creating another object, right?
So in total, we got two objects.
So will it take different space or will it be accommodated
in the same place?
Of course, we have talked about this before
when we talked about integers, allocation.
If I run this code, you can see we got different addresses.
And again, every time you run this code,
you will get different address, right?
Because every time you run this code,
it will create a new object for you.
So this time we got two new objects.
Now, if I run this again, we will get two different objects,
not the same object again, right?
Because this is new execution.
So point to remember is every time you create the object,
it will take two different spaces.
Now, for sure, how much space it will take?
Maybe one MB, maybe one KB, maybe five KB.
So who will decide and who will allocate the memory?
Now, first of all, the size of the object
is dependent upon the number of variables we have
or the attributes, remember?
If this class has five variables of different type,
it depends upon how much data you pass,
it will change the size of it, okay?
So the size of the object is dependent upon
the size of the variables and number of variables.
But who is responsible to assign that memory?
Or who is responsible to calculate the memory?
And that's your constructor.
Now, this thing here, which is computer brackets,
this is your constructor, right?
So whenever you write a constructor,
it will call the init method for you.
Of course, you don't have to call it explicitly,
it will be called internally.
Now, let me define some variables here.
How do we create a variables, right?
So how do we define a variable for the object?
Now, in this case, if you want to define a variable,
we have one choice, which you can define a function,
which is init.
Again, we have seen that.
So this is the init function, right?
Now, it uses self, but as of now,
we'll not talk about self, we'll continue here.
And I will use two variables.
Again, we have talked about this,
but let me just do it once again.
I will say self.h.
I want to have two attributes.
One is name.
I will say name is Navin and age.
So let's say age is equal to 28.
So we got two things, we got name and we got age.
Now, both the object will have the same values, right?
So you can imagine we have two objects
and both the objects have the same value.
If I want to change it,
if I want to change the value of one object,
the way you can do that is, in fact,
instead of printing IDs, I want to change it now
because of course, the IDs will print different now.
We know that.
So we'll say c1.
I want to print name of c1
and I want to print the name of c2 as well.
So what will happen?
Will it print the same data or different data?
That's a question.
So let's run this code and you can see
they are printing Navin, of course, right?
Because the moment you create the object,
both will have the same value
because that is what by default you're getting.
If you want to assign your own values,
you have two choices here.
What we can do is, before printing it,
we can change the value for c1.
We can say c1.name is equal to Rashi.
So we are changing the name, right?
And now if I run this code,
you can see we got Rashi and we got Navin.
So of course, c1 is different objects.
c2 is different object and we got different names.
So that perfectly makes sense.
We can change the age of c1.
We can say c1.age is listed 12.
We've got Rashi with age 12.
And of course, we are not printing age here
but we can do that.
So we can change the value of one object
from different objects.
But of course, there are two different entities.
So remember this, we got two different objects
and both the objects will have different variables.
Okay, you can assign the values there.
You can change it your wish.
Now, question arise.
Why do we need this self?
So what I will do is just to explain that,
let me take one more method here.
We'll say def update.
Okay, so I'm changing the value of something.
And the moment I say update,
I want to change age.
I will assign new age and we'll say age is let's say 30.
So we are changing the age now, right?
So we got a method which will change the age totally.
Now, I want to call update.
Now, how do you call update with the help of class name
or with the help of object name?
Let's try with objects.
I will say c1.update.
Now see, we have two different objects, right?
So what is program execution, right?
So execution will start from here.
You got the object, you got the object,
you are changing the names and everything is fine.
The moment you say c1.update,
your pointer, which is your focus,
will move towards this update function of update method.
So it is executing it, right?
Update will say, okay, I'm getting called.
I belong to a class computer.
My job is to do something.
My job is to change the value of age.
But hold on, we got two objects.
Which value you want to change, right?
Because we are calling update.
And we are not mentioning which object I'm talking about
because when you call this update,
we have not mentioned is it c1 or c2.
We have mentioned that by calling it.
So we are saying c1.update.
But we are not passing anything in the bracket.
So when you're calling it, when you're calling update,
how your pointer will know which object I'm talking about.
Is it the c1 age or is it the c2 age?
And that's where you need to use self.
So this self is a pointer.
Or you can say self is directing to c1 or c2.
So we have two objects.
This self will direct either on c1 or c2
based on what you're calling.
So if you're saying c1.update,
then in the bracket, it is passing c1.
So self will be assigned to c1, okay?
So that's the importance of that self.
It is very important because it is referring to the object.
If you have 10 objects,
and if you want to refer to one object, you can use self.
So it is the current instance you can say.
Even if you have 10 objects,
at one point you're working with one object, that is self.
I hope that makes sense.
So that is self, right?
So we have talked about constructor and self here.
Let me show you one more thing.
What if I want to compare two objects here, okay?
So I want to compare.
Let's say we have c1, c2, and both have same names, right?
So they have same name and they have same age.
But let's say I want to compare the age.
So I will say if c1 is equal to equal to c2.
So I want to compare two people based on their age.
If their age is same, I want to print their same.
So I will say c1 is equal to equal to c2, print, they are the same.
So let's do that.
So I want to check if both the objects are same,
then I will print their same.
But then I don't want to compare the object address, right?
I want to compare their values.
I want to compare their age.
Name doesn't matter if name is different.
What is what should be same is age.
Now in this case, we cannot simply say c1 equal to c2
because we don't know, your Python don't know how to compare.
So in this case, what you will do is, you will use a separate function to do that.
I will say, hey, I want to compare c1 with c2.
So I will say c1, compare, and you can pass c2
because we are comparing it.
Well, again, this compare is not an inbuilt function.
So if I click on this, you can see it says,
cannot find declaration to go to something.
The thing is, compare is not an inbuilt method we have.
So in order to work with compare, you have to define your function.
You have to say, compare.
And in this compare, of course, you have to pass self.
And then you have to also pass one more object, which is of c2.
Right?
So we are comparing two objects.
Right?
So we have to pass self.
So what is self here?
So the c1 becomes self and c2 becomes c2.
Again, you can change in the name.
You see your choice, right?
You can say other, right?
So you're comparing self with other.
So c1 becomes self and c2 becomes other.
Now, why c1 becomes self is because c1 is calling it.
So c1 is comparing itself with c2.
You can reverse it.
You can say c2.compare c1.
In that case, c2 becomes self and c1 becomes other.
Right?
And now once you have this self and other, you can compare.
If self.h is equal to equal to other.h, you will return true.
Else return false.
In fact, you could have done that in one line.
But just to make it look good, I'm doing this.
And now you can compare it.
Right?
So they don't have same age because we are changing it after update.
Let's remove the update part here.
They have the same age.
Right?
Let's run this demo and you can see, oh, we got an error.
We forgot to put a code in there.
My bad.
Let's run this code.
And so you can see just printing, they are same.
So they are same.
Right?
Now what if they have different age?
So what I will do is once I got c1, I will change this age of c1.
I will say age of c1 is 30.
Anyway, we are not using update here.
And we can say run demo.
And you can see it is not printing.
They are same.
We should print the as well.
So that we'll see, is it different?
Let's print.
They are different.
And let's run this code.
In case of that, we got they are different.
Now, since that age is different, we are getting that different.
See, names are same.
What is different is age.
So we can compare two objects by defining our own function,
which is compare in this case or method in this case.
But remember this thing, compare takes two parameters,
the first one who is calling it, and second one whom to compare.
Right?
So here in this case, we are saying c1.compare with c2.
So c1 becomes self, c2 becomes other.
This is very important.
I know it is a bit confusing at the start,
but the moment you start working on it, it becomes very easy.
Now, we know how to work with class and object, right?
And we have also seen how can you create a variable inside an object.
Of course, right?
Every object should know something.
But when it comes to variable, in oops,
we have two different types of variable.
The first one is an instance variable,
and the second one is a class variable,
or you can call them as static variables.
What is the difference between them?
Now, think about this.
Let me just remove this code, whatever we have done till now.
So let me just clean this up.
Okay?
So we will start from a plain slate.
So here, let's go with another very example.
Let's take a class call us car.
Okay?
We all love cars, right?
So let's say we have a class car,
and of course, every car will have different variables, right?
Of course, you can mention the company name,
you can mention the type of engineer you're working with,
and the mileage what it gives you.
So we have different variables.
Okay?
So what I will do is, if I want to use those variables here,
we need to use a function, which is init.
So you will say init function,
and in this, you can define those variables, right?
I can say self dot mileage,
and I will say mileage is, let's say, 10.
And then I will say the company.
So company would be, let's say, bmw.
Any random company doesn't matter.
So we have these two values, right?
Now, these two variables are called as instance variables.
So when you talk about mileage and comm, these are instance.
Now, why is our instance is because,
as your car changes, as the object changes,
this value also change.
By default, the value is 10 and bmw,
but you can change it, right?
Example, we have done that before just to give you a glimpse.
I will say the first one is c1, and this is car.
That's my first object.
I got c2, which is, again, a car.
That is, we got c1, c2.
Now, we got two different objects,
and both the object will have different variables, right?
Different area for the variables.
And now, if I print the value, so I will say c.com,
and I also want to print c1.milit.
So I want to print both.
Both the variables.
So you can see we got c1.com, c1.milit, c2.com, c2.milit.
That's perfect.
And now, if I run this code, of course,
it will print same values because they are same.
But can we change it?
Yes, we can.
So I will say, if I change for c1, so let's say c1.milit.
So let's say c1.milit changes from 10 to, let's say, 8.
This is what happens, you know, with some cars.
And let's run this code.
You can see the value is changing now.
So, of course, both the objects are different,
and they will have different values.
But what if I want to create a variable,
which is common for all the objects?
Of course, these variables, which are instance variable,
they are different for different objects, right?
If you change one object, it will not affect other objects.
What if you want to have a variable,
which will change, it will affect all other objects?
Example, the number of wheels in a car is 4, right?
By default, it is 4, right?
But what if, in future, we got a new concept?
And they're saying, hey, now, this time,
we will have five tires, or five wheels.
I don't know why we'll have five wheels, but let's imagine.
In this case, what you will do is,
you will define a variable outside in it, okay?
Because if you create, or if you define the variable inside in it,
it becomes an instance variable.
If you define a variable outside in it,
and inside a class, of course, it becomes a class variable.
Let's say, we'll say wheels.
So, let's say wheels are by default 4, of course, will be 4, right?
And if I print the wheels as well, now, how do you print wheels?
The way you can print is very simple.
You can say C1.wheels, and here as well, I'll say C2.wheels.
And let's run this code now, and you can see we got the output.
We got 4 and 4.
So, if you want to access wheels, you can use C1.wheels and C2.wheels.
So, instead of using the object name, we can also use class name.
Because see, if you talk about mill and com,
it is specific to the object, right?
But that's not the case with wheels.
Wheels is common to all the objects.
So, every object can share the same value of it.
So, we can use object name, or we can use class name, both works.
So, you're getting value 4, right?
What if you want to change the value of it?
If you want to change the value, you can come here,
and you can change the value.
See, what happens?
You know, in your memory, you have different namespace.
Now, what is namespace?
The place where you create an object or the variables,
there was namespace.
So, we have two types of namespace.
One is class namespace, where you will store all the class variables,
and then we have an instance namespace,
where you will create all the instance variable.
So, these variables, which is mill and com, they are instance, right?
So, they will belong to instance namespace.
This wheel belongs to class namespace, right?
So, if you want to work with wheels, if you want to modify it,
you have to use a class name.
You have to say car.wheels, and you can assign the value to 5.
Now, the moment you change the value for wheels,
it will affect all the objects, right?
Because they are shared.
So, this wheel is shared between all the objects,
and neither on this code, you can see the output is 5 and 5.
So, that's your class variable.
So, the point to remember is we have two types of variables,
instance variables, and class variables.
Or, in fact, class variables are also called as steady variables.
Now, till this point, we have talked about
different types of variables, right?
We have seen instance variable and a class variable.
We can call them as steady variables, right?
Now, in this video, we'll talk about methods
and different types of methods.
Now, we have seen that, right?
When you talk about objects, object will have two things, right?
The first one it will have is variables,
and second one is methods.
Now, variable to store data and methods for the behavior, right?
So, if you want to perform some operation,
that's where methods comes into picture.
As human as well, we know something and we do something, right?
So, those are your variables and methods, right?
Now, here, when you talk about methods,
we have different types of methods.
Now, basically, we have three types of methods.
The first one is instance method.
The second one we have is class method,
and then we have static method.
Now, hold on.
When you talk about variables, we only have two, right?
Because class and static behave the same way in variables.
But, hold on. In variables, we have the same thing, right?
In variables, we have class variables and static variables,
which are same.
That's not the case with methods, okay?
So, class methods and static methods are different in methods.
Okay, so, let's get started.
So, understand this concept, we'll take an example.
So, let's take a class here and we'll name this class as student.
So, in this student class, we'll be having multiple variables, right?
Now, of course, when you talk about student,
we have names, we have roll number, and then we have marks.
At this point, let me only focus on marks, okay?
So, what I will do is let me create a function,
which is your init function,
because I want to declare some variables.
So, it says self.
Now, I want to go for three variables here.
One is marks one,
and marks one, I want to pass this value from the user, okay?
Of course, you can define your own values here,
but I want to pass the value when I create the object.
And the way you do that is by saying self comma,
you will pass m1, m2, m3.
I want to pass three variables.
And m1 value will be assigned to the object
by saying self.m1 equal to m1.
I will go to same thing for m2.
I will say m2 and the same thing for m3, right?
So, we got m1, m2, and m3.
Now, we got three variables.
I want to create certain objects here.
Okay, let's create objects for this.
I will go back here.
So, let's create the object here.
I will say s1 is equal to,
and as usual, we can create multiple objects.
But time it will go for s1 equal to,
I will say student.
That's my first object.
And let me get one more object.
We'll say s2 equal to student.
So, we basically, we got two objects here.
One is s1 and s2.
I also want to pass a value to it, right?
Because we are not passing it.
So, let me pass any value, a random value.
I'm not actually saying what I'm typing here,
but then we got three values there.
And here as well, I will go for any random value.
That doesn't make any sense to see that.
So, we got these values, right?
So, first student got 34, 67, and 32.
Second student got 87, 32, and 12.
Now, what I'll do is, of course,
these variables here, m1, m2, and m3,
those are instance variables, right?
We have talked about that.
At this point, we have not created any methods.
Let me just do that.
In fact, before going for methods,
let me also create a variable, a static variable this time.
And the way you create a static or a class variable
just by defining or declaring the variable
outside the constructor, right?
So, here, I will say, I have a variable,
and we'll name this variable as school.
Because, of course, a student belongs to a school,
right, or a college.
At this point, all the students belongs to the same school,
which is the disco.
Imagine, if we have the disco university,
we'll be having a school.
So, we got the school name as well, right?
So, you can print those values by simply saying,
in fact, you can print those values here as well.
You can say, s1.m1, and x2.m1, we can do that.
What I am concerned about here is,
I want to know the average of marks, okay?
So, I've got these three variables, right?
I want to performance and operation.
How do you find the average, right?
So, the logic of average you can define by yourself,
you know, everyone has their own way of doing it.
I will be doing a very simple calculation.
So, let me create a method called as def,
method called average.
So, when I say object.average,
it will give me average marks, okay?
So, I want to return the average marks.
And the way you do that by saying return,
you want to return the value.
And here, you will simply say m1,
or not just m1, you have to say self.m1 plus self.m3.
So, we have to divide this number by three,
that's how you find the average, right?
And we know the stuff, right?
That's how you find the average of multiple numbers.
So, we got the average and we are returning the value.
Okay, so now this, if you focus on this average,
this is an instance method.
How do you know that's an instance method
because we are passing self.
Now, when you say self,
it means it belongs to a particular object, right?
Of course, we are defining that in a class,
but it works with the object.
And that's why we are passing self.
So, if you want to call average,
you have to say s1.average,
or you have to say s2.average,
because we are passing self.
We cannot simply say student.average,
because we are not using object there.
But in this case, we have to say s1.avg.
That's how you do it.
So, I have to say s1.avg.
It will give you the values.
I will print the value here.
I will say print the average here.
So, let's run this code and you can see it works.
We got the average of our student.
You can do the same thing for second student.
You can stop saying s1.avg.
You can say s2.avg.
And if you run this code,
you can see we got the average for second student as well.
And they almost say, I don't know why.
Okay, so after changing value,
we got different average, you know?
So, this was just for coincidence, you know?
I have given some values
and then they were giving the same average, right?
So, yeah, so you got different average for s1
and different average for s2.
So, that works.
Now, what we are going to do is,
so this method here,
this average is an instance method
because it works with the object.
Now, in instance itself,
we have two different types, okay?
The first type of instance which we use
is called as accessors.
And the second type we use is mutators.
So, we have accessors and mutators.
Now, what is accessors?
So, if you are only fetching the value,
see ultimately, when you talk about this method,
they are only responsible to work with variables, right?
Which is your instance variables.
So, if you want to just fetch the value of the instance variable,
we will be using accessors.
If you want to modify the value,
you will use mutators.
So, the way you do that example,
but if you want to fetch the value of m1.
So, if you want to know the value for m1,
you can fetch directly,
you can say print s1.m1,
you will get the value like this.
Or, instead of using the variables,
we should actually use methods.
So, what we'll do here is,
we'll say def and we'll define the function as get m1.
So, we'll say get m1 and which m1 you want.
So, you will say return,
I want to return the value for self.m1.
This is how you do it.
So, if you want the value for m1,
you will say get m1 and you've got the value.
Normally, it's not compulsion to have that get keyword there.
You can also say m1, that's fine.
But, when you write a code conventionally,
you simply specify get there.
So, whether you say get methods
or in fact, to set the value,
we use set methods.
Example, if you want to set the value for m1,
you will say set m1.
Of course, we are passing that from a constructor.
So, we can say set m1
and you can pass some values here.
I would pass a value f.
I will say a value.
And this value will be assigned to m1.
So, we'll say self.m1 is equal to value.
So, you can use constructor to pass the value
or we can use setters, right?
So, we have get methods and we have set methods.
Now, for different variables,
we'll be having different get and set methods, right?
So, if you have three variables,
you might be using three get methods and three set methods.
And that's why they're called as getters and setters, right?
So, getters get the value, setters set the value.
Getters only fetch the value.
It will not change the value.
That's why we say accessors.
Setters, they change the value
and that's why we say mutators.
So, this makes sense.
Whether you can call this method, right?
But, this works.
Now, once you talked about instance,
the second type we have is a class method.
Now, why we use class method?
See, if you talk about these variables, m1, m2, m3,
those are your instance variable, right?
An instance variable can be used with instance methods.
What about this one?
This is cool, right?
Now, school is basically your class variable.
And if you want to work with class variable,
you need to use a class method.
And the way you do that,
let's say I want to know the info of a student.
So, I will set def info.
Info will print the name of the school, okay?
So, let's say if you are studying for Therisco,
it will print Therisco.
And of course, all the students belong to same school, right?
If you change the school name for one student,
it will affect all the students.
For example, this channel name earlier was NavinSkills, right?
And we have changed it to Therisco.
So, if the name changes for one subscriber,
it will affect all the subscribers, right?
And that's what is happening here.
So, if I want to print info and that to a school name,
I don't want marks here.
Of course, we don't want to work with self.
We want to work with class, right?
So, if you are working with instance,
you will use a self keyword.
If you are working with a class variable,
you have to use class, CLS, okay?
It should be CLS, it should not be something else.
Now, once you got that, you can simply print the value.
So, you can say print or you can return the value, your choice.
We can say return CLS.school.
That's how you do it.
So, you have to say CLS.school.
So, whenever you want to work with class variable,
you have to say CLS.school.
Okay, but then how do you call info?
It's very simple.
You will say print S1.info.
We can do that, but there's only one problem.
Info should work with all the objects, right?
It's not specific to one object.
So, instead of using S1, we can use a student.info.
Now, this should work.
Let's try.
I will say run.
Oh, we got an error.
It says, inform is seeing one required potential argument,
which is a position argument, which is CLS.
Oh, we have to pass CLS.
That's weird.
I don't want to pass CLS, right?
In fact, we are not even doing that for average.
We are not passing S1.
Here also, I don't want to pass thing.
Normally, what happens, you know,
if you want to create a class method,
we need to use a special symbol or special way of doing that.
And we can use something called decorators.
So, we have to say add rate.
And you have to mention this as a class method.
Again, we'll talk about decorators later in detail.
But time being, we got a class method as decorator.
So, if you want to use info as a class method,
you have to say at class method, okay?
That's how you define it.
So, let's run this code now and it works.
You can see that we got the disco there.
Quite simple, right?
So, now we know about instance method
because it works with instance variables.
Now, we know about class method
because it works with class variables.
How about static methods?
See, think about this.
Let's say if you want any method, okay?
It doesn't matter what method we want here.
If you want a method which has nothing to do with instance variable,
which has nothing to do with the class variables,
we want to do something extra, okay?
So, something different which is not concerned with the variables.
At that time, you will be using a static method
because we are not concerned about instance variable.
We are not concerned about class variables.
Example, let's say I want to print the info about this class, okay?
Not about student, but the class.
So, I will say def about, you know, in fact,
instead of saying info for class,
I would say get school name.
That will make more sense.
So, I'm changing the name from info to get school for class method, okay?
Not for this.
And let me also change from here.
So, we'll say get school.
Here, I will define a function
and the function name will be info
because when I say info, I want to know the class name, okay?
So, this is not related to the object.
This is not related to class as I will keep it blank, okay?
So, if you don't want to relate this to a class, keep it blank.
If you don't want to relate this to an object, keep it blank.
No self, no class, okay?
Static method.
And this will return.
This will print.
In fact, not return, this will print.
We can do whatever you want.
So, we can say this is student class.
You can do that, right?
So, we are printing this is student class
and in ABC module.
That's it.
You can print whatever you want.
As I mentioned, important is this method
is nothing to do with the class variables
and the instance variable.
Now, where it will be useful.
So, let's say if you want to perform any operation
which has something to do with the other objects
or the class objects, we can use static methods here.
Or if you want to perform some operation
like finding a factorial for number, right?
Because the factorial has nothing to do
with the class variables or instance variable.
Maybe you're passing a value.
You just want to know what's the factor of the number.
You can use static methods there.
Now, since we are using a static method,
we need to use a special decorator here as well.
So, we have to say any guess.
We will be using static method.
So, for class method, we have to say class method
and for static method, we have to use static method, okay?
And then you can call it.
So, you can say, you have to use a class name.
So, you will say student dot info, right?
So, this is static.
So, you don't have to pass anything.
Not even class and not even object.
Let's run this code and it works.
Okay?
So, basically, we have different types of methods.
We have instance method which works with instance variable.
Class method works with class variable and static works with nothing.
It has, if you want to do something extra with a class,
nothing to do with class variables or instance variables,
go with static.
Now, to this point, we have talked about different types of variables
and we have talked about different types of methods, right?
So, we can write variable and methods instead of class, right?
So, a class will have variables and methods.
The question is, can we have a class inside a class?
That sounds weird, right?
Why would anyone want to have a class inside a class?
So, let's try to understand that.
So, let's say I have a class here and this class name is student,
as usual, the way we have done earlier.
And when we talk about students, we have different types of variables, right?
Let me define that function first.
And the variables which I want here is self.
First, I want a name.
Of course, in the last example, we have taken marks,
but here, let's take something different.
I would take a name of a person and that will be coming from a user,
of course, or from when you create an object.
We'll say name.
The second thing I want is roll number and I want these two details.
And then I will assign name here and I will say self.roll number.
Now, we have used to it, right?
So, I would say roll number, right?
Now, once we got these two variables, what I want is I want to print them.
The way you print these values is by defining some functions, right?
Of course, you can do that directly.
Example, if I create an object here.
So, let's say the object is S1 and I will say student.
And when you create this object, you have to pass values as well, right?
The first one I want is navin and roll number is let's say 2.
The second object we want here is S2 and we'll say student,
in which we'll be having two things.
Of course, I would say this is Jenny and the roll number is let's say 3.
So, I have navin and we have Jenny here, we got 2 and 3.
Okay, so let's say I want to print.
I want to print S1.
So, I want to print all the details about S1, okay?
I want to print the name and roll number.
So, the way you do that is by saying S1.name and we can say S1.roll number.
So, this is how you can print the values, right?
Let me run this code and you can say it works.
We got the details about S1.
Now, what I want to do is I don't want to, see, this doesn't look good, right?
What you should be saying is you should say S1.show.
So, when I say S1.show, it should print all the details about S1.
Maybe it has roll number, name or different variables, right?
So, of course, we need to define that function or method here.
So, we'll set F, show.
So, this will print self.name and we'll print self.roll number.
So, we are printing these two data, right?
It should work. Let's run this code and you can see we got the same data.
Now, let's say student also has a laptop.
Of course, right?
When you say you are doing IT, in fact, we have done that, right?
So, you are a student of Therisco.
You will be using a laptop to run your code or the extra doesn't matter.
And let's say we want laptop here.
So, of course, I want to know which laptop we are using.
So, I want to know your config.
Now, in that case, I will also ask a user, hey, tell me which laptop you are using.
The problem is when you talk about laptop, there are different things important, right?
It's not just about brand.
You will not simply say, hey, I have HP laptop.
I have a Lenovo laptop.
You will also mention the configuration, maybe CPU and RAM.
That's very important.
Maybe any i5 CPU with, let's say, 8GB RAM is enough.
So, I want to know your config.
So, what you will do?
Will you pass three variables?
Like, you will pass a brand, HP, and then you will also pass the CPU,
which you are using, let's say i5, or you will also pass, let's say, RAM of 8GB.
Yes, you can do that, okay?
So, I have to accept these variables here.
I have to accept that here, right?
And we can do that.
The other option which we have is different, okay?
So, the other option which we can do here is, we can create a class, okay?
We can create a supply class as laptop, or instead of creating a class outside the student,
we can also create a laptop inside student.
So, a laptop will be only used by student, and in this case.
So, I will say a class and I will say laptop.
So, we are creating a laptop class inside a student, so that we can get that group, okay?
So, we have to also set depth here, and we have to say init, right?
And then let's create a variable.
So, the first variable we need here is brand, and let's say the brand is HP.
That's the first thing we need.
Second thing we need is the CPU which you are working with.
I would say CPU is i5, and the third one is RAM.
Let's say aGB RAM.
So, we got these three things, right?
Now, we got these three variables.
And where to create the object of it?
So, we can create the object here itself.
So, we can create the object inside the init, and normally that's what we do.
So, if you want to create the object of laptop, we should be creating that object inside the
outer class, okay?
So, the object of laptop will be inside the student class.
The way to do that is very simple.
Here, you will say self.lap.
You can create any variable you want, and you will say laptop.
Or we are getting error, so we have to say self.laptop.
Okay, this works.
So, you can see in the constructor itself, you can define a variable.
So, in the outer class, you can define a variable lab, and you can define the object.
So, if you really want to use a laptop, you have to say the student object.lap.
Example, outside, if I want to use it, I will say s1.lap.
Whatever brand you want to fetch.
So, you cannot simply say lab.brand, you have to say s1.lab.brand.
Because the lab object is inside the student class.
This is one way.
What if you want to create another object of it?
Let's say I don't want lab.
I want...
So, you can simply say lab1 is equal to s1.lab.
You can get another object for s2.
You can say lab2 is equal to s2.lab.
Because for every object, you will get different laptop object.
Okay, trust me, this is how it works.
In fact, you can also check that.
We got two different laptop objects here.
We will print lab1.
And let's print laptop.
So, let's print the ideas of lab1, lab2.
We got two different objects here.
So, this works.
Okay?
This is where you create inner class.
Okay?
So, we have a laptop as an inner class of a student.
Right?
You could have done the outer class as well.
I mean, you could have created different classes that you want that works.
But sometime, when you know that this class will be used only for student, nothing else,
then you don't have to create a separate file for that.
You can do that in student class itself.
Now, can I directly create the object outside?
Let's say I don't want to get an object of laptop inside the student class.
Can we do it outside directly?
Let's try.
So, I will say lab1 is equal to...
I will say student.laptop.
Now, why student here?
Because you cannot simply access laptop directly.
Right?
Because laptop class belongs to a student class.
So, we have to always say student.laptop constructor.
You cannot simply create laptop directly.
Okay?
So, this is one thing you have to remember.
You can create the object of inner class inside outer class.
Or you can do that outside the outer class provided.
You are using the outer class name.
So, you have to say student.laptop.
Okay?
This works.
In fact, just to enhance the example, what I will also do is,
we can create a show method for a laptop as well.
So, we can say show for laptop.
And you can see we have two show methods.
One is student and one is laptop.
Okay?
So, in such student, we have show method inside laptop.
Also, we have show.
But these are two different show methods.
The show method of student will print the data about a student.
And the show method of laptop will print the show method of student.
I know that makes it.
That's weird.
So, let's do that.
So, I will say print self.brand, self.cpu, and self.ram.
Okay? So, we are printing this data.
So, this show is different from this show.
Let me now print laptop here.
Let me on this quote.
And you can see it brings only the name and the roll number.
I also want to print the laptop.
Oh, you need the object, right?
We have removed that statement.
Because if you want to access laptop, you have to say self.lap is equal to laptop.
But you have to say self.
So, this is important.
And after printing, this will call laptop show because we also want to do that.
So, you will say self.laptop show.
Okay?
So, we are printing data about a student and laptop as well.
So, this should work.
Let's run this code and it worked.
You can see we got data about a student and laptop as well.
So, this is how you create the class inside a class.
Now, in this video, we'll talk about inheritance.
Now, we talk about a concept of oops, you know,
where which is object-oriented programming.
We have so many concepts to talk about.
And one of them is inheritance.
Now, in real life, what we have is we have this parent and child relationship, right?
So, whatever belongs to your parents belongs to you.
Example, if my father or mother has a phone, it's my phone, right?
By default, my phone would be my phone.
But my father's phone would be my phone, right?
That's how it works.
So, if your parent's house, it's your house.
That's what we say inheritance, right?
In the same concept, you can implement in programming as well.
In fact, all the languages which follows oops concept,
they do implement inheritance, right?
And the way you do that is with the help of classes.
Class inherit a class.
Let's try that.
What I'm talking about is, let's say if you have a class
and class is a, okay?
Again, it should be a logical name.
So, you can go with employee class, you can go with student class,
you can go with laptop class, whatever class you love.
But time being, just for the example, we are going for class a and class b or class c.
In future, we'll try to implement some other examples
using different names and with proper example.
But at this point, just to keep it simple, let's go for class a.
Now, if we talk about this class a, this class a will have multiple features, right?
Maybe we can define two methods here.
So, we'll set definition there.
The first method which I want to go for is, let's say feature one, okay?
So, let's say we got this function which is feature one
and this function does provide you something, okay?
So, time being, we are printing feature one working.
That's it, nothing much.
Of course, it can be a complex code, but make it simple.
Let's keep it that.
And then we can have another feature here.
Let me just copy paste this code.
So, I will say copy and paste and this would be my feature two.
So, we got feature one and feature two and this will point feature two is working.
So, this class a has two features.
We got feature one, feature two, right?
And the way you can access them is with the help of object, right?
And the way you create an object is very simple.
You simply say a one is equal to a, that's how you create the object, right?
Where a is your constructor.
Again, you can define that in it method here, but not needed at this point.
So, this will work.
And using this a one, you can call feature one, you can call feature two, right?
So, you can say a one dot feature one and a one dot feature two.
And this will work.
Let me just run this code and you can see we got feature one working,
feature two working.
So, this code is working.
Now, what I'm excited about is, let's say we have one more class.
Let's talk about class B.
So, let me just create a class B here itself.
So, here I will say class B.
And class B will also have two features.
I will name this as feature three and feature four.
Instead of typing them, let me just copy paste the code here.
And we'll name this as feature three and feature four, right?
See, normally what happens, you know, when you work on a project,
of course, we have a very big team, right?
So, example, if one person is defining a class, okay?
In that class, we provide you four features or four methods.
Maybe you want to define some other class in which you need some extra features
and you also want the existing features.
You don't have to really find it, right?
You can use it.
And the way you do that, you're simply saying,
example, in this class B, we got two features, right?
We got feature three, we got feature four.
And of course, if I create the object of B one,
so it's a B one is equal to B.
And the functions which you can call using B one.
So, if I say B one dot, you can see we got only two options.
We got feature three and feature four, of course, right?
Because in B class, we have only two features.
What if you want to get the features of A as well?
And that's where inheritance comes into picture.
So, we can say, hey, this B is a child class of A, right?
And the moment you say child class, it will import all the features.
What I will say is this B is a child class or you can say subclass.
We have different terminology we can use here.
And we can simply say in the bracket, you can say A.
So, this class B is inheriting all the features from A.
And we got it, right?
Just writing that one thing, you know, just bracket A.
We are saying B is inheriting the features from A,
which means with the object of B, which is B one in this case,
the moment I say B one dot, see the options.
You can access feature one, feature two, feature three and feature four.
And that's the importance of inheritance,
which simply means if you already have a class which provides you some feature,
and in future, if you want to create your own classes,
in which you want to use those features, you just need to inherit them, right?
So, we can use some terminologies here.
We can say superclass, subclass, or we can say parent class or child class.
So, timing will refer them as superclass and subclass.
So, super is a class which is A and a class which inherits the class,
we will call them as subclass.
So, B is subclass and A is superclass.
So, that's the concept about inheritance.
Now, this is also called as a single level inheritance.
We have some other types as well.
We also have a multi-level inheritance.
Now, what it means?
Example, let's say if I have another class here,
let me get one more class here, and this class is let's say C.
So, we'll call this class C or this class C inherits B.
Now, what will happen is whatever you do in this class, let's say timebin,
I will define only one feature here, we'll say feature five.
You can see how lazy I am.
So, this is feature five working, right?
So, we got C class which has only one feature.
But the moment you create an object for C one, so I will say C one is equal to C.
The moment I say C one dot, see the methods you can use.
So, we can use feature one now.
So, feature one feature two are coming from A, right?
But C is only extending B.
So, that's our relationship.
We have grandparent, we have parent, and then we have child, right?
So, a child can access all the features from parent, grandparent, great grandparent, right?
So, that's how it works.
Okay, this is working, right?
So, we got single where you have one superclass, one subclass,
then we have multi-level where you have superclass, subclass,
and then I get subclass of that superclass.
Okay, this is working.
What if you go for multiple?
What is multiple here?
Let's say the C is not only taking from A and B.
We got some other class as well.
Just for time being, what I will do is I will say B is not inheriting A, okay?
So, A and B, they are two different classes.
Nothing, they are not related to each other.
A provides two features, B provides two features, okay?
So, there's no relationship between A and B.
They are two different classes.
C says, I want to access features from both, from A and B.
So, in this case, the C will inherit from A and B both.
So, you will say A, B.
So, C will copy from both, or C will inherit from both.
So, we will say C1.
The moment you say C1, you can see you can access all the features.
That's not the case with B1 now.
B1 can only access two features, feature three and feature four,
because B is not inheriting A, okay?
Point to remember.
So, we got A, we got B, and then we got C.
C is inheriting both the classes, A and B.
So, this is called as multi-pull.
So, this is your multi-pull, right?
So, we have done with single, we have done with multi-level,
and then we have multi-pull.
This is how we can work with inheritance.
Now, to this point, we have talked about OOPS concept, right?
In which we have seen inheritance, right?
Now, what is inheritance?
If you already have some classes, and if you want to use the existing features,
you will simply say class B, which will take the features from A, right?
So, class B inherits A.
Or you can go with a concept of multiple inheritance,
where one class will extend from two different classes,
or more than two classes, right?
So, in this case, we have class A, class B,
and then we have class C, which has a feature five,
but it is also inheriting A and B.
So, we can say C has five features, right?
So, that makes sense.
Now, what we'll do in this video is we'll talk about two topics.
The first one is the constructor in inheritance, how it behaves,
and we'll also talk about method resolution order, or you can say MRO.
So, let's start with the constructor.
Timebin, let's ignore C, okay?
So, let's say we don't have this C, so we'll ignore that part.
And, in fact, we'll delete that part for timebin.
And let's focus only on A and B, where B is inheriting A, okay?
So, in total, in B, we have four features, right?
Now, what happens is, if I create an object of A,
so let's say if I say A1 is equal to constructor of A,
so this will work, right?
So, when you say A bracket, that's a constructor,
it will call a method which is in it.
Now, even if you don't define it, it is there somewhere, right?
But let me define my own constructor, own init here.
So, I will set def, and we'll define the init method,
and this init method will print one stuff.
So, I will say print in A init.
Nothing much, we are not doing anything extra here,
we are just printing in A init, that's it.
Now, what do you think?
What it will print?
Of course, we are creating object of A, right?
So, it will only execute A.
See, with the object of A, you cannot access features of B, okay?
So, even if I try example, if I say A1 dot,
you can only access feature one and feature two.
But yes, if you have an object of B,
you can access all the features, right?
Features from A and B,
because B is a subclass and A is superclass.
And as I mentioned, subclass can access all the features
from superclass, but that's not vice versa, right?
A superclass cannot access all the features of subclass,
not even one feature of subclass.
Okay, this is fun.
Now, what if I create object of B?
So, I'm not getting object of A here,
I'm getting object of B.
Doesn't matter what is A1 or B1,
important is if I create an object,
B, which call the constructor, that's the question,
because we are not getting object of A,
we are getting object of B.
Will it call the constructor of A?
That's the question.
Let me just run this code and it works, okay?
So, even if you have the object of B,
it will still call the constructor of A, right?
That's how it works.
But what if you have your own constructor?
What if you have your own init method?
Example in B, see in B, we don't have that init, right?
And that's why it is going up.
So, let me repeat, since we don't have init inside B,
that's why it is going to A.
But what if you already have an init with you?
So, I will simply copy paste here in B.
So, both have init, but then in this,
I will print in B init, right?
So, in A, we are printing in A init,
in B, we are printing in B init.
So, this makes sense.
Now, if I run this code, what it will print?
It will print in A init or in B init.
Of course, if you are getting object of B,
it should only call the init of B, right?
And let's see if that works.
And let me just run this code and we are right.
So, when you run the code, you can see we only got in B init.
So, that means if you create an object of B,
first it will try to find the init of B.
If it is not there, then it will go for A.
Okay, that's the point you have to remember.
But what if you also want to call the init of A?
Is it possible?
I mean, if I create an object of B,
can I call the init of both the classes?
I mean A and B.
See, by default, it will call only B, right?
What if I want to call A as well?
And that's where we have a very special keyword or a method,
you can say, and that is super.
So, with the help of super,
so you can say super and it's a method, basically.
So, you will say super dot.
The moment you say super,
you can access all the features of the parent class.
So, you can say super dot init.
So, what we are doing is we are trying to call
an init method of class A.
So, the moment you say super,
you are representing the super class, okay?
Which in this case, it is A.
So, we are trying to call the init method of class A.
That's important.
And now, let's run this quote.
And you can see we got both the output.
We got in A end and we got in B end.
So, point to remember is when you create an object of B,
it will call the init of B first.
And from the init of B,
you are trying to call the init of A.
So, it will jump up,
it will execute the init of A first,
which will print in A in it.
And then it will come back to print in B in it, okay?
That's why we got the output.
So, this makes sense.
So, we can work with constructor in inheritance, right?
Now, let me add a twist here.
So, what I will do is I will remove this super from here.
Let's clean it.
And I will not even say that this is B.
So, class A and class B, two different things, okay?
They're not linked with each other.
But then we have class C.
As we have done earlier, we'll say class C.
And class C will inherit both the classes A and B, okay?
And now, if I say def and init,
you know what we are trying to do here.
First of all, we'll print in C in it, okay?
And then I will create the object of C.
So, there's no object of A and B.
I'm trying to object of C.
Now, what do you think?
Will it call the init of C or A or B?
Of course, right?
When you say the object is of C,
it will call the init of C only.
Let's run this code.
And that's right.
We got the output as in C in it.
So, this works perfectly.
But what if you want to call the init method
of a superclass?
But there's a twist here.
Now, C has two superclasses, right?
One is A and B.
The moment you say super, dot init.
Now, what do you think?
Which init it will call?
Will it call the init of A or B?
That's a question.
Let's run this and let's see what happens.
The moment you run this code,
you can see it says in A init.
That means we are unfair here.
We are biased towards A.
We are not taking B here, right?
This is completely wrong.
Oh, but the thing is, we have a concept of MRO,
which is method resolution order.
So, what happens is,
whenever you have this multiple inheritance,
it will always start from left to right.
Which means, so first,
so the moment you say init,
it will try to find the init of itself.
So, since we have init here,
it will execute the init of C.
Then, the moment you say super, dot init,
now we have two classes, right?
A and B.
And on the left side, we have A
and on the right side, we have B.
So, it will prefer left one first.
It goes from left to right.
And that's something you have to remember.
It's always from left to right, okay?
And that's why we got in A init.
The same thing can be done for methods.
Example, let's say, we have two methods which are same.
So, in this case, you can see we have feature one in A
and feature one in B.
Both are the same methods with the same name, of course.
And in this, I will print some different message.
Here, I will print feature one A.
And here, I will say feature one B.
That means, the feature one is in A
and feature one is in B.
And now, if I try to call, so I will say A1 dot feature one.
Will it call from A or B?
That's a question and we know the answer, right?
It will always call from A, because it goes from left to right.
And you can see the output.
So, this is something you have to remember,
which is a concept of method resolution order.
So, basically, in this video, we have talked about three things.
The first one is how constructor behaves in inheritance.
The second one is how to use that super method.
And the third one is MRO, which is method resolution order.
Now, in fact, with the help of super method,
it can be called function.
Let's see that.
So, let's say from, we have a function here, which is def,
and I will say feature, feed.
That's it.
And in this, I'm trying to call the method of super class, right?
So, we can say super dot.
And we can use that thing, okay?
So, we can say super dot feature two.
And let's see if it is working.
Let me call feature.
It should call the feature two.
So, yes, it works.
So, you can also use super method to call other methods as well,
not just in it.
So, to represent this super class, we use super method, okay?
Now, we have started talking about objects, right?
Then, we move towards class.
And then, we have discussed about inheritance.
Now, it's time to focus on one of the major concept in OPS,
which is polymorphism.
Oh, that's a weird word, right?
Now, when we talk about polymorphism,
it's break down this word poly and morphism.
So, poly means many, right?
And when you say morph, it means forms.
So, that means one thing can take multiple forms.
Example, like, as human, you know, we have different forms.
As the situation changes, we change ourselves, right?
Example, we behave differently at different location at office.
We behave differently when we are with our friends.
We behave differently.
So, we are polymorphic.
In the same way, when we talk about object-oriented,
objects will have multiple forms.
So, this concept is very important when you talk about software development.
So, we use this concept a lot when it comes to loose coupling,
dependency injection.
We also have a concept of interfaces, which we'll see later.
There are four ways of implementing polymorphism.
The first one is duct typing in Python.
The second one is operator overloading.
Then, we have method overloading and method overriding.
In the next few videos, we are going to talk about all these topics, okay?
And one of the interesting ones is duct typing,
especially if you are coming from different backgrounds, let's say,
if you have already seen Java or C++ or C sharp,
this has been different for you because in Java or in C sharp,
we have to mention the type of the variable which you work with, right?
We have to mention the type of object you work with.
But Python, we have something different, right?
In the last video, we have talked about polymorphism, right?
Which simply means you have one thing which will behave in a different way.
Or you can say one thing and multiple forms, right?
That is many forms.
Now, in this video, we'll talk about the first way of doing that,
and that is your duct typing.
I know that's a weird word, right?
Duck typing.
We have this famous line, which is if there's a bird which is walking like a duck,
which is quacking like a duck, and which is swimming like a duck,
that bird is a duck, right?
Which simply means it doesn't matter if it's a duck or not,
what matters is the behavior of that bird.
If it is matching with duck, that's a duck, right?
Now, how do you implement that in programming?
So what we will do here is let's take an example.
Let's say if I have x equal to 5.
Now, we talk about the type.
Now, in Python, we have a concept of dynamic typing,
which simply means the type you can mention later.
Example, when you say x equal to 5,
the type which we are representing now is integer.
But what if you say x equal to, let's say, Navin?
Are we changing the type of x here?
See, that's not the case.
What is happening here is when you say 5, in your memory,
you got a space which is of type integer.
When you say Navin, in your memory,
you got a space which is of type string.
The x is just a name to it, okay?
So when you say x equal to 5, there is an object of type integer,
you are just naming it as x.
Later, when you say you got Navin,
you got some space in your memory and you are representing that with x.
x is just a name to it, okay?
So we don't have specific type to x.
The moment you say type of x, you are actually getting the type of 5.
When you say the type of x, you are getting the type of Navin, right?
So that's one thing you have to remember.
The moment you give a variable name, that's just a name to a memory.
Now, to understand that typing what we'll do is we'll take another example.
To explain this, what we'll do is we'll create a class
and we'll name this class as laptop.
And this laptop class will have a method which is, let's say, code.
So in this code, what I will do is I want to execute my code, right?
So as a programmer, what we do is we write code, right?
We write code and we compile it,
we run it and we get the output at the end.
But then to do that, we also need an IDE which is Integrated Development Environment.
And in this case, if you want to write a code, you need to pass an IDE.
So we are expecting in the arguments that someone will pass an IDE to us.
And using this IDE, I will say IDE.execute.
So the question is, the IDE is of what type?
Is it a type of integer?
Is it a type of float?
Is it a type of string?
Now, of course, when you say execute, that means there's something
which is not there in the existing classes which you have.
That means the type of IDE is something very unique,
it is something which is user is defining, right?
That means if you want to create this object IDE,
you need to create your own class.
Let me get a class here and I will call this class as PyCharm.
Now, for different languages, we use different IDEs.
In fact, for one language, we have multiple options, right?
Example, when you work on Java, maybe you will be using NetBeans,
Eclipse, IntelliJ, for Python as well, we have different IDEs.
We are using PyCharm here because it works well.
Now, when you say PyCharm, of course, it will have a method, right?
So let me define a method which is def execute.
So you can see we have these two statements.
The moment you say execute, it will say compiling and running.
That's what you do, right?
We are code gets compiled and your code get run.
Now, will this work?
Of course not because we are not calling anything.
So when you run this code, you will not get any output.
Let me just try it out.
I will right click and say run demo.
You can see there's no output because we are not calling methods.
Let me call code.
The way you call code is by creating the object of laptop first
because you cannot call code without laptop.
So I will say lap one is equal to laptop.
And with the help of lap one, now you can call code.
So you can say lap one dot code.
But there's one problem here, which is inside a code,
you have to pass an argument which is of IDE.
That's a question now.
How do you pass an IDE here?
So what I will do is first you need to create an object of IDE.
You will say IDE, of course, you can have different names here,
but let me go with IDE.
So IDE equal to this will be of type PyCharm.
So the type of IDE we are working with is PyCharm, which is usually fine,
of course.
And then when you are calling code, you have to pass IDE.
And now it should work.
You can see from this code, you got compiling and running.
So the type of IDE here is PyCharm.
But is it fixed?
Can we change the type of IDE later?
Maybe let's say we have one more IDE.
Let's say in future, I'm creating my own editor,
which is way better than PyCharm, maybe.
And in that as well, we have the same method.
Let's say execute.
And in that, I'm doing some extra stuff.
So my IDE also does spell check.
Maybe PyCharm does that.
My IDE also does what?
Convention checks, the name of the variable and different stuff.
And then it also does compiling and running.
So my IDE does extra stuff.
Now what if I want to change the type of IDE?
Is the IDE type fixed to PyCharm not exactly
because this is dynamic typing?
So you can replace this IDE type from PyCharm
to editor provided.
You have that method, which is execute.
It doesn't matter which class object you're passing.
What matters is that object should have the execute method.
Because in IDE, we are saying execute.
So now, even if you change from PyCharm to my editor,
there is no problem.
The code will still work.
Provided you have that method.
So if you should be having this method, which is execute.
And that's the case.
If there's a bird, and if that bird behaves like a duck,
it works like a duck, it quacks like a duck,
it swims like a duck, it should be a duck.
In the same way, if there is an object, which is IDE,
and it has a method execute, that's it.
We are not concerned about which class object it is.
What we are concerned about, it should have that method,
which is execute.
And that is called as duck typing.
I know it is amazing.
And if you're coming from different background, like Java,
so we have a concept of interfaces.
So that's what we do.
We create interface.
And we have this my editor and PyCharm as a class,
which will implement that interface.
But if you are new to this programming, don't worry.
That's the Java part.
This is simple.
We have started talking about polymorphism.
And in that, we have seen one example of duck typing.
Now, in this video, we'll talk about operator overloading.
So what is operator overloading?
So we know the concept of operators.
So we have two operands.
Example, if you want to add two numbers,
you can say 5 plus 6, where 5 and 6 are your operands.
And plus is the operator.
So we know that.
And then we have a concept of polymorphism.
So it simply means you have one thing
which has multiple forms.
Now, if you can think about this, we have two integers.
And then we are trying to add them.
We can also add an integer and a float.
So in different programming language, it does support.
What about two strings?
So if you say you have two strings, let's say,
hello plus world.
Will it work?
And the answer is yes.
So plus works with the strings as well.
But what if you want to say you have a number 5?
So let's say we got a and a is 5.
And then we got b and b is, let's say, world.
Now, can I print by saying a plus b?
The moment you try to underscore, you can see we got an error.
It says unsupported operand types for plus.
So we cannot use int and string for plus.
So all these things are predefined.
All these things, they are called as a synthetic sugar,
which simply means it is trying to simplify the code
for the user.
See, behind the scene, things are a bit different.
Imagine this one.
Example, if I say a is 5 and b is 6.
Now, what do you think?
What is happening behind the scene?
Now, trust me, whatever happens in Python
happens with the help of object.
And here as well, when we talk about a and b,
the type of it is int.
So int is a class here.
And when you say class, of course,
class will have certain methods.
So behind the scene, what is happening
is when you say a plus b, which is of type integer,
it is calling something.
So behind the scene, it is calling int dot.
The moment you say int dot, int is a class.
And you can see we have a method called as init.
We have a method called as abs.
And we also have a method called as add,
which is very important here.
The moment you say int dot add, this
is taking two parameters.
The first one is a comma b.
So what we are doing here in print a plus b,
the same thing can be done here.
Let me just run this code here.
You can see we've got the same output.
So both are printing 11.
So you can say a plus b, or you can say int dot add
by passing two parameters a comma b.
And of course, the first one looks cool, right?
You're simply saying a plus b.
Because from our childhood, we are doing that.
We are trying to add numbers using plus operator.
But the moment you come to programming in programming,
whatever you want to do, you will
be doing that with the help of methods.
And add is a method which belongs to the int class, right?
If I jump to integer, so you can press on the control button
and click on the method which you want to see,
or the class which you want to see.
You can see it's a class.
And this class has multiple methods.
In the same way, the moment you say int dot,
you can access a method called as add,
and you're calling a comma b.
So even if you say a plus b behind the scene,
this is getting called, right?
So this is one thing you have to remember, OK?
So we'll talk about operator overloading later,
but this is something you have to remember.
So whenever you add two numbers, this
is what is getting called behind the scene.
Now, if these two things are strings,
so if I make a string here, now this is not integers, right?
They are strings.
So I have to say str dot add.
Now, when you say str dot add, in fact, str
also has an add method which takes two parameters.
And both should be of the same type, which is string type.
And then it will work, right?
So if I run this code, and you can see it is working.
So we got five and six as a string.
So they got concatenated here.
So this works.
The moment you change the type of it,
it will not work because the inbuilt class
doesn't have two things, which is integer and string
together, right?
So this thing you have to remember.
Now, once we know the moment you add a plus operator,
it calls the add method.
The moment you put a minus operator,
it will call a sub method.
The moment you use a star symbol, which is multiplication,
it will call a mul method.
So we have different methods for different operators, right?
And normally, those things are called as magic methods,
but that's what they say, magic methods, right?
So all these operators, behind the scene,
they work as methods.
Now, to understand the concept of operator overloading,
what I will do is I will say class.
And let's say we have a student class.
And every student will have, let's say, two variables.
And that will be marks one and marks two,
just to keep it simple.
So what I will do here is I will set def and init.
And here, I will say self.m1 is equal to oh,
now we want the value from the user, right?
So maybe I want to pass the value.
So I will pass it from here, m1 comma m2.
And let's specify self.m2 is equal to m2.
So we got these two values, right?
Now, what I want to do is I want to create two objects,
okay, two students object.
One is, let's say, s1 is equal to student.
And this will take two values.
I would say 58 comma 69, that's the value here.
And then s2 is equal to student.
And this student will have, let's say, 60 comma 65.
So we got two marks here, right?
We got two student and each student have two marks.
Now, I want to apply the operator here,
which is plus operator.
So I want to add these two students.
So the moment I say s1 plus s2,
I want a different student object, right?
Is it possible to do that?
Let's try.
So I will say s3 is equal to s1 plus s2.
Because now we know that plus operator means
it will add two values.
But it is possible with the help of integer.
It is possible with the help of string.
Is it possible to use plus operator with student class?
That's a question.
So let's run this code.
Let's see what happens.
Okay, we are not printing the value of s3,
but let's run this code.
The moment you try to run this code, you will get an error.
Oh, okay, we got different error here.
It says student takes no argument,
but it is taking arguments, right?
What's wrong?
Oh, we have written the wrong name, my bad.
Let's run this code once again.
So I was expecting this error, not the first one.
And the error is it says unsupported operant type plus.
We cannot use plus between student and student
because we have not defined it, right?
If you remember, behind the scene,
even if you use plus with integers,
it will be calling an add method.
But if you see our class,
we don't have that add method, right?
Because if you say s1 plus s2,
how your compiler, how your Python will know what to do?
And that's where you have to define it.
Yeah, that's where you have to say,
hey, the moment anyone says plus of a student,
you need to call this method called as add.
Okay, so you can overload the operator
and you can change definition for it.
You can define anything you want, right?
So I can say add and this add will take two parameters.
The first one is self comma other.
And you can see it takes two parameters, self and other.
Okay, guess what is happening?
So behind the scene,
this code is getting converted into,
it is student dot add,
which takes two parameters, s1 comma s2.
So what is self and what is other here?
So the first parameter is self
and s2 is the other parameter.
You can change the variable name, that's fine, okay?
You can say this is o and it should work.
It's a variable name, right?
So this is what is getting called behind the scene, right?
So here what I will do is I will say,
let's take two variables, m1,
m1 is equal to self dot m1
and m2 is equal to self dot m2.
So we got two variables, right?
Oh, not just self m1 plus,
it is other dot m1 plus other dot m2.
So this is how you add values, right?
So self m1 and other m1
and then m2 will have the addition of self m2 and other m2.
So this works.
And once you've got these two values,
what you will be doing is you will be getting
a new student object, we'll call that s3,
you can have any name as a matter.
So s3 is equal to student
by passing these two values, m1 comma m2.
And now once you've got this student,
you will return s3 here, right?
That is what you're expecting.
So the moment you say s1 plus s2,
it will return the value,
it will return a new object of student
and you will assign that to s3.
Okay, so this is what will happen.
Now if I print the value for s3,
so I will let me print s3 dot m1
and the moment you run this code, run
and you can see it works, you've got 118.
Is it right?
Of course it should be, right?
So it is 58 plus 60 and that's right.
We got 118.
This thing is working, right?
Perfect.
So if you want to add two students,
you need to overload the operator of plus
because integer knows what is plus,
string knows what is plus,
your student class don't know what is that plus means.
So plus means call the add method,
but we don't have an add method here.
So we have to define our own method.
The same thing can be done with subtraction,
is minus, the same thing can be done with multiplication.
So I would recommend you to explore more on this, you know?
So the moment you say def underscore underscore,
you can see we have so many methods.
We also have greater than, we also have equal to symbol.
We can compare two objects.
We can say that different methods are available here.
Okay, so try it out.
We also have multiplication somewhere.
So you can see we also have mull.
So everything is predefined, you can just use them.
In fact, for this example, I will take one more.
I want to compare if two objects are
greater than or equal to example,
if I say if S1 is greater than S2,
this is the horrible way of comparing students
because marks is not a criteria
where you can compare students.
But just for the example, I will say S1 wins.
So whoever has maximum marks, I will say they win.
I will say else, print S2 wins.
So what we are trying to do here is
whoever has maximum marks, they will win.
But when you say maximum marks, how do you check it?
Because we are not defining it, right?
Maybe I want to check only first marks,
which is M1 or maybe I want to check M2
or maybe the addition of both.
You can try it out.
So what I will do here is this will work, of course not
because the moment you try to run this code,
it will give you an error by saying
the greater than symbol not supported
between two instances of student.
It is supported for integers because it is predefined.
So here as well, if you want to make it work,
you have to define a function of method, which is GT.
GT is greater than, GE is greater than equal to.
So you want to check only greater than.
And then here you'll be using self and other as usual
because behind the scene, that is what is happening.
It is saying student.GT and it's passing two variables,
S1, S2.
So S1 goes to self, S2 goes to other.
And now, how do I compare?
So we'll say S1 doesn't matter, is it S1 or something?
So we'll say S1 is equal to self.M1 plus self.M2.
And we'll say S2 is equal to other.M1 plus other.M2.
So we are adding their marks basically.
You can compare.
If S1 is greater than S2,
now this time S1, S2, they're not objects, okay?
They are simple variables of integer.
Okay, if I'm getting confused with this,
let me just make it R, that should make sense.
So let's compare R1 and R2.
Now those are just marks, right?
If R1 is greater than R2, we will say return true,
else return false.
Simple.
Now if you're on this code, we are comparing it, right?
Let's compare and let's run.
And it worked, you can see S1 wins, right?
Because S1 values are higher.
So 58 plus 69 is higher than 60 plus 65.
But what if I change the value for S2?
Let's say there's 69 and you can see, of course,
now S2 is bigger, so let's run this code.
And you can see it says S2 wins, so that's right.
So what we are doing is we are adding those values
and then we are comparing it.
So if you want to perform any operation on the objects
which I usually find, you have to define all these methods.
Okay, there's one more.
What if you have a variable, let's say A is equal to nine?
Now when you say print A, and you can see
it will print the value of A, there's nothing wrong with that.
You can see it is printing the value of A.
Now is it printing the address of A?
That's not the case.
Why it is not printing the address of A?
It is printing the value of A.
But what happens, the moment you try to print S1,
it will not print the values of S1.
It will try to print the address of S1.
Okay, so you can see that it says it's a student object
at the address at this position.
Okay, we don't want that address, right?
We want values.
What is happening?
So when you try to print the object,
doesn't matter is it integer or your class,
behind the scene, it is calling a method called as str.
It is happening behind the scene, okay?
Even if you don't call it, it is happening behind the scene.
So the moment you say print A,
it will try to call A.str.
And that's why you are getting the output, right?
You're getting nine because it is calling str.
In the same way, the moment you say S1,
even this is calling str, right?
And now if you run this code,
you can see it is still giving the same output.
That means it is calling str.
What is this str?
So if I click on this, you can see it is in built-in.
So even if you don't define str function
or method in your own class,
it is getting defined somewhere.
And that definition, what is printing?
It is printing the module name.
It is printing the name of the class
and it is printing the object address.
We don't want that, we want values, right?
That means we need to override this method.
So what I will do is I will say def.
And the method name is str,
so you have to define this by yourself.
So we want to return the value of m1 and m2, right?
So you will say self.m1, self.m2.
And now if I run this code,
it will return a tuple, of course.
Let's run this code and you got it.
Can you see that we got 58 and 69.
So now if you want to print the object,
it will not print the address,
it will print the values, right?
Because we are overriding the str.
So if you remove str,
if you run this code, you got an error.
So it is returning a non-string value.
We have to return a string value.
How do we do that?
Because by default, when you say print,
you want to print a string, right?
So what you will do is,
you will use a format here.
So you can say curly packets,
curly packets, you're printing two stuff, dot, format.
And inside this format, you can pass this to value.
So what will happen is those curly packets
will be replaced by these values.
So you are returning a string now.
And we have seen that before, right?
So let's run this code and it worked.
You can see it got 58 and 69.
So even if you say print S1, it does work.
You can also print S2 if you want.
And let's run this code.
And you can see we got 69 and 65.
So that's perfect.
So this is how you work with operator overloading, okay?
So point to remember is,
whenever you perform any operator like addition,
subtraction, deletion,
behind this scene, we are calling methods, okay?
So for plus, we use add method,
for minus, we use sub method.
And for star, we use mult method.
In fact, we have a list of methods there.
In the last video, we have talked about operator overloading,
right?
Which simply means you have operator like plus,
minus, or division, or multiplication.
So the operator will remain same,
but the operands will change, right?
The type of parameters we are passing, it will change.
Example, when you say plus,
we are calling the add method, right?
And add method takes different types of parameters
or different types of arguments.
So that is overloading.
So it simply means you have the same method name,
but the arguments are different.
Or maybe the number of arguments
or the type of arguments are different.
In the same way, we have two more types in polymorphism.
One is method overloading and method overriding.
So what it means?
Let's start with the first one,
which is method overloading.
Now languages like Java, C sharp,
or any other oops language,
they have this concept of method overloading,
which is not there in Python.
But what exactly it is?
So it simply means if you have a class,
and in that class if you have, let's say,
two methods with the same name,
but different parameters or arguments,
which is called as method overloading.
Example, let's say if you have student class,
and in student class if you have two methods,
let's say average.
So we have two methods with the same name, average.
One takes two parameters, one takes three parameters.
This is called as method overloading.
But in Python, we don't have this concept.
So we cannot create two methods with the same name.
The next one is method overriding,
which simply means you have two methods
with the same name and same number of parameters
or arguments.
Okay, so that means can we create two methods
with the same name and same parameter in the same class?
Of course not, not in the same class.
But let's say if you have a concept of inheritance,
we have class A and class B,
and both the class have the same method
with the same name, same parameter,
this is called as overriding.
Again, we'll see the impact of that.
Let's start with the method overloading first.
So if you want to achieve method overloading,
what I will do is I will just remove this methods from here.
Just to keep it simple, right?
So we got a init method and it is working perfectly.
Let's remove all the extra stuff from here.
We just want to create one object, not even two.
I want to add two numbers.
So I have to create a method, let's say sum,
and this sum will take two arguments.
We'll say A and B.
So I want to add two values, that's it.
Nothing complex, I want to add two numbers.
Now if you want to add two numbers,
I will say S is equal to A plus B,
and at the end, we'll return S.
That's what we want to do here.
We just want to return the value of S, okay?
And if you want to work with that, you will say S1.
In fact, you will print the value, you will say S1 dot sum,
and you want to add two numbers here.
I will say five and nine.
And let's see if it is working.
Let's run this code and it works.
You can see we got 14.
So yes, we can create a method in setup class
which takes two parameters
and we can pass two parameters, it works.
What if, if you want to pass three values,
you want to pass five, nine, and six.
Now this is not possible, right?
The moment you run this code, you will get an error
because you are passing three parameters
or you're passing three arguments
and you're accepting only two.
So this will not work.
That means you need to create another method called a sum
which will take three arguments.
That's what we do in other languages.
But here we'll not do that.
Here what you can do is you can also use third variable.
You will say C, you got A, B, and C,
and you will simply say A plus B plus C, right?
So this will work.
So if I run this code and you can see you got 20
and this is right, you will get 20.
So we are passing three arguments
and we are accepting three arguments, it will work.
But what if I'm not passing third argument,
I'm passing only two arguments?
And now the problem starts, right?
Because you are expected to pass the third argument as well.
How do we solve this?
To solve this thing, we can use a concept
where you will say A is equal to none.
So this is one option.
The other option, we can use the variable length arguments.
If you remember, we have done that before,
the star and variable name.
But this is another option.
You can say all the values are by default none,
which means even if you don't pass the value,
this is default arguments, right?
So even if you don't pass the value,
the default value will be none.
So that means even if you don't pass any value,
example, even if you don't pass five and nine, it will work.
All the values will become none.
I want to pass some values, I will say five comma nine.
I'm passing with two values, right?
Let's start with third one.
Let's say I want to pass three values, five comma nine comma six.
All these values will be assigned to A, B, and C, respectively.
So if I will go to A, nine will go to B, and six will go to C.
So these values will be replaced by none.
So none will be replaced by these values.
So now, once I know this, so we can simply add it.
But what if you're passing two?
So in this case, you will check.
So before adding, you will check.
You will check if A is not equal to none, B is not equal to none,
and C is not equal to none.
So if none of them are none, that simply means you're passing three arguments, right?
And if you're passing three arguments, this is the calculation we have to go for.
You will say S is equal to A plus B plus C.
And you want to declare S outside so that you can use it from anywhere.
So you will say S is by default zero, and you've got this.
Otherwise, if let's say if I'm passing only two arguments,
I'm not passing the third argument, in that case, it will go to LF.
And inside LF, I will check, I forgot a colon here.
So inside LF, I will check if A is not equal to none.
So I'm concerned about A and B.
If they are not none, in that case, I will say S is equal to A plus B,
because we're not concerned about C, right?
And then we can go for one more condition.
What if you pass only one parameter or one argument?
In that case, you will say else, and you will say S equal to A.
So when you say only one parameter, let's say if I'm not passing nine and six,
I'm passing only five, so it will return five, right?
That's what we want.
So we can do that.
Else part is not required here, but just to make it more effective.
We can pass one argument, we can pass two arguments, we can pass three arguments.
That's perfect.
Let's run this code, and it worked.
You can see we got 20.
Now, if I pass only five and nine, even this will work because if you pass only
five and nine, C will get none, and it will execute LF, and you can see we got 14.
Now, if you pass only one value, let's say five, in this case,
if you run this code, you got five, right?
That's how it works.
So this is your method overloading.
So we are overloading methods.
But then we are not doing directly because it doesn't support in Python.
So we are doing some trick.
The next one is method overriding.
So let's go with that.
Let me just remove this code.
And let's once again take a simple example.
And this time we'll go for A and B.
I love these classes.
So what I will do is, let's say we have a class A, OK?
And in this class A, we have a function.
I will say function name is, or the method name is show.
And in this method, I will simply print in a show.
Now, first of all, before going ahead, this concept is method overriding.
This is very famous in software industry, you know?
So in future videos, we'll also talk about this thing.
When we talk about interfaces and abstract classes,
this concept is used very heavily, OK?
So make sure that you understand this concept properly.
Maybe with simple example like A and B.
But understanding the concept is important here.
We can go with complex example as well.
Concept is important.
So let's say we got class A, which has a method which is show.
And we are printing in a show.
That's it.
Nothing fancy.
Now, if I create an object of A here.
So if I go back and if I say A1 is equal to A,
so we are creating object of A, right?
And with the help of this, we can call show.
If you have this code, you can see we got in A show.
That perfectly worked.
Now, what if you create another class?
Let's say class B, OK?
And now imagine this class A is a parent and class B is a child.
Example, let's say this is my dad and this is me.
So we have B here.
And time in, I'm not writing anything here.
We say pass.
I just want to keep it empty.
OK, so we are keeping it empty.
And let me create object of B, not A, but let me get object of B.
And let's run this code.
And you can see we got an error.
It says B object has no attribute as show.
Of course, in B, we don't have anything.
At this point, you will use a concept of inheritance.
And you will say, hey, B inherits A. So when you say B inherits A,
it means you will get all the features of A to B.
And let's run this code.
And you can see we got in A show.
Because of course, in B, we don't have show.
The moment you run this code, it will first
search for the method show inside B.
Now, since we don't have that, it will go to A to search it.
And that's how it works.
So before going ahead, let me tell you one story.
A small story.
I've used this story in multiple examples
when I was teaching Java as well.
So the concept is, when I was in my 11th standard,
when I've just joined my college, I was not having any phone.
So a lot of people used to ask me, which phone you have.
So I used to say, I don't have any phone.
Because I was not having a phone.
But then this question got repeated multiple times.
Then I realized, OK, I have to say something.
Now, at that point, my father was
having a phone which is Nokia double one, double zero.
I was not having any phone.
So whenever someone used to ask me, which phone you have,
I used to say, I got Nokia double one, double zero.
I don't have a phone.
But my father says a phone.
So father's phone is my phone.
That's how I think it works.
So since B and B, my father is A. So B in hates A.
So I got all the features.
In this case, show is in A. In B, we don't have show.
After some time, after a few months, I got a new phone.
And that is Motorola phone.
So my father has a Nokia phone, and I got Motorola phone.
Now, if you ask me which phone I have, of course,
I would say Motorola, right?
I would not say Nokia, right?
Because my phone overwrites my father's phone.
That's what happened here.
The moment you create a show method inside B as well,
and if you try to print in B show.
Because when we were not having show inside B,
it was going to A. Now, since we have show inside B,
it will print the show of B, right?
So if you ask me which phone I have now,
so I will say Motorola, not Nokia, right?
So my phone overwrites my father's phone in the same way.
This show overwrites the earlier show method.
So this is how you work with method overriding.
Again, we'll be doing this concept more in the next tutorials
when we talked about abstract classes or interfaces.
But this is awesome, right?
Remember this point, when you call show,
it will call the show method of this subclass
if you have it, okay?
So that's it, everyone.
I hope you enjoyed this session.
Let me know in the comment section
and do subscribe for the videos.
