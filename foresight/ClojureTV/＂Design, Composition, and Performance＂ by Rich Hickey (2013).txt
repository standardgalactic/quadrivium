Thanks for having me. It's nice to see everybody here, bright-eyed, after a night of heavy thinking.
This is the obligatory legal disclaimer.
Okay, so we're going to talk about design.
And of course, as you all know by now, I don't actually write talks, I just look up stuff in the dictionary.
So I looked it up in the dictionary, I saw this great definition.
Prepare the plans for a work to be executed, especially to plan the form and the structure of that thing.
So there's a lot of really interesting stuff in this definition.
The fact that there's a plan, the fact that upon having the plan, something's going to be done,
and the plan's going to be executed, and that it's about form and structure.
It's really good.
There are other definitions there, one of which is this.
There's nothing wrong with this definition.
This is not what I'm talking about today.
We're not talking about how things look.
At no point today when I say design, am I using this meaning of the word design?
And the root goes back to designare, which means to mark out.
And it's also a very interesting thing.
It has to do sort of with writing, but also with sort of demarcating, right, to designate or to sort of set something aside.
But, you know, most simply we can just say it's about making plans and also writing them down.
Unfortunately, I think that, you know, with all our effort to become agile,
we're letting design become less of what we do.
And so there are a lot of butts when people say, oh, design, you know, it's like, you know, we already write down code.
Do we need to write down design?
You know, do we still need to do designs?
Obviously, it makes sense that if you're going to build a house, right, you can't just say, let's just go build the house.
You have to write something down so that somebody can go build the house,
because the realization of the plan has a different form than the plan, right?
The plan is something written down, but the realization is made of wood and nails and things like that.
But code's already written down, so we have something to read.
You know, do we still need designs?
Or can we just generate them?
Can we just write our program and then generate some documentation from the implementation?
And the answer is no, that's not a plan.
It would be something written down, but it's not a plan.
The other argument you get against design is, oh my god, you know, I lived in the 80s and design stunk.
You know, there were people who thought they could just do everything.
It was all top-down monolithic designs, these giant plans, etched in phone books that never came true.
And it's true that those were plans, but those are not good plans.
That doesn't mean planning is bad, it means that that style of planning is not good.
So what do we mean when we say, what do I mean, when I say good design?
I think one of the most interesting things about design is that people think it's generating this intricate plan.
But designing is not that.
Designing is fundamentally about taking things apart.
It's about taking things apart in such a way that they can be put back together.
If that makes sense.
So separating things into things that can be composed.
That's what design is.
If you just make this intricate thing, you really haven't designed in a way that's going to support the things designs need to support, like change.
Every component of a design should be kind of about one or very few things.
Sort of the nature of it, breaking things down until they're nearly atomic.
And only then do you take those things that you've broken apart and compose them to solve the problem you set out to solve.
But the first job is to take things apart in such a way that you can do that.
And a good design process is iterative.
This isn't a grand plan you do once and then you go and finish.
Obviously there are some kinds of design that you do have to sort of etch in stone because you're going to build a fabrication plant and have few options later.
But in software we know the materials we're working with are so malleable we can get some cycles back to iterate.
So when I say taking things apart, what kinds of things can we take apart?
We can take apart all the things in this list and I'm going to break them down one by one.
So what does it mean to take apart requirements?
This is actually quite important.
Obviously there's a job, another job, also sort of gone wanting these days called analysts.
There used to be analysts and designers and this whole waterfall model.
But there are requirements and usually we get these now directly from customers.
And they often take the form of I want this, I need that, I want, I want, I need, I want, I want.
And the first job we have to do is decompose those wants and needs into problems because obviously underneath all those wants and needs are some problems the customer wants to solve.
And understanding those problems is the key to designing something that solves the problems because oftentimes the design that solves the problems is not what the customer said they wanted or needed.
We separate requirements into knowns and unknowns.
We know how to do some part of this job and we don't know how to do this other part.
That's quite important.
There are problems, now again we're dealing with problems, we're very sorted things.
So there are problems that are on the domain side, possibly some domain expert's going to need to help us solve them.
And other problems that are on the solution side, how will it scale, where will we run it, how much will it cost to operate, how much energy will it use, things like that.
The other thing that we have to take apart are the difference between causes and symptoms.
So sometimes a customer will say I have this problem.
The problem is my screen is black.
And that's not actually the problem.
You know that's not the problem.
The problem is that's a symptom of a problem and the problem is somewhere underneath it.
So another thing you have to do when you're taking things apart is take apart causes and root causes from symptoms.
Because you want to get to causes because the thing your design needs to address are the causes of problems, not the symptoms.
Of course you could just throw up a JPEG over that black screen and you'd be like, it's fixed.
The other requirements are the unstated requirements which are always present.
They're problems that nobody wants to have in the future.
Like I don't want this system to be something I can't maintain.
I don't want it to run out of memory.
I don't want it to run really slowly.
They often don't even say that these are problems because they're just problems, they're future problems they don't want to have.
But they end up being part of the requirements set.
Other things we can take apart.
We can take apart time and order and flow.
The use of cues, the use of item potency, commutation and transactions are all ways in which we can separate apart when things happen.
And often these are the paths to separating apart who does these things.
And these terms become more and more important.
You see them more and more in systems level design.
Communitivity is going to become a huge thing for us to be thinking about.
And then there are times when we really need to know that a bunch of things are going to happen together.
And transactions help keep things separate by keeping things that are supposed to be together.
We take apart places and participants where things are going to happen and what components or processes are going to do them.
This is a classic quote, just add some indirection.
And there is a lot of that.
A lot of design is just putting in appropriate levels of indirection.
But this kind of indirection happens at all levels.
For instance, part of a design incorporates how it's going to be built.
Is it possible for more than one person or more than one team or people working in more than one language to build this system all together?
Or does everybody have to work in the same space at the same time with the same tool?
Then your process for building it isn't going to scale because you haven't taken that apart.
It's another kind of thing you take apart.
This next one I think is really super critical and I think we don't understand it or think about it enough in our software.
Which is the difference between the information our systems is going to manipulate and the mechanisms by which we're going to manipulate it.
To just talk about it simply here, we'll say the set of logged in users in my system is an idea and it will be information that my system is going to need to manage.
But if I have a set class or some sort of set construct in my programming language, that's a mechanism by which I might achieve representing that information.
But unfortunately, because we only have our programming language and our programming language constructs to represent both these things,
we often conflate things that might be appropriate as mechanisms as being appropriate for information and they are desperately not so.
So we have a lot, especially in an object oriented language, you have a lot of very mechanical kinds of classes.
And when you use them to represent information, like for instance any kind of mutable information object,
it's an absolutely atrocious idea. It's really, really bad.
And it comes out of the fact that we're not separating these two things when we're doing our designs.
Finally, after we've gotten something we think might be an answer, we need to take that apart.
So I have maybe one or more possible designs that I think address the problems that I'm trying to take on.
At this point, I have to look at each of those solutions and take them apart from a bunch of perspectives.
What benefits do they provide?
Yes, I think we have no problem with that. Everybody looks at a library, the library is like, it does this, it does that.
You know, it's a floor wax, it's a dessert topping.
You know, it's all benefits. It's all benefits. It's very rare that you see somebody say,
and here's the trade-offs of using this. Here's what's not good about it.
Here's where I decided to do X and I'm not going to be able to do Y.
And being honest about that to ourselves about our own designs is really important.
We all just communicate to stakeholders, right? You are going to get this and you are not going to get that, okay?
There's nothing wrong with that. We have to see what the costs are.
And the other thing we have to do is determine problem fit.
Sometimes you can take on this big solution, you know, part of which solves your problem,
but you've taken on this big thing, you know, and only part of it really addresses your problem.
Do you want that whole big thing? Is it really a fit?
Is there a smaller solution or answer that's a closer fit?
Because both may solve the problem. You're going to have a set of choices here.
So I think design is really important. I mean, that's what I do and I know a lot of other people do it.
But I think it's important to enumerate why it's good to spend time on this.
A design helps you understand a system, right?
Without a design, you're sort of flailing around wondering, why is this this way?
A design helps us coordinate. That becomes obvious as you get into, you know, having teams.
You can't build two things and never have talked to each other.
If you don't have an agreed upon plan written down somewhere,
it's unlikely that your two things are going to plug in together and work.
You know, it's like finding a napkin, you know, what we wrote it on.
Design helps extension, right?
To the extent that you've broken things into separate parts with an eye towards connecting them back together,
it means that your resulting design is going to have connection points.
And when you want your system to do something new, it will be possible to do it because there's something there.
That's why design is not just about, you know, accreting up to an answer.
Because when you do that, you don't end up with any connecting points.
You don't end up with any building blocks and you can't really extend that thing.
Similarly, the flip side of that is to the extent you've broken your problem down into reusable parts and compose them,
those parts may be separable from your design and useful in another context, right?
And that's how we get reuse.
Reuse comes from design.
It doesn't come from language constructs or anything like that.
Of course, everyone does design driven testing, right?
Because that's the right kind of testing.
If you have designs and they specify things well and you have some automated way to go from that specification to a test,
that's good testing.
Everything else is backwards.
And the last thing I think, one of the main reasons people say,
I can't do design is I don't have time.
I don't have time to do design.
But I will make the argument that design is the key to more efficiency
because it's a lot easier to iterate a design than it is to iterate a solution or an implementation.
And even after you've got an implementation, right?
Because I said it's iterative, so you're going to have some form of iteration.
After you've done this kind of design and you're iterating and you need to do more design,
that design often takes the form of, ah, you know what, this part of the system,
I actually didn't break down enough.
I need to break it down more.
I need to take this thing and split it in half.
And that's what I find most often.
When I have more to do in an iterative design process,
it's almost always because I look at something and say, ah, that's still doing more than one thing.
I just need to cut it in half.
And it ends up that that kind of further decomposition is really easy to integrate
in an ongoing process in further development.
So it is possible to do iterative design,
especially when you think about design as taking things apart.
You can always take something more apart.
It's great.
Okay, so this talk is going to be about design, composition, and performance.
And I know, you know, when you think about composition and performance,
you think about bar talk and culturing.
I know I do.
So this is the great thing about the dictionary,
is that, you know, there's the first definition,
and then there's, like, more definition.
And so there are more definitions, obviously,
and more notions of the word composition and performance.
And this is near and dear to me because, as the intro said,
this is my background.
How many people don't know who bar talk or culturing are?
It's okay if you don't.
So bar talk was a Hungarian composer who sort of bridged
the Romantic era and the modern era.
And a phenomenal composer who had a great interest in the folk music of Hungary
and really advanced, I think, still to this day,
modern composition in very interesting ways.
And John Coltrane, and by the way, was also a pianist and performer,
and teacher of piano.
John Coltrane is, you know, possibly one of the best improvisers
humanity has ever produced.
A fantastic saxophone player, played fundamentally, you know,
mostly tenor and here soprano sax.
He was also a composer and wrote very interesting tunes
and advanced jazz harmony in those tunes.
But he's going to play the role of performer today.
So we have bar talk, the composer, and Coltrane, the performer.
So when we talk about composition, and in particular music composition,
you know, what are we talking about?
Now we're into the arts, right?
And it's quite interesting, right?
Because the arts usually are not about solving real-world problems at all.
But if you look at any of the art forms,
where there's somebody like a composer,
it could be a choreographer or anything like that,
the first thing these people do, they have blank slate.
They have like blank staff of music, blank page, empty stage.
The first thing they do is they make problems for themselves.
They set up a set of constraints,
under which they're going to form an artistic work.
It's quite interesting that they create their own problems to solve.
From there, and this happens again for all these different forms,
and from there they now have a design problem.
They're like, oh great, I just made myself a design problem,
now I can go and design.
Now I can go try to solve this problem,
solve those constraints I've set up for myself,
and make a plan, which will be realized by performers.
So when we look at music composition,
it's quite interesting that there's a variety of specificity
and scale to the designs that are created.
Often you'll see fully orchestrated pieces,
so classical music is typically this way,
where every note that's going to be played by every instrument is specified in a score.
What's particularly interesting, I think, about music composition here,
is that this specificity is much more common, the larger the scale.
They're taking on bigger problems,
and the bigger the problem they take on, the more they specify.
It's kind of unusual, I think.
The other kinds of compositions you see are like songs.
We'll take the lyrics out of the picture and just say melody and changes.
And here, you're giving the suggestion of what the piece is going to be,
but the specifics are left out.
This kind of design just says, here's the melody, here's the harmony,
and everything else is going to be left to the performers.
They have a lot more latitude, and with that a lot more responsibility.
I think one of the things that's interesting is that software straddles these two worlds.
We tend, when we're working on the smallest part of the system,
to have the most specificity in our designs,
and we're working at the largest scale in our systems,
we have the least specificity.
But I think that one of the things that programmers are afraid of
are these large-scale designs that are going to completely tell them what to do.
They're like, don't repress me, man, I don't want to see this.
And certainly, that was well-founded.
In the 80s, people thought people would make pictures and push buttons
and get COBOL to come out.
And that would be what software was going to become.
So programmers were legitimately skeptical, if not afraid of that.
So here we have two examples of what I'm talking about.
The piece on the left is a segment of Bartok's Concerto for Orchestra.
You can't see the details, but there's all the woodwind parts
and the percussion and the string parts all completely specified.
The phrasing, the tempo,
everything is completely notated.
Although not totally completely, because you see this has been written on,
and it's been written on by the one person who has some latitude in this kind of an approach,
which is the conductor.
And of course, the conductor struggled with some things that might not have been said,
like they have to translate the Italian tempo markings into actual beats per minute.
And there's lots of contention about how to do that.
On the right, we have a completely different kind of composition.
This is my favorite things.
It's Richard Rogers from Sound of Music.
That's a very pretty song, but you can see here just roughly that very little is specified.
There's a melody and then some chord changes.
And John Coltrane quite famously did a rendition of this piece,
which is absolutely gorgeous, and if you've never heard it,
you need to hear it before you die, because it's great, really, really great.
But you see the difference in how much is specified.
So we've talked a little bit about constraints already in design,
and again, it's the same kind of thing happens here in music composition.
Most compositions are about something, and this is true also.
Most dances are about something, and most plays are about something,
and most screenplays are about something, or a few things.
So this problem that the composers and artists set aside for themselves are normally pretty simple.
They try to focus on one or a few ideas, and in music that would be melodic or timbral or rhythmic kinds of ideas.
And they're going to take this fundamental idea and work it out, resolve it,
try to see what it's about, try to explore what it means.
And when you get to larger scales, like when Bartok does these larger compositions,
you end up with this set of constraints at each level.
The larger works just have more structural components, but they're very stratified.
So he has all kinds of techniques for dealing with harmony in the small and form in the large.
On the flip side now, we have the performer's space improvisation,
and the route there takes us to not foreseen or not provided.
So it hasn't all been written down in advance.
It's not completely specified.
There's this melody and these changes, and they provide constraints for a performer
who has to provide the variations on the fly.
The thing I think that's really important here is some people think that improvisation is some genius just spontaneously emoting.
It is not that. It is not the way it works.
The best improvisers practice the most,
and John Coltrane is a great example of somebody who practiced an amazing amount of time
and studied quite extensively.
And what you end up hearing when you hear an improvisation is an application of a lot of knowledge
and a tremendous amount of vocabulary.
It's almost like dynamic composition that's happening in these improvisations.
And you can tell, like now there are a lot of releases that include the outtakes.
So you go and you listen to this thing, and you listen to the first track,
and it's like, I've been listening to this for years.
It was amazing he came up with this.
And you listen to the outtakes, and there's like five takes with very, very similar solos.
I mean, Coltrane was working out this composition he was going to perform dynamically,
but the resources behind it were things that he had prepared.
He didn't just make it up as he went along.
So it's this delicate balance of being able to be dynamic,
but having compositional sensibilities to apply on the fly.
That's what developers need.
So there's another great term in this space called harmony,
and the dictionary definition says a chord, a congruity,
and that makes sense, the degree to which things fit together.
Specifically in music, we get this notion of simultaneity.
So melody is about sequentiality, and harmony is about simultaneity.
When things are sounding at the same time,
whether it's an instrument that can play a chord or an ensemble,
where all the instruments playing at the same time yields a combination of tones.
There's another notion of harmony, which is sort of the rulebook.
There's a mathematics to harmony, which is sort of something you could study.
It's an art or a science. I don't know, you could have that argument later.
But there is this sort of system.
There are systems about how things fit together that you could study.
And I will argue here that harmonic sensibility is of critical design skill.
This is really what you need to acquire if you want to make systems that are going to work.
So I like Bartok and Coltrane as examples, because both of them were masters of harmony.
And by this, I don't mean they were masters of the rulebook.
They were masters of the notion of harmony.
And in fact, both of them were students of harmoniousness.
If you look at their careers and what they did, Bartok came from a romantic tradition
and was aware of a lot of intellectual exercises going on in composition to try to modernize it,
break free of the old rules of diatonic harmony, and go to new rules.
We're going to get rid of those constraints and just have different constraints.
And he sort of never really went there with serialism.
He stuck with essentially tonal systems, but he went beyond the rules.
He tried to figure out what exactly worked and didn't work.
And he explored, for instance, this Hungarian folk music, which was tonal,
but didn't follow the classical rulebook because it was folk.
It wasn't academic.
And similarly, you see Coltrane doing the exact same thing.
On giant steps, there's this famous reharmonization system that he developed
that really broke the rules of the day, but were fundamentally about retaining
what worked about harmony and finding new ways to figure out things that worked together.
So they both essentially developed new systems while retaining a focus on what fits together.
And I think that artistically, they're just tremendous artists
because there was a lot of intellectual effort.
If you look at the insides of some of what Coltrane is doing,
it just seems like the most emotional thing, but there's a tremendous amount of intellectual stuff going on there.
It's the same thing with Bartok.
You can listen to some piece that will make you cry, and then you go and you look at the score,
and it's full of Fibonacci ratios.
It's like, oh my God, that's really cool.
All right, so what does this have to do with anything that we do?
Closure, programming languages, tools, or anything like that.
Is closure like a song?
Is it like a symphony?
Is it like these things?
Are languages like these things?
What are they like if we're going to play the like game?
They're like instruments.
So let's look at instruments.
This is one I'm particularly fond of.
I happen to have one that's just like this.
Instruments are particularly interesting.
Instruments start with something called an excitation.
Again, we see the same notion.
Most instruments are about one thing.
Whether you're going to pluck a string, cause a reed to vibrate, whack on a string, whack on a drum skin.
There's this fundamental excitation, and the rest of the instrument is completely about it.
It's about shaping it and conveying it.
Then any particular instrument is going to provide some sort of human control interface.
These are all interfaces.
They're really good interfaces.
You should study them.
They're very interesting.
Whether it's keys on the piano or on the saxophone, frets on a guitar, and pedals on a piano.
All instruments have these things.
Most of them at least fundamentally address pitch and also volume, but they can do other things as well.
So this is where the performer can exercise control.
Then the rest of the instrument is oriented towards projecting this excitation.
So there's an excitation that you get to shape, and the rest of the instrument is about directing the energy at a particular outcome.
Usually it's about directing the sound at the audience.
But when you try to extract the ideas out of this, there's a fundamental idea, and the rest of the instrument is about directing it at a good outcome.
There's another interesting aspect of instruments, which is that while there is this initial excitation,
once you get an instrument in play, once you get this body that has some air inside of it, it has its own modes of vibration.
So it will tend to vibrate at certain frequencies, and that's known as the resonance of an instrument.
And this is sort of the harmony of the physics of instruments.
A good instrument designer is going to try to make an instrument whose fundamental resonances are compatible with the excitation.
So again, the harmony sort of comes into play.
When we look at instruments, we see that they're incredibly limited.
The piano can't even play any in-between notes, so it only plays exactly the notes to which the keys correspond.
And a saxophone can't play more than one note at a time, except with some advanced techniques.
And even then, it can't play arbitrary pairs of notes at a time.
Most instruments are minimal, yet in some way sufficient.
So an instrument may have a limited range, but if it's an instrument designed for western music within that range, it probably has all the notes.
But there may be other things that are limits, like certain transitions between notes or registers might be awkward or impossible.
But there are instruments that don't comply, like a blues harmonica doesn't have all the notes. It has only one key at a time.
And that's a little bit like our DSLs.
The thing is that players overcome these things. How many people here play piano?
So how do you overcome the fact that there are no in-between notes? What do you do?
Trills and grace notes and things like that are all techniques piano players and piano composers use to deal with the fact that there's no in-between notes.
Coltrane, quite famously, because he had such dexterity and speed on the saxophone, had this technique that was coined, the sheets of sound,
where he could play scales so fast that he could give you the effect as if there was harmony, even though he could only really play one note at a time.
So they can fix this stuff by performance.
Because otherwise what are we going to do? We're going to submit a patch for pianos? Let's fix that nasty one note at a time, no in-between notes problem.
So why don't we do this? Why haven't all these things been fixed? Why hasn't the saxophone been fixed to play more than one note?
And the reason is that no one wants to play a choose-a-phone. No one wants to be a choose-a-phone player.
Alright, some people do want to be a choose-a-phone. Let me say this then, no one wants to compose for choose-a-phone.
Let's imagine you had an orchestra where everyone was sitting in front of one of these. This is a modular synthesizer if you don't know.
It's an electronic instrument where you patch together modules that are either tone generators or filters or things like that.
And eventually you can control it with a keyboard or some other sort of source.
But what happens if you try to compose where the bass units are things like this?
Well you have this problem, right? Your fundamental target is complex. Each subcomponent you're trying to reuse is really complex.
You also have this nested design problem. As a composer, composers study the instruments, they study flute,
and they learn what the range is and what transitions are good and what transitions are bad, what's hard and what's easy.
And they learn that for the entire orchestra, and they can look at a flute or think about a flute and know,
I know what flute is about and what it can do, and therefore I can use that knowledge to build something that uses flute and violin and whatever
and make something that works together. But if each piece is complex, then you end up with this nested design problem.
You can't look at one of these things and know what it's going to sound like when you press the key.
And it may do something completely different tomorrow. And if you were wondering what would happen if you pulled out one of the wires,
that's a good question. It's totally fair. So it's hard to build things out of things like this.
Other interesting things about instruments. Instruments are made for people who can play them.
Isn't that outrageous? Isn't that scandalous?
They're made for people who can actually play them. And that's a problem, right? Because beginners can't play.
They're not yet players. They don't know how to do it. Again, I think there should be outrage on the internet.
We should submit patches. We should fix the cello. Should cellos auto-tune?
Or maybe they should have red and green lights. It's green when you're in tune and it's red when you're not in tune.
Or maybe they shouldn't make any sound at all until you get it right. Is that how it works? Is that what we want?
No, that's not how it works. Look at these kids. They're being subjected to cellos. There's nothing helping them here.
Although apparently their shoes have been taken away until they get it right.
But otherwise, they're smaller, but those are real cellos. They're hard to play. They're awkward. They sound terrible.
They're going to be out of tune. It's going to be tough for a while for these kids.
But if they had any of those kinds of aids, they would never actually learn to play cello.
They'd never learn to hear themselves and to tune themselves and to listen.
Playing a cello is about being able to hear more than anything else. That's true of most instruments.
We need players. Here's where I would rant. I'm not going to rant.
I'm going to rant a little bit. As a simple example, here's a guitar player, a harp player, a double bass player, all holding up their blisters.
Imagine if you downloaded a library off the internet and it gave you blisters.
The horror. Yet every musician has overcome a barrier to entry similar to this.
The thing we have to remember is that humans are incredibly capable. In particular, we are really, really good learners.
We've just evolved to learn. That's what we do. The other thing we're really good at is teaching.
The thing is that neither of these things are effort-free. They take time. They take effort.
We should not sell humanity short by trying to solve the problem of beginners in our stuff.
We need to make things for people to use and we need to teach people and trust people to be able to learn how to do that.
Fundamentally, we are novices and the thing is we're only absolute beginners for a very short period of time.
On the flip side, we're beginners forever. We never totally get it. We're going to be learning on an ongoing basis.
This is just the human condition. This is not something to be fixed. It's not something to submit a patch for. This is how it works.
Effort is not a bad thing. These are two guys who are experts and yet they're still trying. This is not autocomplete.
Just as we shouldn't target beginners in our designs, nor should we try to eliminate all effort.
It's an anti-pattern. It's not going to yield a good instrument. It's okay for there to be effort.
Another interesting thing about instruments is that they're usually for one user. This is a tool meant for two people to use at the same time.
That's extremely rare for tools or instruments to be for more than one person to play at the same time.
And yet we have these complicated T-mux, whatever things that people pair at.
I don't really want to despair because while I personally don't understand it, I can see analogies, for instance, rather than two musicians at the same instrument to two musicians playing in the same room.
And that obviously has good effects. But you have to wonder, is this just a way to keep somebody from typing all the time?
If we haven't otherwise built in time for design, is pairing one way that we're trying to buy it? It's a fair question.
So what should the ratio be between planning and performance? What's the ratio of time spent practicing and studying versus performing and recording?
For musicians, how many people here are musicians who play an instrument? It's usually pretty high amongst people in the software world.
Do you spend more time practicing or on stage? Definitely practicing.
If you're hired to perform in an orchestra, they don't even book you for even half of your time to actually sit in the orchestra.
They know you're going to have to spend time shedding.
I don't know why, as software developers, we think we can just show up. How many people here dedicate 50% or more of their time to not programming?
Not too many. Everybody else practices.
Obviously, we went to school and studied whatever we studied, but musicians are not like, well, I went to school, so now I don't need to practice anymore.
I'm just going to go and show up at the orchestra and they're going to let me play because I showed up.
This is a great quote. You have to prepare to be creative and you have to keep preparing to be creative, or else it's not going to happen.
You can't just show up and play. But I know there's going to be complaints.
We're in a whole different space. Culturing couldn't build a website in a day.
I don't know why this has become so important to us. It's really a stupid thing to be important, especially to an entire industry.
I'm not really going to spend a lot of time on that, but it is a fair question to say, in what ways is this different?
In software, we seem to have all these ones and zeros and so many ways to put them together.
It's not as simple as making an instrument. It's not wood and metal. We just have this sort of infinite nature to our resources.
How does that impact the difference in how design works? Well, I just have to show this.
Obviously, as soon as we had the ability to make sound by using electricity, so having electricity drive a speaker and have the speaker vibrate and have sound come through the room.
The initial applications where we recorded sound with microphones somehow captured it or transferred it live, and then the wire hit a speaker and then it came out on the other side.
But as soon as that capability was there, people started imagining, well, could we just take out that first part and directly generate some electricity that would sound good when it comes out the speaker?
From that was born electronic music and music synthesis.
The theremin is one of the earliest synthesizers. It's from, I think, the 20s. It's quite interesting. It has extremely simplistic sound generation capabilities.
There's a little oscillator in there and something that changes the waveform very slightly.
The way you play a theremin is that those two things, those two pieces of metal, are antenna. The vertical one is controls pitch.
The closer you get to the antenna, the higher the pitch. The further away you get, the lower the pitch.
The loop antenna controls the volume. The closer you get to the antenna, the lower the volume. The further away, the higher the volume.
You play theremin by moving your hand through the air. You do not touch it. It's an extremely simple instrument.
But over the years, more and more sophisticated electronic music instruments came about.
Those modular synthesizers I showed before are built out of modules.
And again, now we're starting to see the same kinds of things we see in software. Modularity, right? There's modules. Each module is about something, right?
So there's an oscillator there and a filter. And they have interfaces. They connect together. And it's quite stunning.
This is pre-digital. So the way these things communicate is through control voltage, completely analog.
Just dynamic voltage variations are what connect them together. And you patch voltage from connector to connector and you build systems.
But of course, we also start to see the levels, right? If you look at the back of one of these modules, there's another piece of design there.
There's the circuit. And these are analog circuits that determine what the module does.
The other thing that's interesting, and it's a little bit hard to see from this diagram, is that each of these knobs has a corresponding jack.
In other words, there's a human interface and a machine interface to the same things.
And the machine interfaces were there all the time. In fact, they were first. And then the human interfaces come.
We have to remember that as design thing, right? What's wrong with SQL?
What's wrong with SQL is there's no machine interface to SQL. They only designed a human interface to SQL.
And we've suffered ever since, right? Because we have to send these strings around.
So you always have a machine. You can always build a human interface on top of a machine interface, but the other is often disgusting.
All right. So now we see the things that we start to see in programming, right?
There's this whole design stack. This guy, Yves Usan, he's amazing. I think he's like a biochemist or something.
And in his spare time, he's a C++ programmer. And in his other spare time, he actually makes these modules.
So he designs and builds analog modules. And then, of course, he builds synthesizers.
And then he builds sounds with those synthesizers by patching things together.
And hopefully, sometimes, he gets to play that little keyboard there and actually make music.
But there's this entire stack of design. The design of the modules, the assembly of the modules into a rack thing.
So this is your choices. Then the patching, which is designing the sound that the module is going to make.
And finally, maybe some music later. So it's interesting to see when that stuff gets captured.
So this guy happened to help this company make this synthesizer, which incorporates several of those kinds of modules inside,
but doesn't have any wires on the surface. So a bunch of decisions have been made about how the modules will connect together.
The oscillator will fill the filter and the envelope generator will control this.
And those things were all already decided. This same guy made those decisions.
And they were captured in this device that's now a lot closer to the programmer.
In fact, you don't see the machine interface at all. There's only the human interface.
And it's more like an instrument that you could just turn on and play.
Of course, you still have to do some sound design on the top.
The important thing to know is that as you start looking at things with these design stacks, you really have to pay attention to where you are in the stack.
When this guy is soldering together one of these modules, he's not making music that day.
He's not. And this is the problem we have.
Our problem is this is what somebody feels like. This is what somebody feels like when you say you should use Emacs.
They feel like they want to make music and you handed them a soldering iron. That's what you just did.
And why does this happen to us? It happens to us because we use the same stuff all the way down.
For us, it's code at every layer. It's always software.
In this thing, you do something different when you perform. You do something different when you're a sound designer.
You do something different when you assemble modules.
And something different still when you wire things together behind the scene.
But for software developers, we all have soldering irons. We all can jump to the absolute bottom and mess around.
It doesn't actually mean that we're skilled enough to do that.
But it's there and it uses the same stuff and we think, well, I got some solder and some spare time.
I should design a filter.
And I think it yields to a tremendous amount of distraction and also a tremendous amount of expansion.
We change things and enhance things because we can because we're all Luthiers.
I'm glad. It would be cool to know how to build a guitar.
But if I knew how to do that, I'd play less guitar because I'd be fiddling around with wood.
And you need to decide what you want to do.
So there's a sense in which having a lot of choices, which we seem to always seek.
I've got to have choices. Don't repress me, man.
It's the opposite of enabling us to accomplish things.
And in fact, you'll see time and time again people documenting the fact that constraint is actually a driver.
When you have fewer choices, you make them and you get on with it.
When you have a ton of choices, you sit around and wonder about things all day.
So constraint is a driver of creativity. That's not a new thing.
I mean, people have been saying this forever, but this is what they mean. This is where it comes from.
So if I was going to advocate anything, it would be as a community and an industry,
we spend an unbelievable amount of time catering to ourselves.
It's just ridiculous. It really is because we can.
Talking about it, enhancing things, adding stuff.
You know where this goes. It creates these monsters.
And the chances are good that every one of these modules is a good idea.
What's to say it is? Every one of these things is a good idea.
But if you take every one and you just keep accreting them and adding them together,
you end up with something that you can't play.
I mean, I don't care if you could configure this thing with spring, right?
Nobody wants to play this. And in fact, no one can play this.
This one actually plays itself.
It's in a museum somewhere and it spontaneously makes music.
No one sits at it and tries to play it. It just plays itself.
And I'm sure it makes interesting sounds, but I don't think it can play my favorite things.
Because it has no memory. It just makes up stuff.
So I think the thing we need to keep in mind is there are people who can make music
by waving their hands through the air.
They don't need Emacs or anything else.
They don't need a million options or deep class hierarchies or anything else.
Don't start playing this right now. The whole room will be like Derriman, whatever.
But it's really cool to listen to this.
So getting back to the topic, what is design?
I would say on one level design is about imagining things, right?
That doesn't mean like imagining that you have every possible option.
You want to embrace the constraints because you're going to use them.
They're going to help you.
The trick is to not let them get you down, right?
The key thing to design is saying, I have this set of problems.
I have this set of constraints, and I know I can solve that, right?
If you combine the optimism with the constraints, you're going to get designs.
And so you want to imagine a lot.
You want to take these two things and roll with them and try not to like get the first answer,
but try to get a lot of answers and then have them to choose from.
However, the flip side of design is design is about making decisions, right?
After you've got this spectrum of things you think are interesting answers,
maybe you thought of a hundred times as many things as you need to.
You need to admit very little.
You want to mostly say no.
Design is about making decisions, right?
In fact, the value of a design is in conveying those decisions to the next person, right?
When that guy worked on that synthesizer with the company and made those decisions,
it's to help out the next person, the musician that doesn't want to solder, right?
They need to be able to trust the decisions that prior person made
so that they can get on with their level, right?
If you leave every option open and you make everything configurable, you're not designing.
You're failing to design.
You're failing to make decisions and convey them to the next person.
You're not actually helping them, right?
You're giving them a choose a phone, right?
On the performing side, we already saw a little bit of this.
Performing is preparing.
It's practicing, right?
Which we do, right?
We do a lot of coding, so we get a lot of practice in it.
But it's also studying.
And I think the biggest thing in trying to connect performing to developing or coding is this nature, right?
Coltrane was great because he had fantastic design sensibilities that he could apply dynamically, right?
It wasn't all about his fingers.
I mean, he had incredible dexterity.
He did, right?
He had incredible technique and incredible tone that he got from playing a lot.
But what he played was a result of what he studied and the analysis that he did
and the thinking that he had done about how music works.
If he just had the finger speed and everything else, he wouldn't have been the great player that he was.
So, to wrap things up, take things apart.
Take things apart not with a hammer and smashing them, but with an eye towards how you're going to put them back together.
That's what design is about.
You want to design like Bartok.
And by that, I don't mean specifying every note for every player.
I'm not advocating that.
I don't believe that's the way software design is or ever should work.
But to think about the way things fit together at every level, the thing you're working on,
when you're working on large things as he did, you have to bring the design sensibilities to the small things
and to the medium-sized things and to the large things.
And often apply different techniques and different ways of thinking for each level,
you know, ways that are appropriate.
You want to code like Coltrane, right?
Bring that harmonic sensibility, bring that design sensibility to the coding that you do and to the code that you write.
I think most fundamentally we want to seek out and build languages and libraries that are like instruments
in all the ways that I just talked about, in particular in the simplicity aspect.
All those things I showed you were different ways to say instruments are simple in that deep way.
That's what we want.
And finally, to pursue harmony, to actually think about how things fit together,
it's real easy to code right out of a problem and then get an answer.
But if you haven't thought about how things fit together, that answer is not going to be easy to maintain
or easy to change or easy to reuse.
So you have to think about harmony as you go.
And then go do it.
Hope you enjoy the rest of the conference.
Thanks.
