This desert is awesome.
That's how I feel like about doing this topic.
I feel like I feel like the better approach to people who criticize Pearl is to just like
chill and drink my coffee and go, mm-hmm, mm-hmm, mm-hmm, yeah, yeah, yeah, mm-hmm,
Are you done yet? Yep, are you done? Mm-hmm. Oh, right, right, right. Yeah, when was the last time you used Pearl?
Oh, oh, yeah. Oh, did you? What was that? What was that? Regular expression? Did you have trouble with that?
What's a regular expression? Oh, um, how do I put this?
Yeah, what was the language you were using instead that you said you prefer to use?
Oh, do you think that that language is the only language that has regular expressions?
Okay, mm, all right. How much coding in Chinese do you do for Chinese strings that use the Unicode?
Oh, none. Right, okay.
Well, yeah. Well, I'm sure you're going to have a great day. I really am. I'm sure you're going to have a great day.
I got stuff to do, though. So if it's okay with you, I'm going to go up on my camel here and we'll get you done while you're doing whatever you do.
I'm sure it's fun. I couldn't resist. I couldn't resist. I know I'm an old pedantic, grumpy asshole. My Rust video proves it.
I know it. I'm just going to own it. And one of the things that makes me the most annoyed of all is people criticizing Pearl for being a read only language
or writing it and not being able to understand it or not knowing what it's for. Or, oh, that's only a Boomer language.
You know what else is a Boomer language? C. You know what else is Boomer technology? Linux. These are old things.
You still use them every day and you love it. Just because something, you know, has been around a while doesn't mean you throw it out and start using something new.
And that's not just, I'm not just saying it because I'm an old guy. I'm saying it because I recently had a massive sort of come to tech Jesus moment where I just was like, why did I ever throw Pearl out?
Some 12 years ago, 13 years ago, I threw Pearl out on the floor and I said, no, I'm going to do everything in Python from now on because that's what the world is doing.
I didn't bother to ask myself why. I just listened to everybody else and said, well, this is obviously the way to do it. If I want to get a job, I better do it in Python.
So I did invest back when four people were doing Python. I was doing Ruby and I had done Ruby before that. Ruby was awesome. But here's the thing.
We were also writing large applications. We were writing applications that needed the pseudo object orientedness of Python or, you know, the scale of Ruby.
Really, what we needed was go at the time or a language like it that could support the weight of enterprise development without the complexity and just absolute bloat of Java.
And so that's what we needed. So I went ahead and I'm definitely going to accept comments at some point and I'm going to go into the IRC.
There's going to be all kinds of people in here with all kinds of opinions and I love that. But I was particularly grumpy recently.
Not particularly because of any single person. A lot of people took the back end of my wrath on this because it was actually me.
I've done a lot of reflection over the last day. It was actually me coming to terms with the fact that I threw out something which I tend to do that had an application for a specific area.
And that area is a very niche area, but it is a very important area. And so then I came back to it. I actually just discovered all over again that the only prototyping language I should be using for Unicode regular expression matches right now is Perl.
It's the only language on the planet that supports it as far as I know right now. If I'm wrong, put it in the comments and I'll go look it up.
But so here's I just put these these items together here. I don't know, but these are good reasons to use Perl in 2021.
It's 2021 that everybody thinks, oh, my God, we got to get Perl out of there.
The BSC team went to exhaustive effort to remove Perl permanently from the district, which I think was a stupid choice.
The new of him, the new of him team ripped out Perl from inside of it.
You know, it had some internal Perl support from they might get that fucking Perl out of there. We get that out of there.
We can't have that. And everybody's just got this Perl hate F security, which by the way, F security, really, really, you're going to you're going to permanently date your company to,
you know, to an Amazon thing about a guy who struggles with
psychotic problems. That's that's you're going to make a Mr. Elliot reference for your company name.
And then you're going to have the gall to put inside of your job description as a bullet point has a healthy disdain for Perl.
I'll show you those lines of that. You know, all you're really doing is proving how stupid you are.
If you don't understand why Perl is still a very, very viable cybersecurity language, then you don't have any business being in the industry.
Because Python's not going to do what Perl is going to do. And I'm going to tell you all the ways that that's true.
All right. So the first one is regular expressions.
Perl is the industry standard for regular expressions. In fact, your regular expressions use in JavaScript and in go and in and in Python, they're all using PCRE.
In fact, you look at the Python source code, it literally links in live PCRE, which is the exact library created for Perl compatible regular expressions, because Perl set the standard.
Because Larry Wall in the game, they saw, they saw a problem. They said, you know what, Auk ain't doing it, said, Oh, my God, ain't doing it. By the way, which version of Auk or said you have on your system?
Is it Auk or is it N Auk? So Larry Wall fixed a problem. He said, you know what, we need something that's relatively standardized that has the best of all of these things together that fits that space in between shell and C.
And that's what Perl was. That's what it became. And that's all it was ever intended to be. The fact that Perl went on to become the industry standard for back end web development is just a testament to the robustness of this
command line utility scripting language. That's all it was ever intended to be. The fact that he even put up with what it was put under all the weight of the entire worldwide web development was put on Perl's shoulders, which it was never designed to do.
The fact that I was right able to write enterprise software that fell on its face with PHP, by the way, and with Python, those things just did not do it. It didn't do it.
And so Perl was there to do that thing. So stop judging Perl as an enterprise language. It was never meant to be a language. You know what it was meant to do? It was meant to replace said Auk, TR, Cut, and all the other unnecessary sub shells in a way that could take one sub shell and it could be extremely powerful and it could be loaded and it could do things that the other languages don't even dream of doing, like, oh, something as simple as mapping, you know, map, filter, reduce.
Those are all built into Perl. Those concepts were built into Perl before JavaScript was even conceived and they've been there all along. Somebody the other day was saying, you know, I've been looking for a language that's better than Node because it has more, it's like, that's more, you know, powerful on the command line. I don't have to have a Node install Node on everything. I was like, have you even looked at Perl? What's Perl?
So leave it to the old guy to bring this up. And, you know, I was just as much, I even made jokes about it. There's a video, somebody put a comment recently on one of my Go videos and they say I was making a joke about it. You know, this looks like, you know, it's harder to read than Perl.
And I'll be the first to admit that there has been really bad Perl written. There really has been. There's been Perl that's been written that is, you know, just abysmally bad. In fact, there's entire competitions that I'll let you go look up on your own about Perl obfuscation contests.
We're like really super intelligent people, you know, show off their ability to make their code absolutely completely incomprehensible. By the way, that same sort of culture and thinking reminds me a lot of the Rust community today. A lot of the Rust developers, they're very elite, they're very intelligent, and they take pride in writing code that no one can understand.
Well, it sucks to be you. Can we just agree that that attitude in a developer should be like rooted out of any dev shop? If you think you're better because you can write code that no one can understand, you need to be fired on the spot.
I mean, if that sentiment bubbles up at any level in your team, you have to shut that stuff down because it will destroy your team because, you know, they'll think they're elite and they wanted this thing. But let's talk about that for a second. The reason that Perl is considered a read-only language is because it's got completely different design decisions.
The design decisions are, we want to write a very contextual, very implicit, very magical language that is able to write very, very quickly and powerfully in the fewest amount of keystrokes because it's a shell script. It's a shell scripting language, guys.
It has the best command line one-liners for shell that you will ever come across. You might not understand them, but it doesn't matter because they're a single, I'm not reading the comments yet. If you guys are slamming me, I'm going to get my, say my piece and then I'll read what you guys had to say.
So this is an example. So here is a one-liner for Perl right here. It's integrated into my VMRC that will actually go out and it will change any markdown link that doesn't have anything between the parentheses into something that contains a link to DuckDuckO every time I exit my program.
Now, that is a very, very dense, unreadable line. It would take you several minutes to look at it because everything that it's doing, if you were to write it out in Python one step at a time, you would have like 30 lines of code.
So, you know, 20 lines, maybe. You know, the point I'm trying to make is that Perl is deliberately dense and contextual. It's deliberately that way. It's that way so that you can get more done on the command line.
And if you look at a language like AUK, you know, people are like, people, people, this is, this is the craziest thing. I, in 2021, 2020, I continue to read and hear people talk about the praises of said and AUK and how awesome they are.
And then those same people will turn around without having any knowledge of what Perl even does and they will slam on Perl.
They will slam on Perl and they will say, well, Perl is that, oh, blah, blah, blah. Meanwhile, AUK is awesome.
And they have no idea what they're talking about. And it's like, and they'll talk about how great AUK and these big, fancy lines, you know, like if you're going to make a bunch of subchills, do it on a single command line.
And a powerful single command line is an essential skill to have if you're in cybersecurity, if you're doing a lot of system administration.
But most knowledge workers should be able to learn how to use the UNIX command line. That is the true power of the UNIX command line is learning how to use pipes and stuff.
And so if you don't know how to do that, you know, that's on you. It's not on the language.
The language was designed for those people who can level up to the place where they can get a lot done in one line.
And that's why it exists that way. And AUK, by the way, is very contextual as well.
It's very, very contextual. And people will love on AUK while they'll hate on Perl, even though Perl is also contextual and they'll hate on it for the same reason.
The difference is you don't see AUK scripts in files that are running back-end common gateway interface processing to connect to a database.
Perl can do that shit. AUK can't. And it's the same exact language. In fact, it starts up almost faster than AUK.
Not the same speed. Perl is obviously bigger than AUK, but AUK is, you know, instead, people complain all the time about it.
Well, it says, you know, but you should see how fast the runtimes are in Perl these days.
I mean, you just started from the command line. So let's talk about that for a second.
The chances of you getting a consistent version of Perl on a Unix system are equal or better than getting a consistent version of AUK on a system.
In the day, in the 90s, there was an AUK, there was NAUK, AUK, and all of the different AUKs had different forms of regular expressions.
One of the most annoying things that Larry Wall fixed with Perl is he was sick and tired of everybody disagreeing about regular expressions.
Regular expressions are hard enough to learn as it is. I mean, there's wicked difficulty to master as a beginner.
And so he was like, you know, I can't remember which one has which. If you've written any VIM script, you'll know it's already different than said.
You know, do I escape it? Do I not escape it? Does it support this class? Does it support, you know, politics classes? Does it have a backslash?
So he said, you know what, I'm done with that. I'm going to take all of that. I'm going to put it in here and I'm going to take all of this.
I'm going to put that in there. And he took every single regular expression was there and made sure that the priority of Perl is on really powerful text manipulation, the practical extraction and reporting language, P-E-R-L.
I think that the acronym came after Perl existed. And, you know, there's all kinds of stuff you can read out there from people on this whole topic.
So that's what Perl has always been good at doing. Perl has a wicked, great templating. People don't even know. You can use FMT in Perl and get really great textual templates for output.
You can, you know, anytime you're dealing with text manipulation and that includes parsing logs, you know, power gripping through stuff.
It also includes converting things to binary. People don't understand this very well. It's usually the last thing they learn in Perl.
There's a Perl pack, it's called. And Perl pack allows you to specify very precise binary notation so you can parse binary files with Perl using the pack statement.
Let's you do that with Ock. You can do it with Python, but which version of Python is Python even going to be on your system? Is it going to require a pip install?
That's the problem with Python. Python's not on those systems. It's not on all unique systems. And if it is, it's not going to be consistent.
It's not. You can't count on it. So think of all the reasons that you want something that's already there.
The reason that you use, you know, the bash is because it's default on Linux.
The arguments people make for using a POSIX shell is because that's supported on all forms of Unix.
They don't have to, you know, have a Docker container just to run their application.
They can write a script and share it, or they can, more importantly, they can put a script on the system.
And if you've done any pen testing at all, you should obviously immediately understand the benefit of this,
which is why it's so stupid that F security would make fun of the language that's the most effective for writing, harvesting, you know, penetrations code on.
The reason that Go is going to destroy Python in a cybersecurity world as soon as everything gets ported over is because Go can write packages and payloads that run on the target system
without any other system. I can write it on my Mac. I can write a target for a Windows machine, send it over there and execute it on the system without any dependencies whatsoever.
If the system is a Unix system, I can write it in Perl. I can write a Perl script and run that Perl script over there.
And I could, you know, it depends on how powerful your shell is, right, but that you've, you know, your back door you've got.
But if you go on that system, you have Perl ready. It's a Unix system, right?
So you don't have Python. Go dig apart the rootkits. They use Python.
They have to ship the whole fucking Python interpreter with it to make sure that they have the right version.
Whereas if they were attacking a system, and that's fine if you're attacking Windows or something.
This is why Go is going to be better. Go doesn't have a whole bunch of bundles.
It's just got one very difficult to decompile executable that then can go on the target system.
That's got a ton of stuff, including high-level encryption built into the standard library.
So, again, I think Go and Perl are still very viable for all kinds of hacking techniques, particularly when you just have a shell thing.
So, I mean, anytime you're dealing with text, and so the reason I came to this is because I'm doing, oh, here's another thing.
Let's say you want to work with a system that's in Chinese, and you want to use regular expressions to parse through logs in Chinese.
Oh, no, you don't have regular expressions support for Unicode. How am I going to parse these congee characters? Can't do it.
It's no surprise that Perl is the first language to implement backslash p, which is a Unicode REGAX class match.
So, you put in parentheses behind that, you can put whatever plane of Unicode set that you want.
As far as I know, as of this date, Perl is the only thing that supports that.
And so, as I was implementing my KN utility for knowledge management stuff, I wanted to make very strict regular expression matches for the URIs that I'm using for knowledge nodes.
And I wanted to set any uppercase letter, not just any ASCII uppercase letter.
You should all go, if you want some homework right now, go find your preferred language right now for your standard language, your workhorse language,
and go find out, go see if with a regular expression you can match a set of Unicode characters that matches all capital L lowercase u, that class,
which is the Unicode character set for uppercase letters. And we're not talking about just ASCII.
Ask yourself and then do the research to see if your language can do it.
And I'll bet you that it can't.
Because I know BASH can't.
I was trying to do some of this stuff in BASH because 2020 was an experiment to see how much of my life I could just do completely entirely in BASH and go.
And I found out that as of this week that there's a pretty significant portion of what I like to do that I can't do.
I can't match Unicode character classes, period, not possible.
Maybe that's coming out.
I imagine all of that.
I imagine the pressure that Pearl's going to put on everything else is going to do that.
And since Pearl is the thing that defines the standard for regular expressions, LibPCRE is a good bet that anything that supports LibPCRE is going to get an upgrade because the people who support LibPCRE who are no longer associated with the Pearl project
are going to add that Unicode backslash p support and it's going to land in every other language thanks to Pearl.
Alright, so I don't know how many times I have to say it.
I have a little soft spot on this in me and if I sound aggravated, it's mostly because I'm aggravated at myself for not remembering what Pearl is good for.
Now let's do spend some time talking about what Pearl is horrible for.
Pearl is not for object-oriented programming in any sense.
It's not for programming anything at scale.
It was never designed to do that.
Do that in Pearl.
Do it in Python.
Do it in Go.
Do it in Java.
Do it in C-sharp.
Don't do 10,000 lines, 100,000 lines of Pearl code.
That's ridiculous.
Pearl is a fucking shell script.
It's not designed for that.
Don't use it that way.
Use it the way it's intended.
And then you'll make a benefit of it, right?
So even TypeScript is more suited for that because it's strictly typed.
It can be transpiled.
I mean, Pearl is not the language for that.
It was never designed to do that.
Don't do that.
I did it.
We all did because it was the only thing.
Python couldn't even do some of the stuff we did.
And then eventually Python caught up and it started being able to do that.
It was a little bit more verbose.
It had Python and that really, really, really sweet, you know, C-stubbing so you could like make NumPy and all the stuff that Python's become famous for.
Pearl was always, Pearl didn't like people writing C-stubs for the language.
That was, no, it's a shell scripting language.
We're not going to add support for C-stubbing to the language.
It has it.
It has it.
But it was like, we're not going to really focus on that.
That's not our goal here.
Our goal is to maintain a decent shell scripting language.
As soon as you start, as soon as you have to add a dependency to something from C-pan in your Pearl code, you've failed.
It's my opinion.
In my opinion, you're no longer using Pearl for what it was intended to be.
Just a present shell script that gets a lot of stuff done.
That's better than Bash and Z-shell and Fish and all the other shells for writing really great, fast code.
And the performance of Pearl is way better because your average Bash code that would be, you know, 100 lines, 200 lines long,
is probably got at least half dozen, two dozen, three dozen sub-shells in there to get stuff done.
Even more if you don't know what you're doing and you're using a lot of set and awk.
In that case, you might as well just write one Pearl script, which is one sub-shell.
And all that performance goes away and it's actually faster, even though it might take a little bit more memory for it to run.
It still runs just as fast.
So that's the case where you wouldn't want to use Pearl.
You definitely don't want to use Pearl for large-scale enterprise applications.
It was never intended for that.
Don't do that.
It's a bad idea.
And for that, I personally think Go is the best thing for that because you can tell that Go is highly influenced by Pearl on many levels.
But, you know, grab a more verbose, strictly-type language.
I mean, the whole world has realized that interpreter languages are not the thing to go to for large-scale development.
Microservices, the whole cloud-native world is all Go right now.
All of it.
This is just stating facts for people.
This is an opinion.
This is a fact.
Go was developed for cloud-native development, wherever you want to call that, at Google, specifically for those reasons, with strong concurrency before anyone was thinking about it, because Google needed it.
And now we've all benefited from that and Go has become the overwhelming industry standard for cloud-native development, period.
And that's not even up for debate.
I mean, you can confirm that all over the place.
I don't need to tell you that.
So don't use Pearl for the wrong thing, but do use Pearl for the right thing.
What is Pearl's right thing?
Pearl is the right thing whenever there's a lot of text involved.
Or whenever you're pushing the limit of that little shell script that you wrote, whether it's ZShell or Bash or TCShell or whatever, you know, if you're starting to push the boundary a little bit.
And particularly if you're a little bit afraid of that POSIX glob in your shell, you don't want it to work.
This is another thing about Pearl that people don't really give it credit for.
Pearl is a very, very safe language to write in.
It's probably one of the safest, and that was largely because of all the stuff that was happening with the web.
Anybody know about dash T, capital T?
Okay, so you were slamming on Pearl, but you've never used the dash capital T switch ever?
You don't know what it is?
Okay, let me help you understand that.
Dash capital T turns on taint checking.
And there is no language on planet Earth that does this, and they should.
Taint checking is one of the best things you will ever add to a language.
Taint checking automatically says any input, whether it be an environment variable, standard input, or any other file handle, is automatically tainted.
And the only way it gets untainted is if you explicitly write code that checks the data coming in in some way.
Generally speaking, match it against the regular expression, or you explicitly set the path.
When you turn taint checking on, one of the reasons people turn it off immediately is because it forces you to set the path in the script,
which means that you can't trust the path of the system.
You have to explicitly set the path.
Because the people who made Pearl and added taint checking were fundamentally interested in security.
You don't see that in Python.
You don't see that in many other languages, even Rust.
Rust is supposed to be a secure language.
Well, I don't see anything about tainting in there.
There's a lot about managing memory and borrowing and stuff like that from what I know.
I'm not going to say I'm a Rust expert, of course, but I don't see anything that's doing that.
And I really wish more languages would do it, and Pearl is really good at that.
And by the way, if you're writing a shell, one of the dangers of shell scripting is if your shell script gets adopted as something that gets installed everywhere,
you might want to add those kind of things.
But at that point, you probably should move it to another language like Go, or C Sharp, or Java, or whatever, or even Rust.
But again, Rust is a systems engineering language.
It's a C++ replacement.
I don't want to get into the language where I know.
So let's just recap here.
So good reason to use Pearl in 2021.
So it's old, but it's still very useful, like Linux.
Old, very useful.
Still getting improved upon, still increased.
Just forget Pearl 6 ever existed.
All the rest of us have.
It's got the industry standard for regular expression.
It includes Unicode support, which supports matching Chinese characters as well as emojis and everything else.
And others don't.
Other languages don't.
It's on every system, every Unix or Linux system created in the last 30 years.
I mean, you can go back to Pearl 4, and if you don't push the boundaries, you know, if you don't need Unicode and stuff like that,
you can find Pearl 4 on systems that go all the way back to this, you know, late, I'd say, the very early 80s, probably 86, right?
So, you know, it's going to be on everything.
You have a good, just a good chance of finding Pearl on things as you will finding Auk.
Except BSD.
BSD went to great lengths to rip it out.
And I think that was a really stupid decision, but that's their decision.
It has, it creates a single powerful sub-process instead of lots and lots and lots of sub-processes like you would use in any other shell scripting.
I think it's got one of the most brilliant developer teams ever to have lived.
I have never been burned by Pearl, and I wrote a list of all the things that have burned me over the years,
and Pearl was always there to have my back.
PHP, Bad Memory Lakes burned me.
Java, serious JVM bug.
They had to fly a guy in from Sun Microsystems so I could prove that, you know, our Nike software wasn't going to make the deadline
because of this stupid JVM bug to which the guy said, oh, and I just felt very validated and pissed off at the same time.
Pearl had my back.
It worked out every time.
Every single time something else has failed, and especially because I know Pearl,
it's because it has rock solid development.
It has never had a stop you in your tracks bug that I've encountered.
It may have had them, but I just didn't ever encounter them.
PHP had them.
JVM, Java's had them.
You know, Go hasn't had them in any so far, too.
So far, Go hasn't had any.
The only thing that stopped me with Go that I would consider a bug, a big one,
is that Go routines, if you're not careful with them, they'll leak.
That's not a bug, though.
Pearl provides the ability to write the most powerful one-liners in the world.
I have an alias called Pi, Pearl-P-I-S-E, which will recursively find and replace a keyword in everything.
Said some years, almost like five or six years after Pearl had ever had this,
added said-I in the Linux version, which does essentially the same thing.
The difference is, is it said has a completely different set of regular expressions.
It doesn't use the same PCRE standard, which is really confusing.
So might not go with that.
There is a replacement for that these days called, just read about SD.
It's not in any of the app package kind of things, which actually replaces with the Pearl expression,
so you can use it for said that way.
A lot of the new utilities are getting replaced.
Pearl is dense, hard to read, contextual, and implicit, but it does it on purpose,
so it'll be more powerful.
Pearl's not going anywhere.
Sorry, people are not taking it off of stuff.
In fact, if anything, I think Pearl's going to increase in usage as we go forward,
because the world is turning to conversational things.
The terminal is becoming important again.
People are learning that manipulating text and parsing conversational text and grammars,
and things like that are important, and Pearl's going to be right there to do that.
Python will do it, but it's just you have to, first of all, you have to install Python.
Secondly, you have to make sure you have the right version of Python,
and the answer to that that everyone tells me is, well, you should run a Python virtual environment.
I'm not running a Python virtual environment to run what is a glorified shell script.
Python is good for those applications.
It's horrible as a shell scripting language.
It's horrible.
Have you ever tried to do one-liners in Python?
They're so horrible.
I hate them.
It's still the best language where text is concerned.
It has a pack and map and grip.
The safest shell scripting possible, way safer than Python,
and it has syntax similar to shell.
That's actually something people don't like.
At first, they complain about it being kind of weird and cryptic and looking weird,
but that's because it's designed to feel like you're coding in sort of POSIX or Bash or ZShell
with some extra power.
So $0 is a special variable name for the current running script.
Well, that's the same thing you would use if you were writing shell code.
So that kind of weirdness in the variable naming and stuff like that, that's not Perl's fault.
That's because it feels like you're writing shell code.
So Perl is the natural progression from writing Bash or ZShell or Shell.
And actually, if you're a ZShell advocate, you guys know I don't like ZShell.
I play and complain about it all the time.
But if you are a ZShell or a POSIX person, then Perl is a really great companion for you
because Perl does all of the things that those languages can't do.
Bash can step into that Perl space way more than ZShell can,
particularly with exported functions and things, and full regular expression support.
Actually, ZShell has regular expression support.
We saw that.
The regular expression support in Bash and in ZShell appears to be the same exact regular expression support that you see in Perl.
So I'm able to reuse those kind of things.
And by the way, the use of associative arrays, which are otherwise known as hashes or dictionaries in Python,
you have to have Bash 4.2 or higher to get that.
ZShell doesn't have it, of course, and neither do the POSIX shell scripts.
But Perl has gobs of that in droves.
It's this very advanced support for references and all of that stuff.
So you can do some of those advanced techniques where you're dereferencing
and you can actually directly manipulate the symbol table, which I did to create Perl Classes Pragma,
which at the time it made sense.
It was sort of an effort to bring some of the better parts of object-driven programming for Ruby into Perl.
You can look at that.
It's called Perl Classes Pragma in my GitHub if you want to see it.
But it shows what you can do.
You can actually directly manipulate the symbol table in Perl.
That's the kind of stuff that in Python, you can get down into the underlying stuff,
which by the way, almost all objects in Python are dictionaries.
And it turns out it's benchmarked.
It's actually faster to deal with the internal dictionaries
than it is to use objects as small objects as if they were rather than hash maps.
Anyway, so it can take you to where you need to be, but not further.
And if you try to take it further than that, you're doing it wrong.
At that point, it's probably time to grab another language.
And one of those other languages would be Python.
Python is definitely suited for a larger application sort of approach.
So let's type script.
So as I imagine Dino is going to be more of that kind of thing, but definitely go in that space.
Those are meant for larger applications.
C Sharp and the Java, all the traditional OOP things.
And C++, but if you're going to do, that's a different thing altogether.
As soon as you're headed to C++ and Rust, you're looking for performance and, you know,
C and optimization, something like that.
And all different languages for different purposes.
But to date, Perl remains the best language where regular expressions are concerned
and where any text manipulation or command line is concerned.
Basically, when your shell starts to get a little complicated,
time to pick up some Perl and just use it.
Use the Perl on your system.
You don't have to get crazy.
All right, that's all about it here.
I'm going to actually, technically, I'll be closing the video at this point.
I'm going to take some questions from the chat and try to keep my cool here.
I'm just going to tell you right out.
I have had in the past very little patience for people,
as I kind of started out with, people who attack Perl who don't know it
and have never used it.
And I try my hardest to not be that person.
You should at least have tried it at a minimal level in order to get at least your basic
bearings on it before you don't like it.
And that's my opinion.
So, I mean, obviously, this is all opinionated stuff.
I'm going to bring up the whole chat here.
And I don't know.
I'll put you guys down here.
I'll go back up and go back to the earlier pages.
Windows is boomer.
I fecal.
It's background.
Community and Perl could be there.
Could there be a better combo?
Hi all.
Let's see.
Hello.
Perl is my Swiss Army chainsaw.
I went back anymore.
I like that term.
I heard that term yesterday again.
This was my Swiss Army macro.
This was my Swiss Army chainsaw.
How are you doing today?
I'm pretty good.
Hey, Norman.
It's good to see you the other day, too.
He doesn't read Twitch chat.
I do now, Flame, because I can see Twitch chat now.
So, thank you for having my back there.
But, yeah, you want to chat live.
I don't need to go to blah, blah, blah.
Oh, yesterday he was reading.
So, I thought, yep, Norman, we have a bridge now.
All messages from Twitch are Mirage IRC now.
Thanks.
Yeah, by the way, let me credit to Vera to be Vera for that.
My IRC admin has been doing great.
I really appreciate that.
User Perl, wow, that's new.
Yeah, it was new within the last three days.
So, we move kind of faster, particularly with the people I have helping me out.
Hello, sir.
Just discovered your channel and great.
They're also great, bite-sized articles.
I learned a lot from back in the day.
Yeah, articles and magazines from Merlin.
Yeah, actually, Merlin used to live in the same town as me.
When I was in Portland, yeah, Randall.
I was there when Randall was convicted of hacking.
And we had the Save Randall campaign and all of that stuff.
In fact, Randall, if you happen to watch this all the best, you know,
I know you probably don't remember me.
I remember one time in the middle of the day, Randall Schwartz and I and Lynn Soprell,
the web mistress from Teleport Internet Services,
we went and grabbed a drink.
And I remember just shooting the breeze.
I don't even remember what we were talking about.
He was a really nice guy.
And I remember all the hassle he had to go through.
He's the one who wrote Learning Pearl.
He's something of a God in the Pearl community.
He invented the Schwartzian transformation and a bunch of other optimizations for Pearl
that, quite frankly, should have been unnecessary.
As I said, Pearl was pushed to do things it was never intended to do.
And the fact that it did them and kept on going
is just a testament to how great this shell scripting language is.
Okay?
Let's just remember that that's what it is.
It's a shell scripting language.
It's not anything more, so don't use it for that.
And you'll be fine.
In fact, you'll be happy, particularly if you're in cybersecurity.
And if I was in security, I'd be all over this thing.
Thanks for a great talk this morning.
Yeah.
You know, problem.
Hi, everybody.
Hi, Rob.
This is...
Oh, hi, Kitty.
Yesh's mood and I see...
Hi, everybody.
Rob is in the yesterday's mood as I see.
I'm not even sure what Pearl is.
And I've just started learning how to navigate the terminal.
That's nice, Mark.
Pearl is basically a more powerful version of Bash.
I'm going to get shot.
Bash, awk and said all combined.
Those are all tools that you use on the command line.
Bash is the language that the interpreter that you use every time you execute a command
in an analytics system by default.
And so Pearl is...
You can write scripts in that language in the same language that you run,
you're interactive terminal.
You can write things that just happen when you run them,
you know, and that's what makes the terminal so powerful.
But at some point, you're going to want to reach for a little bit more power,
particularly when you're dealing with stuff with text.
And then when that time comes, that's what Pearl is there to help you with.
And that's normal in the past.
You would reach for said and awk and TR and stuff.
So these days, that's what Pearl is there to help you with.
Pearl's a women wisdom.
Did I say women?
I did.
I know.
I can't remember the soundly defunct London Pearl Mangers Group.
I know.
I was all over the Pearl Mangers Groups too.
I loved them.
I gave lots of conversations and presentations and all that stuff.
This has inspired me to learn to Pearl.
I still use Pearl all the time for interacting with network kits and APIs.
There you go.
See what I'm saying?
And this is something too, is people like Cypheric, do not speak up.
You don't.
The people who are using Pearl aren't just old cronies like me, you know,
curmudgeons in me, pearl curmudgeons, like we used to call them.
They're not.
There are people who have discovered the use of Pearl as a network integration layer,
as the duct tape of the internet, that was once called.
Because that's what it's good at doing.
Pearl is fantastic duct tape.
It's like really great and making a whole bunch of stuff work interactive together.
So you can have executables and you can call those executables.
I do that in the KN tool.
You can parse network input.
It has a really great TCP IP stack so we can go talk to it.
Try that with awk.
Can't do it.
Python has it, but it gets like which version, right?
And it's not going to be on the system by default.
So, yeah, will Pearl integrate with Vim as well as Bash?
Absolutely.
You know why?
Because Pearl can be any...
Look, so Fecal, let me...
I want to make something clear here.
Anything that can be executed can be integrated into Shell.
Okay.
So if you use the...
And if you watch me do the KN development, which I'm going to do later,
the script that can run can be integrated into Vim, right?
Now, this is actually...
If Pearl and Vim has integrated support so you can actually code Vim script in Pearl,
the new Vim people ripped it out.
Another reason new Vim is totally stupid.
I mean, they've made so many...
I mean, why would you rip out the world's best text manipulation language from the world's best editor?
I mean, what kind of stupidity do you have to have in your head
to disassociate Pearl from new Vim?
That decision by itself, when I saw that, I was like,
okay, you've just proved you have absolutely no idea what you're doing to me.
That's a project.
Anything that braves appropriately with stead instead of what works with Pearl.
That's right.
And that's really the shell.
When I say shell integration, what I really mean is anything that can be run from the shell.
And that includes Pearl.
So let's try something here.
I want to show you what I mean by that.
So if I'm just doing a foo, I can write a markdown file, right?
I can just say, I put my title up here, something in the title.
And then over here, I'm going to say, I can actually write some Pearl code.
And I can say, well, let's see.
Something simple.
I mean, I'm used to writing Bash so much because Bash is so easy to integrate.
You could do four.
I mean, there's not very many reasons that I would write Pearl in line to do this kind of thing.
But I guess I could.
I know.
I just can't think of any reason that you would do.
Oh, maybe a pack.
Let me see if I can think of a pack.
I'll do one for you, Fico.
I'll make a video on that.
So one example would be if you had to bring in some binary data.
You know what I mean?
But Pearl isn't very good for writing one-liners.
For that kind of thing, I'm big into shell.
For I in 0, like 34, I do echo I done.
And most of the time when I'm writing one-liners, I'm writing in Bash and I will continue to do so.
Pearl steps in when I need to make a script.
You know what I mean?
Like when I need to make a script.
But if I'm writing one-liners, yeah, that is your friend.
But so much of that is already done in Bash.
So I would be, you know, I'd be sort of hesitant to do that.
So, okay, so let me show you how to do this.
This is some Bash code in the middle of my thing.
And let's say I want to write, you know, number, I want to number a bunch of stuff.
So some, and then I can just run this code.
Old Codgers, Git team, yeah.
Yeah.
Yeah, they're, the Git team, I think the Git team has some pearls still left in it.
That's what people were complaining about actually.
So I can run this through Bash and then that'll just replace it.
It'll put the zero in there even if I want.
So I got to, so for that kind of thing, I would stick with Bash just because it's so easy to do.
But when you want to use pearls, when you want to start to write a script like I've done with the KN tool.
So this is the KN tool that has to look through the environment.
And it has, another thing too is it has the data dumpers and things like that are standard.
So you can like dump your structures and get, you know, do that kind of stuff in Bash is really, really painful.
I mean, it's really painful.
You've got to know, like, I just, it's just crazy.
I got into it there at the little bit at the end and then I came back to Pearl and I was like, oh my God, this is so much easier.
But the thing that's important to consider is that the subroutines are like shell subroutines.
In other words, you don't pass, you know, define an argument signature, you just shift stuff off.
It's, you're coding in shell is what it is.
And once again, if you take nothing more away from this, Pearl is a shell scripting language.
That's what it is.
It's not meant to be, you know, you don't, you can't run a Pearl interactive shell.
But it's meant to be a shell scripting language like the next level up.
So here's how you do a dictionary.
This is actually, this actually is taking a reference to the function so that I can run the function later.
Here, this is a good example of a map.
So this, this takes, this takes every file inside of this directory through Glob expansion.
Maps every one of those files replacing everything up to the slash with nothing.
So it's basically trimming off the stuff except for the name.
And then it, it returns the name by just, that's the current value through the loop.
And then that thing gets returned.
So all of that returns as an array.
And then it loops through the array and it joins them all and makes it will pass for the whole thing.
So that looks pretty dense.
And it is dense, but it's also very, very, very powerful.
I mean, if I were to write that in Python, I don't know how many lines that would be.
That would, you know, so.
Actually, for Pearl, I recommend you do install Pearl docs and just use the man pages.
Something else I didn't even mention is how great the man pages are.
You gotta remember, Pearl existed before the internet existed.
So it's documentation.
You can go Pearl intro, man, Pearl intro.
This is the best source of information on Pearl you'll ever find.
I'm telling you.
And they even have user-bin ENV.
I hate this.
I do not like user-bin ENV.
I do not recommend you do that.
It's unnecessary.
So it's also insecure, even though they suggest it.
But my point is, is that you can go read anything you might want to ever read about here,
just by reading through the documents that come with it.
So the man pages on Pearl are what I would recommend for free.
There's, you know, the good old learning Pearl from Randall Schwartz.
It's probably, I don't know if it's been updated recently.
The thing about Pearl is it's been around.
It hasn't really changed in 15 years.
I mean, they've added support for a command called say, which I really love.
I mean, actually, I found out, by the way, if you are a Pearl person, this might be of interest to you.
If you are a Pearl person, you need at least 5.10 to use say instead of print.
But that'll save you that annoying backslash and at the end of everything.
And if you've done any Pearl coding at all, you know what I'm talking about.
Super annoying, right?
You have to put backslash and on the end of everything.
And if you're a shell scrapper, it's super annoying.
So if you use at least version 5.10 or above, I also did the research and found out that 5.14.
5.14 is the first version that supports Unicode backslash P.
And they're at now at Pearl 5.30.
And there's no intention of ceasing support for Pearl 5 ever in the future.
So they're continuing to maintain it.
The Pearl Cookbook is, yeah, I love the Pearl Cookbook.
It's funny, I actually, when I gave it to Pearl some years ago for Python and some other things, I got rid of all my books.
I had, I have like, Pearl testing.
I used to be on pretty good terms with most of the book authors.
It's been forever.
It's been forever.
I mean, I was really in the Pearl community.
But I, you know, and then I kind of moved on.
And it was funny because a lot of the people in the Pearl community, many of them have never left.
There's still all they do every day all day is Pearl.
I'm like, guys, there's a lot of other stuff out there now.
You know, just give it a hard time.
But environment variables are the same.
I don't know if you can notice this, but you see how things look a lot similar to Shell, right?
This is a file spec is a standard library for joining.
So you can do it in a, you know, in a standard way.
If it looks a little bit like, you know, I also find interesting.
Doesn't this look a little bit like Rust?
It does, doesn't it?
In fact, there's remarkable similarities between Pearl syntax and Rust syntax.
I think I find always find interesting.
You can sometimes run into a Rust person that will slam Pearl for being right only or read only because the syntax is so bad.
Meanwhile, they're on syntax.
That's not, I mean, I'm going to say it again.
Since I had, I just moderated like 80 comments on my 48,000 hit Rust is slow and I changed the title and everything to try to get people to leave me alone.
Over that thing.
But no one watches the end 14% of the people only 14% of the people watch.
They only watch the first like 20 minutes of that Rust video.
They don't see any of my conclusions at the end.
They just see the first stuff and then they go off.
Most of them don't even watch the video.
So I had to be careful by making this video and try to be more specific about it.
I'm going to go ahead and drop the stream here pretty soon and restart the stream.
I have a little coffee with my wife and I'll come back.
I'll be coding in Pearl all day today and tomorrow.
In fact, I'm going to be coding in Pearl a lot over the next few days.
Most of my shell script library in my .files is going to be converted to Pearl sub commands of the KN tool.
And the rest of them are probably going to, I'm going to rewrite them in either POSIX and dash or a few will remain as bash.
But I'm personally going to start writing everything.
All my shell scripts will either be in POSIX, Shell or Pearl.
And to the ZShell people out there, that's probably going to be music to your ears because everything I write, you'll be able to use.
You could use the bash stuff anyway, right?
Because it's got a shebang line that points to bash and your system probably has bash on it even if it has ZShell.
Not if you have a Mac though, but there's a good bet that you have Pearl on it.
So say, for example, you're a Mac user and you want to use any of the stuff that I write.
You'll be able to use it because it'll either be in POSIX Shell, which is ZShell compatible, or it'll be in Pearl.
And you already got Pearl in your system usually.
In fact, anybody got a Mac handy right now, they can just go on their terminal and do which Pearl or do pearl dash version.
Anybody have a Mac out there and want to admit it?
I would love to see what version Mac comes with.
It might not come with it though, but Pearl Artistic License is completely different than GPL3.
So I think it has a good shot of still staying on the system, maybe not though.
5.32, seriously, on your Mac?
Wow, I'm impressed.
So there's another reason to use it.
Yeah, so I'm going to, I mean, another reason to write your shell scripts is if you write your shell scripts in bash, default Mac users won't be able to run your shell script.
Because bash has to be installed.
They can run your pearl script.
We just proved it.
They can run your POSIX Shell scripts.
So if you're searching for usability across the board for your team and for your friends, or if you're a live streamer who wants to be able to share cool things with people, you know, it kind of behooves you to write it either in POSIX Shell.
And interestingly, that's the position I had in 2007.
Or Python, but Python has to be installed, right?
So yeah, there are slight differences with Active Pearl, Strawberry Pearl.
Yeah, especially using different modules.
Yeah, I don't, but none of those need to be installed.
Yeah, yep.
Good old Active Pearl, Strawberry Pearl.
Anybody ever play with Indigo Pearl?
That's how I used to, I got Indigo Pearl.
I'm not a Pearl 7 or a Pearl 6 fan.
I will only use the Pearl that comes on the system.
The very purpose of Pearl is to have a shell script that's on everything that just works.
And that's Pearl 5.
And that's never going to be Pearl 6 or 7.
If you're reaching for Pearl 6 or 7, then you're making a different decision.
You know what I'm saying?
You're now making a decision about kind of a different scope of application.
And at that point, you've got lots of things to evaluate, right?
You've got to see, is this better than TypeScript?
Is this better than Go or Rust if it's like low level?
I am never going to code any Pearl other than Pearl 5.
Because I want, I just want the shell script.
That's what Pearl was intended to be.
That's the best thing it ever was.
And the fact that it keeps getting pushed to be more, I think is a mistake.
I apologize, Pearl people out there.
I know some of you are very hard working and they tried really hard with Pearl 6.
But Pearl 6 is a perfect example of what Brian Cantrell, formerly a joint now from Oxide Computing, calls Second System Syndrome.
It's when you open up the gates because you're going to make a new thing and all of a sudden it never gets done all of a sudden.
Because so many new ideas come in and they overweigh the thing so it never gets done.
Because you just keep trying to do it.
So I think all of the Pearl versions beyond Pearl 5 suffer from Second System Syndrome.
And they frankly, they open the door for Python.
I would easily pick Python over Pearl 6 or 7 any day.
Just based on the TensorFlow support and all its wide adoption and Jupyter notebooks.
And I mean, I know those things can be done in Pearl 2, but there are so many reasons to stick with Python for that stuff.
And automation, all of that stuff.
Pearl 5 after 4, yeah, completely fair.
That's a fair critique.
Yep.
Yeah.
Yeah, finding talk.
I'm off.
Take care Q-Macro.
I completely agree.
A lot of people don't know this, but Pearl 4 didn't have this notation at all.
This reference notation right here.
See this file spec stuff like this?
That was all of Pearl 5 edition.
Yeah, the split between Pearl 4 and 5.
Pearl 4 was really, really just a better awk.
And you didn't have this idea of objects at all and bless.
I don't even want to talk to you about stuff.
That stuff.
In fact, I would suggest you not even use it.
I really, I think as best as possible.
I do hear because I'm doing a join, but for the most part, I would rather you try to stick with Pearl 4 syntax as much as you can and keep it functional.
And if you get too much into the pro object oriented world, which you can totally do with the thing called bless.
Python does the same thing as bless, by the way.
They just don't call it that.
Then you're kind of going off the deep end at that point.
If you're reaching for bless or for some way to make an object, you're probably doing it in the wrong language.
And you probably want to rethink your selection of Pearl for that and move to something else.
And keep Pearl as a glorified shell language.
And then you'll be fine because that's what it's really, really great at doing.
So anyway, yeah.
So any other questions?
Let me talk to the YouTube people for a second.
Oh, here, by the way, here is the regular expression I want to see if people can test in their own languages and see their preferred languages and see if they can match it.
So we have a match.
This matches any uppercase letter character according to the Unicode classification, which includes several letters that are not in the code play.
If you're interested in this, by the way, this stuff is all in the pagan notation.
If you go to getup.com slash pagan and you click on spec and then classes in there, you'll see all of these planes subdivided out by their exact character names.
And so you can decide if the match is actually working.
We did that because we built it into the specification, into the parsing expression grammar notation, into the specification for that.
No more talking about that, though.
If you want to know about that, we do that on Fridays.
We work on the pagan grammar notation, meta language, and writing all of that stuff up, which is really fun.
That's how I happened to know about this because I was going through it and because of pagan, I was like, well, gosh, I really don't want to just match upper ASCII here.
I want to match any uppercase letter even though I think environment variables, as a default, must be ASCII characters.
I think that's the requirement for all systems, but I don't know that.
So this is just a match to isolate any action that might actually be an environment variable, which allows me to do this.
So now I can just do a KN path, and it will show me the whole path, right?
I can do, you know, whatever.
And I can do some other things with KN.
But if you want to know more about the KN tool and you have questions about what it does and how it works and why I'm doing it, stick around.
And when I come back, I'm going to be coding on that all day today.
And I'll be coding in Perl, mostly.
Perl and, in fact, I'm going to be moving all of my library, my dotfalls library, either to Perl or to POSIX shell.
So if those topics interest you, please stay tuned.
I won't always be talking a lot, because, you know, you can listen to the desert in the background if you want.
I thought I'd bring up the old Perl Camel for fun, because, you know, Perl's not lost in the desert.
It's still getting used all over the place, right, Cypheric?
Anyway, it's been fun.
I'm going to go check our YouTubers who don't have a way to communicate with us right now.
It's unfortunate.
Uh-oh.
Message retacted.
We had a couple of messages get retacted.
Looks like they didn't want to follow through with it anyway.
Maybe they came in to our other thing.
So, Alexi, did you get your question answered?
And, Catalan, I was planning on using a Perl set of Bash scripts.
What do you think?
I think it's a great idea.
I do.
And you're hearing this from a guy who was big on Bash until two days ago.
Two days ago, I got really burned by Bash.
And the first burn was that, oh, okay.
Thank you.
Thank you.
The first burn about Bash was that I could not match Unicode characters.
That was the first burn.
And the second one was that I could not do documentation.
And we haven't even talked about that, but Perl has wicked awesome documentation support.
You write the documentation in the script file at the end.
So it doesn't, your interpreter doesn't have to go through the hassle of parsing it
like it does with Python.
And it makes it wicked fast.
And so that way your little script that was, at one point it was just a little shell script
and now it's a Perl script can actually document it in a way that is totally marked.
You can mark it up and everything using pod.
Pod's an old format, but it still allows you to do to create man pages and stuff for your little shell script.
So you got little shell script that you made as it can grow up.
And because it's all coming at the end of the file, the interpreter completely ignores it.
Completely ignores it.
So it's extremely efficient documentation.
So for the KN tool, I wanted to document each of these commands that I'm making, these actions I'm calling them.
And I was like putting these big long bash comments and stuff.
I'm like, man, this is horrible.
And then I remembered how well and easy it was to document your functions in Perl.
I mean, to document everything in Perl using Perl pod after the underscore underscore end and putting it all there.
And so that documentation travels with your script.
So once again, that and the Unicode support caused me to change writing my KN actions from bash to Perl.
And frankly, based on that, I won't be returning to bash other than as an interactive shell.
I won't be writing any more shell scripts in bash because of it.
And I love bash.
Don't get me wrong.
I love it.
I think it's really cool.
I learned a lot going through it.
I still think reading through the bash user guidelines is fine.
But I've got to tell you, I was getting a little bit annoyed at all the stuff for variables that I had to do to use the Perl in bash.
In bash, I had to make sure that I had curly brackets and double quotes around all my variables and I had to write a little macro to do that.
And I was starting to wear on me.
And then last night, I started writing all the same stuff in Perl.
And it was like, I wasn't pushing a rock uphill anymore.
It was like easy.
I can just use $ whatever for a variable name and just be done with it.
And it was just so liberating.
And it just started flowing again.
Not just because I knew it before, but because it's a much better language to write shell scripts in.
And that's what it's always been intended for.
So anyway, also I feel Perl is easier to read than bash.
Yes, absolutely.
In fact, can I show you the bash equivalent?
So the other thing that, and you got to understand, I was really loving on bash.
But let me show you this here.
So here's a good example of where bash falls on its face.
The fact that you can do it is still pretty cool.
I'm sorry for the background.
It's a little bit off, but so here is the code to do completion for build scripts.
Oh, yeah.
Perl has got awesome support on Windows.
You usually have to install something, but usually people are running it on Linux through WSL or something like that.
So let me see if I can find it offline.
All right, so this code right here, so this is code that converts.
I mean, it's just as every bit is dense as Perl, right?
The difference is that it's not as powerful as Perl.
So if you're going to buy off on that kind of, this replaces everything up to the dot.
Actually, this replaces all the dots with the slash, right?
So that's what it does.
But this is where it really gets crazy.
So let me see if I can find it.
Compliant.
Where's my complaint?
I guess I took it out already.
Yep.
See dot files.
Scripts.
I might remove those icons.
They're kind of annoying.
I was just trying another thing for icons.
Let's try Perl.
Yeah, for Windows.
Where is it?
Right here?
No, I think I removed it already.
Oh, well.
Actually, I have another one that does this.
All right, so this command, this here, see this?
This code right here fulfills tab completion by checking to see if an environment variable has a
compliance set.
And if it does, it iterates over all of the commands.
This is how you write, and this is, I'm just going to say it.
This is ugly.
This is how you write a dictionary in Bash.
Yeah.
Ugly sin, right?
You know how you write that in Perl?
Hashtag, I mean percent commands.
But you have to type all of that just to get to that in Bash.
This here points to malware.
The address tied to malware.
What's that?
Perl com domain.
IP address tied to malware.
Oh, boy.
Perl.com points to malware.
It doesn't surprise me.
Yeah.
There's a lot of hackers still using Perl.
Not just old people.
This here says replace.
This says, does the substring from zero to however long the first argument is, which
is like maybe five, 10, six characters, does it equal that same value to see?
It's basically a substring match.
That match is like no problem.
It's like half that length in Perl.
The one I was really going to show you is the dereferencing.
When you're dereferencing a function and you want to do alias and stuff like that, Bash
just really falls apart because it's not designed for that.
Bash is not meant to do that kind of thing.
You know what I mean?
They forgot to renew the domain.
That doesn't surprise me.
A lot of the Perlmongers are tired.
They're just like, I just want to make my stuff work.
That's another reason I decided to do an entire video on Perl because a lot of them
aren't doing anything.
I'm going to call you out, guys.
They're stuck on UCP and they don't come up for air.
They barely got on Twitter like three years ago.
I hate to say it, but it's true.
There are many people from the Perl community who are stuck in the past.
They're good.
They're smart in their intelligence.
Would they consider live streaming?
Probably not.
I figured I had to make a video on it at least to show people what's available.
People didn't even want to use the terminal.
Now everybody is starting to see the terminal.
That's largely because people who have been making powerful use of the terminal for years
are finally making videos and showing it.
Hey, this thing is actually a thing.
In fact, I've seen several security people do things.
Hammond comes to mind.
Stoke, I think his name is.
A couple of people have done videos on the terminal.
The terminal is really awesome for cybersecurity.
Oh, news flash.
Because they're doing it, other people are becoming interested because the generation,
that's where they get their data.
Everyone else is like, well, yeah.
But there's not a lot of people making content that's digestible.
I'm just going to say it.
The older generation is not communicating their knowledge to the younger generation.
They're doing their thing and they're too busy to be bothered to do it.
They're making their craft beer.
They're doing whatever they're doing and they're not sharing.
So I figured I at least needed to start sharing.
It doesn't mean what I have to say is anything is any better than what anybody else has to say.
It just means that I just have an opinion to the voice as well.
And so we can put that out there with everybody else.
What's that?
I switched to Win at 10 to FreeBSD and JWM for the exact reason of never going back.
And I'd be curious, does your FreeBSD come with parole?
I'm not going to rip on you.
I promise.
Don't be afraid.
Does your BSD have parole on it by default?
I'm pretty sure it doesn't, right?
Yeah.
I read a bunch of stuff that said that the modern BSD variants have successfully ripped parole dependencies out of everything.
I still think Git has a dependency on it, but I think it's built into the problem, to the program.
And I understand why they did that.
I think it was a stupid decision, but I understand why they did it, right?
But anyway, trying to turn it back to processes going on right now for parole.com.
Oh, wow.
Yeah, Git is heavily dependent on parole, right?
When I joined development, parole was already considered legacy.
Yeah.
So it's interesting to hear that alternative point of view.
Well, I'm going to say something here.
Pearl is legacy.
You know what else is legacy?
Linux.
Linux is legacy.
Linux is older than parole.
Is that true?
No, I don't even think that's true.
I think parole is older than Linux.
I would love to know that.
The point is, using parole for machine learning is idiotic and definitely legacy.
But using parole as a better awk, as a better said, is...
Yeah, it's 87.
Yeah, clean start.
Using parole for what it was intended to be used for, which it is still the best in breed at doing, is not legacy.
It's not legacy.
I mean, the code bases are trying to migrate.
God, yes.
The term parole code base is a fucking oxymoron.
Sorry.
Sorry for the swear word.
It's a tool for the job.
Yeah, it's a tool for the job.
And I recently had to blog a lot about this.
I find myself, you know, getting uptight for having to defend tools that are the best tools for the job.
And sometimes, you know, people...
I get overly defensive about it, and I call people assholes and stuff, which I shouldn't do.
I did that yesterday to Mosh if you're out there.
I apologize.
You know, I...
It's not about that.
What it's about is it's like what Cypheric says, it's the best tool for the job.
If the job is parsing text that potentially has Unicode in it, there is no better tool on planet Earth than parole right now.
Your language doesn't do backslash p capital L U to parse uppercase letters in Unicode.
It doesn't do it.
And so, you know, just best tool for the job.
And if the job is a better bash, that's going to write a shell script and prototype rapid applications development in,
and then port it perhaps if you're going to, you know, write a module or thing that does grow a little bit,
then at that point, yeah, do it in Python, do it in Go, do it in something else.
But having a parole code base that's not a bunch of scripts, that's definitely legacy, in my opinion.
In my opinion, that's legacy.
You know what else is legacy?
Using anything with parole moose or mong, you know, there's all kinds of object-oriented things that got added onto parole.
I hated all of them.
I tried really hard to make parole into object-oriented language back when I drank the object-oriented Kool-Aid.
But then, you know, the parole class is pregnant that I made.
But the fact of the matter is, is if parole has no business in that space,
I have a parole code base running on 52,000 machines that I've been to this day.
And I wrote it, and for only going, I got shipped.
It was my endpoint for collecting data.
But that was definitely a sweet spot application for Go.
And if I had it to do today, I would have done the whole thing in Go.
But we didn't have those options back then.
So I definitely agree that most parole in the enterprise that you're going to encounter, or anywhere, frankly,
is going to be legacy.
The application is legacy.
The application of parole in that instance is legacy.
But parole itself is not legacy at all.
Paral is cutting edge when it comes to regular expression parsing.
It is the front of the pack in creating the best regular expressions known to mankind, humankind, whatever.
And in that sense, parole is not legacy.
Paral is the industry standard.
So as long as you can separate those things, though.
PCRE is a separate lib, but it does not have slash pat p in it yet, as far as I know.
If it did, Python would have.
So that might be that it's a new thing.
So if anybody has any information on that, I'm wrong.
I would really love to be wrong on that.
So please let me know if your language supports the backslash p Unicode class match.
PCRE is not the same as Paral Regex.
It's very close.
Yes, it's very close, but it was heavily inspired by Paral.
In regular expressions, most people don't ever need a regular expression.
I'm the first to admit that regular expressions are usually bad.
Regular expressions are a bad idea if a simple substring match or a split would work.
Paral regular expressions are an unnecessary complexity that can actually really tank your performance.
So a lot of times, just a good old substring match or a prefix match or a range match are way better.
I'm guilty of really, really loving a good regular expression and wanting to do that first because it's just easier to write.
It's easier to write than a substring this and if this substring matches that, but that code is usually more performant.
So that's the thing.
Are more powerful than PCRE?
Yeah, they are.
Paral regular expressions continue to be more powerful than PCRE and they will be.
I think they're going to continue.
Paral once again proves that on the front of regular expressions, it is not legacy.
It is the cutting edge and it's going to continue to influence PCRE and the rest of the regular expression.
It's because it's dominated the industry forever doing that.
So yes, most code bases are legacy Paral, but Paral itself is anything but legacy.
And as long as you use it as the most powerful shell scripting language on planet Earth, which it is, then you're going to be fine.
How's that?
And you might profit, particularly in cybersecurity.
You can clean up with cybersecurity.
Yep, I'm telling you, man.
I wonder if I might subcode really fast and hack really quickly.
Paral's your baby.
Plus it looks cool.
Hackers love it.
We'll be sticking to Paral 5 plus instead of a code.
Yeah, absolutely.
I personally, I personally, I'm not telling you what to do, but I personally am not ever going to use anything but Paral 5.
Because the whole point of me using it is that it's everywhere and it has regular expression support for Unicode and that I just know how to write it really quickly.
I'm not going to use anything that, look, I'm not putting down the people who have made those projects.
I just, as I said before, if you are using, if you're reaching for something besides Paral 5, you have a lot of other options in that field.
At that point, you need to compare your choice with a bunch of other things and not just, and not just, you know, a great, you know, the world's best shell scripting language.
Because that's what it is.
And, you know, so that's all I'm going to say about that.
I have not even cracked open Rakudu and the other ones.
We had, actually, we had one of the developers was on our stream some time ago and she said, you should really give it a try.
And I, she's very, very nice.
And I was seriously thinking about looking at it, but I got to tell you, I mean, I like keeping my mind open on those kind of things.
I, I can't imagine there being, I've been wrong before, but I can't imagine there being anything that I would ever want to code in besides, you know, because every, because Go covers all my other bases.
And the very few little edge cases that aren't covered by Go are covered by Rust or they're covered by Python or Bash or C.
There's no more room.
There's no more room in there.
You see what I'm saying?
I mean, it's like, if there's going to be other languages in NIM, for example, NIM is another one that's really, really cool, right?
Am I getting it right?
I think it's called NIM.
I mean, there's a lot of really cool languages.
Haskell, you know, any of the purely functional.
If I, you know, if I was going to go to plug in for Pandoc or something like that, then I could see doing, or if I was having a really, really, really highly concurrent system like Discord does, I would do Erlang for that.
You know, but, but I don't see, I don't see the sweet spot for anything outside of Pro 5.
If that makes sense.
Because, you know what I mean?
You know what I mean?
Because all the other needs that I would have are well, well covered by other languages, sometimes redundantly well covered, and particularly Rust and C++.
They both cover and see, right?
They want, they cover, all of them cover one area of high performance computing that is, you know, arguably harder to write, but more stable and more performant.
But not the thing that you would grab for every day to make a microservice.
In fact, you, to write a microservice in Rust seems kind of silly, right?
It's particularly given all the libraries that exist in, in, for go and to do that very same thing.
You know, if you're, if you're doing, if you're doing machine learning, it's either, it's either Python, obviously, or, you know, or R, or, you know, scientific computing, or Julia.
I just don't see there being a lot of space in the language realm for yet another multi-purpose offering.
That's not one of the ones that's already existed.
It's already been adopted by everybody.
And so that's, that's my reason for not really caring about anything besides Pro 5.
And I apologize if that, if that makes people sad.
I mean, you know, because there's, there's probably people have done a lot of really good work on that.
Pro 6 was a complete disaster.
And you guys, we just have to own it.
The reason you try to rebrand the whole thing is because Pro 6 was a freaking disaster.
You couldn't get it right.
You couldn't plan the thing.
You tried to spite up more than you could chew.
You basically tried to do all things for all people and you failed.
And maybe you finally came around and got it to being something better than it is, but, but at the time it failed.
I mean, it was, I'm sad to say that because I lived through that.
I was, I was buying into the 6, the Pro 6 thing and I was sending a waiting, waiting, waiting, waiting, waiting.
And meanwhile, Python was progressing and people were moving, porting from Pro to Python for enterprise solutions for all the right reasons.
And, and, you know, C++ was getting a lot of big leverage at that time.
It was coming into the enterprise because it was easier to write than Bruno was taking over from Java.
And Java, of course, was dominant through the whole thing.
And, and then what?
Nothing.
And now, you know, like 12 years after I gave up Pearl, someone tells me that there's a version of Pearl that's actually really awesome.
I'm like, I'm just sorry.
You had your chance.
I'm not interested.
You know, I would, I'm not saying I won't look, but, you know, pre-installed most of us.
Right.
Pearl is, but not, but not, not Roku.
Yeah.
And one, one of the reasons I say that you should, you know, Pearl for is on everything.
So, and, and that's pretty much on steroids.
So if you just keep yourself to, to writing basic Pearl for constructs and you don't do any of the other stuff, you're totally fine.
You can write at Pearl run anywhere except for BSD, apparently, you know, some BSD stuff and in which case, you know, you have to decide why you're doing that in the first place.
So, yeah, I don't, I don't believe that I would ever deploy production software in Pearl today.
And I don't mean that to be as an SRE.
I would use it all the time as a cybersecurity person.
I would use it all the time as a, you know, as a tool.
Anytime I would use bash as a tool.
It's not like you're going to deploy a thousand lines of bash in a production system.
If you're doing that, and I know Vera was talking about doing that, and he's porting that code to go right now, picking on him a little bit.
You know, if you're doing that, that's, that's fine, but it's, it's, it's arguably not the best way to do it.
Really, if you got 10,000 lines of bash code, you want to reconsider your life priorities.
You know, I actually refactored 9,000 lines of Pearl for, for VMware integration layer at IBM.
Yeah, that was not fun.
You have to duck.
Love that someone else is loving Pearl the way I do.
Pearl was my second language after C. Wow.
Yeah.
And it does, it feels like C a little bit, you know, don't you?
I love Pearl for what Pearl is designed to be.
I'm wrapping up here.
This is a long video, but, but, but I really want to hit that part home.
I love Pearl for what Pearl, and I suggest Pearl is cutting edge for what Pearl was intended to be, the world's best shell scripting language.
It's not designed to be an enterprise language.
The prototype that I'm making in KN will eventually, many pieces of that will be rewritten in Go.
The core pieces of it will be rewritten in Go.
This scripting language, so people can write their own plugins, will support anything that can run on the command line, including probably mostly Pearl.
So, so that's, you know, if you want to add expandability on a, on a Unix or Linux system to assist to something, and you can say, well, you can write it in any shifting scripting language, right?
Or you could, you know, make a compile compatible program in Go.
I'm back and read the chat again.
Lots of, lots of great people here.
How's it going?
Infility?
See, it's moving to Subversion to get.
Are they?
Oh wait, I got some interesting stuff to read.
Yesterday was fun though.
Legacy, yeah.
Um, yeah, yep, yep, yep, yep, yep.
BSD, since free BSD is moving from Subversion to get, it's supposed Pearl will be, will be added back to, you think it's going to be?
I wonder what version it is.
That'd be interesting to know.
I wonder, I bet it's, I bet it's 5.10.
That's the one I'm going to bet they're going to go with.
I think we should probably know.
Which, I could have swore get Bundles Pearl with it.
You know, it makes sense that get has Pearl in it because of how fast it was turned around.
I mean, it was like, it was like he thought of it and then it was done.
So it was like, yeah, it looks like it's been installed with it.
Um, version forget.
Oh, let's look at this one.
Do, do, do, do, do, do.
Let me check this.
Take a, take a pic.
Ah, there we go.
Uh, get on the system which runs.
And the standard version is Pearl 5.8.
Oh my gosh, that is ancient.
Uh, what's important is that Pearl command keeps referring to Pearl 8.8 so that our script run fine.
Oh, let's see.
Get has a dependency on Pearl 5.28.
That's not true.
The docs doesn't even mention it requires Pearl though.
It does require Pearl that we know for sure.
Um, it doesn't say it get depends on who it is.
It says that package requires that.
It says that package requires 5.28.
Okay.
No good answers here.
The proscripts that get runs on beginning with the shebang lines.
And they get sourced.
These lines are user bin pearl.
Yay.
Which is what you should use instead of user bin ENV.
But as you build to get to install it, the source builder replaces these with the correct path,
which is also the right thing to do instead of using bin ENV.
So if you correct password or correct version of Pearl, use it with a bin pearl.
Uh, all right, fine.
What's the version?
God damn it.
Um, anybody know?
Uh, question.
What does it matter so much whether something is installed by default?
Let's say a scripting language takes someone, package manager, away from being able,
it's really important that you have installed something from the fishery pod stories.
Oh, Pearl 5 is greater than equal 5.32.
Really?
Git has a 5.32 runtime dependency?
Holy cow.
So much for no pearl on VSD.
That's like the most recent version.
Wow.
Well, do I need to make my case further?
The most useful, powerful version management system in the world depends on Pearl 5.32.
There we go.
So, and, um, so yeah, it is really important to have it on the remote system.
Yeah.
It depends on what you're making, right?
Uh, if you're, if you're, if you're, if you're a system administrator and you want your script to just be able to work,
you want to SCP the script over and be able to run it or your hacker and you want to be able to do that,
uh, that makes a lot of difference.
I'm going to be able to share your script with somebody else who has also has a Linux machine.
It doesn't have, you don't have to install anything.
The small things make a difference.
There are less and less of a difference in a Docker world now, right?
Most people have Docker installed, but that's usually for larger applications.
So it's different in that space, in that space of, you know, shell scripts on steroids,
Pearl, having Pearl everywhere is a plus.
Uh, but as soon as you go beyond that, as soon as you're making an application,
then it's not as big a deal, right?
Because you, you've got to already bundle and then, you know, the Python virtual environment makes sense,
even though it's stupid, but, you know, you have to bundle everything together.
You have all your dependencies match and everything at that point,
you should just make a Docker container, by the way.
Um, you're running 13 current though.
Interesting.
There's a runtime dependency.
That's really interesting.
You have to report back on that.
That's a really, uh, it's a really interesting question.
Uh, don't go to Pearl.com.
There are a bunch of, uh, it's apparently malware,
which I didn't say that the Pearl community is on top of everything as well as some of our other communities.
They're just, they're tired.
So they're forgetting to renew things and they have like really, really ancient websites.
I was on the Pearl Mager site the other day.
I was like, it needs a facelift so bad.
I was like, you know, because they, I mean, the whole, the whole initiative has lost a lot of its oomph,
because it's not sexy and cool anymore, but, but it's still sexy and cool when it comes to being a powerful shell script.
Stop thinking of Pearl as more than that.
And a lot of the, frankly, a lot of the, the, the Pearl community, you know, the, you know, previous community and current community
still trying to push Pearl for large scale applications development.
And I think that's a mistake.
I think it's a huge mistake.
Um, but again, if you look at Pearl as a shell script language, I'm just going to put it that way.
They're trying to change the version that required, uh, at most it's just looking if you're compliant, uh, when you're, uh, you're closed over.
Yeah, that's probably what's going on with it.
Yeah, it really depends on the dependency there as well.
Uh, this, this particular video has, has, has generated a lot more interest than I would have thought.
So this has been really fun.
I'm going to have to go ahead and cut it short and just want to go read if there's any more questions.
Um, I have to duck down again.
Learning Pearl is one of the best programming books I've ever written.
I agree.
Um, yeah, Schwartz did a great job with it.
It's very, very easy to understand.
It's one of the better, one of the greatest things about Pearl is that all of the documentation has always been really easy to read.
And I told you all the man pages that are there, right?
There's literally a man page on everything and you have to learn man to do Pearl really, uh, to do it really well.
But if you're going to jump into it, do that.
Please don't go overboard though.
I, I'm going to just recommend that you not, there are other very much more important languages for you to learn than Pearl.
Pearl, Pearl is important if you're, if you want to do a lot of shell scripting, you're going to live on the command line.
If you're going to be an SRE, if you're, you know, if you're going to be a hacker, uh, or if you just want to be a terminal power,
user, Pearl is really good, but it wouldn't be the first thing I would learn, right?
Uh, I would, I would have you learn JavaScript first, uh, you know, in the web browser, by the way, not on the command line.
And then I would learn, uh, go as the first compiled language personally.
That's what I'd recommend.
And, uh, I would learn enough shell, uh, to be able to write shell scripts and, uh, and, and then I would, I would learn Pearl to help you out.
But it's a supplementary language that basically turns you into a terminal power user.
And I, and that way, you know, you won't get into the problem of, it's, it's more important that you learn Python than Pearl,
unless you're going to live on the command line all the time.
So, but don't rule it out.
It does have a place that is not filled by any other language.
And that's the recent discovery.
And frankly, I thought Bash filled that spot and it doesn't, it doesn't.
In fact, Bash and I, it was a fun, it was a fun year that I think Bash and I are done for a while.
Yeah.
I'm going to be back to Dash and, uh, Pearl for everything and Python.
Yeah.
Because you have, you have like, you have like POSIX, right?
POSIX shell, which is compatible everywhere.
And then you have Pearl, which is everywhere when you need something more powerful.
You have Python for those enterprise, Python and TypeScript for like those enterprisey kind of scale interpreted applications,
still interpreted language applications.
And then boom, you need some, you need some statically typed compilation stuff.
Go as your friend.
So that kind of go TypeScript and Python kind of all overlap.
And then you need like edgy, high-performance stuff, Rust and C, C++, right?
And you need, you need stuff on the hardware assembly.
Yeah.
And, and that's, that's my spectrum of languages right now.
So, but the distinction between POSIX shell, Bash, you know, there might be a little bit of,
I am still going to use the Bash interactive shell because I want to be able to export functions that do things that I can't do with the shell.
So as a shell, it's still the best interactive shell if you ask me, but, but, but, you know, so that, that's still, that's where I'll be.
If I write any code in Bash, that's where it'll be.
Otherwise it's going to be just in straight up POSIX Dash or it's going to be in Pearl.
And that's, that's a position that I held or Python.
And that's a position I held back in, in 2007.
And I'm just returning to it.
And if you read my blog, it's not a blog.
If you read my notes, if you go to github.com.
And you click on log, you can read some of my lament about going through all of this and how it made me into a very grumpy Gus yesterday, going through this, this, this process of discovery.
And to anyone that I may have offended yesterday, I'm sorry.
I'm just, I'm sorry.
That's all I'm going to say.
Probably time for me to go.
Can we, can we agree this topic is dead now?
Did we kill the camel?
Or did we resurrect the camel?
I was actually really fun for me because I feel like I've given myself permission to use, to use it again.
Just like I gave myself permission in January to use Bash.
So this is what happened.
I gave myself permission in January to use Bash all the ways that I'd been prohibited from using as a, as a system in a developer at IBM for years, because I was forced to use POSIX compliance.
So I'd run on Solaris and AIX and all that stuff.
And, and then I'm going to, I'm going to go, but I'm going to just drop the stream.
I'll be back in a bit.
The stream script removed the R to let off steam.
It was all good.
And so all I want to say is that, you know, that was fun.
It was an experiment.
So I used Bash.
All of Bash is crazy, awesome things.
You know what?
I discovered about CD path, which nobody knows about, which is the same thing that you want out of your, your fish and your Z-shell for automatic CD completion.
Lots of things I discovered about Bash over the last year.
And, and I'm so I'm not, I don't look, I don't feel that was a bad thing, but I gave myself permission to use it after having been told, you can't, thou shall not use that cool Bashism and that Bashism and that Bashism.
And, and I let myself do that and I had a lot of fun with it for about a year.
But, you know, this week I hit a two, those two significant blocks for Bash.
No Unicode support for regular expressions, which Pearl does, and no support for extensive documentation in a script, which Pearl does.
And those two things have caused me to abandon Bash and relook at the whole thing.
And, and so I'm back to using basically pausing shell and Pearl for everything.
And you'll see me doing a lot of code doing that and go, of course.
So I think with that, I'm going to go ahead and put the, the, the dunes, the dunes back on, maybe turn them up a little bit.
Yeah.
Actually, this terrifies my wife.
She's scared of the desert like this.
I'm like, this looks really fun to me.
I'll be back.
It'll probably be about a half an hour or so.
I will be back when I come back.
I'll be doing a lot of Pearl coding actually on the knowledge node utility.
It's called KN.
It's a way of managing your notes and your schedule and everything.
And it's modular so you can expand it and customize it.
It's part of the associated federated knowledge workers, our effort to create tools that are kind of come together on,
building for each other so that we can manage our knowledge better and then share that knowledge over the knowledge exchange grid,
which we call KEG, which I'm going to put a plug in for that.
If you want to be involved with any of that conversation, that's always going to be on Friday.
But in my time as I do my daily routine, I'm going to be doing a lot of, a lot of refactoring of all my scripts directory.
And it's going to be a lot of code in POSIX and in Pearl for the next week or two.
All right.
Take care.
Bye.
Bye.
