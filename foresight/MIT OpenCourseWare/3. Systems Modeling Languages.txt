The following content is provided under a Creative
Commons license.
Your support will help MIT OpenCourseWare
continue to offer high quality educational resources for free.
To make a donation or to view additional materials
from hundreds of MIT courses, visit MIT OpenCourseWare
at ocw.mit.edu.
So let me start.
Session three is about system modeling languages.
But before I start, I'd like to remind you
that A1 is due today.
The first assignment is due today.
And I think neither Ioana or I or Liz,
did you get a lot of questions about A1?
No, I didn't get any questions.
Yeah, so we didn't get many questions.
So I think I interpret that as a positive,
but I guess we'll find out.
Everybody submitted.
OK, well, so we're hoping to have these graded in about a week,
give you feedback, and we'll also post a master solution.
And A2 is out right now.
And the other good news is there's no new assignment today.
The next A3 is going to go out next week, OK?
Any questions about A1?
Was there something that was particularly difficult or confusing,
or was it straightforward?
Anybody want to comment on A1?
Wow.
Sam?
Do you want to push the button?
No, our team thought it was fairly clear
on what we had to do based on the lectures.
OK.
We didn't have any trouble.
Good.
All right, well, let's keep going then.
So the V model is our roadmap for the class.
We're starting to fill in the V. We're still
in the upper left corner.
And today's lecture is actually a little different.
It's sort of in the center of the V. System modeling languages
as a precondition or precursor to what
we've been calling NBSC, model-based system engineering.
So what I'd like to cover today is why do we need
or why have these system modeling languages emerged?
Particularly, what do we mean by ontology, semantics,
and syntax?
And then I would characterize this
as a sampler of three different system modeling languages
that have emerged really within the last 10, 15 years.
The first one is called OPM, Object Process Methodology.
The second one is called SysML, System Modeling Language.
And then the third one is called Medellica.
And then we'll sort of quickly wrap up with the question,
what does this mean now for system engineering today
and tomorrow in the future?
So I'd like to motivate this with a little exercise.
You remember Mr. Sticky from last time?
You came up with some requirements.
So it's kind of the simplest system I could think of here.
So what we'd like to do is have you work in pairs again.
And the assignment here is to describe this system
as clearly as you can, provide a description.
So last time the assignment was write a requirement,
come up with some requirements that led to this design.
But today I would like you to describe
what the system is, how it functions, and so forth,
as clearly as you can.
And I would like you to do this, so hopefully you're
on the WebEx, logged into the WebEx.
I would like you to do this in teams of two.
And as you're doing this, I don't know if you noticed,
but on the WebEx, there's actually a note pad feature.
Where is it?
Tell me.
Left, right.
I see.
So I can't share and use the note pad at the same time.
It's the whiteboard right there.
Annotate?
Yeah, yeah.
But if you go back into view.
Stop sharing.
But then they can't see it, right?
Can they see this?
So you can write text.
You can draw the shapes.
OK, so the reason I want you to do this on the whiteboard
is such that we can then sort of go around
and look at some examples.
So the assignment is take five minutes,
turn to your partner, and try to describe the system.
And then we'll go around and look at some,
I will sample people's descriptions.
Go for it.
All right, so keep working on the assignment,
but do it locally on your computer, not on the whiteboard.
And then we'll sort of discuss it and share it,
and maybe not use the whiteboard.
Because I didn't realize there's only one whiteboard
that we all share.
I thought that you have individually the whiteboard,
and then you can sort of pass it on to different people.
So but if you do it locally on your machine,
then we can share the screen.
So it'll work.
So do it in PowerPoint, or Word, or Sketchpad,
or anything you want.
Sorry about that.
OK, all right, so let's do this.
We're going to sort of go back and forth between here and EPFL.
Let's start maybe over here with Narik.
Are you ready?
So I'm going to give you the ball,
and then you can sort of explain how you guys describe the system.
So what we decided to do was identify the primary function
of the sticky, Mr. Sticky.
So the primary function is to trap the fly, we thought.
This is enabled by a couple of other functions
that are sort of at a lower layer of abstraction.
It's attracting the fly, immobilizing the fly,
transporting the object to where you
need to immobilize the fly, and deploying Mr. Sticky.
And we map this to the physical forms
that enable the function.
So the canister, the physical form of the canister
is helping with the transporting function.
The sticky tape is helping with the immobilizing function.
The scented material, we thought,
that would be helping for the attracting function.
And the hook, maybe on top that you used to hang it,
would help with the deploying.
OK, good.
So nice function form separation,
and you use primarily text, human language to describe it.
So let's see, at EPFL, who would like to share?
And we'll give you the ball.
OK, we can try, maybe.
Who is speaking?
Maxim.
Maxim, OK.
Can we give the ball to Maxim?
Yes, do you see something?
Yeah, it's good.
Oh, perfect.
So we draw the same system when deployed and deployed.
So we begin with the container containing
basically the sticky setup rolled.
Then when unrolled, we have the container
that should be linked to the sticky setup with a stick,
but whatever.
And we have like, an external input from the insects
that come to be sticked onto the.
Yeah, go ahead.
OK, so that's all.
OK, so I'll note here that you guys use graphics, right?
You use some kind of graphical language.
And at the highest level, it's like a state diagram, right?
Rolled, unrolled.
So you show the system in two different states.
Very nice.
Somebody else here on the MIT side,
and then we'll go back one more time.
Who would like to share here?
You see him?
OK.
So let's.
OK, so we did a diagram showing the use of Mr. Sticky.
So we have a user, because Mr. Sticky has
to be rolled and unrolled.
The user installs or disposes of Mr. Sticky.
The flies are attracted to, or Mr. Sticky
attracts the flies, and the flies stick to Mr. Sticky.
And then we decompose Mr. Sticky into the different components
that are below at a lower level.
And yeah, so it's basically at a higher level of use diagram.
So here we have, again, a graphical description.
The states are sort of implied, but you're
focusing on decomposition, right?
The sub-elements.
Very nice.
Anybody else at EPFL did anybody just
write a paragraph of text, or more of like sentences?
At EPFL, who wants to share?
Chris here.
Chris?
OK.
No, we didn't write a text.
The text seemed a bit heavy to convey
a description in efficient terms.
What we prefer to do is decompose in elements,
and for each element, give some properties.
OK.
And did you do this in the form of a list,
or in the form of a table, or how did you actually describe it?
So wait, I'm trying to share the screen.
OK.
All right, so we just walked on the first half here.
We have the band, and we give here properties,
though, so it has to be made of paper or soft material.
It has to be one to one-size meters long, three centimeters,
three to five centimeters large.
It needs to have a coating, which in itself
is a sticky material, and be sanded in order to attract flies.
It needs to have visible color.
And then, well, the other parts here, which I'm highlighting,
would be really related to the packaging.
So a sealed cylindrical container with a single-user
opening, including a hanger, with possibility
of branding on the packaging.
And, well, the non-toxic material
would still refer to the sticky material.
Good, good.
Thank you very much.
This is great.
So what you showed, that's more like a list, right?
And I would describe, this looks like what
I would call a bill of materials, right?
It's essentially a list of the primary elements
of form of the system, but there's
some attributes that are associated.
So this is a list format in the form
of a bill of materials with attributes attached.
So thank you very much.
That's great.
So let's get, I'm going to share here again.
And you're probably wondering, why did we do this?
Why did we do this exercise?
And that's the point I want to make next.
So here's a very simple system.
And we had four examples of descriptions
that were quite different, right?
And of course, if you had more time,
they'd become more complete, but they
would be really different.
So this is fundamentally the issue
that we've been facing in systems engineering
for a long time.
The means for describing our artifacts,
whether it's something simple as a Mr. Sticky,
or an airplane, or a spacecraft, or a medical device,
or even a service, how would we describe it?
Well, first of all, natural language,
the human natural language.
And as we know, the human natural language
is a very rich, right?
There's very different ways in which we
can express essentially the same facts, the same things.
That's a wonderful thing if you're a poet or a writer,
but it makes system engineering challenging,
because it gets confusing when we're describing
the same thing in very different ways.
Or graphical, so we saw some boxes,
and we saw some great examples, sketches, drawings.
So fundamentally, the way we describe systems,
and this gets to the left half and right half of the brain,
is using language, words, sentences, lists, or graphical.
Those are the two fundamental ways of describing systems.
And then we put all these descriptions together
in what we've been calling documents.
We aggregate this in documents.
So examples of documents would be a requirements document.
That's what essentially you're doing in assignment 2,
or a drawing package.
Even if it's in CAD, it's still essentially a document.
So typically in system engineering,
all of this gets assembled into what
we call a TDP, technical data package.
And fundamentally, when you're designing a new system,
you're producing a technical data package that
has software, drawings, descriptions,
and that's the deliverable from the design process
is this TDP, technical data package.
And from that, you should then be able to build and operate
the system with as few errors, mistakes,
misunderstandings as possible.
And fundamentally, as our systems
have been getting more and more complex,
we're now talking about the systems that
need the three, four, five layers of decomposition.
It's very easy to have errors, omissions,
different interpretations of this information.
So that's fundamentally.
But there are advantages.
I don't want to say it's categorically bad
to use natural language and graphics.
They're definitely advantaged familiarity
to the creator of the description.
So it's easy, it's comfortable, it feels familiar.
And also, it's not confining.
So you can be quite creative by creating descriptions
in this way.
But the list of disadvantages is quite long
for allowing an arbitrary description.
The room for ambiguous interpretations and errors,
it's quite difficult to update.
So if you make a change in one description,
that change will not automatically
propagate to the other descriptions.
Handing off these descriptions from one lifecycle phase
to another, there's discontinuities in these handoffs.
Uneval level of abstraction.
So what I mean by that is you may
describe one part of the system in very detailed.
So the last example we saw with the list,
with the Bill of Materials, there was quite a bit of detail
there on the scent and the attributes of the tape.
But at least a couple of the other descriptions
didn't have that level of detail when it came to the tape.
So the level of abstraction could
be quite different in the different ways to describe it.
And then for a complex system, you
can imagine that the volume of information grows a lot.
And so you can walk into any program manager and systems
engineer's office and see bookshelves full of binders,
dozens and dozens of binders with documents,
thousands and thousands of pages.
And many of them are never read.
That's the big issue.
So that's been the kind of way in which we've
been doing system engineering traditionally.
So the idea here is that in order to mitigate, yes, Justice?
Phase A, conceptual design.
Phase B, preliminary and detailed design.
Phase C is testing and launch.
Phase E is operation.
So usually, not the same people do conceptual design,
preliminary design, testing.
So all the technical data package, these artifacts,
have to be transferred and handed off
to new people who then work on the next phase.
That's what I mean by handoffs.
And so the idea is, in order to mitigate
some of these disadvantages of natural language
and graphical description, there has been,
and this has been recognized for a long time,
a need to be more precise, perhaps more confining,
but to create languages that allow us to describe systems
much more precisely.
And so I'll mention a couple of the past efforts.
And you can read about each of these.
So I'll mention bond graphs first, 1960.
This was actually invented here at MIT
by a professor in mechanical engineering.
His name was Harry Painter.
Professor Painter created bond graphs.
You can think of bond graphs as block diagrams
where different blocks have ports or interfaces
where information, material, energy flows in and out.
And you can compose a system out of these blocks.
These bond graphs are essentially,
and Narek will talk about Modellica,
and which is sort of a modern version of bond graphs.
It has other features too, but this has been sort of one
attempt.
Another one that's very well known is IDEF about 20 years
later.
This was created by the Air Force, the US Air Force.
And this is essentially a description of systems
that's very functionally oriented.
So it shows you what functions are involved.
And we saw one of the descriptions
was very functionally oriented and how
the functions of the system relate to each other.
But generally, these system languages
have not fully been deployed.
Some organizations use them, others don't use them.
And the main reason for that is twofold.
First of all, some of these languages were incomplete.
They would focus only on one aspect, like functions
or the block nature of the system, the block diagrams.
And a lot of them were not executable.
So they would be graphical, but you couldn't actually
simulate and actually check whether that description was
complete or accurate.
So since then, and the other thing, of course, important
is domain agnostic.
So what I mean by this is that the system modeling language
should be applicable for any kind of cyber-physical system.
Again, if you're designing a spacecraft, an aircraft,
medical device, any kind of product,
the language shouldn't have to be adapted.
The language sort of covers all these applications.
That's the idea.
So whatever language it is that you're using or developing,
it has to have these three things.
Any language has these three things.
So the first is ontology.
And I reference here the Wikipedia
articles on these things.
Some of my colleagues in academia, it's a big debate.
Is Wikipedia a legitimate source of information,
or is it not?
My position on this is that it is.
I think Wikipedia is definitely not perfect,
depending on what topic you're looking at.
But it's a self-correcting system.
So I actually go to Wikipedia, and then there's references,
and you can dive deeper.
So I give you the Wikipedia links here for these three things.
First, ontology.
So ontology is a very fancy word.
What ontology actually is, Mark, why don't you come up here?
You're an instructor today.
Ontology, fundamentally, is describing the entities that
are allowed to exist in the language.
Subjects, nouns, adverbs, what are the objects, the entities,
that can exist?
It's a very abstract thing, but it's essentially
the library of words and objects that
are allowed to exist in that language.
And then how these entities can be grouped, perhaps,
in a hierarchy and subdivided.
So it essentially constrains the universe of things
you can describe in that language.
The shorter, the smaller your ontology is,
the more confined the language.
Semantics.
Semantics is basically, it's a branch of science,
of philosophy, which is fundamentally
assigning meaning to those objects
that are described in the ontology.
And so the way that we say this is
that it's the relationship between the signifiers.
So the signifiers are words, letters, symbols,
graphical symbols.
So how do we describe a resistor, for example,
in electrical engineering?
A squiggly line, right?
It's the zigzag line.
Well, if you don't know electrical engineering,
or you never, you just see a squiggly line,
it's meaningless to you.
But if you know that semantically,
that means that's a resistor.
That's the symbol for resistor.
That's what we mean by semantics.
And then the third is syntax.
What is syntax?
It's the set of rules, the set of principles and processes
by which the objects or the entities in the ontology
can be combined to build up higher level information,
like sentences, paragraphs, and so forth.
And so that's essentially the construction rules
for the language.
So every language has these three things.
So any questions about this before we
move into our first language?
So we're going to give three examples of system modeling
languages, and you'll see the similarities and differences.
But as you see these languages, keep in mind,
they all have ontology, semantics, and syntax.
Any questions about that?
OK, so OPM.
Let me describe to you OPM.
This is one of the younger languages.
And so OPM stands for Object Process Methodology.
And it was created by Professor Dov Dory at Technion,
colleague of mine.
Dov is essentially a computer scientist by training.
And you'll see the heritage here of OPM.
And the big news here about OPM is OPM
is not that well known yet.
If you ask around, not too many people know OPM.
But I predict that in the next decade,
that will change very quickly.
And one of the reasons is that OPM was just now
adopted as an ISO standard.
And if you know ISO, the International Standards Organization
that are located in Geneva, it's a big deal
to become an ISO standard.
It took like five years, the whole process,
with committees and reviews.
And so the ISO standard is actually,
OPM was adopted as an ISO standard
as a means to describe and develop other standards.
So it's kind of a meta language.
Because as you can imagine, when you
read different ISO standards, which by the way
have a lot of influence, they're also
written in natural language and graphics
and lots of inconsistencies.
So the idea is that future ISO standards
should be written using OPM, such that they're
clear and consistent and so forth.
So the history here is that if we go back further,
there was UML, which is Unified Modeling Language, which
I'm not going to talk about today, is a software.
This is a language that was developed primarily
for software engineering.
To consistently describe use cases,
to consistently describe activity and flows in software,
the structure of software.
But it's really software-centric.
So from UML2, we then sort of branched off
into CISML, which Mark showed us, who just joined us.
We'll talk about.
And then OPM.
So these are sort of derivatives of UML.
And there's a book.
It's not one of the mandatory books for this class, OPM 2002.
If you're really interested in OPM,
I recommend you invest in that book.
It's really very well written.
So let me give you an example of how
OPM can be used.
So like we said, typical product representations
are sketches, engineering drawings, or UML diagrams
in software, but the need for a unified representation.
And fundamentally, we have functions,
and then we have objects, form, and function in systems.
And so what we would like to do, and what the premise of OPM
is that we can show everything in one diagram type.
So the functions, the functional attributes, the objects,
and there's different types of objects, operands, system
components, consumables, the attributes of those objects,
and then the links.
And I'll show you the different types of links
between these that exist in OPM.
So it's a generic modeling language,
and it has been successfully applied
to system architecting of complex products
in different organizations.
I'm going to try to give you a pretty simple example here,
which is a refrigerator.
So think about it.
We're going to look at a small household level refrigerator
through the eyes of OPM.
All right, so here's the basic ontology of OPM.
It's very, very simple.
And the idea is to have as few objects, as few entities
as possible in the language to keep it simple.
So the first one is the idea of an object.
What is an object?
And objects are drawn as these rectangles.
Objects are defined as entities that
have the potential for stable, unconditional existence
for some positive duration of time.
And objects have states within them.
So what would be an example of an object
that we've talked about today?
Go ahead.
Maybe the sticky tape.
Yeah, so the sticky tape itself, that's an object.
It exists unconditionally.
It's there.
And what's important is it could be a physical object.
So it has a physical existence.
But it could also be an informational object.
So for example, if you have an idea,
or a vision, that's an object, too.
It's not physical in that sense.
But it does exist as an informational object.
What are states?
Let's see it, EPFL.
What would be an example of a state that's
associated with an object?
Yeah, that's OK.
Can somebody give an example of a state?
Rolled and unrolled for the sticky tape?
Rolled and unrolled, exactly.
Or furled and unfurled.
So that's kind of a binary state.
There could be halfway unrolled, or the sticky tape
is full of flies, or it's kind of empty.
Those would be describing the object
in terms of what state it is in, exactly.
So the form is then the sum of all these objects.
So that's one building block.
And then processes are the other.
So what are processes?
Oh, is there another example?
Yeah, go ahead.
Can I ask a question?
Is this Katya?
Go ahead.
Katya, what do you mean by positive duration of time?
Well, meaning that, so the object could be created, right?
It didn't exist before.
It's created, and it exists, and then it could be destroyed
again.
It could disappear, or it could be consumed.
But it means that the object needs
to exist for a non-zero period of time
in order for it to be called an object, right?
So objects in the world that can be described with OPM
fundamentally, objects can be created,
objects can be modified, particularly their states
can be modified, and they can be destroyed or consumed.
That's basically it.
That's a complete set, OK?
Does that make sense?
OK, so processes are, what are processes?
Processes are really fundamentally different
from objects.
Processes are shown as these ellipses,
and they're the patterns of transformation
applied to one or more objects, and processes change states.
So processes, unlike objects, cannot exist on their own.
Processes only make sense if they're
associated with at least one object, OK?
So processes are essentially the functions
that we develop in systems are processes that transform
or create, destroy, or transform objects.
So function emerges from one or more processes,
and then we have different links between objects
and processes.
I'll show you two examples here.
One is the arrow with a pointy head, OK?
That could be a consumption or production type link,
or a link with this little lollipop symbol.
This is known as an instrument link.
And so the difference there is that if an object is
linked to a process using an arrow,
it means that something's happening to that object.
It's being created or destroyed or modified.
If an object is linked to a process using the lollipop
symbol, the instrument link, it means
that in order for that process to happen,
this object is needed.
It's an instrument.
But the object itself, the instrument,
does not get modified in any way by the process.
But the process couldn't happen if that object didn't exist.
Do you see the difference?
And so one of the really, I think, important things
about OPM, but any of the languages,
is that every box, every arrow, every link
has precise semantics.
And usually, when we doodle, when we just think about it,
we put arrows and links between boxes,
we often don't really deeply think,
when I put a link in here, what does that link actually mean?
What does link imply?
So when you do system modeling using these languages,
you become much, much more precise.
Yes, please.
And would you push the mic button when you?
Mark, go ahead.
Can an object be a process or a process be an object?
No.
So what about if you have, I guess
I'm thinking in terms of if there's
some process for doing some procedure,
and you're assembling a satellite or whatnot,
you need to modify that process.
So how is that sort of thing represented in OPM?
The process modifies objects, but processes cannot modify
other processes, because processes
are fundamentally in OPM acting upon the objects.
Now, processes can invoke each other.
So if there's a sequence of processes,
you have to do this assembly step before this other assembly
step, you can have what's called an invocation link.
But that's a logical dependency between processes.
But fundamentally, the processes
act through the objects in OPM.
OK.
So let me be a little bit more.
So let's go into some more detail.
So at a high level, when you look at the economy,
right, products, yes, go ahead.
I have a question.
Why create another language and not just stick with UML?
So good question.
So we'll talk about SysML, which is very similar to UML.
It's sort of generalized for cyber-physical systems,
not just software.
So the reason that OPM was created,
because UML was found to be somewhat too confining,
this is more general, and also the idea
of a unified representation, one type of diagram
and description for any application.
So it's basically a kind of more general version of UML.
But the other really important thing about OPM
is that the processes are often in object-oriented thinking.
Processes are embedded inside objects.
And in OPM, the processes have been emancipated
to stand at the same level as objects.
Those are the main differences.
So let me go in a little bit more detail.
So if you think about the economy in general,
goods and services, goods are objects,
and services are processes.
So if you buy a new iPad or a new pencil or whatever it is,
you're actually buying an object.
You're purchasing an object.
That's obvious.
But why are you purchasing that object?
So let's say you're buying a new tablet.
You're buying the tablet.
But why are you buying the tablet?
Sam, go ahead.
You're buying the tablet to perform an action
or process on something else, to do something.
So what do tablets do?
I mean, not stone tablets, but modern tablets.
They allow you to work with software or communicate.
Yeah, so they're information processing.
They're information processing devices.
And there's an argument.
Tablets are great for consuming information.
They're maybe not as good for generating new information.
So fundamentally, you're purchasing the tablet,
which is an object, in order to be
able to do information processing,
and information consumption.
So the process is then implicit, right?
What's an example?
If you purchase a service, what would be an example of a service?
What would be an example of a service?
Let's see at EPFL.
What would be an example of a service that you could purchase?
Going to the dentist.
Going to the dentist.
Yeah, one of our favorite things to do.
So have you been there recently, or?
Yeah, one month ago.
So I don't want to violate your privacy,
but can you share with us what happened at the dentist?
Usually, it's the yearly checkup.
You have to check that there's no hidden,
I don't know how do you call it in English, the caries?
Yeah, cavities.
Yeah, cavities.
Check that wisdom tooth don't mess up
what you've been walking on tirelessly
when you were younger with braces.
And also these kind of things, get checked.
Very good.
So going to the dentist provides a service, which
is either checking your teeth, or filling cavities, which
is a process.
And all the objects, the chair on which you sit,
the instruments, I guess we still use gold sometimes
in some places, those are objects that
are used in the performance of the service.
You see the relationship?
So objects and processes always come in pairs.
Thank you for that example.
So let me talk about the links in OPM briefly.
So there are two types.
There's the structural links, which link objects to objects.
And we typically use arrows, is related to,
or we can tag these as well.
So for example, something powers something else.
This is known as a tagged link.
It suppresses the processes.
And then there's these triangles that are essentially,
there's a kind of hierarchy implied there.
And slightly different meanings.
So the solid triangle means decomposition.
So the higher level object is composed
of lower level objects.
So that's Mark, you mentioned assembly.
You're creating the bus of the spacecraft,
and it has a whole bunch of stuff in it.
Well, you would use this filled in triangle
to show that decomposition.
The second example is the characterization link.
So this is essentially relating an attribute
to its kind of master object.
Specialization and generalization is the empty triangle.
And then this funny symbol here is instantiation.
So essentially you have a general object,
and then you can instantiate that.
So I have two children, okay?
And then there's two, I have two children,
which is general, and there's two instantiations of them.
One of them is called Gabrielle,
and one of them is called Christian,
and they're actual people.
So that's the idea of instantiation.
Processes, processes are these patterns of transformation.
They're tricky.
Processes are trickier to understand than the objects
because we cannot hold or touch a process.
It's fleeting, and the creation change
or destruction of objects is what processes do.
They rely on at least one object
in what we call the pre-process set.
A process transforms at least one object,
and the time is implied.
So processes take along a timeline.
And in terms of the description in English,
we use the so-called gerund form.
So all the processes,
there's some examples on the right side,
use the ing form of a verb.
So we can then put these together, objects and processes.
So here's an example of a machine.
This happens to be like a printer or copy machine.
It has a main switch.
The main switch has an attribute called main switch state,
which can be on or off.
The process of switching transforms, in this case,
the main switch state from on to off,
or we could go the other way.
And in order for this to happen, we have here,
this is actually slightly different than the instrument link.
This is a filled-in lollipop,
which is known as an agent link.
So the operator is an active agent
to carry out the switching process,
which changes the main switch state
from on to off or off to on.
And the main switch state is an attribute
of the main switch, right?
So transporting, this is another example.
Transporting changes the state of a person
from being here, location A,
to being there, location B.
So there are seven, huh, coincidence,
seven, seven object process links in OPM.
So P changes, the process changes the object,
say from state A to B,
that's the example we just looked at.
You can actually hide that.
If you're really not interested in all the states
and details, you hide the states.
You don't wanna see them.
And then you can replace that
with what's called the affect T link,
which is this two-sided arrow.
And all you know is that this process
is affecting that object, right?
And it's a two-sided arrow.
But you don't know exactly how,
but you know it's affected.
A result T link, so this is an arrow pointing
from the process to the object,
means that the process of transporting
produces emissions, right, that weren't there before.
So that's a result T link.
But the process of transporting
requires or consumes energy.
So the arrow is pointing from energy
into the transporting process,
because it's being consumed.
I did mention the agent link,
so there's an operator of a vehicle.
And this, you know, when we talk about
autonomously driving vehicles, big topic right now,
actually it was cool at EPFL this summer,
there's the autonomous shuttle right on the campus,
the electric shuttle, did anybody take that?
Did you guys try that shuttle this summer?
Yeah, did you like it?
No, I didn't, but the friend is working
in this kind of shuttle, like sitting for hours
waiting for people actually.
Okay, so fundamentally, I mean,
if you wanna think of this in OPM language,
driverless vehicle is basically eliminating this, right?
No longer needing an operator with an agent link
and replacing this with a piece of software,
which would be an instrument link.
So the instrument, the transporting process
requires a vehicle, and then we have what's known
as a conditional link.
So this process can only occur if this object
is in that particular state.
So this example here obviously ignores
the existence of credit cards.
So you can do the purchasing, purchasing,
the process of purchasing is conditional
upon the state of the object money
being in a state of enough for doing the purchase, right?
Okay, so here's an example of a little bit more complicated.
This is a level zero OPM diagram of a car, of a vehicle.
So you can see in the upper right is sort of a sketch
of a vehicle and it has these different attributes.
ED is engine displacement, height, ground clearance,
overall length, wheel base.
There's a trailer here with a towing capacity.
So the way you would interpret this
is that we have a transporting process.
That's our master sort of the highest level process.
And it changes the attribute location
for driver, passengers, and cargo from A to B, right?
And that's fundamentally where the value is
for the owner of the vehicle.
And then we can zoom in to the transporting process
and look at sub-processes, towing, propelling, and housing.
And if you think about what a vehicle does
at the highest level, right, it protects you,
it houses you, and it propels you, right?
Those are, and then you can break those into more detail.
And then on the left side here,
we have essentially the elements of form.
So the automobile, which is an instrument
of the transporting process,
can be decomposed into its major subsystems,
powertrain, chassis, body, wheels.
And each of those are characterized.
You see those attribute links?
Characterized by things like fuel capacity,
engine displacement.
This is the design domain we talked about last time, right?
Ground clearance, and so those are the design variables.
Those are the parts and assemblies.
And then on the right side, the processes,
the internal processes can also be characterized
by performance or functional attributes,
like towing capacity, fuel economy, acceleration.
PV stands for passenger volume and cargo volume.
And those are things, you know,
when you're comparing different vehicles to purchase,
you know, those are the things
you would compare vehicles against.
So those are the internal functions,
and then the functional attributes.
And then up here, there's the fuel and emissions
and safety-related issues,
which that's often where the governments intervene
and then regulate.
And, you know, this is sort of a highest level OPM
of a vehicle.
And then if you want to see more detail,
you would start drilling down into these.
And you'd have multiple levels of these,
like a higher key of these diagrams.
Yeah.
So here, what is the use of the,
or the meaning of the open arrows in the,
it looks like there's a couple different arrows here
than what we had in the other guy.
Are you talking about these guys?
No.
Oh, these here, yeah.
So they're, it's just a visual,
there's no distinction on the arrows,
whether they're filled in or empty.
That's just a kind of graphical thing.
Yeah.
Okay, so one of the, yes, Veronica,
do you want to push the,
how would you represent a process
that creates kind of a temporary state?
So if you were, if you're saying,
this is acted on an object and this changes
the form of the object,
but the object will ultimately return
to its original state,
kind of absent of a reversing process,
if it's a natural tendency for the object to return.
How would you represent that change?
Would you need to break it down
as a kind of a sub-process within the object or?
Right, so, I mean, and this,
there's sometimes there's multiple,
is there's non-uniqueness
in sort of representing the same thing,
but there's one process that brings you
to the temporary state.
Okay.
And then there would be a restoring process
that restores you back to the original state.
Does the process have to be a separate plan
within the system?
Because there are certain objects, right,
that have a tendency,
I'm thinking primarily kind of a chemical states
where reactions would happen naturally.
And it's kind of a specific thing,
but I was thinking about how you might model
different systems.
And I was thinking about the engine of the car,
just kind of how things might naturally return.
So do you have to describe the process explicitly
if it's not something that's inherently designed in,
if it's kind of a, if it will happen anyway?
I think, I wouldn't,
I wanna say you have to explicitly define that.
Okay.
So if it's a man-made process, so to speak,
then that's a process you want to happen.
And then if the restoring it back to some other state
is a natural process, well, it exists, right?
So it will restore the system to a prior state.
That process would also have to be modeled.
Is there a distinction between how you would indicate
a man-made process or a natural process?
Not fundamentally.
Okay.
And in fact, OPM's been applied
to modeling how a cell functions.
So there's some pretty recent work on,
cells are incredibly,
the biological engineering is just really complex.
So it's some really recent work on describing even,
the RNA and cell division using very much this language.
Okay.
So it doesn't matter whether it's an artificial process
or a natural process.
Thank you.
Okay, let me go a couple more minutes
and then we'll take a short break
and then we'll talk about SysML and Modellica.
So the key thing in OPM is there's only one type of diagram
and there's also natural language that gets auto-generated.
And I'll show you this very quickly in the tool.
So as you can imagine, as you're working on real systems,
you know, these diagrams, if you showed them on one,
one sort of level, you'd have thousands of objects
and links, it would be a mess, right?
So how does OPM handle complexity?
There's three fundamental mechanisms.
One is known as folding and unfolding.
What does that mean?
It's basically related to the structure.
So folding, unfolding means that higher level objects,
you can show the decomposition of the objects
or you can hide it.
That's known as folding and unfolding.
Then the second one is called in-zooming or out-zooming.
And so here's an example of a,
here's a process and an instrument and an affectee,
right, that's affected by the process.
I wanna know what are the sub-processes in that process?
So you can zoom into this process
and it will expose the sub-processes
that are happening inside.
That's known as in-zooming
and then going back the other way is called out-zooming.
And then the third one I've already mentioned,
which is that states can be expressed or suppressed
or hidden depending on your interest
in what states of the system you wanna look at.
So here's the sort of level zero OPM of our refrigerator.
I said that was kind of our case study.
So how does the refrigerator work at the sort of level zero
is that's what the stakeholder with the customer sees.
Don't care about the details of what's happening
in the refrigerator.
So we have food and we'll get back to this I think next week
in the kind of creativity concept generation.
Why do we have refrigerators fundamentally?
If you've heard this before, you keep quiet.
Maybe EPFL, why do we have refrigerators?
Any ideas?
Go ahead.
Keep food cold.
Yeah, well, if you're a beer drinker,
you want cold beer, right?
But if you really think about it deeply,
that's not really the primary reason, right?
The primary reason is this state change,
their shelf life, right?
So the primary reason why you have refrigerators
is to extend the shelf life of the food, right?
So speaking as a systems architect, system engineer,
a refrigerator is a food spoilage rate reduction device.
You see that?
So the attribute of the food is the shelf life
and we're gonna extend the shelf life of the food.
That is, if you think about it sort of architecturally,
that's why we have refrigerators.
But I agree with you on the cold beer, right?
We all agree we want cold beer, not warm beer.
So you're right, you're right too.
So the refrigerator essentially is an instrument
of extending the food shelf life.
So the food is the operand.
The food is the operand.
The extending of shelf life is what we call
the primary value delivering process.
That's where the value is.
The refrigerator itself is the product system.
And then the operator sets the thermostat setting
at which temperature the refrigerator should be.
And then here we have the primary operating process,
which is what allows us to keep the temperature
of the food at that level.
And in order to do this, we consume electrical power,
we produce waste heat, and we also require
or we convect that waste heat to the exterior air
at a certain temperature.
How well do refrigerators work in a vacuum chamber?
They don't, right?
They don't.
Well, I guess you could radiate the heat a little bit,
but they're not gonna work very well.
You're not gonna have conduction, right?
Because you're sort of in the middle of the vacuum chamber.
You're not gonna have convection,
so you only have radiation,
and it's not gonna work very well.
So the exterior air is important
for the refrigerator to work.
So then you say, well, okay, that's fine, I buy that.
But now I wanna really know, how does it really work?
So you say operating, the refrigerator is operating,
but I wanna do in-zooming and understand how is it operating?
So what's the key to refrigeration?
What's the magic word there, or two magic words?
Yep, that's part of it.
That's just a sliver of it.
Heat exchange is part of it.
So the magic word is carno cycle, right?
So here's a little graphic that sort of gets into it.
So the carno cycle is actually a thermodynamic concept, right?
Where you're compressing essentially a refrigerant,
you're a coolant is being compressed,
absorbs the heat from the inside,
and then expands and condenses and radiates that,
or convects that heat to the outside.
So here's a, I don't know if you remember
your thermodynamics, right?
This is a classic PV diagram.
You've got the four legs of the carno cycle,
and actually what's really nice here,
so we're going through this counterclockwise,
what's really nice about it is that every leg of the carno
cycle is one of our processes, right?
So compressing is this leg here from D to B,
condensing is from B to A, expanding from A to E,
and then evaporation happens from E to D.
So the carno cycle can be decomposed
into four sub-processes, right?
These are the internal processes in the system
that are governed by physics.
So if we take that operating process
that we looked at before, we can actually
zoom in and see the sub-processes emerging.
And so in cooling, we have those four expanding,
evaporating, compressing, condensing,
but I'm adding the absorbing process,
which is that the heat then needs
to be absorbed by the exterior air.
We have to power the device.
You can decompose that into grounding, protecting,
supplying, regulation, keeping it at the set point.
You can decompose that process into sensing, switching,
and setting the set point.
And then we have supporting, which
is we need to be open and closing the refrigerator,
retaining it, and then connecting all the pieces.
At level minus 1, we had one process at level 0,
which was operating.
The refrigerator is operating.
And then as we zoom in to level minus 1,
four processes appear, powering, regulating, cooling,
and supporting.
And then at level minus 2, we have 15 sub-processes.
So this is a view at level minus 1,
our four sub-processes, cooling, powering, regulating,
supporting, and then we can zoom in more.
So here's the general idea, and we've
looked at many systems over the years,
that most cyber-physical systems, or it says
optomechanical here, but I really mean it more generally,
have this kind of OPM structure.
On the right side, we have the output
that the customer, the stakeholder, cares about,
the operand.
We have a set of specialized processes,
and these can be often organized in a cascade.
And then we have supporting processes,
like powering, connecting, controlling,
that provide support for the specialized processes.
Most systems that we've seen have this generic architecture.
How do you generate an OPM?
Fundamentally, you can do a top-down.
So you start with your stakeholders.
That's what we did in the first lecture.
Where's the value?
You start thinking about requirements, what functions,
how well the functions should be performed,
and you sort of go down.
Or if you already have a system, you can actually
reverse engineer that system.
And from bottom up, we started doing for the Mr. Sticky,
and that's fundamentally reverse engineering.
So just for time, I'm going to skip this demo.
But what I will do is I will post a video.
I'm going to make a little video with the OpCat demo
and post that to Stellar, so you can sort of watch that.
So this is one of the, it's still not super mature,
but it's a Java-based program called OpCat
that allows you to generate object process diagrams
in its computer-supported environment
and store them in an XML format and so forth.
It allows you to create a hierarchy.
And the other thing that's very cool,
it auto-generates text.
So the text is called OPL, Object Process Language.
And right now, you can go from the graphics to the text,
but you can't go the other way.
And so there are complete sentences.
It's not like an exciting novel when you read it,
but it is semantically precise.
So we're going to switch to SysML.
We're going to take a very short break.
Are there any questions about OPM?
In the system architecture class,
we spend like five, six lectures on OPM,
and you get to do detailed exercises.
We kind of don't have time for this in this class,
but hopefully you've seen what it is.
And if, you know, I've wetted your appetite for OPM,
then the goal's been met.
Any questions about OPM?
Is it pretty clear?
All right, so let's take, yes?
Compared to Modellica, because I've
seen one of the links that this OPM is just
for describing the system there.
It's not for making calculations or simulations.
That's correct.
There are the latest versions of OPM.
You can do like a logical simulation.
So you can say, OK, this process enables and does this thing.
So it's kind of a discrete logical,
but usually it's not used for any mathematical calculations.
It's really the purpose of OPM is really
to support conceptual design, early conceptual design.
That's correct.
OK, Mark.
So just a couple words about Mark.
He's a doctoral student right now in the space systems lab.
He's been working a lot on an instrument called Rexis.
I guess you're the chief system engineer, right, for Rexis.
And that was also the topic of his master's thesis.
So Mark really knows what he's talking about.
He knows SysML quite well.
And thanks for doing this.
OK, so let me start by giving kind of a high level overview
of what SysML is and what it aims to do.
So it's similar to OPM, but there
are a couple important differences.
SysML, as Ollie said, it kind of is an extension
or inherits a lot from UML.
And its aim is to really provide a language that
enables you to capture all the different aspects of information
about a system in one place.
And this concept of single source of truth
is something that I'll kind of try and emphasize
through my presentation.
The idea is if all your information is in this one model,
then communication is easy.
There's no ambiguity between versions.
Everyone knows where to go to get the most up to date
and correct piece of information.
So that's one of the emphases of SysML.
SysML is a graphical language similar to OPM.
It's defined in terms of diagram types
that I'll go into in a second and has more than just one diagram
type as compared to OPM.
But basically, it aims to do things
like capture functional behavioral models,
capture performance models, capture
the structural topology of your system, the parts of your system,
and how they're all interconnected.
And any other engineering analysis model
is one of the big emphases with SysML
is integration with external analysis tools.
So if you have a thermal tool, a structural tool,
electronics tool, something like that,
integrating this informational, descriptional model
with that analysis model and enabling,
making it easy to transfer information
from your descriptive model to your analysis model,
do an analysis, and then incorporate those results
back into your descriptive model is one of the things
that SysML really is all about.
And another thing, another difference compared to SysML
from OPM is it incorporates requirements pretty explicitly.
And that's one of the other areas
that people are really interested in
is if you have good modeling of requirements,
what sort of information can you glean about your system
that you couldn't otherwise?
How do I advance this slide?
Oh, there we go.
OK.
So as I said, SysML is composed of diagrams.
I'll go into in a second what each diagram, what
all the diagram types are and what their intent is.
But here's kind of a high-level overview.
It might be a little bit difficult to read.
So at the top, you have a system model.
You have requirements diagrams, behavior, structure,
and parametrics.
Within requirements, there's actually
a specific requirements diagram that's
supposed to represent the relationship between requirements
in your system.
I'll show you an example of that.
In behavior, there are diagrams that describe
kind of the activity of your system,
the sequence of events that may happen.
There's a state machine diagram.
If you want to model your system as a states
and transition between those states, things like that.
In the structure, there's diagrams
that go over the decomposition of your system, what
is your system, and what parts make up your system,
both the logical decomposition and the physical decomposition.
And then there's a topology, how are they all connected,
where the interfaces, where the characteristics of the interfaces,
things like that.
And then parametrics, which is kind of adding constraints
and numbers to all these things, whether they be logical constraints,
mathematical constraints, things like that.
Similar to OPM, SysML has no built-in analysis capability,
so you can't run a model or calculate an equation in SysML.
You can't really do that.
But very frequently, the tools that implement SysML that I'll show you
have that kind of analysis capability built into the tool
as opposed to the language.
So you can do things like use a parametric diagram
with a bunch of equations to create a system of equations
that you then can solve, whether it be in the tool,
or you can move it to an external tool like Mathematica
or something, solve it, and then bring that information back
into your system.
You also can do kind of sequence-based computation
if you have a activity diagram that says, first, you
have to build this part of your system
and then this part of your system.
There's things in sequence, things in parallel.
You can run simulations like that, where it's all about,
have you done everything you need to do to get to the next step,
things in a more logical flow as opposed
to actually mathematical equations.
You can do those sorts of computations as well.
One note is that these diagrams, although they
are the main way to define your system
and interface with the model, are not the model themselves.
So you can create links between diagrams
if an element shows up in one diagram
and that element shows up in another diagram.
That's the same element.
If you make changes in one diagram,
that's going to propagate to all your diagrams.
So there's kind of a database back into this whole,
into the model that encompasses all the information.
So instead of having a bunch of isolated block diagrams,
they're really just views into this model that's
hidden in a back-end database.
OK, so I'll talk a little bit about the applications of ZISMO.
First is requirements engineering.
As I said, when you can explicitly model
requirements in the relationship between requirements
in your system, you can do a lot more.
The way that it's typically done nowadays
is with tons of documents.
I'm not sure if you've ever actually developed a system,
but there's an ungodly amount of documents.
I've experienced that firsthand.
It's a real pain.
There are tools like DOORS that will enable you to link
requirements to other requirements and things
like that that help you manage your requirements.
But what if you had a really explicit tie
between your requirements and your system?
You can actually represent in ZISMO,
and I'll show you a little bit about this.
You can represent in ZISMO a textual requirement.
The mass of your system must be less than five kilograms
or something like that.
You can tie that requirement directly to the mass property
of your system.
You can kind of envision you can start building constraints.
Requirements aren't just textual statements.
They're actually constraints upon properties of your system.
Those are the types of things you can start to do with ZISMO.
You have a question?
Yeah, so that isn't something that's built into the language,
but that is something you can do with basically there's
a whole API, and you can interface with the model.
I'll show you this, actually, in my demo.
But you can build in rules and constraints that say,
check, for example, that all my requirements, at least,
have they been defined are satisfied.
You can run that check, and it will tell you
have they been satisfied or not.
And that's something that's really powerful
that you can't really do with existing kind of techniques.
Yeah.
Thank you.
And can you also, let's say, for example, requirement
changes, like the mass of your system
has to be this much as opposed to this much,
then would it go through and check until you have to now look
at this, this, and this, and then that effect?
So you're getting down in the weeds.
That's something that'd be awesome if you could do, right?
That really, again, that's not something
that SysML enables you to do natively,
but it gives you the language and the syntax
to be able to write queries that give you
that type of information.
That's kind of where the cutting edge is right now is,
can we do that?
Can we get that type of information from a system
and model?
That's something I'm really interested in for my PhD thesis.
So yeah, that's something that I think is possible
and would be really great to have in the development
process of a system.
So the next bullet here is on system description.
So actually, one of the fundamental questions
is, how do you describe a domain-specific system
within SysML?
I'll show you that SysML has a pretty strong notion
of inheritance in classes and things like that.
It's obviously oriented.
And so one of the questions is, I'm in the space system,
so how do you describe a spacecraft in SysML?
SysML is very general, but how do you actually represent,
for example, a C and D H system in SysML?
What are the types of attributes that are typically found?
How do you represent that?
How does it interface with other parts of your system?
Those type of questions, that's another active area
of research, domain-specific modeling.
And then finally, as I said, integration
with external analysis tools.
So there's quite a lot of papers in the literature
about going from a SysML model to MATLAB, to SDK,
to thermal desktop.
External modeling tools, taking that information out
of the model, doing an analysis, putting it back in the model.
And actually, I think Nara's going
to talk about Simscape, which is a kind of analysis tool,
external analysis tool.
And there's actually been papers written on how do you take
SysML information from a SysML model, pull it into Simscape,
process it, and put it back in the model.
OK, so let's talk about the diagrams.
There are nine types of diagrams in SysML.
And I'll try and just give you a brief explanation
of what they do.
I won't go into the syntax for all of them,
because there's quite a bit of detail in the syntax.
But I'll show you some examples of a couple of them.
So I'll go from left to right.
So there's two main classes, behavior and structure,
similar to OPM.
In the behavior diagram, you have a behavior diagram
category.
You have activity diagrams, which are basically
represent flows of activities.
So you do this, then you do this, then you do this.
Those can be tied to system elements.
If this system element has this sort of function or property
or performs this operation on another part of the system,
you can represent that link as well.
There's a sequence diagram, which is more about logical
ordering.
So if you have, for example, a multi-threaded software system,
and you have different threads that may need different other
threads to communicate with them or finish their computation
before that thread can execute things like that,
you can do that interfacing between
different threads of activities in a sequence diagram.
This is one of the diagram types that was inherited directly
from UML.
So it's a very strong software element to that diagram.
There's a state machine diagram.
So obviously, state machines are very powerful.
If your system has various states,
if things in your system have various states,
you can represent that in a state machine diagram
and then talk about what are the criteria for transitioning
between states.
What would trigger or cause a transition between states?
What are guards that must be met before you
can transition states, things like that,
that we'd represent in a state machine diagram.
These type of diagrams are very powerful for describing things
like concept of operations.
So there has been some work.
I did an internship at JPL a couple of summers ago,
and they were trying to build up this capability
to model a concept of operations for a spacecraft.
So what are all the power modes of everything?
What are the time?
It spends this amount of time in this power mode,
and it transitions here over, for example,
like a given orbit of a spacecraft.
That's the thing that you can do with this set
of behavior diagrams.
And then use case analysis.
Again, it's mostly focused on early concept development,
stakeholders, how do they interface with the system?
Where do they derive value?
How does the user interact with the system, things like that?
That's what you put in the use case diagram.
Going over to structure, the block definition diagram
is where you define the structure of your system.
So the logical or physical decomposition,
I'll show you an example of this.
So every system is a spacecraft.
It has various subsystems.
If you want to decompose it logically,
it has a thermal subsystem, a structure subsystem,
ADCS subsystem, things like that.
You can also decompose it physically.
So your spacecraft has solar rays.
It has instruments.
It has thrusters, things like that.
You can represent those types of things
in a block definition diagram.
And then internal block diagram is
where you describe the ties with the interfaces
between all the components of your system.
And these can be at varying different levels
of abstraction, as I'll show you.
Parametric diagram is kind of a sub-diagram type
of the internal block diagram.
So you can, again, put constraints, mathematical, logical,
things like that on your interfaces
and begin to build up the infrastructure for doing
computation in the model.
And then a packaging diagram is not terribly important.
It's really focused on the organization of your model,
how do you scope things.
It's kind of a modeling diagram, as opposed
to a representation of your system.
Then last of all is a requirements diagram up top.
So again, I'll show you a good example of this,
but that's where you represent how your requirements are
related to your system.
And then you can see here what's been modified
and what's been taken from UML and the new diagram types
of requirement in parametric.
There were a couple of diagram types
that were eliminated from UML that were pretty software
specific.
I think there is one called the deployment diagram,
like how has your software been deployed across various servers
or users, things like that.
That's not really, that's a pretty software specific thing.
So in a general system, you might not
care about that all that much, so that diagram was removed.
So let me quickly go over some of the syntax.
So this is an interface block diagram, an IBD.
This is the type of diagram that I find
is really interesting, representing these interfaces.
So here's the system engineering ontology
we typically talk about.
So these are, this is basically a model of an avionics board.
So you have things like voltage converters.
You have memory, the volatile, non-volatile.
We have a FPGA, which is our main computational unit.
We talk about these as being parts of a system
in terms of a system engineering ontology.
Then these are these interfaces or these lines right here.
So in SysML, the way we talk about it
is these are part properties of the system.
It's kind of like an instantiation type of thing.
What we're saying is all of these parts
can represent independent of each other.
And then you define a property of that part
as being part of a different part,
if that makes any sense at all.
So for example, this is a board, right?
This main electronics board is this whole block.
And then it has sub-blocks within this block,
which represent the sub-parts that make up the board.
These are called part properties of this overall block.
We have these green little boxes, which are called ports.
And again, that's to support this kind of system
independent modeling.
So you can model like a voltage converter,
independent of any type of system.
It has maybe an input voltage and output voltage.
You can define what ranges those are, things like that.
And you can model those interfaces using ports.
And then these connectors, which are called connectors
in SysML, which represent the interfaces,
represent how each part is tied into the larger system.
And you could, for example, check that you
don't have any empty ports.
If a part needs an input voltage,
you could run a script that checks
that all the parts have all their ports satisfied.
That's something you can do with SysML.
OK, so before I get into the case study,
I want to talk a little bit about what you're going to see.
As I said, I work on something called
REXIS, which is the Regolith X-ray Imaging Spectrometer.
It's an X-ray spectrometer that's
flying on NASA's OSIRIS-REx asteroid sample return
mission.
I've been working on it since 2011, when I was a senior here,
all throughout my master's and then now for my PhD.
Basically, we're going to measure X-rays that
are fluoresced from the asteroid surface
in order to tell what the elemental composition
of the asteroid is.
So that's our main science goal.
And that will basically enable us to categorize
where the asteroid is within the different meteorite types
that have been defined on the ground based
upon existing meteorite samples.
So what I did from a master's thesis
was model the design history of REXIS.
So how has our design evolved from the very beginning, where
it was very open-ended, very abstract,
and you'll see this, to the current design, which
current in this case was CDR, which was over a year ago now.
Right now, the current state of REXIS
is we're almost ready to mount to the spacecraft.
So it's very exciting.
Just to give you an idea of a timeline,
this is something I'm sure Ollie will
talk about in this course, is the flow
through the system development life cycle.
So we have system requirements review back in January of 2012.
System, I think it's definition review.
April 2012 preliminary design review, January of 2013,
and then critical design review, February of 2014.
So I created models at each of these design points in SysML
and looked at what are the lessons we could have learned.
We didn't use SysML in REXIS.
I was kind of looking back historically,
what if we had used it?
Could we have designed our system better in any sort of way?
So here is kind of a CAD representation
of how our design evolved.
And I think you can kind of get the idea.
Back at SRR, we didn't really know what they would look like.
We didn't know what the interfaces would be.
We didn't know what all the parts would be.
We had a little more development for SDR.
You can see there's more arrows.
The CAD is a little bit more detailed.
For PDR, we had even more detail.
This was actually like a buildable design.
This turned out to not even be buildable.
And then we had more evolution between PDR and CDR
to get to pretty much where the design is.
There's actually been some evolution after this as well.
Sometimes happens with a new system.
But you can see just graphically kind of the increase
in level of detail and level of fidelity
of the state of our system throughout its development cycle.
And I'll show you that and how that looks in the system model
as well.
So one of the things you can do if you have a system model,
as I talked about, you can run queries on it
and pull out information that's very difficult or impossible
to get with our current development practices.
So this is just looking at the different sub-assemblies
within REXIS.
What are the number of parts in each of the sub-assemblies?
So you can see the general trend is up for all of them
as you would expect.
Some jump up very high.
Some kind of stay basically where they were.
But in general, they all increase.
And this is something you might be
able to do with looking at a parts list or something
like that with current methodologies.
But it'd be very hard to get this information, which
is the number of ports per assembly.
So each interface has two ports.
So these numbers divided by two basically
equal the number of interfaces that we have
in each sub-assembly.
You can see, again, there's a general trend of increasing.
Increasing number of ports as you go through the life cycle.
So this is a piece of information
you might want to use if you want to manage the complexity
of your system.
And you say, this sub-assembly is getting
way too many interfaces, way too many parts.
It's way too complex.
We need to think about how we've logically
arranged our system and maybe how can we rearrange it
to make it more understandable and easier to work with.
And then you can divide the two.
And you end up looking at how many
this is ports per part in each sub-assembly at each
of the design reviews.
And you can see trends here, too, which are interesting.
So you can see in the beginning, we
didn't really know what we were doing.
Some of these had a lot of ports per part.
Some of these had very few.
They all ended up stabilizing kind of between the three
and five ports per part range.
And then you can look at the literature and say, well,
typically systems tend to be between five and six
ports per part.
So what does that mean?
Does that mean that our system, that I didn't model it
correctly?
That's one possibility.
It didn't model to the lowest level of fidelity possible.
Does it mean that our system is too simple?
Does it mean that we're missing something
that we haven't thought about?
Does it mean that our system, which
was intended to be simple and cheap and implementable by
students, is actually achieving that goal because it's
beneath what you would typically expect?
Those are the type of questions you can ask with this data.
But this data is not easy to get with the current
methodologies.
So this kind of very simple query you can do gives you
power on managing complexity in your system.
So let me now transition quickly to the demo.
Let's see.
There's no sound.
I know, but I need to sync it up and I need sound to do that.
So you can close out of this.
And then let me see.
So while Mark is setting up for the demo, are there any
questions about SysML so far?
Any observations you guys have?
Maybe at EPFL, you see the similarities and differences
between OPM and SysML.
What's the biggest difference between the two?
There's two really important differences.
No questions?
Yes?
Hang on.
Is there anybody at EPFL who wants to comment on this?
No, there's no comment from EPFL.
OK, good.
That's fine.
That's fine.
Mark, are you set up?
Almost.
What I would say is, first of all, OPM has only one type of
diagram, right?
And then you go really deep, sort of a deep hierarchy.
SysML has nine different types of diagrams split between
behavioral and structural, but that's one difference.
And then the other is that SysML is fundamentally object
oriented, because it comes from object oriented thinking and
software, whereas OPM has objects and processes at the
same level.
Those are two of the most important differences.
OK?
All right.
So what I'm showing, can everyone see the screen?
Just let me know if you can't see the screen.
What I'm showing you right now is a tool called Magic Draw.
There are basically a variety of tools provided by
commercial vendors that enable you to build and work with
SysML models.
So SysML is a language, and then it's implemented in tools.
And this just happens to be one that's fairly widely
utilized.
Unfortunately, it's quite expensive.
But anyway.
So what I'm showing you right now, and this is going to be a
little bit difficult, because as you can see, you need a
big screen.
What I'm showing you right now is a requirements diagram.
So you can see that right here, requirements diagram.
And each of these blocks, as you can see by the tag here, is
a requirement.
So this is one of our operating criteria.
So while operating, the temperature of all our
components shall be maintained within operability limits.
Straightforward requirement.
And you can create these satisfy relationships between
that requirement and the components in the system that
must satisfy that requirement.
So right now, this is being done at SRR, as you can see up
here.
So this is very early in the design.
So we don't have it broken down fully to all the
components.
But here's our main electronics board.
It has to satisfy that requirement.
Here's our radiation cover.
It has to satisfy that requirement.
So you can tie these two things, the requirement, and the
part of the system that must satisfy the requirement.
And here I've tied it to parts.
So these are called blocks, which are the fundamental
unit in SysMLs, is a block.
So these represent parts of our system.
But you could tie it to a property of that
part if you wanted to.
So then you get into the situation I talked about
earlier, where you have the requirement is on the mass of
must be less than this.
You can tie it to the mass of the system itself.
As opposed to the system, you can tie it to the actual
property, which is very useful.
So let me quickly show you one of the cool things.
If I delete these requirements, you can see there's no
requirements.
I'm not actually deleting them from the system itself.
But I'm just doing as I'm removing it from the diagram.
But if you wanted to, you should be able to look at
related elements of the different blocks.
So I just clicked on a block.
And I can choose to show all the things that are satisfied,
the requirements of that component of the system
satisfies, and these requirements pop up.
So this is showing how the diagrams themselves aren't
the model.
There's actually back into the model.
And you can kind of work in the diagram and show or hide
things however you want.
But the information is actually kept behind the diagram.
So to speak.
So my research looked into topology.
So let me just show you a little bit about what I did.
So this is a block definition diagram, again, defining all
the parts of your system.
And I just want to give you kind of a high-level idea of
the type of things that we saw.
So it's big, first of all, very big.
These are all the parts of the system.
So we start hide like the mission context and the
mission context contain things like the environment, the
spacecraft, and then Rexus.
And then you can break down Rexus.
And we have various sub-assemblies broken down
into parts.
And that's how you get this tree structure.
And then this tree structure can be tied together.
I could zoom in, but it's big.
Again, so these are all the parts of our system.
Let me give you an example.
So we have a couple of boards that we call our
detector electronics.
And those detector electronics have various ports.
One thing they have to do, they have this port here and
this interface here, which connects to RCCDs.
So this is showing how you can build interfaces in
system also here.
The green boxes, again, are the ports, the lines of the
connectors, and they're defining all the interfaces.
And you can see, at a high level, how complicated things
get very quickly.
This is the earliest, most abstract version of our
design, and it already has a lot of complication.
One thing you can do, I talked about running scripts.
I'll show you how that works.
It's quite easy.
So I just ran a script on the model that told me to find the
number of parts in the scope that I defined and the number
of ports.
And here's the output of that model right here.
So the script itself is not even very complicated.
It's like 50, 60 lines of code.
And immediately I can pull out how many ports, how many
parts, things like that, information about my system.
So let me kind of take you briefly through the development
process.
So that was, again, the highest, the most abstract, the
earliest version of our system, SRR.
This is SDR.
You can see it's starting to get a bit more complex.
And then you can go over to PDR, and it starts to get
really scary.
Right?
And then you go to CDR, and it's just a nightmare.
So I created all these systems, all these models by hand.
You can't actually build the model with a script, if you
would like.
You can basically do things like define a pattern and then
apply that pattern to all the parts of that type.
That's all possible through the API.
And just to show you how much of a nightmare it was at CDR,
when they run the same script on the CDR model, we have
230 parts and 900 interfaces.
And this was not even modeling to the lowest level of
fidelity possible.
I didn't, for example, model all the components, all the
capacitors, resistors, op-amps, and stuff on the board.
And now you can already see it's quite large.
So this is just the idea behind these models would be to
extend this to the lowest level in a real system and use
this, basically, use all the capabilities that you have
with the model to really manage your complexity in a way
that is just not possible currently.
And there's no way you can really mentally keep track of
all these interfaces and understand
how your system is working.
So having this modeling capability and querying
capability is really, really powerful.
What was used during RECSYS for the systems engineering?
You had applied this after the fact.
What was used to create these block diagrams or track
things during RECSYS?
Do you mean during when we were developing RECSYS?
We basically didn't have this.
So we were relying, as you would typically do, upon the
capabilities of the system engineer or the team.
You'd have documents.
We have a ton of documents.
But I was talking about how things weren't buildable.
I found a situation where, because of the way we had
done our thermal system, we were dumping
spacecraft heat to space, which you don't want to do.
I can explain why, but you don't want to do that.
And that's something we didn't realize at the time.
Like if we had tried to build it, we would have had this
property of the system that we didn't know actually existed
until I went back and looked at the model.
So we definitely missed things.
And this should have improved the design process if we had
been using it.
So Mark, to wrap up, because we've got to switch over to
Modellica, what's your recommendation for, let's say
students in the class got intrigued by CISML.
What's the next step?
There's a couple of different ways.
Certainly, if you're interested, let me know.
And I can give you resources to further your understanding.
As I said, working with these tools can be expensive to get
these tools.
So I can help you understand what that would take.
There are some beginning to be some companies that will do
CISML training courses that will sit down for a day or a
week and teach you CISML, basically, how to work with
the model, how to build the model.
I took one of those courses.
It was really great.
So talk to me if you're interested, and I can steer
you down the right path.
Great.
Thanks, Mark.
Sure.
Very good.
So we did, in 20 minutes, what usually take about a week,
right?
There's a lot more to it.
Great.
So we're going to switch over now to Modellica, which I
think is we're going to maybe run a couple minutes over
today, but I think it's important we cover all three
languages.
So let's get the slides back up.
And I'm going to switch here to Narik.
He's another doctoral student in the group.
And so introduce yourself, and then tell us about Modellica.
Great.
Thank you.
Are you using your computer for slides or this computer?
For the demo, I'm going to use this one.
You need this one?
This one.
So hello, everyone.
My name is Narik.
I'm a doctoral student at AeroAstro here.
My background is in gas turbine engines, and specifically
I've been looking at concept generation of gas turbine
engines, automated concept generation.
And the way I got acquainted with Modellica
was that I needed to be able to rapidly reconfigure different
concepts and simulate them mathematically,
do physics-based simulations.
So in contrast to the first two languages,
Modellica is a lot more about rapidly being
able to build physical models of systems
and reconfiguring them and reusing them for later on.
So like I mentioned, Modellica is primarily
about physics-based modeling of systems
and rapidly being able to reuse models and reconfigure them.
It's a language.
Again, it's not a tool, like the first two that you heard about.
There are many different tools which implement this language,
but I'm going to start off with just describing how the language
works and then go on to describe which tools that you can use.
In contrast to CISML, there are a couple of really good free
tools that you can use and rapidly get into.
And there are a lot of libraries that you
can use with hundreds of even thousands of actually basic
components that you can use for modeling.
So it's a declarative language.
And what I mean by declarative is that you don't,
in sequential sort of programming, you write commands
and you make assignments to various parameters.
Here, you just describe the governing equations
of the components you want to simulate.
And there's no particular order in which you do this.
The models are a-causal.
There's no direction to flows.
All you really need to do is describe what ports,
like Mark mentioned.
It's similar in this situation.
What kind of ports you have, what kind of interfaces
the components can have with other components,
and the governing equations and the parameters and variables.
It's a multi-domain modeling language,
so it's agnostic to what kind of domain you're working in.
It's not particularly electrical engineering.
For example, I'm going to be showing an electrical engineering
example and also show a gas turbine engine example
with aero-elastic vibrations.
So you don't necessarily, you're not attached
to any specific domain.
It's also object-orientated, and it enables you to decompose
systems into subsystems or recombine them
and look at them at various layers of abstraction.
It's designed to be efficient, so this
is a quote from Professor Peter Fritzen
at Linkping University.
So these are just about the sort of scale of problems
that you can solve with the medallic language.
Obviously, it depends on what kind of equations
you're talking about, but it's designed
to be a very efficient way of simulating systems.
So I really want to talk a little bit more
about this idea of a-causal modeling
that I mentioned before.
So on the left-hand side is an assignment,
and that's typically what you do when you program in MATLAB,
just the MATLAB normal scripts.
F is assigned to MA, or P is assigned
the value of RORT for the equation of state of a gas.
And what that means is that you know
what the mass and acceleration are,
and you figure out the force.
And you assign that value to the force.
In medallica, there's almost none of this.
It's equations, not assignments.
And what I mean by that is this equation
can be written in any which way.
As long as your system has the same number of equations
as unknowns, the tool that you're using
will interpret the language and will solve your problem.
So you can write this in any which way you want in any order.
As long as your problem is properly constrained,
the tool that you're using will interpret it and solve
the problem for you.
So just to go into a little bit more detail,
all of medallica's and also of a-causal modeling language
that I'll mention in a little bit, which is one of them
is Simscape.
Models have essentially three parts.
They're designed to be extremely simple.
The first, like Mark mentioned, are ports.
It's essentially identical to SSML in a way.
Ports are the ways with which components
can share information, material, or energy, for example.
You can define any kind of port you want.
All you need to really do is define
what kind of parameters it carries, like for gas,
for example, temperature, pressure, and mass flow,
or for electrical ports, voltage, and current.
The second part of any kind of model
that you're building in medallica or Simscape,
which I'll mention a little later,
are variables and parameters, so you just declare those.
And the third part are governing equations.
The point is that there's nothing else.
It's just that.
And I'll just briefly go through a very, very simple example.
So for example, a capacitor.
This is the entire code for a capacitor,
and this is what will generate a visual image of a capacitor
with the correct ports for you.
First, you have pins that carry voltage and current.
So the key thing to notice here is
that there are fundamentally two types of variables.
Flow variables and normal variables here.
Flow variables are ones through which the Kirchhoff's current
law applies.
So mass flow, for example, every time
you connect 15 components together in a network,
mass flow into that network needs to be conserved.
So the sum of mass flows into any node has to be 0.
That doesn't apply to the standard variables.
So then you essentially define the parameters of variables,
and you need to define the governing equations,
and that's the capacitor for you.
There are slightly more complicated components
that you can use, for example, a pressure drop component.
Did I lose my sharing?
No.
In this case, the interesting thing
is the main thing to take away from this one
is that if you have complicated mathematics describing
the fluid mechanics in a component,
you can actually initialize with one model
and then go to a full turbulent simulation.
That's what this is doing here.
So just to get to the tool side of the equation,
the language I just showed you, it's
the same across all the tools.
But there are many different tools
which you can use free and commercial to actually
run these models.
The main one that you'll be using if you want to get deeper
into this is open medelica.
It's free.
It's actually become quite user friendly,
and there's a link in the slides with which
from which you can download it.
There's one from Wolfram.
It's integrated with Mathematica,
which is quite useful, and there's a free trial of it as well.
There's Daimler, there are other ones.
But mainly, I think open medelica is the one
that you guys will be using.
OK, Sonar, I think we're actually going to wrap up,
and then have you back next week.
Are you around next week?
Yeah, yeah, sure.
So here's, just stay around.
So basically, we're going to finish this lecture next week.
I think it's important enough that you really
see the demo and see sort of the,
and it actually ties in kind of nicely with,
next week's topic is concept generation, right?
This is the next step in the V. And since, you know,
Narik, your research is also in concept generation,
it'll tie in nicely.
So I think we're going to stop here for today.
So you heard about the general idea of system modeling
languages that are rigorous, that have ontology, syntax,
and semantics.
There's different of these that have been proposed,
developed, some are used more than others.
There's really important differences between them.
So OPM is very conceptual.
CISML is based on UML, and has these different type
of diagrams, and can really help you flesh out
your design in more detail.
And then Medellica allows you to build these blocks.
It's acausal or declarative, and you can actually
simulate the physics of the system pretty readily.
So the big picture here, just to wrap up here,
the big picture is the following.
And we'll come back to this next week.
The big picture is basically that system engineering
is in a transition phase.
The classic way of doing system engineering, really,
for the last 50 years, is on the left, document-centric.
You know, write your requirements, do your drawings.
Even CAD, you know, computer-aided design, is great,
but it only essentially does the mechanical part
of the design, right?
And so the result of that is, as you get even REXIS,
so REXIS is a box like shoebox size, basically,
and it's going to fit on a much bigger spacecraft,
and you saw how much complexity is there.
And it gets very, very difficult to manage
all this information, to prevent errors,
oversights, any change that you make.
It doesn't propagate automatically in these documents.
So the transition is happening to the right side,
a model-centric way to do system engineering,
as think of paperless engineering.
Everything you're doing is in a model.
The models are linked, the models are executable,
the models automatically propagate any changes
that you make, you know, in requirements or design.
We're not quite there yet, but that
is where things are moving.
And so keep that in mind.
So there's no new assignment this week.
So next week, we have A2, which is due, the requirements.
Please let us know if you have any.
We're here for you.
So I'm going to have office hours now on the WebEx.
You have the link.
If you have any questions about A2,
don't be shy to email me or, you know,
Juana or Lieslu at EPFL.
We're really here to answer your questions.
So next week, topic we're going to finish
on modelica and concept generation
is going to be sort of our creativity, concept generation
is our main topic next week.
