WEBVTT

00:00.000 --> 00:02.480
The following content is provided under a Creative

00:02.480 --> 00:03.680
Commons license.

00:03.680 --> 00:06.120
Your support will help MIT OpenCourseWare

00:06.120 --> 00:10.000
continue to offer high quality educational resources for free.

00:10.000 --> 00:12.760
To make a donation or to view additional materials

00:12.760 --> 00:16.600
from hundreds of MIT courses, visit MIT OpenCourseWare

00:16.600 --> 00:17.440
at ocw.mit.edu.

00:25.040 --> 00:28.200
So let me start.

00:28.200 --> 00:31.080
Session three is about system modeling languages.

00:31.080 --> 00:35.960
But before I start, I'd like to remind you

00:35.960 --> 00:38.960
that A1 is due today.

00:38.960 --> 00:41.960
The first assignment is due today.

00:41.960 --> 00:46.640
And I think neither Ioana or I or Liz,

00:46.640 --> 00:48.840
did you get a lot of questions about A1?

00:54.120 --> 00:56.200
No, I didn't get any questions.

00:56.200 --> 00:58.280
Yeah, so we didn't get many questions.

00:58.280 --> 01:02.080
So I think I interpret that as a positive,

01:02.080 --> 01:05.160
but I guess we'll find out.

01:05.160 --> 01:06.280
Everybody submitted.

01:06.280 --> 01:12.280
OK, well, so we're hoping to have these graded in about a week,

01:12.280 --> 01:16.880
give you feedback, and we'll also post a master solution.

01:16.880 --> 01:20.160
And A2 is out right now.

01:20.160 --> 01:24.440
And the other good news is there's no new assignment today.

01:24.440 --> 01:26.880
The next A3 is going to go out next week, OK?

01:29.720 --> 01:31.720
Any questions about A1?

01:31.720 --> 01:37.160
Was there something that was particularly difficult or confusing,

01:37.160 --> 01:38.760
or was it straightforward?

01:38.760 --> 01:40.520
Anybody want to comment on A1?

01:45.000 --> 01:47.720
Wow.

01:47.720 --> 01:49.720
Sam?

01:49.720 --> 01:52.760
Do you want to push the button?

01:52.760 --> 01:54.920
No, our team thought it was fairly clear

01:54.920 --> 01:58.120
on what we had to do based on the lectures.

01:58.120 --> 01:58.620
OK.

01:58.620 --> 02:00.120
We didn't have any trouble.

02:00.120 --> 02:01.160
Good.

02:01.160 --> 02:05.320
All right, well, let's keep going then.

02:05.320 --> 02:08.920
So the V model is our roadmap for the class.

02:08.920 --> 02:10.760
We're starting to fill in the V. We're still

02:10.760 --> 02:12.280
in the upper left corner.

02:12.280 --> 02:15.320
And today's lecture is actually a little different.

02:15.320 --> 02:19.560
It's sort of in the center of the V. System modeling languages

02:19.560 --> 02:22.480
as a precondition or precursor to what

02:22.520 --> 02:26.640
we've been calling NBSC, model-based system engineering.

02:26.640 --> 02:32.560
So what I'd like to cover today is why do we need

02:32.560 --> 02:36.080
or why have these system modeling languages emerged?

02:36.080 --> 02:39.360
Particularly, what do we mean by ontology, semantics,

02:39.360 --> 02:40.760
and syntax?

02:40.760 --> 02:44.680
And then I would characterize this

02:44.680 --> 02:49.440
as a sampler of three different system modeling languages

02:49.440 --> 02:53.840
that have emerged really within the last 10, 15 years.

02:53.840 --> 02:58.400
The first one is called OPM, Object Process Methodology.

02:58.400 --> 03:02.320
The second one is called SysML, System Modeling Language.

03:02.320 --> 03:05.520
And then the third one is called Medellica.

03:05.520 --> 03:09.200
And then we'll sort of quickly wrap up with the question,

03:09.200 --> 03:12.520
what does this mean now for system engineering today

03:12.520 --> 03:15.480
and tomorrow in the future?

03:15.480 --> 03:19.040
So I'd like to motivate this with a little exercise.

03:19.480 --> 03:22.120
You remember Mr. Sticky from last time?

03:22.120 --> 03:23.640
You came up with some requirements.

03:23.640 --> 03:27.400
So it's kind of the simplest system I could think of here.

03:27.400 --> 03:32.120
So what we'd like to do is have you work in pairs again.

03:32.120 --> 03:39.280
And the assignment here is to describe this system

03:39.280 --> 03:42.760
as clearly as you can, provide a description.

03:42.760 --> 03:46.360
So last time the assignment was write a requirement,

03:46.360 --> 03:50.440
come up with some requirements that led to this design.

03:50.440 --> 03:52.960
But today I would like you to describe

03:52.960 --> 03:56.000
what the system is, how it functions, and so forth,

03:56.000 --> 03:57.960
as clearly as you can.

03:57.960 --> 04:01.400
And I would like you to do this, so hopefully you're

04:01.400 --> 04:04.440
on the WebEx, logged into the WebEx.

04:04.440 --> 04:07.000
I would like you to do this in teams of two.

04:07.000 --> 04:09.880
And as you're doing this, I don't know if you noticed,

04:09.880 --> 04:18.200
but on the WebEx, there's actually a note pad feature.

04:18.200 --> 04:18.720
Where is it?

04:30.960 --> 04:32.880
Tell me.

04:32.880 --> 04:34.360
Left, right.

04:34.360 --> 04:46.200
I see.

04:46.200 --> 04:49.320
So I can't share and use the note pad at the same time.

04:49.320 --> 04:54.160
It's the whiteboard right there.

04:54.160 --> 04:57.040
Annotate?

04:57.040 --> 04:59.000
Yeah, yeah.

04:59.000 --> 05:01.960
But if you go back into view.

05:02.000 --> 05:04.560
Stop sharing.

05:04.560 --> 05:05.920
But then they can't see it, right?

05:09.800 --> 05:14.440
Can they see this?

05:14.440 --> 05:15.720
So you can write text.

05:32.720 --> 05:35.040
You can draw the shapes.

05:41.440 --> 05:45.240
OK, so the reason I want you to do this on the whiteboard

05:45.240 --> 05:48.160
is such that we can then sort of go around

05:48.160 --> 05:51.000
and look at some examples.

05:51.000 --> 05:54.640
So the assignment is take five minutes,

05:54.640 --> 05:59.840
turn to your partner, and try to describe the system.

05:59.880 --> 06:02.120
And then we'll go around and look at some,

06:02.120 --> 06:05.720
I will sample people's descriptions.

06:05.720 --> 06:08.360
Go for it.

06:08.360 --> 06:12.240
All right, so keep working on the assignment,

06:12.240 --> 06:16.400
but do it locally on your computer, not on the whiteboard.

06:16.400 --> 06:19.600
And then we'll sort of discuss it and share it,

06:19.600 --> 06:22.440
and maybe not use the whiteboard.

06:22.440 --> 06:25.240
Because I didn't realize there's only one whiteboard

06:25.240 --> 06:26.160
that we all share.

06:26.160 --> 06:28.440
I thought that you have individually the whiteboard,

06:28.440 --> 06:31.280
and then you can sort of pass it on to different people.

06:31.280 --> 06:35.120
So but if you do it locally on your machine,

06:35.120 --> 06:36.640
then we can share the screen.

06:36.640 --> 06:37.200
So it'll work.

06:37.200 --> 06:42.840
So do it in PowerPoint, or Word, or Sketchpad,

06:42.840 --> 06:44.360
or anything you want.

06:44.360 --> 06:45.080
Sorry about that.

06:49.680 --> 06:53.400
OK, all right, so let's do this.

06:53.400 --> 06:58.160
We're going to sort of go back and forth between here and EPFL.

06:58.200 --> 07:02.960
Let's start maybe over here with Narik.

07:02.960 --> 07:04.440
Are you ready?

07:04.440 --> 07:07.680
So I'm going to give you the ball,

07:07.680 --> 07:13.680
and then you can sort of explain how you guys describe the system.

07:13.680 --> 07:18.240
So what we decided to do was identify the primary function

07:18.240 --> 07:23.480
of the sticky, Mr. Sticky.

07:23.480 --> 07:28.520
So the primary function is to trap the fly, we thought.

07:28.520 --> 07:30.720
This is enabled by a couple of other functions

07:30.720 --> 07:33.440
that are sort of at a lower layer of abstraction.

07:33.440 --> 07:36.200
It's attracting the fly, immobilizing the fly,

07:36.200 --> 07:39.080
transporting the object to where you

07:39.080 --> 07:42.880
need to immobilize the fly, and deploying Mr. Sticky.

07:42.880 --> 07:45.800
And we map this to the physical forms

07:45.800 --> 07:46.960
that enable the function.

07:46.960 --> 07:49.200
So the canister, the physical form of the canister

07:49.200 --> 07:51.840
is helping with the transporting function.

07:51.840 --> 07:54.880
The sticky tape is helping with the immobilizing function.

07:54.880 --> 07:56.360
The scented material, we thought,

07:56.360 --> 07:58.680
that would be helping for the attracting function.

07:58.680 --> 08:01.480
And the hook, maybe on top that you used to hang it,

08:01.480 --> 08:03.000
would help with the deploying.

08:03.000 --> 08:04.360
OK, good.

08:04.360 --> 08:07.440
So nice function form separation,

08:07.440 --> 08:11.800
and you use primarily text, human language to describe it.

08:11.800 --> 08:14.720
So let's see, at EPFL, who would like to share?

08:18.840 --> 08:19.880
And we'll give you the ball.

08:22.520 --> 08:25.600
OK, we can try, maybe.

08:25.600 --> 08:27.720
Who is speaking?

08:27.720 --> 08:28.640
Maxim.

08:28.640 --> 08:29.400
Maxim, OK.

08:29.400 --> 08:32.920
Can we give the ball to Maxim?

08:32.920 --> 08:34.360
Yes, do you see something?

08:34.360 --> 08:36.080
Yeah, it's good.

08:36.080 --> 08:36.600
Oh, perfect.

08:36.600 --> 08:42.680
So we draw the same system when deployed and deployed.

08:42.680 --> 08:45.200
So we begin with the container containing

08:45.200 --> 08:47.960
basically the sticky setup rolled.

08:47.960 --> 08:50.000
Then when unrolled, we have the container

08:50.000 --> 08:54.560
that should be linked to the sticky setup with a stick,

08:54.560 --> 08:55.560
but whatever.

08:55.560 --> 08:59.680
And we have like, an external input from the insects

08:59.680 --> 09:03.320
that come to be sticked onto the.

09:07.400 --> 09:08.160
Yeah, go ahead.

09:11.920 --> 09:14.400
OK, so that's all.

09:14.400 --> 09:19.280
OK, so I'll note here that you guys use graphics, right?

09:19.280 --> 09:21.000
You use some kind of graphical language.

09:21.000 --> 09:25.400
And at the highest level, it's like a state diagram, right?

09:25.400 --> 09:26.400
Rolled, unrolled.

09:26.400 --> 09:29.000
So you show the system in two different states.

09:29.000 --> 09:30.720
Very nice.

09:30.720 --> 09:32.800
Somebody else here on the MIT side,

09:32.800 --> 09:34.600
and then we'll go back one more time.

09:34.600 --> 09:36.800
Who would like to share here?

09:36.800 --> 09:38.040
You see him?

09:38.040 --> 09:39.760
OK.

09:39.760 --> 09:41.880
So let's.

09:41.880 --> 09:48.600
OK, so we did a diagram showing the use of Mr. Sticky.

09:48.600 --> 09:51.040
So we have a user, because Mr. Sticky has

09:51.040 --> 09:54.360
to be rolled and unrolled.

09:54.360 --> 09:59.120
The user installs or disposes of Mr. Sticky.

09:59.120 --> 10:01.520
The flies are attracted to, or Mr. Sticky

10:01.520 --> 10:04.560
attracts the flies, and the flies stick to Mr. Sticky.

10:04.560 --> 10:08.760
And then we decompose Mr. Sticky into the different components

10:08.760 --> 10:11.800
that are below at a lower level.

10:11.800 --> 10:15.680
And yeah, so it's basically at a higher level of use diagram.

10:15.720 --> 10:19.120
So here we have, again, a graphical description.

10:19.120 --> 10:21.240
The states are sort of implied, but you're

10:21.240 --> 10:23.120
focusing on decomposition, right?

10:23.120 --> 10:25.640
The sub-elements.

10:25.640 --> 10:26.960
Very nice.

10:26.960 --> 10:29.240
Anybody else at EPFL did anybody just

10:29.240 --> 10:33.600
write a paragraph of text, or more of like sentences?

10:39.920 --> 10:41.640
At EPFL, who wants to share?

10:42.480 --> 10:45.760
Chris here.

10:45.760 --> 10:46.260
Chris?

10:46.260 --> 10:46.760
OK.

10:46.760 --> 10:49.600
No, we didn't write a text.

10:49.600 --> 10:52.320
The text seemed a bit heavy to convey

10:52.320 --> 10:57.080
a description in efficient terms.

10:57.080 --> 11:01.120
What we prefer to do is decompose in elements,

11:01.120 --> 11:06.640
and for each element, give some properties.

11:09.600 --> 11:10.800
OK.

11:10.800 --> 11:13.720
And did you do this in the form of a list,

11:13.720 --> 11:19.440
or in the form of a table, or how did you actually describe it?

11:19.440 --> 11:21.680
So wait, I'm trying to share the screen.

11:21.680 --> 11:23.360
OK.

11:23.360 --> 11:26.560
All right, so we just walked on the first half here.

11:26.560 --> 11:29.800
We have the band, and we give here properties,

11:29.800 --> 11:33.160
though, so it has to be made of paper or soft material.

11:33.160 --> 11:37.520
It has to be one to one-size meters long, three centimeters,

11:37.520 --> 11:40.720
three to five centimeters large.

11:40.720 --> 11:43.640
It needs to have a coating, which in itself

11:43.640 --> 11:49.360
is a sticky material, and be sanded in order to attract flies.

11:49.360 --> 11:51.280
It needs to have visible color.

11:51.280 --> 11:57.960
And then, well, the other parts here, which I'm highlighting,

11:57.960 --> 12:02.760
would be really related to the packaging.

12:02.760 --> 12:07.640
So a sealed cylindrical container with a single-user

12:07.640 --> 12:11.640
opening, including a hanger, with possibility

12:11.640 --> 12:14.560
of branding on the packaging.

12:14.560 --> 12:16.680
And, well, the non-toxic material

12:16.680 --> 12:20.960
would still refer to the sticky material.

12:20.960 --> 12:21.840
Good, good.

12:21.840 --> 12:22.760
Thank you very much.

12:22.760 --> 12:23.760
This is great.

12:23.760 --> 12:26.920
So what you showed, that's more like a list, right?

12:26.920 --> 12:29.480
And I would describe, this looks like what

12:29.480 --> 12:31.840
I would call a bill of materials, right?

12:31.840 --> 12:36.000
It's essentially a list of the primary elements

12:36.000 --> 12:38.320
of form of the system, but there's

12:38.320 --> 12:41.400
some attributes that are associated.

12:41.400 --> 12:45.480
So this is a list format in the form

12:45.480 --> 12:48.040
of a bill of materials with attributes attached.

12:48.040 --> 12:49.680
So thank you very much.

12:49.680 --> 12:50.720
That's great.

12:50.720 --> 12:54.760
So let's get, I'm going to share here again.

12:54.760 --> 13:01.080
And you're probably wondering, why did we do this?

13:01.080 --> 13:03.440
Why did we do this exercise?

13:03.440 --> 13:10.440
And that's the point I want to make next.

13:10.440 --> 13:12.400
So here's a very simple system.

13:12.400 --> 13:15.320
And we had four examples of descriptions

13:15.320 --> 13:17.480
that were quite different, right?

13:17.480 --> 13:19.960
And of course, if you had more time,

13:19.960 --> 13:21.560
they'd become more complete, but they

13:21.560 --> 13:23.160
would be really different.

13:23.160 --> 13:27.000
So this is fundamentally the issue

13:27.000 --> 13:29.200
that we've been facing in systems engineering

13:29.200 --> 13:30.520
for a long time.

13:30.520 --> 13:33.000
The means for describing our artifacts,

13:33.000 --> 13:35.760
whether it's something simple as a Mr. Sticky,

13:35.760 --> 13:39.960
or an airplane, or a spacecraft, or a medical device,

13:39.960 --> 13:42.560
or even a service, how would we describe it?

13:42.560 --> 13:44.560
Well, first of all, natural language,

13:44.560 --> 13:46.600
the human natural language.

13:46.600 --> 13:49.360
And as we know, the human natural language

13:49.360 --> 13:50.480
is a very rich, right?

13:50.480 --> 13:53.280
There's very different ways in which we

13:53.280 --> 13:56.720
can express essentially the same facts, the same things.

13:56.720 --> 14:01.760
That's a wonderful thing if you're a poet or a writer,

14:01.760 --> 14:04.600
but it makes system engineering challenging,

14:04.600 --> 14:08.800
because it gets confusing when we're describing

14:08.800 --> 14:11.520
the same thing in very different ways.

14:11.520 --> 14:14.200
Or graphical, so we saw some boxes,

14:14.200 --> 14:18.040
and we saw some great examples, sketches, drawings.

14:18.040 --> 14:22.320
So fundamentally, the way we describe systems,

14:22.320 --> 14:25.640
and this gets to the left half and right half of the brain,

14:25.680 --> 14:31.400
is using language, words, sentences, lists, or graphical.

14:31.400 --> 14:34.920
Those are the two fundamental ways of describing systems.

14:34.920 --> 14:38.280
And then we put all these descriptions together

14:38.280 --> 14:41.520
in what we've been calling documents.

14:41.520 --> 14:43.120
We aggregate this in documents.

14:43.120 --> 14:46.880
So examples of documents would be a requirements document.

14:46.880 --> 14:49.920
That's what essentially you're doing in assignment 2,

14:49.920 --> 14:53.560
or a drawing package.

14:53.560 --> 14:58.320
Even if it's in CAD, it's still essentially a document.

14:58.320 --> 15:01.200
So typically in system engineering,

15:01.200 --> 15:03.000
all of this gets assembled into what

15:03.000 --> 15:06.520
we call a TDP, technical data package.

15:06.520 --> 15:09.600
And fundamentally, when you're designing a new system,

15:09.600 --> 15:12.240
you're producing a technical data package that

15:12.240 --> 15:16.320
has software, drawings, descriptions,

15:16.320 --> 15:19.560
and that's the deliverable from the design process

15:19.560 --> 15:22.280
is this TDP, technical data package.

15:22.320 --> 15:25.040
And from that, you should then be able to build and operate

15:25.040 --> 15:28.440
the system with as few errors, mistakes,

15:28.440 --> 15:30.800
misunderstandings as possible.

15:30.800 --> 15:33.600
And fundamentally, as our systems

15:33.600 --> 15:35.760
have been getting more and more complex,

15:35.760 --> 15:38.360
we're now talking about the systems that

15:38.360 --> 15:42.040
need the three, four, five layers of decomposition.

15:42.040 --> 15:45.800
It's very easy to have errors, omissions,

15:45.800 --> 15:48.640
different interpretations of this information.

15:48.640 --> 15:51.760
So that's fundamentally.

15:51.760 --> 15:53.080
But there are advantages.

15:53.080 --> 15:57.120
I don't want to say it's categorically bad

15:57.120 --> 16:00.120
to use natural language and graphics.

16:00.120 --> 16:02.360
They're definitely advantaged familiarity

16:02.360 --> 16:03.960
to the creator of the description.

16:03.960 --> 16:07.400
So it's easy, it's comfortable, it feels familiar.

16:07.400 --> 16:09.200
And also, it's not confining.

16:09.200 --> 16:13.200
So you can be quite creative by creating descriptions

16:13.200 --> 16:14.240
in this way.

16:14.240 --> 16:18.200
But the list of disadvantages is quite long

16:18.200 --> 16:20.760
for allowing an arbitrary description.

16:20.760 --> 16:23.960
The room for ambiguous interpretations and errors,

16:23.960 --> 16:25.840
it's quite difficult to update.

16:25.840 --> 16:28.000
So if you make a change in one description,

16:28.000 --> 16:30.040
that change will not automatically

16:30.040 --> 16:33.000
propagate to the other descriptions.

16:33.000 --> 16:35.960
Handing off these descriptions from one lifecycle phase

16:35.960 --> 16:40.360
to another, there's discontinuities in these handoffs.

16:40.360 --> 16:42.360
Uneval level of abstraction.

16:42.360 --> 16:44.520
So what I mean by that is you may

16:44.520 --> 16:48.040
describe one part of the system in very detailed.

16:48.040 --> 16:53.160
So the last example we saw with the list,

16:53.160 --> 16:55.560
with the Bill of Materials, there was quite a bit of detail

16:55.560 --> 16:59.280
there on the scent and the attributes of the tape.

16:59.280 --> 17:02.680
But at least a couple of the other descriptions

17:02.680 --> 17:05.760
didn't have that level of detail when it came to the tape.

17:05.760 --> 17:08.400
So the level of abstraction could

17:08.400 --> 17:13.040
be quite different in the different ways to describe it.

17:13.040 --> 17:15.480
And then for a complex system, you

17:15.480 --> 17:20.040
can imagine that the volume of information grows a lot.

17:20.040 --> 17:24.400
And so you can walk into any program manager and systems

17:24.400 --> 17:28.880
engineer's office and see bookshelves full of binders,

17:28.880 --> 17:31.680
dozens and dozens of binders with documents,

17:31.680 --> 17:33.880
thousands and thousands of pages.

17:33.880 --> 17:36.400
And many of them are never read.

17:36.400 --> 17:37.840
That's the big issue.

17:37.840 --> 17:41.080
So that's been the kind of way in which we've

17:41.080 --> 17:44.360
been doing system engineering traditionally.

17:44.360 --> 17:50.440
So the idea here is that in order to mitigate, yes, Justice?

17:58.760 --> 18:00.560
Phase A, conceptual design.

18:00.560 --> 18:03.800
Phase B, preliminary and detailed design.

18:03.800 --> 18:08.280
Phase C is testing and launch.

18:08.280 --> 18:09.480
Phase E is operation.

18:09.480 --> 18:14.600
So usually, not the same people do conceptual design,

18:14.600 --> 18:16.160
preliminary design, testing.

18:16.160 --> 18:19.400
So all the technical data package, these artifacts,

18:19.400 --> 18:21.920
have to be transferred and handed off

18:21.920 --> 18:25.360
to new people who then work on the next phase.

18:25.360 --> 18:27.800
That's what I mean by handoffs.

18:27.800 --> 18:34.120
And so the idea is, in order to mitigate

18:34.120 --> 18:37.440
some of these disadvantages of natural language

18:37.480 --> 18:41.600
and graphical description, there has been,

18:41.600 --> 18:44.000
and this has been recognized for a long time,

18:44.000 --> 18:48.840
a need to be more precise, perhaps more confining,

18:48.840 --> 18:53.320
but to create languages that allow us to describe systems

18:53.320 --> 18:56.080
much more precisely.

18:56.080 --> 18:58.680
And so I'll mention a couple of the past efforts.

18:58.680 --> 19:03.120
And you can read about each of these.

19:03.120 --> 19:06.920
So I'll mention bond graphs first, 1960.

19:06.960 --> 19:09.840
This was actually invented here at MIT

19:09.840 --> 19:13.160
by a professor in mechanical engineering.

19:13.160 --> 19:15.320
His name was Harry Painter.

19:15.320 --> 19:18.320
Professor Painter created bond graphs.

19:18.320 --> 19:20.840
You can think of bond graphs as block diagrams

19:20.840 --> 19:24.520
where different blocks have ports or interfaces

19:24.520 --> 19:28.160
where information, material, energy flows in and out.

19:28.160 --> 19:31.680
And you can compose a system out of these blocks.

19:31.680 --> 19:33.880
These bond graphs are essentially,

19:33.880 --> 19:37.240
and Narek will talk about Modellica,

19:37.240 --> 19:41.000
and which is sort of a modern version of bond graphs.

19:41.000 --> 19:45.280
It has other features too, but this has been sort of one

19:45.280 --> 19:46.520
attempt.

19:46.520 --> 19:51.920
Another one that's very well known is IDEF about 20 years

19:51.920 --> 19:52.440
later.

19:52.440 --> 19:56.680
This was created by the Air Force, the US Air Force.

19:56.680 --> 19:59.280
And this is essentially a description of systems

19:59.280 --> 20:01.200
that's very functionally oriented.

20:01.200 --> 20:03.520
So it shows you what functions are involved.

20:03.520 --> 20:05.000
And we saw one of the descriptions

20:05.000 --> 20:07.760
was very functionally oriented and how

20:07.760 --> 20:12.400
the functions of the system relate to each other.

20:12.400 --> 20:16.560
But generally, these system languages

20:16.560 --> 20:19.080
have not fully been deployed.

20:19.080 --> 20:21.880
Some organizations use them, others don't use them.

20:21.880 --> 20:23.880
And the main reason for that is twofold.

20:23.880 --> 20:27.880
First of all, some of these languages were incomplete.

20:27.880 --> 20:30.560
They would focus only on one aspect, like functions

20:30.560 --> 20:34.920
or the block nature of the system, the block diagrams.

20:34.920 --> 20:37.920
And a lot of them were not executable.

20:37.920 --> 20:40.560
So they would be graphical, but you couldn't actually

20:40.560 --> 20:43.680
simulate and actually check whether that description was

20:43.680 --> 20:45.760
complete or accurate.

20:45.760 --> 20:50.200
So since then, and the other thing, of course, important

20:50.200 --> 20:52.120
is domain agnostic.

20:52.120 --> 20:55.520
So what I mean by this is that the system modeling language

20:55.520 --> 20:59.360
should be applicable for any kind of cyber-physical system.

20:59.360 --> 21:03.600
Again, if you're designing a spacecraft, an aircraft,

21:03.600 --> 21:06.400
medical device, any kind of product,

21:06.400 --> 21:08.320
the language shouldn't have to be adapted.

21:08.320 --> 21:11.000
The language sort of covers all these applications.

21:11.000 --> 21:12.480
That's the idea.

21:12.480 --> 21:17.800
So whatever language it is that you're using or developing,

21:17.800 --> 21:20.480
it has to have these three things.

21:20.480 --> 21:22.240
Any language has these three things.

21:22.240 --> 21:24.240
So the first is ontology.

21:24.240 --> 21:26.680
And I reference here the Wikipedia

21:26.680 --> 21:28.560
articles on these things.

21:28.600 --> 21:31.240
Some of my colleagues in academia, it's a big debate.

21:31.240 --> 21:33.960
Is Wikipedia a legitimate source of information,

21:33.960 --> 21:35.160
or is it not?

21:35.160 --> 21:37.080
My position on this is that it is.

21:37.080 --> 21:40.640
I think Wikipedia is definitely not perfect,

21:40.640 --> 21:42.640
depending on what topic you're looking at.

21:42.640 --> 21:45.480
But it's a self-correcting system.

21:45.480 --> 21:48.840
So I actually go to Wikipedia, and then there's references,

21:48.840 --> 21:50.240
and you can dive deeper.

21:50.240 --> 21:53.120
So I give you the Wikipedia links here for these three things.

21:53.120 --> 21:55.040
First, ontology.

21:55.040 --> 21:59.600
So ontology is a very fancy word.

21:59.600 --> 22:03.520
What ontology actually is, Mark, why don't you come up here?

22:03.520 --> 22:06.160
You're an instructor today.

22:06.160 --> 22:11.680
Ontology, fundamentally, is describing the entities that

22:11.680 --> 22:14.920
are allowed to exist in the language.

22:14.920 --> 22:20.040
Subjects, nouns, adverbs, what are the objects, the entities,

22:20.040 --> 22:21.920
that can exist?

22:22.880 --> 22:25.840
It's a very abstract thing, but it's essentially

22:25.840 --> 22:28.600
the library of words and objects that

22:28.600 --> 22:31.840
are allowed to exist in that language.

22:31.840 --> 22:35.240
And then how these entities can be grouped, perhaps,

22:35.240 --> 22:37.160
in a hierarchy and subdivided.

22:37.160 --> 22:40.760
So it essentially constrains the universe of things

22:40.760 --> 22:42.400
you can describe in that language.

22:42.400 --> 22:45.840
The shorter, the smaller your ontology is,

22:45.840 --> 22:48.720
the more confined the language.

22:48.720 --> 22:50.280
Semantics.

22:50.280 --> 22:55.680
Semantics is basically, it's a branch of science,

22:55.680 --> 22:58.560
of philosophy, which is fundamentally

22:58.560 --> 23:01.240
assigning meaning to those objects

23:01.240 --> 23:03.320
that are described in the ontology.

23:03.320 --> 23:06.920
And so the way that we say this is

23:06.920 --> 23:10.320
that it's the relationship between the signifiers.

23:10.320 --> 23:14.240
So the signifiers are words, letters, symbols,

23:14.240 --> 23:16.000
graphical symbols.

23:16.000 --> 23:18.360
So how do we describe a resistor, for example,

23:18.360 --> 23:21.080
in electrical engineering?

23:21.080 --> 23:22.200
A squiggly line, right?

23:22.200 --> 23:23.880
It's the zigzag line.

23:23.880 --> 23:26.240
Well, if you don't know electrical engineering,

23:26.240 --> 23:28.840
or you never, you just see a squiggly line,

23:28.840 --> 23:30.640
it's meaningless to you.

23:30.640 --> 23:33.320
But if you know that semantically,

23:33.320 --> 23:35.400
that means that's a resistor.

23:35.400 --> 23:36.800
That's the symbol for resistor.

23:36.800 --> 23:38.920
That's what we mean by semantics.

23:38.920 --> 23:41.040
And then the third is syntax.

23:41.040 --> 23:42.000
What is syntax?

23:42.000 --> 23:46.320
It's the set of rules, the set of principles and processes

23:46.320 --> 23:51.720
by which the objects or the entities in the ontology

23:51.720 --> 23:55.120
can be combined to build up higher level information,

23:55.120 --> 23:59.360
like sentences, paragraphs, and so forth.

23:59.360 --> 24:02.880
And so that's essentially the construction rules

24:02.880 --> 24:03.760
for the language.

24:03.760 --> 24:07.520
So every language has these three things.

24:07.520 --> 24:10.040
So any questions about this before we

24:10.040 --> 24:12.480
move into our first language?

24:12.480 --> 24:15.000
So we're going to give three examples of system modeling

24:15.000 --> 24:18.120
languages, and you'll see the similarities and differences.

24:18.120 --> 24:20.880
But as you see these languages, keep in mind,

24:20.880 --> 24:25.920
they all have ontology, semantics, and syntax.

24:25.920 --> 24:29.760
Any questions about that?

24:29.760 --> 24:32.520
OK, so OPM.

24:32.520 --> 24:34.240
Let me describe to you OPM.

24:34.240 --> 24:38.160
This is one of the younger languages.

24:38.160 --> 24:41.960
And so OPM stands for Object Process Methodology.

24:41.960 --> 24:48.000
And it was created by Professor Dov Dory at Technion,

24:48.000 --> 24:49.600
colleague of mine.

24:49.600 --> 24:52.920
Dov is essentially a computer scientist by training.

24:52.920 --> 24:56.320
And you'll see the heritage here of OPM.

24:56.320 --> 25:00.600
And the big news here about OPM is OPM

25:00.600 --> 25:03.200
is not that well known yet.

25:03.200 --> 25:06.840
If you ask around, not too many people know OPM.

25:06.840 --> 25:09.040
But I predict that in the next decade,

25:09.040 --> 25:11.040
that will change very quickly.

25:11.080 --> 25:14.200
And one of the reasons is that OPM was just now

25:14.200 --> 25:17.480
adopted as an ISO standard.

25:17.480 --> 25:20.560
And if you know ISO, the International Standards Organization

25:20.560 --> 25:23.440
that are located in Geneva, it's a big deal

25:23.440 --> 25:24.920
to become an ISO standard.

25:24.920 --> 25:26.880
It took like five years, the whole process,

25:26.880 --> 25:28.840
with committees and reviews.

25:28.840 --> 25:32.280
And so the ISO standard is actually,

25:32.280 --> 25:35.080
OPM was adopted as an ISO standard

25:35.080 --> 25:39.640
as a means to describe and develop other standards.

25:39.640 --> 25:41.600
So it's kind of a meta language.

25:41.600 --> 25:43.600
Because as you can imagine, when you

25:43.600 --> 25:45.880
read different ISO standards, which by the way

25:45.880 --> 25:48.480
have a lot of influence, they're also

25:48.480 --> 25:50.760
written in natural language and graphics

25:50.760 --> 25:52.160
and lots of inconsistencies.

25:52.160 --> 25:54.920
So the idea is that future ISO standards

25:54.920 --> 25:58.080
should be written using OPM, such that they're

25:58.080 --> 26:00.680
clear and consistent and so forth.

26:00.680 --> 26:05.640
So the history here is that if we go back further,

26:06.600 --> 26:09.680
there was UML, which is Unified Modeling Language, which

26:09.680 --> 26:12.800
I'm not going to talk about today, is a software.

26:12.800 --> 26:15.080
This is a language that was developed primarily

26:15.080 --> 26:17.000
for software engineering.

26:17.000 --> 26:20.040
To consistently describe use cases,

26:20.040 --> 26:25.400
to consistently describe activity and flows in software,

26:25.400 --> 26:27.440
the structure of software.

26:27.440 --> 26:29.360
But it's really software-centric.

26:29.360 --> 26:32.960
So from UML2, we then sort of branched off

26:33.000 --> 26:36.800
into CISML, which Mark showed us, who just joined us.

26:36.800 --> 26:39.040
We'll talk about.

26:39.040 --> 26:41.560
And then OPM.

26:41.560 --> 26:43.760
So these are sort of derivatives of UML.

26:43.760 --> 26:45.360
And there's a book.

26:45.360 --> 26:50.440
It's not one of the mandatory books for this class, OPM 2002.

26:50.440 --> 26:52.200
If you're really interested in OPM,

26:52.200 --> 26:54.440
I recommend you invest in that book.

26:54.440 --> 26:57.440
It's really very well written.

26:57.440 --> 27:02.360
So let me give you an example of how

27:02.360 --> 27:04.000
OPM can be used.

27:04.000 --> 27:06.760
So like we said, typical product representations

27:06.760 --> 27:09.680
are sketches, engineering drawings, or UML diagrams

27:09.680 --> 27:14.920
in software, but the need for a unified representation.

27:14.920 --> 27:19.600
And fundamentally, we have functions,

27:19.600 --> 27:23.240
and then we have objects, form, and function in systems.

27:23.240 --> 27:27.280
And so what we would like to do, and what the premise of OPM

27:27.280 --> 27:33.120
is that we can show everything in one diagram type.

27:33.120 --> 27:38.360
So the functions, the functional attributes, the objects,

27:38.360 --> 27:41.200
and there's different types of objects, operands, system

27:41.200 --> 27:45.320
components, consumables, the attributes of those objects,

27:45.320 --> 27:46.440
and then the links.

27:46.440 --> 27:48.520
And I'll show you the different types of links

27:48.520 --> 27:51.000
between these that exist in OPM.

27:51.000 --> 27:53.200
So it's a generic modeling language,

27:53.200 --> 27:55.120
and it has been successfully applied

27:55.120 --> 27:57.920
to system architecting of complex products

27:57.920 --> 27:59.720
in different organizations.

27:59.720 --> 28:02.320
I'm going to try to give you a pretty simple example here,

28:02.320 --> 28:03.720
which is a refrigerator.

28:03.720 --> 28:04.400
So think about it.

28:04.400 --> 28:08.440
We're going to look at a small household level refrigerator

28:08.440 --> 28:12.040
through the eyes of OPM.

28:12.040 --> 28:16.040
All right, so here's the basic ontology of OPM.

28:16.040 --> 28:18.000
It's very, very simple.

28:18.000 --> 28:24.200
And the idea is to have as few objects, as few entities

28:24.200 --> 28:27.440
as possible in the language to keep it simple.

28:27.440 --> 28:31.360
So the first one is the idea of an object.

28:31.360 --> 28:32.600
What is an object?

28:32.600 --> 28:35.840
And objects are drawn as these rectangles.

28:35.840 --> 28:39.840
Objects are defined as entities that

28:39.840 --> 28:44.480
have the potential for stable, unconditional existence

28:44.480 --> 28:47.160
for some positive duration of time.

28:47.160 --> 28:49.680
And objects have states within them.

28:49.680 --> 28:55.360
So what would be an example of an object

28:55.360 --> 28:57.440
that we've talked about today?

28:57.440 --> 28:58.400
Go ahead.

28:58.400 --> 28:59.640
Maybe the sticky tape.

28:59.640 --> 29:01.960
Yeah, so the sticky tape itself, that's an object.

29:01.960 --> 29:04.000
It exists unconditionally.

29:04.000 --> 29:05.000
It's there.

29:05.000 --> 29:08.920
And what's important is it could be a physical object.

29:08.920 --> 29:11.280
So it has a physical existence.

29:11.280 --> 29:16.040
But it could also be an informational object.

29:16.040 --> 29:19.400
So for example, if you have an idea,

29:19.440 --> 29:22.920
or a vision, that's an object, too.

29:22.920 --> 29:24.560
It's not physical in that sense.

29:24.560 --> 29:29.000
But it does exist as an informational object.

29:29.000 --> 29:30.640
What are states?

29:30.640 --> 29:31.920
Let's see it, EPFL.

29:31.920 --> 29:34.520
What would be an example of a state that's

29:34.520 --> 29:36.080
associated with an object?

29:43.760 --> 29:46.360
Yeah, that's OK.

29:46.360 --> 29:49.240
Can somebody give an example of a state?

29:50.200 --> 29:52.760
Rolled and unrolled for the sticky tape?

29:52.760 --> 29:55.280
Rolled and unrolled, exactly.

29:55.280 --> 29:56.760
Or furled and unfurled.

29:56.760 --> 29:59.000
So that's kind of a binary state.

29:59.000 --> 30:03.440
There could be halfway unrolled, or the sticky tape

30:03.440 --> 30:06.800
is full of flies, or it's kind of empty.

30:06.800 --> 30:09.000
Those would be describing the object

30:09.000 --> 30:11.920
in terms of what state it is in, exactly.

30:11.920 --> 30:17.160
So the form is then the sum of all these objects.

30:17.200 --> 30:19.440
So that's one building block.

30:19.440 --> 30:21.800
And then processes are the other.

30:21.800 --> 30:23.400
So what are processes?

30:23.400 --> 30:24.560
Oh, is there another example?

30:24.560 --> 30:25.400
Yeah, go ahead.

30:25.400 --> 30:26.360
Can I ask a question?

30:26.360 --> 30:28.680
Is this Katya?

30:28.680 --> 30:29.200
Go ahead.

30:29.200 --> 30:33.840
Katya, what do you mean by positive duration of time?

30:33.840 --> 30:37.920
Well, meaning that, so the object could be created, right?

30:37.920 --> 30:39.360
It didn't exist before.

30:39.360 --> 30:42.760
It's created, and it exists, and then it could be destroyed

30:42.760 --> 30:43.640
again.

30:43.640 --> 30:46.560
It could disappear, or it could be consumed.

30:46.560 --> 30:48.280
But it means that the object needs

30:48.280 --> 30:52.600
to exist for a non-zero period of time

30:52.600 --> 30:57.680
in order for it to be called an object, right?

30:57.680 --> 31:02.640
So objects in the world that can be described with OPM

31:02.640 --> 31:06.600
fundamentally, objects can be created,

31:06.600 --> 31:09.960
objects can be modified, particularly their states

31:09.960 --> 31:14.600
can be modified, and they can be destroyed or consumed.

31:14.600 --> 31:16.120
That's basically it.

31:16.120 --> 31:18.760
That's a complete set, OK?

31:18.760 --> 31:21.400
Does that make sense?

31:21.400 --> 31:24.440
OK, so processes are, what are processes?

31:24.440 --> 31:26.560
Processes are really fundamentally different

31:26.560 --> 31:27.320
from objects.

31:27.320 --> 31:30.560
Processes are shown as these ellipses,

31:30.560 --> 31:33.760
and they're the patterns of transformation

31:33.760 --> 31:37.400
applied to one or more objects, and processes change states.

31:37.400 --> 31:42.160
So processes, unlike objects, cannot exist on their own.

31:42.160 --> 31:45.520
Processes only make sense if they're

31:45.520 --> 31:48.880
associated with at least one object, OK?

31:48.880 --> 31:52.440
So processes are essentially the functions

31:52.440 --> 31:56.280
that we develop in systems are processes that transform

31:56.280 --> 31:59.480
or create, destroy, or transform objects.

31:59.480 --> 32:02.840
So function emerges from one or more processes,

32:02.840 --> 32:05.520
and then we have different links between objects

32:05.520 --> 32:06.800
and processes.

32:06.800 --> 32:08.040
I'll show you two examples here.

32:08.040 --> 32:11.280
One is the arrow with a pointy head, OK?

32:11.280 --> 32:18.840
That could be a consumption or production type link,

32:18.840 --> 32:23.480
or a link with this little lollipop symbol.

32:23.480 --> 32:26.000
This is known as an instrument link.

32:26.000 --> 32:29.280
And so the difference there is that if an object is

32:29.280 --> 32:32.040
linked to a process using an arrow,

32:32.040 --> 32:34.480
it means that something's happening to that object.

32:34.480 --> 32:37.400
It's being created or destroyed or modified.

32:37.400 --> 32:40.640
If an object is linked to a process using the lollipop

32:40.640 --> 32:43.160
symbol, the instrument link, it means

32:43.160 --> 32:46.360
that in order for that process to happen,

32:46.360 --> 32:48.000
this object is needed.

32:48.000 --> 32:49.320
It's an instrument.

32:49.320 --> 32:51.360
But the object itself, the instrument,

32:51.360 --> 32:55.120
does not get modified in any way by the process.

32:55.120 --> 32:59.560
But the process couldn't happen if that object didn't exist.

32:59.560 --> 33:01.160
Do you see the difference?

33:01.160 --> 33:03.520
And so one of the really, I think, important things

33:03.520 --> 33:06.360
about OPM, but any of the languages,

33:06.400 --> 33:10.040
is that every box, every arrow, every link

33:10.040 --> 33:12.640
has precise semantics.

33:12.640 --> 33:16.000
And usually, when we doodle, when we just think about it,

33:16.000 --> 33:18.960
we put arrows and links between boxes,

33:18.960 --> 33:20.920
we often don't really deeply think,

33:20.920 --> 33:24.000
when I put a link in here, what does that link actually mean?

33:24.000 --> 33:25.760
What does link imply?

33:25.760 --> 33:28.840
So when you do system modeling using these languages,

33:28.840 --> 33:31.400
you become much, much more precise.

33:31.400 --> 33:32.440
Yes, please.

33:32.440 --> 33:34.920
And would you push the mic button when you?

33:34.920 --> 33:36.480
Mark, go ahead.

33:36.480 --> 33:39.520
Can an object be a process or a process be an object?

33:39.520 --> 33:40.800
No.

33:40.800 --> 33:45.160
So what about if you have, I guess

33:45.160 --> 33:48.680
I'm thinking in terms of if there's

33:48.680 --> 33:50.640
some process for doing some procedure,

33:50.640 --> 33:53.800
and you're assembling a satellite or whatnot,

33:53.800 --> 33:55.440
you need to modify that process.

33:55.440 --> 33:58.920
So how is that sort of thing represented in OPM?

33:58.920 --> 34:04.160
The process modifies objects, but processes cannot modify

34:04.160 --> 34:06.280
other processes, because processes

34:06.280 --> 34:11.360
are fundamentally in OPM acting upon the objects.

34:11.360 --> 34:13.440
Now, processes can invoke each other.

34:13.440 --> 34:16.000
So if there's a sequence of processes,

34:16.000 --> 34:19.400
you have to do this assembly step before this other assembly

34:19.400 --> 34:24.080
step, you can have what's called an invocation link.

34:24.080 --> 34:26.560
But that's a logical dependency between processes.

34:26.560 --> 34:28.160
But fundamentally, the processes

34:28.160 --> 34:30.640
act through the objects in OPM.

34:31.360 --> 34:32.360
OK.

34:32.360 --> 34:35.560
So let me be a little bit more.

34:35.560 --> 34:37.320
So let's go into some more detail.

34:37.320 --> 34:41.080
So at a high level, when you look at the economy,

34:41.080 --> 34:45.280
right, products, yes, go ahead.

34:45.280 --> 34:45.960
I have a question.

34:45.960 --> 34:51.400
Why create another language and not just stick with UML?

34:51.400 --> 34:54.800
So good question.

34:54.800 --> 34:59.640
So we'll talk about SysML, which is very similar to UML.

34:59.640 --> 35:02.480
It's sort of generalized for cyber-physical systems,

35:02.480 --> 35:03.960
not just software.

35:03.960 --> 35:07.600
So the reason that OPM was created,

35:07.600 --> 35:11.440
because UML was found to be somewhat too confining,

35:11.440 --> 35:14.720
this is more general, and also the idea

35:14.720 --> 35:19.080
of a unified representation, one type of diagram

35:19.080 --> 35:22.440
and description for any application.

35:22.440 --> 35:27.040
So it's basically a kind of more general version of UML.

35:27.040 --> 35:29.600
But the other really important thing about OPM

35:29.600 --> 35:36.880
is that the processes are often in object-oriented thinking.

35:36.880 --> 35:40.000
Processes are embedded inside objects.

35:40.000 --> 35:45.000
And in OPM, the processes have been emancipated

35:45.000 --> 35:47.520
to stand at the same level as objects.

35:47.520 --> 35:49.720
Those are the main differences.

35:49.720 --> 35:53.160
So let me go in a little bit more detail.

35:53.160 --> 35:58.120
So if you think about the economy in general,

35:58.120 --> 36:01.680
goods and services, goods are objects,

36:01.680 --> 36:04.120
and services are processes.

36:04.120 --> 36:13.760
So if you buy a new iPad or a new pencil or whatever it is,

36:13.760 --> 36:16.080
you're actually buying an object.

36:16.080 --> 36:17.440
You're purchasing an object.

36:17.440 --> 36:19.480
That's obvious.

36:19.480 --> 36:21.720
But why are you purchasing that object?

36:24.160 --> 36:28.200
So let's say you're buying a new tablet.

36:28.200 --> 36:30.280
You're buying the tablet.

36:30.280 --> 36:34.200
But why are you buying the tablet?

36:34.200 --> 36:34.880
Sam, go ahead.

36:39.480 --> 36:42.360
You're buying the tablet to perform an action

36:42.360 --> 36:45.520
or process on something else, to do something.

36:45.520 --> 36:46.760
So what do tablets do?

36:46.760 --> 36:49.960
I mean, not stone tablets, but modern tablets.

36:49.960 --> 36:56.560
They allow you to work with software or communicate.

36:56.560 --> 36:59.240
Yeah, so they're information processing.

36:59.240 --> 37:01.320
They're information processing devices.

37:01.320 --> 37:03.600
And there's an argument.

37:03.600 --> 37:05.640
Tablets are great for consuming information.

37:05.640 --> 37:09.560
They're maybe not as good for generating new information.

37:09.560 --> 37:13.360
So fundamentally, you're purchasing the tablet,

37:13.360 --> 37:16.800
which is an object, in order to be

37:16.800 --> 37:18.880
able to do information processing,

37:18.880 --> 37:20.680
and information consumption.

37:20.680 --> 37:25.200
So the process is then implicit, right?

37:25.200 --> 37:26.160
What's an example?

37:26.160 --> 37:29.880
If you purchase a service, what would be an example of a service?

37:33.920 --> 37:37.480
What would be an example of a service?

37:37.480 --> 37:38.600
Let's see at EPFL.

37:38.600 --> 37:41.200
What would be an example of a service that you could purchase?

37:47.360 --> 37:48.560
Going to the dentist.

37:48.560 --> 37:49.880
Going to the dentist.

37:49.880 --> 37:53.560
Yeah, one of our favorite things to do.

37:53.560 --> 37:55.720
So have you been there recently, or?

37:58.520 --> 38:00.200
Yeah, one month ago.

38:00.200 --> 38:04.320
So I don't want to violate your privacy,

38:04.320 --> 38:09.800
but can you share with us what happened at the dentist?

38:09.800 --> 38:11.480
Usually, it's the yearly checkup.

38:11.480 --> 38:16.080
You have to check that there's no hidden,

38:16.120 --> 38:19.160
I don't know how do you call it in English, the caries?

38:19.160 --> 38:21.160
Yeah, cavities.

38:21.160 --> 38:22.760
Yeah, cavities.

38:22.760 --> 38:25.440
Check that wisdom tooth don't mess up

38:25.440 --> 38:28.560
what you've been walking on tirelessly

38:28.560 --> 38:30.240
when you were younger with braces.

38:30.240 --> 38:35.160
And also these kind of things, get checked.

38:35.160 --> 38:36.160
Very good.

38:36.160 --> 38:39.840
So going to the dentist provides a service, which

38:39.840 --> 38:43.840
is either checking your teeth, or filling cavities, which

38:43.840 --> 38:45.240
is a process.

38:45.240 --> 38:47.520
And all the objects, the chair on which you sit,

38:47.520 --> 38:51.640
the instruments, I guess we still use gold sometimes

38:51.640 --> 38:54.880
in some places, those are objects that

38:54.880 --> 38:57.440
are used in the performance of the service.

38:57.440 --> 38:59.640
You see the relationship?

38:59.640 --> 39:02.760
So objects and processes always come in pairs.

39:02.760 --> 39:04.760
Thank you for that example.

39:04.760 --> 39:08.680
So let me talk about the links in OPM briefly.

39:08.680 --> 39:09.680
So there are two types.

39:09.680 --> 39:13.800
There's the structural links, which link objects to objects.

39:13.800 --> 39:16.760
And we typically use arrows, is related to,

39:16.760 --> 39:19.000
or we can tag these as well.

39:19.000 --> 39:22.000
So for example, something powers something else.

39:22.000 --> 39:23.760
This is known as a tagged link.

39:23.760 --> 39:26.080
It suppresses the processes.

39:26.080 --> 39:30.200
And then there's these triangles that are essentially,

39:30.200 --> 39:32.800
there's a kind of hierarchy implied there.

39:32.800 --> 39:34.840
And slightly different meanings.

39:34.840 --> 39:38.680
So the solid triangle means decomposition.

39:38.680 --> 39:41.760
So the higher level object is composed

39:42.120 --> 39:43.880
of lower level objects.

39:43.880 --> 39:46.600
So that's Mark, you mentioned assembly.

39:46.600 --> 39:48.960
You're creating the bus of the spacecraft,

39:48.960 --> 39:51.120
and it has a whole bunch of stuff in it.

39:51.120 --> 39:53.680
Well, you would use this filled in triangle

39:53.680 --> 39:55.480
to show that decomposition.

39:55.480 --> 39:59.160
The second example is the characterization link.

39:59.160 --> 40:02.840
So this is essentially relating an attribute

40:02.840 --> 40:05.200
to its kind of master object.

40:05.200 --> 40:09.160
Specialization and generalization is the empty triangle.

40:09.160 --> 40:12.400
And then this funny symbol here is instantiation.

40:12.400 --> 40:17.400
So essentially you have a general object,

40:17.480 --> 40:19.000
and then you can instantiate that.

40:19.000 --> 40:21.200
So I have two children, okay?

40:21.200 --> 40:23.760
And then there's two, I have two children,

40:23.760 --> 40:27.680
which is general, and there's two instantiations of them.

40:27.680 --> 40:29.160
One of them is called Gabrielle,

40:29.160 --> 40:30.480
and one of them is called Christian,

40:30.480 --> 40:31.960
and they're actual people.

40:31.960 --> 40:35.920
So that's the idea of instantiation.

40:35.920 --> 40:40.920
Processes, processes are these patterns of transformation.

40:41.480 --> 40:42.600
They're tricky.

40:42.600 --> 40:45.600
Processes are trickier to understand than the objects

40:45.600 --> 40:48.040
because we cannot hold or touch a process.

40:48.040 --> 40:51.640
It's fleeting, and the creation change

40:51.640 --> 40:55.760
or destruction of objects is what processes do.

40:55.760 --> 40:58.320
They rely on at least one object

40:58.320 --> 41:00.760
in what we call the pre-process set.

41:00.760 --> 41:03.680
A process transforms at least one object,

41:03.720 --> 41:06.880
and the time is implied.

41:06.880 --> 41:09.360
So processes take along a timeline.

41:09.360 --> 41:12.240
And in terms of the description in English,

41:12.240 --> 41:14.280
we use the so-called gerund form.

41:14.280 --> 41:16.400
So all the processes,

41:16.400 --> 41:18.040
there's some examples on the right side,

41:18.040 --> 41:20.520
use the ing form of a verb.

41:21.960 --> 41:26.440
So we can then put these together, objects and processes.

41:26.440 --> 41:29.040
So here's an example of a machine.

41:29.040 --> 41:31.840
This happens to be like a printer or copy machine.

41:31.840 --> 41:33.480
It has a main switch.

41:33.480 --> 41:36.840
The main switch has an attribute called main switch state,

41:36.840 --> 41:38.440
which can be on or off.

41:39.680 --> 41:43.680
The process of switching transforms, in this case,

41:43.680 --> 41:46.520
the main switch state from on to off,

41:46.520 --> 41:48.200
or we could go the other way.

41:48.200 --> 41:51.280
And in order for this to happen, we have here,

41:52.280 --> 41:55.200
this is actually slightly different than the instrument link.

41:55.200 --> 41:57.160
This is a filled-in lollipop,

41:57.160 --> 41:59.320
which is known as an agent link.

41:59.320 --> 42:01.640
So the operator is an active agent

42:01.640 --> 42:03.800
to carry out the switching process,

42:03.800 --> 42:05.680
which changes the main switch state

42:05.680 --> 42:07.960
from on to off or off to on.

42:07.960 --> 42:10.480
And the main switch state is an attribute

42:10.480 --> 42:13.400
of the main switch, right?

42:13.400 --> 42:16.320
So transporting, this is another example.

42:16.320 --> 42:19.120
Transporting changes the state of a person

42:19.120 --> 42:22.160
from being here, location A,

42:22.160 --> 42:24.480
to being there, location B.

42:27.240 --> 42:31.240
So there are seven, huh, coincidence,

42:31.280 --> 42:36.280
seven, seven object process links in OPM.

42:37.920 --> 42:42.680
So P changes, the process changes the object,

42:42.680 --> 42:44.160
say from state A to B,

42:44.160 --> 42:46.800
that's the example we just looked at.

42:46.800 --> 42:48.120
You can actually hide that.

42:48.120 --> 42:50.920
If you're really not interested in all the states

42:50.920 --> 42:53.080
and details, you hide the states.

42:53.080 --> 42:54.640
You don't wanna see them.

42:54.640 --> 42:56.040
And then you can replace that

42:56.040 --> 42:58.520
with what's called the affect T link,

42:58.520 --> 43:00.560
which is this two-sided arrow.

43:00.560 --> 43:03.480
And all you know is that this process

43:03.480 --> 43:05.720
is affecting that object, right?

43:05.720 --> 43:07.560
And it's a two-sided arrow.

43:07.560 --> 43:09.440
But you don't know exactly how,

43:09.440 --> 43:10.760
but you know it's affected.

43:11.760 --> 43:14.800
A result T link, so this is an arrow pointing

43:14.800 --> 43:17.300
from the process to the object,

43:17.300 --> 43:20.200
means that the process of transporting

43:20.200 --> 43:23.160
produces emissions, right, that weren't there before.

43:23.160 --> 43:24.980
So that's a result T link.

43:24.980 --> 43:26.640
But the process of transporting

43:26.640 --> 43:29.200
requires or consumes energy.

43:29.200 --> 43:31.440
So the arrow is pointing from energy

43:31.440 --> 43:33.560
into the transporting process,

43:33.560 --> 43:34.960
because it's being consumed.

43:36.080 --> 43:37.600
I did mention the agent link,

43:37.600 --> 43:39.600
so there's an operator of a vehicle.

43:39.600 --> 43:42.000
And this, you know, when we talk about

43:42.000 --> 43:45.520
autonomously driving vehicles, big topic right now,

43:45.520 --> 43:47.800
actually it was cool at EPFL this summer,

43:47.800 --> 43:51.400
there's the autonomous shuttle right on the campus,

43:51.400 --> 43:53.880
the electric shuttle, did anybody take that?

43:53.880 --> 43:57.040
Did you guys try that shuttle this summer?

43:57.040 --> 43:58.560
Yeah, did you like it?

44:00.040 --> 44:03.120
No, I didn't, but the friend is working

44:03.120 --> 44:06.760
in this kind of shuttle, like sitting for hours

44:06.760 --> 44:08.560
waiting for people actually.

44:08.560 --> 44:11.360
Okay, so fundamentally, I mean,

44:11.360 --> 44:13.920
if you wanna think of this in OPM language,

44:14.880 --> 44:18.120
driverless vehicle is basically eliminating this, right?

44:18.120 --> 44:21.560
No longer needing an operator with an agent link

44:21.560 --> 44:24.400
and replacing this with a piece of software,

44:24.400 --> 44:27.340
which would be an instrument link.

44:28.340 --> 44:31.140
So the instrument, the transporting process

44:31.140 --> 44:33.940
requires a vehicle, and then we have what's known

44:33.940 --> 44:35.740
as a conditional link.

44:35.740 --> 44:39.020
So this process can only occur if this object

44:39.020 --> 44:40.860
is in that particular state.

44:40.860 --> 44:43.260
So this example here obviously ignores

44:43.260 --> 44:46.020
the existence of credit cards.

44:46.020 --> 44:49.900
So you can do the purchasing, purchasing,

44:49.900 --> 44:52.980
the process of purchasing is conditional

44:52.980 --> 44:56.940
upon the state of the object money

44:56.940 --> 45:01.100
being in a state of enough for doing the purchase, right?

45:02.660 --> 45:07.060
Okay, so here's an example of a little bit more complicated.

45:07.060 --> 45:11.740
This is a level zero OPM diagram of a car, of a vehicle.

45:11.740 --> 45:15.660
So you can see in the upper right is sort of a sketch

45:15.660 --> 45:18.860
of a vehicle and it has these different attributes.

45:18.860 --> 45:23.260
ED is engine displacement, height, ground clearance,

45:23.260 --> 45:25.860
overall length, wheel base.

45:25.900 --> 45:28.780
There's a trailer here with a towing capacity.

45:28.780 --> 45:31.540
So the way you would interpret this

45:31.540 --> 45:34.140
is that we have a transporting process.

45:34.140 --> 45:37.740
That's our master sort of the highest level process.

45:37.740 --> 45:40.420
And it changes the attribute location

45:40.420 --> 45:44.460
for driver, passengers, and cargo from A to B, right?

45:44.460 --> 45:46.820
And that's fundamentally where the value is

45:46.820 --> 45:49.340
for the owner of the vehicle.

45:49.340 --> 45:52.060
And then we can zoom in to the transporting process

45:52.060 --> 45:55.980
and look at sub-processes, towing, propelling, and housing.

45:55.980 --> 45:57.780
And if you think about what a vehicle does

45:57.780 --> 46:00.940
at the highest level, right, it protects you,

46:00.940 --> 46:04.540
it houses you, and it propels you, right?

46:04.540 --> 46:07.820
Those are, and then you can break those into more detail.

46:07.820 --> 46:09.140
And then on the left side here,

46:09.140 --> 46:13.180
we have essentially the elements of form.

46:13.180 --> 46:15.380
So the automobile, which is an instrument

46:15.380 --> 46:16.740
of the transporting process,

46:16.740 --> 46:20.140
can be decomposed into its major subsystems,

46:20.140 --> 46:22.780
powertrain, chassis, body, wheels.

46:22.780 --> 46:24.740
And each of those are characterized.

46:24.740 --> 46:26.540
You see those attribute links?

46:26.540 --> 46:31.660
Characterized by things like fuel capacity,

46:31.660 --> 46:33.220
engine displacement.

46:33.220 --> 46:36.580
This is the design domain we talked about last time, right?

46:36.580 --> 46:39.940
Ground clearance, and so those are the design variables.

46:39.940 --> 46:41.820
Those are the parts and assemblies.

46:41.820 --> 46:44.020
And then on the right side, the processes,

46:44.020 --> 46:46.580
the internal processes can also be characterized

46:46.580 --> 46:49.820
by performance or functional attributes,

46:49.820 --> 46:54.540
like towing capacity, fuel economy, acceleration.

46:54.540 --> 46:58.020
PV stands for passenger volume and cargo volume.

46:58.020 --> 46:59.180
And those are things, you know,

46:59.180 --> 47:01.980
when you're comparing different vehicles to purchase,

47:01.980 --> 47:03.060
you know, those are the things

47:03.060 --> 47:05.140
you would compare vehicles against.

47:05.140 --> 47:07.140
So those are the internal functions,

47:07.140 --> 47:09.500
and then the functional attributes.

47:09.500 --> 47:12.980
And then up here, there's the fuel and emissions

47:12.980 --> 47:14.460
and safety-related issues,

47:14.460 --> 47:17.300
which that's often where the governments intervene

47:17.300 --> 47:18.740
and then regulate.

47:18.740 --> 47:22.420
And, you know, this is sort of a highest level OPM

47:22.420 --> 47:23.820
of a vehicle.

47:23.820 --> 47:25.780
And then if you want to see more detail,

47:25.780 --> 47:27.980
you would start drilling down into these.

47:27.980 --> 47:30.180
And you'd have multiple levels of these,

47:30.180 --> 47:31.940
like a higher key of these diagrams.

47:31.940 --> 47:33.260
Yeah.

47:33.260 --> 47:36.300
So here, what is the use of the,

47:36.300 --> 47:40.660
or the meaning of the open arrows in the,

47:40.660 --> 47:42.340
it looks like there's a couple different arrows here

47:42.340 --> 47:44.940
than what we had in the other guy.

47:44.940 --> 47:46.860
Are you talking about these guys?

47:48.100 --> 47:49.060
No.

47:49.060 --> 47:50.780
Oh, these here, yeah.

47:50.780 --> 47:53.340
So they're, it's just a visual,

47:53.340 --> 47:55.260
there's no distinction on the arrows,

47:55.260 --> 47:56.780
whether they're filled in or empty.

47:56.780 --> 47:59.140
That's just a kind of graphical thing.

47:59.140 --> 47:59.980
Yeah.

48:01.340 --> 48:05.420
Okay, so one of the, yes, Veronica,

48:05.420 --> 48:06.500
do you want to push the,

48:08.260 --> 48:10.460
how would you represent a process

48:10.460 --> 48:13.200
that creates kind of a temporary state?

48:14.460 --> 48:15.820
So if you were, if you're saying,

48:15.820 --> 48:17.700
this is acted on an object and this changes

48:17.700 --> 48:18.940
the form of the object,

48:18.940 --> 48:20.620
but the object will ultimately return

48:20.620 --> 48:21.580
to its original state,

48:21.580 --> 48:24.540
kind of absent of a reversing process,

48:24.540 --> 48:27.060
if it's a natural tendency for the object to return.

48:28.260 --> 48:30.500
How would you represent that change?

48:30.500 --> 48:31.580
Would you need to break it down

48:31.580 --> 48:35.060
as a kind of a sub-process within the object or?

48:35.060 --> 48:36.540
Right, so, I mean, and this,

48:36.540 --> 48:38.140
there's sometimes there's multiple,

48:38.140 --> 48:39.340
is there's non-uniqueness

48:39.340 --> 48:41.100
in sort of representing the same thing,

48:41.100 --> 48:43.540
but there's one process that brings you

48:43.540 --> 48:44.980
to the temporary state.

48:44.980 --> 48:45.820
Okay.

48:45.820 --> 48:47.260
And then there would be a restoring process

48:47.260 --> 48:49.380
that restores you back to the original state.

48:49.380 --> 48:52.380
Does the process have to be a separate plan

48:52.380 --> 48:53.820
within the system?

48:53.820 --> 48:55.820
Because there are certain objects, right,

48:55.820 --> 48:56.740
that have a tendency,

48:56.740 --> 48:59.020
I'm thinking primarily kind of a chemical states

48:59.020 --> 49:01.220
where reactions would happen naturally.

49:01.220 --> 49:02.900
And it's kind of a specific thing,

49:02.900 --> 49:04.220
but I was thinking about how you might model

49:04.220 --> 49:05.060
different systems.

49:05.060 --> 49:07.140
And I was thinking about the engine of the car,

49:07.180 --> 49:09.540
just kind of how things might naturally return.

49:09.540 --> 49:12.580
So do you have to describe the process explicitly

49:12.580 --> 49:17.580
if it's not something that's inherently designed in,

49:17.660 --> 49:20.220
if it's kind of a, if it will happen anyway?

49:21.540 --> 49:22.860
I think, I wouldn't,

49:22.860 --> 49:25.180
I wanna say you have to explicitly define that.

49:25.180 --> 49:26.020
Okay.

49:26.020 --> 49:28.860
So if it's a man-made process, so to speak,

49:28.860 --> 49:30.980
then that's a process you want to happen.

49:30.980 --> 49:33.900
And then if the restoring it back to some other state

49:33.900 --> 49:36.620
is a natural process, well, it exists, right?

49:36.620 --> 49:40.380
So it will restore the system to a prior state.

49:40.380 --> 49:42.300
That process would also have to be modeled.

49:42.300 --> 49:44.140
Is there a distinction between how you would indicate

49:44.140 --> 49:45.980
a man-made process or a natural process?

49:45.980 --> 49:47.020
Not fundamentally.

49:47.020 --> 49:47.860
Okay.

49:47.860 --> 49:49.300
And in fact, OPM's been applied

49:49.300 --> 49:51.140
to modeling how a cell functions.

49:51.140 --> 49:53.460
So there's some pretty recent work on,

49:53.460 --> 49:54.860
cells are incredibly,

49:54.860 --> 49:58.180
the biological engineering is just really complex.

49:58.180 --> 50:00.940
So it's some really recent work on describing even,

50:00.940 --> 50:04.820
the RNA and cell division using very much this language.

50:04.820 --> 50:05.660
Okay.

50:05.660 --> 50:08.500
So it doesn't matter whether it's an artificial process

50:08.500 --> 50:09.900
or a natural process.

50:09.900 --> 50:10.740
Thank you.

50:10.740 --> 50:12.060
Okay, let me go a couple more minutes

50:12.060 --> 50:13.340
and then we'll take a short break

50:13.340 --> 50:16.460
and then we'll talk about SysML and Modellica.

50:16.460 --> 50:21.460
So the key thing in OPM is there's only one type of diagram

50:21.500 --> 50:24.820
and there's also natural language that gets auto-generated.

50:24.820 --> 50:27.120
And I'll show you this very quickly in the tool.

50:27.120 --> 50:30.780
So as you can imagine, as you're working on real systems,

50:30.780 --> 50:33.580
you know, these diagrams, if you showed them on one,

50:33.580 --> 50:36.740
one sort of level, you'd have thousands of objects

50:36.740 --> 50:38.820
and links, it would be a mess, right?

50:38.820 --> 50:41.020
So how does OPM handle complexity?

50:41.020 --> 50:43.060
There's three fundamental mechanisms.

50:43.060 --> 50:45.860
One is known as folding and unfolding.

50:45.860 --> 50:46.780
What does that mean?

50:46.780 --> 50:50.980
It's basically related to the structure.

50:50.980 --> 50:54.620
So folding, unfolding means that higher level objects,

50:54.620 --> 50:57.100
you can show the decomposition of the objects

50:57.100 --> 50:58.320
or you can hide it.

50:58.320 --> 51:00.580
That's known as folding and unfolding.

51:00.580 --> 51:04.780
Then the second one is called in-zooming or out-zooming.

51:04.780 --> 51:07.060
And so here's an example of a,

51:07.060 --> 51:10.780
here's a process and an instrument and an affectee,

51:10.780 --> 51:12.420
right, that's affected by the process.

51:12.420 --> 51:16.880
I wanna know what are the sub-processes in that process?

51:16.880 --> 51:18.980
So you can zoom into this process

51:18.980 --> 51:22.040
and it will expose the sub-processes

51:22.040 --> 51:23.540
that are happening inside.

51:23.540 --> 51:24.860
That's known as in-zooming

51:24.860 --> 51:27.540
and then going back the other way is called out-zooming.

51:28.580 --> 51:30.380
And then the third one I've already mentioned,

51:30.380 --> 51:34.580
which is that states can be expressed or suppressed

51:34.580 --> 51:37.040
or hidden depending on your interest

51:37.040 --> 51:39.380
in what states of the system you wanna look at.

51:40.940 --> 51:44.500
So here's the sort of level zero OPM of our refrigerator.

51:44.500 --> 51:46.940
I said that was kind of our case study.

51:46.940 --> 51:51.300
So how does the refrigerator work at the sort of level zero

51:51.300 --> 51:54.620
is that's what the stakeholder with the customer sees.

51:54.620 --> 51:56.940
Don't care about the details of what's happening

51:56.940 --> 51:58.660
in the refrigerator.

51:58.660 --> 52:03.660
So we have food and we'll get back to this I think next week

52:03.820 --> 52:06.900
in the kind of creativity concept generation.

52:06.900 --> 52:09.200
Why do we have refrigerators fundamentally?

52:10.620 --> 52:14.220
If you've heard this before, you keep quiet.

52:14.220 --> 52:17.580
Maybe EPFL, why do we have refrigerators?

52:22.340 --> 52:23.340
Any ideas?

52:27.220 --> 52:28.060
Go ahead.

52:28.900 --> 52:30.180
Keep food cold.

52:30.180 --> 52:33.980
Yeah, well, if you're a beer drinker,

52:33.980 --> 52:36.300
you want cold beer, right?

52:36.300 --> 52:39.060
But if you really think about it deeply,

52:39.060 --> 52:41.540
that's not really the primary reason, right?

52:41.540 --> 52:44.740
The primary reason is this state change,

52:44.740 --> 52:46.500
their shelf life, right?

52:46.500 --> 52:48.860
So the primary reason why you have refrigerators

52:48.860 --> 52:53.100
is to extend the shelf life of the food, right?

52:53.100 --> 52:57.460
So speaking as a systems architect, system engineer,

52:57.460 --> 53:02.460
a refrigerator is a food spoilage rate reduction device.

53:03.860 --> 53:04.860
You see that?

53:04.860 --> 53:08.420
So the attribute of the food is the shelf life

53:08.420 --> 53:11.100
and we're gonna extend the shelf life of the food.

53:11.100 --> 53:14.340
That is, if you think about it sort of architecturally,

53:14.340 --> 53:15.740
that's why we have refrigerators.

53:15.740 --> 53:19.220
But I agree with you on the cold beer, right?

53:19.220 --> 53:21.960
We all agree we want cold beer, not warm beer.

53:21.960 --> 53:24.740
So you're right, you're right too.

53:24.740 --> 53:27.240
So the refrigerator essentially is an instrument

53:27.240 --> 53:30.040
of extending the food shelf life.

53:30.040 --> 53:32.520
So the food is the operand.

53:32.520 --> 53:34.320
The food is the operand.

53:34.320 --> 53:36.520
The extending of shelf life is what we call

53:36.520 --> 53:38.960
the primary value delivering process.

53:38.960 --> 53:40.620
That's where the value is.

53:40.620 --> 53:44.320
The refrigerator itself is the product system.

53:44.320 --> 53:48.460
And then the operator sets the thermostat setting

53:48.460 --> 53:51.160
at which temperature the refrigerator should be.

53:51.160 --> 53:53.920
And then here we have the primary operating process,

53:53.960 --> 53:57.800
which is what allows us to keep the temperature

53:57.800 --> 53:59.720
of the food at that level.

53:59.720 --> 54:02.480
And in order to do this, we consume electrical power,

54:02.480 --> 54:05.800
we produce waste heat, and we also require

54:05.800 --> 54:09.160
or we convect that waste heat to the exterior air

54:09.160 --> 54:10.620
at a certain temperature.

54:11.600 --> 54:14.800
How well do refrigerators work in a vacuum chamber?

54:19.920 --> 54:21.640
They don't, right?

54:21.640 --> 54:22.480
They don't.

54:23.120 --> 54:25.920
Well, I guess you could radiate the heat a little bit,

54:25.920 --> 54:28.160
but they're not gonna work very well.

54:28.160 --> 54:29.760
You're not gonna have conduction, right?

54:29.760 --> 54:32.200
Because you're sort of in the middle of the vacuum chamber.

54:32.200 --> 54:33.520
You're not gonna have convection,

54:33.520 --> 54:34.720
so you only have radiation,

54:34.720 --> 54:36.920
and it's not gonna work very well.

54:36.920 --> 54:40.320
So the exterior air is important

54:40.320 --> 54:42.320
for the refrigerator to work.

54:42.320 --> 54:45.600
So then you say, well, okay, that's fine, I buy that.

54:45.600 --> 54:48.500
But now I wanna really know, how does it really work?

54:48.500 --> 54:51.840
So you say operating, the refrigerator is operating,

54:51.840 --> 54:56.720
but I wanna do in-zooming and understand how is it operating?

54:56.720 --> 54:58.840
So what's the key to refrigeration?

55:00.080 --> 55:02.940
What's the magic word there, or two magic words?

55:07.640 --> 55:08.920
Yep, that's part of it.

55:08.920 --> 55:11.720
That's just a sliver of it.

55:11.720 --> 55:13.240
Heat exchange is part of it.

55:13.240 --> 55:17.560
So the magic word is carno cycle, right?

55:17.560 --> 55:20.680
So here's a little graphic that sort of gets into it.

55:20.680 --> 55:25.520
So the carno cycle is actually a thermodynamic concept, right?

55:25.520 --> 55:30.040
Where you're compressing essentially a refrigerant,

55:30.040 --> 55:32.800
you're a coolant is being compressed,

55:32.800 --> 55:35.920
absorbs the heat from the inside,

55:35.920 --> 55:39.480
and then expands and condenses and radiates that,

55:39.480 --> 55:42.400
or convects that heat to the outside.

55:42.400 --> 55:44.240
So here's a, I don't know if you remember

55:44.240 --> 55:45.720
your thermodynamics, right?

55:45.720 --> 55:48.240
This is a classic PV diagram.

55:48.240 --> 55:50.760
You've got the four legs of the carno cycle,

55:50.760 --> 55:52.720
and actually what's really nice here,

55:52.720 --> 55:55.340
so we're going through this counterclockwise,

55:55.340 --> 55:59.080
what's really nice about it is that every leg of the carno

55:59.080 --> 56:01.960
cycle is one of our processes, right?

56:01.960 --> 56:06.200
So compressing is this leg here from D to B,

56:06.200 --> 56:10.000
condensing is from B to A, expanding from A to E,

56:10.000 --> 56:12.720
and then evaporation happens from E to D.

56:12.760 --> 56:17.960
So the carno cycle can be decomposed

56:17.960 --> 56:20.640
into four sub-processes, right?

56:20.640 --> 56:23.880
These are the internal processes in the system

56:23.880 --> 56:26.200
that are governed by physics.

56:26.200 --> 56:29.120
So if we take that operating process

56:29.120 --> 56:31.400
that we looked at before, we can actually

56:31.400 --> 56:35.400
zoom in and see the sub-processes emerging.

56:35.400 --> 56:38.720
And so in cooling, we have those four expanding,

56:38.720 --> 56:40.920
evaporating, compressing, condensing,

56:40.920 --> 56:43.000
but I'm adding the absorbing process,

56:43.000 --> 56:44.320
which is that the heat then needs

56:44.320 --> 56:47.400
to be absorbed by the exterior air.

56:47.400 --> 56:48.800
We have to power the device.

56:48.800 --> 56:51.720
You can decompose that into grounding, protecting,

56:51.720 --> 56:55.840
supplying, regulation, keeping it at the set point.

56:55.840 --> 56:59.760
You can decompose that process into sensing, switching,

56:59.760 --> 57:02.040
and setting the set point.

57:02.040 --> 57:03.520
And then we have supporting, which

57:03.520 --> 57:07.000
is we need to be open and closing the refrigerator,

57:07.000 --> 57:09.640
retaining it, and then connecting all the pieces.

57:10.160 --> 57:14.120
At level minus 1, we had one process at level 0,

57:14.120 --> 57:15.480
which was operating.

57:15.480 --> 57:17.640
The refrigerator is operating.

57:17.640 --> 57:20.160
And then as we zoom in to level minus 1,

57:20.160 --> 57:23.440
four processes appear, powering, regulating, cooling,

57:23.440 --> 57:24.560
and supporting.

57:24.560 --> 57:28.880
And then at level minus 2, we have 15 sub-processes.

57:28.880 --> 57:33.720
So this is a view at level minus 1,

57:33.720 --> 57:37.160
our four sub-processes, cooling, powering, regulating,

57:37.160 --> 57:40.840
supporting, and then we can zoom in more.

57:40.840 --> 57:43.760
So here's the general idea, and we've

57:43.760 --> 57:45.880
looked at many systems over the years,

57:45.880 --> 57:49.880
that most cyber-physical systems, or it says

57:49.880 --> 57:52.880
optomechanical here, but I really mean it more generally,

57:52.880 --> 57:55.680
have this kind of OPM structure.

57:55.680 --> 57:58.120
On the right side, we have the output

57:58.120 --> 58:00.880
that the customer, the stakeholder, cares about,

58:00.880 --> 58:02.040
the operand.

58:02.040 --> 58:04.800
We have a set of specialized processes,

58:04.800 --> 58:07.600
and these can be often organized in a cascade.

58:07.600 --> 58:09.240
And then we have supporting processes,

58:09.240 --> 58:11.880
like powering, connecting, controlling,

58:11.880 --> 58:15.920
that provide support for the specialized processes.

58:15.920 --> 58:22.800
Most systems that we've seen have this generic architecture.

58:22.800 --> 58:24.760
How do you generate an OPM?

58:24.760 --> 58:27.040
Fundamentally, you can do a top-down.

58:27.040 --> 58:29.200
So you start with your stakeholders.

58:29.200 --> 58:31.600
That's what we did in the first lecture.

58:31.600 --> 58:33.960
Where's the value?

58:33.960 --> 58:37.200
You start thinking about requirements, what functions,

58:37.200 --> 58:40.040
how well the functions should be performed,

58:40.040 --> 58:41.560
and you sort of go down.

58:41.560 --> 58:44.000
Or if you already have a system, you can actually

58:44.000 --> 58:46.000
reverse engineer that system.

58:46.000 --> 58:51.320
And from bottom up, we started doing for the Mr. Sticky,

58:51.320 --> 58:54.880
and that's fundamentally reverse engineering.

58:54.880 --> 58:59.320
So just for time, I'm going to skip this demo.

58:59.320 --> 59:01.600
But what I will do is I will post a video.

59:01.600 --> 59:04.520
I'm going to make a little video with the OpCat demo

59:04.520 --> 59:08.000
and post that to Stellar, so you can sort of watch that.

59:08.000 --> 59:11.720
So this is one of the, it's still not super mature,

59:11.720 --> 59:14.720
but it's a Java-based program called OpCat

59:14.720 --> 59:21.400
that allows you to generate object process diagrams

59:21.400 --> 59:23.200
in its computer-supported environment

59:23.200 --> 59:27.120
and store them in an XML format and so forth.

59:27.120 --> 59:29.040
It allows you to create a hierarchy.

59:29.040 --> 59:30.680
And the other thing that's very cool,

59:30.680 --> 59:32.800
it auto-generates text.

59:32.800 --> 59:36.760
So the text is called OPL, Object Process Language.

59:36.760 --> 59:40.080
And right now, you can go from the graphics to the text,

59:40.080 --> 59:41.800
but you can't go the other way.

59:41.800 --> 59:44.280
And so there are complete sentences.

59:44.280 --> 59:47.200
It's not like an exciting novel when you read it,

59:47.200 --> 59:50.480
but it is semantically precise.

59:50.480 --> 59:53.960
So we're going to switch to SysML.

59:53.960 --> 59:55.800
We're going to take a very short break.

59:55.800 --> 59:58.120
Are there any questions about OPM?

59:58.120 --> 59:59.640
In the system architecture class,

59:59.640 --> 01:00:02.960
we spend like five, six lectures on OPM,

01:00:02.960 --> 01:00:05.280
and you get to do detailed exercises.

01:00:05.280 --> 01:00:07.680
We kind of don't have time for this in this class,

01:00:07.680 --> 01:00:10.040
but hopefully you've seen what it is.

01:00:10.040 --> 01:00:13.360
And if, you know, I've wetted your appetite for OPM,

01:00:13.360 --> 01:00:16.200
then the goal's been met.

01:00:16.200 --> 01:00:17.640
Any questions about OPM?

01:00:21.000 --> 01:00:22.960
Is it pretty clear?

01:00:22.960 --> 01:00:25.720
All right, so let's take, yes?

01:00:26.160 --> 01:00:28.680
Compared to Modellica, because I've

01:00:28.680 --> 01:00:31.960
seen one of the links that this OPM is just

01:00:31.960 --> 01:00:33.480
for describing the system there.

01:00:33.480 --> 01:00:37.160
It's not for making calculations or simulations.

01:00:37.160 --> 01:00:38.280
That's correct.

01:00:38.280 --> 01:00:40.400
There are the latest versions of OPM.

01:00:40.400 --> 01:00:42.640
You can do like a logical simulation.

01:00:42.640 --> 01:00:46.120
So you can say, OK, this process enables and does this thing.

01:00:46.120 --> 01:00:47.960
So it's kind of a discrete logical,

01:00:47.960 --> 01:00:52.080
but usually it's not used for any mathematical calculations.

01:00:52.080 --> 01:00:54.520
It's really the purpose of OPM is really

01:00:54.520 --> 01:00:58.200
to support conceptual design, early conceptual design.

01:00:58.200 --> 01:00:58.720
That's correct.

01:01:02.440 --> 01:01:04.120
OK, Mark.

01:01:04.120 --> 01:01:07.560
So just a couple words about Mark.

01:01:07.560 --> 01:01:10.800
He's a doctoral student right now in the space systems lab.

01:01:10.800 --> 01:01:15.280
He's been working a lot on an instrument called Rexis.

01:01:15.280 --> 01:01:18.600
I guess you're the chief system engineer, right, for Rexis.

01:01:18.600 --> 01:01:21.360
And that was also the topic of his master's thesis.

01:01:21.400 --> 01:01:24.880
So Mark really knows what he's talking about.

01:01:24.880 --> 01:01:27.160
He knows SysML quite well.

01:01:27.160 --> 01:01:29.080
And thanks for doing this.

01:01:29.080 --> 01:01:32.080
OK, so let me start by giving kind of a high level overview

01:01:32.080 --> 01:01:34.440
of what SysML is and what it aims to do.

01:01:34.440 --> 01:01:36.160
So it's similar to OPM, but there

01:01:36.160 --> 01:01:39.200
are a couple important differences.

01:01:39.200 --> 01:01:42.400
SysML, as Ollie said, it kind of is an extension

01:01:42.400 --> 01:01:44.800
or inherits a lot from UML.

01:01:44.800 --> 01:01:48.560
And its aim is to really provide a language that

01:01:48.560 --> 01:01:52.200
enables you to capture all the different aspects of information

01:01:52.200 --> 01:01:54.280
about a system in one place.

01:01:54.280 --> 01:01:56.720
And this concept of single source of truth

01:01:56.720 --> 01:01:58.440
is something that I'll kind of try and emphasize

01:01:58.440 --> 01:01:59.680
through my presentation.

01:01:59.680 --> 01:02:03.200
The idea is if all your information is in this one model,

01:02:03.200 --> 01:02:05.800
then communication is easy.

01:02:05.800 --> 01:02:08.680
There's no ambiguity between versions.

01:02:08.680 --> 01:02:10.840
Everyone knows where to go to get the most up to date

01:02:10.840 --> 01:02:13.080
and correct piece of information.

01:02:13.080 --> 01:02:17.160
So that's one of the emphases of SysML.

01:02:17.200 --> 01:02:20.480
SysML is a graphical language similar to OPM.

01:02:20.480 --> 01:02:22.320
It's defined in terms of diagram types

01:02:22.320 --> 01:02:25.120
that I'll go into in a second and has more than just one diagram

01:02:25.120 --> 01:02:27.040
type as compared to OPM.

01:02:27.040 --> 01:02:28.480
But basically, it aims to do things

01:02:28.480 --> 01:02:31.240
like capture functional behavioral models,

01:02:31.240 --> 01:02:33.160
capture performance models, capture

01:02:33.160 --> 01:02:35.840
the structural topology of your system, the parts of your system,

01:02:35.840 --> 01:02:37.760
and how they're all interconnected.

01:02:37.760 --> 01:02:39.480
And any other engineering analysis model

01:02:39.480 --> 01:02:41.680
is one of the big emphases with SysML

01:02:41.680 --> 01:02:44.160
is integration with external analysis tools.

01:02:44.160 --> 01:02:47.960
So if you have a thermal tool, a structural tool,

01:02:47.960 --> 01:02:49.680
electronics tool, something like that,

01:02:49.680 --> 01:02:52.560
integrating this informational, descriptional model

01:02:52.560 --> 01:02:55.720
with that analysis model and enabling,

01:02:55.720 --> 01:02:58.240
making it easy to transfer information

01:02:58.240 --> 01:03:00.520
from your descriptive model to your analysis model,

01:03:00.520 --> 01:03:02.400
do an analysis, and then incorporate those results

01:03:02.400 --> 01:03:05.680
back into your descriptive model is one of the things

01:03:05.680 --> 01:03:07.320
that SysML really is all about.

01:03:07.320 --> 01:03:09.560
And another thing, another difference compared to SysML

01:03:09.560 --> 01:03:13.120
from OPM is it incorporates requirements pretty explicitly.

01:03:13.120 --> 01:03:14.400
And that's one of the other areas

01:03:14.400 --> 01:03:15.840
that people are really interested in

01:03:15.840 --> 01:03:18.000
is if you have good modeling of requirements,

01:03:18.000 --> 01:03:20.320
what sort of information can you glean about your system

01:03:20.320 --> 01:03:23.080
that you couldn't otherwise?

01:03:23.080 --> 01:03:24.160
How do I advance this slide?

01:03:27.160 --> 01:03:28.120
Oh, there we go.

01:03:28.120 --> 01:03:29.440
OK.

01:03:29.440 --> 01:03:32.440
So as I said, SysML is composed of diagrams.

01:03:32.440 --> 01:03:34.840
I'll go into in a second what each diagram, what

01:03:34.840 --> 01:03:37.160
all the diagram types are and what their intent is.

01:03:37.160 --> 01:03:39.480
But here's kind of a high-level overview.

01:03:39.480 --> 01:03:41.040
It might be a little bit difficult to read.

01:03:41.040 --> 01:03:42.600
So at the top, you have a system model.

01:03:42.600 --> 01:03:45.360
You have requirements diagrams, behavior, structure,

01:03:45.360 --> 01:03:46.880
and parametrics.

01:03:46.880 --> 01:03:48.160
Within requirements, there's actually

01:03:48.160 --> 01:03:50.280
a specific requirements diagram that's

01:03:50.280 --> 01:03:52.720
supposed to represent the relationship between requirements

01:03:52.720 --> 01:03:53.240
in your system.

01:03:53.240 --> 01:03:55.080
I'll show you an example of that.

01:03:55.080 --> 01:03:58.320
In behavior, there are diagrams that describe

01:03:58.320 --> 01:04:00.000
kind of the activity of your system,

01:04:00.000 --> 01:04:02.560
the sequence of events that may happen.

01:04:02.560 --> 01:04:04.000
There's a state machine diagram.

01:04:04.000 --> 01:04:05.840
If you want to model your system as a states

01:04:05.840 --> 01:04:08.920
and transition between those states, things like that.

01:04:08.920 --> 01:04:11.200
In the structure, there's diagrams

01:04:11.200 --> 01:04:13.240
that go over the decomposition of your system, what

01:04:13.240 --> 01:04:15.880
is your system, and what parts make up your system,

01:04:15.880 --> 01:04:19.720
both the logical decomposition and the physical decomposition.

01:04:19.720 --> 01:04:22.120
And then there's a topology, how are they all connected,

01:04:22.120 --> 01:04:25.000
where the interfaces, where the characteristics of the interfaces,

01:04:25.000 --> 01:04:26.200
things like that.

01:04:26.200 --> 01:04:31.120
And then parametrics, which is kind of adding constraints

01:04:31.120 --> 01:04:34.200
and numbers to all these things, whether they be logical constraints,

01:04:34.200 --> 01:04:36.160
mathematical constraints, things like that.

01:04:36.160 --> 01:04:39.960
Similar to OPM, SysML has no built-in analysis capability,

01:04:40.000 --> 01:04:45.280
so you can't run a model or calculate an equation in SysML.

01:04:45.280 --> 01:04:46.400
You can't really do that.

01:04:46.400 --> 01:04:54.480
But very frequently, the tools that implement SysML that I'll show you

01:04:54.480 --> 01:04:57.240
have that kind of analysis capability built into the tool

01:04:57.240 --> 01:04:58.480
as opposed to the language.

01:04:58.480 --> 01:05:02.880
So you can do things like use a parametric diagram

01:05:02.880 --> 01:05:05.720
with a bunch of equations to create a system of equations

01:05:05.720 --> 01:05:08.360
that you then can solve, whether it be in the tool,

01:05:08.360 --> 01:05:10.440
or you can move it to an external tool like Mathematica

01:05:10.440 --> 01:05:12.720
or something, solve it, and then bring that information back

01:05:12.720 --> 01:05:15.040
into your system.

01:05:15.040 --> 01:05:19.920
You also can do kind of sequence-based computation

01:05:19.920 --> 01:05:23.080
if you have a activity diagram that says, first, you

01:05:23.080 --> 01:05:24.560
have to build this part of your system

01:05:24.560 --> 01:05:25.760
and then this part of your system.

01:05:25.760 --> 01:05:27.760
There's things in sequence, things in parallel.

01:05:27.760 --> 01:05:31.000
You can run simulations like that, where it's all about,

01:05:31.000 --> 01:05:34.160
have you done everything you need to do to get to the next step,

01:05:34.160 --> 01:05:35.840
things in a more logical flow as opposed

01:05:35.840 --> 01:05:37.480
to actually mathematical equations.

01:05:37.480 --> 01:05:39.360
You can do those sorts of computations as well.

01:05:41.800 --> 01:05:44.280
One note is that these diagrams, although they

01:05:44.280 --> 01:05:46.080
are the main way to define your system

01:05:46.080 --> 01:05:50.000
and interface with the model, are not the model themselves.

01:05:50.000 --> 01:05:53.080
So you can create links between diagrams

01:05:53.080 --> 01:05:55.560
if an element shows up in one diagram

01:05:55.560 --> 01:05:58.240
and that element shows up in another diagram.

01:05:58.240 --> 01:05:59.440
That's the same element.

01:05:59.440 --> 01:06:00.800
If you make changes in one diagram,

01:06:00.800 --> 01:06:02.720
that's going to propagate to all your diagrams.

01:06:02.720 --> 01:06:05.000
So there's kind of a database back into this whole,

01:06:05.000 --> 01:06:07.760
into the model that encompasses all the information.

01:06:07.760 --> 01:06:10.320
So instead of having a bunch of isolated block diagrams,

01:06:10.320 --> 01:06:12.760
they're really just views into this model that's

01:06:12.760 --> 01:06:14.080
hidden in a back-end database.

01:06:19.840 --> 01:06:23.440
OK, so I'll talk a little bit about the applications of ZISMO.

01:06:23.440 --> 01:06:24.800
First is requirements engineering.

01:06:24.800 --> 01:06:26.560
As I said, when you can explicitly model

01:06:26.560 --> 01:06:28.600
requirements in the relationship between requirements

01:06:28.600 --> 01:06:31.200
in your system, you can do a lot more.

01:06:31.200 --> 01:06:32.840
The way that it's typically done nowadays

01:06:32.840 --> 01:06:34.880
is with tons of documents.

01:06:34.880 --> 01:06:36.680
I'm not sure if you've ever actually developed a system,

01:06:36.680 --> 01:06:39.200
but there's an ungodly amount of documents.

01:06:39.200 --> 01:06:41.200
I've experienced that firsthand.

01:06:41.200 --> 01:06:42.480
It's a real pain.

01:06:42.480 --> 01:06:44.600
There are tools like DOORS that will enable you to link

01:06:44.600 --> 01:06:46.200
requirements to other requirements and things

01:06:46.200 --> 01:06:48.440
like that that help you manage your requirements.

01:06:48.440 --> 01:06:50.280
But what if you had a really explicit tie

01:06:50.280 --> 01:06:52.040
between your requirements and your system?

01:06:52.040 --> 01:06:53.440
You can actually represent in ZISMO,

01:06:53.440 --> 01:06:55.120
and I'll show you a little bit about this.

01:06:55.120 --> 01:06:57.840
You can represent in ZISMO a textual requirement.

01:06:57.840 --> 01:07:00.560
The mass of your system must be less than five kilograms

01:07:00.560 --> 01:07:01.560
or something like that.

01:07:01.560 --> 01:07:03.840
You can tie that requirement directly to the mass property

01:07:03.840 --> 01:07:04.800
of your system.

01:07:04.800 --> 01:07:08.280
You can kind of envision you can start building constraints.

01:07:08.280 --> 01:07:10.120
Requirements aren't just textual statements.

01:07:10.120 --> 01:07:12.120
They're actually constraints upon properties of your system.

01:07:12.120 --> 01:07:15.400
Those are the types of things you can start to do with ZISMO.

01:07:15.400 --> 01:07:16.520
You have a question?

01:07:16.520 --> 01:07:28.880
Yeah, so that isn't something that's built into the language,

01:07:28.880 --> 01:07:31.600
but that is something you can do with basically there's

01:07:31.600 --> 01:07:35.280
a whole API, and you can interface with the model.

01:07:35.280 --> 01:07:37.160
I'll show you this, actually, in my demo.

01:07:37.160 --> 01:07:39.560
But you can build in rules and constraints that say,

01:07:39.560 --> 01:07:42.120
check, for example, that all my requirements, at least,

01:07:42.120 --> 01:07:43.840
have they been defined are satisfied.

01:07:43.840 --> 01:07:45.240
You can run that check, and it will tell you

01:07:45.240 --> 01:07:46.520
have they been satisfied or not.

01:07:46.520 --> 01:07:47.880
And that's something that's really powerful

01:07:47.880 --> 01:07:51.240
that you can't really do with existing kind of techniques.

01:07:51.240 --> 01:07:52.240
Yeah.

01:07:52.240 --> 01:07:53.480
Thank you.

01:07:53.480 --> 01:07:56.600
And can you also, let's say, for example, requirement

01:07:56.600 --> 01:07:59.200
changes, like the mass of your system

01:07:59.200 --> 01:08:01.480
has to be this much as opposed to this much,

01:08:01.480 --> 01:08:04.560
then would it go through and check until you have to now look

01:08:04.560 --> 01:08:08.120
at this, this, and this, and then that effect?

01:08:08.120 --> 01:08:10.280
So you're getting down in the weeds.

01:08:10.280 --> 01:08:13.520
That's something that'd be awesome if you could do, right?

01:08:13.520 --> 01:08:15.040
That really, again, that's not something

01:08:15.040 --> 01:08:17.200
that SysML enables you to do natively,

01:08:17.200 --> 01:08:19.440
but it gives you the language and the syntax

01:08:19.440 --> 01:08:21.720
to be able to write queries that give you

01:08:21.720 --> 01:08:22.520
that type of information.

01:08:22.520 --> 01:08:24.720
That's kind of where the cutting edge is right now is,

01:08:24.720 --> 01:08:25.560
can we do that?

01:08:25.560 --> 01:08:27.560
Can we get that type of information from a system

01:08:27.560 --> 01:08:28.200
and model?

01:08:28.200 --> 01:08:30.600
That's something I'm really interested in for my PhD thesis.

01:08:30.640 --> 01:08:33.000
So yeah, that's something that I think is possible

01:08:33.000 --> 01:08:34.920
and would be really great to have in the development

01:08:34.920 --> 01:08:35.760
process of a system.

01:08:38.800 --> 01:08:40.800
So the next bullet here is on system description.

01:08:40.800 --> 01:08:43.000
So actually, one of the fundamental questions

01:08:43.000 --> 01:08:46.080
is, how do you describe a domain-specific system

01:08:46.080 --> 01:08:47.360
within SysML?

01:08:47.360 --> 01:08:50.000
I'll show you that SysML has a pretty strong notion

01:08:50.000 --> 01:08:51.920
of inheritance in classes and things like that.

01:08:51.920 --> 01:08:53.560
It's obviously oriented.

01:08:53.560 --> 01:08:56.680
And so one of the questions is, I'm in the space system,

01:08:56.680 --> 01:08:59.320
so how do you describe a spacecraft in SysML?

01:08:59.320 --> 01:09:02.360
SysML is very general, but how do you actually represent,

01:09:02.360 --> 01:09:04.880
for example, a C and D H system in SysML?

01:09:04.880 --> 01:09:09.680
What are the types of attributes that are typically found?

01:09:09.680 --> 01:09:10.920
How do you represent that?

01:09:10.920 --> 01:09:12.880
How does it interface with other parts of your system?

01:09:12.880 --> 01:09:15.240
Those type of questions, that's another active area

01:09:15.240 --> 01:09:17.440
of research, domain-specific modeling.

01:09:17.440 --> 01:09:19.920
And then finally, as I said, integration

01:09:19.920 --> 01:09:21.200
with external analysis tools.

01:09:21.200 --> 01:09:23.200
So there's quite a lot of papers in the literature

01:09:23.200 --> 01:09:28.560
about going from a SysML model to MATLAB, to SDK,

01:09:28.560 --> 01:09:31.200
to thermal desktop.

01:09:31.200 --> 01:09:33.960
External modeling tools, taking that information out

01:09:33.960 --> 01:09:36.960
of the model, doing an analysis, putting it back in the model.

01:09:36.960 --> 01:09:39.080
And actually, I think Nara's going

01:09:39.080 --> 01:09:42.840
to talk about Simscape, which is a kind of analysis tool,

01:09:42.840 --> 01:09:43.960
external analysis tool.

01:09:43.960 --> 01:09:45.720
And there's actually been papers written on how do you take

01:09:45.720 --> 01:09:48.600
SysML information from a SysML model, pull it into Simscape,

01:09:48.600 --> 01:09:50.280
process it, and put it back in the model.

01:09:53.920 --> 01:09:56.680
OK, so let's talk about the diagrams.

01:09:56.720 --> 01:09:59.280
There are nine types of diagrams in SysML.

01:09:59.280 --> 01:10:01.280
And I'll try and just give you a brief explanation

01:10:01.280 --> 01:10:01.840
of what they do.

01:10:01.840 --> 01:10:03.360
I won't go into the syntax for all of them,

01:10:03.360 --> 01:10:05.200
because there's quite a bit of detail in the syntax.

01:10:05.200 --> 01:10:07.960
But I'll show you some examples of a couple of them.

01:10:07.960 --> 01:10:09.120
So I'll go from left to right.

01:10:09.120 --> 01:10:12.400
So there's two main classes, behavior and structure,

01:10:12.400 --> 01:10:14.040
similar to OPM.

01:10:14.040 --> 01:10:17.120
In the behavior diagram, you have a behavior diagram

01:10:17.120 --> 01:10:17.600
category.

01:10:17.600 --> 01:10:19.920
You have activity diagrams, which are basically

01:10:19.920 --> 01:10:21.520
represent flows of activities.

01:10:21.520 --> 01:10:24.840
So you do this, then you do this, then you do this.

01:10:24.840 --> 01:10:26.880
Those can be tied to system elements.

01:10:26.880 --> 01:10:29.840
If this system element has this sort of function or property

01:10:29.840 --> 01:10:32.680
or performs this operation on another part of the system,

01:10:32.680 --> 01:10:35.080
you can represent that link as well.

01:10:35.080 --> 01:10:39.760
There's a sequence diagram, which is more about logical

01:10:39.760 --> 01:10:40.200
ordering.

01:10:40.200 --> 01:10:44.080
So if you have, for example, a multi-threaded software system,

01:10:44.080 --> 01:10:47.360
and you have different threads that may need different other

01:10:47.360 --> 01:10:49.880
threads to communicate with them or finish their computation

01:10:49.880 --> 01:10:51.800
before that thread can execute things like that,

01:10:51.800 --> 01:10:54.480
you can do that interfacing between

01:10:54.520 --> 01:10:59.720
different threads of activities in a sequence diagram.

01:10:59.720 --> 01:11:03.440
This is one of the diagram types that was inherited directly

01:11:03.440 --> 01:11:03.920
from UML.

01:11:03.920 --> 01:11:07.720
So it's a very strong software element to that diagram.

01:11:12.040 --> 01:11:13.200
There's a state machine diagram.

01:11:13.200 --> 01:11:15.040
So obviously, state machines are very powerful.

01:11:15.040 --> 01:11:16.440
If your system has various states,

01:11:16.440 --> 01:11:18.040
if things in your system have various states,

01:11:18.040 --> 01:11:20.240
you can represent that in a state machine diagram

01:11:20.240 --> 01:11:22.880
and then talk about what are the criteria for transitioning

01:11:22.880 --> 01:11:23.520
between states.

01:11:23.520 --> 01:11:26.560
What would trigger or cause a transition between states?

01:11:26.560 --> 01:11:28.760
What are guards that must be met before you

01:11:28.760 --> 01:11:30.240
can transition states, things like that,

01:11:30.240 --> 01:11:32.880
that we'd represent in a state machine diagram.

01:11:32.880 --> 01:11:36.000
These type of diagrams are very powerful for describing things

01:11:36.000 --> 01:11:38.280
like concept of operations.

01:11:38.280 --> 01:11:39.920
So there has been some work.

01:11:39.920 --> 01:11:42.400
I did an internship at JPL a couple of summers ago,

01:11:42.400 --> 01:11:44.720
and they were trying to build up this capability

01:11:44.720 --> 01:11:47.000
to model a concept of operations for a spacecraft.

01:11:47.000 --> 01:11:50.160
So what are all the power modes of everything?

01:11:50.160 --> 01:11:51.120
What are the time?

01:11:51.120 --> 01:11:53.040
It spends this amount of time in this power mode,

01:11:53.040 --> 01:11:55.640
and it transitions here over, for example,

01:11:55.640 --> 01:11:56.960
like a given orbit of a spacecraft.

01:11:56.960 --> 01:11:59.160
That's the thing that you can do with this set

01:11:59.160 --> 01:12:01.200
of behavior diagrams.

01:12:01.200 --> 01:12:02.360
And then use case analysis.

01:12:02.360 --> 01:12:04.800
Again, it's mostly focused on early concept development,

01:12:04.800 --> 01:12:07.120
stakeholders, how do they interface with the system?

01:12:07.120 --> 01:12:08.800
Where do they derive value?

01:12:08.800 --> 01:12:11.640
How does the user interact with the system, things like that?

01:12:11.640 --> 01:12:14.640
That's what you put in the use case diagram.

01:12:14.640 --> 01:12:18.000
Going over to structure, the block definition diagram

01:12:18.000 --> 01:12:21.000
is where you define the structure of your system.

01:12:21.040 --> 01:12:23.280
So the logical or physical decomposition,

01:12:23.280 --> 01:12:24.680
I'll show you an example of this.

01:12:24.680 --> 01:12:26.200
So every system is a spacecraft.

01:12:26.200 --> 01:12:28.440
It has various subsystems.

01:12:28.440 --> 01:12:29.640
If you want to decompose it logically,

01:12:29.640 --> 01:12:32.080
it has a thermal subsystem, a structure subsystem,

01:12:32.080 --> 01:12:34.200
ADCS subsystem, things like that.

01:12:34.200 --> 01:12:35.520
You can also decompose it physically.

01:12:35.520 --> 01:12:37.640
So your spacecraft has solar rays.

01:12:37.640 --> 01:12:38.640
It has instruments.

01:12:38.640 --> 01:12:40.560
It has thrusters, things like that.

01:12:40.560 --> 01:12:41.960
You can represent those types of things

01:12:41.960 --> 01:12:43.600
in a block definition diagram.

01:12:43.600 --> 01:12:45.000
And then internal block diagram is

01:12:45.000 --> 01:12:46.840
where you describe the ties with the interfaces

01:12:46.840 --> 01:12:48.720
between all the components of your system.

01:12:48.720 --> 01:12:50.360
And these can be at varying different levels

01:12:50.360 --> 01:12:53.360
of abstraction, as I'll show you.

01:12:53.360 --> 01:12:55.720
Parametric diagram is kind of a sub-diagram type

01:12:55.720 --> 01:12:57.080
of the internal block diagram.

01:12:57.080 --> 01:12:59.640
So you can, again, put constraints, mathematical, logical,

01:12:59.640 --> 01:13:01.280
things like that on your interfaces

01:13:01.280 --> 01:13:04.680
and begin to build up the infrastructure for doing

01:13:04.680 --> 01:13:06.480
computation in the model.

01:13:06.480 --> 01:13:10.160
And then a packaging diagram is not terribly important.

01:13:10.160 --> 01:13:12.280
It's really focused on the organization of your model,

01:13:12.280 --> 01:13:13.240
how do you scope things.

01:13:13.240 --> 01:13:15.800
It's kind of a modeling diagram, as opposed

01:13:15.800 --> 01:13:17.600
to a representation of your system.

01:13:17.600 --> 01:13:19.560
Then last of all is a requirements diagram up top.

01:13:19.560 --> 01:13:21.160
So again, I'll show you a good example of this,

01:13:21.160 --> 01:13:23.160
but that's where you represent how your requirements are

01:13:23.160 --> 01:13:25.160
related to your system.

01:13:25.160 --> 01:13:27.000
And then you can see here what's been modified

01:13:27.000 --> 01:13:30.000
and what's been taken from UML and the new diagram types

01:13:30.000 --> 01:13:32.000
of requirement in parametric.

01:13:32.000 --> 01:13:33.520
There were a couple of diagram types

01:13:33.520 --> 01:13:36.520
that were eliminated from UML that were pretty software

01:13:36.520 --> 01:13:37.560
specific.

01:13:37.560 --> 01:13:39.680
I think there is one called the deployment diagram,

01:13:39.680 --> 01:13:43.120
like how has your software been deployed across various servers

01:13:43.120 --> 01:13:44.200
or users, things like that.

01:13:44.200 --> 01:13:47.200
That's not really, that's a pretty software specific thing.

01:13:47.200 --> 01:13:49.040
So in a general system, you might not

01:13:49.080 --> 01:13:53.280
care about that all that much, so that diagram was removed.

01:13:53.280 --> 01:13:56.520
So let me quickly go over some of the syntax.

01:13:56.520 --> 01:13:59.280
So this is an interface block diagram, an IBD.

01:13:59.280 --> 01:14:01.080
This is the type of diagram that I find

01:14:01.080 --> 01:14:06.160
is really interesting, representing these interfaces.

01:14:06.160 --> 01:14:08.160
So here's the system engineering ontology

01:14:08.160 --> 01:14:09.080
we typically talk about.

01:14:09.080 --> 01:14:12.200
So these are, this is basically a model of an avionics board.

01:14:12.200 --> 01:14:14.880
So you have things like voltage converters.

01:14:14.880 --> 01:14:17.600
You have memory, the volatile, non-volatile.

01:14:17.600 --> 01:14:21.440
We have a FPGA, which is our main computational unit.

01:14:21.440 --> 01:14:23.760
We talk about these as being parts of a system

01:14:23.760 --> 01:14:25.400
in terms of a system engineering ontology.

01:14:25.400 --> 01:14:28.920
Then these are these interfaces or these lines right here.

01:14:28.920 --> 01:14:30.760
So in SysML, the way we talk about it

01:14:30.760 --> 01:14:35.520
is these are part properties of the system.

01:14:35.520 --> 01:14:38.280
It's kind of like an instantiation type of thing.

01:14:38.280 --> 01:14:40.240
What we're saying is all of these parts

01:14:40.240 --> 01:14:42.120
can represent independent of each other.

01:14:42.120 --> 01:14:44.840
And then you define a property of that part

01:14:44.840 --> 01:14:47.120
as being part of a different part,

01:14:47.120 --> 01:14:48.840
if that makes any sense at all.

01:14:48.840 --> 01:14:50.560
So for example, this is a board, right?

01:14:50.560 --> 01:14:53.120
This main electronics board is this whole block.

01:14:53.120 --> 01:14:55.560
And then it has sub-blocks within this block,

01:14:55.560 --> 01:14:57.880
which represent the sub-parts that make up the board.

01:14:57.880 --> 01:15:02.920
These are called part properties of this overall block.

01:15:02.920 --> 01:15:05.120
We have these green little boxes, which are called ports.

01:15:05.120 --> 01:15:07.840
And again, that's to support this kind of system

01:15:07.840 --> 01:15:08.760
independent modeling.

01:15:08.760 --> 01:15:11.040
So you can model like a voltage converter,

01:15:11.040 --> 01:15:12.840
independent of any type of system.

01:15:12.840 --> 01:15:15.080
It has maybe an input voltage and output voltage.

01:15:15.080 --> 01:15:17.400
You can define what ranges those are, things like that.

01:15:17.400 --> 01:15:20.000
And you can model those interfaces using ports.

01:15:20.000 --> 01:15:23.240
And then these connectors, which are called connectors

01:15:23.240 --> 01:15:25.400
in SysML, which represent the interfaces,

01:15:25.400 --> 01:15:28.520
represent how each part is tied into the larger system.

01:15:28.520 --> 01:15:30.360
And you could, for example, check that you

01:15:30.360 --> 01:15:31.840
don't have any empty ports.

01:15:31.840 --> 01:15:34.360
If a part needs an input voltage,

01:15:34.360 --> 01:15:36.360
you could run a script that checks

01:15:36.360 --> 01:15:39.800
that all the parts have all their ports satisfied.

01:15:39.800 --> 01:15:43.920
That's something you can do with SysML.

01:15:43.920 --> 01:15:45.480
OK, so before I get into the case study,

01:15:45.480 --> 01:15:47.920
I want to talk a little bit about what you're going to see.

01:15:47.920 --> 01:15:49.400
As I said, I work on something called

01:15:49.400 --> 01:15:52.240
REXIS, which is the Regolith X-ray Imaging Spectrometer.

01:15:52.240 --> 01:15:53.960
It's an X-ray spectrometer that's

01:15:53.960 --> 01:15:56.360
flying on NASA's OSIRIS-REx asteroid sample return

01:15:56.360 --> 01:15:57.360
mission.

01:15:57.360 --> 01:16:00.680
I've been working on it since 2011, when I was a senior here,

01:16:00.680 --> 01:16:03.560
all throughout my master's and then now for my PhD.

01:16:03.560 --> 01:16:05.480
Basically, we're going to measure X-rays that

01:16:05.480 --> 01:16:07.320
are fluoresced from the asteroid surface

01:16:07.320 --> 01:16:09.840
in order to tell what the elemental composition

01:16:09.840 --> 01:16:10.640
of the asteroid is.

01:16:10.640 --> 01:16:12.640
So that's our main science goal.

01:16:12.640 --> 01:16:16.600
And that will basically enable us to categorize

01:16:16.600 --> 01:16:18.800
where the asteroid is within the different meteorite types

01:16:18.800 --> 01:16:20.600
that have been defined on the ground based

01:16:20.600 --> 01:16:23.240
upon existing meteorite samples.

01:16:23.240 --> 01:16:25.720
So what I did from a master's thesis

01:16:25.720 --> 01:16:28.400
was model the design history of REXIS.

01:16:28.400 --> 01:16:32.040
So how has our design evolved from the very beginning, where

01:16:32.040 --> 01:16:35.440
it was very open-ended, very abstract,

01:16:35.440 --> 01:16:39.000
and you'll see this, to the current design, which

01:16:39.000 --> 01:16:44.400
current in this case was CDR, which was over a year ago now.

01:16:44.400 --> 01:16:45.800
Right now, the current state of REXIS

01:16:45.800 --> 01:16:48.040
is we're almost ready to mount to the spacecraft.

01:16:48.040 --> 01:16:50.640
So it's very exciting.

01:16:50.640 --> 01:16:53.080
Just to give you an idea of a timeline,

01:16:53.080 --> 01:16:54.760
this is something I'm sure Ollie will

01:16:54.760 --> 01:16:56.440
talk about in this course, is the flow

01:16:56.440 --> 01:16:58.080
through the system development life cycle.

01:16:58.080 --> 01:17:01.360
So we have system requirements review back in January of 2012.

01:17:01.400 --> 01:17:04.400
System, I think it's definition review.

01:17:04.400 --> 01:17:08.160
April 2012 preliminary design review, January of 2013,

01:17:08.160 --> 01:17:11.040
and then critical design review, February of 2014.

01:17:11.040 --> 01:17:14.000
So I created models at each of these design points in SysML

01:17:14.000 --> 01:17:16.440
and looked at what are the lessons we could have learned.

01:17:16.440 --> 01:17:18.040
We didn't use SysML in REXIS.

01:17:18.040 --> 01:17:19.600
I was kind of looking back historically,

01:17:19.600 --> 01:17:20.960
what if we had used it?

01:17:20.960 --> 01:17:25.800
Could we have designed our system better in any sort of way?

01:17:25.800 --> 01:17:27.920
So here is kind of a CAD representation

01:17:27.920 --> 01:17:28.920
of how our design evolved.

01:17:28.920 --> 01:17:30.640
And I think you can kind of get the idea.

01:17:30.640 --> 01:17:34.280
Back at SRR, we didn't really know what they would look like.

01:17:34.280 --> 01:17:36.000
We didn't know what the interfaces would be.

01:17:36.000 --> 01:17:38.320
We didn't know what all the parts would be.

01:17:38.320 --> 01:17:40.280
We had a little more development for SDR.

01:17:40.280 --> 01:17:42.200
You can see there's more arrows.

01:17:42.200 --> 01:17:44.200
The CAD is a little bit more detailed.

01:17:44.200 --> 01:17:46.880
For PDR, we had even more detail.

01:17:46.880 --> 01:17:48.640
This was actually like a buildable design.

01:17:48.640 --> 01:17:50.800
This turned out to not even be buildable.

01:17:50.800 --> 01:17:54.600
And then we had more evolution between PDR and CDR

01:17:54.600 --> 01:17:56.680
to get to pretty much where the design is.

01:17:56.680 --> 01:17:59.160
There's actually been some evolution after this as well.

01:17:59.760 --> 01:18:02.400
Sometimes happens with a new system.

01:18:02.400 --> 01:18:04.560
But you can see just graphically kind of the increase

01:18:04.560 --> 01:18:06.640
in level of detail and level of fidelity

01:18:06.640 --> 01:18:09.640
of the state of our system throughout its development cycle.

01:18:09.640 --> 01:18:12.760
And I'll show you that and how that looks in the system model

01:18:12.760 --> 01:18:14.840
as well.

01:18:14.840 --> 01:18:17.000
So one of the things you can do if you have a system model,

01:18:17.000 --> 01:18:18.840
as I talked about, you can run queries on it

01:18:18.840 --> 01:18:21.160
and pull out information that's very difficult or impossible

01:18:21.160 --> 01:18:23.320
to get with our current development practices.

01:18:23.320 --> 01:18:26.520
So this is just looking at the different sub-assemblies

01:18:26.520 --> 01:18:27.320
within REXIS.

01:18:27.320 --> 01:18:29.600
What are the number of parts in each of the sub-assemblies?

01:18:29.600 --> 01:18:31.920
So you can see the general trend is up for all of them

01:18:31.920 --> 01:18:33.360
as you would expect.

01:18:33.360 --> 01:18:35.520
Some jump up very high.

01:18:35.520 --> 01:18:37.760
Some kind of stay basically where they were.

01:18:37.760 --> 01:18:39.160
But in general, they all increase.

01:18:39.160 --> 01:18:40.560
And this is something you might be

01:18:40.560 --> 01:18:42.960
able to do with looking at a parts list or something

01:18:42.960 --> 01:18:44.640
like that with current methodologies.

01:18:44.640 --> 01:18:46.480
But it'd be very hard to get this information, which

01:18:46.480 --> 01:18:48.440
is the number of ports per assembly.

01:18:48.440 --> 01:18:49.840
So each interface has two ports.

01:18:49.840 --> 01:18:51.400
So these numbers divided by two basically

01:18:51.400 --> 01:18:53.160
equal the number of interfaces that we have

01:18:53.160 --> 01:18:54.320
in each sub-assembly.

01:18:54.320 --> 01:18:56.880
You can see, again, there's a general trend of increasing.

01:18:56.920 --> 01:18:59.760
Increasing number of ports as you go through the life cycle.

01:18:59.760 --> 01:19:02.040
So this is a piece of information

01:19:02.040 --> 01:19:04.320
you might want to use if you want to manage the complexity

01:19:04.320 --> 01:19:04.800
of your system.

01:19:04.800 --> 01:19:07.040
And you say, this sub-assembly is getting

01:19:07.040 --> 01:19:09.240
way too many interfaces, way too many parts.

01:19:09.240 --> 01:19:10.120
It's way too complex.

01:19:10.120 --> 01:19:11.920
We need to think about how we've logically

01:19:11.920 --> 01:19:14.160
arranged our system and maybe how can we rearrange it

01:19:14.160 --> 01:19:16.840
to make it more understandable and easier to work with.

01:19:16.840 --> 01:19:18.720
And then you can divide the two.

01:19:18.720 --> 01:19:20.440
And you end up looking at how many

01:19:20.440 --> 01:19:24.040
this is ports per part in each sub-assembly at each

01:19:24.040 --> 01:19:25.360
of the design reviews.

01:19:25.360 --> 01:19:27.760
And you can see trends here, too, which are interesting.

01:19:27.760 --> 01:19:29.240
So you can see in the beginning, we

01:19:29.240 --> 01:19:30.160
didn't really know what we were doing.

01:19:30.160 --> 01:19:32.400
Some of these had a lot of ports per part.

01:19:32.400 --> 01:19:33.880
Some of these had very few.

01:19:33.880 --> 01:19:36.640
They all ended up stabilizing kind of between the three

01:19:36.640 --> 01:19:38.840
and five ports per part range.

01:19:38.840 --> 01:19:40.840
And then you can look at the literature and say, well,

01:19:40.840 --> 01:19:44.120
typically systems tend to be between five and six

01:19:44.120 --> 01:19:45.240
ports per part.

01:19:45.240 --> 01:19:46.200
So what does that mean?

01:19:46.200 --> 01:19:48.440
Does that mean that our system, that I didn't model it

01:19:48.440 --> 01:19:48.920
correctly?

01:19:48.920 --> 01:19:49.680
That's one possibility.

01:19:49.680 --> 01:19:52.880
It didn't model to the lowest level of fidelity possible.

01:19:52.920 --> 01:19:55.640
Does it mean that our system is too simple?

01:19:55.640 --> 01:19:57.280
Does it mean that we're missing something

01:19:57.280 --> 01:19:58.640
that we haven't thought about?

01:19:58.640 --> 01:20:00.760
Does it mean that our system, which

01:20:00.760 --> 01:20:03.280
was intended to be simple and cheap and implementable by

01:20:03.280 --> 01:20:05.800
students, is actually achieving that goal because it's

01:20:05.800 --> 01:20:07.600
beneath what you would typically expect?

01:20:07.600 --> 01:20:09.400
Those are the type of questions you can ask with this data.

01:20:09.400 --> 01:20:11.440
But this data is not easy to get with the current

01:20:11.440 --> 01:20:12.720
methodologies.

01:20:12.720 --> 01:20:15.480
So this kind of very simple query you can do gives you

01:20:15.480 --> 01:20:19.400
power on managing complexity in your system.

01:20:19.400 --> 01:20:24.600
So let me now transition quickly to the demo.

01:20:24.600 --> 01:20:25.360
Let's see.

01:20:45.680 --> 01:20:46.800
There's no sound.

01:20:46.800 --> 01:20:51.080
I know, but I need to sync it up and I need sound to do that.

01:20:51.080 --> 01:20:54.040
So you can close out of this.

01:20:54.040 --> 01:20:56.200
And then let me see.

01:21:00.720 --> 01:21:03.880
So while Mark is setting up for the demo, are there any

01:21:03.880 --> 01:21:06.440
questions about SysML so far?

01:21:06.440 --> 01:21:07.960
Any observations you guys have?

01:21:11.440 --> 01:21:15.160
Maybe at EPFL, you see the similarities and differences

01:21:15.160 --> 01:21:18.840
between OPM and SysML.

01:21:18.840 --> 01:21:22.440
What's the biggest difference between the two?

01:21:22.440 --> 01:21:24.200
There's two really important differences.

01:21:27.680 --> 01:21:28.280
No questions?

01:21:28.280 --> 01:21:29.960
Yes?

01:21:29.960 --> 01:21:31.000
Hang on.

01:21:31.000 --> 01:21:34.440
Is there anybody at EPFL who wants to comment on this?

01:21:40.880 --> 01:21:42.840
No, there's no comment from EPFL.

01:21:42.840 --> 01:21:43.640
OK, good.

01:21:43.640 --> 01:21:45.400
That's fine.

01:21:45.400 --> 01:21:46.760
That's fine.

01:21:46.760 --> 01:21:48.720
Mark, are you set up?

01:21:48.720 --> 01:21:49.220
Almost.

01:21:54.320 --> 01:21:58.920
What I would say is, first of all, OPM has only one type of

01:21:58.920 --> 01:21:59.920
diagram, right?

01:21:59.920 --> 01:22:03.520
And then you go really deep, sort of a deep hierarchy.

01:22:03.520 --> 01:22:06.840
SysML has nine different types of diagrams split between

01:22:06.840 --> 01:22:10.120
behavioral and structural, but that's one difference.

01:22:10.120 --> 01:22:13.040
And then the other is that SysML is fundamentally object

01:22:13.040 --> 01:22:16.560
oriented, because it comes from object oriented thinking and

01:22:16.560 --> 01:22:20.680
software, whereas OPM has objects and processes at the

01:22:20.680 --> 01:22:22.200
same level.

01:22:22.200 --> 01:22:26.000
Those are two of the most important differences.

01:22:26.000 --> 01:22:27.600
OK?

01:22:27.600 --> 01:22:28.520
All right.

01:22:28.520 --> 01:22:30.480
So what I'm showing, can everyone see the screen?

01:22:30.480 --> 01:22:33.200
Just let me know if you can't see the screen.

01:22:33.200 --> 01:22:36.560
What I'm showing you right now is a tool called Magic Draw.

01:22:36.560 --> 01:22:38.680
There are basically a variety of tools provided by

01:22:38.680 --> 01:22:41.560
commercial vendors that enable you to build and work with

01:22:41.560 --> 01:22:42.320
SysML models.

01:22:42.320 --> 01:22:45.120
So SysML is a language, and then it's implemented in tools.

01:22:45.120 --> 01:22:48.520
And this just happens to be one that's fairly widely

01:22:48.520 --> 01:22:49.880
utilized.

01:22:49.880 --> 01:22:51.560
Unfortunately, it's quite expensive.

01:22:51.560 --> 01:22:53.480
But anyway.

01:22:53.480 --> 01:22:55.240
So what I'm showing you right now, and this is going to be a

01:22:55.240 --> 01:22:57.840
little bit difficult, because as you can see, you need a

01:22:57.840 --> 01:22:59.600
big screen.

01:22:59.600 --> 01:23:01.520
What I'm showing you right now is a requirements diagram.

01:23:01.520 --> 01:23:04.520
So you can see that right here, requirements diagram.

01:23:04.520 --> 01:23:09.080
And each of these blocks, as you can see by the tag here, is

01:23:09.080 --> 01:23:10.080
a requirement.

01:23:10.080 --> 01:23:13.000
So this is one of our operating criteria.

01:23:13.000 --> 01:23:14.560
So while operating, the temperature of all our

01:23:14.560 --> 01:23:17.400
components shall be maintained within operability limits.

01:23:17.400 --> 01:23:19.240
Straightforward requirement.

01:23:19.240 --> 01:23:22.440
And you can create these satisfy relationships between

01:23:22.440 --> 01:23:25.000
that requirement and the components in the system that

01:23:25.000 --> 01:23:27.160
must satisfy that requirement.

01:23:27.160 --> 01:23:30.280
So right now, this is being done at SRR, as you can see up

01:23:30.280 --> 01:23:30.840
here.

01:23:30.840 --> 01:23:33.960
So this is very early in the design.

01:23:33.960 --> 01:23:36.600
So we don't have it broken down fully to all the

01:23:36.600 --> 01:23:37.040
components.

01:23:37.040 --> 01:23:39.160
But here's our main electronics board.

01:23:39.160 --> 01:23:40.880
It has to satisfy that requirement.

01:23:40.880 --> 01:23:41.920
Here's our radiation cover.

01:23:41.920 --> 01:23:43.360
It has to satisfy that requirement.

01:23:43.360 --> 01:23:45.680
So you can tie these two things, the requirement, and the

01:23:45.680 --> 01:23:47.840
part of the system that must satisfy the requirement.

01:23:47.840 --> 01:23:50.120
And here I've tied it to parts.

01:23:50.120 --> 01:23:52.480
So these are called blocks, which are the fundamental

01:23:52.480 --> 01:23:54.760
unit in SysMLs, is a block.

01:23:54.760 --> 01:23:56.160
So these represent parts of our system.

01:23:56.160 --> 01:23:57.720
But you could tie it to a property of that

01:23:57.720 --> 01:23:59.280
part if you wanted to.

01:23:59.280 --> 01:24:00.880
So then you get into the situation I talked about

01:24:00.880 --> 01:24:04.080
earlier, where you have the requirement is on the mass of

01:24:04.080 --> 01:24:05.280
must be less than this.

01:24:05.280 --> 01:24:07.200
You can tie it to the mass of the system itself.

01:24:07.200 --> 01:24:08.960
As opposed to the system, you can tie it to the actual

01:24:08.960 --> 01:24:12.760
property, which is very useful.

01:24:12.760 --> 01:24:19.760
So let me quickly show you one of the cool things.

01:24:19.760 --> 01:24:22.760
If I delete these requirements, you can see there's no

01:24:22.760 --> 01:24:23.160
requirements.

01:24:23.160 --> 01:24:25.800
I'm not actually deleting them from the system itself.

01:24:25.800 --> 01:24:28.600
But I'm just doing as I'm removing it from the diagram.

01:24:28.600 --> 01:24:37.120
But if you wanted to, you should be able to look at

01:24:37.120 --> 01:24:39.200
related elements of the different blocks.

01:24:39.200 --> 01:24:40.080
So I just clicked on a block.

01:24:40.080 --> 01:24:46.760
And I can choose to show all the things that are satisfied,

01:24:46.760 --> 01:24:48.760
the requirements of that component of the system

01:24:48.760 --> 01:24:53.040
satisfies, and these requirements pop up.

01:24:53.040 --> 01:24:56.800
So this is showing how the diagrams themselves aren't

01:24:56.800 --> 01:24:57.120
the model.

01:24:57.120 --> 01:24:59.040
There's actually back into the model.

01:24:59.040 --> 01:25:01.760
And you can kind of work in the diagram and show or hide

01:25:01.760 --> 01:25:02.880
things however you want.

01:25:02.880 --> 01:25:06.960
But the information is actually kept behind the diagram.

01:25:06.960 --> 01:25:09.080
So to speak.

01:25:09.080 --> 01:25:11.840
So my research looked into topology.

01:25:11.840 --> 01:25:15.280
So let me just show you a little bit about what I did.

01:25:15.280 --> 01:25:17.720
So this is a block definition diagram, again, defining all

01:25:17.720 --> 01:25:18.680
the parts of your system.

01:25:18.680 --> 01:25:21.840
And I just want to give you kind of a high-level idea of

01:25:21.840 --> 01:25:24.880
the type of things that we saw.

01:25:24.880 --> 01:25:32.080
So it's big, first of all, very big.

01:25:32.080 --> 01:25:33.920
These are all the parts of the system.

01:25:33.920 --> 01:25:36.080
So we start hide like the mission context and the

01:25:36.080 --> 01:25:38.480
mission context contain things like the environment, the

01:25:38.480 --> 01:25:40.440
spacecraft, and then Rexus.

01:25:40.440 --> 01:25:41.640
And then you can break down Rexus.

01:25:41.640 --> 01:25:43.840
And we have various sub-assemblies broken down

01:25:43.840 --> 01:25:44.680
into parts.

01:25:44.680 --> 01:25:47.000
And that's how you get this tree structure.

01:25:47.000 --> 01:25:50.440
And then this tree structure can be tied together.

01:25:50.440 --> 01:25:52.360
I could zoom in, but it's big.

01:25:52.360 --> 01:25:55.360
Again, so these are all the parts of our system.

01:25:55.360 --> 01:25:58.240
Let me give you an example.

01:25:58.240 --> 01:26:00.840
So we have a couple of boards that we call our

01:26:00.840 --> 01:26:02.200
detector electronics.

01:26:02.200 --> 01:26:05.440
And those detector electronics have various ports.

01:26:05.440 --> 01:26:07.680
One thing they have to do, they have this port here and

01:26:07.680 --> 01:26:10.840
this interface here, which connects to RCCDs.

01:26:10.840 --> 01:26:14.040
So this is showing how you can build interfaces in

01:26:14.040 --> 01:26:14.840
system also here.

01:26:14.840 --> 01:26:17.200
The green boxes, again, are the ports, the lines of the

01:26:17.200 --> 01:26:19.680
connectors, and they're defining all the interfaces.

01:26:19.680 --> 01:26:23.680
And you can see, at a high level, how complicated things

01:26:23.680 --> 01:26:24.920
get very quickly.

01:26:24.920 --> 01:26:27.360
This is the earliest, most abstract version of our

01:26:27.360 --> 01:26:30.920
design, and it already has a lot of complication.

01:26:30.920 --> 01:26:34.480
One thing you can do, I talked about running scripts.

01:26:34.480 --> 01:26:35.600
I'll show you how that works.

01:26:35.600 --> 01:26:37.160
It's quite easy.

01:26:40.040 --> 01:26:42.920
So I just ran a script on the model that told me to find the

01:26:42.920 --> 01:26:46.080
number of parts in the scope that I defined and the number

01:26:46.080 --> 01:26:47.600
of ports.

01:26:47.600 --> 01:26:49.480
And here's the output of that model right here.

01:26:49.480 --> 01:26:53.080
So the script itself is not even very complicated.

01:26:53.080 --> 01:26:56.000
It's like 50, 60 lines of code.

01:26:56.000 --> 01:26:58.240
And immediately I can pull out how many ports, how many

01:26:58.240 --> 01:27:01.520
parts, things like that, information about my system.

01:27:01.520 --> 01:27:03.960
So let me kind of take you briefly through the development

01:27:03.960 --> 01:27:05.200
process.

01:27:05.200 --> 01:27:07.680
So that was, again, the highest, the most abstract, the

01:27:07.680 --> 01:27:10.040
earliest version of our system, SRR.

01:27:10.040 --> 01:27:11.960
This is SDR.

01:27:11.960 --> 01:27:16.760
You can see it's starting to get a bit more complex.

01:27:16.760 --> 01:27:20.560
And then you can go over to PDR, and it starts to get

01:27:20.560 --> 01:27:21.800
really scary.

01:27:24.480 --> 01:27:25.680
Right?

01:27:25.680 --> 01:27:29.640
And then you go to CDR, and it's just a nightmare.

01:27:29.640 --> 01:27:32.440
So I created all these systems, all these models by hand.

01:27:32.440 --> 01:27:35.120
You can't actually build the model with a script, if you

01:27:35.120 --> 01:27:37.160
would like.

01:27:37.160 --> 01:27:39.880
You can basically do things like define a pattern and then

01:27:39.880 --> 01:27:42.800
apply that pattern to all the parts of that type.

01:27:42.800 --> 01:27:45.120
That's all possible through the API.

01:27:45.120 --> 01:27:48.200
And just to show you how much of a nightmare it was at CDR,

01:27:48.200 --> 01:27:54.680
when they run the same script on the CDR model, we have

01:27:54.680 --> 01:27:57.880
230 parts and 900 interfaces.

01:27:57.880 --> 01:27:59.760
And this was not even modeling to the lowest level of

01:27:59.760 --> 01:28:00.480
fidelity possible.

01:28:00.480 --> 01:28:02.920
I didn't, for example, model all the components, all the

01:28:02.920 --> 01:28:06.200
capacitors, resistors, op-amps, and stuff on the board.

01:28:06.200 --> 01:28:08.280
And now you can already see it's quite large.

01:28:08.280 --> 01:28:12.760
So this is just the idea behind these models would be to

01:28:12.760 --> 01:28:16.480
extend this to the lowest level in a real system and use

01:28:16.480 --> 01:28:18.520
this, basically, use all the capabilities that you have

01:28:18.520 --> 01:28:20.600
with the model to really manage your complexity in a way

01:28:20.600 --> 01:28:22.320
that is just not possible currently.

01:28:22.320 --> 01:28:24.880
And there's no way you can really mentally keep track of

01:28:24.880 --> 01:28:26.200
all these interfaces and understand

01:28:26.200 --> 01:28:27.400
how your system is working.

01:28:27.400 --> 01:28:29.320
So having this modeling capability and querying

01:28:29.320 --> 01:28:33.040
capability is really, really powerful.

01:28:33.040 --> 01:28:38.840
What was used during RECSYS for the systems engineering?

01:28:38.840 --> 01:28:41.640
You had applied this after the fact.

01:28:41.640 --> 01:28:46.400
What was used to create these block diagrams or track

01:28:46.400 --> 01:28:46.840
things during RECSYS?

01:28:46.840 --> 01:28:49.560
Do you mean during when we were developing RECSYS?

01:28:49.560 --> 01:28:51.480
We basically didn't have this.

01:28:51.480 --> 01:28:54.960
So we were relying, as you would typically do, upon the

01:28:54.960 --> 01:28:57.280
capabilities of the system engineer or the team.

01:28:57.280 --> 01:28:58.080
You'd have documents.

01:28:58.080 --> 01:29:00.000
We have a ton of documents.

01:29:00.000 --> 01:29:02.360
But I was talking about how things weren't buildable.

01:29:02.360 --> 01:29:05.760
I found a situation where, because of the way we had

01:29:05.760 --> 01:29:07.240
done our thermal system, we were dumping

01:29:07.240 --> 01:29:11.160
spacecraft heat to space, which you don't want to do.

01:29:11.160 --> 01:29:13.600
I can explain why, but you don't want to do that.

01:29:13.600 --> 01:29:16.280
And that's something we didn't realize at the time.

01:29:16.280 --> 01:29:18.920
Like if we had tried to build it, we would have had this

01:29:18.920 --> 01:29:21.400
property of the system that we didn't know actually existed

01:29:21.400 --> 01:29:23.000
until I went back and looked at the model.

01:29:23.000 --> 01:29:25.080
So we definitely missed things.

01:29:25.080 --> 01:29:27.200
And this should have improved the design process if we had

01:29:27.200 --> 01:29:29.880
been using it.

01:29:29.880 --> 01:29:33.600
So Mark, to wrap up, because we've got to switch over to

01:29:33.600 --> 01:29:37.320
Modellica, what's your recommendation for, let's say

01:29:37.320 --> 01:29:40.320
students in the class got intrigued by CISML.

01:29:40.320 --> 01:29:42.840
What's the next step?

01:29:42.840 --> 01:29:43.800
There's a couple of different ways.

01:29:43.800 --> 01:29:45.480
Certainly, if you're interested, let me know.

01:29:45.480 --> 01:29:49.760
And I can give you resources to further your understanding.

01:29:49.760 --> 01:29:53.120
As I said, working with these tools can be expensive to get

01:29:53.120 --> 01:29:54.080
these tools.

01:29:54.080 --> 01:29:57.720
So I can help you understand what that would take.

01:29:57.720 --> 01:30:03.600
There are some beginning to be some companies that will do

01:30:03.600 --> 01:30:06.920
CISML training courses that will sit down for a day or a

01:30:06.920 --> 01:30:10.080
week and teach you CISML, basically, how to work with

01:30:10.080 --> 01:30:11.680
the model, how to build the model.

01:30:11.680 --> 01:30:12.600
I took one of those courses.

01:30:12.600 --> 01:30:14.160
It was really great.

01:30:14.160 --> 01:30:16.840
So talk to me if you're interested, and I can steer

01:30:16.840 --> 01:30:18.480
you down the right path.

01:30:18.480 --> 01:30:19.160
Great.

01:30:19.160 --> 01:30:19.800
Thanks, Mark.

01:30:19.800 --> 01:30:20.280
Sure.

01:30:20.280 --> 01:30:22.360
Very good.

01:30:22.400 --> 01:30:25.560
So we did, in 20 minutes, what usually take about a week,

01:30:25.560 --> 01:30:27.160
right?

01:30:27.160 --> 01:30:29.320
There's a lot more to it.

01:30:29.320 --> 01:30:29.560
Great.

01:30:29.560 --> 01:30:34.280
So we're going to switch over now to Modellica, which I

01:30:34.280 --> 01:30:37.440
think is we're going to maybe run a couple minutes over

01:30:37.440 --> 01:30:40.040
today, but I think it's important we cover all three

01:30:40.040 --> 01:30:42.160
languages.

01:30:42.160 --> 01:30:45.360
So let's get the slides back up.

01:30:45.360 --> 01:30:47.160
And I'm going to switch here to Narik.

01:30:47.160 --> 01:30:49.760
He's another doctoral student in the group.

01:30:49.760 --> 01:30:55.320
And so introduce yourself, and then tell us about Modellica.

01:30:55.320 --> 01:30:56.320
Great.

01:30:56.320 --> 01:30:58.320
Thank you.

01:30:58.320 --> 01:31:00.720
Are you using your computer for slides or this computer?

01:31:00.720 --> 01:31:03.200
For the demo, I'm going to use this one.

01:31:03.200 --> 01:31:04.640
You need this one?

01:31:04.640 --> 01:31:05.120
This one.

01:31:16.120 --> 01:31:16.880
So hello, everyone.

01:31:16.880 --> 01:31:17.600
My name is Narik.

01:31:17.600 --> 01:31:20.720
I'm a doctoral student at AeroAstro here.

01:31:20.720 --> 01:31:23.760
My background is in gas turbine engines, and specifically

01:31:23.760 --> 01:31:26.280
I've been looking at concept generation of gas turbine

01:31:26.280 --> 01:31:28.840
engines, automated concept generation.

01:31:28.840 --> 01:31:31.360
And the way I got acquainted with Modellica

01:31:31.360 --> 01:31:34.840
was that I needed to be able to rapidly reconfigure different

01:31:34.840 --> 01:31:38.080
concepts and simulate them mathematically,

01:31:38.080 --> 01:31:39.880
do physics-based simulations.

01:31:39.880 --> 01:31:42.440
So in contrast to the first two languages,

01:31:42.440 --> 01:31:46.400
Modellica is a lot more about rapidly being

01:31:46.400 --> 01:31:48.840
able to build physical models of systems

01:31:48.840 --> 01:31:51.680
and reconfiguring them and reusing them for later on.

01:31:54.280 --> 01:31:57.600
So like I mentioned, Modellica is primarily

01:31:57.600 --> 01:32:00.400
about physics-based modeling of systems

01:32:00.400 --> 01:32:04.560
and rapidly being able to reuse models and reconfigure them.

01:32:04.560 --> 01:32:05.480
It's a language.

01:32:05.480 --> 01:32:09.560
Again, it's not a tool, like the first two that you heard about.

01:32:09.560 --> 01:32:12.080
There are many different tools which implement this language,

01:32:12.080 --> 01:32:14.800
but I'm going to start off with just describing how the language

01:32:14.800 --> 01:32:17.720
works and then go on to describe which tools that you can use.

01:32:17.720 --> 01:32:20.760
In contrast to CISML, there are a couple of really good free

01:32:20.760 --> 01:32:22.960
tools that you can use and rapidly get into.

01:32:22.960 --> 01:32:25.440
And there are a lot of libraries that you

01:32:25.440 --> 01:32:28.400
can use with hundreds of even thousands of actually basic

01:32:28.400 --> 01:32:31.000
components that you can use for modeling.

01:32:31.000 --> 01:32:32.680
So it's a declarative language.

01:32:32.680 --> 01:32:35.880
And what I mean by declarative is that you don't,

01:32:35.880 --> 01:32:39.920
in sequential sort of programming, you write commands

01:32:39.920 --> 01:32:42.840
and you make assignments to various parameters.

01:32:42.880 --> 01:32:45.760
Here, you just describe the governing equations

01:32:45.760 --> 01:32:48.680
of the components you want to simulate.

01:32:48.680 --> 01:32:51.320
And there's no particular order in which you do this.

01:32:51.320 --> 01:32:52.520
The models are a-causal.

01:32:52.520 --> 01:32:54.480
There's no direction to flows.

01:32:54.480 --> 01:32:57.280
All you really need to do is describe what ports,

01:32:57.280 --> 01:32:59.400
like Mark mentioned.

01:32:59.400 --> 01:33:00.840
It's similar in this situation.

01:33:00.840 --> 01:33:02.760
What kind of ports you have, what kind of interfaces

01:33:02.760 --> 01:33:04.680
the components can have with other components,

01:33:04.680 --> 01:33:08.160
and the governing equations and the parameters and variables.

01:33:08.160 --> 01:33:10.160
It's a multi-domain modeling language,

01:33:10.160 --> 01:33:12.520
so it's agnostic to what kind of domain you're working in.

01:33:12.520 --> 01:33:14.920
It's not particularly electrical engineering.

01:33:14.920 --> 01:33:17.120
For example, I'm going to be showing an electrical engineering

01:33:17.120 --> 01:33:20.120
example and also show a gas turbine engine example

01:33:20.120 --> 01:33:22.520
with aero-elastic vibrations.

01:33:22.520 --> 01:33:24.440
So you don't necessarily, you're not attached

01:33:24.440 --> 01:33:26.320
to any specific domain.

01:33:26.320 --> 01:33:30.560
It's also object-orientated, and it enables you to decompose

01:33:30.560 --> 01:33:35.200
systems into subsystems or recombine them

01:33:35.200 --> 01:33:37.920
and look at them at various layers of abstraction.

01:33:37.920 --> 01:33:40.680
It's designed to be efficient, so this

01:33:40.680 --> 01:33:42.280
is a quote from Professor Peter Fritzen

01:33:42.280 --> 01:33:44.320
at Linkping University.

01:33:44.320 --> 01:33:47.600
So these are just about the sort of scale of problems

01:33:47.600 --> 01:33:50.680
that you can solve with the medallic language.

01:33:50.680 --> 01:33:52.600
Obviously, it depends on what kind of equations

01:33:52.600 --> 01:33:55.480
you're talking about, but it's designed

01:33:55.480 --> 01:34:00.520
to be a very efficient way of simulating systems.

01:34:00.520 --> 01:34:02.600
So I really want to talk a little bit more

01:34:02.600 --> 01:34:04.920
about this idea of a-causal modeling

01:34:04.920 --> 01:34:06.520
that I mentioned before.

01:34:06.520 --> 01:34:09.760
So on the left-hand side is an assignment,

01:34:09.760 --> 01:34:13.560
and that's typically what you do when you program in MATLAB,

01:34:13.560 --> 01:34:15.880
just the MATLAB normal scripts.

01:34:15.880 --> 01:34:18.160
F is assigned to MA, or P is assigned

01:34:18.160 --> 01:34:21.160
the value of RORT for the equation of state of a gas.

01:34:21.160 --> 01:34:23.200
And what that means is that you know

01:34:23.200 --> 01:34:24.760
what the mass and acceleration are,

01:34:24.760 --> 01:34:26.000
and you figure out the force.

01:34:26.000 --> 01:34:28.040
And you assign that value to the force.

01:34:28.040 --> 01:34:30.440
In medallica, there's almost none of this.

01:34:30.440 --> 01:34:32.360
It's equations, not assignments.

01:34:32.360 --> 01:34:34.440
And what I mean by that is this equation

01:34:34.440 --> 01:34:35.600
can be written in any which way.

01:34:35.600 --> 01:34:38.720
As long as your system has the same number of equations

01:34:38.760 --> 01:34:41.680
as unknowns, the tool that you're using

01:34:41.680 --> 01:34:44.640
will interpret the language and will solve your problem.

01:34:44.640 --> 01:34:47.680
So you can write this in any which way you want in any order.

01:34:47.680 --> 01:34:51.120
As long as your problem is properly constrained,

01:34:51.120 --> 01:34:53.680
the tool that you're using will interpret it and solve

01:34:53.680 --> 01:34:54.640
the problem for you.

01:34:58.040 --> 01:35:02.440
So just to go into a little bit more detail,

01:35:02.440 --> 01:35:06.600
all of medallica's and also of a-causal modeling language

01:35:06.600 --> 01:35:09.040
that I'll mention in a little bit, which is one of them

01:35:09.040 --> 01:35:11.040
is Simscape.

01:35:11.040 --> 01:35:12.840
Models have essentially three parts.

01:35:12.840 --> 01:35:15.760
They're designed to be extremely simple.

01:35:15.760 --> 01:35:19.800
The first, like Mark mentioned, are ports.

01:35:19.800 --> 01:35:24.680
It's essentially identical to SSML in a way.

01:35:24.680 --> 01:35:27.600
Ports are the ways with which components

01:35:27.600 --> 01:35:31.880
can share information, material, or energy, for example.

01:35:31.880 --> 01:35:33.880
You can define any kind of port you want.

01:35:33.880 --> 01:35:35.240
All you need to really do is define

01:35:35.240 --> 01:35:37.400
what kind of parameters it carries, like for gas,

01:35:37.400 --> 01:35:39.400
for example, temperature, pressure, and mass flow,

01:35:39.400 --> 01:35:42.960
or for electrical ports, voltage, and current.

01:35:42.960 --> 01:35:44.960
The second part of any kind of model

01:35:44.960 --> 01:35:47.600
that you're building in medallica or Simscape,

01:35:47.600 --> 01:35:49.120
which I'll mention a little later,

01:35:49.120 --> 01:35:51.240
are variables and parameters, so you just declare those.

01:35:51.240 --> 01:35:53.000
And the third part are governing equations.

01:35:53.000 --> 01:35:55.360
The point is that there's nothing else.

01:35:55.360 --> 01:35:57.840
It's just that.

01:35:57.840 --> 01:36:01.720
And I'll just briefly go through a very, very simple example.

01:36:01.720 --> 01:36:04.720
So for example, a capacitor.

01:36:04.720 --> 01:36:06.680
This is the entire code for a capacitor,

01:36:06.680 --> 01:36:10.600
and this is what will generate a visual image of a capacitor

01:36:10.600 --> 01:36:13.640
with the correct ports for you.

01:36:13.640 --> 01:36:18.040
First, you have pins that carry voltage and current.

01:36:18.040 --> 01:36:20.640
So the key thing to notice here is

01:36:20.640 --> 01:36:23.440
that there are fundamentally two types of variables.

01:36:23.440 --> 01:36:26.960
Flow variables and normal variables here.

01:36:26.960 --> 01:36:30.200
Flow variables are ones through which the Kirchhoff's current

01:36:30.200 --> 01:36:30.760
law applies.

01:36:30.760 --> 01:36:33.640
So mass flow, for example, every time

01:36:33.640 --> 01:36:36.040
you connect 15 components together in a network,

01:36:36.040 --> 01:36:39.160
mass flow into that network needs to be conserved.

01:36:39.160 --> 01:36:43.040
So the sum of mass flows into any node has to be 0.

01:36:43.040 --> 01:36:46.360
That doesn't apply to the standard variables.

01:36:49.480 --> 01:36:54.680
So then you essentially define the parameters of variables,

01:36:54.680 --> 01:36:57.200
and you need to define the governing equations,

01:36:57.200 --> 01:36:58.960
and that's the capacitor for you.

01:36:58.960 --> 01:37:01.040
There are slightly more complicated components

01:37:01.040 --> 01:37:05.480
that you can use, for example, a pressure drop component.

01:37:05.480 --> 01:37:06.920
Did I lose my sharing?

01:37:06.920 --> 01:37:08.840
No.

01:37:08.840 --> 01:37:10.680
In this case, the interesting thing

01:37:10.680 --> 01:37:12.560
is the main thing to take away from this one

01:37:12.560 --> 01:37:15.000
is that if you have complicated mathematics describing

01:37:15.000 --> 01:37:16.920
the fluid mechanics in a component,

01:37:16.920 --> 01:37:19.480
you can actually initialize with one model

01:37:19.480 --> 01:37:21.880
and then go to a full turbulent simulation.

01:37:21.880 --> 01:37:25.120
That's what this is doing here.

01:37:25.120 --> 01:37:30.800
So just to get to the tool side of the equation,

01:37:30.800 --> 01:37:32.360
the language I just showed you, it's

01:37:32.360 --> 01:37:34.040
the same across all the tools.

01:37:34.040 --> 01:37:35.200
But there are many different tools

01:37:35.200 --> 01:37:38.080
which you can use free and commercial to actually

01:37:38.080 --> 01:37:40.720
run these models.

01:37:40.720 --> 01:37:44.800
The main one that you'll be using if you want to get deeper

01:37:44.800 --> 01:37:46.040
into this is open medelica.

01:37:46.040 --> 01:37:47.120
It's free.

01:37:47.120 --> 01:37:49.560
It's actually become quite user friendly,

01:37:49.560 --> 01:37:53.680
and there's a link in the slides with which

01:37:53.680 --> 01:37:55.600
from which you can download it.

01:37:55.600 --> 01:37:57.120
There's one from Wolfram.

01:37:57.120 --> 01:38:00.280
It's integrated with Mathematica,

01:38:00.280 --> 01:38:03.000
which is quite useful, and there's a free trial of it as well.

01:38:03.000 --> 01:38:05.800
There's Daimler, there are other ones.

01:38:05.800 --> 01:38:07.760
But mainly, I think open medelica is the one

01:38:07.760 --> 01:38:10.080
that you guys will be using.

01:38:10.080 --> 01:38:13.520
OK, Sonar, I think we're actually going to wrap up,

01:38:13.520 --> 01:38:14.600
and then have you back next week.

01:38:14.600 --> 01:38:15.640
Are you around next week?

01:38:15.640 --> 01:38:16.880
Yeah, yeah, sure.

01:38:16.880 --> 01:38:21.800
So here's, just stay around.

01:38:21.800 --> 01:38:27.400
So basically, we're going to finish this lecture next week.

01:38:27.400 --> 01:38:29.640
I think it's important enough that you really

01:38:29.640 --> 01:38:31.720
see the demo and see sort of the,

01:38:31.720 --> 01:38:34.240
and it actually ties in kind of nicely with,

01:38:34.240 --> 01:38:36.840
next week's topic is concept generation, right?

01:38:36.840 --> 01:38:39.680
This is the next step in the V. And since, you know,

01:38:39.680 --> 01:38:42.080
Narik, your research is also in concept generation,

01:38:42.080 --> 01:38:44.360
it'll tie in nicely.

01:38:44.360 --> 01:38:47.000
So I think we're going to stop here for today.

01:38:47.000 --> 01:38:50.440
So you heard about the general idea of system modeling

01:38:50.440 --> 01:38:54.160
languages that are rigorous, that have ontology, syntax,

01:38:54.160 --> 01:38:55.840
and semantics.

01:38:55.840 --> 01:38:58.320
There's different of these that have been proposed,

01:38:58.320 --> 01:39:00.680
developed, some are used more than others.

01:39:00.680 --> 01:39:03.040
There's really important differences between them.

01:39:03.040 --> 01:39:05.560
So OPM is very conceptual.

01:39:05.560 --> 01:39:09.920
CISML is based on UML, and has these different type

01:39:09.920 --> 01:39:12.960
of diagrams, and can really help you flesh out

01:39:12.960 --> 01:39:14.640
your design in more detail.

01:39:14.640 --> 01:39:17.120
And then Medellica allows you to build these blocks.

01:39:17.120 --> 01:39:20.960
It's acausal or declarative, and you can actually

01:39:20.960 --> 01:39:25.920
simulate the physics of the system pretty readily.

01:39:25.920 --> 01:39:29.240
So the big picture here, just to wrap up here,

01:39:29.240 --> 01:39:32.200
the big picture is the following.

01:39:32.200 --> 01:39:34.640
And we'll come back to this next week.

01:39:34.640 --> 01:39:39.680
The big picture is basically that system engineering

01:39:39.680 --> 01:39:41.880
is in a transition phase.

01:39:41.880 --> 01:39:44.280
The classic way of doing system engineering, really,

01:39:44.280 --> 01:39:48.400
for the last 50 years, is on the left, document-centric.

01:39:48.400 --> 01:39:51.840
You know, write your requirements, do your drawings.

01:39:51.840 --> 01:39:55.240
Even CAD, you know, computer-aided design, is great,

01:39:55.240 --> 01:39:57.600
but it only essentially does the mechanical part

01:39:57.600 --> 01:39:59.040
of the design, right?

01:39:59.040 --> 01:40:02.200
And so the result of that is, as you get even REXIS,

01:40:02.200 --> 01:40:05.880
so REXIS is a box like shoebox size, basically,

01:40:05.880 --> 01:40:08.920
and it's going to fit on a much bigger spacecraft,

01:40:08.920 --> 01:40:11.040
and you saw how much complexity is there.

01:40:11.040 --> 01:40:13.280
And it gets very, very difficult to manage

01:40:13.280 --> 01:40:16.000
all this information, to prevent errors,

01:40:16.000 --> 01:40:19.400
oversights, any change that you make.

01:40:19.400 --> 01:40:22.920
It doesn't propagate automatically in these documents.

01:40:22.920 --> 01:40:26.360
So the transition is happening to the right side,

01:40:26.360 --> 01:40:30.400
a model-centric way to do system engineering,

01:40:30.400 --> 01:40:33.080
as think of paperless engineering.

01:40:33.080 --> 01:40:35.720
Everything you're doing is in a model.

01:40:35.720 --> 01:40:38.920
The models are linked, the models are executable,

01:40:38.920 --> 01:40:42.240
the models automatically propagate any changes

01:40:42.240 --> 01:40:44.880
that you make, you know, in requirements or design.

01:40:44.880 --> 01:40:46.800
We're not quite there yet, but that

01:40:46.800 --> 01:40:48.960
is where things are moving.

01:40:48.960 --> 01:40:51.760
And so keep that in mind.

01:40:51.760 --> 01:40:53.600
So there's no new assignment this week.

01:40:53.600 --> 01:40:57.000
So next week, we have A2, which is due, the requirements.

01:40:57.000 --> 01:40:58.320
Please let us know if you have any.

01:40:58.320 --> 01:40:59.240
We're here for you.

01:40:59.240 --> 01:41:02.360
So I'm going to have office hours now on the WebEx.

01:41:02.360 --> 01:41:03.200
You have the link.

01:41:05.800 --> 01:41:07.680
If you have any questions about A2,

01:41:07.680 --> 01:41:10.440
don't be shy to email me or, you know,

01:41:10.440 --> 01:41:13.640
Juana or Lieslu at EPFL.

01:41:13.640 --> 01:41:15.360
We're really here to answer your questions.

01:41:15.360 --> 01:41:17.720
So next week, topic we're going to finish

01:41:17.720 --> 01:41:20.640
on modelica and concept generation

01:41:20.640 --> 01:41:23.520
is going to be sort of our creativity, concept generation

01:41:23.520 --> 01:41:25.120
is our main topic next week.

