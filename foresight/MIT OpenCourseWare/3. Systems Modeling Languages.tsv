start	end	text
0	2480	The following content is provided under a Creative
2480	3680	Commons license.
3680	6120	Your support will help MIT OpenCourseWare
6120	10000	continue to offer high quality educational resources for free.
10000	12760	To make a donation or to view additional materials
12760	16600	from hundreds of MIT courses, visit MIT OpenCourseWare
16600	17440	at ocw.mit.edu.
25040	28200	So let me start.
28200	31080	Session three is about system modeling languages.
31080	35960	But before I start, I'd like to remind you
35960	38960	that A1 is due today.
38960	41960	The first assignment is due today.
41960	46640	And I think neither Ioana or I or Liz,
46640	48840	did you get a lot of questions about A1?
54120	56200	No, I didn't get any questions.
56200	58280	Yeah, so we didn't get many questions.
58280	62080	So I think I interpret that as a positive,
62080	65160	but I guess we'll find out.
65160	66280	Everybody submitted.
66280	72280	OK, well, so we're hoping to have these graded in about a week,
72280	76880	give you feedback, and we'll also post a master solution.
76880	80160	And A2 is out right now.
80160	84440	And the other good news is there's no new assignment today.
84440	86880	The next A3 is going to go out next week, OK?
89720	91720	Any questions about A1?
91720	97160	Was there something that was particularly difficult or confusing,
97160	98760	or was it straightforward?
98760	100520	Anybody want to comment on A1?
105000	107720	Wow.
107720	109720	Sam?
109720	112760	Do you want to push the button?
112760	114920	No, our team thought it was fairly clear
114920	118120	on what we had to do based on the lectures.
118120	118620	OK.
118620	120120	We didn't have any trouble.
120120	121160	Good.
121160	125320	All right, well, let's keep going then.
125320	128920	So the V model is our roadmap for the class.
128920	130760	We're starting to fill in the V. We're still
130760	132280	in the upper left corner.
132280	135320	And today's lecture is actually a little different.
135320	139560	It's sort of in the center of the V. System modeling languages
139560	142480	as a precondition or precursor to what
142520	146640	we've been calling NBSC, model-based system engineering.
146640	152560	So what I'd like to cover today is why do we need
152560	156080	or why have these system modeling languages emerged?
156080	159360	Particularly, what do we mean by ontology, semantics,
159360	160760	and syntax?
160760	164680	And then I would characterize this
164680	169440	as a sampler of three different system modeling languages
169440	173840	that have emerged really within the last 10, 15 years.
173840	178400	The first one is called OPM, Object Process Methodology.
178400	182320	The second one is called SysML, System Modeling Language.
182320	185520	And then the third one is called Medellica.
185520	189200	And then we'll sort of quickly wrap up with the question,
189200	192520	what does this mean now for system engineering today
192520	195480	and tomorrow in the future?
195480	199040	So I'd like to motivate this with a little exercise.
199480	202120	You remember Mr. Sticky from last time?
202120	203640	You came up with some requirements.
203640	207400	So it's kind of the simplest system I could think of here.
207400	212120	So what we'd like to do is have you work in pairs again.
212120	219280	And the assignment here is to describe this system
219280	222760	as clearly as you can, provide a description.
222760	226360	So last time the assignment was write a requirement,
226360	230440	come up with some requirements that led to this design.
230440	232960	But today I would like you to describe
232960	236000	what the system is, how it functions, and so forth,
236000	237960	as clearly as you can.
237960	241400	And I would like you to do this, so hopefully you're
241400	244440	on the WebEx, logged into the WebEx.
244440	247000	I would like you to do this in teams of two.
247000	249880	And as you're doing this, I don't know if you noticed,
249880	258200	but on the WebEx, there's actually a note pad feature.
258200	258720	Where is it?
270960	272880	Tell me.
272880	274360	Left, right.
274360	286200	I see.
286200	289320	So I can't share and use the note pad at the same time.
289320	294160	It's the whiteboard right there.
294160	297040	Annotate?
297040	299000	Yeah, yeah.
299000	301960	But if you go back into view.
302000	304560	Stop sharing.
304560	305920	But then they can't see it, right?
309800	314440	Can they see this?
314440	315720	So you can write text.
332720	335040	You can draw the shapes.
341440	345240	OK, so the reason I want you to do this on the whiteboard
345240	348160	is such that we can then sort of go around
348160	351000	and look at some examples.
351000	354640	So the assignment is take five minutes,
354640	359840	turn to your partner, and try to describe the system.
359880	362120	And then we'll go around and look at some,
362120	365720	I will sample people's descriptions.
365720	368360	Go for it.
368360	372240	All right, so keep working on the assignment,
372240	376400	but do it locally on your computer, not on the whiteboard.
376400	379600	And then we'll sort of discuss it and share it,
379600	382440	and maybe not use the whiteboard.
382440	385240	Because I didn't realize there's only one whiteboard
385240	386160	that we all share.
386160	388440	I thought that you have individually the whiteboard,
388440	391280	and then you can sort of pass it on to different people.
391280	395120	So but if you do it locally on your machine,
395120	396640	then we can share the screen.
396640	397200	So it'll work.
397200	402840	So do it in PowerPoint, or Word, or Sketchpad,
402840	404360	or anything you want.
404360	405080	Sorry about that.
409680	413400	OK, all right, so let's do this.
413400	418160	We're going to sort of go back and forth between here and EPFL.
418200	422960	Let's start maybe over here with Narik.
422960	424440	Are you ready?
424440	427680	So I'm going to give you the ball,
427680	433680	and then you can sort of explain how you guys describe the system.
433680	438240	So what we decided to do was identify the primary function
438240	443480	of the sticky, Mr. Sticky.
443480	448520	So the primary function is to trap the fly, we thought.
448520	450720	This is enabled by a couple of other functions
450720	453440	that are sort of at a lower layer of abstraction.
453440	456200	It's attracting the fly, immobilizing the fly,
456200	459080	transporting the object to where you
459080	462880	need to immobilize the fly, and deploying Mr. Sticky.
462880	465800	And we map this to the physical forms
465800	466960	that enable the function.
466960	469200	So the canister, the physical form of the canister
469200	471840	is helping with the transporting function.
471840	474880	The sticky tape is helping with the immobilizing function.
474880	476360	The scented material, we thought,
476360	478680	that would be helping for the attracting function.
478680	481480	And the hook, maybe on top that you used to hang it,
481480	483000	would help with the deploying.
483000	484360	OK, good.
484360	487440	So nice function form separation,
487440	491800	and you use primarily text, human language to describe it.
491800	494720	So let's see, at EPFL, who would like to share?
498840	499880	And we'll give you the ball.
502520	505600	OK, we can try, maybe.
505600	507720	Who is speaking?
507720	508640	Maxim.
508640	509400	Maxim, OK.
509400	512920	Can we give the ball to Maxim?
512920	514360	Yes, do you see something?
514360	516080	Yeah, it's good.
516080	516600	Oh, perfect.
516600	522680	So we draw the same system when deployed and deployed.
522680	525200	So we begin with the container containing
525200	527960	basically the sticky setup rolled.
527960	530000	Then when unrolled, we have the container
530000	534560	that should be linked to the sticky setup with a stick,
534560	535560	but whatever.
535560	539680	And we have like, an external input from the insects
539680	543320	that come to be sticked onto the.
547400	548160	Yeah, go ahead.
551920	554400	OK, so that's all.
554400	559280	OK, so I'll note here that you guys use graphics, right?
559280	561000	You use some kind of graphical language.
561000	565400	And at the highest level, it's like a state diagram, right?
565400	566400	Rolled, unrolled.
566400	569000	So you show the system in two different states.
569000	570720	Very nice.
570720	572800	Somebody else here on the MIT side,
572800	574600	and then we'll go back one more time.
574600	576800	Who would like to share here?
576800	578040	You see him?
578040	579760	OK.
579760	581880	So let's.
581880	588600	OK, so we did a diagram showing the use of Mr. Sticky.
588600	591040	So we have a user, because Mr. Sticky has
591040	594360	to be rolled and unrolled.
594360	599120	The user installs or disposes of Mr. Sticky.
599120	601520	The flies are attracted to, or Mr. Sticky
601520	604560	attracts the flies, and the flies stick to Mr. Sticky.
604560	608760	And then we decompose Mr. Sticky into the different components
608760	611800	that are below at a lower level.
611800	615680	And yeah, so it's basically at a higher level of use diagram.
615720	619120	So here we have, again, a graphical description.
619120	621240	The states are sort of implied, but you're
621240	623120	focusing on decomposition, right?
623120	625640	The sub-elements.
625640	626960	Very nice.
626960	629240	Anybody else at EPFL did anybody just
629240	633600	write a paragraph of text, or more of like sentences?
639920	641640	At EPFL, who wants to share?
642480	645760	Chris here.
645760	646260	Chris?
646260	646760	OK.
646760	649600	No, we didn't write a text.
649600	652320	The text seemed a bit heavy to convey
652320	657080	a description in efficient terms.
657080	661120	What we prefer to do is decompose in elements,
661120	666640	and for each element, give some properties.
669600	670800	OK.
670800	673720	And did you do this in the form of a list,
673720	679440	or in the form of a table, or how did you actually describe it?
679440	681680	So wait, I'm trying to share the screen.
681680	683360	OK.
683360	686560	All right, so we just walked on the first half here.
686560	689800	We have the band, and we give here properties,
689800	693160	though, so it has to be made of paper or soft material.
693160	697520	It has to be one to one-size meters long, three centimeters,
697520	700720	three to five centimeters large.
700720	703640	It needs to have a coating, which in itself
703640	709360	is a sticky material, and be sanded in order to attract flies.
709360	711280	It needs to have visible color.
711280	717960	And then, well, the other parts here, which I'm highlighting,
717960	722760	would be really related to the packaging.
722760	727640	So a sealed cylindrical container with a single-user
727640	731640	opening, including a hanger, with possibility
731640	734560	of branding on the packaging.
734560	736680	And, well, the non-toxic material
736680	740960	would still refer to the sticky material.
740960	741840	Good, good.
741840	742760	Thank you very much.
742760	743760	This is great.
743760	746920	So what you showed, that's more like a list, right?
746920	749480	And I would describe, this looks like what
749480	751840	I would call a bill of materials, right?
751840	756000	It's essentially a list of the primary elements
756000	758320	of form of the system, but there's
758320	761400	some attributes that are associated.
761400	765480	So this is a list format in the form
765480	768040	of a bill of materials with attributes attached.
768040	769680	So thank you very much.
769680	770720	That's great.
770720	774760	So let's get, I'm going to share here again.
774760	781080	And you're probably wondering, why did we do this?
781080	783440	Why did we do this exercise?
783440	790440	And that's the point I want to make next.
790440	792400	So here's a very simple system.
792400	795320	And we had four examples of descriptions
795320	797480	that were quite different, right?
797480	799960	And of course, if you had more time,
799960	801560	they'd become more complete, but they
801560	803160	would be really different.
803160	807000	So this is fundamentally the issue
807000	809200	that we've been facing in systems engineering
809200	810520	for a long time.
810520	813000	The means for describing our artifacts,
813000	815760	whether it's something simple as a Mr. Sticky,
815760	819960	or an airplane, or a spacecraft, or a medical device,
819960	822560	or even a service, how would we describe it?
822560	824560	Well, first of all, natural language,
824560	826600	the human natural language.
826600	829360	And as we know, the human natural language
829360	830480	is a very rich, right?
830480	833280	There's very different ways in which we
833280	836720	can express essentially the same facts, the same things.
836720	841760	That's a wonderful thing if you're a poet or a writer,
841760	844600	but it makes system engineering challenging,
844600	848800	because it gets confusing when we're describing
848800	851520	the same thing in very different ways.
851520	854200	Or graphical, so we saw some boxes,
854200	858040	and we saw some great examples, sketches, drawings.
858040	862320	So fundamentally, the way we describe systems,
862320	865640	and this gets to the left half and right half of the brain,
865680	871400	is using language, words, sentences, lists, or graphical.
871400	874920	Those are the two fundamental ways of describing systems.
874920	878280	And then we put all these descriptions together
878280	881520	in what we've been calling documents.
881520	883120	We aggregate this in documents.
883120	886880	So examples of documents would be a requirements document.
886880	889920	That's what essentially you're doing in assignment 2,
889920	893560	or a drawing package.
893560	898320	Even if it's in CAD, it's still essentially a document.
898320	901200	So typically in system engineering,
901200	903000	all of this gets assembled into what
903000	906520	we call a TDP, technical data package.
906520	909600	And fundamentally, when you're designing a new system,
909600	912240	you're producing a technical data package that
912240	916320	has software, drawings, descriptions,
916320	919560	and that's the deliverable from the design process
919560	922280	is this TDP, technical data package.
922320	925040	And from that, you should then be able to build and operate
925040	928440	the system with as few errors, mistakes,
928440	930800	misunderstandings as possible.
930800	933600	And fundamentally, as our systems
933600	935760	have been getting more and more complex,
935760	938360	we're now talking about the systems that
938360	942040	need the three, four, five layers of decomposition.
942040	945800	It's very easy to have errors, omissions,
945800	948640	different interpretations of this information.
948640	951760	So that's fundamentally.
951760	953080	But there are advantages.
953080	957120	I don't want to say it's categorically bad
957120	960120	to use natural language and graphics.
960120	962360	They're definitely advantaged familiarity
962360	963960	to the creator of the description.
963960	967400	So it's easy, it's comfortable, it feels familiar.
967400	969200	And also, it's not confining.
969200	973200	So you can be quite creative by creating descriptions
973200	974240	in this way.
974240	978200	But the list of disadvantages is quite long
978200	980760	for allowing an arbitrary description.
980760	983960	The room for ambiguous interpretations and errors,
983960	985840	it's quite difficult to update.
985840	988000	So if you make a change in one description,
988000	990040	that change will not automatically
990040	993000	propagate to the other descriptions.
993000	995960	Handing off these descriptions from one lifecycle phase
995960	1000360	to another, there's discontinuities in these handoffs.
1000360	1002360	Uneval level of abstraction.
1002360	1004520	So what I mean by that is you may
1004520	1008040	describe one part of the system in very detailed.
1008040	1013160	So the last example we saw with the list,
1013160	1015560	with the Bill of Materials, there was quite a bit of detail
1015560	1019280	there on the scent and the attributes of the tape.
1019280	1022680	But at least a couple of the other descriptions
1022680	1025760	didn't have that level of detail when it came to the tape.
1025760	1028400	So the level of abstraction could
1028400	1033040	be quite different in the different ways to describe it.
1033040	1035480	And then for a complex system, you
1035480	1040040	can imagine that the volume of information grows a lot.
1040040	1044400	And so you can walk into any program manager and systems
1044400	1048880	engineer's office and see bookshelves full of binders,
1048880	1051680	dozens and dozens of binders with documents,
1051680	1053880	thousands and thousands of pages.
1053880	1056400	And many of them are never read.
1056400	1057840	That's the big issue.
1057840	1061080	So that's been the kind of way in which we've
1061080	1064360	been doing system engineering traditionally.
1064360	1070440	So the idea here is that in order to mitigate, yes, Justice?
1078760	1080560	Phase A, conceptual design.
1080560	1083800	Phase B, preliminary and detailed design.
1083800	1088280	Phase C is testing and launch.
1088280	1089480	Phase E is operation.
1089480	1094600	So usually, not the same people do conceptual design,
1094600	1096160	preliminary design, testing.
1096160	1099400	So all the technical data package, these artifacts,
1099400	1101920	have to be transferred and handed off
1101920	1105360	to new people who then work on the next phase.
1105360	1107800	That's what I mean by handoffs.
1107800	1114120	And so the idea is, in order to mitigate
1114120	1117440	some of these disadvantages of natural language
1117480	1121600	and graphical description, there has been,
1121600	1124000	and this has been recognized for a long time,
1124000	1128840	a need to be more precise, perhaps more confining,
1128840	1133320	but to create languages that allow us to describe systems
1133320	1136080	much more precisely.
1136080	1138680	And so I'll mention a couple of the past efforts.
1138680	1143120	And you can read about each of these.
1143120	1146920	So I'll mention bond graphs first, 1960.
1146960	1149840	This was actually invented here at MIT
1149840	1153160	by a professor in mechanical engineering.
1153160	1155320	His name was Harry Painter.
1155320	1158320	Professor Painter created bond graphs.
1158320	1160840	You can think of bond graphs as block diagrams
1160840	1164520	where different blocks have ports or interfaces
1164520	1168160	where information, material, energy flows in and out.
1168160	1171680	And you can compose a system out of these blocks.
1171680	1173880	These bond graphs are essentially,
1173880	1177240	and Narek will talk about Modellica,
1177240	1181000	and which is sort of a modern version of bond graphs.
1181000	1185280	It has other features too, but this has been sort of one
1185280	1186520	attempt.
1186520	1191920	Another one that's very well known is IDEF about 20 years
1191920	1192440	later.
1192440	1196680	This was created by the Air Force, the US Air Force.
1196680	1199280	And this is essentially a description of systems
1199280	1201200	that's very functionally oriented.
1201200	1203520	So it shows you what functions are involved.
1203520	1205000	And we saw one of the descriptions
1205000	1207760	was very functionally oriented and how
1207760	1212400	the functions of the system relate to each other.
1212400	1216560	But generally, these system languages
1216560	1219080	have not fully been deployed.
1219080	1221880	Some organizations use them, others don't use them.
1221880	1223880	And the main reason for that is twofold.
1223880	1227880	First of all, some of these languages were incomplete.
1227880	1230560	They would focus only on one aspect, like functions
1230560	1234920	or the block nature of the system, the block diagrams.
1234920	1237920	And a lot of them were not executable.
1237920	1240560	So they would be graphical, but you couldn't actually
1240560	1243680	simulate and actually check whether that description was
1243680	1245760	complete or accurate.
1245760	1250200	So since then, and the other thing, of course, important
1250200	1252120	is domain agnostic.
1252120	1255520	So what I mean by this is that the system modeling language
1255520	1259360	should be applicable for any kind of cyber-physical system.
1259360	1263600	Again, if you're designing a spacecraft, an aircraft,
1263600	1266400	medical device, any kind of product,
1266400	1268320	the language shouldn't have to be adapted.
1268320	1271000	The language sort of covers all these applications.
1271000	1272480	That's the idea.
1272480	1277800	So whatever language it is that you're using or developing,
1277800	1280480	it has to have these three things.
1280480	1282240	Any language has these three things.
1282240	1284240	So the first is ontology.
1284240	1286680	And I reference here the Wikipedia
1286680	1288560	articles on these things.
1288600	1291240	Some of my colleagues in academia, it's a big debate.
1291240	1293960	Is Wikipedia a legitimate source of information,
1293960	1295160	or is it not?
1295160	1297080	My position on this is that it is.
1297080	1300640	I think Wikipedia is definitely not perfect,
1300640	1302640	depending on what topic you're looking at.
1302640	1305480	But it's a self-correcting system.
1305480	1308840	So I actually go to Wikipedia, and then there's references,
1308840	1310240	and you can dive deeper.
1310240	1313120	So I give you the Wikipedia links here for these three things.
1313120	1315040	First, ontology.
1315040	1319600	So ontology is a very fancy word.
1319600	1323520	What ontology actually is, Mark, why don't you come up here?
1323520	1326160	You're an instructor today.
1326160	1331680	Ontology, fundamentally, is describing the entities that
1331680	1334920	are allowed to exist in the language.
1334920	1340040	Subjects, nouns, adverbs, what are the objects, the entities,
1340040	1341920	that can exist?
1342880	1345840	It's a very abstract thing, but it's essentially
1345840	1348600	the library of words and objects that
1348600	1351840	are allowed to exist in that language.
1351840	1355240	And then how these entities can be grouped, perhaps,
1355240	1357160	in a hierarchy and subdivided.
1357160	1360760	So it essentially constrains the universe of things
1360760	1362400	you can describe in that language.
1362400	1365840	The shorter, the smaller your ontology is,
1365840	1368720	the more confined the language.
1368720	1370280	Semantics.
1370280	1375680	Semantics is basically, it's a branch of science,
1375680	1378560	of philosophy, which is fundamentally
1378560	1381240	assigning meaning to those objects
1381240	1383320	that are described in the ontology.
1383320	1386920	And so the way that we say this is
1386920	1390320	that it's the relationship between the signifiers.
1390320	1394240	So the signifiers are words, letters, symbols,
1394240	1396000	graphical symbols.
1396000	1398360	So how do we describe a resistor, for example,
1398360	1401080	in electrical engineering?
1401080	1402200	A squiggly line, right?
1402200	1403880	It's the zigzag line.
1403880	1406240	Well, if you don't know electrical engineering,
1406240	1408840	or you never, you just see a squiggly line,
1408840	1410640	it's meaningless to you.
1410640	1413320	But if you know that semantically,
1413320	1415400	that means that's a resistor.
1415400	1416800	That's the symbol for resistor.
1416800	1418920	That's what we mean by semantics.
1418920	1421040	And then the third is syntax.
1421040	1422000	What is syntax?
1422000	1426320	It's the set of rules, the set of principles and processes
1426320	1431720	by which the objects or the entities in the ontology
1431720	1435120	can be combined to build up higher level information,
1435120	1439360	like sentences, paragraphs, and so forth.
1439360	1442880	And so that's essentially the construction rules
1442880	1443760	for the language.
1443760	1447520	So every language has these three things.
1447520	1450040	So any questions about this before we
1450040	1452480	move into our first language?
1452480	1455000	So we're going to give three examples of system modeling
1455000	1458120	languages, and you'll see the similarities and differences.
1458120	1460880	But as you see these languages, keep in mind,
1460880	1465920	they all have ontology, semantics, and syntax.
1465920	1469760	Any questions about that?
1469760	1472520	OK, so OPM.
1472520	1474240	Let me describe to you OPM.
1474240	1478160	This is one of the younger languages.
1478160	1481960	And so OPM stands for Object Process Methodology.
1481960	1488000	And it was created by Professor Dov Dory at Technion,
1488000	1489600	colleague of mine.
1489600	1492920	Dov is essentially a computer scientist by training.
1492920	1496320	And you'll see the heritage here of OPM.
1496320	1500600	And the big news here about OPM is OPM
1500600	1503200	is not that well known yet.
1503200	1506840	If you ask around, not too many people know OPM.
1506840	1509040	But I predict that in the next decade,
1509040	1511040	that will change very quickly.
1511080	1514200	And one of the reasons is that OPM was just now
1514200	1517480	adopted as an ISO standard.
1517480	1520560	And if you know ISO, the International Standards Organization
1520560	1523440	that are located in Geneva, it's a big deal
1523440	1524920	to become an ISO standard.
1524920	1526880	It took like five years, the whole process,
1526880	1528840	with committees and reviews.
1528840	1532280	And so the ISO standard is actually,
1532280	1535080	OPM was adopted as an ISO standard
1535080	1539640	as a means to describe and develop other standards.
1539640	1541600	So it's kind of a meta language.
1541600	1543600	Because as you can imagine, when you
1543600	1545880	read different ISO standards, which by the way
1545880	1548480	have a lot of influence, they're also
1548480	1550760	written in natural language and graphics
1550760	1552160	and lots of inconsistencies.
1552160	1554920	So the idea is that future ISO standards
1554920	1558080	should be written using OPM, such that they're
1558080	1560680	clear and consistent and so forth.
1560680	1565640	So the history here is that if we go back further,
1566600	1569680	there was UML, which is Unified Modeling Language, which
1569680	1572800	I'm not going to talk about today, is a software.
1572800	1575080	This is a language that was developed primarily
1575080	1577000	for software engineering.
1577000	1580040	To consistently describe use cases,
1580040	1585400	to consistently describe activity and flows in software,
1585400	1587440	the structure of software.
1587440	1589360	But it's really software-centric.
1589360	1592960	So from UML2, we then sort of branched off
1593000	1596800	into CISML, which Mark showed us, who just joined us.
1596800	1599040	We'll talk about.
1599040	1601560	And then OPM.
1601560	1603760	So these are sort of derivatives of UML.
1603760	1605360	And there's a book.
1605360	1610440	It's not one of the mandatory books for this class, OPM 2002.
1610440	1612200	If you're really interested in OPM,
1612200	1614440	I recommend you invest in that book.
1614440	1617440	It's really very well written.
1617440	1622360	So let me give you an example of how
1622360	1624000	OPM can be used.
1624000	1626760	So like we said, typical product representations
1626760	1629680	are sketches, engineering drawings, or UML diagrams
1629680	1634920	in software, but the need for a unified representation.
1634920	1639600	And fundamentally, we have functions,
1639600	1643240	and then we have objects, form, and function in systems.
1643240	1647280	And so what we would like to do, and what the premise of OPM
1647280	1653120	is that we can show everything in one diagram type.
1653120	1658360	So the functions, the functional attributes, the objects,
1658360	1661200	and there's different types of objects, operands, system
1661200	1665320	components, consumables, the attributes of those objects,
1665320	1666440	and then the links.
1666440	1668520	And I'll show you the different types of links
1668520	1671000	between these that exist in OPM.
1671000	1673200	So it's a generic modeling language,
1673200	1675120	and it has been successfully applied
1675120	1677920	to system architecting of complex products
1677920	1679720	in different organizations.
1679720	1682320	I'm going to try to give you a pretty simple example here,
1682320	1683720	which is a refrigerator.
1683720	1684400	So think about it.
1684400	1688440	We're going to look at a small household level refrigerator
1688440	1692040	through the eyes of OPM.
1692040	1696040	All right, so here's the basic ontology of OPM.
1696040	1698000	It's very, very simple.
1698000	1704200	And the idea is to have as few objects, as few entities
1704200	1707440	as possible in the language to keep it simple.
1707440	1711360	So the first one is the idea of an object.
1711360	1712600	What is an object?
1712600	1715840	And objects are drawn as these rectangles.
1715840	1719840	Objects are defined as entities that
1719840	1724480	have the potential for stable, unconditional existence
1724480	1727160	for some positive duration of time.
1727160	1729680	And objects have states within them.
1729680	1735360	So what would be an example of an object
1735360	1737440	that we've talked about today?
1737440	1738400	Go ahead.
1738400	1739640	Maybe the sticky tape.
1739640	1741960	Yeah, so the sticky tape itself, that's an object.
1741960	1744000	It exists unconditionally.
1744000	1745000	It's there.
1745000	1748920	And what's important is it could be a physical object.
1748920	1751280	So it has a physical existence.
1751280	1756040	But it could also be an informational object.
1756040	1759400	So for example, if you have an idea,
1759440	1762920	or a vision, that's an object, too.
1762920	1764560	It's not physical in that sense.
1764560	1769000	But it does exist as an informational object.
1769000	1770640	What are states?
1770640	1771920	Let's see it, EPFL.
1771920	1774520	What would be an example of a state that's
1774520	1776080	associated with an object?
1783760	1786360	Yeah, that's OK.
1786360	1789240	Can somebody give an example of a state?
1790200	1792760	Rolled and unrolled for the sticky tape?
1792760	1795280	Rolled and unrolled, exactly.
1795280	1796760	Or furled and unfurled.
1796760	1799000	So that's kind of a binary state.
1799000	1803440	There could be halfway unrolled, or the sticky tape
1803440	1806800	is full of flies, or it's kind of empty.
1806800	1809000	Those would be describing the object
1809000	1811920	in terms of what state it is in, exactly.
1811920	1817160	So the form is then the sum of all these objects.
1817200	1819440	So that's one building block.
1819440	1821800	And then processes are the other.
1821800	1823400	So what are processes?
1823400	1824560	Oh, is there another example?
1824560	1825400	Yeah, go ahead.
1825400	1826360	Can I ask a question?
1826360	1828680	Is this Katya?
1828680	1829200	Go ahead.
1829200	1833840	Katya, what do you mean by positive duration of time?
1833840	1837920	Well, meaning that, so the object could be created, right?
1837920	1839360	It didn't exist before.
1839360	1842760	It's created, and it exists, and then it could be destroyed
1842760	1843640	again.
1843640	1846560	It could disappear, or it could be consumed.
1846560	1848280	But it means that the object needs
1848280	1852600	to exist for a non-zero period of time
1852600	1857680	in order for it to be called an object, right?
1857680	1862640	So objects in the world that can be described with OPM
1862640	1866600	fundamentally, objects can be created,
1866600	1869960	objects can be modified, particularly their states
1869960	1874600	can be modified, and they can be destroyed or consumed.
1874600	1876120	That's basically it.
1876120	1878760	That's a complete set, OK?
1878760	1881400	Does that make sense?
1881400	1884440	OK, so processes are, what are processes?
1884440	1886560	Processes are really fundamentally different
1886560	1887320	from objects.
1887320	1890560	Processes are shown as these ellipses,
1890560	1893760	and they're the patterns of transformation
1893760	1897400	applied to one or more objects, and processes change states.
1897400	1902160	So processes, unlike objects, cannot exist on their own.
1902160	1905520	Processes only make sense if they're
1905520	1908880	associated with at least one object, OK?
1908880	1912440	So processes are essentially the functions
1912440	1916280	that we develop in systems are processes that transform
1916280	1919480	or create, destroy, or transform objects.
1919480	1922840	So function emerges from one or more processes,
1922840	1925520	and then we have different links between objects
1925520	1926800	and processes.
1926800	1928040	I'll show you two examples here.
1928040	1931280	One is the arrow with a pointy head, OK?
1931280	1938840	That could be a consumption or production type link,
1938840	1943480	or a link with this little lollipop symbol.
1943480	1946000	This is known as an instrument link.
1946000	1949280	And so the difference there is that if an object is
1949280	1952040	linked to a process using an arrow,
1952040	1954480	it means that something's happening to that object.
1954480	1957400	It's being created or destroyed or modified.
1957400	1960640	If an object is linked to a process using the lollipop
1960640	1963160	symbol, the instrument link, it means
1963160	1966360	that in order for that process to happen,
1966360	1968000	this object is needed.
1968000	1969320	It's an instrument.
1969320	1971360	But the object itself, the instrument,
1971360	1975120	does not get modified in any way by the process.
1975120	1979560	But the process couldn't happen if that object didn't exist.
1979560	1981160	Do you see the difference?
1981160	1983520	And so one of the really, I think, important things
1983520	1986360	about OPM, but any of the languages,
1986400	1990040	is that every box, every arrow, every link
1990040	1992640	has precise semantics.
1992640	1996000	And usually, when we doodle, when we just think about it,
1996000	1998960	we put arrows and links between boxes,
1998960	2000920	we often don't really deeply think,
2000920	2004000	when I put a link in here, what does that link actually mean?
2004000	2005760	What does link imply?
2005760	2008840	So when you do system modeling using these languages,
2008840	2011400	you become much, much more precise.
2011400	2012440	Yes, please.
2012440	2014920	And would you push the mic button when you?
2014920	2016480	Mark, go ahead.
2016480	2019520	Can an object be a process or a process be an object?
2019520	2020800	No.
2020800	2025160	So what about if you have, I guess
2025160	2028680	I'm thinking in terms of if there's
2028680	2030640	some process for doing some procedure,
2030640	2033800	and you're assembling a satellite or whatnot,
2033800	2035440	you need to modify that process.
2035440	2038920	So how is that sort of thing represented in OPM?
2038920	2044160	The process modifies objects, but processes cannot modify
2044160	2046280	other processes, because processes
2046280	2051360	are fundamentally in OPM acting upon the objects.
2051360	2053440	Now, processes can invoke each other.
2053440	2056000	So if there's a sequence of processes,
2056000	2059400	you have to do this assembly step before this other assembly
2059400	2064080	step, you can have what's called an invocation link.
2064080	2066560	But that's a logical dependency between processes.
2066560	2068160	But fundamentally, the processes
2068160	2070640	act through the objects in OPM.
2071360	2072360	OK.
2072360	2075560	So let me be a little bit more.
2075560	2077320	So let's go into some more detail.
2077320	2081080	So at a high level, when you look at the economy,
2081080	2085280	right, products, yes, go ahead.
2085280	2085960	I have a question.
2085960	2091400	Why create another language and not just stick with UML?
2091400	2094800	So good question.
2094800	2099640	So we'll talk about SysML, which is very similar to UML.
2099640	2102480	It's sort of generalized for cyber-physical systems,
2102480	2103960	not just software.
2103960	2107600	So the reason that OPM was created,
2107600	2111440	because UML was found to be somewhat too confining,
2111440	2114720	this is more general, and also the idea
2114720	2119080	of a unified representation, one type of diagram
2119080	2122440	and description for any application.
2122440	2127040	So it's basically a kind of more general version of UML.
2127040	2129600	But the other really important thing about OPM
2129600	2136880	is that the processes are often in object-oriented thinking.
2136880	2140000	Processes are embedded inside objects.
2140000	2145000	And in OPM, the processes have been emancipated
2145000	2147520	to stand at the same level as objects.
2147520	2149720	Those are the main differences.
2149720	2153160	So let me go in a little bit more detail.
2153160	2158120	So if you think about the economy in general,
2158120	2161680	goods and services, goods are objects,
2161680	2164120	and services are processes.
2164120	2173760	So if you buy a new iPad or a new pencil or whatever it is,
2173760	2176080	you're actually buying an object.
2176080	2177440	You're purchasing an object.
2177440	2179480	That's obvious.
2179480	2181720	But why are you purchasing that object?
2184160	2188200	So let's say you're buying a new tablet.
2188200	2190280	You're buying the tablet.
2190280	2194200	But why are you buying the tablet?
2194200	2194880	Sam, go ahead.
2199480	2202360	You're buying the tablet to perform an action
2202360	2205520	or process on something else, to do something.
2205520	2206760	So what do tablets do?
2206760	2209960	I mean, not stone tablets, but modern tablets.
2209960	2216560	They allow you to work with software or communicate.
2216560	2219240	Yeah, so they're information processing.
2219240	2221320	They're information processing devices.
2221320	2223600	And there's an argument.
2223600	2225640	Tablets are great for consuming information.
2225640	2229560	They're maybe not as good for generating new information.
2229560	2233360	So fundamentally, you're purchasing the tablet,
2233360	2236800	which is an object, in order to be
2236800	2238880	able to do information processing,
2238880	2240680	and information consumption.
2240680	2245200	So the process is then implicit, right?
2245200	2246160	What's an example?
2246160	2249880	If you purchase a service, what would be an example of a service?
2253920	2257480	What would be an example of a service?
2257480	2258600	Let's see at EPFL.
2258600	2261200	What would be an example of a service that you could purchase?
2267360	2268560	Going to the dentist.
2268560	2269880	Going to the dentist.
2269880	2273560	Yeah, one of our favorite things to do.
2273560	2275720	So have you been there recently, or?
2278520	2280200	Yeah, one month ago.
2280200	2284320	So I don't want to violate your privacy,
2284320	2289800	but can you share with us what happened at the dentist?
2289800	2291480	Usually, it's the yearly checkup.
2291480	2296080	You have to check that there's no hidden,
2296120	2299160	I don't know how do you call it in English, the caries?
2299160	2301160	Yeah, cavities.
2301160	2302760	Yeah, cavities.
2302760	2305440	Check that wisdom tooth don't mess up
2305440	2308560	what you've been walking on tirelessly
2308560	2310240	when you were younger with braces.
2310240	2315160	And also these kind of things, get checked.
2315160	2316160	Very good.
2316160	2319840	So going to the dentist provides a service, which
2319840	2323840	is either checking your teeth, or filling cavities, which
2323840	2325240	is a process.
2325240	2327520	And all the objects, the chair on which you sit,
2327520	2331640	the instruments, I guess we still use gold sometimes
2331640	2334880	in some places, those are objects that
2334880	2337440	are used in the performance of the service.
2337440	2339640	You see the relationship?
2339640	2342760	So objects and processes always come in pairs.
2342760	2344760	Thank you for that example.
2344760	2348680	So let me talk about the links in OPM briefly.
2348680	2349680	So there are two types.
2349680	2353800	There's the structural links, which link objects to objects.
2353800	2356760	And we typically use arrows, is related to,
2356760	2359000	or we can tag these as well.
2359000	2362000	So for example, something powers something else.
2362000	2363760	This is known as a tagged link.
2363760	2366080	It suppresses the processes.
2366080	2370200	And then there's these triangles that are essentially,
2370200	2372800	there's a kind of hierarchy implied there.
2372800	2374840	And slightly different meanings.
2374840	2378680	So the solid triangle means decomposition.
2378680	2381760	So the higher level object is composed
2382120	2383880	of lower level objects.
2383880	2386600	So that's Mark, you mentioned assembly.
2386600	2388960	You're creating the bus of the spacecraft,
2388960	2391120	and it has a whole bunch of stuff in it.
2391120	2393680	Well, you would use this filled in triangle
2393680	2395480	to show that decomposition.
2395480	2399160	The second example is the characterization link.
2399160	2402840	So this is essentially relating an attribute
2402840	2405200	to its kind of master object.
2405200	2409160	Specialization and generalization is the empty triangle.
2409160	2412400	And then this funny symbol here is instantiation.
2412400	2417400	So essentially you have a general object,
2417480	2419000	and then you can instantiate that.
2419000	2421200	So I have two children, okay?
2421200	2423760	And then there's two, I have two children,
2423760	2427680	which is general, and there's two instantiations of them.
2427680	2429160	One of them is called Gabrielle,
2429160	2430480	and one of them is called Christian,
2430480	2431960	and they're actual people.
2431960	2435920	So that's the idea of instantiation.
2435920	2440920	Processes, processes are these patterns of transformation.
2441480	2442600	They're tricky.
2442600	2445600	Processes are trickier to understand than the objects
2445600	2448040	because we cannot hold or touch a process.
2448040	2451640	It's fleeting, and the creation change
2451640	2455760	or destruction of objects is what processes do.
2455760	2458320	They rely on at least one object
2458320	2460760	in what we call the pre-process set.
2460760	2463680	A process transforms at least one object,
2463720	2466880	and the time is implied.
2466880	2469360	So processes take along a timeline.
2469360	2472240	And in terms of the description in English,
2472240	2474280	we use the so-called gerund form.
2474280	2476400	So all the processes,
2476400	2478040	there's some examples on the right side,
2478040	2480520	use the ing form of a verb.
2481960	2486440	So we can then put these together, objects and processes.
2486440	2489040	So here's an example of a machine.
2489040	2491840	This happens to be like a printer or copy machine.
2491840	2493480	It has a main switch.
2493480	2496840	The main switch has an attribute called main switch state,
2496840	2498440	which can be on or off.
2499680	2503680	The process of switching transforms, in this case,
2503680	2506520	the main switch state from on to off,
2506520	2508200	or we could go the other way.
2508200	2511280	And in order for this to happen, we have here,
2512280	2515200	this is actually slightly different than the instrument link.
2515200	2517160	This is a filled-in lollipop,
2517160	2519320	which is known as an agent link.
2519320	2521640	So the operator is an active agent
2521640	2523800	to carry out the switching process,
2523800	2525680	which changes the main switch state
2525680	2527960	from on to off or off to on.
2527960	2530480	And the main switch state is an attribute
2530480	2533400	of the main switch, right?
2533400	2536320	So transporting, this is another example.
2536320	2539120	Transporting changes the state of a person
2539120	2542160	from being here, location A,
2542160	2544480	to being there, location B.
2547240	2551240	So there are seven, huh, coincidence,
2551280	2556280	seven, seven object process links in OPM.
2557920	2562680	So P changes, the process changes the object,
2562680	2564160	say from state A to B,
2564160	2566800	that's the example we just looked at.
2566800	2568120	You can actually hide that.
2568120	2570920	If you're really not interested in all the states
2570920	2573080	and details, you hide the states.
2573080	2574640	You don't wanna see them.
2574640	2576040	And then you can replace that
2576040	2578520	with what's called the affect T link,
2578520	2580560	which is this two-sided arrow.
2580560	2583480	And all you know is that this process
2583480	2585720	is affecting that object, right?
2585720	2587560	And it's a two-sided arrow.
2587560	2589440	But you don't know exactly how,
2589440	2590760	but you know it's affected.
2591760	2594800	A result T link, so this is an arrow pointing
2594800	2597300	from the process to the object,
2597300	2600200	means that the process of transporting
2600200	2603160	produces emissions, right, that weren't there before.
2603160	2604980	So that's a result T link.
2604980	2606640	But the process of transporting
2606640	2609200	requires or consumes energy.
2609200	2611440	So the arrow is pointing from energy
2611440	2613560	into the transporting process,
2613560	2614960	because it's being consumed.
2616080	2617600	I did mention the agent link,
2617600	2619600	so there's an operator of a vehicle.
2619600	2622000	And this, you know, when we talk about
2622000	2625520	autonomously driving vehicles, big topic right now,
2625520	2627800	actually it was cool at EPFL this summer,
2627800	2631400	there's the autonomous shuttle right on the campus,
2631400	2633880	the electric shuttle, did anybody take that?
2633880	2637040	Did you guys try that shuttle this summer?
2637040	2638560	Yeah, did you like it?
2640040	2643120	No, I didn't, but the friend is working
2643120	2646760	in this kind of shuttle, like sitting for hours
2646760	2648560	waiting for people actually.
2648560	2651360	Okay, so fundamentally, I mean,
2651360	2653920	if you wanna think of this in OPM language,
2654880	2658120	driverless vehicle is basically eliminating this, right?
2658120	2661560	No longer needing an operator with an agent link
2661560	2664400	and replacing this with a piece of software,
2664400	2667340	which would be an instrument link.
2668340	2671140	So the instrument, the transporting process
2671140	2673940	requires a vehicle, and then we have what's known
2673940	2675740	as a conditional link.
2675740	2679020	So this process can only occur if this object
2679020	2680860	is in that particular state.
2680860	2683260	So this example here obviously ignores
2683260	2686020	the existence of credit cards.
2686020	2689900	So you can do the purchasing, purchasing,
2689900	2692980	the process of purchasing is conditional
2692980	2696940	upon the state of the object money
2696940	2701100	being in a state of enough for doing the purchase, right?
2702660	2707060	Okay, so here's an example of a little bit more complicated.
2707060	2711740	This is a level zero OPM diagram of a car, of a vehicle.
2711740	2715660	So you can see in the upper right is sort of a sketch
2715660	2718860	of a vehicle and it has these different attributes.
2718860	2723260	ED is engine displacement, height, ground clearance,
2723260	2725860	overall length, wheel base.
2725900	2728780	There's a trailer here with a towing capacity.
2728780	2731540	So the way you would interpret this
2731540	2734140	is that we have a transporting process.
2734140	2737740	That's our master sort of the highest level process.
2737740	2740420	And it changes the attribute location
2740420	2744460	for driver, passengers, and cargo from A to B, right?
2744460	2746820	And that's fundamentally where the value is
2746820	2749340	for the owner of the vehicle.
2749340	2752060	And then we can zoom in to the transporting process
2752060	2755980	and look at sub-processes, towing, propelling, and housing.
2755980	2757780	And if you think about what a vehicle does
2757780	2760940	at the highest level, right, it protects you,
2760940	2764540	it houses you, and it propels you, right?
2764540	2767820	Those are, and then you can break those into more detail.
2767820	2769140	And then on the left side here,
2769140	2773180	we have essentially the elements of form.
2773180	2775380	So the automobile, which is an instrument
2775380	2776740	of the transporting process,
2776740	2780140	can be decomposed into its major subsystems,
2780140	2782780	powertrain, chassis, body, wheels.
2782780	2784740	And each of those are characterized.
2784740	2786540	You see those attribute links?
2786540	2791660	Characterized by things like fuel capacity,
2791660	2793220	engine displacement.
2793220	2796580	This is the design domain we talked about last time, right?
2796580	2799940	Ground clearance, and so those are the design variables.
2799940	2801820	Those are the parts and assemblies.
2801820	2804020	And then on the right side, the processes,
2804020	2806580	the internal processes can also be characterized
2806580	2809820	by performance or functional attributes,
2809820	2814540	like towing capacity, fuel economy, acceleration.
2814540	2818020	PV stands for passenger volume and cargo volume.
2818020	2819180	And those are things, you know,
2819180	2821980	when you're comparing different vehicles to purchase,
2821980	2823060	you know, those are the things
2823060	2825140	you would compare vehicles against.
2825140	2827140	So those are the internal functions,
2827140	2829500	and then the functional attributes.
2829500	2832980	And then up here, there's the fuel and emissions
2832980	2834460	and safety-related issues,
2834460	2837300	which that's often where the governments intervene
2837300	2838740	and then regulate.
2838740	2842420	And, you know, this is sort of a highest level OPM
2842420	2843820	of a vehicle.
2843820	2845780	And then if you want to see more detail,
2845780	2847980	you would start drilling down into these.
2847980	2850180	And you'd have multiple levels of these,
2850180	2851940	like a higher key of these diagrams.
2851940	2853260	Yeah.
2853260	2856300	So here, what is the use of the,
2856300	2860660	or the meaning of the open arrows in the,
2860660	2862340	it looks like there's a couple different arrows here
2862340	2864940	than what we had in the other guy.
2864940	2866860	Are you talking about these guys?
2868100	2869060	No.
2869060	2870780	Oh, these here, yeah.
2870780	2873340	So they're, it's just a visual,
2873340	2875260	there's no distinction on the arrows,
2875260	2876780	whether they're filled in or empty.
2876780	2879140	That's just a kind of graphical thing.
2879140	2879980	Yeah.
2881340	2885420	Okay, so one of the, yes, Veronica,
2885420	2886500	do you want to push the,
2888260	2890460	how would you represent a process
2890460	2893200	that creates kind of a temporary state?
2894460	2895820	So if you were, if you're saying,
2895820	2897700	this is acted on an object and this changes
2897700	2898940	the form of the object,
2898940	2900620	but the object will ultimately return
2900620	2901580	to its original state,
2901580	2904540	kind of absent of a reversing process,
2904540	2907060	if it's a natural tendency for the object to return.
2908260	2910500	How would you represent that change?
2910500	2911580	Would you need to break it down
2911580	2915060	as a kind of a sub-process within the object or?
2915060	2916540	Right, so, I mean, and this,
2916540	2918140	there's sometimes there's multiple,
2918140	2919340	is there's non-uniqueness
2919340	2921100	in sort of representing the same thing,
2921100	2923540	but there's one process that brings you
2923540	2924980	to the temporary state.
2924980	2925820	Okay.
2925820	2927260	And then there would be a restoring process
2927260	2929380	that restores you back to the original state.
2929380	2932380	Does the process have to be a separate plan
2932380	2933820	within the system?
2933820	2935820	Because there are certain objects, right,
2935820	2936740	that have a tendency,
2936740	2939020	I'm thinking primarily kind of a chemical states
2939020	2941220	where reactions would happen naturally.
2941220	2942900	And it's kind of a specific thing,
2942900	2944220	but I was thinking about how you might model
2944220	2945060	different systems.
2945060	2947140	And I was thinking about the engine of the car,
2947180	2949540	just kind of how things might naturally return.
2949540	2952580	So do you have to describe the process explicitly
2952580	2957580	if it's not something that's inherently designed in,
2957660	2960220	if it's kind of a, if it will happen anyway?
2961540	2962860	I think, I wouldn't,
2962860	2965180	I wanna say you have to explicitly define that.
2965180	2966020	Okay.
2966020	2968860	So if it's a man-made process, so to speak,
2968860	2970980	then that's a process you want to happen.
2970980	2973900	And then if the restoring it back to some other state
2973900	2976620	is a natural process, well, it exists, right?
2976620	2980380	So it will restore the system to a prior state.
2980380	2982300	That process would also have to be modeled.
2982300	2984140	Is there a distinction between how you would indicate
2984140	2985980	a man-made process or a natural process?
2985980	2987020	Not fundamentally.
2987020	2987860	Okay.
2987860	2989300	And in fact, OPM's been applied
2989300	2991140	to modeling how a cell functions.
2991140	2993460	So there's some pretty recent work on,
2993460	2994860	cells are incredibly,
2994860	2998180	the biological engineering is just really complex.
2998180	3000940	So it's some really recent work on describing even,
3000940	3004820	the RNA and cell division using very much this language.
3004820	3005660	Okay.
3005660	3008500	So it doesn't matter whether it's an artificial process
3008500	3009900	or a natural process.
3009900	3010740	Thank you.
3010740	3012060	Okay, let me go a couple more minutes
3012060	3013340	and then we'll take a short break
3013340	3016460	and then we'll talk about SysML and Modellica.
3016460	3021460	So the key thing in OPM is there's only one type of diagram
3021500	3024820	and there's also natural language that gets auto-generated.
3024820	3027120	And I'll show you this very quickly in the tool.
3027120	3030780	So as you can imagine, as you're working on real systems,
3030780	3033580	you know, these diagrams, if you showed them on one,
3033580	3036740	one sort of level, you'd have thousands of objects
3036740	3038820	and links, it would be a mess, right?
3038820	3041020	So how does OPM handle complexity?
3041020	3043060	There's three fundamental mechanisms.
3043060	3045860	One is known as folding and unfolding.
3045860	3046780	What does that mean?
3046780	3050980	It's basically related to the structure.
3050980	3054620	So folding, unfolding means that higher level objects,
3054620	3057100	you can show the decomposition of the objects
3057100	3058320	or you can hide it.
3058320	3060580	That's known as folding and unfolding.
3060580	3064780	Then the second one is called in-zooming or out-zooming.
3064780	3067060	And so here's an example of a,
3067060	3070780	here's a process and an instrument and an affectee,
3070780	3072420	right, that's affected by the process.
3072420	3076880	I wanna know what are the sub-processes in that process?
3076880	3078980	So you can zoom into this process
3078980	3082040	and it will expose the sub-processes
3082040	3083540	that are happening inside.
3083540	3084860	That's known as in-zooming
3084860	3087540	and then going back the other way is called out-zooming.
3088580	3090380	And then the third one I've already mentioned,
3090380	3094580	which is that states can be expressed or suppressed
3094580	3097040	or hidden depending on your interest
3097040	3099380	in what states of the system you wanna look at.
3100940	3104500	So here's the sort of level zero OPM of our refrigerator.
3104500	3106940	I said that was kind of our case study.
3106940	3111300	So how does the refrigerator work at the sort of level zero
3111300	3114620	is that's what the stakeholder with the customer sees.
3114620	3116940	Don't care about the details of what's happening
3116940	3118660	in the refrigerator.
3118660	3123660	So we have food and we'll get back to this I think next week
3123820	3126900	in the kind of creativity concept generation.
3126900	3129200	Why do we have refrigerators fundamentally?
3130620	3134220	If you've heard this before, you keep quiet.
3134220	3137580	Maybe EPFL, why do we have refrigerators?
3142340	3143340	Any ideas?
3147220	3148060	Go ahead.
3148900	3150180	Keep food cold.
3150180	3153980	Yeah, well, if you're a beer drinker,
3153980	3156300	you want cold beer, right?
3156300	3159060	But if you really think about it deeply,
3159060	3161540	that's not really the primary reason, right?
3161540	3164740	The primary reason is this state change,
3164740	3166500	their shelf life, right?
3166500	3168860	So the primary reason why you have refrigerators
3168860	3173100	is to extend the shelf life of the food, right?
3173100	3177460	So speaking as a systems architect, system engineer,
3177460	3182460	a refrigerator is a food spoilage rate reduction device.
3183860	3184860	You see that?
3184860	3188420	So the attribute of the food is the shelf life
3188420	3191100	and we're gonna extend the shelf life of the food.
3191100	3194340	That is, if you think about it sort of architecturally,
3194340	3195740	that's why we have refrigerators.
3195740	3199220	But I agree with you on the cold beer, right?
3199220	3201960	We all agree we want cold beer, not warm beer.
3201960	3204740	So you're right, you're right too.
3204740	3207240	So the refrigerator essentially is an instrument
3207240	3210040	of extending the food shelf life.
3210040	3212520	So the food is the operand.
3212520	3214320	The food is the operand.
3214320	3216520	The extending of shelf life is what we call
3216520	3218960	the primary value delivering process.
3218960	3220620	That's where the value is.
3220620	3224320	The refrigerator itself is the product system.
3224320	3228460	And then the operator sets the thermostat setting
3228460	3231160	at which temperature the refrigerator should be.
3231160	3233920	And then here we have the primary operating process,
3233960	3237800	which is what allows us to keep the temperature
3237800	3239720	of the food at that level.
3239720	3242480	And in order to do this, we consume electrical power,
3242480	3245800	we produce waste heat, and we also require
3245800	3249160	or we convect that waste heat to the exterior air
3249160	3250620	at a certain temperature.
3251600	3254800	How well do refrigerators work in a vacuum chamber?
3259920	3261640	They don't, right?
3261640	3262480	They don't.
3263120	3265920	Well, I guess you could radiate the heat a little bit,
3265920	3268160	but they're not gonna work very well.
3268160	3269760	You're not gonna have conduction, right?
3269760	3272200	Because you're sort of in the middle of the vacuum chamber.
3272200	3273520	You're not gonna have convection,
3273520	3274720	so you only have radiation,
3274720	3276920	and it's not gonna work very well.
3276920	3280320	So the exterior air is important
3280320	3282320	for the refrigerator to work.
3282320	3285600	So then you say, well, okay, that's fine, I buy that.
3285600	3288500	But now I wanna really know, how does it really work?
3288500	3291840	So you say operating, the refrigerator is operating,
3291840	3296720	but I wanna do in-zooming and understand how is it operating?
3296720	3298840	So what's the key to refrigeration?
3300080	3302940	What's the magic word there, or two magic words?
3307640	3308920	Yep, that's part of it.
3308920	3311720	That's just a sliver of it.
3311720	3313240	Heat exchange is part of it.
3313240	3317560	So the magic word is carno cycle, right?
3317560	3320680	So here's a little graphic that sort of gets into it.
3320680	3325520	So the carno cycle is actually a thermodynamic concept, right?
3325520	3330040	Where you're compressing essentially a refrigerant,
3330040	3332800	you're a coolant is being compressed,
3332800	3335920	absorbs the heat from the inside,
3335920	3339480	and then expands and condenses and radiates that,
3339480	3342400	or convects that heat to the outside.
3342400	3344240	So here's a, I don't know if you remember
3344240	3345720	your thermodynamics, right?
3345720	3348240	This is a classic PV diagram.
3348240	3350760	You've got the four legs of the carno cycle,
3350760	3352720	and actually what's really nice here,
3352720	3355340	so we're going through this counterclockwise,
3355340	3359080	what's really nice about it is that every leg of the carno
3359080	3361960	cycle is one of our processes, right?
3361960	3366200	So compressing is this leg here from D to B,
3366200	3370000	condensing is from B to A, expanding from A to E,
3370000	3372720	and then evaporation happens from E to D.
3372760	3377960	So the carno cycle can be decomposed
3377960	3380640	into four sub-processes, right?
3380640	3383880	These are the internal processes in the system
3383880	3386200	that are governed by physics.
3386200	3389120	So if we take that operating process
3389120	3391400	that we looked at before, we can actually
3391400	3395400	zoom in and see the sub-processes emerging.
3395400	3398720	And so in cooling, we have those four expanding,
3398720	3400920	evaporating, compressing, condensing,
3400920	3403000	but I'm adding the absorbing process,
3403000	3404320	which is that the heat then needs
3404320	3407400	to be absorbed by the exterior air.
3407400	3408800	We have to power the device.
3408800	3411720	You can decompose that into grounding, protecting,
3411720	3415840	supplying, regulation, keeping it at the set point.
3415840	3419760	You can decompose that process into sensing, switching,
3419760	3422040	and setting the set point.
3422040	3423520	And then we have supporting, which
3423520	3427000	is we need to be open and closing the refrigerator,
3427000	3429640	retaining it, and then connecting all the pieces.
3430160	3434120	At level minus 1, we had one process at level 0,
3434120	3435480	which was operating.
3435480	3437640	The refrigerator is operating.
3437640	3440160	And then as we zoom in to level minus 1,
3440160	3443440	four processes appear, powering, regulating, cooling,
3443440	3444560	and supporting.
3444560	3448880	And then at level minus 2, we have 15 sub-processes.
3448880	3453720	So this is a view at level minus 1,
3453720	3457160	our four sub-processes, cooling, powering, regulating,
3457160	3460840	supporting, and then we can zoom in more.
3460840	3463760	So here's the general idea, and we've
3463760	3465880	looked at many systems over the years,
3465880	3469880	that most cyber-physical systems, or it says
3469880	3472880	optomechanical here, but I really mean it more generally,
3472880	3475680	have this kind of OPM structure.
3475680	3478120	On the right side, we have the output
3478120	3480880	that the customer, the stakeholder, cares about,
3480880	3482040	the operand.
3482040	3484800	We have a set of specialized processes,
3484800	3487600	and these can be often organized in a cascade.
3487600	3489240	And then we have supporting processes,
3489240	3491880	like powering, connecting, controlling,
3491880	3495920	that provide support for the specialized processes.
3495920	3502800	Most systems that we've seen have this generic architecture.
3502800	3504760	How do you generate an OPM?
3504760	3507040	Fundamentally, you can do a top-down.
3507040	3509200	So you start with your stakeholders.
3509200	3511600	That's what we did in the first lecture.
3511600	3513960	Where's the value?
3513960	3517200	You start thinking about requirements, what functions,
3517200	3520040	how well the functions should be performed,
3520040	3521560	and you sort of go down.
3521560	3524000	Or if you already have a system, you can actually
3524000	3526000	reverse engineer that system.
3526000	3531320	And from bottom up, we started doing for the Mr. Sticky,
3531320	3534880	and that's fundamentally reverse engineering.
3534880	3539320	So just for time, I'm going to skip this demo.
3539320	3541600	But what I will do is I will post a video.
3541600	3544520	I'm going to make a little video with the OpCat demo
3544520	3548000	and post that to Stellar, so you can sort of watch that.
3548000	3551720	So this is one of the, it's still not super mature,
3551720	3554720	but it's a Java-based program called OpCat
3554720	3561400	that allows you to generate object process diagrams
3561400	3563200	in its computer-supported environment
3563200	3567120	and store them in an XML format and so forth.
3567120	3569040	It allows you to create a hierarchy.
3569040	3570680	And the other thing that's very cool,
3570680	3572800	it auto-generates text.
3572800	3576760	So the text is called OPL, Object Process Language.
3576760	3580080	And right now, you can go from the graphics to the text,
3580080	3581800	but you can't go the other way.
3581800	3584280	And so there are complete sentences.
3584280	3587200	It's not like an exciting novel when you read it,
3587200	3590480	but it is semantically precise.
3590480	3593960	So we're going to switch to SysML.
3593960	3595800	We're going to take a very short break.
3595800	3598120	Are there any questions about OPM?
3598120	3599640	In the system architecture class,
3599640	3602960	we spend like five, six lectures on OPM,
3602960	3605280	and you get to do detailed exercises.
3605280	3607680	We kind of don't have time for this in this class,
3607680	3610040	but hopefully you've seen what it is.
3610040	3613360	And if, you know, I've wetted your appetite for OPM,
3613360	3616200	then the goal's been met.
3616200	3617640	Any questions about OPM?
3621000	3622960	Is it pretty clear?
3622960	3625720	All right, so let's take, yes?
3626160	3628680	Compared to Modellica, because I've
3628680	3631960	seen one of the links that this OPM is just
3631960	3633480	for describing the system there.
3633480	3637160	It's not for making calculations or simulations.
3637160	3638280	That's correct.
3638280	3640400	There are the latest versions of OPM.
3640400	3642640	You can do like a logical simulation.
3642640	3646120	So you can say, OK, this process enables and does this thing.
3646120	3647960	So it's kind of a discrete logical,
3647960	3652080	but usually it's not used for any mathematical calculations.
3652080	3654520	It's really the purpose of OPM is really
3654520	3658200	to support conceptual design, early conceptual design.
3658200	3658720	That's correct.
3662440	3664120	OK, Mark.
3664120	3667560	So just a couple words about Mark.
3667560	3670800	He's a doctoral student right now in the space systems lab.
3670800	3675280	He's been working a lot on an instrument called Rexis.
3675280	3678600	I guess you're the chief system engineer, right, for Rexis.
3678600	3681360	And that was also the topic of his master's thesis.
3681400	3684880	So Mark really knows what he's talking about.
3684880	3687160	He knows SysML quite well.
3687160	3689080	And thanks for doing this.
3689080	3692080	OK, so let me start by giving kind of a high level overview
3692080	3694440	of what SysML is and what it aims to do.
3694440	3696160	So it's similar to OPM, but there
3696160	3699200	are a couple important differences.
3699200	3702400	SysML, as Ollie said, it kind of is an extension
3702400	3704800	or inherits a lot from UML.
3704800	3708560	And its aim is to really provide a language that
3708560	3712200	enables you to capture all the different aspects of information
3712200	3714280	about a system in one place.
3714280	3716720	And this concept of single source of truth
3716720	3718440	is something that I'll kind of try and emphasize
3718440	3719680	through my presentation.
3719680	3723200	The idea is if all your information is in this one model,
3723200	3725800	then communication is easy.
3725800	3728680	There's no ambiguity between versions.
3728680	3730840	Everyone knows where to go to get the most up to date
3730840	3733080	and correct piece of information.
3733080	3737160	So that's one of the emphases of SysML.
3737200	3740480	SysML is a graphical language similar to OPM.
3740480	3742320	It's defined in terms of diagram types
3742320	3745120	that I'll go into in a second and has more than just one diagram
3745120	3747040	type as compared to OPM.
3747040	3748480	But basically, it aims to do things
3748480	3751240	like capture functional behavioral models,
3751240	3753160	capture performance models, capture
3753160	3755840	the structural topology of your system, the parts of your system,
3755840	3757760	and how they're all interconnected.
3757760	3759480	And any other engineering analysis model
3759480	3761680	is one of the big emphases with SysML
3761680	3764160	is integration with external analysis tools.
3764160	3767960	So if you have a thermal tool, a structural tool,
3767960	3769680	electronics tool, something like that,
3769680	3772560	integrating this informational, descriptional model
3772560	3775720	with that analysis model and enabling,
3775720	3778240	making it easy to transfer information
3778240	3780520	from your descriptive model to your analysis model,
3780520	3782400	do an analysis, and then incorporate those results
3782400	3785680	back into your descriptive model is one of the things
3785680	3787320	that SysML really is all about.
3787320	3789560	And another thing, another difference compared to SysML
3789560	3793120	from OPM is it incorporates requirements pretty explicitly.
3793120	3794400	And that's one of the other areas
3794400	3795840	that people are really interested in
3795840	3798000	is if you have good modeling of requirements,
3798000	3800320	what sort of information can you glean about your system
3800320	3803080	that you couldn't otherwise?
3803080	3804160	How do I advance this slide?
3807160	3808120	Oh, there we go.
3808120	3809440	OK.
3809440	3812440	So as I said, SysML is composed of diagrams.
3812440	3814840	I'll go into in a second what each diagram, what
3814840	3817160	all the diagram types are and what their intent is.
3817160	3819480	But here's kind of a high-level overview.
3819480	3821040	It might be a little bit difficult to read.
3821040	3822600	So at the top, you have a system model.
3822600	3825360	You have requirements diagrams, behavior, structure,
3825360	3826880	and parametrics.
3826880	3828160	Within requirements, there's actually
3828160	3830280	a specific requirements diagram that's
3830280	3832720	supposed to represent the relationship between requirements
3832720	3833240	in your system.
3833240	3835080	I'll show you an example of that.
3835080	3838320	In behavior, there are diagrams that describe
3838320	3840000	kind of the activity of your system,
3840000	3842560	the sequence of events that may happen.
3842560	3844000	There's a state machine diagram.
3844000	3845840	If you want to model your system as a states
3845840	3848920	and transition between those states, things like that.
3848920	3851200	In the structure, there's diagrams
3851200	3853240	that go over the decomposition of your system, what
3853240	3855880	is your system, and what parts make up your system,
3855880	3859720	both the logical decomposition and the physical decomposition.
3859720	3862120	And then there's a topology, how are they all connected,
3862120	3865000	where the interfaces, where the characteristics of the interfaces,
3865000	3866200	things like that.
3866200	3871120	And then parametrics, which is kind of adding constraints
3871120	3874200	and numbers to all these things, whether they be logical constraints,
3874200	3876160	mathematical constraints, things like that.
3876160	3879960	Similar to OPM, SysML has no built-in analysis capability,
3880000	3885280	so you can't run a model or calculate an equation in SysML.
3885280	3886400	You can't really do that.
3886400	3894480	But very frequently, the tools that implement SysML that I'll show you
3894480	3897240	have that kind of analysis capability built into the tool
3897240	3898480	as opposed to the language.
3898480	3902880	So you can do things like use a parametric diagram
3902880	3905720	with a bunch of equations to create a system of equations
3905720	3908360	that you then can solve, whether it be in the tool,
3908360	3910440	or you can move it to an external tool like Mathematica
3910440	3912720	or something, solve it, and then bring that information back
3912720	3915040	into your system.
3915040	3919920	You also can do kind of sequence-based computation
3919920	3923080	if you have a activity diagram that says, first, you
3923080	3924560	have to build this part of your system
3924560	3925760	and then this part of your system.
3925760	3927760	There's things in sequence, things in parallel.
3927760	3931000	You can run simulations like that, where it's all about,
3931000	3934160	have you done everything you need to do to get to the next step,
3934160	3935840	things in a more logical flow as opposed
3935840	3937480	to actually mathematical equations.
3937480	3939360	You can do those sorts of computations as well.
3941800	3944280	One note is that these diagrams, although they
3944280	3946080	are the main way to define your system
3946080	3950000	and interface with the model, are not the model themselves.
3950000	3953080	So you can create links between diagrams
3953080	3955560	if an element shows up in one diagram
3955560	3958240	and that element shows up in another diagram.
3958240	3959440	That's the same element.
3959440	3960800	If you make changes in one diagram,
3960800	3962720	that's going to propagate to all your diagrams.
3962720	3965000	So there's kind of a database back into this whole,
3965000	3967760	into the model that encompasses all the information.
3967760	3970320	So instead of having a bunch of isolated block diagrams,
3970320	3972760	they're really just views into this model that's
3972760	3974080	hidden in a back-end database.
3979840	3983440	OK, so I'll talk a little bit about the applications of ZISMO.
3983440	3984800	First is requirements engineering.
3984800	3986560	As I said, when you can explicitly model
3986560	3988600	requirements in the relationship between requirements
3988600	3991200	in your system, you can do a lot more.
3991200	3992840	The way that it's typically done nowadays
3992840	3994880	is with tons of documents.
3994880	3996680	I'm not sure if you've ever actually developed a system,
3996680	3999200	but there's an ungodly amount of documents.
3999200	4001200	I've experienced that firsthand.
4001200	4002480	It's a real pain.
4002480	4004600	There are tools like DOORS that will enable you to link
4004600	4006200	requirements to other requirements and things
4006200	4008440	like that that help you manage your requirements.
4008440	4010280	But what if you had a really explicit tie
4010280	4012040	between your requirements and your system?
4012040	4013440	You can actually represent in ZISMO,
4013440	4015120	and I'll show you a little bit about this.
4015120	4017840	You can represent in ZISMO a textual requirement.
4017840	4020560	The mass of your system must be less than five kilograms
4020560	4021560	or something like that.
4021560	4023840	You can tie that requirement directly to the mass property
4023840	4024800	of your system.
4024800	4028280	You can kind of envision you can start building constraints.
4028280	4030120	Requirements aren't just textual statements.
4030120	4032120	They're actually constraints upon properties of your system.
4032120	4035400	Those are the types of things you can start to do with ZISMO.
4035400	4036520	You have a question?
4036520	4048880	Yeah, so that isn't something that's built into the language,
4048880	4051600	but that is something you can do with basically there's
4051600	4055280	a whole API, and you can interface with the model.
4055280	4057160	I'll show you this, actually, in my demo.
4057160	4059560	But you can build in rules and constraints that say,
4059560	4062120	check, for example, that all my requirements, at least,
4062120	4063840	have they been defined are satisfied.
4063840	4065240	You can run that check, and it will tell you
4065240	4066520	have they been satisfied or not.
4066520	4067880	And that's something that's really powerful
4067880	4071240	that you can't really do with existing kind of techniques.
4071240	4072240	Yeah.
4072240	4073480	Thank you.
4073480	4076600	And can you also, let's say, for example, requirement
4076600	4079200	changes, like the mass of your system
4079200	4081480	has to be this much as opposed to this much,
4081480	4084560	then would it go through and check until you have to now look
4084560	4088120	at this, this, and this, and then that effect?
4088120	4090280	So you're getting down in the weeds.
4090280	4093520	That's something that'd be awesome if you could do, right?
4093520	4095040	That really, again, that's not something
4095040	4097200	that SysML enables you to do natively,
4097200	4099440	but it gives you the language and the syntax
4099440	4101720	to be able to write queries that give you
4101720	4102520	that type of information.
4102520	4104720	That's kind of where the cutting edge is right now is,
4104720	4105560	can we do that?
4105560	4107560	Can we get that type of information from a system
4107560	4108200	and model?
4108200	4110600	That's something I'm really interested in for my PhD thesis.
4110640	4113000	So yeah, that's something that I think is possible
4113000	4114920	and would be really great to have in the development
4114920	4115760	process of a system.
4118800	4120800	So the next bullet here is on system description.
4120800	4123000	So actually, one of the fundamental questions
4123000	4126080	is, how do you describe a domain-specific system
4126080	4127360	within SysML?
4127360	4130000	I'll show you that SysML has a pretty strong notion
4130000	4131920	of inheritance in classes and things like that.
4131920	4133560	It's obviously oriented.
4133560	4136680	And so one of the questions is, I'm in the space system,
4136680	4139320	so how do you describe a spacecraft in SysML?
4139320	4142360	SysML is very general, but how do you actually represent,
4142360	4144880	for example, a C and D H system in SysML?
4144880	4149680	What are the types of attributes that are typically found?
4149680	4150920	How do you represent that?
4150920	4152880	How does it interface with other parts of your system?
4152880	4155240	Those type of questions, that's another active area
4155240	4157440	of research, domain-specific modeling.
4157440	4159920	And then finally, as I said, integration
4159920	4161200	with external analysis tools.
4161200	4163200	So there's quite a lot of papers in the literature
4163200	4168560	about going from a SysML model to MATLAB, to SDK,
4168560	4171200	to thermal desktop.
4171200	4173960	External modeling tools, taking that information out
4173960	4176960	of the model, doing an analysis, putting it back in the model.
4176960	4179080	And actually, I think Nara's going
4179080	4182840	to talk about Simscape, which is a kind of analysis tool,
4182840	4183960	external analysis tool.
4183960	4185720	And there's actually been papers written on how do you take
4185720	4188600	SysML information from a SysML model, pull it into Simscape,
4188600	4190280	process it, and put it back in the model.
4193920	4196680	OK, so let's talk about the diagrams.
4196720	4199280	There are nine types of diagrams in SysML.
4199280	4201280	And I'll try and just give you a brief explanation
4201280	4201840	of what they do.
4201840	4203360	I won't go into the syntax for all of them,
4203360	4205200	because there's quite a bit of detail in the syntax.
4205200	4207960	But I'll show you some examples of a couple of them.
4207960	4209120	So I'll go from left to right.
4209120	4212400	So there's two main classes, behavior and structure,
4212400	4214040	similar to OPM.
4214040	4217120	In the behavior diagram, you have a behavior diagram
4217120	4217600	category.
4217600	4219920	You have activity diagrams, which are basically
4219920	4221520	represent flows of activities.
4221520	4224840	So you do this, then you do this, then you do this.
4224840	4226880	Those can be tied to system elements.
4226880	4229840	If this system element has this sort of function or property
4229840	4232680	or performs this operation on another part of the system,
4232680	4235080	you can represent that link as well.
4235080	4239760	There's a sequence diagram, which is more about logical
4239760	4240200	ordering.
4240200	4244080	So if you have, for example, a multi-threaded software system,
4244080	4247360	and you have different threads that may need different other
4247360	4249880	threads to communicate with them or finish their computation
4249880	4251800	before that thread can execute things like that,
4251800	4254480	you can do that interfacing between
4254520	4259720	different threads of activities in a sequence diagram.
4259720	4263440	This is one of the diagram types that was inherited directly
4263440	4263920	from UML.
4263920	4267720	So it's a very strong software element to that diagram.
4272040	4273200	There's a state machine diagram.
4273200	4275040	So obviously, state machines are very powerful.
4275040	4276440	If your system has various states,
4276440	4278040	if things in your system have various states,
4278040	4280240	you can represent that in a state machine diagram
4280240	4282880	and then talk about what are the criteria for transitioning
4282880	4283520	between states.
4283520	4286560	What would trigger or cause a transition between states?
4286560	4288760	What are guards that must be met before you
4288760	4290240	can transition states, things like that,
4290240	4292880	that we'd represent in a state machine diagram.
4292880	4296000	These type of diagrams are very powerful for describing things
4296000	4298280	like concept of operations.
4298280	4299920	So there has been some work.
4299920	4302400	I did an internship at JPL a couple of summers ago,
4302400	4304720	and they were trying to build up this capability
4304720	4307000	to model a concept of operations for a spacecraft.
4307000	4310160	So what are all the power modes of everything?
4310160	4311120	What are the time?
4311120	4313040	It spends this amount of time in this power mode,
4313040	4315640	and it transitions here over, for example,
4315640	4316960	like a given orbit of a spacecraft.
4316960	4319160	That's the thing that you can do with this set
4319160	4321200	of behavior diagrams.
4321200	4322360	And then use case analysis.
4322360	4324800	Again, it's mostly focused on early concept development,
4324800	4327120	stakeholders, how do they interface with the system?
4327120	4328800	Where do they derive value?
4328800	4331640	How does the user interact with the system, things like that?
4331640	4334640	That's what you put in the use case diagram.
4334640	4338000	Going over to structure, the block definition diagram
4338000	4341000	is where you define the structure of your system.
4341040	4343280	So the logical or physical decomposition,
4343280	4344680	I'll show you an example of this.
4344680	4346200	So every system is a spacecraft.
4346200	4348440	It has various subsystems.
4348440	4349640	If you want to decompose it logically,
4349640	4352080	it has a thermal subsystem, a structure subsystem,
4352080	4354200	ADCS subsystem, things like that.
4354200	4355520	You can also decompose it physically.
4355520	4357640	So your spacecraft has solar rays.
4357640	4358640	It has instruments.
4358640	4360560	It has thrusters, things like that.
4360560	4361960	You can represent those types of things
4361960	4363600	in a block definition diagram.
4363600	4365000	And then internal block diagram is
4365000	4366840	where you describe the ties with the interfaces
4366840	4368720	between all the components of your system.
4368720	4370360	And these can be at varying different levels
4370360	4373360	of abstraction, as I'll show you.
4373360	4375720	Parametric diagram is kind of a sub-diagram type
4375720	4377080	of the internal block diagram.
4377080	4379640	So you can, again, put constraints, mathematical, logical,
4379640	4381280	things like that on your interfaces
4381280	4384680	and begin to build up the infrastructure for doing
4384680	4386480	computation in the model.
4386480	4390160	And then a packaging diagram is not terribly important.
4390160	4392280	It's really focused on the organization of your model,
4392280	4393240	how do you scope things.
4393240	4395800	It's kind of a modeling diagram, as opposed
4395800	4397600	to a representation of your system.
4397600	4399560	Then last of all is a requirements diagram up top.
4399560	4401160	So again, I'll show you a good example of this,
4401160	4403160	but that's where you represent how your requirements are
4403160	4405160	related to your system.
4405160	4407000	And then you can see here what's been modified
4407000	4410000	and what's been taken from UML and the new diagram types
4410000	4412000	of requirement in parametric.
4412000	4413520	There were a couple of diagram types
4413520	4416520	that were eliminated from UML that were pretty software
4416520	4417560	specific.
4417560	4419680	I think there is one called the deployment diagram,
4419680	4423120	like how has your software been deployed across various servers
4423120	4424200	or users, things like that.
4424200	4427200	That's not really, that's a pretty software specific thing.
4427200	4429040	So in a general system, you might not
4429080	4433280	care about that all that much, so that diagram was removed.
4433280	4436520	So let me quickly go over some of the syntax.
4436520	4439280	So this is an interface block diagram, an IBD.
4439280	4441080	This is the type of diagram that I find
4441080	4446160	is really interesting, representing these interfaces.
4446160	4448160	So here's the system engineering ontology
4448160	4449080	we typically talk about.
4449080	4452200	So these are, this is basically a model of an avionics board.
4452200	4454880	So you have things like voltage converters.
4454880	4457600	You have memory, the volatile, non-volatile.
4457600	4461440	We have a FPGA, which is our main computational unit.
4461440	4463760	We talk about these as being parts of a system
4463760	4465400	in terms of a system engineering ontology.
4465400	4468920	Then these are these interfaces or these lines right here.
4468920	4470760	So in SysML, the way we talk about it
4470760	4475520	is these are part properties of the system.
4475520	4478280	It's kind of like an instantiation type of thing.
4478280	4480240	What we're saying is all of these parts
4480240	4482120	can represent independent of each other.
4482120	4484840	And then you define a property of that part
4484840	4487120	as being part of a different part,
4487120	4488840	if that makes any sense at all.
4488840	4490560	So for example, this is a board, right?
4490560	4493120	This main electronics board is this whole block.
4493120	4495560	And then it has sub-blocks within this block,
4495560	4497880	which represent the sub-parts that make up the board.
4497880	4502920	These are called part properties of this overall block.
4502920	4505120	We have these green little boxes, which are called ports.
4505120	4507840	And again, that's to support this kind of system
4507840	4508760	independent modeling.
4508760	4511040	So you can model like a voltage converter,
4511040	4512840	independent of any type of system.
4512840	4515080	It has maybe an input voltage and output voltage.
4515080	4517400	You can define what ranges those are, things like that.
4517400	4520000	And you can model those interfaces using ports.
4520000	4523240	And then these connectors, which are called connectors
4523240	4525400	in SysML, which represent the interfaces,
4525400	4528520	represent how each part is tied into the larger system.
4528520	4530360	And you could, for example, check that you
4530360	4531840	don't have any empty ports.
4531840	4534360	If a part needs an input voltage,
4534360	4536360	you could run a script that checks
4536360	4539800	that all the parts have all their ports satisfied.
4539800	4543920	That's something you can do with SysML.
4543920	4545480	OK, so before I get into the case study,
4545480	4547920	I want to talk a little bit about what you're going to see.
4547920	4549400	As I said, I work on something called
4549400	4552240	REXIS, which is the Regolith X-ray Imaging Spectrometer.
4552240	4553960	It's an X-ray spectrometer that's
4553960	4556360	flying on NASA's OSIRIS-REx asteroid sample return
4556360	4557360	mission.
4557360	4560680	I've been working on it since 2011, when I was a senior here,
4560680	4563560	all throughout my master's and then now for my PhD.
4563560	4565480	Basically, we're going to measure X-rays that
4565480	4567320	are fluoresced from the asteroid surface
4567320	4569840	in order to tell what the elemental composition
4569840	4570640	of the asteroid is.
4570640	4572640	So that's our main science goal.
4572640	4576600	And that will basically enable us to categorize
4576600	4578800	where the asteroid is within the different meteorite types
4578800	4580600	that have been defined on the ground based
4580600	4583240	upon existing meteorite samples.
4583240	4585720	So what I did from a master's thesis
4585720	4588400	was model the design history of REXIS.
4588400	4592040	So how has our design evolved from the very beginning, where
4592040	4595440	it was very open-ended, very abstract,
4595440	4599000	and you'll see this, to the current design, which
4599000	4604400	current in this case was CDR, which was over a year ago now.
4604400	4605800	Right now, the current state of REXIS
4605800	4608040	is we're almost ready to mount to the spacecraft.
4608040	4610640	So it's very exciting.
4610640	4613080	Just to give you an idea of a timeline,
4613080	4614760	this is something I'm sure Ollie will
4614760	4616440	talk about in this course, is the flow
4616440	4618080	through the system development life cycle.
4618080	4621360	So we have system requirements review back in January of 2012.
4621400	4624400	System, I think it's definition review.
4624400	4628160	April 2012 preliminary design review, January of 2013,
4628160	4631040	and then critical design review, February of 2014.
4631040	4634000	So I created models at each of these design points in SysML
4634000	4636440	and looked at what are the lessons we could have learned.
4636440	4638040	We didn't use SysML in REXIS.
4638040	4639600	I was kind of looking back historically,
4639600	4640960	what if we had used it?
4640960	4645800	Could we have designed our system better in any sort of way?
4645800	4647920	So here is kind of a CAD representation
4647920	4648920	of how our design evolved.
4648920	4650640	And I think you can kind of get the idea.
4650640	4654280	Back at SRR, we didn't really know what they would look like.
4654280	4656000	We didn't know what the interfaces would be.
4656000	4658320	We didn't know what all the parts would be.
4658320	4660280	We had a little more development for SDR.
4660280	4662200	You can see there's more arrows.
4662200	4664200	The CAD is a little bit more detailed.
4664200	4666880	For PDR, we had even more detail.
4666880	4668640	This was actually like a buildable design.
4668640	4670800	This turned out to not even be buildable.
4670800	4674600	And then we had more evolution between PDR and CDR
4674600	4676680	to get to pretty much where the design is.
4676680	4679160	There's actually been some evolution after this as well.
4679760	4682400	Sometimes happens with a new system.
4682400	4684560	But you can see just graphically kind of the increase
4684560	4686640	in level of detail and level of fidelity
4686640	4689640	of the state of our system throughout its development cycle.
4689640	4692760	And I'll show you that and how that looks in the system model
4692760	4694840	as well.
4694840	4697000	So one of the things you can do if you have a system model,
4697000	4698840	as I talked about, you can run queries on it
4698840	4701160	and pull out information that's very difficult or impossible
4701160	4703320	to get with our current development practices.
4703320	4706520	So this is just looking at the different sub-assemblies
4706520	4707320	within REXIS.
4707320	4709600	What are the number of parts in each of the sub-assemblies?
4709600	4711920	So you can see the general trend is up for all of them
4711920	4713360	as you would expect.
4713360	4715520	Some jump up very high.
4715520	4717760	Some kind of stay basically where they were.
4717760	4719160	But in general, they all increase.
4719160	4720560	And this is something you might be
4720560	4722960	able to do with looking at a parts list or something
4722960	4724640	like that with current methodologies.
4724640	4726480	But it'd be very hard to get this information, which
4726480	4728440	is the number of ports per assembly.
4728440	4729840	So each interface has two ports.
4729840	4731400	So these numbers divided by two basically
4731400	4733160	equal the number of interfaces that we have
4733160	4734320	in each sub-assembly.
4734320	4736880	You can see, again, there's a general trend of increasing.
4736920	4739760	Increasing number of ports as you go through the life cycle.
4739760	4742040	So this is a piece of information
4742040	4744320	you might want to use if you want to manage the complexity
4744320	4744800	of your system.
4744800	4747040	And you say, this sub-assembly is getting
4747040	4749240	way too many interfaces, way too many parts.
4749240	4750120	It's way too complex.
4750120	4751920	We need to think about how we've logically
4751920	4754160	arranged our system and maybe how can we rearrange it
4754160	4756840	to make it more understandable and easier to work with.
4756840	4758720	And then you can divide the two.
4758720	4760440	And you end up looking at how many
4760440	4764040	this is ports per part in each sub-assembly at each
4764040	4765360	of the design reviews.
4765360	4767760	And you can see trends here, too, which are interesting.
4767760	4769240	So you can see in the beginning, we
4769240	4770160	didn't really know what we were doing.
4770160	4772400	Some of these had a lot of ports per part.
4772400	4773880	Some of these had very few.
4773880	4776640	They all ended up stabilizing kind of between the three
4776640	4778840	and five ports per part range.
4778840	4780840	And then you can look at the literature and say, well,
4780840	4784120	typically systems tend to be between five and six
4784120	4785240	ports per part.
4785240	4786200	So what does that mean?
4786200	4788440	Does that mean that our system, that I didn't model it
4788440	4788920	correctly?
4788920	4789680	That's one possibility.
4789680	4792880	It didn't model to the lowest level of fidelity possible.
4792920	4795640	Does it mean that our system is too simple?
4795640	4797280	Does it mean that we're missing something
4797280	4798640	that we haven't thought about?
4798640	4800760	Does it mean that our system, which
4800760	4803280	was intended to be simple and cheap and implementable by
4803280	4805800	students, is actually achieving that goal because it's
4805800	4807600	beneath what you would typically expect?
4807600	4809400	Those are the type of questions you can ask with this data.
4809400	4811440	But this data is not easy to get with the current
4811440	4812720	methodologies.
4812720	4815480	So this kind of very simple query you can do gives you
4815480	4819400	power on managing complexity in your system.
4819400	4824600	So let me now transition quickly to the demo.
4824600	4825360	Let's see.
4845680	4846800	There's no sound.
4846800	4851080	I know, but I need to sync it up and I need sound to do that.
4851080	4854040	So you can close out of this.
4854040	4856200	And then let me see.
4860720	4863880	So while Mark is setting up for the demo, are there any
4863880	4866440	questions about SysML so far?
4866440	4867960	Any observations you guys have?
4871440	4875160	Maybe at EPFL, you see the similarities and differences
4875160	4878840	between OPM and SysML.
4878840	4882440	What's the biggest difference between the two?
4882440	4884200	There's two really important differences.
4887680	4888280	No questions?
4888280	4889960	Yes?
4889960	4891000	Hang on.
4891000	4894440	Is there anybody at EPFL who wants to comment on this?
4900880	4902840	No, there's no comment from EPFL.
4902840	4903640	OK, good.
4903640	4905400	That's fine.
4905400	4906760	That's fine.
4906760	4908720	Mark, are you set up?
4908720	4909220	Almost.
4914320	4918920	What I would say is, first of all, OPM has only one type of
4918920	4919920	diagram, right?
4919920	4923520	And then you go really deep, sort of a deep hierarchy.
4923520	4926840	SysML has nine different types of diagrams split between
4926840	4930120	behavioral and structural, but that's one difference.
4930120	4933040	And then the other is that SysML is fundamentally object
4933040	4936560	oriented, because it comes from object oriented thinking and
4936560	4940680	software, whereas OPM has objects and processes at the
4940680	4942200	same level.
4942200	4946000	Those are two of the most important differences.
4946000	4947600	OK?
4947600	4948520	All right.
4948520	4950480	So what I'm showing, can everyone see the screen?
4950480	4953200	Just let me know if you can't see the screen.
4953200	4956560	What I'm showing you right now is a tool called Magic Draw.
4956560	4958680	There are basically a variety of tools provided by
4958680	4961560	commercial vendors that enable you to build and work with
4961560	4962320	SysML models.
4962320	4965120	So SysML is a language, and then it's implemented in tools.
4965120	4968520	And this just happens to be one that's fairly widely
4968520	4969880	utilized.
4969880	4971560	Unfortunately, it's quite expensive.
4971560	4973480	But anyway.
4973480	4975240	So what I'm showing you right now, and this is going to be a
4975240	4977840	little bit difficult, because as you can see, you need a
4977840	4979600	big screen.
4979600	4981520	What I'm showing you right now is a requirements diagram.
4981520	4984520	So you can see that right here, requirements diagram.
4984520	4989080	And each of these blocks, as you can see by the tag here, is
4989080	4990080	a requirement.
4990080	4993000	So this is one of our operating criteria.
4993000	4994560	So while operating, the temperature of all our
4994560	4997400	components shall be maintained within operability limits.
4997400	4999240	Straightforward requirement.
4999240	5002440	And you can create these satisfy relationships between
5002440	5005000	that requirement and the components in the system that
5005000	5007160	must satisfy that requirement.
5007160	5010280	So right now, this is being done at SRR, as you can see up
5010280	5010840	here.
5010840	5013960	So this is very early in the design.
5013960	5016600	So we don't have it broken down fully to all the
5016600	5017040	components.
5017040	5019160	But here's our main electronics board.
5019160	5020880	It has to satisfy that requirement.
5020880	5021920	Here's our radiation cover.
5021920	5023360	It has to satisfy that requirement.
5023360	5025680	So you can tie these two things, the requirement, and the
5025680	5027840	part of the system that must satisfy the requirement.
5027840	5030120	And here I've tied it to parts.
5030120	5032480	So these are called blocks, which are the fundamental
5032480	5034760	unit in SysMLs, is a block.
5034760	5036160	So these represent parts of our system.
5036160	5037720	But you could tie it to a property of that
5037720	5039280	part if you wanted to.
5039280	5040880	So then you get into the situation I talked about
5040880	5044080	earlier, where you have the requirement is on the mass of
5044080	5045280	must be less than this.
5045280	5047200	You can tie it to the mass of the system itself.
5047200	5048960	As opposed to the system, you can tie it to the actual
5048960	5052760	property, which is very useful.
5052760	5059760	So let me quickly show you one of the cool things.
5059760	5062760	If I delete these requirements, you can see there's no
5062760	5063160	requirements.
5063160	5065800	I'm not actually deleting them from the system itself.
5065800	5068600	But I'm just doing as I'm removing it from the diagram.
5068600	5077120	But if you wanted to, you should be able to look at
5077120	5079200	related elements of the different blocks.
5079200	5080080	So I just clicked on a block.
5080080	5086760	And I can choose to show all the things that are satisfied,
5086760	5088760	the requirements of that component of the system
5088760	5093040	satisfies, and these requirements pop up.
5093040	5096800	So this is showing how the diagrams themselves aren't
5096800	5097120	the model.
5097120	5099040	There's actually back into the model.
5099040	5101760	And you can kind of work in the diagram and show or hide
5101760	5102880	things however you want.
5102880	5106960	But the information is actually kept behind the diagram.
5106960	5109080	So to speak.
5109080	5111840	So my research looked into topology.
5111840	5115280	So let me just show you a little bit about what I did.
5115280	5117720	So this is a block definition diagram, again, defining all
5117720	5118680	the parts of your system.
5118680	5121840	And I just want to give you kind of a high-level idea of
5121840	5124880	the type of things that we saw.
5124880	5132080	So it's big, first of all, very big.
5132080	5133920	These are all the parts of the system.
5133920	5136080	So we start hide like the mission context and the
5136080	5138480	mission context contain things like the environment, the
5138480	5140440	spacecraft, and then Rexus.
5140440	5141640	And then you can break down Rexus.
5141640	5143840	And we have various sub-assemblies broken down
5143840	5144680	into parts.
5144680	5147000	And that's how you get this tree structure.
5147000	5150440	And then this tree structure can be tied together.
5150440	5152360	I could zoom in, but it's big.
5152360	5155360	Again, so these are all the parts of our system.
5155360	5158240	Let me give you an example.
5158240	5160840	So we have a couple of boards that we call our
5160840	5162200	detector electronics.
5162200	5165440	And those detector electronics have various ports.
5165440	5167680	One thing they have to do, they have this port here and
5167680	5170840	this interface here, which connects to RCCDs.
5170840	5174040	So this is showing how you can build interfaces in
5174040	5174840	system also here.
5174840	5177200	The green boxes, again, are the ports, the lines of the
5177200	5179680	connectors, and they're defining all the interfaces.
5179680	5183680	And you can see, at a high level, how complicated things
5183680	5184920	get very quickly.
5184920	5187360	This is the earliest, most abstract version of our
5187360	5190920	design, and it already has a lot of complication.
5190920	5194480	One thing you can do, I talked about running scripts.
5194480	5195600	I'll show you how that works.
5195600	5197160	It's quite easy.
5200040	5202920	So I just ran a script on the model that told me to find the
5202920	5206080	number of parts in the scope that I defined and the number
5206080	5207600	of ports.
5207600	5209480	And here's the output of that model right here.
5209480	5213080	So the script itself is not even very complicated.
5213080	5216000	It's like 50, 60 lines of code.
5216000	5218240	And immediately I can pull out how many ports, how many
5218240	5221520	parts, things like that, information about my system.
5221520	5223960	So let me kind of take you briefly through the development
5223960	5225200	process.
5225200	5227680	So that was, again, the highest, the most abstract, the
5227680	5230040	earliest version of our system, SRR.
5230040	5231960	This is SDR.
5231960	5236760	You can see it's starting to get a bit more complex.
5236760	5240560	And then you can go over to PDR, and it starts to get
5240560	5241800	really scary.
5244480	5245680	Right?
5245680	5249640	And then you go to CDR, and it's just a nightmare.
5249640	5252440	So I created all these systems, all these models by hand.
5252440	5255120	You can't actually build the model with a script, if you
5255120	5257160	would like.
5257160	5259880	You can basically do things like define a pattern and then
5259880	5262800	apply that pattern to all the parts of that type.
5262800	5265120	That's all possible through the API.
5265120	5268200	And just to show you how much of a nightmare it was at CDR,
5268200	5274680	when they run the same script on the CDR model, we have
5274680	5277880	230 parts and 900 interfaces.
5277880	5279760	And this was not even modeling to the lowest level of
5279760	5280480	fidelity possible.
5280480	5282920	I didn't, for example, model all the components, all the
5282920	5286200	capacitors, resistors, op-amps, and stuff on the board.
5286200	5288280	And now you can already see it's quite large.
5288280	5292760	So this is just the idea behind these models would be to
5292760	5296480	extend this to the lowest level in a real system and use
5296480	5298520	this, basically, use all the capabilities that you have
5298520	5300600	with the model to really manage your complexity in a way
5300600	5302320	that is just not possible currently.
5302320	5304880	And there's no way you can really mentally keep track of
5304880	5306200	all these interfaces and understand
5306200	5307400	how your system is working.
5307400	5309320	So having this modeling capability and querying
5309320	5313040	capability is really, really powerful.
5313040	5318840	What was used during RECSYS for the systems engineering?
5318840	5321640	You had applied this after the fact.
5321640	5326400	What was used to create these block diagrams or track
5326400	5326840	things during RECSYS?
5326840	5329560	Do you mean during when we were developing RECSYS?
5329560	5331480	We basically didn't have this.
5331480	5334960	So we were relying, as you would typically do, upon the
5334960	5337280	capabilities of the system engineer or the team.
5337280	5338080	You'd have documents.
5338080	5340000	We have a ton of documents.
5340000	5342360	But I was talking about how things weren't buildable.
5342360	5345760	I found a situation where, because of the way we had
5345760	5347240	done our thermal system, we were dumping
5347240	5351160	spacecraft heat to space, which you don't want to do.
5351160	5353600	I can explain why, but you don't want to do that.
5353600	5356280	And that's something we didn't realize at the time.
5356280	5358920	Like if we had tried to build it, we would have had this
5358920	5361400	property of the system that we didn't know actually existed
5361400	5363000	until I went back and looked at the model.
5363000	5365080	So we definitely missed things.
5365080	5367200	And this should have improved the design process if we had
5367200	5369880	been using it.
5369880	5373600	So Mark, to wrap up, because we've got to switch over to
5373600	5377320	Modellica, what's your recommendation for, let's say
5377320	5380320	students in the class got intrigued by CISML.
5380320	5382840	What's the next step?
5382840	5383800	There's a couple of different ways.
5383800	5385480	Certainly, if you're interested, let me know.
5385480	5389760	And I can give you resources to further your understanding.
5389760	5393120	As I said, working with these tools can be expensive to get
5393120	5394080	these tools.
5394080	5397720	So I can help you understand what that would take.
5397720	5403600	There are some beginning to be some companies that will do
5403600	5406920	CISML training courses that will sit down for a day or a
5406920	5410080	week and teach you CISML, basically, how to work with
5410080	5411680	the model, how to build the model.
5411680	5412600	I took one of those courses.
5412600	5414160	It was really great.
5414160	5416840	So talk to me if you're interested, and I can steer
5416840	5418480	you down the right path.
5418480	5419160	Great.
5419160	5419800	Thanks, Mark.
5419800	5420280	Sure.
5420280	5422360	Very good.
5422400	5425560	So we did, in 20 minutes, what usually take about a week,
5425560	5427160	right?
5427160	5429320	There's a lot more to it.
5429320	5429560	Great.
5429560	5434280	So we're going to switch over now to Modellica, which I
5434280	5437440	think is we're going to maybe run a couple minutes over
5437440	5440040	today, but I think it's important we cover all three
5440040	5442160	languages.
5442160	5445360	So let's get the slides back up.
5445360	5447160	And I'm going to switch here to Narik.
5447160	5449760	He's another doctoral student in the group.
5449760	5455320	And so introduce yourself, and then tell us about Modellica.
5455320	5456320	Great.
5456320	5458320	Thank you.
5458320	5460720	Are you using your computer for slides or this computer?
5460720	5463200	For the demo, I'm going to use this one.
5463200	5464640	You need this one?
5464640	5465120	This one.
5476120	5476880	So hello, everyone.
5476880	5477600	My name is Narik.
5477600	5480720	I'm a doctoral student at AeroAstro here.
5480720	5483760	My background is in gas turbine engines, and specifically
5483760	5486280	I've been looking at concept generation of gas turbine
5486280	5488840	engines, automated concept generation.
5488840	5491360	And the way I got acquainted with Modellica
5491360	5494840	was that I needed to be able to rapidly reconfigure different
5494840	5498080	concepts and simulate them mathematically,
5498080	5499880	do physics-based simulations.
5499880	5502440	So in contrast to the first two languages,
5502440	5506400	Modellica is a lot more about rapidly being
5506400	5508840	able to build physical models of systems
5508840	5511680	and reconfiguring them and reusing them for later on.
5514280	5517600	So like I mentioned, Modellica is primarily
5517600	5520400	about physics-based modeling of systems
5520400	5524560	and rapidly being able to reuse models and reconfigure them.
5524560	5525480	It's a language.
5525480	5529560	Again, it's not a tool, like the first two that you heard about.
5529560	5532080	There are many different tools which implement this language,
5532080	5534800	but I'm going to start off with just describing how the language
5534800	5537720	works and then go on to describe which tools that you can use.
5537720	5540760	In contrast to CISML, there are a couple of really good free
5540760	5542960	tools that you can use and rapidly get into.
5542960	5545440	And there are a lot of libraries that you
5545440	5548400	can use with hundreds of even thousands of actually basic
5548400	5551000	components that you can use for modeling.
5551000	5552680	So it's a declarative language.
5552680	5555880	And what I mean by declarative is that you don't,
5555880	5559920	in sequential sort of programming, you write commands
5559920	5562840	and you make assignments to various parameters.
5562880	5565760	Here, you just describe the governing equations
5565760	5568680	of the components you want to simulate.
5568680	5571320	And there's no particular order in which you do this.
5571320	5572520	The models are a-causal.
5572520	5574480	There's no direction to flows.
5574480	5577280	All you really need to do is describe what ports,
5577280	5579400	like Mark mentioned.
5579400	5580840	It's similar in this situation.
5580840	5582760	What kind of ports you have, what kind of interfaces
5582760	5584680	the components can have with other components,
5584680	5588160	and the governing equations and the parameters and variables.
5588160	5590160	It's a multi-domain modeling language,
5590160	5592520	so it's agnostic to what kind of domain you're working in.
5592520	5594920	It's not particularly electrical engineering.
5594920	5597120	For example, I'm going to be showing an electrical engineering
5597120	5600120	example and also show a gas turbine engine example
5600120	5602520	with aero-elastic vibrations.
5602520	5604440	So you don't necessarily, you're not attached
5604440	5606320	to any specific domain.
5606320	5610560	It's also object-orientated, and it enables you to decompose
5610560	5615200	systems into subsystems or recombine them
5615200	5617920	and look at them at various layers of abstraction.
5617920	5620680	It's designed to be efficient, so this
5620680	5622280	is a quote from Professor Peter Fritzen
5622280	5624320	at Linkping University.
5624320	5627600	So these are just about the sort of scale of problems
5627600	5630680	that you can solve with the medallic language.
5630680	5632600	Obviously, it depends on what kind of equations
5632600	5635480	you're talking about, but it's designed
5635480	5640520	to be a very efficient way of simulating systems.
5640520	5642600	So I really want to talk a little bit more
5642600	5644920	about this idea of a-causal modeling
5644920	5646520	that I mentioned before.
5646520	5649760	So on the left-hand side is an assignment,
5649760	5653560	and that's typically what you do when you program in MATLAB,
5653560	5655880	just the MATLAB normal scripts.
5655880	5658160	F is assigned to MA, or P is assigned
5658160	5661160	the value of RORT for the equation of state of a gas.
5661160	5663200	And what that means is that you know
5663200	5664760	what the mass and acceleration are,
5664760	5666000	and you figure out the force.
5666000	5668040	And you assign that value to the force.
5668040	5670440	In medallica, there's almost none of this.
5670440	5672360	It's equations, not assignments.
5672360	5674440	And what I mean by that is this equation
5674440	5675600	can be written in any which way.
5675600	5678720	As long as your system has the same number of equations
5678760	5681680	as unknowns, the tool that you're using
5681680	5684640	will interpret the language and will solve your problem.
5684640	5687680	So you can write this in any which way you want in any order.
5687680	5691120	As long as your problem is properly constrained,
5691120	5693680	the tool that you're using will interpret it and solve
5693680	5694640	the problem for you.
5698040	5702440	So just to go into a little bit more detail,
5702440	5706600	all of medallica's and also of a-causal modeling language
5706600	5709040	that I'll mention in a little bit, which is one of them
5709040	5711040	is Simscape.
5711040	5712840	Models have essentially three parts.
5712840	5715760	They're designed to be extremely simple.
5715760	5719800	The first, like Mark mentioned, are ports.
5719800	5724680	It's essentially identical to SSML in a way.
5724680	5727600	Ports are the ways with which components
5727600	5731880	can share information, material, or energy, for example.
5731880	5733880	You can define any kind of port you want.
5733880	5735240	All you need to really do is define
5735240	5737400	what kind of parameters it carries, like for gas,
5737400	5739400	for example, temperature, pressure, and mass flow,
5739400	5742960	or for electrical ports, voltage, and current.
5742960	5744960	The second part of any kind of model
5744960	5747600	that you're building in medallica or Simscape,
5747600	5749120	which I'll mention a little later,
5749120	5751240	are variables and parameters, so you just declare those.
5751240	5753000	And the third part are governing equations.
5753000	5755360	The point is that there's nothing else.
5755360	5757840	It's just that.
5757840	5761720	And I'll just briefly go through a very, very simple example.
5761720	5764720	So for example, a capacitor.
5764720	5766680	This is the entire code for a capacitor,
5766680	5770600	and this is what will generate a visual image of a capacitor
5770600	5773640	with the correct ports for you.
5773640	5778040	First, you have pins that carry voltage and current.
5778040	5780640	So the key thing to notice here is
5780640	5783440	that there are fundamentally two types of variables.
5783440	5786960	Flow variables and normal variables here.
5786960	5790200	Flow variables are ones through which the Kirchhoff's current
5790200	5790760	law applies.
5790760	5793640	So mass flow, for example, every time
5793640	5796040	you connect 15 components together in a network,
5796040	5799160	mass flow into that network needs to be conserved.
5799160	5803040	So the sum of mass flows into any node has to be 0.
5803040	5806360	That doesn't apply to the standard variables.
5809480	5814680	So then you essentially define the parameters of variables,
5814680	5817200	and you need to define the governing equations,
5817200	5818960	and that's the capacitor for you.
5818960	5821040	There are slightly more complicated components
5821040	5825480	that you can use, for example, a pressure drop component.
5825480	5826920	Did I lose my sharing?
5826920	5828840	No.
5828840	5830680	In this case, the interesting thing
5830680	5832560	is the main thing to take away from this one
5832560	5835000	is that if you have complicated mathematics describing
5835000	5836920	the fluid mechanics in a component,
5836920	5839480	you can actually initialize with one model
5839480	5841880	and then go to a full turbulent simulation.
5841880	5845120	That's what this is doing here.
5845120	5850800	So just to get to the tool side of the equation,
5850800	5852360	the language I just showed you, it's
5852360	5854040	the same across all the tools.
5854040	5855200	But there are many different tools
5855200	5858080	which you can use free and commercial to actually
5858080	5860720	run these models.
5860720	5864800	The main one that you'll be using if you want to get deeper
5864800	5866040	into this is open medelica.
5866040	5867120	It's free.
5867120	5869560	It's actually become quite user friendly,
5869560	5873680	and there's a link in the slides with which
5873680	5875600	from which you can download it.
5875600	5877120	There's one from Wolfram.
5877120	5880280	It's integrated with Mathematica,
5880280	5883000	which is quite useful, and there's a free trial of it as well.
5883000	5885800	There's Daimler, there are other ones.
5885800	5887760	But mainly, I think open medelica is the one
5887760	5890080	that you guys will be using.
5890080	5893520	OK, Sonar, I think we're actually going to wrap up,
5893520	5894600	and then have you back next week.
5894600	5895640	Are you around next week?
5895640	5896880	Yeah, yeah, sure.
5896880	5901800	So here's, just stay around.
5901800	5907400	So basically, we're going to finish this lecture next week.
5907400	5909640	I think it's important enough that you really
5909640	5911720	see the demo and see sort of the,
5911720	5914240	and it actually ties in kind of nicely with,
5914240	5916840	next week's topic is concept generation, right?
5916840	5919680	This is the next step in the V. And since, you know,
5919680	5922080	Narik, your research is also in concept generation,
5922080	5924360	it'll tie in nicely.
5924360	5927000	So I think we're going to stop here for today.
5927000	5930440	So you heard about the general idea of system modeling
5930440	5934160	languages that are rigorous, that have ontology, syntax,
5934160	5935840	and semantics.
5935840	5938320	There's different of these that have been proposed,
5938320	5940680	developed, some are used more than others.
5940680	5943040	There's really important differences between them.
5943040	5945560	So OPM is very conceptual.
5945560	5949920	CISML is based on UML, and has these different type
5949920	5952960	of diagrams, and can really help you flesh out
5952960	5954640	your design in more detail.
5954640	5957120	And then Medellica allows you to build these blocks.
5957120	5960960	It's acausal or declarative, and you can actually
5960960	5965920	simulate the physics of the system pretty readily.
5965920	5969240	So the big picture here, just to wrap up here,
5969240	5972200	the big picture is the following.
5972200	5974640	And we'll come back to this next week.
5974640	5979680	The big picture is basically that system engineering
5979680	5981880	is in a transition phase.
5981880	5984280	The classic way of doing system engineering, really,
5984280	5988400	for the last 50 years, is on the left, document-centric.
5988400	5991840	You know, write your requirements, do your drawings.
5991840	5995240	Even CAD, you know, computer-aided design, is great,
5995240	5997600	but it only essentially does the mechanical part
5997600	5999040	of the design, right?
5999040	6002200	And so the result of that is, as you get even REXIS,
6002200	6005880	so REXIS is a box like shoebox size, basically,
6005880	6008920	and it's going to fit on a much bigger spacecraft,
6008920	6011040	and you saw how much complexity is there.
6011040	6013280	And it gets very, very difficult to manage
6013280	6016000	all this information, to prevent errors,
6016000	6019400	oversights, any change that you make.
6019400	6022920	It doesn't propagate automatically in these documents.
6022920	6026360	So the transition is happening to the right side,
6026360	6030400	a model-centric way to do system engineering,
6030400	6033080	as think of paperless engineering.
6033080	6035720	Everything you're doing is in a model.
6035720	6038920	The models are linked, the models are executable,
6038920	6042240	the models automatically propagate any changes
6042240	6044880	that you make, you know, in requirements or design.
6044880	6046800	We're not quite there yet, but that
6046800	6048960	is where things are moving.
6048960	6051760	And so keep that in mind.
6051760	6053600	So there's no new assignment this week.
6053600	6057000	So next week, we have A2, which is due, the requirements.
6057000	6058320	Please let us know if you have any.
6058320	6059240	We're here for you.
6059240	6062360	So I'm going to have office hours now on the WebEx.
6062360	6063200	You have the link.
6065800	6067680	If you have any questions about A2,
6067680	6070440	don't be shy to email me or, you know,
6070440	6073640	Juana or Lieslu at EPFL.
6073640	6075360	We're really here to answer your questions.
6075360	6077720	So next week, topic we're going to finish
6077720	6080640	on modelica and concept generation
6080640	6083520	is going to be sort of our creativity, concept generation
6083520	6085120	is our main topic next week.
