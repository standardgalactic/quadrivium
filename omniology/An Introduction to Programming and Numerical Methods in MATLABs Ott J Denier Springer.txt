An Introduction to Programming
and Numerical Methods in MATLAB

S.R. Otto and J.P. Denier
An Introduction to
Programming and
Numerical Methods
in MATLAB
With 111 Figures

S.R. Otto, BSc, PhD
The R & A
St Andrews
Fife
KY16 9JD
Scotland
J.P. Denier, BSc (Hons), PhD
School of Mathematical Sciences
The University of Adelaide
South Australia 5005
Australia
British Library Cataloguing in Publication Data
Otto, S. R. (Stephen Robert)
An introduction to programming and numerical methods in
MATLAB
1. MATLAB (Computer file)
2. Numerical analysis — Data
processing
I. Title
II. Denier, J. P.
518′.02855
ISBN 1852339195
Library of Congress Control Number: 2005923332
Apart from any fair dealing for the purposes of research or private study, or criticism or review, as
permitted under the Copyright, Designs and Patents Act 1988, this publication may only be repro-
duced, stored or transmitted, in any form or by any means, with the prior permission in writing of
the publishers, or in the case of reprographic reproduction in accordance with the terms of licences
issued by the Copyright Licensing Agency. Enquiries concerning reproduction outside those terms
should be sent to the publishers.
ISBN-10: 1-85233-919-5
ISBN-13: 978-185233-919-7
Springer Science+Business Media
springeronline.com
© Springer-Verlag London Limited 2005
The use of registered names, trademarks, etc. in this publication does not imply, even in the absence
of a specific statement, that such names are exempt from the relevant laws and regulations and there-
fore free for general use.
The publisher makes no representation, express or implied, with regard to the accuracy of the informa-
tion contained in this book and cannot accept any legal responsibility or liability for any errors or
omissions that may be made.
Typesetting: Camera-ready by authors
Printed in the United States of America
12/3830-543210
Printed on acid-free paper
SPIN 11317333

For
Julie
and
Jill and Megan.

Preface
This text provides an introduction to the numerical methods that are typically
encountered (and used) in science and engineering undergraduate courses. The
material is developed in tandem with MATLAB which allows rapid prototyping
and testing of the methods. The package MATLAB (matrix laboratory) pro-
vides an environment in which students can learn to programme and explore
the structure of the numerical methods. The methods included here are of a
basic nature and only rely on material which should have been explored prior
to the ﬁrst year undergraduate stage.
The methods presented are supplemented with a set of tasks at the end
of each chapter (full solutions of these are given in Appendix C). The tasks
are introduced in such a way as to allow students to explore the topics as
they evolve. Some are of a mathematical nature, but in the main they involve
manipulating codes which are given in the text of the chapter (or section).
Those tasks which we regard as being harder are marked with an asterisk.
Throughout the text MATLAB commands appear using this font in the text.
In the main the names of MATLAB commands reﬂect the commands rˆole. We
have taken particular care to highlight many of the problems that occur with
interpreting the syntax of MATLAB commands. In Appendix B we provide
a glossary of all MATLAB commands within the text and short examples of
how these commands can be used. Reference is made to the comprehensive
help facility within MATLAB: however examples are given which are similar
to those given in other places within the text.
Throughout the text we derive the numerical techniques we use, but also
emphasise that MATLAB’s rich vocabulary provides commands for perform-
ing most of the fundamental tasks encountered in numerical methods. This
approach serves to introduce students to the methods and also provides an

viii
Preface
understanding of their inner workings.
Why Do We Need Numerical Methods?
Mathematics is an elegant and precise subject: however when numerical an-
swers are required one sometimes needs to rely on approximate methods to
obtain useable answers. There are many problems which simply do not have
analytical solutions, or those whose exact solution is beyond our current state
of knowledge. There are also many problems which are too long (or tedious)
to solve by hand. When such problems arise we can exploit numerical analysis
to reduce the problem to one involving a ﬁnite number of unknowns and use a
computer to solve the resulting equations.
The text starts with a description of how we could perform some very
basic calculations (that is, simply using the computer as a calculator). It then
moves on to solving problems which cannot, in practice, be solved by hand.
Sometimes the solution of these problems can become as intricate and involved
as the original problems and requires almost as much ﬁnesse and care to obtain
a solution. There are several options available to us, both in terms of language
and also overall approach. In this book we elect to express our ideas in terms
of the syntax of the computer package MATLAB. Once you have mastered the
syntax of MATLAB it will be easier for you to learn other languages, if you
should decide you need to.
The Structure of This Text
This text is designed to be used as a source of reference for MATLAB commands
(mainly through the glossary in Appendix B) and the examples given in the
chapters. This is an approach we have found works well with our students. The
text gives an introduction to numerical methods and the manipulation of the
quantities used therein (for instance matrices). At each stage, short codes are
given to allow the reader to try their own examples.
Examples of code which can be typed at the MATLAB prompt will appear
within the general text in this font (this font is also used for the names of
MATLAB codes), while longer examples will be written
>> commands to be entered
Results

Preface
ix
Those codes which are designed to be saved to a ﬁle will appear in boxes




a = 1;
(sometimes wider boxes will be used for codes with longer lines).
At the end of each section, or chapter, there are a variety of tasks which are
designed to help the reader understand the topics they have just read. Solutions
of these are given in Appendix C.
Chapter 2 concentrates on some aspects of programming. We also introduce
another of MATLAB’s powerful tools, namely its ability to produce high quality
plots of data. Students are shown how to create codes and functions, which
serve to augment MATLAB’s built-in vocabulary. This chapter concludes with
a discussion of the important topic of errors, both from the perspective of
classical numerical analysis and also from human interaction which arise in
the action of coding. We have found that students beneﬁt enormously from
debugging programmes and it is hoped that this will help them to hone these
skills, which we consider to be essential.
The third chapter contains a discussion of looping and logical structures
within MATLAB. Again the mathematics is developed in tandem. Finally con-
cluding the ﬁrst part of the book we give some examples of how MATLAB can
be used to solve problems (using just algebra and exploiting MATLAB as an
advanced calculator).
In Chapters 4 and 5 we meet some classical numerical methods, in the form
of root ﬁnding and interpolation (and extrapolation). Although MATLAB has
intrinsic functions which will perform most of these operations (fzero and
polyfit) we have included a detailed description of both topics. This is aimed
at helping the students to understand how these methods work, and where
they can potentially fail. In Chapter 5 we discuss the general form of Newton
forward diﬀerences, which are used in this chapter and subsequent ones (for
instance to derive the formula for integration). In the next two chapters we
explore the numerical analysis associated with integration and diﬀerentiation.
In Chapter 6 we return to the topic of matrices. We start by discussing
the mathematical concepts of rank and linear independence. We also discuss
eigenvalues and eigenvectors (and their interpretation for 2-by-2 matrices). The
topic of numerical integration is taken up in Chapter 7 and in Chapter 8 meth-
ods for the numerical solution of ordinary diﬀerential equations are explored.
Finally in Chapter 9 we use MATLAB to calculate some basic statistical quan-
tities and also to explore some maps, some of which may be exhibit chaotic
behaviour.
The text ﬁnishes with appendices containing an introduction to the basics

x
Preface
of matrix algebra, a glossary of useful terms and solutions to all the tasks
contained within the text. These appendices have deliberately been made quite
wordy, since we believe that the material they contain is one of the important
aspects of the book.
At the outset we expect readers to be mathematically literate to the level of
being able to: and solve algebraic equations (for instance determine the roots
of a quadratic and solve simultaneous equations); integrate and diﬀerentiate
simple functions; solve separable diﬀerential equations (although examples are
given within the text). Although exposure to complex numbers and matrices
would be useful at the start of the text, it is not necessary as these concepts
are introduced in some detail in the introductory chapter.
We would like to thank students of the University of Birmingham whose
patience and comments have been invaluable in the construction of this text.
In particular we would like to identify Sukhjinder Chana and Rob Ackeroyd
for their careful proof reading and comments.
St Andrews, UK
S. R. Otto
Adelaide, Australia
J. P. Denier

Contents
1.
Simple Calculations with MATLAB . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1
Introduction and a Word of Warning . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2
Scalar Quantities and Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.2.1
Rules for Naming of Variables. . . . . . . . . . . . . . . . . . . . . . . .
4
1.2.2
Precedence: The Order in Which Calculations Are Per-
formed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.2.3
Mathematical Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
1.3
Format: The Way in Which Numbers Appear . . . . . . . . . . . . . . . . 12
1.4
Vectors in MATLAB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.4.1
Initialising Vector Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.4.2
Manipulating Vectors and Dot Arithmetic . . . . . . . . . . . . . 14
1.5
Setting Up Mathematical Functions . . . . . . . . . . . . . . . . . . . . . . . . . 17
1.6
Some MATLAB Speciﬁc Commands . . . . . . . . . . . . . . . . . . . . . . . . 20
1.6.1
Looking at Variables and Their Sizes. . . . . . . . . . . . . . . . . . 22
1.7
Accessing Elements of Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
1.8
Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2.
Writing Scripts and Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
2.1
Creating Scripts and Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
2.1.1
Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
2.1.2
Brief Aside . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.2
Plotting Simple Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
2.2.1
Evaluating Polynomials and Plotting Curves . . . . . . . . . . . 41
2.2.2
More on Plotting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
2.3
Functions of Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
2.4
Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

xii
Contents
2.4.1
Numerical Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
2.4.2
User Error. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
2.5
Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
3.
Loops and Conditional Statements . . . . . . . . . . . . . . . . . . . . . . . . . . 63
3.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
3.2
Loops Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
3.3
Summing Series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
3.3.1
Sums of Series of the Form
N

j=1
jp, p ∈N. . . . . . . . . . . . . . . 73
3.3.2
Summing Inﬁnite Series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
3.3.3
Summing Series Using MATLAB Speciﬁc Commands . . . 79
3.3.4
Loops Within Loops (Nested) . . . . . . . . . . . . . . . . . . . . . . . . 82
3.4
Conditional Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
3.4.1
Constructing Logical Statements . . . . . . . . . . . . . . . . . . . . . 85
3.4.2
The MATLAB Command switch . . . . . . . . . . . . . . . . . . . . 88
3.5
Conditional loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
3.5.1
The break Command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
3.6
MATLAB Speciﬁc Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
3.7
Error Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
3.8
Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
4.
Root Finding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
4.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
4.2
Initial Estimates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
4.3
Fixed Point Iteration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
4.4
Bisection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
4.5
Newton–Raphson and Secant Methods . . . . . . . . . . . . . . . . . . . . . . 117
4.5.1
Derivation of the Newton–Raphson Method . . . . . . . . . . . . 117
4.6
Repeated Roots of Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
4.7
Zeros of Higher-Dimensional Functions(*) . . . . . . . . . . . . . . . . . . . 125
4.8
MATLAB Routines for Finding Zeros . . . . . . . . . . . . . . . . . . . . . . . 128
4.8.1
Roots of a Polynomial . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
4.8.2
The Command fzero . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
4.9
Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
5.
Interpolation and Extrapolation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
5.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
5.2
Saving and Reading Data. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
5.3
Which Points to Use? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
5.4
Newton Forward Diﬀerences and Lagrange Polynomials . . . . . . . 141
5.4.1
Linear Interpolation/Extrapolation . . . . . . . . . . . . . . . . . . . 147

Contents
xiii
5.5
Calculating Interpolated and Extrapolated Values . . . . . . . . . . . . 148
5.6
Splines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
5.7
Curves of Best Fit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
5.8
Interpolation of Non-Smooth Data . . . . . . . . . . . . . . . . . . . . . . . . . . 155
5.8.1
Insuﬃcient Data Points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
5.9
Minimisation of Functions and Parameter Retrieval . . . . . . . . . . . 161
5.9.1
Parameter Retrieval . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
5.9.2
Using fmins for Parameter Retrieval . . . . . . . . . . . . . . . . . . 164
5.10 Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
6.
Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
6.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
6.1.1
Initialising Matrices Within MATLAB . . . . . . . . . . . . . . . . 169
6.1.2
Matrix Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
6.1.3
Operations on Elements of Matrices . . . . . . . . . . . . . . . . . . 180
6.1.4
More on Special Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
6.1.5
Matrices Containing Strings . . . . . . . . . . . . . . . . . . . . . . . . . 185
6.2
Properties of Matrices and Systems of Equations . . . . . . . . . . . . . 186
6.2.1
Determinants of Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
6.3
Elementary Row Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
6.3.1
Solving Many Equations at Once . . . . . . . . . . . . . . . . . . . . . 198
6.4
Matrix Decomposition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
6.5
Eigenvalues and Eigenvectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
6.6
Speciﬁc MATLAB Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
6.7
Characteristic Polynomials . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
6.8
Exponentials of Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
6.9
Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
7.
Numerical Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
7.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
7.2
Integration Using Straight Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
7.2.1
Errors in the Trapezium Method . . . . . . . . . . . . . . . . . . . . . 229
7.3
Integration Using Quadratics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
7.4
Integration Using Cubic Polynomials . . . . . . . . . . . . . . . . . . . . . . . . 235
7.5
Integrating Using MATLAB Commands . . . . . . . . . . . . . . . . . . . . . 237
7.6
Speciﬁc Examples of Integrals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238
7.6.1
Inﬁnite Integrals and Removable Singularities . . . . . . . . . . 238
7.6.2
Indeﬁnite Integrals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
7.7
Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242

xiv
Contents
8.
Solving Diﬀerential Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
8.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
8.2
Euler’s Method and Crank–Nicolson . . . . . . . . . . . . . . . . . . . . . . . . 247
8.2.1
Analytical Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
8.3
Banded Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259
8.4
Runge–Kutta Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
8.5
Higher-Order Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
8.5.1
Second-Order Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
8.5.2
Bessel’s equation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
8.5.3
Airy’s Equation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
8.5.4
Shooting Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
8.6
Boundary-Value Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
8.7
Population Dynamics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
8.8
Eigenvalues of Diﬀerential Systems . . . . . . . . . . . . . . . . . . . . . . . . . 285
8.9
Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
9.
Simulations and Random Numbers . . . . . . . . . . . . . . . . . . . . . . . . . 291
9.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
9.2
Statistical quantities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
9.2.1
Averages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
9.2.2
Other Statistical Measures. . . . . . . . . . . . . . . . . . . . . . . . . . . 293
9.3
Random Numbers and Distributions . . . . . . . . . . . . . . . . . . . . . . . . 295
9.3.1
Normal Distribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298
9.3.2
Calculating Probabilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
9.3.3
Permutations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
9.4
Maps and White Noise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
9.4.1
Modelling Discrete Systems . . . . . . . . . . . . . . . . . . . . . . . . . . 307
9.4.2
Periodicity and Chaos. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
9.4.3
Random Motion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316
9.5
Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
A.
A Mathematical Introduction to Matrices . . . . . . . . . . . . . . . . . . 323
A.1 Special Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330
A.2 Inverses of Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
B.
Glossary of Useful Terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 335
B.1 Arithmetic and Logical Operators . . . . . . . . . . . . . . . . . . . . . . . . . . 335
B.2 Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343
B.3 Plotting Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347
B.4 General MATLAB Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 365

Contents
xv
C.
Solutions to Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389
C.1 Solutions for Tasks from Chapter 1 . . . . . . . . . . . . . . . . . . . . . . . . . 389
C.2 Solutions for Tasks from Chapter 2 . . . . . . . . . . . . . . . . . . . . . . . . . 394
C.3 Solutions for Tasks from Chapter 3 . . . . . . . . . . . . . . . . . . . . . . . . . 400
C.4 Solutions for Tasks from Chapter 4 . . . . . . . . . . . . . . . . . . . . . . . . . 408
C.5 Solutions for Tasks from Chapter 5 . . . . . . . . . . . . . . . . . . . . . . . . . 414
C.6 Solutions for Tasks from Chapter 6 . . . . . . . . . . . . . . . . . . . . . . . . . 418
C.7 Solutions for Tasks from Chapter 7 . . . . . . . . . . . . . . . . . . . . . . . . . 429
C.8 Solutions for Tasks from Chapter 8 . . . . . . . . . . . . . . . . . . . . . . . . . 436
C.9 Solutions for Tasks from Chapter 9 . . . . . . . . . . . . . . . . . . . . . . . . . 454
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 459

1
Simple Calculations with MATLAB
1.1 Introduction and a Word of Warning
MATLAB is an incredibly powerful tool, but in order to use it safely you
need to be able to understand how it works and to be very precise when you
enter commands. Changing the way you enter a command, even subtly can
completely change its meaning.
The main aim of this text is to teach you to converse with MATLAB and un-
derstand its responses. It is possible to interact with MATLAB using a “phrase
book” approach, which is ﬁne if the answer is what you expect. However it is far
better to learn the language so that you can understand the response. As well
as learning the language it is essential that you learn the grammar or syntax;
this is perhaps even more important with computer languages than conven-
tional languages! MATLAB uses an interpreter to try to understand what you
type and this can come back with suggestions as to where you might have gone
wrong: sometimes what you have written makes sense to MATLAB but does
not mean what you expect! So you need to be careful. It is crucial that you
formulate ideas clearly in your head (or on paper) before trying to translate
them into MATLAB (or any other language).
We begin by discussing mathematical operations performed on scalars1. It
is crucial that the material in this chapter is understood before proceeding, as
it forms the basis of all that is to follow2.
1 That is numbers.
2 MATLAB has a wealth of introductory material available to the user that can

2
1. Simple Calculations with MATLAB
We shall start by introducing MATLAB commands which can be typed at
the MATLAB prompt; these will ultimately form part of our vocabulary of
MATLAB commands. MATLAB already has an extensive vocabulary: however
we will learn that we can expand this set. As the name MATLAB (MATrix
LABoratory) suggests, most of the commands work with matrices and these
will be discussed in due course. We shall start with scalar operations, for which
MATLAB acts like a very powerful calculator.
1.2 Scalar Quantities and Variables
We will begin with the basic ideas of equations and variables. Try entering the
commands as they are given. Consider the following two commands:
>> a = 3
a =
3
>> b = 4;
3 These two commands are entered on separate lines; the MATLAB prompt is
denoted by >> (which does not need to be typed), as distinguished from the
standard greater than sign >. The command on the ﬁrst line sets the variable
a to be equal to three (3) and that on the second line sets the variable b to
be equal to four (4). The two commands also diﬀer because the second one
ends with a semicolon. This instructs MATLAB to execute the command but
suppress any output; whereas above we can see that the value of a has been
set to 3. These commands can be read as
set a equal to 3
set b equal to 4 (and suppress output)
Reading the commands in this way it should be clear that it is not possible
to have a command of the form 7 = x (set 7 equal to x), whereas we could
have x = 7 (set x equal to 7). These variables can now be used again, for
instance
be accessed using the commands demo or tour. There is also a good help facility
which, unsurprisingly, can be accessed by typing help followed by the command in
question. There is also a facility to use a web browser (helpdesk or helpbrowser).
3 Here, you would type a = 3, and then press RETURN, and then type b = 4; and
press RETURN again. The spaces are included purely for clarity.

1.2 Scalar Quantities and Variables
3
>> a = 3;
>> b = a+1;
>> x = a+b;
The ﬁrst line sets the variable a to be equal to 3, the semicolon instructing
MATLAB to execute the command but to suppress the output. The second
line sets b to be equal to a plus one, namely 4: again the semicolon suppresses
output. The third line sets x to be a+b which is 7 (again output is suppressed).
MATLAB can be used as a very powerful calculator and its operations fall
into two basic groups: unary and binary, the former operating on one quan-
tity and the latter on two. We shall begin by considering simple arithmetic
operations, which are binary. For instance typing 3*4 generates
>> 3*4
ans =
12
Notice here that we have multiplied the two integers 3 and 4, and the answer
has been returned correctly as 12. MATLAB uses the variable ans to store the
result of our calculation, in this case the value 12, so that it can be used in
the subsequent commands. For instance the command ans*3 will generate the
result 36 (and now the variable ans will have the value 36). We could also have
used the commands a = 3; b = 4; x = a*b which can be typed on one line
and read as
set a equal to 3 (don’t output anything),
set b equal to 4 (don’t output anything)
and set x equal to a times b
Division works in exactly the same way as in the multiplication example above.
If we try the command 3/4, MATLAB returns the value 0.75.
It is a good idea to use meaningful variable names and we shall shortly
discuss valid forms for these.
Example 1.1 Try entering the following commands into MATLAB, but before
you do so try to work out what output you would expect.
>> 3*5*6
>> z1 = 34;
>> z2 = 17;
>> z3 = -8;
>> z1/z2

4
1. Simple Calculations with MATLAB
>> z1-z3
>> z2+z3-z1
Hopefully you should get the answers, 90, 2, 42 and −25.
Example 1.2 Here we give an example of the simple use of brackets:
>> format rat
>> a = 2; b = 3; c = 4;
>> a*(b+c)
>> a*b+c
>> a/b+c
>> a/(b+c)
>> format
In this example you should get the answers, 14, 10, 14/3 and 2/7. Hopefully this
gives you some idea that brackets make MATLAB perform those calculations
ﬁrst. (The command format rat has been used to force the results to be shown
as rationals, the ﬁnal command format reverts to the default, which happens
to be format short.)
1.2.1 Rules for Naming of Variables
In the examples we have seen so far we have simply used variable names which
seemed to suit the task at hand with no mention of restrictions on allowable
variable names in MATLAB. The rules for naming variables in MATLAB can
be summarised as follows:
1. Variable names in MATLAB must start with a letter and can be up to 31
characters long. The trailing characters can be numbers, letters or under-
scores (some other characters are also available but in this text we shall
stick to these). There are many choices which are forbidden as variable
names, some for very obvious reasons (such as a*b which signiﬁes a mul-
tiplication of the variables a and b) and others for more subtle reasons (a
good example is4 a.b).
The rules for naming variables also hold for naming MATLAB ﬁles. How-
ever, in this case a single dot is allowed within the name of the ﬁle; every-
thing after the dot is used to tell MATLAB what type of ﬁle it is dealing
4 The reason this is not a valid variable name lays in the fact that MATLAB supports
object orientated programming. Because of this a.b refers to the value of the “b”
component of the object a.

1.2 Scalar Quantities and Variables
5
with (whether it be a ﬁle containing MATLAB code, or data etc). We will
see more on this later in the section on script ﬁles.
2. Variable names in MATLAB are case sensitive, so that a and A are two
diﬀerent objects.
3. It is good programming practise to employ meaningful variable names.
In our initial examples we have only used very simple (but appropriate)
names: however as the examples become more complex our variable names
will be more informative.
4. Variables names should not coincide with a predeﬁned MATLAB command
or with any user-deﬁned subroutines. To see whether a variable name is al-
ready in use we can use the command type variable name, but it may
be better to use the command which variable name (this will tell you
whether the name variable name corresponds to an existing code or in-
trinsic function.
1.2.2 Precedence: The Order in Which Calculations Are
Performed
This represents one of the most common sources of errors and it is often the
most diﬃcult to detect. Before proceeding we brieﬂy comment on the question
of precedence, or the order in which commands are executed. Consider the
mathematical expression a(b + c) which you might read as “a times b plus c”
which would appear to translate to the MATLAB command a*b+c. Hopefully
you can see that this actually is equal to ab+c. The correct MATLAB command
for a(b+c) is a*(b+c). The brackets have been used to force MATLAB to ﬁrst
evaluate the expression (b+c) and then to multiply the result by a. We should
avoid falling into the trap of assuming that commands are performed from left-
to-right, for instance c+a*b is equal to c + ab (not (c + a)b as if the addition
was performed ﬁrst).
At this point we should pause brieﬂy and make sure the ideas of brackets are
ﬁrmly in place. Brackets should always appear in pairs and the mathematics
contained within brackets (or equivalently MATLAB) will be evaluated ﬁrst.
Hopefully this concept is familiar to you: however it is worth reiterating, since
one of the most common problems in using MATLAB occurs due to either
unbalanced or incorrectly placed brackets. For example the commands (3+4/5)
and (3+4)/5 are obviously diﬀerent, the former being 3 4
5 and the latter being
3+4
5 .
The most critical use of brackets, which circumvents another popular source

6
1. Simple Calculations with MATLAB
of error, is in terms of division. We should note that in the syntax of MATLAB
a/b*c is not equal to
a
bc but a
b c. In order to ensure that the denominator of
the fraction is calculated ﬁrst we would need to use a/(b*c), which is equal to
a
bc. Similarly for examples like a/b+c versus a/(b+c).
Example 1.3 Determine the value of the expression a(b + c(c + d))a, where
a = 2, b = 3, c = −4 and d = −3.
Although this is a relatively simple example it is worth constructing the
MATLAB statement to evaluate the expression:
>> a = 2; b = 3; c = -4; d = -3;
>> a*(b+c*(c+d))*a
This gives the answer 124. It is worth pausing here to consider the syntax of
these commands. In the ﬁrst line of this code we initialize the four variables a,
b, c and d to have the values 2, 3, −4 and −3 respectively. The commands each
end with semicolons; we have chosen to place all four commands on one line:
however they could just as easily be placed on separate lines. With the variables
assigned values we can now use them to perform calculations, such as in the
second line where we form the mathematical expression a(b + c(c + d))a. Note
all multiplications must be denoted by an asterisk and brackets have been used
to force precedence of the operation; of course the brackets must balance (for
each left bracket there is a corresponding right bracket) for the expression to
make sense.
Example 1.4 Evaluate the MATLAB expressions
'
&
$
%
1+2/3*4-5
1/2/3/4
1/2+3/4*5
5-2*3*(2+7)
(1+3)*(2-3)/3*4
(2-3*(4-3))*4/5
by hand and then check answers with MATLAB.
Recall that the operations of division and multiplication take precedence over
addition and subtraction (type help precedence at the MATLAB prompt for
more details).

1.2 Scalar Quantities and Variables
7
The expressions are given by
1+2/3*4-5 = 1 + 2
34 −5 = −4
3,
1/2/3/4 = (((1/2)/3)/4) = 1
24,
1/2+3/4*5 = 1
2 + 3
45 = 17
4 ,
5-2*3*(2+7) = 5 −6(9) = −49,
(1+3)*(2-3)/3*4 = 4 × (−1)
3
4 = −16
3 ,
(2-3*(4-3))*4/5 = (2 −3 × 1)4
5 = −4
5;
which can be veriﬁed in MATLAB; we can use the command format rat to
force MATLAB to output the results as rational numbers (that is, fractions).
We mention here MATLAB has a number of intrinsic constants which
the programmer can use, for instance pi and eps. The former is merely
π = 3.14159265 · · · and the latter is the distance from unity to the next
real number in MATLAB5. It is also possible to enter numbers using the
exponent-mantissa form. This uses the fact that numbers can be written as
“mantissa × 10exponent”, for example
Number
mantissa - exponent
MATLAB form
789.34
7.8934 × 102
7.8934e2
0.0001
1 × 10−4
1e-4
4
4 × 100
4
400000000000
4 × 1011
4e11
Example 1.5 Write 3432.6 in exponent-mantissa form and write 100 × 1010
in normal form.
We have
3432.6 ≡3.4326 × 103
and
100 × 1010 ≡1, 000, 000, 000, 000.
5 The smallest positive number that MATLAB can store which is diﬀerent from zero
is realmin which is approximately 10−308, whilst the largest number is realmax
which approximately 10308. These intrinsic constants may be dependent upon your
version of MATLAB and/or your computer’s operating system.

8
1. Simple Calculations with MATLAB
Example 1.6 Use MATLAB to calculate the expression
b −
a
b + b+a
ca
where a = 3, b = 5 and c = −3.
The code for this purpose is:




a = 3;
b = 5;
c = -3;
x = b-a/(b+(b+a)/(c*a));
with the solution being contained in the variable x.
Example 1.7 Enter the numbers x = 45 × 109 and y = 0.0000003123 using
the exponent-mantissa syntax described above. Calculate the quantity xy using
MATLAB and by hand.
This is accomplished using the code




x = 45e9;
y = 3.123e-7;
xy = x*y;
Notice that here we have used a variable name xy which should not be confused
with the mathematical expression xy (that is x × y).
We can now set the values of variables and perform basic arithmetic operations.
We now proceed to discuss other mathematical operations.
1.2.3 Mathematical Functions
Before we proceed let us try some more of the “calculator” functions (that is,
those which are familiar from any scientiﬁc calculator).
Arithmetic functions +, -, / and *.
Trigonometric functions sin (sine), cos (cosine) and tan (tangent) (with their
inverses being obtained by appending an a as in asin, acos or atan).
These functions take an argument in radians, and the result of the inverse
functions is returned in radians. It should be noted these are functions and
as such should operate on an input; the syntax of the commands is sin(x)
rather than sin x.

1.2 Scalar Quantities and Variables
9
Exponential functions exp, log, log10 and ˆ. These are largely self explana-
tory, but notice the default in MATLAB for a logarithm is the natural
logarithm ln x. The ﬁnal command takes two arguments (and hence is a
binary operation) so that aˆb gives ab.
Other functions There are a variety of other functions available in MATLAB
that are not so commonly used, but which will deﬁnitely be useful:
round(x)
Rounds a number to the nearest integer
ceil(x)
Rounds a number up to the nearest integer
floor(x)
Rounds a number down to the nearest integer
fix(x)
Rounds a number to the nearest integer towards zero
rem(x,y)
The remainder left after division
mod(x,y)
The signed remainder left after division
abs(x)
The absolute value of x
sign(x)
The sign of x
factor(x)
The prime factors of x
There are many others which we will meet throughout this book. We note that
the ﬁnal command factor gives multiple outputs.
We now construct some more involved examples to illustrate how these
functions work.
Example 1.8 Calculate the expressions: sin 60◦(and the same quantity squared),
exp(ln(4)), cos 45◦−sin 45◦, ln exp(2 + cos π) and tan 30◦/(tan π/4 + tan π/3).
We shall give the MATLAB code used for the calculation together with the
results:
>> x = sin(60/180*pi)
x =
0.8660
>> y = xˆ2
y =
0.7500
>> exp(log(4))

10
1. Simple Calculations with MATLAB
ans =
4
>> z = 45/180*pi; cos(z)-sin(z)
ans =
1.1102e-16
>> log(exp(2+cos(pi)))
ans =
1
>> tan(30/180*pi)/(tan(pi/4)+tan(pi/3))
ans =
0.2113
The values of these expressions should be
√
3/2, 3/4, 4, 0, 1 and 1/(3 +
√
3).
Notice that zero has been approximated by 1.1102e-16 which is smaller than
the MATLAB variable eps, which reﬂects the accuracy to which this calculation
is performed.
It is worth going through the previous example in order to practise the
command syntax. Getting this right is crucial since it is only through mastering
the correct syntax (that is, the MATLAB language) that you will be able to
communicate with MATLAB. When you ﬁrst start programming it is common
to get the command syntax confused. To emphasise this let’s consider some of
the commands above in a little more detail. Let us start with f(x) = x sin x: the
MATLAB command to return a value of this expression is x*sin(x) and not
x*sinx or xsin(x). The command x*sinx would try to multiply the variable
x by the variable sinx; unless the variable sinx is deﬁned (it isn’t) MATLAB
would return an error message
??? Undefined function or variable ’sinx’.
Similarly the command xsin(x) tries to evaluate the MATLAB function xsin,
which isn’t deﬁned, at the point x. Again MATLAB would return an error

1.2 Scalar Quantities and Variables
11
message, in this case
??? Undefined function or variable ’xsin’.
In cases such as these MATLAB provides useful information as to where we
have gone wrong; information we can use to remedy the syntax error in our
piece of code. This simple example emphasises the need to read your code very
carefully to ensure such syntax errors are avoided.
It is essential that arguments for functions are contained within round
brackets, for instance cos(x) and that where functions are multiplied
together an asterisk is used, for instance f(x) = (x + 2) cos x should be
written (x+2)*cos(x).
Important Point
Example 1.9 The functions we used in the previous example all took a single
argument as input, for example sin(x). Mathematically we can deﬁne functions
of two or more variables. MATLAB has a number of intrinsic functions of this
type (such as the remainder function rem). To see how these are employed
in MATLAB we consider two examples of such functions, one of which takes
multiple inputs and returns a single output and the other which takes a single
input and returns multiple outputs.
Our ﬁrst example is the MATLAB function rem. The command rem(x,y)
calculates the remainder when x is divided by y. For example 12345 = 9 ×
1371 + 6, so the remainder when 12345 is divided by 9 is equal to 6. We can
determine this with MATLAB by simply using rem(12345,9).
An example of a command which takes a single input and returns multiple
outputs is factor which provides the prime decomposition of an integer. For
example
>> factor(24)
ans =
[2 2 2 3]
Here the solution is returned as an array of numbers as the answer is not a
scalar quantity. We could just as easily used the command x = factor(24) to
set x equal to the array [2 2 2 3]. We can now check MATLAB has correctly

12
1. Simple Calculations with MATLAB
determined the prime decomposition of the number 24 by multiplying the ele-
ments of the array x together; this is most readily achieved by using another
intrinsic function prod(x).
1.3 Format: The Way in Which Numbers
Appear
Before we proceed we stop to discuss this important topic. This can be simply
illustrated by the following example:
Example 1.10 Consider the following code
#
"
 
!
s = [1/2 1/3 pi sqrt(2)];
format short; s
format long; s
format rat; s
format ; s
this generates the output
>> format short; s
s =
0.5000
0.3333
3.1416
1.4142
>> format long; s
s =
0.50000000000000
0.33333333333333
3.14159265358979
1.41421356237310
>> format rat; s
s =
1/2
1/3
355/113
1393/985
>> format ; s
s =
0.5000
0.3333
3.1416
1.4142

1.4 Vectors in MATLAB
13
There are other options for format which you can see by typing help format.
The default option is format short (which can be reverted back to by simply
typing format). The above options are
short – 5 digits
long – 15 digits
rat – try to represent the answer as a rational.
You should note that whilst format rat is very useful, it can lead to misleading
answers (in the above example clearly π is not equal to 355/113). At the start
of a calculation it is a good idea to ensure that the data is being displayed
in the appropriate format. In this example we have performed an operation
on four numbers at once using the vector construction in MATLAB. We now
proceed to discuss this further.
1.4 Vectors in MATLAB
One of the most powerful aspects of MATLAB is its use of vectors (and ul-
timately matrices) as objects. In this section we shall introduce the idea of
initiating vectors and how they can be manipulated as “MATLAB objects”.
1.4.1 Initialising Vector Objects
We shall start with simple objects and construct these using the colon symbol:




r = 1:5;
This sets the variable r to be equal to the vector [1 2 3 4 5] (and the semi-
colon suppresses output, as normal). This is a row vector, which we can see by
typing size(r) (which returns [1 5], indicating that r has one row and ﬁve
columns). This simple way of constructing a vector r = a:b creates a vector r
which runs from a to b in steps of one. We can change the step by using the
slightly more involved syntax r = a:h:b, which creates the vector r running
from a to b in steps of h, for instance




r = 1:2:5;
s = 1:0.5:3.5;

14
1. Simple Calculations with MATLAB
gives r = [1 3 5] and s = [1 1.5 2 2.5 3 3.5]. We note that if the inter-
val b-a is not exactly divisible by h, then the loop will run up until it exceeds
b, for instance t = 1:2:6 gives t = [1 3 5]. We can also initiate vectors by
typing the individual entries; this is especially useful if the data is irregular, for
instance t = [14 20 27 10];. There are many other ways of setting up vec-
tors and for the moment we shall only mention one more. This is the command
linspace: this has two syntaxes




s = linspace(0,1);
t = linspace(0,1,10);
Here s is set up as a row vector which runs from zero to one and has one
hundred elements and t again runs from zero to one but now has ten elements.
Note here that to set up a vector which runs from zero to one in steps of 1/N, we
can use w = 0:1/N:1 or W = linspace(0,1,N+1). (For example trying typing
s=0:0.1:1.0; length(s). You will ﬁnd that s has eleven elements!). The
command linspace is especially useful when setting up mathematical functions
as we shall discover in the next section.
1.4.2 Manipulating Vectors and Dot Arithmetic
We shall now talk about the idea of calculations involving vectors and for this
purpose we shall discuss dot arithmetic. This allows us to manipulate vectors
in an element-wise fashion rather than treating them as mathematical objects
(in fact for addition and subtraction this is the same thing).
To see how dot arithmetic works let’s consider a simple example:
>> a = [1 2 3];
>> 2*a;
ans =
2
4
6
Suppose now we try to multiply a vector by a vector, as in
>> a = [1 2 3];
>> b = [4 5 6];
>> a*b
??? Error using ==> *
Inner matrix dimensions must agree.

1.4 Vectors in MATLAB
15
An error message appears because both a and b are row vectors and therefore
cannot be multiplied together. Suppose however that what we really want to
achieve is to multiply the elements of vector a by the elements of vector b in
an element by element sense. We can achieve this in MATLAB by using dot
arithmetic as follows
>> a = [1 2 3];
>> b = [4 5 6];
>> a.*b
ans =
4
10
18
A glance at the answer shows that MATLAB has returned a vector containing
the elements
[a1b1, a2b2, a3b3].
The . indicates to MATLAB to perform the operation term by term and the *
indicates we require a multiplication. We can also do a term by term division
with
>> a = [1 2 3];
>> b = [4 5 6];
>> a./b
ans =
0.2500
0.4000
0.5000
The result is, as we would expect,
a1
b1
, a2
b2
, a3
b3

.
Example 1.11 We shall create two vectors running from one to six and from
six to one and then demonstrate the use of the dot arithmetical operations:

16
1. Simple Calculations with MATLAB
'
&
$
%
s = 1:6;
t = 6:-1:1;
s+t
s-t
s.*t
s./t
s.ˆ2
1./s
s/2
s+1
This produces the output
>> s+t
ans =
7
7
7
7
7
7
>> s-t
ans =
-5
-3
-1
1
3
5
>> s.*t
ans =
6
10
12
12
10
6
>> s./t
ans =
0.1667
0.4000
0.7500
1.3333
2.5000
6.0000
>> s.ˆ2
ans =
1
4
9
16
25
36

1.5 Setting Up Mathematical Functions
17
>> 1./s
ans =
1.0000
0.5000
0.3333
0.2500
0.2000
0.1667
>> s/2
ans =
0.5000
1.0000
1.5000
2.0000
2.5000
3.0000
>> s+1
ans =
2
3
4
5
6
7
These represent most of the simple operations which we may want to use.
We note that in order for these operations to be viable the vectors need to be
of the same size (unless one of them is a scalar – as in the last three examples).
1.5 Setting Up Mathematical Functions
Following on from the previous section we discuss how one might evaluate a
function. It is crucial that you understand this section before you proceed.
We revisit the topics introduced in the previous section and discuss the
ways in which you can set up the input to the function
Example 1.12 Set up a vector x which contains the values from zero to one
in steps of one tenth.
This can be done in a variety of ways:

18
1. Simple Calculations with MATLAB
'
&
$
%
% Firstly just list all the values:
x = [0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0];
% Use the colon construction
x = 0:0.1:1.0;
% Or use the command linspace
x = linspace(0,1,11);
As noted previously we note that there are eleven values between zero
and one (inclusive) for a step length of one tenth. You may want to try
linspace(0,1,10) and see what values you get.
Each of these methods are equally valid (and more importantly will produce
the same answer) but the latter two are probably preferable, since they are
easily extended to more elements.
We now wish to set up a simple mathematical function, say for instance
y = x2. Initially you may want to type xˆ2 but this will generate the error
message
??? Error using ==> ˆ
Matrix must be square.
This is because this operation is trying to perform the mathematical operation
x × x and this operation is not possible. Instead we need to use y=x.ˆ2 which
gives
>> y = x.ˆ2
y =
Columns 1 through 7
0
0.0100
0.0400
0.0900
0.1600
0.2500
0.3600
Columns 8 through 11
0.4900
0.6400
0.8100
1.0000
Here we see that each element of x has been squared and stored in the array
y. Equivalently we could use y = x.*x;.
Example 1.13 Construct the polynomial y = (x + 2)2(x3 + 1) for values of x
from minus one to one in steps of 0.1.

1.5 Setting Up Mathematical Functions
19
Here it would be laborious to type out all the elements of the vector so instead
we use the colon construction. We shall also deﬁne f = (x+2) and g = x3 +1,
so that we have the code:




x = -1:0.1:1;
f = x+2;
g = x.ˆ3+1;
y = (f.ˆ2).*(g);
In the construction of g we have used the dot arithmetic to cube each element
and then add one to it. When constructing y we ﬁrstly square each element
of f (with f.ˆ2) and then multiply each element of this by the corresponding
element of g.
You should make sure that you are able to understand this example.
Example 1.14 Construct the function y =
x2
x3 + 1 for values of x from one to
two in steps of
0.01.
Here we merely give the solution:




x = 1:0.01:2;
f = x.ˆ2;
g = x.ˆ3+1;
y = f./g;
(We could have combined the last three lines into the single expression y =
x.ˆ2./(x.ˆ3+1);).
For the moment it may be a good idea to use intermediate functions when
constructing complicated functions.
Example 1.15 Construct the function
y(x) = sin

x cos x
x2 + 3x + 1

,
for values of x from one to three in steps of 0.02.
Here, again, we use the idea of intermediate functions

20
1. Simple Calculations with MATLAB




x = 1:0.02:3;
f = x.*cos(x);
g = x.ˆ2+3*x+1;
y = sin(f./g);
NB MATLAB will actually calculate f/g and in this case it will return a
scalar value of −0.1081. Unfortunately this will not generate an error but it
will mean that the answer is not a vector as we should be expecting.
1.6 Some MATLAB Speciﬁc Commands
We shall now introduce a couple of commands which can be used to make cal-
culations where the input can take a variety of forms. The ﬁrst command is
polyval. This command takes two inputs, namely the coeﬃcients of a polyno-
mial and the values at which you want to evaluate it. In the following example
we shall use a cubic but hopefully you will be able to see how this generalises
to polynomials of other orders.
Example 1.16 Evaluate the cubic y = x3 + 3x2 −x −1 at the points x =
(1, 2, 3, 4, 5, 6). We provide the solution to this example as a commented code:
'
&
$
%
% Firstly set up the points at which the polynomial
% is to be evaluated
x = 1:6;
% Enter the coefficients of the cubic (note that
% these are entered starting with the
% coefficient of the highest power first
c = [1 3 -1 -1];
% Now perform the evaluation using polyval
y = polyval(c,x)
Note that in this short piece of code everything after the % is treated by MAT-
LAB as a comment and so is ignored. It is good practice to provide brief, but
meaningful, comments at important points within your code.

1.6 Some MATLAB Speciﬁc Commands
21
It is important that you remember to enter the coeﬃcients of the poly-
nomial starting with the one associated with the highest power and
that zeros are included in the sequence.
Important Point
We might want to plot the results of this calculation and this can be simply
accomplished using the plot command. Consider the following example:
Example 1.17 Plot the polynomial y = x4 +x2 −1 between x = −2 and x = 2
(using ﬁfty points).




x = linspace(-2,2,50);
c = [1 0 1 0 -1];
y = polyval(c,x);
plot(x,y)
This produces the output
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
−5
0
5
10
15
20
In the next chapter we shall discuss plotting in more detail and show how plots
can be customised.
There are many other commands which allow us to manipulate polynomials:
perhaps one of the most useful ones is the roots. The polynomial is deﬁned in
the same way as in the previous examples. The input to the routine is simply
these coeﬃcients and the output is the roots of the polynomial.
Example 1.18 Find the roots of the polynomial y = x3 −3x2 + 2x using the

22
1. Simple Calculations with MATLAB
command roots.




c = [1 -3 2 0];
r = roots(c)
This returns the answers as zero, two and one.
In fact the converse command also exists, which is poly. This takes the roots
and generates the coeﬃcients of the polynomial having those roots (which is
monic, that is the coeﬃcient of the highest term is unity).
1.6.1 Looking at Variables and Their Sizes
Before we proceed we mention a couple of useful commands for seeing which
variables are deﬁned. To list the variables which are currently deﬁned we can
use the command whos. This will give a list of the variables which are currently
deﬁned (a shorter output can be obtained by using the command who). This
command can be used to list certain variables only, for instance whos re* lists
only the variables whose names start with re.
Example 1.19 The following code
#
"
 
!
clear all
a = linspace(0,1,20);
b = 0:0.3:5;
c = 1.;
whos
gives the output
Name
Size
Bytes
Class
a
1x20
160
double array
b
1x17
136
double array
c
1x1
8
double array
Grand total is 38 elements using 304 bytes
Here we have used the clear all command to remove all previously deﬁned
variables. To look at the size of one variable we can use the command length,
for instance with the previous example length(a) will give the answer 20. We
note that the command size(a) will give two dimensions of the array, that is

1.7 Accessing Elements of Arrays
23
in this case [1 20]; this will be particularly useful when we consider matrices
in due course.
1.7 Accessing Elements of Arrays
This is one of the most important ideas in MATLAB and other programming
languages which is often misunderstood. Let us start by considering a simple
array x = 0:0.1:1.;. The elements of this array can be recalled by using the
format x(1) through to x(11). The number in the bracket is the index and
refers to which value of x we require. A convenient mathematical notation for
this would be xj where j = 1, · · · , 11. This programming notation should not
be confused with x(j); that is x is a function of j. Let us consider the following
illustrative example:
Example 1.20 Construct the function f(x) = x2+2 on the set of points x = 0
to 2 in steps of 0.1 and give the value of f(x) at x = 0, x = 1 and x = 2. The
code to construct the function is:
'
&
$
%
x = 0:0.1:2;
f = x.ˆ2+2;
% Function at x=0
f(1)
% Function at x=1
f(11)
% Function at x=2
f(21)
Note that the three points are not f(0), f(1) and f(2)!
In this example we have noted that xj = (j −1)/10 and hence x1 = 0, x11 = 1
and x21 = 2. These three indices are the ones we have used to ﬁnd the value of
the function.
In MATLAB f(j) the value of j refers to the index within the array
rather than the function f(.) evaluated at the value j!
Important Point

24
1. Simple Calculations with MATLAB
The expression end is very useful at this point, since it can be used to refer
to the ﬁnal element within an array. In the previous example f(end) gives the
value of f(21) since the length of f is 21.
Example 1.21 We now show how to extract various parts of the array x.
#
"
 
!
x = linspace(0,1,10);
y = x(1:end);
% Whole of x
y = x(1:end/2);
% First half
y = x(2:2:end);
% Even indices only
y = x(2:end-1);
% All but the last one
1.8 Tasks
In this introductory chapter we shall give quite a few details (at least initially)
concerning these suggested tasks. However, as the reader’s grasp of the MAT-
LAB syntax develops the tasks will be presented more like standard questions
(the solutions are given at the back of the book in Appendix C).
Task 1.1 Calculate the values of the following expressions (to ﬁnd the MAT-
LAB commands for each function you can use the Glossary, see for instance
the entry for tan on page 386 or the help command, help tan).
p(x) = x2 + 3x + 1 at x = 1.3,
y(x) = sin(x) at x = 30◦,
f(x) = tan−1(x) at x = 1,
g(x) = sin

cos−1(x)

at x =
√
3
2 .
Task 1.2 Calculate the value of the function y(x) = |x| sin x2 for values of
x = π/3 and π/6 (use the MATLAB command abs(x) to calculate |x|).
Task 1.3 Calculate the quantities sin(π/2), cos(π/3), tan 60◦and ln(x +
√
x2 + 1) where x = 1/2 and x = 1. Calculate the expression x/((x2 + 1) sin x)
where x = π/4 and x = π/2. (If you are getting strange answers in the form

1.8 Tasks
25
of rationals you may well have left the format as rat, so go back to the default
by typing format).
Task 1.4 Explore the use of the functions round, ceil, floor and fix for the
values x = 0.3, x = 1/3, x = 0.5, x = 1/2, x = 1.65 and x = −1.34.
Task 1.5 Compare the MATLAB functions rem(x,y) and mod(x,y) for a va-
riety of values of x and y (try x = 3, 4, 5 and y = 3, 4, −4, 6). (Details of the
commands can be found using the help feature).
Task 1.6 Evaluate the functions
1. y = x3 + 3x2 + 1
2. y = sin x2
3. y = (sin x)2
4. y = sin 2x + x cos 4x
5. y = x/(x2 + 1)
6. y =
cos x
1+sin x
7. y = 1/x + x3/(x4 + 5x sin x)
for x from 1 to 2 in steps of 0.1
Task 1.7 Evaluate the function
y =
x
x +
1
x2
,
for x = 3 to x = 5 in steps of 0.01.
Task 1.8 Evaluate the function
y = 1
x3 + 1
x2 + 3
x,
for x = −2 to x = −1 in steps of 0.1.
Task 1.9 (D) The following code is supposed to evaluate the function
f(x) =
x2 cos πx
(x3 + 1)(x + 2),

26
1. Simple Calculations with MATLAB
for x ∈[0, 1] (using 200 steps). Correct the code and check this by evaluating
the function at x = 1 using f(200) which should be −1/6.
'
&
$
%
x = linspace(0,1);
clear all
g = xˆ3+1;
H = x+2;
z = x.ˆ2;
y = cos xpi;
f = y*z/g*h
Task 1.10 (D) Debug the code which is supposed to plot the polynomial x4 −1
between x = −2 and x = 2 using 20 points.




x = -2:0.1:2;
c = [1 0 0 -1];
y = polyval(c,x);
plot(y,x)
Task 1.11 (D) Debug the code which is supposed to set up the function f(x) =
x3 cos(x + 1) on the grid x = 0 to 3 in steps of 0.1 and give the value of the
function at x = 2 and x = 3.
'
&
$
%
x = linspace(0,3);
f = xˆ3.*cos x+1;
% x = 2
f(2)
% x = 3
f(End)

2
Writing Scripts and Functions
2.1 Creating Scripts and Functions
With the preliminaries out of the way we now turn our attention to actually
using MATLAB by writing a short piece of code. Most of the commands in
this section have purposely been written so they can be typed at the prompt,
>>. However, as we develop longer codes or ones which we will want to run
many times it becomes necessary to construct scripts. A script is simply a ﬁle
containing the sequence of MATLAB commands which we wish to execute to
solve the task at hand; in other words a script is a computer program written
in the language of MATLAB.
To invoke the MATLAB editor1 we type edit at the prompt. This editor
has the advantage of understanding MATLAB syntax and producing automatic
formatting (for instance indenting pieces of code as necessary). It is also useful
for colour coding the MATLAB commands and variables. Both of these at-
tributes are extremely useful when it comes to debugging code. The MATLAB
editor also has the feature that once a piece of code has been run the values
of variables can be displayed by placing the mouse close to the variable’s loca-
tion within the editor. This is extremely useful for seeing what is going on and
provides the potential to identify where we might have made a mistake (for
instance, if we had set a variable to be the wrong size).
1 You can of course make use of any other editor you have available on your computer.
We have chosen to use the built-in MATLAB editor. Its implementation may diﬀer
slightly from platform to platform. If you are unsure of its use try typing help
edit at the MATLAB prompt.

28
2. Writing Scripts and Functions
Example 2.1 We begin by entering and running the code:




a = input(’First number ’);
b = input(’Second number ’);
disp([’ Their sum is ’ num2str(a+b)])
disp([’ Their product is ’ num2str(a*b)])
This simple code can be entered at the prompt, but that would defeat our
purpose of writing script ﬁles. We shall therefore create our ﬁrst script and save
it in a ﬁle named twonums.m. To do this, ﬁrst we type edit at the MATLAB
prompt to bring the editor window to the foreground (if it exists) or invoke a
new one if it doesn’t. Along the base of the typing area are a set of tabs. These
allow you to switch between multiple codes you may be simultaneously working
on. Since this is our ﬁrst use of the editor, MATLAB will have given this code
the default name Untitled.m.
To proceed we type the above code into the editor and then use the File Menu
(sub item Save As) to change the name of the code and Save it as twonums.m.
We will need to erase the current default name (Untitled.m) and type the new
ﬁlename. After a code has been named we can use the save icon (a little picture
of a disc) to save it, without the need to use the File Menu. If we now return
to the MATLAB window and enter the command twonums at the prompt, our
code will be executed; we will be asked to enter two numbers and MATLAB will
calculate, and return, their product and sum. The contents of the ﬁle can be
displayed by typing type twonums.
This simple example has introduced two new commands, input and num2str.
The input command prompts the user with the ﬂag contained within the quotes
’ ’ and takes the user’s response from the standard input, in this case the MAT-
LAB window. In the ﬁrst example it then stores our response in the variable
a. The second command num2str stands for number-to-string and instructs
MATLAB to convert the argument from a number, such as the result of a+b,
to a character string. This is then displayed using the disp.
It is very important you give your ﬁles a meaningful name and that
the ﬁles end with .m. You should avoid using ﬁlenames which are the
same as the variables you are using and which coincide with MATLAB
commands. Make sure you do not use a dot in the body of the ﬁlename
and that it does not start with a special character or a number.
Important Point

2.1 Creating Scripts and Functions
29
For instance myfile.1.m and 2power.m are not viable ﬁlenames (good al-
ternatives would be myfile 1.m and twopower.m respectively). Filenames also
have the same restrictions which we met earlier for variable names (see page
4). When processing a command, MATLAB searches to see if there is a user-
deﬁned function of that name by looking at all the ﬁles in its search path with
a .m extension. If you are in any doubt whether something is a MATLAB com-
mand use either the command help or the command which in combination
with the ﬁlename, for instance help load or which load for the MATLAB
command load.
You should consider creating a directory for your MATLAB work. For in-
stance on a Unix machine the sequence of commands (at the Unix prompt)




mkdir Matlab_Files
cd Matlab_Files
matlab
will create a directory (which obviously only needs to be done once), the sec-
ond command changes your working directory to Matlab Files and the third
command invokes MATLAB (to check that you are in the correct directory use
the command pwd to ‘print working directory’). In a Windows environment you
can use Explorer to create a new folder and then invoke MATLAB by clicking
on the MATLAB icon. On a Macintosh you can simply create a new directory
as you would a new folder2. Depending upon your computing platform you will
probably need to change to your new folder; the cd within MATLAB allows you
to change directories. In MATLAB6 you can use the ... symbol at the top of
the control environment to change the working directory and this is displayed
to the left of this symbol. It is also possible to access ﬁles from other direc-
tories by augmenting MATLAB’s search path. Again, this is platform-speciﬁc;
the following works on our Unix platforms




path(path,’/home/sro/MyMatlabFiles’)
On a Macintosh you can set the path by choosing Set Path from the MATLAB
File menu. With the search paths set it is possible to create and manage a
central resource of user written library functions which can be accessed from
any directory on your computer.
One of the most common sources of problems for the novice programmer
occurs when the wrong script is being run or when the computer cannot ﬁnd
the program you have just entered. This is usually because the ﬁle isn’t in
the correct directory, or is misnamed. You can check that a ﬁle is the correct
2 Under MacOS X you can use the standard Unix commands given above.

30
2. Writing Scripts and Functions
one by using the command type. The syntax for this command is simply type
file1; this will produce a listing of the MATLAB ﬁle file1.m. If the text is
not what you are expecting you may well be using a ﬁlename which clashes
with an existing MATLAB command. In order to see which ﬁle you are looking
at, type the command which file1. This will tell you the full pathname of the
listed ﬁles which can be compared with the current path by typing pwd. You
can also list the ﬁles in the current directory by typing dir or alternatively all
the available MATLAB ﬁles can be listed by using what: for more details see
help what.
Example 2.2 If we create a MATLAB ﬁle called power.m using the editor
it can be saved in the current directory: however the code will not work. The
reason for this can be seen by typing which power which produces the output
>> which power
power is a built-in function.
So MATLAB will try to run the built-in function.
2.1.1 Functions
In the previous sections we wrote codes which could be legitimately run at the
MATLAB prompt. We now discuss the important class of codes which actually
act as functions. These codes take inputs and return outputs. We shall start
with a very simple example:




function [output] = xsq(input)
output = input.ˆ2;
which we will save as xsq.m. It is important that we get the syntax for functions
correct so we’ll go through this example in some detail.
- The ﬁrst line of xsq.m tells us this is a function called xsq which takes an
input called input and returns a value called output. The input is contained
in round brackets, whereas the output is contained within square brackets.
It is crucial for good practice that the name of the function xsq corresponds
to the name of the ﬁle xsq.m (without the .m extension), although there is
some ﬂexibility here.
- The second line of this function actually performs the calculation, in this
case squaring the value of the input, and storing this result in the variable
output. Notice that the function uses dot arithmetic .ˆ so that this function

2.1 Creating Scripts and Functions
31
will work with both vector and matrix inputs (performing the operation
element by element). Notice also that we have suppressed the output of the
calculation by using a semicolon; in general all communication between a
function subroutine and the main calling program should be done through
the input and output.
Having written our function we can now access it from within MATLAB. Con-
sider the following:




x = 1:10;
y = xsq(x)
Here we have initialised the vector x to contain the ﬁrst ten integers. We call
the function in the second line and assign the result, in this case x.ˆ2, to
the variable y. Notice that we have called the function with the argument x
and not something called input. The variables input and output are local
variables that are used by the function; they are not accessible to the general
MATLAB workspace3. When the function is run it merely looks at what is
given as the argument. It is therefore important the function has the correct
input; in our example scalar, vector or matrix inputs are allowed. In other
cases, if the function expects an argument of a certain type then it must be
given one otherwise an error will occur (which will not always be reported
by MATLAB). Of course it is not possible to call the function just using xsq
since the code cannot possibly know what the input is. MATLAB will return
an error stating that the Input argument ’input’ is undefined. As noted
above this function can also be used for scalars, for instance xsq(2) returns
the value 4, and for vectors
>> A = [1 2 3 4 5 6];
>> y = xsq(A)
y =
1
4
9
16
25
36
Functions can also take multiple inputs and give multiple outputs. Consider
the following examples:
Example 2.3 Suppose we want to plot contours of a function of two variables
z = x2 + y2. We can use the code
3 You can ﬁnd out what variables are in use by MATLAB by typing who, which lists
all variables in use, or whos, which lists all variables along with their size and type.

32
2. Writing Scripts and Functions




function [output] = func(x,y)
output = x.ˆ2 + y.ˆ2;
which should be saved in the ﬁle func.m. The ﬁrst line indicates this is a func-
tion which has two inputs x and y, and returns a single output output. The
next line calculates the function x2 + y2; again we have used dot arithmetic to
allow for the possibility of vector or matrix arguments. For the calculation to
be valid the vectors x and y must have the same size. To plot the contours (that
is the level curves) of the function z = x2 + y2 we would proceed as follows:
'
&
$
%
x = 0.0:pi/10:pi;
y = x;
[X,Y] = meshgrid(x,y);
f = func(X,Y);
contour(X,Y,f)
axis([0 pi 0 pi])
axis equal
This gives us the plot
0
0.5
1
1.5
2
2.5
3
0
0.5
1
1.5
2
2.5
3
For the moment we do not need to worry about the plotting commands used to
display the curves: we will return to plotting in more detail later in this chapter.

2.1 Creating Scripts and Functions
33
It is just as important that the function receives the correct number of
inputs as it is that they are of the correct type. For example, we cannot
call our function using func or func(1) (or with arguments of diﬀerent
size). In all these cases MATLAB will give an error message.
Important Point
Example 2.4 Suppose we now want to construct the squares and cubes of the
elements of a vector. We can use the code




function [sq,cub] = xpowers(input)
sq = input.ˆ2;
cub = input.ˆ3;
Again, the ﬁrst line deﬁnes the function xpowers, which has two outputs sq and
cub and one input. The second and third lines calculates the values of input
squared and cubed. This function ﬁle must be saved as xpowers.m and it can
be called as follows:




x = 1:10;
[xsq,xcub] = xpowers(x);
This gives
>> xsq
xsq =
1
4
9
16
25
36
49
64
81
100
>> xcub
xcub =
Columns 1 through 6
1
8
27
64
125
216
Columns 7 through 10
343
512
729
1000
The output is two row vectors, one containing the values of the ﬁrst ten
integers squared and the second the values of the ﬁrst ten integers cubed. Notice
that when the function is called we must know what form of output we expect,

34
2. Writing Scripts and Functions
whether it be a scalar, a vector or a matrix. The expected outputs should be
placed within square brackets.
Example 2.5 As you might expect a function can have multiple inputs and
outputs:




function [out1,out2] = multi(in1,in2,in3)
out1 = in1 + max(in2,in3);
out2 = (in1 + in2 + in3)/3;
which should be saved as multi.m. This gives us a function called multi that
takes three inputs in1, in2 and in3 and returns two outputs out1 and out2.
The ﬁrst output is the sum of the ﬁrst input and the maximum of the latter
two, calculated using the MATLAB intrinsic function max. The second output
is simply the arithmetic mean (the average) of the inputs. We can call this
function in the following way




x1 = 2; x2 = 3; x3 = 5;
[y1,y2] = multi(x1,x2,x3);
y1, y2
For this example we obtain y1=7 and y2=3.3333.
The input and output of a function do not have to be the same size (although
in most cases they will be). Consider the following example:
Example 2.6 Consider a code which returns a scalar result from a vector in-
put. For example




function [output] = sumsq(x)
output = sum(x.ˆ2);
Our function sumsq takes a vector (or potentially a scalar) as an input and
returns the sum of the squares of the elements of the vector. The MATLAB
intrinsic function sum calculates the sum of its vector argument. For instance
x = [1 2 4 5 6];
y = sumsq(x)
sets y equal to the scalar 12 + 22 + 42 + 52 + 62 = 82.

2.1 Creating Scripts and Functions
35
2.1.2 Brief Aside
For those of you familiar with matrices we pause here and note that the com-
mand in the previous example will also work with matrices:
>> A=[1 2 3; 4 5 6];
>> sumsq(A)
ans =
17
29
45
The command has squared (and summed) the elements of the matrix A, which is
two-by-three. This has exploited the property that the sum command sums the
columns of a matrix. If we want to sum the rows of a matrix we use sum(A,2),
so that we have
>> sum(A,1)
% which is equivalent to sum(A)
ans =
5
7
9
>> sum(A,2)
ans =
6
15
Notice that the answers are the shape we would expect: the ﬁrst is a row vector
whereas the second is a column vector. Many of the MATLAB commands we
shall meet in this text, in general those commands which reduce the dimension
of the input object by one, can operate along the rows or the columns; which
is speciﬁed using an additional argument.
Many of MATLAB’s intrinsic commands work in the same way and so care
is needed to ensure that the correct number and form of inputs to functions
are used.

36
2. Writing Scripts and Functions
2.2 Plotting Simple Functions
One of the most powerful elements of MATLAB is its excellent plotting facilities
which allow us to easily and rapidly visualise the results of calculations. We have
already met some examples of plotting (the line graph plotting of the functions
and the contour plot on page 32). We pause here to try some examples of
the plotting facilities available within MATLAB. We start with the simplest
command plot and use this as an opportunity to revisit the ways in which
functions can be initialised. We start with initialising an array, in this case x




x = 0:pi/20:pi;
which as we know sets up a vector whose elements are

0, π
20, 2 π
20, · · · , 19 π
20, π
	
,
(that is, a vector whose elements range from 0 to π in steps of π/20). This array
is of size one-by-twenty one, which can be conﬁrmed by using the command
size(x) or, if we know it is a one-dimensional array as is the case here, by using
the command length(x) (in general length gives the maximum of the dimen-
sions of a matrix). We can plot simple functions, for instance plot(x,sin(x))
or more complicated examples such as
plot(x,sin(3*x),x,x.ˆ2.*sin(3*x)+cos(4*x))
(this plots sin 3x and x2 sin 3x + cos 4x). Try these examples out for yourself.
Now we have an array x we begin using it as an argument to other functions.
We start with calculating the point on a straight line 3x −1 using




y = 3*x-1;
Again size(y), or length(y), conﬁrms that this array has the same dimensions
as the vector x. We can plot y versus x using the command plot(x,y) to
produce a straight line (in the default colour blue). You can change the colour
or style of the line, or force the individual data points to be plotted, using
a third argument for the plot command; more details will be given later on
page 45.
Proceeding to polynomials, the code




y = x.ˆ2+3;
produces a vector y whose elements are given by the quadratic x2 + 3. No-
tice that by using the dot before the operator (here exponentiation ˆ) we are
performing the operation element by element on the array x.

2.2 Plotting Simple Functions
37
Example 2.7 To plot the quadratic x2 +7x−3 from x equals −3 to 3 in steps
of 0.2 we use the code




x = -3:0.2:3;
y = x.ˆ2+7*x-3;
grid on
plot(x,y)
The resulting plot is given below
−3
−2
−1
0
1
2
3
−15
−10
−5
0
5
10
15
20
25
30
We have given the plot a grid by using the command grid on; this can be
removed using the command grid off.
MATLAB provides an excellent computing environment for producing re-
sults which can be viewed quickly and easily. This is essential when we come
to analyse the results of our calculations, a task that is usually necessary in
order to obtain useful information from an otherwise mathematical calcula-
tion. MATLAB is capable of producing very intricate and clear plots, as the
following example illustrates.
Example 2.8 Consider the following code:

38
2. Writing Scripts and Functions
'
&
$
%
x = 0:pi/20:pi;
n = length(x);
r = 1:n/7:n;
y = x.ˆ2+3;
plot(x,y,’b’,x(r),y(r),’r*’)
axis([-pi/3 pi+pi/3 -1 15])
xlabel(’x values’)
ylabel(’Function values’)
title(’Demonstration plot’)
text(pi/10,0,’\alpha=\betaˆ2’)
If we dissect this piece of code we see the ﬁrst line initializes the vector x.
The second and third lines pick out every third integer value between 1 and
length(x). The fourth line computes the values of the quadratic y = x2 + 3
at the points in the vector x (using dot arithmetic to achieve this). We then
reach the plot command. Here we are telling MATLAB to plot the curve y
versus x and to colour the plot blue (using the ﬂag ’b’). The second part of
the plot command tells MATLAB to plot every third point on the curve (here
represented by x(r) and y(r)) as points which are labelled with a red asterisk
using ’r*’. The commands directly following the plot command are used to
manipulate the ﬁnal look of the plot. The command axis sets the start and
end points of the horizontal (from −π/3 to π + π/3) and then the vertical
axis (from −1 to 15). The commands xlabel and ylabel add labels to the
horizontal and vertical axes and the command title, not surprisingly adds the
title to the ﬁgure. The command text allows the user to add text to the ﬁgure
at a coordinate speciﬁed within the units of the plot. The arguments of these
commands include a string which starts and ends with a quotation mark. The
text can include many characters but here we have included Greek letters, using
the LATEX4 construction \alpha for α and \beta for β. The properties of a ﬁgure
can be edited using the drop down menus on its window. This includes being
able to increase the size of the characters used in labels. By changing the line
which sets the title to
title(’Demonstration plot’,’FontSize’,24)
we see quite a dramatic change in the size of the characters in the title.
4 LATEX is a language that is almost universally used for typesetting mathematics.
It is available for almost all computing platforms and operating systems. Further
details can be found by consulting any good LATEX text.

2.2 Plotting Simple Functions
39
−1
−0.5
0
0.5
1
1.5
2
2.5
3
3.5
4
0
5
10
15
x values
Function values
Demonstration plot
α=β2
There are a wide variety of other plotting options available. For instance
loglog(x,y) produces a log-log plot. Similarly semilogx and semilogy pro-
duces a log plot for the x and y-axis, respectively. You should also be aware of
the commands clf which clears the current ﬁgure and hold which holds the
current ﬁgure. We will explore the use of these commands in the tasks at the
end of this section.
One of the excellent features of MATLAB is the way in which it handles
two and three-dimensional graphics. Although we will have little need to exploit
the power of MATLAB’s graphical rendering we should be aware of the basic
commands. Examples serve to highlight some of the many possibilities:
'
&
$
%
x = linspace(-pi/2,pi/2,40);
y = x;
[X,Y] = meshgrid(x,y);
f = sin(X.ˆ2-Y.ˆ2);
figure(1)
contour(X,Y,f)
figure(2)
contourf(X,Y,f,20)
figure(3)
surf(X,Y,f)
This gives the three ﬁgures

40
2. Writing Scripts and Functions
−1.5
−1
−0.5
0
0.5
1
1.5
−1.5
−1
−0.5
0
0.5
1
1.5
−1.5
−1
−0.5
0
0.5
1
1.5
−1.5
−1
−0.5
0
0.5
1
1.5
−2
−1
0
1
2
−2
−1
0
1
2
−1
−0.5
0
0.5
1
These ﬁgures are, respectively, a contour plot (created using contour(X,Y,f)),
a ﬁlled contour plot with 20 contour levels (created using contourf(X,Y,f,20)
and a surface plot (created using surf(X,Y,f)). The function f is plotted on
a grid generated using the command meshgrid(x,y). As the name suggests

2.2 Plotting Simple Functions
41
meshgrid sets up a grid of points by generating copies of the x and y values;
see help meshgrid for details of this command. To further explore the potential
of MATLAB’s plotting facilities see the MATLAB demo topics Visualization
and Language/Graphics.
2.2.1 Evaluating Polynomials and Plotting Curves
We return to the topic of functions by ﬁrst constructing a simple program to
evaluate a quadratic. We shall start with a code to generate the value of a
speciﬁc quadratic at a speciﬁc point:




x = 3;
y = xˆ2+x+1;
disp(y)
This code sets x equal to 3, calculates x2 + x + 1 and then displays the answer.
We now expand the above code so that the user can enter the point and the
coeﬃcients of the quadratic. In general suppose we have the general quadratic
y = a2x2 + a1x + a0.
Firstly we need to deﬁne the quadratic and this is done by ﬁxing the three
coeﬃcients a0, a1 and a2. This can be done using the following script, which
we will call quadratic.m
'
&
$
%
% quadratic.m
% This program evaluates a quadratic
% at a certain value of x
% The coefficients are stored in a2, a1 and a0.
%
SRO & JPD
%
str = ’Please enter the ’;
a2 = input([str ’coefficient of x squared: ’]);
a1 = input([str ’coefficient of x: ’]);
a0 = input([str ’constant term: ’]);
x = input([str ’value of x: ’]);
y = a2*x*x+a1*x+a0;
% Now display the result
disp([’Polynomial value is: ’ num2str(y)])
Again we have a code where the ﬁrst few lines of the code start with a
percent sign %. MATLAB treats anything coming after a % sign as a comment.

42
2. Writing Scripts and Functions
Comments at the start of a code have a special signiﬁcance in that they are
used by MATLAB to provide the entry for the help manual for that particular
script. The manual entry can then be accessed by typing help quadratic at
the MATLAB prompt to produce
quadratic.m
This programme evaluates a quadratic
at a certain value of x
The coefficients are stored in a2, a1 and a0.
SRO & JPD
Notice the manual entry terminates once MATLAB reaches a line in the ﬁle
quadratic.m in which the ﬁrst character is not a % sign. The line later on in
the code which starts with a percent sign is again a comment. In this case we
have inserted this line to provide information to the user about the calculation
which is to be performed; in this case display the result of our calculation.
Judicious use of comments throughout a code makes it readable by a person
who may not be fully conversant with the precise details of the calculations to
be performed. It is good programming practice to insert text as a manual entry
at the start of any code as well as including comments on particular aspects of
the calculation which may not be transparent to the user of the code. Note it
is also possible to obtain a complete listing of the code from within MATLAB
by typing type quadratic at the prompt.
Back to our code. The ﬁrst three non-comment lines use the input command
to prompt the user to enter the values of the constants a2, a1 and a0. As we
saw earlier the input command takes an argument in the form of a character
string, contained between quotes, that acts as the prompt which appears on
the screen. Here we have introduced a variable str which is equal to ’Please
enter the ’, a phrase which is common to each of the input statements. The
argument to input is then a vector containing strings. Notice in this example
we have appended to the prompt a colon followed by a space so that when the
user types the values, rather than them being ﬂush against the ﬁnal character,
there is a space. This is not necessary but simply a style convention we will
usually adopt.
For the moment we shall assume the user responds to the prompts by en-
tering values which are reasonable. The user is then prompted for the value of
x at which they wish to evaluate the polynomial. The following line actually
does the calculation of evaluating the polynomial; at this stage we have used
the fact that x2 = x×x, but of course we could use a2*xˆ2+a1*x+a0. There are
many ways of writing polynomials, for instance this could have been written
recursively as
a0 + x(a1 + xa2).
(2.1)

2.2 Plotting Simple Functions
43
This general recursive form goes under the name of Horner’s method. With
the function evaluated the answer is displayed, using the function num2str
(‘number-to-string’) which takes as input a number and returns a character
string which is then appended to the phrase ’Polynomial value is: ’. The
concatenation (joining together) of strings is achieved by writing them as ele-
ments in a row vector and then using the disp function to write them to the
screen.
There is no obvious reason why we couldn’t type the commands given above
at the MATLAB prompt and enter all the values required for the calculation
to proceed. However, it is preferable to carry out the calculation by simply
typing the command quadratic; this also allows us to have access to a general
program which calculates the value of a quadratic. An even better approach is
to write a user callable function. We will use this example to build up the level
of complexity of the function until we have one which is as general as we can
possibly make it.
Firstly let’s suppose the values of the coeﬃcients in the quadratic are known
a priori5. For example, suppose we want to evaluate the quadratic y = 3x2 +
2x + 1. We could then use the function
#
"
 
!
%
% evaluate_poly.m
%
function [value] = evaluate_poly(x)
value = 3*x.ˆ2+2*x+1;
Here we have again used dot arithmetic in the construction x.ˆ2, thus making
this function able to take both a scalar or vector (or even a matrix) argument.
As we have seen earlier if this function is called with a vector, then a vector is
returned as output.
Now we can use the function evaluate poly, in the form evaluate poly(2)
or x = 2;y = evaluate poly(x). Note within MATLAB we are able to call a
function with a variety of diﬀerent inputs; whether this is valid depends upon
the structure of the function6. With this in mind we can now use our function
to generate a vector containing the values of the polynomial at a number of x
points and plot the result using
>> x = -5:0.5:5;
5 A very similar command already exists in MATLAB, namely polyval, but this
function is developed to demonstrate the construction.
6 This is similar to the idea of overloading which is intrinsic to object orientated
languages like C++ and Java. However, in those languages a diﬀerent function
is called depending on the type of input, whereas here it is one function which
apparently deals with all the cases.

44
2. Writing Scripts and Functions
>> y = evaluate_poly(x);
>> plot(x,y)
which gives
−5
−4
−3
−2
−1
0
1
2
3
4
5
0
10
20
30
40
50
60
70
80
90
2.2.2 More on Plotting
At this point we brieﬂy return to the problem of generating plots using MAT-
LAB. The simple code given above ﬁrst sets up a vector which runs from x = −5
to x = 5 in steps of 0.5. The value of the quadratic at each point is then calcu-
lated, using our newly deﬁned function. The ﬁnal plot(x,y) command ‘simply’
draws a line through these points. The way the plot is constructed can best
be seen by making the x-grid coarser (that is, with less points); we then ﬁnd
the plot is constructed by drawing a straight line through each pair of points.
MATLAB is slightly more subtle than this in that it checks whether there is a
window open ready for plotting, and if not it opens one. The axes are automati-
cally rescaled and tick marks are drawn. The default settings are generally ﬁne,
although at some points you may want to look at certain regions of the plot.
At the moment we will not worry about the details of how this is achieved7.
In general we shall introduce the features of the plotting package as we need
them. Here we extend our plotting capability by considering the impact of a
7 Try the commands h = gca. This returns what MATLAB calls a ‘handle’ to the
current axis, and then the function get(h) lists all the properties of the axis. There
is also a command gcf which returns a handle to the entire ﬁgure.

2.2 Plotting Simple Functions
45
third argument of the plot command, such as in plot(x,y,’r.’). The string
which is passed as the third argument conveys information as to how the plot
should be presented: here the ﬁrst character r is the colour (red) and the second
is the symbol (in this case a dot .) to be used at each point (as opposed to a
line joining the points). The colour options are
y
yellow
m
magenta
c
cyan
r
red
g
green
b
blue
w
white
k
black
and the choice of symbols are
.
point
v
triangle (down)
o
circle
X
triangle (up)
x
x-mark
<
triangle (left)
+
plus
>
triangle (right)
*
star
p
pentagram
s
square
h
hexagram
d
diamond
It is also possible to control the line style. Instead of using a symbol, as in the
previous command, we can draw the line using one of the following options:
-
solid
:
dotted
-.
dashdot
- -
dashed
As we saw earlier (on page 38) we can also plot more than one curve on the
same graph. One simple way of achieving this is through the following code
>>x = -pi:pi/20:pi;
>>plot(x,sin(x),’r-’,x,cos(x),’b:’)
This generates the plot

46
2. Writing Scripts and Functions
−4
−3
−2
−1
0
1
2
3
4
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
from which the command syntax can be deduced; a plot of sin(x) versus x using
a solid red line and a plot of cos(x) versus x using a blue dotted line (if the plot
were to be viewed in colour). This could have been achieved in another way
'
&
$
%
x = -pi:pi/20:pi;
clf
plot(x,sin(x),’r-’)
hold on
plot(x,cos(x),’b:’)
hold off
As you might infer from this, using the command plot clears the current plot
and replaces it with the new ﬁgure, unless the ﬁgure is being “held”. So here
we plot sin(x), hold this current ﬁgure using hold on and then plot cos(x).
The current ﬁgure is released using hold off.
We could add a legend to this plot to help us identify which line is which.
This is accomplished with the command
legend(’sine’,’cosine’)
which now gives

2.2 Plotting Simple Functions
47
−4
−3
−2
−1
0
1
2
3
4
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
sine
cosine
In this case the legend has been placed in the top right corner, however its
location can be changed, see help legend for details.
We now return to our discussion of functions and consider in more detail
functions which can be called with more than one argument and return as many
arguments as we wish. In constructing functions we do need to take some care
with how our outputs are returned; we have already seen that if the function is
called with a vector then the “output” is, in general, a vector. However, there
is no reason why there should not be two (or more) outputs returned. Consider
the following modiﬁcation to the function evaluate poly from page 43
'
&
$
%
%
% evaluate_poly2.m
%
function [f, fprime] = evaluate_poly2(x)
f = 3*x.ˆ2+2*x+1;
fprime = 6*x+2;
This MATLAB function calculates the values of the polynomial and its deriv-
ative. This could be called using the sequence of commands




x = -5:0.5:5;
[func,dfunc] = evaluate_poly2(x);
We can further generalise our code by passing the coeﬃcients of the quadratic
to the function, either as individual values or a vector. The code then becomes

48
2. Writing Scripts and Functions
'
&
$
%
%
% evaluate_poly3.m
%
function [f,fprime] = evaluate_poly3(a,x)
f = a(1)*x.ˆ2+a(2)*x+a(3);
fprime = 2*a(1)*x+a(2);
which can be called using




x = -5:0.5:5;
a = [1 2 1];
[f,fp] = evaluate_poly3(a,x);
Before proceeding, we make one ﬁnal comment regarding the general form for
function ﬁles. The only communication between the function and the calling
program is through the input and output variables; the function should not
prompt a user for input nor should it echo the result of any calculation. This is
not a necessary constraint on MATLAB functions but more a useful program-
ming convention which is worth following.
This fairly simple routine evaluate poly3(x) was chosen to demonstrate
some of the particulars of MATLAB function ﬁles because MATLAB has a
built-in function, called polyval, which also evaluates polynomials. The extract
from help polyval yields the information
Y = POLYVAL(P,X), when P is a vector of length N+1 whose elements
are the coefficients of a polynomial, is the value of the
polynomial evaluated at X.
Y = P(1)*XˆN + P(2)*Xˆ(N-1) + ... + P(N)*X + P(N+1)
Care needs to be taken with the order in which the coeﬃcients of the polyno-
mial are presented. In fact these are in the same order as in our routine. This
example provides a good opportunity to investigate the full code for this built-
in function; the code listing can be obtained using type polyval. Compare
this with our three-line function evaluate poly3(x).
Example 2.9 We can use polyval to evaluate polynomials. We will use it
to test a hypothesis that the values of n2 + n + 41, where n is an integer, are
prime (at least for the ﬁrst few integer values of n: obviously this is not so for
n = 41). Consider

2.3 Functions of Functions
49




p = [1 1 41];
x = 1:40;
f = polyval(p,x);
isprime(f)
the function isprime(f) returns a value of 1 if the element of f is a prime and
0 if it is not. The result of our calculation is a string of 39 ones demonstrating
that all but the value for n = 40 are prime (402 +40+41 = 40×(40+1)+41 =
41 × (40 + 1) = 412). We note that the value of quadratic n2 −n + 41 is also
prime for all integers up to and including n = 40.
2.3 Functions of Functions
One MATLAB command which provides us with considerable freedom in writ-
ing versatile code is the command feval which loosely translates as function
evaluation. The simplest use for this command is




y= feval(’sin’,x);
evaluate the function sin at x. This is equivalent to sin(x). In general the argu-
ments for feval are the name of the function, which must be either a MATLAB
built-in function or a user deﬁned function, contained between quotes, and the
value (or values in the case of a vector) at which the function is to be evaluated.
The utility of feval is that it allows us to use function names as arguments.
By way of introduction we provide an example. Consider the function
h(x) = 2 sin2 x + 3 sin x −1.
One way of writing code that would evaluate this function is




function [h] = fnc(x)
h = 2*sin(x).*sin(x)+3*sin(x)-1
However we can recognise this function as a composition of two functions g(x) =
sin(x) and f(x) = 2x2 + 3x −1 so that h(x) = f(g(x)). We can easily write a
function ﬁle f.m to evaluate f(x)




function [y] = f(x)
y = 2*x.ˆ2+3*x-1;

50
2. Writing Scripts and Functions
(using dot arithmetic to allow for the possibility of vector arguments x). To
use this in calculating the value of the composite function h(x) we need to be
able to pass the function name to f as an argument. We can do this with the
following modiﬁcation to our code




function [y] = f(fname,x)
z = feval(fname,x);
y = 2*z.ˆ2+3*z-1;
Calculating the function h(x) is now as simple as




x = -pi:pi/20:pi;
y = f(’sin’,x);
plot(x,y)
This gives a plot of the function h(x) as
−4
−3
−2
−1
0
1
2
3
4
−3
−2
−1
0
1
2
3
4
A more useful example is given by the function plotf
'
&
$
%
function plotf(fname,x)
y = feval(fname,x)
plot(x,y)
grid on
axis([min(x) max(x) min(y) max(y)])
xlabel(’x’)
ylabel([fname ’(x)’])

2.4 Errors
51
This function takes as input a function name and a vector x and produces a
labelled plot. Notice although there are two inputs for this function there are
no values output; the ﬁgure is the output.
−3
−2
−1
0
1
2
3
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
x
sin(x)
The command feval has a wide range of uses, some of which we will exploit
later throughout the text.
2.4 Errors
2.4.1 Numerical Errors
We mentioned right at the start of this text that numerical methods are usually
not exact (that is, they are approximate methods). In fact it is very hard to get
computers to perform exact calculations. If we add (or subtract) integers then a
computer can be expected to get the exact answer, but even this operation has
its limits. Once we try to perform the division operation we run into trouble.
We are happy with the fact that one divided by three is a third, which we can
write as 1/3, but if we need to store this on a computer we run into diﬃculties.
For the moment let’s suppose we have a virtual computer that works in
decimal. By this we mean that any number which can be written as a termi-
nating decimal (that is, one which stops), can be stored ‘exactly’ (provided we
do not require too many digits). We know that a third does not have a ﬁnite
representation, so there is no way we can store this number in our imaginary

52
2. Writing Scripts and Functions
computer other than by truncating the sequence. We would use the notation
1/3 ≈0.3333. Obviously the more three’s we retain the more accurate the
answer.
Almost all numerical schemes are prone to some kind of error. It is important
to bear this in mind and understand the possible extent of the error. Intrinsic
to this has to be the knowledge of how much we can trust the results which are
produced. Errors can be expressed as two basic types:
Absolute error: This is the diﬀerence between the exact answer and the
numerical answer.
Relative error: This is the absolute error divided by the size of the answer
(either the numerical one or the exact one), which is often converted to a
percentage.
(In each case we take the modulus of the quantity.)
Example 2.10 Suppose an error of £1 is made in a ﬁnancial calculation of in-
terest on £5 and on £1,000,000. In each case the absolute error is £1, whereas
the relative errors are 20% and 0.0001% respectively.
Example 2.11 Suppose a relative error of 20% is made in the above interest
calculations on £5 and £1,000,000. The corresponding absolute errors are £1
and £200,000.
Example 2.12 Estimate the error associated with taking 1.6 to be a root of
the equation x2 −x −1 = 0.
The exact values for the roots are (1 ±
√
5)/2 (let us take the positive root).
As such the absolute error is





1 +
√
5
2
−1.6





 ≈0.01803398874989
and the relative error is the absolute error divided by the value 1.6 (or alter-
natively the exact root) which is approximately equal to 0.01127124296868 or
1.127%.
We could also substitute x = 1.6 into the equation to see how wrong it is:
1.62 −1.6 −1 = −0.04. Although it is diﬃcult to understand how this can
be used, it is often the only option (particularly if the exact answer cannot be
found).
This method can be used to determine roots of a function. We now discuss
an example which uses this technique:

2.4 Errors
53
Example 2.13 Determine a value of x such that
f(x) = x2 + 4x = 40.
We start by guessing that x = 6 is the root we require:
x = 6, f(6) = 60 > 40 which is too big, try x = 5.
x = 5, f(5) = 45 > 40 which is still too big, try x = 4.
x = 4, f(4) = 32 < 40 now this is too small, so we shall try x = 4.5.
x = 4.5, f(4.5) = 38.25 < 40 a bit too small, try x = 4.75
x = 4.75, f(4.75) = 41.5625 > 40 a bit too big, back down again to x = 4.625
x = 4.625, f(4.625) = 39.890625 < 40 a bit too small, back up again to x =
(4.75 + 4.625)/2
x = 4.6875, f(4.6875) = 40.72265625 > 40 and we can continue this process.
Here we have just moved around to try to ﬁnd the value of x such that f(x) =
40, but we could have done this in a systematic manner (actually using the size
of the errors).
It appears that in order to work out the error one needs to know the exact
answer in which case the whole idea of an error would seem to be superﬂuous.
In fact when we focus on errors we are merely trying to work out their size (or
magnitude) rather than their actual numerical value.
Before we move on we revisit the MATLAB variable eps. This is deﬁned as
the smallest positive number such that 1+eps is diﬀerent from 1. Consider the
calculations:




x1 = 1+eps;
y1 = x1-1
x2 = 1+eps/2;
y2 = (x2-1)*2
In both cases using simple algebra you would expect to get the same answer,
namely eps; but in fact y2 is equal to zero. This is because MATLAB cannot
distinguish between 1 and 1+eps/2. The quantity eps is very useful, especially
when it comes to testing routines.
Example 2.14 Calculate the absolute errors associated with the following cal-
culations:

54
2. Writing Scripts and Functions




sin(15*pi)
(sqrt(2))ˆ2
1000*0.001
1e10*1e-10
To calculate the absolute errors we need to know the exact answers which are
0, 2, 1 and 1 respectively. We can use the code:




abs(sin(15*pi))
abs((sqrt(2))ˆ2-2)
abs(1000*0.001-1)
abs(1e10*1e-10-1)
(notice in the last case the exponent form of the number takes precedence in the
calculation: we could of course make sure of this using brackets). The errors
are 10−15, 10−16 and zero (in the last two cases).
2.4.2 User Error
The elimination of user error is critical in achieving accurate results. In practice
user error is usually more critical than numerical errors, and after some practise
their identiﬁcation and elimination becomes easier. User error is avoidable,
whereas many numerical errors are intrinsic to the numerical techniques or the
computational machinery being employed in the calculation.
The most severe user errors will often cause MATLAB to generate error
messages; these can help us to understand and identify where in our code we
have made a mistake. Once all the syntax errors have been eliminated within
a code (that is MATLAB is prepared to run the code), the next level of errors
are harder to ﬁnd. These are usually due to:
1. An incorrect use of variable names.
This may be due to a typographical error which has resulted in changes
during the coding.
2. An incorrect use of operators.
The most common instance of this error occurs with dot arithmetic.
3. Syntactical errors which still produce feasible MATLAB code.
For instance in order to evaluate the expression cos x, we should use cos(x):
unfortunately the expression cos x also yields an answer (which is incor-

2.4 Errors
55
rect); somewhat bizarrely cos pi yields a row vector (which has the cosines
of the ASCII values of the letters p and i as elements).
4. Mathematical errors incorporated into the numerical scheme the code seeks
to implement.
These usually occur where the requested calculation is viable but incorrect
(see the example on page 181).
5. Logical errors in the algorithm.
This is where an error has occurred during the coding and we ﬁnd we are
simply working out what is a wrong answer.
Avoiding all of these errors is something which only comes with practice and
usually after quite a lot of frustration. The debugging of any program is diﬃcult,
fortunately in MATLAB we have the luxury of being able to access variables
straight away. This allows us to check results at any stage. Simply removing
the semicolons from a code will cause the results to be printed. Although this
is not recommended for codes which will produce a deluge of results, it can be
very useful.
In Task 2.10 at the end of this chapter and similarly in other chapters8, we
have included some codes with deliberate errors. They also contain commands
from future chapters: however most of the errors do not rely on understanding
the nuances of these unfamiliar commands. Hopefully by trying to locate the
errors in these you should start to develop the debugging skills which will
eventually ensure you become a competent programmer.
We shall start with a couple of examples which demonstrate some of the
most common sources of problems. Of course it is impossible to predict all
possible errors which could be made, but the more you are aware of the better!
Example 2.15 This code purports to obtain three numbers a, b and c from a
user and then produce the results a + b + c, a/((b + c)(c + a)) and a/(bc).
8 These tasks are marked with (D).

56
2. Writing Scripts and Functions
'
&
$
%
a = input(’ Please entere a )
b = 1nput(’ Please enter b )
a = Input ’ Please enter c ’
v1 = a+ B+d
v2 = a/((b+c)(c+a)
v3 = a/b*c
disp(’ a + b + c= ’ int2str(v1)])
disp([’v2 = ’ num2str v2 ]
disp([’v3 =
num2str(v4) ]);
We shall now work through the lines one-by-one detailing where the errors are
and how they can be ﬁxed.
a = input(’ Please entere a ) Firstly the single left-hand quote mark should
be balanced by a corresponding right-hand quote mark. The command should
also end with a semicolon. This will stop the value of a being printed out
after it is entered. The misspelling of the word enter is annoying but will
not actually aﬀect the running of the code: however it is worth correcting
if only for presentation’s sake.
b = 1nput(’ Please enter b ) Again we have an imbalance in the single
quote mark and the lack of a semicolon. We also have the fact that input
has become 1nput.
a = Input ’ Please enter c ’ Here we have a capitalised command (which
MATLAB will actually point out in its error message – try typing Input
in MATLAB). Again we are missing the semicolon, but the more severe
errors here are the lack of brackets around the message and the fact that
we are resetting the variable a. This erases the previous value of a and also
does not set the value of c as we intended.
v1 = a+ B+d The spacing is unimportant and is merely a matter of style. Here
again we should add a semicolon. The main problem here is that the variable
b has been capitalized to B and since MATLAB is case sensitive these are
treated as diﬀerent variables. Another new variable d has also slipped in.
This means MATLAB will either complain that the variable has not been
initialised or will use a previous value which has nothing to do with this
calculation. To avoid this it is a good idea to start the code with clear all
to clear all variables from memory.
v2 = a/((b+c)(c+a) This command presents a number of errors in the eval-
uation of the denominator of the fraction. The ﬁrst of these is the missing

2.5 Tasks
57
asterisk between the two factors and secondly we have a unbalanced bracket.
v3 = a/b*c This has one error but it is one of the most common ones. As
mentioned previously this evaluates
 a
b

c. We need to force the calculation
bc to be performed ﬁrst by using brackets. With this (and the previous two
commands we might want to elect to add semicolons to stop extra output).
disp(’ a + b + c= ’ int2str(v1)]) This command is missing a left square
bracket to show that we are going to display a vector (with strings as ele-
ments). We have used the command int2str which takes an integer and
returns a character string. However at no point have we speciﬁed that a,
b and c are integers. We should instead use the command num2str which
converts a general number to a character string.
disp([’v2 = ’ num2str v2 ] This command is missing a round bracket from
the end of the expression and a pair of brackets to show that num2str is
being applied to the variable v2.
disp([’v3 = num2str(v4) ]); Here we are missing a single quote to show
that the string has ended (after the equals sign). We have also erroneously
introduced a new variable v4 which should be v3. The semicolon on the end
of this line is superﬂuous since the disp command displays the result.
The corrected code looks like:
'
&
$
%
clear all
a = input(’ Please enter a ’);
b = input(’ Please enter b ’);
c = input(’ Please enter c ’);
v1 = a+b+c;
v2 = a/((b+c)*(c+a));
v3 = a/(b*c);
disp([’ a + b + c= ’ num2str(v1)])
disp([’ v2 = ’ num2str(v2)])
disp([’ v3 = ’ num2str(v3)])
2.5 Tasks
Task 2.1 Enter and run the code

58
2. Writing Scripts and Functions
'
&
$
%
a = input(’Enter a : ’);
b = input(’Enter b : ’);
res = mod(a,b);
str1 = ’The remainder is ’;
str2 = ’
when ’ ;
str3 = ’ is divided by ’;
disp([str1 num2str(res) str2 ...
num2str(a) str3 num2str(b)]);
which should be saved as remainders.m. Experiment with this code by running
it with various values for a and b. Make sure you understand how this code
works, in particular the mod command and the disp command.
Task 2.2 Modify the code in Task 2.1 so it returns the answer to ab and change
the character strings str1, str2 and str3 so that the format of the answer is
‘The answer is ab when a is raised to the power b’.
Task 2.3 Write a code which takes a variable x and returns the value of 2x.
Make sure that your code works for variables which are scalars, vectors and
matrices.
Task 2.4 By modifying the function func.m (given earlier on page 32) repeat
the example for the functions x2 −y2 and then sin(x + y) (extending the range
to [0, 2π] in the latter case).
Task 2.5 Modify the code xpowers.m to simultaneously give the values of the
functions sin x, cos x and sin2 x + cos2 x.
Task 2.6 Modify the code multi.m in Example 2.5 to work out the values of
the map:
x →
(x + y)|1
y →
(x + 2y)|1,
where (a|b) is the remainder when a is divided by b and can be calculated using
the MATLAB function mod. If b is unity this is the fractional part. This new
function will take two inputs and return two outputs.

2.5 Tasks
59
Task 2.7 The code




clear x y
x = -2:0.1:2;
y = 9-x.ˆ2;
plot(x,y)
plots the function y = 9 −x2 for x ∈[−2, 2] in steps of 1/10. Modify the code
so the function y = x3 + 3x is plotted between the same limits and then for
x ∈[−4, 6] in steps of 1/4. (If you can’t see the current ﬁgure, type figure(1)
which should bring it to the foreground). This code can be run from the prompt
or can be entered using edit and then saved.
Task 2.8 Consider the quartic y = x4 + x2 + a. For which values of a does the
equation have two real roots?
Task 2.9 Plot on the same graph the functions f(x) = x + 3, g(x) = x2 + 1,
f(x)g(x) and f(x)/g(x) for the range x ∈[−1, 1]. (You need to decide how
many points to use to get a smooth curve, and whether to set up the vector x
either using the colon construction or linspace). You also need to remember
to use dot arithmetic since you are operating on vectors.
Task 2.10 (D) This task contains codes which are written with deliberate mis-
takes. You should try to debug the codes so that they actually perform the cal-
culations they are supposed to:
1. Perform the calculations
x = 4
x + 2 = y
z =
1
y2π




x=4
x+2=y
z=1/yˆ2Pi
2. Calculate the sum
N

i=1
1
i +
1
(i + 2)(i + 3)

60
2. Writing Scripts and Functions
where the user inputs N.
'
&
$
%
N=input(’Enter N )
for i=1:n
sum = 1/j + 1/(j+2)*(j+3)
end
disp( ’ The answer is ’ s])
Make sure the code gives the correct answer, for instance for N = 1.
3. Calculate the function
f(x) =
x cos x
(x2 + 1)(x + 2)
for x from 0 to 1 in steps of 0.1.




x==0.0:0.1:1.0;
f=xcos x/*([xˆ2+1]*(x+2)
4. Set up the vector 1 3 3 3 5 3 7 3 9
'
&
$
%
w = ones(9);
w(1) = 1;
for j = 1:4
w(2j) = 3:
w(2j+1) = 2j+1:
Make sure that the code returns the correct values of the entries of w.
Task 2.11 The following codes should be written to produce conversion between
speeds in diﬀerent units.

2.5 Tasks
61
(a) Construct a code which converts a speed in miles per hour to kilometres per
hour.
(b) Write a code which converts metres per second to miles per hour and use
it to determine how fast a sprinter who runs the 100 metres in 10 seconds
is travelling in miles per hour (on average).
(c) Rewrite your code from part (a) so that it is now a function that takes a
single input, the speed in miles per hour, and returns a single output, the
speed in kilometres per hour.
(d) Now modify the code you wrote in part (b) to determine the sprinter’s speed
in kilometres per hour by calling the function from the previous part.
(NB: 1 mile = 1760 yards; 1 yard = 36 inches; 1 inch = 2.54 cm; 1 m = 100
cm)
Task 2.12 The functions f(x) and g(x) are deﬁned by
f(x) =
x
1 + x2 and g(x) = tan x.
Write MATLAB codes to calculate these functions and plot them on the interval
(−π/2, π/2). Also plot the functions f(g(x)) and g(f(x)) on this interval.
Task 2.13 Write a code which enables a user to input the coeﬃcients of a
quadratic q(x) = ax2 + bx + c and plot the function q(x) for x = sin y where
y ∈[0, π].

3
Loops and Conditional Statements
3.1 Introduction
We now consider how MATLAB can be used to repeat an operation many times
and how decisions are taken. We shall conclude with a description of a condi-
tional loop. The examples we shall use for demonstrating the loop structures
are by necessity simplistic and, as we shall see, many of the commands can be
reduced to a single line. The true power of computers comes into play when we
need to repeat calculations over and over again.
In order to help you to understand the commands in this chapter, it is
suggested that you work through the codes on paper. You should play the rˆole
of the computer and make sure that you only use values which are assigned at
that time. Remember that computers usually operate in a serial fashion and
that they can only use a variable once it has been deﬁned and given a value.
This kind of thought process is very helpful when designing your own codes.
3.2 Loops Structures
The basic MATLAB loop command is for and it uses the idea of repeating an
operation for all the elements of a vector. A simple example helps to illustrate
this:

64
3. Loops and Conditional Statements
'
&
$
%
%
% looping.m
%
N = 5;
for ii = 1:N
disp([int2str(ii) ’ squared equals ’ int2str(iiˆ2)])
end
This gives the output
1 squared equals 1
2 squared equals 4
3 squared equals 9
4 squared equals 16
5 squared equals 25
The ﬁrst three lines start with % indicating that these are merely comments
and are ignored by MATLAB. They are included purely for clarity, and here
they just tell us the name of the code. The fourth line sets the variable N equal
to 5 (the answer is suppressed by using the semicolon). The for loop will run
over the vector 1:N, which in this case gives [1 2 3 4 5], setting the variable
ii to be each of these values in turn. The body of the loop is a single line which
displays the answer. Note the use of int2str to convert the integers to strings
so they can be combined with the message “ squared equals ”. Finally we have
the end statement which indicates the end of the body of the loop.
We pause here to clarify the syntax associated with the for command:




for ii = 1:N
commands
end
This repeats the commands for each of the values in the vector with ii=
1, 2, · · · , N. If instead we had for ii = 1:2:5 then the commands would be
repeated with ii equal to 1, 3 and 5. Notice in the code above we have indented
the disp command. This is to help the reading of the code and is also useful
when you are debugging. The spaces are not required by MATLAB. If you use
MATLAB built-in editor (using the command edit) then this indentation is
done automatically.
Example 3.1 The following code writes out the seven times table up to ten
seven’s.

3.2 Loops Structures
65
'
&
$
%
str = ’ times seven is ’;
for j = 1:10
x = 7 * j ;
disp([int2str(j) str int2str(x)])
end
The ﬁrst line sets the variable str to be the string “ times seven is ” and this
phrase will be used in printing out the answer. In the code this character string
is contained within single quotes. It also has a space at the start and end (inside
the quotes); this ensures the answer is padded out.
The start of the for loop on the third line tells us the variable j is to run
from 1 to 10 (in steps of the default value of 1), and the commands in the for
loop are to be repeated for these values. The command on the fourth line sets
the variable x to be equal to seven times the current value of j. The ﬁfth line
constructs a vector consisting of the value of j then the string str and ﬁnally
the answer x. Again we have used the command int2str to change the variables
j and x into character strings, which are then combined with the message str.
Example 3.2 The following code prints out the value of the integers from 1
to 20 (inclusive) and their prime factors.
To calculate the prime factors of an integer we use the MATLAB command
factor




for i = 1:20
disp([i factor(i)])
end
This loop runs from i equals 1 to 20 (in unit steps) and displays the integer
and its prime factors. There is no need to use int2str (or num2str) here since
all of the elements of the vector are integers.
The values for which the for loop is evaluated do not need to be speciﬁed
inline, instead they could be set before the actual for statement. For example




r = 1:3:19;
for ii = r
disp(ii)
end
displays the elements of the vector r one at a time, that is 1, 4, 7, 10, 13, 16
and 19; of course we could have used more complicated expressions in the loop.

66
3. Loops and Conditional Statements
The following simple example shows how loops can be used not only to
repeat instructions but also to operate on the same quantity.
Example 3.3 Suppose we want to calculate the quantity six factorial (6! =
6 × 5 × 4 × 3 × 2 × 1) using MATLAB.
One possible way is




fact = 1;
for i = 2:6
fact = fact * i;
end
To understand this example it is helpful to unwind the loop and see what
code has actually executed (we shall put two commands on the same line for
ease)
fact = 1;
i=2; fact = fact * i; At this point fact is equal to 2
i=3; fact = fact * i; At this point fact is equal to 6
i=4; fact = fact * i; At this point fact is equal to 24
i=5; fact = fact * i; At this point fact is equal to 120
i=6; fact = fact * i; At this point fact is equal to 720
The same calculation could be done using the MATLAB command factorial(6).
Example 3.4 Calculate the expression nCm for a variety of values of n and
m. This is read as ‘n choose m’ and is the number of ways of choosing m
objects from n. The mathematical expression for it is
nCm =
n!
m!(n −m)!.
We could rush in and work out the three factorials in the expression, or
we could try to be a little more elegant. Let’s consider n!/(n −m)! is equal to
n×(n−1)×(n−2)×· · ·×(n−m+1). We can therefore use the loop structure.
Note also that there are m terms in this product, as there are in m!, so we can
do both calculations within one loop

3.2 Loops Structures
67
'
&
$
%
prod = 1;
mfact = 1;
for i = 0:(m-1)
mfact = mfact * (i+1);
prod = prod * (n-i);
end
soln = prod/mfact;
Breaking up the calculation like this can lead to problems for large values of m
and so it is often best to work out the answer directly:




soln = 1;
for i = 0:(m-1)
soln = soln * (n-i) / (i+1);
end
This product could also be written as:




soln = 1;
for i = 0:(m-1)
soln = soln * (n-i) / (m-i);
end
This version may have a slight computational advantage since the terms ap-
pearing in the fractions are closer in magnitude. That these two versions are
identical can be seen by rewriting the product as
t =
n
1
	 n −1
2

· · ·
n −m + 2
m −1
 n −m + 1
m

or as
s =
 n
m
	  n −1
m −1

· · ·
n −m + 2
2
 n −m + 1
1

.
This example could also be done using the MATLAB command prod, which
calculates the product of the elements of a vector; in fact MATLAB has a
command nchoosek designed for just this calculation. In order to use prod we
could use:




M = 1:m;
t = (n-1+M)./M; prod(t)
s = (n-1+M)./(m-M+1); prod(s)

68
3. Loops and Conditional Statements
where t and s correspond to the two expressions above.
So far we have dealt with products: in the next example we shall consider
a simple summation.
Example 3.5 Determine the sum of the geometric progression
6

n=1
2n.
This is accomplished using the code:




total = 0
for n = 1:6
total = total + 2ˆn;
end
which gives the answer 126, as you might expect from the formula for the sum
of a geometric progression
S = a1 −rn
1 −r
where a is the ﬁrst term, r is the ratio of the terms and n is the number of
terms. In our case a = 2, r = 2 and n = 6, which gives S = 126.
We now go through the ideas of summing series more thoroughly since it
provides important information on how loop structures work.
3.3 Summing Series
In Example 3.5 we have summed a series: we now describe this topic in more
detail. We start by constructing a code to evaluate
N

i=1
i2.
Firstly, we note that we do not necessarily know N so this will need to be
entered by the user or on a command line. We will ﬁrst do one case by “hand”.
Let us consider N = 4, so we wish to determine
4

i=1
i2.

3.3 Summing Series
69
If we were to do this on paper we would probably write down all the terms in
the summation and then add them up: evaluating the terms in the series
4

i=1
i2 = 1 + 4 + 9 + 16
and adding them up we obtain
30.
At this stage we can add the terms up in our heads: however, what would
happen if N was larger, for instance 10. In this case note the answer is given
by
10

i=1
i2 = 1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 + 81 + 100.
But in fact we may actually do it like this:
- The ﬁrst term corresponds to i = 1, for which i2 = 1.
- The second term, that is i = 2, has i2 = 4 and adding to the previous answer
gives 1 + 4 = 5.
- The third term, that is i = 3, has i2 = 9 and adding to our previous answer
gives 5 + 9 = 14, etc.
We can automate this process by using the MATLAB code:
'
&
$
%
N = input(’Enter the number of terms required: ’);
s = 0;
for i = 1:N
s = s + iˆ2;
end
disp([’Sum of the first ’ int2str(N) ...
’ squares is ’ int2str(s)])
As we mentioned earlier the command int2str converts an integer to a string.
This means we can concatenate these strings into a sentence. If we tried
apple = 8;disp([’I have ’ apple ’ apples’])
MATLAB misses out the number and gives “I have apples”, whereas the com-
mand

70
3. Loops and Conditional Statements
disp([’I have ’ int2str(apple) ’ apples’])
gives “I have 8 apples”, as required: for more information on this command see
page 185.
We can break down our summation code as follows:
– The ﬁrst line simply asks the user to enter the value of N when prompted
with the string contained in the input statement.
– The second line sets a variable s to be zero: this will be used to store the
cumulative sum. The blank line is included to make our code more readable.
– The next three lines form a loop. The loop variable is i which runs from 1
to N. This means the command in the loop will be repeated for each of these
values. The value of iˆ2 will be added to the previous value of s.
– After the loop there is another blank line (again purely for readability).
– Finally, we display our results using the disp command. We have constructed
a row vector with four elements: the ﬁrst and third elements are merely the
strings ’Sum of the first ’ and ’ squares is ’ whereas the second and
fourth are the values N and s converted from integers to strings using the
MATLAB command int2str.
We can now modify the above code to determine the value of the summation
7

i=3
i3.
Previously we were asked to calculate the sum of square terms and now we
need the sum of cubes so the line s = s + iˆ2; needs to be modiﬁed to s =
s + iˆ3;. We also need to change the range which the loop runs over from
1:N to 3:7, which is accomplished by changing the argument of the for loop
to i = 3:7. The modiﬁed code will now work, however it will ask for a value
of N which is no longer relevant. We can comment out this line by prepending
it with a percentage sign. This instructs MATLAB to ignore everything else
on this line. This can be very useful when you want to change a code but do
not want to just delete lines. It can also be used to include comments so you
can understand the code. Finally, we need to change the line which outputs the
results, the amended code looks like this:
'
&
$
%
% N = input(’Enter the number of terms required: ’);
s = 0;
for i = 3:7
s = s + iˆ3;
end
disp([’Required value of the summation is ’ int2str(s)])

3.3 Summing Series
71
Again we have used the command int2str to change the variable s into a
string. This only works correctly if s is an integer. If s is not an integer we
need to use the command num2str which changes a general number to a string.
In all the cases so far we have only been interested in the ﬁnal answer. Let’s
consider instead the problem of determining the values of
IN =
N

i=1
f(i),
where the f(i) are deﬁned by the problem at hand. At the moment we will
stick to f(i) = iˆ2. Again we shall start by doing an example by hand, let us
determine the values of I N for N equals one to four. Firstly N = 1
I1 =
1

i=1
i2 = 1,
and now N = 2, which is
I2 =
2

i=1
i2 = 1 + 4 = 5,
and N = 3,
I3 =
3

i=1
i2 = 1 + 4 + 9 = 14,
and ﬁnally N = 4, which gives
I4 =
4

i=1
i2 = 1 + 4 + 9 + 16 = 30.
You should have noticed that I 2 = I 1+2ˆ2, I 3 = I 2+3ˆ2 and I 4 =
I 3+4ˆ2: These are just like the elements of an array (or vector). In general
IN = IN−1 + N 2.
(3.1)
It is exactly this kind of recursion relation which a computer can take advantage
of. In order to calculate these values we can use the code:

72
3. Loops and Conditional Statements
'
&
$
%
maxN = input(’Enter the maximum value of N required: ’);
I(1) = 1ˆ2;
for N = 2:maxN
I(N) = I(N-1) + Nˆ2;
end
disp([’Values of I_N’])
disp([1:N; I])
This code uses a vector I to store the results of the calculation. It ﬁrst prompts
the user to input the value of N, which it stores in the variable maxN. The
ﬁrst value of the vector is then set as 12. Equation (3.1) now tells us the
relation between the ﬁrst and second elements of I, which we exploit in the
loop structure. The ﬁnal two lines display the string Values of I N and the
actual values. The answers are given as a matrix, the ﬁrst row of which contains
the numbers 1 to N and the second row gives the corresponding values of I N.
This produces the results:
Enter the maximum value of N required: 10
Values of I_N
1
2
3
4
5
6
7
8
9
10
1
5
14
30
55
91
140
204
285
385
(for N = 10). This can be compared with the analytical solution, see equation
(3.4). Up until now we have considered very simple summations. Let’s now see
how we can sum the series where the terms are deﬁned by some function f(i).
We use a separate MATLAB program to construct the series. Let’s consider
IN =
N

i=1
i sin iπ
4 .
We start by using a code f.m which will return the coeﬃcients we are going to
sum. You should enter this code and save it as f.m.




function [value] = f(inp)
value = inp * sin(inp*pi/4);
– The ﬁrst line tells the computer this program is a function, which should take
as input a value inp and return the variable value (if value is undeﬁned
MATLAB will complain).

3.3 Summing Series
73
– The second line simply works out the required value. Notice that MATLAB
already has a variable pi.
The above code is now modiﬁed to:
'
&
$
%
maxN = input(’Enter the maximum value of N required: ’);
I(1) = f(1);
for N=2:maxN
I(N) = I(N-1) + f(N);
end
disp([’Values of I_N’])
disp([1:N; I])
This produces the result
Enter the maximum value of N required: 5
Values of I_N
1.0000
2.0000
3.0000
4.0000
5.0000
0.7071
2.7071
4.8284
4.8284
1.2929
(for N = 5). We note that here we have a good example of the diﬀering mean-
ings of the command y(n). In the case of I(N), this refers to the N th entry of
the array I, whereas for f(N), it refers to the function f evaluated at the point
N. This subtle diﬀerence is critical!
3.3.1 Sums of Series of the Form
N

j=1
jp, p ∈N
Let’s consider the simple code which works out the sum of the ﬁrst N integers
raised to the power p:

74
3. Loops and Conditional Statements
'
&
$
%
% Summing series
N = input(’Please enter the number of terms required ’);
p = input(’Please enter the power ’);
sums = 0;
for j = 1:N
sums = sums + jˆp;
end
disp([’Sum of the first ’ int2str(N) ...
’ integers raised to the power ’ ...
int2str(p) ’ is ’ int2str(sums)])
so this produces
SN =
N

j=1
jp.
We note the formula when p = 1 is given by N(N + 1)/2. We pause here to
think how we could work this out. If we substitute in the values N = 1, N = 2
and N = 3 (all for p = 1) we would obtain three points on the ‘curve’ and
these will uniquely determine its coeﬃcients (assuming it is a quadratic). We
assume that SN = aN 2 + bN + c and use the three values above to give three
simultaneous equations from which we can determine the coeﬃcients a, b and
c, these equations are:
N = 1
a + b + c = S1 = 1,
(3.2a)
N = 2
4a + 2b + c = S2 = 1 + 2 = 3,
(3.2b)
N = 3
9a + 3b + c = S3 = 1 + 2 + 3 = 6.
(3.2c)
From (3.2a) we see that c = 1−a−b and this can be substituted into the other
two equations to yield
3a + b = 2,
(3.3a)
8a + 2b = 5.
(3.3b)
Now using (3.3a) in (3.3b) we ﬁnd a = 1/2 and then in (3.3a), b = 1/2 and
ﬁnally using (3.2a) we have c = 0. Hence
SN = 1
2N 2 + 1
2N,
for
N = 1, 2, 3.
In order to prove that this is true for all N we can use proof by induction.

3.3 Summing Series
75
It seems reasonable to expect that the sum for a certain power of p will be
of degree p + 1. In order to determine the coeﬃcients of a polynomial of degree
p + 1 we require p + 2 points. Consider this example:
'
&
$
%
clear all
format rat
p = input(’Please enter the power you require ’);
points = p+2;
n = 1:points;
for N=n
sums(N)=0;
for j = 1:N
sums(N) = sums(N) + jˆp;
end
end
[coe] = polyfit(n,sums,p+1)
format
This code is worth dissecting, since it is our ﬁrst example of nested loops.
– The ﬁrst line ensures all values of variables have been cleared. This is good
programming practice since it means undeclared variables will be noticed
rather than used incorrectly.
– The second line sets the format for the duration of this run to be rat, forcing
MATLAB to try to print the answers as rationals (notice this is coupled with
the ﬁnal line which merely resets the formatting to the default).
– The next line asks the user for the value of p. As noted above we need to
determine p + 2 coeﬃcients and as such we need p + 2 equations. A vector n
is set up running over these values.
– We now have a nested for loop structure which sets up the points (from 1
to p + 2).
– The next line sets the initial value of the element of the array sums to be
zero, ready to be set to the required cumulative sum. This sum is calculated
within the inner loop. We note again that each for statement needs to be
balanced with an end.
– Now we use the MATLAB intrinsic command polyfit which gives the
coeﬃcients of the required polynomial. The syntax of this command is

76
3. Loops and Conditional Statements
polyfit(x,y,n) which returns the coeﬃcients of order n through the points
in (x, y).
For the examples p = 2 and p = 3 we have
>> sumser2
Please enter the power you require 2
coe =
1/3
1/2
1/6
*
>> sumser2
Please enter the power you require 3
coe =
1/4
1/2
1/4
*
*
Notice here we have asked the code to try to give us rational answers. The
asterisks are merely where MATLAB cannot express zero (or something close
to it) as a rational. In the ﬁrst case we have
N

j=1
j2 = N 3
3 + N 2
2 + N
6 = N
6 (2N + 1)(N + 1),
(3.4)
(where we have factorised our answer) and in the second case
N

j=1
j3 = N 4
4 + N 3
2 + N 2
4
= N 2
4 (N + 1)2.
We could use this procedure for any integer value of p: however a rigorous proof
requires mathematical induction (or another similar process).
3.3.2 Summing Inﬁnite Series
We now consider examples where we need to truncate the series.
Example 3.6 The Taylor series for a function f(x) about a point x = a is
given by
f(x) = f(a) +
∞

n=0
(x −a)n
n!
f (n)(a).

3.3 Summing Series
77
We can use this to approximate sin x by an inﬁnite series in x as
sin x = lim
N→∞
N

n=0
(−1)n
x2n+1
(2n + 1)!.
Of course in using a computer we cannot actually take N to be inﬁnity, but
we shall take it to be large in the hope that the error will be small. We can write
the above series (taking N = 10) and evaluate the series at the points 0, 0.1,
0.2, 0.3, 0.4 and 0.5 using
'
&
$
%
v = 0.0:0.1:0.5;
sinx = zeros(size(v));
N = 10; range = 0:N;
ints = 2*range+1;
for n = range
sinx = sinx+(-1)ˆn*v.ˆints(n+1)...
/(factorial(ints(n+1)));
end
This is perhaps the most complicated code we have produced so far, so we shall
pause and break it down.
v = 0.0:0.1:0.5; sets up the vector v running from zero to a half in steps of
a tenth.
sinx = zeros(size(v)); In order to understand this command it is best to
start with what’s inside the brackets. The command size(v) gives the size
of the vector v and then the command zero sets up sinx as an array of
zeros of the same size.
N = 10; range = 0:N; sets a variable N to be equal to 10 and then sets up a
vector range which runs from zero to N.
ints = 2*range+1; This gives the mathematical expression 2n + 1 for all the
elements of the vector range and puts them in ints.
for n = range ..... end This loop structure repeats its arguments for n
equal to all the elements of range.
sinx = sinx+(-1)ˆn*v.ˆints(n+1)/(factorial(ints(n+1))); This math-
ematical expression evaluates the subject of the summation as a function
of n. (Notice the necessary oﬀset when referring to the elements of ints,
for instance ints(1) refers to the value when n = 0). Also note the use of
.ˆ when operating on v as this is a vector.
Running this gives

78
3. Loops and Conditional Statements
>> sinx
sinx =
0
0.0998
0.1987
0.2955
0.3894
0.4794
These values can be compared to those calculated directly by MATLAB to give
>> sin(v)
ans =
0
0.0998
0.1987
0.2955
0.3894
0.4794
>> sinx-sin(v)
ans =
1.0e-16 *
0
0.1388
0.2776
0
-0.5551
0
Since all the elements of the vector sinx-sin(v) share a factor of 1.0e-16
this has been extracted. This results shows that our approximation has worked
very well (for relatively few terms). For larger values of x more terms might
be needed. For a value of x = π we ﬁnd the same number of terms as used
above produces a value of ∼10−11, which is still a good approximation (since
the actual value of sin π is zero), but not quite as good as those shown above.
The inﬁnite series given above actually converges for all values of x.
Example 3.7 Calculate the sum
∞

n=0
e−n.
This poses a problem for us since we can obviously not add up an inﬁnite
number of terms, we need to truncate the calculation. In this case we do not
need very many terms since e−x gets very small very quickly. We can use the
code:

3.3 Summing Series
79
#
"
 
!
N = 10;
total = 0;
for n = 0:N
total = total + exp(-n);
end
To test for convergence of our results we should compare our answer for dif-
ferent values of N. Fortunately, in this case, we are able to work out the value
of the truncated series, since it is merely a geometric progression (the formula
for the sum of a geometric progression is given on page 68). The ﬁrst term is
e0 = 1 and the ratio between successive terms is 1/e, hence the sum is
SN = 1 −e−(N+1)
1 −e−1
.
In the limit as N →∞this tends to
S∞=
1
1 −e−1 =
e
e −1 ≈1.581977.
If we compare the results for N = 10 the error is already ∼10−5. To ﬁnd a
formula for the error we need to calculate |SN −S∞|, which is
|SN −S∞| =




1 −e−(N+1)
1 −e−1
−
1
1 −e−1




 =




e−N
e −1




 ,
which decreases (exponentially fast) as N increases.
3.3.3 Summing Series Using MATLAB Speciﬁc
Commands
So far we have used commands which are common to many programming lan-
guages (or at least similar to) and have not exploited the power of MATLAB.
In the ﬁrst example, given above, we mentioned the idea of adding things up in
our head. MATLAB is very good at this type of exercise. Consider the previous
example
10

i=1
i2.
Firstly we set up a vector running from one to ten:
i = 1:10;
and now a vector which contains the values in i squared:

80
3. Loops and Conditional Statements
i_squared = i.ˆ2;
Now we use the MATLAB command sum to evaluate this:
value = sum(i_squared)
(notice here we have left oﬀthe semicolon so the result is displayed automati-
cally). The full code for this example is




i = 1:10;
i_squared = i.ˆ2;
value = sum(i_squared)
This can all be contracted on to one line sum((1:10).ˆ2): you should make
sure you know how this works!
Using the command sum allows us to simplify our codes: however it is es-
sential we understand exactly what it is doing. Consider a problem where we
have a set of values y1, y2 up to yN, where for the sake of argument N is taken
to be odd. The problem is to work out the sum of the series
N

i=1
yif(i),
where f(i) = 1 when i is odd and f(i) = 2 when i is even. We can set up these
values of f using the commands:
#
"
 
!
N = 11;
iodd = 1:2:N;
ieven = 2:2:(N-1);
f(iodd) = 1;
f(ieven) = 2;
which gives
f =
1
2
1
2
1
2
1
2
1
2
1
This can be achieved in one command, namely 2-mod(1:11,2). We can now
use a similar code to those we wrote earlier to sum the series. For example if
y = x2, we have




x = 1:11;
y = x.ˆ2;
sum(y.*f)

3.3 Summing Series
81
This kind of expression will prove to be very useful when we come to consider
numerically evaluating integrals in a later chapter.
Example 3.8 Evaluate the expression
N

n=1

1 + 2
n

for N = 10 (the symbol  means the product of the terms, much in the same
way  means summation). This can be done using the code:




n = 1:10;
f = 1+(2)./n;
pr = prod(f)
The ﬁrst line sets up a vector with elements running from 1 to 10; the second
line sets up a vector f whose elements have the values 1 + 2/n; notice f is
the same shape as n. We have divided 2 by a vector and so we have used “./”
rather than just “/”. If you want to see what the code does, just leave oﬀthe
semicolons; this will show you the vectors which are generated. Finally, the last
line gives the product of all the elements of the vector f.
This gives the answer 66. This can be seen by a slight rearrangement of the
expression
N

n=1

1 + 2
n

=
N

n=1
n + 2
n

=
N
n=1
n + 2
N
n=1
n
,
where we have used the fact  anbn = ( an)( bn). Now actually evaluating
the products:
= (N + 2)(N + 1) · · · 3
N(N −1) · · · 1
= (N + 2)!/(2.1)
N!
= (N + 2)(N + 1)
2
.
When N = 10 this gives a value of 66.

82
3. Loops and Conditional Statements
3.3.4 Loops Within Loops (Nested)
Many algorithms require us to use nested loops (loops within loops), as in
the example of summing series on page 75. We illustrate this using a simple
example of constructing an array of numbers:
#
"
 
!
for ii = 1:3
for jj = 1:3
a(ii,jj) = ii+jj;
end
end
Notice that the inner loop (that is, the one in terms of the variable jj) is
executed three times with ii equal to 1, 2 and then 3. These structures can
be extended to have further levels. Notice each for command must be paired
within an end, and for the sake of readability these have been included at the
same level of indentation as their corresponding for statement.
Example 3.9 Calculate the summations
N

j=1
jp
for p equal to one, two and three for N = 6.
We could perform each of these calculations separately but since they are so
similar it is better to perform them within a loop structure:
'
&
$
%
N = 6;
for p = 1:3
sums(p) = 0.0;
for j = 1:N
sums(p) = sums(p)+jˆp;
end
end
disp(sums)
The order in which the loops occur should be obvious for each problem but in
many examples the outer loop and inner loop could be reversed.

3.4 Conditional Statements
83
3.4 Conditional Statements
MATLAB has a very rich vocabulary when it comes to conditional operations
but we shall start with the one which is common to many programming lan-
guages (even though the syntax may vary slightly). This is the if command
which takes the form:
if (expression)
commands
...
end
As you might expect, if the expression is true then the commands are
executed, otherwise the programme continues with the next command imme-
diately beyond the end statement. There are more involved forms of the com-
mand, but before proceeding with these let’s ﬁrst discuss the construction of
the expression. Firstly there are the simple mathematical comparisons
a < b
True if a is less than b
a <= b
True if a is less than or equal to b
a > b
True if a is greater than or equal to b
a >= b
True if a is greater than or equal to b
a == b
True if a is equal to b
a ∼= b
True if a is not equal to b
More often than not we will need to form compound statements, comprising
more than one condition. This is done by using logical expressions, these are:
and(a,b)
a & b
Logical AND
or(a,b)
a | b
Logical OR
not(a)
∼a
NOT
xor(a,b)
Logical exclusive OR
The eﬀect of each of these commands is perhaps best illustrated by using tables
AND
false
true
false
false
false
true
false
true
OR
false
true
false
false
true
true
true
true
XOR
false
true
false
false
true
true
true
false

84
3. Loops and Conditional Statements
NOT (∼) This simply changes the state so ∼(true)=false and ∼(false)=true.
We pause and just run through these logical operators:
a AND b This is true if both a and b are true
a OR b This is true if one of a and b is true (or both).
a XOR b This is true if one of a and b is true, but not both.
In many languages you can deﬁne Boolean (named after George Boole)
variables and these will have actual logical meaning. For instance in Excel you
can set values to be True or False. In MATLAB zero represents False and
any other value implies True. We shall adopt the convention that 1 (one) is
true and 0 (zero) is false. In fact sometimes it is useful to deﬁne variables such
that false=0; true= (∼false). This statement is read as set true to be
equal to not false; we have added the brackets for clariﬁcation.
Example 3.10 In the following examples it may be helpful to draw pictures,
but we should at least teach you to read these statements. We recall that in this
context a square bracket means a closed set (that is, including the end point)
whereas a round bracket indicates an open set (that is, not including the end
point).
Determine the sets for which these statements are true:
1. x>1 & x<2
We can read this command as “x is greater than one and less than two”.
This is obviously true only for values between one and two (not inclusive).
This is the open set (1, 2).
2. x<0 | x>=1
This command can be read as “x less than zero or greater than (or equal
to) one”. This set has two parts: x strictly negative or x greater than (or
equal to one). Hence the set is (−∞, 0) ∪[1, ∞).
3. x>1 | x<2
This command can be read as “x greater than 1 or x less than 2”. In fact
all values of x are greater than one or less than 2, hence the answer is
(−∞, ∞).
4. x<=1 | x>=1
This one says “x is less than (or equal to) 1 or x is greater than (or equal
to 1)”. This again is true for all values of x, hence the answer is (−∞, ∞).
5. x<=1 & x>=1
This one is similar to the previous one with one word changed so it now
reads:“x is less than (or equal to) 1 and x is greater than (or equal to 1)”.

3.4 Conditional Statements
85
The only value which is less than (or equal to) one and greater than (or
equal to) one is one itself. The answer is the single value one, written as
{1}.
6. ∼(x>2)
This is our ﬁrst example of negation, which is read as “x is not greater
than 2”, which is true for values of x less than (or equal to) 2, that is the
set (−∞, 2].
7. (x>1) & (∼(x<2))
Here we have “x is greater than 1 and x is not less than 2”. The second
part of this expression means that x is greater than (or equal to 2) (and
the ﬁrst part is always true for this range), so the solution is [2, ∞).
8. abs(x-1) < 2
Here we have an expression involving a mathematical function: this one is
read as: “the modulus of x minus 1 is less than two”. This means points
which are within 2 units of the point 1, that is (−1, 3).
9. rem(n,4) == 1
This command calculates the remainder when divided by 4 and checks to see
if this is equal to 1. The values for which this is true are {4n + 1 : n ∈Z}.
3.4.1 Constructing Logical Statements
We shall now actually construct logical arguments which can be used in if
statements.
Example 3.11 Let us consider a command which is only executed if a value x
lies between 1 and 2 or it is greater than or equal to 4. We shall try to describe
the thought processes involved:
– In order that a value lies between one and two, it has to be greater than one
and less than two, so this component is written as:




(x>1) & (x<2)
– If x is greater than or equal to 4, which is written simply as x>=4.
– Finally, we need to combine these conditions and this is done using the logical
operation or, since the value of x could lie in one or the other of the regions.
Hence we have

86
3. Loops and Conditional Statements




((x>1) & (x<2)) | (x>=4)
We could use the commands in a diﬀerent form




a = and(x>1,x<2);
b = (x>=4);
c = or(a,b)
by making use of the and and or commands. Notice here we have actually set
“Boolean” variables a, b and c (in fact they are only normal variables which
take the values zero or one).
We can also use these commands for vectors and matrices (comparing them
element-wise). Consider the following
>> x = [1 2 0 3];
>> and(x>1,x<4)
ans =
0
1
0
1
>> A = eye(2);
>> and(A==1,A>0)
ans =
1
0
0
1
If two sets do not intersect then by deﬁnition A∩B = ∅(the null, or empty,
set). In terms of logical statements we say that the conditions are mutually
exclusive. For instance, the condition (x>1)&(x<0) is never true, since x cannot
be greater than one and less than zero.
Notice that we have used brackets to group the terms in the previous exam-
ple. This is not always necessary but it is very good practice, especially since
we cannot guarantee that the precedence in other languages will be the same.
In fact although the expression (x>=4) | ((x>1) & (x<2)) is the same as
that given above, removing the brackets from both of them yields diﬀerent re-
sults. In the former case the expression still works, whereas in the latter case

3.4 Conditional Statements
87
MATLAB complains about precedence and invites the user to ﬁnd out more
by using help precedence.
It is convenient at this stage to introduce some of the other commands
which are available to us when constructing conditional statements, namely
else and elseif. The general form of these is given by:
'
&
$
%
if (expression)
commands ...
elseif (expression)
commands ...
else
commands ...
end
Notice that each if statement must be paired with an end statement, but we
can use as many elseif statements as we like, but only one else (within a
certain level). We are also able to nest if statements: again it is recommended
that the new levels are indented so as to aid readability.
Example 3.12 Consider the following piece of code which determines which
numbers between 2 and 9 go into a speciﬁed integer exactly:
'
&
$
%
str = ’Divisible by ’;
x = input(’Number to test: ’);
for j = 2:9
if rem(x,j) == 0
disp([str int2str(j)])
end
end
The results of this code can be checked using the factor command. We have
used the command rem to obtain the remainder.
Example 3.13 Here we construct a conditional statement which evaluates the
function:
f(x) =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
0
x < 0
x
0 ⩽x ⩽1
2 −x
1 < x ⩽2
0
x > 2
One of the possible solutions to this problem is:

88
3. Loops and Conditional Statements
'
&
$
%
if x >= 0 & x <= 1
f = x;
elseif x > 1 & x <= 2
f = 2-x;
else
f = 0;
end
Notice that it has not been necessary to treat the end conditions separately;
they are both included in the ﬁnal else clause.
Example 3.14 (Nested if statements) The ideas behind nested if state-
ments is made clear by the following example
'
&
$
%
if raining
if money_available > 20
party
elseif money_available > 10
cinema
else
comedy_night_on_telly
end
else
if temperature > 70 & money_available> 40
beach_bbq
elseif temperature>70
beach
else
you_must_be_in_the_UK
end
end
3.4.2 The MATLAB Command switch
MATLAB has a command called switch which is similar to the BASIC com-
mand select (the syntax is virtually identical). The command takes the form:

3.4 Conditional Statements
89
'
&
$
%
switch switch_expr
case case_expr1
commands ...
case {case_expr2,case_expr3}
commands ...
otherwise
commands ...
end
We shall work through the example given in the manual documentation for this
command:
'
&
$
%
switch lower(METHOD)
case {’linear’,’bilinear’}
disp(’Method is linear’)
case ’cubic’
disp(’Method is cubic’)
case ’nearest’
disp(’Method is nearest’)
otherwise
disp(’Unknown method.’)
end
This code assumes that METHOD has been set as a string. The ﬁrst command
lower(METHOD) changes the string to be lower case (there is also the corre-
sponding command upper). This value is then compared to each case in turn
and if no matches are found the otherwise code is executed.
Example 3.15 We refer to the old rhyme that allows us to remember the
number of days in a particular month.
Thirty days hath September
April, June and November
All the rest have thirty-one
Except February alone
which has twenty-eight days clear
and twenty-nine on leap year
This is exploited in the code:

90
3. Loops and Conditional Statements
'
&
$
%
msg = ’Enter first three letters of the month: ’;
month = input(msg,’s’);
month = month(1:3); % Just use the first three letters
if lower(month)==’feb’
leap = input(’Is it a leap year (y/n): ’,’s’);
end
switch lower(month)
case {’sep’,’apr’,’jun’,’nov’}
days = 30;
case ’feb’
switch lower(leap)
case ’y’
days = 29;
otherwise
days = 28;
end
otherwise
days = 31;
end
Before we proceed it is worth discussing a couple of the commands used above.
The MATLAB command lower forces the characters in the string to be lower
case: for instance if the user typed ’Feb’ the command lower would return ’feb’.
We have also included a command which makes sure the code only considers
the ﬁrst three characters of what the user inputs. The command input is used
here with a second argument ’s’ which tells MATLAB that a string is expected
as an input; without this the user would need to add single quotes at the start
and end of the string.
You might want to consider what you would need to do to check the user has
input a valid month. The next command is very useful for this kind of problem.
3.5 Conditional loops
Suppose we now want to repeat a loop until a certain condition is satisﬁed.
This is achieved by making use of the MATLAB command while, which has
the syntax
while (condition)
commands...
end

3.5 Conditional loops
91
This translates into English as: while condition holds continue executing
the commands.... The true power of this method will be found when tackling
real examples, but here we give a couple of simple examples.
Example 3.16 Write out the values of x2 for all positive integer values x such
that x3 < 2000. To do this we will use the code
'
&
$
%
x = 1;
while xˆ3 < 2000
disp(xˆ2)
x = x+1;
end
value = floor((2000)ˆ(1/3))ˆ2;
This ﬁrst sets the variable x to be the smallest positive integer (that is one) and
then checks whether x3 < 2000 (which it is). Since the condition is satisﬁed it
executes the command within the loop, that is it displays the values of x2 and
then increases the value of x by one.
The ﬁnal line uses some mathematics to check the answer, with the MATLAB
command floor (which gives the integer obtained by rounding down; recall the
corresponding command to ﬁnd the integer obtained by rounding up is ceil).
Example 3.17 Consider the one-dimensional map:
xn+1 = xn
2 +
3
2xn
,
subject to the initial condition xn = 1. Let’s determine what happens as n
increases. We note that the ﬁxed points of this map, that is the points where
xn+1 = xn, are given by the solutions of the equation:
xn = xn
2 +
3
2xn
,
which are xn = ±
√
3. We can use the code
'
&
$
%
xold = 2; xnew = 1;
while abs(xnew-xold) > 1e-5
xold = xnew;
xnew = xnew/2+3/(2*xnew);
end

92
3. Loops and Conditional Statements
This checks to see if xn+1 = xn to within a certain tolerance. This procedure
gives a reasonable approximation to
√
3 and would improve if the tolerance
(1e-5) was reduced.
3.5.1 The break Command
A command which is of great importance within the context of loops and
conditional statements is the break command. This allows loops to stop when
certain conditions are met. For instance, consider the loop structure
'
&
$
%
x = 1;
while 1 == 1
x = x+1;
if x > 10
break
end
end
The loop structure while 1==1 ... end is very dangerous since this can give
rise to an inﬁnite loop, which will continue ad inﬁnitum; however the break
command allows control to jump out of the loop.
3.6 MATLAB Speciﬁc Commands
We could have coded the Example 3.16 using the MATLAB command find,
which returns an array of locations at which a certain condition is satisﬁed.
The condition is formed as above using logical expressions and combinations
of them.
Example 3.18 Find all integers between 1 and 20 for which their sine is neg-
ative.
Firstly we set up the array of integers, then calculate their sines and subse-
quently test whether these values are negative.




ii = 1:20;
f = sin(ii);
il = find(f<0);
disp(ii(il))

3.6 MATLAB Speciﬁc Commands
93
We brieﬂy dissect this code.
– In the ﬁrst line set up a vector which runs from one to twenty;
– the second line calculates the sine of the elements in vector ii and stores the
result in the vector f;
– in the third line we use find to determine the locations in the vector f where
the sine is negative. The command returns a list of positions in the vector f
(and equivalently ii) where the condition is true.
– The ﬁnal command prints out a list of these integers.
Other similar commands are any and all. Examples of their use are:
'
&
$
%
x = 0.0:0.1:1.0;
v = sin(x);
if any(v<0)
disp(’Found a negative value’)
else
disp(’All values zero or positive’)
end
if all(v>0)
disp(’All values positive’)
else
disp(’One value is zero or negative’)
end
Some care is needed with the logic at this point and these commands seem to
be, in some sense, complements of each other.
There are many other commands which test the properties of a variable, for
instance isempty, isreal etc.
Example 3.19 Now we evaluate the expression
f(x) =
1
(x −1)(x −2)(x −3)
on a grid of points n/10 for n = 1 to n = 40 for which the expression is ﬁnite,
else the function is to be returned as ’NaN’.
This is accomplished using the code:

94
3. Loops and Conditional Statements
'
&
$
%
x = (1:40)/10;
g = (x-1).*(x-2).*(x-3);
izero = find(g==0);
ii = find(g˜=0);
f(izero) = NaN;
f(ii) = 1./g(ii);
This allows us to plot the function whilst missing out the inﬁnite parts. This
would be accomplished using the command plot(x,f)
0
0.5
1
1.5
2
2.5
3
3.5
4
−15
−10
−5
0
5
10
15
3.7 Error Checking
To this point we have assumed the data made available to a code is suitable; this
is generally a very dangerous assumption. We have found MATLAB will object
to mathematically impossible tasks: however it will happily perform operations
provided they are viable (which unfortunately they are more often than not).
Now that we have seen conditional statements we can make sure our codes
are more robust. The ultimate aim would be to make them totally “idiot proof”,
but this is virtually impossible. No matter how many diﬀerent scenarios a
programmer comes up with, they can never predict everything a user will do.
MATLAB gives us three very useful commands in this context: break,
warning and error. The ﬁrst of these we have already met. The latter two

3.7 Error Checking
95
allow us to either warn the user of a problem or actually stop the code be-
cause of an irretrievable problem, respectively. Both the commands warning
and error are used with an argument, which is displayed when the command
is encountered. The typical structure might be:
#
"
 
!
if code_fails
error(’ Irretrievable error ’)
elseif code_problem
warning(’ Results may be suspect ’)
end
The actual use of the commands is perhaps best demonstrated by a couple
of examples:
Example 3.20 Let’s now write a code which asks the user for an integer and
returns the prime factors of that integer.
'
&
$
%
msg = ’Please enter a strictly positive integer: ’;
msg0 = ’You entered zero’;
msg1 = ’You failed to enter an integer’;
msg2 = ’You entered a negative integer’;
x = input(msg);
if x==0
error(msg0)
end
if round(x)˜= x
error(msg1)
end
if sign(x)==-1
warning(msg2)
x = -x;
end
disp(factor(x))
Fortunately the command input has its own error checking routine and will
only let you input numbers (if you try inputting a string it will complain). We
now check to see whether zero is entered, in which case the code stops after
having informed the user that they entered a zero. Similarly, if the user enters
a non integer the code will stop. If the user enters a negative integer the code
warns the user they have done so but simply makes it equal to the corresponding
positive value.

96
3. Loops and Conditional Statements
The command input allows us to input a matrix, which would cause our
program to fail (in fact the routine factor issues an error message). We could
incorporate a check to ensure that what is entered is a scalar. This could be
accomplished by using the condition that the length of a scalar is unity. To
this end we could add (below the input statement):




msg3 = ’Code needs a scalar integer’;
if length(x) ˜= 1 | x ˜= floor(x)
error(msg3)
end
When MATLAB encounters these commands it produces a message which
indicates on which line they occurred and in which code. This is very helpful
when debugging codes.
Example 3.21 Now consider a code which compels the user to enter a four
character string and until they have the code will not proceed.
'
&
$
%
msg = [’Please enter a ’ ...
’four character string ’];
msg0 = ’ is not valid, please re-enter’;
str = ’X’; % Clearly not valid
first = 1;
while length(str) ˜= 4
if ˜(first)
warning([str msg0])
end
first = 0;
str = input(msg,’s’);
end
In order to avoid the warning message during the ﬁrst run, we have used
the ﬂag first which basically says if this is the ﬁrst time through don’t issue
the warning. This uses a while loop to repeat until the user enters a string of
length 4.
As we can see this additional code can make the program cumbersome, but
sometimes it is necessary, especially if other users are going to read and use
your codes. Again, it also helps when it comes to debugging.

3.8 Tasks
97
Another very useful command in this context is exist. This can be used to
check whether the requisite variables exist. This is particularly useful if input
is required from another code.
Example 3.22 Let us consider this header for a code:
#
"
 
!
msg = [’The variable z does not exist ’ ...
’and will be required for this code’];
if ˜(exist(’z’))
error(msg)
end
We note this code will not work at the prompt, since the command error will
only run during the execution of an m-ﬁle.
3.8 Tasks
Task 3.1 Modify the code on page 71 to calculate the value of the summation
100

i=1
1
i2 .
(Notice the answer will probably not be an integer, so you will have to modify
the display line to use num2str).
Task 3.2 Modify the code from Task 3.1 to only sum the values corresponding
to odd values of i. (Hint: This only involves a very minor change to the for
loop. You should check the answer you get is smaller than the one from the
previous task.)
Task 3.3 Modify the function f.m (on page 72) to calculate the values of:
IN =
N

i=1
sin iπ
2
i2 + 1,
for N up to N=20.

98
3. Loops and Conditional Statements
Task 3.4 Construct a program to display the values of the function f(x) =
x2 + 1 for x = 0 to x = π in steps of π/4. The key here is to set up an array
of points from a to b in steps of h (you can either use the colon command or
linspace). Make sure you remember to use the dot operator.
Task 3.5 Change the code given in Example 3.6, used to evaluate sin x, to one
that calculates cos x whose series expansion is given by
cos x = lim
N→∞
N

n=0
(−1)n x2n
(2n)!.
Compare the approximations to the values calculated directly from MATLAB
for x = 0, 1/4, 1/2 and 3/4. As for Example 3.6 you will need to truncate the
summation, choosing N to be suitably large.
Task 3.6 Calculate the sum of the series SN, where
SN =
N

n=1
1
n2
for diﬀerent values of N. Given that as N →∞, SN →π2/c where c is a
constant. Determine the value of c. (Here you should modify one of the codes
for summation: the best one is probably the solution to Task 3.1.)
Task 3.7 Calculate the summations
p+1

j=1
jp
for p equal to one, two, three and four (using a nested loop structure).
Task 3.8 Show that, to within the accuracy permitted by MATLAB,
lim
N→∞
N

n=1
(−1)n
n
= −ln 2 and
lim
N→∞
N

n=1
1
n(n + 1) = 2.
Task 3.9 Write down (on paper) a logic expression which is true for values of
x such that 2 < x < 4. Make sure your expression works for x = 1, 3 and 5.
Repeat the exercise for the union of the sets x > 3 and x < −1. (You need to
write the answers in the form of the combination of x is greater than something
and/or x is less than something else).

3.8 Tasks
99
Task 3.10 Write down a logical expression which is true for even values of n.
Extend this to only be true for even values of n greater than 20. (Hint: Try
using the MATLAB command mod: for information on the command type help
mod.)
Task 3.11 Try to work out what value of x the following code returns (initially
without running it).
'
&
$
%
x = 1;
if tan(73*pi*x/4) >= 0
x = 2;
else
x = pi;
end
if floor(x) == x
x = 10;
else
x = 7;
end
if isprime(x)
x = ’True’;
else
x = ’False’;
end
Is this result true whichever value of x we start with? (You can ﬁnd out about
the command isprime by typing help isprime.)
Task 3.12 (*) Write a loop structure which iterates xn+1 = 5xn|1 for xn =
1/7 until it returns to the same value (use while).
Task 3.13 (*) Determine all integers between 1 and 50 for which n3 −n2 +40
is greater than 1000 and n is not divisible by 3. Are any integers between 1 and
50 perfect (that is, are they equal to the sum of their factors)?
Task 3.14 Write a code which only allows the user to input an integer n be-
tween 1 and 10 (inclusive) and then prints out a string of the ﬁrst n letters of
the alphabet. (Hint: You could start with a string of the form “abcdefghij”.)

100
3. Loops and Conditional Statements
Task 3.15 (*) Write a code which allows the user to input a two character
string, the ﬁrst being a letter and the second being a digit. (Note that to check
if a character is a letter we can use inequalities on strings.)
Task 3.16 (*) By modifying the code on page 88 use the find command to
plot the function
f(x) =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
0
x < −1
x2
−1 ⩽x ⩽1
1
1 < x < 4
0
x ⩾4
for the range x ∈[−3, 5] using one hundred points (try using the command
linspace to set up the array of points).
Task 3.17 (*) Using the command find, and modifying the code on page 93,
plot the function
f(x) =
1
cos πx
for x ∈[−3, 3]. You will need to change the code to determine when the denom-
inator becomes small, rather than when it is identically zero.
Task 3.18 (D) The following code is supposed to evaluate the function
f(x) =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
0
x < 0
x
0 ⩽x ⩽1
2 −x
1 ⩽x ⩽2
0
x > 2
'
&
$
%
x=lnspace(-4,4);
N = length x
for j = 1;N
if x(j)>=0 and x(i)<=1
f(j) = x(j);
elseif x(j)>1 or x(i)<2
f(j) = 2 - x
else
f(j) = zero;
end

3.8 Tasks
101
Correct the code so that it accomplishes this. This can be checked by using the
command plot(x,f) and comparing the ﬁgure to what you expect the function
to look like.

4
Root Finding
4.1 Introduction
In many problems we are required to determine when a function is zero. It
should have become clear even for relatively simple examples there were many
subcases. It is our intention to discuss methods which are in some sense robust
and so the form of the actual function we are studying is not important, at
least in the construction of the method.
We now re-introduce the MATLAB function feval which may seem a little
like an extra step, but it will enable us to write more general codes. This
function has the syntax feval(f,x1,...,xn) and as you might expect from the
name evaluates the function f using the arguments x1,...,xn. It is normally
used within other functions which require a function name to be passed to
them. This function can be used as




feval(’sin’,0.3)
feval(’mycode’,0.2,0.3)
In the ﬁrst example this gives sin(0.3) and in the second it returns the value
of mycode(0.2,0.3).

104
4. Root Finding
4.2 Initial Estimates
In order to determine a root it is usually essential to have an initial estimate
of its value. In some cases you may have more than one root (or none) and
you wish to identify which one you are concerned with. The method we will
describe now involves user interaction and is used as an illustration. As we
are developing the ideas in this chapter we could consider how they could be
generalised to include root selection. In general the methods we will consider
will require either an initial guess for the root or a bracketing interval containing
a root.
We will use the graphical capabilities of MATLAB to identify the root (or
this bracketing interval). Firstly, we shall set up a small m-ﬁle called userfn.m,
which will used to specify an example function.




function [value] = userfn(x,par1,par2)
value = x-par1*sin(x.ˆpar2);
This gives f(x) = x −α1 sin xα2, where α1 and α2 are parameters, which the
user will specify. Now in order to plot the function we select a range and use
the plot command. The commands are




x = -2.0:0.01:2.0;
y = feval(’userfn’,x,2,2);
plot(x,y)
grid on
This code sets up a vector x running from −2 to 2 in steps of 0.01. The next
line calculates the value of the function x−2 sin x2 at these points and puts the
answer in y. Note we could also have used the command y = userfn(x,2,2);
for this purpose. We have used the feval format so that we could potentially
vary the function name. The next two lines plot the graph and add the grid
lines.

4.2 Initial Estimates
105
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
−4
−3
−2
−1
0
1
2
3
4
From this initial ﬁgure it is not that clear where the zeros lie. There appears
to be one at the origin, which we can see straight away from consideration of
the function, f(x) = x −2 sin x2. By adding the command grid on (either to
the programme testplot.m or at the command line) we can see two additional
zeros (one near 0.5 and another near 1.5: there is also a hint of an extra one
to the left of the ﬁgure, which could be determined by extending the range
leftwards). In order to investigate further we use the zoom on command. By
clicking the left-hand mouse button we can enlarge areas of the ﬁgure, and
using the right-hand button we can pull back. Typing zoom off disables this
feature.
This can give us a good idea of where the roots lie. Notice this command is
only working using the original data and if we zoom too close we will be able
to see the straight line segments used for the plotting. Here we have exploited
401 points, so this should not be a problem.
We can now use another command ginput to actually return a value rather
than just using our eyes. The syntax we will exploit is

106
4. Root Finding
'
&
$
%
% Modified testplotm.m
x = -2.0:0.01:2.0;
y = feval(’userfn’,x,2,2);
disp(’Click the mouse near the zero’)
disp(’and when you have finished press’)
disp(’the return key’)
plot(x,y)
grid on
[xvalues,yvalues] = ginput
[yy,ii] = min(abs(yvalues));
disp(xvalues(ii))
The ﬁrst few lines are the same as testplot.m and the next line uses the
command ginput. The way ginput works is to allow the user to select points
in the window (using a cross hair) by clicking one of the mouse buttons. This is
terminated by pressing the return button. The results are stored in the arrays
xvalues and yvalues; these essentially contain the x and y coordinates of all
the points which the user clicks. The next command ﬁnds the minimum value
of the function and its integer location within the array. Finally the value of x
at this location is displayed. This gave a guess of 0.4977 for the zero near 0.5
and 1.4931 for the zero near 1.5.
Using these initial guesses we can now proceed with our description of some
of the techniques available to use. We shall also comment on the likely failings
of the methods and we should be mindful of how these failings could manifest
themselves and how we might monitor them.
Example 4.1 Determine initial estimates for the zeros of the function f(x) =
x sin x −√x between 0 and 10.
Firstly we construct the MATLAB code:




function [value] = userf1(x)
value = x.*sin(x)-sqrt(x);
and now run the commands
x = linspace(0,10);
y = feval(’userf1’,x);
plot(x,y)
grid on
which yield

4.2 Initial Estimates
107
0
1
2
3
4
5
6
7
8
9
10
−10
−8
−6
−4
−2
0
2
4
6
We can see that there are zeros at 0 and near 1.2, 2.5, 6.7 and 9.3. We
could use the above data set but it would seem sensible to consider each point
separately. For this purpose we use the code:
'
&
$
%
a = input(’Start of interval ’);
b = input(’End of
interval
’);
x = linspace(a,b);
y = feval(’userf1’,x);
clf
plot(x,y)
grid on
zoom on
Running this code with the inputs 1 and 2, we obtain:
1
1.1
1.2
1.3
1.4
1.5
1.6
1.7
1.8
1.9
2
−0.2
−0.1
0
0.1
0.2
0.3
0.4
0.5

108
4. Root Finding
1
1.05
1.1
1.15
1.2
1.25
1.3
1.35
1.4
1.45
1.5
−0.15
−0.1
−0.05
0
0.05
0.1
0.15
1.1
1.15
1.2
1.25
1.3
−0.08
−0.06
−0.04
−0.02
0
0.02
0.04
0.06
0.08
1.12
1.14
1.16
1.18
1.2
1.22
−0.04
−0.03
−0.02
−0.01
0
0.01
0.02
0.03
0.04
1.15
1.16
1.17
1.18
1.19
1.2
−0.02
−0.015
−0.01
−0.005
0
0.005
0.01
0.015
0.02

4.3 Fixed Point Iteration
109
1.16
1.165
1.17
1.175
1.18
1.185
1.19
−0.01
−0.008
−0.006
−0.004
−0.002
0
0.002
0.004
0.006
0.008
0.01
after successive clicks of the left mouse button. This allows us to obtain a better
estimate of the root, namely 1.175. You should try this interval and repeat the
exercise for the other roots.
In reality you should plot the function and then use a combination of the
grid and zoom commands to obtain estimates for the root or intervals which
contain them. This also helps to ensure that the answers you obtain are sensible.
4.3 Fixed Point Iteration
Most of the techniques we will discuss are iterative in nature and the ﬁrst
one is called the ﬁxed point iteration scheme. Instead of looking for a zero of
the function f(x), it determines a ﬁxed point of an equivalent equation. The
equation is rewritten in the form x = g(x), so when x is substituted in the
function g(x) it returns the value x, hence the nomenclature ﬁxed point. The
conversion of the equation f(x) = 0 into one of the form x = g(x) is not
always straightforward and deﬁnitely can be done in many ways. For instance
the previous example, for which f(x) = x −2 sin x2 could be rewritten as
x = 2 sin x2 (where g(x) = 2 sin x2) or x =

sin−1 x
2. Although the former
version might be more intuitive, there are many examples in which this choice
is not so. For instance consider the quadratic f(x) = x2 + 2x −3, which could
be manipulated to give x = (3 −x2)/2 or x = √3 −2x. With these two forms
neither of them seems to have any advantages over the other. Further the
equation could be written as x = 3/(x + 2) and so on. Before we try to resolve
this issue let us say how this is then implemented as a numerical scheme.
We rewrite the equation as
xn+1 = g(xn)
n = 0, 1, · · · ,

110
4. Root Finding
which is a recursion formula. It starts with an initial guess, namely x0 (which
may be determined graphically or by another means).
Just about the simplest code for this purpose would be




x0 = 1;
for j=1:10
x0 = g(x0);
end
where we have a routine g.m which deﬁnes the function g(x) and x0 = 1 is a
suitable initial guess. This runs through the iterative process ten times. This
kind of code presupposes that it is going to work and will converge in ten steps
(or an appropriate number). You will quickly learn that you can’t rely on this
kind of thing.
We need to pause here to think what we mean by convergence. We could
work out the value of the function f(x) at the current iterate as a check. We
would require this to be less than a certain tolerance (the accuracy to which
we would expect to know the answer). Notice that this is slightly diﬀerent to
knowing the root to within a certain tolerance.
Alternatively in this case the code may be deemed to be successful when
the diﬀerence between xn+1 and xn is less than a certain tolerance. In this case
we have xn+1 ≈xn ⇒xn ≈g(xn) ⇒f(xn) ≈0. This tolerance reﬂects how
well we want to know the answer and the parameter maxits is how many times
we are prepared to perform the iterations. This is to eliminate problems with
cases which don’t converge and hence cause inﬁnite loops. The code we shall
use for this is:

4.3 Fixed Point Iteration
111
'
&
$
%
%
% fixed.m
%
function [answer,iflag] = fixed(g,xinit)
global tolerance maxits
iflag = 0;
iterations = 0 ;
xnext = feval(g,xinit);
while (iterations<maxits) & abs(xnext-xinit)>tolerance
iterations = iterations + 1;
xinit = xnext;
xnext = feval(g, xinit);
end
if iterations == maxits
iflag = -1;
answer = NaN;
else
iflag = iterations;
answer = xnext;
end
#
"
 
!
%
% eqn.m
%
function [g] = eqn(x)
g = 2*sin(x.ˆ2);
and the main function

112
4. Root Finding
'
&
$
%
%
% mfixed.m
%
global tolerance maxits
tolerance = 1e-4;
maxits = 30;
[root,iflag] = fixed(’eqn’,0.2);
switch iflag
case -1
disp(’Root finding failed’)
otherwise
disp([’ Root = ’ num2str(root) ...
’ found in ’ num2str(iflag) ’ iterations’])
end
We have exploited the new command global which allows variables to be
used by any routine which contains a global statement referring to the same
variables, or a subset of them. This is useful when a quantity (or group of
quantities) is unlikely to change and it saves on long argument lists. We have
also used the number 1e-4 which is 1 × 10−4 (refer to page 7).
The code above is run and gives the result of ≈1 × 10−14 after only four
iterations. In order to identify the other roots (near 1/2 and 3/2) we must use
guesses close to these values. Starting around 0.5 (for instance guesses of 0.4
and 0.6 lead to the code ﬁnding the root at zero again). Starting close to the
other root has a variety of outcomes: starting below it produces the zero root,
whereas above leads to the iterations diverging. The reason for this is linked
to the derivative of g(x). In fact the errors are multiplied by |g′(x)| at each
iteration and if this value is greater than one, the method will fail. In this case
we recall that g(x) = 2 sin x2 so that g′(x) = 4x cos x2 which when x =
1
2
equals 1.9378 and when x = 3
2 gives −3.7690. Near the origin the derivative is
very small and consequently the technique works well.
It appears this method is only able to ﬁnd one root and is thus not very
useful. However, at this stage we could change the code eqn.m to
#
"
 
!
%
% eqn.m
%
function [g] = eqn(x)
g = sqrt(abs(asin(x/2)));

4.4 Bisection
113
This form of the code is a simple alternative way of writing the equation f(x) =
0 as given above. We use the function abs to ensure that the square root
function will not lead to imaginary quantities1. In this case the code ﬁnds the
root near x = 1/2 but again fails to obtain the other one. There may well be
a form of the function which gets this root but any method which requires
this amount of manipulation and user interaction is not suitable for detailed
calculations. There are many ﬂaws with this method and consequently it is not
widely used for one-dimensional problems. However, there are some higher-
dimensional (and more complex) problems for which it is the only feasible
option.
We shall discuss whereby this method is improved upon and instead of using
substitution into a function it uses the fact that a zero corresponds to a change
in sign.
4.4 Bisection
In the previous example we used an initial estimate for a root: here we shall
use a bracketing interval. Our initial assumption is that this interval contains
a single root. In order to check this hypothesis we shall build in checks at each
stage.
If the initial interval is between x = a and x = b we know that f(a) and
f(b) are of diﬀerent signs (for the interval to contain a single root): in which
case their product must be negative. As the name of the method suggests we
bisect the interval and deﬁne the point c = (b + a)/2. We can now evaluate the
function to obtain f(c).
1 To evaluate the arcsine we have used the MATLAB command asin, as you might
expect there are also acos and atan, as mentioned previously.

114
4. Root Finding
a
b
c = a + b
2
This must either be positive or negative (or if we are very lucky zero). In
which case f(c) will have the same sign as either f(a) or f(b). The new interval
can then be deﬁned as c and whichever end of the previous interval represents
a change in sign of the function.
A simple version of a code to use this method in an interval [a, b] would be
'
&
$
%
a = 1; b = 5;
for j = 1:10
c = (a+b)/2;
if f(c)*f(a) > 0
a = c;
else
b = c;
end
end
where in this case a = 1, b = 5 and the function f(x) is deﬁned in a routine f.m.
This method is perfectly adequate if you know that the method will converge
in ten steps, the interval [a, b] actually contains a root and no future iterations
actually coincide with a root (see Task 4.8).
If we wish to be slightly more careful we would use the codes

4.4 Bisection
115
'
&
$
%
%
% bisect.m
%
function [answer,iflag] = bisect(fun,a,b)
global tolerance maxits
iflag = 0;
iterations = 0 ;
f_a = feval(fun,a);
f_b = feval(fun,b);
while ((f_a*f_b<0) & iterations<maxits) & (b-a)>tolerance
iterations = iterations + 1 ;
c = (b+a)/2;
f_c = feval(fun,c);
if f_c*f_a<0
b=c; f_b = f_c;
elseif f_b*f_c<0
a=c; f_a = f_c;
else
iflag = 1; answer = c;
end
end
switch iterations
case maxits
iflag = -1; answer = NaN;
case 0
iflag = -2; answer = NaN;
otherwise
iflag = iterations; answer = c;
end
#
"
 
!
%
% func.m
%
function [f] = func(x)
f = x-2*sin(x.ˆ2);
and the main controlling function

116
4. Root Finding
'
&
$
%
%
% mbisect.m
%
global tolerance maxits
tolerance = 1e-4;
maxits = 30;
xlower = 0.4;
xupper = 0.6;
[root,iflag] = bisect(’func’,xlower,xupper);
switch iflag
case -1
disp(’Root finding failed’)
case -2
disp(’Initial range does not only contain one root’)
otherwise
disp([’ Root = ’ num2str(root) ...
’ found in ’ num2str(iflag) ’ iterations’])
end
This method is guaranteed to work provided only one root is in the relevant
interval and the function is continuous. It may work if there are three roots but
this is not recommended: in fact it appears to work provided there are an odd
number of roots, because each iteration may remove a number of roots which is
guaranteed to be even. We note that the length of the interval after n iterations
is (b −a)/2n. Hence if we wish to know the root to within a given tolerance
we can work out how many iterations we need to perform. For instance if the
required tolerance is ϵ, we ﬁnd that we need
n >
1
ln 2 ln
b −a
ϵ

.
Example 4.2 To determine a root of a continuous function f(x) between zero
and one, given that f(0)f(1) < 0 to within 1×10−4 requires n > ln(104)/ ln 2 ≈
13.28: in other words fourteen iterations.
We shall now discuss other methods for solving equations of the form f(x) =
0 which exploit the form of the derivative (or at least an approximation to it)
as well as the function.

4.5 Newton–Raphson and Secant Methods
117
4.5 Newton–Raphson and Secant Methods
These methods are related and often confused. We shall derive them in tandem,
since in reality they only diﬀer in the last stage. The central premise for both
methods is that the function is locally linear and the next iteration for the
required value can be attained via linear extrapolation (or interpolation).
4.5.1 Derivation of the Newton–Raphson Method
We will start using a Taylor series to derive the Newton–Raphson technique2.
We assume the current guess is x and this is incorrect by an amount h, so that
x + h is the required value. It now remains for us to determine h or at least
ﬁnd an approximation to it. The Taylor expansion for the function f(x) at the
point x + h is given by
f(x + h) = f(x) + hf ′(x) + O(h2).
This can be interpreted as: the value of the function at x + h is equal to the
value of the function at x plus the gradient times the distance between the
points. This can be considered to include further terms; at the moment we are
ﬁtting a straight line.
In this expression we have used the term O(h2): loosely this means some-
thing the same size as h2 and also the prime means diﬀerentiated with respect
to the argument of the function. We now note that x + h is supposedly the
actual root so f(x+h) = 0, and discarding the higher-order terms we ﬁnd that
h ≈−f(x)
f ′(x).
(4.1)
This presumes we are close to the actual root, and consequently we can dis-
card the terms proportional to h2 since these should be smaller than those
proportional to h.
This allows us to construct the iterative scheme
xn+1 = xn −f(xn)
f ′(xn),
n = 0, 1, 2, · · · .
This method can also be derived using geometric arguments. In these deriva-
tions the function is taken to be approximated by a straight line in order to
determine the next point.
2 If you haven’t seen Taylor series refer to the geometric argument on the next page.

118
4. Root Finding
h
xn
xn+1
f(xn)
The value of h is determined by using the fact that the ratio of the two
sides h and f(xn) has to be equal to f ′(xn).
At the moment we shall presume that we have two routines func.m and
func prime.m which give us the function and its derivative. For ease let us
consider the function f(x) = x −2 sin x2, so f ′(x) = 1 −4x cos x2 (using the
chain rule). The code func.m is given on page 115 and the other one is:
#
"
 
!
%
% func_prime.m
%
function [value] = func_prime(x)
value = 1 - 4*x.*cos(x.ˆ2);
Notice that we have used the dot operators, even though this routine is only
ever likely to be called in this context using a scalar. This permits the routine
to be used from other codes in a portable fashion.
This can be coded simply using




x = 1;
for j = 1:10
x = x - func(x)/func_prime(x);
end
where we have set the initial guess to be x = 1 and supposed that the method
will converge in ten iterations. We now give a more robust code to perform the

4.5 Newton–Raphson and Secant Methods
119
iterations
'
&
$
%
%
% Newton_Raphson.m
%
x = input(’Starting guess :’);
tolerance = 1e-8;
iterations = 0;
while (iterations<30) & (abs(func(x))>tolerance)
x = x-func(x)/func_prime(x);
iterations = iterations + 1;
end
if iterations==30
disp(’No root found’)
else
disp([’ Root = ’ num2str(x,10) ’ found in ’ ...
int2str(iterations) ’ iterations.’])
end
Hopefully you can see the diﬀerence between the two codes and see that ulti-
mately the second version is more useful. By entering the values 0.1, 0.6 and
1.5 we can obtain the three roots we are concerned with. Notice we have in-
creased the number of digits printed in the answer to 10 using the form of the
MATLAB command num2str which accepts two arguments.
We shall discuss the possibilities open to us when we do not know the
derivative of the function, but we are able to evaluate the function. This relies
on the classical deﬁnition of the derivative, which we shall write as
f ′(x) = lim
δ→0
f(x + δ) −f(x)
δ
.
This allows the previous routine to be rewritten without using func prime.m,
but we need to deﬁne a practical value of δ for this purpose. In general a value
of around 10−6 is suitable, but this may need to be changed depending on the
problem. There is also a version of the method whereby δ is changed during
the iteration process (dependent on the current value of h, see Equation (4.1)).
The previous code is now changed to be

120
4. Root Finding
'
&
$
%
%
% Newton_Raphson_S.m
%
x = input(’Starting guess :’);
tolerance = 1e-8;
iterations = 0;
delta = 1e-6;
while (iterations<30) & (abs(func(x))>tolerance)
f0 = func(x);
f1 = func(x+delta);
x = x-f0*delta/(f1-f0);
iterations = iterations + 1;
end
if iterations==30
disp(’No root found’)
else
disp([’ Root = ’ num2str(x,10) ’ found in ’ ...
num2str(iterations) ’ iterations.’])
end
or alternatively the short version would be
#
"
 
!
del = 1e-6;
x = 1;
for j = 1:10
x = x-del*func(x)/(func(x+del)-func(x));
end
We have changed the name of this method to Newton Raphson S.m since it is
similar to the next method we will discuss, namely the secant technique.
This method starts with two values of x, namely x = x0 and x = x1. A
straight line is drawn between the points (x0, f(x0)) and (x1, f(x1)), which has
the equation
y −f(x0)
f(x1) −f(x0) = x −x0
x1 −x0
.
We wish to ﬁnd the value of x (x2 say) for which y = 0 which is given by
x2 = x0 −f(x0)
x1 −x0
f(x1) −f(x0).
We then move on so that we are going to use x = x1 and x = x2 as the next
two points. This is coded to give:

4.5 Newton–Raphson and Secant Methods
121
'
&
$
%
%
% Secant.m
%
x0 = input(’Starting guess point 1 :’);
x1 = input(’Starting guess point 2 :’);
tolerance = 1e-8;
iterations = 0;
while (iterations<30) & (abs(func(x1))>tolerance)
iterations = iterations + 1 ;
f0 = func(x0);
f1 = func(x1);
x2 = x0-f0*(x1-x0)/(f1-f0);
x0 = x1;
x1 = x2;
end
if iterations==30
disp(’No root found’)
else
disp([’ Root = ’ num2str(x1,10) ’ found in ’ ...
num2str(iterations) ’ iterations.’])
end
This method works far better if the two initial points are on opposite sides of
the root. In the above method we have merely chosen to proceed to use x1 and
the newly attained point x2: however we could equally have chosen x0 and x2.
In order to determine which we should use we require that the function changes
sign between the two ends of the interval. This is done by changing the lines
where the next interval is chosen.

122
4. Root Finding
'
&
$
%
%
% False_Position.m
%
x0 = input(’Starting guess point 1 :’);
x1 = input(’Starting guess point 2 :’);
x2 = x0;
tol = 1e-8;
iters = 0;
while ((iters<30) & (abs(func(x2))>tol))|(iters==0)
iterations = iterations + 1 ;
f0 = func(x0);
f1 = func(x1);
x2 = x0-f0*(x1-x0)/(f1-f0);
if func(x2)*f0 < 0
x1 = x2;
else
x0 = x2;
end
end
if iters==30
disp(’No root found’)
else
disp([’ Root = ’ num2str(x2,10) ’ found in ’ ...
num2str(iters) ’ iters.’])
end
Example 4.3 We consider the function f(x) = xm −a where a > 0. The roots
of this equation are
m√a or, written another way, a1/m. For this equation we
can write the Newton–Raphson scheme as:
xn+1 = xn −xm
n −a
mxm−1
n
,
which can be simpliﬁed to yield:
xn+1 = xn

1 −1
m

+
a
mxm−1
n
.
Notice this is exactly the map solved in the example on page 91, with a = 3 and
m = 2.

4.6 Repeated Roots of Functions
123
Example 4.4 Using the Newton–Raphson routine determine the zero of the
function f(x) = ex −e−2x + 1. This can be done by setting up the functions




function [value] = func(x)
value = exp(x)-exp(-2*x)+1;




function [value] = func_prime(x)
value = exp(x)+2*exp(-2*x);
This yields the result
>> Newton_Raphson
Starting guess :-2
Root = -0.2811995743 found in 8 iterations.
(with a tolerance of 1×10−10). In fact we can solve this equation by introducing
the variable X = ex, and noting that X is never zero. We can rewrite f(x) as
f(x) =
1
X2

X3 −1 + X2
.
This equation can be solved directly and the real root is found to be
X =
3
100 + 12
√
69
6
+
2
3
3
100 + 12
√
69
−1
3,
or by using the MATLAB code co=[1 1 0 -1]; roots(co). Then to retrieve
the root of the equation we use the fact that x = ln X.
4.6 Repeated Roots of Functions
Here we shall brieﬂy discuss an additional technique which can be used to
determine repeated roots. We shall presume the function is known analytically.
We note the bisection method requires the function to change sign and the
Newton–Raphson method requires that the ﬁrst derivative is non-zero. Both
of these limitations pose potential problems. Consider a polynomial p(x) with
a repeated root (of order n > 1) at the point x = λ. This means that we can
write p(x) as
(x −λ)n q(x),

124
4. Root Finding
where q(λ) ̸= 0 (since the root is of order n). Let us now consider the derivative
of p(x) at x = λ, so that
dp
dx = n (x −λ)n−1 q(x) + (x −λ)n dq
dx
so evaluating at x = λ, we ﬁnd
dp
dx




x=λ
= 0.
This means the methods which use the derivative are bound to fail.
Let us return to the derivation of the techniques using a Taylor series, where
we recall that x + h is deigned to be the correct solution, so that
0 = f(x + h) = f(x) + hf ′(x) + h2
2 f ′′(x) + O(h3).
We now note that near the required repeated root f ′(x) will be almost zero, so
we consider the extra term which is proportional to h2. To ﬁnd h we solve the
quadratic:
h(±) = −f ′(x) ±

(f ′(x))2 −2f(x)f ′′(x)
2f ′′(x)
.
And we can deﬁne the next point in the sequence as
x(±)
n+1 = xn + h(±).
But we do not know whether to take the positive or negative root. In the follow-
ing code we calculate the value of the function at each of x(±)
n+1 and determine
which has the smaller magnitude.
'
&
$
%
x=1.1;
for its=1:20
[f,fp,fpp] = fun2(x);
h1 = (-fp+sqrt(fpˆ2-2*f*fpp))/(2*fpp);
h2 = (-fp-sqrt(fpˆ2-2*f*fpp))/(2*fpp);
[f1,f1p,f1pp] = fun2(x+h1);
[f2,f2p,f2pp] = fun2(x+h2);
if abs(f1)<abs(f2)
x = x+h1
else
x = x+h2
end
end

4.7 Zeros of Higher-Dimensional Functions(*)
125
which calls




function [f,fp,fpp] = fun2(x);
f = x.ˆ4+3*x.ˆ3-12*x.ˆ2-20*x+48;
fp = 4*x.ˆ3+9*x.ˆ2-24*x-20;
fpp = 12*x.ˆ2+18*x-24;
We note that the above code is not limited to real numbers. In this example
we have considered the case p(x) = x4 + 3x3 −12x2 −20x + 48 which has roots
at x = −3, x = −4 and x = 2 (twice).
There are other methods of getting round these problems, and indeed these
can be applied for higher-order zeros.
4.7 Zeros of Higher-Dimensional Functions(*)
We note that the Newton–Raphson scheme is readily extended to a technique
whereby one can locate the zero of a higher-dimensional function. Let us con-
sider the zero to occur at x = x∗and the function is f(x). For instance
f(x, y) = (sin(x + y), x2 −y2), which has zero at the origin (0, 0). We can
derive this scheme using the multi-dimensional Taylor series. We presume that
we have a current iterate xg and that x∗= xg + h. By deﬁnition f(x∗) = 0,
hence
0 = f(xg + h) = f(xg) + ∇f|xg · h + O(|h|2)
where we shall explain the notation ∇f · h in due course, but we note that
this can be written as a matrix A times the vector h. We can solve the above
equation for the h (where we assume that O(|h|2) is suﬃciently small enough
to neglect). This gives
h = −A−1f(xg).
We now discuss the entries of the matrix A. Let us consider f : Rn →Rn,
in other words
f(x) = (f1(x1, · · · , xn), · · · , fn(x1, · · · , xn)) .
The elements of the matrix A are
ai,j = ∂fi
∂xj
.
The guess for the value of xg is then updated.

126
4. Root Finding
Example 4.5 Determine the zeros of the function f : R2 →R2 such that
f(x) = (f, g) = (x2 −y2 + 3, (x + 2)2 −y)
where we have used (x1, x2) = (x, y). In this case the matrix A is

∂f
∂x
∂f
∂y
∂g
∂x
∂g
∂y

=

2x
−2y
2(x + 2)
−1

.
The code for solving this is:
'
&
$
%
xg = 1; yg = 1;
for its = 1:10
f = [xgˆ2-ygˆ2+3; (xg+2)ˆ2-yg];
A = [2*xg -2*yg; 2*(xg+2) -1];
h = -A\f;
xg = xg+h(1);
yg = yg+h(2);
end
This gives values (−0.6410, 1.8469) and the value of f of the order of 10−15.
We can check this by noting that y = (x+2)2 and then substituting into f(x, y)
we have
x2 −(x + 2)4 + 3 = x2 −(x4 + 8x3 + 24x2 + 32x + 16) + 3
= −x4 −8x3 −23x2 −32x −13.
The roots of which can be found using the commands




a = [-1 -8 -23 -32 -13];
x =
roots(a)
y = (x+2).ˆ2;
which we shall meet in due course. This gives:
>> x
x =
-4.1124
-1.6233 + 1.5154i
-1.6233 - 1.5154i
-0.6410

4.7 Zeros of Higher-Dimensional Functions(*)
127
>> y
y =
4.4623
-2.1546 + 1.1417i
-2.1546 - 1.1417i
1.8469
Notice we ﬁnd another real root and pairs of complex answers.
In this example we have just performed 10 iterations: however in reality
we would wish to stop once a certain tolerance is achieved. This could be
accomplished by adding an if statement:




if norm(f) < 1e-12
break
end
The command norm calculates the magnitude of the vector (see help norm).
This code should be added after the line evaluating f. We should also check
whether the calculation has actually converged or merely exceeded the maxi-
mum number of iterations. This can be done by adding the code
'
&
$
%
if norm(f) > 1e-12
disp(’Routine did not converge’)
else
disp(’Answer is’)
disp([’ x=’ num2str(xg)])
disp([’ y=’ num2str(yg)])
end
In general we will not be able to determine the partial derivatives of the
functions analytically and we rely on the local approximations to the derivatives
such that
∂f
∂x = lim
δ→0
f(x + δ, y) −f(x, y)
δ
and ∂f
∂y = lim
δ→0
f(x, y + δ) −f(x, y)
δ
.
We note that this method can be used to ﬁnd turning points of functions,
in higher dimensions. For instance consider f : R2 →R the turning points are
such that ∂f/∂x = ∂f/∂y = 0, so we deﬁne f as (∂f/∂x, ∂f/∂y) and seek zeros
of f.

128
4. Root Finding
4.8 MATLAB Routines for Finding Zeros
4.8.1 Roots of a Polynomial
As we have seen MATLAB has a speciﬁc command for ﬁnding the roots of a
polynomial, namely roots. The coeﬃcients of the polynomial are placed in a
vector c and the routine returns the corresponding roots. It is very simple to
use, but care is need when entering the coeﬃcients.
Example 4.6 Find the roots of the quintic equation f(x) = x5 −x4 + x3 +
2x2 −1.
This is accomplished using the code:




c = [1 -1 1 2 0 -1];
roots(c)
There are a couple of things to note from this example:
– The polynomial’s coeﬃcients are listed starting with the one corresponding
to the largest power.
– It is crucial that zeros are included in the sequence where necessary (in the
above we have included the zero times x term).
– As a simple check, a polynomial of order p has p + 1 coeﬃcients, i.e. a
quadratic has three coeﬃcients and a polynomial of degree p will have p
roots. So as long as the coeﬃcients of the polynomial are real, the roots will
be real or occur in complex conjugate pairs.
4.8.2 The Command fzero
The MATLAB command fzero is very powerful. It actually chooses which
scheme should be used to solve a given problem. Let us try the form of the
command




fzero(’func’, 0.4, optimset(’disp’,’iter’))
This produces

4.8 MATLAB Routines for Finding Zeros
129
Func-count
x
f(x)
Procedure
1
0.4
0.0813636
initial
2
0.388686
0.0876803
search
3
0.411314
0.0745675
search
4
0.384
0.0901556
search
5
0.416
0.071613
search
6
0.377373
0.0935142
search
7
0.422627
0.067296
search
8
0.368
0.0979791
search
9
0.432
0.0609148
search
10
0.354745
0.103721
search
11
0.445255
0.0513434
search
12
0.336
0.110687
search
13
0.464
0.0367268
search
14
0.30949
0.118215
search
15
0.49051
0.0139394
search
16
0.272
0.124167
search
17
0.528
-0.0223736
search
Looking for a zero in the interval [0.272, 0.528]
18
0.488914
0.0153797
interpolation
19
0.504837
0.000616579
interpolation
20
0.505484
-1.5963e-06
interpolation
21
0.505482
1.80934e-09
interpolation
22
0.505482
5.32907e-15
interpolation
23
0.505482
0
interpolation
Zero found in the interval: [0.272, 0.528].
ans =
0.50548227233930
The command uses many diﬀerent forms but here we are looking for a root of
the function deﬁned in func.m near the value x = 0.4 and the options are set
to display iterations.
Example 4.7 Determine the zero of the function f(x) = x −x2 sin x nearest
to x = 1. We need to set up the code

130
4. Root Finding




function [val] = myfunc(x)
val = x-x.ˆ2.*sin(x);
and then use the inline command fzero(’myfunc’,1). This gives
>> fzero(’myfunc’,1)
Zero found in the interval: [0.84, 1.16].
ans =
1.1142
4.9 Tasks
Task 4.1 Modify the codes userfn.m and testplotm.m to determine the lo-
cations of the roots of the function f(x) = x sin x between 0 and 10. Use the
ginput command to make sure that you have reasonable estimates of the lo-
cations of the zeros. Notice the code userfn.m as it stands takes two input
parameters, whereas this function does not need any parameters and as such
the function can be changed to only have one input, namely x. You should also
make sure you use a dot in the calculation, since the function will be applied to
vectors.
Task 4.2 Given that ex > 0 ∀x show that cosh x has no zeros and sinh x
has only one. Consequently comment on the zeros of the function f(x) =
coshm x sinhn x where n, m ∈N.
Task 4.3 Determine the location of the roots of the polynomial f(x) = x2 +
bx + 1, b ∈R, giving details of when you expect there to be no real roots, one
roots or two real roots. (Attempt this mathematically but then use MATLAB’s
plotting routine to verify your ﬁndings.)
Task 4.4 Consider the function f(x) = sin x + β cos x β ∈R and derive an
expression for the value of the zeros of f(x) mathematically. Use MATLAB to
verify your answer for certain values of β (perhaps using zero and one as a
start).

4.9 Tasks
131
Task 4.5 Modify the code eqn.m (page 112) to determine the zeros of the func-
tion f(x) = 2 cos x −sin x between −2π and 2π using the ﬁxed point method.
(You may need to use a plot of the function to identify initial guesses for the
values.)
Task 4.6 Consider, using the ﬁxed point method, the zeros of the function
f(x) = x2 + bx + 1 and the two ways of rewriting the function in the required
form as g(x) = −(x2 + 1)/b and g(x) = −

−(bx + 1). Using the results from
Task 4.3 state which method is appropriate (if either) for a given value of b.
(Recall we require |g′(x)| < 1 for the method to work.)
Task 4.7 Use the bisection method to determine the zero of the function
f(x) = 2x2 −x3 + sin x between one and three. You will need to enter the
codes bisect.m, mbisect.m and func.m. The code bisect.m does not need
modiﬁcation: however you need to change func.m to evaluate the function f(x)
at a point x (again remember to use the dots in the correct place). You also
need to change mbisect.m to reﬂect the fact that we are seeking a zero of the
function deﬁned in func.m in the range 1 to 3.
Task 4.8 Consider the function f(x) = cos 3x between 0 and π. Comment on
the bisection method using the ranges [0, π], [0, 7π/8] and ﬁnally [π/8, π]. It is
not necessary to write a code to solve this problem; you should sketch the curve
and work out what is likely to happen.
Task 4.9 Using the Newton–Raphson method calculate the roots of the func-
tions f(x) = x cos x −sin x and g(x) = (x3 −x) sin x. These should be done
as two separate calculations. You will need to write two MATLAB functions
for each case to evaluate the function and its derivative. These should be called
func.m and func prime.m so that they can be called from Newton Raphson.m
(alternatively you could change the line in Newton Raphson.m to reﬂect that
you are using diﬀerent function names).
Task 4.10 Using the method of False Position ﬁnd the roots of the function
sin(x −x3) between x = 0 and x = 6.
Task 4.11 Using the knowledge that the polynomial p(x) = x3 −4x2 + 5x −2
has a repeated root, determine its location.

132
4. Root Finding
Task 4.12 Using the command roots calculate the solutions of the equations
x3 + x2 + x + 1 = 0 and −2x + x5 + x2 = 4.
Here you need to be careful that the coeﬃcients of the polynomials are entered
correctly as vectors.
Task 4.13 Using the command fzero investigate the roots of the functions
x sin x + cos x, (sin x)3 −sin x and (x2 −4x + 5)/(x −1).
Task 4.14 (*) The solutions of the diﬀerential equation
x2 d2y
dx2 + xdy
dx +

x2 −1
4

y = 0
are given by J1/2(x) and Y1/2(x), which are called Bessel functions. Using the
MATLAB command besselj(nu,x) (where nu is equal to 1/2 in this case)
and fzero determine the zeros of the function J1/2(x) in the interval (0, 20].
Task 4.15 (D) The following codes are designed to ﬁnd a root of the function
f(x) = x sin x −x2 cos x −1 using the Newton–Raphson method




function [out] = f(in)
f = x*sin x - xˆ2 cos x:
f.m




function [out] = fp(in)
fp = (x+1)*cos x - 2*x sin x:
fp.m
'
&
$
%
x = 0;
for j = 1:1
x = x - fp(x)/f(x);
end

5
Interpolation and Extrapolation
5.1 Introduction
We shall now consider the problem where we know the values of a function at a
certain set of predetermined points, (x1, f1), (x2, f2), · · · through to (xN, fN).
The question to be answered in this chapter is what values does the function
take at intermediate values of x (which is called interpolation), or alternatively
what values does the function take external to this range (which is called ex-
trapolation).
It is worth pausing here to think how we would determine an intermediate
data value in practice:
0
1
2
3
4
5
6
7
8
0
1
2
3
4
5
6
7
8
9
10
x
y

134
5. Interpolation and Extrapolation
If we presume we are given the original data set, shown here as circles, we
might join them together with straight lines (as shown). In order to work out
the value at x = 3.5 say, we would draw a vertical line and see where it crossed
the appropriate segment. Then a horizontal line would be drawn and the value
read oﬀthe y-axis. In the main this is exactly the technique used: however
diﬀering degrees of approximations are used to create the lines between the
points. We shall start by discussing how we might obtain the original data.
5.2 Saving and Reading Data
In this Chapter we will generally need to read data from a ﬁle. Within the
context of MATLAB there are two routes open to us for this procedure and
it will depend on how the data was initially saved. For illustration we shall
presume we have a MATLAB session which has created a set of variables:
>> whos
Name
Size
Bytes
Class
a
3x4
96
double array
a1
2x2
32
double array
b
6x6
288
double array
c
1x5
40
double array
z
1x1
16
double array (complex)
Grand total is 58 elements using 472 bytes
Here we have used the command whos to list all the current variables, and it
gives information concerning: their size (both in terms of dimensions and in
memory, given in bytes) and their class. Most of these are classed as “double
array” which means they are real matrices. The ﬁnal variable z is a one-by-one
matrix which is complex. The command also gives information concerning the
total number of elements (that is the sum of the product of the dimensions of
the matrices) and the total memory. If we wished to only list those variables
starting with a we could use:
>> whos a*
Name
Size
Bytes
Class
a
3x4
96
double array
a1
2x2
32
double array

5.2 Saving and Reading Data
135
Grand total is 16 elements using 128 bytes
or if we just wanted the names of the variables we could use:
who
Your variables are:
a
a1
b
c
z
If we only wanted information about one variable we could just use the con-
struction whos a1, for instance.
In order to save the data we use the command save. The help command is
very helpful here (help save). However, we shall give a synopsis here of the
main points.
To save all the variables which are currently in use:




% Save all current variables in a file
% session_vars.mat
save session_vars
This creates a ﬁle called session vars.mat, where the ﬁrst part of this ﬁlename
is user-deﬁned to reﬂect the contents of the ﬁle and the second part .mat deﬁnes
it as a MATLAB ﬁle containing variables. Note this suﬃx may also be used by
another package and as such it will be diﬃcult to use the Open menu. This ﬁle
now contains the actual variables, which means both their names and values
are stored.
They can be reloaded using the command




% Loads the variables stored in the
% file session_vars.mat
load session_vars
We note the default ﬁle name for ﬁles of this type end with .mat and as
such we are asking MATLAB to load the ﬁle session vars.mat. This ﬁle is
very special since it actually contains information concerning the variables as
well. If we wish to save only certain variables we can list them:

136
5. Interpolation and Extrapolation
'
&
$
%
% Save the variables a & a1 to the
% file session_vars.mat
save session_vars a a1
% Save all variables starting with b
% to session_vars.mat
save session_vars b*
% Append all variables starting with ca
% to the file session_vars.mat
save session_vars ca* -append
This last command is particularly useful since it adds the variables to the ﬁle
whereas the previous ones erase all the other variables currently stored in the
ﬁles.
If we merely want to save the data from variables (rather than their names)
we can again use save but with a diﬀerent syntax. This time we shall specify
the entire ﬁlename, which needs to be enclosed within single quotes.




save ’session_vals.dat’ a a1 -ascii
This produces an ASCII (American Standard Code for Information Inter-
change – basically human readable) ﬁle containing the values of the variables
a and a1. This creates a ﬁle whose contents looks like:
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
1.0000000e+000
where the variables were deﬁned as a = ones(3); a1 = ones(4). The prob-
lem with this technique is we cannot read this back into MATLAB directly
using load (it complains there are not the same number of pieces of data in
each line). It cannot know this is a three-by-three matrix followed by a four-by-
four one. There are other options for this command which allow extra precision,
for instance -double.
The problem here is that we need to have knowledge about the data in the
ﬁle to understand the form we wish to read it in. For example consider a ﬁle
containing the data

5.2 Saving and Reading Data
137
1.0000000e+000
2.0000000e+000
3.0000000e+000
4.0000000e+000
1.0000000e+000
4.0000000e+000
9.0000000e+000
1.6000000e+001
(this was created using the code: x = 1:4; y = x.ˆ2; save ’bob1.dat’ x
y -ascii). This contains two rows vectors and we can load this using:




load ’bob1.dat’
Now using the command whos we can see that we have a two-by-four ar-
ray called bob1. We can now extract the data using a = bob1(1,:); b =
bob1(2,:); clear bob1. These commands give us the ﬁrst row and the second
row in the row vectors a and b; ﬁnally we clear the array bob1 since we have
extracted the requisite data. Whilst this last stage is not necessary it is good
practice to keep track of the variables you have. Notice there is no requirement
that the variables are called the same as when they were saved (since usually
you won’t know what they were called).
This is probably the best way of reading in data from another source, pro-
vided the data is rectangular in shape. However, there is a further method
which can be used. This involves the commands fopen, fprintf, fscanf and
fclose. These commands are very powerful and as you might expect quite
complicated to use:
'
&
$
%
x = 0:.4:2;
y = [x; exp(x).*cos(2*x)];
fid = fopen(’data.dat’,’w’);
fprintf(fid,’%6.2f
%12.8f\n’,y);
fclose(fid);
In the ﬁrst two lines we set up a vector x running from 0 to 2 in steps of 0.4 and
then a matrix y comprising two columns (ﬁrst x and then the corresponding
values of the function ex cos 2x). The next line opens a ﬁle data.dat using the
command fopen (note the fact that the ﬁlename must be enclosed in single
quotes). The ﬁrst argument is the ﬁlename and the second one reﬂects what
we are going to do: in this case write to the ﬁle. The options for this second
argument are:

138
5. Interpolation and Extrapolation
’r’
read
’w’
write (create if necessary)
’a’
append (create if necessary)
’r+’
read and write (do not create)
’w+’
truncate or create for read and write
’a+’
read and append (create if necessary)
’W’
write without automatic ﬂushing
’A’
append without automatic ﬂushing
(this list can be obtained by typing help fopen). The variable fid is an iden-
tiﬁer or handle for the ﬁle and as such will be used in all commands related
to that ﬁle. If the command fopen is successful fid will be a scalar integer
(it will have value minus one if it is unsuccessful). We can now refer to this
ﬁle merely using this variable (you can actually use the integer value but this
is not advisable). The next line uses the command fprintf which has three
arguments: the ﬁle identiﬁer (fid), the format and the variable to be written.
We need to ensure the format matches the data. The format here prints
two numbers per line, the ﬁrst one ‘%6.2f’ corresponds to a ﬁxed point number
with 2 places after the decimal point using six characters in total; the second
one ‘%12.8f’ has eight places after the decimal point and uses 12 characters in
total. There are several other formats and these are based on those from the C
language. The other option of the most use is e, so the line would be changed
to:




fprintf(fid,’%6.2e %12.8e \n’,y)
which produces ﬂoating point versions of the above. The command \n gives a
new line after printing the two numbers, whilst we could place a tab between
the characters using \t.
Finally we use the command fclose(fid) to close the ﬁle corresponding
to the the ﬁle identiﬁer fid. It is very good practice to close the ﬁles we are
using as soon as we have ﬁnished with them.
This produces a ﬁle called data.dat which contains:
0.00
1.00000000
0.40
1.03936428
0.80
-0.06498473
1.20
-2.44823335
1.60
-4.94458639
2.00
-4.82980938
We could read the data back into MATLAB using the command fscanf:
this is similar syntactically to fprintf except we now specify the shape of what
is to be read in. The simplest way of reading in the above data would be:

5.3 Which Points to Use?
139




clear all
load ’data.dat’
x = data(:,1);
f = data(:,2);
since it is rectangular. We shall now presume we do not know the functional
form of our data. The following sections will use the data contained within
data.dat as an example. It is suggested that you type the above code to create
the ﬁle (or you can directly enter the data).
5.3 Which Points to Use?
We pause here to discuss the problem of which points to use for the process,
in general we apply the following method.
Pick those closest!
Important Point
This can be done by hand, or can be automated. For this purpose we use
the routine findrange.m:

140
5. Interpolation and Extrapolation
'
&
$
%
function [ibot,itop] = findrange(x,z,N)
if mod(N+1,2)˜=0
disp(’Must use odd N’)
break
end
points = (N+1)/2; % Half number of points in stencil
[ii] = find(x>z);
if isempty(ii)
itop = length(x);
else
i = ii(1);
end
itop = i+points-1;
ibot = i-points;
if itop>length(x)
itop = length(x);
ibot = length(x)-2*points+1;
elseif ibot<1
itop = 2*points;
ibot = 1;
end
This takes three arguments: x (the data points); z (the point at which the
function is required) and N (the order of the interpolating polynomial; for linear
interpolation N would be 1 and 3 for cubic interpolation). First we check that the
interpolating polynomial is of odd order. This is accomplished by checking that
one plus N is even. The number of points in half the stencil is then calculated
as the variable points. We use the command [ii] = find(x>z); to list the
points contained within x which are greater than z. If there are no points for
which this is true (in which case ii is empty), we can infer that z is greater
than all the values of x and we need to extrapolate using the last few points.
Else we use the ﬁrst value for which x is greater than z (stored in the ﬁrst
element of the array ii). We now have a marker i and we work out the top
and bottom of the stencil as itop and ibot respectively. We now need to deal
with the cases for which the stencil extends beyond the limits of x, that is if
itop is greater than length(x) or if ibot is less than 1 (the ﬁrst element of
x). We now use the end 2*points.
This routine can now be used in other programs to give the extent of the
stencil.

5.4 Newton Forward Diﬀerences and Lagrange Polynomials
141
5.4 Newton Forward Diﬀerences and Lagrange
Polynomials
We shall now discuss the operation of ﬁtting an N th order polynomial through
N + 1 points and remark again this will yield a unique answer. We consider
the set of data points: (x0, f0), (x1, f1), · · · , (xN, fN). We now introduce the
diﬀerence operator ∆such that
∆f0 = f1 −f0 or in general ∆fj = fj+1 −fj.
These are called forward diﬀerences, since points forward of the current value
are used (there are also backward diﬀerences and central diﬀerences, which
we shall meet in our discussion of the solution of diﬀerential equations). We
consider the composition of the operator whereby
∆2f0 = ∆(∆f0) = ∆(f1 −f0) = ∆f1 −∆f0
= (f2 −f1) −(f1 −f0)
= f2 −2f1 + f0.
Of course we can now proceed to deﬁne ∆nf0 in an iterative manner.
We introduce the polynomial
f(x) = f0 + (x −x0)∆f0
h
+ (x −x0)(x −x1)
2!
∆2f0
h2
+ · · ·
,
which will ultimately terminate after N terms. Alternatively this can be written
as:
f(x) = f0 +
N−1

n=1
∆nf0
hnn!
n−1

j=0
(x −xj).
(5.1)
We consider the data values to be equally spaced, so the value of ∆xj is h ∀j.
This analysis can be extended to irregularly spaced points, but we shall not
attempt that here.
We are now able to construct the polynomial (5.1) for a set of points. We
start with a simple example.
Example 5.1 Let us consider the points (0, 1), (1, 3) and (2, 4). Here we have
three points and as such we would expect to obtain a quadratic. We use a tabular
form, which gives:
x
f
∆f
∆2f
0
1
2
−1
1
3
1
2
4

142
5. Interpolation and Extrapolation
Thus we have
f(x) = 1 + (x −0)2
1 + (x −0)(x −1)
2!
(−1)
12 ,
f(x) = 1 + 2x −x(x −1)
2
,
where h = 1, f0 = 1, ∆f0 = 2 and ∆2f0 = −1 (reading from the top row of the
table).
It is possible to prove that the polynomial (5.1) goes through each of the
set of points, but we shall not include that proof here. We remark that vari-
ous conclusions can be drawn from the data by using the forward diﬀerences;
for instance whether it was generated using a polynomial (in which case the
diﬀerences truncate).
We now construct a polynomial which goes through a set of points which
are not necessarily evenly spaced. Let us consider the polynomial
f(z)
=
(z −x2)(z −x3)(z −x4)
(x1 −x2)(x1 −x3)(x1 −x4)f1 +
(z −x1)(z −x3)(z −x4)
(x2 −x1)(x2 −x3)(x2 −x4)f2
+
(z −x1)(z −x2)(z −x4)
(x3 −x1)(x3 −x2)(x3 −x4)f3
+
(z −x1)(z −x2)(z −x3)
(x4 −x1)(x4 −x2)(x4 −x3)f4.
(5.2)
It is worth pausing at this point and checking that this curve goes through
each of the points (xj, fj). For example for j = 3, we set z = x3 and only the
third term is non-zero and we have
f(x3) = (x3 −x1)(x3 −x2)(x3 −x4)
(x3 −x1)(x3 −x2)(x3 −x4)f3 = 1 × f3 = f3.
Hence the value of the polynomial at z = x3 is f3 (as we would hope). This is an
example of a Lagrange polynomial; which could have equally been written
as
f(z) =
4

i=1
fi
4

j=1
j̸=i
z −xj
xi −xj
.
This is a convenient way to write out the cubic we require (as it is relatively
easily extended to higher-order cases) and in order to evaluate it we can use
the MATLAB code:

5.4 Newton Forward Diﬀerences and Lagrange Polynomials
143
'
&
$
%
ip = 1:4;
f_z = 0.0;
for ii = 1:4
jj = find(ip˜=ii);
prod = f(ip(ii));
for kk = jj
prod = prod *(z-x(ip(kk)))/(x(ip(ii))-x(ip(kk)));
end
f_z = f_z + prod;
end
This code probably needs some explanation.
– Firstly we set up a vector ip=1:4 which runs from one to four,
– and then we have a new variable f z which will ultimately contain our
estimate of the function at the point z.
– We now run through the terms in Equation (5.2).
– Inside the loop we construct a vector jj = find(ip∼=ii), which now con-
tains the indices of the locations in vector ip which are not equal to the
current value of ii. The initial value of the variable prod is set equal to the
function evaluated at the corresponding grid point ip(1) etc.
– We then go through the individual terms in the product
– and then ﬁnally add this onto the value f z until we have gone through the
four terms.
This code has been written in this way so it could be extended to as many
points as we want.
For z = 0.6 we ﬁnd a value of f z=0.6386, which is shown on the ﬁgure as
an asterisk:

144
5. Interpolation and Extrapolation
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
−5
−4
−3
−2
−1
0
1
2
As mentioned we can write this expression as a summation of products and
this is easily extended to N points as
f(z) ≈
N

i=1
fi
N

j=1
j̸=i
z −xj
xi −xj
.
Consider the code:

5.4 Newton Forward Diﬀerences and Lagrange Polynomials
145
'
&
$
%
function [value] = poly_int(z,N)
global x f
imax = length(x);
if mod(N,2) ˜= 0
disp(’ N should be even ’)
break
elseif N >= imax;
disp(’Too many points used’)
break
end
M = N/2;
[ibottom,itop] = findrange(x,z,N);
ip = ibottom:itop;
il = 1:N;
f_z = 0.0;
for ii = 1:N
jj = find(il˜=ii);
prod = f(ip(ii));
for kk = jj
prod = prod *(z-x(ip(kk))) ...
/(x(ip(ii))-x(ip(kk)));
end
f_z = f_z + prod;
end
value = f_z;
And now test the code using1
1 We have re-introduced the command isempty, which is true if its argument is
empty.

146
5. Interpolation and Extrapolation
'
&
$
%
global x f
load data.dat
x = data(:,1);
f = data(:,2);
N = length(x);
xmin = x(1); xmax = x(N);
xtest = linspace(xmin,xmax,20);
for ii = 1:20
[ftest(ii)] = poly_int(xtest(ii),N);
end
plot(x,f,’r’,xtest,ftest,’b’)
This gives the plot
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
−6
−5
−4
−3
−2
−1
0
1
2
As you can see using six points works quite well at ﬁtting the data. Although
as we will see in subsequent examples using high-order polynomials can lead to
signiﬁcant errors.

5.4 Newton Forward Diﬀerences and Lagrange Polynomials
147
5.4.1 Linear Interpolation/Extrapolation
We consider the simplest case wherein we have two points (x1, y1) and (x2, y2).
The straight line through these is given by
y = x −x2
x1 −x2
y1 + x −x1
x2 −x1
y2,
which here we have constructed in a Lagrange polynomial style. We note that
the answer is independent of the process here and provided x1 ̸= x2 we will
always get a straight line. This can be continued for quadratics and higher
order functions.
This is a plot of the data we shall use for this discussion:
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
−5
−4
−3
−2
−1
0
1
2
This was obtained using the commands:
'
&
$
%
clear all
load ’data.dat’
plot(data(:,1),data(:,2),’o’,’MarkerSize’,12)
hold on
plot(data(:,1),data(:,2))
hold off
grid on
print -dps2 data.ps
The ﬁrst two commands merely load the data as discussed in the previous
section (the code to generate this data is given on page 137). The next command
plots the data (the ﬁrst column against the second) using circles, whose size
is speciﬁed by ’MarkerSize’ (and set equal to 12). We then hold the ﬁgure
on which stops any future plotting commands overwriting the ﬁgure. Instead

148
5. Interpolation and Extrapolation
they augment the current image. The next plotting command adds the straight
lines. We then turn the holding off so the ﬁgure will be destroyed if we execute
another plot command. We also add a grid to the ﬁgure.
Finally, we print the results to a Postscript ﬁle so that it can be included
in another document (for instance this text) or sent to a printer. There are
many options for this command, for instance we could use print -djpeg90
data.jpg to generate a JPEG ﬁle.
As mentioned above for convenience we can extract the data from the array
data using:




x = data(:,1);
f = data(:,2);
clear data
5.5 Calculating Interpolated and Extrapolated
Values
We shall now describe how MATLAB can be used to determine the interpolat-
ing polynomial for a set of points. We shall presume that we have the requisite
number of points to perform this operation, that is two points for a line, three
for a quadratic and four for a cubic, etc. We shall make use of the MATLAB
command polyfit. The syntax for this command is polyfit(x,y,N), where
the points are deﬁned in x and y, and N is the order of the interpolating polyno-
mial. We note that this function actually uses a least squares approach and ﬁts
the best polynomial (see page 152). This gives the curve we want provide the
number of points represented in x,y is N +1. Let us consider the interpolation
of data points using a straight line.
Example 5.2 We seek to ﬁnd the value of the function at x = 4.5 where the
data points are (1, −3), (3, 4), (5, 5), (7, −8), (9, −3) and (11, 0), using linear
interpolation.

5.5 Calculating Interpolated and Extrapolated Values
149
'
&
$
%
x = [1 3 5 7 9 11];
y = [-3 4 5 -8 -3 0];
xi = 4.5;
r = 2:3; % xi lies between the 2nd and 3rd point of x.
p = polyfit(x(r),y(r),1);
yi = polyval(p,xi)
This gives p=[0.5000 2.5000] (representing the line y = x/2 + 5/2) and
yi=4.75. We note that here we have determined the range r by hand but we
could employ the function findrange (see page 140).
We have used the command polyval(p,xi) to calculate the value of the
interpolating polynomial (represented by its coeﬃcients p) and xi.
We can easily extend this method to use higher-order curves.
Example 5.3 Using the data in the previous example now calculate the value
of the interpolating polynomial at x = 4.5 using cubic interpolation.
'
&
$
%
x = [1 3 5 7 9 11];
y = [-3 4 5 -8 -3 0];
xi = 4.5;
[ibot,itop] = findrange(x,y,3);
r = ibot:itop;
p = polyfit(x(r),y(r),3);
yi = polyval(p,xi)
This gives p=[-0.1667 0.75 2.667 -6.25] and yi=5.75.
We note that this is quite diﬀerent to the answer given by linear interpolation
and one might argue that linear interpolation is better here. This of course
depends on the underlying function.

150
5. Interpolation and Extrapolation
5.6 Splines
We now mention another form of interpolation: this ﬁts a curve in an interval
where the data at the end of the interval coincides with the data points and
also matches the available derivatives with the next interval. If we consider the
points (xi, fi) and (xi+1, fi+1) and ﬁt a straight line this will match the function
values with the intervals on each side (but not necessarily the derivative). We
need to use a higher-order curve. In order to satisfy the requirements we need
at least a cubic, and this is often the preferred option.
If we consider the points to be (xi, fi) for i = 1 to N, we have N −1
intervals. Let us consider the cubic valid over the interval [xi, xi+1] to be
yi(x) = ai + (x −xi)bi + (x −xi)2ci + (x −xi)3di.
We note that we have N −1 cubics each with four unknowns; that is 4N −4
unknowns in total. We now proceed to give details of the conditions which we
can use to specify the values of the coeﬃcients. Firstly we require that the
cubic matches the data values at the ends of the interval:
yi(xi) = fi and yi(xi+1) = fi+1 for i = 1, · · · , N −1;
this in eﬀect ﬁxes the ai and yields 2(N −1) equations. Secondly we require
the gradient and the curvature to match at the interior points:
y′
i(xi+1) = y′
i+1(xi+1) and y′′
i (xi+1) = y′′
i+1(xi+1) for i = 1, · · · , N −2.
This yields a further 2(N −2) equations. Unfortunately we only have 4N −6
equations and as such our system is not totally speciﬁed. We elect to consider
natural splines, for which the curvature is taken to be zero at the ends of the
domain, that is
y′′
1(x1) = 0 and y′′
N−1(xN) = 0.
We can construct a matrix system in order to determine the coeﬃcients. This
can be coded: however the algorithm is quite involved and again MATLAB
comes to our rescue with the command spline.
Example 5.4 Fit a cubic spline to the data x = (1, 2, 3, 5)T , f = (4, 2, 0, 3)T
and plot the interpolated function on a grid z = 0, 0.1, 0.2, · · · , 5.
#
"
 
!
x = [1 2 3 5];
f = [4 2 0 3];
z = 0.:0.1:5;
y = spline(x,f,z);
plot(z,y,x,f,’MarkerSize’,12)

5.6 Splines
151
This yields the results
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
−0.5
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
By way of illustration we shall now construct the splines through the points
(x1, y1), (x2, y2), (x3, y3).
These curves are taken to have the equations
yj(x) = aj + bj(x −xj) + cj(x −xj)2 + dj(x −xj)3,
where j = 1, 2 and 3. This gives us 12 undetermined coeﬃcients and we shall
now describe the equations which they satisfy.
yj(xj) = fj, j = 1, 2, 3: This represents the condition that the spline goes
through the data point at its left-hand end and these give the equations:
a1 = f1,
(5.3a)
a2 = f2,
(5.3b)
a3 = f3.
(5.3c)
yj(xj+1) = fj+1, j = 1, 2, 3: This gives a similar condition at the right-hand
ends:
a1 + h1b1 + h2
1c1 + h3
1d1 = f2,
(5.3d)
a2 + h2b2 + h2
2c2 + h3
2d2 = f3,
(5.3e)
a3 + h3b3 + h2
3c3 + h3
3d3 = f4.
(5.3f)
Here we have introduced hj = xj+1 −xj for convenience.

152
5. Interpolation and Extrapolation
y′
j(xj+1) = y′
j+1(xj+1), j = 1, 2: This is the matching of the ﬁrst derivative at
the internal points, which gives
b1 + 2h1c1 + 3h2
1d1 = b2,
(5.3g)
b2 + 2h2c2 + 3h2
2d2 = b3.
(5.3h)
y′′
j (xj+1) = y′′
j+1(xj+1), j = 1, 2: This is a similar condition for the second
derivative at the internal points:
2c1 + 6h1d1 = c2,
(5.3i)
2c2 + 6h2d2 = c3.
(5.3j)
y′′
1(x1) = 0 and y′′
3(x4) = 0: These are the conditions that the splines at the
ends of the domain are linear at the end points, which gives:
c1 = 0,
(5.3k)
2c3 + 3h3d3 = 0.
(5.3l)
The solution of the above equations gives the required coeﬃcients. Notice that
these coeﬃcients could also have been retrieved using the spline command
and then using the elements of the answer coefs




pp = spline(x,f);
pp.coefs
Note that the coeﬃcients correspond to a cubic without the −xj factors.
This is an example of an object rather than a variable, that is pp.
5.7 Curves of Best Fit
In all of the examples so far we have forced the curves to go through all the
data points. We now relax that requirement. We shall start with a straight
line and optimise the coeﬃcients used to deﬁne it. The straight line is given
by fL(x) which will be of the form ax + b. Let us assume that the error at a
certain point xj is given by (fL(xj) −fj)2, so the total error is
Error: e =
N

i=1
e2
i
=
N

i=1
(fL(xi) −fi)2
=
N

i=1
(axi + b −fi)2 .
(5.4)

5.7 Curves of Best Fit
153
We wish to minimise this expression by choosing a and b accordingly. In order
to determine the actual values of a and b we diﬀerentiate with respect to each
one and set the result equal to zero.
e1
e2
e3
e4
e5
We need to be very careful at this point, and this is included purely for interest:
∂e
∂a =
N

i=1
2xi (axi + b −fi) = 0
and
∂e
∂b =
N

i=1
2 (axi + b −fi) = 0.
These equations can be manipulated to give the simultaneous equations
a
N

i=1
x2
i + b
N

i=1
xi
=
N

i=1
xifi
a
N

i=1
xi + bN
=
N

i=1
fi.

154
5. Interpolation and Extrapolation
We could solve these equations by hand but we shall exploit MATLAB for this
purpose, so that we solve the matrix form of the equation:
⎛
⎜
⎜
⎝
N

i=1
x2
i
N

i=1
xi
N

i=1
xi
N
⎞
⎟
⎟
⎠
 a
b

=
⎛
⎜
⎜
⎝
N

i=1
xifi
N

i=1
fi
⎞
⎟
⎟
⎠
This is coded as:
'
&
$
%
load data.dat;
x = data(:,1); f=data(:,2);
N = length(x);
A = ([sum(x.ˆ2) sum(x); sum(x) N]);
rhs = ([sum(x.*f); sum(f)]);
vect = inv(A)*rhs;
a = vect(1); b = vect(2);
fss = a*x+b;
plot(x,f,’r’,x,fss,’b’)
This yields the plot:
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
−6
−5
−4
−3
−2
−1
0
1
2
As you can see the curve is a reasonable approximation to the points but does
not pass through many (if any) of the actual grid points. This method can be
extended to assume other forms of data.
We could have also used the MATLAB command polyfit which automates
the previous procedure. This is called using [p,s] = polyfit(x,y,n) and ﬁts
a polynomial of degree n for y = y(x). The coeﬃcients for the polynomial
are returned in p and the second variable is associated with the structure and
is used by other commands to assess the level of the error. We can now use

5.8 Interpolation of Non-Smooth Data
155
the command polyval to determine the value of the ﬁtted polynomial at an
intermediate point. This can be called simply as y = polyval(p,x) or in a
more sophisticated form as [y,delta] = polyval(p,x,s), where delta is in
some sense representative of the error and the input argument s is generated
by polyfit.
If we know more about a function we can use higher-order approximations,
or can use combinations of functions.
Example 5.5 Given that a set of data is of the form y = ax + be−x + c state
how one would determine the constants a, b and c.
As with the linear example we deﬁne the sum of the squares of the errors
e =
N

i=1

axi + be−xi + c −fi
2
and seek the values of the constants which minimises this expression. Again we
construct the partial derivatives:
∂e
∂a =
N

i=1
2xi

axi + be−xi + c −fi

,
∂e
∂b =
N

i=1
2e−xi 
axi + be−xi + c −fi

,
∂e
∂c =
N

i=1
2

axi + be−xi + c −fi

.
These equations can then be combined into a matrix form to give:
⎛
⎝
 x2
i
 xie−xi
 xi
 e−xixi
 e−2xi
 e−xi
 xi
 e−xi
 1
⎞
⎠
⎛
⎝
a
b
c
⎞
⎠=
⎛
⎝
 xifi
 e−xifi
 fi
⎞
⎠.
5.8 Interpolation of Non-Smooth Data
We will demonstrate in this example how one might encounter problems with
seemingly simple data. Let us consider

156
5. Interpolation and Extrapolation
x
f
0
1
1
1
2
1
3
1
4
0
5
0
6
0
7
0
This is a simple step function which has a value of 1 from x = 0 to x = 3 and
a value of 0 from x = 4 to x = 7. It is tempting to say
f(x) =
 1
x ⩽3
0
x > 3 .
However we are not sure so we shall try to determine the values of the func-
tion in a systematic fashion. We shall use the command poly int which was
introduced on page 145. This will be supplemented with the code:
'
&
$
%
global x f
str = ’No. of points for interpolation (even): ’;
x = 0:1:7;
f = zeros(size(x));
ii = find(x<4); f(ii) = 1;
z = 0:0.2:7;
nz = length(z);
N = input(str);
for j = 1:nz
f_z(j) = poly_int(z(j),N);
end
figure(1)
t = [’Using ’ num2str(N) ’ points’];
plot(x,f,’o’,z,f_z,’r’)
title(t,’FontSize’,20)
axis([-1 8 min(f_z)-1 max(f_z)+1])

5.8 Interpolation of Non-Smooth Data
157
−1
0
1
2
3
4
5
6
7
8
−1
−0.5
0
0.5
1
1.5
2
Using 2 points
−1
0
1
2
3
4
5
6
7
8
−1
−0.5
0
0.5
1
1.5
2
Using 4 points
−1
0
1
2
3
4
5
6
7
8
−1
−0.5
0
0.5
1
1.5
2
Using 6 points
−1
0
1
2
3
4
5
6
7
8
−1.5
−1
−0.5
0
0.5
1
1.5
2
2.5
Using 8 points
As you can see as more points are used in the interpolation, the approximation
gets steadily worse and the eﬀect extends far from the discontinuity (which
is causing the problem): in fact less points seem to produce less error. The
question remains as to what is the “real” data (it could actually look like the
ﬁgure in the bottom right – although this is not likely).
Let us consider the problem with
x
f
0
1
1
-0.2
2
0.05
3
0.01
4
0.01
5
0.01
6
0.005
7
0.005
In this case we have

158
5. Interpolation and Extrapolation
−1
0
1
2
3
4
5
6
7
8
−1
−0.5
0
0.5
1
1.5
2
Using 2 points
−1
0
1
2
3
4
5
6
7
8
−1
−0.5
0
0.5
1
1.5
2
Using 4 points
−1
0
1
2
3
4
5
6
7
8
−1
−0.5
0
0.5
1
1.5
2
Using 6 points
−1
0
1
2
3
4
5
6
7
8
−1
−0.5
0
0.5
1
1.5
2
Using 8 points
Here we note that the lower-order polynomials produce reasonable approxima-
tions; it is only when we try to ﬁt an octic to the data we observe the problems
at the right-hand end. We need to be aware the accuracy of our interpolated
values is very dependent on the ﬁdelity and resolution of the starting data.
5.8.1 Insuﬃcient Data Points
Let us consider the example f(x) approximated for an interval from −1 to 1,
using N points and at each stage approximating the curve using all the points.

5.8 Interpolation of Non-Smooth Data
159
'
&
$
%
global x f
for n = 2:1:10
x = linspace(-1,1,n);
f = sin(2*x*pi);
z = linspace(-1,1,100);
if mod(n,2)==0
ni = n;
else
ni = n-1;
end
for j = 1:100
f_z(j) = poly_int(z(j),ni);
end
clf
plot(x,f,’o’,’MarkerEdgeColor’,’k’,...
’MarkerFaceColor’,[.49 1 .63],...
’MarkerSize’,12)
hold on
plot(z,f_z,z,sin(2*z*pi),’--’)
hold off
yrange_max = max(max(f_z),1);
yrange_min = min(min(f_z),-1);
axis([-1.2 1.2 yrange_min-0.2 yrange_max+0.2])
t = [’Interpolated using ’ num2str(n) ’ data points ’];
title(t)
ti = [’int’ num2str(n) ’.ps’];
h = gcf;
print(h,’-dps2’,ti)
pause
end
This program waits for the user to press a key between each plot. It also uses
gcf which returns a handle to the current ﬁgure. This allows a diﬀerent form
of the print command to be used which permits the ﬁlename to be passed as
a string, namely ti which is changed depending on how many points are used.
This code gives

160
5. Interpolation and Extrapolation
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
Interpolated using 2 data points 
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
Interpolated using 3 data points 
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−1
−0.5
0
0.5
1
Interpolated using 4 data points 
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
Interpolated using 5 data points 
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
Interpolated using 6 data points 
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−1.5
−1
−0.5
0
0.5
1
1.5
Interpolated using 7 data points 
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−1
−0.5
0
0.5
1
Interpolated using 8 data points 
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−1
−0.5
0
0.5
1
Interpolated using 9 data points 
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−1
−0.5
0
0.5
1
Interpolated using 10 data points 
It should be noted that when we have very few grid points (denoted by the large
circles) we cannot possibly hope to realise the exact form of the underlying data
(shown as the dashed curve). To highlight this we have included the interpolated
curve (shown as the solid line) using the highest-order polynomial possible. We
note when only two points are used there is no hope of resolving any variation:
similarly when three points are used the interpolation routine still thinks the
data is equal to zero. Even when four points are used, the interpolation routine
gives completely misleading results (these are far closer to being −sin πx rather
than sin 2πx). Unfortunately with ﬁve points these are coincident with the zeros
of the function and again the interpolation routine believes it is looking at a set
of zero data. It is only when ten points are used that the interpolation could
be considered to be accurate. In fact ﬁve points per period are the minimum
points required to resolve a sine wave, which in this case corresponds to nine
points (due to the overlap).
It is also possible to use other functions than polynomials. We could have
plotted the previous function using a sine expansion and got very accurate
results, with eﬀectively only one term, but that would require a knowledge of
the form of the function. If the function was changed to sin(2.3πx) then trying
to ﬁt sine waves using n ∈Z would be prone to severe errors. Some knowledge
of where the underlying data was generated from and its likely form can help

5.9 Minimisation of Functions and Parameter Retrieval
161
signiﬁcantly. We can then consider the idea of parameter retrieval.
5.9 Minimisation of Functions and Parameter
Retrieval
In the previous example we discussed the method of least squares: this is where
the distance from the data to a function of a given form is minimised. We shall
now discuss how we could minimise a function of several variables. This is a
vast topic and rather than deriving the techniques from ﬁrst principles we just
exploit MATLAB from the outset.
We shall use the MATLAB command fmins (which is going to revert to
fminsearch in future editions of MATLAB). Consider the simple function of
two variables f(x1, x2) = x2
1 + x2
2, which has a global minimum at the origin.
The minimum is such that both of the partial derivatives ∂f/∂x1 and ∂f/∂x2
are zero (together with other conditions to ensure that the point is a minimum).
In this case the minimum is obvious and can be found using the code:




function [f] = func(x)
f = x(1)ˆ2+x(2)ˆ2;
and the command [x] = fmins(’func’,[1 1]) (where the array [1 1] is the
initial guess). This uses the default tolerances and returns a value of
x =
1.0e-04 *
-0.2102
0.2548
We shall now discuss how we could improve this value. The input options have
values:
The parameters are:
options(1)-Display parameter (Default:0). 1 displays some results.
options(2)-Termination tolerance for X.(Default: 1e-4).
options(3)-Termination tolerance on F.(Default: 1e-4).
options(4)-Termination criterion on constraint violation.(Default: 1e-6)
options(5)-Algorithm: Strategy:
Not always used.
options(6)-Algorithm: Optimizer: Not always used.
options(7)-Algorithm: Line Search Algorithm. (Default 0)
options(8)-Function value. (Lambda in goal attainment. )
options(9)-Set to 1 if you want to check user-supplied gradients
options(10)-Number of Function and Constraint Evaluations.
options(11)-Number of Function Gradient Evaluations.

162
5. Interpolation and Extrapolation
options(12)-Number of Constraint Evaluations.
options(13)-Number of equality constraints.
options(14)-Maximum number of function evaluations.
(Default is 100*number of variables)
options(15)-Used in goal attainment for special objectives.
options(16)-Minimum change in variables for finite difference gradients.
options(17)-Maximum change in variables for finite difference gradients.
options(18)-Step length. (Default 1 or less).
We shall now use the code




options = foptions;
options(2) = 1e-8;
options(3) = 1e-8;
[x] = fmins(’func’,[1 1],options);
which unsurprisingly gives a better value of [0.2892e-8,-0.0997e-8]. Here
the options(2) and options(3) set the tolerances on the answers and the
function respectively.
Example 5.6 Determine the minimum value of the function
f(x1, x2, x3) = sin

x1
x2
2 + 1

−cos(x3)
in the neighbourhood of the origin to within a tolerance of 10−6.
Firstly we construct the code to evaluate the function:




function [f] = func2(x)
f = sin(x(1)/(x(2)ˆ2+1))+cos(x(3));
and




options = foptions;
options(2) = 1e-6;
options(3) = 1e-6;
[x,opts] = fmins(’func2’,[0 0 0],options)
which gives the answer [-5.5897 1.5995 3.1416]. We can substitute this back
into the function func2 to check the value associated with the minimum. This
gives −2 so that both cos and sin take the value of −1, hence x3 = −π and
x1/(x2
2 + 1) = −π/2.
In the above example we have also returned details of the iteration which
are stored in the array opts. We also note that using the option option(1) =
1; generates a vast amount of information concerning the iterative procedure.

5.9 Minimisation of Functions and Parameter Retrieval
163
This is a very powerful and useful function.
5.9.1 Parameter Retrieval
In this topic we will exploit the idea of minimising the distance between two
functions. We have already met this where we can specify functions as linear
combinations and then minimise the errors using the method of least squares.
Let us presume we have some data which we know to be of the form sin ax
on the range x = 0 to x = π, where a is unknown. Let us simply construct a
function which conveys how close another function sin bx is to this.
'
&
$
%
a = 1.45; % Usually unknown
x = 0.0:pi/20:pi;
data = sin(a*x);
b = 0.0:0.02:3.0;
for j = 1:length(b)
trial = sin(b(j)*x);
f(j) = norm(trial-data);
end
The plot of f against b clearly shows a minimum near b = 1.5, which is unsur-
prising in this case.
0
0.5
1
1.5
2
2.5
3
0
1
2
3
4
5
6
We now remark that in order to ﬁnd the values of this minimum we could
use search methods. But here we make the observation that one is seeking a
minimum of the function, which is associated with a zero of the derivative of
the function. We shall use the Newton–Raphson method modiﬁed for looking
for zeros of f ′(x), which is
xn+1 = xn −f ′(xn)
f ′′(xn).

164
5. Interpolation and Extrapolation
Here we use
f ′(x) ≈f(x + h) −f(x −h)
2h
and f ′′(x) ≈f(x + h) −2f(x) + f(x −h)
h2
.
'
&
$
%
a = 1.45; % Usually unknown
x = 0.0:pi/20:pi;
data = sin(a*x);
b = 1.5;
% Initial guess
del = 0.1;
tol = 1e-6;
for its = 1:20
f0 = norm(sin(b*x)-data);
fp = norm(sin((b+del)*x)-data);
fm = norm(sin((b-del)*x)-data);
df = (fp-fm)/(2*del);
if abs(df)<tol
break
end
df2 = (fp-2*f0+fm)/(delˆ2);
b = b - df/df2;
end
This program actually needs a good starting guess of b: the problem which is
experienced is that the code will locate a local minimum but it cannot identify
whether this is a global minimum.
5.9.2 Using fmins for Parameter Retrieval
We shall now discuss how we might use the aforementioned MATLAB func-
tion fmins to retrieve parameters, see page 161. Initially we shall consider the
sample example again:
Example 5.7 We shall try to determine the value of the constant a given that
the data has been generated using sin(a*x). In general this value will not be
known.

5.9 Minimisation of Functions and Parameter Retrieval
165
'
&
$
%
global x data
a = 1.45;
x = 0.0:pi/20:pi;
data = sin(a*x);
clear a
[a] = fmins(’func’,[1]);
used in conjunction with the program




function [f] = func(a)
global x data
trial = sin(a*x);
f = norm(trial-data);
This gives the value of a very accurately (to within 10−14).
We shall now describe an example with more parameters:
Example 5.8 We start with the data f(x) = 0.2 sin 3.2x + 0.45x and using
the fact that the data is generated using a sin bx + c we try to recover the above
values.
The main code is:




global x data
x = linspace(0,10);
data = 0.2*sin(3.2*x)+0.45*x;
[co] = fmins(’func3’,[0.1 3. 0.5]);
and the code func3.m is
#
"
 
!
function [f] = func3(co)
global x data
trial = co(1)*sin(co(2)*x)+co(3)*x;
f = norm(trial-data);
This recovers the starting values, since we have used a good starting guess.
We note that using other starting locations will lead to other answers, which
correspond to local minima. It is diﬃcult to guarantee that we have obtained a
global minimum.

166
5. Interpolation and Extrapolation
5.10 Tasks
Task 5.1 Calculate the quadratic which passes through the points (0, 0), (2, −1)
and (5, 5) (by hand).
Task 5.2 Generate the data x2 + 3x + 2 on the points x = 0, 1, 2, · · · , 10 using
the code




x = 0:10;
y = x.ˆ2+3*x+2;
Calculate the error associated with using straight lines in the intervals at x
equals 1/2, 3/2 and 5/2. This involves working out which intervals should be
used to calculate the approximate values. The error is given by using the fact
that the exact form of the data is actually known (i.e. as the above quadratic).
Task 5.3 Calculate the quadratic which passes through the points (0, 0), (π/2, 1)
and (π, 0). It would be a good idea to do this by hand and using MATLAB (using
polyfit).
Task 5.4 Calculate the cubic which passes through the points (−π/2, −1),
(0, 0), (π/2, 1) and (π, 0).
Task 5.5 Plot the spline which goes through the points (−π, 0), (−π/2, −1),
(0, 0), (π/2, 1) and (π, 0) at the points (−π, π) in steps of π/20. You could use
the MATLAB command spline for this purpose.
Task 5.6 Given that the data

5.10 Tasks
167
x
y
0.0
3.16
0.1
3.01
0.2
2.73
0.3
2.47
0.4
2.13
0.5
1.82
0.6
1.52
0.7
1.21
0.8
0.76
0.9
0.43
1.0
0.03
was generated using an expression of the form a sin x + b cos x determine the
values of a and b.
Task 5.7 (*) Calculate the splines associated with the points (xj, yj) j =
1, · · · , 5. Plot these splines for the points (−π, 0), (−π/2, −1), (0, 0), (π/2, 1)
and (π, 0) on a grid of points in steps of π/10 from −π to π.
Given that the initial data is given by y = sin x, determine the sum of the
squares of the total errors over these points.
Task 5.8 (D) The following code should construct the function f(x) = x3 +
sin x −1 on the grid of integers from 2 to 11, and then works out the value of
the function at x = 4.5 and x = 15 using linear interpolation and extrapolation.
'
&
$
%
x = 1:11+1;
f = polyvalue([1 0 0 -1],x) + sin x;
% x = 4.5
r = 4:5;
c = polyfit(x(r),f(r),1);
yy = polyvalue(c,4.5)
% x = 15
r = 14:15;
c = polyfit(x(r),f(r),1);
yy = polyvalue(c,15);

6
Matrices
6.1 Introduction
As noted earlier MATLAB derives its name from the term MATrix LABoratory.
It is therefore not surprising that it is in the area of matrix operations that
the true power of MATLAB is brought to light. We now turn our attention to
matrices within MATLAB but we provide a brief mathematical introduction
to the subject of matrices in the Appendix (see page 322)1. We now describe
how matrices are constructed and manipulated within MATLAB.
6.1.1 Initialising Matrices Within MATLAB
Before we proceed with a description of matrix operations it is important to
ﬁrst discuss how we set up and access matrices within MATLAB. The simplest
method involves simply typing the elements:
>> A = [2 3 4; 5 4 3]
A =
2
3
4
1 Even if you are comfortable with the theory of matrices we still recommend you
read this section as it provides the important details of the correct syntax for
entering and manipulating matrices within MATLAB.

170
6. Matrices
5
4
3
Here the elements in the ﬁrst row are separated by a space and the end of the
ﬁrst row is denoted by a semicolon. The second row is then typed, again with
a space between successive elements. The whole matrix is contained within
square brackets. The variable A is now initialised to be a two-by-three matrix;
we can see this by using the command size(A).
>> size(A)
ans =
2
3
Here the command size returns two values; the number of rows followed by the
number of columns. In the main we have just let the answer to our calculations
appear on the screen (in fact they are also put into a variable called ans). We
could have used the code:
>> A = [2 3 4; 5 4 3];
>> b = size(A);
>> disp(b)
>> [rows,columns] = size(A);
>> disp([rows columns])
The variable b is actually a one-by-two matrix (that is, a row vector con-
taining two elements). The elements of this vector are b(1) and b(2) and these
are used to store the number of rows and columns of A, respectively. Thus we
can determine the number of rows of matrix A, in this case 2, by simply typ-
ing b(1) at the MATLAB prompt. We could also call the function size(A)
and assign the values to a vector whose elements are called rows and columns.
This is done in the fourth line of code. In this example we again encounter the
MATLAB function disp, which literally displays its argument (which in this
case is a row vector); we shall again return to the disp command a little later.
We now return to the question of initialising matrices (and vectors) using
the method of just typing in the elements. We need to take some care with
vectors, as MATLAB diﬀerentiates between column and row vectors (as should
we). To enter a column vector we could use any of:
>> column_vector = [4
5
6];
>> column_vector = [4;5;6];

6.1 Introduction
171
>> column_vector = [4 5 6]’;
The ﬁrst command is self-explanatory. In the second we enter the ﬁrst row,
terminated by a semicolon, and then the second row, terminated by a semicolon,
etc. The third version ﬁrst creates the row vector [4 5 6] and then takes its
transpose (interchanges rows and columns) to produce the column vector. We
can use any of these methods but since our ultimate aim will be to write
computer code in MATLAB, rather than entering commands at the prompt,
we will generally not use the ﬁrst method. In general we shall, throughout the
text, employ the second form.
We now turn our attention to how we access elements (or parts of a matrix).
Let us start with the matrix
>> A = [11 12 13 14; 21 22 23 24; 31 32 33 34];
so that
A =
⎛
⎝
11
12
13
14
21
22
23
24
31
32
33
34
⎞
⎠.
There is no signiﬁcance to these numbers, other than that they provide an
indication of their location within the matrix; we have purely used them so we
will be able to check that we have got the correct elements. The simplest way
of obtaining an element is using parentheses, so that A(2,3) returns the value
in the second row, third column (in this case 23). Note also that it is necessary
to use round brackets. This is exactly as we would expect, and follows the
convention that ai,j refers to the element in the ith row and the jth column.
It is also possible to refer to a whole row (or column) of a matrix. For
example
>> A(2,:)
ans =
21
22
23
24
returns the second row of the matrix A. Here the colon indicates all the elements
along a particular row. Alternatively to refer to a particular column we could
use
>> A(:,4)
ans =
14
24

172
6. Matrices
34
to return the fourth column of matrix A. Note that in both cases the answers
are the same “shape” as they would appear in the matrix, that is the second
row has been returned as a row vector and the fourth column has been returned
as a column vector.
With the colon operator we can create row vectors which can then be used
as arguments in other commands. For instance
>> r = 1:3;
>> A(r,1)
ans =
11
21
31
This yields the same result as A(1:3,1) or A(:,1). We could also use r =
1:2 to get the ﬁrst two elements of the ﬁrst column, or r = 1:2:3 to get the
ﬁrst and last (noting that r = 1:2:3 gives the row vector r = [1 3]). The
possibilities are extensive; for example if we want to obtain the top left hand
two-by-two corner of A, we could employ the following:
>> r = 1:2;
>> B = A(r,r)
B =
11
12
21
22
We now return to the problem of initialising matrices. Although it is not
necessary in MATLAB, it is good programming practise to set up an empty
matrix before accessing the elements. In many programming languages this is
crucial and is referred to as dimensionalising variables and the syntax for how
this is done varies considerably between languages. There are many special
commands in MATLAB which aid in the initialisation of matrices and we start
looking at these by using the colon (which refers to the entire row or column,
depending on context) in some examples.

6.1 Introduction
173
Example 6.1 Enter the matrix in MATLAB
⎛
⎜
⎜
⎝
1
2
3
4
2
0
0
0
3
0
0
0
4
0
0
0
⎞
⎟
⎟
⎠
In order to achieve this we use the commands
>> A = zeros(4);
>> r = 1:4;
>> A(:,1) = r’;
% First column
>> A(1,:) = r
% First row
A =
1
2
3
4
2
0
0
0
3
0
0
0
4
0
0
0
The ﬁrst command here initialises the matrix A to be a four-by-four matrix
whose elements are all equal to zero. The matrix we want to enter has the
ﬁrst row and column having the same elements 1, 2, 3, 4. We therefore set up a
vector, in this case r, to contain these values. We now want to assign the ﬁrst
column of the matrix A which we can do with the third command. Notice here
that we are now assigning to the matrix A to have the ﬁrst column equal to the
transpose of the vector r; we have used the transpose because we want a column
vector. The ﬁnal command assigns the ﬁrst row of A to be equal to the vector r
and to print out the resulting matrix A which, as we see, is precisely the matrix
we required. We could have entered the matrix in many diﬀerent ways. One
way would be to simply type the matrix in element by element:
>> A = [1 2 3 4;
2 0 0 0;
3 0 0 0;
4 0 0 0];
This is ﬁne for small matrices but not practical for when we need to set up
larger matrices. Another variant which can be used to set up the matrix is
>> A = [1 2 3 4; 2 zeros(1,3); 3 zeros(1,3); 4 zeros(1,3)];
Here the command zeros(1,3) sets up a row vector (one-by-three) full of zeros.
This example serves to emphasise there is no unique way to go about setting up
a particular matrix; some ways are more elegant (and sometimes less readable)
than others.

174
6. Matrices
6.1.2 Matrix Operations
We shall now consider how matrix operations are performed within MATLAB,
referring to the mathematical deﬁnitions given in the Appendix. We shall start
with addition and subtraction, using simple examples:
Example 6.2 Consider the addition (C = A + B) and subtraction (D =
A −B) of the matrices
A =
 1
2
3
4

and B =
 4
3
2
1

.
We shall start by working through these by hand and then proceed to give the
MATLAB code. Firstly the addition
C =
 1
2
3
4

+
 4
3
2
1

,
=
 1 + 4
2 + 3
3 + 2
4 + 1

=
 5
5
5
5

;
and now the subtraction
D =
 1
2
3
4

−
 4
3
2
1

,
=
 1 −4
2 −3
3 −2
4 −1

=
 −3
−1
1
3

.
The MATLAB code to achieve these operations is
>>A = [1 2; 3 4]; B = [4 3; 2 1];
>>C = A+B
C =
5
5
5
5
>>D = A-B
D =
-3
-1
1
3

6.1 Introduction
175
We note that matrices need to be the same size to perform addition or
subtraction since there needs to be a corresponding element in each matrix.
Example 6.3 Consider the expression A −3BT where
A =
 3
8
−1
5
2
0

and B =
⎛
⎝
−3
2
2
2
−1
3
⎞
⎠.
The MATLAB code is:




A = [3 8 -1; 5
2 0];
B = [-3 2; 2 2; -1 3];
C = A-3*transpose(B);
Note that although the matrix B is not the same size as A, its transpose BT
is.
Before we proceed we add this word of caution within the context of MAT-
LAB. As we have already seen MATLAB will adapt its variable structure to
accommodate solutions. However, it will object to calculations that are impos-
sible (that is, not well deﬁned). For instance if we try to add a three-by-three
matrix to a two-by-two one (both full of 1’s)2
>>A = ones(3); B = ones(2);
>>C = A+B
??? Error using ==> +
Matrix dimensions must agree.
This example demonstrates that MATLAB is not able to add a two-by-two
matrix to a three-by-three one and it returns a sensible error message if we try
to do so; in this case the dimension (or size) of the matrices are not the same.
The only operation of this kind which is possible within MATLAB involves
>>A = ones(1); B = ones(2);
>>C = A+B
2 We will use the command ones(n) which sets up an n-by-n matrix full of ones.
The other form of this command takes two arguments, ones(m,n), which unsur-
prisingly gives a m-by-n matrix with all elements equal to one. This is similar to
the command zeros(n) that we saw earlier. An associated command that gener-
ates an n-by-n matrix with entries made up of random numbers between zero and
one is rand(n). The precise structure of these commands can be found by using
the help command.

176
6. Matrices
C =
2
2
2
2
In this case although the variable A is a one-by-one matrix it is treated as a
scalar. In this case the command is interpreted by MATLAB as
ci,j = λ + bi,j,
i = 1, · · · , m
and j = 1, · · · , n;
where C = λ1 + B, with 1 a matrix full of ones (which can be obtained in
MATLAB using ones ). This operation is mathematically correct and it is also
a well-deﬁned operation within MATLAB. Similarly if a matrix is multiplied
by a scalar then each element is multiplied by that scalar (that is ci,j = λai,j
where C = λA and again the calculation is viable in mathematical terms).
Before proceeding to matrix multiplication within MATLAB we note that
this idea of applying and performing an operation on every element extends to
functions. We can demonstrate this with a simple example:
>> A = [pi/4 pi/2; pi pi/3]
A =
0.7854
1.5708
3.1416
1.0472
>> B = sin(A)
B =
0.7071
1.0000
0.0000
0.8660
Here we have set up the matrix3
A =

π
4
π
2
π
π
3

and it returns the matrix B as
B =
 sin π
4
sin π
2
sin π
sin π
3

=

1
√
2
1
0
√
3
2

.
3 Notice that the variable pi is predeﬁned in MATLAB and returns the value of
π = 3.1415926535897 · · · .

6.1 Introduction
177
We shall return to this method in due course, but we now turn our attention to
matrix multiplication within MATLAB. The operation C = A*B is performed
as one might expect and returns the “normal” result of matrix multiplication
so that if A is n-by-m and B is m-by-p then C is n-by-p whose elements are
deﬁned on page 326. We need to remember that when taking the product of
two matrices the number of columns of the left-hand matrix must match the
number of rows in the right-hand matrix. If this is not so then MATLAB
will give an error message: Inner matrix dimensions must agree. This is
somewhere we need to be very careful and although most of the time our errors
will be ﬂagged by MATLAB, sometimes the calculations will proceed even
though the results are not as we would expect: for instance
>> A = [1 2 3];
>> B = [4; 5; 6];
>> A*B
ans =
32
>> B*A
ans =
4
8
12
5
10
15
6
12
18
In each case MATLAB is prepared to make the calculation (as it should):
however the exchange of the two matrices yields very diﬀerent results. Because
MATLAB is willing to proceed with calculations with scalars or matrices as
arguments, it may well be some time before this error is realised.
Example 6.4 Calculate 3A −B and AB where
A =
⎛
⎝
1
5
6
0
2
3
−1
0
0
⎞
⎠
and
B =
⎛
⎝
0
−3
2
1
0
−2
1
0
−4
⎞
⎠.
The code for this should be relatively self explanatory:
>> A = [1 5 6; 0 2 3; -1 0 0];
>> B = [0 -3 2; 1 0 -2; 1 0 -4];

178
6. Matrices
>> disp(3*A-B)
>> disp(A*B)
Note that it is not necessary to use the command disp here.
Dot arithmetic can be readily extended to work with matrices. With ma-
trices A and B the matrix C = A.*B is given by
ci,j = ai,jbi,j,
i = 1, · · · , m
and j = 1, · · · , n
and similarly those of D = A./B by
di,j = ai,j
bi,j
,
i = 1, · · · , m
and j = 1, · · · , n.
In addition to multiplication .* and division ./ we can also use dot arithmetic
for exponentiation using .ˆas in
>> A = [1 2; 3 4];
>> B = [1 2; 3 4];
>> A.ˆB
ans =
1
4
27
256
Of course in using dot arithmetic in MATLAB we must ensure the matrices
are of the same size for the operation to be deﬁned. We note either of the
arguments can be scalars:
>> A = [1 2; 3 4];
>> B = A.ˆ2;
% square all entries
>> C = 2.ˆA;
% [2 4; 8 16]
We note these are eﬀectively new binary operations and the addition of
the dot should be thought of as changing the variables. It might help to think
of them as separate operations: that is C = A*B performs the mathematical
multiplication A × B whereas C = A.*B gives ci,j = ai,jbi,j. With practice you
will come to appreciate the diﬀerence between these two operations.
It is not necessary to have a .+ or a .- command since using the deﬁnitions
above these give the same results, since the elements of C = A +B are exactly
ci,j = ai,j + bi,j.

6.1 Introduction
179
Example 6.5 Given the matrices
A = I and B =
 1
2
3
4

,
compare the results of the MATLAB calculations A*B, A.*B, A/B and A./B.
For the multiplications we have the code:
>>A = eye(2); B = [1 2; 3 4];
>>C = A*B
C =
1
2
3
4
>> C = A.*B
C =
1
0
0
4
Here we have introduced the command eye(n) which gives an n-by-n identity
matrix4. For the division operations we have
>> C = A/B
C =
-2.0000
1.0000
1.5000
-0.5000
>> C = A./B
C =
1.0000
0
0
0.2500
4 This could also have been obtained using the command diag.

180
6. Matrices
Hopefully this example makes it clear that the straightforward asterisk opera-
tion performs the mathematical operation of multiplication, with multiplication
by the identity matrix A leaving B unchanged, whereas multiplying using .*
performs the operation element-wise, so that
C = A. ∗B =
 1 × 1
0 × 2
0 × 3
1 × 4

=
 1
0
0
4

.
We have previously skirted the issue of division of matrices, but now that we
have introduced the element-wise operation this can be dealt with naturally and
it works in the same way as multiplication. Above we have the results of the
calculation
A/B =
 1
0
0
1

‘/’
 1
2
3
4

=
 −2
1
3
2
−1
2

which is AB−1 and the other calculation is
A./B =
 1
0
0
1

‘./’
 1
2
3
4

=

1
1
0
2
0
3
1
4

=
 1
0
0
1
4

.
We note when using the division operator / without the dot we are, in fact,
constructing the inverse of the matrix B.
In order to calculate the transpose of a matrix we can use the command
transpose or we can use an apostrophe, A’. If the elements of the matrix are
complex numbers, then this operation constructs the complex conjugate of the
transpose of A. If the elements of the matrix are real this is then equal to the
transpose of the matrix. To obtain the transpose without conjugation, in the
case of a complex matrix, we use the construction A.’.
6.1.3 Operations on Elements of Matrices
In the previous section we have talked about dot arithmetic but we have also
met other examples such as where we added a scalar quantity to each element of
a matrix and where we took the sine of each element. We are now in a position
to apply the functions we have discussed to all of the elements of a matrix (or
pairs of elements for binary operations). We can use any unary operation on a
matrix to return a matrix of the same size. We shall consider a few examples
to illustrate this.

6.1 Introduction
181
Example 6.6 Investigate the behaviour of the unary operations abs, sign,
cos , sin, exp and sinh on the matrix
A =
⎛
⎝
1
−.5
−3.2
0
1
−π
π
2
−2
7.25
⎞
⎠.
This is done with the MATLAB code:
>> A = [1 -0.5 -3.2;
0 1 -pi;
pi/2 -2 7.25];
>> abs(A)
>> sign(A)
>> cos(A)
>> sin(A)
>> exp(A)
>> sinh(A)
We have not included the answers which MATLAB displays, but you should try
entering these commands in order to understand how MATLAB interprets a
function of a matrix.
We need to take some care when using the dot command as some commands
may be allowable within MATLAB but may produce results which are not what
we expected, or wanted. The following example provides a good illustration of
this point.
Example 6.7 Consider the matrix
A =

π
4
π
2
π
3
π
6

.
We wish to determine the matrix whose elements take the values sin x/x where
x corresponds to the elements of the matrix A. In other words we want to
calculate the matrix

4
π sin π
4
2
π sin π
2
3
π sin π
3
6
π sin π
6

.
This can be accomplished using the commands
>> A = [pi/4 pi/2; pi/3 pi/6];
>> sin(A)./A
ans =

182
6. Matrices
0.9003
0.6366
0.8270
0.9549
However, if we had missed out the dot and simply typed sin(A)/A we would
still obtain an “answer”:
>> sin(A)/A
ans =
0.5487
0.2637
0.0569
0.7843
which is not what we had in mind. What this last calculation has done is to
construct the matrix BA−1 where the elements of B are sines of those of A.
6.1.4 More on Special Matrices
In the main, to this point in the text, we have constructed matrices by simply
typing in their entries. However, there are commands in MATLAB which allow
us to make use of special matrices. The simplest ones, and those that are most
often used, are
eye(n) The identity matrix of size n-by-n, In. This matrix has the property
that for any square matrix A of size n-by-n AIn = InA = A.
ones(n,m) A matrix ﬁlled with ones of size n-by-m. Note that ones(n) gives
a square n-by-n matrix ﬁlled with ones and that ones(n,1) gives a column
vector of ones and ones(1,n) a row vector.
zeros(n,m) A matrix ﬁlled with zeros of size n-by-m. This command operates
in the same manner to ones when used as zeros(n), zeros(n,1) and
zeros(1,n).
A matrix whose deﬁnition is slightly more involved is that given by the com-
mand diag(x,n). This produces an appropriately sized matrix whose nth di-
agonal is set to be the vector x. The commands diag(x,0) and diag(x) pro-
duce identical results, that is the vector x on the leading diagonal (that is the
one running from the top left to the bottom right; the elements of the form
ai,i). The value of n being positive means that we are considering the nth
super-diagonal and similarly negative values of n gives the nth sub-diagonal. It

6.1 Introduction
183
should be noted that the nth diagonal is shorter by |n| than the leading diag-
onal, for instance if x = ones(3,1) then diag(x) produces a three-by-three
matrix whereas diag(x,1) produces a four-by-four matrix as does diag(x,-1).
Considering an N-by-N matrix: The nth super-diagonal consists of the el-
ements ai,i+n where i = 1, · · · , N −n and the nth sub-diagonal consists of the
elements ai+n,i where i = 1, · · · , N −n. Notice it does not matter whether the
vector is a row or column vector.
Example 6.8 If x = ones(4,1) then we have:
diag(x,0) is given by
⎛
⎜
⎜
⎝
1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
1
⎞
⎟
⎟
⎠
diag(x(1:3),1)
⎛
⎜
⎜
⎝
0
1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
⎞
⎟
⎟
⎠
and similarly
diag(x(1:3),-1)
⎛
⎜
⎜
⎝
0
0
0
0
1
0
0
0
0
1
0
0
0
0
1
0
⎞
⎟
⎟
⎠.
We can use this command to produce combinations such as
diag(x,0)+diag(x(1:3)*2,1)+diag(x(1:3)*(-2),-1)
⎛
⎜
⎜
⎝
1
2
0
0
−2
1
2
0
0
−2
1
2
0
0
−2
1
⎞
⎟
⎟
⎠.
Notice we have been very careful to only try viable combinations. In the above
we have used the fact that we can extract parts of a matrix or vector. The
command ones(4,1) sets up a column vector (four-by-one) full of ones and
then x(1:3) gives the ﬁrst three elements of that vector, that is [1 1 1].

184
6. Matrices
Example 6.9 Consider the matrices constructed using the commands:
>> x = 2*ones(3,1);
>> y = -2*ones(4,1);
>> A = diag(y,0)+diag(x,1);
>> B = diag(y,1)+diag(x,-2);
The ﬁrst command sets x to be a column vector (three-by-one) full of 2’s
and the second one sets y to be a column vector (four-by-one) full of −2’s. It
is worth typing these commands (and leaving the semicolon oﬀto see what is
happening). It is possible to see the contents of a variable by merely typing its
name at the prompt and pressing return. Let’s now dissect the command A =
diag(y,0)+diag(x,1);. The ﬁrst component of the right-hand side puts the
contents of the column vector y down the leading diagonal of a matrix (which
will be a a four-by-four matrix since the vector y is four-by-one). The second
command on the right-hand side constructs a matrix which has the components
of the column vector x down the super-diagonal; notice the vector x is three-by-
one which is one shorter than the leading diagonal. Finally, these two matrices
are added together (to give A) which is a valid operation as both matrices are
four-by-four. If you are having diﬃculty following this try typing diag(y,0)
and diag(x,1) separately, and look at the resulting matrices.
In the second command the matrix B is constructed with a super-diagonal
and a second sub-diagonal. These commands give
>> A
A =
-2
2
0
0
0
-2
2
0
0
0
-2
2
0
0
0
-2
>> B
B =
0
-2
0
0
0
0
0
-2
0
0
2
0
0
-2
0
0
2
0
0
-2
0
0
2
0
0

6.1 Introduction
185
Notice the sizes of the matrices have been determined by the length of the di-
agonals. If we had attempted to use the command diag(y,0)+diag(x,0) we
would have been asking MATLAB to add two matrices of diﬀerent sizes, and
as such it would have produced an error message.
There are several other special matrices which can be easily constructed using
MATLAB. The command magic(n) gives a magic square of size n-by-n. This
matrix has the property that the sum of all the elements along any row or
column is identical (and along diagonals).
The commands hilb(n) and invhilb(n) produce what are known as a
Hilbert matrix and its inverse. The elements of the Hilbert matrix A are given by
ai,j = 1/(i + j); the inverse of these matrices are notoriously hard to calculate.
Other examples of special matrices exist within MATLAB; a full list of
matrix functions can be found by using lookfor matrix. This lists all the
functions which include the word matrix in their description.
6.1.5 Matrices Containing Strings
We brieﬂy note we can form vectors containing strings. This is useful when we
wish to construct arguments to produce prompts for the user. Let us consider
a simple example
Example 6.10 This code gets the user to input a value of a and simply print
it out again.
#
"
 
!
str = ’Please enter the value of a: ’;
a = input(str);
sol = ’The value of a is equal to ’;
soln = [sol num2str(a)];
disp(soln)
Here we have formed a row vector using the two strings ’The value of a is
equal to ’ and num2str(a); the latter of which is the conversion of the value
of a to a string.
We note the size of the row vector sol is one-by-twenty seven and as such
we could access parts of the vector sol(1,1:3) is the word The.
There are numerous commands which can be used to operate on strings:

186
6. Matrices
STR2MAT Form blank padded character matrix from strings.
STRCAT Concatenate strings.
STRCMP Compare strings.
STRCMPI Compare strings ignoring case.
STRINGS Character strings in MATLAB.
STRNCMP Compare first N characters of strings.
STRNCMPI Compare first N characters of strings ignoring case.
STRVCAT Vertically concatenate strings.
(this was generated using the command lookfor strings).
In this chapter we shall tackle the problems involved in the consideration of
matrices and provide details of how they might be inverted. We shall mention
a few concepts but shall not deal with them in depth, electing to leave those
to subsequent books on linear algebra.
We will also discuss the concept of eigensolutions and also show how these
occur within diﬀerential systems.
6.2 Properties of Matrices and Systems of
Equations
We shall discuss the way certain characteristics of systems can be used to
determine whether they have solutions or not. We start by considering a couple
of simple systems:
x = 1
(6.1a)
this system is in one variable (that is x) and has one solution, that is x equal to
1. The number of variables equals the number of unknowns. Now we consider
the system
x = 1
y = 2

(6.1b)
again this system has the same number of variables as equations, and hopefully
we can work out the solution as x equals 1 and y equals 2. In both of these
cases the solution exists and it is unique. These systems are ridiculously simple.
Let us again consider a system with the same number of variables as equations
x −y = 1
x + y = 2

(6.1c)
This has a unique solution x = 3/2 and y = 1/2: however the system
x + y = 1
x + y = 2

(6.1d)

6.2 Properties of Matrices and Systems of Equations
187
clearly does not have a solution, since x + y cannot equal both one and two.
Further considering the system
x + y = 1
x + y = 1

(6.1e)
has solutions: in fact x = α and y = 1 −α is a solution for any value of α. In
this case we say there are an inﬁnite number of solutions. The question we now
pose is what is the diﬀerence between these sets of equations. We start with a
couple of deﬁnitions:
Deﬁnition 6.1 (Linear Independence)
Consider the set of vectors aj, j = 1, · · · , n and the linear combination
n

j=1
ajcj.
This summation is zero if all the cj’s are zero, and the set of vectors aj are said
to be linearly independent if this is the only set of constants for which this
is true.
Example 6.11 Consider the vectors
a1
=
(1
0
1
0),
a2
=
(1
0
−1
0),
a3
=
(1
0
0
0),
a4
=
(0
1
0
1).
We note that a1 +a2 −2a3 = 0, that is c1 = 1, c2 = 1, c3 = −2 and c4 = 0;
hence there are values of the cj’s for which the linear combination of the aj are
zero, and hence these vectors are linearly dependent.
We can now introduce a further term:
Deﬁnition 6.2 (Rank of a Matrix)
The rank of a matrix is the maximum number of linearly independent rows of
a matrix.
This can be calculated using the MATLAB command rank. We can determine
the rank of the system above using the commands

188
6. Matrices
#
"
 
!
a = [1 0 1 0; ...
1 0 -1 0; ...
1 0 0 0; ...
0 1 0 1];
rank(a)
This gives the answer 3, so this tells us that one of the rows depends on the
others (since there are four rows): as noted above a1 = 2a3 −a2.
We now consider a system of linear equations:
a11x1 + a12x2 + · · · + a1nxn
=
b1,
a21x1 + a22x2 + · · · + a2nxn
=
b2,
...
...
...
am1x1 + am2x2 + · · · amnxn
=
bm,
which we can write as Ax = b, where A is an m-by-n matrix and the vectors
x and b are column vectors of lengths n and m respectively. In simple terms
this represents a system of m equations in n unknowns. We also construct the
matrix A|b which is the augmented matrix.
We now state the results that:
1. The system above has solutions if and only if rank(A) = rank(A|b).
2. If this rank is equal to the number of variables then the system has a unique
solution.
3. If the rank is less than the number of variables then there are an inﬁnite
number of solutions. In fact the diﬀerence between these numbers gives
the number of degrees of freedom (which we can think of as the number of
variables like α which are available to us).
We now use MATLAB and this idea to discuss the structure of the systems
(6.1a–6.1e)
#
"
 
!
A1 = [1]; b1 = 1;
A2 = [1 0; 0 1]; b2 = [1; 2];
A3 = [1 -1; 1 1]; b3 = [1; 2];
A4 = [1 1; 1 1]; b4 = [1; 2];
A5 = [1 1; 1 1]; b5 = [1; 1];
and then use the function solns.m

6.2 Properties of Matrices and Systems of Equations
189
'
&
$
%
function [val] = solns(A,b)
rankA = rank(A); rankAb = rank([A b]);
[m,n] = size(A);
disp([’There are ’ int2str(m) ’ equations’])
disp([’with ’ int2str(n) ’ variables’])
if rankA ˜= rankAb
disp(’This system has no solutions’)
elseif rankA == n
disp(’There is a unique solution’)
elseif rankA < n
dof = n-rankA;
disp(’There are an infinite number of solutions’)
disp([’with ’ int2str(dof) ’ degrees of freedom ’])
end
This produces the results:
>> solns(A1,b1)
There are 1 equations
with 1 variables
There is a unique solution
>> solns(A2,b2)
There are 2 equations
with 2 variables
There is a unique solution
>> solns(A3,b3)
There are 2 equations
with 2 variables
There is a unique solution
>> solns(A4,b4)
There are 2 equations
with 2 variables
This system has no solutions
>> solns(A5,b5)
There are 2 equations
with 2 variables
There are an infinite number of solutions
with 1 degrees of freedom
This can be used for far more complex systems and is not limited to cases for
which b is a single column, consider the example on page 199.
A = [2 3; 1 -1];

190
6. Matrices
b = [7 -2;1 8];
solns(A,b)
This informs us that there is a unique solution.
6.2.1 Determinants of Matrices
We now mention the determinant of a matrix. We shall not deﬁne this quantity
mathematically leaving that to a text on linear algebra. However we note the
property that a square matrix A has an inverse if and only if det(A) ̸= 0. In
general this will be more useful to us than the previous section on rank, since we
will not be able to deal with problems with an inﬁnite number of solutions. We
shall generally restrict our attention to systems which have a unique solution
or identifying systems which have no solutions. This is particularly poignant
when discussing eigensolutions, which will be done in due course.
We start with a general two-by-two matrix:
A =
 a
b
c
d

,
whose determinant is ad −bc. Notice if this quantity is zero then a/b = c/d
(presuming that b, d ̸= 0). This means that the second row is merely a multiple
of the ﬁrst as we have in (6.1d) and (6.1e).
We construct the determinant of a three-by-three matrix by reducing it to
three two-by-two determinants. We consider the matrix A:
A =
⎛
⎝
a
b
c
d
e
f
g
h
i
⎞
⎠.
We have
det(A) = +a




e
f
h
i




 −b




d
f
g
i




 + c




d
e
g
h




 .
We could now proceed to expand the two-by-two determinants. Here we have
used the top row to expand the determinant, but we could have used any row
or column, provided we premultiply by either plus or minus one, using
⎛
⎝
+
−
+
−
+
−
+
−
+
⎞
⎠.
The sub-determinants are formed by removing the row and column containing
the element we are using at the time.
We pick the row or column which is most convenient: for instance if one
contains a couple of zeros this is an ideal choice.

6.3 Elementary Row Operations
191
Example 6.12 Investigate the system
⎛
⎝
1
0
2
1
−1
1
r
2
1
⎞
⎠x = b.
The determinant of this matrix is actually 1 + r and in order for this system
to have solutions we require r ̸= −1 (we note that if r = −1 then the third row
is equal to the ﬁrst row minus two copies of the second row, so the rows are
linearly dependent). Consequently we can invert the matrix and hence ﬁnd that
x = A−1b. We can work out the determinant by expanding using the top row
as






1
0
2
1
−1
1
r
2
1






= 1




−1
1
2
1




 −0




1
1
r
1




 + 2




1
−1
r
2




= 1(−1 −2) + 2(2 + r) = 1 + r.
Note we could solve this example by evaluating the determinant for a variety
of values of r and then using the command polyfit to the acquired data.
6.3 Elementary Row Operations
We shall brieﬂy comment on how one might invert a matrix: we shall illustrate
the methods and techniques using small matrices but the same methods will
work for larger matrices.
Let us consider the general two-by-two matrix
A =
 a
b
c
d

.
You may know that the inverse of this matrix is
A−1 = 1
∆

d
−b
−c
a

,
where ∆= ad −bc and this is the determinant of the matrix. You may just
know this or remember it as:5
Exchange the two elements on the leading diagonal and multiply the other
elements by minus one, and divide the whole matrix by the determinant.
5 If you have any diﬃculty remembering which ones are exchanged and which ones
are multiplied by minus one, simply remember it should leave the identity matrix
unchanged.

192
6. Matrices
The fact that we are dividing by the determinant means that this has to be
non-zero for the inverse to exist. Let us consider the equations
ax + by
=
p,
(6.2a)
cx + dy
=
q.
(6.2b)
Hopefully it should be clear to you this is equivalent to the matrix equation
 a
b
c
d
  x
y

=
 p
q

.
The solution of which is
 x
y

= 1
∆

d
−b
−c
a
  p
q

,
thus
x = dp −bq
ad −bc
and
y = −cp + aq
ad −bc .
We could also get this by solving the equations (6.2). Firstly we wish to elimi-
nate x from the second equation (6.2b) so we subtract c/a times the ﬁrst one
(6.2a). Thus (6.2b) becomes
cx + dy −c
a (ax + by)
=
q −c
ap,

d −c
ab
	
y
=
q −c
ap,
ˆdy
=
ˆq,
where for convenience we have introduced ˆd and ˆq. The two equations are now
ax + by
=
p
(6.3a)
ˆdy
=
ˆq.
(6.3b)
We can now eliminate y from (6.3a) using (6.3b) (by subtracting b/ ˆd times
(6.3b) from (6.3a)). This gives
ax + by −b
ˆd

ˆdy
	
=
p −b
ˆd
(ˆq)
ˆax
=
ˆp.
We can now get the solution as x = ˆp/ˆa and y = ˆq/ ˆd, which will agree with
that attained using the inverse of the matrix.
We have been using elementary row operations, these are very useful in the
manipulation of matrices. We are able to:
– exchange complete rows,

6.3 Elementary Row Operations
193
– multiply a row by a non-zero constant
– add a multiple of a row to any other row.
If we consider matrices it is not immediately obvious these operations do not
change the system. However when considering systems of equations we are
happy to perform exactly these operations. Consider the simple set of three
equations in three unknowns:
a11x1 + a12x2 + a13x3 = b1,
(6.4a)
a21x1 + a22x2 + a23x3 = b2,
(6.4b)
a31x1 + a32x2 + a33x3 = b3.
(6.4c)
Dealing with the operations in order:
Exchanging rows This operation is the same as swapping the equations around,
so for instance we could write
a31x1 + a32x2 + a33x3 = b3,
a21x1 + a22x2 + a23x3 = b2,
a11x1 + a12x2 + a13x3 = b1.
Here we have swapped the equations (6.4a) and (6.4c), and hopefully we can
see that the solution remains the same; we have merely altered the order
in which the equations are written down. This operation will be denoted
by R1 ⇌R3.
Multiply a row by a constant Let us multiply the equation (6.4b) by the con-
stant λ, so that the equations become
a11x1 + a12x2 + a13x3 = b1,
λ(a21x1 + a22x2 + a23x3) = λb2,
a31x1 + a32x2 + a33x3 = b3.
Again hopefully we can see this does not alter the solution of the system.
This operation would be denoted as R2 →λR2.
Combining rows We shall now perform the operation R2 →R2 −a21R1/a11,
which gives
a11x1 + a12x2 + a13x3 = b1

a22 −a12a21
a11

x2 +

a23 −a13a21
a11

x3 = b2 −a21b1
a11
a31x1 + a32x2 + a33x3 = b3.

194
6. Matrices
In this case Equations (6.4a) and (6.4c) remain unchanged and we have
succeeded in eliminating x1 from (6.4b). This is the step we would take en
route to solving this system and naturally does not alter the solution of
the system.
We now use these operations to construct the inverse of a two-by-two matrix.
Example 6.13 Use elementary row operations to determine the inverse of the
matrix
 a
b
c
d

.
Firstly we need to augment the matrix with the corresponding identity matrix
and form B = A|I. We then use elementary row operations to reduce the part
of B which corresponds to A to the identity matrix I. We shall run through the
steps. We start with the matrix
 a
b
1
0
c
d
0
1

.
To eliminate c from the second row we use the operation R2 →R2 −c/aR1 so
that we have
 a
b
1
0
0
d −cb
a
−c
a
1

.
Notice that the operation has been recorded in the third element along the second
row. We now divide the second row through using the operation R2 →R2/(d −
cb
a ), which gives
 a
b
1
0
0
1
−
c
ad−bc
a
ad−bc

.
Now, to eliminate the b element we use R1 →R1 −b × R2 so that we have

a
0
1 +
bc
ad−bc
−
ab
ad−bc
0
1
−
c
ad−bc
a
ad−bc

,
after slight simpliﬁcation and dividing the ﬁrst row by a, using the operation
R1 →R1/a we have

1
0
d
ad−bc
−
b
ad−bc
0
1
−
c
ad−bc
a
ad−bc

.
This matrix is now I|A−1. This technique can be extended to larger systems.
You can also compare this with the earlier solution of the system (6.2).

6.3 Elementary Row Operations
195
There is a MATLAB command which will run through these operations,
rref or in slow motion rrefmovie. This also includes pivoting, which is how
this technique deals with zeros when it encounters them.
Example 6.14 Construct the inverse of the matrix
⎛
⎝
1
2
1
3
2
1
1
1
1
⎞
⎠
using MATLAB.
This can be done by using the code:




A = [1 2 1; 3 2 1; 1 1 1];
B = [A eye(3)]
C = rref(B);
By way of illustration we show the actual operations using the command
rrefmovie.
A = [1 2 1; 3 2 1; 1 1 1];
B = [A eye(3)]
B =
1
2
1
1
0
0
3
2
1
0
1
0
1
1
1
0
0
1
This has produced an augmented matrix which we would write as A|I
(not to be confused with the MATLAB ‘or’ command). Now try the command
rrefmovie(B), which yields
Original matrix
A =
1
2
1
1
0
0
3
2
1
0
1
0
1
1
1
0
0
1
Press any key to continue. . .
swap rows 1 and 2
A =
3
2
1
0
1
0

196
6. Matrices
1
2
1
1
0
0
1
1
1
0
0
1
Press any key to continue. . .
pivot = A(1,1)
A =
1
2/3
1/3
0
1/3
0
1
2
1
1
0
0
1
1
1
0
0
1
Press any key to continue. . .
eliminate in column 1
A =
1
2/3
1/3
0
1/3
0
1
2
1
1
0
0
1
1
1
0
0
1
Press any key to continue. . .
eliminate in column 1
A =
1
2/3
1/3
0
1/3
0
0
4/3
2/3
1
-1/3
0
0
1/3
2/3
0
-1/3
1
Press any key to continue. . .
pivot = A(2,2)
A =
1
2/3
1/3
0
1/3
0
0
1
1/2
3/4
-1/4
0
0
1/3
2/3
0
-1/3
1
Press any key to continue. . .
eliminate in column 2
A =
1
2/3
1/3
0
1/3
0
0
1
1/2
3/4
-1/4
0
0
1/3
2/3
0
-1/3
1

6.3 Elementary Row Operations
197
Press any key to continue. . .
eliminate in column 2
A =
1
0
0
-1/2
1/2
0
0
1
1/2
3/4
-1/4
0
0
0
1/2
-1/4
-1/4
1
Press any key to continue. . .
pivot = A(3,3)
A =
1
0
0
-1/2
1/2
0
0
1
1/2
3/4
-1/4
0
0
0
1
-1/2
-1/2
2
Press any key to continue. . .
eliminate in column 3
A =
1
0
0
-1/2
1/2
0
0
1
1/2
3/4
-1/4
0
0
0
1
-1/2
-1/2
2
Press any key to continue. . .
eliminate in column 3
A =
1
0
0
-1/2
1/2
0
0
1
0
1
*
-1
0
0
1
-1/2
-1/2
2
Press any key to continue. . .
This provides a movie of row echelon operations, giving a running commen-
tary. This is used purely for illustration and MATLAB has used the format
rat command to present the numbers as rationals. Notice one number is given
as a *: this is because MATLAB cannot adequately represent this as a rational.
If we now use C = rref(B), we ﬁnd this element is in fact zero but rounding
errors made it to be a very small number. Now extracting the last three columns
X = C(:,4:6) where X is in fact the inverse of A, which can be conﬁrmed by
typing X*A and A*X.

198
6. Matrices
The above technique involves other methods than those we used in the
simple two-by-two case (for instance pivoting). It is not the intention of this
text to provide a comprehensive discussion of these matrix operations, merely
to make you aware of them. You may notice that the rˆole of the augmented
matrix is to keep track of the operations required to change A to the identity
matrix. Have a look at the second matrix in which the command swap rows
1 and 2 has been performed. This is to increase the size of the element which
is going to be used for the elimination. If the original element is zero it will
deﬁnitely need to be moved, as the algorithm is going to divide by this quantity.
If the column is full of zeros then the inverse does not exist and the algorithm
continues to work on the remaining rows. For instance




D=[0 1 3; 0 1 1; 0 1 2];
B=[D eye(3)];
rref(B)
yields
0
1
0
0
2
-1
0
0
1
0
-1
1
0
0
0
1
1
-2
This shows the original matrix does not have an inverse and in fact its rank
is less than the number of rows. In this case we ﬁnd rank(D) = 2 and the
determinant is zero. We note the third row of the matrix can be formed by the
linear combination of the ﬁrst and second ones, (r1 + r2)/2.
6.3.1 Solving Many Equations at Once
We remark it is possible to determine the solution of many systems simulta-
neously where only the right-hand sides of the equation changes. Consider the
solution of the equation:
Ax = b.
We shall assume A is an n-by-n matrix and x is n-by-m and b is n-by-m. This
allows m sets of equations to be solved simultaneously.
Example 6.15 Consider the simple example
2x + 3y
=
7,
x −y
=
1,

6.4 Matrix Decomposition
199
and
2x + 3y
=
−2,
x −y
=
8.
These equations can be written as
 2
3
1
−1
  x
y

=
 7
−2
1
8

.
This system can be solved using the MATLAB code:




A = [ 2 3; 1 -1];
b = [7 -2; 1 8];
x = A\b;
This gives
x =
2.0000
4.4000
1.0000
-3.6000
so the solution to the ﬁrst system is (2, 1)T and the second is (22/5, −18/5)T .
6.4 Matrix Decomposition
As mentioned in the previous section we can think of the last three columns
as recording the operations performed in order to reduce the matrix to row
echelon form. Notice this process involves a forward sweep and a backward
sweep. In general the forward sweep will produce a lower triangular matrix and
an upper triangular matrix will result from the backward sweep6. If pivoting
is used to determine this form it is necessary to also include a permutation
matrix (which swaps rows). We use the MATLAB commands
A = [1 2 1; 3 2 1; 1 1 1];
[L,U,P] = lu(A)
L =
6 The deﬁnition of upper and lower is based on the leading diagonal (which runs
from the top left to the bottom right).

200
6. Matrices
1.0000
0
0
0.3333
1.0000
0
0.3333
0.2500
1.0000
U =
3.0000
2.0000
1.0000
0
1.3333
0.6667
0
0
0.5000
P =
0
1
0
1
0
0
0
0
1
Now we have the three matrices L, U and P, such that
PA = LU.
Notice it is possible to call this routine with only two outputs, in which case L
is no longer lower triangular as it now contains pivoting information.
Let us now consider the inverse of the matrix A. We need to recall that
(XY)−1 = Y−1X−1,
to see this simply multiply both sides of the equation on the left by (XY) (or
on the right). In which case
(PA)−1
=
(LU)−1 ,
A−1P−1
=
U−1L−1,
A−1
=
U−1L−1P,
(6.5)
multiplying both sides of the equation on the right by P.
Consider the solution of the problem
Ax = b.
Multiplying both sides by A−1 on the left and substituting from (6.5), yields:
x
=
U−1L−1Pb
x
=
U−1Eb,

6.4 Matrix Decomposition
201
where we have introduced E = L−1P. This actually occurs earlier in the series
of operations since EA = U. The algorithm can be written as:
(i) Calculate L, U
(ii) Calculate Ly = b (y = Eb)
(iii) Solve Ux = y.
This method is eﬃcient since it works with triangular matrices. If we need
to solve the above system for diﬀerent b then we only need to calculate L and U
once. In fact this is the essence of how MATLAB solves matrix systems. Instead
of actually constructing the inverse it works out the inﬂuence the inverse would
have. This represents a dramatic saving in time. In order to test this we use
the codes
'
&
$
%
%
% testmat.m
%
function [time1,time2] = testmat(n);
A = rand(n);
b = rand(n,1);
tnow = cputime;
x = A\b;
time1 = cputime-tnow;
tnow = cputime;
x = inv(A)*b;
time2 = cputime-tnow;
which is run using

202
6. Matrices
'
&
$
%
%
% mtestmat.m
%
nn = 100:50:800;
n = length(nn);
for i = 1:n
nn(i)
[t1(i),t2(i)] = testmat(nn(i));
end
plot(nn,[t1; t2])
xlabel(’Matrix size’,’FontSize’,15)
ylabel(’CPU time (secs)’,’FontSize’,15)
text(600,10,’Decomposition’,’FontSize’,14)
text(500,20,’Full inversion’,’FontSize’,14)
print -dps2 testmat.ps
This gives the results
100
200
300
400
500
600
700
800
0
5
10
15
20
25
30
35
Matrix size
CPU time (secs)
Decomposition
Full inversion
where the upper curve is the method using the construction of the inverse. In
fact both of these curves grow like the size of the matrix to the power 3, but
the lower one has a smaller constant of proportionality. Matrix inversion (and
multiplication) is very expensive and any symmetry or special properties of a

6.4 Matrix Decomposition
203
matrix should be exploited.
MATLAB has a few commands which can use the properties of these ma-
trices: perhaps the most simple one is sparse. We will meet examples in due
course but we shall simply show this example.
>> A = sparse(eye(4))
A =
(1,1)
1
(2,2)
1
(3,3)
1
(4,4)
1
>> B = sparse(diag(1,3))
B =
(1,4)
1
>> A+B
ans =
(1,1)
1
(2,2)
1
(3,3)
1
(1,4)
1
(4,4)
1
These matrices are
A =
⎛
⎜
⎜
⎝
1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
1
⎞
⎟
⎟
⎠, B =
⎛
⎜
⎜
⎝
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
⎞
⎟
⎟
⎠
and A + B =
⎛
⎜
⎜
⎝
1
0
0
1
0
1
0
0
0
0
1
0
0
0
0
1
⎞
⎟
⎟
⎠.
Instead of storing the whole matrix it only stores the elements which are
non-zero, and when operations are performed it returns a sparse matrix (or a

204
6. Matrices
full one if the result is full). A full matrix can be retrieved by using the full
command.
6.5 Eigenvalues and Eigenvectors
Although this is slightly beyond the scope of this text we shall brieﬂy discuss
the ideas of eigenvalues and eigenvectors. These are very useful when solv-
ing matrix systems and understanding the inﬂuence of matrices. Consider the
simple transformation
x →3x,
y →−2y,
which we could write as
x′ = 3x
y′ = −2y,
or in matrix form
 x′
y′

=
 3
0
0
−2
  x
y

,
p′
=
Ap.
The action of this transformation is to multiply the x component by three and
the y component by minus two. So the coordinate (1, 1) is moved to (3, −2).
Under this transformation which vectors’ directions are left unchanged?
Hopefully you should be able to see that anything on the x or y axes falls
into this category. Along the x axis we have the general point (λ, 0) which
after the transformation becomes (3λ, 0) = 3(λ, 0), so that Ap = 3p (where
p = (1, 0)T ). Similarly along the y axis, we have the general point (0, µ) which
transforms to (0, −2µ) = −2(0, µ). The values 3 and −2 are referred to as the
eigenvalues and (1, 0)T and (0, 1)T are the eigenvectors (we have taken λ and
µ to both be unity).
 x
 y
 x′
 y′
transforms to

6.5 Eigenvalues and Eigenvectors
205
In this simple case it is easy to see how these quantities are determined but
consider the more involved example:
Example 6.16 Determine the eigenvalues and eigenvectors of the matrix
 1
2
3
2

,
and comment on the eﬀect of the matrix.
Let us brieﬂy describe how this is done analytically. We assume that the eigen-
values are λ and as such for an eigenvector x
Ax = λx,
which can be rearranged to give
(A −λI) x = 0.
This equation only has trivial solutions for x unless the determinant of the
matrix multiplying it is zero7, that is
det (A −λI) = 0.
We have used the term ‘det’ to represent the determinant but we also use
vertical lines, as below. In this case this leads to a quadratic:




1 −λ
2
3
2 −λ




=
(1 −λ)(2 −λ) −6
=
λ2 −3λ −4
=
(λ −4)(λ + 1) = 0.
So the eigenvalues are 4 and −1. Notice that we could have used a couple of
MATLAB commands at this point.
>> p = poly(A)
p =
1
-3
-4
>> roots(p)
7 Notice that if the determinant is non-zero, then we could simply invert the matrix
and obtain the solution x = 0; that is the trivial solution.

206
6. Matrices
ans =
4
-1
>>
The ﬁrst command gives the coeﬃcients of the characteristic polynomial (which
is the name of the polynomial in λ, see page 214 for more details). The second
one determines the roots of polynomial whose coeﬃcients are stored in p.
In order to determine the eigenvectors we solve the equations
 1
2
3
2
  x
y

= λ
 x
y

,
for each value of λ.
λ = 4
 1
2
3
2
  x
y

= 4
 x
y

,
which gives
x + 2y
=
4x
⇒2y = 3x,
3x + 2y
=
4y
⇒3x = 2y.
Notice that both equations give the same result and in a sense there is
a redundance (which is all linked to the fact that the determinant of the
modiﬁed system is now zero). The eigenvector is deﬁned by x = 2y/3 and
hence choosing y = 3 gives x = 2:
eλ=4 =
 2
3

;
notice that we could have any scalar multiple of this. As such MATLAB
will return the multiple of this such that
ˆeλ=4 = eλ=4
|eλ=4|,
which has unit modulus. The modulus | · | is deﬁned as the square root of
the sum of the squares of the elements.
λ = −1
 1
2
3
2
  x
y

= (−1)
 x
y

,

6.5 Eigenvalues and Eigenvectors
207
which gives
x + 2y
=
−x
⇒y = −x,
3x + 2y
=
−y
⇒x = −y.
Hence the eigenvector is
eλ=−1 =

1
−1

.
We could have determined these using the command
'
&
$
%
[V,D] = eig(A)
V =
-0.7071
-0.5547
0.7071
-0.8321
D =
-1
0
0
4
This returns two matrices: one with the eigenvectors as columns and the
other with the eigenvalues on the leading diagonal (this is discussed further
on page 208). Notice that the eigenvectors are returned with the columns nor-
malised such that eeT = 1. In one case dividing through by
√
2 and in the
other by
√
13 =
√
22 + 32. It now remains for us to discuss the eﬀect of this
transformation: the eigenvectors are (2, 3)T and (1, −1)T with corresponding
eigenvalues 4 and −1. Hence any vector along the line (2, 3) is extended four
times and along (1, −1) is reﬂected in the origin.
We could consider a vector to be composed on components associated with
each eigenvector, for instance consider the action on the point (1, 1).
Firstly solve the equation
 1
1

= αeλ=4 + βeλ=−1,
which gives the simultaneous equations
1
=
2α + β
1
=
3α −β,

208
6. Matrices
which are solved to give α = 2/5 and β = 1/5. Hence
 1
1

= 2
5eλ=4 + 1
5eλ=−1.
Now we multiply both sides by A to give
A
 1
1

=
2
5Aeλ=4 + 1
5Aeλ=−1,
=
2
5(4)eλ=4 + 1
5(−1)eλ=−1,
=
8
5eλ=4 −1
5eλ=−1,
=
8
5
 2
3

−1
5

1
−1

,
=
 3
5

.
We could have used simple matrix multiplication but this kind of technique will
allow us to perform far more complex calculations in which we may not know
all the values (so in more general cases) and also in higher dimensions. This
technique is especially useful when discussing manifolds in chaos (but that’s
material for another text book).
6.6 Speciﬁc MATLAB Commands
We remark that MATLAB has very powerful commands for determining eigen-
values (and eigenvectors) of these systems, eig and eigs. The former one has
already been used on page 207.
We start with the command eig; in its simplest form it determines the
eigenvalues of a square matrix, the syntax is




a = [1 3 2; 1 1 1; -1 0 0];
e = eig(a)
This gives the answer e = [1.6180;-0.6180; 1.0000] (the actual values are
(1 ±
√
5)/2 and 1). A very simple change in syntax gives the eigenvectors as
well [V,D] = eig(a);. In this case the eigenvectors are the columns of V and
the eigenvalues are on the diagonal of the matrix D. We remark that
A = PDP−1,

6.6 Speciﬁc MATLAB Commands
209
where P is a matrix formed with the eigenvectors of the matrix A as columns
(that is V) and D is a diagonal matrix with the eigenvalues on its diagonal.
Note: the order of these must be the same.
This is veriﬁed for the above example using the code
'
&
$
%
>> [v,d] = eig(a)
v =
0.7529
0.4004
-0.6396
0.4653
-0.6479
-0.4264
-0.4653
0.6479
0.6396
d =
1.6180
0
0
0
-0.6180
0
0
0
1.0000
>> v*d*inv(v)
ans =
1.0000
3.0000
2.0000
1.0000
1.0000
1.0000
-1.0000
0.0000
0
As a direct consequence of this we are able to work out An very cheaply.
We note that
A2 = AA = (PDP−1)(PDP−1)
= (PD)(P−1P)(DP−1)
= (PD)(I)(DP−1)
= (PDDP−1) = PD2P−1.
It is quite simple to see that An = PDnP−1 (using proof induction for instance,
see Task 6.22). We now note that Dn is very easy to work out, if D has the
values (λ1, · · · , λN) along the leading diagonal then Dn has (λn
1, · · · , λn
N) along
that diagonal.

210
6. Matrices
Example 6.17 Calculate the matrix
A =
⎛
⎝
1
0
−1
0
1
1
1
0
0
⎞
⎠
raised to the hundredth power.
This is accomplished using the code
#
"
 
!
a = [1 0 -1; 0 1 1; 1 0 0];
[v,d] = eig(a);
d = sparse(d);
d100 = d.ˆ100;
a100 = v*d100*inv(v);
We also mention the command eigs which allows us to select only certain
eigenvalues. This uses techniques akin to the power method mentioned earlier.
We give an extract of the help page for eigs
[V,D,FLAG] = EIGS(A,B,K,SIGMA,OPTIONS)
[V,D,FLAG] = EIGS(’Afun’,N,B,K,SIGMA,OPTIONS)
where
B
A symmetric positive definite matrix the same size as A.
K
An integer, the number of eigenvalues desired.
SIGMA
A scalar shift or a two letter string.
OPTIONS
A structure containing additional parameters.
The viable values of SIGMA are
’LM’
Largest Magnitude
(the default)
’SM’
Smallest Magnitude (same as sigma = 0)
’LR’
Largest Real part
’SR’
Smallest Real part
’BE’
Both Ends.
Computes k/2 eigenvalues
from each end of the spectrum (one more
from the high end if k is odd.)

6.6 Speciﬁc MATLAB Commands
211
Example 6.18 Determine the largest two eigenvalues of the matrix
⎛
⎜
⎜
⎜
⎜
⎝
1
0
0
1
−1
0
2
3
5
0
−1
0
0
0
1
6
8
1
2
−2
1
1
1
1
1
⎞
⎟
⎟
⎟
⎟
⎠
.
This is done using the code:
'
&
$
%
A = [1 0 0 1 -1; ...
0 2 3 5 0; ...
-1 0 0 0 1; ...
6 8 1 2 -2; ...
1 1 1 1 1];
[V,D] = eigs(A,2,’LM’)
This iterates and gives:
iter =
1
eigs =
8.4127
-4.8097
stopcrit =
2.0072e-15
==========================
iter =
2
eigs =

212
6. Matrices
8.4127
-4.8097
stopcrit =
3.2411e-15
==========================
V =
0.0769
0.1400
0.6050
0.5780
0.0143
0.0270
0.7674
-0.8034
0.1974
0.0100
D =
8.4127
0
0
-4.8097
6.7 Characteristic Polynomials
We shall pause here to discuss the characteristic polynomial of a matrix, that
is the polynomial p(λ) = det(A −λI). The zeros of this polynomial are the
eigenvalues of the matrix. We quote the result
Theorem 6.19 (Cayleigh–Hamilton) Every square matrix satisﬁes its own
characteristic polynomial, so that p(A) = 0.
We also note that p(0) = det(A), which can be seen by setting λ equal to zero
in the deﬁnition of p(λ). The characteristic polynomial of an n-by-n matrix is
of degree n. As a result of the Cayleigh–Hamilton theorem we have a further
mechanism for determining the inverse of a matrix. Let us consider p(λ) to

6.7 Characteristic Polynomials
213
have coeﬃcients a0, · · · , an. Consequently we have
n

i=0
aiAi = 0,
where we use the natural convention that A0 = I. We can extract one term
from the summation so that
a0I +
n

i=1
aiAi = 0.
Notice that p(0) = a0 so that a0 = det(A), which we assume is non-zero.
Multiplying through by A−1 and dividing by det(A) we have:
A−1 = −
1
det(A)
n

i=1
aiAi−1.
Here we have written the inverse in terms of powers of A which we know can
be written using the diagonalised form of the matrix. As such we have
A−1 = −
1
det(A)P
n−1

i=0
ai+1Di

P−1,
where D and P are deﬁned on page 208.
We are aware that we could also construct the inverse using a variety of
MATLAB commands, however it is important that one realises what is behind
these commands.
We now note that we can determine the characteristic polynomial of a
matrix by evaluating the polynomial p(λ) at n + 1 points and then ﬁtting a
polynomial to these points:
'
&
$
%
function [co] = charpoly(A)
[m,n] = size(A);
if m ˜= n
disp(’Matrix is not square’)
co = [];
break
end
for i = 1:(n+1)
x(i) = (i-1)*pi/n;
y(i) = det(A-x(i)*eye(n));
end
co = polyfit(x,y,n);

214
6. Matrices
We have elected to use the points xi = (i −1)π/n since these will not coincide
with eigenvalues unless the elements of the matrix involve π. We can now
consider the roots of this polynomial to determine the eigenvalues of the matrix
(using roots for instance). There is also a MATLAB procedure to determine
this polynomial, poly(A).
6.8 Exponentials of Matrices
We shall motivate this section by discussing the simple diﬀerential equation:
˙x = ax
which shall be solved subject to the initial condition that x(t0) = x0. This has
the solution
x(t) = ea(t−t0)x0.
We now move on to discuss the matrix equivalent of this equation which is
˙x = Ax
together with the initial condition x(t0) = x0 and this has the solution
x(t) = eA(t−t0)x0.
This method can be used for solving constant coeﬃcient second order systems.
Example 6.20 Solve the equation
¨y + y = 0
subject to the initial conditions y(0) = 0 and ˙y(0) = 1. We introduce the
quantities x1(t) = y(t) and x2(t) = ˙y(t). As such this system can be rewritten
as
˙x =

0
1
−1
0

x,
with x0 = (0, 1)T . This has the solution
x(t) = exp(At)x0.

6.8 Exponentials of Matrices
215
We now have to deﬁne and construct exp(A). We do this using the sum-
mation
exp(A) =
∞

i=0
1
i!Ai.
Again we can use the diagonalised form of the matrix to yield
exp(A) = P
 ∞

i=0
1
i!Di

P−1,
but this gives
exp(A) = P exp(D)P−1,
where exp(D) is the matrix formed with (eλ1, eλ2, · · · , eλn) along its leading
diagonal.
Example 6.21 Construct the matrix exp(A) where
A =
 1
2
0
−1

.
This matrix has eigenvalues of 1 and −1, with corresponding eigenvectors
(1, 0)T and (−1, 1)T . Hence we have
P =
 1
−1
0
1

so that P−1 =
 1
1
0
1

.
Hence
exp(A) =
 1
−1
0
1
  e1
0
0
e−1
  1
1
0
1

=
 e
e −1/e
0
e

.
Notice that to construct exp(At) we simply note that exp(Dt) has diagonal
elements of the form eλjt. In the previous example we would have
exp(At) =
 et
et −e−t
0
et

.
There is actually a command for this purpose in MATLAB called expm (to-
gether with expm1, expm2 and expm3 – which exploit diﬀerent methods). Simply
typing exp(A) will return a matrix full of the exponentials of the elements of
the original elements.
There is another way of calculating the exponential of a matrix which occurs
as a direct consequence of Theorem 6.19. We note that since an n-by-n matrix
satisﬁes its own characteristic polynomial An can be written in terms of a
polynomial of degree n −1. Consequently multiplying through by A and using

216
6. Matrices
the previous expression for An we ﬁnd that An+1 can also be expressed in terms
of a similar polynomial. In fact An can be written as a polynomial of degree
n −1 in A. Since the exponential form of the matrix involves only powers of
the matrix, we note that exp(A) can also be written as a polynomial of degree
n −1 in A. We now need to ﬁnd the coeﬃcients of this polynomial. We again
rely on the Cayleigh–Hamilton theory (but in reverse), that is if A satisﬁes the
equation then so do the eigenvalues.
Example 6.22 Determine exp(At) where A is as given in Example 6.20. The
eigenvalues of the matrix

0
1
−1
0

are actually ±i = ±√−1. We now suppose that
exp(At) = α0I + α1A,
which is a ﬁrst degree polynomial in A. Now substituting in λ = i we ﬁnd that
eit = α0 + α1i
(6.6a)
and for the second eigenvalue
e−it = α0 −α1i.
(6.6b)
Solving Equations (6.6a) and (6.6b) we ﬁnd that α0 = (eit + e−it)/2 = cos t
and α1 = (eit −e−it)/(2i) = sin t. This gives
exp(At) = cos tI + sin tA,
=

cos t
sin t
−sin t
cos t

.
Now substituting this into the solution of Example 6.20 we have
 y(t)
˙y(t)

=

cos t
sin t
−sin t
cos t
  0
1

=
 sin t
cos t

.
This is exactly the solution one would expect (which is a good thing).
In general if a matrix has distinct eigenvalues λ1 and λ2 we can show that
x(t) =
1
λ2 −λ1
 
λ2eλ1t −λ1eλ2t
I +

eλ1t −eλ2t
A
!
x0.
We see that the eigenvalues of the matrix associated with a system are
crucial in determining the fate of the solution. For instance if the real parts

6.9 Tasks
217
of the eigenvalues are real and positive the solution will expand as t increases.
Similarly if both are real and negative the solution will contract. This analysis
is very powerful and allows us to understand the structure of these problems
without having to actually solve them in totality (something which gets harder
and harder).
6.9 Tasks
Task 6.1 Repeat the calculations presented in the example on page 328 using
MATLAB.
Task 6.2 Using the vector r = 1:4 construct the matrix
⎛
⎜
⎜
⎝
1
2
3
4
0
0
0
3
0
0
0
2
0
0
0
1
⎞
⎟
⎟
⎠
Note: there are two commands in MATLAB, fliplr (ﬂip left-right) and
flipud (ﬂip up-down), which will help with this task; you can use either (in
order to see how they work use the help command).
There are many commands we can use to set up larger matrices. However,
in the majority of this text we shall limit our attention to relatively small
matrices.
We can use the diag command to set up matrices which have a structure
which lends itself to construction via vectors of diagonals. Such matrices are
referred to as banded. Consider the following example:




>> r = 1:5;
>> A = diag(r)+diag(r(1:4),1)+diag(r(2:5),-1);
which gives the output
>> A
A =
1
1
0
0
0
2
2
2
0
0

218
6. Matrices
0
3
3
3
0
0
0
4
4
4
0
0
0
5
5
You should recall the nth diagonal is shorter by |n| than the leading diagonal.
In order to understand this code it may help you to type r(1:4) (which gives
the ﬁrst four elements of r) and r(2:5) (which gives the last four elements of
r).
Task 6.3 Set up the ten-by-ten matrix which has +1’s in the ﬁrst super-
diagonal (directly above the leading diagonal) and −1’s in the sub-diagonal
(directly below the leading diagonal).
By this point you should be reasonably conﬁdent about how to set up a variety
of matrices, either by directly typing in the elements or by exploiting structures
within the matrix. We pause here to make sure that you are able to understand
how to extract parts of matrices. Before proceeding make sure you under-
stand what the commands a(:,1), a(2,:), a(2:3,:), a(:,:), a(1:2:3,2)
and a(1,3:-1:1) give (you could try them for the matrix a = [11 12 13;
21 22 23; 31 32 33], where this has elements which reﬂect the labels of the
elements). To help you understand these commands type 1:2:3 which gives
the result [1 3] and 3:-1:1 which gives [3 2 1]. You should now be able to
see which elements these expressions correspond to in the matrix.
It is perfectly acceptable to combine matrices: however we need to make
sure that the operation is well deﬁned within MATLAB. This usually involves
ensuring that the matrix (or vectors) involved have the correct dimensions for
the operation to proceed.
Task 6.4 Determine which of the following operations are viable (you can do
this simply by typing them: however you should perhaps try to determine which
ones are viable a priori).

6.9 Tasks
219
'
&
$
%
A = ones(3);
B = 2*ones(3,2);
C = 3*ones(2,3);
[A B]
[A B’]
[A C B’]
[A C’]
[A; C]
[A; B’]
At this stage you are now in a position to perform relatively simple oper-
ations on matrices; we shall start with a couple of examples of addition and
scalar combination of matrices.
Task 6.5 Perform these calculations both by hand and using MATLAB:
 1
2
3
4
 
3
4
−1
2

2
 3
5
6
−2

−4
 −1
0
2
1


1
3
5

⎛
⎝
2
−1
−1
0
7
−2
⎞
⎠
Task 6.6 Calculate the product AB and BA for a variety of two-by-two ma-
trices. Attempt to work out which matrices of the general form
A =
 a
b
c
d

commute with matrices of the form
B =
 α
β
β
α

(that is, which matrices does AB = BA hold for?). Verify that your answer
is correct by trying some examples; the more obscure the numbers you use the
more unlikely your result is not a ﬂuke.

220
6. Matrices
We have also seen that it is possible to use “dot” arithmetic, which acts
element by element on matrices and vectors.
Task 6.7 Show that for all square matrices A, the matrices B = A + AT and
C = A −AT are symmetric and anti-symmetric respectively.
Task 6.8 Construct the matrix
A =

cos θ
sin θ
−sin θ
cos θ

for θ = 0, θ = π/2 and θ = π (you can either do this directly or by using
MATLAB). By considering the eﬀect of multiplying by the matrix, infer how
Ax compares to x for general x ∈R2 (that is points (x, y) where x, y ∈R).
Construct the inverse of this matrix either using MATLAB, directly by hand
(if you know how) or by using geometric arguments.
Task 6.9 Solve the linear system of equations
3x + 4y = 2
−x + 2y = 0
using MATLAB.
Task 6.10 Solve the linear system of equations
x + y + 2z = 1
x −y −3z = 0
−2x −5y + z = 4.
If you are still not conﬁdent with matrix manipulation you should try the
following tasks.
Task 6.11 Given the matrices
A =
⎛
⎝
1
−1
0
2
3
2
⎞
⎠,
B =
⎛
⎝
2
−1
−1
0
3
2
⎞
⎠and C =
 −1
0
2
1

.
Calculate where possible A + B, AC, CB, (A −B)C and AC −BC.

6.9 Tasks
221
Task 6.12 Calculate the quantities
 1
−1
2
3
0
1
 ⎛
⎝
3
2
1
⎞
⎠and

5
−2
−1
2
  4
0
1
−1
2
1
−2
−1

.
Task 6.13 Calculate, by hand, the quantities
 a
b
c
d
  1
0
0
1

and
 1
0
0
1
  a
b
c
d

.
As we saw earlier a matrix with ones on the leading diagonal (running from
top left to bottom right of a square matrix) is called the identity matrix; it is
usually denoted by I.
Task 6.14 If
A =
 3
2
−1
0
−1
−2

calculate the quantities AAT and AT A where a superscript T denotes the
transpose and corresponds to a reﬂection of the matrix elements about the lead-
ing diagonal. If A has elements ai,j then AT has elements aj,i, and the number
of rows of A equals the number of columns of AT (and similarly for the number
of columns of A and rows of AT ).
Task 6.15 Show that the calculation xxT where x is a row vector with real
entries always gives a positive scalar.
Task 6.16 Expand the matrix equation

1
4
−2
3
  x
y

=

1
−2

and write it as two simultaneous equations. Write the set of three simultaneous
equations in matrix form:
x + y + z = 0
x −2y −z = 2
−x + 3y −z = −1.

222
6. Matrices
Task 6.17 Determine whether the following systems have solutions (and if
these are unique):
3x + 2y
= 7
3x −2y
= 7;
x + y + z
= 1
x + y −z
= 0
x + y
= 0;
x + y + z + a + b + c = 1
x −y + z + a + b + c = 1
x + y −z + a + b + c = 1
x + y + z −a + b + c = 1
x + y + z + a −b + c = 1
x + y + z + a + b −c = 1.
Task 6.18 Determine the solution of the systems
x1 −x4
= 0
−x1 + 2x2 −x3
= 0
−x2 + 2x3 −x4
= 0
x4
= 1;
and
x1 −x4
= 1
−x1 + 2x2 −x3
= 0
−x2 + 2x3 −x4
= 0
x4
= 0.
Task 6.19 By using the command polyfit determine the cubic polynomial
which is the determinant of the matrix
⎛
⎝
0
1
s
s
0
1
1
s
0
⎞
⎠.
Consequently determine the values of s for which this matrix is singular.
Task 6.20 Determine an analytical expression for Bn where
B =

0
1
−1
0

.

6.9 Tasks
223
Task 6.21 Determine the eigenvalues of the matrix
⎛
⎜
⎜
⎝
1
0
0
−1
0
1
0
0
0
0
1
0
−1
0
0
1
⎞
⎟
⎟
⎠.
Task 6.22 Prove that An = PDnP−1 using induction where n ∈N and P
and D are comprised of the eigenvectors (as columns) and eigenvalues of A
respectively.
Task 6.23 Determine the characteristic polynomial of the matrix in Task 6.21
using the code on page 214 and, by ﬁnding the roots of this polynomial, verify
the answer to that task.
Task 6.24 Solve the diﬀerential system
˙x =

2
−1
−1
1

x
subject to the initial condition x(0) = (1, −1)T .

7
Numerical Integration
7.1 Introduction
In this chapter we shall discuss techniques whereby functions can be integrated;
these are quite classical. We will give the derivation of the approximations and
will mention the likely failings of the techniques. Two versions of the code will
be given for each of the main methods, so we can start to appreciate the power
of MATLAB. It is of course possible to write the code as if it were Fortran or
C, but that would waste the power of the package.
Before we start we note: if we consider two points we can ﬁt a straight line
through them; with three we can ﬁt a quadratic and with four we can ﬁt a
cubic (this was discussed in more detail in Chapter 5).
We start by breaking down the integration r´egime into small intervals and
approximating the area below the curve by slices. This method is tantamount
to counting the squares and dealing with the parts of squares at the tops of the
columns in sophisticated ways.

226
7. Numerical Integration
In this case the area under the curve is approximately
7 × 4 × “the area of the boxes”
(the fourth row up has a few part squares as does the ﬁfth row). We obviously
need a scheme which is slightly more robust.
7.2 Integration Using Straight Lines
In this chapter our objective is to calculate the value of the integral
I =
b
"
x=a
f(x) dx.
We shall assume we can calculate (easily) the value of f(x) for all values of
x between a and b. This means we are dealing with a function rather than a
set of data values. We shall explore the latter case in due course but at this
juncture we shall use a new routine integrand.m:
'
&
$
%
%
% integrand.m
% input a set of values (x)
% output function values f(x)
%
function [f] = integrand(x)
%
Here we use f = sin(xˆ2) as a
% sample function.
f = sin(x.ˆ2);

7.2 Integration Using Straight Lines
227
We shall now take a while to derive the method we are going to use to integrate
the function on the grid of points. We shall use N points and as such we use
the code




step = (b-a)/(N-1);
x = a:step:b;
f = integrand(x);
In order to derive the form for the integration we introduce the nomenclature
that the points we have deﬁned above are (xj, fj), where j runs from 1 to N. Let
us consider the consecutive points (xj, fj) and (xj+1, fj+1) and approximate
the curve between them by a straight line. We use the formula for the line
through the points (x1, y1) and (x2, y2) which is
y −y1
y2 −y1
= x −x1
x2 −x1
or y = y1 + y2 −y1
x2 −x1
(x −x1) .
In our case this gives
fL(x) = fj + fj+1 −fj
h
(x −xj) ,
where we have introduced h = xj+1 −xj and fL(x) the formula for the straight
line (This is just a direct application of Newton’s Forward Diﬀerences, (5.1).)
Let us now perform the analytical integration of the function fL(x) between
xj and xj+1 to determine the area Aj,j+1:
Aj,j+1 =
xj+1
"
x=xj
fL(x) dx =
xj+1
"
x=xj
fj+1 −fj
h
(x −xj) + fj dx.
We introduce the linear transformation X = x −xj, where dX = dx and when
x = xj, X = 0 and x = xj+1 correspond to X = h. The integral becomes
Aj,j+1 =
h
"
X=0
fj+1 −fj
h
X + fj

dX,
which can be integrated to yield
Aj,j+1 = h
2 (fj + fj+1) .
This is the area of a trapezium with vertices at (xj, 0), (xj, fj), (xj+1, fj+1)
and (xj+1, 0)1.
1 The area of a trapezium is the mean of the length of the two parallel sides times
the perpendicular distance between them; that is (fj + fj+1)/2 times (xj+1 −xj).

228
7. Numerical Integration
xj
xj+1
Aj,j+1
This method is unsurprisingly called the trapezium rule. In order to determine
the total area from x = a to x = b we sum all the parts
Area =
j=N−1

j=1
Aj,j+1 =
j=N−1

j=1
h
2 (fj + fj+1) .
In order to perform this summation it is instructive to write out the series
Area =h
2 (f1 + f2) + h
2 (f2 + f3) + h
2 (f3 + f4) + · · ·
+ h
2 (fN−2 + fN−1) + h
2 (fN−1 + fN) ,
so that
Area = h
2 (f1 + 2f2 + 2f3 + · · · + 2fN−1 + fN) ≈
b
"
x=a
f(x) dx.
Example 7.1 We shall calculate the integral of the function f(x) = x3 sin x
between zero and one. We shall use N points
#
"
 
!
N = 10;
x = linspace(0,1,N);
h = x(2)-x(1);
f = x.ˆ3.*sin(x);
g = h*(sum(f)-f(1)/2-f(N)/2);

7.2 Integration Using Straight Lines
229
Here we have constructed a grid of points running from zero to one and then
worked out the gap between successive points (that is h). We now construct the
function f and work out the expression for the trapezium rule, which is the
sum of the values of f minus half of the end values. This gives the value of the
integral as g.
7.2.1 Errors in the Trapezium Method
The number of points required for a calculation depends on how exactly you
need to know the answer (in general). The error in this scheme is encountered
because we approximate the curve between the points (xj, fj) and (xj+1, fj+1)
by a straight line. This can be reduced by using a quadratic instead over the
interval spanned by the requisite three points.
We could have used the fundamental code which did not make use of the
combinations of the terms:




integral = 0;
for i = 2:N
integral = integral+(f(i)+f(i-1))/2*h;
end
The advantage of this form of the code is it is far easier to convert to one
in which intermediate results are available. We note that the command /2*h
divides by two and multiplies by h rather than dividing by 2h: this would be
accomplished via parentheses, that is /(2*h).
Before we proceed we should consider the error involved in approximating
the area by a set of trapezia.
 xj
 xj+1
 f(xj)
 f(xj+1)

230
7. Numerical Integration
The error is the unshaded part below the curve. To estimate the extent of
this we again use “Taylor Series” and note that
f(x) = f(xj) + f(xj+1) −f(xj)
h
(x −xj) + (x −xj)(x −xj+1)
2
d2f
dx2




x=ξ
,
where ξ ∈[xj, xj+1]. This can be integrated to give
xj+1
"
x=xj
f(x) dx = h
2 (f(xj) + f(xj+1)) + h3
6
d2f
dx2




x=ξ
.
Consequently the error in using just the ﬁrst term is proportional to h3 and
f ′′(ξ). Notice that if the second derivative is zero over the range the error is
actually zero. Unsurprisingly this corresponds to f(x) being a straight line.
7.3 Integration Using Quadratics
We need to construct a curve which passes through the points (xj−1, fj−1),
(xj, fj) and (xj+1, fj+1). Let us consider a value of j = 1: this is purely to
reduce the verbosity of our expressions. The quadratic passing through these
three points can be written as
fq(x) = f0 + ∆f0
x −x0
h
+ ∆2f0
(x −x0)(x −x1)
2h2
,
using a truncation of Newton’s forward diﬀerence formula, (5.1).
In passing we mention this series expansion is similar to a Taylor series
expansion but instead of the terms being diﬀerentials they are diﬀerences. In
order to derive the formula we now need to integrate the function fq(x) from
x = x0 to x = x2. This is quite straightforward: however at this point we will
exploit the symbolic capabilities of MATLAB
syms x f0 f1 f2 h x0
q = f0+(f1-f0)/h*(x-x0)+(f2-2*f1+f0)/(2*hˆ2)*(x-x0)*(x-(x0+h));
iq = int(q,x0,x0+2*h);
simplify(iq)
ans =
1/3*h*(f0+4*f1+f2)
We shall dissect this portion of code so you can appreciate what is happen-
ing.

7.3 Integration Using Quadratics
231
– In the ﬁrst line we assign the variables x, f0, f1, f2, h and x0 to be symbolic.
This means that MATLAB does not have to know the value of the variables
and treats them as mathematical objects.
– In the second line we set up the function q (which is just the quadratic fq(x)).
– This is integrated in the third line (between x0 and x2 = x0+2*h. (This
produces a verbose answer.)
– Finally we simplify our answer.
Hence we have the answer
x=x2
"
x=x0
fq(x) dx = h
3 (f0 + 4f1 + f2) .
Although we know there is only one quadratic through a given set of points, it
is instructive to re-derive this in another way. We shall start with the general
quadratic
fq(x) = a + b(x −x0) + c(x −x0)(x −x1).
The requirement that the quadratic goes through the point (x0, f0) gives us
that a = f0. Using the point (x1, f1) gives us b = (f1 −f0)(x1 −x0). Finally
using (x2, f2) we have
f2 = f0 + f1 −f0
x1 −x0
(x2 −x0) + c(x2 −x0)(x2 −x1),
which can be manipulated to give:
c =
1
x2 −x1
 f2 −f0
x2 −x0
−f1 −f0
x1 −x0

.
This gives us the general form of the quadratic through three points (which can
be used for Task 7.10). We now return to the form for regularly spaced points
so ∆xj = h and integrating from x = x0 to x = x2 = x0 + 2h:
x=x0+2h
"
x=x0
fq(x) dx =
x=x0+2h
"
x=x0
f0 + f1 −f0
h
(x −x0)
+ 1
h
f2 −f0
2h
−f1 −f0
h

(x −x0)(x −x1) dx.
Now using the substitution X = x −x0, so that x = x0 corresponds to X = 0
and x = x2 = x0 + 2h corresponds to X = 2h the expression x −x1 =

232
7. Numerical Integration
X + x0 −x1 = X −h and dx = dX. Hence we have
=
2h
"
X=0
f0 + f1 −f0
h
X +
1
2h2 (f2 −f0 −2(f1 −f0)) X(X −h) dX
=

f0X + f1 −f0
h
X2
2 +
1
2h2 (f0 −2f1 + f2)
X3
3 −hX2
2
2h
0
= 2hf0 + f1 −f0
h
2h2 +
1
2h2 (f0 −2f1 + f2)
8h3
3
−2h3

= h

2f0 + 2(f1 −f0) + 1
3 (f0 −2f1 + f2)

= h
3 (f0 + 4f1 + f2) .
We now need to divide the range of integration into the appropriate number
of subintervals. Notice the number of intervals needs to be even (and hence the
number of points needs to be odd). The total integral is approximated by
b
"
x=a
f(x) dx ≈h
3 (f0 + 4f1 + f2) + h
3 (f2 + 4f3 + f4) + h
3 (f4 + 4f5 + f6) + · · ·
+ h
3 (fN−4 + 4fN−3 + fN−2) + h
3 (fN−2 + 4fN−1 + fN) .
This can be simpliﬁed to give
b
"
x=a
f(x) dx ≈h
3 (f0 + 4f1 + 2f2 + 4f3 + 2f4 + · · · + 2fN−2 + 4fN−1 + fN) .
This is called Simpson’s 1
3 rule.
We shall now construct a code to determine the integral. At this point we
could use a code which used a conventional approach, but we shall try to use
a version which exploits the power of MATLAB.

7.3 Integration Using Quadratics
233
'
&
$
%
%
% Simpson’s 1/3 rule.
%
x = 0.0:0.1:1.0;
h = x(2)-x(1);
N = length(x);
if mod(N,2) == 0
disp(’Routine needs an odd number of points’)
break
% Ensure the number of points is odd
end
rodd = 1:2:N;
reven = 2:2:(N-1);
weights(rodd) = 2; weights(1) = 1; weights(N) = 1;
weights(reven) = 4;
f = sin(x.ˆ2);
integral = h/3*sum(weights.*f);
format long e
disp([integral])
This calculates the value of the expression
1
"
0
sin x2 dx.
The value which MATLAB comes out with is 3.102602344332209e-01, where
we have changed the way in which these numbers are displayed by using the
command format long e. This answer can be checked using MATLAB’s sym-
bolic capabilities:
syms x f
f = sin(xˆ2);
f1 = int(f,0,1)
f1 =
1/2*FresnelS(2ˆ(1/2)/piˆ(1/2))*2ˆ(1/2)*piˆ(1/2)
This value can be compared with that attained using the symbolic toolbox,
using the command vpa (variable precision arithmetic):

234
7. Numerical Integration
vpa(f1)
ans =
.310268301723381101808152423165
(Note we can change the number of digits using the command digits(10)). We
further note that this is still a symbolic object: in order to obtain a value (which
can be used for plotting, for example) we use the command double. This is a
case of MATLAB being too clever: it has solved the integral and written it as a
Fresnel integral (for further details see Abramowitz and Stegun – Handbook of
Mathematical Functions). Our simple integration using ten points does quite
well: in fact the error is proportional to h4, which can be shown using the same
technique as we used for the trapezium rule on page 230.
In the above code we have introduced the term weights which is applied
to the terms before they are added together to obtain the integral. The MAT-
LAB command mod allows the user to determine the remainder when the ﬁrst
argument is divided by the second. In this case when considering mod 2 we are
checking for parity (that is whether N is even or odd).
In the code for Simpson’s one third rule we have re-introduced another
MATLAB command, namely break. This stops the code, or more exactly it
exits the current level: for example if it is used in a nested loop it will terminate
the current level and return to the previous level. This manual entry for break
is instructive here
>> help break
BREAK Terminate execution of WHILE or FOR loop.
BREAK terminates the execution of FOR and WHILE loops.
In nested loops, BREAK exits from the innermost loop only.
We now progress to consider cubic approximations to the function in the
hope that this will provide even more accurate answers.
Again we can use a technique which involves summing the separate intervals,
which you may prefer:




integral = 0;
for j = 1:2:N-2
integral = integral + h*(f(j)+4*f(j+1)+f(j+2))/3;
end

7.4 Integration Using Cubic Polynomials
235
7.4 Integration Using Cubic Polynomials
As in the previous sections we need to deﬁne an approximating curve and in
order to do so we need four points (x0, f0), (x1, f1), (x2, f2) and (x3, f3). Using
the same form as above we can write the cubic equation as
fc(x) = f0+∆f0
x −x0
h
+∆2f0
(x −x0)(x −x1)
2h2
+∆3f0
(x −x0)(x −x1)(x −x2)
6h3
.
In addition to the terms deﬁned earlier we have introduced the third-order
forward diﬀerence. This can be deﬁned recursively using ∆2, so that
∆3f0 = ∆2(∆f0)
=
∆2f1 −∆2f0
=
(f3 −2f2 + f1) −(f2 −2f1 + f0)
=
f3 −3f2 + 3f1 −f0,
using the Newton forward diﬀerence for ∆2f0. We now need to integrate from
x = x0 to x = x3, and we again exploit the symbolic tool box for this, using
the code
syms x f0 f1 f2 f3 h x0
x1 = x0+h; x2 = x0+2*h; x3 = x0+3*h;
t1 = (f1-f0)/h*(x-x0);
t2 = (f2-2*f1+f0)/(2*hˆ2)*(x-x0)*(x-x1);
t3 = (f3-3*f2+3*f1-f0)/(6*hˆ3)*(x-x0)*(x-x1)*(x-x2);
q = f0+t1+t2+t3;
q1 = int(q,x,x0,x3);
simplify(q1)
This gives the answer 3/8*h*(f0+3*f1+3*f2+f3). Thus we have
x3
"
x=x0
fc(x) dx = 3h
8 (f0 + 3f1 + 3f2 + f3) .
You should note it is possible to do all these integrals by hand, but we wish to
demonstrate the power and the utility of this particular toolbox.
We now need to combine all the subintervals, so
b
"
x=a
f(x) dx
≈
3h
8 (f0 + 3f1 + 3f2 + f3) + 3h
8 (f3 + 3f4 + 3f5 + f6) + · · ·
+3h
8 (fN−3 + 3fN−2 + 3fN−1 + fN) ,

236
7. Numerical Integration
which can be simpliﬁed to give
b
"
x=a
f(x) dx ≈3h
8 (f0 + 3f1 + 3f2 + 2f3 + 3f4 + 3f5 + · · ·
+2fN−3 + 3fN−2 + 3fN−1 + fN) .
This is referred to as Simpson’s 3
8 rule.
We shall now give a MATLAB program based on the same structure as the
previous one. Notice this time the number of points needs to be divisible by
three.
'
&
$
%
%
% simpson’s 3/8 rule.
%
N = 10;
x = linspace(0,1,N);
h = x(2)-x(1);
ms = ’Number of intervals should be divisible by three’;
if mod(N-1,3) ˜= 0
disp(ms)
break
end
m = (N-1)/3;
rdiff = 3*(1:(m-1))+1;
weights = 3*ones(1,N);
weights(1) = 1; weights(N) = 1;
weights(rdiff) = 2;
f = sin(x.ˆ2);
integral = 3*h/8*sum(weights.*f);
disp([integral])
The answer given by this is 0.31024037588964. In fact this is not quite as good
as the previous method. The error is again proportional to h4 but the constant
of proportionality is larger. We could also write the integral in separate regions,
that is without combination, so
#
"
 
!
integral = 0;
for j = 1:3:N-3
integral = integral + h*(f(j)+3*f(j+1) ...
+3*f(j+2)+f(j+3))*3/8;
end

7.5 Integrating Using MATLAB Commands
237
Each of these methods has a restriction on the numbers of points one can
use. However these can be circumvented by using an amalgamation of the two
schemes. There are other methods available for integrating functions and some
of these will be met in due course. We could continue this process, especially
with the symbolic toolbox at our disposal to perform the algebra. For instance
the formula obtained by using a quartic over ﬁve points is
x4
"
x=x0
f(x) dx ≈2h
45 (7f0 + 32f1 + 12f2 + 32f3 + 7f4) .
Although you might think the higher the order the polynomial the more
accurately you would know the answer, there are problems which are intrinsic
to using high-order polynomials. In fact the optimum method is to use a com-
bination of the two Simpson methods. If the number of points supplied is even
we use the one third rule for the ﬁrst N −3 points (which is necessarily an odd
number of points and consequently an even number of intervals) and then we
use the three-eighths rule on the remaining points.
7.5 Integrating Using MATLAB Commands
As with many examples in this text we can also use standard MATLAB com-
mands, for instance quad and quad8 (see help quad). These commands use
similar techniques to those above but with the advantage of automation. For
instance they exploit grids which can adapt. This means that in regions which
are harder to integrate (perhaps with more variation in the function) the scheme
adds extra points.
The syntax is:




tol = [1e-4 1e-5];
a = 0; b = pi;
trace = 1;
q = quad(’sin’,a,b,tol,trace)
These quantities are respectively the extent of the domain x ∈[a, b], the
tolerances (relative and absolute) and whether the user wants to see a trace or
not (setting trace as non-zero shows the evolution of the calculation).
Example 7.2 We show the integration of the function J1(x) for x = 0 to
x = 10. This is actually a Bessel function which occurs as one of the solutions

238
7. Numerical Integration
to the diﬀerential equation
x2 d2y
dx2 + xdy
dx + (x2 −1)y = 0,
and is revisited in Chapter 8.
Fortunately MATLAB has a routine which evaluates Bessel functions but
we need to write our own routine to make sure that it is available for quad:




function [value]=ourbess(x)
value = besselj(1,x);
and then we simply need the code:




q = quad(’ourbess’,0,10,[1e-5 1e-5],1);
This gives a value of 1.24593587184673. The integral of the function J1(x) is
−J0(x) and hence the value we seek is −J0(10) + J0(0) ≈1.245935764; so as
we can see the integration scheme does very well.
7.6 Speciﬁc Examples of Integrals
We shall now describe how we can deal with other problems which arise when
evaluating numerical integrals.
7.6.1 Inﬁnite Integrals and Removable Singularities
Using the various methods we can evaluate integrals from a to b, but if one or
more of these values is inﬁnite we need a diﬀerent treatment. This will vary
depending on the form of the integral or more exactly the integrand.
Example 7.3 For example let us consider the integral
I =
∞
"
0
e−x2 dx.

7.6 Speciﬁc Examples of Integrals
239
In this case the integrand e−x2 decays very quickly so we can adequately deter-
mine the value of the integral using
IX =
X
"
0
e−x2 dx,
for a suitable value of X (in this case X = 10 is more than suﬃcient). We
can evaluate the integral for a few values of X until IX is constant (to within
a deﬁned tolerance). We could develop an algorithm to decide what value of X
to use, but in general we will use the above method. We can also exploit the
symmetry of problems, for instance
∞
"
−∞
e−x2 dx = 2
∞
"
0
e−x2 dx ≈2
X
"
0
e−x2 dx,
provided X ≫1. We can also use transformations to rescale the regions of
integration.
In fact in this example we could have used the MATLAB command erf which
gives the error function
E(q) =
2
√π
x
"
q=0
e−q2 dq.
We can use erf(Inf) which gives us the value unity.
We now consider how we might perform an integral for which the integrand
is singular at an end-point of the range. For instance:
1
"
q=0
1
q1/2 dq =
#
2q1/2$1
q=0 = 2.
Example 7.4 We consider the integral of the function f(x) = e−x/√x between
x = 0 and x = 1. Firstly we separate the range into the two disjoint ranges
[0, ϵ)∪[ϵ, 1] where ϵ ≪1 (that is it is very small). We now consider the integral:
ϵ
"
0
e−x
√x dx

240
7. Numerical Integration
and note that over this range e−x ≈1 −x + x2/2 + · · · . Thus
ϵ
"
0
e−x
√x dx ≈
ϵ
"
0
1
√x

1 −x + x2
2 + · · ·

dx =
#
2x1/2 −2
3x3/2 −1
5x5/2 + · · ·
$ϵ
0
=

2ϵ1/2 −2
3ϵ3/2 −1
5ϵ5/2

.
The integral can now be evaluated using:
'
&
$
%
epsil = 0.01;
val = 2*sqrt(epsil)-2/3*epsilˆ1.5-1/5*epsilˆ2.5;
x = linspace(epsil,1,100);
f = exp(-x)./sqrt(x);
h = x(2)-x(1);
N = length(x);
int = val;
for j = 1:N-1
int = int + h/2*(f(j+1)+f(j));
end
This gives a value 1.49764481658781 (the value given by MATLAB is
erf(1)*sqrt(pi) which is erf(1)√π ≈1.493648266) where
erf(x) =
2
√π
x
"
t=0
e−t2 dt.
7.6.2 Indeﬁnite Integrals
So far we have only been interested in deﬁnite integrals, but we shall now
consider how one might determine
I(x) =
x
"
q=a
f(q) dq.
Instead of using a scalar variable to store the cumulative total, we exploit a
vector to store intermediate results, so that

7.6 Speciﬁc Examples of Integrals
241
'
&
$
%
integral = zeros(size(x));
step = x(2)-x(1);
N = length(integral);
for j = 2:N
integral(j) = integral(j-1)+step*(f(j)+f(j-1))/2;
end
disp([’Value of total integral ’ num2str(integral(N))]);
Example 7.5 We now plot the function
g(x) =
x
"
q=0
e−q2 dq.
We determine g(x) for x = 0 to x = 10 using the code
'
&
$
%
xv = linspace(0,10);
f = exp(-xv.ˆ2);
N = length(xv);
step = xv(2)-xv(1);
g(1) = 0.0;
for j = 2:N
g(j) = g(j-1)+step*(f(j)+f(j-1))/2;
end
plot(xv,g)
text(5,max(g)/2,’Integral of eˆ{-xˆ2}’,’FontSize’,20)
which gives

242
7. Numerical Integration
0
1
2
3
4
5
6
7
8
9
10
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
Integral of e−x
2
7.7 Tasks
Task 7.1 Construct the sequence
f(i) =
⎧
⎨
⎩
1
if
mod (i, 3) = 0
2
if
mod (i, 3) = 1
3
if
mod (i, 3) = 2
up to N = 12.
Task 7.2 In Chapter 7 for Simpson’s one third rule we used




rodd = 1:2:N;
reven = 2:2:(N-1);
weights(rodd) = 2; weights(1) = 1; weights(N) = 1;
weights(reven) = 4;
and for Simpson’s three eighths rule
#
"
 
!
m = (N-1)/3;
rdiff = 3*(1:(m-1))+1;
weights = 3*ones(1,N);
weights(1) = 1; weights(N) = 1;
weights(rdiff) = 2;

7.7 Tasks
243
Write out these coeﬃcients for N = 9 for the one third rule and N = 10 for
the three eighths rule. You should construct each of the vectors by hand.
By now you should be able to read the codes trap.m, simp13.m and simp38.m
and understand what they do. You should also be able write your own program
which returns the value of a function evaluated at a given point. Try this task.
Task 7.3 Write a routine which takes an input x and returns the value of
f(x) = ln

x +
√
x2 + 1

.
Task 7.4 Using the trapezium rule calculate the integral of the quadratic x2 −
3x + 2 between x = 1 and x = 3 (check your answer with the exact answer).
Task 7.5 Using Simpson’s one third rule integrate the cubic x3 −x+1 between
the limits x = 0 and x = 1 (check your answer against the exact answer).
Task 7.6 Using Simpson’s one third rule integrate the function f(x) = sin x
between the limits x = 0 and x = π (check your answer against the exact
answer). You might want to change the number of points you use and see what
happens to the error.
Task 7.7 Calculate the value of the integral
∞
"
0
1
√
x2 + 1
dx.
You will need to truncate the domain, and you should investigate the eﬀect of
this truncation as well as the number of points required to accurately calculate
the integral.
Task 7.8 The length along a curve y = y(x) from x = a to x = b is given by
the expression
S =
b
"
x=a
%
1 +
dy
dx
2
dx.
In many cases this expression can be determined analytically: however there are
some very simple cases for which it can’t be. Consider the problem of a sine
curve truncated over the range [θ, π −θ]:

244
7. Numerical Integration
0
0.5
1
1.5
2
2.5
3
0
0.2
0.4
0.6
0.8
1
1.2
The expression for the length of this curve is
S =
π−θ
"
φ=θ

1 + cos2 x dx.
Unfortunately this integral is intractable using analytic means, but determine
the value numerically using the trapezium rule for a variety of values of θ.
Task 7.9 (*) Determine the integral
10
"
0
cos x
x1/2 dx
by splitting the integral into two ranges [0, ϵ] and [ϵ, 10] where ϵ is taken to be
small. In this ﬁrst range the function cos x can be approximated by its Taylor
series and this form can be used to work out the contribution from the “singular
part” of the integral.
Task 7.10 (*) Derive an expression for the integral of the quadratic passing
through the points (xi, fi) i = 0, 1 and 2 from x = x0 to x = x2 (use the general
quadratic on page 231). This gives you Simpson’s scheme for variably spaced
points this can also be extended to four points with a cubic.
If you are feeling very brave you could also work out the errors associated
with these approximations.

7.7 Tasks
245
Task 7.11 Integrate the function x ln x between the limits 1 and 2 using the
MATLAB function quad.

8
Solving Diﬀerential Equations
8.1 Introduction
In this book we have introduced you to a variety of techniques and hopefully
given you a taster for how one might approach the solution of certain types
of problem. In this chapter we shall tackle the problem of solving diﬀerential
equations using numerical methods. This is perhaps the most proliﬁc use of
these techniques and it can involve all of the previous chapters and also those
following.
Initially we will limit our attention to problems which we can solve ana-
lytically. This is purely so we can compare the solutions we obtain with those
derived directly. It is very rare to be able to do this, although as your knowl-
edge of the structure of diﬀerential equations increases you will realise more
problems are tractable than one might initially think, but these still represent
quite idealised situations. Understanding how methods work, or more specif-
ically how they fail, is absolutely crucial when using them. This chapter will
introduce quite a few terms.
8.2 Euler’s Method and Crank–Nicolson
We shall start with ﬁrst-order diﬀerential equations and we will use a formula
which we used when we discussed the modiﬁcation of the Newton–Raphson

248
8. Solving Diﬀerential Equations
method (page 117). Consider the diﬀerential equation
dy
dt = f(y, t).
(8.1)
Using the formal deﬁnition we can write the derivative as
dy
dt = lim
∆t→0
y(t + ∆t) −y(t)
∆t
.
As ∆t →0 this tends to the actual derivative (provided certain conditions are
met), but in reality we will need to use a ﬁnite value for ∆t. We shall denote
the time level t by subscript n and the time level t + ∆t by the subscript n + 1,
in which case
dy
dt




t=tn
≈yn+1 −yn
∆t
,
which can be seen using the Taylor series expansion for y(t + ∆t). We can now
evaluate the diﬀerential equation (8.1) at the time t = tn, to give
yn+1 −yn
∆t
= f(yn, tn).
This is easily rearranged to give
yn+1 = yn + ∆tf(yn, tn).
This is called Euler’s method and is an example of an explicit method. Let us
use it to solve a couple of problems:
Example 8.1 Consider the diﬀerential equation
dy
dt = t
subject to the initial condition that y(0) = 0 from 0 to 2. We can integrate this
equation directly to give y(t) = t2/2. Or using the explicit Euler method we
have
yn+1 −yn
∆t
= tn,
which can be rearranged to give
yn+1 = yn + (n −1)(∆t)2
where we have used tn = (n −1)∆t (so that t1 = 0).

8.2 Euler’s Method and Crank–Nicolson
249
Writing out the ﬁrst few equations:
y2 = y1,
y3 = y2 + (∆t)2 = y1 + (∆t)2,
y4 = y3 + 2(∆t)2 = y1 + 3(∆t)2,
y5 = y4 + 3(∆t)2 = y1 + 6(∆t)2,
y6 = y5 + 4(∆t)2 = y1 + 10(∆t)2 · · ·
In fact we have the result that
yn = y1 + (n −1)(n −2)
2
(∆t)2
and this should be y1 + (n−1)2
2
(∆t)2 for the exact solution: so we can see that
this scheme does a reasonable job.
Example 8.2 Solve the diﬀerential equation
dy
dt = (1 −t)y
subject to the initial condition y(0) = 1 from t = 0 to t = 5. Firstly, let us
determine the analytical solution. This can be found by dividing through by y
1
y
dy
dt = 1 −t
and then integrating with respect to t
" 1
y
dy
dt dt
=
"
1 −t dt
" dy
y
=
t −t2
2 + C
ln y
=
t −t2
2 + C
y
=
Aet−t2/2.
Now applying the initial condition we ﬁnd that A = 1 so the actual solution to
the problem is:
y = et−t2/2.
Now let us determine the numerical solution. We shall ﬁrstly set up the vectors
for the time grid and the solution: the actual coding of the algorithm is very
simple. The function f(y, t) = (1 −t)y, so

250
8. Solving Diﬀerential Equations
'
&
$
%
% Euler’s method
% euler.m
dt = 0.1;
t = 0.0:dt:5.0;
y = zeros(size(t));
y(1) = 1;
for ii = 1:(length(t)-1)
y(ii+1) = y(ii) + dt * (1-t(ii))*y(ii);
end
exact = exp(t-t.ˆ2/2);
plot(t,y,t,exact,’--’)
This solution compares well with the exact solution shown as the dashed curve.
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
We have used ﬁfty-one points to perform this integration and if we used more
then we could have improved the accuracy of this solution.
Consider the example:
Example 8.3 Solve the diﬀerential equation
dy
dt = y

8.2 Euler’s Method and Crank–Nicolson
251
subject to the initial condition y(0) = 1. The solution of this is y(t) = et and
in this case f(y) = y, and we reuse the above codes changing the appropriate
line in the loop.
This method is dubbed explicit. One way of thinking of this is the value
of yn+1 is available explicitly from the equation. We have taken the equation
to be evaluated at t = tn but equally it could have been evaluated at t = tn+1.
Instead of using the formal deﬁnition to give the derivative at t we use it at
t + ∆t (which is equally valid – representing a backward diﬀerence rather than
a forward diﬀerence). The formula is now
yn+1 = yn + ∆tf(yn+1, tn+1).
Depending on the form of f this can be coded easily or it may involve subtle
manipulation or use of the root ﬁnding techniques detailed in Chapter 4. These
techniques are called implicit since the value (that is yn+1) is contained within
the equation; that is it is implicit to it. As an illustration let us consider the
same example as above, that is
dy
dt = y,
subject to
y(0) = 1.
Using this new scheme this equation would be discretised as
yn+1 −yn
∆t
= yn+1,
so that
yn+1 =
yn
1 −∆t.
This type of solution generally improves matters. In fact in this case the schemes
are very similar (especially for small values of ∆t, since 1/(1 −∆t) ∼1 + ∆t).
We could improve things further by using a technique called Crank–Nicolson.
In the previous two cases we have taken the formal deﬁnition of the derivative
to represent the time derivative at either the previous (forward diﬀerence) or
the next point (backward diﬀerence). We could also take it to be valid at the
mid-point (central diﬀerence). The errors in the former two cases are of order
∆t (that is ﬁrst-order accurate) whereas the latter has errors of order ∆t2 (that
is second-order accurate). The code for this purpose is:

252
8. Solving Diﬀerential Equations
'
&
$
%
% crank.m
function [error] = crank(dt)
t = 0.0:dt:5.0;
y = zeros(size(t));
y(1) = 1;
for ii = 1:(length(t)-1)
y(ii+1) = y(ii)*(1+dt/2)/(1-dt/2);
end
exact = exp(t);
errors = abs(exact-y);
error = max(errors);
which is derived by using:
yn+1 −yn
∆t
= yn+1 + yn
2
,
which can be rewritten as:
yn+1 = yn
1 + ∆t/2
1 −∆t/2.
In general this is derived from
dy
dt




tn+1/2
= 1
2 (f(yn, tn) + f(yn+1, tn+1)) .
Notice if the inhomogeneity (or the coeﬃcients) involves functions of t they
may be evaluated at tn+1/2.
By using the MATLAB command polyfit we can conﬁrm that this scheme
behaves as we predicted; that is the errors are of order ∆t2. We can improve
on these methods and they are the basis for schemes which can solve partial
diﬀerential equations. At this point we have dealt with systems for which we
can easily “invert” the function f(y, t). However if this is not so we will need to
guess the new solution (using a predictor step) and then iterate until a solution
is attained at each step (using a corrector step). Sometimes it is suﬃcient to use
ﬁxed-point iteration for this process, in which case the predictor and corrector
steps are synonymous. However with some systems it is necessary to use more
of their history.

8.2 Euler’s Method and Crank–Nicolson
253
8.2.1 Analytical Comparisons
Let us pause and compare the solutions for the equation y′ = y subject to the
initial conditions y(0) = 1. The three schemes are:
Explicit Euler : yn+1 = yn(1 + ∆t),
(8.2a)
Implicit Euler : yn+1 =
yn
1 −∆t,
(8.2b)
Crank–Nicolson : yn+1 = yn
1 + ∆t/2
1 −∆t/2.
(8.2c)
All of which are of the form yn+1 = αyn which have the solution yn = αny0.
We know that the exact solution is y(t) = et so that if t = tn = n∆t, this gives
yn =en∆t =
∞

j=0
(n∆t)j
j!
,
yn =1 + n∆t + (n∆t)2
2!
+ O((n∆t)3).
We can now compare the solutions from each of the schemes:
Explicit Euler The solution of Equation (8.2a) gives
yn = (1 + ∆t)n = 1 + n∆t + n(n −1)
2
∆t2 + O((n∆t)3)
and as we can see this diﬀers from the exact solution in the second term.
Implicit Euler The solution of Equation (8.2b) gives
yn = (1 −∆t)−n = 1 + n∆t + n(n + 1)
2
∆t2 + O((n∆t)3).
Again this solution diﬀers in the second term.
Crank–Nicolson Finally the solution of Equation (8.2c) gives
yn =
1 + ∆t/2
1 −∆t/2
n
,
which can be manipulated to give
yn = 1 + n∆t + (n∆t)2
2
+
1
6n3 + n
12

(∆t)3 + O((n∆t)4).
In this case the solution diﬀers in the third term and the ﬁrst two are
accurate.

254
8. Solving Diﬀerential Equations
So far we have only considered an explicit method: now let us consider an
example using the implicit method. Solve the diﬀerential equation
dy
dt = t + y,
subject to y(0) = 0 from t = 0 to t = 1 in steps of ∆t = 1/4. Firstly we
discretise the equation
yn+1 −yn
∆t
= tn+1 + yn+1,
which can be rearranged to give:
yn+1 =
1
1 −∆t {yn + ∆t tn+1} .
Now construct the solution where ti = i∆t, so with n = 0 we have
y1 =
1
1 −1
4

y0 + 1
4
1
4

,
but the initial value y0 = y(0) = 0 so that
y1 = 1
12.
And at the next point
y2 = 4
3
 1
12 + 1
4
2
4

= 5
18,
and for n = 2
y3 = 4
3
 5
18 + 1
4
3
4

= 67
108
and ﬁnally with n = 3 to give y4 (or y(1))
y4 = 4
3
 67
108 + 1
4
4
4

= 94
81.
Now we should solve the original problem, which we do using an integrating
factor. Multiply through by e−t to give
e−t dy
dt −e−ty = e−tt,
the left hand side of which can be written as an exact diﬀerential so that
d
dt

e−ty

= e−tt,

8.2 Euler’s Method and Crank–Nicolson
255
which can be integrated and manipulated to give:
y = Cet + et
"
t
e−tt dt.
The integral can be determined using integration by parts to give
y(t) = Cet −t −1.
The constant is found to be unity and hence y(1) = e −2 ≈0.718. We can
see that the above solution is quite bad. We note it is possible to perform this
analysis in a far more rigorous manner. We should also note that the stability
of these schemes is crucial.
We now consider an inhomogeneous example.
Example 8.4 Solve the equation
dy
dt + y = sin t
subject to the initial condition y(0) = 1 for the range [0, 1] in steps of 0.1 using
the Crank–Nicolson technique.
We discretise this equation as
yn+1 −yn
∆t
+ yn+1 + yn
2
= sin tn+1/2.
It is tempting to approximate the right-hand side of this expression by (sin tn +
sin tn+1)/2. However the method we have chosen above actually is the value at
the mid-point, whereas this other treatment is merely an approximation. The
diﬀerence is only of order ∆t2, but we aim to reduce errors where possible (this
error can be shown by using Taylor series). Rearranging the above gives:
yn+1 =
1
1
∆t + 1
2

yn
 1
∆t −1
2

+ sin tn+1/2

.
This can be coded using:

256
8. Solving Diﬀerential Equations
'
&
$
%
n = 11;
t = linspace(0,1,n);
dt = t(2)-t(1);
y = zeros(size(t));
y(1) = 1;
f1 = 1/dt+1/2;
f2 = 1/dt-1/2;
for j = 1:(n-1)
y(j+1) = (y(j)*f2+ ...
sin((t(j)+t(j+1))/2)/f1;
end
The exact solution is
y(t) = 1
2(sin t −cos t) + 3
2e−t.
Plotting both solutions on the same graph, there does not appear to be any
diﬀerence.
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0.65
0.7
0.75
0.8
0.85
0.9
0.95
1
However plotting their diﬀerence shows that the errors are of order 10−4.
The explicit Euler method is not limited to linear equations. For instance we
could solve the equation
dy
dt = t2 + y2.

8.2 Euler’s Method and Crank–Nicolson
257
This has the solution
y(t) = −t
CY−3/4

t2
2
	
+ J−3/4

t2
2
	
CY1/4
 t2
2

+ J1/4
 t2
2

,
which is in terms of Bessel functions. These are solutions to the second-order
diﬀerential equation
t2 d2y
dt2 + tdy
dt +

t2 −ν2
y = 0.
In this case the parameter ν takes the value 1/4 or −3/4. You will meet the
functions in due course but at the moment let us presume that the solution to
the above problem is unknown in which case numerical methods are our only
way forward. In fact in some cases even where the solution is known its form
may be so complicated that it is better to use the numerical solution straight
away (however if an analytical solution is available it is worth checking that we
have the correct value).
In order to solve the above problem (subject to the boundary condition that
y(0) = 0) the code euler.m needs to be modiﬁed to (mod eul.m):
'
&
$
%
dt = 0.1;
t = 0.0:dt:1.0;
y = zeros(size(t));
y(1) = 0;
for ii=1:(length(t)-1)
y(ii+1) = y(ii) + dt * (t(ii)ˆ2+y(ii)ˆ2);
end
figure(1)
plot(t,y,’--’)
This gives

258
8. Solving Diﬀerential Equations
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
The “exact” solution can be plotted and is given by
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
t
y
This was obtained using the symbolic toolbox within MATLAB with the code
'
&
$
%
syms t y
y = dsolve(’Dy = tˆ2+yˆ2’,’y(0)=0’,’t’);
N = 20;
tv = linspace(eps,1,N);
for i = 1:N
f(i) = double(subs(y,t,tv(i)));
end
Here we have used the commands
dsolve Which solves the diﬀerential equation deﬁned as its ﬁrst argument,
subject to the initial condition y(0)=0 and ﬁnally we use the third argu-
ment to tell MATLAB that t is the independent variable.

8.3 Banded Matrices
259
subs This substitutes values from the array tv in the solution of the diﬀerential
equation.
double This returns a double precision value (that is it converts a symbolic
value to a double precision value).
We shall now discuss a class of methods which can be derived using Taylor
series.
8.3 Banded Matrices
In many problems matrices will not only be sparse but they will also have very
well-deﬁned structure. Let us consider a tri-diagonal matrix, so that the only
non-zero entries are in the super- and sub-diagonal. We consider the set of
equations
a1y2 + b1y1 = r1,
a2y3 + b2y2 + c2y1 = r2,
... =
...
an−1yn + bn−1yn−1 + cn−1yn−2 = rn−1,
bnyn + cnyn−1 = rn.
Notice that we can solve the ﬁrst equation to give y1 in terms of y2, so that
y1 = r1
b1
−a1
b1
y2
which can then be substituted into the next equation to eliminate y1. This gives
a2y3 + b2y2 + c2
r1
b1
−a1
b1
y2

= r2,
a2y3 +

b2 −c2
a1
b1

y2 = r2 −c2
r1
b1
.
This amounts to a redeﬁnition of b2 and r2. This equation can then be used to
express y2 in terms of y3 and then substitute it into the next equation, until
we reach the ﬁnal equation at which point we have an equation solely in yn
which is easily solved. The system at this point has only got a super-diagonal
(we have eliminated the sub-diagonal) and hence the values of all the preceding
y’s can be found by back substitution. This is written in code as:

260
8. Solving Diﬀerential Equations
'
&
$
%
% Set up system
x = 0.0:pi/6:pi;
N = length(x);
h = x(2)-x(1);
a = 1/hˆ2*ones(size(x));
b = -2/hˆ2*ones(size(x));
c = 1/hˆ2*ones(size(x));
r = x.*sin(x);
a(1) = 0; b(1) = 1; r(1) = 0;
c(N) = 0; b(N) = 1; r(N) = 0;
% Forward sweep
for j = 2:N
b(j) = b(j) - c(j)*a(j-1)/b(j-1);
r(j) = r(j) - c(j)*r(j-1)/b(j-1);
end
% Final equation
y(N) = r(N)/b(N);
for j = (N-1):-1:1
y(j) = r(j)/b(j)-a(j)*y(j+1)/b(j);
end
xf = 0:pi/50:pi;
sol = 2*(1-cos(xf))-xf.*sin(xf)-4*xf/pi;
clf
plot(x,y,’.’,’MarkerSize’,24)
hold on
plot(xf,sol,’b’)
xlabel(’x’,’FontSize’,15)
ylabel(’f’,’FontSize’,15)
text(0.5,-0.2,’Finite difference solution’,’FontSize’,12)
text(0.7,-0.3,’shown as blobs’,’FontSize’,12)
This is actually solving the following problem
d2y
dx2 = x sin x
y(0) = y(π) = 0.
We can solve this by hand by integrating twice and applying the boundary
conditions to obtain
y(x) = −2 cos x −x sin x −4x
π + 2.

8.3 Banded Matrices
261
As you can see even using 7 points determines the solution quite well
This method is called a Thomas algorithm.
Example 8.5 In order to solve the system
d2y
dx2 + 4dy
dx −y = cos x
subject to the boundary conditions y(0) = 0 and y(π) = 1, we use the code
0
0.5
1
1.5
2
2.5
3
3.5
−1.8
−1.6
−1.4
−1.2
−1
−0.8
−0.6
−0.4
−0.2
0
x
f
Finite difference solution
shown as blobs

262
8. Solving Diﬀerential Equations
'
&
$
%
% Set up system
x = 0.0:pi/60:pi;
N = length(x);
h = x(2)-x(1);
a = (1/hˆ2+4/(2*h))*ones(size(x));
b = (-2/hˆ2-1)*ones(size(x));
c = (1/hˆ2-4/(2*h))*ones(size(x));
r = cos(x);
a(1) = 0; b(1) = 1; r(1) = 0;
c(N) = 0; b(N) = 1; r(N) = 1;
% Forward sweep
for j = 2:N
b(j) = b(j) - c(j)*a(j-1)/b(j-1);
r(j) = r(j) - c(j)*r(j-1)/b(j-1);
end
% Final equation
y(N) = r(N)/b(N);
for j = (N-1):-1:1
y(j) = r(j)/b(j)-a(j)*y(j+1)/b(j);
end
clf
plot(x,y)
xlabel(’x’,’FontSize’,15)
ylabel(’y’,’FontSize’,15)
which gives

8.4 Runge–Kutta Methods
263
0
0.5
1
1.5
2
2.5
3
3.5
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
x
y
We have used the discretisation
yn+1 −2yn + yn−1
h2
+ 4yn+1 −yn−1
2h
−yn = cos xn.
This can be extended to penta-diagonal systems, which can again be done
using a Thomas algorithm but this becomes more and more complicated. How-
ever, we can also exploit the sparse command. We can also solve periodic
problems which give rise to sparse problems, but with elements in the top right
and bottom left corners in addition to the diagonals.
8.4 Runge–Kutta Methods
We shall not derive these methods in fullness but shall give a ﬂavour of how
this may be done. In order to solve the system
dy
dt = f(t, y),
we use Taylor series and as such we write the scheme as
yn+1 = yn + ak1 + bk2
(8.3)
where
k1
=
∆t f(tn, yn),
k2
=
∆t f(tn + α∆t, yn + βk1).

264
8. Solving Diﬀerential Equations
In order to derive an equation of this form we start with the Taylor series for
yn+1 = y(t + ∆t)
yn+1 = yn + ∆tf(tn, yn) + ∆t2
2 f ′(tn, yn) + · · · ,
where the prime denotes a derivative with respect to t. Using the chain rule we
can write
df
dt = ∂f
∂t + ∂f
∂y
dy
dt ,
but using the original equation ( ˙y = f)
df
dt = ∂f
∂t + ∂f
∂y f,
so that
yn+1 = yn + ∆tf(tn, yn) + ∆t2
2
∂f
∂t + ∂f
∂y f

· · · .
Let us now substitute the forms for k1 and k2 into Equation (8.3), so that
yn+1 = yn + a∆tf(tn, yn) + b∆tf (tn + α∆t, yn + β∆tf(tn, yn)) .
We now need to expand the last term in this equation, so that
f (tn + α∆t, yn + β∆tf(tn, yn)) ≈f(tn, yn) + α∆t ∂f
∂t




tn,yn
+ β∆tf(tn, yn) ∂f
∂y




tn,yn
.
By substitution and comparison with the other Taylor series we ﬁnd that
in ∆tf
a + b = 1,
in ∆t2 ∂f
∂t
αb
= 1
2,
in ∆t2f ∂f
∂y
βb
= 1
2.
We have only three equations but with four unknowns, so we are free to choose
one value. For instance a = 1/2 implies b = 1/2 with in turn gives α = β = 1.
The scheme is then
yn+1 = yn + ∆t
2 (f(tn, yn) + f (tn + ∆t, yn + ∆tf(tn, yn))) .
We can of course choose other values of a (or any of the other variables). In
order to code this algorithm we use:

8.4 Runge–Kutta Methods
265
'
&
$
%
%
% runge_kutta.m
%
t = 0.0:0.1:5.0;
del_t = 0.1;
a = 0.5; b = 1-a;
alpha = 0.5/b; beta = 0.5/b;
n = length(t);
y = zeros(size(t));
y(1) = 0;
for ii = 1:n-1
time = t(ii);
k_1 = del_t*func(t(ii),y(ii));
k_2 = del_t*func(t(ii)+alpha*del_t,y(ii)+beta*k_1);
y(ii+1) = y(ii) + a * k_1 + b * k_2;
end
exact = exp(t-t.ˆ2/2);
using




function [value] = func1(t,y)
value = y*(1-t);
Using this number of points there is no visible diﬀerence between the numerical
and the exact solution. We can investigate the eﬀect of altering the value of a.
This method can be extended to higher orders: for instance the fourth-order
scheme is given by
yn+1 = yn + 1
6 (k1 + 2k2 + 2k3 + k4)
where
k1
=
∆tf(tn, yn)
k2
=
∆tf

tn + ∆t
2 , yn + k1
2

k3
=
∆tf

tn + ∆t
2 , yn + k2
2

k4
=
∆tf (tn + ∆t, yn + k3) .
MATLAB oﬀers two commands ode23 and ode45 which perform these in-
tegrations. It uses a more advanced numerical scheme which iterates to correct
the solution as it progresses. The above code could be replaced by

266
8. Solving Diﬀerential Equations




y0 = 1; tspan = [0 5];
[tt,yy] = ode45(’func1’,tspan,y0);
This uses an adaptive step which is based on the local gradients. Interestingly
this chooses to use 57 points to attain the default accuracy (which is deﬁned
in terms of relative and absolute errors, see the manual pages help ode45 for
details).
8.5 Higher-Order Systems
8.5.1 Second-Order Systems
At the moment we shall only brieﬂy mention these systems and shall not dwell
on their solution using the so-called ﬁnite diﬀerence techniques. However we
shall discuss how they might be solved using Runge–Kutta methods (speciﬁcally
using the intrinsic MATLAB commands). Let us consider a simple example:
Consider the solution of the system
d2y
dt2 + y = 0,
subject to the conditions that y(0) = 1 and y′(0) = 0 from t = 0 to t = π.
Firstly we introduce a vector z such that
z =
 z1
z2

=
 y
y′

,
so that
z′ =
 y′
y′′

=
 y′
−y

=

z2
−z1

.
We can now construct the corresponding MATLAB code (func2.m):




function [out] = func2(t,in)
out=zeros(2,1);
out(1) = in(2);
out(2) = -in(1);




y0=[1; 0];
ts=[0 pi];
[t,y]=ode45(’func2’,ts,y0);
plot(t,y)

8.5 Higher-Order Systems
267
which gives
0
0.5
1
1.5
2
2.5
3
3.5
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
Notice that y not only contains the solution z1(t) but also its derivative (z2(t)).
The exact solution here is cos t (and consequently its derivative is −sin t). This
technique can be used equally for non-autonomous systems (that is involving t
explicitly). At this stage we will not consider all the options which are available
to use when using these methods: however we merely mention that using the
ode routines one can set the absolute and relative errors.
Before moving on we remark that it is possible to consider higher-order
systems in a variety of ways. For instance in order to solve
d2y
dt2 + 2dy
dt + y = sin t,
(which is a second-order linear ordinary diﬀerential equation), we can either
use ﬁnite diﬀerence representations of the derivatives, for instance
d2y
dt2




t=tn
≈yn+1 −2yn + yn−1
∆t2
,
or we can rewrite the system as coupled ﬁrst-order systems (which is more
conducive to Runge–Kutta techniques). We introduce z1(t) = y and z2(t) =
dy/dt. Hence the above system is rewritten as
dz1
dt = z2
dz2
dt = −2z2 −z1 + sin t.

268
8. Solving Diﬀerential Equations
Example 8.6 We write the system
¨x + x2 = cos t
as a system of ﬁrst-order equations, deﬁning z1 as x and z2 and ˙x so that
˙z1 = z2
˙z2 = −z2
1 + cos t.
We shall now discuss the solution of second-order systems and start with
an example of a constant coeﬃcient problem.
Example 8.7 Solve the diﬀerential equation
d2y
dt2 + 3dy
dt + 2y = 0
subject to the initial conditions that y(0) = 1 and y′(0) = 0, from 0 to 1.
We discretise the above equation to yield
yn+1 −2yn + yn−1
∆t2
+ 3yn+1 −yn−1
2∆t
+ 2yn = 0,
which is rearranged to give
 1
∆t2 +
3
2∆t

yn+1 = −−2yn + yn−1
∆t2
+
3
2∆tyn−1 −2yn.
The initial conditions tell us that y1 = 1 and (y2 −y1)/∆t = 0 (so that y2 = 1
also). The equation has the exact solution y(t) = e−t −e−2t, which is used for
comparison.

8.5 Higher-Order Systems
269
'
&
$
%
n = 10;
t = linspace(0,1,n);
dt = t(2)-t(1);
y = zeros(size(t));
y(1) = 1; y(2) = 1;
fact = (1/dtˆ2+3/(2*dt));
for j = 2:(n-1)
y(j+1) = (-(-2*y(j)+y(j-1))/dtˆ2 ...
+3/(2*dt)*y(j-1) ...
-2*y(j))/fact;
end
true = 2*exp(-t)-exp(-2*t);
clf
plot(t,true,t,y,’.’,’MarkerSize’,15)
legend(’Exact’,’Approx’,-1)
This produces the results:
Notice: only using ten points we do not get a particularly accurate answer.
This can be rectiﬁed by using more points.
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0.6
0.65
0.7
0.75
0.8
0.85
0.9
0.95
1
Exact 
Approx

270
8. Solving Diﬀerential Equations
We shall now discuss the solution of two problems, which are quite similar.
Both of the examples can actually be solved using analytical methods: however
at this stage the solutions are not accessible to us, so we shall treat them as
problems for which we do not know the answers1. The ﬁrst problem will be
solved using ﬁnite diﬀerence methods and the second one will be tackled using
the second-order Runge–Kutta scheme described on page 263.
8.5.2 Bessel’s equation
We shall now discuss the solution of the mathematical problem, whereby we
seek to integrate the diﬀerential equation
t2 d2y
dt2 + tdy
dt +

t2 −1
4

y = 0,
from t = 0 to t = 10 subject to the initial conditions y(0) = 0 and y′(0) = 1.
We shall solve this problem using ﬁnite-diﬀerence techniques, in order to do
this we need to exploit the discretised form for the second derivative given on
page 267. We introduce the grid such that tn = (n−1)∆t, so that t1 corresponds
to the initial time, t = 0. There is also the corresponding values of the function
yn. We shall presume that there are N points in the grid. At time t = tn we
can write the above diﬀerential equation as:
t2
n
yn+1 −2yn + yn−1
∆t2
+ tn
yn+1 −yn−1
2∆t
+

t2
n −1
4

yn = 0
for n = 2 upto n = N −1. In this expression we have used the central diﬀerence
formula for both the ﬁrst and second derivatives, which are both second-order
accurate expressions. We now consider the initial condition y(0) = 0 implies
that y1 = 0 and y′(0) = 1 means that (y2 −y1)/∆t = 1 so that y2 = ∆t. Here
we have used the forward diﬀerence formula, which is necessarily biased. By
using the above discretised equation with n = 2 we obtain an expression for
y3 in terms of the known quantities y2 and y1. Similarly by using the equation
with n = 3 we can obtain y4 and so on. To this end we rewrite the equation as:
 t2
n
∆t2 + tn
2∆t

yn+1 = −t2
n
−2yn + yn−1
∆t2
+ tnyn−1
2∆t
−

t2
n −1
4

yn.
We now use MATLAB code to solve the problem as posed above.
1 The ﬁrst one is called the Bessel equation and has solutions Jν(t) and Yν(t) and
in this case the parameter ν = 1/2. These functions are discussed extensively in
a book by G. N. Watson ‘A Treatise on Bessel Functions’. The second equation
has solutions which are Airy functions, aﬀectionately called the Airy and Bairy
functions.

8.5 Higher-Order Systems
271
'
&
$
%
%
% Code to determine Bessel functions of order 1/2.
%
y_zero = 0;
yp_zero = 1;
delta_t = 0.1;
t=0:delta_t:10;
N = length(t);
y=zeros(size(t));
y(1) = y_zero;
y(2) = y(1) + delta_t * yp_zero;
for j = 2:N-1
factor = t(j)ˆ2/delta_tˆ2+t(j)/(2*delta_t);
y(j+1) = (-t(j)ˆ2*(-2*y(j)+y(j-1))/delta_tˆ2 ...
+t(j)*y(j-1)/(2*delta_t)...
-(t(j)ˆ2-1/4)*y(j))/factor;
end
The solution is found to be:
0
1
2
3
4
5
6
7
8
9
10
−0.2
−0.1
0
0.1
0.2
0.3
0.4
0.5
In this case we have elected to use the higher-order derivatives directly: however
we could have used the idea of introducing a second function so that the system
is reduced to two ﬁrst-order diﬀerential equations. For this purpose we deﬁne
z(1)(t) = y(t) and z(2)(t) = dy
dt .

272
8. Solving Diﬀerential Equations
Using these functions the diﬀerential equation becomes:
t2 dz(2)
dt
+ tz(2) +

t2 −1
4

z(1) = 0
subject to the initial conditions z(1)(0) = 0 and z(2)(0) = 1. Again we discretise
the equation so that
t2
n
z(2)
n+1 −z(2)
n
∆t
+ tnz(2)
n
+

t2
n −1
4

z(1)
n
= 0.
We also need to discretise the relation between z(1) and z(2) so that
z(2)
n
= z(1)
n+1 −z(1)
n
∆t
.
We are now ready to use MATLAB code.
'
&
$
%
%
% Solve Bessel’s equation using two first-order systems.
%
y_zero = 0;
yp_zero = 1;
delta_t = 0.1;
t=0:delta_t:10;
nt = length(t);
z=zeros(nt,2);
z(1,1) = y_zero;
z(1,2) = yp_zero;
for j = 2:N
time = (t(j)+t(j-1))/2;
factor = timeˆ2/delta_t;
z(j,1) = delta_t*z(j-1,2)+z(j-1,1);
z(j,2) = (timeˆ2*z(j-1,2)/delta_t-time*z(j-1,2)...
- (timeˆ2-1/4)*z(j-1,1))/factor;
end
Notice that we have elected to evaluate the time at the midpoint of the interval.
If we had just used it at the start of the range, then the singularity (obtained by
dividing by t2) would cause our scheme to fail. In fact this method does not do
very well and this sensitivity to initial conditions is partly the reason for this.
Also we have actually used ﬁrst-order accurate discretisations. We will see that
this reduction to ﬁrst-order systems is necessary for Runge–Kutta methods in
the next section; fortunately the failings of this approach in ﬁnite diﬀerences
are not reproduced.

8.5 Higher-Order Systems
273
8.5.3 Airy’s Equation
We shall now discuss the solution of the problem
d2y
dx2 −xy = 0
subject to the initial conditions y(0) = 1 and y′(0) = 0. Again we use the
reduction to two ﬁrst-order systems deﬁning
z(1)(x) = y(x) and z(2)(x) = dy
dx.
We also introduce the column vector z with these functions as elements, so that
z′ = f(x, z) =
 z(2)
xz(1)

;
derived using the fact that (z(1))′ = z(2) by deﬁnition, and (z(2))′ = xz(1)
directly from the diﬀerential equation. The Runge–Kutta method derived on
page 263 can equally be applied to vectors. We recall that we have
zn+1 = zn + δx
2 (f(xn, zn) + f(xn + δx, zn + δxf(xn, zn))) .
We can use a similar code to the previous example, but we shall use a slightly
diﬀerent format. Let us deﬁne a function to work out the function f:
#
"
 
!
%
function [out] = func(x,in)
out(1) = in(2);
out(2) = x*in(1);
and the main routine
'
&
$
%
x=0.0:0.1:5.0;
delta_x = 0.1;
N = length(x);
z=zeros(N,2);
z(1,1) = 1; z(1,2) = 0;
for j=1:(N-1)
k1 = delta_x*func(x(j),z(j,:));
k2 = delta_x*func(x(j)+delta_x,z(j,:)+k1);
z(j+1,:) = z(j,:) + 1/2*(k1+k2);
end

274
8. Solving Diﬀerential Equations
In these two examples we have solved problems which have two boundary
(or initial) conditions at one location. Let us now discuss how we might solve
problems which have conditions at two diﬀerent locations.
8.5.4 Shooting Methods
Here we solve problems by starting at a point where we need to guess certain
quantities and these guesses can subsequently be improved upon. We shall
illustrate the technique with a couple of examples.
At the outset we note that for linear problems there are other ways of doing
what we are about to discuss (see for instance the example in the section on
banded matrices on page 259).
Example 8.8 (A Linear Boundary-Value Problem)
We shall use the Runge–Kutta scheme detailed above to solve the problem
d2y
dx2 + y = 0
subject to the boundary conditions y(0) = 1/2 and y(π/3) = 1/2. We can solve
this problem analytically to give
y(x) = 1
2 cos x +
1
2
√
3 sin x.
Let us solve the equation subject to y(0) = 1/2 and y′(0) = λ, where we are
free to choose λ (at the moment). We then integrate from 0 to π/3: if y(π/3)
is not equal to 1/2 then we can adjust the value of λ. In order to do this we
use the Newton–Raphson scheme. The main routine is:

8.5 Higher-Order Systems
275
'
&
$
%
%
%
global x z
lambda = 1; % Initial guess
delta = 1e-2;
for its = 1:40
f_lambda = int_eqn(lambda);
if abs(f_lambda)<1e-8
break
end
f_lambda_del = int_eqn(lambda+delta);
lambda = lambda ...
- f_lambda*delta/(f_lambda_del-f_lambda);
end
exact = 1/2*cos(x)+1/(2*sqrt(3))*sin(x);
'
&
$
%
%
% int_eqn.m
function [err] = int_eqn(lambda)
global x z
delta_x = (pi/3)/100;
x = 0.0:delta_x:pi/3;
N = length(x);
z = zeros(N,2);
z(1,1) = 1/2;
z(1,2) = lambda;
for j=1:(N-1)
k1 = delta_x*func1(x(j),z(j,:));
k2 = delta_x*func1(x(j)+delta_x,z(j,:)+k1);
z(j+1,:) = z(j,:) + 1/2*(k1+k2);
end
err = z(N,1) - 1/2;




function [out] = func1(x,in)
out(1) = in(2);
out(2) = -in(1);
This method is very successful and the exact solution is retrieved (albeit approx-
imately). Let us now discuss the solution of a problem for which an analytical

276
8. Solving Diﬀerential Equations
solution is not available, and in fact this is how it would actually be solved. The
other technique hinted at earlier is not available as this is a nonlinear problem.
Example 8.9 (A Nonlinear Boundary-Value Problem)
This problem comes from ﬂuid dynamics and its solution provides a description
of the ﬂow proﬁle within a boundary layer on a ﬂat plate. We shall not dwell on
its derivation, since it is far beyond the scope of this text, but we are required
to solve
d3f
dη3 + f d2f
dη2 = 0,
subject to the boundary conditions f(0) = f ′(0) = 0 and
lim
η→∞f ′(η) = 1.
In this case we have a third-order equation and as such we shall introduce
z(1) = f(η), z(2) = df
dη and z(3) = d2f
dη2 .
As in the previous example we are short of a boundary condition at one end,
so we solve the problem using the initial conditions
z(1)(0) = 0, z(2)(0) = 0 and z(3)(0) = λ.
We then integrate towards inﬁnity (in fact in this case a value of 10 is ﬁne for
inﬁnity, even if we integrated further nothing would change). The discrepancy
between the value of f ′ at this point and unity is used to iterate on the value of
λ. The codes we shall use for this purpose are

8.5 Higher-Order Systems
277
'
&
$
%
%
%
global x z
lambda = 0.5; % Initial guess
delta = 1e-2;
for its = 1:40
f_lambda = int_blas(lambda);
if abs(f_lambda)<1e-8
break
end
f_lambda_del = int_blas(lambda+delta);
lambda = lambda ...
- f_lambda*delta/(f_lambda_del-f_lambda);
end
plot(z(:,2),x)
xlabel(’Flow velocity’)
ylabel(’Distance from the wall’)
axis([-0.5 1.5 0 10])
'
&
$
%
%
% int_blas.m
function [err] = int_blas(lambda)
global x z
delta_x = 0.1;
x = 0.0:delta_x:10;
N = length(x);
z = zeros(N,3);
z(1,1) = 0;
z(1,2) = 0;
z(1,3) = lambda;
for j=1:(N-1)
k1 = delta_x*funcb(x(j),z(j,:));
k2 = delta_x*funcb(x(j)+delta_x,z(j,:)+k1);
z(j+1,:) = z(j,:) + 1/2*(k1+k2);
end
err = z(N,2) - 1;

278
8. Solving Diﬀerential Equations




function [out] = funcb(x,in)
out(1) = in(2);
out(2) = in(3);
out(3) = -in(1)*in(3);
The actual value of λ is approximately 0.4689. The ﬂow proﬁle looks like this:
−0.5
0
0.5
1
1.5
0
1
2
3
4
5
6
7
8
9
10
Flow velocity
Distance from the wall
8.6 Boundary-Value Problems
We shall now consider more general boundary-value problems. These can be
solved by shooting methods (as presented above): however if the problems are
linear they can generally be solved directly. Rather than starting at one end of
a domain we simply set up a set of equations for the entire problem and solve
these as a matrix problem.
We shall demonstrate this via a few simple examples:
Example 8.10 Solve the diﬀerential equation
d2y
dx2 −y = 0

8.6 Boundary-Value Problems
279
subject to the conditions that y(0) = 0 and y(1) = 1. (The exact solution of
this can be found as y(x) = sinh x/ sinh 1.)
Firstly we consider a grid of points running from 0 to 1 in steps of h: for
the sake of argument we shall take h to be 0.1 (so that there are 11 points).
This grid can be set up using




x = linspace(0,1,11);
y = zeros(size(x));
h = x(2)-x(1);
Here we have used the command linspace to set up the grid and also set aside
a vector y to contain the answer. The step size, h, has also been deﬁned here.
Let us consider the above equation at the point x = xj. Then we can ap-
proximate the quantities to give
yj+1 −2yj + yj−1
h2
−yj = 0
or rearranging
yj+1 + yj(−2 −h2) + yj−1 = 0.
This equation holds for all the interior points, that is j = 2 through to j = 10.
At the end points we need to impose the boundary conditions, so at x = 0
(which corresponds to x = x1) we have y1 = 0 and at the other end, that is
x = x11 = 1, we have y11 = 1. Combining these we have eleven equations in
eleven unknowns which can be put together to form the matrix
⎛
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
1
0
0
0
0
0
0
0
0
0
0
1
τ
1
0
0
0
0
0
0
0
0
0
1
τ
1
0
0
0
0
0
0
0
0
0
1
τ
1
0
0
0
0
0
0
0
0
0
1
τ
1
0
0
0
0
0
0
0
0
0
1
τ
1
0
0
0
0
0
0
0
0
0
1
τ
1
0
0
0
0
0
0
0
0
0
1
τ
1
0
0
0
0
0
0
0
0
0
1
τ
1
0
0
0
0
0
0
0
0
0
1
τ
1
0
0
0
0
0
0
0
0
0
0
1
⎞
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎛
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
y1
y2
y3
y4
y5
y6
y7
y8
y9
y10
y11
⎞
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
=
⎛
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
0
0
0
0
0
0
0
0
0
0
1
⎞
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
,
where τ = −2 + h2. This system can be set up using the MATLAB commands:

280
8. Solving Diﬀerential Equations
'
&
$
%
A = diag(ones(11,1)*(-2-hˆ2),0)+diag(ones(10,1),1) ...
+diag(ones(10,1),-1);
A(1,:) = 0; A(1,1) = 1;
A(11,:) = 0; A(11,11) = 1;
b = zeros(11,1);
b(11) = 1;
y = A\b;
This gives us the solution to the above problem to within approximately 10−4,
which can be seen by comparing it with the exact solution. We have used the
expression A\b to return A−1b.
In this case both of the boundary conditions were imposed on the function,
whereas it is plausible to consider problems in which conditions are imposed
on the derivative (or even mixed conditions).
Example 8.11 Solve the diﬀerential equation
d2y
dx2 −y = 0
subject to the conditions that y′(0) = 0 and y(1) = 1. In this case the exact
solution is y(x) = cosh x/ cosh 1. We have used the same equation as the last
example and hence we only need to change the lines which impose the boundary
conditions. At the lower end of the domain we need to impose y′(0) = 0. The
derivative at this end is given by
dy
dx




x=x1
≈y1 −y0
h
.
This condition translates to y0 = y1. Hence the ﬁrst line of the matrix is set
using




A(1,:) = 0;
A(1,1) = 1; A(1,2) = -1;
This solution has errors of approximately 10−2 which are still acceptable but
are nevertheless larger than in the previous example.
At this point it is worth pausing to consider the source of these errors. We
can choose to use more points to reduce the errors but it would be better to

8.6 Boundary-Value Problems
281
understand how they arise, since increasing the number of points is not always
an option. In the ﬁrst example we used the approximation
d2y
dx2




x=xj
≈yj+1 −2yj + yj−1
h2
.
(8.4)
We now wish to predict the probable error associated with this formula. To do
this we exploit Taylor series. We recall that
y(a + h) = y(a) + h dy
dx




x=a
+ h2
2!
d2y
dx2




x=a
+ h3
3!
d3y
dx3




x=a
+ · · ·
.
The key here is how many terms to take in the expansion. We note that the
entire series can be written as
y(a + h) = y(a) +
∞

n=1
hn
n!
dny
dxn




x=a
or using the intermediate value theorem
y(a + h) = y(a) +
N

n=1
hn
n!
dny
dxn




x=a
+
hN+1
(N + 1)!
dN+1y
dxN+1




x=ξ
where ξ ∈[a, a+h]. Diﬀerent values of ξ in the interval obviously give diﬀering
values of the errors and we usually talk about the maximum error and the
bound on this value.
Consider the simple example of approximating a curve by a straight line: the
source of error is going to come from the fact that the curve is not necessarily
a straight line. A straight line has a zero second derivative so the errors will
be proportional to this quantity, that is if the curve is a straight line then the
approximation will be exact.
Now we shall substitute the Taylor series into the ﬁnite diﬀerence formula
(8.4) which gives:
yj+1 = yj + hy′
j + h2
2! y′′
j + h3
3! y(3)
j
+ h4
4! y(4)
j
+ · · ·
,
yj = yj,
yj−1 = yj −hy′
j + h2
2! y′′
j −h3
3! y(3)
j
+ h4
4! y(4)
j
+ · · ·
.
Thus we have
yj+1 −2yj + yj−1
h2
= y′′
j + 2h2
4! y(4)
j
+ · · ·
.

282
8. Solving Diﬀerential Equations
We can eliminate the dots and write this as
= y′′
j + 2h2
4! y(4)(ξ),
where ξ ∈[xj−1, xj+1]. We now have a useful estimate of the error, namely
that it is proportional to h2 and the maximum value of the fourth derivative
in the interval.
This shows us that we can reduce the error by increasing the number of
points (which you might think anyway). Obviously the fourth derivative is
beyond our control.
In the second example we had to use what is called a biased stencil at the
edge to evaluate the derivative there. Again we can use the Taylor series to ﬁnd
out the form of the error
dy
dx




x=x1
≈y2 −y1
h
= y′
1 + h
2 y′′(ξ)
where ξ ∈[y1, y2]. In this case we note that the error is proportional to h
(rather than h2) and as such the errors will be larger (as indeed they are).
It is possible to reduce these errors by using wider stencils (that is using
the values of yj±2 for example). However, there is a computational cost to pay.
In fact it is possible to use all the points to work out the derivative at a point
and these methods are very accurate and require very few points (due to their
enhanced accuracy). This class of techniques is called spectral methods, but
their structure is beyond the scope of this text.
8.7 Population Dynamics
We now consider the solution of the equations which arise within the descrip-
tion of population models. Let us consider the solution of the problem of a
population which depends on the environment in which it lives, namely the
logistic model
dN
dt = rN −rN 2
K ,
(8.5)
where r is assumed to be positive and the constant K represents the capacity
of the environment to supply the population with resources (for instance food
and water). The solution of this system is
N(t) =
N0K
N0 + (K −N0)e−rt ,

8.7 Population Dynamics
283
where N0 is the initial population. It is also observed that as t →∞N(t) →K
(the equilibrium population). Let us now presume that we do not know this
solution and determine the solution of the equation numerically. Let us start
with a simple Euler integration scheme.
'
&
$
%
r = 0.5;
K = 2;
N0 = 1;
t = 0:0.1:10.0;
delta_t = t(2)-t(1);
nt = length(t);
N = zeros(size(t));
N(1) = N0;
for j = 1:(nt-1)
N(j) = N(j-1) + delta_t*(r*N(j)-r*N(j)ˆ2/K);
end
exact = N0*K./(N0+(K-N0)*exp(-r*t));
0
1
2
3
4
5
6
7
8
9
10
2
2.5
3
3.5
4
4.5
5
Time
Population
As you can see this numerical solution matches that acquired analytically very
well.

284
8. Solving Diﬀerential Equations
We now move on to discuss the numerical solution of multi-dimensional
systems, for instance:
dN
dt = N (a −bP)
dP
dt = P (cN −d) ,
where P reﬂects the number of predators and N the number of prey. The values
of the constants a, b, c and d reﬂect the reproductive and predatory habits of
the two species. For instance a larger value of a corresponds to an increased
rate of reproduction of the prey. We again use Eulerian integration to give the
numerical solution.
'
&
$
%
a = 1; b = 2;
c = 1; d = 2;
N0 = 4;
P0 = 0.2;
t = 0:0.1:10.0;
delta_t = t(2)-t(1);
nt = length(t);
N = zeros(size(t));
P = zeros(size(t));
N(1) = N0;
P(1) = P0;
for j = 1:(nt-1)
N(j+1) = N(j)+delta_t*(N(j)*(a-b*P(j)));
P(j+1) = P(j)+delta_t*(P(j)*(c*N(j)-d));
end
The solution here is oscillatory and looks like this

8.8 Eigenvalues of Diﬀerential Systems
285
0
1
2
3
4
5
6
7
8
9
10
0
1
2
3
4
5
6
7
8
Prey
Predator
Here we observe that the population of the prey grows and then the numbers
of predators are able to increase until there are too many predators and the
supply of prey is virtually destroyed. Enough survive to rebuild the population
and the cycle repeats.
8.8 Eigenvalues of Diﬀerential Systems
We shall now discuss the solution of equations like
d2y
dx2 + λy = 0
subject to the conditions that y(0) = y(π) = 0. This is an example of a simple
diﬀerential eigenvalue problem. It can be solved analytically and we ﬁnd that
there are only solutions when λ = n2 for n ∈Z. There are many problems
where an analytical solution is not accessible and we need to use ﬁnite diﬀerence
techniques. To this end we rewrite the equation as
−d2y
dx2 = λy.
We shall now discretise the equation at a set of points {yj} j = 1, · · · , N, so
that
−yj+1 −2yj + yj−1
h2
= λyj

286
8. Solving Diﬀerential Equations
for j = 2, · · · , N −1 and yj = (j −1)h with h = π/(N −1). We also need the
conditions that y1 = yN = 0, which reﬂect the conditions that y(0) = y(π) = 0.
This gives a system of the form Ay = λy. Consequently we expect the values
of λ to be the eigenvalues of the matrix A.
'
&
$
%
n = 200;
h = pi/(n-1);
A = diag(2*ones(n-2,1)/hˆ2,0) ...
+diag(-ones(n-3,1)/hˆ2,1) ...
+diag(-ones(n-3,1)/hˆ2,-1);
[V,D] = eigs(A,3,’SM’);
y = linspace(0,pi,n);
for i = 1:3
eigf = [0 V(:,i)’ 0];
plot(y,eigf)
pause
end
This code gives the ﬁrst three eigenvalues and eigenfunctions, which should be
1, 4 and 9 and correspondingly sin x, sin 2x and sin 3x.
8.9 Tasks
Task 8.1 In this chapter we have seen an example which uses Euler’s method
to solve a ﬁrst-order equation, namely
dy
dt = (1 −t)y,
subject to y(0) = 1. This was solved using the code euler.m:

8.9 Tasks
287
'
&
$
%
%
% Euler’s method
% euler.m
%
dt = 0.1;
t = 0.0:dt:5.0;
y = zeros(size(t));
y(1) = 1;
for ii=1:(length(t)-1)
y(ii+1) = y(ii) + dt * (1-t(ii))*y(ii);
end
exact = exp(t-t.ˆ2/2);
figure(1)
plot(t,y,t,exact,’--’)
Modify the above code to solve the equation
dy
dt = −y
√
t,
again subject to the boundary condition y(0) = 1 from t = 0 to t = 1. (You
should also work out the exact solution and compare your answers.)
In the notes we then go on to discuss the errors intrinsic to this kind of calcu-
lation. In order to work out the error it is crucial to know the exact solution.
There are two main ways of expressing the error, which are deﬁned earlier (see
page 52).
Task 8.2 Calculate both the above errors involved in the solution of the equa-
tion
dy
dt = ty,
subject to the boundary condition y(0) = 1 between t = 0 and t = 1, using
∆t = 1/4. (You should do these calculations by hand either using a calcula-
tor or typing the numbers into MATLAB). Compare the errors for the same
calculation applied to the diﬀerential equation
dy
dt = −ty,
everything else remaining the same.

288
8. Solving Diﬀerential Equations
Task 8.3 Further modify the above code (mod eul.m) to solve the diﬀerential
equation
dy
dt = sin t + sin y,
subject to the condition that y(0) = 0 from t = 0 to t = 10π. You can use a
variety of step lengths: however you must ensure that they are less than unity
in magnitude.
Task 8.4 Solve the diﬀerential equation
dy
dt = −t
2 −y
3,
using the implicit Euler scheme with ∆t = 1/3, from t = 0 to t = 1 using
the boundary condition y(0) = 0. Compare this solution to the exact solution
and one obtained using a MATLAB code using 1001 points in this interval.
(You will need to solve the above equation for yn+1 and then modify one of the
previous codes. It might be best to go back to euler.m.)
We can also use MATLAB’s intrinsic functions ode23 or ode45, which ex-
ploit Runge–Kutta techniques. These routines are more accurate than the Euler
schemes we have used above. In order to use them it is necessary to write a
code which evaluates the right-hand side of the equation
dy
dt = f(t, y).
One such example is given on page 265. Let us give a further example. In order
to solve the problem posed in Task 8.3 we should use the code (odef.m)




function [value] = odef(t,y)
value = sin(t)+sin(y);
together with the code




y0 = 0;
tspan = [0 10*pi];
[t,y] = ode45(’odef’,tspan,y0);
Task 8.5 Modify the above codes to solve the problem
dy
dt = t2 −y2,

8.9 Tasks
289
from t = 0 to t = 2 subject to the boundary condition that y(0) = 0, using the
MATLAB routine ode45.
It should be noted that even if the system does not explicitly vary with t
(that is a dependence of the right-hand side on t) the ﬁrst line of the corre-
sponding function should include t in its arguments. For example in solving the
system
dy
dt = y,
the corresponding function would be




function [value] = func(t,y)
value
= y
(Note that these equations are referred to as autonomous if there is no explicit
variation with t.)
Task 8.6 Compare the numerical and exact solution of the equation
dy
dt = −y + t2
subject to the condition that y(0) = 1 integrated from t = 0 to t = 2.
Task 8.7 Modify the code on page 260 to solve the problems:
1. y′′ = x cos x subject to the conditions y(0) = 1 and y(1) = 0.
2. y′′ = x cos x subject to the conditions y′(0) = 0 and y(1) = 0.
3. y′′ + 2y′ = 0 subject to the conditions y(0) = 0 and y(1) = 1.
Task 8.8 Solve the diﬀerential equation
d2y
dt2 + 3y = t
subject to the initial conditions y(0) = y′(0) = 0 both numerically and analyti-
cally over the range t ∈[0, 1].
Task 8.9 Solve the equation
d2y
dt2 + ty = sin t,

290
8. Solving Diﬀerential Equations
for the initial conditions y(0) = 1 and y′(0) = 0 over the range t ∈[0, 2]. Either
using a shooting method or by direct solution solve the same equation subject
to the boundary conditions y(0) = y(2) = 0.
Task 8.10 Solve the ﬁrst-order diﬀerential equation
(t2 + 1)y′ + 2ty = 0,
subject to the initial condition that y(0) = 1 (again both analytically and nu-
merically) over the range t ∈[0, 5].
Task 8.11 (*) Solve the third-order diﬀerential equation
y′′′ −2y′′ −y′ + 2y = 0,
subject to the conditions that y(0) = y′(0) = 0 and y′′(0) = 1, by converting it
to a system of three ﬁrst-order equations.
Task 8.12 (*) Using the methods of ﬁnite diﬀerences determine the viable
values of the eigenvalue λ in the diﬀerential equation
y′′ + (sin x −λ) y = 0,
subject to the homogeneous boundary conditions y(0) = y(π) = 0. Consider
the three eigenfunctions which correspond to the eigenvalues with the smallest
magnitude.

9
Simulations and Random Numbers
9.1 Introduction
We shall use MATLAB to generate random numbers so that we can discuss its
statistical capabilities and also explore some simulations. We also show how it
may be used to analyse sets of data.
We start with a deﬁnition of some statistical quantities.
9.2 Statistical quantities
In this section we consider a set of data which we shall refer to as xi where
i = 1 to N. At this point we shall not make any further assumptions about the
data both in terms of its source or its form.
9.2.1 Averages
Perhaps the most popular choice of average is the mean (which is usually the
arithmetic mean): this is given by adding up all the data and dividing by the
number of objects in the set. This is written as:
¯x = 1
N
N

i=1
xi,

292
9. Simulations and Random Numbers
and can also be denoted as E(X), the expected value of the random variable
X. If we presume that our data is stored in a vector, the MATLAB code to
determine the mean is simply:




xbar = sum(x)/length(x);
In fact, as you might expect, there is a MATLAB command which does exactly
this, namely mean(x).
In fact there are two further averages, the median and the mode. The latter
is the data value which occurs the most often and we shall not discuss this
further. However the median is the value in the “middle” when the data has
been put in order. If there are an odd number of pieces of data this is well
deﬁned: however if it is even then the mean of the data at each end of the
central interval is given, for example the median of (1, 2, 3, 4) is (2 + 3)/2 = 2 1
2
whereas the median of (1, 5, 7) is 5. We note that the median can be equal to
the mean (as it is in the former case) but it is not necessarily so. The median
can be determined using the code:
'
&
$
%
xs = sort(x);
lx = length(x);
if mod(lx,2)==0
median = (xs(lx/2)+xs(lx/2+1))/2;
else
median = xs((lx+1)/2);
end
Alternatively we can use the command median(x).
Example 9.1 Determine the mean and median of the following data:
3, 4, 5, 3, 2, 1, 3, 5, 6, 3, 2, 5, 6, 8, 2, 0.
Although it would be a simple matter to do this by hand we use the code:




x = [3 4 5 3 2 1 3 5 6 3 2 5 6 8 2 0];
mean(x)
median(x)
The mean is 3.625 and the median is 3.

9.2 Statistical quantities
293
9.2.2 Other Statistical Measures
In the previous section we have discussed the various averages of a set of data
but there are more measures available to us, for instance these two distributions
have the same mean but are obviously quite diﬀerent in form:
−6
−4
−2
0
2
4
6
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
−6
−4
−2
0
2
4
6
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
The ﬁrst curve is narrower than the second and this is quantiﬁed using the
variance which is given by
1
N −1
N

i=1
(xi −¯x)2.
We can interpret this as the “mean” of the sum of the squares of the distance
from the mean. This can be written in terms of expectations as E(X2)−E(X)2.
The variance can be determined using the simple code




N = length(x);
xbar = sum(x)/N;
var = sum((x-xbar).ˆ2)/(N-1);
or unsurprisingly using the MATLAB command var(x). Another related mea-
sure is the standard deviation which is merely the square root of the variance
(determined using std(x)). This also is a measure of the width of the distrib-
ution but has the advantage that it has the same units as the data.
Example 9.2 Calculate the variance and standard deviation of the data given
in Example 9.1.
This is done simply by augmenting the above code with the lines




var(x)
std(x)

294
9. Simulations and Random Numbers
There are various other measures, some of which are higher-order moments,
the mean being the ﬁrst, the variance the second, the skewness the third and
the kurtosis the fourth (see Task 9.3).
We note that there are also measures which show how two sets of data might
be related. These are the covariance and correlation. They are deﬁned as:
Deﬁnition 9.1 (Covariance)
This quantity is deﬁned as
σXY = E(XY ) −E(X)E(Y ),
and for a set of data is evaluated using
σXY = 1
n
n

i=1
xiyi −1
n2
n

i=1
xi
n

i=1
yi
= 1
n
n

i=1
(xi −¯x)(yi −¯y).
Note that the variance of a random variable X is merely its covariance with
itself. Here we have used a factor of n rather than n −1 (which is relevant
to the covariance of a sample). The correlation is a measure of two variables’
variability with each other when compared to their own “spread”.
Deﬁnition 9.2 (Correlation)
The correlation of two random variables is deﬁned as
rXY = σXY
σXσY
=
n
i=1
(xi −¯x)(yi −¯y)
%
n
i=1
(xi −¯x)2
n
i=1
(yi −¯y)2
.
The correlation takes values between minus one and plus one.
A correlation of plus one means that the random variables are positively cor-
related, that is Y = aX + b (where a is positive), and similarly for r = −1, in
that they are negatively correlated.

9.3 Random Numbers and Distributions
295
0
2
4
6
8
0
2
4
6
8
10
12
 r= 0.9941
0
2
4
6
8
0
2
4
6
8
10
12
 r= −0.9573
0
2
4
6
8
0
2
4
6
8
10
12
 r= 0.5535
0
2
4
6
8
0
2
4
6
8
10
12
 r= −0.09759
There are MATLAB commands cov and corrcoef. The ﬁrst of these calculates
the covariance between two vectors and returns a matrix including the variances
so that cov(x,y) returns

σX
σXY
σY X
σY

and similarly the correlation command corrcoef(x,y) gives

1
rXY
rY X
1

.
The elements along the diagonal merely show that a random variable is corre-
lated with itself (unsurprisingly!).
9.3 Random Numbers and Distributions
In order to generate random numbers we can use the various commands avail-
able within MATLAB. We shall not worry about how this is done and the
technical aspects of the seeding. It is possible to get similar results from a pro-
gram by always getting it to use the same set of random numbers but we will
discourage this.
We shall start with the simple command rand which returns a random
number between zero and one. Let us start with a simple dice program

296
9. Simulations and Random Numbers
#
"
 
!
%
% roll.m
%
function [number] = roll()
number = ceil(rand*6+eps);
which is called using
'
&
$
%
%
% mroll.m
%
for ii = 1:6000
rr(ii) = roll;
end
for j = 1:6
ii(j) = length(find(rr==j));
end
disp([’ Mean ’ num2str(mean(rr))])
We include eps in case the value of the random number is zero, which is im-
probable but possible.
This prints the mean of the sample which is deﬁned as
¯x = 1
N
N

i=1
xi,
which should be given by 7/2, derived from
Noutcomes

i=1
ip(i)
=
1
61 + 1
62 + · · · + 1
66
=
1
6 (1 + 2 + 3 + 4 + 5 + 6) = 21
6 = 31
2.
We can also determine the sample variance as
var =
1
N −1
N

i=1
(xi −¯x)2 ,

9.3 Random Numbers and Distributions
297
and this can be determined for this case as
x2 −¯x2 =
6

i=1
i2p(i) −¯x2
= 1
6
6

i=1
i2 −49
4
= 91
6 −49
4 = 35
12 ≈2.9167.
It also gives the distribution of the values in the array which can be plotted
using bar(ii) to give
1
2
3
4
5
6
0
200
400
600
800
1000
1200
If we wanted the above experiment to investigate the eﬀect of using two dice,
we could modify the line within the for loop to read rr(ii) = roll+roll;
which yields the plot
1
2
3
4
5
6
7
8
9
10
11
12
0
100
200
300
400
500
600
700
800
900
1000
Example 9.3 We can use this process for other “games”, for instance tossing
a coin:

298
9. Simulations and Random Numbers




function [out] = toss()
A = [’heads’;’tails’];
i = ceil(rand*2+eps);
out = A(i,:);
This can then be called just using toss which generates either heads or tails.
There are various other experiments we could try to analyse but let us
discuss other random number generators, or at least variants of the above.
9.3.1 Normal Distribution
The normal distribution has two parameters associated with it: the mean
and the variance. The MATLAB command randn generates random numbers
which have a mean of zero and a variance of unity. We use the command x =
randn(1,500); to set up the array and the command hist(x,12) to produce
the plot
−4
−3
−2
−1
0
1
2
3
0
20
40
60
80
100
120
We can now use the commands mean and var to analyse how close to the
advertised values the random number generator achieves. This gives
>> mean(x)
ans =
0.0702
>> var(x)
ans =

9.3 Random Numbers and Distributions
299
0.9873
Usually we would have the data from an “experiment” but here we shall
generate it from the internal generator.
Example 9.4 Consider the distribution of salaries with mean of £20000 and
standard deviation of £3000. How many people would you expect to have
salaries in excess of £22000 in a group of 200 people?
We use the code
'
&
$
%
no_experiments = 200;
for ii = 1:no_experiments
x = randn(1,200);
salaries = x*3000+20000;
number(ii) = length(find(salaries>22000));
end
mean(number)
which gave mean(number)=50.94, and if it is repeated similar values are ob-
tained. It is possible to determine this value from tables.
9.3.2 Calculating Probabilities
We note that the probability that a random variable X is less than a value z,
where the random variable is known to be distributed normally with mean µ
and variance σ2, and can be written as
P(X ⩽z) =
1
σ
√
2π
z
"
q=−∞
e−1
2( q−µ
σ )
2
dq.
Of course we can calculate this quantity using MATLAB (relatively easily).

300
9. Simulations and Random Numbers
'
&
$
%
mu = 0.2;
sig = 1.5;
min_inf = -6*sig;
z = input(’Enter z: ’);
clear x n
x = linspace(min_inf,z,1000);
n = length(x);
h = x(2)-x(1);
f = exp(-((x-mu)/sig).ˆ2/2);
val = (sum(f)-f(1)/2-f(n)/2)*h;
prob = val/sqrt(2*pi)/sig
In this code we have used the trapezium rule and the fact that the rate at
which the integrand decays to zero is proportional to σ (and as such we set the
lower end of the range of integration as −6σ). We can use this code to work
out conﬁdence intervals.
9.3.3 Permutations
MATLAB has many other commands for this kind of operation but it also
provides other devices which can be used for randomisation of lists.
Example 9.5 Let us suppose that we wish to produce a random ordering of
the ﬁve names: Avril, Beryl, Carol, Daisy and Emily.




a = [’Avril’; ’Beryl’; ’Carol’; ’Daisy’; ’Emily’];
r = randperm(5);
a(r,:)
9.4 Maps and White Noise
We have already met incidences of maps (for instance page 91) and these can
be described as taking a value xn and returning the next iterate. They can be
written in a variety of ways but here we shall use the nomenclature:
xn+1 = f(xn)

9.4 Maps and White Noise
301
for a one-dimensional map. A ﬁxed point of the map is deﬁned to be xn = f(xn).
We can also consider repetitions of the map, for instance f(f(xn)) where f( . )
operates on xn+1. This is written as f 2(xn) and the mth iterate of the map
would be written as f m( . ). In the case where f m(x∗) = x∗we say that x∗is a
ﬁxed point of period m and the sequence of points {x∗, f(x∗), · · · , f m−1(x∗)}
is the corresponding orbit.
Example 9.6 (Tent Map) We deﬁne the Tent map as f : R →R where
f(x) =

ax
x ⩽1
2,
a(1 −x)
x > 1
2.
This can be rewritten as
f(x) = a
1
2 −




x −1
2





,
which is more convenient for use in MATLAB. We now use the code




function [out] = tent(a,x)
out = a*(0.5-abs(0.5-x));
If we plot the results of using a = 4:




x = linspace(-1,2);
plot(x,tent(4,x))
h = gca;
set(h,’YGrid’,’On’)
we have

302
9. Simulations and Random Numbers
−1
−0.5
0
0.5
1
1.5
2
−4
−3
−2
−1
0
1
2
and producing the second iterate (y = tent(4,x); plot(x,tent(4,y)) we
have
−1
−0.5
0
0.5
1
1.5
2
−16
−14
−12
−10
−8
−6
−4
−2
0
2
In fact most points will be expelled to minus inﬁnity, but some points will re-
main. These are the ﬁxed points. For instance points of period two will lie on
the intersection of the lines shown in the previous ﬁgure and the line y = x.
This is a very rich topic for further investigation.

9.4 Maps and White Noise
303
We shall return to one-dimensional maps, but shall start by deriving a
simple two-dimensional map, which is written as
xn+1 = f(xn, yn),
yn+1 = g(xn, yn).
This is a two-dimensional explicit map and can be used to simulate various
behaviours depending on the forms of f and g. We shall start with the simple
example of
˙x = y,
˙y = −x,
where a dot denotes the derivative with respect to time. We shall use the
Crank–Nicolson method to discretise this system and denote the values at the
nth time level by the subscript n. The system becomes
xn+1 −xn
∆t
=
yn + yn+1
2
,
yn+1 −yn
∆t
=
−xn + xn+1
2
.
We can write this as the matrix system

1
−∆t
2
∆t
2
1
  xn+1
yn+1

=
 xn + ∆t
2 yn
yn −∆t
2 xn

.
This can now be solved to yield the next point. Before we give the code for this
purpose we solve the system analytically. Multiply the ﬁrst equation by x and
the second by y and then add them to obtain
x ˙x + y ˙y = 0
which can be written as
1
2
d
dt

x2 + y2
= 0.
This can be integrated to give x2 + y2 = C, which are circles of radius
√
C.
Hence the initial conditions will give the value of C and then the points should
transcribe a circle. Notice if we use an Euler scheme the inaccuracies in the
method soon become evident. However, using the following codes we can track
a point.
'
&
$
%
%
% maps.m
%
function [f,g]=maps(x,y)
global delt
A = [ 1 -delt/2; delt/2 1];
rhs = [x+delt/2*y; -delt/2*x+y];
v = A\rhs;
f = v(1);
g = v(2);

304
9. Simulations and Random Numbers
and'
&
$
%
%
% crmap.m
%
global delt
delt = 0.05;
x = 0.5; y = 0.4;
noise = 0.0;
nop = 500;
po(1) = x+i*y;
for it = 2:nop
[xn,yn] = maps(x,y);
xn = xn+ ...
noise*sqrt(-2*log(rand(1)))*cos(2*pi*rand(1));
yn = yn+ ...
noise*sqrt(-2*log(rand(1)))*sin(2*pi*rand(1));
po(it) = xn+i*yn;
x = xn; y = yn;
end
plot(po,’.’)
axis equal
This gives the result:
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6

9.4 Maps and White Noise
305
where we have used the array po as being complex. Hence it can be plotted in a
straightforward manner using plot. The radius of the circle is
√
0.42 + 0.52 ∼
0.6403 (and this can be veriﬁed by typing max(real(po))). In the above code
we have introduced some noise (at the moment it is set to have an amplitude of
zero). This is two-dimensional Gaussian noise and its eﬀect is to add diﬀusion
to the system. With noise=0.01 we have:
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
We could look at the noise purely in isolation. Here we consider a random walk
using the simple code:
'
&
$
%
x= 0.0; y= 0.0;
noise = 0.05;
nop = 50;
po(1) = x+i*y;
for it = 2:nop
y = y+noise*(rand(1)-0.5);
x = x+0.1;
po(it) = x+i*y;
end
plot(po)
which yields

306
9. Simulations and Random Numbers
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
0
0.05
0.1
0.15
0.2
0.25
The above is a very simple map derived from the Crank–Nicolson scheme
and does not exhibit any strange (that is chaotic) behaviour, but we could try
the map
xn+1 = (xn + yn)|1,
yn+1 = (xn + 2yn)|1,
which gives
0
0.2
0.4
0.6
0.8
1
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9

9.4 Maps and White Noise
307
This plot is given with no noise as the map (which is called the Baker map
(Drazin Nonlinear Systems)) is chaotic. This was coded using the MATLAB
command rem so that the map part of the code is given by




% mapb.m
function [f,g] = mapb(x,y)
f = rem(x+y,1);
g = rem(x+2*y,1);
The function rem gives the remainder when dividing the ﬁrst argument by the
second.
9.4.1 Modelling Discrete Systems
There are many problems which require simulation: this is largely because
it is not viable to actually run the physical tests. This covers things from
experiments on aircrafts (which are too dangerous or expensive) to population
studies and economic strategies.
We consider the example of two populations N and P. The evolution of
these co-existing populations are governed by the diﬀerence equations:
Nt+1 = rNte−aPt
Pt+1 = Nt

1 −e−aPt
.
This is an example of a predator–prey model.
This is solved simply using the code

308
9. Simulations and Random Numbers
'
&
$
%
r = 2;
a = 1;
nt = 20;
t = 1:1:nt;
N = zeros(size(t));
P = zeros(size(t));
N(1) = r*log(r)/(a*(r-1))+0.01;
P(1) = log(r)/a;
for j = 1:(nt-1)
N(j+1) = r*N(j)*exp(-a*P(j));
P(j+1) = N(j)*(1-exp(-a*P(j)));
end
subplot(2,1,1)
plot(t,N,’o’,’MarkerSize’,12)
title(’N values’)
subplot(2,1,2)
plot(t,P,’r+’,’MarkerSize’,12)
title(’P values’)
In this code we have used the MATLAB command subplot which allows more
than one graph to be added to a ﬁgure. The arguments are: the number of
rows, the number of columns and the position within that system. For instance
subplot(2,3,5) has two rows and three columns and makes the second ﬁgure
on the second row the current ﬁgure. The ﬁgures are numbered across the rows,
so that “1” is top left and “6” is bottom right.
The above calculation yields

9.4 Maps and White Noise
309
0
2
4
6
8
10
12
14
16
18
20
1.3
1.35
1.4
1.45
1.5
1.55
N values
0
2
4
6
8
10
12
14
16
18
20
0.6
0.65
0.7
0.75
0.8
0.85
P values
We observe that by changing the values of the equilibrium amplitudes slightly,
the populations start to oscillate and eventually diverge from the values we
start with. This would seem to suggest that this equilibrium is unstable.
9.4.2 Periodicity and Chaos
Here we discuss one of the most famous models of populations, which has an
incredibly rich structure. Consider
Nt+1 = Nt + rNt(1 −Nt).
This diﬀerence equation has very diﬀerent solutions depending on the values
of r. The new population Nt+1 is taken to be the old population Nt plus a
term which is proportional to the term Nt(1 −Nt), where unity is taken to
be the optimal population. Notice that if Nt > 1 then the second term in this
expression is negative, and the new population is reduced. This is supposed
to represent the idea of ﬁnite resources. This model was posed by Verhulst
and it is related to the logistic model. In the main we shall consider an initial
population corresponding to N = 1/10.

310
9. Simulations and Random Numbers
'
&
$
%
str = ’Please enter the ’;
r = input([str ’rate constant r :’]);
N0 = input([str ’initial population N(0) :’]);
n = input([str ’number of years n :’]);
t = 1:1:n;
N = zeros(size(t));
N(1) = N0;
for j = 1:(n-1)
N(j+1) = N(j) + r*N(j)*(1-N(j));
end
plot(t-1,N,’*’,’MarkerSize’,10)
This gives
N =
Columns 1 through 7
0.1000
0.1900
0.3439
0.5695
0.8147
0.9657
0.9988
Columns 8 through 10
1.0000
1.0000
1.0000
and as observed in the other notes the population tends to unity, whereas
when the rate constant r = 2.1 we ﬁnd that
N =
Columns 1 through 7
0.1000
0.2890
0.7205
1.1434
0.7991
1.1362
0.8112
Columns 8 through 10
1.1328
0.8168
1.1310
So after an initial period the population tends to oscillate between two
values, which can be seen by extending the simulation to 100 years

9.4 Maps and White Noise
311
0
10
20
30
40
50
60
70
80
90
100
0
0.2
0.4
0.6
0.8
1
1.2
1.4
Increasing the value of r further leads to higher-order periodicity, for instance
r = 2.5 gives
0
10
20
30
40
50
60
70
80
90
100
0
0.2
0.4
0.6
0.8
1
1.2
1.4
which is a period four structure. Increasing it further produces structures which
don’t seem to possess any periodic structures, for instance r = 2.8 gives

312
9. Simulations and Random Numbers
0
10
20
30
40
50
60
70
80
90
100
0
0.2
0.4
0.6
0.8
1
1.2
1.4
This has changed into a chaotic orbit: for further details refer to Drazin’s book
on Nonlinear systems or any popular science book on Chaos, for instance the
book by Gleick.
We pause here and determine analytical results for certain values of the
rate constant r. Firstly we determine the ﬁxed point in which case Nt+1 = Nt
and using the equation for Nt+1 we ﬁnd that Nt equals zero and one are ﬁxed
points (independent of the choice of r). If we seek points of period two, we
require Nt+2 = Nt so that we have the coupled equations
Nt+1 = Nt + rNt(1 −Nt)
Nt = Nt+1 + rNt+1(1 −Nt+1).
These can be combined to form a single quartic
0 = Nt(1 −Nt) {1 + (1 + r(1 −Nt)) (1 −Ntr)} ,
where we have extracted factors of Nt and (1 −Nt) since we know that the
ﬁxed points must also be solutions. The remaining quadratic has solutions
Nt = r + 2 ±
√
r2 −4
2r
.
This second pair of solutions is only real provided r is greater than or equal to
two, and the system undergoes what we call a bifurcation. In fact at a higher
value of r period four solutions come into existence and this phenomena is called
period doubling. For the case r = 2.1 we ﬁnd that the two points correspond
approximately to 1.1286 and 0.8237.

9.4 Maps and White Noise
313
As we see we can determine the values of the points within the orbit ana-
lytically (sometimes): however here we present a method for ﬁnding the values
numerically using the Newton–Raphson method. Firstly we include a routine
which returns the image of the point after n iterations of the map:
'
&
$
%
% maplog
function [new] = maplog(old,r,n)
for j=1:n
new = old+r*old*(1-old);
old = new;
end
and this is called from the main routine mapsearch which is
'
&
$
%
r = input(’Please enter the value of r :’);
starting_guess = input(’Please enter starting guess ’);
ms = ’Please enter the period of the orbit sought ’
period = input(ms);
maxits = 200;
tolerance = 1e-10;
delta = 1e-4;
x = starting_guess;
for its = 1:maxits
err = maplog(x,r,period)-x;
if abs(err)<tolerance
break
end
err_dx = maplog(x+delta,r,period)-(x+delta);
x = x - delta*err/(err_dx-err);
end
if its==maxits
disp([’No period ’ int2str(period) ’ point found ’])
else
disp(’Orbit’)
for j = 1:period
disp(x)
x = maplog(x,r,1);
end
end
The results of which for the two cases above are:

314
9. Simulations and Random Numbers
>> mapsearch
Please enter the value of r :2.1
Please enter starting guess 0.82
Please enter the period of the orbit sought 2
Orbit
0.8237
1.1286
>> mapsearch
Please enter the value of r :2.5
Please enter starting guess 0.58
Please enter the period of the orbit sought 4
Orbit
0.6000
1.2000
0.6000
1.2000
>> mapsearch
Please enter the value of r :2.5
Please enter starting guess 0.52
Please enter the period of the orbit sought 4
Orbit
0.5359
1.1577
0.7012
1.2250
Notice in the second case the program actually generated a period 2 point, and
so an alternative initial guess was required.
We can actually plot a diagram of the ﬁxed points of this map using

9.4 Maps and White Noise
315
'
&
$
%
clf
for r = 0:0.01:4;
x = rand(1);
% Remove transients
for j = 1:100
x = x+r*x*(1-x);
end
xout = [];
for j = 1:400
x = x+r*x*(1-x);
xout = [xout x];
end
plot(r*ones(size(xout)),xout,’.’,’MarkerSize’,3)
hold on
end
axis([0 4 0 1])
This gives:
0
0.5
1
1.5
2
2.5
3
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
and zooming in

316
9. Simulations and Random Numbers
2.2
2.3
2.4
2.5
2.6
2.7
2.8
2.9
0.4
0.45
0.5
0.55
0.6
9.4.3 Random Motion
Let us now consider a particle in a box and ask the question of how likely it is
to hit the east wall. We assume that the western wall repels the particles and
that there is no vertical motion. In this case the position at a subsequent time
is related to the current position by
xt+1 = xt + f(xt) + Noise,
where f(x) = k/x2 so that the force away from the western wall at x = 0 is
proportional to the inverse of the distance squared. The noise is given by ϵ
times a random number between minus one and one. The eastern wall is taken
to be at x = 5 and the constant of proportionality for the repulsive force is
k = 0.5, with a noise amplitude of 1.

9.4 Maps and White Noise
317
'
&
$
%
x0 = 2.5;
noise = 1.;
east_wall = 5;
k = 0.5;
no_experiments = 200;
for j = 1:no_experiments
x = x0;
steps = 0;
while x<east_wall
steps=steps+1;
x = x + k./xˆ2 + noise*(rand(1)-0.5)*2;
end
st_store(j) = steps;
end
The result of one simulation is given as
0
10
20
30
40
50
60
70
80
90
100
2
3
4
5
6
7
8
9
10
11
12
Running the code for two hundred experiments yields these results:

318
9. Simulations and Random Numbers
0
20
40
60
80
100
120
140
160
180
200
0
20
40
60
80
100
120
We can use the MATLAB commands mean and std to extract statistical in-
formation from the experiments. But perhaps the most helpful command is
hist(st store) which yields:
0
20
40
60
80
100
120
0
10
20
30
40
50
60
70
This shows how many of the runs took for instance above 100 steps to reach
the eastern wall.

9.5 Tasks
319
9.5 Tasks
Task 9.1 Enter the data
X = {3, 2, 4, 5, 6, −1, 5, 6, 7, 8, 2}
Y = {2, −6, 3, 2, 0, 1, 4, 5, 6, 7, 8}
and calculate the means and medians of both distributions, their variances and
the covariance and correlation.
Task 9.2 Show that the correlation r of two random variables who are related
by the relation Y = aX + b is given by sign(a).
Task 9.3 (*) A distribution can be quantiﬁed by higher-order moments. Write
a code to calculate the skewness and the kurtosis, deﬁned as
1
n
n

i=1
xi −¯x
σx
3
and
1
n
n

i=1
xi −¯x
σx
4
−3,
respectively. These represent the level of symmetry and sharpness of the distri-
bution.
We now revisit the topic of maps. We shall start with a one-dimensional
map f : R →R (which is read as: takes a real number and returns another
one). We shall write the map as
xn+1 = f(xn, µ)
n ∈Z,
where xn is the current value, xn+1 is the next one and µ is a parameter.
We have also restricted the values of n to be integers. In general we will only
consider natural numbers: however you should be aware that these maps can
go backwards. The parameter µ can be passed through as an argument to the
routine, map(xn,mu); or as a global variable (this is preferable if the value is
unlikely to change). The codes we will use for this are:




function [xn] = map(xo)
global mu
xn = mu*xo*(1-xo);
in conjunction with

320
9. Simulations and Random Numbers




global mu
mu = 0.4;
xold = 0.25;
xnew = map(xold);
This example has been given for the map xn+1 = f(xn, µ) = µxn(1 −xn). The
command global allows the program to know the value of variables globally.
Any routine which is going to use (or set) a parameter must contain this state-
ment. In the above example the variable is declared as global in main.m and
then set, and when the routine map.m is run and the command global mu is
found it sets mu to be the value set within the main program.
Task 9.4 Rewrite the code main.m to evaluate the map nine times and hence
starting from x1 = 0.25 determine x10.
The ﬁxed points of this map are where xnew is equal to xold and are given
by solutions of
x = µx(1 −x)
=⇒x = 0 or x = 1 −1
µ.
Sometimes we are interested in longer cycles, for instance period 2 points which
are such that xn+2 = xn, where
xn+1 = µxn(1 −xn)
(9.1)
xn+2 = µxn+1(1 −xn+1).
(9.2)
We can substitute xn+1 from (9.1) into (9.2) to give
xn = µ2xn(1 −xn)(1 −µxn(1 −xn)),
which can be manipulated to give the quartic
0 = −µ3x4
n + 2µ3x3
n −µ2(1 + µ)x2
n + (µ2 −1)xn.
We can ﬁnd the roots of this using MATLAB code:




mu = 0.4;
co = [-muˆ3 2*muˆ3 -muˆ2*(1+mu) (muˆ2-1) 0];
[r] = roots(co);
Unfortunately this quartic only has two real roots, which are in fact the
points for which xn = xn+1 (i.e. x = 0 and x = 1 −1/µ). There are values of
µ for which there are real period 2 cycles.

9.5 Tasks
321
Task 9.5 By experimenting with the value of mu in the above code identify a
value for which there is a real period 2 cycle and then show that the points occur
in pairs using the code map.m.
In order to ﬁnd roots of higher order it is obviously impractical to perform
this manipulation; we can use a root ﬁnding technique associated with the
function
xn −f m(xn, µ)
where the m denotes that the map has been applied m times. The zeros of this
function occur at the points of period m.
We can also use these maps in higher dimensions f : R2 →R2 (which takes
two real values and returns two further values).
Let us consider the example
xn+1 = xn + sin(xn + yn)
yn+1 = cos(xn −yn).
We can evaluate the map using the code:




function [xn,yn] = map2(xo,yo)
xn = xo+sin(xo+yo);
yn = cos(xo-yo);
in conjunction with
#
"
 
!
x(1) = 0.2;
y(1) = 0.4;
for i = 2:20
[x(i),y(i)] = map2(x(i-1),y(i-1));
end
Task 9.6 Change the above code to evaluate the ﬁrst 20 images of the points
(1/2, 1/3) and (1/5, 1/5) under the inﬂuence of the map
xn+1 = (xn + 2yn)|1,
yn+1 = (3xn −2yn)|1.
Task 9.7 Consider the H´enon map,
xn+1 =xn cos θ −yn sin θ + x2
n sin θ,
yn+1 =xn sin θ + yn cos θ −x2
n cos θ.

322
9. Simulations and Random Numbers
for a variety of values of θ using the code:
'
&
$
%
cosa = 0.34;
sina = sqrt(1-cosaˆ2);
ii = 0;
for st = -0.5:0.05:0.5
x = st; y = st;
for its = 1:1000
ii = ii+1;
xn = cosa*x-sina*y+xˆ2*sina;
yn = sina*x+cosa*y-xˆ2*cosa;
x = xn; y = yn;
po(ii) = x+i*y;
if or(abs(x)>10 ,abs(y)>10)
break
end
end
end
plot(po,’.’,’MarkerSize’,4)
axis equal
axis([-1 1 -1 1])
This code sets up an initial rake of points running from (−0.5, −0.5) to
(0.5, 0.5). Try using the zoom command to see the details.

A
A Mathematical Introduction to Matrices
Matrices are objects which have special properties and there are a number of
rules which must be adhered to in order to manipulate them in a consistent
(and correct) manner. A matrix can most readily be deﬁned as an n × m array
of numbers which is comprised of n rows and m columns. For example, a two-
by-one matrix (two rows and one column) has the general form
 a
b

whereas a three-by-two matrix (three rows and two columns) has the general
form
⎛
⎝
a
b
c
d
e
f
⎞
⎠.
In these examples a, b, . . . , f may be real or complex numbers. To refer to
individual elements of the matrix we use the notation ai,j to denote the element
in the ith row and the jth column. Using this notation the three-by-two example
could be written in the general form
⎛
⎝
a1,1
a1,2
a2,1
a2,2
a3,1
a3,2
⎞
⎠.
Matrices for which n = m (so that the number of rows equal the number of
columns) are referred to as square matrices. If m = 1 then the matrix is simply
a column vector (as in the ﬁrst example above). If n = 1 (the matrix has only

324
A. A Mathematical Introduction to Matrices
one row) then we refer to it as a row vector. A scalar is simply a matrix in which
both n and m are equal to one (that is, a one-by-one matrix). Throughout this
text we will adopt the universal convection that both vectors and matrices are
denoted by a bold font1. In general we shall use upper-case letters to denote
matrices and lower-case for vectors.
Example A.1 We show the rows and columns of a general three-by-three ma-
trix.
– First row
⎛
⎜
⎝
a
b
c
d
e
f
g
h
i
⎞
⎟
⎠
– Second row
⎛
⎜
⎝
a
b
c
d
e
f
g
h
i
⎞
⎟
⎠
– Third row
⎛
⎜
⎝
a
b
c
d
e
f
g
h
i
⎞
⎟
⎠
– First column
⎛
⎝
a
b
c
d
e
f
g
h
i
⎞
⎠
– Second column
⎛
⎝
a
b
c
d
e
f
g
h
i
⎞
⎠
– Third column
⎛
⎝
a
b
c
d
e
f
g
h
i
⎞
⎠
1 Of course, other notations do exist. For example, many textbooks employ the
notation of a single underbar for vectors x and a double underbar for matrices A.

A. A Mathematical Introduction to Matrices
325
Of all the operations which can be performed on matrices one of the simplest
is that of transposition (or taking the transpose of a matrix); this operation is
usually denoted by a subscript T or a prime ′. If A is n-by-m then B = AT is
m-by-n, where the elements of B are deﬁned by
bj,i = ai,j
i = 1, · · · , n;
j = 1, · · · , m;
the transpose is thus obtained by interchanging the rows and columns of matrix
A to give the matrix B = AT . If the matrix A is square then the operation
of taking the transpose is equivalent to a reﬂection in the leading diagonal
(which runs from the top left corner to the bottom right). Matrices for which
AT = A are referred to as symmetric and those for which AT = −A are anti-
symmetric2. In the case of three-by-three matrices the general symmetric and
anti-symmetric three-by-three matrices can be written as
Asymm =
⎛
⎝
a
b
c
b
d
e
c
e
f
⎞
⎠and Aanti =
⎛
⎝
0
b
c
−b
0
e
−c
−e
0
⎞
⎠.
where a, b, . . . , f ∈C. We remark that if the complex conjugate transpose of a
matrix (with elements a∗
j,i) is equal to the matrix then it is called Hermitian
and if it is equal to minus its complex conjugate transpose then it is referred
to as skew Hermitian.
We pause here to state that A = B implies that ai,j = bi,j for all the
elements of the matrices, whereas A ̸= B only requires that ai,j ̸= bi,j for one
pair (i, j).
Example A.2 Determine the transposes of the following matrices:

1
4
7
−4
−3
4

,

4
2
3

,
⎛
⎝
1
2
3
2
0
2
3
2
3
⎞
⎠.
The solutions are
⎛
⎝
1
−4
4
−3
7
4
⎞
⎠,
⎛
⎝
4
2
3
⎞
⎠,
⎛
⎝
1
2
3
2
0
2
3
2
3
⎞
⎠.
Notice elements on the leading diagonal, that is elements of the form ai,i, re-
main unchanged by transposition. In the ﬁnal example the transpose is equal to
the original matrix and therefore the matrix is symmetric.
2 Note that the diagonal elements of anti-symmetric matrices must be equal to zero.
This can be seen by setting i = j in the relation ai,j = −aj,i, which is only true if
ai,i = 0).

326
A. A Mathematical Introduction to Matrices
The usual arithmetic operations of addition, subtraction and multiplication
also apply to matrices. However, there are now several additional rules (or
constraints) under which these operations can be performed on two (or more)
matrices. These are outlined below.
Addition and subtraction: two matrices can only be added together if they are
the same size (that is, they have the same number of rows and the same
number of columns). In this case the operation of addition is performed
element by element. For example, if A, B are both n-by-m matrices then
C = A + B is deﬁned as the matrix with elements ci,j = ai,j + bi,j. A
similar rule holds for subtraction.
Scalar multiplication: matrices of any size can be multiplied by scalars. The
multiplication is performed element by element so that C = λA where
ci,j = λai,j.
Matrix multiplication: in order to multiply two matrices A and B together the
number of columns of A must equal the number of rows of B. To perform
the multiplication we “multiply” the ﬁrst row of A by the ﬁrst column of
B, multiplying the ﬁrst element of each together and then the second ones,
etc, and ﬁnally adding up all the results. This gives the element in the top
left hand corner. We then proceed to multiply the ﬁrst row by the second
column in the same manner (and put the result in the ﬁrst row, second
column). Mathematically this can be written as
ci,j =
m

k=1
ai,kbk,j
i = 1, · · · , n;
j = 1, · · · , p,
where A is n-by-m and B is m-by-p. Then the answer C is n-by-p.
This rule for matrix multiplication highlights one of their important proper-
ties, namely that the order of multiplication is important. In this example,
with A an n-by-m matrix and B an m-by-p matrix, the operation “A times
B” is deﬁned. However, the operation “B times A” (that is, pre-multiplying
matrix A by matrix B) is not deﬁned unless p = n. Even if p = n, in gen-
eral AB ̸= BA. This is equivalent to saying that, unlike scalar multiplication,
matrix multiplication is not commutative.
Example A.3 We demonstrate these concepts by an example involving two
two-by-two matrices, namely
A =
 a
b
c
d

and B =
 α
β
γ
δ

.

A. A Mathematical Introduction to Matrices
327
The sum C = A + B is determined as follows. Firstly the element c1,1 is
obtained by adding the corresponding elements in A and B, so that

a
b
c
d

+

α
β
γ
δ

=

a + α

.
Now for the c1,2 entry (the top right element):

a
b
c
d

+

α
β
γ
δ

=

a + α
b + β

.
Similarly for c2,1 (the bottom left element)
 a
b
c
d

+

α
β
γ
δ

=

a + α
b + β
c + γ

and ﬁnally for c2,2 (the bottom right element) we have

a
b
c
d

+

α
β
γ
δ

=

a + α
b + β
c + γ
d + δ

.
Example A.4 An example of multiplication of two two-by-two matrices will
serve to highlight the diﬀerences between addition and multiplication of matri-
ces. Consider the matrices
A =
 a
b
c
d

and B =
 α
β
γ
δ

.
By our earlier rule the product C = AB is deﬁned and is determined as follows.
We start with the top left entry, namely c1,1 (formed by multiplying the ﬁrst
row of A by the ﬁrst column of B)

a
b
c
d
  α
β
γ
δ

=

a × α + b × γ

;
now the top right entry, namely c1,2 (which is formed by multiplying the ﬁrst
row of A by the second column of B)

a
b
c
d
  α
β
γ
δ

=

a × α + b × γ
a × β + b × δ

;

328
A. A Mathematical Introduction to Matrices
next the bottom left entry, namely c2,1 (which is formed by multiplying the
second row of A by the ﬁrst column of B)

a
b
c
d
  α
β
γ
δ

=

a × α + b × γ
a × β + b × δ
c × α + d × γ

;
and ﬁnally the bottom right entry, namely c2,2 (which is formed by multiplying
the second row of A by the second column of B)

a
b
c
d
  α
β
γ
δ

=

a × α + b × γ
a × β + b × δ
c × α + d × γ
c × β + d × δ

.
In general, to calculate the ci,j entry we multiply the ith row of the ﬁrst matrix
A by the jth column of the second matrix B term by term.
Example A.5 Calculate the product AB of the matrices
A =
 1
−1
0
3

and B =
 −2
1
4
−2

.
Using the method given in the previous example
AB =
 1
−1
0
3
  −2
1
4
−2

=
 1 × (−2) + (−1) × 4
1 × 1 + (−1) × (−2)
0 × (−2) + 3 × (4)
0 × 1 + 3 × (−2)

=
 −6
3
12
−6

.
(It is worth practising these calculations; try calculating the product BA your-
self by hand.).
We now turn our attention to matrix multiplication in which the matrices are
not necessarily square.
Example A.6 Consider the matrices
A =

3
0
−1
−4
2
2

,
B =
⎛
⎝
−1
7
3
5
−2
0
⎞
⎠and C =

2
0
−1
−3

.

A. A Mathematical Introduction to Matrices
329
Calculate the quantities: AB, BA, A+BT , AC, AT C, 3C+2(AB)T , (AB) C
and ﬁnally A (BC), where possible (and if not, state the reason why the calcu-
lations cannot be performed).
We shall start (for the ﬁrst couple of examples) by providing full solutions
and thereafter just give answers with a minimum of intermediate steps. So,
AB =

3
0
−1
−4
2
2
 ⎛
⎝
−1
7
3
5
−2
0
⎞
⎠
=
 3 × (−1) + 0 × 3 + (−1) × (−2)
3 × 7 + 0 × 5 + (−1) × (0)
(−4) × (−1) + 2 × 3 + 2 × (−2)
(−4) × 7 + 2 × 5 + 2 × (0)

=
 −1
21
6
−18

.
Similarly
BA =
⎛
⎝
−1
7
3
5
−2
0
⎞
⎠

3
0
−1
−4
2
2

=
⎛
⎝
−1 × 3 + 7 × (−4)
−1 × 0 + 7 × 2
−1 × (−1) + 7 × 2
3 × 3 + 5 × (−4)
3 × 0 + 5 × 2
3 × (−1) + 5 × 2
−2 × 3 + 0 × (−4)
−2 × 0 + 0 × 2
−2 × (−1) + 0 × 2
⎞
⎠
=
⎛
⎝
−31
14
15
−11
10
7
−6
0
2
⎞
⎠
A + BT =

3
0
−1
−4
2
2

+
 −1
3
−2
7
5
0

=
 2
3
−3
3
7
2

.
It is not possible to pre-multiply matrix A by C since A is two-by-three and C is
two-by-two, so the inner dimensions do not agree (that is, the second dimension
of the ﬁrst matrix and the ﬁrst dimension of the second matrix are diﬀerent).
For the next example AT C we observe that AT is three-by-two so that the inner
dimensions agree and hence the calculation is possible. We obtain
AT C =
⎛
⎝
3
−4
0
2
−1
2
⎞
⎠

2
0
−1
−3

=
⎛
⎝
10
12
−2
−6
−4
−6
⎞
⎠.

330
A. A Mathematical Introduction to Matrices
The next example requires scalar multiplication and the use of the ﬁrst of the
results in this example; we have
3C + 2 (AB)T = 3

2
0
−1
−3

+ 2
 −1
6
21
−18

,
=

6
0
−3
−9

+
 −2
12
42
−36

,
=

4
12
39
−45

.
The ﬁnal two calculations serve to demonstrate that matrix multiplication is
associative, that is for three matrices A, B and C, A(BC) = (AB)C. (Notice
that this does not constitute a formal proof.)
(AB) C =
 −1
21
6
18
 
2
0
−1
−3

=
 −23
−63
26
54

.
And now the ﬁnal example
A (BC) =

3
0
−1
−4
2
2
 ⎧
⎨
⎩
⎛
⎝
−1
7
3
5
−2
0
⎞
⎠

2
0
−1
−3
⎫
⎬
⎭
=

3
0
−1
−4
2
2
 ⎛
⎝
−9
−21
1
−15
−4
0
⎞
⎠=
 −23
−63
26
54

.
In this example we see that the result of the multiplication BA is a three-
by-three matrix, further emphasising the fact that AB is not necessarily equal
to BA. In some cases it may not even be possible to perform this second mul-
tiplication. This example serves to demonstrate that matrix multiplication is
associative (that is A(BC) ≡(AB)C), but it is not, in general, commutative.
It is also a simple matter to show that matrix multiplication is distributive, that
is A(B + C) = AB + AC for any three matrices A, B and C for which the
matrix multiplications are permitted.
A.1 Special Matrices
There are two special matrices that we will make use of often within the text and
we introduce them here. The ﬁrst is the zero matrix, which we will denote by 0.

A.2 Inverses of Matrices
331
This is simply a matrix whose elements are all equal to zero3. Not surprisingly,
the zero matrix has no eﬀect when it is added to another matrix (of the same
size). So A + 0 = A = 0 + A. We will make use of this matrix to initialise
matrices in preparation to assigning answers to a matrix.
The second important matrix we will have call to use often with the text is
the identity (or unit) matrix, denoted by I. The identity matrix I is a n-by-n
matrix whose elements consist of 1s (ones) along the main diagonal and are
zero everywhere else. For example, the three-by-three identity matrix is given
by
I =
⎛
⎝
1
0
0
0
1
0
0
0
1
⎞
⎠.
Multiplying a square n-by-n matrix A by I has no eﬀect:
AI = A = IA.
A.2 Inverses of Matrices
The inverse of a matrix, written as A−1, is deﬁned as the matrix which when
pre- and post-multiplied by the matrix A produces the identity matrix I:
A−1A = AA−1 = I.
Only square matrices can have an inverse but it is only a subset of all square
matrices for which the inverse exists. The existence of the inverse of a matrix
(that is, whether the matrix is invertible or not) is intimately linked with the
determinant of the matrix. We introduce this, and many other properties of
matrices, in Chapter 6.
The utility of the inverse of a matrix is best seen when solving systems of
equations. An example will serve by way of illustration.
Example A.7 Consider the system of simultaneous equations:
x1 + x2 = 3,
(A.1a)
x1 + 2x2 = 5.
(A.1b)
3 Of course, we could include the dimensions of the matrix by writing 0nm to denote
that it is an n-by-m matrix. We will adopt the convention in the text that when
we refer to the zero matrix we are taking a matrix of the appropriate size required
for the operation.

332
A. A Mathematical Introduction to Matrices
These equations can be solved using conventional means. To do this we ﬁrst
subtract (A.1a) from (A.1b) to give
x1 + 2x2 −(x1 + x2) = 5 −3
or
x2 = 2,
and now substituting back into either equation (let us use (A.1a)) we have
x1 + 2 = 3
which gives
x1 = 1.
We can just as easily write the system (A.1) as a matrix equation
 1
1
1
2
  x1
x2

=
 3
5

or as
Ax = b.
Try multiplying out the matrix equation to check you get (A.1a) and (A.1b).
Elementary linear algebra shows that the solution is given by A−1b, which can
be written in MATLAB as inv(A)*b or A\b. The operator \ determines the
eﬀect of multiplying by the inverse of the ﬁrst argument on the second, without
ever constructing the inverse. The code for this example would be:
>> A = [1 1; 1 2]; % Initialise the matrix A
>> b = [3; 5];
% Initialise the vector b
>> x = inv(A)*b
% Determine the solution vector x
Before we proceed we note in the previous three lines of MATLAB code every-
thing after the percent sign % is taken by MATLAB to be a comment. Com-
ments are a useful way of making your MATLAB code readable by both you
and others.
We can check the answer from our matrix computation by typing A*x, which
should be equal to b.

A.2 Inverses of Matrices
333
Example A.8 Determine the vector x which satisﬁes the equation Ax = b
where
A =
⎛
⎜
⎜
⎝
1
2
3
4
4
3
2
1
1
0
−1
0
−1
1
−1
1
⎞
⎟
⎟
⎠and b =
⎛
⎜
⎜
⎝
5
10
15
20
⎞
⎟
⎟
⎠.
We enter the matrix A and vector b directly using
>> A = [1 2 3 4; ...
4 3 2 1; ...
1 0 -1 0; ...
-1 1 -1 1];
>> b = [5; 10; 15; 20];
(Note we have used the three dots ... (or ellipsis) to indicate to MATLAB that
the input line continues. It is good practise to have a space before the dots at
the end of the line.) These results can then be used to form x:
>> inv(A)*b
ans =
3.2500
4.5000
-11.7500
7.0000
This solution was obtained by considering the equation Ax = b and pre-
multiplying each side by the inverse of the matrix A (we have deliberately chosen
A so that its inverse exists). This gives A−1Ax = A−1b but we recall from the
deﬁnition of the inverse that A−1A = I and that Ix = x. Hence we have the
solution x = A−1b.

B
Glossary of Useful Terms
This appendix is provided purely as a guide. MATLAB has a very informative
help feature help command which is supplemented with several other features
lookfor maths. You can also access the help ﬁles on the web helpdesk.
This appendix is broken down into:
–
arithmetic and logical operators
–
symbols
–
plotting commands
–
general MATLAB commands
B.1 Arithmetic and Logical Operators
+, - Used to add or subtract variables of the same size together, whether they
are matrices, vectors or scalars.
'
&
$
%
A = [1 2; 3 4];
B = ones(2);
A + B
A - B
5 + 0.5
7 - 4

336
B. Glossary of Useful Terms
It is also worth noting that these operations will add (or subtract) scalar
quantities from matrices. For instance:




A = ones(3);
B = A + 2;
C = 3 - A;
This produces a three-by-three matrix full of threes in B and a three-by-
three matrix full of twos in C. MATLAB will complain if these operations
are not viable.
*, / Used to multiply or divide variables as long as the operation is mathe-
matically viable:
'
&
$
%
4 * 3.2
4 / 2.3
A = [1 2; 3 4];
B = ones(2);
A * B
A / B
The last two operations give AB and AB−1. Notice that the multiplica-
tion operation is only viable if the inner dimensions agree: the number of
columns of the ﬁrst matrix must equal the number of rows of the second.
It can also multiply (or divide) matrices by scalars:




A = ones(3);
B = A/3;
C = A*4;
These commands give B as a three-by-three matrix full of 1/3’s and C as a
three-by-three matrix full of fours.
.* This binary operator allows one to perform multiplication calculations el-
ement by element on arrays of the same size. If we consider the vectors
x = (x1, x2, x3, x4) and y = (y1, y2, y3, y4). Then the calculation x‘.*’y
gives (x1y1, x2y2, x3y3, x4y4). Notice that both x and y were row vectors
of length 4 and so is the answer. Let us consider the example:

B.1 Arithmetic and Logical Operators
337




A = [4 3; 2 1];
B = [1 2; 3 4];
C = A.*B;
This does the calculation element-wise and gives the result:
C =
 4 × 1
3 × 2
2 × 3
1 × 4

=
 4
6
6
4

.
This command can also be used on values which are scalars, so for instance
A = ones(2); B = A.*2; gives B as a matrix full of twos.
The most common use of this operator is again in the construction of
functions.




x = 1:5;
f = x.*sin(x);
g = (3*x+4).*(x+2);
This gives us x = [1 2 3 4 5] and then: f = x sin x evaluated at those
points, i.e. [sin(1) 2*sin(2) 3*sin(3) 4*sin(4) 5*sin(5)]; and g =
(3x + 4)(x + 2) at the points. Notice it is not necessary to use the operator
.* when calculating 3*x since 3 is a scalar.
./ This binary operator allows one to perform division calculations element
by element on arrays of the same size. If we consider the vectors x =
(x1, x2, x3, x4) and y = (y1, y2, y3, y4), then the calculation x‘./’y gives
(x1/y1, x2/y2, x3/y3, x4/y4). Notice that both x and y were row vectors of
length 4 and so is the answer. Let us consider the example:




A = [4 3; 2 1];
B = [1 2; 3 4];
C = A./B;
This does the calculation element-wise and gives the result:
C =
 4/1
3/2
2/3
1/4

=
 4
3
2
2
3
1
4

.
This command can also be used on values which are scalars, so for instance
A = ones(2); B = A./2; gives B as a matrix full of halves.
The most common use of this operator is in the construction of functions.

338
B. Glossary of Useful Terms




x = 1:5;
f = x./sin(x);
g = (3*x+4)./(x+2);
This gives us x = [1 2 3 4 5] and then: f = x/ sin x evaluated at
those points, i.e. [1/sin(1) 2/sin(2) 3/sin(3) 4/sin(4) 5/sin(5)];
and g = (3x + 4)/(x + 2) at the points.
We can use this command where either of its arguments are scalars (in fact,
it is necessary for this example).




x = [1 2 3 4 5];
y = 2./x
This gives [2/1 2/2 2/3 2/4 2/5]. This construction is useful when
working out functions of the form f(x) = 2/x.
.ˆ This binary operator allows one to perform exponentiation (raising to a
power) calculations element by element on arrays of the same size. If we
consider the vectors x = (x1, x2, x3, x4) and y = (y1, y2, y3, y4), then the
calculation x‘.ˆ’y gives (xy1
1 , xy2
2 , xy3
3 , xy4
4 ). Notice that both x and y were
row vectors of length 4 and so is the answer. Let us consider the example:




A = [4 3; 2 1];
B = [1 2; 3 4];
C = A.ˆB;
This does the calculation element-wise and gives the result:
C =
 41
32
23
14

=
 4
9
8
1

.
This command can also be used on values which are scalars, so for instance
A = ones(2); B = A.ˆ2; gives B as a matrix full of ones (that is one
squared).
The most common use of this operator is in the construction of functions.




x = 1:5;
f = x.ˆ(x+1);
g = (3*x+4).ˆx;

B.1 Arithmetic and Logical Operators
339
This gives us x = [1 2 3 4 5] and then: f = xx+1 evaluated at those
points, i.e. [1ˆ2 2ˆ3 3ˆ4 4ˆ5 5ˆ6]; and g = (3x + 4)x at the points.
As with the operator ‘./’ we can use this command when either of its
arguments are scalars. For instance:




x = 1:5;
y = 2.ˆx;
z = x.ˆ2;
This gives y=[2ˆ1 2ˆ2 2ˆ3 2ˆ4 2ˆ5] and z=[1ˆ2 2ˆ2 3ˆ2 4ˆ2 5ˆ2].
\ This works out the eﬀect of pre-multiplying by the inverse of the ﬁrst ar-
gument on the second argument. So if we want to solve the set of linear
equations represented in the matrix equation Ax = b, we need to construct
x = A−1b.




A = [1 2; 3 4];
b = [2; 3];
x = A\b;
This solves the set of equations:
x1 + 2x2 = 2
3x1 + 4x2 = 3.
by deﬁning
A =
 1
2
3
4

and b =
 2
3

,
with x = (x1, x2)T .
== Checks equality, rather than sets equal. This is usually exploited within
logical statements with scalars:
#
"
 
!
if i==7
disp(’ i is seven ’)
else
disp(’ i is not seven ’)
end
This can be used in other forms: x = 1:12; mod(x,3)==0. This gives the
output:

340
B. Glossary of Useful Terms
0
0
1
0
0
1
0
0
1
0
0
1
that is it is true provided the corresponding element of x is divisible by 3.
∼= Checks not equal to. Again this is mainly used in logical statements with
scalars:
#
"
 
!
if i˜=7
disp(’ i is not seven ’)
else
disp(’ i is equal to seven ’)
end
This can be used inline x = 1:12; mod(x,3)∼=0. This gives the output:
1
1
0
1
1
0
1
1
0
1
1
0
that is it is true provided the corresponding element of x is not divisible
by 3. Note: great care is needed with this command since the simple order
change to y=∼x means set y equal to not(x).
>, >= Checks greater than and greater than or equal to. Mainly used with
scalars within logical statements:
'
&
$
%
if i>7
disp(’ i is greater than seven ’)
end
if i>=7
disp(’ i is greater than or equal to seven ’)
end
Can be used for an array x = 1:12; x>7 which gives
0
0
0
0
0
0
0
1
1
1
1
1
whereas x = 1:12; x>=7 gives

B.1 Arithmetic and Logical Operators
341
0
0
0
0
0
0
1
1
1
1
1
1
that is the second one is true for x = 7.
<, <= Checks less than and less than or equal to. Mainly used with scalars
within logical statements:
'
&
$
%
if i<7
disp(’ i is less than seven ’)
end
if i<=7
disp(’ i is less than or equal to seven ’)
end
Can be used for an array x = 1:12; x<7 gives
1
1
1
1
1
1
0
0
0
0
0
0
whereas x = 1:12; x<=7
1
1
1
1
1
1
1
0
0
0
0
0
that is the second one is true for x = 7.
all This returns a value of true if all of the arguments are true: all(x.ˆ2>0)
would be true (provided all the values of x are real); x = 1:12; all(x>0)
would give true since all the elements of x are positive.
and Boolean operator for and can also use &. This is true only if both its
arguments are true.




if and(x>7,x<9)
disp(’ x is between 7 and 9’)
end
This can also be written as x>7 & x<9 and can be applied to arrays, so
that x = 1:12; and(x>7,x<9) gives:

342
B. Glossary of Useful Terms
0
0
0
0
0
0
0
1
0
0
0
0
any This returns a value of true if any of the arguments are true: any(x<0)
would be true if any of the values in the vector x are strictly negative; x =
1:12; any(x>10) would be true since some elements of x are greater than
10.
find Provides a list of integers when the condition is true, for instance x =
1:10; [i]=find(x.ˆ2>26); gives the locations i=[6 7 8 9 10].
not Negates logical variables, can also use ∼. This can be used to turn true
into false and vice versa, so that




if not(x>=7)
disp(’ x is not greater than or equal to 7’)
end
This could also be written as ∼(x>=7). This can be applied to arrays, so
that x = 1:12; not(x>=7) gives:
1
1
1
1
1
1
0
0
0
0
0
0
or Boolean operator for or can also use |. This is true provided one of its
arguments is true.




if or(x<7,x>9)
disp(’ x is less than 7 or greater than 9’)
end
This can also be written as x<7 | x>9 and can be applied to arrays, so
that x = 1:12; or(x<7,x>9) gives:
1
1
1
1
1
1
0
0
0
1
1
1
xor Exclusive or. This gives true if one of the values is true and false if they
are both false or both true.

B.2 Symbols
343




x = [0 0 1 1];
y = [0 1 0 1];
xor(x,y)
gives [0 1 1 0].
We note that this can also be done for or and and.
B.2 Symbols
... Used to link lines together (but cannot be used within a string):




x = 1:10;
f = x.ˆ2+sqrt(x.ˆ2+1) ...
+ cos(x)./x;
This gives the function f = x2 +
√
x2 + 1 + cos x/x at the values from x
equals 1 to 10.
% Means the rest of the line is a comment. It also has special meaning at the
start of a code. It can be very useful for eliminating the execution of certain
lines of a code.
'
&
$
%
% This code calculates the value
% of x times sin(x)
f = x.*sin(x);
% and the value of cos(xˆ2)
g = cos(x.ˆ2); % where x can be a vector.
If this code was saved as mycode.m then typing help mycode would pro-
duce:
This code calculates the value
of x times sin(x)

344
B. Glossary of Useful Terms
; Used at the end of a phrase to suppress output. It can occur at the physical
end of a line or at the end of a set of commands.




a = ones(2);
b = ones(2); c = ones(2);
d1 = ones(2); d2 = ones(2)
This code will set up the two-by-two matrices a, b, c, d1 and d2 full of ones.
It will only report on the initiation of d2 since this phrase is not concluded
with a semicolon.
It can also be used to end lines within matrices (enclosed within pairs of
square brackets)




A= [ 1 2; 3 4];
This gives the matrix
A =
 1
2
3
4

.
(Note that the semicolon is used in both its incarnations here.) We note
that both uses of the semicolon correspond to the end of the phrase: it
is merely that the square brackets are unbalanced in the latter case so
MATLAB knows that it is going to read the next line of the matrix.
: Used to delimit values when setting up a vector and also to refer to entire
rows or columns of matrices. When setting a row vector there are two
syntaxes:




x1 = 1:12
x2 = 1:2:13
The ﬁrst of these commands sets up an array from 1 to 12 in steps of
unity (and is equivalent to 1:1:12) whereas the second array runs from
1 to 13 in steps of 2, thus it yields [1 3 5 7 9 11 13]. The syntaxes
are a:b (an array from a to a value not exceeding b in steps of unity)
and a:h:b (an array from a to a value not exceeding b in steps of h)
(see also linspace). Note that h can be negative 11:(-2):1 gives [11 9
7 5 3 1]. We note that the length of an array set up using a:h:b is not
(b−a)/h (presuming that this is an integer), but (b−a)/h+1. For example
0:0.1:1 has eleven points [0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
1.0] rather than ten. This dimension can be determined using length.

B.2 Symbols
345
The second use of this symbol allows reference to all viable values of a row
or column.
'
&
$
%
A = [11 12 13; 21 22 23; 31 32 33];
A(1,:)
% First row of A
A(:,2)
% Second column of A
A(:,:)
% Whole of A.
A(:,1:2)
% First and second columns of A
A(1:2:3,:)
% First and third rows of A
A(1:2,1:2)
% Top left two-by-two corner of A
, Can be used to delimit sets of commands where feedback is required:




a = 1, b = 2
and to separate elements of matrices on a particular line




A = [1,2,3,4;5,6,7,8];
It is also used to separate arguments of functions




x = linspace(0,1,200);
’ ’
Used to surround strings and for passing arguments to various functions:




a = ’Do robots dream of electronic sheep?’
x = 1:12;
y = x.ˆ2;
plot(x,y,’LineWidth’,2)
see the comments on plot below.
’
Gives the complex conjugate transpose of a matrix. If the n-by-m matrix
A has elements ai,j, then B = A’ is m-by-n and has elements bi,j = a∗
j,i
(where i ∈{1, · · · , m} and j ∈{1, · · · , n}).

346
B. Glossary of Useful Terms




A = [1+2*i 2-i; 3 4+i];
B = A’;
This gives
B =
 1 −2i
3
2 + i
4 −i

.
.’
Gives the transpose of a matrix. If the n-by-m matrix A has elements ai,j,
then B = A.’ is m-by-n and has elements bi,j = aj,i (where i ∈{1, · · · , m}
and j ∈{1, · · · , n}).




A = [1+2*i 2-i; 3 4+i];
B = A.’;
This gives
B =
 1 + 2i
3
2 −i
4 + i

.
It is better to use this form rather than A’ unless you are concerned with
issues of complex matrices.
(space) Can be used to separate elements of matrices, as for the comma; but
cannot be used to separate commands. Hence we can use:




A = [1 2 3; 4 5 6];
B = [ 1:3 ; 3 2 1];
The reason that (space) cannot be used to delimit commands is that it
can occur naturally within a command, for instance a = 2 which is used
rather than a=2 merely to improve the readability of the code.
. decimal point – This can be used ﬁrstly as the mathematical decimal point:
3.145 or 567.3245. It is also used to punctuate ﬁle names into two parts:
an identiﬁer (descriptive of the contents of the code, or its function) and
then the ﬁle’s type (.m, .mat, .dat or .fig). For this reason you should
only have one ‘.’ in each number or ﬁlename.
[
] used to enclose elements of a vector or matrix:




A = [1 2 3 5 6 7];
B = [1 2 3;
3 4 5];
ms = [’Vector array’ ’ of strings’];

B.3 Plotting Commands
347
These brackets should balance.
( )
used to surround mathematical expressions and lists of arguments for
functions:




x= 1:12
y = 1./(x.ˆ2+1);
z = x.*sin(y);
Again these brackets should balance.
B.3 Plotting Commands
Before we start this section we need to discuss the idea of a handle. This is
essentially a variable which allows us to access properties of an object.
>> x = 1:12; y = x.ˆ2;
>> h = plot(x,y)
>> get(h)
Color = [0 0 1]
EraseMode = normal
LineStyle = -
LineWidth = [0.5]
Marker = none
MarkerSize = [6]
MarkerEdgeColor = auto
MarkerFaceColor = none
XData = [ (1 by 12) double array]
YData = [ (1 by 12) double array]
ZData = []
ButtonDownFcn =
Children = []
Clipping = on
CreateFcn =
DeleteFcn =
BusyAction = queue
HandleVisibility = on
Interruptible = on
Parent = [3.00012]

348
B. Glossary of Useful Terms
Selected = off
SelectionHighlight = on
Tag =
Type = line
UserData = []
Visible = on
The variable h allows us to access all of these commands, which can be changed
using the command set, for instance set(h,’MarkerSize’,10).
axes Used to initiate a set of axes




figure(1)
h = axes
figure(2)
h = axes(’position’,[0.2 0.2 0.6 0.6])
The ﬁrst command yields a full window set of axes with default ranges.
The second command gives a reduced set of axes:
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
in the centre of the window of dimension 0.4 times the window width and
height. The attributes of the handle can then be used by get and set.
axis In plots used to set the range of the plot, the argument is a row vector of
length 4 (for two-dimensional plots) or of length 6 (for three-dimensional
plots).

B.3 Plotting Commands
349




x = 0:pi/20:pi; y = sin(x);
plot(x,y)
axis([-pi/2 pi/2 -1 1])
The initial ranges for the axes are given by [min(x) max(x) min(y)
max(y)] which gives:
0
0.5
1
1.5
2
2.5
3
3.5
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
whereas typing the axis command above gives
−1
0
1
2
3
4
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
For three dimensions a similar structure applies with an extra pair of vari-
ables representing the minimum and maximum of the third variable.

350
B. Glossary of Useful Terms
'
&
$
%
t = linspace(0,2*pi);
x = cos(t);
y = sin(t);
z = t;
plot3(x,y,z)
grid on
axis([-1.5 1.5 -1.5 1.5 -pi/2 2*pi])
This gives the plot:
−1.5
−1
−0.5
0
0.5
1
1.5
−1.5
−1
−0.5
0
0.5
1
1.5
−1
0
1
2
3
4
5
6
We have used grid on to add the dotted lines.
The command can also be used as:
'
&
$
%
axis off
% Removes the axis from the current figure
axis equal
% Sets the axis scaling to be equal.
axis square % Sets the axis to be square.
axis tight
% Uses the max and min of the
% data for axis limits
for more variants see help axis.
bar Produces a bar chart of the data.

B.3 Plotting Commands
351




x = [1 2 3 4 5];
y = [13 12 9 8 15];
bar(x,y)
This gives:
1
2
3
4
5
0
5
10
15
If only one argument is supplied it uses x = 1:m where m is the number of
values of y.
barh Produces a horizontal bar chart of the data.




x = [1 2 3 4 5];
y = [13 12 9 8 15];
barh(x,y)
This gives:
0
5
10
15
1
2
3
4
5

352
B. Glossary of Useful Terms
If only one argument is supplied it uses x = 1:m where m is the number of
values of y.
clf This clears the current ﬁgure, in fact it removes all children with visible
handles. It removes any axes from the current ﬁgure. It is useful to use this
before we start plotting.
close This is used to close ﬁgures; close all closes all ﬁgures. There are
basically three syntaxes:




close
% Closes the current figure
close(4)
% closes figure number 4
close all
% closes all figures.
This can be used for other windows by using their handle: close(h) closes
the window with handle h.
figure This brings the requested ﬁgure to the fore, or creates it if it doesn’t
exist.
#
"
 
!
figure
% Creates a figure
figure(3)
% Ensures that Figure No. 3 is the current
% figure and is at the fore.
figure(h)
% Ensures that the figure with the handle
% h is the current figure
gca Returns the handle to the current axis; this allows various properties to
be displayed (get) and modiﬁed (set).
There are many variables involved:
>> x = 1:12; y=x.ˆ2;
>> plot(x,y)
>> h = gca
>> get(h)
AmbientLightColor = [1 1 1]
Box = on
CameraPosition = [6 75 17.3205]
CameraPositionMode = auto
CameraTarget = [6 75 0]
CameraTargetMode = auto
CameraUpVector = [0 1 0]
CameraUpVectorMode = auto
CameraViewAngle = [6.60861]

B.3 Plotting Commands
353
CameraViewAngleMode = auto
CLim = [0 1]
CLimMode = auto
Color = [1 1 1]
CurrentPoint = [ (2 by 3) double array]
ColorOrder = [ (7 by 3) double array]
DataAspectRatio = [6 75 1]
DataAspectRatioMode = auto
DrawMode = normal
FontAngle = normal
FontName = Helvetica
FontSize = [10]
FontUnits = points
FontWeight = normal
GridLineStyle = :
Layer = bottom
LineStyleOrder = -
LineWidth = [0.5]
NextPlot = replace
PlotBoxAspectRatio = [1 1 1]
PlotBoxAspectRatioMode = auto
Projection = orthographic
Position = [0.13 0.11 0.775 0.815]
TickLength = [0.01 0.025]
TickDir = in
TickDirMode = auto
Title = [287.001]
Units = normalized
View = [0 90]
XColor = [0 0 0]
XDir = normal
XGrid = off
XLabel = [288]
XAxisLocation = bottom
XLim = [0 12]
XLimMode = auto
XScale = linear
XTick = [ (1 by 7) double array]
XTickLabel =
0
2
4
6
8
10
12
XTickLabelMode = auto
XTickMode = auto
YColor = [0 0 0]
YDir = normal
YGrid = off
YLabel = [289]
YAxisLocation = left

354
B. Glossary of Useful Terms
YLim = [0 150]
YLimMode = auto
YScale = linear
YTick = [0 50 100 150]
YTickLabel =
0
50
100
150
YTickLabelMode = auto
YTickMode = auto
ZColor = [0 0 0]
ZDir = normal
ZGrid = off
ZLabel = [290]
ZLim = [-1 1]
ZLimMode = auto
ZScale = linear
ZTick = [-1 0 1]
ZTickLabel =
ZTickLabelMode = auto
ZTickMode = auto
ButtonDownFcn =
Children = [285]
Clipping = on
CreateFcn =
DeleteFcn =
BusyAction = queue
HandleVisibility = on
HitTest = on
Interruptible = on
Parent = [1]
Selected = off
SelectionHighlight = on
Tag =
Type = axes
UIContextMenu = []
UserData = []
Visible = on
gcf Returns the handle of the current ﬁgure. This allows various properties to
be displayed (get) and modiﬁed (set).




x = 1:12; y = x.ˆ2;
plot(x,y)
h = gcf
get(h)

B.3 Plotting Commands
355
returns the list printed on page 348.
get Extracts a particular attribute from a list, retrieved for example by gca
or gcf.
>> x = 1:12; y = x.ˆ2;
>> plot(x,y)
>> h = gcf
>> a = gca
>> get(h,’Color’)
ans =
0.8000
0.8000
0.8000
>> get(a,’YTick’)
ans =
0
50
100
150
The colour variable is returned as a triple (a one-by-three vector giving the
RGB (Red-Green-Blue) value). The values associated with the axis and the
ﬁgure can be changed using the set command.
ginput Returns coordinates of mouse clicks on the current ﬁgure in terms of
axis units; very useful for obtaining initial estimates for roots (see also
zoom).




x = 0:pi/20:4*pi;
y = sin(x);
plot(x,y)
[xp,yp]= ginput
Notice that control is passed over to the ﬁgure and the points are stored in
the arrays xp and yp (until the return key is hit). The command can also
be used as n = 10; [xp,yp] = ginput(n) to only get 10 points.
gplot Plot a graph using the vertices and the adjacency matrix. To plot the
graph

356
B. Glossary of Useful Terms
we use the code:
'
&
$
%
xy = [0 0;1 0;
1 1; 0.5 0.5];
A = [0 1 0 0;
1 0 1 1;
0 1 0 1;
0 1 1 0];
gplot(A,xy,’-*’)
axis equal
axis off
grid Add a grid to a plot (or turn it oﬀ).
#
"
 
!
grid on
% Turns the grid on
grid off
% Turns the grid off
grid
% Toggles the grid state
hist Produces a histogram of the data.
>> y = [1 2 3 43 32 54 33 2 4 53 5 63 21 1 5 2];
>> hist(y)

B.3 Plotting Commands
357
gives
0
10
20
30
40
50
60
70
0
1
2
3
4
5
6
7
8
9
We can use a second argument for hist to deﬁne the number of bins.
hold Stops overwriting of current ﬁgure.
#
"
 
!
hold on
% Turns the hold on
hold off
% Turns the hold off
hold
% Toggles the hold state
This is useful for putting multiple lines on a plot.
'
&
$
%
x = 0:pi/20:pi;
y = sin(x);
z = cos(2*x);
clf
plot(x,y)
hold on
plot(x,z)
hold off
legend Used to add a “legend” to a ﬁgure, to describe the lines.

358
B. Glossary of Useful Terms
#
"
 
!
x = 1:10;
y = x.ˆ2;
z = sin(x);
plot(x,y,x,z)
legend(’xˆ2’,’sin x’, 0)
This gives
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
0
0.5
1
1.5
2
2.5
3
3.5
4
x2
sin x
The arguments for legend consist of the labelling for the lines and a number
which is chosen from:
0
=
Automatic “best” placement (least conﬂict with data)
1
=
Upper right hand corner (default)
2
=
Upper left hand corner
3
=
Lower left hand corner
4
=
Lower right hand corner
-1
=
To the right of the plot
loglog Produces a graph of natural log against natural log of the data.




x = [1e-3 1e-2 1e-1 1 1e1 1e2];
y = [10e-3 10e-2 10e-1 10 10e1 10e2];
loglog(x,y)
This gives:

B.3 Plotting Commands
359
10
−3
10
−2
10
−1
10
0
10
1
10
2
10
−2
10
−1
10
0
10
1
10
2
10
3
see also semilogx and semilogy.
plot Used to set up ﬁgures and plotting of data. The simplest form would be
plot(x,y). This command is extremely powerful and has many variants
(typing help plot helps tremendously).
x = -1:0.1:1;
y = x.ˆ3;
plot(x,y)
% Produces a simple plot of y=xˆ3
% using the default line colour
plot(x,y,’go’) % Produces a simple plot of y=xˆ3
% using green circles.
The arguments in plot either occur: in pairs in which they are pairs of
coordinates for plotting or in triples in which case they are pairs of coordi-
nates and the line style with which the data is to be plotted. You can also
deﬁne variables associated with the plot in the statement:




plot(x,y,’LineWidth’,2)
plots the line but with a thicker line.
plot3 This is similar to plot but gives a line in three dimensions.

360
B. Glossary of Useful Terms
#
"
 
!
x = 0.:0.1:3.0;
y = x.ˆ2;
z = 3*x+1;
plot3(x,y,z)
grid on
This gives
0
0.5
1
1.5
2
2.5
3
0
2
4
6
8
10
1
2
3
4
5
6
7
8
9
10
print Used to output the contents of ﬁgures to ﬁles, for Postscript use print
-dps2 output.ps. For colour Postscript use print -dpsc2 output.cps
or for JPEG format printf -djpeg90 output.jpg.
semilogx Produce a plot of y versus ln x.




x = linspace(1,100,30);
semilogx(x,log(x))
gives:

B.3 Plotting Commands
361
10
0
10
1
10
2
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
semilogy Produce a plot of ln y versus x.




x = linspace(1,100,30);
semilogy(log(x),x)
gives:
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
10
0
10
1
10
2
set Allows the deﬁnition of a particular attribute from a list, retrieved for
example by gca and gcf, or directly from a plot command.

362
B. Glossary of Useful Terms




x = 1:12;
y = 1./x;
h = plot(x,y)
set(h,’LineWidth’,4)
This gives
0
2
4
6
8
10
12
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
For a list of the attributes of an object (and their values) use get(h), where
h is deﬁned directly using gca or gcf.
subplot Sets up sub-elements of a plot and points to which one is current. It
takes three arguments:




subplot(4,2,3)
% Gives an array of figures 4-by-2
and sets the current axis to be the third ﬁgure, that is the left hand ﬁgure
on the second row.




for j = 1:8
subplot(4,2,j)
text(0.5,0.5,int2str(j),’FontSize’,24)
end
This gives eight subplots (which have been labelled with their correspond-
ing numbers).

B.3 Plotting Commands
363
0
0.2
0.4
0.6
0.8
1
0
0.5
1
1
0
0.2
0.4
0.6
0.8
1
0
0.5
1
2
0
0.2
0.4
0.6
0.8
1
0
0.5
1
3
0
0.2
0.4
0.6
0.8
1
0
0.5
1
4
0
0.2
0.4
0.6
0.8
1
0
0.5
1
5
0
0.2
0.4
0.6
0.8
1
0
0.5
1
6
0
0.2
0.4
0.6
0.8
1
0
0.5
1
7
0
0.2
0.4
0.6
0.8
1
0
0.5
1
8
text Used to add useful labels to ﬁgures.
#
"
 
!
x = -1:0.1:1;
y = sin(x.ˆ2);
plot(x,y)
h = text(0,0.5,’sin xˆ2’)
set(h,’FontSize’,18)
This gives:
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
sin x2
The syntax is text(a,b,string) where (a,b) is the coordinate in terms of
the data and string is enclosed in single quotes. Notice here that sin xˆ2
actually appears as sin x2. These commands also recognise underscore for
subscript and Greek letters in the form \omega, for instance.

364
B. Glossary of Useful Terms
title Used to set the title of a plot or subplot. This has quite simple syntax
and attaches it to the current set of axes.




x = 0.0:0.1:5.0;
y = 1-exp(-x);
plot(x,y)
title(’f(x) = 1-eˆ{-x}’,’FontSize’,18)
which gives:
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
f(x) = 1−e−x
Notice we have used curly brackets to group the power of e for the title.
xlabel, ylabel Sets the text for the x and y axis.
'
&
$
%
x = linspace(-2,2,30);
y = (x - 3).ˆ2;
plot(x,y)
hx = xlabel(’x values’)
hy = ylabel(’y = (x-3)ˆ2’)
set(hx,’FontSize’,16)
set(hy,’FontSize’,16)
which gives:

B.4 General MATLAB Commands
365
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
0
5
10
15
20
25
x values
y = (x−3)2
zoom Permits zooming into ﬁgures: right click enlarge, left click to reduce. This
has the syntax:
#
"
 
!
zoom on
% Turns the zoom on
zoom off
% Turns the zoom off
zoom
% Toggles the zoom state
B.4 General MATLAB Commands
abs Returns the absolute value of a real number or the modulus of a complex
one (actually both are the same thing).
#
"
 
!
abs(-1)
% Gives 1
abs(1+i)
% Gives sqrt(2)
x = [1 -2 3+3i];
abs(x)
This also works for vectors and matrices so that the ﬁnal example gives
[1.0000 2.0000 4.2426] (where the last value is 3
√
2).
angle Returns the argument of a complex number.

366
B. Glossary of Useful Terms




angle(sqrt(-1))
% This gives pi/2
angle(2)
% This gives 0
angle(-2)
% This gives pi
This can be used for an array of values and returns a vector of the same
size full of the corresponding arguments.
atan2 Gives the arctangent with values between (−π, π]. (see also tan,atan).
Rather than calculating y/x and then taking the arctangent this function
takes account of which quadrant the value is in.




atan2(1,1)
% Gives pi/4
atan2(-1,-1)
% Gives -3pi/4
atan2(1,0)
% Gives pi/2
Note that the y value is given ﬁrst. This command can be used to determine
the argument of a complex number as atan2(imag(z),real(z)) (which
can be compared with angle(z).
besselj Gives the solution Jν(x) to Bessel’s equation x2y′′+xy′+(x2−ν2)y =
0.




x = linspace(0,6);
y = besselj(0.5,x);
plot(x,y)
This gives the graph:
0
1
2
3
4
5
6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1

B.4 General MATLAB Commands
367
The parameter ν is set to be 1/2 here and in fact J 1
2 (x) = sin x/√x.
There are other Bessel functions: bessely(nu,x), besseli(nu,x) and
besselk(nu,x).
break Stop current level of execution and go back to the previous level, for
instance exit a function.
'
&
$
%
function [sx] = takesqrt(x)
if x<0
disp(’ x is negative ’)
sx = NaN;
break
end
sx = sqrt(x);
This routine ﬁnds the square root of positive quantities and breaks if x is
negative.
case Elements of a switch list, plausible values which the argument can take
(see switch entry for example).
ceil Rounds up to the integer above, has the syntax ceil(x) where x can be
a matrix, vector or scalar.
>> x = [0.3 0.9; 1.01 -2.3];
>> ceil(x)
ans =
1
1
2
-2
clear Used to reset objects; clear variables removes all variables.
'
&
$
%
clear all
% Clears variables, globals, fns etc
clear variables
% Clear all variables
clear global
% Clear global variables
clear
% Same as clear variable
clear x
% Clear local variable x
clear x*
% Clear local variables starting with x.

368
B. Glossary of Useful Terms
cond Gives the condition number of a matrix, that is the ratio of its largest
and smallest eigenvalues. This reﬂects the ease with which the matrix can
be inverted, amongst other things.




A = [100 0; 0 0.1];
cond(A)
This matrix has eigenvalues of 100 and 0.1 and cond(A) returns 1000, that
is 100/0.1. In particular the Hilbert matrix is particularly badly conditioned
(ill-conditioned), see hilb.
conj Gives the conjugate of a complex number or an array of them.




x = [1 1+i -2-i 4+3i];
conj(x)
corrcoef Gives the correlation coeﬃcient between two sets of data.
>> x = [ 1 2 3 4 5 6];
>> y = [ 3 4 2 1 4 5];
>> corrcoef(x,y)
ans =
1.0000
0.3268
0.3268
1.0000
This means that x and y are totally correlated with themselves and that the
correlation coeﬃcient between the vectors is 0.3268. That is a slight posi-
tive correlation. The correlation coeﬃcient between two random variables
X and Y is given by
r =
cov(X, Y )

var(X)var(Y )
,
where the variances are deﬁned in Equation (B.2) and the covariance in
Equation (B.1).
cos, acos Cosine and arccosine. These functions need to be used with brackets
cos(x) and acos(x) (without, it produces a bizarre result, for instance cos
pi gives a one-by-two row vector with the elements cosine of the ASCII code
for “p” followed by the cosine of the ASCII code for “i”). These functions
can also be used for vectors and matrices.

B.4 General MATLAB Commands
369




x = 0:pi/20:pi;
y = cos(x)
z = acos(y)
cosh Hyperbolic cosine, equal to (ex + e−x)/2.
cov Gives the covariance of two sets of data.
>> x = [ 1 2 3 4 5 6];
>> y = [ 3 4 2 1 4 5];
>> cov(x,y)
ans =
3.5000
0.9000
0.9000
2.1667
The top left and bottom right elements are the variances of x and y and
the other elements are the covariances. The covariance is deﬁned as
σXY =
1
N −1
N

i=1
(xi −¯x)(yi −¯y).
(B.1)
For the deﬁnition of the variance see Equation (B.2). This is normalised
using N −1 (rather than N) since this gives the best unbiased estimate of
the covariance.
cputime Gives the current value of the CPU time. This can be used to time
how long parts of the code take:
#
"
 
!
t = cputime;
A = rand(100);
B = inv(A);
t2 = cputime - t;
disp([’Took ’ num2str(t2) ’ seconds’])
dec2hex Converts a decimal number to a hexadecimal number. The output
will be a string; a=23456; dec2hex(a). See also hex2dec.
demo Demonstrates the features and capabilities of MATLAB.
det This gives the determinant of a matrix. A = ones(10); det(A).

370
B. Glossary of Useful Terms
diag Sets one of the diagonals of a matrix. The diagonals are referred to as: 0
the leading diagonal, which runs from top left to bottom right. The super-
diagonals 1, 2, etc are above the leading diagonal and the sub-diagonals
−1, −2, etc are below the leading diagonal. Note that the nth diagonal is
|n| units longer than the leading one. If no diagonal is speciﬁed then the
leading one is used.




x = 1:4;
A = diag(x);
B = diag(x,2) + diag(x,-2);
The matrix A is a four-by-four matrix with the elements of x (i.e. 1, 2, 3
and 4 down the leading diagonal), whereas B is the matrix
B =
0
0
1
0
0
0
0
0
0
2
0
0
1
0
0
0
3
0
0
2
0
0
0
4
0
0
3
0
0
0
0
0
0
4
0
0
The command can also be used in reverse, for instance diag(A) gives [1 2
3 4] and diag(B,1) gives [0 0 0 0 0]: here we have extracted diagonals.
As a further example we run the code




A = zeros(10);
for i = -9:9
A = A+diag(ones(10-abs(i),1),i)*(i);
end
which gives
>> A
A =
0
1
2
3
4
5
6
7
8
9
-1
0
1
2
3
4
5
6
7
8
-2
-1
0
1
2
3
4
5
6
7

B.4 General MATLAB Commands
371
-3
-2
-1
0
1
2
3
4
5
6
-4
-3
-2
-1
0
1
2
3
4
5
-5
-4
-3
-2
-1
0
1
2
3
4
-6
-5
-4
-3
-2
-1
0
1
2
3
-7
-6
-5
-4
-3
-2
-1
0
1
2
-8
-7
-6
-5
-4
-3
-2
-1
0
1
-9
-8
-7
-6
-5
-4
-3
-2
-1
0
diary Records the user commands and output. This is useful to see which
commands have been used. One can specify the ﬁle in which the output is
stored:




diary(’list.diary’)
x = 1:10;
y = x.ˆ2;
diary off
diff Gives the diﬀerence between successive elements of a vector (is one unit
shorter than the original vector): x=(1:10).ˆ2; diff(x), where d(j) =
x(j + 1) −x(j).
disp Displays its argument, which is usually a string: a=10; disp([’The
value of a is ’ int2str(a)]).
edit Invokes the MATLAB editor, which is very useful since it allows us to
see the current values of variables and provides a very user friendly envi-
ronment for developing MATLAB programs.
eig Returns all the eigenvalues and eigenvectors of a matrix.




A = [1 2; -1 2];
[V, D] = eig(A)
V is a two-by-two matrix with the eigenvectors and columns and D is a
diagonal matrix containing the eigenvalues on the leading diagonal.
eigs Returns certain eigenvalues and eigenvectors of a matrix, speciﬁed by
certain criteria. [V,D] = eigs(A,3,’SM’) gives the three eigenvalues of A
with the smallest magnitude (and the corresponding eigenvectors). There
are many options for this command, see help eigs.
else If the argument for the preceding if statement is false execute these
statements.
elseif Same as else but imposing an alternative constraint.

372
B. Glossary of Useful Terms
end This command ends all of the loop structures and for each starting argu-
ment there must be a corresponding end (used with for, if, switch and
while).
eps The distance from 1.0 to the next largest ﬂoating point number. So MAT-
LAB cannot tell the diﬀerence between 1 and 1+eps/2, for instance.
error Causes the code to stop execution; error(’Broken!’) usually used
within a conditional statement.
exist Checks to see whether an object exists:




if ˜exist(’a’)
disp([’The variable a ’ ...
’does not exist’])
This can be used beyond variables: see the help lines for the command.
exp Evaluate the expression ex, can be used with vectors and matrices.
expm Evaluate the expression eA, where A is a matrix. This diﬀers from
exp(A), which evaluates ex for all the elements of A rather than eA which
is given by:
eA ≡I +
∞

j=1
Aj
j! .
eye Sets up the identity matrix: eye(n) gives In.
factor Gives the prime factors of an integer.
factorial This calculates the factorial of an integer n: factorial(n) gives
n!.
feval Evaluates a function, either user-deﬁned or intrinsic. feval(’sin’,pi).
fix Rounds to the nearest integer (closest to zero), also works for matrices.
fliplr Flips an object left to right. This has no eﬀect on column vectors.




x = 1:6;
y = fliplr(x)
sets y to be [6 5 4 3 2 1]. This also works with matrices.
flipud Flips an object upside down. This has no eﬀect on row vectors.

B.4 General MATLAB Commands
373




x = transpose(1:6);
y = flipud(x)
sets y to be [6; 5; 4; 3; 2; 1]. This also works with matrices.
floor Rounds down to the integer below, also works for matrices.
fmins This uses the Nelder–Mead simplex (direct search) method to ﬁnd the
minimum of a function. For instance to ﬁnd the minimum of the function
f(x1, x2) = (x1 + 2x2 −1)2/(x2
2 + 1) we use




function [f]=func(x)
f = (x(1)+2*x(2)-1)ˆ2/(x(2)ˆ2+1);
and the command [x]=fmins(’func’,[0 0]).
for Deﬁnes the start of a loop which runs over a list of objects.




N = 10
for j = 2:10
disp(j)
end
displays the numbers from 2 to 10.
format Used to specify how MATLAB displays variables. The options can be
retrieved using help format.
full Tells the programme to treat the matrix as full, rather than sparse.




A = [1 0 2; 0 -2 0; -1 0 0];
B = sparse(A);
C = full(B);
>> A
A =
1
0
2
0
-2
0
-1
0
0

374
B. Glossary of Useful Terms
>> B
B =
(1,1)
1
(3,1)
-1
(2,2)
-2
(1,3)
2
and C is back to A again.
function Occurs at the start of a function deﬁnition;
function [v1,v2]=testfn(in1,in2,in3).
fzero Determines one zero of the function passed as the ﬁrst argument to
fzero. This function takes many diﬀerent arguments and these can be
displayed using help fzero.




f = inline(’sin(3*x)’);
x = fzero(f,2);
ﬁnds a zero of the function f(x) = sin 3x near x equals two.
Zero found in the interval: [1.8869, 2.1131].
>> x
x =
2.0944
gcd Gives the greatest common divisor of two integers. This is unity if they
are coprime: used as gcd(x,y).
global This enables variables to be accessed from other places in the code
without being passed directly as an argument. There needs to be a global
statement in the context in which the variable is deﬁned and also one where
it is used.
help Gives help on MATLAB commands and can be used to expand the ma-
terial given in this glossary.
helpbrowser Launches a web browser help facility (MATLAB 6).

B.4 General MATLAB Commands
375
helpdesk Provides access to the web-based help facility.
hex2dec Converts a hexadecimal number to a decimal: the input needs to be
a string; a=’FF0’; hex2dec(a). See also dec2hex.
hilb(n) This sets up the n-by-n Hilbert matrix with entries (A)i,j = 1/(i+j).
i,j Initially set to be the square root of minus 1. These can be used to set up
complex numbers:




a = 3 + 2*i;
b = -4 + j;
(Note that once either of these variables has been used in another context
they will not necessarily be equal to √−1.)
if Start of a conditional block: if the statement is true then execute its con-
tents.




if x>1
disp(’x is greater than 1’)
end
This statement uses the logical structures described in section B.1.
imag Gives the imaginary part of a complex number; imag(1+i) gives 1.
Inf This represents answers which are inﬁnite, for instance 1/0.
inline Used to deﬁne functions which will be evaluated inline, see the help
function; g = inline(’tˆ2’) gives g = t2 and then it can be used in
feval as feval(g,5).
input Used for user entry of data a=input(’Enter a: ’);; can also be used
to enter strings name = input(’Enter name ’,s);.
int2str This takes an integer and returns a string: int2str(10) gives ’10’.
inv Works out the inverse of a matrix (if it exists).




a = [1 3; 2 -1];
b = inv(a);
a * b
This gives the two-by-two identity (which could be constructed using the
command eye(2)).

376
B. Glossary of Useful Terms
isempty Checks whether a variable is empty.




if isempty(x)
disp(’x is empty’)
end
This means that the array has either zero rows or zero columns but still
exists; to check the existence of a variable use the exist command.
isreal Checks whether a variable is real.




isreal(exp(0))
isreal(exp(i))
Care is needed since this command checks to see if the imaginary part of the
complex number is exactly zero and does not allow for computation errors:
for instance eiπ = −1, but the command isreal(exp(i*pi)) suggests that
the quantity is complex.
isprime Checks whether a variable is prime: isprime(24) gives false (that is
zero) whereas isprime(3571) gives true (that is one).
length Gives the length of a vector or alternatively the larger dimension of a
matrix:




a = [1 2 3; 4 5 6];
b = 1:16
length(a)
length(b)
gives the values 3 and 16 respectively.
linspace Sets up a grid of one hundred points from the ﬁrst argument to the
second. If there are three arguments use this as the number of points in
the grid.




x = linspace(0,1,6);
z = linspace(1,10);
This gives x = [0 0.2 0.4 0.6 0.8 1] and z being the array running
from 1 to 10 in steps of (10 −1)/99; since the endpoints are included the
step length is not (10 −1)/100 as you might initially expect.

B.4 General MATLAB Commands
377
load Reads in data, either directly into variable load data (which loads
data.mat) or load ’data.dat’ which returns a matrix data.
log Natural logarithms.




x = [1 exp(1) exp(2)]
y = log(x)
This would be written mathematically as y = ln x.
log10 Logarithm to base ten.




x = [1 10 10ˆ2]
y = log10(x)
This would be written mathematically as y = log10x. We note that log10x =
ln x/ ln 10.
lookfor Allows one to search help ﬁles for any command which has a string
in its speciﬁcation lookfor bessel.
lower Converts the characters in a string to lower case:




name = ’Bob Roberts’;
lower(name)
This gives bob roberts (the opposite command is upper).
lu This produces the LU decomposition of a matrix and can provide informa-
tion concerning pivoting.




A = [1 2 3; -1 3 2; -1 0 1];
[L,U] = lu(A)
Gives
L =
1.0000
0
0
-1.0000
1.0000
0
-1.0000
0.4000
1.0000

378
B. Glossary of Useful Terms
U =
1
2
3
0
5
5
0
0
2
To obtain the pivoting information we would have used [L,U,P] = lu(A).
In this case P is the three-by-three identity.
magic Returns a magic square:
>> magic(4)
ans =
16
2
3
13
5
11
10
8
9
7
6
12
4
14
15
1
Notice that not only do the rows, columns and diagonals add up to 34, but
so do the four numbers in each corner, the numbers in each two-by-two
block in the corner and the central two-by-two block.
max This returns the maximum of a vector: if a matrix is supplied it returns a
vector providing the maxima along the rows.




x = 0:pi/4:2*pi
max(sin(x))
gives 1, and




A = [1 2 3; 4 5 6];
max(A)
max(transpose(A))
gives [4 5 6] (that is the maxima of the columns) and [3 6] (the max-
ima of the rows), respectively. Instead of using the transpose we can use
the syntax max(A,[],2), which determines the maximum along the sec-
ond dimension. To ﬁnd the maximum of a two-dimensional array we use
max(max(A)).

B.4 General MATLAB Commands
379
mean Calculates the mean of a set of data, 1/n
n
i=1
xi.




mean([1 2 3 4 5 6 7])
This can also be used on matrices:




a = [1 2 3; 4 5 6];
mean(a,1)
mean(a,2)
the former giving the averages of the columns and the latter the averages
of the rows.
median Gives the median of a set of data, that is the one in the middle when
the data is ordered. This works in the same way as mean on matrices.
min Similar to max but giving the minimum.
mod This gives the remainder when the ﬁrst argument is divided by the second.
If used in the context mod(x,1) this gives the fractional part of x. It is
similar to rem.
NaN Not-a-Number, used to return quantities which are not assigned, for in-
stance 0/0.
norm Gives the mathematical norm of a quantity, particularly useful for work-
ing out the length of vectors. For vectors we have




norm(v,p)
gives
 n

i=1
|vi|p
1/p
.
If p equals two this is a “conventional” norm and the commands
norm(v,inf)
norm(v,-inf)
give max(abs(V)) and min(abs(V)), respectively.

380
B. Glossary of Useful Terms
num2str Converts a number to a string with a speciﬁed number of digits;
num2str(pi,4). This can also be used without specifying the number of
digits (which uses the default corresponding to four places after the decimal
point).
ode23,ode45 , Hybrid Runge–Kutta routines to integrate functions, the former
being a combination of second- and third-order schemes and the latter
fourth and ﬁfth.
We consider the solution of the diﬀerential equation
dy
dt = t2 −y2
subject to the initial conditions y(0) = 1. Firstly we need to set up a
function to give y′:




function [out] = func(t,y)
out = t.ˆ2-y.ˆ2;
(which we shall presume has been saved as func.m). This can now be called
using:




trange = [0 1];
yinit = 1;
[t,y] = ode45(’func’,trange,yinit);
This gives the solution:
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0.65
0.7
0.75
0.8
0.85
0.9
0.95
1

B.4 General MATLAB Commands
381
We can set tolerances, amongst other options. Consider the system of dif-
ferential equations
dx
dt = t −y
dy
dt = x,
subject to the initial conditions x(0) = y(0) = 0. We introduce the vector
y = (x(t), y(t))T , and as such we modify the code func.m to be:
#
"
 
!
function [out] = func(t,in)
% in(1) is x(t) and in(2) is y(t).
out = zeros(2,1);
out(1) = t-in(2);
out(2) = in(1);
This is called using the code:
trange = [0 1];
yinit = [0; 0];
options = odeset(’RelTol’,1e-4,’AbsTol’,[1e-4 1e-4]);
ode45(’func’,trange,yinit,options);
This is for the above version of func.m for the coupled ﬁrst-order systems,
which sets the relative tolerance to be 1e-4 and the absolute tolerances to
be [1e-4 1e-5]. This gives:
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
0.45
0.5

382
B. Glossary of Useful Terms
The upper line is x(t) and the lower one is y(t).
ones Sets up a matrix full of ones. ones(n,m) gives A which is an n-by-m
matrix for which ai,j = 1. ones(n) gives a square matrix (n-by-n).
otherwise If none of the cases correspond to the argument of the switch
command then these statements are executed.
path A list of places MATLAB looks for ﬁles, also serves as a command to
alter this variable. This command varies on diﬀerent platforms and as such
you should look at help path.
pause Causes the programme to wait a speciﬁed time, or can be used to wait
until the user touches a key.
'
&
$
%
x = linspace(0,10);
for its = 1:5
y = besselj(its/2,x);
clf
plot(x,y)
pause
end
This programme runs through the functions Jn/2(x) for n = 1, 2, 3, 4 and
5 as the user presses a key.
pi π - this is 4*atan(1) or imag(log(-1)).
poly This returns the characteristic polynomial of a matrix.




a = [1 2 3;
-1 2 0;
-1 1 1];
poly(a)
This gives [1.0000 -4.0000 10.0000 -7.0000], which represents |A −
λI| = λ3 −4λ2 + 10λ −7. The eigenvalues of the matrix can then be found
using roots.
polyfit Tries to ﬁt a polynomial of best ﬁt, using a least squares idea. If
there are n points in x (with no repeats) and y, and the user requests a
polynomial of degree n −1 then the ﬁt is “exact”:

B.4 General MATLAB Commands
383




x = [1 2 3];
y = [4 5 -2];
p = polyfit(x,y,2);
Note that the coeﬃcients are returned with the one corresponding to the
largest power ﬁrst. This gives the quadratic −4x2 + 13x −5: however
polyfit(x,y,1) on the same data gives the straight line −3x+25/3 (which
is the line of best ﬁt). It is possible to get information about the level of
the ﬁt using the form [p,s] = polyfit(x,y,1). The object s contains
information, for instance the covariance s.R.
polyval Evaluates a polynomial speciﬁed by its coeﬃcients at a set of data
points y=polyval(c,x).




x = [1 2 3];
c = [-4 13 -5];
y = polyval(c,x);
This reconstructs the data used in the example for polyfit. Notice that
the coeﬃcients are given with the one corresponding to the largest power
ﬁrst.
primes Lists the primes up to and including the argument. The syntax is
simply n=20; primes(n).
prod Similar to sum and gives the product of the elements of the vector x, so
that prod(x) returns
n
i=1
xi.




x = 1:10;
prod(x) % Gives 10!
z = [1 4 5 6 -2];
prod(z)
The factorial could also be found using factorial.
rand Generates random numbers between zero and one. This can be used to
form a matrix of random numbers as well. There are many versions of the
argument for this command, see help rand.
randn Generates normally distributed real numbers: again can be used to gen-
erate matrices randn(n,m).

384
B. Glossary of Useful Terms
randperm Generates a random permutation of a list of objects: To rearrange
the letters of our names:
'
&
$
%
s = ’otto denier’;
for its = 1:20
l = randperm(11);
s(l)
pause
end
rank This yields the rank of a set of linear equations and can be used to
see whether the system has no solutions, a unique solution or an inﬁnite
number of solutions (yielding information about the degrees of freedom).




A = [-1 1 1 2;
3 -1 1 1;
0 0 1 2];
rank(A)
real Gives the real part of a complex number real(z), where z can be a
scalar, vector or matrix.
realmax This is the largest ﬂoating point number representable on the com-
puter.
realmin This is the smallest ﬂoating point number representable on the com-
puter.
rem This is the remainder attained by dividing the ﬁrst argument by the second
one: rem(3.32,1.1) gives 0.02.




rem([3 4 5],2) % Gives 1 0 1
rem(5,[1 2 3]) % Gives 0 1 2
rem([3 4 5],[1 2 3])
% Gives 0 0 2
reshape This simply reshapes a matrix into a new shape. This is used most
commonly to make a vector into a matrix, but can be used to reshape
matrices.

B.4 General MATLAB Commands
385




s = rand(100,1);
a = reshape(s,10,10);
b = [1 3 4; 2 3 4];
d = reshape(b,1,6);
This gives d = [1 2 3 4 4]; the elements of b are read column-wise.
roots This gives the roots of the polynomial which is passed to the routine.
For instance to ﬁnd the roots of the cubic x3 + 4x2 + 7x + 2 we use




co = [1 4 7 2];
roots(co)
Notice again that the coeﬃcients are listed with the one corresponding to
the largest power ﬁrst (similarly for polyfit and polyval).
round Rounds to the nearest integer.
save Saves values of variables to a .mat ﬁle.
sin, asin Sine and arcsine. These functions need to be used with brackets
sin(x) and asin(x) (without, it produces bizarre results, for instance sin
pi gives a one-by-two row vector with the elements sine of the ASCII code
for “p” followed by the sine of the ASCII code for “i”). These functions
can also be used for vectors and matrices.




x = -pi/2:pi/20:pi/2;
y = sin(x)
z = asin(y)
sinh Hyperbolic sine.
size Returns the dimensions of a matrix: [rows,cols]=size(A).
sort This returns a list of numbers sorted into ascending order, together with
a map from their original position to that in the revised list.
sparse Deﬁnes the matrix as sparse so that the computer only operates on
non-zero entries: this can dramatically reduce the time spent doing com-
putations (see full).
spline Fits cubic splines through a set of data points (x, f) and evaluates
them at a further set of points z; y=spline(x,f,z).

386
B. Glossary of Useful Terms
sqrt This ﬁnds the square root of a matrix element by element. If necessary
the answer may be returned as a complex number.
std Calculates the standard deviation of a vector.
str2mat As the name suggests, this takes a string and returns a matrix.
sum This sums the contents of a vector, or the rows of a matrix. It can also be
called with a second argument which deﬁnes which dimension needs to be
summed.
switch This deﬁnes the start of a group of statements, the argument for which
is a variable, the likely values of which are listed in the cases.
tan,atan Tangent and arctangent. These functions need to be used with brack-
ets tan(x) and atan(x) (without, it produces bizarre results, for instance
tan pi gives a one-by-two row vector with the elements tangent of the
ASCII code for “p” followed by the tangent of the ASCII code for “i”).
These functions can also be used for vectors and matrices.




x = 0:pi/20:pi/4;
y = tan(x)
z = atan(y)
(see also atan2).
tour Gives a tour of the facilities of MATLAB.
transpose Returns the transpose of a matrix: can also be done using A.’.
(Note that A’ transposes and also takes the conjugate.)
type Prints out the contents of a MATLAB script.
upper Converts the characters in a string to upper case:




name = ’Bob Roberts’;
upper(name)
This gives BOB ROBERTS (the opposite command is lower).
var Gives the variance of a set of data. The covariance is deﬁned as
σX =
1
N −1
N

i=1
(xi −¯x)2.
(B.2)

B.4 General MATLAB Commands
387
warning Allows codes to issue warnings when there may be problems. Is also
used to aﬀect how the system issues warnings.
which Tells a user where a MATLAB ﬁle can be found, and which version is
going to be run.
while Deﬁnes the start of a loop which is continued while a certain condition
is fulﬁlled.
whos List of all variables (with details): this can be restricted using things like
whos a*.
zeros Sets up a matrix full of zeros: zeros(n,m) gives A which is an n-by-m
matrix for which ai,j = 0. zeros(n) gives 0n.

C
Solutions to Tasks
Please note that these solutions are given for guidance only and are by no means
unique. At the outset we shall give MATLAB output: however subsequently we
shall merely give the commands which can be used to solve the problems.
C.1 Solutions for Tasks from Chapter 1
Solution 1.1 The MATLAB code to solve these problems is:
'
&
$
%
x = 1.3;
p = xˆ2+3*x+1
x = 30/180*pi;
y = sin(x);
x = 1;
f = atan(x);
x = sqrt(3)/2;
h = acos(x);
g = sin(h)

390
C. Solutions to Tasks
The values this returns are: 6.5900, 0.5000, 0.7854 (which is π/4) and
0.5000.
Solution 1.2 To calculate the function y(x) = |x| sin x2 we use the code:




x = pi/3;
y = abs(x)*sin(xˆ2);
and similarly for x = π/6. Notice care is needed with the brackets and the
syntax.
Solution 1.3 The MATLAB commands to determine these quantities are:
sin(pi/2);
cos(pi/3);
tan(60/180*pi);
x=0.5; log(x+sqrt(xˆ2+1)) (and with x=1);
x=0; x/((xˆ2+1)*sin(x))
and ﬁnally x=pi/4; x/((xˆ2+1)*sin(x)).
Notice the penultimate part of this task generates NaN: this is because MATLAB
does not know how to evaluate zero divided by zero.
Solution 1.4 This is a matter of either typing out all the values or exploiting
the fact that MATLAB can operate on vectors. We can use the code:
#
"
 
!
x = [0.3 1/3 0.5 1/2 1.65 -1.34];
round(x)
ceil(x)
floor(x)
fix(x)
This example is included to help understand the rˆole of various MATLAB com-
mands which can be used to return diﬀerent roundings to appropriate integers.
Solution 1.5 The diﬀerence between rem and mod can be illustrated using the
y value of 4. Thus we have

C.1 Solutions for Tasks from Chapter 1
391
>> x=[3 4 5]
x =
3
4
5
>> rem(x,4)
ans =
3
0
1
>> mod(x,4)
ans =
3
0
1
>> rem(x,-4)
ans =
3
0
1
>> mod(x,-4)
ans =
-1
0
-3
>>
So for the second argument being positive we have that rem and mod are equiva-
lent, whereas for negative values the remainder is signed (thus it shows whether
it is positive or negative).
Solution 1.6 The MATLAB code is:

392
C. Solutions to Tasks
'
&
$
%
x = 1:0.1:2;
% Part 1
y = x.ˆ3+3*x.ˆ2+1;
% Part 2
y = sin(x.ˆ2);
% Part 3
y = (sin(x)).ˆ2;
% Part 4
y = sin(2*x)+x.*cos(4*x);
% Part 5
y = x./(x.ˆ2+1);
% Part 6
y = cos(x)./(1+sin(x));
% Part 7
y = 1./x+x.ˆ3./(x.ˆ4+5*x.*sin(x));
Solution 1.7




x = 3:0.01:5;
y = x./(x+1./x.ˆ2);
Solution 1.8




x = -2:0.1:-1;
f = 1./x;
y = f.ˆ3+f.ˆ2+3*f;
Solution 1.9 The code should read

C.1 Solutions for Tasks from Chapter 1
393
'
&
$
%
clear all
x = linspace(0,1,200);
g = x.ˆ3+1;
h = x+2;
z = x.ˆ2;
y = cos(x*pi);
f = y.*z./(g.*h);
f(200)
The errors were: the second line should have been ﬁrst, else this cleared out the
contents of x. The default number of points for linspace is 100, so this needed
to be speciﬁed as being 200. There were dots missing from the deﬁnition of g
and the calculation of f. MATLAB distinguishes between upper and lower case
in variable names so we need to use h rather than H. The command to calculate
y needs brackets around the argument of the cosine function and an asterisk
between x and pi. As mentioned above the dots were missing from f and the
denominator of the fraction needed to be contained within brackets. Finally the
answer needs to be printed (which could have been done at the prompt).
Solution 1.10 The code should read




x = linspace(-2,2,20);
c = [1 0 0 0 -1];
y = polyval(c,x);
plot(x,y)
The errors were: in the ﬁrst line the vector as deﬁned would contain 21 entries
(try typing length(x) after running the original code). A quartic actually has
5 coeﬃcients, so there was a zero missing in the deﬁnition of c and ﬁnally the
x and y needed to be transposed in the plotting command.
This gives the ﬁgure

394
C. Solutions to Tasks
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
−2
0
2
4
6
8
10
12
14
16
Solution 1.11 The corrected code should be
'
&
$
%
x = 0:0.1:3;
f = x.ˆ3.*cos(x+1);
% x = 2
f(21)
% x = 3
f(end)
C.2 Solutions for Tasks from Chapter 2
Solution 2.1 This is hopefully just a matter of typing the code and saving the
answer correctly.
Solution 2.2 The revised code could be:
'
&
$
%
a = input(’Enter a : ’);
b = input(’Enter b : ’);
res = aˆb;
str1 = ’The answer is ’;
str2 = ’
when ’ ;
str3 = ’ is raised to the power ’;
disp([str1 num2str(res) str2 ...
num2str(a) str3 num2str(b)]);

C.2 Solutions for Tasks from Chapter 2
395
Solution 2.3 The function for this purpose is:




function [out] = twox(x)
out = 2.ˆx;
Note the use of the dot so that it can be called with a vector (or even matrix).
Try it with x=1:8.
Solution 2.4 We can do this calculation using only one function




function [out1,out2] = func(x,y)
out1 = x.ˆ2 - y.ˆ2;
out2 = sin(x+y);
or using the two codes:




function [out] = func1(x,y)
out = x.ˆ2 - y.ˆ2;
and




function [out] = func2(x,y)
out = sin(x+y);
and then using the plot commands in the example. To extend the range to [0, 2π]
the ﬁrst line would need to be changed to x=0:pi/10:2*pi;.
Solution 2.5 The code should be modiﬁed to:




function [out1,out2,out3] = xfuncs(x)
out1 = sin(x);
out2 = cos(x);
out3 = out1.ˆ2 + out2.ˆ2;
where we have used the variables out1 and out2 to set the value of out3 (which
is actually always going to be 1).
Solution 2.6 This code takes two inputs and returns two outputs:

396
C. Solutions to Tasks




function [outx,outy] = mapcode(inx,iny)
outx = mod(inx+iny,1);
outy = mod(inx+2*iny,1);
Solution 2.7 This requires the modiﬁcation of the second line to read y =
x.ˆ3+3*x. The change in the limit requires the modiﬁcation of the ﬁrst line to
x = -4:1/4:6. It is perhaps a good idea to clear out the variables, which is
done using clear all.
Solution 2.8 This question can be solved by noting that this is in fact an
equation which is quadratic in x2 and as such can be solved using the formula
to have roots:
x2 = −1 ± √1 −4a
2
.
In order to have real roots we require 1 −4a ⩾0 so that 1/4 ⩾a and the
quantity x2 must be positive so that √1 −4a > 1, which means that a has to be
less than or equal to zero. This condition is more restrictive than the previous
one so consequently we require a ⩽0.
Solution 2.9 In the question the step is not speciﬁed: however we shall use
1/10 since this gives relatively smooth functions:
'
&
$
%
x = -1:0.1:1;
f = x+3;
g = x.ˆ2+1;
fg = f.*g;
f_over_g = f./g;
clf
plot(x,[f; g; fg; f_over_g])
legend(’f’,’g’,’f*g’,’f/g’,0)
This gives

C.2 Solutions for Tasks from Chapter 2
397
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
1
2
3
4
5
6
7
8
f
g
f*g
f/g
We have added a legend which uses the line styles to show which lines we have
plotted. We could have used diﬀerent style lines. We have used the additional
argument at the end of the legend command ,0 to tell MATLAB to put the
legend in the “best” position.
Solution 2.10 Here we shall provide details of how these codes can be improved
(or in some cases actually run).
1. In the ﬁrst line we just add a semicolon on the end to suppress output. The
second line contains a terrible error, although this is ﬁne as a mathematical
equation. In MATLAB you cannot set x+2 equal to y, we need to set y equal
to x+2. In the third line: the MATLAB variable for π has a lower case “p”
and we are missing an asterisk to denote multiplication and brackets around
the denominator of the fraction. The corrected code is:




x = 4;
y = x+2;
z = 1/(yˆ2*pi);
2. In the ﬁrst line we are missing a single quote and a semicolon. In the
deﬁnition of the for loop we have introduced a variable n, which should be
N. We have the loop variable as i whereas it is used as j within the loop.
On the next line we have the brackets missing which should surround the

398
C. Solutions to Tasks
denominator of the fraction, forcing it to be evaluated ﬁrst. In the display
line the ﬁrst square bracket is missing and the answer needs to be converted
to a string, which should be sum not s. On top of this we have failed to set
sum to be zero outside the loop and the command within the loop merely
gives the ﬁnal value rather than calculating the cumulative sum.
The corrected code is:
'
&
$
%
N = input(’Enter N ’);
sum = 0;
for j = 1:N
sum = sum + 1/j+ 1/((j+2)*(j+3));
end
disp([’The answer is ’ num2str(sum)])
3. In the ﬁrst line we have used two equals signs where we should only have
one. Two equals signs ask if x is equal to the right-hand side, rather than
setting x equal to it. The rest of the errors are in the second line. In the
numerator of the fraction we are missing an asterisk and brackets to show
that we are taking the cosine of x. In the denominator we have unbalanced
brackets (an extra round bracket needs to be added at the end). We have
also used a pair of square brackets which should be round. There is an extra
asterisk after the division sign. Since we are operating on a vector all of
the operators should be preceded with a dot. The corrected code is:




x = 0.0:0.1:1.0;
f = x.*cos(x)./((x.ˆ2+1).*(x+2))
4. The ﬁrst line of this code gives us a nine-by-nine matrix rather than a row
vector. The third line is ﬁne. In the for loop we have missed out all the
asterisks and the end which terminates the loop. The colons at the end of
the lines in the loops need to be changed to semicolons.
The corrected code is:

C.2 Solutions for Tasks from Chapter 2
399
'
&
$
%
w = ones(1,9);
w(1) = 1;
for j = 1:4
w(2*j) = 3;
w(2*j+1) = 2*j+1;
end
Solution 2.11
(a) Here the conversion factor will be worked out by remembering that there are
1760 yards in a mile, a yard is 36 inches and one inch is 2.54cm:
'
&
$
%
s = ’Enter speed in mph ’;
sp_mph = input(s);
sp_yards_ph = sp_mph*1760;
sp_inch_ph = sp_yards_ph*36;
sp_cm_ph = sp_inch_ph*2.54;
sp_m_ph = sp_cm_ph/100;
sp_km_ph = sp_m_ph/1000;
disp([’Speed in km/h is ’ ...
num2str(sp_km_ph) ])
(b) This is essentially the reverse of the example above:
'
&
$
%
s = ’Enter speed in m/s ’;
sp_mps = input(s);
sp_cmps = sp_mps*100;
sp_inch_ps = sp_cmps/2.54;
sp_yard_ps = sp_inch_ps/36;
sp_miles_ps = sp_yard_ps/1760;
sp_mph = sp_miles_ps *3600;
disp([’Speed in mph is ’ ...
num2str(sp_mph)])
(c) We now take the solution above and convert it to be a function, so we have

400
C. Solutions to Tasks
'
&
$
%
function [output] = change(input);
sp_mph = input;
sp_yards_ph = sp_mph*1760;
sp_inch_ph = sp_yards_ph*36;
sp_cm_ph = sp_inch_ph*2.54;
sp_m_ph = sp_cm_ph/100;
sp_km_ph = sp_m_ph/1000;
output = sp_km_ph;
(d) This shows that a sprinter will run at 22 mph on average since they do 100
metres in 10 seconds, that is 10 metres per second.
Solution 2.12 This is accomplished using the code:
'
&
$
%
x = linspace(-pi/2,pi/2);
f = x./(1+x.ˆ2);
g = tan(x);
fg = g./(1+g.ˆ2);
gf = f./(1+f.ˆ2);
plot(x,fg,x,gf)
Solution 2.13 This is done using the code:
'
&
$
%
a = input(’Coefficient of x squared: );
b = input(’Coefficient of x:’);
c = input(’The constant:’);
y = linspace(0,pi);
x = sin(y);
q = a*x.ˆ2+b*x+c;
plot(y,q)
C.3 Solutions for Tasks from Chapter 3
Solution 3.1 The required code is:

C.3 Solutions for Tasks from Chapter 3
401
#
"
 
!
s = 0;
for i = 1:100
s = s+1/iˆ2;
end
disp([’Required value is ’ num2str(s)])
Notice that we have changed the command int2str to num2str: this is because
the answer is no longer an integer.
Solution 3.2 This only requires modiﬁcation of the for line to for i=1:2:100,
which gives a vector which increases in twos.
Solution 3.3 The code f.m needs to be changed to




function [value] = f(i)
value = sin(i*pi/2)/(iˆ2+1);
and then use the same code.
Solution 3.4 This is accomplished using the code:




x = 0:pi/4:pi;
f = x.ˆ2+1;
Solution 3.5 The code requires very minor modiﬁcation to:
'
&
$
%
v = 0.:0.25:0.75;
cosx = zeros(size(v));
N = 10; range = 0:N;
ints = 2*range;
for n = range
cosx = cosx + ...
(-1)ˆn*v.ˆints(n)/factorial(ints(n));
end
This gives very accurate answers:

402
C. Solutions to Tasks
cos(v)-cosx
ans =
0
0
0
0
This means that the diﬀerence between the MATLAB and the series answers
are less than eps.
Solution 3.6 We can use code which performs the summations separately for
diﬀerent values of N or note that SN+1 = SN + 1/(N + 1)2 where S1 = 1.
This leads to the simple code:




s(1) = 1;
for n = 1:2000
s(n+1) = s(n)+1/(n+1)ˆ2;
end
This gives a value which when divided by π2 allows one to appreciate that c ∼6.
In fact
∞

i=1
1
n2 = π2
6 .
Solution 3.7 We solve this task by using a nested loop structure
'
&
$
%
for p = 1:4
sum = 0;
for j = 1:(p+1)
sum = sum + jˆp;
end
disp([’ sum for p=’ ...
int2str(p) ’ is ’ int2str(sum)])
end
Solution 3.8 The codes for this task are:

C.3 Solutions for Tasks from Chapter 3
403
'
&
$
%
sumln(1) = -1;
for n = 1:1000
sumln(n+1) = sumln(n)+(-1)ˆ(n+1)/(n+1);
end
sum2(1) = 1/2;
for n = 1:1000
sum2(n+1) = sum2(n)+1/((n+1)*(n+2));
end
where we have used the terms in the summations evaluated at the (N + 1)th
place.
Solution 3.9 The simplest way of doing this would be x>2&x<4, although there
are other ways ∼xor(x>=2,x=<4) for instance. The second example can be
done with xorusing xor(x>3,x<-1) or with or using x>3|x<-1 (you can use
both since the sets are disjoint).
Solution 3.10 mod(n,2)==0 tells us that the remainder when dividing by two
is zero (that is n is even). In order to ensure that this is only true for values
of n > 20 we need the statement mod(n,2)==0 & n>20.
Solution 3.11 This requires us to work out tan(73π/4) but since tan is peri-
odic this is equal to tan(π/4) (which is one). Hence the ﬁrst condition is true
so x is set to 2 and as this is an integer floor(x) is equal to x and so x is set
to 10, which is not prime so x is returned as the string “False”. This changes
with the initial value of x, try for instance x = 3.
Solution 3.12 This uses
#
"
 
!
start = 1/7;
next = mod(5*start,1)
while floor(next*7) ˜= floor(start*7)
next = mod(5*next,1)
end
Here we have used quite a complicated structure to deal with the rounding errors
intrinsic to MATLAB (noting that the only possible answers are n/7 where
n ∈N).

404
C. Solutions to Tasks
Solution 3.13 We have




n = 1:50;
f = n.ˆ3-n.ˆ2+40;
ii = find(f > 1000 & mod(n,3) ˜= 0);
n(ii)
Solution 3.14 The key here is to start with the string of the ﬁrst ten letters,
namely “abcdefghij”. We ask the user to enter the ﬁrst value of n outside the
while loop: this avoids the need for the first ﬂag. The required code is then:
'
&
$
%
str = ’abcdefghij’;
msg = ’Enter an integer from 1 to 10: ’;
n = input(msg);
while (round(n)˜=n) | (n<1 | n>10)
warning(’ Not valid ’)
n = input(msg);
end
str(1:n)
Solution 3.15 Although this problem can be solved in one code it is preferable
to use a couple of functions. The ﬁrst one checks whether a character is a letter
(lower or upper case):
'
&
$
%
function [val] = isletter(charac)
lchar = lower(charac(1));
if lchar>=’a’ & lchar <=’z’
val = 1;
else
val = 0;
end
Firstly the ﬁrst character is extracted and converted to lower case. Then a check
is made to see if it is a character in the lower case alphabet: if it is the variable
val is set to be true (that is 1). A similar code checks for whether a character
is a digit:

C.3 Solutions for Tasks from Chapter 3
405
'
&
$
%
function [val] = isdigit(charac)
lchar = charac(1);
if lchar>=’0’ & lchar <=’9’
val = 1;
else
val = 0;
end
We can now use the functions:
'
&
$
%
msg = ’Please enter a letter and a digit ’;
str = input(msg,’s’);
while ˜isletter(str(1)) | ˜isdigit(str(2))
warning(’This is not valid’)
str = input(msg,’s’);
end
The argument of the while loop checks to see if either of the conditions isn’t
satisﬁed (and as such uses or, that is the vertical line).
Solution 3.16 This can be done with the code:
'
&
$
%
x = linspace(-3,5,100);
for i = 1:length(x)
if x(i) >= -1 & x(i) <= 1
f(i) = x(i)ˆ2;
elseif x(i) > 1 & x(i) < 4
f(i) = 1;
else
f(i) = 0;
end
end
plot(x,f)
axis([-3 5 -0.5 1.5])
The ﬁnal command is added purely so that the curve can be distinguished from
the axis. This gives

406
C. Solutions to Tasks
−3
−2
−1
0
1
2
3
4
5
−0.5
0
0.5
1
1.5
Solution 3.17 Here we use the code
'
&
$
%
x = -3:0.1:3;
g = cos(pi*x);
izero = find(abs(g)<=1e-15);
ii = find(abs(g)>=1e-15);
f(izero) = NaN;
f(ii) = 1./g(ii);
plot(x,f)
which gives

C.3 Solutions for Tasks from Chapter 3
407
−3
−2
−1
0
1
2
3
−4
−3
−2
−1
0
1
2
3
4
and the choice of 10−15 is in a sense arbitrary, but reﬂects how close we come
to the singularities.
Solution 3.18 The ﬁrst line contains a spelling mistake: the command should
be linspace. The second line is missing brackets around x and a semicolon.
In the deﬁnition of the for loop we should have used a colon rather than a
semicolon. In both the logical expressions on the if and the elseif lines the
second reference to the array x uses i rather than j. The ﬁrst logical expression
should use an ampersand (&) rather than the word and; similarly the second
one should also have an ampersand rather than the word or. The ﬁrst part of
the second expression x(j) should be checked to be greater than one or equal to
one (although this change is academic). The following line should refer to x(j)
rather than the entire vector x, and should be ﬁnished oﬀwith a semicolon.
The variable zero is used without deﬁnition. Finally we are missing an end
statement to balance with the for; a fact which would be clear if the correct
indentation was used.
The corrected code is:

408
C. Solutions to Tasks
'
&
$
%
x = linspace(-4,4);
N = length(x);
for j = 1:N
if x(j) >= 0 & x(j) <= 1
f(j) = x(j);
elseif x(j) >= 1 & x(j) < 2
f(j) = 2 - x(j);
else
f(j) = 0;
end
end
C.4 Solutions for Tasks from Chapter 4
Solution 4.1 The solution to this task involves noting that the zeros of a func-
tion f(x) = g(x)h(x) will occur at the zeros of the functions g(x) and h(x),
provided neither of the functions are singular. In this case g(x) = x is zero at
x = 0 and h(x) = sin x is zero at 0, π, 2π and 3π (within the range [0, 10]).
Solution 4.2 We note that cosh x = (ex + e−x)/2 so in order for cosh x to be
zero we require that ex = −e−x or multiplying through by ex that e2x = −1, but
since ex > 0 for all x, this can never be so. Consequently cosh x is never zero.
Similarly for sinh x we ﬁnd that e2x = 1 which is only true when x = 0, which
is the single isolated zero of sinh x. The zeros of the function of f(x) occur at
the zeros of coshm x and sinhn x, which are only at x = 0 (in which case it is
an n-fold zero).
Solution 4.3 We consider the discriminant of the equation, which is b2 −4.
For two real roots we have b2 > 4, in which case |b| > 2, for one real root the
discriminant is zero, so that b = 2 and ﬁnally for complex roots the discriminant
is negative so that |b| < 2. This can be veriﬁed graphically using:

C.4 Solutions for Tasks from Chapter 4
409




b = input(’Value of b ’);
x = -10:0.1:10;
f = x.ˆ2+b*x+1;
plot(x,f)
Notice that we have chosen the range [−10, 10] but we could have used knowledge
of the structure of the function to make sure that both roots were on the image
(where |b| > 2).
Solution 4.4 We shall try to write the equation in the form
cos θ sin x + sin θ cos x
cos θ
in which case tan θ = β, in which case sin θ = β/

1 + β2 and cos θ =
1/

1 + β2. Now the function f(x) can be written as
f(x) = sin(θ + x)
cos θ
,
which has zeros at sin(θ+x) = 0, hence x = nπ−θ where θ = sin−1(β/

1 + β2)
(which is evaluated in MATLAB using asin). If β = 0 then θ = 0 and if β = 1
then θ = π/4.
Solution 4.5 The equation f(x) = 0 can be rewritten in many forms but
we choose x = cos−1(sin x/2) so that a ﬁxed point scheme would be xn+1 =
cos−1 ((sin xn)/2) and the corresponding code is:




function g = eqn(x)
g = acos(sin(x)/2);
The roots of this function can be determined analytically using a similar method
to the previous example and are found to be nπ + θ where θ = sin−1(2/
√
5).
Solution 4.6 The roots of this equation occur at
xb = −b ±
√
b2 −4
2
.
Firstly considering the option g(x) = −(x2 + 1)/b we have that g′ = −2x/b
which at the roots is
g′(xb) = 1 ∓
)
1 −4
b2 .

410
C. Solutions to Tasks
Considering |b| > 2 the modulus of this function is greater than one for the
root corresponding to the negative sign and less than one for the root with the
positive sign. For the other option we ﬁnd that
g′(x) =
b
2

−(bx + 1)
.
When the roots are substituted in we ﬁnd that the above situation is reversed.
Using the code




function g = eqn(x)
b = 3;
g = -(xˆ2+1)/b;
or with the alternative ﬁnal line g = -sqrt(-(b*x+1)); we ﬁnd starting with
an initial guess of −1 we get diﬀerent roots depending on which ﬁxed point
scheme we use.
Solution 4.7 We change the ﬁle func.m to be




function [f] = func(x)
f = 2*x.ˆ2-x.ˆ3+sin(x);
Using the routine we produce the plot
1
1.2
1.4
1.6
1.8
2
2.2
2.4
2.6
2.8
3
−10
−8
−6
−4
−2
0
2
4
Using 2 and 3 as the ends of the range we obtain
>> mbisect
Root = 2.1741 found in 14 iterations
with a tolerance of 1 × 10−4.

C.4 Solutions for Tasks from Chapter 4
411
Solution 4.8 The function f(x) = cos 3x has three zeros in the range 0 to π.
Using the full range, we encounter the left root π/6 (in fact we should check
whether f((b + a)/2) is smaller than the tolerance, which it is in this case. For
the other two ranges we can select the lower or upper root. We note that the
scheme still works for an odd number of roots (since the scheme eliminates
them in pairs).
Solution 4.9 This is merely a matter of setting up the routines




function [f] = func(x)
f = x.*cos(x)-sin(x);




function [fp] = func_prime(x)
fp = -x.*sin(x);




function [f] = func(x)
f = (x.ˆ3-x).*sin(x);




function [fp] = func_prime(x)
fp = (3*x.ˆ2-1).*sin(x) ...
+(x.ˆ3-x).*cos(x);
The roots of the ﬁrst function are at x = 0 and x ≈±4.41 and many other
roots which tend to the zeros of cos x (as x increases).
The other function has zeros at x = 0 and 1, and then at nπ where n ∈Z.
Solution 4.10 The zeros of this function occur where x −x3 = nπ. In order
to obtain initial estimates for the range we plot the function

412
C. Solutions to Tasks
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
Now using the code False Position.m:
>> False_Position
Starting guess point 1 :0.8
Starting guess point 2 :1.2
Root = 0.9999999982 found in 12 iterations.
>> False_Position
Starting guess point 1 :1.6
Starting guess point 2 :1.8
Root = 1.690631797 found in 4 iterations.
The ﬁrst root corresponds to n = 0 above. We note that the function gets very
oscillatory as x increases and may pose problems as more roots are required, in
which case the roots of the cubic x −x3 = nπ can be sought, using for instance
roots.
Solution 4.11 We use the code on page 124 which calls:




function [f,fp,fpp] = fun2(x);
f = x.ˆ3-4*x.ˆ2+5*x+2;
fp = 3*x.ˆ2-8*x+5;
fpp = 6*x.ˆ2-8;
The roots are at 1 (twice) and 2.
Solution 4.12 The roots can be calculated using the inline code roots([1 1
1 1]) and roots([1 0 0 1 -2 -4]).

C.4 Solutions for Tasks from Chapter 4
413
Solution 4.13 This can be done using the code




function [f]=func1(x)
f = x.*sin(x)+cos(x);
and then use the code fzero(’ff’,3) which gives the root ≈2.7984. There are
many others. For the other cases the roots are: sin x = 0 or sin x = ±1, so that
x = nπ/2 (n ∈Z); in this case fzero fails and returns a root at x = 1. The
code has mistaken the fact that the function changes sign for a root.
Solution 4.14 The function J1/2(x) is actually sin x/√x and consequently the
roots are nπ. The code needed for fzero is




function [f] = ourbess(x)
f = besselj(1/2,x);
and then fzero(’ourbess’,3).
Solution 4.15 The function we want to ﬁnd the zeros of is f(x) = x sin x −
x2 cos x −1 which has derivative f ′(x) = sin x + x cos x −2x cos x + x2 sin x =
(1 + x2) sin x −x cos x. The correct deﬁnitions for f(x) and f ′(x) are:




function [out] = f(in)
out = in.*sin(in)-in.ˆ2.*cos(in)-1;
f.m




function [out] = fp(in)
out = (1+in.ˆ2).*sin(in)-in.*cos(in);
fp.m
and the code to use these would be




x = 0;
for j = 1:10
x = x -f(x)/fp(x);
end
(notice that the second term in this expression was the wrong way up in the
question). This code could be written far more eloquently.

414
C. Solutions to Tasks
C.5 Solutions for Tasks from Chapter 5
Solution 5.1 This code inputs four values which represent the points (x1, y1)
and (x2, y2). These are then made into vectors x and y, where the former con-
tains the x coordinates and the latter the y coordinates. The command polyfit
ﬁts a straight line through the points and returns y = mx + c, where the gra-
dient m is the ﬁrst element of p and the intercept c is the second. Then the
ﬁnal command displays the result. If the user enters both values of y, the same
equation is just returned as m = 0 and c equals that value. On the other hand
if two values of x are the same then MATLAB tries to give the line an inﬁnite
gradient, since it should be of the form x = d.
Solution 5.2 We write the quadratic as y = a + b(x −x0) + c(x −x0)(x −x1)
where we choose x0 as the x coordinate of one of the points. For convenience
we shall take the origin as the ﬁrst point so that x0 = 0 and we see that
a = 0. Using the point (2, −1) as the next point we note that the quadratic is
y = bx + cx(x −2) and −1 = 2b. Finally the condition that the curve goes
through the ﬁnal point yields the equation 5 = −5/2 + 15c so that c = 1/2.
Hence the quadratic is
y = −1
2x + 1
2x(x −2)
= x(x −3)
2
.
Solution 5.3 We use the code:
'
&
$
%
x = 0:10;
co = [1 3 2];
y = x.ˆ2+3*x+2;
for i = 1:3
xv = i-0.5;
p = polyfit(x(i:(i+1)),y(i:(i+1)),1);
err(i) = polyval(p,xv)-polyval(co,xv);
end
This gives the same error in each case, namely 1/4 (which we would expect from
understanding the error associated with this method of interpolation (consider
the second derivative)).
Solution 5.4 This quadratic will be of the form cx(π −x) (since it is zero at

C.5 Solutions for Tasks from Chapter 5
415
0 and π). The value of c can be determined from the condition that the curve
goes through the ﬁnal point which gives
y = 4x
π2 (π −x).
Solution 5.5 Since the cubic is zero at the points 0 and π we know that it is of
the form x(π−x)(a(x−π/2)+b). The values of a and b can be determined from
the other points: (π/2, 1) gives b = 4/π2; ﬁnally (−π/2, −1) gives a = 16/(3π2).
Hence the cubic is
y = x(π −x)
 16
3π3 (x −π/2) + 4
π2

= x(π −x)
16x
3π3 x +
4
3π2

.
Solution 5.6 For this we shall use the MATLAB command spline so that
#
"
 
!
x = -pi:(pi/2):pi;
y = [0 -1 0 1 0];
z = -pi:(pi/20):pi;
f = spline(x,y,z);
plot(z,f,x,y,’o’,’MarkerSize’,14)
This gives:
−4
−3
−2
−1
0
1
2
3
4
−1.5
−1
−0.5
0
0.5
1
1.5

416
C. Solutions to Tasks
Solution 5.7 Here we shall use the method of least squares. As such we shall
produce details of the formulation. We calculate the sum of the squares of the
errors:
e =
n

i=1
(a sin xi + b cos xi −fi)2
and partially diﬀerentiating with respect to a and b we have
∂e
∂a =
n

i=1
sin xi(a sin xi + b cos xi −fi)
∂e
∂b =
n

i=1
cos xi(a sin xi + b cos xi −fi).
These equations can be rewritten in matrix form as:
⎛
⎜
⎜
⎝
n
i=1
sin2 xi
n
i=1
sin xi cos xi
n
i=1
cos xi sin xi
n
i=1
cos2 xi
⎞
⎟
⎟
⎠
 a
b

=
⎛
⎜
⎜
⎝
n
i=1
fi sin xi
n
i=1
fi cos xi
⎞
⎟
⎟
⎠.
This can be solved using the code:
'
&
$
%
x = 0:0.1:1.0;
f = [3.16 3.01 2.73 2.47 2.13 1.82 ...
1.52 1.21 0.76 0.43 0.03];
A = [sum(sin(x).ˆ2) sum(cos(x).*sin(x)); ...
sum(cos(x).*sin(x)) sum(cos(x).ˆ2)];
r = [sum(f.*sin(x)); sum(f.*cos(x))];
sol = A\r;
This gives
sol =
-1.9941
3.1892
The original data was actually generated with −2 and 3.2, and then noise was
added.
Solution 5.8 This can be done by hand but in fact MATLAB will actually
return the required coeﬃcients.

C.5 Solutions for Tasks from Chapter 5
417
'
&
$
%
x = -pi:(pi/2):pi;
y = [0 -1 0 1 0];
z = -pi:(pi/10):pi;
pp = spline(x,y);
f = spline(x,y,z);
plot(z,f,x,y,’o’,’MarkerSize’,14)
true = sin(z);
err = sum((true-f).ˆ2);
This gives
−4
−3
−2
−1
0
1
2
3
4
−1.5
−1
−0.5
0
0.5
1
1.5
and
>> pp.coefs
ans =
-0.0860
0.8106
-1.6977
0
-0.0860
0.4053
0.2122
-1.0000
-0.0860
0.0000
0.8488
0
-0.0860
-0.4053
0.2122
1.0000
which are the four cubic equations (given with the coeﬃcients of x3 ﬁrst). The
total sum of the errors was 0.1944.

418
C. Solutions to Tasks
Solution 5.9 The corrected code is:
'
&
$
%
x = 2:11;
f = polyval([1 0 0 -1],x) + sin(x);
% x = 4.5
r = 3:4;
c = polyfit(x(r),f(r),1);
yy = polyval(c,4.5)
% x = 15 (extrapolation)
r = length(x)-1:length(x);
c = polyfit(x(r),f(r),1);
yy = polyval(c,15);
C.6 Solutions for Tasks from Chapter 6
Solution 6.1 These calculations can be repeated using the code
'
&
$
%
A = [3 0 -1; -4 2 2];
B = [-1 7; 3 5; -2 0];
C = [2 0; -1 -3];
A*B
B*A
A+transpose(B)
A*C
A*transpose(C)
3*C+2*transpose(A*B)
(A*B)*C
A*(B*C)
Solution 6.2 Notice that here we set up the matrix A before changing the ele-
ments and this is unnecessary but good practice. Also it is not necessary to set
up r and this can be deﬁned inline. The deﬁnition of r allows for more versatile
code.

C.6 Solutions for Tasks from Chapter 6
419




r = 1:4;
A = zeros(4);
A(1,r) = r;
A(r,4) = flipud(r’);
Note that the ﬁnal command could also be replaced by A(flipud(r),1)=r’;;
you should try to understand this command.
Solution 6.3 Here we rely on the fact that MATLAB knows that a matrix with
a super- or sub-diagonal of length 9 is a ten-by-ten matrix.




a = diag(ones(1,9),1)+diag(-ones(1,9),-1);
Solution 6.4 This is just a matter of typing the commands: however you
should be able to decide which ones are viable before doing this.
Solution 6.5 The code to solve these problems is given by:
'
&
$
%
A = [ 1 2; 3 4];
B = [3 4; -1 2];
A*B
C = [3 5; 6 -2];
D = [-1 0; 2 1];
2*C-4*D
E = [1 3 5];
F = [2 -1; -1 0; 7 -2];
E*F
This gives the answers
ans =
1
8
5
20
ans =

420
C. Solutions to Tasks
10
10
4
-8
ans =
34
-11
Solution 6.6 Consider a general matrix
A =
 a
b
c
d

multiplied by the matrix
X =
 α
β
β
α

.
Now
XA =
 αa + βc
αb + βd
βa + αc
βb + αd

and
AX =
 αa + bβ
aβ + bα
cα + dβ
cβ + dα

.
Now comparing XA and AX we ﬁnd that it is necessary for a = d and b = c
(provided β ̸= 0). Hence the only matrices which commute with matrices of the
form X are those of the same form.
'
&
$
%
stl = ’Top left element of matrix ’;
sbl = ’Bottom left element of matrix ’;
for j = 1:2
a(j) = input([stl num2str(j) ’: ’]);
b(j) = input([sbl num2str(j) ’: ’]);
end
A = [a(1) b(1); b(1) a(1)];
B = [a(2) b(2); b(2) a(2)];
disp(A*B)
disp(B*A)
Notice that the answer is also of the form X.

C.6 Solutions for Tasks from Chapter 6
421
Solution 6.7 The (i, j)th element of B is ai,j + aj,i and the (j, i)th element is
aj,i + ai,j (which are equal so B is symmetric). Similarly the (i, j)th element
of C is ai,j −aj,i, whereas the (j, i)th element is minus this, namely aj,i −ai,j
so that C is anti-symmetric.
Solution 6.8 These matrices can be constructed in MATLAB
'
&
$
%
theta = 0;
A0 = [cos(theta) sin(theta); -sin(theta) cos(theta)];
theta = pi/2;
A1 = [cos(theta) sin(theta); -sin(theta) cos(theta)];
theta = pi;
A2 = [cos(theta) sin(theta); -sin(theta) cos(theta)];
or mathematically and we ﬁnd
A|θ=0 =
 1
0
0
1

,
A|θ=π/2 =

0
1
−1
0

,
and ﬁnally
A|θ=π =
 −1
0
0
−1

.
Working through the cases one at a time
θ = 0 This gives us the identity matrix, so multiplying leaves all points un-
changed.
θ = π/2 Here if we start with x = (x, y)T Ax is (y, −x)T . This moves the point
round the origin by (unsurprisingly) π/2.
θ = π Now the action is to return (−x, −y)T , which is a reﬂection in the origin
(or in fact a rotation of π).
In general the action of multiplying by this matrix is to rotate by θ radians.
We can work out the inverse of this matrix by noting that its determinant
is unity and switching the terms on the leading diagonal and then multiplying
the oﬀdiagonal terms by minus one. However, we could also exploit the fact
that in order to invert the operation of rotating by an angle θ we merely rotate
by θ in the other sense (or more speciﬁcally by −θ). The inverse is given by
A−1 =

cos(−θ)
sin(−θ)
−sin(−θ)
cos(−θ)

=
 cos θ
−sin θ
sin θ
cos θ

.

422
C. Solutions to Tasks
This is easily veriﬁed by performing the multiplication of the matrices
 cos θ
−sin θ
sin θ
cos θ
 
cos θ
sin θ
−sin θ
cos θ

=

cos2 θ + sin2 θ
cos θ sin θ −sin θ cos θ
sin θ cos θ −cos θ sin θ
sin2 θ + cos2 θ

=
 1
0
0
1

= I.
Solution 6.9 This is solved using the code:




A = [3 4; -1 2];
b = [2 ; 0];
x = A\b;
which gives x = 2/5 and y = 1/5.
Solution 6.10 This is solved using the code:




A = [1 1 2; 1 -1 -3; ...
-2 -5 1];
b = [1; 0 ; 4];
x = A\b
This gives x = 4/5, y = −1 and z = 3/5.
Solution 6.11 We are able to add A and B since they are of the same size,
namely they both have three rows and two columns.
⎛
⎝
1
−1
0
2
3
2
⎞
⎠+
⎛
⎝
2
−1
−1
0
3
2
⎞
⎠=
⎛
⎝
3
−2
−1
2
6
4
⎞
⎠.
The matrices A and C can be multiplied together since the number of columns
of A (two) matches the number of rows of C.
⎛
⎝
1
−1
0
2
3
2
⎞
⎠
 −1
0
2
1

=
⎛
⎝
1 × (−1) + (−1) × 2
1 × 0 + (−1) × 1
0 × (−1) + 2 × 2
0 × 0 + 2 × 1
3 × (−1) + 2 × 2
3 × 0 + 2 × 1
⎞
⎠
=
⎛
⎝
−3
−1
4
2
1
2
⎞
⎠.

C.6 Solutions for Tasks from Chapter 6
423
The multiplication of C times B is not possible since the number of columns of
C (two) is not equal to the number of rows of B (three).
First we calculate A−B (which is possible since both matrices are the same
size). This gives another matrix of the same size (again with three rows and
two columns), which can now multiply C since this has two rows. The answer
is
⎛
⎝
1
0
3
2
0
0
⎞
⎠
The ﬁnal calculation should give the same answer. The MATLAB code for
these calculations is:
>> a = [1 -1; 0 2; 3 2];
>> b = [2 -1; -1 0; 3 2];
>> c = [-1 0; 2 1];
>> a+b
ans =
3
-2
-1
2
6
4
>> a*c
ans =
-3
-1
4
2
1
2
>> (a-b)*c
ans =
1
0
3
2
0
0
>> a*c-b*c
ans =

424
C. Solutions to Tasks
1
0
3
2
0
0
Solution 6.12 These calculations can both be performed and the solutions are
 3
10

and
 16
−2
9
−3
0
2
−5
−1

which can be checked using MATLAB
>> [1 -1 2; 3 0 1]*[3; 2; 1]
ans =
3
10
>> [5 -2;-1 2]*[4 0 1 -1; 2 1 -2 -1]
ans =
16
-2
9
-3
0
2
-5
-1
Solution 6.13 The results of both calculations merely returns the matrix un-
changed. This is the eﬀect of multiplying by the identity.
Solution 6.14 Firstly, we reﬂect in the leading diagonal to give AT so that
AT =
⎛
⎝
3
0
2
−1
−1
−2
⎞
⎠
The results of the multiplications are
 14
0
0
5

and
⎛
⎝
9
6
−3
6
5
0
−3
0
5
⎞
⎠,
which can also be done using MATLAB code:

C.6 Solutions for Tasks from Chapter 6
425
>> A = [3 2 -1; 0 -1 -2];
>> A*transpose(A)
ans =
14
0
0
5
>> transpose(A)*A
ans =
9
6
-3
6
5
0
-3
0
5
Solution 6.15 We assume that a general row vector is of the form
(x1, x2, · · · , xN)
and consequently its transpose is the column vector
xT =
⎛
⎜
⎜
⎜
⎝
x1
x2
...
xN
⎞
⎟
⎟
⎟
⎠
Hence
xxT =

x1
x2
· · ·
xN

⎛
⎜
⎜
⎜
⎝
x1
x2
...
xN
⎞
⎟
⎟
⎟
⎠= x2
1 + x2
2 + · · · + x2
N.
This is a scalar which is positive since it is merely the sum of squares.
Solution 6.16 The matrix equation can be expanded to give
x + 4y = 1
−2x + 3y = −2

426
C. Solutions to Tasks
and the three simultaneous equations can be written as the single matrix equa-
tion
⎛
⎝
1
1
1
1
−2
−1
−1
3
−1
⎞
⎠
⎛
⎝
x
y
z
⎞
⎠=
⎛
⎝
0
2
−1
⎞
⎠.
Solution 6.17 We simply present the code which can be used to determine the
character of the systems (this exploits the code solns.m given on page 188)
'
&
$
%
a = [3 2; 3 -2]; b=[7; 7];
solns(a,b)
a = ones(6);
for r = 2:6
a(r,r) = -1;
end
b = ones(6,1);
solns(a,b)
This returns the comments:
There are 2 equations
with 2 variables
There is a unique solution
and for the second case
There are 6 equations
with 6 variables
There is a unique solution
Solution 6.18 This can be accomplished using
'
&
$
%
A = [1 0 0 -1; ...
-1 2 -1 0; ...
0 -1 2 -1;
0 0 0 1];
r = [0 1;0 0; 0 0; 1 0];
sols = A\r;
This gives
sols =

C.6 Solutions for Tasks from Chapter 6
427
1.0000
1.0000
1.0000
0.6667
1.0000
0.3333
1.0000
0
where we have solved both systems at once to give (1, 1, 1, 1) and (1, 2
3, 1
3, 0).
Solution 6.19 We use the code
'
&
$
%
s = pi:pi/3:(2*pi);
ns = length(s);
for j = 1:ns
ss = s(j);
A = [0 1 ss; ...
ss 0 1; ...
1 ss 0];
z(j) = det(A);
end
c = polyfit(s,z,3)
which gives c = (1, 0, 0, 1) so that the determinant of the matrix is s3 + 1.
Solution 6.20 We note that
B2 =

0
1
−1
0
 
0
1
−1
0

= −I.
As such we ﬁnd that B3 = BB2 = −BI = −B and that B4 = B2B2 =
(−I)(−I) = I. Hence we have the code
'
&
$
%
n = input(’What power :’);
b = [0 1; -1 0];
switch mod(n,4)
case 0
bn = eye(2);
case 1
bn = b;
case 2
bn = -eye(2);
case 3
bn = -b;
end

428
C. Solutions to Tasks
Solution 6.21 The eigenvalues can be determined using the code
#
"
 
!
a = [1 0 0 -1; ...
0 1 0 0; ...
0 0 1 0; ...
-1 0 0 1];
eig(a)
which gives 1 (twice), 0 and 2.
Solution 6.22 We start with n = 1 which is merely the deﬁnition, that is
A = PDP−1. And we assume that our conjecture is true for n, that is An =
PDnP−1. Now premultiply by A
AAn = A(PDnP−1)
An+1 = PDP−1(PDnP−1)
= PD(P−1P)DnP−1
= PDDnP−1
= PDn+1P−1.
This is merely the statement of our initial conjecture for n + 1. Thus we have
shown by induction that An = PDnP−1.
Solution 6.23 This gives
>> co = charpoly(a);
>> roots(co)
ans =
2.0000
1.0000 + 0.0000i
1.0000 - 0.0000i
0.0000
This conﬁrms the results above.
Solution 6.24 The eigenvalues of this equation are (3 ±
√
5)/2. Consequently
using the general form on page 216, we have

C.7 Solutions for Tasks from Chapter 7
429
x(t) =
1
√
5
1
2

(3 +
√
5)e(3−
√
5)t/2 −(3 −
√
5)e(3+
√
5)t/2	
I
+

e(3−
√
5)t/2 −e(3+
√
5)t/2	
A
* 
1
−1

.
C.7 Solutions for Tasks from Chapter 7
Solution 7.1 Please try it yourself ﬁrst but this is the answer (or one of them):
'
&
$
%
for i = 1:12
switch mod(i,3)
case 0
f(i) = 1;
case 1
f(i) = 2;
case 2
f(i) = 3;
end
end
There are many alternatives, for instance f = mod(1:12,3)+1;.
Solution 7.2 For the one third case, we can work through the code with N = 9,
so that
rodd=1:2:N gives [1 3 5 7 9]
reven=2:2:(N-1) gives [2 4 6 8]
weights(rodd=2) gives [2 0 2 0 2 0 2 0 2]
weights(1)=1 gives [1 0 2 0 2 0 2 0 2]
weights(N)=1 gives [1 0 2 0 2 0 2 0 1]
weights(reven)=4 gives = [1 4 2 4 2 4 2 4 1]

430
C. Solutions to Tasks
and for the three eighths rule with N = 10 we have
m=(N-1)/3 gives 3
rdiff=3*(1:(m-1))+1 gives [3*(1:2)+1] that is [4 7]
weights=3*ones(1,N) gives [3 3 3 3 3 3 3 3 3 3]
weights(1) gives [1 3 3 3 3 3 3 3 3 3]
weights(N) gives [1 3 3 3 3 3 3 3 3 1]
weights(rdiff)=2 gives [1 3 3 2 3 3 2 3 3 1]
Solution 7.3 This is done using the code:




function [val] = fn(x)
val = log(x+sqrt(x.ˆ2+1));
Solution 7.4 We shall use forty points (which should be more than enough)
and note that the exact answer is
3
"
x=1
x2 −3x + 2 dx =
x3
3 −3x2
2
+ 2x
3
1
= 2
3.
The code is
#
"
 
!
N = 40;
x = linspace(1,3,N);
f = x.ˆ2-3*x+2;
h = x(2)-x(1);
integral = (sum(f)-f(1)/2-f(N)/2)*h;
This gives the value 0.6675, which is within 8.7 × 10−4 of the exact answer.
Notice that by using either of Simpson’s rules we could have retrieved the exact
answer, since the original curve is a quadratic.
Solution 7.5 We use N = 11 and modify Simpson’s 1/3 rule code on page
233, so that we have

C.7 Solutions for Tasks from Chapter 7
431
'
&
$
%
x = linspace(0,1,11);
h = x(2)-x(1);
N = length(x);
rodd = 1:2:N;
reven = 2:2:(N-1);
weights(rodd) = 2; weights(1) = 1;
weights(N) = 1; weights(reven) = 4;
f = x.ˆ3-x+1;
integral = h/3*sum(weights.*f);
disp([integral])
This gives an answer of 0.75. The exact answer is
1
"
0
x3 −x + 1 dx =
x4
4 −x2
2 + x
1
0
= 3
4.
So the scheme does exceedingly well and the error is of the order 10−16. This
is unsurprising since the error is proportional to the fourth derivative, which is
identically zero for a cubic.
Solution 7.6 In this task we produce a minor modiﬁcation of the previous
solution: the ﬁrst line needs to read x=linspace(0,pi,N); and the line deﬁning
f(x) needs modifying to f=sin(x). This now allows us to try diﬀerent values
of N, which we do with a loop structure:
'
&
$
%
Ns = 5:2:19;
for N = Ns
clear rodd reven weights f x
x = linspace(0,pi,N);
h = x(2)-x(1);
rodd = 1:2:N;
reven = 2:2:(N-1);
weights(rodd) = 2;
weights(1) = 1; weights(N) = 1;
weights(reven) =
4;
f = sin(x);
integral(N) = h/3*sum(weights.*f);
end
plot(Ns,abs(integral-2))
This gives

432
C. Solutions to Tasks
5
10
15
20
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
x 10
−3
where we have plotted the errors versus the number of points. We have used the
exact answer which is
π
"
0
sin x dx = [−cos x]π
0 = 2.
As we can see the errors tend to zero very rapidly. Of course sin x is a very
smooth function over this interval and if we had a more oscillatory function
more points would be needed.
Solution 7.7 We shall use the trapezium rule for simplicity. We also note that
the value of this integral over the truncated domain is:
a
"
0
1
√
x2 + 1
dx = sinh−1(a).
We note that sinh−1(a) = ln(a +
√
a2 + 1) so in fact the value of the integral
diverges, but very slowly.
We use the code:

C.7 Solutions for Tasks from Chapter 7
433
'
&
$
%
X = input(’Truncate at:’);
N = ceil(X)*3;
x = linspace(0,X,N);
h = x(2)-x(1);
f = 1./sqrt(x.ˆ2+1);
int = (sum(f)-f(1)/2-f(N)/2)*h
The second line ensures that the step sizes will be smaller than 1/3. This gives:
>> diverge
Truncate at:10
int =
2.9981
>> diverge
Truncate at:100
int =
5.2983
>> diverge
Truncate at:1000
int =
7.6009
which as we see increases as the truncation point increases. (The corresponding
values of arcsinh are 2.9982, 5.2983 and 7.6009; so that the integration does a
good job).
Solution 7.8 We can use the code:

434
C. Solutions to Tasks
'
&
$
%
theta = 0:pi/20:(pi/2-pi/20);
N = 20;
for it = 1:length(theta);
theta1 = theta(it);
clear grid f
grid = linspace(theta1,pi-theta1,N);
f = sqrt(1+cos(grid).ˆ2);
h = grid(2)-grid(1);
arclen(it) = (sum(f)-f(1)/2-f(N)/2)*h;
end
plot(theta/pi*180,arclen)
xlabel(’\theta degrees’)
ylabel(’Arc length’)
which gives
0
10
20
30
40
50
60
70
80
90
0
0.5
1
1.5
2
2.5
3
3.5
4
θ degrees
Arc length
Solution 7.9 Firstly we give details of the analytical solution:
10
"
0
cos x
x1/2 dx =
ϵ
"
0
cos x
x1/2 dx +
10
"
ϵ
cos x
x1/2 dx
For the ﬁrst of these integrals we approximate cos x by 1 −x2/2 (that is the

C.7 Solutions for Tasks from Chapter 7
435
ﬁrst two terms in its Taylor series).
ϵ
"
0
1
x1/2 −x3/2
2
dx =

2x1/2 −x5/2
5

=

2ϵ1/2 −ϵ5/2
5

.
We can now use the code
'
&
$
%
clear all
epsil = input(’Epsilon :’);
int1 = 2*epsilˆ(0.5)-epsilˆ(2.5)/5;
N = 100;
x = linspace(epsil,10,N);
h = x(2)-x(1);
f = cos(x)./sqrt(x);
int2 = (sum(f)-f(1)/2-f(N)/2)*h;
int = int1+int2;
The ﬁrst integral gives a signiﬁcant contribution.
Solution 7.10 The quadratic through the three points is
y(x) = a0 + (x −x0)∆a1 + (x −x0)(x −x1)a2
where the constants are
a0 = f0
a1 = f1 −f0
x1 −x0
a2 = (f2 −f0)(x1 −x0) −(f1 −f0)(x2 −x0)
(x1 −x0)(x2 −x0)(x2 −x1)
Now integrating
x2
"
x=x0
y(x) dx
x2
"
x=x0
a0 + (x −x0)a1 + (x −x0)(x −x1)a2 dx
Solution 7.11 Here we need to use the code




function [f] = fxlnx(x)
f = x.*log(x);

436
C. Solutions to Tasks
and then use the code quad(’fxlnx’,1,2). This gives 0.63629536463993 (us-
ing format long). The exact value can be calculated using integration by parts
2
"
x=1
q ln q dq =
1
2q2 ln q
2
x=1
−
2
"
x=1
q
2 dq
= 2 ln 2 −
q2
4
2
x=1
= 2 ln 2 −3
4.
The value of this expression agrees very well with that above.
C.8 Solutions for Tasks from Chapter 8
Solution 8.1 Let us ﬁrstly ﬁnd the exact solution. Start by dividing the equa-
tion through by y and then integrate with respect to t which gives
" 1
y
dy
dt dt = −
" √
t dt,
hence we have
ln y = −2
3t3/2 + C.
This can be rearranged to give
y = Ae−2
3 t
3
2
and the particular solution can be found by setting y(0) = 1, which gives A = 1.
In order to obtain the numerical solution the code should be modiﬁed to
'
&
$
%
dt = 0.05;
t = 0.0:dt:1.0;
y = zeros(size(t));
y(1) = 1;
for ii=1:(length(t)-1)
y(ii+1) = y(ii) + dt * (-y(ii)*sqrt(t(ii)));
end
exact = exp(-2/3*(t).ˆ(3/2));
plot(t,y,t,exact,’--’)

C.8 Solutions for Tasks from Chapter 8
437
This produces
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0.5
0.55
0.6
0.65
0.7
0.75
0.8
0.85
0.9
0.95
1
Notice that although this solution is “reasonable” it can be improved by reducing
the value of dt.
Solution 8.2 Let us start by considering the exact solutions to both diﬀerential
equations. Again start by dividing through by y and integrating with respect to
t, which gives
" 1
y
dy
dt dt =
"
±t dt,
hence
ln y = ±t2
2 + C
=⇒
y = Ae±t2/2.
In each calculation the value of the constant is unity, hence we have the solu-
tions
y = et2/2
and
y = e−t2/2.
The scheme for the solution of the equations is written as
yn+1 −yn
∆t
= ±tnyn,

438
C. Solutions to Tasks
which can be rearranged to give
yn+1 = yn + ±∆t tnyn = yn

1 + ±n∆t2
,
where we have used the fact that tn = n∆t.
Let us consider the ﬁrst case. Start with n = 0
y1 = 1
and now n = 1, etc.
y2 = 1

1 + 1
16

= 17
16,
y3 = 17
16

1 + 2
16

= 153
128,
y4 = 153
144

1 + 3
16

= 2907
2028 ≈1.419 .
The exact answer is e1/2 ≈1.648, hence the absolute error is |1.419 −e1/2| ≈
0.229 and the relative error is |1.419−e1/2|/e1/2 ≈0.139 (or this can be written
as 13.9%).
Now we can repeat the calculation for the other case
y1 = 1
and now n = 1, etc.
y2 = 1

1 −1
16

= 15
16
y3 = 15
16

1 −2
16

= 105
128
y4 = 105
128

1 −3
16

= 1365
2048.
Here the absolute error is ≈0.21378 whereas the relative error is 0.352 (or
around 35%). Despite the absolute errors being comparable the relative errors
are diﬀerent (due to the magnitude of the answers involved).
It is up to the individual as to which error is best to use and this generally
comes with experience.
Solution 8.3 The code for this task is

C.8 Solutions for Tasks from Chapter 8
439
'
&
$
%
dt = pi/10;
t = 0.0:dt:10.0*pi;
y = zeros(size(t));
y(1) = 0;
for ii=1:(length(t)-1)
y(ii+1) = y(ii) + dt * (sin(t(ii))+sin(y(ii)));
end
This produces the result
0
5
10
15
20
25
30
35
0
0.5
1
1.5
2
2.5
3
3.5
4
You can now change the step length, simply by changing the dt= line (it might
be a good idea to add a clear all statement at the top of the code as well).
Solution 8.4 First let us construct the exact solution to the equation. We need
to multiply through by an integrating factor, namely et/3, which gives
et/3 dy
dt + 1
3et/3y = −1
2tet/3
d
dt

yet/3	
= −1
2tet/3
and now integrating with respect to t we ﬁnd that
yet/3 = A −
" 1
2tet/3 dt.

440
C. Solutions to Tasks
Now integrating the right hand side by parts gives
yet/3 = A −
3
2tet/3

−
" 3
2et/3 dt

,
yet/3 = A −
3
2tet/3 −9
2et/3

.
Hence we have the solution
y = Ae−t/3 −
3
2t −9
2

.
Now applying the boundary condition gives A = −9/2. The solution is
y = 9
2

1 −e−t/3	
−3t
2 .
Now consider the discretised form of the equation, which is
yn+1 −yn
∆t
= −tn+1
2
−yn+1
3
,
which can be rearranged to give
yn+1 =
1
1 + ∆t
3

yn −∆ttn+1
2

.
Now with ∆t = 1/3 and n = 0 this gives
y1 =
1
1 + 1
9

0 −1
3
1
3 × 2

= 9
10

−1
18

= −1
20,
and now with n = 1
y2 = 9
10

−1
20 −1
3
2
3 × 2

= −29
200,
and ﬁnally for n = 2 which gives y3 = y(1)
y3 = 9
10

−29
200 −1
3
3
3 × 2

= −561
2000.
The code to produce this and the other required solutions is

C.8 Solutions for Tasks from Chapter 8
441
'
&
$
%
clear all
dt = 1/3;
t = 0.0:dt:1;
y = zeros(size(t));
y(1) = 0;
for ii = 1:(length(t)-1)
y(ii+1) = 1/(1+dt/3)*(y(ii)-dt*t(ii+1)/2);
end
ts = t; ys = y;
dt = 1/1000;
t = 0.0:dt:1;
y = zeros(size(t));
y(1) = 0;
for ii = 1:(length(t)-1)
y(ii+1) = 1/(1+dt/3)*(y(ii)-dt*t(ii+1)/2);
end
exact = 9/2*(1-exp(-t/3))-3/2*t;
plot(ts,ys,’*’,t,exact,t,y)
This gives the picture
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
−0.35
−0.3
−0.25
−0.2
−0.15
−0.1
−0.05
0
where the solution above is shown using stars.
Solution 8.5 The codes now become

442
C. Solutions to Tasks




function [value] = odes(t,y)
value = tˆ2-yˆ2;
and




y0 = 0;
tspan = [0 2];
[t,y] = ode45(’odes’,tspan,y0);
These give
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
Solution 8.6 The solution to this equation can be obtained by multiplying by
the integrating factor et and then integrating by parts. After application of the
initial condition we ﬁnd that
y(t) = t2 −2t + 2 −e−t.
The numerical solution can be determined using:

C.8 Solutions for Tasks from Chapter 8
443
'
&
$
%
N = 20;
t = linspace(0,2,N);
dt = t(2)-t(1);
y(1) = 1;
for j = 1:(N-1)
y(j+1) = y(j)+dt*(-y(j)+t(j)ˆ2);
end
ex = t.ˆ2-2*t+2-exp(-t);
This gives:
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
0.5
1
1.5
2
which is a reasonable match (the exact solution is shown with the asterisks).
Solution 8.7
1. The solution of this problem is:
y(x) = 2 sin x −x cos x + x(−2 sin 1 + cos 1 −1) + 1.

444
C. Solutions to Tasks
'
&
$
%
% Set up system
x = 0.0:0.1:1.0;
N = length(x);
h = x(2)-x(1);
a = 1/hˆ2*ones(size(x));
b = -2/hˆ2*ones(size(x));
c = 1/hˆ2*ones(size(x));
r = x.*cos(x);
a(1) = 0; b(1) = 1; r(1) = 1;
c(N) = 0; b(N) = 1; r(N) = 0;
% Forward sweep
for j = 2:N
b(j) = b(j)-c(j)*a(j-1)/b(j-1);
r(j) = r(j)-c(j)*r(j-1)/b(j-1);
end
% Final equation
y(N) = r(N)/b(N);
for j = (N-1):-1:1
y(j) = r(j)/b(j)-a(j)*y(j+1)/b(j);
end
which gives
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1

C.8 Solutions for Tasks from Chapter 8
445
2. The analytic solution here is:
y(x) = 2 sin x −x cos x −x −2 sin 1 + cos 1 + 1.
'
&
$
%
% Set up system
x = 0.0:0.1:1.0;
N = length(x);
h = x(2)-x(1);
a = 1/hˆ2*ones(size(x));
b = -2/hˆ2*ones(size(x));
c = 1/hˆ2*ones(size(x));
r = x.*cos(x);
a(1) = -1; b(1) = 1; r(1) = 0;
c(N) = 0; b(N) = 1; r(N) = 0;
% Forward sweep
for j = 2:N
b(j) = b(j)-c(j)*a(j-1)/b(j-1);
r(j) = r(j)-c(j)*r(j-1)/b(j-1);
end
% Final equation
y(N) = r(N)/b(N);
for j = (N-1):-1:1
y(j) = r(j)/b(j)-a(j)*y(j+1)/b(j);
end
which gives

446
C. Solutions to Tasks
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
−0.16
−0.14
−0.12
−0.1
−0.08
−0.06
−0.04
−0.02
0
3. The solution here is
y(x) = e−2x −1
e−2 −1 .
'
&
$
%
% Set up system
x = 0.0:0.1:1.0;
N = length(x);
h = x(2)-x(1);
a = (1/hˆ2+2/(2*h))*ones(size(x));
b = -2/hˆ2*ones(size(x));
c = (1/hˆ2-2/(2*h))*ones(size(x));
r = 0;
a(1) = 0; b(1) = 1; r(1) = 0;
c(N) = 0; b(N) = 1; r(N) = 1;
% Forward sweep
for j = 2:N
b(j) = b(j)-c(j)*a(j-1)/b(j-1);
r(j) = r(j)-c(j)*r(j-1)/b(j-1);
end
% Final equation
y(N) = r(N)/b(N);
for j = (N-1):-1:1
y(j) = r(j)/b(j)-a(j)*y(j+1)/b(j);
end

C.8 Solutions for Tasks from Chapter 8
447
which yields
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Solution 8.8 The exact solution here is
y(t) = 1
3

t −1
√
3 sin
√
3t

.
By discretising the equation we have
yn+1 = 2yn −yn−1 + ∆t2 (−3yn + tn) .
The initial conditions can be realised by setting y1 = 0 and y2 = 0 as a result
of the fact that y′(0) ≈(y2 −y1)/∆t = 0.
'
&
$
%
N = 20;
t = linspace(0,1,N);
dt = t(2)-t(1);
y(1) = 0;
y(2) = 0;
for j = 2:N-1
y(j+1) = 2*y(j)-y(j-1) ...
+dtˆ2*(3*y(j)+t(j));
end
ex = (t-sin(sqrt(3)*t)/sqrt(3))/3;

448
C. Solutions to Tasks
This gives
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.02
0.04
0.06
0.08
0.1
0.12
0.14
0.16
0.18
0.2
The numerical solution does reasonably initially: however as t increases the
solution diverges.
Solution 8.9 This equation can be solved in a similar manner to the previous
task: '
&
$
%
N = 20;
t = linspace(0,2,N);
dt = t(2)-t(1);
y(1) = 1;
y(2) = 1;
for j = 2:N-1
y(j+1) = 2*y(j)-y(j-1) ...
+dtˆ2*(t(j)*y(j)+sin(t(j)));
end
This gives:

C.8 Solutions for Tasks from Chapter 8
449
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
1
1.5
2
2.5
3
3.5
4
4.5
(the solution is expressible in terms of Airy functions, but this does not repre-
sent a great advantage to us).
This second problem can be solved by setting up the discretised system
yn+1 −2yn + yn−1
∆t2
+ tnyn = sin tn
with the conditions that y1 = 0 (y(0) = 0) yN = 0 (y(2) = 0).
'
&
$
%
N = 20;
t = linspace(0,2,N);
dt = t(2)-t(1);
A = zeros(N);
A = diag(-2/dtˆ2*ones(N,1)+t’,0) ...
+diag(1/dtˆ2*ones(N-1,1),-1) ...
+diag(1/dtˆ2*ones(N-1,1),1);
r = transpose(sin(t));
A(1,:) = 0;
A(1,1) = 1; r(1) = 0;
A(N,:) = 0;
A(N,N) = 1; r(N) = 0;
sol = A\r;
This gives:

450
C. Solutions to Tasks
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
−0.7
−0.6
−0.5
−0.4
−0.3
−0.2
−0.1
0
0.1
Solution 8.10 This equation can be integrated directly by dividing through by
y(t2 + 1). This gives
y′
y = −
2t
1 + t2
so that
y(t) =
1
1 + t2 .
The equation can be solved numerically using
'
&
$
%
N = 50;
t = linspace(0,5,N);
dt = t(2)-t(1);
y(1) = 1;
for j = 1:(N-1)
y(j+1) = y(j)-dt*2*t(j)*y(j)/(1+t(j)ˆ2);
end
ex = 1./(1+t.ˆ2);
This yields

C.8 Solutions for Tasks from Chapter 8
451
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Solution 8.11 This system can be written as
y′ =
⎛
⎝
0
1
0
0
0
1
2
1
−2
⎞
⎠y,
where y = (y, y′, y′′). Using MATLAB we ﬁnd that

452
C. Solutions to Tasks
'
&
$
%
>> A = [0 1 0; 0 0 1; 2 1 -2];
>> [V,D] = eig(A)
V =
-0.5774
-0.2182
0.5774
0.5774
0.4364
0.5774
-0.5774
-0.8729
0.5774
D =
-1.0000
0
0
0
-2.0000
0
0
0
1.0000
And hence we know that
eAt = VeDtV−1.
For convenience we shall use the non-normalised form of V so that
˜V =
⎛
⎝
−1
1
1
1
−2
1
−1
4
1
⎞
⎠and ˜V−1 =
⎛
⎝
−1
1
2
1
2
−1
3
0
1
3
1
3
1
2
1
6
⎞
⎠
Hence
eAt =
⎛
⎝
−1
1
1
1
−2
1
−1
4
1
⎞
⎠
⎛
⎝
e−t
0
0
0
e−2t
0
0
0
et
⎞
⎠
⎛
⎝
−1
1
2
1
2
−1
3
0
1
3
1
3
1
2
1
6
⎞
⎠
=
⎛
⎝
−1
1
1
1
−2
1
−1
4
1
⎞
⎠
⎛
⎝
−e−t
1
2e−t
1
2e−t
−1
3e−2t
0
1
3e−2t
1
3et
1
2et
1
6et
⎞
⎠
=
⎛
⎝
e−t −1
3e−2t + 1
3et
−1
2e−t + 1
2et
−1
2e−t + 1
3e−2t + 1
6et
−e−t + 2
3e−2t + 1
3et
1
2e−t + 1
2et
1
2e−t −2
3e−2t + 1
6et
e−t −4
3e−2t + 1
3et
−1
2e−t + 1
2et
−1
2e−t + 4
3e−2t + 1
6et
⎞
⎠.
The solution is obtained by multiplying (0, 0, 1)T (the initial conditions) by this
matrix
eAt
⎛
⎝
0
0
1
⎞
⎠=
⎛
⎝
−1
2e−t + 1
3e−2t + 1
6et
1
2e−t −2
3e−2t + 1
6et
−1
2e−t + 4
3e−2t + 1
6et
⎞
⎠.

C.8 Solutions for Tasks from Chapter 8
453
Finally we have the answer
y(t) = −1
2e−t + 1
3e−2t + 1
6et.
Solution 8.12 This is solved using the ﬁnite diﬀerence code:
'
&
$
%
N = 20;
x = linspace(0,pi,N);
h = x(2)-x(1);
% Only the internal points
A = diag(-2/hˆ2*ones(N-2,1) ...
+sin(x(2:(N-1)))’,0) ...
+diag(1/hˆ2*ones(N-3,1),1) ...
+diag(1/hˆ2*ones(N-3,1),-1);
[V,D] = eigs(A,3,’SM’);
for j = 1:3
ti = [’\lambda = ’ num2str(D(j,j))];
subplot(1,3,j)
plot(x,[0; V(:,j); 0])
title(ti,’FontSize’,14)
end
This creates

454
C. Solutions to Tasks
0
2
4
−0.35
−0.3
−0.25
−0.2
−0.15
−0.1
−0.05
0
λ = −0.14528
0
2
4
−0.4
−0.3
−0.2
−0.1
0
0.1
0.2
0.3
0.4
λ = −3.2813
0
2
4
−0.4
−0.3
−0.2
−0.1
0
0.1
0.2
0.3
0.4
λ = −8.1629
C.9 Solutions for Tasks from Chapter 9
Solution 9.1 This can be achieved using
'
&
$
%
x = [3 2 4 5 6 -1 5 6 7 8 2];
y = [2 -6 3 2 0 1 4 5 6 7 8];
mean(x)
mean(y)
median(x)
median(y)
var(x)
var(y)
A = cov(x,y);
A(1,2)
A = corrcoef(x,y);
A(1,2)
This gives

C.9 Solutions for Tasks from Chapter 9
455
ans =
4.2727
ans =
2.9091
ans =
5
ans =
3
ans =
6.8182
ans =
15.0909
ans =
4.2273
ans =
0.4167
respectively.

456
C. Solutions to Tasks
Solution 9.2 We note that if Y = aX + b then ¯y = a¯x + b which can be seen
by substitution into the formula for the mean. Similarly substituting this into
the expression for the correlation shows that
σXY =
a
√
a2 = a
|a| = sign(a).
Solution 9.3 These two can be calculated using
#
"
 
!
xb=mean(x);
vx=sum((x-xb).ˆ2)/length(x);
std_x=sqrt(vx);
skew=sum(((x-xb)/std_x).ˆ3)/length(x);
kurt=sum(((x-xb)/std_x).ˆ4)/length(x)-3;
Solution 9.4 In order to solve this problem we shall use a basic loop structure
'
&
$
%
global mu
mu = 0.4;
x(1) = 0.25;
for i = 1:9
x(i+1) = map(x(i));
end
The value this code returns is 4.3420e-05 (notice if you get MATLAB to write
out x it will appear that this entry is zero, depending on the current format).
Solution 9.5 One value which works is µ = −2. Then use
'
&
$
%
mu = -2;
co = [-muˆ3 2*muˆ3 -muˆ2*(1+mu) (muˆ2-1) 0];
[r] = roots(co);
x1 = r(3);
x2 = map(x1);
x3 = map(x2);
disp([x1 x2 x3])
Note that x2 is also a period 2 point and its image is x1. These values are
actually given by
1
2
µ2 + µ ±

µ4 −2µ3 −3µ2
µ2

C.9 Solutions for Tasks from Chapter 9
457
The real values of these roots occur for µ < −1 and µ > 3.
Solution 9.6 The code for this map is




function [xn,yn] = map3(xo,yo)
xn = mod(xo+2*yo,1);
yn = mod(3*xo-2*yo,1);
Solution 9.7 The solution of the H´enon map for cos α = 0.24 gives
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1

Index
* multiplication, 4, 6, 8, 15, 176
+ addition, 8
- subtraction, 8
/ division, 8
:, 171
>> prompt, 2
%, 332
Airy functions, 270, 273, 449
ans, 3, 170
ASCII, 55
Bessel functions, 132, 237, 238, 257, 270
Boundary-value problems, 274, 276, 278
Comments, 41, 332
Constants
– eps, 7, 10, 53, 296, 372, 402
– pi,π, 7, 73, 382, 393
– realmax, 384
– realmin, 384
Curves of best ﬁt, 152, 382, 383
Data Loading/Saving, 134–139
Dot Arithmetic, 14, 15, 19, 54, 59, 98,
130, 178, 180, 181, 220
– division, 14, 81, 178, 337
– exponentiation, 14, 30–32, 36, 38, 43,
50, 77, 178, 338, 346, 395
– multiplication, 14, 118, 178, 336, 398
Errors, 51–63
– absolute, 52–54, 237, 266, 267, 438
– numerical, 51–54
– relative, 52, 266, 267, 438
– user, 54–63
Explicit Methods, 248, 251, 253, 254,
256
Extrapolation, 117, 133, 147, 167, 418
feval, 50, 51, 104, 107, 375
Filenames, 28, 30, 135–137, 159, 346
format
– rat, 4, 7, 12, 13, 25, 75, 197
Formatting, 12–13
Functions
– Mathematical
– – acos - arccosine, 8, 368
– – asin - arcsine, 8, 385
– – atan - arctangent, see atan2
– – atan2, 366, 386
– – cos, 8, 181, 368
– – cosh, 369
– – exp - exponential, 9, 181, 372
– – log - natural logarithm, 9, 360, 377
– – log - logarithm base 10, 9
– – ˆ - exponentiation, 9
– – sinh, 181, 385
– – sin, 8, 10, 181, 363, 385
– – tan, 8, 386
– MATLAB
– – \, 332
– – abs, 9
– – all, 93, 341
– – and, 83, 86, 341, 343, 407
– – angle, 365, 366

460
Index
– – any, 93, 99, 342
– – atan2, 366, 386
– – axes, 348
– – axis, 32, 38, 51, 157, 315, 322,
348–350, 356, 405
– – bar, 297, 350
– – barh, 351
– – besselj, 132, 238, 366, 382, 413
– – break, 92, 94, 127, 140, 145, 164,
214, 234, 322, 367
– – case, 112, 115, 116, 367
– – cd, 29
– – ceil, 9, 25, 91, 367, 390, 433
– – clear, 22
– – clf, 39, 46, 107, 260, 262, 269, 315,
352, 357, 382, 396
– – close, 352
– – cond, 368
– – conj, 368
– – contour, 32, 39, 40
– – contourf, 39
– – corrcoef, 295, 368, 454
– – cov, 295, 369, 454
– – cputime, 201, 369
– – dec2hex, 369, 375
– – demo, 41, 369
– – det, 214, 369, 427
– – diag, 179, 182–185, 203, 217, 280,
286, 370, 419, 453
– – diary, 371
– – diff, 371
– – dir, 30
– – disp, 28, 41
– – double, 234, 258, 259
– – dsolve, 258
– – edit, 27, 28, 59, 64, 371
– – eig, 371, 428
– – eigs, 208, 210, 211, 286, 371, 453
– – else, 87, 88, 93, 99, 101, 114, 115,
119–122, 125, 127, 140, 159, 292,
339, 340, 371, 405, 408
– – elseif, 87, 88, 95, 101, 115, 140,
371, 405, 408
– – end, 60
– – end of an array, 24
– – error, 94, 97, 372
– – exist, 96, 372, 376
– – expm, 215, 372
– – eye, 86, 179, 182, 195, 198, 203, 214,
372, 375, 428
– – factor, 9, 11, 65, 87, 95, 271, 272,
372
– – factorial, 66, 77, 372, 383, 401
– – fclose, 137, 138
– – feval, 49–51, 103, 104, 106, 107,
111, 372, 375
– – figure, 39, 59, 156, 257, 287, 348,
352
– – find, 100, 143, 342
– – fix, 9, 25, 372, 390
– – fliplr, 217, 372
– – flipud, 217, 372, 419
– – floor, 9, 25, 91, 96, 99, 373, 390,
403
– – fmins, 161, 162, 164, 373
– – fminsearch, 161
– – fopen, 137, 138
– – for, 63–65, 70, 75, 82, 97, 297, 372,
373, 397, 398, 401, 407
– – format, 4, 7, 12, 13, 25, 75, 197, 373,
436
– – fprintf, 137, 138
– – full, 204, 373, 385
– – function, 30–34
– – fzero, 128, 130, 132, 374, 413
– – gac, 44
– – gca, 301, 352, 355, 361, 362
– – gcd, 374
– – gcf, 44, 159, 354, 361, 362
– – get, 44, 348, 352, 354, 355, 362
– – ginput, 105, 106, 130, 355
– – global, 111, 112, 156, 159, 165, 275,
319, 320, 367, 374, 456
– – gplot, 355
– – grid, 37, 51, 104–107, 109, 147, 148,
356, 360
– – help, 2
– – helpbrowser, 1, 374
– – helpdesk, 1, 335, 375
– – hex2dec, 369, 375
– – hilb, 185, 368, 375
– – hist, 298, 318, 356
– – hold, 39, 46, 147, 148, 159, 260, 315,
357
– – i, 375
– – if, 83, 87, 90
– – imag, 366, 375, 382
– – Inf, 239, 375
– – inline, 374, 375
– – input, 28, 30, 31, 41, 58, 69, 72, 95,
119, 375
– – int, 230, 233, 235
– – int2str, 56, 57, 64, 65, 69–71, 74,
87, 119, 189, 362, 371, 375, 401, 402
– – inv, 154, 201, 209, 210, 332, 333,
369, 375

Index
461
– – invhilb, 185
– – isempty, 93, 140, 145, 376
– – isprime, 49, 99, 376
– – isreal, 93, 376
– – j, 375
– – legend, 46, 47, 269, 357, 396
– – length, 14, 22, 36
– – linspace, 14, 22
– – load, 29, 135–137, 139, 146, 147,
154, 377
– – log10, 9, 377
– – loglog, 39, 358
– – lookfor, 185, 186, 335, 377
– – lower, 89, 90, 377, 404
– – lu, 200, 377, 378
– – magic, 185, 378
– – max, 34, 51, 156, 159, 241, 305, 349,
378, 379
– – mean, 292, 296, 298, 299, 318, 379,
454, 456
– – median, 292, 379, 454
– – meshgrid, 32, 39, 41
– – min, 51, 106, 156, 159, 349, 379
– – mod, 9, 25, 58, 80, 99, 234, 379, 390,
391
– – NaN, 93, 94, 111, 379, 390
– – nchoosek, 67
– – norm, 127, 163–165, 379
– – not, 83, 342
– – num2str, 28, 41, 43, 56–58, 65, 71,
97, 112, 116, 119–122, 127, 156, 159,
185, 241, 296, 380, 395, 398, 399,
401, 420, 453
– – ode23, 265, 288, 380
– – ode45, 265–267, 288, 380, 381, 442
– – ones, 176, 182
– – or, 83, 85, 86, 322, 342, 343, 403,
405, 407
– – otherwise, 89, 90, 112, 115, 116, 382
– – path, 29, 382
– – pause, 159, 286, 382, 384
– – plot, 21, 36–38, 354
– – plot3, 350, 359
– – poly, 22, 43, 206, 214, 382
– – polyfit, 75, 148, 149
– – polyval, 20, 21, 48
– – precedence, 87
– – primes, 383
– – print, 159, 360
– – prod, 12, 67, 68, 81, 383
– – pwd, 30
– – quad, 237, 238, 245, 436
– – rand, 175, 201, 295, 299, 305, 315,
317, 369, 383, 385
– – randn, 298, 299, 383
– – randperm, 300, 384
– – rank, 187, 189, 384
– – real, 305, 366, 384
– – realmax, 7, 384
– – realmin, 7, 384
– – rem, 9, 11, 25, 85, 87, 307, 384, 391
– – reshape, 384
– – roots, 21, 22, 123, 126, 128, 132,
206, 214, 320, 382, 385, 412, 428, 456
– – round, 9, 25, 95, 385, 390, 404
– – rref, 195, 197, 198
– – rrefmovie, 195
– – save, 135, 136, 385
– – semilogx, 39, 359, 360
– – semilogy, 39, 359, 361
– – set, 301, 348, 352, 354, 355, 361–364
– – sign, 9, 95, 181
– – size, 13, 22, 36
– – sort, 292, 385
– – sparse, 203, 210, 373, 385
– – spline, 150, 152, 166, 385, 415, 417
– – sqrt, 12, 343
– – std, 293, 318, 386
– – str2mat, 386
– – subplot, 362, 453
– – sum, 34, 35, 80, 81, 154, 229, 233,
236, 292, 293, 300, 386, 430, 431,
433, 456
– – surf, 39, 40
– – switch, 88–90, 112, 116, 367, 372,
382, 386, 428, 429
– – syms, 230, 233, 235, 258
– – text, 38, 202, 241, 260, 362, 363
– – title, 38, 156, 159, 364, 453
– – tour, 1, 386
– – transpose, 175, 180, 373, 378, 386,
418, 425
– – type, 5, 30, 42, 386
– – upper, 89, 377, 386
– – var, 293, 299, 386, 454
– – warning, 94–96, 387, 404, 405
– – what, 30
– – which, 5, 30, 387
– – while, 90–92, 96, 99, 111, 119–122,
317, 372, 387, 403–405
– – who, 22, 31, 135
– – whos, 22, 31, 134, 135, 137, 387
– – xlabel, 38, 51, 202, 260, 262, 364
– – xor, 83, 342, 343, 403
– – ylabel, 38, 51, 364

462
Index
– – zeros, 77
– – zoom, 105, 107, 109, 322, 355, 365
Geometric Progressions, 68, 79
Help commands
– helpbrowser, 1, 374
– helpdesk, 1, 335, 375
– help, 1, 6, 13, 24, 25, 27, 29, 30, 41,
42, 47, 48, 87, 99, 127, 135, 138, 175,
217, 237, 266, 335, 343, 350, 359, 371,
373, 374, 382, 383
– lookfor, 185, 186, 335, 377
Implicit Methods, 251, 254, 288
Interpolation, 117, 133, 147–158, 160,
414
– cubic, 149
– Lagrange polynomials, 142
– linear, 149, 167
– polynomials, 140, 148
– splines, 150–152, 167, 385
Lagrange polynomials, 141, 142, 147
LATEX, 38
Linear Independence, 187
Logical Operators, 335–343
– Boolean algebra
– – and, 341
– – not, 83, 342
– – or, 83, 85, 86, 322, 342, 343, 403,
405, 407
– – xor, 83, 342, 343, 403
– comparative, 83
– ==, 60, 83, 85–87, 90, 92, 94, 95, 99,
111, 119–122, 159, 189, 233, 292, 296,
339, 403
– <,<=, 84, 88, 101, 341, 404–406, 408
– >,>=, 84, 86, 88, 99, 101, 145, 340,
342, 403–406, 408
– <,<=, 341
–
=, 340
Matrices
– eye, 86, 179, 182, 195, 198, 203, 214,
372, 375, 428
– ones, 176, 182, 183, 219, 236, 243,
260, 262, 280, 286, 315, 335–338, 344,
369, 382, 399, 419, 426, 430, 444, 445,
447, 453
– zeros, 77, 156, 173, 175, 182, 241,
250, 256, 257, 265, 269, 271, 272, 274,
279, 280, 283, 284, 287, 310, 331, 387,
419, 437, 439, 441
– addition, 174, 326–327
– anti-symmetric, 220, 325, 421
– associativity, 330
– characteristic polynomials, 212–215,
223, 382
– commutativity, 219, 326, 330, 420
– determinants, 190–191, 198, 205, 206,
222, 331, 369, 421, 427
– diagonals, 182–185, 191, 199, 207–209,
215, 218, 221, 259, 295, 325, 331, 370,
371, 378, 421, 424
– distributivity, 330
– eigenvalues, 204–208, 210–212,
214–216, 223, 286, 290, 368, 371, 382,
428
– eigenvectors, 204–209, 215, 223, 371
– exponentials, 214–216
– full and sparse, 203, 204, 210, 215,
259, 263, 373, 385
– Hermitian, 325
– identity, see eye
– inverses, 331–333
– Inversion, 339
– LU decomposition, 200, 377
– multiplication, 326–328
– penta-diagonal, 263
– rank, 187–189, 198, 384
– scalar multiplication, 206, 326
– size, see size
– Skew Hermitian, 325
– square, 18, 182, 190, 208, 212, 220,
323, 325, 331, 382
– symmetric, 210, 220, 325, 421
– transpose, 180, 221, 325
– tri-diagonal, 259
– 0, see zeros
Nested if statements, 88
Nested loops, 75, 82, 98, 234, 402
Newton forward diﬀerences, 141, 142,
227, 230, 235, 251, 270
Numbers
– exponent Mantissa form, 7
Numerical Integration, 225–245
– Simpson’s 1
3 rule, 232, 234, 242, 243,
430
– Simpson’s 3
8 rule, 236, 237, 242, 430
– Trapezium Rule, 228, 229, 234, 243,
244, 300, 432
Object orientated programming, 4, 43,
152
ODEs, 247

Index
463
– Crank–Nicolson, 247, 251, 253, 255,
303, 306
– Euler, 247, 253, 256, 283, 284, 286,
288, 303
– Runge–Kutta, 263, 266, 267, 270, 272,
274, 288, 380
Operations
– binary, 3, 9, 178, 180, 336–338
– unary, 3, 180
Plotting, 21, 36–49
Polynomials, 20, 41, 43
– roots, 21
Precedence, 5, 6
– brackets, 4–6, 86
– division, 5
– exponentiation, 54
– multiplication, 5
Products, 81, 383
Root ﬁnding, 103
– bisection, 113, 123, 131
– ﬁxed point iteration, 109, 131, 409,
410
– initial estimates, 105, 109, 130, 355,
411
– Newton-Raphson, 117–125
– Newton–Raphson, 131, 132, 163, 247,
274, 313
– secant, 117–125
Scalars, 2–12
Simultaneous equations, 74, 220, 221,
331
Sums of series, 73
Symbols
– ..., 29, 58, 69, 74, 77, 96, 112, 116,
119–122, 145, 159, 188, 211, 237, 256,
269, 271, 272, 275, 280, 286, 333, 343,
372, 395, 399, 402, 422, 426–428, 448,
453
– %, 20, 41, 332, 343
– apostrophe, see transpose
– colon, 13, 17, 19, 59, 98, 171, 172, 344
– comma, 345
– decimal point, 138, 346, 380
– quotes, 28, 42, 49, 65, 90, 136, 137,
345, 363
– round brackets, 11, 30, 171, 347
– semicolon, 2, 3, 6, 13, 31, 55–57, 64,
80, 81, 170, 171, 184, 344, 397, 398,
407
– space, 346
– square brackets, 30, 34, 57, 84, 170,
344, 346, 398
Taylor series, 76, 98, 117, 124, 125, 230,
244, 248, 255, 259, 263, 264, 281, 282,
435
Variables, 2–12
– clearing, 22, 26, 56, 57, 59, 75, 137,
139, 147, 148, 300, 367, 393, 396, 435,
439
– rules for naming, 4–5
Vectors, 13–17
– column vector, 35, 170–173, 182–184,
188, 273, 323, 425
– row vector, 13–15, 33, 35, 43, 55, 70,
137, 170, 172, 173, 182, 185, 221, 324,
336–338, 344, 348, 368, 372, 385, 386,
398, 425

