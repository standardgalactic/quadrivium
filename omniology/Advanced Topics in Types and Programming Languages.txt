
Advanced Topics in Types and Programming Languages


Advanced Topics in
Types and Programming Languages
Benjamin C. Pierce, editor
The MIT Press
Cambridge, Massachusetts
London, England

©2005 Massachusetts Institute of Technology
All rights reserved. No part of this book may be reproduced in any form by
any electronic of mechanical means (including photocopying, recording, or
information storage and retrieval) without permission in writing from the
publisher.
This book was set in Lucida Bright by the editor and authors using the LATEX
document preparation system.
Printed and bound in the United States of America.
10
9
8
7
6
5
4
3
2
1
Library of Congress Cataloging-in-Publication Data
Advanced topics in types and programming languages / Benjamin C. Pierce,
editor.
p.
cm.
Includes bibliographical references and index.
ISBN 0-262-16228-8 (hc.: alk. paper)
1. Programming languages (Electronic computers). I. Pierce, Benjamin C.
QA76.7.A36 2005
005.13—dc22
200457123

Contents
Preface
ix
I
Precise Type Analyses
1
1
Substructural Type Systems
3
David Walker
1.1
Structural Properties
4
1.2
A Linear Type System
6
1.3
Extensions and Variations
17
1.4
An Ordered Type System
30
1.5
Further Applications
36
1.6
Notes
40
2
Dependent Types
45
David Aspinall and Martin Hofmann
2.1
Motivations
45
2.2
Pure First-Order Dependent Types
50
2.3
Properties
54
2.4
Algorithmic Typing and Equality
56
2.5
Dependent Sum Types
61
2.6
The Calculus of Constructions
64
2.7
Relating Abstractions: Pure Type Systems
71
2.8
Programming with Dependent Types
74
2.9
Implementation of Dependent Types
83
2.10
Further Reading
86

vi
Contents
3
Eﬀect Types and Region-Based Memory Management
87
Fritz Henglein, Henning Makholm, and Henning Niss
3.1
Introduction and Overview
87
3.2
Value Flow by Typing with Labels
90
3.3
Eﬀects
102
3.4
Region-Based Memory Management
106
3.5
The Tofte–Talpin Type System
114
3.6
Region Inference
123
3.7
More Powerful Models for Region-Based Memory
Management
127
3.8
Practical Region-Based Memory Management Systems
133
II
Types for Low-Level Languages
137
4
Typed Assembly Language
141
Greg Morrisett
4.1
TAL-0: Control-Flow-Safety
142
4.2
The TAL-0 Type System
146
4.3
TAL-1: Simple Memory-Safety
155
4.4
TAL-1 Changes to the Type System
161
4.5
Compiling to TAL-1
164
4.6
Scaling to Other Language Features
167
4.7
Some Real World Issues
172
4.8
Conclusions
175
5
Proof-Carrying Code
177
George Necula
5.1
Overview of Proof Carrying Code
177
5.2
Formalizing the Safety Policy
182
5.3
Veriﬁcation-Condition Generation
187
5.4
Soundness Proof
199
5.5
The Representation and Checking of Proofs
204
5.6
Proof Generation
214
5.7
PCC beyond Types
216
5.8
Conclusion
219

Contents
vii
III
Types and Reasoning about Programs
221
6
Logical Relations and a Case Study in Equivalence Checking
223
Karl Crary
6.1
The Equivalence Problem
224
6.2
Non-Type-Directed Equivalence Checking
225
6.3
Type-Driven Equivalence
227
6.4
An Equivalence Algorithm
228
6.5
Completeness: A First Attempt
232
6.6
Logical Relations
233
6.7
A Monotone Logical Relation
236
6.8
The Main Lemma
237
6.9
The Fundamental Theorem
239
6.10
Notes
243
7
Typed Operational Reasoning
245
Andrew Pitts
7.1
Introduction
245
7.2
Overview
246
7.3
Motivating Examples
247
7.4
The Language
253
7.5
Contextual Equivalence
261
7.6
An Operationally Based Logical Relation
266
7.7
Operational Extensionality
279
7.8
Notes
288
IV
Types for Programming in the Large
291
8
Design Considerations for ML-Style Module Systems
293
Robert Harper and Benjamin C. Pierce
8.1
Basic Modularity
294
8.2
Type Checking and Evaluation of Modules
298
8.3
Compilation and Linking
302
8.4
Phase Distinction
305
8.5
Abstract Type Components
307
8.6
Module Hierarchies
317
8.7
Signature Families
320
8.8
Module Families
324
8.9
Advanced Topics
338
8.10
Relation to Some Existing Languages
341
8.11
History and Further Reading
343

viii
Contents
9
Type Deﬁnitions
347
Christopher A. Stone
9.1
Deﬁnitions in the Typing Context
351
9.2
Deﬁnitions in Module Interfaces
358
9.3
Singleton Kinds
367
9.4
Notes
384
V
Type Inference
387
10 The Essence of ML Type Inference
389
François Pottier and Didier Rémy
10.1
What Is ML?
389
10.2
Constraints
407
10.3
HM(X)
422
10.4
Constraint Generation
429
10.5
Type Soundness
434
10.6
Constraint Solving
438
10.7
From ML-the-Calculus to ML-the-Language
451
10.8
Rows
460
A
Solutions to Selected Exercises
491
References
535
Index
567

Preface
Overview
Work in type systems for programming languages now touches many parts
of computer science, from language design and implementation to software
engineering, network security, databases, and analysis of concurrent and dis-
tributed systems. The aim of this book, together with its predecessor, Types
and Programming Languages (Pierce [2002]—henceforth TAPL) is to oﬀer a
comprehensive and accessible introduction to the area’s central ideas, results,
and techniques. The intended audience includes graduate students and re-
searchers from other parts of computer science who want get up to speed in
the area as a whole, as well as current researchers in programming languages
who need comprehensible introductions to particular topics. Unlike TAPL, the
present volume is conceived not as a uniﬁed text, but as a collection of more
or less separate articles, authored by experts on their particular topics.
Required Background
Most of the material should be accessible to readers with a solid grasp of the
basic notations and techniques of operational semantics and type systems—
roughly, the ﬁrst half of TAPL. Some chapters depend on more advanced
topics from the second half of TAPL or earlier chapters of the present vol-
ume; these dependencies are indicated at the beginning of each chapter. Inter-
chapter dependencies have been kept to a minimum to facilitate reading in
any order.
Topics
Precise Type Analyses
The ﬁrst three chapters consider ways of extending
simple type systems to give them a better grip on the run time behavior of

x
Preface
programs. The ﬁrst, Substructural Type Systems, by David Walker, surveys
type systems based on analogies with “substructural” logics such as linear
logic, in which one or more of the structural rules of conventional logics—
which allow dropping, duplicating, and permuting assumptions—are omitted
or allowed only under controlled circumstances. In substructural type sys-
tems, the type of a value is not only a description of its “shape,” but also
a capability for using it a certain number of times; this reﬁnement plays a
key role in advanced type systems being developed for a range of purposes,
including static resource management and analyzing deadlocks and livelocks
in concurrent systems. The chapter on Dependent Types, by David Aspinall
and Martin Hofmann, describes a yet more powerful class of type systems, in
which the behavior of computations on particular run-time values (not just
generic “shapes”) may be described at the type level. Dependent type sys-
tems blur the distinction between types and arbitrary correctness assertions,
and between typechecking and theorem proving. The power of full dependent
types has proved diﬃcult to reconcile with language design desiderata such
as automatic typechecking and the “phase distinction” between compile time
and run time in compiled languages. Nevertheless, ideas of dependent typ-
ing have played a fruitful role in language design and theory over the years,
oﬀering a common conceptual foundation for numerous forms of “indexed”
type systems. Eﬀect Types and Region-Based Memory Management, by Fritz
Henglein, Henning Makholm, and Henning Niss, introduces yet another idea
for extending the reach of type systems: in addition to describing the shape
of an expression’s result (a static abstraction of the possible values that the
expression may yield when evaluated), its type can also list a set of possible
“eﬀects,” abstracting the possible computational eﬀects (mutations to the
store, input and output, etc.) that its evaluation may engender. Perhaps the
most sophisticated application of this idea has been in memory management
systems based on static “region inference,” in which the eﬀects manipulated
by the typechecker track the program’s ability to read and write in particular
regions of the heap. For example, the ML Kit Compiler used a region analy-
sis internally to implement the full Standard ML language without a garbage
collector.
Types for Low-Level Languages
The next part of the book addresses an-
other research thrust that has generated considerable excitement over the
past decade: the idea of adapting type system technologies originally devel-
oped for high-level languages to low-level languages such as assembly code
and virtual machine bytecode. Typed Assembly Language, by Greg Morrisett,
presents a low-level language with a type system based on the parametric
polymorphism of System F and discusses how to construct a type-preserving

Preface
xi
compiler from a high-level language, through a series of typed intermedi-
ate languages, down to this typed assembly code. Proof-Carrying Code, by
George Necula, presents a more general formulation in a logical setting with
close ties to the dependent types described in Aspinall and Hofmann’s chap-
ter. The strength of this presentation is that it oﬀers a natural transition
from conventional type safety properties, such as memory safety, to more
general security properties. A driving application area for both approaches is
enforcing security guarantees when dealing with untrusted mobile code.
Types and Reasoning about Programs
One attraction of rich type systems
is that they support powerful methods of reasoning about programs—not
only by compilers, but also by humans. One of the most useful, the tech-
nique of logical relations, is introduced in the chapter Logical Relations and a
Case Study in Equivalence Checking, by Karl Crary. The extended example—
proving the correctness of an algorithm for deciding a type-sensitive behav-
ioral equivalence relation on terms in the simply typed lambda-calculus with
a Unit type—foreshadows ideas developed further in Christopher Stone’s
chapter on type deﬁnitions. Typed Operational Reasoning, by Andrew Pitts,
develops a more general theory of typed reasoning about program equiv-
alence. Here the examples focus on proving representation independence
properties for abstract data types in the setting of a rich language combin-
ing the universal and existential polymorphism of System F with records and
recursive function deﬁnitions.
Types for Programming in the Large
One of the most important projects
in language design over the past decade and more has been the use of type-
theory as a framework for the design of sophisticated module systems—
languages for assembling large software systems from modular components.
One highly developed line of work is embodied in the module systems found
in modern ML dialects. Design Considerations for ML-Style Module Systems,
by Robert Harper and Benjamin C. Pierce, oﬀers an informal guided tour of
the principal features of this class of module systems—a “big picture” intro-
duction to a large but highly technical body of papers in the research litera-
ture. Type Deﬁnitions, by Christopher A. Stone, addresses the most critical
and technically challenging feature of the type systems on which ML-style
module systems are founded: singleton kinds, which allow type deﬁnitions to
be internalized rather than being treated as meta-level abbreviations.
Type Inference
The ML family of languages—including Standard ML, Objec-
tive Caml, and Moscow ML, as well as more distant relatives such as Haskell—

xii
Preface
has for decades been a showcase for advances in typed language design and
compiler implementation, and for the advantages of software construction in
richly typed languages. One of the main reasons for the success of these lan-
guages is the combination of power and convenience oﬀered by their type
inference (or type reconstruction) algorithms. Basic ML type inference has
been described in many places, but descriptions of the more advanced tech-
niques used in production compilers for full-blown languages have until now
been widely dispersed in the literature, when they were available at all. In
The Essence of ML Type Inference, François Pottier and Didier Rémy oﬀer a
comprehensive, uniﬁed survey of the area.
Exercises
Most chapters include numerous exercises. The estimated diﬃculty of each
exercise is indicated using the following scale:
«
Quick check
30 seconds to 5 minutes
««
Easy
≤1 hour
«««
Moderate
≤3 hours
««««
Challenging
> 3 hours
Exercises marked « are intended as real-time checks of important concepts.
Readers are strongly encouraged to pause for each one of these before mov-
ing on to the material that follows. Some of the most important exercises are
labeled Recommended.
Solutions to most of the exercises are provided in Appendix A. To save
readers searching for solutions to exercises for which solutions are not avail-
able, these are marked 3.
Electronic Resources
Additional materials associated with this book can be found at:
http://www.cis.upenn.edu/~bcpierce/attapl
Resources available on this site will include errata for the text, pointers to
supplemental material contributed by readers, and implementations associ-
ated with various chapters.
Acknowledgments
Many friends and colleagues have helped to improve the chapters as they
developed. We are grateful to Amal Ahmed, Lauri Alanko, Jonathan Aldrich,

Preface
xiii
Derek Dreyer, Matthias Felleisen, Robby Findler, Kathleen Fisher, Nadji Gau-
thier, Michael Hicks, Steﬀen Jost, Xavier Leroy, William Lovas, Kenneth Mac-
Kenzie, Yitzhak Mandelbaum, Martin Müller, Simon Peyton Jones, Norman
Ramsey, Yann Régis-Gianas, Fermin Reig, Don Sannella, Alan Schmitt, Peter
Sewell, Vincent Simonet, Eijiro Sumii, David Swasey, Joe Vanderwaart, Yanling
Wang, Keith Wansbrough, Geoﬀrey Washburn, Stephanie Weirich, Dinghao
Wu, and Karen Zee for helping to make this a much better book than we could
have done alone. Stephanie Weirich deserves a particularly warm round of
thanks for numerous and incisive comments on the whole manuscript. Nate
Foster’s assistance with copy editing, typesetting, and indexing contributed
enormously to the book’s ﬁnal shape.
The work described in many chapters was supported in part by grants from
the National Science Foundation. The opinions, ﬁndings, conclusions, or rec-
ommendations expressed in these chapters are those of the author(s) and do
not necessarily reﬂect the views of the NSF.


P a r t I
Precise Type Analyses


1
Substructural Type Systems
David Walker
Advanced type systems make it possible to restrict access to data structures
and to limit the use of newly-deﬁned operations. Oftentimes, this sort of
access control is achieved through the deﬁnition of new abstract types under
control of a particular module. For example, consider the following simpliﬁed
ﬁle system interface.
type file
val open
: string →file option
val read
: file →string * file
val append : file * string →file
val write
: file * string →file
val close
: file →unit
By declaring that the type file is abstract, the implementer of the module
can maintain strict control over the representation of ﬁles. A client has no way
to accidentally (or maliciously) alter any of the ﬁle’s representation invariants.
Consequently, the implementer may assume that the invariants that he or
she establishes upon opening a ﬁle hold before any read, append, write or
close.
While abstract types are a powerful means of controlling the structure of
data, they are not suﬃcient to limit the ordering and number of uses of func-
tions in an interface. Try as we might, there is no (static) way to prevent a
ﬁle from being read after it has been closed. Likewise, we cannot stop a client
from closing a ﬁle twice or forgetting to close a ﬁle.
This chapter introduces substructural type systems, which augment stan-
dard type abstraction mechanisms with the ability to control the number and
order of uses of a data structure or operation. Substructural type systems are
particularly useful for constraining interfaces that provide access to system

4
1
Substructural Type Systems
resources such as ﬁles, locks and memory. Each of these resources undergoes
a series of changes of state throughout its lifetime. Files, as we have seen, may
be open or closed; locks may be held or not; and memory may be allocated or
deallocated. Substructural type systems provide sound static mechanisms for
keeping track of just these sorts of state changes and preventing operations
on objects in an invalid state.
The bulk of this chapter will focus on applications of substructural type
systems to the control of memory resources. Memory is a pervasive resource
that must be managed carefully in any programming system so it makes an
excellent target of study. However, the general principles that we establish
can be applied to other sorts of resources as well.
1.1
Structural Properties
Most of the type systems in this book allow unrestricted use of variables in the
type checking context. For instance, each variable may be used once, twice,
three times, or not at all. A precise analysis of the properties of such variables
will suggest a whole new collection of type systems.
To begin our exploration, we will analyze the simply-typed lambda calcu-
lus, which is reviewed in Figure 1-1. In this discussion, we are going to be
particularly careful when it comes to the form of the type-checking context Γ.
We will consider such contexts to be simple lists of variable-type pairs. The
"," operator appends a pair to the end of the list. We also write (Γ1, Γ2) for
the list that results from appending Γ2 onto the end of Γ1. As usual, we al-
low a given variable to appear at most once in a context and to maintain this
invariant, we implicitly alpha-convert bound variables before entering them
into the context.
We are now in position to consider three basic structural properties sat-
isﬁed by our simply-typed lambda calculus. The ﬁrst property, exchange,
indicates that the order in which we write down variables in the context is
irrelevant. A corollary of exchange is that if we can type check a term with
the context Γ, then we can type check that term with any permutation of the
variables in Γ. The second property, weakening, indicates that adding extra,
unneeded assumptions to the context, does not prevent a term from type
checking. Finally, the third property, contraction, states that if we can type
check a term using two identical assumptions (x2:T1 and x3:T1) then we can
check the same term using a single assumption.
1.1.1
Lemma [Exchange]: If Γ1, x1:T1, x2:T2, Γ2 ⊢t : T then
Γ1, x2:T2, x1:T1, Γ2 ⊢t : T
2
1.1.2
Lemma [Weakening]: If Γ1, Γ2 ⊢t : T then Γ1, x1:T1, Γ2 ⊢t : T
2

1.1
Structural Properties
5
Syntax
b
::=
booleans:
true
true
false
false
t
::=
terms:
x
variable
b
boolean
if t then t else t
conditional
λx:T.t
abstraction
t t
application
T
::=
types:
Bool
booleans
T→T
type of functions
Γ
::=
contexts:
∅
empty context
Γ, x:T
term variable binding
Typing
Γ ⊢t : T
Γ1, x:T, Γ2 ⊢x : T
(T-Var)
Γ ⊢b : Bool
(T-Bool)
Γ ⊢t1 : Bool
Γ ⊢t2 : T
Γ ⊢t3 : T
Γ ⊢if t1 then t2 else t3 : T
(T-If)
Γ, x:T1 ⊢t2 : T2
Γ ⊢λx:T1.t2 : T1→T2
(T-Abs)
Γ ⊢t1 : T11→T12
Γ ⊢t2 : T11
Γ ⊢t1 t2 : T12
(T-App)
Figure 1-1: Simply-typed lambda calculus with booleans
1.1.3
Lemma [Contraction]: If Γ1, x2:T1, x3:T1, Γ2 ⊢t : T2 then
Γ1, x1:T1, Γ2 ⊢[x2 , x1][x3 , x1]t : T2
2
1.1.4
Exercise [Recommended, «]: Prove that exchange, weakening and contrac-
tion lemmas hold for the simply-typed lambda calculus.
2
A substructural type system is any type system that is designed so that one
or more of the structural properties do not hold. Diﬀerent substructural type
systems arise when diﬀerent properties are withheld.
•
Linear type systems ensure that every variable is used exactly once by
allowing exchange but not weakening or contraction.
•
Aﬃne type systems ensure that every variable is used at most once by
allowing exchange and weakening, but not contraction.
•
Relevant type systems ensure that every variable is used at least once by
allowing exchange and contraction, but not weakening.
•
Ordered type systems ensure that every variable is used exactly once and
in the order in which it is introduced. Ordered type systems do not allow
any of the structural properties.

6
1
Substructural Type Systems
The picture below can serve as a mnemonic for the relationship between
these systems. The system at the bottom of the diagram (the ordered type sys-
tem) admits no structural properties. As we proceed upwards in the diagram,
we add structural properties: E stands for exchange; W stands for weakening;
and C stands for contraction. It might be possible to deﬁne type systems con-
taining other combinations of structural properties, such as contraction only
or weakening only, but so far researchers have not found applications for
such combinations. Consequently, we have excluded them from the diagram.
ordered (none)
linear (E)
aﬃne (E,W)
relevant (E,C)
unrestricted (E,W,C)
The diagram can be realized as a relation between the systems. We say system
q1 is more restrictive than system q2 and write q1⊑q2 when system q1 exhibits
fewer structural rules than system q2. Figure 1-2 speciﬁes the relation, which
we will ﬁnd useful in the coming sections of this chapter.
1.2
A Linear Type System
In order to safely deallocate data, we need to know that the data we deallo-
cate is never used in the future. Unfortunately, we cannot, in general, deduce
whether data will be used after execution passes a certain program point: The
problem is clearly undecidable. However, there are a number of sound, but
useful approximate solutions. One such solution may be implemented using
a linear type system. Linear type systems ensure that objects are used exactly
once, so it is completely obvious that after the use of an object, it may be
safely deallocated.

1.2
A Linear Type System
7
q
::=
system:
ord
ordered
lin
linear
rel
relevant
aff
aﬃne
un
unrestricted
ord ⊑lin
(Q-OrdLin)
lin ⊑rel
(Q-LinRel)
lin ⊑aff
(Q-LinAff)
rel ⊑un
(Q-RelUn)
aff ⊑un
(Q-AffUn)
q ⊑q
(Q-Reflex)
q1 ⊑q2
q2 ⊑q3
q1 ⊑q3
(Q-Trans)
Figure 1-2: A relation between substructural type systems
Syntax
Figure 1-3 presents the syntax of our linear language, which is an extension
of the simply-typed lambda calculus. The main addition to be aware of, at
this point, are the type qualiﬁers q that annotate the introduction forms for
all data structures. The linear qualiﬁer (lin) indicates that the data structure
in question will be used (i.e., appear in the appropriate elimination form) ex-
actly once in the program. Operationally, we deallocate these linear values
immediately after they are used. The unrestricted qualiﬁer (un) indicates that
the data structure behaves as in the standard simply-typed lambda calculus.
In other words, unrestricted data can be used as many times as desired and
its memory resources will be automatically recycled by some extra-linguistic
mechanism (a conventional garbage collector).
Apart from the qualiﬁers, the only slightly unusual syntactic form is the
elimination form for pairs. The term split t1 as x,y in t2 projects the ﬁrst
and second components from the pair t1 and calls them x and y in t2. This
split operation allows us to extract two components while only counting
a single use of a pair. Extracting two components using the more conven-
tional projections π 1 t1 and π2 t1 requires two uses of the pair t1. (It is also
possible, but a bit tricky, to provide the conventional projections.)
To avoid dealing with an unnecessarily heavy syntax, we adopt a couple
abbreviations in our examples in this section. First, we omit all unrestricted
qualiﬁers and only annotate programs with the linear ones. Second, we freely
use n-ary tuples (triples, quadruples, unit, etc.) in addition to pairs and also
allow multi-argument functions. The latter may be deﬁned as single-argument
functions that take linear pairs (triples, etc) as arguments and immediately
split them upon entry to the function body. Third, we often use ML-style type

8
1
Substructural Type Systems
Syntax
q
::=
qualiﬁers:
lin
linear
un
unrestricted
b
::=
booleans:
true
true
false
false
t
::=
terms:
x
variable
q b
boolean
if t then t else t
conditional
q <t,t>
pair
split t as x,y in t
split
q λx:T.t
abstraction
t t
application
P
::=
pretypes:
Bool
booleans
T*T
pairs
T→T
functions
T
::=
types:
q P
qualiﬁed pretype
Γ
::=
contexts:
∅
empty context
Γ, x:T
term variable binding
Figure 1-3: Linear lambda calculus: Syntax
declarations, value declarations and let expressions where convenient; they
all have the obvious meanings.
Typing
To ensure that linear objects are used exactly once, our type system maintains
two important invariants.
1. Linear variables are used exactly once along every control-ﬂow path.
2. Unrestricted data structures may not contain linear data structures. More
generally, data structures with less restrictive type may not contain data
structures with more restrictive type.
To understand why these invariants are useful, consider what could hap-
pen if either invariant is broken. When considering the ﬁrst invariant, as-
sume we have constructed a function free that uses its argument and then
deallocates it. Now, if we allow a linear variable (say x) to appear twice, a
programmer might write <free x,free x>, or, slightly more deviously,
(λz.λy.<free z,free y>) x x.
In either case, the program ends up attempting to use and then free x after it
has already been deallocated, causing the program to crash.
Now consider the second invariant and suppose we allow a linear data
structure (call it x) to appear inside an unrestricted pair (un <x,3>). We can

1.2
A Linear Type System
9
Context Split
Γ = Γ1 ◦Γ2
∅= ∅◦∅
(M-Empty)
Γ = Γ1 ◦Γ2
Γ, x:un P = (Γ1, x:un P) ◦(Γ2, x:un P)
(M-Un)
Γ = Γ1 ◦Γ2
Γ, x:lin P = (Γ1, x:lin P) ◦Γ2
(M-Lin1)
Γ = Γ1 ◦Γ2
Γ, x:lin P = Γ1 ◦(Γ2, x:lin P)
(M-Lin2)
Figure 1-4: Linear lambda calculus: Context splitting
get exactly the same eﬀect as above by using the unrestricted data structure
multiple times:
let z = un <x,3> in
split z as x1,_ in
split z as x2,_ in
<free x1,free x2>
Fortunately, our type system ensures that none of these situations can occur.
We maintain the ﬁrst invariant through careful context management. When
type checking terms with two or more subterms, we pass all of the unre-
stricted variables in the context to each subterm. However, we split the linear
variables between the diﬀerent subterms to ensure each variable is used ex-
actly once. Figure 1-4 deﬁnes a relation, Γ = Γ1 ◦Γ2, which describes how to
split a single context in a rule conclusion (Γ) into two contexts (Γ1 and Γ2) that
will be used to type diﬀerent subterms in a rule premise.
To check the second invariant, we deﬁne the predicate q(T) (and its exten-
sion to contexts q(Γ)) to express the types T that can appear in a q-qualiﬁed
data structure. These containment rules state that linear data structures can
hold objects with linear or unrestricted type, but unrestricted data structures
can only hold objects with unrestricted type.
•
q(T) if and only if T = q′ P and q⊑q′
•
q(Γ) if and only if (x:T) ∈Γ implies q(T)
Recall, we have already deﬁned q⊑q′ such that it is reﬂexive, transitive and
lin⊑un.
Now that we have deﬁned the rules for containment and context splitting,
we are ready for the typing rules proper, which appear in Figure 1-5. Keep in
mind that these rules are constructed anticipating a call-by-value operational
semantics.
It is often the case when designing a type system that the rules for the
base cases, variables and constants, are hardly worth mentioning. However,

10
1
Substructural Type Systems
Typing
Γ ⊢t : T
un (Γ1, Γ2)
Γ1, x:T, Γ2 ⊢x : T
(T-Var)
un (Γ)
Γ ⊢q b : q Bool
(T-Bool)
Γ1 ⊢t1 : q Bool
Γ2 ⊢t2 : T
Γ2 ⊢t3 : T
Γ1 ◦Γ2 ⊢if t1 then t2 else t3 : T
(T-If)
Γ1 ⊢t1 : T1
Γ2 ⊢t2 : T2
q(T1)
q(T2)
Γ1 ◦Γ2 ⊢q <t1,t2> : q (T1*T2)
(T-Pair)
Γ1 ⊢t1 : q (T1*T2)
Γ2, x:T1, y:T2 ⊢t2 : T
Γ1 ◦Γ2 ⊢split t1 as x,y in t2 : T
(T-Split)
q(Γ)
Γ, x:T1 ⊢t2 : T2
Γ ⊢q λx:T1.t2 : q T1→T2
(T-Abs)
Γ1 ⊢t1 : q T11→T12
Γ2 ⊢t2 : T11
Γ1 ◦Γ2 ⊢t1 t2 : T12
(T-App)
Figure 1-5: Linear lambda calculus: Typing
in substructural type systems these cases have a special role in deﬁning the
nature of the type system, and subtle changes can make all the diﬀerence.
In our linear system, the base cases must ensure that no linear variable is
discarded without being used. To enforce this invariant in rule (T-Var), we
explicitly check that Γ1 and Γ2 contain no linear variables using the condition
un (Γ1, Γ2). We make a similar check in rule (T-Bool). Notice also that rule (T-
Var) is written carefully to allow the variable x to appear anywhere in the
context, rather than just at the beginning or at the end.
1.2.1
Exercise [«]: What is the eﬀect of rewriting the variable rule as follows?
un (Γ)
Γ, x:T ⊢x : T
(T-BrokenVar)
The inductive cases of the typing relation take care to use context splitting
to partition linear variables between various subterms. For instance, rule (T-
If) splits the incoming context into two parts, one of which is used to check
subterm t1 and the other which is used to check both t2 and t3. As a result,
a particular linear variable will occur once in t2 and once in t3. However, the
linear object bound to the variable in question will be used (and hence de-
allocated) exactly once at run time since only one of t2 or t3 will be executed.
The rules for creation of pairs and functions make use of the containment
rules. In each case, the data structure’s qualiﬁer q is used in the premise of
the typing rule to limit the sorts of objects it may contain. For example, in the
rule (T-Abs), if the qualiﬁer q is un then the variables in Γ, which will inhabit
the function closure, must satisfy un (Γ). In other words, they must all have

1.2
A Linear Type System
11
unrestricted type. If we omitted this constraint, we could write the follow-
ing badly behaved functions. (For clarity, we have retained the unrestricted
qualiﬁers in this example rather than omitting them.)
type T = un (un bool →lin bool)
val discard =
lin λx:lin bool.
(lin λf:T.lin true) (un λy:un bool.x)
val duplicate =
lin λx:lin bool.
(lin λf:T.lin <f (un true),f (un true)>)) (un λy:un bool.x)
The ﬁrst function discards a linear argument x without using it and the sec-
ond duplicates a linear argument and returns two copies of it in a pair. Hence,
in the ﬁrst case, we fail to deallocate x and in the second case, a subsequent
function may project both elements of the pair and use x twice, which would
result in a memory error as x would be deallocated immediately after the ﬁrst
use. Fortunately, the containment constraint disallows the linear variable x
from appearing in the unrestricted function (λy:bool. x).
Now that we have deﬁned our type system, we should verify our intended
structural properties: exchange for all variables, and weakening and contrac-
tion for unrestricted variables.
1.2.2
Lemma [Exchange]: If Γ1, x1:T1, x2:T2, Γ2 ⊢t : T then
Γ1, x2:T2, x1:T1, Γ2 ⊢t : T.
2
1.2.3
Lemma [Unrestricted Weakening]: If Γ ⊢t : T then
Γ, x1:un P1 ⊢t : T.
2
1.2.4
Lemma [Unrestricted Contraction]:
If Γ, x2:un P1, x3:un P1 ⊢t : T3 then
Γ, x1:un P1 ⊢[x2 , x1][x3 , x1]t : T3.
2
Proof:
The proofs of all three lemmas follow by induction on the structure
of the appropriate typing derivation.
2
Algorithmic Linear Type Checking
The inference rules provided in the previous subsection give a clear, con-
cise speciﬁcation of the linearly-typed programs. However, these rules are
also highly non-deterministic and cannot be implemented directly. The pri-
mary diﬃculty is that to implement the non-deterministic splitting operation,

12
1
Substructural Type Systems
Algorithmic Typing
Γin ⊢t : T;Γout
Γ1, x:un P, Γ2 ⊢x : un P;Γ1, x:un P, Γ2
(A-UVar)
Γ1, x:lin P, Γ2 ⊢x : lin P;Γ1, Γ2
(A-LVar)
Γ ⊢q b : q Bool;Γ
(A-Bool)
Γ1 ⊢t1 : q Bool;Γ2
Γ2 ⊢t2 : T;Γ3
Γ2 ⊢t3 : T;Γ3
Γ1 ⊢if t1 then t2 else t3 : T;Γ3
(A-If)
Γ1 ⊢t1 : T1;Γ2
Γ2 ⊢t2 : T2;Γ3
q(T1)
q(T2)
Γ1 ⊢q <t1,t2> : q (T1*T2);Γ3
(A-Pair)
Γ1 ⊢t1 : q (T1*T2);Γ2
Γ2, x:T1, y:T2 ⊢t2 : T;Γ3
Γ1 ⊢split t1 as x,y in t2 :
T;Γ3 ÷ (x:T1, y:T2)
(A-Split)
q=un ⇒Γ1 = Γ2 ÷ (x:T1)
Γ1, x:T1 ⊢t2 : T2;Γ2
Γ1 ⊢q λx:T1.t2 : q T1→T2;Γ2 ÷ (x:T1)
(A-Abs)
Γ1 ⊢t1 : q T11→T12;Γ2
Γ2 ⊢t2 : T11;Γ3
Γ1 ⊢t1 t2 : T12;Γ3
(A-App)
Figure 1-6: Linear lambda calculus: Algorithmic type checking
Γ = Γ1 ◦Γ2, we must guess how to split an input context Γ into two parts. For-
tunately, it is relatively straightforward to restructure the type checking rules
to avoid having to make these guesses. This restructuring leads directly to a
practical type checking algorithm.
The central idea is that rather than splitting the context into parts before
checking a complex expression composed of several subexpressions, we can
pass the entire context as an input to the ﬁrst subexpression and have it
return the unused portion as an output. This output may then be used to
check the next subexpression, which may also return some unused portions
of the context as an output, and so on. Figure 1-6 makes these ideas concrete.
It deﬁnes a new algorithmic type checking judgment with the form Γin ⊢
t : T;Γout, where Γin is the input context, some portion of which will be
consumed during type checking of t, and Γout is the output context, which
will be synthesized alongside the type T.
There are several key changes in our reformulated system. First, the base
cases for variables and constants allow any context to pass through the judg-
ment rather than restricting the number of linear variables that appear. In
order to ensure that linear variables are used, we move these checks to the
rules where variables are introduced. For instance, consider the rule (A-Split).
The second premise has the form
Γ2, x:T1, y:T2 ⊢t2 : T;Γ3
If T1 and T2 are linear, then they should be used in t2 and should not appear
in Γ3. Conversely, T1 and T2 are unrestricted, then they will always appear

1.2
A Linear Type System
13
in Γ3, but we should delete them from the ﬁnal outgoing context of the rule
so that the ordinary scoping rules for the variables are enforced. To handle
both the check that linear variables do not appear and the removal of unre-
stricted variables, we use a special “context diﬀerence” operator (÷). Using
this operator, the ﬁnal outgoing context of the rule (A-Split) is deﬁned to be
Γ3 ÷ (x:T1, y:T2). Formally, context diﬀerence is deﬁned as follows.
Γ ÷ ∅= Γ
Γ1 ÷ Γ2 = Γ3
(x:lin P) ̸∈Γ3
Γ1 ÷ (Γ2, x:lin P) = Γ3
Γ1 ÷ Γ2 = Γ3
Γ3 = Γ4, x:un P, Γ5
Γ1 ÷ (Γ2, x:un P) = Γ4, Γ5
Notice that this operator is undeﬁned when we attempt to take the dif-
ference of two contexts, Γ1 and Γ2, that contain bindings for the same linear
variable (x:lin P). If the undeﬁned quotient Γ1 ÷ Γ2 were to appear anywhere
in a typing rule, the rule itself would not be considered deﬁned and could not
be part of a valid typing derivation.
The rule for abstraction (A-Abs) also introduces a variable and hence it also
uses context diﬀerence to manipulate the output context for the rule. Ab-
stractions must also satisfy the appropriate containment conditions. In other
words, rule (A-Abs) must check that unrestricted functions do not contain
linear variables. We perform this last check by verifying that when the func-
tion qualiﬁer is unrestricted, the input and output contexts from checking the
function body are the same. This equivalence check is suﬃcient because if a
linear variable was used in the body of an unrestricted function (and hence
captured in the function closure), that linear variable would not show up in
the outgoing context.
It is completely straightforward to check that every rule in our algorithmic
system is syntax directed and that all our auxiliary functions including con-
text membership tests and context diﬀerence are easily computable. Hence,
we need only show that our algorithmic system is equivalent to the simpler
and more elegant declarative system speciﬁed in the previous section. The
proof of equivalence can be a broken down into the two standard compo-
nents: soundness and completeness of the algorithmic system with respect to
the declarative system. However, before we can get to the main results, we
will need to show that our algorithmic system satisﬁes some basic structural
properties of its own. In the following lemmas, we use the notation L(Γ) and
U(Γ) to refer to the list of linear and unrestricted assumptions in Γ respec-
tively.

14
1
Substructural Type Systems
1.2.5
Lemma [Algorithmic Monotonicity]: If Γ ⊢t : T;Γ ′ then U(Γ ′) = U(Γ)
and L(Γ ′) ⊆L(Γ).
2
1.2.6
Lemma [Algorithmic Exchange]: If Γ1, x1:T1, x2:T2, Γ2 ⊢t : T;Γ3 then
Γ1, x2:T2, x1:T1, Γ2 ⊢t : T;Γ ′
3 and Γ3 is the same as Γ ′
3 up to transposition of
the bindings for x1 and x2.
2
1.2.7
Lemma [Algorithmic Weakening]: If Γ ⊢t : T;Γ ′ then Γ, x:T′ ⊢t : T;
Γ ′, x:T′.
2
1.2.8
Lemma [Algorithmic Linear Strengthening]: If Γ, x:lin P ⊢t : T;
Γ ′, x:lin P then Γ ⊢t : T;Γ ′.
2
Each of these lemmas may be proven directly by induction on the initial
typing derivation. The algorithmic system also satisﬁes a contraction lemma,
but since it will not be necessary in the proofs of soundness and complete-
ness, we have not stated it here.
1.2.9
Theorem [Algorithmic Soundness]: If Γ1 ⊢t : T;Γ2 and L(Γ2) = ∅then
Γ1 ⊢t : T.
2
Proof:
As usual, the proof is by induction on the typing derivation. The struc-
tural lemmas we have just proven are required to push through the result, but
it is mostly straightforward.
2
1.2.10
Theorem [Algorithmic Completeness]: If Γ1 ⊢t : T then Γ1 ⊢t : T;Γ2
and L(Γ2) = ∅.
2
Proof:
The proof is by induction on the typing derivation.
2
Operational Semantics
To make the memory management properties of our language clear, we will
evaluate terms in an abstract machine with an explicit store. As indicated in
Figure 1-7, stores are a sequence of variable-value pairs. We will implicitly
assume that any variable appears at most once on the left-hand side of a pair
so the sequence may be treated as a ﬁnite partial map.
A value is a pair of a qualiﬁer together with some data (a prevalue w). For
the sake of symmetry, we will also assume that all values are stored, even
base types such as booleans. As a result, both components of any pair will be
pointers (variables).
We deﬁne the operation of our abstract machine using a context-based,
small-step semantics. Figure 1-7 deﬁnes the computational contexts E, which

1.2
A Linear Type System
15
w
::=
prevalues:
b
boolean
<x,y>
pair
λx:T.t
abstraction
v
::=
values:
q w
qualiﬁed prevalue
S
::=
stores:
∅
empty context
S, x , v
store binding
E
::=
evaluation contexts:
[ ]
context hole
if E then t else t
if context
q <E,t>
fst context
q <x,E>
snd context
split E as x,y in t
split context
E t
fun context
x E
arg context
Figure 1-7: Linear lambda calculus: Run-time data
are terms with a single hole. Contexts deﬁne the order of evaluation of terms—
they specify the places in a term where a computation can occur. In our case,
evaluation is left-to-right since, for example, there is a context with the form
E t indicating that we can reduce the term in the function position before re-
ducing the term in the argument position. However, there is no context with
the form t E. Instead, there is only the more limited context x E, indicating
that we must reduce the term in the function position to a pointer x before
proceeding to evaluate the term in the argument position. We use the nota-
tion E[t] to denote the term composed of the context E with its hole plugged
by the computation t.
The operational semantics, deﬁned in Figure 1-8, is factored into two re-
lations. The ﬁrst relation, (S;t) -→(S′;t′), picks out a subcomputation to
evaluate. The second relation, (S;t) -→β (S′;t′), does all the real work. In
order to avoid creation of two sets of operational rules, one for linear data,
which is deallocated when used, and one for unrestricted data, which is never
deallocated, we deﬁne an auxiliary function, S
q∼x, to manage the diﬀerences.
(S1,x , v,S2) lin
∼x
=
S1,S2
S un
∼x
=
S
Aside from these details, the operational semantics is standard.
Preservation and Progress
In order to prove the standard safety properties for our language, we need to
be able to show that programs are well-formed after each step in evaluation.
Hence, we will deﬁne typing rules for our abstract machine. Since these typing
rules are only necessary for the proof of soundness, and have no place in an

16
1
Substructural Type Systems
Top-level Evaluation
(S;t) -→(S′;t′)
(S;t) -→β (S;t′)
(S;E[t]) -→(S;E[t′])
(E-Ctxt)
Evaluation
(S;t) -→β (S′;t′)
(S;q b) -→β (S, x , q b;x)
(E-Bool)
S(x) = q true
(S;if x then t1 else t2) -→β (S
q∼x;t1)
(E-If1)
S(x) = q false
(S;if x then t1 else t2) -→β (S
q∼x;t2)
(E-If2)
(S;q <y,z>) -→β (S, x , q <y,z>;x) (E-Pair)
S(x) = q <y1,z1>
(S;split x as y,z in t) -→β
(S
q∼x;[y , y1][z , z1]t)
(E-Split)
(S;q λy:T.t) -→β (S, x , q λy:T.t;x)
(E-Fun)
S(x1) = q λy:T.t
(S;x1 x2) -→β (S
q∼x1;[y , x2]t)
(E-App)
Figure 1-8: Linear lambda calculus: Operational semantics
implementation, we will extend the declarative typing rules rather than the
algorithmic typing rules.
Figure 1-9 presents the machine typing rules in terms of two judgments,
one for stores and the other for programs. The store typing rules generate a
context that describes the available bindings in the store. The program typ-
ing rule uses the generated bindings to check the expression that will be
executed.
With this new machinery in hand, we are able to prove the standard progress
and preservation theorems.
1.2.11
Theorem [Preservation]: If
⊢
(S;t)
and
(S;t)
-→
(S′;t′)
then
⊢(S′;t′).
2
1.2.12
Theorem [Progress]: If ⊢(S;t) then (S;t) -→(S′;t′) or t is a value.
2
1.2.13
Exercise [Recommended, «]: You will need a substitution lemma to com-
plete the proof of preservation. Is the following the right one?
Conjecture: Let Γ3 = Γ1 ◦Γ2. If Γ1, x:T ⊢t1 : T1 and Γ2 ⊢t : T then
Γ3 ⊢[x , t]t1 : T1.
2
1.2.14
Exercise [«««, 3]: Prove progress and preservation using TAPL, Chapters 9
and 13, as an approximate guide.
2

1.3
Extensions and Variations
17
Store Typing
⊢S : Γ
⊢∅: ∅
(T-EmptyS)
⊢S : Γ1 ◦Γ2
Γ1 ⊢lin w : T
⊢S,x , lin w : Γ2, x:T
(T-NextlinS)
⊢S : Γ1 ◦Γ2
Γ1 ⊢un w : T
⊢S,x , un w : Γ2, x:T
(T-NextunS)
Program Typing
⊢(S;t)
⊢S : Γ
Γ ⊢t : T
⊢(S;t)
(T-Prog)
Figure 1-9: Linear lambda calculus: Program typing
1.3
Extensions and Variations
Most features found in modern programming languages can be deﬁned to
interoperate successfully with linear type systems, although some are trickier
than others. In this section, we will consider a variety of practical extensions
to our simple linear lambda calculus.
Sums and Recursive Types
Complex data structures, such as the recursive data types found in ML-like
languages, pose little problem for linear languages. To demonstrate the cen-
tral ideas involved, we extend the syntax for the linear lambda calculus with
the standard introduction and elimination forms for sums and recursive types.
The details are presented in Figure 1-10.
Values with sum type are introduced by injections q inlP t or q inrP t,
where P is T1+T2, the resulting pretype of the term. In the ﬁrst instance, the
underlying term t must have type T1, and in the second instance, the under-
lying term t must have type T2. The qualiﬁer q indicates the linearity of the
argument in exactly the same way as for pairs. The case expression will exe-
cute its ﬁrst branch if its primary argument is a left injection and its second
branch if its primary argument is a right injection. We assume that + binds
more tightly that →but less tightly than *.
Recursive types are introduced with a rollP t expression, where P is the
recursive pretype the expression will assume. Unlike all the other introduc-
tion forms, roll expressions are not annotated with a qualiﬁer. Instead, they
take on the qualiﬁer of the underlying expression t. The reason for this dis-
tinction is that we will treat this introduction form as a typing coercion that
has no real operational eﬀect. Unlike functions, pairs or sums, recursive data
types have no data of their own and therefore do not need a separate quali-
ﬁer to control their allocation behavior. To simplify the notational overhead

18
1
Substructural Type Systems
t
::=
terms:
...
as before
q inlP t
left inj.
q inrP t
right inj.
case t (inl x ⇒t | inr y ⇒t) case
rollP t
roll into rec type
unroll t
unroll from rec type
fun f(x:T1):T2.t
recursive fun
P
::=
pretypes:
...
as before
a
pretype variables
T1+T2
sum types
rec a.T
recursive types
Typing
Γ ⊢t : T
Γ ⊢t : T1
q(T1)
q(T2)
Γ ⊢q inlT1+T2 t : q (T1+T2)
(T-Inl)
Γ ⊢t : T2
q(T1)
q(T2)
Γ ⊢q inrT1+T2 t : q (T1+T2)
(T-Inr)
Γ1 ⊢t : q (T1+T2)
Γ2, x:T1 ⊢t1 : T
Γ2, y:T2 ⊢t2 : T
Γ1 ◦Γ2 ⊢case t (inl x ⇒t1 | inr y ⇒t2) : T
(T-Case)
Γ ⊢t : [a , P]q P1
P = rec a.q P1
Γ ⊢rollP t : q P
(T-Roll)
Γ ⊢t : P
P = rec a.q P1
Γ ⊢unroll t : [a , P]q P1
(T-Unroll)
un (Γ)
Γ, f:un T1→T2, x:T1 ⊢t : T2
Γ ⊢fun f(x:T1):T2.t : un T1→T2
(T-TFun)
Figure 1-10: Linear lambda calculus: Sums and recursive types
of sums and recursive types, we will normally omit the typing annotations on
their introduction forms in our examples.
In order to write computations that process recursive types, we add recur-
sive function declarations to our language as well. Since the free variables in
a recursive function closure will be used on each recursive invocation of the
function, we cannot allow the closure to contain linear variables. Hence, all
recursive functions are unrestricted data structures.
A simple but useful data structure is the linear list of Ts:
type T llist = rec a.lin (unit + lin (T * lin a))
Here, the entire spine (aside from the terminating value of unit type) is linear
while the underlying T objects may be linear or unrestricted. To create a fully
unrestricted list, we simply omit the linear qualiﬁers on the sum and pairs
that make up the spine of the list:
type T list = rec a.unit + T * a

1.3
Extensions and Variations
19
After deﬁning the linear lists, the memory conscious programmer can write
many familiar list-processing functions in a minimal amount of space. For
example, here is how we map an unrestricted function across a linear list.
Remember, multi-argument functions are abbreviations for functions that ac-
cept linear pairs as arguments.
fun nil(_:unit) : T2 llist =
roll (lin inl ())
fun cons(hd:T2, tl:T2 llist) : T2 llist =
roll (lin inr (lin <hd,tl>))
fun map(f:T1→T2, xs:T1 llist) : T2 llist =
case unroll xs (
inl _
⇒nil()
| inr xs ⇒
split xs as hd,tl in
cons(f hd,map lin <f,tl>))
In this implementation of map, we can observe that on each iteration of the
loop, it is possible to reuse the space deallocated by split or case operations
for the allocation operations that follow in the body of the function (inside
the calls to nil and cons).
Hence, at ﬁrst glance, it appears that map will execute with only a constant
space overhead. Unfortunately, however, there are some hidden costs as map
executes. A typical implementation will store local variables and temporaries
on the stack before making a recursive call. In this case, the result of f hd will
be stored on the stack while map iterates down the list. Consequently, rather
than having a constant space overhead, our map implementation will have an
O(n) overhead, where n is the length of the list. This is not too bad, but we
can do better.
In order to do better, we need to avoid implicit stack allocation of data
each time we iterate through the body of a recursive function. Fortunately,
many functional programming languages guarantee that if the last operation
in a function is itself a function call then the language implementation will
deallocate the current stack frame before calling the new function. We name
such function calls tail calls and we say that any language implementation
that guarantees that the current stack frame will be deallocated before a tail
call is tail-call optimizing.
Assuming that our language is tail-call optimizing, we can now rewrite map
so that it executes with only a constant space overhead. The main trick in-
volved is that we will explicitly keep track of both the part of the input list we
have yet to process and the ouput list that we have already processed. The

20
1
Substructural Type Systems
output list will wind up in reverse order, so we will reverse it at the end. Both
of the loops in the code, mapRev and reverse are tail-recursive functions.
That is, they end in a tail call and have a space-eﬃcient implementation.
fun map(f:T1→T2, input:T1 llist) : T2 llist =
reverse(mapRev(f,input,nil()),nil())
and mapRev(f:T1→T2,
input:T1 llist,
output:T2 llist) : T2 llist =
case unroll input (
inl _
⇒output
| inr xs ⇒
split xs as hd,tl in
mapRev (f,tl,cons(f hd,output)))
and reverse(input:T2 llist, output:T2 llist)
case unroll input (
inl _
⇒output
| inr xs ⇒
split xs as hd,tl in
reverse(tl,cons(hd,output)))
This link reversal algorithm is a well-known way of traversing a list in
constant space. It is just one of a class of algorithms developed well before
the invention of linear types. A similar algorithm was invented by Deutsch,
Schorr, and Waite for traversing trees and graphs in constant space. Such con-
stant space traversals are essential parts of mark-sweep garbage collectors—
at garbage collection time there is no extra space for a stack so any traversal
of the heap must be done in constant space.
1.3.1
Exercise [«««]: Deﬁne a recursive type that describes linear binary trees
that hold data of type T in their internal nodes (nothing at the leaves). Write
a constant-space function treeMap that produces an identically-shaped tree
on output as it was given on input, modulo the action of the function f that
is applied to each element of the tree. Feel free to use reasonable extensions
to our linear lambda calculus including mutually recursive functions, n-ary
tuples and n-ary sums.
2
Polymorphism
Parametric polymorphism is a crucial feature of almost any functional lan-
guage, and our linear lambda calculus is no exception. The main function of
polymorphism in our setting is to support two diﬀerent sorts of code reuse.

1.3
Extensions and Variations
21
1. Reuse of code to perform the same algorithm, but on data with diﬀerent
shapes.
2. Reuse of code to perform the same algorithm, but on data governed by
diﬀerent memory management strategies.
To support the ﬁrst kind of polymorphism, we will allow quantiﬁcation
over pretypes. To support the second kind of polymorphism, we will allow
quantiﬁcation over qualiﬁers. A good example of both sorts of polymorphism
arises in the deﬁnition of a polymorphic map function. In the code below, we
use a and b to range over pretype variables as we did in the previous section,
and p to range over qualiﬁer variables.
type (p1,p2,a) list =
rec a.p1 (unit + p1 (p2 a * (p1,p2,a) list))
map :
∀a,b.
∀pa,pb.
lin ((pa a →pb b)*(lin,pa,a) list)→(lin,pb,b) list
The type deﬁnition in the ﬁrst line deﬁnes lists in terms of three parameters.
The ﬁrst parameter, p1, gives the usage pattern (linear or unrestricted) for the
spine of the list, while the second parameter gives the usage pattern for the
elements of the list. The third parameter is a pretype parameter, which gives
the (pre)type of the elements of list. The map function is polymorphic in the
argument (a) and result (b) element types of the list. It is also polymorphic
(via parameters pa and pb) in the way those elements are used. Overall, the
function maps lists with linear spines to lists with linear spines.
Developing a system for polymorphic, linear type inference is a challenging
research topic, beyond the scope of this book, so we will assume that, unlike
in ML, polymorphic functions are introduced explicitly using the syntax Λa.t
or Λp.t. Here, a and p are the type parameters to a function with body t. The
body does not need to be a value, like in ML, since we will run the polymorphic
function every time a pretype or qualiﬁer is passed to the function as an
argument. The syntax t′ [P] or t′ [q] applies the function t′ to its pretype
or qualiﬁer argument. Figure 1-11 summarizes the syntactic extensions to the
language.
Before we get to writing the map function, we will take a look at the poly-
morphic constructor functions for linear lists. These functions will take a
pretype parameter and two qualiﬁer parameters, just like the type deﬁnition
for lists.

22
1
Substructural Type Systems
q
::=
qualiﬁers:
...
as before
p
polymorphic qualiﬁer
t
::=
terms:
...
as before
q Λa.t
pretype abstraction
t [P]
pretype application
q Λp.t
qualiﬁer abstraction
t [q]
qualiﬁer application
P
::=
pretypes:
...
as before
∀a.T
pretype polymorphism
∀p.T
qualiﬁer polymorphism
Figure 1-11: Linear lambda calculus: Polymorphism syntax
val nil : ∀a,p2.(lin,p2,a) list =
Λa,p2.roll (lin inl ())
val list :
∀a,p2.lin (p2 a * (lin,p2,a) list)→(lin,p2,a) list =
Λa,p2.
λcell : lin (p2 a * (lin,p2,a) list).
roll (lin inr (lin cell))
Now our most polymorphic map function may be written as follows.
val map =
Λa,b. Λpa,pb.
fun aux(f:(pa a →pb b),
xs:(lin,pa,a) list)) : (lin,pb,b) list =
case unroll xs (
inl _
⇒nil [b,pb] ()
| inr xs ⇒split xs as hd,tl in
cons [b,pb] (pb <f hd,map (lin <f,tl>)>))
In order to ensure that our type system remains sound in the presence
of pretype polymorphism, we add the obvious typing rules, but change very
little else. However, adding qualiﬁer polymorphism, as we have done, is a
little more involved. Before arriving at the typing rules themselves, we need
to adapt some of our basic deﬁnitions to account for abstract qualiﬁers that
may either be linear or unrestricted.
First, we need to ensure that we propagate contexts containing abstract
qualiﬁers safely through the other typing rules in the system. Most impor-
tantly, we add additional cases to the context manipulation rules deﬁned in
the previous section. We need to ensure that linear hypotheses are not du-
plicated and therefore we cannot risk duplicating unknown qualiﬁers, which
might turn out to be linear. Figure 1-12 speciﬁes the details.

1.3
Extensions and Variations
23
Context Split
Γ = Γ1 ◦Γ2
Γ = Γ1 ◦Γ2
Γ, x:p P = (Γ1, x:p P) ◦Γ2
(M-Abs1)
Γ = Γ1 ◦Γ2
Γ, x:p P = Γ1 ◦(Γ2, x:p P)
(M-Abs2)
Figure 1-12: Linear context manipulation rules
∆
::=
type contexts:
∅
empty
∆, a
pretype var.
∆, p
qualiﬁer var.
Typing
∆; Γ ⊢t : T
q(Γ)
∆, a; Γ ⊢t : T
∆; Γ ⊢q Λa.t : q ∀a.T
(T-PAbs)
∆; Γ ⊢t : q ∀a.T
FV(P) ⊆∆
∆; Γ ⊢t [P] : [a , P]T
(T-PApp)
q(Γ)
∆, p; Γ ⊢t : T
∆; Γ ⊢q Λp.t : q ∀p.T
(T-QAbs)
∆; Γ ⊢t : q1 ∀p.T
FV(q) ⊆∆
∆; Γ ⊢t [q] : [p , q]T
(T-QApp)
Figure 1-13: Linear lambda calculus: Polymorphic typing
Second, we need to conservatively extend the relation on type qualiﬁers
q1⊑q2 so that it is sound in the presence of qualiﬁer polymorphism. Since
the linear qualiﬁer is the least qualiﬁer in the current system, the following
rule should hold.
lin ⊑p
(Q-LinP)
Likewise, since un is the greatest qualiﬁer in the system, we can be sure the
following rule is sound.
p ⊑un
(Q-PUn)
Aside from these rules, we will only be able to infer that an abstract qual-
iﬁer p is related to itself via the general reﬂexivity rule. Consequently, lin-
ear data structures can contain abstract ones; abstract data structures can
contain unrestricted data structures; and data structure with qualiﬁer p can
contain other data with qualiﬁer p.
In order to deﬁne the typing rules for the polymorphic linear lambda cal-
culus proper, we need to change the judgment form to keep track of the type
variables that are allowed to appear free in a term. The new judgment uses
the type context ∆for this purpose. The typing rules for the introduction and
elimination forms for each sort of polymorphism are fairly straightforward
now and are presented in Figure 1-13.

24
1
Substructural Type Systems
The typing rules for the other constructs we have seen are almost un-
changed. One relatively minor alteration is that the incoming type context
∆will be propagated through the rules to account for the free type variables.
Unlike term variables, type variables can always be used in an unrestricted
fashion; it is diﬃcult to understand what it would mean to restrict the use
of a type variable to one place in a type or term. Consequently, all parts of ∆
are propagated from the conclusion of any rule to all premises. We also need
the occasional side condition to check that whenever a programmer writes
down a type, its free variables are contained in the current type context ∆.
For instance the rules for function abstraction and application will now be
written as follows.
q(Γ)
FV(T1) ⊆∆
∆; Γ, x:T1 ⊢t2 : T2
∆; Γ ⊢q λx:T1.t2 : q T1→T2
(T-Abs)
∆; Γ1 ⊢t1 : q T1→T2
∆; Γ2 ⊢t2 : T1
∆; Γ1 ◦Γ2 ⊢t1 t2 : T2
(T-App)
The most important way to test our system for faults is to prove the type
substitution lemma. In particular, the proof will demonstrate that we have
made safe assumptions about how abstract type qualiﬁers may be used.
1.3.2
Lemma [Type Substitution]:
1. If ∆, p; Γ ⊢t : T and FV(q) ∈∆then ∆; [p , q]Γ ⊢[p , q]t : [p , q]T
2. If ∆, a; Γ ⊢t : T and FV(P) ∈∆then ∆; [a , P]Γ ⊢[a , P]t : [a , P]T
2
1.3.3
Exercise [«]: Sketch the proof of the type substitution lemma. What struc-
tural rule(s) do you need to carry out the proof?
2
Operationally, we will choose to implement polymorphic instantiation us-
ing substitution. As a result, our operational semantics changes very little.
We only need to specify the new computational contexts and to add the eval-
uation rules for polymorphic functions and application as in Figure 1-14.
Arrays
Arrays pose a special problem for linearly typed languages. If we try to pro-
vide an operation fetches an element from an array in the usual way, perhaps
using an array index expression a[i], we would need to reﬂect the fact that
the ith element (and only the ith element) of the array had been “used.” How-
ever, there is no simple way to reﬂect this change in the type of an array as the
usual form of array types (array(T)) provides no mechanism to distinguish
between the properties of diﬀerent elements of the array.

1.3
Extensions and Variations
25
E
::=
evaluation contexts:
E [P]
pretype app context
E [q]
qualiﬁer app context
(S;q Λa.t) -→β (S, x , q Λa.t;x)
(E-PFun)
S(x) = q Λa.t
(S;x [P]) -→β (S
q∼x;[a , P]t)
(E-PApp)
(S;q Λp.t) -→β (S, x , q Λp.t;x)
(E-QFun)
S(x) = q Λp.t
(S;x [q1]) -→β (S
q∼x;[p , q1]t)
(E-QApp)
Figure 1-14: Linear lambda calculus: Polymorphic operational semantics
We dodged this problem when we constructed our tuple operations by
deﬁning a pattern matching construct that simultaneously extracted all of
the elements of a tuple. Unfortunately, we cannot follow the same path for
arrays because in modern languages like Java and ML, the length of an array
(and therefore the size of the pattern) is unknown at compile time.
Another non-solution to the problem is to add a special built-in iterator
to process all the elements in an array at once. However, this last prevents
programmers from using arrays as eﬃcient, constant-time, random-access
data structures; they might as well use lists instead.
One way out of this jam is to design the central array access operations so
that, unlike the ordinary “get” and “set” operations, they preserve the number
of pointers to the array and the number of pointers to each of its elements.
We avoid our problem because there is no change to the array data structure
that needs to be reﬂected in the type system. Using this idea, we will be able
to allow programmers to deﬁne linear arrays that can hold a collection of
arbitrarily many linear objects. Moreover, programmers will be able to access
any of these linear objects, one at a time, using a convenient, constant-time,
random-access mechanism.
So, what are the magic pointer-preserving array access operations? Actu-
ally, we need only one: a swap operation with the form swap (a[i],t). The
swap replaces the ith element of the array a (call it t′) with t and returns a
(linear) pair containing the new array and t′. Notice the number of pointers
to t and t′ does not change during the operation. If there was one pointer
to t (as an argument to swap) before the call, then there is one pointer to t
afterward (from within the array a) and vice versa for t′. If, in addition, all of
the elements of a had one pointer to them before the swap, then they will all
have one pointer to them after the swap as well. Consequently, we will ﬁnd
it easy to type the swap operation, even when it works over linear arrays of
linear objects.

26
1
Substructural Type Systems
In addition to swap, we provide functions to allocate an array given its list
of elements (array), to determine array length (length) and to deallocate
arrays (free). The last operation is somewhat unusual in that it takes two
arguments a and f, where a is an array of type lin array(T) and f is a
function with type T→unit that is run on each element of T. The function
may be thought of as a ﬁnalizer for the elements; it may be used to deallocate
any linear components of the array elements, thereby preserving the single
pointer property.
Our deﬁnition of arrays is compatible with the polymorphic system from
the previous subsection, but for simplicity, we formalize it in the context of
the simply-typed lambda calculus (see Figure 1-15).
1.3.4
Exercise [Recommended, «]: The typing rule for array allocation (T-Array)
contains the standard containment check to ensure that unrestricted arrays
cannot contain linear objects. What kinds of errors can occur if this check is
omitted?
2
1.3.5
Exercise [««, 3]: With the presence of mutable data structures, it is possible
to create cycles in the store. How should we modify the store typing rules to
take this into account?
2
The swap and free functions are relatively low-level operations. Fortu-
nately, it is easy to build more convenient, higher-level abstractions out of
them. For instance, the following code deﬁnes some simple functions for ma-
nipulating linear matricies of unrestricted integers.
type iArray = lin array(int)
type matrix = lin array(iArray)
fun dummy(x:unit):iArray = lin array()
fun freeElem(x:int):unit = ()
fun freeArray(a:iArray):unit = free(a,freeElem)
fun freeMatrix(m:matrix):unit = free(m,freeArray)
fun get(a:matrix,i:int,j:int):lin (matrix * int) =
split swap(a[i],dummy()) as a,b in
split swap(b[j],0) as b,k in
split swap(b[j],k) as b,_ in
split swap(a[i],b) as a,junk in
freeArray(junk);
lin <a,k>

1.3
Extensions and Variations
27
P
::=
pretypes:
...
as before
array(T)
array pretypes
t
::=
terms:
...
as before
q array(t, . . . ,t)
array creation
swap(t[t],t)
swap
length(t)
length
free(t,t)
deallocate
w
::=
prevalues:
...
as before
array[n,x, . . . ,x]
array
E
::=
evaluation contexts:
...
as before
q array(v, . . . ,v,E,t, . . . ,t)
array context
swap(E(t),t)
swap context
swap(v(E),t)
swap context
swap(v(v),E)
swap context
length(E)
length context
free(E,t)
free context
free(v,E)
free context
Typing
Γ ⊢t : T
q(T)
Γ ⊢ti : T
(for 1 ≤i ≤n)
Γ ⊢q array(t1, . . . ,tn) : q array(T)
(T-Array)
Γ ⊢t1 : q1 array(T1)
Γ ⊢t2 : q2 int
Γ ⊢t3 : T1
Γ ⊢swap(t1[t2],t3) :
lin (q1 array(T1) * T1)
(T-Swap)
Γ ⊢t : q array(T)
Γ ⊢length(t) : lin (q array(T) * int)
(T-Length)
Γ ⊢t1 : q array(T)
Γ ⊢t2 : T →unit
Γ ⊢free(t1,t2) : unit
(T-Free)
Evaluation
(S;t) -→β (S′;t′)
(S;q array(x0, . . . ,xn−1)) -→β
((S, x , q array[n,x0, . . . ,xn−1];x)
(E-Array)
S(xi) = qi j
S = S1, xa , q array[n, . . . ,xj, . . . ], S2
S′ = S1, xa , q array[n, . . . ,xe, . . . ], S2
(S; swap(xa[xi],xe))
-→β (S′ qi∼xi;lin <xa,xj>)
(E-Swap)
S(x) = q array[n,x0, . . . ,xn−1]
(S;length(x)) -→β (S;lin <x,un n>)
(E-Length)
S(xa) = q array[n,x0, . . . ,xn−1]
(S;free(xa,xf))
-→β (S
q∼xa;App(xf ,x0, . . . ,xn−1))
(E-Free)
where
App(xf ,·)
=
()
App(xf ,x0,. . . )
=
xf x0;App(xf ,. . . )
Figure 1-15: Linear lambda calculus: Arrays

28
1
Substructural Type Systems
fun set(a:matrix,i:int,j:int,e:int):matrix =
split swap(a[i],dummy()) as a,b in
split swap(b[j],e) as b,_ in
split swap(a[i],b) as a,junk in
freeArray(junk);
a
1.3.6
Exercise [««, 3]: Use the functions provided above to write matrix-matrix
multiply. Your multiply function should return an integer and deallocate both
arrays in the process. Use any standard integer operations necessary.
2
In the examples above, we needed some sort of dummy value to swap into
an array to replace the value we wanted to extract. For integers and arrays
it was easy to come up with one. However, when dealing with polymorphic
or abstract types, it may not be possible to conjure up a value of the right
type. Consequently, rather than manipulating arrays with type q array(a)
for some abstract type a, we may need to manipulate arrays of options with
type q array(a + unit). In this case, when we need to read out a value, we
always have another value (inr ()) to swap in in its place. Normally such
operations are called destructive reads; they are a common way to preserve
the single pointer property when managing complex structured data.
Reference Counting
Array swaps and destructive reads are dynamic techniques that can help over-
come a lack of compile-time knowledge about the number of uses of a par-
ticular object. Reference counting is another dynamic technique that serves a
similar purpose. Rather than restricting the number of pointers to an object
to be exactly one, we can allow any number of pointers to the object and keep
track of that number dynamically. Only when the last reference is used will
the object be deallocated.
There are various ways to integrate reference counts into the current sys-
tem. Here, we choose the simplest, which is to add a new qualiﬁer rc for
reference-counted data structures, and operations that allow the programmer
to explicitly increment (inc) and decrement (dec) the counts (see Figure 1-16).
More speciﬁcally, the increment operation takes a pointer argument, incre-
ments the reference count for the object pointed to, and returns two copies
of the pointer in a (linear) pair. The decrement operation takes two argu-
ments, a pointer and a function, and works as follows. In the case the object
pointed to (call it x) has a reference count of 1 before the decrement, the
function is executed with x as a linear argument. Since the function treats x

1.3
Extensions and Variations
29
Syntax
q
::=
qualiﬁers:
...
as before
rc
ref. count
t
::=
terms:
...
as before
inc(t)
increment count
dec(t,t)
decrement count
Qualiﬁer Relations
rc ⊑un
(Q-RCUn)
lin ⊑rc
(Q-LinRC)
Typing
Γ ⊢t : T
Γ ⊢t : rc P
Γ ⊢inc(t) : lin (rc P * rc P)
(T-Inc)
Γ ⊢t1 : rc P
Γ ⊢t2 : lin P →unit
Γ ⊢dec(t1,t2) : unit
(T-Dec)
Figure 1-16: Linear lambda calculus: Reference counting syntax and typing
linearly, it will deallocate x before it completes. In the other case, when x has
a reference count greater than 1, the reference count is simply decremented
and the function is not called; unit is returned as the result of the operation.
The main typing invariant in this system is that whenever a reference-
counted variable appears in the static type-checking context, there is one
dynamic reference count associated with it. Linear typing will ensure the
number of references to an object is properly preserved.
The new rc qualiﬁer should be treated in the same manner as the linear
qualiﬁer when it comes to context splitting. In other words, a reference-
counted variable should be placed in exactly one of the left-hand context
or the right-hand context (not both). In terms of containment, the rc quali-
ﬁer sits between unrestricted and linear qualiﬁers: A reference-counted data
structure may not be contained in unrestricted data structures and may not
contain linear data structures. Figure 1-16 presents the appropriate qualiﬁer
relation and typing rules for our reference counting additions.
In order to deﬁne the execution behavior of reference-counted data struc-
tures, we will deﬁne a new sort of stored value with the form rc(n) w. The
integer n is the reference count: it keeps track of the number of times the
value is referenced elsewhere in the store or in the program.
The operational semantics for the new commands and reference-counted
pairs and functions are summarized in Figure 1-17. Several new bits of no-
tation show up here to handle the relatively complex computation that must
go on to increment and decrement reference counts. First, in a slight abuse
of notation, we allow q to range over static qualiﬁers un, lin and rc as well
as dynamic qualiﬁers un, lin and rc(n). Context will disambiguate the two

30
1
Substructural Type Systems
diﬀerent sorts of uses. Second, we extend the notation S
q∼x so that q may
be rc(n) as well as lin and un. If n is 1 then S
rc(n)
∼x removes the binding
x,rc(n) w from S. Otherwise, S
rc(n)
∼x replaces the binding x,rc(n) w with
x,rc(n-1) w. Finally, given a store S and a set of variables X, we deﬁne the
function incr(S;X), which produces a new store S′ in which the reference
count associated with any reference-counted variables x∈X is increased by 1.
To understand how the reference counting operational semantics works,
we will focus on the rules for pairs. Allocation and use of linear and unre-
stricted pairs stays unchanged from before as in rules (E-Pair’) and (E-Split’).
Rule (E-PairRC) speciﬁes that allocation of reference-counted pairs is simi-
lar to allocation of other data, except for the fact that the dynamic reference
count must be initialized to 1. Use of reference-counted pairs is identical to
use of other kinds of pairs when the reference count is 1: We remove the
pair from the store via the function S
rc(n)
∼x as shown in rule and substi-
tute the two components of the pair in the body of the term as shown in
(E-Split’). When the reference count is greater than 1, rule (E-SplitRC) shows
there are additional complications. More precisely, if one of the components
of the pair, say y1, is reference-counted then y1’s reference count must be
increased by 1 since an additional copy of y1 is substituted through the body
of t. We use the incr function to handle the possible increase. In most re-
spects, the operational rules for reference-counted functions follow the same
principles as reference-counted pairs. Increment and decrement operations
are also relatively straightforward.
In order to state and prove the progress and preservation lemmas for our
reference-counting language, we must generalize the type system slightly. In
particular, our typing contexts must be able specify the fact that a particular
reference should appear exactly n times in the store or current computation.
Reference-counted values in the store are described by these contexts and
the context-splitting relation is generalized appropriately. Figure 1-18 sum-
marizes the additional typing rules.
1.3.7
Exercise [«««, 3]: State and prove progress and preservation lemmas for
the simply-typed linear lambda calculus (functions and pairs) with reference
counting.
2
1.4
An Ordered Type System
Just as linear type systems provide a foundation for managing memory allo-
cated on the heap, ordered type systems provide a foundation for managing
memory allocated on the stack. The central idea is that by controlling the

1.4
An Ordered Type System
31
v
::=
values:
...
as before
rc(n) w
ref-counted value
E
::=
evaluation contexts:
...
as before
inc(E)
inc context
dec(E,t)
dec context
dec(x,E)
dec context
Evaluation
(S;t) -→β (S′;t′)
(q ∈{un,lin})
(S;q <y,z>) -→β (S, x , q <y,z>;x)
(E-Pair’)
(S;rc <y,z>) -→β
(S, x , rc(1) <y,z>;x)
(E-PairRC)
S(x) = q <y1,z1>
(q ∈{un,lin,rc(1)})
(S;split x as y,z in t) -→β
(S
q∼x;[y , y1][z , z1]t)
(E-Split’)
S(x) = rc(n) <y1,z1>
(n > 1)
incr(S;{y1,z1}) = S′
(S;split x as y,z in t) -→β
((S′ rc(n)
∼
x);[y , y′
1][z , z′
1]t)
(E-SplitRC)
(q ∈{un,lin})
(S;q λy:T.t) -→β (S, x , q λy:T.t;x)
(E-Fun’)
(S;rc λy:T.t) -→β
(S, x , rc(1) λy:T.t;x)
(E-FunRC)
S(x1) = q λy:T.t
(q ∈{un,lin,rc(1)})
(S;x1 x2) -→β (S
q∼x1;[y , x2]t)
(E-App’)
S(x1) = rc(n) λy:T.t
(n > 1 and X = FV(λy:T.t))
incr(S;X) = S′
(S;x1 x2) -→β (S′ rc(n)
∼
x1;[y , x2]t)
(E-AppRC)
incr(S;{x}) = S′
(S;inc(x)) -→β (S′;lin <x,x>)
(E-Inc)
(S(x) = rc(n) w)
(n > 1)
(S;dec(x,xf )) -→β (S
rc(n)
∼
x;un ())
(E-Dec1)
S = S1,x , rc(1) w,S2
S′ = S1,x , lin w,S2
(S;dec(x,xf )) -→β (S′;xf x)
(E-Dec2)
Figure 1-17: Linear lambda calculus: Reference counting operational semantics
exchange property, we are able to guarantee that certain values, those values
allocated on the stack, are used in a ﬁrst-in/last-out order.
To formalize this idea, we organize the store into two parts: a stack, which
is a sequence of locations that can be accessed on one end (the “top”) and
a heap, which is like the store described in previous sections of this chap-
ter. Pairs, functions and other objects introduced with unrestricted or linear
qualiﬁers are allocated on the heap as before. And as before, when a linear
pair or function is used, it is deallocated. Also, we allow programmers to allo-
cate simple data structures on the stack. Without the exchange property, an
ordered object can only be used when it is at the top of the stack. When this
happens, the ordered object is popped oﬀthe top of the stack.

32
1
Substructural Type Systems
Syntax
Γ
::=
typing contexts:
...
as before
Γ, x:rc(n)P
rc(n) context
Store Typing
⊢S : Γ1 ◦Γ2
Γ1 ⊢rc w : rc P
⊢S,x , rc(n) w : Γ2, x:rc(n) P (T-NextrcS)
Context Splitting
Γ = Γ1 ◦Γ2
n = i + j
Γ, x:rc(n)P =
(Γ1, x:rc(i)P) ◦(Γ2, x:rc(j)P)
(M-RC)
(when i or j is 0, the corresponding binding is
removed from the context)
Variable Typing
un (Γ1, Γ2)
Γ1, x:rc(1)P, Γ2 ⊢x : rc P
(T-RCVar)
Figure 1-18: Linear lambda calculus: Reference counting run-time typing
Syntax
The overall structure and mechanics of the ordered type system are very
similar to the linear type system developed in previous sections. Figure 1-19
presents the syntax. One key change from our linear type system is that we
have introduced an explicit sequencing operation let x = t1 in t2 that ﬁrst
evaluates the term t1, binds the result to x, and then continues with the eval-
uation of t2. This sequencing construct gives programmers explicit control
over the order of evaluation of terms, which is crucial now that we are intro-
ducing data that must be used in a particular order. Terms that normally can
contain multiple nested subexpressions such as pair introduction and func-
tion application are syntactically restricted so that their primary subterms
are variables and the order of evaluation is clear.
The other main addition is a new qualiﬁer ord that marks data allocated on
the stack. We only allow pairs and values with base type to be stack-allocated;
functions are allocated on the unordered heap. Therefore, we declare types
ord T1 →T2 and terms ord λx:T.t to be syntactically ill-formed.
Ordered assumptions are tracked in the type checking context Γ like other
assumptions. However, they are not subject to the exchange property. More-
over, the order that they appear in Γ mirrors the order that they appear on
the stack, with the rightmost position representing the stack’s top.
Typing
The ﬁrst step in the development of the type system is to determine how
assumptions will be used. As before, unrestricted assumptions can be used

1.4
An Ordered Type System
33
Syntax
q
::=
qualiﬁers:
ord
ordered
lin
linear
un
unrestricted
t
::=
terms:
x
variable
q b
Boolean
if t then t else t
conditional
q <x,y>
pair
split t as x,y in t
split
q λx:T.t
abstraction
x y
application
let x = t in t
sequencing
P
::=
pretypes:
Bool
booleans
T*T
pairs
T→T
functions
T
::=
types:
q P
qualiﬁed pretype
Γ
::=
contexts:
∅
empty context
Γ, x:T
term variable binding
Figure 1-19: Ordered lambda calculus: Syntax
as often as the programmer likes but linear assumptions must be used ex-
actly once along every control ﬂow path. Ordered assumptions must be used
exactly once along every control ﬂow path,in the order in which they appear.
As before, the context splitting operator (Γ = Γ1 ◦Γ2) helps propagate as-
sumptions properly, separating the context Γ into Γ1 and Γ2. Some sequence
of ordered assumptions taken from the left-hand side of Γ are placed in Γ1
and the remaining ordered assumptions are placed in Γ2. Otherwise, the split-
ting operator works the same as before. In the typing rules, the context Γ2
is used by the ﬁrst subexpression to be evaluated (since the top of the stack
is at the right) and Γ1 is used by the second subexpression to be evaluated.
Formally, we deﬁne the "=" relation in terms of two subsidiary relations: "=1,"
which places ordered assumptions in Γ1, and "=2," which places ordered as-
sumptions in Γ2. See Figure 1-20.
The second step in the development of the type system is to determine the
containment rules for ordered data structures. Previously, we saw that if an
unrestricted object can contain a linear object, a programmer can write func-
tions that duplicate or discard linear objects, thereby violating the central
invariants of the system. A similar situation arises if linear or unrestricted
objects can contain stack objects; in either case, the stack object might be
used out of order, after it has been popped oﬀthe stack. The typing rules
use the qualiﬁer relation q1⊑q2, which speciﬁes that ord⊑lin⊑un, to ensure
such problems do not arise.
The typing rules for the ordered lambda calculus appear in Figure 1-21. For
the most part, the containment rules and context splitting rules encapsulate

34
1
Substructural Type Systems
Context Split
Γ = Γ1 ◦Γ2
Γ =2 Γ1 ◦Γ2
Γ = Γ1 ◦Γ2
(M-Top)
∅=1 ∅◦∅
(M-Empty)
Γ =1 Γ1 ◦Γ2
Γ, x:ord P =1 (Γ1, x:ord P) ◦Γ2
(M-Ord1)
Γ =2 Γ1 ◦Γ2
Γ, x:ord P =2 Γ1 ◦(Γ2, x:ord P)
(M-Ord2)
Γ =1 Γ1 ◦Γ2
Γ =2 Γ1 ◦Γ2
(M-1to2)
Γ =1,2 Γ1 ◦Γ2
Γ, x:lin P =1,2 (Γ1, x:lin P) ◦Γ2
(M-LinA)
Γ =1,2 Γ1 ◦Γ2
Γ, x:lin P =1,2 Γ1 ◦(Γ2, x:lin P)
(M-LinB)
Γ =1,2 Γ1 ◦Γ2
Γ, x:un P =1,2 (Γ1, x:un P) ◦(Γ2, x:un P)
(M-Un)
Figure 1-20: Ordered lambda calculus: Context splitting
the tricky elements of the type system. The rules for pairs illustrate how this
is done. The rule for introducing pairs (T-OPair) splits the incoming context
into two parts, Γ1 and Γ2; any ordered assumptions in Γ2 will represent data
closer to the top of the stack than Γ1. Therefore, if the pair (x) and its two
components x1 and x2 are all allocated on the stack, then the pointer x will
end up on top, x2 next and x1 on the bottom. The elimination rule for pairs
(T-OSplit) is careful to maintain the proper ordering of the context. As above,
the rule splits the context into Γ1 and Γ2, where Γ2, which represents data on
top of the stack, is used in a computation t1 that generates a pair. The context
Γ1, x1:T1, x2:T2 is used to check t2. Notice that if both components of the
pair, x1 and x2, were allocated on the stack when the pair was introduced,
they reappear back in the context in the appropriate order.
Consider the following function, taking a boolean and a pair allocated se-
quentially at the top of the stack. The boolean is at the very top of the stack
and the integer pair is next (the top is to the right). If the boolean is true,
it leaves the components of the pair (two unrestricted integers) in the same
order as given; otherwise, it swaps them.
λx:ord (ord (int * int) * bool).
split x as p,b in
if b then
p
else
split p as i1,i2 in
ord <i2,i1>

1.4
An Ordered Type System
35
Typing
Γ ⊢t : T
un (Γ1, Γ2)
Γ1, x:T, Γ2 ⊢x : T
(T-OVar)
un (Γ)
Γ ⊢q b : q Bool
(T-OBool)
Γ2 ⊢t1 : q Bool
Γ1 ⊢t2 : T
Γ1 ⊢t3 : T
Γ1 ◦Γ2 ⊢if t1 then t2 else t3 : T
(T-OIf)
Γ1 ⊢x1 : T1
Γ2 ⊢x2 : T2
q(T1)
q(T2)
Γ1 ◦Γ2 ⊢q <x1,x2> : q (T1*T2)
(T-OPair)
Γ2 ⊢t1 : q (T1*T2)
Γ1, x1:T1, x2:T2 ⊢t2 : T
Γ1 ◦Γ2 ⊢split t1 as x1,x2 in t2 : T
(T-OSplit)
q(Γ)
Γ, x:T1 ⊢t2 : T2
Γ ⊢q λx:T1.t2 : q T1→T2
(T-OAbs)
Γ1 ⊢x1 : q T11→T12
Γ2 ⊢x2 : T11
Γ1 ◦Γ2 ⊢x1 x2 : T12
(T-OApp)
Γ2 ⊢t1 : T1
Γ1, x:T1 ⊢t2 : T2
Γ1 ◦Γ2 ⊢let x = t1 in t2 : T2
(T-OLet)
Figure 1-21: Ordered lambda calculus: Typing
Operational Semantics
To deﬁne the operational semantics for our new ordered type system, we will
divide our previous stores into two parts, a heap H and a stack K. Both are
just a list of bindings as stores were before (see Figure 1-22). We also deﬁne a
couple of auxiliary functions. The ﬁrst says what it means to add a binding to
the store. This is straightforward: unrestricted and linear bindings are added
to the heap and ordered bindings are added to the top of the stack.
(H;K),x , ord w
=
(H;K,x , ord w)
(H;K),x , lin w
=
(H,x , lin w;K)
(H;K),x , un w
=
(H,x , un w;K)
The second function speciﬁes how to remove a binding from the store.
Notice that ordered deallocation will only remove the object at the top of the
stack.
(H;K,x , v) ord
∼x
=
H;K
(H1,x , v,H2;K) lin
∼x
=
H1,H2;K
(H;K) un
∼x
=
H;K
With these simple changes, the evaluation rules from previous sections can
be reused essentially unchanged. However, we do need to add the evaluation
context for sequencing (let x = E in t) and its evaluation rule:
(S;let x = x1 in t2) -→β (S;[x , x1]t1)
(E-Let)

36
1
Substructural Type Systems
S
::=
stores:
H;K
complete store
H
::=
heap:
∅
empty heap
H, x , lin w
linear heap binding
H, x , un w unrestricted heap binding
K
::=
stack:
∅
empty stack
K, x , ord w
stack binding
Figure 1-22: Ordered lambda calculus: Operational semantics
1.4.1
Exercise [Recommended, «]: Write a program that demonstrates what can
happen if the syntax of pair formation is changed to allow programmers to
write nested subexpressions (i.e., we allow the term ord <t1,t2> rather than
the term ord <x,y>).
2
1.4.2
Exercise [Recommended, ««]: Demonstrate the problem with allowing or-
dered functions (i.e., admitting the syntax ord λx:T1.t and ord T1 →T2) by
writing a well-typed program that uses ordered functions and gets stuck.
2
1.4.3
Exercise [«««]: Modify the language so that programmers can use stack-
allocated, ordered functions. There are many solutions to this problem, some
more sophisticated than others.
2
1.5
Further Applications
Memory management applications make good motivation for substructural
type systems and provides a concrete framework for studying their proper-
ties. However, substructural types systems, and their power to control the
number and order of uses of data and operations, have found many appli-
cations outside of this domain. In the following paragraphs, we informally
discuss a few of them.
Controlling Temporal Resources
We have studied several ways that substructural type systems can be used to
control physical resources such as memory and ﬁles. What about controlling
the temporal resources? Amazingly, substructural type systems can play a
role here as well: Careful crafting of a language with an aﬃne type system,
where values are used at most once, can ensure that computations execute in
polynomial time.

1.5
Further Applications
37
To begin, we will allow our polynomial time language to contain aﬃne
booleans, pairs and (non-recursive) functions. In addition, to make things in-
teresting, we will add aﬃne lists to our language, which have constructors
nil and cons and a special iterator to recurse over objects with list type.
Such iterators have the following form.
iter (stop ⇒t1 | x with y ⇒t2)
If t1 has type T and t2 also has type T (under the assumption that x has type
T1 and y has type T1 list), our iterator deﬁnes a function from T1 lists to
objects with type T. Operationally, the iterator does a case to see whether its
input list is nil or cons(hd,tl) and executes the corresponding branch. We
can deﬁne the operation of iterators using two simple rules.1
iter (stop ⇒t1 | hd with rest ⇒t2) nil -→β t1
(E-IterNil)
iter (stop ⇒t1 | hd with rest ⇒t2) v2 -→∗
β v′
2
iter (stop ⇒t1 | hd with rest ⇒t2) cons(v1,v2) -→β
[hd , v1][rest , v′
2]t2
(E-IterCons)
In the second rule, the iterator is invoked inductively on v2, giving the result
v′
2, which is used in term t2. The familar append function below illustrates
the use of iterators.
val append : T list→T list→T list =
iter (
stop ⇒λ(l:T list).l
| hd with rest ⇒λ(l:T list).cons(hd,rest l))
When applied to a list l1, append builds up a function that expects a second
list l2 and concatenates l2 to the end of l1. Clearly, append is a polynomial
time function, a linear-time one in fact, but it is straightforward to write ex-
ponential time algorithms in the language as we have deﬁned it so far. For
instance:
val double : T list→T list =
iter (stop ⇒nil | hd with rest ⇒cons(hd,cons(hd,rest)))
val exp : T list→T list =
iter (stop ⇒nil | hd with rest ⇒double (cons(hd,rest)))
1. Since we are not interested in memory management here, we have simpliﬁed our opera-
tional semantics from previous parts of this chapter by deleting the explicit store and using
substitution instead. The operational judgment has the form t -→βt′ and, in general, is deﬁned
similarly to the operational systems in TAPL.

38
1
Substructural Type Systems
The key problem here is that it is trivial to write iterators like double that
increase the size of their arguments. After constructing one of these, we can
use it as the inner loop of another, like exp, and cause an exponential blow-
up in running time. But this is not the only problem. Higher-order functions
make it even easier to construct exponential-time algorithms:
val compose =
λ(fg:(T list→T list) * (T list→T list)).
λ(x:T list).
split fg as f,g in f (g x)
val junk : T
val exp2 : T list→T list→T list =
iter (
stop ⇒λ(l:T list).cons(junk,l)
| hd with rest ⇒λ(l:T list).compose <rest,rest> l)
Fortunately, a substructural type system can be used to eliminate both
problems by allowing us to deﬁne a class of non-size-increasing functions
and by preventing the construction of troublesome higher-order functions,
such as exp2.
The ﬁrst step is to demand that all user-deﬁned objects have aﬃne type.
They can be used zero or one times, but not more. This restriction immedi-
ately rules out programs such as exp2. System deﬁned operators like cons
can be used many times.
The next step is to put mechanisms in place to prevent iterators from in-
creasing the size of their inputs. This can be achieved by altering the cons
constructor so that it can only be applied when it has access to a special
resource with type R.
operator cons : (R,T,T list) →T list
There is no constructor for resources with type R so they cannot be generated
out of thin air; we can only apply fcons as many times as we have resources.
We also adapt the syntax for iterators as follows.
iter (stop ⇒t1 | hd with tl and r ⇒t2)
Inside the second clause of the iterator, we are only granted a single resource
(r) with which to allocate data. Consequently, we can allocate at most one
cons cell in t2. This provides us with the power to rebuild a list of the same
size, but we cannot write a function such as double that doubles the length
of the list or exp that causes an exponential increase in size. To ensure that

1.5
Further Applications
39
a single resource from an outer scope does not percolate inside the iterator
and get reused on each iteration of the loop, we require that iterators be
closed, mirroring the containment rules for recursive functions deﬁned in
earlier sections of this chapter.
Although restricted to polynomial time, our language permits us to write
many useful functions in a convenient fashion. For instance, we can still write
append much like we did before. The resource we acquire from destructing
the list during iteration can be used to rebuild the list later.
val append : T list →T list →T list =
iter (
stop ⇒λ(l:T list).l
| hd with rest and r ⇒λ(l:T list). cons(r,hd,rest l))
We can also write double if our input list comes with appropriate credits,
in the form of unused resources.
val double : (T*R) list →T list =
iter (
stop ⇒nil
| hd with rest and r1 ⇒
split hd as x,r2 in cons(r1,hd,cons(r2,hd,rest)))
Fortunately, we will never be able to write exp, unless, of course, we are
given an exponential number of credits in the size of the input list. In that
case, our function exp would still only run in linear time with respect to our
overall input (list and resources included).
The proof that all (ﬁrst-order) functions we can deﬁne in this language run
in polynomial time uses some substantial domain theory that lies outside
the scope of this book. However, the avid reader should see Section 1.6 for
references to the literature where these proofs can be found.
Compiler Optimizations
Many compiler optimizations are enabled when we know that there will be at
most one use or at least one use of a function, expression or data structure.
If there is at most one use of an object then we say that object has aﬃne
type. If there is at least one use then we say the object has relevant (or strict)
type. The following sorts of optimizations employ usage information directly;
several of them have been implemented in the Glasgow Haskell Compiler.
•
Floating in bindings. Consider the expression let x = e in (λy....x...).
Is it a good idea to ﬂoat the binding inside the lambda and create the new

40
1
Substructural Type Systems
expression λy.let x = e in (...x...)? The answer depends in part on
how many times the resulting function is used. If it is used at most once,
the optimization might be a good one: we may avoid computing e and will
never compute it more than once.
•
Inlining expressions. In the example above, if we have the further informa-
tion that x itself is used at most once inside the body of the function, then
we might want to substitute the expression e for x. This may give rise to
further local optimizations at the site where e is used. Moreover, if it turns
out that e is used zero times (as opposed to one time) we will have saved
ourselves the trouble of computing it.
•
Thunk update avoidance. In lazy functional languages such as Haskell,
evaluation of function parameters is delayed until the parameter is ac-
tually used in the function body. In order to avoid recomputing the value
of the parameter each time it is used, implementers make each parameter
a thunk—a reference that may either hold the computation that needs to
be run or the value itself. The ﬁrst time the thunk is used, the computation
will be run and will produce the necessary result. In general, this result is
stored back in the thunk for all future uses of the parameter. However, if
the compiler can determine that the data structure is used as most once,
this thunk update can be avoided.
•
Eagerness. If we can tell that a Haskell expression is used at least once,
then we can evaluate it right away and avoid creating a thunk altogether.
The optimizations described above may be implemented in two phases. The
ﬁrst phase is a program analysis that may be implemented as aﬃne and/or
relevant type inference. After the analysis phase, the compiler uses the infor-
mation to transform programs. Formulating compiler optimizations as type
inference followed by type-directed translation has a number of advantages
over other techniques. First, the language of types can be used to communi-
cate optimization information across modular boundaries. This can facilitate
the process of scaling intra-procedural optimizations to inter-procedural op-
timizations. Second, the type information derived in one optimization pass
can be maintained and propagated to future optimization passes or into the
back end of the compiler where it can be used to generate Typed Assembly
Language or Proof-Carrying Code, as discussed in Chapters 4 and 5.
1.6
Notes
Substructural logics are very old, dating back to at least Orlov (1928), who ax-
iomatized the implicational fragment of relevant logic. Somewhat later, Moh

1.6
Notes
41
(1950) and Church (1951) provided alternative axiomatizations of the rele-
vant logic now known as R. In the same time period, Church was developing
his theory of the lambda calculus at Princeton University, and his λI calculus
(1941), which disallowed abstraction over variables that did not appear free
in the body of the term, was the ﬁrst substructural lambda calculus. Lambek
(1958) introduced the ﬁrst “ordered logic,” and used it to reason about natu-
ral language sentence structure. More recently, Girard (1987) developed linear
logic, which gives control over both contraction and weakening, and yet pro-
vides the full power of intuitionistic logic through the unrestricted modality
“!”. O’Hearn and Pym (1999) show that the logic of bunched implications pro-
vides another way to recapture the power of intuitionistic logic while giving
control over the structural rules.
For a comprehensive account of the history of substructural logics, please
see Došen (1993), who is credited with coining the phrase “substructural
logic,” or Restall (2005). Restall’s textbook on substructural logics (2000) pro-
vides good starting point to those looking to study the technical details of
either the proof theory or model theory for these logics.
Reynolds pioneered the study of substructural type systems for program-
ming languages with his development of syntactic control of interference
(1978; 1989), which prevents two references from being bound to the same
variable and thereby facilitates reasoning about Algol programs. Later, Gi-
rard’s development of linear logic inspired many researchers to develop func-
tional languages with linear types. One of the main applications of these new
type systems was to control eﬀects and enable in-place update of arrays in
pure functional languages.
Lafont (1988) was the one of the ﬁrst to study programming languages
with linear types, developing a linear abstract machine. He was soon followed
by many other researchers, including Baker (1992) who informally showed
how to compile Lisp into a linear assembly language in which all allocation,
deallocation and pointer manipulation is completely explicit, yet safe. An-
other inﬂuential piece of work is due to Chirimar, Gunter, and Riecke (1996)
who developed an interpretation of linear logic based on reference count-
ing. The reference counting scheme described here is directly inspired by the
work of Chirimar et al., but the technical setup is slightly diﬀerent; we have
explicit operations to increment and decrement reference counts whereas in-
crementing and decrementing counts in Chirimar’s system is done implicitly.
Stephanie Weirich suggested the invariant for proving our reference count-
ing system sound. Turner and Wadler (1999) summarize two computational
interpretations that arise directly through the Curry-Howard isomorphism
from Girard’s linear logic. They diﬀer from the account given in this chapter
as neither account has both shared, usable data structures and deallocation.
Unfortunately, these two features together appear incompatible with a type

42
1
Substructural Type Systems
system derived directly from linear logic and its single unrestricted modality.
The development of practical linear type systems with two classes of type,
one linear and one unrestricted, began with Wadler’s work (1990) in the early
nineties. The presentation given in this chapter is derived from Wadler’s work
and is also inspired by work from Wansbrough and Peyton Jones (1999) and
Walker and Watkins (2001). Wansbrough and Peyton Jones included qualiﬁer
subtyping and bounded parametric polymorphism in their system in addition
to many of the features described here. Walker and Watkins added reference
counting features to a language with linear types and also memory regions.
The idea of formulating the system with a generic context splitting operator
was taken from Cervesato and Pfenning’s presentation of Linear LF (2002).
The algorithmic type system described in section 1-5 solves what is com-
monly known in the linear logic programming and theorem proving literature,
as the resource management problem. Many of the ideas for the current pre-
sentation came from work by Cervesato, Hodas, and Pfenning (2000), who
solve the more general problem that arises when linear logic’s additive con-
nectives are considered. Hofmann takes a related approach when solving the
type inference problem for a linearly-typed functional language (1997a).
The ordered type system developed here is derived from Polakow and Pfen-
ning’s ordered logic (1999), in the same way that the practical linear type
systems mentioned above emerged from linear logic. It was also inspired by
the ordered lambda calculus of Petersen, Harper, Crary, and Pfenning (2003),
though there are some technical diﬀerences. Ahmed and Walker (2003) and
Ahmed, Jia, and Walker (2003) use an ordered, modal logic to specify memory
invariants and have integrated the logical speciﬁcations into a low-level typed
language. Igarashi and Kobayashi (2002) have used ordered types to explore
the more general problem of resource usage analysis. In addition, they have
developed eﬀective type inference algorithms for their type systems.
Recently, O’Hearn (2003) has proposed bunched typing, a new form of sub-
structural typing, to control interference between mutable variables, gener-
alizing Reynolds’s earlier work on syntactic control of interference. These
bunched types were derived from earlier work by O’Hearn and Pym (1999)
on bunched logic. Together, Reynolds, Ishtiaq, and O’Hearn (Reynolds, 2000;
Ishtiaq and O’Hearn, 2001) have used bunched logic to develop a system for
verifying programs that explicitly allocate and deallocate data.
Analysis and reasoning about the time and space complexity of programs
has always been an important part of computer science. However, the use
of programming language technology, and type systems in particular, to au-
tomatically constrain the complexity of programs is somewhat more recent.
For instance, Bellantoni and Cook (1992) and Leivant (1993) developed pred-
icative systems that control the use and complexity of recursive functions.

1.6
Notes
43
It is possible to write all, and only, the polynomial-time functions in their
system. However, it is not generally possible to compose functions and there-
fore many “obviously” polynomial-time algorithms cannot be coded naturally
in their system. Girard (1998), Hofmann (2000; 1999), and Bellantoni, Niggl,
and Schwichtenberg (2000) show how linear type systems can be used to al-
leviate some of these diﬃculties. The material presented in this chapter is
derived from Hofmann’s work.
One of the most successful and extensive applications of substructural
type systems in programming practice can be found in the Concurrent Clean
programming language (Nöcker, Smetsers, van Eekelen, and Plasmeijer, 1991).
Clean is a commercially developed, pure functional programming language. It
uses uniqueness types (Barendsen and Smetsers, 1993), which are a variant of
linear types, and strictness annotations (Nöcker and Smetsers, 1993) to help
support concurrency, I/O and in-place update of arrays. The implementation
is fast and is fully supported by a wide range of program development tools
including an Integrated Development Environment for project management
and GUI libraries, all developed in Clean itself.
Substructural type systems have also found gainful employment in the in-
termediate languages of the Glasgow Haskell Compiler. For instance, Turner,
Wadler, and Mossin (1995) and Wansbrough and Peyton Jones (1999) showed
how to use aﬃne types and aﬃne type inference to optimize programs as
discussed earlier in this chapter. They also use extensive strictness analysis
to avoid thunk creation.
Recently, researchers have begun to investigate ways to combine substruc-
tural type systems with dependent types and eﬀect systems such as those
described in Chapters 2 and 3. The combination of both dependent and sub-
structural types provides a very powerful tool for enforcing safe memory
management and more general resource-usage protocols. For instance, De-
Line and Fähndrich developed Vault (2001; 2002), a programming language
that uses static capabilities (Walker, Crary, and Morrisett, 2000) (a hybrid
form of linear types and eﬀects) to enforce a variety of invariants in Microsoft
Windows device drivers including locking protocols, memory management
protocols and others. Cyclone (Jim et al., 2002; Grossman et al., 2002), a
completely type-safe substitute for C, also uses linear types and eﬀects to
grant programmers ﬁne-grained control over memory allocation and deallo-
cation. In each of these cases, the authors do not stick to the pure linear types
described here. Instead, they add coercions to the language to allow linearly-
typed objects to be temporarily aliased in certain contexts, following a long
line of research on this topic (Wadler, 1990; Odersky, 1992; Kobayashi, 1999;
Smith, Walker, and Morrisett, 2000; Aspinall and Hofmann, 2002; Foster, Ter-
auchi, and Aiken, 2002; Aiken, Foster, Kodumal, and Terauchi, 2003).


2
Dependent Types
David Aspinall and Martin Hofmann
In the most general sense, dependent types are type-valued functions. This
deﬁnition includes, for example, the type operators of F ω such as Pair. When
applied to two types S and T, this yields the type Pair S T whose elements
are pairs (s, t) of elements s from S and t from T (see TAPL, Chapter 29).
However, the terminology “dependent types” is usually used to indicate a
particular class of type-valued functions: those functions which send terms
to types. In this chapter we study this kind of dependency.
2.1
Motivations
We begin the chapter by looking at a few representative examples of where
type-term dependency occurs naturally.
Programming with Vectors and Format Strings
The prototypical example of programming with dependent types is intro-
duced by the type family of vectors (one-dimensional arrays):
Vector :: Nat →∗
This kinding assertion states that Vector maps a natural number k:Nat to
a type. The idea is that the type Vector k contains vectors of length k of
elements of some ﬁxed type, say data.
To use vectors, we need a way of introducing them. A useful initialization
function takes a length n, a value t of type data, and returns a vector with n
The system studied in this chapter is the dependently typed lambda-calculus, λLF (Figures 2-1,
2-2), extended with Σ-types (Figure 2-5) and the Calculus of Constructions (Figure 2-7). The
associated OCaml implementation, called deptypes, can be found on the book’s web site.

46
2
Dependent Types
elements all set to t. The typing of such an init function is written like this,
init : Πn:Nat. data →Vector n
and the application init k t has type Vector k.
The type of init introduces the dependent product type (or “Pi type”), writ-
ten Πx:S.T. This type generalizes the arrow type of the simply typed lambda-
calculus. It is the type of functions which map elements s:S to elements of
[x , s]T. In contrast to the simply-typed case, the result type of a function
with a Π-type can vary according to the argument supplied. According to
Seldin (2002), the Π-type goes back to Curry and is thus almost as old as the
lambda calculus itself.
A more interesting way of building up vectors is given by the constant
empty vector empty : Vector 0 and a constructor for building longer vectors:
cons : Πn:Nat. data →Vector n →Vector (n+1).
The typing of cons expresses that cons takes three arguments: a natural
number n, an element of type data, and a vector of length n. The result is
a vector of length n+1. This means that, for example, if v : Vector 5 and
x : data, then cons 5 x v : Vector 6.
The dependent product type Πx:S.T is somewhat analogous to the uni-
versal type ∀X.T of System F. The type of a term t with type ∀X.T also
varies with the argument supplied; but in the case of a type abstraction, the
argument is a type rather than a term. If A is a type, then t A:[X , A]T. In
System F (and F ω), type variation occurs only with type arguments, whereas
in dependent type theory it may occur with term-level arguments.
The reader familiar with programming with ordinary arrays will have real-
ized that by using a type of arrays instead of vectors we could avoid depen-
dent typing. The initialization function for one-dimensional arrays could be
given the simple type Nat →data →Array, where Array is the type of arrays
with entries of type data. The point of the dependent typing is that it reveals
more information about the behavior of a term, which can be exploited to
give more precise typings and exclude more of the badly behaved terms in a
type system. For example, with the dependent type of vectors, we can type a
function that returns the ﬁrst element of a non-empty vector:
first : Πn:Nat.Vector(n+1) →data
The function first can never be applied to an empty vector—non-emptiness
is expressed within the type system itself! This is a useful gain. With ordinary
arrays instead of dependently-typed vectors, we would need some special
way to deal with the case when first is applied to the empty array. We
could return an ad-hoc default element, or we might use a language-based

2.1
Motivations
47
exception mechanism to indicate the error. Either mechanism is more clumsy
than simply prohibiting illegal applications of first from being written.
We suggested that Πx:S.T generalizes the function space S→T of simply
typed lambda calculus. In fact, we can treat S→T simply as an abbreviation:
S→T
=
Πx:S.T
where x does not appear free in T
For example, Πx:Nat.Nat is exactly equivalent to Nat →Nat. We will con-
tinue to write the arrow →whenever possible, to increase readability.
Another favorite example of a function with a useful dependent typing is
sprintf of the C language.1 Recall that sprintf accepts a format string and
list of arguments whose types must correspond to the declarations made
in the format string. It then converts the given arguments into a string and
returns it. A simpliﬁed form of sprintf might have the typing:
sprintf : Πf:Format. Data(f) →String
where we suppose that Format is a type of valid print formats (for exam-
ple, considered as character lists) and that Data(f) is the type of data cor-
responding to format f. The function Data(f) evaluates the type that the
format string describes, which might include clauses like these:
Data([])
=
Unit
Data("%d"::cs)
=
Nat * Data(cs)
Data("%s"::cs)
=
String * Data(cs)
Data(c::cs)
=
Data(cs)
This example is rather diﬀerent to the case of vectors. Vectors are uniform:
we introduce operations that are parametric in the length n, and the family
of types Vector n is indexed by n. In the case of format strings, we use case
analysis over values to construct the type Data(f) which depends on f in
an arbitrary way. Unsurprisingly, this non-uniform kind of dependent type is
more challenging to deal with in practical type systems for programming.
2.1.1
Exercise [«]: Suggest some dependent typings for familiar data types and
their operations. For example, consider matrices of size n * m and the typing
of matrix multiplication, and a type of dates where the range of the day is
restricted according to the month.
2
1. A sprintf-like formating function can also be typed in ML without dependent types if
formats are represented as appropriate higher-order functions rather than strings. For details
see Danvy (1998).

48
2
Dependent Types
The Curry-Howard Correspondence
A rather diﬀerent source for dependent typing is the Curry-Howard corre-
spondence, also known by the slogan propositions-as-types (Howard, 1980).
Under this correspondence simple types correspond to propositions in the
implicational fragment of constructive logic. A formula has a proof if and
only if the corresponding type is inhabited. For instance, the formula
((A→B) →A) →(A→B) →B
is valid in constructive logic and at the same time is inhabited, namely by
λf.λu.u(f u). The underlying philosophical idea behind this correspondence
is that a constructive proof of an implication A =⇒B ought to be understood
as a procedure that transforms any given proof of A into a proof of B.
If propositions are types, then proofs are terms. We can introduce a type
constructor Prf which maps a formula A (understood as a type) into the type
of its proofs Prf A, and then a proof of A
=⇒B becomes a λ-term of type
Prf A →Prf B. Often the type constructor Prf is omitted, notationally identi-
fying a proposition with the type of its proofs. In that case, a proof of A =⇒B
is simply any term of type A→B.
Generalizing the correspondence to ﬁrst-order predicate logic naturally
leads to dependent types: a predicate B over type A is viewed as a type-
valued function on A; a proof of the universal quantiﬁcation ∀x:A.B(a)
is—constructively—a procedure that given an arbitrary element x of type A
produces a proof of B(x). Hence under the Curry-Howard correspondence
we should identify universal quantiﬁcation with dependent product: a proof
of ∀x:A.B(x) is a member of Πx:A.B(x). Indeed, Per Martin-Löf, one of the
protagonists of dependent typing (1984), was motivated by this extension. In
particular, he introduced type-theoretic equivalents to existential quantiﬁca-
tion (Σ-types) and equality (identity types), used in the next example.
An important application of the Curry-Howard correspondence is that it
allows one to freely mix propositions and (programming language) types. For
example, an indexing function ith(n) to access elements of vectors of length
n could be given the type
Πn:Nat.Πl:Nat.Lt(l,n)→Vector(n)→T
where Lt(l,n) is the proposition asserting that l is less than n. Perhaps more
interestingly, we can package up types with axioms restricting their elements.
For instance, the type of binary, associative operations on some type T may
be given as
Σm:T→T→T.Πx:T.Πy:T.Πz:T.Id (m(x,m(y,z))) (m(m(x,y),z))

2.1
Motivations
49
Here Σx:A.B(x) is the type of pairs (a,b) where a:A and b:B(a) and Id t1 t2
is the type of proofs of the equality t1=t2. In Martin-Löf’s type theory existen-
tial quantiﬁcation is rendered with Σ-types, the idea being that a constructive
proof of ∃x:A.B(x) would consist of a member a of type A and a proof, thus
a member, of B(a)—in other words, an element of Σa:A.B(a).
2.1.2
Exercise [«]: Write down a type which represents a constructive version of
the axiom of choice, characterised by: if for every element a of a type A there
exists an element b of B such that P(a,b) then there exists a function f map-
ping an arbitrary x:A to an element of B such that P(x, f x).
2
2.1.3
Exercise [«]: Suppose that f : A→C, g : B→C are two functions with equal
target domain. Using set-theoretic notation we can form their pullback as
{(a, b) ∈A × B | f a = g b}. Deﬁne an analogous type using Σ and Id.
2
Logical Frameworks
Dependent types have also found application in the representation of other
type theories and formal systems. Suppose that we have an implementation
of dependent types and want to get a rough-and-ready typechecker for simply
typed lambda calculus. We may then make the following declarations:
Ty
:: ∗
Tm
:: Ty →∗
base : Ty
arrow : Ty →Ty →Ty
app
: ΠA:Ty.ΠB:Ty.Tm(arrow A B) →Tm A →Tm B
lam
: ΠA:Ty.ΠB:Ty.(Tm A →Tm B) →Tm(arrow A B)
Here Ty represents the type of simple type expressions and for A:Ty the
type Tm A represents the type of lambda terms of type A. We have a constant
base:Ty representing the base type and a function arrow representing the
formation of arrow types. As for terms we have a function app that accepts
to types A,B, a term of type arrow A B, a term of type A and yields a term of
type B: the application of the two.
Somewhat intriguingly, the function corresponding to lambda abstraction
takes a “function” mapping terms of type A to terms of type B and returns a
term of type arrow A B. This way of using functions at one level to represent
dependencies at another level is particularly useful for representing syntax
with binders, and the technique is known as higher-order abstract syntax.
We can now represent familiar terms such as the identity on A:Ty by
idA = lam A A (λx:Tm A.x)

50
2
Dependent Types
or the Church numeral 2 on type A by
two = λA:Ty.lam A (arrow (arrow A A) A)
(λx:Tm A.lam _ _ (λf:Tm(arrow A A).
app _ _ f (app _ _ f x)))
(replacing some obvious type arguments by underscores to aid readability).
Logical frameworks are systems which provide mechanisms for represent-
ing syntax and proof systems which make up a logic. The exact representation
mechanisms depend upon the framework, but one approach exempliﬁed in
the Edinburgh Logical Framework (Harper, Honsell, and Plotkin, 1993) is sug-
gested by the slogan judgments-as-types, where types are used to capture the
judgments of a logic.2
2.1.4
Exercise [«]: Write down some typing declarations which introduce a judg-
ment expressing an evaluation relation for the representation of simply typed
terms shown above. You should begin with a type family Eval which is pa-
rameterized on a simple type A and two terms of type Tm A, and declare four
terms which represent the rules deﬁning the compatible closure of one-step
beta-reduction.
2
2.2
Pure First-Order Dependent Types
In this section we introduce one of the simplest systems of dependent types,
in a presentation called λLF. As the name suggests, this type system is based
on a simpliﬁed variant of the type system underlying the Edinburgh LF, men-
tioned above. The λLF type theory generalizes simply typed lambda-calculus
by replacing the arrow type S→T with the dependent product type Πx:S.T
and by introducing type families. It is pure, in the sense that it has only Π-
types; it is ﬁrst-order, in the sense that it does not include higher-order type
operators like those of F ω. Under the Curry-Howard correspondence, this
system corresponds to the ∀,→-fragment of ﬁrst-order predicate calculus.
Syntax
The main deﬁnition of λLF appears in Figure 2-1 and 2-2. The terms are
the same as those of the simply typed lambda calculus λ→. The types in-
clude type variables X which can be declared in the context but never appear
bound. Type variables range over proper types as well as type familes such as
2. Judgments are the statements of a logic or a type system. For example, well-formedness,
derivability, well-typedness. In LF these judgments are represented as types and derivations of
a judgment are represented as members.

2.2
Pure First-Order Dependent Types
51
λLF
Syntax
t
::=
terms:
x
variable
λx:T.t
abstraction
t t
application
T
::=
types:
X
type/family variable
Πx:T.T
dependent product type
T t
type family application
K
::=
kinds:
∗
kind of proper types
Πx:T.K
kind of type families
Γ
::=
contexts:
∅
empty context
Γ, x:T
term variable binding
Γ, X::K
type variable binding
Well-formed kinds
Γ ⊢K
Γ ⊢∗
(Wf-Star)
Γ ⊢T :: ∗
Γ, x:T ⊢K
Γ ⊢Πx:T.K
(Wf-Pi)
Kinding
Γ ⊢T :: K
X :: K ∈Γ
Γ ⊢K
Γ ⊢X :: K
(K-Var)
Γ ⊢T1 :: ∗
Γ, x:T1 ⊢T2 :: ∗
Γ ⊢Πx:T1.T2 :: ∗
(K-Pi)
Γ ⊢S :: Πx:T.K
Γ ⊢t : T
Γ ⊢S t : [x , t]K
(K-App)
Γ ⊢T :: K
Γ ⊢K≡K′
Γ ⊢T :: K′
(K-Conv)
Typing
Γ ⊢t : T
x:T ∈Γ
Γ ⊢T :: ∗
Γ ⊢x : T
(T-Var)
Γ ⊢S :: ∗
Γ, x:S ⊢t : T
Γ ⊢λx:S.t : Πx:S.T
(T-Abs)
Γ ⊢t1 : Πx:S.T
Γ ⊢t2 : S
Γ ⊢t1 t2 : [x , t2]T
(T-App)
Γ ⊢t : T
Γ ⊢T ≡T′ :: ∗
Γ ⊢t : T′
(T-Conv)
Figure 2-1: First-order dependent types (λLF)
Vector :: Nat →*. We may use type and term variables declared in a ﬁxed
initial context to simulate the built-in types and operators of a programming
language.3 Apart from variables, types may be dependent products or type
family applications. The latter allow us to instantiate families, for example,
to give types such as Vector k for k:Nat.
Kinds allow us to distinguish between proper types and type families.
Proper types have kind ∗while type families have dependent product kinds
of the form Πx:T.K.
Contexts may bind term variables and type variables.
3. Strictly speaking, we should consider a signature as a special form of context and con-
sider the term and type variables declared in it to be the constants of the language. This isn’t
necessary when we move to richer type theories in which it is possible to deﬁne data types.

52
2
Dependent Types
λLF
Kind Equivalence
Γ ⊢K ≡K′
Γ ⊢T1 ≡T2 :: ∗
Γ, x:T1 ⊢K1 ≡K2
Γ ⊢Πx:T1.K1 ≡Πx:T2.K2
(QK-Pi)
Γ ⊢K
Γ ⊢K ≡K
(QK-Refl)
Γ ⊢K1 ≡K2
Γ ⊢K2 ≡K1
(QK-Sym)
Γ ⊢K1 ≡K2
Γ ⊢K2 ≡K3
Γ ⊢K1 ≡K3
(QK-Trans)
Type Equivalence
Γ ⊢S ≡T :: K
Γ ⊢S1 ≡T1 :: ∗
Γ, x:T1 ⊢S2 ≡T2 :: ∗
Γ ⊢Πx:S1.S2 ≡Πx:T1.T2 :: ∗
(QT-Pi)
Γ ⊢S1 ≡S2 :: Πx:T.K
Γ ⊢t1 ≡t2 : T
Γ ⊢S1 t1 ≡S2 t2 : [x , t1]K
(QT-App)
Γ ⊢T : K
Γ ⊢T ≡T :: K
(QT-Refl)
Γ ⊢T ≡S :: K
Γ ⊢S ≡T :: K
(QT-Sym)
Γ ⊢S ≡U :: K
Γ ⊢U ≡T :: K
Γ ⊢S ≡T :: K
(QT-Trans)
Term Equivalence
Γ ⊢t1≡t2 : T
Γ ⊢S1 ≡S2 :: ∗
Γ, x:S1 ⊢t1 ≡t2 : T
Γ ⊢λx:S1.t1 ≡λx:S2.t2 : Πx:S1.T
(Q-Abs)
Γ ⊢t1 ≡s1 : Πx:S.T
Γ ⊢t2 ≡s2 : S
Γ ⊢t1 t2 ≡s1 s2 : [x , t2]T
(Q-App)
Γ, x:S ⊢t : T
Γ ⊢s : S
Γ ⊢(λx:S.t) s ≡[x , s]t : [x , s]T
(Q-Beta)
Γ ⊢t : Πx:S.T
x ̸∈FV(t)
Γ ⊢λx:T.t x ≡t : Πx:S.T
(Q-Eta)
Γ ⊢t : T
Γ ⊢t ≡t : T
(Q-Refl)
Γ ⊢t ≡s : T
Γ ⊢s ≡t : T
(Q-Sym)
Γ ⊢s ≡u : T
Γ ⊢u ≡t : T
Γ ⊢s ≡t : T
(Q-Trans)
Figure 2-2: First-order dependent types (λLF)—Equivalence rules
Typechecking Rules
The rules in Figure 2-1 deﬁne three judgment forms, for checking kind for-
mation, kinding, and typing.
The characteristic typing rules of the system are the abstraction and appli-
cation rules for terms, altered to use Π-types. The abstraction introduces a
dependent product type, checking that the domain type S is well-formed:
Γ ⊢S :: ∗
Γ, x:S ⊢t : T
Γ ⊢λx:S.t : Πx:S.T
(T-Abs)
The term application rule eliminates a term with this type, substituting the
operand in the Π-type:
Γ ⊢t1 : Πx:S.T
Γ ⊢t2 : S
Γ ⊢t1 t2 : [x , t2]T
(T-App)

2.2
Pure First-Order Dependent Types
53
The well-formedness check in T-Abs uses the kinding rules to ensure that S
is a type. Notice that this check may again invoke the typing rules, in the rule
K-App, which checks the instantiation of a type family. The kind formation
judgment also invokes the well-formedness of types (in the ﬁrst premise of
Wf-Pi), so the three judgment forms are in fact mutually deﬁned. One conse-
quence is that proofs of properties in this system typically proceed by simul-
taneous proofs for the diﬀerent judgment forms, using derivation height as
an overall measure or alternatively simultaneous structural induction.
There are two conversion rules, K-Conv and T-Conv, which allow us to
replace a kind or type with another one that is equivalent.
Kinds have the general form Πx1:T1. . . . xn:Tn.∗but in the typing rules
we only ever need to check for proper types with kind ∗. Nevertheless, we
include the K-Conv to ensure that kinding is closed under conversion within
the Ti. There is no mechanism for forming kinds by abstraction, so the only
way to construct an object of a kind other than ∗is by declaring it in the
context.
Equivalence Rules
One of the main questions in any type system is when two types should be
considered equivalent. Type equivalence is in particular needed in the appli-
cation rules T-App and K-App. To show that some actual argument has an
acceptable type for a function or type family, we may need to use the rule
T-Conv to convert the type. In fact, the algorithmic typing rules introduced
later on show that this is the only place where type equivalence is needed.
But what should our notion of type equivalence be? Without adding spe-
cial equality axioms, we can consider natural notions of equality which arise
from the type structure. With dependent types, a natural notion is to equate
types that diﬀer only in their term components, when those term compo-
nents themselves should be considered equal. So the question is reduced to
considering notions of term equality.
A ﬁrst example is a type-family application containing a β-redex, since we
consider β-equivalent λ-terms to be equal: T ((λx:S.x) z) ≡T z. A slightly
diﬀerent and more concrete example is two diﬀerent applications of the
Vector family: Vector (3 + 4) ≡Vector 7. It seems reasonable that a type-
checker should accept each of these pairs of types as being equivalent. But
we quickly come across more complex equivalences involving more com-
putation, or even, requiring proof in the general case. For example, sup-
posing x is an unknown value of type Nat and f:Nat →Nat is a function
whose behavior is known. If it happens that f x=7 for all x then we have
Vector (f x) ≡Vector 7, but this equality could be more diﬃcult to add
to an automatic typechecker.

54
2
Dependent Types
The question of what form of type equivalence to include in a system of de-
pendent types is therefore a central consideration in the design of the system.
Many diﬀerent choices have been studied, leading to systems with funda-
mentally diﬀerent character. The most notable distinction between systems
is whether or not typechecking is decidable.
In the ﬁrst case, we may choose to include only basic equalities which are
manifestly obvious. This is the viewpoint favored by Martin-Löf, who consid-
ers deﬁnitional equality to be the proper notion of equivalence. The ﬁrst two
equalities above are deﬁnitional: 3 + 4 is deﬁnitionally equal to 7 by the rules
of computation for addition. Alternatively, one may prefer to include as many
equalities as possible, to make the theory more powerful. This is the approach
followed, for example, in the type theory implemented by the NuPrl system
(1986). This formulation of type theory includes type equivalences like the
third example above, which may require arbitrary computation or proof to
establish. In such a type system, typechecking is undecidable.
For λLF, we axiomatize deﬁnitional equality based on the type structure,
which includes β and η equality on lambda terms. It is possible to deﬁne this
using a relation of equality deﬁned via compatible closure of untyped reduc-
tion (this is the approach followed by Pure Type Systems, see Section 2.7).
Instead, we give a declarative, typed deﬁnition of equivalence, using rules
which follow the same pattern as the typing rules. The advantage of this ap-
proach is that it is more extensible than the “untyped” approach and avoids
the need to establish properties of untyped reduction. See Chapter 6 in this
volume for further explanation of the issues here.
The rules for equivalence are shown in Figure 2-2. Again there are three
judgments, for equivalence of each of the syntactic categories of terms, types,
and kinds. The only interesting rules are Q-Beta and Q-Eta which introduce
β and η-equivalence on terms; the remaining rules are purely structural and
express that equivalence is a congruence.
2.3
Properties
In this section we mention some basic properties of λLF. We don’t go very far:
in Section 2.4 we introduce an algorithmic presentation of λLF which allows
us to establish further properties indirectly but rather more easily.
Basic Properties
The following properties use some additional notation. Inclusion is deﬁned
between contexts as Γ ⊆∆iff x:T ∈Γ implies x:T ∈∆, in other words,

2.3
Properties
55
Γ ⊆∆means that ∆is a permutation of an extension of Γ. We write Γ ⊢J
for an arbitrary judgment, amongst the six deﬁned in Figures 2-1 and 2-2. We
write Γ ⊢K, K′ to stand for both Γ ⊢K and Γ ⊢K′, and similarly for other
judgments.
2.3.1
Lemma [Permutation and Weakening]: Suppose Γ ⊆∆. Then Γ ⊢J implies
∆⊢J.
2
2.3.2
Lemma [Substitution]: If Γ, x:S, ∆⊢J and Γ ⊢s : S, then Γ, [x , s]∆⊢
[x , s]J.
2
2.3.3
Lemma [Agreement]: Judgments in the system are in agreement, as follows:
1. If Γ ⊢T :: K then Γ ⊢K.
2. If Γ ⊢t : T then Γ ⊢T :: ∗.
3. If Γ ⊢K ≡K′ then Γ ⊢K, K′.
4. If Γ ⊢T ≡T′ :: K then Γ ⊢T, T′ :: K.
5. If Γ ⊢t ≡t′ : T then Γ ⊢t, t′ : T.
2
2.3.4
Exercise [««, 3]: Prove the lemmas above.
2
Strong Normalization
As an auxiliary device for the soundness and completeness of algorithmic
typechecking we will now introduce general beta reduction which permits
reductions within the scope of abstractions.
We deﬁne beta reduction on λLF terms by the four rules:
t1 -→β t′
1
λx:T1.t1 -→β λx:T1.t′
1
(Beta-Abs)
t1 -→β t′
1
t1 t2 -→β t′
1 t2
(Beta-App1)
t2 -→β t′
2
t1 t2 -→β t1 t′
2
(Beta-App2)
(λx:T1.t1) t2 -→β [x , t2]t1
(Beta-AppAbs)
Notice that this reduction does not go inside the type labels of λ abstractions.
The following central result is required to ensure completeness and termi-
nation of typechecking, proved in the next section.

56
2
Dependent Types
2.3.5
Theorem [Strong normalization]: The relation -→β is strongly normaliz-
ing on well-typed terms. More precisely, if Γ ⊢t:T then there is no inﬁnite
sequence of terms (ti)i≥1 such that t = t1 and ti -→β ti+1 for i ≥1.
2
Proof:
This can be proved by deﬁning a reduction-preserving translation
from λLF to the simply-typed lambda-calculus as follows. First, for every type
variable X, no matter of what kind, we introduce a simple type variable X♮.
Second, for each type expression T, no matter of what kind, we deﬁne a sim-
ple type expression T♮by Πx:S.T♮= S♮→T♮and (T t)♮= T♮. Finally, the
mapping −♮is extended to terms and contexts by applying it to all type ex-
pressions occurring within.
Now we can show by induction on typing derivations in λLF that Γ ⊢t:T
implies Γ ♮⊢t♮:T♮, from which the result follows by the strong normalization
theorem for β-reduction of the simply typed lambda calculus.
2
Since -→β is ﬁnitely branching, this implies that for each term t there exists
a number µ(t) such that if (ti)1≤i≤k is a reduction sequence starting from t,
that is, t=t1 and ti -→β ti+1 for 1 ≤i < k then k ≤µ(t). A term t′ such that
t -→β∗t′ and t′ ̸ -→β is called a (β) normal form of t. Since -→β is conﬂuent,
see below, normal forms are unique and we may write t′ = nf(t).
2.3.6
Theorem: The relation -→β is conﬂuent.
2
2.3.7
Exercise [«««, 3]: Prove the theorem in the following way: ﬁrst show that
-→β is locally conﬂuent in the sense that if t -→β t1 and t -→β∗t2 then
t1 -→β∗t′ and t2 -→β t′ for some t′. Then conclude conﬂuence using the
fact that -→β is strongly normalizing. This last part is a standard result from
term rewriting known as Newman’s Lemma.
Alternatively, you can prove conﬂuence directly using Tait–Martin-Löf’s
method of parallel reduction, see TAPL, Chapter 30.
2
2.4
Algorithmic Typing and Equality
To implement λLF, we need to ﬁnd a formulation of the system that is closer
to an algorithm. As usual, we follow the strategy of reformulating the rules
to be syntax-directed, so that they can be used to deﬁne an algorithm going
from premises to conclusion (see the description of the implementation in
Section 2.9) . We also need an algorithm for deciding type equivalence.
The algorithmic presentation of λLF is shown in Figures 2-3 and 2-4. The
judgments mirror the deﬁning presentation, with the addition of a context
checking judgment. (This is used only to check an initial context: the rules
otherwise maintain context well-formation when extending contexts going
from conclusions to premises.)

2.4
Algorithmic Typing and Equality
57
The non-syntax-directed rules K-conv and T-conv are removed. To replace
T-conv, we add equivalence testing in the algorithmic rules for applications,
KA-app and TA-app.
The equivalence testing rules in Figure 2-4 assume that they are invoked
on well-typed phrases. We show these rules with contexts Γ to facilitate ex-
tensions to type-dependent equalities or deﬁnitions in the context (used in
the implementation), although in the rules for pure λLF, the context plays no
role in equivalence testing.
The equivalence testing algorithm on terms that is suggested by these rules
is similar to the one described in Chapter 6, but we do not make use of type
information. (Similarly, the type equivalence rules do not record kinds.) The
algorithmic judgment Γ ⊢▶s ≡t for arbitrary terms is deﬁned mutually with
Γ ⊢▶s ≡wh t which is deﬁned between weak head normal forms. Weak head
reduction is a subset of the β reduction -→β, deﬁned by the rules:
t1 -→wh t′
1
t1 t2 -→wh t′
1 t2
(WH-App1)
(λx:T1.t1) t2 -→wh [x , t2]t1
(WH-AppAbs)
Weak head reduction only applies β-reduction in the head position. The im-
plementation described in Section 2.9 adds expansion of deﬁnitions to this
reduction; see Chapter 9 for a thorough treatment of how to do this.
2.4.1
Theorem [Weak head normal forms]: If Γ ⊢t:T then there exists a unique
term t′ = whnf(t) such that t -→wh∗t′ ̸ -→wh.
2
The theorem is a direct consequence of Theorem 2.3.5 and of the fact that
-→wh is deterministic (a partial function).
Correctness of the Algorithm
We will now show that the typechecking algorithm deﬁned by the algorithmic
rules is sound, complete, and terminates on all inputs.
Since the algorithm checks the context only as it is extended, and (for ef-
ﬁciency) does not check the type of variables in the leaves, we can only ex-
pect to show soundness for contexts which are well-formed. The soundness
lemma makes use of an auxiliary algorithmic judgment for context formation:
⊢▶∅
(WFA-Empty)
⊢▶Γ
Γ ⊢▶T :: ∗
⊢▶Γ, x:T
(WFA-Tm)
⊢▶Γ
Γ ⊢▶K
⊢▶Γ, X::K
(WFA-Ty)

58
2
Dependent Types
Algorithmic kind formation
Γ ⊢▶K
Γ ⊢▶∗
(WFA-Star)
Γ ⊢▶T :: ∗
Γ, x:T ⊢▶K
Γ ⊢▶Πx:T.K
(WFA-Pi)
Algorithmic kinding
Γ ⊢▶T :: K
X :: K ∈Γ
Γ ⊢▶X :: K
(KA-Var)
Γ ⊢▶T1 :: ∗
Γ, x:T1 ⊢▶T2 :: ∗
Γ ⊢▶Πx:T1.T2 :: ∗
(KA-Pi)
Γ ⊢▶S :: Πx:T1.K
Γ ⊢▶t : T2
Γ ⊢▶T1 ≡T2
Γ ⊢▶S t : [x , t]K
(KA-App)
Algorithmic typing
Γ ⊢▶t : T
x:T ∈Γ
Γ ⊢▶x : T
(TA-Var)
Γ ⊢▶S :: ∗
Γ, x:S ⊢▶t : T
Γ ⊢▶λx:S.t : Πx:S.T
(TA-Abs)
Γ ⊢▶t1 : Πx:S1.T
Γ ⊢▶t2 : S2
Γ ⊢▶S1 ≡S2
Γ ⊢▶t1 t2 : [x , t2]T
(TA-App)
Figure 2-3: Algorithmic presentation of λLF
Algorithmic kind equivalence
Γ ⊢▶K ≡K′
Γ ⊢▶∗≡∗
(QKA-Star)
Γ ⊢▶T1 ≡T2
Γ, x:T1 ⊢▶K1 ≡K2
Γ ⊢▶Πx:T1.K1 ≡Πx:T2.K2
(QKA-Pi)
Algorithmic type equivalence
Γ ⊢▶S ≡T
Γ ⊢▶X ≡X
(QTA-Var)
Γ ⊢▶S1 ≡T1
Γ, x:T1 ⊢▶S2 ≡T2
Γ ⊢▶Πx:S1.S2 ≡Πx:T1.T2
(QTA-Pi)
Γ ⊢▶S1 ≡S2
Γ ⊢▶t1 ≡t2
Γ ⊢▶S1 t1 ≡S2 t2
(QTA-App)
Algorithmic term equivalence
Γ ⊢▶s ≡t
Γ ⊢▶whnf(s) ≡wh whnf(t)
Γ ⊢▶s ≡t
(QA-WH)
Γ ⊢▶x ≡wh x
(QA-Var)
Γ, x:S ⊢▶t1 ≡t2
Γ ⊢▶λx:S.t1 ≡wh λx:S.t2
(QA-Abs)
Γ ⊢▶s1 ≡wh s2
Γ ⊢▶t1 ≡wh t2
Γ ⊢▶s1 t1 ≡wh s2 t2
(QA-App)
Γ, x:S ⊢▶s x ≡t
s not a λ
Γ ⊢▶s ≡wh λx:S.t
(QA-Nabs1)
Γ, x:S ⊢▶s ≡t x
t not a λ
Γ ⊢▶λx:S.s ≡wh t
(QA-Nabs2)
Figure 2-4: Algorithmic presentation of λLF—Equivalence rules

2.4
Algorithmic Typing and Equality
59
2.4.2
Lemma [Soundness of algorithmic λLF]: Each of the algorithmic judgments
is sound, in the following sense:
1. If Γ ⊢▶K then Γ ⊢K.
2. If Γ ⊢▶T :: K then Γ ⊢T :: K.
3. If Γ ⊢▶t : T then Γ ⊢t : T.
4. If Γ ⊢▶K, K′ and Γ ⊢▶K ≡K′, then Γ ⊢K ≡K′.
5. If Γ ⊢▶T, T′ :: K and Γ ⊢▶T ≡T′ then Γ ⊢T ≡T′ :: K.
6. If Γ ⊢▶t, t′ : T and Γ ⊢▶t ≡t′ then Γ ⊢t ≡t′ :: K.
where in each case, we additionally assume ⊢▶Γ.
2
Proof:
By induction on algorithmic derivations.
2
To establish completeness of algorithmic subtyping and later on termina-
tion we need to induct on the length of normalization sequences which we
formalize as follows.
Recall that µ(s) denotes an upper bound on the length of any -→β reduc-
tion sequence starting from s. We write |s| for the size of the term s.
2.4.3
Definition: We associate an ω2-valued weight to each judgment arising in a
possible derivation of an equality judgment by
w(∆⊢▶s1 ≡s2) = w(∆⊢▶s1 ≡wh s2) + 1
w(∆⊢▶s1 ≡wh s2) = ω · (µ(s1) + µ(s2)) + |s1| + |s2| + 1.
2
2.4.4
Lemma [Completeness of algorithmic λLF]: Each of the algorithmic judg-
ments is complete, in the following sense:
1. If Γ ⊢K then Γ ⊢▶K.
2. If Γ ⊢T : K then for some K′, we have Γ ⊢▶T : K′ and Γ ⊢▶K ≡K′ and Γ ⊢▶K′.
3. If Γ ⊢t : T then for some T′, we have Γ ⊢▶t : T′ and Γ ⊢▶T ≡T′ and
Γ ⊢▶T′ :: ∗.
4. If Γ ⊢t1 ≡t2 : T then Γ ⊢▶t1 ≡t2.
5. If Γ ⊢T1 ≡T2 :: K then Γ ⊢▶T1 ≡T2.
2

60
2
Dependent Types
Proof:
One ﬁrst proves that each of the declarative rules is admissible in the
algorithmic system. The result then follows by induction on derivations in
the declarative system. The only rules that are not immediately obvious are
the transitivity rules for equivalence of kinds, types, and terms, and the rule
Q-App. These two are left as exercises with solutions.
2
2.4.5
Exercise [«««]: Show that rule QT-Trans is admissible for the algorithmic
system in the sense that whenever Γ ⊢ti:T for i = 1, 2, 3 and Γ ⊢▶t1 ≡t2 and
Γ ⊢▶t2 ≡t3 then Γ ⊢▶t1 ≡t3.
2
2.4.6
Exercise [«««]: Show that rule Q-App is admissible for the algorithmic sys-
tem in the sense that whenever Γ ⊢t1 t2 : T and Γ ⊢s1 s2 : T and Γ ⊢▶t1 ≡
s1 and Γ ⊢▶t2 ≡s2 then Γ ⊢▶t1t 2 ≡s1s2.
2
Given soundness and completeness, we also want to know that our algo-
rithm terminates on all inputs. This also demonstrates the decidability of the
original judgments.
2.4.7
Theorem [Termination of typechecking]: The algorithmic presentation
yields a terminating algorithm for typechecking.
2
We highlight the crucial ideas of the proof of Theorem 2.4.7 here; the de-
tails are left to the diligent reader (Exercise 2.4.9 below). The equivalence
judgment Γ ⊢▶t1 ≡t2 introduces a possible source of nontermination when
invoked on non-well-typed terms (for example, Ω= ∆∆where ∆= λx:A.x x).
Here, computation of weak head normal form runs into an inﬁnite loop. We
must be careful that equivalence testing is called only on well-typed terms.
The crucial termination property for term equality that we need is captured
by the following lemma.
2.4.8
Lemma: Suppose that Γ ⊢t1:T1 and Γ ⊢t2:T2. Then the syntax-directed
backwards search for a derivation of Γ ⊢▶t1 ≡t2 always terminates. Equiva-
lently, there is no inﬁnite derivation ending in Γ ⊢▶t1 ≡t2.
2
Proof:
We claim that the weight of any premise of a rule is always less than
the weight of the conclusion which excludes any inﬁnite derivation tree. In
other words we argue by induction on the length of reduction sequences
and, subordinately, on the size of terms. This property is obviously satis-
ﬁed for QA-WH, QA-Abs, QA-App. To deal with rule QA-Nabs1 (and similarly,
QA-Nabs2) note that s must be of the form y u1 ... un whereby µ(s x) =
µ(s). The size, however, goes down, as the λ-symbol has disappeared.
2
2.4.9
Exercise [«««, 3]: Complete the proof of 2.4.2, 2.4.4, and 2.4.7.
2

2.5
Dependent Sum Types
61
Properties of λLF
We can use the algorithmic presentation of λLF to prove additional properties
enjoyed by the main deﬁnition. We just mention one example: type preserva-
tion under β-reduction.
2.4.10
Theorem [Preservation]: If Γ ⊢t : T and t -→β t′, then Γ ⊢t′ : T also.
2
Proof:
We show a slightly restricted form of the theorem, for well-formed
contexts Γ. More precisely, well-formed contexts are those which can be built
using the same rules as for ⊢▶Γ (page 57), but in the declarative system; the
corresponding assertion is written ⊢Γ. It is easy to extend the completeness
lemma to show that ⊢Γ implies ⊢▶Γ.
The crucial case is that of an outermost β-reduction (Beta-AppAbs), when
t = (λx:T1.t1) t2 for some T1, t1, t2.
By Lemma 2.4.4, we know that Γ ⊢▶(λx:T1.t1) t2 : T′ for some T′ with
Γ ⊢▶T≡T′ and Γ ⊢▶T′ :: ∗. The ﬁrst judgment must have been derived with
TA-App preceded by TA-Abs, so we have the derivability of
Γ ⊢▶T1 :: ∗
Γ ⊢▶T1 ≡S1
Γ, x:T1 ⊢▶t1 : S2
Γ ⊢▶t2 : S1
in the algorithmic system, with T′ = [x , t2]S2.
By the above and the assumptions about Γ, we have ⊢▶Γ, x:T1. Hence
by Lemma 2.4.2, we can go back to get analogs of the statements above in
the declarative system. For the last case, to establish the equivalence Γ ⊢
T1 ≡S1 :: ∗we use Lemma 2.3.3 to get Γ ⊢S1 :: ∗and then Γ ⊢▶S1 :: ∗.
Now by T-Conv we have Γ ⊢t2:S2 and so with substitution, Lemma 2.3.2,
we get Γ ⊢[x , t2]t1 : [x , t2]S2 and then the result follows using T-Conv
again, with another hop between the systems and Lemma 2.3.3, to show the
equivalence Γ ⊢[x , t2]S2 ≡T :: ∗.
2
2.4.11
Exercise [«««, 3]: Generalize the proof above to arbitrary contexts Γ.
2
2.5
Dependent Sum Types
Figure 2-5 shows extensions to λLF to add dependent sum (or “Sigma”) types,
written Σx:T1.T2. Dependent sums were motivated brieﬂy in the introduc-
tion. They generalize ordinary product types in a similar way to the way
that dependent products generalize ordinary function spaces. The degener-
ate non-dependent case, when x does not appear free in T2, amounts to the
ordinary product, written as T1 × T2.
We extend the terms and types of λLF given in Figure 2-1 with pairs, projec-
tion operations, and the type constructor itself. Notice that the pair (t1,t2)

62
2
Dependent Types
Extends λLF (2-1 and 2-2)
New syntax
t
::=
. . .
terms:
(t, t:Σx:T.T)
typed pair
t.1
ﬁrst projection
t.2
second projection
T
::=
. . .
types:
Σx:T.T
dependent sum type
Kinding
Γ ⊢T :: K
Γ ⊢S :: ∗
Γ, x:S ⊢T :: ∗
Γ ⊢Σx:S.T :: ∗
(K-Sigma)
Typing
Γ ⊢t : T
Γ ⊢Σx:S.T :: ∗
Γ ⊢t1 : S
Γ ⊢t2 : [x , t1]T
Γ ⊢(t1,t2:Σx:S.T) : Σx:S.T
(T-Pair)
Γ ⊢t : Σx:S.T
Γ ⊢t.1 : S
(T-Proj1)
Γ ⊢t : Σx:S.T
Γ ⊢t.2 : [x , t.1]T
(T-Proj2)
Term Equivalence
Γ ⊢t1≡t2 : T
Γ ⊢Σx:S.T :: ∗
Γ ⊢t1 : S
Γ ⊢t2 : [x , t1]T
Γ ⊢(t1,t2:Σx:S.T).1 ≡t1 : S
(Q-Proj1)
Γ ⊢Σx:S.T :: ∗
Γ ⊢t1 : S
Γ ⊢t2 : [x , t1]T
Γ ⊢(t1,t2:Σx:S.T).2 ≡t2 : [x , t1]T
(Q-Proj2)
Γ ⊢t : Σx:S.T
Γ ⊢(t.1, t.2:Σx:S.T) ≡t : Σx:S.T
(Q-SurjPair)
Figure 2-5: Dependent sum types
is annotated explicitly with a type Σx:T1.T2 in the syntax. The reason for this
is that the type of such a pair cannot be reconstructed from the types of t1
and t2 alone. For example, if S:T→∗and x:T and y:S x the pair (x,y) could
have both Σz:T.S z and Σz:T.S x as a type.
The most cluttered typing rule is the one which introduces a dependent
pair, T-Pair. It must check ﬁrst that the Σ-type itself is allowed, and then that
each component has the requested type. The projection rules are straightfor-
ward: compare the second projection with the rule T-App in Figure 2-1.
The equality relation on terms is extended to Σ-types by three rules. The
ﬁrst two deﬁne the elimination behavior of projections on a pair (compare
with the beta rule for Π-types). The third rule, Q-SurjPair, is known as sur-
jective pairing. This rule is a form of eta rule for Σ-types: it states that every
pair can be formed using the pair constructor.
Algorithmic Typing with Dependent Sum Types
To extend the algorithm to deal with Σ-types, we ﬁrst extend the notions of
beta and weak-head reduction. In both, the main clause is projection on a

2.5
Dependent Sum Types
63
Extends λLF algorithm (2-3 and 2-4)
Algorithmic kinding
Γ ⊢▶T :: K
Γ ⊢▶T1 :: ∗
Γ, x:T1 ⊢▶T2 :: ∗
Γ ⊢▶Σx:T1.T2 :: ∗
(KA-Sigma)
Algorithmic typing
Γ ⊢▶t : T
Γ ⊢▶Σx:T1.T2 :: ∗
Γ ⊢▶t1 : T′
1
Γ ⊢▶T′
1 ≡T1
Γ ⊢▶t2 : T′
2
Γ ⊢▶T′
2 ≡[x , t1]T2
Γ ⊢▶(t1,t2:Σx:T1.T2) : Σx:T1.T2
(TA-Pair)
Γ ⊢▶t : Σx:T1.T2
Γ ⊢▶t.1 : T1
(TA-Proj1)
Γ ⊢▶t : Σx:T1.T2
Γ ⊢▶t.2 : [x , t.1]T2
(TA-Proj2)
Algorithmic type equivalence
Γ ⊢▶S ≡T
Γ ⊢▶S1 ≡T1
Γ, x:T1 ⊢▶S2 ≡T2
Γ ⊢▶Σx:S1.S2 ≡Σx:T1.T2
(QTA-Sigma)
Algorithmic term equivalence
Γ ⊢▶t ≡wh t′
Γ ⊢▶ti ≡t′i
Γ ⊢▶(t1,t2:T) ≡wh (t′1,t′2:T′)
(QA-Pair)
Γ ⊢▶ti ≡t.i
t not a pair
Γ ⊢▶(t1,t2:T) ≡wh t
(QA-Pair-NE)
Γ ⊢▶t.i ≡ti
t not a pair
Γ ⊢▶t ≡wh (t1,t2:T)
(QA-NE-Pair)
Figure 2-6: Algorithmic typing for Σ-types
pair. Beta reduction also allows reduction inside the components of a pair.
(t1,t2:T).i -→β ti
(Beta-ProjPair)
t -→β t′
t.i -→β t′.i
(Beta-Proj)
t1 -→β t′
1
(t1,t2:T) -→β (t′
1,t2:T)
(Beta-Pair1)
t2 -→β t′
2
(t1,t2:T) -→β (t1,t′
2:T)
(Beta-Pair2)
Weak head reduction just has two new cases:
(t1,t2:T).i -→wh ti
(WH-ProjPair)
t -→wh t′
t.i -→wh t′.i
(WH-Proj)
Using the weak head reduction, the algorithmic typing and equality judg-
ments are extended with the rules in Figure 2-6 to deal with Σ-types.
2.5.1
Exercise [«««, 3]: Extend Lemmas 2.4.2, 2.4.4 and 2.4.7 to Σ-types. (No sur-
prises are to be expected.)
2

64
2
Dependent Types
Extends λLF (2-1 and 2-2)
New syntax
t
::=
. . .
terms:
all x:T.t
universal quantiﬁcation
T
::=
. . .
types:
Prop
propositions
Prf
family of proofs
Kinding
Γ ⊢T :: K
Γ ⊢Prop :: ∗
(K-prop)
Γ ⊢Prf :: Πx:Prop. ∗
(K-prf)
Typing
Γ ⊢t : T
Γ ⊢T :: ∗
Γ, x : T ⊢t : Prop
Γ ⊢all x:T.t : Prop
(T-All)
Type Equivalence
Γ ⊢S ≡T :: K
Γ ⊢T :: ∗
Γ, x:T ⊢t : Prop
Γ ⊢Prf (all x:T.t) ≡Πx:T.Prf t :: ∗
(QT-All)
Figure 2-7: The Calculus of Constructions (CC)
2.6
The Calculus of Constructions
The Calculus of Constructions (CC), one of the most famous systems of de-
pendent types, was introduced by Coquand and Huet (1988) as a setting for
all of constructive mathematics. While it has turned out that CC needs to be
extended with certain features (in particular inductive types [Mohring, 1986]),
its simplicity in relationship to its expressivity is unprecedented.
In our framework CC can be formulated as an extension of λLF which has
a new basic type Prop and a new type family Prf. Elements of the type
Prop represent propositions, and also “datatypes” such as the type of nat-
ural numbers (we use the term “datatype” to refer to usual programming
language types, as opposed to types of proofs of a proposition). Propositions
and datatypes are identiﬁed in CC by taking the Curry-Howard isomorphism
as an identity. The type family Prf assigns to each proposition or datatype
p : Prop the type Prf p of its proofs, or, in the case of datatypes, its mem-
bers. CC has one new term former all x:T.t, and two rules which relate it
to Prf. The additions to λLF are shown in Figure 2-7.
In most presentations and implementations of CC the type Prf t is nota-
tionally identiﬁed with the term t. This is convenient and enhances readabil-
ity, however, we will not adopt it for the sake of compatibility. The original
formulation of CC went as far as using the same notation, namely (x:A) for
all three binders: Π,all,λ. That did not enhance readability at all and was
thus given up after some time!
CC contains F ω as a subsystem by an obvious translation. For example,
here is the type of an encoding of natural numbers in CC:

2.6
The Calculus of Constructions
65
nat = all a:Prop.all z:Prf a.all s:Prf a →Prf a. a
Recall that A→B abbreviates Πx:A.B.
Notice that nat is a member of type Prop. The natural numbers inhabit the
type Prf nat. Accordingly, we have
zero = λa:Prop.λz:Prf a.λs:Prf a →Prf a.z : Prf nat
succ = λn:Prf nat.λa:Prop.λz:Prf a.
λs:Prf a →Prf a.s(n a z s) : Prf nat →Prf nat
add = λm:Nat.λn:Nat.m nat n succ : Prf nat →Prf nat →Prf nat
Regarding higher-order polymorphism here is how we deﬁne existential types
in CC:
exists = λf:A→Prop.all c:Prop.all m:(Πx:Prop.Prf (f x)→Prf c).c
Here A is any type; we obtain System F’s existential types with A=Prop; we
obtain existential quantiﬁcation over natural numbers with A=Nat.
2.6.1
Exercise [«, 3]: Deﬁne the term corresponding to existential introduction
of type: Πf:A→Prop.Πa:Prop.Πi:Prf (f a).Prf (exists f).
2
Conversely, existential elimination corresponds to applying a term of type
exists f to an appropriately typed argument.
2.6.2
Exercise [«««, 3]: Formalize the translation from F ω into CC.
2
The combination of type dependency and impredicativity à la System F
yields an astonishing expressive power. For example, we can deﬁne Leibniz
equality as follows:
eq = λa:Prop.λx:Prf a.λy:Prf a.
all p:Prf a→Prop.all h:Prf (p x).p y
: Πa:Prop.Prf a →Prf a →Prop
We can now prove reﬂexivity of equality by exhibiting an inhabitant of the
type Πa:Prop. Πx:Prf a. Prf (eq a x x). Indeed,
eqRefl = λa:Prop. λx:Prf a. λp:Prf a →Prop. λh:Prf (p x).h
is such a term.
2.6.3
Exercise [««, 3]: State and prove symmetry and transitivity of equality.
2
In a similar way, we can deﬁne other logical primitives such as boolean con-
nectives and quantiﬁers and then prove mathematical theorems. Occasionally
we have to assume additional axioms. For example, induction for the natural
numbers can be stated, but not proved; it is thus convenient to work under
the assumption:

66
2
Dependent Types
natInd : Πp:Prf nat →Prop.Prf (p zero)
→(Πx:Prf nat.Prf (p x) →Prf (p(succ x)))
→Πx:Prf nat.Prf (p x)
With that assumption in place we can for example prove associativity of ad-
dition in the form of a term of type:
Πx:Prf nat.Πy:Prf nat.Πz:Prf nat.
Prf (eq nat (add x (add y z)) (add (add x y) z))
2.6.4
Exercise [«««]: Find such a term.
2
The task of ﬁnding proof terms inhabiting types is greatly simpliﬁed by
an interactive goal-directed theorem prover such as LEGO (Luo and Pollack,
1992; Pollack, 1994) or Coq (Barras et al., 1997), or a structure-driven text
editor for programming, such as Agda or Alfa (Coquand, 1998; Hallgren and
Ranta, 2000).
Algorithmic Typing and Equality for CC
We will now consider algorithmic typechecking for the pure CC. The beta
reduction relation is extended with a clause for all:
t -→β t′
all x:T.t -→β all x:T.t′
(Beta-All)
2.6.5
Theorem: The relation -→β is strongly normalizing on well-typed terms of
CC.
2
Proof:
One can prove this directly using Tait’s reducibility method; see, for
example, Coquand and Huet (1988) or Luo and Pollack (1992). Alternatively,
we can deﬁne a reduction-preserving mapping from CC into F ω by “forget-
ting” type dependency—e.g., by mappingeq a t1 t2 to ∀P.P →P. Therefore,
an alleged inﬁnite reduction sequence in CC would entail an inﬁnite reduction
sequence in F ω. The details are beyond the scope of this survey.
2
With this result in place it is now possible to establish soundness, complete-
ness, and termination of algorithmic typing. The additional rules for the al-
gorithm (extending those for λLF) are presented in Figure 2-8.
The Calculus of Inductive Constructions
The fact that induction cannot be proved is a ﬂaw of the impredicative en-
coding of datatypes. Not only is it aesthetically unappealing to have to make

2.6
The Calculus of Constructions
67
Extends λLF algorithm (2-3 and 2-4)
Algorithmic kinding
Γ ⊢▶T :: K
Γ ⊢▶Prop :: ∗
(KA-Prop)
Γ ⊢▶t:Prop
Γ ⊢▶Prf t :: ∗
(KA-Prf)
Algorithmic typing
Γ ⊢▶t : T
Γ ⊢▶T :: ∗
Γ, x:T ⊢▶t : Prop
Γ ⊢▶all x:T.t : Prop
(QT-All-E)
Algorithmic type equivalence
Γ ⊢▶S ≡T
t -→wh all x:T1.t2
Γ ⊢▶S1 ≡T1
Γ, x:S1 ⊢▶S2 ≡Prf t2
Γ ⊢▶Πx:S1.S2 ≡Prf t
(QKA-Pi-Prf)
Γ ⊢▶Πx:S1.S2 ≡Prf t
Γ ⊢▶Prf t ≡Πx:S1.S2
(QKA-Prf-Pi)
Γ ⊢▶s ≡t
Γ ⊢▶Prf s ≡Prf t
(QKA-Prf)
Algorithmic term equivalence
Γ ⊢▶t ≡wh t′
Γ ⊢▶S1 ≡T1
Γ, x:S1 ⊢▶s ≡t
Γ ⊢▶all x:S.s ≡wh all x:T.t
(QA-All-E)
Figure 2-8: Algorithmic typing for CC
assumptions on an encoding; more seriously, the assumption of natInd de-
stroys the analog of the progress theorem (see TAPL, §8.3). For example, the
following term does not reduce to a canonical form:
natInd (λx:Prf nat.nat) zero (λx:Prf nat.λy:Prf nat.zero) zero
For these reasons, Mohring (1986) and subsequent authors (Werner, 1994;
Altenkirch, 1993) have combined CC with inductive deﬁnitions as originally
proposed (for a predicative system) by Martin-Löf (1984). In the thus obtained
Calculus of Inductive Constructions (CIC) as implemented in the Coq theorem
prover (Barras et al., 1997) we can declare the type nat:Prop as an induc-
tive type with constructors zero:Prf nat and succ:Prf nat→Prf nat. This
generates a constant:
natInd : Πp:Prf nat→Prop.Prf (p zero) →
(Πx:Prf nat.Prf (p x) →Prf (p(succ x))) →
Πx:Prf nat.Prf (p x)
which obeys the following equality rules:
natInd p hz hs zero ≡hz
natInd p hz hs (succ n) ≡hs n (natInd p hz hs n)
This clearly provides induction, but it also allows us to deﬁne primitive re-
cursive functions such as addition by

68
2
Dependent Types
add = λx:Prf nat.λy:Prf nat.natInd (λx:nat.nat)
y (λy:nat.λr:nat.succ r) x
Notice that we instantiated natInd with the constant “predicate” λx:nat.nat.
The mechanism of inductive deﬁnitions is not restricted to simple induc-
tive types such as nat. CIC, as well as Martin-Löf’s predicative systems (as
implemented in ALF [Magnusson and Nordström, 1994]) admit the inductive
deﬁnition of type families as well. For example, with nat already in place we
may deﬁne an inductive family
vector : Prf nat →Prop
with constructors nil : Prf (vector zero) and
cons : Πx:Prf nat. Prf nat →
Prf (vector x) →Prf (vector(succ x))
The (automatically generated) induction principle then has the typing
vecInd : Πp:Πx:nat.Prf (vector x) →Prop.
Prf (p zero nil) →
(Πx:Prf nat.Πy:Prf (vector x).
Πa:Prf nat.Prf (p y)→Prf (cons x a y)) →
Πx:Prf nat.Πy:Prf (vector x).Prf (p x y)
2.6.6
Exercise [««, 3]: What are the equality rules for this induction principle by
analogy with the equations for natInd?
2
Let us see how we can deﬁne the exception-free first function from the
introduction for these vectors. We ﬁrst deﬁne an auxiliary function first′
that works for arbitrary vectors by
first’ = vecInd (λx:Prf nat.λv:Prf (vector x).nat)
zero
(λx:Prf nat.λy:Prf (vector x).
λa:Prf nat.λprev:Prf nat.a) :
Πx:Prf nat.Πv:Prf (vector x).Prf nat
This function obeys the equations:
first’ zero nil = zero
first’ (succ x) (cons x a y) = a
We obtain the desired function first by instantiation
first = λx:Prf nat.λy:Prf (vector (succ x)).
first’ (succ x) y

2.6
The Calculus of Constructions
69
The default value zero can be omitted in a system like ALF which allows
the deﬁnition of dependently-typed functions by pattern matching. In that
system one would merely declare the type of first and write down the single
pattern
first x (cons x a y) = a
ALF can then work out that this deﬁnes a total function. The extension of pat-
tern matching to dependent types was introduced in Coquand (1992) which
also contains beautiful examples of proofs (as opposed to programs) deﬁned
by pattern matching. McBride (2000) has studied translations of such pat-
tern matching into traditional deﬁnitions using recursion/induction princi-
ples like vecInd.
2.6.7
Exercise [«««, 3]: Deﬁne using vecInd a function
concat : Πx:Prf nat.Πy:Prf nat.Prf (vector x) →
Prf (vector y) →
Prf (vector (add x y))
How does it typecheck?
2
As a matter of fact, the CIC goes beyond the type system sketched here in
that it allows quantiﬁcation over kinds, so, for example, the “predicate” p in
natInd may be an arbitrary type family. This means that using the constant
family p = λx:nat.Prop we can deﬁne a function eqZero: Prf nat →Prop
which equals true when applied to zero and false on all other arguments.
This facility turns out to be useful to deﬁne the exception-free first function
on vectors which was presented in the introduction.
Another additional feature of the CIC is the separation of propositions and
datatypes into two disjoint universes Prop and Set. Both behave like our
Prop, the diﬀerence lies in a program extraction feature that maps develop-
ments in the CIC to programs in an extension of F ω with inductive types
and general recursion. Types and terms residing in Prop are deleted by this
translation; only types and terms in Set are retained. In this way, it is possi-
ble to extract correct programs from formal correctness proofs. Details can
be found in Paulin-Mohring (1989).
Sigma Types in CC
It is unproblematic and useful to combine CC with Σ-types as described in
Section 2.5 and Figure 2-5. This allows one to form types of algebraic struc-
tures, for instance

70
2
Dependent Types
Semigrp = Σa:Prop.Σop:Prf a →Prf a →Prf a.
Πx:Prf a.Πy:Prf a.Πz:Prf a.
Prf (eq a (op x (op y z)) (op (op x y) z));
This system is contained in Luo’s Extended Calculus of Constructions (ECC)
(1994) which additionally permits Π and Σ quantiﬁcation over kinds. For con-
sistency reasons which we will brieﬂy describe next this requires an inﬁnite
hierarchy of ever higher kinds ∗0, ∗1, ∗2, .... For instance, in ECC one has
ΣX:∗3. X : ∗4
ECC has been implemented in the LEGO system (Luo and Pollack, 1992).
It is quite another matter to ask for a reﬂection of Σ-types into the universe
Prop of datatypes and propositions, by analogy with the way all is treated.
The temptation is to introduce a term former ex y:T.t : Prop when x:T ⊢
t:Prop, together with an equality rule asserting that
Pr (ex y:T.t) ≡Σy:T.Prf t.
Coquand (1986) has shown that the resulting system is unsound in the sense
that all types are inhabited and strong normalization fails. Intuitively, the
reason is that in this system we are able to deﬁne
prop = ex x:Prop.nat
and now have a mapping i:Prop→Prf prop deﬁned by
i = λx:Prop.(x,zero:prop)
as well as a left inverse j:Prf prop →Prop given by
j = λx:Prf prop.x.1.
Thus, we have reﬂected the universe Prop into one of its members, which
allows one to encode (after some considerable eﬀort) one of the set-theoretic
paradoxes showing that there cannot be a set of all sets.
This must be contrasted with the impredicative existential quantiﬁer exists
deﬁned on page 65. The diﬀerence between exists and the hypothetical term
former ex is that exists does not allow one to project out the existential
witness in case it is of type Prop.
An existential quantiﬁer which does not provide ﬁrst and second projec-
tions, but only the impredicative elimination rule known from System F is
called a weak sum, weak Σ-type, or existential. In contrast, the Σ-types with
projections are sometimes called strong.
We conclude this section by remarking that it is unproblematic to have
“small” strong Σ-types in the CC, that is, if t1:Prop and x:Prf t1 ⊢t2:Prop
then σx:Prf t1.t2:Prop with the equivalence
Prf(σ x:Prf t1.t2) ≡Σx:Prf t1.Prf t2.

2.7
Relating Abstractions: Pure Type Systems
71
2.6.8
Exercise [«««, 3]: An “approximation” for σ x:Prf t1.t2 is given by
exists = all c:Prop.all b:Πx:Prf t1.Prf t2 →Prf c.c.
Deﬁne pairing and ﬁrst projection for exists. Unfortunately, it is not possi-
ble to deﬁne a second projection.
2
2.7
Relating Abstractions: Pure Type Systems
The Calculus of Constructions is a very expressive system, but at ﬁrst sight,
somewhat diﬃcult to understand because of the rich mix of diﬀerent “lev-
els” of typing (especially in its original formulation with Prf implicit). Given
a lambda term λx : S.t, we cannot tell without (possibly lengthy) further anal-
ysis of S and t whether this is a term-level function, a type abstraction, a type
family, a type operator, or something else.
Partly as an attempt to explain the ﬁne structure of CC, Barendregt intro-
duced the lambda cube of typed calculi (brieﬂy introduced in TAPL, Chapter
30), illustrated below:
F ω
CC
F

·




·
·
λ→

λP




The cube relates previously known typed lambda calculi (recast within a
uniform syntax) to CC, by visualizing three “dimensions” of abstraction. In
the bottom left corner, we have λ→with ordinary term-term abstraction. Mov-
ing rightwards, we add the type-term abstraction characteristic of dependent
types: λP is the Lambda Cube’s version of our λLF. Moving upwards, we add
the term-type abstraction of System F, capturing polymorphism. Finally, mov-
ing towards the back plane of the cube, we add the higher-order type-type
abstraction characteristic of F ω.
Pure Type Systems
The type systems of the Lambda Cube, and many others besides, can be de-
scribed in the setting of pure type systems (Terlouw, 1989; Berardi, 1988;
Barendregt, 1991, 1992; Jutting, McKinna, and Pollack, 1994; McKinna and
Pollack, 1993; Pollack, 1994). There is an simple and elegant central deﬁni-
tion of Pure Type System (PTS) using just six typing rules, which captures a

72
2
Dependent Types
λP
Syntax
t
::=
terms:
s
sort
x
variable
λx:t.t
abstraction
t t
application
Πx:t.t
dependent product type
s
::=
sorts:
∗
sort of proper types
2
sort of kinds
Γ
::=
contexts:
∅
empty context
Γ, x:T
variable binding
Typing
Γ ⊢t : T
Γ ⊢∗: 2
(T-Star)
x:T ∈Γ
Γ ⊢x : T
(T-Var)
Γ ⊢S : ∗
Γ, x:S ⊢t : T
Γ ⊢λx:S.t : Πx:S.T
(T-Abs)
Γ ⊢t1 : Πx:S.T
Γ ⊢t2 : S
Γ ⊢t1 t2 : [x , t2]T
(T-App)
Γ ⊢S : si
Γ, x:S ⊢T : sj
Γ ⊢Πx:S.T : sj
(T-Pi)
Γ ⊢t : T
T ≡T′
Γ ⊢T′ : s
Γ ⊢t : T′
(T-Conv)
where (si, sj) ∈{(∗, ∗), (∗,2)}.
Figure 2-9: First-order dependent types, PTS-style (λP)
large family of systems constructed using Π-types. This uniform presentation
allows one to establish basic properties for many systems at once, and also
to consider mappings between type systems (so-called PTS morphisms).
A presentation of λLF as a Pure Type System is given in Figure 2-9.
The ﬁrst thing to notice about PTSs is that there is a single syntactic cate-
gory of terms, used to form types, terms, and abstractions and applications
of diﬀerent varieties. Although formally there is a single syntactic category,
we use the same meta-variables as before, to aid intuition. (So the letters T
and K and also range over the syntactic category of terms, but the system will
determine that they are types and kinds, respectively).
To allow levels of types and kinds to be distinguished, the PTS framework
uses tokens called sorts to classify diﬀerent categories of term, within the
formal system itself. The system λP requires two sorts: ﬁrst, ∗, which is the
kind of all proper types, as used before, and second, 2, which is the sort
that classiﬁes well-formed kinds. Judgments of the form Γ ⊢T : ∗replace
Γ ⊢T :: ∗from Figure 2-1, and judgments Γ ⊢K : 2 replace Γ ⊢K.
The rule T-Pi controls formation of Π-types, by restricting which sorts we
are allowed to quantify over. In turn, this restricts which λ-abstractions can
be introduced by T-Abs. For λLF, there are two instances of λ-abstraction and

2.7
Relating Abstractions: Pure Type Systems
73
two instances of Π-formation. In the PTS presentation, these are captured by
the two pairs of sorts allowed in T-Pi. When si = sj = ∗, we have the ﬁrst-
order dependent product type, and when sj = 2 we have the kind of type
families, corresponding respectively to K-Pi and Wf-Pi in Figure 2-1.
The conversion rule is the main point of departure. The equivalence rela-
tion s ≡t in Pure Type Systems is deﬁned between untyped terms, as the
compatible closure of β-reduction. This has a strong eﬀect on the meta-
theory.
2.7.1
Exercise [««««]: Using the obvious mapping from the syntax of λLF into
the syntax of λP, give a proposition stating a connection between the two
presentations. Try to prove your proposition.
2
Systems of the Lambda-Cube and Beyond
The other systems of the Lambda Cube can be expressed using the same rules
as in Figure 2-9, with the single diﬀerence of changing the combinations of
pairs of sorts (si, sj) allowed in T-Pi. This controls which kind of abstractions
we can put into the context. The table below characterises the systems of the
Lambda Cube:
System
PTS formation rules
λ→
{ (∗,∗)
}
λP
{ (∗,∗),
(∗,2)
}
F
{ (∗,∗),
(2,∗)
}
F ω
{ (∗,∗),
(2,∗),
(2, 2)
}
CC
{ (∗,∗),
(∗,2),
(2,∗),
(2, 2)
}
Further PTSs are given by adjusting the axiom T-Star of Figure 2-9, which
is another parameter in the formal deﬁnition of PTS. For example, if we take
the axiom to be
Γ ⊢∗: ∗
(T-TypeType)
(together with the T-Pi restriction of {(∗, ∗)}), we obtain a system where ∗
is the sort of all types including itself. In this system, all types are inhab-
ited and there are non-normalizing terms (as in the result of Coquand, 1986
mentioned on page 70). Though this renders the logical interpretation of the
system meaningless, it is debatable whether such systems may nonetheless
be useful in some situations as type systems for programming languages.
For further details of Pure Type Systems, we refer the reader to the refer-
ences given at the end of the chapter.

74
2
Dependent Types
2.8
Programming with Dependent Types
The task of building practical programming languages with dependent types
is a topic of current research. Early languages include Pebble (Lampson and
Burstall, 1988) and Cardelli’s Quest (Cardelli and Longo, 1991). Programming
in Martin-Löf’s type theory is described in the monograph (Smith, Nordström,
and Petersson, 1990). More recently, Augustsson introduced a language called
Cayenne (1998), with a syntax based on the functional programming lan-
guage Haskell, and Xi and Pfenning studied the language Dependent ML,
based around a fragment of Standard ML (1998; 1999). The diﬀerence be-
tween Cayenne and Dependent ML goes beyond the choice of underlying lan-
guage, and serves to illustrate a fundamental design decision for practical
programming with dependent types.
Languages with Undecidable Typechecking
Given the expressivity of dependent types as illustrated in previous sections
it is natural and tempting to add them to a programming language. The
price for this expressivity is, however, the complexity of typechecking. As
we have explained, typechecking dependent types requires deciding equality
of terms as a subtask which in turn requires the underlying term language
to be strongly normalizing. On the other hand, most practical programming
languages provide general recursion with possible nontermination. Simply
adding dependent types to a Turing-complete term language invariably leads
to undecidable typechecking.
Of course, typechecking remains semi-decidable, so one can simply wait
for an answer for a reasonable amount of time before giving up and turning
the typechecker oﬀ. This is basically the (surprisingly successful) approach
undertaken in Cayenne. Another example is the theorem prover PVS (1996)
which includes a dependently-typed programming language (at the time of
writing, in an experimental stage), and also has semi-decidable typechecking.
In PVS, however, it is possible to resort to interactive theorem proving to aid
the type checker.
Undecidablef typechecking is not to the taste of all programming language
designers, and for reasons such as scalability, may not be suitable for general
application. The alternative is to consider dependently typed languages built
around standard programming language features, yet with low-complexity
typechecking algorithms. To achieve this one must sacriﬁce some of the gen-
erality of dependent types. Dependent ML (DML) is a proposal which follows
this approach, which we will investigate in more detail in the remainder of

2.8
Programming with Dependent Types
75
this section. A type system closely related to that of DML, but aimed at
Haskell, was studied by Zenger, under the name indexed types (1997).
Exactly because this class of type systems have the desirable feature that
they provide “static” typechecking independently from execution or equiva-
lence checking of terms, some authors prefer not to call them “dependent”
at all. The deﬁnition of dependent types given in Chapter 8 is slightly stricter
than ours, and contrasts statically typed languages like DML and Indexed
Types with languages where there is a lack of phase distinction between the
compilation and execution of a program (see page 305).
A Simpliﬁed Version of Dependent ML
The crucial idea behind DML is that type dependency on terms is not allowed
for arbitrary types, but only for certain index sorts. Typechecking gives rise
to well-behaved constraint systems on terms belonging to index sorts. Type-
checking and even (to an extent) type inference can then be reduced to a
constraint-solving problem over the index sorts, which is decidable.
In this presentation we ﬁx the index sorts to be integer numbers and linear
subsets thereof, although Pfenning and Xi consider richer possibilities. We
also base the language on the lambda-calculi we have studied so far, rather
than a form of Standard ML.
Before going into details we will look at some simple examples concerning
vectors. We write int for the index sort of integers and assume a basic type
data and a basic type family Vector : int→∗where Vector[n] denotes
arrays over data of length n as usual. Note that, for example, Vector[-1]
will be empty. Next, we introduce the constants
nil
: Vector[0]
cons : Πn:int.data →Vector[n] →Vector[n+1]
and a construct for pattern matching obeying the following typing rule:
Γ ⊢t1 : Vector[i]
Γ, i=0 ⊢t2 : T
Γ, n:int, x:data, l:Vector[n], i=n+1 ⊢t3:T
Γ ⊢match t1 with nil →t2 | cons[n](x,l) →t3 : T
(Match-Vector)
There are several things to notice here. Types distinguish between ordinary
non-dependent function spaces T1→T2 and type families indexed by index
sorts, Πx:I.T. Application for Π-types is written using square brackets. Con-
texts contain bindings of index variables to index sorts, type variables to
types, and constraints over terms of index sort. Here the constraints are equa-
tions; in general they may be propositions of some restricted form so as to
retain decidability.

76
2
Dependent Types
In our setting, nil, cons, and match are just interesting for their typing
behaviors. We might postulate the obvious conversion rules for instances of
match, to deﬁne a term equality judgment as studied earlier. But it is impor-
tant to realize that we needn’t do this for the purpose of typechecking, since
for DML-style systems term equality is completely decoupled from typing.
In examples we will allow the deﬁnition of recursive functions by ﬁrst
declaring them with their type and then giving an accordingly typed imple-
mentation which may involve calls to the function being deﬁned.4
Example: Appending Vectors
We want to deﬁne a function for appending two vectors. It should obey the
following typing:
append : Πm:int.Πn:int.Vector[m] →Vector[n] →Vector[m+n]
To do this we deﬁne the body of append as follows:
append-body = λm:int.λn:int.λl:Vector[m].λt:Vector[n].
match l with
nil →t
| cons[r](x,y) →cons[r+n](x,append[r][n](y,t)
We should prove that append-body has the same type as append. Let Γ =
m:int, n:int, l:Vector[m], t:Vector[n]. After applying the rule Match-Vector
backwards we are required to show that
Γ, m=0 ⊢t : Vector[m+n]
and
Γ, r:int, x:data, y:Vector[r], m=r+1 ⊢
cons[r+n](x,append[r][n](y,t) : Vector[m+n]
For the ﬁrst requirement, we notice that Γ, m=0 ⊢n=m+n:int from which the
claim will follow by the type conversion rule and the obvious type equivalence
which equates instances of Vector indexed by equal index terms:
Γ ⊢i=j
Γ ⊢Vector[i]=Vector[j]
This rule is an instance of QT-App for DML families.
For the second requirement, we ﬁrst notice that, given the purported typing
of append, the append-subterm has type Vector[r+n], thus, by the typing of
cons the term itself has type Vector[r+n+1], but in the given context, this is
equal to Vector[m+n] hence the required typing follows by type conversion
again.
4. One can achieve this eﬀect with a constant fixT : (T→T) →T for any type T.

2.8
Programming with Dependent Types
77
Example: Splitting a Vector
This example illustrates DML’s restricted form of Σ-types. Again, we have
both dependent sums indexed by index sorts, and non-dependent sums (i.e.,
ordinary cartesian products). We will use the following type abbreviation:
T(m) = Σp:int.Σq:{ i | p+i=m }.Vector[p] * Vector[q]
The type T(m) has elements of the form (p,(q,(k,l))), which we shall write
as (p,q,k,l) to avoid excessive parentheses. The terms p and q are integer
indices, obeying the constraint p + q = m.
Now we can deﬁne a split function that partitions a vector into two pieces
of given lengths:
split : Πm:int.Vector[m] →T(m)
split-body = λm:int.λl:Vector[m].
match l with
nil ⇒(0,0,nil,nil) : T(0)
| cons[r](x,y) ⇒let (p,q,u,v) = split[r](y) in
if test(x) then (p+1, q, cons[p](x,u), v) : T(r+1)
else (p, q+1, u, cons[q](x,v)) : T(r+1)
where test(x) is some unspeciﬁed boolean-valued term. The typing of split
guarantees that the result vectors could be appended to form a vector with
the same length as the input. Notice that we can say that there is some pair
p and q such that p+q=m where m is the length of the input, but with the
restricted form of predicates in DML, we cannot say that p is equal to the
number of elements x from the input for which test(x) is true.
To see how split is typed, let Γ = m:int, l:Vector[m]. We have Γ, m=0 ⊢
T(0)=T(m) which deals with the ﬁrst case of the match. For the second case,
we need to show
Γ, p:int, q:int, p+q=r, u:Vector[p], v:Vector[q], r+1=m ⊢
(p+1, q, cons[p](x,u), v) : T(r+1) = T(m)
and similarly for the else-branch of the if statement. Again this follows
from trivial equational reasoning, and the expected rules for sum types.
Deﬁnition of Simpliﬁed DML
Figure 2-10 summarizes the syntax of our simpliﬁed form of DML. Most of
the typing rules are routine, so we leave completing the system to exercises.
The deﬁnition of DML is closely related to λLF with Σ-types, except that
dependencies are restricted to special terms of index sorts, so there is a par-
titioning of the syntax. Index sorts comprise the integers and subsets of index

78
2
Dependent Types
DML
I
::=
index sorts:
int
index sort of integers
{x:I | P}
subset sort
P
::=
propositions:
P ∧P
conjunction
i<=i
index inequality
i
::=
index terms:
x
variable
q
constant q ∈Z
qi
multiplication by q ∈Z
i+i
addition
t
::=
terms:
x
variable
λx:I.t
index abstraction
t[i]
index application
λx:T.t
abstraction
t t
application
(i, t)
index pairing
(t, t)
term pairing
let (x, y)=t in t
projection
T
::=
types:
X
type/family variable
Πx:I.T
indexed product
Σx:I.T
indexed sum
T[i]
type family application
T1 →T2
function type
T1 * T2
cartesian product
K
::=
kinds:
∗
kind of proper types
Πx:I.K
kind of type families
Γ
::=
contexts:
∅
empty context
Γ, x:T
term variable binding
Γ, x:I
index variable binding
Γ, P
constraint
Figure 2-10: Simpliﬁed Dependent ML (DML)
sorts. Subset formation is permitted only with respect to a restricted set of
predicates. In our case, these are conjunctions of linear inequalities (equal-
ity of two indices, i1=i2, can be deﬁned as i1<=i2 ∧i2<=i1). Index terms
themselves are restricted to variables, constants, addition of terms and mul-
tiplication by constants. Given an index sort, proposition, or index term I,
we write FIV(I) to stand for the free (index) variables of I. We use the same
category of variables for index variables and ordinary variables, but we can
tell from a typing context whether a variable ranges over index terms or or-
dinary terms. Given a context Γ, let IV(Γ) stand for the set of index variables
declared in Γ. A term I in the index syntax is well-formed in Γ just in case
FIV(I) ⊆IV(Γ); no typing rules are needed to check well-formedness in the in-
dex syntax. For contexts, we assume as usual that no variable is bound more
than once, and moreover, that the free variables appearing in declarations
x:I and constratints P are declared earlier in the context.
Ordinary terms include index terms in application position and in the ﬁrst
component of pairs. There are types depending on index terms, but there are
no types depending on ordinary terms. As a result, function space and carte-

2.8
Programming with Dependent Types
79
sian product cannot be deﬁned as special cases of Π and Σ-types, but must
be included as primitives. Kinds are just as in LF, except that dependency is
restricted to index sorts I.
In the typing rules we assume given two semantically deﬁned judgments:
Γ |= P
P is a consequence of Γ
Γ |= i : I
i:I follows from the assumptions of Γ
These judgments depend only on the index assumptions and propositions in
Γ, and their intention should be clear. For example, we have:
x:{y:int | y>=8}, z:int, z>=9
|=
x+z >= 13
The judgments can be deﬁned formally using the obvious interpretation of
the index syntax in Z (see Exercise 2.8.1).
In practice we are of course interested an algorithm for deriving the two
judgments. In our simpliﬁed version of DML, both judgments Γ |= P and
Γ |= i:I are decidable, and there are well-known methods which we can
use for handling linear equalities over the integers. In the case of a more
complicated index language the judgments might both be undecidable; for
instance, if we allow multiplication of index terms and existential quantiﬁ-
cation in propositions then undecidability follows from the undecidability of
Hilbert’s 10th problem.
In the typing rules, the semantic judgment is used whenever we need to
check that an index term belongs to an index sort. For example, the rule for
type family application becomes:
Γ ⊢S :: Πx:I.K
Γ |= i : I
Γ ⊢S[i] : [x , i]K
(DML-K-App)
The typing rules for the remainder of the language are deﬁned similarly to
λLF and the simply-typed lambda calculus. For instance, we have the follow-
ing rule for index abstraction:
Γ, x:I ⊢t : T
Γ ⊢λx:I.t : Πx:I.T
(DML-I-Abs)
but for ordinary abstraction we introduce the arrow:
Γ, x:S ⊢t : T
Γ ⊢λx:S.t : S →T
(DML-T-Abs)
There are similarly two rules for pairing and for projections. For the projec-
tion of an indexed pair, we have the dependent case:
Γ ⊢t : Σx:I.T
Γ, x:I, y:T ⊢t′ : T′
Γ ⊢let (x,y)=t in t′ : T′
(DML-I-Proj)

80
2
Dependent Types
We can also follow the same procedure as for λLF to formulate an algorith-
mic version of typing; the diﬀerence is that algorithmic type equality amounts
to checking of index constraints which can be performed semantically by con-
straint solving, without any normalization. In particular, equality of terms
is not intertwined with typechecking at all. The crucial rule for algorithmic
equality is
Γ ⊢▶S1 ≡S2
Γ |= i1 = i2
Γ ⊢▶S1 i1 ≡S2 i2
(DML-QIA-App)
where the second judgment is an instance of the semantic consequence judg-
ment Γ |= P.
2.8.1
Exercise [««]: Give a semantic interpretation of DML index syntax. Consid-
ering only the index variables in Γ, an index environment η is a function
from index variables to integers. Given this notion, we can deﬁne Γ |= P as
∀η. η |= Γ. =⇒η |= P. Complete the deﬁnition.
2
2.8.2
Exercise [«««, 3]: Complete the presentation of DML by deﬁning the type-
checking judgments and give an algorithm for typechecking.
2
Closing Example: Certifying Parameters
Several motivating application examples have been given for DML in the liter-
ature, including eliminating array bounds checks and unnecessary cases from
pattern matches. Rather than repeat those examples, we give a slightly diﬀer-
ent kind of example to illustrate the use of DML-style typing to certify that
constraints are met on parameters of functions.5
The scenario is that we are programming for an embedded system which is
providing safety features for an onboard computer in an automobile. We are
provided with a system call:
brake : int * int →unit
where it is safety critical that whenever brake is called with parameters
(x,y) then some proposition P(x, y) must be satisﬁed, for example, a con-
junction of linear inequalities describing some “safe window.”
To guarantee this, we should try to type our main program under the fol-
lowing assumed typing for brake. Notice that brake is provided as a system
call, so we can assume an arbitrary typing for it.
brake : {(x,y) : int * int | P} →unit
5. This example is taken from the project Mobile Resource Guarantees (EU IST-2001-33149);
see http://www.lfcs.inf.ed.ac.uk/mrg.

2.8
Programming with Dependent Types
81
where P encodes P(x, y). Unfortunately, this typing does not quite ﬁt into
the DML-framework since it unduly mixes index sorts and ordinary types.
To repair this, we introduce a type family Int : int →∗with the intuition
that Int(x) is a singleton type containing just the integer x, as a “run-time”
integer rather than an index term. We also need special typings for run-time
integers:
0 : Int(0)
1 : Int(1)
plus : Πx,y:int.Int(x) →Int(y) →Int(x+y)
timesq : Πx:int.Int(x) →Int(qx)
where q is a ﬁxed integer. These typings allow us to reﬂect the index terms
in ordinary terms. Moreover, we need a type family Bool:int→∗with the
intuition that Bool(x) contains true if 1<=x and Bool(x) contains false if
x<=0. Now we can suppose constants:
true
: Πx:int|1<=x. Bool(x)
false : Πx:int|x<=0. Bool(x)
leq
: Πx,y:int. Int(x) →Int(y) →Bool(1+y-x)
(where we write Πx:int|P.T as an abbreviation of Πx:{x:int | P}. T).
We also need a construct for case distinction obeying the following typing
rule:
Γ ⊢t1 : Bool(i)
Γ, 1<=i ⊢t2 : T
Γ, i<=0 ⊢t3:T
Γ ⊢if t1 then t2 else t3 : T
Notice that if we deﬁne boolean negation in terms of if-then-else then we
would obtain the typing:
not : Πx:int. Bool(x) →Bool(1-x)
because 1<=x |= 1-x<=0 and x<=0 |= 1<=1-x. Unfortunately, the derived typ-
ings for conjunction and disjunction are rather weak:
andalso,orelse : Πx,y:int.Bool(x)→Bool(y) →Σz:int.Bool(z)
Xi introduces a separate index sort of booleans with the usual operations on
the index level. This gives tighter typings for the boolean operations like
orelse : Πx,y:bool.Bool(x)→Bool(y)→Bool(x ∧y).
The price is that constraint solving for such a combined theory is much more
complex.
Returning to the example with the system call, let us suppose that the
linear constraint P simply states x+y<=10 and that the main function is just
a wrapper around brake that makes sure the constraint is actually met, i.e.
main(x,y) = if x+y<=10 then call brake(x,y) else call brake(0,0)

82
2
Dependent Types
Here is the corresponding DML version. We assume that the system call brake
satisﬁes the typing
brake : Πx,y:int|x+y<=10.Int(x) →Int(y) →unit
main : Πx,y:int.Int(x) →Int(y) →unit
main-body = λx,y:int.λxx:Int(x).λyy:Int(y).
if leq[x+y,10](plus[x,y](xx,yy))
then brake[x,y](xx,yy)
else brake[0,0](0,0)
Although this example is rather simple, it illustrates the general technique
for connecting index sort constraints to function calls. The fact that this def-
inition is type correct guarantees that the required safe window for calls to
brake is indeed always obeyed.
Summary and Outlook
We have shown the theory of a simpliﬁed fragment of Pfenning and Xi’s
DML demonstrating the important feature that typechecking amounts to con-
straint solving, for example, in the domain of integers, rather than normaliz-
ing terms. In this way, it becomes possible to retain decidability of typecheck-
ing in the presence of general recursion.
The DML examples show that index annotations are quite heavy. Fortu-
nately, most can be inferred automatically by a process known as elaboration.
It is plausible that in the examples we can reconstruct the annotations by re-
placing them by indeterminate linear terms in the index variables in scope
and then solving for the coeﬃcients. In Xi’s thesis (1998), elaboration is pre-
sented in detail as a logic program in the style of our algorithmic subtyping.
One of the design criteria behind the original DML was to allow ordinary
Standard ML programs to be extended with additional type annotations. Cur-
rent research in dependent type systems for programming seeks further ad-
vances at the programming language level. The aim is to provide more com-
fortable high-level notations and new programming language abstractions for
applying dependent type theory. One example of this is by enriching pattern
matching, see McBride (2000) and McBride and McKinna (2004).
Underlying type theories such as CIC are amply expressive for this purpose;
the challenge lies in making these systems more convenient to use, by adding
programming language constructions, notational conveniences and advanced
inference techniques. Present implementations, oriented towards mathemat-
ical interactive proof development, need to be adapted to programming lan-
guage settings. These exciting developments leave much to be expected for
the future of programming with dependent types.

2.9
Implementation of Dependent Types
83
2.9
Implementation of Dependent Types
In this ﬁnal section we describe an OCaml implementation of the dependent
type theory described in preceding sections. The implementation allows dec-
larations and deﬁnitions of both terms and types. Typechecking occurs as
soon as a declaration or deﬁnition is given. A term may be given with a type,
which will be checked, or without, in which case one will be inferred. Similarly
for kinds. Finally, we can ask to normalise well-typed terms.
The typechecking algorithm proceeds by evaluating the rules in Figures 2-4
and 2-3 and the later tables extending these judgments. More precisely, we
have (simultaneously deﬁned) functions:
val whnf : term →term
val typeof : context →term →ty
val kindof : context →ty →kind
val checkkind :
context →kind →unit
val tyeqv : context →ty →ty →bool
val kindeqv : context →ty →ty →bool
val tmeqv : context →ty →ty →bool
These functions are implemented by encoding the algorithmic rules using
pattern matching. For example, the deﬁnition of tmeqv begins like so:
tmeqv ctx tm1 tm2 =
let tm1’ = whred true ctx tm1 in
let tm2’ = whred true ctx tm2 in
match (tm1’,tm2’) with
(TmVar(fi,i,j), TmVar(fi’,i’,j’)) →i=i’
|
(TmAbs(_,x,tyS1,tmS2),TmAbs(_,y,tyT1,tmT2))→
let ctx’ = addbinding ctx x (VarBind(tyS1)) in
tmeqv ctx’
tmS2 tmT2
...
(the ﬁrst argument of whred is a ﬂag indicating whether to allow deﬁnitions
in the context to be expanded).
We stress that the implementation is a direct rendition of the syntax and
rules described earlier. It does not include any of the numerous desirable fea-
tures that make programming with dependent types more convenient, such
as argument synthesis (Harper and Pollack, 1991) or interactive, goal-directed
construction of terms. Conversely, because the implementation is simple, it
should be straightforward to experiment with extensions. The program is
built on the F ω implementation from TAPL and uses the same design and
data structures (see TAPL, Chapters 6, 7, and 30).

84
2
Dependent Types
We illustrate the use of the implementation by way of some examples.
Notice that the ASCII input to the system to produce a type like Πx:A.B is
Pi x:A.B.
Examples
With the commands
A : ∗;
Nat : ∗;
zero : Nat;
succ : Πn:Nat.Nat;
Vector : Πn:Nat.∗;
we declare variables A,Nat, constants zero and succ intended to denote zero
and successor on the natural numbers, and a type Vector depending on type
Nat. Note that the implementation does not support →; we must use Π-types
throughout. Next, we declare functions to form vectors by
nil : Vector zero
cons : Πn:Nat. Πx:A. Πv:Vector n. Vector (succ n)
allowing us to deﬁne a function for forming vectors of length three:
one = succ zero;two = succ one;
mkthree = λx:A.λy:A.λz:A.
cons two z (cons one y (cons zero x nil));
The implementation will respond by inferring the type of mkthree:
mkthree : Πx:A. Πy:A. Πz:A. Vector (succ two)
We can now partially apply mkthree to two elements of type A by
a:A; b:A;
mkthree a b;
resulting in the response
λz:A.
cons (succ (succ zero)) z
(cons (succ zero) b (cons zero a nil)) :
Πz:A.Vector(succ (succ (succ zero)))
This response exhibits two weaknesses of the implementation. First, deﬁni-
tions are always expanded in results; this will in practice almost always lead
to unreadable outpt. Second, the ﬁrst arguments to cons must be given ex-
plicitly and are printed out while they could be inferred from the types of the

2.9
Implementation of Dependent Types
85
second arguments. Practical implementations of dependent types overcome
both these problems. For instance, in LEGO (Luo and Pollack, 1992), mkthree
would be deﬁned (in our notation) as
mkthree = λx:A.λy:A.λz:A. cons z (cons y (cons x nil));
and the response to mkthree a b would be
λz:A.cons z (cons
b (cons a nil))) :
Πz:A.Vector three
For LEGO to know that the ﬁrst argument to cons is implicit we must declare
cons by
Πn|Nat. Πx:A. Πv:Vector n. Vector (succ n)
where the bar indicates implicitness for argument synthesis.
Returning to our experimental checker, let us illustrate Σ-types. We declare
three types
A:∗; B:Πx:A.∗; C:Πx:A.Πy:B x.∗;
and deﬁne
S = Σx:A.Σy:B x.C x y;
Supposing
a:A; b:B a; c: C a b;
then we can form
(a,(b,c:Σy:B a.C a y):S);
which is an element of S. The ﬁrst type annotation is actually redundant and
the implementation allows one to abbreviate the above by
(a,b,c:S)
If we declare
Q : Πx:S.∗;
x:S; y:Q x;
Then the following typecast succeeds
y:Q (x.1,x.2.1,x.2.2:S);
thus illustrating the built-in surjective pairing.
Here, ﬁnally, is the deﬁnition of natural numbers in CC:
nat = all a:Prop.all z:Prf a.all s:Πx:Prf a.Prf a. a;
Note that Prf always requires parentheses in the implementation.
We also remark that by default the implementation prints the weak-head
normal form of input terms. The β-normal form of a term t is printed with
the command Normal t.

86
2
Dependent Types
2.10
Further Reading
Dependent type theories have been widely investigated, much of the devel-
opment building on the pioneering work of Per Martin-Löf. This is not the
place for a comprehensive overview of the literature; rather we provide a few
pointers into work related to the developments in this chapter.
The Edinburgh Logical Framework and its type system are described in
Harper, Honsell, and Plotkin (1993). Our deﬁnition of λLF has the same type
structure, but omits signatures, and includes declarative equality judgments
rather than an untyped equivalence relation. A more complete recent devel-
opment which also includes equality judgments is in Harper and Pfenning
(2004).
Richer type theories than LF are considered in many places. The calculus
of constructions was introduced in Coquand and Huet (1988) and further
developed in related type theories (Mohring, 1986; Luo, 1994; Pollack, 1994).
Algorithms for typechecking with dependent types were ﬁrst considered by
Coquand (1991), Cardelli (1986; 1988b), and also within the closely related
AUTOMATH system of de Bruijn (1980).
The best survey of Pure Type Systems remains Barendregt’s handbook arti-
cle (1992), which includes a description of the λ-Cube. Although the deﬁnition
of PTS is elegant and short, developing the meta-theory for PTSs has been sur-
prisingly challenging. Several important results and improvements have been
made since Barendregt’s article. For example, Pollack (1994), studied formal-
ization of the meta-theory of PTSs in type theory itself, Poll (1998) established
the expansion postponement property for the class of normalizing PTSs, and
Zwanenburg (1999) studied the addition of subtyping to PTSs.
Type theories which combine inductive types and quantiﬁcation over kinds,
such as CIC, do not permit an easy normalization proof by translation into a
simply-typed normalizing sytem as was the case for the pure CC. Therefore,
strong normalization must be proved from scratch for those systems. So far
only partial proofs have been published for CIC as it is implemented in Coq;
the closest work so far is in the recent PhD thesis of Miquel (2001). For UTT
as implemented in LEGO, a strong normalization proof is given in Goguen
(1994), which introduces the idea of a typed operational semantics as a more
controlled way of managing reduction in a typed setting.
A topic we have not considered here is the semantics of dependent types.
There has been considerable study; see Hofmann (1997b) for a particular
approach and some comparison with the literature. Notable contributions
include Cartmell (1986), Erhard (1988), Streicher (1991), and Jacobs (1999).

3
Eﬀect Types and Region-Based Memory
Management
Fritz Henglein, Henning Makholm, and Henning Niss
Type-based program analysis is program analysis based on the concepts, the-
ories and technologies developed for type systems and employed in the deﬁ-
nition of programming languages. It is a vast ﬁeld of research with numerous
applications and considerable practical impact. Applications include strict-
ness analysis, data representation analysis, binding-time analysis, soft typing
(also called dynamic typing inference), boxing analysis, pointer aliasing, value
ﬂow analysis (and all its applications), region-based memory management,
communication topology analysis, Year 2000 type analysis, cryptographic
protocol veriﬁcation, locking, race detection, and others; see Palsberg (2001)
for an overview of additional applications.
This chapter presents type-based program analysis based on type and ef-
fect systems (or eﬀect type systems) and illustrates their application in region-
based memory management, which is the chapter’s ultimate focus. Classical
type systems express properties of values, not the computations leading to
those values. Eﬀect types describe all important eﬀects of computation, not
just their results. Region-based memory management refers to programming
where heap data is allocated in individually managed regions that are explic-
itly allocated and deallocated. As we shall see, state-of-the-art region-based
memory management employs eﬀect type systems to ensure region safety,
which guarantees that no accesses to unallocated or deallocated regions oc-
cur at run time.
3.1
Introduction and Overview
Region-based memory management has a well-developed theory, has been
subject to practice-oriented engineering, and is deployed in industrial-quality
language implementations and prototype systems. We provide a consolidated

88
3
Eﬀect Types and Region-Based Memory Management
review of the state of the art in region-based memory management and use
it as an application domain to develop fundamental concepts of eﬀect type
systems step by step.
Value Flow and Simple Eﬀect Analyses
In §3.2, we introduce BL, a standard typed higher-order functional language.
Then we present an TL, an extension of BL, with atomic labels p (tags, names)
and corresponding tagging and untagging operations t at p and t ! p. Evalu-
ation of t at p equips the value v of t with label p resulting in a tagged value
⟨v⟩p; correspondingly, evaluation of t ! p′ simply checks that p in the value
⟨v⟩p of t equals label p′ before returning v. We present a type system which
ensures that the check in t ! p′ always succeeds. Thus, the labels and their
operations can be thought of as annotations that let us trace where values are
created and used at run-time; they express and make explicit value ﬂow infor-
mation of the underlying BL program. The connection of TL and the value ﬂow
information expressed in it to region-based memory management is a rein-
terpretation of labels as regions and tagging/untagging operations as region
access operations. An expression t at p is then reinterpreted as “evaluate t,
allocate it in the region bound to p, and return the corresponding pointer,”
and t ! p is reinterpreted as “evaluate t to a pointer into the region bound to
p and load its contents from there.” This leaves the problem of ﬁguring out
when to allocate and deallocate a region. The basic idea is extracting lifetime
information about values living in a region ρ from typing derivations: If a
(sub)term t that contains uses of a region ρ can be typed such that ρ neither
occurs in the typing assumptions nor in the result, we take this to mean that
ρ does not need to exist before evaluating t or after. So we can evaluate t by
ﬁrst allocating a new region ρ, then evaluating t, and ﬁnally deallocating ρ.
To express this we extend TL with a construct new ρ.t and add straightfor-
ward evaluation and typing rules to give language STL. §3.2 concludes with
the observation that STL is unsound because the typing judgments do not
capture accesses to regions from the environment part in lexical closures;
that is, important properties of the computation (evaluation) itself are not
reﬂected in (the types of) the values produced by those computations.
The unsoundness motivates the use of eﬀect type systems to capture ac-
cesses to regions during an evaluation. In §3.3, we introduce eﬀect types
(types and eﬀects), which represent relevant eﬀects (accesses to regions) of
an evaluation together with the type of its result. The basic lifetime interpre-
tation of typing judgments for region allocation and deallocation with explicit
eﬀects is then sound since all accesses to regions are represented in the eﬀect
of an expression, as are those from the environment part of a lexical closure.

3.1
Introduction and Overview
89
Region-Based Eﬀect Analyses
The development in §3.2 and §3.3 is focused on the conceptual roles of
types, eﬀects, value ﬂow information, and lifetime interpretation of typing
judgments. In particular, the type systems are monomorphic, and regions
cannot be passed as parameters. Turning our attention to realistic region-
based memory management, §3.4 extends the region annotations by adding
region abstraction and region application. This extension provides the basis
for region polymorphism, which is crucial for practicality. The key result of
this section is conditional correctness: If a region annotated program does not
run into an error (in particular, does not access an unallocated or deallocated
region) then it has the same result as the underlying program without region
annotations. This result by itself shows that region annotations may intro-
duce errors during evaluation, but do not otherwise change the semantics of
the underlying program. It is noteworthy that conditional correctness holds
for all region-annotated terms independent of any type system.
§3.5 presents TT, the Tofte–Talpin region type system, in a simpliﬁed form
and adapted to our setting. The main result in this section is type sound-
ness: no TT-annotated term can go wrong. Combining soundness with condi-
tional correctness we obtain correctness: A TT-annotated program produces
the same result as the underlying unannotated program. This section high-
lights the role of the type system: its job is to ensure soundness; conditional
correctness is already taken care of.
Region-Based Systems: Inference and Systems
There are usually many diﬀerent well-annotated versions of a given underly-
ing program, all of which are correct. They do not have the same eﬃciency
characteristics: Some retain regions substantially longer during execution
than others. In §3.6 we turn to the question of how to automatically infer
“good” region annotations. Region inference is technically complex. The sec-
tion discusses the algorithmic techniques that have been used for TT infer-
ence and a number of restricted cases, providing pointers to the relevant
literature for detailed descriptions.
The Tofte–Talpin type system enforces a stack discipline on region allo-
cation and deallocation driven by a lexically scoped region-creation expres-
sion. §3.7 presents reﬁnements of its standard implementation to accom-
plish better region performance for lexically scoped regions: region resetting
and delayed allocation/early deallocation. Furthermore, it discusses region
lifetime subtyping and systems where region allocation and deallocation are
decoupled altogether: calculus of capabilities for continuation passing style
programs and imperative regions.

90
3
Eﬀect Types and Region-Based Memory Management
Finally, §3.8 surveys implementations with statically checked region-based
memory management: ML Kit with Regions, a Standard ML compiler; Cyclone
and Vault, which are type-safe C-like languages with explicit region manage-
ment and other novel extensions; and prototype systems for Java and Prolog.
It brieﬂy reviews systems and libraries for region-based programming with no
static region safety guarantees, but with dynamic or no-region fault detection.
3.2
Value Flow by Typing with Labels
The language BL, also called Finitary PCF (Jung and Stoughton, 1993; Loader,
2001), is a simply typed lambda-calculus with general recursion (ﬁx), Boolean
values and call-by-value semantics. It is the underlying language, for which
we shall develop region-based memory management based on eﬀect type sys-
tems in this section. Its syntax and small-step operational semantics are given
in Figure 3-1.
Tagged Language
In this subsection we introduce TL, which is BL extended with explicit tagging
and untagging operations. Syntax and operational semantics are deﬁned in
Figure 3-2, extending the deﬁnitions for BL in Figure 3-1.
The category of label variables ρ designates a denumerable set of label vari-
ables ρ0, ρ1, . . . . Like ordinary program variables, label variables are atomic
and have no internal structure. For convenience we may abbreviate label ex-
pression to label. Labels p can only consist of label variables for now. We shall
extend p later. Anticipating their reinterpretation later, we shall also call label
variables region variables and labels regions or places.
Operationally, evaluation of t at p consists of tagging the value of t with
label p. We write the result of tagging value v with p as ⟨v⟩p. The untagging
operation t at p′ evaluates t to a tagged value ⟨v⟩p, checks that its label p
matches p′ and, if so, returns the underlying value v. If the label does not
match, the evaluation gets stuck—it goes wrong. As we shall see, the typing
rules of TL guarantee that evaluation never goes wrong in this way for well-
typed terms.
The tagging and untagging operations serve to name certain sets of values
and to mark where such values are constructed and used. Note the following:
•
Multiple subterms of a term may have the same label.
•
Even though a label may occur only once in a program, it may tag multiple
values at run time; for example, in λx0.(x0 at ρ0) the same label ρ0 will

3.2
Value Flow by Typing with Labels
91
Terms
t
::=
terms:
v
value expression
x
variable
t t
application
if t then t else t
conditional
fix x.t
recursion
v
::=
value expressions:
λx.t
abstraction
bv
truth value
bv
::=
truth values:
tt
true
ff
false
Evaluation rules
t -→t′
(λx.t12) v2 -→[x , v2]t12
(E-Beta)
fix x.t -→[x , fix x.t]t
(E-FixBeta)
if tt then t2 else t3 -→t2
(E-IfTrue)
if ff then t2 else t3 -→t3
(E-IfFalse)
t1 -→t′
1
t1 t2 -→t′
1 t2
(E-App1)
t2 -→t′
2
v1 t2 -→v1 t′
2
(E-App2)
t1 -→t′
1
if t1
then t2
else t3 -→if t′
1
then t2
else t3
(E-If)
Types
T
::=
types:
bool
Boolean type
T →T
function type
Typing rules
Γ ⊢t : T
x ̸∈Γ ′
Γ, x : T, Γ ′ ⊢x : T
(T-Var)
Γ ⊢bv : bool
(T-Bool)
Γ ⊢t1 : bool
Γ ⊢t2 : T
Γ ⊢t3 : T
Γ ⊢if t1 then t2 else t3 : T
(T-If)
Γ, x : T1 ⊢t : T2
Γ ⊢λx.t : T1 →T2
(T-Abs)
Γ ⊢t0 : T1 →T2
Γ ⊢t1 : T1
Γ ⊢t0 t1 : T2
(T-App)
Γ, x : T ⊢t : T
Γ ⊢fix x.t : T
(T-Fix)
Derived form
let x = t1 in t2
def
= (λx.t2) t1
Figure 3-1: Base language BL
tag multiple values if the function is called multiple times with diﬀerent
argument values.
•
Labels let us distinguish values produced in diﬀerent places even though
they are extensionally equal; for example, in a call f (tt at ρ0) (tt at ρ1)
we can keep track of the uses of both arguments separately even though
they are the same values.
•
We distinguish between v at p and ⟨v⟩p. The former denotes an uneval-
uated expression, where v has not been tagged with p yet, and the lat-
ter denotes the result of performing the tagging. This distinction will be

92
3
Eﬀect Types and Region-Based Memory Management
New terms
t
::=
. . .
terms:
t at p
tagging
t ! p
untagging
v
::=
. . .
value expressions:
⟨v⟩p
tagged value
p
::=
label expressions:
ρ
label variable
New evaluation rules
t -→t′
t -→t′
t at ρ -→t′ at ρ
(E-Tag)
v at ρ -→⟨v⟩ρ
(E-TagBeta)
t -→t′
t ! ρ -→t′ ! ρ
(E-Untag)
⟨v⟩ρ ! ρ -→v
(E-UntagBeta)
New types
T
::=
. . .
types:
T at p
tagged value type
New typing rules
Γ ⊢t : T
Γ ⊢t : T
Γ ⊢t at p : T at p
(T-Tag)
Γ ⊢t : T at p
Γ ⊢t ! p : T
(T-Untag)
Γ ⊢v : T
Γ ⊢⟨v⟩p : T at p
(T-TagValue)
Figure 3-2: Tagged language, TL (extension of BL)
important when interpreting labels as regions later on: evaluation of the
former has the eﬀect of accessing the region p whereas the latter does not.
A term is closed if it has no free occurrences of variables. (Closed terms
may have free occurrences of label variables.) A closed value expression is a
value.
We write t
t-→t′ if t -→t′ can be derived from the TL evaluation rules;
that is, the evaluation rules of both Figures 3-1 and 3-2. A term t is ﬁnal (or
a ﬁnal state) if there is no term t′ such that t
t-→t′. Each value expression
is ﬁnal. We call all ﬁnal states that are not value expressions stuck (or stuck
states).
We write t ↓t′ if t
t-→
∗
t′ and t′ is ﬁnal. We write t ↓if there exists t′
such that t ↓t′. If t has no ﬁnal state and thus does not terminate we write
t ↑.
For simplicity we shall think of BL as a subset of TL. This is justiﬁed since
all BL-terms are also TL-terms and both evaluation and typing relations for
TL are conservative over BL. For emphasis we may write t
BL
-→t′ if t
t-→t′
and t, t′ are BL-terms.

3.2
Value Flow by Typing with Labels
93
Labels as Value Flow Information
The label erasure (or simply erasure) of a TL-term is the BL-term we obtain by
erasing all occurrences of at p, ! p and ⟨.⟩p in it. More precisely, we deﬁne
erasure and its inverse, completion, as follows:
3.2.1
Definition [Erasure, completion]: Let t ∈TL. Then the erasure ∥t∥of
term t is deﬁned as follows:
∥x∥
=
x
∥t1 t2∥
=
∥t1∥∥t2∥
∥if t1 then t2 else t3∥
=
if ∥t1∥then ∥t2∥else ∥t3∥
∥fix x.t∥
=
fix x.∥t∥
∥λx.t∥
=
λx.∥t∥
∥tt∥
=
tt
∥ff∥
=
ff
∥t at p∥
=
∥t∥
∥t ! p∥
=
∥t∥
⟨v⟩p

=
∥v∥
Conversely, we call a TL-term t′ a completion of BL-term t if ∥t′∥= t.
2
Note that erasures are BL-terms. Note also that erasures are closed under
substitution:
3.2.2
Proposition: ∥[x , t2]t1∥= [x , ∥t2∥]∥t1∥
2
A constructor/deconstructor completion (or con/decon completion) is a com-
pletion where each value expression is tagged and untagging takes place
in each destructive context; labels must not occur anywhere else. Formally,
con/decon completions are generated from t in Figure 3-3.
In a con/decon completion each value gets tagged when it is created, and
every such tag is checked and removed immediately before the underlying
untagged value is destructed—that is, when it is needed as the function in a
function application or as the Boolean test in a conditional. In this fashion
the label p in t ! p tells us which value expressions could have constructed
the value of t.
For this to be true, however, evaluations of TL-terms must not get stuck due
to label mismatch in a redex ⟨v⟩ρ ! ρ′. Intuitively, the reason for this is as
follows. It would be clearly wrong to conclude that evaluation of t ! ρ1 uses
a value constructed by a value expression labeled ρ1 in the original source

94
3
Eﬀect Types and Region-Based Memory Management
Con/decon completion templates
t
::=
:
v
x
(t ! p) t
if (t ! p) then t else t
fix x.t
v
::=
:
(λx.t) at p
abstraction
bv at p
truth value
bv
::=
truth values:
tt
true
ff
false
Figure 3-3: Con/decon completions
program if t evaluates to ⟨tt⟩ρ0. Note, however, that ⟨tt⟩ρ0 ! ρ1 is stuck,
which means t ! ρ1 gets stuck. Conversely, if an evaluation does not get
stuck, all its computation steps of the form ⟨tt⟩ρ ! ρ′ succeed, which is only
possible if ρ = ρ′. In that case a subterm t ! ρ expresses that the value of t
is constructed from one of the value expressions labeled ρ.
As we shall see, the type system of TL guarantees that no stuck states can
occur during evaluation of (well-typed) TL-terms. So the label information in
TL-terms can be soundly interpreted as value ﬂow information.
3.2.3
Example: Consider the BL-program t0:
let fst= λu.λv.u in
(let x = λp.p tt ff in λy.λq.q (x fst) y)
tt
Value ﬂow analysis should tell us that x may be applied to fst (which is rather
easy to see), fst may be applied to tt (which is not immediately obvious from
the source code), and the λ-abstraction λy.λp.p (x fst) y may be applied to
tt, but λp.p (x fst) y is not applied anywhere.
The following con/decon completion t1 of t0 captures this:
let fst= λlKu.λlbv.u in
(let x = λlxp.((plK ttlt )
lb fflf ) in
λlf y.λlcq.((qlq (xlx fst))
ld y))
ttlt
To make the completion more readable, we have written λpx.t for (λx.t) at p,
bvp for bv at p, and (tp t′) for (t ! p) t′.
2
3.2.4
Exercise [«, 3]: Show that t1 is a TL-term by giving a TL-typing derivation
for it.
2

3.2
Value Flow by Typing with Labels
95
3.2.5
Exercise [«, 3]: Give a reduction sequence t1
t-→. . .
t-→tk such that tk is
ﬁnal. Which (E-UntagBeta) reduction steps occur in it? Which labels occur in
those steps?
2
3.2.6
Exercise [«, 3]: Note that t0 is the erasure of t1: ∥t1∥= t0. Give a reduction
sequence ∥t1∥
BL-→. . .
BL-→t′
m such that t′
m is ﬁnal. How are tk from Exer-
cise 3.2.5 and t′
m related to each other? How long is the reduction sequence
for t0 to tk in comparison to the reduction sequence for t1? (Generalize to
arbitrary TL-terms and their erasures.)
2
3.2.7
Exercise [««]: Let S be a substitution mapping the labels occurring in t1 to
(not necessarily diﬀerent) labels. Consider the term S(t1), which is t1 with
its labels substituted according to S. Is S(t1) TL-typable? If so, does closure
under all substitutions hold for all closed TL-terms? If not, for which subset
of the closed TL-terms does it hold?
2
Correctness
A TL-term can be thought of as an instrumented version of the underlying
BL-term. Intuitively, this is because an evaluation of a TL-term performs the
same proper computation steps as its erasure (the underlying BL-term), with
interspersed auxiliary label reduction steps (E-TagBeta) and (E-UntagBeta).
Correctness means that evaluation of TL-terms gives the “same” results as
evaluation of their underlying BL-terms. It is factored into two orthogonal
parts:
1. Conditional correctness, which states that TL-terms produce the same re-
sults as their underlying BL-terms unless they get stuck. Conditional cor-
rectness is a property of the evaluation rules for TL and BL alone; it is
independent of their typing rules.
2. Soundness, which states that TL-terms do not get stuck.
It is instructive to see how this method works in a technically very simple
setting such as TL. For this reason we shall introduce it below. The same
results for more expressive languages with eﬀect typing, region scoping and
polymorphism will be proved later on in §3.4 and §3.5.
3.2.8
Definition: Deﬁne relations . t1
-→. and . t2
-→. on TL-terms as follows:
1. t1
t2
-→t2 if t1 -→t2 is derived by application of Axiom (E-TagBeta) or
(E-UntagBeta) from Figure 3-2.
2. t1
t1
-→t2 if t1 -→t2 is derived from all evaluation rules of Figures 3-1 and
3-2, but without application of Axioms (E-TagBeta) or (E-UntagBeta).
2

96
3
Eﬀect Types and Region-Based Memory Management
Each t1
-→reduction step corresponds to a reduction step in the underlying
BL-term whereas t2
-→reductions do not change the underlying BL-term at all.
This is captured in the following lemma.
3.2.9
Lemma [Simulation]: Let t, t1, t2 range over TL-terms.
1. If v is a value expression then so is ∥v∥.
2.
t2
-→is strongly normalizing.
3. If t1
t1
-→t2 then ∥t1∥
BL-→∥t2∥.
4. If t1
t2
-→t2 then ∥t1∥= ∥t2∥.
2
3.2.10
Exercise [««, 3]: Prove Lemma 3.2.9.
2
Using Lemma 3.2.9 we can prove the following theorem. It states that eval-
uation of a TL-term performs basically the same computation steps as the
underlying BL-term until it gets stuck or arrives at a value expression.
3.2.11
Theorem [Conditional Correctness]: For TL-terms t, t′ we have:
1. If t
t-→
∗
t′ then ∥t∥
BL-→
∗
∥t′∥.
2. If t ↑then ∥t∥↑.
3. If ∥t∥gets stuck then t gets stuck, too.
2
3.2.12
Exercise [«]: Prove Theorem 3.2.11.
2
The next lemma says that the type of a term is preserved under evaluation.
3.2.13
Lemma [Subject Reduction (Preservation)]: Let t, t′ be TL-terms. If Γ ⊢
t : T and t
t-→t′ then Γ ⊢t′ : T.
2
3.2.14
Exercise [««, 3]: Prove Lemma 3.2.13 in standard fashion: by induction on
t
t-→t′ and formulating the requisite substitution lemma.
2
3.2.15
Lemma [Progress]: If ⊢t : T then either t = v for some value (closed value
expression) v or there exists t′ such that t
t-→t′.
2
Proof:
(Sketch) The lemma follows from the following statement: For all deriv-
able Γ ⊢t : T, if Γ = ∅then
1. there exists t′ such that t
t-→t′, or

3.2
Value Flow by Typing with Labels
97
2. (a) if T is of the form T′ →T′′ then t = λx.t′′ for some x, t′′, and
(b) if T = bool then t ∈{tt, ff}.
This statement can be proved by rule induction on Γ ⊢t : T.
2
The Progress Lemma says that a well-typed closed term is not stuck. To-
gether with the Subject Reduction Lemma it says that, since all its reducts are
well-typed, too, it never gets stuck.
3.2.16
Theorem [Soundness]: If ⊢t : T then evaluation of t does not get stuck. 2
Putting the Conditional Correctness Theorem and the Soundness Theorem
together we obtain as a corollary the correctness of TL relative to BL:
3.2.17
Corollary [Correctness]: Let t be a closed TL-term and v a TL-value.
1. t ↑iﬀ∥t∥↑.
2. ∥t∥
BL-→
∗
∥v∥iﬀthere exists a TL-value v′ with ∥v′∥= ∥v∥and t
t-→
∗
v′. 2
3.2.18
Exercise [««]: Prove Corollary 3.2.17.
2
Inference of Value Flow Information
Given a BL-term t we are interested in ﬁnding a con/decon completion to
obtain value ﬂow information about t. Note, however, that a BL-term t may
have many diﬀerent con/decon completions, and while each provides sound
value ﬂow information, some provide better information than others. For ex-
ample, the trivial completion in which each label operation in a term has the
same label ρh contains no useful value ﬂow information: it says that any value
created anywhere may be used anywhere. Correct, but trivial. Intuitively, we
are interested in a con/decon completion with a maximal number of distinct
labels, as this gives the most ﬁne-grained value ﬂow information.
3.2.19
Exercise: Consider t0 =
let fst = λu.λv.u in
(let x = λp.p tt ff in λy.λq.q (x fst) y)
tt
again and its con/decon completion t1 =
let fst= λlKu.λlbv.u in
(let x = λlxp.((plK ttlt )
lb fflf ) in
λlf y.λlcq.((qlq (xlx fst))
ld y))
ttlt .

98
3
Eﬀect Types and Region-Based Memory Management
Does there exist another con/decon completion of t0 with more distinct la-
bels or is t1 maximal in this sense?
2
Indeed, it can be shown that each BL-term has a con/decon completion such
that any other of its con/decon completions can be obtained by applying a
label substitution to it. We call it a principal completion of the given BL-term.
In particular, principal completions have the maximal possible number of
distinct labels. Furthermore, they are unique up to renaming of labels.
We shall not go into any technical details on how to infer principal comple-
tions, but present the basic ideas.
A con/decon completion template for a BL-term t is a con/decon com-
pletion of t in which each label variable occurs exactly once. Clearly, each
con/decon completion that satisﬁes the TL-typing rules is a substitution in-
stance (mapping labels to labels) of this template. Furthermore, it can be
shown that a substitution gives rise to a well-typed con/decon completion
if and only if it satisﬁes a set of equational constraints between the tem-
plate labels. That set can be computed in linear time from the con/decon
completion, and a most general solution of the constraints can likewise be
computed in linear time. The most general solution, in turn, gives rise to a
principal completion when applied to the con/decon completion template.
What we have described is the standard method for simple type inference by
equational constraint extraction and solution; see, for example, Wand (1987b)
and Henglein (1989) for simple type inference and Mossin (1997, Section 2)
for its application to value ﬂow analysis.
The pleasant properties of processing sets of equational constraints—in
particular, existence of most general/principal solutions and eﬃcient incre-
mental algorithms for computing them (uniﬁcation)—have led to type sys-
tems whose design has been driven to a considerable degree by a desire to
deploy eﬃcient uniﬁcation technology for automatic inference, not only by
semantic or logical analysis for capturing relevant semantic information.
Labels as Regions
We can think of region variables as being bound to memory regions and
(re)interpret tagging and untagging operations as follows. The value ⟨v⟩p de-
notes a(ny) pointer into region p where v is stored. The tagging operation
t at p is implemented by storing the value of t in region p. Its result is the
pointer to where the value is stored. The untagging operation t ! p is imple-
mented as evaluating t to a pointer, checking that it points into region p and,
if it does, retrieving the pointer’s value. The TL type system guarantees that
all checks succeed and so can be elided at run time.

3.2
Value Flow by Typing with Labels
99
New terms
t
::=
. . .
terms:
new ρ.t
region-scoped term
p
::=
label expressions:
•
deleted/inaccessible region)
New evaluation rules
t ST
-→t′
t -→t′
new ρ.t -→new ρ.t
(E-New)
new ρ.v -→[ρ , •]v
(E-NewBeta)
New typing rules
Γ ⊢t : T
Γ ⊢t : T
ρ ̸∈frv(Γ, T)
Γ ⊢new ρ.t : T
(T-NewUnsound)
Figure 3-4: Scoped tagged language (unsound), STL (basis: TL)
Now consider the (derivable) judgment Γ ⊢t : T for a subterm t in a pro-
gram. Assume that ρ occurs in t in tagging and/or untagging operations. If
ρ does not occur in Γ then, intuitively, the environment in which t evaluates
contains no values in ρ; it is empty. Furthermore, if ρ does not occur in T ei-
ther, then no values stored in ρ are needed by the context of t; all the values
stored in ρ can be deleted.
This leads us to the introduction of terms with (lexically) scoped regions:
new ρ.t. Here new ρ.t binds region variable ρ in t. The semantics of new ρ.t
is as follows: allocate a new region, bind it to ρ, evaluate t and, ﬁnally, deal-
locate the region bound to ρ. This results in a stack-oriented memory man-
agement discipline: the most recently allocated region is deallocated ﬁrst.
Figure 3-4 shows new ρ.t and corresponding evaluation and typing rules,
which extend TL to STL. In rule (T-NewUnsound) function frv(Γ, T) denotes
the set of region variables that occur freely in Γ and T.
Rule (E-New) expresses that a region-scoped term new ρ.t is evaluated by
reducing t to a value v. During this reduction, it is possible that region ρ
is accessed. After evaluation is complete new ρ.v is reduced to [ρ , •]v by
rule (E-NewBeta), where • is substituted for all occurrences of ρ in v. In
particular, all occurrences in v of the form ⟨v′⟩ρ are replaced by ⟨v′⟩•. Since
rule (E-UntagBeta) from Figure 3-2 requires a proper region variable, any
access to such a value gets stuck. Note, in particular, that the term ⟨v′⟩• ! •
is stuck. In this fashion the substitution of • for ρ makes all values stored
in ρ inaccessible in ensuing computation steps, which models deleting the
whole region of values stored in ρ.
The bad news is that STL is unsound: Stuck states can occur. The reason
for this is that a term t with derivable judgment Γ ⊢t : T may still access
region ρ during evaluation even if ρ occurs neither in Γ nor T.

100
3
Eﬀect Types and Region-Based Memory Management
3.2.20
Example: Consider the following STL-term tf =:
new ρ0.let x = tt at ρ0 in λy.if x ! ρ0 then y else ff at ρ1
It reduces as follows:
new ρ0.let x = tt at ρ0 in λy.if x ! ρ0 then y else ff at ρ1
-→
new ρ0.let x = ⟨tt⟩ρ0 in λy.if x ! ρ0 then y else ff at ρ1
-→
new ρ0.λy.if ⟨tt⟩ρ0 ! ρ0 then y else ff at ρ1
-→
λy.if ⟨tt⟩• ! • then y else ff at ρ1
Note that ρ0 occurs freely in λy.if ⟨tt⟩ρ0 ! ρ0 then y else ff at ρ1 before
performing the last reduction step. Its type bool at ρ1 →bool at ρ1, how-
ever, does not mention ρ0. Note that
λy.if ⟨tt⟩• ! • then y else ff at ρ1
is a value; it is not stuck. It is easy to see, however, how it can give rise to a
stuck state. The program tf (tt at ρ1) is a well-typed STL-program of type
bool at ρ1, yet evaluation gets stuck:
tf (tt at ρ1)
∗-→
(λy.if ⟨tt⟩• ! • then y else ff at ρ1) (tt at ρ1)
-→
if ⟨tt⟩• ! • then ff at ρ1 else ff at ρ1
To continue evaluation would require reduction of ⟨tt⟩• ! • to a Boolean
value; ⟨tt⟩• ! •, however, is stuck.
2
In §3.3 we introduce explicit eﬀects into types to capture the accesses to
regions needed for evaluation. This is the path taken by Tofte and Talpin
(1997) in their ground-breaking work on region-based memory management.
Notes on Value Flow Analysis
Although Reynolds (1969) was the ﬁrst to look at the problem of comput-
ing ﬂow for structured data and called it data set computation, we follow
Schwartz (1975) in using the term value ﬂow to emphasize its general ap-
plicability to primitive, structured, and higher-order data. Schwartz (1975)
developed value ﬂow analysis for structured values in the context of SETL
and was the ﬁrst to suggest exploiting lifetime analysis based on value ﬂow
analysis for region-based memory management. Closure analysis, the term in-
troduced by Sestoft (1989), and control ﬂow analysis, the term used by Shivers
(1988; 1991), focus on the ﬂow of function values (function closures). Note

3.2
Value Flow by Typing with Labels
101
that data and control ﬂow are interdependent for higher-order languages; see
Mossin (1997, Section 1.4) for a discussion of this. Shivers coined the term
0CFA, which in other literature is also used for the monovariant value ﬂow
analyses above (which is diﬀerent from Shivers’ 0CFA, however; see Mossin
[1997] for a discussion). Another form of monovariant value ﬂow analysis is
set-based analysis (Heintze, 1994).
Palsberg and O’Keefe (1995) showed that safety analysis, a constraint-based
analysis, characterizes typability in Amadio and Cardelli’s type system (1993)
with recursive subtyping, providing a type theoretic characterization of mono-
variant value ﬂow analysis. Constraint-based value ﬂow analysis for object-
oriented languages was pioneered by Palsberg and Schwartzbach (1990, 1994).
See Nielson, Nielson, and Hankin (1999) for a presentation of monovariant
value ﬂow analysis based on ﬂow logic and abstract interpretation.
Classical data ﬂow analysis corresponds to value ﬂow analysis for primitive
data (only); it has been used in compilers already in the early 1960s. See Aho,
Sethi, and Ullman (1986) for its history.
Monovariant value ﬂow analysis is directional: values ﬂow from construc-
tor points (value expressions) to uses, but not the other way around. The
value ﬂow information for BL as expressed in TL-completions corresponds to
a very simple (and inexpressive) value ﬂow analysis: equational ﬂow analysis,
in which value ﬂows are treated symmetrically (Heintze, 1995). Intuitively,
this means all ﬂows are bidirectional: values do not only “ﬂow” from their
creation points to their uses, as in monovariant value ﬂow analysis (0CFA),
but somewhat weirdly, also the other way around. The type-based presenta-
tion of equational value ﬂow analysis in this section owes greatly to Mossin
(1997, Section 2), where it is called simple ﬂow analysis.
Polymorphic value ﬂow analysis was developed by Mossin (1997), extend-
ing earlier work by Dussart, Henglein, and Mossin (1995) and Henglein and
Mossin (1994) on combining subtyping, parametric polymorphism and poly-
morphic recursion for binding-time analysis. Polymorphic value ﬂow anal-
ysis is modular and can be computed asymptotically in the same time as
monomorphic value ﬂow analysis. Transitive closure is the algorithmic bot-
tleneck in both. Eﬃcient algorithms are given by Fähndrich, Rehof, and Das
(2000), Rehof and Fähndrich (2001), and Gustavsson and Svenningsson (2001).
Polymorphic equational value ﬂow analysis underlies Tofte–Talpin style
region-based memory management; see §3.5. Region-based memory manage-
ment based on directional value ﬂow analysis appears possible, but has not
been explored. The recognition that region inference performs a form of value
ﬂow and dependency analysis is folklore; it has been exploited by Helsen and
Thiemann (2004) for polymorphic specialization. Deriving region-based mem-
ory management systematically from type-based value ﬂow analysis appears

102
3
Eﬀect Types and Region-Based Memory Management
to be new, however. The syntactic modeling of region deallocation by • is due
to Helsen and Thiemann (2000) and Calcagno (2001).
See §3.4 and the following sections for more references on region-based
memory management.
3.3
Eﬀects
We have seen in the previous subsection that the soundness of a typing rule
may depend not only on the results of evaluations, but on certain aspects
of the evaluation itself, in other words on how a value is computed, not just
which value is computed. To capture properties of evaluation we introduce
eﬀects.
Eﬀect Type Judgments
The basic eﬀect type judgment is
Γ ⊢t :ϕ T
where ϕ is an eﬀect expression (henceforth simply called eﬀect) and ϕT is an
eﬀect type or type and eﬀect. The judgment should be read informally as “Un-
der the assumptions Γ, the evaluation of t may have the observable eﬀect ϕ,
and it eventually yields a value of type T, if any.” For program analysis pur-
poses observable may also be understood as interesting. When an evaluation
has no observable eﬀect, we say it has the empty eﬀect, written ∅, and ∅T is
abbreviated to T.
In a call-by-name language, Γ is a sequence of eﬀect type assumptions of the
form x : ϕT, since x may be bound to unevaluated thunks, whereas in a call-
by-value language we have type assumptions of the form x : T since variables
are bound to values, whose evaluation is guaranteed to always have the empty
eﬀect. Analogously, in a call-by-name language we have general functional
types of the form ϕ1T1 →ϕ2T2; in a call-by-value language, however, we can
restrict ourselves to functional types of the form T1 →ϕT2.1
1. The syntax ϕT has been chosen here for several reasons:
•
It expresses that yielding a value of type T is the last “eﬀect” of evaluation; that is it occurs
after ϕ.
•
Functional types in a call-by-value language end up being written T1 →ϕT2, which is con-
sistent with the notation used in the literature where the delayed eﬀect ϕ is written above
the function type arrow.
•
It is consistent with the syntax MϕT used in monadic interpretations of type and eﬀect
systems in the literature.

3.3
Eﬀects
103
Terms
t
::=
terms:
v
value expression
x
variable
t t
application
if t then t else t
conditional
t at p
tagging
t ! p
untagging
new ρ.t
label-scoped term
fix x.t
recursion
v
::=
value expressions:
λx.t
abstraction
bv
truth value
⟨v⟩p
tagged value
bv
::=
truth values:
tt
true
ff
false
p
::=
label/region expressions:
ρ
label/region variable
•
deleted/inaccessible label/region
Eﬀect expressions
ϕ
::=
{ρ, . . . , ρ}
eﬀect expressions:
Types
T
::=
types:
bool
Boolean type
T →ϕT
function type
T at p
tagged value type
Eﬀect typing rules
Γ ⊢t :ϕ T
x ̸∈Γ ′
Γ, x : T, Γ ′ ⊢x :ϕ T
(TE-Var)
Γ ⊢bv :ϕ bool
(TE-Bool)
Γ ⊢t1 :ϕ bool
Γ ⊢t2 :ϕ T
Γ ⊢t3 :ϕ T
Γ ⊢if t1 then t2 else t3 :ϕ T
(TE-If)
Γ, x : T1 ⊢t :ϕ2 T2
Γ ⊢λx.t :ϕ1 T1 →ϕ2T2
(TE-Abs)
Γ ⊢t0 :ϕ T1 →ϕT2
Γ ⊢t1 :ϕ T1
Γ ⊢t0 t1 :ϕ T2
(TE-App)
Γ ⊢t :ϕ T
p ∈ϕ
Γ ⊢t at p :ϕ T at p
(TE-At)
Γ ⊢t :ϕ T at p
p ∈ϕ
Γ ⊢t ! p :ϕ T
(TE-From)
Γ ⊢v :ϕ T
Γ ⊢⟨v⟩p :ϕ T at p
(TE-Cell)
Γ ⊢t :ϕ T
ρ ̸∈frv(Γ, T)
Γ ⊢new ρ.t :ϕ−{ρ} T
(TE-New)
Γ, x : T ⊢t :ϕ T
Γ ⊢fix x.t :ϕ T
(TE-Fix)
Figure 3-5: Scoped eﬀect typed language ETL(sound)
Eﬀect Typed Language ETL
We shall now present an eﬀect typing system for language ETL. ETL has the
same source terms and evaluation rules as STL. The only diﬀerence to STL
is its eﬀect type system. Syntax and eﬀect typing rules for ETL are given in
Figure 3-5.
An eﬀect is a ﬁnite set of region variables. Note that it must not contain •.
A judgment Γ ⊢t :ϕ T is intended to express that, assuming the free variables

104
3
Eﬀect Types and Region-Based Memory Management
of t are bound to values of types according to Γ, the regions that t accesses
during evaluation are included in ϕ and the result of the evaluation has type
T if it terminates.
The typing rules of Figure 3-5 are basically those corresponding to the
monomorphic subset of the Tofte-Talpin system, which we shall encounter in
§3.5.2 They are inspired by a desire to employ equational constraint solving
for eﬀect expressions as much as possible.
Since we are only interested in whether a particular region may be accessed
during evaluation of a term or not, our eﬀect system does not record the
order in which eﬀects take place. We simply record the set of region variables
that may be accessed during evaluation of t. In this sense our eﬀect type
system is control-ﬂow insensitive. Eﬀect type systems that capture evaluation
order in their eﬀects are discussed brieﬂy later.
Soundness
Eﬀects make the region variables accessed during evaluation suﬃciently “vis-
ible” to ensure that the typing rule for new ρ.t is sound.
3.3.1
Example: Consider the term
tf = new ρ0.let x = tt at ρ0 in λy.if x ! ρ0 then y else ff at ρ1
from Example 3.2.20 again. Whereas it is typable in STL even though it gets
stuck when applied to an argument, it is not typable in ETL. To see this,
consider the let-expression tl
let x = tt at ρ0 in λy.if x ! ρ0 then y else ff at ρ1
inside tf . Its ETL eﬀect type Tl is {ρ0}(bool at ρ1 →{ρ0}bool at ρ1). Note that
ρ0 occurs in the eﬀect, but in neither the function type’s domain nor its range
type. This reﬂects the fact that an application of tl may access region ρ0.
Since ρ0 ∈frv(bool at ρ1 →{ρ0}bool at ρ1), rule (TE-New) is not applicable,
and so there is no way of inferring a type for tf , which indeed would be
unsound.
2
3.3.2
Exercise [««, 3]: Give a derivation of ⊢tl : Tl. Argue that any ETL-derivable
type T for tl must contain an occurrence of ρ0.
2
2. The only substantial diﬀerence is rule (TE-App). It is more restrictive than the corresponding
rule (RT-App) in the sense that it requires ϕ2 ⊆ϕ in rule (RT-App) to be solved equationally.
Note that, in general, the typing rules of TT in §3.5 are for con/decon completions (only). They
can be derived from ETL by merging rules (TE-From) and (TE-Cell) into the other rules.

3.3
Eﬀects
105
Generally, we can prove the following soundness theorem.
3.3.3
Theorem [Soundness of ETL]: If ⊢t :ϕ T then evaluation of t does not get
stuck.
2
We shall not prove this result here. The techniques will be presented in
§3.5 for a more general type system.
3.3.4
Exercise [««««, 3]: Prove correctness for ETL. Do so by extending the Con-
ditional Correctness Theorem and the Soundness Theorem for TL to ETL.
2
Notes on Eﬀect Type Systems
Type and eﬀect systems are introduced by Lucassen, Giﬀord and Jouvelot
(Giﬀord and Lucassen, 1986; Lucassen, 1987; Lucassen and Giﬀord, 1988;
Jouvelot and Giﬀord, 1989) for integrating imperative operations, notably up-
datable references and control eﬀects, into functional languages. Type and
eﬀect inference using uniﬁcation technology, which is the basis for region
inference, is developed by Jouvelot and Giﬀord (1991) and Talpin and Jou-
velot; Talpin and Jouvelot (1992; 1994). Tofte and Talpin (1997) develop it
into region inference for region-based memory management.
Nielson and Nielson (1994, 1996) pioneered type and eﬀect systems with
behaviors or causal eﬀects, where eﬀect types model order of evaluation. In
such systems the language of eﬀect expressions has operators for sequen-
tial composition and choice. They also provide for recursively deﬁned eﬀect
expressions. The sequential composition operator captures the sequential or-
der of the execution of eﬀects. The choice operator corresponds to choice
of one eﬀect or another. This changes the nature of eﬀects substantially as
they basically turn into process algebras, with their own nontrivial theory.
Modeling order of execution is key to capturing synchronization properties
of concurrent processes, where atomic eﬀects include sending and receiving
messages. See Amtoft, Nielson, and Nielson (1999) and Nielson, Nielson, and
Hankin (1999) for references on soundness, inference and applications.
The applications of type and eﬀect systems include veriﬁcation of cryp-
tographic protocols by eﬀect type checking (Gordon and Jeﬀrey, 2001b,a,
2002), behavioral type systems for asynchronous programming (Igarashi and
Kobayashi, 2001; Rajamani and Rehof, 2001; Chaki, Rajamani, and Rehof,
2002; Rajamani and Rehof, 2002), and interference analysis for concurrent
threads (see Flanagan and Qadeer [2003] for references).
In terms of the computational λ-calculus of Moggi (1989), types are asso-
ciated with values and eﬀect types with computations; that is, intuitively, an
eﬀect type ϕT corresponds to an (eﬀect indexed) monad type MϕT. This con-

106
3
Eﬀect Types and Region-Based Memory Management
nection is investigated by Semmelroth and Sabry (1999), Wadler (2003), and
Fluet (2004).
3.4
Region-Based Memory Management
Region-based memory management is a particular way to manage the dy-
namically (or heap-) allocated memory of a program. Traditionally, the heap
is managed either explicitly by the programmer using constructs such as C’s
malloc and free, or automatically by a garbage collector leaving the pro-
grammer with only the responsibility of when to allocate memory. Region-
based memory management uses explicit instructions for the allocation and
deallocation of memory, but the safety of the explicit deallocations is guar-
anteed by a type system, and in some cases a compile-time analysis called
“region inference” (§3.6) can insert the allocation and deallocation instruc-
tions automatically.
Basically a region is a sub-heap containing a number of heap-allocated val-
ues, and the heap is a collection of regions. A region starts out empty and
grows when a value is allocated in it. A region can grow independently of the
other regions constituting the heap; that is, one can allocate values in all re-
gions currently available. Regions can only shrink when the complete region
is deallocated; one does not deallocate individual values.
In summary, we use three region primitives: (1) allocation of a new region,
(2) allocation of a value in a region, and (3) deallocation of a complete region
(and thereby all values allocated in the region). In contrast to TL in §3.2 we
simply elide dereferencing.
A Region-Annotated Language
Our region-annotated language RAL is a lambda calculus with a ﬁxed-point
operator and (Boolean) constants, extended with explicit region annotations.
Its syntax and evaluation semantics are deﬁned in Figure 3-6. As usual, λx.t
and fix x.u binds the variable x in t and u, respectively. Similarly, λρ.u and
new ρ.t binds the region variable ρ in u and t, respectively.
By analogy with §3.2, we deﬁne basic semantic notions for RAL. We write
t
RAL
-→t′ if t -→t′ can be derived from the RAL evaluation rules in Figure 3-6.
A RAL-term t is ﬁnal if there is no term t′ such that t
RAL
-→t′. Note that each
value expression is ﬁnal. All other ﬁnal terms are stuck.
We write t -→∗t′ if t
RAL
-→
∗
t′ and t′ is ﬁnal and t ↓if there exists t′ such
that t ↓t′. If t has no ﬁnal state and thus does not terminate, we write t ↑.
The relation →∗! on terms is deﬁned by: t →∗! t′ if t -→∗t′ and t′ is ﬁnal.

3.4
Region-Based Memory Management
107
Terms
t
::=
terms:
u
value or almost-value
x
variable
if t then t else t
conditional
fix x.u
recursion
t t
application
t [[p]]
region application
new ρ.t
region creation
u
::=
almost-values:
v
value
(λx.t) at p
abstraction
(λρ.u) at p
region abstraction
v
::=
value expressions:
bv
truth value
⟨λx.t⟩p
closure
⟨λρ.u⟩p
region closure
bv
::=
truth values:
tt
true
ff
false
p
::=
places:
ρ
region variable
•
deallocated
Evaluation
t
RAL
-→t′
t1 -→t′
1
if t1
then t2
else t3 -→if t′
1
then t2
else t3
(RE-If)
if tt then t2 else t3 -→t2
(RE-IfTrue)
if ff then t2 else t3 -→t3
(RE-IfFalse)
t1 -→t′
1
t1 t2 -→t′
1 t2
(RE-App1)
t2 -→t′
2
v1 t2 -→v1 t′
2
(RE-App2)
λx.t at ρ -→⟨λx.t⟩ρ
(RE-Clos)
⟨λx.t⟩ρ v -→[x , v]t
(RE-Beta)
u -→u′
fix x.u -→fix x.u′
(RE-Fix)
fix x.v
-→[x , fix x.v]v
(RE-FixBeta)
t -→t′
t [[p]] -→t′ [[p]]
(RE-RApp)
λρ1.u at ρ2 -→⟨λρ1.u⟩ρ2
(RE-RClos)
⟨λρ1.u⟩ρ2 [[p]] -→[ρ1 , p]u
(RE-RBeta)
t1 -→t′
1
new ρ.t1 -→new ρ.t′
1
(RE-New)
new ρ.v -→[ρ , •]v
(RE-Dealloc)
Figure 3-6: Region-annotated language, RAL
3.4.1
Definition: Let the function “evalR(·)” from terms to {tt, ff, ⊥, wrong} be:
a) evalR(t0) = bv iﬀt0 →∗!
R bv.
b) evalR(t0) = ⊥iﬀthere is an inﬁnite sequence t1, t2, . . . , ti, . . . such that
ti
RAL
-→ti+1 for 0 ≤i.
c) evalR(t0) = wrong iﬀt0 →∗! t where t is not a value.
2

108
3
Eﬀect Types and Region-Based Memory Management
Recall that the new ρ.t construct introduces a new region variable ρ. The
variable ρ can be used to annotate value-producing terms within t. The al-
location of the new region in our system is implicit; it happens automati-
cally when the execution focus moves inside the new binder. Implicit alpha-
conversion makes sure that the new does not capture any foreign region vari-
ables before the allocation. On the other hand, deallocation is explicit in the
evaluation semantics. The (RE-Dealloc) rule records the fact that a value
stored in the deallocated region is no longer available by replacing the region
variable with the special marker •. The “dangling pointers” to deallocated val-
ues can be manipulated freely as long as one does not attempt to read the
values they point to. At that point execution will get stuck, because there is no
reduction rule for an expression of the form “⟨λx.t⟩• v.” Rule (RE-Beta) that
would ordinarily reduce it applies only when the place is a ρ, which explicitly
does not include • as in the eﬀect typed language ETL.
Observe that the substitution [ρ , •] in (RE-Dealloc) can aﬀect alloca-
tion expressions (· · · ) at ρ as well as already allocated values ⟨· · · ⟩ρ. In the
former case we end up with a “(· · · ) at •” expression which asks to allo-
cate something in a region that does not exist anymore. This is impossible, of
course, but the occurrence of such a subterm is not an error. The error hap-
pens if the expression is eventually executed, in which case execution will get
stuck because (RE-Clos) and (RE-RClos) demand a ρ rather than a p after the
“at.” Similarly a • can appear as the actual parameter in a region application,
and the application can even be reduced without an error.
A novel aspect of the region-annotated language, compared to the tagged
language described previously, is the presence of region abstractions. The in-
tention is that a region abstraction “λρ.u,” where u is an “almost-value (see
Figure 3-6) ranging over normal values and yet-to-be-allocated abstractions,
is the natural counterpart to a normal abstraction only at the level of re-
gions. One can apply such an abstraction to an actual place parameter p in
which case evaluation proceeds by substituting the place p for the formal
parameter ρ in u, and then evaluates the result of this substitution. Region
abstractions allow one to parameterize a function over the regions necessary
for the evaluation of the function. Typically, this means parameterizing over
the regions containing the input to the function and the regions in which the
output should be stored. We say that such a function is region polymorphic
in the region parameters.
For example, consider the following program computing Fibonacci num-
bers.3
3. In examples we shall allow ourselves to use features such as integers allocated in regions
even though they are not part of the formal development.

3.4
Region-Based Memory Management
109
fix fib. λn.
if n<2 then 1
else fib(n-2)+fib(n-1)
One possible region annotation of this program is (ignore everything but the
ﬁrst line for now):
fix fib. (λρi. (λρo. (λn.
if new ρ. (n < (2 at ρ) then 1 at ρo)
else new ρ1.
new ρ2.fib[[ρ2]][[ρ1]] (new ρ.n -at ρ2 (2 at ρ))
+atρonew ρ3.fib[[ρ3]][[ρ1]] (new ρ.n -at ρ3 (1 at ρ))
) at ρi) at ρi) at ρf
The point is that the fib function expects two region parameters at runtime:
one, ρi, in which the input n is stored, and one, ρo, in which the function
is supposed to store its result. Thus, any caller of fib is required to choose
appropriate actual regions for these as witnessed in the two calls to fib in
the body.
Observe that, since the only way to allocate and deallocate a region is via
the new construct, it is not possible for the function to deallocate a region
associated with a parameter, and similarly, the function cannot itself allo-
cate such a region. The consequence is that the lifetime of regions passed as
parameters to a function encompasses the lifetime of the complete function
invocation. In order to avoid large, long-lived regions, it is therefore impor-
tant to allow the body of a recursive function to use actual parameters to
recursive invocations diﬀerent from the formal parameters. This is referred
to as region polymorphic recursion in the literature, as it allows us to choose
diﬀerent instantiations of the polymorphically bound region parameters for
diﬀerent invocations.
Continuing the Fibonacci example above, it is crucial that the two recursive
calls to fib can each supply their own actual parameters (in this case ρ2, ρ1
and ρ3, ρ1). Thus, for each call we store the arguments in separate regions
whose lifetimes are just the duration of the function call. The results need
slightly longer lifetimes, since we need to add those up to give the result of
the original call, but they can be stored in the same region. (The example is
taken from Tofte and Talpin [1997].)
3.4.2
Exercise [««]: What would happen to the region-behavior of the Fibonacci
program if region polymorphic recursion were disallowed (that is, if the re-
cursive calls were required to use the formal region parameters as actual
region parameters)?
2

110
3
Eﬀect Types and Region-Based Memory Management
The original calculus proposed by Tofte and Talpin (let us call it the TT cal-
culus) diﬀers from our RAL in a number of ways. The most conspicuous dif-
ference is that the region-creation construct “new ρ.t” is written “letregion
ρ in t.” A more subtle one is that TT restricts the places where region ab-
stractions and recursive function deﬁnitions can occur. Region abstractions
are only allowed in the deﬁnition of recursive functions, and a recursive func-
tion deﬁnition must appear in a let binding. These restrictions are implicit
in the syntax of TT—it combines recursion and region abstraction in a single
combined construction
t ::= letrec f[ρ1, . . . , ρk](x) at ρ = t1 in t2
which corresponds to the RAL expression
let f = fix f.(λρ1, . . . , ρk, ρ′.(λx.t1) at ρ′) at ρ in t2
Using the letrec as an abbreviation, we can rewrite the Fibonacci example
to the following program:
letrec fib[ρi, ρo] (n) at ρf =
if new ρ. (n < (2 at ρ) then 1 at ρo)
else
new ρ1.
new ρ2. fib[ρ2, ρ1] (new ρ. n -at ρ2 (2 at ρ))
+at ρonew ρ3. fib[ρ3, ρ1] (new ρ. n -at ρ3 (1 at ρ))
3.4.3
Exercise [««]: This unfolding of the TT letrec uses abstraction over multi-
ple regions at once, which is not actually part of the RAL calculus. Show how
n-ary region abstractions can be simulated using our unary ones.
2
3.4.4
Exercise [«]: What is the role of the ρ′ parameter in the above RAL expan-
sion of TT’s letrec construction? Can you guess why it is not part of the
original TT syntax?
2
3.4.5
Exercise [«]: What is the role of ρ in the letrec construction? Is it really
operationally necessary?
2
The dynamic semantics presented by Tofte and Talpin (1997) stresses that
regions are allocated and deallocated according to a stack discipline. A run-
time conﬁguration contains a region environment that maps region variables
to concrete regions (denoted by r), and a store that maps (concrete) regions to
the values stored in them. Evaluation of a new ρ.t then proceeds as follows:
(1) ﬁrst choose a fresh (concrete) region r and extend the region environment

3.4
Region-Based Memory Management
111
with a binding ρ , r and the store with a binding r , ∅where ∅is the
empty region containing no values; (2) then proceed with the evaluation of
t in this extended runtime conﬁguration; (3) complete the evaluation of the
entire term by removing the bindings for ρ and r from the conﬁguration.
That original formulation is closer to an operational understanding of how
the region operations work than the store-less semantics we use here. On the
other hand, the store-less semantics is easier to reason about, a trick due to
Helsen and Thiemann (2000) and Calcagno (2001). See Calcagno et al. (2002)
for a proof that the two styles of semantics are indeed equivalent.
Reusing Deallocated Memory
Intuitively it should be safe to reuse deallocated memory (indicated by the
special place •) while executing a region-safe program. More formally, assume
that t• is a term containing deallocated values and that t is constructed from
t• by replacing some of these with new values. Then if t• evaluates to some
value or loops indeﬁnitely (that is, it does not go wrong), then so does t.
3.4.6
Proposition: Let Val be the set of values and Dead be the subset of values of
the form “⟨. . .⟩•.” Let the relation ⪯between terms be the compatible closure
of Dead × Val. That is, t• ⪯t if t arises from t• by replacing some (zero or
more) deallocated values by arbitrary new values.
If t• ⪯t and evalR(t•) = Y ≠wrong, then evalR(t) = Y, too.
2
Proof:
Left as an exercise (««, 3).
2
Annotating Programs with Regions Preserves Meanings
Region annotating a program is the process of adding region annotations to
it to make the memory management explicit (see §3.6 for how to do this au-
tomatically). Thus, the process takes a program written in BL and produces a
program written in RAL. The intention is, of course, that the region-annotated
program is supposed to have the same behavior as the original program. In
other words, we shall prove that adding region annotations preserves the
meaning of the program. We make this precise in the present section. We
do so by starting with a region-annotated program and showing that it be-
haves the same as the program obtained by removing all region annotations
(thereby obtaining a program in BL, Figure 3-1).
By analogy with erasure for TL-terms, going from a term in the region-
annotated language RAL to a term in the underlying base language BL is a
matter of erasing all region annotations.

112
3
Eﬀect Types and Region-Based Memory Management
∥bv∥
=
bv
if t0
then t1
else t2

=
if ∥t0∥then ∥t1∥
else ∥t2∥
∥x∥
=
x
∥(λx.t) at p∥
=
λx.∥t∥
⟨λx.t⟩p

=
λx.∥t∥
∥t1 t2∥
=
∥t1∥∥t2∥
∥fix x.u∥
=
fix x.∥u∥
∥new ρ.t∥
=
∥t∥
∥(λρ.u) at p∥
=
∥u∥
⟨λρ.u⟩p

=
∥u∥
∥t [[p]]∥
=
∥t∥
Figure 3-7: Deﬁnition of the erasure function
3.4.7
Definition: The erasure ∥t∥of a region-annotated term t is the BL-term
deﬁned by removing the region annotations, as shown in Figure 3-7.
2
The ideal meaning-preservation statement would be: For any region-anno-
tated program t, if evalR(t) = Y then eval(∥t∥) = Y and vice versa. Unfor-
tunately that is not true, since t can go wrong due to memory-management
errors (such as trying to read a value after it has been deallocated) that have
no counterpart in ∥t∥. What we can prove, however, is the following theorem:
3.4.8
Theorem [Conditional correctness]: Let t be a region-annotated program
(i.e., formally, any term), and assume evalR(t) ≠wrong. Then evalR(t) =
eval(∥t∥).
2
In other words, a region-annotated program behaves the same as the orig-
inal unannotated program, unless it goes wrong. Our semantics for region-
annotated programs does not allow us to distinguish between going wrong
because of memory-management errors and going wrong due to plain old
type errors, but it would be straightforward (though tedious) to extend the
semantics with such a notion and then prove that if eval(∥t∥) ≠eval(t) then
eval(t) is memory-wrong rather than type-wrong. Since we are primarily con-
cerned with well-typed programs, we will not pursue that further.
The proof of the theorem proceeds through a series of lemmas:
3.4.9
Lemma: Assume that t is a value v or an almost-value u. Then ∥t∥is a value
for BL.
2
Proof:
By structural induction on t. The induction hypothesis is used in the
case of region abstractions and closures, which disappear during erasure.
(This is why the body of a region abstraction is restricted to be an almost-
value rather than an arbitrary term.)
2

3.4
Region-Based Memory Management
113
3.4.10
Lemma [Simulation]: Assume t
RAL
-→t′. Then either (a) ∥t∥-→∥t′∥or (b)
∥t∥= ∥t′∥.
2
Proof:
By induction on the derivation of t
RAL
-→t′.
For the rules (RE-If), (RE-App1), and (RE-App2), apply the induction hypothe-
sis. If this application yields case (a), use the corresponding context rule from
BL. In the case of (RE-App2), Lemma 3.4.9 ensures that erasure of the function
expression is still a value, such that the corresponding BL rule is available.
For the rule (RE-Fix), ﬁrst observe that since the body of the ﬁx is an almost-
value, the only rules that can establish the reduction u
RAL
-→u′ are (RE-Clos)
and (RE-RClos). Then, by inspection of each of these rules we ﬁnd ∥u∥= ∥u′∥,
and thus also ∥fix x.u∥= ∥fix x.u′∥.
For (RE-IfTrue), (RE-IfFalse), (RE-Beta), and (RE-FixBeta), the ∥t∥-→∥t′∥
case applies through the corresponding BL reductions.
For (RE-RApp) and (RE-New), use the induction hypothesis directly.
For (RE-Clos) and (RE-RClos), ∥t∥= ∥t′∥holds trivially. The case is simi-
lar for (RE-RBeta) and (RE-Dealloc), because the erasure hides the eﬀect of
region substitutions.
2
3.4.11
Lemma [Simulated progress]: Assume t
RAL
-→t′ yet not ∥t∥-→∥t′∥. Then
t′ is strictly smaller than t under a size measure where unevaluated abstrac-
tions are considered “larger” (for example, twice as large) than closures.
2
Proof:
From the proof of Lemma 3.4.10 it is clear that the derivation of
t
RAL
-→t′ must consist of a stack of context rules with one of the axioms
(RE-Clos), (RE-RClos), (RE-RBeta), or (RE-Dealloc) at the top. Because the
context rules do not themselves add material to the term, it is suﬃcient to
check the lemma for those four axioms. For (RE-Clos) and (RE-RClos), the
size measure is explicitly deﬁned to make the lemma true. For (RE-RBeta) or
(RE-Dealloc), the region substitution does not change the size of its argu-
ment, whereas the reductions remove either the λ or the new binder.
2
3.4.12
Lemma: Assume evalR(t) = bv. Then eval(∥t∥) = bv, too.
2
Proof:
We have that t →∗! bv. By applying Lemma 3.4.10 to each of the re-
duction steps in turn, we get ∥t∥
BL
-→∗∥bv∥= bv. Since bv has no successor,
eval(∥t∥) = bv.
2
3.4.13
Lemma: Assume evalR(t0) = ⊥. Then eval(∥t0∥) = ⊥, too.
2
Proof:
The assumption gives us an inﬁnite series of reductions t0
RAL
-→t1
RAL
-→
· · ·
RAL
-→ti . . . . By Lemma 3.4.10, we get for each i ≥0 that either ∥ti∥= ∥ti+1∥

114
3
Eﬀect Types and Region-Based Memory Management
or ∥ti∥
BL
-→∥ti+1∥. Lemma 3.4.11 guarantees that there does not exist an N
such that ∥ti∦
BL-→∥ti+1∥for all i > N. Therefore, by choosing certain i’s,
we get an inﬁnite series of BL reductions ∥t0∥
BL-→
ti1

BL-→· · ·
BL-→
tij
 . . . .
Hence eval(∥t0∥) = ⊥.
2
Proof:
[of Theorem 3.4.8] Assume that evalR(t) ≠wrong. Then evalR(t) is ei-
ther bv or ⊥, and one of the last two lemmas gives us eval(∥t∥) = evalR(t). 2
3.5
The Tofte–Talpin Type System
One of the features that diﬀerentiates Tofte and Talpin’s region language
from other region-based systems (such as Hanson [1990], Ross [1967], and
Schwartz [1975]) is the presence of a type system. The type system is sound
(page 117) and thus well-typed programs do not go wrong at runtime. In the
present setting, this means that if the term t is well-typed then evalR(t) ≠
wrong. In particular, well-typed programs are memory safe. In contrast to
this, in the other systems mentioned above, the programmer has to establish
memory safety manually, and this is essentially just as hard as establishing
memory safety of C-like malloc/free programs.
In Figure 3-8, we deﬁne a region type system for RAL, called RTL for “Region-
Typed Language.” The judgment Γ ⊢t :ϕ T reads: in type environment Γ the
term t has type T and eﬀect ϕ. The eﬀect captures the regions that have to
be live (that is, allocated) for the term to evaluate without memory problems.
In types, ∀X.T binds the type variable X in T, Πρ.ϕT binds the region variable
ρ in T and ϕ, and ∀ϵ.T binds the eﬀect variable ϵ in T. We denote the sets of
free type variables, free region variables, and free eﬀect variables of a type T
by ftv(T), frv(T), and fev(T), respectively. These are extended to typing con-
texts in the obvious manner. We write [X , T], [ρ , p], and [ϵ , ϕ] for the
capture-avoiding substitutions of type T for the type variable X, place p for
the region variable ρ, and eﬀect ϕ for the eﬀect variable ϵ, respectively.
The typing rules in Figure 3-8 are natural extensions of the typing rules for
the eﬀect typed language in Figure 3-5 (page 103). The region-annotated lan-
guage, is however, both type polymorphic and eﬀect polymorphic. The type
system includes standard rules for introducing and eliminating type poly-
morphism and the obvious variations for eﬀect polymorphism. Compared to
System F (TAPL, Chapter 23) we do not have explicit syntax for these intro-
ductions and eliminations. As already mentioned, the language also contains
region polymorphism. Region polymorphism is explicit in the syntax because
it has operational signiﬁcance.
Eﬀect polymorphism is the natural complement to type polymorphism and
higher-order functions. Consider a higher-order polymorphic function such

3.5
The Tofte–Talpin Type System
115
Type expressions
p
∈
Place
places
ϵ
∈
EﬀVar
eﬀect variables
ϕ
∈
Pﬁn(Place ∪EﬀVar)
eﬀects
T
::=
type expressions:
X
type variable
bool
Boolean type
(T →ϕT, p)
function type
(Πρ.ϕT, p)
region function
∀X.T
type polymorphism
∀ϵ.T
eﬀect polymorphism
Typing rules
Γ ⊢t :ϕ T
Γ(x) = T
Γ ⊢x :ϕ T
(RT-Var)
Γ ⊢bv :ϕ bool
(RT-Bool)
Γ ⊢t1 :ϕ bool
Γ ⊢t2 :ϕ T
Γ ⊢t3 :ϕ T
Γ ⊢if t1 then t2 else t3 :ϕ T
(RT-If)
Γ, x : T1 ⊢t :ϕ2 T2
p ∈ϕ
Γ ⊢(λx.t) at p :ϕ (T1 →ϕ2T2, p)
(RT-Abs)
Γ, x : T1 ⊢t :ϕ2 T2
Γ ⊢⟨λx.t⟩p :ϕ (T1 →ϕ2T2, p)
(RT-Clos)
Γ ⊢t0 :ϕ (T1 →ϕ2T2, p)
Γ ⊢t1 :ϕ T1
p ∈ϕ
ϕ2 ⊆ϕ
Γ ⊢t0 t1 :ϕ T2
(RT-App)
Γ, x : T ⊢u :ϕ T
Γ ⊢fix x.u :ϕ T
(RT-Fix)
Γ ⊢u :ϕ′ T
ρ ̸∈frv(Γ)
p ∈ϕ
Γ ⊢(λρ.u) at p :ϕ (Πρ.ϕ′T, p)
(RT-RAbs)
Γ ⊢u :ϕ′ T
ρ ̸∈frv(Γ)
Γ ⊢⟨λρ.u⟩p :ϕ (Πρ.ϕ′T, p)
(RT-RClos)
Γ ⊢t :ϕ (Πρ.ϕ′T, p)
p ∈ϕ
[ρ , p′]ϕ′ ⊆ϕ
Γ ⊢t [[p′]] :ϕ [ρ , p′]T
(RT-RApp)
Γ ⊢t :ϕ,ρ T
ρ ̸∈frv(Γ, T)
Γ ⊢new ρ.t :ϕ T
(RT-New)
Γ ⊢t :ϕ T
X ̸∈ftv(Γ)
Γ ⊢t :ϕ ∀X.T
(RT-TGen)
Γ ⊢t :ϕ ∀X.T
Γ ⊢t :ϕ [X , T′]T
(RT-TInst)
Γ ⊢t :ϕ T
ϵ ̸∈fev(Γ, ϕ)
Γ ⊢t :ϕ ∀ϵ.T
(RT-EGen)
Γ ⊢t :ϕ ∀ϵ.T
Γ ⊢t :ϕ [ϵ , ϕ′]T
(RT-EInst)
Figure 3-8: The RTL region type system
as list map: it takes a function and a list as arguments and applies the func-
tion to each element in the list. In the region-free base language, map has type
∀α, β.(α →β) × α list →β list. What is the eﬀect of applying the equiva-
lent of map in the region-annotated language to such arguments? It certainly
has to include the eﬀect, ϕ say, of applying the argument function, and thus
the type of the region-annotated map function would have to reﬂect that in
the latent eﬀect of the complete function:
∀α, β.(α →ϕβ) × (α list, ρ) →{ρ,ρ′}∪ϕ(β list, ρ′)
(see page 121 for the typing rules concerning lists). However, that would only
allow us to apply map to functions with latent eﬀect ϕ. We could of course in-

116
3
Eﬀect Types and Region-Based Memory Management
spect the complete program and make sure that all eﬀects were large enough
that this is not a problem, but this approach would unnecessarily keep many
regions alive. Instead, we can employ eﬀect polymorphism to propagate the
eﬀect of the functional argument to the eﬀect of the complete evaluation of
map as in ∀α, β.∀ϵ.(α →ϵβ) × (α list, ρ) →{ρ,ρ′}∪ϵ(β list, ρ′).
The RTL type system is based on the type system of the TT calculus in Tofte
and Talpin (1997).4 Compared to TT, RTL has moved eﬀect enlargement up-
wards in the derivation tree so that the axioms are responsible for introduc-
ing proper eﬀects. This simpliﬁes both the presentation of the rules and the
soundness proof slightly, and it is possible to establish a meta-property of
the type system that allows eﬀects to be enlarged. Moreover, the RTL system,
with its System-F-like polymorphism in types, regions, and eﬀects, is more
permissive than the TT system with its let-polymorphism. The restrictions
present in the original system were there to simplify the region inference
algorithm.
The typing rules of RTL can be applied in sequence to obtain a typing of
the letrec construction in the TT system. Recall, that a TT letrec
letrec f[ρ1, . . . , ρk](x) at ρ = t1 in t2
is expressed in RAL as
let f = fix f.(λρ1, . . . , ρk, ρ′.(λx.t1) at ρ′) at ρ in t2
The combined construction can be typed by a stack of RTL rules:
Γ, f , T12, x , T ⊢t1 :ϕ1 T1
(RT-Abs)
Γ, f , T12 ⊢t14 :ρ′ T14
(RT-RAbs)
Γ, f , T12 ⊢t13 :ϕ T13
(RT-EGen)
...
(RT-EGen)
Γ, f , T12 ⊢t13 :ϕ T12
(RT-Fix)
Γ ⊢t11 :ϕ T12
(RT-TGen)
...
(RT-TGen)
Γ ⊢t11 :ϕ T11
Γ, f , T11 ⊢t2 :ϕ T2
(RT-Let)
Γ ⊢letrec f[ρ1, . . . , ρk](x) at ρ = t1 in t2 :ϕ T2
4. The type system in that paper is not deﬁned explicitly. The paper presents a typed transla-
tion from a language resembling our Base Language BL to the TT calculus. From this translation
one can extract a type system for TT.

3.5
The Tofte–Talpin Type System
117
where
t14 = (λx.t1) at ρ′
T14 = (T →ϕ1T1, ρ′)
t13 = (λρ1, . . . , ρk, ρ′.t14) at ρ
T13 = (Πρ1, . . . , ρk, ρ′.ρ′T14, ρ)
T12 = ∀ϵ1.. . . ∀ϵn.T13
t11 = fix f.t13
T11 = ∀X1.. . . ∀Xm.T12.
As usual with let-polymorphism, each time f is mentioned in t2, its type
scheme must immediately be fully instantiated. This principle is extended
to the eﬀect and region abstractions; these must also be fully instantiated
(applied, in the case of region abstraction) each time f is mentioned in t2 or
in t1. Thus, the original TT type system does not allow expressions in general
to have type (Πρ.ϕT, p); in particular, region abstractions cannot be passed
as parameters to, or returned from, functions.
Syntactic Type Soundness
We will now prove that typable programs are memory safe. We do so by es-
tablishing type soundness—that is, that well-typed programs do not go wrong.
The type soundness proof is structured as a standard sequence of substitu-
tion, subject reduction, and progress lemmas. This approach was pioneered
by Helsen and Thiemann (2000) in the context of region-based languages,
and apparently independently discovered by Calcagno (2001) for a big-step
semantics. Tofte and Talpin (1997) also proved type soundness, albeit not di-
rectly but as a consequence of their correctness theorem of region inference
and using a complex co-inductive proof technique.
As usual, we start by showing that one can massage derivations so that the
typing context only mentions the free variables of the term and so that the
derivation does not end with one of the instantiation rules.
3.5.1
Lemma: If Γ ⊢t :ϕ T, dom(Γ ′) = fv(t), and Γ and Γ ′ agree when both are
deﬁned, then Γ ′ ⊢t :ϕ T.
2
Proof:
Straightforward induction on the typing derivation.
2
3.5.2
Lemma: Let S be a substitution of the form [ρ , p], [ϵ , ϕ], or [X , T]. If
Γ ⊢t :ϕ T can be derived in n steps, then likewise can SΓ ⊢St :Sϕ ST.
2
Proof:
Left as an exercise («).
2
3.5.3
Lemma: Assume that Γ ⊢v :ϕ T has a derivation in n steps. Then it has a
derivation in at most n steps where the last rule used is neither (RT-TInst)
nor (RT-EInst).
2

118
3
Eﬀect Types and Region-Based Memory Management
Proof:
By induction on n. All but the cases for (RT-TInst) and (RT-EInst) ei-
ther are direct or are simple applications of the induction hypothesis. Thus,
assume that the derivation ends with (RT-EInst) (the case for (RT-TInst) is
similar). Apply the induction hypothesis to the derivation of its premise; this
gives a derivation that concludes in a type with the shape ∀ϵ.T′ yet does
not end with (RT-EInst) or (RT-TInst). It cannot end with (RT-Var), (RT-If),
(RT-App), (RT-Fix), (RT-RApp), or (RT-New) either, because variables, condi-
tionals, applications, ﬁxed-points, region applications, and region creations
are not values. The only other rule that can conclude ∀ϵ.T′ is (RT-EGen), so
the whole derivation now must end with
Γ ⊢v :ϕ T′
ϵ ̸∈fev(Γ, ϕ)
(RT-EGen)
Γ ⊢v :ϕ ∀ϵ.T′
(RT-EInst)
Γ ⊢v :ϕ T
where T = [ϵ , ϕ′]T′ for some ϕ′.
Lemma 3.5.2 now gives a derivation of [ϵ , ϕ′]Γ ⊢v :[ϵ,ϕ′]ϕ [ϵ , ϕ′]T′ in
n −2 steps. But since ϵ ̸∈fev(Γ, ϕ), this conclusion is the same as Γ ⊢v :ϕ T,
so we can use that instead of the original derivation. Now apply the induction
hypothesis to this new derivation.
2
3.5.4
Lemma [Canonical Forms]:
1. if v is a value of type bool, then v is of the form bv;
2. if v is a value of type (T1 →ϕT2, p) then v is of the form ⟨λx.t⟩p;
3. if v is a value of type (Πρ.ϕT, p) then v is of the form ⟨λρ.u⟩p.
2
Proof:
Left as an exercise («, 3).
2
We next prove some lemmas about eﬀects. First, one can always enlarge the
eﬀect attributed to a term and obtain a derivable typing. Second, if a value can
be typed, then it can also be typed with an empty eﬀect; that is, evaluation of
values does not cause any observable eﬀects.
3.5.5
Lemma: If Γ ⊢t :ϕ T and ϕ ⊆ϕ′, then Γ ⊢t :ϕ′ T.
2
Proof:
Straightforward induction on the typing derivation.
2
3.5.6
Lemma: Let v be a value. If Γ ⊢v :ϕ T then Γ ⊢v :∅T.
2
Proof:
From Lemma 3.5.3 we get a derivation of Γ ⊢v :ϕ T that ends with
neither (RT-TInst) nor (RT-EInst). Therefore, the derivation must end with
one of the typing rules for values. By inspecting each of the rules (RT-Bool),
(RT-Clos), and (RT-RClos) for values we see that we can construct a deriva-
tion of Γ ⊢v :∅T (by choosing the eﬀect to be empty in each case).
2

3.5
The Tofte–Talpin Type System
119
Having established these basic lemmas we can now prove the lemmas lead-
ing to the type soundness result.
3.5.7
Lemma [Substitution]: If Γ, x1 : T1 ⊢t :ϕ T and Γ ⊢t1 :∅T1, then Γ ⊢
[x1 , t1]t :ϕ T.
2
Proof:
By induction on the typing derivation for t. The cases are all standard,
except for (RT-Var) where t = x1. By (RT-Var) itself, T = T1 and since [x1 ,
t1]x1 = t1, the second assumption combined with Lemma 3.5.5 gives us the
desired derivation.
2
3.5.8
Proposition [Subject Reduction]: If Γ
⊢
t
:ϕ
T and t
RAL
-→
t′ then
Γ ⊢t′ :ϕ T.
2
Proof:
By induction over the typing derivation.
The rules (RT-Var), (RT-Bool), (RT-Clos), and (RT-RClos) cannot occur;
these rules require t to have a shape that makes t
RAL
-→t′ impossible.
The cases for the rules (RT-Abs) and (RT-RAbs) are immediate; the evalua-
tion step must be by rule (RE-Clos) or (RE-RClos), and we can immediately
construct typings for the reduct using (RT-Clos) or (RT-RClos).
For the rule (RT-If), use case analysis on the last step in the derivation of
t
RAL
-→t′. The only possibilities are (RE-If), (RE-IfTrue), and (RE-IfFalse). In the
two latter cases, t′ is one of the branches of the conditional, and the sought-
for conclusion is already one of the premises of (RT-If). In the case of (RE-If),
use the induction hypothesis on the typing of the condition; by reusing the
existing typing derivations for the branches, we can produce a typing for t′
using (RT-If) again.
For the rule (RT-App), again use case analysis on the derivation of t
RAL
-→
t′. The possible rules are now (RE-App1), (RE-App2), and (RE-Beta). The two
former are analogous to (RE-If) above, so consider (RE-Beta). The term t must
be of the form ⟨λx.tb⟩ρ v, and the premises to (RT-App) are (1) Γ ⊢⟨λx.tb⟩ρ :ϕ
(T′ →ϕ′T, ρ) and (2) Γ ⊢v :ϕ T′, where further ρ ∈ϕ and ϕ′ ⊆ϕ. Now,
⟨λx.tb⟩ρ is a value and thus by Lemma 3.5.3 there exists a derivation of (1)
ending with (RT-Clos) which must include a (sub-)derivation of (3) Γ, x : T′ ⊢
tb :ϕ′ T. Applying ﬁrst Lemma 3.5.6 to (2) yields Γ ⊢v :∅T′ and then applying
Lemma 3.5.7 to (3) above and this, we get a derivation of Γ ⊢[x , v]tb :ϕ′ T
as required because ϕ′ ⊆ϕ and we can enlarge the eﬀect (Lemma 3.5.5).
For the rule (RT-Fix), the reduction must be by (RE-Fix) or (RE-FixBeta).
Again, the case for (RE-Fix) is analogous to (RE-If), so assume (RE-FixBeta).
The term t must be of the form fix x.v and the typing derivation has a sub-
derivation of (1) Γ, x : T ⊢v :ϕ T. First, apply Lemma 3.5.6 to get Γ, x : T ⊢v :∅
T and use this and (RT-Fix) to construct a derivation of (2) Γ ⊢fix x.v :∅T.
Now, Lemma 3.5.7 applied to (1) and (2) yields Γ ⊢[x , fix x.v]v :ϕ T.

120
3
Eﬀect Types and Region-Based Memory Management
For the rule (RT-RApp), the reduction must be by (RE-RApp) (similar to
the other context rules above) or (RE-RBeta). The term t must be of the
form ⟨λρ1.u⟩ρ [[p]], and the typing derivation has a sub-derivation of (1)
Γ ⊢⟨λρ1.u⟩ρ :ϕ (Πρ1.ϕ′T′, ρ) where further ρ ∈ϕ, [ρ1 , p]ϕ′ ⊆ϕ, and T =
[ρ1 , p]T′. Now, ⟨λρ1.u⟩ρ is a value and thus by Lemma 3.5.3 there exists a
derivation of (1) ending with (RT-RClos) which must include a sub-derivation
of (2) Γ ⊢u :ϕ′ T′ where ρ1 ̸∈frv(Γ). Applying Lemma 3.5.2 to (2) and
[ρ1 , p], we get a derivation of [ρ1 , p]Γ ⊢[ρ1 , p]u :[ρ1,p]ϕ′ [ρ1 , p]T′ as
required because [ρ1 , p]Γ = Γ (since ρ1 ̸∈frv(Γ)), [ρ1 , p]ϕ′ ⊆ϕ which we
can enlarge (Lemma 3.5.5), and T = [ρ1 , p]T′.
For the rule (RT-New), t reduces by (RE-New) or (RE-Dealloc). Only the
latter case is interesting. The term t must be of the form new ρ.v and the
typing derivation must include a derivation of Γ ⊢v :ϕ,ρ T where ρ ̸∈frv(Γ, T).
Then, by Lemma 3.5.6 we have Γ ⊢v :∅T. Applying Lemma 3.5.2 we thus get a
derivation of [ρ , •]Γ ⊢[ρ , •]v :[ρ,•]∅[ρ , •]T, that is Γ ⊢[ρ , •]v :∅T
(since ρ ̸∈frv(Γ, T)). Now use Lemma 3.5.5 to recover the original eﬀect ϕ.
For the rule (RT-TGen) (the case for rule (RT-EGen) is analogous) we have
a derivation of Γ ⊢t :ϕ T′ where X ̸∈ftv(Γ) and T = ∀X.T′. Apply the in-
duction hypothesis to this to get Γ ⊢t′ :ϕ T′. Since still X ̸∈ftv(Γ) we can
use (RT-TGen) to construct a derivation of Γ ⊢t′ :ϕ T where T = ∀X.T′ as
required.
For the rule (RT-TInst) (the case for rule (RT-EInst) is analogous) we have
a derivation of Γ ⊢t :ϕ ∀X.T′ where T = [X , T′′]T′ for some T′′. Again apply
the induction hypothesis to this and get Γ ⊢t′ :ϕ ∀X.T′ and use (RT-TInst)
to construct a derivation of Γ ⊢t′ :ϕ T where T = [X , T′′]T′ as required.
2
3.5.9
Proposition [Progress]: If ∅⊢t :ϕ T and • ̸∈ϕ, then either t is a value or
there is some t′ such that t
RAL
-→t′.
2
Proof:
By induction over the typing derivation of ∅⊢t :ϕ T.
If the last rule in the derivation is (RT-TGen), (RT-EGen), (RT-TInst), or
(RT-EInst), the conclusion follows directly from the induction hypothesis
(since the typing context remains empty and the eﬀect remains the same in
each premise). For example, for (RT-TGen) we have a derivation of ∅⊢t :ϕ T′
where T = ∀X.T′. Applying the induction hypothesis to this we get that either
t is a value, or there exists some t′ such that t
RAL
-→t′ as required.
The case (RT-Var) is impossible (since Γ is empty by assumption).
The cases for (RT-Bool), (RT-Clos), and (RT-RClos) are immediate.
For (RT-Abs) and (RT-RAbs), there are immediate reductions by (RE-Clos)
or (RE-RClos), respectively.
For (RT-Fix): If u in fix x.u is a value v then (RE-FixBeta) applies and we
have a reduction. If u is an abstraction or a region abstraction, then it itself

3.5
The Tofte–Talpin Type System
121
reduces (by either (RE-Clos) or (RE-RClos)), and we obtain a reduction by
(RE-Fix). This exhausts the possible syntactic forms of a non-value u.
For (RT-App), t is an application t0 t1, and we we have derivations of ∅⊢
t0 :ϕ (T1 →ϕ2T, p) and ∅⊢t1 :ϕ T1 for some p ∈ϕ and ϕ2 ⊆ϕ. Apply
the induction hypothesis to each of these. This either gives a reduction for at
least one of them (in which case we can reduce t by (RE-App1) or (RE-App2)),
or shows that t1 and t2 are both values. In this latter case, by Lemma 3.5.4, t0
must have the form

λx0.t′
0

p. Now we can apply the (RE-Beta) rule to obtain
a reduction, because p ∈ϕ cannot be • and so must be a region variable.
The cases for (RT-RApp) and (RT-If) are similar, but simpler.
For (RT-New), t is new ρ.t1, and we have a derivation of ∅⊢t1 :ϕ,ρ T.
Since ρ is (by deﬁnition) not •, the induction hypothesis applies to t1. We get
that either t1 is a value, in which case we get a reduction using (RE-Dealloc),
or t1 reduces to another term t′
1, in which case we get a reduction using
(RE-New).
2
3.5.10
Theorem: If ∅⊢t :∅T, then either (1) there is some value v such that
t →∗v and ∅⊢v :∅T, or (2) for each t′ such that t →∗t′ there is some t′′
such that t′ →+ t′′.
2
Proof:
Straightforward consequence of Propositions 3.5.8 and 3.5.9.
2
3.5.11
Corollary [Type soundness]: If ∅⊢t :∅bool, then it is not the case that
evalR(t) = wrong.
2
Extensions
The region-annotated language that we have presented only has Booleans
and functions, but it is straightforward to add most other common types of
data to it. As an example, in Figure 3-9 we give the necessary rules for ex-
tending the system with lists. The proofs of the metaproperties (in particular
type soundness and conditional correctness) carry through to this extended
system without any changes to the existing cases.
Rule (RT-Cons) implies that when adding a new element in front of a list,
it must have the same type as the elements already there. That is hardly
surprising, but note that it implies that the region part of the type must also
be the same. Thus, the diﬀerent elements of a list are always allocated in the
same region and therefore will be deallocated at the same time. If a single
element of the list turns out to have a long lifetime, the region type system
propagates that long lifetime to all the other elements!
3.5.12
Exercise [Recommended, ««, 3]: Using Figure 3-9 as a guideline, write rules
to extend the system with one or more of: Let bindings (a lambda abstraction

122
3
Eﬀect Types and Region-Based Memory Management
New syntactic forms
t
::=
. . .
terms:
(t :: t) at p
list constructor
case t0 of
nil⇒t1
(x::x′)⇒t2
case on lists
v
::=
. . .
values:
⟨v :: v⟩p
cons cell
nil
empty list
T
::=
. . .
types:
(T list, p)
type of lists
New erasure rules
∥nil∥
=
nil
∥(t1 :: t2) at p∥
=
∥t1∥:: ∥t2∥
⟨t1 :: t2⟩p

=
∥t1∥:: ∥t2∥
case t0 of
nil⇒t1
(x::x′)⇒t2

=
case ∥t0∥of
nil⇒∥t1∥
(x::x′)⇒∥t2∥
New evaluation rules
t
RAL
-→t′
t1
RAL
-→t′
1
(t1 :: t2) at p
RAL
-→(t′
1 :: t2) at p
(E-Cons1)
t2
RAL
-→t′
2
(v1 :: t2) at p
RAL
-→(v1 :: t′
2) at p
(E-Cons2)
(v1 :: v2) at ρ
RAL
-→⟨v1 :: v2⟩ρ (E-ConsAlloc)
t0
RAL
-→t′
0
case t0 of nil ⇒t1 | (x :: x′) ⇒t2
-→case t′
0 of nil ⇒t1 | (x :: x′) ⇒t2
(E-Case)
case nil of nil ⇒t1 | (x :: x′) ⇒t2
RAL
-→t1
(E-CaseNil)
case ⟨v :: v′⟩ρ of nil ⇒t1 | (x :: x′) ⇒t2
-→[x′ , v′][x , v]t2
(E-CaseCons)
New typing rules
Γ ⊢t :ϕ T
Γ ⊢nil :ϕ (T list, p)
(RT-Nil)
Γ ⊢t1 :ϕ T
Γ ⊢t2 :ϕ (T list, p)
p ∈ϕ
Γ ⊢(t1 :: t2) at p :ϕ (T list, p)
(RT-Cons)
Γ ⊢v1 :ϕ T
Γ ⊢v2 :ϕ (T list, p)
Γ ⊢⟨v1 :: v2⟩p :ϕ (T list, p)
(RT-ConsCell)
Γ ⊢t0 :ϕ T′
T′ = (T list, p)
p ∈ϕ
Γ ⊢t1 :ϕ T′′
Γ, x : T, x′ : T′ ⊢t2 :ϕ T′′
Γ ⊢case t0 of
nil⇒t1
(x::x′)⇒t2 :ϕ T′′
(RT-Case)
Figure 3-9: Extending the system with a list type
allocates a closure on the heap, so a let binding cannot simply be simulated as
a β-redex); pairs and records; sums and variants; and general recursive types
(equi- or iso-). Verify that the Conditional Correctness and Type Soundness
theorems still hold for your rules.
2
3.5.13
Exercise [««««]: References can be added easily to the type system with
rules like
Γ ⊢t :ϕ T
p ∈ϕ
Γ ⊢ref t at p :ϕ (T ref, p)
(RT-Ref)
Γ ⊢t :ϕ (T ref, p)
p ∈ϕ
Γ ⊢!t :ϕ T
(RT-Deref)

3.6
Region Inference
123
Γ ⊢t :ϕ (T ref, p)
Γ ⊢t′ :ϕ T
p ∈ϕ
Γ ⊢t:=t′ :ϕ unit
(RT-Assign)
Of course, these rules need to be combined with the usual value restriction
on type and eﬀect polymorphism, as discussed on pages 335–336 in TAPL.
Which extensions to the semantics and soundness proofs are necessary for
proving these rules sound?
2
The typing rules presented in the above exercise correspond exactly to the
way updatable references are handled in the ML Kit. Observe that since the
(RT-Assign) rule demands equality between the type of the value stored in
the reference and the type of the new value, the rule forces the two values to
have the same lifetime. For long-lived references, such as those found with
container classes in object-oriented programs, this behavior is inadequate.
No better solution has, however, been proposed yet.
3.6
Region Inference
So far, we have said a lot about the region type system and how region-
annotated programs are supposed to be executed, but next to nothing about
where the region annotations come from.
One easy answer would be, “why, the programmer wrote them”—but alas,
this answer would not be easy for the programmer. Realistic programs usually
need quite a lot of region abstractions and applications in order to distribute
their data over several regions while still being region typable, and it is not
always obvious exactly where they should be put. While it just might be possi-
ble to write a nontrivial well-typed program in the region-annotated language,
it would be quite impossible to maintain it.
Thus, the idea of using a region type system to check the safety of re-
gion annotations goes hand in hand with the idea that the region annotations
themselves are the product of an automatic compile-time analysis. The hu-
man programmer writes a program t in BL, whereupon the compiler will con-
struct a region-annotated program t′ such that ∥t′∥= t and t′ is well-typed
in RTL. This process is known as region inference, because Tofte and Talpin
(1994) viewed it as akin to a type reconstruction (“inference”) problem.
3.6.1
Exercise [Recommended, «]: One can easily formulate a trivial region infer-
ence: Just choose a single ﬁxed ρ, annotate each lambda abstraction (and
other allocating expressions) in the input program with “at ρ,” and then
wrap the entire program in a single new construction. This evidently always
produces a region-annotated program that erases to the input program, but
will it always be RTL-typable?
2

124
3
Eﬀect Types and Region-Based Memory Management
Of course, the trivial region inference is worthless from a memory-mana-
gement point of view. It produces a region-annotated program that never
deallocates anything until the entire computation is ﬁnished. What we want
is the opposite: region annotations that deallocate data as soon as allowed
by the region type system. Unfortunately it is not known whether “best pos-
sible region annotations” in this sense always exist, but good approximate
solutions are available.
The articles by Tofte and Talpin (1994, 1997) do not themselves present
an algorithm for region inference, but the nondeterministic region inference
system they present has evidently been constructed with an inference algo-
rithm in mind. The inference algorithm was published by Tofte and Birkedal
(1998). We do not have the space to describe it in detail, but instead show
how it works in the context of an example. Consider the term
letrec m(f) = if f(0) then 0 else m(λx.f(x+1)) + 1
in m(λx.x=10)
Let us initially assume an that oracle has told us that the “correct” region-
polymorphic type scheme for m is
∀ϵ1, ϵ2.Πρ1, ρ2.{ρ2}((int →{ϵ1}bool, ρ1) →{ϵ2,ϵ1,ρ1}int, ρ2).
The driving force in the region inference algorithm is an attempt to construct
the RTL typing tree for the region-annotated program. The search proceeds
much like the familiar Algorithm W, unifying types as well as region variables
and eﬀect positions as we go. We don’t know yet what to do with typing-rule
premises of the form ρ ∈ϕ or ϕ ⊆ϕ′, so let us initially just collect them for
further processing.
By the time we have analyzed the subexpression m(λx.f(x+1)), the uni-
ﬁcation-based inference has built the typing tree shown in Figure 3-10. (For
bevity, we assume a primitive rule for adding one to an integer—it allows
concluding Γ ⊢t+1 :ϕ int from Γ ⊢t :ϕ int).
A set of collected eﬀect constraints are also shown on the ﬁgure. Luckily,
the eﬀect polymorphism in the oracle’s type scheme has a form that allows
the possible instantiations of the eﬀect ﬁelds in it to be descibed with subset
and inclusion constraints; in this case ϕ4 ⊆ϕ5 and ρ4 ∈ϕ5.
3.6.2
Exercise [«, 3]: Locate where in the proof tree the other collected constraints
come from.
2
Whenever we choose concrete substitutions for the symbols ϕ, ϕ3, ϕ4,
and ϕ5 that satisfy the constraints, we get a valid proof. What it is proof of
depends on the substitutions we choose for ϕ and ϕ3, because these eﬀect

3.6
Region Inference
125
...
Γ ⊢m [[ρ4, ρ5]] :ϕ ((int →ϕ4bool, ρ4) →ϕ5int, ρ5)
Γ ′ ⊢f :ϕ1 (int →ϕ3bool, ρ3)
Γ ′ ⊢x :ϕ4 int
Γ ′ ⊢x+1 :ϕ4 int
Γ ′ ⊢f(x+1) :ϕ4 bool
Γ ⊢(λx.f(x+1)) at ρ4 :ϕ (int →ϕ4bool, ρ4)
Γ ⊢m [[ρ4, ρ5]]((λx.f(x+1)) at ρ4) :ϕ int
where Γ is m : ∀ϵ1, ϵ2.Πρ1, ρ2.{ρ2}((int →{ϵ1}bool, ρ1) →{ϵ2,ϵ1,ρ1}int, ρ2), f : (int →ϕ3bool, ρ3) and
Γ ′ is Γ, x : int. Collected eﬀect constraints: ϕ4 ⊆ϕ5, ρ4 ∈ϕ5, {ρ5} ⊆ϕ, ϕ3 ⊆ϕ4, ρ3 ∈ϕ4, ρ4 ∈ϕ,
ϕ5 ⊆ϕ, ρ5 ∈ϕ.
Figure 3-10: A partially region-inferred proof tree
meta-variables occur in the conclusion. On the other hand, ϕ4 and ϕ5 do not
occur in the conclusion, so we can eliminate them from the constraint set and
simplify it to {ρ4 ∈ϕ, ρ5 ∈ϕ, ρ3 ∈ϕ, ϕ3 ⊆ϕ}. Much of (Tofte and Birkedal,
1998) is concerned with giving precise rules for such manipulations.
Observe now that the constaints imply that ρ4 and ρ5 must appear in the
eﬀect position of the concluding statement, but there is no reason for any
of them to appear in either the type or the environment. Therefore, we are
allowed to insert a new around the expression, and thus deallocate the closure
for m [[ρ4, ρ5]] as well as the one for λx.f(x+1) after the call returns. By doing
so, we make ρ4 and ρ5 invisible from outside the expression, so constraints
that mention them can be dropped from the constraint set. On the other
hand, ρ3 cannot be ﬁnished oﬀin this way yet, because it occurs (explicitly)
in the environment Γ.
The ﬁnal result of the analysis of the expression is thus the judgment
Γ ⊢new ρ4, ρ5.
 m [[ρ4, ρ5]]((λx.f(x+1)) at ρ4)

:ϕ int
plus the (simpliﬁed) constraint set {ρ3 ∈ϕ, ϕ3 ⊆ϕ}.
3.6.3
Exercise [««]: Why didn’t the region inference insert a new ρ5.· · · around
the subexpression (λx.f(x+1)) at ρ4?
2
The analysis of the rest of the body of m is unsurprising; it ends with
m : · · · , f : (int →ϕ3bool, ρ3) ⊢if f(0) then 0 else (· · · )+1 :ϕ int

126
3
Eﬀect Types and Region-Based Memory Management
and still with the same constraint set {ρ3 ∈ϕ, ϕ3 ⊆ϕ} (another copy of each
of these constraints was produced by the analysis of f(0)).
This gives the immediate type ((int →ϕ3bool, ρ3) →ϕint, ρ′) for m, where
ρ′ was added by the letrec construction itself. Since neither ρ3 nor ρ′ ap-
pears in the (empty) environment for letrec, we can abstract over them and
make them region parameters. Finally we can abstract over eﬀects by intro-
ducing an eﬀect variable for each eﬀect meta-variable in the simpliﬁed con-
straint set that is not connected to the environment by subset constraints.
In the eﬀect-polymorphic type, each ϕ position becomes the set of eﬀect
and region variables that must be in the eﬀect, according to the constraints.5
Thus the eﬀect abstraction simply encapsulates the (transitive closure of the)
simpliﬁed constraint set.
It turns out our oracle was right! The abstracted type of m is exactly what
it said it would be, with ϵ1 corresponding to ϕ3, ϵ2 to ϕ, ρ1 to ρ3, and ρ2 to
ρ′. Now the analysis of the body of the letrec is unsurprising; we get the
following region-annotated program:
letrec m[ρ1](f) =
if f(0) then 0
else new ρ4, ρ5.
 m [[ρ4]] at ρ5((λx.f(x+1)) at ρ4)

+ 1
in new ρ6, ρ7.
 m [[ρ6]] at ρ7((λx.x=10) at ρ6)

Where did the oracle get its prediction of m’s type from? Tofte and Birkedal
(1998) construct it by Mycroft iteration: First, m’s body is analyzed under the
optimistic assumption that m itself will have the type scheme
∀ϵ1, ϵ2.Πρ1, ρ2.{ρ2}((int →{ϵ1}bool, ρ1) →{ϵ2}int, ρ2)
that is, with no constraints at all between the various region and eﬀect parts
of polymorphic instances. If the type scheme constructed after the initial
iteration does not match (which in this case it doesn’t), a new iteration is
tried with the new type scheme as assumption, and so forth until a ﬁxpoint
is reached.
The trick, of course, lies in ensuring that a ﬁxpoint is eventually reached; it
might well be that it just produces a list of ever larger type schemes. The
original region inference algorithm (Tofte and Birkedal, 1998) solved this
problem by heuristically omitting certain opportunities for region and eﬀect
5. The way this is done in the published formulation of the algorithm includes considering
one eﬀect variable in each latent eﬀect to be special; it is called the handle and is the one that
corresponds to the entire eﬀect. The distinction between the handle and other eﬀect variables
is present in the original TT calculus even though it has no special role in the soundness and
correctness proofs.

3.7
More Powerful Models for Region-Based Memory Management
127
abstractions such that the iterative computation of a ﬁxpoint for the recursive
function’s type scheme could be guaranteed to terminate. The cost of this ap-
proach is that completeness fails: Example programs can be constructed for
which the region inference algorithm leads to region annotations that are not
the best possible.
Later Birkedal and Tofte (2001) rephrased the algorithm in terms of con-
straint solving. This reworked algorithm seems to be complete in the sense
that for any region-annotated term t that can be TT-typed, the inference algo-
rithm’s output on ∥t∥will have as least as good space behavior as t. However,
Birkedal and Tofte prove only a weaker “restricted completeness” result; full
completeness in the sense described here was not considered in the article.
Another restricted case with an easy region inference problem is known. It
is when the input program can be typed with ﬁrst order types, that is, such
that neither the argument nor the return type for any function includes a
function type itself. Then there is no reason to use eﬀect polymorphism, and
one never needs to generalize over region variables that appear only in latent
eﬀects. (For since there is only one arrow in each type, such a variable could
just as well have been discharged by a new within the lambda abstraction.)
These two facts lead to a bounded representation of the latent eﬀect: We
simply need to know for each of the p positions in the argument and return
types whether the actual p is in the latent eﬀect. That solves the termination
problem, and with a bit of ingenuity one does not even need ﬁxpoint iteration
for ﬁnding the best type scheme.
This principle has been used to derive a region inference for an adaptation
of the Tofte–Talpin system for a Prolog dialect which is naturally ﬁrst order;
see Makholm (2000, Chapter 10).
3.6.4
Exercise [«]: Why does eﬀect polymorphism not make sense in a ﬁrst-order
program?
2
3.7
More Powerful Models for Region-Based Memory Management
Unfortunately, even with region-polymorphic recursion, the Tofte–Talpin
model (as expressed either as RTL or the original TT) is not quite strong
enough to achieve reasonable object lifetimes. At fault is the very idea of
new—that the lifetime of a region must coincide with the time it takes to
execute some subexpression of the original program. To see how this is a
problem, let us look at how the Tofte-Talpin system treats the classic “Game
of Life” example. The task is to simulate a cellular automaton for n gen-
erations, starting from a speciﬁed state. This is a typical case of iterative

128
3
Eﬀect Types and Region-Based Memory Management
programming, and the problems we will discover are common for iterative
programs in general.
The standard way of programming an iteration in a functional language is
to use tail recursion:
let rec nextgen(g) =

read g; create and return new generation

let rec life(n,g) = if n=0 then g
else life(n-1,nextgen(g))
We shall leave the details of nextgen unspeciﬁed here and in the follow-
ing discussion. We assume, for simplicity, that a single region holds all the
pieces of a generation description, and, for the sake of the argument, that the
iteration count n needs to be heap-allocated, too.
The ordinary TT region inference algorithm annotates the Game of Life
example as follows:
letrec nextgen[ρ](g) =

read g from ρ; create new gen. at ρ

letrec life[ρn, ρg](n,g) =
if n=0 then g
else new ρ′
n
in life[ρ′
n, ρg]((n-1) at ρ′
n, nextgen[ρg](g))
There are two major problems here. First, the recursive call of life is not a
tail call anymore because it takes some work to deallocate a region at the end
of new. Therefore all the ρ′
n regions will pile up on the call stack during the it-
eration and be deallocated only when the ﬁnal result has been found. Second,
any typable region annotation of the program must let the nextgen function
construct its result in the same region that contains its input. This means
that the program has a serious space leak: all the intermediate-generation
data will be deallocated only when the result of the iteration is deallocated.
Both of these problems are caused by the fact that new aligns the lifetime
of its region with the hierarchical expression evaluation. Several solutions for
this have been proposed, but because their formal properties have not been
as thoroughly explored as the TT calculus, we will only present them brieﬂy.
Region Resetting in the ML Kit
The ML Kit’s region implementation (Birkedal et al., 1996; Tofte et al., 2001b)
is based on the TT system. Its solution to the tail recursion problem is based
on a concept of resetting a region, meaning that its entire contents are de-
allocated whereas the region itself continues existing.
After a TT region inference, a special storage-mode analysis (Birkedal, Tofte,
and Vejlstrup, 1996) that runs after region inference amends the region an-

3.7
More Powerful Models for Region-Based Memory Management
129
notations to control resetting: Each “at ρ” annotation gets replaced by either
“atbot ρ,” meaning ﬁrst reset the region and then allocate the new object as
the new oldest object in the region, or “attop ρ,” meaning allocate without
resetting the region.
With this system one can rewrite the original Life program as follows to
obtain better region behavior:
let rec copy(g) =

read g; make fresh copy

let rec life’((n,g) as p)
= if n=0 then p
else life’(n-1,copy(nextgen(g)))
let rec life(p) = snd (life’ (p))
where copy (whose body is omitted here for brevity) takes apart a genera-
tion description and constructs a fresh, identical copy. Region inference and
storage-mode analysis will then produce the region annotations
letrec nextgen[ρ, ρ′](g) =

read g from ρ; new gen. at ρ′
letrec copy[ρ′, ρ](g) =

read g from ρ′; fresh copy atbot ρ

letrec life’[ρn, ρg]((n,g) as p)
= if n=0 then p
else life’[ρn, ρg]((n-1) atbot ρn,
new ρ′
g
in copy[ρ′
g, atbot ρg]
(nextgen[ρg, ρ′
g](g)))
letrec life[ρn, ρg](p) = snd (life’[ρn, ρg](p))
Letting life′ return the entire p instead of just g forces region inference to
place all of the ns in ρn. A memory leak in ρn is prevented by the atbot
allocation, whose eﬀect is that the region ρn is reset prior to placing n-1 in it.
The memory leak in ρg is prevented with the introduction of the copy func-
tion. Now the new generation can be constructed in a temporary region ρ′
g
that gets deallocated before the recursive call; once the old generation is not
needed anymore, the new generation is copied into ρg with the atbot mode,
which frees the old generation. (The atbot annotation in the passing of the
region parameter serves to allow copy to actually reset the region; the need
for this extra annotation has to do with aliasing between region variables.)
The storage-mode analysis works by changing the region annotation for an
allocation to atbot if the value to be allocated is the only live value whose
type includes the region name, as determined by a simple local liveness anal-
ysis. Neither a formal deﬁnition of the storage-mode analysis nor a proof that
it is safe has appeared in the literature, but it is described brieﬂy by Birkedal,

130
3
Eﬀect Types and Region-Based Memory Management
Tofte, and Vejlstrup (1996), together with a number of other analyses that
the ML Kit uses to implement the region model eﬃciently.
This solution does make it possible for iterative computations to run in
constant space (assuming, in the Life example, that the size of a single g is
bounded), but it is by no means obvious that precisely these were the changes
one needed to make to the original unannotated program to improve the
space behavior. Furthermore, inserting such region optimizations in the pro-
gram impede maintainability because they obscure the intended algorithm.
Aiken–Fähndrich–Levien’s Analysis for Early Deallocation
Aiken, Fähndrich, and Levien (1995) extend the TT system in another direc-
tion, decoupling dynamic region allocation and deallocation from the intro-
duction of region variables with the new construct.
In the AFL system, entry into a new block introduces a region variable, but
does not allocate a region for it. During evaluation of the body of new, a re-
gion variable goes through precisely three states: unallocated, allocated, and
ﬁnally deallocated. After a TT region inference (and possibly also storage-
mode analysis as in the ML Kit), a constraint-based analysis—guided by a
higher-order data-ﬂow analysis for region variables—is used to insert explicit
region allocation [[alloc ρ]] and deallocation commands [[free ρ]] into the
program. Ideally the [[alloc ρ]] happens right before the ﬁrst allocation in
the region, and [[free ρ]] just after the last read from the region, but some-
times they need to be pushed farther away from the ideal placements because
the same region annotations on a function body must match all call sites.
With this system, the Life example can be improved by rewriting the origi-
nal program to
let rec copy(g) =

read g; make fresh copy

let rec life(n,g) = if n=0 then copy(g)
else life(n-1,nextgen(g)),
making the base case return a fresh copy of its input rather than the input
itself. This program is analyzed as6
letrec nextgen[ρ, ρ′](g)
= [[alloc ρ′]]

read g from ρ; new gen. at ρ′
[[free ρ]]
letrec copy[ρ, ρ′](g)
= [[alloc ρ′]]

read g from ρ; fresh copy at ρ′
[[free ρ]]
6. The syntax here is not identical with the one used by Aiken, Fähndrich, and Levien (1995);
for example, they write “free_after ρ t” for what we write as “t [[free ρ]].”

3.7
More Powerful Models for Region-Based Memory Management
131
letrec life[ρn, ρg, ρ′](n,g)
= if n=0
then [[free ρn]] copy[ρg, ρ′](g)
else new ρ′
n, ρ′
g
in life[ρ′
n, ρ′
g, ρ′]
([[alloc ρ′
n]] (n-1) at ρ′
n [[free ρn]],
nextgen[ρg, ρ′
g](g))
Because deallocation of each region is done explicitly and not by new, the
body of new is a tail call context, and the regions containing the old n and g
can be freed as soon as n-1 and nextgen(g) have been computed. Without
rewriting the original program this would not be the case, because a function
must either always free one of its input regions or never do it.
Imperative Regions: The Henglein–Makholm–Niss Calculus
Recently Henglein, Makholm, and Niss (2001) published a region system that
completely severs the connection between region lifetimes and expression
structures by eliminating the new construct. Instead, the region annotations
form an imperative sublanguage manipulating region handles asynchronously
with respect to the expression structure.
The HMN system does not, as the two previously sketched solutions, build
on top of the Tofte–Talpin model and its region inference algorithm; instead
it has its own region type system (proved sound by Niss, 2002) and inference
algorithm (Makholm, 2003). Starting anew means that the system is concep-
tually simpler while still incorporating the essential features of ML Kit-like
resetting and AFL-style early deallocation as special cases. On the other hand,
the theory has not yet been extended to higher-order functions.
In the HMN system it is possible to handle the Game of Life with no rewrit-
ing at all. A function can pass regions as output (indicated by o: below) as
well as receive them as input (indicated by i:); HMN region inference pro-
duces
letrec nextgen[i: ρ; o: ρ′](g)
= [[new ρ′]]

read g from ρ; new gen. at ρ′
[[release ρ]]
letrec life[i: ρn, ρg; o: ρ′](n,g)
= if n=0 then [[release ρn]] g [[ρ′ := ρg]]
else life[i: ρ′
n, ρ′
g; o: ρ′]
([[new ρ′
n]] (n-1) at ρ′
n [[release ρn]],
nextgen[i: ρg; o: ρ′
g](g))
where each iteration of life decides for itself whether to release the region
it gets as its second parameter or to return it back to the caller.

132
3
Eﬀect Types and Region-Based Memory Management
The [[ρ′ := ρg]] operation serves the same purpose as the copy operation
in the AFL solution, but is very cheap at runtime—it just renames the region
that was previously called ρg to ρ′, whereupon it is returned to the caller.
The renaming of regions means that the region-annotated types of values
can change during the execution of the program. To manage that, the HMN
region type system is based around a typing judgment with the shape
Ψ ⊢{∆1; Γ1} t : T {∆2; Γ2}
where the contexts Γ1 and Γ2 describe the types of the local variables before
and after t is evaluated. The sets of region variables Ψ, ∆1, and ∆2 describe
the available region variables.
Other advanced features of the HMN system include reference-counted re-
gions with a linear type discipline for region handles, “constant” region pa-
rameters that correspond to the region abstraction of the Tofte–Talpin model,
and a subtyping discipline for regions that allows extensive manipulation of
dangling pointers.
Other Models
A number of more powerful region models and associated region type sys-
tems have been proposed without an accompanying inference algorithm.
Walker, Crary, and Morrisett (2000) have developed a region model with a
region type-system for a continuation-passing style language, intended to be
used for translating the Tofte–Talpin execution model to certiﬁed machine
code. To handle the CPS transformation of region abstractions, a very ad-
vanced type system with bounded quantiﬁcation over regions and eﬀects was
necessary. The ﬁnal system is much stronger than the Tofte–Talpin system it-
self, but little is known about how to make automatic region inference utilize
this extra strength.
Walker and Watkins (2001) have developed a region type system in which
region references can be stored in data structures such as lists. They are still
not completely ﬁrst class, because they must have linear types (see Chap-
ter 1), but the system is strong enough to reason about heterogeneous lists
(i.e., lists whose elements are allocated in diﬀerent regions).
Another, more restricted, way of allowing heterogeneous structures is found
in the system (Grossman et al., 2002). Cyclone employs a kind of subtyping
on region lifetimes and a simpler notion of eﬀects: A region variable ρ out-
lives another region variable ρ′ if the lifetime of ρ encompasses the lifetime
of ρ′. In that event, a value allocated in the region denoted by ρ can safely be
used instead of the same value allocated in the region denoted by ρ′. Cyclone
supports subtyping of values according to this principle.

3.8
Practical Region-Based Memory Management Systems
133
3.8
Practical Region-Based Memory Management Systems
The ML Kit
The ML Kit7 essentially implements the theory described in §3.4 to §3.6 with
two important extensions: ﬁrst, it includes region resetting and storage-mode
analysis as described in §3.7, and, second, it includes a multiplicity inference
allowing the compiler to allocate ﬁnite regions on the runtime stack (Birkedal,
Tofte, and Vejlstrup, 1996). The multiplicity analysis is a type-based analy-
sis that determines, whether each region is ﬁnite or inﬁnite. A ﬁnite region
is one into which the analysis can determine that only one value will ever
be written; all other regions are inﬁnite. The importance of ﬁnite regions is
that they can be stack-allocated since it is known in advance how large they
are. Furthermore, since regions in the Tofte and Talpin region language fol-
low a stack-discipline aligned with the expression structure of the program,
such regions can even be allocated on the normal runtime stack, giving a par-
ticularly simple, eﬃcient implementation. The latest incarnation of the ML
Kit even includes a garbage collector (Hallenberg, Elsman, and Tofte, 2002),
which is useful in situations where it is not practical to make a program more
region friendly. See Tofte et al. (2001b) for a comprehensive introduction to
programming with regions in the ML Kit, and Tofte et al. (2001a) for a survey
of the interplay between theory and practice in the ML Kit.
Cyclone
Cyclone,8 a dialect of C designed to prevent safety violations, uses regions
both as a memory management discipline and as a way to guarantee safety
(through type soundness). Cyclone includes three kinds of regions: a single
global (or heap) region; stack regions (corresponding to stack frames allo-
cated from statement blocks); and dynamic regions (corresponding to our
lexically scoped regions).
Instead of having eﬀect variables as in the Tofte and Talpin system, Cyclone
uses an operator on types (with no operational signiﬁcance). The regions_of
operator represents the region variables that occur free in a type; the cru-
cial trick is that the regions_of operator applied to a type variable is sim-
ply left abstract until the type variable is instantiated. Intuitively, instead of
propagating the eﬀect of functional arguments via eﬀect variables, they are
propagated via the regions_of operator. Returning to the map example on
7. http://www.it-c.dk/research/mlkit
8. http://www.cs.cornell.edu/projects/cyclone/

134
3
Eﬀect Types and Region-Based Memory Management
page 115 we get the following Cyclone type for map:
∀α, β.(α →β) × (α list, ρ) →{ρ,ρ′}∪regions_of(α→β)(β list, ρ′).
For practical reasons, a major aspect in the design of Cyclone was to make
it easy for C programmers to write Cyclone applications and to port legacy
C code to Cyclone. In particular, requiring programmers to write region-
annotations as seen in the present chapter is out of the question. Cyclone
addresses this by combining inference of region annotations with defaults
that work in many cases.
Cyclone began as a compiler for producing typed assembly language (see
Chapter 4) and as such can be seen as one way to realize proof-carrying code
(see Chapter 5). The region aspects of Cyclone are described by Grossman
et al. (2002); a system overview is given by Jim et al. (2002).
Other Systems
The ML Kit and Cyclone are both mature systems. Several research proto-
types demonstrating various principles for region-based memory manage-
ment have been described in the literature.
One trend has been to adapt Tofte and Talpin’s system (and its spirit) to
other languages. Christiansen and Velschow (1998) describe RegJava, which
is a simple, region-annotated core subset of Java and an accompanying im-
plementation. Makholm and Sagonas (2002) extend a Prolog compiler with
region-based memory management and region inference based on Henglein,
Makholm, and Niss (2001).
Another trend has been to vary the fundamental assumption that regions
should be allocated and deallocated according to a stack-discipline. In this di-
rection the present authors have constructed a prototype implementation of
the system of Henglein et al. (2001) for a small functional language with func-
tion pointers (but not lexical closures containing free variables). Cyclone can
also be seen as the practical realization of some of the ideas in the Calculus
of Capabilities (Walker, Crary, and Morrisett, 2000).
Finally, region-based memory management without the memory safety guar-
antees oﬀered by region types has a long history. The basic idea, of gaining
extra eﬃciency by bulk allocations and deallocations, is certainly natural. Sys-
tems using region-like abstractions for their memory management date as far
back as 1967 (Ross, 1967; Schwartz, 1975; Hanson, 1990). In contrast to these
special purpose region abstractions, the GNU C Library provides an abstrac-
tion, called obstacks, to application programmers (GNU, 2001).
Also in this line of work is Gay and Aiken’s RC compiler translating re-
gion annotated C programs to ordinary C programs with library support for

3.8
Practical Region-Based Memory Management Systems
135
regions (2001). At runtime, each region is equipped with a reference count
keeping track of the number of (external) references to objects in the region.
The operation for deleting a region can then ﬂag instances that attempt to
delete a region with non-zero reference count. A type system provides the
compiler the opportunity to remove some of the reference count operations,
but it does not guarantee memory safety as the type systems discussed in
this chapter do.


P a r t I I
Types for Low-Level Languages


Types for Low-Level Languages
the next two chapters explore a number of techniques that can be used to
extend high-level typing ideas to programs written in low-level languages.
This problem is interesting for a number of reasons. It seems natural to as-
sume that low-level code obtained by compiling well-typed high-level pro-
grams should have the same semantics and similar typing properties. Yet, it
is not immediately clear how to write a type-checker for low-level programs.
Type checking is a convenient way to ensure that a program has certain
semantic properties, such as memory safety. Type checking has gained ac-
ceptance as a major component of the security infrastructure in distributed
systems that share code between hosts that do not trust each other. No-
table examples are the Java Virtual Machine (JVM) (Lindholm and Yellin, 1997)
and the Microsoft Common Language Infrastructure (CLI) (Gordon and Syme,
2001; Gough, 2002), both of which feature type checkers for intermediate
languages used for the distribution of code in distributed systems. Such dis-
tribution schemes rely on low-level languages in order to delegate to the un-
trusted code producer most or all of the compilation eﬀort, and to reduce or
eliminate the need for a trusted compiler on the receiving side. This strategy
also has the potential to give the code producer some ﬂexibility in the choice
of the high-level language in which the development of the code takes place.
The distribution of untrusted mobile code is the main scenario that we will
use to guide our design choices. We refer to a system that receives and exe-
cutes untrusted code as a host and to the untrusted code itself as an agent.
Hosts want to have strong guarantees about the safety of the agent’s exe-
cution. Probably the most basic guarantee is memory safety, which ensures
that the agent does not attempt to dereference memory addresses to which it
has not been given access. But often hosts need to have stronger guarantees,
such as type safety with respect to a certain type system, or bounded execu-

140
Types for Low-Level Languages
tion and resource usage, or proper use of the provided APIs. We shall start
to address the memory safety and type safety aspects ﬁrst and then show
how the techniques that we develop can be applied to more complex safety
polices.
It is worth pointing out that, in the absence of type checking, alternative
mechanisms for ensuring the memory safety of untrusted code are based on
coarse-grained memory protection, enforced either by hardware or by soft-
ware. Hardware memory protection is used when the untrusted code is run
in a separate address space. A software equivalent is software fault isola-
tion (SFI) (Wahbe et al., 1993), in which the untrusted code is instrumented
with run-time checks that prevent memory accesses outside a pre-conﬁgured
memory range. In both of these cases, the communication between the un-
trusted code and the host system is expensive because it must involve copy-
ing of data into the untrusted-code address space.
Most of the challenges in typing low-level languages arise because we can-
not abstract details of how high-level features are implemented. In JVM and
CLI, these problems are attenuated by keeping in the intermediate language
the most troublesome high-level features, such as exceptions and dynamic
dispatch.
In these two chapters, we examine instead an extreme situation, in which
the untrusted code is written in assembly language. Correspondingly, the
type system must be more expressive than would be necessary for similar
programs written in a high-level language. In essence, a type checker for a
low-level language veriﬁes not only the well-typedness of the corresponding
high-level constructs but also that the construct has been compiled correctly.
Most of the mechanisms that we’ll need can be expressed using types. Indeed,
Chapter 4 describes a type system that is appropriate for assembly language.
Since such a large part of low-level type checking is closer to program veriﬁca-
tion than type checking, we use in Chapter 5 a method based on logic. Besides
being an instructive alternative presentation of type systems and type check-
ing, that approach will allow us to move seamlessly beyond type checking
and into checking more complex properties of the untrusted code.

4
Typed Assembly Language
Greg Morrisett
How can we ensure that when we download some code that the code will not
do something “bad” when we execute it? One idea is to leverage the principle
of proof-carrying code introduced by Necula and Lee. The principle of PCC is
that we can eliminate the need to trust a piece of code by requiring a formal,
machine-checkable proof that the code has some desired properties. The key
insight is that checking a proof is usually quite easy, and can be done with a
relatively small (and hence trustworthy) proof-checking engine.
If we are to eﬀectively use PCC to build trustworthy systems, then we must
solve two problems:
1. What properties should we require of the code?
2. How do code producers construct a formal proof that their code has the
desired properties?
The ﬁrst question is extremely context and application dependent. It requires
that we somehow rule out all “bad” things without unduly restricting “good”
things, and make both “bad” and “good” formal. The second question is im-
possible to solve automatically for arbitrary code assuming non-trivial safety
properties. So, how are we to take advantage of PCC?
One approach is based on type-preserving compilation. The idea here is to
focus on some form of type safety as the desired property. The advantage
of focusing on type safety is that programmers are willing to do the hard
part—construct a proof that some code is type-safe. The way they do this is
by writing the code in a high-level language (e.g., Java or ML). If the source
they write doesn’t type-check, then they rewrite the code until it does. In this
respect, they are engaging in a form of interactive theorem proving.
Once the initial proof is done, a type-preserving compiler takes over, map-
ping the type-safe source code through a series of successively lower-level

142
4
Typed Assembly Language
intermediate languages to target code. As it transforms the code, it also (con-
ceptually) transforms the proof. It is usually much easier to do this sort of
transformation than to prove type safety directly on the generated code.
Of course, such a methodology demands that as part of the compilation
process, we design a series of typed intermediate languages, culminating with
typed machine code. Intermediate languages such as the Java Virtual Machine
Language (JVML) and Microsoft’s Common Language Infrastructure (CLI) are
targets of type-preserving compilers for a number of high-level languages,
including Java, C#, and ML.
However, both the JVM and CLI are relatively high-level “CISC-like” abstract
machines. That is, they have pre-conceived notions of methods and objects
which may be incompatible with an eﬃcient encoding for a given language.
For instance, the JVM does not support tail-calls, making the implementation
of functional languages impractical. The CLI does support tail-calls, but there
are other features that it lacks. For instance, arrays are treated as covariant
in the type system, and thus require a run-time check upon update.
Of course, there will never be a universal, portable typed intermediate lan-
guage (TIL) that supports all possible languages and implementation strate-
gies. Nonetheless, we seek a principled approach to the design of TILs that
minimizes the need to add new features and typing rules. In particular, we
seek a more “RISC-like” design for type systems that makes it possible to en-
code high-level language features and to support a variety of optimizations.
4.1
TAL-0: Control-Flow-Safety
We begin our design for a “RISC”-style typed assembly language by focus-
ing on one safety property, known as control-ﬂow safety. Informally, we wish
to ensure that a program does not jump to arbitrary machine addresses
throughout its execution, but only to a well-deﬁned subset of possible entry
points. Control-ﬂow safety is a crucial building block for building dynamic
checks into a system. For instance, before performing a system call, such
as a ﬁle read, we might need to check that the arguments to the call have
the right properties (e.g., the ﬁle has been opened for reading and the des-
tination buﬀer is suﬃciently large.) Without control-ﬂow safety, a malicious
client could jump past these checks and directly into the underlying routine.
A focus on control-ﬂow safety will also let us start with an extremely simple
abstract machine and demonstrate the key ideas of adapting a type system
to machine code. In subsequent sections, we will expand this machine and its
type system to accommodate more features.
The syntax for our control-ﬂow-safe assembly language, which we will call
TAL-0, is given in Figure 4-1. We assume a ﬁxed set of k general-purpose

4.1
TAL-0: Control-Flow-Safety
143
r
::=
registers:
r1 | r2 | · · · | rk
v
::=
operands:
n
integer literal
ℓ
label or pointer
r
registers
ι
::=
instructions:
rd:=v
rd:=rs+v
if r jump v
I
::=
instruction sequences:
jump v
ι; I
Figure 4-1: Instructions and operands for TAL-0
registers and a few representative instructions based on a subset of MIPS
assembly language. To keep the language readable, we use a somewhat more
familiar notation for instructions than the usual cryptic “mov,” “add,” etc.
Intuitively, each instruction uses the value in a source register (rs) and an
operand to compute a value which is placed in the destination register (rd).
In this setting, an operand is either another register, a word-sized immediate
integer,1 or a label. We use “value” to refer to an operand that is not a register.
For our purposes, it is also useful to deﬁne instruction sequences (I) as lists
of instructions terminated by an explicit, unconditional control transfer (i.e., a
jump). Of course, when the assembly code is mapped down to machine code,
jumps to adjacent blocks can be eliminated since the code will fall through.
We could make the order of instruction sequences and hence fall-throughs
explicit, but we prefer a simpler, more uniform assembly language to present
the key ideas.
Here is an example TAL-0 code fragment that computes the product of
registers r1 and r2, placing the ﬁnal result in r3 before jumping to a return
address assumed to be in r4.
prod: r3 := 0;
// res := 0
jump loop
loop: if r1 jump done; // if a = 0 goto done
r3 := r2 + r3;
// res := res + b
r1 := r1 + -1;
// a := a - 1
jump loop
done: jump r4
// return
1. As we are dealing with an assembly language, we ignore the issue of ﬁtting a full word-sized
integer into a single instruction.

144
4
Typed Assembly Language
R
::=
register ﬁles:
{r1 = v1, . . . , rk = vk}
h
::=
heap values:
I
code
H
::=
heaps:
{ℓ1 = h1, . . . , ℓm = hm}
M
::=
machine states:
(H, R, I)
Figure 4-2: TAL-0 abstract machine syntax
We model evaluation of TAL-0 assembly programs using a rewriting rela-
tion between abstract machine states. Rather than model the execution of
a concrete machine, we use a higher-level representation for machine states
which maintains certain distinctions. For instance, in a real machine, labels
are resolved during program loading to some machine address which is also
represented as an integer. In our abstract machine, we maintain the distinc-
tion between labels and arbitrary integers because this will allow us to easily
state and then prove our desired safety property—that any control ﬂow in-
struction can only branch to a valid, labelled entry point. Indeed, our abstract
machine will get stuck if we try to transfer control to an integer as opposed
to a label. So, the problem of enforcing the safety property now reduces to
ensuring that our abstract machine cannot get stuck.
However, to support this level of abstraction, we must worry about the
situation where a label is added to an integer, or where a test is done on a
label. One possibility is to assume a coercion function intof which maps la-
bels to integers, and use intof(ℓ) whenever ℓappears as an operand to an
arithmetic instruction. Though a perfectly reasonable approach, there are a
number of reasons one might avoid it: First, it violates the abstraction that
we are attempting to provide which may lead to subtle information ﬂows.
In some security contexts, this could be undesirable. Second, such a coer-
cion would make it harder to prove the equivalence of two program states,
where labels are α-converted. In turn, this would restrict an implementation’s
freedom to re-arrange code or recycle its memory.2 Finally, it simpliﬁes the
type system if we simply treat labels as abstract. In particular, if we included
such a coercion, we would need some form of subtyping to validate the coer-
cion. However, we emphasize that it is possible to expose labels as machine
integers if desired.
The syntax for TAL-0 abstract machines is given in Figure 4-2. An abstract
machine state M contains three components: (1) A heap H which is a ﬁnite,
2. The problem can be avoided by assuming a coercion relation between labels and integers
that respects the alpha-equivalence class of labels.

4.1
TAL-0: Control-Flow-Safety
145
partial map from labels to heap values (h), (2) a register ﬁle R which is a total
map from registers to values, and (3) a current instruction sequence I. The
instruction sequence is meant to model the sequence of instructions pointed
to by the program counter in a concrete machine. One way to think of the
machine’s operation is that it pre-fetches sequences of instructions up to the
nearest jump whenever a control-transfer is made.
We consider heaps and register ﬁles to be equivalent up to re-ordering. We
also consider the labels in the domain of H to bind the free occurrences of
those labels in the rest of the abstract machine. Finally, we consider abstract
machine states to be equivalent up to alpha-conversion of bound labels.
The rewriting rules for TAL-0 are as follows:
H(ˆR(v)) = I
(H, R, jump v) -→(H, R, I)
(JUMP)
(H, R, rd:=v; I) -→(H, R[rd = ˆR(v)], I)
(MOV)
R(rs) = n1
ˆR(v) = n2
(H, R, rd:=rs+v; I) -→(H, R[rd = n1 + n2], I)
(ADD)
R(r) = 0
H(ˆR(v)) = I′
(H, R, if r jump v; I) -→(H, R, I′)
(IF-EQ)
R(r) = n
n ≠0
(H, R, if r jump v; I) -→(H, R, I)
(IF-NEQ)
The rules make use of ˆR which simply lifts R from operating on registers to
operands:
ˆR(r) = R(r)
ˆR(n) = n
ˆR(ℓ) = ℓ
Notice that for jump and a successful if-jump we simply load a new instruc-
tion sequence from the heap and begin executing it. Of course, this assumes
that the destination operand evaluates to some label ℓ(as opposed to an in-
teger), and that the heap provides a binding for ℓ. Otherwise, the machine
cannot make the transition and becomes stuck. For instance, if we attempted
to evaluate jump 42, then no transition could occur. In other words, if we can
devise a type system that rules out such stuck machine states, then we can
be assured that all control transfers must go to properly labelled instruction
sequences.
Of course, there are other ways this particular abstract machine can get
stuck. For instance, if we attempt to add an integer to a label, or test a label

146
4
Typed Assembly Language
using if, then the machine will get stuck. This reﬂects our choice to leave
labels abstract.
4.1.1
Exercise [«, 3]: Taking H to be a heap that maps the labels prod, loop,
and done to their respective instruction sequences above, and taking R0 =
{r1=2,r2=2,r3=0,r4=exit} where exit is some unspeciﬁed label, show
that (H, R0, jump prod) steps to a state (H, R, jump r4) with R(r3) = 4.
2
4.1.2
Exercise [Recommended, «««, 3]: Build an interpreter for the TAL-0 ab-
stract machine in your favorite programming language.
2
4.1.3
Exercise [«««, 3]: Formulate a semantics for a concrete machine based on
the TAL-0 instruction set. The concrete machine should manipulate only in-
tegers and have states of the form (M, R, pc) where M is a memory mapping
32-bit integers to 32-bit integers, R is a register ﬁle, and pc holds a 32-bit in-
teger for the next instruction to execute. You should assume an isomorphism
encode and decode that maps instructions to and from distinct integers.
Then, prove that the TAL-0 abstract machine is faithful to the concrete
machine by establishing a simulation relation between abstract and concrete
machine states and by showing that this relation is preserved under evalua-
tion.
2
4.2
The TAL-0 Type System
The goal of the type system for TAL-0 is to ensure that any well-formed ab-
stract machine M cannot get stuck—that is, there always exists an M′ such
that M -→M′. Obviously, our type system is going to have to distinguish la-
bels from integers to ensure that the operands of a control transfer are labels.
But we must also ensure that, no matter how many steps are taken by the ab-
stract machine, it never gets into a stuck state (i.e., typing is preserved.) Thus,
when we transfer control to a label, we need to know what kinds of values it
expects to have in the registers.
To this end, we deﬁne our type syntax in Figure 4-3. There are four basic
type constructors. Obviously, int will be used to classify integer values and
code types will classify labels. Furthermore, code(Γ) will classify those labels
which, when jumped to, expect to have values described by Γ in the associated
register. Here, Γ is a register ﬁle type—a total function from registers to types.
In this respect, we can think of a label as a continuation which takes a record
of values described by Γ as an argument.
We also support universal polymorphism in TAL-0 through the addition of
type variables (α) and quantiﬁed types (∀α.τ). As usual, we consider types

4.2
The TAL-0 Type System
147
τ
::=
operand types:
int
word-sized integers
code(Γ)
code labels
α
type variables
∀α.τ
universal polymorphic types
Γ
::=
register ﬁle types:
{r1 : τ1, . . . , rk : τk}
Ψ
::=
heap types:
{ℓ1 : τ1, . . . , ℓn : τn}
Figure 4-3: TAL-0 type syntax
up to alpha-equivalence of bound type variables. Finally, we consider register
ﬁle types and heap types to be equivalent up to re-ordering.
With these static constructs in hand, we can now formalize the type system
using the inference rules in Figure 4-4. The ﬁrst judgment, Ψ ⊢v : τ, is used
to determine the type of a value. Recall that a value is a register-free operand,
so there is no need for a register context in the judgment. Integer literals are
given type int, whereas labels are given the type assigned to them by the
heap type context Ψ. Note that this rule only applies when the label is in the
domain of Ψ.
The second judgment, Ψ; Γ ⊢v : τ lifts value typing to operands. A register
is given the type assigned by the register ﬁle type Γ. In addition, a polymor-
phic operand can be instantiated with any type, in a fashion similar to ML.3
The next judgment, Ψ ⊢ι : Γ1 →Γ2 is used to check instructions. The nota-
tion is meant to suggest that the instruction expects a register ﬁle described
by Γ1 on input, and produces a register ﬁle described by Γ2 on output. Note
that for the if instruction, we must ensure that the destination operand v
is a code pointer that expects a register ﬁle described by the same Γ as any
subsequent instruction. This ensures that, no matter which way the branch
goes, the resulting machine state will be well-formed.
The judgment Ψ ⊢I : code(Γ) assigns an instruction sequence I the type
code(Γ) when the sequence expects to be given a register ﬁle described by Γ.
In particular, a jump instruction’s type is dictated by the type of its operand.
The code type for a sequence of instructions is determined from composi-
tion. Most importantly, we can generalize the type of an instruction sequence
by abstracting any type variables. Note that there is no need to prevent ab-
straction of type variables which occur free in the context Ψ, as is the case
with generalization in ML. This is because Ψ will only contain closed types
(see below). Thus, generalization is always possible.
3. We could also include instantiation for values, but to keep things simple, we have omitted
that rule.

148
4
Typed Assembly Language
Values
Ψ ⊢v : τ
Ψ ⊢n : int
(s-int)
Ψ ⊢ℓ: Ψ(ℓ)
(s-lab)
Operands
Ψ; Γ ⊢v : τ
Ψ; Γ ⊢r : Γ(r)
(s-reg)
Ψ ⊢v : τ
Ψ; Γ ⊢v : τ
(s-val)
Ψ; Γ ⊢v : ∀α.τ
Ψ; Γ ⊢v : τ[τ′/α]
(s-inst)
Instructions
Ψ ⊢ι : Γ1 →Γ2
Ψ; Γ ⊢v : τ
Ψ ⊢rd:=v : Γ →Γ[rd : τ]
(s-mov)
Ψ; Γ ⊢rs : int
Ψ; Γ ⊢v : int
Ψ ⊢rd:=rs+v : Γ →Γ[rd : int]
(s-add)
Ψ; Γ ⊢rs : int
Ψ; Γ ⊢v : code(Γ)
Ψ ⊢if rs jump v : Γ →Γ
(s-if)
Instruction Sequences
Ψ ⊢I : τ
Ψ; Γ ⊢v : code(Γ)
Ψ ⊢jump v : code(Γ)
(s-jump)
Ψ ⊢ι : Γ →Γ2
Ψ ⊢I : code(Γ2)
Ψ ⊢ι; I : code(Γ)
(s-seq)
Ψ ⊢I : τ
Ψ ⊢I : ∀α.τ
(s-gen)
Register Files
Ψ ⊢R : Γ
∀r.Ψ ⊢R(r) : Γ(r)
Ψ ⊢R : Γ
(s-regfile)
Heaps
⊢H : Ψ
∀ℓ∈dom(Ψ).Ψ ⊢H(ℓ) : Ψ(ℓ)
FTV(Ψ(ℓ)) = ∅
⊢H : Ψ
(s-heap)
Machine States
⊢M
⊢H : Ψ
Ψ ⊢R : Γ
Ψ ⊢I : code(Γ)
⊢(H, R, I)
(s-mach)
Figure 4-4: TAL-0 typing rules
The judgment Ψ ⊢R : Γ asserts that the register ﬁle R is accurately de-
scribed by Γ, under the assumptions of Ψ. Similarly, the judgment ⊢H : Ψ
asserts that the heap H is accurately described by Ψ. This is essentially the
same rule as a “letrec” for declarations in a conventional functional language:
We get to assume that the labels have their advertised type, and then check
for any inconsistencies within their deﬁnitions. This allows labels to refer to
one another directly. Note also that we require the types in Ψ to be closed so
that generalization remains valid.
Finally, the judgment ⊢(H, R, I) puts the pieces together: We must have
some type assignment Ψ that describes the heap H, a register ﬁle typing Γ
that describes R consistent with Ψ, and I must be a continuation with a pre-
condition of Γ on the register ﬁle, under the assumptions of Ψ.

4.2
The TAL-0 Type System
149
Some Examples and Subtleties
As a simple example of the type system in action, let us revisit the prod
example:
prod: r3 := 0;
// res := 0
jump loop
loop: if r1 jump done;
// if a = 0 goto done
r3 := r2 + r3;
// res := res + b
r1 := r1 + (-1);
// a := a - 1
jump loop
done: jump r4
// return
Let Γ be the register ﬁle type:
{r1,r2,r3:int,r4:∀α.code{r1,r2,r3:int,r4:α}}
Registers r1, r2, and r3 are assigned the type int, and r4 is assigned a poly-
morphic code type for reasons revealed below. Let Ψ be the label type assign-
ment that maps prod, loop, and and done to code(Γ). Let I be the instruction
sequence associated with loop and let us verify that it is indeed well-formed
with the type that we have assigned it.
We must show that Ψ ⊢I : code(Γ). It suﬃces to show that each instruction
preserves Γ, since the ﬁnal jump is to loop, which expects Γ. For the ﬁrst
instruction, we must show Ψ ⊢if r1 jump done : Γ →Γ using the S-IF rule:
S-REG
Ψ; Γ ⊢r1 : Γ(r1) = int
S-LAB
Ψ ⊢done : Ψ(done) = code(Γ)
S-VAL
Ψ; Γ ⊢done : code(Γ)
Ψ ⊢if r1 jump done : Γ →Γ
Next, we must show that adding r2 to r3 preserves Γ:
S-REG
Ψ; Γ ⊢r2 : Γ(r2) = int
S-REG
Ψ; Γ ⊢r3 : Γ(r3) = int
Ψ ⊢r3 := r2 + r3 : Γ →Γ
Then, we must show that subtracting 1 from r1 preserves Γ:
S-REG
Ψ; Γ ⊢r1 : Γ(r2) = int
S-INT
Ψ ⊢−1 : int
S-VAL
Ψ; Γ ⊢−1 : int
Ψ ⊢r1 := r1 + (-1) : Γ →Γ

150
4
Typed Assembly Language
Finally, we must show that the jump which terminates the sequence has type
code(Γ), using the S-JUMP rule:
S-LAB
Ψ; Γ ⊢loop : Ψ(loop) = code(Γ)
S-VAL
Ψ; Γ ⊢loop : code(Γ)
Ψ ⊢jump loop : code(Γ)
Stringing the sub-proofs together using the S-SEQ rule, we can thus conﬁrm
that Ψ ⊢I : code(Γ).
Carrying on, we can show that each label’s code has the type associated
with it. However, there is a major subtlety with the last jump r4 instruction
and the type that we have assigned r4 throughout the code. To understand
this, consider the following:
foo: r1 := bar;
jump r1
bar: ...
What type can we assign to bar? Without the polymorphism, it must be a
code type code(Γ) such that Γ(r1) = code(Γ), since the label bar will be in
register r1 when we jump to it. But with only simple types (i.e., no subtyping,
polymorphism, or recursive types), there is no solution to this equation.
With our support for polymorphism, the problem can be averted. In par-
ticular, we can assign bar a polymorphic type τ of the form ∀α.code{r1 :
α, . . . }. At the jump instruction, we have a register ﬁle context of the form
Γ = {r1 : τ, . . . } and we must show that Γ ⊢r1 : code(Γ). Using S-INST, we
can instantiate the type of r1, which is τ, with τ to derive Γ ⊢r1 : code{r1 :
τ, . . . }.
This explains why we have used a polymorphic type for r4 in the prod
example above. Of course, this problem can be solved in other ways. Clearly,
adding recursive types provides a solution to the problem. An alternative is to
add some type Top which is greater than or equal to all other types, and use
this to forget the type of a register as we jump through it. Yet another solution
is to treat register ﬁle types as partial maps, and provide a form of subtyping
that lets you forget the type of a register, thereby making it unusable as an
operand until it is assigned a value. This last approach was the one used by
the original TAL. We prefer the approach based on polymorphism, because
there are many other compelling uses of this feature.
4.2.1
Exercise [«, 3]: Draw the derivation of well-formedness for the instruction
sequences associated with prod and done.
2

4.2
The TAL-0 Type System
151
For instance, polymorphism can also be used to achieve a type for “join-
points” in a control-ﬂow graph. Consider the situation where we have two
jumps from distinct contexts to the same label:
{r1:int,...}
jump baz
...
{r1:code{...},...}
jump baz
What type should baz require of register r1? Again, without support for some
form of polymorphism or subtyping, we would be forced to make the types
the same, in which case this code would be rejected. The problem could be
worked around by, for instance, always loading an integer into r1 before
jumping to this label. But that would slow down the program with unnec-
essary instructions. Fortunately, polymorphism saves us again. In particular,
we can assign baz a type of the form ∀α.code{r1:α,...}. Then, at the ﬁrst
jump, we would instantiate α to int, whereas at the second jump, we would
instantiate α with the appropriate code type. Of course, the addition of Top
would also provide a convenient mechanism for typing join points.
One other feature that polymorphism provides which cannot be captured
through simple subtyping, is the idea of callee-saves registers. A callee-save
register is a register whose value should remain the same across a procedure
call. If the procedure wishes to use that register, then it is responsible for
saving and restoring its value before returning to the caller. Of course, we
don’t yet have a way to save and restore registers to memory, but a procedure
could shuﬄe values around into diﬀerent registers.
Suppose we wish to call a procedure, such as prod, and guarantee that the
register r5 is preserved across the call. We can accomplish this by requiring
the procedure’s entry label to have a type of the form:
∀α.{r5:α,r4:∀β.code{r5:α,r4:β, . . . }, . . . }
where r4 is the register which is meant to hold the return address for the
procedure, and “. . .” does not contain a free occurrence of α. Note that the
return address’s type speciﬁes that r5 must have the same type (α) upon re-
turn as was originally passed in. Furthermore, the procedure is required to
treat r5 uniformly since its type is abstract. Since there is no way to manu-
facture values of abstract type, and since we’ve only passed in one α value,
it must be that if the procedure ever returns, then r5 has the same value in
it as it did upon entry (see Exercise 4.2.5.) Note that the procedure is free to
move r5’s value into some other register, and to use r5 to hold other values.
But before it can return, it must restore the original value.

152
4
Typed Assembly Language
So, it is clear that polymorphism can play a unifying role in the design
of type systems for low-level languages. It provides a way for us to conve-
niently “forget” types, which is necessary for jumps through registers and
join points. But it also provides an ability to capture critical compiler invari-
ants, such as callee-saves registers.
4.2.2
Exercise [Recommended, «, 3]: Suppose we change the done instruction se-
quence from jump r4 to jump r1. Show that there is no way to prove the
resulting code is well-typed.
2
4.2.3
Exercise [Recommended, «««, 3]: Reformulate the type system by elimi-
nating type variables and universal polymorphism in favor of a Top type and
subtyping. Then show how the product example can be typed under your
rules.
2
4.2.4
Exercise [«««, 3]: Reformulate the type system by using recursive types in
lieu of polymorphism. Then show how the product example can be typed
under your rules.
2
4.2.5
Exercise [««««, 3]: Prove that the approach to callee-saves registers actu-
ally preserves values. Hint: one relatively easy way to prove this is suggested
by Crary (1999). Another possible solution is to adapt Reynolds’ relational se-
mantics for the polymorphic lambda calculus (1983) to the TAL setting. The
result should follow as a “free theorem” (Wadler, 1989).
2
Proof of Type Soundness for TAL-0
We now wish to show that the type system given in the previous section
actually enforces our desired safety property. In particular, we wish to show
that, given a well-typed machine state M, then M cannot get stuck (i.e., jump
to an integer or undeﬁned label.) It suﬃces to show that a well-typed machine
state is not immediately stuck (progress), and that when it steps to a new
machine state M′, that state is also well-typed (preservation). For then, by
induction on the length of an evaluation sequence, we can argue that there is
no stuck M′ such that M -→∗M′.
Our ﬁrst step is to establish a set of substitution lemmas which show that
derivations remain possible after substituting types for type variables:
4.2.6
Lemma [Type Substitution]: If:
1. Ψ; Γ ⊢v : τ1, then Ψ; Γ[τ/α] ⊢v : τ1[τ/α].
2. Ψ ⊢ι : Γ1 →Γ2 then Ψ ⊢ι : Γ1[τ/α] →Γ2[τ/α].

4.2
The TAL-0 Type System
153
3. Ψ ⊢I : τ1, then Ψ ⊢I : τ1[τ/α].
4. Ψ ⊢R : Γ, then Ψ ⊢R : Γ[τ/α].
2
The register substitution lemma ensures that typing is preserved when we
look up a value in the register ﬁle. It corresponds to the value substitution
lemma in a soundness proof for a conventional lambda calculus.
4.2.7
Lemma [Register Substitution]: If ⊢H : Ψ, Ψ ⊢R : Γ and Ψ; Γ ⊢v : τ then
Ψ; Γ ⊢ˆR(v) : τ
2
As usual, we shall need a Canonical Values lemma that tells us what kind
of value we have from its type:
4.2.8
Lemma [Canonical Values]: If ⊢H : Ψ and Ψ ⊢v : τ then:
1. If τ = int then v = n for some n.
2. If τ = code(Γ) then v = ℓfor some ℓ∈dom(H) and Ψ ⊢H(ℓ) : code(Γ). 2
This extends to operands as follows:
4.2.9
Lemma [Canonical Operands]: If ⊢H : Ψ, Ψ ⊢R : Γ, and Ψ; Γ ⊢v : τ then:
1. If τ = int then ˆR(v) = n for some n.
2. If τ = code(Γ) then ˆR(v) = ℓfor some ℓ∈dom(H) and Ψ ⊢H(ℓ) :
code(Γ).
2
4.2.10
Theorem [Soundness of TAL-0]: If ⊢M, then there exists an M′ such that
M -→M′ and ⊢M′.
2
Proof:
Suppose M = (H, R, I) and ⊢M. By inversion of the S-MACH rule, there
exists a Ψ and Γ such that (a) ⊢H : Ψ, (b) Ψ ⊢R : Γ, and (c) Ψ ⊢I : code(Γ).
The proof proceeds by induction on I.
case I = jump v: From (c) and inversion of S-JUMP, we have Ψ; Γ ⊢v :
code(Γ). From the Canonical Operands lemma, we know that there exists an
I′ such that H(ˆR(v)) = I′ and Ψ ⊢I′ : code(Γ). Taking M′ = (H, R, I′), we
can show M -→M′ via the JUMP rule. We must now show ⊢(H, R, I′), but this
follows immediately.
case I = rd:=v; I′: From inversion of the S-SEQ rule, we have Ψ ⊢rd:=v : Γ →
Γ2 and Ψ ⊢I′ : code(Γ2) for some Γ2. Then, by inversion of the S-MOV rule, we
have Ψ; Γ ⊢v : τ and Γ2 = Γ[rd : τ] for some τ. By the Register Substitution
lemma, we have Ψ; Γ ⊢ˆR(v) : τ. Taking M′ = (H, R[rd = ˆR(v)], I′), we see
that M -→M′ via the MOV rule. From the S-REGFILE rule, we conclude that
Ψ ⊢R[rd = ˆR(v)] : Γ[rd : τ].

154
4
Typed Assembly Language
case I = rd:=rs+v; I′: From inversion of S-SEQ, we have Ψ ⊢rd:=rs+v :
Γ →Γ2 and Ψ ⊢I′ : code(Γ2) for some Γ2. Then, by inversion of the S-ADD
rule, we have Ψ; Γ ⊢rs : int, Ψ; Γ ⊢v : int and Γ2 = Γ[rd : int]. From
the and Canonical Operand lemma, we know that there exists integers n1
and n2 such that R(rs) = n1 and ˆR(v) = n2. Taking n = n1 + n2 and M′ =
(H, R[rd = n], I′), we see that M -→M′ via the ADD rule. By the S-INT and
S-VAL rules, Ψ; Γ[rd : int] ⊢n : int. Thus, by the S-REGFILE rule, we conclude
that Ψ ⊢R[rd = n] : Γ[rd : int].
case I = if rs jump v; I′: From inversion of the S-SEQ rule, we have Ψ ⊢
if rs jump v : Γ →Γ2 and Ψ ⊢I′ : code(Γ2) for some Γ2. Then, by inversion
of the S-IF rule, we have Ψ; Γ ⊢rs : int, Ψ; Γ ⊢v : code(Γ) and Γ2 = Γ. By
the Canonical Operands lemma, there exists an ℓand I2 such that ˆR(v) = ℓ,
H(ℓ) = I2, and Ψ ⊢I2 : code(Γ). Also by Canonical Operands, R(rs) = n
for some integer n. If n = 0 then M -→(M, R, I2) via IF-EQ. If n ≠0 then
M -→(M, R, I′) via IF-NEQ. In either case, the well-formedness of the resulting
machine state follows from the S-MACH rule.
2
Proof Representation and Checking
It is not clear whether type inference for TAL-0 machine states is decidable.
That is, given a machine state (H, R, I), does there exist a Ψ and Γ such that
⊢H : Ψ, Ψ ⊢R : Γ, and Ψ ⊢: code(Γ)? On the one hand, this seems pos-
sible since the type system is so simple. On the other hand, the system, as
presented, supports polymorphic recursion for which inference is known to
be undecidable in the context of the lambda calculus. Furthermore, as we
progress to more advanced typing features, the decidability of type recon-
struction will surely vanish. Thus, in any practical realization, we must re-
quire some help for constructing a proof that the code is indeed type-correct.
In the case of TAL-0, it is suﬃcient to provide types for the labels (i.e.,
Ψ). Indeed, it is even possible to omit types for some labels and keep recon-
struction decidable. We really only need enough type information to cut each
loop in the control-ﬂow graph, or for those labels that are moved into reg-
isters. Minimizing the type information is an important goal in any practical
system, since the size of the types can often be larger than the code itself!
However, it is desirable to keep the type checker as simple as possible so that
we can trust it is properly enforcing the type system.
One way to keep the type checker simple is to modify the syntax so that
type reconstruction is entirely syntax directed. By this, we mean simply that
for any given term, at most one rule should apply. Furthermore, the checker
should not have to “guess” any of the sub-goal components. For TAL-0, this
could be accomplished by (a) requiring types on all labels and (b) adding a
form of explicit type instantiation to operands (e.g., v[τ]).

4.3
TAL-1: Simple Memory-Safety
155
An alternative approach is to force the code provider to ship an explicit
representation of the complete proof of well-formedness, along with the code,
and make sure that the proof and the code have the same instructions, labels,
etc. Of course, these proof will tend to be much larger than the code itself, but
we can use various techniques to reduce the size of the proof representation
(see for instance Necula and Lee, 1998b).
Such a separation of proofs and code is advantageous because we can ship
the binary machine code (as opposed to the assembly code), disassemble it,
and then compare it against the assembly-level proof. If everything checks
out, then we can load the binary and execute it directly. Such an approach
is called proof-carrying code (Necula, 1997, 1998) and was ﬁrst used by Nec-
ula’s Touchstone compiler (Necula and Lee, 1998a), and the Special-J com-
piler (Colby et al., 2000), both of which are described more fully in the next
chapter.
Indeed, we could even go so far as to pass along the proof of soundness for
the entire type system, and a proof that the abstract machine is faithful to the
concrete machine’s semantics! This would ensure that the code consumer has
to trust nothing but (a) the formalization of the concrete machine semantics,
and (b) the proof checker. This is the approach proposed by Appel and Felty
and is called foundational proof-carrying code (2000).
In the rest of this chapter, we will remain vague about how proofs are to be
represented. The key thing to note is that we are not limited in the choice of
type constructors by issues of inference. Rather, we will require that the code
producer provide us with enough evidence that we can easily reconstruct and
check the proof of well-formedness. Therefore, our only limitation will be the
incompletenesses of the resulting proof system.
4.2.11
Exercise [««««, 3]: Build a type-checker for TAL-0 in your favorite program-
ming language. Assume that you are given as input a set of labels, their asso-
ciated types, and instruction sequences. Furthermore, assume that operands
are augmented with explicit syntax for polymorphic instantiation.
2
4.3
TAL-1: Simple Memory-Safety
TAL-0 includes registers and heap-allocated code, but provides no support
for allocated data. In this section, we will add primitive support for allocated
objects that can be shared by reference (i.e., pointer) and extend our safety
property to include a notion of object-level memory safety: No memory access
should read or write a data object at a given location unless the program has
been granted access to that location.

156
4
Typed Assembly Language
From a typing perspective, the critical issue will be how to accommodate
locations that hold values of diﬀerent types at diﬀerent times during the
execution of the program. We need such a facility to at least support the
construction of compound values, such as tuples, records, datatype construc-
tors, or objects. A high-level language, such as ML, provides mechanisms to
allocate and initialize data structures as a single expression. For instance,
{x = 3, y = 4} is an expression that builds a record with two components. At
the assembly level, such high-level compound expressions must be broken
into machine-level steps. We must ﬁrst allocate space for the object, and then
initialize the components by storing them in that space. To prevent someone
from treating an uninitialized component as if it holds a valid value, we must
use a diﬀerent type. But obviously, once we initialize that component, its type
should change to reﬂect that it is now valid for use.
Already, we have support for storing values of diﬀerent types in registers.
For instance, nothing prevents us from moving a code value into a register
currently holdingan int. However, when we add allocated data objects, we
can no longer track the changes easily due to aliasing. Let ptr(τ) denote a
pointer to a data object of type τ and consider this sequence of instructions:
{r1:ptr(code(...))}
1.
r3 := 0;
2.
Mem[r1] := r3;
3.
r4 := Mem[r1];
4.
jump r4
We assume upon entry that r1 is a pointer to a data location that contains
a code label. The ﬁrst two instructions overwrite the contents of memory at
the location in r1 with the integer 0. The third instruction loads the value
from the location in r1 and jumps to it. Clearly, this code should be rejected
by the type-checker as it violates our control-ﬂow safety property. To ensure
this, we might require that the type system update the type of r1 whenever
we store through it. For instance, after the second instruction, the type of r1
would change from ptr(code(...)) to ptr(int). Then at instruction four,
the code would be rejected because of an attempt to jump to an integer.
Now consider this sequence:
{r1:ptr(code(...)),r2:ptr(code(...))}
1.
r3 := 0;
2.
Mem[r1] := r3;
3.
r4 := Mem[r2];
4.
jump r4
The code is exactly the same except that instead of loading the value pointed
to by r1, we load the value pointed to by r2. Should this code type-check?

4.3
TAL-1: Simple Memory-Safety
157
The answer depends on whether or not r1 and r2 hold the same value—that
is, whether or not they are aliases for the same location. There is no problem
when they are not aliases, but when they are, the code behaves the same as
in the previous example (i.e., attempts to jump to the integer 0.) It becomes
clear that to prevent this problem, whenever we update a memory location
with a value of a diﬀerent type, we must update the types of all aliases to
that location. To do so, the type system must track whether or not two values
are the same and, more generally, whether or not two code labels behave the
same.
Of course, there is no complete logic for tracking the equalities of values
and computations, but it is possible to construct a powerful type system
that allows us to conservatively track equality of some values. For instance
see the work on alias types (Smith, Walker, and Morrisett, 2000; Walker and
Morrisett, 2001; DeLine and Fähndrich, 2001). But all of these systems are,
in my opinion, technically daunting. Furthermore, certifying compilers for
high-level languages rarely need such complex machinery.
Nonetheless, we need some support for (a) allocating and initializing data
structures that are to be shared, and (b) stack-allocating procedure frames.
Therefore, we will focus on typing principles that try to strike a balance be-
tween expressiveness and complexity. After all, our goal is to provide a simple
but expressive structure for implementing type-safe, high-level languages on
conventional architectures.
In particular, we will use the type system to separate locations into one
of two classes: The ﬁrst class, called shared pointers, will support arbitrary
aliasing. However, the types of the contents of shared pointers must remain
invariant. That is, we can never write a value of a diﬀerent type into the
contents of a shared location. This is the same basic principle that ML-style
refs and other high-level languages follow.
The second class of locations, called unique pointers, will support updates
that change the type of the contents. However, unique pointers cannot be
aliased. In particular, we will prevent unique pointers from being copied.
Thus, they will behave much the same way as registers.
The combination of unique and shared pointers will provide us with a sim-
ple, but relatively ﬂexible framework for dealing with memory. In particular,
we will be able to use unique pointers to handle the thorny problem of al-
locating and initializing shared data structures. We will also be able to use
unique pointers to model data structures whose lifetime is controlled by the
compiler, such as stack frames.

158
4
Typed Assembly Language
r
::=
registers:
r1 | r2 | · · · | rk
gp registers
sp
stack pointer
ι
::=
instructions:
· · ·
as in TAL-0
rd:= Mem[rs + n]
load from memory
Mem[rd + n] := rs
store to memory
rd:= malloc n
allocate n heap words
commit rd
become shared
salloc n
allocate n stack words
sfree n
free n stack words
v
::=
operands:
r
registers
n
integer literals
ℓ
code or shared data pointers
uptr(h)
unique data pointers
h
::=
heap values:
I
instruction sequences
⟨v1, . . . , vn⟩
tuples
Figure 4-5: TAL-1 syntax additions
The TAL-1 Extended Abstract Machine
Figure 4-5 gives a set of syntactic extensions to TAL-0 which are used in the
deﬁnition of TAL-1. We have added six new instructions: Two of the instruc-
tions can be used to load a value from memory into a register, or to store
a register’s value to memory respectively. The eﬀective address for both in-
structions is calculated as a word-level oﬀset from a base register. The other
instructions are non-standard. The malloc instruction is used to allocate an
object with n words. A (unique) reference to the object is placed in the des-
tination register. Typically, malloc will be implemented by the concrete ma-
chine using a small sequence of inlined instructions or a procedure call. We
abstract from these details here so that our abstract machine can support a
wide variety of allocation techniques. The commit instruction is used to co-
erce a unique pointer to a shared pointer. It has no real run-time eﬀect but it
makes it easier to state and prove the invariants of the type system.
The salloc and sfree constructs manipulate a special unique pointer
which is held in a distinguished register called sp (stack pointer). The instruc-
tion salloc attempts to grow the stack by n words, whereas sfree shrinks
the stack by n words. The type system will prevent the stack from under-
ﬂowing, so in principle, sfree could be implemented by a simple arithmetic
operation (e.g., sp := sp + n.) Unfortunately, stack overﬂow will not be cap-
tured by this type system. Therefore, we assume that the salloc instruction
checks for overﬂow and aborts the computation somehow.
As before, we will model machine states using a triple of a heap, register
ﬁle, and instruction sequence. And, as before, register ﬁles will map registers
to word-sized values, while heaps will map labels to heap-values. We extend

4.3
TAL-1: Simple Memory-Safety
159
heap values to include tuples of word-sized values. Thus, a label can refer to
either code or data. We could also use the heap to store unique data values,
but this would make it more diﬃcult to prove that the pointers to these values
are indeed unique. Instead, we will extend operands with terms of the form
uptr(h) and use such a term to represent a unique pointer to a heap value h.
The rewriting rules for the instructions of TAL-1 that overlap with TAL-0
remain largely the same. However, we must prevent unique pointers from be-
ing copied. More precisely, we must prevent the situation where we have two
references to the same unique data. Note that, for the addition and if instruc-
tions, the use of a unique pointer as an operand will cause the machine to get
stuck since the operands must be integers to make progress. However, the
typing for assignment (r:=v) must be changed to prevent copies of unique
pointers:
ˆR(v) ≠uptr(h)
(H, R, rd:=v; I) -→(H, R[rd = v], I)
(MOV-1)
This rule can only ﬁre when the source operand is not a unique pointer.
We must now give the rewriting rules for the new instructions:
(H, R, rd:= malloc n; I) -→(H, R[rd = uptr⟨m1, . . . , mn⟩], I)
(MALLOC)
rd ≠sp
ℓ̸∈dom(H)
(H, R[rd = uptr(h)], commit rd; I) -→(H[ℓ= h], R[rd = ℓ], I)
(COMMIT)
R(rs) = ℓ
H(ℓ) = ⟨v0, . . . , vn, . . . , vn+m⟩
(H, R, rd:= Mem[rs + n]; I) -→(H, R[rd = vn], I)
(LD-S)
R(rs) = uptr⟨v0, . . . , vn, . . . , vn+m⟩
(H, R, rd:= Mem[rs + n]; I) -→(H, R[rd = vn], I)
(LD-U)
R(rd) = ℓ
H(ℓ) = ⟨v0, . . . , vn, . . . , vn+m⟩
R(rs) = v
v ≠uptr(h)
(H, R, Mem[rd + n] := rs; I) -→(H[ℓ= ⟨v0, . . . , v, . . . , vn+m⟩], R, I)
(ST-S)
R(rd) = uptr⟨v0, . . . , vn, . . . , vn+m⟩,
R(rs) = v
v ≠uptr(h)
(H, R, Mem[rd + n] := rs; I) -→(H, R[rd = uptr⟨v0, . . . , v, . . . , vn+m⟩], I)
(ST-U)
R(sp) = uptr⟨v0, . . . , vp⟩
p + n ≤MAXSTACK
(H, R, salloc n) -→(H, R[sp = uptr⟨m1, . . . , mn, v0, . . . , vp⟩])
(SALLOC)
R(sp) = uptr⟨m1, . . . , mn, v0, . . . , vp⟩
(H, R, sfree n) -→(H, R[sp = uptr⟨v0, . . . , vp⟩])
(SFREE)
The malloc instruction places a unique pointer to a tuple of n words in the
destination register. We assume that the memory management subsystem

160
4
Typed Assembly Language
has initialized the tuple with some arbitrary integer values m1, . . . , mn. Recall
that the rewriting rules prevent these unique pointers from being copied.
However, the commit instruction allows us to move a unique pointer into the
heap where it can be shared. As we will see, however, shared pointers must
have invariant types, whereas unique pointers’ types can change.
The memory-load instruction has two variants, depending upon whether
the source register holds a value that is shared or unique. If it is shared, then
we must look up the binding in the heap to get the heap value. If it is unique,
then the heap value is immediately available. Then, in both cases, the heap
value should be a tuple. We extract the nth word and place it in the destination
register.
The memory-store instruction is the dual and is used to update the nth
component of a tuple. Note that the machine gets stuck on an attempt to
store a unique pointer, thereby preventing copies from leaking into a data
object.
As a simple example of the use of these constructs, consider the following
code:
copy: {r1:ptr(int,int), r2,r3:int}
r2 := malloc 2;
r3 := Mem[r1];
Mem[r2] := r3;
r3 := Mem[r1+1];
Mem[r2+1] := r3;
commit r2;
{r1:ptr(int,int), r2:ptr(int,int), r3:int }
The code is meant to do a deep copy of the data structure pointed to by
r1 and place the copy in register r2. Suppose that r1 holds a label ℓ1 and
H(ℓ1) = ⟨3, 5⟩. After executing the malloc instruction, r2 will hold a unique
pointer to a pair of (arbitrary) integers of the form uptr⟨m1, m2⟩. After the
load and store, the ﬁrst integer component of r1 will have been copied into
the ﬁrst component of r2. Thus, the contents of ℓ2 will have changed to
uptr⟨3, m2⟩. After the second load and store, the second component will have
been copied, so r2 will hold the value uptr⟨3, 5⟩. Finally, after the commit
instruction, r2 will hold a fresh, shared label ℓ2 and the heap will have been
extended so that it maps ℓ2 to the heap value ⟨3, 5⟩.
Here is an example program which uses salloc and sfree:
foo: {sp : uptr(int), r1 : code{...}}
salloc 2;
// {sp : uptr(int,int,int)}
Mem[sp] := r1; // {sp : uptr(code{...},int,int)}
sfree 1
// {sp : uptr(int,int)}

4.4
TAL-1 Changes to the Type System
161
τ
::=
operand types:
· · ·
as in TAL-0
ptr(σ)
shared data pointers
uptr(σ)
unique data pointers
∀ρ.τ quantiﬁcation over allocated types
σ
::=
allocated types:
ϵ
empty
τ
value type
σ1, σ2
adjacent
ρ
allocated type variable
Figure 4-6: TAL-1 types
On input, the stack has one integer element and r1 has a code pointer. The
ﬁrst instruction grows the stack by two words. The second instruction stores
the value in r1 into the top of the stack. The third instruction frees one of
the words. Note that salloc becomes stuck if we attempt to allocate more
than MAXSTACK (total) words and that sfree becomes stuck if we attempt to
shrink the stack by more words than are on the stack. Finally, note that our
stacks grow “up” (indexing is positive) whereas the common convention is to
have stacks that grow down. The only reason for this choice is that it uniﬁes
unique pointers to tuples with stacks. If we wanted to support downward
stacks, then we could introduce a new kind of data structure (e.g., stptr.)
4.3.1
Exercise [Recommended, «, 3]: Show how stack-push and stack-pop instruc-
tions can be explained using the primitives provided by TAL-1. Explain how a
sequence of pushes or a sequence of pops can be optimized.
2
4.3.2
Exercise [«««, 3]: Modify the abstract machine so that unique pointers are
allocated in the heap, just like shared pointers, but are represented as a
tagged value of the form uptr(ℓ). Then show that the machine maintains
the invariant that there is at most one copy of a unique pointer.
2
4.4
TAL-1 Changes to the Type System
What changes and additions are needed to the type system to ensure that the
new abstract machine won’t get stuck? In particular, how do we ensure that
when we do a load, the source register contains a data pointer (as opposed
to an integer or code label), and the data pointer points to a heap value that
has at least as many components as the oﬀset requires? Similarly, how do
we ensure that for a store, the destination register is a data pointer to a large
enough heap value? And how do we ensure that the stack does not underﬂow?
How do we ensure that we don’t try to copy a unique pointer? In short, how
do we ensure progress?

162
4
Typed Assembly Language
Heap Values
Ψ ⊢v : τ
Ψ; Γ ⊢vi : τi
Ψ ⊢⟨v1, . . . , vn⟩: τ1, . . . , τn
(s-tuple)
Operands
Ψ ⊢v : τ
Ψ; Γ ⊢h : σ
Ψ; Γ ⊢uptr(h) : uptr(σ)
(s-uptr)
Figure 4-7: TAL-1 typing rules (heap values and operands)
Figure 4-6 gives a new set of types for classifying TAL-1 values. The τ
types are used to classify values and operands, whereas the σ types are
used to classify heap-allocated data. We have added three new operand types
corresponding to shared pointers (ptr(σ)), unique pointers (uptr(σ)), and
polymorphism over allocated types (∀ρ.τ.)
The allocated types (σ) consist of sequences of operand types. The syntax
supports nesting structure (i.e., trees) but we implicitly treat adjacency as
associative with ϵ as a unit. So, for instance:
ptr(int, (ρ, (int, ϵ))) = ptr((int, ρ), int)
Allocated types also support variables (ρ) which are useful for abstracting
a chunk of memory. That is, α can be used to abstract a single word-sized
type, whereas ρ can be used to abstract a type of arbitrary size. As we will
see, polymorphism over allocated types is the key to eﬃcient support for
procedures.
Figures 4-7 and 4-8 give the new typing rules. As in TAL-0, we take Γ to be
a total map from registers to operand types. We are also assuming that Ψ is
a ﬁnite partial function from labels to allocated operand types (i.e., code or
ptr types.)
The well-formedness rules for tuples and unique pointers are straightfor-
ward. The s-mov-1 rule deﬁnes the new type for the move instruction. It has
as a pre-condition that the value being moved should not be a unique pointer.
The typing rule for malloc requires a non-negative integer argument, and
updates the destination register’s type with a unique pointer of an n-tuple
of integers. The commit instruction expects a unique pointer in the given
register, and simply changes its type to a shared pointer.
The load and store instructions require two rules each, depending upon
whether they are operating on unique pointers. Notice that for the store rules,
we are not allowed to place a unique pointer into the data structure. Notice
also that that when storing into a unique pointer, there is no requirement
that the new value have the same type as the old value. In contrast, for shared
pointers, the old and new values must have the same type.

4.4
TAL-1 Changes to the Type System
163
Instructions
Ψ ⊢ι : Γ1 →Γ2
Ψ; Γ ⊢v : τ
τ ≠uptr(σ)
Ψ ⊢rd:=v : Γ →Γ[rd : τ]
(s-mov-1)
n ≥0
Ψ ⊢rd:= malloc n : Γ →Γ[rd : uptr⟨int, . . . , int
|
{z
}
n
⟩]
(s-malloc)
Ψ; Γ ⊢rd : uptr(σ)
rd ≠sp
Ψ ⊢commit rd : Γ →Γ[rd : ptr(σ)]
(s-commit)
Ψ; Γ ⊢rs : ptr(τ1, . . . , τn, σ)
Ψ ⊢rd := Mem[rs + n] : Γ →Γ[rd : τn]
(s-lds)
Ψ; Γ ⊢rs : uptr(τ1, . . . , τn, σ)
Ψ ⊢rd := Mem[rs + n] : Γ →Γ[rd : τn]
(s-ldu)
Ψ; Γ ⊢rs : τn
τn ≠uptr(σ ′)
Ψ; Γ ⊢rd : ptr(τ1, . . . , τn, σ)
Ψ ⊢Mem[rd + n] := rs : Γ →Γ
(s-sts)
Ψ; Γ ⊢rs : τ
τ ≠uptr(σ ′)
Ψ; Γ ⊢rd : uptr(τ1, . . . , τn, σ)
Ψ ⊢Mem[rd + n] := rs : Γ →Γ[rd : uptr(τ1, . . . , τ, σ)]
(s-stu)
Ψ; Γ ⊢sp : uptr(σ)
n ≥0
Ψ ⊢salloc n : Γ →Γ[sp : uptr(int, . . . , int
|
{z
}
n
, σ)]
(s-salloc)
Ψ; Γ ⊢sp : uptr(τ1, . . . , τn, σ)
Ψ ⊢sfree n : Γ →Γ[sp : uptr(σ)]
(s-sfree)
Figure 4-8: TAL-1 typing rules (instructions)
The rules for salloc and sfree are straightforward. For sfree n we check
that there are at least n values on the stack to avoid underﬂow. Note that the
rule does not allow allocated type variables (ρ) to be eliminated, reﬂecting
the fact that, in general, we do not know how many words are occupied by ρ.
For instance, ρ could be instantiated with ϵ in which case there are no values.
A similar restriction holds for loads and stores—we must at least know the
sizes up through the word component we are projecting or storing.

164
4
Typed Assembly Language
To prevent the machine from becoming stuck, salloc would ideally check
that adding n words to the stack would not exceed MAXSTACK. But alas, we
cannot always determine the current length of the stack. In particular, if its
type contains an allocated variable ρ, then we are in trouble. One way around
this problem is to change the abstract machine so that it does not get stuck
upon overﬂow by deﬁning a transition (e.g., by jumping to a pre-deﬁned la-
bel). This would correspond to a machine trap due to an illegal access.
It is possible to extend our soundness proof for TAL-0 to cover the new
constructs in TAL-1 and show that a well-formed machine state cannot get
stuck, except when the stack overﬂows. In the proof of soundness, one critical
property we must show is that any typing derivation remains valid under an
extension of the heap. In particular, if ⊢H : Ψ and Ψ ⊢h : τ, then ⊢H[ℓ=
h] : Ψ[ℓ: τ]. Another critical property is that we would have to show that
a given label ℓthat occurs in the heap has exactly one type throughout the
execution of the program. In other words, once we have committed a pointer
so that it can be shared, its type must remain invariant.
4.4.1
Exercise [««««, 3]: Extend the proof of soundness to cover the new fea-
tures in TAL-1.
2
4.5
Compiling to TAL-1
At this point, TAL-1 provides enough mechanism that we can use it as a tar-
get language for the compiler of a polymorphic, procedural language with
integers, tuples, records, and function pointers (but not yet lexically nested
closures.) As a simple example, let us start with the following C code:
int prod(int x, int y) {
int a = 0;
while (x != 0) {
a = a + y;
x = x - 1;
}
return a;
}
int fact(int z) {
if (z != 0) return prod(fact(z-1),z);
else return 1;
}
and show how it may be compiled to TAL-1, complete with typing annotations
on the code labels. We assume a calling convention where arguments are

4.5
Compiling to TAL-1
165
passed on the stack, and the return address is passed in r4. We also assume
that results are returned in register r1, and arguments are popped oﬀthe
stack by the callee. Finally, we assume that registers r2 and r3 are freely
available as scratch registers.
Let us ﬁrst translate the prod function under these conventions:
prod: ∀a,b,c,s.
code{r1:a,r2:b,r3:c,sp:uptr(int,int,s),
r4:∀d,e,f.code{r1:int,r2:d,r3:e,r4:f,sp:uptr(s)}}
r2 := Mem[sp];
// r2:int, r2 := x
r3 := Mem[sp+1];
// r3:int, r3 := y
r1 := 0
// r1:int, a := 0
jump loop
loop: ∀s.code{r1,r2,r3:int,sp:uptr(int,int,s),
r4:∀d,e,f.code{r1:int,r2:d,r3:e,r4:f,sp:uptr(s)}}
if r2 jump done;
// if x ↔0 goto done
r1 := r1 + r3;
// a := a + y
r2 := r2 + (-1);
// x := x - 1
jump loop
done: ∀s.code{r1,r2,r3:int,sp:uptr(int,int,s),
r4:∀d,e,f.code{r1:int,r2:d,r3:e,r4:f,sp:uptr(s)}}
sfree 2;
// sp:uptr(s)
jump r4
The code itself is rather straightforward. What is most interesting is the types
we have placed on the labels. Note that, upon input to prod, r1, r2, and r3 can
have any types, since we have abstracted their types. Note also that the stack
pointer has type uptr(int,int,s) and thus has two integers at the front,
but can have any sequence of values following, since we have abstracted the
tail with an allocated type variable s. The return address in r4 is polymorphic
for r2 and r3 to allow values of any type in those registers upon return. As
discussed earlier, the type of r4 is abstracted by the return address to al-
low jumping through that register. Furthermore, the return address demands
that the stack have type uptr(s), reﬂecting that the callee should pop the
arguments before jumping to the return address. Thus, the contents of the
rest of the stack is guaranteed to be preserved since s is abstract.
In general, a source-level procedure that takes arguments of types τ1, . . . , τn
and returns a value of type τ would translate to a label with the same type as
prod’s, except that the stack pointer would have type uptr(τ1, . . . , τn, s), and
r4’s return code type would expect r1 to have type τ.
The types for the loop and done labels are similar to prod’s, except that
registers r1,r2, and r3 must hold integers. The reader is encouraged to check
that the resulting code is well-formed according to the typing rules for TAL-1.

166
4
Typed Assembly Language
Now let us translate the recursive factorial procedure using the same call-
ing conventions:
fact: ∀a,b,c,s.
code{r1:a,r2:b,r3:c,sp:uptr(int,s),
r4:∀d,e,f.code{r1:int,r2:d,r3:e,r4:f,sp:uptr(s)}}
r1 := Mem[sp];
// r1:int, r1 := z
if r1 jump retn
// if z = 0 goto retn
r2 := r1 + (-1);
// r2:int, r2 := z-1
salloc 2
// sp:uptr(int,int,int,s)
Mem[sp+1] := r4;
// sp:uptr(int,(∀d,e,f.code{...}),int,s)
Mem[sp] := r2;
// sp:uptr(int,(∀d,e,f.code{...}),int,s)
r4 := cont;
jump fact
// r1 := fact(z-1)
cont: ∀c,s’,d,e,f.
code{r1:int,r2:d,r3:e,r4:f,
sp:uptr(∀d,e,f.code{...},int,s’)}
r4 := Mem[sp];
// restore original return address
Mem[sp] := r1;
// sp:uptr(int,int,s’)
jump prod
// tail call prod(fact(z-1),z)
retn: ∀b,c,s.
code{r1:int,r2:b,r3:c,sp:uptr(int,s),
r4:∀d,e,f.code{r1:int,r2:d,r3:e,r4:f,sp:uptr(s)}}
r1 := 1;
sfree 1;
// sp:uptr(s)
jump
r4
// return 1
The ﬁrst couple of instructions load the argument from the stack, test if it
is zero, and if so, jump to the retn block where the argument is popped oﬀ
the stack and the value 1 is returned. If the argument z is non-zero, then we
must calculate z-1, pass it in a recursive call to fact, and then pass the result
along with z to the prod function.
To do the recursive call, we must allocate stack space for the return address
(r4) and the argument z-1, and save those values on the stack. Then we must
load a new return address into r4, namely cont and ﬁnally jump to fact.
When the recursive call returns, control will transfer to the cont label. Notice
that cont expects the stack to hold the original return address and the value
of z. We restore the original return address by loading it from the stack. We
then overwrite the same stack slot with the result of fact(z-1). Finally, we
do a tail-call to prod.
It is important to recognize that the calling conventions we chose are not
speciﬁc to the abstract machine. For instance, we could have chosen a conven-

4.6
Scaling to Other Language Features
167
tion where the return address is pushed on the stack, or where arguments are
passed in registers, introduced callee-saves registers, etc. In contrast, virtual
machines languages such as the JVML and CLI bake the notion of procedure
and procedure call into the language. To add support for diﬀerent calling
conventions (e.g., tail-calls, or a tailored convention for leaf procedures) re-
quires additions and changes to the abstract machine and its type system.
In contrast, by focusing on a more primitive set of type constructors (e.g.,
∀, code, and uptr types), we are able to accommodate many conventions
without change to the type system.
4.5.1
Exercise [Recommended, ««, 3]: Rewrite the fact procedure with a calling
convention where the arguments and return address are placed on the stack.
Include typing annotations on the labels and convince yourself that the code
type-checks.
2
4.6
Scaling to Other Language Features
TAL-1 only supports simple tuple or record-like data structures. Thus, it
is insuﬃcient for compiling real-world high-level languages which provide
data abstraction mechanisms such as closures, algebraic datatypes, objects,
and/or arrays.
Simple Objects and Closures
Support for closures and simple forms of objects is readily accommodated
by adding existential abstraction for both operand and allocated types:
τ
::=
. . . | ∃α.τ | ∃ρ.τ
The rules for introducing and eliminating existentials on operands are ex-
tremely simple:
Ψ; Γ ⊢v : τ[τ′/α]
Ψ; Γ ⊢v : ∃α.τ
(s-pack)
Ψ; Γ ⊢v : ∃α.τ
α ̸∈FTV(Γ)
Ψ; Γ ⊢v : τ
(s-unpack)
(There are two similar rules for existentials that abstract allocated types.) The
ﬁrst rule allows us to abstract a common type for some components of a data
structure. For instance, if r has type
ptr(code{r1:int,r2:int,...},int)

168
4
Typed Assembly Language
then we can use the s-pack rule to treat the value as if it has type
∃α.ptr(code{r1:α,r2:int,...},α).
Now, such a value can only be used by eliminating the existential using the
s-unpack rule. However, we are required to continue treating α as abstract
and distinct from any other type that may be in our context.
As suggested by Pierce and Turner (1993), we can use existentials to encode
very simple forms of objects. For example, consider an object interface that
looks like this, written in a Java-style:
interface Point {
int getX();
int getY();
}
and consider two classes that implement this interface:
class C1 implements Point {
int x = 0, y = 0;
int getX() { return x; }
int getY() { return y; }
}
class C2 implements Point {
int x = 0, y = 0 , n = 0;
int getX() { n++; return x; };
int getY() { n++; return y; }
}
We can think of objects as pairs of a method table and an instance variable
frame. The methods take the instance variable frame as an implicit “self”
argument. For instance, the C1 class would have an instance frame that holds
two integers, whereas the C2 class would have an instance frame that holds
three integers. Thus, at an intermediate language level, C1’s get operations
would have type:
ptr(int,int) →int
while C2’s operations would have type:
ptr(int,int,int) →int
When we build a C1 object or a C2 object, we need to hide the type of the in-
stance frame so that only the methods can gain access to and manipulate the

4.6
Scaling to Other Language Features
169
values of the instance variables. We also need to hide the type of the instance
frames so that we can give the objects a common type. We can achieve this
by using an existential to abstract the type of the instance frame and pairing
the methods with the instance frame. At an intermediate level, the type of a
Point object would thus be something like:
∃α.ptr(ptr(α →int,α →int),α)
Note that for any value with this type, we cannot directly access the instance
variables because their type is abstract (i.e., α). However, once such an ob-
ject is unpacked, we can project out a method and the instance frame, and
pass the frame to the method because the methods expect an α value as an
argument.
Closures are simple forms of objects where the instance frame holds the
environment, and there is a single method for applying the closure to its
arguments. Thus, with the simple addition of existential types, we have the
ability to encode the primary features of modern languages, notably closures
and objects. Indeed, the original TAL paper (Morrisett, Walker, Crary, and
Glew, 1999) showed how a polymorphic, core functional language could be
mapped to a version of typed assembly with support for existentials. This
translation was based on previous work of Minamide, Morrisett, and Harper
(1996).
Of course, in a more realistic implementation, we might represent objects
without the level of indirection on instance variables, and instead of passing
only the instance variables to methods, we could pass the whole object to a
method. With the addition of recursive types (µα.τ) and the usual isomor-
phism (µα.τ = τ[µα.τ/α]), this becomes possible:
∃ρ.µα.ptr(ptr(α →int,α →int),ρ)
Notice that in the above encoding, we have abstracted an allocated type (ρ)
which is used to describe the rest of the object after the method pointer. Fur-
thermore, the methods in the method table expect to take values of type α
which is isomorphic to the type of the (unpacked) object. That is, the meth-
ods take in the whole object (including the method table) instead of just the
instance variables.
This last encoding of objects is closely based on ideas of Bruce (1995;
2002). There are many other potential encodings (see Bruce, Cardelli, and
Pierce, 1997, for a nice overview.) In short, it is possible to draw upon the
wealth of literature on object and closure encodings to ﬁnd a small set of
re-usable type constructors, such as F-bounded existentials, to provide your
typed assembly language with enough power to support compilation of mod-
ern object-oriented or functional languages, without baking in a particular

170
4
Typed Assembly Language
object model. Again, this contrasts with the JVM and CLI which ﬁx on a single
object model and provide poor support for encoding languages outside that
model.
One problem with these object encodings is that they do not readily sup-
port a form of “down-casting” where we perform a run-time test to determine
whether an object implements a given interface. Such operations are common
in languages such as Java, where the lack of parametric polymorphism and
the erroneous addition of covariant arrays requires dynamic type tests. In
general, dynamic type tests can be accomplished by using some form of rep-
resentation types (Crary, Weirich, and Morrisett, 1998), but these encodings
are relatively heavyweight and do not support the actual representations used
by implementations. Glew (1999) suggested and implemented extensions to
TALx86 that better supports practical implementations.
Arrays, Arithmetic, and Dependent Types
In TAL-1, we are restricted to using constant oﬀsets to access the data com-
ponents of an object. Similarly, we can only allocate objects whose size is
known at compile time. Thus, we cannot directly encode arrays.
The simplest way to add arrays is to revert to high-level, CISC-like in-
structions. We could imagine adding a primitive rd:= newarray(ri, rs) which
would allocate an array with ri elements, and initialize all of the components
with the value in rs, returning a pointer to the array in register rd. To read
components out of an array, we might have an operation rd:= ldarr(rs, ri)
which would load the r th
i
component of array rs, placing the result in rd. Du-
ally, the operation starr(rs, rd, ri) would store the value in rs into the r th
i
component of array rd.
To ensure type safety for the ldarr and starr operations, we would need
to check that the element oﬀset ri did not exceed the number of elements in
the array and jump to an exception handler if this constraint is not met. In
turn, this would demand that we (implicitly) maintain the size of the array
somewhere. For instance, we could represent an array with n elements as a
tuple of n + 1 components with the size in the ﬁrst slot.
4.6.1
Exercise [Recommended, ««, 3]: Extend the TAL-1 abstract machine with
rewriting rules for arrays as described above and provide typing rules for the
new instructions.
2
The advantage of the approach sketched above is that it leaves the type
system simple. However, it has a number of drawbacks: First, there is no way
to eliminate the check that an oﬀset is in bounds, even if we know and can
prove that this is the case. Second, this approach requires that we maintain

4.6
Scaling to Other Language Features
171
the size of the array at runtime, even though the size might be statically ap-
parent. Third, the real machine-level operations that make up the primitive
subscript and update operations would not be subject to low-level optimiza-
tions (e.g., instruction scheduling, strength reduction, and induction variable
elimination.)
An alternative approach based on dependent types was suggested by Xi
and Harper (2001) and implemented (to some degree) in TALx86. The key
idea behind the approach, called DTAL, is to ﬁrst add a form of compile-time
expressions to the type system:
e ::= n | e1 + e2 | e1 −e2 | e1 ∗e2 | i | · · ·
A compile-time expression is made up of constants (n), arithmetic operations,
and compile-time integer variables (i). We then allow type constructors to de-
pend upon (i.e., be indexed by) a compile time expression. For instance, the
type arr(τ, 30 + 12) would classify those arrays that have 42 components,
each of which is a value of type τ. Similarly, the type int(36) would clas-
sify those integer values that are equal to 36—in other words, int(36) is a
singleton type.
To support integers whose value is unknown, or arrays whose number of el-
ements are unknown, we can use a suitably quantiﬁed compile-time variable.
For instance, the type ∃i.int(i) would classify any integer value, and the
type ∃i.arr(τ,i*2) would classify arrays of τ values with an even number
of components. More importantly, the type
∀i1,i2.code{r1:int(i1),r2:arr(T,i1),r3:int(i2)}
would classify code that expects r2 to hold an array with i1 elements, r1 to
hold an integer equal to i1, and r3 to hold some other integer equal to i2.
Thus, we can use this limited form of dependent types to track an important
relation between two values—that one register holds the number of elements
in the array pointed to by another register.
To support the elimination of array bounds checks, we need to go beyond
equality relations and track reﬁnements of values as we perform tests. For
instance, in a context with the code type above, if we wanted to use r3 to
index into array r2, it should be suﬃcient to check that the value in r3 is
greater than or equal to 0, and less than r1:4
sub:
∀i1,i2.code{r1:int(i1),r2:arr(T,i1),r3:int(i2), ...}
if r3<0 jump L;
rt := r3 - 1;
if rt>=0 jump L;
rd := ldarr(r2,r3)
// rd := Mem[r2+r3]
4. In practice, this can be determined using a single unsigned comparison.

172
4
Typed Assembly Language
In other words, the ldarr operation above should type-check since we are in
a context where r2 is an array of size i1, r3 is an integer equal to i2, and
the predicate (i2 ≥0) ∧(i2 < i1) is true. To support this validation, DTAL
checked instructions under a typing context of the form (Γ; P) where P was
a predicate that was assumed to be true. Tests, such as the blt r3, ERROR
instruction, would typically add conjuncts to the context’s predicate.
For example, type-checking for the fragment above would proceed as fol-
lows:
1. sub:
∀i1,i2.(...; true)
2.
if r3<0 jump L;
// ({...}; true ^ (i2 >= 0))
3.
rt := r3 - 1;
// ({...,rt:int(i2-i1)};(i2 >= 0))
4.
if rt>=0 jump L; // ({...,rt:int(i2-i1)};(i2 >= 0)^(i2-i1 < 0))
5.
rd := ldarr(r2,r3)
After checking line 2, the context’s predicate (true) has been reﬁned by
adding the conjunct i2 >= 0 since r3 has type int(i2) and the test can only
fall through when r3 is greater than or equal to zero. At line 3, rt is given
the type int(i2-i1) since r1 has type int(i1) and r3 has type int(i2) and
the operation places r3 - r1 into rt. Then, at line 4, the test adds the con-
junct i1-i1 < 0 to the fall-through continuation’s context. Finally, at line 5,
we are able to satisfy the pre-condition of the ldarr construct since we are
in a context where the index lies between 0 and the size of the array.
In DTAL, the predicates used for reﬁnements were restricted to linear in-
equalities so as to keep type-checking decidable. But in general, we could add
support for arbitrary predicates, and simply require that the code producer
provide an explicit proof that the current (inferred) predicate implied the
necessary pre-conditions. In other words, we can fall back to a very general
proof-carrying code framework, as described in the following chapter.
However, as the designer of the type system, we would still be responsible
for providing the code producer a set of sound (and relatively complete) infer-
ence rules for proving these relations. Though this is possible, it is nowhere
as easy as the simple proofs that we have presented here.
4.7
Some Real World Issues
Clearly, TAL-1 and the extensions described earlier provide the mechanisms
needed to implement only very simple languages. Furthermore, most of the
operations of the machine have a one-to-one correspondence with the opera-
tions of a typical RISC-style machine. Some operations, such as commit could
be pushed into the proof representation since they have no run-time eﬀect.

4.7
Some Real World Issues
173
And abstracting other operations, such as malloc, insulates us from details
of the memory management runtime.
Of course, there are a number of simple extensions that could be made
to make the type system a little more useful. For instance, we could anno-
tate primitive memory type components with ﬂags to control whether that
component supports read-only, write-only, or read-write access.
4.7.1
Exercise [«, 3]: Assuming you added type qualiﬁers for read-only and write-
only access to tuple components. How would you change the abstract ma-
chine so that you captured their intended meaning?
2
We could also add support for subtyping in a number of ways. For instance,
we could take: ptr(σ, σ ′) ≤ptr(σ). That is, we can safely forget the tail of a
sequence of values, for both ptr and uptr types. We can also consider a read-
write component to be a subtype of a read-only or a write-only component.
For shared, read-only components, we can support covariant deep subtyping,
and for write-only components, we can have contra-variant subtyping. Inter-
estingly, it is sound to have covariant subtyping on read-write components
of unique pointers. All of these extensions were supported in some form for
TALx86.
An issue not addressed here is support for primitive values of sizes less
than a machine word (e.g., a char or short). But this too is relatively easy
to accommodate. The key thing is that we need some function from operand
types to their sizes so that we can determine whether or not a ld or st is
used at the right oﬀset. A slightly more troublesome problem is the issue of
alignment. On many architectures (e.g., the MIPS, SPARC, and Alpha), primi-
tive datatypes must be naturally aligned. For instance, a 64-bit value (e.g., a
double) should be placed on a double-word boundary. Of course, the com-
piler can arrange to insert padding to ensure this property, if we assume
that malloc places objects on maximally aligned boundaries. Still, we might
need to add a well-formedness judgment to memory types to ensure that they
respect alignment constraints.
The approach to typing the stack is powerful enough to accommodate
standard procedure calls, but cannot handle nested procedures, even if they
are “downward-only” as in Pascal. To support this, we would, in general,
need some form of static pointers back into the stack (or display.) The STAL
type system supports a limited form of such pointers which also provides
the mechanisms needed to implement exceptions (Morrisett et al., 2002).
These extensions were used in the TALx86 implementation. An alternative
approach, based on intersection types, is suggested by Crary’s TALT (Crary,
2003) which has the advantage that it better supports stack-allocated ob-
jects. A more general approach is to integrate support for regions into the

174
4
Typed Assembly Language
type system in the style of Cyclone (Grossman, Morrisett, Jim, Hicks, Wang,
and Cheney, 2002) or one of the other region-based systems described in
Chapter 3.
The original TAL used a diﬀerent mechanism, based on initialization ﬂags
and subtyping, to support shared-object initialization. More recently, the work
of Petersen et al. (2003) provides an approach to initialization based on a
“fuse” calculus. The approach based on initialization ﬂags has the advantage
that uninitialized objects are ﬁrst class, which is useful in some contexts,
such as “tail-allocation” (Minamide, 1998). Neither our approach based on
unique pointers nor the fuse calculus supports this. Furthermore, neither
approach supports the initialization of circular data structures, which is im-
portant when building recursive closures. These concerns motivated the de-
sign of alias types (Smith, Walker, and Morrisett, 2000) which handles all of
these concerns and more, and which were implemented in TALx86. Recently,
Ahmed and Walker (2003) have suggested yet another approach based on an
embedding of the logic of bunched implications within a type system.
It is possible to add a free instruction to TAL-1 which takes a unique
pointer and returns it to the runtime for re-use. In some sense, free is the
ultimate type-changing operation, for it is simply a way to recycle memory so
that it can later be used to hold values of a diﬀerent type. Unfortunately, it is
not so easy to provide a free operation for shared pointers.
4.7.2
Exercise [Recommended, «, 3]: Given an example program that could "go
wrong" if we allowed free to operate on shared pointers.
2
As noted earlier, the type system is closed under extensions to the heap,
but not necessarily a shrinking heap. It can be shown that if a location is not
reachable from the registers (or from reachable code) then a heap value can be
safely thrown away. But discovering that this property is true requires more
than a single machine instruction. Indeed, it requires a run-time examination
of the pointer-graph to determine the unreachable objects.
Therefore, with the introduction of shared data pointers, we are essentially
buying into the need for a garbage collector to eﬀectively recycle memory.
Of course, to support accurate garbage collection requires that we provide
enough information that the collector can determine pointers from other data
values at run-time. Furthermore, the collector requires knowledge of the size
of heap objects. Finally, many collectors require a number of subtle proper-
ties to hold (e.g., no pointers to the interior of heap objects) before they can
be invoked. Capturing all of these constraints in a useful type system is still
somewhat of a challenge.
TALx86 and the proposed TALT use a conservative collector to recycle
memory. Conservative collectors do not require precise information about

4.8
Conclusions
175
which objects are pointers. However, they tend to have leaks, since they some-
times think an integer is a pointer to an unreachable object. Like other collec-
tors, a number of invariants must hold in order for the collection to be sound.
The TALT system formalizes these constraints as part of its type system.
Another possibility is to integrate the Capability types which provide a
general support for regions at the TAL level (Walker, Crary, and Morrisett,
2000). With this type system, it is possible to code up a copying collector
within the language as suggested by Wang and Appel (2001). However, doing
an eﬃcient copying collector requires a bit more technical machinery. Some
of these issues are resolved by Monnier, Saha, and Shao (2001).
Finally, note that, at this point, a paper and pencil proof of the soundness
of a system that incorporates these extensions becomes quite large (and te-
dious) and we are therefore likely to make mistakes. To avoid such pitfalls,
we would be wise to encode the abstract machine and type system in some
formal system where the proof can be veriﬁed. For example, Crary encodes
his TALT abstract machine and typing rules using the LF framework (2003)
whereas Hamid et al. have done this using Coq (2002). Another approach
championed by Appel and Felty (2000) is called Foundational Proof Carry-
ing Code, whereby the types are semantically constructed using higher-order
logic in such a way that they are by deﬁnition sound with respect to the
(concrete) machine’s semantics.
4.8
Conclusions
Type systems for low-level code, including compiler intermediate languages
and target languages, are an exciting area of research. In part, this is because
the “human constraint” is lifted since the typing annotations are produced
and consumed by machines instead of humans. That is, we do not have to
worry about the type system being too complicated for the average program-
mer, or that it requires too many typing annotations. These concerns often
dominate the design of type systems for high-level languages. Of course, it
is still important to keep the design as simple and orthogonal as possible
so that we can construct proofs of soundness and have conﬁdence in the
implementation. Ideally, proofs should be carried out in a machine-checked
environment.
Low-level languages also present new challenges to type system designers.
For instance, the issues of initialization and memory recycling are of little
concern in high-level languages, since these details are meant to be handled
by the compiler and run-time system. Yet, the nitty-gritty details of the run-
time system are crucial for the proper functioning of the system.


5
Proof-Carrying Code
George Necula
In the previous chapter we saw that one can adapt many of the ideas from
type systems for high-level languages to assembly language. In this chapter,
we describe yet another technique that can be used to type check assembly
language programs. This time, however, we are going to depart from tradi-
tional type-checking approaches and see how one can adapt ideas from pro-
gram veriﬁcation to this problem. In the process of doing so, we are going
to obtain a framework that can be adapted more easily to the veriﬁcation of
code properties that go beyond type safety.
5.1
Overview of Proof Carrying Code
Proof-Carrying Code (PCC) (Necula, 1997; Necula and Lee, 1996) is a general
framework that allows the host to check quickly and easily that the agent has
certain safety properties. The key technical detail that makes PCC powerful is
a requirement that the agent producer cooperates with the host by attaching
to the agent code an “explanation” of why the code complies with the safety
policy. Then all that the host has to do to ensure the safe execution of the
agent is to deﬁne a framework in which the “explanation” must be conducted,
along with a simple yet suﬃciently strong mechanism for checking that (a) the
explanation is acceptable (i.e., is within the established framework), that (b)
the explanation pertains to the safety policy that the host wishes to enforce,
and (c) that the explanation matches the actual code of the agent.
There are a number of possible forms of explanations each with its own
advantages and disadvantages. Safety explanations must be precise and com-
prehensive, just like formal proofs. In fact, in this chapter, the explanations
are going to be formal proofs encoded in such a way that they can be checked
easily and reliably by a simple proof checker.

178
5
Proof-Carrying Code
There are several ways to implement the PCC concept, and all share the
common requirement that the untrusted code contains information whose
purpose is to simplify the veriﬁcation task. At one extreme, we have the JVML
and CLI veriﬁers, which rely on typing declarations present in the untrusted
code to check the safety of the code. The KVM (Sun) implementation of the
JVML veriﬁer does further require that the code contains loop invariants in
order to simplify and speed up the veriﬁcation. Typed Assembly Language
(described in Chapter 4) pushes these ideas to the level of assembly language.
The most general instance of PCC, called Foundational Proof-Carrying Code
(FPCC) (Appel, 2001; Appel and Felty, 2000), reduces to a minimum the size
of the veriﬁer and puts almost the entire burden of veriﬁcation on the agent
producer, who now has to produce and send with the agent detailed proofs
of safety. In this chapter, we describe an instantiation of PCC that is similar
to TAL in that it operates on agents written in assembly language, and is
similar to FPCC in that it requires detailed proofs of safety to accompany the
agent code. However, the architecture that we describe here uses a veriﬁer
that is more complex than that of FPCC, and thus somewhat less trustworthy.
However, the advantage of this architecture is that is places a smaller burden
on the agent producer than FPPC, and has been shown to scale to verifying
even very large programs (Colby et al., 2000). We are going to refer to this
architecture as the Touchstone PCC architecture.
A high-level view of the architecture of the Touchstone PCC system is
shown in Figure 5-1. The agent contains, in addition to its executable con-
tent, checking-support data that allows the PCC infrastructure resident on
the receiving host to check the safety of the agent. The PCC infrastructure is
composed of two main modules. The veriﬁcation-condition generator (VCGen)
scans the executable content of the agent and checks directly simple syntactic
conditions (e.g., that direct jumps are within the code boundary). Each time
VCGen encounters an instruction whose execution could violate the safety
policy, it asks the Checker module to verify that the dangerous instruction
executes safely in the actual current context.
In order to construct a formal proof of a program, we need to reason about
them using mathematical concepts. VCGen “compiles” programs to logical
formulae in such a way that the aspects of the execution of the program that
are relevant to the security policy are brought out.
VCGen can be quite simple because it relies on the Checker to verify com-
plex safety requirements. There are some cases, however, when VCGen might
have to understand complex invariants of the agent code in order to follow its
control and data ﬂow. For example, VCGen must understand the loop struc-
ture of the agent in order to avoid scanning the loop body an unbounded
number of times. Also, VCGen must be able to understand even obscure con-

5.1
Overview of Proof Carrying Code
179
Figure 5-1: The Touchstone PCC architecture
trol ﬂow, as in the presence of indirect jumps or function pointers. In such
situations, VCGen relies on code annotations that are part of the checking
support and are packaged with the agent. This puts most of the burden of
handling the complex control-ﬂow issues on the agent producer and keeps
the VCGen simple.
The Checker module veriﬁes for VCGen that all dangerous instructions are
used in a safe context. The Checker module described in this chapter requires
that VCGen formulates the safety preconditions of the dangerous instruc-
tions as formulas in a logic. We call these formulas the veriﬁcation conditions.
The Checker expects to ﬁnd in the checking-support data packaged with the
agent a formal proof that the safety precondition is met. For the veriﬁcation
to succeed, the Checker must verify the validity of the veriﬁcation-condition
proofs for all dangerous instructions identiﬁed by VCGen.
The Touchstone PCC infrastructure described here can be customized to
check various safety policies. The “Safety Policy” element in Figure 5-1 is a
collection of conﬁguration data that speciﬁes the precise logic that VCGen
uses to encode the veriﬁcation conditions, along with the trusted proof rules
that can be used in the safety proofs supplied by the agent producer. For
example, the host might require that the untrusted code interacts correctly
with the runtime system of a Java Virtual Machine. This can be enforced in

180
5
Proof-Carrying Code
type maybepair = Int of int | Pair of int * int
let rec sum(acc : int, x : maybepair list) =
match x with
| nil →acc
| (Int i) :: tail →sum(acc + i, tail)
| (Pair (l, r)) :: tail →sum (acc + l + r, tail)
Figure 5-2: OCaml source for the example agent
our system by a safety policy requiring that the code is well-typed with re-
spect to the typing rules of Java. It is important to separate the safety policy
conﬁguration data from the rest of the infrastructure both for conceptual and
for engineering reasons. This architecture allows the infrastructure to work
with multiple safety policies, without changing most of the implementation.
An Example Agent
In the rest of this chapter, we explore the design and implementation details
of the PCC infrastructure. The infrastructure can be conﬁgured to check many
safety policies. In the example that we use here, we check a simple type-safety
policy for an agent written in a generic assembly language. The agent is a
function that adds all the elements in a list containing either integers or pairs
of integers. If this agent were written in OCaml, its source code might be as
shown Figure 5-2.
In order to write the agent in assembly language, we must decide what
is the representation strategy for lists and for the maybepair type. For the
purpose of this example, we represent a list as either the value 0 (for the
empty list), or a pointer to a two-word memory area. The ﬁrst word of the
memory area contains a list element, and the second element contains the
tail of the list. In order to represent an element of type maybepair in an
economical way we ensure that any element of kind Pair(x, y) is an even-
valued pointer to a two-word memory area containing x and y. We represent
an element of kind Int x as the integer 2x + 1 (to ensure that it is odd and
thus distinguishable from a pair). For example, the representation of the list
[Int 2; Pair (3, 4)] has the concrete representation shown in Figure 5-3.
Notice the tagged representation of the Int 2 element of the list.
In our examples, we will use the simple subset of a generic assembly lan-
guage shown below. The expressions e contain arithmetic and logic opera-
tions involving constants and registers. This is the same assembly language

5.1
Overview of Proof Carrying Code
181
Figure 5-3: Concrete representation of the list [Int 2; Pair (3, 4)]
that was used in Chapter 4, except that we relax slightly the syntax of mem-
ory addresses, and we replace the general form of indirect jump with a return
instruction.
rx := e
assign the result of e to register rx
rx := Mem[e]
load rx from address e
Mem[e′] := e
store the result of e to address e′
jump L
jump to a label L
if e jump L
branch to label L if e is true
return
return from the current function
Given our representation strategy and the choice of assembly language in-
structions, the code for the agent is shown in Figure 5-4. On entry to this code
fragment, registers rx and racc contain the value of the formal arguments x
and acc respectively. The code fragment also uses temporary registers rt and
rs. To simplify the handling of the return instruction, we use the convention
that the return value is always contained in the register rR.
The safety policy in this case requires that all memory reads be from point-
ers that are either non-null lists, in which case we can read either the ﬁrst or
the second ﬁeld of a list cell, or from pointers to elements of the Pair kind.
In the case of a memory write, the safety policy constrains the values that can
be written to various addresses as follows: in the ﬁrst word of a list cell we
can write either an odd value or an even value that is a pointer to an element
of Pair kind, and in the second word of a list cell we can write either zero
or a pointer to some list cell. There are no constraints on what we can write
to the elements of a Pair. The restrictions on memory writes ensure that
the contents of the accessible memory locations is consistent with the type
assigned to their addresses.
The safety policy speciﬁes not only requirements on the agent behavior but
can also specify assumptions that the agent can make about the context of
the execution. In the case of our agent, the safety policy might specify that
the contents of the register rx on entry is either zero or a pointer to a list

182
5
Proof-Carrying Code
1 sum:
; rx : maybepair list
2 Loop:
3
if rx ≠0 jump LCons
; Is rx empty?
4
rR := racc
5
return
6 LCons:
rt := Mem[rx]
; Load the first data
7
if even(rt) jump LPair
8
rt := rt div 2
9
racc := racc + rt
10
jump LTail
11 LPair:
rs := Mem[rt]
; Get the first pair element
12
racc := Mem[racc + rs]
13
rt := Mem[rt + 4]
; and the second element
14
racc := racc + rt
15 LTail:
rx := Mem[rx + 4]
16
jump Loop
Figure 5-4: Assembly code for the function in Figure 5-2
cell. Also, the safety policy can allow the agent to assume that the value read
from the ﬁrst word of a list cell is either odd or otherwise a pointer to a Pair
cell. Similarly, the agent can assume that the value it reads from the second
word of a cell is either null or else a pointer to a list cell. We formalize this
safety policy in the next section.
5.2
Formalizing the Safety Policy
At the core of a safety policy is a list of instructions whose execution may
violate safety. The safety policy speciﬁes, for each one, what is the veriﬁcation
condition that guarantees its safe execution. In the variant of PCC described
here, the instructions that are handled specially are the memory operations
along with the function calls and returns. This choice is hard coded in the
veriﬁcation-condition generator. However, the speciﬁc veriﬁcation condition
for each of these instructions is customizable. In such an implementation, we
can control very precisely what memory locations can be read, what memory
locations can be written and what can be written into them, what functions
we call and in what context, and in what context we return from a function.
This turns out to be suﬃcient for a very large class of safety policies. We shall
explore in Section 5.7 a safety policy for which this is not suﬃcient and for
which we must change the veriﬁcation condition generator.

5.2
Formalizing the Safety Policy
183
The customizable elements of the safety policy are the following:
•
A language of symbolic expressions and formulas that can be used to ex-
press veriﬁcation conditions.
•
A set of function preconditions and postconditions for all functions that
form the interface between the host and the agent.
•
A set of proof rules for veriﬁcation conditions.
In the rest of this section we describe in turn these elements.
The Syntax of the Logic
For this presentation we use a ﬁrst-order language of symbolic expressions
and formulas, as shown below:
Formulas
F
::=
true | F1 ∧F2 | F1 ∨F2 | F1 ⇒F2 | ∀x.F | ∃x.F
| addr Ea | E1 = E2 | E1 ≠E2 | f E1 . . . En
Expressions
E
::=
x | sel Em Ea | upd Em Ea Ev | f E1 . . . En
We consider here only the subset of logical connectives that we need for
examples. In practice, a full complement of connectives can be used. The
formula (addr Ea) is produced by VCGen as a veriﬁcation condition for a
memory read or a memory write to address Ea. This formula holds whenever
Ea denotes a valid address. Formulas can also be constructed using a set of
formula constructors that are speciﬁc to each safety policy.
The language of expressions contains variables and a number of construc-
tors that includes integer numerals and arithmetic operators, and can also be
extended by safety policies. A notable expression construct is (sel Em Ea)
that is used to denote the contents of memory address denoted by Ea in
memory state Em. The construct (upd Em Ea Ev) denotes a new memory state
that is obtained by storing the value Ev at address Ea in memory state Em.
For example, the contents of the address c in a memory that is obtained from
memory state m after writing the value 1 at address a followed by writing of
value 2, can be written:
sel (upd (upd m a 1) b 2) c
A safety policy extends the syntax of the logic by deﬁning new expression
and formula constructors. In particular, for our example agent we add con-
structors for encoding types and a predicate constructor for encoding the
typing judgment:
Word types
W
::=
int | ptr {S} | list W | {x | F(x)}
Structure types
S
::=
W | W; S
Formulas
F
::=
. . . | E : W | listinv Em

184
5
Proof-Carrying Code
We distinguish among types the word types, whose values ﬁt in a machine
register or memory word. Pointers can point to an area of memory containing
a sequence of words. The word type {x | F(x)} contains all those values for
which the formula F is true (this type is sometimes called a comprehension
or set type). The typing formula constructor “:” is written in inﬁx notation.
We also add the listinv formula constructor that will be used to state that
the contents of the memory satisﬁes the representation invariant for lists of
pairs. The precise deﬁnition of the typing and the listinv formulas will be
given on page 200, with respect to a predetermined mapping of values and
memory addresses to types. Informally, we say that listinv M holds when
each memory address that is assigned a pointer type contains values that are
assigned appropriate types.
Using these constructors we can write the low-level version of the ML typing
judgment x : maybepair list as
x : list {y | (even y) ⇒y : ptr {int; int}}
In the rest of this section we use the abbreviation mp_list for the type
maybepair list. Notice that we have built-in the recursive type of lists in
our logic, in order to avoid the need for recursion at the level of the logic, but
we choose to express the union and tuple types explicitly.
5.2.1
Exercise [Recommended, «]: The singleton type is a type populated by a
single value. Write a formula in the above logic corresponding to the assertion
that x has type singleton for the value v. Show also how you can write using
our language of types the singleton type for the value v.
2
5.2.2
Exercise [Recommended, «]: Consider an alternative representation for the
maybepair type. A value of this type is a pointer to a tagged memory area
containing a tag word followed either by another word encoding an Int if the
tag value if 0, or by two words encoding a Pair if the tag value is 1. Write the
formula corresponding to the assertion that x has this representation.
2
The Preconditions and Postconditions
A PCC safety policy contains preconditions and postconditions for the func-
tions that form the interface between the agent and the host. These are either
functions deﬁned by the agent and invoked by the host or library functions
exported by the host for use by the agent. These preconditions and postcon-
ditions are expressed as logic formulas that use a number of formula and
expression constructors speciﬁc to the safety policy.
Function preconditions and postconditions at the level of the assembly
language are expressed in terms of argument and return registers, and thus

5.2
Formalizing the Safety Policy
185
specify also the calling convention. For veriﬁcation purposes, we model the
memory as a pseudo-register rM.
The function precondition and postcondition for our agent are:
Presum
=
rx : mp_list ∧listinv rM
Postsum
=
listinv rM
The safety policy requires that the memory state be well-typed after the agent
returns and allows the agent to assume that the memory state is well-typed
when the host invokes it. Notice that we do not specify constraints on the
integer arguments and results. This reﬂects our decision that any value what-
soever can be used as an integer.
Technically, the preconditions and postconditions are not well-formed for-
mulas in our logic because they use register names as expressions. However,
we can obtain valid formulas from them once we have a substitution of reg-
ister names with expressions. We shall see later how this works out in detail.
5.2.3
Exercise [Recommended, «]: Write the precondition and postcondition of a
function of OCaml type (int * int) * int list →int list. The ﬁrst
argument is represented as a pointer to a sequence of two integers; the sec-
ond is a list. Consider that the return value is placed in register rR.
2
5.2.4
Exercise [Recommended, «]: Consider a function that takes in register r1 a
pointer to a sequence of integer lists. The length of the sequence is passed
in register r2. The function does not return anything. Write the precondition
and postcondition for this function.
2
The Proof Rules
The last part of the safety policy is a set of proof rules that can be used to rea-
son about formulas in our logic in general and about veriﬁcation conditions
in particular. In Figure 5-5 we show, in natural deduction form, a selection of
the derivation rules for the ﬁrst-order logical connectives. We show the con-
junction introduction (andi) and the two conjunction eliminations (andel,
ander), and the similar rules for implication. We also have two rules (mem0
and mem1) that allow us to reason about the sel and upd constructors for
memory expressions. These two rules should not be necessary for most type-
based safety policies because in those cases all we care to know about the
contents of a memory location is its type, not its value.
Note that in this set of base proof rules we do not yet specify when we can
prove that addr holds. This is the prerogative of the safety-policy speciﬁc
rules that we describe next.

186
5
Proof-Carrying Code
F1
F2
F1 ∧F2
(andi)
F1 ∧F2
F1
(andel)
F1 ∧F2
F2
(ander)
F1
...
F2
F1 ⇒F2
(impi)
F1 ⇒F2
F1
F2
(impe)
A = A′
sel (upd M A V) A′ = V
(mem0)
A ≠A′
sel (upd M A V) A′ = sel M A′
(mem1)
Figure 5-5: Built-in proof rules
Each safety policy can extend the built-in proof rules with new rules. In fact,
this is necessary if the safety policy uses formula constructors beyond the
built-in ones. The rules speciﬁc to our safety policy are shown in Figure 5-6.
We have rules for reasoning about the type constructors: lists (nil, cons),
set types (set) and pointers to sequences (this and next). These are similar
to corresponding rules from type systems with recursive types and tuples.
Next come two rules for reasoning about the typing properties of reading
and writing from pointers. The rule sel says that the location referenced by a
pointer to a word type in a well-typed memory state has the given word type.
The rule upd is used to prove that a well-typed write preserves well-typedness
of memory. These rules are similar to corresponding rules for reference types.
Notice that these proof rules are exposing more concrete implementation
details than the corresponding source-level rules. For example, the cons rule
speciﬁes that a list cell is represented as a pointer to a pair of words, of which
the ﬁrst one stores the data and the second the tail of the list.
Finally, the ptraddr rule relates the safety-policy speciﬁc formula con-
structors with the built-in addr memory safety formula constructor. This rule
says that addresses that can be proved to have pointer type in our type sys-
tem are valid addresses. And since this is the only rule whose conclusion
uses the addr constructor, the safety policy is essentially restricting memory
accesses to such addresses.
5.2.5
Exercise [Recommended, ««]: Add a new array type constructor to our
safety policy and write the proof rules for its usage. An array is represented

5.3
Veriﬁcation-Condition Generation
187
0 : list W
(nil)
E : list W
E ≠0
E : ptr {W; list W}
(cons)
E : {y | F(y)}
F(E)
(set)
E : ptr {W; S}
E : ptr {W}
(this)
E : ptr {W; S}
E + 4 : ptr {S}
(next)
A : ptr {W}
listinv M
(sel M A) : W
(sel)
listinv M
A : ptr {W}
V : W
listinv (upd M A V)
(upd)
A : ptr {W}
addr A
(ptraddr)
Figure 5-6: Proof rules speciﬁc to the example safety policy
as a pointer to a memory area that contains the number of elements in the
array in the ﬁrst word and then the array elements in order. Consider ﬁrst
the case where each element is a word type (as in OCaml), and then the case
when each element can be a structure (as in C).
2
We have shown here just a few of the rules for a simple safety policy.
A safety policy for a full language can easily have hundreds of proof rules.
For example, the Touchstone implementation of PCC for the Java type sys-
tem (Colby et al., 2000) has about 150 proof rules.
5.3
Veriﬁcation-Condition Generation
So far, we have shown how to set up the safety policy; now we need to de-
scribe a method for enforcing it. An analogous situation in the realm of high-
level type systems is when we have setup a type system, with a language of
types and a set of typing rules, and we need to design a type checker for
it. A type checker must scan the code and must know what typing rule to
apply at each point in the code. In fact, some type checkers work by explic-
itly collecting typing constraints that are solved in a separate module. Our
PCC infrastructure accomplishes a similar task, and separates the scanning
of the code from the decision of what safety policy proof rules to apply. The
scanning is done by the veriﬁcation-condition generator, which also identiﬁes
what must be checked for each instruction. How the check is performed is
decided by the Checker module, with considerable help from the proof that
accompanies the code. In a regular type checker, there is no pressing need
to separate code scanning from the construction of the typing derivation,

188
5
Proof-Carrying Code
since the scanning process is often simple and the structure of the typing
derivation closely follows that of the code. This is not true for low-level type
checking. In fact, programs written in assembly language may have very little
structure.
To illustrate some of the diﬃculties of type checking low-level code, con-
sider the following fragment of code written in ML, where x is a variable
of type T list and the variable t occurs in the expression e also with type
T list:
match x with
_ :: t →e
A type checker for ML parses this code, constructs an abstract syntax tree
(AST) and then it veriﬁes its well-typedness in a relatively simple manner by
traversing the AST. This is possible because the match expression packages
in one construction all the elements that are needed for type checking: the
expression to be matched, the patterns with the variables they deﬁne, and the
bodies of the cases.
Consider now one particular compilation of this code fragment:
rt := rx
rt := rt + 4
if rx = 0 jump LNil
rt := Mem[rt]
...
We assume that the variable x is allocated to register rx and that the ex-
pression e is compiled with the assumption that, on entry, the variable t is
allocated to the register rt. We observe that the code for compiling the match
construct is spread over several non-contiguous instructions mixed with the
instructions that implement the cases themselves. This is due to the intrinsi-
cally sequential nature of assembly language. It would be hard to implement
a type checker for assembly language that identiﬁes the code for the match
by recognizing patterns, as a source-level type checker does. Also, such a type
checker would be sensitive to code generation and optimization choices.
Another diﬃculty is that some high-level operations are split into several
small operations. For example the extraction of the tail of the list is separated
into the computation of an address in register rt and a memory load. We
cannot check one of the two instructions in isolation of the other because they
both can be used in other contexts as well. Furthermore, it is not suﬃcient
to type check the addition rt + 4 as we would do in a high-level language
(i.e., verify that both operands have compatible arithmetic types). Instead we
need to remember that we added the constant 4 to the contents of register
rx, so that when we reach the load instruction, we can determine that we

5.3
Veriﬁcation-Condition Generation
189
are loading the second word from a list cell. Additionally, our type-checking
algorithm has to be ﬂow sensitive and path sensitive because the outcomes
of conditional expressions sometimes determine the type of values. In our
example, if the conditional falls through then we know that rx points to a
list cell and therefore that rt points to the second element in a list cell. If,
however, the conditional jumps to LNil, then we cannot even assign a type
to rt after the addition.
Yet another complication with assembly language is that, unlike in high-
level languages, we cannot count on a variable having a single type through-
out its scope. In assembly language the registers play the role of variables and
since there is a ﬁnite number of them, compilers reuse them aggressively to
hold diﬀerent data at diﬀerent program points. In our example, the register
rt is used before the load to hold both a pointer to a memory location con-
taining a list and after the load instruction to hold a list. We must thus keep
diﬀerent types for registers for diﬀerent program points. Chapter 4 discusses
these problems extensively.
There are a number of approaches for overcoming these diﬃculties. All of
them do maintain diﬀerent types for registers at diﬀerent program points but
diﬀer on how they handle the dependency on conditionals and the splitting
of high-level operations into several instructions. At one extreme is the Java
Bytecode Veriﬁer (Lindholm and Yellin, 1997), which typechecks programs
written in the Java Virtual Machine Language (JVML). The JVML is relatively
high-level and maintains complicated operations bundled in high-level con-
structs. For instance, in JVML you cannot separate the address computation
from the memory access itself. In the context of our example, this means that
the addition and the load instruction would be expressed as one bytecode in-
struction. The JVML is designed such that the outcome of conditionals does
not matter for type checking. For example, array-bounds checks and pointer
null-checks are bundled with the memory access in high-level bytecode in-
structions. This approach simpliﬁes the type-checking problem but has the
disadvantage that the agent producer cannot really do much optimization.
Also this approach puts more burden on the code receiver for compiling and
optimizing the code.
Another approach is Typed Assembly Language (TAL), described in Chap-
ter 4, where a more sophisticated type system is used to keep track of the in-
termediate result of unbundled instructions. But even in TAL some low-level
instructions are treated as bundles for the purpose of veriﬁcation. Examples
are memory allocation and array accesses.
Here we are going to describe a type checking method that can overcome
the diﬃculties described above. The method is based on symbolic evaluation,
and it was originally used in the context of program veriﬁcation. The method

190
5
Proof-Carrying Code
is powerful enough to verify full correctness of a program, not just its well-
typedness, which will come in handy when we consider safety policies beyond
type safety.
Symbolic Evaluation
In order to introduce symbolic evaluation, consider the code fragment from
above but without the conditional.
rt := rx
rt := rt + 4
rt := Mem[rt]
This fragment exhibits the problems due to reuse of registers with diﬀerent
types and the splitting of high-level operations into low-level instructions.
We have already observed that it is more important to remember the eﬀect of
the addition instruction than it is to type check it immediately as we see it. In
fact, we are going to postpone all checking as much as possible and are going
to focus on “remembering” the eﬀect of instructions instead. Observe that if
we allow arbitrary complex operands in our instructions, we can rewrite the
above code sequence as follows:
rt := Mem[rx + 4]
In this variant, the address computation is bundled with the memory access,
and we can actually perform the usual pattern matching to recognize what
typing rule to apply. Symbolic evaluation is a technique that has the eﬀect of
collecting the results of intermediate computations to create the ﬁnal result
as a complex expression whose meaning is equivalent to the entire computa-
tion. A symbolic evaluator is an interpreter that maintains for each register a
symbolic expression. We will use the symbol σ to range over symbolic states,
which are mappings from register names to symbolic expressions. The sym-
bolic state is initialized with a distinct fresh variable for each register, to
model the lack of information about the initial values of the registers. For
our example the initial symbolic state is:
σ0 = {rt = t, rx = x, rM = m}
where t and x are distinct fresh variables. Technically, this symbolic state
says that at the given program point the following invariant holds:
∃t.∃x.∃m.rt = t ∧rx = x ∧rM = m
The symbolic evaluator proceeds forward to interpret the instructions and
modiﬁes the symbolic state as speciﬁed by the instruction. We show below
the sequence of symbolic states during symbolic evaluation.

5.3
Veriﬁcation-Condition Generation
191
σ = {rt = t, rx = x, rM = m}
rt := rx
σ = {rt = x, rx = x, rM = m}
rt := rt + 4
σ = {rt = x + 4, rx = x, rM = m}
rt := Mem[rt]
σ = {rt = (sel m (x + 4)), rx = x, rM = m}
When the instruction “rt := rx” is processed, the symbolic evaluator looks
up the value of rx in the current symbolic state and then sets rt to that
value. Notice how at the time the load instruction is processed, the symbolic
evaluator can ﬁgure out that the address being accessed is x + 4.
In order to handle memory reads and writes we use a pseudo-register rM
and the sel and upd constructors introduced in Section 5.2. For memory
loads and writes, the symbolic evaluator also emits the required veriﬁcation
conditions using the addr constructor. For example, the veriﬁcation condition
for the load instruction would be (addr (x + 4)).
Another element of interest is the handling of conditionals. In order to
allow for path sensitive checking the symbolic evaluator maintains, in ad-
dition to the symbolic state, a list of assumptions about the state. These
assumptions are simply formulas involving the same existentially quantiﬁed
variables that the symbolic state uses. As the symbolic evaluator follows the
branches of a conditional, it extends the list of assumptions with formulas
that capture the outcome of the conditional expression.
If we now add back the conditional instruction in our example, the symbolic
state and the set of assumptions (initially A) at each point are shown below:
σ = {rt = t, rx = x, rM = m}, A
rt := rx
σ = {rt = x, rx = x, rM = m}, A
rt := rt + 4
σ = {rt = x + 4, rx = x, rM = m}, A
if rx = 0 jump LNil
σ = {rt = x + 4, rx = x, rM = m}, A ∧x ≠0
rt := Mem[rt]
σ = {rt = sel m (x + 4), rx = x, rM = m}, A ∧x ≠0
...
LNil:
σ = {rt = x + 4, rx = x, rM = m}, A ∧x = 0
The symbolic state immediately before the load instruction essentially states
that the following invariant holds at that point:
∃t.∃x.∃m.rt = x ∧rx = x + 4 ∧rM = m ∧A ∧x ≠0

192
5
Proof-Carrying Code
This means that the Checker module would have to check the following
veriﬁcation condition for the load instruction:
∀t.∀x.∀m.(rt = x ∧rx = x + 4 ∧rM = m ∧A ∧x ≠0) ⇒addr (x + 4)
Symbolic evaluation has many applications in program analysis. In the fol-
lowing two exercises you can explore how one can use symbolic evaluation to
verify easily the correctness of some code transformations.
5.3.1
Exercise [Recommended, «]: Consider the following two code fragments.
The one on the right has been obtained from the one on the left by per-
forming a few simple local optimizations. First, we did register allocations,
by renaming register ra, rb, rc, and rd to r1, r2, r3 and r4 respectively. Then
we removed the dead instruction from line 1. We performed copy propa-
gation followed by common subexpression elimination in line 5. Finally, we
performed instruction scheduling by moving the instruction from line 3 to be
the last in the block.
1 ra := 2
2 ra := rb + 1
3 rc := ra + 2
4 rd := 1
5 rd := rb + rd
r1 := r2 + 1
r4 := r1
r3 := r1 + 2
Show that the result of symbolic evaluation for the registers live at the end of
the two basic blocks is identical if you start with symbolic states {rb = b} and
{r2 = b} respectively. This suggests that symbolic evaluation is insensitive to
some common optimizations.
2
5.3.2
Exercise [Recommended, «]: Now consider the ﬁrst code fragment shown
in Exercise 5.3.1 and add the instruction “ra := 3” immediately before line 5.
In this case it is not correct to perform common-subexpression elimination.
Show now that the result of symbolic evaluation is diﬀerent for the modiﬁed
code fragment and the transformed code from Exercise 5.3.1. This suggests
that symbolic evaluation can be use to verify the result of compiler optimiza-
tions. This technique is in fact so powerful that it can be used to verify most
optimizations that the GNU C compiler performs (Necula, 2000).
2
Before we can give a complete formal deﬁnition of the VCGen, we must
consider what happens in the cases when the symbolic evaluator should not
follow directly the control-ﬂow of the program. Two such cases are for loops
(when following the control-ﬂow would make VCGen loop forever) and for
functions (when it is desirable to scan the body of a function only once). In
order to handle those cases, VCGen needs some assistance from the agent
producer, in the form of code annotations.

5.3
Veriﬁcation-Condition Generation
193
The Role of Program Annotations
The VCGen module attempts to execute the untrusted program symbolically
in order to signal all potentially unsafe operations. To make this execution
possible in ﬁnite time and without the need for conservative approximations
on the part of VCGen, we require that the program be annotated with invari-
ant predicates. At least one such invariant must be speciﬁed for each cycle
in the program’s control-ﬂow graph. An easy but conservative way to enforce
such a constraint is to require an invariant annotation for every backward
branch target.
The agent code shown in Figure 5-4 has one loop whose body starts at the
label Loop. There must be one invariant annotation somewhere in that loop.
Let us say that the agent producer places the following invariant at label Loop:
Loop: INV = rx : mp_list ∧listinv rM
The invariant annotation says that whenever the execution reaches the la-
bel Loop the contents of register rx is a list. It also says that the contents
of the memory satisﬁes the representation invariants of lists. Just like the
preconditions and postconditions, the invariants can refer to register names.
A valid question at this point is who discovers this annotation and how.
There are several possibilities. First, annotations can be inserted by hand by
the programmer. This is the only alternative when the agent code is pro-
grammed directly in assembly language or when the programmer wants to
hand-optimize the output of a compiler. It is true that this method does not
scale well, but it is nevertheless a feature of PCC that the code receiver does
not care whether the code is produced by a trusted compiler, and will gladly
accept code that was written or optimized by hand.
Another possibility is that the annotations can be produced automatically
by a certifying compiler. For our simple type safety policy the only annota-
tions that are necessary consist of type declarations for the live registers at
that point. See Necula (1998) for more details.
Finally, note that the invariant annotations are required but cannot be
trusted to be correct as they originate from the same possibly untrusted
source as the code itself. Nevertheless, VCGen can still use them safely, as
described in the next section.
The Veriﬁcation-Condition Generator
Now we have all the elements necessary to describe the veriﬁcation-condition
generator for the case of one function whose precondition and postcondition
are speciﬁed by the safety policy. We will assume that each invariant annota-

194
5
Proof-Carrying Code
tion occupies one instruction slot, even though in practice they are stored in
a separate region of the agent. Let Inv be the partial mapping from program
counters to invariant predicates. If i ∈Dom(Inv), then there is an invariant
Invi at program counter i. Next, for a more uniform treatment of functions
and loops, we will consider that the ﬁrst instruction in each agent function
is an invariant annotation with the precondition predicate. In our example,
this means that Inv1 = rx : mp_list ∧listinv rM. This, along with the loop
invariant (with the same predicate) at index 2 are all the loop invariants in
the example. Thus, Dom(Inv) = {1, 2}, and the ﬁrst few lines of our agent
example are modiﬁed as follows:
1 sum:
INV rx : mp_list ∧listinv rM
2 Loop:
INV rx : mp_list ∧listinv rM
3
if rx ≠0 jump LCons
; list is empty
Given a symbolic state σ and an expression e that contains references to
register names, we write (σ e) to denote the result of substituting the regis-
ter names in e with the expressions given by σ. We extend this notation to
formulas F that refer to register names (e.g., function preconditions or post-
conditions, or loop invariants). We also write σ[r ←e] to denote a symbolic
state that is the same as σ but with register r mapped to e.
We write Πi for the instruction (or annotation) at the program counter i.
The core of the veriﬁcation-condition generator is a symbolic evaluation
function SE that given a value i for the program counter and a symbolic state
σ, produces a formula that captures all of the veriﬁcation conditions from
the given program counter until the next return instruction or invariant. The
deﬁnition of the SE function is shown below:
SE(i, σ) =



SE(i + 1, σ[r ←σ e])
if Πi = r := e
(σ e) ⇒SE(L, σ) ∧
if Πi = if e jump L
(not (σ e)) ⇒SE(i + 1, σ)
addr (σ a) ∧
if Πi = r := Mem[a]
SE(i + 1, σ[r ←(σ (sel rM a))])
addr (σ a) ∧
if Πi = Mem[a] := e
SE(i + 1, σ[rM ←(σ (upd rM a e))]
σ Post
if Πi = return
σ I
if Πi = INV I
Symbolic evaluation is deﬁned by case analysis of the instruction contained
at a given program counter. Symbolic evaluation is undeﬁned for values of
the program counter that do not contain a valid instruction. In the case of a
set instruction, the symbolic evaluator substitutes the current symbolic state
into the right-hand side of the instruction and then uses the result as the new

5.3
Veriﬁcation-Condition Generation
195
value of the destination register. Then the symbolic evaluator continues with
the following instruction. For a conditional, the symbolic evaluator adds the
proper assumption about the outcome of the conditional expression. Memory
operations are handled like assignments but with the generation of additional
veriﬁcation conditions.
When either the return instruction or an invariant is encountered, the sym-
bolic evaluator stops with a predicate obtained by substituting the current
symbolic state into the postcondition or the invariant formula. The symbolic
evaluator also ensures (using a simple check not shown here) that each loop
in the code has at least one invariant annotation. This ensures the termination
of the SE function.
What remains to be shown is how the veriﬁcation-condition generator uses
the SE function. For each invariant in the code, VCGen starts a symbolic eval-
uation with a symbolic state initialized with distinct variables. Assuming that
the set of registers is {r1, . . . , rn}, we deﬁne the global veriﬁcation condition
VC as follows:
VC
=
V
i∈Dom(Inv) ∀x1 . . . xn.
σ0 Invi ⇒SE(i + 1, σ0)
where σ0 = {r1 = x1, . . . , rn = xn}
Essentially the VCGen evaluates symbolically every path in the program
that connects two invariants or an invariant and a return instruction. In Fig-
ure 5-7 we show the operation of the VCGen algorithm on the agent code from
Figure 5-4 (after we have added the invariant annotations for the precondi-
tion and the loop, as explained at the beginning of this section). We show on
the left the program points and a brief description of each action. Some ac-
tions result in extending the stack of assumptions that the Checker is allowed
to make. These assumptions are shown underlined and with an indentation
level that encodes the position in the stack of each assumption. Thus an
assumption at a given indentation level implicitly discards all previously oc-
curring assumptions at the same or larger indentation level. Finally, we show
right-justiﬁed and boxed the checking goals submitted to the Checker.
There are two invariants (in lines 1 and 2) and for each one we generate
fresh new variables for registers, we assume that the invariant holds, and
then we start the symbolic evaluator. For the ﬁrst invariant, the symbolic
evaluator when starting in line 2 encounters an invariant and terminates.
Every boxed formula shown ﬂushed right in Figure 5-7 is a veriﬁcation
condition that VCGen produces and the Checker module has to verify for
some arbitrary values of the initial variables.
Notice that the invariant formulas are used both as assumptions and as
veriﬁcation conditions. There is a strong similarity between the role of in-
variants and that of predicates in a proof by induction. In the latter case the

196
5
Proof-Carrying Code
1: Generate fresh values rM = m0, rR = r0, rx = x0, racc = acc0,
rt = t0 and rs = s0
1: Assume Invariant
x0 : mp_list
listinv m0
2: Invariant
x0 : mp_list
listinv m0
2: Generate fresh values rM = m1, rR = r1, rx = x1, racc = acc1,
rt = t1 and rs = s1
2: Assume Invariant
x1 : mp_list
listinv m1
3: Branch 3 taken
x1 ≠0
6: Check load
addr x1
7: Branch 7 taken
even (sel m1 x1)
11: Check load
addr (sel m1 x1)
13: Check load
addr ((sel m1 x1) + 4)
15: Check load
addr (x1 + 4)
16: Goto Loop
2: Invariant
(sel m1 (x1 + 4)) : mp_list
listinv m1
7: Branch 7 not taken
odd (sel m1 x1)
10: Goto LTail
15: Check load
addr (x1 + 4)
16: Goto Loop
2: Invariant
(sel m1 (x1 + 4)) : mp_list
listinv m1
3: Branch 3 not taken
x1 = 0
5: Return
listinv m1
Figure 5-7: The sequence of actions taken by VCGen

5.3
Veriﬁcation-Condition Generation
197
listinv m1
x1 : mp_list
x1 ≠0
CONS
x1 : ptr {maybepair; mp_list}
THIS
x1 : ptr {maybepair}
SEL
(sel m1 x1) : maybepair
SET
even (sel m1 x1) ⇒(sel m1 x1) : ptr {int; int}
even (sel m1 x1)
IMPE
(sel m1 x1) : ptr {int; int}
THIS
(sel m1 x1) : ptr {int}
PTRADDR
addr (sel m1 x1)
Figure 5-8: Proof of a veriﬁcation condition
predicate is assumed to hold and with this assumption we must prove that it
holds for a larger value in a well founded order. This eﬀectively ensures that
the invariant formulas are preserved through an arbitrary execution from one
invariant point to another.
Let us consider now how one proves the veriﬁcation conditions. The ﬁrst
interesting one is the addr from line 6. Let
maybepair
def
= {y | even(y) ⇒y : ptr {int; int}}
To construct its proof, we ﬁrst derive x1 : ptr {maybepair; mp_list} using
the rule cons with the assumptions x1 : mp_list and x1 ≠0. Then we can
derive addr x1 using the rule ptraddr.
A more interesting case is that of proving addr (sel m1 x1) from the
assumptions x1 : mp_list, listinv m1, x1 ≠0, and even (sel m1 x1). This
proof is shown in Figure 5-8.
5.3.3
Exercise [««, 3]: Construct the the proof of the veriﬁcation condition corre-
sponding to the loop invariant from line 2. You must prove that sel m1 (x1 +
4) : mp_list from the assumptions x1 : mp_list, listinv m1, x1 ≠0, and
even (sel m1 x1).
2
5.3.4
Exercise [«««]: Notice that we have to prove that sel m1 x1 : ptr {int} sev-
eral times as a step in proving those veriﬁcation conditions from Figure 5-7
that refer to (sel m1 x1). Show how you can add an invariant to the program
to achieve the eﬀect of proving this fact only once.
2

198
5
Proof-Carrying Code
We have been arguing that symbolic evaluation is just an alternative method
for type checking, with additional beneﬁts for checking more complex safety
policies. Since there is a simple type checker at the source level for our type
system, it seems reasonable to wonder whether we could hope to build au-
tomatically the proofs of these veriﬁcation conditions. This is indeed possi-
ble for such type-based safety policies. Consider for instance how the proof
shown in Figure 5-8 could be constructed through a goal-directed manner.
The goal is an addr formula, and we observe that only the ptraddr among
our rules (shown in Figure 5-6) has a conclusion that matches the goal. The
subgoal now is (sel m1 x1) : ptr {int}. In order to prove that the result
of reading from a memory location has a certain type, we must prove that
the memory is well-typed and the address has some pointer type. When we
try to prove that x1 has a pointer type, we ﬁnd among the assumptions that
x1 : mp_list. The remaining steps can be easily constructed by a theorem
prover that knows the details of the type system. This general strategy was
used successfully to construct a simple theorem prover that can build auto-
matically and eﬃciently proofs of veriﬁcation conditions for the entire Java
type safety policy (Colby et al., 2000).
5.3.5
Exercise [«««]: Extend the veriﬁcation-condition generator approach shown
here to handle a function call instruction call L, where L is a label that is
considered the start of a function. For each such function there is a precon-
dition and a postcondition. Make the simplifying assumption that the call
instruction saves the return address and a set of callee-save registers on a
special stack that cannot be manipulated directly by the program. A ret in-
struction always returns to the last return address saved on the stack and
also restores the callee-save registers.
2
5.3.6
Exercise [««]: It is sometimes useful to use more kinds of annotations in
addition to the loop invariants. For example, the agent producer might know
that a certain point in the code is not reachable, as is the case for the label L1
in the code fragment shown below:
call exit
L1:
UNREACHABLE
...
In such a case it is useful to add an annotation UNREACHABLE to signal to
the symbolic evaluator that it can stop the evaluation at that point. Show how
you can change the symbolic evaluator to handle these annotation without
allowing the agent producer to “lie” about reachability of code.
2
5.3.7
Exercise [««]: Extend the symbolic evaluator to handle the indirect jump
instruction jump at e, where e must evaluate to a valid program counter.

5.4
Soundness Proof
199
Indirect jumps are often used to implement eﬃciently switch statements, in
which case the destination address is one of a statically-known set of labels.
Assume that immediately after the indirect jump instruction there is an anno-
tation of the form JUMPDEST(L1, L2) to declare that the destination address
is one of L1 or L2.
2
5.3.8
Exercise [««««, 3]: Extend the symbolic evaluator to handle stack frames.
The basic idea is that there is a dedicated stack pointer register rSP that al-
ways points at the last used stack word. This register can only be incremented
or decremented by a constant amount. You can ignore stack overﬂow issues.
The stack frame for a function has a ﬁxed size that is declared with an an-
notation. The only accesses to it are through the stack pointer register along
with a constant oﬀset. The key insight is that since there is no aliasing to
the stack frame slots they can be treated as pseudo registers. Make sure you
handle properly the overlapping of stack frames at function calls.
2
This completes our simpliﬁed account of the operation of VCGen. Note
that the VCGen deﬁned here constructs a global veriﬁcation condition that
it then passes to the Checker module. This approach, while natural and easy
to describe, turns out to be too wasteful. For large examples on the order of
millions of instructions it is quite common for this monolithic formula to re-
quire hundreds of megabytes for storage, slowing down the checking process
considerably. A high-level type checker that would construct an explicit typ-
ing derivation would be just as wasteful. A more eﬃcient VCGen architecture
passes to the Checker module each veriﬁcation condition as it is produced.
After the checker validates it, the veriﬁcation condition is discarded and the
symbolic evaluation resumes. This optimization might not seem interesting
from a scientiﬁc point of view, but it is illustrative of a number of engineering
details that must be addressed to make PCC scalable.
5.4
Soundness Proof
In this section we prove that the type checking technique presented so far
is sound, in the sense that “well-typed programs cannot go wrong.” More
precisely, we prove that if the global veriﬁcation condition for a program is
provable using the proof rules given by the safety policy, then the program
is guaranteed to execute without violating memory safety. The method we
use is similar to those used for type systems for high-level languages. We
deﬁne formally the operational semantics of the assembly language, along
with the notion of “going wrong.” It is a bit more diﬃcult to formalize the
notion of well-typed programs. In high-level type systems there is a direct

200
5
Proof-Carrying Code
connection between the typing derivations and the abstract-syntax tree of
the program. In our case, the connection is indirect: we ﬁrst use a veriﬁcation-
condition generator and then we exhibit a derivation of the global veriﬁcation
condition using the safety policy proof rules. In order to reﬂect this staging in
the operation of our type checker, we split the soundness proof into a proof
of soundness of the set of safety policy rules and a proof of soundness of the
VCGen algorithm.
Soundness of the Safety Policy
The ultimate goal of our safety policy is to provide memory safety. In order to
prove that our typing rules enforce memory safety, we must ﬁrst deﬁne the
semantics of the expression and formula constructors that we have deﬁned.
The semantic domain for the expressions is the set of integers,1 except for
the memory expressions that we model using partial maps from integers to
integers.
Next we observe that the typing formulas involving pointer types and the
listinv formulas have a well-deﬁned meaning only in a given context that
assigns types to addresses. The necessary context is a mapping M from a
valid address to the word type of the value stored at that address. Since we
do not consider allocation or deallocation, our type system ensures that the
mapping M remains constant throughout the execution of the program.
We write |=M F when the formula F holds in the memory typing M. A few
of the most interesting cases from the deﬁnition of |=M are shown below:
|=M F1 ∧F2
iff
|=M F1 and |=M F2
|=M F1 ⇒F2
iff
whenever |=M F1 then |=M F2
|=M ∀x.F(x)
iff
∀e ∈Z. |=M F(e)
|=M a : int
iff
a ∈Z
|=M a : list W
iff
a = 0 ∨(M(a) = W ∧M(a + 4) = list W)
|=M a : ptr {S}
iff
∀i.0 ≤i < |S| ⇒M(a + 4 ∗i) = Si
|=M a : {y | F(y)}
iff
|=M F(a)
|=M listinv m
iff
∀a ∈Dom(M).a ∈Dom(m) and |=M m a : M(a)
|=M addr a
iff
a ∈Dom(M)
In the above deﬁnition we used the notation |S| for the length of a sequence
of word types S, and Si for the ith element of the sequence.
1. A more accurate model would use integers modulo 232 in order to reﬂect the ﬁnite range of
integers that are representable as machine words.

5.4
Soundness Proof
201
With these deﬁnitions we can now start to prove the soundness of the
derivation rules. Given a rule with variables x1, . . . , xn, premises H1, . . . , Hm
and conclusion C, we must prove
|=M ∀x1.∀x2. . . . ∀xn.(H1 ∧· · · ∧Hm) ⇒C
For example, the soundness of rule sel requires proving the following fact:
|=M ∀a.∀W.∀m.(a : ptr {W}) ∧(listinv m) ⇒(sel m a) : W
From the ﬁrst assumption we derive that M(a) = W. From the second
assumption we derive that |=M m a : W and since |=M (sel m a) = m a we
obtain the desired conclusion.
5.4.1
Exercise [Recommended, «]: Prove that cons and next are sound.
2
5.4.2
Exercise [««, 3]: Prove the soundness of the remaining rules shown in Fig-
ure 5-6.
2
An Operational Semantics for Assembly Language
Next we formalize an operational semantics for the assembly language. We
model the execution state as a mapping ρ from register names to values.
Just like in the previous chapter, the domain of values is Z, except for the
rM register, which takes as values partial mappings from Z to Z. Since we do
not consider allocation and deallocation, the domain of the memory mapping
does not change. Let Addr be that domain. The operational semantics is
deﬁned only for programs whose memory accesses are only to addresses in
the Addr domain.
We write (ρ e) for the result of evaluating in the register state ρ the ex-
pression e, which can refer to register names. We write ρ[rr ←v] for the new
register state obtained after setting register rr to value v in state ρ.
The operational semantics is deﬁned in Figure 5-9 in the form of a small-
step transition relation (i, ρ)  (i, ρ′) from a given program counter and
register state to another such pair. Notice that the transition relation is de-
ﬁned for memory operations only if the referenced addresses are valid.
We follow the usual convention and leave the transition relation undeﬁned
for those states where the execution is considered unsafe. For instance, the
transition relation is not deﬁned if the program counter is outside the code
area or if it points to an unrecognized instruction. More importantly, the
transition relation is not deﬁned if a memory access is attempted at an invalid
address.

202
5
Proof-Carrying Code
(i, ρ) 



(i + 1, ρ[rd ←ρ e]),
if
Πi = set rd to e
(i + 1, ρ[rd ←ρ (sel rM e)]),
if
Πi = load rd from e
and
ρ e ∈Addr
(i + 1, ρ[rM ←ρ (upd rM e2 e1)]),
if
Πi = write e1 to e2
and
ρ e2 ∈Addr
(L, ρ),
if
Πi = if e goto L
and
ρ e
(i + 1, ρ),
if
Πi = if e goto L
and
ρ (not e)
(i + 1, ρ),
if
Πi = INV I
Figure 5-9: The abstract machine for the soundness proof
Soundness of Veriﬁcation-Condition Generation
The soundness theorem for VCGen states that if the veriﬁcation condition
holds, and all addresses that are in Dom(M) are valid addresses (i.e., they
belong to Addr), then the execution starting at the beginning of the agent in a
state that satisﬁes the precondition will make progress either forever or until
it reaches a return instruction in a state that satisﬁes the postcondition. What
this theorem rules out is the possibility that the execution gets stuck either
because it tries to execute an instruction at an invalid program counter, or it
tries to dereference an invalid address. The formal statement of the theorem
is the following:
5.4.3
Theorem [Soundness of VCGen]: Let ρ1 be a state such that |=M ρ1 Pre. If
Dom(M) ⊆Addr and if |=M VC then the execution starting at (1, ρ1) can
make progress either forever, or until it reaches a return instruction in state
ρ, in which case |=M ρ Post.
2
We prove by induction on the number of execution steps that either we
have reached the return instruction, or else we can make further progress.
As in all proofs by induction, the most delicate issue is the choice of the
induction hypothesis. Informally, our induction hypothesis is that for each
execution state there is a “corresponding” state of the symbolic evaluator.
In order to express the notion of correspondence, we must consider the dif-
ferences between the concrete execution states ρ (mapping register names to

5.4
Soundness Proof
203
values) and the symbolic evaluation states σ (mapping register names to sym-
bolic expressions that use expression constructors and variables). To bridge
these two notions of states we need a mapping φ from variables that appear
in σ, to values. For a symbolic expression e that contains variables, we write
(φ e) for the result of replacing the variables in e as speciﬁed by φ and eval-
uating the result. Consequently, we write φ ◦σ for a mapping from register
names to values that maps each register name ri to the value φ (σ ri). Thus
φ ◦σ is a concrete execution state.
The main relationship that we impose between ρ and σ is that there exists
a mapping φ such that ρ = φ ◦σ. The full induction hypothesis relates these
states with the program counter i, and is deﬁned as follows:
IH(i, ρ, σ, φ) def
= ρ = φ ◦σ and |=M φ (SE(i, σ))
The core of the soundness proof is the following lemma:
5.4.4
Theorem [Progress]: Let Π be a program such that |=M VC and Dom(M) ⊆
Addr. For any execution state (i, ρ) and σ and φ such that IH(i, ρ, σ, φ)
then either:
• Πi = return, and |=M ρ Post, or
• there exist new states ρ′, σ ′ and a mapping φ′ such that (i, ρ) →(i′, ρ′)
and IH(i′, ρ′, σ ′, φ′).
2
Proof:
The proof is by case analysis on the current instruction. Since we have
that |=M φ SE(i, σ) we know that SE(i, σ) is deﬁned, hence the program
counter is valid and Πi is a valid instruction. We show here only the most
interesting cases.
Case: Πi = return. In this case SE(i, σ) = σ Post and from |=M φ SE(i, σ)
along with ρ = φ ◦σ we can infer that |=M ρ Post.
Case: Πi = load rd from e. In this case SE(i, σ) = addr (σ e) ∧SE(i +
1, σ[rd ←σ (sel rM e)]). Let σ ′ = σ[rd ←σ (sel rM e)], ρ′ = ρ[rd ←
ρ (sel rM e)], i′ = i + 1 and φ′ = φ. In order to prove progress, we must
prove ρ e ∈Addr. The induction hypothesis IH(i, ρ, σ, φ) ensures that |=M
(addr (φ(σ e))), which in turn means that (ρ e) ∈Dom(M). Since we require
that the memory typing be deﬁned only on valid addresses we obtain the
progress condition.
Next we have to prove that the induction hypothesis is preserved. The only
interesting part of this proof is that φ′ ◦σ ′ = ρ′, which in turn requires
proving that φ(σ (sel rM e)) = ρ (sel rM e). This follows from φ ◦σ = ρ.
Case: Πi = INV I. In this case SE(i, σ) = σ I. We know that |=M φ(σ I) and
therefore |=M ρ I. The execution can always make progress for an invariant

204
5
Proof-Carrying Code
instruction and we must choose i′ = i + 1 and ρ′ = ρ. We know that |=M VC
and hence
|=M ∀x1. . . . .∀xn.σ0 I ⇒SE(i + 1, σ0)
where σ0 = {r1 = x1, . . . , rn = xn}. We choose σ ′ = σ0 and φ′ as follows:
φ′ = {x1 = ρ r1, . . . , xn = ρ rn}
This ensures that ρ = φ′ ◦σ ′ and also that |=M φ′ SE(i + 1, σ ′), which
completes this case of the proof.
2
5.4.5
Exercise [Recommended, «, 3]: Finish the proof of Theorem 5.4.4 by prov-
ing the remaining cases (assignment, conditional branch and memory write). 2
The progress theorem constitutes the inductive case of the proof of the
soundness theorem 5.4.3.
5.4.6
Exercise [«]: Prove Theorem 5.4.3.
2
5.5
The Representation and Checking of Proofs
In previous sections, we showed how veriﬁcation-condition generation can be
used to verify certain properties of low-level code. The soundness theorem
states that VCGen constructs a valid veriﬁcation condition for an agent pro-
gram only if the agent meets the safety policy. One way to verify the validity
of the veriﬁcation condition is to witness a derivation using a sound system
of proof rules. In PCC such a derivation must be attached to the untrusted
code so that the Checker module can ﬁnd and check it. For this to work prop-
erly in practice, we need a framework for encoding proofs of logical formulas
so that they are relatively compact and easy to check. We would like to have a
framework and not just one proof checker for a given logic because we want
to be able to change the set of axioms and inference rules as we adapt PCC to
diﬀerent safety policies. We would like to be able to adapt proof checking to
other safety policies with as few changes to the infrastructure as possible. In
this section we present a logical framework derived from the Edinburgh Log-
ical Framework (Harper, Honsell, and Plotkin, 1993), along with associated
proof representation and proof checking algorithms, that have the following
desirable properties:
•
The framework can be used to encode judgments and derivations from a
wide variety of logics, including ﬁrst-order and higher-order logics.
•
The implementation of the proof checker is parameterized by a high-level
description of the logic. This allows a unique implementation of the proof
checker to be used with many logics and safety policies.

5.5
The Representation and Checking of Proofs
205
•
The proof checker performs a directed, one-pass inspection of the proof
object, without having to perform search. This leads to a simple imple-
mentation of the proof checker that is easy to trust and install in existing
extensible systems.
•
Even though the proof representation is detailed, it is also compact.
The above desiderata are important not only for proof-carrying code but
for any application where proofs are represented and manipulated explicitly.
One such application is a proof-generating theorem prover. A theorem prover
that generates an explicit proof object for each successfully proved predicate
enables a distrustful user to verify the validity of the proved theorem by
checking the proof object. This eﬀectively eliminates the need to trust the
soundness of the theorem prover at the relatively small expense of having to
trust a much simpler proof checker.
The ﬁrst impulse when designing eﬃcient proof representation and vali-
dation algorithms is to specialize them to a given logic or a class of related
logics. For example, we might deﬁne the representation and validation algo-
rithms by cases, with one case for each proof rule in the logic. This approach
has the major disadvantage that new algorithms must be designed and im-
plemented for each logic. To make matters worse, the size of such proof
checking implementations grow with the number of proof rules in the logic.
We would prefer instead to use general algorithms parameterized by a high-
level description of the particular logic of interest.
We choose the Edinburgh Logical Framework (LF) as the starting point in
our quest for eﬃcient proof manipulation algorithms because it scores very
high on the ﬁrst three of the four desirable properties listed above. Edinburgh
LF is a simple variant of λ-calculus with the property that, if a predicate is
represented as an LF type then any LF expression of that type is a proof of that
predicate. Thus, the simple logic-independent LF type-checking algorithm can
be used for checking proofs.
The Edinburgh Logical Framework
The Edinburgh Logical Framework (also referred to as LF) has been intro-
duced by Harper, Honsell, and Plotkin (1993) as a metalanguage for high-level
speciﬁcation of logics. LF provides natural support for the management of
binding operators and of the hypothetical and schematic judgments through
LF bound variables. Consider for example, the usual formulation of the im-
plication introduction rule impi in ﬁrst-order logic, shown in Figure 5-5. This
rule is hypothetical because the proof of the right-hand side of the implica-
tion can use the assumption that the left-hand side holds. However, there is

206
5
Proof-Carrying Code
a side condition requiring that this assumption not be used elsewhere in the
proof. As we shall see below, LF can represent this side condition in a natural
way by representing the assumption as a local variable bound in the proof
of the right side of the implication. The fact that these techniques are sup-
ported directly by the logical framework is a crucial factor for the succinct
formalization of proofs.
The LF type theory is a language with entities at three levels: objects, types
and kinds, whose abstract syntax is shown below:
Kinds
K
::=
Type | Πx:A.K
Types
A
::=
a | A M | Πx:A1.A2
Objects
M
::=
x | c | M1M2 | λx:A.M
Types are used to classify objects and similarly, kinds are used to classify
types. The type Πx:A.B is a dependent function type with x bound in B. In the
special case when x does not occur in B, we use the more familiar notation
A →B. Also, Type is the base kind, a is a type constant and c is an object
constant. Dependent types are covered in detail in Chapter 2.
The encoding of a logic in LF is described by an LF signature Σ that contains
declarations for a set of LF type constants and object constants correspond-
ing to the syntactic formula constructors and to the proof rules. For a more
concrete discussion, I describe in this section the LF representation of the
safety policy that we have developed for our example agent.
The syntax of the logic is described in Figure 5-10. This signature deﬁnes
an LF type constant for each kind of syntactic entity in the logic: expressions
(ι), formulas (o), word types (w), and structure types (s). Then, there is an LF
constant declaration for each syntactic constructor, whose LF type describes
the arity of the constructor and the types of the arguments and constructed
value. Two of these are worth explaining. The settype constructor, used to
represent word types of the form {y | F(y)}, has one argument, the func-
tion F from expressions to formulas; similarly, the all constructor encodes
universally quantiﬁed formulas. In both of these cases, we are representing a
binding in the object logic (i.e., the logic that is being represented) with a bind-
ing in LF. The major advantage of this representation is that α-equivalence
and β-reduction in the object logic are supported implicitly by the similar
mechanisms in LF. This higher-order representation strategy is essential for a
concise representation of logics with binding constructs.
The LF representation function [·\ is deﬁned inductively on the structure
of expressions, types and formulas. For example:
[P ⇒(P ∧P)\
=
imp [P\ (and [P\ [P\)
[∀x.addr x\
=
all (λx : ι.addr x)

5.5
The Representation and Checking of Proofs
207
ι
:
Type
o
:
Type
w
:
Type
s
:
Type
zero
:
ι
sel
:
ι →ι →ι
upd
:
ι →ι →ι →ι
int
:
w
list
:
w →w
seq1
:
w →s
seq2
:
w →s →s
ptr
:
s →w
settype
:
(ι →o) →w
true
:
o
and
:
o →o →o
impl
:
o →o →o
all
:
(ι →o) →o
eq
:
ι →ι →o
neq
:
ι →ι →o
addr
:
ι →o
hastype
:
ι →w →o
ge
:
ι →ι →o
(a)
(b)
Figure 5-10: LF signature for the syntax of ﬁrst-order predicate logic with
equality and subscripted variables, showing expression (a) and predicate
(b) constructors
5.5.1
Exercise [«]: Write the LF representation of the predicate ∀a.a : ptr {int} ⇒
addr a.
2
The strategy for representing proofs in LF is to deﬁne a type family “pf ”
indexed by representation of formulas. Then, we represent the proof of “F”
as an LF expression having type “pf F.” This representation strategy is called
“judgments as types and derivations as objects” and was ﬁrst used in the
work of Harper, Honsell, and Plotkin (1993). Note that the dependent types
of LF allow us to encode not only that an expression encodes a proof but also
which formula it proves.
One can view the axioms and inference rules as proof constructors. This
justiﬁes representing the axioms and inference rules in a manner similar to
the syntactic constructors, by means of LF constants. The signature shown
in Figure 5-11 contains a fragment of the proof constructors required for the
proof rules shown in Figure 5-5 (for ﬁrst-order logic) and Figure 5-6 (for our
safety policy). Note how the dependent types of LF can deﬁne precisely the
meaning of each rule. For example, the declaration of the constant “andi”

208
5
Proof-Carrying Code
pf
:
o →Type
truei
:
pf true
andi
:
Πp:o.Πr :o.pf p →pf r →pf (and p r)
andel
:
Πp:o.Πr :o.pf (and p r) →pf p
ander
:
Πp:o.Πr :o.pf (and p r) →pf r
impi
:
Πp:o.Πr :o.(pf p →pf r) →pf (impl p r)
impe
:
Πp:o.Πr :o.pf (impl p r) →pf p →pf r
alli
:
Πp:ι →o.(Πv :ι.pf (p v)) →pf (all p)
alle
:
Πp:ι →o.Πe:ι.pf (all p) →pf (p e)
mem0
:
Πm:ι.Πa:ι.Πv :ι.Πa′ :ι.pf (eq a a′) →pf (eq (sel (upd m a v) a′) v)
mem1
:
Πm:ι.Πa:ι.Πv :ι.Πa′ :ι.
pf (neq a a′) →pf (eq (sel (upd m a v) a′) (sel m a′))
cons
:
ΠE :ι.ΠW :w.
pf (hastype E (list W)) →pf (neq E zero) →
pf (hastype E (ptr (seq2 W (seq1 (list W))))).
set
:
ΠE :ι.ΠF :ι →o.pf (hastype E (settype F)) →pf (F E).
Figure 5-11: LF signature for safety policy proof rules
says that, in order to construct the proof of a conjunction of two predicates,
one can apply the constant “andi” to four arguments, the ﬁrst two being the
two conjuncts and the other two being the representations of proofs of the
conjuncts respectively.
The LF representation function [·\ is extended to derivations and is deﬁned
recursively on the derivation, as shown in the following examples (the letters
D are used to name sub-derivations):
[ D1
F1
D2
F2
F1 ∧F2
\
= andi [F1\ [F2\ [D1\ [D2\
[
F1
... Du
F2
F1 ⇒F2
\
= impi [F1\ [F2\ (λu:pf [F1\.[Du\)

5.5
The Representation and Checking of Proofs
209
M
=
impi [F\ (and [F\ [F\)
(λx:pf [F\.andi [F\ [F\ x x)
Figure 5-12: LF representation of a proof of F ⇒(F ∧F)
In the representation of the implication introduction proof rule, the letter
u is the name of the assumption that F1 holds. Note how the representation
encodes the constraint that this assumptions must be local to the proof of F2.
To conclude the presentation of the LF representation, consider the proof
of the formula “F ⇒(F ∧F).” The LF representation of this proof is shown in
Figure 5-12.
5.5.2
Exercise [«]: Write the LF representation of the proof of the formula ∀a.a :
ptr {int} ⇒addr a, using the proof rules from our safety policy.
2
The LF Type System
The main advantage of using LF for proof representation is that proof validity
can be checked by a simple type-checking algorithm. That is, to check that the
LF object M is the representation of a valid proof of the predicate F we use
the LF typing rules (to be presented below) to verify that M has type pf [F\
in the context of the signature Σ declaring the valid proof rules.
Type checking in the LF type system is deﬁned by means of four judgments
described below:
Γ ⊢
LF A : K
A is a valid type of kind K
Γ ⊢
LF M : A
M is a valid object of type A
A ≡βη B
type A is βη-equivalent to type B
M ≡βη N
object M is βη-equivalent to object N
where Γ is a typing context assigning types to LF variables. These typing judg-
ment are with respect to a given signature Σ.
The derivation rules for the LF typing judgments are shown in Figure 5-13.
For the βη-equivalence judgments we omit the rules that deﬁne it to be an
equivalence and a congruence.
As an example of how LF type checking is used to perform proof checking,
consider LF term M shown in Figure 5-12, representing a proof of the pred-
icate F ⇒(F ∧F by implication introduction followed by conjunction intro-
duction. It is easy to verify, given the LF typing rules and the declaration of the

210
5
Proof-Carrying Code
Types
Γ ⊢
LF A : K
Σ(a) = K
Γ ⊢
LF a : K
Γ ⊢
LF A : Πx:B.K
Γ ⊢
LF M : B
Γ ⊢
LF A M : [M⧸x]K
Γ ⊢
LF A : Type
Γ, x : A ⊢
LF B : Type
Γ ⊢
LF Πx:A.B : Type
Objects
Γ ⊢
LF M : A
Σ(c) = A
Γ ⊢
LF c : A
Γ(x) = A
Γ ⊢
LF x : A
Γ, x : A ⊢
LF M : B
Γ ⊢
LF λx:A.M : Πx:A.B
Γ ⊢
LF M : Πx:A.B
Γ ⊢
LF N : A
Γ ⊢
LF MN : [N⧸x]B
Γ ⊢
LF M : A
A ≡βη B
Γ ⊢
LF M : B
Equivalence
M ≡βη N
(λx:A.M)N ≡βη [N⧸x]M
Figure 5-13: The LF type system
constants involved, that this proof has the LF type “pf (imp[F\ (and[F\ [F\)).”
The adequacy of LF type checking for proof checking in the logic under con-
sideration is stated formally in the Theorems 5.5.3 and 5.5.4 below. These
theorems follow immediately from lemmas proved in Harper, Honsell, and
Plotkin (1993). They continue to hold if the logic is extended with new ex-
pression and predicate constructors.
5.5.3
Theorem [Adequacy of syntax representation]:
1. If E is a closed expression, then · ⊢
LF [E\ : ι. If M is a closed LF object such
that · ⊢
LF M : ι, then there exists an expression E such that [E\ ≡βη M.
2. If W is a word-type, then · ⊢
LF [W\ : w. If M is a closed LF object such that
· ⊢
LF M : w, then there exists a word type W such that [W\ ≡βη M.
3. If S is a structured type, then · ⊢
LF [S\ : s. If M is a closed LF object such
that · ⊢
LF M : s, then there exists a structured type S such that [S\ ≡βη M.
4. If F is a closed formula, then · ⊢
LF [F\ : o. If M is a closed LF object such
that · ⊢
LF M : o, then there exists a formula F such that [F\ ≡βη M.
2
5.5.4
Theorem [Adequacy of Derivation Representation]:
1. If D is a derivation of F then · ⊢
LF [D\ : pf [F\.

5.5
The Representation and Checking of Proofs
211
2. If M is a closed LF object such that · ⊢
LF M : pf [F\, then there exists a
derivation D of F such that [D\ ≡βη M.
2
In the context of PCC, Theorem 5.5.4(2) says that if the agent producer
can exhibit an LF object having the type “pf [VC\” then there is a derivation
of the veriﬁcation condition within the logic, which in turn means that the
veriﬁcation condition is valid and the agent code satisﬁes the safety policy.
Owing to the simplicity of the LF type system, the implementation of the
type checker is simple and easy to trust. Furthermore, because all of the de-
pendencies on the particular object logic are separated in the signature, the
implementation of the type checker can be reused directly for proof checking
in various ﬁrst-order or higher-order logics. The only logic-dependent com-
ponent of the proof checker is the signature, which is usually easy to verify
by visual inspection.
Unfortunately, the above-mentioned advantages of LF representation of
proofs come at a high price. The typical LF representation of a proof is large,
due to a signiﬁcant amount of redundancy. This fact can already be seen in
the proof representation shown in Figure 5-12, where there are six copies
of F as opposed to only three in the predicate to be proved. The eﬀect of
redundancy observed in practice increases non-linearly with the size of the
proofs. Consider for example, the representation of the proof of the n-way
conjunction F ∧. . . ∧F. Depending on how balanced is the binary tree repre-
senting this predicate, the number of copies of F in the proof representation
ranges from an expected value of n log n (when the tree is perfectly balanced)
to a worse case value of n2/2 (when the tree degenerates into a list). The
redundancy of representation is not only a space problem but also leads to
ineﬃcient proof checking, because all of the redundant copies have to be
type checked and then checked for equivalence with instances of F from the
predicate to be proved.
The proof representation and checking framework presented in the next
section is based on the observation that it is possible to retain only the skele-
ton of an LF representation of a proof and to use a modiﬁed LF type-checking
algorithm to reconstruct on the ﬂy the missing parts. The resulting implicit LF
(or LFi) representation inherits the advantages of the LF representation (i.e.,
small and logic-independent implementation of the proof checker) without
the disadvantages (i.e., large proof sizes and slow proof checking).
Implicit LF
The solution to the redundancy problem is to eliminate the redundant sub-
terms from the proof. In most cases we can eliminate all copies of a given

212
5
Proof-Carrying Code
subterm from the proof and rely instead on the copy that exists within the
predicate to be proved, which is constructed by the VCGen and is trusted to
be well formed. But now the code receiver will be receiving proofs with miss-
ing subterms. One possible strategy is for the code receiver to reconstruct
the original form of the proof and then to use the simple LF type checking
algorithm to validate it. But this does not save proof-checking time and re-
quires signiﬁcantly more working memory than the size of the incoming LFi
proof. Instead, we modify the LF type-checking algorithm to reconstruct the
missing subterms while it performs type checking. One major advantage of
this strategy is that terms that are reconstructed based on copies from the
veriﬁcation condition do not need to be type checked themselves.
We will not show the formal details of the type reconstruction algorithm
but will show instead how it operates on a simple example. For expository
purposes, the missing proof subterms are marked with placeholders, written
as ∗. Consider now the proof of the predicate F ⇒(F ∧F) of Figure 5-12. If
we replace all copies of “F” with placeholders we get the following LFi object:
impi ∗1 ∗2 (λu:∗3.andi ∗4 ∗5 u u)
This implicit proof captures the structure of the proof without any redun-
dant information. The subterms marked with placeholders can be recovered
while verifying that the term has type “pf (impl[F\ (and[F\ [F\)),” as de-
scribed below.
Reconstruction starts by recognizing the top-level constructor impi. The
expected type of the entire term, “pf (impl [F\ (and [F\ [F\)),” is “matched”
against the result type of the impi constant, as given by the signature Σ. The
result of this matching is an instantiation for placeholders 1 and 2 and a
residual type-checking constraint for the explicit argument of impi, as fol-
lows:
∗1
≡
[F\
∗2
≡
and [F\ [F\
⊢
(λu:∗3.andi ∗4 ∗5 u u)
:
pf [F\ →pf (and [F\ [F\)
Reconstruction continues with the remaining type-checking constraint. From
its type we can recover the value of placeholder 3 and a typing constraint for
the body:
∗3
≡
pf [F\
u : pf [F\ ⊢
andi ∗4 ∗5 u u
:
pf (and [F\ [F\)
Now andi is the top-level constant and by matching its result type as declared
in the signature with the goal type of the constraint we get the instantiation

5.5
The Representation and Checking of Proofs
213
for placeholders 4 and 5 and two residual typing constraints:
∗4
≡
[F\
∗5
≡
[F\
u : pf [F\ ⊢
u
:
pf [F\
u : pf [F\ ⊢
u
:
pf [F\
The remaining two constraints are solved by the variable typing rule. Note
that this step involves verifying the equivalence of the objects [F\ from the
assumption and the goal. This concludes the reconstruction and checking of
the entire proof. We reconstructed the full representation of the proof by in-
stantiating all placeholders with well-typed LF objects. We know that these
instantiations are well-typed because they are ultimately extracted from the
original constraint type, which is assumed to contain only well-typed sub-
terms.
The formalization of the reconstruction algorithm described informally
above is in two stages. First, we show a variant of the LF type system, called
implicit LF or LFi, that extends LF with placeholders. This type system has the
property that all well-typed LFi terms can be reconstructed to well-typed LF
terms. However, unlike the original LF type system, the LFi type system is not
amenable to a direct implementation of deterministic type checking. Instead,
we use a separate reconstruction algorithm.
An object M is fully reconstructed, or fully explicit, when it is placeholder
free. We write PF(M) to denote this property. We extend this notation to type
environments and write PF(Γ) to denote that all types assigned in Γ to vari-
ables are placeholder free.
The LFi typing rules are an extension of the LF typing rules with two new
typing rules for dealing with implicit abstraction and placeholders, and one
new β-equivalence rule dealing with implicit abstraction. These additions are
shown in Figure 5-14. The LFi typing judgment is written Γ ⊢
i M : A.
Note that according to the LFi type system placeholders cannot occur on
a function position, but only as arguments in an application. This restriction
allows us to simplify the reconstruction algorithm by avoiding higher-order
uniﬁcation. Note also that several LFi rules require that the types involved
do not contain placeholders. This restriction simpliﬁes greatly the proofs of
soundness of the reconstruction algorithms and does not seem to diminish
the eﬀectiveness of the LFi representation.
A quick analysis of the LFi typing rules reveals that they are not directly
useful for type checking or type inference. The main reason is that type check-
ing an application involves “guessing” appropriate A and N. The type A can
sometimes be recovered from the type of the application head, but the term

214
5
Proof-Carrying Code
Objects
Γ ⊢
i M : A
Γ ⊢
i M : A
A ≡βη B
PF(A)
Γ ⊢
i M : B
Γ, x : A ⊢
i M : B
Γ ⊢
i λx:∗.M : Πx:A.B
Γ ⊢
i M : Πx:A.B
Γ ⊢
i N : A
PF(A)
Γ ⊢
i M N : [N/x]B
Γ ⊢
i M : Πx:A.B
Γ ⊢
i N : A
PF(A)
Γ ⊢
i M ∗: [N/x]B
Equivalence
M ≡βη N
(λx:∗.M)N ≡βη [N/x]M
Figure 5-14: The rules that are new in the LFi type system
N in an application to a placeholder cannot be found easily in general. This
is not a problem for us because we need the LFi type-system only as a step in
proving the correctness of the type-reconstruction algorithm, and not as the
basis for an implementation of a type-checking algorithm.
The only property of interest of the LFi type system is that once we have
a typing derivation we can reconstruct the object involved and a correspond-
ing LF typing derivation for it. To make this more precise we introduce the
notation M ↗M′ to denote that M′ is a fully-reconstructed version of the
implicit object M (i.e., PF(M′)). This means that M′ can be obtained from M
by replacing all of its placeholders with fully-explicit LF objects. Note that the
reconstruction relation is not a function as there might be several reconstruc-
tions of a given implicit object or type.
5.5.5
Theorem [Soundness of LFi typing]: If Γ ⊢
i
M : A and PF(Γ), PF(A), then
there exists M′ such that M ↗M′ and Γ ⊢
LF M′ : A.
2
5.5.6
Exercise [««, 3]: Prove Theorem 5.5.5
2
5.6
Proof Generation
We have seen that a successfully checked proof of the veriﬁcation condition
guarantees that the veriﬁcation condition is valid, which in turn guarantees
that the code adheres to the safety policy. The PCC infrastructure is simple,
easy-to-trust and automatic. But this is only because all the diﬃcult tasks
have been delegated to the code and proof producers. The ﬁrst diﬃcult task,
besides writing code that is indeed safe, is to generate the code annotations
consisting of loop invariants for all loops and of function speciﬁcations for all

5.6
Proof Generation
215
Figure 5-15: Interaction between untrusted PCC tools (continuous lines)
and trusted PCC infrastructure (interrupted lines)
local functions. The other diﬃcult task is to prove the veriﬁcation condition
produced by the veriﬁcation-condition generator.
Fortunately there are important situations when both the generation of
the annotations and of the proof can be automated. Consider the situation
in which there exists a high-level language, perhaps a domain-speciﬁc one,
in which the safety policy is guaranteed to be satisﬁed by a combination of
static and run-time checks. For example, if the safety policy is memory safety
then any memory-safe high-level language can be used. The key insight is that
in these systems the safety policy is guaranteed to hold by the design of the
static and run-time checks. In essence, the high-level type checker acts as a
theorem prover. All we have to do is to show that a suﬃcient number and
kind of static and run-time checks have been performed.
Figure 5-15 shows the interaction between the untrusted PCC tools used by
the code producer and the trusted PCC infrastructure used by the code re-
ceiver. The annotations are generated automatically by a certifying compiler
from high-level language to assembly language. For safety polices that follow
closely the high-level type system, it is surprisingly easy for a compiler to
produce the loop invariants, which are essentially conjunctions of type dec-
larations for the live registers at the given program point. This is information
that the compiler can easily maintain and emit.
Before it can generate the required proofs, the code producer must pass
the annotated code to a local copy of VCGen. The proof itself is generated by
a theorem prover customized for the speciﬁc safety policy. As discussed in
Section 5.3, such a theorem prover is little more than a type checker. However,
unlike a regular type checker or theorem prover, the PCC theorem prover
must generate explicit representation of the proofs. The architecture shown
in Figure 5-15 is described in detail in Necula (1998).

216
5
Proof-Carrying Code
Figure 5-16: A privacy policy
5.7
PCC beyond Types
The presentation of PCC so far has focused on type-based safety policies. We
have shown that veriﬁcation condition generation followed by theorem prov-
ing can overcome many of the diﬃculties of type checking programs written
in low-level languages. It should be obvious that we can take the example
that we used so far and change the type system by simply changing the proof
rules, with no changes to the infrastructure itself. But the machinery we have
constructed in the process can be used to enforce more complex safety po-
lices than are usually associated with types. And we can do this with very
few changes, thanks both to the modular design of the infrastructure and to
the choice of using the lower-level mechanism of logic rather than commit-
ting to a high-level type system. However, everytime the set of proof rules is
changed, one must redo the proof of soundness. In this section, we explore
one example of a safety policy that goes beyond types.
Consider a safety policy that allows access to two host services: read the
contents of a local ﬁle and send data over the network. The host wishes to
enforce the policy that the agent cannot send data after it has read local ﬁles.
This is a conservative way to ensure that no local ﬁle contents will be leaked.
This example is taken from Schneider (2000).
This safety policy can be described using the state machine shown in Fig-
ure 5-16. Initially the agent is in the public state in which it can use both the
send and the read services. However, once it uses the read service the agent
transitions in the private state, in which it can use only the read service.
In order to enforce such a safety policy, it is suﬃcient to check that the
send service cannot be used after the read service has been used. At the
level of assembly language, these services would be most likely implemented
as function calls. In that case the privacy safety policy can be implemented as
a precondition on the send function. Instead of introducing a general mecha-
nism for handling function calls (see Exercise 5.3.5), we use a special-purpose
handling of the instructions call read and call send.

5.7
PCC beyond Types
217
In the presentation of PCC from previous sections, there is no element
of the state of the computation that reﬂects whether a certain function has
been invoked or not. One way to address this issue is to require that the agent
code keep track of its own public/private state at run-time, presumably in a
register or a memory location. Then the postcondition of read would require
that this state element reﬂect the private state and the precondition of send
would require that the state element reﬂect the public state. This strategy
is appropriate when the producer of the agent code wishes to use run-time
checking to enforce the safety policy, in which case it would have to prove
that the appropriate checks have been inserted. This strategy also has the
beneﬁt of not requiring any changes in the PCC infrastructure.
We will pursue another alternative. We will modify VCGen and the symbolic
evaluator to keep track of the public/private state. And since we prefer to ex-
tend the PCC infrastructure with a general-purpose mechanism rather than a
speciﬁc policy, the VCGen extension should be able to record any information
about the history of the execution, not just its public/private state.
For this purpose we extend the symbolic evaluation state with another
pseudo-register, called rH to store a sequence of interesting events in the
past of the computation. The set of symbolic expressions that this register
can have are shown below:
Histories
H
::=
x | event V H
Events
V
::=
init | read | send
Additionally we add a number of formulas that we can use for stating prop-
erties of the history of execution:
Formulas
F
::=
. . . | publicState H | privateState H
As usual when we extend the language of formulas we must also extend
the proof rules. For our safety policy we add the following three proof rules:
publicState (event init H)
(init)
publicState H
publicState (event send H)
(send)
privateState (event read H)
(read)
The deﬁnition of the VCGen and the symbolic evaluator can remain un-
changed for the instructions considered so far, except that the rH register
can be used in loop invariants and function preconditions and postcondi-
tions. In particular, for the privacy safety policy the invocations of the read

218
5
Proof-Carrying Code
and send services can be handled in the symbolic evaluator as follows:
SE(i, σ) =



. . .
SE(i + 1, σ[rH ←(σ (event read rH))])
if Πi = call read
publicState (σ rH) ∧
if Πi = call send
SE(i + 1, σ[rH ←(σ (event send rH))])
The symbolic evaluator extends the history state with information about
the services that were used. Additionally, the send call requires through
its precondition that the history of the computation be consistent with the
public state of the safety policy. A realistic symbolic evaluator would sup-
port a general-purpose function call instruction, in which case the eﬀect of
the read and send functions could be achieved by appropriate function pre-
conditions and postconditions.
5.7.1
Exercise [««, 3]: Add two actions lock e and unlock e that can be used
to acquire and release a lock that is denoted by the expression e. Deﬁne a
PCC safety policy (extensions to the logic, new proof rules and changes to
the symbolic evaluator) that requires correct use of locks: a lock cannot be
acquired or released twice in a row, and the agent must release all locks upon
return.
2
5.7.2
Exercise [««, 3]: The veriﬁcation-condition generator that we described in
Section 5.3 cannot enforce a safety policy that allows the agent to “probe” the
accessibility of a memory page by attempting a read from an address within
that page. This is a common way to check for stack overﬂow in many systems.
Show how you can change the symbolic evaluator to use the history register
for the purpose of specifying such a safety policy.
2
This example shows how to use PCC for safety policies that go beyond type
checking. In fact, PCC is extremely powerful in this sense. Any safety policy
that could be enforced by an interpreter using run-time checking could in
principle be enforced by PCC. A major advantage of PCC over interpreters is
that it can check properties that would be very expensive to check at run time.
Consider, for example, how complicated it would be to write an interpreter
that enforces at run-time a ﬁne grained memory safety policy. Each memory
word would have to be instrumented with information whether it is accessible
or not. By comparison, we can use PCC along with a strong type system to
achieve the same eﬀect, with no run-time penalty.

5.8
Conclusion
219
5.8
Conclusion
Below is a list of the most important ways in which PCC improves over other
existing techniques for enforcing safe execution of untrusted code:
•
PCC operates at load time before the agent code is installed in the host
system. This is in contrast with techniques that enforce the safety policy
by relying on extensive run-time checking or even interpretation. As a re-
sult PCC agents run at native-code speed, which can be ten times faster
than interpreted agents (written for example using Java bytecode) or 30%
faster than agents whose memory operations are checked at run time.
Additionally, by doing the checking at load time it becomes possible to en-
force certain safety policies that are hard or impossible to enforce at run
time. For example, by examining the code of the agent and the associated
“explanation” PCC can verify that a certain interrupt routine terminates
within a given number of instructions executed or that a video frame ren-
dering agent can keep up with a given frame rate. Run-time enforcement
of timing properties of such ﬁne granularity is hard.
•
The trusted computing base in PCC is small. PCC is simple and small be-
cause it has to do a relatively simple task. In particular, PCC does not have
to discover on its own whether and why the agent meets the safety policy.
•
For the same reason, PCC can operate even on agents expressed in native-
code form. And because PCC can verify the code after compilation and op-
timization, the checked code is ready to run without needing an additional
interpreter or compiler on the host. This has serious software engineering
advantages since it reduces the amount of security critical code and it is
also a beneﬁt when the host environment is too small to contain an in-
terpreter or a compiler, such as is the case for many embedded software
systems.
•
PCC is general. All PCC has to do is to verify safety explanations and to
match them with the code and the safety policy. By standardizing a lan-
guage for expressing the explanations and a formalism for expressing the
safety policies, it is possible to implement a single algorithm that can per-
form the required check, for any agent code, any valid explanation and a
large class of safety policies. In this sense a single implementation of PCC
can be used for checking a variety of safety policies.
The PCC infrastructure is designed to complement a cryptographic authen-
tication infrastructure. While cryptographic techniques such as digital sig-
natures can be used by the host to verify external properties of the agent

220
5
Proof-Carrying Code
program, such as freshness and authenticity, or the author’s identity, the
PCC infrastructure checks internal semantic properties of the code such as
what the code does and what it does not do. This enables the host to prevent
safety breaches due to either malicious intent (for agents originating from un-
trusted sources) or due to programming errors (for agents originating from
trusted sources).
However, proof-carrying code is not without costs. The most notable chal-
lenge to using PCC is the diﬃculty of producing code annotations and proofs.
In some cases, these can be produced automatically based on some high-level
language invariants. But in general a human is required to be involved and the
more complex the safety policy the more onerous the burden of proof can be
expected to be. All that PCC oﬀers in this direction is a way to shift this bur-
den from the code received to the code producer who can be expected to have
more computational power, and especially more knowledge of why the code
satisﬁes the safety policy.
Proof-carrying code is a witness to the fact that programming language
technology and type theory are the basis of valuable techniques for solving
practical engineering problems. However, in the process of applying these
techniques for the design of a PCC infrastructure, it became necessary to
adapt the oﬀ-the-shelf techniques in non-trivial ways to the particular ap-
plication domain. Some of that adaptation can be carried out in a theoretical
setting, such as the extension of Edinburgh LF to implicit LF, while other parts
involve real engineering.

P a r t I I I
Types and Reasoning
about Programs


6
Logical Relations and a Case Study in
Equivalence Checking
Karl Crary
Logical relations are a fundamental technique for proving properties of pro-
gramming languages. Logical relations arise when a property is to be proven
of all well-formed terms in the language, but that property is not preserved
by one or more of the language’s elimination forms. For example, one such
property is termination: if a function expression tfun and its argument targ
both terminate, it does not follow that the application of tfun to targ necessar-
ily terminates.
In cases such as this, it is impossible to prove directly by induction on
typing derivations that all well-formed terms enjoy the property in question.
However, such a property may nevertheless be true; for example, normaliza-
tion holds for all well-typed terms in the simply typed lambda-calculus (TAPL,
Chapter 12). Logical relations surmount this diﬃculty by proving a stronger
property based on a term’s type. In the example above, for tfun one would
show (informally speaking) not only that tfun itself terminates, but also that
any application of tfun to a terminating argument also terminates.
The classic application of logical relations is to prove various sorts of termi-
nation properties, especially strong normalization (Tait, 1967). A very simple
example of a logical relation argument is given in TAPL, Chapter 12, to prove
a simple termination result. However, the technique has wide applicability
beyond just termination properties. This chapter will develop the technique
of logical relations via a case study in decision procedures for equivalence
of terms. Then, the next chapter will exploit this technique in developing a
powerful theory of typed operational reasoning.
This chapter draws on material from TAPL, Chapters 1 through 12, 23,
and 29. As usual, we will identify terms that diﬀer only in the names of bound
variables, and our substitution is capture avoiding. (Recall TAPL, §5.3.)

224
6
Logical Relations and a Case Study in Equivalence Checking
Syntax
t
::=
terms:
x
variable
λx:T.t
abstraction
t t
application
k
constant
T
::=
types:
b
base type
T→T
type of functions
Γ
::=
contexts:
∅
empty context
Γ, x:T
term variable binding
Typing
Γ ⊢t : T
x:T ∈Γ
Γ ⊢x : T
(T-Var)
Γ, x:T1 ⊢t2 : T2
Γ ⊢λx:T1.t2 : T1→T2
(T-Abs)
Γ ⊢t1 : T11→T12
Γ ⊢t2 : T11
Γ ⊢t1 t2 : T12
(T-App)
Γ ⊢k : b
(T-Const)
Equivalence
Γ ⊢s ≡t : T
Γ ⊢t : T
Γ ⊢t ≡t : T
(Q-Refl)
Γ ⊢t ≡s : T
Γ ⊢s ≡t : T
(Q-Symm)
Γ ⊢s ≡t : T
Γ ⊢t ≡u : T
Γ ⊢s ≡u : T
(Q-Trans)
Γ, x:T1 ⊢s2 ≡t2 : T2
Γ ⊢λx:T1.s2 ≡λx:T1.t2 : T1→T2
(Q-Abs)
Γ ⊢s1 ≡t1 : T1→T2
Γ ⊢s2 ≡t2 : T1
Γ ⊢s1 s2 ≡t1 t2 : T2
(Q-App)
Γ, x:T1 ⊢s12 ≡t12 : T2
Γ ⊢s2 ≡t2 : T1
Γ ⊢(λx:T1.s12) s2 ≡[x , t2]t12 : T2
(Q-Beta)
Γ, x:T1 ⊢s x ≡t x : T2
Γ ⊢s ≡t : T1→T2
(Q-Ext)
Figure 6-1: Simply typed lambda-calculus with a base type (λ→b)
6.1
The Equivalence Problem
We are concerned with the problem of determining whether or not two terms
in the simply typed lambda calculus are equivalent. The system we will con-
sider is formulated in Figure 6-1. In order that the problem not be trivial, the
system includes a single base type b that is inhabited by an unspeciﬁed set
of constants. The constants are ranged over by the metavariable k.
The equivalence judgment, which will be our key subject of concern, is
written Γ ⊢s ≡t : T, meaning that (in context Γ) the terms s and t are
equivalent, when considered as members of the type T. (The alert reader may
observe that the type T at which terms are compared does not play an impor-
tant role in the rules in Figure 6-1; however, it will be of critical importance
in our future developments.) It is important to observe that this notion of
equivalence is deﬁned directly, rather than by an appeal to an operational

6.2
Non-Type-Directed Equivalence Checking
225
semantics. For this reason, this form of equivalence is often referred to as
deﬁnitional equivalence.
The equivalence system consists of seven rules. The ﬁrst three rules ex-
press that term equivalence is an equivalence relation, and the next two rules
express that it is a congruence with respect to abstraction and application.
Finally, there are two substantiative rules. The ﬁrst expresses that a beta re-
dex is equivalent to its contractum. The second is an extensionality principle;
it says that two functions (i.e., terms of type T1→T2) are equivalent if all ap-
plications to an argument are equivalent.1 (A variable is used to stand in for
all possible arguments.)
Motivation
Term equivalence is important for a variety of reasons, but one of the most
important applications of the system relates not to the equivalence of terms,
but of types. Recall the language λω from TAPL, Chapter 29. In λω the type
system provided type expressions of higher kind in order to provide a facility
for type operators. As a result, the type system of λω was essentially a copy
of the simply typed lambda calculus “one level up,” in which terms became
types and types became kinds.
Conversely, we may view the simply typed lambda calculus as the type
system of λω viewed “one level down,” in which types become terms and
kinds become types. Thus, the type b in λ→b corresponds to the kind ∗of
types in λω. By solving the problem of checking equivalence of terms, we
also learn how to check equivalence of types, which is in turn essential to the
problem of type checking.
Note that λ→b contains no actual terms standing for types such as Nat;
they correspond to the uninterpreted constants k of type b. Terms standing
for built-in type operators such as →would correspond to constants of type
b→b→b. For simplicity, we include no such built-in operators, but they would
be easy to add.
6.2
Non-Type-Directed Equivalence Checking
The most common strategy for checking for term equivalence is normalize-
and-compare. To determine whether two well-typed terms, say s and t, are
1. Although extensionality considerably broadens deﬁnitional equivalence, many systems pre-
fer to omit extensionality because it can sometimes complicate equivalence checking. However,
for the approach to equivalence checking we discuss in this chapter, extensionality actually
simpliﬁes matters, so we do not hesitate to include it.

226
6
Logical Relations and a Case Study in Equivalence Checking
equal, the strategy computes their normal forms s′ and t′ using a reduction
relation derived from the equivalence rules and then compares to see if s′
and t′ are identical.2 The original terms s and t are equivalent if and only if
the normal forms s′ and t′ are identical.
Normalize-and-compare relies on three facts:
•
One must be able to derive a reduction relation s⇒t from the equivalence
rules. This relation must be suitable in the sense that, if Γ ⊢s : T and
Γ ⊢t : T, then Γ ⊢s ≡t : T iﬀs a∗t, where a∗is the symmetric,
transitive closure of ⇒. For λ→b a suitable relation is given in Figure 6-2.
•
The reduction relation must be conﬂuent, meaning that if r ⇒∗s and
r ⇒∗t then there exists some term u such that s ⇒∗u and t ⇒∗u. If the
relation is conﬂuent, then its symmetric, transitive closure may be decided
by comparing normal forms, as stated by Lemma 6.2.1 below.
•
The reduction relation must be normalizing, meaning that every term must
have a normal form, and those normal forms must be eﬀectively com-
putable. Given the existence and computability of normal forms, one may
use the preceding two facts to show that two terms are equivalent exactly
when their normal forms coincide.
6.2.1
Lemma: Suppose ⇒is conﬂuent and the normal forms of s and t are s′ and
t′. Then sa∗t iﬀs′ = t′.
2
Proof:
Exercise [««, 3].
2
In summary, to employ the normalize-and-compare strategy, one must de-
ﬁne a suitable reduction relation, and prove that it is suitable, conﬂuent, and
normalizing. In some cases, the strategy is not applicable, either because the
suitable relation fails to be conﬂuent and normalizing, or because no suitable
relation can be deﬁned in the ﬁrst place. It is this latter case that will arise
in the next section. In fact, many proofs of normalization employ a logical
relation (such as those in the presence of polymorphism [Girard, Lafont, and
Taylor, 1989]), so the normalize-and-compare strategy, even when applicable,
often still involves logical relations.
6.2.2
Exercise [««]: Prove one half of the suitability of ⇒for deﬁnitional equiv-
alence: if Γ ⊢s ≡t : T then s a∗t. (Hint: in the case for Q-Ext, use the
reduction rule QR-Eta.)
2
2. Actually, nearly all implementations of equivalence checkers reﬁne this strategy to inter-
leave comparison with the computation of normal forms. This is done for two reasons: First, if
the terms are inequivalent, it can be detected earlier. Second, once any corresponding compo-
nents of the normal forms are determined to be equivalent, they can be discarded. Thus, one
can avoid storing the entire normal forms, which can be large.

6.3
Type-Driven Equivalence
227
Parallel reduction
s ⇒t
t ⇒t
(QR-Refl)
s2 ⇒t2
λx:T1.s2 ⇒λx:T1.t2
(QR-Abs)
s1 ⇒t1
s2 ⇒t2
s1 s2 ⇒t1 t2
(QR-App)
s1 ⇒t1
s2 ⇒t2
(λx:T1.s1) s2 ⇒[x , t2]t1
(QR-Beta)
s ⇒t
x not free in s
λx:T.s x ⇒t
(QR-Eta)
Figure 6-2: Parallel reduction of terms
New syntactic forms
t
::=
. . .
terms:
unit
unit term
T
::=
. . .
types:
Unit
unit type
Typing
Γ ⊢t : T
Γ ⊢unit : Unit
(T-Unit)
Equivalence
Γ ⊢s ≡t : T
Γ ⊢s : Unit
Γ ⊢t : Unit
Γ ⊢s ≡t : Unit
(Q-Unit)
Figure 6-3: Unit type (λ→b1)
6.2.3
Exercise [««]: Because of the rule QR-Eta, the reduction relation ⇒is conﬂu-
ent only for well-typed terms. Give an example of an ill-typed term for which
conﬂuence fails.
2
6.3
Type-Driven Equivalence
One case in which the normalize-and-compare strategy is inapplicable is when
the deﬁnition of equivalence is type sensitive. The example we will work with
arises when we add a second base type corresponding to Unit (recall TAPL,
§11.2). The important thing about this type is that it contains exactly one
element; the sole element of Unit is written unit. These additions are sum-
marized in Figure 6-3.
The interesting facet of the extension with unit is its equivalence rule:
Γ ⊢s : Unit
Γ ⊢t : Unit
Γ ⊢s ≡t : Unit
(Q-Unit)
This rule expresses the fact that, since the type Unit contains exactly one
element, any two elements of Unit must actually be the same. It is important

228
6
Logical Relations and a Case Study in Equivalence Checking
to note that this rule is strictly stronger than the alternative rule:
Γ ⊢unit ≡unit : Unit
(Q-Unit-Weak)
Although Q-Unit-Weak is sound (indeed, it is derivable from either Q-Unit
or Q-Refl), it cannot derive equivalences involving unit variables, such as:
T-Unit
x:Unit, y:Unit ⊢x : Unit
T-Unit
x:Unit, y:Unit ⊢y : Unit
Q-Unit
x:Unit, y:Unit ⊢x ≡y : Unit
This example also illustrates why the normalize-and-compare strategy is
inapplicable once the unit type is added. The terms x and y must be judged to
be equivalent, but the reason for this has nothing to do with the form of x or
y. Indeed, x and y are already in normal form according to the usual reduction
relation. The terms must be judged equivalent because of their types, and the
normalize-and-compare strategy has no way to account for that.
There are a variety of ways to address this diﬃculty. Many repair the
normalize-and-compare strategy by, in one way or another, giving it the abil-
ity to exploit type information. However, we will consider an entirely diﬀerent
strategy, an algorithm that tests for equivalence directly, without computing
normal forms.
6.3.1
Exercise [«]: The need for types in deciding equivalence is not limited to
open terms. Give two closed terms that are equivalent but have distinct nor-
mal forms.
2
6.4
An Equivalence Algorithm
We wish to devise an algorithm for the equivalence problem. Stated precisely,
the problem is this: Supposing Γ ⊢s : T and Γ ⊢t : T, determine whether or
not Γ ⊢s ≡t : T.
To solve this problem, we will employ a type-driven algorithm. This algo-
rithm is based on two main observations:
1. If T is Unit, we can immediately return true. This is because we then have
Γ ⊢s : Unit and Γ ⊢t : Unit from our assumptions, and Γ ⊢s ≡t :
Unit follows directly by Q-Unit.
2. If T is T1→T2, we can reduce the problem to a related problem where T is
just T2. To do so, we replace any query of the form:
Γ ⊢s
?≡t : T1→T2

6.4
An Equivalence Algorithm
229
with the equivalent query:
Γ, x:T1 ⊢s x
?≡t x : T2
These queries are equivalent because the latter judgment immediately im-
plies the former using the Q-Ext rule, and the former implies the latter
using the Q-App rule and a weakening lemma:
6.4.1
Lemma [Weakening]: If Γ ⊢s ≡t : T then Γ, x:S ⊢s ≡t : T.
2
Proof:
Straightforward induction on equivalence and typing derivations.
(Recall TAPL Lemma 9.3.7.)
2
The signiﬁcance of these observations is that they give us a means to re-
duce an equivalence problem at an arbitrary type to one at the base type b.
Therefore, it remains only to ﬁnd an algorithm that decides equivalence at
type b.
Equivalence at Base Type
At type b we can use a variant of the normalize-and-compare strategy. Infor-
mally, this is because we address elsewhere the type Unit, which mandated
type-directed consideration. The normalization phase (discussed in detail be-
low) will place the equivalence problem in one of ﬁve forms (or a symmetric
form):3
1. Γ ⊢x s1 ... sn
?≡x t1 ... tn : b
2. Γ ⊢k
?≡k : b
3. Γ ⊢x s1 ... sm
?≡y t1 ... tn : b (where x ≠y)
4. Γ ⊢x s1 ... sn
?≡k : b
5. Γ ⊢k
?≡k′ : b (where k ≠k′)
Clearly, in case 2 we may immediately return true, and in case 5 we may
immediately return false. We may also return false in case 3, since we know
nothing about what the variables x and y represent, and therefore they could
return distinct types. Similarly, we can return false for case 4.
3. Note that in case 1, x must be applied to the same number of arguments on each side, since
both sides have the same type.

230
6
Logical Relations and a Case Study in Equivalence Checking
However, in case 1, a subtlety remains: Suppose, for example, that we wish
to determine whether x s ≡x t : b, where x has the type T→b, and s and t
have type T. Since we know nothing about what the variable x represents, this
equivalence holds exactly when s ≡t : T. Thus, although x s ≡x t : b is an
equivalence problem at type b, to decide it we must still decide an equivalence
problem at type T (which could be anything, such as Unit), and we have seen
that we cannot do so with a simple syntactic comparison.
Thus, if the normalization portion of the normalize-and-compare phase
writes the problem in the form:
Γ ⊢x s1 ... sn
?≡x t1 ... tn : b
the comparisons of si to ti should be done using the entire type-driven algo-
rithm, and not simple syntactic comparison.
Weak Head Normalization
One additional insight is necessary to understand the algorithm. Since the
comparison portion works on a term of the form x t1 ... tn by using the
entire algorithm on the subterms ti, there is no point in normalizing the
term any more than is required to put it in that form.
For example, if we wish to determine whether x s ≡x t : b, where x has the
type Unit→b, and s and t have type Unit, the answer will always be true, so
any eﬀort spent normalizing s or t is wasted.
Consequently, our algorithm will employ a less aggressive form of nor-
malization called weak head normalization. In weak head normalization, the
leftmost, outermost redex is always selected for reduction, and the process
is halted as soon as the term begins with something other than a lambda
abstraction.
Such terms of type b will always either be a constant k or be in the form
x t1 ... tn. These terms are called paths. (Although some other terms—such
as abstractions—are also weak head normal, those other terms cannot have
type b so they will not arise.)
The Algorithm
An algorithm based on the preceding observations is given in Figure 6-4. The
algorithm is given in the form of rules deﬁning four relations:
1. Algorithmic term equivalence: Γ ⊢s a t : T. This portion of the algorithm
is directed by the type T. It works by driving the type T down to b. All of Γ,
s, t, and T are inputs to this relation.

6.4
An Equivalence Algorithm
231
Syntax
p, q
::=
paths:
x
variable
p t
application
k
constant
Weak head reduction
s ; t
(λx:T11.t12) t2 ; [x , t2]t12 (QAR-Beta)
t1 ; t′
1
t1 t2 ; t′
1 t2
(QAR-App)
Weak head normalization
s ⇓t
s ; t
t ⇓u
s ⇓u
(QAN-Reduce)
t ̸;
t ⇓t
(QAN-Normal)
Algorithmic term equivalence
Γ ⊢s a t : T
s ⇓p
t ⇓q
Γ ⊢p ↔q : b
Γ ⊢s a t : b
(QAT-Base)
Γ, x:T1 ⊢s x a t x : T2
Γ ⊢s a t : T1→T2
(QAT-Arrow)
Γ ⊢s a t : Unit
(QAT-One)
Algorithmic path equivalence
Γ ⊢p ↔q : T
x:T ∈Γ
Γ ⊢x ↔x : T
(QAP-Var)
Γ ⊢p ↔q : T1→T2
Γ ⊢s a t : T1
Γ ⊢p s ↔q t : T2
(QAP-App)
Γ ⊢k ↔k : b
(QAP-Const)
Figure 6-4: Equivalence algorithm for λ→b1
2. Algorithmic path equivalence: Γ ⊢p ↔q : T. This portion of the algorithm
is directed by the structure of the paths p and q. It works by checking
that the head variables of p and q are the same (or that p and q are the
same constant), and then comparing corresponding subterms of the path
for algorithmic term equivalence. The type T is an output of this relation,
and Γ, p, and q are inputs.
3. Weak head reduction: s ; t. This portion of the algorithm reduces one
redex at the head of the term s. It implements one step of weak head
normalization.
4. Weak head normalization: s ⇓t. This portion of the algorithm computes
weak head normal forms by performing weak head reductions until no
more can be performed. (We write t ̸; to mean that there exists no term
t′ such that t ; t′.)
6.4.2
Exercise [««, 3]: Hand-execute the algorithm on:
f:(Unit→Unit)→b ⊢f (λx:Unit.unit)
?a f (λx:Unit.x) : b→b
2

232
6
Logical Relations and a Case Study in Equivalence Checking
6.4.3
Exercise [««««, 3]: Prove that the algorithm is sound. That is, show that if
Γ ⊢s a t : T (where Γ ⊢s : T and Γ ⊢t : T) then Γ ⊢s ≡t : T.
2
6.5
Completeness: A First Attempt
There are two parts to showing that the algorithm is correct. First, we wish to
show that the algorithm is sound; that is, that the algorithm says yes only for
equivalent terms. We considered soundness in Exercise 6.4.3. Second, we wish
to show that the algorithm is complete; that is, that the algorithm says yes for
all equivalent terms. Completeness is a good deal trickier than soundness,
and is the subject of the remainder of this chapter.
We wish to show the following result:
6.5.1
Proposition: If Γ ⊢s ≡t : T then Γ ⊢s a t : T.
2
Our ﬁrst attempt to prove this would naturally be to try proving it directly
by induction on derivations. This attempt encounters a variety of diﬃculties,
most of which are surmountable. Because of the Q-Refl rule, we must ﬁrst
prove something about typing:
6.5.2
Proposition: If Γ ⊢t : T then Γ ⊢t a t : T.
2
With this addition, several cases for the two propositions go through with-
out diﬃculty: for Proposition 6.5.1, T-Const and T-Unit; and for Proposi-
tion 6.5.2, Q-Refl, Q-Ext, and Q-Unit. Four other rules are more diﬃcult, but
can be dealt with, as follows:
•
Cases Q-Symm and Q-Trans: For these cases, we must prove lemmas stating
that the algorithm is symmetric and transitive (Lemmas 6.5.3 and 6.5.4
below).
•
Case Q-Abs (T-Abs is similar): Here we wish to show that Γ ⊢λx:T1.s2 a
λx:T1.t2 : T1→T2, for which we must prove that:
Γ, x:T1 ⊢(λx:T1.s2)x a (λx:T1.t2)x : T2
However, the induction hypothesis provides us a related but diﬀerent fact:
Γ, x:T1 ⊢s2 a t2 : T2
To conclude this case from the available information, we need another
lemma stating that the algorithm is closed under weak head expansion
(Lemma 6.5.5 below).

6.6
Logical Relations
233
6.5.3
Lemma [Algorithmic Symmetry]: If Γ ⊢s a t : T then Γ ⊢t a s : T.
2
6.5.4
Lemma [Algorithmic Transitivity]: If Γ ⊢s a t : T and Γ ⊢t a u : T
then Γ ⊢s a u : T.
2
Proof:
Both proofs are by induction on derivations, with a simultaneous in-
duction showing the analogous property for algorithmic path equivalence. 2
6.5.5
Lemma [Algorithmic Weak Head Closure]: If Γ ⊢s a t : T and s′ ;∗s
and t′ ;∗t then Γ ⊢s′ a t′ : T.
2
Proof:
By induction on the derivation of algorithmic term equivalence.
2
6.5.6
Exercise [«, 3]: Verify Lemma 6.5.5.
2
Trouble with Application
This leaves four rules: two dealing with application (T-App and Q-App), and two
dealing with variables and substitution (T-Var and Q-Beta). It is the applica-
tion rules that bring the proof attempt to a standstill.4
The essential problem is that the induction hypothesis gives us no infor-
mation about what happens when a term is applied to an argument. Consider
the case Q-App:
Γ ⊢s1 ≡t1 : T1→T2
Γ ⊢s2 ≡t2 : T1
Γ ⊢s1 s2 ≡t1 t2 : T2
(Q-App)
The induction hypothesis gives us that Γ ⊢s1 a t1 : T1→T2 and Γ ⊢s2 a
t2 : T1. We wish to conclude that Γ ⊢s1 s2 a t1 t2 : T2, but we cannot.
By inversion on Γ ⊢s1 a t1 : T1→T2 we obtain the fact that Γ, x:T1 ⊢
s1 x a t1 x : T2, but that is as close as we get, since the behavior of the algo-
rithm comparing s1 x to t1 x is entirely diﬀerent from its behavior comparing
s1 s2 to t1 t2.
6.6
Logical Relations
The problem discussed above arises because the algorithmic equivalence re-
lation is not logical, in the following sense:5
4. The variable and substitution rules could be addressed using a device we develop in Sec-
tion 6.9, but we will not bother to employ it here, since this proof attempt is doomed by
application.
5. Actually, it is more precise to say that algorithmic term equivalence is not evidently logical;
that is, we cannot prove it at this stage in the proof. (See Exercise 6.9.12.)

234
6
Logical Relations and a Case Study in Equivalence Checking
6.6.1
Definition: Suppose R(s, t, T) is a relation indexed by types T, such that s
and t are terms having type T. Then R is logical if whenever R(s1, t1, T1→T2)
and R(s2, t2, T1) hold, it follows that R(s1 s2, t1 t2, T2) also holds.
2
That is, a relation is logical when the relatedness of two applications s1 s2
and t1 t2 is inherited from the pairwise relatedness of their constituent func-
tion and argument (s1 with t1, and s2 with t2). Such a relation is called
“logical” because it respects the actions of the logical operators (in this case
implication) that correspond to the language’s type constructors.
The idea behind proof by logical relations is to circumvent problems result-
ing from the absence of logicality by deﬁning another relation that is logical,
and that also implies the desired property (in this case algorithmic equiva-
lence). The new, logical relation is then used in the induction hypothesis in
the proof.
Our overall proof strategy, then, consists of three stages:
1. Deﬁne a suitable logical relation. When two terms are related by the logical
relation, we will say that they are logically equivalent.
2. Show that logical equivalence implies algorithmic equivalence.
3. Show that deﬁnitional equivalence implies logical equivalence.
A Logical Relation
A direct way to deﬁne a logical relation is essentially by ﬁat. The deﬁnition
proceeds inductively by cases on the index type, asserting algorithmic equiv-
alence at base types, and asserting exactly the necessary property at function
types. This gives us the following ﬁrst attempt at a deﬁnition of logical equiv-
alence:
Γ ⊢s is t : T if and only if either:
T=Unit,
or T=b and Γ ⊢s a t : b,
or T=T1→T2 and for all s′, t′,
if Γ ⊢s′ is t′ : T1
then Γ ⊢s s′ is t t′ : T2.
Note that the ﬁrst clause of the deﬁnition could equivalently be “T=Unit and
Γ ⊢s a t : Unit,” since the algorithmic equivalence at Unit always holds.

6.6
Logical Relations
235
Monotonicity
This relation is clearly logical, and at base types it just as clearly implies al-
gorithmic equivalence. The question is, does it imply algorithmic equivalence
at function types? The answer turns out to be almost, but not quite:
Suppose Γ ⊢s is t : T1→T2. We wish to show that Γ ⊢s a t : T1→T2, for
which it is suﬃcient to show:
Γ, x:T1 ⊢s x a t x : T2
Since T2 is smaller than T1→T2, we can conclude by induction that the desired
algorithmic equivalence follows from the corresponding logical equivalence.
Thus it remains to show:
Γ, x:T1 ⊢s x is t x : T2
From the deﬁnition of logical equivalence, we can deduce the desired logical
equivalence from:
1. Γ, x:T1 ⊢s is t : T1→T2, and
2. Γ, x:T1 ⊢x is x : T1.
The latter is not obvious, but we will be able to prove it (for our ﬁnal def-
inition). The former, on the other hand, is very similar to our assumption,
Γ ⊢s is t : T1→T2. All we need to know is that logical equivalence is
preserved when bindings are added to the context. This property is called
monotonicity (or, preservation under weakening).
Failure of Monotonicity
Unfortunately, monotonicity fails for our current deﬁnition of logical equiva-
lence. It is not diﬃcult to show monotonicity for the algorithm:
6.6.2
Lemma [Algorithmic Monotonicity]: Suppose Γ ′ ⊇Γ. Then:
1. If Γ ⊢s a t : T then Γ ′ ⊢s a t : T.
2. If Γ ⊢p ↔q : T then Γ ′ ⊢p ↔q : T.
2
Proof:
By induction on derivations.
2
The lemma gives us monotonicity of logical equivalence for type b, and
logical equivalence is trivially monotone for type Unit. That leaves T1→T2,
where monotonicity fails.

236
6
Logical Relations and a Case Study in Equivalence Checking
To see why, let us attempt to prove the special case where the context is
extended with a single binding. We suppose Γ ⊢s is t : T1→T2 and attempt
to show Γ, x:S ⊢s is t : T1→T2. By the deﬁnition, it is suﬃcient to show
that if Γ, x:S ⊢s′ is t′ : T1 then Γ, x:S ⊢s s′ is t t′ : T2. Since T2 is
smaller than T1→T2, induction gives us monotonicity for T2, so it is suﬃcient
to show that Γ ⊢s s′ is t t′ : T2. This follows from our original supposition
by the deﬁnition of logical equivalence, provided that Γ ⊢s′ is t′ : T1.
Unfortunately, our second supposition provides only Γ, x:S ⊢s′ is t′ : T1.
Thus, at type T1 we need not monotonicity (which induction could provide),
but the converse, antitonicity (or, preservation under strengthening), which is
certainly false.
6.6.3
Exercise [«]: Let antitonicity be the property that if Γ, x:S ⊢s is t : T then
Γ ⊢s is t : T. Produce a counterexample for antitonicity.
2
6.6.4
Exercise [«««]: Suppose the language contains exactly one constant k. Pro-
duce a counterexample for monotonicity and give the proof.
2
6.7
A Monotone Logical Relation
Earlier we addressed the problem of logicality by ﬁat, crafting a deﬁnition
that provided exactly the necessary property. We can address the problem of
monotonicity in essentially the same manner. The problem is that the deﬁni-
tion’s clause for function types could hold for a context Γ, but not evidently
hold for a larger context Γ ′.
To resolve this diﬃculty, we revise the deﬁnition so that the clause for
function types must hold not only for the current context Γ, but also for any
extended context Γ ′ ⊇Γ. This gives us our ﬁnal deﬁnition of logical equiva-
lence:
6.7.1
Definition [Logical Equivalence]:
Γ ⊢s is t : T if and only if either:
T=Unit,
or T=b and Γ ⊢s a t : b,
or T=T1→T2 and, for all s′, t′ and all Γ ′ ⊇Γ,
if Γ ′ ⊢s′ is t′ : T1
then Γ ′ ⊢s s′ is t t′ : T2.
2
With this deﬁnition, we can easily prove the monotonicity of logical equiva-
lence:
6.7.2
Lemma [Logical Monotonicity]: If Γ ⊢s is t : T and Γ ′ ⊇Γ then Γ ′ ⊢s is
t : T.
2

6.8
The Main Lemma
237
Proof:
By induction on T, appealing to algorithmic monotonicity in the case
where T = b.
2
An Aside
A logical relation made monotone in this manner is often called a Kripke log-
ical relation, by analogy to Kripke models for modal logic. Modal logic is a
form of logic designed for reasoning about the diﬀerences between various
degrees or forms of truth, typically including contingent truths—truths that
happen to hold given the existing state of aﬀairs—and necessary (or “cate-
gorical”) truths, which must hold in any reasonable state of aﬀairs.
A Kripke model for modal logic is based on a set of “worlds,” where each
world supports a diﬀerent set of truths. The set of worlds is additionally
structured by a notion of which worlds are “reachable” from which other
worlds. In such a model, a contingent truth is one that holds in the current
world, and a necessary truth is one that holds in all worlds reachable from the
current world. (Any world not reachable from the current world is ignored,
since there is no way to observe its existence.)
The connection to Kripke models arises in the logical relation’s use of a
context Γ, which we may view as specifying a world. Each world provides a
diﬀerent set of variables, and we may reach another world by adding variables
to the current context. Thus, when we require that our logical relation be
monotone (that is, that it continues to hold in all reachable contexts), we are
saying that we are interested in necessary equivalence, not accidental (i.e.,
contingent) equivalence.6
6.8
The Main Lemma
With a monotone logical relation in hand, we are now ready to prove the com-
pleteness of the algorithm. Recalling our proof strategy from page 234, we
have accomplished the ﬁrst step, the deﬁnition of a suitable logical relation.
We now wish to show that logical equivalence implies algorithmic equiva-
lence. It will then remain to show that deﬁnitional equivalence implies logical
equivalence.
The former fact is established by the following “main lemma.” The Main
Lemma actually establishes two facts simultaneously. First, it shows that
logical equivalence implies algorithmic equivalence. To appreciate the sec-
ond fact, recall (from page 235) that to show that logical implies algorithmic
6. Exercise 6.6.4 in essence asks you to produce an example of an accidental equivalence, one
that holds only in a certain world.

238
6
Logical Relations and a Case Study in Equivalence Checking
equivalence, we also need to establish that variables are logically equivalent
to themselves. To do so, we prove the stronger result that algorithmically
equivalent paths are logically equivalent. The necessary result for variables
follows, since a variable is always algorithmically path equivalent to itself
(rule QAP-Var).
In the following proof, observe how inseparably the two induction hypothe-
ses of the lemma are intertwined. It is typical of logical relations proofs to use
a lemma such as this, wherein one clause of the lemma establishes the logical
relation and the other clause exploits it. This structure of the proof usually
results from the deﬁnition of the logical relation in the arrow case, where the
relation appears on both the left and the right of the implication.
6.8.1
Lemma [Main Lemma]:
1. If Γ ⊢s is t : T then Γ ⊢s a t : T.
2. If Γ ⊢p ↔q : T then Γ ⊢p is q : T.
2
Proof:
By induction on T.
Case:
T = b
1. Suppose Γ ⊢s is t : b. By deﬁnition, Γ ⊢s a t : b.
2. Suppose Γ ⊢p ↔q : b. Since p and q are paths, it follows that p ̸; and
q ̸;, so p ⇓p and q ⇓q by QAN-Normal. Therefore Γ ⊢p a q : b by
QAT-Base, and Γ ⊢p is q : b follows by the deﬁnition.
Case:
T = Unit
1. For any s and t, Γ ⊢s a t : Unit by QAT-One.
2. For any p and q, Γ ⊢p is q : Unit by the deﬁnition.
Case:
T = T1→T2
1. Suppose Γ ⊢s is t : T1→T2. We wish to show that Γ ⊢s a t : T1→T2.
It is suﬃcient to show that Γ, x:T1 ⊢s x a t x : T2. This will follow by
induction, if we can show that Γ, x:T1 ⊢s x is t x : T2.
By induction (using the second clause), since Γ, x:T1 ⊢x ↔x : T1 (by
QAP-Var), we may deduce that Γ, x:T1 ⊢x is x : T1. Therefore, since
(Γ, x:T1) ⊇Γ, we may conclude that Γ, x:T1 ⊢s x is t x : T2, as desired.
2. Suppose Γ ⊢p ↔q : T1→T2. We wish to show that Γ ⊢p is q : T1→T2.
Suppose further that Γ ′ ⊇Γ and Γ ′ ⊢s is t : T1. Then we wish to show

6.9
The Fundamental Theorem
239
that Γ ′ ⊢p s is q t : T2. This will follow by induction, if we can show that
Γ ′ ⊢p s ↔q t : T2.
By induction (using the ﬁrst clause), Γ ′ ⊢s a t : T1. By algorithmic mono-
tonicity (Lemma 6.6.2), Γ ′ ⊢p ↔q : T1→T2. Therefore, by rule QAP-App,
Γ ′ ⊢p s ↔q t : T2, as required.
2
6.9
The Fundamental Theorem
The ﬁnal step in the completeness proof is to show that deﬁnitional equiva-
lence implies logical equivalence. We will refer to the theorem showing this
fact as the “Fundamental Theorem.”
Recall our attempted proof from Section 6.5. The principal problem we en-
countered was with application; we could not deduce from the algorithmic
equivalence of two functions anything about the equivalence of their applica-
tions to arguments. We have solved that problem by using a logical relation,
which explicitly provides the necessary conclusions about applications.
Structural Properties of Logical Equivalence
Since we are now using logical equivalence in place of algorithmic equiva-
lence, we must revisit some of our other devices from Section 6.5. To ad-
dress the Q-Symm, Q-Trans, Q-Abs, and T-Ans, we showed that the algorithm is
symmetric, transitive, and closed under weak head reduction (Lemmas 6.5.3,
6.5.4, and 6.5.5). We will now require analogs of these lemmas applicable to
logical equivalence:
6.9.1
Lemma [Logical Symmetry]: If Γ ⊢s is t : T then Γ ⊢t is s : T.
2
Proof:
By induction on T, appealing to algorithmic symmetry (Lemma 6.5.3)
in the case where T = b.
2
6.9.2
Lemma [Logical Transitivity]: If Γ ⊢s is t : T and Γ ⊢t is u : T then
Γ ⊢s is u : T.
2
Proof:
Exercise [Recommended, ««, 3].
2
6.9.3
Lemma [Logical Weak Head Closure]: If Γ ⊢s is t : T and s′ ;∗s and
t′ ;∗t then Γ ⊢s′ is t′ : T.
2
Proof:
By induction on T; in the case where T = b, we appeal to algorithmic
weak head closure (Lemma 6.5.5).
2

240
6
Logical Relations and a Case Study in Equivalence Checking
Closure under Substitution
There remain two more cases we did not consider in Section 6.5, T-Var and
Q-Beta. We could deal with T-Var immediately, since a consequence of the
Main Lemma is that variables are logically equivalent to themselves. However,
we will actually end up dealing with T-Var somewhat diﬀerently in light of one
last remaining complication. (See the T-Var case of Theorem 6.9.8.)
That ﬁnal complication stems from the rule Q-Beta:
Γ, x:T1 ⊢s12 ≡t12 : T2
Γ ⊢s2 ≡t2 : T1
Γ ⊢(λx:T1.s12) s2 ≡[x , t2]t12 : T2
(Q-Beta)
Suppose we employ the obvious induction hypothesis: if Γ ⊢s ≡t : T then
Γ ⊢s is t : T. Then, for the Q-Beta case, we need to show that:
Γ ⊢(λx:T1.s12) s2 is [x , t2]t12 : T2
Using logical weak head closure (Lemma 6.9.3), it is suﬃcient to show that:
Γ ⊢[x , s2]s12 is [x , t2]t12 : T2
Induction provides us with Γ, x:T1 ⊢s12 ≡t12 : T2 and Γ ⊢s2 ≡t2 : T1.
Thus, we could complete the proof by showing that logical equivalence is
closed under logically equivalent substitutions. Unfortunately, it is not clear
how to prove such a proposition at this stage in the completeness proof, as
the form of the logical relation gives us no leverage on the matter.
The Theorem
Fortunately, we can work around this diﬃculty by building this notion of
equivalent substitutions into the Fundamental Theorem itself. First we re-
quire a few deﬁnitions:
6.9.4
Definition [Substitutions]: A substitution is a function from some set of
variables to terms.
2
6.9.5
Definition [Substitutions and Terms]: Suppose γ is a substitution and t
is a term such that the free variables of t are contained in dom(γ). Then we
write γ(t) to refer to the term resulting from simultaneously carrying out on
t all the substitutions speciﬁed by γ.
2
6.9.6
Definition [Substitution Extension]: Suppose x ̸∈dom(γ). Then we de-
ﬁne γ[x , t] as the substitution with domain dom(γ) ∪{x} such that:
(γ[x , t])(y) =
(
γ(y)
x ≠y
t
x = y
2

6.9
The Fundamental Theorem
241
6.9.7
Definition [Logically Equivalent Substitutions]: Logical equivalence of
substitutions is deﬁned as follows:
Γ ′ ⊢γ is δ : Γ if dom(γ) = dom(δ) = dom(Γ) and for every x:T ∈Γ we
have Γ ′ ⊢γ(x) is δ(x) : T.
2
Now we can state the Fundamental Theorem by uniformly considering all
equivalences under the application of equivalent substitutions. Since typing
never depends on equivalence, we can separate the Fundamental Theorem
into two parts (one for typing and one for equivalence) and prove each in
turn.
6.9.8
Theorem [Fundamental Theorem 1]: If Γ ⊢t : T and Γ ′ ⊢γ is δ : Γ then
Γ ′ ⊢γ(t) is δ(t) : T.
2
Proof:
By induction on derivations. We show several cases; the rest are left
as exercises.
Case T-Var:
t = x
with x:T ∈Γ
By assumption, Γ ′ ⊢γ(x) is δ(x) : T.
Case T-Abs:
t = λx:T1.t2
T = T1→T2
We wish to show that Γ ′ ⊢γ(λx:T1.t2) is δ(λx:T1.t2) : T1→T2. Suppose
Γ ′′ ⊇Γ ′ and Γ ′′ ⊢s′ is t′ : T1. We wish to show that Γ ′′ ⊢(λx:T1.γ(t2))s′ is
(λx:T1.δ(t2))t′ : T2. By logical weak head closure (Lemma 6.9.3), it is suﬃ-
cient to show that Γ ′′ ⊢[x , s′]γ(t2) is [x , t′]δ(t2) : T2.
By logical monotonicity, Γ ′′ ⊢γ
is δ : Γ. Thus, Γ ′′ ⊢γ[x , s′] is
δ[x , t′] : (Γ, x:T1). Therefore, by induction, Γ ′′ ⊢γ[x , s′](t2) is δ[x ,
t′](t2) : T2, which is equivalent to the desired conclusion.
Case T-App:
t = t1 t2
T = T12
By induction, Γ ′ ⊢γ(t1) is δ(t1) : T1→T2 and Γ ′ ⊢γ(t2) is δ(t2) : T1.
By the deﬁnition of the logical relation, since Γ ′ ⊇Γ, we may conclude Γ ′ ⊢
γ(t1)γ(t2) is δ(t1)δ(t2) : T2. That is, Γ ′ ⊢γ(t1 t2) is δ(t1 t2) : T2.
2
6.9.9
Theorem [Fundamental Theorem 2]: If Γ ⊢s ≡t : T and Γ ′ ⊢γ is δ : Γ
then Γ ′ ⊢γ(s) is δ(t) : T.
2
Proof:
By induction on derivations. We show one case; the rest are left as
exercises.

242
6
Logical Relations and a Case Study in Equivalence Checking
Case Q-Beta:
s = (λx:T1.s12) s2
t = [x , t2]t12 : T2
T = T2
By induction, Γ ′ ⊢γ(s2) is δ(t2) : T1. Thus Γ ′ ⊢γ[x , γ(s2)] is δ[x ,
δ(t2)] : (Γ, x:T1). Therefore, by induction:
Γ ′ ⊢γ[x , γ(s2)](s12) is δ[x , δ(t2)](t12) : T2
By rearranging substitutions:
Γ ′ ⊢[x , γ(s2)]γ(s12) is δ([x , t2]t12) : T2
Finally, by logical weak head closure (Lemma 6.9.3):
Γ ′ ⊢(λx:T1.γ(s12))γ(s2) is δ([x , t2]t12) : T2
That is:
Γ ′ ⊢γ((λx:T1.s12) s2) is δ([x , t2]t12) : T2
2
6.9.10
Exercise [Recommended, «««]: Complete the proof of Theorems 6.9.8 and
6.9.9.
2
Now we can establish the algorithm’s completeness, using the Fundamental
Theorem with an identity substitution:
6.9.11
Corollary [Completeness]: If Γ ⊢s ≡t : T then Γ ⊢s a t : T.
2
Proof:
Suppose Γ ⊢s ≡t : T. Let γ be the identity substitution on dom(Γ).
For all x:T in Γ, observe that Γ ⊢x is x : T by the Main Lemma. Therefore
Γ ⊢γ is γ : Γ. By the Fundamental Theorem, Γ ⊢γ(s) is γ(t) : T, which is
to say Γ ⊢s is t : T. Therefore Γ ⊢s a t : T by the Main Lemma.
2
6.9.12
Exercise [«]: An irony arises from the use logical relations to show com-
pleteness: it turns out that algorithmic equivalence actually is logical after all
(at least for well-formed terms); we just cannot prove it until we have already
proven the algorithm to be sound and complete. Show that if Γ ⊢s1 a t1 :
T1→T2 and Γ ⊢s2 a t2 : T1 (where Γ ⊢s1 : T1→T2, Γ ⊢t1 : T1→T2, Γ ⊢s2 : T1,
and Γ ⊢t2 : T1), then Γ ⊢s1 s2 a t1 t2 : T2.
2
6.9.13
Exercise [««««]: We have shown that the equivalence algorithm is sound
and complete. To show that the algorithm decides the equivalence problem,
it remains to show that it terminates on all well-formed inputs. Show that if
Γ ⊢s : T and Γ ⊢t : T then there exists no inﬁnite proof search rooted in
Γ ⊢s a t : T.
Hint: Termination is a corollary of completeness. You will not need to prove
any additional non-trivial facts about the algorithm.
2

6.10
Notes
243
New syntactic forms
t
::=
. . .
terms:
⟨t, t⟩
pair
t.1
ﬁrst projection
t.2
second projection
T
::=
. . .
types:
T1 × T2
product type
Typing
Γ ⊢t : T
Γ ⊢t1 : T1
Γ ⊢t2 : T2
Γ ⊢⟨t1, t2⟩: T1 × T2
(T-Pair)
Γ ⊢t : T1 × T2
Γ ⊢t.1 : T1
(T-Proj1)
Γ ⊢t : T1 × T2
Γ ⊢t.2 : T2
(T-Proj2)
Equivalence
Γ ⊢s ≡t : T
Γ ⊢s1 ≡t1 : T1
Γ ⊢s2 ≡t2 : T2
Γ ⊢⟨s1, s2⟩≡⟨t1, t2⟩: T1 × T2
(Q-Pair)
Γ ⊢s ≡t : T1 × T2
Γ ⊢s.1 ≡t.1 : T1
(Q-Proj1)
Γ ⊢s ≡t : T1 × T2
Γ ⊢s.2 ≡t.2 : T2
(Q-Proj2)
Γ ⊢s1 ≡t : T1
Γ ⊢s2 : T2
Γ ⊢⟨s1, s2⟩.1 ≡t : T1
(Q-Beta-Prod1)
Γ ⊢s2 ≡t : T2
Γ ⊢s1 : T1
Γ ⊢⟨s1, s2⟩.2 ≡t : T2
(Q-Beta-Prod2)
Γ ⊢s.1 ≡t.1 : T1
Γ ⊢s.2 ≡t.2 : T2
Γ ⊢s ≡t : T1 × T2
(Q-Ext-Prod)
Figure 6-5: Product types (λ→×b1)
6.9.14
Exercise [Recommended, ««««]: Our language can be extended straightfor-
wardly with pairs. Figure 6-5 gives the extended syntax and type system, and
Figure 6-6 extends the equivalence algorithm to account for pairs. Extend the
completeness proof to cover the extended language and algorithm.
2
6.9.15
Exercise [«««]: Unfortunately, some extensions of the technique of logical
relations, such as for universal types, are not as simple as that for pairs.
Suppose our language and algorithm are extended in the natural manner to
support universal types as in System F (TAPL, Chapter 23). To prove the al-
gorithm complete involves deﬁning a logical relation. However, to deﬁne the
necessary logical relation is not straightforward. Observe what goes wrong. 2
6.10
Notes
The ideas behind logical relations were ﬁrst developed by Tait (1967) and
Howard (1973), and were reﬁned further by Plotkin (1980). Logical relations
were ﬁrst proposed as a general proof technique by Statman (1985).

244
6
Logical Relations and a Case Study in Equivalence Checking
Syntax
p, q ::= . . .
paths:
p.1
ﬁrst projection
p.2
second projection
Weak head reduction
s ; t
⟨t1, t2⟩.1 ; t1
(QAR-Beta-Prod1)
⟨t1, t2⟩.2 ; t2
(QAR-Beta-Prod2)
t ; t′
t.1 ; t′.1
(QAR-Proj1)
t ; t′
t.2 ; t′.2
(QAR-Proj2)
Algorithmic term equivalence
Γ ⊢s a t : T
Γ ⊢s.1 a t.1 : T1
Γ ⊢s.2 a t.2 : T2
Γ ⊢s a t : T1 × T2
(QAT-Prod)
Algorithmic path equivalence
Γ ⊢p ↔q : T
Γ ⊢p ↔q : T1 × T2
Γ ⊢p.1 ↔q.1 : T1
(QAP-Proj1)
Γ ⊢p ↔q : T1 × T2
Γ ⊢p.2 ↔q.2 : T2
(QAP-Proj2)
Figure 6-6: Equivalence algorithm for λ→×b1
The idea of using a Kripke logical relation to show the completeness of an
equivalence algorithm is due to Coquand (1991), who applies it to algorithms
for various similar type systems. Unlike the algorithm we consider here, Co-
quand’s algorithms are not type-directed. Coquand’s technique was adopted
by Stone and Harper (2000), who use a more sophisticated form of logical re-
lation to show the completeness of an equivalence algorithm for a language
with singleton kinds. (Singleton kinds arise from a form of type deﬁnitions,
and are discussed in §9.3.)
A broader survey of applications of logical relations appears in Mitchell’s
Foundations for Programming Languages (1996). A good introductory text on
modal logic and Kripke models is Sally Popkorn’s First Steps in Modal Logic
(1994). A shorter introduction to modal logic from a diﬀerent perspective
(leaving out connections to Kripke models) is given by Pfenning and Davies
(2001).

7
Typed Operational Reasoning
Andrew Pitts
The aim of this chapter is to explain, by example, some methods for reason-
ing about equivalence of programs based directly upon a type system and
an operational semantics for the programming language in question. We will
concentrate on methods for reasoning about equivalence of representations
of abstract data types. This provides an excellent example: it is easy to appre-
ciate why such methods are useful and at the same time non-trivial problems
have to be solved to get a sound reasoning principle in the presence of non-
termination and recursion. Rather than just treat abstract data types, we will
cover full existential types, using a programming language combining a pure
fragment of ML (including records and recursive functions) with System F.
7.1
Introduction
As explained in TAPL, Chapter 24, type systems involving existentially quan-
tiﬁed type variables provide a useful foundation for explaining and relating
various features of programming languages to do with information hiding.
To establish the properties of such type-theoretic interpretations of infor-
mation hiding requires a theory of semantic equivalence for expressions of
existential type. Methods involving type-indexed families of relations between
between expressions have proved very useful in this respect. Study of rela-
tional properties of typed calculi goes back to the logical relations for simply
typed lambda calculus in Plotkin (1973) and Statman (1985) and discussed in
Chapter 6, and the notion of relational parametricity for polymorphic types
in Reynolds (1983). More relevant to the kind of example considered in this
chapter is Mitchell’s principle for establishing the denotational equivalence
of programs involving higher-order functions and diﬀerent implementations
of an abstract datatype in terms of the existence of a simulation relation be-

246
7
Typed Operational Reasoning
tween the implementations (Mitchell, 1991a). This principle was extended by
Plotkin and Abadi (1993) to encompass all the (possibly impredicative) exis-
tential types of the Girard-Reynolds polymorphic lambda calculus.
One feature of these works is that they develop proof principles for deno-
tational models of programming languages. The relevance of such principles
to the operational behavior of programs relies upon ‘goodness of ﬁt’ results
(some published, some not) connecting operational and denotational seman-
tics. Another feature of the above works is that they do not treat the use of
general recursive deﬁnitions; and so the languages considered are not Tur-
ing powerful. It is folklore that a proof principle for denotational equality at
existential type, phrased in terms of the existence of certain simulation rela-
tions, is still valid in the presence of recursively deﬁned functions of higher
type, provided one imposes some admissibility conditions on the notion of
relation. In fact using techniques for deﬁning operationally based logical re-
lations developed in Pitts (2000), we will see in this chapter that suitable
admissibility conditions for relations and an associated proof principle for
operational equivalence at existential type can be phrased directly, and quite
simply, in terms of the syntax and operational semantics of a programming
language combining existential types with recursively deﬁned, higher-order
functions. The programming language we work with combines a pure frag-
ment of ML (including records and recursive functions) with the polymorphic
lambda calculus of Girard (1972) and Reynolds (1974).
7.2
Overview
In order to get the most out of this chapter you should have some familiarity
with TAPL, Chapters 23 and 24. The material in this chapter is technically
quite intricate (especially the deﬁnition and properties of the logical relation
in §7.6) and it is easy to lose sight of the wood for the trees. So here is an
overview of the chapter.
Equivalence of programs One application of formal semantics of program-
ming languages is to give a mathematically precise deﬁnition of what it
means for one program to be semantically equal to another. In this chapter
we use operational semantics and discuss a notion of program equivalence
called contextual equivalence (§7.5).
Extensionality principles In order to reason about program equivalence, it
is useful to establish the validity of proof methods for it. The most basic
method uses the congruence property—reasoning by “replacing equals by
equals”—which holds of contextual equivalence by construction. In §7.1

7.3
Motivating Examples
247
we discuss informally some methods for proving contextual equivalence
of implementations of abstract datatypes. The discussion culminates with
the Extensionality Principle 7.3.6. One goal of this chapter is to give a
mathematically precise formulation of this principle and to establish its
validity.
Logical relations The Extensionality Principle is phrased in terms of type-
respecting relations between the terms of our example language. In order
to formulate this principle precisely and then prove it we develop an alter-
native characterisation of contextual equivalence in terms of a certain “log-
ical relation” (§7.6). The combination of features in our language—higher-
order recursive functions and fully impredicative polymorphic types—
force us to use a form of logical relation with quite a diﬃcult deﬁnition.
Chapter 6 presents another use of logical relations with a simpler deﬁni-
tion; as such, that chapter provides a useful warm-up for this one.
7.3
Motivating Examples
In this section we motivate the use of logical relations for reasoning about
existential types by giving some examples.
To begin, let us recall the syntax for expressions involving existentially
quantiﬁed type variables from TAPL, Chapter 24. If T is a type expression and
X is a type variable, then we write {∃X,T} for the corresponding existentially
quantiﬁed type. Free occurrences of X in T become bound in this type expres-
sion. We write [X , S]T for the result of substituting a type S for all free
occurrences of X in T, renaming bound type variables as necessary to avoid
capture.1 It t is a term of type [X , S]T, then we can “pack” the type S and
the term t together to get a term
{*S,t} as {∃X,T}
(7.1)
of the indicated existential type. To eliminate such terms we use the form
let {*X,x}=t1 in t2
(7.2)
This is a binding construct: free occurrences of the type variable X and the
value variable x in t2 become bound in the term. The typing of such terms
goes as follows:
if t1 has type {∃X,T} and t2 has type T2 when we assume the variable
x has type T, then provided X does not occur free in T2, we can conclude
that the term in (7.2) has type T2.
1. Throughout this chapter we will always identify expressions, be they types or terms, up to
renaming of bound variables.

248
7
Typed Operational Reasoning
(Such rules are better presented symbolically, but we postpone doing that
until we give a formal deﬁnition of the language we will be using, in the next
section.) The italicized restriction on free occurrences of X in T2 in the above
rule is what distinguishes an existential type from a type-indexed dependent
sum, where there is free access both to the type component as well as the
term component of a “packed” term: see Mitchell and Plotkin (1988), p. 474 et
seq, for a discussion of this point.
Since we wish to consider existential types in the context of an ML-like
language, we adopt an eager strategy for evaluating expressions like (7.1)
and (7.2). Thus to evaluate the ﬁrst, one evaluates t to canonical form, v say,
and returns the canonical form {*S,v} as {∃X,T}; to evaluate the second,
one evaluates t1 to canonical form, {*S,v} as {∃X,T} say, and then evalu-
ates [X , S][x , v]t2.
7.3.1
Example: Consider the existentially quantiﬁed record type
type Counter = {∃X, {mk:X, inc:X→X, get:X→Int}}
where Int is a type of integers. Values of type Counter consist of some type
together with values of the appropriate types implementing mk, inc, and get.
For example
val counter1 = {*Int, {mk
= 0,
inc = λx:Int.x+1,
get = λx:Int.x
} as Counter
and
val counter2 = {*Int, {mk
= 0,
inc = λx:Int.x-1,
get = λx:Int.0-x } as Counter
are both values of type Counter. The terms
let {*X,x} = counter1
in x.get(x.inc(x.mk))
let {*X,x} = counter2 in x.get(x.inc(x.mk))
(where we use the syntax r.f for selecting ﬁeld f of record r) are both terms
of type Int which evaluate to 1. By contrast, of the terms
let {*X,x} = counter1
in x.get(x.inc(1))
let {*X,x} = counter2 in x.get(x.inc(1))
the ﬁrst evaluates to 2, whereas the second evaluates to 0; but in this case
neither term is well-typed. Indeed, it is the case that any well-typed closed
term involving occurrences of the term counter1 will exhibit precisely the
same evaluation behavior if we replace those occurrences by counter2. In
other words, counter1 and counter2 are equivalent in the following sense. 2

7.3
Motivating Examples
249
7.3.2
Definition [Contextual equivalence, informally]: We write t1 =ctx t2:T
to indicate that two terms t1 and t2 of the same type T are contextually equiv-
alent. By deﬁnition, this means that for all well-typed terms t[t1] containing
instances of t1, if t[t2] is the term obtained by replacing those instances
by t2, then t[t1] and t[t2] give exactly the same observable results when
evaluated.
2
This notion of program equivalence assumes we have already ﬁxed upon a
deﬁnition of the “observable results” of evaluating terms. It also presupposes
that the meaning of a well-typed term should only depend upon the ﬁnal
result (if any) of evaluating it. This is reasonable for deterministic and non-
interactive programming even in the presence of computational eﬀects like
side-eﬀecting state or raising exceptions, provided we include those eﬀects as
part of the observable results of evaluation. Certainly, contextual equivalence
is a widely used notion of program equivalence in the literature and it is the
one we adopt here.
For the terms in Example 7.3.1, it is the case that
counter1 =ctx counter2:Counter
(7.3)
but the quantiﬁcation over all possible contexts t[−] in the deﬁnition of =ctx
makes a direct proof of this and similar facts rather diﬃcult. Thus one is
led to ask whether there are proof principles for contextual equivalence that
make proving such equivalences at existential types more tractable. Since
values {*S,v} as {∃X,T} of a given existential type {∃X,T} are speciﬁed by
pairs of data S and v, as a ﬁrst stab at such a proof principle one might
try componentwise equivalence. Equivalence in the second component will of
course mean contextual equivalence; but in the ﬁrst component, where the
expressions involved are types, what should equivalence mean? If we take
it to mean syntactic identity, =, (which for us includes renaming of bound
variables) we obtain the following proof principle.2
7.3.3
Principle [Extensionality for ∃-types, Version I]: For an existential type
E
def
= {∃X,T}, types T1, T2, and values v1, v2, if T1 = T2 and v1 =ctx v2:[X ,
T2]T, then ({*T1,v1} as E) =ctx ({*T2,v2} as E):{∃X,T}.
2
The hypotheses of Principle 7.3.3 are far too strong for it to be very useful.
For example, it cannot be used to prove (7.3), since in this case T1 = Int = T2,
but
2. This and subsequent proof principles for {∃X,T} are called extensionality principles by
analogy with the familiar extensionality principle for functions; it is a convenient terminology,
but perhaps the analogy is a little stretched.

250
7
Typed Operational Reasoning
val v1 = {mk=0, inc=λx:Int.x+1, get=λx:Int.x}
and
val v2 = {mk=0, inc=λx:Int.x-1, get=λx:Int.0-x}
are clearly not contextually equivalent values of the record type
{mk:Int,inc:Int→Int,get:Int→Int}
(for example, we get diﬀerent integers when evaluating t[v1] and t[v2] when
t[−] is (−.inc)0). However, they do become contextually equivalent if in
the second term we use a variant of integers in which the roles of positive
and negative are reversed. Such “integers” are of course in bijection with
the usual ones and this leads us to our second version of an extensionality
principle for existential types—in which the use of syntactic identity as the
notion of type equivalence is replaced by the more ﬂexible one of bijection.
A bijection i : T1 ≊T2 means a closed term i : T1→T2 for which there is
a closed term i−1 : T2→T1 which is a two-sided inverse up to contextual
equivalence: i−1(i x1) =ctx x1 : T1 and i(i−1 x2) =ctx x2 : T2.
7.3.4
Principle [Extensionality for ∃-types, Version II]: For
each
existential
type E
def
= {∃X,T}, types T1, T2, and values v1, v2, if there is a bijection
i : T1 ≊T2 such that T(i) v1 =ctx v2 : [X , T2]T, then
({*T1,v1} as E) =ctx ({*T2,v2} as E) : {∃X,T}.
In stating this principle we have used the notation T(i) for the “action” of
types T on bijections i: given a type T, possibly containing free occurrences
of a type variable X, one can deﬁne an induced bijection T(i) : [X , T1]T ≊
[X , T2]T (with inverse T(i−1)). For example, if T is the type
{mk:X, inc:X→X, get:X→Int}
then T(i) is
λx:{ mk:T1, inc:T1→T1, get:T1→Int}.
{ mk = i(x.mk),
inc = λx2:T2.i(x.inc(i−1 x2)),
get = λx2:T2.x.get(i−1 x2)) }
and T(i−1) is
λx:{ mk:T2, inc:T2→T2, get:T2→Int}.
{ mk = i−1(x.mk),
inc = λx1:T1.i−1(x.inc(i x1)),
get = λx1:T1.x.get(i x1)) }.

7.3
Motivating Examples
251
(In general, if T is a simple type then the deﬁnition of T(i) and T(i−1) can
be done by induction on the structure of T; for recursively deﬁned types, the
deﬁnition of the induced bijection is not so straightforward.)
2
We can use this second version of the extensionality principle for existen-
tial types to prove the contextual equivalence in (7.3), using the bijection
i
def
= (λx:Int.0-x) : Int ≊Int.
This does indeed satisfy T(i) v1 =ctx v2 : Int when v1, v2, and T are de-
ﬁned as above. (Of course these contextual equivalences, and indeed the fact
that this particular term i is a bijection, all require proof; but the methods
developed in this chapter render this straightforward.) However, the use of
bijections between types is still too restrictive for proving many common ex-
amples of contextual equivalence of abstract datatype implementations, such
as the following.
7.3.5
Example: Consider the following existentially quantiﬁed record type, where
Bool is a type of booleans.
type Semaphore = {∃X, {bit:X, flip:X→X, read:X→Bool}}
The following terms have type Semaphore:
val semaphore1 =
{*Bool, {bit
= true
flip = λx:Bool.not x,
read = λx:Bool.x
} as Semaphore;
val semaphore2 =
{*Int,
{bit
= 1,
flip = λx:Int.0-2*x,
read = λx:Int.x >= 0} as Semaphore
There is no bijection Bool ≊Int, so one cannot use Principle 7.3.4 to prove
semaphore1 =ctx semaphore2 : Semaphore.
(7.4)
Nevertheless, this contextual equivalence does hold. An informal argument
for this makes use of the following relation r : Bool ↔Int between values
of type Bool and of type Int.
r
def
=
{(true, m) | m = (−2)n for some even n ≥0}
∪
{(false, m) | m = (−2)n for some odd n ≥0}.
Write si for the second component of semaphorei (i = 1, 2). Then

252
7
Typed Operational Reasoning
• s1.bit evaluates to true; s2.bit evaluates to 1; and (true, 1) ∈r;
• if (t1, t2) ∈r, then (s1.flip)t1 and (s2.flip)t2 evaluate to a pair of
values which are again r-related;
• if (t1, t2) ∈r, then (s1.read)t1 and (s2.read)t2 evaluate to the same
boolean value.
The informal argument for the contextual equivalence (7.4) goes as follows:
“any context t[−] which is well-typed whenever its hole ‘−’ is ﬁlled with a
term of type Semaphore can only make use of a term placed in its hole by
opening it as an abstract pair {X,x} and applying the methods bit, flip,
and read in some combination; therefore the above observations about r
are enough to show that t[semaphore1] and t[semaphore2] always have the
same evaluation behavior.”
2
The validity of this informal argument and in particular the assumptions
it makes about the way a context can “use” its hole are far from immediate
and need formal justiﬁcation. Leaving that for later, at least we can state the
relational principle a bit more precisely.
7.3.6
Principle [Extensionality for ∃-types, Final Version]: For each existen-
tial type E
def
= {∃X,T}, types T1, T2, and values v1, v2, if there is a relation
r : T1 ↔T2 between terms of type T1 and of type T2, such that (v1, v2) ∈T[r],
then ({*T1,v1} as E) =ctx ({*T2,v2} as E) : {∃X,T}.
2
Evidently this principle presupposes the existence of an “action” of types on
term-relations that sends relations r : T1 ↔T2 to relations T[r] : [X ,
T1]T ↔[X , T2]T and with certain other properties. It is the deﬁnition of
this action that is at the heart of the matter. It has to be phrased with some
care in order for the above extensionality principle to be valid for languages
involving non-termination of evaluation (through the presence of ﬁxpoint re-
cursion for example). We will give a precise deﬁnition in §7.6 (Deﬁnition 7.6.9)
for a language combining impredicative polymorphism with ﬁxpoint recur-
sion at the level of terms. How best to deﬁne such relational actions in the
presence of recursion at the level of types is still a matter for research (see
Exercise 7.8.1).
7.3.7
Note: Principle 7.3.4 generalizes Principle 7.3.3, because if T1 = T2, then the
identity function i
def
= λx:T1.x is a bijection T1 ≊T2 satisfying
(T(i) v) =ctx v
(for any v)

7.4
The Language
253
so that v1 =ctx v2 implies (T(i) v1) =ctx v2. Principle 7.3.6 generalizes Prin-
ciple 7.3.4, because each bijection i : T1 ≊T2 can be replaced by its graph
ri
def
= {(u1, u2) | i u1 =ctx u2}
which in fact has the property that (v1, v2) ∈T[ri] if and only if (T(i) v1) is
contextually equivalent to v2.
2
As mentioned in the Introduction, Principle 7.3.6 is an operational gen-
eralization of similar principles for the denotational semantics of abstract
datatypes over the simply typed lambda calculus (Mitchell, 1991a) and rela-
tionally parametric models of the polymorphic lambda calculus (Plotkin and
Abadi, 1993). It permits many examples of contextual equivalence at existen-
tial types to be proved rather easily. Nevertheless, we will see in §7.7 that it is
incomplete for the particular ML-like language we consider here, in the sense
that ({*T1,v1} as E) =ctx ({*T2,v2} as E) : {∃X,T} can hold even though
there is no relation r for which (v1, v2) ∈T[r] holds (see Example 7.7.4).
7.4
The Language
In this section we deﬁne a small, ML-like programming language that we will
use in the rest of the chapter. It combines Girard’s System F (1972) (in other
words, the polymorphic lambda calculus of Reynolds [1974]) with recursively
deﬁned functions, record types and ground types; in common with ML (Mil-
ner, Tofte, Harper, and MacQueen, 1997), evaluation order is strict (i.e., left-to-
right, call-by-value). We will call the language FML. Its syntax and type system
are speciﬁed in Figure 7-1 and its operational semantics in Figure 7-2.
Syntax
In Figure 7-1, X and x respectively range over disjoint countably inﬁnite sets
of type variables and value variables; l ranges over a countably inﬁnite set
of ﬁeld labels; c ranges over the constants true, false and n (for n ∈Z);
Gnd is either the type of booleans Bool or the type of integers Int; and op
ranges over a ﬁxed collection of arithmetic and boolean operations (such as
+, =, not, etc).
To simplify the deﬁnition of the language’s operational semantics we em-
ploy the now quite common device of using a syntax for terms that is in a
“reduced” (or “A-normal”) form, with all sequential evaluation expressed via
let-expressions. For example, the general form of (left-to-right, call-by-value)
function application is coded by
t1 t2
def
= let x1=t1 in (let x2=t2 in x1 x2).
(7.5)

254
7
Typed Operational Reasoning
Syntax
t
::=
terms:
v
value
if v then t else t
conditional
op(vi
i∈1..n)
operation
v v
application
v.l
projection
v T
type application
let {*X,x}=v in t
unpacking
let x=t in t
sequencing
v
::=
values:
x
value variable
c
constant
fun x(x:T)=t:T
recursive function
{li=vi
i∈1..n}
record value
λX.v
type abstraction
{*T,v} as {∃X,T}
package value
T
::=
types:
X
type variable
Gnd
ground type
T→T
function type
{li:Ti
i∈1..n}
record type
∀X.T
universally quantiﬁed type
{∃X,T}
existentially quantiﬁed type
Γ
::=
typing contexts:
∅
empty context
Γ, x:T
non-empty context
Γ, X
non-empty context
Typing terms
Γ ⊢t : T
x:T ∈Γ
Γ ⊢x : T
(T-Var)
Γ ⊢c : Typeof (c)
(T-Const)
Γ, f:T, x:T1 ⊢t : T2
T = T1→T2
Γ ⊢fun f(x:T1)=t:T2 : T
(T-Fun)
(Γ ⊢vi : Ti) i∈1..n
Γ ⊢{li=vi
i∈1..n} : {li:Ti
i∈1..n}
(T-Rcd)
Γ, X ⊢v : T
X ∉ftv(Γ)
Γ ⊢λX.v : ∀X.T
(T-Tabs)
Γ ⊢v1 : [X , T1]T
T′ = {∃X, T}
Γ ⊢{*T1,v1} as T′ : T′
(T-Pack)
Γ ⊢v : Bool
Γ ⊢t1 : T
Γ ⊢t2 : T
Γ ⊢if v then t1 else t2 : T
(T-If)
op:Gnd1,...,Gndn→Gnd
(Γ ⊢vi : Gndi) i∈1..n
Γ ⊢op(vi
i∈1..n) : Gnd
(T-Op)
Γ ⊢v1 : T1→T2
Γ ⊢v2 : T1
Γ ⊢v1 v2 : T2
(T-App)
Γ ⊢v : {li:Ti
i∈1..n}
Γ ⊢v.lj : Tj
(T-Proj)
Γ ⊢v : ∀X.T
Γ ⊢v T1 : [X , T1]T
(T-Tapp)
Γ, X, x:T ⊢t : T1
X ∉ftv(Γ, T1)
Γ ⊢v : {∃X,T}
Γ ⊢let {*X,x}=v in t : T1
(T-Unpack)
Γ ⊢t1 : T1
Γ, x:T1 ⊢t2 : T2
Γ ⊢let x=t1 in t2 : T2
(T-Seq)
Figure 7-1: FML syntax and typing

7.4
The Language
255
As a further simpliﬁcation, function abstraction and recursive function dec-
laration have been rolled into the one form fun f(x:T1) = t:T2, which corre-
sponds to the expressions
let fun f (x:T1) = t:T2 in f end
in Standard ML
or
let rec f (x:T1) = t:T2 in f
in Ocaml.
Ordinary function abstraction can be coded as
λx:T1.t
def
= fun f(x:T1) = t:T2
(7.6)
where f does not occur freely in t (and T2 is the type of t, given f has type
T1→T2 and x has type T1). In what follows we shall use the abbreviations (7.5)
and (7.6) without further comment. We shall also use inﬁx notation for appli-
cation of constant arithmetic and boolean operators such as +, =, etc.
7.4.1
Remark [Value-restriction]: Note that the operation λX.(−) of polymor-
phic generalization is restricted to apply only to values. This is a real re-
striction since for a non-value term t, one cannot deﬁne λX.t to be the term
let x=t in λX.x, since the latter will in general be an ill-typed term. In an ML-
like language λX.t is not yet fully evaluated if t is a non-value; and thus eval-
uation must go under type abstraction λX.(−) and work on terms at types
with free type variables. By imposing the restriction that λX.t is only well-
formed when t is a value we can restrict attention to the evaluation of closed
terms of closed type, simplifying the technical development. The restriction
does not seem to aﬀect the expressiveness of FML in practice and is compara-
ble to the “value restriction” on let-bound polymorphism used in the 1997
revision of Standard ML (Milner et al., 1997) and in Objective Caml (Leroy,
2000). However, this restriction does have an eﬀect on the properties of FML.
For example, with the restriction the type ∀X.X contains no closed values (see
Exercise 7.7.6); whereas without the restriction there are closed values of that
type, such as λX. (fun f(x:Bool) = f x : X) true. The “emptiness” of ∀X.X
plays a role in the properties explored in Example 7.7.4 and Remark 7.7.7. 2
Operational Semantics
Although we do not do so, the operational semantics of FML could be speci-
ﬁed in the style of the Deﬁnition of Standard ML (Milner, Tofte, Harper, and
MacQueen, 1997) as a syntax-directed, inductively deﬁned relation between
terms and values.3 Here we are interested primarily in the notion of contex-
3. That Deﬁnition uses environments assigning values to value variables. For reasons of tech-
nical convenience we eliminate the use of environments by substituting them into the term
and only considering the evaluation relation between closed terms and values.

256
7
Typed Operational Reasoning
Frame stack syntax
S
::=
frame stacks:
Id
nil stack
S ◦(x.t)
stack cons
Typing frame stacks
Γ ⊢S : T1 ⊸T2
Γ ⊢Id : T ⊸T
(S-Nil)
Γ, x:T1 ⊢t : T2
Γ ⊢S : T2 ⊸T3
Γ ⊢S ◦(x.t) : T1 ⊸T3
(S-Cons)
Primitive reductions
t1 ; t2
if true then t1 else t2
; t1
(R-IfTrue)
if false then t1 else t2
; t2
(R-IfFalse)
the value of op(ci
i∈1..n) is c
op(ci
i∈1..n) ; c
(R-Op)
v1 is fun f(x:T1)=t:T2
v1 v2 ; [f , v1][x , v2]t
(R-AppAbs)
{li=vi
i∈1..n}.j ; vj
(R-ProjRcd)
(λX.v)T ; [X , T]v
(R-TappTabs)
v is {*T1,v1} as {∃X,T}
let {*X,x}=v in t
; [X , T1][x , v1]t
(R-UnpackPack)
Termination
⟨S, t⟩↓
and
t ↓
⟨Id, v⟩↓
(S-NilVal)
⟨S, [x , v]t⟩↓
⟨S ◦(x.t), v⟩↓
(S-ConsVal)
⟨S ◦(x.t2), t1⟩↓
⟨S, let x=t1 in t2⟩↓
(S-Seq)
t1 ; t2
⟨S, t2⟩↓
⟨S, t1⟩↓
(S-Red)
⟨Id, t⟩↓
t ↓
(Term)
Figure 7-2: FML operational semantics
tual equivalence (Deﬁnition 7.3.2) that this evaluation relation determines by
observing the results of evaluating terms in context. Because evaluation in
FML is strict and the language has a suﬃciently expressive collection of con-
structs for deconstructing values, it turns out that the notion of contextual
equivalence is not aﬀected much by the choice of what to observe of evalua-
tion. Most reasonable choices give rise to the same equivalence as the one we
adopt (see Exercise 7.5.10 below), which is based upon observing termination:
whether or not a term evaluates to some value, we care not which. So instead
of deﬁning the relation of evaluation between terms and values, we proceed
directly to a deﬁnition of the termination relation, t ↓, for FML. This is given
in Figure 7-2, using an auxiliary notion of frame stack. (The conventions and
notations used in Figure 7-2 in connection with binding, free variables and
substitution are summarized in Figure 7-3.)
Frame stacks are ﬁnite lists of individual “evaluation frames.” They provide
a convenient syntax for the notion of evaluation context E[−] (Felleisen and
Hieb, 1992; Wright and Felleisen, 1994). Every closed term can be decomposed

7.4
The Language
257
Binding constructs
let {*X,x}=v in (−)
let x=t in (−)
fun f(x:T1)=(−:T2)
λX.(−)
∀X.(−)
{∃X,(−)}
S ◦(x.(−))
We identify expressions up to renaming of
bound value and type variables.
Notation for free variable sets
ftv(E)
is the ﬁnite set of free type variables
of the expression E (a type, a term, or a
frame stack);
fv(E)
is the ﬁnite set of free value variables
of an expression E (a term, or a frame stack,
but not a type, since types do not contain
occurrences of value variables).
Closed types, terms and frame stacks
A type T is closed if ftv(T) = ∅.
A term or frame stack E is closed if fv(E) =
∅(even if ftv(E) ̸= ∅).
Notation for substitution
[X , T]E
denotes
the
result
of
capture-
avoiding substitution of a type T for all free
occurrences of a type variable X in E (a type,
a term, or a frame stack);
[x , v]E
denotes
the
result
of
capture-
avoiding substitution of a value v for all free
occurrences of the value variable x in a term
or frame stack E.
(Note that as their name suggests, value variables
stand for unknown values—the substitution of a
non-value term for a variable makes no sense syn-
tactically, in that it may result in an ill-formed ex-
pression.)
Figure 7-3: Binding, free variables and substitution
uniquely as E[t] where the evaluation context E[−] is a context with a unique
hole (−) occurring in the place where the next step of evaluation (called a
primitive reduction in Figure 7-2), if any, will take place. With FML’s reduced
syntax, such evaluation contexts turn out to be just nested sequences of the
let-construct
E[−] = let x1=(...(let xn=(−) in tn)...) in t1.
The corresponding frame stack
S = Id ◦(x1.t1) ◦· · · ◦(xn.tn)
records this sequence as a list of evaluation frames, xi.ti (with free occur-
rences of xi in ti being bound in xi.ti). Under this correspondence it can be
shown that E[t] evaluates to some value in the standard evaluation-style (or
“big-step”) structural operational semantics if and only if ⟨S, t⟩↓holds, for
the relation ⟨−, −⟩↓deﬁned in Figure 7-2. Not only does the use of frame

258
7
Typed Operational Reasoning
stacks enable a conveniently syntax-directed inductive deﬁnition of termina-
tion, but also frame stacks play a big role in §7.6 when deﬁning the logical
relation that we use to establish properties of FML contextual equivalence.
7.4.2
Exercise [Recommended, ««]: Consider a relation ⟨S1, t1⟩-→⟨S2, t2⟩de-
ﬁned by cases according to the structure of the term t1 and the frame stack
S1, as follows:
• ⟨S ◦(x.t), v⟩-→⟨S, [x , v]t⟩
• ⟨S, let x=t1 in t2⟩-→⟨S ◦(x.t2), t1⟩
• ⟨S, t1⟩-→⟨S, t2⟩, if t1 ; t2.
Show that
⟨S′@S, t⟩↓
a
(∃v) ⟨S, t⟩-→
∗⟨Id, v⟩& ⟨S′, v⟩↓
(7.7)
where -→
∗denotes the reﬂexive-transitive closure of the -→relation, and
S′@S is the frame stack obtained by appending the two lists of evaluation
frames S′ and S. Deduce that t ↓holds if and only if there is some value v
with ⟨Id, t⟩-→
∗⟨Id, v⟩.
2
Typing
We will consider the termination relation only for frame stacks and terms
that are well-typed. A term t is well-typed with respect to a particular typing
context Γ if a typing judgment
Γ ⊢t : T
(7.8)
can be derived for some type T using the rules in Figure 7-1. We identify
typing contexts Γ up to rearranging their constituent hypotheses (“X” or “x :
X”) and eliminating duplicates. Thus a typical typing context looks like
Γ = X1, . . . , Xm, x1 : T1, . . . , xn : Tn
where the type variables Xi and the value variables xj are all distinct (and
m = 0 or n = 0 is allowed). The typing judgments that are derivable from
the rules all have the property that the free type variables of T and each Tj
occur in the set {X1, . . . , Xm}, and the free value variables of t occur in the set
{x1, . . . , xn}. This is ensured by including some explicit side-conditions about
free variable occurrences in the typing rules (T-Abs) and (T-Unpack). In TAPL,
Chapters 23 and 24, such side-conditions are implicit, being subsumed by

7.4
The Language
259
extra well-formedness conditions for typing judgments. Also, we have chosen
to include suﬃcient explicit type information in terms to ensure that for any
given Γ and t, there is at most one T for which (7.8) holds. Apart from such
minor diﬀerences, the rules in Figure 7-1 for inductively generating the valid
FML typing judgments are all quite standard.
The judgment for typing frame stacks takes the form
Γ ⊢S : T1 ⊸T2
(7.9)
where, in terms of the evaluation context corresponding to S, T2 is the overall
type of the context, given that T1 is the type of the hole. The rules for gen-
erating this judgment are given in Figure 7-2. Unlike for terms, we have not
included explicit type information in the syntax of frame stacks; for example,
Id is not tagged with a type. However, it is not hard to see that, given Γ, S,
and T1, there is at most one T2 for which (7.9) holds. This property is enough
for our purposes, since the argument type of a frame stack will always be
supplied in any particular situation in which we use it.
7.4.3
Exercise [«, 3]: Write Γ ⊢⟨S, t⟩: T to mean that Γ ⊢S : T′ ⊸T and Γ ⊢t :
T′ hold for some type T′. Using the relation -→from Exercise 7.4.2, show that
if ∅⊢⟨S1, t1⟩: T and ⟨S1, t1⟩-→⟨S2, t2⟩, then ∅⊢⟨S2, t2⟩: T.
2
Unwinding Recursive Functions
In what follows we will need a ﬁniteness property of recursively deﬁned func-
tions with respect to the termination relation. This unwinding property, as
it is called, is a syntactic analog of the fact that the denotation of a re-
cursively deﬁned function is constructed as the least upper bound (lub) of
ﬁnite approximations obtained by successively unfolding its deﬁnition start-
ing with the bottom denotation, i.e., the totally undeﬁned partial function.
This gives rise to the useful principle of Scott induction in denotational se-
mantics: given an admissible property of denotations, i.e., one closed under
the formation of lubs of increasing chains, to show that it holds of the deno-
tation of recursively deﬁned data it suﬃces to show that it holds of bottom
and is closed under application of the function that deﬁnes the data as a
ﬁxed point. Here we use a syntactic analog of Scott induction for recursively
deﬁned functions, fun f(x:T1) = u:T2, in order to prove the “fundamental
property” (Lemma 7.6.17) of the logical relation constructed in §7.6.
The proof of the unwinding property that we give here is made easier by
our syntax-directed deﬁnition of termination using frame stacks. For state-
ments and proofs of similar properties see for example: Mason, Smith, and
Talcott (1996), Section 4.3, Pitts and Stark (1998), Theorem 3.2, Birkedal and
Harper (1999), Section 3.1, and Lassen (1998), Section 4.5.

260
7
Typed Operational Reasoning
7.4.4
Theorem [Unwinding]: Given any closed recursive function value F of the
form fun f(x:T1)=u:T2, deﬁne the followings abbreviations4 :
F0
def
= fun f(x:T1) = (f x) : T2
Fn+1
def
= fun f(x:T1) = [f , Fn]u : T2
Thus F0 is a closed function value describing a function of type T1→T2 that
diverges when applied to any argument, and the Fn are obtained from this
by repeatedly substituting for the the value variable f in the body u of the
original function value F. Then for all terms t containing at most f free we
have [f , F]t ↓if and only if (∃n) [f , Fn]t ↓.
2
Proof:
By deﬁnition of the relation t ↓in terms of the relation ⟨S, t⟩↓(via
rule (Term) in Figure 7-2), it suﬃces to prove the more general property that
for all terms t and frame stacks S (containing at most f free) we have
⟨[f , F]S, [f , F]t⟩↓a (∃n) ⟨[f , Fn]S, [f , Fn]t⟩↓
(7.10)
The proof of (7.10) is via a series of straightforward, if somewhat tedious,
inductions that we leave as an exercise.
2
7.4.5
Exercise [«««, 3]: This exercise leads you through a proof of (7.10). First
prove that
⟨[f , Fn]S, [f , Fn]t⟩↓⇒⟨[f , F]S, [f , F]t⟩↓
(7.11)
holds for all n, S and t by induction on the derivation of ⟨[f , Fn]S, [f ,
Fn]t⟩↓from the rules in Figure 7-2. Conversely show that
⟨[f , F]S, [f , F]t⟩↓⇒(∃n) ⟨[f , Fn]S, [f , Fn]t⟩↓
(7.12)
holds for all S and t, by induction on the derivation of ⟨[f , F]S, [f , F]t⟩↓
from the rules. To do this, you will ﬁrst need to prove by induction on n that
⟨[f , Fn]S, [f , Fn]t⟩↓⇒⟨[f , Fn+1]S, [f , Fn+1]t⟩↓
(7.13)
holds for all n, S and t; the base case n = 0 involves yet another induction,
this time over the derivation of ⟨[f , F0]S, [f , F0]t⟩↓from the rules.
2
4. Note that in the deﬁnition of Fn+1, the outer binding instance of f is a dummy, since f does
not occur free in [f , Fn]u.

7.5
Contextual Equivalence
261
7.5
Contextual Equivalence
Deﬁnition 7.3.2 gave an informal deﬁnition of the notion of contextual equiv-
alence that applies to any (typed) programming language. In giving a precise
deﬁnition of this notion for the FML language we will take the more abstract,
relational approach of Gordon (1998) and Lassen (1998) that avoids the ex-
plicit use of program contexts t[−] in favor of congruence relations. For one
thing, program contexts are an inconveniently concrete notion, because sub-
stitution of terms t′ for the hole “−” in a context t[−] to produce a term
t[t′] may involve the capture of free variables in t′ by binders in t[−]. For
example, when we replace the hole “−” in the context fun f(x:T) = f [−] by
the term f x, its free value variables are captured by the fun-binder. Con-
sequently, contexts have to be treated more concretely than terms since re-
naming their bound variables may not preserve their meaning. For example,
if we identiﬁed fun f(x:T) = f [−] with fun g(x:T) = g [−] (where f and g
are distinct value variables), then we should have to identify the results of
ﬁlling the hole with f x, that is, we should have to identify the syntactically
unequal terms fun f(x:T) = f(f x) and fun g(x:T) = g(f x). But more than
this, the abstract treatment of contextual equivalence that we use focuses at-
tention upon the key features of this kind of program equality, namely that it
is a congruence and is “adequate” for observing termination. In a nutshell, we
will deﬁne contextual equivalence to be the largest type-respecting congru-
ence relation between FML terms that is adequate for observing termination.
7.5.1
Definition: A type-respecting binary relation between FML terms is a set R
of quadruples (Γ, t, t′, T), each consisting of a typing context, two terms and
a type satisfying Γ ⊢t : T and Γ ⊢t′ : T. Figure 7-4 deﬁnes the properties
of reﬂexivity, symmetry, transitivity, substitutivity, and compatibility for such
relations; R has one of these properties if it is closed under the axioms and
rules under the corresponding heading in the ﬁgure. In these ﬁgures, and
elsewhere, we write Γ ⊢t R t′ : T instead of (Γ, t, t′, T) ∈R. We say that R is
• an equivalence relation if it has the reﬂexivity, symmetry and transitivity
properties;
• a congruence relation if it is an equivalence relation with the substitutivity
and compatibility properties;
• adequate (for the termination relation ↓deﬁned in Figure 7-2) if whenever
∅⊢t R t′ : T holds, then t ↓holds if and only if t′ ↓does.
2
7.5.2
Definition: We will need to use the following constructions on type-res-
pecting binary relations.

262
7
Typed Operational Reasoning
Reﬂexivity
Γ ⊢t : T
Γ ⊢t R t : T
Symmetry
Γ ⊢t R t′ : T
Γ ⊢t′ R t : T
Transitivity
Γ ⊢t R t′ : T
Γ ⊢t′ R t′′ : T
Γ ⊢t R t′′ : T
Substitutivity
Γ ⊢v R v′ : T1
Γ, x : T1 ⊢t R t′ : T2
Γ ⊢[x , v]t R [x , v′]t′ : T2
Γ, X ⊢t R t′ : T
Γ ⊢[X , T1]t R [X , T1]t′ : [X , T1]T
Compatibility
(x:T) ∈Γ
Γ ⊢x R x : T
Γ ⊢c R c : Typeof (c)
Γ, f:T1→T2, x:T1 ⊢t R t′ : T2
Γ ⊢fun f(x:T1)=t:T2 R
fun f(x:T1)=t′:T2 : T1→T2
(Γ ⊢vi R v′
i : Ti) i∈1..n
Γ ⊢{li=vi
i∈1..n} R {li=v′
i
i∈1..n}
: {li:Ti
i∈1..n}
Γ, X ⊢v R v′ : T
X ∉ftv(Γ)
Γ ⊢λX.v R λX.v′ : ∀X.T
Γ ⊢v1 R v′
1 : [X , T1]T
Γ ⊢{*T1,v1} as {∃X,T} R
{*T1,v′
1} as {∃X,T} : {∃X,T}
Γ ⊢v R v′ : Bool
Γ ⊢t1 R t′
1 : T
Γ ⊢t2 R t′
2 : T
Γ ⊢if v then t1 else t2 R
if v′ then t′
1 else t′
2 : T
op:Gnd1,...,Gndn→Gnd
(Γ ⊢vi R v′
i : Gndi) i∈1..n
Γ ⊢op(vi
i∈1..n) R op(v′
i
i∈1..n) : Gnd
Γ ⊢v1 R v′
1 : T1→T2
Γ ⊢v2 R v′
2 : T1
Γ ⊢v1 v2 R v′
1 v′
2 : T2
Γ ⊢v R v′ : {li:Ti
i∈1..n}
Γ ⊢v.lj R v′.lj : Tj
Γ ⊢v R v′ : ∀X.T
Γ ⊢v T1 R v′ T1 : [X , T1]T
Γ, X, x:T ⊢t R t′ : T1
X ∉ftv(Γ, T1)
Γ ⊢v R v′ : {∃X,T}
Γ ⊢let {*X,x}=v in t R
let {*X,x}=v′ in t′ : T1
Γ ⊢t1 R t′
1 : T1
Γ, x:T1 ⊢t2 R t′
2 : T2
Γ ⊢let x=t1 in t2 R let x=t′
1 in t′
2 : T2
Figure 7-4: Properties of a type-respecting relation R between FML terms
(i) The identity relation is Id
def
= {(Γ, t, t, T) | Γ ⊢t : T}.
(ii) The reciprocal of the relation R is Rop def
= {(Γ, t′, t, T) | Γ ⊢t R t′ : T}.
(iii) The composition of relations R1 and R2 is
R1 ◦R2
def
= {(Γ, t, t′′, T) | ∃t′. Γ ⊢t R1 t′ : T & Γ ⊢t′ R2 t′′ : T}.

7.5
Contextual Equivalence
263
(iv) The transitive closure of the relation R is the countable union R+ def
=
S
i∈N Ri, where R0 = R and Ri+1 = R ◦Ri.
(v) The open extension of the relation R is denoted R◦and consists of all
quadruples (Γ, t, t′, T) such that ∅⊢σ(t) R σ(t′) : σ(T) holds for all
Γ-closing substitutions σ. If Γ = X1, . . . ,Xm, x1 : T1, . . . ,xn : Tn, then a Γ-
closing substitution is given by a function [Xi , Ti | i = 1..m] mapping the
type variables Xi to closed types Ti and by a function [xj , vj | j = 1..n]
mapping the value variables xj to closed values vj of appropriate type,
namely satisfying ∅⊢vj : [Xi , Ti | i = 1..m]Tj.
(Note that R◦only depends on the quadruples of the form (∅, t, t′, T) in
R.)
2
We wish to deﬁne contextual equivalence to be the largest adequate con-
gruence relation, but it is not immediately clear why a largest such relation
exists. Therefore we give a theorem rather than a deﬁnition.
7.5.3
Theorem [FML contextual equivalence, =ctx]: There exists a largest type-
respecting binary relation between FML terms that is a congruence and ade-
quate. We call it contextual equivalence and write it =ctx.
2
Proof:
The proof makes use of the following series of facts, only the last of
which is not entirely straightforward to prove (see Exercise 7.5.4).
(i) The identity relation Id is an adequate congruence relation.
(ii) The collection of adequate relations is closed under taking unions.
(iii) Every compatible relation is reﬂexive, i.e., contains Id.
(iv) The set of all of compatible relations is closed under the operations
of composition and reciprocation; similarly for the set of all substitutive
relations and the set of all adequate relations.
(v) If the union of a non-empty family of compatible relations is transi-
tive, it is also compatible; similarly, if the union of a non-empty family of
reﬂexive and substitutive relations is transitive, it is also (reﬂexive and)
substitutive.
Let =ctx be the union of the family of relations that are adequate, compatible
and substitutive. Note that this family is non-empty by (i). By (ii), =ctx is ad-
equate. So it suﬃces to show that it is a congruence relation. It is certainly
reﬂexive by (i); and (iv) implies that it is also symmetric and transitive. So it
just remains to show that it is compatible and substitutive, and this follows
from (v), whose proof needs (iii).
2

264
7
Typed Operational Reasoning
7.5.4
Exercise [««]: Prove properties (iii) and (v) stated in the above proof.
2
It is not easy to use either the formulation in terms of contexts in Deﬁ-
nition 7.3.2 or the more abstract characterisation of Theorem 7.5.3 to prove
that a particular pair of terms are contextually equivalent. For example, it is
not easy to see from these characterisations that terms in the primitive reduc-
tion relation of Figure 7-2 are contextually equivalent (Corollary 7.5.8). That
this is so follows from the coincidence of =ctx with a notion of equivalence
popularized by Mason and Talcott (1991).
7.5.5
Definition [ciu-Equivalence, =ciu]: Two closed FML terms belonging to the
same (closed) type are ciu-equivalent if they have the same termination be-
havior when they are paired with any frame stack (a “use” of the terms);
the relation is extended to open terms via closing substitutions (or “closed
instantiations”—thus we arrive at an explanation of the rather cryptic name
for this equivalence).
More formally, we deﬁne =ciu to be the type-respecting relation R◦(us-
ing the operation from Deﬁnition 7.5.2(v)), where R consists of quadruples
(∅, t, t′, T) satisfying ∅⊢t : T, ∅⊢t′ : T, and ∀S. ⟨S, t⟩↓a ⟨S, t′⟩↓.
2
7.5.6
Lemma: For any frame stack S and term t, deﬁne a term S[t] by induction of
the length of the stack S as follows:
Id[t]
def
=
t
S ◦(x.t′)[t]
def
=
S[let x=t in t′]



(7.14)
Then ⟨S, t⟩↓if and only if S[t] ↓(i.e., ⟨Id, S[t]⟩↓).
2
Proof:
This is proved by induction on the length of S. The base case S = Id
is trivial. The induction step follows from the fact that ⟨S, let x=t in t′⟩↓
holds if and only if it was derived using rule (S-Seq) in Figure 7-4, if and only
if ⟨S ◦(x.t′), t⟩↓holds.
2
7.5.7
Theorem [CIU Theorem for FML]: The contextual and ciu-equivalence rela-
tions coincide.
2
Proof:
We ﬁrst show that =ctx is contained in =ciu. Suppose
Γ ⊢t =ctx t′ : T.
(7.15)
Since =ctx satisﬁes the substitutivity and reﬂexivity properties from Figure 7-4,
it follows that
∅⊢σ(t) =ctx σ(t′) : σ(T)
(7.16)

7.5
Contextual Equivalence
265
for any Γ-closing substitution σ. For any frame stack S, since =ctx satisﬁes
the compatibility (and reﬂexivity) properties from Figure 7-4, from (7.16) we
deduce that ∅⊢S[σ(t)] =ctx S[σ(t′)] : σ(T) (using the notation of (7.14)).
Since =ctx is adequate, this means that S[σ(t)] ↓if and only if S[σ(t′)] ↓;
hence by Lemma 7.5.6, ⟨S, σ(t)⟩↓if and only if ⟨S, σ(t′)⟩↓. As this holds for
all σ and S, we have Γ ⊢t =ciu t′ : T, as required.
To complete the proof of the theorem we have to show conversely that
=ciu is contained in =ctx. We can deduce this as a corollary of a stronger
characterisation of =ctx in terms of logical relations (Theorem 7.6.25) that we
establish later; so we postpone the rest of this proof until then.
2
7.5.8
Corollary [Conversions]: The following are valid contextual equivalences:
(i) Γ ⊢if true then t1 else t2 =ctx t1 : T and
Γ ⊢if false then t1 else t2 =ctx t2 : T, where Γ ⊢ti : T for i = 1, 2.
(ii) Γ ⊢op(ci
i∈1..n) =ctx c : Gnd, where c is the value of op(ci
i∈1..n) and
Typeof (c) = Gnd.
(iii) Γ ⊢v1 v2 =ctx [f , v1][x , v2]t : T2,
where v1 = fun f(x:T1)=t:T2.
(iv) Γ ⊢{li=vi
i∈1..n}.j =ctx vj : Tj,
where Γ ⊢{li=vi
i∈1..n} : {li:Ti
i∈1..n}.
(v) Γ ⊢(λX.v)T1 =ctx [X , T1]v : [X , T1]T, where Γ ⊢v : ∀X.T.
(vi) Γ ⊢let {*X,x}=({*T1,v1} as {∃X,T}) in t =ctx [X , T1][x , v1]t :
T2, where Γ, X, x:T ⊢t : T2 with X ∉ftv(Γ, T2).
(vii) Γ ⊢let x=v in t =ctx [x , v]t : T2, where Γ ⊢v : T1 and Γ, x:T1 ⊢
t : T2.
(viii) Γ ⊢let x1=t1 in (let x2=t2 in t) =ctx
let x2=(let x1=t1 in t2) in t : T, where Γ ⊢t1 : T1,
Γ, x1:T1 ⊢t2 : T2 and Γ, x2:T2 ⊢t : T.
2
Proof:
These are all ciu-equivalences, so we can just apply Theorem 7.5.7 (us-
ing the diﬃcult half of the theorem whose proof we have postponed to §7.6!).
The ciu-equivalences all follow easily from the deﬁnition of the termination
relation (Figure 7-2) except for the last one, where one can apply property (7.7)
from Exercise 7.4.2 to reduce proving (viii) for =ciu to the special case when
t1 is a value: see the following exercise.
2

266
7
Typed Operational Reasoning
7.5.9
Exercise [«, 3]: Given
∅⊢t1 : T1
x1:T1 ⊢t2 : T2
x2:T2 ⊢t : T
use property (7.7) to show for all frame stacks S that
⟨S ◦(x1.let x2=t2 in t), t1⟩↓
iﬀ
⟨S ◦(x2.t) ◦(x1.t2), t1⟩↓.
Deduce part (viii) of Corollary 7.5.8.
2
7.5.10
Exercise [««]: Recall from Deﬁnition 7.5.1 the notion of an adequate type-
respecting binary relation. Let us call a type-respecting binary relation R
true-adequate if, whenever ∅⊢t R t′ : Bool holds, ⟨Id, t⟩-→
∗⟨Id, true⟩
holds if and only if ⟨Id, t′⟩-→
∗⟨Id, true⟩does. Here -→
∗is the relation de-
ﬁned in Exercise 7.4.2. One can adapt the proof of Theorem 7.5.3 to show that
there is a largest type-respecting binary relation =true
ctx
between FML terms that
is a congruence and true-adequate. Show that =true
ctx
coincides with contex-
tual equivalence, =ctx.
2
7.6
An Operationally Based Logical Relation
We now have a precise deﬁnition of contextual equivalence for FML terms. Be-
fore showing that the Extensionality Principle 7.3.6 holds for existential types
in FML, we need a precise deﬁnition of the action of types on term-relations,
r , T[r], mentioned in the principle. That is the topic of this section. We will
end up with a characterisation of =ctx in terms of a logical relation, yielding
several useful extensionality properties of contextual equivalence.
7.6.1
Notation: Let Typ denote the set of closed FML types. Given T ∈Typ, let
• Term(T) denote the set of closed terms of type T, i.e., those terms t for
which ∅⊢t : T holds;
• Val(T) denote the subset of Term(T) whose elements are values; and
• Stack(T) denote the set of closed frame stacks whose argument type is T,
i.e., those frame stacks S for which ∅⊢S : T ⊸T′ for some T′ ∈Typ.
Given T, T′ ∈Typ, let
• TRel(T, T′) denote the set of all subsets of Term(T) × Term(T′); we call
its elements term-relations;

7.6
An Operationally Based Logical Relation
267
• VRel(T, T′) denote the set of all subsets of Val(T) × Val(T′); we call its
elements value-relations;
• SRel(T, T′) denote the the set of all subsets of Stack(T) × Stack(T′); we
call its elements stack-relations.
2
Note that every value-relation is also a term-relation (since values are par-
ticular sorts of term): VRel(T, T′) ⊆TRel(T, T′). On the other hand we can
obtain a value-relation from a term-relation just by restricting attention to
values: given r ∈TRel(T, T′), deﬁne r v ∈VRel(T, T′) by
r v def
= {(v, v′) ∈Val(T) × Val(T′) | (v, v′) ∈r}.
(7.17)
We will be particularly interested in term-relations r that are indistinguish-
able, as far as termination properties are concerned, from their value restric-
tions, r v. Deﬁnition 7.6.3 makes this precise, using a Galois connection be-
tween term-relations and stack-relations. The deﬁnition may appear to be
rather mysterious; its nature will emerge as we develop the action of types
on term-relations and its properties. First we recall for the reader what is
meant in general by a “Galois connection.”
7.6.2
Definition: A Galois connection between partially ordered sets (P, ≤P) and
(Q, ≤Q) is speciﬁed by a pair of functions f : P →Q and g : Q →P satisfying
q ≤Q f(p) if and only if p ≤P g(q), for all p ∈P and q ∈Q.
2
7.6.3
Definition [Closed and valuable term-relations]: Let T ∈Typ and T′ ∈
Typ be closed types. Given a term-relation r ∈TRel(T, T′), deﬁne a stack-
relation r s ∈SRel(T, T′) by
(S, S′) ∈r s if and only if for all (t, t′) ∈r, ⟨S, t⟩↓holds if and only if
⟨S′, t′⟩↓does.
Conversely, given a stack-relation s ∈SRel(T, T′), deﬁne a term-relation st ∈
TRel(T, T′) by
(t, t′) ∈st if and only if for all (S, S′) ∈s, ⟨S, t⟩↓holds if and only if
⟨S′, t′⟩↓does.
Call a term-relation r ∈TRel(T, T′) closed if it satisﬁes r = r s t and valuable if
it satisﬁes r = r v s t.
2
7.6.4
Note: The operator (−)s t is denoted (−)⊤⊤in Pitts (1998; 2000).
2

268
7
Typed Operational Reasoning
7.6.5
Lemma: The operations (−)s and (−)t for turning term-relations into stack-
relations and vice versa, form a Galois connection:
s ⊆r s
if and only if
r ⊆st.
(7.18)
Hence the operator (−)s t on term-relations is monotone (r1 ⊆r2 implies
(r1)s t ⊆(r2)s t), inﬂationary (r ⊆r s t), and idempotent ((r s t)s t = r s t).
2
Proof:
If s ⊆r s, then for any (t, t′) ∈r we have for all (S, S′) ∈s that
(S, S′) ∈r s, so ⟨S, t⟩↓iﬀ⟨S′, t′⟩↓; hence (t, t′) ∈st. Thus s ⊆r s implies
r ⊆st. The converse implication holds by a similar argument. Once we have
(7.18), the other properties follow by standard arguments true of any Galois
connection, which we give in case the reader has not seen them before.
Thus for any term-relation r, since r s ⊆r s, from (7.18) we conclude that
r ⊆r s t; so (−)s t is inﬂationary (and symmetrically, so is the operator (−)t s
on stack-relations).
Now we can deduce that (−)s and (−)t are order-reversing. For if r1 ⊆r2,
then r1 ⊆r2 ⊆r s t
2 , so by (7.18), r s
2 ⊆r s
1. Similarly, s1 ⊆s2 implies st
2 ⊆st
1.
Hence (−)s t is monotone (and so is (−)t s).
Finally, for idempotence, in view of the inﬂationary property we just have to
show (r s t)s t ⊆r s t. But applying (7.18) to r s t ⊆r s t we get r s ⊆(r s t)s; applying
the order-reversing operator (−)t to this yields (r s t)s t ⊆r s t, as required.
2
7.6.6
Corollary: Every valuable term-relation is—in particular—a closed term-
relation.
2
Proof:
Note that because (−)s t is idempotent (by the above lemma), any
term-relation of the form r s t is closed. Thus valuable term-relations (ones
satisfying r = r v s t) are in particular closed.
2
The following exercise establishes a supply of valuable term-relations that
we will need later.
7.6.7
Exercise [Recommended, ««]: Given any value-relation r ∈VRel(T, T′), show
that r s t is valuable, i.e., satisﬁes r s t = (r s t)v s t.
2
Closed term-relations (and hence also valuable term-relations) have excel-
lent “admissibility” properties that we record in the following lemma.
7.6.8
Lemma: If r ∈TRel(T, T′) satisﬁes r = r s t (and in particular if it is valuable),
then it has the following properties.
Equivalence-respecting If (t, t′) ∈r, ∅⊢t =ciu t1 : T, and ∅⊢t′ =ciu t′
1 :
T, then (t1, t′
1) ∈r.

7.6
An Operationally Based Logical Relation
269
Admissibility Given recursive function values F
def
= fun f(x:T1)=u:T2 and
F′ def
= fun f(x:T1)=u′:T2, let Fn and F′
n (n = 0, 1, . . .) be their “unwindings,”
as in Theorem 7.4.4. If ([x , Fn]t, [x , F′
n]t′) ∈r for all n = 0, 1, . . ., then
([x , F]t, [x , F′]t′) ∈r.
2
Proof:
Suppose (t, t′) ∈r, ∅⊢t =ciu t1 : T and ∅⊢t′ =ciu t′
1 : T. To see
that (t1, t′
1) ∈r, since r = (r s)t, it suﬃces to show for all (S, S′) ∈r s that
⟨S, t1⟩↓iﬀ⟨S′, t′
1⟩↓. But
⟨S, t1⟩↓iﬀ⟨S, t⟩↓
(since ∅⊢t =ciu t1 : T)
iﬀ⟨S′, t′⟩↓
(since (S, S′) ∈r s and (t, t′) ∈r)
iﬀ⟨S′, t′
1⟩↓
(since ∅⊢t′ =ciu t′
1 : T).
For the Admissibility property we apply the Unwinding Theorem. Suppose
([x , Fn]t, [x , F′
n]t′) ∈r holds for all n = 0, 1, . . .. Then for any (S, S′) ∈r s
we have
⟨S, [x , F]t⟩↓
iﬀfor some n, ⟨S, [x , Fn]t⟩↓
(by Theorem 7.4.4)
iﬀfor some n, ⟨S′, [x , F′
n]t′⟩↓
(since (S, S′) ∈r s and
([x , Fn]t, [x , F′
n]t′) ∈r)
iﬀ⟨S, [x , F′]t′⟩↓
(by Theorem 7.4.4 again)
and therefore ([x , F]t, [x , F′]t′) ∈(r s)t; but r s t = r.
2
7.6.9
Definition [Action of types on term-relations]: The action of types on
term-relations takes the following form: if T(X) is a type whose free type
variables lie among the list X = X1, . . . , Xn, then given a corresponding list
of term relations r1 ∈TRel(T1, T′
1), . . . , rn ∈TRel(Tn, T′
n), we deﬁne a term
relation T[r] ∈TRel([X , T]T, [X , T′]T). The deﬁnition is by induction on
the structure of T as follows.
Xi[r]
def
=
(ri)v s t
Gnd[r]
def
=
(IdGnd)s t
(T1→T2)[r]
def
=
fun(T1[r], T2[r])s t
{li:Ti
i∈1..n}[r]
def
=
{li=Ti[r] i∈1..n}s t
(∀X.T)[r]
def
=
(λr.T[r, r])s t
{∃X,T}[r]
def
=
{∃r,T[r, r]}s t

270
7
Typed Operational Reasoning
IdGnd
∈VRel(Gnd, Gnd)
is {(c, c) | Typeof (c) = Gnd}.
fun(r1, r2)
∈VRel(T1→T2, T′
1→T′
2),
given r1 ∈TRel(T1, T′
1) and r2 ∈TRel(T2, T′
2),
is deﬁned by:
(v, v′) ∈fun(r1, r2) if and only if for all
(v1, v′
1) ∈(r1)v, it is the case that
(v v1, v′ v′
1) ∈r2.
{li=ri
i∈1..n}
∈VRel({li:Ti
i∈1..n},
{li:T′
i
i∈1..n})
given (ri ∈TRel(Ti, T′
i)
i∈1..n),
is deﬁned by:
(v, v′) ∈{li=ri
i∈1..n} if and only if for all
i ∈1..n, it is the case that
(v.li, v′.li) ∈ri.
λr.R(r)
∈VRel(∀X.T, ∀X.T′),
given R(r) ∈TRel([X , T1]T, [X , T′
1]T′)) for
r ∈TRel(T1, T′
1) and T1, T′
1 ∈Typ,
is deﬁned by:
(v, v′) ∈λr.R(r) if and only if for all
T1, T′
1 ∈Typ and all r ∈TRel(T1, T′
1), it
is the case that (v T1, v′ T′
1) ∈R(r).
{∃r,R(r)}
∈VRel({∃X,T}, {∃X,T′}),
given R(r) ∈TRel([X , T1]T, [X , T′
1]T′)) for
r ∈TRel(T1, T′
1) and T1, T′
1 ∈Typ,
is deﬁned by:
(v, v′) ∈{∃r,R(r)} if and only if there
exist T1, T′
1 ∈Typ, r ∈TRel(T1, T′
1) and
(v1, v′
1) ∈R(r) with
v = {*T1,v1} as {∃X,T} and
v′ = {*T′
1,v′
1} as {∃X,T′}.
Figure 7-5: Type-directed constructions on term-relations
In addition to the operations on term-, value- and stack-relations given in
Deﬁnition 7.6.3, these deﬁnitions make use of the operations for constructing
value-relations from term-relations given in Figure 7-5.
2
We can use the action of types on term-relations to deﬁne a type-respecting
binary relation between open terms (in the sense of Deﬁnition 7.5.1) by in-
sisting that if we substitute related terms for the free value variables, the re-
sulting terms are still related. This “mapping related things to related things”
property is the common characteristic of the wide variety of constructs called
logical relations that have arisen since the seminal work of Plotkin (1973) and
Statman (1985) concerning simply typed λ-calculus; see also Chapter 6.
7.6.10
Definition [Logical relation, ∆]: Given Γ ⊢t : T and Γ ⊢t′ : T, with
Γ = X1, . . . ,Xm, x1 : T1, . . . ,xn : Tn say, we write Γ ⊢t ∆t′ : T to mean that
for all Γ-closing substitutions σ, σ ′ (cf. Deﬁnition 7.5.2(v)) and all families of
term-relations r = (ri ∈TRel(σ(Xi), σ ′(Xi)) i∈1..m), if (σ(xj), σ ′(xj)) ∈Tj[r]v
holds for each j = 1, . . . , n, then (σ(t), σ ′(t′)) ∈T[r].
2
7.6.11
Remark: Since it is far from straightforward, the form of Deﬁnitions 7.6.9
and 7.6.10 deserves some explanation. These deﬁnitions embody certain ex-

7.6
An Operationally Based Logical Relation
271
tensionality and parametricity properties (see §7.7 and Theorem 7.7.8) that
we wish to show hold for FML contextual equivalence: eventually we show
that the above logical relation ∆coincides with contextual equivalence (Theo-
rem 7.6.25). To get that coincidence we have to formulate the deﬁnition of ∆
so that it satisﬁes the crucial property of Lemma 7.6.17 below (the so-called
fundamental property of the logical relation) and is adequate (Lemma 7.6.24).
The deﬁnition of the action of types on term-relations in Deﬁnition 7.6.9 is
carefully formulated to ensure these properties hold.
First of all, note the use of closing substitutions to reduce the logical re-
lation for open terms to that for closed ones. This builds in the “instantia-
tion” aspect of ciu-equivalence that we wish to prove of contextual equiva-
lence. (It also means that the logical relation has the “monotonicity” prop-
ertymonotonicity property of logical relations considered in Chapter 6.)
Secondly, we want T[r] to always be a closed term-relation, because then it
has the equivalence-respecting and admissibility properties noted in Lemma
7.6.8. This accounts for the use of (−)s t in the deﬁnition. The (−)s and (−)t
operators build into the logical relation a delicate interplay between terms
and frame stacks. Of course this relies on the formulation of the operational
semantics of FML in §7-3: although more traditional “big-step” or “small-
step” operational semantics lead to the same termination relation (cf. Exer-
cise 7.4.2), the pairing between frame stacks and terms deﬁned in Figure 7-2
is ideal for our purposes.
Lastly, the call-by-value nature of FML dictates that relational parametric-
ity properties of polymorphic types should be with respect to term-relations
that are valuable; but instead of letting r range over such relations in the
deﬁnition of (∀X.T)[r] and {∃X,T}[r] we have used an equivalent formula-
tion in which r ranges over all term-relations (of appropriate type), but type
variables X are interpreted using the closure of the value-restriction opera-
tor (−)v: for in fact as r ranges over all term-relations, r v s t ranges over all
valuable term-relations.
2
The rest of this section is devoted to showing that contextual equivalence
and ciu-equivalence coincide with the logical relation.
7.6.12
Lemma: Each of the term relations T[r] deﬁned in Deﬁnition 7.6.9 is valuable,
i.e., satisﬁes T[r] = T[r]v s t, and hence in particular by Corollary 7.6.6 is
closed.
2
Proof:
It is immediate from the deﬁnition that each T[r] is of the form r s t
for some value-relation r; so just apply Exercise 7.6.7.
2
The following lemma helps with calculations involving the action on term-
relations of function types. We give its proof in detail since it typiﬁes the kind

272
7
Typed Operational Reasoning
of reasoning needed when working with the Galois connection given by the
(−)s and (−)t operators. (For related properties for record and ∀-types, see
Exercise 7.6.14.)
7.6.13
Lemma: The operation fun(−, −) from Deﬁnition 7.6.9(ii) satisﬁes
fun(r1, (r2)s t)s t v = fun(r1, (r2)s t)
(7.19)
fun((r1)v s t, (r2)s t) = fun(r1, (r2)s t).
(7.20)
Proof:
To prove (7.19), ﬁrst note that since (−)s t is inﬂationary (Lemma 7.6.5)
we have fun(r1, (r2)s t) ⊆fun(r1, (r2)s t)s t; and since fun(r1, (r2)s t) is a value-
relation, it follows that fun(r1, (r2)s t) ⊆fun(r1, (r2)s t)s t v. For the reverse
inclusion it suﬃces to prove
fun(r1, (r2)s t)s t ⊆fun(r1, (r2)s t)
(7.21)
and then apply (−)v to both sides (noting that fun(r1, (r2)s t), being a value-
relation, is equal to fun(r1, (r2)s t)v). For (7.21) we use the following simple
property of the termination relation (Figure 7-2) with respect to application:
⟨S ◦(f.f v1), v⟩↓a ⟨S, v v1⟩↓
and hence
(⟨S, v v1⟩↓a ⟨S′, v′ v′
1⟩↓) a
(⟨S ◦(f.f v1), v⟩↓a ⟨S′ ◦(f.f v′
1), v′⟩↓)
(7.22)
If (v, v′) ∈fun(r1, (r2)s t) and (v1, v′
1) ∈(r1)v, then we have (v v1, v′ v′
1) ∈
(r s
2)t by deﬁnition of the fun(−, −) operation on term-relations (Figure 7-5).
So if (S, S′) ∈(r2)s, then
⟨S, v v1⟩↓a ⟨S′, v′ v′
1⟩↓
and hence by (7.22)
⟨S ◦(f.f v1), v⟩↓a ⟨S′ ◦(f.f v′
1), v′⟩↓.
Since this holds for all (v, v′) ∈fun(r1, (r2)s t), we deduce that
(S, S′) ∈(r2)s & (v1, v′
1) ∈(r1)v ⇒
(S ◦(f.f v1), S′ ◦(f.f v′
1)) ∈fun(r1, (r2)s t)s.
So for any (S, S′) ∈(r2)s and (v1, v′
1) ∈(r1)v, since
(S ◦(f.f v1), S′ ◦(f.f v′
1)) ∈fun(r1, (r2)s t)s

7.6
An Operationally Based Logical Relation
273
it follows that if
(v, v′) ∈fun(r1, (r2)s t)s t
(7.23)
then ⟨S ◦(f.f v1), v⟩↓a ⟨S′ ◦(f.f v′
1), v′⟩↓, and hence by (7.22) it fol-
lows that ⟨S, v v1⟩↓a ⟨S′, v′ v′
1⟩↓. Since this holds for all (S, S′) ∈(r2)s,
it follows that (v v1, v′ v′
1) ∈(r2)s t whenever (v1, v′
1) ∈(r1)v. So (v, v′) ∈
fun(r1, (r2)s t) whenever (7.23) holds; thus we have proved the inclusion in
(7.21), as required.
Turning to the proof of (7.20), ﬁrst note that since since (−)s t is inﬂation-
ary, we have (r1)v ⊆(r1)v s t. So since fun(−, −) is clearly order-reversing
in its ﬁrst argument, we have fun((r1)v s t, (r2)s t) ⊆fun((r1)v, (r2)s t); and
fun((r1)v, (r2)s t) = fun(r1, (r2)s t), because fun(−, −) only depends upon the
values related by its ﬁrst argument. Thus to prove (7.20), we just have to show
fun(r1, (r2)s t) ⊆fun((r1)v s t, (r2)s t).
(7.24)
For this we use the following fact about termination
⟨S ◦(x.v x), v1⟩↓a ⟨S, v v1⟩↓
which is immediate from the deﬁnition in Figure 7-2. From this it follows that
(⟨S, v v1⟩↓a ⟨S′, v′ v′
1⟩↓) a
(⟨S ◦(x.v x), v1⟩↓a ⟨S′ ◦(x.v′ x), v′
1⟩↓)
(7.25)
If (v, v′) ∈fun(r1, (r2)s t) and (v1, v′
1) ∈(r1)v, then by deﬁnition of fun(−, −)
we have (v v1, v′ v′
1) ∈(r2)s t. So if (S, S′) ∈(r2)s, then
⟨S, v v1⟩↓a ⟨S′, v′ v′
1⟩↓
and hence by (7.25) we have
⟨S ◦(x.v x), v1⟩↓a ⟨S′ ◦(x.v′ x), v′
1⟩↓.
Since this holds for all (v1, v′
1) ∈(r1)v, we deduce that
(S, S′) ∈(r2)s & (v, v′) ∈fun(r1, (r2)s t) ⇒
(S ◦(x.v x), S′ ◦(x.v′ x)) ∈(r1)v s.
So for any (S, S′) ∈(r2)s and (v, v′) ∈fun(r1, (r2)s t), since (S ◦(x.v x), S′ ◦
(x.v′ x)) ∈(r1)v s, it follows for any (v1, v′
1) ∈((r1)v s t)v ⊆((r1)v s)t that
we have ⟨S ◦(x.v x), v1⟩↓a ⟨S′ ◦(x.v′ x), v′
1⟩↓, and hence by (7.25) that
⟨S, v v1⟩↓a ⟨S′, v′ v′
1⟩↓. Since this holds for all (S, S′) ∈(r2)s, it follows that
(v v1, v′ v′
1) ∈(r2)s t. Hence (v, v′) ∈fun((r1)v s t, (r2)s t) whenever (v, v′) ∈
fun(r1, (r2)s t), as required for (7.24).
2

274
7
Typed Operational Reasoning
7.6.14
Exercise [Recommended, «]: Show that constructions (iii) and (iv) in Deﬁni-
tion 7.6.9 satisfy
{li=(ri)s t i∈1..n}s t v = {li=(ri)s t i∈1..n}
(7.26)
(λr.R(r)s t)s t v = λr.R(r)s t.
(7.27)
(Cf. the proof of Lemma 7.6.13.)
2
7.6.15
Lemma: For all ground types Gnd, (IdGnd)s t v = IdGnd.
2
Proof:
Since (−)s t is idempotent (Lemma 7.6.5), we have IdGnd ⊆(IdGnd)s t;
and since IdGnd is a value-relation it follows that IdGnd ⊆(IdGnd)s t v. To prove
the reverse inclusion, for each constant c of type Gnd consider
diverge
def
= (fun f(b:Bool) = f b : Bool)true
Sc
def
= Id ◦(x. if x=c then true else diverge).
Note that for all constants c′ of type Gnd
⟨Sc, c′⟩↓a c = c′.
(7.28)
Furthermore, since (c′, c′′) ∈IdGnd iﬀc′ = c′′, we have that (Sc, Sc) ∈(IdGnd)s;
so if the constants c and c′ satisfy (c, c′) ∈(IdGnd)s t, then we have ⟨Sc, c⟩↓a
⟨Sc, c′⟩↓. So by (7.28), (c, c′) ∈(IdGnd)s t implies c = c′; thus (IdGnd)s t v ⊆
IdGnd.
2
7.6.16
Lemma: The action of types on term-relations of Deﬁnition 7.6.9 has the fol-
lowing substitution property. For any types T and T′ with ftv(T) ⊆X, X and
ftv(T′) ⊆X, it is the case that ([X , T′]T)[r] = T[T′[r], r].
2
Proof:
This follows by induction on the structure of the type T; for the base
case when T = X, use Lemma 7.6.12.
2
7.6.17
Lemma [Fundamental property of the logical relation]: The logical re-
lation ∆of Deﬁnition 7.6.10 has the substitutivity and compatibility proper-
ties deﬁned in Figure 7-4.
2
Proof:
The ﬁrst substitutivity property in Figure 7-4 (closure under substi-
tuting values for value variables) holds for ∆because of the way it is de-
ﬁned in terms of closing substitutions. The second substitutivity property
(closure under substituting types for types variables) holds for ∆because of
Lemma 7.6.16.

7.6
An Operationally Based Logical Relation
275
Now consider the compatibility properties given in Figure 7-4. There is one
for each clause in the grammar of FML terms and values (Figure 7-1). We con-
sider each in turn, giving the details in some cases and setting the others as
exercises (with solutions).
Value variables: This case is immediate from the deﬁnition of ∆in Deﬁni-
tion 7.6.10.
Constants: We have to show for each constant c, with Typeof (c) = Gnd
say, that (c, c) ∈Gnd[r] = (IdGnd)s t. But by deﬁnition of IdGnd (Figure 7-5),
(c, c) ∈IdGnd; and IdGnd ⊆(IdGnd)s t by Lemma 7.6.5.
Recursive functions: Using property (7.19) and the fact that each T[r] is
valuable and hence closed (Lemma 7.6.12), the compatibility property for re-
cursive functions reduces to proving the property in Exercise 7.6.18.
Record values: This case follows from the property in Exercise 7.6.19.
Type abstractions: This case follows from the property in Exercise 7.6.20.
Package values: This case follows easily from the deﬁnition of {∃r,R(r)}
in Figure 7-5, using Lemma 7.6.16.
Conditionals: This case follows from the property in Exercise 7.6.21.
Operations: In view of Lemma 7.6.15, this compatibility property follows
once we prove (op(ci
i∈1..n), op(ci
i∈1..n)) ∈(IdGnd)s t for any (suitably typed)
constants ci and operator op. But if the value of op(ci
i∈1..n) is the constant c
say, then for any S
⟨S, op(ci
i∈1..n)⟩↓a ⟨S, c⟩↓.
Hence for any (S, S′) ∈(IdGnd′)s (where Gnd′ = Typeof (c)), we have
⟨S, op(ci
i∈1..n)⟩↓a ⟨S, c⟩↓
a ⟨S′, c⟩↓
(since (c, c) ∈IdGnd′)
a ⟨S′, op(ci
i∈1..n)⟩↓.
So we do indeed have (op(ci
i∈1..n), op(ci
i∈1..n)) ∈(IdGnd)s t.
Applications: This case amounts to proving that if recursive function values
v and v′ satisfy (v, v′) ∈fun(r1, r2)s t for some closed term-relations r1 and
r2, then for any (v1, v′
1) ∈r1 it is the case that (v v1, v′ v′
1) ∈r2. But this
property follows immediately from the deﬁnition of fun(−, −) using the ﬁrst
part of Lemma 7.6.13: for
(v, v′) ∈fun(r1, r2)s t v
= fun(r1, (r2)s t)s t v
(since r2 is closed)
= fun(r1, (r2)s t)
(by (7.19))
= fun(r1, r2)
(since r2 is closed).

276
7
Typed Operational Reasoning
Projections: This case is similar to the previous one, but using property
(7.26) from Exercise 7.6.14 rather than (7.19).
Type applications: This case is similar to the previous one, using property
(7.27) from Exercise 7.6.14.
Unpacking: This case follows from the property in Exercise 7.6.22.
Sequencing: This case follows from the property in Exercise 7.6.23.
2
7.6.18
Exercise [Recommended, «««]: Suppose
F
def
= fun f(x:T1)=t:T2 ∈Val(T1→T2)
F′ def
= fun f(x:T′
1)=t′:T′
2 ∈Val(T′
1→T′
2)
r1 ∈TRel(T1, T′
1)
r2 ∈TRel(T2, T′
2)
satisfy r2 = (r2)s t and
([f , v][x , v1]t, [f , v′][x , v′
1]t′) ∈r2,
for all (v, v′) ∈fun(r1, r2) and (v1, v′
1) ∈(r1)v.
(7.29)
Use the admissibility property of valuable term-relations established in Lem-
ma 7.6.8 to show that (F, F′) ∈fun(r1, r2).
2
7.6.19
Exercise [««]: Suppose for i ∈1..n that vi ∈Val(Ti), v′
i ∈Val(T′
i) and ri ∈
TRel(Ti, T′
i) with ri = (ri)s t. Putting
v
def
= {li=vi
i∈1..n} ∈Val({li:Ti
i∈1..n})
v′ def
= {li=v′
i
i∈1..n} ∈Val({li:T′
i
i∈1..n})
show that if (vi, v′
i) ∈ri for i ∈1..n, then (v, v′) is in the value-relation
{li=ri
i∈1..n} deﬁned in Figure 7-5.
2
7.6.20
Exercise [««]: Let T and T′ be types with at most X free. For each T1, T′
1 ∈Typ
and r ∈TRel(T1, T′
1) suppose we are given a closed term-relation R(r) in
TRel([X , T1]T, [X , T′
1]T′)) (i.e., R(r) = R(r)s t). Show that if the values v
and v′ satisfy
X ⊢v : T
X ⊢v′ : T′
∀T1, T′
1 ∈Typ, r ∈TRel(T1, T′
1). ([X , T1]v, [X , T′
1]v′) ∈R(r)
then (λX.v, λX.v′) is in the value-relation λr.R(r) deﬁned in Figure 7-5.
2

7.6
An Operationally Based Logical Relation
277
7.6.21
Exercise [««]: Suppose (v, v′) ∈(IdBool)s t and (t1, t′
1), (t2, t′
2) ∈r, where
r ∈TRel(T, T′) is closed (i.e., r = (r)s t). Show that
(if v then t1 else t2, if v′ then t′
1 else t′
2)
is in r.
2
7.6.22
Exercise [««]: Let T and T′ be types with at most X free. For each T1, T′
1 ∈Typ
and r1 ∈TRel(T1, T′
1) suppose we are given a closed term-relation R(r1) =
R(r1)s t in TRel([X , T1]T, [X , T′
1]T′)). Suppose we are also given a closed
term-relation r2 = (r2)s t ∈TRel(T2, T′
2) for some closed types T2, T′
2 ∈Typ.
Show that if the terms t, t′ satisfy
X, x : T ⊢t : T2
X, x : T′ ⊢t′ : T′
2
∀T1, T′
1 ∈Typ, r1 ∈TRel(T1, T′
1), (v1, v′
1) ∈(r1)v.
([X , T1][x , v1]t, [X , T1][x , v1]t) ∈r2
then whenever (v, v′) ∈{∃r1,R(r1)}s t v, it is also the case that
(let {*X,x}=v in t, let {*X,x}=v′ in t′)
is in r2.
2
7.6.23
Exercise [««]: Suppose we are given r1 ∈TRel(T1, T′
1), r2 ∈TRel(T2, T′
2) with
r1 valuable (i.e., r1 = (r1)v s t) and r2 closed (i.e., r2 = (r2)s t). Show that if the
terms t2, t′
2 satisfy
x : T1 ⊢t2 : T2
x : T′
1 ⊢t′
2 : T′
2
∀(v1, v′
1) ∈(r1)v. ([x , v1]t2, [x , v′
1]t′
2) ∈r2
then whenever (t1, t′
1) ∈r1, it is also the case that
(let x=t1 in t2, let x=t′
1 in t′
2)
is in r2.
2
7.6.24
Lemma [Adequacy]: The logical relation ∆is adequate (Deﬁnition 7.5.1).
2
Proof:
Suppose ∅⊢t ∆t′ : T; we have to show that t ↓holds iﬀt′ ↓does,
or equivalently that
⟨Id, t⟩↓
iﬀ
⟨Id, t′⟩↓.
(7.30)

278
7
Typed Operational Reasoning
Unraveling Deﬁnition 7.6.10, the assumption that the closed terms t and t′
of closed type T are ∆-related means that (t, t′) ∈T[], the latter being the
action of the type T on the empty list of term-relations. By Lemma 7.6.12, T[]
is valuable; so (t, t′) ∈T[]v s t. Hence to prove (7.30), it suﬃces to show that
(Id, Id) ∈(T[]v)s; but for any (v, v′) ∈T[]v,
⟨Id, v⟩↓
iﬀ
⟨Id, v′⟩↓
holds trivially by axiom (S-NilVal) in Figure 7-2.
2
We are ﬁnally able to put all the pieces together and prove the main result
of this section. At the same time we complete the proof of Theorem 7.5.7.
7.6.25
Theorem [=ctx equals ∆equals =ciu]: FML contextual equivalence, =ctx, (as
deﬁned in Theorem 7.5.3) coincides with the logical relation ∆of Deﬁni-
tion 7.6.10 and with ciu-equivalence, =ciu (Deﬁnition 7.5.5): Γ ⊢t =ctx t′ : T
holds if and only if Γ ⊢t ∆t′ : T does, if and only if Γ ⊢t =ciu t′ : T does. 2
Proof:
It suﬃces to show that the following chain of inclusions holds:
=ctx
(1)
⊆=ciu
(3)
⊆∆
(2)
⊆=ctx.
(1) This is the half of Theorem 7.5.7 that we have already proved in §7.5.
(2) We have not yet shown that ∆is an equivalence relation; and in fact we
will only deduce this once we have shown that it coincides with =ctx and
=ciu (which are easily seen to be equivalence relations). However, we have
shown that ∆is compatible, substitutive and adequate (Lemmas 7.6.17 and
7.6.24). In the proof of Theorem 7.5.3 we constructed =ctx as the union of
all such type-respecting relations, without regard to whether they were
also equivalence relations; therefore ∆is contained in =ctx.
(3) Noting how =ciu and ∆are deﬁned on open terms via substitutions, we
can combine the ﬁrst part of Lemma 7.6.8 with Lemma 7.6.12 to give
Γ ⊢t =ciu t′ : T & Γ ⊢t′ ∆t′′ : T ⇒Γ ⊢t ∆t′′ : T.
(7.31)
We noted in the proof of Theorem 7.5.3 that every compatible term-relation
is reﬂexive. (This is easily proved by induction on the structure of terms.)
So since ∆is compatible (Lemma 7.6.17) it is in particular reﬂexive. So
we can take t′ = t′′ in (7.31) to deduce that Γ ⊢t =ctx t′ : T implies
Γ ⊢t ∆t′ : T.
2

7.7
Operational Extensionality
279
7.7
Operational Extensionality
In this section we develop some of the consequences of Theorem 7.6.25.
Now that we know that contextual equivalence coincides with ciu-equivalence
(Theorem 7.5.7), when giving general properties of =ctx we restrict attention
to closed terms of closed type where possible, since the corresponding prop-
erty for open terms can be obtained via closing substitutions.
7.7.1
Theorem [Extensionality for values]: We now give extensionality princi-
ples for the various types of value; for package values, the principle is a for-
malization of the ﬁnal one discussed in the Introduction (Principle 7.3.6).
1. Constants: Given constants c, c′ of the same ground type, Gnd say, ∅⊢
c =ctx c′ : Gnd holds if and only if c = c′.
2. Functions: Given f:T1→T2, x:T1 ⊢t : T2 and f:T1→T2, x:T1 ⊢t′ : T2,
writing v and v′ for the recursive function values fun f(x:T1)=t:T2 and
fun f(x:T1)=t′:T2 respectively, then ∅⊢v =ctx v′ : T1→T2 if and only
if for all ∅⊢v1 : T1, it is the case that ∅⊢[f , v][x , v1]t =ctx [f ,
v′][x , v1]t′ : T2.
3. Records: Given values ∅⊢vi : Ti and ∅⊢v′
i : Ti for i ∈1..n, then
∅⊢{li=vi
i∈1..n} =ctx {li=v′
i
i∈1..n} : {li:Ti
i∈1..n} if and only if for each
i ∈1..n, ∅⊢vi =ctx v′
i : Ti.
4. Type abstractions: Given X ⊢v : T and X ⊢v′ : T, then ∅⊢λX.v =ctx
λX.v′ : ∀X.T if and only if for all closed types T′, ∅⊢[X , T′]v =ctx [X ,
T′]v′ : [X , T′]T.
5. Packages: For any closed existential type {∃X,T}, closed types T1, T2, and
values ∅⊢vi : [X , Ti]T (i = 1, 2),
∅⊢{*T1,v1} as {∃X,T} =ctx {*T2,v2} as {∃X,T} : {∃X,T}
holds if there is some term-relation r ∈TRel(T1, T2) with (v1, v2) ∈T[r]. 2
Proof:
1. The property for constants follows from Lemma 7.6.15 combined with
Theorem 7.6.25.
2. Suppose for all ∅⊢v1 : T1 that
∅⊢[f , v][x , v1]t =ctx [f , v′][x , v1]t′ : T2
(7.32)

280
7
Typed Operational Reasoning
where v and v′ are as in part 2 of the theorem. To show ∅⊢v =ctx
v′ : T1→T2, by Theorem 7.6.25 it suﬃces to show ∅⊢v ∆v′ : T1→T2,
i.e., that (v, v′) ∈(T1→T2)[] = fun(T1[], T2[])s t. In fact we show that
(v, v′) ∈fun(T1[], T2[]). For this we have to prove that if (v1, v′
1) ∈T1[]v,
then (v v1, v′ v′
1) ∈T2[]. By Theorem 7.6.25 again, this is the same as
showing: if ∅⊢v1 =ctx v′
1 : T1, then ∅⊢v v1 =ctx v′ v′
1 : T2. As noted in
Corollary 7.5.8, we can turn the primitive reduction for function applica-
tion into a ciu-equivalence and hence by Theorem 7.6.25 into a contextual
equivalence:
∅⊢v v1 =ctx [f , v][x , v1]t : T2
(7.33)
and similarly for v′ v′
1. Therefore we just need to show: if ∅⊢v1 =ctx v′
1 :
T1, then ∅⊢[f , v][x , v1]t =ctx [f , v′][x , v′
1]t′ : T2. But this
follows from the assumption (7.32) using the reﬂexivity and substitutivity
properties of =ctx. So we have established one half (the diﬃcult half) of
the property in 2. For the converse, if ∅⊢v =ctx v′ : T1→T2, then for any
∅⊢v1 : T1, the compatibility properties of =ctx give ∅⊢v v1 =ctx v′ v1 :
T2; and then as before, we can compose with (7.33) to get (7.32).
3. We leave the extensionality property for records as an exercise (7.7.2).
4. For the property for type abstractions, suppose
∀T′ ∈Typ.
∅⊢[X , T′]v =ctx [X , T′]v′ : [X , T′]T.
(7.34)
Note that since ∆coincides with =ctx (Theorem 7.6.25) it is reﬂexive and
hence X ⊢v ∆v : T holds. According to Deﬁnition 7.6.10 this means
that for all T1, T′
1 ∈Typ and r ∈TRel(T1, T′
1), ([X , T1]v, [X , T′
1]v) ∈
T[r]. Since T[r] is closed (Lemma 7.6.12), we can combine (7.34) with the
ﬁrst part of Lemma 7.6.8 (using =ctx in place of =ciu by virtue of Theo-
rem 7.6.25) to conclude that ([X , T1]v, [X , T′
1]v′) ∈T[r] for all r. Then
using the equivalence in Corollary 7.5.8(v), we have
∀T1, T′
1 ∈Typ, r ∈TRel(T1, T′
1).
((λX.v)T1, (λX.v′)T′
1) ∈T[r]
and hence (λX.v, λX.v′) is in λr.T[r]. Since λr.T[r] ⊆(λr.T[r])s t and
the latter is equal to (∀X.T)[] by deﬁnition, we have ∅⊢λX.v ∆λX.v′ :
∀X.T, and hence by Theorem 7.6.25, ∅⊢λX.v =ctx λX.v′ : ∀X.T. So
we have established one half (the diﬃcult half) of the property in 4. The
argument for the other half is similar to that for property 2, using Corol-
lary 7.5.8(v) and the congruence properties of =ctx.

7.7
Operational Extensionality
281
5. Finally, let us consider the extensionality property for package values.
(Note that unlike the other four, this only gives a suﬃcient condition for
contextual equivalence; Example 7.7.4 below shows that the condition is
not necessary.) If (v1, v2) ∈T[r], then from Deﬁnition 7.6.9 we have
({*T1,v1} as {∃X,T}, {*T2,v2} as {∃X,T}) ∈{∃r,T[r]}
⊆{∃r,T[r]}s t
= {∃X,T}[].
Thus ∅⊢{*T1,v1} as {∃X,T} ∆{*T2,v2} as {∃X,T} : {∃X,T} and we
can apply Theorem 7.6.25 to get the desired contextual equivalence.
2
7.7.2
Exercise [««, 3]: Use Theorem 7.6.25, Corollary 7.5.8 and the deﬁnition of
the term-relation {li=ri
i∈1..n} in Deﬁnition 7.6.9 to deduce extensionality prop-
erty 3 of Theorem 7.7.1.
2
To see how Theorem 7.7.1(5) can be used in practice, we will apply it to
establish the contextual equivalence of Example 7.3.5 from the Introduction.
7.7.3
Example: Recall the type Semaphore and its values semaphore1, semaphore2
from Example 7.3.5. To show ∅⊢semaphore1 =ctx semaphore2 : Semaphore
using Theorem 7.7.1(5), it suﬃces to show that (v1, v2) ∈T[r] where
T
def
= {bit:X, flip:X→X, read:X→Bool}
v1
def
= {bit=true, flip=λx:Bool.not x, read=λx:Int.x}
v2
def
= {bit=1, flip=λx:Int.0-2*x, read=λx:Int.x >= 0}
and r ∈VRel(Bool, Int) is
r
def
=
{(true, m) | m = (−2)n for some even n ≥0} ∪
{(false, m) | m = (−2)n for some odd n ≥0}.
Since r is a value-relation, we can use Lemma 7.6.13 to slightly simplify T[r]:
T[r]
def
=
{bit=r s t, flip=fun(r s t, r s t)s t, read=fun(r s t, Ids t
Bool)s t}s t
=
{bit=r s t, flip=fun(r, r s t)s t, read=fun(r, Ids t
Bool)s t}s t.
So since (−)s t is inﬂationary, to prove (v1, v2) ∈T[r], it suﬃces to show
(true, 1)
∈
r
(λx:Bool.not x, λx:Int.0-2*x)
∈
fun(r, r s t)
(λx:Int.x, λx:Int.x >= 0)
∈
fun(r, Ids t
Bool).

282
7
Typed Operational Reasoning
These follow from the deﬁnition of r—the ﬁrst trivially and the second two
once we combine the deﬁnition of fun(−, −) with the fact (Lemma 7.6.8)
that closed relations such as r s t and Ids t
Bool respect ciu-equivalence. For ex-
ample, if (v1, v′
1) ∈r, then (λx:Bool.not x)v1 and (λx:Int.0-2*x)v′
1 are
ciu-equivalent to r-related values v2 and v′
2; then since (v2, v′
2) ∈r ⊆r s t and
the latter is closed, we have ((λx:Bool.not x)v1, (λx:Int.0-2*x)v′
1) ∈r s t.
As this holds for all (v1, v′
1) ∈r, we have (λx:Bool.not x, λx:Int.0-2*x) in
fun(r, r s t).
2
Theorem 7.7.1(5) gives a suﬃcient condition for contextual equivalence of
package values, but the condition is not necessary: it can be the case that
{* T1, v1} as {∃X, T} is contextually equivalent to {* T2, v2} as {∃X, T}
even though there is no r ∈TRel(T1, T2) with (v1, v2) ∈T[r]. The rest of
this section is devoted to giving an example of this unpleasant phenomenon
(based on a suggestion of Ian Stark arising out of our joint work on logical
relations for functions and dynamically allocated names in Pitts and Stark,
1993).
7.7.4
Example: Consider the following types and terms.
P
def
= (X→Bool)→Bool
Q
def
= {∃X,P}
N
def
= ∀X.X
diverge
def
= (fun f(b:Bool) = f b : Bool)true
G
def
= fun g(f:N→Bool) = diverge : Bool
G′
def
= fun g(f:Bool→Bool) =
(if f true then
if f false then diverge else true
else diverge) : Bool.
Thus N is a type with no values (Exercise 7.7.6); G is a function that diverges
when applied to any value of type N→Bool; and G′ is a function that diverges
when applied to any value of type Bool→Bool except ones (such as the iden-
tity function) that map true to true and false to false, in which case it
returns true. We claim that
(i) there is no r ∈TRel(N, Bool) for which (G, G′) ∈P[r] holds,
(ii) but nevertheless ∅⊢{*N,G} as Q =ctx {*Bool,G′} as Q : Q.
2

7.7
Operational Extensionality
283
Proof:
For (i) note that the deﬁnition of N implies that Val(N) = ∅, i.e., there
are no closed values of type N (Exercise 7.7.6). So any r ∈TRel(N, Bool) satis-
ﬁes r v = ∅. Now
P[r]v
def
= ((X→Bool)→Bool)[r]v
def
= fun((X→Bool)[r], Ids t
Bool)s t v
= fun((X→Bool)[r], Ids t
Bool)
using (7.19)
def
= fun(fun(r v s t, Ids t
Bool)s t, Ids t
Bool)
= fun(fun(r v s t, Ids t
Bool)s t v, Ids t
Bool)
by deﬁnition of fun(−, −)
= fun(fun(r v s t, Ids t
Bool), Ids t
Bool)
using (7.19)
= fun(fun(r, Ids t
Bool), Ids t
Bool)
using (7.20)
= fun(fun(r v, Ids t
Bool), Ids t
Bool)
by deﬁnition of fun(−, −).
Since r v = ∅, we have fun(r v, Ids t
Bool) = Val(N→Bool)×Val(Bool→Bool); and
we know by Theorem 7.6.25 that Ids t
Bool is the relation {(t, t′) | ∅⊢t =ctx
t′ : Bool}. Therefore
P[r]v = {(v, v′) |
∅⊢v v1 =ctx v′ v′
1 : Bool
for all v1 ∈Val(N→Bool) and v′
1 ∈Val(Bool→Bool) }.
However, ∅⊢G v1 =ctx G′ v′
1 : Bool does not hold if we take v1 and v′
1 to be
the values
v1
def
= fun f(x:N) = diverge : Bool
v′
1
def
= fun f(x:Bool) = x : Bool
since evaluation of G v1 does not terminate, whereas evaluation of G′ v′
1 does.
Therefore (G, G′) ∉P[r]v, for any r ∈TRel(N, Bool).
Turning to the proof of (ii), now we know that it cannot be deduced from
the extensionality principle for package values in Theorem 7.7.1, we have to
prove this contextual equivalence by brute force. The termination relation
deﬁned in Fig. 7-2 provides a possible strategy (if rather a tedious one) for
proving ciu-equivalences and hence contextual equivalences—by what one
might call termination induction. Thus to prove (ii) it suﬃces to prove that
the two terms are ciu-equivalent:
∀S.
⟨S, {*N,G} as Q⟩↓a ⟨S, {*Bool,G′} as Q⟩↓.
Attempting to do this by induction on the derivation of terminations ⟨−, −⟩↓
(for all S simultaneously), one rapidly realizes that a stronger induction hy-
pothesis is needed: prove for all frame stacks S and terms t that

284
7
Typed Operational Reasoning
⟨[x , {*N,G} as Q]S, [x , {*N,G} as Q]t⟩↓
if and only if ⟨[x , {*Bool,G′} as Q]S, [x , {*Bool,G′} as Q]t⟩↓.
It is possible to prove this by induction on the deﬁnition of the termination
relation in Fig. 7-2 (for all S and t simultaneously). We omit the details except
to note that the only diﬃcult induction step is for the primitive reduction
(R-UnpackPack) in Fig. 7-3 in the case that t is the form let{*X,g}=x in t′.
For that step, one can ﬁrst show for all frame stacks S and terms t that
⟨[X , N][g , G]S, [X , N][g , G]t⟩↓
if and only if ⟨[X , Bool][g , G′]S, [X , Bool][g , G′]t⟩↓.
This also is proved by induction on the deﬁnition of the termination relation.
Once again we omit the details except to note that now the only diﬃcult in-
duction step is for the primitive reduction (R-AppAbs) in the case that t is of
the form g v for some value v. To prove that step one can use Lemma 7.7.5
below. This lemma lies at the heart of the reason why the contextual equiva-
lence in (ii) is valid: if an argument supplied to G′ is suﬃciently polymorphic
(which is guaranteed by the existential abstraction), then when specialized to
Bool it cannot have the functionality (true , true, false , false) needed
to distinguish G′ from the divergent behavior of G.
2
7.7.5
Lemma: For any value v satisfying X, g:P ⊢v : X→Bool, evaluation of G′([X ,
Bool][g , G′]v) does not terminate.
2
Proof:
To prove this we can use the logical relation from the previous sec-
tion. Consider the following value-relation in VRel(Bool, Bool):
r
def
= {(true, true), (false, false), (true, false)}.
Note that
(X→Bool)[r]v
def
= fun(rv s t, Ids t
Bool)s t v
(7.20)
=
fun(r, Ids t
Bool)s t v (7.19)
=
fun(r, Ids t
Bool)
(7.35)
and hence
P[r]v
def
= fun((X→Bool)[r], Ids t
Bool)s t v = fun((X→Bool)[r]v, Ids t
Bool)s t v
(7.35)
=
fun(fun(r, Ids t
Bool), Ids t
Bool)s t v (7.19)
=
fun(fun(r, Ids t
Bool), Ids t
Bool).
(7.36)
If (v1, v′
1) ∈fun(r, Ids t
Bool), since (true, true), (false, false) ∈r and Ids t
Bool
is contextual equivalence (Theorem 7.6.25) we get
∅⊢v1 true =ctx v′
1 true : Bool
∅⊢v1 false =ctx v′
1 false : Bool.

7.7
Operational Extensionality
285
So using Corollary 7.5.8(iii) and the congruence properties of =ctx, we have
G′ v1 =ctx (if v1 true then
if v1 false then diverge else true
else diverge)
=ctx (if v′
1 true then
if v′
1 false then diverge else true
else diverge)
=ctx G′ v′
1
Therefore (G′ v1, G′ v′
1) ∈Ids t
Bool whenever (v1, v′
1) ∈fun(r, Ids t
Bool); and so
(G′, G′) ∈P[r]v, by (7.36). Hence using Lemma 7.6.17 we have
([X , Bool][g , G′]v, [X , Bool][g , G′]v) ∈(X→Bool)[r]v
= fun(r, Ids t
Bool)
by (7.35).
So since (true, false) ∈r, we get
([X , Bool][g , G′]v true, [X , Bool][g , G′]v false) ∈Ids t
Bool.
Thus ([X , Bool][g , G′]v)true and ([X , Bool][g , G′]v)false are
contextually equivalent closed terms of type Bool. Therefore it cannot be
the case that the ﬁrst evaluates to true and the second to false (cf. Exer-
cise 7.5.10); but in that case, by deﬁnition of G′, it must be that evaluation of
G′([X , Bool][g , G′]v) does not terminate.
2
7.7.6
Exercise [«, 3]: By considering the possible typing derivations from the rules
in Figure 7-1, show that there is no value v satisfying ∅⊢v : ∀X.X. (Note
that the syntactic restriction on values of universally quantiﬁed type men-
tioned in Remark 7.4.1 plays a crucial role here.)
2
7.7.7
Remark [The role of non-termination]: Example 7.7.4 shows that the log-
ical relation presented here is incomplete for proving contextual equivalence
of FML values of existential type. The example makes use of the fact that, be-
cause of the presence of recursive function values, evaluation of FML terms
need not terminate. However, it seems that the source of the incompleteness
has more to do with the existence of types with no values (such as ∀X.X) than
with non-termination. Eijiro Sumii (private communication) has suggested the

286
7
Typed Operational Reasoning
following, “terminating” version of Example 7.7.4:
P
def
= (X→Bool)→Bool
Q
def
= {∃X,P}
N
def
= ∀X.X
H
def
= λf:N→Bool. false
H′
def
= λf:Bool→Bool.
(if f true then
if f false then false else true
else false) : Bool.
Consider a version of FML with only non-recursive function abstractions (i.e.
with λx:T.t rather than fun f(x:T) = t:T′). Evaluation is terminating in this
version. So to be non-trivial, contextual equivalence should be formulated in
terms of observing convergence to the same ground value in all contexts of
ground type. Making corresponding changes to the deﬁnition of the opera-
tions (−)s and (−)t on term- and stack-relations, one could develop a logical
relation for this terminating version of FML. It seems that properties (i) and (ii)
in Example 7.7.4 are also true of H and H′ in this version (the ﬁrst by the same
argument we gave, but the second by a diﬀerent argument that nevertheless
hinges on the observation at the end of the proof of Example 7.7.4). We leave
investigating this as an extended exercise for the reader.
2
The proof of Lemma 7.7.5 exploits “relational parametricity” properties of
polymorphic types in FML. In fact Theorem 7.6.25 tells us far more about the
properties of type abstraction values than just the extensionality property of
Theorem 7.7.1(4).
7.7.8
Theorem [Relational parametricity for ∀-types]: Given X ⊢v : T and
X ⊢v′ : T, then ∅⊢λX.v =ctx λX.v′ : ∀X.T if and only if for all closed
types T1, T′
1 ∈Typ and all term-relations r ∈TRel(T1, T′
1) it is the case that
([X , T1]v, [X , T′
1]v′) ∈T[r].
2
Proof:
By Theorem 7.6.25, we have that ∅⊢λX.v =ctx λX.v′ : ∀X.T iﬀ
∅⊢λX.v ∆λX.v′ : ∀X.T, i.e., iﬀ(λX.v, λX.v′) ∈(∀X.T)[] = (λr.T[r])s t.
Since λX.v and λX.v′ are values, the latter is the case iﬀ(λX.v, λX.v′) ∈
(λr.T[r])s t v, and by Lemma 7.6.12 and Exercise 7.6.14 (λr.T[r])s t v = λr.T[r].
Hence ∅⊢λX.v =ctx λX.v′ : ∀X.T iﬀ(λX.v, λX.v′) ∈λr.T[r]. By deﬁnition
(Figure 7-5), this is the case iﬀfor all for all closed types T1, T′
1 ∈Typ and
all term-relations r ∈TRel(T1, T′
1), ((λX.v)T1, (λX.v′)T′
1) ∈T[r]; and the

7.7
Operational Extensionality
287
latter holds iﬀ([X , T1]v, [X , T′
1]v′) ∈T[r], because (λX.v)T1 =ciu [X ,
T1]v and (λX.v′)T′
1 =ciu [X , T′
1]v′ (so that we can use Lemmas 7.6.8 and
7.6.12).
2
The force of Theorem 7.7.1(4) is to give a method for establishing that two
type abstraction values are contextually equivalent. By contrast, the force of
Theorem 7.7.8 is to give us useful properties of families of values parameter-
ized by type variables. Given such a value, X ⊢v : T, since =ctx is reﬂexive,
we have ∅⊢λX.v =ctx λX.v : ∀X.T; hence the theorem has the following
corollary.
7.7.9
Corollary: Given a value X ⊢v : T, for all T1, T′
1 ∈Typ and all r ∈
TRel(T1, T′
1), it is the case that ([X , T1]v, [X , T′
1]v) ∈T[r].
2
Such “relational parametricity” properties can often be exploited for prov-
ing contextual equivalences: we already saw an example in the proof of Lem-
ma 7.7.5 and other examples can be found in Pitts (2000), Bierman, Pitts, and
Russo (2000), and Johann (2002). However, the strict nature of function ap-
plication and type abstraction in FML means that it does not satisfy all the
parametricity properties one might expect. For example, in Pitts (2000), §7, it
is shown that
{∃X,T} ≊∀Y.(∀X.T→Y)→Y
holds in the polymorphic version of PCF (Plotkin, 1977) studied in that pa-
per (where ≊is “bijection up to contextual equivalence”—see Principle 7.3.4).
However this bijection does not hold in general for FML (Exercise 7.7.10).
7.7.10
Exercise [«««]: Consider the type N
def
= ∀X.X from Example 7.7.4 that you
showed has no closed values in Exercise 7.7.6. Show that there cannot exist
values
i ∈Val({∃X,N}→∀Y.(∀X.N→Y)→Y)
j ∈Val((∀Y.(∀X.N→Y)→Y)→{∃X,N})
that are mutually inverse, in the sense that
p:{∃X,N} ⊢j(i p) =ctx p : {∃X,N}
y:∀Y.(∀X.N→Y)→Y ⊢i(j y) =ctx y : ∀Y.(∀X.N→Y)→Y.
2
7.7.11
Exercise [«««, 3]: Verify the claim made in Note 7.3.7 that Principle 7.3.4 is
a special case of Principle 7.3.6. To do so, you will ﬁrst have to give a deﬁni-
tion of the action of FML types on bijections mentioned in Principle 7.3.4.
2

288
7
Typed Operational Reasoning
7.8
Notes
This chapter is a revised and expanded version of Pitts (1998) and also draws
on material from Pitts (2000).
In discussing typed operational reasoning we have focused on reasoning
about contextual equivalence of program phrases. Being by construction a
congruence, contextual equivalence permits us to use the usual forms of
equational reasoning (replacing equals by equals) when deriving equivalences
between phrases. However, its deﬁnition does not lend itself to establish-
ing the basic laws that are needed to get such reasoning going. We studied
two characterisations of contextual equivalence in order to get round this
problem: ciu-equivalence (Deﬁnition 7.5.5) and a certain kind of operationally
based logical relation (Deﬁnition 7.6.10).
contextual equivalence!vs. bisimilarity The informal notion of contextual
equivalence (Deﬁnition 7.3.2) has been studied for a wide variety of pro-
gramming languages. If the language’s operational semantics involves non-
determinism—usually because the language supports some form of concur-
rent or interactive computation—then contextual equivalence tends to iden-
tify too many programs and various co-inductive notions of bisimilarity are
used instead (see the textbook by Sangiorgi and David, 2001, for example).
But even if we remain within the realm of languages with deterministic oper-
ational semantics, one may ask to what extent the results of this chapter are
stable with respect to adding further features such as recursive datatypes,
mutable state, and object-oriented features à la Objective Caml.
Ciu-equivalence has the advantage of being quite robust in this respect—
it can provide a characterisation of contextual equivalence in the presence
of such features (Honsell, Mason, Smith, and Talcott, 1995; Talcott, 1998).
However, its usefulness is mainly limited to establishing basic laws such as
the conversions in Corollary 7.5.8; it cannot be used directly to establish ex-
tensionality properties such as those in Theorem 7.7.1 without resorting to
tedious “termination inductions” of the kind we sketched in the proof of Ex-
ample 7.7.4. Ciu-equivalence is quite closely related to some notions of “ap-
plicative bisimilarity” that have been applied to functional and object-based
languages (Gordon, 1995, 1998), in that their congruence properties can both
be established using a clever technique due to Howe (1996). The advantage of
applicative bisimilarity is that it has extensionality built into its deﬁnition; so
when it does coincide with contextual equivalence, this provides a method of
establishing some extensionality properties for =ctx (such as (1)–(4) in Theo-
rem 7.7.1, but not, as far as I know, property (5) for package values).
The kind of operationally based logical relation we developed in this chap-
ter provides a very powerful analysis of contextual equivalence. We used it

7.8
Notes
289
to prove not only conversions and simple extensionality principles for FML,
but also quite subtle properties of =ctx such as Theorems 7.7.1(5) and 7.7.8.
Similar logical relations can be used to prove some properties of ML-style
references and of linear types: see Pitts and Stark (1998), Bierman, Pitts, and
Russo (2000), and Pitts (2002). Unfortunately, the characteristic feature of
logical relations—that functions are related iﬀthey map related arguments
to related results—makes it diﬃcult to deﬁne them in the presence of “recur-
sive features.” I mean by the latter programming language features which in a
denotational semantics lead one to have to solve domain equations in which
the deﬁned domain occurs both positively (to the left of an even number
of function space constructions) and negatively (to the left of an odd num-
ber of function space constructions). Recursive datatypes involving function
types can lead to such domain equations; as does the use of references to
functions in ML. Suitable logical relations can be deﬁned in the denotational
semantics of languages with such features using techniques such as those in
Pitts (1996), but they tell us properties of denotational equality, which is of-
ten a poor (if safe) approximation to contextual equivalence. For this reason
people have tried to develop syntactical analogs of these denotational logi-
cal relations: see Birkedal and Harper (1999). The unwinding theorem (Theo-
rem 7.4.4) provides the basis for such an approach. However, it seems like a
fresh idea is needed to make further progress. Therefore I set a last exercise,
whose solution is not included.
7.8.1
Exercise [««««. . . , 3]: Extend FML with isorecursive types, µX.T, as in Figure
20-1 of TAPL, Chapter 20. By ﬁnding an operationally based logical relation as
in §7.6 or otherwise, try to prove the kind of properties of contextual equiv-
alence for this extended language that we developed for FML in this chapter.
(For the special case of iso-recursive types µX.T for which T contains no neg-
ative occurrences of X, albeit for a non-strict functional language, see Johann
(2002). The generalized ideal model of recursive polymorphic in Vouillon and
Melliès (2004) uses the same kind of Galois connection as we used in §7.6 and
may well shed light on this exercise. Recent work by Sumii and Pierce [2005]
is also relevant.)
2


P a r t I V
Types for Programming
in the Large


8
Design Considerations for ML-Style
Module Systems
Robert Harper and Benjamin C. Pierce
A programming language for large-scale software development must pro-
vide some means of breaking large programs into parts of manageable size,
commonly known as modules. The division into modules is chosen to re-
ﬂect natural divisions of labor within a program, minimizing redundancy and
maximizing opportunities for re-use (Parnas, 1972).
The literature on modularity is extensive, covering both methodology—
how best to decompose programs into modules with a variety of desirable
engineering characteristics—and mechanisms used to support modular pro-
gramming. In this chapter, we focus on the latter, laying out a set of core
requirements and design issues and developing linguistic mechanisms for ad-
dressing them. The heart of our story is the module system found in present-
day dialects of ML, but the discussion touches on modularity features from a
range of other languages such as C, Modula, and Java.
Our presentation emphasizes type systems for modularity grounded in the
framework of TAPL. To keep the discussion focused on basic concepts and
avoid type-theoretic technicalities, the presentation is informal. However, the
material will be easier to follow for readers with some familiarity with basic
concepts of subtyping (TAPL, Chapter 15), universal polymorphism (TAPL,
Chapter 23), existential polymorphism and abstract types (TAPL, Chapter 24),
and type operators (TAPL, Chapter 29). Some more advanced typing features
are also mentioned in passing, but prior acquaintance with these features
is not assumed; these include recursive types (TAPL, Chapters 20 and 21),
bounded quantiﬁcation (TAPL, Chapters 26 and 28), dependent types (Chap-
ter 2 of this volume) and singletons (Chapter 9).
The chapter begins in §8.1 to §8.3 with a suite of basic modularity mech-
anisms: modules and signatures, namespace management, separate compi-
lation, inter-module type checking, and principal signatures. §8.4 introduces

294
8
Design Considerations for ML-Style Module Systems
the central concept of the phase distinction and the terminology of ﬁrst- and
second-class module systems. §8.5 discusses abstract data types. Abstract
types arise by sealing a module with a signature that selectively suppresses
the deﬁnitions of its type components. Data abstraction raises a number of
important technical issues, including representation independence and the
avoidance problem. §8.6 extends the module language with nested hierar-
chies of modules. §8.7 discusses two alternative mechanisms for represent-
ing families of signatures—explicitly parameterized signatures and the less
familiar but more ﬂexible idea of ﬁbered signatures, which allow any submod-
ule in a signature to be considered a posteriori as the “index” of a signature
family. §8.8 extends this discussion to families of modules deﬁned by func-
tors and raises the issue of coherence. We compare two approaches to the
coherence problem—sharing by construction, which is based on parameter-
ized signatures, and sharing by speciﬁcation, based on ﬁbered signatures—
and explain why the latter scales well while the former does not. We then
discuss the pragmatic motivations for module families in more depth, ex-
ploring several classes of situations in which functors arise naturally. The
section closes with a discussion of generative and applicative functors. §8.9
brieﬂy describes three more advanced topics in module system design: ﬁrst-
class modules, in which modules can be treated as ordinary values; higher-
order modules, in which functors are treated on the same footing as other
modules; and recursive modules, which permit self-reference. §8.10 relates
the modularity concepts of this chapter to the mechanisms found in several
well-known languages. §8.11 closes the chapter with historical remarks and
additional suggestions for further reading.
8.1
Basic Modularity
Informally, a module (or structure) is a collection of components, which may
include procedure or function deﬁnitions, variable declarations, type deﬁni-
tions, and initialization code—speciﬁcs will vary from one language to an-
other. A program consists of a collection of bindings of module names to
modules. One module is speciﬁed as the root—the main entry point of the
program.
One module in a program may refer to another by using the latter’s name in
an external reference. The occurrences of external references between mod-
ules determine a dependency ordering in which the referring module depends
on the module to which it refers. (We assume for now that cyclic dependen-
cies between modules are not allowed; §8.9 discusses relaxing this restric-
tion.) The job of a linker is to compose a complete program by resolving

8.1
Basic Modularity
295
external references, creating module bindings for each of the external refer-
ences in the partial program under construction until no unresolved refer-
ences remain.
To support separate compilation, the dependency of one module on an-
other is mediated by a signature (or interface) that describes the externally
visible components of the latter module. A signature must be suﬃciently ex-
pressive as to enable clients of a module to be compiled without reference to
its implementation. This information typically includes type declarations for
procedures and variables and the deﬁnitions of type variables.
In practice, most languages support modularity through a mixture of lin-
guistic and extra-linguistic mechanisms. For example, modules are often or-
ganized as ﬁles, and module naming conventions are often tied to ﬁle system
naming conventions. To avoid such complications, we concentrate on a mod-
ule language that emphasizes the central concepts, relegating its realization
in speciﬁc languages and development environments to informal discussions
in §8.10.
Syntax
We employ a notation for modules and signatures that is loosely based on
ML. We consider the module language to be constructed in terms of some
underlying core language, whose details we do not care too much about. The
principal point of contact between the module and core language consists
of references to components of modules from within core language expres-
sions. To account for the type deﬁnitions in signatures, it is necessary to
enrich the deﬁnition of type equivalence to ensure that type components are
synonymous with their deﬁnitions.
The grammar given in Figure 8-1 deﬁnes the syntax of a basic module sys-
tem that we enrich as further ideas are developed. We use the metavariables
x and y to range over term variables, s, t, and u to range over terms, X and Y
to range over type variables, S, T, and U to range over types, m and n to range
over module variables, M and N to range over module expressions, and I and
J to range over signatures and signature variables.1
A program consists of a sequence of bindings, each of which is either a
module binding or an signature binding. A module binding binds a module
1. We are departing slightly from TAPL’s metavariable conventions here. In TAPL, lowercase
identiﬁers were used consistently for term-level expressions and variables, and uppercase
identiﬁers for type-level expressions and variables. Here, we are using M and N for module-
level expressions and m and n for module-level variables. Also, we use I and J to denote both
signatures and signature variables. No confusion results from this overlap, since in any case
we regard a signature variable as just an abbreviation for its deﬁnition.

296
8
Design Considerations for ML-Style Module Systems
P
::=
programs:
B1 . . . Bn
binding sequence
B
::=
bindings:
module m [: I] = M
module binding
signature J = I
signature binding
M
::=
modules:
m
module variable
mod { CB1, . . . , CBn }
basic module
I
::=
signatures:
J
signature variable
sig { CD1, . . . , CDn }
basic signature
CB
::=
component bindings:
type X [> X] = T
type binding
val x [> x] = t
value binding
CD
::=
component declarations:
type X [> X] = T
type declaration
val x [> x] : T
value declaration
T
::=
. . .
types:
m.X
type selection
t
::=
. . .
terms:
m.x
value selection
Γ
::=
typing contexts:
∅
empty
Γ, D
declaration
D
::=
declarations:
m : I
module declaration
Figure 8-1: Basic module syntax
variable to a module expression, perhaps with a speciﬁed signature. A signa-
ture binding binds a signature variable to a signature. The scope of a binding
in a program is the remainder of the program following that binding. The
ﬁnal module binding is the root module.
Signature bindings are used to give names to signatures: a bound signature
variable is simply an abbreviation for the right-hand side of its binding.
A basic module consists of a sequence of component bindings, which are
either type bindings or value bindings. A type binding is a binding of a type
variable to a type expression. A value binding binds a run-time entity to a
term variable. These entities may include procedures, classes, objects, muta-
ble reference cells, and other structures from the core language.
Each component binding has both a label, which is underlined, and a vari-
able, which is not. The variable governs references to that binding within the
module; the label governs reference from outside of the module. For this rea-
son the label is sometimes called the external name of the component, and
the variable its internal name. The use of a label from outside of a module to
designate one of its components is called an external reference; the use of a
variable from inside the module to designate a preceding binding is called an
internal reference. If m is a module variable, then m.X is an external reference
to the type component of m labeled X, and m.X is an external reference to the
value component of m labeled x.

8.1
Basic Modularity
297
Internal names are bound variables whose scope is the rest of the module
in which they occur. As such, internal names may be chosen (and renamed)
arbitrarily without aﬀecting the meaning of the module, subject only to the
usual requirement that distinct bound variables not be confused in a given
scope. In contrast the external name of a component of a module cannot be
renamed without aﬀecting the entire program in which that module occurs.
This distinction between external and internal names is necessary for both
conceptual and technical reasons (detailed in §8.6). In most cases, however,
it is not important to emphasize the distinction, so we take the liberty of pro-
viding a single name for each component binding with the understanding that
it plays a dual role as both the external and internal name of that component.
A basic signature consists of a sequence of component declarations, either
a type declaration or a value declaration. A type declaration is a labeled type
binding, with the same syntactic form as a type binding in a module. A value
declaration deﬁnes the type of a term variable, but does not give its actual
binding. As with bindings, we usually assign a single name to each declaration
with the understanding that it serves as both the internal and external name
of that component.
Examples
Here is a simple module binding:
module m = mod {
type X = Nat
val x = 5
}
The module bound to m includes one type binding and one value binding.
These components are designated, externally, by m.X and m.x. Note that these
are, respectively, core-language type and value expressions: the grammar of
the core language is enriched to include external references to components
of modules.
Here is a more interesting module binding:
module n = mod {
type X = λW:*. W × W
val f = λy:X(Nat). plus y.1 y.2
}
The right-hand side of the type binding X has kind *→* (i.e., this module is
exporting a type operator). The right-hand side of the term binding f uses
the previously bound operator X. This illustrates the impact of the module
language on core-language type checking: in order to check that the core-

298
8
Design Considerations for ML-Style Module Systems
language expression λy:X(Nat). plus y.1 y.2 is well typed, we need to use
the module-level information that X is deﬁnitionally equal to λW:*. W × W.
The signature I introduced by the binding
signature I = sig {
type X = Nat
val x : X
}
describes the module m above, in a sense to be made precise shortly. Similarly,
signature J = sig {
type X = λW:*. W × W
val f : X(Nat) →Nat
}
binds J to a signature corresponding to the module n.
8.2
Type Checking and Evaluation of Modules
To avoid getting bogged down in formalities, we describe type checking and
evaluation throughout the chapter in English prose rather than giving precise,
formal deﬁnitions. §8.11 oﬀers a number of pointers into the literature for
readers interested in a more technical treatment.
Type Checking
Signatures are used to describe modules. If a signature I accurately describes
a module M, then we say that M implements I. This relation may be deﬁned in
one of two ways. The direct method simply deﬁnes a correspondence between
a module and any signature that it may implement. An indirect method is to
associate with each module M a unique (up to suitable equivalences) principal
signature|seesignatures, which is the “most precise” (least in the subtyping
ordering) signature implemented by M. The latter method, though elegant,
applies only in languages where every module actually has a principal sig-
nature. We start by deﬁning the implementation relation directly and later
discuss conditions under which it may be reduced to subtyping.
We say that a basic module M implements a basic signature I if M contains
at least the type and value components speciﬁed by I, up to type equiva-
lence. That is, each type component declared in I must be bound in M with
the same kind and an equivalent deﬁnition. (A type deﬁnition in a signature is
an equational constraint that must be satisﬁed by any implementation of that
signature.) Moreover, each value component declared in I must be matched
by a value binding in M with a subtype of the type speciﬁed in I. The subtyp-
ing relation here is inherited from the core language, enriched to include the

8.2
Type Checking and Evaluation of Modules
299
expansion of deﬁnitions introduced by type bindings in modules and signa-
tures.
When a module binding speciﬁes a signature, the type checker ensures
that its right-hand side implements this signature. For example, the following
bindings are well-formed because the module bound to m implements the
signature I:
signature I = sig {
type T = Int
type U = Int × Int
val x : U
}
module m : I = mod {
type T = Int
type U = T × T
val x : T × T = (3,4)
}
Since I provides deﬁnitions for the types T and U and declares the value x,
it follows that m.T and m.U are valid type expressions (equal, respectively, to
Int and Int × Int), and m.x is a valid value expression (of type m.T × m.T,
which is equivalent to m.U).
To account for external references during type checking, each module vari-
able is assigned a signature by a typing context. The assignment of a signature
to a module variable amounts to the assumption that it will be bound to a
module implementing that signature. This is enforced during linking, which
is described in more detail in §8.3.
Signature Matching
Since signatures are descriptions of modules, it is natural to consider a sub-
typing relation between signatures, called signature matching and written
I<:J. A signature I may be considered to be a sub-signature of a signature
J only if any module implementing I also implements J (this is the ordinary
subsumption principle from type systems with subtyping). Said diﬀerently,
if I is a sub-signature of J, then I expresses stronger requirements on an
implementation than does J. When I<:J we say that I matches J.
There is some room for variation in how the signature matching relation is
deﬁned, subject only to the requirement that it validate subsumption. There
are two well-known styles of signature matching, which we call structural and
nominal. Structural matching is based entirely on the requirements imposed
by the signature, without requiring any declarations. Nominal matching is
based on the explicit declaration of subtyping relationships among signa-

300
8
Design Considerations for ML-Style Module Systems
tures. Such declarations are often tied to a naming mechanism for modules
and signatures, which gives rise to the terminology. (This distinction exactly
mirrors the distinction between structural and nominal subtype relations dis-
cussed in TAPL, §19.3.)
Structural matching aﬀords greater ﬂexibility, since it does not require the
programmer to explicitly specify that one signature subsumes another. How-
ever, structural matching does not preclude unintended matching relation-
ships; this is at once a strength and a weakness. Nominal matching sacriﬁces
ﬂexibility for simplicity by requiring explicit declaration of matching relation-
ships among signatures. Nominal matching precludes unintended matching
relationships, but requires that any intended ones be explicitly stated. This
rigidity can sometimes lead to signiﬁcant problems in practice. For example,
in Java, it is impossible to create a new interface J that lies above an existing
class or interface I without modifying the source code of I, which may be
unavailable, for example, if I is part of a commercial library.
The deﬁnition of structural matching is guided by purely semantic consid-
erations: it is the largest pre-order on signatures that validates the subsump-
tion principle. That is, I<:J iﬀevery module implementing I also implements
J. This is ensured by the following requirements:
1. Every type declaration in J must be matched by a corresponding type dec-
laration in I. Moreover, their deﬁnitions must be equivalent, taking into
account the preceding type declarations in I.
2. Every value declaration in J must be matched by a corresponding value
declaration in I. Moreover, the type declared in I must be a subtype of
that declared in J, taking account of the preceding type bindings in I.
These conditions do not impose any ordering requirements on components
and permit the sub-signature to have components not present in the super-
signature. (In the terminology of record subtyping from TAPL, Chapter 15,
the subtype relation between signatures permits width subtyping, depth sub-
typing, and permutation, with one caveat: in contrast to record subtyping,
permutation must be limited to respect the scoping of internal names for
components. For example, a value speciﬁcation cannot be permuted to pre-
cede a type speciﬁcation on which it depends.) For example, according to this
deﬁnition the signature
signature I = sig {
type T = Int
type U = T × T
type V = Int
}
matches the signature

8.2
Type Checking and Evaluation of Modules
301
signature J = sig {
type T = Int
type U = Int × T
}.
8.2.1
Exercise [««««]: How much of the development in the rest of the chapter
can be carried out in a nominal setting?
2
Principal Signatures
The principal signature of a module, when it exists, is the most precise signa-
ture that the module implements. If a module M has a principal signature IM,
then M implements another signature I exactly when IM matches I. Checking
whether a module implements a signature is thus reduced to checking the
subtyping relation between this signature and the module’s principal signa-
ture. Naturally, this reduction is possible only if every module expression has
a principal signature; otherwise there is some module expression M and a sig-
nature I such that M implements I, yet there is no way to express this fact as
a subtyping relationship.
Unfortunately few module languages have principal signatures for all mod-
ule expressions. One reason is that the language of signatures may be too
weak to permit a precise description of the properties of a module. For exam-
ple, if subtyping for signatures is nominal, then the inferred signature for a
module is not, in general, its smallest signature in the declared subtyping hi-
erarchy. A work-around for weak signatures is to draw a distinction between
a signature expression and its internal representation in a type checker. Every
well-formed signature has an internal representation, but some modules may
have an internal representation that is not denotable by a signature of the
language itself. This creates an unnatural separation between what a partic-
ular type checking algorithm knows about a module and what a programmer
may state about it in a signature. An alternative solution is to require that
the programmer specify a signature for every module, which is then deemed
to be the smallest signature for that module, even if it is larger (i.e., weaker)
than necessary. This avoids the need for principal signatures, at the expense
of some verbosity as well as some loss of ﬂexibility when the speciﬁed signa-
ture precludes uses of the module that would otherwise be permissible.
Evaluation
Complete programs (those with no free variables) are executed by evaluating
each of the module bindings in the order given. A basic module is evaluated
by evaluating each of its component bindings in turn according to the rules of

302
8
Design Considerations for ML-Style Module Systems
the core language, resulting in a module value. We insist on a “call by value”
binding discipline for module variables: a module variable is bound to the
value of its binding. The motivation for this requirement is explained in §8.5.
The notion of an initializer for a module arises here as a value binding
whose right-hand side has a side-eﬀect (initializing the module’s internal
state) when evaluated. For example, evaluating the right-hand side of the
binding of f in
module p = mod {
val f =
let r = ref 0 in
λx:Nat. r := plus x (!r)
}
allocates a storage cell and then returns a function whose body uses this
cell. This example also illustrates the need to distinguish between module
expressions and module values. Each time the expression mod { val f = ... }
is evaluated, a new cell is allocated and a diﬀerent module value results.
8.3
Compilation and Linking
The process of evaluating a program may be decomposed into two steps:
compilation and execution. For present purposes, the most important aspect
of compilation is type checking, and the most important aspect of execution
is linking. We shall not concern ourselves with code generation or the execu-
tion of compiled code. A key distinction between compilation and execution
is that the former may be performed on a module-by-module basis, provided
only that we are given the signatures of the free module variables occur-
ring in a module, whereas the latter is performed on a complete program in
which we have at hand the bindings of all of its free module variables. We
follow Cardelli (1997) in modelling linking as a process of binding modules
to module variables.
Compilation
To support code re-use and team development, it is important to compile
modules independently from one another. To compile a module, it is neces-
sary to have an assignment of a signature to each of its free module variables
(external references) provided by the typing context. There are two main
methods of obtaining this context: separate and incremental compilation.2
2. We caution the reader that this terminology is not standard; these and related phrases are
used with a variety of loosely related meanings in the literature.

8.3
Compilation and Linking
303
The diﬀerence is whether the signatures of free module variables are explic-
itly given by the programmer (separate compilation) or are inferred by the
compiler from the source code of the referenced module (incremental compi-
lation). Both separate and incremental compilation may be supported in the
same language. Furthermore, both mechanisms are compatible with cut-oﬀ
compilation (Adams, Tichy, and Weinert, 1994): if the source code of a mod-
ule has changed, but its signature has not, then there is no need to recompile
modules that depend on it—recompilation may be “cut oﬀ” at that point.
In a separate compilation system, the programmer states signature as-
sumptions for each of the external references in a module. This is typically
achieved by “import” declarations that state such assumptions. The module
is compiled relative to these assumptions, independently of whether the im-
plementation of the externally referenced modules is available. This aﬀords
maximal ﬂexibility in the order of development of the modules in a program
and permits re-use of libraries of previously compiled modules whose source
may not be available at all. Separate compilation places a burden on the
linker to ensure that the binding of a module variable implements the pre-
sumed signature. A subtle point is that two diﬀerent modules may import
the same module, but with a diﬀerent assumed signature. The linker must
ensure that each such assumption is satisﬁed to ensure safety, or else insist
that all imports specify equivalent signatures. Since most conventional link-
ers are incapable of verifying typing constraints, it is usually necessary to
devise language-speciﬁc linkers or to introduce post-linking checks (similar
to Java bytecode veriﬁcation) to ensure type safety.
In an incremental compilation system, it is not necessary to specify the
signatures of externally referenced modules. Instead, the compiler consults
the implementation of a module to determine its signature, which is used for
compiling any module that depends on it. This implies that the implementa-
tion of any externally referenced module must be present in order to compile
the referring module. This impedes independent development, but avoids the
need to ensure that the binding of a module implements the presumed sig-
nature, since it does so by explicit construction. A module system that lacks
principal signatures cannot properly support incremental compilation.
Linking
A linker assembles a complete program from a collection of module bind-
ings, called the linking context.3
This is achieved by tracing the external
3. We are talking here about conventional static linking. Languages that support dynamic link-
ing permit name resolution during execution.

304
8
Design Considerations for ML-Style Module Systems
references occurring in the collection of program fragments (starting with
a speciﬁed root module), and building a sequence of module bindings that
is consistent with the occurrences of these references. Whenever an external
reference is encountered, its binding is determined by consulting the link-
ing context, and emitted as part of the resulting fully linked program. The
external reference is thereby said to be resolved. The occurrence of external
references constrains the order of the bindings in the fully linked program,
but it does not completely determine it. Further constraints on the order of
bindings are imposed by initialization code whose side eﬀects constitute an
implicit dependency of one module on another.
This motivates the deﬁnition of a dependency relation among a set of mod-
ules, consisting of its reference dependencies together with its initialization
dependencies. Reference dependencies are determined by inspection of the
code of a module. If a module N contains an external reference m to a module
M, then N is said to contain a reference dependency on M. Signatures may also
contain reference dependencies on modules, for if a signature I contains a
reference m to a module M, then I depends on M and hence m must be bound
before I can be used. (At this point such dependencies are inessential, be-
cause they can only arise in type selections of the form m.X, which may be
replaced by their deﬁnitions. However, once abstract types are introduced in
§8.5, such references are not in general eliminable in this way.) Initialization
dependencies arise when the evaluation of one module is materially aﬀected
by the evaluation of another, even though no reference dependency need ex-
ist between them. Initialization dependencies cannot always be determined
by inspection; for example, one module may read a ﬁle that another writes
without either sharing a common reference. Therefore, initialization depen-
dencies must be explicitly speciﬁed (by some means not detailed here) to
ensure that they are respected by the linker.
Ordinarily, the dependency relation among a collection of modules is re-
quired to be acyclic, precluding circular dependencies of a module on itself
(whether via intermediate modules or not). This is enough to ensure that it
is always possible to ﬁnd a linear ordering of modules consistent with the
dependency relation. It is possible to permit circular dependencies, at the
expense of considerable complications in the general case; see §8.9.
It is worth noticing that, in the simple setting we are describing at the mo-
ment, all the external references to a given module m, everywhere in a given
set of modules, are guaranteed to be resolved to the same module value at
link time—that is, external references are deﬁnite. These deﬁnite references
are to be contrasted with the indeﬁnite references that arise with parameter-
ized modules and signatures (see §8.8). Indeﬁnite references raise diﬃculties
related to aliasing, called coherence problems.

8.4
Phase Distinction
305
8.4
Phase Distinction
Most modern programming languages are statically typed, meaning that type
checking may be performed prior to, and independently of, execution. Stat-
ically typed languages maintain a clear separation between the static (type
checking) and dynamic (execution) phases of processing, and are therefore
said to respect the phase distinction.4 This can be made precise by consider-
ing the forms of reasoning required during type checking to test type equiva-
lence. If type checking may be performed without testing equivalence of run-
time expressions, then the phase distinction is respected, and the language is
said to be statically typed. If, however, type checking requires testing equiva-
lence of run-time expressions (sometimes called “symbolic execution”), then
the phase distinction is violated, and the language is said to be dependently
typed.5 Examples of dependently typed programming languages include Rus-
sell (Donahue and Demers, 1985), Pebble (Burstall and Lampson, 1984), and
Cayenne (Augustsson, 1998). See Chapter 2 for further information on depen-
dently typed languages.
Since modules contain bindings for types, testing type equivalence involves
reasoning about the identity of the type components of modules. But since
modules also contain bindings for values, we are at risk of violating the phase
distinction. For example, a type expression of the form m.X appears super-
ﬁcially to be dependent on the entire module m, including its dynamic com-
ponents. Consequently, checking equality of m.X with another type threat-
ens to require comparison of modules for equality, in violation of the phase
distinction. We take it as a fundamental design principle that a module sys-
tem should preserve the phase distinction in the sense that a module system
should be statically typed if the underlying core language is. The type theory
of modularity developed in this chapter is carefully designed to ensure that
the phase distinction is preserved.
The phase distinction is related to the distinction between ﬁrst- and second-
class modules. Informally, a ﬁrst-class module expression is one whose type
4. This terminology was introduced by Cardelli (1988a) in an attempt to relate phases to a
universe distinction in type theory. The present formulation is derived from Harper, Mitchell,
and Moggi’s deﬁnition (1990).
5. The natural contrasting phrase is “dynamically typed,” but this conﬂicts with the term’s
established usage to refer to languages (such as Java or Scheme) with run-time dispatch on
tagged data. Our use of the phase “dependently typed” stresses the core semantic issue, rather
than focusing on purely syntactic features such as the occurrence of terms in types. The mod-
ule language of this chapter will exhibit superﬁcial syntactic dependencies that do not, in fact,
amount to semantic dependencies in the sense used here. Technically this is achieved by re-
stricting type selection to separable modules—those with a fully transparent interface; see
Dreyer, Crary, and Harper (2003) for further details.

306
8
Design Considerations for ML-Style Module Systems
components are not determined until run-time; otherwise it is second-class.
The essential diﬀerence between a ﬁrst- and a second-class module expres-
sion is whether or not its type components are determined statically (during
type checking) or dynamically (during execution). A rough-and-ready criterion
for a module expression to be ﬁrst-class is that the bindings of its type com-
ponents depend on the outcome of a run-time test. If so, then the identity of
its type components cannot be determined statically, rendering the module
ﬁrst-class; if not, it is second-class. (Consequently, a module expression with
no type components is vacuously second-class, even though its evaluation
may involve arbitrary run-time computation.)
All basic module expressions, including module values, are second-class
because they explicitly specify their type components. For example, the fol-
lowing module expression is second-class:
mod {
type X = Nat
val f = λx:X. x
type Y = Bool
}
On the other hand, consider the following module expression, M
if ...moon is full... then m1 else m2
where m1 and m2 are bound by the following declarations:
module m1 = mod {
type X = Int
type Y = X→X
val x = 3
val f = succ
}
module m2 = mod {
type X = Bool
type Y = X→X
val x = false
val f = not
}
The expression M is chosen so that the deﬁnitions of its type components X
and Y are dependent on a run-time test whose outcome cannot be predicted
at typechecking time. Consequently, it is ﬁrst-class.
If, instead, m2 were deﬁned as follows, then the bindings of X and Y would
not be dependent on a run-time condition:

8.5
Abstract Type Components
307
module m2 = mod {
type X = Bool
type Y = Bool→Bool
val x = true
val f = not
}
In this case M is second-class, despite its syntactic form. The distinction be-
tween ﬁrst- and second-class module is a matter of evaluation behavior.
Up to this point, the type system for modules we have developed so far is
too weak to permit any ﬁrst-class module expressions to be well-typed. For
example, the conditional M given above does not implement any signature
in the language of signatures developed thus far, for the simple reason that
signatures must reveal the deﬁnitions of their type components. To assign a
signature to M it is necessary to suppress the identity of its type component,
X. To do so, we require a richer language of signatures.
8.5
Abstract Type Components
So far in our development signatures are transparent—a signature I for a
module M must reveal the deﬁnitions of the type components of M. As we
have just mentioned, a ﬁrst-class module expression cannot implement a
transparent signature. Worse, limiting ourselves to transparent signatures im-
pedes modular programming by creating tight dependencies of one module
on another. A transparent signature for a module M must expose the repre-
sentations of its type components, and modules that makes use of M may be
sensitive to that choice. Consequently, any change to M has a knock-on eﬀect
on all modules that make use of it. In many cases such a close coupling is
unnecessary, and therefore undesirable.
The solution to both of these shortcomings is to permit not only concrete
(or transparent) type declarations in signatures, as we have until now, but
also abstract (or opaque) type declaration revealing the existence, but not the
deﬁnition, of a type component. An abstract type declaration is said to “hold
its type abstract,” or to “hide its representation.” Signatures in which type
declarations may be either concrete and abstract are said to be translucent,
because they partially reveal their type components. Transparent signatures,
which reveal all of their type components, and opaque signatures, which hold
all of their type components abstract, are two important limiting cases.
Signatures with abstract type declarations are similar to existential types
(see Mitchell and Plotkin (1988) and TAPL, Chapter 24). Just as with existen-
tial types, translucent signatures permit changing the type deﬁnitions within

308
8
Design Considerations for ML-Style Module Systems
CD
::=
component declarations:
type X [> X]
opaque type
type X [> X] = T
transparent type
Figure 8-2: Translucent signature syntax
a module without fear of disrupting the type correctness of any module that
makes use of it. In short, translucency supports representation independence
in much the same manner as do existential types. However, the relationship
to existentials is more analogical than technically accurate. In particular, ex-
istentials do not support dot notation for existential types (i.e., given an exis-
tential package p with an abstract type component X, one cannot just refer
to p.X; instead, p must ﬁrst be “opened” in some particular lexical scope),
and so do not oﬀer a fully satisfactory foundation for module systems. In
particular, dot notation is required to give adequately expressive types for
hierarchical and parameterized modules, as explained in §8.6 and §8.8. This
point is discussed in detail by Cardelli and Leroy (1990) and Lillibridge (1997).
The passage to translucent signatures has surprisingly far-reaching con-
sequences. Most immediately, translucent signatures support a ﬂexible form
of data abstraction and permit formation of ﬁrst-class module expressions.
Translucent types are crucial for permitting ﬁne-grained control over the
propagation of type deﬁnitions in hierarchical and parameterized modules
while maintaining static typing. Less obviously, they make possible a number
of signiﬁcant enrichments of the module language with a minimum of addi-
tional machinery. In particular, translucent signatures provide type-indexed
families of signatures “for free” and support a direct and natural way of en-
suring type compatibility among the arguments of a parameterized module.
(See §8.7, §8.6 and §8.8 for further discussion of these points.) It is remark-
able that a single mechanism, translucent signatures, not only aﬀords ﬂex-
ible type abstraction, but also provides all of the supporting apparatus re-
quired for several important extensions to the basic formalism. As might be
expected, this increase in expressiveness goes hand-in-hand with some signif-
icant meta-theoretic challenges. Thus, in terms of both power and cost, the
extension to translucent signatures is the most signiﬁcant step in the chapter.
Translucent Signatures
To support translucency we extend the syntax of our language to permit two
forms of type declaration—one that reveals the deﬁnition, and one that sup-

8.5
Abstract Type Components
309
presses it, as detailed in Figure 8-2. For example, the signature
signature I = sig {
type X
type Y = X→Nat
val c : X
val f : Y
}
speciﬁes the existence of type components named X and Y, revealing the def-
inition of Y, but hiding the deﬁnition of X.
The signature matching relation is generalized to permit “forgetting” of
type deﬁnitions: an abstract type declaration type X in a super-signature may
be matched by either an abstract or a concrete type declaration in the sub-
signature. For example, the signature
signature J = sig {
type X = Nat
type Y = X→Nat
val c : X
val f : Y
}
matches the signature I.
As we noted on page 300, the deﬁnitions of type components of a signa-
ture are propagated forward when checking whether one signature matches
another. So, for example, the signature
signature K = sig {
type X = Nat
type Y = X→Nat
val c : Nat
val f : Nat→X
}
matches the signature J, and so, perhaps surprisingly, it also matches the
signature I.
8.5.1
Exercise [«, 3]: Check in detail that K matches J and I.
2
A module implements a translucent signature if it provides the type com-
ponents speciﬁed in the signature with, where given, bindings equivalent to
the speciﬁed deﬁnitions. During type checking, the deﬁnitions of type com-
ponents of a module are again propagated forward while checking the re-
mainder of the components against the speciﬁed signature. For example, the
module M declared by the binding

310
8
Design Considerations for ML-Style Module Systems
module m =
mod {
type X = Nat
type Y = X→Nat
val c = 5
val f = λx:X. succ x
}
implements the translucent signature I given above.
8.5.2
Exercise [«, 3]: Check in detail that M implements I.
2
Sealing
To limit the visibility of the type components of a module M to the degree
speciﬁed in the signature I, it is necessary to seal M with I, written M:>I. (Note
the similarity to the term-level ascription operator described in TAPL, Chapter
11.) A sealed module expression M:>I is well-formed only if M implements I;
the sealed module is considered to implement I (and, by subsumption, the
supertypes of I). A sealed module is evaluated by stripping oﬀthe seal and
evaluating the underlying module. This reﬂects the informal idea that data
abstraction is relevant only during type checking and has no signiﬁcance at
run time.
For example, consider the signature, I, given in the preceding subsection,
and the following module expression, M:
mod {
type X = Nat
type Y = X→Nat
val c = 5
val f = λx:X. succ x
}
It is easy to check that M implements I, so that M:>I is a well-formed module
expression with signature I. Since X is held abstract by I, no use of the sealed
module may rely on its identity.
A “decorated” module binding of the form module m : I = M may be seen as
syntactic sugar for the “bare” binding module m = (M:>I)—that is, the mod-
ule M is implicitly sealed with signature I by the binding. For example, if M
and I are as in the preceding example, then the module binding
module m = M:>I
assigns to m the signature I. Since I holds X abstract, m.X is opaque, whereas
m.Y is equivalent to m.X→Int.

8.5
Abstract Type Components
311
M, N ::= . . .
modules:
M ! I
sealing
T, U ::= . . .
type:
M .X
type selection
t, u ::= . . .
term:
M .x
value selection
Figure 8-3: Mechanisms for abstraction
The formalization of abstract types considered here diﬀers from conven-
tional existential types (as described in TAPL, Chapter 24) by separating the
imposition of abstraction on a module from any means of binding that mod-
ule or its components to variables. In the existential framework abstraction
is imposed through a binding construct that holds the representation type
of the abstract type abstract within a speciﬁed scope, which is a single core
language expression. For this reason existential types are sometimes said to
impose a closed scope abstraction discipline. However, in the presence of
translucent sums, it is also necessary to make direct reference to abstract
types within types, as well as terms. Achieving this using existential types re-
quires that the abstract type binding be “extruded” to encompass essentially
the region of a program in which it is used. In practice this means that the
lowest-level, and most widely used, abstract types must be given the largest
scope, thereby everting the natural structure of the program. In contrast the
present framework is based on an open scope mechanism in which abstrac-
tion is imposed without specifying the scope in which it may be used. This
avoids the complex re-structuring required in the pure existential framework,
and, moreover, scales naturally to support later extensions to the language.
To support open-scope abstraction we extend the grammar of module expres-
sions to permit sealing, remove signatures from module bindings, and permit
type and value selection from an arbitrary module expression. (See Figure 8-3
for the revised grammar.)
One consequence of sealing modules with abstract type components is that
signatures may now contain unavoidable dependencies on modules. For ex-
ample, consider the following bindings:
signature I = sig {
type X
val c : X
val f : X→X
}

312
8
Design Considerations for ML-Style Module Systems
module m : I = mod {
type X = Int
val c = 0
val f = succ
}
signature J = sig {
type Y
val d : m.X
}
module n : J = mod {
type Y = m.X
val d = m.f(m.f(m.c))
}.
Since J contains a reference to m.X, which is opaque, the signature J is only
sensible within the scope of the binding for m. The meaning of the signature
J is tied to the binding of the module variable m. In particular, any module
implementing J must deﬁne Y to be equivalent to m.X.
Determinacy and Abstraction
Any adequate abstraction mechanism must ensure representation indepen-
dence, which ensures that the behavior of clients are insulated from the de-
tails of the implementation of an abstraction. We will not attempt to give a
precise deﬁnition of independence here (but see work by Reynolds (1974) and
Mitchell (1986)). At a minimum, though, it should ensure that if the modules M
and N implement the interface I, then replacing M:>I by N:>I should not dis-
turb the type correctness of a program. In particular, if the type X is abstract
in I, then the deﬁnition of X must not “leak” from M:>I so as to aﬀect the
type correctness of client code. For if it did, then we could choose N to con-
ﬂict with M on the deﬁnition of X and violate even this minimum requirement
for abstraction.
This suggests that representation independence is closely tied up with type
equivalence—when is one abstract type equivalent to another? In particular,
when is (M:>I).X equivalent to (N:>I).X? To ensure that type equality is
reﬂexive (as surely it ought to be), we must ensure that this equivalence hold
whenever M and N are equivalent. But module equivalence is, in general, unde-
cidable and, moreover, conﬂicts with the phase distinction, both undesirable.
To avoid this, we simply prohibit type selection from sealed modules so that
embarrassing questions such as these never arise.
Another strong reason to limit type selection is to ensure type safety in
the presence of ﬁrst-class modules. Since type expressions may be compared

8.5
Abstract Type Components
313
for equality with other types during type checking, it is important to ensure
that every type expression stand for a ﬁxed type at compile time. Surprisingly,
ﬁrst-class modules violate this seemingly innocent requirement. For example,
if M is the conditional module expression
if ... moon-is-full ...
then mod { type X = Int }
else mod { type X = Bool }
then M.X might turn out to be either Int or Bool, but we cannot tell which at
compile time. Consequently, it makes no sense to compare M.X for equality
with another type. The following exercise shows that permitting such type
expressions is, in fact, unsound.
8.5.3
Exercise [«««]: Devise an expression t involving unrestricted selection from
the ﬁrst-class module expression M that incurs a type error at run time.
2
Now a ﬁrst-class module expression such as this can only be well-formed
if we seal it with an interface that hides the identity of the type compo-
nent X. This establishes a close connection between ﬁrst-class modules and
sealing that provides further support for the prohibition of type selection
from sealed modules. More generally, since a sealed module may, in fact, be
ﬁrst-class, its abstract type components may or may not be statically well-
determined. Consequently, we must “assume the worst” of it, and prohibit
type selection.
At the present stage of development, only sealing poses any problems for
type selection, but, as we enrich the language, further constructs (such as ap-
plication of a generative functor) raise similar concerns. It is therefore useful
to isolate a subset of module expressions, the determinate ones, whose type
components are statically known and can be selected without fear of violating
safety or representation independence. The remaining module expressions
are said to be indeterminate; they do not permit type selection.
Basic module expressions, including module values, are determinate be-
cause they provide explicit deﬁnitions for their type components. For exam-
ple, the module expression (call it M)
mod {
type X = Bool
type Y = X→X
val x = false
val f = not
}
is determinate because we can see immediately that M.X is equivalent to Bool
and M.Y is equivalent to Bool→Bool.

314
8
Design Considerations for ML-Style Module Systems
By forcing evaluation of its right-hand side, a module binding resolves any
indeterminacy before the module variable is bound to the resulting value.
Consequently, module variables are also determinate. For example, consider
the following module binding:
module m = if ... moon-is-full ...
then mod { type X = Int }
else mod { type X = Bool }
Even though the conditional is indeterminate, the variable m is determinate. In
fact, the only way (so far) to make use of an indeterminate module expression
is to bind it to a variable and refer to that variable to access its components.
This sheds light on the informal idea that abstract types are “new” in the
sense of being distinct from all other types in a program, regardless of any
coincidences of representation. By α-conversion the name of a bound variable
is automatically changed so as to avoid clashes with any other module vari-
able in scope at that point in the program, thereby ensuring that its abstract
type components are “new.”
8.5.4
Exercise [«]: What would go wrong if we changed the evaluation of module
bindings to call-by-name?
2
For the time being, module values and variables are the only determinate
module expressions. Sealed modules are indeterminate, for the reasons out-
lined above.
8.5.5
Exercise [«]: Show that if sealed modules were determinate, then represen-
tation independence could be violated. That is, ﬁnd a well-typed term t whose
type correctness is destroyed by replacing one implementation of an abstract
type with another.
2
8.5.6
Exercise [«]: Why would it be bad for two copies of M:>I to induce inter-
changeable abstract type components?
2
This same observation also accounts for the informal idea that data ab-
straction ties a type to a particular set of operations that interpret it: any
non-trivial computation with a value of that type must be through these op-
erations. This greatly facilitates maintaining a representation invariant on the
data structure, since those, and only those, operations may potentially violate
it. Moreover, by insisting that sealed modules are indeterminate, we ensure
that the operations from two diﬀerent abstract types are not interchangeable,
even if the underlying representations of values of those types are the same.

8.5
Abstract Type Components
315
8.5.7
Exercise [Recommended, ««]: Devise an example of two implementations
of an abstract signature that share a common representation type but diﬀer
in the operations used to interpret it. Assuming that these two implementa-
tions give rise to the same (but hidden) abstract type, give a program (using
sealing as a determinate construct) that incurs an error that would otherwise
be avoided.
2
An important special case of this arises when the implementation of an
abstraction involves private state. In that case two instances of the abstract
type must be kept distinct, even though both the representation type and
the code of the associated operations are identical! The following exercise
explores one example of what can go wrong.
8.5.8
Exercise [Recommended, ««]: Devise an implementation of a hash table in-
volving state, and show that, if two instances of the hash table were to deter-
mine equivalent abstract types, then errors could arise that would otherwise
be avoided.
2
The Avoidance Problem
Consider a local module binding construct of the form
let module m = M in M’.
This expression implements the signature I′ provided that (1) M implements
some signature I, and (2) M′ implements some signature I′ under the assump-
tion that m implements I.
At ﬁrst glance, it would seem reasonable to say that the principal signature
for a let expression would simply be the principal signature (I′) of its body.
But what if the principal signature of the body involves an abstract type com-
ponent from M? For example, consider the following the module expression:
let
module m = M :> I
in
mod { val z = m.y }
where I is the signature
sig {
type X
val y : X
}.

316
8
Design Considerations for ML-Style Module Systems
Clearly, the principal signature of the body of the let is sig { val z : m.X }.
But this signature cannot be the type of N, because it involves an essential
reference to the locally bound module variable m. (An analogous observation
for the unpack form for existential types motivates the scoping restrictions
discussed in TAPL, §28.7.)
It is tempting to consider N to be ill-formed, since it attempts to export
the type m.X outside of its scope. But this neglects the possibility that N has
some signature that does not involve m.X. For example, if the core language
subtype relation has a maximal type Top, then another possible signature for
the body of the let is sig { val z : Top }. Indeed, this may even be the prin-
cipal signature for N. In general, the principal signature of a let expression
of the form let module m = M in M′ is the least signature for M′ that does not
involve the bound module variable m.
The problem of ﬁnding such a signature is called the avoidance problem.
First reported by Ghelli and Pierce (1992) in the context of System F≤, the
avoidance problem is a central design issue for module systems that support
data abstraction. Unfortunately, it does not appear to admit a completely sat-
isfactory solution. In some languages (including ML), there exists a signature
I involving a module variable m with more than one minimal super-signature
avoiding m, none of which is least. In such cases the occurrence of m cannot
be avoided without losing valuable type information.
8.5.9
Exercise [«««]: Consider a signature I
sig {
type X = λW:*. m.Z
type Y = m.Z
}
containing a free module variable m whose signature has an abstract type
component Z. Show that I has inﬁnitely many super-signatures that avoid m,
but none that is a sub-signature of all the others Assume, for this exercise,
that the core language is just F ω, with no subtyping between core-language
types. (For substantial extra credit, ﬁnd a similar example where the core
language is full F≤.)
2
What to do? A fallback position is to admit as well formed those let ex-
pressions for which there is a principal signature avoiding the bound mod-
ule variable, and to reject all others. The trouble is that there is no simple
characterization of which modules admit principal signatures and which do
not. Reliance on a particular algorithm for detecting cases for which a prin-
cipal signature exists ruins the declarative nature of the type system. An al-

8.6
Module Hierarchies
317
CB
::=
. . .
component bindings:
module m [> m] = M
module binding
CD
::=
. . .
component declarations:
module m [> m] : I
module declaration
M
::=
. . .
modules:
M.m
module selection
Figure 8-4: Mechanisms for hierarchy
ternative is to require the programmer to specify the signatures of all let
expressions. Rather than solving the problem, this approach simply shifts
the burden to the programmer. Another possibility is to prohibit leaving the
scope of a module variable whose signature has an abstract type component.
This means that all abstract types must be global, rather than local. To soften
the blow we may rename locally declared abstract types with special names
that indicate that they are “hidden,” relying on a programming convention
to avoid using types with such names. Such a convention may be systemati-
cally imposed by “name mangling” during elaboration of the source language
program into internal form. Using this approach, hiding abstract types can
be handled in much the same manner as type inference, pattern compilation,
and overloading resolution (Dreyer, Crary, and Harper, 2003).
8.6
Module Hierarchies
To avoid name clashes, it is useful to organize a collection of module bindings
into “clusters” of closely related bindings with more limited cross-cluster de-
pendencies. This may be achieved by permitting module bindings to occur as
components of other modules (with the usual distinction between its internal
and external names). Correspondingly, we introduce a new form of module
expression, the selection of a module component from another module. The
additional syntax to support module hierarchies is given in Figure 8-4.
A module that is bound within another is called a submodule of the sur-
rounding module. Most of the properties and relations associated with mod-
ules are extended recursively to sub-modules. For example, if all of the sub-
modules of a module are determinate, then so is the module itself. Equiv-
alently, if any sub-module is indeterminate (in particular, if it is sealed),
then the module itself is indeterminate. The implementation relation between
modules and signatures is extended recursively to submodules so that the
module

318
8
Design Considerations for ML-Style Module Systems
module q = mod {
module m = mod {
val x = 5
val y = 6
}
module n = mod {
val z = 7
}
}
implements this signature:
signature Q = sig {
module m : sig { val x:Nat val y:Nat }
module n : sig { val z:Nat }
}
The signature matching relation is extended covariantly to submodules. For
example, the signature Q above matches the signature
signature Q’ = sig {
module m : sig { val y:Nat }
}
(among others).
Besides simple namespace management, hierarchical modularity is also
useful in representing compound abstractions. A familiar example is the dic-
tionary abstraction, which builds on the concept of a linearly ordered type
of keys. The layering of dictionaries atop keys is naturally expressed using a
module hierarchy.
signature Ordered = sig {
type X
val leq : X × X →Bool
}
signature Dict = sig {
module key : Ordered
type Dict : *→*
val new : ∀V. Dict V
val add : ∀V. Dict V →key.X →V →Dict V
val member : ∀V. Dict V →key.X →Bool
val lookup : ∀V. Dict V →key.X →V
}
The Ordered signature speciﬁes a type equipped with a binary operation that
is intended to be a total ordering of that type. The Dict signature speciﬁes a
sub-module key implementing an ordered type.

8.6
Module Hierarchies
319
The types of the operations declared in the signature Dict make reference
to the type key.X, the type of keys. This illustrates the dependence of the
“rest” of a signature on (the type components of) a preceding sub-module
declaration. Strictly speaking, the type selections key.X occurring within the
signature Dict refer to the internal name of the sub-module key, whereas any
selections from a module implementing Dict refer to the external name, or
label, of that sub-module. To distinguish these two aspects of the sub-module
declaration we may write the Dict signature as follows:
signature Dict = sig {
module key > k : Ordered
type Dict : *→*
val new : ∀V. Dict V
val add : ∀V. Dict V →k.X →V →Dict V
val member : ∀V. Dict V →k.X →Bool
val lookup : ∀V. Dict V →k.X →V
}
In most cases it is not necessary to make explicit the distinction between the
internal and external name of a sub-module, and we rarely do. However, there
are situations in which the distinction is critical, as in the following example.
Consider the following module expression (call it M):
mod {
type X = Int
module m =
mod {
type X = Bool
val f = λa:X. 3
}
}
We wish to assign a signature to M that speciﬁes M.m.f to be a function of
type M.m.X→M.X. Without distinguishing internal from external names, there
is no way to write such a signature while holding M.m.X and M.X abstract. The
only possible attempt
sig {
type X
module m : sig { type X
val f : X →X }
},
fails because of shadowing of the outer declaration of X by the inner one.
However, by distinguishing the internal from the external name, we may write
the desired signature as follows:

320
8
Design Considerations for ML-Style Module Systems
sig {
type X > X’
module m : sig { type X > X”
val f : X” →X’ }
}.
Since the internal name is a bound variable, it may be renamed at will, thereby
avoiding problems of shadowing.
Returning to the Dict signature, the declaration of the sub-module key
indicates that any module implementing Dict comes equipped with its own
ordered type of keys. At ﬁrst glance this may seem unnatural, since we do
not ordinarily expect a dictionary abstraction to provide an ordered type of
keys, but rather to require one. The distinction is largely a matter of perspec-
tive. Even though the key sub-module is a component of an implementation
of Dict, it would ordinarily be obtained “oﬀthe shelf” by reference to an-
other module such as the type of integers ordered by magnitude, or the type
of strings ordered lexicographically. However, nothing precludes deﬁning the
key module “in place,” for example in the case that there is precisely one dic-
tionary in use in an entire program. Conversely, we would ordinarily expect
the type constructor Dict to be constructed as part of the implementation of
Dict, but this need not be the case. We might, in fact, copy this type from an-
other module, say a generic implementation of balanced binary search trees.
Or we may choose to construct a suitable data structure “on the spot.” Thus,
the components of a module may sometimes play the role of an “argument”
to that module, yet at other times play the role of a “result.” This ﬂexibil-
ity is of particular importance when considering families of signatures and
modules, to which we now turn.
8.7
Signature Families
To support code re-use, it is important to isolate repeated patterns in both
modules and signatures so that we may consolidate what is common to many
instances, allowing only the essential diﬀerences to vary. This is achieved by
introducing families of signatures and modules that isolate the pattern and
that may be specialized to recover a speciﬁc instance of the pattern. In this
section we consider families of signatures; families of modules are discussed
in §8.8.
A good example of the need for signature families is provided by the Dict
abstraction in the preceding section. An implementation of the Dict signa-
ture for an ordered type of keys takes the following form:

8.7
Signature Families
321
module dict1 = mod {
module key = key1
type Dict = λX:* . ...
...
}
Here key1 is some module implementing the signature Ordered. The princi-
pal signature for dict1 speciﬁes the type of keys:
signature Dict1 = sig {
module key : sig {
type X = key1.X
val leq : X × X →Bool
}
type Dict : *→*
...
}
We may seal the module dict1 with the signature Dict1 to ensure that the
type constructor Dict is held abstract. Note that it would not make sense to
seal dict1 with the signature Dict.
8.7.1
Exercise [«]: Why?
2
Now suppose that we wish to implement a second dictionary whose keys
are drawn from the module key2. As matters stand, we have no choice but to
replicate the same text, replacing key1 by key2 wherever it occurs.
signature Dict2 = sig {
module key : sig {
type X = key2.X
val leq : X × X →Bool
}
type Dict : *→*
...
}
module dict2 :> Dict2 = mod {
module key = key2
type Dict : *→* = ...
...
}
Doing this makes the code unnecessarily diﬃcult to modify—any change to
the signature Dict must be replicated for dict1 and dict2.

322
8
Design Considerations for ML-Style Module Systems
Clearly, what is needed is some means of isolating the common pattern as
a family of modules implementing a corresponding family of signatures, both
indexed by the type of keys. That way we may obtain each dictionary signa-
ture and module as an instance of the family for the corresponding ordered
type of keys. We turn ﬁrst to the representation of families of signatures;
families of modules are considered in the next section.
Representing Families
There are two main ways of representing families, parameterization and ﬁ-
bration.6 Using parameterization, we explicitly abstract the type of keys from
the Dict signature using a form of λ-abstraction.
signature DictP = λY:*.
sig {
module key : sig {
type X = Y
val leq : X × X →Bool
}
type Dict : *→*
...
}
Instances are obtained by application, writing
signature Dict1 = DictP(key1.X)
signature Dict2 = DictP(key2.X)
to obtain the signatures Dict1 and Dict2 that we wrote out explicitly above.
Using ﬁbration, on the other hand, we simply specify the type of keys by
“patching” the generic Dict signature using a “where clause” as follows:
signature Dict1 = Dict where key.X = key1.X
signature Dict2 = Dict where key.X = key2.X
As with parameterization, the result of these declarations is the same as the
explicit deﬁnitions of Dict1 and Dict2 given earlier. Observe that Dict1 and
Dict2 both match Dict.7
6. This terminology is borrowed from category theory, which considers two methods for rep-
resenting families of categories F indexed by a category I. An indexed category is a functor
IndF : Iop →Cat mapping I into the “category of categories”—roughly, a function from I to
categories. A ﬁbration is a functor (satisfying some conditions) FibF : F →I assigning to each
family in F its index in I. Our use of this terminology is analogical, not technically precise.
7. These where clauses can be thought of as a form of “signature inheritance,” analogous to
the “code inheritance” found in object-oriented languages. The fact that where clauses give
rise to subtypes is a natural corollary.

8.7
Signature Families
323
In both representations, the family of signatures is indexed by a type. While
theoretically suﬃcient, it is pragmatically unfortunate that, in both repre-
sentations, the indexing type is separated from its interpretation in terms
of operations. For example, since a type can be ordered in several diﬀer-
ent ways—for example, strings might be ordered lexicographically or by the
preﬁx ordering—it is preferable to maintain the association of a type with
its ordering operation. This may be achieved by generalizing type-indexed
families to module-indexed families. In the present case this would amount
to parameterization or ﬁbration over a module implementing the signature
Ordered. In parameterized form this would be written
signature DictP’ = λkey : Ordered.
sig {
module key = key
type Dict = ...
...
}
with instances
signature Dict1 = DictP’(key1)
signature Dict2 = DictP’(key2).
In ﬁbered form we would write
signature Dict1 = Dict where key = key1
signature Dict2 = Dict where key = key2.
In either case, instantiation of a signature family by a module may be viewed
as a convenient form of type indexing, since it is only the type components
of the instantiating module that aﬀect the result. This is particularly useful
in situations where the indexing module contains several type components,
possibly nested within sub-modules.
8.7.2
Exercise [«««]: Give a formal deﬁnition of the operation I where m = M, mak-
ing explicit any restrictions that must be made for this operation to be sensi-
ble.
2
Parameterization vs. Fibration
The chief advantage of parameterization over ﬁbration is familiarity. It is
natural (especially for functional programmers) to consider a family of sig-
natures indexed over implementations of a signature I as a “function” map-
ping implementations of I to signatures. Representing signature families by

324
8
Design Considerations for ML-Style Module Systems
parameterization requires a modest enrichment of the syntax to permit λ-
abstractions and applications of signatures, an extension of signature equiv-
alence to account for instantiation by substitution, and an extension of the
type system to classify parameterized signatures as a kind of function. Fiber-
ing, on the other hand, avoids the need for a new form of signature family by
exploiting submodule declarations, which are useful for other reasons.
A more important diﬀerence is that the parameterized approach requires
the programmer to anticipate the patterns of abstraction and instantiation
that may arise in any future use of a given signature. When several (type
or module) components are involved, it can be diﬃcult to anticipate which
are to be thought of as parameters and which are to be thought of as con-
structed components of the module. Indeed, the context may dictate one
choice in one situation, and another in another. The ﬁbered approach avoids
the need to anticipate the future, because it aﬀords a kind of “after the fact”
parameterization—any module or abstract type component may be consid-
ered to be the “argument” in a given situation without prior arrangement.
Taken in isolation, one may argue the advantages and disadvantages of ei-
ther representation as compared to the other, with neither coming out a clear
winner. However, when examined in the larger context of modular program-
ming, a distinct advantage for ﬁbration over parameterization emerges. To
explain why this is the case, we must ﬁrst consider families of modules.
8.8
Module Families
Needless to say, the justiﬁcations for introducing families of signatures apply
just as well to implementations. Continuing with the example from §8.7, we
might well require, in the same program, several diﬀerent dictionary mod-
ules, diﬀering only in the choice of key type. We would then like to abstract
the common pattern by forming a family of modules indexed by modules
satisfying a particular signature (Ordered).
A natural representation of a family of modules is as a λ-abstraction of a
module expression over a module variable of a speciﬁed signature. Such an
abstraction is called a parameterized module, or functor.8
Instances of the
family are obtained by functor application.9
The syntax required to support functors is given in Figure 8-5. (This gram-
mar permits higher-order functors, but for now we concentrate on the ﬁrst-
8. Rod Burstall once remarked that if we do not call the factorial function a “parameterized
integer,” then we should not call a functor a “parameterized module”!
9. We adopt here an indexed approach to module families, but it is worth noticing that a
ﬁbered approach also makes sense and has been explored under the name mixin modules; we
discuss these brieﬂy on page 343 below.

8.8
Module Families
325
M, F ::= . . .
modules:
λ( m:I) N
functor
F(M)
application
I
::=
. . .
signatures:
Π ( m:I1)I2
functor signature
λm:I1.I2
parameterized signature
I1 I2
application
I where X=T
where signature
Figure 8-5: Mechanisms for functors
order case, in which only basic modules may be provided as functor argu-
ments. See §8.9 for a discussion of the higher-order case.) The metavariables
F and G range over functors.
In §8.7 we noted that it would be useful to deﬁne a family of dictionary
modules indexed by the type of keys. Using the notation of Figure 8-5, a
dictionary functor might be written
module dictFun = λkey:Ordered. mod { ... }
where ... represents some implementation of the dictionary type and op-
erations. The dictionary module dict1 (with signature Dict1, deﬁned on
page 320) would then be obtained by applying dictFun to the key module
key1:
module dict1 = dictFun(key1)
If a functor is a kind of function, then its signature should be like a function
type—for example, the signature of the dictFun functor should be something
like this:
signature DictFun =
Ordered →
sig {
type Dict : *→*
val new : ∀V. Dict V
val add : ∀V. Dict V →key.X →V →Dict V
val member : ∀V. Dict V →key.X →Bool
val lookup : ∀V. Dict V →key.X →V
}
However, the arrow notation does not quite give us what we need because it
does not express the dependency between the argument and the result of the
dictionary functor—i.e., the fact that the module key appearing in the result
signature is precisely the functor’s argument. To capture this dependency,
we need an additional form of signature, called a functor signature, of the

326
8
Design Considerations for ML-Style Module Systems
form Πm:I.J. Such a signature binds the module variable m in the signature
J, permitting the dependency of the result signature on the argument to be
expressed. The signature I is the called the domain, and J is called the range.
(The signature Πm:I.J is a form of dependent function type; see Chapter 2
for background.) The type of the dictionary functor given above may now be
written as follows:
signature DictFun =
Πkey:Ordered.
sig {
type Dict : *→*
val new : ∀V. Dict V
val add : ∀V. Dict V →key.X →V →Dict V
val member : ∀V. Dict V →key.X →Bool
val lookup : ∀V. Dict V →key.X →V
}
Instantiating DictFun by a module M implementing the domain signature
Ordered yields a module whose type is the instance of the range signature
obtained by replacing key by M throughout.
8.8.1
Exercise [«]: One might guess that a family of modules would have a family
of signatures, but, instead of this, we introduced a new notion of functor
signatures. Why?
2
8.8.2
Exercise [«]: Note that DictFun can be written more concisely in terms of
the parameterized signature family DictP, as Πkey:Ordered. DictP(key).
Can DictFun also be expressed using the ﬁbered signature family Dict?
2
Functor arguments are required to be determinate because the range sig-
nature may involve type selections from the domain parameter (as in the
example above). Substitution of the argument for the parameter results in a
specialization of the range signature. Rather than use substitution, we may
also formulate the typing rule for functor application using subsumption.
Just as for ordinary function types, functor signatures are contravariant in
the domain and covariant in the range. This implies that we may weaken a
functor signature by strengthening its domain type. In particular, if F is a
functor with signature Πm:I.J, and M is a determinate module with transpar-
ent signature I′<:I, then F also implements the signature Πm:I′.J. Since I′
is transparent, any type selection of the form m.X in J may be replaced by its
deﬁnition in I′, thereby eliminating the dependence of the range signature
on the functor argument. This results in a signature of the form I′→J′, where
J′<:J. By covariance F implements I′→J′, and hence F(M) implements J′. In

8.8
Module Families
327
eﬀect we’ve performed the substitution of M for m in J using the types of F
and M alone, rather than by inspecting M itself.
8.8.3
Exercise [«, 3]: Work out the type checking of the application dictFun(M),
where M is a determinate implementation of the key signature Ordered of
your choosing, using the rules just described.
2
Coherence
Since families of modules are just functions from modules to modules, one
might guess that the language design issues they raise would be just the ones
familiar from higher-order functional programming languages. However, a
closer look reveals a signiﬁcant diﬃculty, called the coherence problem, that
must be overcome in any practical language with module families.
Suppose we have deﬁned modules ab and bc, each providing a function f
that maps between some input type In and some output type Out. For ab, the
input and output types are A and B; for bc they are B and C:
module ab = mod {
type In = A
type Out = B
val f : In →Out =
/* ... some function from A to B */
}
module bc = mod {
type In = B
type Out = C
val f : In →Out = /* ... some function from B to C */
}
Since the output type of ab is the same as the input type of bc, we can write
a third module of the same form that uses the f functions of ab and bc to
construct its own f mapping from A to C.
module ac = mod {
type In = A
type Out = C
val f = λx:In. bc.f (ab.f x)
}
The point to notice here is that the well-typedness of ac.f depends on the
fact that the result type of ab.f is the same as the argument type of bc.f.
Now, suppose that we have a lot of modules of the same form as ab and
bc, and we want to write many modules like ac that “compose” the transfor-

328
8
Design Considerations for ML-Style Module Systems
mations provided by a pair of existing modules.10 We would like to write a
composition functor that encapsulates, once and for all, the boilerplate in-
volved in building these composite modules. To do this, we ﬁrst deﬁne a
generic signature for “transformers”; this is the type of the inputs and the
output of the composition functor.
signature Tr =
sig {
type In
type Out
val f : In →Out
}
Both ab and bc implement Tr.
A naive ﬁrst attempt at writing the composition functor itself would be
this:
module compose =
λm:Tr. λn:Tr.
mod {
type In = m.In
type Out = n.Out
val f = λx:In. n.f (m.f x)
}
However, this is not well typed: the type expected by n.f is n.In, while the
type returned by m.f is m.Out, and we have no reason to believe that these
are the same. That is, we have failed to express the fact that, for composition
to make sense, the argument modules m and n must be coherent in the sense
that they share this type.
There are two well-known techniques for ensuring coherence, called shar-
ing by construction (also sharing by parameterization or Pebble-style sharing)
and sharing by speciﬁcation (or ML-style sharing). Sharing by construction
was invented by Burstall and Lampson (1984) in their Pebble language and
has been explored by many people, famously Jones (1996). Sharing by spec-
iﬁcation was originated by MacQueen (1984) and is used in the ML module
system.
10. One real-world domain where this sort of situation arises is in networking protocol toolkits
such as FoxNet (Biagioni, Haines, Harper, Lee, Milnes, and Moss, 1994) and Ensemble (van Re-
nesse, Birman, Hayden, Vaysburd, and Karr, 1998): the modules ab and bc in the example
correspond to individual protocol layers or “micro protocols,” the functions f correspond to
the processing performed by each protocol layer, and the input and output types correspond
to diﬀerent packet or message formats. Composite modules like ac correspond to protocol
stacks such as TCP/IP.

8.8
Module Families
329
Sharing by speciﬁcation relies on the technique of ﬁbered signature fami-
lies introduced in §8.7: the required coherence between the module param-
eters m and n is expressed by reﬁning the signature of n so that the only
modules to which compose can legally be applied are those whose Out com-
ponent coincides with the In component of m:
module compose =
λm:Tr. λn:(Tr where In = m.Out).
mod {
type In = m.In
type Out = n.Out
val f = λx:In. n.f (m.f x)
}
The type of this functor is
Π(m:Tr) Π(n:Tr where In = m.Out)
Tr where In=m.In and Out=m.Out
(writing and as a more readable synonym for where).
Before we go on, a short digression on notation is in order. The deﬁni-
tion of compose that we have just given is a little hard to read: since we
have deﬁned functors to take just one parameter at a time and used currying
to write multiple-argument functors, the inherently symmetric sharing rela-
tion between m.Out and n.In has to be de-symmetrized. We can recover the
symmetry in two steps. We begin by un-currying compose—i.e., we rewrite
compose into a one-argument functor whose parameter is a module with two
sub-modules m and n:
signature TrPair = sig {
module m : Tr
module n : Tr where In = m.Out
}
module compose =
λp:TrPair.
mod {
type In = p.m.In
type Out = p.n.Out
val f = λx:In. p.n.f (p.m.f x)
}
Second, we rewrite the signature TrPair in a symmetric way using a new
keyword sharing:

330
8
Design Considerations for ML-Style Module Systems
signature TrPair = sig {
module m : Tr
module n : Tr
sharing n.In = m.Out
}
The signature of compose now becomes:
Π(p:TrPair) Tr where In=p.m.In where Out=p.m.Out
Fortunately, sharing declarations add no foundational complexity to the lan-
guage: they are simple syntactic sugar. The sharing form just desugars into
the primitive where form—i.e., the compiler can straightforwardly expand the
second deﬁnition of TrPair into the ﬁrst. This syntax clariﬁes the essential
intuition that the argument to compose is not simply a pair of transformer
modules, but a coherent pair of modules.11
The sharing-by-construction style expresses the coherence required by the
compose functor in a diﬀerent way: by “factoring out” the shared type as
another parameter to compose. To achieve this, we ﬁrst replace the signature
Tr by a signature family, indexed by the types In and Out:
signature Tr = λIn:*. λOut:*.
sig {
val f : In →Out
}
module ab = mod { val f : A →B = ... }
: Tr A B
module cb = mod { val f : B →C = ... }
: Tr B C
Similarly, the signature of composable pairs, TrPair is parameterized on
three types:
signature TrPair = λIn:*. λMid:*. λOut:*.
sig {
module m : Tr In Mid
module n : Tr Mid Out
}
The coherence between m and n is expressed here by the fact that their signa-
tures both mention the same type Mid. Now we can write a compose functor
11. That is, in category-theoretic terms, not just a product but a pullback.

8.8
Module Families
331
module compose =
λIn:*. λMid:*. λOut:*.
λp : TrPair In Mid Out.
mod {
val f = λx:In. p.n.f (p.m.f x)
}
of type:
ΠIn:*. ΠMid:*. ΠOut:*.
Πp:(TrPair In Mid Out).
Tr In Out
We are using a little syntactic sugar here to make the example easier to read:
compose takes three types and a module as parameters, whereas, strictly
speaking, functors can only take modules as parameters. What we’ve written
can be regarded as an abbreviation for a heavier notation where each “bare
type” parameter is wrapped in a little module.
Sharing by construction has an appealing directness, especially for pro-
grammers trained in the mental habits of higher-order functional languages.
Moreover, since it relies only on abstraction and application for deﬁning
signature families, it can be carried out even in rudimentary module sys-
tems lacking the translucency required to express ﬁbered signatures. Unfor-
tunately, it suﬀers from a defect that makes it diﬃcult to use in practice: it
does not scale to deep hierarchies of functors.
To see why, note how the parameterized form of the compose functor has
to take the “middle type” Mid as an explicit parameter. This is not so bad
in the present example, where the hierarchy is shallow. But suppose that,
for some reason, we want to write a functor that composes together four
transformations.
In the ﬁbered style, we can write another signature that packages together
two TrPairs with an appropriate sharing declaration relating the ﬁnal out-
put of the ﬁrst with the initial input of the second:
signature TrQuad = sig {
module xy : TrPair
module zw : TrPair
sharing zw.m.In = xy.n.Out
}
Note how the coherence between the ﬁrst and second transformations and
between the third and fourth is expressed by the two uses of the TrPair
signature—all that needs to be stated explicitly in TrQuad is the coherence
of the second and third. The compose4 functor is equally straightforward to
write, using three applications of the original compose:

332
8
Design Considerations for ML-Style Module Systems
module compose4 =
λq:TrQuad.
let xtheny = compose q.xy in
let zthenw = compose q.zw in
let p = mod { module m = xtheny, module n = zthenw } in
compose p
In the parameterized style, on the other hand, the TrQuad signature is
much more awkward:
signature TrQuad = λT1:*. λT2:*. λT3:*. λT4:*. λT5:*.
sig {
module xy : TrPair T1 T2 T3
module zw : TrPair T3 T4 T5
}
Note how the “internal” coherence constraints on xy and zw have “come to
the outside” as parameters to TrQuad. Now compose4 looks like this:
module compose4 =
λT1:*. λT2:*. λT3:*. λT4:*. λT5:*.
λq : TrQuad T1 T2 T3 T4 T5.
let xtheny = compose T1 T2 T3 q.xy in
let zthenw = compose T3 T4 T5 q.zw in
let p = mod { module m = xtheny, module n = zthenw } in
compose T1 T3 T5 p
The type parameters to compose4 are nuisance parameters: they are present
solely to express the required type sharing relationships among the “real”
arguments to the functor.
8.8.4
Exercise [«]: Suppose we extended this pattern to write compose8 (using
two applications of compose4 and one of compose). How many type param-
eters would compose8 need to take in the parameterized style? What about
compose16?
2
This example shows how sharing by parameterization forces the “plumb-
ing” required to ensure coherence of a functor low in the dependency hier-
archy to be recapitulated by every higher-level functor that uses it, by yet
higher level functors that use these, etc. Setting up this plumbing (and worse,
maintaining it as the program evolves), quickly becomes impractical except
for shallow hierarchies. This failure of scalability was observed early on by
MacQueen (1984), but has not been widely recognized.
It is important to emphasize that the representation of signature families
bears strongly on the method of expressing sharing relationships. If signature

8.8
Module Families
333
families are represented in parameterized form, then sharing by construction
is the only available method of ensuring coherence. We must instantiate two
families by application to the common types or modules to ensure compat-
ibility. On the other hand, if signature families are represented in ﬁbered
form, then either method of ensuring coherence is available, since we may
either specialize two or more signatures with the common component using
the where construct, or we may specify that they cohere on the common com-
ponents using sharing. The crucial reason for this is that a ﬁbered signature
is a signature—it can be instantiated, or not, as a given situation demands.
This allows decisions about parameterization and sharing to be performed in
a natural “post-hoc” manner. Since each module internally recapitulates the
whole module dependency graph, coherence requirements can be satisﬁed
simply by adding a few equations tying together subgraphs as appropriate.
The Pragmatics of Functors
Since relatively few present-day languages support families of modules, it is
worth surveying the practical motivations for including them in a module
system. These fall into several categories:
1. Many abstractions are naturally parametric in a type and its associated op-
erations. For example, we illustrated in §8.8 that a dictionary abstraction is
naturally parametric in both the type of its keys and the interpretation of
that type as pre-ordered. Thus, functors arise naturally in shared libraries.
2. Many programs are naturally functorial in nature. For example, the archi-
tecture of the FoxNet implementation of TCP/IP (Biagioni et al., 1994) and
related networking protocols is based on treating each “layer” of a protocol
stack as a functor that is parametric in the layers that occur “above” and
“below” it in the protocol hierarchy. To take another example, the SML/NJ
compiler for Standard ML implements cross-compilation by deﬁning the
central code generation module to be parametric in the target architecture
module, so that several code generators can be simultaneously active and
share the bulk of the code. Thus, some program architectures are naturally
functorial.
3. A variety of link-time techniques—based on mechanisms such as “path
hacking,” class loaders, and various tools provided by the programming
environment—are commonly used to achieve eﬀects similar to those ex-
pressible using functors. For example, partial linking of several object ﬁles
into a single, further-linkable object ﬁle (using ld -r in Unix, for example)
is nothing but a means of deﬁning a functor whose parameters are the

334
8
Design Considerations for ML-Style Module Systems
unresolved modules and whose result is the partially linked module con-
structed by the linker. Because such devices are extra-linguistic in nature,
they can be unsafe because the external tools are not aware of typing re-
strictions. In particular, when used for languages with abstract types, such
devices may violate coherence constraints, leading to unsafe code. Thus,
functors codify and formalize certain extra-linguistic programming prac-
tices.
Some of the problems addressed by functors are also amenable to treat-
ment by more primitive modularity mechanisms. (This helps explain why the
software industry has not yet ground to a halt due to the lack of functors
in mainstream languages!) These mechanisms are often more convenient for
speciﬁc purposes, even if they may be subsumed or explained by the more
general mechanism of functors.
For example, Haskell encourages the use of type classes to deﬁne inter-
pretations of types by operations. One may, for instance, introduce a class of
ordered types as those that come equipped with a binary relation on them. In-
stances of this class are introduced by specifying the (sole) interpretation of
a type by a given binary relation. Instances are often conditional on other
instance requirements. For example, one may declare the type Int to be
pre-ordered by the standard magnitude comparison function, and one may
declare the product type (A,B) to be pre-ordered lexicographically (say), pro-
vided that A and B are also ordered. In the terminology of this chapter, type
classes are simply signatures and instance declarations are functors mapping
zero or more instances of some classes to an instance of a designated class.
(This use of functors is limited in that a given type may implement the class
of ordered types in at most one way, whereas in general a type may admit
many orderings. A beneﬁt of this limitation is that the “functor applications”
required to calculate appropriate instances of classes may be performed au-
tomatically by the compiler.)
Another case where a more primitive mechanism may suﬃce concerns a
parameterized abstraction, such as dictionaries (parameterized on keys), pro-
vided by a library. If we happen to know that any given program using this
abstraction instantiates it just once, then the abstraction itself need not be
functorized. Instead, the dictionary library can simply be a module contain-
ing an unresolved external reference to a key module that must be resolved
in the linking context of each program that uses it. Specifying the instance is
generally achieved by extra-linguistic mechanisms such as modifying a search
path or installing a special-purpose loader, but such mechanisms could also
be internalized as a part of the module language.

8.8
Module Families
335
Another important special case is found in object-oriented languages. The
nearest analogs of modules in these languages are classes and objects. Ob-
jects may be viewed as ﬁrst-class modules with one abstract type, which
speciﬁes the types of the instance variables of the object. (This correspon-
dence between objects and modules is explored in depth in TAPL, Chapter
24.) While suﬃcient to capture some common cases, this idiom makes it awk-
ward to manage a collection of inter-related abstract types. (One example is
the mathematical notion of a vector space, which involves an abstract type
of vectors together with a related type of scalars, each with its own set of
associated operations.) Another issue is that these languages oﬀer no analog
of sharing (by parameterization or speciﬁcation) of representations, which
is the core issue underlying the well-known diﬃculties with binary methods
(Bruce et al., 1996).
Classes provide a limited form of modularity by serving as the locus of code
sharing for all instances of the class. But inheritance is, by its very nature,
anti-modular in that it couples the code of a sub-class to the code of its
super-class. In particular, there is no notion of signature for a class, nor—in
most object-oriented languages12—any means of inheriting from an unknown
(abstract) super-class. Moreover, if a sub-class determines a subtype of the
super-class type, it is impossible to determine anything about the behavior
of an instance of a class from its type alone. For knowing that o is an object
of a (non-final) class C means only that o is an instance of some sub-class
of C, whose behavior may be totally unrelated to instances of C itself. For
these reasons classes provide only a weak form of modularity, and cannot be
considered to replace it. Fisher and Reppy have examined these issues in the
design of the Moby language (1999).
An often-repeated argument for functors is that they may be used as a
replacement for a linking mechanism. The idea is that all inter-module refer-
ences are to be mediated by a functor—the so-called fully functorized style
of programming—so as to improve program readability by making explicit all
cross-module references. But adopting a fully functorized style amounts to
replacing each deﬁnite reference in a module by an indeﬁnite reference—the
free module variable is λ-abstracted in the functor. A central “linking module”
then applies these functors in dependency order to construct the complete
system; i.e., the behavior of the linker itself is internalized and made explicit
as a module-level program. Experience has shown this to be a bad idea: all
this parameterization—most of it unnecessary—gives rise to spurious coher-
ence issues, which must be dealt with by explicitly (and tediously) decorating
12. Languages with mixin modules are, in this respect, closer to the module systems we are
discussing.

336
8
Design Considerations for ML-Style Module Systems
I
::=
. . .
signatures:
ΠG ( m:I1):I2
generative functor
ΠA ( m:I1):I2
applicative functor
Figure 8-6: Mechanisms for applicative and generative functors
module code with numerous sharing declarations, resulting in a net decrease
in clarity and readability for most programs.
Functors and Determinacy
When is a functor application determinate? There are two possibilities, de-
pending on whether we take the functor to be generative or applicative. If
generative, each instance of a functor that yields an abstract type “generates”
a new abstract type at the point of instantiation. If applicative, there is one
abstract type covering all instances of the functor with equivalent arguments.
The diﬀerence between these two forms of functor is that the application of
a generative functor is indeterminate, whereas the application of an applica-
tive functor is determinate. To model both forms of functor we introduce two
forms of functor signature, as described in Figure 8-6.
Needless to say, the classiﬁcation of functors into applicative and genera-
tive is not arbitrary. If the body of a functor is indeterminate, then the functor
can only be regarded as generative. Otherwise, an application of such a func-
tor would be determinate, even though it is essentially a substitution instance
of its indeterminate body. Thus a functor may be deemed applicative only if
its body is determinate, but we may regard any functor as generative, by ne-
glecting the possible determinacy of its body. Therefore, it is natural to posit
that the applicative functor type is a subtype of the corresponding generative
functor type.
8.8.5
Exercise [«««]: Show that it is unsound to consider the generative functor
type to match the applicative. (Hint: Adapt the solution to Exercise 8.5.6.)
2
Assuming we have both applicative and generative functors at our disposal,
when is it appropriate to use one or the other? Let us consider several exam-
ples.
If a functor implements an abstract type using per-instance state, it should
be generative. For example, consider the implementation of a type of sym-
bols using a hash table. (Here and elsewhere, we omit the result signature on
functors for the sake of brevity.)

8.8
Module Families
337
signature ST = sig {
type Symbol
val str2sym : String →Symbol
val sym2str : Symbol →String
val eq : Symbol × Symbol →Bool
}
module stFun :> ΠG m:(sig{}).ST =
λG m:(sig{}). mod {
type Symbol = Int
val table : string array = Array.new (100, NONE)
val str2sym = λs:String. ...
val sym2str = λs:Symbol.
case Array.sub (table, n) of
SOME x ⇒x | NONE ⇒...
val eq = λ(n1,n2) = (n1 = n2)
}
module stOne = stFun (mod{})
module stTwo = stFun (mod{})
The two instances, stOne and stTwo, of stFun generate distinct abstract
Symbol types, and stOne.Symbol is distinct from stTwo.Symbol. Were these
types confused, symbols from one table could be intermixed with symbols
from another, leading to incorrect results and run-time exceptions that could
be avoided by keeping them apart. In particular, the NONE clause in the body
of stFun can safely be omitted if the functor is generative, but must be in-
cluded (or we run the risk of a match failure) if it is applicative.
A natural example of an applicative functor is one whose argument consists
solely of types and whose result does not involve any eﬀects. For in such a
case there is no reason to distinguish abstract types in diﬀerent instances
of the functor. For example, consider a functor setFun that takes a type of
elements as argument and yields an abstract type of sets of these elements.
signature setFunInt =
ΠA m:(sig { type X }).
sig {
type Set
val insert : m.X × Set →Set
... }
module setFun :> setFunInt =
λA m : sig { type X }.
mod {
type Set = ...
val insert = ... }

338
8
Design Considerations for ML-Style Module Systems
Notice that the functor itself is sealed with an applicative functor type to
ensure that the Set type in the result is abstract.
One consequence of restricting an applicative functor to have a determi-
nate body is that neither its body nor any of its sub-modules may be sealed.
(Were we to do so, the body would be indeterminate, forcing the functor to
be generative.) This explains why we sealed the setFun functor itself, rather
than writing it in the form
module setFun =
λm:sig { type X }.
(mod {
type Set = ...
val insert = ...
} :>
sig {
type Set
val insert : m.X * Set →Set
...
}).
While sealing the functor itself can be used to impose abstraction on its
instances, it cannot be used to impose abstraction within the body of the
functor. One way to remedy this deﬁciency is to distinguish two forms of
sealing, static sealing and dynamic sealing, and two associated forms of in-
determinacy, static indeterminacy and dynamic indeterminacy. The dynamic
forms of sealing and indeterminacy are just those considered up to now. The
static forms are added solely to enrich the class of applicative functors. A
statically sealed module is statically indeterminate, which ensures represen-
tation independence. An applicative functor body is permitted to be statically
indeterminate, but not dynamically indeterminate (which would force gen-
erativity). The terminology stems from considering that, for an applicative
functor, abstraction is imposed once when the functor is type-checked, rather
than each time the functor is applied; the abstraction eﬀect is “static,” rather
than “dynamic.”
8.9
Advanced Topics
First-Class Modules
The framework developed here is compatible with treating modules as ﬁrst-
class values, by which we mean that we may readily enrich the language to
permit modules to be manipulated as ordinary values in the core language.
For example, we may store a module in a data structure, then retrieve it and

8.9
Advanced Topics
339
reconstitute it as a module-level expression, without violating representation
independence or type safety. We need only ensure that any means of creating
a module from a core language computation is considered indeterminate so
as to preserve safety and representation independence.
Why not just do away with the distinction between the core and module
languages entirely? While this would seem to simplify matters by collaps-
ing a distinction, it complicates the type theory signiﬁcantly, requiring that
the core language be enriched with the mechanisms required to support
modularity. These include types for submodules and functors, a subtyping
relation, and the means to ensure static type checking in their presence.
These complications are not insurmountable. One such formalism was devel-
oped by Harper and Lillibridge (1994), who also showed that the type check-
ing problem for this language is undecidable, due to complex interactions
between subtyping, impredicative polymorphism, and type sharing speciﬁ-
cations. Dreyer, Crary, and Harper’s formalism (Dreyer, Crary, and Harper,
2003), on the other hand, achieves adequate expressiveness, including sup-
port for ﬁrst-class modules, without incurring undecidability.
Finally, even if we were to attempt to consolidate the module and core lev-
els, we would ﬁnd ourselves facing the same questions at a higher level. For,
as the development of this chapter makes clear, once we introduce separate
compilation (as surely we must), we once again face the same questions of
modularity, at the level of compilation units. Module arise even when you try
to avoid them!
Higher-Order Modules
Higher-order modules—i.e., functors taking functors as parameters—present
some interesting further diﬃculties. The classic (if somewhat contrived) mo-
tivating example is the apply functor, deﬁned as follows:
module apply =
λf:(Πi:I.J).
λi:I.
f(i)
module m :> I = ...
module f :> Πi:I.J = ...
module n = f(m)
module p = apply(f)(m)
One might expect that n and p are equivalent, since both apply f to m. But this
need not be so, at least if we wish to give a single type for apply that governs
all of its uses. For then we must specify whether the argument, f, to apply

340
8
Design Considerations for ML-Style Module Systems
is applicative or generative. If it is required to be applicative, we may ascribe
the following type to apply:
ΠA f:(ΠA i:I.J). ΠA i:I. (J where X=f(i).X).
This expresses the dependence of the result type X on the two arguments
consistent with the deﬁnition of apply. Indeed, apply(f)(a).X is equivalent
to f(a).X, as desired.
On the other hand the functor argument to apply might be taken to be
generative, in which case the best typing for apply is
ΠG f:(ΠG i:I.J). ΠG i:I. J
Since f is taken to be generative, we lose type sharing information in the
result, because the application f(a) is indeterminate, and hence the “type”
f(a).X is ill-formed. Consequently, the abstract type X in n and p are not
known by the type checker to be the same.
It has been suggested that there should only be one apply functor that
covers both cases illustrated above. To do so requires that we employ a
form of intersection type (at the level of signatures) that captures the two
forms of behavior just described. An alternative, suggested by MacQueen and
Tofte (1994), is to refrain from assigning types to functors, in eﬀect re-type-
checking the body on each use. This means that the code, and not just the
type, of the functor must be available to all clients, which precludes separate
compilation.
Static and Dynamic Equivalence
There are two main choices for module equivalence: static equivalence and
dynamic equivalence. Static equivalence deems two modules to be equivalent
whenever their static parts are equivalent. This is the coarsest equivalence be-
tween modules that conservatively extends core language type equivalence,
and is therefore the most permissive choice. The alternative, dynamic equiv-
alence, considers both the static and dynamic parts of modules in the deﬁni-
tion of equivalence. Dynamic equivalence is, in general, undecidable, so some
conservative approximation must be used in practice.
However, dynamic equivalence makes it possible to distinguish two diﬀer-
ent interpretations of the same type without generativity. For example, if f is
a module variable of functor type, and M and N are determinate modules of its
domain type, then f(M).X is equivalent to f(N).X iﬀM and N are equivalent
modules. Static equivalence ignores the dynamic part of these two modules,
whereas dynamic equivalence would distinguish these types if M and N diﬀer
only in their dynamic components.

8.10
Relation to Some Existing Languages
341
Recursive Modules
The model of linking discussed in §8.1 requires that the dependency relation
among modules be acyclic—that there be a linear ordering of the modules
consistent with their dependencies. It is natural to consider whether this re-
striction might be lifted to permit a more general form of “cross-linking”
of modules. Since cyclic dependencies amount to (direct or indirect) self-
reference, one approach to modelling such a generalization is via recursive
modules (Crary, Harper, and Puri, 1999; Russo, 2001). Another approach is
to devise a linking formalism that permits cyclic dependencies (Ancona and
Zucca, 1998; Hirschowitz and Leroy, 2002; Flatt and Felleisen, 1998).
Cyclic dependencies raise some signiﬁcant problems that must be addressed
in any satisfactory solution. Most importantly, permitting recursive modules
should not disrupt the semantics of the underlying language. Without restric-
tion, cyclic dependencies among modules can introduce a type A satisfying
the equation A = A →Int, or a value v of type Int satisfying the equation
v=v+1. In most languages such equations have no solution, and should not be
permitted. Another issue is the interaction with eﬀects. Permitting cyclic de-
pendencies conﬂicts with the need for a linear initialization order consistent
with dependencies. Care must be taken to ensure that values are not refer-
enced before they are deﬁned (or, at a minimum, that such references are
caught at run time). Finally, for maximum ﬂexibility, mutually recursive mod-
ules should be separately compilable. This requires some form of “forward”
declaration to cut cycles in the dependency graph. It also requires a linking
formalism that can support mutually cross-referencing modules, even in the
presence of type declarations.
8.10
Relation to Some Existing Languages
The design issues discussed in this chapter are largely motivated by the ML
module system. There are two closely related realizations of the ML module
system, the Standard ML module system and the Objective Caml module sys-
tem. Basic modules are called structures, signatures are called signatures, and
functors are so-called in both cases. Both designs provide for hierarchy and
parameterization using essential the same mechanisms as described here,
and both adopt the approach to sharing by speciﬁcation described in §8.8.
The designs diﬀer signiﬁcantly in their treatment of separate compilation,
the avoidance problem, and higher-order modularity. The two languages are
based on rather diﬀerent foundations. Standard ML is deﬁned by an elabora-
tion relation that constitutes an algorithmic speciﬁcation of the well-formed
programs. Objective Caml lacks a formal deﬁnition, but the design follows
quite closely a type theory of the general kind considered here.

342
8
Design Considerations for ML-Style Module Systems
Standard ML, as oﬃcially deﬁned (Milner, Tofte, Harper, and MacQueen,
1997), permits only ﬁrst-order, generative functors, provides no support for
separate or incremental compilation, and handles the avoidance problem by a
technical device that sacriﬁces principality. To amplify the last point ﬁrst, the
elaboration relation that deﬁnes the static semantics of Standard ML relies on
an internal notion of “type names” that are generated during elaboration. Hid-
den abstract types are represented by type names that cannot be designated
by any Standard ML type expression, and hence internal “signatures” are not
expressible by any signature in the language. Consequently, the Standard ML
module system does not in general admit principal (source language) signa-
tures. As to separate compilation, the formal deﬁnition of Standard ML does
not address it, so each implementation provides its own mechanisms. The
most widely used implementation, Standard ML of New Jersey (SML/NJ), has
a well-developed compilation manager (Blume and Appel, 1999; Blume, 2002)
that supports incremental and cut-oﬀcompilation. SML/NJ also provides ex-
tensions to permit higher-order modularity that rely on elaborate internal
representations of functors that cannot be written in any source language sig-
nature, and is therefore incompatible with separate compilation. Moscow/ML
(Sestoft, 2003; Russo, 1998) is an implementation of Standard ML based on a
type-theoretic interpretation of the language. It provides recursive and ﬁrst-
class structures, and both applicative and generative functors.
Objective Caml permits higher-order, applicative functors, supports sepa-
rate and incremental compilation, and handles the avoidance problem by sac-
riﬁcing principality. Again taking the last point ﬁrst, Objective Caml rejects
certain well-formed programs (in the sense of the underlying type theory of
the language) when the implementation does not succeed in weakening a sig-
nature to avoid the occurrence of an abstract type (Dreyer, Crary, and Harper,
2003). The commitment to applicative functors stems from a desire to permit
type selections of the form f(m).X in sharing speciﬁcations.
The Haskell (Peyton Jones, 2003) module system is rather weak, providing
only rudimentary namespace management. This deﬁciency is ameliorated by
type classes. Viewed in terms of the framework of this chapter, the Haskell
type class system amounts to a stylized use of modules. Polymorphic abstrac-
tion is generalized to functor abstraction—expressions take not only types,
but associated operations, as arguments. The functor arguments are gener-
ated automatically during type inference based on a signiﬁcant methodolog-
ical restriction: no type may admit more than one interpretation by a given
set of operations. (For example, in conjunction with type classes no type may
be partially ordered in more than one way in a given program.) These inter-
pretations are speciﬁed by type class declarations that amount to functor
deﬁnitions. The type checker implicitly instantiates these functors (through

8.11
History and Further Reading
343
a process of backchaining) to determine the required implicit arguments. Ex-
perimental designs for richer modularity mechanisms have been proposed
in the literature. For example, Jones (1996) regards modules as polymorphic
records, which forces the programmer to manage explicitly the separation of
the static from the dynamic parts of a module.
Flatt and Felleisen’s units (1998) provide a form of modularity for Scheme
programs (and other languages) that emphasizes separate compilation and
recursive linking. Their language does not consider type abstraction or the
associated problems of type sharing. In their realization, units are ﬁrst-class
values, amounting to records in the underlying language. In other formu-
lations, units are used to structure existing C code to provide namespace
management and a ﬂexible linking formalism (Reid et al., 2000).
Ancona and Zucca’s mixin modules (1998; 2002) isolate a variety of com-
binators for combining modules into programs. As suggested by Bracha and
Cook (1990), mixins provide a basis for modelling inheritance, as well as sup-
porting cyclic dependency relationships among modules. Mixins may be seen
as ﬁbered representations of families of modules in which instantiation is
represented by “mixing in” one module with another.
8.10.1
Exercise [«««]: The C language lacks an internal notion of module, prefer-
ring instead to exploit the ambient ﬁle system to provide most of the requisite
mechanisms. Discuss.
2
8.10.2
Exercise [«««]: The Java language also lacks direct analogs of most of the
mechanisms we have introduced. However, Java does oﬀer a rich collection
of program structuring mechanisms, some of which can be used to achieve
eﬀects similar to the ones illustrated here. Discuss.
2
8.11
History and Further Reading
The development of the linguistic and methodological foundations of data
abstraction and modularity dates back to the earliest days of academic com-
puter science (Parnas, 1972). Seminal work by Wirth (1973) and Hoare (1972)
(among many others) was inﬂuential on the development of languages in the
Algol family such as Pascal (Jensen and Wirth, 1975), Modula-2 (Wirth, 1983),
CLU (Liskov, 1993), and Modula-3 (Cardelli, Donahue, Jordan, Kalsow, and
Nelson, 1989). The Lisp family of languages (Steele, 1990) inﬂuenced the de-
sign of ML (Gordon, Milner, and Wadsworth, 1979), which introduced type
inference, polymorphism, and abstract types. This sparked the development
of several languages, such as Hope (Burstall, MacQueen, and Sannella, 1980),
Standard ML (Milner, Tofte, Harper, and MacQueen, 1997), Objective Caml

344
8
Design Considerations for ML-Style Module Systems
(Leroy, 2000), and Haskell (Peyton Jones, 2003), founded on these ideas. The
ML module system, originally proposed by MacQueen (1984), further devel-
oped in the design of Standard ML and Objective Caml, forms the conceptual
basis for much of the material presented in this chapter.
The theoretical framework employed in this chapter (and in TAPL) is the
typed λ-calculus. One important topic was to develop type systems to support
data abstraction. A fundamental ﬁrst step was taken by Mitchell and Plotkin
(1988) who related abstract types to second-order existential quantiﬁcation,
extending the connection between type polymorphism and second-order uni-
versal quantiﬁcation discovered by Girard (1972) and Reynolds (1974). Mac-
Queen (1986) pointed out that existential types are not adequate for express-
ing modular structure, suggesting instead a formalism based on dependent
types. These initial steps provided the impetus for further research into type
systems for modularity with the overall goal of providing the abstraction
guarantees aﬀorded by existential types and the ﬂexible modular program-
ming mechanisms aﬀorded by dependent types.
One strand of research focused on enriching the existential framework to
support controlled propagation of type sharing information in a program.
Three important developments were Harper and Lillibridge’s translucent sum
types (1994; Lillibridge, 1997), Cardelli and Leroy’s “dot notation” (1990) and
Leroy’s manifest types (1994; 1996), and Stone and Harper’s singleton kinds
(2000; Stone, 2000). These type systems support hierarchy and parameteri-
zation with control over the propagation of type sharing relationships, even
in the presence of ﬁrst-class modules.
Another strand focused on developing the mechanisms of dependent types
to support higher-order modules. Building on MacQueen’s suggestions, Harper
and Mitchell proposed a calculus of dependent types suitable for modelling
many aspects of the ML module system (1993). This framework was further
reﬁned by Harper, Mitchell, and Moggi (1990) to ensure respect for the phase
distinction in a fully expressive higher-order module system. Further work
by Russo (1999) further underscored the point that the apparent dependen-
cies are not really dependencies at all, by performing a “manual” form of
phase-splitting during elaboration in the setting of a type-theoretic semantics
for Standard ML. This formalism also provided the foundation for compil-
ing modules into typed intermediate languages (Shao, League, and Monnier,
1998). Shao (1999) considered a type system that ensures the existence of
principal signatures, at the expense of ruling out some programs that are
expressible in ML.
The abstract-type formalisms provided only weak support for higher-order
modules, and the dependent-type formalisms provided no support for ab-
straction. Leroy introduced applicative functors (1995) in an eﬀort to enrich

8.11
History and Further Reading
345
the abstract type formalism with richer higher-order constructs, but in the
process sacriﬁced generative type abstraction. A fully comprehensive formal-
ism was introduced by Dreyer, Crary, and Harper (2003), based on interpret-
ing type abstraction as a pro forma computational eﬀect.
A rather diﬀerent approach to the semantics of modularity is the elabo-
ration framework of The Deﬁnition of Standard ML (Milner, Tofte, Harper,
and MacQueen, 1997). The type checking rules for modular programming
are given by an algorithm (expressed in inference rule format) for comput-
ing an internal representation of the signature of a module. A weakness of
this approach is that it lacks any connection with the typed λ-calculus for-
malisms that form the foundation for the semantics and implementation of
programming languages. This deﬁciency was addressed by Russo (1998), who
re-formulated The Deﬁnition using constructs from type theory. Harper and
Stone (2000) provided an alternative deﬁnition for Standard ML based on a
separation between elaboration, which included type inference, overloading
resolution, pattern compilation, and semantics, which was based on a foun-
dational type theory for modularity.
Garcia et al. (2003) make an interesting comparison of the modularity mech-
anisms found in several popular languages, from the point of view of support-
ing a particular style of “generic programming.”


9
Type Deﬁnitions
Christopher A. Stone
Practical uses of interesting type systems often involve large and complex
types, and it is useful to have methods for abbreviating these types. The
simplest idea is to treat these deﬁnitions purely as meta-level constructs (de-
rived forms), an approach with few theoretical complications. For example, in
a language with recursive and variant types (e.g., λµ in TAPL, Chapter 20), we
could deﬁne
Nat
def
=
µY.<zero:Unit, succ:Y>
NatList
def
=
µX. <nil:Unit, cons:Nat × X>
after which the cons function for lists could be described as having the type
Nat →NatList →NatList rather than the much larger type
(µY. <zero:Unit, succ:Y>) →
(µX. <nil:Unit, cons:(µY.<zero:Unit, succ:Y>) × X>)
→
(µX. <nil:Unit, cons:(µY.<zero:Unit, succ:Y>)× X>).
As long as these deﬁnitions are non-circular, they are convenient but inessen-
tial syntactic sugar. In principle the symbolic names can all be replaced by
their deﬁnitions, and so we can ignore them when reasoning about the lan-
guage itself: we may write types such as Nat →NatList →NatList infor-
mally, but “oﬃcially” we always mean the corresponding expanded type.
It is not always possible or practical, however, to omit type deﬁnitions from
the language being studied. In some instances type deﬁnitions are explicitly
part of the language itself. For example, the ML language permits type deﬁni-
tions by the user using the type keyword. C and C++ allow similar deﬁnitions
with the typedef keyword.
Alternatively, a language implementation might preserve deﬁnitions rather
than substituting them away; expanding all deﬁnitions can lead to signiﬁ-

348
9
Type Deﬁnitions
cantly larger types. Techniques such as DAG representations and hash con-
sing (Shao, League, and Monnier, 1998) can ameliorate this problem but the
results can be signiﬁcantly less readable: if a type is originally written using
abbreviations, it is often desirable to retain them for displaying the type (e.g.,
when reporting errors during type checking, as discussed in TAPL, §11.4).
If type deﬁnitions are included in the language or its implementation, we
would still like to know that properties such as type safety continue to hold,
and that our algorithms (e.g., for type checking or code transformations) are
correct. However, the addition of deﬁnitional mechanisms can change the
properties of type systems in ways that are not immediately obvious. For
example, suppose X is an operator mapping types to types. In F ω, the type
equivalence X T1 ≡X T2 holds if and only if T1 ≡T2. But if X is deﬁned as the
constant operator λY::*.Int, then suddenly X T1 ≡X T2 holds for arbitrary
T1 and T2.
As deﬁnitional mechanisms become more sophisticated, ensuring a proper
implementation can be more diﬃcult. For example, after the module deﬁni-
tion (using roughly the syntax of Chapter 8)
module n = mod
type t = Nat
val
x : t = 3
end
we can use n.t as a synonym for Nat. In this case we have a deﬁnition not for
the simple name t, but for the entire projection n.t. Moreover, module com-
ponents can be referenced indirectly; we cannot eliminate the type deﬁnition
just by replacing n.t by Nat. For example, the further deﬁnitions
module n’ = n
module diag = λ(p : sig
type t
val x : t
end).
mod
type u = p.t × p.t
val
y : u = {p.x, p.x}
end
module nn = diag(n’)
nowhere mention the projection n.t, yet a correct type checker must nev-
ertheless conclude both that n′.t is a synonym for int (by deﬁnition the
components of n′ are the same as the components of n) and that nn.u is

349
equal to the type int × int (guaranteed by the deﬁnition of diag). Addition-
ally, the deﬁnition for u in the functor’s result, which depends on the speciﬁc
functor argument, must be retained in order to type check further uses of
diag.
It is therefore useful to study type deﬁnitions as primitive concepts. The
focus here is deﬁnitions for types because these have the most signiﬁcant
eﬀect on type equivalence and type checking and hence on language prop-
erties such as safety. Very similar approaches are used, however, to study
term-level deﬁnitions and their eﬀects upon term equivalence.
We look at three approaches to adding type deﬁnitions to a language. Sec-
tion 9.1 deﬁnes the language λlet, which adds primitive deﬁnitions of type
variables to the typing context. The context can record X::K if X is an un-
known type variable of kind K, and can record X::K=T if X is known to be
equal to the type T of kind K. This mechanism directly allows deﬁnitions
analogous to NatList above.
Section 9.2 formalizes parts of Chapter 8 by considering a calculus λL M of
second-class modules based on translucent sums. Again we have the choice
between specifying either just a kind or both a kind and a deﬁnition, but now
here all type deﬁnitions appear in module interfaces. This requires specifying
a language of modules and interfaces, and also introduces a limited form of
dependent type (since modules, which contain terms, can appear in types).
Finally, Section 9.3 deﬁnes λS, a generalization of λlet that incorporates
deﬁnitions into the kind system itself. The kind * classiﬁes all ordinary types,
while the new, more-precise singleton kind S(T) classiﬁes only those ordinary
types equivalent to T. This allows deﬁnitions at any point where a kind is
speciﬁed. We then relate λL M to λS by showing that modules can be translated
away using a phase-splitting transformation.
All three systems are described as variants of F ω
×η, the higher-order poly-
morphic lambda calculus extended with product types and with extensional-
ity (eta). The types and kinds of this base language are shown in Figure 9-1,
and the terms are shown in Figure 9-2. Although not formally part of the
system, many examples will assume the existence of familiar base types (e.g.,
Nat or Bool) and terms (e.g., numeric constants and addition).
The least usual aspect of the formulation of F ω
×η is the use of the judgment
Γ ⊢⋄, which formalizes the notion of Γ being a well-formed context (see
TAPL, 30.3.18). A typing context is well-formed if all bound variables are dis-
tinct, and if each type within the context is well-formed with respect to the
preceding portion of the context. For convenience in working with the sys-
tem, all judgments are designed to require (directly or indirectly) that their
typing context be well-formed.
The evaluation rules for terms are standard and have been omitted.
9
Type Deﬁnitions

350
9
Type Deﬁnitions
F ω
×η
T
::=
types:
X
type variable
T→T
type of functions
T × T
type of pairs
∀X::K.T
universal type
λX::K.T
type operator abstraction
T T
type operator application
K
::=
kinds:
*
kind of proper types
K⇒K
kind of type operators
Context Validity
Γ ⊢⋄
· ⊢⋄
(CTX-Empty)
Γ ⊢T :: *
x ̸∈dom(Γ)
Γ, x:T ⊢⋄
(CTX-Type)
Γ ⊢⋄
X ̸∈dom(Γ)
Γ, X::K ⊢⋄
(CTX-Kind)
Kinding
Γ ⊢T :: K
X::K ∈Γ
Γ ⊢⋄
Γ ⊢X :: K
(K-Var)
Γ, X::K1 ⊢T2 :: K2
Γ ⊢λX::K1.T2 :: K1⇒K2
(K-Abs)
Γ ⊢T1 :: K11⇒K12
Γ ⊢T2 :: K11
Γ ⊢T1 T2 :: K12
(K-App)
Γ ⊢T1 :: *
Γ ⊢T2 :: *
Γ ⊢T1→T2 :: *
(K-Arrow)
Γ ⊢T1 :: *
Γ ⊢T2 :: *
Γ ⊢T1 × T2 :: *
(K-Times)
Γ, X::K1 ⊢T2 :: *
Γ ⊢∀X::K1.T2 :: *
(K-All)
Type Equivalence
Γ ⊢S ≡T :: K
Γ ⊢T :: K
Γ ⊢T ≡T :: K
(Q-Refl)
Γ ⊢T ≡S :: K
Γ ⊢S ≡T :: K
(Q-Sym)
Γ ⊢S ≡U :: K
Γ ⊢U ≡T :: K
Γ ⊢S ≡T :: K
(Q-Trans)
Γ ⊢S1 ≡T1 :: *
Γ ⊢S2 ≡T2 :: *
Γ ⊢S1 →S2 ≡T1 →T2 :: *
(Q-Arrow)
Γ ⊢S1 ≡T1 :: *
Γ ⊢S2 ≡T2 :: *
Γ ⊢S1 × S2 ≡T1 × T2 :: *
(Q-Times)
Γ, X::K1 ⊢S2 ≡T2 :: *
Γ ⊢∀X::K1.S2 ≡∀X::K1.T2 :: *
(Q-All)
Γ, X::K1 ⊢S2 ≡T2 :: K2
Γ ⊢λX::K1.S2 ≡λX::K1.T2 :: K1⇒K2
(Q-Abs)
Γ ⊢S1 ≡T1 :: K11⇒K12
Γ ⊢S2 ≡T2 :: K11
Γ ⊢S1 S2 ≡T1 T2 :: K12
(Q-App)
Γ, X::K11 ⊢S12 ≡T12 :: K12
Γ ⊢S2 ≡T2 :: K11
Γ ⊢(λX::K11.S12)S2 ≡[X , T2]T12 :: K12
(Q-Beta)
Γ, X::K1 ⊢S X ≡T X : K2
Γ ⊢S ≡T : K1→K2
(Q-Ext)
Figure 9-1: Types and kinds of F ω
×η

9.1
Deﬁnitions in the Typing Context
351
t
::=
terms:
x
variable
λx:T.t
abstraction
t t
application
λX::K.t
type abstraction
t [T]
type application
{t,t}
pair
t.1
ﬁrst projection
t.2
second projection
Typing
Γ ⊢t : T
x:T ∈Γ
Γ ⊢⋄
Γ ⊢x : T
(T-Var)
Γ, x:T1 ⊢t2 :: T2
Γ ⊢λx:T1.t2 :: T1→T2
(T-Abs)
Γ ⊢t1 : T11⇒T12
Γ ⊢t2 : T11
Γ ⊢t1 t2 : T12
(T-App)
Γ, X::K1 ⊢t2 : T2
Γ ⊢λX::K1.t2 : ∀X::K1.T2
(T-TAbs)
Γ ⊢t1 : ∀X::K11.T12
Γ ⊢T2 :: K11
Γ ⊢t1 [T2] : [X , T2]K12
(T-TApp)
Γ ⊢t1 : T1
Γ ⊢t2 : T2
Γ ⊢{t1,t2} : T1 × T2
(T-Pair)
Γ ⊢t1 : T11 × T12
Γ ⊢t1.1 : T11
(T-Proj1)
Γ ⊢t1 : T11 × T12
Γ ⊢t1.2 : T12
(T-Proj2)
Γ ⊢t : S
Γ ⊢S ≡T :: *
Γ ⊢t : T
(T-Eq)
Figure 9-2: Terms of F ω
×η
9.1
Deﬁnitions in the Typing Context
In a language with eager evaluation, side-eﬀects prevent us from eliminat-
ing term-level deﬁnitions by replacing variables by their deﬁnitions. As an
alternative, therefore, closed-scope term-level deﬁnitions are often treated as
derived forms involving applications, namely
let x=t1 in t2
def
= (λx:T1.t2) t1
where T1 is the type of t1. In languages with type operators a similar approach
can be used at the level of types, putting
let X=T1 in T2
def
= (λX::K1.T2) T1
where K1 is the kind of the type T1.
However, a type deﬁnition used within a term does not correspond to an
instantiation of a polymorphic abstraction as one might expect. Although
let X=Nat in (λx:X.x+1)(4)
is semantically reasonable, the polymorphic instantiation

352
9
Type Deﬁnitions
λlet
Extends F ω
×η
New syntactic forms
Γ
::=
. . .
contexts:
Γ, X::K=T
open-scope deﬁnition
t
::=
. . .
terms:
let X = T in t
closed-scope deﬁnition
Type Equivalence
Γ ⊢S ≡T :: K
X::K=T ∈Γ
Γ ⊢⋄
Γ ⊢X ≡T :: K
(Q-Def)
Context Validity
Γ ⊢⋄
Γ ⊢T :: K
X ̸∈dom(Γ)
Γ, X::K=T ⊢⋄
(CTX-Def)
Kinding
Γ ⊢T :: K
X::K=T ∈Γ
Γ ⊢⋄
Γ ⊢X :: K
(K-Def)
Typing Rules
Γ ⊢t : T
Γ ⊢T1 :: K1
Γ ⊢T2 :: *
Γ, X::K1=T1 ⊢t2 : T2
Γ ⊢let X=T1 in t2 : T2
(T-TLet)
Evaluation rules
t -→t′
let X=T in t -→[X , T]t
(E-TLet)
Figure 9-3: Adding deﬁnitions to the context
(λX::*. (λx:X.x+1)(4))[Nat]
is ill-typed because its sub-term λX::*. (λx:X.x+1)(4) is ill-typed.
We therefore extend F ω
×η by making deﬁnitions of type variables into a
primitive notion, resulting in the language λlet shown in Figure 9-3. The syn-
tax of contexts is broadened to permit deﬁned type variables, and the new
rule Q-Def equates type variables with their deﬁnitions. Equivalence of well-
formed types therefore depends upon deﬁnitions in the typing context. In
λlet we can prove
X::*=Int ⊢Int→X ≡X→Int :: *
but not
X::*=Bool ⊢Int→X ≡X→Int :: *
or
X::* ⊢Int→X ≡X→Int :: *.
This is an immediate diﬀerence from ordinary F ω
×η, where type equivalence
can be determined by looking only at the two types involved (in this case,
Int→X and X→Int, which are never equal in F ω
×η).
Context validity is extended by the rule CTX-Def, which requires that def-
initions make sense in the preceding context. Consequently, type deﬁnitions

9.1
Deﬁnitions in the Typing Context
353
⊢⋄
⊢Nat :: *
...
Γ, x:X ⊢x : X
...
Γ, x:X ⊢X ≡Nat
Γ, x:X ⊢x : Nat
...
Γ, x:X ⊢1 : Nat
Γ, x:X ⊢x+1 : Nat
Γ ⊢λx:X. x+1 : X→Nat
...
Γ ⊢4 : Nat
...
Γ ⊢X ≡Nat
Γ ⊢Nat ≡X
Γ ⊢4 : X
Γ ⊢(λx:X. x+1)(4) : Nat
⊢(let X=Nat in (λx:X. x+1)(4)) : Nat
Figure 9-4: Typing of let X=Nat in (λx:X.x+1)(4), using Γ
def
= X::*=Nat
in well-formed contexts are never circular, which will ensure that all deﬁni-
tions can in principle be substituted away.1
The new kinding rule K-Def looks up the kind of a deﬁned type variable,
paralleling the F ω
×η rule K-Var for type variables without deﬁnitions.
Deﬁnitions in the context are open-scope; they can be considered ambient
and usable anywhere. We can also use this mechanism to describe the typ-
ing of primitive closed-scope (local) type deﬁnitions; the type checking rule
T-TLet puts the deﬁnition into the context for use while type checking a spe-
ciﬁc term. Thus, for example, the code let X=Nat in (λx:X.x+1)(4) would
be well-typed in the presence of natural numbers and addition; a proof ap-
pears in Figure 9-4, where the omitted leaf proofs are uninteresting context-
validity checks.
The following propositions collect a number of useful properties of λlet.
They are all provable via induction on derivations.
9.1.1
Proposition [Weakening]:
1. If Γ1, Γ3 ⊢T :: K and Γ1, Γ2, Γ3 ⊢⋄then Γ1, Γ2, Γ3 ⊢T :: K.
2. If Γ1, Γ3 ⊢S ≡T :: K and Γ1, Γ2, Γ3 ⊢⋄then Γ1, Γ2, Γ2 ⊢S ≡T :: K.
2
1. The non-circularity requirement for context validity would not prevent T itself from being a
recursive type, as in the Nat and NatList examples, assuming recursive types were added to
the language.

354
9
Type Deﬁnitions
9.1.2
Proposition [Validity]:
1. If Γ ⊢J for any judgment form J then Γ ⊢⋄.
2. If Γ1, Γ2 ⊢⋄then Γ1 ⊢⋄and dom(Γ1) ∩dom(Γ2) = ∅.
3. If Γ ⊢T :: K then FV(T) ⊆dom(Γ).
4. If Γ ⊢S ≡T :: K then Γ ⊢S :: K and Γ ⊢T :: K.
2
9.1.3
Proposition [Substitution]:
1. If Γ1, X::K, Γ2 ⊢J for any judgment form J and Γ1 ⊢T :: K then Γ1, [X ,
T]Γ2 ⊢[X , T]J.
2. If Γ1, X::K=S, Γ2 ⊢J for any judgment form J and Γ1 ⊢S ≡T :: K then
Γ1, [X , T]Γ2 ⊢[X , T]J.
3. If Γ1, X::K, Γ2 ⊢S :: L and Γ1 ⊢T ≡T′ :: K then Γ1, [X , T]Γ2 ⊢[X , T]S ≡
[X , T′]S :: L.
2
9.1.4
Exercise [««, Recommended]: Explain why the type system would be un-
sound if the premise Γ ⊢T2 :: * were omitted from T-TLet.
2
9.1.5
Exercise [««, Recommended]: Suppose we wanted to add primitive type def-
initions to the simply-typed calculus λ→. What changes to that language would
be appropriate?
2
Deciding Equivalence
The hardest part of type checking in λlet, as in F ω, is deciding type equiva-
lence. There are multiple ways to approach this. For example, we could deﬁne
a notion of reduction (and/or parallel reduction) that allows beta-reduction
and allows a variable to be replaced by its deﬁnition, a step known as delta-
reduction.2
Such notions of reduction can be shown to be conﬂuent and
normalizing (Severi and Poll, 1994), which provides a method for determin-
ing type equivalence: compute normal forms and check for equality up to
bound variables.
2. Some authors (e.g., Barendregt, 1984) instead use the name delta-reduction to refer to the
slightly diﬀerent process of executing built-in primitive operators, e.g., replacing 3+4 by 7 in a
language where addition and integer constants are taken as primitive.

9.1
Deﬁnitions in the Typing Context
355
If explicit deﬁnitions are being used to keep the representation small, how-
ever, then computing normal forms can be an expensive way to determine
type equivalence. For example, if we had deﬁnitions such as
Pair
def
=
λY::*.(Y × Y)
List
def
=
λY::*. (µX. <nil:Unit, cons:{Nat,X}>)
we would like to be able to determine that List(List(Pair(Nat))) and
List(List(Nat × Nat)) are equivalent without expanding them to their com-
mon (but noticeably larger) normal form. Although for arbitrary types we
might not be able to do any better, in practice code reuses the same deﬁned
names and so simple short-circuiting heuristics can help.
One approach to avoiding explicit construction of normal forms involves
simultaneous reduction and comparison of the types using weak head reduc-
tion, as discussed in Chapter 6. Instead of fully normalizing the types, only
the “outermost” applications or deﬁnitions are reduced. If the resulting types
turn out to have the same shape, then corresponding sub-components of the
types can be recursively compared. Conversely, if the two types are weak
head normalized but fail to have the same structure then the types are not
equivalent and the algorithm can short-circuit and report inequivalence.
Figure 9-5 presents an algorithmic version of equivalence in this fashion.
The weak head normalization relation Γ ⊢T1 ⇓Tn speciﬁes that there is
a ﬁnite sequence of types T1, . . . , Tn with n ≥1 such that each weak head
reduces to the next, and such that Tn is weak head normal. Given Γ and S
there is at most one T such that Γ ⊢S ⇓T.
The algorithmic type equivalence judgment Γ ⊢S a T :: K holds if the
weak head normal forms of T1 and T2 are structurally equivalent; this is the
algorithmic equivalent to type equivalence for well-formed types. As in Chap-
ter 6, extensional equivalence is implemented here for types with arrow kinds
by applying both sides to a fresh variable and checking for equivalent results.
Finally, the structural equivalence judgment Γ ⊢T1 ↔T2 ↑K implements
equivalence for weak head-normal types only; T1 and T2 must have the same
shape and their subcomponents must be algorithmically equivalent. Then K
will be the common kind of T1 and T2. Given Γ, S, and T, there is at most one
rule that can apply.
Conveniently, the correctness of this comparison algorithm can be shown
using the same logical relations proof as in Chapter 6 with only minor modi-
ﬁcations. We here are interested in equivalence of types that are classiﬁed by
kinds, but this corresponds exactly to the problem considered in Chapter 6
of equivalence of terms classiﬁed by types. In particular, the kind * here cor-
responds to the base type b from Chapter 6. Rewriting the logical equivalence

356
9
Type Deﬁnitions
Weak Head Reduction
Γ ⊢▶T ; T′
Γ ⊢▶(λX::K11.T12)T2 ; [X , T2]T12
X::K=T ∈Γ
Γ ⊢▶X ; T
Γ ⊢▶T1 ; T′1
Γ ⊢▶T1 T2 ; T′1 T2
Weak head normalization
Γ ⊢▶T ⇓T′
Γ ⊢▶T ; S
Γ ⊢▶S ⇓T′
Γ ⊢▶T ⇓T′
Γ ⊢▶T ̸;
Γ ⊢▶T ⇓T
Algorithmic type equivalence
Γ ⊢▶S a T :: K
Γ ⊢▶S ⇓S′
Γ ⊢▶T ⇓T′
Γ ⊢▶S′ ↔T′ ↑*
Γ ⊢▶S a T :: *
Γ, X::K1 ⊢▶S X a T X :: K2
X ̸∈dom(Γ)
Γ ⊢▶S a T :: K1⇒K2
Structural type equivalence
Γ ⊢▶S ↔T ↑K
X::K ∈Γ
Γ ⊢▶X ↔X ↑K
Γ ⊢▶S1 a T1 ↑*
Γ ⊢▶S2 a T2 ↑*
Γ ⊢▶S1→S2 ↔T1→T2 ↑*
Γ ⊢▶S1 a T1 ↑*
Γ ⊢▶S2 a T2 ↑*
Γ ⊢▶S1 × S2 ↔T1 × T2 ↑*
Γ, X::K1 ⊢▶S2 a T2 ↑*
X ̸∈dom(Γ)
Γ ⊢▶∀X::K1.S2 ↔∀X::K1.T2 ↑*
Γ ⊢▶S1 ↔T1 ↑K1⇒K2
Γ ⊢▶S2 a T2 :: K1
Γ ⊢▶S1 S2 ↔T1 T2 ↑K2
Figure 9-5: Algorithmic equivalence with deﬁnitions
relation to refer to types and kinds (and simplifying it a bit, as we have no
“unit kind”) yields:
9.1.6
Definition [Logical Equivalence]: Logical equivalence is deﬁned as fol-
lows:
Γ ⊢S is T :: K if and only if either:
K=* and Γ ⊢S a T :: *,
or K=K1⇒K2 and for all S′, T′, and for all Γ ′ ⊇Γ,
if Γ ′ ⊢S′ is T′ :: K1
then Γ ′ ⊢S S′ is T T′ :: K2.
2
Similarly, γ or δ will now represent a substitutions mapping type variables
to types. Recall that γ[X , T] is the substitution that agrees with γ except
that it maps X to the type T.
The biggest diﬀerence from Chapter 6 is that we must be more careful
about substitutions. The proof of the Fundamental Theorem of Logical Rela-

9.1
Deﬁnitions in the Typing Context
357
tions will not go through if we allow substitutions that replace a deﬁned type
variable by an unrelated type. (Speciﬁcally, the Q-Def case would fail.) The
following deﬁnition builds in this restriction, while still being easy to show
symmetric and transitive:
9.1.7
Definition: Γ ′ ⊢γ is δ :: Γ if and only if
• For every X::K ∈Γ we have Γ ′ ⊢γ(X) is δ(X) :: K.
• For every X::K=T ∈Γ we have Γ ′ ⊢γ(X) is δ(X) :: K, Γ ′ ⊢γ(X) is
δ(T) :: K, and Γ ′ ⊢γ(T) is δ(X) :: K.
2
9.1.8
Exercise [«««, Recommended]: Show how to adapt the methods of Chap-
ter 6 to prove that if Γ ⊢S :: K and Γ ⊢T :: K then it is decidable whether
Γ ⊢S ≡T :: K in λlet.
2
A major advantage of this variant algorithm is that it allows further reﬁne-
ments. For example, an implementation might check for alpha-equivalence
of corresponding components before reducing. Thus, a request to compare
List(T1) with List(T2) could directly check whether T1 and T2 are equiva-
lent without expanding the deﬁnition of List.
One must be careful in trying to optimize, though, since the addition of
deﬁnitions alters usual properties of type equivalence. In F ω
×η the equivalence
X T1 ≡X T2 holds if and only if T1 ≡T2. In a λlet-style language, however, we
can prove
X::(*⇒*)=(λY::*.Nat) ⊢X Nat ≡X Bool
even though Nat and Bool are not equivalent—both applications are prov-
ably equal to Nat. Therefore, although comparing X T1 with X T2 by showing
that T1 and T2 are equivalent may often be faster than expanding out a def-
inition for X, if the arguments are inequivalent we may need to consider the
expansion anyway.3
One might think to special-case variables like X above whose deﬁnitions
completely ignore their arguments, but similar behavior can arise more gen-
erally.
9.1.9
Exercise [Recommended, ««]: Find a typing context and pairwise inequiva-
lent T1, T2, and T3 such that X T1 ≡X T2 but X T2 ̸≡X T3 (and so X cannot
completely ignore its argument).
2
3. The presence of deﬁnitions has consequences for uniﬁcation as well (e.g., in implementa-
tions of ML type inference): the most general substitution making X T1 and X T2 equal might
not make T1 and T2 unify.

358
9
Type Deﬁnitions
If the simultaneous comparison process ﬁnds no short-cuts, it will do work
equivalent to entirely normalizing and comparing the two types. It may still
be more memory-eﬃcient, however, than separate normalizations. Full nor-
mal forms are not explicitly computed and stored; when two subcomponents
of the types are found to be equal their reduced forms can be immediately
discarded, freeing up memory for the rest of the comparison.
9.1.10
Exercise [«««, 3]: Extend the fullomega checker to include deﬁnitions, and
make type equivalence checking as eﬃcient as possible.
2
9.2
Deﬁnitions in Module Interfaces
In the presence of modules, type deﬁnitions are often permitted to appear
within interfaces. The most interesting aspect of the theory of ML-style mod-
ule systems involves tracking information about the types involved, given
that type components in modules may have deﬁnitions that are not syntacti-
cally apparent.
One line of research in formalizing the type theory of ML-like module sys-
tems (as discussed in Chapter 8) led to the calculi known as translucent sums
(Harper and Lillibridge, 1994) and manifest types (Leroy, 1994). These similar
systems largely correspond to the module systems of Revised Standard ML
(Milner, Tofte, Harper, and MacQueen, 1997) and (with some extensions—see
Leroy [1995]) of Objective Caml.
The Language λL M
Figure 9-6 deﬁnes a minimalist language λL M with second-class modules, based
on the calculus of Lillibridge (1997). Modules are not ﬁrst-class values able
to be passed to term-level functions, and similarly interfaces are not types.
Though simpler than any module system usable in practice, λL M is still com-
plex enough to demonstrate many issues discussed in Chapter 8.
In ML, modules can contain any combination of named value, type, and
sub-module components in any order. λL M instead builds up modules starting
with two primitives: modules that contain a single unnamed term, written
LtM, and modules that contain a single unnamed type, written LT::KM. The
contents of primitive modules can be extracted by using the ! operator.
For each sort of module, there are corresponding interfaces. The interface
LTM classiﬁes primitive modules containing a value of type T, while the opaque
interface LKM classiﬁes modules containing a type of kind K. Modules contain-
ing types may also have a transparent interface LK=TM if they contain just the
type T (or a provably equivalent type) of kind K.

9.2
Deﬁnitions in Module Interfaces
359
λL M
extends F ω
×η
Syntax
Γ
::=
. . .
contexts:
m:I
module variable
W
::=
determinate modules:
m
variable
LvM
term module
LT::KM
type module
LW,WM
pairing
W.1
ﬁrst projection
W.2
second projection
λm:I.M
functor
Wv
::=
module values:
LvM
term module
LT::KM
type module
LWv,WvM
pairing
λm:I.M
functor
M
::=
modules:
W
determinates
LtM
term module
LM,MM
pairing
M.1
ﬁrst projection
M.2
second projection
M M
application
M :> I
generative sealing
I
::=
interfaces:
LTM
term interface
LKM
opaque interface
LK=TM
transparent interface
Σm:I.I
pair interface
Πm:I.I
functor interface
t
::=
. . .
terms:
!M
module projection
T
::=
. . .
types:
!W
module projection
Derived Forms
I1 × I2
def
= Σm:I1.I2
(m ̸∈FV(I2))
I1 →I2
def
= Πm:I1.I2
(m ̸∈FV(I2))
Context Validity
Γ ⊢⋄
Γ ⊢I
m ̸∈dom(Γ)
Γ, m:I ⊢⋄
(CTX-Mod)
Well-Formed Interface
Γ ⊢I
Γ ⊢T :: *
Γ ⊢LTM
(I-Term)
Γ ⊢⋄
Γ ⊢LKM
(I-Opaque)
Γ ⊢T :: K
Γ ⊢LK=TM
(I-Transp)
Γ, m:I1 ⊢I2
Γ ⊢Σm:I1.I2
(I-Sigma)
Γ, m:I1 ⊢I2
Γ ⊢Πm:I1.I2
(I-Pi)
Subinterface
Γ ⊢I <: I′
Γ ⊢T ≡T′ :: *
Γ ⊢LTM <: LT′M
(SI-Term)
Γ ⊢LKM <: LKM
(SI-Opaque)
Γ ⊢T ≡T′ :: K
Γ ⊢LK=TM <: LK=T′M
(SI-Transp)
Γ ⊢T :: K
Γ ⊢LK=TM <: LKM
(SI-Forget)
Figure 9-6: Syntax, typing, and semantics for λL M

360
9
Type Deﬁnitions
Subinterface (continued)
Γ ⊢I <: I′
Γ ⊢Πm:I11.I12
Γ ⊢I21 ≡I11
Γ, m:I21 ⊢I12 <: I22
Γ ⊢Πm:I11.I12 <: Πm:I21.I22
(SI-Pi)
Γ ⊢Σm:I21.I22
Γ ⊢I11 <: I21
Γ, m:I11 ⊢I12 <: I22
Γ ⊢Σm:I11.I12 <: Σm:I21.I22
(SI-Sigma)
Interface Equivalence
Γ ⊢I <: I′
Γ ⊢I <: I′
Γ ⊢I′ <: I
Γ ⊢I ≡I′
(QI-Eqv)
Kinding
Γ ⊢T :: K
Γ ⊢W : LKM
Γ ⊢!W :: K
(K-MProj)
Type Equivalence
Γ ⊢S ≡T :: K
Γ ⊢T :: K
Γ ⊢W : LK=TM
Γ ⊢!W ≡T :: K
(Q-MProj)
Well-Formed Modules
Γ ⊢M : I
Γ ⊢t : T
Γ ⊢LtM : LTM
(M-Term)
Γ ⊢T :: K
Γ ⊢LT::KM : LK=TM
(M-Type)
Γ ⊢M : I′
Γ ⊢I′ <: I
Γ ⊢M : I
(M-Sub)
Γ ⊢⋄
m:I ∈Γ
Γ ⊢m : I
(M-Var)
Γ, m:I1 ⊢M2 : I2
Γ ⊢λm:I1.M2 : Πm:I1.I2
(M-Abs)
Γ ⊢M1 : I1
Γ ⊢M2 : I2
Γ ⊢LM1,M2M : I1 × I2
(M-Pair)
Γ ⊢M : Σm:I1.I2
Γ ⊢M.1 : I1
(M-Fst)
Γ ⊢M : I1 × I2
Γ ⊢M.2 : I2
(M-Snd)
Γ ⊢M1 : I1→I2
Γ ⊢M2 : I1
Γ ⊢M1 M2 : I2
(M-Apply)
Γ ⊢W : LKM
Γ ⊢W : LK=!WM
(M-Self)
Γ ⊢Σm:I1.I2
Γ ⊢W : Σm:I′1.I2
Γ ⊢W.1 : II
Γ ⊢W : Σm:I1.I2
(M-Self1)
Γ ⊢W : Σm:I1.I′2
Γ ⊢W.2 : I2
Γ ⊢W : I1 × I2
(M-Self2)
Γ ⊢M : I
Γ ⊢(M :> I) : I
(M-Seal)
Typing
Γ ⊢t : T
Γ ⊢M : LTM
Γ ⊢!M : T
(T-Mod-Proj)
Figure 9-6: Syntax, typing, and semantics for λL M, continued

9.2
Deﬁnitions in Module Interfaces
361
Module Evaluation
M -→M′
t -→t′
LtM -→Lt′M
(EM-Term)
M1 -→M1′
LM1,M2M -→LM′1,M2M
(EM-Pair1)
M2 -→M2′
LWv 1,M2M -→LWv 1,M2M
(EM-Pair2)
M1 -→M1′
M1.1 -→M′
1.1
(EM-Proj1)
M1 -→M1′
M1.2 -→M′
1.2
(EM-Proj2)
LWv1,Wv2M.1 -→Wv 1
(EM-PairBeta1)
LWv 1,Wv2M.2 -→Wv 2
(EM-PairBeta2)
M1 :> I2 -→M1
(EM-Seal)
M1 -→M′1
M1 M2 -→M′1 M2
(EM-App1)
M2 -→M′2
Wv M2 -→Wv M′2
(EM-App2)
(λm:I11.M12)Wv2 -→[s , Wv2]M12
(EM-AppAbs)
Term Evaluation
t -→t′
M -→M′
!M -→!M′
(E-MProj)
!LvM -→v
(E-MProjV)
Figure 9-6: Syntax, typing, and semantics for λL M, continued
More complex modules can be created by using the module-level pairing
operator L · , · M. The projection operators .1 and .2 then access the sub-
modules within such a pair.
Interfaces of module-pairs are given by specifying the interfaces of the
two submodules. However, in order to permit speciﬁcations such as “a mod-
ule containing an abstract type and a term of that type,” these interfaces
are allowed to be dependent. The interface Σm:I1.I2 classiﬁes module pairs
whose ﬁrst component satisﬁes the interface I1 and whose second compo-
nent satisﬁes I2, where the latter interface may refer to the contents of the
ﬁrst component by the name m. (In the vocabulary of Chapter 8, m is an in-
ternal name for the ﬁrst component of the module pair, while the external
names of the two components are always 1 and 2.)
For example, consider again the module n, deﬁned by
module n = mod
type t = Nat
val
x : t = 3
end
This is in essence a module containing a single type and a single term, and
hence can be encoded into λL M as
L LNat::*M, L3M M.

362
9
Type Deﬁnitions
This module satisﬁes the very precise interface
Σm:L*=NatM. LNatM,
which describes it as containing the type Nat and a natural number. This
interface is completely equivalent to
Σm:L*=NatM. L!mM,
which is an interface satisﬁed by modules containing the type Nat and a value
of that same type.
The encoding of n further matches the strictly more abstract (less informa-
tive) interface
Σm:L*M. L!mM
specifying only that the module contains some type and a value of that type.
Parameterized modules, or functors, are simply module-level functions.
Thus, for example, the diag functor deﬁned above can be encoded as
λm:(Σm’:L*M. L!m’M).
L L!m.1 × !m.1::*M, L{!m.2,!m.2}M M
The argument of this functor is required to be a module pair containing a
type and a value of that type (in sub-modules); it then returns a module pair
containing a pair type and a pair value (in sub-modules). By convention, ﬁrst
and second projections bind most tightly, followed by applications, !, and
ﬁnally the binary operators such as × . Thus the type being returned by this
functor is (!(m.1)) × (!(m.1)).
Interfaces for functors are also dependent, because the types in the func-
tor’s result may depend upon the types contained in the functor’s argument
value. The interface Πm:I1.I2 classiﬁes functors that require an argument
satisfying I1 and which return a result satisfying I2, where I2 can involve the
argument value m. Thus, one possible most-precise interface describing the
encoded diag functor would be
Πm:(Σm’:L*M. L!m’M).
(Σm”:L*=!m.1 × !m.1M. L!m”M).
In both Σm:I1.I2 and Πm:I1.I2 the variable m is bound in I2. In those
cases where m does not appear in I2 we can omit mention of the dependent
variable, writing non-dependent pair interfaces as I1 × I2, and non-dependent
functor interfaces as I1→I2.
The remaining module expression is the sealing operation M :> I. This is
the generative sealing operation of Chapter 8, taking a module M and hiding

9.2
Deﬁnitions in Module Interfaces
363
all information about that module except what is explicitly mentioned in the
interface I. This is used for information-hiding purposes, in order to create
abstract (opaque) types.
The syntax separates out a syntactic set of modules which are determinate
(have type components that are predictable at compile-time) in the termi-
nology of Chapter 8. Only determinate modules are allowed in types. Some
non-values (e.g., L LNat::*M, LBool::*M M.1) are syntactically determinate and
so can appear within types. This design results from the fact that we must
allow module projections such as !m.1 within types, yet it is desirable for the
syntax of types to be closed under replacements of variables by values (e.g.,
replacing m by L LNat::*M, LBool::*M M).4
Typing and Evaluation Rules
The static semantics of λL M appears in Figure 9-6. The judgment Γ ⊢I deﬁnes
the well-formedness of interfaces, which requires all types in the interface
to be well-formed. More interesting is the subinterface relation Γ ⊢I <: I′,
which is nontrivial even though λL M has no subtyping relation. The key rule
here is SI-Forget, which speciﬁes that a module with a transparent interface
can be used as if it had the corresponding opaque interface; type deﬁnitions
in interfaces may be neglected when not relevant. Subtyping for other base
interfaces coincides with equivalence. For simplicity SI-Pi speciﬁes that inter-
faces for functors are invariant in their domain (contravariance would be a
reasonable alternative), but otherwise the dependent interfaces are covariant.
9.2.1
Exercise [«]: Find a syntactically diﬀerent (but equivalent) precise interface
for the diag functor above, and a strictly less-precise interface also satisﬁed
by diag.
2
9.2.2
Exercise [«, Recommended]: The language λL M has a sub-interface relation,
but no subtyping. Suppose we added this, e.g., with Nat <: Top. How should
the interfaces LNatM and LTopM be related? How about L*=NatM and L*=TopM? 2
Interface equivalence could be deﬁned directly, but it is shorter as in rule
QI-Eqv to deﬁne equivalent interfaces as being mutual subinterfaces.
λL M adds the single kinding rule K-MProj, stating that we can project from
a syntactically determinate module W to obtain a type as long as W is a module
whose interface guarantees that it contains a type. In this rule we need only
4. An alternative is to redeﬁne substitution so that it reduces any new projections-from-pair-
values introduced (Lillibridge, 1997).

364
9
Type Deﬁnitions
check that W has an opaque interface of the form LKM because by subsumption
and SI-Forget, any module with a transparent interface also has an opaque
interface.
Type equivalence is extended as in λlet, but the new rule Q-MProj looks
for type deﬁnitions that occur in transparent interfaces rather than for type
deﬁnitions directly in the context.
The rules M-Term and M-Type give precise interfaces to the two sorts of
primitive modules; transparent interfaces can be weakened by subsumption
as speciﬁed in M-Sub.
The rules M-Var through M-Apply are similar to those in other systems
with dependent types. The only surprise might be the requirement of non-
dependent interfaces in the rules M-Snd and M-Apply. In many systems appli-
cations of (or projections from) items whose classiﬁer has dependencies can
be handled using substitution, but substitution of general modules may lead
to ill-formed types, as only syntactically determinate modules may appear in
types.
The rule M-Self is justiﬁed by the following observation: assume a determi-
nate module W satisﬁes the interface LKM. Now consider the interface LK=!WM;
this is the interface of a module containing a single type, speciﬁcally the type
contained in W. Clearly W itself satisﬁes this description and hence ought to
have this latter interface. M-Self ensures that this is always provable. The
rules M-Self1 and M-Self2 are similar, and allow the M-Self rule to be ap-
plied to submodules of a larger module. For example, by using all three rules
we can conclude
m : L*M × L*M ⊢m : L*=!m.1M × L*=!m.2M,
i.e., that if m is a module containing two types, then it satisﬁes an interface
requiring a pair containing the two types in m.
In the presence of the Self rules, the more usual dependent typing rules
are admissible for determinate modules (Lillibridge, 1997):
Γ ⊢W : Σm:I1.I2
Γ ⊢W.2 : [m , W.1]I2
(M-SndW)
Γ ⊢M1 : Πm:I1.I2
Γ ⊢W2 : I1
Γ ⊢M1 W2 : [m , W2]I2
(M-ApplyW)
For example, suppose that we had M1 : Πm:L*M. L*=!m × !mM and W2 : L*M.
The interface of if M1 is dependent so we cannot directly use M-Apply to
type check the application M1 W2, but we can show, using SI-Pi, SI-Forget,
SI-Opaque, and M-Sub, that M1 satisﬁes the strictly less precise interface

9.2
Deﬁnitions in Module Interfaces
365
Πm:L*=!W2M. L*=!m × !mM and hence that M1 satisﬁes the equivalent interface
Πm:L*=!W2M. L*=!W2 × !W2M, i.e., we have that M1 : L*=!W2M →L*=!W2 × !W2M.
Now by M-Self we have W2 : L*=!W2M, so the premises of M-Apply are satisﬁed
and we obtain M1 W2 : L*=!W2 × !W2M, exactly as the admissible rule M-ApplyW
predicts.
Finally, the M-Seal rule is an explicit form of subsumption hiding all infor-
mation not mentioned in the speciﬁed interface. The module
LLNat::*M,L3MM
has the very precise interface L*=NatM × LNatM, allowing the contents of its
second projection to be used as a natural number. In contrast, the sealed
module
LLNat::*M,L3MM
:>
Σm′:L*M.L!m′M
must be checked as having only the more abstract interface Σm′:L*M.L!m′M.
This enforces abstraction; we know that we could change this line to
LLBool::*M,LtrueMM
:>
Σm′:L*M.L!m′M
and any code using the module would continue to type check.
The evaluation relation for modules looks very much like the evaluation
relation for any lambda calculus with pairs. The one completely new rule
is EM-Seal. This sealing operation is generative and aﬀects type checking
by mimicking the creation of a fresh abstract type whenever the sealing op-
eration is performed, but once we have checked that abstraction is being
respected we can ignore the sealing; when the program begins running it has
no observable eﬀect.
Type Equivalence and Type Checking
The translucent sums calculus suﬀers from the avoidance problem discussed
in Chapter 8, and hence fails to have most-speciﬁc interfaces.
9.2.3
Exercise [«««]: Find a λL M module that (even up to equivalence) does not
have a most-precise interface.
2
This makes type checking diﬃcult, though in practice programs can often be
restricted to subsets guaranteed to have principal interfaces. Leroy (1996),
for example, considers modules restricted to named form where every subex-
pression has a name. Thus, instead of writing
(λm::L*M. m) ( LLNat::*M, LBool::*MM.2 )

366
9
Type Deﬁnitions
Natural interface
Γ ⊢▶W ↑I
m:I ∈Γ
Γ ⊢▶m ↑I
Γ ⊢▶LT::KM ↑LK=TM
Γ ⊢▶W1 ↑Σm:I1.I2
Γ ⊢▶W1.1 ↑I1
Γ ⊢▶W1 ↑Σm:I1.I2
Γ ⊢▶W1.2 ↑[m , W1.1]I1
Weak head reduction
Γ ⊢▶T ; T′
Γ ⊢▶!W ↑LK=TM
Γ ⊢▶!W ; T
Γ ⊢▶!(LW1,W2M.1) ; !W1
Γ ⊢▶!(LW1,W2M.2) ; !W2
Γ ⊢▶(λX::K11.T12)T2 ; [X , T2]T12
Γ ⊢▶T1 ; T′1
Γ ⊢▶T1 T2 ; T′1 T2
Figure 9-7: Algorithmic equivalence for λL M
we must assign names to all intermediate module computations, e.g.:
let m1 = λm::L*M. m
in let m2 =
LNat::*M
in let m3 = LBool::*M
in let m4 = Lm2, m3M
in let m5 = m4.2
in let m = m1 m5
in ...
Given these restrictions, every module has a most-speciﬁc interface.
Even in the absence of most-speciﬁc interface, however, type equivalence
remains decidable. A similar comparison algorithm to that for λlet will work,
except that now it is module projections of the form !W that may have deﬁni-
tions. For example, if m : L*M × L*=NatM then !m.2 is known to be equivalent
to Nat.
When does !W have a deﬁnition? A necessary, though not suﬃcient, con-
dition is that W have a transparent interface. For example, starting from the
bare assumptions that m1 : L*M and m2 : L*=!m1M (which would be the case
if m1 were a module containing an abstract type, and m2 were deﬁned as be-
ing m1), then intuitively !m2 has as its deﬁnition the abstract type !m1, while
!m1 itself has no deﬁnition. Using M-Self, though, we can further show that
m1 : L*=!m1M. For the purposes of an algorithm, it is not useful to say that !m1
has itself as a deﬁnition.
In general, the M-Self rule allows more equations to be added to the inter-
faces of determinate modules, but never introduces any “new” information.
It therefore is irrelevant when trying to detect deﬁnitions, and this leads to
the notion of the natural interface of a module. The natural interface is the

9.3
Singleton Kinds
367
most-precise interface that can be computed without using the rule M-Self.
We say that the type !W has the deﬁnition T if its natural interface is a trans-
parent interface LK=TM. Figure 9-7 deﬁnes an algorithmic judgment Γ ⊢▶W ↑I
for computing the natural interface I given Γ and W. Figure 9-7 then extends
weak head reduction to reduce type projections from determinate modules.
Algorithmic and structural type equivalence are not shown, as they are
very similar to the deﬁnition for λlet; the only diﬀerence would be that struc-
tural type equivalence must be extended to equate !W (where !W is weak head
normal) with itself.
9.2.4
Exercise [«, 3]: Verify that according to the deﬁnition of weak head reduc-
tion shown in Figure 9-7 we have m : (Σm′:L*M.L*=!m′M) ⊢▶!m.2 ⇓!m.1.
2
Proofs of properties of module languages such as λL M can quickly become
diﬃcult, however, because the type equivalence relation now is deﬁned in
terms of all the other judgments of the static semantics, including well-
formedness of modules (via Q-MProj) and hence on well-formedness of terms.
However, soundness and decidability results have been shown for systems
closely related to λL M(Lillibridge, 1997; Dreyer, Crary, and Harper, 2003).
9.3
Singleton Kinds
In λlet, deﬁnitions were recorded with a new sort of context entry. Instead
of just listing the kinds of type variables, contexts could additionally specify
deﬁnitions. Deﬁnitions in λL M were similar, but the choice between kind and
kind-with-deﬁnition was in module interfaces.
In general, wherever a language normally requires a kind, we could allow
either the kind or the kind and a speciﬁc type. For example, we could extend
F ω
×η with a new sort of polymorphic abstraction, written, λX::K1=T1.t2, that
is allowed to be instantiated only with the argument T1 (or an equivalent
type).
With this mechanism, we could now express type deﬁnitions in terms of
polymorphic instantiation. The derived form becomes
let X=T1 in t2
def
= (λX::K1=T1.t2) [T1]
where K1 is the kind of T1. The constraint on the function argument—namely
that the value passed in for X will be T1—is enough to type check the function
body. This deﬁnition repeats the type T1, but the result still can be signiﬁ-
cantly smaller than [X , T1]t2.
Minamide, Morrisett, and Harper (1996) used this idea for the purposes of
polymorphic closure conversion. The goal was to turn both free term vari-
ables and free type variables of functions into arguments; this was useful in

368
9
Type Deﬁnitions
the context of a type-passing interpretation of polymorphism (Tarditi et al.,
1996) where types are computed and analyzed at run time. By using restricted
polymorphic abstractions, they were able to preserve well-formedness when
pulling types out of function bodies.
The cases where this sort of construct is genuinely useful are probably rare,
but rather than trying to predict exactly where deﬁnitions will and will not
be needed, the more general approach is to permit deﬁnitions at all points
where type variables appear. One natural formulation of this idea augments
the kinds themselves to include deﬁnitions.
The singleton kind S(T::K) classiﬁes exactly those types of kind K provably
equivalent to T. For example, the kind S(int × int :: *) classiﬁes all types
that are provably equivalent to the type of pairs of integers; up to equiva-
lence there is exactly one such type. Then instead of choosing between a kind
speciﬁcation Y::* or a kind-and-deﬁnition speciﬁcation Y::*=Nat, we specify
either Y::* or Y::S(Nat :: *).
Figure 9-8 deﬁnes λS, an alternate variant of F ω
×η including singleton kinds.
Because the changes are pervasive, the type and kind judgments are shown
in full rather than just listing additions to F ω
×η.
The built-in singleton kinds in λS are of the form S(T) where T is restricted
to be an ordinary type of kind *. We will show later, however, that more
general singleton kinds of the form S(T::K) are nevertheless expressible.
The types of λS include ordinary types, type operators, and (to permit ex-
pressiveness similar to that of λL M) pairs of types. The addition of singletons
allows kinds to refer to types, and thus it is natural to permit the kinds clas-
sifying type operators or pairs of types to be dependent. The kind ΣX::K1.K2
classiﬁes pairs whose ﬁrst component has kind K1 and second component
has kind K2, where K2 can use the type variable X to refer to the value of the
ﬁrst component. In the case where K2 does not mention X, we can abbrevi-
ate this to K1 × K2. Thus, for example, we give the pair of types (a collection
of two types, not the single type for a pair of values) {Nat,Nat} the kind
* × * stating simply that it is a pair of types, or give it the very precise kind
S(Nat) × S(Nat), i.e., that we have a pair of types whose components are
both equal to Nat, or an in-between kind such as ΣX::*. S(X), i.e., that we
have a pair of types whose ﬁrst component has kind *, and whose second
component is the same as the ﬁrst, or S(Nat) × *, i.e., that the ﬁrst type is
Nat and the second is some proper type, and so on.
Similarly, the kind ΠX::K1.K2 classiﬁes type operators that take an argu-
ment X of kind K1 and return a result of kind K2, where K2 can depend on the
argument X. If K2 does not mention X then the kind can be written K1⇒K2.
Thus, possible kinds for the identity function λX::*.X on types will include
the familiar *⇒* as well as the very precise kind ΠX::*. S(X), stating that,

9.3
Singleton Kinds
369
λS
extends F ω
×η
Syntax
K
::=
kinds:
*
kind of proper types
S(T)
singleton kind
ΠX::K.K
kind of type operators
ΣX::K.K
kind of pairs of types
T
::=
types:
X
type variable
T→T
type of functions
T × T
type of pairs of terms
∀X::K.T
universal type
λX::K.T
type operator abstraction
T T
type operator application
{T,T}
pair of types
π1 T
ﬁrst projection
π2 T
second projection
Derived Forms
K1 × K2
def
= ΣX::K1.K2
(X ̸∈FV(K2))
K1 ⇒K2
def
= ΠX::K1.K2
(X ̸∈FV(K2))
Kind validity
Γ ⊢K
Γ ⊢⋄
Γ ⊢*
(WK-*)
Γ ⊢T :: *
Γ ⊢S(T)
(WK-Sing)
Γ, X::K1 ⊢K2
Γ ⊢ΠX::K1.K2
(WK-Pi)
Γ, X::K1 ⊢K2
Γ ⊢ΣX::K1.K2
(WK-Sigma)
Subkinding
Γ ⊢K <: L
Γ ⊢⋄
Γ ⊢* <: *
(SK-*)
Γ ⊢S ≡T :: *
Γ ⊢S(S) <: S(T)
(SK-Sing)
Γ ⊢T :: *
Γ ⊢S(T) <: *
(SK-Forget)
Γ ⊢L1 <: K1
Γ, X::L1 ⊢K2 <: L2
Γ ⊢ΠX::K1.K2
Γ ⊢ΠX::K1.K2 <: ΠX::L1.L2
(SK-Pi)
Γ ⊢K1 <: L1
Γ, X::K1 ⊢K2 <: L2
Γ ⊢ΣX::L1.L2
Γ ⊢ΣX::K1.K2 <: ΣX::L1.L2
(SK-Sigma)
Kind Equivalence
Γ ⊢K ≡L
Γ ⊢K <: L
Γ ⊢L <: K
Γ ⊢K ≡L
(QK-Eqv)
Kinding rules
Γ ⊢T :: K
X::K ∈Γ
Γ ⊢⋄
Γ ⊢X :: K
(K-Var)
Γ ⊢T :: *
Γ ⊢T :: S(T)
(K-SIntro)
Γ, X::K1 ⊢T2 :: K2
Γ ⊢λX::K1.T2 :: ΠX::K1.K2
(K-Abs)
Γ ⊢T1 :: ΠX::K1.K2
Γ ⊢T2 :: K1
Γ ⊢T1 T2 :: [X , T2]K2
(K-App)
Figure 9-8: Singleton kinds

370
9
Type Deﬁnitions
Kinding rules (continued)
Γ ⊢T :: K
Γ ⊢T1 :: *
Γ ⊢T2 :: *
Γ ⊢T1→T2 :: *
(K-Arrow)
Γ ⊢T1 :: *
Γ ⊢T2 :: *
Γ ⊢T1 × T2 :: *
(K-Times)
Γ, X::K1 ⊢T2 :: *
Γ ⊢∀X::K1.T2 :: *
(K-All)
Γ ⊢ΣX::K1.K2
Γ ⊢T1 :: K1
Γ ⊢T2 :: [X , T1]K2
Γ ⊢{T1,T2} :: ΣX::K1.K2
(K-Pair)
Γ ⊢T :: ΣX::K1.K2
Γ ⊢π 1 T :: K1
(K-Fst)
Γ ⊢T :: ΣX::K1.K2
Γ ⊢π2 T :: [X , π1 T]K2
(K-Snd)
Γ ⊢T :: ΠX::K1.L
Γ, X :: K1 ⊢T(X) :: K2
X ̸∈FV(T)
Γ ⊢T :: ΠX::K1.K2
(K-AbsSelf)
Γ ⊢T :: ΣX::K′1.K2
Γ ⊢π1 T :: K1
Γ ⊢T :: ΣX::K1.K2
(K-Self1)
Γ ⊢T :: ΣX::K1.K′2
Γ ⊢π2 T :: K2
Γ ⊢T :: K1 × K2
(K-Self2)
Γ ⊢T :: K1
Γ ⊢K1 <: K2
Γ ⊢T :: K2
(K-Sub)
Equivalence rules
Γ ⊢S ≡T :: K
Γ ⊢T :: K
Γ ⊢T ≡T :: K
(Q-Refl)
Γ ⊢T ≡S :: K
Γ ⊢S ≡T :: K
(Q-Sym)
Γ ⊢S ≡U :: K
Γ ⊢U ≡T :: K
Γ ⊢S ≡T :: K
(Q-Trans)
Γ ⊢S1 ≡T1 :: ΠX::K1.K2
Γ ⊢S2 ≡T2 :: K1
Γ ⊢S1 S2 ≡T1 T2 :: [X , S1]K2
(Q-App)
Γ ⊢S ≡T :: ΣX::K1.K2
Γ ⊢π1 S ≡π1 T :: K1
(Q-Fst)
Γ ⊢S ≡T :: ΣX::K1.K2
Γ ⊢π 2 S ≡π2 T :: [X , π1 S]K2
(Q-Snd)
Γ ⊢ΣX::K1.K2
Γ ⊢S1 ≡T1 :: K1
Γ ⊢S2 ≡T2 :: [X , S1]K2
Γ ⊢{S1,S2} ≡{T1,T2} :: ΣX::K1.K2
(Q-Pair)
Γ ⊢K1 ≡K2
Γ, X :: K1 ⊢S2 ≡T2 :: K2
Γ ⊢λX::K1.S2 ≡λX::K2.T2 :: ΠX::K1.K2
(Q-Abs)
Γ ⊢K1 ≡K2
Γ, X :: K1 ⊢T1 ≡T2 :: *
Γ ⊢∀X::K1.T1 ≡∀X::K2.T2 :: *
(Q-All)
Γ ⊢S :: S(T)
Γ ⊢S ≡T :: S(S)
(Q-SElim)
Γ ⊢ΣX::K1.K2
Γ ⊢π1S ≡π1T :: K1
Γ ⊢π2S ≡π2T :: [X , π 1 S]K2
Γ ⊢S ≡T :: ΣX::K1.K2
(Q-Pair-Ext)
Γ ⊢S :: ΠX::K1.L1
Γ ⊢T :: ΠX::K1.L2
Γ, X :: K1 ⊢S X ≡T X :: K2
Γ ⊢S ≡T :: ΠX::K1.K2
(Q-Ext)
Γ ⊢S ≡T :: L
Γ ⊢L <: K
Γ ⊢S ≡T :: K
(Q-Sub)
Figure 9-8: Singleton kinds, continued

9.3
Singleton Kinds
371
given any type X of kind *, the function returns a result equal to X. There are
inﬁnitely many other possibilities as well, including S(Nat)⇒S(Nat), which
states that the function can be applied to the type Nat and will return the
same type Nat.
Every type of kind S(T) is, by the deﬁnition of λS, also a proper type of
kind *. This induces a subkinding relation with S(T) <: * for any type T. Sub-
kinding between singleton kinds coincides with equivalence, and subkinding
is lifted to the kinds of functions and of pairs in the normal way; e.g., function
kinds are contravariant in their argument and covariant in their result.
9.3.1
Exercise [«]: The language λS has subkinding but not subtyping. If subtyp-
ing were added, with Nat <: Top, then how should the kinds S(Nat) and
S(Top) be related?
2
The well-formedness rules for types are mostly the familiar rules for a
dependently-typed (or, in this case, dependently-kinded) lambda calculus with
functions and pairs. Five rules stand out for special consideration, however.
Rule K-Sub is a subsumption rule that makes use of the subkinding rule; a
type with a more-precise kind can also be used as a type with a less-precise
kind. Rule K-SIntro is the introduction rule for singleton kinds. This rule al-
lows a well-formed type T of kind * to be given the more precise singleton
kind S(T).
Rules K-Self1 and K-Self2 serve the same purpose as M-Self1 and M-Self2
in the translucent sum calculus, while K-AbsSelf serves a similar purpose
for kinds of type operator abstractions. In most type systems all three rules
would be admissible, but here they allow more precise typings. For exam-
ple, suppose Y is a pair of types, that is, Y::* × *. Now consider the kind
S(π1 Y) × S(π2 Y), i.e., the kind of pairs of types whose ﬁrst component is
equal to the ﬁrst component of Y, and whose second component is equal
to the second component of Y. Regardless of whether the language includes
eta-equivalence for types (λS does), Y itself should satisfy this latter kind.
Rules K-Self1 and K-SIntro allow us to conclude that Y : S(π1 Y) × *, and
then K-Self2 and K-SIntro allow us to further prove Y : S(π1 Y) × S(π2 Y).
Similarly, assume Z :: *⇒*. The kind ΠX::*. S(Z X) classiﬁes all type op-
erators that, when given a type argument X, yield the same result as Z does
when given X. Again, Z itself has this property and rule K-AbsSelf is used to
prove it.
Collectively, the three Self rules ensure that types have every kind that
their eta-expansions do.
Rules Q-Refl through Q-All are standard for a lambda calculus with de-
pendencies; they insure that deﬁnitional equivalence is a congruence on well-
formed types. Rule Q-SElim is the elimination rule for singleton kinds, letting

372
9
Type Deﬁnitions
us make use of the fact that a type has a singleton kind. Rules Q-Pair-Ext
and Q-Ext yield extensionality: componentwise-equivalent pairs are equiv-
alent and pointwise-equivalent functions are equivalent. Finally, we have a
subsumption rule for equivalence, Q-Sub, corresponding to the subsumption
rule for typing.
The addition of singleton kinds has more consequences for equivalence
than might appear at ﬁrst. An attentive reader may have noticed that the
deﬁnition of type equivalence omits the beta-reduction rule for function ap-
plications and the two standard rules for reducing projections from pairs. A
surprising fact about languages with singletons, noticed by Aspinall (1994),
is that other elimination rules can become admissible (i.e., if the premises are
provable using the above rules then so is the conclusion):
Γ ⊢T1 :: K1
Γ ⊢T2 :: K2
Γ ⊢π1 {T1,T2} ≡T1 :: K1
(Q-Beta-Fst)
Γ ⊢T1 :: K1
Γ ⊢T2 :: K2
Γ ⊢π2 {T1,T2} ≡T2 :: K2
(Q-Beta-Snd)
Γ, X::K1 ⊢T12 :: K12
Γ ⊢T2 :: K12
Γ ⊢(λX::K11.T12)T2 ≡[X , T2]T12 :: [X , T2]K12
(Q-AppAbs)
More importantly (since we would have added beta-equivalence had it not
been admissible), the kind at which two types are compared can determine
whether or not they are equivalent. Types do not have unique kinds, and a
pair of types can be equivalent at one kind but not another.
For example, consider the identity function on types, λX::*.X, and the
constant function λX::*.Nat. There is no way to prove the judgment
(λX::*.X) ≡(λX::*.Nat) :: (*⇒*).
However, by subsumption both functions also have the kind S(Nat)⇒*, and
at this kind we can prove
⊢(λX::*.X) ≡(λX::*.Nat) :: (S(Nat)⇒*).
Viewed as functions that will only be applied to the argument Nat, the two
functions do return the same result Nat. By extensionality, then, the two func-
tions are equivalent at kind S(Nat)⇒*.
Using this result and Rule Q-App we can further show that
Y :: (S(Nat)⇒*)⇒* ⊢Y(λX::*.X) ≡Y(λX::*.Nat) :: *.
In this equivalence judgment, both sides are normal with respect to beta and
eta-reduction. Y itself has no obvious deﬁnition that can be expanded away.
Nevertheless, equivalence remains decidable; one algorithm appears below.

9.3
Singleton Kinds
373
S(T :: *)
def
=
S(T)
S(T :: S(T′))
def
=
S(T)
S(T :: ΠX::K1.K2)
def
=
ΠX::K1.S(T X :: K2)
where X ̸∈FV(T)
S(T :: ΣX::K1.K2)
def
=
S(π1 T :: K1) × S(π2 T :: [X , π1 T]K2)
Figure 9-9: Labeled singleton kinds
Singletons at Higher Kinds
In λlet the context could contain deﬁnitions for type operators, for example
Y :: (*⇒*) = (λX::*.X→X). We cannot directly represent this deﬁnition as
Y :: S(λX::*.X→X) because the kind S(T) is well-formed only for types T of
kind *.
Using extensionality, however, more general singletons are deﬁnable. For
example, one can show that the kind
ΠX::*.S(X→X)
classiﬁes all type operators that are equivalent to λX::*.X→X at kind *⇒*.
More generally, whenever T :: K holds we can deﬁne the kind of types
equivalent to T at kind K as a derived form, written S(T :: K). Again the kind
classiﬁer is crucial, since the function λX::*.X should have kind
S((λX::*.Nat) :: S(Nat)⇒*)
but not kind
S((λX::*.Nat) :: *⇒*).
Figure 9-9 deﬁnes labeled singleton kinds S(T::K) by induction on the size
of the classifying kind K. The sizes of kinds are deﬁned as follows:
size(*)
def
=
1
size(S(T))
def
=
2
size(ΣX::K1.K2)
def
=
1 + size(K1) + size(K2)
size(ΠX::K1.K2)
def
=
1 + size(K1) + size(K2)
An easy inductive proof shows that substitutions have no eﬀect on the size
of kinds, and hence the labeled singleton kinds in Figure 9-9 are well-deﬁned.
These labeled singletons behave exactly as one would expect. To show this,
we start with some basic facts about λS.

374
9
Type Deﬁnitions
9.3.2
Proposition [Weakening]: 1. If Γ1, Γ3 ⊢J for any λS judgment form J and
Γ1, Γ2, Γ3 ⊢⋄then Γ1, Γ2, Γ3 ⊢J.
2. If Γ1, X::K, Γ2 ⊢J and Γ1 ⊢L <: K then Γ1, X::L, Γ2 ⊢J.
2
9.3.3
Proposition [Substitution]:
1. If Γ1, X::K, Γ2 ⊢J for any judgment form J and Γ1 ⊢T :: K then Γ1, [X ,
T]Γ2 ⊢[X , T]J.
2. If Γ1, X::K, Γ2 ⊢S :: L and Γ1 ⊢T ≡T′ :: K then Γ1, [X , T]Γ2 ⊢[X , T]S ≡
[X , T′]S :: [X , T]L.
2
9.3.4
Proposition [Validity]:
1. If Γ ⊢T :: K then FV(T) ∪FV(K) ⊆dom(Γ).
2. If Γ1, Γ2 ⊢⋄then Γ1 ⊢⋄and dom(Γ1) ∩dom(Γ2) = ∅.
3. If Γ ⊢K then Γ ⊢⋄.
4. If Γ ⊢T :: K then Γ ⊢K.
5. If Γ ⊢S ≡T :: K then Γ ⊢S :: K and Γ ⊢T :: K.
2
At this point we can consider properties of the labeled singletons them-
selves.
9.3.5
Proposition: [X , S](S(T :: K)) = S([X , S]T :: [X , S]K).
2
Proof:
By induction on the size of K.
2
9.3.6
Proposition [Labeled Singletons]: 1. If Γ ⊢T :: K then Γ ⊢T :: S(T::K).
2. If Γ ⊢S :: S(T :: K) and Γ ⊢T :: K then Γ ⊢S ≡T :: K.
3. If Γ ⊢S ≡T :: K and Γ ⊢K <: L then Γ ⊢S(S::K) <: S(T::L).
4. If Γ ⊢T :: K then Γ ⊢S(T::K) <: S(T::S(T::K)).
2
Proof:
We show the proof of just the ﬁrst part, which follows by induction
on the size of K. Assume Γ ⊢T :: K.
Case: K = *, so S(T::K) = S(T).
Then Γ ⊢S :: S(T) by Rule K-SIntro.

9.3
Singleton Kinds
375
Case: K = S(S), so S(T::K) = S(T).
By Proposition 9.3.4(5) we have Γ ⊢S(S), so by inversion of Rule WK-Sing we
have Γ ⊢S :: *. Therefore Γ ⊢S(S) <: *, and so by K-Sub we have Γ ⊢T :: *
and hence Γ ⊢T :: S(T) by K-SIntro.
Case: K = ΠX::K1.K2, so S(T::K) = ΠX::K1.S(T X :: K2).
By Proposition 9.3.4(5) and inversion we have Γ, X::K1 ⊢⋄, so by Proposi-
tion 9.3.2(1) and K-App, Γ, X::K1 ⊢T X :: K2. By the inductive hypothesis,
Γ, X::K1 ⊢T X :: S(T X :: K2). Thus by Rule K-AbsSelf we have Γ ⊢T ::
ΠX::K1.S(T X :: K2) as desired.
Case: K = ΣX::K1.K2, so S(T::K) = S(π1 T :: K1) × S(π2 T :: [X , π1 T]K2)
By K-Fst and K-Snd and the inductive hypothesis, we have Γ ⊢π1 T ::
S(π1 T :: K1) and Γ ⊢π 2 T :: S(π2 T :: [X , π1 T]K2). Therefore, by
Rules K-Self1 and K-Self2 the desired result follows.
2
9.3.7
Exercise [««]: Prove Part 2 of Proposition 9.3.6. Why do we need the extra
assumption Γ ⊢T :: K ?
2
At this point, it is not too hard to show that the Beta rules are admissible,
as there is a natural proof involving labeled singletons.
9.3.8
Exercise [««, Recommended]: Prove that rules Q-Beta-Fst, Q-Beta-Snd, and
Q-AppAbs are admissible.
2
Aspinall (1994) took a slightly diﬀerent approach to formalizing a lan-
guage with singletons. His language λ≤{} included only a very restricted form
of extensionality. The encoding of labeled singletons used here was thus
unavailable, and labeled singletons were therefore made primitive language
constructs.5
The properties of Proposition 9.3.6 are then axioms describ-
ing the behavior of these primitive singletons. In this formulation, Proposi-
tion 9.3.6(4) is necessary to have principal kinds; otherwise
*
:>
S(Nat::*)
:>
S(Nat::S(Nat::*))
:>
S(Nat::S(Nat::S(Nat::*)))
:>
· · ·
would be an inﬁnite sequence of increasingly more-precise kinds for Nat.
An interesting consequence of making labeled singletons primitive is that
Aspinall was able to deﬁne the equivalence judgment Γ ⊢S ≡T :: K as
syntactic sugar for the judgment Γ ⊢S :: S(T :: K); there was not a separate
collection of rules deﬁning the equivalence judgment.
5. More precisely, Aspinall studied term equivalence in a language with singleton types, but
the ideas apply just as well for type equivalence with singleton kinds.

376
9
Type Deﬁnitions
A disadvantage of making labeled singletons primitive rather than relying
on extensionality is that most-precise classiﬁers can be large. For example, in
an Aspinall-style system the most-precise kind of λX::*.λY::*.X would be
S((λX::*.λY::*.X) ::
ΠX::*.S((λY::*.X) :: (ΠY::*.S(X :: *))))
rather than
ΠX::*. ΠY::*. S(X)
as in λS. The advantages are not entirely one-sided; S(Z :: *⇒*⇒*) seems
simpler than the λS kind ΠY1::*.ΠY2::*.S(Z Y1 Y2).
Algorithmic Type Equivalence
Figure 9-10 shows an algorithmic version of equivalence for well-kinded λS
types. The general framework is very similar to that for λlet and λL M.
First of all, there is a judgment for computing “natural kinds” in analogy
with the natural interfaces for modules in Figure 9-7. These are the most-
precise kind available without using singleton introduction rules, and a type
has a deﬁnition T if its natural kind is a singleton S(T).
The algorithmic equivalence relation is deﬁned by induction on the clas-
sifying kind: type operators are compared by applying both sides to a fresh
variable (to determine if they are pointwise equivalent), while pairs of types
are compared componentwise. Types of kind * are head-normalized and com-
pared structurally very much as before. Finally, types with singleton kinds are
easy to compare because of the precondition that the two types actually have
the kind at which they are being compared; any two types of kind S(T) are
equivalent to T and hence equivalent to each other.
Viewed as an algorithm with inputs Γ, S, and T, the structural equivalence
judgment both compares S and T and determines the natural kind of S. This
kind is used only to determine the kind at which to compare arguments of
two irreducible applications.
Finally, there is a kind equivalence algorithm, necessary since kinds can
contain types, and hence can be equivalent without being identical.
9.3.9
Exercise [««, Recommended]: Show that
Y::(S(Nat)⇒*)⇒* ⊢▶Y(λX::*.X) a Y(λX::*.Nat) :: *
is provable, but
Y::(*⇒*)⇒* ⊢▶Y(λX::*.X) a Y(λX::*.Nat) :: *
is not.
2

9.3
Singleton Kinds
377
Natural kind
Γ ⊢▶T ↑K
X::K ∈Γ
Γ ⊢▶X ↑K
Γ ⊢▶T1 ↑ΠX::K1.K2
Γ ⊢▶T1 T2 ↑[X , T2]K2
Γ ⊢▶T1 ↑ΣX::K1.K2
Γ ⊢▶π1 T1 ↑K1
Γ ⊢▶T1 ↑ΣX::K1.K2
Γ ⊢▶π2 T2 ↑[X , π1 T1]K2
Weak head reduction
Γ ⊢▶T ; T′
Γ ⊢▶T ↑S(T′)
Γ ⊢▶T ; T′
Γ ⊢▶(λX::K11.T12)T2 ; [X , T2]T12
Γ ⊢▶π 1 {T1,T2} ; T1
Γ ⊢▶π 2 {T1,T2} ; T2
Γ ⊢▶T1 ; T′1
Γ ⊢▶T1 T2 ; T′1 T2
Γ ⊢▶T1 ; T′1
Γ ⊢▶π1 T1 ; π1 T′1
Γ ⊢▶T1 ; T′1
Γ ⊢▶π2 T1 ; π2 T′1
Head Normalization
Γ ⊢▶S ⇓T
Γ ⊢▶S ; S′
Γ ⊢▶S′ ⇓T
Γ ⊢▶S ⇓T
Γ ⊢▶S ̸;
Γ ⊢▶S ⇓S
Type Equivalence
Γ ⊢▶S ↔T :: K
Γ ⊢▶S ⇓S′
Γ ⊢▶T ⇓T′
Γ ⊢▶S′ ↔T′ ↑*
Γ ⊢▶S a T :: *
Γ ⊢▶S a T :: S(T′)
X ̸∈dom(Γ)
Γ, X::K1 ⊢▶S X a T X :: K2
Γ ⊢▶S a T :: ΠX::K1.K2
Γ ⊢▶π1 S a π1 T :: K1
Γ ⊢▶π2 S a π2 T :: [X , π1 S]K2
Γ ⊢▶S a T :: ΣX::K1.K2
Structural Type Equivalence
Γ ⊢▶S ↔T ↑K
X::K ∈Γ
Γ ⊢▶X ↔X ↑K
Γ ⊢▶S1 a T1 :: *
Γ ⊢▶S2 a T2 :: *
Γ ⊢▶S1→S2 ↔T1→T2 ↑*
Γ ⊢▶S1 a T1 :: *
Γ ⊢▶S2 a T2 :: *
Γ ⊢▶S1 × S2 ↔T1 × T2 ↑*
Γ ⊢▶K1 a L1
X ̸∈dom(Γ)
Γ, X::K1 ⊢▶S2 a T2 :: *
Γ ⊢▶∀X::K1.S2 ↔∀X::L1.T2 ↑*
Γ ⊢▶S1 ↔T1 ↑ΠX::K1.K2
Γ ⊢▶S2 a T2 :: K1
Γ ⊢▶S1 S2 ↔T1 T2 ↑[X , S2]K2
Γ ⊢▶S1 ↔T1 ↑ΣX::K1.K2
Γ ⊢▶π1 S1 ↔π1 T1 ↑K1
Γ ⊢▶S1 ↔T1 ↑ΣX::K1.K2
Γ ⊢▶π2 S1 ↔π2 T1 ↑[X , π1 S1]K2
Kind Equivalence
Γ ⊢▶K a L
Γ ⊢▶* a *
Γ ⊢▶S a T :: *
Γ ⊢▶S(S) a S(T)
Γ ⊢▶K1 a K2
X ̸∈dom(Γ)
Γ, X::K1 ⊢▶K2 a L2
Γ ⊢▶ΠX::K1.K2 a ΠX::L1.L2
Γ ⊢▶K1 a K2
X ̸∈dom(Γ)
Γ, X::K1 ⊢▶K2 a L2
Γ ⊢▶ΣX::K1.K2 a ΣX::L1.L2
Figure 9-10: Algorithmic equivalence for λS

378
9
Type Deﬁnitions
The equivalence algorithm is correct and terminating for well-formed types:
9.3.10
Fact: Assume Γ ⊢S :: K and Γ ⊢T :: K. Then Γ ⊢▶S a T :: K if and only if
Γ ⊢S ≡T :: K. Furthermore, the judgment Γ ⊢▶S a T :: K is always decidable
(i.e, proof search will terminate whether or not S and T are equivalent).
2
The correctness of this equivalence algorithm is nontrivial. The approach
suggested in Chapter 6 does not directly apply because there is no a priori
reason to believe that algorithmic equivalence is symmetric and transitive.
The problem is in the “asymmetry” of the rules. The structural equivalence
judgment Γ ⊢▶S ↔T ↑K computes the natural kind K of S as it goes along,
but might have just as well computed the natural kind of T instead. Although
we the two natural kinds turn out to be provably equivalent, this does not
guarantee that the algorithm is unaﬀected—kinds in the classiﬁer end up in
the context, which can aﬀect how later weak head normalizations proceed,
which could a priori result in a diﬀerent answer or aﬀect termination.
If the algorithm cannot be shown directly to be symmetric or transitive,
then a logical equivalence relation deﬁned as for λlet cannot directly be
shown to be symmetric or transitive. Stone and Harper (2000; 2005) showed,
however, that variants of Kripke logical relations can be used to prove the
correctness of closely-related algorithms, from which the correctness of the
above algorithm can be derived.
Phase-Splitting
λL M added second-class modules to a language and in so doing increased
the number of sorts of entities in the language: modules and interfaces, in
addition to the pre-existing terms, types, and kinds. Interestingly, modules
and interfaces can sometimes be decomposed into uses of terms, types, and
kinds. Some compilers for Standard ML (Petersen, Cheng, Harper, and Stone,
2000; Shao, 1997, 1998) even implement modules using this technique.
The translation is possible if the module system has a phase distinction, as
discussed in Chapter 8: types in modules must depend only on other types.
λL M appears to violate this requirement, as the type !W may involve term
values. Similarly, a functor application M1 M2 can yield a module containing
types, and the result syntactically appears to depend on all of M2, which can
contain terms.
As observed by Harper, Mitchell, and Moggi (1990), however, the depen-
dency of types on the terms in modules is illusory. References to modules in
types really involve only the type components of that module; all else is irrel-
evant. Similarly, in a functor application M1 M2 the types returned to depend
only on types deﬁned in M1 and types deﬁned in M2; there is no way that the
terms in these modules can aﬀect the resulting types.

9.3
Singleton Kinds
379
It is therefore possible to split every module into a type part and a term
part, referred to here as the static and dynamic parts of the module; the
former can be represented as a type (perhaps of a higher kind), and the latter
as a term (potentially polymorphic).
A module containing many types and many values would split into a col-
lection of types (not to be confused with the type of a tuple of terms) and
a collection of values. In parallel, a functor application can be split into an
application of types (the type part of the functor applied to the type part of
the argument) and an application of a polymorphic term (the term part of the
functor applied to both the type part of the argument and the term part of
the argument). For example, the functor
module diag = λ(p : sig
type t
val x : t
end).
mod
type u = p.t × p.t
val
y : u = {p.x, p.x}
end
which we encoded in λL M as
λm:(Σm’:L*M. L!m’M).
L L!m.1 × !m.1M, L{!m.2,!m.2}M M
could have its behavior with respect to producing types modeled by the
type operator λX::*. X × X, since diag takes a type in its argument and
returns a corresponding pair type in its result. Similarly, the behavior of
diag in producing terms can be modeled as the polymorphic abstraction
λX::*. λx:X. {x,x}, representing that it takes a type and a term of that
type in the argument, and that it returns a pair value.
Interfaces can be split correspondingly into a kind classifying the static
portion of the module, and a type classifying the dynamic portion of the
module. For example, a speciﬁcation
diag : (Πm:(Σm’:L*M. L!m’M). (Σm”:L*=!m.1× !m.1M. L!m”M))
could be split into two speciﬁcations for the static and dynamic parts of diag:
diags :: ΠX::*. S(X × X)
and
diagd : ∀X::*. X →diags(X).
Equations in λL M interfaces become singleton kinds after phase-splitting.
Figure 9-11 speciﬁes a formal translation from λL M into λS. For simplicity,
the translation maintains the invariant that every module and every interface

380
9
Type Deﬁnitions
Modules
|m|s
:=
Xm
|m|d
:=
xm
|LtM|s
:=
S0
|LtM|d
:=
v
|LT::KM|s
:=
|T|
|LT::KM|d
:=
t0
|LM1,M2M|s
:=
{ |M1|s, |M2|s }
|LM1,M2M|d
:=
{ |M1|d, |M2|d }
|M.1|s
:=
π1(|M|s)
|M.1|d
:=
π1(|M|d)
|M.2|s
:=
π2(|M|s)
|M.2|d
:=
π2(|M|d)
|λm:I.M|s
:=
λXm:|I|s.|M|s
|λm:I.M|d
:=
λXm:|I|s.
λxm:|I|d(Xm).
|M|d
|M1 M2|s
:=
|M1|s |M2|s
|M1 M2|d
:=
(|M1|d [|M2|s]) |M2|d
|M :> I|s
:=
|M|s
|M :> I|d
:=
|M|d
Interfaces
|LTM|s
:=
K0
|LTM|d(Ts)
:=
|T|
|LKM|s
:=
K
|LKM|d(Ts)
:=
T0
|LK=TM|s
:=
S(|T| :: K)
|LK=TM|d(Ts)
:=
T0
|Πm:I1.I2|s
:=
ΠXm::|I1|s.
|Πm:I1.I2|d(Ts)
:=
∀Xm::|I1|s.
|I2|s
[if Xm ̸∈FV(Ts)]
|I1|d(Xm) →
(|I2|d(Ts Xm))
|Σm:I1.I2|s
:=
ΣXm::|I1|s.
|Σm:I1.I2|d(Ts)
:=
|I1|d(π1 Ts) ×
|I2|s
([Xm , π1 Ts]|I2|d(π2 Ts))
Types and Contexts
|X|
:=
X
|·|
:=
·
|T1→T2|
:=
|T1| →|T2|
|Γ, X::K|
:=
|Γ|, X::K
|T1 × T2|
:=
|T1| × |T2|
|Γ, x:T|
:=
|Γ|, x:|T|
|∀X::K1.T2|
:=
∀X::K1.|T2|
|Γ, m:I|
:=
|Γ|, Xm::|I|s,
|λX::K1.T2|
:=
λX::K1.|T2|
xm:|I|d(Xm)
|T1 T2|
:=
|T1| |T2|
|!W|
:=
|W|s
Terms
|x|
:=
x
|{t1,t2}|
:=
{ |t1|, |t2| }
|λx:T.t|
:=
λx:|T|.|t|
|t.1|
:=
|t|.1
|t1 [t2]|
:=
|t1| [ |t2| ]
|t.2|
:=
|t|.2
|λX::K.t|
:=
λX::K.|t|
|!M|
:=
|M|d
|t1 T2|
:=
|t1| |T2|
Figure 9-11: Phase-splitting translation

9.3
Singleton Kinds
381
has static and dynamic parts. Since λL M contains primitive modules that con-
tain only terms or only types, the translation uses an arbitrary term t0 of
some type T0 to represent the dynamic part of a module containing only a
type (an obvious choice for t0 would be the value of type Unit), and uses an
arbitrary type S0 of kind K0 representing the static part of a module contain-
ing only a term.
Also, for every module variable m we assume there exists a type variable Xm
and a term variable xm. These will be bound to the static and dynamic parts
respectively of whatever m would have been bound to in the original code.
Figure 9-11 begins by deﬁning |M|s, which is a type expression contain-
ing all the types in the module M. In most cases this is straightforward. The
static part of a module variable m is the corresponding type variable Xm; the
static part of a module containing the type T is T itself, or more precisely, the
translation of T, which eliminates occurrences of modules (see below). The
static part of the ﬁrst or second projection from a module pair is the ﬁrst or
second projection the pair’s static part. The static part of an application is
the application of its static parts.
The static part of a sealed module is deﬁned to be the static part of the
underlying module; generative sealing is the one construct in λL M with no
direct equivalent in λS. The λS language has no abstraction mechanism, and
there is no easy way to add a generative construct to its equational theory
of types. However, since sealing has no dynamic eﬀect it is possible to take a
well-formed λL M term and erase all occurrence of sealing, yielding a well-typed
and behaviorally-equivalent term. Implementations of λL M based on phase-
splitting typically ﬁrst do type checking in λL M to ensure that abstraction is
being respected, and then erase the sealing as they perform phase-splitting.
The deﬁnition |M|d of the dynamic part of a module M is similar. The dy-
namic part of a functor is parameterized both by the static part of the argu-
ment and the dynamic part, since values returned by a functor can depend
both on the types in the argument and the values in the argument. Mod-
ule applications then turn into the corresponding polymorphic instantiation
followed by an application.
The static part |I|s of a module interface I is a kind describing the types
in any module satisfying I. Singleton kinds are used to describe equations
found in transparent interfaces.
The dynamic part of a module interface is more interesting. The values
in a module may be describable only in terms of the types in the module.
For example, after phase-splitting the dynamic part of a module of interface
Σm:L*M.L!mM (a module containing an abstract type and a value of that type)
can only be described as containing a value whose type is contained in the
static part of that same module. The deﬁnition of the dynamic part of an in-

382
9
Type Deﬁnitions
terface, |I|d(Ts), is therefore deﬁned in terms of both the interface I and
the static part Ts of a module satisfying I. Such a static part is available wher-
ever the dynamic part of an interface is needed. For example, the deﬁnition of
the dynamic part of a functor module with argument interface I is a polymor-
phic function requiring in succession both Xm (the static part of the functor’s
argument) and a valid dynamic part for a module with that static part, i.e., a
value of type |I|d(Xm).
Recall that the static part of a module application is the application of
the static parts. Therefore, when computing the dynamic part of an interface
Πm:I1.I2, we know that the module being returned satisﬁes the interface I2
and that the static part of the module being returned is the static part of this
functor applied to the static part of the functor argument. Thus, the type of
the value returned by the dynamic part is |I2|d(Ts Xm), where Ts is the static
part of the functor as a whole.
Similarly, if we have a module pair with interface Σm:I1.I2 having static
part Ts, then the static parts of the components are π1 Ts and π2 Ts respec-
tively. Further, since I2 may contain free-occurrences of m, its dynamic part
may refer to Xm. Xm stands for the static part of (i.e., the types in) in the
module’s ﬁrst component, so we can replace it by π1 Ts, the static part of
the module’s ﬁrst component. No similar substitution is needed for xm; the
dynamic part of I2 is still a type and cannot contain term variables.
The translation of |T| of a type is very simple. Phase-splitting is possi-
ble because references to modules in types just involve the types in these
modules. We can therefore replace all module projections of the form !W by
the static part |W|s of W. Similarly, the translation of a term goes through
and translates all types, and replaces every projection !M of a value from a
module by the dynamic part of M.
The translation of a context translates types, leaves kinds alone (since λL M
kinds do not contain types, terms, or variables), and replaces every assump-
tion of a module variable m with assumptions for the two corresponding vari-
ables Xm and xm.
9.3.11
Exercise [««, Recommended]: Compute the static and dynamic parts for
the λL M deﬁnition of the diag functor. How do these diﬀer from the intuitive
translations given above?
2
We can show that this transformation turns well-formed λL M code into well-
formed λS code. We distinguish proofs in the two languages λL M and λS by
writing ⊢LM and ⊢S respectively.
9.3.12
Lemma: If Y ̸∈FV(I) then |I|d(Ts) = [Y , Ts]|Id|(Y).
2

9.3
Singleton Kinds
383
9.3.13
Theorem [Phase-Splitting]:
1. If Γ ⊢LM ⋄then |Γ| ⊢S ⋄.
2. If Γ ⊢LM T :: K then |Γ| ⊢S |T| :: K.
3. If Γ ⊢LM S ≡T :: K then |Γ| ⊢S |S| ≡|T| :: K.
4. If Γ ⊢LM t : T then |Γ| ⊢S |t| : |T|.
5. If Γ ⊢LM I then |Γ| ⊢S |I|s, and if further Y ̸∈dom(Γ) and Y ̸= Xm for every
m then |Γ|, Y::|I|s ⊢S |I|d(Y) :: *.
6. If Γ ⊢LM I1 <: I2 then |Γ| ⊢S |I1|s <: |I2|s and if further Y ̸∈dom(Γ) and
Y ̸= Xm for every m then |Γ|, Y::|I1|s ⊢S |I1|d(Y) ≡|I2|d(Y) :: *.
7. If Γ ⊢LM I1 ≡I2 then |Γ| ⊢S |I1|s <: |I2|s and if further Y ̸∈dom(Γ) and
Y ̸= Xm for every m then |Γ|, Y::|I1|s ⊢S |I1|d(Y) ≡|I2|d(Y) :: *.
8. If Γ ⊢LM M : I then |Γ| ⊢S |M|s :: |I|s and |Γ| ⊢S |M|d : |I|d(|M|s). 2
Proof:
By induction on derivations and cases on the last rule used. Two rep-
resentative cases are sketched here.
Case I-Sigma: Γ ⊢LM Σm:I1.I2 because Γ, m:I1 ⊢LM I2.
By the inductive hypothesis, |Γ|, Xm::|I1|s, xm:|I1|d(Xm) ⊢S |I2|s. Inspec-
tion of λS shows that terms variables have no eﬀect on the well-formedness of
kinds,
so
we
have
|Γ|, Xm::|I1|s
⊢S
|I2|s
and
hence
|Γ| ⊢S ΣXm::|I1|s.|I2|s. That is, |Γ| ⊢S |Σm:I1.I2|.
Also by the inductive hypothesis|Γ|,X m::|I1|s, xm:|I1|d(Xm), Y2:|I2|s ⊢S
|I2|d(Y2) :: * where Y2 is fresh. By Proposition 9.3.2(1) and the observa-
tion that term variables have no eﬀect on the well-formedness of types, we
have |Γ|, Y::(ΣXm::|I1|s.|I2|s), Xm::|I1|s, Y2:|I2|s ⊢S |I2|d(Y2) :: *.
By Proposition 9.3.3(1), |Γ|, Y::(ΣXm::|I1|s.|I2|s), Y2:[Xm , π1 Y]|I2|s ⊢S
[Xm , π1 Y]|I2|d(Y2) :: *. By Lemma 9.3.12 and Proposition 9.3.3(1),
|Γ|, Y::(ΣXm::|I1|s.|I2|s) ⊢S [Xm , π1 Y]|I2|d(π2 Y) :: *. That is,
|Γ|, Y::(ΣXm::|I1|s.|I2|s) ⊢S |Σm:I1.I2|d(Y) :: *.
Case M-Self2: Γ ⊢LM W : I1 × I2 because Γ ⊢LM W : Σm:I1.I′2 and Γ ⊢LM W.2 :
I2.
By the inductive hypothesis, |Γ| ⊢S |W|s :: ΣXm::|I1|s.|I′2|s and |Γ| ⊢S
π2 |W|s :: |I2|s. By Rule K-Self2, then, |Γ| ⊢S |W|s :: |I1|s × |I2|s. That
is, |Γ| ⊢S |W|s :: |I1 × I2|s. Similarly, by the inductive hypothesis we have
|Γ| ⊢S |W|d : |I1|d(π1 |W|s) × . . . and |Γ| ⊢S π2 |W|d : |I2|d(π2 |W|s).
Since λS has no subtyping and terms can be shown to have unique types up to
equivalence, it follows that |Γ| ⊢S |W|d : |I1|d(π1 |W|s) × |I2|d(π2 |W|s).
That is, |Γ| ⊢S |W|d : |I1 × I2|d(|W|s).
2

384
9
Type Deﬁnitions
Many variations on the phase-splitting transformation are possible. Also,
instead of relying on singleton kinds, type deﬁnitions can be eliminated dur-
ing phase-splitting. This approach is taken by the FLINT compiler for Stan-
dard ML (Shao, 1998).
If the source language λL Mis modiﬁed to make Π interfaces contravariant in
their domains, then to type check the result we either need to add a limited
form of subtyping in λS (in addition to the subkinding that already exists),
or to insert explicit type coercions (Breazu-Tannen, Coquand, Gunter, and
Scedrov, 1991) This last approach is taken by the TILT compiler for Standard
ML (Petersen, Cheng, Harper, and Stone, 2000).
9.3.14
Exercise [««, Recommended]:
1. Suppose we add terms of the form let m=M in t to λL M, allowing modules
to be deﬁned locally within terms. Can the phase-splitting algorithm be
extended to handle such terms?
2. Suppose we added a conditional expression at the module level to λL M,
if t then M else M′. Can the phase-splitting algorithm be extended to han-
dle these modules?
2
9.3.15
Exercise [««««, 3]: Formally specify a method for obtaining more optimized
λS code corresponding to λL M inputs. For example, the diag functor encoded
in λL M might split into λX::*. X × X and λX::*. λx:X. {x,x} as originally
suggested. Verify that your optimization preserves well-formedness of code,
in analogy with Theorem 9.3.13.
2
9.4
Notes
Primitive deﬁnitions are permitted in most implementations of λ-calculus-
based systems. The AUTOMATH system (de Bruijn, 1980; van Daalen, 1980),
for example, relied vitally on deﬁnitions, as do modern systems such as Coq
(Barras et al., 1997). Most directly related to the system λlet is the work of
Severi and Poll (1994), who studied a pure type system supporting primitive
deﬁnitions at all levels. They observed that one might wish to permit prim-
itive deﬁnitions for items (e.g., kinds) even if the language does not include
operators parameterized by such items. Their decidability proof is not based
on logical relations, but instead deﬁnes a rewrite rule implementing beta-
delta reduction, which they show to be conﬂuent and strongly normalizing.
For many references on the theory of module systems, see Chapter 8; the
presentation of λL M is most similar to that of Lillibridge (1997) and Dreyer,
Crary, and Harper (2003).

9.4
Notes
385
Aspinall (1994) suggested that if types are viewed as program speciﬁca-
tions, then singleton types would allow very speciﬁc speciﬁcations (e.g., re-
quiring that a particular function not only map natural numbers to natural
numbers, but that it compute factorials; the function could be speciﬁed as be-
gin a member of a singleton type, namely the type of all terms equivalent to
a reference implementation for factorial). He presented a system of labeled
singleton types with beta-equivalence and a limited form of extensionality
for lambda abstractions. Stone and Harper (2000) proved decidability of a
system essentially equivalent to λS, and later simpliﬁed their proof (Stone
and Harper, 2005). Coquand, Pollack, and Takeyama (2003) took a diﬀerent
approach to deciding equivalence in the presence of singletons and extension-
ality; their algorithm is based on eta-expanding and expanding deﬁnitions,
followed by a comparison for beta-equivalence.
Courant (2002) has studied a system with labeled singleton types but no
extensionality principles at all; then equivalence depends on the typing con-
text but not the classiﬁer at which the comparison is taking place, and so
it was possible to use a more traditional approach to equivalence by proving
conﬂuence and strong-normalization of a rewrite relation similar to that used
by Severi and Poll.


P a r t V
Type Inference


10
The Essence of ML Type Inference
François Pottier and Didier Rémy
10.1
What Is ML?
The name ML appeared during the late seventies. It then referred to a general-
purpose programming language that was used as a meta-language (whence its
name) within the theorem prover LCF (Gordon, Milner, and Wadsworth, 1979).
Since then, several new programming languages, each of which oﬀers several
diﬀerent implementations, have drawn inspiration from it. So, what does ML
stand for today?
For a semanticist, ML might stand for a programming language featuring
ﬁrst-class functions, data structures built out of products and sums, muta-
ble memory cells called references, exception handling, automatic memory
management, and a call-by-value semantics. This view encompasses the Stan-
dard ML (Milner, Tofte, and Harper, 1990) and Caml (Leroy, 2000) families of
programming languages. We refer to it as ML-the-programming-language.
For a type theorist, ML might stand for a particular breed of type systems,
based on the simply-typed λ-calculus, but extended with a simple form of
polymorphism introduced by let declarations. These type systems have de-
cidable type inference; their type inference algorithms strongly rely on ﬁrst-
order uniﬁcation and can be made eﬃcient in practice. Besides Standard ML
and Caml, this view encompasses programming languages such as Haskell
(Peyton Jones, 2003) and Clean (Brus, van Eekelen, van Leer, and Plasmeijer,
1987), whose semantics is rather diﬀerent—indeed, it is nonstrict and pure
(Sabry, 1998)—but whose type system ﬁts this description. We refer to it as
ML-the-type-system. It is also referred to as the Hindley-Milner type discipline
in the literature.
Code for this chapter may be found on the book’s web site.

390
10
The Essence of ML Type Inference
For us, ML might also stand for the particular programming language whose
formal deﬁnition is given and studied in this chapter. It is a core calculus fea-
turing ﬁrst-class functions, local deﬁnitions, and constants. It is equipped
with a call-by-value semantics. By customizing constants and their seman-
tics, one may recover data structures, references, and more. We refer to this
particular calculus as ML-the-calculus.
Why study ML-the-type-system today, such a long time after its initial dis-
covery? One may think of at least two reasons.
First, its treatment in the literature is often cursory, because it is consid-
ered either as a simple extension of the simply-typed λ-calculus (TAPL, Chap-
ter 9) or as a subset of Girard and Reynolds’ System F (TAPL, Chapter 23).
The former view is supported by the claim that local (let) deﬁnitions, which
distinguish ML-the-type-system from the simply-typed λ-calculus, may be un-
derstood as a simple textual expansion facility. However, this view tells only
part of the story, because it fails to give an account of the principal types
property enjoyed by ML-the-type-system, leads to a naive type inference al-
gorithm whose time complexity is exponential not only in the worst case
but in the common case, and breaks down when the language is extended
with side eﬀects, such as state or exceptions. The latter view is supported by
the fact that every type derivation within ML-the-type-system is also a valid
type derivation within an implicitly-typed variant of System F. Such a view is
correct but again fails to give an account of type inference for ML-the-type-
system, since type inference for System F is undecidable (Wells, 1999).
Second, existing accounts of type inference for ML-the-type-system (Milner,
1978; Damas and Milner, 1982; Tofte, 1988; Leroy, 1992; Lee and Yi, 1998;
Jones, 1999) often involve heavy manipulations of type substitutions. Such
a ubiquitous use of type substitutions is often quite obscure. Furthermore,
actual implementations of the type inference algorithm do not explicitly ma-
nipulate substitutions; instead, they extend a standard ﬁrst-order uniﬁcation
algorithm, where terms are updated in place as new equations are discovered
(Huet, 1976; Martelli and Montanari, 1982). Thus, it is hard to tell, from these
accounts, how to write an eﬃcient type inference algorithm for ML-the-type-
system. Yet, in spite of the increasing speed of computers, eﬃciency remains
crucial when ML-the-type-system is extended with expensive features, such
as Objective Caml’s object types (Rémy and Vouillon, 1998), variant types
(Garrigue, 1998), or polymorphic methods (Garrigue and Rémy, 1999).
Our emphasis on eﬃciency might come as a surprise, since type inference
for ML-the-type-system is known to be dexptime-complete (Kfoury, Tiuryn,
and Urzyczyn, 1990; Mairson, Kanellakis, and Mitchell, 1991). In practice,
however, most implementations of it behave well. This apparent contradic-
tion may be explained by observing that types usually remain small and

10.1
What Is ML?
391
that let constructs are never deeply nested towards the left. Indeed, un-
der the assumption that types have bounded size and that programs have
bounded “scheme depth,” type inference may be performed in quasi-linear
time (McAllester, 2003). In ML-the-programming-language, algebraic data type
deﬁnitions allow complex data structures to be described by concise expres-
sions, such as “list X,” which helps achieve the bounded-type-size property.
In fact, in such favorable circumstances, even an ineﬃcient algorithm may
behave well. For instance, some deployed implementations of type inference
for ML-the-type-system contain sources of ineﬃciency (see remark 10.1.21
on page 404) and do not operate in quasi-linear time under the bounded-
type-size assumption. However, such implementations are put under greater
stress when types become larger, a situation that occurs in some programs
(Saha, Heintze, and Oliva, 1998) and also arises when large, transparent type
expressions are used instead of algebraic data types, as in Objective Caml’s
object-oriented fragment (Rémy and Vouillon, 1998).
For these reasons, we believe it is worth giving an account of ML-the-type-
system that focuses on type inference and strives to be at once elegant and
faithful to an eﬃcient implementation, such as Rémy’s (1992a). In this presen-
tation, we forego type substitutions and instead put emphasis on constraints,
which oﬀer a number of advantages.
First, constraints allow a modular presentation of type inference as the
combination of a constraint generator and a constraint solver, allowing sep-
arate reasoning about when a program is correct and how to check whether
it is correct. This perspective has long been standard in the setting of the
simply-typed λ-calculus: see, for example, Wand (1987b) and TAPL, Chap-
ter 22. In the setting of ML-the-type-system, such a decomposition is pro-
vided by the reduction of typability problems to acyclic semi-uniﬁcation prob-
lems (Henglein, 1993; Kfoury, Tiuryn, and Urzyczyn, 1994). This approach,
however, was apparently never used in production implementations of ML-
the-programming-language. An experimental extension of SML/NJ with poly-
morphic recursion (Emms and LeiSS, 1996) did reduce type inference to a
semi-uniﬁcation problem. Semi-uniﬁcation found applications in the closely
related area of program analysis; see, for example, Fähndrich, Rehof, and Das
(2000) and Birkedal and Tofte (2001). In this chapter, we give a constraint-
based description of a “classic” implementation of ML-the-type-system, which
is based on ﬁrst-order uniﬁcation and a mechanism for creating and instan-
tiating principal type schemes.
Second, it is often natural to deﬁne and implement the solver as a con-
straint rewriting system. The constraint language allows reasoning not only
about correctness—is every rewriting step meaning-preserving?—but also
about low-level implementation details, since constraints are the data struc-

392
10
The Essence of ML Type Inference
x, y
::=
Identiﬁers:
z
Variable
m
Memory location
c
Constant
t
::=
Expressions:
x
Identiﬁer
λz.t
Function
t t
Application
let z = t in t
Local deﬁnition
v, w
::=
Values:
z
Variable
m
Memory location
λz.t
Function
c v1 . . . vk
Data
c ∈Q+ ∧k ≤a(c)
c v1 . . . vk
Partial application
c ∈Q−∧k < a(c)
E
::=
Evaluation Contexts:
[]
Empty context
E t
Left side of an application
v E
Right side of an application
let z = E in t
Local deﬁnition
Figure 10-1: Syntax of ML-the-calculus
tures manipulated throughout the type inference process. For instance, de-
scribing uniﬁcation in terms of multi-equations allows reasoning about the
sharing of nodes in memory, which a substitution-based approach cannot
account for. Last, constraints are more general than type substitutions, and
allow smooth extensions of ML-the-type-system with recursive types, rows,
subtyping, and more. These arguments are developed, for example, in Jouan-
naud and Kirchner (1991).
Before delving into the details of this new presentation of ML-the-type-
system, it is worth recalling its standard deﬁnition. Thus, in what follows,
we ﬁrst deﬁne the syntax and operational semantics of ML-the-calculus, and
equip it with a type system, known as Damas and Milner’s type system.
ML-the-Calculus
The syntax of ML-the-calculus is deﬁned in Figure 10-1. It is made up of sev-
eral syntactic categories.
Identiﬁers group several kinds of names that may be referenced in a pro-
gram: variables, memory locations, and constants. We let x and y range over
identiﬁers. Variables—also called program variables, to avoid ambiguity—are
names that may be bound to values using λ or let binding forms; in other
words, they are names for function parameters or local deﬁnitions. We let
z and f range over program variables. We sometimes write
for a program
variable that does not occur free within its scope: for instance, λ .t stands for
λz.t, provided z is fresh for t. (We say that z is fresh for t when z does not oc-

10.1
What Is ML?
393
cur free in t.) Memory locations are names that represent memory addresses.
They are used to model references (see Example 10.1.9 below). Memory loca-
tions never appear in source programs, that is, programs that are submitted
to a compiler. They only appear during execution, when new memory blocks
are allocated. Constants are ﬁxed names for primitive values and operations,
such as integer literals and integer arithmetic operations. Constants are el-
ements of a ﬁnite or inﬁnite set Q. They are never subject to α-conversion,
in contrast to variables and memory locations. Program variables, memory
locations, and constants belong to distinct syntactic classes and may never
be confused.
The set of constants Q is kept abstract, so most of our development is
independent of its concrete deﬁnition. We assume that every constant c has
a nonnegative integer arity a(c). We further assume that Q is partitioned into
subsets of constructors Q+ and destructors Q−. Constructors and destructors
diﬀer in that the former are used to form values, while the latter are used to
operate on values.
10.1.1
Example [Integers]: For every integer n, one may introduce a nullary con-
structor ˆn. In addition, one may introduce a binary destructor ˆ+, whose ap-
plications are written inﬁx, so t1 ˆ+ t2 stands for the double application ˆ+ t1
t2 of the destructor ˆ+ to the expressions t1 and t2.
2
Expressions—also known as terms or programs—are the main syntactic cat-
egory. Indeed, unlike procedural languages such as C and Java, functional
languages, including ML-the-programming-language, suppress the distinction
between expressions and statements. Expressions consist of identiﬁers, λ-
abstractions, applications, and local deﬁnitions. The λ-abstraction λz.t repre-
sents the function of one parameter named z whose result is the expression t,
or, in other words, the function that maps z to t. Note that the variable z is
bound within the term t, so (for instance) the notations λz1.z1 and λz2.z2
denote the same entity. The application t1 t2 represents the result of calling
the function t1 with actual parameter t2, or, in other words, the result of
applying t1 to t2. Application is left-associative, that is, t1 t2 t3 stands for
(t1 t2) t3. The construct let z = t1 in t2 represents the result of evaluating
t2 after binding the variable z to t1. Note that the variable z is bound within
t2, but not within t1, so for instance let z1 = z1 in z1 and let z2 = z1 in z2
are the same object. The construct let z = t1 in t2 has the same meaning as
(λz.t2) t1, but is dealt with in a more ﬂexible way by ML-the-type-system. To
sum up, the syntax of ML-the-calculus is that of the pure λ-calculus, extended
with memory locations, constants, and the let construct.
Values form a subset of expressions. They are expressions whose evalua-
tion is completed. Values include identiﬁers, λ-abstractions, and applications

394
10
The Essence of ML Type Inference
of constants, of the form c v1 . . . vk, where k does not exceed c’s arity if c
is a constructor, and k is smaller than c’s arity if c is a destructor. In what
follows, we are often interested in closed values—ones that do not contain
any free program variables. We use the meta-variables v and w for values.
10.1.2
Example: The integer literals . . . , d
−1, ˆ0, ˆ1, . . . are nullary constructors, so they
are values. Integer addition ˆ+ is a binary destructor, so it is a value, and
so is every partial application ˆ+ v. Thus, both ˆ+ ˆ1 and ˆ+ ˆ+ are values. An
application of ˆ+ to two values, such as ˆ2ˆ+ˆ2, is not a value.
2
10.1.3
Example [Pairs]: Let (·, ·) be a binary constructor. If t1 are t2 are expres-
sions, then the double application (·, ·) t1 t2 may be called the pair of t1
and t2, and may be written (t1, t2). By the deﬁnition above, (t1, t2) is a value
if and only if t1 and t2 are both values.
2
Stores are ﬁnite mappings from memory locations to closed values. A store
µ represents what is usually called a heap, that is, a collection of values,
each of which is allocated at a particular address in memory and may contain
pointers to other elements of the heap. ML-the-programming-language allows
overwriting the contents of an existing memory block—an operation some-
times referred to as a side eﬀect. In the operational semantics, this eﬀect is
achieved by mapping an existing memory location to a new value. We write 
for the empty store. We write µ[m , v] for the store that maps m to v and
otherwise coincides with µ. When µ and µ′ have disjoint domains, we write
µµ′ for their union. We write dom(µ) for the domain of µ and range(µ) for
the set of memory locations that appear in its codomain.
The operational semantics of a pure language like the λ-calculus may be
deﬁned as a rewriting system on expressions. Because ML-the-calculus has
side eﬀects, however, we deﬁne its operational semantics as a rewriting sys-
tem on conﬁgurations. A conﬁguration t/µ is a pair of an expression t and a
store µ. The memory locations in the domain of µ are not considered bound
within t/µ, so, for instance, m1/(m1 , ˆ0) and m2/(m2 , ˆ0) denote distinct
entities. (In the literature, memory locations are often considered bound in-
side conﬁgurations. This oﬀers the advantage of making memory allocation a
deterministic operation. However, there is still a need for non-α-convertible
conﬁgurations: rules R-Extend and R-Context in Figure 10-2 cannot other-
wise be correctly stated! Quite a few papers run into this pitfall.)
A conﬁguration t/µ is closed if and only if t has no free program variables
and every memory location that appears within t or within the range of µ is in
the domain of µ. If t is a closed source program, its evaluation begins within
an empty store—that is, with the conﬁguration t/. Because source programs
do not contain memory locations, this conﬁguration is closed. Furthermore,
we shall see that closed conﬁgurations are preserved by reduction.

10.1
What Is ML?
395
(λz.t) v -→[z , v]t
(R-Beta)
let z = v in t -→[z , v]t
(R-Let)
t/µ
δ-→t′/µ′
t/µ -→t′/µ′
(R-Delta)
t/µ -→t′/µ′
dom(µ′′) # dom(µ′)
range(µ′′) # dom(µ′ \ µ)
t/µµ′′ -→t′/µ′µ′′
(R-Extend)
t/µ -→t′/µ′
E[t]/µ −−▶E[t′]/µ′
(R-Context)
Figure 10-2: Semantics of ML-the-calculus
Note that, instead of separating expressions and stores, it is possible to
make store fragments part of the syntax of expressions; this idea, proposed in
Crank and Felleisen (1991), has also been used for the encoding of reference
cells in process calculi.
A context is an expression where a single subexpression has been replaced
with a hole, written []. Evaluation contexts form a strict subset of contexts. In
an evaluation context, the hole is meant to highlight a point in the program
where it is valid to apply a reduction rule. Thus, the deﬁnition of evaluation
contexts determines a reduction strategy: it tells where and in what order
reduction steps may occur. For instance, the fact that λz.[] is not an evalu-
ation context means that the body of a function is never evaluated—that is,
not until the function is applied. The fact that t E is an evaluation context
only if t is a value means that, to evaluate an application t1 t2, one should
fully evaluate t1 before attempting to evaluate t2. More generally, in the case
of a multiple application, it means that arguments should be evaluated from
left to right. Of course, other choices could be made: for instance, deﬁning
E ::= . . . | t E | E v | . . . would enforce a right-to-left evaluation order, while
deﬁning E ::= . . . | t E | E t | . . . would leave the evaluation order unspeci-
ﬁed, eﬀectively allowing reduction to alternate between both subexpressions,
and making evaluation nondeterministic (because side eﬀects could occur in
diﬀerent order). The fact that let z = v in E is not an evaluation context
means that the body of a local deﬁnition is never evaluated—that is, not until
the deﬁnition itself is reduced. We write E[t] for the expression obtained by
replacing the hole in E with the expression t.
Figure 10-2 deﬁnes ﬁrst a relation -→between arbitrary conﬁgurations,
then a relation −−▶between closed conﬁgurations. If t/µ -→t′/µ holds for
every store µ, then we write t -→t′ and say that the reduction is pure.
The semantics need not be deterministic. That is, a conﬁguration may re-
duce to two diﬀerent conﬁgurations. In fact, our semantics is deterministic

396
10
The Essence of ML Type Inference
only if the relation
δ-→, which is a parameter to our semantics, is itself de-
terministic. In practice,
δ-→is usually deterministic, up to α-conversion of
memory locations. As explained above, the semantics could also be made
nondeterministic by a diﬀerent choice in the deﬁnition of evaluation contexts.
The key reduction rule is R-Beta, which states that a function application
(λz.t) v reduces to the function body, namely t, where every occurrence of
the formal argument z has been replaced with the actual argument v. The λ
construct, which prevented the function body t from being evaluated, disap-
pears, so the new term may (in general) be further reduced. Because ML-the-
calculus adopts a call-by-value strategy, rule R-Beta is applicable only if the
actual argument is a value v. In other words, a function cannot be invoked un-
til its actual argument has been fully evaluated. Rule R-Let is very similar to
R-Beta. Indeed, it speciﬁes that let z = v in t has the same behavior, with re-
spect to reduction, as (λz.t) v. Substitution of a value for a program variable
throughout a term is expensive, so R-Beta and R-Let are never implemented
literally: they are only a simple speciﬁcation. Actual implementations usually
employ runtime environments, which may be understood as a form of explicit
substitutions (Abadi, Cardelli, Curien, and Lévy, 1991; Hardin, Maranget, and
Pagano, 1998). Note that our choice of a call-by-value reduction strategy has
essentially no impact on the type system; the programming language Haskell,
whose reduction strategy is known as lazy or call-by-need, also relies on the
Hindley-Milner type discipline.
Rule R-Delta describes the semantics of constants. It states that a certain
relation
δ-→is a subset of -→. Of course, since the set of constants is un-
speciﬁed, the relation
δ-→must be kept abstract as well. We require that, if
t/µ
δ-→t′/µ′ holds, then
(i) t is of the form c v1 . . . vn, where c is a destructor of arity n; and
(ii) dom(µ) is a subset of dom(µ′).
Condition (i) ensures that δ-reduction concerns full applications of destruc-
tors only, and that these are evaluated in accordance with the call-by-value
strategy. Condition (ii) ensures that δ-reduction may allocate new memory
locations, but not deallocate existing locations. In particular, a “garbage col-
lection” operator, which destroys unreachable memory cells, cannot be made
available as a constant. Doing so would not make much sense anyway in the
presence of R-Extend. Condition (ii) allows proving that, if t/µ reduces (by
-→) to t′/µ′, then dom(µ) is also a subset of dom(µ′); checking this is left as
an exercise to the reader.
Rule R-Extend states that any valid reduction is also valid in a larger store.
The initial and ﬁnal stores µ and µ′ in the original reduction are both ex-

10.1
What Is ML?
397
tended with a new store fragment µ′′. The rule’s second premise requires that
the domain of µ′′ be disjoint with that of µ′ (and consequently, also with that
of µ), so that the new memory locations are indeed undeﬁned in the original
reduction. (They may, however, appear in the image of µ.) The last premise
ensures that the new memory locations in µ′′ do not accidentally carry the
same names as the locations allocated during the original reduction step, that
is, the locations in dom(µ′ \ µ). The notation A # B stands for A ∩B = .
Rule R-Context completes the deﬁnition of the operational semantics by
deﬁning −−▶, a relation between closed conﬁgurations, in terms of -→. The
rule states that reduction may take place not only at the term’s root, but also
deep inside it, provided the path from the root to the point where reduction
occurs forms an evaluation context. This is how evaluation contexts deter-
mine an evaluation strategy. As a purely technical point, because −−▶relates
closed conﬁgurations only, we do not need to require that the memory lo-
cations in dom(µ′ \ µ) be fresh for E; indeed, every memory location that
appears within E must be a member of dom(µ).
10.1.4
Example [Integers, continued]: The operational semantics of integer addi-
tion may be deﬁned as follows:
ˆk1 ˆ+ ˆk2
δ-→\
k1 + k2
(R-Add)
The left-hand term is the double application ˆ+ ˆk1 ˆk2, while the right-hand
term is the integer literal ˆk, where k is the sum of k1 and k2. The distinction
between object level and meta level (that is, between ˆk and k) is needed here
to avoid ambiguity.
2
10.1.5
Example [Pairs, continued]: In addition to the pair constructor deﬁned in
Example 10.1.3, we may introduce two destructors π1 and π2 of arity 1. We
may deﬁne their operational semantics as follows, for i ∈{1, 2}:
πi (v1, v2)
δ-→vi
(R-Proj)
Thus, our treatment of constants is general enough to account for pair con-
struction and destruction; we need not build these features explicitly into the
language.
2
10.1.6
Exercise [Booleans, Recommended, ««, 3]: Let true and false be nullary
constructors. Let if be a ternary destructor. Extend the semantics with
if true v1 v2
δ-→v1
(R-True)
if false v1 v2
δ-→v2
(R-False)
Let us use the syntactic sugar if t0 then t1 else t2 for the triple applica-
tion of if t0 t1 t2. Explain why these deﬁnitions do not quite provide the
expected behavior. Without modifying the semantics of if, suggest a new

398
10
The Essence of ML Type Inference
deﬁnition of the syntactic sugar if t0 then t1 else t2 that corrects the
problem.
2
10.1.7
Example [Sums]: Booleans may in fact be viewed as a special case of the more
general concept of sum. Let inj1 and inj2 be unary constructors, called re-
spectively left and right injections. Let case be a ternary destructor, whose
semantics is deﬁned as follows, for i ∈{1, 2}:
case (inji v) v1 v2
δ-→vi v
(R-Case)
Here, the value inji v is being scrutinized, while the values v1 and v2, which
are typically functions, represent the two arms of a standard case construct.
The rule selects an appropriate arm (here, vi) based on whether the value un-
der scrutiny was formed using a left or right injection. The arm vi is executed
and given access to the data carried by the injection (here, v).
2
10.1.8
Exercise [«, 3]: Explain how to encode true, false, and the if construct
in terms of sums. Check that the behavior of R-True and R-False is properly
emulated.
2
10.1.9
Example [References]: Let ref and ! be unary destructors. Let := be a binary
destructor. We write t1 := t2 for the double application := t1 t2. Deﬁne the
operational semantics of these three destructors as follows:
ref v/
δ-→m/(m , v)
if m is fresh for v
(R-Ref)
!m/(m , v)
δ-→v/(m , v)
(R-Deref)
m := v/(m , v0)
δ-→v/(m , v)
(R-Assign)
According to R-Ref, evaluating ref v allocates a fresh memory location m and
binds v to it. The name m must be chosen fresh for v to prevent inadvertent
capture of the memory locations that appear free within v. By R-Deref, evalu-
ating !m returns the value bound to the memory location m within the current
store. By R-Assign, evaluating m := v discards the value v0 currently bound to
m and produces a new store where m is bound to v. Here, the value returned
by the assignment m := v is v itself; in ML-the-programming-language, it is
usually a nullary constructor (), pronounced unit.
2
10.1.10
Example [Recursion]: Let fix be a binary destructor, whose operational se-
mantics is:
fix v1 v2
δ-→v1 (fix v1) v2
(R-Fix)
fix is a ﬁxpoint combinator: it eﬀectively allows recursive deﬁnitions of
functions. Indeed, the construct letrec f = λz.t1 in t2 provided by ML-
the-programming-language may be viewed as syntactic sugar for let f =
fix (λf.λz.t1) in t2.
2

10.1
What Is ML?
399
10.1.11
Exercise [Recommended, ««, 3]: Assuming the availability of Booleans and
conditionals, integer literals, subtraction, multiplication, integer comparison,
and a ﬁxpoint combinator, most of which were deﬁned in previous exam-
ples, deﬁne a function that computes the factorial of its integer argument,
and apply it to ˆ3. Determine, step by step, how this expression reduces to a
value.
2
It is straightforward to check that, if t/µ reduces to t′/µ′, then t is not a
value. In other words, values are irreducible: they represent completed com-
putations. The proof is left as an exercise to the reader. The converse, how-
ever, does not hold: if the closed conﬁguration t/µ is irreducible with respect
to −−▶, then t is not necessarily a value. In that case, the conﬁguration t/µ is
said to be stuck. It represents a runtime error, that is, a situation that does not
allow computation to proceed, yet is not considered a valid outcome. A closed
source program t is said to go wrong if and only if the initial conﬁguration
t/ reduces to a stuck conﬁguration.
10.1.12
Example: Runtime errors typically arise when destructors are applied to ar-
guments of an unexpected nature. For instance, the expressions ˆ+ ˆ1 m and
π1 ˆ2 and !ˆ3 are stuck, regardless of the current store. The program let z =
ˆ+ ˆ+ in z 1 is not stuck, because ˆ+ ˆ+ is a value. However, its reduct through
R-Let is ˆ+ ˆ+ 1, which is stuck, so this program goes wrong. The primary
purpose of type systems is to prevent such situations from arising.
2
10.1.13
Remark: The conﬁguration !m/µ is stuck if m is not in the domain of µ. In
that case, however, !m/µ is not closed. Because we consider −−▶as a rela-
tion between closed conﬁgurations only, this situation cannot arise. In other
words, the semantics of ML-the-calculus never allows the creation of dan-
gling pointers. As a result, no particular precautions need be taken to guard
against them. Several strongly typed programming languages do neverthe-
less allow dangling pointers in a controlled fashion (Tofte and Talpin, 1997;
Walker, Crary, and Morrisett, 2000; DeLine and Fähndrich, 2001; Grossman,
Morrisett, Jim, Hicks, Wang, and Cheney, 2002).
2
Damas and Milner’s Type System
ML-the-type-system was originally deﬁned by Milner (1978). Here, we repro-
duce the deﬁnition given a few years later by Damas and Milner (1982), which
is written in a more standard style: typing judgments are deﬁned inductively
by a collection of typing rules. We refer to this type system as DM.
We must ﬁrst deﬁne types. In DM, types are terms built out of type con-
structors and type variables. Furthermore, they are ﬁrst-order terms: that is,

400
10
The Essence of ML Type Inference
in the grammar of types, none of the productions binds a type variable. This
situation is identical to that of the simply-typed λ-calculus.
We begin with several considerations concerning the speciﬁcation of type
constructors.
First, we do not wish to ﬁx the set of type constructors. Certainly, since
ML-the-calculus has functions, we need to be able to form an arrow type
T →T′ out of arbitrary types T and T′; that is, we need a binary type con-
structor →. However, because ML-the-calculus includes an unspeciﬁed set of
constants, we cannot say much else in general. If constants include integer
literals and integer operations, as in Example 10.1.1, then a nullary type con-
structor int is needed; if they include pair construction and destruction, as in
Examples 10.1.3 and 10.1.5, then a binary type constructor × is needed; etc.
Second, it is common to refer to the parameters of a type constructor by
position, that is, by numeric index. For instance, when one writes T →T′, it
is understood that the type constructor →has arity 2, that T is its ﬁrst pa-
rameter, known as its domain, and that T′ is its second parameter, known as
its codomain. Here, however, we refer to parameters by names, known as di-
rections. For instance, we deﬁne two directions domain and codomain and let
the type constructor →have arity {domain, codomain}. The extra generality
aﬀorded by directions is exploited in the deﬁnition of nonstructural subtyp-
ing (Example 10.2.9) and in the deﬁnition of rows (§10.8).
Last, we allow types to be classiﬁed using kinds. As a result, every type
constructor must come not only with an arity, but with a richer signature,
which describes the kinds of the types to which it is applicable and the
kind of the type that it produces. A distinguished kind ⋆is associated with
“normal” types, that is, types that are directly ascribed to expressions and
values. For instance, the signature of the type constructor →is {domain ,
⋆, codomain , ⋆} ⇒⋆, because it is applicable to two normal types and
produces a normal type. Introducing kinds other than ⋆allows viewing some
types as ill-formed: this is illustrated, for instance, in §10.8. In the simplest
case, however, ⋆is really the only kind, so the signature of a type constructor
is nothing but its arity (a set of directions), and every term is a well-formed
type, provided every application of a type constructor respects its arity.
10.1.14
Definition: Let d range over a ﬁnite or denumerable set of directions and κ
over a ﬁnite or denumerable set of kinds. Let ⋆be a distinguished kind. Let K
range over partial mappings from directions to kinds. Let F range over a ﬁnite
or denumerable set of type constructors, each of which has a signature of the
form K ⇒κ. The domain of K is called the arity of F, while κ is referred to
as its image kind. We write κ instead of K ⇒κ when K is empty. Let →be a
type constructor of signature {domain , ⋆, codomain , ⋆} ⇒⋆.
2

10.1
What Is ML?
401
The type constructors and their signatures collectively form a signature S.
In the following, we assume that a ﬁxed signature S is given and that every
type constructor in it has ﬁnite arity, so as to ensure that types are machine
representable. However, in §10.8, we shall explicitly work with several distinct
signatures, one of which involves type constructors of denumerable arity.
A type variable is a name that is used to stand for a type. For simplicity,
we assume that every type variable is branded with a kind, or in other words,
that type variables of distinct kinds are drawn from disjoint sets. Each of
these sets of type variables is individually subject to α-conversion: that is,
renamings must preserve kinds. Attaching kinds to type variables is only a
technical convenience; in practice, every operation performed during type
inference preserves the property that every type is well-kinded, so it is not
necessary to keep track of the kind of every type variable. It is only necessary
to check that all types supplied by the programmer, within type declarations,
type annotations, or module interfaces, are well-kinded.
10.1.15
Definition: For every kind κ, let Vκ be a disjoint, denumerable set of type
variables. Let X, Y, and Z range over the set V of all type variables. Let ¯X and
¯Y range over ﬁnite sets of type variables. We write ¯X¯Y for the set ¯X ∪¯Y and
often write X for the singleton set {X}. We write ftv(o) for the set of free type
variables of an object o.
2
The set of types, ranged over by T, is the free many-kinded term algebra
that arises out of the type constructors and type variables. Types are given
by the following inductive deﬁnition:
10.1.16
Definition: A type of kind κ is either a member of Vκ, or a term of the form
F {d1 , T1, . . . , dn , Tn}, where F has signature {d1 , κ1, . . . , dn , κn} ⇒κ
and T1, . . . , Tn are types of kind κ1, . . . , κn, respectively.
2
As a notational convention, we assume that, for every type constructor F,
the directions that form the arity of F are implicitly ordered, so that we may
say that F has signature κ1 ⊗. . . ⊗κn ⇒κ and employ the syntax F T1 . . . Tn
for applications of F. Applications of the type constructor →are written inﬁx
and associate to the right, so T →T′ →T′′ stands for T →(T′ →T′′).
In order to give meaning to the free type variables of a type, or more gen-
erally, of a typing judgment, traditional presentations of ML-the-type-system,
including Damas and Milner’s, employ type substitutions. Most of our pre-
sentation avoids substitutions and uses constraints instead. However, we do
need substitutions on a few occasions, especially when relating our presenta-
tion to Damas and Milner’s.
10.1.17
Definition: A type substitution θ is a total, kind-preserving mapping of type
variables to types that is the identity everywhere but on a ﬁnite subset of V ,

402
10
The Essence of ML Type Inference
which we call the domain of θ and write dom(θ). The range of θ, which we
write range(θ), is the set ftv(θ(dom(θ))). A type substitution may naturally
be viewed as a total, kind-preserving mapping of types to types.
2
If ⃗X and ⃗T are respectively a vector of distinct type variables and a vector
of types of the same (ﬁnite) length such that, for every index i, Xi and Ti
have the same kind, then [⃗X , ⃗T] denotes the substitution that maps Xi to
Ti for every index i and is the identity elsewhere. The domain of [⃗X , ⃗T] is
a subset of ¯X, the set underlying the vector ⃗X. Its range is a subset of ftv(¯T),
where ¯T is the set underlying the vector ⃗T. (These may be strict subsets; for
instance, the domain of [X , X] is the empty set, since this substitution is the
identity.) Every substitution θ may be written under the form [⃗X , ⃗T], where
¯X = dom(θ). Then, θ is idempotent if and only if ¯X # ftv(¯T) holds.
As pointed out earlier, types are ﬁrst-order terms. As a result, every type
variable that appears within a type T appears free within T. Things become
more interesting when we introduce type schemes. As its name implies, a
type scheme may describe an entire family of types; this eﬀect is achieved via
universal quantiﬁcation over a set of type variables.
10.1.18
Definition: A type scheme S is an object of the form ∀¯X.T, where T is a type
of kind ⋆and the type variables ¯X are considered bound within T. Any type
of the form [⃗X , ⃗T]T is called an instance of the type scheme ∀¯X.T.
2
One may view the type T as the trivial type scheme ∀.T, where no type vari-
ables are universally quantiﬁed, so types of kind ⋆may be viewed as a subset
of type schemes. The type scheme ∀¯X.T may be viewed as a ﬁnite way of
describing the possibly inﬁnite family of its instances. Note that, throughout
most of this chapter, we work with constrained type schemes, a generalization
of DM type schemes (Deﬁnition 10.2.2).
Typing environments, or environments for short, are used to collect as-
sumptions about an expression’s free identiﬁers.
10.1.19
Definition: An environment Γ is a ﬁnite ordered sequence of pairs of a pro-
gram identiﬁer and a type scheme. We write  for the empty environment and
“;” for the concatenation of environments. An environment may be viewed as
a ﬁnite mapping from program identiﬁers to type schemes by letting Γ(x) = S
if and only if Γ is of the form Γ1; x : S; Γ2, where Γ2 contains no assumption
about x. The set of deﬁned program identiﬁers of an environment Γ, written
dpi(Γ), is deﬁned by dpi() =  and dpi(Γ; x : S) = dpi(Γ) ∪{x}.
2
To complete the deﬁnition of Damas and Milner’s type system, there re-
mains to deﬁne typing judgments. A typing judgment takes the form Γ ⊢t : S,
where t is an expression of interest, Γ is an environment, which typically con-
tains assumptions about t’s free program identiﬁers, and S is a type scheme.

10.1
What Is ML?
403
Γ(x) = S
Γ ⊢x : S
(dm-Var)
Γ; z : T ⊢t : T′
Γ ⊢λz.t : T →T′
(dm-Abs)
Γ ⊢t1 : T →T′
Γ ⊢t2 : T
Γ ⊢t1 t2 : T′
(dm-App)
Γ ⊢t1 : S
Γ; z : S ⊢t2 : T
Γ ⊢let z = t1 in t2 : T
(dm-Let)
Γ ⊢t : T
¯X # ftv(Γ)
Γ ⊢t : ∀¯X.T
(dm-Gen)
Γ ⊢t : ∀¯X.T
Γ ⊢t : [⃗X , ⃗T]T
(dm-Inst)
Figure 10-3: Typing rules for DM
Such a judgment may be read: under assumptions Γ, the expression t has the
type scheme S. By abuse of language, it is sometimes said that t has type S.
A typing judgment is valid (or holds) if and only if it may be derived using
the rules that appear in Figure 10-3. An expression t is well-typed within the
environment Γ if and only if there exists some type scheme S such that the
judgment Γ ⊢t : S holds; it is ill-typed within Γ otherwise.
Rule dm-Var allows fetching a type scheme for an identiﬁer x from the
environment. It is equally applicable to program variables, memory locations,
and constants. If no assumption concerning x appears in the environment
Γ, then the rule isn’t applicable. In that case, the expression x is ill-typed
within Γ. Assumptions about constants are usually collected in a so-called ini-
tial environment Γ0. It is the environment under which closed programs are
typechecked, so every subexpression is typechecked under some extension Γ
of Γ0. Of course, the type schemes assigned by Γ0 to constants must be con-
sistent with their operational semantics; we say more about this later (§10.5).
Rule dm-Abs speciﬁes how to typecheck a λ-abstraction λz.t. Its premise re-
quires the body of the function, t, to be well-typed under an extra assumption
that causes all free occurrences of z within t to receive a common type T. Its
conclusion forms the arrow type T →T′ out of the types of the function’s
formal parameter, T, and result, T′. It is worth noting that this rule always
augments the environment with a type T—recall that, by convention, types
form a subset of type schemes—but never with a nontrivial type scheme.
Rule dm-App states that the type of a function application is the codomain
of the function’s type, provided that the domain of the function’s type is a
valid type for the actual argument. Rule dm-Let closely mirrors the opera-
tional semantics: whereas the semantics of the local deﬁnition let z = t1
in t2 is to augment the runtime environment by binding z to the value of
t1 prior to evaluating t2, the eﬀect of dm-Let is to augment the typing envi-

404
10
The Essence of ML Type Inference
ronment by binding z to a type scheme for t1 prior to typechecking t2. Rule
dm-Gen turns a type into a type scheme by universally quantifying over a set
of type variables that do not appear free in the environment; this restriction
is discussed in Example 10.1.20 below. Rule dm-Inst, on the contrary, turns a
type scheme into one of its instances, which may be chosen arbitrarily. These
two operations are referred to as generalization and instantiation. The no-
tion of type scheme and the rules dm-Gen and dm-Inst are characteristic of
ML-the-type-system: they distinguish it from the simply-typed λ-calculus.
10.1.20
Example: It is unsound to allow generalizing type variables that appear free
in the environment. For instance, consider the typing judgment z : X ⊢z :
X (1), which, according to dm-Var, is valid. Applying an unrestricted version
of dm-Gen to it, we obtain z : X ⊢z : ∀X.X (2), whence, by dm-Inst, z : X ⊢
z : Y (3). By dm-Abs and dm-Gen, we then have  ⊢λz.z : ∀XY.X →Y. In
other words, the identity function has unrelated argument and result types!
Then, the expression (λz.z) ˆ0 ˆ0, which reduces to the stuck expression ˆ0 ˆ0,
has type scheme ∀Z.Z. So, well-typed programs may cause runtime errors:
the type system is unsound.
What happened? It is clear that the judgment (1) is correct only because
the type assigned to z is the same in its assumption and in its right-hand
side. For the same reason, the judgments (2) and (3)—the former of which
may be written z : X ⊢z : ∀Y.Y—are incorrect. Indeed, such judgments defeat
the very purpose of environments, since they disregard their assumption.
By universally quantifying over X in the right-hand side only, we break the
connection between occurrences of X in the assumption, which remain free,
and occurrences in the right-hand side, which become bound. This is correct
only if there are in fact no free occurrences of X in the assumption.
2
10.1.21
Remark: A naive implementation of dm-Gen would traverse the environment
Γ in order to compute the set of its free type variables. However, the num-
ber of entries in Γ may be linear in the program size, so, even if types have
bounded size, the time required by this computation may be linear in the
program size. Since it is performed at every let node, this naive approach
gives type inference quadratic time complexity. To avoid this pitfall, our con-
straint solver annotates every type variable with an integer rank, which allows
telling, in constant time, whether it appears free in Γ (page 444).
2
It is a key feature of ML-the-type-system that dm-Abs may only introduce a
type T, rather than a type scheme, into the environment. Indeed, this allows
the rule’s conclusion to form the arrow type T →T′. If instead the rule were
to introduce the assumption z : S into the environment, then its conclusion
would have to form S →T′, which is not a well-formed type. In other words,

10.1
What Is ML?
405
this restriction is necessary to preserve the stratiﬁcation between types and
type schemes. If we were to remove this stratiﬁcation, thus allowing univer-
sal quantiﬁers to appear deep inside types, we would obtain an implicitly-
typed version of System F (TAPL, Chapter 23). Type inference for System F
is undecidable (Wells, 1999), while type inference for ML-the-type-system is
decidable, as we show later, so this design choice has a rather drastic impact.
10.1.22
Exercise [Recommended, «]: Build a type derivation for the expression λz1.
let z2 = z1 in z2.
2
10.1.23
Exercise [Recommended, «]: Let int be a nullary type constructor of signa-
ture ⋆. Let Γ0 consist of the bindings ˆ+ : int →int →int and ˆk : int, for every
integer k. Can you ﬁnd derivations of the following valid typing judgments?
Which of these judgments are valid in the simply-typed λ-calculus, where
let z = t1 in t2 is syntactic sugar for (λz.t2) t1?
Γ0 ⊢λz.z : int →int
Γ0 ⊢λz.z : ∀X.X →X
Γ0 ⊢let f = λz.zˆ+ˆ1 in f ˆ2 : int
Γ0 ⊢let f = λz.z in f f ˆ2 : int
Show that the expressions ˆ1 ˆ2 and λf.(f f) are ill-typed within Γ0. Could these
expressions be well-typed in a more powerful type system?
2
DM enjoys a number of nice theoretical properties, which have practical
implications.
First, it is sound: that is, well-typed programs do not go wrong. This essen-
tial property ensures that programs that are accepted by the typechecker may
be compiled without runtime checks. Establishing this property requires (i)
suitable hypotheses about the semantics of constants and the type schemes
assigned to constants in the initial environment, and (ii) in the presence of
side eﬀects, a slight restriction of the syntax of let constructs, known as the
value restriction.
Furthermore, there exists an algorithm that, given a (closed) environment Γ
and a program t, tells whether t is well-typed with respect to Γ, and if so, pro-
duces a principal type scheme S. A principal type scheme is such that (i) it is
valid, that is, Γ ⊢t : S holds, and (ii) it is most general, that is, every judgment
of the form Γ ⊢t : S′ follows from Γ ⊢t : S by dm-Inst and dm-Gen. (For the
sake of simplicity, we have stated the properties of the type inference algo-
rithm only in the case of a closed environment Γ; the speciﬁcation is slightly
heavier in the general case.) This implies that type inference is decidable: the
compiler need not require expressions to be annotated with types. The fact
that, under a ﬁxed environment Γ, all of the type information associated with

406
10
The Essence of ML Type Inference
an expression t may be summarized in the form of a single, principal type
scheme is also key to modular programming. Indeed, exporting a value out
of a module requires explicitly assigning a type scheme to it as part of the
module’s signature. If the chosen type scheme is not principal, then part of
the value’s (hence, of the module’s) potential for reuse is lost.
Road Map
Before proving the above claims, we ﬁrst generalize our presentation by mov-
ing to a constraint-based setting. The necessary tools—the constraint lan-
guage, its interpretation, and a number of constraint equivalence laws—are
introduced in §10.2. In §10.3, we describe the standard constraint-based type
system HM(X) (Odersky, Sulzmann, and Wehr, 1999). We prove that, when
constraints are made up of equations between free, ﬁnite terms, HM(X) is
a reformulation of DM. In the presence of a more powerful constraint lan-
guage, HM(X) is an extension of DM. In §10.4, we show that type inference
may be viewed as a combination of constraint generation and constraint solv-
ing, as promised earlier. Then, in §10.5, we give a type soundness theorem. It
is stated purely in terms of constraints, but—thanks to the results developed
in the previous sections—applies equally to HM(X) and DM.
Throughout this core material, the syntax and interpretation of constraints
are left partly unspeciﬁed. Thus, the development is parameterized with re-
spect to them—hence the unknown X in the name HM(X). We really describe
a family of constraint-based type systems, all of which share a common con-
straint generator and a common type soundness proof. Constraint solving,
however, cannot be independent of X: on the contrary, the design of an ef-
ﬁcient solver is heavily dependent on the syntax and interpretation of con-
straints. In §10.6, we consider constraint solving in the particular case where
constraints are made up of equations interpreted in a free tree model, and
deﬁne a constraint solver on top of a standard ﬁrst-order uniﬁcation algo-
rithm.
The remainder of this chapter deals with extensions of the framework. In
§10.7, we explain how to extend ML-the-calculus with a number of features,
including products, sums, references, recursion, algebraic data types, and re-
cursive types. Last, in §10.8, we extend the type language with rows and use
them to assign polymorphic type schemes to operations on records and vari-
ants.

10.2
Constraints
407
σ
::=
type scheme:
∀¯X[C].T
C, D
::=
constraint:
true
truth
false
falsity
P T1 . . . Tn
predicate application
C ∧C
conjunction
∃¯X.C
existential quantiﬁcation
def x : σ in C type scheme introduction
x ⪯T
type scheme instantiation
C, D ::=
Syntactic sugar for constraints:
. . .
As before
σ ⪯T
Deﬁnition 10.2.3
let x : σ in C
Deﬁnition 10.2.3
∃σ
Deﬁnition 10.2.3
def Γ in C
Deﬁnition 10.2.4
let Γ in C
Deﬁnition 10.2.4
∃Γ
Deﬁnition 10.2.4
Figure 10-4: Syntax of type schemes and constraints
10.2
Constraints
In this section, we deﬁne the syntax and logical meaning of constraints. Both
are partly unspeciﬁed. Indeed, the set of type constructors (Deﬁnition 10.1.14)
must contain at least the binary type constructor →, but might contain more.
Similarly, the syntax of constraints involves a set of so-called predicates on
types, which we require to contain at least a binary subtyping predicate ≤, but
might contain more. (The introduction of subtyping, which is absent in DM,
has little impact on the complexity of our proofs, yet increases the frame-
work’s expressive power. When subtyping is not desired, we interpret the
predicate ≤as equality.) The logical interpretation of type constructors and
of predicates is left almost entirely unspeciﬁed. This freedom allows reason-
ing not only about Damas and Milner’s type system, but also about a family
of constraint-based extensions of it.
Syntax of Constraints
We now deﬁne the syntax of constrained type schemes and of constraints and
introduce some extra constraint forms as syntactic sugar.
10.2.1
Definition: Let P range over a ﬁnite or denumerable set of predicates, each
of which has a signature of the form κ1 ⊗. . . ⊗κn ⇒·, where n ≥0. For every
kind κ, let =κ and ≤κ be distinguished predicates of signature κ ⊗κ ⇒·.
2
10.2.2
Definition: The syntax of type schemes and constraints is given in Figure 10-4.
It is further restricted by the following requirements. In the type scheme
∀¯X[C].T and in the constraint x ⪯T, the type T must have kind ⋆. In the con-

408
10
The Essence of ML Type Inference
straint P T1 . . . Tn, the types T1, . . . , Tn must have kind κ1, . . . , κn, respectively,
if P has signature κ1⊗. . .⊗κn ⇒·. We write ∀¯X.T for ∀¯X[true].T, which allows
viewing DM type schemes as a subset of constrained type schemes.
2
We write T1 =κ T2 and T1 ≤κ T2 for the binary predicate applications =κ T1 T2
and ≤κ T1 T2, and refer to them as equality and subtyping constraints, respec-
tively. We often omit the subscript κ, so T1 = T2 and T1 ≤T2 are well-formed
constraints whenever T1 and T2 have the same kind. By convention, ∃and def
bind tighter than ∧; that is, ∃¯X.C ∧D is (∃¯X.C) ∧D and def x : σ in C ∧D
is (def x : σ in C) ∧D. In ∀¯X[C].T, the type variables ¯X are bound within
C and T. In ∃¯X.C, the type variables ¯X are bound within C. The sets of free
type variables of a type scheme σ and of a constraint C, written ftv(σ) and
ftv(C), respectively, are deﬁned accordingly. In def x : σ in C, the identiﬁer
x is bound within C. The sets of free program identiﬁers of a type scheme
σ and of a constraint C, written fpi(σ) and fpi(C), respectively, are deﬁned
accordingly. Note that x occurs free in the constraint x ⪯T.
The constraint true, which is always satisﬁed, mainly serves to indicate
the absence of a nontrivial constraint, while false, which has no solution,
may be understood as the indication of a type error. Composite constraints
include conjunction and existential quantiﬁcation, which have their standard
meaning, as well as type scheme introduction and type scheme instantiation
constraints, which are similar to Gustavsson and Svenningsson’s constraint
abstractions (2001). In order to be able to explain these last two forms, we
must ﬁrst introduce a number of derived constraint forms:
10.2.3
Definition: Let σ be ∀¯X[D].T. If ¯X # ftv(T′) holds, then σ ⪯T′ (read: T′ is an
instance of σ) stands for the constraint ∃¯X.(D ∧T ≤T′). We write ∃σ (read: σ
has an instance) for ∃¯X.D and let x : σ in C for ∃σ ∧def x : σ in C.
2
Constrained type schemes generalize Damas and Milner’s type schemes, while
this deﬁnition of instantiation constraints generalizes Damas and Milner’s no-
tion of instance (Deﬁnition 10.1.18). Let us draw a comparison. First, Damas
and Milner’s instance relation is binary (given a type scheme S and a type T,
either T is an instance of S, or it isn’t), and is purely syntactic. For instance,
the type Y →Z is not an instance of ∀X.X →X in Damas and Milner’s sense,
because Y and Z are distinct type variables. In our presentation, on the other
hand, ∀X.X →X ⪯Y →Z is not an assertion; rather, it is a constraint, which
by deﬁnition is ∃X.(true ∧X →X ≤Y →Z). We later prove that it is equivalent
to ∃X.(Y ≤X∧X ≤Z) and to Y ≤Z, and, if subtyping is interpreted as equality,
to Y = Z. That is, σ ⪯T′ represents a condition on (the ground types denoted
by) the type variables in ftv(σ, T′) for T′ to be an instance of σ, in a logical,
rather than purely syntactic, sense. Second, the deﬁnition of instantiation

10.2
Constraints
409
constraints involves subtyping, to ensure that any supertype of an instance
of σ is again an instance of σ (see rule C-ExTrans on page 418). This is con-
sistent with the purpose of subtyping: to allow a subtype where a supertype
is expected (TAPL, Chapter 15). Third and last, every type scheme σ is now
of the form ∀¯X[C].T. The constraint C, whose free type variables may or may
not be members of ¯X, is meant to restrict the set of instances of the type
scheme ∀¯X[C].T. This is evident in the instantiation constraint ∀¯X[C].T ⪯T′,
which by Deﬁnition 10.2.3 stands for ∃¯X.(C ∧T ≤T′): the values that ¯X may
assume are restricted by the demand that C be satisﬁed. This requirement
vanishes in the case of DM type schemes, where C is true. Our notions of con-
strained type scheme and of instantiation constraint are standard, coinciding
with those of HM(X) (Odersky, Sulzmann, and Wehr, 1999).
Let us now come back to an explanation of type scheme introduction and
instantiation constraints. In brief, the construct def x : σ in C binds the name
x to the type scheme σ within the constraint C. If C contains a subconstraint
of the form x ⪯T, where this occurrence of x is free in C, then this subcon-
straint acquires the meaning σ ⪯T. Thus, the constraint x ⪯T is indeed an
instantiation constraint, where the type scheme that is being instantiated is
referred to by name. The constraint def x : σ in C may be viewed as an ex-
plicit substitution of the type scheme σ for the name x within C. Later (§10.4),
we use such explicit substitutions to supplant typing environments. That is,
where Damas and Milner’s type system augments the current typing envi-
ronment (dm-Abs, dm-Let), we introduce a new def binding in the current
constraint; where it looks up the current typing environment (dm-Var), we
employ an instantiation constraint. (The reader may wish to look ahead at Fig-
ure 10-9 on page 431.) The point is that it is then up to a constraint solver to
choose a strategy for reducing explicit substitutions—for instance, one might
wish to simplify σ before substituting it for x within C—whereas the use of
environments in standard type systems such as DM and HM(X) imposes an
eager substitution strategy, which is ineﬃcient and thus never literally imple-
mented. The use of type scheme introduction and instantiation constraints
allows separating constraint generation and constraint solving without com-
promising eﬃciency, or, in other words, without introducing a gap between
the description of the type inference algorithm and its actual implementation.
Although the algorithm that we plan to describe is not new (Rémy, 1992a), its
description in terms of constraints is: to the best of our knowledge, the only
close relative of our def constraints is to be found in Gustavsson and Sven-
ningsson (2001). An earlier work that contains similar ideas is Müller (1994).
Approaches based on semi-uniﬁcation (Henglein, 1989, 1993) achieve a simi-
lar separation between constraint generation and constraint solving, but are
based on a rather diﬀerent constraint language.

410
10
The Essence of ML Type Inference
In the type system of Damas and Milner, every type scheme S has a ﬁxed,
nonempty set of instances. In a constraint-based setting, things are more
complex: given a type scheme σ and a type T, whether T is an instance
of σ (that is, whether the constraint σ ⪯T is satisﬁed) depends on the
meaning assigned to the type variables in ftv(σ, T). Similarly, given a type
scheme, whether some type is an instance of σ (that is, whether the con-
straint ∃Z.σ ⪯Z, where Z is fresh for σ, is satisﬁed) depends on the meaning
assigned to the type variables in ftv(σ). Because we do not wish to allow
forming type schemes that have no instances, we often use the constraint
∃Z.σ ⪯Z. In fact, we later prove that it is equivalent to ∃σ, as deﬁned above.
We also use the constraint form let x : σ in C, which requires σ to have an
instance and at the same time associates it with the name x. Because the def
form is more primitive, it is easier to work with at a low level, but it is no
longer explicitly used after §10.2; we always use let instead.
10.2.4
Definition: Environments Γ remain as in Deﬁnition 10.1.19, except DM type
schemes S are replaced with constrained type schemes σ. The set of free
program identiﬁers of an environment Γ, written fpi(Γ), is deﬁned by fpi() =
 and fpi(Γ; x : σ) = fpi(Γ) ∪fpi(σ). We write dfpi(Γ) for dpi(Γ) ∪fpi(Γ). We
deﬁne def  in C as C and def Γ; x : σ in C as def Γ in def x : σ in C. Similarly,
we deﬁne let  in C as C and let Γ; x : σ in C as let Γ in let x : σ in C. We deﬁne
∃ as true and ∃(Γ; x : σ) as ∃Γ ∧def Γ in ∃σ.
2
In order to establish or express certain laws of equivalence between con-
straints, we need constraint contexts. A constraint context is a constraint with
zero, one, or several holes, written []. The syntax of contexts is as follows:
C ::= [] | C | C ∧C | ∃¯X.C | def x : σ in C | def x : ∀¯X[C].T in C
The application of a constraint context C to a constraint C, written C[C], is
deﬁned in the usual way. Because a constraint context may have any number
of holes, C may disappear or be duplicated in the process. Because a hole
may appear in the scope of a binder, some of C’s free type variables and free
program identiﬁers may become bound in C[C]. We write dtv(C) and dpi(C)
for the sets of type variables and program identiﬁers, respectively, that C may
thus capture. We write let x : ∀¯X[C].T in C for ∃¯X.C ∧def x : ∀¯X[C].T in C.
(Being able to state such a deﬁnition is why we require multi-hole contexts.)
We let X range over existential constraint contexts, deﬁned by X ::= ∃¯X.[].
Meaning of Constraints
We have deﬁned the syntax of constraints and given an informal description
of their meaning. We now give a formal deﬁnition of the interpretation of
constraints. We begin with the deﬁnition of a model:

10.2
Constraints
411
10.2.5
Definition: For every kind κ, let Mκ be a nonempty set, whose elements
are called the ground types of kind κ. In the following, t ranges over Mκ, for
some κ that may be determined from the context. For every type constructor
F of signature K ⇒κ, let F denote a total function from MK into Mκ, where
the indexed product MK is the set of all mappings T of domain dom(K) that
map every d ∈dom(K) to an element of MK(d). For every predicate symbol
P of signature κ1 ⊗. . . ⊗κn ⇒·, let P denote a predicate on Mκ1 × . . . × Mκn.
For every kind κ, we require the predicate =κ to be equality on Mκ and the
predicate ≤κ to be a partial order on Mκ.
2
For the sake of convenience, we abuse notation and write F for both the
type constructor and its interpretation, and similarly for predicates.
By varying the set of type constructors, the set of predicates, the set of
ground types, and the interpretation of type constructors and predicates, one
may deﬁne an entire family of related type systems. We refer to the collection
of these choices as X. Thus, the type system HM(X), described in §10.3, is
parameterized by X.
The following examples give standard ways of deﬁning the set of ground
types and the interpretation of type constructors.
10.2.6
Example [Syntactic models]: For every kind κ, let Mκ consist of the closed
types of kind κ. Then, ground types are types that do not have any free type
variables, and form the so-called Herbrand universe. Let every type construc-
tor F be interpreted as itself. Models that deﬁne ground types and interpret
type constructors in this manner are referred to as syntactic.
2
10.2.7
Example [Tree models]: Let a path π be a ﬁnite sequence of directions. The
empty path is written ϵ and the concatenation of the paths π and π′ is written
π · π′. Let a tree be a partial function t from paths to type constructors
whose domain is nonempty and preﬁx-closed and such that, for every path
π in the domain of t, if the type constructor t(π) has signature K ⇒κ, then
π · d ∈dom(t) is equivalent to d ∈dom(K) and, furthermore, for every
d ∈dom(K), the type constructor t(π · d) has image kind K(d). If π is in
the domain of t, then the subtree of t rooted at π, written t/π, is the partial
function π′ , t(π · π′). A tree is ﬁnite if and only if it has ﬁnite domain. A
tree is regular if and only if it has a ﬁnite number of distinct subtrees. Every
ﬁnite tree is thus regular. Let Mκ consist of the ﬁnite (respectively regular)
trees t such that t(ϵ) has image kind κ: then, we have a ﬁnite (respectively
regular) tree model.
If F has signature K ⇒κ, one may interpret F as the function that maps
T ∈MK to the ground type t ∈Mκ deﬁned by t(ϵ) = F and t/d = T(d) for
d ∈dom(T), that is, the unique ground type whose head symbol is F and

412
10
The Essence of ML Type Inference
whose subtree rooted at d is T(d). Then, we have a free tree model. Note
that free ﬁnite tree models coincide with syntactic models, as deﬁned in the
previous example.
2
Rows (§10.8) are interpreted in a tree model, albeit not a free one. The fol-
lowing examples suggest diﬀerent ways of interpreting the subtyping predi-
cate.
10.2.8
Example [Equality models]: The simplest way of interpreting the subtyp-
ing predicate is to let ≤denote equality on every Mκ. Models that do so
are referred to as equality models. When no predicate other than equality is
available, we say that the model is equality-only.
2
10.2.9
Example [Structural, nonstructural subtyping]: Let a variance ν be a
nonempty subset of {−, +}, written −(contravariant), + (covariant), or ± (in-
variant) for short. Deﬁne the composition of two variances as an associative,
commutative operation with + as neutral element, ± as absorbing element
(that is, ±−= ±+ = ±± = ±), and such that −−= +. Now, consider a free
(ﬁnite or regular) tree model, where every direction d comes with a ﬁxed vari-
ance ν(d). Deﬁne the variance ν(π) of a path π as the composition of the
variances of its elements. Let à be a partial order on type constructors such
that (i) if F1 à F2 holds and F1 and F2 have signature K1 ⇒κ1 and K2 ⇒κ2, re-
spectively, then K1 and K2 agree on the intersection of their domains and κ1
and κ2 coincide; and (ii) F0 à F1 à F2 implies dom(F0) ∩dom(F2) ⊆dom(F1).
Let à+, à−, and à± stand for à, á, and =, respectively. Then, deﬁne the inter-
pretation of subtyping as follows: if t1, t2 ∈Mκ, let t1 ≤t2 hold if and only if,
for every path π ∈dom(t1) ∩dom(t2), t1(π) àν(π) t2(π) holds. It is not diﬃ-
cult to check that ≤is a partial order on every Mκ. The reader is referred to
Amadio and Cardelli (1993), Kozen, Palsberg, and Schwartzbach (1995), and
Brandt and Henglein (1997) for more details about this construction. Models
that deﬁne subtyping in this manner are referred to as nonstructural subtyp-
ing models.
A simple nonstructural subtyping model is obtained by: letting the direc-
tions domain and codomain be contra- and covariant, respectively; introduc-
ing, in addition to the type constructor →, two type constructors ⊥and ⊤of
signature ⋆; and letting ⊥à →à ⊤. This gives rise to a model where ⊥is the
least ground type, ⊤is the greatest ground type, and the arrow type construc-
tor is, as usual, contravariant in its domain and covariant in its codomain.
This form of subtyping is called nonstructural because comparable ground
types may have diﬀerent shapes: consider, for instance, ⊥and ⊥→⊤.
A typical use of nonstructural subtyping is in type systems for records. One
may, for instance, introduce a covariant direction content of kind ⋆, a kind

10.2
Constraints
413
◦, a type constructor abs of signature ◦, a type constructor pre of signature
{content , ⋆} ⇒◦, and let pre à abs. This gives rise to a model where
pre t ≤abs holds for every t ∈M⋆. Again, comparable ground types may
have diﬀerent shapes: consider, for instance, pre ⊤and abs. §10.8 says more
about typechecking operations on records.
Nonstructural subtyping has been studied, for example, in Kozen, Palsberg,
and Schwartzbach (1995), Palsberg, Wand, and O’Keefe (1997), Jim and Pals-
berg (1999), Pottier (2001b), Su et al. (2002), and Niehren and Priesnitz (2003).
An important particular case arises when any two type constructors related
by à have the same arity (and thus also the same signatures). In that case, it
is not diﬃcult to show that any two ground types related by subtyping must
have the same shape, that is, if t1 ≤t2 holds, then dom(t1) and dom(t2) must
coincide. For this reason, such an interpretation of subtyping is usually re-
ferred to as atomic or structural subtyping. It has been studied in the ﬁnite
(Mitchell, 1984, 1991b; Tiuryn, 1992; Pratt and Tiuryn, 1996; Frey, 1997; Re-
hof, 1997; Kuncak and Rinard, 2003; Simonet, 2003) and regular (Tiuryn and
Wand, 1993) cases. Structural subtyping is often used in automated program
analyses that enrich standard types with atomic annotations without altering
their shape.
2
Many other kinds of constraints exist, which we lack space to list; see
Comon (1994) for a short survey.
Throughout this chapter, we assume (unless otherwise stated) that the set
of type constructors, the set of predicates, and the model—which, together,
form the parameter X—are arbitrary, but ﬁxed.
As usual, the meaning of a constraint is a function of the meaning of its
free type variables and of its free program identiﬁers, which are respectively
given by a ground assignment and a ground environment.
10.2.10
Definition: A ground assignment φ is a total, kind-preserving mapping from
V into M. Ground assignments are extended to types by φ(F T1 . . . Tn) =
F(φ(T1), . . . , φ(Tn)). Then, for every type T of kind κ, φ(T) is a ground type
of kind κ.
A ground type scheme s is a set of ground types, which we require to be
upward-closed with respect to subtyping: that is, t ∈s and t ≤t′ must im-
ply t′ ∈s. A ground environment ψ is a partial mapping from identiﬁers to
ground type schemes.
Because the syntax of type schemes and constraints is mutually recursive,
so is their interpretation. The interpretation of a type scheme σ under a
ground assignment φ and a ground environment ψ is a ground type scheme,
written (φ, ψ)σ. It is deﬁned in Figure 10-5. The ↑is the upward closure

414
10
The Essence of ML Type Inference
Interpretation of type schemes:
(φ, ψ)(∀¯X[C].T) =
↑{φ[⃗X , ⃗t](T) ; φ[⃗X , ⃗t], ψ |= C}
Interpretation of constraints:
φ, ψ |= true
(CM-True)
P(φ(T1), . . . , φ(Tn))
φ, ψ |= P T1 . . . Tn
(CM-Predicate)
φ, ψ |= C1
φ, ψ |= C2
φ, ψ |= C1 ∧C2
(CM-And)
φ[⃗X , ⃗t], ψ |= C
φ, ψ |= ∃¯X.C
(CM-Exists)
φ, ψ[x , (φ, ψ)σ] |= C
φ, ψ |= def x : σ in C
(CM-Def)
φ(T) ∈ψ(x)
φ, ψ |= x ⪯T
(CM-Instance)
Figure 10-5: Meaning of constraints
operator and |= is the constraint satisfaction predicate, deﬁned next. The in-
terpretation of a constraint C under a ground assignment φ and a ground
environment ψ is a truth value, written φ, ψ |= C (read: φ and ψ satisfy C).
The three-place predicate |= is deﬁned by the rules in Figure 10-5. A con-
straint C is satisﬁable if and only if φ, ψ |= C holds for some φ and ψ. It is
false (or unsatisﬁable) otherwise.
2
Let us now explain these deﬁnitions. The interpretation of the type scheme
∀¯X[C].T is a set of ground types, which we may refer to as the type scheme’s
ground instances. It contains the images of T under extensions of φ with
new values for the universally quantiﬁed variables ¯X; these values may be
arbitrary, but must be such that the constraint C is satisﬁed. We implicitly
require ⃗X and ⃗t to have matching kinds, so that φ[⃗X , ⃗t] remains a kind-
preserving ground assignment. This set is upward closed, so any ground type
that lies above a ground instance of σ is also a ground instance of σ. This
interpretation is standard; see, for example, Pottier (2001a).
The rules that deﬁne |= (Figure 10-5) are syntax-directed. CM-True states
that the constraint true is a tautology, that is, holds in every context. No rule
matches the constraint false, which means that it holds in no context. CM-
Predicate states that the meaning of a predicate application is given by the
predicate’s interpretation within the model. More speciﬁcally, if P’s signature
is κ1 ⊗. . . ⊗κn ⇒·, then, by well-formedness of the constraint, every Ti is of
kind κi, so φ(Ti) is a ground type in Mκi. By Deﬁnition 10.2.5, P denotes a
predicate on Mκ1 × . . . × Mκn, so the rule’s premise is mathematically well-
formed. It is independent of ψ, which is natural, since a predicate application
has no free program identiﬁers. CM-And requires each of the conjuncts to be

10.2
Constraints
415
valid in isolation. CM-Exists allows the type variables ⃗X to denote arbitrary
ground types ⃗t within C, independently of their image through φ. CM-Def
deals with type scheme introduction constraints, of the form def x : σ in C.
It binds x, within C, to the ground type scheme currently denoted by σ. Last,
CM-Instance concerns type scheme instantiation constraints of the form x ⪯
T. Such a constraint is valid if and only if the ground type denoted by T is a
member of the ground type scheme denoted by x.
It is possible to prove that the constraints def x : σ in C and [x , σ]C have
the same meaning, where the latter denotes the capture-avoiding substitution
of σ for x throughout C. As a matter of fact, it would have been possible to
use this equivalence as a deﬁnition of the meaning of def constraints, but the
present style is pleasant as well. This conﬁrms our claim that the def form is
an explicit substitution form.
Because constraints lie at the heart of our treatment of ML-the-type-system,
most of our proofs involve establishing logical properties of constraints.
These properties are usually not stated in terms of the satisfaction predi-
cate |=, which is too low-level. Instead, we reason in terms of entailment or
equivalence assertions. Let us ﬁrst deﬁne these notions.
10.2.11
Definition: We write C1 ð C2, and say that C1 entails C2, if and only if,
for every ground assignment φ and for every ground environment ψ, the
assertion φ, ψ |= C1 implies φ, ψ |= C2. We write C1 ≡C2, and say that C1
and C2 are equivalent, if and only if C1 ð C2 and C2 ð C1 hold.
2
In other words, C1 entails C2 when C1 imposes stricter requirements on
its free type variables and program identiﬁers than C2 does. Note that C is
unsatisﬁable if and only if C ≡false holds. It is straightforward to check
that entailment is reﬂexive and transitive and that ≡is indeed an equivalence
relation.
We immediately exploit the notion of constraint equivalence to deﬁne what
it means for a type constructor to be covariant, contravariant, or invariant
with respect to one of its parameters. Let F be a type constructor of signature
κ1 ⊗. . . ⊗κn ⇒κ. Let i ∈{1, . . . , n}. F is covariant (respectively contravariant,
invariant) with respect to its ith parameter if and only if, for all types T1, . . . , Tn
and T′
i of appropriate kinds, the constraint F T1 . . . Ti . . . Tn ≤F T1 . . . T′
i . . . Tn
is equivalent to Ti ≤T′
i (respectively T′
i ≤Ti, Ti = T′
i).
10.2.12
Exercise [«, 3]: Check the following facts: (i) in an equality model, covari-
ance, contravariance, and invariance coincide; (ii) in an equality free tree
model, every type constructor is invariant with respect to each of its parame-
ters; and (iii) in a nonstructural subtyping model, if the direction d has been
declared covariant (respectively contravariant, invariant), then every type con-

416
10
The Essence of ML Type Inference
structor whose arity includes d is covariant (respectively contravariant, in-
variant) with respect to d.
2
In the following, we require the type constructor →to be contravariant
with respect to its domain and covariant with respect to its codomain—a
standard requirement in type systems with subtyping (TAPL, Chapter 15).
This requirement is summed up by the following equivalence law:
T1 →T2 ≤T′
1 →T′
2 ≡T′
1 ≤T1 ∧T2 ≤T′
2
(C-Arrow)
Note that this requirement bears on the interpretation of types and of the
subtyping predicate. In an equality free tree model, by (i) and (ii) in the exer-
cise above, it is always satisﬁed. In a nonstructural subtyping model, it boils
down to requiring that the directions domain and codomain be declared con-
travariant and covariant, respectively. In the general case, we do not have any
knowledge of the model and cannot formulate a more precise requirement.
Thus, it is up to the designer of the model to ensure that C-Arrow holds.
We also exploit the notion of constraint equivalence to deﬁne what it means
for two type constructors to be incompatible. Two type constructors F1 and
F2 with the same image kind are incompatible if and only if all constraints
of the form F1 ⃗T1 ≤F2 ⃗T2 and F2 ⃗T2 ≤F1 ⃗T1 are false. Note that in an equality
free tree model, any two distinct type constructors are incompatible. In the
following, we often indicate that a newly introduced type constructor must
be isolated. We implicitly require that, whenever both F1 and F2 are isolated,
F1 and F2 be incompatible. Thus, the notion of isolation provides a concise
and modular way of stating a collection of incompatibility requirements. We
require the type constructor →to be isolated.
Reasoning with Constraints
In this section, we give a number of equivalence laws that are often useful and
help understand the meaning of constraints. To begin, we note that entail-
ment is preserved by arbitrary constraint contexts, as stated by the theorem
below. As a result, constraint equivalence is a congruence. Throughout this
chapter, these facts are often used implicitly.
10.2.13
Theorem [Congruence]: C1 ð C2 implies C[C1] ð C[C2].
2
Next, we deﬁne what it means for a constraint to determine a set of type
variables. In brief, C determines ¯Y if and only if, given a ground assignment
for ftv(C) \ ¯Y and given that C holds, it is possible to reconstruct, in a unique
way, a ground assignment for ¯Y. Determinacy appears in the equivalence law
C-LetAll on page 418 and is exploited by the constraint solver in §10.6.

10.2
Constraints
417
10.2.14
Definition: C determines ¯Y if and only if, for every environment Γ, two
ground assignments that satisfy def Γ in C and that coincide outside ¯Y must
coincide on ¯Y as well.
2
We now give a toolbox of constraint equivalence laws. It is worth noting
that they do not form a complete axiomatization of constraint equivalence;
in fact, they cannot, since the syntax and meaning of constraints is partly
unspeciﬁed.
10.2.15
Theorem: All equivalence laws in Figure 10-6 hold.
2
Let us explain. C-And and C-AndAnd state that conjunction is commuta-
tive and associative. C-Dup states that redundant conjuncts may be freely
added or removed, where a conjunct is redundant if and only if it is entailed
by another conjunct. Throughout this chapter, these three laws are often used
implicitly. C-ExEx and C-Ex* allow grouping consecutive existential quanti-
ﬁers and suppressing redundant ones, where a quantiﬁer is redundant if and
only if the variables bound by it do not occur free within its scope. C-ExAnd
allows conjunction and existential quantiﬁcation to commute, provided no
capture occurs; it is known as a scope extrusion law. When the rule is ori-
ented from left to right, its side-condition may always be satisﬁed by suitable
α-conversion. C-ExTrans states that it is equivalent for a type T to be an
instance of σ or to be a supertype of some instance of σ. We note that the in-
stances of a monotype are its supertypes, that is, by Deﬁnition 10.2.3, T′ ⪯T
and T′ ≤T are equivalent. As a result, specializing C-ExTrans to the case
where σ is a monotype, we ﬁnd that T′ ≤T is equivalent to ∃Z.(T′ ≤Z∧Z ≤T),
for fresh Z, a standard equivalence law. When oriented from left to right, it
becomes an interesting simpliﬁcation law: in a chain of subtyping constraints,
an intermediate variable such as Z may be suppressed, provided it is local, as
witnessed by the existential quantiﬁer ∃Z. C-InId states that, within the scope
of the binding x : σ, every free occurrence of x may be safely replaced with σ.
The restriction to free occurrences stems from the side-condition x ̸∈dpi(C).
When the rule is oriented from left to right, its other side-conditions, which
require the context let x : σ in C not to capture σ’s free type variables or
free program identiﬁers, may always be satisﬁed by suitable α-conversion.
C-In* complements the previous rule by allowing redundant let bindings to
be simpliﬁed. We note that C-InId and C-In* provide a simple procedure for
eliminating let forms. C-InAnd states that the let form commutes with con-
junction; C-InAnd* spells out a common particular case. C-InEx states that it
commutes with existential quantiﬁcation. When the rule is oriented from left
to right, its side-condition may always be satisﬁed by suitable α-conversion.
C-LetLet states that let forms may commute, provided they bind distinct

418
10
The Essence of ML Type Inference
C1 ∧C2
≡
C2 ∧C1
(C-And)
(C1 ∧C2) ∧C3
≡
C1 ∧(C2 ∧C3)
(C-AndAnd)
C1 ∧C2
≡
C1
if C1 ð C2
(C-Dup)
∃¯X.∃¯Y.C
≡
∃¯X¯Y.C
(C-ExEx)
∃¯X.C
≡
C
if ¯X # ftv(C)
(C-Ex*)
(∃¯X.C1) ∧C2
≡
∃¯X.(C1 ∧C2)
if ¯X # ftv(C2)
(C-ExAnd)
∃Z.(σ ⪯Z ∧Z ≤T)
≡
σ ⪯T
if Z ̸∈ftv(σ, T)
(C-ExTrans)
let x : σ in C[x ⪯T]
≡
let x : σ in C[σ ⪯T]
(C-InId)
if x ̸∈dpi(C) and dtv(C) # ftv(σ) and {x} ∪dpi(C) # fpi(σ)
let Γ in C
≡
∃Γ ∧C
if dpi(Γ) # fpi(C)
(C-In*)
let Γ in (C1 ∧C2)
≡
(let Γ in C1) ∧(let Γ in C2)
(C-InAnd)
let Γ in (C1 ∧C2)
≡
(let Γ in C1) ∧C2
if dpi(Γ) # fpi(C2)
(C-InAnd*)
let Γ in ∃¯X.C
≡
∃¯X.let Γ in C
if ¯X # ftv(Γ)
(C-InEx)
let Γ1; Γ2 in C
≡
let Γ2; Γ1 in C
(C-LetLet)
if dpi(Γ1) # dpi(Γ2) and dpi(Γ2) # fpi(Γ1) and dpi(Γ1) # fpi(Γ2)
let x : ∀¯X[C1 ∧C2].T in C3
≡
C1 ∧let x : ∀¯X[C2].T in C3
if ¯X # ftv(C1)
(C-LetAnd)
let Γ; x : ∀¯X[C1].T in C2
≡
let Γ; x : ∀¯X[let Γ in C1].T in C2
(C-LetDup)
if ¯X # ftv(Γ) and dpi(Γ) # fpi(Γ)
let x : ∀¯X[∃¯Y.C1].T in C2
≡
let x : ∀¯X¯Y[C1].T in C2
if ¯Y # ftv(T)
(C-LetEx)
let x : ∀¯X¯Y[C1].T in C2
≡
∃¯Y.let x : ∀¯X[C1].T in C2
(C-LetAll)
if ¯Y # ftv(C2) and ∃¯X.C1 determines ¯Y
∃X.(T ≤X ∧let x : X in C)
≡
let x : T in C
if X ̸∈ftv(T, C)
(C-LetSub)
⃗X = ⃗T ∧[⃗X , ⃗T]C
≡
⃗X = ⃗T ∧C
(C-Eq)
true
≡
∃¯X.(⃗X = ⃗T)
if ¯X # ftv(¯T)
(C-Name)
[⃗X , ⃗T]C
≡
∃¯X.(⃗X = ⃗T ∧C)
if ¯X # ftv(¯T)
(C-NameEq)
Figure 10-6: Constraint equivalence laws

10.2
Constraints
419
program identiﬁers and provided no free program identiﬁers are captured
in the process. C-LetAnd allows the conjunct C1 to be moved outside of the
constrained type scheme ∀¯X[C1 ∧C2].T, provided it does not involve any of
the universally quantiﬁed type variables ¯X. When oriented from left to right,
the rule yields an important simpliﬁcation law: indeed, taking an instance of
∀¯X[C2].T is less expensive than taking an instance of ∀¯X[C1 ∧C2].T, since the
latter involves creating a copy of C1, while the former does not. C-LetDup al-
lows pushing a series of let bindings into a constrained type scheme, provided
no capture occurs in the process. It is not used as a simpliﬁcation law but as a
tool in some proofs. C-LetEx states that it does not make any diﬀerence for a
set of type variables ¯Y to be existentially quantiﬁed inside a constrained type
scheme or part of the type scheme’s universal quantiﬁers. Indeed, in either
case, taking an instance of the type scheme means producing a constraint
where ¯Y is existentially quantiﬁed. C-LetAll states that it is equivalent for
a set of type variables ¯Y to be part of a type scheme’s universal quantiﬁers
or existentially bound outside the let form, provided these type variables are
determined. In other words, when a type variable is suﬃciently constrained,
it does not matter whether it is polymorphic or monomorphic. Together, C-
LetEx and C-LetAll allow, in some situations, hoisting existential quantiﬁers
out of the left-hand side of a let form.
10.2.16
Example: C-LetAll would be invalid without the condition that ∃¯X.C1 de-
termines ¯Y. Consider, for instance, the constraint let x : ∀Y.Y →Y in (x ⪯
int →int ∧x ⪯bool →bool) (1), where int and bool are incompatible nullary
type constructors. By C-InId and C-In*, it is equivalent to ∀Y.Y →Y ≤int →
int ∧∀Y.Y →Y ≤bool →bool which, by Deﬁnition 10.2.3, means ∃Y.(Y →
Y ≤int →int) ∧∃Y.(Y →Y ≤bool →bool), that is, true. Now, if C-LetAll
was valid without its side-condition, then (1) would also be equivalent to
∃Y.let x : Y →Y in (x ⪯int →int∧x ⪯bool →bool), which by C-InId and C-In*
is ∃Y.(Y →Y ≤int →int ∧Y →Y ≤bool →bool). By C-Arrow and C-ExTrans,
this is int = bool, that is, false. Thus, the law is invalid in this case. It is easy to
see why: when the type scheme σ contains a ∀Y quantiﬁer, every instance of
σ receives its own ∃Y quantiﬁer, making Y a distinct (local) type variable; but
when Y is not universally quantiﬁed, all instances of σ share references to a
single (global) type variable Y. This corresponds to the intuition that, in the
former case, σ is polymorphic in Y, while in the latter case, it is monomorphic
in Y. It is possible to prove that, when deprived of its side-condition, C-LetAll
is only an entailment law, that is, its right-hand side entails its left-hand side.
Similarly, it is in general invalid to hoist an existential quantiﬁer out of the
left-hand side of a let form. To see this, one may study the (equivalent) con-
straint let x : ∀X[∃Y.X = Y →Y].X in (x ⪯int →int ∧x ⪯bool →bool).
Naturally, in the above examples, the side-condition “true determines Y” does

420
10
The Essence of ML Type Inference
not hold: by Deﬁnition 10.2.14, it is equivalent to “two ground assignments
that coincide outside Y must coincide on Y as well,” which is false when M⋆
contains two distinct elements, such as int and bool here.
There are cases, however, where the side-condition does hold. For instance,
we later prove that ∃X.Y = int determines Y; see Lemma 10.6.7. As a result,
C-LetAll states that let x : ∀XY[Y = int].Y →X in C (1) is equivalent to
∃Y.let x : ∀X[Y = int].Y →X in C (2), provided Y ̸∈ftv(C). The intuition is
simple: because Y is forced to assume the value int by the equation Y = int, it
makes no diﬀerence whether Y is or isn’t universally quantiﬁed. By C-LetAnd,
(2) is equivalent to ∃Y.(Y = int ∧let x : ∀X.Y →X in C) (3). In an eﬃcient
constraint solver, simplifying (1) into (3) before using C-InId to eliminate the
let form is worthwhile, since doing so obviates the need for copying the type
variable Y and the equation Y = int at every free occurrence of x inside C.
2
C-LetSub is the analog of an environment strengthening lemma: roughly
speaking, it states that, if a constraint holds under the assumption that x has
type X, where X is some supertype of T, then it also holds under the assump-
tion that x has type T. The last three rules deal with the equality predicate.
C-Eq states that it is valid to replace equals with equals; note the absence of a
side-condition. When oriented from left to right, C-Name allows introducing
fresh names ⃗X for the types ⃗T. As always, ⃗X stands for a vector of distinct
type variables; ⃗T stands for a vector of the same length of types of appropri-
ate kind. Of course, this makes sense only if the deﬁnition is not circular, that
is, if the type variables ¯X do not occur free within the terms ¯T. When oriented
from right to left, C-Name may be viewed as a simpliﬁcation law: it allows
eliminating type variables whose value has been determined. C-NameEq is
a combination of C-Eq and C-Name. It shows that applying an idempotent
substitution to a constraint C amounts to placing C within a certain context.
So far, we have considered def a primitive constraint form and deﬁned
the let form in terms of def, conjunction, and existential quantiﬁcation. The
motivation for this approach was to simplify the (omitted) proofs of several
constraint equivalence laws. However, in the remainder of this chapter, we
work with let forms exclusively and never employ the def construct. This of-
fers us an extra property: every constraint that contains a false subconstraint
must be false.
10.2.17
Lemma: C[false] ≡false.
2
Reasoning with Constraints in an Equality-Only Syntactic Model
We have given a number of equivalence laws that are valid with respect to
any interpretation of constraints, that is, within any model. However, an im-

10.2
Constraints
421
portant special case is that of equality-only syntactic models. Indeed, in that
speciﬁc setting, our constraint-based type systems are in close correspon-
dence with DM. In brief, we aim to prove that every satisﬁable constraint C
such that fpi(C) =  admits a canonical solved form and to show that this
notion corresponds to the standard concept of a most general uniﬁer. These
results are exploited when we relate HM(X) with Damas and Milner’s system
(p. 428).
Thus, let us now assume that constraints are interpreted in an equality-
only syntactic model. Let us further assume that, for every kind κ, (i) there
are at least two type constructors of image kind κ and (ii) for every type con-
structor F of image kind κ, there exists t ∈Mκ such that t(ϵ) = F. We refer to
models that violate (i) or (ii) as degenerate; one may argue that such models
are of little interest. The assumption that the model is nondegenerate is used
in the proof of Theorem 10.3.7. Last, throughout the present subsection we
manipulate only constraints that have no free program identiﬁers.
A solved form is a conjunction of equations, where the left-hand sides are
distinct type variables that do not appear in the right-hand sides, possibly
surrounded by a number of existential quantiﬁers. Our deﬁnition is identi-
cal to Lassez, Maher, and Marriott’s solved forms (1988) and to Jouannaud
and Kirchner’s tree solved forms (1991), except we allow for prenex existen-
tial quantiﬁers, which are made necessary by our richer constraint language.
Jouannaud and Kirchner also deﬁne dag solved forms, which may be expo-
nentially smaller. Because we deﬁne solved forms only for proof purposes,
we need not take performance into account at this point. The eﬃcient con-
straint solver presented in §10.6 does manipulate graphs, rather than trees.
Type scheme introduction and instantiation constructs cannot appear within
solved forms; indeed, provided the constraint at hand has no free program
identiﬁers, they can be expanded away. For this reason, their presence in the
constraint language has no impact on the results contained in this section.
10.2.18
Definition: A solved form is of the form ∃¯Y.(⃗X = ⃗T), where ¯X # ftv(¯T).
2
Solved forms oﬀer a convenient way of reasoning about constraints be-
cause every satisﬁable constraint is equivalent to one. This property is estab-
lished by the following lemma.
10.2.19
Lemma: Every constraint is equivalent to either a solved form or false.
2
It is possible to impose further restrictions on solved forms. A solved form
∃¯Y.(⃗X = ⃗T) is canonical if and only if its free type variables are exactly ¯X. This
is stated, in an equivalent way, by the following deﬁnition.
10.2.20
Definition: A canonical solved form is a constraint of the form ∃¯Y.(⃗X = ⃗T),
where ftv(¯T) ⊆¯Y and ¯X # ¯Y.
2

422
10
The Essence of ML Type Inference
10.2.21
Lemma: Every solved form is equivalent to a canonical solved form.
2
It is easy to describe the solutions of a canonical solved form: they are the
ground reﬁnements of the substitution [⃗X , ⃗T].
Hence, every canonical
solved form is satisﬁable.
The following deﬁnition allows entertaining a dual view of canonical solved
forms, either as constraints or as idempotent type substitutions. The latter
view is commonly found in standard treatments of uniﬁcation (Lassez, Maher,
and Marriott, 1988; Jouannaud and Kirchner, 1991) and in classic presenta-
tions of ML-the-type-system.
10.2.22
Definition: If [⃗X , ⃗T] is an idempotent substitution of domain ¯X, let ∃[⃗X ,
⃗T] denote the canonical solved form ∃¯Y.(⃗X = ⃗T), where ¯Y = ftv(¯T). An idem-
potent substitution θ is a most general uniﬁer of the constraint C if and only
if ∃θ and C are equivalent.
2
By deﬁnition, equivalent constraints admit the same most general uniﬁers.
Many properties of canonical solved forms may be reformulated in terms
of most general uniﬁers. By Lemmas 10.2.19 and 10.2.21, every satisﬁable
constraint admits a most general uniﬁer.
10.3
HM(X)
Constraint-based type systems appeared during the 1980s (Mitchell, 1984;
Fuh and Mishra, 1988) and were widely studied during the following decade
(Curtis, 1990; Aiken and Wimmers, 1993; Jones, 1994; Smith, 1994; Palsberg,
1995; Trifonov and Smith, 1996; Fähndrich, 1999; Pottier, 2001b). We now
present one such system, baptized HM(X) because it is a parameterized ex-
tension of Hindley and Milner’s type discipline; the meaning of the parameter
X was explained on page 411. Its original description is due to Odersky, Sulz-
mann, and Wehr (1999). Since then, it has been completed in a number of
works including Müller (1998), Sulzmann, Müller, and Zenger (1999), Sulz-
mann (2000), Pottier (2001a), and Skalka and Pottier (2002). Each of these
presentations introduces minor variations. Here, we follow Pottier (2001a),
which is itself inspired by Sulzmann, Müller, and Zenger (1999).
Deﬁnition
Our presentation of HM(X) relies on the constraint language introduced in
§10.2. Technically, our approach to constraints is less abstract than that
of Odersky, Sulzmann, and Wehr (1999). We interpret constraints within a
model, give conjunction and existential quantiﬁcation their standard mean-

10.3
HM(X)
423
Γ(x) = σ
C ð ∃σ
C, Γ ⊢x : σ
(hmx-Var)
C, (Γ; z : T) ⊢t : T′
C, Γ ⊢λz.t : T →T′
(hmx-Abs)
C, Γ ⊢t1 : T →T′
C, Γ ⊢t2 : T
C, Γ ⊢t1 t2 : T′
(hmx-App)
C, Γ ⊢t1 : σ
C, (Γ; z : σ) ⊢t2 : T
C, Γ ⊢let z = t1 in t2 : T
(hmx-Let)
C ∧D, Γ ⊢t : T
¯X # ftv(C, Γ)
C ∧∃¯X.D, Γ ⊢t : ∀¯X[D].T
(hmx-Gen)
C, Γ ⊢t : ∀¯X[D].T
C ∧D, Γ ⊢t : T
(hmx-Inst)
C, Γ ⊢t : T
C ð T ≤T′
C, Γ ⊢t : T′
(hmx-Sub)
C, Γ ⊢t : σ
¯X # ftv(Γ, σ)
∃¯X.C, Γ ⊢t : σ
(hmx-Exists)
Figure 10-7: Typing rules for HM(X)
ing, and derive a number of equivalence laws (§10.2). Odersky et al., on the
other hand, do not explicitly rely on a logical interpretation; instead, they
axiomatize constraint equivalence, that is, they consider a number of equiva-
lence laws as axioms. Thus, they ensure that their high-level proofs, such as
type soundness and correctness and completeness of type inference, are in-
dependent of the low-level details of the logical interpretation of constraints.
Their approach is also more general, since it allows dealing with other logi-
cal interpretations, such as “open-world” interpretations, where constraints
are interpreted not within a ﬁxed model, but within a family of extensions
of a “current” model. In this chapter, we have avoided this extra layer of ab-
straction and given ﬁxed meaning to constraints, making things somewhat
simpler. However, the changes required to adopt Odersky et al.’s approach
would not be extensive, since the forthcoming proofs do indeed rely mostly
on constraint equivalence laws, rather than on low-level details of the logical
interpretation of constraints.
Another slight departure from Odersky et al.’s work lies in the fact that
we have enriched the constraint language with type scheme introduction and
instantiation forms, which were absent in the original presentation of HM(X).
To prevent this addition from aﬀecting HM(X), we require the constraints
that appear in HM(X) typing judgments to have no free program identiﬁers.
Note that this does not prevent them from containing let forms.
The type system HM(X) consists of a four-place judgment whose parame-
ters are a constraint C, an environment Γ, an expression t, and a type scheme
σ. A judgment is written C, Γ ⊢t : σ and is read: under the assumptions C
and Γ, the expression t has type σ. One may view C as an assumption about

424
10
The Essence of ML Type Inference
the judgment’s free type variables and Γ as an assumption about t’s free pro-
gram identiﬁers. Recall that Γ now contains constrained type schemes, and
that σ is a constrained type scheme.
We would like the validity of a typing judgment to depend not on the syn-
tax, but only on the meaning of its constraint assumption. We enforce this
point of view by considering judgments equal modulo equivalence of their
constraint assumptions. In other words, the typing judgments C, Γ ⊢t : σ
and D, Γ ⊢t : σ are considered identical when C ≡D holds. A judgment is
valid, or holds, if and only if it is derivable via the rules given in Figure 10-7.
Note that a valid judgment may involve an arbitrary constraint. A (closed)
program t is well-typed within the (closed) environment Γ if and only if a
judgment of the form C, Γ ⊢t : σ holds for some satisﬁable constraint C. One
might wonder why we do not make the apparently stronger requirement that
C ∧∃σ be satisﬁable; however, by inspection of the typing rules, the reader
may check that, if the above judgment is derivable, then C ð ∃σ holds, hence
the two requirements are equivalent.
Let us now explain the rules. Like dm-Var, hmx-Var looks up the environ-
ment to determine the type scheme associated with the program identiﬁer x.
Its second premise plays a minor technical role: as noted in the previous para-
graph, its presence helps simplify the deﬁnition of well-typedness. hmx-Abs,
hmx-App, and hmx-Let are identical to dm-Abs, dm-App, and dm-Let, respec-
tively, except that the assumption C is made available to every subderivation.
We recall that the type T may be viewed as the type scheme ∀[true].T (Deﬁ-
nitions 10.1.18 and 10.2.2). As a result, types form a subset of type schemes,
which implies that Γ; z : T is a well-formed environment and C, Γ ⊢t : T a
well-formed typing judgment. To understand hmx-Gen, it is best to ﬁrst con-
sider the particular case where C is true. This yields the following, simpler
rule:
D, Γ ⊢t : T
¯X # ftv(Γ)
∃¯X.D, Γ ⊢t : ∀¯X[D].T
(hmx-Gen’)
The second premise is identical to that of dm-Gen: the type variables that
are generalized must not occur free within the environment. The conclusion
forms the type scheme ∀¯X[D].T, where the type variables ¯X have become uni-
versally quantiﬁed, but are still subject to the constraint D. Note that the
type variables that occur free in D may include not only ¯X, but also other
type variables, typically free in Γ. hmx-Gen may be viewed as a more liberal
version of hmx-Gen’, whereby part of the current constraint, namely C, need
not be copied if it does not concern the type variables that are being gener-
alized, namely ¯X. This optimization is important in practice, because C may
be very large. An intuitive explanation for its correctness is given by the con-

10.3
HM(X)
425
straint equivalence law C-LetAnd, which expresses the same optimization in
terms of let constraints. Because HM(X) does not use let constraints, the op-
timization is hard-wired into the typing rule. As a last technical remark, let
us point out that replacing C ∧∃¯X.D with C ∧D in hmx-Gen’s conclusion
would not aﬀect the set of derivable judgments; this fact may be established
using hmx-Exists and Lemma 10.3.1. hmx-Inst allows taking an instance of
a type scheme. The reader may be surprised to ﬁnd that, contrary to dm-
Inst, it does not involve a type substitution. Instead, the rule merely drops
the universal quantiﬁer, which amounts to applying the identity substitu-
tion ⃗X , ⃗X. One should recall, however, that type schemes are considered
equal modulo α-conversion, so it is possible to rename the type scheme’s
universal quantiﬁers prior to using hmx-Inst. The reason why this provides
suﬃcient expressive power appears in Exercise 10.3.2 below. The constraint
D carried by the type scheme is recorded as part of the current constraint
in hmx-Inst’s conclusion. The subsumption rule hmx-Sub allows a type T to
be replaced at any time with an arbitrary supertype T′. Because both T and
T′ may have free type variables, whether T ≤T′ holds depends on the cur-
rent assumption C, which is why the rule’s second premise is an entailment
assertion. An operational explanation of hmx-Sub is that it requires all uses
of subsumption to be explicitly recorded in the current constraint. Note that
hmx-Sub remains a useful and necessary rule even when subtyping is inter-
preted as equality: then, it allows exploiting the type equations found in C.
Last, hmx-Exists allows the type variables that occur only within the current
constraint to become existentially quantiﬁed. As a result, these type variables
no longer occur free in the rule’s conclusion; in other words, they have be-
come local to the subderivation rooted at the premise. One may prove that
the presence of hmx-Exists in the type system does not augment the set of
well-typed programs, but does augment the set of valid typing judgments; it
is a pleasant technical convenience. Indeed, because judgments are consid-
ered equal modulo constraint equivalence, constraints may be transparently
simpliﬁed at any time. (By simplifying a constraint, we mean replacing it with
an equivalent constraint whose syntactic representation is considered sim-
pler.) Bearing this fact in mind, one ﬁnds that an eﬀect of rule hmx-Exists
is to enable more simpliﬁcations: because constraint equivalence is a con-
gruence, C ≡D implies ∃¯X.C ≡∃¯X.D, but the converse does not hold in
general. For instance, there is in general no way of simplifying the judgment
X ≤Y ≤Z, Γ ⊢t : σ, but if it is known that Y does not appear free in Γ or
σ, then hmx-Exists allows deriving ∃Y.(X ≤Y ≤Z), Γ ⊢t : σ, which is the
same judgment as X ≤Z, Γ ⊢t : σ. Thus, an interesting simpliﬁcation has
been enabled. Note that X ≤Y ≤Z ≡X ≤Z does not hold, while, according to
C-ExTrans, ∃Y.(X ≤Y ≤Z) ≡X ≤Z does.

426
10
The Essence of ML Type Inference
A pleasant property of HM(X) is that strengthening a judgment’s con-
straint assumption (that is, weakening the judgment itself) preserves its va-
lidity. It is worth noting that in traditional presentations, which rely more
heavily on type substitutions, the analog of this result is a type substitu-
tion lemma; see for instance Tofte (1988), Lemma 2.7; Rémy (1992a), Lemma
1; Leroy (1992), Proposition 1.2; and Skalka and Pottier (2002), Lemma 3.4.
Here, the lemma further states that weakening a judgment does not alter the
shape of its derivation, a useful property when reasoning by induction on
type derivations.
10.3.1
Lemma [Weakening]: If C′ ð C, then every derivation of C, Γ ⊢t : σ may be
turned into a derivation of C′, Γ ⊢t : σ with the same shape.
2
10.3.2
Exercise [Recommended, ««]: In some presentations of HM(X), hmx-Inst
is replaced with the following variant:
C, Γ ⊢t : ∀¯X[D].T
C ð [⃗X , ⃗T]D
C, Γ ⊢t : [⃗X , ⃗T]T
(hmx-Inst’)
Show that hmx-Inst’ is admissible in our presentation of HM(X)—that is, if its
premise is derivable according to the rules of Figure 10-7, then so is its con-
clusion. Thus, the choice between hmx-Inst and hmx-Inst’ is only stylistic: it
makes no diﬀerence in the system’s expressive power. Because hmx-Inst is
more elementary, choosing it simpliﬁes some proofs.
2
10.3.3
Exercise [«]: Give a derivation of true,  ⊢λz.z : int →int. Give a derivation
of true,  ⊢λz.z : ∀X.X →X. Check that the former judgment also follows
from the latter via hmx-Inst’ (Exercise 10.3.2), and determine which deriva-
tion of true,  ⊢λz.z : int →int this path gives rise to.
2
We do not give a direct type soundness proof for HM(X). Instead, in the
forthcoming sections, we prove that well-typedness in HM(X) is equivalent
to the satisﬁability of a certain constraint and use that characterization as
a basis for our type soundness proof. A direct type soundness result, based
on a denotational semantics, may be found in Odersky, Sulzmann, and Wehr
(1999). Another type soundness proof, which follows Wright and Felleisen’s
syntactic approach (1994), appears in Skalka and Pottier (2002). Last, a hybrid
approach, which combines some of the advantages of the previous two, is
given in Pottier (2001a).
An Alternate Presentation of HM(X)
The presentation of HM(X) given in Figure 10-7 has only four syntax-directed
rules out of eight. It is a good speciﬁcation of the type system, but it is far

10.3
HM(X)
427
Γ(x) = ∀¯X[D].T
C ∧D, Γ ⊢x : T
(hmd-VarInst)
C, (Γ; z : T) ⊢t : T′
C, Γ ⊢λz.t : T →T′
(hmd-Abs)
C, Γ ⊢t1 : T →T′
C, Γ ⊢t2 : T
C, Γ ⊢t1 t2 : T′
(hmd-App)
C ∧D, Γ ⊢t1 : T1
¯X # ftv(C, Γ)
C ∧∃¯X.D, (Γ; z : ∀¯X[D].T1) ⊢t2 : T2
C ∧∃¯X.D, Γ ⊢let z = t1 in t2 : T2
(hmd-LetGen)
C, Γ ⊢t : T
C ð T ≤T′
C, Γ ⊢t : T′
(hmd-Sub)
C, Γ ⊢t : T
¯X # ftv(Γ, T)
∃¯X.C, Γ ⊢t : T
(hmd-Exists)
Figure 10-8: An alternate presentation of HM(X)
from an algorithmic description. As a ﬁrst step towards such a description,
we provide an alternate presentation of HM(X), where generalization is per-
formed only at let expressions and instantiation takes place only at refer-
ences to program identiﬁers (Figure 10-8). This presentation only has two
non-syntax-directed rules, making it sometimes easier to reason about. It has
the property that all judgments are of the form C, Γ ⊢t : T, rather than
C, Γ ⊢t : σ. The following theorem states that the two presentations are
indeed equivalent.
10.3.4
Theorem: C, Γ ⊢t : T is derivable via the rules of Figure 10-8 if and only if it
is a valid HM(X) judgment.
2
This theorem shows that the rule sets of Figures 10-7 and 10-8 derive
the same monomorphic judgments, that is, the same judgments of the form
C, Γ ⊢t : T. The fact that judgments of the form C, Γ ⊢t : σ, where σ is
a not a monotype, cannot be derived using the new rule set is a technical
simpliﬁcation, without deep signiﬁcance.
10.3.5
Exercise [«««, 3]: Show that it is possible to simplify the presentation of
Damas and Milner’s type system in an analogous manner. That is, deﬁne an
alternate set of typing rules for DM, which allows deriving judgments of the
form Γ ⊢t : T; then, show that this new rule set is equivalent to the previous
one, in the same sense as above. Which auxiliary properties of DM does your
proof require? A solution is given by Clement, Despeyroux, Despeyroux, and
Kahn (1986).
2

428
10
The Essence of ML Type Inference
Relating HM(X) with Damas and Milner’s Type System
In order to explain our interest in HM(X), we wish to show that it is more gen-
eral than Damas and Milner’s type system. Since HM(X) really is a family of
type systems, we must make this statement more precise. First, every mem-
ber of the HM(X) family contains DM. Conversely, DM contains HM(=), the
constraint-based type system obtained by specializing HM(X) to the setting
of an equality-only syntactic model.
The ﬁrst of these assertions is easy to prove because the mapping from
DM judgments to HM(X) judgments is essentially the identity: every valid
DM judgment may be viewed as a valid HM(X) judgment under the trivial
assumption true. This statement relies on the fact that the DM type scheme
∀¯X.T is identiﬁed with the constrained type scheme ∀¯X[true].T, so DM type
schemes (respectively environments) form a subset of HM(X) type schemes
(respectively environments). Its proof is easy and relies on Exercise 10.3.2.
10.3.6
Theorem: If Γ ⊢t : S holds in DM, then true, Γ ⊢t : S holds in HM(X).
2
We are now interested in proving that HM(=), as deﬁned above, is con-
tained within DM. To this end, we must translate every HM(=) judgment to
a DM judgment. It turns out that this is possible if the original judgment’s
constraint assumption is satisﬁable. The translation relies on the fact that
the deﬁnition of HM(=) assumes an equality-only syntactic model. Indeed, in
that setting, every satisﬁable constraint admits a most general uniﬁer (Deﬁ-
nition 10.2.22), whose properties we make essential use of.
Unfortunately, due to lack of space, we cannot give the details of this trans-
lation, which are fairly involved. Let us merely say that, given a type scheme
σ and an idempotent type substitution θ such that ftv(σ) ⊆dom(θ) and
∃θ ð ∃σ hold, the translation of σ under θ is a DM type scheme, written
JσKθ. Its meaning is intended to be the same as that of the HM(X) type
scheme θ(σ). For instance, under the identity substitution, the translation of
the HM(X) type scheme ∀XY[X = Y →Y].X is the DM type scheme ∀Z.Z →Z.
The translation is extended to environments in such a way that JΓKθ is deﬁned
when ftv(Γ) ⊆dom(θ) holds. We are now ready to state the main theorem.
10.3.7
Theorem: Let C, Γ ⊢t : σ hold in HM(=). Let θ be a most general uniﬁer of
C such that ftv(Γ, σ) ⊆dom(θ). Then, JΓKθ ⊢t : JσKθ holds in DM.
2
Note that, by requiring θ to be a most general uniﬁer of C, we also require C
to be satisﬁable. Judgments that carry an unsatisﬁable constraint cannot be
translated.
Together, Theorems 10.3.6 and 10.3.7 yield a precise correspondence be-
tween DM and HM(=): there exists a compositional translation from each to

10.4
Constraint Generation
429
the other. In other words, they may be viewed as two equivalent formulations
of a single type system. One might also say that HM(=) is a constraint-based
formulation of DM. Furthermore, Theorem 10.3.6 states that every member of
the HM(X) family is an extension of DM. This explains our double interest in
HM(X), as an alternate formulation of DM, which we believe is more pleasant
for reasons already discussed, and as a more expressive framework.
10.4
Constraint Generation
We now explain how to reduce type inference problems for HM(X) to con-
straint solving problems. A type inference problem consists of a type environ-
ment Γ, an expression t, and a type T of kind ⋆. The problem is to determine
whether there exists a satisﬁable constraint C such that C, Γ ⊢t : T holds. A
constraint solving problem consists of a constraint C. The problem is to de-
termine whether C is satisﬁable. To reduce a type inference problem (Γ, t, T)
to a constraint solving problem, we must produce a constraint C that is both
suﬃcient and necessary for C, Γ ⊢t : T to hold. Below, we explain how to
compute such a constraint, which we write JΓ ⊢t : TK. We check that it is
indeed suﬃcient by proving JΓ ⊢t : TK, Γ ⊢t : T. That is, the constraint
JΓ ⊢t : TK is speciﬁc enough to guarantee that t has type T under environ-
ment Γ. We say that constraint generation is sound. We check that it is indeed
necessary by proving that, for every constraint C, the validity of C, Γ ⊢t : T
implies C ð JΓ ⊢t : TK. That is, every constraint that guarantees that t has
type T under environment Γ is at least as speciﬁc as JΓ ⊢t : TK. We say
that constraint generation is complete. Together, these properties mean that
JΓ ⊢t : TK is the least speciﬁc constraint that guarantees that t has type T
under environment Γ.
We now see how to reduce a type inference problem to a constraint solving
problem. Indeed, if there exists a satisﬁable constraint C such that C, Γ ⊢
t : T holds, then, by the completeness property, C ð JΓ ⊢t : TK holds, so
JΓ ⊢t : TK is satisﬁable. Conversely, by the soundness property, if JΓ ⊢t : TK
is satisﬁable, then we have a satisﬁable constraint C such that C, Γ ⊢t : T
holds. In other words, t is well-typed with type T under environment Γ if and
only if JΓ ⊢t : TK is satisﬁable.
The reader may be somewhat puzzled by the fact that our formulation
of the type inference problem requires an appropriate type T to be known
in advance, whereas the very purpose of type inference seems to consist in
discovering the type of t! In other words, we have made T an input of the con-
straint generation algorithm, instead of an output. Fortunately, this causes
no loss of generality, because it is possible to let T be a type variable X, cho-

430
10
The Essence of ML Type Inference
sen fresh for Γ. Then, the constraint produced by the algorithm will contain
information about X. This is the point of the following exercise.
10.4.1
Exercise [Recommended, «]: Let X ̸∈ftv(Γ). Show that, if there exist a sat-
isﬁable constraint C and a type T such that C, Γ ⊢t : T holds, then there
exists a satisﬁable constraint C′ such that C′, Γ ⊢t : X holds. Conclude that,
given a closed environment Γ and an arbitrary type variable X, the term t is
well-typed within Γ if and only if JΓ ⊢t : XK is satisﬁable.
2
This shows that providing T as an input to the constraint generation proce-
dure is not essential. We adopt this style because it is convenient. A somewhat
naive alternative would be to provide Γ and t only, and to have the procedure
return both a constraint C and a type T (Sulzmann, Müller, and Zenger, 1999).
It turns out that this does not quite work, because C and T may mention
“fresh” variables, which we must be able to quantify over, if we are to avoid
an informal treatment of “freshness.” Thus, the true alternative is to provide
Γ and t only and to have the procedure return a type scheme σ (Bourdoncle
and Merz, 1997; Bonniot, 2002).
The existence of a sound and complete constraint generation procedure
is the analog of the existence of principal type schemes in classic presenta-
tions of ML-the-type-system (Damas and Milner, 1982). Indeed, a principal
type scheme is least speciﬁc in the sense that all valid types are substitution
instances of it. Here, the constraint JΓ ⊢t : TK is least speciﬁc in the sense
that all valid constraints entail it. More about principal types and principal
typings may be found in Jim (1996) and Wells (2002).
How do we perform constraint generation? A standard approach (Sulz-
mann, Müller, and Zenger, 1999; Bonniot, 2002) is to deﬁne JΓ ⊢t : TK by
induction on the structure of t. At every let node, following hmd-LetGen,
part of the current constraint, namely D, is turned into a type scheme, namely
∀¯X[D].T, which is used to extend the environment. Then, at every occurrence
of the program variable that was bound at this let node, following hmd-
VarInst, this type scheme is retrieved from the environment, and a copy of
D is added back to the current constraint. If such an approach is adopted, it is
important to simplify the type scheme ∀¯X[D].T before it is stored in the en-
vironment, because it would be ineﬃcient to copy an unsimpliﬁed constraint.
In other words, in an eﬃcient implementation of this standard approach,
constraint generation and constraint simpliﬁcation cannot be separated.
Type scheme introduction and elimination constraints, which we intro-
duced in §10.2 but did not use in the speciﬁcation of HM(X), are intended
as a means of solving this problem. By extending our vocabulary, we are able
to achieve the desired separation between constraint generation, on the one
hand, and constraint solving and simpliﬁcation, on the other hand, without

10.4
Constraint Generation
431
Jx : TK
=
x ⪯T
Jλz.t : TK
=
∃X1X2.(let z : X1 in Jt : X2K ∧X1 →X2 ≤T)
Jt1 t2 : TK
=
∃X2.(Jt1 : X2 →TK ∧Jt2 : X2K)
Jlet z = t1 in t2 : TK
=
let z : ∀X[Jt1 : XK].X in Jt2 : TK
Figure 10-9: Constraint generation
compromising eﬃciency. Indeed, by exploiting these new constraint forms,
we may deﬁne a constraint generation procedure whose time and space com-
plexity is linear, because it no longer involves copying subconstraints back
and forth between the environment and the constraint that is being gener-
ated. (It is then up to the constraint solver to perform simpliﬁcation and
copying, if and when necessary.) In fact, the environment is suppressed al-
together: we deﬁne Jt : TK by induction on the structure of t—notice the
absence of the parameter Γ. Then, the constraint JΓ ⊢t : TK discussed above
becomes syntactic sugar for let Γ in Jt : TK. We now employ the full constraint
language: the program identiﬁers that appear free in t may also appear free in
Jt : TK, as part of instantiation constraints. They become bound when Jt : TK
is placed within the context let Γ in []. A similar approach to constraint gen-
eration appears in Müller (1994).
The deﬁning equations for Jt : TK appear in Figure 10-9. We refer to them
as the constraint generation rules. The deﬁnition is quite terse and certainly
simpler than the declarative speciﬁcation of HM(X) given in Figure 10-7; yet,
we prove below that the two are equivalent.
Before explaining the deﬁnition, we state the requirements that bear on
the type variables X1, X2, and X, which appear bound in the right-hand sides
of the second, third, and fourth equations. These type variables must have
kind ⋆. They must be chosen distinct (that is, X1 ̸= X2 in the second equa-
tion) and fresh for the objects that appear on the left-hand side—that is, the
type variables that appear bound in an equation’s right-hand side must not
occur free in the term and type that appear in the equation’s left-hand side.
Provided this restriction is obeyed, diﬀerent choices of X1, X2, and X lead
to α-equivalent constraints—that is, to the same constraint, since we iden-
tify objects up to α-conversion—which guarantees that the above equations
make sense. Since expressions do not have free type variables, the freshness
requirement may be simpliﬁed to: type variables that appear bound in an
equation’s right-hand side must not appear free in T. However, this simpliﬁca-
tion would be rendered invalid by the introduction of open type annotations

432
10
The Essence of ML Type Inference
within expressions. Note that we are able to state a precise (as opposed to in-
formal) freshness requirement. This is made possible by the fact that Jt : TK
has no free type variables other than those of T, which in turn depends on
our explicit use of existential quantiﬁcation to limit the scope of auxiliary
variables.
Let us now review the four equations. The ﬁrst equation may be read: x
has type T if and only if T is an instance of the type scheme associated with
x. Note that we no longer consult the type scheme associated with x in the
environment—indeed, there is no environment. Instead, we merely generate
an instantiation constraint, where x appears free. (For this reason, every pro-
gram identiﬁer that occurs free within t typically also occurs free within
Jt : TK.) This constraint acquires its full meaning when it is later placed within
a context of the form let x : σ in []. This equation roughly corresponds to
hmd-VarInst. The second equation may be read: λz.t has type T if and only
if, for some X1 and X2, (i) under the assumption that z has type X1, t has type
X2, and (ii) T is a supertype of X1 →X2. Here, the types associated with z
and t must be fresh type variables, namely X1 and X2, because we cannot in
general guess them. These type variables are bound so as to guarantee that
the generated constraint is unique up to α-conversion. They are existentially
bound because we intend the constraint solver to discover their value. Con-
dition (i) is expressed by the subconstraint let z : X1 in Jt : X2K. This makes
sense as follows. The constraint Jt : X2K typically contains a number of in-
stantiation constraints bearing on z, of the form z ⪯Ti. By wrapping it within
the context let z : X1 in [], we eﬀectively require every Ti to be a supertype
of X1. Note that z does not occur free in the constraint let z : X1 in Jt : X2K,
which is necessary for well-formedness of the deﬁnition, since it does not
occur free in λz.t. This equation roughly corresponds to hmd-Exists, hmd-
Abs, and hmd-Sub. The third equation may be read: t1 t2 has type T if and
only if, for some X2, t1 has type X2 →T and t2 has type X2. Here, the fresh
type variable X2 stands for the unknown type of t2. This equation roughly
corresponds to hmd-App. The last equation, which roughly corresponds to
hmd-LetGen, may be read: let z = t1 in t2 has type T if and only if, under
the assumption that z has every type X such that Jt1 : XK holds, t2 has type
T. As in the case of λ-abstractions, the instantiation constraints bearing on z
that appear within Jt2 : TK are given a meaning via a let preﬁx. The diﬀerence
is that z may now be assigned a type scheme, as opposed to a monotype.
An appropriate type scheme is built as follows. The constraint Jt1 : XK is the
least speciﬁc constraint that must be imposed on the fresh type variable X
so as to make it a valid type for t1. In other words, t1 has every type X such
that Jt1 : XK holds, and none other. That is, the type scheme ∀X[Jt1 : XK].X,
abbreviated σ in the following, is a principal type scheme for t1. It is inter-

10.4
Constraint Generation
433
esting to note that there is no question of which type variables to generalize.
Indeed, by construction, no type variables other than X may appear free in
Jt1 : XK, so we cannot generalize more variables. On the other hand, it is valid
to generalize X, since it does not appear free anywhere else. This interesting
simpliﬁcation is inspired by Sulzmann, Müller, and Zenger (1999), where a
similar technique is used. Now, what happens when Jt2 : TK is placed inside
the context let z : σ in []? When placed inside this context, an instantiation
constraint of the form z ⪯T′ acquires the meaning σ ⪯T′, which by deﬁni-
tion of σ and by Lemma 10.4.6 (see below) is equivalent to Jt1 : T′K. Thus, the
constraint produced by the fourth equation simulates a textual expansion of
the let construct, where every occurrence of z would be replaced with t1.
Thanks to type scheme introduction and instantiation constraints, however,
this eﬀect is achieved without duplication of source code or constraints. In
other words, constraint generation has linear time and space complexity.
10.4.2
Exercise [«, 3]: Deﬁne the size of an expression, of a type, and of a con-
straint, viewed as abstract syntax trees. Check that the size of Jt : TK is linear
in the sum of the sizes of t and T.
2
10.4.3
Exercise [Recommended, «, 3]: Compute and simplify, as best as you can,
the constraint Jlet f = λz.z in f f : TK.
2
We now state several properties of constraint generation. We begin with
soundness, whose statement was explained above.
10.4.4
Theorem [Soundness]: let Γ in Jt : TK, Γ ⊢t : T.
2
The following lemmas are used in the proof of the completeness property
and in a number of other occasions. The ﬁrst two state that Jt : TK is covari-
ant with respect to T. Roughly speaking, this means that enough subtyping
constraints are generated to achieve completeness with respect to hmd-Sub.
10.4.5
Lemma: Jt : TK ∧T ≤T′ ð Jt : T′K.
2
10.4.6
Lemma: X ̸∈ftv(T) implies ∃X.(Jt : XK ∧X ≤T) ≡Jt : TK.
2
The next lemma gives a simpliﬁed version of the second constraint genera-
tion rule, in the speciﬁc case where the expected type is an arrow type. Thus,
fresh type variables need not be generated; one may directly use the arrow’s
domain and codomain instead.
10.4.7
Lemma: Jλz.t : T1 →T2K is equivalent to let z : T1 in Jt : T2K.
2
We conclude with the completeness property. The theorem states that if,
within HM(X), t has type T under assumptions C and Γ, then C must be at

434
10
The Essence of ML Type Inference
least as speciﬁc as let Γ in Jt : TK. The statement requires C and Γ to have
no free program identiﬁers, which is natural, since they are part of an HM(X)
judgment. The hypothesis C ð ∃Γ excludes the somewhat pathological situa-
tion where Γ contains constraints not apparent in C. This hypothesis vanishes
when Γ is the initial environment; see Deﬁnition 10.5.2.
10.4.8
Theorem [Completeness]: Let C ð ∃Γ. Assume fpi(C, Γ) = . If C, Γ ⊢t : T
holds in HM(X), then C entails let Γ in Jt : TK.
2
10.5
Type Soundness
We are now ready to establish type soundness for our type system. The
statement that we wish to prove is sometimes known as Milner’s slogan:
“Well-typed programs do not go wrong” (Milner, 1978). Below, we deﬁne well-
typedness in terms of our constraint generation rules, for the sake of con-
venience, and establish type soundness with respect to that particular def-
inition. Theorems 10.3.6 and 10.4.8 imply that type soundness also holds
when well-typedness is deﬁned with respect to the typing judgments of DM
or HM(X). We establish type soundness by following Wright and Felleisen’s
so-called syntactic approach (1994). The approach consists of isolating two in-
dependent properties. Subject reduction, whose exact statement will be given
below, implies that well-typedness is preserved by reduction. Progress states
that no stuck conﬁguration is well-typed. It is immediate to check that, if both
properties hold, then no well-typed program can reduce to a stuck conﬁgu-
ration. Subject reduction itself depends on a key lemma, usually known as a
(term) substitution lemma. Here is a version of this lemma, stated in terms of
the constraint generation rules.
10.5.1
Lemma: let z : ∀¯X[Jt2 : T2K].T2 in Jt1 : T1K entails J[z , t2]t1 : T1K.
2
Before going on, let us give a few deﬁnitions and formulate several re-
quirements. First, we must deﬁne an initial environment Γ0, which assigns a
type scheme to every constant. A couple of requirements must be established
to ensure that Γ0 is consistent with the semantics of constants, as speciﬁed
by
δ-→. Second, we must extend constraint generation and well-typedness to
conﬁgurations, as opposed to programs, since reduction operates on conﬁgu-
rations. Last, we must formulate a restriction to tame the interaction between
side eﬀects and let-polymorphism, which is unsound if unrestricted.
10.5.2
Definition: Let Γ0 be an environment whose domain is the set of constants
Q. We require ftv(Γ0) = , fpi(Γ0) = , and ∃Γ0 ≡true. We refer to Γ0 as the
initial typing environment.
2

10.5
Type Soundness
435
10.5.3
Definition: Let ref be an isolated, invariant type constructor of signature
⋆⇒⋆. A store type M is a ﬁnite mapping from memory locations to types. We
write ref M for the environment that maps every m ∈dom(M) to ref M(m).
Assuming dom(µ) and dom(M) coincide, the constraint Jµ : MK is deﬁned
as the conjunction of the constraints Jµ(m) : M(m)K, where m ranges over
dom(µ). Under the same assumption, the constraint Jt/µ : T/MK is deﬁned
as Jt : TK ∧Jµ : MK. A closed conﬁguration t/µ is well-typed if and only if
there exist a type T and a store type M such that dom(µ) = dom(M) and the
constraint let Γ0; ref M in Jt/µ : T/MK is satisﬁable.
2
The type ref T is the type of references (that is, memory locations) that
store data of type T (TAPL, Chapter 13). It must be invariant in its parameter,
reﬂecting the fact that references may be both read and written.
A store is a complex object: it may contain values that indirectly refer to
each other via memory locations. In fact, it is a representation of the graph
formed by objects and pointers in memory, which may contain cycles. We rely
on store types to deal with such cycles. In the deﬁnition of well-typedness,
the store type M imposes a constraint on the contents of the store—the value
µ(m) must have type M(m)—but also plays the role of a hypothesis: by plac-
ing the constraint Jt/µ : T/MK within the context let ref M in [], we give
meaning to free occurrences of memory locations within Jt/µ : T/MK, and
stipulate that it is valid to assume that m has type M(m). In other words, we
essentially view the store as a large, mutually recursive binding of locations
to values. The context let Γ0 in [] gives meaning to occurrences of constants
within Jt/µ : T/MK.
We now deﬁne a relation between conﬁgurations that plays a key role in the
statement of the subject reduction property. The point of subject reduction is
to guarantee that well-typedness is preserved by reduction. However, such a
simple statement is too weak to be amenable to inductive proof. Thus, for the
purposes of the proof, we must be more speciﬁc. To begin, let us consider the
simpler case of a pure semantics, that is, a semantics without stores. Then,
we must state that if an expression t has type T under a certain constraint,
then its reduct t′ has type T under the same constraint. In terms of generated
constraints, this statement becomes: let Γ0 in Jt : TK entails let Γ0 in Jt′ : TK.
Let us now return to the general case, where a store is present. The state-
ment of well-typedness for a conﬁguration t/µ now involves a store type
M whose domain is that of µ. So, the statement of well-typedness for its
reduct t′/µ′ must involve a store type M′ whose domain is that of µ′, which
is larger if allocation occurred. The types of existing memory locations must
not change: we must request that M and M′ agree on dom(M), that is, M′
must extend M. Furthermore, the types assigned to new memory locations in

436
10
The Essence of ML Type Inference
dom(M′)\dom(M) might involve new type variables, that is, variables that do
not appear free in M or T. We must allow these variables to be hidden—that
is, existentially quantiﬁed—otherwise the entailment assertion cannot hold.
These considerations lead us to the following deﬁnition:
10.5.4
Definition: t/µ ⊑t′/µ′ holds if and only if, for every type T and for every
store type M such that dom(µ) = dom(M), there exist a set of type variables
¯Y and a store type M′ such that ¯Y # ftv(T, M) and ftv(M′) ⊆¯Y ∪ftv(M) and
dom(M′) = dom(µ′) and M′ extends M and
let Γ0; ref M in Jt /µ : T/M K
ð ∃¯Y.let Γ0; ref M′ in Jt′/µ′ : T/M′K.
The relation ⊑is intended to express a connection between a conﬁguration
and its reduct. Thus, subject reduction may be stated as: (−−▶) ⊆(⊑), that
is, ⊑is indeed a conservative description of reduction.
2
We have introduced an initial environment Γ0 and used it in the deﬁnition
of well-typedness, but we haven’t yet ensured that the type schemes assigned
to constants are an adequate description of their semantics. We now for-
mulate two requirements that relate Γ0 with
δ-→. They are specializations of
the subject reduction and progress properties to conﬁgurations that involve
an application of a constant. They represent proof obligations that must be
discharged when concrete deﬁnitions of Q,
δ-→, and Γ0 are given.
10.5.5
Definition: We require (i) (
δ-→) ⊆(⊑); and (ii) if the conﬁguration c v1 . . .
vk/µ (where k ≥0) is well-typed, then either it is reducible, or c v1 . . . vk is a
value.
2
The last point that remains to be settled before proving type soundness
is the interaction between side eﬀects and let-polymorphism. The following
example illustrates the problem:
let r = ref λz.z in let
= (r := λz.(z ˆ+ ˆ1)) in !r true
This expression reduces to true ˆ+ ˆ1, so it must not be well-typed. Yet, if
natural type schemes are assigned to ref, !, and := (see Example 10.7.5), then
it is well-typed with respect to the rules given so far, because r receives the
polymorphic type scheme ∀X.ref (X →X), which allows writing a function of
type int →int into r and reading it back with type bool →bool. The problem
is that let-polymorphism simulates a textual duplication of the let-bound
expression ref λz.z, while the semantics ﬁrst reduces it to a value m, causing
a new binding m , λz.z to appear in the store, then duplicates the address m.

10.5
Type Soundness
437
The new store binding is not duplicated: both copies of m refer to the same
memory cell. For this reason, generalization is unsound in this case, and must
be restricted. Many authors have attempted to come up with a sound type
system that accepts all pure programs and remains ﬂexible enough in the
presence of side eﬀects (Tofte, 1988; Leroy, 1992). These proposals are often
complex, which is why they have been abandoned in favor of an extremely
simple syntactic restriction, known as the value restriction (Wright, 1995).
10.5.6
Definition: A program satisﬁes the value restriction if and only if all subex-
pressions of the form let z = t1 in t2 are in fact of the form let z = v1 in
t2. In the following, we assume that either all constants have pure semantics,
or all programs satisfy the value restriction.
2
Put slightly diﬀerently, the value restriction states that only values may be
generalized. This eliminates the problem altogether, since duplicating values
does not aﬀect a program’s semantics. Note that any program that does not
satisfy the value restriction can be turned into one that does and has the
same semantics: it suﬃces to change let z = t1 in t2 into (λz.t2) t1 when
t1 is not a value. Of course, such a transformation may cause the program to
become ill-typed. In other words, the value restriction causes some perfectly
safe programs to be rejected. In particular, in its above form, it prevents gen-
eralizing applications of the form c v1 . . . vk, where c is a destructor of arity
k. This is excessive, because many destructors have pure semantics; only a
few, such as ref, allocate new mutable storage. Furthermore, we use pure
destructors to encode numerous language features (§10.7). Fortunately, it is
easy to relax the restriction to allow generalizing not only values, but also
a more general class of nonexpansive expressions, whose syntax guarantees
that such expressions cannot allocate new mutable storage (that is, expand
the domain of the store). The term nonexpansive was coined by Tofte (1988).
Nonexpansive expressions may include applications of the form c t1 . . . tk,
where c is a pure destructor of arity k and t1, . . . , tk are nonexpansive. Ex-
perience shows that this slightly relaxed restriction is acceptable in practice.
Some limitations remain: for instance, constructor functions (that is, func-
tions that do not allocate mutable storage and build a value) are regarded
as ordinary functions, so their applications are considered potentially expan-
sive, even though a naked constructor application would be a value and thus
considered nonexpansive. For instance, in the expression let f = c v in
let z = f w in t, where c is a constructor of arity 2, the partial application
c v, to which the name f is bound, is a constructor function (of arity 1). The
program variable z cannot receive a polymorphic type scheme, because f w
is not a value, even though it has the same semantic meaning as c v w, which
is a value. A recent improvement to the value restriction (Garrigue, 2004)

438
10
The Essence of ML Type Inference
provides a partial remedy. Technically, the eﬀect of the value restriction (as
stated in Deﬁnition 10.5.6) is summarized by the following result.
10.5.7
Lemma: Under the value restriction, the production E ::= let z = E in t
may be suppressed from the grammar of evaluation contexts (Figure 10-1)
without altering the operational semantics.
2
We are ﬁnished with deﬁnitions and requirements. Let us now turn to the
type soundness results.
10.5.8
Theorem [Subject reduction]: (−−▶) ⊆(⊑).
2
Subject reduction ensures that well-typedness is preserved by reduction.
10.5.9
Corollary: Let t/µ −−▶t′/µ′. If t/µ is well-typed, then so is t′/µ′.
2
Let us now state the progress property.
10.5.10
Theorem [Progress]: If t/µ is well-typed, then either it is reducible, or t is
a value.
2
We may now conclude:
10.5.11
Theorem [Type Soundness]: Well-typed source programs do not go wrong. 2
Recall that this result holds only if the requirements of Deﬁnition 10.5.5 are
met. In other words, some proof obligations remain to be discharged when
concrete deﬁnitions of Q,
δ-→, and Γ0 are given. This is illustrated by several
examples in §10.7 and §10.8.
10.6
Constraint Solving
We have introduced a parameterized constraint language, given equivalence
laws describing the interaction between its logical connectives, and exploited
them to prove theorems about type inference and type soundness, which
are valid independently of the nature of primitive constraints—the so-called
predicate applications. However, there would be little point in proposing a
parameterized constraint solver, because much of the diﬃculty of design-
ing an eﬃcient constraint solver lies precisely in the treatment of primitive
constraints and in its interaction with let-polymorphism. In this section, we
focus on constraint solving in the setting of an equality-only free tree model.
Thus, the constraint solver developed here allows performing type inference
for HM(=) (that is, for Damas and Milner’s type system) and for its extension
with recursive types. Of course, some of its mechanisms may be useful in
other settings. The program analysis and type inference literature abounds

10.6
Constraint Solving
439
with constraint-based systems of all kinds; a short list of papers that put par-
ticular emphasis on constraint solving is Aiken and Wimmers (1992), Hen-
glein (1993), Niehren, Müller, and Podelski (1997), Fähndrich (1999), Melski
and Reps (2000), Müller, Niehren, and Treinen (2001), Pottier (2001b), Niel-
son, Nielson, and Seidl (2002), McAllester (2002; 2003), and Simonet (2003).
We begin with a rule-based presentation of a standard, eﬃcient ﬁrst-order
uniﬁcation algorithm. This yields a constraint solver for a subset of the con-
straint language, except for the type scheme introduction and instantiation
forms. On top of it, we build a full constraint solver, which corresponds to
the code that accompanies this chapter.
Uniﬁcation
Uniﬁcation is the process of solving equations between terms. It was ﬁrst
introduced by Robinson (1971), but his original algorithm could be very in-
eﬃcient. Eﬃcient algorithms, which perform uniﬁcation in quasi-linear time,
were independently proposed by Martelli and Montanari (1976; 1982) and by
Huet (1976, Chapter 5). Both algorithms rely on a data structure that eﬃ-
ciently solves the union-ﬁnd problem (Tarjan, 1975). Martelli and Montanari’s
algorithm performs uniﬁcation in topological (top-down) order, and is thus
restricted to the acyclic case, that is, to the case where equations are inter-
preted in a syntactic model. In this speciﬁc case, uniﬁcation may actually be
performed in truly linear time (Paterson and Wegman, 1978). On the other
hand, Huet’s algorithm is able to deal with cyclic structures. The acyclicity
check is postponed until the very end of the solving process if equations are
interpreted within a syntactic model, or omitted altogether if working within
a regular tree model. Except for the ﬁnal acyclicity check, Huet’s algorithm is
incremental. Furthermore, it is simple; we present a version of it here. Knight
(1989) and Baader and Siekmann (1994) also describe Huet’s algorithm, and
provide further historical background and references.
Following Jouannaud and Kirchner (1991), we specify the algorithm as a
(nondeterministic) system of constraint rewriting rules. As suggested above,
it is almost the same for ﬁnite and regular tree models; only one rule, which
implements the occurs check, must be removed in the latter case. In other
words, the algorithm works with possibly cyclic data structures and does
not rely in an essential way on the occurs check. In order to more closely
reﬂect the behavior of the actual algorithm, and in particular the union-ﬁnd
data structure, we modify the syntax of constraints by replacing equations
with multi-equations—equations involving an arbitrary number of types, as
opposed to exactly two.

440
10
The Essence of ML Type Inference
10.6.1
Definition: Let there be, for every kind κ and for every n ≥1, a predicate
=n
κ, of signature κn ⇒·, whose interpretation is (n-ary) equality. The predicate
constraint =n
κ T1 . . . Tn is written T1 = . . . = Tn, and called a multi-equation.
We consider the constraint true as a multi-equation of length 0 and let ϵ
range over all multi-equations. In the following, we identify multi-equations
up to permutations of their members, so a multi-equation ϵ of kind κ may
be viewed as a ﬁnite multiset of types of kind κ. We write ϵ = ϵ′ for the
multi-equation obtained by concatenating ϵ and ϵ′.
2
Thus, we are interested in the following subset of the constraint language:
U ::= true | false | ϵ | U ∧U | ∃¯X.U
Equations are replaced with multi-equations; no other predicates are avail-
able. Type scheme introduction and instantiation forms are absent.
10.6.2
Definition: A multi-equation is standard if and only if its variable mem-
bers are distinct and it has at most one nonvariable member. A constraint
U is standard if and only if every multi-equation inside U is standard and
every variable that occurs (free or bound) in U is a member of at most one
multi-equation inside U. (Note that to be a member of ϵ implies, but is not
equivalent to, to occur free in ϵ.)
2
A union-ﬁnd algorithm maintains equivalence classes (that is, disjoint sets)
of variables, and associates with each class a descriptor, which in our case is
either absent or a nonvariable term. Thus, a standard constraint represents
a state of the union-ﬁnd algorithm. A constraint that is not standard may be
viewed as a superposition of a state of the union-ﬁnd algorithm, on the one
hand, and of control information, on the other hand. For instance, a multi-
equation of the form ϵ = T1 = T2, where ϵ is made up of distinct variables
and T1 and T2 are nonvariable terms, may be viewed, roughly speaking, as the
equivalence class ϵ = T1, together with a pending request to solve T1 = T2 and
to update the class’s descriptor accordingly. Because multi-equations encode
both state and control, our speciﬁcation of the uniﬁcation algorithm remains
rather abstract. It would be possible to give a lower-level description, where
state (standard conjunctions of multi-equations) and control (pending binary
equations) are distinguished.
10.6.3
Definition: Let U be a conjunction of multi-equations. Y is dominated by X
with respect to U (written: Y ≺U X) if and only if U contains a conjunct of the
form X = F ⃗T = ϵ, where Y ∈ftv(¯T). U is cyclic if and only if the graph of ≺U
exhibits a cycle.
2

10.6
Constraint Solving
441
(∃¯X.U1) ∧U2
→
∃¯X.(U1 ∧U2)
(S-ExAnd)
if ¯X # ftv(U2)
X = ϵ ∧X = ϵ′
→
X = ϵ = ϵ′
(S-Fuse)
X = X = ϵ
→
X = ϵ
(S-Stutter)
F ⃗X = F ⃗T = ϵ
→
⃗X = ⃗T ∧F ⃗X = ϵ
(S-Decompose)
F T1 . . . Ti . . . Tn = ϵ
→
∃X.(X = Ti ∧F T1 . . . X . . . Tn = ϵ)
(S-Name-1)
if Ti ̸∈V ∧X ̸∈ftv(T1, . . . , Tn, ϵ)
F ⃗T = F′ ⃗T′ = ϵ
→
false
(S-Clash)
if F ̸= F′
T
→
true
(S-Single)
U ∧true
→
U
(S-True)
U
→
false
(S-Cycle)
if the model is syntactic and U is cyclic
U[false]
→
false
(S-Fail)
if U ̸= []
Figure 10-10: Uniﬁcation
The speciﬁcation of the uniﬁcation algorithm consists of a set of constraint
rewriting rules, given in Figure 10-10. Rewriting is performed modulo α-
conversion, modulo permutations of the members of a multi-equation, mod-
ulo commutativity and associativity of conjunction, and under an arbitrary
context. The speciﬁcation is nondeterministic: several rule instances may be
simultaneously applicable.
S-ExAnd is a directed version of C-ExAnd, whose eﬀect is to ﬂoat up all
existential quantiﬁers. In the process, all multi-equations become part of a
single conjunction, possibly causing rules whose left-hand side is a conjunc-
tion of multi-equations, namely S-Fuse and S-Cycle, to become applicable.
S-Fuse identiﬁes two multi-equations that share a common variable X, and
fuses them. The new multi-equation is not necessarily standard, even if the
two original multi-equations were. Indeed, it may have repeated variables or
contain two nonvariable terms. The purpose of the next few rules, whose
left-hand side consists of a single multi-equation, is to deal with these sit-
uations. S-Stutter eliminates redundant variables. It only deals with vari-

442
10
The Essence of ML Type Inference
ables, as opposed to terms of arbitrary size, so as to have constant time cost.
The comparison of nonvariable terms is implemented by S-Decompose and
S-Clash. S-Decompose decomposes an equation between two terms whose
head symbols match. It produces a conjunction of equations between their
subterms, namely ⃗X = ⃗T. Only one of the two terms remains in the original
multi-equation, which may thus become standard. The terms ⃗X are copied:
there are two occurrences of ⃗X on the right-hand side. For this reason, we
require them to be type variables, as opposed to terms of arbitrary size. (We
slightly abuse notation by using ⃗X to denote a vector of type variables whose
elements are not necessarily distinct.) By doing so, we allow explicit reasoning
about sharing: since a variable represents a pointer to an equivalence class,
we explicitly specify that only pointers, not whole terms, are copied. As a
result of this decision, S-Decompose is not applicable when both terms at
hand have a nonvariable subterm. S-Name-1 remedies this problem by intro-
ducing a fresh variable that stands for one such subterm. When repeatedly
applied, S-Name-1 yields a uniﬁcation problem composed of so-called small
terms only—that is, where sharing has been made fully explicit. S-Clash com-
plements S-Decompose by dealing with the case where two terms with diﬀer-
ent head symbols are equated; in a free tree model, such an equation is false,
so failure is signaled. S-Single and S-True suppress multi-equations of size
1 and 0, respectively, which are tautologies. S-Cycle is the occurs check: it
signals failure if the constraint is cyclic. It is applicable only in the case of
syntactic uniﬁcation, that is, when ground types are ﬁnite trees. It is a global
check: its left-hand side is an entire conjunction of multi-equations. S-Fail
propagates failure; U ranges over uniﬁcation constraint contexts.
The constraint rewriting system in Figure 10-10 enjoys the following prop-
erties. First, rewriting is strongly normalizing, so the rules deﬁne a (nonde-
terministic) algorithm. Second, rewriting is meaning-preserving. Third, every
normal form is either false or of the form ∃¯X.U, where U is satisﬁable. The
latter two properties indicate that the algorithm is indeed a constraint solver.
10.6.4
Lemma: The rewriting system →is strongly normalizing.
2
10.6.5
Lemma: U1 →U2 implies U1 ≡U2.
2
10.6.6
Lemma: Every normal form is either false or of the form X[U], where X is an
existential constraint context, U is a standard conjunction of multi-equations
and, if the model is syntactic, U is acyclic. These conditions imply that U is
satisﬁable.
2

10.6
Constraint Solving
443
A Constraint Solver
On top of the uniﬁcation algorithm, we now deﬁne a constraint solver. Its
speciﬁcation is independent of the rules and strategy employed by the uni-
ﬁcation algorithm. However, the structure of the uniﬁcation algorithm’s nor-
mal forms as well as the logical properties of multi-equations are exploited
when performing generalization, that is, when creating and simplifying type
schemes. Like the uniﬁcation algorithm, the constraint solver is speciﬁed in
terms of a reduction system. However, the objects that are subject to rewrit-
ing are not just constraints: they have more complex structure. Working
with such richer states allows distinguishing the solver’s external language—
namely, the full constraint language, which is used to express the problem
that one wishes to solve—and an internal language, introduced below, which
is used to describe the solver’s private data structures. In the following, C
and D range over external constraints, that is, constraints that were part of
the solver’s input. External constraints are to be viewed as abstract syntax
trees, subject to no implicit laws other than α-conversion. As a simplifying
assumption, we require external constraints not to contain any occurrence of
false—otherwise the problem at hand is clearly false. Internal data structures
include uniﬁcation constraints U, as previously studied, and stacks, whose
syntax is as follows:
S ::= [] | S[[] ∧C] | S[∃¯X.[]] | S[let x : ∀¯X[[]].T in C] | S[let x : σ in []]
In the second and fourth productions, C is an external constraint. In the last
production, we require σ to be of the form ∀¯X[U].X, and we demand ∃σ ≡
true. Every stack may be viewed as a one-hole constraint context (page 410);
indeed, one may interpret [] as the empty context and ·[·] as context com-
position, which replaces the hole of its ﬁrst context argument with its second
context argument. A stack may also be viewed, literally, as a list of frames.
Frames may be added and deleted at the inner end of a stack, that is, near the
hole of the constraint context that it represents. We refer to the four kinds of
frames as conjunction, existential, let, and environment frames, respectively.
A state of the constraint solver is a triple S; U; C where S is a stack, U is a
uniﬁcation constraint, and C is an external constraint. The state S; U; C is to
be understood as a representation of the constraint S[U ∧C], that is, the
constraint obtained by placing both U and C within the hole of the constraint
context S. The notion of α-equivalence between states is deﬁned accordingly.
In particular, one may rename type variables in dtv(S), provided U and C are
renamed as well. In brief, the three components of a state play the following
roles. C is an external constraint that the solver intends to examine next. U

444
10
The Essence of ML Type Inference
is the internal state of the underlying uniﬁcation algorithm; one might think
of it as the knowledge that has been obtained so far. S tells where the type
variables that occur free in U and C are bound, associates type schemes with
the program variables that occur free in C, and records what should be done
after C is solved. The solver’s initial state is usually of the form []; true; C,
where C is the external constraint that one wishes to solve, that is, whose
satisﬁability one wishes to determine. If the constraint to be solved is of the
form let Γ0 in C, and if the type schemes that appear within Γ0 meet the
requirements that bear on environment frames, as deﬁned above, then it is
possible to pick let Γ0 in []; true; C as an initial state. For simplicity, we make
the (unessential) assumption that states have no free type variables.
The solver consists of a (nondeterministic) state rewriting system, given in
Figure 10-11. Rewriting is performed modulo α-conversion. S-Unify makes
the uniﬁcation algorithm a component of the constraint solver, and allows the
current uniﬁcation problem U to be solved at any time. Rules S-Ex-1 to S-Ex-4
ﬂoat existential quantiﬁers out of the uniﬁcation problem into the stack and
through the stack up to the nearest enclosing let frame, if there is any, or to
the outermost level, otherwise. Their side-conditions prevent capture of type
variables, and can always be satisﬁed by suitable α-conversion of the left-
hand state. If S; U; C is a normal form with respect to these ﬁve rules, then U
must be either false or a conjunction of standard multi-equations, and every
type variable in dtv(S) must be either universally quantiﬁed at a let frame or
existentially bound at the outermost level. (Recall that, by assumption, states
have no free type variables.) In other words, provided these rules are applied
in an eager fashion, there is no need for existential frames to appear in the
machine representation of stacks. Instead, it suﬃces to maintain, at every let
frame and at the outermost level, a list of the type variables that are bound
at this point and, conversely, to annotate every type variable in dtv(S) with
an integer rank, which allows telling, in constant time, where the variable is
bound: type variables of rank 0 are bound at the outermost level, and type
variables of rank k ≥1 are bound at the kth let frame down in the stack S.
The code that accompanies this chapter adopts this convention. Ranks were
initially described in Rémy (1992a) and have also been studied by McAllester
(2003).
Rules S-Solve-Eq to S-Solve-Let encode an analysis of the structure of the
third component of the current state. There is one rule for each possible case,
except false, which by assumption cannot arise, and true, which is dealt with
further on. S-Solve-Eq discovers an equation and makes it available to the
uniﬁcation algorithm. S-Solve-Id discovers an instantiation constraint x ⪯T
and replaces it with σ ⪯T, where the type scheme σ = S(x) is the type

10.6
Constraint Solving
445
S; U; C
→
S; U′; C
(S-Unify)
if U →U′
S; ∃¯X.U; C
→
S[∃¯X.[]]; U; C
(S-Ex-1)
if ¯X # ftv(C)
S[(∃¯X.S′) ∧D]; U; C
→
S[∃¯X.(S′ ∧D)]; U; C
(S-Ex-2)
if ¯X # ftv(D)
S[let x : ∀¯X[∃¯Y.S′].T in D]; U; C
→
S[let x : ∀¯X¯Y[S].′T in D]; U; C
(S-Ex-3)
if ¯Y # ftv(T)
S[let x : σ in ∃¯X.S′]; U; C
→
S[∃¯X.let x : σ in S′]; U; C
(S-Ex-4)
if ¯X # ftv(σ)
S; U; T1 = T2
→
S; U ∧T1 = T2; true
(S-Solve-Eq)
S; U; x ⪯T
→
S; U; S(x) ⪯T
(S-Solve-Id)
S; U; C1 ∧C2
→
S[[] ∧C2]; U; C1
(S-Solve-And)
S; U; ∃¯X.C
→
S[∃¯X.[]]; U; C
(S-Solve-Ex)
if ¯X # ftv(U)
S; U; let x : ∀¯X[D].T in C
→
S[let x : ∀¯X[[]].T in C]; U; D
(S-Solve-Let)
if ¯X # ftv(U)
S[[] ∧C]; U; true
→
S; U; C
(S-Pop-And)
S[let x : ∀¯X[[]].T in C]; U; true
→
S[let x : ∀¯XX[[]].X in C];
U ∧X = T; true
(S-Name-2)
if X ̸∈ftv(U, T) ∧T ̸∈V
S[let x : ∀¯XY[[]].X in C]; Y = Z = ϵ ∧U; true
→
S[let x : ∀¯XY[[]].θ(X) in C];
Y ∧Z = θ(ϵ) ∧θ(U); true
(S-Compress)
if Y ̸= Z ∧θ = [Y , Z]
S[let x : ∀¯XY[[]].X in C]; Y = ϵ ∧U; true
→
S[let x : ∀¯X[[]].X in C]; ϵ ∧U; true
(S-UnName)
if Y ̸∈X ∪ftv(ϵ, U)
S[let x : ∀¯X¯Y[[]].X in C]; U; true
→
S[∃¯Y.let x : ∀¯X[[]].X in C]; U; true
(S-LetAll)
if ¯Y # ftv(C) ∧∃¯X.U determines ¯Y
S[let x : ∀¯X[[]].X in C]; U1 ∧U2; true
→
S[let x : ∀¯X[U2].X in []]; U1; C
(S-Pop-Let)
if ¯X # ftv(U1) ∧∃¯X.U2 ≡true
S[let x : σ in []]; U; true
→
S; U; true
(S-Pop-Env)
Figure 10-11: A constraint solver

446
10
The Essence of ML Type Inference
scheme carried by the nearest environment frame that deﬁnes x in the stack
S. It is deﬁned as follows:
S[[] ∧C](x)
=
S(x)
S[∃¯X.[]](x)
=
S(x)
if ¯X # ftv(S(x))
S[let y : ∀¯X[[]].T in C](x)
=
S(x)
if ¯X # ftv(S(x))
S[let y : σ in []](x)
=
S(x)
if x ̸= y
S[let x : σ in []](x)
=
σ
If x ∈dpi(S) does not hold, then S(x) is undeﬁned and the rule is not appli-
cable. If it does hold, then the rule may always be made applicable by suitable
α-conversion of the left-hand state. Recall that, if σ is of the form ∀¯X[U].X,
where ¯X # ftv(T), then σ ⪯T stands for ∃¯X.(U ∧X = T). The process of
constructing this constraint is informally referred to as “taking an instance
of σ.” In the worst case, it is just as ineﬃcient as textually expanding the
corresponding let construct in the program’s source code, and leads to ex-
ponential time complexity. In practice, however, the uniﬁcation constraint
U is often compact because it was simpliﬁed before the environment frame
let x : σ in [] was created, which explains why the solver usually performs
well. (The creation of environment frames, performed by S-Pop-Let, is dis-
cussed below.) S-Solve-And discovers a conjunction. It arbitrarily chooses to
explore the left branch ﬁrst, and pushes a conjunction frame onto the stack,
so as to record that the right branch should be explored afterwards. S-Solve-
Ex discovers an existential quantiﬁer and enters it, creating a new existential
frame to record its existence. Similarly, S-Solve-Let discovers a let form and
enters its left-hand side, creating a new let frame to record its existence. The
choice of examining the left-hand side ﬁrst is not arbitrary. Indeed, examin-
ing the right-hand side ﬁrst would require creating an environment frame—
but environment frames must contain simpliﬁed type schemes of the form
∀¯X[U].X, whereas the type scheme ∀¯X[D].T is arbitrary. In other words, our
strategy is to simplify type schemes prior to allowing them to be copied by
S-Solve-Id, so as to avoid any duplication of eﬀort. The side-conditions of S-
Solve-Ex and S-Solve-Let may always be satisﬁed by suitable α-conversion
of the left-hand state.
Rules S-Solve-Eq to S-Solve-Let may be referred to as forward rules, be-
cause they “move down into” the external constraint, causing the stack to
grow. This process stops when the external constraint at hand becomes true.
Then part of the work has been ﬁnished, and the solver must examine the
stack in order to determine what to do next. This task is performed by the
last series of rules, which may be referred to as backward rules, because they
“move back out,” causing the stack to shrink and possibly scheduling new
external constraints for examination. These rules encode an analysis of the

10.6
Constraint Solving
447
structure of the innermost stack frame. There are three cases, correspond-
ing to conjunction, let, and environment frames. The case of existential stack
frames need not be considered, because rules S-Ex-2 to S-Ex-4 allow either
fusing them with let frames or ﬂoating them up to the outermost level, where
they shall remain inert. S-Pop-And deals with conjunction frames. The frame
is popped, and the external constraint that it carries is scheduled for exam-
ination. S-Pop-Env deals with environment frames. Because the right-hand
side of the let construct at hand has been solved—that is, turned into a uni-
ﬁcation constraint U—it cannot contain an occurrence of x. Furthermore, by
assumption, ∃σ is true. Thus, this environment frame is no longer useful: it
is destroyed. The remaining rules deal with let frames. Roughly speaking,
their purpose is to change the state S[let x : ∀¯X[[]].T in C]; U; true into
S[let x : ∀¯X[U].T in []]; true; C, that is, to turn the current uniﬁcation con-
straint U into a type scheme, turn the let frame into an environment frame,
and schedule the right-hand side of the let construct (that is, the external
constraint C) for examination. In fact, the process is more complex, because
the type scheme ∀¯X[U].T must be simpliﬁed before becoming part of an en-
vironment frame. The simpliﬁcation process is described by rules S-Name-2
to S-Pop-Let. In the following, we refer to type variables in ¯X as young and
to type variables in dtv(S) \ ¯X as old. The former are the universal quanti-
ﬁers of the type scheme that is being created; the latter contain its free type
variables.
S-Name-2 ensures that the body T of the type scheme that is being created
is a type variable, as opposed to an arbitrary term. If it isn’t, then it is re-
placed with a fresh variable X, and the equation X = T is added so as to recall
that X stands for T. Thus, the rule moves the term T into the current uniﬁca-
tion problem, where it potentially becomes subject to S-Name-1. This ensures
that sharing is made explicit everywhere. S-Compress determines that the
(young) type variable Y is an alias for the type variable Z. Then, every free
occurrence of Y other than its deﬁning occurrence is replaced with Z. In an
actual implementation, this occurs transparently when the union-ﬁnd algo-
rithm performs path compression (Tarjan, 1975, 1979). We note that the rule
does not allow substituting a younger type variable for an older one; indeed,
that would make no sense, since the younger variable could then possibly
escape its scope. In other words, in implementation terms, the union-ﬁnd al-
gorithm must be slightly modiﬁed so that, in each equivalence class, the rep-
resentative element is always a type variable with minimum rank. S-UnName
determines that the (young) type variable Y has no occurrences other than its
deﬁning occurrence in the current type scheme. (This occurs, in particular,
when S-Compress has just been applied.) Then, Y is suppressed altogether.
In the particular case where the remaining multi-equation ϵ has cardinal 1,

448
10
The Essence of ML Type Inference
it may then be suppressed by S-Single. In other words, the combination of
S-UnName and S-Single is able to suppress young unused type variables as
well as the term that they stand for. This may, in turn, cause new type vari-
ables to become eligible for elimination by S-UnName. In fact, assuming the
current uniﬁcation constraint is acyclic, an inductive argument shows that
every young type variable may be suppressed unless it is dominated either
by X or by an old type variable. (In the setting of a regular tree model, it is
possible to extend the rule so that young cycles that are not dominated either
by X or by an old type variable are suppressed as well.) S-LetAll is a directed
version of C-LetAll. It turns the young type variables ¯Y into old variables.
How to tell whether ∃¯X.U determines ¯Y is discussed later (see Lemma 10.6.7).
Why S-LetAll is an interesting and important rule will be explained shortly.
S-Pop-Let is meant to be applied when the current state has become a nor-
mal form with respect to S-Unify, S-Name-2, S-Compress, S-UnName, and
S-LetAll, that is, when the type scheme that is about to be created is fully
simpliﬁed. It splits the current uniﬁcation constraint into two components
U1 and U2, where U1 is made up entirely of old variables, as expressed by
the side-condition ¯X # ftv(U1), and U2 constrains young variables only, as
expressed by the side-condition ∃¯X.U2 ≡true. Note that U2 may still con-
tain free occurrences of old type variables, so the type scheme ∀¯X[U2].X that
appears on the right-hand side is not necessarily closed. It is not obvious
why such a decomposition must exist; Lemma 10.6.10 proves that it does.
Let us say for now that S-LetAll plays a role in guaranteeing its existence,
whence comes part of its importance. Once the decomposition U1 ∧U2 is
obtained, the behavior of S-Pop-Let is simple. The uniﬁcation constraint U1
concerns old variables only, that is, variables that are not quantiﬁed in the
current let frame; thus, it need not become part of the new type scheme and
may instead remain part of the current uniﬁcation constraint. This is justi-
ﬁed by C-LetAnd and C-InAnd* and corresponds to the diﬀerence between
hmx-Gen’ and hmx-Gen discussed in §10.3. The uniﬁcation constraint U2, on
the other hand, becomes part of the newly built type scheme ∀¯X[U2].X. The
property ∃¯X.U2 ≡true guarantees that the newly created environment frame
meets the requirements imposed on such frames. Note that the more type
variables are considered old, the larger U1 may become, and the smaller U2.
This is another reason why S-LetAll is interesting: by allowing more vari-
ables to be considered old, it decreases the size of the type scheme ∀¯X[U2].X,
making it cheaper to instantiate.
To complete our description of the constraint solver, there remains to ex-
plain how to decide when ∃¯X.U determines ¯Y, since this predicate occurs in
the side-condition of S-LetAll. The following lemma describes two important
situations where, by examining the structure of an equation, it is possible to

10.6
Constraint Solving
449
discover that a constraint C determines some of its free type variables ¯Y (Def-
inition 10.2.14). In the ﬁrst situation, the type variables ¯Y are equated with or
dominated by a distinct type variable X that occurs free in C. In that case,
because the model is a free tree model, the values of the type variables ¯Y
are determined by the value of X: they are subtrees of it at speciﬁc positions.
For instance, X = Y1 →Y2 determines Y1Y2, while ∃Y1.(X = Y1 →Y2) deter-
mines Y2. In the second situation, the type variables ¯Y are equated with a
term T, all of whose type variables are free in C. Again, the value of the type
variables ¯Y is then determined by the values of the type variables ftv(T). For
instance, X = Y1 →Y2 determines X, while ∃Y1.(X = Y1 →Y2) does not. In the
second situation, no assumption is in fact made about the model. (Note that
X = Y1 →Y2 determines Y1Y2 and determines X, but does not simultaneously
determine XY1Y2.)
10.6.7
Lemma: Let ¯X # ¯Y. Assume either ϵ is X = ϵ′, where X ̸∈¯X¯Y and ¯Y ⊆ftv(ϵ′), or
ϵ is ¯Y = T = ϵ′, where ftv(T) # ¯X¯Y. Then, ∃¯X.(C ∧ϵ) determines ¯Y.
2
Thanks to Lemma 10.6.7, an eﬃcient implementation of S-LetAll comes
to mind. The problem is, given a constraint ∃¯X.U, where U is a standard con-
junction of multi-equations, to determine the greatest subset ¯Y of ¯X such that
∃(¯X \ ¯Y).U determines ¯Y. By the ﬁrst part of the lemma, it is safe for ¯Y to in-
clude all members of ¯X that are directly or indirectly dominated (with respect
to U) by some free variable of ∃¯X.U. Those can be found, in time linear in
the size of U, by a top-down traversal of the graph of ≺U. By the second part
of the lemma, it is safe to close ¯Y under the closure law X ∈¯X ∧(∀Y
Y ≺U
X ⇒Y ∈¯Y) ⇒X ∈¯Y. That is, it is safe to also include all members of ¯X
whose descendants (with respect to U) have already been found to be mem-
bers of ¯Y. This closure computation may be performed, again in linear time,
by a bottom-up traversal of the graph of ≺U. When U is acyclic, it is possible
to show that this procedure is complete, that is, does compute the greatest
subset ¯Y that meets our requirement.
The above discussion has shown that when Y and Z are equated, if Y is
young and Z is old, then S-LetAll allows making Y old as well. If binding
information is encoded in terms of integer ranks, as suggested earlier, then
this remark may be formulated as follows: when Y and Z are equated, if the
rank of Y exceeds that of Z, then it may be decreased so that both ranks
match. As a result, it is possible to attach ranks with multi-equations, rather
than with variables. When two multi-equations are fused, the smaller rank is
kept. This treatment of ranks is inspired by Rémy (1992a); see the resolution
rule Fuse, as well as the simpliﬁcation rules Propagate and Realize, in that
paper.

450
10
The Essence of ML Type Inference
Let us now state the properties of the constraint solver. First, the reduction
system is terminating, so it deﬁnes an algorithm.
10.6.8
Lemma: The reduction system →is strongly normalizing.
2
Second, every rewriting step preserves the meaning of the constraint that
the current state represents. We recall that the state S; U; C is meant to rep-
resent the constraint S[U ∧C].
10.6.9
Lemma: S; U; C →S′; U′; C′ implies S[U ∧C] ≡S′[U′ ∧C′].
2
Last, we classify the normal forms of the reduction system:
10.6.10
Lemma: A normal form for the reduction system →is one of (i) S; U; x ⪯T,
where x ̸∈dpi(S); (ii) S; false; true; or (iii) X; U; true, where X is an existential
constraint context and U a satisﬁable conjunction of multi-equations.
2
In case (i), the constraint S[U ∧C] has a free program identiﬁer x. In other
words, the source program contains an unbound program identiﬁer. Such an
error could of course be detected prior to constraint solving, if desired. In
case (ii), the uniﬁcation algorithm failed. By Lemma 10.2.17, the constraint
S[U ∧C] is then false. In case (iii), the constraint S[U ∧C] is equivalent to
X[U], where U is satisﬁable, so it is satisﬁable as well. If the initial constraint
is closed, case (i) cannot arise, while cases (ii) and (iii) respectively denote
failure and success. Thus, Lemmas 10.6.9 and 10.6.10 indeed prove that the
algorithm is a constraint solver.
10.6.11
Remark: Type inference for ML-the-calculus is dexptime-complete (Kfoury,
Tiuryn, and Urzyczyn, 1990; Mairson, Kanellakis, and Mitchell, 1991). Thus,
our constraint solver cannot run any faster, asymptotically. This cost is es-
sentially due to let-polymorphism, which requires a constraint to be du-
plicated at every occurrence of a let-bound variable (S-Solve-Id). In order
to limit the amount of duplication to a bare minimum, it is important that
rule S-LetAll be applied before S-Pop-Let, allowing variables and constraints
that need not be duplicated to be shared. We have observed that algorithms
based on this strategy behave remarkably well in practice (Rémy, 1992a). In
fact, McAllester (2003) has proved that they have linear time complexity, pro-
vided the size of type schemes and the (left-) nesting depth of let constructs
are bounded. Unfortunately, many implementations of type inference for ML-
the-programming-language do not behave as eﬃciently as the algorithm pre-
sented here. Some spend an excessive amount of time in computing the set
of nongeneralizable type variables; some do not treat types as dags, thus los-
ing precious sharing information; others perform the expensive occurs check
after every uniﬁcation step, rather than only once at every let construct, as
suggested here (S-Pop-Let).
2

10.7
From ML-the-Calculus to ML-the-Language
451
10.7
From ML-the-Calculus to ML-the-Language
In this section, we explain how to extend the framework developed so far
to accommodate operations on values of base type (such as integers), pairs,
sums, references, and recursive function deﬁnitions. Then, we describe alge-
braic data type deﬁnitions. Last, the issues associated with recursive types
are brieﬂy discussed. For space reasons, exceptions are not discussed; the
reader is referred to (TAPL, Chapter 14).
Simple Extensions
Introducing new constants and extending
δ-→and Γ0 appropriately allows
adding many features of ML-the-programming-language to ML-the-calculus. In
each case, it is necessary to check that the requirements of Deﬁnition 10.5.5
are met, that is, to ensure that the new initial environment faithfully reﬂects
the nature of the new constants as well as the behavior of the new reduc-
tion rules. Below, we describe several such extensions in isolation. The ﬁrst
exercise establishes a technical result that is useful in the next exercises.
10.7.1
Exercise [Recommended, «]: Let Γ0 contain the binding c : ∀¯X.T1 →. . . →
Tn →T. Prove let Γ0 in Jc t1 . . . tn : T′K equivalent to let Γ0 in ∃¯X.(
Vn
i=1Jti :
TiK ∧T ≤T′).
2
10.7.2
Exercise [Integers, Recommended, ««]: Integer literals and integer addition
have been introduced and given an operational semantics in Examples 10.1.1,
10.1.2, and 10.1.4. Let us now introduce an isolated type constructor int of
signature ⋆and extend the initial environment Γ0 with the bindings ˆn : int,
for every integer n, and ˆ+ : int →int →int. Check that these deﬁnitions meet
the requirements of Deﬁnition 10.5.5.
2
10.7.3
Exercise [Pairs, ««, 3]: Pairs and pair projections have been introduced and
given an operational semantics in Examples 10.1.3 and 10.1.5. Let us now in-
troduce an isolated type constructor × of signature ⋆⊗⋆⇒⋆, covariant in
both of its parameters, and extend the initial environment Γ0 with the follow-
ing bindings:
(·, ·) :
∀XY.X →Y →X × Y
π1 :
∀XY.X × Y →X
π2 :
∀XY.X × Y →Y
Check that these deﬁnitions meet the requirements of Deﬁnition 10.5.5.
2
10.7.4
Exercise [Sums, ««, 3]: Sums have been introduced and given an operational
semantics in Example 10.1.7. Let us now introduce an isolated type construc-
tor + of signature ⋆⊗⋆⇒⋆, covariant in both of its parameters, and extend

452
10
The Essence of ML Type Inference
the initial environment Γ0 with the following bindings:
inj1 :
∀XY.X →X + Y
inj2 :
∀XY.Y →X + Y
case :
∀XYZ.(X + Y) →(X →Z) →(Y →Z) →Z
Check that these deﬁnitions meet the requirements of Deﬁnition 10.5.5.
2
10.7.5
Exercise [References, «««]: References have been introduced and given an
operational semantics in Example 10.1.9. The type constructor ref has been
introduced in Deﬁnition 10.5.3. Let us now extend the initial environment Γ0
with the following bindings:
ref :
∀X.X →ref X
! :
∀X.ref X →X
:= :
∀X.ref X →X →X
Check that these deﬁnitions meet the requirements of Deﬁnition 10.5.5.
2
10.7.6
Exercise [Recursion, Recommended, «««, 3]: The ﬁxpoint combinator fix
has been introduced and given an operational semantics in Example 10.1.10.
Let us now extend the initial environment Γ0 with the following binding:
fix :
∀XY.((X →Y) →(X →Y)) →X →Y
Check that these deﬁnitions meet the requirements of Deﬁnition 10.5.5. Re-
call how the letrec syntactic sugar was deﬁned in Example 10.1.10, and
check that this gives rise to the following constraint generation rule:
let Γ0 in Jletrec f = λz.t1 in t2 : TK
≡
let Γ0 in let f : ∀XY[let f : X →Y; z : X in Jt1 : YK].X →Y in Jt2 : TK
Note the somewhat peculiar structure of this constraint: the program variable
f is bound twice in it, with diﬀerent type schemes. The constraint requires
all occurrences of f within t1 to be assigned the monomorphic type X →Y.
This type is generalized and turned into a type scheme before inspecting t2,
however, so every occurrence of f within t2 may receive a diﬀerent type, as
usual with let-polymorphism. A more powerful way of typechecking recur-
sive function deﬁnitions, proposed by (Mycroft, 1984) and known as polymor-
phic recursion, allows the types of occurrences of f within t1 to be possibly
distinct instances of a single type scheme. However, type inference for this
extension is equivalent to semi-uniﬁcation (Henglein, 1993), which has been
proved undecidable (Kfoury, Tiuryn, and Urzyczyn, 1993). Hence, type infer-
ence must either require type annotations or rely on a semi-algorithm.
2

10.7
From ML-the-Calculus to ML-the-Language
453
In the exercises above, we have considered a number of extensions (inte-
gers, booleans, pairs, etc.) in isolation. We have checked that each of them
preserves type soundness. Unfortunately, this does not in general imply that
their combination preserves type soundness. In fact, it is possible to prove
that these extensions are independent in a suitable sense and that indepen-
dent extensions may be safely combined. Unfortunately, we lack space to
further explain these notions.
Algebraic Data Types
Exercises 10.7.3 and 10.7.4 have shown how to extend the language with bi-
nary, anonymous products and sums. These constructs are quite general but
still have several shortcomings. First, they are only binary, while we would
like to have k-ary products and sums, for arbitrary k ≥0. Such a general-
ization is of course straightforward. Second, more interestingly, their compo-
nents must be referred to by numeric index (as in “extract the second com-
ponent of the pair”), rather than by name (“extract the component named y”).
In practice, it is crucial to use names, because they make programs more
readable and more robust in the face of changes. One could introduce a
mechanism that allows deﬁning names as syntactic sugar for numeric in-
dices. That would help a little, but not much, because these names would
not appear in types, which would still be made of anonymous products and
sums. Third, in the absence of recursive types, products and sums do not
have suﬃcient expressiveness to allow deﬁning unbounded data structures,
such as lists. Indeed, it is easy to see that every value whose type T is com-
posed of base types (int, bool, etc.), products, and sums must have bounded
size, where the bound | T | is a function of T. More precisely, up to a con-
stant factor, we have | int | = | bool | = 1, | T1 × T2 | = 1 + | T1 | + | T2 |, and
| T1 + T2 | = 1 + max(| T1 |, | T2 |). The following example describes another
facet of the same problem.
10.7.7
Example: A list is either empty, or a pair of an element and another list. So,
it seems natural to try and encode the type of lists as a sum of some arbitrary
type (say, unit) on the one hand, and of a product of some element type and of
the type of lists itself on the other hand. With this encoding in mind, we can
go ahead and write code—for instance, a function that computes the length
of a list:
letrec length = λl.case l (λ .ˆ0) (λz.ˆ1 ˆ+ length (π2 z))
We have used integers, pairs, sums, and the letrec construct introduced in
the previous section. The code analyzes the list l using a case construct.

454
10
The Essence of ML Type Inference
If the left branch is taken, the list is empty, so 0 is returned. If the right
branch is taken, then z becomes bound to a pair of some element and the
tail of the list. The latter is obtained using the projection operator π2. Its
length is computed using a recursive call to length and incremented by 1.
This code makes perfect sense. However, applying the constraint generation
and constraint solving algorithms eventually leads to an equation of the form
X = Y + (Z × X), where X stands for the type of l. This equation accurately re-
ﬂects our encoding of the type of lists. However, in a syntactic model, it has
no solution, so our deﬁnition of length is ill-typed. It is possible to adopt
a free regular tree model, thus introducing equirecursive types into the sys-
tem (TAPL, Chapter 20); however, there are good reasons not to do so (see
the section on Recursive Types on p. 459).
2
To work around this problem, ML-the-programming-language oﬀers alge-
braic data type deﬁnitions, whose elegance lies in the fact that, while repre-
senting only a modest theoretical extension, they do solve the three problems
mentioned above. An algebraic data type may be viewed as an abstract type
that is declared to be isomorphic to a (k-ary) product or sum type with named
components. The type of each component is declared, as well, and may refer
to the algebraic data type that is being deﬁned: thus, algebraic data types are
isorecursive (TAPL, Chapter 20). In order to allow suﬃcient ﬂexibility when
declaring the type of each component, algebraic data type deﬁnitions may be
parameterized by a number of type variables. Last, in order to allow the de-
scription of complex data structures, it is necessary to allow several algebraic
data types to be deﬁned at once; the deﬁnitions may then be mutually recur-
sive. In fact, in order to simplify this formal presentation, we assume that
all algebraic data types are deﬁned at once at the beginning of the program.
This decision is, of course, at odds with modular programming but will not
otherwise be a problem.
In the following, D ranges over a set of data types. We assume that data
types form a subset of type constructors. We require each of them to be iso-
lated and to have image kind ⋆. Furthermore, ℓranges over a set L of labels,
which we use both as data constructors and as record labels. An algebraic
data type deﬁnition is either a variant type deﬁnition or a record type deﬁni-
tion, whose respective forms are
D ⃗X ≈
kX
i=1
ℓi : Ti
and
D ⃗X ≈
k
Y
i=1
ℓi : Ti.
In either case, k must be nonnegative. If D has signature ⃗κ ⇒⋆, then the type
variables ⃗X must have kind ⃗κ. Every Ti must have kind ⋆. We refer to ¯X as
the parameters and to ⃗T (the vector formed by T1, . . . , Tk) as the components

10.7
From ML-the-Calculus to ML-the-Language
455
of the deﬁnition. The parameters are bound within the components, and the
deﬁnition must be closed, that is, ftv(⃗T) ⊆¯X must hold. Last, for an algebraic
data type deﬁnition to be valid, the behavior of the type constructor D with
respect to subtyping must match its deﬁnition. This requirement is clariﬁed
below.
10.7.8
Definition: Consider an algebraic data type deﬁnition whose parameters
and components are respectively ⃗X and ⃗T. Let ⃗X′ and ⃗T′ be their images under
an arbitrary renaming. Then, D ⃗X ≤D ⃗X′ ð ⃗T ≤⃗T′ must hold.
2
Because it is stated in terms of an entailment assertion, the above require-
ment bears on the interpretation of subtyping. The idea is, since D ⃗X is de-
clared to be isomorphic to (a sum or a product of) ⃗T, whenever two types
built with D are comparable, their unfoldings should be comparable as well.
The reverse entailment assertion is not required for type soundness, and it
is sometimes useful to declare algebraic data types that do not validate it—
so-called phantom types (Fluet and Pucella, 2002). Note that the requirement
may always be satisﬁed by making the type constructor D invariant in all of
its parameters. Indeed, in that case, D ⃗X ≤D ⃗X′ entails ⃗X = ⃗X′, which must en-
tail ⃗T = ⃗T′ since ⃗T′ is precisely [⃗X , ⃗X′]⃗T. In an equality free tree model, every
type constructor is naturally invariant, so the requirement is trivially satis-
ﬁed. In other settings, however, it is often possible to satisfy the requirement
of Deﬁnition 10.7.8 while assigning D a less restrictive variance. The following
example illustrates such a case.
10.7.9
Example: Let list be a data type of signature ⋆⇒⋆. Let Nil and Cons be data
constructors. Then, the following is a deﬁnition of list as a variant type:
list X ≈Σ (Nil : unit; Cons : X × list X)
Because data types form a subset of type constructors, it is valid to form the
type list X in the right-hand side of the deﬁnition, even though we are still in
the process of deﬁning the meaning of list. In other words, data type deﬁni-
tions may be recursive. However, because ≈is not interpreted as equality, the
type list X is not a recursive type: it is nothing but an application of the unary
type constructor list to the type variable X. To check that the deﬁnition of list
satisﬁes the requirement of Deﬁnition 10.7.8, we must ensure that
list X ≤list X′ ð unit ≤unit ∧X × listX ≤X′ × list X′
holds. This assertion is equivalent to listX ≤list X′ ð X ≤X′. To satisfy the
requirement, it is suﬃcient to make list a covariant type constructor, that is,
to deﬁne subtyping in the model so that list X ≤listX′ ≡X ≤X′ holds.

456
10
The Essence of ML Type Inference
Let tree be a data type of signature ⋆⇒⋆. Let root and sons be record
labels. Then, the following is a deﬁnition of tree as a record type:
tree X ≈Π (root : X; sons : list (tree X))
This deﬁnition is again recursive, and relies on the previous deﬁnition. Be-
cause list is covariant, it is straightforward to check that the deﬁnition of tree
is valid if tree is made a covariant type constructor as well.
2
A prologue is a set of algebraic data type deﬁnitions, where each data type
is deﬁned at most once and where each data constructor or record label ap-
pears at most once. A program is a pair of a prologue and an expression.
The eﬀect of a prologue is to enrich the programming language with new
constants. That is, a variant type deﬁnition extends the operational seman-
tics with several injections and a case construct, as in Example 10.1.7. A
record type deﬁnition extends it with a record formation construct and sev-
eral projections, as in Examples 10.1.3 and 10.1.5. In either case, the initial
typing environment Γ0 is extended with information about these new con-
stants. Thus, algebraic data type deﬁnitions might be viewed as a simple
conﬁguration language that allows specifying in which instance of ML-the-
calculus the expression that follows the prologue should be typechecked and
interpreted. Let us now give a precise account of this phenomenon.
To begin, suppose the prologue contains the deﬁnition D ⃗X ≈
Pk
i=1 ℓi : Ti.
Then, for each i ∈{1, . . . , k}, a constructor of arity 1, named ℓi, is introduced.
Furthermore, a destructor of arity k + 1, named caseD, is introduced. When
k > 0, it is common to write case t [ℓi : ti]k
i=1 for the application caseD t t1
. . . tn. The operational semantics is extended with the following reduction
rules, for i ∈{1, . . . , k}:
case (ℓi v) [ℓj : vj]k
j=1
δ-→vi v
(R-Alg-Case)
For each i ∈{1, . . . , k}, the initial environment is extended with the binding
ℓi : ∀¯X.Ti →D ⃗X. It is further extended with the binding caseD : ∀¯XZ.D ⃗X →
(T1 →Z) →. . . (Tk →Z) →Z.
Now, suppose the prologue contains the deﬁnition D ⃗X ≈
Qk
i=1 ℓi : Ti. Then,
for each i ∈{1, . . . , k}, a destructor of arity 1, named ℓi, is introduced. Fur-
thermore, a constructor of arity k, named makeD, is introduced. It is common
to write t.ℓfor the application ℓt and, when k > 0, to write {ℓi = ti}k
i=1 for
the application makeD t1 . . . tk. The operational semantics is extended with
the following reduction rules, for i ∈{1, . . . , k}:
({ℓj = vj}k
j=1).ℓi
δ-→vi
(R-Alg-Proj)
For each i ∈{1, . . . , k}, the initial environment is extended with the binding
ℓi : ∀¯X.D ⃗X →Ti. It is further extended with the binding makeD : ∀¯X.T1 →. . . →
Tk →D ⃗X.

10.7
From ML-the-Calculus to ML-the-Language
457
10.7.10
Example: The eﬀect of deﬁning list (Example 10.7.9) is to make Nil and Cons
data constructors of arity 1 and to introduce a binary destructor caselist. The
deﬁnition also extends the initial environment as follows:
Nil :
∀X.unit →list X
Cons :
∀X.X × list X →list X
caselist :
∀XZ.listX →(unit →Z) →(X × listX →Z) →Z
Thus, the value Cons(ˆ0, Nil()), an integer list of length 1, has type list int. A
function that computes the length of a list may now be written as follows:
letrec length = λl.case l [ Nil : λ .ˆ0 | Cons : λz.ˆ1 ˆ+ length (π2 z) ]
Recall that this notation is syntactic sugar for
letrec length = λl.caselist l (λ .ˆ0) (λz.ˆ1 ˆ+ length (π2 z))
The diﬀerence with the code in Example 10.7.7 appears minimal: the case
construct is now annotated with the data type list. As a result, the type infer-
ence algorithm employs the type scheme assigned to caselist, which is derived
from the deﬁnition of list, instead of the type scheme assigned to the anony-
mous case construct, given in Exercise 10.7.4. This is good for a couple of
reasons. First, the former is more informative than the latter, because it con-
tains the type Ti associated with the data constructor ℓi. Here, for instance,
the generated constraint requires the type of z to be X × list X for some X, so
a good error message would be given if a mistake was made in the second
branch, such as omitting the use of π2. Second, and more fundamentally,
the code is now well-typed, even in the absence of recursive types. In Exam-
ple 10.7.7, a cyclic equation was produced because case required the type of
l to be a sum type and because a sum type carries the types of its left and
right branches as subterms. Here, caselist requires l to have type list X for
some X. This is an abstract type: it does not explicitly contain the types of
the branches. As a result, the generated constraint no longer involves a cyclic
equation. It is, in fact, satisﬁable; the reader may check that length has type
∀X.listX →int, as expected.
2
Example 10.7.10 stresses the importance of using declared, abstract types,
as opposed to anonymous, concrete sum or product types, in order to obviate
the need for recursive types. The essence of the trick lies in the fact that the
type schemes associated with operations on algebraic data types implicitly
fold and unfold the data type’s deﬁnition. More precisely, let us recall the type
scheme assigned to the ith injection in the setting of (k-ary) anonymous sums:
it is ∀X1 . . . Xk.Xi →X1 + . . . + Xk, or, more concisely, ∀X1 . . . Xk.Xi →
Pk
i=1 Xi.

458
10
The Essence of ML Type Inference
By instantiating each Xi with Ti and generalizing again, we ﬁnd that a more
speciﬁc type scheme is ∀¯X.Ti →
Pk
i=1 Ti. Perhaps this could have been the
type scheme assigned to ℓi? Instead, however, it is ∀¯X.Ti →D ⃗X. We now re-
alize that the latter type scheme not only reﬂects the operational behavior
of the ith injection but also folds the deﬁnition of the algebraic data type D
by turning the anonymous sum
Pk
i=1 Ti—which forms the deﬁnition’s right-
hand side—into the parameterized abstract type D ⃗X—which is the deﬁnition’s
left-hand side. Conversely, the type scheme assigned to caseD unfolds the
deﬁnition. The situation is identical in the case of record types: in either case,
constructors fold, destructors unfold. In other words, occurrences of data
constructors and record labels in the code may be viewed as explicit instruc-
tions for the typechecker to fold or unfold an algebraic data type deﬁnition.
This mechanism is characteristic of isorecursive types.
10.7.11
Exercise [«, 3]: For a ﬁxed k, check that all of the machinery associated
with k-ary anonymous products—that is, constructors, destructors, reduction
rules, and extensions to the initial typing environment—may be viewed as the
result of a single algebraic data type deﬁnition. Conduct a similar check in the
case of k-ary anonymous sums.
2
10.7.12
Exercise [«««, 3]: Check that the above deﬁnitions meet the requirements
of Deﬁnition 10.5.5.
2
10.7.13
Exercise [«««, 3]: For the sake of simplicity, we have assumed that all data
constructors have arity one. If desired, it is possible to accept variant data
type deﬁnitions of the form D ⃗X ≈
Pk
i=1 ℓi : ⃗Ti, where the arity of the data con-
structor ℓi is the length of the vector ⃗Ti, and may be an arbitrary nonnegative
integer. This allows, for instance, altering the deﬁnition of list so that the
data constructors Nil and Cons are respectively nullary and binary. Make the
necessary changes in the above deﬁnitions and check that the requirements
of Deﬁnition 10.5.5 are still met.
2
One signiﬁcant drawback of algebraic data type deﬁnitions resides in the
fact that a label ℓcannot be shared by two distinct variant or record type
deﬁnitions. Indeed, every algebraic data type deﬁnition extends the calculus
with new constants. Strictly speaking, our presentation does not allow a sin-
gle constant c to be associated with two distinct deﬁnitions. Even if we did
allow such a collision, the initial environment would contain two bindings
for c, one of which would then hide the other. This phenomenon arises in
actual implementations of ML-the-programming-language, where a new alge-
braic data type deﬁnition may hide some of the data constructors or record
labels introduced by a previous deﬁnition. An elegant solution to this lack of
expressiveness is discussed in §10.8.

10.7
From ML-the-Calculus to ML-the-Language
459
Recursive Types
We have shown that specializing HM(X) with an equality-only syntactic model
yields HM(=), a constraint-based formulation of Damas and Milner’s type
system. Similarly, it is possible to specialize HM(X) with an equality-only
free regular tree model, yielding a constraint-based type system that may be
viewed as an extension of Damas and Milner’s type discipline with recursive
types. This ﬂavor of recursive types is sometimes known as equirecursive,
since cyclic equations, such as X = X →X, are then satisﬁable. Our theo-
rems about type inference and type soundness, which are independent of the
model, remain valid. The constraint solver described in §10.6 may be used
in the setting of an equality-only free regular tree model; the only diﬀerence
with the syntactic case is that the occurs check is no longer performed.
Note that, although ground types are regular, types remain ﬁnite objects:
their syntax is unchanged. The µ notation commonly employed to describe
recursive types may be emulated using type equations: for instance, the no-
tation µX.X →X corresponds, in our constraint-based approach, to the type
scheme ∀X[X = X →X].X.
Although recursive types come for free, as explained above, they have not
been adopted in mainstream programming languages based on ML-the-type-
system. The reason is pragmatic: experience shows that many nonsensical
expressions are well-typed in the presence of recursive types, whereas they
are not in their absence. Thus, the gain in expressiveness is oﬀset by the fact
that many programming mistakes are detected later than otherwise possible.
Consider, for instance, the following OCaml session:
ocaml -rectypes
# let rec map f = function
| [] →[]
| x :: l →(map f x) :: (map f l);;
val map : ’a →(’b list as ’b) →(’c list as ’c) = <fun>
This nonsensical version of map is essentially useless, yet well-typed. Its prin-
cipal type scheme, in our notation, is ∀XYZ[Y = list Y ∧Z = list Z].X →Y →Z.
In the absence of recursive types, it is ill-typed, since the constraint Y =
listY ∧Z = listZ is then false.
The need for equirecursive types is usually suppressed by the presence of
algebraic data types, which oﬀer isorecursive types, in the language. Yet, they
are still necessary in some situations, such as in Objective Caml’s extensions
with objects (Rémy and Vouillon, 1998) or polymorphic variants (Garrigue,
1998, 2000, 2002), where recursive object or variant types are commonly in-
ferred. In order to allow recursive object or variant types while still rejecting
the above version of map, Objective Caml’s constraint solver implements a

460
10
The Essence of ML Type Inference
selective occurs check, which forbids cycles unless they involve the type con-
structors ⟨·⟩or [·] respectively associated with objects and variants. The
corresponding model is a tree model where every inﬁnite path down a tree
must encounter the type constructor ⟨·⟩or [·] inﬁnitely often.
10.8
Rows
In §10.7, we have shown how to extend ML-the-programming-language with
algebraic data types, that is, variant and record type deﬁnitions, which we
now refer to as simple. This mechanism has a severe limitation: two distinct
deﬁnitions must deﬁne incompatible types. As a result, one cannot hope
to write code that uniformly operates over variants or records of diﬀerent
shapes, because the type of such code is not even expressible.
For instance, it is impossible to express the type of the polymorphic record
access operation, which retrieves the value stored at a particular ﬁeld ℓinside
a record, regardless of which other ﬁelds are present. Indeed, if the label
ℓappears with type T in the deﬁnition of the simple record type D ⃗X, then
the associated record access operation has type ∀¯X.D ⃗X →T. If ℓappears
with type T′ in the deﬁnition of another simple record type, say D′ ⃗X′, then
the associated record access operation has type ∀¯X
′.D′ ⃗X′ →T′; and so on.
The most precise type scheme that subsumes all of these incomparable type
schemes is ∀XY.X →Y. It is, however, not a sound type scheme for the record
access operation. Another powerful operation whose type is currently not
expressible is polymorphic record extension, which copies a record and stores
a value at ﬁeld ℓin the copy, possibly creating the ﬁeld if it did not previously
exist, again regardless of which other ﬁelds are present. (If ℓwas known to
previously exist, the operation is known as polymorphic record update.)
In order to assign types to polymorphic record operations, we must do
away with record type deﬁnitions: we must replace named record types, such
as D ⃗X, with structural record types that provide a direct description of the
record’s domain and contents. (Following the analogy between a record and
a partial function from labels to values, we use the word domain to refer to
the set of ﬁelds that are deﬁned in a record.) For instance, a product type is
structural: the type T1 × T2 is the (undeclared) type of pairs whose ﬁrst com-
ponent has type T1 and whose second component has type T2. Thus, we wish
to design record types that behave very much like product types. In doing so,
we face two orthogonal diﬃculties. First, as opposed to pairs, records may
have diﬀerent domains. Because the type system must statically ensure that
no undeﬁned ﬁeld is accessed, information about a record’s domain must be
made part of its type. Second, because we suppress record type deﬁnitions,

10.8
Rows
461
labels must now be predeﬁned. However, for eﬃciency and modularity rea-
sons, it is impossible to explicitly list every label in existence in every record
type.
In what follows, we explain how to address the ﬁrst diﬃculty in the simple
setting of a ﬁnite set of labels. Then we introduce rows, which allow dealing
with an inﬁnite set of labels, and address the second diﬃculty. We deﬁne the
syntax and logical interpretation of rows, study the new constraint equiva-
lence laws that arise in their presence, and extend the ﬁrst-order uniﬁcation
algorithm with support for rows. Then we review several applications of rows,
including polymorphic operations on records, variants, and objects, and dis-
cuss alternatives to rows.
Because our interest is in typechecking and type inference issues, we do
not address the compilation issue: how does one eﬃciently compile poly-
morphic records or polymorphic variants? A few relevant papers are Pugh
and Weddell (1990), Ohori (1995), and Garrigue (1998). The problem of op-
timizing message dispatch in object-oriented languages, which has received
considerable attention in the literature, is related.
Records with Finite Carrier
Let us temporarily assume that L is ﬁnite. In fact, for the sake of deﬁniteness,
let us assume that L is the three-element set {ℓa, ℓb, ℓc}.
To begin, let us consider only full records, whose domain is exactly L—in
other words, tuples indexed by L. To describe them, it is natural to introduce
a type constructor Π of signature ⋆⊗⋆⊗⋆⇒⋆. The type Π Ta Tb Tc rep-
resents all records where the ﬁeld ℓa (respectively ℓb, ℓc) contains a value
of type Ta (respectively Tb, Tc). Note that Π is nothing but a product type
constructor of arity 3. The basic operations on records, namely creation of
a record out of a default value, which is stored into every ﬁeld, update of
a particular ﬁeld (say, ℓb), and access to a particular ﬁeld (say, ℓb), may be
assigned the following type schemes:
{·} :
∀X.X →Π X X X
{· with ℓb = ·} :
∀XaXbX′
bXc.Π Xa Xb Xc →X′
b →Π Xa X′
b Xc
·.{ℓb} :
∀XaXbXc.Π Xa Xb Xc →Xb
Here, polymorphism allows updating or accessing a ﬁeld without knowledge
of the types of the other ﬁelds. This ﬂexibility stems from the key property
that all record types are formed using a single Π type constructor.
This is ﬁne, but in general, the domain of a record is not necessarily L: it
may be a subset of L. How may we deal with this fact while maintaining the
above key property? A naive approach consists of encoding arbitrary records

462
10
The Essence of ML Type Inference
in terms of full records, using the standard algebraic data type option, whose
deﬁnition is option X ≈pre X+abs. We use pre for present and abs for absent:
indeed, a ﬁeld that is deﬁned with value v is encoded as a ﬁeld with value pre
v, while an undeﬁned ﬁeld is encoded as a ﬁeld with value abs. Thus, an arbi-
trary record whose ﬁelds, if present, have types Ta, Tb, and Tc, respectively,
may be encoded as a full record of type Π (option Ta) (option Tb) (option
Tc). This naive approach suﬀers from a serious drawback: record types still
contain no domain information. As a result, ﬁeld access must involve a dy-
namic check, so as to determine whether the desired ﬁeld is present; in our
encoding, this corresponds to the use of caseoption.
To avoid this overhead and increase programming safety, we must move
this check from runtime to compile time. In other words, we must make the
type system aware of the diﬀerence between pre and abs. To do so, we re-
place the deﬁnition of option by two separate algebraic data type deﬁnitions,
namely pre X ≈pre X and abs ≈abs. In other words, we introduce a unary
type constructor pre, whose only associated data constructor is pre, and a
nullary type constructor abs, whose only associated data constructor is abs.
Record types now contain domain information; for instance, a record of type
Π abs (pre Tb) (pre Tc) must have domain {ℓb, ℓc}. Thus, the type of a ﬁeld
tells whether it is deﬁned. Since the type pre has no data constructors other
than pre, the accessor pre−1, whose type is ∀X.pre X →X, and which allows
retrieving the value stored in a ﬁeld, cannot fail. Thus, the dynamic check has
been eliminated.
To complete the deﬁnition of our encoding, we now deﬁne operations on
arbitrary records in terms of operations on full records. To distinguish be-
tween the two, we write the former with angle braces, instead of curly braces.
The empty record ⟨⟩, where all ﬁelds are undeﬁned, may be deﬁned as {abs}.
Extension at a particular ﬁeld (say, ℓb) ⟨· with ℓb = ·⟩is deﬁned as λr.λz.
{r with ℓb = pre z}. Access at a particular ﬁeld (say, ℓb) ·.⟨ℓb⟩is deﬁned as
λz.pre−1z.{ℓb}. It is straightforward to check that these operations have the
following principal type schemes:
⟨⟩:
Π abs abs abs
⟨· with ℓb = ·⟩:
∀XaXbX′
bXc.Π Xa Xb Xc →X′
b →Π Xa (pre X′
b) Xc
·.⟨ℓb⟩:
∀XaXbXc.Π Xa (pre Xb) Xc →Xb
It is important to notice that the type schemes associated with extension
and access at ℓb are polymorphic in Xa and Xc, which now means that these
operations are insensitive, not only to the type, but also to the presence or
absence of the ﬁelds ℓa and ℓc. Furthermore, extension is polymorphic in Xb,
which means that it is insensitive to the presence or absence of the ﬁeld ℓb
in its argument. The subterm pre X′
b in its result type reﬂects the fact that

10.8
Rows
463
ℓb is deﬁned in the extended record. Conversely, the subterm pre Xb in the
type of the access operation reﬂects the requirement that ℓb be deﬁned in its
argument.
Our encoding of arbitrary records in terms of full records was carried out
for pedagogical purposes. In practice, no such encoding is necessary: the data
constructors pre and abs have no machine representation, and the compiler
is free to lay out records in memory in an eﬃcient manner. The encoding
is interesting, however, because it provides a natural way of introducing the
type constructors pre and abs, which play an important role in our treatment
of polymorphic record operations.
Once we forget about the encoding, the arguments of the type constructor
Π are expected to be either type variables or formed with pre or abs, while,
conversely, the type constructors pre and abs are not intended to appear
anywhere else. It is possible to enforce this invariant using kinds. In addition
to ⋆, let us introduce the kind ◦of ﬁeld types. Then, let us adopt the following
signatures: pre: ⋆⇒◦, abs : ◦, and Π : ◦⊗◦⊗◦⇒⋆.
10.8.1
Exercise [Recommended, «, 3]: Check that the three type schemes given
above are well-kinded. What is the kind of each type variable?
2
10.8.2
Exercise [Recommended, ««]: Our Π types contain information about every
ﬁeld, regardless of whether it is deﬁned: we encode deﬁnedness informa-
tion within the type of each ﬁeld, using the type constructors pre and abs.
A perhaps more natural approach would be to introduce a family of record
type constructors, indexed by the subsets of L, so that the types of records
with diﬀerent domains are formed with diﬀerent constructors. For instance,
the empty record would have type {}; a record that deﬁnes the ﬁeld ℓa only
would have a type of the form {ℓa : Ta}; a record that deﬁnes the ﬁelds
ℓb and ℓc only would have a type of the form {ℓb : Tb; ℓc : Tc}; and so on.
Assuming that the type discipline is Damas and Milner’s (that is, assuming
an equality-only syntactic model), would it be possible to assign satisfactory
type schemes to polymorphic record access and extension? Would it help to
equip record types with a nontrivial subtyping relation?
2
Records with Inﬁnite Carrier
The treatment of records described above is not quite satisfactory, from prac-
tical and theoretical points of view. First, in practice, the set L of all record
labels that appear within a program could be very large. Because every record
type is just as large as L itself, even if the record that it describes only has a
few ﬁelds, this is unpleasant. Furthermore, in a modular setting, the set of all
record labels that appear within a program cannot be determined until link

464
10
The Essence of ML Type Inference
time, so it is still unknown at compile time, when each compilation unit is
separately typechecked. As a result, it may only be assumed to be a subset of
the inﬁnite set of all syntactically valid record labels. Resolving these issues
requires coming up with a treatment of records that does not become more
costly as L grows and that, in fact, allows L to be inﬁnite. Thus, from here
on, let us assume that L is inﬁnite.
As in the previous section, we ﬁrst concentrate on full records, whose do-
main is exactly L. The case of arbitrary records, whose domain is a subset of
L, will then follow in the same manner, by using the type constructors pre
and abs to encode domain information.
Of course, even though we have assumed that L is inﬁnite, we must ensure
that every record has a ﬁnite representation. We choose to restrict our atten-
tion to records that are almost constant, that is, records where all ﬁelds but
a ﬁnite number contain the same value. Every such record may be deﬁned in
terms of two primitive operations, namely (i) creation of a constant record
out of a value; for instance, {false} is the record where every ﬁeld contains
the value false; and (ii) update of a record at a particular ﬁeld; for instance,
{{false} with ℓ= 1} carries the value 1 at ﬁeld ℓand the value false at
every other ﬁeld. As usual, an access operation allows retrieving the contents
of a ﬁeld. Thus, the three primitive operations are the same as in the previous
subsection, only in the setting of an inﬁnite number of ﬁelds.
If we were to continue as before, we would now introduce a type construc-
tor Π, equipped with an inﬁnite family of type parameters. Because types
must remain ﬁnite objects, we cannot do so. Instead, we must ﬁnd a ﬁnite
(and economical) representation of such an inﬁnite family of types. This is
precisely the role played by rows.
A row is a type that denotes a function from labels to types or, equiva-
lently, a family of types indexed by labels. Its domain is L—the row is then
complete—or a coﬁnite subset of L—the row is then incomplete. (A subset of
L is coﬁnite if and only if its complement is ﬁnite. Incomplete rows are used
only as building blocks for complete rows.) Because rows must admit a ﬁnite
representation, we build them out of two syntactic constructions, namely (i)
construction of a constant row out of a type; for instance, the notation ∂bool
denotes a row that maps every label in its domain to bool; and (ii) strict ex-
tension of an incomplete row; for instance, (ℓ: int ; ∂bool) denotes a row
that maps ℓto int and every other ﬁeld in its domain to bool. Formally, ∂is
a unary type constructor, while, for every label ℓ, (ℓ: · ; ·) is a binary type
constructor. These two constructions are reminiscent of the two operations
used above to build records. There are, however, a couple of subtle but im-
portant diﬀerences. First, ∂T may be a complete or incomplete row. Second,
(ℓ: T ; T′) is deﬁned only if ℓis not in the domain of the row T′, so this

10.8
Rows
465
construction is strict extension, not update. These aspects are made clear by
a kinding discipline, to be introduced later on.
It is possible for two syntactically distinct rows to denote the same func-
tion from labels to types. For instance, according to the intuitive interpreta-
tion of rows given above, the three complete rows (ℓ: int ; ∂bool), (ℓ: int ;
(ℓ′ : bool ; ∂bool)), and (ℓ′ :bool ; (ℓ: int ; ∂bool)) denote the same total func-
tion from labels to types. In the following, we deﬁne the logical interpretation
of types in such a way that the interpretations of these three rows in the
model are indeed equal.
We may now make the record type constructor Π a unary type constructor,
whose parameter is a row. Then, (say) Π (ℓ: int ; ∂bool) is a record type, and
we intend it to be a valid type for the record {{false} with ℓ= 1}. The basic
operations on records may be assigned the following type schemes:
{·} :
∀X.X →Π (∂X)
{· with ℓ= ·} :
∀XX′Y.Π (ℓ: X ; Y) →X′ →Π (ℓ: X′ ; Y)
·.{ℓ} :
∀XY.Π (ℓ: X ; Y) →X
These type schemes are reminiscent of those given above. However, in the
previous section, the size of the type schemes was linear in the cardinal of L,
whereas here it is constant, even though L is inﬁnite. This is made possible
by the fact that record types no longer list all labels in existence; instead, they
use rows. In the type scheme assigned to record creation, the constant row
∂X is used to indicate that all ﬁelds have the same type in the newly created
record. In the next two type schemes, the row (ℓ: Xℓ; X) is used to separate
the type Xℓ, which describes the contents of the ﬁeld ℓ, and the row X, which
collectively describes the contents of all other ﬁelds. Here, the type variable X
stands for an arbitrary row; it is often referred to as a row variable. The ability
of quantifying over row and type variables alike confers great expressiveness
to the type system.
We have explained, in an informal manner, how rows allow typechecking
operations on full records, in the setting of an inﬁnite set of labels. We return
to this issue in Example 10.8.25. To deal with the case of arbitrary records,
whose domain is ﬁnite, we rely on the ﬁeld type constructors pre and abs, as
explained previously. We return to this point in Example 10.8.30. In the fol-
lowing, we give a formal exposition of rows. We begin with their syntax and
logical interpretation. Then we give some new constraint equivalence laws,
which characterize rows, and allow extending our ﬁrst-order uniﬁcation al-
gorithm with support for rows. We conclude with several illustrations of the
use of rows and some pointers to related work.

466
10
The Essence of ML Type Inference
Syntax of Rows
In the following, the set of labels L is considered denumerable. We let L range
over ﬁnite subsets of L. When ℓ∉L holds, we write ℓ.L for {ℓ} ⊎L. Before
explaining how the syntax of types is enriched with rows, we introduce row
kinds, whose grammar is as follows:
s ::= Type | Row(L)
Row kinds help distinguish between three kinds of types, namely ordinary
types, complete rows, and incomplete rows. While ordinary types are used to
describe expressions, complete or incomplete rows are used only as building
blocks for ordinary types. For instance, the record type Π (ℓ: int ; ∂bool),
which was informally introduced above, is intended to be an ordinary type,
that is, a type of row kind Type. Its subterm (ℓ:int ; ∂bool) is a complete row,
that is, a type of row kind Row(). Its subterm ∂bool is an incomplete row,
whose row kind is Row({ℓ}). Intuitively, a row of kind Row(L) denotes a fam-
ily of types whose domain is L\L. In other words, L is the set of labels that the
row does not deﬁne. The purpose of row kinds is to outlaw meaningless types,
such as Π (int), which makes no sense because the argument to the record
type constructor Π should be a (complete) row, or (ℓ:T1 ; ℓ: T2 ; ∂bool), which
makes no sense because no label may occur twice within a row.
Let us now deﬁne the syntax of types in the presence of rows. As usual, it
is given by a signature S (Deﬁnition 10.1.14), which lists all type constructors
together with their signatures. Here, for the sake of generality, we do not wish
to give a ﬁxed signature S. Instead, we give a procedure that builds S out of
two simpler signatures, referred to as S0 and S1. The input signature S0 lists
the type constructors that have nothing to do with rows, such as →, ×, int,
etc. The input signature S1 lists the type constructors that allow a row to be a
subterm of an ordinary type, such as the record type constructor Π. In a type
system equipped with extensible variant types or with object types, there
might be several such type constructors; see the sections on Polymorphic
Variants (p. 483) and Other Applications of Rows (p. 486). Without loss of
generality, we assume that all type constructors in S1 are unary. The point of
parameterizing the deﬁnition of S over S0 and S1 is to make the construction
more general: instead of deﬁning a ﬁxed type grammar featuring rows, we
wish to explain how to enrich an arbitrary type grammar with rows.
In the following, we let G (respectively H) range over the type constructors
in S0 (respectively S1). We let κ range over the kinds involved in the deﬁni-
tion of S0 and S1, and refer to them as basic kinds. We let F range over the
type constructors in S. The kinds involved in the deﬁnition of S are com-
posite kinds, that is, pairs of a basic kind κ and a row kind s, written κ.s.

10.8
Rows
467
This allows the kind discipline enforced by S to reﬂect that enforced by S0
and S1 and also to impose restrictions on the structure and use of rows,
as suggested above. For the sake of conciseness, we write K.s for the map-
ping (d , K(d).s)d∈dom(K) and (K ⇒κ).s for the (composite) kind signature
K.s ⇒κ.s. (In other words, we let .s distribute over basic signatures.) We use
symmetric notations to build a composite kind signature out of a basic kind
and a row kind signature.
10.8.3
Definition: The signature S is deﬁned as follows:
F ∈dom(S)
Signature
Conditions
Gs
(K ⇒κ).s
(G : K ⇒κ) ∈S0
H
K.Row() ⇒κ.Type
(H : K ⇒κ) ∈S1
∂κ,L
κ.(Type ⇒Row(L))
ℓκ,L
κ.(Type ⊗Row(ℓ.L) ⇒Row(L))
ℓ∉L
We sometimes refer to S as the row extension of S0 with S1.
2
Examples 10.8.7 and 10.8.8 suggest common choices of S0 and S1 and give a
perhaps more concrete-looking deﬁnition of the grammar of types that they
determine. First, however, let us explain the deﬁnition. The type constructors
that populate S come in four varieties: they may be (i) taken from S0, (ii)
taken from S1, (iii) a unary row constructor ∂, or (iv) a binary row constructor
(ℓ: · ; ·). Let us review and explain each case.
Let us ﬁrst consider case (i) and assume, for the time being, that s is Type.
Then, for every type constructor G in S0, there is a corresponding type con-
structor GType in S. For instance, S0 must contain an arrow type constructor
→, whose signature is {domain , ⋆, codomain , ⋆} ⇒⋆. Then, S contains
a type constructor →Type, whose signature is {domain , ⋆.Type, codomain ,
⋆.Type} ⇒⋆.Type. Thus, →Type is a binary type constructor whose parame-
ters and result must have basic kind ⋆and must have row kind Type; in other
words, they must be ordinary types, as opposed to complete or incomplete
rows. The family of all type constructors of the form GType, where G ranges
over S0, forms a copy of S0 at row kind Type: one might say, roughly speak-
ing, that S contains S0. This is not surprising, since our purpose is to enrich
the existing signature S0 with syntax for rows.
Perhaps more surprising is the existence of the type constructor Gs, for
every G in S0, and for every row kind s. For instance, for every L, S contains a
type constructor →Row(L), whose signature is {domain , ⋆.Row(L), codomain
, ⋆.Row(L)} ⇒⋆.Row(L). Thus, →Row(L) is a binary type constructor whose
parameters and result must have basic kind ⋆and must have row kind Row(L).
In other words, this type constructor maps a pair of rows that have a common
domain to a row with the same domain. Recall that a row is to be interpreted

468
10
The Essence of ML Type Inference
as a family of types. Our intention is that →Row(L) maps two families of types
to a family of arrow types. This is made precise in the next subsection. One
should point out that the type constructors Gs, with s ̸= Type, are required
only in some advanced applications of rows; Examples 10.8.28 and 10.8.39
provide illustrations. They are not used when assigning types to the usual
primitive operations on records, namely creation, update, and access (Exam-
ples 10.8.25 and 10.8.30).
Case (ii) is simple: it simply means that S contains S1. It is only worth
noting that every type constructor H maps a parameter of row kind Row()
to a result of row kind Type, that is, a complete row to an ordinary type.
Thanks to this design choice, the type Π (intType) is invalid: indeed, intType
has row kind Type, while Π expects a parameter of row kind Row().
Cases (iii) and (iv) introduce new type constructors that were not present
in S0 or S1 and allow forming rows. They were informally described in the
previous subsection. First, for every κ and L, there is a constant row construc-
tor ∂κ,L. Its parameter must have row kind Type, while its result has row kind
Row(L); in other words, this type constructor maps an ordinary type to a row.
It is worth noting that the row thus built may be complete or incomplete; for
instance, ∂⋆, bool is a complete row, and may be used, for example, to build
the type Π (∂⋆, bool), while ∂⋆,{ℓ} bool is an incomplete row, and may be
used, for example, to build the type Π (ℓ: int ; ∂⋆,{ℓ} bool). Second, for every
κ, L, and ℓ∉L, there is a row extension constructor ℓκ,L. We usually write
ℓκ,L : T1 ; T2 for ℓκ,L T1 T2 and let this symbol be right associative so as to
recover the familiar list notation for rows. According to the deﬁnition of S,
if T2 has row kind Row(ℓ.L), then ℓκ,L : T1 ; T2 has row kind Row(L). Thanks
to this design choice, the type (ℓ⋆,L : T1 ; ℓ⋆,L : T2 ; ∂⋆,ℓ.L bool) is invalid; in-
deed, the outer ℓexpects a parameter of row kind Row(ℓ.L), while the inner
ℓproduces a type of row kind Row(L).
The superscripts carried by the type constructors G, ℓ, and ∂in the signa-
ture S make all kind information explicit, obviating the need for assigning
several kinds to a single type constructor. In practice, however, we often
drop the superscripts and use unannotated types. No ambiguity arises be-
cause, given a type expression T of known kind, it is possible to reconstruct
all superscripts in a unique manner. This is the topic of the next example and
exercises.
10.8.4
Example [Ill-kinded types]: Assume that S0 contains type constructors int
and →, whose signatures are respectively ⋆and ⋆⊗⋆⇒⋆, and that S1
contains a type constructor Π, whose signature is ⋆⇒⋆.
The unannotated type X →Π(X) is invalid. Indeed, because Π’s image row
kind is Type, the arrow must be →Type. Thus, the leftmost occurrence of X

10.8
Rows
469
must have row kind Type. On the other hand, because Π expects a parameter
of row kind Row(), its rightmost occurrence must have row kind Row()—a
contradiction. The unannotated type X →Π(∂X) is, however, valid, provided
X has kind ⋆.Type. In fact, it is the type of the primitive record creation oper-
ation.
The unannotated type (ℓ: T ; ℓ: T ; T′′) is also invalid: there is no way
of reconstructing the missing superscripts so as to make it valid. Indeed,
the row (ℓ: T′ ; T′′) must have row kind Row(L) for some L that does not
contain ℓ. However, the context where it occurs requires it to also have row
kind Row(L) for some L that does contain ℓ. This makes it impossible to
reconstruct consistent superscripts.
Any type of the form Π(Π(T)) is invalid, because the outer Π expects a pa-
rameter of row kind Row(), while the inner Π constructs a type of row kind
Type. This is an intentional limitation: unlike those of S0, the type construc-
tors of S1 are not lifted to every row kind s. (If they were, we would be led to
work not only with rows of ordinary types, but also with rows of rows, rows
of rows of rows, and so on. Rémy (1990) explores this avenue.)
2
10.8.5
Exercise [Recommended, «]: Consider the unannotated type
X →Π(ℓ: int ; (Y →∂X)).
Can you guess the kind of the type variables X and Y, as well as the missing
superscripts, so as to ensure that this type has kind ⋆.Type?
2
10.8.6
Exercise [«««, 3]: Propose a kind checking algorithm that, given an unan-
notated type T, given the kind of T, and given the kind of all type variables that
appear within T, ensures that T is well-kinded, and reconstructs the missing
superscripts within T. Next, propose a kind inference algorithm that, given an
unannotated type T, discovers the kind of T and the kind of all type variables
that appear within T so as to ensure that T is well-kinded.
2
We have given a very general deﬁnition of the syntax of types. In this view,
types, ranged over by the meta-variable T, encompass both “ordinary” types
and rows: the distinction between the two is established only via the kind
system. In the literature, however, it is common to establish this distinction
by letting distinct meta-variables, say T and R, range over ordinary types and
rows, respectively, so as to give the syntax a more concrete aspect. The next
two examples illustrate this style and suggest common choices for S0 and S1.
10.8.7
Example: Assume that there is a single basic kind ⋆, that S0 consists of the
arrow type constructor →, whose signature is ⋆⊗⋆⇒⋆, and that S1 consists

470
10
The Essence of ML Type Inference
of the record type constructor Π, whose signature is ⋆⇒⋆. Then, the com-
posite kinds are ⋆.Type and ⋆.Row(L), where L ranges over the ﬁnite subsets
of L. Let us employ T (respectively R) to range over types of the former (re-
spectively latter) kind, and refer to them as ordinary types (respectively rows).
Then, the syntax of types, as deﬁned by the signature S, may be presented
under the following form:
T
::=
X | T →T | Π R
R
::=
X | R →R | (ℓ: T ; R) | ∂T
Ordinary types T include ordinary type variables (that is, type variables of
kind ⋆.Type), arrow types (where the type constructor →is really →Type), and
record types, which are formed by applying the record type constructor Π to
a row. Rows R include row variables (that is, type variables of kind ⋆.Row(L)
for some L), arrow rows (where the row constructor →is really →Row(L) for
some L), row extension (whereby a row R is extended with an ordinary type T
at a certain label ℓ), and constant rows (formed out of an ordinary type T). It
would be possible to also introduce a syntactic distinction between ordinary
type variables and row variables, if desired.
Such a presentation is rather pleasant, because the syntactic segregation
between ordinary types and rows makes the syntax less ambiguous. It does
not allow getting rid of the kind system, however: (row) kinds are still neces-
sary to keep track of the domain of every row.
2
10.8.8
Example: Assume that there are two basic kinds ⋆and ◦, that S0 consists
of the type constructors →, abs, and pre, whose respective signatures are
⋆⊗⋆⇒⋆, ◦, and ⋆⇒◦, and that S1 consists of the record type constructor Π,
whose signature is ◦⇒⋆. Then, the composite kinds are ⋆.Type, ⋆.Row(L),
◦.Type, and ◦.Row(L), where L ranges over the ﬁnite subsets of L. Let us em-
ploy T⋆, R⋆, T◦, and R◦, respectively, to range over types of these four kinds.
Then, the syntax of types, as deﬁned by the signature S, may be presented
under the following form:
T⋆
::=
X | T⋆→T⋆| Π R◦
R⋆
::=
X | R⋆→R⋆| (ℓ: T⋆; R⋆) | ∂T⋆
T◦
::=
X | abs | pre T⋆
R◦
::=
X | abs | pre R⋆| (ℓ: T◦; R◦) | ∂T◦
Ordinary types T⋆are as in the previous example, except the record type
constructor Π must now be applied to a row of ﬁeld types R◦. Rows R⋆are
unchanged. Field types T◦include ﬁeld type variables (that is, type variables
of kind ◦.Type) and applications of the type constructors abs and pre (which
are really absType and preType). Field rows R◦include ﬁeld row variables (that

10.8
Rows
471
is, type variables of kind ◦.Row(L) for some L), applications of the row con-
structors abs and pre (which are really absRow(L) and preRow(L) for some L),
row extension, and constant rows, where row components are ﬁeld types T◦.
In many basic applications of rows, absRow(L) and preRow(L) are never re-
quired: that is, they do not appear in the type schemes that populate the
initial environment. (Applications where they are required appear in Pot-
tier [2000].) In that case, they may be removed from the syntax. Then, the
nonterminal R⋆becomes unreachable from the nonterminal T⋆, which is the
grammar’s natural entry point, so it may be removed as well. In that simpli-
ﬁed setting, the syntax of types and rows becomes:
T⋆
::=
X | T⋆→T⋆| Π R◦
T◦
::=
X | abs | pre T⋆
R◦
::=
X | (ℓ: T◦; R◦) | ∂T◦
This is the syntax found in some introductory accounts of rows (Rémy, 1989;
Pottier, 2000).
2
Meaning of Rows
We now give meaning to the type grammar deﬁned in the previous section
by interpreting it within a model. We choose to deﬁne a regular tree model,
but alternatives exist; see Remark 10.8.12 below. In this model, every type
constructor whose image row kind is Type (that is, every type constructor of
the form GType or H) is interpreted as itself, as in a free tree model. However,
every application of a type constructor whose image row kind is Row(L) for
some L receives special treatment: it is interpreted as a family of types in-
dexed by L \ L, which we encode as an inﬁnitely branching tree. To serve as
the root label of this tree, we introduce, for every κ and for every L, a symbol
Lκ, whose arity is L \ L. More precisely,
10.8.9
Definition: The model, which consists of a set Mκ.s for every κ and s, is the
regular tree algebra that arises out the following signature:
Symbol
Signature
Conditions
G
(K ⇒κ).Type
(G : K ⇒κ) ∈S0
H
K.Row() ⇒κ.Type
(H : K ⇒κ) ∈S1
Lκ
κ.(TypeL\L ⇒Row(L))
The ﬁrst two lines in this signature coincide with the deﬁnitions of GType
and H in the signature S. Indeed, as stated above, we intend to interpret

472
10
The Essence of ML Type Inference
these type constructors in a syntactic manner, so each of them must have a
counterpart in the model. The third line introduces the symbols Lκ hinted at
above.
According to this signature, if t is a ground type of kind κ.Type (that is, an
element of Mκ.Type), then its head symbol t(ϵ) must be of the form G or H.
If t is a ground type of kind κ.Row(L), then its head symbol must be Lκ, and
its immediate subtrees, which are indexed by L \ L, are ground types of kind
κ.Type; in other words, the ground row t is eﬀectively a family of ordinary
ground types indexed by L \ L. Thus, our intuition that rows denote inﬁnite
families of types is made literally true.
We have deﬁned the model; there remains to explain how types are mapped
to elements of the model.
10.8.10
Definition: The interpretation of the type constructors that populate S is
deﬁned as follows.
1. Let (G : K ⇒κ) ∈S0. Then, GType is interpreted as the function that maps
T ∈MK.Type to the ground type t ∈Mκ.Type deﬁned by t(ϵ) = G and
t/d = T(d) for every d ∈dom(K). This is a syntactic interpretation.
2. Let (H : K ⇒κ) ∈S1. Then, H is interpreted as the function that maps
T ∈MK.Row() to the ground type t ∈Mκ.Type deﬁned by t(ϵ) = H and
t/d = T(d) for every d ∈dom(K). (Because H is unary, there is exactly
one such d.) This is also a syntactic interpretation.
3. Let (G : K ⇒κ) ∈S0. Then, GRow(L) is interpreted as the function that
maps T ∈MK.Row(L) to the ground type t ∈Mκ.Row(L) deﬁned by t(ϵ) =
Lκ and t(ℓ) = G and t/(ℓ· d) = T(d)/ℓfor every ℓ∈L \ L and d ∈
dom(K). Thus, when applied to a family of rows, the type constructor
GRow(L) produces a row where every component has head symbol G. This
deﬁnition may sound quite technical; its eﬀect is summed up in a simpler
fashion by the equations C-Row-GD and C-Row-GL in the next section.
4. Interpret ∂κ,L as the function that maps t1 ∈Mκ.Type to the ground type
t ∈Mκ.Row(L) deﬁned by t(ϵ) = Lκ and t/ℓ= t1 for every ℓ∈L \ L. Note
that t/ℓdoes not depend on ℓ: t is a constant ground row.
5. Let ℓ∉L. Then, ℓκ,L is interpreted as the function that maps (t1, t2) ∈
Mκ.Type ×Mκ.Row(ℓ.L) to the ground type t ∈Mκ.Row(L) deﬁned by t(ϵ) = Lκ
and t/ℓ= t1 and t/ℓ′ = t2(ℓ′) for every ℓ′ ∈L \ ℓ.L. This deﬁnition
is precisely row extension; indeed, the ground row t maps ℓto t1 and
coincides with the ground row t2 at every other label ℓ′.
2

10.8
Rows
473
Deﬁning a model and an interpretation allows our presentation of rows to ﬁt
within the formalism proposed earlier in this chapter (§10.2). It also provides
a basis for the intuition that rows denote inﬁnite families of types. From a
formal point of view, the model and its interpretation allow proving several
constraint equivalence laws concerning rows, which are given and discussed
in the next subsection. Of course, it is also possible to accept these equiv-
alence laws as axioms and give a purely syntactic account of rows without
relying on a model; this is how rows were historically dealt with (Rémy, 1993).
10.8.11
Remark: We have not deﬁned the interpretation of the subtyping predicate,
because much of the material that follows is independent of it. One common
approach is to adopt a nonstructural deﬁnition of subtyping (Example 10.2.9),
where every Lκ is considered covariant in every direction, and where the vari-
ances and relative ordering of all other symbols (G and H) are chosen at will,
subject to the restrictions associated with nonstructural subtyping and to the
conditions necessary to ensure type soundness.
Recall that the arrow type constructor →is contravariant in its domain and
covariant in its codomain. The record type constructor Π is usually covariant.
These properties are exploited in proofs of the subject reduction theorem.
The type constructors →and Π are usually incompatible. This property is
exploited in proofs of the progress theorem. In the case of Example 10.8.7,
because no type constructors other than →and Π are present, these condi-
tions imply that there is no sensible way of interpreting subtyping other than
equality. In the case of Example 10.8.8, two sensible interpretations of sub-
typing exist: one is equality, while the other is the nonstructural subtyping
order obtained by letting pre à abs. In the former interpretation, abs means
“deﬁnitely absent,” while in the latter, it means “possibly absent.”
2
10.8.12
Remark: The model proposed above is a regular tree model. Of course, it
is possible to adopt a ﬁnite tree model instead. Furthermore, other interpre-
tations of rows are possible: for instance, Fähndrich (1999) extends the set
constraints formalism with rows. In his model, an ordinary type is interpreted
as a set of values, while a row is interpreted as a set of functions from labels
to values. While the deﬁnition of the model may vary, the key point is that
the characteristic laws of rows, which we discuss next, hold in the model.
2
Reasoning with Rows
The interpretation presented in the previous section was designed to support
the intuition that a row denotes an inﬁnite family of types, indexed by labels,
that the row constructor ℓ: · ; · denotes row extension, and that the row
constructor ∂denotes the creation of a constant row. From a formal point of

474
10
The Essence of ML Type Inference
(ℓ1 : T1 ; ℓ2 : T2 ; T3) = (ℓ2 : T2 ; ℓ1 : T1 ; T3)
(C-Row-LL)
∂T = (ℓ: T ; ∂T)
(C-Row-DL)
G ∂T1 . . . ∂Tn = ∂(G T1 . . . Tn)
(C-Row-GD)
G (ℓ: T1 ; T′
1) . . . (ℓ: Tn ; T′
n) = (ℓ: G T1 . . . Tn ; G T′
1 . . . T′
n)
(C-Row-GL)
Figure 10-12: Equational reasoning with rows
view, the deﬁnition of the model and interpretation may be exploited to es-
tablish some reasoning principles concerning rows. These principles take the
form of equations between types (Figure 10-12) and constraint equivalence
laws (Figure 10-13), which we now explain and prove.
10.8.13
Remark: As stated earlier, we omit the superscripts of row constructors. We
also omit the side conditions that concern the kind of the type variables (X)
and type meta-variables (T) involved. Thus, each equation in Figure 10-12
really stands for the (inﬁnite) family of equations obtained by reconstructing
the missing kind information in a consistent way. For instance, the second
equation may be read ∂ℓ.LT = (ℓκ,L : T ; ∂LT), where ℓ∉L and T has kind
κ.Type.
2
10.8.14
Exercise [Recommended, «, 3]: Reconstruct all of the missing kind infor-
mation in the equations of Figure 10-12.
2
10.8.15
Remark: There is a slight catch with the unannotated version of the second
equation in Figure 10-12: its left-hand side admits strictly more kinds than its
right-hand side, because the former has row kind Row(L) for every L, while
the latter has row kind Row(L) for every L such that ℓ∉L holds. As a result,
while replacing the unannotated term (ℓ: T ; ∂T) with ∂T is always valid, the
converse is not: replacing the unannotated term ∂T with (ℓ: T ; ∂T) is valid
only if it does not result in an ill-kinded term.
2
The ﬁrst equation in Figure 10-12 states that rows are equal up to commu-
tation of labels. For the equation to be well-kinded, the labels ℓ1 and ℓ2 must
be distinct. The equation holds under our interpretation because extension
of a ground row at ℓ1 and extension of a ground row at ℓ2 commute. The
second equation states that ∂T maps every label within its domain to T, that
is, ∂LT maps every label ℓ̸∈L to T. This equation holds because ∂T is inter-
preted as a constant row. The last two equations deal with the relationship
between the row constructors G and the ordinary type constructor G. Indeed,
notice that their left-hand sides involve GRow(L) for some L, while their right-
hand sides involve GType. Both equations state that it is equivalent to apply

10.8
Rows
475
(ℓ1 : T1 ; T′
1) = (ℓ2 : T2 ; T′
2)
≡
∃X.(T′
1 = (ℓ2 : T2 ; X) ∧T′
2 = (ℓ1 : T1 ; X))
(C-Mutate-LL)
if X # ftv(T1, T′
1, T2, T′
2) ∧ℓ1 ̸= ℓ2
∂T = (ℓ: T′ ; T′′)
≡
T = T′ ∧∂T = T′′
(C-Mutate-DL)
G T1 . . . Tn = ∂T
≡
∃X1 . . . Xn.(G X1 . . . Xn = T ∧
Vn
i=1(Ti = ∂Xi))
(C-Mutate-GD)
if X1 . . . Xn # ftv(T1, . . . , Tn, T)
G T1 . . . Tn = (ℓ: T ; T′)
≡
∃X1 . . . Xn, X′
1 . . . X′
n.(G X1 . . . Xn = T ∧
G X′
1 . . . X′
n = T′ ∧
Vn
i=1(Ti = (ℓ: Xi ; X′
i)))
if X1 . . . Xn, X′
1 . . . X′
n # ftv(T1, . . . , Tn, T, T′)
(C-Mutate-GL)
Figure 10-13: Constraint equivalence laws involving rows
GRow(L) at the level of rows or to apply GType at the level of types. Our inter-
pretation of GRow(L) was designed to give rise to these equations; indeed, the
application of GRow(L) to n ground rows (where n is the arity of G) is inter-
preted as a pointwise application of GType to the rows’ components (item 3 of
Deﬁnition 10.8.10). Their use is illustrated in Examples 10.8.28 and 10.8.39.
10.8.16
Lemma: Each of the equations in Figure 10-12 is equivalent to true.
2
The four equations in Figure 10-12 show that two types with distinct head
symbols may denote the same element of the model. In other words, in the
presence of rows, the interpretation of types is no longer free: an equation of
the form T1 = T2, where T1 and T2 have distinct head symbols, is not necessar-
ily equivalent to false. In Figure 10-13, we give several constraint equivalence
laws, known as mutation laws, that concern such “heterogeneous” equations,
and, when viewed as rewriting rules, allow solving them. To each equation
in Figure 10-12 corresponds a mutation law. The soundness of the mutation
law, that is, the fact that its right-hand side entails its left-hand side, follows
from the corresponding equation. The completeness of the mutation law, that
is, the fact that its left-hand side entails its right-hand side, holds by design
of the model.
10.8.17
Exercise [Recommended, «, 3]: Reconstruct all of the missing kind infor-
mation in the laws of Figure 10-13.
2
Let us now review the four mutation laws. For the sake of brevity, in the
following informal explanation, we assume that a ground assignment φ that

476
10
The Essence of ML Type Inference
satisﬁes the left-hand equation is ﬁxed, and write “the ground type T” for “the
ground type φ(T).” C-Mutate-LL concerns an equation between two rows,
which are both given by extension but exhibit distinct head labels ℓ1 and ℓ2.
When this equation is satisﬁed, both of its members must denote the same
ground row. Thus, the ground row T′
1 must map ℓ2 to the ground type T2,
while, symmetrically, the ground row T′
2 must map ℓ1 to the ground type
T1. This may be expressed by two equations of the form T′
1 = (ℓ2 : T2 ; . . .)
and T′
2 = (ℓ1 : T1 ; . . .). Furthermore, because the ground rows T′
1 and T′
2
must agree on their common labels, the ellipses in these two equations must
denote the same ground row. This is expressed by letting the two equations
share a fresh, existentially quantiﬁed row variable X. C-Mutate-DL concerns
an equation between two rows, one of which is given as a constant row, the
other of which is given by extension. Then, because the ground row ∂T maps
every label to the ground type T, the ground type T′ must coincide with the
ground type T, while the ground row T′′ must map every label in its domain
to the ground type T. This is expressed by the equations T = T′ and ∂T = T′′.
C-Mutate-GD and C-Mutate-GL concern an equation between two rows, one
of which is given as an application of a row constructor G, the other of which
is given either as a constant row or by extension. Again, the laws exploit
the fact that the ground row G T1 . . . Tn is obtained by applying the type
constructor G, pointwise, to the ground rows T1, . . . , Tn. If, as in C-Mutate-
GD, it coincides with the constant ground row ∂T, then every Ti must itself be
a constant ground row, of the form ∂Xi, and T must coincide with G X1 . . . Xn.
C-Mutate-GL is obtained in a similar manner.
10.8.18
Lemma: Each of the equivalence laws in Figure 10-13 holds.
2
Solving Equality Constraints in the Presence of Rows
We now extend the uniﬁcation algorithm given in §10.6 with support for rows.
The extended algorithm is intended to solve uniﬁcation problems where the
syntax and interpretation of types are as deﬁned in the discussions above of
the syntax (p. 466) and meaning (p. 471) of rows. Its speciﬁcation consists
of the original rewriting rules of Figure 10-10, minus S-Clash, which is re-
moved and replaced with the rules given in Figure 10-14. Indeed, S-Clash is
no longer valid in the presence of rows: not all distinct type constructors are
incompatible.
The extended algorithm features four mutation rules, which are in direct
correspondence with the mutation laws of Figure 10-13, as well as a weak-
ened version of S-Clash, dubbed S-Clash’, which applies when neither S-
Decompose nor the mutation rules are applicable. (Let us point out that, in

10.8
Rows
477
(ℓ1 : X1 ; X′
1) = (ℓ2 : T2 ; T′
2) = ϵ
→
∃X.(X′
1 = (ℓ2 : T2 ; X) ∧T′
2 = (ℓ1 : X1 ; X))
∧(ℓ1 : X1 ; X′
1) = ϵ
(S-Mutate-LL)
if ℓ1 ̸= ℓ2
∂X = (ℓ: T ; T′) = ϵ
→
X = T ∧∂X = T′ ∧∂X = ϵ
(S-Mutate-DL)
G T1 . . . Tn = ∂X = ϵ
→
∃X1 . . . Xn.(G X1 . . . Xn = X ∧
Vn
i=1(Ti = ∂Xi))
∧∂X = ϵ
(S-Mutate-GD)
G T1 . . . Tn = (ℓ: X ; X′) = ϵ
→
∃X1 . . . Xn, X′
1 . . . X′
n.(G X1 . . . Xn = X ∧
G X′
1 . . . X′
n = X′ ∧
Vn
i=1(Ti = (ℓ: Xi ; X′
i)))
∧(ℓ: X ; X′) = ϵ
(S-Mutate-GL)
F ⃗T = F′ ⃗T′ = ϵ
→
false
(S-Clash’)
if F ̸= F′ and none of the four rules above applies
Figure 10-14: Row uniﬁcation (changes to Figure 10-10)
S-Decompose, the meta-variable F ranges over all type constructors in the sig-
nature S, so that S-Decompose is applicable to multi-equations of the form
∂X = ∂T = ϵ or (ℓ: X ; X′) = (ℓ: T ; T′) = ϵ.) Three of the mutation rules
may allocate fresh type variables, which must be chosen fresh for the rule’s
left-hand side. The four mutation rules paraphrase the four mutation laws
very closely. Two minor diﬀerences are (i) the mutation rules deal with multi-
equations, as opposed to equations; and (ii) any subterm that appears more
than once on the right-hand side of a rule is required to be a type variable,
as opposed to an arbitrary type. Neither of these features is speciﬁc to rows:
both may be found in the deﬁnition of the standard uniﬁcation algorithm
(Figure 10-10), where they help reason about sharing.
10.8.19
Exercise [«, 3]: Check that the rewriting rules in Figure 10-14 preserve well-
kindedness. Conclude that, provided its input constraint is well-kinded, the
uniﬁcation algorithm needs not keep track of kinds.
2
The properties of the uniﬁcation algorithm are preserved by this extension,
as witnessed by the next three lemmas. Note that the termination of reduction
is ensured only when the initial uniﬁcation problem is well-kinded. The ill-
kinded uniﬁcation problem X = (ℓ1 : T ; Y) ∧X = (ℓ2 : T ; Y), where ℓ1 and ℓ2
are distinct, illustrates this point.
10.8.20
Lemma: The rewriting system →is strongly normalizing.
2

478
10
The Essence of ML Type Inference
10.8.21
Lemma: U1 →U2 implies U1 ≡U2.
2
10.8.22
Lemma: Every normal form is either false or of the form X[U], where X is an
existential constraint context, U is a standard conjunction of multi-equations
and, if the model is syntactic, U is acyclic. These conditions imply that U is
satisﬁable.
2
The time complexity of standard ﬁrst-order uniﬁcation is quasi-linear. What
is, then, the time complexity of row uniﬁcation? Only a partial answer is
known. In practice, the algorithm given in this chapter is extremely eﬃcient
and appears to behave just as well as standard uniﬁcation. In theory, the com-
plexity of row uniﬁcation remains unexplored and forms an interesting open
issue.
10.8.23
Exercise [«««, 3]: The uniﬁcation algorithm presented above, although very
eﬃcient in practice, does not have linear or quasi-linear time complexity. Find
a family of uniﬁcation problems Un such that the size of Un is linear with re-
spect to n and the number of steps required to reach its normal form is
quadratic with respect to n.
2
10.8.24
Remark: Mutation is a common technique for solving equations in a large
class of non-free algebras that are described by syntactic theories (Kirchner
and Klay, 1990). The equations of Figure 10-12 happen to form a syntactic
presentation of an equational theory. Thus, it is possible to derive a uniﬁca-
tion algorithm out of these equations in a systematic way (Rémy, 1993). Here,
we have presented the same algorithm in a direct manner, without relying on
the apparatus of syntactic theories.
2
Operations on Records
We now illustrate the use of rows for typechecking operations on records. We
begin with full records; our treatment follows Rémy (1992b).
10.8.25
Example [Full records]: As before, let us begin with full records, whose do-
main is exactly L. The primitive operations are record creation {·}, update
{· with ℓ= ·}, and access ·.{ℓ}.
Let < denote a ﬁxed strict total order on row labels. For every set of labels
L of cardinal n, let us introduce a (n + 1)-ary constructor {}L. We use the fol-
lowing syntactic sugar: we write {ℓ1 = t1; . . . ; ℓn = tn; t} for the application
{}L ti1 . . . tin t, where L = {ℓ1, . . . , ℓn} = {ℓi1, . . . , ℓin} and ℓi1 < . . . < ℓin
holds. The use of the total order < makes the meaning of record expressions
independent of the order in which ﬁelds are deﬁned; in particular, it allows
ﬁxing the order in which t1, . . . , tn are evaluated. We abbreviate the record

10.8
Rows
479
value {ℓ1 = v1; . . . ; ℓn = vn; v} as {V; v}, where V is the ﬁnite function that
maps ℓi to vi for every i ∈{1, . . . , n}.
The operational semantics of the above three operations may now be de-
ﬁned in the following straightforward manner. First, record creation {·} is
precisely the unary constructor {}. Second, for every ℓ∈L, let update
{· with ℓ= ·} and access ·.{ℓ} be destructors of arity 1 and 2, respectively,
equipped with the following reduction rules:
{{V; v} with ℓ= v′}
δ-→
{V[ℓ, v′]; v}
(R-Update)
{V; v}.{ℓ}
δ-→
V(ℓ)
(ℓ∈dom(V))
(R-Access-1)
{V; v}.{ℓ}
δ-→
v
(ℓ∉dom(V))
(R-Access-2)
In these rules, V[ℓ, v] stands for the function that maps ℓto v and coincides
with V at every other label, while V(ℓ) stands for the image of ℓthrough V.
Because these rules make use of the syntactic sugar deﬁned above, they are,
strictly speaking, rule schemes: each of them really stands for the inﬁnite
family of rules that would be obtained if the syntactic sugar was eliminated.
Let us now deﬁne the syntax of types as in Example 10.8.7. Let the initial
environment Γ0 contain the following bindings:
{}{ℓ1,...,ℓn} :
∀X1 . . . XnX.X1 →. . . →Xn →X →Π (ℓ1 : X1; . . . ; ℓn : Xn; ∂X)
where ℓ1 < . . . < ℓn
{· with ℓ= ·} :
∀XX′Y.Π (ℓ: X ; Y) →X′ →Π (ℓ: X′ ; Y)
·.{ℓ} :
∀XY.Π (ℓ: X ; Y) →X
Note that, in particular, the type scheme assigned to record creation {·} is
∀X.X →Π (∂X). As a result, these bindings are exactly as stated in the discus-
sion of records with inﬁnite carrier (p. 463).
To illustrate how these deﬁnitions work together, let us consider the pro-
gram {{0} with ℓ1 = true}.{ℓ2}, which builds a record, extends it at ℓ1, then
accesses it at ℓ2. Can we build an HM(X) type derivation for it, under the
constraint true and the initial environment Γ0? To begin, by looking up Γ0
and using hmx-Inst, we ﬁnd that {·} has type int →Π (∂int). Thus, assum-
ing that 0 has type int, the expression {0} has type Π (∂int). Indeed, this
expression denotes a record all of whose ﬁelds hold an integer value. Then,
by looking up Γ0 and using hmx-Inst, we ﬁnd that {· with ℓ1 = ·} has type
Π (ℓ1 : int ; ∂int) →bool →Π (ℓ1 : bool ; ∂int). May we immediately use hmx-
App to typecheck the application of {· with ℓ1 = ·} to {0}? Unfortunately,
no, because there is an apparent mismatch between the expected type Π
(ℓ1:int ; ∂int) and the eﬀective type Π (∂int). To work around this problem, let
us recall that, by C-Row-DL, the equation Π (∂int) = Π (ℓ1 :int ; ∂int) is equiv-
alent to true. Thus, hmx-Sub allows proving that {0} has type Π (ℓ1 :int ; ∂int).

480
10
The Essence of ML Type Inference
Assuming that true has type bool, we may now apply hmx-App and deduce
true, Γ0 ⊢{{0} with ℓ1 = true} : Π (ℓ1 : bool ; ∂int).
We let the reader check that, in a similar manner involving C-Row-DL, C-Row-
LL, and hmx-Sub, one may prove that {{0} with ℓ1 = true}.{ℓ2} has type int,
provided ℓ1 and ℓ2 are distinct.
2
10.8.26
Exercise [««, 3]: Unfold the deﬁnition of the constraint let Γ0 in J{{0} with
ℓ1 = true}.{ℓ2} : XK, which states that X is a valid type for the above program.
Assuming that subtyping is interpreted as equality, simulate a run of the
constraint solver (§10.6), extended with support for rows, so as to solve this
constraint. Check that the solved form is equivalent to X = int.
2
10.8.27
Exercise [«««]: Check that the deﬁnitions of Example 10.8.25 meet the re-
quirements of Deﬁnition 10.5.5.
2
10.8.28
Example [Record application]: Let us now introduce a more unusual prim-
itive operation on full records. This operation accepts two records, the ﬁrst of
which is expected to hold a function in every ﬁeld and produces a new record,
whose contents are obtained by applying, pointwise, the functions in the ﬁrst
record to the values in the second record. In other words, this new primitive
operation lifts the standard application combinator (which may be deﬁned as
λf.λz.f z), pointwise, to the level of records. For this reason, we refer to it as
rapply. Its operational semantics is deﬁned by making it a binary destructor
and equipping it with the following reduction rules:
rapply {V; v} {V′; v′}
δ-→
{V V′; v v′}
(R-Apply-1)
rapply {V; v} {V′; v′}
δ-→
rapply {V; v} {V′[ℓ, v′]; v′}
(R-Apply-2)
if ℓ∈dom(V) \ dom(V′)
rapply {V; v} {V′; v′}
δ-→
rapply {V[ℓ′ , v]; v} {V′; v′}
(R-Apply-3)
if ℓ′ ∈dom(V′) \ dom(V)
In the ﬁrst rule, V V′ is deﬁned only if V and V′ have a common domain; it is
then deﬁned as the function that maps ℓto the expression V(ℓ) V′(ℓ). The
second and third rules, which are symmetric, deal with the case where some
ﬁeld is explicitly deﬁned in one input record but not in the other; in that case,
the ﬁeld is made explicit by creating a copy of the record’s default value.
The syntax of types remains as in Example 10.8.25. We extend the initial
environment Γ0 with the following binding:
rapply :
∀XY.Π (X →Y) →Π X →Π Y

10.8
Rows
481
To understand this type scheme, recall that the principal type scheme of
the standard application combinator (which may be deﬁned as λf.λz.f z) is
∀XY.(X →Y) →X →Y. The type scheme assigned to rapply is very similar; the
most visible diﬀerence is that both arguments, as well as the result, are now
wrapped within the record type constructor Π. A more subtle, yet essential
change is that X and Y are now row variables: their kind is ⋆.Row(). As
a result, the leftmost occurrence of the arrow constructor is really →Row().
Thus, we are exploiting the presence of type constructors of the form Gs,
with s ̸= Type, in the signature S.
To illustrate how these deﬁnitions work together, let us consider the pro-
gram rapply {ℓ= not; succ} {ℓ= true; 0}, where the terms not and succ
are assumed to have types bool →bool and int →int, respectively. Can
we build an HM(X) type derivation for it, under the constraint true and
the initial environment Γ0? To begin, it is straightforward to derive that the
record {ℓ= not; succ} has type Π (ℓ: bool →bool ; ∂(int →int)) (1). In or-
der to use rapply, however, we must prove that this record has a type of
the form Π (R1 →R2), where R1 and R2 are rows. This is where C-Row-GD
and C-Row-GL (Figure 10-12) come into play. Indeed, by C-Row-GD, the type
∂(int →int) may be written ∂int →∂int. So, (1) may be written Π (ℓ: bool →
bool ; ∂int →∂int) (2), which by C-Row-GL may be written Π ((ℓ: bool ;
∂int) →(ℓ: bool ; ∂int)) (3). Thus, hmx-Sub allows deriving that the record
{ℓ= not; succ} has type (3). We let the reader continue and conclude that the
program has type Π (ℓ: bool ; ∂int) under the constraint true and the initial
environment Γ0.
This example illustrates a very important use of rows, namely to lift an
operation on ordinary values so as to turn it into a pointwise operation on
records. Here, we have chosen to lift the standard application combinator,
giving rise to rapply on records. The point is that, thanks to the expres-
sive power of rows, we were also able to lift the standard combinator’s type
scheme in the most straightforward manner, giving rise to a suitable type
scheme for rapply.
2
10.8.29
Exercise [«««, 3]: Check that the deﬁnitions of Example 10.8.28 meet the
requirements of Deﬁnition 10.5.5.
2
The previous examples have illustrated the use of rows to typecheck op-
erations on full records. Let us now move to records with ﬁnite domain. As
explained in the discussion above of records with ﬁnite carrier (p. 461), they
may be either encoded in terms of full records, or given a direct deﬁnition.
The latter approach is illustrated below.
10.8.30
Example [Finite records]: For every set of labels L of cardinal n, let us in-
troduce a n-ary constructor ⟨⟩L. We deﬁne the notations ⟨ℓ1 = t1; . . . ; ℓn = tn⟩

482
10
The Essence of ML Type Inference
and ⟨V⟩, where V is a ﬁnite mapping of labels to values, in a manner similar
to that of Example 10.8.25.
The three primitive operations on ﬁnite records, namely the empty record
⟨⟩, extension ⟨· with ℓ= ·⟩, and access ·.⟨ℓ⟩, may be deﬁned as follows. First,
the empty record ⟨⟩is precisely the nullary constructor ⟨⟩. Second, for every
ℓ∈L, let extension ⟨· with ℓ= ·⟩and access ·.⟨ℓ⟩be destructors of arity 1
and 2, respectively, equipped with the following reduction rules:
⟨⟨V⟩with ℓ= v⟩
δ-→
⟨V[ℓ, v]⟩
(R-Extend)
⟨V⟩.⟨ℓ⟩
δ-→
V(ℓ)
(ℓ∈dom(V))
(R-Access)
Let us now deﬁne the syntax of types as in Example 10.8.8. Let the initial
environment Γ0 contain the following bindings:
⟨⟩{ℓ1,...,ℓn} : ∀X1 . . . Xn.X1 →. . . →Xn →Π (ℓ1 : pre X1; . . . ; ℓn : pre Xn; ∂abs)
where ℓ1 < . . . < ℓn
⟨· with ℓ= ·⟩: ∀XX′Y.Π (ℓ: X ; Y) →X′ →Π (ℓ: pre X′ ; Y)
·.⟨ℓ⟩: ∀XY.Π(ℓ: pre X ; Y) →X
Note that, in particular, the type scheme assigned to the empty record ⟨⟩is
Π (∂abs).
2
10.8.31
Exercise [Recommended, «, 3]: Reconstruct all of the missing kind infor-
mation in the type schemes given in Example 10.8.30.
2
10.8.32
Exercise [Recommended, ««, 3]: Give an encoding of ﬁnite records in terms
of full records, along the lines of the discussion of records with ﬁnite carrier
(p. 461). Check that the principal type schemes associated, via the encod-
ing, with the three operations on ﬁnite records are precisely those given in
Example 10.8.30.
2
10.8.33
Exercise [Recommended, «]: The extension operation, as deﬁned above, may
either change the value of an existing ﬁeld or create a new ﬁeld, depending
on whether the ﬁeld ℓis or isn’t present in the input record. This ﬂavor is
known as free extension. Can you deﬁne a strict ﬂavor of extension that is
not applicable when the ﬁeld ℓalready exists? Can you deﬁne (free and strict
ﬂavors of) a restriction operation that removes a ﬁeld from a record?
2
10.8.34
Exercise [Recommended, «]: Explain why, when pre à abs holds, subsump-
tion allows a record with more ﬁelds to be supplied in a context where a
record with fewer ﬁelds is expected. This phenomenon is often known as
width subtyping. Explain why such is not the case when subtyping is inter-
preted as equality.
2
10.8.35
Exercise [«««, 3]: Check that the deﬁnitions of Example 10.8.30 meet the
requirements of Deﬁnition 10.5.5.
2

10.8
Rows
483
Polymorphic Variants
So far, we have emphasized the use of rows for ﬂexible typechecking of opera-
tions on records. The record type constructor Π expects one parameter, which
is a row; informally speaking, one might say that it is a product constructor of
inﬁnite arity. It appears natural to also deﬁne sums of inﬁnite arity. This may
be done by introducing a new unary type constructor Σ, whose parameter is
a row.
As in the case of records, we use a nullary type constructor abs and a
unary type constructor pre in order to associate information with every row
label. Thus, for instance, the type Σ (ℓ1 :pre T1 ; ℓ2 : pre T2 ; ∂abs) is intended
to contain values of the form ℓ1 v1, where v1 has type T1, or of the form
ℓ2 v2, where v2 has type T2. The type constructors abs and pre are not the
same type constructors as in the case of records. In particular, their subtyping
relationship, if there is one, is reversed. Indeed, the type Σ (ℓ1 : pre T1 ;
ℓ2 : abs ; ∂abs) is intended to contain only values of the form ℓ1 v1, where
v1 has type T1, so it is safe to make it a subtype of the above type; in other
words, it is safe to allow abs ≤pre T2. In spite of this, we keep the names abs
and pre by tradition.
The advantages of this approach over algebraic data types are the same as
in the case of records. The namespace of data constructors becomes global,
so it becomes possible for two distinct sum types to share data constructors.
Also, the expressiveness aﬀorded by rows allows assigning types to new op-
erations, such as ﬁltering (see below), which allows functions that perform
case analysis to be incrementally extended with new cases. One disadvantage
is that it becomes more diﬃcult to understand what it means for a function
deﬁned by pattern matching to be exhaustive; this issue is, however, out of
the scope of this chapter.
10.8.36
Example [Polymorphic variants]: For every label ℓ∈L, let us introduce a
unary constructor ℓand a ternary destructor [ ℓ: · | · ] ·. We refer to the for-
mer as a data constructor, and to the latter as a ﬁlter. Let us also introduce a
unary destructor []. We equip these destructors with the following reduction
rules:
[ ℓ: v | v′ ] (ℓw)
δ-→
v w
(R-Filter-1)
[ ℓ: v | v′ ] (ℓ′ w)
δ-→
v′ (ℓ′ w)
if ℓ̸= ℓ′
(R-Filter-2)
Let us deﬁne the syntax of types as follows. Let there be two basic kinds ⋆
and •. Let S0 consist of the type constructors →, abs, and pre, whose respec-
tive signatures are ⋆⊗⋆⇒⋆, •, and ⋆⇒•. Let S1 consist of the record type
constructor Σ, whose signature is • ⇒⋆. Note the similarity with the case of
records (Example 10.8.8).

484
10
The Essence of ML Type Inference
Subtyping is typically interpreted in one of two ways. One is equality. The
other is the nonstructural subtyping order obtained by letting →be con-
travariant in its domain and covariant in its codomain, Σ be covariant, →
and Σ be incompatible, and letting abs à pre. Compare this deﬁnition with
the case of records (Remark 10.8.11).
To complete the setup, let the initial environment Γ0 contain the following
bindings:
ℓ· :
∀XY.X →Σ (ℓ: pre X ; Y)
[ ℓ: · | · ] · :
∀XX′YY′.(X →Y) →(Σ (ℓ: X′ ; Y′) →Y) →Σ (ℓ: pre X ; Y′) →Y
[] :
∀X.Σ (∂abs) →X
The ﬁrst binding means, in particular, that if v has type T, then a value of the
form ℓv has type Σ (ℓ: pre T ; ∂abs). This is a sum type with only one branch
labeled ℓ, hence a very precise type for this value. However, it is possible to
instantiate the row variable Y with rows other than ∂abs. For instance, the
value ℓv also has type Σ (ℓ: pre T ; ℓ′ : pre T′ ; ∂abs). This is a sum type with
two branches, hence a somewhat less precise type, but still a valid one for
this value. It is clear that, through this mechanism, the value ℓv admits an
inﬁnite number of types. The point is that, if v has type T and v′ has type T′,
then both ℓv and ℓ′ v′ have type Σ (ℓ: pre T ; ℓ′ : pre T′ ; ∂abs), so they may
be stored together in a homogeneous data structure, such as a list.
Filters are used to perform case analysis on variants, that is, on values of
a sum type. According to R-Filter-1 and R-Filter-2, a ﬁlter [ ℓ: v | v′ ] is a
function that expects an argument of the form ℓ′ w and reduces to v w if ℓ′ is
ℓand to v′ (ℓ′ w) otherwise. Thus, a ﬁlter deﬁnes a two-way branch, where the
label of the data constructor at hand determines which branch is taken. The
expressive power of ﬁlters stems from the fact that they may be organized
in a sequence, so as to deﬁne a multi-way branch. The inert ﬁlter [], which
does not have a reduction rule, serves as a terminator for such sequences. For
instance, the composite ﬁlter [ ℓ: v | [ ℓ′ : v′ | [] ] ], which may be abbreviated
as [ ℓ: v | ℓ′ : v′ ], may be applied either to a value of the form ℓw, yielding
v w, or to a value of the form ℓ′ w′, yielding v′ w′. Applying it to a value w
whose head symbol is not ℓor ℓ′ would lead to the term [] w, which is stuck,
since [] does not have a reduction rule.
For the type system to be sound, we must ensure that every application
of the form [] w is ill-typed. This is achieved by the third binding above: the
domain type of [] is Σ (∂abs), a sum type with zero branches, which contains
no values. The return type of [] may be chosen at will, which is ﬁne; since it
can never be invoked, it can never return. The second binding above means
that, if v accepts values of type T and v′ accepts values of type Σ (ℓ: T′′ ; T′),
then the ﬁlter [ ℓ: v | v′ ] accepts values of type Σ (ℓ: pre T ; T′). Note that

10.8
Rows
485
any choice of T′′ will do, including, in particular, abs. In other words, it is
okay if v′ does not accept values of the form ℓw. Indeed, by deﬁnition of the
semantics of ﬁlters, it will never be passed such a value.
2
10.8.37
Exercise [«««, 3]: Check that the deﬁnitions of Example 10.8.36 meet the
requirements of Deﬁnition 10.5.5.
2
10.8.38
Remark: It is interesting to study the similarity between the type schemes
assigned to the primitive operations on polymorphic variants and those as-
signed to the primitive operations on records (Example 10.8.30). The type of
[] involves the complete row ∂abs, just like the empty record ⟨⟩. The type
of [ ℓ: · | · ] · is pretty much identical to the type of record extension
⟨· with ℓ= ·⟩, provided the three continuation arrows →Y are dropped.
Last, the type of the data constructor ℓis strongly reminiscent of the type
of record access ·.⟨ℓ⟩. With some thought, this is hardly a surprise. Indeed,
records and variants are dual: it is possible to encode the latter in terms of
the former and vice-versa. For instance, in the encoding of variants in terms
of records, a function deﬁned by cases is encoded as a record of ordinary
functions, in continuation-passing style. Thus, the encoding of [] is λf.f ⟨⟩,
the encoding of [ ℓ: v | v′ ] is λf.f ⟨v′ with ℓ= v⟩, and the encoding of
ℓv is λr.r.⟨ℓ⟩v. The reader is encouraged to study the type schemes that
arise out of this encoding and how they relate to the type schemes given in
Example 10.8.36.
2
10.8.39
Example [First-class messages]: In a programming language equipped with
both records and variants, it is possible to make the duality between these
two forms of data explicit by extending the language with a primitive opera-
tion # that turns a record of ordinary functions into a single function, deﬁned
by cases. More precisely, # may be introduced as a binary destructor, whose
reduction rule is
# v (ℓw)
δ-→
v.⟨ℓ⟩w
(R-Send)
What type may we assign to such an operation? In order to simplify the an-
swer, let us assume that we are dealing with full records (Example 10.8.25)
and full variants; that is, we have a single basic kind ⋆, and do not employ
abs and pre. Then, a suitable type scheme would be
∀XY.Π (X →∂Y) →Σ X →Y
In other words, this operation accepts a record of functions, all of which have
the same return type Y, but may have arbitrary domain types, which are given
by the row X. It produces a function that accepts a parameter of sum type Σ X

486
10
The Essence of ML Type Inference
and returns a result of type Y. The fact that the row X appears both in the Σ
type and in the Π type reﬂects the operational semantics. Indeed, according
to R-Send, the label ℓcarried by the value ℓw is used to extract, out of the
record v, a function, which is then applied to w. Thus, the domain type of
the function stored at ℓwithin the record v should match the type of w. In
other words, at every label, the domain of the contents of the record and the
contents of the sum should be type compatible. This is encoded by letting
a single row variable X stand for both of these rows. Note that the arrow in
X →∂Y is really →Row(); once again, we are exploiting the presence of type
constructors of the form Gs, with s ̸= Type, in the signature S.
If the record of functions v is viewed as an object, and if the variant ℓw
is viewed as a message ℓcarrying a parameter w, then R-Send may be under-
stood as (ﬁrst-class) message dispatch, a common feature of object-oriented
languages. (The ﬁrst-class qualiﬁer refers to the fact that the message name
ℓis not statically ﬁxed, but is discovered at runtime.) The issue of type infer-
ence in the presence of such a feature has been studied by Nishimura (1998),
Müller and Nishimura (1998), and Pottier (2000). These papers address two is-
sues that are not dealt with in the above example, namely (i) accommodating
ﬁnite (as opposed to full) record and variants and (ii) allowing distinct meth-
ods to have distinct result types. This is achieved via the use of subtyping
and of some form of conditional constraints.
2
10.8.40
Exercise [«««, 3]: Check that the deﬁnitions of Example 10.8.39 meet the
requirements of Deﬁnition 10.5.5.
2
The name polymorphic variants stems from the highly polymorphic type
schemes assigned to the operations on variants (Example 10.8.36). A row-
based type system for polymorphic variants was ﬁrst proposed by Rémy
(1989). A somewhat similar, constraint-based type system for polymorphic
variants was then studied by Garrigue (1998; 2000; 2002) and implemented
by him as part of the programming language Objective Caml.
Other Applications of Rows
Typechecking records and variants is the best-known application of rows.
Many variations of it are conceivable, some of which we have illustrated, such
as the choice between full and ﬁnite records and variants. However, rows may
also be put to other uses, of which we now list a few.
First, since objects may be viewed as records of functions, at least from a
typechecking point of view, rows may be used to typecheck object-oriented
languages in a structural style (Wand, 1994; Rémy, 1994). This is, in particu-
lar, the route followed in Objective Caml (Rémy and Vouillon, 1998). There,

10.8
Rows
487
an object type consists of a row of method types, and gives the object’s inter-
face. Such a style is considered structural, as opposed to the style adopted by
many popular object-oriented languages, such as C++, Java, and C#, where an
object type consists of the name of its class. Thanks to rows, method invo-
cation may be assigned a polymorphic type scheme, similar to that of record
access (Example 10.8.30), making it possible to invoke a speciﬁc method (say,
ℓ) without knowing which class the receiver object belongs to.
Rows may also be used to encode sets of properties within types or to
encode type reﬁnements, with applications in type-based program analysis.
Some instances worth mentioning are soft typing (Cartwright and Fagan,
1991; Wright and Cartwright, 1994), exception analysis (Leroy and Pessaux,
2000; Pottier and Simonet, 2003), and static enforcement of an access control
policy (Pottier, Skalka, and Smith, 2001). BANE (Fähndrich, 1999), a versatile
program analysis toolkit, also implements a form of rows.
Variations on Rows
A type system may be said to have rows, in a broad sense, if mappings from
labels to types may be (i) deﬁned incrementally, via some syntax for extending
an existing mapping with information about a new label and (ii) abstracted by
a type variable. In this chapter, which follows Rémy’s ideas (1993; 1992a;
1992b), the former feature is provided by the row constructors (ℓ: · ; ·),
while the latter is provided by the existence of row variables, that is, type
variables of row kind Row(L) for some L. There are, however, type systems
that provide (i) and (ii) while departing signiﬁcantly from the one presented
here. These systems diﬀer mainly in how they settle some important design
choices:
1. Does a row denote a ﬁnite or an inﬁnite mapping from labels to types?
2. Is a row with duplicate labels considered well-formed? If not, by which
mechanism is it ruled out?
In Rémy’s approach, every row denotes an inﬁnite (in fact, coﬁnite) mapping
from labels to types. The type constructors abs and pre are used to encode
domain information within ﬁeld types. A row with duplicate labels, such as
(ℓ: T1 ; ℓ: T2 ; T3), is ruled out by the kind system. Below, we mention a
number of type systems that make diﬀerent design choices.
The ﬁrst use of rows for typechecking operations on records, including
record extension, is due to Wand (1987a; 1988). In Wand’s approach, rows de-
note ﬁnite mappings. Furthermore, rows with duplicate labels are considered
legal; row extension is interpreted as function extension, so that, if a label oc-
curs twice, the later occurrence takes precedence. This leads to a diﬃculty in

488
10
The Essence of ML Type Inference
the constraint solving process: the constraint (ℓ:T1 ; R1) = (ℓ:T2 ; R2) entails
T1 = T2, but does not entail R1 = R2, because R1 and R2 may have diﬀerent
domains—indeed, their domains may diﬀer at ℓ. Wand’s proposed solution
(1988) introduces a four-way disjunction, because each of R1 and R2 may or
may not deﬁne ℓ. This gives type inference exponential time complexity.
Later work (Berthomieu, 1993; Berthomieu and le Moniès de Sagazan, 1995)
interprets rows as inﬁnite mappings but sticks with Wand’s interpretation of
row extension as function extension, so that duplicate labels are allowed. The
constraint solving algorithm rewrites the problematic constraint (ℓ:T1 ; R1) =
(ℓ: T2 ; R2) to (T1 = T2) ∧(R1 ={ℓ} R2), where the new predicate =L is inter-
preted as row equality outside L. Of course, the entire constraint solver must
then be extended to deal with constraints of the form T1 =L T2. The advan-
tage of this approach over Wand’s lies in the fact that no disjunctions are
ever introduced, so that the time complexity of constraint solving apparently
remains polynomial.
Several other works make opposite choices, sticking with Wand’s interpre-
tation of rows as ﬁnite mappings but forbidding duplicate labels. No kind
discipline is imposed: some other mechanism is used to ensure that dupli-
cate labels do not arise. In Jategaonkar and Mitchell (1988) and Jategaonkar
(1989), somewhat ad hoc steps are taken to ensure that, if the row (ℓ: T ; X)
appears anywhere within a type derivation, then X is never instantiated with
a row that deﬁnes ℓ.
In Gaster and Jones (1996), Gaster (1998), and Jones
and Peyton Jones (1999), explicit constraints prevent duplicate labels from
arising. This line of work uses qualiﬁed types (Jones, 1994), a constraint-
based type system that bears strong similarity with HM(X). For every label
ℓ, a unary predicate · lacks ℓis introduced; roughly speaking, the constraint
R lacks ℓis considered to hold if the (ﬁnite) row R does not deﬁne the label ℓ.
The constrained type scheme assigned to record access is
·.⟨ℓ⟩: ∀XY[Y lacks ℓ].Π (ℓ: X ; Y) →X.
The constraint Y lacks ℓensures that the row (ℓ: X ; Y) is well-formed. Al-
though interesting, this approach is not as expressive as that described in
this chapter. For instance, although it accommodates record update (where
the ﬁeld being modiﬁed is known to exist in the initial record) and strict
record extension (where the ﬁeld is known not to initially exist), it cannot ex-
press a suitable type scheme for free record extension, where it is not known
whether the ﬁeld initially exists. This approach has been implemented as the
“Trex” extension to Hugs (Jones and Peterson, 1999).
It is worth mentioning a line of type systems (Ohori and Buneman, 1988,
1989; Ohori, 1995) that do not have rows, because they lack feature (i) above,
but are still able to assign a polymorphic type scheme to record access. One

10.8
Rows
489
might explain their approach as follows. First, these systems are equipped
with ordinary, structural record types, of the form {ℓ1 : T1; . . . ; ℓn : Tn}. Sec-
ond, for every label ℓ, a binary predicate · has ℓ: · is available. The idea is
that the constraint T has ℓ: T′ holds if and only if T is a record type that
contains the ﬁeld ℓ: T′. Then, record access may be assigned the constrained
type scheme
·.⟨ℓ⟩: ∀XY[X has ℓ: Y].X →Y.
This technique also accommodates a restricted form of record update, where
the ﬁeld being written must initially exist and must keep its initial type; it
does not, however, accommodate any form of record extension, because of
the absence of row extension in the syntax of types. Although the papers
cited above employ diﬀerent terminology, we believe it is fair to view them as
constraint-based type systems. In fact, Odersky, Sulzmann, and Wehr (1999)
prove that Ohori’s system (1995) may be viewed as an instance of HM(X).
Sulzmann (2000) proposes several extensions of it, also presented as in-
stances of HM(X), which accommodate record extension and concatenation
using new, ad hoc constraint forms in addition to · has ℓ.
In the label-selective λ-calculus (Garrigue and Aït-Kaci, 1994; Furuse and
Garrigue, 1995), the arrow type constructor carries a label, and arrows that
carry distinct labels may commute, so as to allow labeled function arguments
to be supplied in any order. Some of the ideas that underlie this type system
are closely related to rows.
Pottier (2003) describes an instance of HM(X) where rows are not part of
the syntax of types: equivalent expressive power is obtained via an exten-
sion of the constraint language. The idea is to work with constraints of the
form R1 ≤L R2, where L may be ﬁnite or coﬁnite, and to interpret such a
constraint as row subtyping inside L. In this approach, no new type variables
need be allocated during constraint solving; contrast this with S-Mutate-LL,
S-Mutate-GD, and S-Mutate-GL in Figure 10-14. One beneﬁt is to simplify
the complexity analysis; another is to yield insights that lead to generaliza-
tions of rows.
Even though rows were originally invented with type inference in mind,
they are useful in explicitly typed languages as well; indeed, other approaches
to typechecking operations on records appear quite complex (Cardelli and
Mitchell, 1991).


A
Solutions to Selected Exercises
1.1.4
Solution: The proof of each lemma proceeds by induction on the typing
derivation. Almost all cases follow directly from the induction hypothesis.
The base cases are straightforward as well, but some slight amount of work
is involved. For instance, in the base case for weakening we are given the judg-
ment Γ1, x:T, Γ2 ⊢x : T. and must prove that for arbitrary Γ3, Γ1, x:T, Γ2, Γ3 ⊢
x : T. The latter judgment follows directly from the variable rule as the rule
schema allows the context Γ1, x:T, Γ2, Γ3. Notice, however, that if we were not
careful in the deﬁnition of the variable rule and had omitted Γ2 from the con-
text in the rule schema, we would be unable to prove this weakening lemma.
Hence, while simple, the rules for the variables and constants play an integral
role in deﬁning the structural properties of a type system.
1.2.1
Solution: Since the variable may only appear on the extreme right-hand side
of the context, we will be unable to prove the exchange lemma. In the liter-
ature, you will see this formulation of the variable rule all the time because
authors often treat contexts as ﬁnite partial maps. In other words, contexts
that diﬀer only in the order in which we write down their elements are treated
equally and are never distinguished from one another. In this chapter, we
choose not to take this perspective so that we may study the complete set of
structure rules directly.
1.2.13
Solution: No: the lemma is false. Fortunately, the preservation theorem for
our language only depends upon a substitution lemma involving variables:
Lemma [Linear Variable Substitution]: Let Γ3 = Γ1 ◦Γ2. If Γ1, x:T ⊢t1 : T1
and Γ2 ⊢y : T then Γ3 ⊢[x , y]t1 : T1.
1.3.1
Solution: The type of linear trees with elements of type T follows.
type T tree = rec a.lin (unit + lin (T * a * a))
It will be convenient to deﬁne some constructors for trees of type T as well.

492
A
Solutions to Selected Exercises
fun nilT (nil:unit) : T tree =
roll (lin inl nil)
fun nodeT (arg : lin (T * T tree * T tree)) : TL =
roll (lin inr arg)
As we recurse into the tree structure, we must create a list of subtrees that
have yet to be processed. This list will be constructed from parts of the tree
itself. In ML, we could deﬁne the appropriate sort of list using the following
datatype.
datatype (T1,T2) TL =
done
| right of T2 * T1 tree * TL
| left of T2 * T2 tree * TL
Let us assume that our recursive tree map procedure takes a tree t and a
TL-list l as an argument. If l is the ﬁrst constructor done, then all we have
to do is process t. If l is the second constructor (say right(elem,tr,l′))
then when we ﬁnish processing t, we have ﬁnished processing a left subtree,
but we still need to process the right subtree (tr) and glue the processed tree
element (elem) together with the results. We also need to recursively process
the rest of the list l′. If l is the last constructor (say left(elem,tl,l′)) then
when we ﬁnish processing t, we have just ﬁnished processing a right subtree
and we need to assemble the tree element (elem), the left subtree (tl) and the
recently ﬁnished right subtree, and recursively process the rest of the list.
In our linear lambda calculus, the ML type deﬁnition given above and its
associated constructors will be deﬁned as follows. We will use in0, in1,...
inn−1 to inject into a n-ary sum when n is greater than two.
type TL =
mu a.
lin (unit + lin (T2 * T1 tree * a)
+ lin (T2 * T2 tree * a))
fun done (nil:unit) : TL = roll (lin in0 nil)
fun right (arg : lin (T2 * T1 tree * TL)) : TL =
roll (lin in2 arg)
fun left (arg : lin (T2 * T2 tree * TL)) : TL =
roll (lin in1 arg)
The algorithm is factored into a top-level function treeMap and two helpers.
The ﬁrst processes a subtree we have not seen yet. The second determines
what to do next by looking at the TL stack.

A
Solutions to Selected Exercises
493
type FT = T1 →T2
fun treeMap(f:FT,t:T1 tree) : T2 tree =
procTree (f,t,done())
and procTree(f:FT,t:T1 tree,tl:TL) : T2 tree =
case unroll t (
inl nil ⇒procTL (f,nilT2(),tl)
| inr tree ⇒
split tree as elem,t1,t2 in
procTree (f,t1,right lin <f elem,t2,tl>)
and procTL(f:FT,t:T2 tree,tl:TL): T2 tree =
case unroll tl (
in0 nil
⇒t
| in1 arg ⇒
split arg as elem,t2,tl in
procTree (f,t2,left lin <elem,t,tl>)
| in2 arg ⇒
split arg as elem,t1,tl in
procTL (f,nodeT2 lin <elem,t1,t2>,tl)
1.3.4
Solution: If an unrestricted array can contain a linear object, the linear ob-
ject might never be used because the programmer might forget to use the en-
tire array. Due to our swapping operational semantics for arrays, even though
an unrestricted array (containing linear objects) can be used many times, the
linear objects themselves can never be used more than once. In short, the
supposedly linear objects would actually be aﬃne.
1.4.1
Solution: Consider the following expression. If we generalized the syntax
to allow nested sub expressions but made no change to the typing rules, it
would type check despite the fact that booleans are confused with integers.
let x = ord <true,true> in
let y = ord <ord <3,2>,x> in
split y as z1,z2 in
split z2 as b1,b2 in
if b1 then ...
(* using an int as if it was a bool *)
Can we change the typing rules in some way to solve the soundness problem?
1.4.2
Solution: Consider the following well-typed expression.
let x1 = ord true in
let f = ord λy:ord bool.ord <x1,y> in
let x2 = ord false in
f x2

494
A
Solutions to Selected Exercises
At the point of execution just before the function call, the stack will be or-
ganized with x1, which belongs to f’s closure, at the bottom of the stack, f
allocated immediately on top of x1, and x2 allocated immediately on top of f.
When the function f is called, f should be deallocated, since ordered ob-
jects are always deallocated when they are used. However, f is in the middle
of the stack rather than on top, so the ordered abstract machine gets stuck.
The main problem centers around checking ordered functions with ordered
arguments.
1.4.3
Solution: The previous problem demonstrates that the diﬃculty with or-
dered functions is that when the function has an ordered argument, the
function will appear in the middle of the stack when it is called. We cannot
deallocate the function at that point, but one thing we can do is substitute a
placeholder with type junk for the used function pointer. The only thing that
can be done with an object of type junk is to pop it oﬀthe stack. When the
code in the function body has used up the ordered function argument, the
junk item will appear at the top of the stack. At this point, programmer will
explicitly pop it oﬀthe stack and move on to using objects in the function’s
closure.
The typing rule for the specialized ordered abstraction with ordered argu-
ment appears below. We also give the typing rule for the command pop x; t,
which pops its argument (x) oﬀthe top of the stack and continues execution
with t below. It is up to you to deﬁne their operational rules.
Γ, f:ord junk, x:ord P1 ⊢t2 : T2
Γ ⊢ord λf x:(ord P1).t2 : ord (ord P1)→T2
(T-Abs)
Γ2 ⊢x : ord junk
Γ1 ⊢t : T
Γ1 ◦Γ2 ⊢pop x; t : T
(T-Pop)
2.1.1
Solution: We can introduce a type family for rectangular matrices thus:
Matrix
:: Nat →Nat →∗
idmatrix
: Πn:Nat. Matrix n n
multmatrix : Πl:Nat. Πm:Nat. Πn:Nat.
Matrix l m →Matrix m n →Matrix l n
Suppose we have a dependent type for ranges of integers: {n...m} denotes
the type of integers between n and m inclusive, either n or m may be omitted.
A possible typing for dates is given by:
Year
=
{2003..} :: ∗
Month =
{1..12}
:: ∗
Day
:: Month →∗

A
Solutions to Selected Exercises
495
where
Day(n)
=
{1..31}
if n ∈{1, 3, 5, 7, 8, 10, 12}
Day(n)
=
{1..30}
if n ∈{4, 6, 9, 11}
Day(2)
=
{1..29}
A date is then given by an element of the Σ-type (see page 48):
Date :: Σy:Year. Σm:Month. Day(m)
Of course, we could gain more accuracy by making the type of days also
depend on the year.
2.1.2
Solution: A type representing the constructive axiom of choice for a pred-
icate P is (Πa:A.Σb:B. P(a,b)) →(Σf:A→B. Πx:A. P(x, f x)). It can be
shown in Martin-Löf’s type theory that this type is inhabited (Martin-Löf,
1984).
2.1.3
Solution: Σa:A.Σb:B.Id(f a, g b)
2.1.4
Solution: Here are some terms representing β-reduction and its closure on
lambda terms:
Eval
:: ΠA:Ty. Tm A →Tm A →∗
evalAppAbs : ΠA:Ty. ΠB:Ty.
Πt1:(Tm A →Tm B).
Πt2:(Tm A) →Eval (app (lam t1) t2) (t1 t2)
evalLam
:
ΠA:Ty. ΠB:Ty.
Πft1,ft1’:(Tm A →Tm B).
(Πx: Tm A. Eval (ft1 x) (ft1’ x))
→Eval (lam ft1) (lam ft2)
evalApp1 :
ΠA:Ty. ΠB:Ty.
Πt1,t1’:(Tm (arrow A B)).
Πt2: Tm B. Eval t1 t1’
→Eval (app t1 t2) (app t1’ t2)
evalApp2 :
ΠA:Ty. ΠB:Ty.
Πt1: (Tm (arrow A B)).
Πt2,t2’: Tm B. Eval t2 t2’
→Eval (app t1 t2) (app t1 t2’)
2.6.4
Solution: We give the solution in the syntax of the implementation.
eqSucc =
λx:Prf(nat).λy:Prf(nat).λh:Prf(eq nat x y).
h(λz:Prf(nat).eq nat (succ x) (succ z)) (eqRefl nat (succ x))
: Πx:Prf(nat).Πy:Prf(nat).Prf(eq nat x y) →
Prf(eq nat (succ x) (succ y));

496
A
Solutions to Selected Exercises
addAssoc = λx:Prf(nat).λy:Prf(nat).λz:Prf(nat).
eq nat (add x (add y z)) (add (add x y) z);
proofOfAddAssoc = λx:Prf(nat).λy:Prf(nat).λz:Prf(nat).
natInd (λx1:Prf(nat).addAssoc x1 y z)
(eqRefl nat (add y z))
(λx1:Prf(nat).λp:Prf(addAssoc x1 y z).
eqSucc (add x1 (add y z)) (add (add x1 y) z) p)
x
: Πx:Prf(nat).Πy:Prf(nat).Πz:Prf(nat).Prf(addAssoc x y z);
2.7.1
Solution: Let i : Syntax(λLF) →Syntax(λP) be the obvious mapping be-
tween the syntaxes, which collapses each λLF λ-construct to the single λP
λ-operator, etc. (Except that type and term variables have disoint images).
Then we would hope to show:
1. Γ ⊢λLF t : T ⇐⇒i(Γ) ⊢λP i(t) : i(T)
2. Γ ⊢λLF T :: K ⇐⇒i(Γ) ⊢λP i(T) : i(K)
3. Γ ⊢λLF K ⇐⇒i(Γ) ⊢λP i(K) : 2
There are two diﬃculties in establishing this equivalence. First, the presenta-
tion of λLF includes Q-Eta, but η equalities are not included in the deﬁnition
of PTS we gave. If Q-Eta is removed from λLF, the left to right direction is
straightforward. The right to left direction raises the second diﬃculty: we
must show that the untyped conversion relation of PTS can be simulated
by the declarative equality in λLF. This requires showing the Church-Rosser
property for the PTS conversion.
2.8.1
Solution: To complete the deﬁnition, we must give a simultaneous deﬁnition
of the interpretation of index sorts, JIKη ⊆Z, index terms, JiKη ∈Z, and
satisfaction between environments and contexts, η |= Γ and environments
and propositions, η |= P. The deﬁnitions are given below.
η |= ∅
η |= Γ, x : I
if η |= Γ and η(x) ∈JIKη
η |= Γ, P
if η |= P
η |= P1 ∧P2
if η |= P1, η |= P2
η |= i1 <= i2
if Ji1Kη ≤Ji2Kη
JxKη
=
η(x)
JqKη
=
q
JqiKη
=
q × JiKη
Ji1 + i2Kη
=
Ji1Kη + Ji2Kη
JintKη
=
Z
J{x:I | P}Kη
=
{ z ∈Z | η[x , z] |= P }
Finally, Γ |= i : I is deﬁned as ∀η. η |= Γ. =⇒JiKη ∈JIKη.

A
Solutions to Selected Exercises
497
3.2.7
Solution: All TL-typing rules are closed under arbitrary substitutions. Con-
sequently all substitutions of TL-typable closed terms yield typable terms. In
particular, S(t1) is TL-typable.
3.2.18
Solution:
1. That t ↑implies ∥t∥↑follows directly from the Conditional Correctness
Theorem, part 2. Assume now t ↓, that is t terminates. By the Soundness
Theorem t cannot terminate with a stuck state, so t
t-→
∗
v for some value
v. By Conditional Correctness, part 1, this implies that ∥t∥-→∗∥v∥. By
Lemma 3.2.9, part 1, ∥v∥is also a value. Since all values are ﬁnal (easy),
this shows that ∥t∥↓.
2. The implication from right to left follows directly from Conditional Cor-
rectness, part 1. As for the converse direction, assume ∥t∥-→∗∥v∥. By
Soundness evaluation of t does not get stuck and by part 1 of the corollary
there exists a TL-value v′ such that t
t-→
∗
v′. By Conditional Correctness,
part 1, we have ∥t∥-→∗∥v′∥. Since
-→is deterministic and we also have
∥t∥-→∗∥v∥by assumption, we can conclude that ∥v′∥= ∥v∥, and we are
done.
3.2.19
Solution: (Sketch) There is a better completion. The two occurrences of tt
can be given distinct labels.
3.4.2
Solution: Both of the two recursive calls would have to specify ρi, ρo as
actual parameters, and so all intermediate arguments and results would end
up in the same two regions; namely the two argument regions supplied to the
function at the outermost level.
3.4.3
Solution: An n-ary region abstraction can be converted into a stack of unary
ones, but one must decide where the intermediate region closures that the se-
mantics require are allocated. The following solution takes care not to cause
any net heap allocation in the translation of an n-ary application:
(λρ1, . . . , ρn.t) at ρ ⇒(λρ′.(λρ1.· · · (λρn.t) at ρ′ · · ·) at ρ′) at ρ
f [[ρ1, . . . , ρn]] ⇒new ρ′.f [[ρ′]] [[ρ1]] · · · [[ρn]]
3.4.4
Solution: When the region abstraction is applied (i.e., each time f is men-
tioned), a closure must be allocated to contain the region parameters and the
free variables of the function body, because the ordinary BL parameter may
not be supplied right away. The parameter ρ′ selects the region in which this
closure will be allocated. It is not part of the TT syntax for letrec because

498
A
Solutions to Selected Exercises
this closure allocation is implicit in the letrec construct; instead the original
syntax for applying the region abstraction is
t ::= f[ρ1, . . . , ρk] at ρ′
which can be expressed as f [[ρ1, . . . , ρk, ρ′]] in RAL.
3.4.5
Solution: ρ is the region where a closure for the region abstraction is allo-
cated. This closure contains the values of the free variables of the lambda ex-
pression. The intention in TT was that this closure would be consulted when
the region abstraction is applied, such that the variables could be moved to
the ﬁnal closure in ρ′. However, due to the syntactic requirement that the
region abstraction is applied whenever f is mentioned in t1 or t2, the free
variables will actually still be in scope at the application point. Since the body
of the region abstraction is also statically known, nothing actually needs to
be allocated in ρ, and indeed the ML Kit, a practical realization of TT (refer to
Section 3.8), does not allocate this closure. But this was not realized when TT
was ﬁrst formulated.
3.4.6
Solution: By a simple induction over the derivation of the evaluation rela-
tion, we may prove that if t•
RAL
-→t′
• and t• ⪯t, then there is a t′ such that
t
RAL
-→t′ and t′
• ⪯t′.
Apply this lemma to each step of the reduction of the original t•. In the
case Y = bv, note that bv ⪯t implies bv = t.
3.5.2
Solution: The only interesting issue in the proof is that the substitutions
substitute from sets of variables to another syntactic class (from region vari-
ables to places, for example). Observe, however, that everywhere in the typing
rules something is required to be a type, region, or eﬀect variable (rather than,
say, a place or eﬀect), it occurs in a binding context and so is unaﬀected by
substitution.
3.5.13
Solution: The reference operations would need a formal semantics, so we
would have to extend the evaluation and typing judgments with stores and
store typings as in Chapter 13 of TAPL. But that would break the lexical scop-
ing of region variables, on which the correct operation of rule (re-Dealloc)
depends critically. So the entire semantic treatment of region allocation and
deallocation needs to be reworked. How to do this can be seen in Calcagno,
Helsen, and Thiemann (2002).
3.6.1
Solution: No. It is typable (if and) only if the input program satisﬁes our
syntactic restriction on the use of the fix operator, and is typable in (region-
free) F with recursion, such that the type of the entire program is either bool

A
Solutions to Selected Exercises
499
or a type variable. If the input program is ill-typed, it can never be region
annotated; a derivation of ∅⊢t :ϕ T can be converted into a derivation of
∅⊢∥t∥: ∥T∥in System F with recursion simply by erasing all of the region-
related syntax. (∥T∥, is of course, T with the region annotations removed, in
a way similar to ∥t∥.) Such an erasure transforms each RTL type rule into
either a well-known F rule or the identity rule that concludes any judgment
from itself.
3.6.3
Solution: The constraints collected during the analysis of that subexpres-
sion did not entail ρ5 being in ϕ at all. It was only when the two sides of the
m application were combined that ρ5 entered the picture. (The point here is
that construction of new must necessarily happen while each subterm is ana-
lyzed; the raw type tree plus constraints does not immediately show where it
is useful to insert new except at the root.)
3.6.4
Solution: Eﬀect polymorphism serves to enforce relations between the eﬀect
parts of diﬀerent arrow constructions in the polymorphic variant of a type.
In a ﬁrst-order program, there is at most one arrow in each type, so there is
no need for explicit eﬀect polymorphism.
5.2.1
Solution: The assertion that x has type singleton for value v can be writ-
ten simply as x = v. The singleton type for the value v can be written
as {x | x = v} and correspondingly the assertion can also be written as x :
{x | x = v}
5.2.2
Solution: {x | x : ptr {{y | y = 0} ; int} ∨x : ptr {{y | y = 1} ; int; int}}.
5.2.3
Solution: We assume that the same listinv formula constructor is used to
specify that the contents of the memory is well-typed. The function speciﬁ-
cation is then:
Pre
=
r1 : ptr {int; int} ∧r2 : list int ∧listinv rM
Post
=
rR : list int ∧listinv rM
5.2.4
Solution: The challenge here is to express the sequence property. We can do
that either by adding a new type constructor or simply by using a universal
quantiﬁer.
Pre
=
listinv rM ∧∀i.(0 ≤i ∧i < r2) ⇒(r1 + 4 ∗i) : ptr {list int}
Post
=
listinv rM
5.2.5
Solution: We show the solution for the more complicated case when the
array elements are structures. We must add the array S type constructor,

500
A
Solutions to Selected Exercises
where S is a structure type. We also add the (sizeof S N) formula to state
that the size of the structure S is N bytes.
In order to handle the sizeof formula constructor we add the following
two rules:
sizeof W 4
sizeof S N
sizeof (W; S) (N + 4)
By indexing into an array we can obtain pointers to elements, provided that
the index is in the bounds of the array. For the purpose of bounds checking
we must fetch the length of the array from memory and hence we must add
a requirement that the memory contents is well-typed.
A : array S
(sizeof S N)
0 ≤I
I < (sel M A)
listinv M
(A + 4 + I ∗N) : ptr {S}
5.3.1
Solution: For the ﬁrst program fragment the symbolic state at the end is
σ = {ra = b + 1, rb = b, rc = (b + 1) + 2, rd = b + 1}. For the second
program fragment the resulting symbolic state is σ = {r1 = b + 1, r2 =
b, rc = (b + 1) + 2, rd = b + 1}. Notice that the symbolic state is the same,
considering the renaming of registers once we consider the
5.3.2
Solution: With the addition of the new instruction in the ﬁrst code fragment,
the symbolic state at the end of the block becomes σ = {ra = 3, rb = b, rc =
(b + 1) + 2, rd = b + 1}. The symbolic state of register ra is diﬀerent from the
symbolic state of the corresponding register (r1) in the second code fragment.
5.3.4
Solution: The key observation is that the symbolic evaluator carries precise
information about the result of the load in line 6 in Figure 5-2. Everytime this
value is used, we have to prove that it has the right type. We have to ensure
that VCGen “forgets” the precise description of the result of the load, and
maintains only the fact that it is a value of type ptr {int}. We do this by
adding an invariant annotation immediately after the load:
...
6 LCons:
rt := Mem[rx]
; Load the first data
7
INV rt : ptr {int} ∧rx : ptr {maybepair; mp_list} ∧listinv rM
8
...
When encountering this invariant, the VCGen assumes fresh values for all reg-
isters and assumes that the invariant holds for these values. This eﬀectively
means that the fact sel m1 x1 : ptr {int} is proved only once, when the
invariant is ﬁrst encountered. Notice also that the invariant must preserve all
useful information about the live registers. For the rx register we know that
it is not equal to zero and has type mp_list, hence it is a pointer to a list cell.

A
Solutions to Selected Exercises
501
5.3.5
Solution: We assume that for each function staring at address L in the agent
we have a precondition PreL and a postcondition PostL. These can be speci-
ﬁed by the agent producer using annotations. For example, in JVML they are
speciﬁed as types in a special table in the .class ﬁle that contains the agent.
Assume also that the set of registers is r1, . . . , rn and that the callee-save
registers are r1, . . . , rCS. Unlike in the original symbolic evaluator we must
identify for each return instruction to which function it belongs, and thus
what postcondition to use. This can be done by carrying an additional pa-
rameter in the symbolic evaluator to specify the postcondition to use for the
return instructions. Instead, we are going to assume that return instructions
are annotated with the starting address of the function to which they belong.
We also assume that each start of a function contains an invariant corre-
sponding to the precondition. Now we can extend the symbolic evaluator as
follows:
SE(i, σ) =



. . .
(σ PostL)
if Πi = returnL
(σ PreL) ∧
if Πi = call L
∀xCS+1. . . . .xn.(σ ′ PostL) ⇒SE(i + 1, σ ′)
where σ ′ = σ[rCS+1 = xCS+1, . . . , rn = xn]. Thus a function call ﬁrst asserts
that the precondition holds, then modiﬁes the symbolic state so that the non
callee-save registers are modiﬁed to have arbitrary values. The state σ ′ mod-
els the state after the call. In this state the postcondition is assumed to hold
and the symbolic evaluation continues.
5.3.6
Solution: We extend the symbolic evaluator as follows:
SE(i, σ) =
(
. . .
false
if Πi = UNREACHABLE
Notice that indeed we stop the evaluation at that point, but we require that
the agent producer proves that this context is never reachable. The agent
producer can actually produce a proof of false if this program point follows
a function call to a function that never returns and whose postcondition is
false, as is the case with the myexit function in the problem statement. It
is also possible to prove false at a program point following a conditional
branch that can be proved to be always taken.
5.3.7
Solution: We shall consider that each label in the program also acts as a
nullary constructor in the logic, denoting the program counter where it is
placed. We extend the symbolic evaluator to read the annotation that follows
an indirect jump and to require a proof that the address being jumped to

502
A
Solutions to Selected Exercises
is equal to one of the declared destinations. Otherwise, the indirect jump is
handled as a conditional branch.
SE(i, σ) =



. . .
((σ e) = L1 ∨(σ e) = L2) ∧
if Πi = jump at e
((σ e) = L1 ⇒SE(L1, σ)) ∧
and Πi+1 = JUMPDEST(L1,L2)
((σ e) = L2 ⇒SE(L2, σ))
5.4.1
Solution: We prove here only the soundness of the cons rule. We must
prove the following statement: |=M ∀E.∀W.(E : list W) ∧(E ≠0) ⇒E :
ptr {W; list W}. Assuming that the left-hand side of the implication holds,
and using the deﬁnition of |=M (see page 200), we derive that (M(E) = W ∧
M(E+4) = list W). Now we can verify the right-hand side of the implication:
|=M E : ptr {W; list W}.
5.4.6
Solution: Let ρ1 be a state such that |=M ρ1 Pre. We assume that Dom(M) ⊆
Addr and |=M VC. By convention the ﬁrst instruction in the program (at
program counter 1) is an invariant INV Pre. Let σ1 = {r1 = x1, . . . , rn = xn}
and τ1 = {x1 = ρ1 r1, . . . , xn = ρ1 rn}. This means that ρ1 = τ1 ◦σ1. We also
know that SE(1, σ1) = σ1 Pre and therefore we know that |=M τ1 SE(1, σ1).
This allows us to establish that the induction hypothesis holds for the ﬁrst
instruction: IH(1, ρ1, σ1, τ1).
We can prove by induction on the number of transition steps, that for any
(i, ρ) reachable from the initial state (1, ρ1), there exist σ and τ such that
IH(i, ρ, σ, τ). Furthermore, either i points to a return instruction or else we
can make further progress. The base case follows from the argument above
and the inductive step is proved using Theorem 5.4.4.
5.5.1
Solution:
all (λa : ι.
(imp (hastype a (ptr (seq1 int)))
(addr a)))
5.5.2
Solution: The proof of the predicate ∀a.a : ptr {int} ⇒addr a is:
u
a : ptr {int}
ptraddr
addr a
impiu
a : ptr {int} ⇒addr a
allia
∀a.a : ptr {int} ⇒addr a
The LF representation of this proof is shown below. Notice how the parameter
a and the hypothesis u are properly scoped by using higher-order represen-
tation.

A
Solutions to Selected Exercises
503
alli (λa : ι.(imp (hastype a (ptr (seq1 int)))
(addr a)))
(impi (hastype a (ptr (seq1 int)))
(addr a)
(λu : pf (hastype a (ptr (seq1 int)))
(ptraddr a (seq1 int) u)))
In the above representation we used LF constants declared in Figure 5-11
along with the following declaration for ptraddr:
ptraddr
:
ΠA : ι.ΠS : s.pf (hastype A (ptr S)) →pf (addr A)
6.2.1
Solution: The if direction (s′ = t′ implies sa∗t) follows directly from sym-
metry and transitivity. For the only-if direction, suppose sa∗t. We claim
that s and t have a common reduct (that is, there exists u such that s⇒∗u
and t⇒∗u):
Proof:
The proof is by induction on s a∗t.
Base step:
Suppose sa∗t holds because s⇒t. Then let u be t.
Induction step: (Symmetry)
Suppose sa∗t holds because ta∗s. By induction, t and s have a common
reduct u.
Induction step: (Transitivity)
Suppose sa∗t holds because sa∗u′ and u′a∗t. By induction, s and u′ have
a common reduct s′′, and u′ and t have a common reduct t′′. Thus u′⇒∗s′′
and u′⇒∗t′′, so by conﬂuence there exists u such that s′′⇒∗u and t′′⇒∗u.
Therefore u is a common reduct of s and t.
2
We have shown that s and t have a common reduct u. Observe that s⇒∗s′
and s⇒∗u. By conﬂuence, there exists r such that s′⇒∗r and u⇒∗r. But s′ is
a normal form, so r = s′. Hence u⇒∗s′. Similarly u⇒∗t′. Then, by conﬂuence,
s′ and t′ must have a common reduct, but again they are normal forms so
they must be equal.
6.2.2
Solution: By induction on derivations. We show the case for Q-Ext; the oth-
ers are straightforward. For Q-Ext, choose x so as not to be free in s or t.
By induction, s x a∗t x. It is easy to show by induction that λx:T1.s x a∗
λx:T1.t x (by repeatedly using QR-Abs). By QR-Eta, λx:T1.s x ⇒s and
λx:T1.t x ⇒t. Therefore s a∗t by symmetry and transitivity.
6.2.3
Solution: Let T and T′ be any two distinct types. Let t be λx:T.(λy:T′.y)x.
By QR-Abs and QR-Beta, t reduces to λx:T.x, and by QR-Eta, t reduces to

504
A
Solutions to Selected Exercises
λy:T′.y. These two terms are distinct normal forms, so they have no common
reduct.
6.3.1
Solution: s is λx:Unit.x and t is λx:Unit.unit.
6.6.3
Solution: The logical equivalence x:b ⊢x is x : b holds but ⊢x is x : b
does not.
6.6.4
Solution: The logical equivalence ⊢λx:b.x is λx:b.k : b→b holds, but
y:b ⊢λx:b.x is λx:b.k : b→b does not.
Proof:
We begin by showing the former logical equivalence holds. Suppose
⊢s is t : b. We wish to show that ⊢(λx:b.x) s is (λx:b.k) t : b. It is
suﬃcient to show that: ⊢(λx:b.x) s a (λx:b.k) t : b. Since ⊢s is t : b,
we have that ⊢s a t : b. By inversion s ⇓s′, t ⇓t′, and ⊢s′ ↔t′ : b. Since
the context is empty, and there exists only one constant, it is easy to verify
that s′ = t′ = k. Therefore ((λx:b.x) s) ⇓k and ((λx:b.k) t) ⇓k. The
desired conclusion follows.
Now we show that the latter logical equivalence does not hold. Let s =
t = y. Then certainly y:b ⊢s is t : b. However, ((λx:b.x) s) ⇓y and
((λx:b.k) t) ⇓k, and y and k are not path equivalent. Therefore (λx:b.x) s
and (λx:b.k) t are not algorithmically equivalent and hence not logically
equivalent at b.
2
6.9.2
Solution: By induction on T. The case T = Unit is trivial, and the case T = b
follows from algorithmic transitivity (Lemma 6.5.4).
Suppose T = T1→T2. Then Γ ⊢s is t : T1→T2 and Γ ⊢t is u : T1→T2. We
wish to show that Γ ⊢s is u : T1→T2. Suppose Γ ′ ⊇Γ and Γ ′ ⊢s′ is u′ : T1.
Then we wish to show that Γ ′ ⊢s s′ is u u′ : T2.
By logical symmetry (Lemma 6.9.1), Γ ′ ⊢u′ is s′ : T1, and then by in-
duction, Γ ′ ⊢u′ is u′ : T1. By the deﬁnition of logical equivalence, we may
deduce Γ ′ ⊢s s′ is t u′ : T2 and also Γ ′ ⊢t u′ is u u′ : T2. By induction,
Γ ′ ⊢s s′ is u u′ : T2.
6.9.10
Solution:
Case T-Const:
t = k
T = b
By the Main Lemma, Γ ′ ⊢k is k : b. Therefore Γ ′ ⊢γ(k) is δ(k) : b, since k
contains no free variables.
Case Q-Refl:
Immediate by the ﬁrst clause of the induction hypothesis.

A
Solutions to Selected Exercises
505
Case Q-Symm:
Immediate from the induction hypothesis and logical symmetry.
Case Q-Trans:
By logical symmetry, Γ ′ ⊢δ is γ : Γ, so by logical transitivity, Γ ′ ⊢δ is δ : Γ.
Therefore, by induction (using γ and δ), Γ ′ ⊢γ(s) is δ(t) : T, and also
by induction (using δ and δ), Γ ′ ⊢δ(t) is δ(u) : T. By logical transitivity,
Γ ′ ⊢γ(s) is δ(u) : T.
Case Q-Abs:
s = λx:T1.s2
t = λx:T1.t2
T = T1→T2
We wish to show that Γ ′ ⊢γ(λx:T1.s2) is δ(λx:T1.t2) : T1→T2. Suppose
Γ ′′ ⊇Γ ′ and Γ ′′ ⊢s′ is t′ : T1. We wish to show that Γ ′′ ⊢(λx:T1.γ(s2))s′ is
(λx:T1.δ(t2))t′ : T2. By logical weak head closure, it is suﬃcient to show
that Γ ′′ ⊢[x , s′]γ(s2) is [x , t′]δ(t2) : T2.
By logical monotonicity, Γ ′′ ⊢γ
is δ : Γ. Thus, Γ ′′ ⊢γ[x , s′] is
δ[x , t′] : (Γ, x:T1). Therefore, by induction, Γ ′′ ⊢γ[x , s′](s2) is δ[x ,
t′](t2) : T2, which is equivalent to the desired conclusion.
Case Q-App:
s = s1 s2
t = t1 t2
T = T12
By induction, Γ ′ ⊢γ(s1) is δ(t1) : T1→T2 and Γ ′ ⊢γ(s2) is δ(t2) : T1.
By the deﬁnition of the logical relation, since Γ ′ ⊇Γ, we may conclude Γ ′ ⊢
γ(s1)γ(s2) is δ(t1)δ(t2) : T2. That is, Γ ′ ⊢γ(s1 s2) is δ(t1 t2) : T2.
Case Q-Ext:
s = s
t = t
T = T1→T2
We wish to show that Γ ′ ⊢γ(s) is δ(t) : T1→T2. Suppose Γ ′′ ⊇Γ ′ and
Γ ′′ ⊢s′ is t′ : T1. We wish to show that Γ ′′ ⊢γ(s) s′ is δ(t) t′ : T2.
By logical monotonicity, Γ ′′ ⊢γ is δ : Γ. Thus, Γ ′′ ⊢γ[x , s′] is δ[x ,
t′] : (Γ, x:T1). Therefore, by induction, Γ ′′ ⊢γ[x , s′](s x) is δ[x ,
t′](t x) : T2. That is, Γ ′′ ⊢γ(s) s′ is δ(t) t′ : T2, as desired.
6.9.12
Solution: By soundness, Γ ⊢s1 ≡t1 : T1→T2 and Γ ⊢s2 ≡t2 : T1. By Q-App,
Γ ⊢s1 s2 ≡t1 t2 : T2. By completeness, Γ ⊢s1 s2 a t1 t2 : T2.
6.9.13
Solution: The key observation is that the left- and right-hand sides of the
algorithm do not interact, except insofar as a failure to match in path equiva-
lence allows the algorithm to quit early. That is, except for early termination,
one can trace the execution of the algorithm ignoring the terms either to the

506
A
Solutions to Selected Exercises
left or to the right of the arrows. Therefore we can devise a termination metric
that takes each side into account independently.
Therefore, deﬁne the metric M(Γ ⊢s a t : T) to be the size of the deriva-
tion (if it exists) of Γ ⊢s a s : T plus the size of the derivation (if it exists) of
Γ ⊢t a t : T. Deﬁne the metric M(Γ ⊢p ↔q : T) similarly. It is straightfor-
ward to show that the metric decreases in each recursive call of the algorithm.
It is also straightforward to show that all normalizations terminate, since the
normalization derivations being sought already exist within the derivations
measured by the metric.
Thus, it remains to show only that the metric is actually deﬁned, that is,
that there exist derivations of Γ ⊢s a s : T and Γ ⊢t a t : T. This follows
by the completeness of the algorithm from our assumptions that Γ ⊢s : T
and Γ ⊢t : T.
This strategy works precisely because the two sides of the algorithm do
not interact. It fails when the two sides do interact, such as in the algorithm
for full F≤(TAPL, Chapter 28), wherein bounded universal types on the right-
hand side aﬀect the context, which in turn aﬀects the promotion of variables
on the left-hand side. On the other hand, in the algorithm for kernel F≤, the
bounds on the left- and right-hand sides are required to be the same, so
the two sides do act independently (although the side being considered does
switch back and forth because of contravariance).
6.9.14
Solution: First, we extend the proofs of the basic algorithmic properties
(symmetry, transitivity, weak head closure, and monotonicity) to deal with
the new algorithm. These proofs are straightforward.
Second, we deﬁne logical equivalence as follows:
Γ ⊢s is t : T if and only if either:
T=Unit,
or T=b and Γ ⊢s a t : b,
or T=T1→T2 and, for all s′, t′ and all Γ ′ ⊇Γ,
if Γ ′ ⊢s′ is t′ : T1
then Γ ′ ⊢s s′ is t t′ : T2,
or T=T1 × T2 and Γ ⊢s.1 is t.1 : T1 and
Γ ⊢s.2 is t.2 : T2.
Third, we extend the proofs of the basic logical properties (symmetry, tran-
sitivity, weak head closure, and monotonicity) to deal with the new deﬁnition
of logical equivalence. These proofs are also straightforward.
Fourth, we extend the Main Lemma to account for product types (the other
cases are unchanged):

A
Solutions to Selected Exercises
507
Case:
T = T1 × T2
1. Suppose Γ ⊢s is t : T1 × T2. We wish to show that Γ ⊢s a t : T1 × T2.
The deﬁnition of logical equivalence provides that Γ ⊢s.1 is t.1 : T1,
and so Γ ⊢s.1 a t.1 : T1 follows by induction. Similarly, Γ ⊢s.2 a
t.2 : T2. Therefore, Γ ⊢s a t : T1 × T2.
2. Suppose Γ ⊢p ↔q : T1 × T2. We wish to show that Γ ⊢p is q : T1 × T2.
The algorithm provides that Γ ⊢p.1 ↔q.1 : T1, so Γ ⊢p.1 is q.1 : T1
follows by induction. Similarly, Γ ⊢p.2 is q.2 : T2. Therefore Γ ⊢p is
q : T1 × T2.
Finally, we extend the proof of the Fundamental Theorem to cover the new
typing and equivalence cases:
Case T-Pair:
t = ⟨t1, t2⟩
T = T1 × T2
By induction, Γ ′ ⊢γ(t1) is δ(t1) : T1, so by logical weak head closure,
Γ ′ ⊢γ(⟨t1,t2⟩).1 is δ(⟨t1,t2⟩).1 : T1. Similarly, Γ ′ ⊢γ(⟨t1,t2⟩).2 is
δ(⟨t1,t2⟩).2 : T2. Therefore Γ ′ ⊢γ(⟨t1,t2⟩) is δ(⟨t1,t2⟩) : T1 × T2.
Case T-Proj1:
t = t1.1
T = T1
We wish to show that Γ ′ ⊢γ(t1.1) is δ(t1.1) : T1. By induction, Γ ′ ⊢
γ(t1) is δ(t1) : T1 × T2, and the desired follows by the deﬁnition of logical
equivalence.
Case T-Proj2:
Similar to the case for T-Proj1.
Case Q-Pair:
s = ⟨s1, s2⟩
t = ⟨t1, t2⟩
T = T1 × T2
By induction, Γ ′ ⊢γ(s1) is δ(t1) : T1, so by logical weak head closure,
Γ ′ ⊢γ(⟨s1,s2⟩).1 is δ(⟨t1,t2⟩).1 : T1. Similarly, Γ ′ ⊢γ(⟨s1,s2⟩).2 is
δ(⟨t1,t2⟩).2 : T2. Therefore Γ ′ ⊢γ(⟨s1,s2⟩) is δ(⟨t1,t2⟩) : T1 × T2.
Case Q-Proj1:
s = s1.1
t = t1.1
T = T1
We wish to show that Γ ′ ⊢γ(s1.1) is δ(t1.1) : T1. By induction, Γ ′ ⊢
γ(s1) is δ(t1) : T1 × T2, and the desired follows by the deﬁnition of logical
equivalence.
Case Q-Proj2:
Similar to the case for Q-Proj1.

508
A
Solutions to Selected Exercises
Case Q-Beta-Prod1:
s = ⟨s1,s2⟩.1
t = t
T = T1
By induction, Γ ′ ⊢γ(s1) is δ(t) : T1. Therefore, by logical weak head clo-
sure, Γ ′ ⊢γ(⟨s1,s2⟩.1) is δ(t) : T1.
Case Q-Beta-Prod2:
s = ⟨s1,s2⟩.2
t = t
T = T2
By induction, Γ ′ ⊢γ(s2) is δ(t) : T2. Therefore, by logical weak head clo-
sure, Γ ′ ⊢γ(⟨s1,s2⟩.2) is δ(t) : T2.
Case Q-Ext-Prod:
s = s
t = t
T = T1 × T2
We wish to show that Γ ′ ⊢γ(s) is δ(t) : T1 × T2. It suﬃces to show that
Γ ′ ⊢γ(s.1) is δ(t.1) : T1 and Γ ′ ⊢γ(s.2) is δ(t.2) : T2, each of which
follows immediately by induction.
6.9.15
Solution: We must add a case for universal types to the deﬁnition of logical
equivalence. The most obvious deﬁnition is to quantify over all type argu-
ments and compare the type applications at the corresponding instantiated
type:
Γ ⊢s is t : ∀X.T if and only if
for all closed types T′, Γ ⊢s [T′] is t [T′] : [X , T′]T
Unfortunately, this is an invalid deﬁnition, because logical equivalence is
deﬁned by induction on types, and there is no guarantee that the type [X ,
T′]T is smaller than ∀X.T.
The problem is tied to the issue of impredicativity (TAPL, §23.10). In both
∀X.T, the domain of the quantiﬁed type variable X includes the very type
being deﬁned. This prevents the obvious deﬁnition from being well-founded.
For the simple deﬁnition attempt given above, the impredicativity prob-
lem is fatal. Sometimes we can save the simple deﬁnition by changing the
language to be predicative. However, for an impredicative language, a more
sophisticated deﬁnition is required.
The solution to the problem is Girard’s method of candidates (Girard, La-
font, and Taylor, 1989). An explanation of Girard’s method is beyond the
scope of this discussion, but informally the method works as follows: Instead
of quantifying over types, the deﬁnition of logical equivalence quantiﬁes over
possible interpretations of types called candidates. Importantly, candidates

A
Solutions to Selected Exercises
509
come equipped with their own notion of logical equivalence that can be de-
ﬁned independently (i.e., without reference to the general deﬁnition of logical
equivalence). Thus, the deﬁnition of logical equivalence may refer to arbitrary
candidates and remain well-founded.
7.4.2
Hint: First prove
⟨S1, t1⟩-→⟨S2, t2⟩⇒(∀S)(⟨S@S2, t2⟩↓⇒⟨S@S1, t1⟩↓)
by considering the diﬀerent cases for -→. Deduce the ‘if’ part of (7.7) from
this. For the ‘only if’ part, show that
{(S, t) | (∃S1, S2, v) S = S1@S2 & ⟨S2, t⟩-→
∗⟨Id, v⟩& ⟨S1, v⟩↓}
is closed under the axiom and rules in Figure 7-2 inductively deﬁning the
termination relation.
7.5.4
Solution: For property (iii), assuming R is compatible, argue by induction on
the derivation of Γ ⊢t : T that this typing judgment implies that Γ ⊢t R t :
T holds. For property (v), if R =
S
i∈I Ri with I ̸= ∅and each Ri compatible,
ﬁrst note that by (iii), R is reﬂexive since it contains at least one relation Ri.
For each of the compatibility properties in Figure 7-4 with a single hypothesis,
it is clear that R has this property because each of the Ri does. For compat-
ibility properties with multiple hypotheses, we can break them down into a
chain of single-hypothesis compatibilities and appeal to the transitivity of R
(which we are assuming). For example consider the compatibility property for
function application. It suﬃces to show that R satisﬁes
Γ ⊢v1 R v′
1 : T1→T2
Γ ⊢v2 : T1
Γ ⊢v1 v2 R v′
1 v2 : T2
(A.1)
and
Γ ⊢v1 : T1→T2
Γ ⊢v2 R v′
2 : T1
Γ ⊢v1 v2 R v1 v′
2 : T2
.
(A.2)
For then if Γ ⊢v1 R v′
1 : T1→T2 and Γ ⊢v2 R v′
2 : T1, we get
Γ ⊢v1 v2 R v′
1 v2 : T2
by (A.1), since Γ ⊢v2 : T1
Γ ⊢v′
1 v2 R v′
1 v′
2 : T2
by (A.2), since Γ ⊢v′
1 : T1→T2.
and hence Γ ⊢v1 v2 R v′
1 v′
2 : T2 by transitivity. Each of the single-hypothesis
properties (A.1) and (A.2) holds of R because they hold for each Ri: each is
a special case of the compatibility property for function application because
each Ri, being compatible, is also reﬂexive by (iii).

510
A
Solutions to Selected Exercises
7.5.10
Solution: Consider the frame stacks
S
def
= Id ◦(x.(fun f(x′:Bool) = if x′ then true else f x′)x)
ST
def
= Id ◦(x.(fun f(x′:T) = true)x)
Note that ∅⊢S : Bool ⊸Bool and ∅⊢ST : T ⊸Bool. It is not hard to see
for all ∅⊢b : Bool that
S[b] ↓iﬀ⟨Id, b⟩-→
∗⟨Id, true⟩
(A.3)
and for all ∅⊢t : T that
t ↓iﬀ⟨Id, ST[t]⟩-→
∗⟨Id, true⟩
(A.4)
From (A.3) and the fact that =ctx is a congruence (so that ∅⊢b =ctx b′ : Bool
implies ∅⊢S[b] =ctx S[b′] : Bool) it follows that =ctx is true-adequate;
hence it is contained in =true
ctx . Similarly, (A.4) and the fact that =true
ctx
is a
congruence implies that it is adequate and hence contained in =ctx.
7.6.7
Solution: Since (−)s t is inﬂationary we have r ⊆r s t; and since r only relates
values, this implies r ⊆r s t v. Then since (−)s t is monotone, we have r s t ⊆
r s t v s t. Conversely, since (r ′)v ⊆r ′ for any r ′, we have r s t v ⊆r s t; and then
since (−)s t is monotone and idempotent, r s t v s t ⊆r s t s t = r s t.
7.6.14
Hint: The proof of (7.26) is just like the proof of (7.21), using the following
property of the termination relation:
(⟨S, v.l⟩↓a ⟨S′, v′.l⟩↓) iﬀ(⟨S ◦(x.x.l), v⟩↓a ⟨S′ ◦(x.x.l), v′⟩↓).
Similarly, the proof of (7.27) follows from:
(⟨S, v T⟩↓a ⟨S′, v′ T′⟩↓) iﬀ(⟨S ◦(x.x T), v⟩↓a ⟨S′ ◦(x.x T′), v′⟩↓).
7.6.18
Solution: It suﬃces to show
(∀n = 0, 1, . . .) (Fn, F′
n) ∈fun(r1, r2)
(A.5)
where Fn and F′
n are the unwindings associated with F and F′ respectively, as
in Theorem 7.4.4. For if (A.5) holds, then using the fact that (−)s t is inﬂation-
ary
(Fn, F′
n) ∈fun(r1, r2) ⊆fun(r1, r2)s t
for each n; so by the Admissibility property in Lemma 7.6.8 we have (F, F′) ∈
fun(r1, r2)s t. Thus (F, F′) ∈fun(r1, r2)s t v = fun(r1, r2) by Lemma 7.6.13,
since (r2)s t = r2. (A.5) is proved by induction on n:

A
Solutions to Selected Exercises
511
Base case n = 0: By deﬁnition of F0, ⟨S, F0 v1⟩↓does not hold for any S ∈
Stack(T2) and v1 ∈Val(T1); similarly for F′
0. Hence for all (v1, v′
1) ∈(r1)v,
(F0 v1, F′
0 v′
1) ∈st for any s ∈SRel(T2, T′
2) and hence in particular for
s = (r2)s. So (F0 v1, F′
0 v′
1) ∈(r2)s t = r2 for all (v1, v′
1) ∈(r1)v. Therefore
(F0, F′
0) ∈fun(r1, r2).
Induction step: Suppose (Fn, F′
n) ∈fun(r1, r2). Then for any (v1, v′
1) ∈(r1)v,
from (7.29) we have
([f , Fn][x , v1]t, [f , F′
n][x , v′
1]t′) ∈r2.
By deﬁnition of Fn+1 and Corollary 7.5.8 we have ∅⊢Fn+1v1 =ctx [f ,
Fn][x , v1]t; and similarly, ∅⊢F′
n+1v′
1 =ctx [f , F′
n][x , v′
1]t′. So
since r2 is closed, we can apply the Equivalence-respecting property in
Lemma 7.6.8 to conclude that (Fn+1v1, F′
n+1v′
1) ∈r2. Since this holds for
any (v1, v′
1) ∈(r1)v, we have (Fn+1, F′
n+1) ∈fun(r1, r2).
7.6.19
Solution: To show (v, v′) ∈{li=ri
i∈1..n} we must show (v.li, v′.li) ∈ri for
each i ∈1..n. Since each ri is closed, this is equivalent to showing (v.li, v′.li) ∈
(ri)s t, i.e. that ⟨S, v.li⟩↓a ⟨S′, v′.li⟩↓holds for all (S, S′) in (ri)s. But by
deﬁnition of v, ⟨S, v.li⟩↓a ⟨S, vi⟩↓; and similarly for v′. So it suﬃces to
show ⟨S, vi⟩↓a ⟨S′, v′
i⟩; and this holds because by assumption (vi, v′
i) ∈ri
and (S, S′) ∈(ri)s.
7.6.20
Solution: To show (λX.v, λX.v′) ∈λr.R(r) we have to show for each T1, T′
1 ∈
Typ and r ∈TRel(T1, T′
1) that ((λX.v)T, (λX.v′)T′) ∈R(r) . Since each
R(r) is closed, this is equivalent to showing ((λX.v)T, (λX.v′)T′) ∈R(r)s t,
i.e. that ⟨S, (λX.v)T⟩↓a ⟨S′, (λX.v′)T′⟩↓holds for all (S, S′) ∈R(r)s. But
⟨S, (λX.v)T⟩↓a ⟨S, [X , T1]v⟩↓; and similarly for v′. So it suﬃces to show
⟨S, [X , T1]v⟩↓a ⟨S, [X , T′
1]v′⟩↓; and this holds because by assumption
([X , T1]v, [X , T1]v) ∈R(r) and (S, S′) ∈R(r)s.
7.6.21
Hint: To show (if v then t1 else t2, if v′ then t′
1 else t′
2) ∈r = (r)s t it
suﬃces to show for all (S, S′) ∈(r)s that
⟨S, if v then t1 else t2⟩↓a ⟨S′, if v′ then t′
1 else t′
2⟩↓
or equivalently that
⟨S ◦(x.if x then t1 else t2), v⟩↓a
⟨S′ ◦(x.if x then t′
1 else t′
2), v′⟩↓.
Do this by proving that
(S ◦(x.if x then t1 else t2), S′ ◦(x.if x then t′
1 else t′
2) ∈(IdBool)s.

512
A
Solutions to Selected Exercises
7.6.22
Solution: For any (S, S′) ∈(r2)s it follows from the assumptions on t, t′ and
the deﬁnition of {∃r1,R(r1)} (Figure 7-5) that
(S ◦(y.let {*X,x}=y in t), S′ ◦(y.let {*X,x}=y in t′))
is in {∃r1,R(r1)}s. Hence if (v, v′) ∈{∃r1,R(r1)}s t v ⊆({∃r1,R(r1)}s)t, then
⟨S ◦(y.let {*X,x}=y in t), v⟩↓a ⟨S′ ◦(y.let {*X,x}=y in t′), v′⟩↓
and so ⟨S, let {*X,x}=v in t⟩↓a ⟨S, let {*X,x}=v′ in t′⟩↓. Since this is
true for all (S, S′) ∈(r2)s, we deduce that
(let {*X,x}=v in t, let {*X,x}=v in t) ∈(r2)s t = r2.
7.6.23
Solution: For any (S, S′) ∈(r2)s it follows from the assumptions on t, t′
that (S ◦(x.t2), S′ ◦(x.t′
2)) ∈(r1)v s. Since ((r1)v s)t = r1, if (t1, t′
1) ∈r1 then
we get ⟨S ◦(x.t2), t1⟩↓a ⟨S′ ◦(x.t′
2), t′
1⟩↓, and hence that
⟨S, let x=t1 in t2⟩↓a ⟨S′, let x=t′
1 in t′
2⟩↓.
Since this holds for all (S, S′) ∈(r2)s, we deduce that
(let x=t1 in t2, let x=t′
1 in t′
2) ∈(r2)s t = r2.
7.7.10
Solution: Since N has no closed values, neither does {∃X,N}. On the other
hand
val v = λY.fun f(x:∀X.N→Y) = (f x):Y
is a closed value of type ∀Y.(∀X.N→Y)→Y. If i and j were to exist with
the stated properties we could use them to construct from v a closed value
of type {∃X,N}, which is impossible. (For i(j v) and v are ciu-equivalent
(Theorem 7.5.7); so since v ↓, we also have i(j v) ↓. Hence by Exercise 7.4.2,
⟨Id, j v⟩-→
∗⟨Id, v′⟩for some v′, which is a closed value of type {∃X,N}, by
Exercise 7.4.3.)
8.2.1
Solution: As of this writing, the question of how far nominal module sys-
tems can be pushed is wide open. A step in this direction was recently taken
by Odersky, Cremet, Rockl, and Zenger (2003).
8.5.3
Solution: Deﬁne m1 to be the module
module m1 = mod {
type X = Int
val c = 0
val f = succ
}

A
Solutions to Selected Exercises
513
and deﬁne m2 to be the module
module m2 = mod {
type X = Bool
val c = true
val f = not
}.
Deﬁne M to be the expression if flip() then m1 else m2, where the function
flip:unit→bool alternates between true and false on each call. Now con-
sider the term t = M.f(M.c). This is well-typed, because M.f : M.X→M.X and
M.c : M.X. But evaluation of t goes wrong by applying either succ to a value
of type Bool or not to a value of type Int.
8.5.4
Solution: In a call-by-name setting, variables may no longer be considered
determinate, because they stand for unevaluated module expressions. There-
fore we cannot “determinize” an indeterminate module expression by binding
it to a variable, with the result that there is no way to use its type components.
8.5.5
Solution: Consider the following declarations:
signature I = sig { type X
val x : X }
module m = mod { type X = Int
val x = 5 }
module n = mod { type X = Bool
val x = true }
Then the term (λx : (m:>I).X ...)((m:>I).x) is well typed, but the term
(λx : (n:>I).X ...)((m:>I).x) is not.
8.5.6
Solution: For example, we might hash the same value in the two diﬀerent
hash tables, producing two hash codes that, because they have the same type,
could be compared and (surprisingly) found to be diﬀerent. Conversely, we
could get unlucky and hash two diﬀerent values to the same hash code.
8.5.7
Solution: Consider the signature
signature INTDICT =
sig {
type T
val insert : T × Int →T
val lookup : T × Int →Bool
}
If M and N both implement INTDICT as a list of integers, but M requires that the
list be sorted while N does not, then interchanging N.lookup with M.lookup
could cause an inserted key not to be found.

514
A
Solutions to Selected Exercises
8.5.9
Solution: The signature
signature J = sig {
type X : *→*
type Y : * }
is a super-signature of I that avoids m. For each type A the signature
signature KA = sig {
type X : *→*
type Y = X(A) }
is also a super-signature of I that avoids m. But the signature J is a proper
super-signature of every signature KA, so it cannot be principal, and yet the
signatures KA and KB are incomparable whenever A and B are inequivalent
types.
For an example in System F≤, see Ghelli and Pierce (1992).
8.7.1
Solution: Because there would be no way to obtain instances of the com-
pletely abstract type (dict1:>Dict).X, and hence no way to ever put any-
thing into a dictionary.
8.7.2
Solution:
sig { CD1, ..., CDn } where m = M
=
sig { CD1 where m=M, ..., CDn where m=M }
type X where m = M
=
type X
type X = T where m = M
=
type X = T
val x : T where m = M
=
val x : T
module m : I where m = M
=
module m : (I is M)
module n : I where m = M
=
module n : I
(if m ̸= n)
sig { CD1, ..., CDn } is M
=
sig { CD1 is M, ..., CDn is M }
type X is M
=
type X = M.X
type X = T is M
=
type X = T
val x : T is M
=
val x : T
module m : I is M
=
module m : (I is M.m)
8.8.1
Solution: A functor signature is an signature describing module-level func-
tions; a family of signatures is itself a function from modules to signatures.
The body of a functor signature is a family of signatures indexed by the
functor parameter. Or, in the slogan coined by Sannella, Sokolowski, and
Tarlecki (1992), parameterized (program speciﬁcation) ̸= (parameterized pro-
gram) speciﬁcation.

A
Solutions to Selected Exercises
515
In a sense, in the case of ﬁrst-order module systems, there is no real need
for functor signatures per se, because there are no variable functors. We could
just say that a family of modules has a family of signatures, each module in-
stance determining a corresponding signature instance. But for higher-order
or separate compilation purposes we need a notation meaning “F is a functor
implementing signature I.”
8.8.2
Solution: Yes, but we need to make sure that the dictFun functor includes
its parameter as a submodule of its result:
module dictFun =
λk:ordered.
mod {
module key = k
... (as before) ...
}
signature DictFun =
Πk:Ordered.
sig {
module key = k
type Dict : *→*
val new : ∀V. Dict V
val add : ∀V. Dict V →key.X →V →Dict V
val member : ∀V. Dict V →key.X →Bool
val lookup : ∀V. Dict V →key.X →V
}
Or, more concisely, DictFun = Πm:K. (D where k = m).
8.8.4
Solution: The compose8 functor will require 9 type parameters; compose16
will require 17. Note that, in this series of examples, the part of each functor
that is doing useful work is the same size as as its predecessor, while the
amount of “nuisance parameterization” increases exponentially.
8.8.5
Solution: Let HashFun be a generative hash table functor. If, by subsump-
tion, HashFun could be regarded as applicative, then two instances would
determine the same abstract type, permitting confusion of distinct hash ta-
bles.
8.10.1
Solution: A module in our sense corresponds to a “.c” ﬁle, which con-
tains procedure and function deﬁnitions, type deﬁnitions, and declarations
of global variables. Procedures, functions, and variables may be made private
by declaring them static; otherwise they are presumed to be exported. An

516
A
Solutions to Selected Exercises
signature in our sense corresponds to a “.h” ﬁle, which contains procedure
and function headers, type deﬁnitions, and declarations of global variables.
The compiled versions of modules correspond to “.o” ﬁles, which are linked
(e.g., using the ld command in Unix) into complete executable programs.
8.10.2
Solution: A rigorous comparison of Java’s modularity features with the ones
described in this chapter is actually quite diﬃcult. Here are some observa-
tions, however.
A class in Java is a medium-scale program structuring device, and is often
a unit of abstraction, maintaining interesting invariants among its ﬁelds and
allowing access to the ﬁelds only through its own methods. In these ways, a
class is like a module. However, Java classes do not have type components.
Conversely, class instantiation (in the sense of saying new to a class to get
an object) is something that we don’t do with modules. Also, classes in Java
are not units of compilation—it is not generally possible to compile a class
separately from other classes that it refers to (e.g., because mutually recursive
references are allowed).
An object in Java is also something like a module, providing a collection
of named components; like classes, however, objects do not contain type
components1 —just methods (functions) and ﬁelds (reference cells holding
pointers to objects).
Both Java signatures and abstract classes (all of whose methods are virtual)
are something like signatures in the sense of this chapter, since they describe
the components of an object without providing implementations.
Signatures and abstract classes can be used to achieve separate compila-
tion in Java, but in a somewhat diﬀerent style from the separate compilation
discussed here. One deﬁnes an signature I, then deﬁnes one class that im-
plements I and, separately, another that expects to be given an object imple-
menting I. These two classes can be compiled separately from each other.
Java’s packages are also useful in structuring and decomposing the names-
paces of large software systems, but they do not have many of the characteris-
tics of modules in our sense: packages are not units of separate compilation,
and there is no notion of an “signature of a package.” This suggests that
packages could be turned into something more like real modules by equip-
ping them with signatures. This extension has been explored by Bauer, Appel,
and Felten (1999).
9.1.4
Solution: The premise Γ ⊢T2 :: * in T-TLet ensures that the local variable X
appears only within the scope where it is deﬁned and not in T2. Omitting the
1. . . . except in experimental extensions with virtual types (Thorup, 1997; Torgersen, 1998;
Igarashi and Pierce, 1999, etc.).

A
Solutions to Selected Exercises
517
side condition would allow not just ⊢(let X=Nat in λy:X.y+1) : Nat→Nat
but also ⊢(let X=Nat in λy:X.y+1) : X→Nat. Thus, code such as
(let X=Nat in λy:X.y+1) (let X=Nat × Nat in {5,4})
would type check because the function could be given type X→Nat and the
argument could be given type X. At run-time, however, this code would try to
increment a pair, and hence ought to be rejected.
9.1.5
Solution: If primitive deﬁnitions were added to the simply-typed lambda
calculus, we would probably want to allow type variables to appear in types
(requiring an extension of the syntax of types) and to allow type deﬁnitions to
appear in the context. In contrast to λlet, though, every type variable would
have a deﬁnition (and be of kind *, since the language lacks type operators).
These deﬁnitions would induce a context-sensitive type equivalence relation
based purely on deﬁnition expansion; thus adding the F ω rule T-Eq would be
appropriate.
Given the lack of type operators, a further extension might be to allow
parameterized type deﬁnitions with ﬁxed arity, i.e., to allow deﬁnitions such
as X(Y1,Y2) = Y1→Y2 in the context and then to allow fully-applied uses of X
such as X(Nat,Bool→Bool) to appear in types. This leads to the possibility
of ill-formed types supplying the wrong number of arguments (e.g., X by itself
or X(Nat)) and so might require a type well-formedness judgment.
9.1.8
Solution: This logical relation satisﬁes the same properties as that in Chap-
ter 6 (being a monotone partial equivalence relation and closed under weak
head-expansion), for the same reasons.
A.1
Lemma:
1. If Γ ⊢S is T :: K and Γ ′ ⊇Γ then Γ ′ ⊢S is T :: K
2. If Γ ⊢S is T :: K then Γ ⊢T is S :: K.
3. If Γ ⊢S is T :: K and Γ ⊢T is U :: K then Γ ⊢S is U :: K.
4. If Γ ⊢S is T :: K and Γ ⊢▶S′ ;∗S and Γ ⊢▶T′ ;∗T then Γ ⊢S′ is T′ :: K.
A corresponding version of the Main Lemma holds as well. It is no longer
true that all paths are weak head-normal, so we make this an explicit require-
ment in part 2:
A.2
Lemma [Main Lemma]: 1. If Γ ⊢S is T :: K then Γ ⊢▶S a T :: K.
2. If Γ ⊢▶S ↔T :: K where S and T are paths (a variable applied zero or more
times) with Γ ⊢▶S ⇓S and Γ ⊢▶T ⇓T, then Γ ⊢S is T :: K.
2

518
A
Solutions to Selected Exercises
Proof:
By simultaneous induction on K.
2
Because the deﬁnition of logical equivalence of substitutions has changed,
we need to recheck that it is an equivalence relation.
A.3
Lemma:
1. If Γ ′ ⊢γ is δ :: Γ then Γ ′ ⊢δ is γ :: Γ.
2. If Γ ′ ⊢γ is γ′ :: Γ and Γ ′ ⊢γ′ is γ′′ :: Γ then Γ ′ ⊢γ is γ′′ :: Γ.
2
Proof:
1. Follows from Lemma A.1(2).
2. Assume X::K ∈Γ. Then by Lemma A.1(3) Γ ′ ⊢γ(X) is γ′′(X) :: K just as
before.
Alternatively, assume X::K=T ∈Γ. Then among other consequences we
know that Γ ′ ⊢γ(X) is γ′(X) :: K, Γ ′ ⊢γ(T) is γ′(X) :: K, Γ ′ ⊢γ′(X) is
γ′′(X) :: K, and Γ ′ ⊢γ′(X) is γ′′(T) :: K. By Lemma A.1(2,3), then, Γ ′ ⊢
γ(X) is γ′′(X) :: K, Γ ′ ⊢γ(T) is γ′′(X) :: K and Γ ′ ⊢γ(X) is γ′′(T) :: K
as required.
2
Finally, we have the Fundamental Theorem:
A.4
Theorem [Fundamental Theorem]:
1. If Γ ⊢T :: K and Γ ′ ⊢γ is δ :: Γ then Γ ′ ⊢γ(T) is δ(T) : K.
2. If Γ ⊢S ≡T :: K and Γ ′ ⊢γ is δ :: Γ then Γ ′ ⊢γ(S) is δ(T) : K.
2
Proof:
We proceed by induction on derivations. Most of the cases are exactly
the same (modulo the transition from a lambda-calculus of terms to a lambda-
calculus of types) as the corresponding proof in Chapter 6. The cases for the
new rules Q-Def and K-Def follow directly from our assumptions for γ and
δ. The cases for K-All and Q-All are similar to each other; we sketch just the
former.
Case Q-All: Γ ⊢∀X::K1.T2 :: * because Γ, X::K1 ⊢T2 :: *.
Using the Main Lemma we have that Γ ′, X::K1 ⊢γ[X,X] is δ[X,X] : Γ, X::K1.
By the inductive hypothesis we have Γ ′, X::K1 ⊢(γ[X,X])T2 is (δ[X,X])T2 :
*. By the Main Lemma, Γ ′, X::K1 ⊢(γ[X,X])T2 a (δ[X,X])T2 : *. Thus Γ ′ ⊢
γ(∀X::K1.T2) ↔δ(∀X::K1.T2) : *. Universally-quantiﬁed types are weak
head normal, so by the Main Lemma one last time, Γ ′ ⊢γ(∀X::K1.T2) is
δ(∀X::K1.T2) : *.
2

A
Solutions to Selected Exercises
519
Because the deﬁnition for logical equivalence of substitutions has become
more involved, the fact that the identity substitution is logically related to
itself is no longer an immediate corollary of the Main Lemma.
A.5
Lemma: Let γ be the identity substitution. If Γ ⊢⋄then Γ ⊢γ is γ :: Γ.
2
Proof:
By induction on the proof of Γ ⊢⋄.
Case CTX-Type: Γ = Γ ′, x:T with Γ ′ ⊢⋄.
By the inductive hypothesis.
Case CTX-Kind: Γ = Γ ′, X::K with Γ ′ ⊢⋄.
By the inductive hypothesis we have that Γ ′ ⊢γ is γ :: Γ ′. By monotonicity,
Γ ⊢γ is γ :: Γ ′. Finally, by the Main Lemma we have Γ ⊢X is X :: K, so
Γ ⊢γ is γ :: Γ.
Case CTX-Def: Γ = Γ ′, X::K=T with Γ ′ ⊢T :: K.
By the inductive hypothesis and monotonicity we again have Γ ⊢γ is γ :: Γ ′.
By the Fundamental Theorem, Γ ⊢T is T :: K. By weak head expansion,
then, Γ ⊢X is T :: K, Γ ⊢T is X :: K, and Γ ⊢X is X :: K. Therefore,
Γ ⊢γ is γ :: Γ.
2
A.6
Corollary [Completeness]: If Γ ⊢S :: K and Γ ⊢T :: K and Γ ⊢S ≡T :: K
then Γ ⊢▶S a T :: K.
2
Proof:
Apply the Fundamental Theorem with the identity substitution.
2
A.7
Corollary [Termination]: If Γ ⊢S :: K and Γ ⊢T :: K then Γ ⊢▶S a T ::
K is decidable (i.e., deterministic proof search must always terminate with
success or failure).
2
Proof:
By completeness we know that Γ ⊢▶S a S :: K and that Γ ⊢▶T a T ::
K. We can show by induction on the former algorithm that the comparison of
S and T must terminate.
2
9.1.9
Solution: As one example, the equivalence
X :: (*⇒*⇒*) = (λY::(*⇒*). Y Nat) ⊢X(λZ::*.Z) ≡X(λZ::*.Nat)
is provable, because both sides are provably equivalent to Nat. However,
given the same deﬁnition for X we have X(λZ::*.Nat) ̸≡X(λZ::*.Bool).
Pfenning and Schürmann (1998) give a syntactic criterion for detecting a
collection of injective type operators that yield equivalent results only when
given equivalent arguments, and hence can be treated specially by an imple-
mentation.

520
A
Solutions to Selected Exercises
9.2.1
Solution: An equivalent most-precise interface would be
Πm:(Σm’:L*M. L!m’M).
(Σm”:L*=!m.1 × !m.1M. L!m.1 × !m.1M),
which is a subinterface of inﬁnitely many interfaces, including
Πm:(Σm’:L*M. L!m’M). (Σm”:L*M. L!m”M)
and
Πm:(Σm’:L*=NatM. LNatM). (Σm”:L*=Nat× NatM. LNat × NatM).
9.2.2
Solution: If Nat <: Top then we could allow LNatM <: LTopM in analogy with
depth subtyping for records. In contrast, the interfaces L*=NatM and L*=TopM
must be unrelated, because a module containing the type Nat is not a module
containing the type Top nor vice versa. To see what goes wrong, assume that
L*=NatM <: L*=TopM and let M be the module LNatM. Then M : L*=NatM, which
by subsumption would further yield M : L*=TopM. At this point, we could then
show that !M ≡Nat and !M ≡Top and hence that Nat ≡Top.
9.2.3
Solution: The module deﬁned by
(λm : Σm:L*M.L!mM). L L λX::*.(!m.1)::*⇒*M, !m.2 M
(L LNat::*M, L3::NatM M :> Σm:L*M.L!mM)
or, using syntactic sugar,
let m = L LNat::*M, L3::NatM M :> Σm:L*M.L!mM
in
L L λX::*.(!m.1)::*⇒*M, !m.2 M
satisﬁes the interface Σm′:L*⇒*M. L(!m′)(Nat)M and more generally the in-
terface Σm′:L*⇒*M. L(!m′)(T)M for any type T, but it satisﬁes no interface
that is a subinterface of all of these.
9.3.1
Solution: If Nat <: Top then we should expect S(Nat) and S(Top) to be
kinds unrelated in the subkinding hierarchy. All types of kind S(Nat) are
provably equivalent to Nat, and hence should not be provably equivalent to
Top. See also Exercise A.
9.3.7
Solution: We again proceed by induction on the size of K. Assume Γ ⊢S ::
S(T :: K) and Γ ⊢T :: K.
Case: K = *, so S(T::K) = S(T).
Then Γ ⊢S ≡T :: S(T) by Rule Q-SElim, and Γ ⊢S(T) <: * by SK-Forget, so
Γ ⊢S ≡T :: * by Rule Q-Sub.

A
Solutions to Selected Exercises
521
Case: K = S(U), so S(T::K) = S(T).
By Rule Q-SElim we have Γ ⊢S ≡T :: S(S). By Proposition 9.3.4(5), inversion
of K-Sing, and SK-Forget we have Γ ⊢S(S) <: *, so Γ ⊢S ≡T :: * by
Q-Sub. Since Γ ⊢T :: S(U), by similar arguments we have Γ ⊢T ≡U :: *
and so Γ ⊢S ≡U :: * and Γ ⊢S(S) <: S(U). Therefore by Q-Sub we have
Γ ⊢S ≡T :: S(U) as required.
Case: K = ΠX::K1.K2, so S(T::K) = ΠX::K1.S(T X :: K2).
By Proposition 9.3.4(5) and inversion we have Γ, X::K1 ⊢⋄, so by Proposi-
tion 9.3.2(1) and K-App, Γ, X::K1 ⊢S X :: S(T X :: K2). By the same reasoning
we have Γ, X::K1 ⊢T X :: K2. By the inductive hypothesis, Γ, X::K1 ⊢S X ≡
T X :: K2. Therefore, by Rule Q-Ext we have Γ ⊢S ≡T :: ΠX::K1.K2.
Case: K = ΣX::K1.K2, so S(T::K) = S(π1 T :: K1) × S(π2 T :: [X , π1 T]K2)
By K-Fst and K-Snd we have Γ ⊢π1 S :: S(π1 T :: K1) and Γ ⊢π2 S ::
S(π2 T :: [X , π1 T]K2). Again by K-Fst and K-Snd we have Γ ⊢π1 T :: K1
and Γ ⊢π 2 T :: [X , π1 T]K2, so by the inductive hypothesis we have we
have Γ ⊢π1 S ≡π1 T :: K1 and and Γ ⊢π1 S ≡π2 T :: [X , π 1 T]K2). By
Rule Q-Pair-Ext, therefore, we have Γ ⊢S ≡T :: ΣX::K1.K2 as desired.
By the deﬁnitions in Figure 9-9 it is possible for S(T::K) to be a well-
formed kind even if T does not satisfy kind K; for example, take T = Nat and
K = S(Nat→Nat). Then we have Γ ⊢Nat :: S(Nat::S(Nat→Nat)) but not
Γ ⊢Nat ≡Nat :: S(Nat→Nat).
9.3.8
Solution: Using the properties of Fact 9.3.6, we can show the admissibility
of Q-Beta-Fst.
Γ ⊢T1 :: K1
Γ ⊢T1 :: S(T1 :: K1) Γ ⊢T2 :: S(T1 :: K2)
Γ ⊢{T1,T2} :: S(T1 :: K1) × K2
Γ ⊢π1 {T1,T2} :: S(T1 :: K1)
Γ ⊢π1 {T1,T2} ≡T1 :: K1
The proof for Q-Beta-Snd is exactly analogous, and a similar idea works for
Q-AppAbs:
Γ, X::K11 ⊢T12 :: K12
Γ, X::K11 ⊢T12 :: S(T12 :: K12)
Γ ⊢(λX::K11.T12) :: (ΠX::K11.S(T12 :: K12)) Γ ⊢T2 :: K12
Γ ⊢(λX::K11.T12)T2 :: S([X , T2]T12 :: [X , T2]K12)
Γ ⊢(λX::K11.T12)T2 ≡[X , T2]T12 :: [X , T2]K12

522
A
Solutions to Selected Exercises
9.3.9
Solution: Let Γ1
def
= Y::(S(Nat)⇒*)⇒*. Then
Y::(S(Nat)⇒*)⇒* ⊢▶Y(λX::*.X) a Y(λX::*.Nat) :: *
because
• Γ1 ⊢▶Y(λX::*.X) ⇓Y(λX::*.X)
• Γ1 ⊢▶Y(λX::*.Nat) ⇓Y(λX::*.Nat)
• Γ1 ⊢▶Y(λX::*.X) ↔Y(λX::*.X) ↑*, because
–
Γ1 ⊢▶Y ↔Y ↑(S(Nat)⇒*)⇒*, and
–
Γ1 ⊢▶λX::*.X a λX::*.Nat : S(Nat)⇒*, because
∗Γ1, Z::S(Nat) ⊢▶(λX::*.X)Z a (λX::*.Nat)Z :: *, because
·
Γ1, Z::S(Nat) ⊢▶(λX::*.X)Z ⇓Nat
·
Γ1, Z::S(Nat) ⊢▶(λX::*.Nat)Z ⇓Nat
·
Γ1, Z::S(Nat) ⊢▶Nat ↔Nat ↑*.
The analogous proof for Y::(*⇒*)⇒* ⊢▶Y(λX::*.X) a Y(λX::*.Nat) ::
* fails because it requires proving Y::(*⇒*)⇒*, Z::*
⊢▶
(λX::*.X)Z a
(λX::*.Nat)Z :: * and hence that Y::(*⇒*)⇒*, Z::* ⊢▶Z ↔Nat ↑*.
9.3.11
Solution: The compile-time part is
λXm::* × K0. {(π1 Xm) × (π1 Xm), S0}
and the run-time part is
λXm::* × K0. λxm:T0 × (π1 Xm). {t0, {xm.2, xm.2}}.
These perform the same computations as the intuitive phase-splittings, but
take some useless arguments (e.g., the second argument of the type pair Xm
and the ﬁrst argument of the pair xm) and return some useless results (S0
and t0).
9.3.14
Solution:
1. Terms containing local modules can be translated as
|let m=M in t|
:=
let Xm = |M|c in
let xm = |M|r in
|t|.
Both let forms can be expressed as derived forms in λS, or one could
extend the language to make them primitive.

A
Solutions to Selected Exercises
523
2. Adding a conditional module expression destroys the phase distinction,
because the types in a conditional module, e.g.
if ... then LNat::*M else LUnit::*M,
depends on the run-time value of the test.
10.1.22
Solution: Within Damas and Milner’s type system, we have:
dm-Let
dm-Var
z1 : X ⊢z1 : X
z1 : X; z2 : X ⊢z2 : X
dm-Var
dm-Abs
z1 : X ⊢let z2 = z1 in z2 : X
 ⊢λz1.let z2 = z1 in z2 : X →X
Note that, because X occurs free within the environment z1 : X, it is impossible
to apply dm-Gen to the judgment z1 : X ⊢z1 : X in a nontrivial way. For this
reason, z2 cannot receive the type scheme ∀X.X, and the whole expression
cannot receive type X →Y, where X and Y are distinct.
10.1.23
Solution: It is straightforward to prove that the identity function has type
int →int:
Γ0; z : int ⊢z : int
dm-Var
Γ0 ⊢λz.z : int →int
dm-Abs
In fact, nothing in this type derivation depends on the choice of int as the type
of z. Thus, we may just as well use a type variable X instead. Furthermore,
after forming the arrow type X →X, we may employ dm-Gen to quantify
universally over X, since X no longer appears in the environment.
dm-Gen
dm-Abs
dm-Var
Γ0; z : X ⊢z : X
Γ0 ⊢λz.z : X →X
X ̸∈ftv(Γ0)
Γ0 ⊢λz.z : ∀X.X →X
It is worth noting that, although the type derivation employs an arbitrary
type variable X, the ﬁnal typing judgment has no free type variables. It is thus
independent of the choice of X. In the following, we refer to the above type
derivation as ∆0.
Next, we prove that the successor function has type int →int under the
initial environment Γ0. We write Γ1 for Γ0; z : int, and make uses of dm-Var
implicit.
dm-App
dm-App
Γ1 ⊢ˆ+ : int →int →int
Γ1 ⊢z : int
Γ1 ⊢ˆ+ z : int →int
Γ1 ⊢ˆ1 : int
dm-Abs
Γ1 ⊢z ˆ+ ˆ1 : int
Γ0 ⊢λz.z ˆ+ ˆ1 : int →int

524
A
Solutions to Selected Exercises
In the following, we refer to the above type derivation as ∆1. We may now
build a derivation for the third typing judgment. We write Γ2 for Γ0; f : int →
int.
∆1
Γ2 ⊢f : int →int
Γ2 ⊢ˆ2 : int
Γ2 ⊢f ˆ2 : int
dm-App
Γ0 ⊢let f = λz.z ˆ+ ˆ1 in f ˆ2 : int
dm-Let
To derive the fourth typing judgment, we re-use ∆0, which proves that the
identity function has polymorphic type ∀X.X →X. We write Γ3 for Γ0; f :
∀X.X →X. By dm-Var and dm-Inst, we have both Γ3 ⊢f : (int →int) →
(int →int) and Γ3 ⊢f : int →int. Thus, we may build the following derivation:
∆0
dm-App
dm-App
Γ3 ⊢f : (int →int) →(int →int)
Γ3 ⊢f : int →int
Γ3 ⊢f f : int →int
Γ3 ⊢ˆ2 : int
Γ3 ⊢f f ˆ2 : int
Γ0 ⊢let f = λz.z in f f ˆ2 : int
dm-Let
The ﬁrst and third judgments are valid in the simply-typed λ-calculus, be-
cause they use neither dm-Gen nor dm-Inst, and use dm-Let only to introduce
the monomorphic binding f : int →int into the environment. The second judg-
ment, of course, is not: because it involves a nontrivial type scheme, it is not
even a well-formed judgment in the simply-typed λ-calculus. The fourth judg-
ment is well-formed, but not derivable, in the simply-typed λ-calculus. This is
because f is used at two incompatible types, namely (int →int) →(int →int)
and int →int, inside the expression f f ˆ2. Both of these types are instances of
∀X.X →X, the type scheme assigned to f in the environment Γ3.
By inspection of the rules, a derivation of Γ0 ⊢ˆ1 : T must begin with an
instance of dm-Var, of the form Γ0 ⊢ˆ1 : int. It may be followed by an arbitrary
number of instances of the sequence (dm-Gen; dm-Inst), turning int into a
type scheme of the form ∀¯X.int, then back to int. Thus, T must be int. Because
int is not an arrow type, there follows that the application ˆ1 ˆ2 cannot be
well-typed under Γ0. In fact, because this expression is stuck, it cannot be
well-typed in a sound type system.
The expression λf.(f f) is ill-typed in the simply-typed λ-calculus, because
no type T may coincide with a type of the form T →T′: indeed, T would be
a subterm of itself. In DM, this expression is ill-typed as well, but the proof
of this fact is slightly more complex. One must point out that, because f
is λ-bound, it must be assigned a type T (as opposed to a type scheme) in
the environment. Furthermore, one must note that dm-Gen is not applicable
(except in a trivial way) to the judgment Γ0; f : T ⊢f : T, because all of the

A
Solutions to Selected Exercises
525
type variables in the type T appear free in the environment Γ0; f : T. Once these
points are made, the proof is the same as in the simply-typed λ-calculus.
It is important to note that the above argument crucially relies on the fact
that f is λ-bound and must be assigned a type, as opposed to a type scheme.
Indeed, we have proved earlier in this exercise that the self-application f f is
well-typed when f is let-bound and is assigned the type scheme ∀X.X →X.
For the same reason, λf.(f f) is well-typed in an implicitly-typed variant of
System F. It also relies on the fact that types are ﬁnite: indeed, λf.(f f) is well-
typed in an extension of the simply-typed λ-calculus with recursive types,
where the equation T = T →T′ has a solution.
Later, we will develop a type inference algorithm for ML-the-type-system
and prove that it is correct and complete. Then, to prove that a term is ill-
typed, it will be suﬃcient to simulate a run of the algorithm and to check
that it reports a failure.
10.3.2
Solution: Our hypotheses are C, Γ ⊢t : ∀¯X[D].T (1) and C ð [⃗X , ⃗T]D (2).
We may also assume, w.l.o.g., ¯X # ftv(C, Γ, ⃗T) (3). By hmx-Inst and (1), we have
C ∧D, Γ ⊢t : T, which by Lemma 10.3.1 yields C ∧D∧⃗X = ⃗T, Γ ⊢t : T (4). Now,
we claim that ⃗X = ⃗T ð T ≤[⃗X , ⃗T]T (5) holds; the proof appears in the next
paragraph. Applying hmx-Sub to (4) and to (5), we obtain C ∧D ∧⃗X = ⃗T, Γ ⊢
t : [⃗X , ⃗T]T (6). By C-Eq and by (2), we have C ∧⃗X = ⃗T ð D, so (6) may be
written C ∧⃗X = ⃗T, Γ ⊢t : [⃗X , ⃗T]T (7). Last, (3) implies ¯X # ftv(Γ, [⃗X , ⃗T]T) (8).
Applying rule hmx-Exists to (7) and (8), we get ∃¯X.(C ∧⃗X = ⃗T), Γ ⊢t : [⃗X ,
⃗T]T (9). By C-NameEq and by (3), ∃¯X.(C ∧⃗X = ⃗T) is equivalent to C, hence (9)
is the goal C, Γ ⊢t : [⃗X , ⃗T]T.
There now remains to establish (5). One possible proof method is to unfold
the deﬁnition of ð and reason by structural induction on T. Here is another,
axiomatic approach. Let Z be fresh for T, ⃗X, and ⃗T. By reﬂexivity of subtyping
and by C-ExTrans, we have true ≡T ≤T ≡∃Z.(T ≤Z ∧Z ≤T), which by
congruence of ≡and by C-ExAnd implies ⃗X = ⃗T ≡∃Z.(T ≤Z ∧⃗X = ⃗T ∧Z ≤
T) (10). Furthermore, by C-Eq, we have (⃗X = ⃗T ∧Z ≤T) ≡(⃗X = ⃗T ∧Z ≤[⃗X ,
⃗T]T) ð (Z ≤[⃗X , ⃗T]T) (11). Combining (10) and (11) yields ⃗X = ⃗T ð ∃Z.(T ≤
Z ∧Z ≤[⃗X , ⃗T]T), which by C-ExTrans may be read ⃗X = ⃗T ð T ≤[⃗X , ⃗T]T.
10.3.3
Solution: The simplest possible derivation of true,  ⊢λz.z : int →int is
syntax-directed. It closely resembles the Damas-Milner derivation given in
Exercise 10.1.23.
true, z : int ⊢z : int
hmx-Var
true,  ⊢λz.z : int →int
hmx-Abs
As in Exercise 10.1.23, we may use a type variable X instead of the type int,

526
A
Solutions to Selected Exercises
then employ hmx-Gen to quantify universally over X.
true, z : X ⊢z : X
hmx-Var
true,  ⊢λz.z : X →X
hmx-Abs
X # ftv(true, )
true,  ⊢λz.z : ∀X[true].X →X
hmx-Gen
The validity of this instance of hmx-Gen relies on the equivalence true∧true ≡
true and on the fact that judgments are identiﬁed up to equivalence of their
constraint assumptions.
If we now wish to instantiate X with int, we may use hmx-Inst’ as follows:
true,  ⊢λz.z : ∀X[true].X →X
true ð [X , int]true
true,  ⊢λz.z : int →int
hmx-Inst’
This is not, strictly speaking, an HM(X) derivation, since hmx-Inst’ is not
part of the rules of Figure 10-7. However, since the proof of Lemma 10.3.1
and the solution of Exercise 10.3.2 are constructive, it is possible to exhibit
the HM(X) derivation that underlies it. We ﬁnd:
Y = int, z : X ⊢z : X
hmx-Var
Y = int,  ⊢λz.z : X →X
hmx-Abs
Y = int,  ⊢λz.z : ∀X.X →X
hmx-Gen
Y = int,  ⊢λz.z : Y →Y
hmx-Inst
Y = int ð Y →Y ≤int →int
Y = int,  ⊢λz.z : int →int
hmx-Sub
∃Y.(Y = int),  ⊢λz.z : int →int
hmx-Exists
Since ∃Y.(Y = int) is equivalent to true, the conclusion is indeed the desired
judgment.
10.4.1
Solution: Let X ̸∈ftv(Γ) (1). Assume that there exist a satisﬁable constraint
C and a type T such that C, Γ ⊢t : T (2) holds. Thanks to (1), we ﬁnd that,
up to a renaming of C and T, we may further assume X ̸∈ftv(C, T) (3). Then,
applying Lemma 10.3.1 to (2), we obtain C ∧T = X, Γ ⊢t : T, which by hmx-
Sub yields C ∧T = X, Γ ⊢t : X (4). Furthermore, by (3) and C-NameEq, we have
∃X.(C ∧T = X) ≡C. Because C is satisﬁable, this implies that C ∧T = X is
satisﬁable as well. As a result, we have found a satisﬁable constraint C′ such
that C′, Γ ⊢t : X holds.
Now, assume Γ is closed and X is arbitrary. Then, (1) holds, so the previous
paragraph proves that, if t is well-typed within Γ, then there exists a satisﬁ-
able constraint C′ such that C′, Γ ⊢t : X holds. By the completeness property,

A
Solutions to Selected Exercises
527
we must then have C′ ð JΓ ⊢t : XK. Since C′ is satisﬁable, this implies that
JΓ ⊢t : XK is satisﬁable as well. Conversely, if JΓ ⊢t : XK is satisﬁable, then,
by the soundness property, t is well-typed within Γ.
10.7.1
Solution: We have
let Γ0 in Jc t1 . . . tn : T′K
≡
let Γ0 in ∃Z1 . . . Zn.(
Vn
i=1Jti : ZiK ∧c ⪯Z1 →. . . →Zn →T′)
(1)
≡
let Γ0 in ∃Z1 . . . Zn¯X.(
Vn
i=1Jti : ZiK
∧T1 →. . . →Tn →T ≤Z1 →. . . →Zn →T′)
(2)
≡
let Γ0 in ∃¯X.(
Vn
i=1Jti : TiK ∧T ≤T′)
(3)
where (1) is by deﬁnition of constraint generation; (2) is by C-InId; (3) is by
C-Arrow, C-ExAnd, and by Lemma 10.4.6.
10.7.2
Solution: We must ﬁrst ensure that R-Add respects ⊑(Deﬁnition 10.5.4).
Since the rule is pure, it is suﬃcient to establish that let Γ0 in Jˆn1 ˆ+ ˆn2 : TK
entails let Γ0 in J \
n1 + n2 : TK. In fact, we have
let Γ0 in Jˆn1 ˆ+ ˆn2 : TK
≡
let Γ0 in (Jˆn1 : intK ∧Jˆn2 : intK ∧int ≤T)
(1)
≡
let Γ0 in (int ≤int ∧int ≤int ∧int ≤T)
(2)
≡
int ≤T
(3)
≡
let Γ0 in J \
n1 + n2 : TK
(4)
where (1) and (2) are by Exercise 10.7.1; (3) is by C-In* and by reﬂexivity of
subtyping; (4) is by Exercise 10.7.1 again.
Second, we must check that if the conﬁguration c v1 . . . vk/µ (where k ≥0)
is well-typed, then either it is reducible, or c v1 . . . vk is a value.
We begin by checking that every value that is well-typed with type int is of
the form ˆn. Indeed, suppose that let Γ0; ref M in Jv : intK is satisﬁable. Then, v
cannot be a program variable, for a well-typed value must be closed. v cannot
be a memory location m, for otherwise ref M(m) ≤int would be satisﬁable—
but the type constructors ref and int are incompatible. v cannot be ˆ+ or ˆ+ v′,
for otherwise int →int →int ≤int or int →int ≤int would be satisﬁable—but
the type constructors →and int are incompatible. Similarly, v cannot be a
λ-abstraction. Thus, v must be of the form ˆn, for it is the only case left.
Next, we note that, according to the constraint generation rules, if the
conﬁguration c v1
. . . vk/µ is well-typed, then a constraint of the form
let Γ0; ref M in (c ⪯X1 →. . . →Xk →T ∧Jv1 : X1K ∧. . . ∧Jvk : XkK) is satisﬁable.
We now reason by cases on c.
◦Case c is ˆn. Then, Γ0(c) is int. Because the type constructors int and →
are incompatible with each other, this implies k = 0. Since ˆn is a constructor,
the expression is a value.

528
A
Solutions to Selected Exercises
◦Case c is ˆ+. We may assume k ≥2, because otherwise the expression is
a value. Then, Γ0(c) is int →int →int, so, by C-Arrow, the above constraint
entails let Γ0; ref M in (X1 ≤int ∧X2 ≤int ∧Jv1 : X1K ∧Jv2 : X2K), which, by
Lemma 10.4.5, entails let Γ0; ref M in (Jv1 : intK ∧Jv2 : intK). Thus, v1 and
v2 are well-typed with type int. By the remark above, they must be integer
literals ˆn1 and ˆn2. As a result, the conﬁguration is reducible by R-Add.
10.7.5
Solution: We must ﬁrst ensure that R-Ref, R-Deref and R-Assign respect ⊑
(Deﬁnition 10.5.4).
◦Case R-Ref. The reduction is ref v/ -→m/(m , v), where m ̸∈fpi(v) (1).
Let T be an arbitrary type. According to Deﬁnition 10.5.4, the goal is to show
that there exist a set of type variables ¯Y and a store type M′ such that
¯Y # ftv(T) and ftv(M′) ⊆¯Y and dom(M′) = {m} and let Γ0 in Jref v : TK
entails ∃¯Y.let Γ0; ref M′ in Jm/(m , v) : T/M′K. Now, we have
let Γ0 in Jref v : TK
≡
∃Y.let Γ0 in (ref Y ≤T ∧Jv : YK)
(2)
≡
∃Y.let Γ0; ref M′ in (m ⪯T ∧Jv : M′(m)K)
(3)
≡
∃Y.let Γ0; ref M′ in Jm/(m , v) : T/M′K
(4)
where (2) is by Exercise 10.7.1 and by C-InEx; (3) assumes M′ is deﬁned as
m , Y, and follows from (1), C-InId and C-In*; and (4) is by deﬁnition of
constraint generation.
◦Case R-Deref. The reduction is !m/(m , v) -→v/(m , v). Let T be an
arbitrary type and let M be a store type of domain {m}. We have
let Γ0; ref M in J!m/(m , v) : T/MK
≡
let Γ0; ref M in ∃Y.(ref M(m) ≤ref Y ∧Y ≤T ∧Jv : M(m)K)
(1)
≡
let Γ0; ref M in ∃Y.(M(m) = Y ∧Y ≤T ∧Jv : M(m)K)
(2)
≡
let Γ0; ref M in (M(m) ≤T ∧Jv : M(m)K)
(3)
ð
let Γ0; ref M in (Jv : TK ∧Jv : M(m)K)
(4)
≡
let Γ0; ref M in Jv/(m , v) : T/MK
(5)
where (1) is by Exercise 10.7.1 and by C-InId; (2) follows from C-ExTrans and
from the fact that ref is an invariant type constructor; (3) is by C-NameEq;
(4) is by Lemma 10.4.5 and C-Dup; and (5) is again by deﬁnition of constraint
generation.
◦Case R-Assign. The reduction is m := v/(m , v0) -→v/(m , v). Let T

A
Solutions to Selected Exercises
529
be an arbitrary type and let M be a store type of domain {m}. We have
let Γ0; ref M in Jm := v/(m , v0) : T/MK
ð
let Γ0; ref M in Jm := v : TK
(1)
≡
let Γ0; ref M in ∃Z.(ref M(m) ≤ref Z ∧Jv : ZK ∧Z ≤T)
(2)
≡
let Γ0; ref M in ∃Z.(M(m) = Z ∧Z ≤T ∧Jv : ZK)
(3)
≡
let Γ0; ref M in (M(m) ≤T ∧Jv : M(m)K)
(4)
ð
let Γ0; ref M in Jv/(m , v) : T/MK
(5)
where (1) is by deﬁnition of constraint generation; (2) is by Exercise 10.7.1
and C-InId; (3) follows from the fact that ref is an invariant type constructor;
(4) is by C-NameEq; and (5) is obtained as in the previous case.
Second, we must check that if the conﬁguration c v1 . . . vk/µ (where k ≥0)
is well-typed, then either it is reducible, or c v1 . . . vk is a value. We only
give a sketch of this proof; see the solution to Exercise 10.7.2 for details of a
similar proof.
We begin by checking that every value that is well-typed with a type of the
form ref T is a memory location. This assertion relies on the fact that the type
constructor ref is isolated.
Next, we note that, according to the constraint generation rules, if the
conﬁguration c v1
. . . vk/µ is well-typed, then a constraint of the form
let Γ0; ref M in (c ⪯X1 →. . . →Xk →T ∧Jv1 : X1K ∧. . . ∧Jvk : XkK) is satisﬁable.
We now reason by cases on c.
◦Case c is ref. If k = 0, then the expression is a value; otherwise, it is
reducible by R-Ref.
◦Case c is !. We may assume k ≥1; otherwise the expression is a value.
By deﬁnition of Γ0(!), the above constraint entails let Γ0; ref M in ∃Y.(ref Y →
Y ≤X1 →. . . →Xk →T ∧Jv1 : X1K), which, by C-Arrow, Lemma 10.4.5, and
C-InEx, entails ∃Y.let Γ0; ref M in Jv1 : ref YK. Thus, v1 is well-typed with a
type of the form ref Y. By the remark above, v1 must be a memory location
m. Furthermore, because every well-typed conﬁguration is closed, m must
be a member of dom(µ). As a result, the conﬁguration ref
v1 . . . vk/µ is
reducible by R-Deref.
◦Case c is :=. We may assume k ≥2, because otherwise the expression is a
value. As above, we check that v1 must be a memory location and a member
of dom(µ). Thus, the conﬁguration is reducible by R-Assign.
10.8.2
Solution: The record access operation ·.⟨ℓb⟩may be given the type scheme
∀Xb.{ℓb : Xb} →Xb. However, this type scheme isn’t satisfactory, because it
allows accessing ℓb only in records where ℓa and ℓc are undeﬁned. The type
scheme ∀XaXb.{ℓa : Xa; ℓb : Xb} →Xb is also a valid type scheme for ·.⟨ℓb⟩,

530
A
Solutions to Selected Exercises
but allows accessing ℓb only in records where ℓa is deﬁned and ℓc is not. To
sum up, a satisfactory description of ·.⟨ℓb⟩requires a whole family of type
schemes, none of which is principal (more general than the others). A similar
problem arises with record extension ⟨· with ℓb = ·⟩.
A potential solution is to equip record types with a subtyping relationship,
so that (say) both {ℓa : Ta; ℓb : Tb} and {ℓa : Ta; ℓb : Tb; ℓc : Tc} are subtypes
of {ℓb : Tb}. Then, ∀Xb.{ℓb : Xb} →Xb becomes a satisfactory type scheme for
the record access operation ·.⟨ℓb⟩. Indeed, the operation is now applicable
to any record that admits a type of the form {ℓb : Tb}, that is, thanks to
subtyping, to any record where ℓb is deﬁned, regardless of which other ﬁelds
are deﬁned.
However, this is only half a solution, because there still is a problem with
record extension. The type scheme ∀Xb.{ℓb : Xb} →{ℓb : Xb} is valid, and
makes record extension applicable to any record where ℓb is deﬁned, which
is good. The trouble is with its return type: it states that only ℓb may be
safely assumed to be deﬁned in the new record. In other words, it causes
static information about all ﬁelds other than ℓb to be lost. Addressing this
dramatic loss of precision is one of the key motivations for introducing rows.
10.8.5
Solution: We let the reader check that X must have kind ⋆.Type and Y must
have kind ⋆.Row({ℓ}). The type with all superscripts made explicit is
X →Type Π (ℓ⋆,Row() : intType ; (Y →Row({ℓ}) ∂⋆,Row({ℓ})X)).
In this case, because the type constructor Π occurs on the right-hand side
of the toplevel arrow, it is possible to guess that the type must have kind
⋆.Type. There are cases where it is not possible to guess the kind of a type,
because it may have several kinds; consider, for instance, ∂int.
10.8.27
Solution: For the sake of generality, we perform the proof in the presence of
subtyping, that is, we do not assume that subtyping is interpreted as equality.
We formulate some hypotheses about the interpretation of subtyping: the
type constructors (ℓ: · ; ·), ∂, and Π must be covariant; the type constructors
→and Π must be isolated.
We begin with a preliminary fact: if the domain of V is {ℓ1, . . . , ℓn}, where
ℓ1 < . . . < ℓn, then the constraint let Γ0 in J{V; v} : TK is equivalent to
let Γ0 in ∃Z1 . . . ZnZ.(
Vn
i=1JV(ℓi) : ZiK ∧Jv : ZK ∧Π (ℓ1 : Z1; . . . ; ℓn : Zn; ∂Z) ≤T).
We let the reader check this fact using the constraint generation rules, the
deﬁnition of Γ0 and rule C-InId, and the above covariance hypotheses. We
note that, by C-Row-LL, the above constraint is invariant under a permuta-
tion of the labels ℓ1, . . . , ℓn, so the above fact still holds when the hypothesis
ℓ1 < . . . < ℓn is removed.

A
Solutions to Selected Exercises
531
We now prove that rules R-Update, R-Access-1, and R-Access-2 enjoy sub-
ject reduction (Deﬁnition 10.5.4). Because the store is not involved, the goal
is to establish that let Γ0 in Jt : TK entails let Γ0 in Jt′ : TK, where t is the redex
and t′ is the reduct.
◦Case R-Update. We have:
let Γ0 in J{{V; v} with ℓ= v′} : TK
≡
let Γ0 in ∃XX′Y.(J{V; v} : Π (ℓ: X ; Y)K ∧Jv′ : X′K ∧Π (ℓ: X′ ; Y) ≤T)
(1)
≡
let Γ0 in ∃XX′YZ1 . . . ZnZ.(
Vn
i=1JV(ℓi) : ZiK ∧Jv : ZK
∧Π (ℓ1 : Z1; . . . ; ℓn : Zn; ∂Z) ≤Π (ℓ: X ; Y)
∧Jv′ : X′K ∧Π (ℓ: X′ ; Y) ≤T)
(2)
where (1) is by Exercise 10.7.1, and (2) follows from the preliminary fact and
from C-ExAnd, provided {ℓ1, . . . , ℓn} is the domain of V. We now distinguish
two subcases:
Subcase ℓ∈dom(V). We may assume, w.l.o.g., that ℓis ℓ1. Then, by our
covariance hypotheses, the subconstraint in the second line of (2) entails
(ℓ2 : Z2; . . . ; ℓn : Zn; ∂Z) ≤Y, which in turn entails Π (ℓ1 : X′; ℓ2 : Z2; . . . ; ℓn :
Zn; ∂Z) ≤Π (ℓ: X′ ; Y). By transitivity of subtyping, the subconstraint in the
second and third lines of (2) entails Π (ℓ1 : X′; ℓ2 : Z2; . . . ; ℓn : Zn; ∂Z) ≤T. By
this remark and by C-Ex*, (2) entails
let Γ0 in ∃X′Z2 . . . ZnZ.(Jv′ : X′K ∧
Vn
i=2JV(ℓi) : ZiK ∧Jv : ZK
∧Π (ℓ1 : X′; ℓ2 : Z2; . . . ; ℓn : Zn; ∂Z) ≤T)
(3)
which by our preliminary fact is precisely let Γ0 in J{V[ℓ, v′]; v} : TK.
Subcase ℓ∉dom(V). By C-Row-DL and C-Row-LL, the term (ℓ1 : Z1; . . . ; ℓn :
Zn; ∂Z) may be replaced with (ℓ: Z; ℓ1 : Z1; . . . ; ℓn : Zn; ∂Z). Thus, reasoning as
in the previous subcase, we ﬁnd that (2) entails
let Γ0 in ∃X′Z1 . . . ZnZ.(Jv′ : X′K ∧
Vn
i=1JV(ℓi) : ZiK ∧Jv : ZK
∧Π (ℓ1 : X′; ℓ1 : Z1; . . . ; ℓn : Zn; ∂Z) ≤T)
(4)
which by our preliminary fact is precisely let Γ0 in J{V[ℓ, v′]; v} : TK.
◦Cases R-Access-1, R-Access-2. We have:
let Γ0 in J{V; v}.{ℓ} : TK
≡
let Γ0 in ∃XY.(J{V; v} : Π (ℓ: X ; Y)K ∧X ≤T)
(1)
≡
let Γ0 in ∃XYZ1 . . . ZnZ.(
Vn
i=1JV(ℓi) : ZiK ∧Jv : ZK
∧Π (ℓ1 : Z1; . . . ; ℓn : Zn; ∂Z) ≤Π (ℓ: X ; Y)
∧X ≤T)
(2)
where (1) is by Exercise 10.7.1, and (2) follows from the preliminary fact and
from C-ExAnd, provided {ℓ1, . . . , ℓn} is the domain of V. We now distinguish
two subcases:

532
A
Solutions to Selected Exercises
Subcase ℓ∈dom(V), i.e., (R-Access-1). We may assume, w.l.o.g., that ℓis
ℓ1. Then, by our covariance hypotheses, the subconstraint in the second line
of (2) entails Z1 ≤X. By transitivity of subtyping, by Lemma 10.4.5, and by
C-Ex*, we ﬁnd that (2) entails let Γ0 in JV(ℓ) : TK.
Subcase ℓ∉dom(V), i.e., (R-Access-2). By C-Row-DL and C-Row-LL, the
term (ℓ1 : Z1; . . . ; ℓn : Zn; ∂Z) may be replaced with (ℓ: Z; ℓ1 : Z1; . . . ; ℓn :
Zn; ∂Z). Thus, reasoning as in the previous subcase, we ﬁnd that (2) entails
let Γ0 in Jv : TK.
Before attacking the proof of the progress property, let us brieﬂy check that
every value v that is well-typed with type Π T must be a record value, that is,
must be of the form {V; w}. Indeed, assume that let Γ0; ref M in Jv : Π TK
is satisﬁable. Then, v cannot be a program variable, for a well-typed value
must be closed. Furthermore, v cannot be a memory location m, because
ref M(m) ≤Π T is unsatisﬁable: indeed, the type constructors ref and Π
are incompatible (recall that Π is isolated). Similarly, v cannot be a partially
applied constant or a λ-abstraction, because T′ →T′′ ≤Π T is unsatisﬁable.
Thus, v must be a fully applied constructor. Since the only constructors in
the language are the record constructors {}L, v must be a record value. (If
there were other constructors in the language, they could be ruled out as
well, provided their return types are incompatible with Π.)
We must now prove that if the conﬁguration c v1 . . . vk/µ is is well-typed,
then either it is reducible, or c v1 . . . vk is a value. By the well-typedness hy-
pothesis, a constraint of the form let Γ0; ref M in Jc v1 . . . vk : TK is satisﬁable.
◦Case c is {}L. If k is less than or equal to n + 1, where n is the cardinal
of L, then c v1 . . . vk is a value. Otherwise, unfolding the above constraint,
we ﬁnd that it cannot be satisﬁable, because Π and →are incompatible; this
yields a contradiction.
◦Case c is {· with ℓ= ·}. Analogous to the next case.
◦Case c is ·.{ℓ}. If k = 0, then c v1 . . . vk is a value. Assume k ≥1. Then,
the constraint let Γ0; ref M in Jc v1 : TK is satisﬁable. By Exercise 10.7.1, this
implies that let Γ0; ref M in Jv1 : Π (ℓ: X ; Y)K is satisﬁable. Thus, v1 must be a
record value, and the conﬁguration is reducible by R-Access-1 or R-Access-2.
10.8.33
Solution: To make extension strict, it suﬃces to restrict its binding in the
initial environment Γ0, as follows:
⟨· with ℓ= ·⟩: ∀XY.Π (ℓ: abs ; Y) →X →Π (ℓ: pre X ; Y).
The new binding, which is less general than the former, requires the ﬁeld ℓ
to be absent in the input record. The operational semantics need not be mod-
iﬁed, since strict extension coincides with free extension when it is deﬁned.

A
Solutions to Selected Exercises
533
Deﬁning the operational semantics of (free) restriction is left to the reader.
Its binding in the initial environment should be:
· \ ⟨ℓ⟩: ∀XY.Π (ℓ: X ; Y) →Π (ℓ: abs ; Y)
In principle, there is no need to guess this binding: it may be discovered
through the encoding of ﬁnite records in terms of full records (10.8.32). Strict
restriction, which requires the ﬁeld to be present in the input record, may be
assigned the following type scheme:
· \ ⟨ℓ⟩: ∀XY.Π (ℓ: pre X ; Y) →Π (ℓ: abs ; Y)
10.8.34
Solution: The informal sentence “supplying a record with more ﬁelds in a
context where a record with fewer ﬁelds is expected” may be understood as
“providing an argument of type Π (ℓ: pre T ; T′) to a function whose domain
type is Π (ℓ: abs ; T′),” or, more generally, as “writing a program whose
well-typedness requires some constraint of the form Π (ℓ: pre T ; T′) ≤Π
(ℓ: abs ; T′) to be satisﬁable.” Now, in a nonstructural subtyping order where
pre à abs holds, such a constraint is equivalent to true. On the opposite, if
subtyping is interpreted as equality, then such a constraint is equivalent to
false. In other words, it is the law pre T ≤abs ≡true that gives rise to width
subtyping.
It is worth drawing a comparison with the way width subtyping is deﬁned in
type systems that do not have rows. In such type systems, a record type is of
the form {ℓ1 : T1; . . . ; ℓn : Tn}. Let us forget about the types T1, . . . , Tn, because
they describe the contents of ﬁelds, not their presence, and are thus orthog-
onal to the issue at hand. Then, a record type is a set {ℓ1, . . . , ℓn}, and width
subtyping is obtained by letting subtyping coincide with (the reverse of) set
containment. In a type system that exploits rows, on the other hand, a record
type is a total mapping from row labels to either pre or abs. (Because we are
ignoring T1, . . . , Tn, let us temporarily imagine that pre is a nullary type con-
structor.) The above record type is then written {ℓ1 : pre; . . . ; ℓn : pre; ∂abs}.
In other words, a set is now encoded as its characteristic function. Width sub-
typing is obtained by letting pre à abs and by lifting this ordering, pointwise,
to rows (which corresponds to our convention that rows are covariant).


References
Abadi, Martín, Luca Cardelli, Pierre-Louis Curien, and Jean-Jacques Lévy. Explicit sub-
stitutions. Journal of Functional Programming, 1(4):375–416, 1991. Summary in
ACM Symposium on Principles of Programming Languages (POPL), San Francisco,
California, 1990.
Adams, Rolf, Walter Tichy, and Annette Weinert. The cost of selective recompila-
tion and environment processing. ACM Transactions on Software Engineering and
Methodology, 3(1):3–28, January 1994.
Ahmed, Amal, Limin Jia, and David Walker. Reasoning about hierarchical storage.
In IEEE Symposium on Logic in Computer Science (LICS), Ottawa, Canada, pages
33–44, June 2003.
Ahmed, Amal and David Walker. The logical approach to stack typing. In ACM SIG-
PLAN Workshop on Types in Language Design and Implementation (TLDI), New
Orleans, Louisiana, pages 74–85, January 2003.
Aho, Alfred V., Ravi Sethi, and Jeﬀrey D. Ullman. Compilers: Principles, Techniques,
and Tools. Addison-Wesley, Reading, Massachusetts, 1986.
Aiken, Alexander, Manuel Fähndrich, and Raph Levien. Better static memory man-
agement: Improving region-based analysis of higher-order languages. In ACM SIG-
PLAN Conference on Programming Language Design and Implementation (PLDI),
La Jolla, California, pages 174–185, June 1995.
Aiken, Alexander, Jeﬀrey S. Foster, John Kodumal, and Tachio Terauchi. Checking
and inferring local non-aliasing.
In ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI), San Diego, California, pages 129–140,
June 2003.
Aiken, Alexander and Edward L. Wimmers. Solving systems of set constraints. In
IEEE Symposium on Logic in Computer Science (LICS), Santa Cruz, California, pages
329–340, June 1992.

536
References
Aiken, Alexander and Edward L. Wimmers. Type inclusion constraints and type infer-
ence. In ACM Symposium on Functional Programming Languages and Computer
Architecture (FPCA), Copenhagen, Denmark, pages 31–41, June 1993.
Altenkirch, Thorsten. Constructions, Inductive Types and Strong Normalization. PhD
thesis, Laboratory for Foundations of Computer Science, University of Edinburgh,
Edinburgh, Scotland, 1993.
Amadio, Roberto M. and Luca Cardelli.
Subtyping recursive types.
ACM Transac-
tions on Programming Languages and Systems, 15(4):575–631, 1993.
Summary
in ACM Symposium on Principles of Programming Languages (POPL), Orlando,
Florida, pp. 104–118; also DEC/Compaq Systems Research Center Research Report
number 62, August 1990.
Amtoft, Torben, Flemming Nielson, and Hanne Riis Nielson. Type and Eﬀect Systems:
Behaviours for Concurrency. Imperial College Press, 1999.
Ancona, Davide and Elena Zucca. A theory of mixin modules: Basic and derived op-
erators. Mathematical Structures in Computer Science, 8(4):401–446, August 1998.
Ancona, Davide and Elena Zucca. A calculus of module systems. Journal of Functional
Programming, 12(2):91–132, March 2002.
Appel, Andrew W. Foundational proof-carrying code. In IEEE Symposium on Logic in
Computer Science (LICS), Boston, Massachusetts, pages 247–258, June 2001.
Appel, Andrew W. and Amy P. Felty. A semantic model of types and machine instruc-
tions for proof-carrying code. In ACM SIGPLAN–SIGACT Symposium on Principles
of Programming Languages (POPL), Boston, Massachusetts, pages 243–253, January
2000.
Aspinall, David. Subtyping with singleton types. In International Workshop on Com-
puter Science Logic (CSL), Kazimierz, Poland, volume 933 of Lecture Notes in Com-
puter Science, pages 1–15. Springer-Verlag, September 1994.
Aspinall, David and Martin Hofmann. Another type system for in-place update. In
European Symposium on Programming (ESOP), Grenoble, France, volume 2305 of
Lecture Notes in Computer Science, pages 36–52. Springer-Verlag, April 2002.
Augustsson, Lennart. Cayenne—A language with dependent types. In ACM SIGPLAN
International Conference on Functional Programming (ICFP), Baltimore, Maryland,
pages 239–250, 1998.
Baader, Franz and Jörg Siekmann. Uniﬁcation theory. In D. M. Gabbay, C. J. Hogger,
and J. A. Robinson, editors, Handbook of Logic in Artiﬁcial Intelligence and Logic
Programming, volume 2, Deduction Methodologies, pages 41–125. Oxford Univer-
sity Press, 1994.
Baker, Henry G. Lively linear Lisp—look ma, no garbage! ACM SIGPLAN Notices, 27
(8):89–98, 1992.
Barendregt, Henk P. The Lambda Calculus. North Holland, revised edition, 1984.
Barendregt, Henk P. Introduction to generalized type systems. Journal of Functional
Programming, 1(2):125–154, 1991.

References
537
Barendregt, Henk P. Lambda calculi with types. In S. Abramsky, D. M. Gabbay, and
T. Maibaum, editors, Handbook of Logic in Computer Science, volume 2, Computa-
tional Structures. Oxford University Press, 1992.
Barendsen, Erik and Sjaak Smetsers. Conventional and uniqueness typing in graph
rewrite systems. In Foundations of Software Technology and Theoretical Computer
Science (FSTTCS), Bombay, India, volume 761 of Lecture Notes in Computer Science,
pages 41–51. Springer-Verlag, December 1993.
Barras, Bruno, Samuel Boutin, Cristina Cornes, Judicael Courant, Jean-Christophe
Filliatre, Eduardo Gimenez, Hugo Herbelin, Gerard Huet, Cesar Munoz, Chetan
Murthy, Catherine Parent, Christine Paulin-Mohring, Amokrane Saibi, and Benjamin
Werner. The Coq proof assistant reference manual: Version 6.1. Technical Report
RT-0203, INRIA, 1997.
Bauer, Lujo, Andrew W. Appel, and Edward W. Felten. Mechanisms for secure modular
programming in Java. Technical Report TR-603-99, Princeton University, 1999.
Bellantoni, Stephan and Stephan Cook. A new recursion-theoretic characterization of
polytime functions. Computational Complexity, 2(2):97–110, 1992.
Bellantoni, Stephan, K.-H. Niggl, and H. Schwichtenberg. Higher type recursion, rami-
ﬁcation and polynomial time. Annals of Pure and Applied Logic, 104:17–30, 2000.
Berardi, Stefano.
Towards a mathematical analysis of the Coquand-Huet calculus
of constructions and the other systems in Barendregt’s cube. Technical report,
Department of Computer Science, CMU, and Dipartimento Matematica, Universita
di Torino, 1988.
Berthomieu, Bernard. Tagged types: A theory of order sorted types for tagged expres-
sions. Research Report 93083, LAAS, 7, avenue du Colonel Roche, 31077 Toulouse,
France, March 1993.
Berthomieu, Bernard and Camille le Moniès de Sagazan. A calculus of tagged types,
with applications to process languages. In Workshop on Types for Program Analysis
(TPA), informal proceedings, pages 1–15, May 1995.
Biagioni, Edoardo, Nicholas Haines, Robert Harper, Peter Lee, Brian G. Milnes, and
Eliot B. Moss.
Signatures for a protocol stack: A systems application of Stan-
dard ML. In ACM Symposium on Lisp and Functional Programming (LFP), Orlando,
Florida, pages 55–64, June 1994.
Bierman, G. M., A. M. Pitts, and C. V. Russo. Operational properties of Lily, a polymor-
phic linear lambda calculus with recursion. In Workshop on Higher Order Opera-
tional Techniques in Semantics (HOOTS), Montréal, Québec, volume 41 of Electronic
Notes in Theoretical Computer Science. Elsevier, September 2000.
Birkedal, Lars and Robert W. Harper. Constructing interpretations of recursive types
in an operational setting. Information and Computation, 155:3–63, 1999.
Birkedal, Lars and Mads Tofte. A constraint-based region inference algorithm. Theo-
retical Computer Science, 258:299–392, 2001.

538
References
Birkedal, Lars, Mads Tofte, and Magnus Vejlstrup. From region inference to von Neu-
mann machines via region representation inference.
In ACM SIGPLAN–SIGACT
Symposium on Principles of Programming Languages (POPL), St. Petersburg Beach,
Florida, pages 171–183, 1996.
Blume, Matthias. The SML/NJ Compilation and Library Manager, May 2002. Available
from http://www.smlnj.org/doc/CM/index.html.
Blume, Matthias and Andrew W. Appel. Hierarchical modularity. ACM Transactions
on Programming Languages and Systems, 21(4):813–847, 1999.
Bonniot, Daniel. Type-checking multi-methods in ML (a modular approach). In Inter-
national Workshop on Foundations of Object-Oriented Languages (FOOL), informal
proceedings, January 2002.
Bourdoncle, François and Stephan Merz.
Type-checking higher-order polymorphic
multi-methods. In ACM SIGPLAN–SIGACT Symposium on Principles of Program-
ming Languages (POPL), Paris, France, pages 302–315, January 1997.
Bracha, Gilad and William R. Cook. Mixin-based inheritance. In ACM SIGPLAN Confer-
ence on Object Oriented Programming: Systems, Languages, and Applications (OOP-
SLA)/European Conference on Object-Oriented Programming (ECOOP), Ottawa, On-
tario, pages 303–311, October 1990.
Brandt, Michael and Fritz Henglein.
Coinductive axiomatization of recursive type
equality and subtyping. In International Conference on Typed Lambda Calculi and
Applications (TLCA), Nancy, France, volume 1210 of Lecture Notes in Computer
Science, pages 63–81. Springer-Verlag, April 1997.
Full version in Fundamenta
Informaticae, 33:309–338, 1998.
Breazu-Tannen, Val, Thierry Coquand, Carl Gunter, and Andre Scedrov. Inheritance
as implicit coercion. Information and Computation, 93(1):172–221, July 1991. Also
in C. A. Gunter and J. C. Mitchell, editors, Theoretical Aspects of Object-Oriented
Programming: Types, Semantics, and Language Design, MIT Press, 1994.
Bruce, Kim B.
Typing in object-oriented languages: Achieving expressibility and
safety, 1995. Available through http://www.cs.williams.edu/~kim.
Bruce, Kim B. Foundations of Object-Oriented Languages: Types and Semantics. MIT
Press, 2002.
Bruce, Kim B., Luca Cardelli, Giuseppe Castagna, the Hopkins Objects Group
(Jonathan Eifrig, Scott Smith, Valery Trifonov), Gary T. Leavens, and Benjamin
Pierce. On binary methods. Theory and Practice of Object Systems, 1(3):221–242,
1996.
Bruce, Kim B., Luca Cardelli, and Benjamin C. Pierce. Comparing object encodings.
In International Symposium on Theoretical Aspects of Computer Software (TACS),
September 1997. An earlier version was presented as an invited lecture at the Third
International Workshop on Foundations of Object Oriented Languages (FOOL 3),
July 1996; full version in Information and Computation, 155(1–2):108-133, 1999.

References
539
de Bruijn, Nicolas G. A survey of the project AUTOMATH. In J. P. Seldin and J. R.
Hindley, editors, To H. B. Curry: Essays in Combinatory Logic, Lambda Calculus,
and Formalism, pages 589–606. Academic Press, 1980.
Brus, Tom, Marko van Eekelen, Maarten van Leer, and Marinus Plasmeijer. Clean: A
language for functional graph rewriting. In ACM Symposium on Functional Pro-
gramming Languages and Computer Architecture (FPCA), Portland, Oregon, vol-
ume 274 of Lecture Notes in Computer Science, pages 364–384. Springer-Verlag,
September 1987.
Burstall, Rod and Butler Lampson. A kernel language for abstract data types and
modules. In International Symposium on Semantics of Data Types, Sophia-Antipolis,
France, volume 173 of Lecture Notes in Computer Science, pages 1–50. Springer-
Verlag, June 1984.
Burstall, Rod, David MacQueen, and Donald Sannella.
HOPE: an experimental ap-
plicative language. In ACM Symposium on Lisp and Functional Programming (LFP),
Stanford, California, pages 136–143, August 1980.
Calcagno, Cristiano. Stratiﬁed operational semantics for safety and correctness of re-
gion calculus. In ACM SIGPLAN–SIGACT Symposium on Principles of Programming
Languages (POPL), London, England, pages 155–165, 2001.
Calcagno, Cristiano, Simon Helsen, and Peter Thiemann. Syntactic type soundness
results for the region calculus.
Information and Computation, 173(2):199–221,
2002.
Cardelli, Luca.
A polymorphic λ-calculus with Type:Type.
Research report 10,
DEC/Compaq Systems Research Center, May 1986.
Cardelli, Luca. Phase distinctions in type theory, 1988a. Manuscript, available from
http://www.luca.demon.co.uk.
Cardelli, Luca. Typechecking dependent types and subtypes. In Foundations of Logic
and Functional Programming, Trento, Italy, (December, 1986), volume 306 of Lec-
ture Notes in Computer Science, pages 45–57. Springer-Verlag, 1988b.
Cardelli, Luca. Program fragments, linking, and modularization. In ACM SIGPLAN–
SIGACT Symposium on Principles of Programming Languages (POPL), Paris, France,
pages 266–277, January 1997.
Cardelli, Luca, James Donahue, Mick Jordan, Bill Kalsow, and Greg Nelson.
The
Modula-3 type system. In Proceedings of the Sixteenth Annual ACM Symposium
on Principles of Programming Languages, pages 202–212, January 1989.
Cardelli, Luca and Xavier Leroy. Abstract types and the dot notation. In IFIP TC2
Working Conference on Programming Concepts and Methods. North Holland, 1990.
Also appeared as DEC/Compaq SRC technical report 56.
Cardelli, Luca and Giuseppe Longo. A semantic basis for Quest. Journal of Functional
Programming, 1(4):417–458, October 1991. Summary in ACM Conference on Lisp
and Functional Programming, pp. 30-43, 1990. Also available as DEC/Compaq SRC
Research Report 55, Feb. 1990.

540
References
Cardelli, Luca and John Mitchell. Operations on records. Mathematical Structures
in Computer Science, 1:3–48, 1991. Also in C. A. Gunter and J. C. Mitchell, edi-
tors, Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and
Language Design, MIT Press, 1994; available as DEC/Compaq Systems Research
Center Research Report #48, August, 1989; and in the Proceedings of Workshop
on the Mathematical Foundations of Programming Semantics (MFPS), New Orleans,
Louisiana, Springer LNCS, volume 442, pp. 22-52, 1989.
Cartmell, John. Generalised algebraic theories and contextual categories. Annals of
Pure and Applied Logic, 32:209–243, 1986.
Cartwright, Robert and Mike Fagan. Soft typing. In ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation (PLDI), Toronto, Ontario, pages
278–292, June 1991.
Cervesato, Iliano, Joshua S. Hodas, and Frank Pfenning. Eﬃcient resource manage-
ment for linear logic proof search. Theoretical Computer Science, 232(1–2):133–
163, February 2000.
Cervesato, Iliano and Frank Pfenning. A linear logical framework. Information and
Computation, 179(1):19–75, November 2002.
Chaki, Sagar, Sriram K. Rajamani, and Jakob Rehof. Types as models: Model checking
message-passing programs. In ACM SIGPLAN–SIGACT Symposium on Principles of
Programming Languages (POPL), Portland, Oregon, pages 45–57, 2002.
Chirimar, Jawahar, Carl A. Gunter, and Jon G. Riecke. Reference counting as a com-
putational interpretation of linear logic. Journal of Functional Programming, 6(2):
195–244, March 1996.
Christiansen, Morten Voetmann and Per Velschow. Region-based memory manage-
ment in Java. Master’s thesis, University of Copenhagen, Department of Computer
Science, 1998.
Church, Alonzo. The Calculi of Lambda Conversion. Princeton University Press, 1941.
Church, Alonzo. The weak theory of implication. Kontroliertes Denken: Untersuchun-
gen zum Logikkalk ul und zur Logik der Einzelwissenschaften, pages 22–37, 1951.
Clement, Dominique, Joelle Despeyroux, Thierry Despeyroux, and Gilles Kahn.
A
simple applicative language: Mini-ML. In ACM Symposium on Lisp and Functional
Programming (LFP), Cambridge, Massachusetts, pages 13–27, August 1986.
Colby, Christopher, Peter Lee, George C. Necula, Fred Blau, Mark Plesko, and Kenneth
Cline. A certifying compiler for Java. ACM SIGPLAN Notices, 35(5):95–107, May
2000.
Comon, Hubert. Constraints in term algebras (short survey). In Conference on Alge-
braic Methodology and Software Technology (AMAST), June, 1993, Workshops in
Computing, pages 97–108. Springer-Verlag, 1994.
Constable, Robert L., Stuart F. Allen, Mark Bromley, Rance Cleaveland, James F. Cre-
mer, Robert W. Harper, Douglas J. Howe, Todd B. Knoblock, Paul Mendler, Prakash
Panangaden, James T. Sasaki, and Scott F. Smith. Implementing Mathematics with
the NuPRL Proof Development System. Prentice-Hall, Englewood Cliﬀs, NJ, 1986.

References
541
Coquand, Catarina.
The AGDA proof system homepage, 1998.
http://www.cs.
chalmers.se/~catarina/agda/.
Coquand, Thierry. An analysis of Girard’s paradox. In IEEE Symposium on Logic in
Computer Science (LICS), Cambridge, Massachusetts, pages 227–236, June 1986.
Coquand, Thierry. An algorithm for testing conversion in type theory. In G. Huet
and G. Plotkin, editors, Logical Frameworks, pages 255–279. Cambridge University
Press, 1991.
Coquand, Thierry.
Pattern matching with dependent types.
In Workshop on
Types for Proofs and Programs (TYPES), Båstad, Sweden, informal proceed-
ings. Available from ftp://ftp.cs.chalmers.se/pub/cs-reports/baastad.
92/proc.ps.Z, June 1992.
Coquand, Thierry and Gérard Huet. The calculus of constructions. Information and
Computation, 76(2–3):95–120, February/March 1988.
Coquand, Thierry, Randy Pollack, and Makoto Takeyama. A logical framework with
dependently typed records. In International Conference on Typed Lambda Calculi
and Applications (TLCA), Valencia, Spain, volume 2701 of Lecture Notes in Com-
puter Science, pages 105–119. Springer-Verlag, June 2003.
Courant, Judicaël. Strong normalization with singleton types. In Workshop on In-
tersection Types and Related Systems (ITRS), Copenhagen, Denmark, volume 70 of
Electronic Notes in Theoretical Computer Science. Elsevier, July 2002.
Crank, Erik and Matthias Felleisen.
Parameter-passing and the lambda calculus.
In ACM Symposium on Principles of Programming Languages (POPL), Orlando,
Florida, pages 233–244, January 1991.
Crary, Karl. A simple proof technique for certain parametricity results. In ACM SIG-
PLAN International Conference on Functional Programming (ICFP), Paris, France,
pages 82–89, September 1999.
Crary, Karl.
Toward a foundational typed assembly language.
In ACM SIGPLAN–
SIGACT Symposium on Principles of Programming Languages (POPL), New Orleans,
Louisiana, pages 198–212, January 2003.
Crary, Karl, Robert Harper, and Sidd Puri. What is a recursive module? In ACM SIG-
PLAN Conference on Programming Language Design and Implementation (PLDI),
pages 50–63, May 1999.
Crary, Karl, Stephanie Weirich, and Greg Morrisett.
Intensional polymorphism in
type-erasure semantics. In ACM SIGPLAN International Conference on Functional
Programming (ICFP), Baltimore, Maryland, pages 301–312, 1998. Full version in
Journal of Functional Programming, 12(6), Nov. 2002, pp. 567–600.
Curtis, Pavel. Constrained Quantiﬁcation in Polymorphic Type Analysis. PhD thesis,
Cornell University, Ithaca, New York, February 1990.
van Daalen, Diederik T. The Language Theory of Automath. PhD thesis, Technische
Hogeschool Eindhoven, Eindhoven, The Netherlands, 1980.

542
References
Damas, Luis and Robin Milner. Principal type schemes for functional programs. In
ACM Symposium on Principles of Programming Languages (POPL), Albuquerque,
New Mexico, pages 207–212, 1982.
Danvy, Olivier. Functional unparsing. Journal of Functional Programming, 8(6):621–
625, 1998.
DeLine, Rob and Manuel Fähndrich. Enforcing high-level protocols in low-level soft-
ware. In ACM SIGPLAN Conference on Programming Language Design and Imple-
mentation (PLDI), Snowbird, Utah, pages 59–69, June 2001.
Donahue, James and Alan Demers.
Data types are values.
ACM Transactions on
Programming Languages and Systems, 7(3):426–445, July 1985.
Došen, Kosta.
A historical introduction to substructural logics.
In K. Došen and
P. Schroeder-Heister, editors, Substructural Logics, pages 1–30. Oxford University
Press, 1993.
Dreyer, Derek, Karl Crary, and Robert Harper. A type system for higher-order mod-
ules.
In ACM SIGPLAN–SIGACT Symposium on Principles of Programming Lan-
guages (POPL), New Orleans, Louisiana, pages 236–249, New Orleans, January
2003.
Dussart, Dirk, Fritz Henglein, and Christian Mossin. Polymorphic recursion and sub-
type qualiﬁcations: Polymorphic binding-time analysis in polynomial time. In Inter-
national Symposium on Static Analysis (SAS) , Paris, France, volume 983 of Lecture
Notes in Computer Science, pages 118–135. Springer-Verlag, July 1995.
Emms, Martin and Hans LeiSS.
Extending the type checker for SML by polymor-
phic recursion—A correctness proof.
Technical Report 96-101, Centrum für
Informations- und Sprachverarbeitung, Universität München, 1996.
Erhard, Thomas. A categorical semantics of constructions. In IEEE Symposium on
Logic in Computer Science (LICS), Edinburgh, Scotland, pages 264–273, July 1988.
Fähndrich, Manuel. Bane: A Library for Scalable Constraint-Based Program Analysis.
PhD thesis, University of California at Berkeley, Berkeley, California, 1999.
Fähndrich, Manuel and Rob DeLine. Adoption and focus: Practical linear types for
imperative programming. In ACM SIGPLAN Conference on Programming Language
Design and Implementation (PLDI), Berlin, Germany, pages 13–24, June 2002.
Fähndrich, Manuel, Jakob Rehof, and Manuvir Das. Scalable context-sensitive ﬂow
analysis using instantiation constraints. In ACM SIGPLAN Conference on Program-
ming Language Design and Implementation (PLDI), Vancouver, British Columbia,
Canada, pages 253–263, June 2000.
Felleisen, Matthias and Robert Hieb. A revised report on the syntactic theories of
sequential control and state. Theoretical Computer Science, 103(2):235–271, 1992.
Fisher, Kathleen and John H. Reppy. The design of a class mechanism for Moby. In
ACM SIGPLAN Conference on Programming Language Design and Implementation
(PLDI), Atlanta, Georgia, pages 37–49, May 1999.

References
543
Flanagan, Cormac and Shaz Qadeer.
A type and eﬀect system for atomicity.
In
ACM SIGPLAN Conference on Programming Language Design and Implementation
(PLDI), San Diego, California, pages 338–349, June 2003.
Flatt, Matthew and Matthias Felleisen. Units: Cool modules for HOT languages. In
ACM SIGPLAN Conference on Programming Language Design and Implementation
(PLDI), Montréal, Québec, pages 236–248, 1998.
Fluet, Matthew. Monadic regions. In Workshop on Semantics, Program Analysis and
Computing Environments for Memory Management (SPACE), informal proceedings,
January 2004.
Fluet, Matthew and Riccardo Pucella. Phantom types and subtyping. In IFIP Interna-
tional Conference on Theoretical Computer Science (TCS), pages 448–460, August
2002.
Foster, Jeﬀrey S., Tachio Terauchi, and Alex Aiken. Flow-sensitive type qualiﬁers. In
ACM SIGPLAN Conference on Programming Language Design and Implementation
(PLDI), Berlin, Germany, pages 1–12, June 2002.
Frey, Alexandre. Satisfying subtype inequalities in polynomial space. In International
Symposium on Static Analysis (SAS) , Paris, France, volume 1302 of Lecture Notes
in Computer Science, pages 265–277. Springer-Verlag, September 1997.
Fuh, You-Chin and Prateek Mishra. Type inference with subtypes. In European Sym-
posium on Programming (ESOP), Nancy, France, volume 300 of Lecture Notes in
Computer Science, pages 94–114. Springer-Verlag, March 1988.
Furuse, Jun P. and Jacques Garrigue. A label-selective lambda-calculus with optional
arguments and its compilation method.
RIMS Preprint 1041, Kyoto University,
October 1995.
Garcia, Ronald, Jaakko Jarvi, Andrew Lumsdaine, Jeremy Siek, and Jeremia h Will-
cock. A comparative study of language support for generic programming. In ACM
SIGPLAN Conference on Object Oriented Programming: Systems, Languages, and
Applications (OOPSLA), Anaheim, California, pages 115–134, October 2003.
Garrigue, Jacques. Programming with polymorphic variants. In ACM SIGPLAN Work-
shop on ML, informal proceedings, September 1998.
Garrigue, Jacques. Code reuse through polymorphic variants. In Workshop on Foun-
dations of Software Engineering (FOSE), November 2000.
Garrigue, Jacques. Simple type inference for structural polymorphism. In Interna-
tional Workshop on Foundations of Object-Oriented Languages (FOOL), informal
proceedings, January 2002.
Garrigue, Jacques.
Relaxing the value restriction.
In International Symposium on
Functional and Logic Programming (FLOPS), Nara, Japan, volume 2998 of Lecture
Notes in Computer Science, pages 196–213. Springer-Verlag, April 2004.
Garrigue, Jacques and Hassan Aït-Kaci.
The typed polymorphic label-selective
lambda-calculus. In ACM SIGPLAN–SIGACT Symposium on Principles of Program-
ming Languages (POPL), Portland, Oregon, pages 35–47, 1994.

544
References
Garrigue, Jacques and Didier Rémy.
Extending ML with semi-explicit higher-order
polymorphism. Information and Computation, 155(1):134–169, 1999.
Gaster, Benedict R. Records, variants and qualiﬁed types. PhD thesis, University of
Nottingham, Nottingham, England, July 1998.
Gaster, Benedict R. and Mark P. Jones. A polymorphic type system for extensible
records and variants. Technical Report NOTTCS-TR-96-3, Department of Computer
Science, University of Nottingham, November 1996.
Gay, David and Alexander Aiken. Language support for regions. In ACM SIGPLAN
Conference on Programming Language Design and Implementation (PLDI), Snow-
bird, Utah, pages 70–80, June 2001.
Ghelli, Giorgio and Benjamin Pierce.
Bounded existentials and minimal typing,
1992. Circulated in manuscript form. Full version in Theoretical Computer Science,
193(1–2):75–96, February 1998.
Giﬀord, David K. and John M. Lucassen. Integrating functional and imperative pro-
gramming. In ACM Symposium on Lisp and Functional Programming (LFP), Cam-
bridge, Massachusetts, pages 28–38, August 1986.
Girard, Jean-Yves. Interprétation fonctionnelle et élimination des coupures de l’arith-
métique d’ordre supérieur. Thèse d’état, University of Paris VII, 1972. Summary
in J. E. Fenstad, editor, Scandinavian Logic Symposium, pp. 63–92, North-Holland,
1971.
Girard, Jean-Yves. Linear logic. Theoretical Computer Science, 50:1–102, 1987.
Girard, Jean-Yves.
Light linear logic.
Information and Computation, 143:175–204,
1998.
Girard, Jean-Yves, Yves Lafont, and Paul Taylor. Proofs and Types, volume 7 of Cam-
bridge Tracts in Theoretical Computer Science. Cambridge University Press, 1989.
Glew, Neal. Type dispatch for named hierarchical types. In ACM SIGPLAN Interna-
tional Conference on Functional Programming (ICFP), Paris, France, pages 172–182,
1999.
GNU.
GNU C library, version 2.2.5, 2001.
Available from http://www.gnu.org/
manual/glibc-2.2.5/html_mono/libc.html.
Goguen, Healfdene.
A Typed Operational Semantics for Type Theory.
PhD thesis,
LFCS, University of Edinburgh, Edinburgh, Scotland, 1994.
Report ESC-LFCS-94-
304.
Gordon, Andrew D. Bisimilarity as a theory of functional programming. In Workshop
on the Mathematical Foundations of Programming Semantics (MFPS), New Orleans,
Louisiana, volume 1 of Electronic Notes in Theoretical Computer Science. Elsevier,
April 1995.
Gordon, Andrew D. Operational equivalences for untyped and polymorphic object
calculi. In A. D. Gordon and A. M. Pitts, editors, Higher-Order Operational Tech-
niques in Semantics, Publications of the Newton Institute, pages 9–54. Cambridge
University Press, 1998.

References
545
Gordon, Andrew D. and Alan Jeﬀrey. Authenticity by typing for security protocols. In
IEEE Computer Security Foundations Workshop (CSFW), Cape Breton, Nova Scotia,
pages 145–159, 2001a.
Gordon, Andrew D. and Alan Jeﬀrey. Typing correspondence assertions for commu-
niation protocols. In Workshop on the Mathematical Foundations of Programming
Semantics (MFPS), Aarhus, Denmark, volume 45 of Electronic Notes in Theoretical
Computer Science, pages 379–409. Elsevier, May 2001b.
Gordon, Andrew D. and Alan Jeﬀrey. Types and eﬀects for asymmetric cryptographic
protocols. In IEE Computer Security Foundations Workshop (CSFW) , Cape Breton,
Nova Scotia, pages 77–91, 2002.
Gordon, Andrew D. and Don Syme.
Typing a multi-language intermediate code.
In ACM SIGPLAN–SIGACT Symposium on Principles of Programming Languages
(POPL), London, England, pages 248–260, January 2001.
Gordon, Michael J., Robin Milner, and Christopher P. Wadsworth.
Edinburgh LCF,
volume 78 of Lecture Notes in Computer Science. Springer-Verlag, 1979.
Gough, John. Compiling for the .NET Common Language Runtime. .NET series. Pren-
tice Hall, 2002.
Grossman, Dan, Greg Morrisett, Trevor Jim, Michael Hicks, Yanling Wang, and James
Cheney. Region-based memory management in Cyclone. In ACM SIGPLAN Con-
ference on Programming Language Design and Implementation (PLDI), Berlin, Ger-
many, pages 282–293, 2002.
Gustavsson, Jörgen and Josef Svenningsson. Constraint abstractions. In Symposium
on Programs as Data Objects (PADO), Aarhus, Denmark, volume 2053 of Lecture
Notes in Computer Science, pages 63–83. Springer-Verlag, May 2001.
Hallenberg, Niels, Martin Elsman, and Mads Tofte. Combining region inference and
garbage collection. In ACM SIGPLAN Conference on Programming Language De-
sign and Implementation (PLDI), Berlin, Germany, pages 141–152, June 2002.
Hallgren, Thomas and Aarne Ranta. An extensible proof text editor (abstract). In
International Conference on Logic for Programming and Automated Reasoning
(LPAR), Reunion Island, volume 1955 of Lecture Notes in Computer Science, pages
70–84. Springer-Verlag, 2000.
Hamid, Nadeem, Zhong Shao, Valery Trifonov, Stefan Monnier, and Zhaozhong Ni.
A syntactic approach to foundational proof-carrying code. In IEEE Symposium on
Logic in Computer Science (LICS), pages 89–100, July 2002.
Hanson, David R. Fast allocation and deallocation of memory based on object life-
times. Software—Practice and Experience, 20(1):5–12, 1990.
Hardin, Thérèse, Luc Maranget, and Bruno Pagano. Functional runtimes within the
lambda-sigma calculus. Journal of Functional Programming, 8(2):131–172, March
1998.
Harper, Robert, Furio Honsell, and Gordon Plotkin. A framework for deﬁning logics.
Journal of the ACM, 40(1):143–184, 1993. Summary in IEEE Symposium on Logic in
Computer Science (LICS), Ithaca, New York, 1987.

546
References
Harper, Robert and Mark Lillibridge. A type-theoretic approach to higher-order mod-
ules with sharing. In ACM SIGPLAN–SIGACT Symposium on Principles of Program-
ming Languages (POPL), Portland, Oregon, pages 123–137, January 1994.
Harper, Robert and John C. Mitchell. On the type structure of Standard ML. ACM
Transactions on Programming Languages and Systems, 15(2):211–252, April 1993.
An earlier version appeared in ACM Symposium on Principles of Programming Lan-
guages (POPL), San Diego, California, under the title “The Essence of ML” (Mitchell
and Harper), 1988.
Harper, Robert, John C. Mitchell, and Eugenio Moggi. Higher-order modules and the
phase distinction. In ACM Symposium on Principles of Programming Languages
(POPL), San Francisco, California, pages 341–354, January 1990.
Harper, Robert and Frank Pfenning. On equivalence and canonical forms in the LF
type theory. ACM Transactions on Computational Logic, 2004. To appear. An ear-
lier version is available as Technical Report CMU-CS-00-148, School of Computer
Science, Carnegie Mellon University.
Harper, Robert and Robert Pollack. Type checking with universes. Theoretical Com-
puter Science, 89:107–136, 1991.
Harper, Robert and Christopher Stone. A type-theoretic interpretation of Standard
ML. In G. Plotkin, C. Stirling, and M. Tofte, editors, Proof, Language and Interaction:
Essays in Honour of Robin Milner. MIT Press, 2000.
Heintze, Nevin. Set based analysis of ML programs. In ACM Symposium on Lisp and
Functional Programming (LFP), Orlando, Florida, pages 306–317, June 1994.
Heintze, Nevin.
Control-ﬂow analysis and type systems.
In International Sympo-
sium on Static Analysis (SAS) , Glasgow, Scotland, volume 983 of Lecture Notes in
Computer Science, pages 189–206. Springer-Verlag, 1995.
Helsen, Simon and Peter Thiemann. Syntactic type soundness for the region calculus.
In Workshop on Higher Order Operational Techniques in Semantics (HOOTS), Mon-
tréal, Québec, volume 41(3) of Electronic Notes in Theoretical Computer Science,
pages 1–20. Elsevier, September 2000.
Helsen, Simon and Peter Thiemann. Polymorphic specialization for ML. ACM Trans-
actions on Programming Languages and Systems, 26(4):652–701, July 2004.
Henglein, Fritz. Polymorphic Type Inference and Semi-Uniﬁcation. PhD thesis, Rutgers
University, April 1989. Available as NYU Technical Report 443, May 1989, from
New York University, Courant Institute of Mathematical Sciences, Department of
Computer Science, 251 Mercer St., New York, NY 10012, USA.
Henglein, Fritz. Type inference with polymorphic recursion. ACM Transactions on
Programming Languages and Systems, 15(2):253–289, 1993.
Henglein, Fritz, Henning Makholm, and Henning Niss. A direct approach to control-
ﬂow sensitive region-based memory management. In ACM SIGPLAN International
Conference on Principles and Practice of Declarative Programming (PPDP), Firenze,
Italy, pages 175–186, September 2001.

References
547
Henglein, Fritz and Christian Mossin. Polymorphic binding-time analysis. In European
Symposium on Programming (ESOP), Edinburgh, Scotland, volume 788 of Lecture
Notes in Computer Science, pages 287–301. Springer-Verlag, April 1994.
Hirschowitz, Tom and Xavier Leroy.
Mixin modules in a call-by-value setting.
In
European Symposium on Programming (ESOP), Grenoble, France, pages 6–20, April
2002.
Hoare, C. A. R.
Proof of correctness of data representation.
Acta Informatica, 1:
271–281, 1972.
Hofmann, Martin.
A mixed modal/linear lambda calculus with applications to
bellantoni-cook safe recursion.
In International Workshop on Computer Science
Logic (CSL), Aarhus, Denmark, pages 275–294, August 1997a.
Hofmann, Martin.
Syntax and semantics of dependent types.
In A. M. Pitts and
P. Dybjer, editors, Semantics and Logic of Computation, pages 79–130. Cambridge
University Press, 1997b.
Hofmann, Martin. Linear types and non-size-increasing polynomial time computa-
tion. In IEEE Symposium on Logic in Computer Science (LICS), Trento, Italy, pages
464–473, June 1999.
Hofmann, Martin. Safe recursion with higher types and BCK-algebra. Annals of Pure
and Applied Logic, 104(1–3):113–166, 2000.
Honsell, Furio, Ian A. Mason, Scott F. Smith, and Carolyn L. Talcott. A variable typed
logic of eﬀects. Information and Computation, 119(1):55–90, 1995.
Howard, William A. Hereditarily majorizable functionals of ﬁnite type. In A. S. Troel-
stra, editor, Metamathematical Investigation of Intuitionistic Arithmetic and Analy-
sis, volume 344 of Lecture Notes in Mathematics, pages 454–461. Springer-Verlag,
Berlin, 1973.
Howard, William A.
The formulas-as-types notion of construction.
In J. P. Seldin
and J. R. Hindley, editors, To H. B. Curry: Essays on Combinatory Logic, Lambda
Calculus, and Formalism, pages 479–490. Academic Press, 1980. Reprint of 1969
article.
Howe, Douglas J.
Proving congruence of bisimulation in functional programming
languages. Information and Computation, 124(2):103–112, 1996.
Huet, Gérard. Résolution d’equations dans les langages d’ordre 1,2, ...,ω. Thèse de
Doctorat d’Etat, Université de Paris 7, Paris, France, 1976.
Igarashi, Atsushi and Naoki Kobayashi. A generic type system for the Pi-calculus.
In ACM SIGPLAN–SIGACT Symposium on Principles of Programming Languages
(POPL), London, England, pages 128–141, January 2001.
Igarashi, Atsushi and Naoki Kobayashi. Resource usage analysis. In ACM SIGPLAN–
SIGACT Symposium on Principles of Programming Languages (POPL), Portland,
Oregon, pages 331–342, January 2002.

548
References
Igarashi, Atsushi and Benjamin C. Pierce. Foundations for virtual types. In European
Conference on Object-Oriented Programming (ECOOP), Lisbon, Portugal, June 1999.
Also in informal proceedings of the Workshop on Foundations of Object-Oriented
Languages (FOOL), January 1999. Full version in Information and Computation,
175(1): 34–49, May 2002.
Ishtiaq, Samin and Peter O’Hearn.
BI as an assertion language for mutable data
structures. In ACM SIGPLAN–SIGACT Symposium on Principles of Programming
Languages (POPL), London, England, pages 14–26, January 2001.
Jacobs, Bart. Categorical Logic and Type Theory. Studies in Logic and the Foundations
of Mathematics 141. Elsevier, 1999.
Jategaonkar, Lalita A. ML with extended pattern matching and subtypes. Master’s
thesis, Massachusetts Institute of Technology, August 1989.
Jategaonkar, Lalita A. and John C. Mitchell. ML with extended pattern matching and
subtypes (preliminary version). In ACM Symposium on Lisp and Functional Pro-
gramming (LFP), Snowbird, Utah, pages 198–211, Snowbird, Utah, July 1988.
Jensen, Kathleen and Niklaus Wirth. Pascal User Manual and Report. Springer-Verlag,
second edition, 1975.
Jim, Trevor. What are principal typings and what are they good for? In ACM SIGPLAN–
SIGACT Symposium on Principles of Programming Languages (POPL), St. Petersburg
Beach, Florida, pages 42–53, 1996.
Jim, Trevor, J. Greg Morrisett, Dan Grossman, Michael W. Hicks, James Cheney, and
Yanling Wang.
Cyclone: A safe dialect of C.
In General Track: USENIX Annual
Technical Conference, pages 275–288, June 2002.
Jim, Trevor and Jens Palsberg. Type inference in systems of recursive types with sub-
typing, 1999.
Manuscript, available from http://www.cs.purdue.edu/homes/
palsberg/draft/jim-palsberg99.pdf.
Johann, Patricia.
A generalization of short-cut fusion and its correctness proof.
Higher-Order and Symbolic Computation, 15(4):273–300, 2002.
Jones, Mark P. Qualiﬁed Types: Theory and Practice. Cambridge University Press,
1994.
Jones, Mark P. Using parameterized signatures to express modular structure. In ACM
SIGPLAN–SIGACT Symposium on Principles of Programming Languages (POPL),
St. Petersburg Beach, Florida, January 21–24, 1996.
Jones, Mark P. Typing Haskell in Haskell. In ACM Haskell Workshop, informal pro-
ceedings, October 1999.
Jones, Mark P. and John C. Peterson. The Hugs 98 user manual, 1999. Available from
http://www.haskell.org/hugs/.
Jones, Mark P. and Simon Peyton Jones. Lightweight extensible records for Haskell.
In ACM Haskell Workshop, informal proceedings, October 1999.

References
549
Jouannaud, Jean-Pierre and Claude Kirchner. Solving equations in abstract algebras:
a rule-based survey of uniﬁcation. In J.-L. Lassez and G. Plotkin, editors, Computa-
tional Logic: Essays in honor of Alan Robinson, pages 257–321. MIT Press, 1991.
Jouvelot, Pierre and David Giﬀord.
Algebraic reconstruction of types and eﬀects.
In ACM Symposium on Principles of Programming Languages (POPL), Orlando,
Florida, pages 303–310, January 1991.
Jouvelot, Pierre and David K. Giﬀord. Reasoning about continuations with control
eﬀects. In ACM SIGPLAN Conference on Programming Language Design and Im-
plementation (PLDI), Portland, Oregon, pages 218–226, June 1989.
Jung, Achim and Allen Stoughton. Studying the fully abstract model of PCF within its
continuous function model. In International Conference on Typed Lambda Calculi
and Applications (TLCA), Utrecht, The Netherlands, volume 664 of Lecture Notes in
Computer Science, pages 230–244. Springer-Verlag, March 1993.
Jutting, L.S. van Benthem, James McKinna, and Robert Pollack. Checking algorithms
for Pure Type Systems. In International Workshop on Types for Proofs and Pro-
grams (TYPES), Nijmegen, The Netherlands, May 1993, volume 806 of Lecture Notes
in Computer Science, pages 19–61. Springer-Verlag, 1994.
Kfoury, Assaf J., Jerzy Tiuryn, and Pawel Urzyczyn.
ML typability is dexptime-
complete. In Colloquium on Trees in Algebra and Programming (CAAP), Copen-
hagen, Denmark, volume 431 of Lecture Notes in Computer Science, pages 206–
220. Springer-Verlag, May 1990.
Kfoury, Assaf J., Jerzy Tiuryn, and Pawel Urzyczyn. The undecidability of the semi-
uniﬁcation problem. Information and Computation, 102(1):83–101, January 1993.
Kfoury, Assaf J., Jerzy Tiuryn, and Pawel Urzyczyn.
An analysis of ML typability.
Journal of the ACM, 41(2):368–398, March 1994.
Kirchner, Claude and Francis Klay. Syntactic theories and uniﬁcation. In IEEE Sympo-
sium on Logic in Computer Science (LICS), Philadelphia, Pennsylvania, pages 270–
277, June 1990.
Knight, Kevin. Uniﬁcation: a multidisciplinary survey. ACM Computing Surveys, 21
(1):93–124, March 1989.
Kobayashi, Naoki. Quasi-linear types. In ACM SIGPLAN–SIGACT Symposium on Princi-
ples of Programming Languages (POPL), San Antonio, Texas, pages 29–42, January
1999.
Kozen, Dexter, Jens Palsberg, and Michael I. Schwartzbach. Eﬃcient recursive sub-
typing. Mathematical Structures in Computer Science, 5(1):113–125, 1995.
Kuncak, Viktor and Martin Rinard.
Structural subtyping of non-recursive types is
decidable. In IEEE Symposium on Logic in Computer Science (LICS), Ottawa, Canada,
pages 96–107, June 2003.
Lafont, Yves. The linear abstract machine. Theoretical Computer Science, 59:157–180,
1988.

550
References
Lambek, Joachim. The mathematics of sentence structure. American Mathematical
Monthly, 65:154–170, 1958.
Lampson, Butler and Rod Burstall. Pebble, a kernel language for modules and abstract
data types. Information and Computation, 76:278–346, February/March 1988.
Lassen, Søren Bøgh. Relational Reasoning about Functions and Nondeterminism. PhD
thesis, Department of Computer Science, University of Aarhus, Aarhus, Denmark,
1998.
Lassez, Jean-Louis, Michael J. Maher, and Kim G. Marriott. Uniﬁcation revisited. In
J. Minker, editor, Foundations of Deductive Databases and Logic Programming,
pages 587–625. Morgan Kaufmann, 1988.
Lee, Oukseh and Kwangkeun Yi. Proofs about a folklore let-polymorphic type infer-
ence algorithm. ACM Transactions on Programming Languages and Systems, 20
(4):707–723, July 1998.
Leivant, Daniel.
Stratiﬁed functional programs and computational complexity.
In ACM SIGPLAN–SIGACT Symposium on Principles of Programming Languages
(POPL), Charleston, South Carolina, pages 325–333, January 1993.
Leroy, Xavier. Polymorphic typing of an algorithmic language. Research Report 1778,
INRIA, October 1992.
Leroy, Xavier. Manifest types, modules and separate compilation. In ACM SIGPLAN–
SIGACT Symposium on Principles of Programming Languages (POPL), Portland,
Oregon, pages 109–122, January 1994.
Leroy, Xavier.
Applicative functors and fully transparent higher-order modules.
In ACM SIGPLAN–SIGACT Symposium on Principles of Programming Languages
(POPL), San Francisco, California, pages 142–153, January 1995.
Leroy, Xavier. A syntactic theory of type generativity and sharing. Journal of Func-
tional Programming, 6(5):667–698, September 1996.
Leroy, Xavier. The Objective Caml system: Documentation and user’s manual, 2000.
With Damien Doligez, Jacques Garrigue, Didier Rémy, and Jérôme Vouillon. Avail-
able from http://caml.inria.fr.
Leroy, Xavier and François Pessaux.
Type-based analysis of uncaught exceptions.
ACM Transactions on Programming Languages and Systems, 22(2):340–377, March
2000. Summary in ACM SIGPLAN–SIGACT Symposium on Principles of Program-
ming Languages (POPL), San Antonio, Texas, 1999.
Lillibridge, Mark. Translucent Sums: A Foundation for Higher-Order Module Systems.
PhD thesis, School of Computer Science, Carnegie Mellon University, Pittsburgh,
Pennsylvania, May 1997.
Lindholm, Tim and Frank Yellin. The Java Virtual Machine Speciﬁcation. The Java
Series. Addison-Wesley, Reading, MA, January 1997.
Liskov, Barbara. A history of CLU. ACM SIGPLAN Notices, 28(3):133–147, 1993.

References
551
Loader, Ralph. Finitary PCF is not decidable. Theoretical Computer Science, 266(1–2):
341–364, September 2001.
Lucassen, John M. Types and Eﬀects towards the Integration of Functional and Impera-
tive Programming. PhD thesis, Massachusetts Institute of Technology, Cambridge,
Massachusetts, August 1987. Technical Report MIT-LCS-TR-408.
Lucassen, John M. and David K. Giﬀord. Polymorphic eﬀect systems. In ACM Sympo-
sium on Principles of Programming Languages (POPL), San Diego, California, pages
47–57, 1988.
Luo, Zhaohui.
Computation and Reasoning: A Type Theory for Computer Science.
Number 11 in International Series of Monographs on Computer Science. Oxford
University Press, 1994.
Luo, Zhaohui and Robert Pollack.
The LEGO proof development system: A user’s
manual. Technical Report ECS-LFCS-92-211, University of Edinburgh, May 1992.
MacQueen, David. Modules for Standard ML. In ACM Symposium on Lisp and Func-
tional Programming (LFP), Austin, Texas, pages 198–207, 1984.
MacQueen, David.
Using dependent types to express modular structure.
In ACM
Symposium on Principles of Programming Languages (POPL), St. Petersburg Beach,
Florida, pages 277–286, January 1986.
MacQueen, David B. and Mads Tofte. A semantics for higher-order functors. In Eu-
ropean Symposium on Programming (ESOP), Edinburgh, Scotland, volume 788 of
Lecture Notes in Computer Science, pages 409–423. Springer-Verlag, April 1994.
Magnusson, Lena and Bengt Nordström. The ALF proof editor and its proof engine. In
International Workshop on Types for Proofs and Programs (TYPES), Nijmegen, The
Netherlands, May, 1993, volume 806 of Lecture Notes in Computer Science, pages
213–237. Springer-Verlag, 1994.
Mairson, Harry G., Paris C. Kanellakis, and John C. Mitchell. Uniﬁcation and ML type
reconstruction. In J.-L. Lassez and G. Plotkin, editors, Computational Logic: Essays
in Honor of Alan Robinson, pages 444–478. MIT Press, 1991.
Makholm, Henning. Region-based memory management in Prolog. Master’s thesis,
University of Copenhagen, Department of Computer Science, March 2000. Techni-
cal Report DIKU-TR-00/09.
Makholm, Henning. A Language-Independend Framework for Region Inference. PhD
thesis, University of Copenhagen, Department of Computer Science, Copenhagen,
Denmark, 2003.
Makholm, Henning and Kostis Sagonas. On enabling the WAM with region support.
In International Conference on Logic Programming (ICLP), volume 2401 of Lecture
Notes in Computer Science, pages 163–178. Springer-Verlag, July 2002.
Martelli, Alberto and Ugo Montanari. Uniﬁcation in linear time and space: A struc-
tured presentation. Internal Report B76-16, Istituto di Elaborazione delle Infor-
mazione, Consiglio Nazionale delle Ricerche, Pisa, July 1976.

552
References
Martelli, Alberto and Ugo Montanari. An eﬃcient uniﬁcation algorithm. ACM Trans-
actions on Programming Languages and Systems, 4(2):258–282, 1982.
Martin-Löf, Per. Intuitionistic Type Theory. Bibliopolis, 1984.
Mason, Ian A., Scott F. Smith, and Carolyn L. Talcott. From operational semantics to
domain theory. Information and Computation, 128(1):26–47, 1996.
Mason, Ian A. and Carolyn L. Talcott. Equivalence in functional languages with eﬀects.
Journal of Functional Programming, 1:287–327, 1991.
McAllester, David. On the complexity analysis of static analyses. Journal of the ACM,
49(4):512–537, July 2002.
McAllester, David. A logical algorithm for ML type inference. In International Con-
ference on Rewriting Techniques and Applications (RTA), Valencia, Spain, volume
2706 of Lecture Notes in Computer Science, pages 436–451. Springer-Verlag, June
2003.
McBride, Conor. Dependently Typed Functional Programs and their Proofs. PhD thesis,
LFCS, University of Edinburgh, Edinburgh, Scotland, 2000.
McBride, Conor and James McKinna. The view from the left. Journal of Functional
Programming, 14(1):69–111, 2004.
McKinna, James and Robert Pollack. Pure Type Sytems formalized. In International
Conference on Typed Lambda Calculi and Applications (TLCA), Utrecht, The Nether-
lands, volume 664 of Lecture Notes in Computer Science, pages 289–305. Springer-
Verlag, March 1993.
Melski, David and Thomas Reps.
Interconvertibility of a class of set constraints
and context-free language reachability.
Theoretical Computer Science, 248(1–2),
November 2000.
Milner, Robin. A theory of type polymorphism in programming. Journal of Computer
and System Sciences, 17:348–375, August 1978.
Milner, Robin, Mads Tofte, and Robert Harper. The Deﬁnition of Standard ML. MIT
Press, 1990.
Milner, Robin, Mads Tofte, Robert Harper, and David MacQueen. The Deﬁnition of
Standard ML, Revised edition. MIT Press, 1997.
Minamide, Yasuhiko.
A functional representation of data structures with a hole.
In ACM SIGPLAN–SIGACT Symposium on Principles of Programming Languages
(POPL), San Diego, California, pages 75–84, January 1998.
Minamide, Yasuhiko, Greg Morrisett, and Robert Harper. Typed closure conversion.
In ACM SIGPLAN–SIGACT Symposium on Principles of Programming Languages
(POPL), St. Petersburg Beach, Florida, pages 271–283, January 1996.
Miquel, Alexandre. Le calcul des constructions implicite: syntaxe et sémantique. PhD
thesis, University Paris 7, Paris, France, 2001.
Mitchell, John C.
Coercion and type inference.
In ACM Symposium on Principles
of Programming Languages (POPL), Salt Lake City, Utah, pages 175–185, January
1984.

References
553
Mitchell, John C. Representation independence and data abstraction. In ACM Sympo-
sium on Principles of Programming Languages (POPL), St. Petersburg Beach, Florida,
pages 263–276, January 1986.
Mitchell, John C. On the equivalence of data representations. In V. Lifschitz, editor,
Artiﬁcial Intelligence and Mathematical Theory of Computation: Papers in Honor of
John McCarthy, pages 305–330. Academic Press, 1991a.
Mitchell, John C. Type inference with simple subtypes. Journal of Functional Pro-
gramming, 1(3):245–286, July 1991b.
Mitchell, John C. Foundations for Programming Languages. MIT Press, 1996.
Mitchell, John C. and Gordon D. Plotkin. Abstract types have existential types. ACM
Transactions on Programming Languages and Systems, 10(3):470–502, 1988. Sum-
mary in ACM Symposium on Principles of Programming Languages (POPL), New
Orleans, Louisiana, 1985.
Moggi, Eugenio. Computational lambda-calculus and monads. In IEEE Symposium
on Logic in Computer Science (LICS), Asilomar, California, pages 14–23, June 1989.
Full version, titled Notions of Computation and Monads, in Information and Com-
putation, 93(1), pp. 55–92, 1991.
Moh, Shaw-Kwei. The deduction theorems and two new logical systems. Methodos, 2:
56–75, 1950.
Mohring, Christine. Algorithm development in the calculus of constructions. In IEEE
Symposium on Logic in Computer Science (LICS), Cambridge, Massachusetts, pages
84–91, June 1986.
Monnier, Stefan, Bratin Saha, and Zhong Shao. Principled scavenging. In ACM SIG-
PLAN Conference on Programming Language Design and Implementation (PLDI),
Snowbird, Utah, pages 81–91, June 2001.
Morrisett, Greg, Karl Crary, Neal Glew, and David Walker. Stack-based typed assembly
language. Journal of Functional Programming, 12(1):43–88, January 2002.
Morrisett, Greg, David Walker, Karl Crary, and Neal Glew. From System-F to typed
assembly language. ACM Transactions on Programming Languages and Systems,
21(3):527–568, May 1999.
Mossin, Christian. Flow Analysis of Typed Higher-Order Programs. PhD thesis, Uni-
versity of Copenhagen, Department of Computer Science, Copenhagen, Denmark,
1997. Also available as Technical Report DIKU-TR-97/1.
Müller, Martin. A constraint-based recast of ML-polymorphism. In International Work-
shop on Uniﬁcation, June 1994. Also available as Technical Report 94-R-243, CRIN,
Nancy, France.
Müller, Martin.
Notes on HM(X), August 1998.
Available from http://www.ps.
uni-sb.de/~mmueller/papers/HMX.ps.gz.
Müller, Martin, Joachim Niehren, and Ralf Treinen. The ﬁrst-order theory of ordering
constraints over feature trees.
Discrete Mathematics and Theoretical Computer
Science, 4(2):193–234, 2001.

554
References
Müller, Martin and Susumu Nishimura. Type inference for ﬁrst-class messages with
feature constraints. In Asian Computer Science Conference (ASIAN), Manila, The
Philippines, volume 1538 of Lecture Notes in Computer Science, pages 169–187.
Springer-Verlag, December 1998.
Mycroft, Alan. Polymorphic type schemes and recursive deﬁnitions. In International
Symposium on Programming, Toulouse, France, volume 167 of Lecture Notes in
Computer Science, pages 217–228, Toulouse, France, April 1984. Springer-Verlag.
Necula, George C. Proof-carrying code. In ACM SIGPLAN–SIGACT Symposium on Prin-
ciples of Programming Languages (POPL), Paris, France, pages 106–119, January
1997.
Necula, George C. Compiling with Proofs. PhD thesis, Carnegie Mellon University,
Pittsburgh, Pennsylvania, September 1998. Technical report CMU-CS-98-154.
Necula, George C. Translation validation for an optimizing compiler. In ACM SIG-
PLAN Conference on Programming Language Design and Implementation (PLDI),
Vancouver, British Columbia, Canada, pages 83–94, June 2000.
Necula, George C. and Peter Lee. Safe kernel extensions without run-time checking.
In USENIX Symposium on Operating Systems Design and Implementation (OSDI),
Seattle, Washington, pages 229–243, October 1996.
Necula, George C. and Peter Lee.
The design and implementation of a certifying
compiler.
In ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI), Montréal, Québec, pages 333–344, June 1998a.
Necula, George C. and Peter Lee. Eﬃcient representation and validation of logical
proofs. In IEEE Symposium on Logic in Computer Science (LICS), Indianapolis, Indi-
ana, pages 93–104, June 1998b.
Niehren, Joachim, Martin Müller, and Andreas Podelski. Inclusion constraints over
non-empty sets of trees. In Theory and Practice of Software Development (TAP-
SOFT), Lille, France, volume 1214 of Lecture Notes in Computer Science, pages
217–231. Springer-Verlag, April 1997.
Niehren, Joachim and Tim Priesnitz. Non-structural subtype entailment in automata
theory. Information and Computation, 186(2):319–354, November 2003.
Nielson, Flemming and Hanne Riis Nielson. From CML to its process algebra. Theo-
retical Computer Science, 155:179–219, 1996.
Nielson, Flemming, Hanne Riis Nielson, and Christopher L. Hankin. Principles of Pro-
gram Analysis. Springer-Verlag, 1999.
Nielson, Flemming, Hanne Riis Nielson, and Helmut Seidl. A succinct solver for ALFP.
Nordic Journal of Computing, 9(4):335–372, 2002.
Nielson, Hanne Riis and Flemming Nielson. Higher-order concurrent programs with
ﬁnite communication topology. In ACM SIGPLAN–SIGACT Symposium on Principles
of Programming Languages (POPL), Portland, Oregon, pages 84–97, January 1994.

References
555
Nishimura, Susumu. Static typing for dynamic messages. In ACM SIGPLAN–SIGACT
Symposium on Principles of Programming Languages (POPL), San Diego, California,
pages 266–278, 1998.
Niss, Henning.
Regions are Imperative: Unscoped Regions and Control-Flow Sensi-
tive Memory Management. PhD thesis, University of Copenhagen, Department of
Computer Science, Copenhagen, Denmark, 2002.
Nöcker, Erick and Sjaak Smetsers. Partially strict non-recursive data types. Journal
of Functional Programming, 3(2):191–215, 1993.
Nöcker, Erick G. M. H., Sjaak E. W. Smetsers, Marko C. J. D. van Eekelen, and Mari-
nus J. Plasmeijer. Concurrent clean. In Symposium on Parallel Architectures and
Languages Europe, Volume I: Parallel Architectures and Algorithms (PARLE), Eind-
hoven, The Netherlands, volume 505 of Lecture Notes in Computer Science, pages
202–219. Springer-Verlag, June 1991.
Odersky, Martin. Observers for linear types. In European Symposium on Program-
ming (ESOP), Rennes, France, volume 582 of Lecture Notes in Computer Science,
pages 390–407. Springer-Verlag, February 1992.
Odersky, Martin, Vincent Cremet, Christine Rockl, and Matthias Zenger. A nominal
theory of objects with dependent types. In International Workshop on Foundations
of Object-Oriented Languages (FOOL), informal proceedings, 2003.
Odersky, Martin, Martin Sulzmann, and Martin Wehr. Type inference with constrained
types. Theory and Practice of Object Systems, 5(1):35–55, 1999. Summary in Inter-
national Workshop on Foundations of Object-Oriented Languages (FOOL), informal
proceedings, 1997.
O’Hearn, Peter. On bunched typing. Journal of Functional Programming, 13(4):747–
796, 2003.
O’Hearn, Peter and David Pym. The logic of bunched implications. Bulletin of Symbolic
Logic, 5(2):215–244, 1999.
Ohori, Atsushi. A polymorphic record calculus and its compilation. ACM Transac-
tions on Programming Languages and Systems, 17(6):844–895, November 1995.
Ohori, Atsushi and Peter Buneman. Type inference in a database programming lan-
guage. In ACM Symposium on Lisp and Functional Programming (LFP), Snowbird,
Utah, pages 174–183, July 1988.
Ohori, Atsushi and Peter Buneman. Static type inference for parametric classes. In
Conference on Object Oriented Programming: Systems, Languages, and Applica-
tions (OOPSLA), New Orleans, Louisiana, pages 445–456, October 1989. Also in C.
A. Gunter and J. C. Mitchell, editors, Theoretical Aspects of Object-Oriented Pro-
gramming: Types, Semantics, and Language Design, MIT Press, 1994.
Orlov, Ivan E. The calculus of compatibility of propositions (in Russian). Matematich-
eskii Sbornik, 35:263–286, 1928.

556
References
Owre, Sam, Sreeranga Rajan, John M. Rushby, Natarajan Shankar, and Mandayam K.
Srivas.
PVS: Combining speciﬁcation, proof checking, and model checking.
In
International Conference on Computer Aided Veriﬁcation (CAV), New Brunswick,
New Jersey, volume 1102 of Lecture Notes in Computer Science, pages 411–414.
Springer-Verlag, July 1996.
Palsberg, Jens. Eﬃcient inference of object types. Information and Computation, 123
(2):198–209, 1995.
Palsberg, Jens.
Type-based analysis and applications.
In ACM SIGPLAN–SIGSOFT
Workshop on Program Analysis for Software Tools and Engineering (PASTE), Snow-
bird, Utah, pages 20–27, June 2001.
Palsberg, Jens and Patrick O’Keefe. A type system equivalent to ﬂow analysis. In ACM
SIGPLAN–SIGACT Symposium on Principles of Programming Languages (POPL), San
Francisco, California, pages 367–378, 1995.
Palsberg, Jens and Michael Schwartzbach.
Type substitution for object-oriented
programming.
In ACM SIGPLAN Conference on Object Oriented Programming:
Systems, Languages, and Applications (OOPSLA)/European Conference on Object-
Oriented Programming (ECOOP), Ottawa, Ontario, volume 25(10) of ACM SIGPLAN
Notices, pages 151–160, October 1990.
Palsberg, Jens and Michael I. Schwartzbach. Object-Oriented Type Systems. Wiley,
1994.
Palsberg, Jens, Mitchell Wand, and Patrick M. O’Keefe.
Type inference with non-
structural subtyping. Formal Aspects of Computing, 9:49–67, 1997.
Parnas, David. The criteria to be used in decomposing systems into modules. Com-
munications of the ACM, 14(1):221–227, 1972.
Paterson, Michael S. and Mark N. Wegman. Linear uniﬁcation. Journal of Computer
and System Sciences, 16:158–167, 1978.
Paulin-Mohring, Christine.
Extracting Fω’s programs from proofs in the calculus
of constructions.
In ACM Symposium on Principles of Programming Languages
(POPL), Austin, Texas, pages 89–104, January 1989.
Petersen, Leaf, Perry Cheng, Robert Harper, and Chris Stone. Implementing the TILT
internal language. Technical Report CMU-CS-00-180, Department of Computer Sci-
ence, Carnegie Mellon University, 2000.
Petersen, Leaf, Robert Harper, Karl Crary, and Frank Pfenning.
A type theory for
memory allocation and data layout. In ACM SIGPLAN–SIGACT Symposium on Prin-
ciples of Programming Languages (POPL), New Orleans, Louisiana, pages 172–184,
January 2003.
Peyton Jones, Simon.
Special issue: Haskell 98 language and libraries. Journal of
Functional Programming, 13, January 2003.
Pfenning, Frank and Rowan Davies.
A judgmental reconstruction of modal logic.
Mathematical Structures in Computer Science, 11(4):511–540, 2001.

References
557
Pfenning, Frank and Carsten Schürmann.
Algorithms for equality and uniﬁcation
in the presence of notational deﬁnitions.
In T. Altenkirch, W. Naraschewski,
and B. Reus, editors, International Workshop on Types for Proofs and Programs
(TYPES), Kloster Irsee, Germany, volume 1657 of Lecture Notes in Computer Sci-
ence. Springer-Verlag, 1998.
Pierce, Benjamin C. Types and Programming Languages. MIT Press, 2002.
Pierce, Benjamin C. and David N. Turner. Object-oriented programming without re-
cursive types. In ACM SIGPLAN–SIGACT Symposium on Principles of Programming
Languages (POPL), Charleston, South Carolina, pages 299–312, January 1993.
Pitts, Andrew M. Relational properties of domains. Information and Computation,
127:66–90, 1996.
Pitts, Andrew M.
Existential types: Logical relations and operational equivalence.
In International Colloquium on Automata, Languages and Programming (ICALP),
Aalborg, Denmark, volume 1443 of Lecture Notes in Computer Science, pages 309–
326. Springer-Verlag, 1998.
Pitts, Andrew M. Parametric polymorphism and operational equivalence. Mathemat-
ical Structures in Computer Science, 10:321–359, 2000.
Pitts, Andrew M. Operational semantics and program equivalence. In G. Barthe, P. Dy-
bjer, and J. Saraiva, editors, Applied Semantics, Advanced Lectures, volume 2395 of
Lecture Notes in Computer Science, Tutorial, pages 378–412. Springer-Verlag, 2002.
Pitts, Andrew M. and Ian D. B. Stark. Observable properties of higher order functions
that dynamically create local names, or: What’s new? In International Symposium
on Mathematical Foundations of Computer Science, Gda´nsk, Poland, volume 711 of
Lecture Notes in Computer Science, pages 122–141. Springer-Verlag, 1993.
Pitts, Andrew M. and Ian D. B. Stark. Operational reasoning for functions with local
state. In A. D. Gordon and A. M. Pitts, editors, Higher-Order Operational Techniques
in Semantics, Publications of the Newton Institute, pages 227–273. Cambridge Uni-
versity Press, 1998.
Plotkin, Gordon D. Lambda-deﬁnability and logical relations. Memorandum SAI–RM–
4, University of Edinburgh, Edinburgh, Scotland, October 1973.
Plotkin, Gordon D. LCF considered as a programming language. Theoretical Computer
Science, 5:223–255, 1977.
Plotkin, Gordon D.
Lambda-deﬁnability in the full type hierarchy.
In J. P. Seldin
and J. R. Hindley, editors, To H. B. Curry: Essays on Combinatory Logic, Lambda
Calculus and Formalism, pages 363–373. Academic Press, 1980.
Plotkin, Gordon D. and Martín Abadi. A logic for parametric polymorphism. In In-
ternational Conference on Typed Lambda Calculi and Applications (TLCA), Utrecht,
The Netherlands, volume 664 of Lecture Notes in Computer Science, pages 361–375.
Springer-Verlag, March 1993.

558
References
Polakow, Jeﬀand Frank Pfenning.
Natural deduction for intuitionistic non-
commutative linear logic. In International Conference on Typed Lambda Calculi
and Applications (TLCA), L’Aquila, Italy, volume 1581 of Lecture Notes in Computer
Science, pages 295–309. Springer-Verlag, April 1999.
Poll, Erik. Expansion Postponement for Normalising Pure Type Systems. Journal of
Functional Programming, 8(1):89–96, 1998.
Pollack, Robert. The Theory of LEGO: A Proof Checker for the Extended Calculus of
Constructions. PhD thesis, University of Edinburgh, Edinburgh, Scotland, 1994.
Popkorn, Sally. First Steps in Modal Logic. Cambridge University Press, 1994.
Pottier, François. A versatile constraint-based type inference system. Nordic Journal
of Computing, 7(4):312–347, November 2000.
Pottier, François.
A semi-syntactic soundness proof for HM(X).
Research Report
4150, INRIA, March 2001a.
Pottier, François. Simplifying subtyping constraints: a theory. Information and Com-
putation, 170(2):153–183, November 2001b.
Pottier, François. A constraint-based presentation and generalization of rows. In IEEE
Symposium on Logic in Computer Science (LICS), Ottawa, Canada, pages 331–340,
June 2003.
Pottier, François and Vincent Simonet. Information ﬂow inference for ML. ACM Trans-
actions on Programming Languages and Systems, 25(1):117–158, January 2003.
Pottier, François, Christian Skalka, and Scott Smith. A systematic approach to static
access control. In European Symposium on Programming (ESOP), Genova, Italy,
volume 2028 of Lecture Notes in Computer Science, pages 30–45. Springer-Verlag,
April 2001.
Pratt, Vaughan and Jerzy Tiuryn. Satisﬁability of inequalities in a poset. Fundamenta
Informaticae, 28(1–2):165–182, 1996.
Pugh, William and Grant Weddell.
Two-directional record layout for multiple in-
heritance. In ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI), White Plains, New York, pages 85–91, June 1990.
Rajamani, Sriram K. and Jakob Rehof. A behavioral module system for the pi-calculus.
In International Symposium on Static Analysis (SAS) , Paris, France, volume 2126 of
Lecture Notes in Computer Science, pages 375–394. Springer-Verlag, July 2001.
Rajamani, Sriram K. and Jakob Rehof. Conformance checking for models of asyn-
chronous message passing software.
In International Conference on Computer
Aided Veriﬁcation (CAV), Copenhagen, Denmark, pages 166–179, July 2002.
Rehof, Jakob. Minimal typings in atomic subtyping. In ACM SIGPLAN–SIGACT Sym-
posium on Principles of Programming Languages (POPL), Paris, France, pages 278–
291, January 1997.
Rehof, Jakob and Manuel Fähndrich. Type-based ﬂow analysis: From polymorphic
subtyping to CFL reachability. In ACM SIGPLAN–SIGACT Symposium on Principles
of Programming Languages (POPL), London, England, pages 54–66, 2001.

References
559
Reid, Alastair, Matthew Flatt, Leigh Stoller, Jay Lepreau, and Eric Eide. Knit: Com-
ponent composition for systems software.
In USENIX Symposium on Operating
Systems Design and Implementation (OSDI), San Diego, California, pages 347–360,
October 2000.
Rémy, Didier. Typechecking records and variants in a natural extension of ML. In
ACM Symposium on Principles of Programming Languages (POPL), Austin, Texas,
pages 242–249, January 1989. Long version in C. A. Gunter and J. C. Mitchell, ed-
itors, Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and
Language Design, MIT Press, 1994.
Rémy, Didier. Algèbres Touﬀues. Application au Typage Polymorphe des Objets Enreg-
istrements dans les Langages Fonctionnels. PhD thesis, Université Paris VII, 1990.
Rémy, Didier. Extending ML type system with a sorted equational theory. Research
Report 1766, Institut National de Recherche en Informatique et Automatisme, Roc-
quencourt, BP 105, 78 153 Le Chesnay Cedex, France, 1992a.
Rémy, Didier. Projective ML. In ACM Symposium on Lisp and Functional Programming
(LFP), San Francisco, California, pages 66–75, June 1992b.
Rémy, Didier. Syntactic theories and the algebra of record terms. Research Report
1869, Institut National de Recherche en Informatique et Automatisme, Rocquen-
court, BP 105, 78 153 Le Chesnay Cedex, France, 1993.
Rémy, Didier. Programming objects with ML-ART: An extension to ML with abstract
and record types. In International Symposium on Theoretical Aspects of Computer
Software (TACS), Sendai, Japan, volume 789 of Lecture Notes in Computer Science,
pages 321–346. Springer-Verlag, April 1994.
Rémy, Didier and Jérôme Vouillon. Objective ML: An eﬀective object-oriented exten-
sion to ML. Theory And Practice of Object Systems, 4(1):27–50, 1998. Summary
in ACM SIGPLAN–SIGACT Symposium on Principles of Programming Languages
(POPL), Paris, France, 1997.
van Renesse, Robbert, Kenneth P. Birman, Mark Hayden, Alexey Vaysburd, and David
Karr. Building adaptive systems using Ensemble. Software: Practice and Experience,
28(9):963–979, August 1998.
Restall, Greg. An Introduction to Substructural Logics. Routledge, February 2000.
Restall, Greg. Relevant and substructural logics. In D. Gabbay and J. Woods, editors,
Handbook of the History and Philosophy of Logic, volume 6, Logic and the Modalities
in the Twentieth Century. Elsevier, 2005. To appear.
Reynolds, John C. Automatic computation of data set deﬁnitions. In Information
Processing 68, Edinburgh, Scotland, volume 1, pages 456–461. North Holland, 1969.
Reynolds, John C. Towards a theory of type structure. In Colloque sur la Programma-
tion, Paris, France, volume 19 of Lecture Notes in Computer Science, pages 408–425.
Springer-Verlag, 1974.

560
References
Reynolds, John C. Syntactic control of interference. In ACM Symposium on Principles
of Programming Languages (POPL), Tucson, Arizona, pages 39–46, January 1978.
Reprinted in O’Hearn and Tennent, ALGOL-like Languages, vol. 1, pages 273–286,
Birkhäuser, 1997.
Reynolds, John C.
Types, abstraction, and parametric polymorphism.
In R. E. A.
Mason, editor, Information Processing 83, Paris, France, pages 513–523. Elsevier,
1983.
Reynolds, John C. Syntactic control of interference, part 2. Report CMU-CS-89-130,
Carnegie Mellon University, April 1989.
Reynolds, John C. Intuitionistic reasoning about shared mutable data structure. In
J. Davies, A. W. Roscoe, and J. Woodcock, editors, Millennial Perspectives in Com-
puter Science: Proceedings of the 1999 Oxford-Microsoft Symposium in honour of
Sir Tony Hoare. Palgrave Macmillan, 2000.
Robinson, J. Alan. Computational logic: The uniﬁcation computation. Machine Intel-
ligence, 6:63–72, 1971.
Ross, Douglas T. The AED free storage package. Communications of the ACM, 10(8):
481–492, 1967.
Russo, Claudio V. Types for Modules. PhD thesis, Edinburgh University, Edinburgh,
Scotland, 1998. LFCS Thesis ECS–LFCS–98–389.
Russo, Claudio V. Non-dependent types for standard ML modules. In ACM SIGPLAN
International Conference on Principles and Practice of Declarative Programming
(PPDP), Paris France, pages 80–97, September 1999.
Russo, Claudio V. Recursive structures for Standard ML. In ACM SIGPLAN Interna-
tional Conference on Functional Programming (ICFP), Firenze, Italy, pages 50–61,
September 2001.
Sabry, Amr. What is a purely functional language? Journal of Functional Program-
ming, 8(1):1–22, January 1998.
Saha, Bratin, Nevin Heintze, and Dino Oliva. Subtransitive CFA using types. Technical
Report YALEU/DCS/TR-1166, Yale University, Department of Computer Science,
October 1998.
Sangiorgi, Davide and David. The π-Calculus: a Theory of Mobile Processes. Cam-
bridge University Press, 2001.
Sannella, Donald, Stefan Sokolowski, and Andrzej Tarlecki. Toward formal develop-
ment of programs from algebraic speciﬁcations: Parameterisation revisited. Acta
Informatica, 29(8):689–736, 1992.
Schneider, Fred B. Enforceable security policies. ACM Transactions on Information
and System Security, 3(1):30–50, February 2000.
Schwartz, Jacob T. Optimization of very high level languages (parts I and II). Com-
puter Languages, 1(2–3):161–194, 197–218, 1975.

References
561
Seldin, Jonathan. Curry’s anticipation of the types used in programming languages.
In Proceedings of the Annual Meeting of the Canadian Society for History and Phi-
losophy of Mathematics, Toronto, Ontario, pages 143–163, May 2002.
Semmelroth, Miley and Amr Sabry. Monadic encapsulation in ML. In ACM SIGPLAN
International Conference on Functional Programming (ICFP), Paris, France, pages
8–17, September 1999.
Sestoft, Peter. Replacing function parameters by global variables. In ACM Sympo-
sium on Functional Programming Languages and Computer Architecture (FPCA),
London, England, pages 39–53, September 1989. Also available as University of
Copenhagen, Department of Computer Science Technical Report 88-7-2.
Sestoft, Peter.
Moscow ML homepage, 2003.
http://www.dina.dk/~sestoft/
mosml.html.
Severi, Paula and Erik Poll. Pure type systems with deﬁnitions. In International Sym-
posium on Logical Foundations of Computer Science (LFCS), St. Petersburg, Russia,
volume 813 of Lecture Notes in Computer Science, pages 316–328. Springer-Verlag,
September 1994.
Shao, Zhong. An overview of the FLINT/ML compiler. In ACM SIGPLAN Workshop on
Types in Compilation (TIC), Amsterdam, The Netherlands, June 1997.
Shao, Zhong. Typed cross-module compilation. In ACM SIGPLAN International Con-
ference on Functional Programming (ICFP), Baltimore, Maryland, pages 141–152,
September 1998.
Shao, Zhong. Transparent modules with fully syntactic signatures. In ACM SIGPLAN
International Conference on Functional Programming (ICFP), Paris, France, pages
220–232, September 1999.
Shao, Zhong, Christopher League, and Stefan Monnier.
Implementing typed inter-
mediate languages. In ACM SIGPLAN International Conference on Functional Pro-
gramming (ICFP), Baltimore, Maryland, pages 313–323, September 1998.
Shivers, Olin. Control ﬂow analysis in Scheme. In ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation (PLDI), Atlanta, Georgia, pages
164–174, June 1988.
Shivers, Olin. Control-Flow Analysis of Higher-Order Languages or Taming Lambda.
PhD thesis, Carnegie Mellon University, Pittsburgh, Pennsylvania, May 1991.
Simonet, Vincent. Type inference with structural subtyping: a faithful formalization
of an eﬃcient constraint solver. In Asian Symposium on Programming Languages
and Systems (APLAS), Beijing, China, pages 283–302, November 2003.
Skalka, Christian and François Pottier. Syntactic type soundness for HM(X). In Work-
shop on Types in Programming (TIP), Dagstuhl, Germany, volume 75 of Electronic
Notes in Theoretical Computer Science. Elsevier, July 2002.
Smith, Frederick, David Walker, and Greg Morrisett. Alias types. In European Sym-
posium on Programming (ESOP), Berlin, Germany, volume 1782 of Lecture Notes in
Computer Science, pages 366–381. Springer-Verlag, April 2000.

562
References
Smith, Geoﬀrey S. Principal type schemes for functional programs with overloading
and subtyping.
Science of Computer Programming, 23(2–3):197–226, December
1994.
Smith, Jan, Bengt Nordström, and Kent Petersson. Programming in Martin-Löf’s Type
Theory: An Introduction. Oxford University Press, 1990.
Statman, Richard. Logical relations and the typed λ-calculus. Information and Con-
trol, 65(2–3):85–97, May–June 1985.
Steele, Guy L., Jr. Common Lisp: The Language. Digital Press, 1990.
Stone, Christopher A.
Singleton Kinds and Singleton Types.
PhD thesis, Carnegie
Mellon University, Pittsburgh, Pennsylvania, August 2000.
Stone, Christopher A. and Robert Harper. Deciding type equivalence in a language
with singleton kinds. In ACM SIGPLAN–SIGACT Symposium on Principles of Pro-
gramming Languages (POPL), Boston, Massachusetts, pages 214–227, January 2000.
Stone, Christopher A. and Robert Harper.
Extensional equivalence and singleton
types. 2005. To appear.
Streicher, Thomas. Semantics of Type Theory. Springer-Verlag, 1991.
Su, Zhendong, Alexander Aiken, Joachim Niehren, Tim Priesnitz, and Ralf Treinen.
The ﬁrst-order theory of subtyping constraints. In ACM SIGPLAN–SIGACT Sym-
posium on Principles of Programming Languages (POPL), Portland, Oregon, pages
203–216, January 2002.
Sulzmann, Martin. A General Framework for Hindley/Milner Type Systems with Con-
straints. PhD thesis, Yale University, Department of Computer Science, New Haven,
Connecticut, May 2000.
Sulzmann, Martin, Martin Müller, and Christoph Zenger. Hindley/Milner style type
systems in constraint form. Research Report ACRC–99–009, University of South
Australia, School of Computer and Information Science, July 1999.
Sumii, Eijiro and Benjamin C. Pierce.
A bisimulation for type abstraction and re-
cursion. In ACM SIGPLAN–SIGACT Symposium on Principles of Programming Lan-
guages (POPL), Long Beach, California, 2005.
Sun.
JavaTM 2 Platform Micro Edition (J2METM) Technology for Creating Mobile
Devices—White Paper. Sun Microsystems, May 2000. Available from http://java.
sun.com/products/kvm/wp/KVMwp.pdf.
Tait, William W. Intensional interpretations of functionals of ﬁnite type I. Journal of
Symbolic Logic, 32(2):198–212, June 1967.
Talcott, C. Reasoning about functions with eﬀects. In A. D. Gordon and A. M. Pitts,
editors, Higher Order Operational Techniques in Semantics, Publications of the
Newton Institute, pages 347–390. Cambridge University Press, 1998.
Talpin, Jean-Pierre and Pierre Jouvelot. Polymorphic type, region and eﬀect inference.
Journal of Functional Programming, 2(2):245–271, 1992.

References
563
Talpin, Jean-Pierre and Pierre Jouvelot. The type and eﬀect discipline. Information
and Computation, 111:245–296, 1994.
Tarditi, David, Greg Morrisett, Perry Cheng, Christopher Stone, Robert Harper, and
Peter Lee. TIL: A type-directed optimizing compiler for ML. In ACM SIGPLAN Con-
ference on Programming Language Design and Implementation (PLDI), Philadephia,
Pennsylvania, pages 181–192, May 1996.
Tarjan, Robert Endre. Eﬃciency of a good but not linear set union algorithm. Journal
of the ACM, 22(2):215–225, April 1975.
Tarjan, Robert Endre. Applications of path compression on balanced trees. Journal
of the ACM, 26(4):690–715, October 1979.
Terlouw, J. Een nadere bewijstheoretische analyse van GSTTs. Manuscript, University
of Nijmegen, Netherlands, 1989.
Thorup, Kresten Krab. Genericity in Java with virtual types.
In European Confer-
ence on Object-Oriented Programming (ECOOP), Jyväskylä, Finland, volume 1241
of Lecture Notes in Computer Science, pages 444–471. Springer-Verlag, June 1997.
Tiuryn, Jerzy. Subtype inequalities. In IEEE Symposium on Logic in Computer Science
(LICS), Santa Cruz, California, pages 308–317, June 1992.
Tiuryn, Jerzy and Mitchell Wand.
Type reconstruction with recursive types and
atomic subtyping.
In Theory and Practice of Software Development (TAPSOFT),
Orsay, France, volume 668 of Lecture Notes in Computer Science, pages 686–701.
Springer-Verlag, April 1993.
Tofte, Mads.
Operational Semantics and Polymorphic Type Inference.
PhD thesis,
Computer Science Department, Edinburgh University, Edinburgh, Scotland, 1988.
Tofte, Mads and Lars Birkedal. A region inference algorithm. ACM Transactions on
Programming Languages and Systems, 20(4):724–767, 1998.
Tofte, Mads, Lars Birkedal, Martin Elsman, and Niels Hallenberg. Region-based mem-
ory management in perspective.
In ACM SIGPLAN International Conference on
Principles and Practice of Declarative Programming (PPDP), Firenze, Italy, pages
175–186, September 2001a.
Tofte, Mads, Lars Birkedal, Martin Elsman, Niels Hallenberg, Tommy Højfeld Olesen,
and Peter Sestoft. Programming with regions in the ML Kit (for version 4). Technical
report, IT University of Copenhagen, October 2001b.
Tofte, Mads and Jean-Pierre Talpin. Implementing the call-by-value lambda-calculus
using a stack of regions. In ACM SIGPLAN–SIGACT Symposium on Principles of
Programming Languages (POPL), Portland, Oregon, January 1994.
Tofte, Mads and Jean-Pierre Talpin. Region-based memory management. Information
and Computation, 132(2):109–176, February 1997.
Torgersen, Mads. Virtual types are statically safe. In International Workshop on Foun-
dations of Object-Oriented Languages (FOOL), informal proceedings, January 1998.

564
References
Trifonov, Valery and Scott Smith. Subtyping constrained types. In International Sym-
posium on Static Analysis (SAS) , Aachen, Germany, volume 1145 of Lecture Notes
in Computer Science, pages 349–365. Springer-Verlag, September 1996.
Turner, David N. and Philip Wadler. Operational interpretations of linear logic. The-
oretical Computer Science, 227:231–248, 1999. Special issue on linear logic.
Turner, David N., Philip Wadler, and Christian Mossin. Once upon a type. In ACM
Symposium on Functional Programming Languages and Computer Architecture
(FPCA)San Diego, California, pages 1–11, June 1995.
Vouillon, Jerome and Paul-André Melliès. Semantic types: A fresh look at the ideal
model for types. In ACM SIGPLAN–SIGACT Symposium on Principles of Program-
ming Languages (POPL), Venice, Italy, pages 52–63, 2004.
Wadler, Philip. Theorems for free! In ACM Symposium on Functional Programming
Languages and Computer Architecture (FPCA), London, England, pages 347–359,
September 1989.
Wadler, Philip. Linear types can change the world. In IFIP TC 2 Working Conference
on Programming Concepts and Methods, Sea of Galilee, Israel, pages 546–566, April
1990.
Wadler, Philip. The marriage of eﬀects and monads. ACM Transactions on Computa-
tional Logic, 4(1):1–32, 2003.
Wahbe, Robert, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. Eﬃcient
software-based fault isolation. In ACM Symposium on Operating Systems Principles
(SOSP), Asheville, North Carolina, pages 203–216, December 1993.
Walker, David, Karl Crary, and Greg Morrisett. Typed memory management via static
capabilities. ACM Transactions on Programming Languages and Systems, 22(4):
701–771, July 2000.
Walker, David and Greg Morrisett. Alias types for recursive data structures. In ACM
SIGPLAN Workshop on Types in Compilation (TIC), Montréal, Québec, September,
2000, volume 2071, pages 177–206. Springer-Verlag, 2001.
Walker, David and Kevin Watkins. On regions and linear types. In ACM SIGPLAN
International Conference on Functional Programming (ICFP), Firenze, Italy, pages
181–192, September 2001.
Wand, Mitchell. Complete type inference for simple objects. In IEEE Symposium on
Logic in Computer Science (LICS), Ithaca, New York, pages 37–44, June 1987a.
Wand, Mitchell. A simple algorithm and proof for type inference. Fundamenta Infor-
maticae, 10:115–122, 1987b.
Wand, Mitchell. Corrigendum: Complete type inference for simple objects. In IEEE
Symposium on Logic in Computer Science (LICS), Edinburgh, Scotland, page 132,
1988.
Wand, Mitchell. Type inference for objects with instance variables and inheritance.
In C. A. Gunter and J. C. Mitchell, editors, Theoretical Aspects of Object-Oriented

References
565
Programming: Types, Semantics, and Language Design, pages 97–120. MIT Press,
1994.
Wang, Daniel C. and Andrew W. Appel. Type-preserving garbage collectors. In ACM
SIGPLAN–SIGACT Symposium on Principles of Programming Languages (POPL),
London, England, pages 166–178, January 2001.
Wansbrough, Keith and Simon Peyton Jones. Once upon a polymorphic type. In ACM
SIGPLAN–SIGACT Symposium on Principles of Programming Languages (POPL), San
Antonio, Texas, pages 15–28, January 1999.
Wells, Joe B. Typability and type checking in system F are equivalent and undecidable.
Annals of Pure and Applied Logic, 98(1–3):111–156, 1999.
Wells, Joe B. The essence of principal typings. In International Colloquium on Au-
tomata, Languages and Programming (ICALP), volume 2380 of Lecture Notes in
Computer Science, pages 913–925. Springer-Verlag, 2002.
Werner, Benjamin. Une Théorie des Constructions Inductives. PhD thesis, Université
Paris 7, Paris, France, May 1994.
Wirth, Niklaus. Systematic Programming: An Introduction. Prentice Hall, 1973.
Wirth, Niklaus. Programming in Modula-2. Texts and Monographs in Computer Sci-
ence. Springer-Verlag, 1983.
Wright, Andrew K. Simple imperative polymorphism. Lisp and Symbolic Computation,
8(4):343–355, 1995.
Wright, Andrew K. and Robert Cartwright. A practical soft type system for Scheme.
In ACM Symposium on Lisp and Functional Programming (LFP), Orlando, Florida,
pages 250–262, June 1994. Full version available in ACM Transactions on Program-
ming Languages and Systems, 19(1):87–52, January 1997.
Wright, Andrew K. and Matthias Felleisen. A syntactic approach to type soundness.
Information and Computation, 115(1):38–94, November 1994.
Xi, Hongwei. Dependent Types in Practical Programming. PhD thesis, Carnegie Mellon
University, Pittsburgh, Pennsylvania, 1998.
Xi, Hongwei and Robert Harper. A dependently typed assembly language. In ACM SIG-
PLAN International Conference on Functional Programming (ICFP), Firenze, Italy,
pages 169–180, September 2001.
Xi, Hongwei and Frank Pfenning. Dependent types in practical programming. In ACM
SIGPLAN–SIGACT Symposium on Principles of Programming Languages (POPL), San
Antonio, Texas, pages 214–227, January 1999.
Zenger, Christoph. Indexed types. Theoretical Computer Science, 187:147–165, 1997.
Zwanenburg, Jan.
Pure type systems with subtyping.
In International Conference
on Typed Lambda Calculi and Applications (TLCA), L’Aquila, Italy, volume 1581 of
Lecture Notes in Computer Science, pages 381–396. Springer-Verlag, April 1999.


Index
0CFA, 101
«
“quick check” exercise, xii
««
easy exercise, xii
«««
moderate exercise, xii
««««
challenging exercise, xii
3
exercise without solution, xii
A-normal form, 253
abbreviations, see type deﬁnitions
abstract types, 245–289, see also mod-
ules, 454
access control with linear types, 3
adequacy, 277
admissible property, 259
aﬃne types, see substructural types
Agda, 66
ALF, 68, 69
Alfa, 66
algebraic data types and type inference,
453–458
algorithmic type checking, see also un-
decidability
for the calculus of constructions,
66
for LF, 56–60, 62–63
for linear lambda-calculus, 11–14
aliasing, see also syntactic control of
interference
and typed assembly language, 156
alias types, see typed assembly language
applicative bisimilarity, 288
arrays
and typed assembly language, 170–
171
in linear type systems, 24–28
AUTOMATH, 86, 384
avoidance problem, see signatures
Barendregt cube, see lambda cube
behavioral type systems, 105
bisimilarity, 288
bunched logic, see substructural log-
ics
bunched types, see substructural types
C, 43, 90, 106, 133, 343
C#, 142
Calculus of Capabilities, 134
Calculus of Constructions, 64–71, 86
with dependent sum types, 69–71
Calculus of Inductive Constructions,
66–69
Caml, 389
capability types and typed assembly
language, 175
Cayenne, 74, 305
CC, see Calculus of Constructions
CIC, see Calculus of Inductive Construc-
tions
ciu-equivalence, 264, 288
Clean, 43, 389
CLI, see Common Language Infrastruc-
ture

568
Index
closing substitution, 263
closure analysis, 100
closures in TAL, 168–170
CLU, 343
coherence, see modules
Common Language Infrastructure, 139,
142, 178
compilation, separate, see modules
compilation, type-preserving, 141
compiler optimizations
enabled by aﬃne and relevant types,
39–40
enabled by linear types, 19
computational λ-calculus, 105
concatenation of records, see type in-
ference
constraints, see also type inference
for type inference, 407–422
generation, 429–434
solving, 438–450
containment rules, see substructural
types
context
evaluation, 256
context splitting, see substructural types
contextual equivalence, 249, 261–266
vs. bisimilarity, 288
continuation-passing style and regions,
132
contraction, see structural properties
control ﬂow analysis, 100
control ﬂow safety, see typed assem-
bly language
Coq, 66, 67, 86, 175, 384
cryptographic authentication infrastruc-
ture, see proof-carrying code
Curry-Howard correspondence
and dependent types, 48–49
and linear logic, 41
cut-oﬀcompilation, 303
Cyclone, 43, 90, 132–134, 174
Damas–Milner type system, 399–406
relation with HM(X), 428–429
data types and type inference, 453–
458
decidability, see undecidability
deﬁnitional equality, see equivalence
checking
deﬁnitions, see type deﬁnitions
delta-reduction, 395
delta-reduction of type deﬁnitions, 354
Dependent ML, 74–82
dependent types, 45–86, see also LF,
calculus of constructions, calcu-
lus of inductive constructions
and typed assembly language, 171–
172
decidable type checking for restricted
systems, 75
higher-order abstract syntax and,
49, 206
implementation, 83–85
indexed types, 75
products, 46
semantics, 86
sums, 61–63, 69–71
sums vs. existentials (weak sums),
70
type inference, 82
undecidability of type checking, 74–
75
with substructural types, 43
dependently vs. statically typed lan-
guages, 305
determinate module, 363
DML, see Dependent ML
dot notation for existential types, 308
ECC, see Extended Calculus of Construc-
tions
Edinburgh Logical Framework, see LF
eﬀect type systems, 89–90, 102–123,
see also regions
applications, 87
and interference analysis, 105
polymorphism, 114
and protocol veriﬁcation, 105
region inference, 89–90

Index
569
and soundness of value ﬂow anal-
ysis, 104
with substructural types, 43
Tofte–Talpin type system, 89, 101,
114–123
value restriction and polymorphism,
123
eﬀects, 390
equirecursive types, 454, 459
equivalence, see contextual equivalence,
cui-equivalence
equivalence checking, 223–244
deﬁnitional equality, 54
for LF, 53–54
erasure
in region-based analysis, 111–114
in value ﬂow analysis, 93–97
evaluation context, 256
evaluation frame, 257
exchange, see structural properties
exercises, diﬃculty ratings, xii
existential types, see also abstract types
in typed assembly language, 168
vs. Sigma types, 70
vs. signatures, 307, 308
in typed assembly language, 167
Extended Calculus of Constructions, 70
extensionality principle, 225, 249, 250,
252, 279
external name, see modules
external references between modules,
294
families of modules, see modules
families of signatures, see signatures
ﬁbered signatures, see signatures
Finitary PCF, 90
ﬁrst-class modules, see modules
foundational proof-carrying code (FPCC),
see proof-carrying code
frame
evaluation, 257
functors, see modules
fundamental property, see logical re-
lations
Galois connection, 267
garbage collection, see memory man-
agement
generalization of a type scheme, 402–
404
generic programming, 345
Glasgow Haskell Compiler, 39, 43
Haskell, 43, 74, 334, 342, 344, 389
Herbrand universe, 411
hiding, see abstract types, modules
higher-order abstract syntax in depen-
dent type systems, 49, 206
higher-order modules, see modules
HM(X), see type inference
Hope, 343
Howe’s method, 288
implicit syntax, see type inference and
dependent types
incremental compilation, see modules
indexed types, see dependent types
inference, see type inference
information hiding, see abstract types,
modules
instantiation of a type scheme, 402–
404, 407, 408
interfaces, see signatures
interference, see aliasing
interference analysis via eﬀect type sys-
tems, 105
internal name, see modules
isorecursive types, 289, 454, 458, 459
Java, 90, 141, 142, 187, 300, 303, 305,
343
Java Virtual Machine, 139, 142, 178,
189
judgments-as-types, see LF
Kripke logical relation, 237
lambda cube, 71–73, 86
language-based security, see proof-carrying
code, typed assembly language

570
Index
LCF, 389
LEGO, 66, 70, 85, 86
LF, 49–63, 86, 175
algorithmic type checking, 56–60,
62–63
with dependent sum types, 61–63
implicit, in proof-carrying code sys-
tems, 211–214
Linear, 42
in proof-carrying code systems, 205–
214
linear lambda-calculus, 6–30
algorithmic type checking, 11–14
and arrays, 24–28
polymorphic, 20–24
with reference counting, 28–30
Linear LF, 42
linear logic, see substructural logics
linear types, see substructural types
linking, see modules
Lisp, 343
logical equivalence, 234
Logical Frameworks, see LF
logical relations, 223–289
fundamental property, 239–243, 274
history, 243–244
Kripke, 237
monotonicity, 235–237
operationally based, 266
and “recursive language features”,
289
manifest types, see type deﬁnitions
memory management, see also regions
with linear types, 7, 14
with linear types and regions, 42,
132
reference counting, 28–30, 41
reuse, 111
stack discipline, 30, 89, 99, 157
with substructural types, 4
and typed assembly language, 174
memory safety, see typed assembly lan-
guage
Microsoft Common Language Infras-
tructure, see Common Language
Infrastructure
mixin modules, 343
ML, 141, 142, 389–489
meanings of the term, 389
ML Kit, 90, 123, 128–130, 133
ML module system, see modules
ML type inference, see type inference
mobile code, see proof-carrying code,
typed assembly language
Modula-2 and Modula-3, 343
modules, see also signatures
abstract type components, 307–317
applicative vs. generative functors,
336–338
coherence, 327–333
determinacy, 312–315
in existing programming languages,
341–343
external references between, 294
families of, 324–338
ﬁrst-class, 312, 338–339
functors, 324–338
functors and determinacy, 336–338
hierarchies, 317–320
higher-order, 339–340
internal vs. external names, 296, 317–
320
linking, 303–304
mixin modules, 343
ML module system, 341–342
phase distinction, 305–307
pragmatics of functors, 333–336
recursive, 341
separate and incremental compila-
tion, 302–303
static vs. dynamic equivalence, 340
units, 343
monad, 105
monotonicity property of logical rela-
tions, 271
nominal vs. structural signature match-
ing, 299

Index
571
nonstructural subtyping, 412
normalize-and-compare algorithm for
equivalence checking, 225
NuPrl, 54
object encodings in TAL, 168–170
Objective Caml, 342, 343
objects, type inference for, 459
occurs check, 439
opaque interface, 358
operational extensionality, see exten-
sionality principle
operational reasoning using types, 245–
289
ordered lambda-calculus, 30–36, 42
ordered logic, see substructural logics
ordered types, see substructural types
parameterized modules, see modules
parameterized signatures, see signatures
parametricity, see relational parametric-
ity
parametric polymorphism, see polymor-
phism
Pascal, 343
PCC, see proof-carrying code
Pebble, 74, 305
phantom types, 455
phase distinction, see also modules
and dependent types, 75
phase splitting, see type deﬁnitions
Pi types, see dependent types
pointers, shared vs. unique, 157
polymorphic record update, 460
polymorphic recursion, 154, 452
polymorphic variants, 483–486
polymorphism, see also type inference
and regions, 110
in eﬀect type systems, 114
in linear type systems, 20–24
and regions, 108
in typed assembly language, 146
in value ﬂow analysis, 101
pre- and postconditions, in proof-carrying
code, 184
principal signature, see signatures
principal type schemes, 405, 430
principal typings, 430
privacy, guaranteeing with PCC, 216–
218
program analysis, type-based, 87–135
program equivalence, see typed oper-
ational reasoning
programming languages
C, 43, 90, 106, 133, 343
C#, 142
Caml, 389
Cayenne, 74, 305
Clean, 43, 389
CLU, 343
Cyclone, 43, 90, 132–134, 174
Dependent ML, 75–82
Haskell, 43, 74, 334, 342, 344, 389
Hope, 343
Java, 90, 141, 142, 187, 300, 303,
305, 343
LF, 86
Lisp, 343
ML, 141, 142, 389–489
ML Kit, 90, 123, 128–130, 133
Modula-2 and Modula-3, 343
Objective Caml, 342, 343
Pascal, 343
Pebble, 74, 305
Prolog, 90, 127, 134
Quest, 74
Russell, 305
Scheme, 305
Standard ML, 255, 341, 343, 345,
389
Vault, 43, 90
Prolog, 90, 127, 134
proof-carrying code, 139–140, 177–220
architecture, 178–180
beyond types, 216–218
costs, 211, 220
for cryptographic authentication, 219
eﬃcient proof representation in im-
plicit LF, 211–214

572
Index
foundational, 155, 175, 178
guaranteeing privacy, 216–218
pre- and postconditions, 184
program annotation, 193
proof checking as LF type check-
ing, 209–211
proof generation, 214–215
proof representation in LF, 205–214
safety policy, 182–187
and substructural types, 40
symbolic evaluation, 190–192, 194–
195
vs. typed assembly language, 141,
155, 178, 189
veriﬁcation condition generation, 187–
190
propositions-as-types, see Curry-Howard
correspondence
protocol veriﬁcation with eﬀect type
systems, 105
pure type systems (PTS), 71–73
PVS, 74
qualiﬁed types, 488
qualiﬁers, see type qualiﬁers
Quest, 74
record operations, 460–489
record update and extension, polymor-
phic, 460
recursive deﬁnitions, 398
recursive modules, see modules
recursive types, see also modules, re-
cursive
in linear type systems, 17
and type inference, 453–460
reference counting, see also memory
management
in linear type systems, 28–30, 41
references, 390, 398, 435, 452, see also
eﬀects
regions, 87–135, see also eﬀect type
systems
and continuation-passing style, 132
erasure, 111–114
imperative, 131–132
inference, 89–90, 101, 123–127
lexically scoped, 89, 99–100
and linear types, 42, 132
polymorphic, 108–110
practical memory-management sys-
tems, 133–135
reuse of deallocated memory, 111
safety properties, 87, 106
and stack-oriented memory manage-
ment, 89, 99
and typed assembly language, 173,
175
register ﬁle type, 146
relational parametricity, 245, 271, 286,
287
relevant logic, see substructural logics
relevant types, see substructural types
resource management, see memory man-
agement, regions
row variables, see type inference
Russell, 305
safety policy, see proof-carrying code
Scheme, 305
scheme, see type scheme
Scott induction, 259
sealing, see signatures, 362
security, see proof-carrying code, typed
assembly language
separate compilation, see modules
set-based analysis, 101
Sigma types, see dependent types
signatures, see also modules
avoidance problem, 315–317, 365
dot notation, 307
vs. existential types, 307, 308
families of, 320–324
ﬁbered vs. parameterized, 322–324
matching, 299
nominal vs. structural matching, 299
opaque, 307
principal, 298, 301
role in separate compilation, 295
sealing, 310–312

Index
573
sealing, static vs. dynamic, 338
subsumption principle for, 299
translucent, 307–310
transparent, 307
singleton kinds, see type deﬁnitions
singleton types, 385
software fault isolation, 140
sorts in pure type systems, 72
stack typing, see typed assembly lan-
guage
Standard ML, 255, 341, 343, 345, 389
statically vs. dependently typed lan-
guages, 305
strictness analysis, 43
strict types, see relevant types
strong sum types, see dependent types
structural properties, 4–6
contraction, 4, 11, 41
exchange, 4, 11, 31, 32
weakening, 4, 11, 41
structural subtyping, 412
structural vs. nominal signature match-
ing, 299
structures, see modules
submodules, see modules
substructural logics, 40–42
substructural types, 3–43
aﬃne types, 5, 36–40, 43
bunched types, 42
containment rules, 9, 33
context splitting, 9, 42
context splitting, algorithmic, 11
with dependent types, 43
with eﬀect type systems, 43
linear types, 5–30, 41, 43
ordered types, 5, 30–36, 42
relevant types, 5, 39
temporal resource management, 36
uniqueness types, 43
subtyping, see also constraints
and typed assembly language, 173
co- and contra-variance, 412, 415
structural vs. nonstructural, 412
sum types, see also algebraic data types,
variant types
in dependent type systems, 61–63
in linear type systems, 17
surjective pairing, 62
symbolic evaluation, see proof-carrying
code
syntactic control of interference, 41
syntax-directedness, see algorithmic type
checking
TAL, see typed assembly language
TAPL, ix
temporal resource management with
substructural types, 36
theorem provers
Agda, 66
ALF, 68, 69
Alfa, 66
AUTOMATH, 86, 384
Coq, 66, 67, 86, 175, 384
LCF, 389
LEGO, 66, 70, 85, 86
NuPrl, 54
PVS, 74
TIL, see typed intermediate language
Tofte–Talpin type system, see eﬀect type
systems
Touchstone PCC architecture, see proof-
carrying code
translucent sums, see type deﬁnitions
transparent interface, 358
type-based program analysis, 87–135
type checking, see algorithmic type check-
ing
type deﬁnitions, 347–385
for algebraic data types, 454
delta-reduction, 354
in module interfaces, 358–367
manifest types, 358
phase splitting, 378–384
primitive, 351–358
singleton kinds, 367–384
translucent sums, 358–367
type inference, 389–489

574
Index
and algebraic data types, 453–458
and dependent types, 82
HM(X), 389–489
objects, 459, 461, 486
polymorphic variants, 483–486
records, 460–489
and recursive types, 453–460
regions, 101, 123–127
regions and eﬀect types, 89–90
row variables, 460–489
in typed assembly language, 154
and value ﬂow analysis, 97–98
type-preserving compilation, 141
type qualiﬁers, 7
linear qualiﬁer, 7
ordered qualiﬁer, 32
quantiﬁcation over, 21
reference counting qualiﬁer, 28
unrestricted qualiﬁer, 7
type reconstruction, see type inference
type scheme, 402–404, 407
typed assembly language, 139–175
and aliasing, 156
and alias types, 157
and arrays, 170–171
and capability types, 175
closures, 168–170
compiling to, 164–172
control ﬂow safety, 142–155
and dependent types, 171–172
encoding objects, 168–170
ensuring memory safety, 155–172
and existential types, 167–168
memory management, 174
and origins of Cyclone, 134
polymorphism, 146
vs. proof-carrying code, 141, 155,
178, 189
and regions, 173, 175
stack-allocated memory, 157
and substructural types, 40
and stack typing, 173
and subtyping, 173
TALT, 173–175
TALx86, 170, 171, 173, 174
and type inference, 154
typed intermediate language, 142, see
also typed assembly language
typed operational reasoning, 245–289
typed operational semantics, 86
type and eﬀect systems, see eﬀect type
systems
Types and Programming Languages,
ix
undecidability
of dependent type checking, 54, 74–
75
of module type systems, 339
of type inference with polymorphic
recursion, 452
uniﬁcation, 439–442
with record types, 476
uniqueness types, see substructural types
units, 343
untrusted code, see proof-carrying code,
typed assembly language
unwinding property, 259–260
UTT, 86
value ﬂow analysis, 88, 90–102
constraint-based, 101
erasure, 93–97
polymorphic, 101
soundness with eﬀect types, 104
type inference, 97–98
unsoundness without eﬀect types,
88, 99
value restriction, 255, 437
in eﬀect type systems, 123
variants, polymorphic, 483–486
Vault, 43, 90
veriﬁcation conditions, see proof-carrying
code
weak head normalization, 57, 230
weak sum types, see dependent types
weakening, see structural properties
web resources, xii

