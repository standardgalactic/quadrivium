MATLAB and
Simulink Crash Course
for Engineers
Eklas Hossain

MATLAB and Simulink Crash Course for Engineers

Eklas Hossain
MATLAB and Simulink
Crash Course for Engineers

Eklas Hossain
Oregon Institute of Technology
Klamath Falls, OR, USA
ISBN 978-3-030-89761-1
ISBN 978-3-030-89762-8
(eBook)
https://doi.org/10.1007/978-3-030-89762-8
© The Editor(s) (if applicable) and The Author(s), under exclusive license to Springer Nature Switzerland
AG 2022
This work is subject to copyright. All rights are solely and exclusively licensed by the Publisher, whether
the whole or part of the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of
illustrations, recitation, broadcasting, reproduction on microﬁlms or in any other physical way, and
transmission or information storage and retrieval, electronic adaptation, computer software, or by
similar or dissimilar methodology now known or hereafter developed.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication
does not imply, even in the absence of a speciﬁc statement, that such names are exempt from the relevant
protective laws and regulations and therefore free for general use.
The publisher, the authors and the editors are safe to assume that the advice and information in this
book are believed to be true and accurate at the date of publication. Neither the publisher nor the authors or
the editors give a warranty, expressed or implied, with respect to the material contained herein or for any
errors or omissions that may have been made. The publisher remains neutral with regard to jurisdictional
claims in published maps and institutional afﬁliations.
This Springer imprint is published by the registered company Springer Nature Switzerland AG
The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland

Preface
MATLAB and Simulink are two programming and simulating tools developed by
MathWorks®. They are the go-to tools for solving engineering problems and design-
ing, modelling, and simulating new inventions. They are the present-day engineer’s
favorite tools and are recognized as the most widely used and standard software used
all across the globe in all ﬁelds of science and engineering. Numerous researches
have been developed based solely on the magic of programming in MATLAB and
Simulink. Hence, it is essential for STEM students and academicians, and also
professional engineers to be fairly acquainted with the usage of MATLAB and
Simulink.
All branches of engineering except computer science have only a handful of
programming courses in C/C++ or MATLAB/PSpice at a very few weekly contact
hours. However, programming is highly relevant to all branches of engineering
study. For undergraduate or graduate level projects, thesis, or assignments, working
knowledge on programming is necessary to accomplish tasks, build models, simu-
late designs, or simply replicate the ideas from others. Programming is so intricately
connected in modern life that no engineering student can avoid programming
anymore, no matter their major. Therefore, students need to develop adequate
programming skills early on in their careers to help them work independently
throughout their student and professional life. Although programming is required
at all levels of study, it is seldom taught academically, and students are eventually
compelled to learn everything on their own or simply surrender their weaknesses.
When I began teaching advanced technologies in electrical engineering at Oregon
Tech, I discovered that most students have a sort of phobia in programming. They
wander around to ﬁnd solid material to help them solve their programming require-
ments. I realized the gravity of the problem even more when in the senior year power
system or control system projects, many students are either shy or admit their
weakness in programming. In fact, programming is an inherent part of not only
academia but also in professional engineering and technical jobs.
v

Hence, I decided to teach programming to students and approached the head of
the department for approval. Getting approval from the department, I worked an
entire summer to build the right course material for students to build their program-
ming skills from scratch and develop the course outline based on real-world appli-
cations. The students were involved in providing their feedback on the course, and
they really appreciated the course curriculum.
After teaching the course on MATLAB and Simulink for three to four consecu-
tive years and having solid proof of its efﬁcacy, the course curriculum is now being
presented in the form of a book to aid most engineering students worldwide, if not
all. This book will be an independent study guide for engineering students. It is
designed from an instructor’s perspective to help them teach students, to help
students learn on their own, and also for helping out independent researchers and
professional engineers. The book is rich in case studies that will be relatable to many
ﬁelds of work.
As an author, I will consider this book a success only if it is able to help students
overcome their fear of programming and use this book as a guide to solving
engineering problems using MATLAB and Simulink. Thus, the main aim of pub-
lishing this book is to disseminate the knowledge that I have gleaned over the years
from experiences in teaching and witnessing the problems that engineering students
frequently face.
This book comprising 18 chapters is divided into 2 sections. Chapters 1–11 cover
MATLAB programming, while Chaps. 12–18 cover Simulink. Each section begins
with chapters encompassing the fundamentals of MATLAB and Simulink, and then
proceeds towards the applications of these two tools in various ﬁelds, particularly in
the electrical engineering arena. Since the main research interest of the author is on
energy systems, the book is more biased towards the applications of MATLAB and
Simulink in electrical circuits, electronics, power electronics, power systems, control
systems, renewable energy, etc. In addition to helping develop programming skills,
this book will help engineering students to brush up on concepts related to electrical
engineering and build projects based on the case studies included in the chapters.
This book caters to the needs of both students and instructors. Students and
professional engineers will be able to use this book as self-study material, and
instructors will ﬁnd this book utterly useful to deliver their lectures based on the
outlines of this book and also may use any part of this book directly as course
material. By the completion of this book, the reader is expected to develop at least an
intermediate level of expertise in programming in MATLAB and Simulink. The
advanced level will gradually grow with practice and more exposure to the software.
To all those willing to develop skills on MATLAB and Simulink and set out on
the path to discovery and learning, good luck on your journey!
Klamath Falls, OR, USA
Eklas Hossain
vi
Preface

Acknowledgments
I am thankful to everyone at Springer Nature who has patiently helped me complete
the manuscript of this book. Besides, my colleagues and fellow students at Oregon
Tech deserve a heartfelt appreciation for their never-ending faith in me and their
amiable cooperation. This book reﬂects my time as an instructor at Oregon Tech, and
my experience and knowledge to develop this book would have been zero without
Oregon Tech. I thank each and every member of the Oregon Tech family for helping
shape my career as an academician.
This book has been designed and drafted with the help of many people. I am
thankful to all those who have supported me throughout the process of writing this
book. I am grateful to MathWorks® for developing MATLAB and Simulink, and for
providing free guidelines on their website to help people learn the two software.
Those resources have profoundly helped to develop this book. In addition, I would
like to express my appreciation for all the other books and resources available freely
on the Internet that have enriched this book. It would be wrong not to mention the
reviewers of the book proposal for helping improve the outline and contents of this
book. I am thankful to their suggestions to update the contents of this book.
I am indebted to my family, for they have always been there for me in all ups and
downs and showered me with their constant love and support. I thank my friends and
collaborators for cheering for me and constantly pushing me to improve myself.
And at last, I am inﬁnitely grateful to my Lord, for making me, this world, and all
that is there in the Universe. This book, or even I, would be nothing without the
Mercy and Blessings of the Creator.
vii

Contents
1
Introduction to MATLAB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2
What Is MATLAB? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.3
History, Purpose, and Importance . . . . . . . . . . . . . . . . . . . . . .
2
1.3.1
History . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.3.2
Purpose and Importance . . . . . . . . . . . . . . . . . . . . . .
3
1.4
Installation and Dependencies . . . . . . . . . . . . . . . . . . . . . . . .
4
1.4.1
Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.5
Starting MATLAB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.6
MATLAB Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.7
Features of MATLAB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
1.8
Variables in MATLAB: Categories and Conversion
Between Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
1.8.1
Categories of Data Types . . . . . . . . . . . . . . . . . . . . .
9
1.8.2
MATLAB Example 1.1: Different Data Types . . . . . .
9
1.8.3
Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
1.8.4
MATLAB Example 1.2: Conversion
of Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
1.9
Suppressing Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
1.10
Recording a MATLAB Session . . . . . . . . . . . . . . . . . . . . . . .
14
1.11
Printing Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
1.12
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
Exercise 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
2
Vectors and Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
2.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
2.2
Creating Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
2.3
Creating Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
2.4
Manipulation of Vectors and Matrices . . . . . . . . . . . . . . . . . .
21
ix

2.5
Dimensions of Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
2.5.1
MATLAB Example 2.10: Dimension
of a Matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
2.6
Operations on Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
2.6.1
Addition and Subtraction . . . . . . . . . . . . . . . . . . . . .
24
2.6.2
MATLAB Example 2.1: Addition
and Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
2.6.3
Multiplication . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25
2.6.4
MATLAB Example 2.2: Multiplication . . . . . . . . . . .
26
2.6.5
Transpose . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
2.6.6
MATLAB Example 2.3: Transpose . . . . . . . . . . . . . .
27
2.6.7
Determinant . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
2.6.8
MATLAB Example 2.4: Determinant . . . . . . . . . . . .
28
2.6.9
Identity Matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
2.6.10
MATLAB Example 2.5: Identity Matrix . . . . . . . . . .
28
2.6.11
Inverse Matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
2.6.12
MATLAB Example 2.6: Inverse Matrix . . . . . . . . . . .
29
2.7
Simple Matrix Concatenation . . . . . . . . . . . . . . . . . . . . . . . . .
30
2.7.1
MATLAB Example 2.9: Matrix
Concatenation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
2.8
Creating Arrays of Zeros, Ones, and Random Numbers . . . . . .
31
2.8.1
MATLAB Example 2.7: Arrays
of Zeros and Ones . . . . . . . . . . . . . . . . . . . . . . . . . .
32
2.8.2
MATLAB Example 2.8: Random Numbers . . . . . . . .
33
2.9
Array Function for One-Dimensional Arrays . . . . . . . . . . . . . .
35
2.9.1
MATLAB Example 2.11: Creating Linearly
Spaced One-Dimensional Array . . . . . . . . . . . . . . . . .
35
2.9.2
MATLAB Example 2.12: Finding Maximum
and Minimum Value from an Array . . . . . . . . . . . . . .
37
2.10
Mean, Standard Deviation, Variance, and Mode . . . . . . . . . . .
37
2.10.1
MATLAB Example 2.13: Mean, Variance,
Standard Deviation, and Mode . . . . . . . . . . . . . . . . .
39
2.11
Dot Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
2.11.1
MATLAB Example 2.14: Instances
of the Dot Operator . . . . . . . . . . . . . . . . . . . . . . . . .
40
2.12
Table Arrays, Cell Arrays, and Structure Arrays . . . . . . . . . . .
41
2.12.1
MATLAB Example 2.15: Creating Table . . . . . . . . . .
42
2.12.2
MATLAB Example 2.16: Cell Array . . . . . . . . . . . . .
43
2.12.3
MATLAB Example 2.17: Structured Array . . . . . . . .
44
2.13
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
Exercise 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
46
3
Programs and Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
3.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
3.2
Scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
3.2.1
Live Script . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
50
3.2.2
Script vs. Live Script . . . . . . . . . . . . . . . . . . . . . . . .
51
x
Contents

3.3
Saving, Running, and Publishing a Script . . . . . . . . . . . . . . . .
52
3.3.1
Saving a Script . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
52
3.3.2
Running a Script . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
3.3.3
Publishing a Script . . . . . . . . . . . . . . . . . . . . . . . . . .
55
3.4
Conditional Statements and Loops . . . . . . . . . . . . . . . . . . . . .
56
3.4.1
“If” Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
3.4.2
MATLAB Example 3.1: “If” Statement . . . . . . . . . . .
58
3.4.3
Switch Statement . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
3.4.4
MATLAB Example 3.2: Switch Statement . . . . . . . . .
60
3.4.5
For Loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
61
3.4.6
MATLAB Example 3.3: “For” Loop . . . . . . . . . . . . .
62
3.5
User-Deﬁned Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
63
3.6
Creating User-Deﬁned Functions . . . . . . . . . . . . . . . . . . . . . .
63
3.6.1
MATLAB Example 3.4: User-Deﬁned Function . . . . .
64
3.6.2
MATLAB Example 3.5: User-Deﬁned
Function–Anonymous Function . . . . . . . . . . . . . . . . .
65
3.6.3
Examples of User-Deﬁned Function . . . . . . . . . . . . . .
65
3.7
Solve Quadratic Equations Using Functions . . . . . . . . . . . . . .
68
3.7.1
MATLAB Example 3.6: User-Deﬁned Function
for Solving Quadratic Equation . . . . . . . . . . . . . . . . .
69
3.8
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
69
Exercise 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
4
Complex Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
71
4.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
71
4.2
Origin of Complex Numbers . . . . . . . . . . . . . . . . . . . . . . . . .
71
4.3
Rectangular Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
4.3.1
MATLAB Example 4.1: Rectangular Form . . . . . . . .
73
4.4
Polar Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
73
4.4.1
MATLAB Example 4.2: Polar Form . . . . . . . . . . . . .
74
4.5
Euler’s Series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
75
4.5.1
MATLAB Example 4.3: Euler’s Formula . . . . . . . . . .
76
4.5.2
MATLAB Example 4.4: Euler’s Series
for Solving Initial Value Problem . . . . . . . . . . . . . . .
77
4.6
Fourier Series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
79
4.6.1
MATLAB Example 4.5: Fourier Series . . . . . . . . . . .
80
4.6.2
MATLAB Example 4.6: DFT and Inverse DFT . . . . .
82
4.7
Taylor Series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
82
4.7.1
MATLAB Example 4.7: Taylor Series . . . . . . . . . . . .
84
4.8
Equilibrium Point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
4.8.1
MATLAB Example 4.8: Equilibrium Points . . . . . . . .
86
4.9
Energy Calculation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
87
4.9.1
MATLAB Example 4.9: Energy Calculation . . . . . . .
87
Contents
xi

4.10
Impedance Calculation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
89
4.10.1
MATLAB Example 4.10: Impedance
Calculation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
89
4.11
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
Exercise 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
5
Visualization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
5.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
5.2
Line Plot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
5.2.1
MATLAB Example 5.1: Line Plot . . . . . . . . . . . . . . .
98
5.2.2
MATLAB Example 5.2: Subplot . . . . . . . . . . . . . . . .
99
5.2.3
MATLAB Example 5.3: Double-Axis Plot . . . . . . . . .
100
5.3
Bar Plot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
102
5.3.1
MATLAB Example 5.4: Bar Plot . . . . . . . . . . . . . . .
102
5.3.2
MATLAB Example 5.5: Horizontal Bar Plot . . . . . . .
103
5.4
Area Plot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
104
5.4.1
MATLAB Example 5.6: Area Plot . . . . . . . . . . . . . . .
105
5.5
Surface Plot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
105
5.5.1
MATLAB Example 5.7: Surface Plot . . . . . . . . . . . . .
107
5.6
Pie Plot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
109
5.6.1
MATLAB Example 5.8: Pie Plot . . . . . . . . . . . . . . . .
109
5.7
Heat Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
110
5.7.1
MATLAB Example 5.9: Heat Map . . . . . . . . . . . . . .
110
5.8
Radar Plot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
112
5.8.1
MATLAB Example 5.10: Radar Plot . . . . . . . . . . . . .
112
5.9
3D Plot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
114
5.9.1
MATLAB Example 5.11: 3D Pie Plots . . . . . . . . . . .
115
5.10
Exporting High-Quality Figure . . . . . . . . . . . . . . . . . . . . . . . .
115
5.11
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
117
Exercise 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
117
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
122
6
Solving Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
123
6.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
123
6.2
Linear Algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
123
6.2.1
MATLAB Example 6.1: Rank . . . . . . . . . . . . . . . . . .
124
6.2.2
MATLAB Example 6.2: Eigenvalue . . . . . . . . . . . . .
125
6.2.3
MATLAB Example 6.3: Eigenvector . . . . . . . . . . . . .
126
6.3
Quadratic Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
127
6.3.1
MATLAB Example 6.4: Solving
Quadratic Equation . . . . . . . . . . . . . . . . . . . . . . . . . .
127
6.3.2
MATLAB Example 6.5: “Solve” Function . . . . . . . . .
128
6.4
Differential Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
129
6.4.1
Ordinary Differential Equations . . . . . . . . . . . . . . . . .
129
6.4.2
MATLAB Example 6.6: First-Order Differential
Equation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
130
xii
Contents

6.4.3
MATLAB Example 6.7: Second-Order Differential
Equation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
131
6.4.4
MATLAB Example 6.8: Third-Order Differential
Equation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
132
6.4.5
Partial Differential Equations . . . . . . . . . . . . . . . . . . .
133
6.4.6
MATLAB Example 6.9: Partial Differential
Equation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
133
6.5
Integral Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
134
6.5.1
MATLAB Example 6.10: Single Variable Integral
Equation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
135
6.5.2
MATLAB Example 6.11: Multivariable Integral
Equation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
136
6.6
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
137
Exercise 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
137
7
Numerical Methods in MATLAB . . . . . . . . . . . . . . . . . . . . . . . . . .
139
7.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
139
7.2
Gauss-Seidel Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
139
7.2.1
MATLAB Example 7.1: Gauss-Seidel Method . . . . . .
142
7.3
Newton-Raphson Method . . . . . . . . . . . . . . . . . . . . . . . . . . .
143
7.3.1
MATLAB Example 7.2: Newton-Raphson Method . . .
144
7.4
Runge-Kutta Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
144
7.4.1
MATLAB Example 7.3: Runge-Kutta Method . . . . . .
146
7.5
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
146
Exercise 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
148
8
Electrical Circuit Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
151
8.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
151
8.2
DC Circuit Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
151
8.2.1
Ohm’s Law . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
151
8.2.2
Equivalent Resistance . . . . . . . . . . . . . . . . . . . . . . . .
152
8.2.3
Delta-Wye Conversion . . . . . . . . . . . . . . . . . . . . . . .
154
8.2.4
Kirchhoff’s Laws . . . . . . . . . . . . . . . . . . . . . . . . . . .
158
8.2.5
Voltage Divider and Current Divider Laws . . . . . . . . .
162
8.2.6
Thevenin’s Theorem . . . . . . . . . . . . . . . . . . . . . . . . .
164
8.2.7
Maximum Power Transfer Theorem . . . . . . . . . . . . . .
167
8.3
AC Circuit Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
169
8.3.1
Some Terminologies . . . . . . . . . . . . . . . . . . . . . . . . .
170
8.3.2
Impedance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
172
8.3.3
Power Triangle . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
175
8.3.4
Three-Phase AC Circuit Analysis . . . . . . . . . . . . . . .
176
8.4
Operational Ampliﬁer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
197
8.4.1
Inverting Ampliﬁer . . . . . . . . . . . . . . . . . . . . . . . . . .
198
8.4.2
Non-inverting Ampliﬁer . . . . . . . . . . . . . . . . . . . . . .
199
8.4.3
Follower Circuit . . . . . . . . . . . . . . . . . . . . . . . . . . . .
201
Contents
xiii

8.4.4
Differentiator Circuit . . . . . . . . . . . . . . . . . . . . . . . .
202
8.4.5
Integrator Circuit . . . . . . . . . . . . . . . . . . . . . . . . . . .
204
8.5
Transistor Circuit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
206
8.5.1
MATLAB Example 8.25: Transistor Circuit . . . . . . . .
208
8.6
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
208
Exercise 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
209
9
Control System and MATLAB . . . . . . . . . . . . . . . . . . . . . . . . . . . .
215
9.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
215
9.2
Frequency Response Overview . . . . . . . . . . . . . . . . . . . . . . .
215
9.2.1
Linear Time-Invariant System . . . . . . . . . . . . . . . . . .
216
9.2.2
Transfer Function . . . . . . . . . . . . . . . . . . . . . . . . . . .
217
9.2.3
Laplace Transform . . . . . . . . . . . . . . . . . . . . . . . . . .
219
9.2.4
Inverse Laplace Transform . . . . . . . . . . . . . . . . . . . .
221
9.2.5
Partial Fraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
223
9.2.6
DC Gain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
231
9.2.7
Initial Value and Final Value Theorem . . . . . . . . . . . .
232
9.2.8
Poles/Zeros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
233
9.2.9
Laplace Transform in Electrical Circuit . . . . . . . . . . .
235
9.3
Time Response Overview . . . . . . . . . . . . . . . . . . . . . . . . . . .
237
9.3.1
First-Order System . . . . . . . . . . . . . . . . . . . . . . . . . .
239
9.3.2
Second-Order System . . . . . . . . . . . . . . . . . . . . . . . .
240
9.3.3
Impact of Damping Ratio . . . . . . . . . . . . . . . . . . . . .
242
9.3.4
Steady-State Error . . . . . . . . . . . . . . . . . . . . . . . . . .
255
9.4
A State-Space Representation for RLC Circuit . . . . . . . . . . . .
257
9.4.1
State-Space Model and Response . . . . . . . . . . . . . . .
258
9.4.2
State-Space Model to Transfer Function . . . . . . . . . . .
259
9.4.3
Transfer Function to State-Space Model . . . . . . . . . . .
261
9.5
Controllability and Observability of State-Space Model . . . . . .
262
9.5.1
Controllability . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
262
9.5.2
Testing for Controllability . . . . . . . . . . . . . . . . . . . . .
264
9.5.3
Observability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
264
9.5.4
Testing for Observability . . . . . . . . . . . . . . . . . . . . .
264
9.6
Stability Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
266
9.6.1
Routh Criteria . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
267
9.6.2
Root Locus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
272
9.6.3
Bode Plot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
274
9.6.4
Nyquist Plot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
277
9.7
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
278
Exercise 9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
280
10
Optimization Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
283
10.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
283
10.2
One-Dimensional Optimization . . . . . . . . . . . . . . . . . . . . . . .
283
10.2.1
MATLAB Example 10.1: One-Dimensional
Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
284
xiv
Contents

10.3
Multidimensional Optimization . . . . . . . . . . . . . . . . . . . . . . .
285
10.3.1
MATLAB Example 10.2: Multidimensional
Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
287
10.4
Linear Programming Optimization . . . . . . . . . . . . . . . . . . . . .
288
10.4.1
MATLAB Example 10.3: Linear Programming
Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
289
10.5
Quadratic Programming Optimization . . . . . . . . . . . . . . . . . . .
291
10.5.1
MATLAB Example 10.4: Quadratic Programming
Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
292
10.6
Nonlinear Programming Optimization . . . . . . . . . . . . . . . . . . .
293
10.7
Li-ion Battery Optimization Problem and Solutions . . . . . . . . .
293
10.8
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
296
Exercise 10 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
296
11
App Designer and Graphical User Interface in MATLAB . . . . . . . .
299
11.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
299
11.2
App Designer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
299
11.2.1
Basic Layout of App Designer . . . . . . . . . . . . . . . . .
299
11.2.2
Components of App Designer . . . . . . . . . . . . . . . . . .
302
11.2.3
Detecting and Correcting Errors . . . . . . . . . . . . . . . .
303
11.2.4
Designing and Programming a GUI
with App Designer . . . . . . . . . . . . . . . . . . . . . . . . . .
303
11.3
App Designer vs GUIDE . . . . . . . . . . . . . . . . . . . . . . . . . . . .
311
11.4
GUIDE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
312
11.4.1
Exporting GUIDE App as MATLAB ﬁle . . . . . . . . . .
312
11.4.2
Migrate GUIDE App to App Designer . . . . . . . . . . . .
313
11.5
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
314
Exercise 11 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
314
12
Introduction to Simulink . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
317
12.1
What Is Simulink? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
317
12.2
Starting Simulink . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
317
12.3
Basic Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
319
12.3.1
Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
319
12.3.2
Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
321
12.3.3
Other Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
322
12.4
Simulink Library Browser . . . . . . . . . . . . . . . . . . . . . . . . . . .
326
12.5
Physical System Modeling . . . . . . . . . . . . . . . . . . . . . . . . . . .
327
12.6
Building a Model in Simulink . . . . . . . . . . . . . . . . . . . . . . . .
332
12.7
Simulate a Model in Simulink . . . . . . . . . . . . . . . . . . . . . . . .
334
12.7.1
“Run” Option . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
334
12.7.2
“Step Forward” and “Step Back” . . . . . . . . . . . . . . . .
337
12.7.3
Customizing the Style of the “Scope” Figure . . . . . . .
340
12.7.4
“Solver” Option . . . . . . . . . . . . . . . . . . . . . . . . . . . .
342
12.7.5
Data Import and Export . . . . . . . . . . . . . . . . . . . . . .
345
12.7.6
Math and Data Types . . . . . . . . . . . . . . . . . . . . . . . .
348
Contents
xv

12.7.7
Diagnostics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
349
12.7.8
Other Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . .
349
12.8
User-Deﬁned Block in Simulink . . . . . . . . . . . . . . . . . . . . . . .
351
12.9
Using MATLAB in Simulink . . . . . . . . . . . . . . . . . . . . . . . . .
354
12.10
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
358
Exercise 12 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
358
13
Commonly Used Simulink Blocks . . . . . . . . . . . . . . . . . . . . . . . . . .
361
13.1
Sink . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
361
13.1.1
Display . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
361
13.1.2
Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
364
13.1.3
Floating Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
367
13.1.4
Add Viewer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
370
13.1.5
XY Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
372
13.2
Source . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
373
13.2.1
Pulse Generator . . . . . . . . . . . . . . . . . . . . . . . . . . . .
374
13.2.2
Ramp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
374
13.2.3
Step . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
376
13.2.4
Sine Wave . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
378
13.2.5
Constant . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
379
13.3
Math Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
380
13.3.1
Abs and MinMax . . . . . . . . . . . . . . . . . . . . . . . . . . .
381
13.3.2
Add, Subtract, and Sum of Elements . . . . . . . . . . . . .
382
13.3.3
Product and Divide . . . . . . . . . . . . . . . . . . . . . . . . . .
384
13.3.4
Sum and Sqrt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
386
13.3.5
Complex to Magnitude-Angle and Complex
to Real-Imag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
390
13.3.6
Magnitude-Angle to Complex and Real-Imag
to Complex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
392
13.3.7
Math Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
392
13.3.8
Trigonometric Function . . . . . . . . . . . . . . . . . . . . . .
394
13.3.9
Derivative and Integrator . . . . . . . . . . . . . . . . . . . . .
396
13.4
Port and Subsystem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
397
13.4.1
Subsystem, In1, and Out1 . . . . . . . . . . . . . . . . . . . . .
398
13.4.2
Mux and Demux . . . . . . . . . . . . . . . . . . . . . . . . . . .
401
13.5
Logical Operator, Relational Operator, Programs,
and Lookup Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
402
13.5.1
Logical Operator . . . . . . . . . . . . . . . . . . . . . . . . . . .
403
13.5.2
Relational Operator . . . . . . . . . . . . . . . . . . . . . . . . .
404
13.5.3
If and Switch Case . . . . . . . . . . . . . . . . . . . . . . . . . .
404
13.5.4
Lookup Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
411
13.6
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
413
Exercise 13 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
414
xvi
Contents

14
Control System in Simulink . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
417
14.1
Control System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
417
14.2
Open-Loop Control System . . . . . . . . . . . . . . . . . . . . . . . . . .
417
14.3
Closed-Loop Control System . . . . . . . . . . . . . . . . . . . . . . . . .
418
14.4
Open-Loop vs Closed-Loop Control System . . . . . . . . . . . . . .
418
14.5
Simulink Model Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
418
14.5.1
Open-Loop Control System . . . . . . . . . . . . . . . . . . . .
419
14.5.2
Closed-Loop Control System . . . . . . . . . . . . . . . . . .
422
14.6
Stability Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
427
14.6.1
Stable System . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
428
14.6.2
Unstable System . . . . . . . . . . . . . . . . . . . . . . . . . . . .
434
14.7
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
435
Exercise 14 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
439
15
Electrical Circuit Analysis in Simulink . . . . . . . . . . . . . . . . . . . . . .
443
15.1
Measure Voltage, Current, and Power of a Circuit . . . . . . . . . .
443
15.1.1
DC Circuit Analysis . . . . . . . . . . . . . . . . . . . . . . . . .
443
15.1.2
AC Circuit Analysis . . . . . . . . . . . . . . . . . . . . . . . . .
445
15.2
RLC Circuit Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
448
15.2.1
AC RLC Circuit Analysis . . . . . . . . . . . . . . . . . . . . .
449
15.2.2
DC RLC Circuit Analysis . . . . . . . . . . . . . . . . . . . . .
449
15.3
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
451
Exercise 15 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
452
16
Application of Simulink in Power Systems . . . . . . . . . . . . . . . . . . .
455
16.1
Modeling Single-Phase Power Source in Simulink . . . . . . . . . .
455
16.2
Modeling Three-Phase AC Power Source in Simulink . . . . . . .
456
16.2.1
Three-Phase Wye-Connected AC Power Source . . . . .
458
16.2.2
Three-Phase Delta-Connected AC Power Source . . . .
461
16.3
Model of Three-Phase Series RLC Load with Three-Phase
AC Power Source . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
464
16.4
Model of Three-Phase Parallel RLC Load with Three-Phase
AC Power Source . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
467
16.5
Power Factor Calculation Simulink Model . . . . . . . . . . . . . . .
468
16.6
Modeling Different Power System Conﬁgurations . . . . . . . . . .
470
16.6.1
Balanced Y-Y Power System Conﬁguration . . . . . . . .
471
16.6.2
Unbalanced Y-Y Power System Conﬁguration . . . . . .
473
16.6.3
Balanced Δ  Δ Power System Conﬁguration . . . . . .
477
16.6.4
Unbalanced Δ  Δ Power System Conﬁguration . . . .
479
16.7
Electrical Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
482
16.7.1
DC Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
484
16.7.2
Asynchronous Machine . . . . . . . . . . . . . . . . . . . . . .
485
16.8
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
487
Exercise 16 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
491
Contents
xvii

17
Application of Simulink in Power Electronics . . . . . . . . . . . . . . . . .
495
17.1
Diode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
495
17.1.1
Diode Characteristics . . . . . . . . . . . . . . . . . . . . . . . .
495
17.1.2
Single-Phase Half-Wave Rectiﬁer . . . . . . . . . . . . . . .
497
17.1.3
Single-Phase Full-Wave Rectiﬁer . . . . . . . . . . . . . . .
499
17.1.4
Three-Phase Full-Wave Rectiﬁer . . . . . . . . . . . . . . . .
504
17.2
Transistor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
506
17.2.1
Bipolar Junction Transistors (BJTs) . . . . . . . . . . . . . .
508
17.2.2
MOSFET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
510
17.2.3
IGBT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
511
17.3
Operational Ampliﬁer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
515
17.3.1
Inverting Ampliﬁer . . . . . . . . . . . . . . . . . . . . . . . . . .
516
17.3.2
Non-inverting Ampliﬁer . . . . . . . . . . . . . . . . . . . . . .
518
17.3.3
Differentiator Circuit . . . . . . . . . . . . . . . . . . . . . . . .
519
17.3.4
Integrator Circuit . . . . . . . . . . . . . . . . . . . . . . . . . . .
520
17.4
Control Devices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
520
17.4.1
Pulse Generation . . . . . . . . . . . . . . . . . . . . . . . . . . .
521
17.4.2
Controlled Rectiﬁcation with Thyristor . . . . . . . . . . .
528
17.4.3
Controlled Rectiﬁcation with GTO . . . . . . . . . . . . . .
528
17.5
Facts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
532
17.5.1
Reference Frame Transformation . . . . . . . . . . . . . . . .
534
17.5.2
Phase-Locked Loop (PLL) . . . . . . . . . . . . . . . . . . . .
536
17.5.3
Static Var Compensator . . . . . . . . . . . . . . . . . . . . . .
538
17.6
Modeling of Converters . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
542
17.6.1
Model of DC-DC Converters . . . . . . . . . . . . . . . . . .
544
17.6.2
Model of DC-AC Converter . . . . . . . . . . . . . . . . . . .
553
17.6.3
Model of AC-DC Converter . . . . . . . . . . . . . . . . . . .
560
17.6.4
Model of AC-AC Converter . . . . . . . . . . . . . . . . . . .
563
17.7
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
566
Exercise 17 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
566
18
Application of Simulink in Renewable Energy Technology . . . . . . .
569
18.1
Solar Photovoltaics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
569
18.1.1
Mathematical Model of PV Cell . . . . . . . . . . . . . . . .
569
18.1.2
PV Panel Design from Solar Cell . . . . . . . . . . . . . . . .
571
18.1.3
PV Panel Design with PV Array . . . . . . . . . . . . . . . .
577
18.1.4
Case Study: Grid-Connected PV Array . . . . . . . . . . .
581
18.2
Wind Turbine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
591
18.2.1
Model Wind Turbine-Based Generator in Simulink . . .
594
18.2.2
Case Study: Grid-Connected Wind
Turbine Generator . . . . . . . . . . . . . . . . . . . . . . . . . .
600
18.3
Hydraulic Turbine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
610
18.3.1
Case Study: Hydro Turbine and Power Generator
Model in Simulink . . . . . . . . . . . . . . . . . . . . . . . . . .
611
xviii
Contents

18.4
Battery . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
619
18.4.1
Battery Cell Implementation in Simulink . . . . . . . . . .
620
18.4.2
Battery Modeling of Different Types
in Simulink . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
620
18.4.3
Case Study: Battery Pack Design Using
Battery Cells . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
625
18.5
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
627
Exercise 18 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
631
Answer Keys to the End-of-Chapter Exercises . . . . . . . . . . . . . . . . . . . .
633
Contents
xix

About the Author
Eklas Hossain is an associate professor in the Department of Electrical Engineering
and Renewable Energy and an Associate Researcher with the Oregon Renewable
Energy Center (OREC) at the Oregon Institute of Technology (OIT), which is home
to the only ABET-accredited BS and MS programs in renewable energy. He has
been working in distributed power systems and renewable energy integration for the
last 10 years and has published a number of research papers and posters in this ﬁeld.
He is currently involved with several research projects on renewable energy and
grid-tied microgrid systems at OIT. He received his PhD from the College of
Engineering and Applied Science at the University of Wisconsin Milwaukee
(UWM), his MS in Mechatronics and Robotics Engineering from International
Islamic University of Malaysia, and a BS in Electrical & Electronic Engineering
from Khulna University of Engineering and Technology, Bangladesh. Dr. Hossain is
a registered Professional Engineer (PE) in the state of Oregon and is also a Certiﬁed
Energy Manager (CEM) and Renewable Energy Professional (REP). He is a senior
member of the Association of Energy Engineers (AEE) and an Associate Editor for
IEEE Access, IEEE Systems Journal, and IET Renewable Power Generation. His
research interests include modelling, analyzing, designing, and controlling power
electronic devices; energy storage systems; renewable energy sources; integration of
distributed generation systems; microgrid and smart grid applications; robotics, and
advanced control system.
Dr. Hossain has authored the book Excel Crash Course for Engineers, coauthored
the book Renewable Energy Crash Course: A Concise Introduction, and is working
on several other book projects. He is the winner of the Rising Faculty Scholar Award
in 2019 from Oregon Institute of Technology for his outstanding contribution to
teaching. Dr. Hossain, with his dedicated research team, is looking forward to
exploring methods to make electric power systems more sustainable, cost-effective,
and secure through extensive research and analysis on energy storage, microgrid
system, and renewable energy sources.
xxi

Chapter 1
Introduction to MATLAB
1.1
Introduction
MATLAB is a highly useful tool in engineering for solving problems, designing
systems, and simulating models. The versatile nature of MATLAB makes it suitable
for numerous applications catering to the needs of almost all engineering ﬁelds. This
book is particularly designed for electrical engineering problems. This chapter will
provide a basic overview of MATLAB and help the readers get familiarized with the
software to be able to gradually build the complete idea given in the next chapters.
1.2
What Is MATLAB?
MATLAB provides an environment for researchers and engineers of all domains to
create models and algorithms and compute and analyze numerical data with pro-
gramming capability. The acronym MATLAB came from Matrix Laboratory, as
initially the software was built with a goal to perform numerous operations on
matrices and vectors. Over the years, MATLAB has developed several toolboxes
that facilitate research on control systems, signal/image processing, deep learning,
robotics, and so on. It provides the high graphic capability to visualize data in both
2D and 3D formats. MATLAB is also a high-level programming language, and the
platform offers great ﬂexibility to use with other programming languages, e.g.,
Python, C/C++, Java, Fortran, etc. Another distinguishing feature of MATLAB is
that it can run in a public cloud environment outside the MathWorks cloud domain.
The features of parallel computing, hardware interfacing, embedded applications,
and app building have elevated MATLAB to a much higher level in the ﬁeld of
scientiﬁc research and engineering applications.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_1
1

1.3
History, Purpose, and Importance
The historical development of MATLAB, the purpose of introducing MATLAB,
and the importance of MATLAB in the present engineering world are described in
the following sections.
1.3.1
History
The earliest origin of MATLAB can be traced back to the invention of EISPAC
(Matrix Eigensystem Package) software, which was developed to solve eigenvalue
problems. The fundamental of this software was the procedure followed by ALGOL
60 to solve such problems. It was ﬁrst developed at the Argonne National Laboratory
around 1970, and the ﬁrst version of the software was released in 1971, followed by
the release of the second update in 1976. Later, another software for mathematical
analysis named LINPACK (Linear Equation Package) was developed as a byproduct
in 1975 in the same lab by Cleve Moler, Jack Dongarra, Pete Stewart, and Jim
Bunch. EISPACK and LINPACK both were formed in Fortran and can be consid-
ered as the very primal stage before the appearance of MATLAB.
Although EISPACK and LINPACK were capable of performing numerical
analysis and solving linear algebra problems, Moler wanted to upgrade both of
them to reduce the complexity of access for his students. With that aim, Moler
ﬁrst came up with the idea of MATLAB, which was named after the Matrix
Laboratory. MATLAB was simply a matrix calculator, where the data type of
input was matrix. This version was created by Moler only for the usage of his
students, which is later regarded as classical MATLAB.
The idea of the ﬁrst commercial MATLAB was proposed by a graduate student of
Stanford named Jack Little in 1983. Jack Little, Steve Bangert, and Cleve Moler took
the initiative to bring IBM PC-based MATLAB, which was translated in C from
Fortran. The ﬁrst PC-based commercial MATLAB made its appearance in
December 1984, followed by the ﬁrst marketization in 1985. This new version of
MATLAB was updated and modiﬁed signiﬁcantly by both Jack Little and Steve
Bangert, where they added many mathematical functions, graphics, and toolboxes
based on various applications. MATLAB has been upgraded multiple times for
adjusting itself with the new applications and requirements in the domain of engi-
neering and science. The major changes that have occurred over time in different
versions of MATLAB are summarized in Table 1.1.
2
1
Introduction to MATLAB

1.3.2
Purpose and Importance
The original purpose of MATLAB is to provide a programming platform where
mathematical analysis, along with different applications in the engineering and
science domain, can be performed in the most optimized and user-friendly way.
As mentioned earlier, MATLAB can take input in the form of a matrix; hence, the
vector, array, and matrix operations can be performed more easily by writing
minimal code compared to other programming languages. In MATLAB, algorithm
development and advanced mathematics problems can be solved using numerous
built-in functions. One of the most important features of MATLAB is its toolbox,
which can be used to enhance the performance of MATLAB in any desired domain.
Table 1.1 Chronological development of MATLAB
MATLAB version
Major features
Year
Classical
MATLAB
• Input data type matrix
Around
1981
• Used as a simple matrix calculator
• Written in Fortran
MATLAB 1.0
(PC-MATLAB)
• Translated in C from Fortran
1984
• IBM PC-based software
• Multiple mathematical functions, graphics, and
toolboxes
MATLAB-3
• Ordinary differential equation toolbox
1987
• Signal processing toolbox
MATLAB-4
• Simulink
1992
• Sparse matrix
• 2D and 3D color graphics
MATLAB-5
• Data types
1996
• Visualization (advanced)
• Cell arrays and structure
• Graphical user interface
MATLAB-6
• Desktop MATLAB
2000
• Linear Algebra Package (LAPACK)
MATLAB-7
• Parallel computing toolbox
2004
• Anonymous function
• Nested function
• Integer data types
MATLAB-8
• MATLAB app
2012
• Toolstrip interface
MATLAB-9
• Live editor
2016
• App designer
MATLAB-9.9
• Simulink online
2020
MATLAB-9.10
• Satellite communication toolbox
2021
• Radar toolbox
• DDS blockset
1.3
History, Purpose, and Importance
3

MATLAB covers control systems, signal processing, image processing, robotics,
communications, mechatronics, biology, data analytics, and other numerous ﬁelds in
different domains. Such widespread versatility and functionality of MATLAB have
made it one of the most widely used scientiﬁc platforms in the world.
1.4
Installation and Dependencies
Installation of MATLAB software can be conducted in three ways [1], as described
hereunder.
Method 1: Installation with Internet Connection
Step 1: Sign in to the MathWorks account and download the installer.
Step 2: Run the installer and accept the license agreements, which will create the
appearance of the following window in Fig. 1.1.
Step 3: Use the activation key, or navigate to the relevant license ﬁle by selecting the
Advanced Options > I want to install network license manager.
Step 4: Navigate to the directory, where the MATLAB will be installed.
Step 5: MATLAB provides a variety of products, and it provides the option to the
user to only install products that are necessary, or relevant for a particular user.
Thus, it facilitates the users to save enough space by avoiding the installation of
irrelevant products. Choose the products based on your work or interest.
Step 6: Choose any convenient option and make the conﬁrmation.
Step 7: Click on the “Begin Install” option, and wait for a while.
Step 8: After the installation is completed, a “Finish” option will appear. By clicking
on it, ﬁnalize the installation of MATLAB.
Method 2: Installation Using File Activation Key
Step 1: Start the installer by clicking on the installer ﬁle.
Step 2: Accept all the terms and agreements.
Fig. 1.1 MathWorks Product Installer
4
1
Introduction to MATLAB

Step 3: Find the “Advanced Option” dropdown box, and choose the option “I have a
File Installation Key.” This is shown in Fig. 1.2.
Step 4: Enter the key.
Step 5: Navigate to the license ﬁle location.
Step 6: Navigate to the directory, where MATLAB will be installed.
Step 7: Choose the products for the installation.
Step 8: Choose the options that are convenient.
Step 9: Click on the “Begin Install” option, and wait for a while.
Step 10: After the installation is completed, a “Finish” option will appear. By
clicking on it, ﬁnalize the installation of MATLAB.
Method 3: Download Installation Package
Step 1: Download the installation ﬁle and run the installer.
Step 2: MathWorks sign-in option will appear; hence, sign in to the account. From
the dropdown “Advanced Options,” select the “I want to download without
installing” option.
Step 3: Navigate to the directory where MATLAB will be installed.
Step 4: Choose the platform of installation and also decide the products that are
relevant to be installed.
Step 5: After proceeding further, a “Begin Download” option will appear. Click on
that option, and wait for a while.
Step 6: When the download will be ﬁnished, click on the “Finish” button, which will
appear right after the completion of the download.
Step 7: Move the ﬁle to the desired destination, and run the installer ﬁle. For
windows, the installer ﬁle will be found as “setup.exe.” For Linux and MAC,
the name of the installer ﬁle will be “install” and “InstallForMacOSX,”
respectively.
Step 8: After running the installer ﬁle, follow Method 1, if the Internet connection is
available. Otherwise, follow Method 2, if a ﬁle activation key is available for
completing the installation.
Fig. 1.2 MathWorks Product Installer dropdown menu
1.4
Installation and Dependencies
5

1.4.1
Dependencies
Before installing MATLAB, the dependencies, or the system requirements, need to
be checked. The dependencies for different platforms are listed in Table 1.2.
Table 1.2 Dependencies of MATLAB
Windows
Mac
Linux
Operating
systems
• Windows Server 2016
• Windows Server 2019
• Windows 7 Service Pack
1
• Windows 10 (version
1803 or higher)
• macOS Mojave (10.14)
• macOS Catalina (10.15)
• macOS Big Sur (11)
• Red Hat Enterprise
Linux 7 (minimum 7.6)
• Red Hat Enterprise
Linux 8 (minimum 8.1)
• Ubuntu 16.04 LTS
• Ubuntu 18.04 LTS
• Ubuntu 20.04 LTS
• SUSE Linux Enterprise
Server 12 (minimum
SP2)
• SUSE Linux Enterprise
Desktop 12 (minimum
SP2)
• SUSE Linux Enterprise
Server 15
• SUSE Linux Enterprise
Desktop 15
RAM
Min. 4 GB
Recommended: 8 GB
For Polyspace: 4 GB/core
(recommended)
Min. 4 GB
Recommended: 8 GB
For Polyspace: 4 GB/core
(recommended)
Min. 4 GB
Recommended: 8 GB
For Polyspace: 4 GB/
core (recommended)
Processors
Min. any Intel or AMD
x86-64 processor
Recommended: any Intel
or AMD x86-64 processor
with four logical cores and
AVX2 instruction set
support
Min. any Intel x86-64
processor
Recommended: any Intel
x86-64 processor with
four logical cores and
AVX2 instruction set
support
Min. any Intel x86-64
processor
Recommended: any Intel
x86-64 processor with
four logical cores and
AVX2 instruction set
support
Disk
3.4 GB of HDD space for
MATLAB only, 5–8 GB
for a typical installation
A full installation of all
MathWorks products may
require 29 GB
3 GB of HDD space for
MATLAB only, 5–8 GB
for a typical installation
A full installation of all
MathWorks products
may require 22 GB
3.3 GB of HDD space for
MATLAB only, 5–8 GB
for a typical installation
A full installation of all
MathWorks products
may require 27 GB
Graphics
Graphics card: not limited
Recommended: hardware
accelerated graphics card
supporting OpenGL 3.3
with 1 GB GPU memory
Graphics card: not limited
Recommended: hardware
accelerated graphics card
supporting OpenGL 3.3
with 1 GB GPU memory
Graphics card: not lim-
ited
Recommended: hard-
ware accelerated
graphics card supporting
OpenGL 3.3 with 1 GB
GPU memory
6
1
Introduction to MATLAB

1.5
Starting MATLAB
Windows: Open the program menu and ﬁnd the MATLAB application ﬁle (matlab.
exe) from the directory. Double-click on it to start the MATLAB.
Linux: Open the terminal and write “matlab.” After pressing enter, the MATLAB
will start.
Mac: On the dock, ﬁnd the MATLAB icon. By clicking on it, MATLAB can be
opened.
1.6
MATLAB Environment
In the MATLAB environment, there are multiple windows that can be set as the
starting layout. In a starting layout, the basic windows that are docked in default
form are Command Window, Editor, Current Folder, and Workspace. In the header
tool strip of MATLAB, the “Layout” option is available, by clicking on which the
layout can be changed according to our convenience. In Fig. 1.3, the layout of the
MATLAB starter page in default mode is shown. The “Command Window” pro-
vides a window where any MATLAB command can be written for execution. The
command can be run by pressing the “Enter” button on the keyboard. For writing a
long program, the command window probably is not the best place. For that, the
“Editor” window is available, where a complete program can be written and run for
execution. The output of the program will appear on the command window. In the
default mode, there are also two other windows: Current Folder or Directory and
Fig. 1.3 MATLAB environment
1.6
MATLAB Environment
7

Workspace. The current directory indicates the directory from where any MATLAB
ﬁle can be exported or imported. In the workspace, all the variables deﬁned in the
command window, or the editor, will appear along with their values after the
execution of the program. From the “Layout” menu, “Command History” window
can also be docked in the starter page, which lists all the previous commands in an
ordered manner. Therefore, if any previous command needs to be reused, it can be
selected from the command history. By clicking the “Up” and “Down” key of the
keyboard, the previous commands can also be navigated. In MATLAB, there is a
header tool strip, where multiple menus and tools are available, which are also parts
of the MATLAB environment.
1.7
Features of MATLAB
The features of MATLAB are crucial in the ﬁeld of engineering. Some of the most
important features of MATLAB can be listed as follows:
1. High-level programming language
2. Built-in graphics
3. Interactive environment
4. High computational capability
5. Numerous mathematical functions
6. Numerous toolboxes dedicated to separate applications
7. Compatibility with other languages
8. Parallel computing
9. App designing
10. Algorithm formation
11. Hardware interfacing
12. Deployment capability, etc.
One of the important aspects of MATLAB is that it is not limited to one
application area; instead, it covers a wide area of applications. MATLAB 9.10
version has a total of 82 toolboxes dedicated to numerous application ﬁelds in
various domains. A list of available toolboxes in different application ﬁelds is
given in Table 1.3.
1.8
Variables in MATLAB: Categories and Conversion
Between Variables
While writing a MATLAB code, variables are used to deﬁne different parameters
that are needed to be used in the same program multiple times. In variable deﬁnition,
the main task is to assign data against each variable, and this assigned data can be of
8
1
Introduction to MATLAB

different types, such as integer, ﬂoat, string, etc. When a variable is deﬁned, it can be
observed in the Workspace. The name of the variables can be any letter, or any
combination of multiple letters and numbers, such as “var1.” However, a variable’s
name cannot be started with a number; for example, “1var” is not a valid variable
name. In addition, special characters such as “@,” “#,” “$,” “&,” and “-” cannot be
included in a variable’s name. Underscore can be allowed to be used in the variable’s
name except at the starting place. For example, “var_1” is a valid variable name, but
“_var” is invalid in MATLAB.
1.8.1
Categories of Data Types
The mostly used categories of data types of variables can be listed as follows:
(a) Numeric data type: integer, ﬂoat (single and double), and logical
(b) Character and string type: character, string, and cell array
(c) Date and time
An example of variable deﬁnition for each of the above-mentioned data types is
given below using MATLAB.
1.8.2
MATLAB Example 1.1: Different Data Types
The MATLAB code demonstrating different data types is given in Fig. 1.4, and its
output is given in Fig. 1.5.
Table 1.3 Number of toolboxes available in MATLAB for various applications
Applications
Number of toolboxes
Aerospace
04
Automotive
10
Code veriﬁcation
07
Computational biology
02
Computational ﬁnance
07
Control systems
10
FPGA, ASIC, and SoC development
08
Image processing and computer vision
03
RF and mixed signal
05
Robotics and autonomous systems
09
Signal processing
06
Test and measurement
06
Wireless communications
05
Total
82
1.8
Variables in MATLAB: Categories and Conversion Between Variables
9

Fig. 1.4 Code—Different data types in MATLAB
Fig. 1.5 Output—Different data types in MATLAB
10
1
Introduction to MATLAB

Output:
In MATLAB whos command can be used to print the details of all the deﬁned
variables stored in the Workspace. More precisely, it provides the name, size, bytes,
class, and attributes of the deﬁned variables. Here, the class indicates the data types
of the variable. For example, the class of var1 is int8, which signiﬁes that var1 is a
positive signed 8-bit integer. The data types of the rest of the variables can also be
found from the above-mentioned output.
After deﬁning a variable, the assigned data of the variable can be reused any time
throughout the program, unless the variable is reassigned with new data, or cleared
by MATLAB command. To erase any deﬁned variable from MATLAB, the clear
command can be utilized. Variables can also be cleared by selecting them in the
Workspace window and selecting the delete option.
•
If you want to erase all variables from the MATLAB memory, type
clear or clear all
•
To erase a speciﬁc variable, say x, type clear x
•
To clear two speciﬁc variables, say x and y, type clear x y
•
To clear only the command window, type clc
1.8.3
Conversions
The data types of the deﬁned variables can be converted in MATLAB. The most
used conversions that are required are number-to-text conversion and text-to-number
conversion. The commands for such conversions are listed in Table 1.4.
A MATLAB example is given below for further illustration.
Table 1.4 MATLAB functions for data type conversion
Number to text
Text to number
• int2str(number)
Convert any integer number to a character.
Here, number indicates any integer number
• num2str(number)
Convert any number to a character. Here,
number indicates any number
• char(number)
Convert any number to a character. Here,
number indicates any number
• string(number)
Convert any number to a string. Here,
number indicates any number
• str2num(text)
Convert any character or string into a double
number. Here, text indicates any character or
string
• str2double(text).
Convert any character or string into a double
number. Here, text indicates any character or
string
1.8
Variables in MATLAB: Categories and Conversion Between Variables
11

1.8.4
MATLAB Example 1.2: Conversion of Data Types
The MATLAB code demonstrating the conversion of data types is given in Fig. 1.6,
and its output is given in Fig. 1.7.
Output:
Here, all the conversions can be veriﬁed by observing the “Class” of all the
variables.
Fig. 1.6 Code—Conversion of data types in MATLAB
12
1
Introduction to MATLAB

1.9
Suppressing Output
In MATLAB, after each command, a semicolon is used to suppress the output.
Without a semicolon, the output of the command will be printed on the command
window. In general, we normally use a semicolon at the end of every line of code,
except the ﬁnal output, or the results we want to see in the command window.
An example of MATLAB code with and without the usage of the semicolon is
shown in Fig. 1.8 to understand the distinction between them:
Fig. 1.7 Output—Conversion of data types in MATLAB
Fig. 1.8 Suppressing output in MATLAB
1.9
Suppressing Output
13

Here, in the ﬁrst example, a vector a has been deﬁned without using a semicolon.
As an outcome, the value of a is printed in the command window. In the second
example, with the usage of the semicolon, the output is suppressed.
1.10
Recording a MATLAB Session
In MATLAB, diary function can be useful while recording a MATLAB session that
creates a ﬁle containing the keyboard inputs and the outputs. The MATLAB
command for the usage of the diary function is as follows:
MATLAB command for recording a session:
diary 0Name0
ð
Þ
Here, 0Name0 indicates the name of the ﬁle in which the session will be
recorded.
A MATLAB example is provided in Fig. 1.9 with its output in Fig. 1.10 for
further illustration.
Output:
Here the output including the keyboard inputs is recorded in a text ﬁle named
“DiaryFile.txt,” as shown above in the output. To record a particular part of the
MATLAB session, diary on and diary off command placed at the start and the end of
a session, respectively, can be very useful. Later, the diary(‘Name’) command can be
used to deﬁne the ﬁle name on which the recorded version will be saved.
Fig. 1.9 Code—diary function in MATLAB
14
1
Introduction to MATLAB

1.11
Printing Output
The output of the MATLAB program can be printed in the command window by
using two MATLAB built-in functions fprintf() and disp(). It provides the users great
ﬂexibility to choose which output they want to print. Both fprintf() and disp()
commands are explained below:
MATLAB fprintf command printing:
fprintf 0text0
ð
Þ
fprintf 0text%d0, var
ð
Þ
fprintf 0text% f 0, var
ð
Þ
fprintf 0∖n0
ð
Þ
Here, 0text0 can be any string or character, and var indicates the value of a
variable that is required to be printed. Finally, 0\n0 is used to shift to the
next line.
fprintf() can be used to print both text and numbers in the command window. The
input provided within the bracket will be printed in the command window as a string,
or characters. If the deﬁned value of any variable is required to be printed with text,
the fprintf(0text % d0, var) command can be utilized where %d will be replaced by the
value of the deﬁned variable var. Here var indicates the name of the variable.
However, it is only true if the variable is an integer type. For printing the values of
ﬂoat type variables, %f is used in place of %d. To shift to a new line, \n is used.
Fig. 1.10 Output—diary function in MATLAB
1.11
Printing Output
15

A MATLAB example regarding the usage of the fprintf() is provided in Fig. 1.11
with its output in Fig. 1.12.
Output:
Here, in the ﬁrst fprintf() command, a text is printed. In the second command, \n is
used to print the next output in a separate line. In the third command, an integer
variable named var is printed with text. Finally, in the fourth command, a ﬂoat type
variable printing with text is shown.
disp() is another MATLAB command for printing output. The usage of disp()
command is shown below:
MATLAB ‘disp’ command printing:
disp 0text0
ð
Þ
disp var
ð
Þ
disp
0text0, num2str var
ð
Þ
½

ð
Þ
Here, 0text0 can be any string or character, and var indicates the value of a
variable that is required to be printed.
In disp(), a new line shift occurs by default; hence, \n notation, as used in fprintf(),
is not required to use here. To print both strings and variables, it is necessary to
convert the data types of the variables in a string format while using disp(). In the
Fig. 1.11 Code—fprintf function in MATLAB
Fig. 1.12 Output—fprintf function in MATLAB
16
1
Introduction to MATLAB

above example, num2str() function is used to convert the data types of the variable in
string format. An example of the usage of disp() is shown in Fig. 1.13 with its output
in Fig. 1.14 for better understanding.
Output:
1.12
Conclusion
This chapter provides a brief introduction to MATLAB and presents the history,
purpose, and importance of MATLAB. The concept of MATLAB is put forward
such that the chapter can be interesting for a new audience. To help the readers
getting started with MATLAB with a hand-in experience, the chapter provides step-
by-step methods of its installation procedures. The readers are advised to implement
all the examples and coding in MATLAB simultaneously to understand the contents
more rigidly. To accomplish this purpose, this chapter introduces the overall
MATLAB environment along with some fundamental features, so that the readers
can feel comfortable writing MATLAB code while going through the rest of
the book.
Fig. 1.13 Code—disp function in MATLAB
Fig. 1.14 Output—disp function in MATLAB
1.12
Conclusion
17

Exercise 1
1. Write down some of the notable applications of MATLAB in engineering.
2. What are the major data types in MATLAB? How are they represented in
MATLAB programming?
3. Mention the usage of the following commands/functions with examples where
applicable:
(a) clc
(b) num2str()
(c) str2double()
(d) int8()
(e) disp()
4. Perform the following operations in MATLAB and save the results in a variable.
Demonstrate the variables using “whos” command:
(a) 2*4^2
(b) (2*4)^2
(c) 503+224604
(d) (10^3)/(9*2)
(e) 6.25*0.42^3.56
(f) Save “MATLAB is fun!” in a variable
5. Take two numerical inputs from the user and save them in variables num1 and
num2. Perform the following operations and record the session using the diary
function:
(i) num1/num2
(ii) num1\num2
Do they produce the same result? If not, why?
Reference
1. https://www.mathworks.com/help/install/
18
1
Introduction to MATLAB

Chapter 2
Vectors and Matrices
2.1
Introduction
Vectors and matrices are two of the data types that can be taken as input directly by
MATLAB. Initially, MATLAB was regarded as a matrix calculator, which has been
extended and modiﬁed signiﬁcantly over the years. A vector is a one-dimensional
matrix that contains multiple values ordered either in a row or a column. If the values
are ordered in a row, the vector is regarded as a row vector. Conversely, in a column
vector, all the values are incorporated in a single column. A matrix has multiple
values placed in both rows and columns. In another sense, a matrix can be formed by
aggregating multiple vectors. The number of rows and columns of a matrix deter-
mines its size. As in MATLAB, the input data types can be of both matrix and
vector; it is imperative to learn about different vector and matrix operations that can
be performed directly in MATLAB. Therefore, this chapter aims to demonstrate the
manipulations and operations of vectors and matrices in light of MATLAB
implementations.
2.2
Creating Vectors
A vector can be created in MATLAB by using the values enclosed within square
brackets, [ ]. To differentiate among different values, a space is used. A vector can be
a row vector or column vector. In a row vector, the values are separated using space,
and in the case of a column vector, semicolons are used among the values. For
example, A is a row vector, which contains four values that are separated using space
between two neighboring values (Fig. 2.1). Here, the size of vector A is 1  4, which
represents the vector containing four values in a single row.
For a column vector, the values are arranged over a single column. An example of
a column vector having a size of 4  1 is shown in Fig. 2.2.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_2
19

A vector having values of equal increment or decrement can be deﬁned in an
easier way for avoiding enlisting a large number of values manually. For example, if
a vector B contains values starting from 1 to 12 with +2 increment, it can be deﬁned
as shown in Fig. 2.3.
The vector B has three entities—the ﬁrst one is the starting value and the last one
is the ending value of the vector. The values are equally spaced and have a +2
increment. The increment value represents the middle entity of the B vector. In case,
the increment is +1, the middle entity can be skipped as MATLAB considers +1 as
the default increment. For decrement or negative increment, the middle entity will
become a negative value. An example of a vector having descending values with
negative increment is given in Fig. 2.4.
Fig. 2.1 A row vector
Fig. 2.2 A column vector
Fig. 2.3 A row vector with increments
Fig. 2.4 A row vector with decrements
20
2
Vectors and Matrices

2.3
Creating Matrices
A matrix can be deﬁned in the same way as a vector. A matrix can have multiple
rows and columns, based on which its size is determined. The size can be controlled
by using space and semicolons. Space indicates a shift from one column to another
within a single row, whereas a semicolon represents the end of one row or the start of
a new row. The size of any vector is deﬁned by row  column.
An example is shown in Fig. 2.5 to realize the row-column deﬁnition of a matrix
in MATLAB.
Here, the size of matrix A is 4  3, which signiﬁes A has 4 rows and 3 columns.
The semicolon is used to shift to a new row, while space corresponds to separate
column values.
2.4
Manipulation of Vectors and Matrices
A matrix can be formed by combining multiple vectors. A simple example is given
in Fig. 2.6, where three row vectors V1, V2, and V3 formed a new matrix M.
While combining vectors to make a matrix, it is noted that the sizes of all the
vectors need to be identical.
After deﬁning a vector or matrix, it is essential to access each value. In a matrix,
row and column numbers are used to specify the position of a certain value, which
can be used to access a speciﬁc value in a matrix. For example, in matrix M, the value
“8” situated in the third column of the second row. This value can be accessed by
using the following command in Fig. 2.7.
Here, 2 signiﬁes the row number and 3 represents the column number. Using this
concept, a matrix can be broken down into separate vectors. For example, the matrix
M can be interpreted as three separate row vectors as presented in Fig. 2.8.
Here, V1, V2, and V3 represent the values of the ﬁrst, second, and third rows of M,
respectively. It is noted that a colon (:) is used while accessing multiple values.
V1 ¼ M(1, :) signiﬁes all the values that are positioned in the ﬁrst row of every
column of matrix M. If the entities are interchanged as V1 ¼ M(:, 1), it will depict all
the values of M residing on the ﬁrst column and every row. In that case, V1 will
become a column vector instead of a row vector.
Fig. 2.5 A 4  3 matrix
2.4
Manipulation of Vectors and Matrices
21

2.5
Dimensions of Matrices
The dimension of a matrix can be represented by row  column, where row indicates
the total number of rows and column refers to the number of columns of that matrix.
In MATLAB, the dimension of a matrix can be determined by using size().
The MATLAB command for determining the dimension of a matrix, A:
size A
ð Þ
Fig. 2.6 Manipulation of vectors and matrices
Fig. 2.7 Accessing value from a matrix
22
2
Vectors and Matrices

2.5.1
MATLAB Example 2.10: Dimension of a Matrix
The MATLAB code for determining the dimension of a matrix is given in Fig. 2.9,
and its output is given in Fig. 2.10.
Output:
Fig. 2.8 Accessing vectors from a matrix
Fig. 2.9 Code—Dimension of a matrix
2.5
Dimensions of Matrices
23

2.6
Operations on Matrices
Several operations may be performed upon a matrix, such as addition, subtraction,
multiplication, making transpose, making inverse, etc. These operations are
described in the following sections.
2.6.1
Addition and Subtraction
The addition and subtraction of two matrices can be performed by using the “+” and
“” signs, respectively. However, it is to be noted that the sizes of two matrices need
to be identical while performing either addition or subtraction.
The MATLAB command for addition is “+” sign.
The MATLAB command for subtraction is “2” sign.
2.6.2
MATLAB Example 2.1: Addition and Subtraction
In Fig. 2.11, both A and B are 3  3 matrices. The addition of these two matrices is
the element-wise addition, and the size of the output is the same as matrices A and B.
Similarly, the subtraction (sub) is the element-wise subtraction of two matrices
A and B.
Fig. 2.10 Output—
Dimension of a matrix
24
2
Vectors and Matrices

2.6.3
Multiplication
The multiplication of two matrices is possible only if the number of columns of the
ﬁrst matrix equals the number of rows of the second matrix. Consider two matrices
X and Y as shown in Fig. 2.12, whose sizes are n  m and m  r, respectively. As the
number of columns of X and the number of rows of Y are similar, X and Y can be
multiplied. The size of the product of these matrices will be n  r.
Fig. 2.11 Addition and subtraction of matrices
Fig. 2.12 Matrix size in multiplication
2.6
Operations on Matrices
25

2.6.4
MATLAB Example 2.2: Multiplication
The MATLAB command for multiplication is the “*” symbol.
In Fig. 2.13, the sizes of matrices X and Y are 2  3 and 3  2, respectively. The
column number of X and the row number of Y are similar, which is 3. Hence,
multiplication can be performed and the size of the output is 2  2 (the row number
of X  the column number of Y).
Note that the multiplication of matrices is noncommutative, i.e., M  N and
N  M are not the same thing. Therefore, if two matrices fulﬁll the condition of
multiplicativity, it is not necessary that they will do so in the reverse order as well.
2.6.5
Transpose
A transpose matrix is a matrix whose row and column values interchange with each
other. For example, if X is a n  m dimensional matrix, the dimension of the
transpose matrix of X will be m  n by swapping the row and column values with
each other.
Fig. 2.13 Matrix multiplication
26
2
Vectors and Matrices

2.6.6
MATLAB Example 2.3: Transpose
The MATLAB command for transposing a matrix is to use the prime (0)
symbol.
In Fig. 2.14, the dimension of the X matrix is 2  3, while the transpose matrix
X_T has a dimension of 3  2 due to the swapping of row and column values.
2.6.7
Determinant
A determinant of a matrix provides a distinguished scalar value; however, it is only
applicable for a square matrix. A square matrix is a matrix whose row and column
numbers are identical. Consider a square matrix X, whose dimension is 2  2. The
determinant of matrix X can be referred to as |X| or det(X), which can be determined
as follows:
X ¼ a b; c d
½
,
ð2:1Þ
X
j j ¼ ad  bc:
ð2:2Þ
Consider another square matrix Y with a dimension of 3  3. In this case, the
determinant can be derived by utilizing the following method:
Y ¼ a b c; d e f ; g h i
½

ð2:3Þ
Y
j j ¼ a  det e f h i
½
  b  det d f g i
½
 þ c  det d e g h
½

ð2:4Þ
Fig. 2.14 Transpose of a matrix
2.6
Operations on Matrices
27

2.6.8
MATLAB Example 2.4: Determinant
Figure 2.15 shows how to create a determinant in MATLAB.
The MATLAB command for calculating determinant is to use det()
function.
2.6.9
Identity Matrix
An identity matrix has three distinctive characteristics:
1. It is a square matrix.
2. The diagonal values of an identity matrix are 1. The other values except for the
diagonal values are all zero.
3. The determinant of an identity matrix is always 1.
For example, a 3  3 identity matrix, I3  3, or I3 ¼ [1 0 0; 0 1 0; 0 0 1 ]
2.6.10
MATLAB Example 2.5: Identity Matrix
The MATLAB command for identity matrix is to use eye(N) function,
where N represents the dimension.
In Fig. 2.16, I is a three-dimensional identity matrix.
Fig. 2.15 Determinant of a matrix
28
2
Vectors and Matrices

2.6.11
Inverse Matrix
If the determinant of a certain matrix is zero, it is called a singular matrix. A
non-singular matrix always has a nonzero determinant. Consider a non-singular
square matrix X having a dimension of n  n. If another matrix Y, having the
same dimension as X, can be related as XY ¼ I, the second matrix Y can be regarded
as the inverse matrix of X. Here, I represents the identity matrix, which has the same
dimension as X and Y.
If X is a matrix, the inverse matrix of X can be represented as X1. The matrix X is
invertible only if:
1. X is a square, non-singular matrix
2. XX1 ¼ I
The mathematical formula for determining inverse matrix X1 is as follows:
X1 ¼ adj X
ð Þ
det X
ð Þ
ð2:5Þ
Here, adj(X) is the adjugate of matrix X. The adjugate of a matrix can be
determined by transposing the cofactor of that matrix.
2.6.12
MATLAB Example 2.6: Inverse Matrix
The MATLAB command for calculating the inverse of a matrix is to use
inv() function.
In Fig. 2.17, X is a 3  3 square non-singular matrix. Implementing inv(X), the
inverse matrix of X is determined, which has the same dimension as matrix X.
Fig. 2.16 Identity matrix
2.6
Operations on Matrices
29

2.7
Simple Matrix Concatenation
Multiple matrices can be appended together to form a larger combined matrix using
matrix concatenation. Matrix concatenation can be of two types—horizontal and
vertical concatenation. When two matrices are concatenated horizontally, the pro-
cess is called horizontal concatenation; conversely, vertical concatenation occurs
when one matrix appends with the other vertically.
A MATLAB example showing both horizontal and vertical concatenation is
given below.
2.7.1
MATLAB Example 2.9: Matrix Concatenation
The MATLAB code demonstrating matrix concatenation is given in Fig. 2.18, and
its output is given in Fig. 2.19.
Fig. 2.17 Inverse matrix
Fig. 2.18 Code—Matrix concatenation
30
2
Vectors and Matrices

Output:
In horizontal concatenation, two matrices are enclosed within the third bracket by
separating them with a comma. For vertical concatenation, the comma is replaced by
a semicolon.
2.8
Creating Arrays of Zeros, Ones, and Random Numbers
While writing MATLAB programs, arrays of zeros and ones may become essential
in some aspects. In MATLAB the commands for producing each of these arrays are
listed below:
The MATLAB command for producing arrays of zeros: zeros(row, col)
The MATLAB command for producing arrays of ones: ones(row, col)
Fig. 2.19 Output—Matrix
concatenation
2.8
Creating Arrays of Zeros, Ones, and Random Numbers
31

2.8.1
MATLAB Example 2.7: Arrays of Zeros and Ones
The MATLAB code for demonstrating arrays of zeros and ones is given in Fig. 2.20,
and its output is given in Fig. 2.21.
Output:
Here, the sizes of arrays for both zeros and ones are considered as 3  4.
Random number generation is another important task that is usually needed while
writing MATLAB code. For verifying any particular program with random input
values, random number generation can be very effective. In MATLAB, based on the
types of random numbers that are required to be generated, the MATLAB command
may vary. Some of the MATLAB commands for generating random number arrays
are given below:
Fig. 2.20 Code—Arrays of zeros and ones
Fig. 2.21 Output—Arrays
of zeros and ones
32
2
Vectors and Matrices

The MATLAB command for producing arrays of random numbers that
are uniformly distributed:
rand row, col
ð
Þ
The MATLAB command for producing arrays of random numbers that
are normally distributed:
randn row, col
ð
Þ
The MATLAB command for producing arrays of random pseudo-integer
numbers that are uniformly distributed:
randi nummin, nummax
½
, row, col
½

ð
Þ
Here, row and col indicate the array size; nummin and nummax are the
minimum and maximum range of the generated random numbers.
The MATLAB command for producing arrays of random numbers that
are uniformly distributed:
rand row, col
ð
Þ
The MATLAB command for producing arrays of random numbers that
are normally distributed:
randn row, col
ð
Þ
The MATLAB command for producing arrays of random pseudo-integer
numbers that are uniformly distributed:
randi nummin, nummax
½
, row, col
½

ð
Þ
Here, row and col indicate the array size; nummin and nummax are the
minimum and maximum range of the generated random numbers.
2.8.2
MATLAB Example 2.8: Random Numbers
The MATLAB code to create arrays of random numbers is given in Fig. 2.22, and its
output is given in Fig. 2.23.
2.8
Creating Arrays of Zeros, Ones, and Random Numbers
33

Output:
From the output, it can be observed that randi() can be used to generate an array
of pseudo-integers within a predeﬁned range. For the other two functions, rand() and
randn() do not have the features of specifying the range.
Fig. 2.22 Code—Arrays of random numbers
Fig. 2.23 Output—Arrays of random numbers
34
2
Vectors and Matrices

2.9
Array Function for One-Dimensional Arrays
Several functions are available in MATLAB to perform operations on a
one-dimensional array. Three important and widely used functions will be discussed
in this section, namely, linspace(), max (), and min().
linspace() is a function that can be used to create a one-dimensional array, which
contains equally spaced values within a speciﬁc range.
The MATLAB command for linspace() function:
linspace Lowerlimit, Upperlimit, point
ð
Þ
The above command creates a one-dimensional array that includes values
within the range of [Lowerlimit, Upperlimit], and point indicates the num-
ber of evenly spaced values.
In a linspace(), the number of values that one requires within a certain range can
be given as input. The function automatically creates an array of evenly spaced
values maintaining the range and the number of values.
In another version of MATLAB command, the space/range between the upper
and lower limits can be speciﬁed. This command can create a one-dimensional array
maintaining the speciﬁed range. The MATLAB command can be written as follows:
Alternative MATLAB command for linspace() function:
Lowerlimit : space : Upperlimit
A MATLAB example is provided below to show a demonstration of both the
commands:
2.9.1
MATLAB Example 2.11: Creating Linearly Spaced
One-Dimensional Array
The MATLAB code to create a linearly spaced one-dimensional array is given in
Fig. 2.24, and its output is given in Fig. 2.25.
Output:
2.9
Array Function for One-Dimensional Arrays
35

From the output in Fig. 2.25, it can be observed that the results are the same for
both MATLAB commands. However, the difference is the input that the user can
provide. For linspace(), the number of points is given as an input, which is 5. For the
second command, the space or the difference among the values is speciﬁed, which is
2.5. As the range is kept the same for both of the instances, the generated arrays are
identical in both cases.
To determine the maximum or the minimum values within an array, max() and
min() can be used in MATLAB.
The MATLAB command for determining the maximum value of an
array, A: max(A)
The MATLAB command for determining the minimum value of an
array, A: min(A)
Fig. 2.24 Output—Arrays of random numbers
Fig. 2.25 Output—Linearly spaced one-dimensional array
36
2
Vectors and Matrices

2.9.2
MATLAB Example 2.12: Finding Maximum
and Minimum Value from an Array
The MATLAB code to ﬁnd the minimum and maximum value from an array is given
in Fig. 2.26, and its output is given in Fig. 2.27.
Output:
2.10
Mean, Standard Deviation, Variance, and Mode
Mean, standard deviation, and variance are three essential statistical terminologies to
understand the distribution of data. In a one-dimensional array, multiple values are
available. Determining the mean, standard deviation, and variance of an array can
Fig. 2.26 Code—Finding maximum and minimum value from an array
Fig. 2.27 Output—Finding maximum and minimum value from an array
2.10
Mean, Standard Deviation, Variance, and Mode
37

help to understand the characteristics of the data and infer conclusions from the
pattern.
Mean: The average of all the values in an array is called the mean or arithmetic
mean. In MATLAB, the mean value of an array can be determined using the mean ()
function.
Variance: The variance is the average of the squared difference between each value
and the mean of an array, which can be represented as in Eq. (2.6).
Variance ¼
PN
n¼1 xn  x
ð
Þ2
N
,
where, n ¼ 1, 2, 3, . . . , N
ð2:6Þ
Here, N is the length of an array or the number of values in an array; x is the mean
of the array. In MATLAB, the variance of an array can be determined by using var()
function.
Standard deviation: Standard deviation is the square root of the variance of an
array. Therefore, the standard deviation of an array can be written as in Eq. (2.7).
Standard deviation ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
PN
n¼1 xn  x
ð
Þ2
N
s
,
where, n ¼ 1, 2, 3, . . . , N
ð2:7Þ
The MATLAB command for determining the standard deviation of an array
is std().
Mode: In an array, the value that creates the maximum appearance is regarded as
the mode of that array. The MATLAB command for determining the mode of an
array is mode().
The MATLAB command for determining the mean value of an array, A:
mean(A)
The MATLAB command for determining the variance of an array, A:
var(A)
The MATLAB command for determining the standard deviation of an
array, A: std(A)
The MATLAB command for determining the mode of an array, A:
mode(A)
It is to be noted that mode(A) provides the most frequent value of an array.
However, if all the values in an array appear only one time, mode()
recognizes the lowest value of that array as its mode.
38
2
Vectors and Matrices

2.10.1
MATLAB Example 2.13: Mean, Variance, Standard
Deviation, and Mode
The MATLAB code demonstrating the use of mean, variance, standard deviation,
and mode is given in Fig. 2.28, and its output is given in Fig. 2.29.
Output:
2.11
Dot Operator
The dot operator is utilized to perform element-wise operations. In many cases, the
dot operator becomes useful in MATLAB. Some of the useful instances where dot
operator can be useful are listed below:
Fig. 2.28 Output—Finding maximum and minimum value from an array
Fig. 2.29 Output—Mean, variance, standard deviation, and mode
2.11
Dot Operator
39

1. Dot multiplication or element-wise multiplication of two arrays having the
same size.
Usage: Dot operator “.” is used right before the multiplication sign (*).
2. Element-wise division among two arrays having the same size, or when the
numerator is a scalar value and the denominator is an array.
Usage: Dot operator “.” is used right before the division sign (/).
3. Determining power or exponential whenever either the base or the power is an
array.
Usage: Dot operator “.” is used right before the power sign (^).
4. For writing complicated and complex equations.
2.11.1
MATLAB Example 2.14: Instances of the Dot
Operator
The MATLAB code demonstrating the use of the dot operator is given in Fig. 2.30,
and its output is given in Fig. 2.31.
Output:
Fig. 2.30 Code—Dot operator
40
2
Vectors and Matrices

2.12
Table Arrays, Cell Arrays, and Structure Arrays
In MATLAB, a table can be created containing different data types by using the
built-in function table(). In a MATLAB-created table, all the variables can be
accessed and operated like separate arrays. The MATLAB command for table() is
given below:
The
MATLAB
command
for
creating
a
table:
table(variable1,
variable2, . . . .)
Here, variable1, variable2, . . .indicate the variables to be incorporated in
the table.
Fig. 2.31 Output—Dot operator
2.12
Table Arrays, Cell Arrays, and Structure Arrays
41

2.12.1
MATLAB Example 2.15: Creating Table
The MATLAB code to create a table is given in Fig. 2.32, and its output is given in
Fig. 2.33.
Output:
In the above-mentioned example, a table containing four different variables—
Battery_name, Energy_density, Life_cycle, and safety—is generated using the
MATLAB command. In the table, “Battery_name” and “safety” are cell arrays,
whereas the remaining variables have “double” data type values. Each of these
arrays can be accessed separately to perform operations individually, which have
been shown in the above examples as well.
2.12.1.1
Cell Array
In a cell array, there are different cells, each of which can contain data of different
data types. In MATLAB, the command for creating a cell array is given below:
Fig. 2.32 Code—Creating table in MATLAB
42
2
Vectors and Matrices

The MATLAB command for creating a cell array:
cell row, col
ð
Þ
Here, row, col are used to deﬁne the size of the cell array, as well as to
access each of the cells.
2.12.2
MATLAB Example 2.16: Cell Array
The MATLAB code demonstrating cell arrays is given in Fig. 2.34, and its output is
given in Fig. 2.35.
Output:
Fig. 2.33 Output—Creating table in MATLAB
2.12
Table Arrays, Cell Arrays, and Structure Arrays
43

In the above cell array, it can be observed that each cell can contain data of
different types. In the ﬁrst row, all the cells contain data of “double” data types,
whereas in the second row, all the cells have “character” data types.
2.12.2.1
Structure Array
In a structure array, different data can be grouped in several ﬁelds. In each ﬁeld, there
can be data of different types. In MATLAB, the command for creating a structured
array is as follows:
The MATLAB command for creating a structured array:
struct Field1, Val1Field1, Field2, Val2Field2, . . . . . . :
ð
Þ
Here, Field1, Field2, . . . . indicates the different ﬁelds under which differ-
ent data will be grouped. The grouped data of each ﬁeld is represented
by Val1Field1, Val2Field2, . . . .
2.12.3
MATLAB Example 2.17: Structured Array
The MATLAB code demonstrating structured arrays is given in Fig. 2.36, and its
output is given in Fig. 2.37.
Fig. 2.34 Code—Cell array in MATLAB
Fig. 2.35 Output—Cell
array in MATLAB
44
2
Vectors and Matrices

Output:
In this example, a structured array that contains parameters of different battery
types is created using the MATLAB command. Here, the ﬁelds of the structured
array are Battery_name, Energy_density, Life_cycle, and safety. Under each ﬁeld,
there are grouped data of different data types. The above example also shows how to
access each ﬁeld by using the dot operator.
2.13
Conclusion
From this chapter, the readers will be able to learn about different operations of
vectors and matrices that can be performed in MATLAB. The manipulations of
vectors and matrices along with some special arrays that can be created utilizing
MATLAB built-in functions, such as zeros, ones, and random numbers generator,
are covered in this chapter. The usage of the dot operator, matrix concatenation, and
some widely used array functions applicable for one-dimensional arrays is discussed
and demonstrated in MATLAB. At the end of the chapter, some special arrays such
as table array, cell array, and structured array are explained due to their importance in
the engineering domain. This chapter is prepared in such a way that the readers can
be introduced to most of the essential MATLAB commands and functions related to
vectors and matrices with relevant MATLAB examples.
Fig. 2.36 Code—Structured array in MATLAB
2.13
Conclusion
45

Exercise 2
1. Deﬁne vectors and matrices. What are their applications in engineering?
2. What is the difference between the rand(), randn(), and randi() functions? Explain
with examples.
3. What will be the output of the following commands?
(a) A ¼ 3:3:15
(b) B ¼ [;]
(c) Z ¼ [143,324,676,432;656,657,987,235;768,876,234,764]; Z(2,:)
Fig. 2.37 Output—Structured array in MATLAB
46
2
Vectors and Matrices

4. Consider three matrices given as follows:
MatA ¼
4
7
1
7
2
3
5
5
9
2
64
3
75; MatB ¼
6
0
4
9
8
1
7
5
2
2
64
3
75; MatC ¼
2
5
3
0
17
9
8
0
1
2
64
3
75
(i) Calculate the following:
(a) MatA + MatB
(b) MatB  MatC
(c) MatA/MatC
(d) Transpose of MatB
(e) Determinant of MatC
(f) Inverse MatA
(g) Horizontally concatenate MatB and MatC
(h) Vertically concatenate MatC and MatA
(ii) Determine MatA  MatB, MatB  MatA, and MatA.  MatB. Do the
results vary? If so, why?
5. Given an array a ¼ linspace(2,20,100). What is the mean, variance, standard
deviation, and mode of a?
6. Suppose you are working with ﬁve semiconductor materials, namely, silicon (Si),
germanium (Ge), tin (Sn), carbon (C), and tellurium (Te). Each of them has a
bandgap of 1.12, 0.67, 0.08, 5.47, and 0.33 eV, respectively, eV being their unit
of measurement.
(a) Enlist the information in a table with a column for “Serial_Number,”
“Element_Name,” “Element_Symbol,” and “Bandgap.” Use MATLAB
“table” function for the purpose.
(b) Form and display a structured array from the above information with the same
column name as mentioned in 5a. Change the bandgap of tin from 0.08 to
0.07 eV by accessing the speciﬁc ﬁeld and display the array again.
Exercise 2
47

Chapter 3
Programs and Functions
3.1
Introduction
To write a complete program using MATLAB, the creation, saving, running, and
publishing of a MATLAB script are the fundamental steps. Similar to other pro-
gramming languages, MATLAB can also be used to write conditional statements
and loops. In this chapter, some examples are shown implementing different condi-
tional statements and loops. In MATLAB, it is possible to create user-deﬁned
functions, which becomes important to avoid writing redundant code for performing
the same task multiple times within the program. The methods of creating such
functions and the implementations are discussed in this chapter with multiple
examples.
3.2
Scripts
For compiling a sequence of code, a script is required which allows one to write a
complete program and run it sequentially at the end. The script can be saved as a ﬁle
for a future run by calling the name of the script. In MATLAB, there are multiple
ways of creating a new script.
1. A new script can be created by clicking the “New Script” option from the header
toolstrip, as shown in Fig. 3.1.
2. Right-click on the “New” button, which will cause an appearance of a scrolling
menu. By selecting the “Script” option from that menu bar, a new script can be
created (Fig. 3.2).
3. In the command window using the “edit” command, a new script can be created
(Fig. 3.3).
4. Using a shortcut—“Ctrl + N”—on the keyboard, a new script can be generated.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_3
49

3.2.1
Live Script
A new version of Script called “Live Script” is available from MATLAB 2016
version. It allows accommodating both command and compiled output in the same
script. The ﬁle can be saved which can have both the programs and the output. The
“Live Script” feature facilitates the sharing of the program along with the output. To
open a “Live Script,” click on the “Live Script” button from the header toolstrip as
shown in Fig. 3.4.
Fig. 3.1 Header Toolstrip
Fig. 3.2 New Script
Fig. 3.3 edit command
Fig. 3.4 Live Script
50
3
Programs and Functions

A Live Script provides three format styles—output on right, output inline, and
hide code. A sample version of Live Script along with these three features is shown
in Figs. 3.5, 3.6, and 3.7.
3.2.2
Script vs. Live Script
Live script is an interactive platform, where both the code and the output stay in the
same environment. The output ﬁgures will be generated on the same live script page
Fig. 3.5 Output on right
Fig. 3.6 Output inline
Fig. 3.7 Hide Code
3.2
Scripts
51

instead of creating a separate ﬁgure ﬁle. In the script ﬁle, the outputs can be seen in
the command window. The ﬁgures are produced in a separate ﬁgure window. The
advantage of a live script is that it can be shared with the produced outputs.
However, for a script ﬁle, the output cannot be shared. The user needs to run a script
ﬁle to observe the outputs. Live script is very useful for making lectures or books, as
it provides both text and code insert options. A script ﬁle is more appropriate and
professional to implement in projects or real-time applications.
3.3
Saving, Running, and Publishing a Script
The processes of saving, running, and publishing a script in MATLAB are described
in this section.
3.3.1
Saving a Script
After writing a complete program in a script, it is essential to save it for future use.
To save a script ﬁle, there are multiple ways, such as the following:
1. Click on the “Save” option on the Editor tab from the header toolstrip as shown in
Fig. 3.8. Later, navigate to the location and write the appropriate name for the
script ﬁle to save it. The script ﬁle will be saved with an extension of “.m,” which
can be run in MATLAB in the future. If multiple scripts are open, the “Save”
option will save only the active script ﬁle. However, MATLAB also provides
options to save all the script ﬁles opened in the Editor. By opening the scrolling
menu bar from the “Save” button, and selecting the “Save All” option will do that
trick, as shown in Fig. 3.9.
2. Using the keyboard shortcut “Ctrl + S,” a script ﬁle can also be saved.
Fig. 3.8 Saving a Script
52
3
Programs and Functions

3.3.2
Running a Script
1. A script can be run by clicking the “Run” button Editor tab from the header
toolstrip as shown in Fig. 3.10. If a script ﬁle is not saved before clicking the
“Run” button, MATLAB will prompt the save option ﬁrst by default. Therefore,
it is to be noted that the “Run” option works only for the saved script ﬁle.
2. Using the keyboard shortcut “F5,” a script ﬁle can also be run.
MATLAB provides another feature for running a script ﬁle without saving upfront.
By clicking the “Run and Advance” option (Fig. 3.11), a script ﬁle can be compiled
without prior saving.
Another useful feature of MATLAB is to create different sections in a script ﬁle
and run individual sections. For debugging, this option provides great ﬂexibility. To
create a new section in a script ﬁle, there are two ways:
1. Selecting a place on the script where a new section needs to be created and
clicking on the “Insert” button on the Editor tab (Fig. 3.12)
2. By typing “%%”—right from where a new section needs to be created (Fig. 3.13)
Fig. 3.10 Running a Script
Fig. 3.11 Running a Script without Saving
Fig. 3.9 Saving Multiple Scripts
3.3
Saving, Running, and Publishing a Script
53

After creating multiple sections, it may be required to run separate sections. For
running individual sections in a script ﬁle, “Run Section” on the Editor tab can be
utilized after selecting a speciﬁc section as shown in Fig. 3.14.
Fig. 3.12 Creating Different Sections in a Script File using Insert
Fig. 3.13 Starting New Section in a Script File using %%
Fig. 3.14 Running a Speciﬁc Section from a Script
54
3
Programs and Functions

3.3.3
Publishing a Script
After conﬁrming a programming script, it can be published in “html,” in “pdf,” or in
other formats. The purpose of publishing a script is to make the script shareable with
others. As the script ﬁle can be sharable in “html,” “pdf,” or other formats, the person
with whom the script ﬁle will be shared does not require to open the MATLAB
application. In the published format, the output will also be included in the docu-
ment. The steps of publishing a script are listed below and illustrated in Fig. 3.15.
1. After writing a program in a script ﬁle, select the “PUBLISH” option from the
header menu bar.
2. After that, choose the “Publish” dropdown option from the header toolstrip.
3. Choose the “Edit Publishing Options” from the dropdown box options.
4. Step 3 will create the appearance of the following window in Fig. 3.16, from
where you can choose the desired output ﬁle format.
Fig. 3.15 Publishing a Script
Fig. 3.16 Selecting the Output File Format
3.3
Saving, Running, and Publishing a Script
55

5. Click on the “Publish” button. In this example, “html” format is selected for the
publishing option, which creates the following publishing page (Fig. 3.17).
3.4
Conditional Statements and Loops
In conditional statements, logical and relational operators play important roles to
formulate them. Hence, it is necessary to understand the logical and relational
operators available in MATLAB. In Table 3.1, some of the important logical and
relational operators along with the meanings and examples are listed.
Conditional statements are essential to execute a particular block of code based on
conditions associated with it. The most basic and widely used conditional statements
in MATLAB are “if” and “switch.”
Fig. 3.17 Maximum and minimum values from an array
56
3
Programs and Functions

3.4.1
“If” Statement
The structure of an if statement can be represented in three formats as follows:
if (logical conditions)
Executable
command. . .
end
if (logical conditions)
Executable
command. . .
else
Executable
command. . .
end
if (logical conditions)
Executable
command. . .
elseif
Executable
command. . .
else
Executable
command. . .
end
The ﬁrst structure is the simplest version of the “if” statement, and the second and
the third one provide more extensions. In the above structure, “logical statements”
indicate the conditions, which need to be TRUE for the execution of the “Executable
Table 3.1 Logical and relational operators
Logical and
relational
operator
Deﬁnition
Example
¼¼
Equal
a ¼ ¼ b will be true only if both a and b are
completely identical
1 ¼ ¼ 1 : True
2 ¼ ¼ 1 : : False
~¼
Not equal
a~ ¼ b will be true only if a and b are unequal
2~ ¼ 1 : True
2~ ¼ 2 : False
&
Logical “and”
Condition 1 and Condition 2 will be true only if
both Condition 1 and Condition 2 are true
2 > 1 & 5 < 10 : True
2 > 1 & 5 > 10 : False
j
Logical “or”
Condition 1/Condition 2 will be true if either Con-
dition 1 or Condition 2 is true
2 > 1 j 5 < 10 : True
2 > 1 j 5 > 10 : True
1 > 2 j 5 > 10 : False
>
Greater than
a > b will be true, only if a is greater than b
2 > 1 : True
2 > 2 : False
1 > 2 : False
<
Less than
a < b will be true, only if a is less than b
1 < 2 : True
1 < 1 : False
2 < 1 : False
>¼
Greater than or equal to
a >¼ b will be true, if a is greater than b, or a is
equal to b
5 > ¼ 2 : True
2 > ¼ 2 : True
5 > ¼ 8 : False
<¼
Less than or equal to
a <¼ b will be true, if a is less than b, or a is equal to
b
2 < ¼ 5 : True
2 < ¼ 2 : True
8 < ¼ 5 : False
3.4
Conditional Statements and Loops
57

command.” If the conditions become FALSE, the compiler will skip the “Executable
command.” An example based on the ﬁrst structure of the “if” statement is given
below:
3.4.2
MATLAB Example 3.1: “If” Statement
The following MATLAB code in Fig. 3.18 shows the use of an if statement and
Fig. 3.19 shows its output.
Output:
Here, randi is a MATLAB function that generates random integer values. The
input parameters of the function “20” represent the maximum range of the integer,
while 1 signiﬁes the size of the output vector. Therefore, each time, randi is run in
the above program, a pseudo-integer value of x is randomly generated, within the
range of 20.
In the if statement within the ﬁrst bracket, the condition is mentioned as x > 10. If
this condition is satisﬁed, the successive command—disp(‘x is greater than 10’)—
will be executed; otherwise, this command will be skipped. Two outputs generated
from two consecutive runs are shown above. In the ﬁrst output, the initial value of
x is 1, which does not satisfy the logical condition. Therefore, the logical condition
of the if statement in the ﬁrst run is FALSE, and the next disp command is ignored. In
the second output, the value of x is 19, which satisﬁes the logical condition. Hence,
the next disp command is executed. The end command ﬁnally truncates the if
statement.
Fig. 3.18 Code—if statement
Fig. 3.19 Output—if statement
58
3
Programs and Functions

If multiple conditions are available, else and elseif commands become useful. An
example is shown below where both these commands are used. The following
MATLAB code in Fig. 3.20 shows the use of an if-else statement and Fig. 3.21
shows its output.
Output for four different runs:
While multiple conditions are needed to be considered for executing different
tasks, elseif and else become more useful. If the ﬁrst logical condition becomes
FALSE, the execution of the ﬁrst command will be skipped, and sequentially the
second logical condition within the elseif statement will be checked as before. Thus,
using multiple elseif statements, multiple conditions can be set forth for different
outputs. The else statement becomes useful when the program needs to execute a
ﬁnal command in case multiple conditions fail to satisfy. In the above-mentioned
Fig. 3.20 Code—elseif and else statement
Fig. 3.21 Output—elseif and else statement
3.4
Conditional Statements and Loops
59

code, the outputs have four outcomes—Grade: A, B, C, and F—depending on four
conditions, which have been addressed by the one if statement, two elseif statements,
and one else statement. The outcomes for four different grades have been shown in
the output by executing multiple runs for better comprehensibility of the code.
3.4.3
Switch Statement
switch statement is another conditional statement through which multiple cases can
be set up for executing different blocks of codes. It acts almost similar to the if
statement; however, the switch statement provides more simplicity in terms of
comprehension. However, the switch statement cannot be used for inequality; it
only works for discrete equality cases. The structure of the switch statement is given
below for facilitating the understanding:
switch Switch Expression
case Case Expression
Executable Statement
case Case Expression
Executable Statement
. . . .. . . .. . .
otherwise
Executable Statement
end
To execute a certain command, the Switch Expression needs to be matched with
Case Expression. Whenever a speciﬁc Case Expression matches with a Switch
Expression, the corresponding case statement will be executed, and MATLAB will
exit the switch block right away.
3.4.4
MATLAB Example 3.2: Switch Statement
The following MATLAB code in Fig. 3.22 shows the use of a switch statement and
Fig. 3.23 shows its output.
Output:
60
3
Programs and Functions

3.4.5
For Loop
for loop is a repetitive structure, where a certain task will be repeated in a systematic
manner. This loop performs a set of tasks deﬁned by the statements for a number of
times, which is to be provided in the ﬁrst line. for loop is usually used where there is
Fig. 3.22 Code—switch statement
Fig. 3.23 Output—switch
statement
3.4
Conditional Statements and Loops
61

a range of time for which the operation is needed to be run. Within a for loop, other
conditional statements, such as if statement or nested if statement, can be embedded
as required. The structure of the for loop is shown as follows:
for index ¼ values
statements
end
An example will help to understand the syntax shown above.
3.4.6
MATLAB Example 3.3: “For” Loop
The following MATLAB code in Fig. 3.24 shows the use of a for loop and Fig. 3.25
shows its output.
Output:
In the example, an array a is provided, which has to be printed. After the
for keyword, a range is provided to a variable i. The variable is an array from 1 to
the length of a, which is 5. The statements inside the for loop is written after the
indentation. The end keyword after the indented statements indicates the end of the
loop. Upon running the program, the result shows that while the value of i is 1, the
following two statements are executed, where the number of iteration (the value of i)
and the value for that iteration (the value in array a) are shown. The operation is
repeated until the last value of i is met.
Multiple for loops can also be nested like if statements. There are two other
statements associated with the loop. A break statement within the for loop helps to
exit the loop without running further. A continue statement, on the other hand, helps
a program to skip the statements after the continue statement, and to start from the
next iteration again.
Fig. 3.24 Code—for loop
62
3
Programs and Functions

3.5
User-Deﬁned Functions
Apart from the built-in functions, MATLAB also provides scope for creating user-
deﬁned functions, where the user can create a function to carry out a certain task. The
user-deﬁned function consists of three parts—input parameters, output variables,
and executable commands—for accomplishing a task. A user-deﬁned function may
have multiple inputs and outputs, or even no inputs and outputs at all. This function
can be saved as a script ﬁle (MATLAB M-ﬁle) and can be used in a separate script
ﬁle by calling out the function’s name. It is to be noted that both script ﬁles (Function
ﬁle, Main Script ﬁle) need to be in the same path of the directory. MATLAB allows
to have another type of user-deﬁned function named Anonymous function, which
does not require to be saved as a separate script ﬁle. Instead, the function can be
created on the same main script ﬁle and can be usable in the rest of the code in the
same script.
3.6
Creating User-Deﬁned Functions
The structures of creating different user-deﬁned functions based on the number of
input and output parameters are given below:
Fig. 3.25 Output—for loop
3.6
Creating User-Deﬁned Functions
63

Function with single input and
single output:
function out = functionName
(input1)
Executable commands for a task
End
Function with multiple inputs and single
output:
function out = functionName(input1, input2,
. . .)
Executable commands for a task
end
Function with no input and single
output:
function out = functionName ()
Executable commands for a task
end
Function with multiple inputs and multiple
outputs:
function [out1, out2, . . .] = functionName
(input1, input2, ...)
Executable commands for a task
end
Here, input1, input2, . . . represent the input variables of the function, whereas
out1, out2, . . . signify the output parameters. After writing a function in a script ﬁle,
the ﬁle needs to be saved as an M-ﬁle in the same path directory of the main script
ﬁle where the function will be used. By calling the “functionName” along with
relevant inputs, the user-deﬁned function will return the outputs. A simple example
of such a function is given below:
3.6.1
MATLAB Example 3.4: User-Deﬁned Function
The following MATLAB code in Fig. 3.26 shows how to create a user-deﬁned
function and Fig. 3.27 shows its output.
Output:
The structure of the other format of user-deﬁned function—Anonymous func-
tion—is given below:
functionName= @ (input1, input2, . . . ..)
Expression
Here, input1, input2, . . . indicate the input variables as before and the
“functionName” represents the name of the function. “Expression” refers to any
Fig. 3.26 Code—User deﬁned function
64
3
Programs and Functions

mathematical expression with the association of the corresponding input variables.
This type of function can be used inline in the main script ﬁle. A simple example of
this type of function is given below:
3.6.2
MATLAB Example 3.5: User-Deﬁned Function–
Anonymous Function
The MATLAB code for a user-deﬁned anonymous function is provided in Fig. 3.28.
Here, 2  x + 3 is the expression with a variable x. The name of the function is
“myfunc.” By calling “myfunc” with a given value of x ¼ 2, the function calculates
the output from the expression, which becomes: 2*2+3¼7.
3.6.3
Examples of User-Deﬁned Function
Four examples of user-deﬁned functions for addition, subtraction, multiplication,
and division of two numbers are provided below. Likewise, the functions could be
modiﬁed for more than two inputs.
Fig. 3.28 User deﬁned function—Anonymous function
Fig. 3.27 Output—User
deﬁned function
3.6
Creating User-Deﬁned Functions
65

3.6.3.1
User-Deﬁned Function for Summation
A user-deﬁned function that can perform the summation of two numbers is created in
Fig. 3.29.
The above-mentioned function needs to be saved as an M-ﬁle named “Summa-
tion.m.” In the command window, by recalling the function name with two given
input numbers, the function will automatically return the summation as an output.
The usage of the “Summation” function in the command window is shown in
Fig. 3.30.
It is to be noted that the current directory and the directory of the saved ﬁle of the
function need to be the same to work correctly.
3.6.3.2
User-Deﬁned Function for Subtraction
A user-deﬁned function that can perform a subtraction of any two numbers is formed
below with the implementation in the command window as well. The MATLAB
code is provided in Fig. 3.31 with its output in Fig. 3.32.
Fig. 3.29 Code—Summation function
Fig. 3.30 Output—
Summation function
Fig. 3.31 Code—Subtraction function
66
3
Programs and Functions

Output:
3.6.3.3
User-Deﬁned Function for Multiplication
The multiplication task performed between any two numbers is written in the forms
of a user-deﬁned function in the following example code in Fig. 3.33 with its output
in Fig. 3.34.
Output:
Fig. 3.32 Output—
Subtraction function
Fig. 3.33 Code—Multiplication function
Fig. 3.34 Output—
Multiplication function
3.6
Creating User-Deﬁned Functions
67

3.6.3.4
User-Deﬁned Function for Division
Finally, a division example is shown using a user-deﬁned function in the following
example. The MATLAB code is provided in Fig. 3.35 with its output in Fig. 3.36.
Output:
3.7
Solve Quadratic Equations Using Functions
The general format of a quadratic equation can be represented as in Eq. (3.1).
ax2 þ bx þ c ¼ 0
ð3:1Þ
Here, x is the variable; and a, b, c are real coefﬁcients. In this equation, the highest
degree is 2. Hence, the solution to such an equation will have two roots.
The formula used to calculate the roots is shown in Eq. (3.2).
x1, x2 ¼ b 
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
b2  4ac
p
2a
ð3:2Þ
A user-deﬁned function can be created to solve such quadratic equations for
ﬁnding the roots in MATLAB. An example of such a user-deﬁned function is given
below:
Fig. 3.35 Code—Division function
Fig. 3.36 Output—
Division function
68
3
Programs and Functions

3.7.1
MATLAB Example 3.6: User-Deﬁned Function
for Solving Quadratic Equation
Find the roots of the following quadratic equation using MATLAB:
Quadratic equation : 2x2 þ 3x þ 5 ¼ 0
The MATLAB code is provided in Fig. 3.37 with its output in Fig. 3.38.
3.8
Conclusion
As MATLAB is a high-level programming language, it is imperative for the readers
to learn about the conditional statements and loops that can be implemented in
MATLAB. For the convenience of the readers, multiple examples are provided that
are implemented in MATLAB. While writing large programs, user-deﬁned functions
play important roles in many aspects. In MATLAB, two types of user-deﬁned
functions are mostly used, which are demonstrated in this chapter with adequate
examples. This chapter will help the readers to build up the knowledge to initiate
writing programs and details about creating and using a user-deﬁned function in a
MATLAB program.
Fig. 3.37 Code—Quadratic equation function
Fig. 3.38 Output—Quadratic equation function
3.8
Conclusion
69

Exercise 3
1. What is the difference between a script and a live script in MATLAB?
2. Enlist the logical operators in MATLAB with examples.
3. Create a MATLAB program which will take a numerical user input. If the user
input is within the 0–100 range, the program would display “Inside range”;
otherwise, the program would display “Outside range.” Moreover, if the input
is greater than 25 and less than or equal to 50, the program would additionally
display “First half,” and if the number is more than 50 but less than or equal to
75, the program would additionally display “Second half.”
4. Hexadecimal codes of colors are vastly used in computer science. The hexadec-
imal codes of certain colors are given in Table 3.2.
Write a MATLAB code using switch-case so that the users can provide the given
hexadecimal code as input to know the corresponding color. If the hexadecimal
color is wrong or is not available in the table, the code should output an error
message: “The color code you entered is wrong/not available.”
5. For two Cartesian coordinates (x1, y1) and (x2, y2),the formula to determine the
distance is d ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
x1  x2
ð
Þ2 þ y1  y2
ð
Þ2
n
o
r
. Write a user-deﬁned function “dis-
tance” to take two coordinates as input and return the distance as the output.
Check the function for:
(a) (2,1) and (2, 2)
(b) (3, 5) and (1,6)
6. Create a user-deﬁned function “usercal,” which will take two numbers as input
from the user, and another number to determine the mathematical operation to
perform. If the third number is 1, 2, or 3, addition, subtraction, or multiplication
will be performed. If any other third number is entered, an error message “Wrong
operation entered” will be demonstrated.
Table 3.2 Hexadecimal
codes of various colors
Color
Hexadecimal code
Red
#FF0000
Green
#00FF00
Blue
#0000FF
Orange
#FFA500
Yellow
#FFFF00
Black
#000000
White
#FFFFFF
70
3
Programs and Functions

Chapter 4
Complex Numbers
4.1
Introduction
Complex numbers have penetrated deep into the world of electrical engineering. It is
impossible to imagine terms such as impedance, inductance, capacitance, reactive
power, etc. without referencing complex quantities. As such, an electrical engineer
must be ﬂuent with the use and execution of complex quantities for solving engi-
neering problems. In this chapter, the main concentration will be on complex
numbers and their different representations in rectangular and polar forms. Later,
the chapter also introduces different mathematical series, where complex numbers
play signiﬁcant roles. Another important concept named equilibrium point is cov-
ered in this chapter. At the end, some examples related to the ﬁeld of engineering are
demonstrated, where the previous concepts will be utilized.
4.2
Origin of Complex Numbers
The origin of complex numbers came from the concept of dealing with the solution
of the square root of any negative numbers. While solving polynomial equations, the
square root term of the negative number appears. During the sixteenth century, the
square root of any negative number was a mystery for mathematicians. Therefore,
solving such problems requires a unique solution. In 1530, Niccolò Tartaglia ﬁrst
used a formula in a competition to solve cubic equations, where he found a way to
deal with the root of a negative number. The opponent of that competition was a
mathematician named Girolamo Cardano. Cardano published the method applied by
Tartaglia after some time of that competition in 1545, where he improvised the
method to create a generalized formula to deal with the mysterious number—the root
of a negative number, for solving all quadratic and cubic equations. This is consid-
ered as the discovery of the complex number for which he is regarded as its creator.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_4
71

Later, Rafael Bombelli derived general rules for arithmetic operations for the root
of a negative number. The imaginary unit, i, was ﬁrst introduced later by Mathema-
tician Leonhard Euler in 1777 for the roots of the equation: x2 + 1 ¼ 0. The usage of
complex numbers became popular after mathematicians were able to interpret it both
geometrically and arithmetically.
The general form of any complex number is:
a þ ib ,
ð4:1Þ
where i refers to the imaginary unit, which is represented as i ¼
ﬃﬃﬃﬃﬃﬃﬃ
1
p
. One of the
interesting characteristics of i is that the square of that number is a negative value,
i.e., i2 ¼  1, although the square of any number is considered as positive. The
introduction of the complex number plays a signiﬁcant role in mathematics, such as
solving any polynomial equation.
4.3
Rectangular Form
The rectangular form of a complex number can be referred to as follows:
C ¼ a þ i  b
ð4:2Þ
Here, i is the imaginary number; a and b are coefﬁcients; C represents the
complex number.
In this complex number, there are two parts—real and imaginary parts. In the
above equation, a represents the real part, whereas b indicates the imaginary part of
the complex value. In a rectangular coordinate system, the position of a complex
number has been shown in Fig. 4.1 to understand the parameters.
Fig. 4.1 Rectangular co-
ordinate system
72
4
Complex Numbers

If the real and imaginary values are known, the complex number can be generated
using the above-mentioned formula. In MATLAB, there is also an in-built function
complex(real, imaginary)—which can be utilized to generate the complex number.
In this complex function, there are two input parameters—real and imaginary values.
An example is given below, where the complex number is generated using
MATLAB in both ways:
4.3.1
MATLAB Example 4.1: Rectangular Form
The following code in Fig. 4.2 depicts the process of displaying complex numbers in
the rectangular form.
4.4
Polar Form
The general format of the polar form of any complex number is:
j C j ∠θ
ð4:3Þ
Here, jCj is the absolute value or magnitude of the complex number, C ¼ a + i  b;
and θ represents the angle.
The absolute value or the magnitude of a complex number is given by j C j¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
a2 þ b2
p
and the angle is given by θ ¼ b
a rad ¼
b
a
 
 180

π
degree . In a polar
Fig. 4.2 Code and output—Rectangular co-ordinate system
4.4
Polar Form
73

coordinate system, the position of a complex number has been shown in Fig. 4.3 to
understand the parameters.
To convert a complex number from its rectangular form to polar form, we can
utilize the above formula. MATLAB also provides some in-built functions to
calculate both magnitude and angle directly by using abs() and angle(), respectively.
Another way is to utilize the direct conversion of Cartesian to polar form by using
cart2pol(). An example showing all these ways is given below:
4.4.1
MATLAB Example 4.2: Polar Form
The following code in Fig. 4.4 shows how to get the polar form of any complex
number from the rectangular form.
Fig. 4.3 Polar co-ordinate
system
Fig. 4.4 Code and output—Polar co-ordinate system
74
4
Complex Numbers

4.5
Euler’s Series
Euler’s formula provides a relationship between trigonometric and exponential
terms. It can be deduced from the exponential series by inserting the imaginary
unit in there. Mathematician Euler ﬁrst came up with this idea, and set forth the
following formula, which is known as Euler’s formula:
eix ¼ cos cos x þ i sin sin x ,
ð4:4Þ
where e is the base of the natural logarithm, x is any real number, and i is the
imaginary unit.
In the Cartesian coordinate system, any complex number C can be written as
C ¼ a + ib, while in the polar form, it can be written as |C| ∠θ, where C
j j ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
a2 þ b2
p
and θ ¼ b
a rad . As discussed earlier, it is also possible to convert a
complex number from its polar form to Cartesian form by using the following
relationships:
a ¼ C
j j cos cos θ
ð4:5Þ
b ¼ C
j j sin sin θ
ð4:6Þ
Therefore, the complex number in a Cartesian format becomes:
C ¼ C
j j cos cos θ þ i sin sin θ
ð
Þ
ð4:7Þ
Euler’s formula shows its beauty while it is implemented in the above-mentioned
equation, and suddenly the complex number can be represented in an exponential
format as below:
C ¼ C
j j cos cos θ þ i sin sin θ
ð
Þ ¼ C
j jeiθ
ð4:8Þ
If the magnitude and the angle are known for a complex number in its polar
coordinate system, it can be converted back into the exponential form using Euler’s
formula, which makes the multiplication and division of complex numbers easier to
follow.
Example Consider two complex number, C1 ¼ 10 ∠45 rad and C2 ¼ 20 ∠30 rad.
Determine:
i. C1. C2
ii. C1/C2
4.5
Euler’s Series
75

Solution Using Euler’s formula to convert the polar form into the exponential form:
C1 ¼ 10∠45 ¼ 10ei45
ð4:9Þ
C2 ¼ 20∠30 ¼ 20ei30
ð4:10Þ
i. C1. C2 ¼ 10ei45  20ei30 ¼ 10  20 ei(45 + 30) ¼ 200ei75 ¼ 200 ∠75
ii. C1
C2 ¼ 10ei45
20ei30 ¼ 0:5ei 4530
ð
Þ ¼ 0:5ei15 ¼ 0:5∠15
4.5.1
MATLAB Example 4.3: Euler’s Formula
Two complex numbers are C1 ¼ 2 + 5i and C2 ¼ 5 + 10i. Determine:
(a) C1 and C2 in exponential form
(b) C1*C2 and C1/C2 in exponential form
The MATLAB code is provided in Fig. 4.5 with its output in Fig. 4.6.
Fig. 4.5 Code—Euler’s formula
76
4
Complex Numbers

Output
Application of Euler’s Series for Solving Initial Value Problem
Euler’s method can be used to produce a numerical solution for the initial value
problem. The general format of such a problem is as follows:
dy
dx ¼ y0 ¼ f x, y
ð
Þ, where y x0
ð
Þ ¼ y0
ð4:11Þ
The variable x may have a certain range, which can be deﬁned as lower and upper
limit values. The procedure for generating solutions to such problem using Euler’s
series can be arranged as follows:
1. Deciding number of steps (N) for iteration over the range of values x, based on
which a step size (h) will be determined.
2. For each iteration, the values of y and x will be updated as follows:
ynþ1 ¼ yn þ h  f xn, yn
ð
Þ;
ð4:12Þ
xnþ1 ¼ x0 þ n  h; where n ¼ 0, 1, 2, . . . . . . :N
ð4:13Þ
4.5.2
MATLAB Example 4.4: Euler’s Series for Solving
Initial Value Problem
Problem
dy
dx ¼ y0 ¼ f x, y
ð
Þ ¼ 2x2 þ y  2; 0  x  5; y 0
ð Þ ¼ 0:1
ð4:14Þ
The MATLAB code is provided in Figs. 4.7 and 4.8 with its output in Figs. 4.9
and 4.10.
Fig. 4.6 Output—Euler’s formula
4.5
Euler’s Series
77

Fig. 4.7 Code—Creating the function for Euler’s series for solving initial value problem
Fig. 4.8 Code—Using the function for Euler’s series for solving initial value problem

Output
4.6
Fourier Series
Fourier series is a series through which any periodic function can be represented as a
summation of sine and cosine functions. It provides an opportunity to represent any
periodic function to a trigonometric representation.
Fig. 4.9 Output—Euler
series for solving initial
value problem
Fig. 4.10 Graphical output—Euler series for solving initial value problem
4.6
Fourier Series
79

Consider a periodic function f(t),with a period T. The Fourier series of this
function is:
f tð Þ ¼ a0
2 þ
X1
k¼1ak cos kωt
ð
Þ þ
X1
k¼1bk sin
kωt
ð
Þ; k ¼ 0, 1, 2, . . . . . . : ð4:15Þ
where:
a0 ¼ 2
T
Z T=2
T=2
f tð Þ dt
ð4:16Þ
ak ¼ 2
T
Z T=2
T=2
f tð Þ  cos
kωt
ð
Þ dt
ð4:17Þ
bk ¼ 2
T
Z T=2
T=2
f tð Þ  sin
kωt
ð
Þ dt
ð4:18Þ
4.6.1
MATLAB Example 4.5: Fourier Series
The Fourier series of a square function with ω ¼ π and T ¼ 2 for k ¼ 5 terms can be
determined using the MATLAB code provided in Fig. 4.11 with its output in
Fig. 4.12.
Fig. 4.11 Code—Fourier series
80
4
Complex Numbers

Output
Discrete Fourier Transform
Discrete Fourier Transform (DFT) is almost similar to continuous Fourier transform,
except that in DFT, a ﬁnite sequence of the input is considered as an input. In this
method, any continuous signal is sampled for a ﬁnite length to make the input a ﬁnite
discrete sequence.
Consider a sequence x[k], for which the DFT can be determined using Eq. (4.19):
X n½  ¼
XN1
k¼0 e
j2πnk
N :x k½ , where n ¼ 0, 1, 2, . . . , n  1
ð4:19Þ
Here, the length of the sequence is N.
It is also essential to study inverse DFT, which can be accomplished by using the
formula as shown in Eq. (4.20):
x k½  ¼
XN1
n¼0 e
þj2πnk
N :X n½ , where k ¼ 0, 1, 2, . . . , n  1
ð4:20Þ
Here, the output of DFT is considered as input of the inverse DFT function, and
we can reproduce the original sequence, x[k], by implementing inverse DFT.
Fig. 4.12 Graphical output—Fourier series
4.6
Fourier Series
81

•
In MATLAB, the DFT of an input vector can be determined by using a
built-in function: fft().
•
Inverse DFT can be achieved by using a built-in function: ifft().
4.6.2
MATLAB Example 4.6: DFT and Inverse DFT
Consider an input sequence, x ¼ [1 4 5 7]. Determine:
(i) Fourier transform of the input vector
(ii) Inverse Fourier transform of the output of (i)
The MATLAB code is provided in Fig. 4.13 with its output in Fig. 4.14.
Output
4.7
Taylor Series
Taylor series was ﬁrst discovered by Mathematician Brook Taylor, who came up
with a general formula to represent any function as the summation of inﬁnite terms
that incorporates the derivatives of the function at a single point. The sum of this
inﬁnite series provides a ﬁnite value, which is equal to the original value of the
function near that single point. This series is called the Taylor series.
Fig. 4.13 Code—Discrete and inverse discrete Fourier transform
82
4
Complex Numbers

The Taylor series of a real function f(x) about a point x ¼ a can be represented as
follows:
f x
ð Þ ¼ f a
ð Þ þ x  a
ð
Þ f 0 a
ð Þ
1!
þ x  a
ð
Þ2 f 00 a
ð Þ
2!
þ x  a
ð
Þ3 f 000 a
ð Þ
3!
þ . . .
ð4:21Þ
In general format, this series can be represented as follows:
f x
ð Þ ¼
X1
n¼0 x  a
ð
Þn f n a
ð Þ
n!
ð4:22Þ
Here, f n represents the nth derivative of the function f(x).
When the Taylor series is determined at a point x ¼ 0, i.e., a ¼ 0, it becomes the
Maclaurin series. The general format of the Maclaurin series is shown in Eq. (4.23):
f x
ð Þ ¼
X1
n¼0 x
ð Þn f n 0
ð Þ
n!
ð4:23Þ
The higher order we can go of a Taylor series, the more accurate the result will be
for a particular function at a certain point. MATLAB provides a built-in function for
determining the Taylor series of a certain function at a speciﬁc point, which is
taylor(f, var).
Fig. 4.14 Output—Discrete and inverse discrete Fourier transform
4.7
Taylor Series
83

MATLAB function for Taylor series for a function f at a point var ¼ 0 up
to ﬁfth order (default) is taylor( f, var).
MATLAB function for Taylor series for a function f at a point var ¼ a up
to ﬁfth order (default) is taylor( f, var , a).
MATLAB function for Taylor series for a function f at a point var ¼ a up
to n order (default) is taylor( f, var , a, 0order0, n).
4.7.1
MATLAB Example 4.7: Taylor Series
The MATLAB code to expand the Taylor series is provided in Fig. 4.15 with its
output in Figs. 4.16 and 4.17.
Output
When a ¼ 0, the Taylor series becomes Maclaurin series and can be determined
using the same taylor() function as shown above.
Fig. 4.15 Code—Taylor series
84
4
Complex Numbers

4.8
Equilibrium Point
Mathematically, the equilibrium point can be deﬁned as the constant solution of a
differential equation. It represents the steady-state points of a dynamic system.
Consider a differential equation as follows:
dy
dt ¼ f t, y
ð
Þ
ð4:24Þ
For such a differential equation, the equilibrium points will be the solutions of the
following equation:
Fig. 4.16 Output—Taylor series
Fig. 4.17 Graphical output—Taylor series
4.8
Equilibrium Point
85

dy
dt ¼ f t, y
ð
Þ ¼ 0
ð4:25Þ
Here, the values of y will be the equilibrium points, for satisfying the above
condition. It can be useful to determine the stability of a system. In linearization, the
equilibrium point also plays an important role.
4.8.1
MATLAB Example 4.8: Equilibrium Points
Consider the following two differential equations:
dy
dt ¼ 4x2  xy
ð4:26Þ
dy
dx ¼ 2y  x2
ð4:27Þ
Determine the equilibrium points using MATLAB.
The MATLAB code is provided in Fig. 4.18 with its output in Fig. 4.19.
Output
Fig. 4.18 Code—Equilibrium points of a differential equation
86
4
Complex Numbers

4.9
Energy Calculation
In an electrical system, the power can be represented using Eq. (4.28):
S ¼ P þ jQ,
ð4:28Þ
where, S, P, and Q are apparent, real, and reactive power, respectively, and j is the
imaginary unit. Therefore, the electrical power can be considered as a complex
number, which is multiplied with scalar value time to calculate the electrical energy
of a system. Hence, the electrical energy can be calculated using Eq. (4.29):
E ¼j S j t ¼j P þ jQ
ð
Þ j t,
ð4:29Þ
where E is the electrical energy and t represents the time of energy usage. The units
of S, P, and Q are VA, W, and VAR.
4.9.1
MATLAB Example 4.9: Energy Calculation
An electrical system consumes 10 W real power and 20 VAR reactive power for
24 h. Using MATLAB, determine:
(i) Apparent power in rectangular form
(ii) Apparent power in polar form
(iii) Electrical energy
The MATLAB code is provided in Fig. 4.20 with its output in Fig. 4.21.
Output
Fig. 4.19 Output—
Equilibrium points of a
differential equation
4.9
Energy Calculation
87

Fig. 4.20 Code—Power and energy calculation
Fig. 4.21 Output—Power and energy calculation
88
4
Complex Numbers

4.10
Impedance Calculation
Impedance is a parameter in an electrical network that is used to depict the overall
opposition of the ﬂow of current. Impedance consists of two parts—resistance and
reactance. Impedance is also a complex number that can be represented as in
Eq. (4.30):
Z ¼ R þ jX
ð4:30Þ
Here, Z is the impedance, R is the resistance, and X represents the reactance of an
electrical circuit.
Another deﬁnition of impedance is that it is the ratio of the voltage to the current
of a circuit. Therefore, impedance can also be represented by Eq. (4.31):
Z ¼ V
I
ð4:31Þ
Here, V and I represent the voltage and the current of a circuit, respectively.
4.10.1
MATLAB Example 4.10: Impedance Calculation
In a series ac electrical circuit, consider a voltage source of 100 ∠60
 V. There is an
impedance connected in series with the voltage source. The current ﬂowing through
the circuit is 3 ∠30
 A. Determine the impedance in both rectangular and polar
forms.
The MATLAB code is provided in Fig. 4.22 with its output in Fig. 4.23.
Output
Consider a series AC circuit with a voltage source of 100 ∠90
 V. In series, there
is a resistor of 5 ohms, a capacitor of 2 μF, and an inductor of 15 mH. Determine the
impedance of the circuit in both rectangular and polar forms.
The MATLAB code is provided in Fig. 4.24 with its output in Fig. 4.25.
Output
4.10
Impedance Calculation
89

Fig. 4.22 Code—Impedance Calculation 1
Fig. 4.23 Output—Impedance Calculation 1
90
4
Complex Numbers

Fig. 4.24 Code—Impedance Calculation 2
Fig. 4.25 Output—Impedance Calculation 2
4.10
Impedance Calculation
91

4.11
Conclusion
From this chapter, the readers will be able to learn about complex numbers and their
importance in the engineering domain. In MATLAB, how to deﬁne a complex
number and their different forms of representations are shown in this chapter. In
addition, some of the important series, such as Euler’s series, Taylor’s series, Fourier
series, inverse Fourier series, that are widely used in the engineering domain are
explained and implemented in MATLAB to solve different mathematical problems.
The chapter concludes with a demonstration of how to use this concept in real
engineering applications such as energy calculation and impedance calculation.
Exercise 4
1. Write down some of the applications of complex numbers in engineering context.
2. Deﬁne the following functions with examples:
(a) cart2pol()
(b) abs()
(c) taylor()
(d) ifft()
(e) ezplot()
3. Take a user input for a complex number in rectangular form.
(a) Convert the complex number into polar form and save it in a variable m.
(b) Determine the magnitude and angle of the complex number.
(c) Consider another complex number n ¼ 5  i. Determine m  n in
exponential form.
4. Given a differential equation with initial values as follows:
(a) dy
dx ¼ y0 ¼ f x, y
ð
Þ ¼ 5x4 þ x2  x þ 2y  14; 7  x  20; y 0
ð Þ ¼ 0:2
(b) dy
dx ¼ y0 ¼ f x, y
ð
Þ ¼ x2 þ 5x  y;  2  x  2; y 0
ð Þ ¼ 0:05:
Develop a function for Euler’s series, such that the function takes the equation,
lower and upper limit, step number, and the initial value to generate the values of
x and y. Plot the ‘x versus y0 graph.
5. Consider an input sequence x ¼ linspace(2, 2, 10). Determine the Fourier
transform of x and the inverse Fourier transform of the output.
6. Perform the Taylor series expansion of the function f ¼ 2 cos (x) + 3 sin (x) at a
point 0.6, for the order up to fourth and tenth.
7. In a series ac electrical circuit, consider a voltage source of 220∠30 V. There is a
resistor of 10 ohms, an inductor of 20  103 H, and a capacitor of 4 μF attached
to the circuit in series. The current ﬂowing through the circuit is 5∠45 A. The
92
4
Complex Numbers

systems connected to it take 20 W real power and 35 VAR reactive power for a
single day.
(a) Determine the impedance in both rectangular and polar forms.
(b) Calculate the apparent power in rectangular and polar form.
(c) Determine the electrical energy.
Exercise 4
93

Chapter 5
Visualization
5.1
Introduction
Visualization is one of the best features of MATLAB. In this chapter, different
visualization techniques of MATLAB are elaborately explained and demonstrated.
Similar to other programming languages, MATLAB covers a wide variety of
visualization techniques, such as line plot, bar plot, area plot, surface plot, pie plot,
heat map, radar plot, etc. In this chapter, all of these visualization methods are
produced in MATLAB by using data relevant to engineering ﬁelds. In MATLAB,
three-dimensional plotting is also available, which is also covered in this chapter. In
the end, the process of exporting high-quality ﬁgures from MATLAB will be
demonstrated with step-by-step directions.
5.2
Line Plot
In visualization, a line plot is the most basic and important form of graphics. In
MATLAB, a 2D line plot can be drawn by utilizing the plot command, which offers
several features, and user customization options. A plot command incorporating
some common features is given below with necessary illustrations:
Line plot command for MATLAB:
plot(xvalue, yvalue, ‘Line Color Line Style Marker’, ‘Linewidth’, n)
xvalue: x-axis values
yvalue: y-axis values
The above-mentioned plot command will plot a 2D line of xvalue vs yvalue.
Therefore, plot(xvalue, yvalue) command is the simplest version of this command
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_5
95

through which a 2D line plot can be drawn using MATLAB. For all the other
features, MATLAB will use default values or styles.
However, it is also important to know about the other features to learn how to
make a plot self-customized. Hence, descriptions of the other features of the plot
command are given below:
Line Color: The color of the plotted line can be speciﬁed, or MATLAB will use
the default color. Therefore, it is an optional feature. MATLAB supports a wide
range of colors. For the most common colors, there are some speciﬁc commands. A
table incorporating commands of most common colors is given in Table 5.1.
Apart from the above-mentioned colors, MATLAB also supports all combina-
tions of red, green, and blue (RGB) colors, which are represented by a single vector
in MATLAB. By changing the values of the vector, all kinds of variations in colors
can be made possible. An RGB color vector in MATLAB contains pixel values of
red, green, and blue that range from (0,255) individually. Therefore, a vector of
[1 120 230] deﬁnes a speciﬁc color, and thus, a wide variety of colors can be formed
and utilized in MATLAB.
Line Style: Line style deﬁnes the nature of the line that will be used to plot a 2D
line plot. The line can be solid, or dashed, or any other form. MATLAB provides the
opportunity to customize such styles by introducing some speciﬁc symbols to deﬁne
them. A table incorporating different line styles is provided in Table 5.2.
It is to be noted that MATLAB uses solid lines as the default line style.
Marker: Marker is also an optional feature provided by MATLAB. The feature
allows marking speciﬁc points in a line plot by using a customized marker. Some of
the line markers that are offered by MATLAB are given in Table 5.3 with
corresponding symbols to use in the code.
Linewidth: The width of the plotted line can be weighted by choosing a numerical
value. By default, MATLAB will choose linewidth as 1. By increasing the number,
the width can be customized. The standard procedure to add linewidth feature in the
Table 5.1 Line colors in
MATLAB
Color
Commands
Blue
‘b’
Red
‘r’
Green
‘g’
Black
‘k’
Yellow
‘y’
White
‘w’
Magenta
‘m’
Cyan
‘c’
Table 5.2 Line styles in
MATLAB
Line style
Symbols
Solid line
-
Dashed line
--
Dash-dotted line
-.
Dotted line
:
96
5
Visualization

plot command is to incorporate—‘Linewidth0, n—command within the plot com-
mand, where n represents a numerical value referring to the level of the weight of the
linewidth.
A plot command for input x and y, with other features, can be written as shown in
Fig. 5.1.
Basic Features There are some basic features of visualizations that are not only
restricted to be used in a line plot but also for other forms of visualizations. To
beautify and also to add relevant information to a ﬁgure, the features mentioned in
Table 5.4 are essential and used widely in MATLAB.
Table 5.3 Line Markers in
MATLAB
Marker
Symbol
Circle
O
Asterisk
*
Point
.
Cross
X
Plus
+
Diamond
d
Square
s
Hexagram
h
Pentagram
p
Triangle (pointed upward)
^
Triangle (pointed downward)
v
Triangle (pointed right)
>
Triangle (pointed left)
<
Fig. 5.1 Plot command syntax and example
Table 5.4 Axis labels and titles in MATLAB plots
Features
Signiﬁcance
xlabel()
To label the x-axis to enable a better understanding of the x-axis data, this function is
used, which takes strings as input
ylabel()
To label the y-axis to enable a better understanding of the y-axis data, this function is
used, which takes strings as input
title()
To provide a title of the plotted ﬁgure, this function is used, which also takes strings as
input
5.2
Line Plot
97

5.2.1
MATLAB Example 5.1: Line Plot
A line plot of global temperature from 2010 to 2020 is shown below using the
MATLAB code in Fig. 5.2. The data is collected from NOAA National Centers for
Environmental Information [1]. In the output presented in Fig. 5.3, the x-axis
represents the years, while the y-axis represents the temperature in degree Celsius.
Subplot Subplot is essential for visualization when comparisons or decisions need
to be made from the side-by-side display. In a subplot, multiple ﬁgures can be plotted
separately in one frame side by side. For subplotting multiple ﬁgures, subplot
Fig. 5.2 Code—Line plot
Fig. 5.3 Graphical output—Line plot
98
5
Visualization

command is used in MATLAB, where a dimension size is deﬁned in the input to
create a frame. For example, subplot(2, 3, 1) signiﬁes the total ﬁgure window will
create a subspace of two by three blocks, i.e., there will be six blocks available in the
entire ﬁgure window arranged in two rows and three columns. The last numerical
number 1 represents the placement—ﬁrst block—where the next plot command will
generate a sub-ﬁgure.
5.2.2
MATLAB Example 5.2: Subplot
The line plots of global temperatures over the years 2010–2020 can be plotted using
the MATLAB code in Fig. 5.4, and the output is shown as subplots in Fig. 5.5.
Here, a subplot(1, 2, 1) is used before the ﬁrst plot command, which signiﬁes
there will be two sub-ﬁgures in one row and two columns and the ﬁrst sub-ﬁgure will
be plotted in the ﬁrst place. For plotting the second sub-ﬁgure in the second block
(ﬁrst row and second column), the subplot(1, 2, 2) command is used right after the
plot command of the second plot.
Double-Axis Plot In a line plot, sometimes we need to plot two line plots in the
same ﬁgure with the double-axis feature. For creating double-axis feature, yyaxis left
Fig. 5.4 Code—Subplot
5.2
Line Plot
99

command is used right before the ﬁrst plot command, which deﬁnes the left y-axis.
Similarly, yyaxis right command is used to deﬁne the right y-axis. Between the two
plot commands, hold on command is used to keep both the plots. hold on is usually
used to hold the previous plotted ﬁgure until the hold off command. If two plot
commands are used consecutively without hold on and hold off command, the ﬁrst
ﬁgure will be replaced by the second one. A hold on command placed between these
two plot commands allows MATLAB to keep both of these plots in one ﬁgure
without replacing anyone. Using hold on even multiple plots can be incorporated in
one ﬁgure until we ﬁnish it by hold off command.
5.2.3
MATLAB Example 5.3: Double-Axis Plot
The code in Fig. 5.6 is for the price comparison of two energy commodities—steel
and copper—from 2000 to 2020 (Data source [2]). The output is presented in
Fig. 5.7. The left y-axis represents the prices of copper, whereas the right y-axis
signiﬁes the prices of steel over the years.
Fig. 5.5 Graphical output—Subplot
100
5
Visualization

Fig. 5.6 Code—Double axis plot
Fig. 5.7 Graphical output—Double axis plot
5.2
Line Plot
101

5.3
Bar Plot
Bar plot is an important visualization that facilitates better comparative analysis. The
bar plot command for MATLAB is listed below:
Bar plot command for MATLAB:
bar(xvalue, yvalue,0Bar color0)
Here, the Bar color can be deﬁned similarly as mentioned in the Line Color part in
Sect. 5.2.
5.3.1
MATLAB Example 5.4: Bar Plot
A bar plot showing the global CO2 emissions in Giga metric ton (Gt) over the years
2010–2020 is illustrated below using the MATLAB code in Fig. 5.8, whose output is
given in Fig. 5.9.
It is to be noted that the data of the above plot is obtained from the International
Energy Agency (IEA) [3].
Horizontal Bar Plot
MATLAB offers some variations in bar plot visualization, such as horizontal bar
plots. For plotting horizontal bar, the command line for MATLAB will be as
follows:
Horizontal bar plot command for MATLAB:
barh(xvalue, yvalue,0Bar color0)
Fig. 5.8 Code—Bar plot
102
5
Visualization

In all bar plots, the “Bar color” deﬁnes the color of all the bars in a plot. However,
MATLAB also provides the opportunity to customize the colors of each bar indi-
vidually. An example for customizing colors of each bar is given in the following
example, which is applicable not only for horizontal bar plots but also for vertical bar
plots.
5.3.2
MATLAB Example 5.5: Horizontal Bar Plot
The data of electricity consumption by different household entities as end-users in
the USA (2018) is utilized to plot a horizontal bar. The unit considered for electricity
consumption per household is kWh/household. The data has been collected from
Ref. [2]. The code is given in Fig. 5.10 with the output in Fig. 5.11.
Output
From the output (Fig. 5.11), it is clear that the highest consumption/household is
obtained from the air conditioning system, whereas the least is from refrigeration. To
color each bar individually, we have assigned the barh plot to a variable C, through
which we have accessed each bar, and assigned an RGB vector representing separate
colors for each of them.
Fig. 5.9 Graphical output—Bar plot
5.3
Bar Plot
103

5.4
Area Plot
Area plot is another interesting and essential visualization technique. The command
for area plot is MATLAB is demonstrated below:
Area plot command for MATLAB:
area(input _ matrix)
Fig. 5.10 Code—Horizontal bar plot
Fig. 5.11 Graphical output—Horizontal bar plot
104
5
Visualization

The dimension of the area matrix may vary according to the dataset. In the area plot,
each of the features stacked over each other sequentially over the y-axis. An example
is given below to facilitate the understanding.
5.4.1
MATLAB Example 5.6: Area Plot
In a power system, the load curve illustrates the variation of loads within a certain
time period. When the time period is 24 h, we consider it as a daily load curve. The
loads can be of different types, such as base load, shoulder load, and peak load. Base
load is the constant load that does not change over time. Shoulder load may change
during certain time intervals by ramping up or ramping down and stay constant for
the rest of the time. On the other hand, peak load only occurs for a short period of
time in a day. It may happen twice, for example, during early morning or late
afternoon.
An ideal scenario of load curve over 24 h in terms of base load, shoulder load, and
peak load is shown in the following MATLAB code (Fig. 5.12) using an area plot.
Output
The data of the input matrix, y, used for the area plot is shown below (Fig. 5.13) to
understand the plotted ﬁgure more conveniently. The ﬁrst, second, and third col-
umns of the y matrix represent the data of base load, shoulder load, and peak load,
respectively.
From Fig. 5.14, the different load patterns over a day can be observed to ﬁnd a
pattern. The curves on different intervals in a day can be utilized to plan on dispatch
opportunities and decide on energy market price as well.
5.5
Surface Plot
Surface plot provides a 3D illustration that facilitates better visualization interpreta-
tion. The MATLAB command for the surface plot is given below:
Fig. 5.12 Code—Area plot
5.5
Surface Plot
105

Fig. 5.13 Output—Area
plot
Fig. 5.14 Output—Area plot

Surface plot command for MATLAB:
surf(x, y, z)
Here, x, y, and z are the input matrices, having the same dimension. The three inputs
utilize a 3D coordinate system to create a surface plot.
5.5.1
MATLAB Example 5.7: Surface Plot
The data of the day-ahead locational marginal price (LMP) of electricity, collected
from California ISO Open Access Same-Time Information System (OASIS), is used
to plot a surface plot [4]. In this plot, only 1-week data started from January 1 to
January 7, 2019 is utilized for a 24-hour time horizon to understand the interval of a
particular day at which the LMP is maximum, or minimum. The surface plot can be
useful to decide on arbitrage or regulation opportunities during a particular interval
on a speciﬁc day. Moreover, the surface plot can also determine when an energy
storage system needs to be charged and when it can be discharged. The code is given
in Fig. 5.15.
Output
The x-axis represents 7 days of the week, and the y-axis refers to the 24-h time
horizon. The x- and y-axis data are used to make a mesh grid, which creates a
coordinate array of dimensions 24  7. Later, the LMP matrix of dimension 7  24
indicates the z-axis value in the surface coordinate. The LMP data is shown in
Fig. 5.16 to realize the surface plot generated afterward.
Fig. 5.15 Output—Area plot
5.5
Surface Plot
107

Here, in this plot in Fig. 5.17, the yellow color signiﬁes the highest locational
marginal price on a certain day and certain interval. The deep blue on the other hand
represents the period when the price is the lowest. The colors are chosen by default;
no code has been used to select these colors in the plot. From an energy market
perspective, when the price is higher, the stakeholder will be more interested to
dispatch energy storage systems for the highest proﬁt. Conversely, during lower
price conditions, the energy storage system will be charged for future use. The
surface plot, thus, can be very useful in regard to attaining higher proﬁt from the
energy market.
Fig. 5.16 Output—Surface plot
Fig. 5.17 Graphical output—Surface plot
108
5
Visualization

5.6
Pie Plot
Pie plot is a widely used visualization method. In MATLAB, a pie plot can be made
using the following command:
Pie plot command for MATLAB:
pie(x, explode)
Here, x is the input vector, and explode is an optional feature of the function. The
explode feature is used whenever single or multiple pieces of pie need to explode
from their original position to signifying their impact. An example with both explode
and without explode feature is shown in the following example.
5.6.1
MATLAB Example 5.8: Pie Plot
The data of electricity consumption by different sectors in the USA (2018) is
demonstrated using a pie plot in MATLAB using the code in Fig. 5.18. A subplot
is used to demonstrate two pie plots side by side with and without explode feature.
In the ﬁrst subplot of Fig. 5.19, all the pieces are stuck together without the
“explode” feature. In the second subplot, we can see that all the pieces explode from
their rigid position. In the code, explode represents a vector, where the value “0”
indicates not to explode, while the value “1” indicates to explode. As all the values in
the explode vector in the above-mentioned code are “1’s,” all of the pieces are
exploded in the second subplot.
Fig. 5.18 Code—Pie plot
5.6
Pie Plot
109

5.7
Heat Map
A heat map is another visualization format for decision-making while considering
three sets of parameters. The MATLAB command for generating a heat map is
shown below:
Heat map plot command for MATLAB:
heatmap(x, y, z)
Here, x, y, and z are the three input parameters. An illustration of a heat map is
shown in the following example to understand its signiﬁcance.
5.7.1
MATLAB Example 5.9: Heat Map
The data of electricity day-ahead market price, more precisely, locational marginal
price (LMP), for 1 week (January 1, 2019 to January 7, 2019) over the time horizon
starting from 10 AM to 3 PM is utilized to generate a heat map using the MATLAB
code in Fig. 5.20. The data is available on the California ISO OASIS site [4].
Fig. 5.19 Graphical output—Pie plot
110
5
Visualization

Output
In the heat map in Fig. 5.21, the x-axis represents the time periods and the y-axis
signiﬁes the date. The individual blocks represent the value of LMP for a speciﬁc
date and period. The color bar is used to differentiate among the different LMPs. The
mild blue indicates the lowest LMP, while the deep blue regards the highest LMP.
Fig. 5.20 Code—Heat map
Fig. 5.21 Output—Heat map
5.7
Heat Map
111

By demonstrating each block in terms of different color intensity makes the heat map
very useful to realize where the price is comparatively higher and lower to make
better decisions.
5.8
Radar Plot
Radar plot is one of the most intriguing and sophisticated visualization techniques.
In a radar plot, the center can be deﬁned as zero. The coordinate starts to span outside
from the center with equal distribution. There is no in-built function in MATLAB for
the radar plot. However, due to its importance in the engineering domain, we have
shown a user-deﬁned function for allowing the scope of radar plot in MATLAB.
5.8.1
MATLAB Example 5.10: Radar Plot
For radar plot, a user-deﬁned function named “RADAR.m” is created, which has
ﬁve input parameters.
This function needs to be saved in the same working directory of the executing
M-ﬁle from which the function will be called to execute.
The MATLAB code of user-deﬁned function named “RADAR.m” is given in
Fig. 5.22.
We are interested in plotting a radar plot to compare among different batteries
considering their certain entities. The features that we have used to compare are
power density, energy density, life cycle, and safety. The batteries that have been
considered to compare are Li-ion, liquid supercapacitor, and NaS. The values of the
mentioned features for each of these batteries are obtained from Ref. [5]. All of these
values have been ranked within a range of 0 to 5, where 5 indicates the most
favorable rank and 0 refers to the least favorable rank. A radar plot has been plotted
using the previously created RADAR function with the code in Fig. 5.23. The output
is shown in Fig. 5.24.
Output
From the above ﬁgure, it can be depicted that liquid supercapacitor battery provides
the highest life cycle and power density opportunity compared to other batteries. On
the other hand, Li-ion is highly favorable while considering safety and energy
density. Therefore, the above radar plot provides an opportunity to decide on
choosing a speciﬁc battery based on intended features.
112
5
Visualization

Fig. 5.22 Code—Creation of RADAR function
5.8
Radar Plot
113

5.9
3D Plot
3D plot enhances the visualization, by providing the opportunity to plot a ﬁgure
which can be rotated in a three-dimensional space. We can realize any plot far better
in a 3D view instead of 2D. MATLAB offers such an opportunity for some of the
plots, such as pie plot, bar plot, etc. To make a 3D pie plot, the MATLAB command
remains almost the same except for including “3” at the later of the name of the
function. For example, the 3D pie plot command of MATLAB is as follows:
3D pie plot command for MATLAB:
pie3(x, explode.)
Fig. 5.23 Code—Radar plot
Fig. 5.24 Graphical output—Radar plot
114
5
Visualization

5.9.1
MATLAB Example 5.11: 3D Pie Plots
The following MATLAB code in Fig. 5.25 demonstrates the plotting of a 3D pie plot
with its output in Fig. 5.26. The plot depicts the share of different sectors in the
electricity consumption in the USA in 2018.
5.10
Exporting High-Quality Figure
In MATLAB, it is possible to customize the quality of the ﬁgure while exporting by
choosing the value of dpi. It is expected by most of the journals to maintain a
minimum quality of the ﬁgures. The recommended dpi level for a good quality ﬁgure
is generally 300 dpi. From MATLAB, while exporting a ﬁgure, the dpi level can be
customized manually. In default mood, the dpi level in MATLAB is below 300 dpi.
Therefore, it is necessary to know how to increase the dpi level while exporting
ﬁgure from MATLAB, which is described below:
Fig. 5.25 Code—3D pie plot
Fig. 5.26 Graphical output—3D pie plot
5.10
Exporting High-Quality Figure
115

Step 1 After producing a ﬁgure in MATLAB, the ﬁrst step is to select File > Export
Setup. A window as in Fig. 5.27 will appear.
Step2 After selecting “Export Setup,” the following window (Fig. 5.28) will
appear:
From this window, ﬁrst, select the “Rendering” option. Later, click on the
dropdown option named “Resolution (dpi).” From this dropdown box, the user
may choose their desired dpi level. In Fig. 5.28, 600 dpi is selected as the resolution.
Step 3 Click on the “Apply to Figure” option, and then select the “Export” button.
Save the ﬁgure in the desired format by browsing the desired saving location.
By following the above-mentioned steps, high-quality ﬁgures can be exported
from MATLAB.
Fig. 5.27 Export Setup from File
116
5
Visualization

5.11
Conclusion
The readers will be able to learn different visualization techniques that can be
implemented in MATLAB from this chapter. This chapter demonstrated line plot,
bar plot, area plot, surface plot, pie plot, heat map, and 3D plot. For all of these
visualizations, MATLAB has built-in functions with many features to self-
customize. All of these functions and the customization techniques are shown and
implemented in this chapter. Radar plot, another important visualization in the
engineering domain, is also illustrated in this chapter. For producing a radar plot,
MATLAB does not have any built-in function. However, in this chapter, a user-
deﬁned function is created for producing radar plots in MATLAB. The chapter
concludes with the demonstration of an essential topic that is the exportation of high-
quality images produced in MATLAB.
Exercise 5
1. Name different types of plots that can be drawn in MATLAB.
2. What is the difference between:
(a) Plot and subplot
(b) Hold on and hold off
Fig. 5.28 Export Setup Window
Exercise 5
117

(c) Bar and barh
(d) Pie and pie3
3. Two products have their average price varied over different months of the year as
shown in Table 5.5. Demonstrate the graph with a line plot:
(a) With subplots
(b) With double axis, where the left axis shows the price of product A, and the
right axis shows the price of product B
The graphs should resemble Figs. 5.29 and 5.30.
(a)
(b)
Table 5.5 Average prices of products A and B in 6 months
Months
Average price of product A
Price (in dollars)
Average price of product B
Price (in dollars)
1
129
178
2
155
198
3
145
183
4
131
174
5
160
181
6
151
193
Fig. 5.29 Expected graphical output for Question 3a
118
5
Visualization

4. A new startup has team members as mentioned in Table 5.6. Using MATLAB,
represent the data in a (a) horizontal bar chart and (b) vertical bar chart.
The graphs should resemble Figs. 5.31 and 5.32.
(a)
(b)
5. In an apparatus purchase for university laboratories, the number of equipment is
estimated as shown in Table 5.7.
Using MATLAB, represent the mentioned data in a:
(a) 2D pie chart (with and without explode feature of the smallest pie using subplot)
(b) 3D pie chart (with and without explode feature of the largest pie using subplot).
The graphs should resemble Figs. 5.33 and 5.34.
(a)
(b)
Fig. 5.30 Expected graphical output for Question 3b
Table 5.6 Number of mem-
bers in each team
Team
Members
HR
5
Software team
15
Electrical team
22
Mechanical team
17
Management team
8
Marketing team
10
Exercise 5
119

Fig. 5.31 Expected graphical output for Question 3b
Fig. 5.32 Expected graphical output for Question 4b
120
5
Visualization

6. The temperature for a particular location is recorded in Table 5.8.
Draw the heat map from the above data using MATLAB. The graph should
appear as in Fig. 5.35.
Table 5.7 Number of each
type of equipment
Equipment
Number
Electrical machines
7
Communication trainer kit
5
Electronics trainer kit
6
PLCs
15
Assorted IC boxes
10
Fig. 5.5 Expected graphical output for Question 5a
Fig. 5.34 Expected graphical output for Question 5b
Exercise 5
121

References
1. NOAA. National Centers for Environmental information, Climate at a Glance: Global Time
Series, published April 2021, retrieved on April 14, 2021 from https://www.ncdc.noaa.gov/cag/.
2. Sakib N, Hossain E, Ahamed SI. A qualitative study on the United States internet of energy: a
step towards computational sustainability. IEEE Access. 2020;8:69003–37.
3. https://www.iea.org/data-and-statistics?country¼WORLD&fuel¼CO2%20emissions&
indicator¼TotCO2.
4. http://oasis.caiso.com/mrioasis/logon.do.
5. http://www.ﬂashchargebatteries.com/solution/.
Table 5.8 The temperature, in C, at different times in different dates
Date/time
12 AM
4 AM
8 AM
12 PM
4 PM
8 PM
1 march
31.5
29.3
30.1
33.2
32.5
31.7
2 march
29.8
28.4
29.0
30.3
30.1
28.8
3 march
27.9
28.1
29.2
30.0
29.5
28.1
4 march
30.7
29.6
30.2
31.6
32.9
32.7
5 march
31.2
30.5
30.4
30.9
31.8
31.4
6 march
31.1
30.6
31.6
32.5
33.7
32.2
Fig. 5.35 Expected graphical output for Question 6
122
5
Visualization

Chapter 6
Solving Equations
6.1
Introduction
In the engineering domain, solving equations is very crucial, which may take
signiﬁcant time and brainwork if solved manually. In MATLAB, all of these
equations can be solved very easily with a few lines of code, without spending too
much time and effort. In this chapter, the basics of linear algebra are explained, and
techniques to solve different types of algebraic and differential equations are
presented with several examples using MATLAB.
6.2
Linear Algebra
Rank The rank of a matrix can be deﬁned as the maximum number of linearly
independent rows or columns. Here, a row or a column vector can be regarded as
linearly independent if:
(a) The vector is not a scalar multiple of other vectors
(b) The vector is not a resultant of the combinations of other vectors
If the dimension of a matrix is row  col, the rank of that matrix will be either the
maximum number of linearly independent rows or columns. It can be distinguished
more precisely as follows:
(a) If row > col, the rank of the matrix maximum number of linearly independent
columns.
(b) If row < col, the rank of the matrix maximum number of linearly
independent rows.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_6
123

The rank of a matrix can be determined using MATLAB, by using rank function
as follows:
MATLAB command for determining the rank of a matrix, A:
rank(A)
6.2.1
MATLAB Example 6.1: Rank
Determine the ranks of the following two matrices A and B:
(i) A ¼ [1 2 4; 2 4 8 ]
(ii) B ¼ [1 1 2; 5 2 7; 0 4 4; 2 6 8 ]
The MATLAB code for this example is given in Fig. 6.1 with its output in
Fig. 6.2.
Fig. 6.1 Code—Determination of rank of a matrix
Fig. 6.2 Output—
Determination of rank of a
matrix
124
6
Solving Equations

Output
Eigenvector and Eigenvalue
Consider a square matrix X of dimension n  n. The eigenvector, v,of the square
matrix A signiﬁes a linear transformation that follows the following condition in
Eq. (6.1):
Xv ¼ λv
ð6:1Þ
Here, λ is a scalar value, which can also be regarded as eigenvalue; and v 2 Rn is a
nonzero vector.
For determining the eigenvalues, the following characteristic equation can be
solved for λ:
XI  λ
j
j ¼ 0,
ð6:2Þ
where I is the identity matrix having the same dimension as X. In MATLAB, using
eig() function eigenvalues can be determined easily.
Finding eigenvalues of a matrix, X, in MATLAB:
eig(X)
It is to be noted that the input matrix X always needs to be a square matrix.
6.2.2
MATLAB Example 6.2: Eigenvalue
Find the eigenvalues of the following matrix, X:
X ¼ 1 2 0; 0 5 0; 1 3 1
½

ð6:3Þ
The MATLAB code for this example is given in Fig. 6.3 with its output in
Fig. 6.4.
Fig. 6.3 Code—
Determination of
eigenvalues of a matrix
6.2
Linear Algebra
125

6.2.3
MATLAB Example 6.3: Eigenvector
Find the eigenvector of the following matrix, X:
X ¼ 1 2 0; 0 5 0; 1 3 1
½

ð6:4Þ
The MATLAB code for this example is given in Fig. 6.5 with its output in
Fig. 6.6.
Here, the MATLAB command [vector, lambda] ¼ eig(X) provides two outputs—
the eigenvector (vector) and a diagonal vector containing the eigenvalues (lambda).
Using the above code, both eigenvalues and eigenvectors can be determined.
Fig. 6.4 Output—
Determination of
eigenvalues of a matrix
Fig. 6.5 Code—Determination of eigenvectors of a matrix
126
6
Solving Equations

6.3
Quadratic Equations
MATLAB has built-in functions to solve any quadratic equations by using the solve
command. The “solve” command also becomes useful to solve multiple equations
with multiple variables. The entities of the solve function of MATLAB are given
below:
Solving Equations in MATLAB:
solve(equation, variable)
Here, the variables can be single or multiple, and the output of the solve function can
also be single or multiple. Some examples solving different types of equations using
the solve function are given below.
6.3.1
MATLAB Example 6.4: Solving Quadratic Equation
Consider a quadratic equation: 2x2 + 4x + 5 ¼ 0. Determine the values of x using
MATLAB.
The MATLAB code for this example is given in Fig. 6.7 with its output in
Fig. 6.8.
Fig. 6.6 Output—
Determination of
eigenvectors of a matrix
6.3
Quadratic Equations
127

Output
Here, the highest degree of x is 2. Therefore, the solution will have two values of
x. The output in Fig. 6.8 conﬁrms that theory.
6.3.2
MATLAB Example 6.5: “Solve” Function
Consider the following two equations:
2x2 þ 4xy þ 5 ¼ 0
ð6:5Þ
3y2 þ 5xy  2 ¼ 0
ð6:6Þ
Determine the values of x and y using MATLAB.
The MATLAB code for this example is given in Fig. 6.9 with its output in
Fig. 6.10.
In the above example, two quadratic equations with two variables have been
solved using MATLAB. Thus, the solve function provides a wide opportunity to
solve different types of equations. It is to be noted that the syms is used to deﬁne the
unknown variables at the start of implementing solve function in each case.
Fig. 6.7 Code—Solving
quadratic equation
Fig. 6.8 Output—Solving
quadratic equation
128
6
Solving Equations

6.4
Differential Equations
6.4.1
Ordinary Differential Equations
Using MATLAB, ordinary differential equations can be solved by dsolve function. It
not only can be used for ﬁrst-order differential equations but also covers higher
degrees of differential equations. The input parameters of dsolve function are given
below:
Solving Equations:
dsolve(equation, condition)
dsolve function has two parameters—equation, which represents the differential
equation that needs to be solved, and condition, which is an optional feature. If the
problem has initial conditions, the function will provide an exact solution based on
Fig. 6.9 Code—solve function
Fig. 6.10 Output—solve function
6.4
Differential Equations
129

those conditions. Otherwise, the function will provide a generalized result with an
unknown constant C1. Hence, dsolve function can be used to solve initial value
problems as well.
Some examples covering ﬁrst-order to third-order differential equation solves are
shown in the following examples:
6.4.2
MATLAB Example 6.6: First-Order Differential
Equation
Consider the following ﬁrst-order differential equation:
dy
dx ¼ 2x þ y
ð6:7Þ
(i) Solve the differential equation.
(ii) If initial condition y(0) ¼ 1, ﬁnd the solution of the differential equation.
The MATLAB code for this example is given in Fig. 6.11 with its output in
Fig. 6.12.
Output
Fig. 6.11 Code—First-order differential equation
130
6
Solving Equations

6.4.3
MATLAB Example 6.7: Second-Order Differential
Equation
Solve the following second-order differential equation:
d2y
dx2 ¼ 2x2 þ 3 dy
dx  5;
y 0
ð Þ ¼ 1, y0 0
ð Þ ¼ 1
ð6:8Þ
The MATLAB code for this example is given in Fig. 6.13 with its output in
Fig. 6.14.
Fig. 6.12 Output—First-
order differential equation
Fig. 6.13 Code—Second-order differential equation
6.4
Differential Equations
131

Output
6.4.4
MATLAB Example 6.8: Third-Order Differential
Equation
Solve the following third-order differential equation:
d3y
dx3 ¼ 3x2 þ 3 d2y
dx2  2 dy
dx þ 1;
y 0
ð Þ ¼ 1, y0 0
ð Þ ¼ 0, y00 0
ð Þ ¼ 1
ð6:9Þ
The MATLAB code for this example is given in Fig. 6.15 with its output in
Fig. 6.16.
Fig. 6.14 Output—Second-order differential equation
Fig. 6.15 Code—Third-order differential equation
132
6
Solving Equations

Output
6.4.5
Partial Differential Equations
In the partial derivative of a function of multiple variables, the differentiation is
performed with respect to one variable while considering the rest of the variables as
constant. To solve a partial differential equation, the ﬁrst step is to solve the partial
derivative terms using diff() command. The distinction between the ordinary and the
partial derivative will be made while deﬁning the symbols of the variable at the start
of MATLAB code. In ordinary differentiation, we deﬁne the output variable as a
function of other variables. However, in partial derivatives, we treat only one as an
active variable, while the rest are considered constants. An example is given below
for further understanding.
6.4.6
MATLAB Example 6.9: Partial Differential Equation
Consider the following partial differential equation:
∂
∂x 2x2 þ y  5


 x2 ¼ 0
ð6:10Þ
Solve the partial differential equation for x.
The MATLAB code for this example is given in Fig. 6.17 with its output in
Fig. 6.18.
Output
Here, after solving each partial derivative terms, we have used solve() function to
ﬁnally solve the partial differential equation for x.
Fig. 6.16 Output—Third-order differential equation
6.4
Differential Equations
133

6.5
Integral Equations
In MATLAB, integration can be solved using int() function. Integrals can be of two
types: deﬁnite integral and indeﬁnite integrals. In an indeﬁnite integral, the limits are
not deﬁned; whether in a deﬁnite integral, the limits are deﬁned for the variable with
respect to which the integration will be performed. To solve any integral equation,
the very basic step is to ﬁrst determine the values of the integral terms. The
MATLAB command for determining integration of a function is as follows:
Integration of a function f with respect to x with a limit of [a, b] in
MATLAB:
int( f, x, a, b)
After determining the integral terms, by using solve(), integral equations can be
solved.
Fig. 6.17 Code—Partial differential equation
Fig. 6.18 Output—Partial
differential equation
134
6
Solving Equations

6.5.1
MATLAB Example 6.10: Single Variable Integral
Equation
Consider the following single variable integral equation:
Z
2x2:dx  3x ¼ 0
ð6:11Þ
(i) Solve the above integral equation for x.
(ii) If the limit of x is [0 2], ﬁnd the solution for x.
Fig. 6.19 Code—Single variable integral equation
Fig. 6.20 Output—Single
variable integral equation
6.5
Integral Equations
135

The MATLAB code for this example is given in Fig. 6.19 with its output in
Fig. 6.20.
Output
6.5.2
MATLAB Example 6.11: Multivariable Integral
Equation
Consider the following multivariable integral equation:
Z
x2 þ ey


:dx ¼ 0
ð6:12Þ
(i) Solve the above integral equation for y.
(ii) If the limit of x is [0 1], ﬁnd the solution for y.
The MATLAB code for this example is given in Fig. 6.21 with its output in
Fig. 6.22.
Output
Fig. 6.21 Code—Multi-variable integral equation
136
6
Solving Equations

6.6
Conclusion
Linear algebra is an important ﬁeld in the engineering domain. In this chapter, some
essential concepts of linear algebra, such as rank, eigenvalues, and eigenvectors, are
discussed with MATLAB examples. The key part of this chapter is the detailed
MATLAB implementations to solve different types of equations. The readers will be
able to learn about different MATLAB functions and their implementations to solve
quadratic equations, differential equations, and integral equations. The possible
variations of each of these equations are brought in the discussion of this chapter,
to facilitate the readers with a detailed understanding of the topic.
Exercise 6
1. What are eigenvalues and eigenvectors? How these are mathematically
determined?
2. Mention the application of solve() and dsolve() on MATLAB with examples.
3. Given
two
matrices
ið Þ M ¼
4
5
8
11


and ii
ð Þ N ¼
0:33
1
3:3
0:5
0:45
5:12
2
2
0
2
64
3
75 :
(a) Determine the rank of M and N.
(b) Determine the inverse of M and N.
(c) Determine the eigenvalues and eigenvector of M and N.
Fig. 6.22 Output—Multi-
variable integral equation
Exercise 6
137

4. Solve the following algebraic equations using MATLAB:
(a) x2 + 5x + 9 ¼ 0
(b) 101x2 + 36x + 255 ¼ 4
(c) 2.60x2 + 5.34x  7 ¼ 7.44
(d) 9x2 + 3xy  2 ¼  3; 4x2 + 7xy + 5/2 ¼ 0
(e) 16x2 + xy  3 ¼ 9x2  11xy + 2 ¼ 7
5. Solve the following differential equations using MATLAB. Show the solution
with the initial condition where applicable. Use vpa() to summarize large expres-
sion up to two signiﬁcant digits:
(a) dy
dx ¼ 3x þ 2y; y 0
ð Þ ¼ 2
(b) dy
dx ¼ 7x þ 4y þ 2; y 0
ð Þ ¼ 1
(c) d2y
dx2 ¼ 5x2 þ 9 dy
dx þ 2y;
y 0
ð Þ ¼ 2, y0 0
ð Þ ¼ 1
(d) d2y
dx2 ¼ 3x2  dy
dx þ 2;
y 0
ð Þ ¼ 1, y0 0
ð Þ ¼ 1
(e) d3y
dx3 ¼ 5x2 þ 11 d2y
dx2 þ dy
dx þ 8;
y 0
ð Þ ¼ 2, y0 0
ð Þ ¼ 1, y00 0
ð Þ ¼ 1
(f) d3y
dx3 ¼ 6x2 þ d2y
dx2  23;
y 0
ð Þ ¼ 1, y0 0
ð Þ ¼ 0, y00 0
ð Þ ¼ 1
(g)
∂
∂x x2 þ 4y þ 3
ð
Þ þ 7x2 ¼ 3
(h)
∂
∂x 3x2  11y
ð
Þ  2x2 ¼ 0
6. Consider the following integral equations:
(a) R(log(x))2. dx  2x
(b)
R
(2x  ey). dx.
For each of the above:
(i) Solve the above integral equations for y.
(ii) If the limit of x is [0 2], ﬁnd the solution for y.
138
6
Solving Equations

Chapter 7
Numerical Methods in MATLAB
7.1
Introduction
Numerical methods are important to solve mathematical problems that contain
continuous variables, and not possible to solve explicitly. It is an important area
that involves both mathematics and computer science. In the ﬁeld of engineering,
numerical methods can be applied in numerous applications. With the recent advent
of digital computers, the implication of numerical analysis has become a part and
parcel of engineering applications. MATLAB can provide the platform to utilize
different numerical methods in various applications. In this chapter, some of the
important numerical methods are described and implemented using MATLAB, such
as the Gauss-Seidel method, the Newton-Raphson method, and the Runge-Kutta
method.
7.2
Gauss-Seidel Method
Gauss-Seidel method is an iterative method through which a set of equations can be
solved for determining unknown variables. Carl Friedrich Gauss ﬁrst developed the
Gauss iteration method, which was later improved by Philipp Ludwig Seidel. Due to
both of their contributions, the improved algorithm was named after both of them,
which is called the Gauss-Seidel method.
Consider the following set of equations, where x, y, and z are the unknown
variables:
a1x þ b1y þ c1z ¼ d1
ð7:1Þ
a2x þ b2y þ c2z ¼ d2
ð7:2Þ
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_7
139

a3x þ b3y þ c3z ¼ d3
ð7:3Þ
Here, a1, a2, a3 are the coefﬁcients of x; b1, b2, b3 are the coefﬁcients of y; c1, c2,
c3 represents the coefﬁcients of z; and d1, d2, d3 are the constants of the above
equations.
In the Gauss-Seidel method, the aim is to solve these equations for x, y, and z,
respectively. Hence, these equations can be rewritten as follows:
x ¼ 1
a1 d1  b1y  c1z
ð
Þ
ð7:4Þ
y ¼ 1
b2 d1  a2x  c2z
ð
Þ
ð7:5Þ
z ¼ 1
c3 d1  a3x  b3y
ð
Þ
ð7:6Þ
The next step is to assign the initial values of x, y, and z into the above Eqs. (7.4)–
(7.6) to determine the values of x1, y1, z1, which indicates the ﬁrst approximation of
the values of x, y, and z, respectively after the ﬁrst iteration. In the previous Gauss
iteration method, all the initial values are used during the ﬁrst iteration; and later the
results of the ﬁrst iterations are used for the successive iteration. To understand it
more clearly, let us assume the initial values of x, y, and z are x0, y0, and z0,
respectively.
In the Gauss iteration method, the ﬁrst approximations of the values are deter-
mined as follows:
x1 ¼ 1
a1 d1  b1y0  c1z0
ð
Þ
ð7:7Þ
y1 ¼ 1
b2 d1  a2x0  c2z0
ð
Þ
ð7:8Þ
z1 ¼ 1
c3 d1  a3x0  b3y0
ð
Þ
ð7:9Þ
To determine the values of x2, y2, z2 in the second iteration, the determined values
x1, y1, z1 will be used in place of x0, y0, and z0,respectively. This algorithm continues
until convergence.
Later, with an improvisation made by Seidel, the Gauss-Seidel method appears,
where instead of using all the values of the previous iteration for the calculation of
the next iterated values, this method suggests the usage of the most recent updated
values all the time to converge faster than before.
In the Gauss-Seidel method, the ﬁrst approximations are calculated as follows:
140
7
Numerical Methods in MATLAB

x1 ¼ 1
a1 d1  b1y0  c1z0
ð
Þ
ð7:10Þ
y1 ¼ 1
b2 d1  a2x1  c2z0


ð7:11Þ
z1 ¼ 1
c3 d1  a3x1  b3y1


ð7:12Þ
Here, in the ﬁrst iteration, for determining y1, the latest updated value x1 is used
instead of x0. The same continues for other values and other iterations as well. Due to
this improvisation, the number of iterations greatly reduces, and the algorithm
converges more quickly.
After repeating these steps for several iterations, we can determine the values of
x, y, and z more accurately. Generally, the greater the number of iterations, the results
will start to become more accurate. Therefore, it is a good question to ask—what is
the standard number of iterations before we can stop the procedure? There is no
speciﬁc number to answer this question; however, in this iterative method, the
approximate values become almost constant after some iterations. When this occurs,
we can conclude that the convergence has happened, and it is probably the best place
to stop the iteration. There are also some other methods such as calculating the
tolerance and making a decision based on our expectation of tolerance for a certain
problem to set up stopping criteria.
The tolerance is calculated by using the following formula:
Tol xiþ1 ¼ xiþ1  xi


xi
ð7:13Þ
Here, Tol _ xi + 1 indicates the tolerance for xi + 1 in the (i + 1)th iteration.
Similarly, the tolerance for both yi and zi can be calculated. A threshold tolerance can
be deﬁned based on which the stopping decision will be made. For example, if the
tolerance values for all x, y, and z fall below 0.0001, we can make a decision that the
convergence has been achieved at that iteration; and further iterations can be
curtailed.
MATLAB is one of the most suitable platforms to perform this iterative analysis.
Using MATLAB, it is easier to perform a higher number of iterations more easily to
reach the convergence. An example is given below where a set of equations are
solved for determining the unknown variables using the Gauss-Seidel method.
7.2
Gauss-Seidel Method
141

7.2.1
MATLAB Example 7.1: Gauss-Seidel Method
Consider the following set of equations to determine the values of x, y,and z using the
Gauss-Seidel method:
80x  10y þ 2z ¼ 85
ð7:14Þ
5x þ 50y þ 12z ¼ 112
ð7:15Þ
4x þ 9y þ 30z ¼ 68
ð7:16Þ
Consider the tolerance for x, y, and z to be less than 0.00001.
Solution The ﬁrst step is to rewrite Eqs. (7.14)–(7.16) as follows:
x ¼ 1
80 85  10y þ 2z
ð
Þ
ð7:17Þ
Fig. 7.1 Code—Gauss-Seidel method
142
7
Numerical Methods in MATLAB

y ¼ 1
50 112  5x  12z
ð
Þ
ð7:18Þ
z ¼ 1
30 68  4x  9y
ð
Þ
ð7:19Þ
These equations will be our input to the MATLAB program. The initial values of
x, y,and z will be considered as zero.
The MATLAB code for this example is given in Fig. 7.1 with its output in
Fig. 7.2.
Here, we can observe that at the sixth iteration, the tolerances for x, y, and z are all
below the threshold—0.00001. Hence, the iteration is stopped after the sixth itera-
tion, and the values obtained at this iteration are our desired outcomes.
7.3
Newton-Raphson Method
Newton-Raphson (N-R) method is one of the most effective methods to approximate
the root of a nonlinear function, which is differentiable. It uses the concept of the
tangent to produce an approximation of the root, and it only needs one initial value,
which needs to be close to the value of the actual root of that function. The closer will
be the initial value, the accuracy of approximation will enhance accordingly. Con-
sider a function f(x) and we are interested in approximating its root using the N-R
method. If the initial guess of x is xo, the procedure to approximate the root through
iteration is to follow the steps below:
The ﬁrst step is to determine the ﬁrst approximate value of the root by using the
following formula:
x1 ¼ x0  f x0
ð
Þ
f 0 x0
ð
Þ
ð7:20Þ
where x1 indicates the ﬁrst approximated root determined after the ﬁrst iteration and
f 0(x) is the ﬁrst derivative of the input function f(x). In the above equation, the ratio of
Fig. 7.2 Output—Gauss-Seidel method
7.3
Newton-Raphson Method
143

the original function and its derivative at the point x ¼ x0 is used. In the next step, x1
replaces x0, and the second iteration is performed to determine the second approx-
imate root. This step is repeated until convergence is attained. Therefore, the general
formula for the approximation of root using the N-R method can be written as
follows:
xnþ1 ¼ xn  f x
ð Þ
f 0 x
ð Þ
ð7:21Þ
Here, i represents the number of iterations. Sometimes the initial value can be a
small range instead of a single value. In that case, the good strategy is to take the
mean value of that range as our initial guess and start from there. For the stopping
criteria of iteration, we can follow the same procedure mentioned previously in the
Gauss-Seidel method. Here, as we are only interested in approximate the root, we
only need to calculate the tolerance of x in each iteration using the following formula
as mentioned earlier as well:
Tol xiþ1 ¼ xiþ1  xi


xi
ð7:22Þ
7.3.1
MATLAB Example 7.2: Newton-Raphson Method
Consider the function, f(x) ¼ 2x + sin (x)  2, which has a root within the range of
[0,2]. Using the N-R method, approximate the root of the function in MATLAB.
Also, make sure that the tolerance for the value of root is less than 0.0001.
The MATLAB code for this example is given in Fig. 7.3 with its output in
Fig. 7.4.
Here, after the fourth iteration, the tolerance has fallen below 0.00001. Therefore,
the approximation of the root value of our function is obtained in the fourth iteration,
which is 0.68404.
7.4
Runge-Kutta Method
Runge-Kutta method is an iterative method to solve or approximate ordinary differ-
ential equations. Out of the Runge-Kutta family, “RK4” or the fourth-order Runge-
Kutta method is the most widely used method. Sometimes it is also regarded as the
classical Runge-Kutta method.
144
7
Numerical Methods in MATLAB

Consider a differential equation y0 ¼ f(x, y), with the initial value of y(0) ¼ y0. For
approximating the solution of this differential equation for the value of y using the
Runge-Kutta method, the following formula needs to be followed:
xiþ1 ¼ xi þ h
ð7:23Þ
yiþ1 ¼ yi þ 1
6 k1 þ 2k2 þ 2k3 þ k4
½
,
ð7:24Þ
where:
Fig. 7.3 Code—Newton-Raphson method
Fig. 7.4 Output—Newton-Raphson method
7.4
Runge-Kutta Method
145

k1 ¼ hf xi, yi


ð7:25Þ
k2 ¼ hf
xi þ h
2, yi þ k1
2


ð7:26Þ
k3 ¼ hf
xi þ h
2, yi þ k2
2


ð7:27Þ
k4 ¼ hf xi þ h, yi þ k3


ð7:28Þ
Here, the value of x is updated with a certain time step h in every ith iteration. For
each of that, the updated value of x, the value of y is approximated in every iteration
as mentioned in the equation. In the above equation k1, k2, k3,k4 are the weights of the
fourth-order Runge-Kutta method, which are updated in every iteration following
the formula mentioned above. For a certain range of the x value, the solution y is
approximated in each iteration step. An example of the implementation of the
Runge-Kutta method in MATLAB is given below to understand the method more
clearly.
7.4.1
MATLAB Example 7.3: Runge-Kutta Method
Consider the following differential equation:
dy
dx ¼ x þ 2y
ð
Þ cos y
ð Þ; 0  x  2, y 0
ð Þ ¼ 5
ð7:29Þ
Solve the equation for the value of y using the Runge-Kutta method for the step
size of 0.2 in MATLAB.
The MATLAB code for this example is given in Fig. 7.5 with its output in
Fig. 7.6.
Here, the solution of the differential equation is plotted for the range of x[0, 2]
using the step size 0.2. The obtained ﬁnal value of y for x ¼ 2 is 7.49116.
7.5
Conclusion
In this chapter, some of the important numerical methods are explained, along with
the implementation in MATLAB. From this chapter, the readers will be able to learn
about three numerical methods—Gauss-Seidel method, Newton-Raphson method,
and Runge-Kutta method—that have been described in detail. The algorithms for
146
7
Numerical Methods in MATLAB

each of these algorithms are demonstrated both theoretically and practically to grasp
the concept. Examples of mathematical problems and their solutions utilizing these
three numerical methods are shown in this chapter by using MATLAB programming
language. Therefore, the contents of this chapter will immensely help the readers to
build up a basic understanding of numerical methods and their practical applications
to solve different mathematical problems using MATLAB.
Fig. 7.5 Code—Runge-Kutta method
Conclusion
147

Exercise 7
1. Write down the basic steps of the following:
(a) Gauss-Seidel method
(b) Newton-Raphson method
(c) Runge-Kutta method
2. State the major differences in the calculation of the three methods mentioned in
Question 1.
3. Given a set of equation as follows:
20x  2y  z ¼ 122
4x  60y þ 18z ¼ 76
2x  15y þ 35z ¼ 50
(a) Solve the equation using Gauss-Seidel method in MATLAB. Consider the
tolerance for x, y, and z to be less than 0.00001.
(b) What happens when you decrease the tolerance to 0.0001 and 0.001? Do the
values vary from the values determined in question (a)? Why do you think
this occurs?
Fig. 7.6 Graphical output—Runge-Kutta method
148
7
Numerical Methods in MATLAB

(c) What happens when you increase the tolerance to 0.000001 and 0.0000001?
Do the values vary from the values determined in question (a)? Why do you
think this occurs?
4. Solve the following equation using Newton-Raphson method, which has a root
within the range of [0, 2]. Consider a tolerance for the value of root less than
0.0001:
(a) 3x + 2 cos (x)  5
(b) x5  x  2
5. Use the classical fourth-order Runge-Kutta method to solve the following differ-
ential equations for the step size of 0.2, for 0  x  2, and with an initial condition
of y(0) ¼ 5 in MATLAB:
(a) dy
dx ¼ 4x3  6x2  10x þ 2
(b)
dy
dx ¼ xsin y
ð Þ þ y cos x
ð Þ
Exercise 7
149

Chapter 8
Electrical Circuit Analysis
8.1
Introduction
Electrical circuit analysis can be carried out by implementing different circuit
theories and formulas by utilizing MATLAB programming language. The electrical
circuit analyses can be divided initially into two main parts—DC and AC circuit
analysis. Both in DC and AC circuit analysis, some of the important theorems and
methods relevant to solving individual circuit problems are explained with necessary
MATLAB illustrations. Apart from that, two important electrical components—
operational ampliﬁer and transistor—are covered in this chapter with their relevant
circuit problems.
8.2
DC Circuit Analysis
In DC circuit analysis, MATLAB can be useful for circuit solutions and demon-
strating different circuit laws. In this section, some of the important laws and circuit
problem solutions will be discussed utilizing MATLAB.
8.2.1
Ohm’s Law
Ohm’s law demonstrates the relationship among voltage, current, and resistance as
shown in Eq. (8.1) with the consideration of constant temperature:
V ¼ IR,
ð8:1Þ
where V is the voltage, I is the current, and R is the resistance of a DC circuit.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_8
151

This formula demonstrates a proportional relationship between voltage and
current. In MATLAB, this relationship can be demonstrated graphically to realize
this proportionality.
8.2.1.1
MATLAB Example 8.1: Ohm’s Law
Consider a DC series circuit whose voltage across a resistance changes within the
range of 1 to 10 V, if the resistance is 5 ohms. Plot a graph showing the changes of
current in accordance with the changes of voltage.
The MATLAB code for this example is given in Fig. 8.1 with its output in
Fig. 8.2.
Output
8.2.2
Equivalent Resistance
In an electrical circuit analysis, equivalent resistance calculation is of supreme
importance. The equivalent resistance signiﬁes the overall resistance of a circuit,
where the multiple resistance can be connected in series, parallel, or a combination
of both.
If multiple resistances are connected in series, the equivalent resistance is the
summation of all of them. Therefore, for a series-connected resistive circuit, the
equivalent resistance will be as shown in Eq. (8.2):
Fig. 8.1 Code—Ohm’s law
152
8
Electrical Circuit Analysis

Req ¼ R1 þ R2,
ð8:2Þ
where R1 and R2 are the two resistances connected in series. For parallel or shunt
connected circuit, the equivalent resistance can be represented by Eq. (8.3):
Req ¼ 1
R1 þ 1
R2 ¼ R1  R2
R1 þ R2
ð8:3Þ
An example is provided below, where both the combination of series and parallel
resistances can be found in a single circuit.
In the circuit in Fig. 8.3, R2 and R3 are connected in parallel, with which R1 is in
series. Therefore, the equivalent resistance of the circuit can be written as follows:
Fig. 8.2 Output—Ohm’s law
Fig. 8.3 A series-parallel
resistive circuit
8.2
DC Circuit Analysis
153

Req ¼ R1 þ
R2
R3


¼ R1 þ R2  R3
R2 þ R3
ð8:4Þ
8.2.2.1
MATLAB Example 8.2: Equivalent Resistance
Determine the equivalent resistance for the circuit shown in Fig. 8.3. Consider the
value of R1 ¼ 10; R2 ¼ 5; R3 ¼ 4 ohms.
The MATLAB code for this example is given in Fig. 8.4 with its output in
Fig. 8.5.
8.2.3
Delta-Wye Conversion
In some scenarios, the resistances of a circuit may not be connected either in series or
parallel. During that scenario, delta-wye conversion may become useful.
Consider the following circuit in Fig. 8.6, where R1, R2, and R3 are in a delta
conﬁguration, and R4, R5,and R3 are in another delta conﬁguration. To determine the
equivalent resistance, one of the easiest ways is to convert the delta conﬁguration
into a wye conﬁguration to make the calculation easy. Before we solve the following
circuit for equivalent resistance, let us have a look at the formula to convert any delta
conﬁguration to a wye conﬁguration and vice versa.
In Fig. 8.7, the delta conﬁguration and the wye conﬁguration of resistances have
been shown with a diagram. In the delta conﬁguration, the resistances are connected
in such a way that it looks like the delta symbol Δ. Conversely, in the wye
conﬁguration, the resistances create an appearance of “Y.” This conﬁguration is
Fig. 8.4 Code—Equivalent resistance
Fig. 8.5 Output—
Equivalent resistance
154
8
Electrical Circuit Analysis

termed star conﬁguration as well. The conversion among delta to wye and wye to
delta are both possible and can be deﬁned with a generalized formula.
Delta to Wye Conversion
In Fig. 8.7, Rd1, Rd2, and Rd3 are the resistances that are connected in a delta
conﬁguration. This delta conﬁguration can be transformed into an equivalent wye
conﬁguration, where the new resistances will be Ry1, Ry2, and Ry3. Both of the
conﬁgurations have three common nodes A, B, and C. The formulas for converting
each of the delta resistances to its corresponding wye resistances are enlisted as
Eqs. (8.5)–(8.7):
Ry1 ¼
Rd1 Rd2
Rd1 þ Rd2 þ Rd3
ð8:5Þ
Ry2 ¼
Rd1 Rd3
Rd1 þ Rd2 þ Rd3
ð8:6Þ
Fig. 8.6 A delta connected
resistive circuit
Fig. 8.7 Delta and wye conﬁguration in electrical circuits
8.2
DC Circuit Analysis
155

Ry3 ¼
Rd2 Rd3
Rd1 þ Rd2 þ Rd3
ð8:7Þ
8.2.3.1
MATLAB Example 8.3: Delta to Wye Conversion
Consider a delta conﬁgured circuit as shown in Fig. 8.7, having the resistances
Rd1 ¼ 10 Ω, Rd2 ¼ 5 Ω, and Rd3 ¼ 20 Ω. Determine the equivalent wye resistances
Ry1, Ry2, and Ry3 using MATLAB.
The MATLAB code for this example is given in Fig. 8.8 with its output in
Fig. 8.9.
Output
Wye to Delta Conversion
To convert a wye conﬁgured resistances Ry1, Ry2, and Ry3 to a delta conﬁgured
equivalent resistances Rd1, Rd2, and Rd3; the following relationships shown in
Eqs. (8.8)–(8.10) can be utilized:
Fig. 8.8 Code—Delta to wye conversion
Fig. 8.9 Output—Delta to wye conversion
156
8
Electrical Circuit Analysis

Rd1 ¼ Ry1 ∙Ry2 þ Ry2 ∙Ry3 þ Ry3 ∙Ry1
Ry3
ð8:8Þ
Rd2 ¼ Ry1 ∙Ry2 þ Ry2 ∙Ry3 þ Ry3 ∙Ry1
Ry2
ð8:9Þ
Rd3 ¼ Ry1 ∙Ry2 þ Ry2 ∙Ry3 þ Ry3 ∙Ry1
Ry1
ð8:10Þ
8.2.3.2
MATLAB Example 8.4: Delta to Wye Conversion
Consider a delta conﬁgured circuit as shown in Fig. 8.7, having the resistances
Rd1 ¼ 10 Ω, Rd2 ¼ 5 Ω, and Rd3 ¼ 20 Ω. Determine the equivalent wye resistances
Ry1, Ry2, and Ry3 using MATLAB.
The MATLAB code for this example is given in Fig. 8.10 with its output in
Fig. 8.11.
Fig. 8.11 Code—Wye to delta conversion
Fig. 8.10 Code—Wye to delta conversion
8.2
DC Circuit Analysis
157

Output
8.2.3.3
MATLAB Example 8.5: Equivalent Resistance with Delta-Wye Conversion
Consider Fig. 8.6 to determine its equivalent resistance by utilizing the delta-wye
conversion method. The values of the resistances are R1 ¼ 2 Ω; R2 ¼ 4 Ω; R3 ¼ 6 Ω;
R4 ¼ 3 Ω; and R5 ¼ 2 Ω.
For clariﬁcation, in Fig. 8.12, the procedures for determining equivalent resis-
tance are shown graphically, which is implemented in the MATLAB code below.
The MATLAB code for this example is given in Fig. 8.13 with its output in
Fig. 8.14.
Output
8.2.4
Kirchhoff’s Laws
Gustav Robert Kirchhoff ﬁrst proposed two very fundamental laws of electrical
circuits known as Kirchhoff’s Current Law (KCL) and Kirchhoff’s Voltage Law
(KVL).
Fig. 8.12 Simplifying the circuit by determining the equivalent resistance using delta-wye
conversion
158
8
Electrical Circuit Analysis

Kirchhoff’s Current Law (KCL) According to KCL, the sum of all the currents
entering a speciﬁc node is always zero. It can also be interpreted in the
following way:
The summation of all the currents entering a node is equal to the summation of all
the currents drawing out from that node.
Kirchhoff’s Voltage Law (KVL) According to KVL, the summation of all the
voltages in a closed loop is always zero.
These two formulas can be utilized to solve electrical circuits for determining
various parameters such as voltage, current, etc.
Consider the circuit in Fig. 8.15, where there are two loops, whose currents are
considered as IL1 and IL2. The resistances of the circuit are R1 ¼ 2 Ω, R2 ¼ 4 Ω,
and R3 ¼ 4 Ω. The voltage source, E ¼ 10 V. At node B, the current I1 is entering,
which gets divided into two parts—I2 and I3. We are interested to determine the
current I1, I2,and I3, and the voltage across the resistance R3, which is termed as VR3.
In the ﬁrst ABCD loop, we can apply KVL, and the equation will be as follows:
Fig. 8.13 Code—Equivalent resistance using delta-wye conversion
Fig. 8.14 Output—Equivalent resistance using delta-wye conversion
8.2
DC Circuit Analysis
159

E  VR1  VR2 ¼ 0
or,
E ¼ IL1R1 þ IL1R2  IL2R2
ð
Þ ¼ 2IL1 þ 4IL1  4IL2 ¼ 6IL1  4IL2
Hence,
6IL1  4IL2 ¼ 10 1
ð Þ
Here, VR1 and VR2 are the voltages across resistance R1 and R2, respectively.
For the second loop BEFC, applying KVL:
VR2 þ VR3 ¼ 0
or,
IL2R2  IL1R2
ð
Þ þ IL2R3 ¼ 0
Hence,
4IL1 þ 8IL2 ¼ 0 2
ð Þ
By solving (1) and (2), the determined values of IL1 and IL2 are IL1 ¼ 2.5 A and
IL1 ¼ 1.25 A.
From the ﬁgure, we can write the following equations:
I1 ¼ IL1 ¼ 2:5 A
Fig. 8.15 A resistive electrical circuit with two loops
160
8
Electrical Circuit Analysis

I2 ¼ IL2 ¼ 1:25 A
At node B, applying KCL, we can write the following equation:
I1 ¼ I2 þ I3
Hence,
Fig. 8.16 Code—Using KVL and KCL in a circuit
Fig. 8.17 Output—Using
KVL and KCL in a circuit
8.2
DC Circuit Analysis
161

I3 ¼ I1  I2 ¼ 1:25 A
The voltage across the resistance R3 can be determined by applying Ohm’s law as
follows:
VR3 ¼ I2  R3 ¼ 1:25  4 ¼ 5 V
The MATLAB implementation of the above solution of the circuit is given
below:
8.2.4.1
MATLAB Example 8.6: Circuit Problem
Using loop analysis, solve the circuit shown in Fig. 8.15, considering R1 ¼ 2 Ω,
R2 ¼ 4 Ω, R3 ¼ 4 Ω, and E ¼ 10 V, for determining:
(a) The loop currents in ABCD and BEFC loops
(b) The currents I1, I2, and I3
(c) The voltages across resistances R1, R2, and R3
The MATLAB code for this example is given in Fig. 8.16 with its output in
Fig. 8.17.
Output
8.2.5
Voltage Divider and Current Divider Laws
Voltage Divider Rule In a series circuit, the voltages are divided across all the
series-connected resistances. Consider the circuit in Fig. 8.18, where three resis-
tances R1, R2, and R3 are connected in series. Using the voltage divider rule, the
Fig. 8.18 An electrical
circuit with a voltage source
and series resistance
162
8
Electrical Circuit Analysis

voltages across each resistance can be determined using the following formulas in
Eqs. (8.11)–(8.13):
VR1 ¼
R1
R1 þ R2 þ R3  V
ð8:11Þ
VR2 ¼
R2
R1 þ R2 þ R3  V
ð8:12Þ
VR3 ¼
R3
R1 þ R2 þ R3  V
ð8:13Þ
It can be noted that the total voltage V is equal to the summation of VR1, VR2,and VR3.
8.2.5.1
MATLAB Example 8.7: Voltage Divider
Consider the circuit shown in Fig. 8.18, where R1 ¼ 2 Ω, R2 ¼ 4 Ω, R3 ¼ 8 Ω,
and E ¼ 24 V. Determine the voltage VR2 and VR3 using voltage divider rule.
The MATLAB code for this example is given in Fig. 8.19 with its output in
Fig. 8.20.
Output
Fig. 8.19 Code—Voltage divider rule
Fig. 8.20 Output—Voltage divider rule
8.2
DC Circuit Analysis
163

Current Divider Rule In a parallel circuit, the current is divided among all the
parallel resistive paths based on different resistances in each path. Consider the
circuit in Fig. 8.21, where two resistances R1 and R2 are connected in parallel. Using
the current divider rule, the current through each of these resistances can be
determined using the following formulas:
I1 ¼
R1
R1 þ R2  I
ð8:14Þ
I2 ¼
R2
R1 þ R2  I
ð8:15Þ
It is also to be noted that the total current, I, will be the summation of I1 and I2.
8.2.5.2
MATLAB Example 8.8: Current Divider
Consider the circuit in Fig. 8.21, where R1 ¼ 2 Ω, R2 ¼ 4 Ω, and I ¼ 16 A. Determine
the currents I1 and I2 ﬂowing through the resistances R1 and R2, respectively, using
the current divider rule. The MATLAB code for this example is given in Fig. 8.22
with its output in Fig. 8.23.
Output
8.2.6
Thevenin’s Theorem
According to Thevenin’s theorem, any linear circuit can be represented with an
equivalent series circuit, incorporating an open-circuit voltage in the terminal, Vth,
and an input equivalent resistance, which is determined considering all the voltage
Fig. 8.21 An electrical
circuit with a current source
and parallel resistance
164
8
Electrical Circuit Analysis

sources replaced by short circuit, and the current sources replaced by open circuit. A
simple illustration is provided in Fig. 8.24.
Here, Fig. 8.24a is the original circuit. For determining its Thevenin’s circuit,
Thevenin’s voltage Vth and Thevenin’s equivalent resistance Rth need to be deter-
mined. In Fig. 8.24b, the circuit representation for determining Vth is shown, from
where it can be observed that the voltage across the resistance R2 is equal to Vth. By
applying the voltage divider rule, the value of Vth can be determined as follows:
Vth ¼
R2
R1 þ R2  V
ð8:16Þ
The equivalent resistance Rth can be determined from Fig. 8.24c, where the
voltage source is replaced by a short circuit. If there was a current source, it would
be replaced by an open circuit. From the ﬁgure, Thevenin’s equivalent resistance can
be calculated as follows:
Rth ¼
R1
R2


þ R3 ¼ R1  R2
R1 þ R2 þ R3
ð8:17Þ
The ﬁnal equivalent of Thevenin’s circuit is demonstrated in Fig. 8.24d.
Fig. 8.23 Output—Current divider rule
Fig. 8.22 Code—Current divider rule
8.2
DC Circuit Analysis
165

8.2.6.1
MATLAB Example 8.9: Thevenin’s Theorem
Consider the circuit shown in Fig. 8.24a, where the parameters are R1 ¼ 4 Ω,
R2 ¼ 2 Ω, R3 ¼ 3 Ω, RL ¼ 5 Ω, and V ¼ 10 V. Using Thevenin’s theorem, ﬁnd
the following parameters:
(a) Thevenin’s voltage, Vth
(b) Thevenin’s equivalent resistance, Rth
(c) The current ﬂowing through the load resistance, RL
The MATLAB code for this example is given in Fig. 8.25 with its output in
Fig. 8.26.
Output
Fig. 8.24 Application of Thevenin’s theorem to simplify an electrical circuit
166
8
Electrical Circuit Analysis

8.2.7
Maximum Power Transfer Theorem
According to the maximum power transfer theorem, the maximum power can be
achieved from a circuit if its load resistance matches with the Thevenin’s equivalent
resistance.
Consider the following Thevenin’s equivalent circuit, where the load resistance is
RL and the Thevenin’s voltage and equivalent resistance are Vth and Rth. According
to this theorem, maximum power will be achieved when RL ¼ Rth; and the maximum
power will be calculated using Eq. (8.18):
Pmax ¼ I2RL ¼
Vth
Rth þ RL

2
∙RL
ð8:18Þ
8.2.7.1
MATLAB Example 8.10: Maximum Power Transfer Theorem
Consider the circuit shown in Fig. 8.27, where the parameters are Rth ¼ 5 Ω
and Vth ¼ 10 V. Vary the load resistance starting from 1 to 12 ohms, and determine
the output power for all scenarios to prove the maximum power transfer theorem;
Fig. 8.25 Code—Thevenin’s theorem
Fig. 8.26 Output—Thevenin’s theorem
8.2
DC Circuit Analysis
167

also determine the maximum output power. The MATLAB code for this example is
given in Fig. 8.28 with its output in Figs. 8.29 and 8.30.
Fig. 8.27 Thevenin’s
equivalent circuit
Fig. 8.28 Code—Maximum power transfer theorem
Fig. 8.29 Output—
Maximum power transfer
theorem
168
8
Electrical Circuit Analysis

Output
Here, from the ﬁgure, it can be observed that the highest maximum power can be
attained only when the load resistance is equal to Thevenin’s equivalent resistance.
8.3
AC Circuit Analysis
An AC circuit can be referred to those circuits having sinusoid inputs as voltage or
current source. A sinusoid can be either a sine or cosine signal. The general
representation of an AC voltage and current source can be deﬁned as follows:
v tð Þ ¼ VM sin ωt
ð
Þ
ð8:19Þ
i tð Þ ¼ IM sin ωt
ð
Þ
ð8:20Þ
Here, VM and IM are the magnitude of voltage and current signal, respectively.
Both sources are a function of time; therefore, after a certain time, the voltage and
current may become both positive and negative. ω indicates the angular frequency in
radian.
Fig. 8.30 Graphical output—Maximum power transfer theorem
8.3
AC Circuit Analysis
169

8.3.1
Some Terminologies
Some terminologies on the aspect of AC voltage are deﬁned below:
Peak Value The maximum value of a sinusoid from the zero level is regarded as the
peak value. Vp represents the peak voltage, which is the maximum positive value of
the voltage.
RMS Value RMS value implies the root mean square value of the amplitude of a
sinusoid signal. It can also be regarded as the effective value of an AC circuit. The
RMS value of voltage plays an important role while calculating different terms of an
AC circuit. The RMS value of an AC voltage can be calculated using the following
formula:
RMS Voltage, VRMS ¼ 1ﬃﬃﬃ
2
p  Vp
ð8:21Þ
Average Value The average value indicates the area under the sinusoid signal. The
average value of an AC voltage signal can also be calculated from its peak value by
using the following formula:
Average Voltage, Vavg ¼ 2
π  Vp
ð8:22Þ
Instantaneous Value Instantaneous value represents the exact value of a sinusoid
at a speciﬁc time. As AC voltage is a function of time, by providing a speciﬁc time,
AC voltage at that time can be determined.
Instantaneous Voltage, Vinst tð Þ ¼ Vp sin 2πft
ð
Þ
ð8:23Þ
Here, t is the time at which the instantaneous voltage can be calculated.f indicates
the frequency of the input voltage.
8.3.1.1
MATLAB Example 8.11: AC Circuit Terminologies
The input voltage of an AC circuit is v(t) ¼ 2 sin (2πft), where f ¼ 60 Hz. Answer the
following questions using MATLAB:
(a) Plot the input voltage in MATLAB for t ¼ 0:0.1.
(b) Find the values of peak voltage, peak-to-peak voltage, RMS voltage, and
average voltage.
(c) Find the instantaneous voltage at t ¼ 0.02.
The MATLAB code for this example is given in Fig. 8.31 with its output in
Figs. 8.32 and 8.33.
170
8
Electrical Circuit Analysis

Fig. 8.31 Code—Determination of AC circuit voltage parameters
Fig. 8.32 Output—Determination of AC circuit voltage parameters
8.3
AC Circuit Analysis
171

Output
8.3.2
Impedance
Impedance signiﬁes the total impediment of the ﬂow of charge in an AC circuit. The
impedance can be divided into two parts—resistance and reactance. The resistance is
a zero-frequency component; on the other hand, reactance is dependent on fre-
quency. The general expression for overall impedance can be written as follows:
Impedance, Z ¼ R þ jX
ð8:24Þ
Here the real part is the resistance, and the imaginary part is the reactance. Again,
the reactance can be categorized into two parts—inductive reactance, (XL), and
capacitive reactance, (XC). With the inclusion of both of these reactances with
resistance in series, the formula of impedance can be rewritten as follows:
Fig. 8.33 Graphical output—Determination of AC circuit voltage parameters
172
8
Electrical Circuit Analysis

Z ¼ R þ j XL  XC
ð
Þ ¼ R þ j ωL  1
ωC


ð8:25Þ
Therefore,
Z
j j∠θ ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
R2 þ
ωL  1
ωC

2
r
∠ωL  1
ωC

	
R
ð8:26Þ
Here, L is the inductance, C is the capacitance, and ω represents the angular
frequency. From the formula, it can also be observed that XL ¼ ωL and XC ¼
1
ωC. An
inductive circuit is called a lagging circuit, as the current through the reactance lags
the voltage across it. Conversely, a capacitive circuit has a leading current with
respect to voltage. A pure inductive circuit lags the current by 90
, whereas a
purely capacitive circuit leads the current by +90
. If the circuit has both inductive
and capacitive reactance, the nature of the circuit can be determined as follows:
if (XL  XC) > 0
Inductive reactance;
Power factor lagging;
elseif (XL  XC) < 0
Capacitive reactance;
Power factor leading;
else
Resistive
Power factor Unity;
end
Based on the above discussion, an impedance triangle can be drawn (Fig. 8.34),
which shows the relationship between resistance and reactance more clearly. In an
impedance triangle, the horizontal line indicates the resistance, as it is a zero-
frequency component. The reactance indicates the perpendicular line, as they shift
the voltage or current by +90
 or 90
. An upward perpendicular line refers to an
overall inductive reactance, while a downward perpendicular line depicts an overall
Fig. 8.34 The impedance
triangle
8.3
AC Circuit Analysis
173

capacitive reactance. The hypotenuse of the triangle demonstrates the magnitude of
the overall impedance, and the angle between the hypotenuse and the horizontal line
refers to the phase angle of impedance, which is usually regarded as θ. The cosine of
this angle introduces a crucial term in the AC circuit, which is called power factor.
8.3.2.1
MATLAB Example 8.12: Impedance
Consider a series RLC circuit with R ¼ 10 ohm, L ¼ 0.02 H, and C ¼ 0.05 F. If the
frequency is 60 Hz, determine:
Fig. 8.36 Output—Impedance in an RLC circuit
Fig. 8.35 Code—Impedance in an RLC circuit
174
8
Electrical Circuit Analysis

(a) Impedance of the circuit
(b) Power factor
The MATLAB code for this example is given in Fig. 8.35 with its output in
Fig. 8.36.
Output
8.3.3
Power Triangle
In an AC circuit, the power can also be divided into two components—real power
(P) and reactive power (Q). The real power is the resistive power, which does not
depend on frequency. On the other hand, reactive power is the frequency-dependent
part. The vector summation of these two components is called the apparent power
(S). These three components can be represented using the power triangle (Fig. 8.37),
where the horizontal line represents the real power, P; the perpendicular line
indicates the reactive power, Q; and the hypotenuse is the apparent power, S,
which can be represented using the following formula:
S ¼ P þ jQ
ð8:27Þ
Hence,
j S j ∠θ ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
P2 þ Q2
q
∠Q
P
ð8:28Þ
For the inductive circuit, the reactive power will be indicated by upward perpen-
dicular line; and for the capacitive circuit, the reactive power will be represented by a
downward perpendicular line. The angle between the horizontal line and hypotenuse
is called the power angle (θ), cosine of which is also referred to as the power factor.
Fig. 8.37 The power
triangle
8.3
AC Circuit Analysis
175

Therefore, both in the impedance and power triangle, this angle corresponds to the
same entity.
Q ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
Q2
L þ Q2
C
q
ð8:29Þ
if (QL  QC) > 0
Inductive reactance;
Power factor lagging;
elseif (QL  QC) < 0
Capacitive reactance;
Power factor leading;
else
Resistive
Power factor Unity;
end
8.3.3.1
MATLAB Example 8.13: Power Triangle
Consider a series RLC circuit with P ¼ 10 W and Q ¼ 5 Var. Determine:
(a) Apparent power, S
(b) Power factor, PF
The MATLAB code for this example is given in Fig. 8.38 with its output in
Fig. 8.39.
Output
8.3.4
Three-Phase AC Circuit Analysis
In a three-phase circuit, the conﬁguration can either be in wye or delta conﬁguration,
based on which the properties change. To understand the relationship among
different parameters in both wye and delta connection, we ﬁrst need to categorize
the circuit into two parts based on the nature of the load, which are balanced load and
unbalanced load. In an unbalanced load, all the loads are not equally distributed
among three phases, whereas in a balanced load condition, all the loads are
176
8
Electrical Circuit Analysis

Fig. 8.38 Code—Determination of the parameters of the power triangle
8.3
AC Circuit Analysis
177

Fig. 8.39 Output—Determination of the parameters of the power triangle
178
8
Electrical Circuit Analysis

distributed evenly among the phases. In a balanced system, all the voltages, or
currents, in three phases are in 120
 phase difference from each other. Based on
the nature of the order of the sequence of phase voltages, two-phase sequences are
available—“abc” sequence and “acb” sequence. The phase sequence implies the
order of sequence based on which the individual phase voltage or current reaches
their peak values. A simple representation of these two types of phase sequences is
given in Fig. 8.40.
8.3.4.1
Delta-Connected Unbalanced Load
A delta-connected unbalanced load is shown in Fig. 8.41, where the impedances are
of different values in each phase to make the system unbalanced.
Fig. 8.40 abc and acb phase sequence in three-phase systems
Fig. 8.41 A delta
connected unbalanced
system
8.3
AC Circuit Analysis
179

The relevant parameters for a delta-connected unbalanced load system are
enlisted in Table 8.1 in accordance with Fig. 8.41.
For a delta-connected unbalanced system, the parameters can be related with each
other by the formulas as mentioned in Table 8.2.
8.3.4.2
MATLAB Example 8.14: Delta-Connected Unbalanced Load
Consider a system shown in Fig. 8.41 with the following parameters:
VAB ¼ 120∠0
 V
VBC ¼ 110∠120
 V
VCA ¼ 150∠240
 V
Z1 ¼ 10∠10

Z2 ¼ 15∠ 25

Z3 ¼ 20∠ 10

Determine:
(a) Phase currents IAB, IBC, and ICA
(b) Line currents IA, IB, and IC.
The MATLAB code for this example is given in Fig. 8.42 with its output in
Fig. 8.43.
Output
Table 8.1 Parameters in a delta-connected unbalanced load system
Line-to-line voltage
Phase voltage
Line current
Phase current
VAB
Va
IA
IAB
VBC
Vb
IB
IBC
VCA
Vc
IC
ICA
Table 8.2 Relationship
between the parameters in a
delta-connected unbalanced
load system
Line-to-line voltage
Phase current
Line current
VAB ¼ Va  Vb
VBC ¼ Vb  Vc
VCA ¼ Vc  Va
IAB ¼ VAB
Z1
IBC ¼ VBC
Z2
ICA ¼ VCA
Z3
IA ¼ IAB  ICA
IB ¼ IBC  IAB
IC ¼ ICA  IBC
180
8
Electrical Circuit Analysis

Fig. 8.42 Code—Delta connected unbalanced load
8.3
AC Circuit Analysis
181

8.3.4.3
Delta-Connected Balanced Load
A delta-connected balanced load is shown in Fig. 8.44, where the impedances are
equally distributed in each phase to make the system balanced. In a balanced delta
system, the magnitudes of the input line to line to voltages and phase voltages are
equal.
The relevant parameters of a delta-connected balanced system are enlisted in
Table 8.3.
Fig. 8.43 Output—Delta connected unbalanced load
Table 8.3 Parameters in a delta-connected balanced load system
Line-to-line voltage
Phase voltage
Line current
Phase current
VAB
Va
IA
IAB
VBC
Vb
IB
IBC
VCA
Vc
IC
ICA
Fig. 8.44 A delta
connected unbalanced
system
182
8
Electrical Circuit Analysis

Table 8.4 Relationship between the parameters in a delta-connected balanced load system
Line-to-line voltage
Phase current
Line current
VAB ¼ Va  Vb
VBC ¼ Vb  Vc
VCA ¼ Vc  Va
jVAB j ¼ j VBC j ¼ j VCA j ¼ VL
Therefore, considering acb sequence,
VAB ¼ VL ∠0

VBC ¼ VL ∠+ 120

VCA ¼ VL ∠ 120

IAB ¼ VAB
Z
IBC ¼ VBC
Z
ICA ¼ VCA
Z
jIAB j ¼ j IBC j ¼ j ICA j ¼ IP
Therefore, considering acb sequence,
IAB ¼ IP ∠0

IBC ¼ IP ∠+ 120

ICA ¼ IP ∠ 120

IA ¼ IAB  ICA
¼IP ∠0
  IP ∠ 120

¼IP(1 ∠0
  1 ∠ 120
)
¼
ﬃﬃﬃ
3
p
IP∠30

IB ¼ IBC  IAB
¼IP ∠+ 120
  IP ∠0

¼IP(1 ∠120
  1 ∠0
)
¼
ﬃﬃﬃ
3
p
IP∠150

IC ¼ ICA  IBC
¼IP ∠ 120
  IP ∠+ 120
¼IP(1 ∠120
  1 ∠0
)
¼
ﬃﬃﬃ
3
p
IP∠ 90

Therefore,
IA
j
j ¼ IB
j
j ¼ IC
j
j ¼
ﬃﬃﬃ
3
p
IP ¼ IL
8.3
AC Circuit Analysis
183

The relationship among the parameters for a delta-connected balanced load
system can be summarized as shown in Table 8.4.
8.3.4.4
MATLAB Example 8.15: Delta-Connected Balanced Load
Consider a system shown in Fig. 8.44 with the following parameters:
Fig. 8.45 Code—Delta connected balanced load
184
8
Electrical Circuit Analysis

VAB ¼ 120∠0
 V
VBC ¼ 110∠120
 V
VCA ¼ 150∠240
 V
Z ¼ 10∠10

Determine:
(a) Phase currents IAB, IBC, and ICA
(b) Line currents IA, IB, and IC
The MATLAB code for this example is given in Fig. 8.45 with its output in
Fig. 8.46.
Output
From the output, we can observe that the magnitude of the line current in each
phase is equivalent to the square root of three multiplied with the phase current in
each phase.
8.3.4.5
Wye-Connected Four-Wire Unbalanced Load
A wye-connected four-wire unbalanced load is shown in Fig. 8.47, where the
impedances are different in each phase to make the system unbalanced. In addition,
the common point is connected to a neutral, which explains the reason for naming it a
four-wire system.
The relevant parameters of a wye-connected four-wire unbalanced system are
enlisted in Table 8.5.
Fig. 8.46 Output—Delta connected balanced load
8.3
AC Circuit Analysis
185

The relationship among the parameters for a wye-connected four wire unbalanced
load system can be summarized as shown in Table 8.6.
8.3.4.6
MATLAB Example 8.16: Wye-Connected Four-Wire
Unbalanced Load
Consider a system shown in Fig. 8.47 with the following parameters:
VAN ¼ 120∠10
 V
VBN ¼ 110∠150
 V
Fig. 8.47 A wye connected
four wire unbalanced system
Table 8.5 Parameters in a wye-connected four-wire unbalanced load system
Line-to-line voltage/line
voltage
Line to neutral voltage/phase
voltage
Line
current
Phase
current
VAB
Va ¼ VAN
IA
IAN
VBC
Vb ¼ VBN
IB
IBN
VCA
Vc ¼ VCN
IC
ICN
Table 8.6 Relationship
between the parameters in a
wye-connected four-wire
unbalanced load system
Line-to-line voltage
Phase current
Line current
VAB ¼ VAN  VBN
VBC ¼ VBN  VCN
VCA ¼ VCN  VAN
IAN ¼ VAN
Z1
IBN ¼ VBN
Z2
ICN ¼ VCN
Z3
IA ¼ IAN
IB ¼ IBN
IC ¼ ICN
186
8
Electrical Circuit Analysis

Fig. 8.48 Code—A wye connected four wire unbalanced load
8.3
AC Circuit Analysis
187

VCN ¼ 150∠ 50
 V
Z1 ¼ 10∠10

Z2 ¼ 15∠ 25

Z3 ¼ 20∠ 10

Determine:
(a) Line-to-line voltages VAB, VBC, and VCA
(b) Phase currents IAN, IBN, and ICN
(c) Line currents IA, IB, and IC
The MATLAB code for this example is given in Fig. 8.48 with its output in
Fig. 8.49.
Output
8.3.4.7
Wye-Connected Four-Wire Balanced Load
A wye-connected four-wire balanced load is shown in Fig. 8.50, where the imped-
ances are distributed evenly in each phase to make the system balanced. In addition,
the common point is connected to a neutral, which explains the reason for naming it a
four-wire system.
Fig. 8.49 Output – A wye connected four wire unbalanced load
188
8
Electrical Circuit Analysis

The relevant parameters of a wye-connected four-wire balanced load system are
enlisted in Table 8.7.
Fig. 8.50 A wye connected
four wire balanced system
Table 8.7 Parameters in a wye-connected four-wire balanced load system
Line-to-line voltage
Line to neutral voltage/phase voltage
Line current
Phase current
VAB
Va ¼ VAN
IA
IAN
VBC
Vb ¼ VBN
IB
IBN
VCA
Vc ¼ VCN
IC
ICN
Table 8.8 Relationship between the parameters in a wye-connected four-wire balanced load
system
Phase voltage
Line-to-line voltage
Phase current and line
current
VAN ¼ IAN  Z
VBN ¼ IBN  Z
VCN ¼ ICN  Z
jVAN j ¼ |VBN| ¼ |
VCN| ¼ VP
Considering acb sequence,
VAB ¼ VAN  VBN
¼VP ∠0
  VP ∠120

¼VP(1 ∠0
  1 ∠120

¼
ﬃﬃﬃ
3
p
VP∠ 30

VBC ¼ VBN  VCN
¼VP ∠120
  VP ∠ 120

¼VP(1 ∠120
  1 ∠ 120

¼
ﬃﬃﬃ
3
p
VP∠90

VCA ¼ VCN  VAN
¼VP ∠ 120
  VP ∠0

¼VP(1 ∠ 120
  1 ∠0

¼
ﬃﬃﬃ
3
p
VP∠ 150

Therefore,
j VAB ¼ jVBC
j
j ¼j VCA j¼
ﬃﬃﬃ
3
p
VP ¼ VL
IAN ¼ VAN
Z ¼ IA
IBN ¼ VBN
Z ¼ IB
ICN ¼ VCN
Z ¼ IC
IAN
j
j ¼ IBN
j
j ¼j ICN j¼
VP
Z




8.3
AC Circuit Analysis
189

The relationship among the parameters for a wye-connected four-wire balanced
load system can be summarized as shown in Table 8.8.
Fig. 8.51 Code—A wye connected four wire balanced load
190
8
Electrical Circuit Analysis

8.3.4.8
MATLAB Example 8.17: Wye-Connected Four-Wire
Balanced Load
Consider a system shown in Fig. 8.50 with the following parameters:
VAN ¼ 110∠10
 V
VBN ¼ 110∠150
 V
VCN ¼ 110∠ 50
 V
Z ¼ 10∠10

Determine:
(a) Line-to-line voltages VAB, VBC, and VCA
(b) Phase currents IAN, IBN, and ICN
(c) Line currents IA, IB, and IC.
The MATLAB code for this example is given in Fig. 8.51 with its output in
Fig. 8.52.
Output
Here, from the output, the phase and line currents of a wye-connected four-wire
balanced system are equal.
Fig. 8.52 Output—A wye connected four wire balanced load
8.3
AC Circuit Analysis
191

8.3.4.9
Wye-Connected Three-Wire Unbalanced Load
A wye-connected three-wire unbalanced load system is shown in Fig. 8.53, where
the impedances are different in each phase to make the system unbalanced. In
addition, the common point is not connected to a neutral; therefore, it will be
regarded as a common point, not a neutral point.
The relevant parameters of a wye-connected three-wire balanced load system are
enlisted in Table 8.9.
Fig. 8.53 A wye connected three wire unbalanced system
Table 8.9 Parameters in a wye-connected three-wire balanced load system
Line-to-line voltage
Phase voltage
Line current
Phase current
VAB
Va
IA
Iao
VBC
Vb
IB
Ibo
VCA
Vc
IC
Ico
Table 8.10 Relationship between the parameters in a wye-connected three-wire balanced load
system
Line to common point voltage
Line-to-line voltage
Line current and phase current
Vao ¼ IA  Z1
Vbo ¼ IB  Z2
Vco ¼ IC  Z3
VAB ¼ Vao  Vbo
VBC ¼ Vbo  Vco
VCA ¼ Vco  Vao
IA ¼ Iao
IB ¼ Ibo
IC ¼ Ico
192
8
Electrical Circuit Analysis

The relationship among the parameters for a wye-connected three-wire balanced
load system can be summarized as shown in Table 8.10.
8.3.4.10
MATLAB Example 8.18: Wye-Connected Three-Wire
Unbalanced Load
Consider a system shown in Fig. 8.53 with the following parameters:
Fig. 8.54 Code—A wye connected three wire unbalanced load
8.3
AC Circuit Analysis
193

Vao ¼ 120∠10
 V
Vbo ¼ 110∠150
 V
Vco ¼ 150∠ 50
 V
Z1 ¼ 10∠10

Z2 ¼ 15∠ 25

Z3 ¼ 20∠ 10

Determine:
(a) Line-to-line voltages VAB, VBC, and VCA
(b) Line currents IA, IB, and IC
The MATLAB code for this example is given in Fig. 8.54 with its output in
Fig. 8.55.
Output
8.3.4.11
Wye-Connected Three-Wire Balanced Load
A wye-connected three-wire balanced load system is shown in Fig. 8.56, where the
impedances are equal in each phase to make the system balanced. In addition, the
Fig. 8.55 Output—A wye connected three wire unbalanced load
194
8
Electrical Circuit Analysis

common point is not connected to a neutral; therefore, it will be regarded as a
common point, not a neutral point.
All the relevant parameters in this system are summarized in Table 8.11 in
accordance with Fig. 8.56.
The relationships to determine each parameter are enlisted in Table 8.12 to make
the system more understandable.
Fig. 8.56 A wye connected three wire balanced system
Table 8.11 Parameters in a wye-connected three-wire balanced load system
Line-to-line voltage
Phase voltage
Line current
Phase current
VAB
Va
IA
Iao
VBC
Vb
IB
Ibo
VCA
Vc
IC
Ico
Table 8.12 Relationship between the parameters in a wye-connected three-wire balanced load
system
Line to common point
voltage
Line-to-line voltage
Line current and phase
current
Vao ¼ IA  Z
Vbo ¼ IB  Z
Vco ¼ IC  Z
|Vao| ¼ j Vbo j ¼ |
Vco| ¼ VP
VAB ¼ Vao  Vbo
VBC ¼ Vbo  Vco
VCA ¼ Vco  Vao
VAB
j
j ¼j VBC j¼ VCA
j
j ¼ VL ¼
ﬃﬃﬃ
3
p
VP
IA ¼ Iao
IB ¼ Ibo
IC ¼ Ico
8.3
AC Circuit Analysis
195

8.3.4.12
MATLAB Example 8.19: Wye-Connected Three-Wire
Balanced Load
Consider a system shown in Fig. 8.56 with the following parameters:
Vao ¼ 120∠0
 V
Fig. 8.57 Code—A wye connected three wire balanced load
196
8
Electrical Circuit Analysis

Vbo ¼ 110∠120
 V
Vco ¼ 150∠240
 V
Z ¼ 10∠10

Determine:
(a) Line-to-line voltages VAB, VBC, and VCA
(b) Line currents IA, IB, and IC.
The MATLAB code for this example is given in Fig. 8.57 with its output in
Fig. 8.58.
Output
The magnitude of each phase voltage is 120 V. By multiplying this value with
ﬃﬃﬃ
3
p
provides the magnitude of each line-to-line voltages, which is 207.846 V. The
magnitudes of the line currents are also similar in a wye-connected three-wire
balanced system that can be realized from the above output as well.
8.4
Operational Ampliﬁer
An operational ampliﬁer is an active device that can amplify any input signals; can
perform mathematical operations such as addition, multiplication, differentiation,
and integration; and can be utilized for ﬁltering purposes as well. The block diagram
of an operational ampliﬁer (Op-amp) is provided in Fig. 8.59. A standard Op-amp
has ﬁve important ports, where port 1 and port 2 signify the inverting and the
Fig. 8.58 Output—A wye connected three wire balanced load
8.4
Operational Ampliﬁer
197

non-inverting input signals; and port 5 is for the output signal. In port 3 and port
4, the positive and negative voltage connection is provided.
8.4.1
Inverting Ampliﬁer
In an inverting ampliﬁer, the gain of the ampliﬁer is negative. The gain of an
ampliﬁer is the ratio of output to input. A conﬁguration of an inverting ampliﬁer is
given in Fig. 8.60, where a positive voltage source is connected with the negative
input port of an Op-amp, and the positive input port is grounded.
Vout ¼  R2
R1 ∙Vin
ð8:30Þ
Fig. 8.59 Pin diagram of an
operational ampliﬁer
Fig. 8.60 Circuit diagram
of an inverting ampliﬁer
198
8
Electrical Circuit Analysis

8.4.1.1
MATLAB Example 8.20: Inverting Ampliﬁer
Consider an inverting ampliﬁer as shown in Fig. 8.60 with 40 V input and R1 ¼ 4Ω,
R2 ¼ 2Ω. Determine the gain and the output voltage of the ampliﬁer.
The MATLAB code for this example is given in Fig. 8.61 with its output in
Fig. 8.62.
Output
8.4.2
Non-inverting Ampliﬁer
In a non-inverting ampliﬁer, the gain of the ampliﬁer is positive. The gain of an
ampliﬁer is the ratio of output to input. A conﬁguration of a non-inverting ampliﬁer
is given in Fig. 8.63, where a positive voltage source is connected with the positive
input port of an Op-amp, and the negative input port is grounded.
Vout ¼
1 þ R2
R1


∙Vin
ð8:31Þ
Fig. 8.61 Code—Inverting ampliﬁer
Fig. 8.62 Output—
Inverting ampliﬁer
8.4
Operational Ampliﬁer
199

8.4.2.1
MATLAB Example 8.21: Non-inverting Ampliﬁer
Consider a non-inverting ampliﬁer as shown in Fig. 8.63 with 40 V input and
R1 ¼ 4Ω, R2 ¼ 2Ω. Determine the gain and the output voltage of the ampliﬁer.
The MATLAB code for this example is given in Fig. 8.64 with its output in
Fig. 8.65.
Output
Fig. 8.63 Circuit diagram
of a non-inverting ampliﬁer
Fig. 8.64 Code—Non-inverting ampliﬁer
Fig. 8.65 Output—Non-
inverting ampliﬁer
200
8
Electrical Circuit Analysis

8.4.3
Follower Circuit
In a follower circuit, the gain is always unity. The feedback resistance is short-
circuited, and the input impedance is open-circuited. Therefore, the input impedance
of a follower circuit is inﬁnity, or very high; and the output impedance is zero, or
very small. A conﬁguration of the follower circuit is given in Fig. 8.66.
8.4.3.1
MATLAB Example 8.22: Follower Circuit
Consider the circuit in Fig. 8.67, where the output of an inverting ampliﬁer is
connected as an input of a follower circuit. Determine the values of V1 and Vout
from the circuit.
The MATLAB code for this example is given in Fig. 8.68 with its output in
Fig. 8.69.
Fig. 8.66 Circuit diagram
of a follower circuit
Fig. 8.67 A follower circuit
8.4
Operational Ampliﬁer
201

Output
8.4.4
Differentiator Circuit
A differentiator circuit is shown in Fig. 8.70. For a given signal input Vin(t), the
output of the Op-amp will be a differentiation of the input with the multiplication of
resistance and capacitance value. As it is an inverting ampliﬁer, the output will be
inverted. The output of a differentiator circuit can be deﬁned using the following
formula:
Vout tð Þ ¼ RC dVin
dt
ð8:32Þ
The current through the resistance R and the capacitor C can be represented by the
following formula:
IR ¼ Vout
R
ð8:33Þ
IC ¼ C dVin
dt
ð8:34Þ
Fig. 8.68 Code—Follower circuit
Fig. 8.69 Output—
Follower circuit
202
8
Electrical Circuit Analysis

8.4.4.1
MATLAB Example 8.23: Differentiator Circuit
Consider the circuit in Fig. 8.70, where R ¼ 5Ω and C ¼ 0.5 F. If the input signal is
v(t) ¼ 2 sin (t), determine:
(a) The output signal, vout(t)
(b) The output of the circuit at t ¼ 0.1 s
(c) IR and IC at t ¼ 0.1 s
The MATLAB code for this example is given in Fig. 8.71 with its output in
Fig. 8.72.
Fig. 8.70 Circuit diagram
of a differentiator circuit
Fig. 8.71 Code—Differentiator circuit
8.4
Operational Ampliﬁer
203

Output
8.4.5
Integrator Circuit
An integrator circuit is shown in Fig. 8.73. For a given signal input Vin(t), the output
of the Op-amp will be an integration of the input with the multiplication of some
certain value. As it is an inverting ampliﬁer, the output will be inverted. The output
of a differentiator circuit can be deﬁned using Eq. (8.35):
Vout tð Þ ¼  1
RC
Z
Vin tð Þdt
ð8:35Þ
The current through the resistance R and the capacitor C can be represented by the
following formula:
IR ¼ Vout
R
ð8:36Þ
IC ¼ C dVin
dt
ð8:37Þ
8.4.5.1
MATLAB Example 8.24: Integrator Circuit
Consider the integrator circuit in Fig. 8.73, where R ¼ 5Ω and C ¼ 0.5 F. If the input
signal is v(t) ¼  5 cos (t), determine:
Fig. 8.72 Output—Differentiator circuit
204
8
Electrical Circuit Analysis

(a) The output signal, vout(t)
(b) The output of the circuit at t ¼ 0.1 s
(c) IR and IC at t ¼ 0.1 s
The MATLAB code for this example is given in Fig. 8.74 with its output in
Fig. 8.75.
Fig. 8.73 Circuit diagram
of an integrator circuit
Fig. 8.74 Code—Integrator circuit
8.4
Operational Ampliﬁer
205

Output
8.5
Transistor Circuit
A transistor is a semiconductor-based device that has two pn junctions. By
sandwiching either a n-type with two p-types or a p-type with two n-types, a
transistor is made. Therefore, a transistor has three terminals and three sections
named emitter, base, and collector. The two types of transistors based on the pn
junction, termed as p  n  p transistor and n  p  n transistors, are shown in
Fig. 8.76.
In a transistor-based circuit, the connections can be made in three ways:
•
Common emitter (CE) connection
•
Common base (CB) connection
•
Common collector (CC) connection
The circuit conﬁgurations of these three connection types are illustrated in
Fig. 8.77.
In any transistor circuit, there is a relation of current among emitter, base, and
collector currents that can be deﬁned as follows:
IE ¼ IB þ IC
ð8:38Þ
Here, IE, IB, and IC are the emitter current, base current, and collector current,
respectively.
Fig. 8.75 Output—Integrator circuit
206
8
Electrical Circuit Analysis

Two common terminologies used in transistor circuits are as follows:
Current ampliﬁcation factor, α
The current ampliﬁcation factor is the ratio of output current to input current,
generally regarded as α. For a transistor with a common base connection, the current
ampliﬁcation factor can be written as:
α ¼ Collector current
Emitter current ¼ IC
IE
ð8:39Þ
Base current ampliﬁcation, β
The base current ampliﬁcation factor is the ratio of output current to base current,
generally regarded as β. For a transistor with a common emitter connection, the
current ampliﬁcation factor can be written as:
Fig. 8.76 p-n-p and n-p-n transistor
Fig. 8.77 Three conﬁgurations of a transistor
8.5
Transistor Circuit
207

β ¼ Collector current
Base current
¼ IC
IB
ð8:40Þ
8.5.1
MATLAB Example 8.25: Transistor Circuit
Consider a transistor with a common base connection. If the emitter current,
IE ¼ 10 mA,and α ¼ 0.8, determine the collector current and the base current.
The MATLAB code for this example is given in Fig. 8.78 with its output in
Fig. 8.79.
Output
8.6
Conclusion
In this chapter, the readers will be able to learn how to utilize MATLAB to solve
different electrical circuit problems. The chapter describes some of the basic theo-
rems of electrical circuits along with their implementations in MATLAB that are
useful to solve different circuit problems. In DC circuit analysis, Ohm’s law,
Kirchhoff’s theorem, Thevenin’s theorem, and the maximum power transfer theo-
rem are presented along with the formulas of voltage and current divider rules. The
methods of determining equivalent resistance and delta-wye conversions are also
Fig. 8.78 Code—Transistor
Fig. 8.79 Output—
Transistor
208
8
Electrical Circuit Analysis

presented in this section. All of these topics are explained with necessary examples
that are shown by implementing in MATLAB individually. In AC circuit analysis,
deﬁnitions of some of the relevant terminologies, impedance, and power triangle are
covered. In addition, three-phase AC circuit analysis is also added in this section.
Due to the vast applications of Op-amp and transistor devices, both of their studies
are included in this chapter. In Op-amp, different categories and their applications
are demonstrated using MATLAB. However, in transistor circuits, this chapter
provides an overview of the different types of transistors and their structures with
limited details. For electrical engineers, the contents of this chapter will be very
essential to create fundamental knowledge on circuit analysis.
Exercise 8
1. Using MATLAB, determine the equivalent resistance of the following circuit in
Fig. 8.80. Hence, verify Ohm’s law if the voltage varies from 1 V to 12 V.
The graph should look as shown in Fig. 8.81.
2. Consider the following circuit in Fig. 8.82, where R1 ¼ 0.2 ohm, R2 ¼ 0.5 ohm,
R3 ¼ 1 ohm, R4 ¼ 0.8 ohm, and R5 ¼ 1.44 ohm.
(a) Determine the equivalent resistance of the circuit using MATLAB.
(b) Determine the current using MATLAB if the voltage is 6 V.
3. (a) Create a function voltdiv() which will calculate the divided voltages in the
following circuit in Fig. 8.83 given the values of the resistances (R1, R2, and R3)
and voltage, V. Test the function with R1¼ 2 ohm, R2¼4 ohm, R3¼8 ohm, and
V ¼ 24 V.
Fig. 8.80 A resistive
electrical circuit
Exercise 8
209

Fig. 8.81 Expected graphical output for Question 1
Fig. 8.82 A delta
connected resistive
electrical circuit
Fig. 8.83 An electrical
circuit with three resistors in
series
210
8
Electrical Circuit Analysis

(b) Create a function curdiv() which will calculate the divided currents in the
following circuit in Fig. 8.84 given the values of the resistances (R1 and R2) and
current, I. Test the function with R1¼ 2 ohm, R2¼4 ohm, and I ¼ 8A.
4. In the following circuit in Fig. 8.85, R1 ¼ 4 ohm, R2 ¼ 9 ohm, and load resistance,
RL ¼ 5 ohm. The circuit is running at a voltage of 12 V. Using MATLAB,
determine:
(i) Thevenin’s voltage, Vth
(ii) Thevenin’s equivalent resistance, Rth
(iii) The current ﬂowing through the load resistance, RL
(iv) From the calculated Thevenin’s circuit, vary the load resistance starting
from 1 to 20 ohms, and determine the output power for all scenarios to
prove the maximum power transfer theorem; also determine the maximum
output power.
5. Using MATLAB and Example 8.13 as a reference, determine the apparent power,
S, and the power factor of a series RLC circuit with:
(a) P ¼ 50 W and Q ¼ 13 Var
(b) P ¼ 12 W and Q ¼ 2.3 Var
Fig. 8.84 An electrical
circuit with two resistors in
parallel
Fig. 8.85 An electrical
circuit with three resistors
Exercise 8
211

6. Consider the following delta-connected system as shown in Fig. 8.86.
(a) The following parameters for the system are given:
VAB ¼ 100∠0
 V
VBC ¼ 110∠120
 V
VCA ¼ 120∠240
 V
Z1 ¼ 8∠25

Z2 ¼ 14∠55

Z3 ¼ 18∠ 23

Determine if the system is balanced or unbalanced. Hence, calculate:
(i) Phase currents IAB, IBC, and ICA
(ii) Line currents IA, IB, and IC
(b) Now consider the following parameters for the same system:
VAB ¼ 100∠0
 V
VBC ¼ 110∠120
 V
VAB ¼ 120∠240
 V
Z1 ¼ Z2 ¼ Z3 ¼ Z ¼ 5∠30

Determine if the system is balanced or unbalanced. Hence, calculate:
Fig. 8.86 An electrical
circuit with delta connection
212
8
Electrical Circuit Analysis

(i) Phase currents IAB, IBC, and ICA.
(ii) Line currents IA, IB, and IC
7. (a) Determine the gain and output voltage of the inverting ampliﬁer as shown in
Fig. 8.87, where R1 ¼ 10 ohm, R2 ¼ 14 ohm, and input voltage Vin¼ 24 V.
(b) What is the gain and output voltage of the non-inverting ampliﬁer if the
diagram as shown in Fig. 8.88 has the same R1, R2, and input voltage of 5 ohm,
7 ohm, and 12 V, respectively?
8. (a) Design a differentiator circuit as shown in Fig. 8.89 using MATLAB, where
you have an input of v(t) ¼ 6cos2(t), a resistor of 10 ohm, a capacitor of 0.5
Farads. What will be the output signal, vout(t) from your differentiator? What will
be the output voltage, IR, and IC of the circuit at 0.1 s?
(b) Design an integrator circuit as shown in Fig. 8.90 using MATLAB, where
you have an input of v(t) ¼ cos2(t)/ sin (t), a resistor of 12 ohm, a capacitor of 0.2
Farads. What will be the output signal, vout(t) from your integrator? What will be
the output voltage, IR, and ICof the circuit at 0.5 s?
Fig. 8.87 An inverting
ampliﬁer
Fig. 8.88 A non-inverting
ampliﬁer
Exercise 8
213

Fig. 8.89 A differentiator
circuit
Fig. 8.90 An integrator
circuit
214
8
Electrical Circuit Analysis

Chapter 9
Control System and MATLAB
9.1
Introduction
In the engineering domain, the study of control systems is required to govern the
behavior of any physical system. The behavior of a physical system can be regarded
as the response or the output of that system. In control systems, one of the objectives
is to regulate that response with respect to the input of that system. The response of a
physical system can be represented mathematically either in the frequency domain or
in the time domain. The concepts of both of these domains in control systems will be
explained with practical illustration in this chapter using MATLAB. To implement
the concepts of control systems, it is required to convert any physical system to a
mathematical representation. The opposite can also be necessary for various aspects.
In this chapter, the concept of state-space representation, which can be used to
convert any physical system to a mathematical model, will be demonstrated with
MATLAB implementation. In control system study, controllability, observability,
and stability analysis hold special signiﬁcance. Hence, all of these topics will be
illustrated by means of MATLAB with proper theoretical guidance and practical
examples.
9.2
Frequency Response Overview
Control systems are mostly associated with signals, because by understanding the
signals and their response by the system, one can easily control different aspects of
the complete system. These systems may be exposed to the signals of different
frequencies, the response for which is important to comprehend and eventually
control the system. The frequency response can therefore be stated as the output of
a system to a waveform of a particular frequency. More speciﬁcally, the frequency
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_9
215

response can provide more information on the amplitude response and phase
response of a system.
A system in control system is commonly represented either in a time domain, an
s-domain, or a frequency domain. In the s-domain, the system is represented by a
new parameter called s, which is represented by a transfer function, and which can be
derived from a time domain system through Laplace transform. A frequency domain,
on the other hand, provides speciﬁc details on the amplitude and phase of the system.
This can be determined from the s-domain by replacing s with jω, where ω is the
frequency of the input signal. This section will discuss the formation and compo-
nents of a transfer function, domain transformation using Laplace and inverse
Laplace transformation, and analysis and operation on transfer function through
partial fraction decomposition, giving insights to dive into more complex operations
to understand the determination of frequency responses in control systems.
9.2.1
Linear Time-Invariant System
Linear time-invariant (LTI) systems refer to a certain group of systems with two
distinctive characteristics—linearity and time invariance. Linearity is the character-
istic that signiﬁes that the output of the system is linearly related to the output.
Consider Fig. 9.1 to understand the concept of linearity. The ﬁrst output of the ﬁrst
is y1(t), and the input is x1(t), whereas the second output and the input of the system
is y2(t) and x2(t) respectively. The linear characteristic of the system can be realized
by observing the third inputs and outputs. Here, the given input is the combination of
the previous two inputs—(a) and (b). Due to the linearity property, the output of the
system changes linearly according to the changes made in the inputs, i.e., the output
has also become the combination of the outputs of (a) and (b). Such linear charac-
teristic is one of the characteristics of the LTI system.
Another characteristic of an LTI system is its time invariance, which signiﬁes that
if the input is applied at different timing, the output will not be dependent on that
timing. Consider a system that produces y(t) output for an input x(t). If a time shift
Fig. 9.1 Illustration of linearity
216
9
Control System and MATLAB

occurs in the input, such as x(t + 1), the produced output will remain the same with
the same time shift, i.e., y(t + 1), as shown in Fig. 9.2.
The LTI system can also be deﬁned in terms of a transfer function, which is an
important characteristic of LTI systems, which will be discussed in later sections.
9.2.2
Transfer Function
Transfer function of a system can be deﬁned as the ratio of the Laplace transform of
output to the Laplace transform of input. Consider the following system in Fig. 9.3,
where Y(s) represents the Laplace transform of the output y(t) and X(s) is the Laplace
transform of the input x(t).
Hence, the transfer function of the system can be referred to as follows:
G sð Þ ¼ Y sð Þ
X sð Þ
ð9:1Þ
In MATLAB the transfer function can be created using tf() function, where the
input is a matrix representing the coefﬁcients of the numerator and the denominator.
MATLAB command for transfer function:
tf([Numerator], [Denominator])
Here, in [Numerator] the coefﬁcients of s need to be incorporated starting from the
highest degree to the lowest degree as a row vector. For [Denominator], the same
process will be repeated; however, the denominator represents the input and the
numerator represents the output of the system both in the Laplace transformation
forms.
Fig. 9.2 Illustration of time invariance
Fig. 9.3 Illustration of
transfer function
9.2
Frequency Response Overview
217

An example is given below to make the above command more comprehensible.
9.2.2.1
MATLAB Example 9.1: Transfer Function
Create the following transfer function using MATLAB:
G sð Þ ¼
s þ 50
s2 þ 11s þ 12
ð9:2Þ
The MATLAB code for this example is given in Fig. 9.4 with its output in
Fig. 9.5.
Output
The transfer function can also be deﬁned as a function of s using MATLAB
manually as below. The MATLAB code for this example is given in Fig. 9.6 with its
output in Fig. 9.7.
Output
Fig. 9.4 Code—Transfer function
Fig. 9.5 Output—Transfer
function
218
9
Control System and MATLAB

9.2.3
Laplace Transform
Laplace transform is very essential in the study of the LTI system. The task of
Laplace transformation is to convert any time domain input into a frequency domain,
or s-domain output. One of the beneﬁts of such conversion is that it can convert any
differential equation into a simple algebraic equation in its frequency domain.
Hence, the calculation becomes easier as the rules of algebra become applicable to
such an equation. We already discussed that the transfer function of an LTI system is
the ratio of the Laplace transform of both output and input. Therefore, the concept of
Laplace transform needs further emphasis. In MATLAB, the Laplace transform of
any time domain equation can be converted into an s-domain equation by using the
following command:
MATLAB command for Laplace transform of g:
laplace(g)
9.2.3.1
MATLAB Example 9.2: Laplace Transform
Consider the following function for performing Laplace transform using MATLAB:
g tð Þ ¼ e3t sin 6t
ð
Þ
ð9:3Þ
The MATLAB code for this example is given in Fig. 9.8 with its output in
Fig. 9.9.
Fig. 9.6 Code—Manually determining the transfer function
Fig. 9.7 Output—
Manually determining the
transfer function
9.2
Frequency Response Overview
219

Output
Laplace transform can also be utilized for solving initial value problems involv-
ing differential equations. The Laplace transform of derivative terms can be deter-
mined using the following formula:
yn tð Þ ¼ snY sð Þ  sn1y 0
ð Þ  sn2y0 0
ð Þ  sn3y00 0
ð Þ . . . ::  yn1 0
ð Þ
ð9:4Þ
where n ¼ 1, 2, 3, . . .. . . . Here, yn represents the nth derivative of y(t). Using the
above formula, the Laplace transform of the ﬁrst, second, and third derivative terms
are listed in Table 9.1, as these are the most commonly used terms in the initial value
problems.
Fig. 9.8 Code—Laplace transform
Fig. 9.9 Output—Laplace
transform
Table 9.1 Differential terms and the corresponding Laplace transforms
Differential term
Laplace transform
y0
L{y0} ¼ sY(s)  y(0)
y00
L{y00} ¼ s2Y(s)  sy(0)  y0(0)
y0 0 0
L{y0 0 0} ¼ s3Y(s)  s2y(0)  sy0(0)  y00(0)
220
9
Control System and MATLAB

9.2.3.2
MATLAB Example 9.3: Laplace Transform of Initial Value
Problem with Differential Equation
Solve the following initial value problem using Laplace transform:
3y000 tð Þ þ 2y00 tð Þ þ 3y tð Þ ¼ 1; y 0
ð Þ ¼ y0 0
ð Þ ¼ 0; y00 0
ð Þ ¼ 1
ð9:5Þ
The MATLAB code for this example is given in Fig. 9.10 with its output in
Fig. 9.11.
Output
9.2.4
Inverse Laplace Transform
To convert the frequency domain output back into its original time domain input,
inverse Laplace transform is required. The command for inverse Laplace transform
in MATLAB is as follows:
Fig. 9.10 Code—Laplace transform of initial value problem with differential equation
Fig. 9.11 Output—Laplace
transform of initial value
problem with differential
equation
9.2
Frequency Response Overview
221

MATLAB command for inverse Laplace transform of G:
ilaplace(G)
9.2.4.1
MATLAB Example 9.4: Inverse Laplace Transform
Consider the following function for performing inverse Laplace transform using
MATLAB:
G sð Þ ¼
6
s  3
ð
Þ2 þ 36
ð9:6Þ
The MATLAB code for this example is given in Fig. 9.12 with its output in
Fig. 9.13.
Output
Fig. 9.12 Code—Inverse Laplace transform
Fig. 9.13 Output—Inverse
Laplace transform
222
9
Control System and MATLAB

9.2.5
Partial Fraction
Partial fraction is also an important concept that is required while performing
Laplace, or inverse Laplace transform manually. It also appears in other relevant
problems. Partial fraction decomposition is a method through which any rational
fraction can be broken down in terms of simpler fractions to make the computations
easier. This technique facilitates greatly while performing inverse Laplace of rational
fractions. Before introducing the MATLAB command for performing partial frac-
tion decomposition, let us have a look at the generalized format of a rational fraction
and its partial fraction expansion as stated below:
F sð Þ ¼ N sð Þ
D sð Þ ¼ Nn:sn þ Nn1sn1 þ . . . þ N1:s þ N0
Dm:sm þ Dm1sm1 þ . . . þ D1:s þ D0
ð9:7Þ
Partial fraction expansion ¼
rm
s  pm
þ
rm1
s  pm1
þ . . . þ
r1
s  p1
þ k sð Þ
ð9:8Þ
Here, N(s) and D(s) represent the numerator and denominator terms. The partial
fraction expansion of the fraction F(s) is also shown above.
In Eqs. (9.7)–(9.8), N ¼ [Nn Nn  1. . .N0] and D ¼ [Dn Dn  1. . .D0] indicate two
row vectors containing the coefﬁcients of s for numerator and denominator, respec-
tively. These two vectors are the input of MATLAB for determining the residuals,
poles, and coefﬁcients of polynomials of the partial fraction expansion. Hence,
MATLAB provides three row vectors, r ¼ [rm rm  1. . .r1]; p ¼ [pm pm  1. . .p0];
k ¼ [km km  1. . .k0], which represent the residuals, poles, and coefﬁcients of
polynomials, respectively. By incorporating the values of these three vectors, the
partial fraction expansion can be derived as shown in the above equation.
The MATLAB command for partial fraction expansion is given below:
MATLAB command for partial fraction expansion:
[r, p, k] ¼ residue(N, D)
Here, the input and output parameters have been kept the same as the discussion
provided earlier for better comprehension.
A rational fraction can be proper or improper based on which the steps for
determining partial fraction decompositions vary. The conditions of the proper and
improper rational fraction are provided in Table 9.2.
For the third case, when the highest degree for both the numerator and the
denominator becomes equal, the fraction can either be proper or improper based
on certain conditions. To illustrate the conditions clearly, let’s consider the following
9.2
Frequency Response Overview
223

rational fraction F(s), where the highest degree for both numerator and denominator
is n:
F sð Þ ¼ a1sn þ a2sn1 þ . . . þ an1s þ ans0
b1sn þ b2sn1 þ . . . þ bn1s þ bns0
ð9:9Þ
For the above-generalized fraction, the recognition of proper and improper
fraction can be made by following the steps incorporated in Tables 9.3. Two
examples are provided in Table 9.4.
9.2.5.1
MATLAB Example 9.5: Partial Fraction Expansion
Determine the partial fraction expansion of the following proper rational fraction,
where the highest degree of the denominator is greater than the highest degree of
numerator:
2s þ 3
s2 þ 2s
ð9:10Þ
The MATLAB code for this example is given in Fig. 9.14 with its output in
Fig. 9.15.
Output
Table 9.2 The conditions of the proper and improper rational fraction
Case
Decision
Number of the highest degree in the numerator < number of the highest
degree in the denominator
Proper rational
fraction
Number of the highest degree in the numerator > number of the highest
degree in the denominator
Improper rational
fraction
Number of the highest degree in the numerator ¼ number of the highest
degree in the denominator
Proper or improper
224
9
Control System and MATLAB

Table 9.3 Conditions for being proper and improper fraction when the highest degree for both in the numerator and the denominator is equal
Step 1:
If (a1 > b1)
Decision : Improper
elseif (a1 < b1)
Decision : Proper
else
Go ! Step 2
end
Step 2:
If (a2 > b2)
Decision : Improper
elseif (a2 < b2)
Decision : Proper
else
Go ! Step 3
end
. . .
. . .
. . .
Step (n  1):
If (an  1 > bn  1)
Decision : Improper
elseif (an  1 < bn  1)
Decision : Proper
else
Go ! Step n
end
Step n:
If (an > bn)
Decision : Improper
elseif (an < bn)
Decision : Proper
else
Decision : Improper
(considering 1 as
Improper fraction)
end
9.2
Frequency Response Overview
225

9.2.5.2
MATLAB Example 9.6: Partial Fraction Expansion
Determine the partial fraction expansion of the following improper rational fraction,
where the highest degree of the denominator is equal to the highest degree of
numerator:
2s2 þ 4s þ 1
s2 þ 2s
ð9:11Þ
The MATLAB code for this example is given in Fig. 9.16 with its output in
Fig. 9.17.
Output
9.2.5.3
MATLAB Example 9.7: Partial Fraction Expansion
Determine the partial fraction expansion of the following proper rational fraction,
where the highest degree of the denominator is equal to the highest degree of
numerator:
Table 9.4 Examples of
fractions
2s2þ4sþ2
2s2þ3sþ2
Step 1: 2 ¼ 2
Step 2: 4 > 3
Decision: Improper fraction
2s4þ3s3
2s4þ3s3þ4s2þ3sþ1
Step 1: 2 ¼ 2
Step 2: 3 ¼ 3
Step 3: 0 < 4
Decision: Proper fraction
Fig. 9.14 Code—Partial fraction
226
9
Control System and MATLAB

Fig. 9.15 Output—Partial fraction
Fig. 9.16 Code—Partial fraction expansion 1
9.2
Frequency Response Overview
227

2s2 þ 2s þ 1
2s2 þ 4s þ 3
ð9:12Þ
The MATLAB code for this example is given in Fig. 9.18 with its output in
Fig. 9.19.
Output
Fig. 9.17 Output—Partial fraction expansion 1
228
9
Control System and MATLAB

9.2.5.4
MATLAB Example 9.8: Partial Fraction Expansion
Determine the partial fraction expansion of the following improper rational fraction,
where the highest degree of denominator is less than the highest degree of
numerator:
Fig. 9.19 Output—Partial fraction expansion 2
Fig. 9.18 Code—Partial fraction expansion 2
9.2
Frequency Response Overview
229

Fig. 9.20 Code—Partial fraction expansion 3
Fig. 9.21 Output—Partial fraction expansion 3
230
9
Control System and MATLAB

2s3 þ 4s2 þ 3s þ 2
s2 þ 2s þ 1
ð9:13Þ
The MATLAB code for this example is given in Fig. 9.20 with its output in
Fig. 9.21.
Output
9.2.6
DC Gain
In general, the value of a transfer function signiﬁes gain, which is termed as AC gain
due to the existence of the frequency term. When that frequency component
becomes zero, the AC gain can be referred to as DC gain.
To be more precise, DC gain can be deﬁned as the ratio of the steady-state step
output or response to state input. It can also be regarded as the value of the transfer
function solved at s ¼ 0. Mathematically, it can be represented using the following
formula:
DC gain ¼ G sð Þ:
ð9:14Þ
Here, G(s) represents the transfer function of a system. An example to determine
the value of DC gain using MATLAB is shown below.
9.2.6.1
MATLAB Example 9.9: DC Gain
Determine the DC gain of the following transfer function:
Fig. 9.22 DC gain example
9.2
Frequency Response Overview
231

G sð Þ ¼
20
s2 þ 10s þ 11
ð9:15Þ
The MATLAB code for this example with its output is given in Fig. 9.22.
9.2.7
Initial Value and Final Value Theorem
The initial value theorem is used to determine the value of a time domain function,
g(t), at t ¼ 0 given the Laplace transform of that function. On the other hand, the ﬁnal
value theorem helps to determine the ﬁnal value of the function at t ¼ 1. Both of
these theorems are regarded together as the limiting theorem.
The initial and the ﬁnal value theorem can be written as follows:
Initial value theorem : g tð Þ ¼ lim
s!1 sG sð Þ
ð9:16Þ
Final value theorem : g tð Þ ¼ lim
s!0 sG sð Þ
ð9:17Þ
Here, G(s) is the Laplace transform of the time domain function g(t).
9.2.7.1
MATLAB Example 9.10: Initial and Final Value Theorem
Consider the following transfer function:
G sð Þ ¼ 2 þ 6s þ 2s2
2s s þ 2
ð
Þ2
ð9:18Þ
Fig. 9.23 Initial value problem
232
9
Control System and MATLAB

Determine the initial and ﬁnal value of g(t) by using the initial and ﬁnal value
theorem in MATLAB. Here, G(s) is the Laplace transform g(t).
The MATLAB code and output for this example are given in Fig. 9.23 and
Fig. 9.24.
9.2.8
Poles/Zeros
The poles are the roots of the denominator of the transfer function of a system. On
the other hand, zeros are the roots of the numerator of the transfer function of a
system. In MATLAB, the commands for determining poles and zeros of a system
from its transfer function are listed below:
MATLAB command for determining poles from transfer function, G:
pole(G)
MATLAB command for determining zeros from transfer function, G:
zero(G)
MATLAB command for pole-zero mapping from transfer function, G:
pzmap(G)
9.2.8.1
MATLAB Example 9.11: Poles and Zeros
Consider the following transfer function to determine the poles and zeros:
Fig. 9.24 Final value problem
9.2
Frequency Response Overview
233

Fig. 9.25 Code—Poles and zeros
Fig. 9.26 Output—Poles and zeros
234
9
Control System and MATLAB

G sð Þ ¼
s þ 50
s2 þ 11s þ 12
ð9:19Þ
The MATLAB code for this example is given in Fig. 9.25 with its output in
Figs. 9.26 and 9.27.
Output
9.2.9
Laplace Transform in Electrical Circuit
The concept of Laplace transform can be utilized for electrical circuit analysis. We
can convert the ratio of output to input into Laplace transformation to determine its
transfer function. Later, from the transfer function, we can perform frequency
domain analysis. Consider the RLC circuit drawn in Fig. 9.28 to determine the
following aspects using MATLAB:
(a) Transfer function
(b) Poles and zeros
(c) DC gain
(d) Initial and ﬁnal value
Fig. 9.27 Graphical output—Pole zero map
9.2
Frequency Response Overview
235

(a) When converting from the time domain to the frequency domain, a capacitive
element is represented as 1
sC and an inductive element is represented as sL, while
the resistive element stays the same.
Transfer function of the circuit:
G sð Þ ¼ Vout
Vin ¼
sL
R þ sL þ 1
sC
¼
s
2 þ s þ
1
0:5s
¼
s2
s2 þ 2s þ 2
(b) Poles and zeros:
Poles ¼ The roots of the denominator s2 + 2s + 2
Poles ¼ 2 
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
22  4  1  2
p
2  1
¼ 1  i
Zeros ¼ The roots of the numerator s2
Zeros ¼ 0, 0
DC gain : DC gain ¼ G sð Þ ¼
s2
s2 þ 2s þ 2


¼ 0
(c) Initial and ﬁnal value:
Initial value theorem : g tð Þ ¼ sG sð Þ ¼
s ∙
s2
s2 þ 2s þ 2


¼ 1
Final value theorem : g tð Þ ¼ sG sð Þ ¼
s ∙
s2
s2 þ 2s þ 2


¼ 0
Fig. 9.28 An RLC circuit
236
9
Control System and MATLAB

MATLAB Implementation
The MATLAB code for this example is given in Fig. 9.29 with its output in
Fig. 9.30.
Output
9.3
Time Response Overview
Time response signiﬁes the output of a time domain function that characterizes any
dynamic system. To determine the time response of a system, the nature of the input
and the mathematical model of the system need to be known.
The time response of a system can be categorized into two components—tran-
sient response and steady-state response.
Transient response is the early part of the time response which exists only for a
short period of time, and approaches toward zero as time continues to proceed.
Conversely, a steady-state response is the stable response of the system that happens
right after the transient response dries out.
Fig. 9.29 Code—Laplace transform in electrical circuit
9.3
Time Response Overview
237

Before discussing more about time response, it is required to ﬁrst illustrate some
of the basic input signals that are used in different control systems. In Table 9.5,
some of the input signal functions with their time and frequency domain character-
istics are listed.
Fig. 9.30 Output—Laplace transform in electrical circuit
Table 9.5 Some input signals and their functions in time and frequency domain
Input signal
Time domain function
Frequency domain function
Unit step function
R(t) ¼ 1; t  0
L R tð Þ
f
g ¼ 1
s
Unit impulse function
δn tð Þ ¼ 1
n ; 0  t  n
L{δ(t)} ¼ 1
Unit ramp function
R(t) ¼ t; t  0
L R tð Þ
f
g ¼ 1
s2
Sinusoidal function
sinωt ¼ Img[e jωt]
L sin ωt
f
g ¼
ω
s2þω2
cosωt ¼ Real[e jωt]
L cos ωt
f
g ¼
s
s2þω2
238
9
Control System and MATLAB

9.3.1
First-Order System
The general representation of the transfer function of a ﬁrst-order system can be
generalized using the following formula:
G sð Þ ¼
K
1 þ τs
ð9:20Þ
Here, G(s) represents the transfer function of the ﬁrst-order system, K signiﬁes the
DC gain, and τ depicts the time constant.
Consider the following transfer function of a ﬁrst-order system:
G sð Þ ¼
8
2 þ 5s
ð9:21Þ
Determine the following parameters:
(a) DC gain
(b) Time constant
Solution
G sð Þ ¼
K
1 þ τs ¼
8
2 þ 5s ¼
4
1 þ 5
2 s
Hence, DC gain, K ¼ 4; time constant, τ ¼ 5
2.
9.3.1.1
Speciﬁc Characteristics of First-Order Systems
Rise Time The time required by a signal to reach 90% of its ﬁnal value starting
from 10% is regarded as the rise time. Consider the following step response of a ﬁrst-
order system:
y tð Þ ¼ K 1  e
t
τ


,
ð9:22Þ
where K is the DC gain and τ is the time constant.
The time required to reach 10% of the ﬁnal value can be determined by the
following formula:
t10% ¼ τ ln 0:1
ð
Þ
ð9:23Þ
9.3
Time Response Overview
239

The time required to reach 90% of the ﬁnal value can be determined by the
following formula:
t90% ¼ τ ln 0:9
ð
Þ
ð9:24Þ
Therefore, the rise time of a ﬁrst-order system can be determined by using the
following formula:
Rise time, TR ¼ t90%  t10% ¼ τ ln 9
ð Þ  2:2 τ
ð9:25Þ
Settling Time
The time required for a signal to reach and remain steady within 2%–5% of its ﬁnal
value is regarded as the settling time.
The formula for determining settling time for 2% criteria can be written as:
Maximum settling time, TS
max ¼ τlnln 0:02
ð
Þ  4 τ
ð9:26Þ
The formula for determining settling time for 5% criteria can be written as:
Minimum settling time, TS
min ¼ τlnln 0:05
ð
Þ  3 τ
ð9:27Þ
Delay Time Delay time can be deﬁned as the required time for a response to reach
50% of its ﬁnal value during the ﬁrst half cycle of the waveform.
The formula for determining delay time can be represented as follows:
Delay time, TD ¼ τlnln 0:5
ð
Þ  0:7 τ
ð9:28Þ
9.3.2
Second-Order System
The general format of the transfer function of a second-order system can be
represented using Eq. (9.29):
G sð Þ ¼
Kω2
n
s2 þ 2ζωns þ ω2
n
ð9:29Þ
Here, K is the DC gain; ωn is the natural frequency; and ζ represents the damping
ratio of the second-order system.
The roots of the denominator of the transfer function indicate the poles of the
system, based on which the stability of a system can be determined. Hence, the poles
of a second-order system can be determined using the formula in Eq. (9.30):
240
9
Control System and MATLAB

poles ¼ 2ζωn 
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
4ζ2ωn2  4  1  ωn2
p
2  1
¼ ζωn  ωn
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
ζ2  1
q
ð9:30Þ
The damping ratio of a second-order system, ζ, creates an opportunity to classify
different systems based on damping, which represents the oscillation characteristics
of a system.
9.3.2.1
Speciﬁc Characteristics of Second-Order Systems
Delay Time The deﬁnition of delay time is the same as mentioned earlier for a ﬁrst-
order system. However, the delay time of a second-order system is quite different
from a ﬁrst-order system, and is represented by a different formula in Eq. (9.31):
Delay time, TD ¼
0:7ζ þ 1
ωn
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
1  ζ2
p
ð9:31Þ
Rise Time Rise time of the response of a second-order system can be deﬁned as the
required time of the response to reach from its 10% ﬁnal value to 90% ﬁnal value
during the ﬁrst cycle of the response. It is to be noted that the deﬁnition works when
the damping ratio is greater than 1. The formula of the rise time calculation for a
second-order system can be written as in Eq. (9.32):
Rise time, TR ¼
π 
ﬃﬃﬃﬃﬃﬃﬃﬃ
1ζ2
p
ζ
ωn
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
1  ζ2
p
ð9:32Þ
Peak Time The time required for the response of a second-order system to reach its
peak or maximum value during the ﬁrst cycle is called the peak time. The peak time
of a second-order system can be determined by using Eq. (9.33):
Peak time, TP ¼
π
ωn
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
1  ζ2
p
ð9:33Þ
Settling Time The deﬁnition of settling time is the same as before mentioned in the
ﬁrst-order system. The formula for determining settling time for the response of a
second-order system can be represented by Eqs. (9.34)–(9.35):
Maximum settling time, TS
max ¼
4
ζωn
ð9:34Þ
Minimum settling time, TS
min ¼
3
ζωn
ð9:35Þ
9.3
Time Response Overview
241

Percent of Overshoot Percent of overshoot of a second-order system can be
determined mathematically by using Eq. (9.36):
%Overshoot ¼ 100e
ζπﬃﬃﬃﬃﬃﬃ
1ζ2
p
ð9:36Þ
9.3.3
Impact of Damping Ratio
The value of damping ratio categorizes second-order systems in four different cases,
which are named as below:
(i) Overdamped system
(ii) Critically damped system
(iii) Underdamped system
(iv) Negative damped system
9.3.3.1
Overdamped System
When the damping ratio of a system is greater than 1, i.e., ζ > 1, the system is
regarded as an overdamped system. It occurs when the poles of the system are real,
unequal, and negative.
9.3.3.2
MATLAB Example 9.12: Overdamped System
Consider the following second-order system:
G sð Þ ¼
Kω2
n
s2 þ 2ζωns þ ω2
n
¼
50
s2 þ 15s þ 25
ð9:37Þ
Here, K ¼ 2, ζ ¼ 1.5, and ωn ¼ 5. The response of the above-mentioned
overdamped system is produced using MATLAB in the example below. The
MATLAB code for this example is given in Fig. 9.31 with its output in Figs. 9.32,
9.33, and 9.34.
Output
242
9
Control System and MATLAB

Fig. 9.31 Code—Overdamped system
Fig. 9.32 Output—Overdamped system
9.3
Time Response Overview
243

9.3.3.3
Critically Damped System
Critically damped system represents those systems that have a damping ratio,ζ ¼ 1.
For such systems, the poles are real, equal, and negative.
Fig. 9.33 Graphical output—Step response of overdamped system
Fig. 9.34 Graphical output—Pole zero map of overdamped system
244
9
Control System and MATLAB

9.3.3.4
MATLAB Example 9.13: Critically Damped System
Consider the following second-order system:
G sð Þ ¼
Kω2
n
s2 þ 2ζωns þ ω2
n
¼
50
s2 þ 10s þ 25
ð9:38Þ
Here, K ¼ 2, ζ ¼ 1, and ωn ¼ 5. The response of the above-mentioned critically
damped system is produced using MATLAB in the example below. The MATLAB
code for this example is given in Fig. 9.35 with its output in Figs. 9.36, 9.37,
and 9.38.
Output
9.3.3.5
Underdamped System
Underdamped system represents those systems that have a damping ratio, 0 < ζ < 1.
For such systems, the poles are complex numbers with negative real parts.
9.3.3.6
MATLAB Example 9.14: Underdamped System
Consider the following second-order system:
Fig. 9.35 Code—Critically damped system
9.3
Time Response Overview
245

Fig. 9.36 Output—Critically damped system
Fig. 9.37 Graphical output—Step response of critically damped system
246
9
Control System and MATLAB

G sð Þ ¼
Kω2
n
s2 þ 2ζωns þ ω2
n
¼
50
s2 þ 5s þ 25
ð9:39Þ
Here, K ¼ 2, ζ ¼ 0.5, and ωn ¼ 5. The response of the above-mentioned
underdamped system is produced using MATLAB in the example below. The
MATLAB code for this example is given in Fig. 9.39 with its output in Figs. 9.40,
9.41, and 9.42.
Output
9.3.3.7
Undamped System
Undamped system has a damping ratio, ζ ¼ 0. In an undamped system, the poles are
complex; however, the real parts become zero in such cases.
Fig. 9.38 Graphical output—Pole zero map of critically damped system
9.3
Time Response Overview
247

Fig. 9.39 Code—Underdamped system
Fig. 9.40 Output—Underdamped system
248
9
Control System and MATLAB

Fig. 9.41 Graphical output—Step response of underdamped system
Fig. 9.42 Graphical output—Pole zero map of underdamped system
9.3
Time Response Overview
249

9.3.3.8
MATLAB Example 9.15: Undamped System
Consider the following second-order system:
G sð Þ ¼
Kω2
n
s2 þ 2ζωns þ ω2
n
¼
50
s2 þ 25
ð9:40Þ
Here, K ¼ 2, ζ ¼ 0, and ωn ¼ 5. The response of the above-mentioned
underdamped system is produced using MATLAB in the example below. The
MATLAB code for this example is given in Fig. 9.43 with its output in Figs. 9.44,
9.45, and 9.46.
N.B. In the output shown in Fig. 9.44, the term Inf appears when the result is
inﬁnity; and the term NaN stands for “not a number.”
Output
9.3.3.9
Negative Damped System
In a negative damped system, the damping ratio is negative, i.e., ζ < 0. The poles of a
negative damped system are positive real numbers, i.e., they are positioned in the
right half-plane of the coordinate system. Therefore, such systems are always
regarded as unstable systems.
Fig. 9.43 Code—Undamped system
250
9
Control System and MATLAB

Fig. 9.44 Output—Undamped system
Fig. 9.45 Graphical output—Step response of undamped system
9.3
Time Response Overview
251

9.3.3.10
MATLAB Example 9.16: Negative Damped System
Consider the following second-order system:
G sð Þ ¼
Kω2
n
s2 þ 2ζωns þ ω2
n
¼
50
s2  20s þ 25
ð9:41Þ
Here, K ¼ 2, ζ ¼  2, and ωn ¼ 5. The response of the above-mentioned negative
damped system is produced using MATLAB in the example below. The MATLAB
code for this example is given in Fig. 9.47 with its output in Figs. 9.48, 9.49,
and 9.50.
Output
Fig. 9.46 Graphical output—Pole zero map of undamped system
252
9
Control System and MATLAB

Fig. 9.47 Code—Negative damped system
Fig. 9.48 Output—Negative damped system
9.3
Time Response Overview
253

Fig. 9.49 Graphical output—Step response of negative damped system
Fig. 9.50 Graphical output—Pole zero map of negative damped system
254
9
Control System and MATLAB

9.3.4
Steady-State Error
The steady-state error of a system can be deﬁned by utilizing the following formula
for a system illustrated in Fig. 9.51:
Ess ¼
sR sð Þ
1 þ H sð ÞG sð Þ
ð9:42Þ
Position Error Coefﬁcient Position error coefﬁcient can be deﬁned by the follow-
ing formula mathematically for the same system shown in Fig. 9.51:
Kp ¼ lim
s!0H sð Þ ∙G sð Þ
ð9:43Þ
Velocity Error Coefﬁcient
Velocity error coefﬁcient can be deﬁned by the following formula mathematically
for the same system shown in Fig. 9.51:
Kv ¼ lim
s!0s ∙H sð Þ ∙G sð Þ
ð9:44Þ
Acceleration Error Coefﬁcient
Acceleration error coefﬁcient can be deﬁned by the following formula mathemati-
cally for the same system shown in Fig. 9.51:
Ka ¼ lim
s!0s2 ∙H sð Þ ∙G sð Þ
ð9:45Þ
9.3.4.1
MATLAB Example 9.17: Steady-State Error
Consider the system shown in Fig. 9.51. Here, G sð Þ ¼
20 sþ2
ð
Þ
sþ3
ð
Þ sþ2
ð
Þs and H(s) ¼ 1.
The input of the system in the time domain is r(t) ¼ 1 + 5t.
Find the following using MATLAB:
(a) Position error coefﬁcient
(b) Velocity error coefﬁcient
Fig. 9.51 A closed-loop
feedback system
9.3
Time Response Overview
255

(c) Acceleration error coefﬁcient
(d) Steady-state error
The MATLAB code for this example is given in Fig. 9.52 with its output in
Fig. 9.53.
Output
Fig. 9.52 Code—Steady-state error
Fig. 9.53 Output—Steady-state error
256
9
Control System and MATLAB

9.4
A State-Space Representation for RLC Circuit
State-space representation signiﬁes a mathematical model to describe any physical
system in terms of input, output, variables, and the ﬁrst-order derivative. In state-
space representation, the variables that are used to deﬁne a physical system are called
state variables. One of the advantages of state-space representation is that state-space
modeling reduces any nth order mathematical model of dynamic systems into a
simple ﬁrst-order mathematical representation; hence, the computation becomes
easier.
A simple illustration of any state-space representation of any dynamic system can
be shown as in Fig. 9.54.
From Fig. 9.54, the state-space representation consists of three important param-
eters—inputs, state variables, and outputs. A generalized mathematical representa-
tion of a state-space model can be deﬁned by the following sets of equations, where
the ﬁrst one is regarded as a state equation and the second one can be called as output
equation:
x0 ¼ Ax þ Bu
ð9:46Þ
y ¼ Cx þ Du
ð9:47Þ
Here, x is the vector representing the state variables; u and y are the input and
output vector, respectively; A is the system matrix; B is regarded as the control input
matrix; C is called the output matrix; and D is the direct matrix of the state-space
representation.
State-space representation can be applied to electrical systems as well. Any RLC
circuit can be deﬁned in terms of state space. If we can deﬁne the state variables,
inputs, and outputs, an RLC circuit can be represented by adopting state-space
modeling to make the calculation more simpliﬁed.
Fig. 9.54 Output—Steady-state error
9.4
A State-Space Representation for RLC Circuit
257

9.4.1
State-Space Model and Response
Consider the following RLC series circuit, where the output is the voltage across the
inductor,vL, and the input is the voltage source, v(t). Here, the state variable is the
voltage across the capacitor, vC, and the current of the circuit, i. The system is shown
in Fig. 9.55 for more clariﬁcation.
In the RLC circuit, the storage elements are inductance L and capacitance C. The
following two relationships are available for any electrical circuit:
C dvC
dt ¼ Cv0
C ¼ i
ð9:48Þ
L di
dt ¼ Li0 ¼ vL
ð9:49Þ
v tð Þ ¼ iR þ vC þ vL
ð9:50Þ
Using the above equations, the state equations can be deﬁned as follows:
v0
C ¼
1
C
 
i
ð9:51Þ
i0 ¼ 1
L vL
ð
Þ ¼ 1
L v tð Þ  iR  vC
ð
Þ ¼
 1
L


vC þ
 1
R


i þ
1
L
 
v tð Þ
ð9:52Þ
The output equation can be represented as follows by using Eq. (9.50):
vL ¼ 1
ð
ÞvC þ R
ð
Þi þ v tð Þ
ð9:53Þ
Finally utilizing state Eqs. (9.51) and (9.52), and output Eq. (9.53), the state-space
representation of the RLC circuit can be written as follows:
Fig. 9.55 An RLC series circuit
258
9
Control System and MATLAB

v0
C i0


¼ 0 1
C  1
L  1
R
h
i
vC i
½
 þ 0 1
½
v tð Þ
ð9:54Þ
vL ¼ 1  R
½
 vC i
½
 þ 1½ v tð Þ
ð9:55Þ
9.4.2
State-Space Model to Transfer Function
From the state-space representation, it is possible to determine the transfer function
of the system. Consider the state-space representation in Eqs. (9.46) and (9.47). The
mathematical formula to determine the transfer function from the above-mentioned
state-space representation can be written by the following equation:
Transfer function, G sð Þ ¼ C 	 sI  A
ð
Þ1 	 B þ D
ð9:56Þ
Here, I is the identity matrix of the same dimension as A matrix.
In MATLAB, by deﬁning the matrices A, B, C, and D, the state-space represen-
tation of a system can be determined using ss() as mentioned below:
MATLAB command for state-space representation:
ss(A, B, C, D)
To determine the transfer function from its state-space model, MATLAB provides an
in-built function called ss2tf().
MATLAB command for determining transfer function from state-space
model:
ss2tf(A, B, C, D)
9.4.2.1
MATLAB Example 9.18: State-Space Model and Conversion
into Transfer Function
Consider the circuit in Fig. 9.56, where the output and input are vL and v(t),
respectively. The state variables are vC and i.
(a) Determine the state-space representation of the RLC circuit.
(b) From the state-space model, determine the transfer function using ss2tf().
(c) Verify the result of (b) by using the state-space to transfer function conversion
formula manually.
9.4
A State-Space Representation for RLC Circuit
259

Fig. 9.56 An RLC series circuit
Fig. 9.57 Code—State-space model to transfer function
260
9
Control System and MATLAB

The MATLAB code for this example is given in Fig. 9.57 with its output in
Fig. 9.58.
Output
9.4.3
Transfer Function to State-Space Model
From a given transfer function of a system, it is also possible to determine the state-
space model of that system. The MATLAB command for such conversion is
provided below:
MATLAB command for determining state-space model from transfer
function from:
tf2ss([Numerator], [Denominator])
Here, [Numerator] represents a vector containing the coefﬁcients of the numerator of
the transfer function; [Denominator] is a vector incorporating the coefﬁcient of the
denominator of the transfer function.
Fig. 9.58 Output—State-space model to transfer function
9.4
A State-Space Representation for RLC Circuit
261

9.4.3.1
MATLAB Example 9.19: Conversion into the State-Space Model
from the Transfer Function
Consider the following transfer function to determine its state-space model using
MATLAB:
G sð Þ ¼
2
s2 þ 20s þ 2
ð9:57Þ
The MATLAB code for this example is given in Fig. 9.59 with its output in
Fig. 9.60.
Output
9.5
Controllability and Observability of State-Space Model
9.5.1
Controllability
The controllability of a system requires to be identiﬁed, as it can help to determine
whether the state output of the system can be controlled with a control input. A
system is called controllable if the initial state of a system can be forwarded to the
desired state by controlling the input of a system within a ﬁnite time.
Consider the state-space representation in Eqs. (9.46) and (9.47). If a control input
u(t) exists that can transfer any initial state of the system x(to) to our desired state x(t)
in a ﬁnite time, the system can be regarded as controllable.
Fig. 9.59 Code—Transfer function to state-space model
262
9
Control System and MATLAB

Fig. 9.60 Output—Transfer function to state-space model
9.5
Controllability and Observability of State-Space Model
263

9.5.2
Testing for Controllability
To test the controllability, the rank of the controllability matrix needs to be equal to
the rank of the system matrix. Therefore, the condition of controllability can be listed
as follows:
If Rank (Controllability Matrix ) ¼ ¼ Rank(System Matrix, A)
System : Controllable
else
System : Not controllable
end
9.5.3
Observability
A system is called observable if the initial state of a system can be determined by
observing the output and the control input within a ﬁnite time. Consider the state-
space representation in Eqs. (9.46) and (9.47). If a ﬁnite time T exists within which
the initial state of the system x(to) can be determined by observing the output y(t) for
a given input u(t), the system can be regarded as observable.
9.5.4
Testing for Observability
To test observability, the rank of the observability matrix needs to be equal to the
rank of the system matrix. Therefore, the condition of controllability can be listed as
follows:
If Rank (Observability Matrix ) ¼ ¼ Rank(System Matrix, A)
System : Observable
else
System : Not Observable
end
264
9
Control System and MATLAB

9.5.4.1
MATLAB Example 9.20: Controllability and Observability
Consider the following system:
x0 ¼ 2 0  1  3 4 0 10 6  8
½
x þ 1 0 1
½
u
ð9:58Þ
y ¼ 3 2 4
½
x þ 1½ u
ð9:59Þ
Determine the controllability and the observability of the system.
The MATLAB code for this example is given in Fig. 9.61 with its output in
Fig. 9.62.
Fig. 9.61 Code—Controllability and observability of state-space model
9.5
Controllability and Observability of State-Space Model
265

Output
9.6
Stability Analysis
The stability of a system can be deﬁned by observing the output of a system that
corresponds to a speciﬁc input signal. A system can be regarded as stable when the
output is bounded for a speciﬁc bounded input. In control systems, it is crucial to
determine the stability of a system. Hence, stability analysis is a very essential part of
the control study.
In general, the stability analysis is followed by the rules mentioned below:
(a) Stable system: If all the poles of a system reside in the left-half plane of the
coordinate system, the system is regarded as a stable system.
(b) Unstable system: If at least one of the poles of a system is positioned in the right-
half plane, it will be referred to as an unstable system. Again, if the number of
Fig. 9.62 Code—Controllability and observability of state-space model
266
9
Control System and MATLAB

zeros is greater than the number of poles of a system, the system becomes
unstable.
(c) Marginally stable system: Marginally stable is another type of stability to deﬁne
a system which occurs when at least one of the poles lies on the imaginary axis,
and the others on the left-half plane of the coordinate system.
The above rules are applicable for any system having a closed-loop transfer
function. There are many methods to conclude the stability of a system. In this
section, the following methods will be covered to determine the stability of a system:
1. Routh criteria
2. Root locus
3. Bode plot
4. Nyquist plot
9.6.1
Routh Criteria
This is a method that yields stability information without the need to solve for the
closed-loop system poles. Using this method, we can tell how many closed-loop
system poles are in the left half-plane, in the right half-plane, and on the jω-axis.
(Notice that we say how many, not where.) We can ﬁnd the number of poles in each
section of the s-plane, but we cannot ﬁnd their coordinates. The method is called the
Routh-Hurwitz criterion for stability.
The method requires two steps:
(i) Generate a data table called a Routh table.
(ii) Interpret the Routh table to tell how many closed-loop system poles are in the
left half-plane, in the right half-plane, and on the jω -axis.
Consider the following transfer function of a linear closed-loop system:
G sð Þ ¼ Y sð Þ
X sð Þ ¼ b1sn þ b2sn1 þ b3sn2 þ . . . þ bNs0
a1sm þ a2sm1 þ a3sm2 þ . . . þ aMs0
ð9:60Þ
Here, n and m represent the highest degree of the numerator and the denominator,
respectively. {b1, b2, . . ., bN} are the coefﬁcients of the numerator, and {a1, a2, . . .,
aM} represent the coefﬁcients of the denominator. The denominator of the transfer
function is regarded as the characteristic equation, the solutions of which provide the
poles of a system. For the Routh’s criterion, the method is applied on this charac-
teristic equation, which is rewritten as follows:
C sð Þ ¼ a1sm þ a2sm1 þ a3sm2 þ . . . þ aMs0
ð9:61Þ
9.6
Stability Analysis
267

Table 9.6 The Routh table from the characteristic equation in Eq. (9.61)
sm
a1
a3
. . .. . .
. . . ..
sm  1
a2
a4
. . .. . .
aM
sm  2
A1
m2 ¼ 1
a2 a1 a3 a2 a4
j
j
A2
m2 ¼ 1
a4 a3 a5 a4 a6
j
j
. . .. . .
AM
m2 ¼ 1
aM aM1 aMþ1 aM aMþ2
j
j
sm  3
A1
m3 ¼
1
A1
m2 a2 a4 A1
m2 A2
m2
		
		
A2
m3 ¼
1
A2
m2 a4 a6 A2
m2 A3
m2
		
		
. . .. . .
AM
m3 ¼
1
AM
m2 aM aMþ2 AM
m2 AMþ1
m2
		
		
.
.
.
.
.
.
.
.
.
. . .. . .
.
.
.
s0
A1
0
268
9
Control System and MATLAB

The ﬁrst step in Routh criteria is to generate the Routh table or array from the
characteristic equation as shown in Table 9.6.
From the Routh table, the number of rows indicates the highest degree of the
characteristic equation. In the ﬁrst row, the coefﬁcients on the odd position of the
C(s) are enlisted, whereas in the second row, the coefﬁcients of the even positions
take the place of the columns. It is to be noted that C(s) needs to be ordered from the
highest degree to the lowest. Starting from the third row, the ﬁrst column value, A1
m2
, is deﬁned as shown in Eq. (9.62):
A1
m2 ¼ 1
a2 a1 a3 a2 a4
j
j
ð9:62Þ
Here, |a1 a3 a2 a4 | indicates the determinant of the matrix. It can be observed that,
in the determinant matrix, the values are from the immediate previous two row
values of two columns; and the division value is the immediate previous row value.
The same pattern can be seen for all the other values as well.
After the Routh array or table is made, the values of the ﬁrst column (marked
green) are evaluated to determine the stability of the system.
According to Routh’s criterion, the number of roots of the characteristic equation,
i.e., the number of poles having positive real part, i.e., lie on the right-half plane, is
equivalent to the number of sign changes that occur in the ﬁrst green marked column
of the Routh’s array, or table.
Therefore, if the number of sign changes in the ﬁrst green marked column is equal
to zero, the system can be regarded as stable; otherwise, it is unstable. It is also to be
noted that Routh’s criterion is capable of only making a decision, whether the system
is stable or unstable; it cannot provide any additional remarks, such as how to make
an unstable system stable.
The MATLAB code for Routh’s criterion is shown in the later examples. In
Routh’s criterion, there are two special cases as mentioned below:
Special Case 1: When the ﬁrst element of any row is zero
Special Case 2: When the entire row is zero
If zero appears in any of the rows, the consecutive row value becomes undeﬁned,
or inﬁnite. Therefore, during such special cases, the implementation of Routh’s table
is changed to accommodate such variation. These two special cases are beyond the
scope of this book. Therefore, the deviation of the implementation of Routh’s table
during such special cases will not be included in this chapter. However, in such
cases, the former value is replaced with 0.001 instead of 0 to proceed further with
calculation for avoiding the complex methods of Routh’s table implementations
during special cases.
9.6
Stability Analysis
269

9.6.1.1
MATLAB Example 9.21: Routh’s Criteria
Determine the stability of a system having the following characteristic equation:
Fig. 9.63 Code—Routh’s criterion
270
9
Control System and MATLAB

C sð Þ ¼ s3 þ 2s2 þ 10s þ 15
ð9:63Þ
In the following MATLAB code, an input() function is used, through which we
can provide the coefﬁcients of any characteristic equation manually to make the code
applicable for any such problems. For the above problem, the input is a vector of the
coefﬁcients [1 2 10 15], which has been provided to test the stability.
The MATLAB code for the example is given in Fig. 9.63 with its output in
Fig. 9.64. The code is created based on Table 9.6 described earlier.
Output
In the above example, the Routh array is produced for better understanding. From
the Routh array, it can be observed that no sign changes have occurred. Therefore,
the system does not have any poles which have positive real parts, i.e., all the poles
reside in the left-half plane. Based on this information, it can be concluded that the
system is stable, as shown in MATLAB as well. For veriﬁcation, the poles of the
Fig. 9.64 Output—Routh’s criterion
9.6
Stability Analysis
271

system have been determined using root(), which determined the roots of the
characteristic equation. From the output, it can be observed that all the poles have
negative real parts and match with the previous hypothesis as well as the outcome.
9.6.2
Root Locus
Root locus represents a graphical method that illustrates the locus of the roots of a
characteristic equation in an s-plane followed by the changes of system parameters.
By observing the root locus of a system, the stability of a system can be decided. In
the next example, the root loci of a stable system, an unstable system, and a
marginally stable system are shown using the following MATLAB command.
MATLAB command for producing root locus from a transfer function:
rlocus(sys)
Here, sys is the transfer function.
9.6.2.1
MATLAB Example 9.22: Root Locus
Produce the root locus of the following systems and comment on the stability:
(a) G sð Þ ¼
50
s2þ12sþ11
(b) G sð Þ ¼
sþ1
s3þ9s2
(c) G sð Þ ¼
sþ1
s320s210sþ1
The MATLAB code for the example is given in Fig. 9.65.
Fig. 9.65 Code—Root locus
272
9
Control System and MATLAB

The root loci of the systems (a), (b), and (c) are provided in Figs. 9.66, 9.67, and
9.68, respectively.
Fig. 9.66 Output—Root locus for stable system
Fig. 9.67 Output—Root locus for marginally stable system
9.6
Stability Analysis
273

Comment for Fig. 9.66 The system is stable, as the poles lie on the right-half plane.
Comment for Fig. 9.67 The system is marginally stable, as one of the poles lies on
the imaginary axis, and the rest reside in the left-half plane.
Comment for Fig. 9.68 The system is unstable, as one of the poles lies in the right-
half plane.
9.6.3
Bode Plot
The Bode plot is a graphical representation of the frequency response of a system,
which consists of two parts—Bode magnitude plot and Bode phase plot. To under-
stand the Bode plot, some terminologies need to be deﬁned ﬁrst, such as:
Phase Crossover Frequency The phase crossover frequency, ωpc, is the frequency
where the phase shift is equal to 180

.
Gain Crossover Frequency The gain crossover frequency, ωgc, is the frequency
where the amplitude ratio is 1, or when log modulus is equal to 0.
Fig. 9.68 Output—Root locus for unstable system
274
9
Control System and MATLAB

Gain Margin The gain margin of a system can be deﬁned as in Eq. (9.64):
Gain Margin ¼
1
G iωpc


		
		
ð9:64Þ
Phase Margin The phase margin of a system can be deﬁned as in Eq. (9.65):
Phase Margin ¼ 180

 þ arg G iωgc




:
ð9:65Þ
The stability conditions according to the Bode plot are given below:
•
Stable System: Both the margins should be positive or the phase margin should be
greater than the gain margin.
•
Marginal Stable System: Both the margins should be zero or the phase margin
should be equal to the gain margin.
•
Unstable System: If any of them is negative or phase margin should be less than
the gain margin.
The MATLAB command for producing Bode plot of a system is as follows:
MATLAB command for producing bode plot from a transfer function:
margin(sys)
Here, sys is the transfer function.
9.6.3.1
MATLAB Example 9.23: Bode Plot
Produce the Bode plot of the following systems and comment on the stability:
Fig. 9.69 Code—Bode plot
9.6
Stability Analysis
275

Fig. 9.70 Bode diagram for stable system
Fig. 9.71 Bode diagram for unstable system
276
9
Control System and MATLAB

(a) G sð Þ ¼
50
s2þ12sþ11
(b) G sð Þ ¼
sþ1
s320s210sþ1
The MATLAB code for the example is given in Fig. 9.69.
The Bode plots of the systems (a) and (b) are provided in Figs. 9.70 and 9.71,
respectively.
Comment for Fig. 9.70 The system is stable, as both the margins are positive.
Comment for Fig. 9.71 The system is unstable, as the phase margin is negative.
9.6.4
Nyquist Plot
Nyquist plot is a graphical representation of the frequency response of a system
drawn in polar coordinates. In the polar coordinate, the gain of the transfer function
of a system indicates the radial points, whereas the phase represents the angular
coordinates in a Nyquist plot.
The stability criteria of the Nyquist plot can be deﬁned by the following rules:
•
If the contour does not enclose (21, 0) point, and the number of poles in
the right-half plane is zero, the system is stable.
•
If the number of clockwise encirclements by the contour of (21,0) point
is equivalent to the number of poles in the right-half plane, the system
is stable.
In summary, if the following formula is satisﬁed, the system is stable;
otherwise, it is unstable:
Z ¼ N þ P
Here,
Z ¼ number of zeroes in the right-half plane
P ¼ number of poles in the right-half plane
N ¼ number of encirclements of (1,0) point by the Nyquist contour
The MATLAB command for producing the Nyquist plot of a system is as
follows:
MATLAB command for producing Nyquist plot from a transfer function:
nyquist(sys)
Here, sys is the transfer function.
9.6
Stability Analysis
277

9.6.4.1
MATLAB Example 9.24: Nyquist Plot
Produce the Nyquist plot of the following systems and comment on the stability:
(a) G sð Þ ¼
50
s2þ12sþ11
(b) G sð Þ ¼
400
s34s250sþ45
The MATLAB code for the example is given in Fig. 9.72.
The Nyquist plots of the systems (a) and (b) are provided in Figs. 9.73 and 9.74,
respectively.
Comment for Fig. 9.73 The contour does not encircle (1, 0); hence, N ¼ 0. In
addition, Z ¼ 0 and P ¼ 0. The system satisﬁes the Nyquist stability criteria:
Z ¼ N + P; therefore, the system is stable.
Comment for Fig.9.74 The contour encircles (1, 0) two times; hence, N ¼ 2. In
addition, Z ¼ 0 and P ¼ 0. The system does not satisfy the Nyquist stability criteria:
Z ¼ N + P. Therefore, the system is unstable.
9.7
Conclusion
In this chapter, various aspects of control systems are presented with the combina-
tion of both theoretical knowledge and practical implementations via MATLAB.
The chapter initiates by introducing both frequency and time domain responses of
physical systems followed by the concept of state-space representations. In addition,
controllability and observability are also covered here. The chapter is concluded by
presenting an overview of the stability analysis of any physical system. While
introducing all of these topics of control systems, the chapter not only takes the
Fig. 9.72 Code—Nyquist plot
278
9
Control System and MATLAB

Fig. 9.74 Nyquist diagram for unstable system
Fig. 9.73 Nyquist diagram for stable system
9.7
Conclusion
279

theoretical approach but also provides MATLAB illustrations to facilitate the reader
to understand. The objective of this chapter is to help the reader to visualize the
important concepts of control systems and realize the applications in the engineering
domain with the aid of MATLAB.
Exercise 9
1. Deﬁne transfer function. How does a transfer function mathematically represent a
control system?
2. What are the engineering applications of Laplace transform and inverse Laplace
transform?
3. Explain the following functions with examples:
(a) laplace()
(b) residue()
(c) limit()
(d) ss()
(e) pzmap()
4. Consider the given transfer functions:
(a) G sð Þ ¼
s12
s24sþ1
(b) G sð Þ ¼
s26sþ52
2s215s25
(c) G sð Þ ¼ s3þ5sþ12
6s24sþ1
Perform the following using MATLAB:
(i) Determine the pole and zero of G(s).
(ii) Demonstrate the pole-zero map.
(iii) Determine the inverse Laplace of G(s). Perform Laplace on the result to
verify if the output returns G(s). (The resulting fractions may be hard to
comprehend; use pretty() function to display the results in a more convenient
manner.)
(iv) What is the DC gain for the transfer function?
(v) Decompose the transfer function into partial fractions (sometimes, the result
may return large fraction values. To convert the large fractions with symbols
into decimals of x signiﬁcant values, use the function vpa( function, x). To
convert large numeric fractions into decimals, use the function double().
280
9
Control System and MATLAB

5. The following transfer functions have K ¼ 2. From the functions, classify which
are overdamped, critically damped, underdamped, or underdamped. Determine
the step response, pole-zero diagram, rise time, settling time, overshoot, and peak
time using MATLAB.
(a) G sð Þ ¼
18
s2þ12sþ9
(b) G sð Þ ¼
196
2s2þ14sþ98
(c) G sð Þ ¼
8
s2þ4sþ4
(d) G sð Þ ¼
6
3s2þ3
6. In the following circuit in Fig. 9.75, given that R ¼ 2 ohm, C ¼ 0.6 F,
and L ¼ 1.5 H. The output and input are vL and v(t), respectively. The state
variables are vC and i.
(a) Determine the state-space representation of the circuit.
(b) Determine the transfer function of the system from the state-space model.
(c) Verify the result of (b) by using the state-space to transfer function conversion
formula manually.
7. Using the MATLAB code used to determine the Routh’s criteria in Example 9.21,
show whether the following characteristic polynomials are stable. Perform veri-
ﬁcation of the result by determining the root of the characteristic equation:
(a) s5 + 3s4 + 27s3 + 45s2  60
(b) s4 + 21s3 + 36s2 + 5s + 1.
8. Produce the (i) root locus, (ii) Bode plot, and (iii) Nyquist plot of the following
systems and comment on the stability based on their respective graphical output:
(a) G sð Þ ¼
36
2s2þ14sþ61
(b) G sð Þ ¼
4sþ1
s3þ2sþ6
(c) G sð Þ ¼
s22sþ1
7s3þ11s25sþ1
Fig. 9.75 An RLC series
circuit
Exercise 9
281

Chapter 10
Optimization Problem
10.1
Introduction
Optimization is a pivotal aspect in the ﬁeld of engineering. To determine the best
possible outcome subjected to different conditions or constraints, optimization is one
of the best processes. When a certain problem does not have a perfect solution,
optimization has the capability to come with different good answers to follow. In the
optimization process, the very ﬁrst step is to deﬁne the problem mathematically,
which leads to two basic parts of any optimization problem—objective function and
condition. The objective function refers to our objective in terms of the mathematical
equation with single or multiple decision variables that affect the outcome of the
objective function. The goal of any optimization algorithm is to either minimize or
maximize the outcome of the objective function by optimizing the values of decision
variables. However, to maximize or minimize a function, there is another part that
needs to be incorporated in an optimization problem, which is the condition. For a
certain boundary or range of the variables, the optimization problem can be solved.
An optimization problem can also be subjected to different constraints. Based on the
number of variables of an objective function, it can be classiﬁed into two classes in
general—one-dimensional optimization and multidimensional optimization. The
mathematical nature of objective function can also be used to categorize optimiza-
tion problems into three classes—linear programming, quadratic programming, and
nonlinear programming. To implement optimization problems, MATLAB can be
utilized efﬁciently, as it provides in-built functions that can be used to solve different
optimization problems.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_10
283

10.2
One-Dimensional Optimization
In one-dimensional optimization, the objective function has a single decision vari-
able. The goal is to ﬁnd the value of the decision variable for which the objective
function will be maximized or minimized. Mathematically, such an optimization
problem can be deﬁned as follows:
Obj ¼ f x
ð Þ;
subject to xupper < x < xlower
ð10:1Þ
Here, f(x) is the objective function with decision variable x. And the inequality
term is the condition that needs to be satisﬁed for the optimization solution.
To solve the one-dimensional optimization problem, different algorithms are
available, such as golden section search, Fibonacci search, parabolic interpolation
search, etc. In MATLAB, one-dimensional optimization can be performed by
utilizing the built-in function fminbd(). The parameters of this function are listed
below:
MATLAB command for one-dimensional optimization:
x, value
½
 ¼ fminbd obj, xlow, xup


Inputs: obj refers to the objective function; xlow and xup are the lower and
upper limits of the decision variable x.
Outputs: x is the value of the decision variable for which obj is minimized.
value indicates the minimized value of obj.
It is to be noted that fminbd() uses a combination of both golden section search
and parabolic interpolation search algorithms for solving one-dimensional optimi-
zation problems.
10.2.1
MATLAB Example 10.1: One-Dimensional
Optimization
Consider the following one-dimensional optimization problem for ﬁnding the value
of the optimized decision variable and the minimized value of the objective function.
Obj ¼ 2x þ ex;
284
10
Optimization Problem

subject to  5 < x < 10
ð10:2Þ
The MATLAB code and its output for the above optimization problem are
provided in Figs. 10.1 and 10.2, respectively.
Output
It is to be noted that the lower limit and the upper limit of the decision boundary
do not include the boundary values in the condition. Therefore, while we are deﬁning
the boundary of x from –5 to 10, the fminbd() considers the values of x as any values
within the range, but does not include the boundary values itself, i.e., –5 and 10.
10.3
Multidimensional Optimization
In a multidimensional optimization problem, the objective function is a function of
multiple decision variables. The objective function can be subjected to different
linear or nonlinear constraints, with boundary conditions. The generalized form of a
multidimensional optimization problem can be deﬁned as follows, with different
types of constraints and boundary conditions:
obj ¼ f x 1
ð Þ, x 2
ð Þ, . . . . . . x n
ð Þ
ð
Þ
Fig. 10.1 Code—One-dimensional optimization
Fig. 10.2 Output—One-dimensional optimization
10.3
Multidimensional Optimization
285

subject to :
Boundary condition : xlow  x  xup
Linear inequality constraint : A ∙x  B
Linear equality constraint : AEQ ∙x ¼ BEQ
Nonlinear inequality constraint : C ∙x  0
Nonlinear equality constraint : CEQ ∙x ¼ 0
ð10:3Þ
To solve such an optimization problem, MATLAB has a built-in function called
fmincon(). For the above-mentioned generalized format of a multidimensional
optimization problem, the MATLAB command can be written as follows:
MATLAB command for multidimensional optimization:
x, value
½
 ¼ fmincon obj, xo, A, B, AEQ, BEQ, xlow, xup, nonLinearConstraint


Inputs:
obj refers to the objective function with multiple variables, which is
represented by a vector or matrix, x.
xo is the initial values of the decision variables, which is also represented by
a vector or matrix.
A is a matrix containing the coefﬁcients of x of a linear inequality
constraint.
B is a vector containing the constant of the linear inequality constraint.
AEQ is a matrix incorporating the coefﬁcients of x of a linear equality
constraint.
BEQ is a vector containing the constant of the linear equality constraint.
xlow and xup are lower and upper limits of the decision variables x, which is
given input as two matrices.
nonLinearConstraint indicates the nonlinear equality constraint, CEQ, and
the nonlinear inequality constraints, C, of x.
Outputs: x is the vector or matrix of the decision variables for which obj is
minimized.
value indicates the minimized value of obj that satisﬁes all the linear and
nonlinear constraints with decision boundary conditions.
286
10
Optimization Problem

10.3.1
MATLAB Example 10.2: Multidimensional
Optimization
Solve the following multidimensional optimization problem using MATLAB:
obj x
ð Þ ¼ x2
1 þ 2x1x2 þ x2
3 þ ex2
subject to :
1  x1  5; 0  x2  5; 0  x3  7;
Fig. 10.3 Code—Creating function for multidimensional optimization
Fig. 10.4 Code—Multidimensional optimization
10.3
Multidimensional Optimization
287

x1 þ x2 þ x3 < 10;
x1 þ 2x3 ¼ 4;
x2
1 þ x2
2 þ x2
3 ¼ 12;
x1x2 þ x2x3  30;
ð10:4Þ
To solve the above-mentioned problem, a function has been created to address the
nonlinear constraints, which must be satisﬁed while optimizing. C and C _ EQ
represent a value to check whether the optimized values of the decision variables are
satisfying the conditions or not. The function has been named “nonlinear_constraint.
m,” which will be used as an input in the later fmincon() function.
The MATLAB code for the optimization problem is given in Figs. 10.3 and 10.4,
and the output is given in Fig. 10.5.
Output
10.4
Linear Programming Optimization
The mathematical nature of the objective function can be utilized to classify opti-
mization problems into three categories—linear programming, quadratic program-
ming, and nonlinear programming optimization.
Linear programming optimization deals with linear objective function with linear
constraints for optimization. The generalized format of linear programming optimi-
zation can be deﬁned as follows:
obj ¼ obj x
ð Þ
Fig. 10.5 Output—Multidimensional optimization
288
10
Optimization Problem

subject to :
Boundary condition : xlow  x  xup
Linear inequality constraint : A ∙x  B
Linear equality constraint : AEQ ∙x ¼ BEQ
ð10:5Þ
In MATLAB, there is a built-in function for solving linear programming optimi-
zation, which is shown below:
MATLAB command for linear programming optimization:
x, value
½
 ¼ linprog obj, A, B, AEQ, BEQ, xlow, xup


Inputs:
obj refers to the objective function with multiple variables, which is
represented by a vector or matrix, x.
A is a matrix containing the coefﬁcients of x of a linear inequality
constraint.
B is a vector containing the constant of the linear inequality constraint.
AEQ is a matrix incorporating the coefﬁcients of x of a linear equality
constraint.
BEQ is a vector containing the constant of the linear equality constraint.
xlow and xup are lower and upper limits of the decision variables x, which is
given input as two matrices.
Outputs: x is the vector or matrix of the decision variables for which obj is
minimized.
value indicates the minimized value of obj that satisﬁes all the linear and
nonlinear constraints with decision boundary conditions.
10.4.1
MATLAB Example 10.3: Linear Programming
Optimization
Solve the following multidimensional optimization problem using MATLAB.
obj x
ð Þ ¼ 2x1 þ 3x2 þ x3
subject to :
1  x1  5; 0  x2  10; 0  x3  15;
10.4
Linear Programming Optimization
289

x1 þ x2 þ x3  15;
x1  4x2 þ x3  8;
x1 þ 2x3 ¼ 4;
ð10:6Þ
The MATLAB code and the output for the optimization problem are given in
Figs. 10.6 and 10.7, respectively.
Output
Fig. 10.6 Code—Linear programming optimization
Fig. 10.7 Output—Linear programming optimization
290
10
Optimization Problem

10.5
Quadratic Programming Optimization
In quadratic optimization, the objective function is quadratic in nature; however, the
constraints are linear. The general format of a quadratic programming optimization
can be represented as follows:
obj x
ð Þ ¼ 0:5xTHx þ FTx
subject to :
Boundary condition : xlow  x  xup
Linear inequality constraint : A ∙x  B
Linear equality constraint : AEQ ∙x ¼ BEQ
ð10:7Þ
In MATLAB, there is a built-in function for solving quadratic programming
optimization, which is shown below:
MATLAB command for quadratic programming optimization:
x, value
½
 ¼ quadprog H, F, A, B, AEQ, BEQ, xlow, xup


Inputs:
H refers to the Hessian matrix, which is determined by using the following
formula:
HF
i,j ¼
∂2F
∂xi∂x j
:
F is a vector containing the coefﬁcients of the linear variables.
A is a matrix containing the coefﬁcients of x of a linear inequality
constraint.
B is a vector containing the constant of the linear inequality constraint,
AEQ is a matrix incorporating the coefﬁcients of x of a linear equality
constraint.
BEQ is a vector containing the constant of the linear equality constraint.
xlow and xup are lower and upper limits of the decision variables x, which is
given input as two matrices.
Outputs: x is the vector or matrix of the decision variables for which obj is
minimized.
value indicates the minimized value of obj that satisﬁes all the linear and
nonlinear constraints with decision boundary conditions.
10.5
Quadratic Programming Optimization
291

10.5.1
MATLAB Example 10.4: Quadratic Programming
Optimization
Consider the following objective function in Eq. (10.8) and optimize it using
MATLAB:
obj x
ð Þ ¼ 2x2
1 þ 3x2
2 þ 0:5x1x2  4x1 þ x2
subject to:
1  x1  5; 0  x2  10;
x1 þ x2  15;
x1  4x2  8;
x1 þ 2x2 ¼ 4:
ð10:8Þ
The MATLAB code and the output for the optimization problem are given in
Figs. 10.8 and 10.9, respectively.
Output
Fig. 10.8 Code—Quadratic programming optimization
292
10
Optimization Problem

10.6
Nonlinear Programming Optimization
For nonlinear programming optimization, the objective function needs to be a
nonlinear function subjected to either linear constraints or nonlinear constraints. In
this type of optimization problem, both linear and nonlinear constraints may also be
included. A nonlinear programming optimization problem can be solved by using
fmincon() function, as explained earlier in Sect. 10.3. The difference between
multidimensional
and
nonlinear
programming
optimization
is
that
in
multidimensional optimization, it is not required for the objective function to be
nonlinear; conversely, in nonlinear programming, the objective function must have
to be nonlinear.
10.7
Li-ion Battery Optimization Problem and Solutions
Consider a Li-ion battery system, whose sizing needs to be minimized in terms of
minimized modules’ number. Here, the minimized modules’ number indicates the
most optimized combination of battery modules connected in row and column to
form a pack, which is capable of providing a predetermined discharge rate by
maintaining an acceptable nominal voltage range. For this particular problem, the
battery pack needs to be designed in such a way, so that the discharge rate always
remains 100 kWh with an overall output voltage of 150–400 V. A small variation of
1% of the discharge rate may be allowed for this problem. The aim is to solve an
optimization problem for the battery sizing, where the number of rows and columns
for the modules to form a battery pack will be minimized by satisfying the required
conditions. a simple illustration of a battery pack is given in Fig. 10.10.
The following parameters are going to be considered for the problem:
a. Number of cells per module, cellmod ¼ 4
b. The number of rows in a battery pack, row
c. The number of columns in a battery pack, col
Fig. 10.9 Code—Quadratic programming optimization
10.7
Li-ion Battery Optimization Problem and Solutions
293

d. The nominal voltage per module, volmod ¼ 12 V
e. The maximum discharge rate per module, dischargecell ¼ 90 W
The optimization problem can be deﬁned mathematically, by utilizing the above-
mentioned parameters, as follows:
Fig. 10.10 A Li-ion battery pack
Fig. 10.11 Code—Creating function for the Li-ion battery optimization problem
294
10
Optimization Problem

obj row, col
ð
Þ ¼ row  col
Subject to :
150 V  volmod  col  400 V
Fig. 10.12 Code—Li-ion battery optimization problem
Fig. 10.13 Output—Li-ion battery optimization problem
10.7
Li-ion Battery Optimization Problem and Solutions
295

99:5 kWh  dischargecell  row  col  cellmod  100:5 kWh
ð10:9Þ
The MATLAB code for solving the battery optimization problem is given in
Figs. 10.11 and 10.12, and the output of the code is given in Fig. 10.13.
MATLAB Code
Output
10.8
Conclusion
From this chapter, the readers can gain knowledge on optimization problems, and
their solving procedures via MATLAB. The categorizations of different optimiza-
tion problems are enlisted here based on the variables and the nature of objective
functions. For each of the optimization problems, MATLAB has built-in functions,
which have been explained with necessary illustrations in this chapter. A sample
optimization problem directly related to the engineering ﬁeld is incorporated at the
end of the chapter to walk through how a real optimization problem can be solved
utilizing MATLAB. This chapter will greatly help the readers to attain a strong
fundamental knowledge of various optimization problems.
Exercise 10
1. What
are
the
differences
between
one-dimensional
optimization
and
multidimensional optimization?
2. (a) Consider a function f(x) ¼ 6x4  11x + 10. Determine the optimized value of
the decision variable and minimized value of the objective function at a range
of12 < x < 12.
(b) Consider a function f(x) ¼  x5 + 4x3 + 7x2  15x. Determine the optimized
value of the decision variable and minimized value of the objective function at a
range of 0 < x < 1.
3. Using the same function nonlinear _ constraint() and the same linear and
nonlinearity inequality and equality constrains, and initial values, replicate Exam-
ple 10.2 for the following limits:
a. 4 < x1 < 7;  2 < x2 < 9;  1 < x3 < 10
b. 1 < x1 < 4;  3 < x2 < 3;  7 < x3 <  3
296
10
Optimization Problem

Mention which of the programs will successfully run, and which one will
show errors. For the successful programs, show the optimized values of the
decision variables, and the minimized values of the objective function. For the
programs that stopped prematurely or converged to an infeasible point, explain
why these errors occurred.
4. Solve the following multidimensional optimization problem using linprog().
Comment on the feasibility of the solution.
a. obj(x) ¼ 4x1 + 6x2 + 2x3
subject to :
0  x1  10;  3  x2  9; 0  x3  12;
4x1 þ 5x2 þ 8x3  30;
7x1 þ 12x2 þ 3x3  65;
2x1 þ 3x2 þ 5x3 ¼ 11;
b. obj(x) ¼ 5x1 + 7x2  2x3
subject to :
3  x1  4;  2  x2  7; 2  x3  11;
2x1 þ x2 þ 3x3  20;
4x1 þ 2x2  10;
3x1 þ x2  2x3 ¼ 16;
c. obj(x) ¼ 4x1 + 9x2 + x3
subject to:
2  x1  6;  10  x2  10; 0  x3  22;
x1 þ x2 þ x3  26;
8x2  3x3  15;
x1 þ 9x2 þ 4x3 ¼ 18;
Exercise 10
297

5. (a) Given the Hessian matrix of the quadratic objective function [10 3; 3 7] with a
vector [–5;3] which contains the coefﬁcients of the linear variables, determine if
the function has the minimum that satisﬁes the constrains. If so, ﬁnd the opti-
mized value of the decision variables x1 and x2 for the function, and determine the
minimized value of the objective function. The function maintains the following
constraints:
subject to:
0  x1  8;  5  x2  5;
4x1 þ 5x2  21;
3x1  9x2  15;
5x1 þ 3x2 ¼ 12;
(b) Given the Hessian matrix of the quadratic objective function [1 0.24; 0.24 5]
with a vector [1;6] which contains the coefﬁcients of the linear variables, determine
if the function has the minimum that satisﬁes the constrains. If so, ﬁnd the optimized
value of the decision variables x1 and x2 for the function, and determine the
minimized value of the objective function. The function maintains the following
constraints:
subject to:
4  x1  4; 0  x2  10;
6x1  7x2  17;
x1 þ 12x2  10;
3x1 þ 13x2 ¼ 21;
298
10
Optimization Problem

Chapter 11
App Designer and Graphical User Interface
in MATLAB
11.1
Introduction
App Designer is a product of MATLAB that provides an environment to create
professional apps. It is an interactive environment with a sophisticated component
library that can be used to build any desired app. The programming platform enables
the users to deﬁne the behavior of the app. It is a new modiﬁed and improved version
of the previous Graphical User Interface Design Environment (GUIDE). In future
releases of MATLAB, GUIDE will no longer be a part of MATLAB and will be
completely replaced by App Designer (https://www.mathworks.com/products/
matlab/app-designer/comparing-guide-and-app-designer.html).
However,
the
GUIDE apps will run in MATLAB without any editing feature.
11.2
App Designer
To initiate App Designer in MATLAB, the ﬁrst task is to open the App Designer
window by typing appdesigner command in the command window (Fig. 11.1). After
pressing “Enter,” the “App Designer Start Page” (Fig. 11.2) will appear.
From the start page, any example can be loaded for the ﬁrst-time user. To start a
new blank app, click on the “Blank App” option from the start page. By clicking
“Open” from the left panel of the start page, any existing app can be loaded using the
App Designer. The ﬁle extension of an App Designer is “.mlapp.”
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_11
299

11.2.1
Basic Layout of App Designer
After creating a blank app, the graphical user interface of the App Designer will
appear. In the basic layout of the App Designer, two different views are available—
design view and code view. In the design view, the structure of an app can be
designed by utilizing the components. In the code view, the individual building
blocks, or components, can be customized and programmed by writing MATLAB
code. The basic layout in these two view modes is illustrated in Figs. 11.3 and 11.4.
In the design view layout of App Designer, there is a Component Library tab at
the left panel, where all the available components for designing an app can be found.
Using this library, an app can be designed in the “Design window.” The components
dragged on the Design window will appear in the component browser. By selecting
each component from the component browser, the individual parameters can be
deﬁned from the “Inspect” tab.
Fig. 11.1 appdesigner command
Fig. 11.2 App Designer Start Page
300
11
App Designer and Graphical User Interface in MATLAB

Fig. 11.3 App Designer Design Window
Fig. 11.4 App Designer Program Window
11.2
App Designer
301

After completing the design of an app in the design view mode, the next step is to
shift the layout to the code view mode. In the code view layout, there is a code
browser in the left panel. Below the code browser tab, the app layout feature is
available, where the designed app created in the design view will be shown. In the
middle, there is a program window, where the relevant codes need to be written to
conﬁgure each component used in an app. A default code is already available in the
program window to deﬁne the basic properties of an app. However, when a partic-
ular app needs to be designed, each of the added components requires to be
conﬁgured by updating the codes in the program window. The steps of creating an
entire app will be discussed in more detail in the later sections.
At the end of the app design, the “Run” button is available to test the entire app.
The app can be saved by utilizing the “Save” button. These two buttons are available
on the upper strip of the app design available both in the design view and code view
modes.
11.2.2
Components of App Designer
In the Component Library of the App Designer in design view mode, all the
components are listed and categorized among Common, Containers, Figure tools,
Instrumentation, and Aerospace. In each of these sections, multiple components are
available for designing an app. In Fig. 11.5, all the available components are listed.
Fig. 11.5 Components of App Designer
302
11
App Designer and Graphical User Interface in MATLAB

11.2.3
Detecting and Correcting Errors
After pressing the “Run” button, the designed app will be demonstrated in the App
Designer, where the user can test the app. If errors occurred in the coding part,
MATLAB will automatically detect the errors and will explain the reason for such
error occurrence. An example is given in Fig. 11.6, where an error tab appears on the
exact place where the error occurs, and it also explains the reason for this error.
If the error can be detected automatically, and the reason is explained, it is easier
to ﬁnd a solution to correct the errors. Based on the reasoning, the corrections are
made which will differ in each case.
11.2.4
Designing and Programming a GUI with App
Designer
In the previous section, the layout and the components are explained. In this section,
some apps will be designed to explain the entire process of app designing step-by-
step.
Example 11.1 Designing a calculator Design View
Step 1: From the component library, drag the following components into the
design window:
a. Edit ﬁeld (numeric)
b. Button
c. Panel
Step 2: Select each component from the component browser, and edit the
parameters from the Inspection tab. For example, the labels of the three Edit Field
(Numeric) components have been renamed as “Enter Number,” “Enter Number,”
and “Output.” Four push buttons have been renamed as “ADD,” “SUB,” “MUL,”
and “DIV.” In the component browser, the push button will appear as “app.
ADDButton,” “app.SUBButton,” “app.MULButton,” and “app.DIVButton.” The
three Edit Field (Numeric) components have also been renamed in the component
browser as “app.Num1,” “app.Num2,” and “app.out” for convenience.
Step 3: Select each of the components from the component browser to conﬁgure
them by coding. For example, consider conﬁguring the “ADD” push button. As the
name of the push button was renamed as “ADD” earlier, it will appear as “app.
Fig. 11.6 Error Tab
11.2
App Designer
303

ADDButtton” in the component browser. The next goal is to write a callback
function, whose objective is to perform a certain task whenever the button is pushed.
To conﬁgure such a program, right-click on the “app.ADDButton” and select the
option “Callbacks” followed by “AddButtonPushedFcn callback,” as shown in
Fig. 11.7.
Step 4: The previous step will shift the layout to code view mode, where a
function will be created automatically for the “ADDButton.” To conﬁgure this
pushed button, the user can write their codes within the function. In the design
view, the overall design of the app can be made. For conﬁguring each component,
the user has to shift to the coding view mode. The app layout of the calculator app is
given in Fig. 11.8.
In the above app, the user can provide two numbers as input. Four push buttons
are available for performing addition, subtraction, multiplication, and division. The
output will provide the result that corresponds to the pushed button. The entire layout
Fig. 11.7 Component Browser
Fig. 11.8 App layout of calculator app
304
11
App Designer and Graphical User Interface in MATLAB

has been added in a panel, which has been dragged from the Component Library, and
renamed as “Calculator.” In the later part, this conﬁguration will be ensured via
MATLAB coding.
Code View
There are four push buttons, which need to be conﬁgured in such a way, so that they
can perform one of the four basic operations—addition, subtraction, multiplication,
and division—individually. In the previous section, it has been shown how to create
a callback function for a speciﬁc component. To recall, the step is to select a speciﬁc
component, such as “app.ADDButton” from the component browser, right-clicking
on it, and navigate to Callbacks!AddButtonPushedFcn callback. This step will
automatically create an “ADDButtonPushed” function as shown below in code view
mode (Fig. 11.9), where the white space indicates the place for writing our code to
assign a speciﬁc task that will be performed whenever the ADDButton will be
pushed.
In the above code, app.Num1.Value and app.Num2.Value indicate the two values
that will be provided as input by the user. The objective of the ADDButton is to
perform the addition operation between these two input numerical values, and assign
the output to the app.out.Value.
In the same manner, the other three push buttons can be conﬁgured by deﬁning
the functions for each component as shown in Fig. 11.10.
Fig. 11.9 Code—Addition Button
Fig. 11.10 Code—Subtraction, Multiplication, and Division Button
11.2
App Designer
305

Output
The last step is to press the “Run” button to create the ﬁnal app, and to test the
different outputs. To test whether the app is working in our designed way, two
numeric inputs have been provided, and four individual push buttons are pressed one
by one to check the different outputs. The results are shown in Fig. 11.11, which
justiﬁes that the calculator app is working perfectly.
Example 11.2 Risk warning app In a risk warning app, the objective is to show
warning through different colors of lamps indicating the level of risks. The risks are
assessed via a knob which indicates the level of risk starting from “Low” to “High”
including the “Off” condition as well. For each state of the knob, lamps of different
colors are utilized to demonstrate the level of warning. When the knob indicates the
“High” risk, a red alert lamp will get lit. For the “Medium” and “Low” levels in the
knob, the lamp colors will be yellow and green, respectively. During the “Off” level,
all the lights will be in dark mode.
Design View
In the design view, the components that have been chosen for the design of this app
are one knob, three lamps, and one panel. The design of the app is shown in
Fig. 11.12.
Coding View
After the design, the knob is conﬁgured by choosing the callback option, which
creates a function named knobValueChanged () in the code view. To address the
objective of the app, the following code (Fig. 11.13) is written to deﬁne the task of
the knobValueChanged () function:
Fig. 11.11 Output—Calculator app
306
11
App Designer and Graphical User Interface in MATLAB

Output
After running the app, it is tested for different scenarios. In the ﬁrst scenario, the
knob is in the “Off” state, and all the lamps are in black, indicating no warning. In the
second scenario, the knob is in the “Low” level, which initiates a green lamp
indicating a safe zone. The yellow lamp and the red lamp can be seen, when the
knob touches the “Medium” and “High” level, respectively. The yellow demon-
strates moderate risk, and the red refers to high risk. The output is shown in
Fig. 11.14.
Fig. 11.12 App layout of risk warning app
Fig. 11.13 Code—Risk levels in the risk warning app
11.2
App Designer
307

Example 11.3 App for step response of a second-order system The generalized
formula of the transfer function of a second-order system can be represented as
follows:
G sð Þ ¼
Kωn
s2 þ 2ζωns þ ω2
n
ð11:1Þ
In Eq. (11.1), K is the gain; ωn is the natural frequency; and ζ refers to the
damping ratio. Based on the different values of ζ, the second-order systems can be
categorized among different types, such as overdamped, underdamped, critically
damped, and negative damped systems. The goal of this app is to plot the step
response of a second-order system with the given inputs of K, ωn,and ζ, and also
showing the types of the system based on damping ratio.
Design View
The components used for the design of the app layout are as follows:
a. Axes: for plotting the step response
b. Two edit ﬁeld (numeric): for taking input K, ωn
c. Slider: to vary the value of ζ
d. Edit ﬁeld (numeric): to display the value of ζ that will be selected by the slider
e. Edit ﬁeld (string): To display the type of the system based on the damping ratio
f. Panel: To incorporate the entire design in a single panel
The app layout design is shown in Fig. 11.15.
Fig. 11.14 Output—Risk warning app
308
11
App Designer and Graphical User Interface in MATLAB

Coding View
The value of K and ωn (omega_n) will be considered as the values of the two “Edit
Field (Numeric),” which are deﬁned in the following code as “app.K.Value” and
“app.omega_n.Value.” In the AmplitudeSliderValueChanged (), the value of the
slider is assigned as the value of zeta. All these values are utilized to calculate the
transfer function by using the generalized transfer function formula of the second-
order system. Later, the plot command is used to generate the step response and
show it in the axes component. Another “Edit Field (String)” is deﬁned to show the
type of the system, which can be determined based on the selected value of zeta.
According to the code, ﬁve different types of system are deﬁned based on the values
of zeta, which are:
1. Overdamped system: ζ > 1
2. Underdamped system: 0 < ζ < 1
3. Critically damped system: ζ ¼ 1
4. Undamped system: ζ ¼ 0
5. Negative damped system: ζ < 0
The added code to conﬁgure the app is provided in Figs. 11.16 and 11.17.
Output
After pressing the “Run” button, the step response of the second-order systems app
will appear. To test the app, the values of K and omega_n are chosen as 2 and
5, respectively. After providing the input values of K and omega_n, the slider
position is changed to select different values of zeta. Based on the change made
by the slider, the speciﬁc value of the zeta that is selected will appear on the “Edit
Fig. 11.15 App layout of step response of second-order systems app
11.2
App Designer
309

Field (Numeric)” named zeta. When the value of zeta will be selected, the step
response of the second-order system will be plotted on the axes component. The type
of the system will also appear on “Edit Field (String)” named System. The values of
zeta are selected in different ranges that deﬁne different types of systems that have
been described earlier. The step responses of four such types are produced one by
one to verify the performance of the app. The produced outputs are shown in
Fig. 11.18.
Fig. 11.16 Code—Step response of second-order systems app
Fig. 11.17 Code—Step response of second-order systems app
310
11
App Designer and Graphical User Interface in MATLAB

11.3
App Designer vs GUIDE
App Designer is the new improved version of MATLAB that was launched in 2016.
GUIDE is an old version of app building technology that was built based on third-
party technologies. However, in the App Designer, MATLAB has improved the
canvas and the environment with increased library components. The robustness of
the programming in the App Designer is also signiﬁcantly improved. Another
feature of the App Designer is its web-based sharing options. Any improvements
or updates of GUIDE have been stopped since 2016, and it will be completely
removed from the future version of MATLAB, according to an announcement of
MathWorks made in 2019 [1]. Therefore, it is imperative to migrate from GUIDE to
App Designer.
Fig. 11.18 Output—Step response of second-order systems app
11.3
App Designer vs GUIDE
311

11.4
GUIDE
GUIDE is an old version of app builder. App Designer has been built in 2016 to
replace GUIDE completely. Hence, it is recommended by MathWorks to migrate
from GUIDE to App Designer. For the current guide users, it is very important to
learn how to migrate from GUIDE to App Designer. In addition, the current GUIDE
ﬁles can be exported as M-ﬁles and Fig-ﬁles for future use. The procedures of
exporting any GUIDE app as MATLAB ﬁles and the migration procedures from
GUIDE to the App Designer will be explained in the later part in detail.
11.4.1
Exporting GUIDE App as MATLAB ﬁle
For exporting a GUIDE app as MATLAB ﬁles, the ﬁrst step is to select “File” and
navigate to the “Export to MATLAB-ﬁle” option, as shown in Fig. 11.19. By
clicking this option, the app will be exported as two separate ﬁles—“.m” ﬁle and
“.ﬁg” ﬁle.
Fig. 11.19 GUIDE app to MATLAB ﬁle
312
11
App Designer and Graphical User Interface in MATLAB

11.4.2
Migrate GUIDE App to App Designer
As in the future version of MATLAB “GUIDE” will be completely removed, it is
necessary to learn how to migrate to the App Designer from GUIDE. To migrate the
GUIDE app to App Designer, the ﬁrst step is to open GUIDE and create a new
graphical user interface. By writing a command “guide” in the command window,
the start page of GUIDE can be loaded. By clicking “Blank GUI (Default),” and
browsing the directory, a new GUIDE ﬁle can be created, which is shown in
Fig. 11.20.
After opening a GUIDE ﬁle, the migration can be started by using any of the two
options shown in Fig. 11.21.
Fig. 11.20 GUIDE Quick Start
Fig. 11.21 GUIDE to App Designer
11.4
GUIDE
313

The above-mentioned step will automatically load the “Guide to App Designer
Migration Tool,” and the migration will occur automatically.
11.5
Conclusion
This chapter mainly concentrates on illustrating how to use the App Designer for app
building. The chapter initiates by providing a brief overview of the basic layout and
components of the App Designer for the sake of new users. Later, step-by-step
guidance to build a calculator app is presented to help the readers understand how to
design and program to create a complete app. To make the readers more comfortable
in making more sophisticated apps, two more examples of app building are included
in the chapter. For the GUIDE users, the migration procedure for shifting to the App
Designer is incorporated in the last part of the chapter, as the GUIDE will be replaced
by the App Designer in a future release of MATLAB.
Exercise 11
1. What is the difference between the design view and code view of MATLAB App
Designer?
2. Mention some usage of MATLAB App Designer in engineering.
3. Create an app with a button and an edit ﬁeld (text) to show the sentence
“AppDesigner is Fun” once the “Click me” button is clicked. The app should
look like in Fig. 11.22.
Fig. 11.22 App Designer is
Fun
314
11
App Designer and Graphical User Interface in MATLAB

4. Replicate the calculator application that was built in Example 11.1.
a. Add another button with the title “POW” to calculate the power of the ﬁrst
number to the second one (FirstnumberSecond number).
b. Add another button with the title “Z,” which will perform the average of both
the numbers and display the result.
The application should look like in Fig. 11.23.
5. In this exercise, you have to create a stereo system volume knob with ﬁve lamps,
which will change the color as shown in Table 11.1.
The app should look like in Fig. 11.24 while changing the knob:
Fig. 11.23 MATLAB App Designer Calculator
Table 11.1 The status and lamp color of each knob level of the stereo system
Knob level
Status
Lamp color
0
None
No color
1–20
Low
Green
21–40
Mid-low
Green and cyan
41–60
Mid
Green, cyan, and yellow
61–80
Mid-high
Green, cyan, yellow, and magenta
81–100
High
Green, cyan, yellow, magenta, and red
Exercise 11
315

Fig. 11.24 Stereo System App Layout
316
11
App Designer and Graphical User Interface in MATLAB

Chapter 12
Introduction to Simulink
12.1
What Is Simulink?
Simulink is a platform that allows the modeling, design, and simulation of any
dynamic physical system or embedded system. It provides graphically programma-
ble blocks to create such designs. All the blocks can be customized according to
users’ preferences. Simulink and MATLAB can interact with each other, and thus
the behavior of a model can be changed and simulated simultaneously. In Simulink
Library Browser, several blocks are available based on numerous applications. The
user can also create additional customizable blocks deﬁned via MATLAB program-
ming. In addition, data ﬂow can also happen from Simulink to MATLAB and vice
versa. A tested Simulink model can be deployed in any embedded system for
practical use. Thus, Simulink works as a sophisticated platform to simulate any
dynamic system in real time via graphical tools; and with the participation of
MATLAB environment, such model can be analyzed and tested in-depth to improve
the model for practical implementation.
12.2
Starting Simulink
A Simulink can be started from the header toolstrip of MATLAB. In the toolbar,
click on the “Simulink” button as shown in Fig. 12.1.
Pressing on the “Simulink” button will create the appearance of the “Simulink
Start Page” shown in Fig. 12.2, from where a blank model can be produced by
selecting the “Blank Model!Create Model” option.
After choosing the “Create Model” option, the Simulink window will appear, as
shown in Fig. 12.3. In the Simulink window, there is a “Model Design Window” as
shown in the ﬁgure. This window is the core part, where any block diagram model
can be designed by utilizing components that will be available in the “Library
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_12
317

Fig. 12.1 Starting Simulink
Fig. 12.2 Simulink Start Page
Fig. 12.3 Simulink Window
318
12
Introduction to Simulink

Browser” as marked in the header toolstrip of Simulink in Fig. 12.3. There are two
other features in the Simulink starting window—Model Browser and Property
Inspector, which can be minimized from the starting page as users’ choice. Model
Browser incorporates the name of the Simulink model available in the browser.
Property Inspector can be used to customize the properties of the current Simulink
model, such as changing the name of the Simulink ﬁle.
“Simulink Starter Page” can be accessed from the command window as well by
typing the simulink command in there and pressing the enter key on the keyboard.
The rest of the procedures to create a blank Simulink model are the same as
mentioned earlier.
12.3
Basic Elements
In Simulink, two basic types of elements are available, with the use of which a
Simulink model can be designed. These two elements are blocks and lines.
12.3.1
Blocks
In Simulink, a dynamic model can be designed and simulated, by utilizing different
blocks available in Simulink Library Browser. In the Library Browser, multiple
blocks are listed based on different applications, which can be dragged into the
Model Design Window. Each of these blocks may have single or multiple ports
based on its deﬁnition. They have certain properties which can be customized
according to the users’ requirements. Multiple blocks can be used and customized
to create an entire model. In Fig. 12.4, a block named “Add” is dragged into the
Fig. 12.4 Simulink Blocks
12.3
Basic Elements
319

Simulink
Model
Design
window
from
“Simulink
Library
Browser!Simulink!Math Operations!Add.” In the “Add” block, there are
three ports, two of which are the input ports (left side of the block) and one is the
output port (right side of the block).
By double-clicking on the “Add” block, the following window will appear, from
where a description of the block can be found. In addition, this window can be used
to change any parameters according to the requirement.
From Fig. 12.5, it can be observed that the “Add” block can be used to perform
both addition and subtraction. For doing so, two more input blocks and one output
block to simulate the result are required. Therefore, two “Constant” blocks and one
“Display” block are dragged into the Simulink Model Design window to complete
the design as shown in Fig. 12.6.
By double-clicking on the “Constant” block, the value can be changed manually.
In the above example, the values for the two input blocks are chosen as 5 and 10. A
“Display” block is chosen to observe the output result after the simulation. Thus,
blocks can be integrated into a Simulink Model Design window to create any desired
model.
Fig. 12.5 Simulink Block Parameters
320
12
Introduction to Simulink

12.3.2
Lines
To complete the design of a model, lines are very essential to make the relevant
connections among different blocks. For example, in the previous model shown in
Fig. 12.6, the goal is to perform the addition operation. Although all of the required
blocks are gathered in the window, the model is not ready yet to run. All of the
blocks are in ﬂoat mode that needed to be connected via lines. A line connection can
only be made between an input and an output port. Therefore, the output ports of the
“Constant” blocks need to be connected with the input ports of the “Add” block.
Similarly, the output port of the “Add” block is required to be connected with the
input port of the “Display” block. The line connection can be made by dragging the
mouse close to the ports. In Fig. 12.7, all the necessary line connections are made to
complete the model design. The last part is to run the model for simulation which can
be performed by clicking on the “Run” button from the Simulink header toolstrip.
Fig. 12.6 Simulink Library Browser
12.3
Basic Elements
321

After the simulation, the output will be appeared on the display, as shown in
Fig. 12.7. Thus, blocks and lines constitute any basic model design in Simulink.
12.3.3
Other Features
Apart from blocks and lines, there are some other features which are very useful
while creating any Simulink design. Some of the features, such as Annotation, Show
Block Name, Fit to View, Area, Comment Out, and Uncomment, are covered in this
section.
12.3.3.1
Annotation
Annotation is used to create captions of the parts of a design or an entire design. To
write an annotation in the Simulink design window, the ﬁrst step is to click on the
“Annotation” option from the left strip of the design window as shown in Fig. 12.8.
The second step is to click on the Simulink design window, which will create an
appearance of a rectangular text box to write text, with a customization toolstrip
above. Type the annotation and click outside the text box to complete the annotation.
In Fig. 12.8, the ﬁnal appearance of an annotation is shown in the right ﬁgure. The
annotation can be dragged any place on the Simulink design window.
Fig. 12.7 Complete Simulink design for addition operation
322
12
Introduction to Simulink

12.3.3.2
Show Block Name
In Simulink, after dragging a block in the Simulink design window, the name of the
block disappears. To show the name of the block, select the block and move the
mouse over the three blue dots as marked by a red arrow in the ﬁrst ﬁgure of
Fig. 12.9. When the mouse is moved over the three blue dots, a small tools strip
will appear as shown in the second ﬁgure of Fig. 12.9. On that tool strip, move the
mouse over each symbol, which will create the appearance of the name of each
symbol. From there, select the option named “Show Block Name,” which will make
the appearance of the block name right below the blocks as shown in the third ﬁgure
of Fig. 12.9.
12.3.3.3
Fit to View
A useful feature of the Simulink is the “Fit to View” option. Consider the ﬁrst ﬁgure
of Fig. 12.10, where the design does not ﬁt to the entire window. By clicking on the
“Fit to View” icon from the left tools strip, the entire design automatically ﬁtted to
Fig. 12.8 Simulink Annotation
Fig. 12.9 Simulink Block Name
12.3
Basic Elements
323

the design window. The alternative way to make this happen is to click the “Space
button” after clicking on the Simulink design window.
If the user wants to make any particular block or part of a design to be ﬁtted in the
window, the procedure is to select the block or the parts of the design and type
“Space + F.”
12.3.3.4
Area
In Simulink, the Area feature is used to enclose a particular part of the design or the
entire design. The enclosed part under an Area can be moved by only moving the
Area window. In Fig. 12.11a, the procedure to enter an Area window into the
Simulink design window is shown, where the “Area” icon is selected from the left
tools strip. Later, the shape of the Area window can be adjusted according to the
preference of the user. When a particular design is enclosed by an “Area” window, as
shown in Fig. 12.11b, the entire design can be dragged by only dragging the Area
window (Fig. 12.11c). The Area window is also used to highlight an important part
of a design.
12.3.3.5
“Comment Out” and “Uncomment”
When designing a complete model in the Simulink, sometimes some blocks are
required to make inactive as testing procedures. It happens especially when design-
ing any complex model in the Simulink. As some blocks are required to make
inactive for a short while, it is not an efﬁcient way to delete the blocks for those
Fig. 12.10 Fit-to-view in Simulink
324
12
Introduction to Simulink

moments and reentered them again in the design. Another option is to leave the
blocks unconnected; however, sometimes it creates some errors while simulating.
Therefore, the best option in this scenario is to use the “Comment Out” and
“Uncomment” features of the Simulink. By default, all the blocks remain in
“Uncomment” mode while dragging to the Simulink design window. If the users
“Comment Out” any block, it will become inactive even when simulating the model.
When the users want to make the block active again, it can be done by changing the
mode into “Uncomment.” This is the most feasible option and becomes handy while
designing complex model. To make particular blocks inactive, the ﬁrst step is to
select these blocks, which will create the appearance of three blue dots. Move the
mouse over these blue dots, and a small ribbon of tools strip will appear with
multiple tools symbols. Move the mouse over these tools one by one and ﬁnd out
the option named “Comment Out.” Click on this option, and the selected blocks will
become fade. An example is given in Fig. 12.12, where the ﬁrst one is in the
“Uncomment” mode, while the second one is in the “Comment Out” mode. Even
Fig. 12.11 Simulink Area
12.3
Basic Elements
325

after running the simulation, the second one remains inactive in this mode as shown
in Fig. 12.12.
12.4
Simulink Library Browser
A Simulink Library Browser contains all the blocks that are available in the Simulink
arranged according to applications and operations. By clicking on the “Library
Browser” option from the Simulink header toolstrip, it can be accessed. The appear-
ance of the Simulink Library Browser window is provided in Fig. 12.13.
In the Simulink Browser window, different ﬁelds appeared on the left side, such
as Simulink, Aerospace Blockset, Audio Toolbox, etc. In each of these ﬁelds, there
are many subﬁelds that incorporate several distinctive blocks. All of these blocks can
be utilized to create a new model. Any of the blocks from this browser can be
dragged to the Simulink Model Design window. There is a search option at the top of
the browser, through which any particular block can be searched by the name
as well.
Fig. 12.12 Commenting and Uncommenting in Simulink
326
12
Introduction to Simulink

12.5
Physical System Modeling
Like MATLAB which consists of several toolboxes, Simulink includes several
modeling segments, which are specially created for speciﬁc applications. Event-
based modeling, physical system modeling, systems engineering, code generation,
application deployment, and reporting are some types of specialized products
Simulink has to offer, which consist of different sets of libraries and syntaxes.
Since this book will deal mostly with power and energy systems, Simulink’s
Simscape environment for modeling multi-domain physical systems will be utilized.
Simscape contains a new set of libraries and specialized simulation features to
work with electrical systems, power electronics, mechanical devices, and control
systems, which can be interconnected with any other Simulink blocks. The approach
that Simscape takes to design physical system models is known as the Physical
Network approach. Physical systems allow users with a unique experience to work
with nondirectional devices and connect them like real physical components without
specifying ﬂow directions or information ﬂow.
Fig. 12.13 Simulink Library Browser
12.5
Physical System Modeling
327

Simscape libraries are available in Simulink Library Browser. The names of the
main libraries in Simscape are Driveline, Electrical, Fluids, Multibody, Utilities, and
Foundation Library, as shown in Fig. 12.14. Most of the components in the library
are in blue or green color to show distinction with other Simulink libraries.
The physical systems cannot be directly connected to the Simulink blocks
because the physical systems are usually nondirectional like real physical compo-
nents, whereas Simulink blocks require information about directionality. Converter
blocks are needed to be used to convert the signal of a physical system into a
Simulink output signal and vice versa. There are some Simscape blocks that serve
the same purpose as other Simulink blocks. For example, the “voltage sensor” and
“current sensor” blocks in Simscape measure voltage and current similar to a
“voltage measurement” block and “current measurement” block. However, the
output of the voltage sensor cannot be displayed in a display block in Simulink. In
order to do so, a “PS-Simulink converter” is to be used. A “PS-Simulink converter”
converts a physical signal into a Simulink output signal, which can be used to
interconnect with any Simulink block available. A “Simulink-PS converter,” on
the other hand, converts a Simulink input signal into a physical system to be used by
any Simscape blocks.
Figure 12.15 shows an example where the voltage and current in a DC circuit
(with a voltage of 12 V and a resistor of 1000 Ω) are measured both in the physical
environment (in the magenta area) and in the Simulink environment (in the cyan
area). It is visible that each environment has its own counterpart for doing the same
task. For example, DC voltage source and resistors exist in both environments but
Fig. 12.14 Simscape Libraries
328
12
Introduction to Simulink

cannot be used interchangeably because of their difference in character. A “PS-
Simulink converter” is used from the voltage and current sensors to convert the
physical signal into the Simulink signal to be demonstrated using the “Display”
Simulink block.
Physical models use two additional blocks to perform simulation, i.e.,
“powergui” and “solver conﬁguration.”
A powergui is an environment block that is used for designing electrical models.
The block helps to use continuous and discretized methods to simulate a model.
Since the model could be solved either by using a variable-step solver, or at a ﬁxed
time step, or through phasor solutions, the powergui block helps to select the
appropriate method for the system. The block also aids the user in performing
steady-state analysis and parameterizes the circuit for advanced designs. The block
does not need to be connected to any component; rather, it is to be placed in the
model ﬁle separate from other components, as shown in Fig. 12.15. The powergui
block can be selected by going to Simscape!Electrical!Specialized Power
Systems!Fundamental blocks. The types of simulation performed with this block
are demonstrated in Fig. 12.16. Powergui block also consists of engineering tools
that can facilitate advanced functionalities to a model such as steady-state and initial
state calculation, line parameter and impedance calculation, fast Fourier transform
analysis, line linear system analysis, hysteresis design, and load ﬂow analysis. The
tool can also generate reports and create custom blocks related to power systems.
The window for the advanced powergui tools is shown in Fig. 12.17.
Fig. 12.15 A PS-Simulink converter
12.5
Physical System Modeling
329

Fig. 12.16 Powergui
blocks
Fig. 12.17 Advanced
powergui tools
330
12
Introduction to Simulink

Table 12.1 summarizes the model simulation type of the powergui blocks.
A solver conﬁguration block is another block used in Simscape to specify solver
parameters of the model. The block is needed to be present with each physical
network. Unlike powergui block, the solver conﬁguration block must be connected
at any point of the model. The block validates the model before running the
simulation, by providing the solver setting, such as the parameters for starting the
simulation from steady state, using different solver, or providing other runtime
related
constraints.
The
solver
conﬁguration
block
is
available
in
Simscape!Utilities. Figure 12.18 shows the default parameters of the block.
Selecting these options typically enables the user to perform steady-state or transient
initialization for the designed electrical model. In-depth analysis of other solver
setting parameters is out of the scope of this book.
Table 12.1 Model simulation type of the powergui blocks
Attributes
Simulation type
Continuous
Discrete
Phasor
Discrete phasor
Usage
Used for continu-
ous system simula-
tion, where
previous states
(conditions or
results) of a system
are taken into
consideration
Used for discrete
system simulation,
where previous
states of a system
do not matter and a
ﬁxed time step is
taken into
consideration
Used for continu-
ous systems,
where only elec-
trical phasors are
needed for
calculation
Used for discrete
systems, where
only electrical
phasors are
needed for
calculation
Feature
Considers continu-
ous time steps and
integrated system,
provides better
accuracy and fast
runtime for small
systems
Considers only a
ﬁxed time step,
provides better
accuracy and fast
runtime for large
systems
Considers
phasors for con-
tinuous time
steps, calculation
is faster in large
systems as it uses
continuous
phasors and con-
verts network dif-
ferential equa-
tions into
algebraic
equations
Considers
phasors for ﬁxed
time steps, cal-
culation is more
faster in large
systems as it uses
discrete phasors
and converts net-
work differential
equations into
algebraic
equations
Notable
applications
Small systems
(usually with 20–
30 states in a
model), such as
zero crossing
analysis
Systems requiring
ﬁnite cycle analy-
sis, such as
nonlinear power
electronic switches
Systems requiring
phasor analysis,
such as machine
transient
modeling
Multimachine
system design,
such as three-
phase motor or
generator
12.5
Physical System Modeling
331

12.6
Building a Model in Simulink
All the components that are required to design a model are discussed earlier. In this
section, a complete Simulink model will be designed and simulated to get comfort-
able with the platform. A step-by-step guideline to design a Simulink model to
generate sine wave will be demonstrated in the following example:
Generating Sine Wave
For generating a sine wave model in Simulink, the following blocks are required:
1. Sine wave
2. Scope
In Fig. 12.19, the procedures to pick up these two blocks are shown. From
Simulink Library Browser, any block can also be found out by using the name of
that block, instead of navigating. In Fig. 12.20, two alternated procedures to ﬁnd out
the Scope block are shown. In Fig. 12.20a, the name of the block “Scope” is typed in
the search option of the Simulink Library Browser. After hitting the “Enter” button
from the keyboard, the “Scope” block will appear. The same searching procedure
Fig. 12.18 Default
parameters of the solver
conﬁguration block
332
12
Introduction to Simulink

can also be performed in the Simulink design window as shown in Fig. 12.20b. By
double-clicking on the design window, a blue strip will appear with the search
symbol. Type the name of the block, which will create the appearance of a list of
available options. Select the desired block from the list by clicking on it. The block
will readily appear on the design window.
For generating a sine wave, a model is designed by utilizing the Sine Wave and
Scope block. These two blocks are connected with a line as shown in Fig. 12.21. The
Sine Wave block can be customized according to users’ choice, which can be done
by double-clicking on the block. After double-clicking on the Sine Wave block, the
parameter window will appear as shown in Fig. 12.22. On the parameter window,
there is a short description of the parameters of the Sine Wave block that can be
Fig. 12.19 Sine wave and scope from Simulink Library Browser
Fig. 12.20 Two ways of inserting the scope block
12.6
Building a Model in Simulink
333

altered. In this example, the amplitude and the frequency of the sine wave are set to
5 and 1, respectively. After clicking the “Apply” button, the Sine Wave block is
customized and the model is ready to be simulated.
12.7
Simulate a Model in Simulink
After building a simulation model, the next step is to simulate the design and observe
the desired outputs. Multiple parameters can be adjusted and customized before
simulating a model, which affects the outputs in different ways. In this section, some
of these parameter customizations will be discussed with examples. If the parameters
are not customized, the simulation will occur for a default setup. Before discussing
the customization of different parameters, the simulation procedure will be covered
with the default setup.
12.7.1
“Run” Option
To simulate any model in Simulink, the user need to press the “Run” button from the
Simulink header toolstrip, which is shown in Fig. 12.23. The “Run” button is a
dropdown box with two options. The ﬁrst option “Run” implies simulating the
model with default speed. The second option “Simulation Pacing” provides an
option to simulate the model at a slower pace. The second option is useful to
watch the output in a slower mode to visualize the change more accurately.
Fig. 12.21 A sine wave can be observed from the scope block
334
12
Introduction to Simulink

For checking out the difference between these two simulation options, let us
consider our previously designed Sine Wave Generator. Double-click on the
“Scope” block to observe the output waveform. Initially, before the simulation, a
blank scope window will appear. If the ﬁrst option in the “Run” button is placed, the
simulation will occur too fast that the user will have no time to stop or pause the
simulation in midway. The scope window will show the ﬁnal output, i.e., the
generated sine wave. It will be generated so fast that the user will not be able to
keep a track of the entire generator starting from the initial time to the end time. The
following waveform in Fig. 12.24 will appear in the scope window:
Fig. 12.22 Block parameters of the sine wave
12.7
Simulate a Model in Simulink
335

However, by selecting the second option “Simulation Pacing,” the speed of the
simulation can be customized. If the second option is chosen, the following window
will appear:
The window shown in Fig. 12.25 can be called the “Simulation Pacing Options
window.” From this window, the ﬁrst task is to check the square box that states
“Enable pacing to slow down simulation.” There is a slider and a write-down box in
the window. The user can choose any desired pacing by moving the slider or by
writing a value in the write-down box. In the above example, the pacing that has
been chosen is 0.45 s. Whenever the pacing will be enabled, a clock sign will appear
right next to the “Run” button as shown in Fig. 12.26.
The next step is to press the “Run” button which will simulate the model with the
selected pacing. As the model will simulate slower, two more options—“Pause” and
“Stop”—will be visible and can be utilized during the time of the simulation, as
Fig. 12.24 Scope output of the sine wave generator
Fig. 12.23 Running the sine wave generator
336
12
Introduction to Simulink

shown in Fig. 12.27. The lower left part of the window, which is marked as 3, veriﬁes
that the pacing is active. The marked 4 part indicates the percentage of the comple-
tion of the simulation. From the scope window, the generated wave can be tracked
from the start point to the end. Another option that is marked as number 5 in the
Simulink header strip is the “Stop Time,” which indicates the duration of the
simulation. If the “Stop Time” is speciﬁed as 20, it will indicate that the simulation
will stop after 20 s. It should be noted that the simulation time is not identical to
clock time. The simulation time may vary based on the computer speed, the
complexity of the designed model, and other aspects. The default value of the
“Stop Time” in Simulink is 10 s.
12.7.2
“Step Forward” and “Step Back”
“Step Forward” and “Step Back” options provide opportunities to pause a simulation
and step forward and backward with a predeﬁned step size. The ﬁrst step to enable
this feature is to click on the “Step Back” dropdown option, and select the “Conﬁg-
ure Simulation Stepping” option as shown in Fig. 12.28.
Fig. 12.25 Simulation pacing options of the sine wave generator
Fig. 12.26 Running the sine wave generator with pacing
12.7
Simulate a Model in Simulink
337

This step will create the appearance of the following window, from where the user
can enable the above-mentioned feature by clicking the checkbox next to the
“Enable stepping back” line. In this window, the user can customize the maximum
number of saved back steps, and the interval between them. Another option appears,
where the user can decide how many steps they want to go forward, or backward for
each click on the “Step Forward” and “Step Back” options. In Fig. 12.29, the default
values are shown for each of the options:
After customizing the stepping option, the user can click on the “Run” button for
simulation. After clicking the “Run” button, the “Pause” and the “Stop” options will
appear. To observe each step of the simulation meticulously, the user needs to click
on the “Pause” button, which will cause the appearance of three options by replacing
the “Pause” option. The three options are “Step Back,” “Continue,” and “Step
Forward.” In Fig. 12.30, the Simulink window along with the “Scope” window for
the Sine Wave Generator model after clicking the “Run” button is shown, where the
“Scope” window is blank initially. In Fig. 12.31, the same appearance is shown right
after clicking the “Pause” button after a while. Figures 12.32 and 12.33 illustrate the
concept of stepping forward and stepping backward, respectively. While clicking the
“Step Forward” button during the pause condition makes the simulation go one step
forward (Fig. 12.32) and after clicking the “Step Back” option, the simulation steps
one step backward (Fig. 12.33). If the “Continue” button is pressed, the simulation
Fig. 12.27 Scope output of the sine wave generator with pacing
Fig. 12.28 “Step Forward” and “Step Back” options
338
12
Introduction to Simulink

Fig. 12.29 Simulation stepping options of the sine wave generator
Fig. 12.30 Initial blank scope window in the sine wave generator
Fig. 12.31 Paused sine wave generator
12.7
Simulate a Model in Simulink
339

will start to continue from the paused position. Thus, for a detailed analysis of a
simulation, this feature is very fruitful and effective in the engineering domain.
12.7.3
Customizing the Style of the “Scope” Figure
In default mode, the background color of the scope window is black. While writing
scientiﬁc papers, or publishing books, white backgrounds are preferable in most
cases. In Simulink, the style of the “Scope” window can be customized according to
users’ choices. The ﬁrst step is to navigate to the “View!Style” option from the
“Scope” window as shown in Fig. 12.34.
After clicking the “Style” option, a “Style” window will appear, which can be
changed as shown in Fig. 12.35. In the changed window, the “Figure color” and
“Axes background color” are changed into white from black. The “Ticks, labels, and
grid colors” is changed into black from gray color. The Line color is changed into
black from yellow, and ﬁnally, the line width is set as 1 in place of 0.75. After
Fig. 12.32 The sine wave generator with step forward
Fig. 12.33 The sine wave generator with step back
340
12
Introduction to Simulink

changing all these options from the “Style” window, the ﬁnal step is to click
“Apply,” which will create the output ﬁgure of the “Scope” as shown in
Fig. 12.36. Although some certain changes have been made from the “Style”
window, the users may change any options from this window to customize the
style of the ﬁgure of the “Scope” window.
Fig. 12.34 Custom scope styling
Fig. 12.35 Scope style window
12.7
Simulate a Model in Simulink
341

12.7.4
“Solver” Option
While simulating a design “Solver” option decides the solving algorithm that works
for a particular simulation. In default, Simulink provides the “Auto” option, which
selects a solving algorithm automatically for a particular design. The user can
observe which solving algorithm is used by looking at the red marked zone shown
in Fig. 12.37.
As the following model is simulated in the default mode of solving option, it can
be observed that the Solver name in this simulation is “Variable StepDiscreet” in the
“Auto” Mode. If the user wants to customize the solver information, it can be
performed by ﬁrst clicking on the setting option from the “Solver Information”
feature window, as marked in blue in Fig. 12.38.
After clicking the “Solver Setting” option, the “Conﬁguration Parameters” win-
dow will appear (Fig. 12.39), where parameters relevant to solver information can be
conﬁgured according to the users’ choice.
The selection of a particular solver depends on the type of solver that will be
appropriate for a certain simulation. The types of solver can be categorized into two
parts—Variable-step and Fixed-step type. Within each of these types, multiple
solving algorithms are available in Simulink that can be utilized according to the
users’ choice. In Table 12.2, all the available solver is categorized in the following
table based on the two different types of solvers as mentioned earlier:
The users have the liberty to pick any of the solver algorithms from the above-
mentioned table for a particular simulation. In default, the setup remains in “Auto”
mode, which automatically decides a particular algorithm for a certain Simulink
Fig. 12.36 New scope style
342
12
Introduction to Simulink

Fig. 12.38 Settings in solver information
Fig. 12.37 Solver information
12.7
Simulate a Model in Simulink
343

Fig. 12.39 Conﬁguration parameters
Table 12.2 Different types of solver algorithms in Simulink
Solver type
Fixed-step solver
Variable-step solver
Continuous
• Ode1 (Euler)
• Ode1be (Backward Euler)
• Ode2 (Heun)
• Ode3 (Bogacki-Shampine)
• Ode4 (Runge-Kutta)
• Ode5 (Dormand-Prince)
• Ode8 (Dormand Prince)
• Ode14x (Extrapolation)
• Ode15s (Stiff/NDF)
• Ode23 (Bogacki-Shampine)
• Ode23s (Stiff/Modiﬁed Rosenbrock)
• Ode23t (Modiﬁed stiff/Trapezoidal)
• Ode23tb (Stiff/TR-BDF2)
• Ode45 (Dormand-Prince)
• Ode113 (Adams)
• OdeN (Nonadaptive)
• Daessc (DAE solver for Simcape)
Discrete
• Fixed-step discrete solver
• Variable-step discrete solver
344
12
Introduction to Simulink

design. For conﬁguring any particular solver, the ﬁrst step is to navigate to the
“Solver” section of the “Conﬁguration Parameters” window, and then, select the
type of the solver by clicking the dropdown option named “Type” under the “Solver
Selection” section. Later, the second step is to click on the “Solver” dropdown
option to choose any particular solver algorithm that falls under the previously
selected types of the solver. These two steps are highlighted in Fig. 12.40 by
1 and 2 with red marks:
For each type of solver, Simulink also provides the option for conﬁguring other
parameters to customize solver options with more details. The available parameters
that can be conﬁgured for each type of solver are listed in Tables 12.3 and 12.4 with
some details:
12.7.5
Data Import and Export
In the “Conﬁguration Parameters” window, a “Data Import/Export” section can be
found, which can be utilized to link Simulink with the Workspace of MATLAB. The
input data can be loaded from the Workspace by using the option “Connect Input”
under the subsection “Load from workspace.” The initial state can also be assigned
externally as well.
Another feature of this section is to save data in the Workspace from the
Simulink. The users may pick the data which they want to export in the Workspace.
Thus, the parameters of this window can be conﬁgured to make collaboration
between Simulink and MATLAB by importing and exporting data. The “Data
Import/Export” window is shown in Fig. 12.41.
Fig. 12.40 Solver selection in conﬁguration parameters
12.7
Simulate a Model in Simulink
345

Table 12.3 Different types of parameters for ﬁxed-step solver algorithm in Simulink
Fixed-step solver
Parameters
Details
1. Periodic sample time
constraint
• The constraint of the periodic sample time can be selected
• There are three options to select for this parameter:
a. Unconstrained
b. Ensure sample time-independent
c. Speciﬁed
• In “Unconstrained” mode selection, a “Fixed-step size”
option will appear, which will be needed to specify. The
“Fixed-step size” option will be explained later
• In “Ensure sample time-independent” mode selection, the
Simulink model needs to have a sample time inherited by
itself
• In “Speciﬁed” mode selection, the “Sample time properties”
option will appear, where the priorities of sample time need
to be assigned. “Sample time properties” will be explained
later
2. Fixed-step size (fundamental
sample time)
• The step size of the numerical solver, which is a ﬁxed value
• Set “Auto” or type any valid number
• It will only appear if the “Periodic sample time constraint”
is assigned in the “Unconstrained” mode
3. Sample time properties
• It mentions and speciﬁes the priorities of the sample time
• The type of input of this parameter is a n  3 size matrix,
where n indicates the number of sample times
• It is ordered from the fastest to the slowest of the sample
times
• For each sample time, three values are assigned, which are
period (sample rate), offset, and priorities, respectively, in
order.
• Sample format:
[Period_1 Offset_1 Priority_1 (1st sample time)
Period_2 offset_2 priority_2 (2nd sample time)
Period_n Offset_n Priority_n (nth sample time)]
4. Treat each discrete rate as a
separate task
• A checkbox option, which has two modes “On” and “Off”
• By clicking on the check box, “On” mode can be initiated
• In “On” mode, multitasking is enabled, where the Simulink
model can be executed at different sample rates
• In “Off” mode, all the blocks will be executed for a single
sample rate
5. Higher priority value indicates
higher task priority
• A checkbox option, which has two modes “On” and “Off”
• By clicking on the check box, “On” mode can be initiated
• In the “Sample time properties,” the priority value can be
assigned. However, which priority value will indicate higher
or lower task priority can be assigned by this option
• In “On” mode, a higher priority value indicates a higher
priority task
• In the “Off” mode, a higher priority value signiﬁes a lower
priority task
346
12
Introduction to Simulink

Table 12.4 Different types of parameters for variable-step solver algorithm in Simulink
Variable-step solver
Parameters
Details
1. Max step size
• The maximum step size of the numerical solver
• Set “Auto” or type any valid number
• In default, it will be assigned as “Auto”
2. Min step size
• The minimum step size of the numerical solver
• Set “Auto” or type any valid number
• In default, it will be assigned as “Auto”
3. Initial step size
• The initial step size of the numerical solver
• Set “Auto” or type any valid number
• In default, it will be assigned as “Auto”
4. Relative
tolerance
• It speciﬁes the maximum acceptable error of the solver relative to the size
of every state during every time step
• Default value: 1e3
• It can be set any valid number
5. Absolute
tolerance
• It speciﬁes the maximum acceptable error when the measured state value
approaches zero
• Default value: “auto”
• It can be set any valid number
6. Shape
preservation
• It has two options—disable all and enable all
• In the “enable all” option, shape preservation is applied to all the signals. In
this mode, the integration accuracy in each state is improved by using
derivative information in each time step
• In the “disable all” option, shape preservation is not applied
• Default value: “disable all”
7. Zero-crossing
control
• It is used to enable or disable zero-crossing detection
• It has three options to choose:
a. Use local settings
b. Enable all
c. Disable all
• In the “use local settings” option, zero-crossing detection can be enabled
for each block manually. For enabling the zero-crossing detection of a
particular block, navigate to the parameter box of that block, and check on
the “enable zero-crossing detection” option
• By selecting the “enable all” option, zero-crossing detection will be
enabled for all the blocks in a Simulink model
• By selecting the “disable all” option, zero-crossing detection will be
disabled for all the blocks in a Simulink model
8. Algorithm
• It falls under the category of the zero-crossing option
• It is used to specify the algorithm for zero-crossing detection
• Simulink provides two algorithms for such task—adaptive and
nonadaptive algorithm
• Adaptive algorithm is more suitable for models that have strong zero
behavior
• The nonadaptive algorithm can provide accurate detection; however, it
may take a longer simulation time
• Default value: nonadaptive algorithm
12.7
Simulate a Model in Simulink
347

12.7.6
Math and Data Types
“Math and Data Types” is another section in the “Conﬁguration Parameters” win-
dow. In the Math subsection, the users can conﬁgure two parameters. Firstly, the
choice regarding how to handle denormal numbers during simulation. A denormal
number can be deﬁned as a number, which is nonzero and smaller than the lowest
ﬂoating normalized number. In some aspects, denormal values are ﬂushed to zero.
Therefore, under the “Math” subsection, there is a dropdown option named “Simu-
lation behavior for denormal numbers,” which has two options to conﬁgure: Gradual
Underﬂow, which does not make any changes for the denormal numbers, and Flush
to Zero (FTZ), which converts any denormal number to zero.
Secondly, there is a checkbox option named “Use algorithms optimized for
row-major array layout” under the “Math” subsection. If the checkbox is checked
to enable this option, such conﬁguration will allow Simulink to enable an efﬁcient
algorithm that will traverse the data in row-major order. For selecting such an option,
the generated algorithm will be efﬁcient for a row-major array layout, however will
not be fruitful for a column-major array layout.
Unchecking, or disabling, the above option indicates that an efﬁcient algorithm
will be enabled, which will traverse the data in column-major order. Therefore, the
generated code will be efﬁcient, if the array layout is column-major.
Fig. 12.41 Data Import and Export in conﬁguration parameters
348
12
Introduction to Simulink

In the Data Types subsection, any unspeciﬁed data can be conﬁgured as either
double or single. There are some other parameters, such as the options of computing
ﬁxed-point net slope computation, handling net slope corrections, etc. All of these
parameters can be conﬁgured by using the window as shown in Fig. 12.42.
12.7.7
Diagnostics
A Diagnostics window appears after a simulation model is run to simulate, which
shows errors, or any kind of warnings that need to be ﬁxed. If there is no error, or
associated warning, the “Diagnostics” window will not appear after the simulation.
Simulink provides the users’ ﬂexibility to choose for which conditions a simulated
model should show warnings, errors, or none. The “Diagnostics” window is shown
in Fig. 12.43, which is a section of the “Conﬁguration Parameters” window.
12.7.8
Other Parameters
In the “Conﬁguration Parameters” window, there are ﬁve more sections under which
different parameters can be customized. For example, the “Hardware Implementa-
tion” section can be conﬁgured to specify the types and characteristics of a
computer-based model, to be more speciﬁc, an embedded system designed using
Simulink. In this chapter, all these parameters will not be explained, as the book aims
to work as a crash course for the readers. To learn more about these parameters,
select a section from the “Conﬁguration Parameters” window, and click on the
Fig. 12.42 Math and Data Types in conﬁguration parameters
12.7
Simulate a Model in Simulink
349

“Help” button from the lower-left portion of the window. A sample is shown in
Fig. 12.44, where the “Hardware Implementation” section is chosen, and after
clicking the “Help” button, the help page appears as shown in Fig. 12.45. From
this page, a concise overview of this section can be learned. To know more about the
individual parameter conﬁguration of this section, move the mouse to a certain
parameter and right-click on it. An option box named “What’s This?” will appear.
By clicking on it, a help page will appear describing all the relevant information on
when and how to conﬁgure this particular parameter. In Fig. 12.44, a sample is
shown where after right-clicking on the “Device vendor” parameter, the
“What’s This?” option appears. After clicking on this option, a short guideline to
conﬁgure this parameter will appear, which is shown in Fig. 12.45. For learning
Fig. 12.44 Hardware implementation in conﬁguration parameters
Fig. 12.43 Diagnostics in conﬁguration parameters
350
12
Introduction to Simulink

more details about the conﬁguration of this parameter, click on the “Show more
information” option red marked in Fig. 12.46.
12.8
User-Deﬁned Block in Simulink
In Simulink, multiple user-deﬁned blocks are available, such as C caller, C Function,
MATLAB Function, MATLAB System, etc. The algorithms of the block can be
written in C, C++, MATLAB, or Fortran depending on a particular user-deﬁned
block. From the Simulink Library Browser, navigate to the “Simulink!User-
Deﬁned Functions,” where all the available blocks are listed. In the following
example, the MATLAB Function block is utilized to illustrate how to create a
user-deﬁned block in Simulink.
Fig. 12.45 Hardware implementation overview
12.8
User-Deﬁned Block in Simulink
351

Example 12.1 A rectangular to polar converter block is created by utilizing the
MATLAB Function block in this example. A step-by-step guideline is provided
below to create such a user-deﬁned block:
Step 1: Drag the “MATLAB Function” block from the “Simulink Library
Browser!Simulink!User-Deﬁned
Functions!MATLAB
Function”
to
the
Simulink design window.
Step 2: Double-click on the “MATLAB Function,” which will open a MATLAB
script ﬁle in the Editor.
Step 3: Write a user-deﬁned function by specifying input and output parameters
to deﬁne the task. In this example, the input parameters are the real and imaginary
parts of the number represented in rectangular form. The outputs are the magnitude
and angle in polar form. A user-deﬁned function for rectangular to polar conversion
is written as in Fig. 12.47 in the MATLAB script:
Step 4: Save the MATLAB script (.m ﬁle) in the same working directory as the
Simulink ﬁle (.slx ﬁle). It will create two input and output ports in the MATLAB
Function block that was dragged before in the Simulink design window.
Step
5:
Drag
two
“Constant”
blocks
from
the
“Simulink
Library
Browser!Simulink!Sink” to provide inputs of the real and imaginary number.
Connect both of them with the input port of the “MATLAB Functions” block.
Step
6:
Get
two
“Display”
blocks
from
the
“Simulink
Library
Browser!Simulink!Sink” to display the two output parameters—Magnitude and
Angle. Connect these displays with the output ports of the “MATLAB Functions.”
Fig. 12.46 Getting more information about device vendor
Fig. 12.47 Code—Function for conversion from rectangular to polar coordinates
352
12
Introduction to Simulink

Step 7: Double-click on the “Constant” blocks to set two different values—real
and imaginary parts—in the blocks.
Step 8: Click on the “Run” button to simulate the model. The overall Simulink
design after the simulation is shown in Fig. 12.48, where the “MATLAB Function”
acts as a user-deﬁned block:
Example 12.2 A user-deﬁned Simulink block that can compute mean, standard
deviation, and variance. To create this Simulink block, the MATLAB Function
block is utilized. After double-clicking the “MATLAB Function” block, a
MATLAB script appears. The MATLAB code to deﬁne the task of the “MATLAB
Function” block is shown in Fig. 12.49.
In the above code, a user-deﬁned function fcn() is created, where the outputs are
Mean_value, Standard_deviation, and Variance. Three “Display” blocks are
connected with the output ports to display the results. In the “input” port, a
“Constant” block is connected, where a vector array [5 2 10 2 8 7 9] is assigned
from its parameter window. The overall design of the model is shown in Fig. 12.50
after the simulation.
Fig. 12.48 Simulink diagram of the function for conversion from rectangular to polar coordinates
Fig. 12.49 Code—Function for computing mean, standard deviation, and variance
12.8
User-Deﬁned Block in Simulink
353

12.9
Using MATLAB in Simulink
From Simulink, it is possible to shift any simulated output, or data, to the MATLAB
Workspace, from where it can be used to perform any task using MATLAB coding.
One of the options to perform such a task is to utilize a Simulink block “To
Workspace.” An example is shown below to show the usage of this block to
establish the usage of MATLAB in Simulink:
Example 12.3 In this example, a solar cell is simulated to demonstrate the PV
characteristic curve for different solar irradiance values with the usage of both
Simulink and MATLAB. The utilized blocks and the navigation routes from them
are summarized in the following Table 12.5:
The designed model by utilizing the above-mentioned blocks is shown in
Fig. 12.51. The value of the PS Constant block indicates the solar irradiance
value, which is set as 800 initially. Except for three “To Workspace” blocks, all
other blocks are kept with their default parameter values. The “To Workspace” block
is customized by changing the “Variable name” and the “Save format.” In
Fig. 12.52, the customization of the “To Workspace” block is shown, where the
“Variable name” is changed to “I1” and the “Save format” is changed to “array.” For
“To Workspace1” block, the “Variable name” and the “Save format” are changed
into “P1” and “array,” respectively. Finally, the “To Workspace2” block is modiﬁed
by setting the “Variable name” and “Save format” as “V1” and “array.” It is to be
noted that the “To Workspace” and “Display” blocks indicate the current; the “To
Workspace1” and “Display1” blocks refer to the power; and the “To Workspace2”
and “Display2” blocks indicate the voltage from the solar cell circuit.
In this example, we are interested in plotting the PV characteristic curve for
different solar irradiance values by utilizing MATLAB. Therefore, in the ﬁrst
simulation, the value of the PS Constant block is set to 800 initially which represents
the value of solar irradiance. To shift the data of voltage, current, and power to the
Fig. 12.50 Simulink diagram of the function for computing mean, standard deviation, and variance
354
12
Introduction to Simulink

Fig. 12.51 Simulink diagram for the simulation of solar cell to demonstrate the PV characteristic
curve for different solar irradiance values
Table 12.5 Blocks and navigation routes utilized in Example 12.3
Name of the block
Navigation route
Solar cell
Simscape!Electrical!Sources!Solar cell
PS constant
Simscape!Foundation library!Physical signals!Sources!PS constant
Solver
conﬁguration
Simscape!Utilities!Solver conﬁguration
PS-simulink
converter
Simscape!Utilities!PS-Simulink converter
Simulink-PS
converter
Simscape!Utilities!Simulink-PS converter
Current sensor
Simscape!Foundation library!Electrical!Electrical sensors!Current
sensor
Voltage sensor
Simscape!Foundation library!Electrical!Electrical sensors!Voltage
sensor
Variable resistor
Simscape!Foundation library!Electrical!Electrical
elements!Variable resistor
Ramp
Simulink!Sources!Ramp
To workspace
Simulink!Sinks!To workspace
Product
Simulink!Math operations!Product
Display
Simulink!Sinks!Display
12.9
Using MATLAB in Simulink
355

Fig. 12.52 Block parameters
Fig. 12.53 Variables in the
workspace
356
12
Introduction to Simulink

MATLAB Workspace, the “To Workspace” blocks are used. For the solar irradiance
value 800, the variable names of the three “To Workspace” values are set as “I1,”
“P1,” and “V1” as mentioned earlier. Afterward, click the “Run” button to simulate
the model, which will shift the values of I1, P1, and V1 to the MATLAB Workspace
directory. Later, change the value of the “PS Constant” block to 1000 and change the
variable names of the three “To Workspace” blocks to “I2,” “P2,” and “V2.” Later,
simulate the model again by clicking the “Run” button. Finally, simulate the model
for the new “PS Constant” value 1200 and the changed variable name of the three
Fig. 12.54 Code—Plotting the PV characteristic curve for different solar irradiance values
Fig. 12.55 PV characteristic curve of photovoltaic cell
12.9
Using MATLAB in Simulink
357

“To Workspace” blocks “I3,” “P3,” and “V3.” To check whether the values of the
variables are shifted to the MATLAB Workspace, go to the MATLAB starting page,
and in the “Workspace” directory, all the variables will be available with the
assigned name in the “To Workspace” blocks as shown in Fig. 12.53.
As the variables are shifted to the MATLAB Workspace, we can use MATLAB
Editor to write code using the available variables. As we are interested in plotting the
PV characteristic curves for different solar irradiance values, the following code
(Fig. 12.54) in the MATLAB editor can do this task.
After running the above-mentioned code in the MATLAB Editor, the PV char-
acteristic plots appear as shown in Fig. 12.55. Here, we have utilized only the values
of powers and voltages for plotting the PV curve. By utilizing the values of voltages
and currents, the VI curve can also be plotted in the same manner. Thus, using
MATLAB, any simulated model can be analyzed further in more detail.
12.10
Conclusion
This chapter acts as introductory guidelines for the readers to proceed further with
Simulink. By going through the contents of this chapter, the readers will be able to
understand the basic features of the Simulink along with different elements that will
be necessary to realize the contents of the later chapters. The basic procedures to
build any model in the Simulink design window, usage of the Simulink Library
Browser, and simulating a model are illustrated step-by-step with examples in this
chapter. In addition, this chapter also covers how to create a user-deﬁned block and
conﬁgure it according to the users’ interests. Finally, the interaction between
MATLAB and Simulink is shown with examples in the last section of this chapter
to realize their usability and applications in the engineering domain.
Exercise 12
1. How can you describe the importance of Simulink in the engineering domain?
2. (a) What are the ways to open Simulink from the MATLAB window?
(b) Use one of the ways and create a blank Simulink ﬁle titled “First_Exercise.
slx.”
(c) Drag the following blocks in the Simulink design window of the
“First_Exercise.slx” ﬁle:
(i) Add
(ii) Constant
(iii) Display
(d) Design a model that can perform subtraction using the previous blocks.
358
12
Introduction to Simulink

(e) Simulate the model and verify the result by performing it in the MATLAB
command window.
3. (a) What is the purpose user-deﬁned blocks?
(b) Create a user-deﬁned block that can convert any polar coordinates to rectan-
gular coordinates.
(c) Using the user-deﬁned block mentioned in (b), design a model that can
perform polar to rectangular conversion
(d) Convert the following two numbers in their rectangular forms by using the
previous model:
(i) 10 ∠45 rad
(ii) 20 ∠30 rad
4. (a) Recreate the model shown in Example 12.3 and simulate the model for solar
irradiance 1000.
(b) Generate the graph of P and V with respect to time using a single scope.
Customize the following parameters of the style of the graph in the Scope
window:
(i) Figure color: White
(ii) Axes background color: White
(iii) Ticks, labels, and grid colors: Black
(iv) Linewidth: 1.0
(v) Line color of the P graph: Blue
(vi) Line color of the V graph: Red
(c) Generate the PV characteristic curve of the photovoltaic cell using an XY
Graph block in the design. (The XY Graph is available in Simulink!Sinks!XY
Graph). Change the maximum and minimum value of the x-axis into [0 1], and
y-axis into [0 3] by double-clicking on it.
(d) Use MATLAB “plot” command to generate VI characteristic curve of pho-
tovoltaic cell for solar irradiances 800, 1000, 1200, and 1600.
Exercise 12
359

Chapter 13
Commonly Used Simulink Blocks
13.1
Sink
In Simulink, it is essential to display signal values or signal graphs. Hence, sinks are
one of the most commonly used blocks in the Simulink model to visualize the output
results in the form of values or graphs. There are different forms of sinks available in
the Simulink platform. In this chapter, some of the basic blocks will be explained,
such as display, scope, ﬂoating scope, to workspace, XY graph, etc.
13.1.1
Display
“Display” block is used to observe values from a particular signal line. To drag the
“Display” block in the Simulink design window, navigate to the path—Simulink
Library Browser!Simulink!Sinks!Display.
Navigation route:
Simulink Library Browser! Simulink! Sinks! Display
After dragging the block into the design window, double-click on the block,
which will cause the appearance of the window named “Block Parameters: Display.”
From this parameter window, the users have the opportunity to customize some of
the parameters of the block, such as the Numeric display format. There are nine
available formats available for the “Display” block. Another parameter of this block
is called “Decimation,” which indicates the frequency of displaying data on this
block. The last customizable parameter is the checking box option named “Floating
display.” By checking this box, a “Display” block can be made ﬂoating, which
means the block does not require to be connected with the signal line. By selecting a
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_13
361

signal line before simulation, it is enough to show the data in a Floating display. In
Fig. 13.1, the “Display” block ﬁnding, dragging, and parameter window appearance
are shown graphically.
An example of the usage of the “Display” block is shown in Fig. 13.2, where the
“Constant” block is used as a source. In the following ﬁgure, three “Display” blocks
can be found, where “Display 2” is in the ﬂoating mode. In “Display” and “Display
1,” the values of the “Constant” blocks can be observed after the simulation happens;
however, in “Display 2,” it is blank.
In Fig. 13.3, the signal line between the “Constant” and “Display” blocks is
selected, and simulated afterward by clicking the “Run” button. It causes the
“Display 2” block, which is on the ﬂoating mode, to show the output of the
“Constant” block. On the other hand, in Fig. 13.4, the signal line between the
“Constant 1” and “Display 1” blocks is selected before the simulation. As a result,
this time “Display 2” presents the signal value of “Constant 1.” It is to be noted that
Fig. 13.1 The display block
Fig. 13.2 Three display blocks
362
13
Commonly Used Simulink Blocks

when the checkbox option of the “Floating display” is checked, the port sign
disappears from the “Display” block.
Fig. 13.3 Display2 shows the same output as Display block
Fig. 13.4 Display2 shows the same output as Display1 block
Fig. 13.5 The scope block
13.1
Sink
363

13.1.2
Scope
The Scope is a frequently used block in Simulink that is used to plot any output
signal graph. In Fig. 13.5, the navigation of the “Scope” block and its parameter
window is shown:
The “Scope” has one input port, which needs to be connected with a signal line.
After simulation, the output graph of the signal line can be observed by double-
clicking on the “Scope” block. If multiple line output needs to be observed using one
“Scope” block, it can also be attained. For doing so, right-click on the “Scope” block
and choose the option “Signal and Ports!Number” of input ports. Under “Number
of input ports,” there are options to select a number to deﬁne the desired number of
input ports for a scope.
The “Style” feature of the Scope window is demonstrated in Sect. 12.7.3. The
Scope has some other features as well. One of the most widely used features is its
scaling feature. If a graph in the Scope window does not ﬁt quite well, it can be
conﬁgured to be scaled either along the X-axis or Y-axis. Even scaling along both
Fig. 13.6 Scaling the scope window
364
13
Commonly Used Simulink Blocks

the X- and Y-axis can also be performed for a graph to be ﬁtted in the Scope window
perfectly. An example is provided below to show how the scaling feature works in
the Scope:
In Fig. 13.6a, a Sine Wave Generator is connected with a Scope block. This
simple model is generated to demonstrate the feature of the Scope window more
easily. In Fig. 13.6b, a red marked box is placed to encircle a particular option of the
Scope window from its upper tool strip. In this red marked box, three symbols are
available in a dropdown option list. In that ﬁgure, the ﬁrst symbol indicates “Scale
X-Axis Limits,” while the second refers to “Scale Y-Axis Limits.” Finally, the third
one represents “Scale X- and Y-Axes Limits.” In Fig. 13.6b, the ﬁrst option is chosen
that indicates the “Scale X-Axis Limits” option. The model is simulated for
10 s. Therefore, the highest limit of the X-axis is 10. While the Scope window is
scaled for the X-axis limit, the entire graph along the X-Axis is observable; however,
the Y-axis limit is not scaled in this case. Hence, some of the upper and lower
portions of the graph are invisible in Fig. 13.6b. In Fig. 13.6c, another phenomenon
is shown where the Y-axis scaling option is chosen. In this case, the graph is scaled
over the Y-axis but does not scale over the X-axis. Hence, some of the portions of the
graph along the X-axis are not observable. Finally, in Fig. 13.6d, the scaling of both
X- and Y-Axes is chosen, which causes the scaling of the graph over both axes.
Hence, the overall graph is visible. Thus, the user has the preference to choose how
they want to scale the graph according to their requirement.
Another important feature of the Scope window is the Layout feature. If multiple
graphs are plotted in the same Scope window, they can be separated by using the
principle of Subplot. The layout can be deﬁned based on which the graphs will be
plotted in separate subwindows of the original Scope window. An example is
provided in Fig. 13.7 to explain the Layout feature of the Scope window.
In Fig. 13.7a, four Sine Wave blocks are connected with the four input ports of a
Scope window. The method of customizing the number of input ports of a Scope
block is explained earlier. After simulating the model, the graph of Fig. 13.7b can be
visible, from which it can be observed that all of the four sine wave graphs are
plotted in the same Scope window. This layout can be changed by clicking on the
“Conﬁguration Properties” option from the upper tool strip as marked by “1” in
Fig. 13.7b. After clicking on this dropdown option, select the Layout feature, which
is marked by “2” in the ﬁgure. This will cause the appearance of a small window as
shown in Fig. 13.7c. This window represents the layout in a matrix format. The user
has the preference to create subwindows by selecting the number of box arrays from
this small window. In Fig. 13.7c, four-column box arrays are chosen, which form
four-column subwindows in the original Scope window. The four ﬁgures shift to one
of these four subwindows as shown in Fig. 13.7d. The Layout can be changed in
another format as well. For example, in Fig. 13.7e, another layout option is chosen.
In this case, four box arrays are chosen in such a format that it creates a 2 by 2 matrix
format, i.e., four boxes in two rows and two columns formation. By selecting this
layout, the subwindows are created exactly in the same manner as shown in
Fig. 13.7f. Thus, based on the preference of the layout, the Scope window can be
13.1
Sink
365

formatted to create as many subwindows as possible to make the graphs more
presentable.
Fig. 13.7 Illustrating multiple plots on the scope window
366
13
Commonly Used Simulink Blocks

13.1.3
Floating Scope
The “Floating Scope” block allows observing output signal without any line con-
nection. To observe the signals of different lines, the “Floating Scope” block pro-
vides more ﬂexibility as it can work as a replacement for multiple “Scope” blocks
and direct line connections. An example is given in Fig. 13.8, where three separate
“Sine Wave” blocks with different amplitudes are connected with three separate
“Out” blocks. To observe the output of these three signal lines, three “Scope” blocks
can be utilized by connecting them with the signal lines. However, another alterna-
tive way is to use the “Floating Scope,” which does not require any direct line
connection and only one is sufﬁcient to observe the multiple signal outputs. The
navigation route of the Floating Scope is given below:
Navigation route:
Simulink library browser!Simulink!Sinks!Floating scope
In Fig. 13.8, the objective is to observe the output signals of Sine Wave 1, Sine
Wave 2, and Sine Wave 3. These three sources are connected with three Out 1 blocks,
which are available on Simulink Library Browser!Ports and Subsystems!Out
1. In the ﬁgure, a Floating Scope can be seen, which can be used to either plot one
of the sine wave signals or all of them according to users’ preference. The steps for
using ﬂoating scope are mentioned below:
1. Double-click on the Floating Scope, which will create the appearance of the
following Scope window in Fig. 13.9. Select the “Signal Selector” option from
this window.
Fig. 13.8 Floating scope
13.1
Sink
367

2. Later get back to the Simulink Design Window and select the Sine Wave 1 block
and its associated signal line as shown in Fig. 13.10. This will make the appear-
ance of the Display 1 window, where under Connect option, there will be a
checkbox option named Sine Wave 1: 1. Click on the Checkbox, if the user is
only interested to observe the plot of Sine Wave 1. After clicking the “Run”
option, the desired output signal of the Sine Wave 1 block will appear on the
Fig. 13.9 Signal selector from scope window
Fig. 13.10 Observing the plot of Sine Wave1
368
13
Commonly Used Simulink Blocks

Floating Scope window. However, in this example, we are interested in observing
three of the output signals of the Sine Wave blocks together in the Floating Scope
window. Therefore, we will skip the clicking of the “Run” option for now.
3. Afterward, select the Sine Wave 2 block along with its signal line as shown in
Fig. 13.11, which will add another checkbox option in the Display 1 window
named Sine Wave 2: 1. Continue the same process for the Sine Wave 3 block
as well.
Fig. 13.11 Observing the plot of Sine Wave1 and Sine Wave2
Fig. 13.12 Three plots of Sine Wave1, Sine Wave2, and Sine Wave3 in the same window
13.1
Sink
369

Finally, click on the “Run” option, which will create the plots of the three sine
wave signals in the Scope window as shown in Fig. 13.12.
13.1.4
Add Viewer
Add Viewer is an alternative feature for observing any output signal. Add Viewer
can provide the opportunity to observe any output signal in the Scope Window,
without dragging any Scope block in the Simulink Design Window. The previous
example of the ﬂoating scope is used in this section to implement Add Viewer
feature as shown in Fig. 13.13. To observe the output signal of a particular signal line
using Add Viewer, the ﬁrst step is to select that signal line. The second step is to
select the “Add Viewer” option available on the header Strip under Simulation
mode. By clicking on the “Add Viewer” option, a small window will appear from
where multiple options can be chosen. In this example, we are interested to utilize
the “Scope” option; hence, the next step is to select the “Scope” from the Add
Viewer window. These steps are illustrated graphically in the following ﬁgure for
more comprehensibility of the reader:
Fig. 13.14 Small fade scope icons next to the Sine Wave blocks
Fig. 13.13 The Add Viewer feature
370
13
Commonly Used Simulink Blocks

After selecting the three signal lines associated with Sine Wave 1, Sine Wave
2, and Sine Wave 3 one by one and performing the above-mentioned steps separately
for each line, we will create the appearance of the design as shown in Fig. 13.14. In
this ﬁgure, it can be observed that a small fade scope window appears right next to
the Sine Wave blocks, or at the start point of each output signal. After simulating the
model by clicking on the “Run” button, click on any of the small scope icons
(Fig. 13.15). This will create the appearance of the scope window with the associated
output signal line plot as shown in Fig. 13.16. The Add Viewer makes the overall
design simple by avoiding the usage of extra blocks in the design.
Fig. 13.16 The scope windows after clicking the small scope icons
Fig. 13.15 Clicking on the scope icons will show the scope window
13.1
Sink
371

13.1.5
XY Graph
XY Graph can be utilized to plot a simple 2D graph. It is a graphical tool available in
Simulink that performs almost the same task as the “plot” function of MATLAB.
The navigation route of the XY Graph is shown below:
Fig. 13.18 Block parameters of step block
Fig. 13.17 Simulink block for XY graph
372
13
Commonly Used Simulink Blocks

Navigation route:
Simulink Library Browser!Simulink!Sinks!XY Graph
In Fig. 13.17, an example of the usage of the XY Graph block is shown, where
two inputs are provided by using two “Step” blocks. For the second input, a “Gain”
block is used which multiplied the step signal three times as assigned in the Gain
block parameter window. It is to be noted that the “Gain” block is available on
Simulink Library Browser!Simulink!Math Operations!Gain.
In Fig. 13.18, the parameter window of the “Step” block is shown. After
simulating the model, double-click on the XY Graph block, which will create the
appearance of the XY plot as shown in Fig. 13.19. This block can also be used from
Add Viewer by following the same procedures described in the previous section.
13.2
Source
For any Simulink model, the Source plays one of the most important parts of the
design. For an electrical circuit, a DC or AC source is necessary for the circuit to
become active. Similarly, for any physical system, a source is the working factor.
Therefore, different blocks that may act as a source in the Simulink are described in
this section. In Simulink, different source blocks are available; however, in this
Fig. 13.19 XY plot
13.2
Source
373

section, only the most commonly used Source blocks are covered to make this
section concise.
13.2.1
Pulse Generator
The Pulse Generator is a source block that can generate any customized pulse signal.
This block is available on Simulink Library Browser!Simulink!Sources!Pulse
Generator. An example is shown in Fig. 13.20, where the Pulse Generator is
connected with a “Scope” block to observe the nature of a pulse signal. In
Fig. 13.20, the parameter window of the Pulse Generator is also shown, through
which the pulse signal can be customized according to users’ preferences.
The amplitude of the pulse signal is set as 5, the period of the signal as 2, and the
pulse width as 10. To observe the generated pulse signal, a Scope block is added
with the Pulse Generator block. After simulating the model, double-click on the
Scope signal to observe the pulse signal in the Scope window as shown in Fig. 13.21.
13.2.2
Ramp
Ramp block can generate ramp signals, which is an important source for many
physical models. The navigation path of the Ramp block is given below:
Fig. 13.20 Pulse generator
374
13
Commonly Used Simulink Blocks

Navigation route:
Simulink Library Browser! Simulink! Sources! Ramp
In Fig. 13.22, a Ramp block is connected with a Scope block. The slope of the
Ramp block is assigned as 2. The start time and the initial output of the ramp signal
are both set as zero. The user can customize these parameters according to their
Fig. 13.22 Ramp block and its parameters
Fig. 13.21 Pulse signal in the scope window
13.2
Source
375

preference. The output ramp signal can be observed from the Scope block by double-
clicking on it. The generated ramp signal is shown in Fig. 13.23.
13.2.3
Step
A Step signal is one of the most commonly used blocks in Simulink. The navigation
path of the Step block is provided below:
Navigation route:
Simulink Library Browser!Simulink!Sources!Step
In Fig. 13.24, a Step block is dragged into the Simulink design window along
with a Scope block. The parameters of the Step block that can be customized in the
Simulink can also be observed in Fig. 13.24. In the following example, the Step time
is selected as 2. The initial and the ﬁnal values of the Step signal are assigned as
0 and 10, respectively. The sample time is considered as zero for this example.
According to this particular customization, the output Step signal can be observable
via the Scope block as shown in Fig. 13.25.
Fig. 13.23 Ramp signal in the scope window
376
13
Commonly Used Simulink Blocks

Fig. 13.25 Step signal in the scope window
Fig. 13.24 Step signal block and its parameters
13.2
Source
377

13.2.4
Sine Wave
In Simulink, the Sine Wave block is available that can generate a sine wave signal.
The destination path of the Sine Wave block is shown below:
Navigation route:
Simulink Library Browser!Simulink!Sources!Sine Wave
For any sine wave, it is important to have the ﬂexibility to customize different
parameters such as amplitude, frequency, phase, etc. In Simulink, these parameters
can be customized as shown in Fig. 13.26. The sine wave function in the Simulink
can be observed in the parameter window of the Sine Wave block (Fig. 13.26),
where the parameters are explained initially. In the following example, the amplitude
and the frequency of the sine wave signal are selected as 5 and 1. The rest of the
parameters are assigned as zero. The output sine wave signal can be seen through the
Scope block, which is demonstrated in Fig. 13.27.
Fig. 13.26 Sine wave block and its parameters
378
13
Commonly Used Simulink Blocks

13.2.5
Constant
Constant is another source available in Simulink, capable of providing any numeric
values or array of numbers as input. The navigation path of the Constant block is
given below:
Navigation route:
Simulink Library Browser!Simulink!Sources!Constant
In Fig. 13.28, two examples are provided, where in the ﬁrst example, a single
numeric value is given as input. In the other example, an array of numbers is
provided as input. In the Display blocks, the outputs can be observed.
In Fig. 13.29, the parameter customization of the Constant blocks for the two
different examples is shown. It is to be noted that, for providing an array as an input,
the third bracket needs to be used along with commas among the different numbers.
The Constant block can also be used to provide a matrix as the input. An example
is given in Fig. 13.30 to show the procedure of assigning a matrix input via the
Constant block:
Fig. 13.27 Sine wave in the scope window
13.2
Source
379

13.3
Math Operators
One of the important features of Simulink is its vast library of Math Operators. By
using several blocks that can perform mathematical operations, any mathematical
model can be simulated in the Simulink. Out of several Math Operators blocks, some
of the widely used blocks will be explained in this section.
Fig. 13.29 Block parameters of the constant blocks
Fig. 13.28 Sine wave in the scope window
380
13
Commonly Used Simulink Blocks

13.3.1
Abs and MinMax
Abs and MinMax are two mathematical operators that can be utilized in the
Simulink. These two blocks can be found in the Simulink Browser by following
the steps mentioned in Fig. 13.31.
The Abs block can determine the absolute value of any number including a
complex number as well. In Fig. 13.32, two examples are given, where in the ﬁrst
example, a negative number 2 is given as input. The Abs block can determine the
absolute value of 2, which is 2, and is displayed in the Display block. In the second
example, a complex number 3 + 4i is given as input. The absolute value of this
number should be
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
3
ð
Þ2 þ 42
q
¼ 5, which can be observed in Display 2.
In Fig. 13.33, two examples of MinMax block are demonstrated. MinMax block
is capable of ﬁnding out either the maximum or the minimum value from an array of
numbers. In the ﬁrst example of Fig. 13.33, the MinMax block is conﬁgured to
determine the minimum value from an array input, which is given by a Constant
block. From the array of numbers, it can be seen that the minimum value is 2.5, the
same value displayed in the Display 3. In the second example, for the same given
input array, the MinMax block is conﬁgured in its maximum mode to determine the
maximum value from the array. In Display 4, it can be observed that the block can
determine the maximum value from the array, which is 10.
It is to be noted that, to conﬁgure the MinMax block either in minimum or
maximum mode, the parameter window needs to be customized by double-clicking
on the block. In Fig. 13.34, the parameter window of the MinMax block is shown,
where the Function has a dropdown options list that incorporates the min and max
options. While the user needs to conﬁgure the MinMax block in minimum mode, the
Function option needs to be selected as min. For conﬁguring the block in the
maximum mode, the max option needs to be selected. Thus, the MinMax block
can be utilized for determining either maximum or minimum values from an input
array.
Fig. 13.30 Constant matrix
13.3
Math Operators
381

13.3.2
Add, Subtract, and Sum of Elements
Some of the basic operations of mathematics are addition, subtraction, and the sum
of elements. In Simulink, these three operations can be performed graphically using
separate blocks—Add, Subtract, Sum of Elements—which are shown in Fig. 13.35.
The navigation routes of these three blocks are listed below:
Navigation route:
(continued)
Fig. 13.32 Math operations in the Simulink library browser
Fig. 13.31 Math operations in the Simulink library browser
382
13
Commonly Used Simulink Blocks

Add: Simulink Library Browser!Simulink!Math Operations!Add
Subtract:
Simulink
Library
Browser!Simulink!Math
Operations!Subtract
Sum
of
Elements:
Simulink
Library
Browser!Simulink!Math
Operations!Sum of Elements
Fig. 13.33 Use of the MinMax block
Fig. 13.34 Block parameters of the MinMax block
13.3
Math Operators
383

An example is given in Fig. 13.36, where all three of these blocks are utilized in
the same model. Two Constant blocks are connected with the two input ports of the
Add block. Similarly, two other Constant blocks are also connected with the input
ports of the Subtract block as well. The Constant blocks are used to provide
numerical input to the ports. The output of the Add and Subtract blocks are set as
the inputs for the Sum of Elements blocks. In the three Display blocks, “Display”
indicates the output of the Add block; “Display 2” shows the output of the Subtract
block; and “Display 1” refers to the output of the Sum of Elements block.
13.3.3
Product and Divide
Product and Divide blocks in the Simulink perform the multiplication and division
operation. The navigation routes of these two blocks are provided below:
Fig. 13.36 Use of the Add, Subtract, and Sum of Elements blocks
Fig. 13.35 Blocks for Add, Subtract, and Sum of Elements
384
13
Commonly Used Simulink Blocks

Navigation route:
Product:
Simulink
Library
Browser!Simulink!Math
Operations!Product
Divide: Simulink Library Browser!Simulink!Math Operations!Divide
Product
In Fig. 13.37, two examples of the implementation of the Product block are shown.
In the ﬁrst example, two numeric numbers are provided as input via two Constant
blocks to perform the multiplication of these two numbers. In the second example,
instead of a single numerical value, two matrices are provided as input for the
Product block. The Constant 3 block is used to give the ﬁrst matrix input of size
2  2, and the Constant 4 block provides a 2  3 size matrix as the second input. The
Product 1 block is customized to perform Matrix Multiplication from the parameter
window of the Product 1 block as shown in Fig. 13.38. By selecting the Multipli-
cation option “Matrix(*),” the Product 1 block can be used to perform matrix
multiplication. From the output shown in Display 1 (Fig. 13.37), it can be observed
that the size of the output matrix is 2  3, which proves that the matrix multiplication
has occurred. If the user wants to perform element-wise multiplication, the size of the
two input matrices needs to be of the same size, and the Multiplication option from
the Product 1 parameter window needs to be assigned as “Element-wise(.*).”
Divide
Divide block can be used to perform Division operations. In Fig. 13.39, three
separate examples are provided for three different inputs. In the ﬁrst example, two
Fig. 13.37 Use of the product block
13.3
Math Operators
385

numeric numbers are provided to perform simple division among them. In the
second example, two matrices of the same size are provided as input to perform
element-wise division. Finally, in the last example, a single matrix is provided as
input, and the Divide 2 block is customized from its parameter window to perform
Matrix operation instead of Element-wise operation (Fig. 13.40). By selecting the
“Matrix(*)” option, the Divide 2 block is utilized to determine the inverse matrix of
the given input matrix in the last example.
13.3.4
Sum and Sqrt
Sum and Sqrt are two widely used mathematical operators of Simulink. The navi-
gation routes of these two blocks are listed below:
Navigation route:
Sum: Simulink Library Browser!Simulink!Math Operations!Sum
Sqrt: Simulink Library Browser!Simulink!Math Operations!Sqrt
Fig. 13.38 Block parameters of the product block
386
13
Commonly Used Simulink Blocks

Fig. 13.40 Block parameters of the divide block
Fig. 13.39 Use of the divide block
13.3
Math Operators
387

Sum
The Sum block can be utilized to perform multiple addition, subtraction, or combi-
nation of both of them as shown in Fig. 13.41. In the ﬁrst example, two numeric
values are summed up. Therefore, in the Sum block, two additions are placed via the
customization made from its parameter window. In Fig. 13.42, the parameter
window of the Sum block is shown on the right side. On that window, the blank
option named “List of signs” is ﬁlled with “|++.” Here, the “|” sign is used to place
space among the two signs mentioned later by “++.” In the Sum block, the user may
use multiple signs to perform multiple addition or subtraction operations using a
single block. To place the signs in the block in a more presentable way, the user has
the ﬂexibility to control the space among the signs by using the “|” sign. A second
example is shown in Fig. 13.41, where the two “+” signs and one “-” sign are
incorporated in the Sum 1 block. The customization of the block from the parameter
window can be observed from the left ﬁgure of Fig. 13.42.
Sqrt
Sqrt block in the Simulink can perform three operations—square root, reverse square
root, and signed square root. A Simulink model example demonstrating these three
operations is provided in Fig. 13.43. In the model, three examples performing these
three operations are shown. In the ﬁrst example, a positive numeric number, 36, is
given as input of the Sqrt block. Sqrt block can be customized from its parameter
window, which has been shown in Fig. 13.44. In the parameter window, there is a
Fig. 13.41 Use of the sum block
388
13
Commonly Used Simulink Blocks

dropdown option box under the name Function. This dropdown box has three
options—sqrt, signed Sqrt, and rSqrt. In the ﬁrst example shown in Fig. 13.43, the
sqrt option is chosen for the Sqrt block. For the Sqrt 1 block, the rSqrt option is
selected, which indicates the reverse square root operation. Right after selecting the
rSqrt option from the dropdown option, it can be seen that the symbol within the Sqrt
1 block changes from
ﬃﬃﬃu
p to
1ﬃﬃu
p .
Here, u indicates the given input. Similarly, for the Sqrt 2 block, the Function
option is set as SignedSqrt, which indicates the operation that will be performed by
Fig. 13.42 Block parameters of the sum block
Fig. 13.43 Use of the sqrt block
13.3
Math Operators
389

the block is 
ﬃﬃﬃﬃﬃﬃ
uj j
p
. The results of the three conﬁgured Sqrt blocks are displayed in
three Display blocks.
13.3.5
Complex to Magnitude-Angle and Complex
to Real-Imag
In Chap. 4, the representation of any complex number in two different forms—
rectangular and polar form—is explained. In Simulink, the Complex to Magnitude-
Angle block is available, where any complex number in its rectangular form can be
given as input, and the block can determine the magnitude and the angle. Another
block named Complex to Real-Imag block in the Simulink can perform the deter-
mination of real and imaginary values from a complex number. The navigation
routes of these two blocks are given below:
Navigation route:
Complex
to
Magnitude-Angle:
Simulink
Library
Browser!Simulink!Math Operations!Complex to Magnitude-Angle
Complex to Real-Imag: Simulink Library Browser!Simulink!Math
Operations!Complex to Real-Imag
A model given in Fig. 13.45 comprises two examples where these blocks are
implemented. For both of these two blocks, a complex number, 2 + 5i, is given as
input via the Constant blocks. In the ﬁrst example, the Complex to Magnitude-Angle
Fig. 13.44 Block parameters of the sqrt block
390
13
Commonly Used Simulink Blocks

block can calculate the magnitude and angle of the complex number in its polar
form. From the Display and Display 1 blocks, the magnitude and the angle can be
observed. It is to be noted that the user has the ﬂexibility to choose the output of the
block either as only magnitude, or only angle, or both of them. It can be customized
from the parameter window of the Complex to Magnitude-Angle block as shown in
Fig. 13.46. Similarly, in the second example, the same complex number is given as
input to the Complex to Real-Imag block, which determines the real and imaginary
values from the complex number that are displayed in the Display 2 and Display
3 blocks. Similar to the Complex to Magnitude-Angle block, this block also provides
the opportunity to choose the output as only real value, only imaginary value, or both
of them from its parameter window (Fig. 13.46).
Fig. 13.45 Use of the Complex to Magnitude-Angle and Complex to Real-Imag blocks
Fig. 13.46 Block parameters of the Complex to Magnitude-Angle and Complex to Real-Imag
blocks
13.3
Math Operators
391

13.3.6
Magnitude-Angle to Complex and Real-Imag
to Complex
Magnitude-Angle to Complex and Real-Imag to Complex blocks perform just the
opposite operations of the previously mentioned two blocks. Given the input in
terms of magnitude and angle, the Magnitude-Angle to Complex block can deter-
mine the complex number in rectangular form. For the Real-Imag to Complex block,
the real and imaginary numbers are given as inputs, and the block can determine the
complex number in its rectangular form. The navigation routes of these two blocks
are mentioned below:
Navigation route:
Magnitude-Angle
to
Complex:
Simulink
Library
Browser!Simulink!Math Operations!Magnitude-Angle to Complex
Real-Imag to Complex: Simulink Library Browser!Simulink!Math
Operations!Real-Imag to Complex
In Fig. 13.47, a Simulink model comprising the implementation of these two
blocks is given. The customization of the input port of these two blocks can be
performed from their parameter window, as shown in Fig. 13.48.
13.3.7
Math Function
The Math Function block is a very useful block to perform mathematical operations
in the Simulink. The Math Function block is available in the following path of the
Simulink Library Browser:
Fig. 13.47 Use of the Magnitude-Angle to Complex and Real-Imag to Complex blocks
392
13
Commonly Used Simulink Blocks

Navigation route:
Math
Function:
Simulink
Library
Browser!Simulink!Math
Operations!Math Function
The Math Function block can be utilized to perform 14 different mathematical
operations. To choose a particular mathematical operation using the Math Function
block, it needs to be customized ﬁrst from its parameter window. In Fig. 13.49, six
operations out of the available 14 operations are shown to grasp the idea of utilizing
the Math Function block. In Fig. 13.50, the parameter window of the Math Function
block is shown, where under the Function option, a dropdown options list is
available. In the list, the name of the 14 mathematical functions is enlisted. The
user can choose any one of the function names from this list to make the Math
Function block perform that particular operation. For example, in Fig. 13.49, the ﬁrst
Math Function block is customized for a function name “exp.” Hence, it can be
observed that the symbol within the Math Function block is changed into eu, where
u is the input of the block. In the second example, the function name of the Math
Fig. 13.48 Block parameters of the Magnitude-Angle to Complex and Real-Imag to Complex
blocks
Fig. 13.49 Use of the math function blocks
13.3
Math Operators
393

Function 1 block is selected as “square.” Similarly in the third example, “rem”
option is chosen for the Math Function 2 block, which automatically creates two
input ports in the block, due to its necessity to perform the remainder operation.
Three more examples are also provided in the model shown in Fig. 13.49. The
parameter window of the Math Function has another parameter called “Output signal
type,” which can be customized as auto, real, or complex. The user may choose any
of these types to display the output results in the Display blocks.
13.3.8
Trigonometric Function
The Trigonometric Function in the Simulink block can perform trigonometric
operations. The navigation route of this block is listed below:
Navigation route:
Trigonometric Function: Simulink Library Browser!Simulink!Math
Operations!Trigonometric Function
The Trigonometry Function block can perform 16 operations in the Simulink. A
model is provided in Fig. 13.51, where three examples are given with three different
operations. To select a particular trigonometric operation, the parameter window of
the Trigonometry Function block needs to be customized, which is shown in
Fig. 13.52. In the parameter window, 16 operations are available, out of which
three operations are shown in the model of Fig. 13.51. In this model, the ﬁrst block is
customized for “sin” operation, the second block for “acos” operation, and the third
block for “tanh” operation. In the second example, a “Gain” block is used in the
Fig. 13.50 Block parameters of the math function blocks
394
13
Commonly Used Simulink Blocks

middle to multiple the answer with “180/pi” value to convert the output from radian
to degree value. Therefore, the Display 1 indicates the value 60 in degree unit instead
of radian unit.
Fig. 13.52 Block parameters of the trigonometric function blocks
Fig. 13.51 Use of the trigonometric function blocks
13.3
Math Operators
395

13.3.9
Derivative and Integrator
In Simulink, derivation and integration can be performed by using graphical blocks
Derivative and Integrator. The navigation routes of these two blocks are demon-
strated in Fig. 13.53.
In Fig. 13.54, a Simulink model is shown where a ramp signal is differentiated
ﬁrst by using the Derivative block, and later the output is integrated by using the
Integrator block. The input ramp signal, the output signal from the Derivative block,
and the output signal from the Integrator block are connected with the input ports of
the Scope block. The number of input ports of the Scope block can be set by right-
clicking on the Scope block and navigating to “Signal and Ports!Number of Input
Ports!3.” As integration is the opposite of differentiation, in this example, the
output of the Integrator block should be identical to the input signal. After simulating
the model, the input and the output signals can be observed from the Scope window
as shown in Fig. 13.55.
Fig. 13.54 Use of the derivative and integrator blocks
Fig. 13.53 The derivative and integrator blocks
396
13
Commonly Used Simulink Blocks

13.4
Port and Subsystem
One of the interesting features of the Simulink is the subsystem. A subsystem is a
group of blocks that constitutes a part of the entire system. The blocks that comprise
a subsystem reside in another layer; therefore, a subsystem can make the original
design model simple to represent. It can also be helpful when a particular part of a
system is required multiple times in the same design. In that case, a subsystem can be
very useful, as it works almost like a user-deﬁned block. The difference between a
subsystem and a user-deﬁned block is that a subsystem does not require to be
programmed by MATLAB. While creating a subsystem, two types of ports—In1
and Out1—become very necessary to establish the connection between the
subsystem and the original system. Apart from that, there are also some other
types of ports, which are necessary while designing a model in the Simulink. Mux
and Demux are two widely used port blocks in the Simulink. The procedures of
creating a subsystem and the usage of the other ports are described in the following
subsections.
Fig. 13.55 Scope window output of the ramp, derivative, and integrator blocks
13.4
Port and Subsystem
397

13.4.1
Subsystem, In1, and Out1
To explain the procedures of creating a subsystem, an example is considered where a
subsystem will be created that incorporates a Derivative and an Integrator block. The
subsystem will have two inputs and two outputs. The ﬁrst input will represent the
Derivative signal of the given ﬁrst input. On the other hand, the second output of the
subsystem will indicate the integration of the second input signal. To complete this
objective, the following steps need to be followed:
Step 1: Drag a Derivative and an Integrator block to the Simulink design window
following the navigation route described previously in Sect. 13.3.9.
Step 2: Select both of the blocks, which will create the appearance of three blue
dots as indicated in the ﬁrst ﬁgure of Fig. 13.56. Drag the mouse over these three
blue dots, which will create a small blue ribbon with multiple options represented by
small icons. Move the mouse over these options one by one, which will show the
name of each option. Find out the option called “Create Subsystem” as shown in the
second ﬁgure of Fig. 13.56, and click on it.
Step 3: Another alternative method of creating a subsystem is to skip the second
step and follow the step that will be mentioned in this step. Step 3 is to select the
Derivative and the Integrator block as before, and right-click on the mouse. This will
create the appearance of a small window from where choose the option “Create
Subsystem from selection” as shown in Fig. 13.57. Another shortcut method of
creating a subsystem is to select the two blocks and type “ctrl+G.”
Step 4: By following either Step 2 or Step 3, a subsystem can be created. When a
subsystem is created, it will appear as the ﬁgure shown in Fig. 13.58 with two input
and two output ports. Right-click on the Subsystem, which will make the appearance
of another layer named Subsystem that incorporates the original two blocks as
shown in Fig. 13.59.
In Fig. 13.59, it can be observed that In1 and In2 blocks appear in the input ports,
while Out1 and Out2 ports appear in the output ports automatically. The name of
these ports can be changed from their parameter window.
Fig. 13.56 Creating subsystem
398
13
Commonly Used Simulink Blocks

Fig. 13.58 Subsystem
Fig. 13.57 Creating subsystem from selection
13.4
Port and Subsystem
399

The subsystem is created, and the next step is to complete the original model by
providing input signals to the two input ports and connecting a scope to the output
side. The complete model is shown in Fig. 13.60, where a Ramp block is connected
to port 1 and a Sawtooth Generator block is connected to port 2. The navigation
routes of both of these sources are given below:
Navigation route:
Ramp: Simulink Library Browser!Simulink!Sources!Ramp
Sawtooth
Generator:
Simulink
Library
Browser!Simulink!Quick
Insert!Sources!Sawtooth Generator
After simulating the model, the output signals can be observed from the Scope
window as shown in Fig. 13.61.
Fig. 13.60 Complete Simulink diagram of the subsystems
Fig. 13.59 Simulink diagram of the subsystems
400
13
Commonly Used Simulink Blocks

13.4.2
Mux and Demux
Mux block is used to combine multiple signal lines into a signal one, while the
Demux block is used to do the opposite. The navigation routes of these two blocks
are listed below:
Navigation route:
Mux: Simulink Library Browser!Simulink!Signal Routing!Mux
Demux: Simulink Library Browser!Simulink!Signal Routing!Demux
A Simulink model is shown in Fig. 13.62, where the usage of both of these blocks
is shown in two separate examples. In the ﬁrst example, the two signal lines from
two constant blocks are connected with a Mux block, which converts them into a
single output line. However, when this output line is connected with the Display
block, it can be observed that the Display block shows the two original values
Fig. 13.61 Output signals of the two subsystems
13.4
Port and Subsystem
401

obtained from the two Constant blocks. It proves that the Mux block does not create
any data loss in the process. In the second example, one Constant block is connected
with the input of Demux. The Constant block provides an array of two values as
input. The Demux creates two output lines, one of which displays the ﬁrst value of
the array and the second output line displays the other value of the array.
The number of inputs of the Mux block and the number of outputs of the Demux
block can be customized from their parameter windows as shown in Fig. 13.63.
13.5
Logical Operator, Relational Operator, Programs,
and Lookup Table
Logical operators and relational operators can be useful in some applications in the
engineering domain. Although they can be programmed in MATLAB, Simulink
provides the opportunity to implement the same logic via graphical blocks. In this
section, the procedures to implement both logical and relational operators will be
explained with examples. In Simulink, programs such as “If” and “Switch Case” can
also be implemented graphically, which will be demonstrated via examples. Another
Fig. 13.63 Block parameters of Mux and Demux
Fig. 13.62 Simulink diagram of Mux and Demux
402
13
Commonly Used Simulink Blocks

important block of Simulink is the Lookup Table, which is useful while performing
graphical approximation. All of these topics will be covered in this section with the
necessary illustrations.
13.5.1
Logical Operator
In Simulink, the Logical Operator block can be found in the following path of the
Simulink Library Browser:
Navigation route:
Logical Operator: Simulink Library Browser!Simulink!Logic and Bit
Operations!Logical Operator
By using the Logical Operator block, seven logical operations can be performed.
To select a particular logical operator, double-click on the block for opening the
parameter window. In the parameter window of the Logical Operator, a dropdown
options list will be available under the Operator option as shown in Fig. 13.64. In this
dropdown list, seven logical operators such as AND, OR, NAND, NOR, XOR,
NXOR, and NOT are available to implement.
In the Simulink models shown in Fig. 13.65, two examples are provided with two
different logical operators—AND and OR.
Fig. 13.64 Block parameters of logical operator
13.5
Logical Operator, Relational Operator, Programs, and Lookup Table
403

13.5.2
Relational Operator
In Simulink, the Relational Operator block is available in the following navigation
path of the Simulink Library Browser:
Navigation route:
Relational Operator: Simulink Library Browser!Simulink!Logic and Bit
Operations!Relational Operator
By double-clicking on the Relational Operator block, the parameter window of
the block can be opened. From this parameter window, ten relational operators are
available in a dropdown options list under the Relation Operator option as shown in
Fig. 13.66.
In Fig. 13.67, two examples are provided side by side with two different inputs. In
both of these examples, the Relational Operator block is customized for the “Greater
than equal, ” option. In the ﬁrst example, two numeric numbers 10 and 5 are given
as inputs of the Relational Operator block. If the statement “1st input 2nd input” is
true, the Relational Operator block will provide output 1, otherwise 0. For the ﬁrst
example, “10 5” is true; therefore, the output in the Display block after the
simulation is 1. In the second example, the inputs are altered; hence, “5  10”
becomes false. Consequently, the output of the Relational Operator block as
displayed in the Display 1 block is 0.
13.5.3
If and Switch Case
“If” Block
In Simulink, the “If” block along with the “If Action Subsystem” block can perform
the “If-else” program. The “If” block is used to provide the conditions, and the “If
Action Subsystem” is utilized to deﬁne the tasks for different conditions. The
navigation path of both of these blocks is given below:
Fig. 13.65 Logical AND and OR operators
404
13
Commonly Used Simulink Blocks

Navigation route:
If: Simulink Library Browser!Simulink!Ports and Subsystems!If
If Action Subsystem: Simulink Library Browser!Simulink!Ports and
Subsystems!If Action Subsystem
The implementation of the above-mentioned blocks is demonstrated in the
following ﬁgures. In Fig. 13.68, the parameter window of the “If” block is shown.
At the beginning of the parameter window, the general format of the “If” expression
is described. For each “If” and “Elseif” statement, a condition (expression) and
action are required to be deﬁned. The action will only be fulﬁlled if the input satisﬁes
the associated condition or expression. The input can be a single variable, or multiple
variables, depending on the application. From the parameter window, the number of
inputs can be speciﬁed. For this example, the number of inputs parameter is set as
1. The second step of customization is to provide the sets of expressions for both “If”
Fig. 13.66 Block parameters of relational operator
Fig. 13.67 Demonstration of the operation of the relational operator block
13.5
Logical Operator, Relational Operator, Programs, and Lookup Table
405

and “Elseif.” In this example, the expression of the “If” statement is deﬁned as
u1  10, and for the “Elseif” statement, the assigned expression is u1 < 10 & u1 > 0.
It is to be noted that the operators used to deﬁne the expression are explained
previously in Sect. 13.3.4. At the end of the parameter window, there are two
checkbox options, one of which is named “Show else statement.” This is an optional
condition that depends on the users’ preference. For this example, “Else” is consid-
ered to be included; hence, the checkbox option is checked, as shown in Fig. 13.68.
To summarize, the number of inputs is set as 1; hence, the “If” block has one input
port in the model shown in Fig. 13.69. “If,” “Elseif,” and “Else”—all three of these
statements—are selected, which have created three output ports for the “If” block.
For each of these three statements, an “If Action Subsystem” block is connected.
These three connection lines can be seen as dotted lines from the model designed in
Fig. 13.69. The reason for such dotted lines can be understood from the logic of
operations of these two types of blocks. When an input is provided via the Constant
block to the input port of the “If” block, the block checks the deﬁned expressions one
by one from its parameter window by considering the input value. If the ﬁrst
Fig. 13.68 Block parameters of the if block
406
13
Commonly Used Simulink Blocks

expression under the “If” statement satisﬁes the expression for the given input, the
line connection between the ﬁrst output port to the “If Action Subsystem” block
becomes active, and the other two output ports remain inactive. Therefore, only the
task deﬁned in the ﬁrst “If Action Subsystem” block is executed in such a scenario. If
the expression of the “If” statement does not satisfy the input value, the “If” block
will shift to the next “Elseif” expression for the veriﬁcation. If this expression is
satisﬁed by the input value, the second output port will be activated, and only the
task of the “If Action Subsystem 1” will be executed. Similarly, if the “Elseif”
expression turns out to be false for the input value, the third output port will be
activated. Hence, only the task deﬁned in the “If Action Subsystem 2” block will be
performed. This is the general overview of the working procedure of the “If” and “If
Action Subsystem” blocks.
The input of Fig. 13.69 is set in such a way that it satisﬁes the “If” expression.
Therefore, the task of the “If Action Subsystem” block is executed and the result can
be observed in the Display block. As only the task of the ﬁrst “If Action Subsystem”
block is executed, the output of the other “If Action Subsystem” blocks can be seen
as zero from the Display block.
For the second model shown in Fig. 13.70, the input is changed that does not
satisfy the “If” expression but satisﬁes the expression of the “Elseif.” Therefore, the
task of the “If Action Subsystem 1” block is executed, and the result can be seen
from the second output result of the Display block. The rest of the outputs of the
Display block becomes zero, in this case.
In Fig. 13.71, the input value does not satisfy any of the “If” and “Elseif”
expressions, thereby the task of the “If Action Subsystem 2” connected with the
“Else” port becomes active. From the Display block, the third output refers to the
result, while the remaining two outputs become zero due to inactivity.
Fig. 13.69 Simulink diagram of the if…else block for the constant 12
13.5
Logical Operator, Relational Operator, Programs, and Lookup Table
407

The tasks performed by each “If Action Subsystem” blocks need to be deﬁned
before the simulation. This can be performed by customizing their parameter
windows. The deﬁned tasks for this particular example are demonstrated in
Fig. 13.72. The results can be veriﬁed from the output of the Display block.
“Switch Case”
The “Switch Case” block works almost as similar as the “If” block. Instead of “If,”
“Elseif,” and “Else” statements, in the “Switch Case” block, the expressions are
deﬁned under “Case [1],” “Case [2],” . . ., “default” statements. The user has the
preference to create as many cases as necessary. To deﬁne the number of cases, and
the associated condition, the parameter window of the “Switch Case” block needs to
be customized as shown in Fig. 13.73.
Fig. 13.70 Simulink diagram of the if…else block for the constant 2
Fig. 13.71 Simulink diagram of the if…else block for the constant −2
408
13
Commonly Used Simulink Blocks

Fig. 13.72 The three subsystems of if action
Fig. 13.73 Block parameters of the switch case
13.5
Logical Operator, Relational Operator, Programs, and Lookup Table
409

In the parameter window, the “Case Conditions” is deﬁned as {1,2}, which
implies if the input is 1, the output port 1 will run, and for input 2, the port 2 will
become active. Inside the curly bracket, each numeric value separated by commas
creates an individual case. The numeric value deﬁnes the input value for which the
port associated with that case will be run. For example, for a condition {[1,2], 3},
two separate cases will be created as inside the curly bracket there are two types of
data separated by one comma. For the ﬁrst data, an array of [1,2] can be seen, which
indicates that port 1 of Case 1 will become active when the input will be either 1 or
2. If the input becomes 3, port 2 associated with Case 2 will become active. If the
“Show default case” option is checked, another port named “default” will be created
as an output port of the “Switch Case” block. The “Switch Case” block only
determines which case will run based on the given input. For each case, the task
that needs to be performed can be deﬁned by the “Switch Case Action Subsystem”
block, which works almost similar to the “If Action Subsystem” block. When a
particular case becomes active, the “Switch Case Action Subsystem” associated with
that case becomes active, and only the task deﬁned under that particular block is
executed. In our example, two cases are considered along with an additional
“default” case. Therefore, the “Switch Case” block has three output ports that are
connected with three separate “Switch Case Action Subsystem” blocks. The tasks of
these three blocks are deﬁned as shown in Fig. 13.74.
Fig. 13.74 The three subsystems of the switch case action
410
13
Commonly Used Simulink Blocks

In Fig. 13.75, the complete model is shown with an input set as 1. The “Case
Conditions” is selected as {1,2} as mentioned earlier for this example. As the input is
1, Case [1] becomes activated and the task of the “Switch Case Action Subsystem” is
executed. The task is deﬁned in Fig. 13.74a, and it can be observed that the task is to
provide the square output of its input. The inputs of the three “Switch Case Action
Subsystem” blocks are set as the same value, which is 4. Therefore, the output result
of the ﬁrst “Switch Case Action Subsystem” should be the square of 4. From the
display, the same result can be found for the ﬁrst output, while the remaining two
outputs are zero, as they are inactive. In Fig. 13.76, the input of the “Switch Case”
block is set as 2, which activates the port of the Case [2]. Hence, the task of the
“Switch Case Action Subsystem 1” block is executed and displayed in the Display
block. Similarly, from Fig. 13.77, it can be observed that the input of the “Switch
Case” block activates the “default” case port, and thus, the task of the “Switch Case
Action Subsystem 2” is executed only and displayed in the Display block.
It is to be noted that both the “Switch Case” and the “Switch Case Action
Subsystem” blocks are available in the destination of the Simulink Library
Browser!Simulink!Ports and Subsystems.
13.5.4
Lookup Tables
In Simulink, different Lookup Tables are available. In this section, the Lookup
Table Dynamic block will be explained in detail due to its wide usage in the
engineering domain. Lookup Table Dynamic block can be useful to approximate
missing values based on a given data. It can produce data for interpolation or
extrapolation, and also for other applications. The navigation route of this block in
the Simulink Library Browser is listed below:
Fig. 13.75 Switch case action subsystems with constant 1
13.5
Logical Operator, Relational Operator, Programs, and Lookup Table
411

Navigation route:
Simulink
Library
Browser!Simulink!Lookup
Tables!Lookup
Table Dynamic
In the following example, the Lookup Table Dynamic block is utilized to
approximate unknown values of a given dataset base. In the block shown in
Fig. 13.78, there are three input ports—x, xdat, and ydat. “xdat” and “ydat” are
the given dataset of x and y pairs. “x” represents the values of x for which the values
of corresponding “y” values are unknown. The Lookup Table Dynamic in Fig. 13.79
can approximate the values of “y” for the corresponding “x” values based on the
given dataset, as shown in the Display block.
Fig. 13.76 Switch case action subsystems with constant 2
Fig. 13.77 Switch case action subsystems with constant 3
412
13
Commonly Used Simulink Blocks

13.6
Conclusion
A Simulink model is comprised of blocks and lines; hence, the readers need to learn
about as many blocks as possible that will be useful while designing any physical
model. With that intent in mind, this chapter presents some of the most commonly
used blocks which are categorized among different types for the convenience of
keeping track of them. The chapter initiates by introducing some of the common
blocks of sink and source type. The source type blocks are important to provide input
to any physical model, while the sink acts for displaying the output. In Simulink,
almost all possible mathematical operations can be performed by utilizing different
math operator blocks, some of which are incorporated in this chapter with necessary
illustrations. The subsystem is another important feature of Simulink, which is
Fig. 13.79 Block parameters of the Lookup Table Dynamic
Fig. 13.78 Simulink diagram of the Lookup Table
13.6
Conclusion
413

explained along with the demonstration of some important ports such as In1, Out1,
etc. In Simulink, apart from mathematical operators, many logical and relational
operators are also available in terms of different blocks. In the programming context,
“if” and “switch” are two important programs, which can also be implemented in
Simulink with graphical tools. This chapter introduces all of these aspects with the
usage of relevant blocks. Finally, the chapter ends by demonstrating the Lookup
Table considering its importance in the engineering domain. The main objective of
this chapter is to provide the readers some practical insights regarding several blocks
to make them comfortable with the Simulink environment more rigidly.
Exercise 13
1. Name some of the types of commonly used Simulink blocks, and provide two
examples from each type.
2. (a) What are the importance of source type blocks in Simulink?
(b) Generate the following sine waves using the Sine Wave block and show them
in the two Scope blocks:
(i) 5 sin (2π  60  t)
(ii) 2 sin (50  t)
(c) Show the same sine waves as mentioned in (b), by utilizing single ﬂoating
scope.
3. (a) Write down the formulas to convert a coordinate from its polar form to
rectangular form and vice versa.
(b) Consider the following two complex numbers in their rectangular form. Use
Complex to Magnitude-Angle block to determine their polar form:
(i) 0.5 + 3i
(ii) 2 + 0.5i
(c) Perform the previous task in (b), by using blocks in the mathematical
operations except for the Complex to Magnitude-Angle block. Verify the result
with the previous one.
4. (a) What is a subsystem? Write down some of the advantages of creating a
subsystem.
(b) Create a subsystem that can take two inputs (input1, input2), and provide the
following output:
Output ¼ 2 sin input1
ð
Þ þ d
dt cos input2
ð
Þ
ð
Þ þ
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
input12 þ input22
q
(c) Show the result using any relevant blocks from the sink type.
414
13
Commonly Used Simulink Blocks

5. (a) What are the general format of the “if” and “switch” blocks?
(b) What is the navigation route of the Lookup Dynamic Table block in the
Simulink Library Browser?
(c) Given any number input, create a model that can determine whether it is even
or not. If it is even, display 1, and if it is odd, display 0. Use any convenient
Programs blocks for the model.
Exercise 13
415

Chapter 14
Control System in Simulink
14.1
Control System
Control system is an important part of the engineering ﬁeld, which makes it crucial to
incorporate some fundamental ideas regarding this topic with the usage of Simulink.
Simulink is widely used as a simulation platform to implement in numerous appli-
cations related to the control system. A control system signiﬁes the system that can
regulate, or control, the output of a system for a given input. The concept of the
control system is very important to ensure the stability of a system and govern the
output according to a predetermined reference. A control system can be categorized
into two types—open-loop control system and closed-loop control system—based
on the structure of a control system. These two individual types will be explained
with necessary illustrations utilizing Simulink in the following subsections:
14.2
Open-Loop Control System
The open-loop control system refers to such systems whose output is controlled with
respect to the input. In such systems, the effect of feedback is not considered; hence,
the output of such systems is never measured. The design of an open-loop system is
not complicated; hence, it is cheaper to implement. Open-loop systems have many
applications in the real world, such as microwave, washing machine, etc. The basic
structure of an open-loop system is demonstrated through a block diagram in
Fig. 14.1, where the control system incorporates both the controller and the funda-
mental process blocks to produce the desired output response subjected to a given
input.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_14
417

14.3
Closed-Loop Control System
In a closed-loop control system, the output of the system is considered for making
adjustments to the input signal for controlling the output with more accuracy. To
consider the effect of output in such a manner is regarded as feedback in the control
system domain. The feedback creates an interconnection between the output and
input; hence, error calculation is a necessary part of such systems to make the proper
adjustments. A basic layout of a closed-loop control system is provided in Fig. 14.2.
A closed-loop control system can be made more accurate and stable than an open-
loop system. However, due to the incorporation of feedback in such systems, the
closed-loop systems are comparatively more complex and costly to implement in
real-time applications.
14.4
Open-Loop vs Closed-Loop Control System
The differences between the open-loop and closed-loop control systems are tabu-
lated in Table 14.1.
14.5
Simulink Model Design
This section describes the design of an open-loop and a closed-loop control system.
Fig. 14.1 Input and output
of a control system
Fig. 14.2 A closed-loop
control system
418
14
Control System in Simulink

14.5.1
Open-Loop Control System
In this section, an open-loop control system will be designed using Simulink to
realize the concepts via simulation. The characteristics of a system are deﬁned by the
transfer function of that system. The concept of the transfer function is explained in
detail previously in Sect. 9.2.2. In an open-loop system, the output is not connected
via any feedback. In Fig. 14.3, a Simulink model demonstrating an open-loop system
is shown. The blocks that are used for the simulation are summarized in the
following Table 14.2 with their navigation routes:
Table 14.1 Various aspects of open-loop and closed-loop control systems
Aspects
Closed-loop control system
Open-loop control system
1. Stability
A closed-loop system may become unstable,
as the controlled parameters may change for
different aspects
An open-loop system will never
become unstable unless the con-
troller is unstable
2.
Sensitivity
The sensitivity of a closed-loop control sys-
tem is comparatively better
The open-loop control system
has poor sensitivity
3. Gain
The gain of a closed-loop system is compar-
atively low
An open-loop system possesses
high gain
4. Accuracy
and
complexity
A closed-loop system is comparatively more
accurate due to its high capability of noise
cancellation, but complex in design
An open-loop system is simple
in design but has less accuracy as
such a system is affected signiﬁ-
cantly by unknown noises or
disturbances
Fig. 14.3 Simulink diagram of an open-loop control system
14.5
Simulink Model Design
419

The parameters of the Transfer Fcn block are customized from its parameter
window as shown in Fig. 14.4. The considered transfer function of the system in this
example is
1
2sþ3. To customize this exact function in the Transfer Fcn block from its
parameter window, the numerator and the denominator of the function need to be
deﬁned in terms of an array. In the parameter window shown in Fig. 14.4, the ﬁrst
parameter is named “Numerator coefﬁcients,” which is set as [1]. For the “Denom-
inator coefﬁcients,” an array [2 3] is assigned, where 2 represents the coefﬁcient of
“s” and 3 represents the constant. The concept of deﬁnition is almost similar to the
built-in function tf(), which was used in the MATLAB section. By providing the
coefﬁcients of the numerator and the denominator, the Transfer Fcn block can ﬁgure
out the transfer function of the system, and it will appear automatically within the
Transfer Fcn block as shown in Fig. 14.3. The Gain block is customized by setting
Table 14.2 The blocks and navigation routes used in Fig. 14.3
Blocks
Navigation routes
Step
Simulink Library Browser!Simulink!Sources!Step
Gain
Simulink Library Browser!Simulink!Sources!Gain
Transfer Fcn
Simulink Library Browser!Continuous!Transfer Fcn
Scope
Simulink Library Browser!Sinks!Scope
Fig. 14.4 Block parameters of the transfer function block for the open-loop control system
420
14
Control System in Simulink

Fig. 14.5 Block parameters of the gain block of the open-loop control system
Fig. 14.6 The output in the scope window of the open-loop control system
14.5
Simulink Model Design
421

the value 4 (Fig. 14.5), which will be multiplied with the transfer function of the
system. After simulating the model, the output response of the open-loop system can
be observed from the Scope window as shown in Fig. 14.6. Simulink provides the
opportunity to observe the output response of an open-loop system for different
transfer functions and gain value. The impacts of the gain on the output response of
the system can be observed from the Scope window by changing the value of gain
from the parameter window of the Gain block. Thus, the transfer function can also be
changed to simulate a completely different system, by only changing the customi-
zation of the Transfer Fcn. Before designing a control system in practice with real
instruments, Simulink provides the opportunity to test different systems for varying
parameters with an objective to build up a prototype on the Simulation platform. It
reduces the cost of performing testing procedures with real instruments, and also the
efforts. This is one of the most important beneﬁts of utilizing Simulink for the
control system domain.
14.5.2
Closed-Loop Control System
A Simulink model of a closed-loop control system is illustrated in Fig. 14.7. The
considered transfer function for such a system is
1
2s2þ3sþ5. As a controller, PID is
considered for the following system. As the system is a closed-loop system, there
needs to be a feedback gain among the output and the input. In this example, unity
feedback gain is considered. If the feedback gain is not unity, a Gain block needs to
be inserted into the line between the output and the input. The input of the system is
provided by using the Step block. The feedback gain connects with the input via the
Fig. 14.7 Simulink diagram of a PID controller
422
14
Control System in Simulink

Sum block. The Sum block can be customized according to the speciﬁcation of the
system. For this example, the feedback gain is added to the input; therefore, two “+”
signs are used in the Sum block customization. It can be altered from the parameter
window of the Sum block according to the users’ preference for the system.
The customization of the Transfer Fcn block is shown in Fig. 14.8, where the
numerator coefﬁcients and the denominator coefﬁcients are provided. The custom-
ization of the Sum block is demonstrated in Fig. 14.9. Another block named the PID
Controller can also be customized from its parameter window. The PID Controller
has three parameters—Proportional (P), Integral (I), and Derivative (D) constants.
The block can be utilized for P, I, PI, PD, or PID controller by choosing any of the
controller types from the dropdown option list of its parameter window as shown in
Fig. 14.10. For this example, the PID controller is chosen. The values of the three
constants can be deﬁned from the parameter window as well. For ensuring the
stability of the system, the values of these three constants need to be tuned by
varying the values. By selecting appropriate values, the complete design of the
closed-loop control system using the PID controller is ready for the simulation.
After simulating the model, the response can be observed from the Scope window as
shown in Fig. 14.11.
Fig. 14.8 Block parameters of the transfer function block for the PID controller
14.5
Simulink Model Design
423

Fig. 14.9 Block parameters of the sum block
Fig. 14.10 Block parameters of the PID controller
424
14
Control System in Simulink

The Simulation result shows that the response becomes stable after 9 s approxi-
mately. The characteristics of this system can be further analyzed by experimenting
with different parameter values. The parameter value can be swept or changed by
using the MATLAB command window as well. An example of how to change the
value of a parameter or variable using MATLAB command window is shown in the
following example, where the same closed-loop model is used for better
comprehensibility.
Customizing Variables Utilizing MATLAB Command Window
For this example, the value of the Gain block is considered as the variable, which
will be deﬁned by using the MATLAB command window. For doing so, the ﬁrst
step is to set the value of the gain as “K” or other letters from the parameter window
of the Gain block as shown in Fig. 14.12.
The next step is to deﬁne the name of the variable in the MATLAB command
window by assigning a value in there, as shown in Fig. 14.13.
The complete design of the Simulink model is demonstrated in Fig. 14.14, where
the only change is made in the Gain block.
After simulating the model again, the model will now be simulated for the new
value of the gain, K ¼ 6.5. Thus, instead of changing the value from the Simulink,
the value of a particular parameter of a block can be changed from the MATLAB
command window as well. The output response of the system obtained from the
Scope window is shown in Fig. 14.15.
Fig. 14.11 The output in the scope window of the PID controller
14.5
Simulink Model Design
425

Fig. 14.12 Block parameters of the gain block of the PID controller
Fig. 14.13 Deﬁning the
variable for the gain
Fig. 14.14 Complete Simulink diagram of the PID controller
426
14
Control System in Simulink

For another simulation, the value of the gain K is set as 9 from the MATLAB
command window (Fig. 14.16), and the model is simulated to observe the output.
The response of the system is shown in Fig. 14.17, from where the effects of gain on
the system can be realized.
Due to the increase of gain, it can be observed that the value of the early
oscillation is increased for the response shown in Fig. 14.17. Thus, the characteris-
tics of any control system can be analyzed by utilizing the Simulink model.
14.6
Stability Analysis
Stability analysis is a key part of designing any control system. The stability of a
control system can be determined by following multiple procedures such as the Pole-
Zero Map, Bode Plot, Nyquist Plot, etc. The procedures to comment on the stability
Fig. 14.15 The output in the scope window of the PID controller
Fig. 14.16 Deﬁning another variable for the gain
14.6
Stability Analysis
427

of a system—stable or unstable—based on these plots of a system are explained in
Sect. 9.6 in detail. In this section, a stable and an unstable system will be designed
utilizing Simulink to demonstrate the procedures of generating Zero-Pole plotting,
Bode plotting, and Nyquist plotting.
14.6.1
Stable System
A control system that incorporates a transfer function, G sð Þ ¼
50
s2þ12sþ1 with the Step
input, is designed and presented in Fig. 14.18. The blocks utilized to design this
model are enlisted with their navigation routes in the following Table 14.3:
The output response of the system can be observed from the Scope window, and
the stability of such systems can be determined by generating different plots such as
Pole-Zero Plot, Bode Plot, and Nyquist Plot.
The customizations of the Step and Transfer Fcn blocks are illustrated in
Fig. 14.19. The numerator of the transfer function is assigned to be [50], whereas
the denominator is provided as an array of [1 12 1], to represent the transfer function,
G sð Þ ¼
50
s2þ12sþ1.
Fig. 14.17 The output in the scope window of the PID controller for the new gain
428
14
Control System in Simulink

Pole-Zero Plot
The Pole-Zero Plot of a control system can be used to determine the stability of a
system. If all the poles of a system lie in the left-half plane of the coordinate system,
the system can be regarded as a stable system. In Simulink, the Pole-Zero Plot block
can be utilized to generate such plots. The conﬁguration of this block to produce the
Pole-Zero Plot is summarized below:
Step 1: Double-click on the Pole-Zero block which will create the appearance of a
parameter window as shown in Fig. 14.20a. Click on the “+” button as red marked
by “1,” which will create a right-side box in the parameter window (Fig. 14.20a).
Step 2: Select the input signal line as shown in Fig. 14.21a that will automatically
enlist the name of the signal on the right-side box of the parameter window of the
Pole-Zero Plot block (Fig. 14.21b). Select the name and click on the “<<” button as
red marked by “3,” to shift the signal to the left box. From the “Conﬁguration” tab of
the left-side box, select “Open-loop Input,” as shown in Fig. 14.21c.
Fig. 14.18 A stable control system with a step input
Table 14.3 Navigation routes of the blocks used in the design of Fig. 14.18
Blocks
Navigation path on the Simulink library browser
Step
Simulink!sources!step
Transfer Fcn
Simulink library browser!continuous!transfer Fcn
Scope
Simulink library browser!sinks!scope
Pole-zero plot
Simulink!control design!linear analysis plots!pole-zero plot
Bode plot
Simulink! control design!linear analysis plots!bode plot
Gain and phase margin
plot
Simulink!control design!linear analysis plots!gain and phase
margin plot
14.6
Stability Analysis
429

Step 3: Select the output signal line that is connected with the Scope, and follow
the same procedures mentioned in Step 2. From the “Conﬁguration” tab, choose the
“Open-loop Output” option this time. Make sure to check the “Show plot on block
open” option in the end. This concludes the customization of the Pole-Zero Plot,
which looked like Fig. 14.22 in its ﬁnal stage.
Bode Plot
The Bode Plot is also used to determine the stability of a system. More details on the
Bode Plot can be found in Sect. 9.6.3. To generate the Bode Plot diagram of the same
Fig. 14.19 Block parameters of the step and transfer function blocks
Fig. 14.20 Block parameters of the pole zero plot
430
14
Control System in Simulink

Fig. 14.21 Open-loop input of the control system
14.6
Stability Analysis
431

system, drag the “Bode Plot” block in the Simulink design window. The conﬁgura-
tion of the Bode Plot block is similar to the customization of the Pole-Zero Plot
block. Hence, following the previous steps mentioned in the Pole-Zero Plot section
is sufﬁcient to complete the conﬁguration of the Bode Plot. The ﬁnal customized
look of the parameter window of the Bode Plot block is presented in the following
ﬁgure:
Gain and Phase Margin Plot
Gain and Phase Margin Plot can be utilized to plot Bode Plot, Nyquist Plot, Nichols
Plot, etc. In this example, this block will be used to plot the Nyquist Plot of the
system. The Customization of the Gain and Phase Margin Plot block can be
performed in the same manner as described in the Pole-Zero Plot block customiza-
tion. One additional requirement for the customization of this block is to select the
“Plot Type” from four options—Bode, Nichols, Nyquist, and Tabular. Choose the
“Nyquist” option, and the ﬁnal look of the parameter window is illustrated in
Fig. 14.24.
Simulation
After simulating the model for 100 s, the output response of the system can be seen
by double-clicking on the Scope block. The output response of this system is shown
in Fig. 14.25, from where it can be observed that the response becomes stable after
some time.
Fig. 14.21 (continued)
432
14
Control System in Simulink

The Pole-Zero Plot of the system can be produced by double-clicking on the Pole-
Zero Plot block. A ﬁgure window will appear and click on the “Run” button from the
head tool strip of this window. It will generate the Pole-Zero Map of the system,
which is shown in Fig. 14.26. From the ﬁgure, it can be observed that all the poles lie
on the left-half plane, hence proving the stability of the system.
For generating the Bode Plot of the system, double-click on the Bode Plot block,
which will generate a ﬁgure window. From that ﬁgure window, click on the “Run”
button from the header tool strip. The Bode Plot of the system will generate, which is
demonstrated in Fig. 14.27. From the ﬁgure, it can be observed that both of the
margins are positive; therefore, the system is stable. More details regarding the
procedures to comment on the stability of a system from its Bode Plot can be
found in Sect. 9.6.3.
Finally, to produce the Nyquist Plot of the system, double-click on the Gain and
Phase Margin block, and click on the “Run” button from its ﬁgure window. It is seen
that the contour does not enclose (1,0) point, and there is no pole in the right-half
plane; therefore, the system is stable. More details on the plot are available in Sect. 9.
6.4. The Nyquist Plot of the system will appear as follows:
Fig. 14.22 Block parameters of the Bode plot
14.6
Stability Analysis
433

14.6.2
Unstable System
An example of an unstable system is demonstrated in this section utilizing Simulink.
Like the previous stable system, different plots such as Pole-Zero Map, Bode Plot,
and Nyquist Plot of the system are produced to perform stability analysis. The entire
Simulink design of the unstable system is provided in Fig. 14.29. The blocks that are
used in this design are the same as the previous model as listed in Table 14.3.
The customizations of the Step and the Transfer Fcn blocks are shown in
Fig. 14.30. The transfer function of this unstable system is set as G sð Þ ¼
sþ1
s320s210sþ1.
The Pole-Zero Plot, Bode Plot, and the Gain and Phase Margin Plot are custom-
ized in the same manner as demonstrated for the stable system. Hence, it will be
skipped for this example to reduce redundancy. After simulating the model for 10 s,
the output response of the unstable system can be observed from the Scope window,
which is shown in Fig. 14.31. From the response, it can be seen that the response is
increasing steadily, and becoming unstable.
Fig. 14.23 Customization of the Bode plot parameters
434
14
Control System in Simulink

The Pole-Zero Plot, the Bode Plot, and the Nyquist Plot of the unstable system are
illustrated in Fig. 14.32a–c, respectively, to realize the instability of the system (see
Sect. 9.6 for more details).
14.7
Conclusion
This chapter introduces the reader to the two different types of control systems—
open-loop and closed-loop control systems. Before diving into the Simulink model,
the basic structures of these two types of control systems along with their distinctions
are explained for building up the fundamental knowledge regarding the topic. Later,
the Simulink model designs of these two types are illustrated with step-by-step
guidelines to understand the characteristics via simulation. For both of these types,
separate example models are designed and simulated. The utilization of the
MATLAB command window for parameter deﬁnition of any Simulink block is
Fig. 14.24 Block parameters of the Gain and Phase Margin Plots
14.7
Conclusion
435

Fig. 14.25 The output response in the scope window
Fig. 14.26 The pole zero map of the control system
436
14
Control System in Simulink

Fig. 14.27 The Bode plot of the control system
Fig. 14.28 The Gain and Phase Margin Plot of the control system
14.7
Conclusion
437

also demonstrated in this chapter. Finally, the stability analysis of any control system
is demonstrated in this chapter with necessary illustrations. For the stability analysis,
Pole-Zero Map, Bode Plot, and Nyquist Plot are covered in this chapter. The main
objective of this chapter is to provide the reader adequate knowledge for designing
any control system model in the Simulink and understand the characteristics of
different control systems via simulation.
Fig. 14.29 An unstable control system with a step input
Fig. 14.30 Block parameters of the step and transfer function blocks
438
14
Control System in Simulink

Exercise 14
1. Deﬁne control system and write down the name of the two types of control
systems based on structure.
2. (a) List the advantages of an open-loop control system.
(b) Consider an open-loop system with a transfer function, G sð Þ ¼
sþ2
2S2þ1, and gain
¼ 3. Design the model in the Simulink and show the response in a Scope window.
(c) Simulate the previous model for the gain of K ¼ 5, K ¼ 8, and K ¼ 12. Write
down the effects of the gain increments for an open-loop system based on the
responses obtained here.
3. (a) List the advantages of a closed-loop system.
(b) Consider a closed-loop system with a transfer function, G sð Þ ¼
3sþ5
2S2þ5sþ2, and
the gain of K ¼ 2. For unity feedback and PID controller, design the model in the
Simulink and show the response.
(c) Simulate the same model by changing the value of the gain to K ¼ 6 by utilizing
the MATLAB command window. Demonstrate the response of the system.
4. (a) What are the key controller parameters of a PID controller?
(b) Design the following model (Fig. 14.33) in Simulink and show the response of
the system in the Scope window. Set the value of P and I of the PID controller as
1.
(c) Simulate the same model for a PD controller using the value of P and D as
1. Show the response of the system using Scope.
Fig. 14.31 The output response of the unstable system in the scope window
Exercise 14
439

Fig. 14.32 The pole zero map, the Bode plot, and the Nyquist diagram of the unstable system
Fig. 14.33 A PID control system with feedback gain
440
14
Control System in Simulink

(d) Evaluate the effects of the two controllers—PI and PD—on the response of
the above system.
5. (a) State some of the methods to determine the stability of a control system
(b) Consider an open-loop control system with a transfer function, G sð Þ ¼
400
s34s2þ50sþ45. Design the model with a Step input to produce the following plots:
(i) Pole-Zero Map
(ii) Nyquist Plot
(c) Comment on the stability of the system based on individual plots generated on
(b).
Exercise 14
441

Chapter 15
Electrical Circuit Analysis in Simulink
15.1
Measure Voltage, Current, and Power of a Circuit
In electrical circuit analysis, the parameters that are emphasized most are voltage,
current, and power. In this section, the simulation will be performed on both DC and
AC circuits with an aim of measuring these parameters.
15.1.1
DC Circuit Analysis
For electrical circuit design, different electrical blocks are available in the Simulink.
For
this
section,
we
are
going
to
utilize
the
blocks
from
Simscape!Electrical!Specialized Power Systems. A DC circuit where a DC
voltage source is connected with two resistances in series is modeled in the Simulink
design window in Fig. 15.1. After the simulation, the current, voltage, and power of
the circuit across one of the resistances are displayed. This is a simple circuit
conﬁguration aimed to show how to measure the voltage, current, and power of a
DC circuit. The used blocks in Fig. 15.1 are tabulated in Table 15.1, to help the
reader navigate easily to ﬁnd the exact blocks.
In the model shown in Fig. 15.1, the blocks are customized as shown in Fig. 15.2.
The amplitude of the voltage in the DC voltage source block is set at 60 V. The
Series RLC Branch block provides the users’ ﬂexibility to utilize R, L, C, or any
combinations of these three passive elements with a series connection. For this
example, the Branch type is selected as “R” from the dropdown option list for
both the “Series RLC Branch” and “Series RLC Branch1.” The values of the
resistances for these blocks are set as 10 Ω and 20 Ω, respectively. To measure the
current of the series circuit, the current measurement block is connected in series,
while the voltage measurement block is connected in parallel across the resistance—
series RLC branch 1—to measure the voltage across it. Two displays are connected
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_15
443

with the output ports of these two measurement blocks to display the results. In a DC
circuit, the power across a resistance is the product of the current through the
resistance and the voltage across it. Therefore, the product block is utilized where
the two inputs are from the output lines of the voltage measurement and the current
measurement blocks. The Product block simply multiplies the voltage and current to
determine the power which has been displayed in the Display block connected with
the output port of the product block.
Fig. 15.1 Simulink diagram of a DC electrical circuit with a voltage source and two RLC branches
Table 15.1 Blocks and navigation routes used for the DC circuit analysis in Fig. 15.1
Blocks
Navigation path on the Simulink Library Browser
DC voltage source 1
Simscape!electrical!specialized power systems!fundamental
blocks!electrical sources!DC voltage source
Series RLC branch, series
RLC branch 1
Simscape!electrical!specialized power systems!fundamental
blocks!elements!series RLC branch
Current measurement
Simscape!electrical!specialized power systems!fundamental
blocks!measurements!current measurement
Voltage measurement
Simscape!electrical!specialized power systems!fundamental
blocks!measurements!voltage measurement
Product
Simulink!math operations!product
Display, display 1, display 2
Simulink!sinks!display
Powergui
Simscape!electrical!specialized power systems!fundamental
blocks!powergui
444
15
Electrical Circuit Analysis in Simulink

15.1.2
AC Circuit Analysis
In AC circuit analysis, an AC voltage source is required. In Fig. 15.3, a simple series
AC circuit simulation is shown, where different voltages associated with the AC
voltage source are displayed. In the series circuit, an inductor and a resistor are
connected in series with an AC voltage source. The voltage across the resistance is
displayed in the “Display” block. The amplitude of the voltage in the AC voltage
source is set as 100 V and the frequency is given as 60 Hz (Fig. 15.4). For an AC
voltage source, different voltage and current terminologies are available, such as
RMS, peak, peak to peak, average, and instantaneous value. In this simulation, all of
the values of voltage are displayed. The values of the same terminologies related to
current are shown in a later simulation in Fig. 15.5. For determining the RMS value,
Fig. 15.2 Block parameters of the voltage source and the series RLC branch
Fig. 15.3 The voltage parameters of the AC circuit are shown in the display blocks
15.1
Measure Voltage, Current, and Power of a Circuit
445

the RMS block is used. The output signal line from the Voltage Measurement block
indicates the instantaneous value. The other values can be determined from the RMS
value, by applying the following formulas in Eqs. (15.1), (15.2), and (15.3) via the
Gain block:
Peak value ¼
ﬃﬃﬃ
2
p
 RMS value
ð15:1Þ
Peak to peak value ¼ 2 
ﬃﬃﬃ
2
p
 RMS value
ð15:2Þ
Fig. 15.4 Block parameters
of the AC voltage source
Fig. 15.5 The current parameters of the AC circuit are shown in the display blocks
446
15
Electrical Circuit Analysis in Simulink

Average value ¼ 2
π 
ﬃﬃﬃ
2
p
 RMS value
ð15:3Þ
In Fig. 15.3, all of these values for the voltage across the resistance are displayed
in the “Display” blocks. The same values for the current ﬂowing through the series
circuit are displayed in Fig. 15.5.
In an AC circuit, the power measurement can be done by utilizing the “Power”
block, where the inputs are voltage and current; and the outputs are real power
(P) and reactive power (R). In Fig. 15.6, a series AC RL circuit is simulated. In the
circuit, the amplitude of the AC voltage source is selected as 100 V and the
frequency is given as 60 Hz (Fig. 15.7). The resistance and the inductance of the
circuit are provided as 20 Ω and 500 mH, respectively. In this example, the power
across the resistor, the inductor, and the input source or the total power is measured.
In an AC circuit, the total power component can be subdivided into two parts—real
and reactive power. The vector summation of these two components constitutes the
apparent power. In Scope 1, the real powers across the resistor, inductor, and input
source are shown (Fig. 15.7). Similarly, in Scope 2, the reactive powers across the
resistor, inductor, and input source are demonstrated (Fig. 15.8). It is to be noted that,
in the “Power” block, the frequency of the block needs to be identical with the
frequency of the input voltage source (Fig. 15.7).
In Fig. 15.8, it can be observed that the total real power or the power of the input
source is the summation of the real power across the resistor and the inductor. The
same is also true for the reactive power scenario, which can be seen in Fig. 15.9.
Power Factor
The power factor of an AC circuit can be determined by utilizing the real power (P),
the reactive power (Q), and the apparent power (S) of the input source. The power
factor of a circuit can be calculated by using the power triangle concept as demon-
strated below:
Fig. 15.6 Simulink diagram of a series RL AC circuit
15.1
Measure Voltage, Current, and Power of a Circuit
447

In Fig. 15.10, the cosine of the angle Ɵ is called the power factor. It can also be
deﬁned as the ratio of real power to apparent power. Therefore, the power factor of
an AC circuit can be formulated as in Eq. (15.4) or (15.5):
Power Factor ¼ cos Ɵ
ð15:4Þ
Power Factor ¼ P
S ¼
P
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
P2 þ Q2
p
ð15:5Þ
In the following example, the power factor of a series RL circuit is determined
using the Simulink model by adopting two procedures, where the two above
formulas are implemented for the calculation. In Fig. 15.11, the Simulink design
model is shown, from where it can be observed that the simulated power factor
obtained from the two procedures is the same.
15.2
RLC Circuit Analysis
In any RLC circuit, three components are very necessary—resistance (R), induc-
tance (L), and capacitance (C). Hence, a circuit incorporating three of these elements
is named the RLC circuit. In the electrical engineering domain, the most common
type of circuit that is implemented in various applications is the RLC circuit.
Therefore, learning about RLC circuit simulation in Simulink is essential indeed.
Fig. 15.7 Block parameters of the AC voltage source and the power blocks
448
15
Electrical Circuit Analysis in Simulink

15.2.1
AC RLC Circuit Analysis
In Simulink, RLC circuit analysis can be performed with less complexity. In
Fig. 15.12, an RLC circuit is demonstrated with an AC input source. The voltage
and current across the resistance named as the “Series RLC Branch 1” are simulated
and displayed.
15.2.2
DC RLC Circuit Analysis
The same example is repeated with the replacement of the AC source with a DC
voltage source in Fig. 15.13. For a circuit with a DC source that has zero frequency
component, the inductor acts like a short circuit, and the capacitor behaves as an
Fig. 15.8 The scope window showing the real power parameters
15.2
RLC Circuit Analysis
449

open circuit, which can be observed from the following example as shown in
Fig. 15.13. As the capacitor creates an open circuit and the inductor becomes a
short circuit with the DC voltage source, the voltage across the resistance becomes
the voltage of the DC source. In this simulation, the voltage of the DC source and the
resistor are identical, which proves the former concept via simulation. Thus, any
kind of RLC circuit simulation can be performed utilizing Simulink.
Fig. 15.9 The scope window showing the reactive power parameters
Fig. 15.10 The power
triangle
450
15
Electrical Circuit Analysis in Simulink

15.3
Conclusion
This chapter presents the analysis of electrical circuits for both AC and DC with
separate examples implemented in the Simulink. In Simulink, the parameters of an
electrical circuit can be determined avoiding any complex calculations. The user just
needs to utilize different Simulink blocks available in the Simulink Library Browser
to create the exact circuit. After running the simulation, the values of different
parameters as well as graphical illustrations of input and output signals can also be
observed by utilizing Simulink. Before creating any actual hardware testbed,
Simulink can be used as a simulation platform to verify the performance of the
Fig. 15.11 Simulink diagram of a series RL AC circuit
Fig. 15.12 Simulink diagram of a series RLC AC circuit
15.3
Conclusion
451

testbed. The reader can also verify the circuit theories by performing simulations in
the Simulink for different circuit analyses. Thus, this chapter can signiﬁcantly help
the readers to understand and analyze the electrical circuit with more depth.
Exercise 15
1. Mention some of the parameters of the electrical circuit.
2. (a) Write some of the differences between DC and AC circuits.
(b) Consider a series RLC circuit with resistance, R ¼ 10 Ω; inductance, L ¼ 0.5
H; and capacitance, C ¼ 0.4 μF, with an AC voltage source. The amplitude of the
AC voltage source, V ¼ 120 V; and the frequency ¼ 60 Hz. Determine the
following parameters:
(i) RMS voltage across the resistance
(ii) Peak-to-peak voltage across the resistance
(iii) Average voltage across the resistance
3. (a) What is an RLC circuit?
(b) Recreate the following Simulink model by using the same parameters:
(c) Demonstrate the real and reactive power across the resistance of Fig. 15.14
using a Scope block.
Fig. 15.13 Simulink diagram of a series RLC DC circuit
452
15
Electrical Circuit Analysis in Simulink

4. (a) What is the power factor?
(b) Design a Simulink model for the following circuit, and measure the RMS
current (I1) through the inductor, L.
(c) Simulate the model of Fig. 15.15 to determine the power factor of the source.
Fig. 15.14 Simulink diagram of a series RLC AC circuit for Question 3b
Fig. 15.15 An RLC AC circuit for Question 4b
Exercise 15
453

Chapter 16
Application of Simulink in Power Systems
16.1
Modeling Single-Phase Power Source in Simulink
In the ﬁeld of the power system, Simulink is widely used due to its rich collection of
different power system blocks. The importance of Simulink in the power system is
quite undeniable, as it provides an advanced simulation platform along with versatile
facilities. A power source can be categorized into two types—DC power and AC
power. For DC sources, the power is unidirectional, while an AC source produces
power that changes its direction constantly. In our current age, AC sources are
considered as a standard power source due to their efﬁciency to transfer power
over long distances without signiﬁcant losses.
A single-phase AC power system incorporates one single AC source with two
wires. One wire is termed power wire, while the other one is called neutral wire.
Electricity ﬂows from the power wire to the neutral wire. Almost all of our house-
hold appliances work by using a single-phase AC power source. A Simulink model
showing a simple single-phase AC source is shown in Fig. 16.1. The navigation
routes of all the utilized blocks of this example are listed in Table 16.1.
The AC Voltage Source block is customized by setting the amplitude of voltage
as 120 V and the frequency as 60 Hz (Fig. 16.2). In the USA, the standard frequency
for a single-phase AC source is 60 Hz. In some other countries, the standard may
become 50 Hz. For this example, 60 Hz frequency is considered.
A Voltage Measurement block is used to observe the voltage output of the source
via the Scope window. The output voltage can be seen in Fig. 16.3, which appears
after double-clicking the Scope block.
A dual, or split phase, power source is also considered a single-phase power
source in some aspects. In such scenarios, two phases may available with one neutral
wire. An example is given below (Fig. 16.4), where Phase-A or Phase-B wire with
the neutral wire provides 120 V supply individually. However, taking voltage across
the Phase-A and Phase-B wires without the neutral wire can be used as a voltage
source of 240 V. This type of arrangement can be utilized for multi-functioning
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_16
455

purposes. For example, low-power loads can be operated using the 120 V arrange-
ments, and for high-power loads, 240 V arrangement can be more feasible.
16.2
Modeling Three-Phase AC Power Source in Simulink
In a three-phase AC power source, three individual AC sources are connected either
in delta or wye/star conﬁguration. A concise analysis of the characteristics of the
three-phase AC source based on delta and wye conﬁguration including the two
sequences is demonstrated in Sect. 8.3.4. Hence, the theoretical concept of this
section will be skipped to avoid redundancy. In this section, the aim is to model a
three-phase AC power source for both delta and wye conﬁguration by utilizing
Simulink and observe the characteristics via simulation graphs. Based on different
conﬁgurations, the three-phase AC power source can be of ﬁve types in general,
such as:
Fig. 16.1 A simple single-phase AC voltage source
Table 16.1 Blocks and navigation routes for modeling a single-phase AC power source
Blocks
Navigation path on the Simulink Library Browser
AC Voltage
Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources ! AC Voltage Source
Voltage
Measurement
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Measurements ! Voltage Measurement
Scope
Simulink ! Sinks ! Scope
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! powergui
456
16
Application of Simulink in Power Systems

Fig. 16.2 Block parameters of the AC voltage source
Fig. 16.3 The output of the AC voltage source in the scope window
16.2
Modeling Three-Phase AC Power Source in Simulink
457

1. Delta-connected three-phase AC source.
2. Wye-connected three-wire three-phase AC source.
3. Wye-connected four-wire three-phase AC source.
16.2.1
Three-Phase Wye-Connected AC Power Source
In a three-phase wye-connected AC power source, three individual AC power
sources are connected in a wye conﬁguration. The voltages and currents of the
three sources are 120 apart from each other in phase difference. The sequences of
the phase differences among the three phases create the categorization of two
sequences—“abc” sequence and “acb” sequence—that are described earlier in
Sect. 8.3.4. In Fig. 16.5, two examples are provided where a three-phase AC source
model in wye conﬁguration is designed and simulated. The blocks utilized in this
example are enlisted in Table 16.2.
In Fig. 16.5, two examples are separated by using two Area windows. In the ﬁrst
example, three AC voltage sources are connected in a wye conﬁguration, and the
neutral point is grounded. The voltages of the three phases can be observed in the
Scope window. This example provides a balanced three-phase AC source; hence, the
amplitudes and the frequencies of the three voltage sources are kept similar which
are 150 V and 60 Hz, respectively. The customization of the parameter windows of
the AC Voltage Sources is shown in Fig. 16.6. The phase degree of the AC Voltage
Source, AC Voltage Source1, and AC Voltage Source2 blocks are set as
0
,  120
, and + 120
, respectively, by maintaining “acb” sequence.
In example two, the same conﬁguration is designed using different blocks. In
Simulink, a Three-Phase Voltage Source block is available, through which wye
conﬁguration can be made easily without using three separate voltage sources. In the
Fig. 16.4 A dual or split
phase power source
458
16
Application of Simulink in Power Systems

parameter window of the Three-Phase Voltage Source block, three types of conﬁg-
urations are available—Y, Yg, and Yn (Fig. 16.7). Here, the Y conﬁguration
indicates that the neutral point is in the ﬂoating mode and cannot be accessed. Yg
conﬁguration refers that the neutral point is grounded, and for Yn conﬁguration, the
neutral point can be accessed externally. In this example, the Yg conﬁguration is
chosen to match the conﬁguration of the ﬁrst example. The line-to-neutral voltages
(RMS value) of the three phases are set as 150=
ﬃﬃﬃ
2
p
. It is to be noted that, in the ﬁrst
example, the peak amplitude of the voltages is set as 150 V. To make the results
identical, the RMS voltages of the sources in the second example are assigned as
Fig. 16.5 Simulink diagram of a three-phase AC voltage source
Table 16.2 Blocks and navigation routes for modeling a three-phase wye-connected AC power
source
Blocks
Navigation path on the Simulink Library Browser
AC Voltage Source
AC Voltage Source1
AC Voltage Source2
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources ! AC Voltage Source
Voltage Measurement
Voltage Measurement1
Voltage Measurement2
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Measurements ! Voltage Measurement
Three-Phase Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources ! Three-Phase Source
Three-Phase V-I
Measurement
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Measurements ! Three-Phase V-I Measurement
Scope, Scope1
Simulink ! Sinks ! Scope
Ground
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Elements ! Ground
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! powergui
16.2
Modeling Three-Phase AC Power Source in Simulink
459

Fig. 16.6 Block parameters of the three AC voltage sources
Fig. 16.7 Block parameters of the three-phase AC voltage source
460
16
Application of Simulink in Power Systems

1=
ﬃﬃﬃ
2
p
times of the peak amplitudes of the ﬁrst example. The Phase angles are set as
0
,  120
, + 120
, for ensuring “acb” sequence as before.
A Three-Phase V-I Measurements block is connected to the Three-Phase Voltage
Source. The Three-Phase V-I Measurements block has three inputs, which are
connected with the three phases of the Three-Phase Voltage Source block. The
output ports of the Three-Phase V-I Measurements blocks are Vabc, Iabc, and the
output terminals for the three phases. This block can be utilized to measure the
voltages and currents both in per unit values and in volts and amperes. The parameter
window of the Three-Phase V-I Measurements block is shown in Fig. 16.8, from
where measurement options for both voltages and currents can be conﬁgured. For
this example, the phase-to-ground option is chosen for voltage measurement and the
per unit value option is kept unchecked. The current measurement option is selected
as “no,” as in this example, the currents of the phases are not measured. However,
the user has the preference to select the current measurement option.
The voltages of the three phases for both of the examples can be observed from
the Scope windows as shown in Fig. 16.9.
16.2.2
Three-Phase Delta-Connected AC Power Source
A three-phase delta-connected AC power source is designed in the Simulink, which
is shown in Fig. 16.10. In the ﬁgure, three AC Voltage Source blocks with three
Series RLC Branches are connected in such a way to form a delta connection. The
utilized blocks for this example are listed in Table 16.3 with their navigation routes.
The customization of the AC Voltage Source blocks is similar to the customiza-
tion of the previous wye-connected AC Voltage Source blocks. The peak amplitude
Fig. 16.8 Block parameters of the three-phase V-I measurement
16.2
Modeling Three-Phase AC Power Source in Simulink
461

and the frequency are set as 150 V and 60 Hz, respectively. The phase angles of the
three sources are set as 0
,  120
, and + 120
. In Fig. 16.11, the parameter window
of one of the AC Voltage Source blocks is shown in the ﬁrst ﬁgure. In the second
ﬁgure, the parameter window of the Series RLC Branch is shown, where the block is
customized for RL branch by setting the resistance value 5000 ohms and the
inductance value 100 mH. The other two Series RLC Branch blocks are customized
in the same manner.
The voltages of the three phases can be observed from the Scope windows, which
are shown in Fig. 16.12.
Fig. 16.9 The voltage output of the three AC voltage sources and the three-phase AC voltage
source
Fig. 16.10 A three-phase delta-connected AC power source
462
16
Application of Simulink in Power Systems

Table 16.3 Blocks and navigation routes for modeling a three-phase delta connected AC power
source
Blocks
Navigation path on the Simulink Library Browser
AC Voltage
Source
AC Voltage
Source1
AC Voltage
Source2
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources ! AC Voltage Source
Voltage Measure-
ment
Voltage Measure-
ment1
Voltage
Measurement2
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Measurements ! Voltage Measurement
Series RLC
Branch
Series RLC
Branch1
Series RLC
Branch2
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Elements ! Series RLC Branch
Scope
Simulink ! Sinks ! Scope
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! powergui
Fig. 16.11 Block parameters of the AC voltage source and the series RLC branch
16.2
Modeling Three-Phase AC Power Source in Simulink
463

16.3
Model of Three-Phase Series RLC Load
with Three-Phase AC Power Source
Similar to the Three-Phase Source, a Three-Phase Series RLC Load block is also
available in the Simulink. In this section, a Three-Phase Series RLC Load is
connected with a three-phase AC source to observe the instantaneous power and
current of the circuit. In Fig. 16.13, a model where a Three-Phase Source is
connected to a Three-Phase Series RLC Load through a Three-Phase V-I Measure-
ment block is shown.
The navigation routes of the blocks that are used in this example are given in
Table 16.4.
To measure the real and reactive power of the system, the voltage and current
terminals from the Three-Phase V-I Measurement block are inserted into the input of
the Power (3 ph, Instantaneous) block. The outputs of this block are inserted into the
input terminals of the Scope block. The Vabc and the Iabc signal lines are connected to
the Scope1 block to observe the voltages and currents of the phases. The parameter
windows of the Three-Phase Source and the Three-Phase Series RLC Load blocks
Fig. 16.12 The voltages of the three phases observed from the scope window
464
16
Application of Simulink in Power Systems

are shown in Fig. 16.14. It can be noted that both the source and the load are
customized to act in Yg conﬁguration mode. The graphs of the real and reactive
power can be observed from the Scope window, as shown in Fig. 16.15. On the other
hand, the voltages and the currents of the system can be seen from the Scope1
window, which is illustrated in Fig. 16.16.
Fig. 16.13 Simulink diagram of a Three-Phase Series RLC Load with Three-Phase AC Power
Source
Table 16.4 Blocks and navigation routes for modeling a Three-Phase Series RLC Load with three-
phase AC power source
Blocks
Navigation path on the Simulink Library Browser
Three-Phase Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources ! Three-Phase Source
Three-Phase V-I
Measurement
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Measurements ! Three-Phase V-I Measurement
Power (3 ph,
Instantaneous)
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Power Electronics ! Pulse and signal generators/
Measurements
Three-Phase Series
RLC Load
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Elements ! Three-Phase Series RLC Load
Scope, Scope1
Simulink ! Sinks ! Scope
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! powergui
16.3
Model of Three-Phase Series RLC Load with Three-Phase AC Power Source
465

Fig. 16.14 Block parameters of the three-phase source and the three-phase series RLC load
Fig. 16.15 The graphs of the real and reactive power from the scope window
466
16
Application of Simulink in Power Systems

16.4
Model of Three-Phase Parallel RLC Load
with Three-Phase AC Power Source
A Simulink model incorporating a three-phase parallel RLC load with a three-phase
AC power source is demonstrated in Fig. 16.17. The model is almost similar to the
previous model shown in Fig. 16.13. The only difference is that the Three-Phase
Series RLC Load block is replaced by a Three-Phase Parallel RLC Load block. The
navigation route of this block is Simulink Library Browser ! Simscape ! Electri-
cal ! Specialized Power Systems ! Fundamental Blocks ! Elements ! Three-
Phase Parallel RLC Load. The parameter windows of the Three-Phase Source and
the Three-Phase Parallel RLC Load blocks are shown in Fig. 16.18. The real and the
reactive power of the system are shown in Fig. 16.19, while the voltages and currents
waveforms of the system are illustrated in Fig. 16.20.
Fig. 16.16 The voltages and the currents of the system observed from the scope window
16.4
Model of Three-Phase Parallel RLC Load with Three-Phase AC Power Source
467

16.5
Power Factor Calculation Simulink Model
In the power system, power factor calculation is an important part to analyze
different characteristics of a system. In Simulink, a model can be designed to
calculate the power factor. An example is given in Fig. 16.21, where the power
factor of a system is calculated. The system incorporates a Three-Phase Source with
a Three-Phase Parallel RLC Load. To calculate the power factor of the system, the
Fig. 16.17 Simulink diagram of a Three-Phase Parallel RLC Load with Three-Phase AC Power
Source
Fig. 16.18 Block parameters of Three-Phase Source and the Three-Phase Parallel RLC Load
468
16
Application of Simulink in Power Systems

real (P) and reactive (Q) power of the system are determined by using the Power
(3 ph, Instantaneous) block. Later the following formula is utilized to design the rest
of the part to calculate the power factor:
Power factor ¼
Real power
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
Real power2 þ Reactive power2
p
¼
P
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
P2 þ Q2
p
ð16:1Þ
The used blocks for this model can be found from the mentioned navigation
routes described in Table 16.5.
Fig. 16.19 The real and the reactive power graphs observed from the scope window
16.5
Power Factor Calculation Simulink Model
469

16.6
Modeling Different Power System Conﬁgurations
In the previous sections, wye- and delta-connected three-phase power sources are
shown. Similar to the three-phase power source, the load can also be connected in
wye and delta forms. Based on the conﬁgurations of both three-phase power source
and three-phase load, the power system conﬁguration can be categorized in four
forms, such as:
1. Y-Y power system conﬁguration.
2. Y-Δ power system conﬁguration.
3. Δ-Δ power system Conﬁguration.
4. Δ-Y power system conﬁguration.
Each of these conﬁgurations can be balanced or unbalanced based on their
characteristics. In this section, a Y-Y and a Δ  Δ conﬁguration of the power
system will be demonstrated with the Simulink models for both balanced and
unbalanced systems.
Fig. 16.20 The voltages and currents waveforms observed from the scope window
470
16
Application of Simulink in Power Systems

16.6.1
Balanced Y-Y Power System Conﬁguration
A balanced Y-Y power system conﬁguration, where the ﬁrst term “Y” indicates the
conﬁguration of the Three-Phase Source, and the second term “Y” refers to the
conﬁguration of the three-phase load, is demonstrated in Fig. 16.22. In a balanced
system, the amplitudes of the voltages in the Three-Phase Source are similar.
Additionally, the impedances of each phase of a three-phase load are identical.
The Simulink blocks used in the example shown in Fig. 16.22 are listed in
Table 16.6 with their navigation routes.
Fig. 16.21 Simulink diagram of a Three-Phase Source with a Three-Phase Parallel RLC Load
Table 16.5 Blocks and navigation routes for modeling the calculation of power factor
Blocks
Navigation path on the Simulink Library Browser
Three-Phase Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources ! Three-Phase Source
Three-Phase V-I
Measurement
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Measurements ! Three-Phase V-I Measurement
Power (3 ph,
Instantaneous)
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Power Electronics ! Pulse & Signal Generators/
Measurements
Three-Phase Parallel
RLC Load
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Elements ! Three-Phase Parallel RLC Load
Product, Product1
Simulink ! Math Operations ! Product
Add
Simulink ! Math Operations ! Add
Square Root
Simulink ! Quick Insert ! Math Operations ! Square Root
Divide
Simulink ! Math Operations ! Divide
Display
Simulink ! Sinks ! Display
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! powergui
16.6
Modeling Different Power System Conﬁgurations
471

The customized parameter windows of the Three-Phase Source and the Three-
Phase Series RLC Load blocks are shown in Figs. 16.23 and 16.24, respectively. To
make the system balanced, the magnitudes of the voltages of each phase are made
identical. Moreover, the nominal phase-to-neutral voltages and PQ speciﬁcations of
the three-phase loads are also set to be exactly similar. In Fig. 16.25, the conﬁgured
parameter windows of the Three-Phase V-I Measurement and the RMS Measure-
ment blocks are demonstrated. For a Y-Y conﬁgured balanced power system, the
following characteristics should be observed:
Balanced Y-Y power system conﬁguration
Consider the three phases as A, B, and C.
Line-to-line voltages: VAB, VBC, and VCA
Phase-to-ground voltages: Van, Vbn, and Vcn
For balanced Y-Y conﬁguration:
j VAB j¼j VBC j¼j VCA j
j Van j¼j Vbn j¼j Vcn j
j VAB j¼j VBC j¼j VCA j¼
ﬃﬃﬃ
3
p
 j Van j¼
ﬃﬃﬃ
3
p
 j Vbn j¼
ﬃﬃﬃ
3
p
 j Vcn j
Line currents: IA, IB, and IC
Phase currents: Ian, Ibn, and Icn
j IA j¼j IB j¼j IC j
j Ian j¼j Ibn j¼j Icn j
j IA j¼j IB j¼j IC j¼j Ian j¼j Ibn j¼j Icn j
Fig. 16.22 Simulink diagram of a Y-Y conﬁguration balanced system
472
16
Application of Simulink in Power Systems

To verify whether the above-mentioned characteristics are identical with the simu-
lation results, Table 16.7 is shown to correlate the above-mentioned parameters with
the simulation results.
The simulated results verify the characteristics that are deﬁned earlier and can be
observed from Fig. 16.22.
The Scope and Scope1 windows demonstrate the phase-to-ground voltages and
the phase currents of the system as shown in Fig. 16.26. The line-to-line voltages and
the line currents can also be observed similarly by utilizing two other Scopes.
16.6.2
Unbalanced Y-Y Power System Conﬁguration
For an unbalanced Y-Y power system conﬁguration, the impedances of the three-
phase load change. If the magnitudes of the Three-Phase Source vary, the system can
also become unbalanced. For the same Simulink model shown in Fig. 16.22, the
system is made unbalanced by changing the nominal phase-to-neutral voltage of the
three-phase load and the magnitudes of the Three-Phase Source from the parameter
windows of the blocks. The ﬁnal Simulink model of the unbalanced Y-Y conﬁgured
Table 16.6 Blocks and navigation routes for modeling a balanced Y-Y power system
Blocks
Navigation path on the Simulink Library Browser
Three-Phase Source
Simscape ! Electrical ! Specialized Power Systems ! Fun-
damental Blocks ! Electrical Sources ! Three-Phase Source
Three-Phase V-I Measurement
Simscape ! Electrical ! Specialized Power Systems ! Fun-
damental Blocks ! Measurements ! Three-Phase V-I
Measurement
Three-Phase Series RLC Load
Simscape ! Electrical ! Specialized Power Systems ! Fun-
damental Blocks ! Elements ! Three-Phase Series RLC
Load
Voltage Measurement, Voltage
Measurement1,
Voltage Measurement2
Simulink ! Sinks ! Voltage Measurement
Current Measurement, Current
Measurement1, Current
Measurement2
Simulink ! Sinks ! Current Measurement
RMS Measurement,
RMS Measurement1,
RMS Measurement2,
RMS Measurement3
Simscape ! Electrical ! Control ! Measurements ! RMS
Measurement1
Scope, Scope1
Simulink ! Sinks ! Scope
Mux, Mux1
Simulink ! Signal Routing ! Mux
Display, Display1, Display2,
Display3
Simulink ! Sinks ! Display
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fun-
damental Blocks ! powergui
16.6
Modeling Different Power System Conﬁgurations
473

system is shown in Fig. 16.27. The customized parameter window of the Three-
Phase Source block is shown in Fig. 16.28, where the magnitudes of the three phases
are made unequal. In Fig. 16.29, the parameter window of the Three-Phase Series
RLC Load is shown, where the nominal phase-to-neutral voltages and the PQ
speciﬁcations are also made unequal.
For a Y-Y conﬁgured unbalanced power system, the following characteristics
should be observed:
Unbalanced Y-Y power system conﬁguration
Consider the three phases as A, B, and C.
Line-to-line voltages: VAB, VBC, and VCA
Phase-to-ground voltages: Van, Vbn, and Vcn
For unbalanced Y-Y conﬁguration:
(continued)
Fig. 16.23 Block parameters of the three-phase source
474
16
Application of Simulink in Power Systems

j VAB j6¼j VBC j6¼j VCA j
j Van j6¼j Vbn j6¼j Vcn j
j VAB 6¼
ﬃﬃﬃ
3
p
jVan

; j VBC 6¼
ﬃﬃﬃ
3
p
jVbn

; VCA
j
j 6¼
ﬃﬃﬃ
3
p
 j Vcn j
VAB ¼ Van  Vbn; VBC ¼ Vbn  Vcn; VCA ¼ Vcn  Van
Line currents: IAB, IBC, and ICA
Phase currents: Ian, Ibn, and Icn
j IAB j6¼j IBC j6¼j ICA j
j IAB j¼j Ian ; jIBCj ¼ jIbn
j
j; j ICA j¼j Icn j
Fig. 16.24 Block parameters of the three-phase series RLC load
16.6
Modeling Different Power System Conﬁgurations
475

Table 16.7 Correlation between the Simulink model and the reference parameters of the balanced
Y-Y system
Simulink model
Reference
Vabc (Three-Phase V-I Measurement Block)
Phase-to-Ground Voltages: Van, Vbn, Vcn
Display
jVan j , j Vbn j , j Vcn| (RMS values)
Display1
jVAB|, | VBC|, j VCAj (RMS values)
Iabc (Three-Phase V-I Measurement Block)
Phase currents: Ian, Ibn, Icn
Display2
jIan|, | Ibn|, |Icn| (RMS values)
Display3
jIA|, | IB|, |IC| (RMS values)
Fig. 16.26 The phase to ground voltages and the phase currents of the system observed from the
scope window
Fig. 16.25 Block parameters of the three-phase V-I measurement and RMS measurement
476
16
Application of Simulink in Power Systems

For verifying the above-mentioned characteristics, Table 16.8 can be utilized to
make the connection with the Simulink model:
The phase-to-ground voltages and the phase currents of the load can be shown
from the Scope windows as shown in Fig. 16.30. From the ﬁgure, it is observable
that the amplitudes of the three phases vary both for voltages and currents.
16.6.3
Balanced Δ 2 Δ Power System Conﬁguration
For a balanced Δ  Δ three-phase power system, both the source and the load are
conﬁgured in the delta conﬁguration. A delta conﬁgured Three-Phase Source is
already demonstrated previously in Sect. 16.2.2. Here, in this example, an additional
delta-connected three-phase load is connected to make the system. The ﬁnal
Simulink model is illustrated in Fig. 16.31. The blocks that are used to create the
model are summarized along with their navigation routes in Table 16.9.
The parameter windows of the AC Voltage Source and the Series RLC Branch are
shown in Fig. 16.32 to provide a sample. The Series RLC Branch block is used to
represent the internal impedance of the AC Voltage Source. The other two AC
Voltage Source blocks and the Series RLC Branch blocks are customized in the
same manner as well to make the system balanced.
For a balanced Δ  Δ conﬁgured power system, the characteristics can be
demonstrated as follows:
Balanced Δ 2 Δ power system conﬁguration
Consider the three phases as A, B, and C.
(continued)
Fig. 16.27 Simulink diagram of a Y-Y conﬁguration unbalanced system
16.6
Modeling Different Power System Conﬁgurations
477

Line-to-line voltages: VAB, VBC, VCA
Phase-to-phase voltages: Vab, Vbc, and Vca
For balanced Δ 2 Δ conﬁguration:
j VAB j¼j VBC j¼j VCA j
j Vab j¼j Vbc j¼j Vca j
j VAB j¼j VBC j¼j VCA j¼j Vab j¼j Vbc j¼j Vca j
Line currents: IA, IB, and IC
Phase-to-phase currents: Iab, Ibc, and Ica
j IA j¼j IB j¼j IC j
j Iab j¼j Iba j¼j Ica j
j IA j¼j IB j¼j IC j¼
ﬃﬃﬃ
3
p
 j Iab j¼
ﬃﬃﬃ
3
p
 j Ibc j¼
ﬃﬃﬃ
3
p
 j Ica j
Fig. 16.28 Block parameters of the three-phase source
478
16
Application of Simulink in Power Systems

In Fig. 16.30, the same characteristics can be observable from the simulation values.
To relate the above-mentioned characteristics to the obtained simulation results,
Table 16.10 is created:
From the reference of the above table and the simulation results obtained from
Fig. 16.31, it can be observed that the phase voltages and the line-to-line voltages are
identical. However, the line current is
ﬃﬃﬃ
3
p
times to the phase-to-phase currents per
phase. Thus, the characteristics of a balanced Δ-Δ power system conﬁguration can
be justiﬁed via the Simulink model.
The waveforms of phase-to-phase voltages and phase-to-phase currents of the
three-phase load can be seen from the Scope windows as shown in Fig. 16.33.
16.6.4
Unbalanced Δ 2 Δ Power System Conﬁguration
In an unbalanced Δ-Δ power system conﬁguration, either the magnitudes of the
three-phase AC source vary, or the impedances of the three-phase load differ from
phase to phase. In Fig. 16.34, an unbalanced Δ-Δ power system is modeled. This
model is the same as the previous model showed in Fig. 16.31. The only difference is
the customization of the Three-Phase AC Source blocks and the Series RLC Load
blocks to make the system unbalanced. The amplitudes of Three-Phase AC Source
blocks are selected as 200 V, 150 V, and 100 V to make the system unbalanced
(Fig. 16.35). In addition, the Series RLC Load blocks in the three phases are
Fig. 16.29 Block parameters of the three-phase series RLC load
16.6
Modeling Different Power System Conﬁgurations
479

Table 16.8 Blocks and navi-
gation routes for modeling an
unbalanced Y-Y power
system
Simulink model
Reference
Display
jVan j , j Vbn j , j Vcn| (RMS values)
Display1
jVAB|, | VBC|, j VCAj (RMS values)
Display2
jIan|, | Ibn|, j Icnj (RMS values)
Display3
jIAB|, | IBC|, j ICAj (RMS values)
Scope
Van, Vbn, Vcn
Scope1
Ian, Ibn, Icn
Fig. 16.30 The phase to ground voltages and the phase currents of the load observed from the
scope window
Fig. 16.31 Simulink diagram of a Delta-Delta conﬁguration balanced system
480
16
Application of Simulink in Power Systems

customized as shown in Fig. 16.36. The nominal phase-to-neutral voltages of each
Series RLC Load block are made unequal to ensure that the system is unbalanced.
For an unbalanced Δ  Δ conﬁgured power system, the characteristics can be
demonstrated as follows:
Unbalanced Δ 2 Δ power system conﬁguration
Consider the three phases as A, B, and C.
Line-to-line voltages: VAB, VBC, and VCA
Phase-to-ground voltages: Van, Vbn, and Vcn
For balanced Δ 2 Δ conﬁguration:
j VAB j6¼j VBC j6¼j VCA j
j Vab j6¼j Vbc j6¼j Vca j
j VAB ¼ jVab
j
j; VBC
j
j ¼j Vbc j ; j VCA j¼j Vca j
Line currents: IA, IB, and IC
Phase-to-phase currents: Iab, Ibc, and Ica
(continued)
Table 16.9 Blocks and navigation routes for modeling a balanced Δ  Δ power system
Blocks
Navigation path on the Simulink Library Browser
AC Voltage Source, AC Volt-
age Source1, AC Voltage
Source2
Simscape ! Electrical ! Specialized Power Systems ! Fun-
damental Blocks ! Electrical Sources ! AC Voltage Source
Series RLC Branch
Series RLC Branch1
Series RLC Branch2
Simscape ! Electrical ! Specialized Power Systems ! Fun-
damental Blocks ! Elements ! Series RLC Branch
Voltage Measurement
Voltage Measurement1
Voltage Measurement2
Simulink ! Sinks ! Voltage Measurement
Current Measurement
Current Measurement1
Current Measurement2
Simulink ! Sinks ! Current Measurement
RMS Measurement1
RMS Measurement2
RMS Measurement3
Simscape ! Electrical ! Control ! Measurements ! RMS
Measurement
Scope, Scope1
Simulink ! Sinks ! Scope
Mux, Mux1
Simulink ! Signal Routing ! Mux
Display, Display1, Display2
Simulink ! Sinks ! Display
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fun-
damental Blocks ! powergui
16.6
Modeling Different Power System Conﬁgurations
481

j IA j6¼j IB j6¼j IC j
j Iab j6¼j Ibc j6¼j Ica j
j IA j6¼
ﬃﬃﬃ
3
p
 j Iab j ; j IB j6¼
ﬃﬃﬃ
3
p
 j Ibc j ; j IC j6¼
ﬃﬃﬃ
3
p
 j Ica j
IA ¼ Iab  Ibc; IB ¼ Ibc  Ica; IC ¼ Ica  Iab
Table 16.11 helps to relate the characteristics with the simulation results:
From the Scope windows in Fig. 16.37, the phase-to-phase voltages, lines
currents, and phase-to-phase currents can be observed as shown in the following
ﬁgure respectively:
16.7
Electrical Machine
In the power system, the concept of the electrical machine is very essential. An
electrical machine can act either as a generator or a motor. In general, the electrical
machine can be of two types based on its sources, such as DC Machine and AC
Machine. The AC Machine can be further categorized into two types—Asynchro-
nous Machine and Synchronous Machine. In this section, only DC Machine and
Asynchronous Machine will be covered by using the Simulink platform to provide
the readers a general idea of the applications of the power system in terms of
electrical machines.
Fig. 16.32 Block parameters of the AC voltage source and the series RLC branch
482
16
Application of Simulink in Power Systems

Table 16.10 Correlation between the Simulink model and the reference parameters of the balanced
Δ  Δ system
Simulink model
Reference
Display
jVAB j , j VBC j , j VCA| (RMS values)
Display1
jIA|, | IB|, j ICj (RMS values)
Display2
jIab|, | Ibc|, j Icaj (RMS values)
Scope
Phase-to-phase voltages or line-to-line voltages
Scope1
Line currents (IA, IB, IC)
Scope2
Phase-to-phase currents (Iab, Ibc, Ica)
Fig. 16.33 The waveforms of phase-to-phase voltages and phase to phase currents of the three-
phase load observed from the scope window
16.7
Electrical Machine
483

16.7.1
DC Machine
In Simulink, a DC Machine block can be utilized both as a generator and a motor. In
a DC Machine, two DC voltage sources are required. One DC source is used as a
ﬁeld voltage source and the other acts as an armature voltage source. A Simulink
model where the DC Machine block is utilized to act as a motor is illustrated in
Fig. 16.38. As a ﬁeld voltage source, DC Voltage Source1 block is used, the
amplitude of which is set as 96 V. For armature voltage source, DC Voltage Source
block is utilized set as 480 V. In input port Torque Load (TL) of the DC Machine, a
step response is provided via a Step block. The step value is set as +1, which
demonstrates that the DC Machine will act as a motor. For a given step input of
1, the DC Machine can be used in the generator mode as well. The mechanical
outputs of the motor are displayed both in the Display and the Scope blocks. The
required blocks to design the Simulink model shown in Fig. 16.38 are summarized in
Table 16.12 with their navigation routes:
The parameter window of the DC Machine is shown in Fig. 16.39. In the
Parameter window, the user has the preference to select any Preset model from the
dropdown option list. Simulink also provides options to the advanced user to create
their own model by specifying the parameters which are shown in the second ﬁgure
of Fig. 16.39. For getting access to the “Parameters” window, the Preset model
should be set as “No.” For this particular example, the ﬁrst Preset model is chosen.
All the other parameters are kept in their default mode for this simulation.
The outputs of the DC Machine are the armature current, ﬁeld current, power, and
electrical torque, which are displayed in the Display block. In the Scope window, the
output signals can be observed graphically as shown in Fig. 16.40.
Fig. 16.34 Simulink diagram of a Delta-Delta conﬁguration unbalanced system
484
16
Application of Simulink in Power Systems

16.7.2
Asynchronous Machine
In an Asynchronous Machine, the AC voltage source is given as a supply. A
Simulink model where an Asynchronous Machine is run with the usage of a three-
phase wye-connected AC voltage source is shown in Fig. 16.41. For designing the
model, the blocks that are used are listed in Table 16.13 with their navigation routes:
In Fig. 16.41, an Asynchronous Machine block is utilized, where the input source
is provided by a three-phase wye-connected AC source. The block that is utilized to
provide the AC input source is the Three-Phase Source block, which is customized
as shown in Fig. 16.42. The RMS voltages for the three phases are set as 480 V.
The Asynchronous Machine block can be customized from its parameter window
as shown in Fig. 16.43. The Rotor type of the machine can be selected from three
options, such as Squirrel-cage rotor, Wound rotor, or Double squirrel cage rotor. For
this example, the Squirrel-cage rotor type is selected. Like DC Machine, a preset
model can be selected for the Asynchronous Machine as well. In this example, a
preset model of 5 HP, 575 V, 60 Hz, 1750 RPM is selected. If the preset model is
selected as “No,” the model can be designed manually by the user from the
Parameters option. The rest of the parameters are set in their default values.
The outputs of the Asynchronous Machine are shown in two Scope windows for
better visibility. In the ﬁrst Scope window, the rotor speed and the electromagnetic
torque can be observed as shown in Fig. 16.44. The stator and rotor currents can be
seen in the Scope1 window as demonstrated in Fig. 16.45.
Fig. 16.35 Block parameters of the three AC voltage sources
Fig. 16.36 Block parameters of the three series RLC loads
16.7
Electrical Machine
485

Table 16.11 Correlation between the Simulink model and the reference parameters of the unbal-
anced Δ  Δ system
Simulink model
Reference
Display
jVAB j , j VBC j , j VCA| (RMS values)
Display1
jIA|, | IB|, j ICj (RMS values)
Display2
jIab|, | Ibc|, j Icaj (RMS values)
Scope
Phase-to-phase voltages or line-to-line voltages
Scope1
Line currents (IA, IB, IC)
Scope2
Phase-to-phase currents (Iab, Ibc, Ica)
Fig. 16.37 The phase-to-phase voltages, lines currents, and phase-to-phase currents observed from
the scope window
486
16
Application of Simulink in Power Systems

16.8
Conclusion
In this chapter, different types of power sources are modeled using the Simulink
platform considering both single-phase and three-phase power sources. Later the
chapter focuses mainly on the three-phase AC source due to its wide applicability in
the real world. The usage of such three-phase power sources with different series or
parallel RLC loads is demonstrated using the Simulink model to understand their
characteristics. The power factor calculation of a three-phase system is covered in
Fig. 16.38 Simulink diagram of a DC machine block
Table 16.12 Blocks and navigation routes for modeling a DC machine
Blocks
Navigation path on the Simulink Library Browser
DC Machine
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Machines ! DC Machine
DC Voltage
Source
DC Voltage
Source1
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources ! DC Voltage Source
Step
Simulink ! Sources ! Step
Bus Selector
Simulink ! Signal Routing ! Bus Selector
Scope
Simulink ! Sinks ! Scope
Display
Simulink ! Sinks ! Display
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! powergui
16.8
Conclusion
487

Fig. 16.39 Block parameters of the DC machine
Fig. 16.40 The armature current, ﬁeld current, power, and electrical torque observed from the
scope window
488
16
Application of Simulink in Power Systems

this chapter due to its importance in the power engineering domain. Afterward,
different power system conﬁgurations, such as Y-Y, Δ  Δ conﬁgurations, are
explained in terms of simulation results obtained via Simulink modeling. To under-
stand the applications of Simulink in the power system domain, the electrical
machine section is included in the last part of this chapter. In this section, two
different types of machines—DC Machine and Asynchronous Machine—are incor-
porated with adequate graphical demonstration to grasp the usage of the Simulink in
the power system domain. To understand and learn the modeling of different power
systems via simulation, this book can be used as a tutorial that incorporates several
examples for better comprehensibility.
Fig. 16.41 Simulink diagram of an asynchronous machine block
Table 16.13 Blocks and navigation routes for modeling an asynchronous machine
Blocks
Navigation path on the Simulink Library Browser
Asynchronous
Machine
SI Units
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Machines ! Asynchronous Machine SI Units
Three-Phase
Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources ! DC Voltage Source
Step
Simulink ! Sources ! Step
Bus Selector
Simulink ! Signal Routing ! Bus Selector
Scope, Scope1
Simulink ! Sinks ! Scope
Display
Simulink ! Sinks ! Display
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! powergui
16.8
Conclusion
489

Fig. 16.43 Block parameters of the asynchronous machine SI units
Fig. 16.42 Block parameters of the three-phase source
490
16
Application of Simulink in Power Systems

Exercise 16
1. (a) Write down the differences between single-phase and three-phase AC power
sources?
(b) Design a Simulink model for a three-phase wye-connected AC power source
by utilizing a Three-Phase Source block for the following parameters:
(i) Peak amplitude ¼ 480 V per phase; internal impedance, R ¼ 0.5 ohms,
L ¼ 0.015 H.
(ii) RMS voltage ¼ 480 V per phase; internal impedance ¼ 0.
(c) Show the voltages of the source using a Scope block.
Fig. 16.44 The rotor speed and the electromagnetic torque observed from the scope window
Exercise 16
491

(d) With a three-phase AC power source, connect a Three-Phase Series RLC
Load. Show the voltages and the currents of the system using Scope.
2. (a) Represent power factor in terms of real and reactive power.
(b) For a delta-connected three-phase AC source with a Three-Phase Parallel RLC
Load, simulate a model to calculate the power factor of the system.
(c) Show the real, reactive, and apparent power of the system using a Scope block.
3. (a) What are the characteristics of a balanced Y-Y power system.
(b) Design a balanced Y-Δ power system conﬁguration using Simulink.
(c) Show the different voltages and currents (line and phase) of the entire system.
(d) Make comments on the obtained simulation results to justify the characteris-
tics of the model.
4. (a) What are the differences between a balanced and an unbalanced system?
(b) Design an unbalanced Δ-Y power system using Simulink.
Fig. 16.45 The stator and rotor currents observed from the scope window
492
16
Application of Simulink in Power Systems

(c) Show the line voltages and currents of the system along with the phase values
as well.
(d) Comment on the characteristics of such a model based on the simulation
result.
5. (a) What is the categorization of electrical machines?
(b) Design a Simulink model to run a DC Machine with a preset model of 20HP,
500 V, 1750 RPM, ﬁeld: 300 V.
(c) Show the output Power and Torque of the DC Machine using a Scope block.
6. (a) Write down some of the rotor types of Asynchronous Machine.
(b) Design a Simulink model to run an Asynchronous Machine by using a delta-
connected three-phase AC source as the input.
(c) Show the output parameters of the machine using Scope blocks.
Exercise 16
493

© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_17
495
Chapter 17
Application of Simulink in Power
Electronics
17.1
Diode
Power electronics, as the name suggests, is the study of the electronics devices that deals
with high power, integrating control, energy, and electronics altogether. Electronics
devices usually have small voltage and currents (typically millivolt and milliampere),
whereas power electronics devices handle high voltage and current of kilovolt and
ampere or above. Such devices are at the core of numerous applications, since AC
and DC conversions, machine controls, and switching regulations are essential parts of
daily electrical activities. A diode is a semiconductor device with two terminals, which
can operate as a switch with a speciﬁed voltage, called forward voltage. For example, if
the forward voltage of a diode is 0.7 V, and if the diode is placed in a series circuit
between the switch and load, the circuit will conduct only when the source voltage is
above 0.7 V. It is a unidirectional device, which allows current to ﬂow only in a single
direction. The major applications of diode include switching, isolation of a system from
outside signals, and converting AC parameters into DC parameters.
17.1.1
Diode Characteristics
The diode works in two modes—in forward biased mode when the anode is positive
compared to the cathode and in reverse-biased mode when the cathode is positive
compared to the anode. The diode conducts when the voltage across the diode is
higher than the turn-on voltage of the diode. Typically, the turn-on voltage for the
diode is considered to be 0.7 V, which varies depending on the material. In Simulink,
diode parameters can be changed to verify the characteristics and make the diode
suitable for different power electronics applications. In the Simulink library, diodes
for both physical system modeling and Simulink modeling are present. However, the

working principle of both devices is the same, and the component for Simulink is
used in this chapter.
In order to demonstrate the diode characteristics, a setup has been built using the
following components (Table 17.1).
A 5 V AC source with 60 Hz frequency is used in the system with a resistance of
5 Ω. A diode with 0.7 V forward voltage (which can be selected by double-clicking
on the diode and changing the forward voltage into 0.7) is chosen for the operation.
In this example, the voltage across the source, diode, and resistive load will be
demonstrated and compared in understanding the diode behavior.
When the diode is initially placed into the window, it consists of three ports,
including an extra measurement port for measuring diode voltages and currents. In
this chapter, the measurement ports for the devices are not shown and are disabled by
double-clicking on the diode and unchecking the “Show measurement port”
checkbox. It is to be noted that the measurement port has been disabled to highlight
the actual measurement of the voltage and current (Fig. 17.1).
The discrete powergui block is used and the conﬁguration parameters have been
changed to Modeling ! Model Settings ! Solver ! Solver Selection ! discrete
(no continuous states) (Fig. 17.2).
Connect the components as shown in Fig. 17.3. The voltage measurement devices
have been renamed for the ease of demonstration in the scope. Some of the
components in this chapter have also been rotated or ﬂipped for better visualization.
The components can be rotated or ﬂipped by right-clicking on the block, selecting
“Rotate & Flip,” and picking the appropriate orientation for the demonstration.
It is seen from the graph in Fig. 17.4 that although the voltage varies sinusoidally
from 0 V to 5 V, the output is not the same for the load due to the presence of the
diode. As the turn-on voltage for the diode is 0.7 V, the voltage below 0.7 V appears
on the second subplot. However, the diode allows the current to ﬂow only when the
voltages are above 0.7 V, creating a voltage difference of 4.63 V across the resistive
load. A similar characteristic for reverse-biased operation can be obtained by
changing the polarity of the diode in the same setup.
Table 17.1 Blocks and navigation routes for demonstrating diode characteristics
Name of the
block
Navigation route
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks
AC Voltage
Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources
Diode
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Power Electronics
Voltage
Measurement
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Measurements
Series RLC
Branch
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Elements
Scope
Simulink ! Sinks
496
17
Application of Simulink in Power Electronics

17.1.2
Single-Phase Half-Wave Rectiﬁer
Due to its unidirectional capability, diodes are used for current and voltage rectiﬁ-
cation—an operation to convert AC into DC. An initial approach for the conversion
is to cut the negative half of the voltage through unidirectional switching. The circuit
through which this is done for a single phase is called a single-phase half-wave
rectiﬁer.
17.1.2.1
Single-Phase Half-Wave Rectiﬁer with R Load
A similar setup used in the previous section is used with a resistive load (R load) for
this example, with voltage and current measurement blocks placed as per Fig. 17.5.
Fig. 17.1 Block parameters of the diode block
Fig. 17.2 Conﬁguration parameters of the diode
17.1
Diode
497

An AC voltage source of 12 V at 60 Hz, with a resistance of 10 Ω, is used in this
setup.
In the circuit, whenever the AC current attempts to ﬂow toward the negative
direction in the resistive load, the diode acts as an off-switch and stops the ﬂow. For
this reason, the voltage or current value during the negative source voltage appears to
be zero, as shown in Fig. 17.6. The circuit is able to work only for the positive half-
cycles; hence, the circuit is called a half-wave rectiﬁer.
17.1.2.2
Single-Phase Half-Wave Rectiﬁer with RL Load
The value of the inductance as a load changes the output waveform. To demonstrate
the output with inductance load, the “Series RLC Branch” is modiﬁed to be an “RL”
branch by double-clicking on it. Two values of inductances, i.e., 1 mH and 500 mH,
have been considered for comparing the impact of low and high inductance on the
setup (Fig. 17.7).
It is seen that at a low inductance, the branch behaves like the R branch. As
inductance works as an energy storage device, at a low value, the inductor does not
store much energy, and thus, the whole branch behaves somewhat similar to the R
branch (Fig. 17.8). But at a high inductance value, the inductor stores more energy to
allow a constant ﬂow of current. This extra energy is dissipated through high voltage
across the load. Hence, the output waveform deviates from that of the R load
(Fig. 17.9). Sometimes, the excess energy trapped in the load may damage the
diode, for which a bypass path through another diode called a freewheeling diode
is used in parallel with the load.
Fig. 17.3 Simulink diagram of the diode in an AC circuit
498
17
Application of Simulink in Power Electronics

17.1.2.3
Single-Phase Half-Wave Rectiﬁer with RC Load
Like the inductor, the presence of a capacitor in the diode circuit also impacts the
output waveforms. To demonstrate the output with capacitance load, the “Series
RLC Branch” is modiﬁed to be an “RC” branch by double-clicking on it. Two values
of capacitors, i.e., 1 μF and 100 μF, have been considered for comparing the impact
of low and high capacitance on the setup (Fig. 17.10).
Unlike inductors, capacitors attempt to maintain a constant voltage. For a lower
capacitance value, the output voltage still ﬂuctuates, as shown in Fig. 17.11, but for a
higher value, the output voltage almost smoothens, as visible from the waveform of
the output voltage in Fig. 17.12.
17.1.3
Single-Phase Full-Wave Rectiﬁer
Unlike half-wave circuits, this rectiﬁer can convert both the cycles of the AC sine
wave into a unidirectional signal (pulsating DC). A two-diode with center-tap
transformer or a four-diode with center-tap or linear transformer is used for this
circuit. In this system, one set of the diodes are forward biased and two of the other
Fig. 17.4 The input voltage and the voltages across the diode and the load observed from the scope
window
17.1
Diode
499

Fig. 17.5 Simulink diagram of a Single-Phase Half-wave Rectiﬁer with resistive load
Fig. 17.6 The input and output voltages and the current measurement observed from the scope
window
500
17
Application of Simulink in Power Electronics

diodes remain in the reverse-biased mode to let the ﬁrst half-cycle ﬂow in the
positive direction. During the ﬂow of the negative half-cycle, the diodes alter their
modes, providing the circuital path for another ﬂow in the positive direction—
converting the complete input sinusoidal into a full-wave rectiﬁed output.
Fig. 17.7 Simulink diagram of a Single-Phase Half-wave Rectiﬁer with RL load
Fig. 17.8 The input and output voltages and the current measurement observed from the scope
window
17.1
Diode
501

17.1.3.1
Two-Diode Full-Wave Rectiﬁer
In a center-tap transformer, one of the coils in a winding is used to take the output for
voltage or current rectiﬁcation or transformation. Such transformers are widely used
as dual or split supplies, or for rectiﬁcation. This transformer also helps to perform
full-wave rectiﬁcation using only two diodes; hence, this setup is utilized in labora-
tories for experimentations (Fig. 17.13).
The setup is simulated in Fig. 17.14 with an 110 V 60 Hz AC voltage source and
with a resistance of 10 Ω. The linear transformer is taken from the path
Simscape
!
Electrical
!
Specialized
Power
Systems
!
Fundamental
Blocks ! Elements ! Linear Transformer. The transformer parameters are changed
as follows for a 40 VA 60 Hz 110/12 V transformer. In order to make it center-
tapped, winding two and three are shortened with a ground (from the same library
path as the linear transformer).
Notice that with the R load, another ground has also been connected to make sure
the full-wave rectiﬁcation. From the output waveforms, it is clearly visible that the
input voltage of 110 V is rectiﬁed into a full-wave pulsating DC of 12 V (Fig. 17.15).
17.1.3.2
Four-Diode Full-Wave Rectiﬁer
Four-diode full-wave rectiﬁers are used in relatively high-power applications. In this
conﬁguration, the loads are not needed to be connected to the ground (Fig. 17.16).
Fig. 17.9 The input and output voltages and the current measurement for high inductance value
observed from the scope window
502
17
Application of Simulink in Power Electronics

Notice the connection of the AC voltage source, the ﬁrst terminal of which is
connected with the ﬁrst set of diodes, while the other terminal is connected with the
Fig. 17.10 Simulink diagram of Single-Phase Half-wave Rectiﬁer with RC load
Fig. 17.11 The input and output voltages and the current measurement observed from the scope
window
17.1
Diode
503

second set of diodes as shown in the diagram. The same AC voltage source of 110 V
60 Hz is used with 10 Ω resistive load. The transformer with the previously
mentioned ratings is used, but the third winding has been disabled by double-
clicking on the “Linear Transformer” and unchecking the box for the “Three
windings transformer.” Note that in order to work with the two-diode full-wave
rectiﬁer, a center-tapped transformer must be used, but in the case of the four-diode
counterpart, either a center-tapped or double winding transformer can be utilized.
The output waveforms are similar to the two-diode conﬁguration, as shown in
Fig. 17.17.
In both these examples, it is seen that the output voltage does not fully achieve
12 V. It is because of some voltage drop across other electrical elements in the
circuit, especially across the diode, which has a forward voltage of 0.7 V for this
example. By decreasing the value, a more accurate output voltage can be acquired.
17.1.4
Three-Phase Full-Wave Rectiﬁer
A three-phase full-wave rectiﬁer performs full-wave rectiﬁcation but simultaneously
for all three phases. A six-diode conﬁguration with a Three-Phase Source is used for
this purpose. As shown in Fig. 17.18, the phase angles for each of the AC voltage
source are chosen at a phase difference of 120. A resistive load of 100 Ω has been
considered for this setup. The voltage and frequency of the AC source are chosen to
Fig. 17.12 The input and output voltages and the current measurement for high capacitance value
observed from the scope window
504
17
Application of Simulink in Power Electronics

Fig. 17.13 Block parameters of the linear transformer
Fig. 17.14 Simulink diagram of Single-Phase Full-Wave Rectiﬁer with transformer
17.1
Diode
505

be 110 V and 60 Hz, respectively. The complete setup in Simulink for the rectiﬁer is
shown in Fig. 17.19.
Figure 17.20 shows the three-phase input voltage and the resulting full-wave
rectiﬁed output voltage and current. Such rectiﬁers are highly efﬁcient and are vastly
used in industries and companies for motor control applications, voltage stabilization
and protection, and energy storage charging.
From the graph, it is visible that the voltage across the load is rectiﬁed and the
current waveform shares its resemblance with the voltage waveform.
17.2
Transistor
Transistors are three-terminal devices that can transfer signals from lower resistance
to higher resistance. The device is used for regulation, ampliﬁcation, generating, and
controlling electrical signals. Such a wide range of applications has resulted in many
variations of transistors. Based on the constructions, transistors are mainly of two
types, called bipolar junction transistors (BJTs) and ﬁeld-effect transistors (FETs).
Both of these transistors can be designed in Simulink, and some of the built-in
transistor models are present in the Simscape environment. The NPN and PNP
variations of BJTs, along with metal-oxide-semiconductor ﬁeld-effect transistors
(MOSFETs) and insulated gate bipolar transistors (IGBTs), are discussed in detail
in the following subsections.
Fig. 17.15 The input voltage and the load voltage observed from the scope window
506
17
Application of Simulink in Power Electronics

Fig. 17.16 Simulink diagram of Single-Phase Full-Wave rectiﬁer with Four Diodes
Fig. 17.17 The input voltage and the load voltage observed from the scope window
17.2
Transistor
507

17.2.1
Bipolar Junction Transistors (BJTs)
BJTs are transistors consisting of three terminals and two junctions controlled by
both electron and hole carriers. The transistor goes through two semiconductor
layers, called the p-layer and the n-layer. Depending on the constructions, the
transistor is called either an NPN or a PNP transistor. The three terminals of a BJT
are named emitter, base, and collector. BJT is known as a current-controlled device;
the small amount of current provided from the base to the emitter (in NPN) paves the
path for a higher current to ﬂow from collector to emitter (in NPN). In PNP
transistors, the current ﬂows are in the opposite direction than NPN transistors.
The I-V characteristics for NPN and PNP transistors are shown using Simulink to
understand their behaviors better. The following elements are taken from the
“Simulink Library Browser” for constructing the circuits in this subsection
(Table 17.2).
(a)  
(b)
(c)
Fig. 17.18 Block parameters of the three AC voltage sources
508
17
Application of Simulink in Power Electronics

Fig. 17.19 Simulink diagram of a Three-Phase Full-Wave Rectiﬁer
Fig. 17.20 The three input voltages, the output voltage, and the output current observed from the
scope window
17.2
Transistor
509

The I-V characteristic for the transistor is a graph for the collector current (Ic)
versus the collector-emitter voltage (Vce). A small base current of 0.003 A is
provided in the “DC Current Source” block (named as Ib), and a slope of 4 in the
ramp (named as Vce) at the input of the “Controlled Voltage Source” block is given,
to observe the collector current (Ic) for a period of 5 s. As the bipolar transistors are
physical components (i.e., from the Simscape environment), conversion blocks such
as PS-Simulink and Simulink-PS converters are used for signal conversion. Since an
I-V characteristic is to be demonstrated, an “XY Graph” with a limit of 0–5 in the x-
axis and 0–0.3 in the y-axis is used. The circuit is connected as per Fig. 17.21.
The I-V characteristics for the NPN transistor for 0.003 A base current, therefore,
appear to be as follows (Fig. 17.22):
The PNP transistor demonstrates a similar characteristic to that of the NPN
transistor, but since the current ﬂow is the opposite, the values also appear
negative to that of the NPN transistor. A small base current of 0.003 A is
provided in the “DC Current Source” block (named as Ib), and a slope of 5 in the
ramp (named as Vce) at the input of the “Controlled Voltage Source” block is
given, to see the collector current (Ic) for a period of 5 s. Additionally, in the
Ramp block, the start time is 0, and the initial output is selected to be 5. The
“XY Graph” with a limit of 4 to 0 on the x-axis and 0.3 to 0.05 in the y-axis
are used. The circuit is connected as per Fig. 17.23 with the components as
follows (Fig. 17.24 and Table 17.3):
17.2.2
MOSFET
The metal-oxide-semiconductor ﬁeld-effect transistor (MOSFET) is a FET that has
three terminals, which are named drain, source, and gate. Unlike typical BJT, FET is
controlled by a gate signal. Whenever the gate signal is greater than zero, the
MOSFET turns on irrespective of the drain-source voltage. However, if the current
Table 17.2 Blocks and navigation routes for modeling NPN bipolar transistor
Name of the block
Navigation route
Solver Conﬁguration
Simscape ! Utilities
NPN Bipolar Transistor
Simscape ! Electrical ! Semiconductors & Converters
DC Current Source
Simscape ! Foundation Library ! Electrical ! Electrical Sources
Current Sensor
Simscape ! Foundation Library ! Electrical ! Electrical Sensors
Controlled Voltage Source
Simscape ! Foundation Library ! Electrical ! Electrical Sources
PS-Simulink Converter
Simscape ! Utilities
Simulink-PS Converter
Simscape ! Utilities
Ramp
Simulink ! Sources
XY Graph
Simulink ! Sinks
Electrical Reference
(ERef)
Simscape ! Foundation Library ! Electrical ! Electrical
Elements
510
17
Application of Simulink in Power Electronics

ﬂowing through it is negative with no gate signal, MOSFET turns off. MOSFETs are
also divided into two types, N-Channel MOSFET and P-Channel MOSFET. There is
more than one instance of MOSFET block in the Simscape library. The N-Channel
MOSFET is utilized in this example.
In order to build a MOSFET circuit for characterization, the following compo-
nents were used (Table 17.4).
A gate voltage of 4.5 V has been set in the DC Voltage Source block named Vg. A
Slope of 1 for the Ramp block (named as Vds), with other parameters (“start time”
and “initial output”) as 0, has been set. For showing the V-I graph clearly, the
parameters in the XY Graph block have been changed as X-min 0, X-max 4, Y-min
0, and Y-max 20, with the default sample time. In the setup outlined in Fig. 17.25 and
the graph in Fig. 17.26, the V-I characteristics for a MOSFET are shown for a stop
time of 5 s. It is seen that the current across the MOSFET increases as the voltage
increases.
17.2.3
IGBT
Similar to MOSFET, Insulated Gate Bipolar Transistor (IGBT) is a transistor that has
three terminals. These are made with four layers of alternating P- and N-type
semiconductors. Their terminals are termed as collector, emitter, and gate. An
IGBT merges the features of both BJT and MOSFET. An IGBT turns on when a
positive gate signal is applied, and its collector-emitter voltage is positive and greater
than its forward voltage. The device turns off during a zero gate signal and stays in
Fig. 17.21 Simulink diagram of a circuit containing an NPN transistor
17.2
Transistor
511

Fig. 17.22 The I-V characteristic curve of the NPN transistor
Fig. 17.23 Simulink diagram of a circuit containing an PNP transistor
512
17
Application of Simulink in Power Electronics

off-state during a negative collector-emitter voltage. In Simulink, there are two
IGBTs as physical components (named as “IGBT (Ideal, Switching)” and “N-
Channel IGBT”), and as Simulink components (named as “IGBT” and “IGBT/
Diode”). The IGBT/Diode block consists of a diode in parallel with the IGBT called
antiparallel diode to block current ﬂow in the reverse direction. Like MOSFET
blocks, the IGBT blocks contain snubber circuits for enhanced protection and
performance.
In order to build an IGBT circuit for characterization, the following components
were used (Table 17.5).
Fig. 17.24 The I-V characteristic curve of the PNP transistor
Table 17.3 Blocks and navigation routes for modeling PNP bipolar transistor
Name of the block
Navigation route
Solver Conﬁguration
Simscape ! Utilities
PNP Bipolar Transistor
Simscape ! Electrical ! Semiconductors & Converters
DC Current Source
Simscape ! Foundation Library ! Electrical ! Electrical Sources
Current Sensor
Simscape ! Foundation Library ! Electrical ! Electrical Sensors
Controlled Voltage Source
Simscape ! Foundation Library ! Electrical ! Electrical Sources
PS-Simulink Converter
Simscape ! Utilities
Simulink-PS Converter
Simscape ! Utilities
Ramp
Simulink ! Sources
XY Graph
Simulink ! Sinks
Electrical Reference
(ERef)
Simscape ! Foundation Library ! Electrical ! Electrical
Elements
17.2
Transistor
513

In the setup outlined in Fig. 17.27 and the graph in Fig. 17.28, the ideal V-I
characteristics for an IGBT are shown. The DC Voltage Source block named as
“Vge” is selected to be 4.5 V. The Ramp block annotated as “Vce ramp” is used to
update the Controlled Voltage Source block with a “Slope” of 1, “Start time” of
0, and “Initial output” of 0. For showing the V-I graph clearly, the parameters in the
XY Graph block have been changed as X-min 0, X-max 5, Y-min 0, and Y-max
Table 17.4 Blocks and navigation routes for demonstrating MOSFET characteristics
Name of the block
Navigation route
Solver Conﬁguration
Simscape ! Utilities
N-channel MOSFET
Simscape ! Electrical ! Semiconductors & Converters
DC Current Source
Simscape ! Foundation Library ! Electrical ! Electrical Sources
Current Sensor
Simscape ! Foundation Library ! Electrical ! Electrical Sensors
Controlled Voltage Source
Simscape ! Foundation Library ! Electrical ! Electrical Sources
PS-Simulink Converter
Simscape ! Utilities
Simulink-PS Converter
Simscape ! Utilities
Ramp
Simulink ! Sources
XY Graph
Simulink ! Sinks
Electrical Reference
(ERef)
Simscape ! Foundation Library ! Electrical ! Electrical
Elements
Fig. 17.25 Simulink diagram of a circuit containing an N-channel MOSFET
514
17
Application of Simulink in Power Electronics

400, with the default sample time. The simulation has been run for 5 s for a better
representation.
17.3
Operational Ampliﬁer
As mentioned in Chap. 8, an operational ampliﬁer or Op-amp is an active device that
can amplify any input signals, perform mathematical operations, and ﬁlter signals. A
standard Op-amp has ﬁve important ports, which are used to invert input signal as
necessary, connect with power signals, and deliver the output signal. The calcula-
tions for the inverting ampliﬁer, non-ampliﬁer, differentiator, and integrator were
performed using MATLAB in Chap. 8. In this section, Simulink models for those
Op-amp circuits will be prepared, and the formulas will be veriﬁed to understand
Op-amp applications better. Op-amp is a physical device in Simulink, which is
available from the following library:
Simscape ! Foundation Library ! Electrical ! Electrical Elements
Fig. 17.26 The I-V characteristic curve of the N-channel MOSFET
17.3
Operational Ampliﬁer
515

17.3.1
Inverting Ampliﬁer
As the name suggests, the circuit ampliﬁes the input signal through the Op-amp but
inverts the gain at the same time. The formula for determining the output voltage for
the inverting ampliﬁer is:
Table 17.5 Blocks and navigation routes for demonstrating IGBT characteristics
Name of the block
Navigation route
Solver Conﬁguration
Simscape ! Utilities
N-channel IGBT
Simscape ! Electrical ! Semiconductors & Converters
DC Current Source
Simscape ! Foundation Library ! Electrical ! Electrical Sources
Current Sensor
Simscape ! Foundation Library ! Electrical ! Electrical Sensors
Controlled Voltage Source
Simscape ! Foundation Library ! Electrical ! Electrical Sources
PS-Simulink Converter
Simscape ! Utilities
Simulink-PS Converter
Simscape ! Utilities
Ramp
Simulink ! Sources
XY Graph
Simulink ! Sinks
Electrical Reference
(ERef)
Simscape ! Foundation Library ! Electrical ! Electrical
Elements
Fig. 17.27 Simulink diagram of a circuit containing an N-channel IGBT
516
17
Application of Simulink in Power Electronics

Vout ¼  R2
R1 Vin
For an AC source with 12 V 60 Hz; two resistors of values 10 Ω and 50 Ω (R1 and
R2), respectively; and a load resistance of 1 Ω (named as Resistor3 in the circuit), the
output voltage for the inverter ampliﬁer can be calculated as:
Vout ¼  50
10  12 V ¼ 60 V
The minus sign indicates the negative polarity of the waveform. The circuit is
constructed with the mentioned speciﬁcations according to Fig. 17.29. The Op-amp
is ﬂipped for the convenience of connection. The Op-amp can be ﬂipped by right-
clicking on it, selecting “Rotate & Flip,” selecting “Flip Block,” and then “Up-
Down.” Upon running the simulation and observing the graph from the Scope, it will
be seen that the output waveform resembles the mathematical calculation performed
above, with a peak value of 60 V and in the opposite direction with respect to the
input signal (Fig. 17.30).
Fig. 17.28 The I-V characteristic curve of the N-channel IGBT
17.3
Operational Ampliﬁer
517

17.3.2
Non-inverting Ampliﬁer
Unlike an inverter ampliﬁer, a non-inverting ampliﬁer ampliﬁes the input signal
without inverting the signal. The formula for the output voltage can be written as
follows:
Vout ¼
1 þ R2
R1


 Vin
For the same setup as in the previous circuit (12 V circuit with 10 Ω R1 resistor,
50 Ω R2 resistor, and load resistance of 1 Ω), the output voltage can be calculated as:
Vout ¼
1 þ 50
10


 12 V ¼ 72 V
That means the voltage across the 1 Ω load resistor will be 72 V. The positive sign
indicates that the output voltage is in a similar direction with the input voltage. The
circuit diagram and the voltage waveforms are shown in Fig. 17.31 and Fig. 17.32,
respectively.
Fig. 17.29 Simulink diagram of a circuit containing an operational ampliﬁer
518
17
Application of Simulink in Power Electronics

17.3.3
Differentiator Circuit
In a differentiator circuit, the Op-amp performs differentiation on the system and
provides the resultant signal as the output signal. The formula for the resultant
voltage can be represented as follows:
Vout ¼ RC dVin
dt


In the designed circuit in Fig. 17.33, the input AC voltage source is set to be 12 V
60 Hz, with the value of capacitor and resistance being 0.001 F and 10 Ω, respec-
tively, and with a load resistance of 1 Ω only. The input and output waveform is
shown in Fig. 17.34.
Fig. 17.30 The PS Simulink Converter outputs observed from the scope window
17.3
Operational Ampliﬁer
519

17.3.4
Integrator Circuit
In an integrator circuit, the Op-amp performs integration on the system and provides
the resultant signal as the output signal. The formula for the resultant voltage can be
represented as follows:
Vout ¼  1
RC
Z
Vindt


In the designed circuit in Fig. 17.35, the input AC voltage source is set to be 12 V
60 Hz, with the value of capacitor and resistance being 0.001 F and 10 Ω, respec-
tively, and with a load resistance of 1 Ω only. The input and output waveform is
shown in Fig. 17.36.
17.4
Control Devices
Power electronics devices can be broadly classiﬁed into controllable and uncontrol-
lable devices. The two-terminal devices, such as diodes, are considered uncontrolled
because there is no way to control the current ﬂow or voltage across such devices. On
the other hand, three-terminal devices, such as MOSFET, IGBT, and thyristor, are
controlled devices, as their third terminal controls the current ﬂow between the other
two terminals. Since the characteristics of MOSFET and IGBT have been discussed
Fig. 17.31 Simulink diagram of a circuit containing a non-inverting ampliﬁer
520
17
Application of Simulink in Power Electronics

in the previous section, this chapter will build circuits with thyristors and gate turn-
off (GTO) thyristor and show the characteristics through controlling the sinusoidal
inputs. The model for thyristor and GTO is readily available in Simulink and will be
used in other sections of this chapter.
17.4.1
Pulse Generation
Pulse generation is important for control devices in power electronics, as these
signals guide how the current ﬂow between the devices will ﬂow. The pulses are
usually square waves with a unit amplitude, varying from 1 (on-state) and
0 (off-state) only, similar to the digital systems. This signal is provided at the gate
terminal of the control devices. There are two types of pulse in Simulink that can be
Fig. 17.32 The voltage outputs observed from the scope window
17.4
Control Devices
521

Fig. 17.33 Simulink diagram of a differentiator circuit
Fig. 17.34 The differentiator circuit input and output observed from the scope window
522
17
Application of Simulink in Power Electronics

Fig. 17.35 Simulink diagram of an integrator circuit
Fig. 17.36 The integrator circuit input and output observed from the scope window
17.4
Control Devices
523

used with these devices, i.e., time-based pulse and sample-based pulse. In this
chapter, time-based pulse using simulation time is utilized. The most commonly
used pulse generator is available in Simulink ! Source. There are options for
selecting the amplitude, pulse period, pulse width, and phase delay for time-based
pulses. For every setup, the pulse characteristics are determined and provided to the
control device for the desired performance.
17.4.1.1
Duty Cycle
Duty cycle is the percentage time a pulse stays on-state, with respect to the total cycle
time. If a pulse has a total cycle time of T, and the pulse stays on-state and off-state
for a time period of T1and T2, respectively, then the duty cycle can be represented as:
Duty cycle ¼
T1
T1 þ T2 ¼ T1
T
For the following Simulink example, 20% and 80% duty cycles are shown. A
PWM Generator block is used to show that a DC input of constant value can be
considered the on-time for generating a pulse. Constant values of 0.2 and 0.8 are
used to generate a duty cycle of 20% and 80%, respectively, in these examples. After
setting the components as shown in Fig. 17.37, the output waveform shows an
on-time of 0.2 and 0.8 ms, respectively, where the total cycle time is 1 ms in each
case (Fig. 17.38).
17.4.1.2
Pulse Modulation
Pulse modulation is the transmission of pulsating signals in different forms. The
variations in different forms of pulse help to produce pulses of different nature (e.g.,
different amplitude, width, or position). These pulses trigger (turn-on) the controlled
devices to generate output waveforms as desired. A modulating wave is provided as
a reference to modify a given pulse (career pulse) to obtain modulated pulses. By
using modulating wave and career pulse, pulses can be modulated with three
techniques mentioned as follows:
1. Pulse-Amplitude Modulation (PAM)
In PAM, the amplitude of the career pulse is changed, keeping the width and
frequency the same. The amplitude of the modulated signal is dependent on the
modulating waveform. In Fig. 17.39, a pulse of constant amplitude and width is
generated using the Pulse Generator block. Sinusoidal wave generated from the
Sine Wave block is used as the modulated signal to vary the amplitude of the
pulse sinusoidally. The modulating wave and career pulse are multiplied to obtain
such variations of amplitude. Figure 17.40 shows the PAM technique and
corresponding output for the given signal. It is to be noted that, for this example,
524
17
Application of Simulink in Power Electronics

the amplitude and frequency (rad/s) for the setup are chosen to be 1 and 5, respec-
tively. The rest of the parameters are 0 for the Sine Wave block. For the Pulse
Generator block, the amplitude, period, pulse width, and phase delay are chosen
to be 1, 0.1, 50, and 0, respectively.
2. Pulse-Width Modulation (PWM)
In PWM, the width of the career pulse is changed, keeping the amplitude the
same. In order to produce a pulse of the same amplitude but with the varying
wave, the sawtooth wave and sine wave of different amplitudes have been
superimposed on each other. At the points where the amplitude of the sawtooth
wave is higher than the sine wave is considered to be the on-time for the pulse.
The varying nature of both the waves generates a pulse with different widths.
In
order
to
demonstrate
the
modulation,
a
Sine
Wave
block
(Simulink ! Sources) and a Sawtooth Generator block (Simscape ! Electri-
cal ! Specialized Power Systems ! Fundamental Blocks ! Power Electron-
ics ! Pulse & Signal Generators) are used, the output waveforms of which are
subtracted using an Add block. The output is then compared to a “Compare to
Zero” block (Simulink ! Logic and Bit Operations), which compares the
subtracted result and returns the pulse when the resultant is less than zero. For
this example, the amplitude and frequency of the Sine Wave block are chosen to
Fig. 17.37 Use of the PWM generator blocks in Simulink
Fig. 17.38 The output of the PWM generator blocks observed from the scope window
17.4
Control Devices
525

be 0.75 and 60 rad/s, the rest of the parameters (bias, phase, and sample time)
being zero. For the Add block, the sign is changed to “+” to perform subtrac-
tion. The operator in the Compare to Zero block is changed to “<¼.” After setting
the model up as in Fig. 17.41, the waveforms are visible as shown in Fig. 17.42.
3. Pulse-Position Modulation (PPM)
In PPM, the position of the career pulse is changed with respect to a reference
waveform, keeping the amplitude and width the same. In order to demonstrate
PPM, the PWM output obtained from the previous example is used as a reference
waveform, which considers the rising edge of the PWM signal as the starting
position for the PPM output pulse (Fig. 17.43).
The setup is similar to the PWM, but a new block Monostable (available at
Simscape ! Electrical ! Specialized Power Systems ! Control & Measure-
ments ! Logic) is used to provide a rising pulse whenever a change in the PWM
logic is detected. The edge detection parameter for the Monostable block is
selected to be “Rising,” with a pulse duration of 0.002 s, and the initial condition
of previous input and sample time of zero. The output waveform for PPM is
shown in Fig. 17.44, which shows the change in position with respect to the rising
edge of the PWM signal.
17.4.1.3
Determining the Firing Angle
For a particular frequency of f for a system, the time period can be calculated as
T ¼ 1
f. Since one cycle corresponds to 360 if the phase of the signal is to be delayed
Fig. 17.39 Pulse Amplitude Modulation (PAM) in Simulink
526
17
Application of Simulink in Power Electronics

for x
. Then the phase angle is calculated to be
x
360
, making the phase delay to be
x  1
T 
1
360 : The turn-on time for a control device from the starting of the waveform
can be calculated through the delay angle, also called the ﬁring angle. Therefore, for
a 60 Hz system, if a control device has a ﬁring angle of 45, the phase delay for the
system can be calculated as 45  1
60 
1
360 ¼ 0:002083 s. Using this calculation, the
“phase delay” parameter for the pulse generator in Simulink is determined based on
the required ﬁring angle.
Fig. 17.40 Output of the Pulse Amplitude Modulation (PAM) in Simulink
17.4
Control Devices
527

17.4.2
Controlled Rectiﬁcation with Thyristor
A thyristor is a three-terminal device with four layers of alternating p- and n-type
semiconductors. A thyristor is also known as a silicon-controlled rectiﬁer (SCR).
These devices are different than transistors because of their usage in more high-
power applications for having high current and voltage ratings. Thyristors have three
terminals called anode, cathode, and gate. Through the gate terminal, the current
across the anode and cathode is controlled. This subsection will control a sinusoidal
input with a ﬁring angle of 60
, provided by a 240 V 60 Hz AC voltage source,
connected to a 0.5 Ω resistor in series, as shown in Fig. 17.45. The following
components are taken from the Simulink library to arrange the circuit (Table 17.6).
The parameters for the Pulse Generator block to produce an angle of 60
 are
planned as follows (Fig. 17.46).
The output voltage waveform shows ﬁring at 60
, after which the wave follows
the positive half-cycle of the input and turns off for the negative half-cycle of the
input at the zero crossings of the current (Fig. 17.47).
17.4.3
Controlled Rectiﬁcation with GTO
The gate turn-off (GTO) thyristor is a controlled device similar to a thyristor, which
is controlled upon applying a gate signal at the gate of the device. Similar to
conventional thyristors, the three terminals of GTO are named anode, cathode, and
Fig. 17.41 Pulse Width Modulation (PWM) in Simulink
528
17
Application of Simulink in Power Electronics

Fig. 17.42 Output of the Pulse Width Modulation (PWM) in Simulink
Fig. 17.43 Pulse Position Modulation (PPM) in Simulink
17.4
Control Devices
529

gate. The GTO thyristor turns on when a positive gate signal is provided. However,
GTO thyristor is different from a conventional thyristor because it can be turned off
anytime upon applying a zero gate signal.
The characteristics of GTO thyristor are studied with the same circuit and same
parameter to that of the thyristor. The thyristor is replaced with the GTO, and the
input and output voltages are visualized through the Scope block. The GTO is
available from the same navigation path as the thyristors (Simscape ! Electri-
cal ! Specialized Power Systems ! Fundamental Blocks ! Power Electronics)
(Fig. 17.48).
Since a pulse width of 5% is selected for this example, the gate pulse will turn on
at the mentioned phase delay (for this example, it is at 60), and stay on for 5% of the
Fig. 17.44 Output of the Pulse Position Modulation (PPM) in Simulink
530
17
Application of Simulink in Power Electronics

period. It is seen from the graph that although the GTO turns on at the mentioned
ﬁring angle, the GTO turns off as soon as the gate pulse falls to 0, at 5% pulse width.
If the pulse width is increased, the gate will stay on for more period, and turn off as
soon as the gate pulse falls to 0 (Fig. 17.49).
Fig. 17.45 Controlled Rectiﬁcation with Thyristor in Simulink
Table 17.6 Blocks and navigation routes for modeling thyristor-based controlled rectiﬁer
Name of the
block
Navigation route
Powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks
AC Voltage
Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources
Series RLC
Branch
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Elements
Thyristor
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Power Electronics
Pulse Generator
Simulink ! Sources
Voltage
Measurement
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Measurements
Scope
Simulink ! Commonly Used Blocks
17.4
Control Devices
531

17.5
Facts
Flexible AC transmission systems (FACTS) are a growing technology in the domain
of power engineering, where static power electronics components are used to
enhance the quality of AC transmission. FACTS devices enhance the controlling
capacity during AC transmission, thus improving power transfer capability and
quality. In addition, these devices have the speciﬁcations to control megawatt-
range power using control devices. Among numerous applications of FACTS
devices, voltage regulation, transmission parameter control, and line loading capac-
ity are notable.
In Simulink, there are four power electronics-based FACTS devices dedicated to
experimenting with the power compensation technique through phasor-type FACTS
devices. Static synchronous compensator (STATCOM), static synchronous series
compensator (SSSC), static var compensator (SVC), and uniﬁed power ﬂow
Fig. 17.46 Block parameters of the pulse generator
532
17
Application of Simulink in Power Electronics

controller (UPFC) are the blocks for the purpose, which are available in the naviga-
tion
path
Simscape
!
Electrical
!
Specialized
Power
Sys-
tems ! FACTS ! Power-Electronics Based Facts.
Fig. 17.47 Output of the Controlled Rectiﬁcation with Thyristor
Fig. 17.48 Controlled Rectiﬁcation with GTO in Simulink
17.5
Facts
533

The construction of these devices is relatively complex and requires some prior
knowledge of reference frame transformation and phase-locked loop for designing
phasor models with these blocks. Therefore, these concepts are brieﬂy explored, and
only the operation of SVC is demonstrated in this section for the sake of simplicity.
17.5.1
Reference Frame Transformation
The three-axis frame where three-phase quantities of the AC circuit are represented
is called abc frame. For the ease of mathematical calculation, the three-phase
quantities of the AC circuits are sometimes required to be represented with respect
to two stationary axes (e.g., for calculating the reference signals for space vector
modulation control of three-phase inverter circuits). The two-axis stationary frame is
called the alpha-beta-zero frame. The transformation from abc frame to alpha-beta-
zero frame is known as Clarke transformation.
There is another reference frame with a rotating reference frame, unlike the alpha-
beta-zero frame, which is stationary. The frame is called direct-quadrature-zero (also
known as dq0 and dqz) frame. The purpose of the frame is to rotate the reference
frames for the AC waveforms so that the AC quantities appear as DC quantities,
which helps simplify complex calculations. The transformation from abc frame to
Fig. 17.49 Output of the Controlled Rectiﬁcation with GTO
534
17
Application of Simulink in Power Electronics

dq0 frame is called Park transformation. This transformation is used in performing
induction motor control.
Simulink has built-in blocks for straightforward transformation without diving
deeper into complicated mathematical calculations. Figure 17.50 shows the Clarke
and Park transformation using the components and their navigation path as shown
below. There are four other blocks to perform transformation between alpha-beta-
0 to dq0 and inverse transformations for each conversion (Table 17.7).
A Three-Phase Source is used to generate three-phase voltage. The parameters for
the Three-Phase Source are mentioned as follows (Fig. 17.51):
The voltage measurement parameter of the Three-Phase V-I Measurement block
is selected to be “phase-to-ground” for measuring the phase voltage, by omitting the
current measurement option (Fig. 17.52).
The Ramp block used in the setup is provided with a slope of 2*pi*60, with
starting time and initial output as 0. Figure 17.53 shows the output waveforms for the
reference frame. In the ﬁrst subplot, the abc quantities are shown; in the second
subplot, the alpha (red) and beta (blue) components are shown (the green wave being
0). Finally, in the third subplot, the direct (red) and quadrature (blue) components of
the dq0 frame are shown, representing the DC equivalent components of abc in a
rotating dq0 frame.
Fig. 17.50 Clarke and Park transformation in Simulink
17.5
Facts
535

17.5.2
Phase-Locked Loop (PLL)
A phase-locked loop (PLL) is a control algorithm that determines the frequency and
phase angle of a sinusoidal input. PLL is used for frequency matching between two
systems, after which there remains a constant phase difference, hence “locking” the
phase. PLL consists of a phase detection mechanism, a PID controller, and an
oscillator to generate the phase angle information. A low-pass ﬁlter is also present
Table 17.7 Blocks and navigation routes for demonstrating reference frame transformation
Name of the Bbock
Navigation route
Powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks
Three-Phase Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources
Three-Phase V-I
Measurement
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Measurements
abc to Alpha-Beta-
Zero
Simscape ! Electrical ! Specialized Power Systems ! Control &
Measurements ! Transformations
abc to dq0
Simscape ! Electrical ! Specialized Power Systems ! Control &
Measurements ! Transformations
Ramp
Simscape ! Sources
Scope
Simulink ! Commonly Used Blocks
Fig. 17.51 Block
parameters of the three-
phase source
536
17
Application of Simulink in Power Electronics

in the system to obtain the frequency information of the sinusoidal input. In FACTS
devices, PLL gain plays a vital role in stabilizing system performance.
In order to visualize how PLL reﬂects the change in frequency and phase, a setup
is created in the Simulink environment. The purpose is to change the frequency from
60 Hz to 61 Hz and observe how PLL responds to the change in frequency. For
Fig. 17.52 Block parameters of the three-phase V-I measurement
Fig. 17.53 The output waveforms of the Clarke and Park transformation
17.5
Facts
537

establishing the setup, the following components are utilized from the Simulink
library (Table 17.8):
For a three-phase signal with speciﬁc amplitude, phase, and frequency, generated
by the Three-Phase Programmable Generator, the behavior of the single-phase PLL,
the three-phase PLL, and the ideal system through bus selector is shown in
Fig. 17.54.
The speciﬁcations of the blocks are provided in the following ﬁgures (Figs. 17.55,
17.56, and 17.57):
In the ﬁrst area (green), only the ﬁrst phase information from the Three-Phase
Programmable Generator is obtained through a selector. The Selector is modiﬁed so
that the input port size becomes 3 and the index becomes 1. After double-clicking on
the Selector block, the index and input port size are, therefore, changed into 1 and
3, respectively, to obtain the symbol as shown in Fig. 17.54. The single-phase
information is fed to the single-phase PLL through the Selector to see the frequency
and phase angle information using Scope1.
In the second area (cyan), all the three-phase information is directly fed at the
input of the three-phase PLL to see the output results in Scope2. Finally, in the third
area (purple), the frequency and phase angle information is extracted from four other
signals using a Bus Selector block, where only the “Freq (Hz)” and “wt (rad)” signals
are selected from the left portion for visualization through Scope3 (Fig. 17.58).
The ﬁrst graph shows the frequency response for the single-phase PLL. The
response is relatively slower than that of the three-phase PLL because of the lack of
phase information. However, both the responses are close to the ideal behavior
(Fig. 17.59).
17.5.3
Static Var Compensator
The Static Var Compensator (SVC) is a power electronics device for FACTS
applications. The SVC is used in an AC transmission system to provide or absorb
reactive power to regulate voltage. During low voltages, SVC becomes capacitive
Table 17.8 Blocks and navigation routes for designing phase-locked loop
Name of the block
Navigation route
Three-Phase Programma-
ble Generator
Simscape ! Electrical ! Specialized Power Systems ! Funda-
mental Blocks ! Power Electronics ! Pulse & Signal Generators
Selector
Simulink ! Signal Routing
Bus Selector
Simulink ! Signal Routing
PLL
Simscape ! Electrical ! Specialized Power Systems ! Control &
Measurements ! PLL
PLL (3 ph)
Simscape ! Electrical ! Specialized Power Systems ! Control &
Measurements ! PLL
Scope
Simulink ! Commonly Used Blocks
538
17
Application of Simulink in Power Electronics

Fig. 17.54 Phase Locked Loop (PLL) in Simulink
Fig. 17.55 Block
parameters of the three-
phase programmable
generator
17.5
Facts
539

and provides reactive power to compensate for the reactive power, hence the name
“Var Compensator.” For high voltages, it absorbs reactive power to maintain the
voltage at the terminal. Switching for delivering or absorbing reactive power in this
manner is performed by thyristor switches, for which a PLL-supported synchroniz-
ing mechanism provides the pulse.
For demonstrating how an SVC compensates reactive power, the setup shown in
Fig. 17.60 is built using the following components from the Simulink Library
Browser (Table 17.9):
The objective of the setup is to compare the performance of the system with and
without SVC. A Three-Phase Programmable Voltage Source block with speciﬁc
parameters mentioned in Fig. 17.61 is used as the main source. Only the positive
Fig. 17.56 Block parameters of the PLL
540
17
Application of Simulink in Power Electronics

sequence input voltage is measured through the blocks “Three-Phase V-I Measure-
ment1” block (Fig. 17.62) and “Sequence Analyzer (Phasor)1” (Fig. 17.63)at the
ﬁrst input of the Scope (blue color in Fig. 17.68). A Terminator block at the end of
the second output in the Sequence Analyzer block is used to cap the output and block
any error message from Simulink for keeping the terminal disconnected.
Through a Three-Phase Series RLC Branch, a Three-Phase Series RLC Load is
connected with the speciﬁcations provided in Figs. 17.64 and 17.65. The positive
sequence voltage taken from the “Three-Phase V-I Measurement2” block is actually
the voltage without the SVC (as shown by the red line in the graph). This indicates
that the voltage drops signiﬁcantly compared to the input voltage. SVC will be used
at this instance to improve the voltage level and make the output voltage as close as
possible to the input voltage.
The following parameters are used in the Static Var Compensator block
(Fig. 17.66). Only the control voltage “Control VM (pu)” is chosen through a Bus
Selector block, as shown in Fig. 17.67.
Fig. 17.57 Block parameters of the three-phase PLL
17.5
Facts
541

After introducing the SVC, the output is seen to be closely matched with the input
voltage. A gain is added with the output of the control voltage signal to match better
with the input voltage (Fig. 17.68).
17.6
Modeling of Converters
In power electronics, it is necessary to work with various waveforms and convert
those to any suitable level of amplitude, frequency, or phase as per the requirement.
Converters help to serve the purpose by taking the input and transforming speciﬁc
features according to the behavior of the circuital elements. In this section, a brief
overview of the signiﬁcant DC-DC, DC-AC, AC-DC, and AC-AC converter model-
ing will be discussed with the help of Simulink simulations so that the readers can
obtain a sound knowledge of the working principles of each of the converters and
can design a converter with a proper understanding of how the circuital elements
impact the output.
Fig. 17.58 Block parameters of the bus selector
542
17
Application of Simulink in Power Electronics

(a)
(b) 
(c)
Fig. 17.59 The response of the PLL system observed from the scope window
17.6
Modeling of Converters
543

17.6.1
Model of DC-DC Converters
DC-DC converters convert a DC input to a DC output of a different voltage, as
required for the application. These can be used as switching-mode regulators,
converting an unregulated DC voltage into a regulated DC output voltage. The
voltages can either be lower or higher than the input voltages. The switching for
such conversion is performed using transistors with a pulse generated at a particular
Fig. 17.60 Static Var Compensator (SVC) in Simulink
Table 17.9 Blocks and navigation routes for modeling static var compensator
Name of the block
Navigation route
powergui
Simscape ! Electrical ! Specialized Power Sys-
tems ! Fundamental Blocks
Three-Phase Programmable Voltage
Source
Simscape ! Electrical ! Specialized Power Sys-
tems ! Fundamental Blocks ! Electrical Sources
Three-Phase V-I Measurement1,
Three-Phase V-I Measurement2
Simscape ! Electrical ! Specialized Power Sys-
tems ! Fundamental Blocks ! Measurements
Three-Phase Series RLC Branch
Simscape ! Electrical ! Specialized Power Sys-
tems ! Fundamental Blocks ! Elements
Three-Phase Series RLC Load
Simscape ! Electrical ! Specialized Power Sys-
tems ! Fundamental Blocks ! Elements
Static Var Compensator (Phasor
Type)
Simscape ! Electrical ! Specialized Power Sys-
tems ! FACTS ! Power-Electronics Based FACTS
Sequence Analyzer (Phasor)1,
Sequence Analyzer (Phasor)2
Simscape ! Electrical ! Specialized Power Sys-
tems ! Control & Measurements ! Measurements
Terminator
Simulink ! Sinks
Bus Selector
Simulink ! Commonly Used Blocks
Gain
Simulink ! Commonly Used Blocks
Scope
Simulink ! Commonly Used Blocks
Ground
Simscape ! Electrical ! Specialized Power Sys-
tems ! Fundamental Blocks ! Elements
544
17
Application of Simulink in Power Electronics

frequency. Buck converter and boost converter are the two most known switching-
mode regulators. The former decreases an input DC voltage, whereas the latter
increases the voltage. The simulation model for these converters is shown in the
following subsections.
Fig. 17.61 Block parameters of the three-phase programmable voltage source
Fig. 17.62 Block parameters of the three-phase V-I measurement 1
17.6
Modeling of Converters
545

17.6.1.1
Buck Converter
Buck converter provides a lower DC voltage than the source DC voltage. If a voltage
of Va is desired from a source voltage of Vs, a pulse with duty cycle k is is to be
Fig. 17.63 Block parameters of the three-phase V-I measurement 2
Fig. 17.64 Block parameters of the three-phase series RLC branch
546
17
Application of Simulink in Power Electronics

Fig. 17.65 Block parameters of the three-phase series RLC load
Fig. 17.66 Block parameters of the SVC (phasor type)
17.6
Modeling of Converters
547

Fig. 17.67 Block parameters of the bus selector
Fig. 17.68 The response of the SVC system observed from the scope window
548
17
Application of Simulink in Power Electronics

provided at the gate of the transistor. For buck converter, the relation between the
parameters can be written as follows:
Va ¼ k Vs
According to the formula above, for the desired voltage of 8 V from an input
voltage of 12 V, the duty cycle for the transistor should be:
k ¼ 8
12 ¼ 0:667 s
The following components are used to demonstrate the modeling of the buck
converter (Table 17.10). The circuit is then built as per Fig. 17.69.
Here, the DC voltage is 12 V, the inductor is 10 mH, the capacitor is 1 μF, and the
resistor is 50 Ω. In the pulse generator, the amplitude is set to be 1, with a pulse
period of
1
10000 s, as the switching frequency is considered to be 10,000 Hz. The pulse
width in percentage is the duty cycle, which is set as 66.67%, as calculated from the
value of k from the equation. After running the simulation for 0.05 s, the output
voltage is found out to be nearing 8 V, as shown in the graph below (Fig. 17.70).
As it is seen from the graph, the output is not exactly 8 V. It is because there are
some voltage drops in other switching components such as the MOSFET or diode.
For example, the output voltage drops due to a default forward voltage of 0.8 V in
the diode. To verify this, change the forward voltage of the diode from 0.8 V to a
minimum value (e.g., 0.1 V). It will be seen that the output voltage becomes closer to
8 V as there is a very little voltage drop across the diode.
Table 17.10 Blocks and navigation routes for designing buck converter
Name of the block
Navigation route
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks
DC Voltage
Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources
MOSFET
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Power Electronics
Diode
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Power Electronics
Pulse Generator
Simulink ! Sources
Series RLC
Branch
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Elements
Voltage
Measurement
Simscape ! Electrical ! Specialized Power Systems ! Control &
Measurements ! Measurements
Scope
Simulink ! Commonly Used Blocks
17.6
Modeling of Converters
549

17.6.1.2
Boost Converter
As the name suggests, a boost converter provides a higher DC voltage than the
source DC voltage. For an input voltage of Vs, which is to be boosted to an output
Fig. 17.69 Buck converter in Simulink
Fig. 17.70 The response of the buck converter observed from the scope window
550
17
Application of Simulink in Power Electronics

voltage of Va, with a pulse with duty cycle k at the gate of the transistor, the relation
is shown as:
Va ¼ 1  k
ð
Þ Vs
According to the formula above, for the desired voltage of 5 V from an input
voltage of 15 V, the duty cycle for the transistor should be:
k ¼ 1  5
15 ¼ 0:667 s
The same components that were used to design the buck converter are used in this
simulation as well. With these components, the circuit can be built as follows
(Fig. 17.71).
Here, the input DC voltage of 5 V is expected to be boosted into 15 V with an
amplitude of 1, pulse period of
1
10000 s, and pulse width of 66.67% at the pulse
generator. The value of the inductor is chosen to be 333 mH, the capacitor to be
10 μF, and the resistor to be 500 Ω. After running the simulation for 0.2 s, the output
voltage is found out to be nearing 15 V, as shown in the graph below. Similar to the
previous case, a small voltage drops across the diode, if minimized by reducing the
forward voltage, will help to increase the output voltage to 15 V (Fig. 17.72).
17.6.1.3
Buck-Boost Converter
Buck-boost converter changes the input DC voltage depending on the pulse width
(duty cycle) of the pulse. If the pulse is within 1–50%, the converter works as a buck
converter. If the pulse is within 51–100%, the converter works as a boost converter.
Fig. 17.71 Boost converter in Simulink
17.6
Modeling of Converters
551

A special characteristic of the buck-boost converter is that it reverses the polarity of
the output voltage. For a source voltage of Vs, the output voltage Va can be
represented with respect to the duty cycle k as follows:
Va ¼ Vs 
k
1  k
In this example, a source voltage of 10 V is considered. For demonstrating buck
operation, a pulse width of 25% and for demonstrating boost operation, a pulse width
of 75% are to be used. As per the formula, the output voltages will be:
For k ¼ 0.25,
Va ¼ 10V 
0:25
1  0:25 ¼ 3:33V
For k ¼ 0.75,
Fig. 17.72 The response of the boost converter observed from the scope window
552
17
Application of Simulink in Power Electronics

Va ¼ 10V 
0:75
1  0:75 ¼ 30V
The minus sign indicates that the output voltage will be in opposite direction with
respect to the input voltage.
The same components that were used to design the buck converter are used in this
simulation as well. With these components, the circuit is then built as per Fig. 17.73.
Here, an input DC voltage of 10 V is used as the input for the converter. A 10 mH
inductor, a 500 μF capacitor, and a 10 Ω resistor are used. Pulse with amplitude of
1, pulse period of
1
10, 000 s, is provided at the gate of the MOSFET, at ﬁrst with 25%
pulse width for an output voltage of 3.33 V (buck operation), and then with 75%
pulse width for an output voltage of 30 V (boost operation). After running the
simulation for 0.1 s, the output for both the pulse widths can be demonstrated as
follows (Figs. 17.74 and 17.75):
17.6.2
Model of DC-AC Converter
DC-AC converters are called inverters, as they change the incoming DC signal to a
ﬁxed or variable AC output signal. Inverters can either be voltage source or current
source, inverting either voltage or current, respectively. PWM signals are usually
utilized to vary the gain of the inverter to obtain an output signal of desired
magnitude or frequency. The ideal output waveform should be sinusoidal, but due
to harmonics (lower frequency components of the fundamental signal) or noise from
external or internal sources, it is not easy to obtain the pure sinusoidal output. For
this reason, there are different inverter schemes to minimize harmonics as much as
possible for nearing the sinusoidal waveform. In this subsection, the basic layout of
Fig. 17.73 Buck-boost converter in Simulink
17.6
Modeling of Converters
553

single-phase and three-phase inverters will be shown without diving deeper into
advanced architectures for simplicity.
17.6.2.1
Single-Phase Half-Wave Bridge Inverter
Single-phase half-wave inverter is a voltage source bridge inverter made with two
control devices, where one of the devices remains in on-state for half of the time
period and the other remains in on-state for another half of the time period. In the
setup shown in Fig. 17.76, two “IGBT/Diode” blocks have been used since the block
consists of both IGBT and an antiparallel diode. Two DC sources or three-wire DC
sources, or two capacitors, are additionally used in this setup. The other blocks that
are used in this setup are shown in the following Table 17.11.
A DC voltage source of 48 V is used, with two capacitors of value 100 mF each.
A small resistor of 1 Ω is connected in series with the DC voltage source, as
connecting a capacitor with a DC voltage source would initially short-circuit the
source. Load resistance of 5 Ω is considered for the circuit. Two pulses are provided
Fig. 17.74 The response of the buck operation observed from the scope window
554
17
Application of Simulink in Power Electronics

at the gates of two IGBTs, one directly connected and the other with a “NOT” logical
operator in the middle. The amplitude of the pulse generator is 12, with a period of
0.0167 s, a pulse width of 50%, and with no phase delay. While connecting the
circuit, the polarity of the measurement devices is to be matched because changing
their polarity may show the waveforms with the same magnitude and frequency but
in the opposite direction. The input DC voltage and the output waveforms of voltage
and current are shown in Fig. 17.77.
17.6.2.2
Single-Phase Full-Wave Inverter
Unlike a single-phase half-wave inverter, the full-wave inverter can be used with
two-wire DC voltage sources without the need for any capacitors. However, the
setup requires the use of four control devices with antiparallel diodes, with the gate
pulses in the particular order shown in Fig. 17.78. Using the same components as for
Fig. 17.75 The response of the boost operation observed from the scope window
17.6
Modeling of Converters
555

the half-wave inverter (except the capacitors), the conﬁguration is connected as
follows.
The voltage source is 48 V and the load resistance is 5 Ω for this setup. The
parameters for the pulse generator are kept similar to that of the half-wave inverter.
The input voltage, load voltage, and current are visible from the scope (Fig. 17.79).
Fig. 17.76 Simulink diagram of a Single-Phase Half-Wave Bridge Inverter
Table 17.11 Blocks and navigation routes for designing single-phase half-wave bridge inverter
Name of the block
Navigation route
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks
DC Voltage
Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources
IGBT/Diode
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Power Electronics
Pulse Generator
Simulink ! Sources
Logical Operator
Simulink ! Logic and Bit Operations
Series RLC
Branch
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Elements
Voltage
Measurement
Simscape ! Electrical ! Specialized Power Systems ! Control &
Measurements ! Measurements
Current
Measurement
Simscape ! Electrical ! Specialized Power Systems ! Control &
Measurements ! Measurements
Scope
Simulink ! Commonly Used Blocks
556
17
Application of Simulink in Power Electronics

17.6.2.3
Three-Phase Inverter
A three-phase inverter converts a DC voltage into a three-phase AC supply using six
control devices with six different pulses. Each arm of the inverter can be delayed
either for 120 or 180 to obtain the three-phase output. In the setup shown in
Fig. 17.80, 180 conduction mode is used where each of the control devices is
activated at an interval of 60. The list of components used in this simulation are as
follows (Table 17.12):
An input DC voltage of 48 V is provided, with a “Three-Phase Series RLC Load.”
The default parameters for the load are used in this example. The “IGBT/Diode” and
“Pulse Generator” blocks should be placed in the order as mentioned in the image.
Since each pulse will be at a 60 delay, a varying pulse width is provided in each
signal. For all six Pulse Generator blocks, the amplitude is set as 1, the period as 1
60 s
(as the frequency is considered to be 60 Hz), and the pulse wide as 50%. The phase
delay for each pulse is varied as follows:
For “Pulse Generator 1,” the phase delay is 0 
1
60
 

1
360


.
For “Pulse Generator 2,” the phase delay is 60 
1
60
 

1
360


:
For “Pulse Generator 3,” the phase delay is 120 
1
60
 

1
360


:
For “Pulse Generator 4,” the phase delay is 180 
1
60
 

1
360


:
Fig. 17.77 Input voltage, load voltage, and load current of Single-Phase Half-Wave Bridge
Inverter observed from the scope window
17.6
Modeling of Converters
557

For “Pulse Generator 5,” the phase delay is 240 
1
60
 

1
360


:
For “Pulse Generator 6,” the phase delay is 300 
1
60
 

1
360


:
Fig. 17.78 Simulink diagram of a Single-Phase Full-Wave Inverter
Fig. 17.79 Simulink diagram of a Single-Phase Full-Wave Inverter
558
17
Application of Simulink in Power Electronics

The line-to-phase voltage is measured for each arm using “Voltage Measure-
ment” block and “Scope.” It is seen from Fig. 17.81 that the voltages appear in three
levels as per the equivalent resistance of the Y (grounded) load. There are spikes
visible in the ﬁrst portion of the waves due to the internal parameters of diodes,
Fig. 17.80 Simulink diagram of a Three-Phase Inverter
Table 17.12 Blocks and navigation routes for designing three phase inverter
Name of the block
Navigation route
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks
DC Voltage Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources
IGBT/Diode
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Power Electronics
Pulse Generator
Simulink ! Sources
Three-Phase Series
RLC Load
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Elements
Voltage Measurement
Simscape ! Electrical ! Specialized Power Systems ! Control &
Measurements ! Measurements
Scope
Simulink ! Commonly Used Blocks
17.6
Modeling of Converters
559

which can be considered to be negligible for this example. Such inverters are vastly
used in high voltage applications and electrical machines in industries.
17.6.3
Model of AC-DC Converter
In previous sections, AC-DC conversion with uncontrolled rectiﬁers was demon-
strated. Control devices, such as thyristors and GTOs, were used to show the
characteristics of the devices by changing the ﬁring angle in the latter sections.
With the help of a similar setup from the previous subsection, the AC-DC converters
can be modeled for single-phase and three-phase full-wave AC signals to be
converted into DC voltage of desired nature. These AC-DC converters are used in
motor speed controls, designing uninterruptible power supplies, and charging energy
storage systems.
Fig. 17.81 Response of a Three-Phase Inverter observed from the scope window
560
17
Application of Simulink in Power Electronics

17.6.3.1
Single-Phase Full-Wave Converter
For designing a single-phase full-wave converter, four thyristors are required. The
Table 17.13 enlists the components used for designing the converter.
For this example, one pair of the thyristor is triggered at an angle of 45, whereas
the other pair of the thyristor is triggered at an angle of 225. An AC voltage source
with 110 V at 60 Hz is used, and an R load of 5 Ω resistor is selected as the load. The
model is constructed as shown in Fig. 17.82.
In each pulse generator, an amplitude of 1, a period of 1
60 s, and a pulse width of
5% are mentioned. The phase delay for each pulse generator is mentioned as follows:
For “Pulse Generator 1,” the phase delay is 45 
1
60
 

1
360


:
For “Pulse Generator 2,” the phase delay is 225 
1
60
 

1
360


.
It is seen from the output waveform that a controlled DC output voltage with the
same magnitude is obtained. Upon changing the triggering angle for the thyristors, it
is possible to vary the waveform as desired for the application (Fig. 17.83).
17.6.3.2
Three-Phase Full-Wave Converter
Similar to a single-phase converter, the three-phase converter converts a three-phase
AC input into a controlled DC output voltage, controlled by three pairs of thyristors.
For demonstrating such a converter, the same components as mentioned in the
single-phase full converter are utilized: three AC voltage sources with 220 V
60 Hz, with a phase of 0, 120, and 240, respectively. A 1 Ω R load is used to see
the output voltage across. In each “Pulse Generator,” the amplitude is selected to be
1, the period is selected to be 1
60 s as the system frequency is 60 Hz, and the pulse
width is selected to be 5%. The phase delay for each of the pulse generators is
mentioned below.
Table 17.13 Blocks and navigation routes for designing single-phase full-wave converter
Name of the block
Navigation route
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks
AC Voltage
Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources
Thyristor
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Power Electronics
Pulse Generator
Simulink ! Sources
Series RLC
Branch
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Elements
Voltage
Measurement
Simscape ! Electrical ! Specialized Power Systems ! Control &
Measurements ! Measurements
Scope
Simulink ! Commonly Used Blocks
17.6
Modeling of Converters
561

Fig. 17.82 Simulink diagram of a Single-Phase Full-Wave Converter
Fig. 17.83 Response of a Single-Phase Full-Wave Converter observed from the scope window
562
17
Application of Simulink in Power Electronics

For “Pulse Generator 1,” the phase delay is 45 
1
60
 

1
360


:
For “Pulse Generator 2,” the phase delay is 165 
1
60
 

1
360


:
For “Pulse Generator 3,” the phase delay is 285 
1
60
 

1
360


:
The circuit is set up as shown in Fig. 17.84.
After running the simulation for 0.0335 s, the output waveform is found out to be
as follows. The input three-phase voltage is summarized into a controlled DC output,
which can further be controlled by changing the phase delay in each pulse generator
(Fig. 17.85).
17.6.4
Model of AC-AC Converter
AC-AC converters convert the magnitude and frequency of an AC input voltage as
desired. Electrical transformers also serve the same purpose, which either “steps up”
or “steps down” an input AC voltage with the same frequency. The major difference
between a converter and a transformer lies in the method of AC conversion. In
converters, an input signal is disintegrated into the shape of the desired output, but in
the case of a transformer, the length of the input wave is modiﬁed without chopping
the input waveform. Moreover, converters can change the input frequency, whereas
transformers cannot change the frequency. Since transformer blocks can easily
change the voltage level depending on the turns ratio, this section discusses the
converter that changes the frequency of the input AC voltage. There are typically
Fig. 17.84 Simulink diagram of a Three-Phase Full-Wave Converter
17.6
Modeling of Converters
563

three types of cycloconverters, single-phase cycloconverter, three-phase to single-
phase cycloconverter, and three-phase to three-phase cycloconverter. Since the
structure of the three-phase cycloconverters can easily be understood using three
single-phase cycloconverters, only the formation of a single-phase cycloconverter is
discussed in this section.
17.6.4.1
Single-Phase Cycloconverter
Cycloconverters are AC-AC converters that convert AC signals of particular fre-
quency and voltage into a different frequency and voltage as required by the system.
Figure 17.86 shows a single-phase cycloconverter. The components that are used for
modeling the converter are tabulated as follows (Table 17.14):
In this system, the voltage of the AC voltage source is chosen to be 220 V 60 Hz.
Two sets of converters, called P-converter and N-converter, are combined in this
single-phase cycloconverter with four ideal switches. The left portion of the
cycloconverter consisting of thyristors 1–4 is called the P-converter, which provides
the positive half-cycles of the input waveform. The right portion of the
cycloconverter, consisting of thyristors 5–8, is called the N-converter, which
Fig. 17.85 Response of a Three-Phase Full-Wave Converter observed from the scope window
564
17
Application of Simulink in Power Electronics

provides the negative half-cycles of the input waveform. In this circuit, three pulse
generators are used: “Pulse Generator 1” provides a pulse to the P-converter, “Pulse
Generator 2” provides a pulse to the N-converter, and “Pulse Generator 3” and its
opposite pulse through the logical operator “NOT” are provided in the “Ideal Switch
1” to “Ideal Switch 4” as shown in the ﬁgure below.
Fig. 17.86 Simulink diagram of a Single-Phase Cycloconverter
Table 17.14 Blocks and navigation routes for modeling single-phase cycloconverter
Name of the block
Navigation route
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks
AC Voltage
Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources
Thyristor
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Power Electronics
Ideal Switch
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Power Electronics
Pulse Generator
Simulink ! Sources
Logical Operator
Simulink ! Commonly Used Blocks
Series RLC
Branch
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Elements
Voltage
Measurement
Simscape ! Electrical ! Specialized Power Systems ! Control &
Measurements ! Measurements
Scope
Simulink ! Commonly Used Blocks
17.6
Modeling of Converters
565

A resistor of 1 Ω is used as the load for this circuit. The powergui block has been
changed to “Discrete” with the default sample time. The parameters for the pulse
generators are given as follows:
For “Pulse Generator 1” and “Pulse Generator 2,” the amplitude is 1, the period is
0.00835 s, the pulse width is 50%, and the phase delay is 0.
For “Pulse Generator 3,” the amplitude is 1, the period is 0.0334, the pulse width is
50%, and the phase delay is 0.
The period in “Pulse Generator 3” is a multiple of 0.0167 since the source voltage
is 60 Hz. If the period is twice that of 0.0167 (0.0334, which is used in this example),
two positive half-cycles and two negative half-cycles will be generated as the output
waveform (as shown in Fig. 17.87). If the period is increased, the output waveform
would also have an increased number of positive and negative cycles.
17.7
Conclusion
Power electronics is one of the crucial aspects in the domain of electrical engineer-
ing, as it bridges the gap between low-power and high-power applications by
working as an interface. In this chapter, basic components of power electronics
such as diodes, bipolar junction transistors, MOSFETs, IGBTs, GTOs, and Op-amps
have been introduced, and their characteristics have been demonstrated using
Simulink. Intermediate concepts of power frame transformation and phase-locked
loop have been brieﬂy explained with examples so that the readers may work with
the advanced concepts of ﬂexible AC transmission systems. Modeling of DC-DC
converter and switching regulators, inverters, AC-DC converters, and AC-AC
cycloconverters with guided simulations will help the readers distinguish their
performances and choose the appropriate converter well-suited to the applications.
The chapter will work as a compendium of power electronics concepts and mathe-
matical examples to work on advanced topics in the domain.
Exercise 17
1. (a) Name some of the applications of diode.
(b) State the major differences between single-phase half- and single-phase full-
wave rectiﬁers.
(c) Design a single-phase full-wave rectiﬁer with (i) two diodes and (ii) four
diodes which will take a 220 V input and provide an output of 24 V.
(d) Replicate the three-phase full-wave rectiﬁer with (i) RL load and (ii) RC load.
Change the values of the inductor and capacitor from low to high. What are the
impacts of these variations on the output voltage and current?
2. (a) Deﬁne transistor. What is the difference between a diode and a transistor?
566
17
Application of Simulink in Power Electronics

(b) Demonstrate the BJT characteristics for (i) NPN transistor for a base voltage
of 0.004 V and (ii) PNP transistor for a base voltage of 0.004 V.
3. (a) Write down the formula for determining the output voltage of Op-amp
differentiator and integrator circuit from the circuital elements.
(b) Design an Op-amp-based inverter circuit with appropriate resistors to obtain a
voltage of 50 V from an input of 5 V.
(c) Design an Op-amp-based non-inverter circuit with appropriate resistors to
obtain a voltage of 70 V from an input of 7 V.
4. (a) What is the difference between uncontrolled and controlled rectiﬁcation?
(b) Perform controlled rectiﬁcation with (i) MOSFET with a ﬁring angle of 45
and 90, and (ii) GTO with ﬁring angle at 45 at pulse width 10%, and with a
ﬁring angle of 90 at pulse width 25%. Compare the waveforms for each case and
explain the device characteristics.
5. (a) Replicate the example of reference frame transformation shown in Sect.
17.5.1. Perform alpha-beta-zero to dq0 transformation using Simulink block
and verify the output from the result provided in the example.
Fig. 17.87 Response of a Single-Phase Cycloconverter observed from the scope window
Exercise 17
567

(b) Design a buck converter to obtain a regulated DC voltage of 5 V from a source
of 24 V.
(c) Design a boost converter to obtain a regulated voltage of 24 V from a source of
5 V. Use arbitrary circuital parameters.
6. (a) What are the major applications of AC-DC converters?
(b) Replicate the three-phase inverter model shown in Sect. 17.6.2.3. Change the
DC voltage to 24 V. Determine the phase-to-phase voltage of the system.
(c) Design a single-phase cycloconverter as created in Sect. 17.6.4, which pro-
duces the output voltage with the same waveform as follows.
568
17
Application of Simulink in Power Electronics

Chapter 18
Application of Simulink in Renewable
Energy Technology
18.1
Solar Photovoltaics
Solar energy is one of the most used renewable energy in power system applications.
The term “photovoltaics” originated from the combination of two terms—photon
and voltage. Solar photovoltaics converts solar lights, i.e., photons into electricity, or
in other terms—voltage. This phenomenon is named as “photovoltaic effect” and is
considered as the fundamental concept behind the recent progress of solar photo-
voltaics in the power domain. A single photovoltaic cell can generate a certain DC
voltage and current with limited power wattage. By combining multiple PV cells, a
PV array can be formed for usage in small- or medium-scale deployment. For
contributing to a large-scale power system, PV panels are used that can be formed
by combining multiple PV arrays.
18.1.1
Mathematical Model of PV Cell
To understand the mathematical model of a PV cell, ﬁrst consider the following
representation of a single solar cell circuit consisting of a current source, two
photodiodes, and resistors:
In the circuit of Fig. 18.1, the current of the current source is represented by Iph,
and the two diodes D1 and D2 are connected in parallel with the current source. The
parallel resistor is named as Rp, and series resistance is represented by Rs. The ﬁnal
output current from this solar cell is I, which can be represented by the following
mathematical equation:
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8_18
569

I ¼ Iph  Is  Id  1
ð
Þ  Is2  Id2  1
ð
Þ V þ I ∙Rs
RP
Here, Id ¼ e
VþI ∙Rs
N ∙Vt ; Id2 ¼ e
VþI ∙Rs
N2 ∙Vt and, Vt ¼ kT
q
The ﬁnal output power of the cell can be deﬁned by the following equation:
Power, P ¼ V  I
¼ V  Iph  Is 
e
VþI ∙Rs
N ∙Vt  1


 Is2 
e
VþI ∙Rs
N2 ∙Vt  1


 V þ I  Rs
RP


Here, Is represents the current ﬂowing through the ﬁrst parallel diode, D1;
Is2 indicates the current through diode D2; Vt represents the thermal voltage; k is
the Boltzmann constant; T is the temperature; q represents the charge of an electron;
N is the quality factor of D1; N2 is the quality factor of D2; and V refers to the output
voltage of the cell.
The mathematical model of the solar PV cell is modeled in the Simulink as
illustrated in Fig. 18.2. The PV and IV characteristic curves of the PV cell are
determined and plotted using the XY Graph blocks in the Simulink.
To understand the designed mathematical model, all the blocks that are utilized in
the design are summarized with their navigation routes in the Table 18.1. The
mathematical representation of each block based on their output is also enlisted in
the block for better comprehensibility.
In the simulation, multiple variables are used, which are provided in the simula-
tion using different blocks via parameter customization. The values of the parame-
ters that are considered for the example given in Fig. 18.2 are listed in the Table 18.2:
At the end, the characteristic curves are plotted by utilizing two XY Graph blocks,
which are customized from their parameter window for ﬁtting the curves within the
window with better visibility. The customization of these two blocks is shown in
Fig. 18.3. The output of the simulation, i.e., the two characteristic curves, is
illustrated in Fig. 18.4. In Fig. 18.4, the ﬁrst ﬁgure represents the PV characteristic
curve, while the second ﬁgure indicated the VI characteristic curve of the solar cell.
Fig. 18.1 Equivalent circuit of a PV cell
570
18
Application of Simulink in Renewable Energy Technology

18.1.2
PV Panel Design from Solar Cell
Before building a PV panel, it is important to learn about the solar cell. In the
previous section, the mathematical model of a single solar cell is demonstrated. The
same modeling can be done by utilizing the Solar Cell block, which can be
customized from its parameter window. By implementing the Solar Cell block, the
PV and VI characteristic curves are shown in the demonstration (Fig. 18.5). The
blocks that are utilized to design the model are summarized in the following table
with their navigation routes (Table 18.3).
The parameter window of the Solar Cell block is shown in Fig. 18.6, from where
the parameters of the solar cell can be customized. The deﬁning mathematical
equation of the Solar Cell block can be seen from the description of the parameter
window. In the parameter window, there are three settings—Cell Characteristics,
Conﬁguration, and Temperature Dependence. In each of these settings, multiple
parameters are available that can be customized. Under the Cell Characteristics
options, parameters such as short-circuit current, open-circuit voltage, irradiance,
quality factor, and series resistance can be conﬁgured manually to deﬁne the charac-
teristics of a particular solar cell. In the Conﬁguration setting, the number of cells in
series can be deﬁned. The last option of settings of the Solar Cell block called
Temperature Dependence has several customizable parameters, which is shown in
Fig. 18.7.
A PS Constant block is connected to the input port of the Solar Cell block. This
PS Constant block signiﬁes the irradiance value of the solar cell. From its parameter
window, the constant value is set as 1000 (Fig. 18.8), which refers that the irradiance
of the solar cell is 1000 W/m2.
Fig. 18.2 Simulink mathematical model of the solar PV cell
18.1
Solar Photovoltaics
571

Table 18.1 Mathematical representation, blocks, and navigation routes for representing the math-
ematical model for the PV cell
Mathematical representation
Block
name
Navigation route
V
Ramp
Simulink Library
Browser ! Simulink ! Sources ! Ramp
Rs
Constant
Simulink Library
Browser ! Simulink ! Sources ! Constant
k
Constant1
Simulink Library
Browser ! Simulink ! Sources ! Constant
T
Constant2
Simulink Library
Browser ! Simulink ! Sources ! Constant
q
Constant3
Simulink Library
Browser ! Simulink ! Sources ! Constant
1
Constant4
Simulink Library
Browser ! Simulink ! Sources ! Constant
Ipho
Constant5
Simulink Library
Browser ! Simulink ! Sources ! Constant
Ir=Iro
Constant6
Simulink Library
Browser ! Simulink ! Sources ! Constant
Is
Constant7
Simulink Library
Browser ! Simulink ! Sources ! Constant
Rp
Constant8
Simulink Library
Browser ! Simulink ! Sources ! Constant
I  Rs
Product
Simulink Library Browser ! Simulink ! Math
Operations ! Product
Vt ¼ kT
q
Product1
Simulink Library Browser ! Simulink ! Math
Operations ! Product
VþIRs
Rp
Product2
Simulink Library Browser ! Simulink ! Math
Operations ! Product
VþIRs
NVt
Product3
Simulink Library Browser ! Simulink ! Math
Operations ! Product
P
Product4
Simulink Library Browser ! Simulink ! Math
Operations ! Product
Is  (Id  1)
Product5
Simulink Library Browser ! Simulink ! Math
Operations ! Product
Id ¼ e
VþIRs
NVt
ð
Þ
Math
Function
Simulink Library Browser ! Simulink ! Math
Operations ! Math Function
V + I  Rs
Add
Simulink Library Browser ! Simulink ! Math
Operations ! Add
Id  1
Add1
Simulink Library Browser ! Simulink ! Math
Operations ! Add
I ¼ Iph  Is  Id  1
ð
Þ 
VþIRs
RP


Add2
Simulink Library Browser ! Simulink ! Math
Operations ! Add
N
Gain
Simulink Library Browser ! Simulink ! Math
Operations ! Gain
V-I Plot
XY
Graph
Simulink Library
Browser ! Simulink ! Sinks ! XY Graph
P-V Plot
XY
Graph1
Simulink Library
Browser ! Simulink ! Sinks ! XY Graph
572
18
Application of Simulink in Renewable Energy Technology

Table 18.2 Parameter values
considered for the example
Parameters
Considered value
Rs
0.1 ohms
k
1.38e-23 J/K
T
313 K
q
1.6e-19 C
Ipho
7.34 A
Ir/Iro
1
Is
16e-10 A
Rp
620 ohms
N
2.5
Fig. 18.3 Block parameters of the P-V plot and the V-I plot
Fig. 18.4 The P-V plot and the V-I plot
18.1
Solar Photovoltaics
573

Fig. 18.5 Simulink model of the solar PV cell
Table 18.3 Blocks and navigation path for PV panel design from solar cell
Blocks
Navigation path on the Simulink Library Browser
Solar Cell
Simscape ! Electrical ! Sources ! Solar Cell
PS Constant
Simscape ! Foundation Library ! Physical Signals ! Sources ! PS
Constant
Ramp
Simulink ! Sources ! Ramp
Variable Resistor
Simscape ! Foundation Library ! Electrical ! Electrical Ele-
ments ! Variable Resistor
PS-Simulink
Converter
Simscape ! Utilities ! PS-Simulink Converter
Simulink-PS
Converter
Simscape ! Utilitie ! Simulink-PS Converter
Product
Simulink ! Math Operations ! Product
Voltage Sensor
Simscape ! Foundation Library ! Electrical ! Electrical Sen-
sors ! Voltage Sensor
Current Sensor
Simscape ! Foundation Library ! Electrical ! Electrical Sen-
sors ! Current Sensor
XY Graph, XY
Graph1
Simulink ! Sinks ! XY Graph
Solver
Conﬁguration
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! powergui
574
18
Application of Simulink in Renewable Energy Technology

To complete the circuit, a Variable Resistor block is connected in series with the
Solar Cell block. The Variable Resistor block responds with the ramp signal
provided in the input port via the Ramp block. Both of these blocks are kept in
their default parameter mode for this example. A Current Sensor is connected in
series and a Voltage Sensor is connected in parallel to the variable resistor to
measure the current and voltage of the circuit. It is to be noted that Simulink-PS
Converter is used between the Ramp block and the Variable Resistor block, as these
two blocks belong to separate libraries. Both Current and Voltage Sensors are
physical systems; therefore, to display their results in a XY Graph block,
PS-Simulink Converters are utilized. The Product block is used to multiply the
voltage and current to determine the overall power of the solar cell. In the XY
Graph and XY Graph1 blocks, VI and PV characteristic plots can be seen after
simulating the model. The scaling of these XY Graph and XY Graph1 block is
altered from their respective parameter windows as shown in Fig. 18.9.
The output curves are illustrated in Fig. 18.10, where the ﬁrst curve represents the
PV characteristic curve and the second curve refers to the VI characteristic curve.
Fig. 18.6 Block parameters of the solar cell: cell characteristics
18.1
Solar Photovoltaics
575

Fig. 18.7 Block parameters of the solar cell: temperature dependence
Fig. 18.8 Block parameters of the PS constant
576
18
Application of Simulink in Renewable Energy Technology

18.1.3
PV Panel Design with PV Array
Instead of creating PV panels from the solar cells, it is more convenient to utilize PV
arrays, where different solar cells are connected in series and parallel conﬁgurations
to create a PV array. By utilizing multiple PV arrays, a PV panel can be designed. A
Simulink model is constructed in Fig. 18.11 to show the performance of a PV array
via its PV and VI characteristic curves. The navigation routes of the utilized blocks
in this example are listed in the Table 18.4:
The parameter window of the PV Array block is shown in Fig. 18.12, where
multiple parameters can be adjusted for speciﬁc PV Array module. In this block,
several module options are available under the Module dropdown box option. For
Fig. 18.9 Block parameters of the P-V plot and the V-I plot
Fig. 18.10 The P-V plot and the V-I plot
18.1
Solar Photovoltaics
577

this example, “SunPower SER-220P” module is selected. The number of parallel
strings and the series-connected modules per string are both set as 1. If the user does
not want to use any speciﬁc module from the dropdown list, and want to create a
completely new user-deﬁned module by customizing its parameters, it can be done
by selecting “User-deﬁned” option from the dropdown option list of the Module. It
will provide the users an opportunity to customize user-deﬁned modules by deﬁning
the parameters.
The PV Array block has two input parameters—Irradiance and Temperature.
These two values are provided to the PV Array block by using two Constant blocks.
The Constant block that is referring to the Irradiance value is customized by setting
Fig. 18.11 Simulink model of the PV array
Table 18.4 Blocks and navigation path for PV panel design with PV array
Blocks
Navigation path on the Simulink Library Browser
PV Array
Simscape ! Electrical ! Specialized Power Systems ! Renew-
ables ! Solar ! PV Array
Constant, Constant1
Simulink ! Sources ! Constant
Controlled Voltage
Source
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! Electrical Sources ! Controlled Voltage Source
Ramp
Simulink ! Sources ! Ramp
Bus Selector
Simulink ! Signal Routing ! Bus Selector
Product
Simulink ! Math Operations ! Product
XY Graph, XY
Graph1
Simulink ! Sinks ! XY Graph
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! powergui
578
18
Application of Simulink in Renewable Energy Technology

the constant value 1000. In the same manner, the temperature is provided by the
Constant1 block by assigning the constant value 25. Both of these customizations are
shown in the Fig. 18.13:
With the PV Array block, a Controlled Voltage Source is connected in series,
which is controlled by a source block Ramp. The Source type of the Controlled
Voltage Source is selected as AC, and all other values of different parameters are
assigned to zero (Fig. 18.14).
The output port of the PV Array is connected to the Bus Selector block. After
connecting the block, double-click on the Bus Selector block, which will create the
appearance of the window shown in Fig. 18.15. In this parameter window, the right
box named Signals in the bus corresponds to the available output signals of the PV
Array. The left box named Selected Signals represents the signals that are selected to
appear from the output ports of the Bus Selector block. To shift any signal from the
right box to the left box, ﬁrst select a speciﬁc signal from the right box, and click on
the “Select” option, which will shift the selected signal to the left box. In this same
Fig. 18.12 Block parameters of the PV array
Fig. 18.13 Block parameters of the irradiance and the temperature
18.1
Solar Photovoltaics
579

Fig. 18.14 Block
parameters of the controlled
voltage source
Fig. 18.15 Block parameters of the bus selector
580
18
Application of Simulink in Renewable Energy Technology

manner, V_PV and I_PV signals are selected to shift to the left box. After clicking
the Apply button, it can be observed that the Bus Selector has two output ports, as
two signals are selected and shifted into the left box. One of the signals represents the
voltage and the other represents the current of the PV Array.
A Product block is used to calculate the power from the voltage and current
values of the PV Array circuit. Two XY Graph blocks are utilized to produce the
characteristic curves of both PV and VI. The scaling of these two curves in the XY
Graphs is customized from their respective parameter window as shown in
Fig. 18.16. The output curves can be observed from Fig. 18.17, which are similar
to the standard PV and VI characteristic curves of a solar system.
18.1.4
Case Study: Grid-Connected PV Array
An example is provided in Fig. 18.18, where a PV panel is utilized to generate
electricity and connected with a utility grid system. The output voltage of a PV array
is DC; hence, before connecting it to a grid system, it is mandatory to convert the DC
voltage into three-phase AC voltage. For doing this, the ﬁrst basic step is to boost the
voltage level of the PV array using a DC-DC Boost Converter. In this example for
simplicity, the Boost circuit is avoided. Instead, the number of PV array in series and
parallel strings is increased to get comparatively higher voltage from the PV panel. A
three-phase inverter is also necessary to convert the DC voltage into a three-phase
AC voltage. Finally, the obtained three-phase AC voltage is connected with the grid
to complete the design. Therefore, the entire design can be classiﬁed into three
Fig. 18.16 Block parameters of the P-V plot and the V-I plot
18.1
Solar Photovoltaics
581

parts—PV panel, three-phase inverter, and grid design—which are separated by
using three different Area boxes in the design shown in Fig. 18.18 for the sake of
better comprehensibility.
Before explaining the customization of each block, a list of all the blocks with
their navigation routes for this design is shown in the Table 18.5:
The PV panel design of this case study can be found in the ﬁrst area block, which
is named accordingly. The core component of this area block is the PV Array. The
parameter window of this block is shown in Fig. 18.19. The “SunPower SER-220P”
PV Array module is chosen for this simulation. The number of parallel strings is set
as 5 and the number of series-connected modules per string is assigned to 30. The PV
Array has two input ports—Irradiance and Temperature. By using two Constant
blocks, these two inputs are provided numerically. The value of the irradiance is
Fig. 18.17 The P-V plot and the V-I plot
Fig. 18.18 Simulink model of a Grid-Connected PV Array
582
18
Application of Simulink in Renewable Energy Technology

provided to be 1000 W/m2, while the temperature value is set as 25
C. With the
positive and negative output port of the PV array, a Series RLC Branch conﬁgured
for 10 ohm resistance only is connected. With the mechanical output port of the PV
Array, a Bus Selector is connected. The parameter window of the Bus Selector is
given in Fig. 18.20, where the left box indicated the available output signals and the
right-side box incorporates the selected signal. For this example, only the voltage is
the point of interest; hence, the V_PV signal is selected to be shifted on the right side.
From the Display block, the generated DC output voltage from the PV panel can be
observed, which is 270.6 V.
Table 18.5 Blocks and navigation path for the designed grid-connected PV array
Blocks
Navigation path on the Simulink Library
Browser
PV Array
Simscape ! Electrical ! Specialized Power
Systems ! Renewables ! Solar ! PV Array
Constant, Constant1
Simulink ! Sources ! Constant
Bus Selector
Simulink ! Signal Routing ! Bus Selector
Universal Bridge
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Power
Electronics ! Universal Bridge
PWM Generator (Two Level)
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Power
Electronics ! Pulse & Signal Generators
Three-Phase Series RLC Branch, Three-Phase
Series RLC Branch1
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Ele-
ments ! Three-Phase Series RLC Branch
Three-Phase V-I Measurements, Three-Phase
V-I Measurements1, Three-Phase V-I
Measurements2
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Measure-
ments ! Three-Phase V-I Measurements
Three-Phase PI Section Line, Three-Phase PI
Section Line1
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Elements
! Three-Phase PI Section Line
Three-Phase Transformer (Two Windings),
Three-Phase Transformer (Two Windings)1,
Three-Phase Transformer (Two Windings)1
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Elements
! Three-Phase Transformer (Two Windings)
Three-Phase Series RLC Load, Three-Phase
Series RLC Load1
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Elements
! Three-Phase Series RLC Load
Three-Phase Source
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Electrical
Sources ! Three-Phase Source
RMS Measurement
Simscape ! Electrical ! Control !
Measurement
Ground
Simulink ! Sources ! Ground
Scope, Scope1, Scope2
Simulink ! Sinks ! Scope
Display, Display1, Display2
Simulink ! Sinks ! Display
powergui
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! powergui
18.1
Solar Photovoltaics
583

The next step of the design is the three-phase inverter, which is marked by the
second area block. To design a three-phase inverter, a Universal Bridge block is
utilized. The parameter window of this block is given in Fig. 18.21. The ﬁrst step of
customizing this block is to assign the number of bridge arms to be 3 and to select the
type of power electronic device as IGBT/Diodes. Later the other parameters such as
the Snubber resistance and capacitance can be conﬁgured as shown in the ﬁgure
below:
Fig. 18.19 Block parameters of the PV array
Fig. 18.20 Block parameters of the bus selector
584
18
Application of Simulink in Renewable Energy Technology

The two output DC voltage terminals of the PV panel are connected with the
positive and negative terminals of the Universal Bridge. The output of this block is
the three terminals that represent the three phases. The Universal block requires a
gate signal, which is provided by a PWM Generator (two-Level) block. The cus-
tomization of the PWM Generator (two-Level) block is shown in Fig. 18.22.
To ﬁlter the harmonics of the output of the inverter, an LC ﬁlter requires to be
used. For doing so, two Three-Phase Series RLC Branch blocks are utilized. The ﬁrst
RLC Branch is conﬁgured for inductance only, with a value of 30 mH, while the
second RLC Branch is conﬁgured for capacitance only with a value of 100 uF. The
parameter window of these two blocks is shown below (Fig. 18.23):
After this LC ﬁlter, a Three-Phase V-I Measurement block is utilized to represent
as a Bus3 of RMS voltage 240 V. The phase-to-neutral voltages of the three phases
can be observed from the Scope window connected with this Bus. The parameter
window of the Three-Phase V-I Measurement block is shown in Fig. 18.24. An RMS
Measurement block is connected with the Three-Phase V-I Measurement block to
display the RMS voltage value of the phase-to-ground voltages of three phases,
which appear to be 249.5 V for each phase.
Fig. 18.21 Block
parameters of the universal
bridge
18.1
Solar Photovoltaics
585

The three-phase terminals of the AC voltage are connected with a subsystem
named Grid. This subsystem incorporates the design of a Utility Grid. By double-
clicking on the Subsystem, the original design of the Grid will appear in another
subwindow. The overall design of this Grid is shown in the Fig. 18.25:
The Grid contains a Three-Phase Transformer (Two Windings) at the beginning,
which is conﬁgured as a step-up transformer of 240 V/11 kV voltage. The nominal
power of the transformer is set as 250 MVA. The ﬁrst winding of the transformer is
set to be connected in “Yg,” while the other is assigned to be in the “Delta(D1)”
connection. The parameter window of the Three-Phase Transformer (Two Wind-
ings) is shown in the Fig. 18.26:
Fig. 18.22 Block parameters of the PWM generator (2-level)
Fig. 18.23 Block parameters of the three-phase series RLC branch
586
18
Application of Simulink in Renewable Energy Technology

Two Three-Phase PI Section Line blocks customized to be of 10 km lines are
connected with a Three-Phase V-I Measurement block in the middle. These two
blocks are used to represent the transmission line of a grid system. The customized
windows of these two blocks are illustrated in Fig. 18.27, and the parameter window
of the Three-Phase V-I Measurement block is shown in Fig. 18.28.
A Scope is connected with the Three-Phase V-I Measurement block to observe
the phase-to-ground three-phase voltages at this stage. The observed output voltages
from the Scope1 window are shown in the Fig. 18.29:
Fig. 18.24 Block parameters of the three-phase V-I measurement
Fig. 18.25 Overall Simulink design of the grid
18.1
Solar Photovoltaics
587

Before Bus2 of the design that is conﬁgured by the Three-Phase V-I Measure-
ment2 Block, a load of 10 kW is connected. For representing the load, a Three-Phase
Series RLC Load block is utilized. The customized parameter window of this block
can be found in Fig. 18.30.
Fig. 18.26 Block parameters of the three-phase transformer
Fig. 18.27 Block parameters of the three-phase PI section
588
18
Application of Simulink in Renewable Energy Technology

Fig. 18.28 Block parameters of the three-phase V-I measurement 2
Fig. 18.29 The output voltages observed from the scope window
18.1
Solar Photovoltaics
589

After the second bus of 11 kV, a Grounding Transformer block is connected with
a resistance of 3.5 ohms. The parameter window of this Grounding Transformer
block is shown in Fig. 18.31. A load of 25 MW is also connected here, which is
represented by using the Three-Phase Series Load1 block. The parameter window of
this block can be seen in Fig. 18.32.
A step-up transformer of 11 kV/269 kV is connected right after that to step up the
voltages of the three phases. The Three-Phase Transformer (Two Windings)1 is
customized on this account as follows (Fig. 18.33):
A Three-Phase V-I Measurement block is connected to observe the phase-to-
ground voltage at this stage, which can be observed from the Scope2 window. It is
also conﬁgured to represent Bus1. The customization of this block can be found in
Fig. 18.34. The voltages of the three phases observed from the Scope2 window are
shown in Fig. 18.35.
Finally, a Three-Phase AC Source of 2500 MVA and 269 kV RMS voltage is
connected to complete the grid design. The customized parameter window of this
block is presented in Fig. 18.36. With this, the entire design of a grid-connected PV
panel model is completed to simulate.
Fig. 18.30 Block parameters of the three-phase parallel RLC load
590
18
Application of Simulink in Renewable Energy Technology

18.2
Wind Turbine
Wind turbine is used to generate electricity by converting the kinetic energy devel-
oped from wind speed into electric energy. Similar to solar energy, the kinetic energy
of the wind speed is signiﬁcantly used as a renewable source for generating elec-
tricity. With the advent of modern technologies, the capacity of wind turbine-based
generators has signiﬁcantly increased. In Simulink, a wind turbine-based generator
can be designed and modeled to explore its characteristics as well as to realize its
implications in the power system domain. In this section, Wind Turbine Doubly-Fed
Induction Generator (DFIG) will be utilized to explain the applications of the wind
turbine in the power system domain.
Fig. 18.31 Block parameters of the grounding transformer
18.2
Wind Turbine
591

Fig. 18.32 Block parameters of the three-phase parallel RLC load 2
Fig. 18.33 Block parameters of the three-phase transformer (2 windings)
592
18
Application of Simulink in Renewable Energy Technology

Fig. 18.34 Block parameters of the three-phase V-I measurement
Fig. 18.35 The voltages of the three phases observed from the scope window
18.2
Wind Turbine
593

18.2.1
Model Wind Turbine-Based Generator in Simulink
In Simulink, Wind Turbine Doubly-Fed Induction Generator (Phasor Type) block is
available that can be utilized to simulate a wind turbine-based model. A Simulink
example is provided in Fig. 18.37, where a Three-Phase Source is connected with the
Wind Turbine Doubly-Fed Generator with a given wind speed and trip logic. The
utilized blocks on this Simulink design are given below with their respective
navigation routes (Table 18.6):
The different customizable features of the parameter window of the Wind Turbine
Doubly-Fed Induction Generator (Phasor Type) block are shown in Figs. 18.38,
18.39, 18.40, 18.41, and 18.42. In Fig. 18.38, the parameters that correspond to the
generator data are shown, e.g., the nominal power, line-to-line voltage, stator and
rotor impedances based on the ratings of the generator, etc. For this particular
example, speciﬁcations of these parameters can be observed from this ﬁgure.
In Fig. 18.39, the parameters representing the Turbine data are shown, such as the
mechanical output power of the wind turbine, tracking speeds, wind speed, etc. The
assigned values of these parameters for this speciﬁc example are illustrated in the
following ﬁgure:
Fig. 18.36 Block parameters of the three-phase source
594
18
Application of Simulink in Renewable Energy Technology

Based on the speciﬁcation, the power characteristic curve of the wind turbine can
be observed by clicking on the option named “Display wind turbine power charac-
teristics” (Fig. 18.39), which will create the appearance of the following ﬁgure:
In Fig. 18.40, the output powers of the turbine are plotted against different turbine
speeds. It can be observed from the graph that, up to point A, the turbine does not
produce any output power. When the turbine speed exceeds 0.7 m/s, the output
power of the turbine starts to increase gradually. After point D, the output power
becomes almost stable.
The parameters that affect the converters can be customized from the Converters
tab of the parameter window shown in Fig. 18.41. The speciﬁed values for such
parameters for this example can be found from the following ﬁgure:
Fig. 18.37 Wind Turbine-based Generator in Simulink
Table 18.6 Blocks and navigation path for modeling wind turbine-based generator
Blocks
Navigation path on the Simulink Library Browser
Wind Turbine Doubly-Fed Induction
Generator (Phasor Type)
Simscape ! Electrical ! Specialized Power Systems !
Renewables ! Wind Generation ! Wind Turbine
Doubly-Fed Induction Generator (Phasor Type)
Three-Phase Source
Simscape ! Electrical ! Specialized Power Systems !
Fundamental Blocks ! Electrical Sources ! Three-
Phase Source
Step
Simulink ! Sources ! Step
Constant
Simulink ! Sources ! Constant
Bus Selector
Simulink ! Signal Routing ! Bus Selector
Rate Limiter
Simulink ! Discontinuities ! Rate Limiter
Scope, Scope1
Simulink ! Sinks ! Scope
powergui
Simscape ! Electrical ! Specialized Power Systems !
Fundamental Blocks ! powergui
18.2
Wind Turbine
595

The last tab of the parameter window of the Wind Turbine Doubly-Fed Induction
Generator block is the Control tab (Fig. 18.42). From here, the mode of the control
can be selected from two options—Voltage regulation or Var regulation. For this
example, Voltage regulation mode is selected. Apart from this, several control
parameters are available in this tab, which can be customized according to the
user’s preference. To know more about details regarding the different parameters,
click on the Help button right below the parameter window.
Fig. 18.38 Block parameters of the Wind Turbine Doubly-Fed Induction Generator: Generator
Fig. 18.39 Block parameters of the Wind Turbine Doubly-Fed Induction Generator: Turbine
596
18
Application of Simulink in Renewable Energy Technology

Fig. 18.40 Turbine power characteristics
Fig. 18.41 Block parameters of the Wind Turbine Doubly-Fed Induction Generator: Converter
18.2
Wind Turbine
597

The Wind Turbine Doubly-Fed Induction Generator (Phasor Type) has inputs
named wind and trip. The wind takes wind speed as an input, while the trip takes any
logical inputs. The wind speed is provided by utilizing two blocks—Step and Rate
Limiter. The Step block creates a step response, whose initial and ﬁnal values are
deﬁned as 6 and 16 with a stepping time of 4. As the wind speed is not constant or
does not have a gradual increase or decrease properties, a Rate Limiter block is used
to closely match with the nature of the wind speed. The customization of both of
these blocks is shown in Fig. 18.43.
The Wind Turbine Doubly-Fed Induction Generator (Phasor Type) is connected
with a Three-Phase Source, which is customized in the following manner from its
parameter window (Fig. 18.44):
Finally, a Bus Selector is utilized to list all the output parameters of the Wind
Turbine Doubly-Fed Generator and to select certain signals to be observed in the
Scope window. After connecting the Bus Selector with the output port, double-click
on the Bus Selector block, which will create the appearance of the parameter window
as shown in Fig. 18.45. In the parameter window, the left box lists all the available
output signals. To select any of these signals, click on a particular signal name and
choose the “Select” option by clicking on it. The selected signal will be shifted to the
right box. Repeat the same procedure to select multiple signals from the left box.
Fig. 18.42 Block parameters of the Wind Turbine Doubly-Fed Induction Generator: Control
598
18
Application of Simulink in Renewable Energy Technology

Fig. 18.43 Block parameters of the rate limiter and the step block
Fig. 18.44 Block
parameters of the three-
phase source
18.2
Wind Turbine
599

Based on the number of signals selected to be on the right box, the number of output
ports of the Bus Selector will be decided. For this example, ﬁve signals are made to
be shifted to the right side, which automatically creates the appearance of ﬁve output
ports of the Bus Selector block. Two separate Scope blocks are connected with the
output signals to observe the graphs. The selected output signals can be observed
from the Scope windows as shown in Figs. 18.46 and 18.47.
18.2.2
Case Study: Grid-Connected Wind Turbine Generator
In this section, a case study of a grid-connected wind turbine generator is demon-
strated using a Simulink design. To design the complete model, the Simulink blocks
that are utilized are summarized below with their navigation routes (Table 18.7):
The complete Simulink design of this case study is illustrated in Fig. 18.48, where
a Wind Turbine Doubly-Fed Induction Generator is connected with a grid system.
To design the grid, a Three-Phase Programmable Voltage Source is used at the
beginning to represent a source of 230 kV voltage. The customization of this block
Fig. 18.45 Block parameters of the bus selector
600
18
Application of Simulink in Renewable Energy Technology

from its parameter window is shown in Fig. 18.49. In the parameter window, the
amplitude of the phase-to-phase RMS voltage is assigned 230 kV with a frequency
of 60 Hz.
With the Three-Phase Programmable Voltage Source, a Three-Phase Mutual
Inductance Z1-Z0 block is connected in series, which is conﬁgured to be of
2500 MVA. The ratio of self and mutual reactance, X0/X1, is kept as a ratio of 2:1
for this instance. The parameter window of this block is demonstrated in the
Fig. 18.50:
Fig. 18.46 The selected output signals observed from the Scope window
18.2
Wind Turbine
601

Afterward, a Three-Phase V-I Measurement block is utilized to act as Bus1. The
format of the block is changed in this example, by right-clicking on the block and
selecting Format ! Background Color ! Black. The customization of parameters
of this block is shown below, where the measurements are checked as a label
(Fig. 18.51).
The Bus1 that was deﬁned previously by utilizing a Three-Phase Transformer is a
230 kV bus line. A step-up transformer is utilized to step up the voltage from 230 kV
to 33 kV. The reason for doing so is to minimize the losses while transferring
Fig. 18.47 The selected output signals observed from the Scope window
602
18
Application of Simulink in Renewable Energy Technology

electricity over a large distance by minimizing the current. As a step-up transformer,
the Three-Phase Transformer (Two Windings) is utilized. For the ﬁrst winding “Yg”
connection and for the second winding “Delta(D1)” connection are conﬁgured for
the transformer block. The 230 kV/33 kV conﬁguration is set up from its Parameters
option by updating the phase-to-phase RMS voltages of the two windings as shown
in Fig. 18.52. The nominal power of the transformer is set as 250 MVA for this
example.
Before introducing the transmission line, a Three-Phase Transformer (Two
Windings) block is used to perform as a grounding transformer. Hence, the conﬁg-
uration of the ﬁrst winding is set as “Yn,” while for the second winding, the “Delta
Table 18.7 Blocks and navigation path for modeling grid-connected wind turbine generator
Blocks
Navigation path on the Simulink Library
Browser
Wind Turbine Doubly-Fed Induction Generator
(Phasor Type)
Simscape ! Electrical ! Specialized Power
Systems ! Renewables ! Wind Generation
! Wind Turbine Doubly-Fed Induction Gen-
erator (Phasor Type)
Three-Phase Programmable Voltage Source
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Electrical
Sources ! Three-Phase Programmable Volt-
age Source
Three-Phase Mutual Inductance Z1-Z0
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Elements
! Three-Phase Mutual Inductance Z1-Z0
Three-Phase V-I Measurements, Three-Phase
V-I Measurements1, Three-Phase V-I
Measurements2
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Measure-
ments ! Three-Phase V-I Measurements
Three-Phase PI Section Line, Three-Phase PI
Section Line1
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Elements
! Three-Phase PI Section Line
Three-Phase Transformer (Two Windings),
Three-Phase Transformer (Two Windings)1,
Three-Phase Transformer (Two Windings)2
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Elements
! Three-Phase Transformer (Two Windings)
Three-Phase Series RLC Load
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Elements
! Three-Phase Series RLC Load
Series RLC Branch
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! Elements
! Series RLC Branch
Step
Simulink ! Sources ! Step
Constant
Simulink ! Sources ! Constant
Bus Selector
Simulink ! Signal Routing ! Bus Selector
Rate Limiter
Simulink ! Discontinuities ! Rate Limiter
Scope, Scope1
Simulink ! Sinks ! Scope
powergui
Simscape ! Electrical ! Specialized Power
Systems ! Fundamental Blocks ! powergui
18.2
Wind Turbine
603

(D11)” connection is assigned. The nominal power of this transformer is set as
150 MVA. Both the magnetization resistance and inductance of this transformer are
set as 500 per unit. The neutral port of the transformer is made grounded through a
series-connected Series RLC Branch block, which is conﬁgured for 3.5 ohms
resistance only. The customization of the 150 MVA grounding transformer is
shown in the Fig. 18.53:
Two Three-Phase PI Section Line blocks are used to act as the transmission line
linked with Bus2 in the middle. The Bus2 is modeled by using a formatted Three-
Phase V-I Measurement block by following the same procedure as shown during the
Fig. 18.48 Simulink diagram of a Grid Connected Wind Turbine Generator
Fig. 18.49 Block parameters of the three-phase programmable voltage source
604
18
Application of Simulink in Renewable Energy Technology

formation of Bus1. The Three-Phase PI Section lines are conﬁgured for 10 km
distance of lines. The parameter windows of both these line blocks are demonstrated
in the Fig. 18.54:
The customization of the Three-Phase V-I Measurement2 block (Bus2) is shown
in the left ﬁgure of Fig. 18.55. In this grid network, another 480 V bus line named
Bus3 is modeled in the same manner. The conﬁgured parameter window of this Bus3
can be found on the right ﬁgure of Fig. 18.56, where the block is named Three-Phase
V-I Measurement1.
Before the Bus3, the voltage of the 33 kV bus line is made to be stepped down by
utilizing a step-down transformer to make the 33 kV/480 V conversion. A Three-
Phase Transformer (Two Windings) is utilized on this account, and the customiza-
tion of this block is shown in the following ﬁgure:
A 300 kW load is connected with the 480 V line, which is made by using the
Three-Phase Series RLC Load. The active power of this block is set as 300 kW, and
the nominal phase-to-phase RMS voltage is assigned as 480 V from its parameter
window (Fig. 18.57).
With Bus3, ﬁnally, the Wind Turbine Doubly-Fed Induction Generator block is
connected. As shown in Sect. 18.4.1, the Wind Turbine DFIG block requires wind
speed and trip values as inputs. Therefore, a Step block is conﬁgured to act as the
wind speed input of the Wind Turbine DFIG block with the association of the Rate
Limiter block connected in series. For providing the trip input, a Constant block set
as zero value is connected to perform as a logical zero input. The parameter windows
of the Step and the Rate Limiter blocks are shown in Fig. 18.58.
Fig. 18.50 Block parameters of the three-phase mutual inductance
18.2
Wind Turbine
605

Fig. 18.52 Block parameters of the three-phase transformer
Fig. 18.51 Block parameters of the three-phase V-I measurement
606
18
Application of Simulink in Renewable Energy Technology

With the output port of the Wind Turbine DFIG block, the Bus Selector block is
connected to select the output signals that will be shown in the Scope window. The
parameter window of the Bus Selector is shown in Fig. 18.59, where several output
signals that can be observed and set as outputs can be seen from the left box. Out of
these signals, three are chosen for this particular setup—Vdc (V), wr (pu),
Fig. 18.53 Block parameters of the three-phase transformer 2
Fig. 18.54 Block parameters of the three-phase PI section line
18.2
Wind Turbine
607

pitch_angle (deg). After selecting these three output signals from the Bus Selector,
the number of output ports of this block is automatically conﬁgured as 3. A Scope
block whose number of input ports is conﬁgured as 3 is connected with the three
output ports of the Bus Selector.
Fig. 18.55 Block parameters of the three-phase V-I measurement 2
Fig. 18.56 Block parameters of the three-phase transformer
608
18
Application of Simulink in Renewable Energy Technology

Fig. 18.57 Block parameters of the three-phase series RLC load
Fig. 18.58 Block parameters of the step and the rate limiter
18.2
Wind Turbine
609

After running the simulation, the output signals can be observed from the Scope
window as shown in Fig. 18.60. Simulink provides the user ﬂexibility to simulate the
model for different output signals to observe and analyze in the Scope window as
shown in this example.
18.3
Hydraulic Turbine
Hydraulic Turbine and Governor is a core component of a hydro-power-based
electricity generator. In such a system, the energy of moving water is utilized to
turn the blade of a hydro turbine. The spin of that rotating turbine, in other words, the
mechanical energy, is converted into electrical energy. This is the basic principle of a
hydraulic turbine-based power generator. In this section, a Hydraulic Turbine and
Governor will be utilized to run a synchronous generator to produce electricity by
utilizing the Simulink platform.
Fig. 18.59 Block parameters of the bus selector
610
18
Application of Simulink in Renewable Energy Technology

18.3.1
Case Study: Hydro Turbine and Power Generator
Model in Simulink
In this section, a Hydraulic Turbine and Governor block is utilized to power a
synchronous generator with the assistance of an Excitation System. The overall
design will be explained later with the necessary illustrations. The navigation routes
of all the blocks that are used in this simulation are listed in the Table 18.8:
In Fig. 18.61, a Simulink design demonstrating the application of hydraulic
turbines by powering up a synchronous generator is shown. In this design, the
Hydraulic Turbine and Governor block is the core component and is customized
from its parameter window. The parameter window of this block is shown in
Fig. 18.60 The output signals observed from the scope window
18.3
Hydraulic Turbine
611

Table 18.8 Blocks and navigation path for modeling hydro turbine and power generator
Blocks
Navigation path on the Simulink Library Browser
Hydraulic Turbine and Governor
Simscape ! Electrical ! Specialized Power Systems !
Fundamental Blocks ! Machines ! Hydraulic Turbine
and Governor
Excitation System
Simscape ! Electrical ! Specialized Power Systems !
Fundamental Blocks ! Machines ! Excitation System
Synchronous Machine pu Standard
Simscape ! Electrical ! Specialized Power Systems !
Fundamental Blocks ! Machines ! Synchronous
Machine pu Standard
Three-Phase Transformer (Two
Windings)
Simscape ! Electrical ! Specialized Power Systems !
Fundamental Blocks ! Elements ! Three-Phase
Transformer (Two Windings)
Three-Phase Source
Simscape ! Electrical ! Specialized Power Systems !
Fundamental Blocks ! Electrical Sources ! Three-
Phase Source
Three-Phase Series RLC Load,
Three-Phase Series RLC Load1
Simscape ! Electrical ! Specialized Power Systems !
Fundamental Blocks ! Elements ! Three-Phase Series
RLC Load
Constant, Constant1, Constant2
Simulink ! Sources ! Constant
Bus Selector
Simulink ! Signal Routing ! Bus Selector
Ground
Simulink ! Sources ! Ground
Scope
Simulink ! Sinks ! Scope
powergui
Simscape ! Electrical ! Specialized Power Systems !
Fundamental Blocks ! powergui
Fig. 18.61 Hydro Turbine and Power Generator Model in Simulink
612
18
Application of Simulink in Renewable Energy Technology

Fig. 18.62. There are several customizable parameters for this block, such as gain
and time constant of the servo-motor, gate opening limits, etc. To learn about these
parameters, click on the Help button of its parameter window. The Hydraulic
Turbine and Governor block has ﬁve input ports—reference speed (wref), reference
mechanical power (pref), actual speed of the machine (we), actual electrical power
(Pe0), and speed deviation (dw). It is to be noted that all the inputs need to be
provided in their respective per unit values.
An Excitation System block is required to provide the ﬁeld voltage to the
Synchronous Machine. The output port of the Excitation System block is the ﬁeld
voltage (Vf), in the per unit value. The output stator voltages Vd and Vq of the
Synchronous Machine are the two inputs of the Excitation System. The reference
voltage of the Excitation System is set as 1 by using a Constant block. The voltage
stabilizer input of the Excitation System is made grounded in this example. The
customized parameter window of this block is illustrated in Fig. 18.63.
Fig. 18.62 Block parameters of the hydraulic turbine and governor
18.3
Hydraulic Turbine
613

The parameter window of the Synchronous Machine is provided in Figs. 18.64,
18.65, and 18.66. From this parameter window, the model of the Synchronous
Machine can be selected from a list of preset models. In this example, no present
model is selected. The nature of the mechanical input that is selected in this example
is the mechanical power (Pm), which is provided via the Hydraulic Turbine and
Governor block. The selected rotor type of the Synchronous Machine is the Salient-
Pole type for this instance. After customizing the conﬁguration of the Synchronous
Machine (Fig. 18.64), go to the Parameters tab of its parameter window.
Fig. 18.63 Block parameters of the excitation system
614
18
Application of Simulink in Renewable Energy Technology

Fig. 18.64 Block parameters of the synchronous machine pu standard: Conﬁguration
Fig. 18.65 Block parameters of the synchronous machine pu standard: Parameters
18.3
Hydraulic Turbine
615

In Fig. 18.65, the customization of the parameters under the Parameters tab is
shown. The nominal power of the Synchronous Machine is set as 300 MVA with the
line-to-line RMS voltage of 11 kV. The d-axis is set in the short-circuit mode, while
the q-axis is assigned in the open-circuit mode. All the other parameters that are
deﬁned for this example can be found in Fig. 18.65. The last remaining tab of the
parameter window of the Synchronous Machine is called Load Flow. From this tab,
the PV type generator is selected, and the active power of the generator is set as
200 MW, while the range of the reactive power is set as inf to +inf (Fig. 18.66).
A Three-Phase Transformer is connected with the Synchronous Machine to step
up the voltage from 11 kV to 269 kV. The conﬁguration tab of the Three-Phase
Transformer (Two Windings) is shown in the left ﬁgure of Fig. 18.67. The Delta
Fig. 18.66 Block parameters of the synchronous machine pu standard: Load ﬂow
Fig. 18.67 Block parameters of the three-phase transformer
616
18
Application of Simulink in Renewable Energy Technology

(D1) connection is selected for the ﬁrst winding, whereas the “Yg” connection is
chosen for the connection of the second winding. The Parameters tab of this block is
shown on the right side of Fig. 18.67. The nominal power of the transformer is set as
350 MVA. As it will work as a step-up transformer, the RMS phase-to-phase voltage
of the ﬁrst winding is assigned as 11 kV, while for the second winding, the assigned
voltage is 269 kV.
With the transformer a Three-Phase AC Source is connected, which is customized
to have a phase-to-phase RMS voltage rating of 269 kV. The three-phase short-
circuit power of the AC source at the 269 kV base voltage is set to be 5000 MVA as
shown in Fig. 18.68. The X/R ratio of the source for this example is 7. A load of
10 MW is connected right after the Synchronous Machine, where the line voltage is
11 kV. Another load of 15 MW is connected with the 269 kV line after the step-up
transformer. The customization of these two Three-Phase Series Load blocks is
presented in Fig. 18.69.
The output port of the Synchronous Machine is connected with a Bus Selector
block. The parameter window of the Bus Selector block is illustrated in Fig. 18.70,
where the left box indicates all the available output signals, and the right box refers
to the selected ones from the left box. The signal line of Mechanical Rotor speed
Fig. 18.68 Block parameters of the three-phase source
18.3
Hydraulic Turbine
617

(wm) is connected to one of the input ports of the Hydraulic Turbine and Governor
block named actual speed of the machine (we). Similarly, the Output active power
(wm) and the Mechanical Rotor speed deviation (dw) signal lines from the Bus
Selector output ports are connected respectively with the two input ports—actual
electrical power (Pe0) and speed deviation (dw)—of the Hydraulic Turbine and
Governor. The two other selected signals in the Bus Selector vd and vq are connected
with the two input ports of the Excitation System that match the name. A Scope is
Fig. 18.69 Block parameters of the three-phase series RLC load
Fig. 18.70 Block parameters of the bus selector
618
18
Application of Simulink in Renewable Energy Technology

connected with four output signals of the Bus Selector to realize the characteristics of
the Synchronous Machine. The obtained simulated results observable in the Scope
window are demonstrated in Fig. 18.71.
18.4
Battery
In the renewable energy-based power system, battery plays an important role. One of
the disadvantages of renewable energy-based power systems is their intermittency
problem. On this account, the battery system can be utilized to overcome the power
intermittency by providing energy during the unavailability of the renewables. Due
to the advancement of the current battery system, it can be employed as both
temporary and permanent sources of power. In Simulink, a design can be modeled
using a single battery cell, or by utilizing a battery pack created from multiple battery
cells. Based on the structure of a battery cell, different types of batteries such as lead-
acid batteries, Li-ion batteries, etc. are available. Simulink provides the opportunity
to utilize any speciﬁc battery type to model a design.
Fig. 18.71 The response observed from the scope window
18.4
Battery
619

18.4.1
Battery Cell Implementation in Simulink
In Simulink, the Battery block can be considered as a single battery cell, which can
be used as a voltage source. In Fig. 18.72, a simple demonstration of the usage of a
battery cell is made to supply current to a resistor. The utilized blocks in this example
are listed below with their respective navigation routes (Table 18.9):
In Fig. 18.72, it can be observed that a single battery cell is connected with a
resistor in series. To observe the voltage and current, a Voltage Sensor is connected
in parallel across the resistor, and a Current Sensor is connected in series. As the
utilized blocks are physical system blocks, a Solver Conﬁguration block is required
as explained in Sect. 12.5. Finally, the output of the voltage and current measure-
ments are required to be displayed in the Display blocks. However, as the Display
block can only display Simulink signals, the PS-Simulink Converters are required to
convert the physical signals to the Simulink Signals. Hence, one PS-Simulink
Converter is connected with the voltage signal line, whereas the other converter is
connected with the current signal line as shown in the following ﬁgure:
In the parameter window of the Battery, three tabs are available. The Main tab
contains the nominal voltage, internal resistance, and battery charge capacity param-
eters. The nominal voltage of the battery cell is assigned to be 10 V with an internal
resistance (r) of 2.5 ohms (Fig. 18.73). The battery charge capacity is kept as inﬁnite
for this instance. The parameters belonging to the other tabs are kept in their default
forms, such as no dynamics are chosen from the Dynamic tab of the parameter
window.
The Resistor that is connected in series with the voltage source is customized as
shown in Fig. 18.74. The value of the resistance is set as 10 ohms, while the
tolerance is assigned to be 5%. All the other parameters in the remaining tabs are
kept in their default forms or values.
For physical systems, the Solver Conﬁguration block is used instead of the
powergui block. The parameter window of the Solver Conﬁguration block is
shown in Fig. 18.75. To learn more about the Solver Conﬁguration, click on the
Help button, or get back to Sect. 12.5.
After simulating the model, it can be observed from the two Display blocks that
the voltage across the load resistor is 8 V, and the current is 0.8 A. Due to the internal
resistance of the battery cell and the load resistance, voltage drops occur, resulting in
such a reduction of voltage across the load that is expected. Thus, a single battery cell
can be utilized to provide the necessary power to a load.
18.4.2
Battery Modeling of Different Types in Simulink
In Simulink, different battery types can be customized by using Simulink block—
Battery. The navigation route of this block can be found in the following table,
which is different than the previous example. The previous Battery block represents
620
18
Application of Simulink in Renewable Energy Technology

a single battery cell, whereas the Battery block within the Extra Sources is a generic
battery model that can be customized for different types. In Fig. 18.76, a Lithium-Ion
type battery is modeled by customizing its different parameters to simulate a design.
The blocks that are used in this design are enlisted below along with their navigation
routes (Table 18.10):
The Simulink design showed in Fig. 18.76 has a Battery connected with a
Controlled Current Source. Here the Controlled Current Source acts as a constant
load for the battery. A load resistor is also connected in parallel to the Controlled
Current Source. To observe the different characteristic parameters of the battery, a
Bus Selector with a Scope is connected with the output port of the Battery.
Fig. 18.72 Battery cell implementation in Simulink
Table 18.9 Blocks and navigation path for implementing battery cell model
Blocks
Navigation path on the Simulink Library Browser
Battery
Simscape ! Electrical ! Sources ! Battery
Resistor
Simscape ! Electrical ! Passive ! Resistor
Solver Conﬁguration
Simscape ! Utilities ! Solver Conﬁguration
PS-Simulink Converter,
PS-Simulink Converter1
Simscape ! Utilities ! PS-Simulink Converter
Current Sensor
Simscape ! Electrical ! Sensors & Transducers ! Current
Sensor
Voltage Sensor
Simscape ! Electrical ! Sensors & Transducers ! Voltage
Sensor
Electrical Reference
Simscape ! Foundation Library ! Electrical ! Electrical
Elements ! Electrical Reference
Display, Display1
Simulink ! Sinks ! Display
18.4
Battery
621

The Parameter window of the Battery is shown in Fig. 18.77, where two tabs
named Parameters and Discharge can be found. Under the Parameters tab, the type of
the battery can be selected out of four different options, which are Lithium-Ion
Battery, Lead-Acid Battery, Nickel-Cadmium Battery, and Nickel-Metal-Hydride
Fig. 18.73 Block parameters of the battery
Fig. 18.74 Block parameters of the resistor
622
18
Application of Simulink in Renewable Energy Technology

Battery. For this example, the Lithium-Ion Battery type is chosen. The temperature
and the aging effect of the battery can be deﬁned while modeling such batteries by
clicking the checkbox for each of these options. Here, for this particular example,
both are kept unchecked. The nominal voltage of the battery is selected as 50 V with
a rated capacity of 6.5 Ah. The initial State-of-Charge (SoC) of the battery is
assigned to be 100%, and the response time is set as 30 s. The customization can
be seen in the left ﬁgure of Fig. 18.77. Under the other tab named Discharge, several
customizable parameters are available that can be seen in the right-side ﬁgure of
Fig. 18.75 Block parameters of the solver conﬁguration
18.4
Battery
623

Fig. 18.77. In the Discharge tab, all the parameters can be set automatically based on
the nominal values assigned earlier for the battery by clicking the checkbox option
that appears in the front. According to the users’ preferences, the parameters can be
set manually as well. At the bottom of that tab, a Plot option is available, which can
be used to observe the discharge characteristics of the modeled battery. At the left
side of the Plot button, the Unit option can be seen, which can be selected to observe
the plot either in the time scale or in the ampere-hour scale along the x-axis. The
discharge characteristic curve of the modeled battery in the time scale is shown in
Fig. 18.78, which can be observed by double-clicking on the Plot button.
Fig. 18.76 Battery modeling of different types in Simulink
Table 18.10 Blocks and navigation path for modeling different types of battery
Blocks
Navigation path on the Simulink Library Browser
Battery
Simscape ! Electrical ! Specialized Power Systems ! Electric Drives
! Extra Sources ! Battery
Resistor
Simscape ! Electrical ! Passive ! Resistor
Controlled Current
Source
Simscape ! Foundation Library ! Electrical ! Electrical Sources !
Controlled Current Source
Bus Selector
Simulink ! Signal Routing ! Bus Selector
Electrical Reference
Simscape ! Foundation Library ! Electrical ! Electrical Elements !
Electrical Reference
Constant
Simulink ! Sources ! Constant
Display
Simulink ! Sinks ! Display
Scope
Simulink ! Sinks ! Scope
powergui
Simscape ! Electrical ! Specialized Power Systems ! Fundamental
Blocks ! powergui
624
18
Application of Simulink in Renewable Energy Technology

The Controlled Current Source is customized by selecting the initial parameters
as shown in Fig. 18.79. The initial amplitude, phase, and frequency are assigned to
zero with a source type of AC. A Constant block is connected with its input port,
which is customized to be a value of 100. A Series RLC Branch is connected in
parallel, which is conﬁgured as a RL branch with a resistance of 10 ohms and
inductance of 1 mH (Fig. 18.80).
Afterward, a Bus Selector is connected with the output port of the battery. From
the parameter window of the Bus Selector (Fig. 18.81), three parameters can be
observed in the left-side box—SOC (%), Current (A), and Voltage (V). All three of
these parameters are selected to shift on the right-side box. A Scope customized with
three input ports is connected with the three output signals of the Bus Selector. After
simulating the model for 250 s, the observed graphs from the Scope window are
shown in Fig. 18.82. From the graph, it can be observed that the State-of-Charge of
the battery reduces over time from 100% to 0%. As the battery discharges, the
current and voltage also reduce over the period.
18.4.3
Case Study: Battery Pack Design Using Battery Cells
In practical applications, it is always required to design a battery pack for certain
rated values. A battery pack can be designed using multiple battery cells. In many
applications, different rated voltages or ampere-hour ratings may be required. It is
not efﬁcient to purchase different rated batteries all the time based on different
application requirements. Instead, same-rated multiple battery cells can be utilized
Fig. 18.77 Block parameters of the battery
18.4
Battery
625

to design different battery packs of different sizes. In this case study, a battery pack
will be designed to fulﬁll only the voltage requirement of a particular application.
In this case study, a battery pack of 15 V will be designed by utilizing multiple
4 V single battery cells with an internal resistance of 1 ohm. The designed model is
shown in Fig. 18.83, where four single battery cells are connected in series with an
external resistance of 60 ohm. The output voltage across the resistor is shown in the
Display block that shows the exact 15 V voltage, as desired.
The four battery cells have the same rating and hence, are customized in the same
manner. The parameter window of the Battery block is shown in Fig. 18.84, where it
can be observed that the voltage and the internal resistance are assigned as 4 V and
1 ohm, respectively.
The external resistance is entered via the Resistor block, which is conﬁgured to
have a resistance of 60 ohms, and tolerance of 5%, as shown in the Fig. 18.85:
All the utilized blocks in this design are summarized in the following table with
their navigation routes (Table 18.11):
Fig. 18.78 Battery discharge characteristics
626
18
Application of Simulink in Renewable Energy Technology

18.5
Conclusion
In this chapter, the modeling and applications of solar photovoltaics, wind turbines,
hydraulic turbines, and batteries are demonstrated via Simulink. As solar photovol-
taics are widely used renewable energy in the power system domain, this chapter
comparatively emphasizes more on this content. The chapter initiates by creating a
mathematical model of a PV cell and demonstrating the characteristic curves of the
PV cell using different mathematical blocks of Simulink. Later, the same character-
istic curves are generated by utilizing the Solar Cell graphical block of the Simulink.
For demonstrating the applications of solar photovoltaics in the power system
domain, it is imperative to introduce the PV Array to design a PV panel. Followed
by the modeling of a PV panel by using PV Array, the chapter provides a case study
that illustrates the grid connection of a PV panel to realize the practical application of
Fig. 18.79 Block parameters of the controlled current source
18.5
Conclusion
627

Fig. 18.80 Block parameters of the series RLC branch
Fig. 18.81 Block parameters of the bus selector
628
18
Application of Simulink in Renewable Energy Technology

solar photovoltaics. Afterward, the modeling and application of the wind turbine are
showed with necessary illustrations in this chapter. Due to the recent popularity of
hydraulic turbines, a case study of hydraulic turbines to run a synchronous generator
is demonstrated. Finally, the modeling of both battery cells and different battery
models is explained by using Simulink designs. A case study of creating battery
packs from single battery cells is also covered in this chapter to make the reader
familiarized with some of the practical aspects of batteries. This chapter will
tremendously help a reader to grasp the concept of the applicability of renewable
energies in the power system.
Fig. 18.82 The response observed from the scope window
18.5
Conclusion
629

Fig. 18.83 Battery pack design using battery cells in Simulink
Fig. 18.84 Block parameters of the battery
630
18
Application of Simulink in Renewable Energy Technology

Exercise 18
1. Why renewable energy-based technologies are important? Name some of the
renewable energies that are used for electricity generation.
2. (a) Draw the simple circuit model of a single solar cell.
(b) Write the equation of the output power of a single solar cell.
(c) Design a Simulink model demonstrating the mathematical model of a
single solar cell to generate both PV and VI characteristic curves. Use the same
values of the parameters of Fig. 18.2.
(d) Simulate the model for a temperature of 37
C and quality factor, N ¼ 2.
Show both PV and VI characteristic curves.
(e) Design a three-phase inverter for an input DC voltage of 300 V.
3. (a) Write the navigation route of the Wind Turbine Doubly-Fed Induction
Generator (Phasor Type).
Fig. 18.85 Block parameters of the resistor
Table 18.11 Blocks and navigation path for designing battery pack using battery cells
Blocks
Navigation path on the Simulink Library Browser
Battery, Battery1, Bat-
tery2, Battery3
Simscape ! Electrical ! Sources ! Battery
Resistor
Simscape ! Electrical ! Passive ! Resistor
Solver Conﬁguration
Simscape ! Utilities ! Solver Conﬁguration
PS-Simulink Converter
Simscape ! Utilities ! PS-Simulink Converter
Voltage Sensor
Simscape ! Electrical ! Sensors & Transducers ! Voltage
Sensor
Electrical Reference
Simscape ! Foundation Library ! Electrical ! Electrical Ele-
ments ! Electrical Reference
Display
Simulink ! Sinks ! Display
Exercise 18
631

(b) Design a wind turbine-based generator in the Simulink to display the
output powers.
(c) Reproduce the case study of the grid-connected wind turbine generator
shown in Fig. 18.48 to show the output DC voltage of the Wind Turbine Doubly-
Fed Induction Generator.
(d) Use a 500 kW load in the previous design by replacing the previous load
and show the output DC voltage of the Wind Turbine Doubly-Fed Induction
Generator.
4. (a) What is the importance of the Excitation System block used in the design of
Fig. 18.61.
(b) Reproduce the Simulink model shown in Fig. 18.61 to show the Output
active power of the Synchronous Machine.
(c) In the previous design, use a Synchronous Machine of 300 MVA, 33 kV,
and replace the transformer with a 33 kV/269 kV step-up transformer. Show the
Output active power curve of the Synchronous Machine in the Scope window.
5. (a) Name some of the types of batteries.
(b) Design a Lead-Acid Battery model with a Controlled Current Source and
an RL impedance in parallel. Show the discharge characteristic curve of the
battery.
(c) Simulate the previous design to display the SOC (%) curve in the Scope
window.
(d) Design a battery pack of 15 V by using single battery cells of 6 V and
internal resistance of 2 ohms. Show the output voltage in a Display block.
632
18
Application of Simulink in Renewable Energy Technology

Answer Keys to the End-of-Chapter Exercises
Chapter 1
1
See Sect. 1.4
2
See Sect. 1.8
3
Type “help <command/function name>” in MATLAB command window to
learn more details about the commands/functions
4
5
These operations do not produce the same result because the operator “/”
calculates num1/num2, whereas “\” calculates the expression 1/(num1/num2)
© The Editor(s) (if applicable) and The Author(s), under exclusive license to
Springer Nature Switzerland AG 2022
E. Hossain, MATLAB and Simulink Crash Course for Engineers,
https://doi.org/10.1007/978-3-030-89762-8
633

Chapter 2
1
See Sect. 2.1
2
See Sect. 2.6
3
See Sect. 2.3
4
5
6a
6b
634
Answer Keys to the End-of-Chapter Exercises

Chapter 3
1
See Sect. 3.2
2
See Sect. 3.4
3
4
5
6
Answer Keys to the End-of-Chapter Exercises
635

Chapter 4
1
See Sect. 4.1
2
Type “help <command/function name>” in MATLAB command window to
learn more details about the commands/functions
3
4
See Example 4.4, as the solution code closely matches this example
5
See Example 4.6, as the solution code closely matches this example
6
See Example 4.7, as the solution code closely matches this example
7
Chapter 5
1
See Sect. 5.1
2
Type “help <command/function name>” in MATLAB command window to
learn more details about the commands/functions
3
See Examples 5.2 and 5.3
4
See Examples 5.4 and 5.5
5
See Examples 5.8 and 5.11
6
See Example 5.9
Chapter 6
636
Answer Keys to the End-of-Chapter Exercises

1
See Sect. 6.2
2
See the examples that use the functions to solve equations
3
4
Only (a) and (d) are done since the others are similar to these solutions
(a)
(d)
5
See Example 6.6 for (a) and (b), Example 6.7 for (c) and (d), Example 6.8 for
(e) and (f), and Example 6.9 for (g) and (h), and change the equations as suitable
6
Only (a)(i) has been done as the other one can be done similarly
Answer Keys to the End-of-Chapter Exercises
637

Chapter 7
1
See Sects. 7.2, 7.3, and 7.4 to summarize the basic steps
2
Gauss-Seidel method is used to solve a set of equations and for determining
unknown variables, and Newton-Raphson method is used to approximate the
root of a nonlinear function. On the other hand, Runge-Kutta method is used to
solve ordinary differential equations
3a
See Example 7.1 and change the equations as follows:
Result:
3b
For tolerance ¼ 0.0001:
For tolerance ¼ 0.001:
The results vary from the answer in question (a). It is seen that with less
precision in tolerance level, the iteration decreases, hence the less converged
solutions may be visible
3c
For tolerance ¼ 0.000001:
For tolerance ¼ 0.0000001:
The result does not vary much from the answer in question (a) (apart from the
value of y, which changes very little). It is seen that with more precision in
tolerance level, the iteration increases, but since converged solutions have
already been obtained, the solution can be considered as the ﬁnal solution, and
further iterations can be curtailed.
4a
See Example 7.2 and change the equation as follows:
Result:
4b
Result:
5a
See Example 7.2 and change the equation as follows:
Result:
5b
Result:
638
Answer Keys to the End-of-Chapter Exercises

Chapter 8
1
2
3a
3b
4
5
Replicate and run Example 8.13 by changing the value of P as 50 and Q as 13.
Since (b) is similar in procedure with (a), the result of (a) is shown only
Answer Keys to the End-of-Chapter Exercises
639

6a
See and replicate Example 8.14 with the following equations:
6b
See and replicate Example 8.15 with the following equations:
7a
See Example 8.20 and change the values as per the question
7b
See Example 8.21 and change the values as per the question
Result:
8a
See Example 8.23 and change the values as per the question
8b
See Example 8.24 and change the values as per the question
Chapter 9
1
See Sect. 9.2.2
2
See Sects. 9.2.3 and 9.2.4
3
Type “help <command/function name>” in MATLAB command window to
learn more details about the commands/functions
4
Only (a) has been done as the others can be done similarly
640
Answer Keys to the End-of-Chapter Exercises

5
Only (a) has been done as the others can be done similarly. The system is
overdamped because zeta is greater than 1
6
Answer Keys to the End-of-Chapter Exercises
641

7
Only (a) has been done as the other one can be done similarly
8
Only (a) has been done as the others can be done similarly
(a) The system is stable
Chapter 10
1
See Sects. 10.2 and 10.3
2
Only (a) has been done as the others can be done similarly
3a
Use the functions that are coded in Example 10.2. Change the upper and lower limits
in the script as follows:
642
Answer Keys to the End-of-Chapter Exercises

Result:
3b
Result:
4
See Example 10.3, as the code is similar. Only these values are needed to
be changed
4a
Result:
4b
Result:
Answer Keys to the End-of-Chapter Exercises
643

4c
Result:
5
Only (a) has been done as the other one can be done similarly
Result:
644
Answer Keys to the End-of-Chapter Exercises

Chapter 11
1
See Sect. 11.2.1
2
See the examples to infer some of the engineering applications
3
Step 1: Draw a “panel,” an “Edit Field (Text),” and a “Button” from the component
library, and arrange it according to the app shown
Step 2: Rename the panel “Exercise 3,” the edit ﬁeld “Sentence,” and the button
“Click me”
Step 3: Right-click on the button, and select “Callback” and “Go to
ClickmeButtonPushed callback”
Step 4: Write the following code in the function:
Step 5: Save and Run
4
Step 1: While doing Example 11.1, add two more buttons named “POW” and “Z.”
Make the panel appear as the interface shown in the question. The component
browser would look like this:
Step 2: While adding the callback functions for each of the buttons (ﬁrst app.
ADDButton, then for app.SUBButton, then for app.MULButton, then for app.
DIVButton, then for app.POWButton, and ﬁnally for app.ZButton), add the fol-
lowing lines of code in their respective locations as shown as follows:
Answer Keys to the End-of-Chapter Exercises
645

Step 3: Run the app.
5
Step 1: Drag and drop a panel, a knob (not the “Discrete Knob” used in Example
11.2), and ﬁve lamps, and rename the labels and titles as shown in the following
ﬁgure:
646
Answer Keys to the End-of-Chapter Exercises

Step 2: Right-click on the app.VolumeKnob and select callbacks, and then
VolumeKnobValueChanged() function. Enter the following code and save:
Step 3: Run the program
Chapter 12
1
See Sect. 12.2
2
See Sects. 12.2–12.7. The ﬁnal model would look like this:
3
See Sect. 12.8. The function and model for (d)(i) is shown only since (d)(ii) can
be done similarly
Function:
Answer Keys to the End-of-Chapter Exercises
647

Model:
4a
Follow the example shown in Example 12.3 and replace the value of solar
irradiance in the PS constant block into 1000
4b
Connect the power and voltage output only to the two inputs of the scope. The
graph should look like this:
648
Answer Keys to the End-of-Chapter Exercises

4c
Connect the power and voltage output only to the two inputs of the XY graph.
The graph should look like this:
4d
The graph should look as follows. The legend has been changed from North-
west to Southwest for this solution
Answer Keys to the End-of-Chapter Exercises
649

Chapter 13
1
Select any two blocks from the chapter and use corresponding examples
2a
See Sect. 13.2
2b
2c
650
Answer Keys to the End-of-Chapter Exercises

3a
See Sects. 4.3 and 4.4 in Chap. 4 for the formula
3b
3c
Use “Complex to Real-Imag,” “Math Function,” “Trigonometric Function,”
and other mathematical blocks to display the result
4a
See Sect. 13.4
4b
The subsystem is as follows:
4c
“Display” block can be used for demonstrating the result
5a
See Sect. 13.5.3
5b
See Sect. 13.5.4
5c
The model should look as follows:
Answer Keys to the End-of-Chapter Exercises
651

Chapter 14
1
See Sects. 14.1, 14.2, and 14.3
2a
See Sect. 14.2
2b
The response graph should look as follows:
2c
Change the values of the gain into 5, 8, and 12, respectively, in the same
system. Describe the changes noticed in each waveform
3a
See Sect. 14.3
3b
652
Answer Keys to the End-of-Chapter Exercises

3c
4a
See Sect. 14.5.2
4b
Follow the example shown in Sect. 14.5.2 to parameterize the PID controller
4c
The graph should provide the following response:
Answer Keys to the End-of-Chapter Exercises
653

4d
Describe the changes noticed from the scope of the PI and PD controller
5a
See Sect. 14.6
5b
Replicate example shown in Sect. 14.6.1 with the given transfer function.
Double-click on the “Pole-Zero Plot” section and for pole-zero analysis and the
“Gain and Phase Margin Plot” for observing the Nyquist plot
5c
The system is unstable. See Sects. 14.6.1 and 14.6.2 for the characteristics of a
stable and an unstable system. Compare the obtained graph with the charac-
teristics and comment on the resembling features
Chapter 15
1
See Sect. 15.1
2a
See Sect. 15.2 and corresponding examples in the section
2b
See the example shown in Sect. 15.1.2. The resultant values are (i) 4.509,
(ii) 12.75, and (iii) 4.06
3a
See Sect. 15.2
3c
Use Power Measurement block to measure real and reactive power and dem-
onstrate the graph using a Scope block
4a
See Sect. 15.1.2 for the deﬁnition of power factor
4b
The value of the RMS current is 13.76 A
4c
The value of the power factor is 0.1281
Chapter 16
1a
See Sects. 16.1 and 16.2
1b,
c
See the example shown in Sect. 16.2.1 and follow the model provided at the
right side of the example. In the Three-Phase Source block, the input voltage
is given as RMS. Therefore, the input for (i) will be peak amplitude/
ﬃﬃﬃ
2
p
. For
(ii), the given parameter can be used as the RMS value is given
1d
With the three-phase power source parameters in question 1b(ii), and default
parameters of three-phase series RLC load, follow the example shown in Sect.
16.3 to measure voltage and current only
2a
Follow the formula provided in Sect. 16.5
2b
Replicate the example shown in Sect. 16.5, and replace the Three-Phase
Source with the three-phase delta power source
2c
Follow the measurement scheme used in the example in Sect. 16.5
3a
See Sect. 16.6.1
3b,
c
Follow the example shown in Sect. 16.6.1 and replace the load with balanced
three-phase delta load as shown in Sect. 16.6.3. Use the measurement scheme
used in the example in Sect. 16.6.1
3d
Comment on the basis of voltage, current, and impedances on each side and
match with the individual characteristics of wye and delta connection
4a
See the descriptions in Sects. 16.6.1 and 16.6.2
654
Answer Keys to the End-of-Chapter Exercises

4b,
c
Follow the example shown in Sect. 16.6.4 and replace the load with unbal-
anced three-phase wye load as shown in Sect. 16.6.2. Use the measurement
scheme used in the example in Sect. 16.6.4
4d
Comment on the basis of voltage, current, and impedances on each side and
match with their individual characteristics of delta and wye connection
5a
See Sect. 16.7
5b,
c
See the example shown in Sect. 16.7.1 and replace the Preset model value as
per the question. Follow the measurement scheme shown in the example of
Sect. 16.7.1
6a
See Sect. 16.7.2 for the types of rotors
6b,
c
See the example shown in Sect. 16.7.2 and replace the wye model with the
delta model from Sect. 16.2.2. Consider resistive loads only if RL loads do
not work for the system
Chapter 17
1a
See Sect. 17.1
1b
See the explanation for each type of rectiﬁer in Sects. 17.1.2 and 17.1.3
1c
Replicate the example in Sect. 17.1.3 and change the value of the transformer
winding parameters for 220 V input voltage and 24 V output voltage
1d
Replicate the design of three-phase rectiﬁer from Sect. 17.1.4. Change the load
from R to RL and RC. Change the value of L and C as shown in Sects. 17.1.2.2
and 17.1.2.3 and see the explanation to justify the observed changes
2a
See Sects. 17.1 and 17.2
2b
Replicate two examples shown in Sect. 17.2.1 for NPN and PNP transistors,
and change the value of the DC current source into 0.004 V (for NPN
transistor) and 0.004 V (for PNP transistor), and change the parameters of the
XY Graph for better visualization
3a
See Sects. 17.3.3 and 17.3.4 for the formula
3b
See Sect. 17.3.1. With the given value of input and output voltages, determine
the ratio of R2/R1. Pick appropriate values of R1 and R2 to match the ratio. Then
replicate the example in the section with those resistor values to obtain the
desired input and output voltage
3c
See Sect. 17.3.2. With the given value of input and output voltages, determine
the ratio of R2/R1. Pick appropriate values of R1 and R2 to match the ratio. Then
replicate the example in the section with those resistor values to obtain the
desired input and output voltage
4a
See the initial explanation in Sect. 17.4
4b
(i) Replicate the example of MOSFET in Sect. 17.4.2 and change the phase
delay ﬁrst into (45*(1/60)*(1/360)) and then into (90*(1/60)*(1/360)) in Pulse
Generator block. Compare the output and explain the changes with the help of
Sect. 17.4.2
(ii) Replicate the example of GTO in Sect. 17.4.3 and change the pulse width to
10 and phase delay for (45*(1/60)*(1/360)) in the Pulse Generator block. Then
Answer Keys to the End-of-Chapter Exercises
655

change the pulse width to 25 and phase delay for (90*(1/60)*(1/360)). Com-
pare the output and explain the changes with the help of Sect. 17.4.3
5a
Replicate the example shown in Sect. 17.5.1. Add an alpha-beta-zero to dq0
block from Simulink, and provide the alpha-beta-zero signal as the input.
Compare the dq0 output from this block with the one in the example
5b
See Sect. 17.6.1.1 and calculate the value of the duty cycle from the source
voltage and output voltage. Change the duty cycle in the Pulse Generator block
and change the value of resistor, inductor, and capacitor if needed to obtain a
graph with less ripple and oscillation as much as possible
5c
See Sect. 17.6.1.2 and calculate the value of the duty cycle from the source
voltage and output voltage. Change the duty cycle in the Pulse Generator block
and change the value of resistor, inductor, and capacitor if needed to obtain a
graph with less ripple and oscillation as much as possible
6a
See Sect. 17.6.3
6b
Replicate the three-phase full-wave converter shown in Sect. 17.6.2.3 with DC
voltage of 24 V. Measure the phase-to-phase voltages using Voltage Mea-
surement blocks and demonstrate the output in a Scope block
6c
Replicate the example cycloconverter designed in Sect. 17.6.4 with the same
parameters. Provide a period of 0.0668 s at the “Pulse Generator3” block
Chapter 18
1
See the abstract of the chapter
2a
See Fig. 18.1
2b
See Sect. 18.1.1
2c
See Fig. 18.2
2d
See Fig. 18.2. Update the value, T ¼ 310 and N ¼ 2. Simulate the model for
showing the characteristic curves
2e
See Fig. 18.18. Use the Second Area box for the three-phase inverter design.
Replace the ﬁrst PV panel Area box with a DC voltage source of 300 V
3a
See Sect. 18.2.1
3b
See Fig. 18.37. From the Bus Selector, only select P (pu) and Q (pu) to show
them in the Scope
3c
See Fig. 18.48. From the Bus Selector, only select Vdc (V) to show it in the
Scope
3d
See Fig. 18.48. Update the active power (W) of the Three-Phase Series RLC
Load from its parameter window (see Fig. 18.57). From the Bus Selector, only
select Vdc (V) to show it in the Scope
4a
See Sect. 18.3.1
4b
See Fig. 18.61. From the Bus Selector, only select Output active power, Pe0
(pu), to show it in the Scope
4c
See Fig. 18.65 to update the nominal power and line-to-line voltage of the
Synchronous Machine
See Fig. 18.67 to update the two winding voltages of the Three-Phase
656
Answer Keys to the End-of-Chapter Exercises

Transformer (Two Windings)
From the Bus Selector, only select Output active power, Pe0 (pu), to show it in
the Scope
5a
See Sect. 18.4.2 to ﬁnd out the types of batteries
5b
See Fig. 18.76 to design the model. See Fig. 16.77 to select the battery type and
to show the discharge characteristic curve
5c
See Fig. 18.76. From the Bus Selector, only select SOC (%) to show it in the
Scope
5d
See Fig. 18.83. The resultant output voltage ¼ 15 V. The design may vary. One
of the acceptable designs is as follows:
Answer Keys to the End-of-Chapter Exercises
657

