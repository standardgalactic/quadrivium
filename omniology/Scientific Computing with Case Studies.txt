Scientific Computing
W I T H  C A S E  S T U D I E S
www.ebook3000.com


Scientific Computing
W I T H  C A S E  S T U D I E S
Dianne P. O’Leary
University of Maryland
College Park, Maryland
Society for Industrial and Applied Mathematics
Philadelphia
www.ebook3000.com

Copyright © 2009 by the Society for Industrial and Applied Mathematics and the Mathematical
Programming Society
10 9 8 7 6 5 4 3 2 1
All rights reserved. Printed in the United States of America. No part of this book may be repro-
duced, stored, or transmitted in any manner without the written permission of the publisher. For
information, write to the Society for Industrial and Applied Mathematics, 3600 Market Street,
6th Floor, Philadelphia, PA, 19104-2688 USA.
Trademarked names may be used in this book without the inclusion of a trademark symbol.
These names are used in an editorial context only; no infringement of trademark is intended.
MATLAB is a registered trademark of The MathWorks, Inc. For MATLAB product information,
please contact The MathWorks, Inc., 3 Apple Hill Drive, Natick, MA 01760-2098 USA, 508-647-
7000, Fax: 508-647-7101, info@mathworks.com, www.mathworks.com.
Mathematica is a registered trademark of Wolfram Research, Inc.
Maple is a registered trademark of Waterloo Maple, Inc.
The images in Figure 1.1 were taken from http://nightglow.gsfc.nasa.gov/eric_journal_files/
sydney_bridge.jpg and http://www.cpsc.gov/cpscpub/prerel/prhtml07/07267a.jpg
Figure 26.1 (http://www.myrmecos.net/insects/Tribolium1.html) is owned by Alex Wild.
Figures 11.1 and 11.2 were taken by Timothy O’Leary.
Library of Congress Cataloging-in-Publication Data
O'Leary, Dianne P.
Scientific computing with case studies / Dianne P. O'Leary.
p. cm.
Includes bibliographical references and index.
ISBN 978-0-898716-66-5
1.  Mathematical models--Data processing--Case studies.  I. Title. 
QA401.O44 2008
510.285--dc22
2008031493
is a registered trademark.


To Gene H. Golub, my first research mentor.
To my parents, Raymond and Anne Prost.
To my husband, Timothy.
To my children, Theresa, Thomas, and Brendan.
With love.

www.ebook3000.com


Contents
Preface
xiii
I
Preliminaries: Mathematical Modeling, Errors, Hardware, and Software
1
1
Errors and Arithmetic
5
1.1
Sources of Error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.2
Computational Science and Scientiﬁc Computing . . . . . . . . . . . .
7
1.3
Computer Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
1.4
How Errors Propagate . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
1.5
Mini Case Study: Avoiding Catastrophic Cancellation . . . . . . . . . .
15
1.6
How Errors Are Measured
. . . . . . . . . . . . . . . . . . . . . . . .
17
1.7
Conditioning and Stability
. . . . . . . . . . . . . . . . . . . . . . . .
20
2
Sensitivity Analysis: When a Little Means a Lot
23
2.1
Sensitivity Is Measured by Derivatives. . . . . . . . . . . . . . . . . . .
23
2.2
Condition Numbers Give Bounds on Sensitivity. . . . . . . . . . . . . .
24
2.3
Monte Carlo Experiments Can Estimate Sensitivity. . . . . . . . . . . .
27
2.4
Conﬁdence Intervals Give Insight into Sensitivity . . . . . . . . . . . .
28
3
Computer Memory and Arithmetic:
31
A Look Under the Hood
3.1
A Motivating Example
. . . . . . . . . . . . . . . . . . . . . . . . . .
31
3.2
Memory Management . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
3.3
Determining Hardware Parameters . . . . . . . . . . . . . . . . . . . .
34
3.4
Speed of Computer Arithmetic . . . . . . . . . . . . . . . . . . . . . .
36
4
Design of Computer Programs:
39
Writing Your Legacy
4.1
Documentation
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
4.2
Software Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
41
4.3
Validation and Debugging . . . . . . . . . . . . . . . . . . . . . . . . .
42
4.4
Efﬁciency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
vii
www.ebook3000.com

viii
Contents
II
Dense Matrix Computations
45
5
Matrix Factorizations
49
5.1
Basic Tools for Matrix Manipulation: The BLAS . . . . . . . . . . . . .
50
5.2
The LU and Cholesky Decompositions . . . . . . . . . . . . . . . . . .
52
5.3
The QR Decomposition . . . . . . . . . . . . . . . . . . . . . . . . . .
57
5.3.1
QR Decomposition by Givens Rotations
. . . . . . . . . . . .
58
5.3.2
QR by Gram–Schmidt Orthogonalization . . . . . . . . . . . .
60
5.3.3
Computing and Using the QR Decomposition . . . . . . . . . .
62
5.3.4
Mini Case Study: Least Squares Data Fitting . . . . . . . . . .
65
5.4
The Rank-Revealing QR Decomposition (RR-QR) . . . . . . . . . . . .
67
5.5
Eigendecomposition . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
5.5.1
Computing the Eigendecomposition . . . . . . . . . . . . . . .
68
5.5.2
Mini Case Study: Stability Analysis of a Linear Control System
71
5.5.3
Other Uses for Eigendecompositions . . . . . . . . . . . . . .
72
5.6
The Singular Value Decomposition (SVD) . . . . . . . . . . . . . . . .
73
5.6.1
Computing and Using the SVD . . . . . . . . . . . . . . . . .
73
5.6.2
Mini Case Study: Solving Ill-Conditioned and Rank-Deﬁcient
Least Squares Problems . . . . . . . . . . . . . . . . . . . . .
74
5.7
Some Matrix Tasks to Avoid
. . . . . . . . . . . . . . . . . . . . . . .
76
5.8
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
78
6
Case Study: Image Deblurring: I Can See Clearly Now
81
(coauthored by James G. Nagy)
7
Case Study: Updating and Downdating Matrix Factorizations:
87
A Change in Plans
8
Case Study: The Direction-of-Arrival Problem
97
III
Optimization and Data Fitting
105
9
Numerical Methods for Unconstrained Optimization
109
9.1
Fundamentals for Unconstrained Optimization . . . . . . . . . . . . . . 109
9.1.1
How Do We Recognize a Solution? . . . . . . . . . . . . . . . 110
9.1.2
Geometric Conditions for Optimality . . . . . . . . . . . . . . 112
9.1.3
The Basic Minimization Algorithm . . . . . . . . . . . . . . . 113
9.2
The Model Method: Newton . . . . . . . . . . . . . . . . . . . . . . . 114
9.2.1
How Well Does Newton’s Method Work? . . . . . . . . . . . . 116
9.2.2
Making Newton’s Method Safe: Modiﬁed Newton Methods . . 117
9.3
Descent Directions and Backtracking Linesearches
. . . . . . . . . . . 119
9.4
Trust Regions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
9.5
Alternatives to Newton’s Method . . . . . . . . . . . . . . . . . . . . . 122
9.5.1
Methods that Require Only First Derivatives
. . . . . . . . . . 123
9.5.2
Low-Storage First-Derivative Methods
. . . . . . . . . . . . . 126
9.5.3
Methods that Require No Derivatives . . . . . . . . . . . . . . 129
9.6
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131

Contents
ix
10
Numerical Methods for Constrained Optimization
135
10.1
Fundamentals for Constrained Optimization . . . . . . . . . . . . . . . 135
10.1.1
Optimality Conditions for Linear Constraints . . . . . . . . . . 136
10.1.2
Optimality Conditions for the General Case . . . . . . . . . . . 138
10.2
Solving Problems with Bound Constraints . . . . . . . . . . . . . . . . 139
10.3
Solving Problems with Linear Equality Constraints: Feasible Directions 140
10.4
Barrier and Penalty Methods for General Constraints
. . . . . . . . . . 141
10.5
Interior-Point Methods
. . . . . . . . . . . . . . . . . . . . . . . . . . 144
10.6
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
11
Case Study: Classiﬁed Information:
149
The Data Clustering Problem
(coauthored by Nargess Memarsadeghi)
12
Case Study: Achieving a Common Viewpoint:
157
Yaw, Pitch, and Roll
(coauthored by David A. Schug)
13
Case Study: Fitting Exponentials: An Interest in Rates
163
14
Case Study: Blind Deconvolution: Errors, Errors Everywhere
169
15
Case Study: Blind Deconvolution: A Matter of Norm
175
IV
Monte Carlo Computations
183
16
Monte Carlo Principles
187
16.1
Random Numbers and Their Generation . . . . . . . . . . . . . . . . . 188
16.2
Properties of Probability Distributions . . . . . . . . . . . . . . . . . . 190
16.3
The World Is Normal . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
16.4
Pseudorandom Numbers and Their Generation . . . . . . . . . . . . . . 192
16.5
Mini Case Study: Testing Random Numbers . . . . . . . . . . . . . . . 193
17
Case Study: Monte Carlo Minimization and Counting:
195
One, Two, Too Many
(coauthored by Isabel Beichl and Francis Sullivan)
18
Case Study: Multidimensional Integration:
203
Partition and Conquer
19
Case Study: Models of Infection: Person to Person
213
V
Ordinary Differential Equations
221
20
Solution of Ordinary Differential Equations
225
20.1
Initial Value Problems for Ordinary Differential Equations
. . . . . . . 226
20.1.1
Standard Form . . . . . . . . . . . . . . . . . . . . . . . . . . 226
20.1.2
Solution Families and Stability
. . . . . . . . . . . . . . . . . 228
www.ebook3000.com

x
Contents
20.2
Methods for Solving IVPs for ODEs . . . . . . . . . . . . . . . . . . . . 232
20.2.1
Euler’s Method, Stability, and Error . . . . . . . . . . . . . . . 232
20.2.2
Predictor-Corrector Methods . . . . . . . . . . . . . . . . . . . 237
20.2.3
The Adams Family . . . . . . . . . . . . . . . . . . . . . . . . 239
20.2.4
Some Ingredients in Building a Practical ODE Solver . . . . . . 240
20.2.5
Solving Stiff Problems . . . . . . . . . . . . . . . . . . . . . . 243
20.2.6
An Alternative to Adams Formulas: Runge–Kutta
. . . . . . . 243
20.3
Hamiltonian Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
20.4
Differential-Algebraic Equations . . . . . . . . . . . . . . . . . . . . . 247
20.4.1
Some Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
20.4.2
Numerical Methods for DAEs
. . . . . . . . . . . . . . . . . . 249
20.5
Boundary Value Problems for ODEs
. . . . . . . . . . . . . . . . . . . 250
20.5.1
Shooting Methods . . . . . . . . . . . . . . . . . . . . . . . . 253
20.5.2
Finite Difference Methods . . . . . . . . . . . . . . . . . . . . 254
20.6
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256
21
Case Study: More Models of Infection: It’s Epidemic
259
22
Case Study: Robot Control: Swinging Like a Pendulum
265
(coauthored by Yalin E. Sagduyu)
23
Case Study: Finite Differences and Finite Elements
273
Getting to Know You
VI
Nonlinear Equations and Continuation Methods
281
24
Nonlinear Systems
285
24.1
The Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
24.2
Nonlinear Least Squares Problems . . . . . . . . . . . . . . . . . . . . 287
24.3
Newton-like Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . 288
24.3.1
Newton’s Method for Nonlinear Equations . . . . . . . . . . . 288
24.3.2
Alternatives to Newton’s Method . . . . . . . . . . . . . . . . 289
24.4
Continuation Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
24.4.1
The Theory behind Continuation Methods
. . . . . . . . . . . 293
24.4.2
Following the Solution Path . . . . . . . . . . . . . . . . . . . 294
25
Case Study: Variable-Geometry Trusses
297
26
Case Study: Beetles, Cannibalism, and Chaos
301
VII Sparse Matrix Computations,
with Application to Partial Differential Equations
307
27
Solving Sparse Linear Systems
311
Taking the Direct Approach
27.1
Storing and Factoring Sparse Matrices . . . . . . . . . . . . . . . . . . 311
27.2
What Matrix Patterns Preserve Sparsity? . . . . . . . . . . . . . . . . . 313
27.3
Representing Sparsity Structure . . . . . . . . . . . . . . . . . . . . . . 314

November 20, 2008 10:52
sccsbook
Sheet number 5 Page number xi
cyan magenta yellow black
Contents
xi
27.4
Some Reordering Strategies for Sparse Symmetric Matrices . . . . . . . 314
27.5
Reordering Strategies for Nonsymmetric Matrices . . . . . . . . . . . . 321
28
Iterative Methods for Linear Systems
323
28.1
Stationary Iterative Methods (SIMs)
. . . . . . . . . . . . . . . . . . . 324
28.2
From SIMs to Krylov Subspace Methods . . . . . . . . . . . . . . . . . 326
28.3
Preconditioning CG . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328
28.4
Krylov Methods for Symmetric Indeﬁnite Matrices and for Normal
Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330
28.5
Krylov Methods for Nonsymmetric Matrices . . . . . . . . . . . . . . . 331
28.6
Computing Eigendecompositions and SVDs with Krylov Methods . . . 333
29
Case Study: Elastoplastic Torsion: Twist and Stress
335
30
Case Study: Fast Solvers and Sylvester Equations
341
Both Sides Now
31
Case Study: Eigenvalues: Valuable Principles
347
32
Multigrid Methods: Managing Massive Meshes
353
Bibliography
361
Index
373
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 6 Page number xii
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 7 Page number xiii
cyan magenta yellow black
Preface
A master carpenter does not need to know how her hammer was designed or what
Newton’s laws say about the force that the hammer applies. But she does need to know
how to use the hammer, when to use a ball-peen hammer instead, and what to do when
things go wrong, for example, when a nail bends as it is driven.
We take the same viewpoint in this book. Although there are fascinating stories to
tell in the details of how basic numerical algorithms are designed and how they operate, we
view them as tools in our virtual toolbox, discussing the innards just enough to be able to
master their uses. Instead we focus on how to choose the most appropriate algorithm, how
to make use of it, how to evaluate the results, and what to do when things go wrong.
This viewpoint frees us to explore many diverse applications of our tools, and through
such case studies we practice the analysis and experimentation that are the mainstays of
computational science.
The reader should have background knowledge equivalent to a ﬁrst course in scien-
tiﬁc computing or numerical analysis. Excellent textbooks for learning this information
include those by Michael Heath [71], Cleve Moler [108], and Charles Van Loan [148].
Examples and illustrations use the MATLAB R⃝programming language. Standard
MATLAB functions provide us with our basic numerical algorithms, and the graphics in-
terface is quite useful. For some problems, we make use of some of the MATLAB tool-
boxes, in particular, the Optimization Toolbox. If you do not have access to MATLAB, the
basic numerical algorithms can also be obtained from NETLIB and other sources noted in
the text. Sample programs for each case study are available at the website
www.cs.umd.edu/users/oleary/SCCS/
No single book can give a computational scientist all of the background needed for a
career. In fact, computational science is primarily a collaborative enterprise, since it is rare
that a single individual has all of the computational and scientiﬁc background necessary
to complete a project. My hope is that this particular slice of knowledge will prove use-
ful in your work and will lead you to further study, exciting applications, and productive
collaborations.
I’m grateful to my many mentors, collaborators, and students, who through their
probing questions forced me to seek deeper understanding and clearer explanations. May
you too be blessed with good colleagues.
xiii
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 8 Page number xiv
cyan magenta yellow black
xiv
Preface
Notes to Students
This book is written as a textbook for a second course in scientiﬁc computing, so it assumes
that you have had a semester (or equivalent) of background using a standard textbook such
as that by Heath [71], Moler [108], Van Loan [148], or equivalent. The Basics box at the
beginning of each unit tells you what part of this material you might want to review in
preparation for the unit. The Mastery box is a checklist of points to master in working
through the unit.
The basic premise behind this book is that people learn by doing. Therefore, the
book is best read with a pencil, paper, and MATLAB window close at hand. Challenges
are sprinkled throughout the text, and they are meant be worked as they are encountered,
or at least before the end of the chapter. Answers are provided for most challenges at
www.cs.umd.edu/users/oleary/SCCS/
There you can see examples of how someone else worked through the challenges. Mastery
will be best if the answers are used to verify and reﬁne your own approach to the problem.
Merely reading the answer, though tempting, is (unfortunately) no substitute for trying to
work the challenge on your own.
Pointers give important information and references to additional literature and soft-
ware. I hope the content of this book leads you to want to learn more about scientiﬁc
computing.
Notes to Instructors
The material in this book has been used for a semester and a half in a graduate level course
in the applied mathematics program at the University of Maryland.
• I lecture from the introductory material in each unit, with material from the Case
Studies used to occasionally provide extra information and motivation. Students can
become quite passionate about some of the Case Studies, especially the more visual
ones such as the image deblurring problem (Chapter 6), the data clustering problem
(Chapter 11), and the epidemiology models (Chapter 19 and 21).
• For quizzes and exams, I derive problems from the Mastery points at the beginning
of each unit.
• If possible, I like to allow “laboratory time” in class for students to work on some of
the Challenges. The opportunity to see how other people solve problems is helpful
even to the best students. This is especially true if, as at the University of Maryland,
the students in this course come from backgrounds in mathematics, computer sci-
ence, and engineering. This provides a remarkably diverse set of viewpoints on the
material and enriches the dialog.
• Many of the Case Studies were originally homeworks.
• For a term project, I often ask students to develop a Case Study, using the tools
presented in the course to solve a problem in their application area. Such projects can
then be adapted for use in later terms. My students Nargess Memarsadeghi, David
A. Schug, and Yalin E. Sagduyu developed particularly interesting case studies, and
adapted versions of them are included here.

November 20, 2008 10:52
sccsbook
Sheet number 9 Page number xv
cyan magenta yellow black
Preface
xv
• There are not many unsolved exercises in this book. In the age of the Internet, there
are very few textbook problems for which solutions cannot be found somewhere,
and providing solutions here at least puts all students on equal footing. Some un-
solved exercises and Case Studies are available on the book’s website, and I would
be grateful for your contribution of additional ones to post there.
There is a great deal of ﬂexibility in choice and ordering of units, except that the
optimization unit should be covered before nonlinear equations, and dense matrix compu-
tations should be discussed before optimization. The ﬁrst six units form the syllabus for
a one semester course at Maryland, while the ﬁnal one is combined with a textbook in
numerical solution of partial differential equations for the second semester.
Acknowledgments
I am grateful for the help of many, including the following:
• Computing in Science and Engineering, published by the American Institute of Physics
and the IEEE Computer Society, for permission to include chapters derived from the
case studies published there: Chapters
1 (Vol. 8, No. 5, 2006, pp. 86–90),
3 (Vol. 8, No. 3, 2006, pp. 86–89),
4 (Vol. 7, No. 6, 2006, pp. 78–80),
6 (Vol. 5, No. 3, 2003, pp. 82–85),
7 (Vol. 8, No. 2, 2006, pp. 66–70),
8 (Vol. 5, No. 6, 2003, pp. 60–63),
11 (Vol. 5, No. 5, 2003, pp. 54–57),
12 (Vol. 6, No. 5, 2004; pp. 60–62),
13 (Vol. 6, No. 3, 2004, pp. 66–69),
14 (Vol. 7, No. 1, 2005, pp. 56–59),
15 (Vol. 7, No. 2, 2005, pp. 60–62),
17 (Vol. 9, No. 1, 2007, pp. 72–76),
18 (Vol. 6, No. 6, 2004; pp. 58–62),
19 (Vol. 6, No. 1, 2004, pp. 68–70),
21 (Vol. 6, No. 2, 2004, pp. 50–53),
22 (Vol. 5, No. 4, 2003, pp. 68–71),
23 (Vol. 7, No. 3, 2005, pp. 20–23),
26 (Vol. 9, No. 2, 2007, pp. 96–99),
27 (Vol. 7, No. 5, 2005, pp. 62–67),
28 (Vol. 8, No. 4, 2006, pp. 74–78),
29 (Vol. 6, No. 4, 2004, pp. 74–76),
30 (Vol. 7, No. 6, 2005, pp. 74–77),
31 (Vol. 7, No. 4, 2005, pp. 68–70),
32 (Vol. 8, No. 5, 2006, pp. 86–90).
• Jennifer Stout, Lead Editor of Computing in Science and Engineering, who patiently
edited the case studies.
• Mei Huang, for her work on Chapter 18.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 10 Page number xvi
cyan magenta yellow black
xvi
Preface
• Jin Hyuk Jung, who as a teaching assistant wrote supplementary lecture notes from
which some of the ﬁgures were taken, particularly those in Chapters 5, 9, and 24.
• Nargess Memarsadeghi, David Schug, and Yalin Sagduyu, whose term projects were
so interesting that they led to case studies included here.
• Staff in the Technical Support Department at The MathWorks, for discussions about
the sources of overhead in MATLAB interpreted and compiled instructions.
• James G. Nagy, a master teacher, who inspired the case studies and coauthored the
ﬁrst one.
• The National Science Foundation and the National Institute of Standards and Tech-
nology, for supporting my research into many of the problems discussed in the case
studies.
• Timothy O’Leary for the photo of Charlie in Chapter 11.
• Students in the University of Maryland courses Scientiﬁc Computing I and II: (espe-
cially Samuel Lamphier) for their patience and debugging as the notes were devel-
oped.
• G. W. Stewart, for his example of clearly written textbooks and for the privilege of
being his colleague at Maryland.
• Howard Elman, David Gilsinn, Vadim Kavalerov, Tamara Kolda, Samuel Lamphier,
K.J.R. Liu, Brendan O’Leary, Bert Rust, Simon P. Schurr, Elisa Sotelino, G. W.
Stewart, and Layne T. Watson for helpful comments.
The images in Figure 1.1 were taken from http://nightglow.gsfc.nasa.
gov/eric_journal_files/sydney_bridge.jpgand http://www.cpsc.gov/
cpscpub/prerel/prhtml07/07267a.jpg,and that in Figure 26.1 (http://www.
myrmecos.net/insects/Tribolium1.html) is owned by Alex Wild.

November 20, 2008 10:52
sccsbook
Sheet number 11 Page number 1
cyan magenta yellow black
Unit I
Preliminaries: 
Mathematical Modeling, Errors, 
Hardware and Software
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 12 Page number 2
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 13 Page number 3
cyan magenta yellow black
3
The topic of this book is efﬁcient and accurate computation with mathematical mod-
els. In this unit, we discuss the basic facts that we need to know about error, software, and
computers.
We begin our study with some basics. First in Chapter 1 we consider how errors are
introduced in scientiﬁc computing and how to measure them. We apply these principles in
Chapter 2, studying how small changes in our data can affect our answers. In Chapter 3,
we see how computer memory is organized and how that impacts the efﬁciency of our
algorithms. Then in Chapter 4, we study the principles behind writing and documenting
our algorithms.
BASICS: To understand this unit, the following background is helpful:
• MATLAB programming [78].
• Gauss elimination; see a linear algebra textbook or a beginning book on numerical
analysis or scientiﬁc computing [148].
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 14 Page number 4
cyan magenta yellow black
4
MASTERY: After you have worked through this unit, you should be able to do the follow-
ing:
• Identify the sources of error in scientiﬁc computing.
• Represent an integer in a ﬁxed-point number system and a real number in a ﬂoating-
point number system.
• Use the parameter ϵm (machine epsilon) to determine the error introduced in ﬂoating-
point representation.
• Measure relative and absolute errors and determine how they are magniﬁed during
computation.
• Write algorithms that compute values such as the sum of a series, avoiding unneces-
sary inaccuracies.
• Determine ways to avoid catastrophic cancellation in designing algorithms.
• Use forward and backward error analysis to assess the quality of a computed solution
to a problem.
• Determine whether a problem is well-conditioned or ill-conditioned.
• Discuss the importance of stability in an algorithm.
• Measure the sensitivity of a problem using derivatives, condition numbers, Monte
Carlo experiments, and conﬁdence intervals.
• Distinguish between a row-oriented matrix algorithm and a column-oriented matrix
algorithm, and be able to write them for simple tasks.
• Explain how matrices are stored in main memory and moved to cache, and perform
counts of page moves.
• Count the number of multiplications in a given MATLAB algorithm.
• Explain what the BLAS are and why they are useful.
• Document computer programs effectively.
• Understand the principles of modular design.
• Write a program to validate a function that you have written.

November 20, 2008 10:52
sccsbook
Sheet number 15 Page number 5
cyan magenta yellow black
Chapter 1
Errors and
Arithmetic
What better way to start a book than with error? We need to know how errors arise, how
they are propagated in calculations, and how to measure and bound errors.
1.1
Sources of Error
Suppose an engineer wants to study the stresses in the bridge shown in Figure 1.1. The
study would begin by gathering some data, including the lengths and angles for the girders
and cables and the material properties for each component. There is some measurement
error, though, since no measuring device gives full precision. Therefore, the measurements
would typically be recorded as a value plus or minus an uncertainty.
The engineer would then need to model the stresses on the bridge. The bridge might
be approximated by a “ﬁnite element model” to limit the number of unknowns in the prob-
lem, and this is an additional source of error. Simplifying assumptions might be made;
for example, we might assume that the material in each girder is homogeneous. Modeling
error is the result of the difference between the true bridge and our computable model.
Now we have a mathematical model, and we need to compute the stresses. If the
model is large or nonlinear, then a numerical analyst might develop an algorithm that com-
putes the solution as
lim
n→∞G(n),
where, for example, G(n) might be the result of n iterations of Newton’s method. In gen-
eral, we can’t take this limit on a computer, so we might decide that G(150) is good enough.
This introduces truncation error.
Finally, we implement the algorithm and run it on our favorite computer. This intro-
duces additional error, since we don’t compute with real numbers but with ﬁnite-precision
numbers: a ﬁxed number of digits are carried in the computation. The effect of this is
rounding error.
5
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 16 Page number 6
cyan magenta yellow black
6
Chapter 1. Errors and Arithmetic
Estimates
of stresses
Finite Element Model
wlist = [];
csinvclist = [];
nupdates = 0;
alpha = eye(p);
for my_ifnct=1:p,
gnew(:,my_ifnct) = mygrad(my_x(:,my_ifnct));
fval(my_ifnct) = myfnct(my_x(:,my_ifnct));
end
for i=1:nits,
my_searchdir = gnew;
for kk=1:nupdates,
lo=(kk-1)*p+1;
up=kk*p;
my_searchdir = my_searchdir+wlist(:,lo:up) ...
* (csinvclist(lo:up,:)*my_searchdir);
end
gold = gnew;
alpfindlin_nonsym;
if (norm(s,'fro') ~= 0)
hy =  y;
for kk=1:nupdates,
lo=(kk-1)*p+1;
up=kk*p;
hy = hy + wlist(:,lo:up)*(csinvclist(lo:up,:)*hy);
end
w = s - hy;
csinvc = (s'*hy) \ s';
wlist = [wlist, w];
csinvclist = [csinvclist; csinvc];
nupdates = nupdates + 1;
else
nupdates = 0;
end
end
Algorithm
Figure 1.1. Computing the stresses in a bridge involves measurement error, mod-
eling error, truncation error, and rounding error.
Therefore, the results obtained for the stresses on the bridge are contaminated by
these four types of error: measurement error, modeling error, truncation error, and rounding
error. It is important to note that no mistakes were made:
• The engineer did not misread the measurement device.
• The model was a good approximation to the true bridge.
• The programmer did not type the value of π incorrectly.
• The computer worked ﬂawlessly.

November 20, 2008 10:52
sccsbook
Sheet number 17 Page number 7
cyan magenta yellow black
1.2. Computational Science and Scientiﬁc Computing
7
Science
Engineering
Numerical
Analysis
Statistics
Mathematical
Software
The
Problem
The
Data
Mathematics
Figure 1.2. Computational science involves knowledge from many disciplines.
POINTER 1.1. Modeling the Error.
Developing a realistic understanding of the errors in the data is often the most chal-
lenging part of scientiﬁc computing. If you are solving a spectroscopy problem, for ex-
ample, ideally you would ﬁrst want to take a sample for which the composition is known
and obtain several sets of sample data from the spectrometer. Using that data, you could
develop a model for the error and see how your algorithms are affected by it.
But at the end of the process, the engineer needs to ask what the computed solution has to
do with the stresses on the bridge!
1.2
Computational Science and Scientiﬁc Computing
In order to answer the question posed at the end of the previous section, we require several
types of expertise. We use science and engineering to formulate the problem and determine
what data is needed. We use mathematics and statistics to design the model. We use
numerical analysis to design and analyze the algorithms, develop mathematical software,
and answer questions about how accurate the ﬁnal answer is. Therefore, our project could
easily involve an interdisciplinary team of four or more experts; see Figure 1.2. Often,
though, if the model is more or less routine, one person might do it all.
A computational scientist is a team member whose focus is on scientiﬁc comput-
ing: intelligently using mathematical software to analyze mathematical models. To do this
requires a basic understanding of how computers do arithmetic.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 18 Page number 8
cyan magenta yellow black
8
Chapter 1. Errors and Arithmetic
POINTER 1.2. Matrix and Vector Notation.
Throughout this book we use the following notational conventions:
• All vectors are column vectors.
• Matrices are denoted by boldface upper case letters; vectors are boldface lower case.
• The elements of a matrix or vector are denoted by subscripted values: the element of
A in row i and column j is aij or A(i, j).
• The elements of matrices and vectors can be real or complex numbers.
• I is the identity matrix, and ei is the ith column of I.
• B = AT means that B is the transpose of A: bij = aji. Therefore, (AT )T = A.
• B = A∗means that B is the complex conjugate transpose of A: bij = ¯aji, where the
bar denotes complex conjugate. Therefore, (A∗)∗= A. If A is real, then A∗= AT .
• We’ll use MATLAB notation when convenient. For example, A(3 : 5,1 : 7) denotes
the submatrix of A with row entries between 3 and 5 and column entries between 1
and 7 (inclusive), and A(:,5) denotes column 5 of the matrix A.
1.3
Computer Arithmetic
Computers use binary arithmetic, representing each number as a binary number, a ﬁnite
sum of integer powers of 2. Some numbers can be represented exactly, but others, such as
1/10, 1/100, 1/1000, ..., cannot. For example,
2.125 = 21 +2−3
has an exact representation in binary (base 2), but
3.1 ≈21 +20 +2−4 +2−5 +2−8 +···
does not. And, of course, there are numbers like π that have no ﬁnite representation in
either our usual decimal number system or in binary.
Computers use two formats for numbers. Fixed-point numbers are used to store
integers. Typically, each number is stored in a computer word consisting of 32 binary
digits (bits) with values 0 and 1. Therefore, at most 232 different numbers can be stored.
If we allow for negative numbers, then we can, for example, represent integers in the range
−231 ≤x ≤231 −1, since there are 232 such numbers. Since 231 ≈2.1 × 109, the range
for ﬁxed-point numbers is too limited for scientiﬁc computing. Therefore, they are used
mostly for indices and counters.
As an alternative to ﬁxed-point numbers, ﬂoating-point numbers approximate real
numbers. We’ll discuss features of the most common ﬂoating-point number system, the
IEEE Standard Floating Point Arithmetic.

November 20, 2008 10:52
sccsbook
Sheet number 19 Page number 9
cyan magenta yellow black
1.3. Computer Arithmetic
9
The format for a ﬂoating-point number is
x = ±z ×2p,
where z is called the mantissa or signiﬁcand. This representation is not unique; for exam-
ple,
1 ×22 = 4 ×20 = 8 ×2−1.
Therefore we make the rule that if x ̸= 0, we normalize so that 1 ≤z < 2, choosing the
ﬁrst of the three alternatives in the example.
To ﬁt a ﬂoating-point number in a single word, we need to limit the number of digits
in the mantissa and the exponent. For these single-precision numbers, 24 digits are used
to represent the mantissa, and the exponent is restricted to the range −126 ≤p ≤127. This
allows us to represent numbers as close to zero as 2−126 ≈1.18×10−38 and as far as almost
2128 ≈3.40×1038, a considerably larger range than for ﬁxed-point.
If this range is not large enough, or if 24 digits of precision are not enough, we turn
to double-precision numbers, stored in two words, using 53 digits for the mantissa, with
an exponent −1022 ≤p ≤1023. This allows us to represent numbers as close to zero as
2−1022 ≈2.23×10−308 and as large as almost 21024 ≈1.80×10308.
If we perform a computation in which the exponent of the answer is outside the
allowed range, we have a more or less serious error.
• If the exponent is too big, then we cannot store the answer, and our computation has
produced an overﬂow error. The answer is set to a special representation called Inf
or -Inf to signal an error.
• If the exponent is too small, then the computation produced an underﬂow. If the
number can be stored using the smallest possible exponent and a mantissa that is less
than 1 in magnitude, then the IEEE Standard produces this as the answer.1
• If we divide zero by zero, then the answer is set to a code indicating not-a-number,
NaN.
In double precision, at most 264 different numbers can be represented (including
NaN and ±Inf) so any other number must be approximated by one of the representable
numbers. For example, numbers in the range 1 + 2−53 ≤x < 1 + (2−52 + 2−53) might be
rounded to xm = 1 +2−52, which can be represented exactly. This introduces a very small
error: the absolute error in the representation is
|x −xm| ≤2−53.
Similarly, numbers in the range 1024+2−43 ≤x < 1024+(2−42+2−43) might be rounded
to xm = 1024 +2−42, with absolute error bound 2−43, which is 1024 times bigger than the
bound for numbers near 1. In each case, though, the relative error
|x −xm|
|x|
1Some hardware manufacturers implement this gradual underﬂow only in software, with the faster default
option of setting the answer to zero, thus reducing the reliability of computations and causing difﬁculties with
portability of software [121, Chap. 14].
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 20 Page number 10
cyan magenta yellow black
10
Chapter 1. Errors and Arithmetic
POINTER 1.3. IEEE Standard Floating-Point Arithmetic.
Up until the mid-1980s, each computer manufacturer had a different representation
for ﬂoating-point numbers and different rules for rounding the answer to a computation.
Therefore, a program written for one machine would not compute the same answers on
other machines. The situation improved somewhat with the introduction in 1987 of the
IEEE standard ﬂoating-point arithmetic, now used by virtually all computers.
For more detailed information on ﬂoating-point computer arithmetic, see the excel-
lent book by Overton [121]. In particular, a careful reader might note that we seem to be
storing 33 bits of ﬂoating-point information in a 32 bit word, and the trick that enables us
to avoid storing the leading bit in the mantissa is explained in that book.
POINTER 1.4. Internal Representation vs. Printed Numbers.
In interpreting MATLAB results, remember that if a number x is displayed as 1.0000,
it is not necessarily equal to 1. All you know is that if you round the number to the nearest
decimal number with 5 signiﬁcant (trusted) digits, you get 1. If you want to see whether
it equals 1 exactly, then display x-1. Alternatively, typing format hex changes the
display to the internal machine representation.
is bounded by 2−53 when 53 digits are used for the mantissa.
Let’s pause to consider the difference between the ﬁxed-point number system and the
ﬂoating-point number system.
CHALLENGE 1.1.
For each machine-representablenumber r, deﬁne f(r) to be the next larger machine-
representable number. Consider the following statements:
(a) For ﬁxed-point (integer) arithmetic, the distance between r and f(r) is
constant.
(b) For ﬂoating-point arithmetic, the relative distance |(f(r)-r)/r| is con-
stant (for r ̸= 0).
Are the statements true or false? Give examples or counterexamples to explain your rea-
soning.2
This brings us to a very important parameter that characterizes machine precision:
machine epsilon ϵm is deﬁned as the gap between 1 and the next bigger number; for double
precision, ϵm = 2−52. The relative error in rounding a number is bounded by ϵm/2. Note
that ϵm is much larger than the smallest positive number that the machine can store exactly!
2The solutions to challenges, except those marked “Extra,” can be found on the book’s website.

November 20, 2008 10:52
sccsbook
Sheet number 21 Page number 11
cyan magenta yellow black
1.3. Computer Arithmetic
11
POINTER 1.5. Floating-Point Precision.
By default, MATLAB computes using double-precision ﬂoating-point numbers, and
that is what we use in all of our computations.
There are two features of computer arithmetic that can make predictions of results
difﬁcult:
• Although ﬂoating-point arithmetic uses 64 bits to store a result, sometimes interme-
diate values are stored in 80 bits, giving them extra precision. For example, in the
statement z = a + b + c, the value of a + b might be stored in 80 bits; then c
would be added on, and the rounded result would be stored in 64 bits, specifying the
value of z.
• In some languages such as C and FORTRAN, the sequence of arithmetic operations
that you specify might be modiﬁed by the compiler (the software that translates your
program into machine language) in order to shorten the computation time, making
use of mathematical properties such as commutivity of addition and multiplication,
or the distributive property of multiplication over addition. Since these properties do
not always hold for ﬂoating-point arithmetic (See Challenge 1.4), such optimization
of your program by the compiler can change the computed answer.
The next two challenges provide some practice with ﬂoating-point number systems,
ﬁrst in base 10 and then in base 2.
CHALLENGE 1.2.
Assume you have a base 10 computer that stores ﬂoating-point numbers using a 5
digit normalized mantissa (x.xxxx), a 4 digit exponent, and a sign for each.
(a) For this machine, what is machine epsilon?
(b) What is the smallest positive normalized number that can be represented exactly in this
machine?
CHALLENGE 1.3.
Assume you have a base 2 computer that stores ﬂoating-point numbers using a 6 digit
(bit) normalized mantissa (x.xxxxx), a 4 digit exponent, and a sign for each.
(a) For this machine, what is machine epsilon?
(b) What is the smallest positive normalized number that can be represented exactly in this
machine?
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 22 Page number 12
cyan magenta yellow black
12
Chapter 1. Errors and Arithmetic
(c) What mantissa and exponent are stored for the value 1/10? Hint:
1
10 = 1
16 + 1
32 + 1
256 + 1
512 +
1
4096 +
1
8192 +···.
We’ll experiment a bit with the oddities of ﬂoating-point arithmetic.
CHALLENGE 1.4.
(a) Consider the following program:
x = 1;
delta = 1 / 2^(53);
for j=1:2^(20),
x = x + delta;
end
Using mathematical reasoning, we expect the ﬁnal value of x to be 1 + 2−33. Use your
knowledge of ﬂoating-point arithmetic to predict what it actually is. Verify by running the
program. Explain the result.
(b) Using mathematical reasoning, we know that for any positive number x, 2x is a number
greater than x. Is this true of ﬂoating-point numbers? Run this program fragment and
explain your result:
x = 1;
twox = 2 * x;
k = 0;
while (twox > x)
x = twox;
twox = 2*x;
k = k + 1;
end
(c) Using mathematical reasoning, we know that addition and multiplication are commuta-
tive
x + y = y + x, xy = yx,
and associative
((x + y)+ z) = x +(y + z), (xy)z = x(yz)
and that multiplication distributes over addition:
x(y + z) = xy + xz.

November 20, 2008 10:52
sccsbook
Sheet number 23 Page number 13
cyan magenta yellow black
1.3. Computer Arithmetic
13
Give examples of ﬂoating-point numbers x, y, and z for which addition is not as-
sociative. Find a similar example for multiplication, and a third example showing that
ﬂoating-point multiplication does not always distribute over addition. (Avoid expressions
that evaluate to ±Inf or NaN, even though examples can be constructed using these val-
ues.)
(d) Write a MATLAB expression that gives an answer of NaN and one that gives -Inf.
(e) Given a ﬂoating-point number x, what is the distance between x and the next larger
ﬂoating-point number? (Answer this either by analyzing the machine representation scheme
or by experimenting in MATLAB.) Approximate your answer as a multiple of ϵm.
Our experiments have shown us the following:
• Unlike the ﬁxed-point numbers, the numbers that we can store in ﬂoating-point rep-
resentation are not equally spaced.
• When we do a ﬂoating-point operation (addition, subtraction, multiplication, or di-
vision), we get either exactly the right answer, or a rounded version of it, or NaN, or
an indication of overﬂow.
• The main advantage of ﬂoating-point representation is the wide range of values that
can be approximated with it.
Because of the errors introduced in ﬂoating-point computation, small changes in the
way the data is stored can make large changes in the answer, as we see in the next challenge.
CHALLENGE 1.5.
Suppose we solve the linear system
Ax ≡
 2.00
1.00
1.99
1.00

x =

1.00
−1.00

≡b.
Now suppose that the units for b1 are centimeters, while the units for b2 are meters. If we
convert the problem to meters we obtain the linear system
Cz ≡

0.02
0.01
1.99
1.00

z =

0.01
−1.00

≡d.
Solve both systems in MATLAB using the backslash operator and explain why x is not
exactly equal to z.
If all data were exact and if computers did their arithmetic using real numbers, then
mathematical analysis would tell us all we need to know. Because of uncertainty in data
and use of the ﬂoating-point number system, we need to understand how errors propagate
through computation.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 24 Page number 14
cyan magenta yellow black
14
Chapter 1. Errors and Arithmetic
POINTER 1.6. Numerical Disasters.
Studying error propagation and catastrophic cancellation is not just an academic ex-
ercise. These kinds of errors have led to real disasters: explosion of the Ariane 5 rocket due
to an overﬂow error, and many errors due to rounding, including the 1982 miscalculation
of the index on the Vancouver stock exchange, the 1991 Patriot Missile failure in Saudi
Arabia, and a vote counting error in a 1992 German election. See the websites of Douglas
Arnold [3], Kees Vuik [149], and Thomas Huckle [82] for discussion of these and other
examples. Walter Gander explains the strange “Heisenberg effects in computer arithmetic”
arising from the difference in length between registers and words of memory [53].
1.4
How Errors Propagate
If answers to our calculations were always represented as the ﬂoating-point number closest
to the true answer, then designing accurate algorithms would be easy. Unfortunately, the
computed answer tends to drift away from the true answer due to accumulation of rounding
error. This happens whenever the number of digits is limited, so for convenience, we’ll look
at examples in decimal arithmetic rather than binary.
Suppose we have measured the lengths of two cables (meters):
a = 2.003±0.001,
b = 2.000±0.001.
The absolute error in each measurement is bounded by 0.001, and the relative error in the
second is at most .001/1.999 ≈0.05% (since the true value is at least 1.999). The relative
error in the ﬁrst is also about 0.05%.
What can we conclude about the difference between the two values? The true differ-
ence is at most 2.004−1.999= .005 and at least 2.002−2.001= .001. We obtain the same
information by taking the difference between the measurements and adding the uncertain-
ties: a −b = 0.003±0.002.
When we subtracted the numbers, our bounds on the absolute errors were added.
What happened to our bound on the relative error? If the true answer is 0.001, the relative
error would be (0.003−0.001)/0.001= 200%. This enormous magniﬁcation of the relative
error bound resulted from catastrophic cancellation of the signiﬁcant (trusted) digits in the
two measurements: although the measured values have 4 signiﬁcant digits, the difference
has only 1. Any subsequent computation involving this difference propagates the error.
We could generalize this example to prove a theorem: when adding or subtracting,
the bounds on absolute error add.
What about multiplication and division?
CHALLENGE 1.6.
Suppose x and y are true (nonzero) values and ˜x and ˜y are our approximations to
them. Let’s express the errors as
˜x = x(1 −r),
˜y = y(1 −s).

November 20, 2008 10:52
sccsbook
Sheet number 25 Page number 15
cyan magenta yellow black
1.5. Mini Case Study: Avoiding Catastrophic Cancellation
15
(a) Show that the relative error in ˜x is |r| and the relative error in ˜y is |s|.
(b) Show that we can bound the relative error in ˜x ˜y as an approximation to xy by

˜x ˜y −xy
xy
 ≤|r|+|s|+|rs|.
Since we expect the relative errors r and s to be much less than 1, the quantity |rs| is
expected to be very small compared to |r| and |s|. Therefore, when multiplying or dividing,
the bounds on relative errors (approximately) add.
Notice that these statements about errors after arithmetic operations assume that the
computed solution is stored exactly; additional error may result from rounding to the near-
est ﬂoating-point number.
CHALLENGE 1.7.
Consider the following MATLAB program:
x = .1;
sum = 0;
for i=1:100,
sum = sum + x;
end
Is the ﬁnal value of sum equal to 10? If not, why not?
In computations where error build-up can occur, it is good to rearrange the compu-
tation to avoid cancellation whenever possible. We’ll consider a familiar example, ﬁnding
the roots of a quadratic polynomial, next.
1.5
Mini Case Study: Avoiding Catastrophic Cancellation
Suppose we are asked to ﬁnd the roots of the polynomial
x2 −56x +1 = 0.
The usual formula, which you may have learned in an algebra class, computes
x1
=
28 +
√
783
≈
28 +27.982
=
55.982
(±0.0005),
x2
=
28 −
√
783
≈
28 −27.982
=
0.018
(±0.0005).
The error arose from approximating
√
783 by its correctly rounded value, 27.982. The
absolute error bounds are the same, but the relative error bounds are about 10−5 for x1 and
0.02 for x2 – vastly different!
The problem, of course, was catastrophic cancellation in the computation of x2, and
it is easy to convince yourself that for any quadratic with real roots, the quadratic formula
causes some cancellation during the computation of one of the roots.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 26 Page number 16
cyan magenta yellow black
16
Chapter 1. Errors and Arithmetic
We can avoid this cancellation by using other facts about quadratic equations and
about square roots. We consider three possibilities.
• Use an alternate formula. The product of the two roots equals the constant term in
the polynomial,3 so x1x2 = 1. If we compute
x2 = 1
x1
,
then our relative error is bounded by 10−5, the relative error in our value for x1, so
we obtain
x2 ≈.0178629(±2 ×10−7),
accurate to the same relative error.
• Rewrite the formula. Notice that
x2 = 28 −
√
783 =
√
784−
√
783.
Let’s derive a better formula for the difference of these square roots:
√
z +e −√z = (
√
z +e−√z)
√z +e+√z
√z +e+√z
=
z +e −z
√z +e +√z
=
e
√z +e +√z .
Therefore, letting z = 783 and e = 1, we calculate
x2 =
1
28 +
√
783
,
giving the same result as above but from a different approach.
• Use Taylor series. Let f (x) = √x. Then
f (z +e)−f (z) = f ′(z)e + 1
2 f ′′(z)e2 +···,
so we can approximate the difference by f ′(z)e = 1/(2
√
783).
CHALLENGE 1.8. (Extra)
Write a MATLAB function that computes the two roots of a quadratic polynomial
with good relative precision.
3This is true since x2 −56x +1 = (x −x1)(x −x2).

November 20, 2008 10:52
sccsbook
Sheet number 27 Page number 17
cyan magenta yellow black
1.6. How Errors Are Measured
17
POINTER 1.7. Symbolic Computation.
Some people claim that the pitfalls in ﬂoating-point arithmetic are best avoided by
avoiding ﬂoating-point arithmetic altogether, and instead using symbolic computation sys-
tems such as MAPLE (http://www.maplesoft.com) (available with MATLAB) or
MATHEMATICA (www.wolfram.com). These systems are incredibly useful, but even-
tually they produce a formula that needs to be evaluated using arithmetic. These systems
have pitfalls of their own: the computation can use a tremendous amount of time and stor-
age, and they can produce formulas that lead to unnecessarily high relative and absolute
errors.
1.6
How Errors Are Measured
Error analysis determines the cumulative effects of error. We have been using forward error
analysis, but there are alternatives, including backward error analysis.
• In forward error analysis, we ﬁnd an estimate for the answer and bounds on the
error. Schematically, we see in the top of Figure 1.3 that we have a space of all
possible problems and a space of their solutions. We are given a problem whose
true solution is unknown. We compute a solution and report that solution along with
a bound on the distance between the computed solution and the true solution. For
example, we might compute the answer 5.348 and determine that the true answer is
5.348± .001. Or, for a vector solution, we might report that ∥xc −xtrue∥≤10−5,
where xc is the computed solution and xtrue is the true solution.
• In backward error analysis, we again are given a problem whose true solution is
unknown. We compute a solution, and report that solution along with a bound on the
difference between the problem we solved and the given problem. This is illustrated
in the bottom of Figure 1.3.
Let’s determine forward and backward error bounds for a simple problem.
CHALLENGE 1.9.
Suppose the sides of a rectangle have lengths 3.2± .005 and 4.5 ± .005. Consider
approximating the area of the rectangle by A = 14.
(a) Give a forward error bound for A as an approximation to the true area.
(b) Give a backward error bound.
It might be hard to imagine a situation in which backward error analysis provides
any useful information, but think back to our bridge. Suppose we compute a solution to a
problem for which the measurements differ from our measurements by 10−5. If the error
bounds in our measurements are greater than 10−5, then we may have computed the stresses
for the true bridge! In any case, the solution we computed is as reasonable as one for any
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 28 Page number 18
cyan magenta yellow black
18
Chapter 1. Errors and Arithmetic
Forward Error Analysis:
Report the computed solution and a region known to
contain both the true and computed solutions.
Problem space
Solution space
*
*
Given
problem
Region guaranteed
to contain both solutions.
o
Computed
solution
True solution
(unknown)
Backward Error Analysis:
Report the computed solution and a region known to
contain both the given and solved problems.
Problem space
Solution space
*
*
Given
problem
o
Problem
solved
True solution
(unknown)
o
Computed
solution
Region guaranteed
to contain both problems.
Figure 1.3. In forward error analysis, we ﬁnd bounds on the distance between the
computed solution and the true solution. In backward error analysis, we ﬁnd bounds on the
distance between the problem we solved and the problem we wanted to solve.

November 20, 2008 10:52
sccsbook
Sheet number 29 Page number 19
cyan magenta yellow black
1.6. How Errors Are Measured
19
other problem in the uncertainty intervals, so we can be quite satisﬁed with the outcome.
In general, backward error statements are quite useful when the data has uncertainty.
Backward error estimates also tend to be less pessimistic than forward error esti-
mates, since they don’t involve taking a worst-case bound after every computation. Back-
ward error estimates are usually derived at the end of the algorithm. For example, if we
compute an approximate solution xc to a linear system of equations
Ax = b,
then we can test how good it is by evaluating the residual
r = b−Axc.
If xc equals the true solution, then r = 0; if it is a good approximation, then we expect
r ≈0. In any case, we know that our computed solution xc is the exact solution to the
nearby problem
Axc = b−r,
so ∥r∥gives us a backward error bound.
Here are two examples to provide some experience in computing error bounds.
CHALLENGE 1.10.
Bound the backward error in approximating the solution to

2
1
3
6

x1
x2

=

5.244
21.357

by xc =

1
3

.
CHALLENGE 1.11.
Suppose that you have measured the length of the side of a cube as (3.00 ± .005)
meters. Give an estimate of the volume of the cube and a (good) bound on the absolute
error in your estimate.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 30 Page number 20
cyan magenta yellow black
20
Chapter 1. Errors and Arithmetic
1.7
Conditioning and Stability
It is important to distinguish between difﬁcult problems and bad algorithms.
We say that a problem is well-conditioned if small changes in the data always make
small changes in the solution; otherwise it is ill-conditioned. Similarly, an algorithm is
stable if it always produces the solution to a nearby problem, and unstable otherwise.4
To illustrate these ideas, consider the linear system of equations

δ
1
1
1

x1
x2

=

1
0

,
where δ is a small positive number. Suppose we solve the system on a computer for which
δ < ϵm/2. If use Gauss elimination without pivoting, we compute

δ
1
0
−1/δ

x1
x2

=

1
−1/δ

so
x2 = 1,
x1 = 0.
The true solution is
xtrue =

−1
1−δ
1
1−δ

,
so our answer is very bad. The problem is well-conditioned, though; we can see this
graphically on the left in Figure 1.4, since small changes in any of the coefﬁcients of the
two lines move the intersection point by just a little. Therefore, Gauss elimination without
pivoting must be an unstable algorithm. If we use pivoting, our answer improves: the linear
system is rewritten as
 1
1
δ
1
 x1
x2

=
 0
1

,
so the elimination gives us
 1
1
0
1
 x1
x2

=
 0
1

from which we determine that
x2 = 1, x1 = −1.
This is quite close to the true solution.
Consider a second example with 3 digit decimal arithmetic:
 0.661
0.991
0.500
0.750
 x1
x2

=
 0.330
0.250

.
(1.1)
If we compute the solution with pivoting, truncating all intermediate results to 3 digits, we
obtain
xc =

−.470
.647

.
4Actually, for historical reasons, well-conditioned problems are sometimes called stable in some areas of
scientiﬁc computing, but it is best to use the term well-conditioned to avoid confusion.

November 20, 2008 10:52
sccsbook
Sheet number 31 Page number 21
cyan magenta yellow black
1.7. Conditioning and Stability
21
−2
−1.8
−1.6
−1.4
−1.2
−1
−0.8
−0.6
−0.4
−0.2
0
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
Equations for Linear System 1
x1
x2
−2
−1.8
−1.6
−1.4
−1.2
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
Equations for Linear System 2
x1
x2
Figure 1.4. (Left) Plot of a well-conditioned system of linear equations. Points
on the red line satisfy δx1 + x2 = 1, and points on the blue line satisfy x1 + x2 = 0. Small
changes in the data move the intersection of the two lines by a small amount. (Right) Plot
of an ill-conditioned system of linear equations. Small changes in the data can move the
intersection of the two lines by a large amount. This is the example in equation (1.1) except
that the (1,1) coefﬁcient in the matrix has been changed from 0.661 to 0.630 so that the two
lines are visually distinct.
The true solution is quite far from this:
xtrue =

−1.000
1.000

.
But when we substitute our computed solution back into (1.1), we see that the residual, or
difference between the left and right sides, is
r =

−.000507
−.000250

.
Gauss elimination with pivoting produced a small residual because it is a stable algorithm,
so it is guaranteed to solve a nearby problem. But the x-error is not small, since the problem
is ill-conditioned. We can see this graphically on the right in Figure 1.4; if we wiggle the
coefﬁcients of the two lines, we can make the intersection move quite a bit.
Sometimes we have additional information about the solution to a problem that gives
us some guidance about improving a computed solution, as in the next challenge.
CHALLENGE 1.12.
Suppose you solve the nonlinear equation f (x) = 0 using a MATLAB routine, and
the answers are complex numbers with small imaginary parts. If you know that the true
answers are real numbers, what would you do?
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 32 Page number 22
cyan magenta yellow black
22
Chapter 1. Errors and Arithmetic
POINTER 1.8. Further Reading.
Further information on this material can be found in the book by Overton [121] on
IEEE ﬂoating-point arithmetic and the book by Higham [79], which focuses on the impact
of ﬂoating-point arithmetic on algorithms.
Life may toss us some ill-conditioned problems, but there is no good reason to settle
for an unstable algorithm.
In the next chapter we illustrate various ways of measuring the sensitivity or condi-
tioning of a problem.

November 20, 2008 10:52
sccsbook
Sheet number 33 Page number 23
cyan magenta yellow black
Chapter 2
Sensitivity Analysis:
When a Little Means
a Lot
In contrast to classroom exercises, it is rare to be given a problem in which the data is
known with absolute certainty. There are some parameters, such as π, that we can deﬁne
with certainty, and others like Planck’s constant ¯h that we know to high precision, but most
data is measured and therefore contains signiﬁcant measurement error.
So what we really solve is not the problem we want, but some nearby problem, and
in addition to reporting the computed solution, we really need to report a bound on either
• the difference between the true solution and the computed solution (a forward error
bound), or
• the difference between the problem we solved and the problem we wanted to solve
(a backward error bound).
This need occurs throughout computational science. Consider these examples:
• If we compute the resonant frequencies of a building, we want to know how these
frequencies change if the load within the building changes a little.
• If we compute the stresses on a bridge, we want to know how sensitive these values
are to changes that might occur as the bridge ages.
• If we develop a model for our data and ﬁt the parameters, we want to know how
much the parameters change when the data is wiggled within the uncertainty limits.
In this chapter we use some simple problems to investigate the use of several tools
for sensitivity analysis.
2.1
Sensitivity Is Measured by Derivatives.
The best way to measure the sensitivity of a variable x to a small change in a parameter t
is to compute dx/dt, since, by Taylor series, if δ is a small number, then
x(t +δ) ≈x(t)+δ dx
dt (t).
23
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 34 Page number 24
cyan magenta yellow black
24
Chapter 2. Sensitivity Analysis: When a Little Means a Lot
Therefore, the change in x due to a small change in t is approximately proportional to
dx/dt (whenever the second derivative d2x/dt2 is bounded). Sometimes the derivative
does not exist, and sometimes it is too expensive to compute, but whenever possible, this is
the method of choice.
As an example, let’s use the derivative to get insight into the sensitivity of roots of a
quadratic equation to changes in the coefﬁcients.
CHALLENGE 2.1.
Suppose x1 and x2 are the roots of the quadratic equation
x2 +bx +c = 0.
(a) Use implicit differentiation to compute dx/db.
(b) We know that the roots are
x1,2 = 1
2(−b ±

b2 −4c).
Differentiate this expression with respect to b and show that the answer is equivalent to the
one you obtained in (a).
(c) Find values of b and c for which the roots are very sensitive to small changes in b, and
values for which they are not very sensitive.
If there are several parameters to vary, then the partial derivatives of the variable with
respect to the parameters yield the sensitivity information.
Derivatives also give sensitivity information for constrained problems. For example,
if we want to minimize a function f (x) subject to the constraints h(x) = 0, then we learned
in calculus to introduce Lagrange multipliers λ, one per constraint, and look for solutions
(xsol,λsol) for which the Lagrangian function
L(x,λ) = f (x)−λT h(x)
has a zero gradient. The “artiﬁcial” variables λ actually have a physical meaning: λi is
the partial derivative of L with respect to the constraint hi. Therefore, the value of a
multiplier at a point where h(x) = 0 measures the sensitivity of f to small changes in
the corresponding constraint. For this reason, Lagrange multipliers are sometimes called
marginal values or reduced costs. We’ll see an example of their use in Challenge 2.3.
2.2
Condition Numbers Give Bounds on Sensitivity.
Although the derivatives of the variable with respect to the parameters provide the “gold
standard” for sensitivity analysis, differentiation is not always practical. For example, a
linear system of equations with 100 variables has 104 coefﬁcients in the matrix, and that
is a lot of partial derivatives to compute and assess! Because of that, shortcuts have been
developed to give less speciﬁc information but summarize what can happen in the worst

November 20, 2008 10:52
sccsbook
Sheet number 35 Page number 25
cyan magenta yellow black
2.2. Condition Numbers Give Bounds on Sensitivity.
25
POINTER 2.1. Matrix and Vector Norms.
The size of an n ×1 vector x is usually measured using the familiar 2-norm:
∥x∥2 =

|x1|2 +···+|xn|2.
There are alternatives, though, including
∥x∥1 = |x1|+···+|xn|,
∥x∥∞= max
j
|xj|.
Similarly, there are many matrix norms. In particular, for each vector norm ∥·∥, we deﬁne
a matrix norm by
∥A∥= max
x̸=0
∥Ax∥
∥x∥.
Computing a matrix norm using this deﬁnition is a difﬁcult problem, but fortunately there
are shortcuts. It can be shown that for an m ×n matrix A
∥A∥1 = max
j
m
	
i=1
|aij|,
∥A∥2 =

max
j
λj(A∗A),
∥A∥∞= max
i
n
	
j=1
|aij|,
where λj(A∗A) ( j = 1,...,n) denotes the eigenvalues of the conjugate transpose of A times
A. One other norm, the Frobenius norm, is also useful. It is the 2-norm of the matrix A
after stacking its columns:
∥A∥F =




n
	
j=1
m
	
i=1
|aij|2.
In this book, if you see a norm without a subscript, assume that the 2-norm is used.
Two properties of norms are useful to know: if A and B are matrices and x is a vector,
then for all of these norms, ∥AB∥≤∥A∥∥B∥and ∥Ax∥≤∥A∥∥x∥.
case for perturbations of a given size. These shortcuts involve computing a condition
number for the problem.
Given a condition number, we can make statements such as the following: If the
matrix A is changed to A+A, where
∥A∥
∥A∥≤δ,
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 36 Page number 26
cyan magenta yellow black
26
Chapter 2. Sensitivity Analysis: When a Little Means a Lot
POINTER 2.2. Eigenvalues, Determinants, and Condition Numbers.
People often try to measure the sensitivity of the solution to the problem Ax = b using
eigenvalues or the determinant of A, saying that if there is an eigenvalue close to zero, or
if the determinant is very small, then the problem is ill-conditioned. We notice, though,
that the solution to Ax = b is also the solution to (cA)x = (cb) for any nonzero constant c.
Multiplying by c changes the eigenvalues by a factor of c and the determinant by a factor
cn. By changing c, we can make the determinant of A (or some eigenvalue of A) arbitrarily
big or arbitrarily close to zero. The condition number of A is independent of scale and is
the number that correctly characterizes the sensitivity of x to relative changes in the data,
as we will see in Pointer 5.3.
and δ is a small number, then the difference between the solution x to the linear system
Ax = b
and the solution y to the linear system
(A+A)y = b
is bounded by
∥x−y∥
∥x∥
≤
κ(A)
1 −κ(A)δδ,
(2.1)
where κ(A) is the condition number of A. This bound is valid when δ < 1/κ(A) and holds
for the 1, 2, or ∞norm.
By its very nature, (2.1) is a worst-case statement, since it needs to hold for all per-
turbations A that are small enough. For some values of A, the error bound (2.1) can
be a serious overestimate, but there always exists some particular matrix A for which the
bound is tight.
Condition numbers enable us to replace the full set of partial derivatives by a sin-
gle number, but even that one number may be hard to compute. For example, for (2.1),
the condition number of A is deﬁned to be κ(A) = ∥A∥∥A−1∥. The norm of A is usu-
ally easy to compute; see Pointer 2.1. Even so, computing the norm of A−1 is quite ex-
pensive, since computing the inverse of a matrix is expensive (and generally not a good
idea). Therefore, the condition number is usually estimated. In MATLAB we can use
cond(A,normtype) to compute the condition number (setting normtype to 1, 2, or
inf), or use the cheaper function condest to estimate the condition number.
CHALLENGE 2.2.
Consider the linear system Ax = b with
A =

δ
1
1
1

, b =

1
0

,
and δ = 0.002.

November 20, 2008 10:52
sccsbook
Sheet number 37 Page number 27
cyan magenta yellow black
2.3. Monte Carlo Experiments Can Estimate Sensitivity.
27
(a) Plot the two equations deﬁned by this system and compute the condition number of A
(cond(A)).
(b) Compute the solution xtrue to Ax = b and also compute the solution to the nearby
systems
(A+A(i))x(i) = b
for i = 1,...,1000, where the elements of A(i) are independent and normally distributed
with mean 0 and standard deviation τ = .0001. (You can generate these examples by setting
each DeltaA = tau*randn(2,2).) Plot the 1000 points (e(i)
1 ,e(i)
2 ) with e(i) = x(i) −
xtrue. This plot reveals the forward error in using (A + A(i)) as an approximation to A.
In a separate ﬁgure, plot the 1000 residuals (r(i)
1 ,r(i)
2 ) with r(i) = b −Ax(i) (the backward
error) for each of the computed solutions.
(c) Repeat (a) and (b) with the linear system Ax = b with
A =

1 +δ
δ −1
δ −1
1 +δ

, b =

2
−2

.
(d) Discuss your results. Why do the forward error plots for the two problems look so
different? How does the condition number relate to what you see in the forward error
plots? What do the backward error plots tell you?
2.3
Monte Carlo Experiments Can Estimate Sensitivity.
In Challenge 2.2(b) you did a Monte Carlo experiment, discussed in more detail in Chapter
16. The idea is to randomly sample nearby problems and see how the solution changes.
This is a ﬁne way to measure sensitivity if a condition number would not give enough
information and if derivatives cannot be obtained, but the process can be expensive.
Let’s try two more applications of Monte Carlo to estimate sensitivity, one involving
linear programming and one involving a differential equation.
CHALLENGE 2.3.
Investigate the sensitivity of the linear programming problem
min
x cT x
subject to
Ax ≤b,
x ≥0.
(a) For Example 1, let A = [1,1], b = 1, and cT = [−3,−1]. Solve the linear program
(using, for example, MATLAB’s linprog from the Optimization Toolbox) and use the
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 38 Page number 28
cyan magenta yellow black
28
Chapter 2. Sensitivity Analysis: When a Little Means a Lot
Lagrange multipliers (also called dual variables) to evaluate the sensitivity of cT x to small
changes in the constraints. Illustrate this sensitivity using a Monte Carlo experiment, solv-
ing 100 problems with A replaced by A + A(i), where the elements of A(i) are uni-
formly distributed on the interval [−τ,τ], with τ = 0.001. (You can do this by setting each
deltaA = 2*tau*(rand(1,2)-.5*ones(1,2)).) Plot all of the solutions in one
ﬁgure, and all of the function values cT x in another.
(b) Repeat for two more examples:
Example 2: A = [1,1], b = 1, cT = [−1.0005,−0.9995].
Example 3: A = [0.01, 5], b = 0.01, cT = [−1,0].
(c) Explain how the Lagrange multiplier for the constraint Ax ≤b gives insight into the
sensitivity observed in the corresponding Monte Carlo experiment.
CHALLENGE 2.4.
Consider the very simple differential equation
y′(t) = ay(t),
where y(0) = 1 and a(t) is given. Let’s investigate the sensitivity of the equation to pertur-
bations in a.
(a) To make the problem concrete, the population growth rate a(t) of the U.S. can be di-
vided into two pieces: a rate of 0.006 due to births and deaths, and a rate of 0.003 due to
migration. Determine how much the population increases over the next 50 years if this rate
stays constant, and how much it increases if migration is set to zero.
(b) Then perform Monte Carlo experiments to see how sensitive the solution is to changes
in the population growth rate. Assume that the rate can change each year. For each experi-
ment, choose the birth/death rate for each year from a normal distribution with mean 0.006
and standard deviation 0.001, and choose the migration rate from a uniform distribution on
the interval [0,0.003].
(c) Also experiment with what happens if years of high growth rate come early, followed
by years of low growth rate, and vice versa.
2.4
Conﬁdence Intervals Give Insight into Sensitivity
Another way to assess sensitivity is to make a statement like the following: If we repeat
the data measurement many times, then we expect that 95% of the time the solution lies in
the interval [xlo,xup]. Such an interval is called a conﬁdence interval, and α = .95 is the
conﬁdence level, determined using statistical estimation, assuming that the errors in the
measurements are random.

November 20, 2008 10:52
sccsbook
Sheet number 39 Page number 29
cyan magenta yellow black
2.4. Conﬁdence Intervals Give Insight into Sensitivity
29
As an example, consider a linear system Ax = b and assume that the error b −btrue
is (multivariate) normally distributed with mean 0 and variance S2. Suppose that we want
to estimate the value of wT x; taking w to be the ﬁrst column of the identity matrix, for
example, gives us an estimate of x1. We proceed as follows:
• Determine a value κ from the cumulative normal distribution, so that
1
√
2π
 +κ
−κ
e−z2/2 dz = α.
(2.2)
For 95% conﬁdence intervals, α = 0.95 and κ ≈1.960.
• Given the value κ, letx solve Ax = b and compute
φlo = wTx−κ

wT (AT S−2A)−1w,
φup = wTx+κ

wT (AT S−2A)−1w.
Then [φlo,φup] is a 100α% conﬁdence interval for wT x.
There are more general forms of the procedure. It is possible to construct (wider)
conﬁdence intervals that have joint probability α so that, for example, we can bound all
the components of x simultaneously. There is also a nonparametric form of the result that
allows us to compute conﬁdence intervals when the error is not normally distributed. See
Pointer 2.3 for some references.
Let’s apply our procedure to the examples from Challenge 2.2.
CHALLENGE 2.5.
Using the ﬁrst linear system from Challenge 2.2, perform a Monte Carlo experiment
that computes the solution to the nearby systems
Ax(i) = b+e(i)
for i = 1,...,1000, where the elements of e(i) are independent and normally distributed
with mean 0 and standard deviation τ = 0.0001 (so that S = τI). Compute 95% conﬁdence
intervals on each component of the solution and see how many of the components of the
Monte Carlo samples lie within the conﬁdence limits.
Repeat for the second linear system from Challenge 2.2.
We have experimented with several ways to measure sensitivity in our problems, and
Pointer 2.3 gives additional alternatives. A good computational scientist computes not just
an answer to a problem but an assessment of how good it is, and sensitivity analysis is an
important component in this assessment.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 40 Page number 30
cyan magenta yellow black
30
Chapter 2. Sensitivity Analysis: When a Little Means a Lot
POINTER 2.3. Further Reading.
Lagrange multipliers are discussed in Unit III, in standard advanced calculus text-
books, and in textbooks on optimization, such as that by Nash and Sofer [111].
Condition numbers are commonly used in numerical linear algebra to measure sen-
sitivity of linear systems of equations, eigenvalues, eigenvectors, and other quantities. The
book by Higham [79] is a good reference.
See the book by Fishman [49] for more information on Monte Carlo estimation.
Standard statistical textbooks explain the use of conﬁdence intervals. These methods
can also be applied to constrained problems, as seen, for example, in [130].
One alternative to the methods we considered is interval analysis. In this method,
we carry upper and lower bounds on each quantity along through our calculations. The
result is a rigorous, although often pessimistic, set of forward error bounds on the answer.
The method’s most forceful advocate was R. E. Moore [110], and there are many textbooks
that apply the method to scientiﬁc computing.
A second alternative is the use of symbolic computation, in which we carry analytic
expressions for each quantity; see Pointer 1.7.

November 20, 2008 10:52
sccsbook
Sheet number 41 Page number 31
cyan magenta yellow black
y(8)
A(16,1)
A(15,1)
y(7)
A(14,1)
y(6)
A(13,1)
y(5)
A(12,1)
y(4)
y(3)
A(11,1)
y(2)
A(10,1)
y(1)
A(9,1)
Chapter 3
Computer Memory
and Arithmetic: A
Look under the
Hood
You have many places where you store data. You might keep your identiﬁcation and credit
cards in your wallet, where you can get to them quickly. Space is limited, though, so
you can’t keep all important information there. You might carry current papers for work or
school in a backpack or briefcase. Older papers might be stored in your desk or ﬁle cabinet.
And papers that you don’t think you need but are afraid to throw out might be stored in an
attic, basement, or storage locker. Your wallet, backpack, desk, and attic form a hierarchy
of storage spaces. The small ones give you fast access to data that you often need, while
the larger ones give slower access but more space.
For the same reasons, computers also have a hierarchy of storage units. Memory
management systems try to store information that you will soon need in a unit that gives
fast access. This means that large vectors and arrays are broken up and moved piece by
piece as needed. You can write a correct computer program without ever knowing about
memory management, but attention to memory management allows you to consistently
write programs that don’t have excessive memory delays.
In this chapter, we’ll consider a model of computer memory organization. We’ll
hide some detail but discuss making decisions about how to organize our computations
for efﬁciency. We’ll use mathematical modeling to estimate the memory parameters for a
typical computer. Then we’ll see how important these parameters are relative to the speed
of ﬂoating-point arithmetic.
Our discussions assume that the computation is being performed by a single proces-
sor on a machine that possibly has many processors (multicore). When the full power of a
multicore system is used to solve a problem, then obviously memory management becomes
more complicated!
3.1
A Motivating Example
Suppose we have an m ×n matrix A and an n ×1 vector x. To form y = Ax in MATLAB,
we just write y = A * x, but let’s consider how this might be implemented. The vector
31
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 42 Page number 32
cyan magenta yellow black
32
Chapter 3. Computer Memory and Arithmetic
y can be deﬁned by inner-products (also called dot-products) between x and rows of A: for
i = 1,...,m,
yi = A(i, :)∗x.
(3.1)
In contrast to this row-oriented algorithm, we can also deﬁne Ax using a column-oriented
algorithm:
y = Ax = x(1)∗A(: ,1)+ x(2)∗A(: ,2)+···+ x(n)∗A(: ,n).
(3.2)
This scheme is based on an operation called axpy, which is an abbreviation for ax + y.
We work left to right through our expression, taking a scalar times a vector and adding
it to a previously accumulated vector. Thus we initialize y to zero and then compute y =
y+ x( j)∗A(: , j) for j = 1,...,n.
These algorithms both have the same rounding properties and take almost the same
number of numeric operations: mn multiplications and m(n −1) or mn additions. But,
surprisingly, the time taken by the two algorithms is quite different.
CHALLENGE 3.1.
Program the two algorithms in MATLAB. Time them for a random matrix A and a
random vector x for m = n = 1024, and verify that they yield the same product Ax but take
a different amount of time (as measured by tic and toc).
Your results should have indicated that the second algorithm is much faster than
the ﬁrst when m and n are large. The speed difference is due to memory management;
MATLAB stores matrices column by column, and if we want a fast implementation, we
must use this fact in design of our algorithm.
3.2
Memory Management
The computer memory hierarchy includes registers, cache, main memory, and disk.
Arithmetic and logical operations are performed on the contents of registers. The other
storage units are accessed when data is on its way to or from the registers. It is as if when-
ever you need to change some data in your attic, you move it ﬁrst to your desk, then to
your backpack, then to your wallet, make the correction, and move it back through wallet,
backpack, and desk, ﬁnally storing it back in the attic.
A small illustration of memory management is given in Figure 3.1. We’ll consider a
1-level cache, although most machines have a hierarchy of cache units. Let’s see how infor-
mation is moved between main memory and cache in forming y = Ax using (3.2). Suppose
that A is a matrix of size m ×n, with m = 128 and n = 32, and suppose for ease of count-
ing that the ﬁrst element in each matrix and vector lies in the ﬁrst element of some page
of main memory. The matrix elements are stored in the order A(1,1),...,A(128,1),
A(1,2),...,A(128,2),..., A(1,32),...,A(128,32).
Cache memory is
loaded by block (also called a cache line); in this example, this means 8 elements at a
time. So in the axpy implementation, where we successively add xj ∗A(:, j) to y, the com-
puter ﬁrst loads A(1,1),...,A(8,1) into one block of the cache, x(1),...,x(8)
into a second block (since the value of x(1) is needed), and lets y(1),..., y(8) oc-
cupy a third block (Figure 3.1, top). (Note that y must be loaded into cache, since at later

November 20, 2008 10:52
sccsbook
Sheet number 43 Page number 33
cyan magenta yellow black
3.2. Memory Management
33
Stage 1:
A(8,1)
x(8)
y(8)
Old data
A(7,1)
x(7)
Old data
y(7)
A(6,1)
x(6)
Old data
y(6)
A(5,1)
x(5)
Old data
y(5)
A(4,1)
x(4)
Old data
y(4)
A(3,1)
x(3)
y(3)
Old data
A(2,1)
x(2)
y(2)
Old data
A(1,1)
x(1)
y(1)
Old data
Stage 2:
y(16)
x(8)
y(8)
A(16,1)
y(15)
x(7)
A(15,1)
y(7)
y(14)
x(6)
A(14,1)
y(6)
y(13)
x(5)
A(13,1)
y(5)
y(12)
x(4)
A(12,1)
y(4)
y(11)
x(3)
y(3)
A(11,1)
y(10)
x(2)
y(2)
A(10,1)
y(9)
x(1)
y(1)
A(9,1)
Figure 3.1. State of a cache memory of 4 blocks, 8 words each, during two stages
of the matrix-vector product algorithm. The red blocks are the ones that were least recently
used.
times through the loop it is nonzero.) After x(1)*A(1:8,1) is added into y(1:8), we
then need A(9,1),...,A(16,1) and y(9),...,y(16). In this example we have
only 4 blocks of cache, though, so to access the ﬁfth block of data we overwrite some old
block, after being sure that any updated values are changed in main memory. In our case,
the old y-block or A-block disappears from cache (Figure 3.1, bottom).
Loading 5 blocks from main memory into the cache has allowed us to do 16 of our
128 ∗32 multiplications. We continue the count in the next challenge.
CHALLENGE 3.2.
(a) Count the number of blocks that are moved from main memory into the cache memory
in Figure 3.1 for each of the two matrix-vector multiplication algorithms (3.1) and (3.2)
with m = 128 and n = 32. If a cache block needs to be written over, choose the least-
recently-used block.
(b) How does your answer change if matrices are stored row-by-row (as in C, C++, or Java)
rather than column-by-column (as in MATLAB or FORTRAN)?
In contrast to row- and column-oriented algorithms, we might choose to store our
matrix in block-matrix order. For example, if our matrix is 4 × 4, we might divide it into
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 44 Page number 34
cyan magenta yellow black
34
Chapter 3. Computer Memory and Arithmetic
four 2 ×2 submatrices:
⎡
⎢⎣
a11
a12
a13
a14
a21
a22
a23
a24
a31
a32
a33
a34
a41
a42
a43
a44
⎤
⎥⎦
and store the elements in the order a11,a21,a12,a22, a31,a41,a32,a42, a13,a23,a14,a24, a33,
a43,a34,a44. If each submatrix ﬁts in a single memory block, then it can be moved efﬁ-
ciently and used in computation.
CHALLENGE 3.3. (Extra)
Suppose that the m ×n matrix A is stored in k ×k blocks, with m = 128, n = 32, and
k = 8. Write an efﬁcient algorithm for forming Ax for a given vector x.
3.3
Determining Hardware Parameters
We see that memory management matters in matrix multiplication! It is certainly faster
to use the algorithm that has fewer moves of blocks into cache, but how much it matters
depends on memory parameters such as the following:
• b = the number of blocks that can be held in cache memory.
• ℓ= the number of double-precision words in a block.
• α = the time to access a double-precision word in cache (nanoseconds).
• μ = the extra time needed for access if the word is not already in cache, also known
as the cache miss penalty (nanoseconds).
To estimate the memory parameters, we can run a program that constructs a long
vector z of length m and then steps through it, incrementing some elements. When we step
through every element, we are almost always accessing a value that can be found in cache.
If we step through elements z(1),z(1 + s),z(1 + 2s),..., where the stride s is bigger than
the block size ℓ, then we always get a cache miss penalty (unless the hardware correctly
guesses our next request and pre-fetches the block before we ask for it). By varying s we
can estimate the block size, and by cycling through the computation several times, we can
estimate the size of the cache. Consider the following program fragment, written in C:
steps = 0;
i = 1;
do
{
z(i);
steps = steps + 1;
i = i + s;
if (i > m)
i = 1;
end }
while (steps < naccess)

November 20, 2008 10:52
sccsbook
Sheet number 45 Page number 35
cyan magenta yellow black
3.3. Determining Hardware Parameters
35
The loop makes naccess accesses to the array z, where naccess is a suitably
large number. If we time the loop, subtract off the loop overhead (estimated by timing a
similar loop with the statement z(i) omitted), and divide the resulting time by naccess,
we estimate the average time for one access.
We see how this works in the next challenge.
CHALLENGE 3.4.
Suppose our cache memory has parameters b = 4, ℓ= 8, α = 1 ns, and μ = 16 ns.
Assume that when necessary we replace the block in cache that was least-recently used,
and that we set naccess=256 in the program fragment above. Consider the following
table of estimated times per access in nanoseconds and show how each entry is derived.
s
m = 16
m = 32
m = 64
m = 128
1
1.125
1.250
3.000
3.000
2
1.125
1.250
5.000
5.000
4
1.125
1.250
9.000
9.000
8
1.125
1.250
17.000
17.000
16
1.063
1.125
1.250
17.000
If we work in a high-performance “compiled” language such as FORTRAN or a C-
variant, we can use our timings of program fragments to estimate the cache miss penalty.
In “interpreted” MATLAB, overhead masks the penalty.
Whenever we time a program, though, there are many sources of uncertainty:
• Other processes are running. Even if you are running on a laptop on which you
are the only user, the operating system (Windows, Linux, ...) is still doing many
other tasks, e.g., refreshing the screen, updating the clock, tracking the cursor. Most
systems have two timers, one that gives the elapsed time (e.g., tic, toc) and one
that tries to capture the time used by this process alone (e.g., cputime).
• There is uncertainty in the timer, so the data you collect are noisy. Most timers give
trash unless they are timing intervals that are at least a millisecond, and they are
much better at intervals near one second. Therefore, the loop you are timing should
do as many operations as possible, but not so many that interruptions by other active
processes contaminate elapsed time.
• The time for arithmetic operations often depends on the values of the operands. For
instance, dividing by a power of 2 is usually much faster than dividing by other
numbers, and adding zero is usually faster than other additions.
• The computer uses pipelining. This occurs on many levels but the fundamental idea
is that the execution of each instruction that we give the computer is partially over-
lapped with other instructions, so it is difﬁcult to assign a cost to a single instruction.
• Compilers optimize the statements that we write. For example, a compiler might
recognize that z(i) is not changed by our program fragment above and therefore
remove that statement from the loop.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 46 Page number 36
cyan magenta yellow black
36
Chapter 3. Computer Memory and Arithmetic
Table 3.1. Average memory access times (nanoseconds) on a Sun workstation for
various lengths m of (single precision) arrays and various strides s. The negative entry
that occurred when overhead was subtracted off is indicative of the uncertainty in the data.
log2 m =
log2 s
10
11
12
13
14
15
16
17
18
19
20
0
2
3
4
5
5
7
7
8
7
8
9
1
4
4
3
4
4
8
10
9
8
10
11
2
7
7
6
7
8
15
18
17
18
20
22
3
6
7
7
7
8
19
21
21
21
21
25
4
13
12
12
10
11
21
22
21
22
23
23
5
14
15
15
14
15
25
26
26
27
27
26
6
10
12
10
10
9
20
19
17
17
18
19
7
11
11
10
9
10
19
20
18
17
19
19
8
1
11
11
10
9
18
18
17
18
17
18
9
1
0
10
11
10
20
18
18
19
17
18
10
3
0
1
10
11
21
18
18
17
17
19
11
3
2
0
11
30
57
58
58
60
59
62
12
1
3
2
0
10
51
60
60
61
58
62
13
3
3
3
3
0
10
48
61
60
60
61
14
2
3
3
2
4
-1
10
50
59
61
60
15
3
2
2
2
3
2
0
11
49
60
59
16
2
3
4
3
4
3
4
0
9
49
61
17
3
2
2
2
2
3
3
4
0
9
51
18
3
3
3
4
3
2
3
4
1
0
10
19
3
3
2
3
2
3
2
4
3
2
0
• Cache blocks might be prefetched. Programs often access data in order, so computers
might predict that the next adjacent block of memory should be loaded into cache
while you are operating on the current one.
Therefore, real data values are not as clean as those in the previous challenge. Running a
program like that considered in Challenge 3.4 on an old Sun workstation gives the data in
Table 3.1. Let’s try to estimate the workstation’s cache parameters.
CHALLENGE 3.5.
Estimate the cache parameters from the data of Table 3.1.
3.4
Speed of Computer Arithmetic
We saw in Section 3.3 that the order in which we access the elements of a matrix affects
the time, but is it a signiﬁcant effect? Let’s time some arithmetic operations and memory
accesses to see whether it matters.

November 20, 2008 10:52
sccsbook
Sheet number 47 Page number 37
cyan magenta yellow black
3.4. Speed of Computer Arithmetic
37
POINTER 3.1. Fast Algorithms for Matrix Multiplication.
Matrix multiplication algorithms built on the techniques discussed in this chapter
require O(mnp) multiplications. Some faster algorithms have been proposed, variants on
Strassen’s algorithm [143], which makes recursive use of a clever algorithm for multiplying
2×2 matrices using 7 multiplications instead of 8. The best currently known uses O(n2.376)
operations when m = n = p, but the constant factor is very large [30]. Strassen’s algorithm
requires fewer multiplications when m = n = p ≥655, but the memory management is
quite different and the stability properties are somewhat weaker [79, Sec. 23.2.2].
CHALLENGE 3.6.
Determine for your computer the time for ﬂoating-point operations (addition, sub-
traction, multiplication, division, square-root) and the time for integer operations (addition,
subtraction, multiplication, division). One way is to look up the peak speed claimed by the
manufacturer. An alternative is to write a timing loop in a high-performance language.
CHALLENGE 3.7. (Extra)
Write a program in a high-performance language such as C or FORTRAN to estimate
the cache size, the block size for the cache, the time to access a value in cache, and the cache
miss penalty. Run it on your favorite computer. Average the time over enough operations
to get an accurate estimate, and also estimate the variance in your measurements.
Find the manufacturer’s claims for at least some of these parameters and determine
whether your estimates agree or disagree, and why.
Knowing our machine’s timing parameters allows us to design matrix algorithms that
achieve speeds close to the manufacturer’s peak performance claims, as illustrated in the
next challenge.
CHALLENGE 3.8. (Extra)
Use the information you gathered about the memory access properties of your ma-
chine to write the best program that you can for doing matrix-matrix multiplication on your
computer. Use a high-performance language. The inputs to the function are two matrices
A of dimension m × n and B of dimension n × p, along with n, m, and p. The output of
the function is the m × p matrix F = AB. The program should order the computations in
order to minimize the number of cache misses.
A (better) alternative to writing our own fast algorithms for basic matrix operations
is to use the ones provided in the BLAS implementation discussed in Chapter 5 and in
Pointer 3.2. In MATLAB we access the BLAS for matrix-vector product by typing A*x.
For other matrix tasks, we now know to keep our MATLAB algorithms column oriented
whenever possible.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 48 Page number 38
cyan magenta yellow black
38
Chapter 3. Computer Memory and Arithmetic
POINTER 3.2. Further Reading.
A good, detailed description of memory hierarchies is given in the textbook by Hen-
nessy and Patterson [74, Chapter 5].
In MATLAB, the underlying matrix decomposition software is drawn from the LA-
PACK FORTRAN suite [2]. This is based on a set of Basic Linear Algebra Subroutines
(BLAS), provided by hardware manufacturers to optimize operations such as inner prod-
uct, axpy, matrix-matrix multiplication, etc. The LAPACK routines implement stable al-
gorithms and provide high performance on a variety of hardware.
Matrices are not the only kinds of data that need to be carefully organized in mem-
ory. Samet [133] gives an encyclopedic treatment of more complicated data structures,
especially multidimensional ones.
Floating-point speed is increasing faster than memory access times are decreasing,
so ﬂoating-point operations are becoming almost free. Algorithms are optimized not by
minimizing arithmetic but by minimizing access to slow levels of memory.

November 20, 2008 10:52
sccsbook
Sheet number 49 Page number 39
cyan magenta yellow black
Chapter 4
Design of Computer
Programs: Writing
Your Legacy
In scientiﬁc computing, we sometimes begin with a clean slate; we are given a new prob-
lem, and we write software to solve it. In this situation, we are inventors. Other times we
work on a problem for which considerable software development has been done, often over
a period of many years. The existing software may have many authors, some of whom have
moved on to other positions. In this situation, our job is more akin to detective work. We
study the existing program, run examples to see how it behaves, and come to understand
both what it does and how it does it.
In this chapter, we consider the second situation, in which we are asked to work with
a legacy code, a program that has been in use for a while and now needs maintenance by
someone other than its author. We use the MATLAB function posted.m from Table 4.1
as an example. Let’s consider some principles of documentation and design and see how
they apply to posted.
4.1
Documentation
Documentation provides you and other potential users of your program an easy source of
information about the use and design of the software. Although you completely understand
the program you write today, by next year, or even next week, you will be surprised at how
difﬁcult it is to reconstruct your ideas if you neglect the documentation.
Ideally, the documentation at the top of the module provides basic information to help
a potential user decide whether the software is of interest. It should include the following:
• purpose of the module, since this is certainly the ﬁrst thing a user wants to know!
• name of author, since this provides someone to whom bugs can be reported and
questions asked.
• original date of the module and a list of later modiﬁcations, since this gives informa-
tion such as whether the module is likely to run under the current computer environ-
ment and whether it might include the latest advances.
39
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 50 Page number 40
cyan magenta yellow black
40
Chapter 4. Design of Computer Programs
Table 4.1. A MATLAB function posted.m, an example of a legacy program.
function [r, q] = posted (C)
[m,n] = size(C);
for k = 1:n
for j=1:m
x(j) = C(j,k);
end
xn = 0;
for j=1:m,
xn = xn + x(j)*x(j);
end
r(k,k) = sqrt(xn);
for j=1:m,
q(j,k) = C(j,k)/r(k,k);
end
for j = k+1:n
r(k,j) = 0;
for p=1:m
r(k,j) = r(k,j) + q(p,k)’*C(p,j);
end
for p=1:m
C(p,j) = C(p,j) - q(p,k)*r(k,j);
end
end
end
• description of each input parameter, so that a user knows what information needs to
be provided and in what format.
• description of each output parameter, so that a user knows what information is pro-
duced.
• brief description of the method and references, to help a user decide whether the
method ﬁts his/her needs.
In-line documentation identiﬁes the major sections of the module and provides some
detail on the method used. It is important in specifying the algorithm, identifying bugs, and
providing information to someone who might need to modify the software in order to solve
a slightly different problem.
Note that the documentation should be an integral part of the module; in other words,
it is not enough to include it in a separate document, because a potential user might not have
access to that document. If you ﬁnd posted frustrating, please resolve never to leave your
own programs undocumented!
CHALLENGE 4.1.
Guided by the principles listed above, add documentation to posted.

November 20, 2008 10:52
sccsbook
Sheet number 51 Page number 41
cyan magenta yellow black
4.2. Software Design
41
4.2
Software Design
Software should be designed according to a principle articulated by Albert Einstein: “Make
everything as simple as possible, but not simpler.”
• Code should be modular, so that a user can substitute another piece when necessary.
For example, a minimization algorithm should call a separate function to get a func-
tion value, so that it can be used to minimize any function. Separate modules should
also be used when the same computation is repeated in different places, to make the
software easier to understand and maintain.
• On the other hand, there is overhead involved in function calls, so ideally each mod-
ule should involve a substantial computation in order to mask this overhead,
• Input parameters should be tested for validity, and clear error messages should be
generated for invalid input, telling a user, for example, if a parameter that must be
real and positive has a negative or complex value.
• Data that a function needs should be speciﬁed in variables, not constants. For ex-
ample, a function that solves a linear system should work for any size of the matrix,
rather than having a size speciﬁed.
• Spaghetti code should be avoided. In other words, the sequence of instructions
should be top-to-bottom (including loops), without a lot of jumps.
• The names of variables should be chosen to remind the reader of their purpose. For
example, lambda is better than l as the name of a Lagrange multiplier.
• The instructions should be formatted in a way that makes them easy for a reader to
understand: the statements within loops or if statements should be indented, blank
lines should be used to visually partition blocks of code, and lines should be short
enough to ﬁt in a window and read at a glance.
• The module should be reasonably efﬁcient. In particular, it should not take an order
of magnitude more time or storage than necessary. For example, if a function that
solves a linear system with n variables takes O(n4) operations or O(n3) storage, then
it is not so useful.
• And, of course, the program should be correct.
CHALLENGE 4.2.
Judge posted according to each of the ﬁrst seven design principles listed above.
(We’ll consider its efﬁciency and correctness later.)
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 52 Page number 42
cyan magenta yellow black
42
Chapter 4. Design of Computer Programs
4.3
Validation and Debugging
It would be comforting to have a proof that each module that we use is correct. Although
there has been considerable effort in developing methodologies for proving correctness,
there are formidable limitations, both theoretical and practical. If correctness means match-
ing a set of speciﬁcations given for the module, how do we know that the speciﬁcations are
correct? What does correctness mean when we consider the effects of rounding error? And
even if each module is correct, can we ensure that the modules interact with each other
correctly?
Rather than a proof of correctness, in most situations we settle for a validation of
correctness on a limited set of inputs that we believe span the range of possibilities. Proper
design of this testing program is just as important as proper design of the modules being
tested, and it is a critical part of the debugging process.
• The testing program should be well-documented and easy to read.
• The test should exercise every statement in the target modules, include all typical
kinds of correct input, and test all conceivable errors in input.
• The testing program should compare the output against some trusted result and create
a log of the test results.
• The testing program should be archived so that it can be used later in case the target
modules are modiﬁed.
In addition to using a testing program, a powerful way to debug a module is to write it
one day and then read it carefully the next, reasoning through each statement to be sure
that it performs as intended. Programmers in the 1960s and 1970s had a major incentive
to do such desk checks: running the program once could mean waiting until the next
morning to see the results, so it was important to get it right without too many runs. With
today’s machines we usually have the luxury of seeing results from our programs much
more quickly. It is tempting just to run and modify the program until the answers look
good, but this is no substitute for a careful reading.
Let’s apply these validation principles to posted.
CHALLENGE 4.3.
(a) What does posted do?
(b) Develop a testing program for posted.
(c) Users complain that posted does not seem to behave well when the matrix C has more
columns than rows. In particular, they expect that q’ * q is an identity matrix, and this
is not true. Investigate this bug complaint and see what can be done.

November 20, 2008 10:52
sccsbook
Sheet number 53 Page number 43
cyan magenta yellow black
4.4. Efﬁciency
43
POINTER 4.1. Further Reading.
Organizations often have their own standards for documentation of programs. One
of the most widely admired and underutilized systems is Knuth’s Literate Programming
[93], used, for example, in his TEXdocument typesetting language. Knuth’s programming
style is also a model of clarity and good design.
Becoming a good programmer requires practice as well as good models. Bentley’s book
[14] is an excellent source of deceptively simple problems with beautiful solutions, and
Oliveira and Stewart [118] propose problems related to scientiﬁc software.
Mastery of the capabilities of the programming language is essential to writing good soft-
ware, and performance optimization in MATLAB is discussed in [78].
Considerable research was done in the 1970s on proving programs correct, but it is not a
mainstream activity. See, for example, [31].
4.4
Efﬁciency
Finally, we turn our attention to making posted more efﬁcient. The main sources of
inefﬁciency in posted arise from
• failing to use the vector capabilities of MATLAB. (For example, the programmer
used a loop instead of writing r(k,j) = q(:,k)’*C(:,j).)
• failing to use built-in functions like norm that make use of BLAS.
• failing to initialize matrices such as r to all zeros, and instead forcing MATLAB to
allocate new space each time through the loop.
Let’s eliminate these inefﬁciencies.
CHALLENGE 4.4.
Users have run a timing proﬁler on their software, and they have found that posted
takes 22% of the total time. Their typical input matrices C have about 200 rows and 100
columns. Change posted to make it run faster. Test the original and modiﬁed versions,
graphing the time required for problems with 200 rows and 50, 60,..., 200 columns.
After redesign, documentation, and validation, you should have a program that runs
100 times faster than posted and provides a much more useful legacy.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 54 Page number 44
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 55 Page number 45
cyan magenta yellow black
Unit II
Dense Matrix Computations
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 56 Page number 46
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 57 Page number 47
cyan magenta yellow black
47
Matrix computations are basic to a wide variety of problems in scientiﬁc comput-
ing, from function minimization to solving partial differential equations. In this unit, we
consider computations involving dense matrices, those that don’t have a large number of
zero elements. Computations involving sparse matrices, those that contain a substantial
number of zeros, are discussed in Unit VII.
In Chapter 2, we investigated how sensitive matrix problems can be to small changes
in the data. In Chapter 3 we learned to efﬁciently manipulate matrices on computers. Now
we focus on being able to choose the right matrix decomposition for a given task.
Our plan is to ﬁrst, in Chapter 5, discuss some basic tools for matrix manipulation:
the BLAS. Then we consider in turn a variety of matrix decompositions and their uses:
LU decomposition, QR decomposition, rank-revealing QR decomposition, eigendecompo-
sition, and singular value decomposition (SVD).
One important question is how to adapt a matrix decomposition when the matrix
changes slightly. We address this issue in Chapter 7.
We illustrate the use of the SVD in two case studies. We study in Chapter 6 how to
deblur images, using the SVD to exploit the Kronecker product structure of a matrix and
obtaining an efﬁcient algorithm for quite large problems. In estimating the direction of
arrival of signals in Chapter 8, we use the SVD as well as another useful matrix decompo-
sition, the rank-revealing URV.
BASICS: To understand this unit, the following background is helpful:
• Linear algebra: matrix multiplication; solution of linear systems; orthogonality;
ﬁnding a basis for a subspace; deﬁnitions of eigenvalues and eigenvectors. See a
standard textbook for a ﬁrst course in linear algebra.
• Matrix computations: LU decomposition; Gauss elimination; forward and back
substitution for solving Ax = b when A is lower triangular or upper triangular. See,
for example, [148, Chapters 5,6,7].
MASTERY: After you have worked through this unit, you should be able to do the follow-
ing:
• Write a MATLAB algorithm for forward substitution or back substitution (row or
column oriented).
• Use BLAS effectively.
• Explain what pivoting is in the LU decomposition and why it is necessary.
• Compute the determinant of a triangular matrix or permutation matrix.
• Recognize when to use the Cholesky decomposition rather than LU.
• Test a matrix for positive deﬁniteness.
• Determine whether a unique solution to a linear system or least squares problem
exists and how sensitive it is to perturbations.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 58 Page number 48
cyan magenta yellow black
48
• Deﬁne orthogonal and unitary matrices and prove simple facts about them (e.g., the
product of unitary matrices is unitary; multiplication by them does not change the
2-norm of a vector).
• Compute a Givens transformation to reduce a 2x1 vector to have a zero in its second
position.
• Write an algorithm to reduce a matrix to upper-triangular form or upper-Hessenberg
form using Givens matrices.
• Write an algorithm to reduce a matrix to upper-triangular form using the Gram–
Schmidt algorithm.
• Show that the vectors produced by the QR Gram–Schmidt algorithm are orthogonal
and that A = QR.
• Understand the difference between QR and RR-QR and state the uses of each.
• Show the relation between the SVD of A and the eigendecomposition of A∗A and
AA∗(where A∗is the complex conjugate transpose of A).
• Use RR-QR or SVD for tasks such as ﬁnding the range and null space of a matrix,
solving a least squares problem, and ﬁnding a lower-rank matrix near A.
• Use MATLAB’s eig to determine the stability of a matrix.
• Give bounds on sensitivity of eigenvalues to perturbations.
• Choose an appropriate decomposition for a given task.
• Know why matrix inverses are not useful unless the elements themselves are needed.
• Solve linear discrete ill-posed problems.
• Exploit Kronecker product structure in a matrix.
• Update a QR decomposition when a row or a column is added or deleted.
• Know the costs of the matrix decompositions.
• Show the validity of the Sherman–Morrison–Woodbury formula and use it to efﬁ-
ciently solve a modiﬁed linear system without using inverses.

November 20, 2008 10:52
sccsbook
Sheet number 59 Page number 49
cyan magenta yellow black
Chapter 5
Matrix Factorizations
We might have access to many tools for cutting, ranging from a scalpel to a chain saw. In
order to perform a given cutting task quickly and safely, we try to choose the appropriate
tool. It is good to have access to a variety of tools, since we would not want to have to cut
our ﬁngernails with the chain saw, but if we had to choose just one cutting tool, it might be
a Swiss Army knife.
Similarly, there are many decompositions for solving matrix problems, and we need
to know how to choose the appropriate one for a given problem. In this chapter we develop
the basic tools we need to solve matrix problems with speed and stability. The problems
include the three most common ones in numerical computation:
Linear system of equations: Given an n ×n matrix A and an n ×1 vector b, ﬁnd x so that
Ax = b.
Least squares problem: Given an m × n matrix A (usually m > n) and an m × 1 vector b,
solve the problem
min
x ∥b −Ax∥.
Eigenvalue problem: Given an n ×n matrix A, ﬁnd a vector x and a scalar λ so that
Ax = λx.
49
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 60 Page number 50
cyan magenta yellow black
50
Chapter 5. Matrix Factorizations
POINTER 5.1. Useful Deﬁnitions and Facts from Linear Algebra.
Review the matrix and vector notation deﬁned in Pointer 1.2 and the matrix and
vector norms deﬁned in Pointer 2.1. In this chapter we make use of the following facts:
• The determinant of a square matrix is the product of its eigenvalues. The usual
deﬁnition involves an expansion by minors, but the determinant of a lower-triangular
matrix (one with zeros above the main diagonal) or upper-triangular matrix (one with
zeros below the main diagonal) is just the product of the diagonal entries.
• The rank of a matrix is the number of linearly independent rows, and it is equal to
the number of linearly independent columns.
• An m ×n matrix is full rank if its rank is min(m,n).
• For any nonsingular matrix X, the matrix XAX−1 is a similarity transform of A and
the eigenvalues are unchanged.
• The range of a matrix A is the set of vectors y that can be expressed as Ax for some
vector x.
• The null space of a matrix A is the set of vectors x for which Ax = 0.
• A set of vectors forms a basis for a linear subspace if every vector in the subspace
can be expressed as a linear combination of these vectors and if no set with a smaller
number of vectors sufﬁces. The basis is an orthogonal basis if the inner product
between any two different vectors in the basis is zero. If in addition, the basis vectors
have length 1, then they form an orthonormal basis. The columns of an orthogonal
matrix (see Pointer 5.2) form an orthonormal basis for the range of the matrix.
We discuss in turn the BLAS, the LU decomposition, the QR decomposition, the
eigendecomposition, and (the Swiss Army knife) the singular value decomposition. These
decompositions, and their uses in computational problems, are summarized in Table 5.1 at
the end of the chapter.
5.1
Basic Tools for Matrix Manipulation: The BLAS
There are certain tasks we do all the time. For example, we get dressed, we retrieve our
mail, and we travel to work or school or other places. For each of these tasks, we develop
shortcuts to minimize the amount of thought and effort that we need to give them.
Similarly, there are certain tasks that are common to many matrix problems, so short-
cuts (subroutines) have been developed so that programmers don’t need to redo the work
each time. These Basic Linear Algebra Subroutines or BLAS were mentioned in Chapter
3. Libraries of BLAS are available for all of the standard languages, and using the BLAS
has many advantages:
• The functions are reliable, so debugging our own programs is simpler.
• We only need one line to accomplish a complicated task, so our programs are more
compact and easier to read and maintain.

November 20, 2008 10:52
sccsbook
Sheet number 61 Page number 51
cyan magenta yellow black
5.1. Basic Tools for Matrix Manipulation: The BLAS
51
POINTER 5.2. Special Kinds of Matrices.
Some matrices have important structure that we can exploit in algorithms. Here are
some examples:
• An n ×n matrix is nonsingular if it is full rank. A nonsingular matrix has an inverse.
• An n × n matrix A is upper-Hessenberg if it is zero below its ﬁrst subdiagonal
(aij = 0 if i > j + 1). It is tridiagonal if it is zero below its ﬁrst subdiagonal and
above its ﬁrst superdiagonal (aij = 0 if i ̸= j −1, j, j +1)
• A real orthogonal matrix U satisﬁes the relation UT U = I, so UT = U−1 if U is
square.
• A permutation matrix is the identity matrix with the order of its columns scrambled.
It is a special case of an orthogonal matrix and it can be “stored” just by recording
the column ordering in a vector.
• A unitary matrix U satisﬁes the relation U∗U = I, so U∗= U−1 if U is square.
• A is symmetric if AT = A, and Hermitian if A∗= A.
• A real symmetric (or complex Hermitian) matrix A is positive deﬁnite if all of its
eigenvalues are positive, or, equivalently, if x∗Ax > 0 for all x ̸= 0.
• The execution is optimized, so tasks are accomplished faster than we might be able
to achieve in a high-level language.
The BLAS are partitioned by level, with a Level k BLAS performing O(nk) ﬂoating-
point operations, where n is a dimension of the vector or matrix.
The Level 1 BLAS perform vector operations. Let x and y be column vectors of
length n and let a be a scalar. Examples of Level 1 operations are
• scal to compute ax,
• axpy to compute ax+y,
• dot to compute x∗y (the dot-product or inner-product of two vectors).
The Level 2 BLAS perform operations that cost O(n2) ﬂoating-point computations. These
include
• matrix-vector product,
• low-rank updates to a matrix (See the case study of Chapter 7),
• solution of linear systems involving triangular matrices.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 62 Page number 52
cyan magenta yellow black
52
Chapter 5. Matrix Factorizations
The Level 3 BLAS perform matrix-matrix operations, including
• matrix-matrix product,
• solution of multiple linear systems involving a triangular matrix.
When a BLAS exists for a task you need, it is a good idea to use it in your algorithm!
MATLAB automatically uses the BLAS for tasks such as A * B. In other languages, you
need to call on the BLAS yourself.
CHALLENGE 5.1.
Let A be an m × n matrix. Write a column-oriented MATLAB algorithm for com-
puting
si =
n
	
j=1
|aij|
for i = 1,2,...,m. Then use the BLAS, accessed through norm, to accomplish the same
task, and compare the efﬁciency of the two algorithms.
5.2
The LU and Cholesky Decompositions
The LU decomposition of an n × n matrix A is deﬁned by PA = LU, where P is a per-
mutation matrix, L is a unit lower-triangular matrix (zero above the main diagonal and
ones on the main diagonal) and U is an upper-triangular matrix (zero below the main
diagonal). These matrices are computed in the process of Gauss elimination. We compute
the LU decomposition by reducing the matrix A to upper-triangular form. We put zeros
below the main diagonal, one column at a time, subtracting a multiple of the current pivot
row from all rows below it. The multipliers form the entries of L.
We illustrate using an example with P = I. Consider the matrix
A =
⎡
⎣
4
4
8
2
8
7
1
3
6
⎤
⎦.
In Step 1, we set U = A and then we subtract 1/2 times the ﬁrst row of U from the second,
and 1/4 times the ﬁrst row from the third. We obtain the matrix
U =
⎡
⎣
4
4
8
0
6
3
0
2
4
⎤
⎦,
In Step 2, we subtract 1/3 times the new second row from the new third row, obtaining
U =
⎡
⎣
4
4
8
0
6
3
0
0
3
⎤
⎦,

November 20, 2008 10:52
sccsbook
Sheet number 63 Page number 53
cyan magenta yellow black
5.2. The LU and Cholesky Decompositions
53
POINTER 5.3. Existence, Uniqueness, and Sensitivity of Solutions to Linear Systems
of Equations.
• The linear system of equations Ax = b, where A is n × n, is guaranteed to have a
unique solution if the matrix A is nonsingular.
• If A is singular, then a solution xgood exists only if b can be expressed as a linear
combination of the columns of A, and in that case any vector x = xgood +y is also a
solution if Ay = 0.
• Suppose we make a small change in our problem, solving instead a nearby problem
(A+A)y = b+b.
We might want to know how close the solution to this problem is to our original
problem. To answer this question, deﬁne
ϵA ≡∥A∥
∥A∥,
ϵb ≡∥b∥
∥b∥,
κ ≡∥A∥∥A−1∥.
Then if κϵA < 1 we have the bound
∥x−y∥
∥x∥
≤
κ
1 −κϵA
(ϵA +ϵb).
Consult a standard text such as [64, 119, 139] for a proof of this and related results,
valid for any of the norms (1, 2, ∞) we have considered. We already used a special
case of this inequality, when ϵb = 0, in equation (2.1).
which is upper triangular. But notice that the multipliers are important, too, since we can
express the original matrix as
A =
⎡
⎣
4
4
8
2
8
7
1
3
6
⎤
⎦=
⎡
⎣
1
0
0
1/2
1
0
1/4
1/3
1
⎤
⎦
⎡
⎣
4
4
8
0
6
3
0
0
3
⎤
⎦≡LU.
To obtain a reliable algorithm, it is necessary to pivot, or interchange rows in the ma-
trix U, as illustrated in Figure 5.1. The most common rule for pivoting is partial pivoting.
Using this rule, at the kth stage of the decomposition, when we are putting zeros in column
k of U below its main diagonal, we ﬁrst interchange two rows of U (if necessary) so that
the maximum magnitude element in column k, among those in rows k through n, appears
on the main diagonal. In this way, all of the multipliers have magnitude bounded by 1, and
this is sufﬁcient for stability. The record of interchanges deﬁnes P.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 64 Page number 54
cyan magenta yellow black
54
Chapter 5. Matrix Factorizations
Choose the largest magnitude
element among these and
interchange rows if necessary
to bring it to the main diagonal.
Record this change in the
permutation vector.
Figure 5.1. Partial pivoting in computing the LU decomposition. We search the
cross-hatched part of column k of the U matrix for the largest magnitude element and
interchange rows to move it to the main diagonal position.
Pivoting is essential for two reasons. First, we need pivoting because the LU decom-
position of a nonsingular matrix A may not be possible. For example, the matrix
B =

0
1
1
1

has no LU decomposition. But for any matrix A we can always ﬁnd a permutation matrix P
so that the matrix PA does have an LU decomposition. For our example, if we premultiply
B by a permutation matrix that interchanges the two rows, we obtain
PB ≡

0
1
1
0

0
1
1
1

=

1
1
0
1

,
so the LU decomposition of PB is just the identity matrix times PB itself.
Second, as already mentioned, the LU decomposition without pivoting is an unstable
algorithm. Let δ be a positive number less than 1
2ϵmach and consider, for example,
C =

δ
4
1
1
1

=
 1
0
4
δ
1

δ
4
1
0
−4
δ +1

.
If δ/4 and 4/δ are exactly representable in ﬂoating-point arithmetic, then for small positive
values of δ, the factors would be approximated in ﬂoating-point arithmetic as
 1
0
4
δ
1

δ
4
1
0
−4
δ

,
and this is the exact decomposition of the matrix

δ
4
1
1
0

,
far from the matrix C. Using forward and back substitution to solve the problem Cx = b
with these factors can lead to a large residual b −Cxc, where xc is the computed value.

November 20, 2008 10:52
sccsbook
Sheet number 65 Page number 55
cyan magenta yellow black
5.2. The LU and Cholesky Decompositions
55
With pivoting, however, we obtain the decomposition
PC =
 1
1
δ
4
1

=
 1
0
δ
4
1
 1
1
0
1 −δ
4

,
which would be approximated by
 1
0
δ
4
1

1
1
0
1

.
This is exact for the matrix
 1
1
δ
4
1 + δ
4

,
and the residual would be small.
We compute an LU decomposition in MATLAB by typing [L,U,P] = lu(A) or
[PtL,U] = lu(A) to compute PT L and U. The arithmetic cost is n3/3+ O(n2) multi-
plications.5 In MATLAB, the backslash command x = A \ b uses the LU decomposition
to solve the problem (or, if A is triangular, it uses substitution, discussed below).
The LU decomposition has two main uses: solving linear systems and computing the
determinant of a matrix.
• To solve the linear system Ax = b, we ﬁrst solve Ly = Pb by solving equation i for
yi: for i = 1,...,n,
yi = (Pb)i −
i−1
	
j=1
ℓij yj.
This is called forward substitution. Then we solve Ux = y by back substitution,
considering the equations from last to ﬁrst: for i = n,n −1,...,1,
xi =
⎛
⎝yi −
n
	
j=i+1
uij xj
⎞
⎠/uii.
• If PA = LU, then
detP detA = detL detU.
The determinant of a triangular matrix is just the product of its main diagonal ele-
ments, and det(P) = ±1 (positive if the number of interchanges is even and negative
otherwise). Therefore, since L has ones on its main diagonal, the determinant of A is
just plus or minus the product of the diagonal entries of U.
The following challenges give practice with these concepts.
5For large values of n, only the high-order term n3/3 term is signiﬁcant, so we generally neglect the
low-order terms n2, n, and constants.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 66 Page number 56
cyan magenta yellow black
56
Chapter 5. Matrix Factorizations
POINTER 5.4. Testing Positive Deﬁniteness.
By inspection, we can decide whether a matrix is symmetric or Hermitian, but posi-
tive deﬁniteness (see Pointer 5.2) is not obvious. Luckily, we often know from the under-
lying physical problem that a matrix has this property. For example, if A is the matrix of
second partial derivatives of a smooth strictly convex function, or if it deﬁnes the energy
function for a variational problem, then it is positive deﬁnite. Another easy case is if a non-
singular A is formed as B∗B. Then x∗Ax = x∗B∗Bx = ∥Bx∥2
2 and this quantity is positive
for nonzero x as long as B has linearly independent columns.
A test based on the Gerschgorin circle theorem [64] is sometimes useful. For any
matrix A, all of the eigenvalues of A lie in the union of the n circles in the complex plane
deﬁned by
{z : |aii −z| ≤
n
	
j=1
j̸=i
|aij|}
for i = 1,...,n. Therefore, if our matrix is real symmetric or complex Hermitian, and none
of these circles touches the negative real axis, then the matrix is positive deﬁnite.
CHALLENGE 5.2.
Use back substitution to solve the linear system
 2
5
0
3
 x1
x2

=
 8
6

.
What is the determinant of the matrix?
CHALLENGE 5.3.
Write a column oriented algorithm to compute the determinant of A and to solve
the linear system Ax = b by forward substitution when A is an n × n nonsingular lower-
triangular matrix.
One special case of triangular decomposition is important. If the matrix A is real
symmetric and positive deﬁnite then we can use the Cholesky decomposition in place of
LU. This gives a decomposition as
• LLT , where L is lower triangular (see MATLAB’s chol)
• or LDLT , where L is unit lower triangular and D is diagonal
at half the arithmetic cost of LU. The restriction to positive deﬁnite matrices assures that the
decomposition is stable without pivoting. A similar decomposition exists for a Hermitian
positive deﬁnite matrix.

November 20, 2008 10:52
sccsbook
Sheet number 67 Page number 57
cyan magenta yellow black
5.3. The QR Decomposition
57
CHALLENGE 5.4.
Suppose A is real n ×n symmetric positive deﬁnite, and let A = LLT be its Cholesky
decomposition.
(a) Let n = 3 and write formulas for aij , i, j = 1,2,3, in terms of the entries of L.
(b) Notice that if we consider the formulas in column order, we can compute the elements
ℓ11,ℓ21,ℓ31,ℓ22,ℓ32, and ℓ33. Use this insight to write a MATLAB function to compute the
Cholesky decomposition for a general value of n. Check the correctness of your function
by comparing with chol.
5.3
The QR Decomposition
The QR decomposition of a full-rank m ×n matrix A (m ≥n) is deﬁned by
A
=
Q
0
m × n
m  ≥n
m × m
m × n
A
=
0
n × n
Q
n × n
n × n
or
A
m × n
Q
m × n
R 
R 
where
• Q is an m ×m unitary matrix (orthogonal, if A is real) and R is an m ×n matrix with
zeros below the main diagonal (upper-trapezoidal) or
• Q is an m × n unitary matrix (orthogonal, if A is real) and R is an n × n upper-
triangular matrix.
The compact m ×n decomposition arises because part of the m ×m matrix Q is not needed
in the decomposition:
A
=
0
R1
m × n
m  ≥n
m × n
Q1
Q2
n
n
m-n
= Q1 R 1 + Q2 0 = Q1 R 1
m × m
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 68 Page number 58
cyan magenta yellow black
58
Chapter 5. Matrix Factorizations
Although Q2 is not needed to reconstruct A, it contains useful information, an or-
thogonal basis for the null space of A∗, as we will see in Section 5.3.3.
We’ll discuss two algorithms for computing the QR decomposition:
• Givens rotations (good for Q m ×m),
• Gram-Schmidt orthogonalization (good for Q m ×n).
A third algorithm using Householder transformations, also useful, is presented as Chal-
lenge 5.10.
5.3.1
QR Decomposition by Givens Rotations
A simple orthogonal matrix, a rotation, can be used to introduce one zero at a time into
a real matrix A. (We’ll discuss the extension of the algorithm to complex matrices in
Challenge 5.7.)
We’ll write the Givens rotation matrix as
G =

c
s
−s
c

,
where c2 + s2 = 1. Thus, c and s have the geometric interpretation of the cosine and sine
of an angle, and the product Gx rotates the vector x through that angle.
We use Givens rotations to rotate a given vector to point in the direction of the positive
x-axis, thus putting a zero in its second entry. Given a vector z ̸= 0 of dimension 2×1, we
want to ﬁnd G so that Gz = xe1 where x = ∥z∥and e1 is the ﬁrst column of the identity
matrix.
To solve this, note that
Gz =

cz1 +sz2
−sz1 +cz2

= xe1.
Multiplying the ﬁrst equation by c and the second by s and then subtracting yields
(c2 +s2)z1 = cx ,
so
c = z1/x .
Similarly, we can determine that s = z2/x . Since c2 +s2 = 1, we conclude that
z2
1 + z2
2 = x2 ,
so
c =
z1

z2
1 + z2
2
,
s =
z2

z2
1 + z2
2
.
The next challenge gives practice in computing a real-valued Givens rotation.

November 20, 2008 10:52
sccsbook
Sheet number 69 Page number 59
cyan magenta yellow black
5.3. The QR Decomposition
59
CHALLENGE 5.5.
Find an orthogonal matrix G and a number w so that
G
 3
4

=
 w
0

.
We can use Givens matrices to zero out single components of a matrix. We use the
notation Gij to denote an n ×n identity matrix with its ith and jth rows modiﬁed to include
the Givens rotation. For example, if n = 6, then
G25 =
⎡
⎢⎢⎢⎢⎢⎣
1
0
0
0
0
0
0
c
0
0
s
0
0
0
1
0
0
0
0
0
0
1
0
0
0
−s
0
0
c
0
0
0
0
0
0
1
⎤
⎥⎥⎥⎥⎥⎦
.
Multiplication of a vector by this matrix leaves all but rows 2 and 5 of the vector unchanged.
If we choose the angle appropriately, multiplying a matrix by G25 can put a zero in some
entry in row 5.
We can reduce a matrix A to upper-trapezoidal form by the sequence of rotations
indicated in Algorithm 5.1. Since the product of orthogonal matrices is an orthogonal
matrix, the product of the Givens rotation matrices is an m ×m orthogonal matrix that we
call QT . We use a variant of this algorithm in the next challenge.
Algorithm 5.1 QR via Givens Rotations
Initialize Q to be the m ×m identity matrix.
Initialize R to be the m ×n matrix A.
for i = 1,...,n,
for j = i +1,...,m,
Choose the matrix Gij to put a zero in position ( j,i) of the matrix R, using the
current value in position (i,i), and set R = Gij R.
Q = QG∗
ij .
end
end
CHALLENGE 5.6.
MATLAB’s function W = planerot(y) takes a 2 × 1 vector y as input and re-
turns a Givens matrix W so that Wy has a zero in its 2nd position.
Write a MATLAB program that uses planerot to reduce a matrix of the form
A =
⎡
⎢⎣
×
×
×
×
×
×
×
×
0
×
×
×
0
0
×
×
⎤
⎥⎦
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 70 Page number 60
cyan magenta yellow black
60
Chapter 5. Matrix Factorizations
to upper-triangular form, where × indicates a nonzero element. (In other words, do a QR
decomposition of this matrix, but don’t worry about saving Q.)
A derivation similar to the one above determines (complex) Givens matrices to reduce
a complex matrix A to triangular form.
CHALLENGE 5.7.
For a given 2 ×1 vector z with complex entries, let c = |z1|/∥z∥. Determine s in the
matrix
G =

c
s
−¯s
c

so that G is unitary and Gz = ∥z∥2 e1. (Note that ¯s denotes the complex conjugate of the
number s.) This is the complex extension of the idea behind the Givens matrix and it can
be used in applying Algorithm 5.1 to complex matrices.
5.3.2
QR by Gram–Schmidt Orthogonalization
An alternative to the Givens QR uses Gram–Schmidt orthogonalization to compute the
decomposition. From the columns [a1,...,an] of the matrix A, we create an orthonormal
basis {q1,...,qn} (the columns of Q) and save the coefﬁcients that compute this basis in an
upper-triangular matrix R. We summarize this in Algorithm 5.2.
Algorithm 5.2 Gram–Schmidt Orthogonalization
r11 = ∥a1∥
q1 = a1/r11
(Comment:
Compute the component of qk+1 orthogonal to all previous vectors
q1,...,qk.)
for k = 1,...,n −1,
qk+1 = ak+1
for i = 1,...,k,
ri,k+1 = q∗
i qk+1
qk+1 = qk+1 −ri,k+1qi
end
(Comment: Normalize qk+1 to length 1.)
rk+1,k+1 = ∥qk+1∥
qk+1 = qk+1/rk+1,k+1
end
Convince yourself that Algorithm 5.2 computes a matrix decomposition A = QR,
where Q is m ×n. The geometry of the transformation is illustrated in Figure 5.2, and you
can try the algebra in the next challenge.

November 20, 2008 10:52
sccsbook
Sheet number 71 Page number 61
cyan magenta yellow black
5.3. The QR Decomposition
61
2
2
2
ˆ
ˆ
a
a
q =
3ˆa
1a
1
q
2
a
3
a
Figure 5.2. The geometry of the QR decomposition. The vector a1 is normalized
to length 1 to obtain the ﬁrst basis vector q1. We ﬁnd the component of a2 orthogonal to this
vector and normalize to obtain q2. If we have a third vector a3, we ﬁnd that its component
orthogonal to q1 is a3, which has no component orthogonal to q2, since in R2, we can
have at most two linearly independent basis vectors.
CHALLENGE 5.8.
Compute a QR decomposition of the matrix

3
3
3
1

using
(a) a Givens rotation,
(b) Gram–Schmidt orthogonalization.
Let’s make sure we believe that the Gram–Schmidt algorithm produces orthogonal
vectors.
CHALLENGE 5.9.
For the Gram–Schmidt algorithm, show (by ﬁnite induction) that q∗
i qk = 0 for i < k.
Finally, in the next challenge we consider a third QR algorithm, based on House-
holder transformations.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 72 Page number 62
cyan magenta yellow black
62
Chapter 5. Matrix Factorizations
CHALLENGE 5.10. (Challenging)
(a) Suppose we are given an n ×1 vector z. Represent its ﬁrst coordinate in polar notation
as z1 = eiθζ, where ζ is real. Deﬁne v = z−αe1, where α = −eiθ∥z∥. Let u = v/∥v∥, and
deﬁne
Q = I−2uu∗.
Verify that Q is a unitary matrix and that Qz = αe1. The matrix Q is one version of a
Householder transformation.
(b) Given an m × n matrix A, we can determine a Householder transformation Q1 so that
A1 = Q1A has zeros in its ﬁrst column below the main diagonal. Show how to determine
Q2 in the form
Q2 =

1
0
0
I−2u2u∗
2

so that A2 = Q2A1 has zeros in its ﬁrst and second column below the main diagonal.
(c) Continuing this process, write an algorithm to reduce a matrix A to upper-triangular
form by multiplying by a series of Householder transformations.
(d) How many ﬂoating-point multiplications does your algorithm take? (Hint: When m =
n, your answer should reduce to 2n3/3 + O(n2) multiplications to form R.)
5.3.3
Computing and Using the QR Decomposition
In MATLAB, we compute the QR decomposition of the m ×n matrix A (m ≥n) by typing
[Q,R] = qr(A). Alternatively, qr(A,0) returns the compact matrix Q of dimension
m ×n (although ﬁrst the full m ×m matrix is computed). Householder transformations are
used. The function orth can be used if only the compact Q is needed and not R.
The arithmetic cost of the QR decomposition is approximately
• 2mn2 −2/3n3 multiplications, using Givens rotations (without explicit formation of
Q),
• mn2 −1/3n3 multiplications, using Householder reﬂections (without explicit forma-
tion of Q),
• mn2 multiplications, using Gram–Schmidt orthogonalization.
A nice feature of the QR decomposition is that in general, we don’t need to pivot to
preserve numerical stability. This makes QR a useful alternative to LU for solving linear
systems. Although the operations count is twice as big, the data handling is simpler. To
solve Ax = b, we use back substitution to solve Rx = Q∗b, taking advantage of the fact that
Q−1 = Q∗.
If the columns of A are linearly dependent, or are close to being linearly dependent,
then the QR decomposition does not behave well, and the rank-revealing QR of Section 5.4
or the SVD of Section 5.6 should be used instead.

November 20, 2008 10:52
sccsbook
Sheet number 73 Page number 63
cyan magenta yellow black
5.3. The QR Decomposition
63
An important use of the QR decomposition is to obtain orthogonal bases for the
range of a full-rank matrix A and the null space of A∗, i.e., a set of orthonormal vectors
spanning these spaces. Suppose A = QR. Then
A = QR =  Q1
Q2

R1
0

=  q1...qn
qn+1...qm

R1
0

.
Since Q has linearly independent columns, we can express any m-vector z as
z =
m
	
i=1
ciqi
for some coefﬁcients ci. Note that
Q∗z =
⎡
⎢⎣
q∗
1z
...
q∗
mz
⎤
⎥⎦=
⎡
⎢⎣
c1
...
cm
⎤
⎥⎦
and
A∗z = R∗Q∗z =
 R∗
1
0 
⎡
⎢⎣
c1
...
cm
⎤
⎥⎦= R∗
1
⎡
⎢⎣
c1
...
cn
⎤
⎥⎦.
Therefore, if R1 is full rank, then A∗z = 0 if and only if c1 = ... = cn = 0, which happens
if and only if z can be expressed as a linear combination of the columns of Q2, so these
columns are an orthogonal basis for the null space of A∗.
Similarly, since
Ax = Q1R1x,
every vector in the range of A can be expressed as a linear combination of columns of Q1.
Thus the ﬁrst n columns of Q form an orthogonal basis for the range of A and the last m −n
columns of Q form an orthogonal basis for the null space of A∗.
By far the most common use of the QR decomposition is to solve linear least squares
problems
min
x ∥b−Ax∥
when A has more rows than columns. The MATLAB backslash command, x = A \ b,
which solves a linear system when A is square and nonsingular, uses the QR decomposition
to solve the problem in the least squares sense when m > n. The residual is deﬁned as
r = b −Ax.
(5.1)
The solution process is based on three fundamental facts, whose proof we leave to the next
challenge.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 74 Page number 64
cyan magenta yellow black
64
Chapter 5. Matrix Factorizations
CHALLENGE 5.11.
Prove the following facts:
• Minimizing the norm of b−Ax gives the same solution as minimizing the square of
the norm.
• The norm of a vector is invariant under multiplication by Q∗, so ∥y∥= ∥Q∗y∥for any
vector y.
• Suppose we partition the vector y into two pieces:
y =

y1
y2

.
Then ∥y∥2 = ∥y1∥2 +∥y2∥2.
Now suppose we have factored the full-rank matrix A = QR, and deﬁne
c = Q∗b =

c1
c2

,
where c1 is n ×1 and c2 is (m −n)×1. Then
∥b −Ax∥2 = ∥Q∗(b−Ax)∥2
= ∥c−Rx∥2
= ∥c1 −R1x∥2 +∥c2 −0x∥2
= ∥c1 −R1x∥2 +∥c2∥2.
To minimize this quantity, we make the ﬁrst term zero by taking x to be the solution to the
n ×n linear system R1x = c1. This leads to Algorithm 5.3. The MATLAB command x =
A \ b performs the ﬁrst three steps.
Algorithm 5.3 Linear Least Squares via QR for a Full-Rank Matrix A
Factor A = QR.
Partition Q = [Q1,Q2], where Q1 contains the ﬁrst n columns.
Compute c1 = Q∗
1b.
Solve R1x = c1 by back substitution.
The norm of the residual can be computed as ∥b−Ax∥or as ∥c2∥= ∥Q∗
2b∥.

November 20, 2008 10:52
sccsbook
Sheet number 75 Page number 65
cyan magenta yellow black
5.3. The QR Decomposition
65
0
1
2
3
4
5
6
7
8
9
10
11
−0.2
0
0.2
0.4
0.6
0.8
1
time (years)
pollutant (micrograms per liter)
A least squares fit to pollution data
Figure 5.3. Is a straight line a good model to this data? The measured values
of the pollutant are indicated by stars, and the vertical lines indicate the error bars, an
uncertainty of two standard deviations plus or minus.
CHALLENGE 5.12.
Try justifying the QR algorithm for least squares without referring to the previous
derivation. Suppose we have factored the full-rank m ×n matrix A = QR (m ≥n), and let
x be the solution to the least squares problem
min
x ∥b −Ax∥.
Show that ∥b −Ax∥2 = ∥c2∥2, where c2 is the vector consisting of the last m −n compo-
nents of Q∗b.
5.3.4
Mini Case Study: Least Squares Data Fitting
We consider the problem of ﬁtting a model to data in order to reduce the effects of noise in
the measurements.
As an example, we consider the data (ti, fi), i = 1,...,10, in Figure 5.3, representing
the amount (μg per liter) of a pollutant in a river, measured once a year. We want to
know whether a straight line is a good ﬁt to this data. We suppose that the errors in the
measurements fi are independent, with mean 0 and standard deviation equal to σ = 0.05.
We express the line as x1 +tx2 and determine the parameters x1 and x2 by solving
min
x ∥b −Ax∥,
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 76 Page number 66
cyan magenta yellow black
66
Chapter 5. Matrix Factorizations
POINTER 5.5.
Existence, Uniqueness, and Sensitivity of Solutions to Linear Least
Squares Problems.
• A solution to the problem
min
x ∥b−Ax∥
always exists, and it is unique if the m × n matrix A has rank n. If the rank of A is
less than n, and if xgood solves the problem, then any vector x = xgood + y is also a
solution if Ay = 0.
• Suppose we make a small change in our problem, solving instead a nearby problem
min
y ∥(A+A)y−(b+b)∥.
We might want to know how close the solution to this problem is to our original
problem. To answer this question, deﬁne
ϵA ≡∥A∥
∥A∥,
ϵb ≡∥b∥
∥b∥.
Then if the rank of A is equal to the rank of A+A, and if κϵA < 1 (where κ is the
square root of the ratio of the largest to the smallest eigenvalue of A∗A), the solution
to the problem can change by at most
∥x−y∥≤
κ
1 −κϵA

ϵA∥x∥+ϵb
∥b∥
∥A∥+ϵAκ ∥rx∥
∥A∥

+ϵAκ∥x∥.
Similarly, the residuals rx = b−Ax and ry = (b+b)−(A+A)y are related by
∥ry −rx∥≤ϵA∥x∥∥A∥+ϵb∥b∥+ϵAκ∥rx∥.
See the excellent book by Björck [16, Thm. 1.4.6] for the proof of these results.
where
A =
⎡
⎢⎢⎢⎣
1
t1
.
.
.
.
.
.
1
t10
⎤
⎥⎥⎥⎦, b =
⎡
⎢⎢⎢⎣
f1
.
.
.
f10
⎤
⎥⎥⎥⎦.
We compute and plot the straight-line ﬁt using the following MATLAB program:

November 20, 2008 10:52
sccsbook
Sheet number 77 Page number 67
cyan magenta yellow black
5.4. The Rank-Revealing QR Decomposition (RR-QR)
67
sigma=.05
t = [1:10];
b = ...
% the values of f
plot(t,b,’g*’)
hold on
for i=1:10,
plot([t(i),t(i)],[b(i)+2*sigma,b(i)-2*sigma])
end
axis([0 11 -.2 1.2])
A = [ones(10,1),t’];
x = A \ b’;
plot(t,A*x,’m’)
xlabel(’time (years)’)
ylabel(’pollutant (micrograms per liter)’)
title(’A least squares fit to pollution data’)
Figure 5.3 shows the data (with error bars covering the range ±2σ) and the straight
line produced by least squares. The ﬁt is quite good, with the straight line passing through
all of the error bars.
5.4
The Rank-Revealing QR Decomposition (RR-QR)
The RR-QR decomposition of an m × n matrix A is deﬁned by AP = QR, where P is a
permutation matrix chosen so that the leading principal submatrix of R of dimension p × p
is well conditioned and the other diagonal block (of dimension (n−p)×(n−p))has entries
of small magnitude. This means that
R =
⎡
⎣
R1
F
0
R2
0
0
⎤
⎦,
where R1 is p × p and upper triangular, R2 is (n −p) × (n −p) and upper triangular, and
∥R2∥is small relative to the main diagonal elements of R1. The numerical rank of A is p,
indicating that A is quite close to the matrix QR of rank p, where R is obtained by replacing
R2 by 0.
We can compute this decomposition by a pivoted version of our Givens QR decom-
position, Algorithm 5.4. A similar modiﬁcation can be made to the Gram–Schmidt and
Householder versions. The number of multiplications in computing the RR-QR decom-
position is the same as for the original decomposition, whichever version is used, but the
pivoting introduces O(mn) extra overhead.
In MATLAB, [Q,R,P] = qr(A) produces a rank-revealing QR decomposition.
The RR-QR decomposition has two main uses in addition to those of the QR decom-
position. We can use the RR-QR decomposition to
• Determine whether A is rank-deﬁcient. As discussed above, we can even use the
RR-QR to construct a matrix of lower rank that is close to A.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 78 Page number 68
cyan magenta yellow black
68
Chapter 5. Matrix Factorizations
Algorithm 5.4 Givens QR with Pivoting
for i = 1 : n,
Among columns i : n of rows i : m of the current A matrix, choose the column with
largest norm.
Permute so that this column becomes the ith column.
Perform Givens rotations to put zeros below row i in column i of A.
end
• Compute a “poor man’s” principal component analysis (PCA). If we are modeling
b as b ≈Ax, then the RR-QR decomposition tells us that we can produce almost as
good a ﬁt using p parameters instead of n, and the ﬁrst p elements of the permutation
tell us which parameters to use.
The RR-QR decomposition can be fooled into overestimating the numerical rank of
the matrix (but it never underestimates it). If reliability is essential, use the somewhat more
expensive SVD of Section 5.6.
5.5
Eigendecomposition
The eigendecomposition of a matrix A of dimension n ×n is
A = UU−1,
(5.2)
where  is a diagonal matrix with the eigenvalues λi as its entries. The columns of U are
the right eigenvectors,
Aui = λiui ,
and the rows of U−1 are the left eigenvectors z∗
i , satisfying
z∗
i A = λiz∗
i .
The decomposition is guaranteed to exist if
• A is real symmetric or complex Hermitian, or
• the eigenvalues of A are distinct.
Otherwise, the decomposition may fail to exist, although it always exists for a nearby ma-
trix.
5.5.1
Computing the Eigendecomposition
The basic algorithm to compute the eigendecomposition is simple, but the reﬁnements that
make it work really well are not. We’ll just focus on the basics. When you do an eigende-
composition, make sure you choose high-quality software to compute it. The algorithm is
a two-step process.

November 20, 2008 10:52
sccsbook
Sheet number 79 Page number 69
cyan magenta yellow black
5.5. Eigendecomposition
69
POINTER 5.6. Existence, Uniqueness, and Sensitivity of Solutions to the Eigenprob-
lem.
Here are some basic results, found, for example, in [64, 139]. Other properties of the
eigenproblem are presented in Chapter 31.
• Every n ×n matrix has n eigenvalues (counting multiplicities), the roots of the equa-
tion det(A−λI) = 0, but computing the roots using this polynomial equation is un-
stable.
• Almost every square matrix has a full set of linearly independent eigenvectors; the
only exceptions are matrices which have a Jordan block of size greater than one; see
Section 5.7. If the matrix is real symmetric or complex Hermitian, there is a full set
of orthogonal eigenvectors.
• If the multiplicity of the eigenvalue λ is one, then the corresponding eigenvector is
unique, up to multiplication by a nonzero constant.
• If the multiplicity of an eigenvalue λ is greater than 1, then although the eigenvectors
corresponding to this eigenvalue are not unique, the subspace that they span, known
as an invariant subspace of the matrix, is unique.
• For general matrices A and E, suppose A has a full set of n linearly independent
eigenvectors, the columns of the matrix U, and let κ(U) = ∥U∥∥U−1∥using either
the 1, 2, or ∞norm.
– (Bauer–Fike theorem) The matrix A+E has an eigenvalue within κ(U)∥E∥of
each eigenvalue of A.
– If we have a number ˜λ and a vector z of norm 1 satisfying ∥Az−˜λz∥= ϵ, then
˜λ is within ϵ κ(U) of an eigenvalue of A.
• Suppose that A and E are real symmetric or Hermitian matrices. Denote the kth
largest eigenvalue of a matrix B by λk(B), the largest by λmax, and the smallest by
λmin. Then
– for k = 1,...,n,
λk(A)+λmin(E) ≤λk(A+E) ≤λk(A)+λmax(E).
– (Weilandt–Hoffman theorem)
n
	
k=1
(λk(A+E)−λk(A))2 ≤∥E∥2
F.
Results on the sensitivity of eigenvectors can be found in the references mentioned above.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 80 Page number 70
cyan magenta yellow black
70
Chapter 5. Matrix Factorizations
• Step 1: Reduce the matrix A to compact form, so that it is easy to manipulate. To do
this, ﬁnd a unitary matrix V so that
V∗AV = H,
where H is
– tridiagonal if A is Hermitian (or real symmetric),
– upper-Hessenberg otherwise.
This can be done in O(n3) operations using Givens rotations. For example, if A is
4 × 4, then we choose G24 to reduce the (4,1) element of A to zero, G23 to re-
duce the (3,1) element of G24AG∗
24 to zero, and G34 to reduce the (4,2) element of
G23G24AG∗
24G∗
23 to zero, obtaining V = G∗
24G∗
23G∗
34 and H = G34G23G24AG∗
24G∗
23G∗
34
= V∗AV. Note that we have applied a similarity transform, so if we ﬁnd an eigen-
decomposition of H as
H = UU−1
then the eigendecomposition of A is
A = (VU)(VU)−1.
The arithmetic cost of this step is O(n3).
• Step 2: Find the eigendecomposition of H by QR iteration:
– Form H = QR.
– Replace H by RQ.
Note that since Q∗Q = I and H = QR,
RQ = (Q∗Q)RQ = Q∗HQ.
Therefore we have performed a similarity transform, so the new H has the same
eigenvalues as the old one, and if we ﬁnd an eigendecomposition of RQ, then we
have an eigendecomposition of H.
The arithmetic cost of this step is O(n2).
We repeat Step 2 O(n) times. Although it is not obvious, some subdiagonal elements
of H often converge to zero. Once that happens, we can read some eigenvalues off the
diagonal.
In order to ensure convergence of all subdiagonal elements and make it faster, there
are many reﬁnements to the algorithm, mostly involving shifting the matrix (by subtracting
a multiple γ of the identity matrix, factoring H −γ I = QR and forming the new H by
RQ + γ I) in order to emphasize one eigenvalue for the iteration. The resulting algorithm
typically requires about 2n iterations of Step 2 [37, p. 173]), so the total arithmetic cost is
O(n3).
In MATLAB, we compute the eigendecomposition as [U,Lambda] = eig(A).
In general, the eigenvalues with large magnitude are computed more accurately than
those of small magnitude. This happens because, due to rounding error, a stable algorithm

November 20, 2008 10:52
sccsbook
Sheet number 81 Page number 71
cyan magenta yellow black
5.5. Eigendecomposition
71
computes the exact eigendecomposition for some matrix close to the given matrix A. The
eigenvalues cannot be changed by more than the norm of the perturbation, so the large
eigenvalues are computed quite accurately. But if A has an eigenvalue close to zero, the
relative error in its computed value may be large.
Applications of the eigendecomposition include determining modes of resonance of
structures (see Chapter 31), determining the long-term behavior of a Markov chain (used
implicitly in Chapters 17 and 19), determining the solution (or stability) of a system of
linear differential equations (Section 20.1.2), and analyzing the stability of control systems,
as in the next section.
5.5.2
Mini Case Study: Stability Analysis of a Linear Control System
Any automatic system must accomplish its goal without going out of control. For example,
the antilock braking system on an automobile must be able to bring the car to a stop as
quickly as possible without causing it to skid. Control theory is a complicated area, but
the ﬁrst thing to know about it is the importance of stability of the system.6 Without
stability, small changes in the controls create arbitrarily large changes in the response of
the system, and this can be dangerous.
Suppose we have a model of our system:
xk+1 = Axk +Buk,
vk = Cxk +Duk,
where
• A (n ×n), B (n × p), C (q ×n), and D (q × p) are design matrices,
• xk is the state vector of the system at time k,
• uk deﬁnes the controls used on the system at time k,
• vk is some observation of the system at time k.
For stability, i.e., for small changes in u to make small changes in x, it is sufﬁcient
that ∥A∥2 < 1.
For example, we might want to design a system with
A =
⎡
⎣
.5
.4
a
a
.3
.4
.3
.3
.3
⎤
⎦,
(5.3)
where a is a parameter to be determined. We might wish to determine the range of values of
a for which ∥A∥2 < 1. This is one type of stability problem; other matrix stability problems
involve determining whether all of the eigenvalues of a matrix lie in the left half-plane.
CHALLENGE 5.13.
Determine the range of values of a in (5.3) for which ∥A∥2 < 1.
6Using the terminology in Chapter 1, we would call the system well-conditioned or ill-conditioned, but
the jargon of the ﬁeld is stable or unstable.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 82 Page number 72
cyan magenta yellow black
72
Chapter 5. Matrix Factorizations
5.5.3
Other Uses for Eigendecompositions
The eigendecomposition of a matrix determines its invariant subspaces and is also used to
study convergence of iterations, as demonstrated in the next two challenges.
CHALLENGE 5.14. (Challenging: requires considerable comfort with linear algebra.)
Let A be an n ×n matrix with linearly independent eigenvectors u1,...,un. Let S be
a subspace of Rn such that for any x ∈S, the vector Ax is also in S. We call S an invariant
subspace for A.
Show that S is an invariant subspace if a subset of the eigenvectors of A contains a
basis for it. (This is actually an if and only if statement, but proving the other direction is
more challenging.)
CHALLENGE 5.15.
Let A be an n ×n matrix with a full set of linearly independent eigenvectors. Given
a vector x(0), consider the iteration
x(k+1) = Ax(k) +b,
for k = 0,1,.... (This is called a stationary iterative method or SIM.)
(a) Suppose we have a vector xtrue satisfying
xtrue = Axtrue +b.
Such a vector is called a ﬁxed point of the iteration. Show that if e(k) = x(k) −xtrue, then
e(k+1) = Ae(k).
(b) Show by induction that
e(k) = Ake(0).
(c) Show that e(k) →0 as k →∞for any initial vector x(0) if and only if all eigenvalues of
A lie within the unit circle; i.e., if and only if |λj| < 1 for j = 1,...,n. Hint: To do this,
consider expressing e(0) as
e(0) =
n
	
j=1
αjuj,
where uj are the eigenvectors of A and the values αj are appropriate coefﬁcients. Now
compute Ake(0) and study its convergence.

November 20, 2008 10:52
sccsbook
Sheet number 83 Page number 73
cyan magenta yellow black
5.6. The Singular Value Decomposition (SVD)
73
POINTER 5.7. The Relation between the 2-Norm and the SVD.
The largest singular value of a matrix is its 2-norm. The 2-norm condition number
κ(A) is the ratio between the largest singular value and the smallest. Equivalently, it is the
square root of the ratio between the largest and smallest eigenvalues of A∗A.
5.6
The Singular Value Decomposition (SVD)
Every matrix A of dimension m ×n (m ≥n) can be decomposed as
A = UV∗,
where
• U has dimension m ×m and U∗U = I,
•  has dimension m × n, the only nonzeros are on the main diagonal, and they are
nonnegative real numbers σ1 ≥σ2 ≥··· ≥σn ≥0,
• V has dimension n ×n and V∗V = I.
This is the SVD. Observe that
A∗A = (UV∗)∗UV∗
= V∗U∗UV∗= V∗V∗.
So we have a decomposition of the real symmetric matrix A∗A as a unitary matrix times a
diagonal matrix times the conjugate transpose of the unitary, and the diagonal matrix has
entries σ 2
i . Therefore, by the eigendecomposition (5.2), we have the following facts:
• The singular values σi of A are the square roots of the eigenvalues of A∗A.
• The columns of V are the right singular vectors of A and the eigenvectors of A∗A.
• By forming AA∗, we would see that the columns of U, which are the left singular
vectors of A, are the eigenvectors of AA∗.
5.6.1
Computing and Using the SVD
Because of the SVD-eigendecomposition relation, algorithms to compute the SVD are vari-
ants on algorithms for computing eigendecompositions. We won’t give details, but note that
it is rather complicated, so you would want to use a high-quality existing function rather
than writing your own. Also because of this relationship, the singular values are quite stable
with respect to perturbations in the matrix A.
In MATLAB we compute [U,S,V] = svd(A). The arithmetic cost of computing
the SVD is O(mn2) when m ≥n. The constant is usually of order 10.
Uses of the SVD include solving ill-conditioned least squares problems and solving
discretized ill-posed problems (See the case study in Chapter 6.).
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 84 Page number 74
cyan magenta yellow black
74
Chapter 5. Matrix Factorizations
The SVD is expensive but the information it provides is quite reliable. Its main virtue
is that it can be used to solve almost any of the problems we have discussed: solving linear
systems of equations, determining the range and null space of a matrix, and solving least
squares problems and other problems, as we see in the following challenges.
CHALLENGE 5.16.
Suppose we have an SVD of a nonsingular matrix A of dimension n ×n: A = UV∗.
Given the SVD, how many multiplications would it take to solve the linear system Ax = b?
(In your answer, make clear how you would use the factors to solve the problem.)
CHALLENGE 5.17.
If A = UV∗, ﬁnd an orthogonal basis for
(a) the range of A,
(b) the null space of A∗.
CHALLENGE 5.18.
(a) Suppose the matrix A is m ×n and suppose that b is in the range of A. Give a formula
for all solutions to the equation Ax = b in terms of the SVD of A, when m ≥n and A has
rank p < n.
(b) Suppose the matrix A is m ×n with rank(A) = n < m. Give a formula for all solutions
to the equation A∗x = b in terms of the SVD of A.
So if you are stranded on a desert island and allowed only one piece of linear algebra
software, which should you choose?
5.6.2
Mini Case Study: Solving Ill-Conditioned and Rank-Deﬁcient
Least Squares Problems
Suppose we want to solve the least squares problem
min
x ∥b−Ax∥2 .
As in (5.1), we deﬁne the residual to be r = b −Ax. Since ∥r∥2 = r∗r = (U∗r)∗(U∗r) =
∥U∗r∥2, we can minimize the norm of r by minimizing the norm of U∗r = U∗b−U∗Ax =
c−V∗x, where
ci = u∗
i b,
i = 1,...,m,
and ui is the ith column of U. If we change the coordinate system (as in Section 5.3.3) by
letting w = V∗x, then our problem is to minimize
∥U∗r∥2 = |c1 −σ1w1|2 +···+|cn −σnwn|2 +|cn+1|2 +···+|cm|2.

November 20, 2008 10:52
sccsbook
Sheet number 85 Page number 75
cyan magenta yellow black
5.6. The Singular Value Decomposition (SVD)
75
POINTER 5.8. Matrix Approximation.
Two other facts about the SVD are useful:
• The SVD expresses the matrix A as a sum of rank-1 matrices
A = UV∗=
n
	
j=1
σjujv∗
j ,
and it is worthwhile to take the time to verify this.
• The best rank p approximation to A, in the sense of minimizing both ∥A −˜A∥2 and
∥A−˜A∥F, is
˜A =
p
	
j=1
σjujv∗
j .
Thus the SVD can be useful in matrix approximation problems.
In the next two challenges we see that the SVD gives us not only an algorithm for
solving the linear least squares problem, but also a measure of the sensitivity of the solution
x to small changes in the data b.
CHALLENGE 5.19.
Our data vector b has been measured with some error. Let btrue be the true but
unknown data, and let Axtrue = btrue.
(a) The columns of the matrix V = [v1,...,vn] form an orthonormal basis for n-dimensional
space. Let’s express the solution xtrue to the least squares problem as
xtrue = w1v1 +···+wnvn .
Determine a formula for wi (i = 1,...,n) in terms of U, btrue, and the singular values of A.
(b) Justify the reasoning behind these two statements.
A(x−xtrue) = b−btrue −r means ∥x −xtrue∥≤1
σn
(∥b−btrue −r∥),
btrue = Axtrue means ∥btrue∥= ∥Axtrue∥≤∥A∥∥xtrue∥.
(c) Use the two statements above and the fact that ∥A∥= σ1 to derive an upper bound
on ∥x −xtrue∥/∥xtrue∥in terms of the condition number κ(A) ≡σ1/σn and ∥b −btrue −
r∥/∥btrue∥.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 86 Page number 76
cyan magenta yellow black
76
Chapter 5. Matrix Factorizations
−0.2
−0.15
−0.1
−0.05
0
0.05
0.1
0.15
−0.2
−0.15
−0.1
−0.05
0
0.05
0.1
0.15
Changes in x for Linear System 2
δ x1
δ x2
Figure 5.4.
Perturbations in the two coordinates of the solution to an ill-
conditioned linear system.
CHALLENGE 5.20.
Denote the SVD of the 2 ×2 matrix A by UV∗.
(a) Express the solution to the linear system Ax = b as x = α1v1 +α2v2, where V = [v1, v2].
(b) Consider the linear system Ax = b with
A =

1 +δ
δ −1
δ −1
1 +δ

,
b =

2
−2

,
and δ = 0.002, and suppose we compute the solution to the nearby systems
(A+E(i))x(i) = b
for i = 1,...,1000, where the elements of E(i) are independent and normally distributed
with mean 0 and standard deviation τ = .0001. Note that this system is very ill-conditioned;
the graphs of the two equations lie almost on top of each other. Using part (a), explain why
the resulting solutions all fall near a straight line, as shown in Figure 5.4.
Sometimes we want to solve least squares problems in which the rank of the matrix
A is p < n. Convince yourself that the problem has many solutions, but a solution x of
minimal norm is computed by Algorithm 5.5.
5.7
Some Matrix Tasks to Avoid
There are some matrix computations that should be avoided, either because there are better
alternatives or they are too expensive. Here are two examples:

November 20, 2008 10:52
sccsbook
Sheet number 87 Page number 77
cyan magenta yellow black
5.7. Some Matrix Tasks to Avoid
77
Algorithm 5.5 Minimum-Norm Solution to a Least Squares Problem
Compute c = U∗b, where A = UV∗.
Let p be the number of nonzero singular values of A.
for j = 1,..., p,
Set wj = cj/σj.
end
The minimum norm solution is x = V(:,1 : p)w.
The norm of the residual is (|cp+1|2 +···+|cm|2)1/2.
• Computing a matrix inverse. We can solve Ax = b by multiplying both sides of the
equation by A−1:
A−1Ax = x = A−1b.
Therefore, we can solve linear systems by multiplying the right-hand side b by A−1.
This is generally a BAD idea. It is more expensive than the LU decomposition and
it generally computes an answer that has larger error. Using the LU decomposition
with pivoting in ﬂoating-point arithmetic is guaranteed to produce a vector x that
solves a nearby problem Ax = b −r, where r is small. There is no such guarantee
when you solve using A−1.
So, whenever you see a matrix inverse in a formula, think “LU decomposition.”
Because of this, never compute a matrix inverse unless you really want to look at
the entries in it. Otherwise, ﬁnd a decomposition that accomplishes your task. Your
answer is then generally more accurate and less expensive than if you used the inverse
matrix. If you choose to use A−1, at least be aware of the trade-offs.
• Computing the Jordan canonical form of a matrix. As we mentioned above, some
matrices do not have an eigendecomposition. For example,
A =
⎡
⎢⎢⎢⎣
1
1
0
0
0
0
1
1
0
0
0
0
1
1
0
0
0
0
1
1
0
0
0
0
1
⎤
⎥⎥⎥⎦
has an eigenvalue 1 of multiplicity 5, but its only right-eigenvector is e1, the ﬁrst
column of the identity matrix. Therefore, the full-rank matrix of eigenvectors does
not exist. (The matrix is called defective since it fails to have a full set of eigenvec-
tors.) This is an example of a Jordan block, with a multiple eigenvalue and only one
linearly independent eigenvector.
Every matrix can be decomposed into Jordan canonical form as
A = WJW−1,
where W is nonsingular and J is almost diagonal, with the eigenvalues on the main
diagonal and ones in positions on the superdiagonal deﬁning the Jordan blocks. If the
eigendecomposition exists, then this decomposition is just the eigendecomposition
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 88 Page number 78
cyan magenta yellow black
78
Chapter 5. Matrix Factorizations
POINTER 5.9. Software for Matrix Decompositions.
For computing matrix decompositions and solving matrix problems in FORTRAN
or C, look for LAPACK
software [2] (more than 20 million downloads!). For Java, see
http://math.nist.gov/javanumerics/. These systems provide
• numerically stable algorithms,
• a uniform interface, making them easy to use,
• row or column oriented implementation, appropriate for the matrix storage scheme
used by the language,
• efﬁcient software built using BLAS.
(More precisely, they are efﬁcient when n is large (100 or more). The overhead for small n
is rather big.)
(J is diagonal) and the computation can be done as in Section 5.5. If not, rounding
error introduced in computing the eigendecomposition generally changes the matrix
enough to make it nondefective so that an eigendecomposition exists.
Note that the A in our example is arbitrarily close to a matrix that has a full set of
eigenvectors:
⎡
⎢⎢⎢⎣
1
1
0
0
0
0
1 +ϵ
1
0
0
0
0
1 −ϵ
1
0
0
0
0
1 +2ϵ
1
0
0
0
0
1 −2ϵ
⎤
⎥⎥⎥⎦,
for example, where ϵ > 0 is arbitrarily small. This is true for any defective matrix,
and for this reason it is difﬁcult to determine whether a given matrix is defective.
There are alternatives to Jordan canonical form that are generally just as useful com-
putationally; in particular, the Schur decomposition, which factors A as URU∗with
U unitary and R upper triangular, also displays the eigenvalues, and its computation
is stable [139]. See Chapter 30 for a use of this decomposition.
5.8
Summary
We summarize in Table 5.1 our matrix decompositions and their uses. We review this
material in the following two challenges.
CHALLENGE 5.21.
Suppose we have a matrix A of dimension n ×n of rank n −1. Explain two numeri-
cally stable ways to ﬁnd a nonzero vector z so that Az = 0.

November 20, 2008 10:52
sccsbook
Sheet number 89 Page number 79
cyan magenta yellow black
5.8. Summary
79
POINTER 5.10. Further Reading.
More information on the LAPACK software can be found in the users’ guide [2].
Matrix decompositions are covered in more detail in [64] and [139].
Table 5.1. A summary of our matrix decompositions.
Decomposition
Multiplications
Examples of uses
LU
n3/3
Solving linear systems.
Computing determinants.
QR
mn2
Solving well-conditioned linear least squares problems.
(Gram–Schmidt)
Representing the range or null space of a matrix.
rank-revealing
mn2
Determining whether a matrix is rank-deﬁcient.
QR
Representing the range or null space of a matrix.
(Gram–Schmidt)
Solving rank-deﬁcient least squares problems.
Fitting a model with a reduced number of parameters.
eigen-
O(n3)
Determining eigenvalues or eigenvectors of a matrix.
decomposition
Determining invariant subspaces.
Determining stability of a control system.
Determining convergence of Ap as p →∞.
SVD
O(mn2)
Solving ill-conditioned linear least squares problems.
Solving discretizations of ill-posed problems.
Fitting a model with a reduced number of parameters.
Representing the range or null space of a matrix.
Computing an approximation to a matrix.
CHALLENGE 5.22.
Choose a matrix decomposition that can be used to efﬁciently solve each of the
following problems in a stable manner, and review how the solution can be computed given
the decomposition.
(a) Find the null space of a matrix.
(b) Solve a least squares problem when the matrix is well conditioned.
(c) Determine the rank of a matrix.
(d) Find the determinant of a matrix.
(e) Determine whether a symmetric matrix is positive deﬁnite.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 90 Page number 80
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 91 Page number 81
cyan magenta yellow black
Chapter 6 / Case Study
Image Deblurring:
I Can See Clearly
Now
(coauthored by James G. Nagy)
Inverse problems are among the most challenging computations in science and en-
gineering. They involve determining the parameters of a system that is only observed
indirectly. For example, we may have a spectrum and want to determine the species that
produced it, as well as their relative proportions. Or we may have taken sonar measure-
ments of a containment tank and want to decide whether it has a hidden crack.
In this case study we consider such an inverse problem: given a blurred image and a
linear model for the blurring, reconstruct the original image. This is a linear inverse prob-
lem (a discrete ill-posed problem that comes from an integral equation of the ﬁrst kind
(See Pointer 6.1). It illustrates the impact of ill-conditioning on the choice of algorithms.
Although deblurring your vacation pictures might be important to you, the techniques we
study are even more important for applications such as interpreting CAT scans or astro-
nomical images.
Consider a linear system of equations
Kf = g,
where K is a real n ×n matrix, and f and g are vectors. Such a system turns out to be a good
model for the process of blurring an image f by a blurring matrix K to obtain an observed
image g; see Pointers 6.1 and 6.2 for the connection. Now suppose that K is scaled so
that its largest singular value is σ1 = 1. If the smallest singular value is σn ≈0, then K is
ill-conditioned. We distinguish two types of ill-conditioning:
• The matrix K is considered numerically rank deﬁcient if there is a j such that
σj ≫σj+1 ≈··· ≈σn ≈0.
That is, there is an obvious gap between large and small singular values.
• If the singular values decay to zero with no particular gap in the spectrum, then we
say the linear system Kf = g is a discrete ill-posed problem.
81
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 92 Page number 82
cyan magenta yellow black
82
Chapter 6. Case Study: Image Deblurring: I Can See Clearly Now
50
100
150
200
250
50
100
150
200
250
Figure 6.1. Can you deblur this image?
POINTER 6.1. Where Does the Image Data Come From?
In our model Kf + η = g, the vector g contains the recorded image, and the noise η
arises from imperfections in recording the data.
Let f be the true image. Then f is actually a function over some two-dimensional
domain that we call , pehaps [0,1]×[0,1]. The function values are the intensities of the
image at each coordinate (s1,s2) in the domain.
Let g be the recorded image. Again, g is actually a function over the two-dimensional
domain, but we have only a few samples of this function, perhaps an nr ×nc array of pixel
values which we may assume are measured at points sjk = ( j/nr,k/nc) for j = 1,...,nr,
k = 1,...,nc. To form the vector we call g, we stack the columns of this two-dimensional
array of values to form a single column with nrnc entries. We use these recorded values to
estimate a vector f, which might correspond to samples at the same points sjk as those that
determine g.
It is very difﬁcult to compute accurate approximate solutions of discrete ill-posed problems,
especially because in most real applications, the right-hand-side vector g is not known
exactly. Rather, it is more typical that the collected data have the form
g = Kf +η,
where η is a vector representing (unknown) noise or measurement errors. The goal, then,
is: Given an ill-conditioned matrix K and a vector g, compute an approximation of the
unknown vector f. Naïvely solving Kf = g usually does not work, since the matrix K is
so ill-conditioned. Instead, one usually uses something called regularization to make the
problem less sensitive to the noise.

November 20, 2008 10:52
sccsbook
Sheet number 93 Page number 83
cyan magenta yellow black
Method 1: Tikhonov Regularization
83
POINTER 6.2. Where Does the Matrix Problem Come From?
For simplicity, we consider the noise-free case with η = 0. Then the recorded image
g is the result of the convolution of the true image f with a recording device speciﬁed by
a kernel function K so that
g(s) =


K(s,t) f (t)dt.
If K(s,t) = δ(∥s −t∥), where δ is the Dirac δ function, then g(s) = f (s); this is the ideal
case, and K is zero almost everywhere.
In practical situations, K is not this nice, although it often has small support, so that
K(s,t) is zero when t and s are not close to each other. In this case, the value of the integral
is a weighted average of values of f in a neighborhood of s.
We obtain the matrix equation g = Kf by discretizing the integral. The row of this
equation corresponding to sjk approximates the relation
g(sjk) =


K(sjk,t) f (t)dt ≈
nr
	
ℓ=1
nc
	
p=1
wℓpK(sjk,tℓp) f (tℓp),
where the values wℓp are chosen to make the approximation as accurate as desired. For
example, choosing wℓp = 1/(nrnc) for all values of ℓand p gives a rectangle rule for
integration. If we use our sample values of s as sample values for t, then the entry in the
row of K corresponding to sjk and the column corresponding to sℓp is wℓpK(sjk,sℓp), and
this deﬁnes our matrix problem.
If the kernel function has the property that K(s,t) depends only on the difference s−t,
then ordering the pixels row-by-row (or column-by-column)gives a matrix with Kronecker
product structure.
One additional issue needs to be addressed: how do we determine K? Usually it is
either modeled by some mathematical function or measured by aiming the camera at a point
source: a picture that is black except for a single white pixel. By moving that white pixel
and repeating the measurement—or by assuming that the image is unchanged except for
translation as we move the white pixel—we can approximately determine all of the values
K(sjk,sℓp).
Method 1: Tikhonov Regularization
The best-known regularization procedure, called Tikhonov regularization, computes a
solution of the damped least squares problem
min
f
{||g−Kf||2
2 +α2||f||2
2}
(6.1)
The extra term α2||f||2
2 imposes a penalty for making the norm of the solution too big, and
this means that the effects of small singular values are reduced. This regularized problem
is also a least squares problem.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 94 Page number 84
cyan magenta yellow black
84
Chapter 6. Case Study: Image Deblurring: I Can See Clearly Now
CHALLENGE 6.1.
Show that (6.1) is equivalent to the linear least squares problem
min
f


g
0

−

K
αI

f

2
2
.
(6.2)
The scalar α (called a regularization parameter) controls the degree of smoothness
of the solution. Note that α = 0 implies no regularization, and for a discrete ill-posed
problem, the computed solution of (6.2) with α = 0 is likely to be horribly corrupted with
noise. On the other hand, if α is large, then the computed solution cannot be a good
approximation to the exact f. It is not a trivial matter to choose an appropriate value for α.
Various algorithms are discussed in the literature [69, 131], but we use a manual approach
here.
We turn to the problem of solving the least squares problem (6.2).
CHALLENGE 6.2.
Show that if K has a singular value decomposition K = UVT , then (6.2) can be
transformed into the equivalent least squares problem
min
f


g
0

−


αI

f

2
2
,
(6.3)
wheref = VT f andg = UT g.
CHALLENGE 6.3.
Derive a linear system of equations whose solution is the solution to (6.3). Hint: Set
the derivative of the minimization function to zero and solve forf.
This gives us an algorithm to determine the Tikhonov solution to a discrete ill-posed
problem. Next we consider a second method for regularization.
Method 2: Truncated SVD
Another way to regularize the problem is to truncate the singular value decomposition. The
next challenge demonstrates how the solution to the least squares problem can be expressed
in terms of the SVD.
CHALLENGE 6.4.
Show that the solution to the problem
min
f
||g−Kf||2
2

November 20, 2008 10:52
sccsbook
Sheet number 95 Page number 85
cyan magenta yellow black
Method 2: Truncated SVD
85
can be written as
fℓs = V†UT g ≡
n
	
i=1
uT
i g
σi
vi ,
where ui is the ith column of U and vi is the ith column of V.
We see that trouble occurs in fℓs if we have a small value of σi dividing a term uT
i g
that is dominated by error. In that case, fℓs is dominated by error, too.
To overcome this, Golub and Kahan [62] suggested truncating the expansion above:
ft =
p
	
i=1
uT
i g
σi
vi
for some value of p < n.
Using Regularization for Image Deblurring
Now we have all the tools in place to solve a problem in image processing: image deblur-
ring. Suppose we have a blurred, noisy image G, as in Figure 6.1, and some knowledge
of the blurring operator, and we want to reconstruct the true original image F. This is an
example of a discrete ill-posed problem, where the vectors in the linear system g = Kf +η
represent the image arrays stacked by columns to form vectors. In MATLAB notation,
• f = reshape(F,n,1),
• g = reshape(G,n,1).
The goal in this problem is, given K and G, reconstruct an approximation of the unknown
image F.
If we assume F and G contain √n ×√n pixels, then f and g are vectors of length n,
and K is an n × n matrix representing the blurring operation. In general this matrix is too
large to use the SVD. However, in some cases K can be written as a Kronecker product,
K = A⊗B, and the SVD can be used.
A Few Facts on Kronecker Products
The Kronecker product A⊗B, where A is an m ×m matrix, is deﬁned to be
A⊗B =
⎡
⎢⎢⎢⎣
a11B
a12B
...
a1mB
a21B
a22B
...
a2mB
...
...
...
...
am1B
am2B
...
ammB
⎤
⎥⎥⎥⎦.
Kronecker products have a very convenientproperty: If A = UAAVT
A, B = UBBVT
B,
then
K = A⊗BK = UVT ,
where U = UA ⊗UB,  = A ⊗B, and V = VA ⊗VB.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 96 Page number 86
cyan magenta yellow black
86
Chapter 6. Case Study: Image Deblurring: I Can See Clearly Now
POINTER 6.3. Further Reading.
Regularization methods are considered in detail by Hansen [68]. Kronecker prod-
ucts are discussed by Horn and Johnson [81]. Hansen, Nagy, and O’Leary [69] give more
detail on image deblurring using matrix techniques.
Therefore, it is possible to compute the SVD of a rather large matrix if it is the Kro-
necker product of two smaller ones. The website for this book contains a sample MATLAB
program, projdemo.m, illustrating this property.
In order to solve our image deblurring problem, we need to operate rather carefully
with the small matrices; otherwise, storage quickly becomes an issue. Again, see the sam-
ple program for guidance. With the Kronecker product as a tool, we are ready to compute.
CHALLENGE 6.5.
Write a program that takes matrices A and B and an image G and computes an image
F using
• Tikhonov regularization,
• truncated SVD.
For each of these two algorithms, experiment to ﬁnd the value of the regularization param-
eter (α for Tikhonov or p for truncated SVD) that gives the clearest image.
Sample data (i.e., a blurred image G, and the matrices A and B) are given on the
book’s website. Your job is to restore the image well enough that you can read the text in
it.
Report how you decided what parameters to try. Comment on the usefulness of the
two methods for this particular example.

November 20, 2008 10:52
sccsbook
Sheet number 97 Page number 87
cyan magenta yellow black
A
B
E
C
D
50
Chapter 7 / Case Study
Updating and
Downdating Matrix
Factorizations:
A Change in Plans
We seldom get it right the ﬁrst time. Whether we are composing an important e-mail,
seasoning a stew, painting a picture, or planning an experiment, we almost always make
improvements on our original thought. The same is true of engineering design; we draft a
plan, but changes are almost always made. Perhaps the customer changes the performance
speciﬁcations, or perhaps a substitution of building materials leads to a redesign. In this
case study, we consider numerical methods that make it easier to reanalyze the design after
small changes are made. For deﬁniteness, we focus on truss design, but the same principles
apply to any linear model.
Consider the truss at the top of Figure 7.1. Beginning engineering students learn
to compute the force acting on each truss member (beam) by considering equations for
each node in the truss, ensuring that the sum of the horizontal forces is zero, the sum
of the vertical forces is zero, and the moment is zero. They can “march” through the
equations, solving for the horizontal and vertical forces by a clever ordering. If the design
is changed—by moving a node, for example, as in the second truss in the ﬁgure—then the
resulting forces are just as easy to determine.
For more complex models, for example, a ﬁnite element model of the forces on the
bridge of Figure 1.1, “marching” no longer works, and the system of equations must be
solved using a method such as Gauss elimination. We would like to have an algorithm
that would enable us to easily recompute the forces if the design of the bridge is changed
slightly.
To introduce methods for solving modiﬁed models, let’s return to the Figure 7.1
example, forget the marching trick, and write a system of equations Af = ℓfor the unknown
force on each member. The matrix of the system has one column for each unknown force
and two rows per node (for horizontal and vertical forces). The load on node C is put in the
right-hand side. For the very simple top truss of Figure 7.1, for example, there are n = 10
87
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 98 Page number 88
cyan magenta yellow black
88
Chapter 7. Case Study: Updating and Downdating Matrix Factorizations
A
B
E
C
D
50
A
B
C
D
E
50
Figure 7.1. (Top) A truss with 5 nodes and 7 equal-length members, loaded with
a force of 50 Newtons. Node A is ﬁxed (supported horizontally and vertically) and node E
is rolling (supported only vertically). (Bottom) A change in the truss. Member CE is now
two times its original length.
forces to be computed, the solution to the linear system
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
−1
0
c
0
0
0
0
1
0
0
0
1
s
0
0
0
0
0
0
0
0
0
−c
c
0
0
1
0
0
0
0
0
s
s
0
0
0
0
0
0
0
0
0
−c
c
0
0
−1
1
0
0
0
0
s
s
0
0
0
0
0
0
0
0
0
−c
c
−1
0
0
0
0
0
0
0
s
s
0
0
0
0
0
0
0
0
0
−c
0
0
−1
0
0
0
0
0
0
s
0
0
0
−1
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
fAh
fAv
fAB
fBC
fC D
fDE
fBD
fAC
fC E
fEv
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
=
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
ℓAh
ℓAv
ℓBh
ℓBv
ℓCh
ℓCv
ℓDh
ℓDv
ℓEh
ℓEv
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
. (7.1)
The subscript Ah, for example, denotes a horizontal force at node A, and the subscript BC
refers to the member connecting nodes B and C. The right-hand-side vector is zero except
for the entry ℓCv, which is −50, corresponding to the vertical load on node C. The truss
members are all equal length, so c = cos(π/3) and s = sin(π/3).

November 20, 2008 10:52
sccsbook
Sheet number 99 Page number 89
cyan magenta yellow black
Changes to the Matrix
89
There are several simple kinds of changes to the truss design that produce “small”
changes in the system of equations. For example:
• If we change the loading on the truss, then we keep the same matrix but change the
right-hand-side ℓ.
• If we add a new node along with two new truss members, then our new matrix has
two additional rows and columns and contains the old matrix as a submatrix.
• If we remove a set of nodes and their truss members, then we delete the columns of
the matrix corresponding to the forces exerted by the members and we delete the pair
of rows corresponding to each removed node.
• If we move a node, then we change the two rows corresponding to the horizontal
and vertical forces on that node, and we change the columns corresponding to its
members.
For a problem with n = 10 unknowns, we could easily recompute the answer after
any of these changes, but if n = 1,000,000, then we might want to take advantage of our
solution to the original problem to more quickly obtain a solution to the modiﬁed problem.
In this case study, we develop the tools to do this.
Changes to the Right-Hand Side
If we need to analyze the truss for several different loadings, then it is a good idea to
compute a decomposition of the matrix A once and save it for multiple uses. For example,
suppose that we compute the LU decomposition with partial pivoting
PA = LU,
(7.2)
where P is a permutation matrix that interchanges rows of A, L is a lower-triangular matrix,
and U is an upper-triangular matrix. Then each of the loads can be processed by solving
Ly = PT ℓ
by forward substitution and then computing
Uf = y
by back substitution. If A is a dense matrix, with very few nonzeros, then the initial LU de-
composition costs O(n3) operations, while forward and back substitution costs only O(n2).
Taking advantage of the sparsity of A can reduce the cost of both the LU decomposition
and the substitution (see Chapter 27), but substitution is still signiﬁcantly less costly than
factorization, especially when n is large.
Changes to the Matrix
The Sherman–Morrison–Woodbury Formula
Sometimes our matrix changes in a rather simple way, and we want to reconsider our
problem, making use of the original decomposition without explicitly forming the update.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 100 Page number 90
cyan magenta yellow black
90
Chapter 7. Case Study: Updating and Downdating Matrix Factorizations
POINTER 7.1. Other Uses for Updated Models.
The problem of efﬁciently handling small changes in the model matrix arises in many
situations other than engineering design.
• Suppose we are solving a system of linear inequalities
Ax ≥b
with A of dimension m × n (m ≥n) and we think that the ﬁrst n of them should be
active:
aT
i x = bi,
i = 1,...,n,
where aT
i is the ith row of A. Suppose then that the solution to these equations
violates the kth inequality (k > n), and we want to add this inequality to our current
system of equations and delete the jth equation. Can we solve our new linear system
easily?
This problem routinely arises in minimization problems when we have linear in-
equality constraints (see Chapter 10), and is the basic computation in the simplex
algorithm for solving linear programming problems.
• Suppose that we are solving a linear least squares problem
Ax ≈b
or
min
x ∥b −Ax∥,
and we get some new measurements. This adds rows to A and b. Can we solve our
new least squares problem easily?
• Suppose we have computed the eigenvalues and eigenvectors of A, and then A is
changed by addition of a rank-1 matrix
A = A+crT .
What are the eigenvalues of A?
Each of these problems (and similar ones) can be solved cheaply using the techniques
discussed in this case study.
As an example, suppose we have the decomposition from equation (7.2) and now we
want to solve the linear system
(A−zvT )f = ℓ,
where z and v are column vectors of length n, so that zvT is an n ×n matrix. For example,
if we decide to move node E as in the truss of Figure 7.1, then we need to change column

November 20, 2008 10:52
sccsbook
Sheet number 101 Page number 91
cyan magenta yellow black
Changes to the Matrix
91
6 in our matrix. To do this, we set v to be the sixth column of the identity matrix and set z
to be the difference between the old column and the new one.
In the next challenge, we see how to apply this principle to more than one set of
changes in the matrix.
CHALLENGE 7.1.
(a) Suppose we want to change columns 6 and 7 in our matrix A. Express the new matrix
as A−ZVT , where Z and V have dimension n ×2.
(b) Suppose we want to change both column 6 and row 4 of A. Find Z and V so that our
new matrix is A−ZVT .
In the next challenge, we see how this formulation of our new matrix as a small-rank
change in our old matrix leads to an efﬁcient computational algorithm.
CHALLENGE 7.2.
(a) Assume that A and A−ZVT are both nonsingular. Show that
(A−ZVT )−1 = A−1 +A−1Z(I−VT A−1Z)−1VT A−1
by verifying that the product of this matrix with A −ZVT is the identity matrix I. This is
called the Sherman–Morrison–Woodbury formula.
(b) Suppose we have an LU decomposition of A as in (7.2). Assume that Z and V are
n ×k and k << n. Show that we can use this decomposition and the Sherman–Morrison–
Woodbury formula to solve the linear system (A−ZVT ) f = ℓwithout forming any matrix
inverses. (If A is dense, then we perform O(kn2) operations using Sherman–Morrison–
Woodbury, rather than the O(n3) operations needed to solve the linear system from scratch.)
Hint: Remember that A−1y can be computed by solving a linear system using forward and
back substitution with the factors L and U.
In the following two challenges, we experiment with the Sherman–Morrison–Wood-
bury algorithm to see when it can be useful.
CHALLENGE 7.3.
Implement the Sherman–Morrison–Woodbury algorithm from Challenge 7.2(b). De-
bug it by factoring the matrix in equation (7.1) modeling the top truss in Figure 7.1 and
then changing the model to the second truss.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 102 Page number 92
cyan magenta yellow black
92
Chapter 7. Case Study: Updating and Downdating Matrix Factorizations
0
100
200
300
400
500
600
700
800
900
1000
0
50
100
150
200
250
300
Size of matrix
Rank of update
Making Sherman−Morrison−Woodbury time comparable to Backslash
Figure 7.2. Results of Challenge 7.4. The plot shows the rank k0 of the update for
which the time for using the Sherman–Morrison–Woodbury formula was approximately the
same as the time for solving using factorization. Sherman–Morrison–Woodbury was faster
for n ≥40 when the rank of the update was less than 0.25n.
CHALLENGE 7.4.
For n taken to be various numbers between 10 and 1000, generate a random n × n
matrix A. Find the number of updates k0 that makes the time for solving a linear system
using the Sherman–Morrison–Woodbury method comparable to the time for computing
A \ ℓ. Plot k0 as a function of n. Results for one machine are shown in Figure 7.2. Are
yours similar?
Updating a Matrix Decomposition
The Sherman–Morrison–Woodbury formula enables us to solve modiﬁed linear systems
without explicitly modifying our matrix decomposition. It is very efﬁcient when only a
few changes are to be made.
In some problems, though, we need to do a long series of updates to the matrix,
and it is better to explicitly update the decomposition. We could consider updating an LU
decomposition, but because pivoting is necessary to preserve stability, this can be compli-
cated. Instead let’s use a decomposition that is stable without pivoting. This also enables
us to consider matrices that have more rows than columns, such as those that arise in least
squares problems.
Suppose we have factored
A = QR,

November 20, 2008 10:52
sccsbook
Sheet number 103 Page number 93
cyan magenta yellow black
Changes to the Matrix
93
where A is m ×n with m ≥n, Q is m ×m and orthogonal (QT Q = I), and R is m ×n and
has zeros below its main diagonal. For deﬁniteness, we’ll let A have dimensions 5×3.
As examples, we’ll consider two kinds of common changes:
• Adding a row. In least squares, this happens when new data comes in; in our truss
problem it means that we have a new node.
• Deleting a column. In least squares, this happens when we decide to reduce the num-
ber of parameters in the model; in our truss problem, it could result from removing a
member.
Adding a row.
Denote the new matrix as A. Our decomposition can be written as
A =

Q
0
0
1

⎡
⎢⎢⎢⎢⎢⎣
r11
r12
r13
0
r22
r23
0
0
r33
0
0
0
0
0
0
a61
a62
a63
⎤
⎥⎥⎥⎥⎥⎦
.
(7.3)
In order to complete the decomposition, we need to reduce the as to zeros. We can do this
using n Givens rotations (see Section 5.3.1), which is much faster than recomputing the
entire decomposition.
Let’s see how we can use Givens rotation matrices.
CHALLENGE 7.5.
(a) Given a vector z ̸= 0 of dimension 2×1, ﬁnd a Givens matrix G so that Gz = xe1, where
x = ∥z∥and e1 is the vector with a 1 in the ﬁrst position and zero in the second.
(b) We use the notation Gij to denote an m × m identity matrix with its ith and jth rows
modiﬁed to include the Givens rotation: for example, if m = 6, then
G25 =
⎡
⎢⎢⎢⎢⎢⎣
1
0
0
0
0
0
0
c
0
0
s
0
0
0
1
0
0
0
0
0
0
1
0
0
0
−s
0
0
c
0
0
0
0
0
0
1
⎤
⎥⎥⎥⎥⎥⎦
,
where c2 +s2 = 1. Multiplication of a vector by this matrix leaves all but rows 2 and 5 of
the vector unchanged. Show that we can ﬁnish our QR decomposition in equation (7.3) by
(left) multiplying the R matrix ﬁrst by G16, then by G26, and ﬁnally by G36, where the angle
deﬁning each of these matrices is suitably chosen. In order to preserve the equality, we
multiply the Q-matrix by GT
16GT
26GT
36 on the right, and we have the updated decomposition.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 104 Page number 94
cyan magenta yellow black
94
Chapter 7. Case Study: Updating and Downdating Matrix Factorizations
Deleting a column.
As an example, if we delete column 1 from A, we can write the
decomposition as
A = Q
⎡
⎢⎢⎢⎣
r12
r13
r22
r23
0
r33
0
0
0
0
⎤
⎥⎥⎥⎦.
The resulting R is almost upper triangular; we just need rotations to reduce the elements
labeled r22 and r33 to zero.
In general, we need n −k rotations when column k is deleted.
Algorithms for deleting a row and adding a column are similar to those that we just
discussed. In the next challenge, we construct algorithms for changing a column.
CHALLENGE 7.6.
Write a MATLAB function that updates a QR decomposition of a matrix A when the
entries in a single column are changed. Apply it to the truss examples in Challenge 7.3.
The Point of Updating
It may seem silly to worry so much about whether to update or recompute; computers are
fast, and if we make one change to the matrix, it really doesn’t matter which we do. But
when we need to do the task over and over again, perhaps in a loop that solves a more
complicated problem, it is essential to use appropriate updating techniques to reduce the
cost.
As a ﬁnal example, we consider one more use of matrix updating, adding both a row
and a column.
CHALLENGE 7.7.
Suppose we have factored the n ×n matrix A as PA = LU and now we want to solve
the linear system formed by adding one row and one column to A to make a matrix
Anew =
⎡
⎢⎢⎢⎢⎣
a1,1
...
a1,n
a1,n+1
a2,1
...
a2,n
a2,n+1
...
...
...
...
an,1
...
an,n
an,n+1
an+1,1
...
an+1,n
an+1,n+1
⎤
⎥⎥⎥⎥⎦
.
Express Anew as
Anew =

A
0
0
1

−ZVT
(where Z and V are rank-2 matrices) so that the Sherman–Morrison–Woodbury formula
can be applied.

November 20, 2008 10:52
sccsbook
Sheet number 105 Page number 95
cyan magenta yellow black
The Point of Updating
95
POINTER 7.2. Further Reading.
The QR decomposition and the use of Givens rotations is discussed in Section 5.3.
Other stable methods for modifying matrix decompositions are considered by Gill, Golub,
Murray, and Saunders [58], and Golub [60] and Golub and Van Loan [64] discuss the
solution of eigenvalue problems when the matrix is modiﬁed.
Note that there are many unstable updating algorithms in the literature, so it is im-
portant to understand the importance of stability and use only trusted algorithms such as
the ones given here and in the references in Pointer 7.2.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 106 Page number 96
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 107 Page number 97
cyan magenta yellow black
Chapter 8 / Case Study
The
Direction-of-Arrival
Problem: Coming at
You
If you break your leg on a mountain but have a cell phone or other transmitter with you, you
will hope that a rescuer will be able to determine the direction in which to travel in order to
reach you. Similarly, when a navy detects a transmission from a submarine, they want to
determine the signal’s direction of arrival (DOA) in order to locate the sub. The problem
is complicated if more than one signal needs to be processed, especially if the number of
signals is unknown, and even more complicated if the submarines are moving.
Surprisingly, we will see that your rescuer can solve an eigenvalue problem—in-
volving the product of two unknown matrices—and use that information to ﬁnd you! This
DOA-ﬁnding algorithm is known as ESPRIT. To understand the process, we use several
matrix decompositions and illustrate the necessity of using update techniques, as pre-
sented in Chapter 7, for real-time computations.
The DOA Problem Deﬁnition
Suppose we have d signal sources, each a long distance from the sensors. Suppose that
the signals are narrowband, so that we can approximate each by a plane wave of ﬁxed
frequency ω.
Let’s take m sensor pairs whose locations are arbitrary except that the spacing δ and
the orientation of the two sensors in each pair is constant. We measure the signal reaching
each sensor as a function of time. Figure 8.1 illustrates a sample conﬁguration with m = 4
sensor pairs and d = 2 signal sources. Let sk(t) be the signal emitted from the kth source
at time t, k = 1,...,d, and let s(t) be the vector made up of these components. The vector
function x1(t) denotes the m signal measurements x1 j(t), j = 1,...,m, received by the ﬁrst
sensor in each pair at time t, and x2(t) denotes the corresponding measurements for the
second sensor in each pair.
After we take measurements for some time, we want to determine the DOAs: the
angles between each plane wave and a line parallel to the lines connecting each sensor pair.
We call these d angles θk, k = 1,...,d. In Figure 8.1, the angles are 45◦and −30◦.
97
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 108 Page number 98
cyan magenta yellow black
98
Chapter 8. Case Study: The Direction-of-Arrival Problem
Figure 8.1. Two signals (plane waves) received by four sensor pairs.
We model the sensor measurements as a function of signal as
x1(t) = As(t)+ϵ1(t),
x2(t) = As(t)+ϵ2(t).
The matrix A of size m ×d is an unknown matrix of array steering vectors, and the matrix
 is a diagonal matrix that accounts for the phase delays between the sensors in each pair.
The kth diagonal entry is
φk = eiωδ sinθk/c,
k = 1,...,d ,
where i = √−1 and c is the speed of sound. Our problem, then, is to determine , given
x, δ, and ω, without knowing A, s(t), the measurement noise ϵ1(t) and ϵ2(t), or even d. As
an added complication, if the sources are moving, then  is also a function of t.
We build algorithms on a very clever observation for extracting . Let’s temporarily
assume that we know the number of signals d < m. We observe the system for n timesteps,
obtaining X1 with m rows and n columns containing the data values x1(t). Similarly, we
construct X2 from the data x2(t). This way of collecting the data is called rectangular
windowing because we just look at the data within a time window of size n. If we neglect
the errors ϵ(t), then our system becomes
X =

X1
X2

=

A
A

S,
where the columns of S are s(t). If A is full rank, then its rank is d, and this is also the
maximal rank of X. Consider the following recipe:
• Find a matrix B of size d ×m so that BA is d ×d and full rank.
• Find a matrix C of size n ×d so that SC is d ×d and full rank.
• Find d vectors zk and d values λk so that BASCzk = λkBASCzk.

November 20, 2008 10:52
sccsbook
Sheet number 109 Page number 99
cyan magenta yellow black
SVD-ESPRIT and Rectangular Windowing
99
Note that λk is an eigenvalue of the generalized eigenproblem

Mz = λAz
involving the matrices 
M ≡BASC and A ≡BASC, and zk is the corresponding eigenvec-
tor.
CHALLENGE 8.1.
Let wk = SCzk and show that wk = λkwk. Conclude that the eigenvalues λk are
equal to the diagonal entries of .
We’ve accomplished something rather surprising: without knowing A or , we can
choose matrices B and C of the proper dimensions and construct the matrices for the eigen-
problem just by knowing X, since BASC = BX1C and BASC = BX2C. But we need to
make sure that BA and SC have full rank.
SVD-ESPRIT and Rectangular Windowing
In order to ensure the full-rank conditions, we use the singular value decomposition
(SVD) of a matrix: any matrix F of dimension p ×q can be factored as
F = UW∗,
where U is p × p, W is q × q, U∗U = I, and W∗W = I. The real diagonal matrix  of
dimension p ×q has nonzeros σ1 ≥σ2 ≥··· ≥σˆq, where ˆq = min(p,q). Because U and W
are unitary matrices, their columns (and rows) are well-conditioned bases for the subspaces
they span, and using unitary matrices leads to numerically stable choices for B and C, which
we deﬁne in the next challenge.
CHALLENGE 8.2.
Suppose that the SVD of X is UW∗, where σj = 0, j > d. Let 1 be the square
diagonal matrix with entries σ1,...,σd, and partition U into
U =

U1
U3
U2
U4

,
where U1 and U2 have m rows and d columns, so that
X1 = AS = U1[1, 0d×(n−d)]W∗,
X2 = AS = U2[1, 0d×(n−d)]W∗,
where 0d×(n−d) is the zero matrix of size d ×(n −d). Let U = [U1,U2] have SVD TV∗,
and denote the leading d ×d submatrix of  by 1. Partition
V =
 V1
V3
V2
V4

www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 110 Page number 100
cyan magenta yellow black
100
Chapter 8. Case Study: The Direction-of-Arrival Problem
so that V1 and V2 have dimension d ×d. Let
B = [1−1, 0d×(m−d)]T∗
and
C = W

1−1
0(n−d)×d

.
Show that the eigenvalues λk that satisfy the equation V∗
2zk = λkV∗
1zk are φk.
Thus we have our ﬁrst algorithm for solving the DOA problem:
• Compute the SVD of X = UW∗.
• Compute the SVD of U = [U1,U2] = TV∗.
• Solve the generalized eigenvalue problem V∗
2z = λV∗
1z
for the values λk = φk, k = 1,...,d.
In the next challenge, we investigate how this algorithm performs.
CHALLENGE 8.3.
Program the SVD algorithm and experiment with rectangularly windowed data and a
window size of n = 10. Note that we need to compute U and V, but we do not need B or C.
You can ﬁnd sample data for X and  on the website. Plot the true and computed DOAs as
a function of time and compute the average absolute error in your DOA estimates (absolute
value of true value minus computed value) and the average relative error (absolute error
divided by absolute value of true value). Your results should resemble those in Figure 8.2.
Eigen-ESPRIT and Exponential Windowing
Experimenting further with the data of Challenge 8.3, we would discover that rectangular
windowing has a drawback: if the window size n is too small, then the DOAs are very
sensitive to errors in the measurements and our estimates can change abruptly. But if
the window size is too large, then very old data contribute to our measurements, and our
estimates will be bad if the sources are moving too fast. The cure for this is to use old data
but give more weight to newer data. We do this in exponential windowing by multiplying
all of our old data by a forgetting factor f (with 0 < f ≤1) every time we add new data.
Thus, after n observations, column ℓof X1 contains data from observation ℓmultiplied by
f n−ℓ, and similarly for X2.
Using exponential windowing, the number of columns in the matrix X can grow
very large, so the SVD is too expensive. We could avoid an SVD (for either exponen-
tial windowing or rectangular windowing) but still use an orthogonal basis by noting that
XX∗= UT U∗, so U can be computed from the eigendecomposition of the 2m × 2m
matrix XX∗. The next challenge shows how XX∗can be formed quickly.

November 20, 2008 10:52
sccsbook
Sheet number 111 Page number 101
cyan magenta yellow black
SVD-ESPRIT and Rectangular Windowing
101
0
100
200
300
400
500
600
700
0
5
10
15
20
25
30
Results using rectangular windowing
time
DOA
Figure 8.2. Results of Challenge 8.3: the true DOA (blue) and the DOA estimated
by rectangular windowing (red) as a function of time.
CHALLENGE 8.4.
Suppose that the matrix X contains the exponential windowing data and that a new
data vector x arrives. Give a formula for the new exponential windowing data matrix XX∗
and show that the cost of computing it from X and x is O(m2) multiplications.
Now we try this eigenvalue variant of ESPRIT, computing an eigendecomposition of
XX∗in place of an SVD of X.
CHALLENGE 8.5.
Program the Eigen-ESPRIT algorithm and experiment with exponential windowing
for the data of Challenge 8.3. Use the forgetting factor f = 0.9, and compare the results
with those of Challenge 8.3.
Determining the Number of Sources
Now suppose we do not know how many source signals we are receiving. Recall that if
m ≥d and A is full rank, then its rank is d, and this is also the maximal rank of X. Thus we
can estimate d experimentally by taking it to be the rank of the matrix X. This works ﬁne
in the absence of error if the signals are all stationary, but if they are moving, or if there
is error in our measurements, then the matrix X has some small nonzero singular values in
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 112 Page number 102
cyan magenta yellow black
102
Chapter 8. Case Study: The Direction-of-Arrival Problem
addition to d nonzeros. We need to be able to distinguish between real signals and noise. If
you know some statistics, you can solve the next challenge to predict how large the noise
will be.
CHALLENGE 8.6.
Suppose that we have a matrix X of size m × n, m ≤n, and each element of X is
normally distributed with mean 0 and standard deviation ψ.
(a) Show that the random variable equal to the sum of the squares of the entries of X is
equal to the sum of the squares of the singular values of X.
(b) Show, therefore, that for rectangular windowing of this data, the expected value of
σ 2
1 +···+σ 2
m is ψ2mn, where σj is a singular value of X.
(c) Using a similar argument, show that for exponential windowing, the expected value of
σ 2
1 +···+σ 2
m is approximately m f 2ψ2/(1−f 2), where σi is a singular value of FX. Here,
F is a diagonal matrix, with jth entry equal to f j.
Solving this challenge relies on a formula for a +a2 +···+ak when 0 < a < 1, and infor-
mation in any basic statistics textbook that discusses the normal distribution.
This gives us a way to experimentally determine d: choose it to be the smallest value
for which the remaining singular values satisfy
σ 2
d+1 +···+σ 2
m < n(m −d)κψ2
for rectangular windowing and
σ 2
d+1 +···+σ 2
m < (m −d)κf 2ψ2/(1 −f 2)
for exponential windowing, where κ > 1 is a user-chosen tolerance.
Now we experiment with this algorithm for determining the number of signals and
their directions of arrival.
CHALLENGE 8.7.
Modify the programs so that they also determine d, and explore the methods’ sensi-
tivity to the choice of n, f , and κ.
Using URV for Efﬁciency
Computing SVDs and eigendecompositions from scratch can be too computationally in-
tensive to keep up with the incoming data; the operations counts are proportional to m2n
for the SVD and m3 for the eigendecomposition. In order to keep up with incoming data,
we need to ﬁnd ways to update our DOA estimates at lower cost. Unfortunately, there is no
easy way to update SVDs or eigendecompositions, but there is a closely related decompo-
sition, the rank-revealing URV decomposition, that can be updated. If we substitute this

November 20, 2008 10:52
sccsbook
Sheet number 113 Page number 103
cyan magenta yellow black
Using URV for Efﬁciency
103
POINTER 8.1. Further Reading.
In this case study, we use three matrix decompositions: the SVD and the eigende-
composition from Chapter 5, and the rank-revealing URV decomposition with updating
[141].
The generalized eigenvalue problem used in Challenge 8.1 is discussed in linear
algebra textbooks and numerical linear algebra textbooks such as [64].
The ESPRIT algorithm was proposed in [127]. The URV variant was proposed in
[104], which is also the source of the data we use in Challenge 8.3.
For Challenge 8.8, you can ﬁnd a detailed discussion of the URV-ESPRIT algorithm
in [104].
A more common algorithm for determining DOAs is the Music algorithm. This
algorithm can also be formulated in terms of matrix decompositions. Standard textbooks
such as that of Haykin [70, Chap. 12] provide further information.
for the SVD of X or the eigendecomposition of XX∗, then our algorithm has a cost propor-
tional to d3 + m2 + n2 and is suitable for real-time applications as long as the number of
incoming signals is not too great.
The rank-revealing URV decomposition of X∗is
X∗= URV∗= U
 ¯R
F
0
G

V∗,
where U and V are square unitary matrices (U∗U = I, V∗V = I), ¯R is an upper-triangular
matrix of size d × d, and G is an upper-triangular matrix of size (n −d) × (2m −d). In
addition, the norms of the matrices F and G should be small. Therefore, X is within

||F||2 +||G||2 of the matrix of rank d obtained by setting these two blocks to zero. The
SVD is a special case of this decomposition in which F is zero and ¯R and G are diagonal,
but by allowing the more general case, we gain the ability to update the decomposition
inexpensively as new data arrives.
The rank-revealing QR decomposition of Section 5.4 is related to the rank-revealing
URV decomposition. In the QR case, we set V = I and ask that G be small, but we do not
restrict F.
CHALLENGE 8.8. (Extra)
Implement the URV updating algorithm, or use available software, and use it on the
matrix X to solve the DOA problem for rectangular windowing and exponential windowing.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 114 Page number 104
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 115 Page number 105
cyan magenta yellow black
Unit III
Optimization and Data Fitting
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 116 Page number 106
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 117 Page number 107
cyan magenta yellow black
107
For some problems we are interested in ﬁnding any solution, but in other cases we
want the best solution. “Best” can have many meanings, but we usually achieve it by
solving an optimization problem.
In this unit we focus on two types of optimization problems: unconstrained problems,
in which any point in Rn can be considered as a candidate (Chapter 9), and constrained
problems, in which candidate points must satisfy extra conditions (Chapter 10). We discuss
algorithms as well as the criteria that characterize a solution.
Chapter 11 considers a difﬁcult class of optimization problems, dividing a set of
data points into appropriate clusters. In Chapter 12, we solve perhaps the most common
optimization problem, the problem of ﬁtting a model to data using nonlinear least squares.
We investigate this further in Chapter 13, in which we introduce more efﬁcient algorithms
for the special case of solving separable least squares problems. In Chapters 14 and 15,
we ﬁt a model to spectroscopy data, assuming that all of the data in the model has some
uncertainty, ﬁrst using (total) least squares and then using minimization in other norms.
Constrained optimization is also used in Chapter 29.
BASICS: To understand this unit, the following background is helpful:
• Taylor series and the use of Lagrange multipliers for equality constraints in optimiza-
tion problems. This can be found in a standard calculus textbook.
• Methods for minimizing a function of a single variable, including Newton’s method
and some alternatives to it. This can be found in standard scientiﬁc computing text-
books such as [148].
• Methods for ﬁtting a function, such as a polynomial or a spline, to a set of data points.
Basic textbooks such as [32, 148] are good references.
MASTERY: After you have worked through this unit, you should be able to do the follow-
ing:
• Recognize a solution to an optimization problem (necessary and sufﬁcient condi-
tions).
• Compute a descent direction to reduce a function f (x) starting from a given point.
• Compute the Newton direction and test whether it is downhill.
• Deﬁne linear and superlinear rates of convergence. Deﬁne quadratic rate of conver-
gence and recognize that Newton’s method usually exhibits this.
• Explain why the Newton direction might need to be modiﬁed, and be able to de-
ﬁne and use the Levenberg–Marquardt method and explain the reasoning behind a
modiﬁed Cholesky strategy.
• Explain what a backtracking linesearch is, contrast it with an exact linesearch, and
explain why we use backtracking.
• Write a program that uses a trust region method (using the Euclidean norm) to solve
an optimization problem. Explain the relation between trust region methods and
Levenberg–Marquardt.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 118 Page number 108
cyan magenta yellow black
108
• State the secant condition and where it comes from. Verify that a given quasi-Newton
matrix update formula satisﬁes the secant condition, and test whether it satisﬁes the
no-change conditions.
• Give advantages and disadvantages of storing a quasi-Newton approximation to the
Hessian matrix H, to H−1, or to factors of H.
• Give the convergence rates, storage requirements, and number of f , g, and H evalu-
ations per iteration for the optimization methods studied.
• Write a program that uses a conjugate gradient method or a quasi-Newton method to
solve an optimization problem, using a given linesearch algorithm.
• Write a program for the truncated Newton method, given a program for the linear
conjugate gradient method.
• Explain what automatic differentiation is used for and what information you need to
provide to it.
• Explain the simplex-based algorithms for unconstrained optimization.
• Deﬁne a positive spanning set. Given a positive spanning set and a linesearch routine,
write a program that does pattern search.
• Give advantages and disadvantages of our methods for minimizing without deriva-
tives: automatic differentiation with our gradient-based methods, ﬁnite difference
methods, simplex algorithm, pattern search, and Monte Carlo minimization (Chap-
ter 17).
• Use Lagrange multipliers to determine the sensitivity of solutions to constrained op-
timization problems.
• Use a feasible direction method to solve an optimization problem with linear equality
constraints.
• Use QR to get a basis for the feasible directions.
• Program and use a barrier method or a penalty method to solve a constrained opti-
mization problem.
• Determine the dual problem and the central path for a linear programming, second-
order cone programming, or semideﬁnite programming problem.
• Use the k-means algorithm for clustering data.
• Minimize the root mean squared distance between points in two objects.
• Solve nonlinear least squares problems, and recognize separable ones.
• Solve total least squares and total least norm problems.

November 20, 2008 10:52
sccsbook
Sheet number 119 Page number 109
cyan magenta yellow black
x
f(x)
x1
x2
x4
x5
x* =x3
Chapter 9
Numerical Methods
for Unconstrained
Optimization
Our goal in this chapter is to develop efﬁcient algorithms to solve the following problem:
Unconstrained Optimization Problem:
Given a function f : S →R with S ⊆Rn, ﬁnd
xopt so that
f (xopt) = min
x∈S f (x).
The point xopt is called the minimizer, and the value f (xopt) is the minimum.
For unconstrained optimization, the set S is usually taken to be Rn, but sometimes
we make use of lower and upper bounds on the variables, restricting our search to a box
S = {x : ℓ≤x ≤u}
for some given vectors ℓ,u ∈Rn.
We begin in Section 9.1 by discussing the basics of how to recognize a solution
algebraically and geometrically. Then we present a template algorithm and consider in
Section 9.2 how to use Newton’s method in this framework. We discuss how close to
Newton’s method we must be to have rapid convergence. We discuss making methods safe
through the use of descent directions and linesearches or the use of trust regions. Finally,
in Section 9.5 we discuss the families of alternatives to Newton’s method.
9.1
Fundamentals for Unconstrained Optimization
In this section we address some basic issues in minimizing a function. First, we determine
how we can recognize a solution and the geometry that determines a solution.
109
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 120 Page number 110
cyan magenta yellow black
110
Chapter 9. Numerical Methods for Unconstrained Optimization
x
f(x)
local minimum
global minimum
x1
x2
x4
x5
x* =x3
Figure 9.1. Local and global minimizers. The function f (x) has ﬁve local mini-
mizers x1,...,x5. The point x2, for example, is a local minimizer because f (x2) is less than
or equal to the function values for all of the points in a neighborhood that includes the blue
line segment. The global minimizer is xopt = x3, since its function value is the lowest.
9.1.1
How Do We Recognize a Solution?
The point xopt is a local minimizer for our unconstrained optimization problem if there is
a δ > 0 so that if x ∈S and ∥x −xopt∥< δ, then f (xopt) ≤f (x). In other words, xopt is
at least as good as any point in its neighborhood. The point xopt is a global minimizer if
f (xopt) ≤f (x) for any x ∈S. Figure 9.1 illustrates these different types of solutions.
It would be nice if every local solution was guaranteed to be global. This is true
when f is convex, which means that for all points x and y in its domain and for all values
α between 0 and 1,
f (αx +(1 −α)y) ≤αf (x)+(1 −α) f (y).
(Geometrically, this means that the surface f (x) lies on or below any line connecting two
points on the surface.) The function in Figure 9.1 is convex on the interval marked with the
blue line, for example.
We assume throughout this chapter that f is smooth enough that it has as many
continuous derivatives as we need. For this section, that means two continuous derivatives
plus one more derivative, possibly discontinuous.

November 20, 2008 10:52
sccsbook
Sheet number 121 Page number 111
cyan magenta yellow black
9.1. Fundamentals for Unconstrained Optimization
111
x*
Unit vector in
steepest downhill
direction –g(x)
Downhill
directions
Unit vector in
gradient direction
g(x)
Unit vector in
Newton direction
H-1(x) g(x)
Figure 9.2. Given the gradient vector g(x) at some point x, the downhill directions
are those in the shaded region. The steepest downhill direction (red) is in the direction of
−g(x). The Newton direction is downhill if H(x) is positive deﬁnite.
POINTER 9.1. Some Hessian Matrices Are Easy.
Although the Hessian matrix has n2 elements, it is sometimes quite inexpensive to
compute. For example,
• If each component of the gradient depends on only a few of the variables, then each
row of the Hessian has only a few nonzero components. In this case we would exploit
the sparsity of the Hessian matrix by using special techniques to solve linear systems
of equations involving the matrix; see Chapters 27 and 28.
• Terms in f involving sines, cosines, or exponentials (as well as some other functions)
have second derivatives that reuse these values.
The gradient and Hessian of f help us to recognize local solutions. The gradient
of f at x is deﬁned to be the vector
g(x) = ∇f (x) =
⎡
⎢⎣
∂f (x)/∂x1
...
∂f (x)/∂xn
⎤
⎥⎦.
The Hessian of f at x is the derivative of the gradient:
H(x) = ∇2 f (x), with hij = ∂2 f (x)
∂xi ∂xj
,
i, j = 1,...,n.
Under our smoothness assumption, the Hessian is symmetric.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 122 Page number 112
cyan magenta yellow black
112
Chapter 9. Numerical Methods for Unconstrained Optimization
First-Order Necessary Condition for Optimality
Taylor series expansions, explained in calculus courses, give us our principal tool
for recognizing a solution. Suppose we have a point xopt, a small positive scalar h, and a
vector p ∈Rn with ∥p∥= 1. Then Taylor series tell us that
f (xopt +hp) = f (xopt)+hpT g(xopt)+ 1
2h2pT H(xopt)p+O(h3).
Now suppose that g(xopt) is nonzero. Then referring to Figure 9.2, we can always ﬁnd a
descent or downhill direction p so that
pT g(xopt) < 0.
Take, for example, p = −g(xopt)/∥g(xopt)∥. Using this direction with a small enough step-
size h, we can make 1
2h2pT H(xopt)p small enough that
f (xopt +hp) < f (xopt).
Therefore, a necessary condition for xopt to be a minimizer is that g(xopt) = 0. This is
called the ﬁrst-order optimality condition, since it depends on ﬁrst derivatives.
Second-Order Necessary Condition for Optimality
We now know that if xopt is a minimizer, then g(xopt) = 0, so
f (xopt +hp) = f (xopt)+ 1
2h2pT H(xopt)p+O(h3).
Now suppose that we have a direction p so that pT H(xopt)p < 0. (We call this a direction
of negative curvature.) Then again, for small enough h, we could make f (xopt + hp) <
f (xopt).
This leads us to the second-order condition for optimality: a necessary condition
for xopt to be a minimizer is that there be no direction of negative curvature. This is equiv-
alent to saying that the matrix H(xopt) must be positive semideﬁnite. In other words, all
of the eigenvalues of H(xopt) must be nonnegative.
Are these conditions sufﬁcient? Not quite. For example, consider
f (x) = x3,
where x ∈R1.
Then f ′(x) = 3x2 and f ′′(x) = 6x, so f ′(0) = 0 and f ′′(0) = 0, so x = 0 satisﬁes the ﬁrst-
and second-order necessary conditions for optimality, but it is not a minimizer of f .
We are very close to sufﬁciency, though: Recall that a symmetric matrix is positive
deﬁnite if all of its eigenvalues are positive. If g(x) = 0 and H(x) is positive deﬁnite, then
x is a local minimizer.
9.1.2
Geometric Conditions for Optimality
Imagine we are at point x on a mountain whose surface is described by the graph of the
function f (x). (So x ∈R2.) Now imagine that it is foggy, so that we cannot see very far in
front of us.

November 20, 2008 10:52
sccsbook
Sheet number 123 Page number 113
cyan magenta yellow black
9.1. Fundamentals for Unconstrained Optimization
113
The direction g(x) is the direction of steepest ascent. So if we want to climb the
mountain, it is the best direction to walk. Similarly, the direction −g(x) is the direction of
steepest descent, the fastest way down.
Further, any direction p that makes a positive inner product with the gradient is an
uphill direction, and any direction that makes a negative inner product is downhill.
If we are standing at a point where the gradient is zero, then there is no ascent di-
rection and no descent direction, but a direction of positive curvature leads us to a point
where we can go uphill, and a direction of negative curvature leads us to a point where
we can descend.
If there is no descent direction and no direction of negative curvature, then we are at
the bottom of a valley, a point that (locally) has minimum altitude.
9.1.3
The Basic Minimization Algorithm
Our basic strategy for ﬁnding a local minimizer of a function is inspired by the foggy
mountain and is given in Algorithm 9.1. Initially, we study algorithms for which the step-
size αk = 1. We sometimes omit the indices k on x, p, and α, and the argument x for H and
g, for brevity.
Algorithm 9.1 Basic Minimization Algorithm
Take an initial guess x(0) for the solution.
Set k = 0.
while x(k) is not a good enough solution,
Find a search direction p(k).
Set x(k+1) = x(k) + αkp(k), where αk is a scalar chosen to guarantee that progress is
made.
Set k = k +1.
end
There are several “details” that we need to resolve to make our algorithm practical:
testing for convergence, ﬁnding a search direction, and computing the stepsize αk.
The test for determining that x(k) is good enough depends on precisely what we are
looking for. It is really a matter of forward and backward error analysis, discussed in
Section 1.6, and in the following discussion we assume that all arithmetic is exact. If we
are most concerned about ﬁnding a point for which f is close to its (local) minimum, then,
using the Taylor series expansion
f (xopt)≈f (x(k))+(xopt −x(k))T g(x(k)),
we stop when ∥g(x(k))∥is small enough, since that forces f (x(k)) ≈f (xopt) unless ∥xopt −
x(k)∥is very large. This is a backward error bound approach. Estimating the distance from
x(k) to a local minimizer xopt gives the forward error bound, and this is more difﬁcult.
Some programs stop when αkp(k) is small, but really this just means that our algorithm
is not making much progress. Instead we might try to estimate the distance to the true
solution. Again, by Taylor series,
0 = g(xopt)≈g(x(k))+H(x(k))(xopt −x(k)),
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 124 Page number 114
cyan magenta yellow black
114
Chapter 9. Numerical Methods for Unconstrained Optimization
p
f(x+p)
Quadratic model
Original function
Figure 9.3. Newton’s method ﬁts a quadratic model q(p) (blue curve) to the
function f (x + p) (black curve) so that q(p) matches F in function value and ﬁrst two
derivatives at p = 0. The minimizer of the quadratic model (star) is close to the minimizer
of f but not identical.
so
∥H(x(k))−1g(x(k))∥≈∥xopt −x(k)∥,
(9.1)
and therefore we can expect that ∥x(k) −xopt∥is less than ∥g(x(k))∥/σmin, where σmin
denotes the smallest singular value of H(x(k)). We will see in the next section that the
vector H(x(k))−1g(x(k)) is computed in Newton’s method, so in that case we can evaluate
the left-hand side of (9.1) directly.
We consider methods for ﬁnding a search direction and determining the stepsize in
the next section.
9.2
The Model Method: Newton
Newton’s method is one way to determine the search direction p(k). It is inspired by our
Taylor series expansion
f (x+p)≈f (x)+pT g(x)+ 1
2pT H(x)p ≡q(p).
(9.2)
Suppose we replace f (x+p) by the quadratic model q(p) and minimize that, as illustrated
in Figure 9.3. In general, the model won’t ﬁt f well at all—except in a neighborhood of
the point x for which it is built. But if our step p is not too big, that is all right! So let’s try
to minimize q with respect to p. If we set the derivative of q equal to zero we obtain the

November 20, 2008 10:52
sccsbook
Sheet number 125 Page number 115
cyan magenta yellow black
9.2.
The Model Method: Newton
115
equation
g(x)+H(x)p = 0.
We see that we need the vector p deﬁned by
H(x)p = −g(x).
(9.3)
This vector is called the Newton direction, and it is obtained by solving the linear system
involving the Hessian matrix and the negative gradient.
The next three challenges give us some practice with Newton’s method.
CHALLENGE 9.1.
Apply one step of Newton’s method (with stepsize αk = 1) to the problem
min
x x4
1 + x2(x2 −1),
starting at the point x1 = 2, x2 = −1.
CHALLENGE 9.2.
Let f (x) = ex1+x2x1 + x2
2 and consider the point x1 = 1, x2 = 0.3863. Compute the
Newton direction and determine whether it is downhill.
Helpful fact: e1.3863 = 4.0000.
CHALLENGE 9.3.
Write a MATLAB program to apply 5 iterations of Newton’s method to the problem
min
x (x1 −5)4 +(x2 +1)4 −x1x2
with a stepsize of αk = 1 and with an initial starting guess of x = [1,2]T.
Note that if the Hessian H(x) is positive deﬁnite, then the linear system deﬁning p is
guaranteed to have a unique solution (since H(x) is therefore nonsingular) and, in addition,
0 < pT H(x)p = −pT g(x),
so in this case p is a downhill direction. In fact, p is the minimizer of the quadratic model
q(p).
If H(x) fails to be positive deﬁnite, then the situation is not as nice. If the matrix H(x)
has a negative eigenvalue, we may walk uphill. Even worse, if the matrix H(x) is singular
and if g(x) does not lie in its range, we have no solution to the linear system, so the search
direction is not deﬁned.
We can also get into trouble if H(x) is close to singular, since in that case it is difﬁcult
to get a good solution to the linear system using ﬂoating-point arithmetic, so the computed
direction may be almost orthogonal to g(x).
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 126 Page number 116
cyan magenta yellow black
116
Chapter 9. Numerical Methods for Unconstrained Optimization
POINTER 9.2. Matrix Inverses.
To ﬁnd the Newton direction or an approximation to it, we solve a linear system of
equations. Recall from Chapter 5 that although the solution to the linear system H(x)p =
−g(x) is deﬁned mathematically by p = −[H(x)]−1g(x), computing the matrix inverse is
generally more expensive and less accurate than using a matrix decomposition to solve the
system.
So to run the basic Newton method safely, we need the Hessian H(x) to be sufﬁciently
positive deﬁnite everywhere we need to evaluate it. Later, in Section 9.2.2, we’ll study ﬁxes
for the cases in which this condition fails to hold, but for now, we’ll just study the basic
Newton algorithm, in which we step from x to x−H(x)−1g(x).
9.2.1
How Well Does Newton’s Method Work?
When it is good, it is very, very good! For example, if we let e(k) = x(k) −xopt be the error
at iteration k and assume that
• H(x) is Lipschitz continuous, so that there is a positive scalar λ such that
∥H(x)−H(y)∥≤λ∥x −y∥
for all points x,y in a neighborhood of xopt,
• x(0) is sufﬁciently close to xopt,
• H(xopt) is positive deﬁnite,
then [50, p. 46] there exists a constant c such that
∥e(k+1)∥≤c∥e(k)∥2,
k = 0,1,....
This rate of convergence is called quadratic convergence, and it is remarkably fast.
If, for example, c = 1 and we have an error of 10−1 at some iteration, then two iterations
later the error is at most 10−4. After four iterations it is at most 10−16, as many ﬁgures as
we carry in double precision arithmetic!
Newton’s quadratic rate of convergence is nice, but Newton’s method is not an ideal
method:
• It requires the computation of H(x) at each iteration.
• It requires the solution of a linear system involving H(x).
• It can fail if H(x) fails to be positive deﬁnite.
• The convergence result only applies when we start “close enough” to the solution,
and Newton’s method may misbehave badly enough that we never get that close.

November 20, 2008 10:52
sccsbook
Sheet number 127 Page number 117
cyan magenta yellow black
9.2.
The Model Method: Newton
117
So we would like to modify Newton’s method to make it cheaper and more widely
applicable without sacriﬁcing its fast convergence. A quadratic convergence rate is great,
but we can settle for a superlinear convergence rate. We say that a sequence of errors e(k)
converges to zero with rate r and rate constant c < ∞if
lim
k→∞
∥e(k+1)∥
∥e(k)∥r = c.
(If r = 2, then this is a quadratic rate of convergence. If r = 1, then we need c < 1.)
The important point is that we can get a superlinear convergence rate (convergence
with rate 1 < r < 2) without walking exactly in the Newton direction. In fact, for the
same class of functions included in the convergence theorem above, we obtain superlinear
convergence if and only if [111, p. 304]
lim
k→∞
∥p(k)+H(x(k))−1g(x(k))∥
∥p(k)∥
= 0.
This means that if we choose a vector p(k) that is a good approximation to the solution to
the Newton equation (9.3), we can still achieve fast convergence. Therefore, we are free
to safeguard Newton’s method, or to substitute an approximate Newton direction, and still
expect good results. This leads us to methods such as quasi-Newton methods (Section 9.5)
and those in the next section.
9.2.2
Making Newton’s Method Safe: Modiﬁed Newton Methods
We want to modify Newton’s method whenever we are not sure that the direction it gen-
erates is downhill. If the Hessian is positive deﬁnite, we know the direction is downhill,
although if H ≡H(x) is nearly singular, we may have some computational difﬁculties.
If the Hessian is semideﬁnite or indeﬁnite, we might or might not get a downhill
direction. So our strategy is as follows:
• We’ll use the Hessian matrix whenever it is positive deﬁnite and not close to singular,
because it leads to quadratic convergence.
• We’ll choose a matrix E and replace H by H = H+E whenever H is close to singular
or fails to be positive deﬁnite.
We want H to satisfy the following conditions:
• H is symmetric positive deﬁnite.
• H is not too close to singular; speciﬁcally, its condition number should be moderate
in size, so that the smallest eigenvalue is not too close to zero, relative to its largest
eigenvalue.
We consider two ways to modify H to satisfy these conditions: the Levenberg–Marquardt
method and a modiﬁed Cholesky strategy.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 128 Page number 118
cyan magenta yellow black
118
Chapter 9. Numerical Methods for Unconstrained Optimization
The Levenberg–Marquardt Method
This strategy was actually proposed for least squares problems, but it works here, too. We
choose E = γ I for a ﬁxed scalar γ and replace H with
H = H+γ I.
This shifts every eigenvalue up by γ . The parameter γ is usually chosen by trial and error:
seek a γ so that H is positive deﬁnite and ∥p(k)∥≤h(k), where {h(k)} is a given sequence
of numbers. The Gerschgorin circle theorem (see Pointer 5.4) can be used to choose γ to
ensure that H is positive deﬁnite; alternatively, we can choose a γ that makes pT g/(∥p∥∥g∥)
small enough. If h(k) is small enough, then we indeed take a downhill step for α = 1, so we
can avoid the expense of a linesearch to ﬁnd a suitable stepsize α.
Modiﬁed Cholesky Strategy
If H is positive deﬁnite, then it has a Cholesky decomposition
H = LDLT .
(See Section 5.2.) But if H has zero or negative eigenvalues, then this factorization may fail.
The idea behind the modiﬁed Cholesky class of algorithms is to diagnose and ﬁx the failure
when it occurs, thus generating a correction matrix E added to H. We choose to make E
diagonal. While factoring, if our pivot element dii ≤0 (or, more practically, if dii ≤δ for
some small parameter δ), we increase dii so that it is sufﬁciently large. This changes the
factored matrix from H to H. If modiﬁcation is needed, we try to keep ∥H−H∥small so
that we have an almost-Newton direction.
Our resulting modiﬁed Newton Algorithm is built upon the Basic Minimization Al-
gorithm, Algorithm 9.1. We ﬁnd a search direction p(k) as indicated in Algorithm 9.2.
Algorithm 9.2 Modiﬁed Cholesky Strategy for Finding a Search Direction p
Given x and a small parameter ϵ.
Calculate g(x) and H = H(x).
Factor H+E = LDLT using a modiﬁed Cholesky strategy.
if ∥g(x)∥≤ϵ and E = 0 then
Halt with an approximate solution.
else
if ∥g(x)∥> ϵ then
Solve LDLT p = −g(x) to get a downhill direction.
else
Get a direction of negative curvature. (Comment: The details of this are different
for each algorithm to modify L, but the cost is O(n2).)
end
end
The main remaining issue for our algorithm is determining how long a step to take in
the direction p(k), and we consider two alternatives in the next two sections.

November 20, 2008 10:52
sccsbook
Sheet number 129 Page number 119
cyan magenta yellow black
9.3. Descent Directions and Backtracking Linesearches
119
9.3
Descent Directions and Backtracking Linesearches
If we have a descent direction p(k), then we know by Taylor series that a small enough step
in this direction decreases f . But in order to make fast progress, we want to take large
steps—in fact, the quadratic convergence rate of Newton’s method depends on taking steps
of size αk = 1. How do we choose αk to make good progress but guarantee that f does not
increase?
One way is to use a backtracking linesearch. We try a stepsize of 1. If we are not
satisﬁed with that step, then we try successively smaller ones: perhaps 1,1/2,1/4,..., until
success. There are better ways to choose the sequence of stepsizes, though. Let
F(α) = f (x+αp),
so that
F′(α) = pT g(x+αp).
Then if the stepsize α = 1 fails, we have values F(0), F′(0), and F(1). This information
allows us to build a model of F using quadratic interpolation, and we can use the minimizer
of the quadratic to predict the minimizer of F, as in Figure 9.4. If the trial is unsuccessful,
we can use the resulting function value to update the interpolant. So we have Algorithm 9.3,
backtracking linesearch. This algorithm does not depend on p being the Newton direction,
but if it is not, then we may need an initial bracketing phase that ﬁnds a good upper bound
on α by testing successively larger values.
Algorithm 9.3 Backtracking Linesearch
Choose α = 1 (to give the full Newton step).
while α is not good enough,
Use recently obtained function values and derivatives of F to ﬁnd a simple function
that interpolates these values.
Let the new αnew ∈[0,α] be the minimizer of the simple function and set α = αnew.
end
So far our situation is as follows:
• We have a downhill direction p, so we know that for very small α, F(α) < F(0).
• If p is the Newton direction, then we predict that α = 1 is the minimizer.
• We really can’t perform an exact linesearch, one that determines the value of α that
exactly minimizes f (x + αp). We can do this for quadratic functions, since in that
case a formula for α can be derived, but in general, exact linesearch is impossible
and is only interesting because a lot of theorems demand it.
How do we decide that a candidate α in Algorithm 9.3 is good enough? Various conditions
have been proposed. Two commonly used ones are the Goldstein–Armijo condition and
the Wolfe(1968)–Powell(1976) condition. The Wolfe–Powell condition demands that
|pT g(x+αp)| ≤η|pT g(x)|,
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 130 Page number 120
cyan magenta yellow black
120
Chapter 9. Numerical Methods for Unconstrained Optimization
b
 r 
 1
α
F
q0
q1
Figure 9.4. Backtracking linesearch. We ﬁrst try a value α = 1 but ﬁnd in this
example that the function value is too high. Then we ﬁnd the minimizer α0 = r of the (red)
quadratic polynomial q0 that matches the data we have gathered: F(0), F′(0), and F(1).
(F′(0) is the slope of the dotted line.) Since the function value F(α0) is still too high, we
ﬁnd the minimizer α1 = b of the (blue dashed) polynomial q1 that matches the most recent
data: F(0), F(1), and F(α0). The function value F(α1) is less than F(0), so we might
accept it and terminate the linesearch.
where η is a ﬁxed constant in the interval [0,1). The parameter η controls how close we
need to be to the exact linesearch, since g(x+αp) = 0 if the search is exact. The Goldstein–
Armijo condition is similar but does not involve gradient evaluation:
f (x+αp) ≤f (x)+ηαpT g(x).
Taking η = 1 in this condition says that the decrease in f should be at least as big as that
predicted from Taylor series, and taking η close to zero requires only a small decrease in
f .
Such conditions are built into good linesearch algorithms. It can be shown that points
acceptable under these conditions exist as long as the minimizer is ﬁnite, and when using
them we are assured of success. In particular, suppose we use these conditions in our
linesearch to minimize a function f for which
• f is continuously differentiable and bounded below,
• g is Lipschitz continuous, so that there exists a constant L such that, for all x and y,
∥g(x)−g(y)∥≤L∥x −y∥.

November 20, 2008 10:52
sccsbook
Sheet number 131 Page number 121
cyan magenta yellow black
9.4. Trust Regions
121
Also suppose that the directions p(k) are downhill and bounded away from orthogonality to
g(k):
g(k)T p(k) ≤−δ∥g(k)∥∥p(k)∥,
k = 0,1,...,
for some ﬁxed δ > 0. Then either g(k) = 0 for some k or g(k) →0 [50].
9.4
Trust Regions
Trust regions are a popular alternative to linesearches. In these methods, we choose p and
α simultaneously. The idea is again based on the quadratic model (9.2):
f (x+p)≈q(p) = f (x)+pT g+ 1
2pT Hp.
But we should only trust the model when ∥p∥< h for some small scalar h. So we step to
the point xnew = x+popt, where popt solves
min
∥p∥≤h q(p).
(9.4)
If the solution popt satisﬁes ∥popt∥< h, then solving (9.4) yields a step of size α = 1 in the
Newton direction, but it gives a different direction otherwise.
The shape of the trust region {p : ∥p∥≤h} depends on the norm we choose, and so
does the algorithm for computing popt. If we choose the inﬁnity norm, for example, then
our problem becomes
min
|pi|≤hq(p).
This is a quadratic programming problem with bound constraints. If we instead use the
2-norm, we show in the next challenge that the problem is closely related to an algorithm
we have seen before.
CHALLENGE 9.4.
Show, using a Lagrange multiplier, that if we deﬁne the region by ∥p∥2 = h, then the
solution corresponds to the direction in the Levenberg–Marquardt algorithm.
Hint: Write the constraint as (1/2)(pT p −h2) = 0.
In order to use the trust region method we need to decide how to determine h, how to
adapt h as x(k) gets closer to the solution, and how to solve the minimization problem for
popt. The parameter h determines the size of the region in which our model q is known to
be a good approximation to f ; for ˆhp in this region, we expect that
r ≡f (x+ ˆhp)−f (x)
q( ˆhp)−q(0)
≈1.
Therefore, often a heuristic rule is used for modifying h based on the solution to (9.4): For
example,
• If r is too small (< 1/4), then reduce h by a factor of 4 and reject the step.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 132 Page number 122
cyan magenta yellow black
122
Chapter 9. Numerical Methods for Unconstrained Optimization
POINTER 9.3. Automatic Differentiation.
Automatic differentiation programs take a function f written in MATLAB or some
other high-level language and produce a function that evaluates the derivatives of f. Auto-
matic differentiation is an old idea.
• A forward (bottom-up) algorithm was proposed in the 1970s. To evaluate the gra-
dient of a function f , this method requires O(n) space and O(n) times the time
required for the evaluation of f .
• A backward (top-down) algorithm was proposed in the 1980s. To evaluate the gra-
dient, this method can take O(n2) space but only requires 2 times the amount of time
needed for evaluating f .
• Reliable software was ﬁrst developed in the 1990s, and one package is found in [27].
• If r is large (> 3/4), then increase h by a factor of 2.
There is a pitfall in using trust region methods: if the problem is poorly scaled, then
the trust region may remain very small and we may never be able to take large steps. For
example, the function
f (x) = f1(x1)+ f1(10000x2),
where f1 is a well-behaved function, is poorly scaled.
A trust region is a good substitute for a linesearch in that it, too, ensures success of
our optimization algorithm: If [50, Thm. 5.1.1]
• the set S0 = {x : f (x) ≤f (x(0))} is bounded,
• f has two continuous derivatives on S0,
then the sequence {x(k)} has an accumulation point xopt that satisﬁes the ﬁrst- and second-
order necessary conditions for optimality.
9.5
Alternatives to Newton’s Method
We now know how to recognize a solution and compute a solution using Newton’s method.
We have included safeguards in case the Hessian fails to be positive deﬁnite, and we have
considered a linesearch or trust region to guarantee convergence. The resulting algorithm
converges rather rapidly, but each iteration is quite expensive.
The most tedious and error-prone part of nonlinear optimization is writing functions
that compute derivatives. An alternative is to let the computer do it, as discussed in Pointer
9.3. If that is not practical, then we use methods that require fewer derivatives. Often these
algorithms have lower cost per iteration.

November 20, 2008 10:52
sccsbook
Sheet number 133 Page number 123
cyan magenta yellow black
9.5. Alternatives to Newton’s Method
123
9.5.1
Methods that Require Only First Derivatives
Suppose we want to solve our problem
min
x
f (x)
when g(x), but not H(x), can be computed.
One strategy is to construct a matrix B to approximate the Hessian matrix H; alter-
natively, sometimes it is convenient to construct a matrix C to approximate H−1. We’ll
discuss two options:
• Approximate H(x) or H(x)−1 using quasi-Newton methods (also called variable
metric methods).
• Estimate H(x) using ﬁnite differences, resulting in discrete Newton methods.
Note, though, that checking optimality is somewhat more problematic once H(x) is no
longer available.
First Derivative Method 1: Quasi-Newton Methods
Recall that the Newton step is deﬁned by
p = −[H(x)]−1g(x).
We deﬁne the quasi-Newton step as
p = −[B(k)]−1g(x),
where
B(k) ≈H(x(k))
and B is accumulated using free information! What information comes free? At step k, we
know g(x(k)) and we compute g(k+1) ≡g(x(k+1)), where x(k+1) = x(k) + s(k). From Taylor
series we know that
g(x+hs) = g(x)+hH(x)s+O(h2),
so the matrix H(x(k)) satisﬁes
H(k)s(k) = lim
h→0
g(x(k) +hs(k))−g(x(k))
h
.
In fact, if f is quadratic, then
H(k)s(k) = g(x(k) +s(k))−g(x(k)).
We’ll ask the same property of our approximation B(k+1) and call this the secant condition:
B(k+1)s(k) = g(k+1) −g(k) .
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 134 Page number 124
cyan magenta yellow black
124
Chapter 9. Numerical Methods for Unconstrained Optimization
CHALLENGE 9.5.
Why do we demand that quasi-Newton matrices B(k) satisfy the secant condition?
Since we know how we want B(k+1) to behave in the direction s(k), and we have no
new information in any other direction, we could require
B(k+1)v = B(k)v
if vT s(k) = 0.
There is a unique matrix B(k+1) that satisﬁes the secant condition and these no-change
conditions. It is computed by Broyden’s good method:
B(k+1) = B(k) −(B(k)s(k) −y(k)) s(k)T
s(k)T s(k) ,
where
s(k) = x(k+1) −x(k) ,
y(k) = g(k+1) −g(k) .
CHALLENGE 9.6.
Verify that Broyden’s good method satisﬁes the secant condition and the no-change
conditions.
For Broyden’s good method, B(k+1) is formed from B(k) by adding a rank-1 matrix,
but the matrix is not necessarily symmetric, even if B(k) is. This is undesirable since we
know H is symmetric.
In order to regain symmetry, we need to sacriﬁce the no-change conditions. Instead,
we formulate the problem in a least change sense:
min
B(k+1) ∥B(k+1) −B(k)∥
subject to a symmetry condition and the secant condition B(k+1)s(k) = y(k). The solution
depends on the choice of norm.
We can impose other constraints, too. Frequently, algorithms demand that B(k+1)
be positive deﬁnite. If we have extra information about the structure of the Hessian (for
example, knowing that H is sparse), then we might want B to have the same structure.
An alphabet soup of quasi-Newton algorithms have been proposed. The oldest is the
DFP method (Davidon 1959, Fletcher–Powell 1963). In this method we accumulate an
approximation C to H−1 as
C(k+1) = C(k) −C(k)y(k)y(k)T C(k)
y(k)T C(k)y(k)
+ s(k)s(k)T
y(k)T s(k) .

November 20, 2008 10:52
sccsbook
Sheet number 135 Page number 125
cyan magenta yellow black
9.5. Alternatives to Newton’s Method
125
DFP is one of the most popular quasi-Newton methods because it has many desirable prop-
erties. But the BFGS method (Broyden, Fletcher, Goldfarb, Shanno 1970) deﬁned by
B(k+1) = B(k) −B(k)s(k)s(k)T B(k)
s(k)T B(k)s(k)
+ y(k)y(k)T
y(k)T s(k)
(9.5)
is the most successful method.
CHALLENGE 9.7.
Verify that the BFGS matrix satisﬁes the secant condition.
Algorithm 9.4 Quasi-Newton Algorithm
Initialize x(0) and C(0) (or B(0)).
Set k = 0.
while x(k) is not a good enough solution,
Compute a search direction p(k) from p(k) = −C(k)g(x(k)) (or solve B(k)p(k) =
−g(x(k))).
Set x(k+1) = x(k) + αkp(k), where αk satisﬁes the Goldstein–Armijo or Wolfe–Powell
linesearch conditions.
Form the updated matrix C(k+1) (or B(k+1)).
Set k = k +1.
end
The quasi-Newton algorithm, Algorithm 9.4, looks very similar to Newton’s method,
but now we need to initialize B(0) (or C(0)) as well as x(0). We take B(0) = I, or a multiple
of I, or some better guess.
Quasi-Newton methods generally have an n-, 2n-, or (n + 2)-step quadratic conver-
gence rate if the linesearch is exact. An n-step quadratic convergence rate, for example,
means that there is a constant c < ∞such that
lim
k→∞
∥x(k+n) −xopt∥
∥x(k) −xopt∥2 = c.
Weakening the linesearch to a Wolfe–Powell or Goldstein–Armijo search generally gives
superlinear convergence; see [111, p. 356] for a typical result.
Some implementation issues remain:
• Near a stationary point, H−1 does not exist. How do we keep C from deteriorating?
• What happens if H is indeﬁnite?
These questions concern stability of the algorithm. We are faced with a dilemma in trying
to balance stability and efﬁciency:
• Updating C can be hazardous when H is close to singular.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 136 Page number 126
cyan magenta yellow black
126
Chapter 9. Numerical Methods for Unconstrained Optimization
• Updating B leaves the problem of solving a linear system at each iteration to deter-
mine the search direction.
The resolution comes by using an appropriate matrix decomposition. Note that (9.5) shows
that the BFGS matrix B is changed by a rank-2 update at each iteration. The most sta-
ble way to implement the algorithm is to update a Cholesky decomposition of B.
If
we have a Cholesky decomposition of B(k) as B(k) = L(k)D(k)L(k)T , then we can obtain
B(k+1) = L(k+1)D(k+1)L(k+1)T , using techniques similar to those used in updating the QR
decomposition in the case study of Chapter 7. This makes it easy to enforce symmetry
and positive deﬁniteness. The algorithms are O(n2), and details are given by Gill, Golub,
Murray, and Saunders [58] and in some textbooks.
First Derivative Method 2: Finite Difference Newton Method
Evaluation of the matrix H(x) can be a major time sink in using Newton’s method. One
way to avoid evaluations of the entries
hij = ∂gi(x)
∂xj
is to use Taylor series to approximate them by
hij ≈gi(x+τej)−gi(x)
τ
,i, j,...,n,
where τ is a small number and ej is the jth column of the identity matrix. We see, using
Taylor series, that this approximation is accurate to O(τ). The cost is n extra gradient
evaluations per iteration. Sometimes this is less than the cost of the Hessian evaluation, but
sometimes it is more. The choice of τ is critical to the success of the method:
• If τ is large, the approximation is poor and we have large truncation error.
• If τ is small, then there is cancellation error in forming the numerator of the approx-
imation, so we have large rounding error.
Usually we try to balance the two errors by choosing τ to make them approximately equal.
If the problem is poorly scaled, we may need a different τ for each j. There are theorems
that say that if we choose τ carefully enough, we can get superlinear convergence.
If you are considering using the ﬁnite difference Newton method, also consider the
truncated Newton method of the next section, since it often gives comparable results at less
cost.
9.5.2
Low-Storage First-Derivative Methods
Sometimes problems are too big to allow n2 storage space for the Hessian matrix, so we
consider three methods that avoid storage of a matrix:
• steepest descent,
• nonlinear conjugate gradient,
• truncated Newton.

November 20, 2008 10:52
sccsbook
Sheet number 137 Page number 127
cyan magenta yellow black
9.5. Alternatives to Newton’s Method
127
Low-Storage Method 1: Steepest Descent
Let’s return to that foggy mountain. If we repeatedly walk in the direction of steepest de-
scent until we stop going downhill, we clearly are guaranteed to get to a local minimizer.
The trouble is that the algorithm is terribly slow. For example, if we apply steepest descent
to a quadratic function of n variables, then after many steps, the algorithm alternates be-
tween just two directions: those corresponding to the eigenvectors of the smallest and the
largest eigenvalues of the Hessian matrix. In this case the convergence rate is only linear:
f (x(k+1))−f (xopt) ≤
κ −1
κ +1
2
( f (x(k))−f (xopt)),
(9.6)
where κ, the condition number, is the ratio of the largest to the smallest eigenvalue of H.
See [111, p. 342] for proof. If steepest descent is applied to non-quadratic functions, using
a good linesearch, then convergence is local and linear.
Instead of this method, consider using nonlinear conjugate gradients. It has the
same advantages as steepest descent, requires only a few more vectors of storage, and
gives a better convergence rate.
Low-Storage Method 2: Nonlinear Conjugate Gradient Methods
The (linear) conjugate gradient method [76] is a method for solving linear systems of equa-
tions Ax = b when A is symmetric and positive deﬁnite. There are many ways to understand
it, but here we can think of it as minimizing the function
ˆf (x) = 1
2xT Ax−xT b,
which has gradientg(x) = Ax−b. So, by the ﬁrst-order optimality conditions, a minimizer
of ˆf is a solution to the linear system Ax = b. We could use steepest descent, but we
want something faster. The conjugate gradient method combines the concepts of descent
and conjugate directions in order to improve on steepest descent. See Section 28.2 for a
description of the algorithm. The nonlinear conjugate gradient algorithm, a generalization
of this algorithm for minimizing arbitrary functions f (x), is shown in Algorithm 9.5.
Algorithm 9.5 Nonlinear Conjugate Gradient Algorithm
Given x(0), form p(0) = −g(x(0)). Set k = 0.
while x(k) is not a good enough solution,
Use a linesearch to determine a parameter αk and then set x(k+1) = x(k) +αkp(k).
Set p(k+1) = −g(x(k+1))+βk+1p(k), where βk+1 is a scalar parameter.
Set k = k +1.
end
If f is quadratic, then there is a formula for αk.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 138 Page number 128
cyan magenta yellow black
128
Chapter 9. Numerical Methods for Unconstrained Optimization
CHALLENGE 9.8.
Let f (x) = 1
2xT Hx −xT b, where H and b are constant, independent of x, and H is
symmetric positive deﬁnite. Given vectors x(0) and p(0), ﬁnd the value of the scalar α that
minimizes f (x(0) + αp(0)). This is the formula for the stepsize αk in the linear conjugate
gradient algorithm.
The parameter βk+1 has many deﬁnitions that are equivalent for quadratic functions
but different when we minimize more general nonlinear functions:
βk+1 = g(x(k+1))T g(x(k+1))
g(x(k))T g(x(k))
Fletcher–Reeves,
βk+1
= y(k)T g(x(k+1))
g(x(k))T g(x(k))
Polak–Ribière,
βk+1
= y(k)T g(x(k+1))
y(k)T p(k)
Hestenes–Stiefel.
Good theorems have been proven about convergence of Fletcher-Reeves, but Polak-Ribière
generally performs better.
Note that this method stores no matrix. We only need to remember a few vectors at a
time, so it can be used for problems in which there are thousands or millions of variables.
The convergence rate is linear, unless the function has special properties, but gener-
ally faster than steepest descent: for quadratics, the rate is
f (x(k+1))−f (xopt) ≤
√κ −1
√κ +1
2
( f (x(k))−f (xopt)),
where again κ is the condition number of H. Comparing this with the steepest descent
bound (9.6) we see that now κ appears with a square-root, which gives a smaller bound.
One important property of conjugate gradients is that if f is quadratic, then the con-
jugate gradient algorithm generates the same iterates as BFGS or DFP started from the
same initial point, with B(0) = I. Just as in the linear case, preconditioning can improve the
convergence rate of conjugate gradients; see Section 28.3.
Low-Storage Method 3: Truncated Newton Method (Newton-CG)
Again we return to the way the Hessian approximation is used. Newton’s method deter-
mines the search direction by solving the linear system
H(x)p = −g(x).
We usually think of solving this by factoring H(x) and then using forward and back substi-
tution. But if n is large, this might be too expensive, and we might choose to use an iterative
method, like linear conjugate gradients (see Section 28.2) to solve the linear system. If
we do, how do we use the Hessian? All we need to do is to multiply a vector by it at each
step of the algorithm.

November 20, 2008 10:52
sccsbook
Sheet number 139 Page number 129
cyan magenta yellow black
9.5. Alternatives to Newton’s Method
129
Now Taylor series tells us that, if v is a vector of length 1, then
g(x+hv) = g(x)+hH(x)v+O(h2),
so
H(x)v = g(x+hv)−g(x)
h
+O(h).
Therefore, we can get an O(h) approximation of the product of the Hessian with an
arbitrary vector by taking a ﬁnite difference approximation (the blue term in the equation
above) to the change in the gradient in that direction. This is akin to the ﬁnite difference
Newton method, but much neater, because we only evaluate the ﬁnite difference in direc-
tions in which we need it.
So we’ll compute an approximation to the Newton direction by solving the linear sys-
tem H(x)p = −g(x) using a few steps of the (linear) conjugate gradient method, computing
approximate matrix-vector products by extra evaluations of the gradient, and stopping the
conjugate gradient method early, before the exact solution is computed.
To obtain a superlinear convergence rate, the result at the end of Section 9.2.1 tells
us that we need our direction to converge to the Newton direction as k →∞. We ensure
this by
• taking enough iterations of conjugate gradient to get a small residual to the linear
system,
• choosing h in the approximation carefully, so that the matrix-vector products are
accurate enough.
To make sure we understand how this truncated Newton algorithm works, let’s im-
plement it.
CHALLENGE 9.9.
Suppose we are using the truncated Newton method to minimize a function f (x).
This means that we use Algorithm 9.1 with “Find a search direction” meaning “Solve the
equation H(x(k)) p = −g(x(k)) using the conjugate gradient method.” We evaluate f (x) and
g(x) by calling a function [f,g] = myfnct(x). Write a MATLAB function which
(approximately) computes the product H(x(k))v for any input vector v. Include enough
documentation so that a reader would know how to use your function.
9.5.3
Methods that Require No Derivatives
These are methods of last resort, generally used when
• derivatives are not available, or
• derivatives do not exist.
An example of the ﬁrst case is when function evaluation is performed by running a physical
experiment or a numerical simulation. This is an area of very active research currently and
all the methods we discuss are slow. We’ll consider three classes of methods here and one
more in the case study of Chapter 17.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 140 Page number 130
cyan magenta yellow black
130
Chapter 9. Numerical Methods for Unconstrained Optimization
f=10
f=1
f=2
1st: reflect this vertex.
2nd: reflect
this vertex.
3rd: shrink, since vertex 
cannot be reflected)
f=1/2
f=2
First simplex
Fourth simplex
Third simplex
Second simplex
Figure 9.5. A simplex-based method for function minimization
No-Derivative Method 1: Finite Difference Methods
We could compute an approximate gradient using ﬁnite differencing on the function. This is
not usually a good idea; for the same reason we rejected ﬁnite difference Newton methods,
it is better to either use automatic differentiation methods to compute the gradient (See
Pointer 9.3) or use pattern search methods to avoid the need for it.
No-Derivative Method 2: Simplex-Based Methods
The most popular of the simplex-based methods is the Nelder–Mead algorithm, and MAT-
LAB has an implementation of this.7 The idea behind simplex methods is to begin by eval-
uating the function at the vertices of a simplex. (In two dimensions, this is a triangle; in
three, it is a tetrahedron, etc.) See Figure 9.5 for an example. We move one vertex of this
simplex (usually the one with the largest function value), reﬂecting it around its current
position, until we have enclosed the minimizer in the simplex. Then we shrink the size of
the simplex to hone in on the minimizer.
Simplex-based algorithms have rather elaborate rules for determining when to reﬂect
and when to shrink, and no algorithm that behaves well in practice has a good convergence
proof. For that reason, it looks as if they will fade in popularity, being supplanted by
pattern search methods.
7The terminology is confusing; these simplex-based methods are distinct from the more widely used
simplex method for linear programming.

November 20, 2008 10:52
sccsbook
Sheet number 141 Page number 131
cyan magenta yellow black
9.6. Summary
131
Figure 9.6. Two positive spanning sets in two dimensions.
No-Derivative Method 3: Pattern Search Methods
Suppose we are given an initial guess x for the solution to the minimization problem, and
a set of at least n +1 directions vi, i = 1,..., N, that form a positive spanning set for Rn:
this means that any vector in Rn can be expressed as a linear combination of these vectors,
where the coefﬁcients in the combination are nonnegative numbers. See Figure 9.6 for two
examples of positive spanning sets in 2 dimensions.
At each step of a pattern search method, we do a linesearch in each of the directions
(or perhaps just use a ﬁxed stepsize) to obtain function values f (x+αivi), and we replace
x by the point with the smallest function value. We repeat this until convergence. This
is a remarkably simple algorithm, but works well in practice and is provably convergent!
Another desirable property is that it is easy to parallelize, and this is crucial to making a
no-derivative algorithm effective when n is large.
9.6
Summary
We summarize in Figure 9.7 the process of choosing an appropriate algorithm for an un-
constrained optimization problem. The next four challenges give us some experience with
such choices.
CHALLENGE 9.10.
Explain how you would decide whether to choose the Nelder–Meade algorithm, the
quasi-Newton algorithm, or the Newton algorithm for minimizing a function of many vari-
ables.
CHALLENGE 9.11.
You are asked to minimize a function of n = 2000 variables. Consider doing this by
Newton’s method, a quasi-Newton method, or pattern search. Give the main advantages
and disadvantages of each. Which would you choose? Why?
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 142 Page number 132
cyan magenta yellow black
132
Chapter 9. Numerical Methods for Unconstrained Optimization
Yes
Is f quadratic?
Are first and second
derivatives available,
with enough room
to store them?
Are first derivatives
explicitly available, or
available using
automatic differentiation?
Is f differentiable?
No
No
No
Use Cholesky factorization or conjugate gradients.
Use Newton’s method, with safeguards.
Use sparse Quasi-Newton,
truncated Newton, or
nonlinear conjugate
gradients.
Use (sparse) Quasi-Newton, truncated Newton,
or nonlinear conjugate gradients, with finite
difference approximation of the gradient.
Use pattern search.
No
Use Quasi-Newton or
truncated Newton.
Yes
Yes
Yes
Is there enough room to store a matrix?
Yes
No
Figure 9.7. Choosing an optimization algorithm. Note that derivatives might be
available explicitly, or through automatic differentiation. The special case when f is the
sum of squared terms is a nonlinear least squares problem, and algorithms are discussed
in the case study in Chapter 13.
CHALLENGE 9.12.
Suppose that you have developed a model that uses an ordinary differential equa-
tion (ODE) to predict the amount of proﬁt that you will receive on December 11 if you
invest $1000 today in various components of your business, and that proﬁt depends on 5
parameters x1,...,x5, so that
y′(t) = f (t, y,x),
y(0) = 0,
y(1) = proﬁt on December 11, using parameters x.
You want to choose those 5 parameters in x to maximize y(1) (which is a scalar value).
(Then you will take the money and run.)
What numerical algorithms would you use to solve your problem and how would they
pass information to each other? (Refer to Chapter 20 if you don’t know methods for the
numerical solution of ordinary differential equations.) Why did you choose these particular
algorithms?

November 20, 2008 10:52
sccsbook
Sheet number 143 Page number 133
cyan magenta yellow black
9.6. Summary
133
POINTER 9.4. Further Reading.
More information on unconstrained optimization algorithms can be found, for exam-
ple, in textbooks by Nash and Sofer [111, Chap. 2, Chap. 10] and by Fletcher [50].
There are many modiﬁed Cholesky strategies in the literature; see, for example, [47].
Conn and Gould [28] give more information on trust regions.
Quasi-Newton methods could be the basis for a full course; there is a textbook by
Dennis and Schnabel [40] and many other good references [22, 41].
Pattern search algorithms are discussed in [95].
CHALLENGE 9.13.
Fill in the following table, giving features of various algorithms for minimizing f (x).
The ﬁrst line has been completed, as an example.
Method
Convergence
Storage
f evals/itn
g evals/itn
H evals/itn
rate
Truncated
> 1
O(n)
0
≤n +1
0
Newton
Newton
Quasi-
Newton
Steepest
descent
Conjugate
gradients
• Assume that all of these methods are convergent and that any linesearch is exact (i.e.,
the true optimal value of the stepsize parameter is used).
• Don’t include the cost of the linesearch in the table entries. We are omitting this cost
because it is the same, independent of method.
• f is the function, g is the gradient, and H is the Hessian matrix. “evals/itn” means
the number of evaluations per iteration.
• The convergence rate should be “1” for linear, “> 1” for superlinear, or “2” for
quadratic.
• Storage should be either O(1), O(n), or O(n2), where n is the number of variables
(i.e., the dimension of x).
• “Conjugate gradients” means the nonlinear conjugate gradient method, not the one
for solving linear systems (minimizing quadratics).
Next we turn our attention to optimization problems with constraints.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 144 Page number 134
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 145 Page number 135
cyan magenta yellow black
Chapter 10
Numerical Methods
for Constrained
Optimization
We deﬁne the constrained optimization problem:
Constrained Optimization Problem: Given a function f : S →R, ﬁnd xopt so that
f (xopt) = min
x∈S f (x).
The set S is deﬁned to be those points x ∈Rn that satisfy the constraints
ci(x) = 0,
i = 1,...,me,
ci(x) ≥0,
i = me +1,...,m,
where ci : S →R,
i = 1,...,m.
Often it is best to convert the problem to an unconstrained problem or a system of
nonlinear equations, but sometimes it is best to treat the constraints explicitly, as in the
simplex algorithm for linear programming. We’ll concentrate in this chapter on the
conversion approach, after ﬁrst reviewing some fundamentals.
10.1
Fundamentals for Constrained Optimization
We assume that f and ci are real-valued functions with two continuous derivatives on S.
We say that xopt is a solution to our problem if
• xopt is feasible; i.e., xopt satisﬁes all of the constraints.
• xopt is locally optimal; i.e., for some ϵ > 0, if ∥x −xopt∥≤ϵ, and if x satisﬁes the
constraints, then f (xopt) ≤f (x).
135
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 146 Page number 136
cyan magenta yellow black
136
Chapter 10. Numerical Methods for Constrained Optimization
Note that unless both f and the feasible region are convex, local minimizers may exist and
there is no guarantee of ﬁnding the global solution. (A region is convex if the line between
any two points in the region lies entirely in the region.)
When solving any problem, it is important to be able to answer two questions:
• How do we recognize a solution?
• How sensitive is the solution to small changes in the data?
In this section we answer these questions for constrained optimization. First we derive the
answer for a simple special case, in which all of the constraints are linear. Then we state
the general results.
10.1.1
Optimality Conditions for Linear Constraints
For an unconstrained optimization problem, we measure the sensitivity of the function f (x)
to small changes in x through the gradient vector g(x), since if ∥hp∥is small, then
f (x+hp)≈f (x)+hpT g(x).
For constrained optimization, an equally interesting question is how sensitive the optimal
function value is to small changes in the constraints.
To investigate this, we introduce Lagrange multipliers, which you may have studied
in calculus. Suppose, to begin with a simple example, that the constraints are c(x) = Ax−
b = 0, where A has me linearly independent rows. Deﬁne the Lagrangian function (used
in Section 2.1) as
L(x,λ) = f (x)−λT c(x),
where λ is a vector containing the me Lagrange multipliers. The Lagrangian function has a
saddle point, a minimizer with respect to x and a maximizer with respect to λ, which is of
interest to us. To ﬁnd it, we set the partial derivatives of L to zero:
g(x)−AT λ = 0,
c(x) = 0.
(If you need to compute these derivatives component by component in order to be com-
fortable with these expressions, now is a good time to stop and do that exercise!) Note
that differentiating with respect to the Lagrange multipliers just gives the constraints back
again, while differentiating with respect to the original variables x gives the condition that
the gradient of f should be a linear combination of the columns of the matrix AT , which
are the constraint gradients.
Now suppose that at some point x satisfying the constraints Ax = b, the gradient of f
is not a linear combination of the constraint gradients but has some additional component
−p. Then g(x) has some component outside of the range of AT , and therefore (by a theorem
in linear algebra) that component is in the null space of A:
Ap = 0.
Since pT g(x) < 0, if we take a small enough step h in the direction p, we reduce the
minimization function
f (x+hp) < f (x)

November 20, 2008 10:52
sccsbook
Sheet number 147 Page number 137
cyan magenta yellow black
10.1. Fundamentals for Constrained Optimization
137
and still have a point that satisﬁes the constraints, since
c(x+hp) = A(x+hp)−b
= Ax−b+hAp
= Ax−b
= 0.
Therefore, we have derived the ﬁrst-order optimality conditions for a problem with linear
equality constraints: the gradient of f must be a linear combination of the gradients of the
constraints. Note that if there are no constraints, this condition forces the gradient to be
zero, which is exactly the ﬁrst-order optimality condition that we found for unconstrained
optimization in Section 9.1.1.
We see that the Lagrange multipliers are useful in determining optimality, but they
are not just an artiﬁcial tool. Suppose that we have a pointx satisfying
∥xopt −x∥≤ϵ,
where xopt satisﬁes the ﬁrst-order optimality conditions and ϵ is small. Compute the vector
δ so that
Ax = b+δ.
Then Taylor series expansion tells us
f (x) = f (xopt)+(x−xopt)T g(xopt)+O(ϵ2)
= f (xopt)+(x−xopt)T AT λopt+O(ϵ2)
= f (xopt)+δT λopt+O(ϵ2).
This gives us a valuable insight: if we wiggle bj by δj, then we wiggle f by δj(λopt)j.
Therefore, (λopt)j is the change in f per unit change in bj. Thus the jth Lagrange multiplier
tells us the sensitivity of f to a small change in the constraint data bj. For this reason, the
Lagrange multiplier λj is sometimes called a dual variable or a shadow price.
So far we have only considered equality constraints. Suppose we have an additional
linearly independent constraint aT x−b ≥0 and our current point ˜x is a linear combination
of the constraint gradients:
g(˜x)−AT λ−λme+1a = 0.
Can we conclude that ˜x is optimal? There are two cases to consider.
Case 1: Suppose that aT ˜x −b = 0, so that the constraint is active. We need to
remember that we are allowed to walk off the additional constraint if such a step reduces f .
If we do choose to move off this constraint, we must still satisfy the remaining (equality)
constraints, so we would need to ﬁnd a vector p so that Ap = 0 and aT p > 0. Suppose
that we ﬁnd such a vector. Then if the Lagrange multiplier for the inequality constraint is
negative,
pT g(˜x) = pT AT λ+λme+1pT a
= λme+1pT a
< 0
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 148 Page number 138
cyan magenta yellow black
138
Chapter 10. Numerical Methods for Constrained Optimization
and p is a descent direction that maintains feasibility. Therefore, for optimality, it is neces-
sary that the Lagrange multiplier for the inequality constraint be nonnegative.
Case 2: Suppose that aT ˜x −b > 0 so that the constraint is not currently active. For
optimality, the Lagrange multiplier λme+1 must be zero, since we would obtain the same
solution by solving the problem without that constraint.
So for a single linear inequality constraint, at an optimal point the Lagrange multiplier
must be zero if the constraint is not active and nonnegative if the constraint is active. A
similar result holds in general, and next we state these optimality conditions.
10.1.2
Optimality Conditions for the General Case
We now have an intuitive understanding of Lagrange multipliers for linear constraints. All
of these ideas can be extended to general (differentiable) constraints by using the fact that
ci(x+hp) = ci(x)+haT
i (x)p+O(h2),
where aT
i (x) is the gradient of the ith constraint at x. In other words, locally (for small
h) the constraints are almost linear. Rather than derive the results, we just summarize the
conclusions.
Let the m ×n matrix A(x) be deﬁned by
aij(x) = ∂ci(x)
∂xj
.
We add one assumption, the constraint qualiﬁcation that the gradients of the active con-
straints are linearly independent. The Lagrangian function is
L(x) = f (x)−λT c(x),
where there is a Lagrange multiplier λi for each constraint.
If all of our constraints are inequalities and the constraint qualiﬁcation holds, then
the ﬁrst-order optimality conditions for x to be a solution to the inequality-constrained
problem are
AT (x)λ = g(x),
λ ≥0,
c(x) ≥0,
λT c(x) = 0.
Since λ and c(x) are nonnegative, the last condition is just a fancy way of saying that if the
ith inequality constraint is not active, then the ith Lagrange multiplier must be zero. This
condition is often called complementarity.
If the jth constraint is an equality constraint rather than an inequality, then we remove
the nonnegativity constraint on its Lagrange multiplier and let λj be positive, negative, or
zero for j = 1,...,me. Other than that, the optimality conditions are unchanged.

November 20, 2008 10:52
sccsbook
Sheet number 149 Page number 139
cyan magenta yellow black
10.2. Solving Problems with Bound Constraints
139
CHALLENGE 10.1.
Let our minimization function be
f (x) = x2
1 +4x2
2 −x1x2 +5x1 +3x2 +6.
For the following problems, write the optimality conditions for minimizing f subject to the
given constraints. Solve each problem graphically and verify that the optimality conditions
hold at the solution.
(a) Suppose that there are no constraints.
(b) The constraint is
x1 + x2 = 2.
(c) The constraint is
x ≥0.
(d) The constraints are
x2
1 + x2
2 ≤1,
x ≥0.
A (necessary) second-order condition for optimality is that the matrix ZT ∇xx L(x,λ)Z
is positive semideﬁnite, where ∇xx denotes the matrix of second derivatives of L with re-
spect to the x variables and where the columns of Z form a basis for the null space of the
matrix whose rows are the gradients of the active constraints.
CHALLENGE 10.2.
Verify the second-order necessary condition for the problems in Challenge 10.1.
These optimality conditions are the basis for the interior-point methods discussed
in Section 10.5. Before studying these methods, though, we consider some ways in which
we might reduce a constrained problem to an unconstrained one so that we can apply the
methods of Chapter 9.
10.2
Solving Problems with Bound Constraints
Most optimization software designed to solve the problems in Chapter 9 can also handle
constraints of the form
ℓ≤x ≤u.
If such software is not available, then variable transformation can be used to eliminate the
constraints, and we give two examples of how this is done.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 150 Page number 140
cyan magenta yellow black
140
Chapter 10. Numerical Methods for Constrained Optimization
If the only constraints are that the variables be nonnegative, x ≥0, then we can re-
place the variables x with xj = eyj or xj = y2
j , for example, and minimize over y without
constraint.
Similarly, if we have only upper and lower bounds on the variables, −1 ≤xj ≤1, for
example, we might use the transformation xj = cos(yj).
The advantage of these variable transformations is the ability to use our unconstrained
minimizers; the disadvantage is the possible introduction of multiple local minimizers y
and the more complicated gradient expressions. For example, the transformation xj = y2
j
introduces 2n minimizers y for each minimizer x (since y2
j = (−yj)2).
10.3
Solving Problems with Linear Equality Constraints:
Feasible Directions
If the only constraints are linear equality constraints Ax = b, where A is an m ×n matrix,
then the feasible direction formulation can be very effective.
Note that usually m < n, since if m = n and A has full rank, then there is only one
point that satisﬁes the constraints, so there is nothing to optimize. In practice, though,
problems are often presented in a form that contains redundant constraints, and A may
fail to have full rank. Because of this it is important to use numerically stable variable
transformations, such as those based on the QR decomposition, as discussed at the end of
this section.
First we consider a simple example. Suppose our constraint is x1 +x2 = 1. Therefore
A =  1,
1  and b = [1]. Then all feasible points have the form
x =

0
1

+α

1
−1

.
(10.1)
This formulation works because if x has this form, then
Ax =  1,
1 x =  1,
1 
0
1

+α 1,
1 
1
−1

= 1,
and all vectors x that satisfy the constraints have the form (10.1).
In general, if our constraints are Ax = b, to get feasible directions, we express x as
x = xgood +Zv,
where
• xgood is a particular solution to the equations Ax = b (any one is ﬁne),
• v is an arbitrary vector of dimension (n −r)×1, where r is the rank of the matrix A,
• the columns of Z form a basis for the null space of A, so that for all v, Ax =
A(xgood)+AZv = Axgood = b.
(See Section 5.3.3 if these ideas need review.)

November 20, 2008 10:52
sccsbook
Sheet number 151 Page number 141
cyan magenta yellow black
10.4. Barrier and Penalty Methods for General Constraints
141
The null space of A deﬁnes the set of feasible directions, the directions in which
we can step without violating a constraint. So we have succeeded in reformulating our
constrained problem as an unconstrained one with a smaller number of variables:
min
v
f (xgood +Zv).
The most reliable way to implement this transformation when the constraints are
Ax = b is to use the QR decomposition of AT = QR to ﬁnd Z; see Section 5.3. If A is
full rank and we have m < n equality constraints, then the last n −m columns of the n ×n
matrix Q form an orthonormal basis for the null space. If we partition Q as [Q1,Z], with m
and n −m columns respectively, then a particular solution can be obtained by solving
RT
1 yp = b,
where R1 is the top n ×n block of R, and then setting xgood = Q1yp.
If A is not full rank, then we use the RR-QR decomposition (Section 5.4), and we
also need to check that the constraints are consistent, so that a vector xgood that satisﬁes
Axgood = b exists.
10.4
Barrier and Penalty Methods for General Constraints
Suppose our constraint is the inequality x2
1 + x2
2 ≤1, so that c1(x) = 1 −x2
1 −x2
2. Deﬁne
the barrier function −log(1 −x2
1 −x2
2), and let
Bμ(x) = f (x)−μ logc1(x)
= f (x)−μ log(1 −x2
1 −x2
2),
where μ > 0 is a given barrier parameter. Suppose we minimize Bμ(x), starting from a
point at which 1 −x2
1 −x2
2 > 0. Then we never move to a point where c1(x) < 0, because
there is a barrier of inﬁnite function values of Bμ that occur for values x satisfying c1(x) =
0. We also notice, as illustrated in Figure 10.1, that when μ is sufﬁciently small, the barrier
term is nearly zero for feasible points, so by minimizing Bμ(x) we approximately solve
our original problem. In this reformulation of our constrained minimization problem, the
barrier function erects a barrier to prevent the iteration from exiting the feasible region.
CHALLENGE 10.3.
Consider the problem
min
x 5x4
1 + x1x2 +6x2
2
subject to the constraints x ≥0 and x1 −2x2 = 4. Formulate this problem as an uncon-
strained optimization problem using feasible directions to eliminate the equality constraint
and a barrier function to eliminate the nonnegativity constraints.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 152 Page number 142
cyan magenta yellow black
142
Chapter 10. Numerical Methods for Constrained Optimization
Now deﬁne the penalty function max(0,(x2
1 + x2
2 −1))2, and let
Pμ(x) = f (x)+ 1
μ max(0,−c1(x))2
= f (x)+ 1
μ max(0,(x2
1 + x2
2 −1))2.
If we minimize Pμ(x) for a sufﬁciently small value of the penalty parameter μ, then
again, as illustrated in Figure 10.1, we have approximately solved our original problem.
This formulation uses a penalty function to impose a penalty in the objective function when
the constraint is violated.
In general, we can formulate a barrier method for a problem with m inequality con-
straints as minimizing
Bμ(x) = f (x)−μ
m
	
j=1
logcj(x),
and a penalty method as minimizing
Pμ(x) = f (x)+ 1
μ
m
	
j=1
max(0,−cj(x))2.
Then we solve the minimization problem using our favorite unconstrained minimization
method.
These examples illustrate the use of barrier and penalty functions. Functions other
than the log and the square functions can be used, but these are the most common choices.
Minimizing Bμ or Pμ can be a difﬁcult problem, because if μ is small and if x is near
the boundary, then the gradient of the function is quite steep. We expect the solution to our
original problem to occur on the boundary, so we cannot avoid this situation. Therefore,
often we solve a sequence of barrier or penalty problems with a decreasing sequence of μ
values, since larger values of μ give easier minimization problems with more gradual gradi-
ents. We decrease μ gradually, using the solution for one value as a good starting point for
the next. This is an important computational strategy: we replace one hard problem (con-
strained minimization) by a sequence of easier (unconstrained) problems, each of which
gives an approximate solution to the next. We see this again in Chapter 24 in continuation
methods for solving systems of nonlinear equations.
Penalty methods are quite convenient since, unlike barrier methods, we do not need
to start the iteration at a feasible point, and they can also be used for equality constraints.
The disadvantage is that they cannot be used if the functions f or c are undeﬁned outside
the feasible region. An advantage of barrier methods is that even if they are stopped early,
they yield a feasible point.
Penalty and barrier methods can be useful for simple optimization problems, but
the methods discussed in the next section, based on barrier functions, are generally more
reliable, since they give a prescription for choosing the sequence of barrier parameters in
order to give fast convergence.

November 20, 2008 10:52
sccsbook
Sheet number 153 Page number 143
cyan magenta yellow black
10.4. Barrier and Penalty Methods for General Constraints
143
−0.1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
z
Log Barrier Function for the Constraint z > 0
μ = 2−1
μ = 2−3
μ = 2−5
μ = 2−7
−1
−0.9
−0.8
−0.7
−0.6
−0.5
−0.4
−0.3
−0.2
−0.1
0
0.1
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
z
Quadratic Penalty Function for the Constraint z > 0
μ = 2−3
μ = 2−5
μ = 2−7
μ = 2−9
Figure 10.1. Barrier and penalty functions for the constraint z > 0. As μ →0,
the log barrier (top) makes almost no change to function values of f at feasible points.
The quadratic penalty (bottom) makes no change to f at feasible points, and as μ →0 it
is increasingly desirable to be feasible.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 154 Page number 144
cyan magenta yellow black
144
Chapter 10. Numerical Methods for Constrained Optimization
POINTER 10.1. Linear Programming Problems.
If f (x) is a linear function and if the constraints are linear, then we have a linear
programming problem. There are two popular types of algorithm:
• Simplex method for linear programming. This was the most popular algorithm until
the 1990s.
• Interior-point methods. These are generally faster on large problems and remain
an active area of research.
Both of these methods are implemented in MATLAB’s linprog.
10.5
Interior-Point Methods
Interior-point methods use log barrier functions in a systematic way in order to solve opti-
mization problems. There are several variants, but we focus here, as an example, on conic
convex optimization problems of the form
inf
x ⟨c,x⟩
subject to the constraints
Ax = b
and
x ∈K,
where ⟨c,x⟩denotes inner product between c and x and K ⊂Rn is a closed convex cone,
meaning that
• closed: the limit point of any sequence of points in K also lies in K,
• convex: if x and y are two points in K, then the line segment connecting them also
lies in K,
• cone: if x ∈K, then so is αx for all nonnegative scalars α.
Many important classes of optimization problems can be expressed in the form of a
conic convex optimization problem. Here are three examples:
• Linear programming: In this case we choose K = {x : x ≥0} to be the positive
orthant, the set of vectors with nonnegative entries. The inner product is deﬁned by
⟨c,x⟩= cT x.
• Second-order cone programming: K = {x : xn ≥∥x1:n−1∥2} is the set of vectors
whose last component is greater than or equal to the norm of the remaining compo-
nents. The inner product is deﬁned by ⟨c,x⟩= cT x.
• Semideﬁnite programming: In this case K is the set of symmetric positive semidef-
inite matrices of dimension n, and the inner product ⟨c,x⟩equals trace(cx), where c
and x are in K. The constraints become trace(aix) = bi, i = 1,...,m, where ai is a
matrix.

November 20, 2008 10:52
sccsbook
Sheet number 155 Page number 145
cyan magenta yellow black
10.5. Interior-Point Methods
145
POINTER 10.2. Min, Max, Inf, and Sup.
The mathematical notation inf (inﬁnum) is used instead of min in conic optimization
problems since it is possible that the function can be made arbitrarily small on the feasible
set and thus no ﬁnite minimum exists. Similarly, sup (supremum) is used instead of max.
This also covers the case when the cone is not closed and the optimal value is not achieved.
We associate with our conic optimization problem a dual problem
sup
w,s
⟨w,b⟩
subject to
A∗w+s = c
and
s ∈K ∗,
where K ∗denotes the set of points y for which ⟨x,y⟩≥0 for all x ∈K. The variables
w are Lagrange multipliers for the constraints Ax = b, and the variables s are Lagrange
multipliers for the cone constraint x ∈K. We assume the following:
• K has a nonempty interior (meaning that there is a point in K for which a small ball
centered at the point is also in K).
• K contains no lines (meaning that there is no point in K at which we can walk
inﬁnitely far in one direction and also in the opposite direction and remain in K).
We associate with our two problems the following nonlinear system of equations deﬁning
the primal-dual central path:
Ax = b,
A∗w+s = c,
μF′(x)+s = 0,
where
• F(x) is a barrier function for the cone K,
• x ∈K and s ∈K ∗,
• The barrier parameter μ is deﬁned to be μ = ⟨x,s⟩/n.
Some examples of barrier functions are given in Table 10.1, and we get some practice with
them in the next two challenges.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 156 Page number 146
cyan magenta yellow black
146
Chapter 10. Numerical Methods for Constrained Optimization
CHALLENGE 10.4.
Use the barrier functions from Table 10.1 to write the system of equations deﬁning
the primal-dual central path for
(a) linear programming,
(b) semideﬁnite programming.
CHALLENGE 10.5.
(a) If K = {x : x ≥0}, what is K ∗?
(b) Consider the linear programming problem
min
x cT x
subject to
Ax = b,
x ≥0.
What is the dual problem?
(c) Show that for linear programming, the dual constraint A∗w + s = c is equivalent to
AT w ≤c.
(d) Assume that the m × n matrix A has rank m, so that the constraint qualiﬁcation is
satisﬁed. Write the ﬁrst-order optimality conditions for the linear programming problem
and the equations for the primal-dual central path. Try to convince yourself that as μ →0,
the solution to the primal-dual central path equations satisﬁes the ﬁrst-order optimality
conditions.
From the preceding challenge we conclude that for linear programming, if we solve
the nonlinear system of equations corresponding to the primal-dual central path, for a se-
quence of values of μ decreasing to zero, the limit point of the solution sequence is a solu-
tion to our optimization problem. This is true in general for convex optimization problems
and is the basis for one class of interior-point methods.
So our problem is reduced to solving the system of nonlinear equations. The reason
that we use a sequence of μ values is related to the idea behind continuation methods: we
want the solution when μ = 0, but this is a difﬁcult problem with steep gradients, and fast
methods such as Newton’s method may fail to converge unless we start very close to the
optimal solution. Since the solution for one μ value is usually close to that for the next one,
a method like Newton’s method can be used quite effectively if μ is gradually decreased.
Interior-point methods have become the methods of choice for solving optimization
problems. We discussed them only for conic convex optimization problems, but they have
wide applicability. They provide a uniform framework, treating linear and nonlinear prob-
lems in a similar way. For some algorithms, it can be shown that the amount of work to

November 20, 2008 10:52
sccsbook
Sheet number 157 Page number 147
cyan magenta yellow black
10.6. Summary
147
Table 10.1. Barrier functions that can be used for various optimization problems
in deﬁning interior-point methods.
Problem
Constraint
Barrier function
Linear programming
x ≥0
F(x) = −n
i=1 log(xi)
Second-order cone
xn ≥∥x1:n−1∥
F(x) = −log(x2
n −∥x1:n−1∥2
2)
programming
Semideﬁnite programming
X pos. semi-def.
F(X) = −log(det(X))
ﬁnd an approximate solution is O(n3) (or better). Algorithms like the traditional simplex
method for linear programming have much worse bounds: in the worst case, they can visit
every vertex of the feasible set, and the number of vertices can be an exponential function
of n.
10.6
Summary
We have a variety of methods for constrained optimization problems:
• feasible direction methods for linear equality constraints.
• penalty and barrier methods if no better software is available.
• interior-point methods for convex optimization.
If the problem is not convex, then these methods can still be tried, but they may fail to
converge or may converge to a point that is just a local minimizer rather than a global one.
CHALLENGE 10.6.
Consider the problem of minimizing the function
f (x) = −(x1 −1/2)(x2−1/2)
over the unit square [0,1] × [0,1]. Convince yourself that there are two minimizers, at
opposite corners of the square. Try to solve this problem using one of our algorithms.
Find starting points so that both minimizers can be found. Then modify the function f so
that one corner is only a local minimizer and again ﬁnd starting points so that both local
minimizers can be found. In nonconvex problems like this one, it is usually impossible to
tell whether a global minimizer has been found.
In the next few chapters we try our algorithms on a variety of constrained and uncon-
strained optimization problems, emphasizing the fact that additional information about the
problem can lead to a more efﬁcient and reliable algorithm.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 158 Page number 148
cyan magenta yellow black
148
Chapter 10. Numerical Methods for Constrained Optimization
POINTER 10.3. Further Reading.
We have just touched the surface of the subject of constrained optimization. More
detail can be found in the textbooks by Nash and Sofer [111] and Nocedal and Wright [115]
and the notes of Nemirovski [114].

November 20, 2008 10:52
sccsbook
Sheet number 159 Page number 149
cyan magenta yellow black
Chapter 11 / Case Study
Classiﬁed
Information: The
Data Clustering
Problem
(coauthored by Nargess Memarsadeghi)
Many projects in engineering and science require the classiﬁcation of data based on
different criteria. For example,
• Designers classify automobile engine performance as acceptable or unacceptable
based on a combination of efﬁciency, emissions, noise levels, and other criteria.
• Researchers routinely classify documents as “relevant to the current project” or “ir-
relevant.”
• Genomic decoding divides RNA molecules into (coding) ones which translate into a
protein and (noncoding) ones that do not.
• Pathologists identify cells as cancerous or benign.
We can classify data into different groups by clustering data that are close with
respect to some distance measure. In this project, we investigate the design, use, and pitfalls
of a popular clustering algorithm, the k-means algorithm, which solves an unconstrained
optimization problem.
The Problem
For concreteness, we cluster the pixels in the image shown in Figure 11.1. Suppose our
original image is of size m × p, with the color for each of the mp pixels recorded by b
bits. Then the total storage requirement is mpb bits. We choose k pixel values (colors) as
cluster centers and map each pixel to one of these. This forms k clusters of pixels. This
149
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 160 Page number 150
cyan magenta yellow black
150
Chapter 11. Case Study: Classiﬁed Information
Figure 11.1. Use clustering algorithms to group the pixels of this image of Charlie
(photographed by Timothy O’Leary).
saves space (since we can store the cluster index for each pixel instead of the pixel value)
and, in addition, ﬁlters out noise in the image.
The data for our sample problem is a 500×500 pixel image in jpeg format. For jpeg,
the b bits for a pixel store q = 3 values (red, green, blue), each ranging between 0 and
255. We begin our investigation in Challenge 11.1 by seeing how clustering reduces data
storage.
CHALLENGE 11.1.
Compare the number of bits required to store the original image and the image formed
after clustering to k colors.
Note that it takes log2 256 = 8 bits to store a number that ranges between 0 and 255.
We can state our clustering problem this way. Given n data points xi ∈Rq, i =
1,...,n, and given a value of k, we want to ﬁnd k cluster centers cj ∈Rq, j = 1,...,k,
that are in some sense optimal and then assign each data point to a cluster. We assign xi to
cluster Cj if it is closer to that cluster’s center than it is to any other center. (Break ties in
an arbitrary way.) The distance from data point i to its cluster’s center is thus
di = min
j=1,...,k ∥xi −cj∥,
and we deﬁne the radius of cluster Cj as
rj = max
i:xi∈Cj
di .

November 20, 2008 10:52
sccsbook
Sheet number 161 Page number 151
cyan magenta yellow black
Why the Problem is Hard
151
For good clustering, we want each point to be close to one cluster’s center. Therefore, we
might want to minimize either
R =
k
	
j=1
rℓ
j
or
D =
n
	
i=1
dℓ
i ,
where ℓ= 1 or 2. The variables in the minimization problem are the cluster centers.
Why the Problem Is Hard
In the next challenge, we consider some properties of the functions R and D.
CHALLENGE 11.2.
For this challenge, use the Euclidean norm with q = 1 and ℓ= 2.
(a) If a function is convex and bounded below, then any local minimizer is a global min-
imizer. If not, then an algorithm for minimization might report a local minimizer rather
than a global one. Consider the problem with n = 2 points and k = 2 clusters. Are D and
R convex functions?
(b) Are D and R differentiable functions when n = 2 and k = 2?
(c) Derive a formula for the minimizer of D when k = 1 and n is arbitrary.
(d) Suppose we move one of our data points xi very far away from the other points, making
it an outlier. As that point moves further away from the others, what happens to the cluster
centers determined by minimizing D or R?
From Challenge 11.2, we know that the minimization problem has some difﬁcult
properties, but let’s try to compute the cluster centers using a standard optimization algo-
rithm. To get the solution process started, we provide an array of k approximate centers.
A common method for ﬁnding initial centers is to select k distinct points randomly among
the data values, or perhaps to use k extreme values. When comparing algorithms, each
should use the same initial centers. Challenge 11.3 investigates our clustering criteria and
the behavior of optimization algorithms.
CHALLENGE 11.3.
Use your favorite optimization function (e.g., MATLAB’s fminunc) to minimize R
with ℓ= 2 and the Euclidean norm. Use the data of Figure 11.1, and provide a function to
evaluate R. Try k = 3,4,5. Also minimize D with the same parameters.
Write a function map_to_cluster that takes the data values and cluster centers as
input and returns the cluster number for each data value and the counts of the number of
data points assigned to each cluster. Use this function to generate the clustered image.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 162 Page number 152
cyan magenta yellow black
152
Chapter 11. Case Study: Classiﬁed Information
Algorithm 11.1 The k-Means Algorithm
Choose initial centers c1,...,ck.
while the clusters are changing,
for i = 1,...,n,
Assign each data point xi to the cluster Cj whose center cj is closest to it, breaking
ties in an arbitrary way.
end
for j = 1,...,k,
Recompute the center cj to be the mean (centroid) of the points in the cluster:
cj = 1
nj
	
i:xi∈Cj
xi ,
where nj is the number of data points in Cj.
end
end
To keep the computation time reasonable, determine the cluster centers based on a
sample of points in the image rather than using all 250,000 pixels. Choose the 1000 points
in columns 210 and 211 in the sample image. Then experiment with other choices of points
to study the algorithm’s sensitivity to this choice.
(a) How does the number of variables increase with k?
(b) How does the running time increase with k?
(c) Evaluate the results of the various clusterings and justify the criteria that you choose to
use in your evaluation. As one criterion, discuss how the clustered images look in compar-
ison to the original image.
(d) How might a good value of k be determined experimentally?
The k-Means Algorithm
A general purpose minimization routine is a good tool to have, because it is useful for
a wide variety of problems. But sometimes we can develop a better algorithm by taking
advantage of special structure in the problem. Consider Algorithm 11.1, the k-Means
Algorithm. It minimizes neither D nor R, but it iterates by clustering based on the current
centers and then moving each center to the centroid of the points in the cluster.
In Challenge 11.4, we implement this algorithm.
CHALLENGE 11.4.
Implement the k-means algorithm and run it with the same data and values of k as
Challenge 11.3. Compare its performance to that of the algorithm in Challenge 11.3.

November 20, 2008 10:52
sccsbook
Sheet number 163 Page number 153
cyan magenta yellow black
Pitfalls in Data Clustering
153
Figure 11.2. The images resulting from k-means.
Your implementation for this challenge should be rather general: write a function
mycluster that takes as input the n data values, an initial guess for the k cluster centers,
a convergence tolerance, and a maximum number of iterations. The output is assignments
of each data point to a cluster, the set of k cluster centers, the number of data values in each
cluster, and the radius of each cluster. Use another function to evaluate R or D, given the k
ﬁnal cluster centers. Compare the resulting clusters to those in Challenge 11.3.
The results of this challenge are shown in Figure 11.2.
Pitfalls in Data Clustering
This form of data clustering is quite useful, and the k-means algorithm is very successful in
practice. Nevertheless, there are many pitfalls associated with its use. We investigate two
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 164 Page number 154
cyan magenta yellow black
154
Chapter 11. Case Study: Classiﬁed Information
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
x1
x2
Figure 11.3. This data set illustrates some of the pitfalls of clustering.
of these, dependence of the answer on the starting data and on the number of clusters, in
Challenge 11.5.
CHALLENGE 11.5.
Consider the data set of n = 20 data points with q = 2, shown in Figure 11.3:
(1,−1 +2 j/9), (−1,−1 +2 j/9),
for j = 0,...,9. Run the k-means algorithm with k = 2,3,4. Initialize the centers to the
ﬁrst k points in the list
(−1,−1),(1,1),(−1,1),(1,−1).
Display the clustered data. Discuss the effects of choosing the “wrong” value for k.
Then repeat the experiment, initializing the centers to
(0,−1 +2 j/(k−1)),
j = 0,...,k −1. Note that although the answer is different, it is also a local minimizer of
the (nonconvex)function R. Compare with the ﬁrst set of answers and discuss the difﬁculty
it illustrates with this kind of clustering.
Sensitivities of the clustering to the initial choice of centers and the number of clus-
ters are serious pitfalls. As we see in Challenge 11.6, another serious pitfall arises from the
sensitivity of the clustering to variable transformations.

November 20, 2008 10:52
sccsbook
Sheet number 165 Page number 155
cyan magenta yellow black
Pitfalls in Data Clustering
155
POINTER 11.1. Further Reading.
The k-means algorithm used in Challenge 11.4 as well as other approaches to clus-
tering are discussed, for example, in [52, 85, 84, 145].
Davidson [34] gives a nice discussion of the troubles we illustrate in Challenges 11.5
and 11.6, as well as many other pitfalls.
There are many implementations of variants of the k-means algorithm; see, for ex-
ample, the software of Guan [44, 65].
CHALLENGE 11.6.
Consider the data set from Challenge 11.5, but multiply the second component of
each data point by 100. Repeat the clustering experiments, applying the same transfor-
mation to the initial centers. Discuss why coordinate scaling is important in clustering
algorithms.
Through our investigations, we see that despite its pitfalls, clustering is an important
tool for data classiﬁcation, noise reduction, and storage savings. Because of the noncon-
vexity of this problem, special purpose optimization algorithms, such as the ones discussed
in this chapter, are preferred to the general purpose ones of Chapters 9 and 10.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 166 Page number 156
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 167 Page number 157
cyan magenta yellow black
Chapter 12 / Case Study
Achieving a
Common Viewpoint:
Yaw, Pitch, and Roll
(coauthored by David A. Schug)
Tracking objects, controlling the navigation of a spacecraft, assessing the quality
of machined parts, and identifying proteins seem to have little in common, but all of these
problems (and many more problems in computer vision and computational geometry) share
a core computational task: rotating and translating two objects so that they have a common
coordinate system. In this case study, we study this deceptively simple optimization prob-
lem and its pitfalls.
“Life is about change; nothing ever stays the same.” In particular, objects move, and
tracking them is an essential ingredient in applications such as navigation and robot motion.
Surprisingly, the same mathematical tools used in tracking are also used in the absolute
orientation problem of comparing two objects, such as proteins or machine parts, to see
if they have the same structure.
Consider molecule A in Figure 12.1, which we specify by the coordinates a1,...,a7
of the centers of the seven spheres that represent some of its atoms, and the corresponding
object B, obtained by rotating A. There are many ways to deﬁne 3D rotations, but in this
case study, we specify the yaw φ, the pitch θ, and the roll ψ, as is common in ﬂight control.
In this coordinate system, the angles φ, θ, and ψ are called the Euler angles, and a rotation
Q is deﬁned by the product of three matrices
Q(φ,θ,ψ) = QrollQpitchQyaw,
where
Qroll =
⎡
⎣
1
0
0
0
cosψ
sinψ
0
−sinψ
cosψ
⎤
⎦,
Qpitch =
⎡
⎣
cosθ
0
−sinθ
0
1
0
sinθ
0
cosθ
⎤
⎦,
157
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 168 Page number 158
cyan magenta yellow black
158
Chapter 12. Case Study: Achieving a Common Viewpoint
,
Figure 12.1. How can we tell that molecule A (left) and molecule B (right) are
the same?
Qyaw =
⎡
⎣
cosφ
sinφ
0
−sinφ
cosφ
0
0
0
1
⎤
⎦.
We impose the restrictions −π < φ < π, −π/2 < θ < π/2, and −π < ψ < π. Our ﬁrst
task is to develop some familiarity with this representation for rotation matrices.
CHALLENGE 12.1.
(a) Explain geometrically the effect of applying a rotation Q to a vector [x, y,z]T to create
the vector Q[x, y,z]T.
(b) Show that if Q is any 3 ×3 orthogonal matrix (i.e., QT Q = I), then Q can be expressed
as QrollQpitchQyaw for some choice of angles ψ, θ, and φ.
Next, we need to determine the Euler angles (φ,θ,ψ) so that Q(φ,θ,ψ) rotates object
A in Figure 12.1 to object B. Let A be the 3 × n matrix (n = 7) whose columns are the
coordinates of the ﬁrst set of points: A = [a1,...,a7]. Deﬁne B similarly from the second
set of points. Then we want to determine the three Euler angles so that
B = Q(φ,θ,ψ)A.
Since life is about change and imperfection, we don’t expect to get an exact equality, but
we want to make the difference between B and Q(φ,θ,ψ)A as small as possible. One
reasonable way to measure this is by taking the sum of the squares of the differences in
each component; then our task is to minimize
f (φ,θ,ψ) = ∥B−Q(φ,θ,ψ)A∥2
F ≡
n
	
i=1
∥bi −Q(φ,θ,ψ)ai∥2
2 .

November 20, 2008 10:52
sccsbook
Sheet number 169 Page number 159
cyan magenta yellow black
Chapter 12. Case Study: Achieving a Common Viewpoint
159
Minimizing f is a nonlinear least squares problem with three variables, so let’s exper-
iment with solving the problem for various data sets. The square root of f/n is the root
mean squared distance (RMSD) between the two objects. The factor 1/n applied to
f forms the average (mean) of the squared distances between the corresponding points.
RMSD provides us in Challenge 12.2 with a measure of how well our objects match.
CHALLENGE 12.2.
Use a nonlinear least squares solver (e.g., MATLAB’s lsqnonlin) to ﬁnd the Euler
angles for the data sets (A,Q(φ,θ,ψ)A) generated by taking the yaw φ = π/4, roll ψ = π/9,
and
A =
⎡
⎣
0
0
1
1
0
−1
0
0
1
1
0
0
1
2
0
1
2
3
4
4
4
⎤
⎦.
Let the pitch θ vary between −π/2 and π/2 in steps of π/120. Plot the computed Euler
angles, and, in a separate plot, the Frobenius norm of the error in the computed Q and the
RMSD in the computed positions. Discuss the time needed for solution and the accuracy
obtained.
The problem we are considering is an old one, sometimes called the orthogonal
Procrustes problem. In the next challenge we derive a better way to solve it.
CHALLENGE 12.3.
(a) Recall that the trace of a square matrix is the sum of its main diagonal entries, and that
the trace of the sum of two matrices is the sum of the two traces. We need two additional
facts about traces in order to derive our algorithm. Prove the following:
1. For any matrix C, trace(CT C) = ∥C∥2
F.
2. For any matrix D for which the product CD is square, trace(CD) = trace(DC).
(b) Use the ﬁrst fact to show that the Q that minimizes ∥B −QA∥2
F over all choices of
orthogonal Q also maximizes trace(AT QT B).
(c) Suppose that the singular value decomposition (SVD) of the m × m matrix BAT is
UVT , where U and V are m ×m and orthogonal, and  is diagonal with diagonal entries
σ1 ≥··· ≥σm ≥0. Deﬁne Z = VT QT U. Use these deﬁnitions and the second fact to show
that
trace(AT QT B) = trace(QT BAT ) = trace(Z) ≤
m
	
i=1
σi.
(d) If Z = I, then
trace(QT BAT ) =
m
	
i=1
σi.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 170 Page number 160
cyan magenta yellow black
160
Chapter 12. Case Study: Achieving a Common Viewpoint
What choice of Q ensures that Z = I and therefore ensures that the trace is maximized over
all choices of Q?
Challenge 12.3 shows that the optimal Q is UVT , determined by computing an SVD
of BAT . This is much more efﬁcient than solving the nonlinear least squares problem as
we did in Challenge 12.2. Let’s redo the computations.
CHALLENGE 12.4.
Use the SVD to ﬁnd the Euler angles for the data in Challenge 12.2. Compare with
your previous results.
So far we have assumed that the object has rotated with respect to the origin but has
not translated. Now we consider a more general problem:
B = Q(φ,θ,ψ)A+teT,
where the 3 ×1 vector t deﬁnes the translation and e is a column vector with n ones. How
might we solve this problem?
One way is to solve a nonlinear least squares problem for t and the Euler angles. Here
(as in the case study of Chapter 13), we could take advantage of the fact that given t, it is
easy to compute the optimal Q, so we can express the problem as a function of just three
variables: t1, t2, and t3. It is interesting to implement this algorithm, but we’ll just focus on
a much more efﬁcient approach.
The “easy” way arises from observing that the translation can be deﬁned by the move-
ment of the centroid of the points:
cA = 1
n
n
	
j=1
aj,
cB = 1
n
n
	
j=1
bj.
Luckily, the averaging in the centroid computations tends to reduce the effects of random
errors, and Challenge 12.5 shows how t can be deﬁned in terms of the centroids.
CHALLENGE 12.5.
Given a ﬁxed rotation matrix Q, show that the minimizer topt of ∥B −QA −teT ∥F
satisﬁes
topt = cB −QcA.
So we have an algorithm for solving our problem: we move both objects so that their
centroids are at zero and then compute the resulting rotation Q using the SVD. Finally,

November 20, 2008 10:52
sccsbook
Sheet number 171 Page number 161
cyan magenta yellow black
Chapter 12. Case Study: Achieving a Common Viewpoint
161
we reconstruct the translation using the formula in Challenge 12.5. Let’s see how this
algorithm behaves.
CHALLENGE 12.6.
Implement this algorithm and try it on the data from Challenge 12.2 using θ = π/4
and 20 randomly generated translations t. Then repeat the experiment with 20 more trans-
lations, adding to each element of A a perturbation that is uniformly distributed between
−10−3 and 10−3, to see how sensitive the computation is to uncertainty in the measure-
ments.
Through these computations (and further experimentation, if desired), you can see
that the rotation matrix Q can almost always be computed quite accurately by the SVD
algorithm; unfortunately, the Euler angles are not as well determined. In the next challenge,
we study some degenerate cases.
CHALLENGE 12.7.
(a) Suppose that all of our points in A lie on a line. Is there more than one choice of Q that
minimizes ∥B−QA∥? Illustrate this with a numerical example.
(b) Use this insight to characterize the degenerate cases for which Q is not well determined.
(c) Suppose that our true data produces the angles (φ,θ = π/2,ψ), but a small perturbation
causes a small increase in the angle θ so that it is greater than π/2. Generate such an
example, and observe that the computed angles are quite different. This jump in angle
is called gimbal lock, a term borrowed from the locking of the mechanism that moves a
stabilizing gyroscope in cases when the angle goes out of the range of motion of the device.
We can always choose a set of reference points for the object to make the matrix Q
well determined, but unfortunately, this does not guarantee that the Euler angles are well
determined.
One way to avoid this artiﬁcial ill-conditioning is to replace Euler angles by a better
representation of the information in Q. Quaternions are a common choice, and Pointer 12.1
gives references to more information on this subject.
In this case study we see that a rather complicated optimization problem reduces to
a simple linear algebra problem, provided we use an appropriate matrix decomposition.
We are not always this lucky, but when we are, we should certainly take advantage of this
structure.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 172 Page number 162
cyan magenta yellow black
162
Chapter 12. Case Study: Achieving a Common Viewpoint
POINTER 12.1. Further Reading.
One important problem that we have ignored is that of getting a set of corresponding
points from the two objects. This is treated, for example, in [146].
To help with Challenge 12.1, a nice demonstration of the parameters for yaw, pitch,
and roll is found at [138]. Other rotation coordinate systems are described, for example, in
[154].
The orthogonal Procrustes problem in Challenge 12.3 is considered in [64].
The use of quaternions instead of Euler angles is discussed, for example, in [96].

November 20, 2008 10:52
sccsbook
Sheet number 173 Page number 163
cyan magenta yellow black
Chapter 13 / Case Study
Fitting Exponentials:
An Interest in Rates
In this case study we investigate the problem of ﬁtting a sum of exponential functions to
data. This problem occurs in many real situations, but we will see that getting a good
solution requires care.
Suppose we have two chemical reactions occurring simultaneously, with the amount
y of a reactant changing due to both processes and behaving as a function of time t as
y(t) = x1eα1t + x2eα2t,
where x1, x2, α1, and α2 are ﬁxed parameters. The negative values α1 and α2 are rate
constants; in time −1/α1, the ﬁrst exponential term drops to 1/e of its value at t = 0. Often
we can observe y(t) fairly accurately, and we would like to determine the rate constants
and the amplitude constants x1 and x2. This involves ﬁtting the parameters of the sum of
exponentials.
In this project we study efﬁcient algorithms for solving this problem, but illustrate
that for many data sets, the solution is not well determined.
How Sensitive Are the Amplitude Constants to Errors in the Data?
In this section, we investigate how sensitive the y function is to choices of parameters x,
assuming that we are given the α parameters exactly.
Typically, we observe the function y(t) for m ﬁxed t values, perhaps ti = 0,t,2t,
...,tf inal. For a given parameter set α and x, we can measure the goodness of the ﬁt of
model to data by calculating the residual
ri = y(ti)−ye(ti),
i = 1,...,m ,
(13.1)
where ye(t) = x1eα1t + x2eα2t is the model prediction. Ideally, the residual vector r = 0,
but due to noise in the measurements, we never achieve this. Instead, we compute model
parameters that make the residual as small as possible, and we often choose to measure size
using the 2-norm: ∥r∥2 = rT r.
Note that if the parameters α are given, then we ﬁnd the x parameters by solving a
linear least squares problem, since ri is a linear function of x1 and x2. Thus, we minimize
163
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 174 Page number 164
cyan magenta yellow black
164
Chapter 13. Case Study: Fitting Exponentials: An Interest in Rates
the norm of the residual, expressed as
r = y−Ax,
where aij = eαjti, j = 1,2, i = 1,...,m, and yi = y(ti).
This problem can be easily solved using matrix decompositions such as the QR de-
composition of A into the product of an orthogonal matrix times an upper-triangular one
(see Section 5.3.3), or the singular value decomposition (SVD) (Section 5.6). We’ll focus
on the SVD since, although it is somewhat more expensive, it generally is less inﬂuenced
by rounding error and also easily gives us a bound on the problem’s sensitivity to small
changes in the data.
The solution to Challenge 5.19 shows that the sensitivity of the parameters x to
changes in the observations y depends on the condition number κ(A). With these basic
formulas in hand, we investigate this sensitivity in Challenge 13.1.
CHALLENGE 13.1.
Generate 100 problems with data xtrue = [0.5,0.5]T, α = −[0.3,0.4], and
ytrue( j) = [eα1t( j),eα2t( j)]xtrue,
where t = [0,0.01,...,6.00]. Suppose there are errors in the measurements so that
y = ytrue +ηz,
where η = 10−4 and the elements of the vector z are independent and uniformly distributed
on the interval [−1,1]. In one ﬁgure, plot the computed solutions x(i), i = 1,...,100 ob-
tained by your SVD algorithm assuming that α is known. In a second ﬁgure, plot the
components w(i) of the solution in the coordinate system determined by the right singular
vectors of A. Interpret these two plots using the results of Pointer 5.5. In particular, the
points in the ﬁrst ﬁgure are close to a straight line. What determines the line’s direction?
What determines the shape and size of the point cluster in the second ﬁgure? Verify your
answers by repeating the experiment with α = −[0.3,0.31], and also try varying η to be
η = 10−2 and η = 10−6.
How Sensitive Is the Model to Changes in the Rate Constants?
Now we need to investigate the sensitivity to the nonlinear parameters α, where −α1 and
−α2 are rate constants. In Challenge 13.2, we display how fast the function y changes
as we vary these parameters, assuming that we compute the optimal x parameters using a
linear least squares algorithm.
CHALLENGE 13.2.
Suppose that the chemical reactions are described by
y(t) = 0.5e−0.3t +0.5e−0.7t .
Suppose that we observe y(t) for t ∈[0,tf inal], with 100 equally-spaced observations per
second.

November 20, 2008 10:52
sccsbook
Sheet number 175 Page number 165
cyan magenta yellow black
Solving the Nonlinear Problem
165
−0.8
−0.6
−0.4
−0.2
−0.8
−0.6
−0.4
−0.2
α1
α2
tfinal = 1
−0.8
−0.6
−0.4
−0.2
−0.8
−0.6
−0.4
−0.2
α1
α2
tfinal = 2
−0.8
−0.6
−0.4
−0.2
−0.8
−0.6
−0.4
−0.2
α1
α2
tfinal = 3
−0.8
−0.6
−0.4
−0.2
−0.8
−0.6
−0.4
−0.2
α1
α2
tfinal = 4
−0.8
−0.6
−0.4
−0.2
−0.8
−0.6
−0.4
−0.2
α1
α2
tfinal = 5
−0.8
−0.6
−0.4
−0.2
−0.8
−0.6
−0.4
−0.2
α1
α2
tfinal = 6
Figure 13.1. Contour plots of the residual norm of the data ﬁtting as a function
of the estimates of α for various values of tf inal. The contours marked are 10−2, 10−6, and
10−10.
Compute the residual norm for various α estimates, using the optimal values of x1
and x2 computed by the algorithm in Challenge 5.19(a) for each choice of α. Make 6
contour plots of the log of the residual norm as a function of α, letting the observation
interval be tf inal = 1,2,...,6 seconds. Plot contours of −2, −6, and −10. How helpful is
it to gather data for longer time intervals? How well determined are the α parameters?
From the results of Challenge 13.2, shown in Figure 13.1, we learn that the parame-
ters α are not well determined; there is a broad range of α values that lead to small residuals.
This is an inherent limitation in the problem and we cannot change it. Nonetheless, we want
to develop algorithms to compute approximate values of α and x as efﬁciently as possible,
and we next turn our attention to this computation.
Solving the Nonlinear Problem
If we are not given the parameters α, then minimizing the norm of the residual r deﬁned
in (13.1) is a nonlinear least squares problem. For our model problem, there are four
parameters to be determined. We could solve this using standard optimization software, but
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 176 Page number 166
cyan magenta yellow black
166
Chapter 13. Case Study: Fitting Exponentials: An Interest in Rates
it is more efﬁcient to take advantage of the problem’s least squares structure. In addition,
since two parameters occur linearly, it is wise to take advantage of that structure, too. One
very good way to do this is to use a variable projection algorithm. The reasoning is
as follows: our residual vector is a function of all four parameters, but given the two α
parameters, the optimal values of the two x parameters are easy to determine by solving the
linear least squares problem that we considered in Challenge 5.19. Therefore, we express
our problem as a minimization problem with only two variables:
min
α ∥r∥2,
where the computation of r(α) requires us to determine the x parameters by solving a linear
least squares problem using, for instance, the SVD.
This is a very neat way to express our minimization problem, but we pay for that
convenience when we evaluate the gradient of the function f (α) = rT r. Since the gradient
is quite complicated, we can choose either to use special purpose software to evaluate it
(See Pointer 13.1) or use a minimizer that computes a difference approximation to it.
CHALLENGE 13.3.
(a) Use a nonlinear least squares algorithm to determine the sum of two exponential func-
tions that approximates the dataset generated with α = [−0.3,−0.4], x = [0.5,0.5]T, and
independent normally distributed error with mean zero and standard deviation η = 10−4.
Provide 601 values of (t, y(t)) with t = 0,0.01,...,6.0. Experiment with the initial guesses
x(0) =
 3
4

, α(0) =
 −1,−2 
and
x(0) =

3
4

, α(0) =
 −5,−6 
.
Plot the residuals obtained from each solution. Repeat the experiment with α = [−0.30,−0.31].
How sensitive is the solution to the starting guess? (If no standard nonlinear least squares
algorithm is available (such as lsqnonlin in MATLAB), use a general purpose mini-
mization algorithm.)
(b) Repeat the runs of part (a), but use variable projection to reduce to two parameters, the
two components of α. Discuss the results.

November 20, 2008 10:52
sccsbook
Sheet number 177 Page number 167
cyan magenta yellow black
Solving the Nonlinear Problem
167
0
1
2
3
4
5
6
−0.02
0
0.02
0.04
0.06
0.08
0.1
0.12
0.14
0.16
Time (t)
Concentration (y)
Figure 13.2. Data for Challenge 13.4. Given these measurements of the species
concentration (mg/ml) vs. time (sec) or drug concentration (mg/liter) vs. time (hours), ﬁnd
the rate constants.
To ﬁnish our investigation of exponential ﬁtting, let’s try dealing with the data of
Figure 13.2.
CHALLENGE 13.4.
Suppose that we gather data from a chemical reaction involving two processes; one
process produces a species and the other depletes it. We have measured the concentration
of the species as a function of time. (If you prefer, suppose that the data arises from mea-
surements of the amount of drug in a patient’s bloodstream while the drug is being absorbed
from the intestine and excreted by the kidneys.) We display the data in Figure 13.2; it is
available on the website. Suppose that your job (or even the patient’s health) depends on
determining the two rate constants and a measure of uncertainty in your estimates. Find the
answer and document your computations and your reasoning.
In this case study we found efﬁcient algorithms for solving data ﬁtting problems that
lead to very sensitive optimization problems. Like the image deblurring problem in the
case study of Chapter 6, ﬁtting rate constants is an ill-posed problem: small changes in the
data can make very large changes in the solution. In the next two case studies we continue
our study of such sensitive problems.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 178 Page number 168
cyan magenta yellow black
168
Chapter 13. Case Study: Fitting Exponentials: An Interest in Rates
POINTER 13.1. Further Reading.
In the case study of Chapter 8, we also studied exponential ﬁtting in order to deter-
mine directions of arrival of signals. That problem was somewhat better posed, since the
data did not decay.
Fitting a sum of exponentials to data is necessary in many experimental systems
including ﬂuorescence of molecules [25], kinetics of voltage formation [73], studies of
scintillators using x-ray excitation [42], drug metabolism, and predator-prey models. Often,
though, the publication of a set of rate constants elicits a storm of letters to the editor,
criticizing the methods used to derive them. It is important to do the ﬁt carefully and to
document the methods used.
See Chapter 5 for further information on perturbation theory, SVD, and numerical
solution of linear least squares problems.
Looking at the contours of a function is a useful way to understand it. The MATLAB
function contour is one way to construct such a plot.
The variable projection algorithm Varpro, which solves nonlinear least squares
problems by eliminating the linear variables, was described by Gene Golub and Victor
Pereyra. Linda Kauffman noticed that each iteration would run faster if certain negligible
but expensive terms in the derivative computation were omitted. A recent review of the
literature on the algorithm and its applications was written by Golub and Pereyra [63].
Although bad computational practices are often used in published papers involving
ﬁtting exponentials, the pitfalls are discussed quite lucidly in many sources. See, for exam-
ple, the work of Shrager and Hendler [137] and the series of tutorials by Rust [129].

November 20, 2008 10:52
sccsbook
Sheet number 179 Page number 169
cyan magenta yellow black
Chapter 14 / Case Study
Blind
Deconvolution:
Errors, Errors
Everywhere
We focus in this case study on a class of methods that accounts for uncertainty in the model
as well as the data. Our example concerns spectroscopy, where we try to reconstruct a true
spectrum from an observed one. The problem we are considering is sometimes called blind
deconvolution, since we are trying to unravel not only the spectrum but the function that
caused the blurring. These problems also arise in image deblurring.
Consider the data of Figure 14.1, representing counts measured by a spectrometer.
Suppose we have particles whose energy ranges from elo to ehigh, and deﬁne some inter-
mediate energy levels elo = e0 < e1 < ··· < enb−1 < enb = ehigh. This creates nb bins,
where the count for the jth bin is the number of particles determined to have energies be-
tween ej−1 and ej. Our spectrometer records nb counts, one for each bin, and in the ﬁgure
we have passed a curve through these counts.
Now ideally, the count in bin j is exactly the number of particles with energies in the
range [ej−1,ej]. But some blurring occurs due to the measurement process, and a particle
in that energy range might instead be included in the count for a different nearby bin. The
probability that a particle with energy e is assigned to bin j is often modeled as a normal
distribution with mean (ej +ej−1)/2 and variance s2
j .
We would like to determine the correct counts fj and the correct blurring given the
measured counts gj, j = 1,...,nb and estimates of the values sj.
One model of this process is the matrix equation (K+E) f = g+r, where E accounts
for errors in modeling the spectrometer’s blur and r accounts for errors in counts. The
matrix entry kjℓis our estimate of the probability that a particle whose energy is in the
interval [eℓ−1,eℓ] is assigned to bin j ( j, ℓ= 1,...,nb). As in the case study of Chapter 6,
this linear system of equations is an approximation to an integral equation of the ﬁrst kind
 ∞
0
K(e, ˜e) f (˜e)d ˜e = g(e),
and our information about the kernel function K(e, ˜e) is incomplete.
169
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 180 Page number 170
cyan magenta yellow black
170
Chapter 14. Case Study: Blind Deconvolution: Errors, Errors Everywhere
1.5
2
2.5
3
3.5
4
4.5
5
0
0.5
1
1.5
2
2.5
3
3.5
energy
thousands of particles
Figure 14.1. (Simulated) data from a spectrometer. Given that there are particles
with at most 5 different energy levels, determine these energies and the relative abundance
of the particles.
There are several sources of differences between the true spectrum g + r and the
recorded spectrum g:
• We effectively assign energy (ej + ej−1)/2 to all particles in bin j, and this is not
correct.
• A count’s value depends on the number of particles with the energies that it repre-
sents, but there is some blurring, so that it also depends on the number of particles
with nearby energies.
• The values of the counts often have some error, since they are ﬁnite precision rep-
resentations rather than the inﬁnite precision “real ones.” In our data, the counter
incremented by 0.1 for every hundred particles detected.
We could assume that the main error is in our estimates of the variances sj, and try
to estimate the correct values of the variances and the correct counts. We take a different
approach, appropriate even when the probabilities are not exactly normal and a correction
needs to be applied to them. Our approach is useful whenever both K and g have errors
whose relative variance is known or can be estimated. We experiment with two models:
• Model 1: Least squares. This model assumes that most of the error is in g, so E is
assumed to be zero.

November 20, 2008 10:52
sccsbook
Sheet number 181 Page number 171
cyan magenta yellow black
Model 1: Least Squares (E = 0)
171
• Model 2: Total least squares. This model assumes that there is signiﬁcant error in
both g and K.
Model 1 was used in the case study of Chapter 6. As in that problem, the matrix K
(m ×n) can be quite ill-conditioned, so small changes in the measured counts g make large
changes in the resulting f. Therefore, as in that case study, we add regularization to make
the problem better conditioned, and we focus on the truncated SVD as a tool for doing this.
Our major algorithmic task is to ﬁgure out how to determine f, E, and r without much
computational effort. In particular, we don’t want to need to start over again if we change
our mind about how many singular values to drop. In fact, we want to compute a singular
value decomposition (SVD) only once.
Let’s consider each case in turn.
Model 1: Least Squares (E = 0).
Deﬁne the SVD of the m ×n matrix K to be
K = UVT ,
where
• U has dimension m ×m and UT U = I, the identity matrix.
•  has dimension m × n, the only nonzeros are on the main diagonal, and they are
nonnegative real numbers σ1 ≥σ2 ≥··· ≥σn,
• V has dimension n ×n and VT V = I.
In Model 1, we determine f by solving the least squares problem
min
f
∥˜K˜nf −g∥2 ,
where
˜K˜n = U

˜n
0
0
0

VT .
We have already considered this problem in Section 5.6.2. There are (n −˜n) zero columns
in the middle matrix, so ˜n is a diagonal matrix with entries σ1,...,σ˜n. The solution to the
minimization problem is not unique if ˜n < n, but the solution of minimal norm is found by
taking
f ˜n = V

˜n−1
0
0
0

UT g.
(14.1)
(Here, there are (m −˜n) zero columns in the matrix following V.) Thus we can compute
different estimates of the solution, for various values of ˜n, without recomputing the SVD.
Which value of ˜n should we pick? One rule of thumb (called the discrepancy princi-
ple) is to choose the value of ˜n that makes the residual norm ∥g−K f ˜n∥close to its expected
value. If the errors in the data values g are independent and normally distributed with mean
zero and variance δ2, then this expected value is δ√m. To estimate the value δ2, other rules
of thumb are used. For example, for many ill-posed problems, the left singular vectors
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 182 Page number 172
cyan magenta yellow black
172
Chapter 14. Case Study: Blind Deconvolution: Errors, Errors Everywhere
corresponding to very small singular values are highly oscillatory, so they capture white
noise in the measured data. Therefore, if we assume that these components are entirely due
to noise, and if we believe that the noise has mean zero, we might estimate the variance by
computing the variance of the last few components ofg = UT g using the formula
δ2 ≈
1
m −ˆm +1
m
	
i= ˆm
ˆg2
i
for some value of ˆm close to m.
CHALLENGE 14.1.
Program the least squares algorithm and try it on the data of Figure 14.1 for various
values of ˜n. (The data can be found on the website.) The matrix K is 27 × 22, and we
assume that the true counts for the ﬁrst two and the last three bins are zero. Note how
ill-conditioned the original matrix K is (by recording κ(K) = σ1/σn).
Model 2: Total Least Squares (TLS)
If we allow both E and r to be nonzero, how can we solve the problem?
First we need a way to measure the size of these quantities. One reasonable way is to
use the Frobenius norm of the errors:
∥
 E
r 
∥2
F =
m
	
i=1
n
	
j=1
e2
ij +
m
	
i=1
r2
i .
(14.2)
(If we expect the errors e2
ij to be much different in size than the errors r2
i , then we might
want to use weights for each term in this expression, but for this case study we just leave
them equally weighted.)
Let’s rewrite K f ≈g as
 K
g 
f
−1

≈0.
Notice these facts:
• If this equation were exactly satisﬁed, then the columns of the matrix [K, g] would
be linearly dependent, so the rank of the matrix would be less than n +1. In this case
there would be at least one singular value equal to zero and [fT ,−1]T would be a
corresponding right singular vector.
• We need a matrix [E, r] to add to [K, g] to make
 K+E
g+r 
f
−1

= 0.
(14.3)

November 20, 2008 10:52
sccsbook
Sheet number 183 Page number 173
cyan magenta yellow black
Model 2: Total Least Squares (TLS)
173
• Among all such matrices [E, r], we need the one with smallest Frobenius norm.
Finding this matrix is a well-studied problem.
CHALLENGE 14.2.
Suppose we have the SVD of [K, g] =  U  VT . Assume that K has rank n and that
 vnn > vn+1,n+1 ̸= 0. Show that the solution to
min
E,r
||
 E
r 
||F,
subject to the constraint
 K+E
g+r 
f
−1

= 0,
is
 E
r 
= − σn+1 un+1 vT
n+1,
with

f
−1

= −
1
 vn+1,n+1
 vn+1,
where  un+1 is the (n +1)st column of  U and vn+1 is the (n +1)st column of  V.
Hint:
(a) First show that this solution satisﬁes the constraint and that the resulting || E
r ||F =
 σn+1.
(b) Show that ∥ UT A V∥F = ∥A∥F for any matrix A of size m ×(n +1).
(c) Then transform the problem to minimizing ∥[ E,  r]∥F subject to (  + E) f = 0 for some
vectors f and r and matrix  E. Solve the problem in this coordinate system, and show that
there is no solution that gives a value of the minimization function smaller than  σn+1.
If we want to truncate our model at ˜n < n, then the solution to the problem of mini-
mizing (14.2) subject to (14.3) becomes
f = −
1
∥ V22∥2 V12 VT
22,
where  V12 consists of rows 1 through n and columns ˜n + 1 through n + 1 of  V, and  V22
contains the last row of these columns of  V.
CHALLENGE 14.3.
Write a MATLAB function to solve Model 2 using this truncated technique for vari-
ous values of ˜n. The input values should be K, g, and a range of ˜n values. Include appro-
priate documentation, and use your function to solve our problem.
Finally, we are ready to answer our original question.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 184 Page number 174
cyan magenta yellow black
174
Chapter 14. Case Study: Blind Deconvolution: Errors, Errors Everywhere
POINTER 14.1. Further Reading.
This case study is related to the case study of Chapter 6, but previously the matrix K
was assumed to be known exactly.
Instead of using truncated SVD for regularization, we might use Tikhonov regular-
ization. This method is quite well studied for least squares problems [68], and for TLS
some analysis appears in a paper by Golub, Hansen, and O’Leary [61].
The standard reference for TLS is the book by Van Huffel and Vandewalle [147].
Fierro, Golub, Hansen, and O’Leary [48] give further information on the truncated TLS
algorithm used in Challenge 14.3. TLS is closely related to the errors-in-variables method
from statistics.
CHALLENGE 14.4.
Write a brief summary of the results you obtained using Model 1 and Model 2 to
solve the problem of Figure 14.1. Give your best estimate of the number of different peaks
(energy levels) in the original data ftrue, the relative heights of the peaks, and the centers
of the peaks. Make a convincing argument to justify your estimate and your choice of
parameters (δ and ˜n) for each method.
The total least squares formulation has given us a good tool for improving our solu-
tion estimate when we have errors in both the matrix and the right-hand side. In the next
case study we add constraints to try to further improve the estimate.

November 20, 2008 10:52
sccsbook
Sheet number 185 Page number 175
cyan magenta yellow black
Chapter 15 / Case Study
Blind
Deconvolution: A
Matter of Norm
We continue the spectroscopy problem from the previous case study, trying to reconstruct
a true spectrum from an observed one. Again we use blind deconvolution, but this time we
impose some constraints on the error matrix E, leading to a more difﬁcult problem to solve
but often a more useful reconstruction.
Recall that we have the counts of Figure 14.1, measured by a spectrometer, and we
model our system by the matrix equation (K+E) f = g+r, where E accounts for errors in
modeling the spectrometer’s blur and r accounts for errors in counts. The matrix entry kjℓ
is our estimate of the probability that a particle whose energy is in the interval [eℓ−1,eℓ] is
assigned to bin j ( j, ℓ= 1,...,nb).
We assume that there is signiﬁcant error in both g and K, but we note that in our data,
the properties of each bin are the same, so that the rows of K have a pattern: for example,
if the m ×n matrix K were 5×5, then we would notice that
K =
⎡
⎢⎢⎢⎣
k5
k4
k3
k2
k1
k6
k5
k4
k3
k2
k7
k6
k5
k4
k3
k8
k7
k6
k5
k4
k9
k8
k7
k6
k5
⎤
⎥⎥⎥⎦,
so that there would be only m + n −1 = 9 distinct entries in K. A matrix of this form is
called a Toeplitz matrix and it is determined by the entries in its ﬁrst row and column.
Under this assumption, it might make sense to assume that the error matrix E also has this
same structure, and therefore also depends on m + n −1 parameters instead of mn. We
gather these parameters in a vector callede.
Using the Euclidean Norm
In the case study of Chapter 14, we minimized (14.2) or, equivalently, we solved
min
E, f
1
2∥E∥2
F + 1
2∥r∥2
2,
(15.1)
175
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 186 Page number 176
cyan magenta yellow black
176
Chapter 15. Case Study: Blind Deconvolution: A Matter of Norm
where
−r = g−(K+E) f.
(15.2)
With our new constraint that E be Toeplitz, our old solution is not feasible. So now we
minimize the function, subject to the constraint that E be Toeplitz, over all choices of f and
e.
Our goal is to ﬁnd an effective algorithm to solve this problem, and we do this in
several steps. The ﬁrst is to derive a useful alternative expression for the matrix-vector
product E f.
CHALLENGE 15.1.
Show that if E is Toeplitz then E f can be written as Fe, where F is a matrix whose
entries depend on the entries in the vector f. In other words, ﬁnd a matrix F so that E f =
Fe.
Let’s use Newton’s method (See Section 9.2) to solve our minimization problem.
Recall that if we are minimizing some function s(x), then the Newton direction is the
solution p to the linear system
H(x)p = −∇s(x),
where ∇s(x) is the gradient of s with respect to x, and H(x) is the Hessian matrix, contain-
ing the second derivatives: hij (x) = ∂2s(x)/∂xi∂xj. Let’s derive a formula for p.
CHALLENGE 15.2.
Derive the Newton direction for (15.1). To do this, use the deﬁnitions of E (in terms
ofe ) and r (equation (15.2)), and then differentiate the function in (15.1) with respect toe
and f.
Although the formula from Challenge 15.2 is mathematically correct, it is not the
best computationally, and Challenge 15.3 provides a better alternative.
CHALLENGE 15.3.
Show that this Newton direction is approximately the same as the solution to the least
squares problem
min
e,f


F
K+E
D
0

e
f

+

−r
De

2
,
where D is a diagonal matrix of size (m + n −1) × (m + n −1) with entries equal to the
square roots of 1,2,...,n,...,n,n −1,...,1. (In particular, the least squares solution is very
close to the Newton direction if the model is good, so that ∥r∥is small.)
If we were to solve problem (15.1) using our spectroscopy data, the solution would be
quite contaminated by error. (That is why we truncated the SVD when solving the problem

November 20, 2008 10:52
sccsbook
Sheet number 187 Page number 177
cyan magenta yellow black
Using Other Norms
177
in the case study of Chapter 14.) Therefore, we make one further modiﬁcation to obtain a
useful model: we solve the problem
min
E,f
1
2∥E∥2
F + 1
2∥r∥2
2 + 1
2λ2∥f∥2
2,
subject to the constraint that E be Toeplitz. The last term is a Tikhonov regularization
term (as in the case study of Chapter 6), with a ﬁxed parameter λ, added on to control the
size of f. In this case, the approximate Newton direction from Challenge 15.3 is computed
from the solution to the least squares problem
min
e,f

⎡
⎣
F
K+E
D
0
0
λI
⎤
⎦

e
f

+
⎡
⎣
−r
De
λf
⎤
⎦

2
.
Now we put these pieces together to solve our problem.
CHALLENGE 15.4.
Use a variant of Newton’s method to solve our Toeplitz-constrained problem in a
stable and efﬁcient way, implementing it in a MATLAB function [f,ehat,r,itn] =
stls(K,g,lambda,tol). Use the least squares problem above to compute the ap-
proximate Newton direction. Start the iteration withe = 0 and f equal to the least squares
solution. Stop the iteration when the norm of the approximate Newton step is smaller than
tol, and set itn to the number of iterations. Provide documentation for your function.
Use it on the data from Figure 14.1, setting λ = 0.06 and tol = 10−3. Plot the solution,
and print the residual norm, the solution norm, and the number of iterations.
Using Other Norms
If the errors in our data are not normally distributed, then there are several reasonable al-
ternatives to the choice of the Euclidean norm for the minimization function. For example,
instead of minimizing
1
2∥E∥2
F + 1
2∥r∥2
2 = 1
2


r
De

2
2
,
we might instead minimize


r
De

p
,
(15.3)
where, if p = 1 the norm is deﬁned as the sum of the absolute values of the components,
and if p = ∞, the norm is the maximum of the absolute values of the components. (See
Pointer 2.1.) Either of these choices has the effect of reducing the effects of outliers in our
measurements.
To derive an algorithm to solve this problem for p = 1 or ∞, and to match our
previous algorithm when p = 2, we reason this way. We need to satisfy the constraint
Fe = E f,
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 188 Page number 178
cyan magenta yellow black
178
Chapter 15. Case Study: Blind Deconvolution: A Matter of Norm
even after we replace f by f +f ande by e, so we require
(F+F)(e+e) = (E+E)(f +f),
where E is formed from e and F is formed from f so that Fe = Ef and Fe =
Ef. This means that
Fe = Ef.
Now let’s examine the residual after we replace f by f +f ande bye+e:
rnew = g−(K+E+E)(f +f)
= g−(K+E)f −Ef −(K+E)f −Ef.
If both f and e are small, then the last term is negligible, and we can approximate
rnew ≈r −Fe−(K+E)f,
so that our minimization function (15.3) is approximated by


F
K+E
D
0

e
f

+

−r
De

p
.
So, to compute our step, we need to minimize a function of this form, and our next task is
to develop an algorithm that does this.
CHALLENGE 15.5.
(a) Show that when p = 1, minimizing

⎡
⎣
F
K+E
D
0
0
λI
⎤
⎦

e
f

+
⎡
⎣
−r
De
λf
⎤
⎦

p
over all choices of f and e is equivalent to solving the linear programming problem
min
e,f,¯σ
¯σ =
m
	
i=1
¯σ1i +
q
	
i=1
¯σ2i +
n
	
i=1
¯σ3i
subject to
−¯σ1
≤
Fe+(K+E)f −r
≤
¯σ1,
−¯σ2
≤
De+De
≤
¯σ2,
−¯σ3
≤
λf +λf
≤
¯σ3,
where
¯
σ1 ∈Rm×1 and
¯
σ2 ∈Rq×1, and
¯
σ3 ∈Rn×1.
(b) Derive a similar linear programming problem that determines e and f when p = ∞.
Let’s see how the choice of norm affects our computed solution.

November 20, 2008 10:52
sccsbook
Sheet number 189 Page number 179
cyan magenta yellow black
Comparing Our Results
179
CHALLENGE 15.6.
Use a variant of Newton’s method to solve the problem when p = 1, and implement
it in a MATLAB function [f,ehat,r,itn] = stln1(K,g,lambda,tol). Use
the solution to the linear programming problem as an approximate Newton direction. Start
the iteration with e = 0 and f equal to the vector of all ones. Stop the iteration when the
norm of the approximate Newton step is smaller than tol, and set itn to the number of
iterations. Use it on the data from Figure 14.1, setting λ = 0.06 and tol = 10−3. Plot the
solution, and print the residual norm, the solution norm, and the number of iterations.
Repeat for the case p = ∞.
Comparing Our Results
Recall that our goal is to reconstruct the spectrum of the particles fed into the spectrome-
ter. Take some time now to compare the results we have obtained using various problem
formulations.
CHALLENGE 15.7.
Results for various values of λ are shown in Figures 15.1 (stls from Challenge
15.4) and 15.2 (stln from Challenge 15.6). The red dots indicate the true spectrum.
Compare these results with those in the case study of Chapter 14 by answering these two
questions:
• How does the quality of results compare?
• How does the amount of work compare?
Our models in this case study use a variety of standard tools from matrix decompo-
sitions and optimization. Using these tools effectively, though, requires some cleverness in
reformulating the problem and choosing methods appropriate to the data.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 190 Page number 180
cyan magenta yellow black
180
Chapter 15. Case Study: Blind Deconvolution: A Matter of Norm
1
2
3
4
5
−1
0
1
2
3
4
2−norm, lambda =  0.02
energy
particle count
1
2
3
4
5
−1
0
1
2
3
4
2−norm, lambda =  0.06
energy
particle count
1
2
3
4
5
−1
0
1
2
3
4
2−norm, lambda =  0.16
energy
particle count
1
2
3
4
5
−1
0
1
2
3
4
2−norm, lambda =  0.40
energy
particle count
Figure 15.1. Results from the structured total least squares algorithm for various
values of λ.

November 20, 2008 10:52
sccsbook
Sheet number 191 Page number 181
cyan magenta yellow black
Comparing Our Results
181
1
2
3
4
5
0
1
2
3
4
5
6
Infinity norm, lambda =  0.00
energy
particle count
1
2
3
4
5
−2
−1
0
1
2
3
4
Infinity norm, lambda =  0.06
energy
particle count
1
2
3
4
5
−1
0
1
2
3
4
1−norm, lambda =  0.02
energy
particle count
1
2
3
4
5
0
1
2
3
4
1−norm, lambda =  0.06
energy
particle count
Figure 15.2. Results from the structured total least norm algorithm, using the
1-norm and the ∞-norm, for various values of λ.
POINTER 15.1. Further Reading.
MATLAB’s linprog can be used to solve the linear programming problems.
Choices of vector norms are discussed in many elementary textbooks, but Ortega
[119] gives a particularly nice discussion.
The use of regularization plus norm choice to solve our problem is discussed by
Pruessner and O’Leary [126]. References to earlier work using regularization or norm
choice can be found in that paper, too.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 192 Page number 182
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 193 Page number 183
cyan magenta yellow black
Unit IV
Monte Carlo Computations
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 194 Page number 184
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 195 Page number 185
cyan magenta yellow black
185
In a Monte Carlo method, the desired answer is a quantity in a stochastic model, and
it is estimated by random sampling of the model. Applications of Monte Carlo methods
range from estimating integrals, to minimizing difﬁcult functions, to simulating complex
systems. We have already seen its use in sensitivity analysis in Chapters 2, 12, and 13.
Our plan is to ﬁrst discuss some basic statistical principles underlying Monte Carlo
methods. Then we consider a variety of uses of these methods. Monte Carlo methods
are also useful for minimizing nonconvex functions and for estimating distributions, and
we illustrate these uses in Chapter 17. In Chapter 18, we develop Monte Carlo methods
for estimating multidimensional integrals when conventional methods are too expensive.
Finally, in Chapter 19, we develop and analyze a stochastic model for the spread of an
epidemic.
BASICS: To understand this unit, the following background is helpful:
• Statistics: Past experience with random sampling and probability distributions is
very helpful. See a basic statistics textbook such as [98] or a numerical book such as
[71, Chap. 13].
MASTERY: After you have worked through this unit, you should be able to do the follow-
ing:
• Write the probability density function for a given distribution.
• Distinguish between random numbers and pseudorandom numbers.
• Compute the mean and variance of a distribution.
• State the two properties that deﬁne a probability density function.
• State and use the central limit theorem.
• Explain why Monte Carlo algorithms are used for optimization problems and for
counting problems.
• Explain or write a MATLAB algorithm to solve a problem like the traveling sales-
person problem using the Metropolis algorithm (simulated annealing).
• Explain or write a MATLAB algorithm to implement the KRS algorithm for estimat-
ing the number of dimer arrangements on a lattice.
• Recognize when a product rule can be applied to a multidimensional integral.
• Write a MATLAB algorithm to estimate an integral using nested calls to a one-
dimensional integrator.
• Write a MATLAB algorithm for Monte Carlo integration.
• Write a MATLAB algorithm for Monte Carlo integration using importance sampling.
• State and use the formulas for mean and variance of the estimates produced by Monte
Carlo integration.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 196 Page number 186
cyan magenta yellow black
186
• Generate quasi-random numbers and explain their use.
• Set up Monte Carlo simulations of systems (such as epidemics).
• Analyze a Markov chain using its transition matrix to determine a stationary vector.

November 20, 2008 10:52
sccsbook
Sheet number 197 Page number 187
cyan magenta yellow black
θ
Chapter 16
Monte Carlo
Principles
In a Monte Carlo method, the desired answer is a quantity in a stochastic (i.e., random)
model, and it is estimated by random sampling of the model.
For example, suppose we have a cube, with the sides numbered 1 to 6. We might toss
the cube 120 times, observe which side comes up on top each time, and study whether the
sides each occur with frequency 1/6. These 120 random samples would not deﬁnitively
answer the question of whether the frequencies are equal, since, for example, it is possible
that one side would come up 120 times in a row, even if an inﬁnitely long experiment would
show that the frequencies are equal. Nevertheless, if we repeat the experiment many times,
the proportion of tosses in which a given side comes up on top gives us a good estimate of
the probability that the side would come up on top in a single toss.
As a second example, if we have a “black box” that takes a number between 0 and 1
as input and emits a number between 0 and 1 as output, we could feed the box m numbers
and observe the m outputs of the box to develop insight into the hidden process.
In the second example, we could use random or non-random inputs to the box. There
is an important difference between Monte Carlo methods, which estimate quantities us-
ing random samples for the inputs, and pseudo-Monte Carlo methods, which use input
samples that might appear to be random but actually are more systematically chosen. We
study random sampling in Section 16.1, and pseudo-random sampling in Section 16.4.
In some sense, all practical computational methods involving randomization are pseudo-
Monte Carlo, since “random” number generators implemented on machines are generally
not truly random. We use the term Monte Carlo even for samples that are generated using
pseudorandom numbers generated by a computer program.
In this chapter, we develop the basic statistical principles needed to understand ran-
dom and pseudorandom numbers and their generation. It is important to remember that
Monte Carlo methods are (at least in some sense) methods of last resort. They are generally
quite expensive and only applied to problems that are too difﬁcult to handle by determin-
istic (nonstochastic) methods.
187
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 198 Page number 188
cyan magenta yellow black
188
Chapter 16. Monte Carlo Principles
θ
Figure 16.1. A spinner that generates uniform random numbers θ in the interval [0,2π).
16.1
Random Numbers and Their Generation
We generate random numbers by taking samples from a collection of numbers. For exam-
ple, suppose we put n cards, numbered 1 to n, in a box and choose one at random. After we
record the resulting number, we put the card back in the box. We have generated a random
number that is uniformly distributed among the values {1,2,...,n}, since the probability
(1/n) of choosing one number is the same as that for any other number.
If we add k cards to the box, all numbered 1, then our distribution becomes nonuni-
form: the probability of choosing 1 is now (k +1)/(n +k) and the probability of choosing
any of the other numbers is 1/(n +k).
The most interesting random systems are those whose outcomes are numbers in some
interval of the real line. For example:
• Make a spinner, as in Figure 16.1, by anchoring a needle at the center of a circle.
Draw a radius line on the circle. Spin the needle, and measure the angle it forms
with the radius line. You obtain random numbers that are uniformly distributed on
the interval [0,2π).
• If, on average, a radioactive substance emits α-particles every μ seconds, then the
time between two successive emissions has the exponential distribution with mean
μ. (This is a special case of the gamma distribution.)
• The normal distribution, whose graph of probabilities is bell-shaped, is a good
model in many situations:
– The pattern formed by leaves that fall from a symmetric tree is approximately
normal, so measuring the distance from the trunk gives a sample from a uni-
variate normal distribution. There are many more leaves close to the trunk than

November 20, 2008 10:52
sccsbook
Sheet number 199 Page number 189
cyan magenta yellow black
16.1. Random Numbers and Their Generation
189
far away. The two coordinates of a leaf, using the tree trunk as the origin, give
a sample from a bivariate normal distribution.
– The IQ measure of intelligence was constructed so that the measures are nor-
mally distributed.
– Many physical characteristics of plants and animals (height, weight, etc.) are
approximately normally distributed.
– The velocity distribution of molecules in a thermodynamicequilibrium (Maxwell–
Boltzmann distribution) is normal [113], so measuring the velocity of a molecule
would give a sample from a normal distribution.
– Measures of psychological variables such as reading ability, introversion, job
satisfaction, and memory are approximately normal.
– Predicting probabilities in gambling was DeMoivre’s (1667–1754) motivation
in deﬁning the normal distribution [98].
We can characterize a set of random samples by a set of numbers (moments) derived
from them. The ﬁrst two moments, the mean and the variance, are the most important.
The mean or average value of a set of samples {xi}, i = 1,...,n, is
μn ≡1
n
n
	
i=1
xi,
and the variance of the set of samples measures the variation of the samples from the mean
value as8
σ 2
n ≡1
n
n
	
i=1
(xi −μn)2 .
The mean and variance of the set of samples are estimates of the mean and variance of
the distribution from which they were drawn, and we discuss these quantities in the next
section. If the true mean μ of the distribution is known, then the variance of the distribution
is estimated by
σ 2
n ≡1
n
n
	
i=1
(xi −μ)2.
CHALLENGE 16.1.
Compute the mean and variance of the following set of random samples: {1,2,5,8,6,2}.
8Dividing by n −1 is appropriate when the samples are from a normal distribution, since this gives the
best unbiased estimator of the variance of the distribution; otherwise, we divide by n. MATLAB’s function
std computes both of these variants.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 200 Page number 190
cyan magenta yellow black
190
Chapter 16. Monte Carlo Principles
16.2
Properties of Probability Distributions
The particular system from which random samples are drawn is characterized by its non-
negative probability density function f (x). The domain  of the function is the set of
possible values that could be obtained by taking random samples of the function. The range
of the function is a subset of the nonnegative numbers. The value

α
f (x)dx
is the probability that a sample from this distribution is in the set deﬁned by α. (Replace
the integral by a summation if the domain is discrete.) Because of these properties, we see
that


f (x)dx = 1.
(In the discrete domain case, the sum of the probabilities is 1.)
For example, for our n cards in the box above, the domain is  = {1,2,...,n} and
f (x) = 1/n for x = 1,...,n. For our spinner, the domain is  = [0,2π) and f (x) = 1/(2π).
The mean μ of a distribution (also known as the expected value) is the sum of all
possible values, weighted by their probabilities. In other words, it is the expected value we
would compute by averaging the values obtained for the sample mean if we took a large
number of very large sets of samples. Similarly, the variance σ 2 of the distribution is
estimated by the sample variances. The mean and variance of the distribution are deﬁned
by
μ =


x f (x)dx ,
σ 2 =


(x −μ)2 f (x)dx .
Again, for discrete distributions, we replace the integral by a summation. So for our
n cards in the box,
μ =
n
	
i=1
i 1
n = n +1
2
,
σ 2 =
n
	
i=1

i −n +1
2
2 1
n = (n +1)(n −1)
12
.
We give the distribution functions for three continuous distributions mentioned in our
examples:
• The uniform distribution over the interval [0,m] has probability density function
f (x) = 1
m .
Its mean and variance are
μ =
 m
0
x
m dx = m
2 , σ 2 =
 m
0
1
m
!
x −m
2
"2
dx = m2
12 .

November 20, 2008 10:52
sccsbook
Sheet number 201 Page number 191
cyan magenta yellow black
16.3. The World Is Normal
191
• The exponential distribution with parameter μ has
f (x) = 1
μe−x/μ
for x ∈[0,∞). Its mean is μ and its variance is σ 2 = μ2.
• The normal distribution with parameters μ and σ has
f (x) =
1
√
2πσ 2 e−(x−μ)2/(2σ 2)
for x ∈(−∞,∞). Its mean is μ and its variance is σ 2.
A bit of practice makes the ideas of mean and variance more clear.
CHALLENGE 16.2.
Suppose we have a box with 8 cards numbered 1 through 8, and 2 cards with the num-
ber 10 written on them. Compute the mean and variance of the distribution corresponding
to drawing a card from the box at random and recording the resulting number.
CHALLENGE 16.3.
Verify that f (x) = 3x2 is a probability density function on the domain [0,1]. (In
other words, verify that it is nonnegative and that its integral is equal to 1.) Find μ and σ 2.
16.3
The World Is Normal
The central importance of the normal distribution in statistics is due to two facts: the fre-
quency of its occurrence in nature (See the examples in Section 16.1), and our ability to
transform any set of observations into a set from a distribution that is approximately normal.
This latter fact is summarized in the central limit theorem: Let f (x) be any distribution
with mean μ and (ﬁnite) variance σ 2. Take a random sample of size n from f (x), and call
the mean of the sample μn. Deﬁne the random variable yn by
yn = √n μn −μ
σ
.
Then the distribution for yn approaches the normal distribution with mean 0 and variance
1 as n increases.
Therefore, even if we know nothing about a distribution except its mean and variance,
we can use samples from it to construct samples from a distribution that is near normal.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 202 Page number 192
cyan magenta yellow black
192
Chapter 16. Monte Carlo Principles
CHALLENGE 16.4.
Suppose the random number generator y = randmy(n) returns n random num-
bers from a distribution with mean 2 and variance 5. Using the central limit theorem, write
a random number generator that uses 1000 numbers generated by randmy to produce a
single random sample taken from an approximately normal distribution with mean 0 and
variance 1.
16.4
Pseudorandom Numbers and Their Generation
In principle, we could generate random samples as discussed in Section 16.1. For example,
when we wanted a uniform distribution, we could build a spinner and play with it for a
while, writing down our list of samples.
In practice, when the random numbers are used in computer software, this does not
work well:
• The samples are irreproducible; if someone else wanted to use the software, they
would get a different result and not know whether it was because of their different
sequence of random numbers or because of a bug.
• Computers run through enormous quantities of random numbers, and it is just not
feasible to generate them manually.
• Sometimes we are very unlucky and generate a long string of random numbers that
are not well-distributed.
Because of this, we usually use pseudorandom numbers in computer software.
Pseudorandom numbers are generated by the computer using a deterministic (i.e., repro-
ducible) procedure and appear to be random, in the sense that the mean, variance, and other
properties of sequences of n samples match what we would expect to obtain from a random
process. But the pseudorandom numbers actually cycle; i.e., if we ask for a long enough
sequence, we see periodicity.
Pseudorandom number generators on computers usually use a seed (a number) to
determine where in the cycle to begin. Thus, if other people want to reproduce our results,
they simply use the same seed.
It is fairly cheap to generate pseudorandom numbers that appear to be uniformly
distributed, and in that sense a pseudorandomnumber generator for the uniform distribution
is easy to write, but it is very, very difﬁcult to write a good one. Don’t try to write your own
unless you have a month to devote to it. Luckily, many good ones are readily available.
Samples from other distributions (for example, the normal or exponential distribu-
tions) are usually generated by taking two or more uniformly distributed pseudorandom
numbers and manipulating them using functions such as sin, cos, and exp. This is much
more costly, but let’s consider a simple example that will be useful to us in the simulated
annealing algorithm presented in Chapter 17.

November 20, 2008 10:52
sccsbook
Sheet number 203 Page number 193
cyan magenta yellow black
16.5. Mini Case Study: Testing Random Numbers
193
POINTER 16.1. The Overhead of a Function Call.
Generating n random numbers in MATLAB is very slow if we do it one at a time:
for i = 1:n
z = rand(1);
(Comment: Use z in the calculations.)
end
This is because the overhead of starting up the rand function is quite high. We can improve
speed (at the expense of storage) with this simple modiﬁcation:
zrand = rand(n, 1);
for i = 1:n
z = zrand(i);
(Comment: Use z in the calculations.)
end
CHALLENGE 16.5.
Write MATLAB statements using the function rand, which generates a sample uni-
formly distributed in [0,1], to generate a random number from the following distribution:
The probability that the number is 0 is 0.6.
The probability that the number is 1 is 0.4.
In other words, if f (x) is the probability density function, it has domain {0,1} with f (0) =
0.6 and f (1) = 0.4 .
16.5
Mini Case Study: Testing Random Numbers
The program demorand.m from the website generates pseudorandom numbers using
rand for the uniform distribution and randn for the normal distribution. It then plots
histograms of these samples, showing the number of samples in each of 100 small inter-
vals. This is a very simple test for random number generators. We expect that for the
uniform distribution, the number of samples in each interval is approximately equal. For
the normal distribution, we expect an approximately bell-shaped histogram. More rigorous
tests of random numbers can be found in the references in Pointer 16.2.
The results of our simple test are shown in Figure 16.2. You can repeat the test with
different seeds to judge the performance of rand and randn.
Now that we understand the basic principles behind pseudorandom numbers and their
generation, we’ll focus in the following case studies on how random numbers help us solve
problems in computational science. We apply Monte Carlo methods to function minimiza-
tion, discrete optimization, and counting in Chapter 17. Then in the case study of Chapter
18 we study their use in multidimensional integration, and we apply them to epidemic
simulation in Chapter 19.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 204 Page number 194
cyan magenta yellow black
194
Chapter 16. Monte Carlo Principles
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
5
10
15
20
25
Histogram of 1200 uniform random numbers
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
200
400
600
800
1000
1200
Histogram of 100000 uniform random numbers
−4
−3
−2
−1
0
1
2
3
4
0
5
10
15
20
25
30
35
40
Histogram of 1200 normal random numbers
−5
−4
−3
−2
−1
0
1
2
3
4
5
0
500
1000
1500
2000
2500
3000
3500
4000
Histogram of 100000 normal random numbers
Figure 16.2. Histograms, plotting the distribution of random samples from rand
and randn.
POINTER 16.2. Further Reading.
A whole course could be taught on how to generate pseudorandom numbers. The
book by Knuth [91] is quite enlightening, talking about the generation of pseudorandom
numbers as well as how to test whether a program is generating pseudorandom numbers
that are a good approximation to random. See also [72]. The standard functions in many
languages (including MATLAB) for generating pseudorandom normal and exponentially
distributed sequences are adequate but not the best. With some searching and testing, you
can ﬁnd better ones when needed.
“True” random number generators, in contrast to pseudorandom number generators,
can be found at [66]. They are based on atmospheric noise.

November 20, 2008 10:52
sccsbook
Sheet number 205 Page number 195
cyan magenta yellow black
Chapter 17 / Case Study
Monte Carlo
Minimization and
Counting: One, Two,
. . . , Too Many
(coauthored by Isabel Beichl and Francis Sullivan)
Given the choice between an electrical pump and a hand pump for getting water out
of a well, most people would choose the electric. Yet the hand pump is quite reliable
and can be used when other sources of power are not available. Similarly, Monte Carlo
methods are remarkably versatile algorithms for solving difﬁcult numerical problems when
other methods are not practical. We focus in this case study on three uses of Monte Carlo
methods: for function minimization, for discrete optimization, and for counting.
Function Minimization
A convex function f (x) has a unique minimum that can be found using a variety of meth-
ods, including Newton’s method and its variants, conjugate gradients, and (if derivatives
are not available) pattern search algorithms. (See Chapter 9.) For functions that are non-
convex, such as that in Figure 17.1, these algorithms ﬁnd a local minimizer such as x1 but
are not guaranteed to ﬁnd the global minimizer x∗.
Minimization Using Monte Carlo Techniques
Monte Carlo methods provide a good means for generating starting points for optimization
problems that are nonconvex. In its simplest form, a Monte Carlo method generates a
random sample of points in the domain of the function. We use our favorite minimization
algorithm starting from each of these points, and among the minimizers found, we report
the best one. By increasing the number of Monte Carlo points, we increase the probability
that we ﬁnd the global minimizer.
195
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 206 Page number 196
cyan magenta yellow black
196
Chapter 17. Case Study: Monte Carlo Minimization and Counting
x
f(x)
x1
x2
x4
x5
x* =x3
x
Figure 17.1. A standard minimization algorithm might ﬁnd the minimum f (x1) if
we start at ×, but Monte Carlo minimization seeks the global minimum f (x3).
This method can be improved by using any extra information we have about the
function f (x) that we are minimizing. For example, suppose we know a Lipschitz constant
L for our function, so that for all x and y in the domain,
| f (x)−f (y)| ≤L∥x −y∥.
To make the example speciﬁc, suppose that L = 1 and the domain is just the real line. If
we know that f (1) = 2 and f (4) = 0, then using the Lipschitz inequality with x = 1, we
obtain | f (1)−f (y)| ≤(1)||1−y||, or |2−f (y)| ≤|1−y|. This says that f (y) is bounded
below by 0 for y between −1 and 3. Therefore, our global minimizer cannot lie here. This
saves us the work of generating more points in this interval.
In the next challenge, we experiment with Monte Carlo minimization.
CHALLENGE 17.1.
Consider the function myf.m (on the website), with domain 0 ≤x ≤7.
(a) Write a function to generate 500 uniformly distributed starting points on the interval
[0,7] and use your favorite minimizer (perhaps fmincon), starting from each one, to ﬁnd
a local minimum. Make a graph that shows which starting points result in which local
minimizer. (There are many ways to do this; just make sure that your graph displays the
information clearly.)
(b) L = 98.5 is a Lipschitz constant for the function myf.m. Try to speed up the mini-
mization using this information. Document the changes to your function and compare the
performance of the two methods.
(c) (Extra)
Try Monte Carlo minimization on your favorite function of n variables for
n > 1.
Minimization Using Simulated Annealing
Suppose we have a box of particles that have been allowed to slowly cool. Then we expect
the potential energy of the system to be small. For example, if we make ice in a freezer,

November 20, 2008 10:52
sccsbook
Sheet number 207 Page number 197
cyan magenta yellow black
Function Minimization
197
POINTER 17.1. Simulated Annealing.
The simulated annealing algorithm has a long history. The basic idea ﬁrst appeared
in the literature in a paper coauthored by Nicholas Metropolis in 1953, so the algorithm
sometimes bears his name.
the crystal structure that results is one that has a lower potential energy than most of the
alternatives. If we drop the temperature too fast, then the system can easily get stuck in a
conﬁguration that has a higher potential energy, and we often see crack lines in ice cubes
resulting from this. The physical process of slow cooling is called annealing, and with luck
it can lead to something close to a perfect ice cube. The annealing process works because
if the temperature is high, then each particle has a lot of kinetic energy and can easily move
to positions that increase the potential energy of the system. This enables a system to avoid
getting stuck in conﬁgurations that are local minimizers but not global ones. But as the
temperature is decreased, it becomes less likely that a particle makes a move that gives a
large increase in energy. This is illustrated in Figure 17.2. This enables a system to do the
ﬁne-tuning that produces an optimal ﬁnal conﬁguration.
This motivates an algorithm: if we want to minimize some function other than energy,
can we simulate this annealing process? We need some artiﬁcial deﬁnition of temperature,
a means of generating a new conﬁguration and deciding whether to keep it, and also a
cooling schedule for reducing the temperature. One way to implement the algorithm is
shown in Algorithm 17.1. Notice that the accept/reject decision can be made in a way
similar to that used in Challenge 16.5. Let’s see how simulated annealing works.
Algorithm 17.1 Simulated Annealing
Given an initial point x, initialize T to some large number and choose a number α be-
tween 0 and 1 and a positive number ϵ close to 0.
while T > ϵ,
Generate a random move from the current x to a newx.
If t ≡f (x)−f (x) < 0, then our new point improves the function value and we accept
the move, setting x =x.
If the function value did not improve, then we accept the move, setting x =x, with
probability e−t/T , where T is the current temperature. With probability 1 −e−t/T
we reject the move and leave x unchanged.
Decrease the temperature, replacing T by αT .
end
CHALLENGE 17.2.
Use the simulated annealing algorithm to minimize myf.m. Experiment with various
choices of T, α, and ϵ. Describe your experiment and the conclusions you can draw about
how to choose parameters to make the method as economical and reliable as possible.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 208 Page number 198
cyan magenta yellow black
198
Chapter 17. Case Study: Monte Carlo Minimization and Counting
x
f(x)
x
x
Figure 17.2. In simulated annealing, we allow moves that increase the function
value, such as that illustrated by the shorter arrow. At high temperature, such moves are
likely to be accepted, while at low temperature they are likely to be rejected. At high
temperature, we also might allow longer moves (horizontally), such as that illustrated by
the left-pointing arrow, and these two features can enable us to escape from valleys that do
not contain the global minimum.
Note that although the simulated annealing algorithm is slow, it has two virtues:
• Compared to standard minimization algorithms, it gives a better probability of ﬁnd-
ing a global rather than a local minimizer.
• It does not require derivative values for f . In fact, it does not even require f to be
differentiable.
The art of the method is determining the probability function and the temperature sequence
appropriate to the speciﬁc problem.
Minimization of Discrete Functions
There are many optimization problems that are simple to state but difﬁcult to solve. An
example is the traveling salesperson problem (TSP). This person needs to visit n cities
exactly once and wants to minimize the total distance traveled and ﬁnish the trip at the
starting point. To solve the problem, we need to deliver the permutation of the list of cities
that corresponds to the shortest total distance traveled.
If, for deﬁniteness, we specify the ﬁrst city, then among the (n −1)! permutations,
we want to choose the best. This is an enormous number of possibilities for moderate
values of n, and it is not practical to test each of them. Therefore, an approximate solution
is often found either by generating random permutations and choosing the best (a Monte
Carlo algorithm), or by using simulated annealing.

November 20, 2008 10:52
sccsbook
Sheet number 209 Page number 199
cyan magenta yellow black
An Example of Monte Carlo Methods for Counting
199
POINTER 17.2. Uses of Statistical Sampling.
Choosing a random sample of reasonable size and using it to estimate the exact
counts of a much larger population has a long history in science, but it is even more widely
used in commerce and public policy: Monte Carlo samples are the basis for opinion polls,
census methodologies, trafﬁc volume surveys, and for many other information estimates.
One step of a simulated annealing algorithm for TSP might look like this:
Start with an initial ordering of cities and an initial temperature T .
Randomly choose two cities.
if interchanging those cities decreases the length of the tour then
interchange them!
else
Interchange them with a probability that is an increasing function of temperature and
a decreasing function of the change in tour length.
end
Decrease the temperature.
Let’s experiment with Monte Carlo and simulated annealing solutions to TSP. One
speciﬁc temperature sequence, the log cooling schedule, is discussed in the answer to the
next challenge.
CHALLENGE 17.3.
(a) MATLAB provides a naïve Monte Carlo solution algorithm for the TSP. Given an or-
dering of the cities, it randomly generates a pair of cities and interchanges them if the inter-
change lowers the total distance. Experiment with the demonstration program travel.m
and display the program using type travel to see how this works.
(b) Write a program for simulated annealing on the TSP problem and compare its perfor-
mance with that of the algorithm of (a).
An Example of Monte Carlo Methods for Counting
Counting is so simple that we learned it as a young child. What could be so difﬁcult about
counting that would lead us to use Monte Carlo methods? It all depends on how many
things we are asked to count!
Consider the lattice of Figure 17.3, and suppose it is the lattice of a crystal contain-
ing two types of molecules: dimers, which ﬁll two adjacent sites, and monomers, which
occupy only one site. Deﬁne C(k) to be the number of distinct arrangements of k dimers
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 210 Page number 200
cyan magenta yellow black
200
Chapter 17. Case Study: Monte Carlo Minimization and Counting
Result of add
Result of delete
Result of swap
Figure 17.3. Upper left: a lattice of 6 dimers (red) and 23 monomers (blue), used
to illustrate the add, delete, and swap operations. Upper right: adding a dimer in row 1.
Bottom left: deleting a dimer in row 3. Bottom right: swapping a horizontally oriented
dimer in row three for a vertical one.
on the lattice. (Clearly C(0) = 1 and C(k) is nonzero only if k is an integer between 0
and half the number of sites in the lattice.) This function C(k) gives the coefﬁcients of the
generating function for the problem.
For small lattices, we actually can count all the arrangements, and, in fact, there
are analytic formulas for C(k) for two-dimensional lattices. For many three-dimensional
lattices, though, the function is not known exactly and computing it by counting all of the
possibilities is too expensive. Therefore, Monte Carlo methods are used to estimate it.
The basic idea is to obtain a random arrangement of dimers, assume that all other
sites are occupied by monomers, determine the number of dimers k, and add one to the
count of occurrences of k dimers. We repeat this process as long as we can. We might ﬁnd,
for example, that we had 0 dimers in 5 of our trials and 3 dimers in 52 trials. Then, since
we know that there is only 1 arrangement of 0 dimers on the lattice, our best guess at the
number of arrangements of 3 dimers is 52/5 = 10.4.
The difﬁculty is in randomly generating acceptable arrangements of dimers, ones
in which the dimers do not overlap. In order to avoid generating mostly unacceptable
arrangements, algorithms usually start with an acceptable arrangement and make a small
change to it. The trouble with this is that the two arrangements are highly correlated, and
therefore our estimate can have high variance. To ﬁx this, we can make a large number of
changes, enough so that the two arrangements are no longer correlated, before we record a
count. One such algorithm is due to Kenyon, Randall, and Sinclair (KRS) and is given in
Algorithm 17.2.

November 20, 2008 10:52
sccsbook
Sheet number 211 Page number 201
cyan magenta yellow black
An Example of Monte Carlo Methods for Counting
201
POINTER 17.3. Randomness vs. Correlation.
At each iteration of the KRS algorithm, either nothing happens or a dimer is added,
deleted, or moved. If it has been long enough since our last recording, then the resulting
conﬁguration is added to the record. Why don’t we record every conﬁguration?
In order to get good estimates of the counts, the samples that we record must be
(almost) uncorrelated. In other words, the probability of getting a particular sample must
not depend on the value of the preceding sample.
It is not correct to say that we skip in order to get random samples. Some random
samples are correlated and some are uncorrelated! For example, suppose we construct a
string of numbers by starting with 0. To obtain the next entry in the string, we do this:
• If the latest entry is 0, the next entry is 0 with probability 0.8 and 1 with probability
0.2.
• If the latest entry is 1, the next entry is 0 with probability 0.3 and 1 with probability
0.7.
The entries in the string are random, because we don’t make the same choices each time
we generate a string. But the entries are correlated: for example, the probability of seeing
the pattern 00 is much more likely than seeing the pattern 01.
Algorithm 17.2 KRS Algorithm
Start with a lattice of monomers.
repeat
Choose an adjacent pair of sites.
If both sites have monomers, add this dimer with some probability.
If the sites are occupied by a single dimer, delete it with some probability.
If one site is occupied with a dimer, swap that dimer for this one with some probability.
If it has been long enough since our last recording, then add the resulting conﬁguration
to the record.
until enough steps are completed.
The add, delete, and swap moves for the KRS algorithm are illustrated in Figure 17.3.
We’ll use the KRS algorithm to estimate C(k) for some simple lattices and compare it (on
small lattices) with explicit counting. We see in solving the next challenge that although
the problem is simple to state, the time for solution is quite large, so data structures must
be carefully chosen to optimize efﬁciency.
CHALLENGE 17.4.
(a) Write a MATLAB function that computes the function C(k) for an n × n lattice by
explicit counting. Try to make it efﬁcient.
(b) Implement the KRS algorithm in a MATLAB function and use it to estimate the function
C(k) for a 4×4 lattice. Try various choices of probabilities and updating intervals. Repeat
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 212 Page number 202
cyan magenta yellow black
202
Chapter 17. Case Study: Monte Carlo Minimization and Counting
POINTER 17.4. Further Reading.
For background on probability, consult a standard textbook such as [109]. Simulated
annealing is discussed in more detail by Kirkpatrick, Gelatt, and Vecchi [90].
More information on random counting algorithms and the estimation of generating func-
tions can be found in papers by Kenyon, Randall, and Sinclair [89], Beichl and Sullivan
[11], Caﬂisch [23], and Beichl, O’Leary, and Sullivan [10].
for a 6 × 6 lattice and then for a lattice as large as possible. Graph the function C(k) for
each lattice, and also report the sum of the C(k) values for each lattice. Discuss the amount
of work performed, the accuracy of your results, and how the work compares with that for
explicit counting.

November 20, 2008 10:52
sccsbook
Sheet number 213 Page number 203
cyan magenta yellow black
Chapter 18 / Case Study
Multidimensional
Integration: Partition
and Conquer
Numerical analysis textbooks provide excellent advice on approximating integrals over
low-dimensional spaces, but many problems of interest are naturally posed in high dimen-
sions and yield integrals over regions with a large number of variables. These problems
arise, for example, in evaluating the failure rate of materials, the expected return on an in-
vestment, or the expected value of the energy of a system with a large number of particles.
In this case study, we consider some algorithms appropriate for these problems, using a
system of particles as a motivating example.
Understanding the behavior of particles subjected to forces is a basic theme in physics.
The simplest system is a set of particles conﬁned to motion along a line, but even this sys-
tem presents computational challenges. For the harmonic oscillator, a particle is subjected
to a force directed toward the origin and proportional to the distance between the particle
and the origin. The resulting potential is V (x) = −1
2αx2, where α is a constant. This sys-
tem is quite thoroughly understood, and quantities of interest can be computed in closed
form. Alternatively, the Ginzburg-Landau anharmonic potential −1
2αx2 + 1
4βx4 (α and
β constant) is related to solution of the Schrödinger equation, and quantities of interest
are computed approximately. One method of obtaining such approximations is numerical
integration, and that is our focus in this case study.
A system in thermodynamic equilibrium can be characterized by its partition func-
tion, an expression for the expected value of e raised to a power equal to the energy of
the system divided by a normalization parameter kT . From the partition function, many
quantities of interest can be computed (for example, the expected value of the energy, the
free energy, the entropy, etc.), so it is a quite important function to compute.
Consider a chain of particles in which each particle interacts with its one or two
neighbors in the chain. For this set of particles, the partition function is
Zd(L) =
 ∞
−∞
ρd(a, L) da,
(18.1)
203
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 214 Page number 204
cyan magenta yellow black
204
Chapter 18. Case Study: Multidimensional Integration
where L = 1/(αT), T is the temperature, α is the Boltzmann constant, d is the number of
particles, and ρd is
ρd(a, L) =
 ∞
−∞
 ∞
−∞
...
 ∞
−∞
g(a,x1, L)g(x1,x2, L)···g(xd,a, L) dx1 dx2...dxd,
where
g(x, y, L) =
1
√
2πδ
exp

−1
2δ(x −y)2 −1
2δ(V(x)+ V(y))

,
V is the potential, and δ = L/(d +1). Our goal in this chapter is to develop some algorithms
for approximating Zd(L).
Numerical Integration Methods
Many methods produce excellent estimates of the value of the integral
I =


f (x) dx
when f is a smooth function of a single variable x and  is a ﬁnite interval [a,b]. For
instance, we can partition the interval into small subintervals, construct a polynomial ap-
proximation to f in each subinterval by evaluating f at several points in the subinterval,
approximate the integral over the subinterval by the integral of the polynomial, and sum
these approximate values. This is the idea behind Newton–Cotes methods. If the function
is slowly changing over some pieces of , then we can reduce the error in the approxima-
tion by taking longer subintervals there and concentrating our work on regions where the
function changes more rapidly.
For multidimensional integrals, however, the situation is much less satisfactory. The
approach that is so successful in one dimension quickly becomes prohibitive. Suppose, for
example, that x ∈R10 and  is the unit hypercube [0,1]×···×[0,1]. Then, as an example,
a polynomial of degree 2 in each variable would have terms of the form
x[]
1 x[]
2 x[]
3 x[]
4 x[]
5 x[]
6 x[]
7 x[]
8 x[]
9 x[]
10,
where the number in each box is 0, 1, or 2. So the polynomial has 310 = 59,049 coefﬁcients,
and we would need 59,049 function values to determine these. If we partition the domain
by dividing each interval [0,1] into 5 pieces, we make 510 ≈10 million boxes, and we
would need 59,049 function evaluations in each. Clearly, this method is expensive!
On the other hand, evaluating integrals this way is quite easy to program if we have
a function quad that works for functions of a single variable, perhaps using a polynomial
approximation method. Then we can use quad to compute
 1
0
h(x1)dx1,
where
h(z) =
 1
0
...
 1
0
f (z,x2,...,x10)dx2...dx10,

November 20, 2008 10:52
sccsbook
Sheet number 215 Page number 205
cyan magenta yellow black
Monte Carlo Integration
205
POINTER 18.1. How to Use Nested Quadrature in MATLAB.
Suppose that we want to compute the volume of a half sphere with radius 1.
I =
 1
−1
 √
1−y2
−√
1−y2

1 −x2 −y2dx dy
We can accomplish this with nested calls to MATLAB’s function quad using the following
function deﬁnitions:
function I = nestedintegration()
I = quad(@ghat, -1, 1)
function z = ghat(y)
global ybar
% y is a vector of evaluation points from quad.
z = zeros(size(y));
for i = 1:length(y),
ybar = y(i);
% Contribution to the integral is zero if (1-ybar^2) <= 0.
if ((1-ybar^2)>0)
z(i) = quad(@h, -sqrt(1-ybar^2), sqrt(1-ybar^2));
end
end
function h = h(x)
global ybar
hsq = 1-x.^2-ybar^2;
% Set contributions from outside the domain to zero.
hsq = (hsq > 0).*hsq;
h = sqrt(hsq);
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 216 Page number 206
cyan magenta yellow black
206
Chapter 18. Case Study: Multidimensional Integration
as long as we can evaluate h(z) for any given value z ∈[0,1]. But h(z) is just an integration,
so we can evaluate it using quad, too. We end up with 10 nested calls to quad. Again,
this is very expensive but quite convenient! We illustrate this method in Pointer 18.1.
As an alternative, some functions f (x) can be approximated quite well by a separable
function f (x)≈f1(x1) f2(x2)... f10(x10). If so, we can approximate our integral by
I≈
 1
0
f1(x1)dx1...
 1
0
f10(x10)dx10.
If this works, it is great, but we aren’t often that lucky.
We need another option, since one of our methods is too expensive and the other is
only special-purpose. If the function cannot be approximated well by a separable function,
then the last resort is Monte Carlo integration.
Algorithm 18.1 Monte Carlo Volume Estimation
Let  ⊂Rd be a set that contains  and has known volume J.
Generate n points {z(i)} ∈ that are uniformly randomly distributed.
Let ˆn be the number of these points that also lie in , and estimate the volume of  by
νn J, where
νn = ˆn
n .
Algorithm 18.2 Basic Monte Carlo Integration
Generate n points {z(i)} ∈ that are uniformly randomly distributed.
(For our 10-D hypercube example, this requires generating 10n random numbers, uni-
formly distributed in [0,1].)
Then the average value of f in the region  is approximated by
μn = 1
n
n
	
i=1
f (z(i)),
and therefore the value of the integral is


f (x) dx = I ≈μn


dx.
Monte Carlo Integration
There are two simple ways to use Monte Carlo integration. For the ﬁrst, think of integration
as computing the volume of some solid , and embed that solid in a larger one  for
which computing the volume is easy. (As a trivial example, we imbed the quarter circle
, illustrated in Figure 18.1, in a square  of side 0.5 in order to compute its area.) Then
generate a sequence of random points in , and determine the fraction ν of points that also

November 20, 2008 10:52
sccsbook
Sheet number 217 Page number 207
cyan magenta yellow black
Monte Carlo Integration
207
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
0.45
0.5
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
0.45
0.5
Figure 18.1. Estimating the area 0.19636 of a quarter circle using Monte Carlo
methods with 20 function evaluations. The volume estimator of Algorithm 18.1 with the
random samples indicated in the ﬁgure gives 13 stars inside the circle and 7 outside, for
an estimate of (13/20)(0.5)2 = 0.163. The basic Monte Carlo algorithm of Algorithm 18.2
averages the 20 blue function values to give a somewhat better estimate, 0.174. Importance
sampling in Algorithm 18.3 averages function values corresponding to the red x’s to yield
0.192.
lie in . We can estimate the volume of  by ν times the volume of . This gives us
Algorithm 18.1.
Another viewpoint gives a somewhat better algorithm, one that obtains more infor-
mation from function values. Again the idea is simple: according to the integral mean value
theorem, the integral
I =


f (x) dx
is equal to the average value of f on  times the volume of , which is
#
 dx. This gives
us a second method, Algorithm 18.2.
How good is the approximation In from Algorithm 18.2? The expected value of In is
the true value of the integral, and this is very good! In fact, for large n, the estimates have
an approximately normal distribution with variance σ 2/n, where
σ 2 =


( f (x)−μn)2 dx.
Note that the variance is a constant that depends on the variation in f around its average
value, but not on the dimension d of the integration domain .
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 218 Page number 208
cyan magenta yellow black
208
Chapter 18. Case Study: Multidimensional Integration
We illustrate the results of Algorithms 18.1 and 18.2 in Figure 18.1 and experiment
with them in Challenge 18.1. We’ll see how well these methods behave on a sample prob-
lem, ﬁnding the area of a quarter circle; but keep in mind that these methods are valuable
for very high dimensional integrals, not the trivial one that we use in Challenge 18.1.
CHALLENGE 18.1.
Suppose we want to estimate the area of a quarter circle  = {(x, y) : x2 + y2 ≤
r2,x ≥0, y ≥0} with radius r. The area is the integral
I =
 r
0

r2 −x2dx ≡
 r
0
f (x)dx.
Let r = 0.5 and use two methods:
(a) Algorithm 18.1 with  equal to the quarter circle of radius r and  equal to the rectangle
[0,r]×[0,r].
(b) Algorithm 18.2 applied to the integrand f (x) and the interval [0,r].
Compare the quality of the two estimates for 10, 100, 1000, 10000, and 100000
points by measuring the error and the convergence rate.
How many function evaluations does your favorite integration routine use to get an
estimate of comparable quality?
CHALLENGE 18.2.
Write a MATLAB program to estimate the volume of the unit sphere x2
1 +x2
2 +x2
3 ≤1
using one of the methods for Monte Carlo integration.
Importance Sampling
The expected value of our estimate from either of the two methods is equal to the value we
are looking for. But there is a nonzero variance to our estimate; we aren’t likely to get the
exact value of the integral. Most of the time, though, the value is close if n is big enough.
If we could reduce the variance of our estimate, then we could use a smaller value of
n. This would mean less work, and it can be achieved by importance sampling.
Suppose that we want to estimate
I =


f (x)dx,
where  is a region in R10 with volume equal to one. Our Monte Carlo estimate of this
integral involves taking uniformly distributed samples from  and taking the average value
of f (x) at these samples. We can improve on this by a good choice of a function p(x)
satisfying p(x) > 0 for all x ∈, normalized so that


p(x) dx = 1.

November 20, 2008 10:52
sccsbook
Sheet number 219 Page number 209
cyan magenta yellow black
Importance Sampling
209
POINTER 18.2. Facts about Importance Sampling.
Importance sampling is very good for decreasing the variance of the Monte Carlo
estimates. In order to use it effectively,
• we need to be able to choose p(x) appropriately;
• we need to be able to sample efﬁciently from the distribution with density p(x).
Then
I =


f (x)
p(x) p(x)dx.
Comparing this with our deﬁnition of expected value μ in Section 16.2, we see that this can
be interpreted as the expected value of the function f (x)/p(x) when the x are distributed
as speciﬁed by p(x). We can get a Monte Carlo estimate of this integral by taking sam-
ples from the distribution with probability density p(x) and taking the average value of
f (x)/p(x) at these samples, and we call this importance sampling. One variant is deﬁned
in Algorithm 18.3 and illustrated in Figure 18.1.
Algorithm 18.3 Monte Carlo Integration by Importance Sampling
(Comment: Use this method only if f (x) is nonnegative.)
Take a “few” samples of f (x), and let ˆp(x) be an approximation to f (x) constructed
from these samples. (For example, ˆp(x) might be a piecewise constant approxima-
tion.)
Let p(x) = ˆp(x)/Ip, where
Ip =


ˆp(x) dx.
Generate points z(i) ∈, i = 1,...,n, distributed according to probability density func-
tion p(x).
Then the average value of f/p in the region  is approximated by
μn = 1
n
n
	
i=1
f (z(i))
p(z(i)) ,
and therefore the value of the integral is
I≈μn


p(x) dx = μn.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 220 Page number 210
cyan magenta yellow black
210
Chapter 18. Case Study: Multidimensional Integration
When is importance sampling better than basic Monte Carlo integration (Algorithm
18.2)? The variance of our estimate is proportional to
σ 2 =


 f (x)
p(x) −I
2
p(x)dx.
So if we choose p so that f (x)/p(x) is close to constant, then σ is close to zero. (This
probably won’t be true if f (x) changes sign on .)
Intuitively, importance sampling works because in regions where f (x) is big, p(x) is
also big, so there is a high probability that we sample from these regions that contribute
most to the magnitude of I, even if the region itself is small.
The big unanswered question is how to get a good choice for p(x). If f is nonnega-
tive, then this can be done by sampling f (x) at a few points and setting p to be piecewise
constant, with value proportional to the sampled values. For our unit hypercube example,
we could divide our domain into 310 smaller cubes (with each side of length 1/3) on which
p is constant. If we evaluate our function f at the center of each of these, this gives a grid
of 310 values at meshpoints wi with each component of wi equal to 1/6, 1/2, or 5/6. We
set p(x) in each cube to be the sampled value f at the center of the cube, divided by the
sum of the sampled values. Then for our integration, among our n random values, we could
choose the number of values in the ith cube to be np(wi).
Let’s repeat our experiment using importance sampling.
CHALLENGE 18.3.
Compute new estimates of the integral of Challenge 18.1 using Algorithm 18.3, tak-
ing 10 samples of f (x) to determine the function p(x). Compare with your previous results.
Using Quasi-Random Numbers
There are many uses of random numbers, and the properties that we need from them depend
on the ultimate use that we intend. For example, simulation might require that the numbers
be as independent of each other as possible, but in Monte Carlo integration, it is most
important that the proportion of points in any region be proportional to the volume of that
region. This property is actually better achieved by points that are correlated, and there have
been many proposals for generating sequences of quasi-random numbers that guarantee
a rather even distribution of points. For example, the van der Corput sequence generates
the kth coordinate of the pth quasi-random number wp in a very simple way. Let bk be the
kth prime number, so, for example, b1 = 2, b2 = 3, and b5 = 11. Now write out the base-bk
representation of p,
p =
	
i
aibi
k ,
and set the coordinate to
wpk =
	
i
aib−i−1
k
.

November 20, 2008 10:52
sccsbook
Sheet number 221 Page number 211
cyan magenta yellow black
Using Quasi-Random Numbers
211
You might think that a regular mesh of points also has a uniform covering property, but it
is easy to see (by drawing the picture) that large boxes are left with no samples at all if
we choose a mesh. The van der Corput sequence, however, gives a sequence that rather
uniformly covers the unit hypercube with samples, as we demonstrate in Challenge 18.4.
CHALLENGE 18.4.
Generate 500 pseudorandom points vp in R2 and 500 quasi-random points wp in R6
(p = 1,...,500). Plot the pseudorandom points. Then for the quasi-random points, make
a plot of the ﬁrst two coordinates, a separate plot of the third and fourth coordinates, and a
ﬁnal plot of the ﬁfth and sixth coordinates. Discuss the desirability of using each of these
four choices for “random” points.
How effective are quasi-random points in approximating integrals?
For random
points, the expected value of the error is proportional to n−1/2 times the square root of
the variance in f ; for quasi-random points, the error is proportional to V [ f ](logn)dn−1,
where V [ f ] is a measure of the variation of f , evaluated by integrating the absolute value
of the dth partial derivative of f with respect to each of its variables, and adding on a
boundary term. Therefore, if d is not too big and f is not too wild, then the result of
Monte Carlo integration using quasi-random points probably has smaller error than using
pseudorandom points.
CHALLENGE 18.5.
Compute new estimates of the integral of Challenge 18.1 using quasi-random num-
bers in Algorithm 18.2 instead of pseudorandom numbers. Compare the results.
Back to Our Partition Function
We now return to computing the partition function (18.1) that motivated our discussion.
CHALLENGE 18.6. (Extra)
(a) Let L = 1 and α = 1.38 angstroms2 g /sec2 K and consider the harmonic oscillator
potential V (x) = −1
2αx2. Determine ﬁnite integration limits for a,x1,...,xd so that the
partition function Zd(L) in (18.1) can be approximated to 3 digit accuracy. (Do this by
bounding the neglected part of the integral.)
(b) Use your favorite one-dimensional integration routine to estimate the partition function
Zd(L). When you need a function value ρd(a, L), use Monte Carlo integration to obtain it.
Try n = 100,1000,10000,100000,1000000 (if possible) and d = 1,2,4,8,16.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 222 Page number 212
cyan magenta yellow black
212
Chapter 18. Case Study: Multidimensional Integration
POINTER 18.3. Further Reading.
The integration techniques we use here, as well as algorithms for generating quasi-
random numbers, are discussed in [23]. Stratiﬁed sampling, also discussed there, is another
tool for improving Monte Carlo estimates.
Beichl and Sullivan give a good introduction to importance sampling [11].
The partition function example is taken from [112], which also presents the divide-
and-conquer approach to computing it. Monte Carlo integration is also used to compute
integrals in rareﬁed gas dynamics [23], estimating the failure rate of materials [135], and
quantum chromodynamics (QCD) [51].
For information on algorithms for approximating integrals in one-dimensional space,
such as that used in MATLAB’s quad, see a standard textbook such as [32, 148].
(c) Repeat the experiment using quasi-random points in the Monte Carlo integration. What
can you say about the accuracy and convergence rate of your estimates?
Partition and Conquer
We noted earlier that if the function to be integrated is separable, then our problem reduces
to a product of one-dimensional integrations. Although our partition function cannot be
separated into d + 1 factors, it can be partially separated. Notice that each variable xi
appears only in a pair of functions g, so it makes sense to accumulate
ˆg(xi−1,xi+1) =
 ∞
−∞
g(xi−1,xi, L)g(xi,xi+1, L) dxi
for even values of i. If we repeat this trick on ˆg for values of i that are multiples of 4,
we reduce our problem further, and continuing, we can actually reduce the problem to a
two-dimensional integration when d is a power of 2. This very nice observation is due to
Nauenberg, Kuttner, and Furman [112]. Therefore, although the partition function provides
a nice test problem for multidimensional integration, we should really compute it using this
divide-and-conquer formulation.

November 20, 2008 10:52
sccsbook
Sheet number 223 Page number 213
cyan magenta yellow black
Chapter 19 / Case Study
Models of Infection:
Person to Person
When faced with a spreading infection, public health workers would like to predict its path
and severity in order to make decisions about vaccination strategies, quarantine policy, and
use of public health resources. This is true whether dispersal of the pathogen is natural
(as in SARS or the 1918 ﬂu) or deliberate (for example, through terrorism). Effective
mathematical models form a way to test the potential outcome of a public health policy and
arrive at an effective response.
In this problem we focus on an overly simpliﬁed model of the spread of an infection
and develop some tools that lend insight into its behavior.
To make our problem as easy as possible, we impose some rather artiﬁcial assump-
tions. Suppose that we have nm patients in a hospital ward and that their beds are arranged
as n rows of m beds. Suppose that one of the patients, the one in the bed ⌈m/2⌉in row
⌈n/2⌉, becomes infected and then can possibly infect patients in neighboring beds. How
does this infection spread through the ward?
Insight through Monte Carlo Simulation
We’ll need some parameters in our model. A patient, once infected, stays contagious for
k days and then recovers, never to be infected again. During each day of infection, the
probability that each susceptible neighbor (north, south, east or west) becomes infected
is τ.
So there are three parts of the population to track. At day t, I(t) is the proportion of
the population that is infected and S(t) is the proportion of the population that has never
been infected. These quantities satisfy 0 ≤I(t) ≤1 and 0 ≤S(t) ≤1 for t ≥0. The third
part, R(t), the proportion of the population that was once infected but has now recovered,
can be derived from these two: R(t) = 1 −I(t)−S(t).
We study this model by running a simulation. Each patient is in one of k +2 states:
the patient has recovered from an infection, is susceptible to infection, or is in the ith day
(i = 1,...,k) of the k-day infection. It is convenient to use the integer values −1, 0, and
213
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 224 Page number 214
cyan magenta yellow black
214
Chapter 19. Case Study: Models of Infection: Person to Person
1,...,k to represent these different states. Each day, we update the status of each infected
patient by incrementing the state of that patient (resetting it to −1 after k days), and for
each susceptible neighbor, we generate a random number between 0 and 1; if that number
is less than τ, then the neighbor’s state is changed from 0 to 1, indicating infection. We
continue this process until there are no infected patients; at that point, our model allows no
possibility of any additional infections, so the epidemic ends.
Let’s see how this model behaves.
CHALLENGE 19.1.
Run this model for m = n = 10, k = 4, τ = 0.2 until there are no infected patients.
Plot I(t), S(t), and R(t) in a single graph.
If possible, display the epidemic as a movie. To do this, form a matrix of dimension
m ×n, where the value of each entry corresponds to the state of the corresponding patient
on a particular day. Using the movie command, we can display these matrices in sequence,
day after day.
Since the model is stochastic, if we run it 10 times, we might get 10 different results,
possibly ranging from no infections other than the original patient to infection of every
patient, although these are both very low probability events. We need to investigate the
variation in results, but ﬁrst we’ll add two complications.
The patients in our original model are immobile and only contact their four nearest
neighbors. In most situations, population members move in more arbitrary ways. For
example, epidemics jump from continent to continent by air or ship travel. In our hospital
ward, let’s assume that the nursing staff sometimes moves patients to other beds. For
deﬁniteness, we’ll assume that each patient initiates a swap with probability δ. Then, at
each time and for each patient we need to decide whether that patient initiates a swap. If
so, we’ll choose the bed indices for the second patient randomly, as ⌊r2n + 1⌋,⌊r2m + 1⌋,
where r1 and r2 are random samples from a uniform distribution on [0,1].
CHALLENGE 19.2.
Modify your model to include mobility and run it for δ = 0.01 until there are no
infected patients. Display the results as in Challenge 19.1.
There are two major tools used to slow the spread of epidemics: quarantine, to iso-
late infected individuals, and vaccination, to protect susceptible individuals. To reduce the
infections in our hospital model, infected individuals should be moved to a corner of the
ward, with recovered individuals separating them from susceptible ones whenever possible.
You can experiment with this quarantine strategy, but in the next problem we turn our at-
tention to the use of vaccinations. For convenience, you might use the value −2 to indicate
a vaccinated patient.

November 20, 2008 10:52
sccsbook
Sheet number 225 Page number 215
cyan magenta yellow black
Insight through Monte Carlo Simulation
215
0
5
10
15
20
25
30
35
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
day
Proportion of individuals
Disease Status with tau = 0.200000, delta = 0.010000
Infected
Susceptible
Recovered
0
2
4
6
8
10
12
14
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
day
Proportion of individuals
Disease Status with tau = 0.200000, delta = 0.010000, nu= 0.100000
Infected
Susceptible
Recovered
Vaccinated
Figure 19.1. Proportion of individuals (in one simulation) infected by day in a
10×10 grid of hospital beds, with infection rate τ = 0.2 and mobility rate δ = 0.01 and no
vaccination (left) and with vaccination rate ν = 0.1 (right).
CHALLENGE 19.3.
Suppose that each day each susceptible individual has a probability ν of being vac-
cinated. Rerun your model with ν = 0.1 until there are no infected patients. Display the
results as in Challenge 19.1 and compare the results of the three models.
Some results from Challenges 19.2 and 19.3 are shown in Figure 19.1. Now we need
to see how much variation is possible in the results if we run the model multiple times.
CHALLENGE 19.4.
Run the model of Challenge 19.3 1000 times, recording the number of individuals
who become infected in each run. (Note that this is equal to the number of recovered
individuals when the run is terminated.) Plot this data as a histogram (as in Figure 19.2),
and compute the mean proportion of recovered individuals and the variance in this number.
Try several different values of ν to see whether the variance changes.
From the results of Challenge 19.3, we can see that vaccinations can contain the
spread of the epidemic. In Challenge 19.5, we take the role of a public health ofﬁcial trying
to limit the spread of the epidemic.
CHALLENGE 19.5.
Develop a vaccination strategy that, on average, limits the epidemic to 20% of the
population. Do this by using a nonlinear equation solver to solve the problem R(ν)−.2 = 0,
where R(ν) is the mean proportion of recovered individuals when we use a vaccination rate
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 226 Page number 216
cyan magenta yellow black
216
Chapter 19. Case Study: Models of Infection: Person to Person
0
20
40
60
80
100
0
100
200
300
400
Percent infected
Number of trials
Histogram of infection rate for nu = 0.000000
0
10
20
30
40
0
50
100
150
200
Percent infected
Number of trials
Histogram of infection rate for nu = 0.100000
0
5
10
15
20
0
50
100
150
200
250
Percent infected
Number of trials
Histogram of infection rate for nu = 0.200000
0
5
10
15
20
0
50
100
150
200
250
300
350
Percent infected
Number of trials
Histogram of infection rate for nu = 0.300000
Figure 19.2. Results of 1000 trials for a 10×10 grid of hospital beds, with infec-
tion rate τ = 0.2 and vaccination rate ν, with ν varying.
of ν. For each value of ν presented by the solver, you need to get a reliable estimate of R
by running the model multiple times. Use the variance estimates from Challenge 19.4 to
determine how many runs to use, and justify your choice.
A Markov Chain Model
The model we have developed has the Markov property: the status of each individual
depends only on the status of the population on the previous day, and not on any older
history. In fact, the system is a Markov chain. The states in the chain correspond to the
possible statuses of the population; each state can be labeled (d1,...,dp), where there are
p beds and di ranges from −2 to k, indicating that individual i (i = 1,..., p) is vaccinated,
recovered, susceptible, or in day j (1 ≤j ≤k) of the infection. There is an edge from one
state to a second state if it is possible for the population to move from the ﬁrst state to the
second state the next day, and the weight on the edge is the probability of this happening.
Figure 19.3 illustrates a Markov chain corresponding to three individuals in a single row
of beds, with the middle one initially infected, a disease duration of k = 2 days, and no

November 20, 2008 10:52
sccsbook
Sheet number 227 Page number 217
cyan magenta yellow black
A Markov Chain Model
217
A
0,1,0
C
1,2,1
D
2,-1,2
R
-1,-1,-1
E
0,2,1
H
1,2,0
F
1,-1,2
I
2,-1,1
L
2,-1,0
K
0,-1,2
G
2,-1,-1
J
-1,-1,2
S
0,-1,-1
P
-1,-1,0
B
0,2,0
M
1,-1,0
O
0,-1,1
Q
0,-1,0
N
1,-1,1
Figure 19.3. A Markov chain that models three patients in a row of beds, with the
middle patient infected and able to possibly infect two neighbors. The triple of numbers
for each state gives the status of each of the three patients. The yellow state A is the state
in which we start, and the red states are the possible outcomes when the infection runs its
course, corresponding to 1 (state Q), 2 (states S and P), or 3 (state R) patients eventually
infected.
vaccination. (You will determine the edge weights in Challenge 19.6.) For this model, we
are interested in three probabilities: the probability of terminating in
• state Q, corresponding to 33% of the population becoming infected,
• state R, corresponding to 100%,
• state P or state S, with the infection contained to 67% of the population.
CHALLENGE 19.6.
(a) Construct the transition matrix A corresponding to this Markov chain: element ai, j is
the probability of transitioning to the ith state from the jth state and is therefore equal to
the weight on that edge of the Markov chain in Figure 19.3.
(b) Let e1 be the ﬁrst column of the identity matrix. If we begin in day 1 in the ﬁrst state,
then the vector Ae1 tells us the probabilities of being in each of the states on day 2. Prove
this.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 228 Page number 218
cyan magenta yellow black
218
Chapter 19. Case Study: Models of Infection: Person to Person
(c) Similarly, A2e1 gives the probabilities for day 3. For efﬁciency, this should be computed
as A(Ae1) rather than as (A2)e1. Explain why, by doing the operations counts.
(d) If we compute z = A je1 for a large enough j, we have the (exact) probabilities of
being in each state after the epidemic passes. Use this fact to compute the probabilities of
having 1, 2, or 3 infected individuals, and compare these probabilities with the results of
a Monte Carlo experiment performed as in Challenge 19.4 but using 3 individuals. How
many Monte Carlo simulations does it take to get 2 digits of accuracy in the probabilities?
(e) In this simple problem, you can determine the three probabilities directly from Figure
19.3, by determining the probability of a transition from state A to states P, Q, R, and S.
Show how these probabilities can be derived, giving the same answer as obtained by the
Markov chain computation above.
In the preceding challenge, we estimated the probabilities of being in each state of a
Markov chain at steady state, after a long time has passed. These estimates were formed
by computing A je1, where A is the transition matrix. The matrix A has several interesting
properties, and it is worthwhile to take the time to verify them to see the relation between
the steady state probabilities and the eigenproblem for A.
CHALLENGE 19.7.
Verify that the matrix A has the following properties:
• Its elements are all nonnegative, since they represent probabilities.
• The sum of the elements in every column is 1, since the transition probabilities out
of a given state must sum to 1. We can write this as eT A = eT , where e is the vector
with each component equal to 1.
• Therefore, e is a left eigenvector of the matrix A corresponding to eigenvalue λ = 1.
So we can ﬁnd the vector of steady state probabilities for a Markov chain by using
any algorithm for solving the matrix eigenvalue problem. Any right-eigenvector z
corresponding to λ = 1 is a steady state vector, since it satisﬁes Az = z.
• We can use the Gerschgorin theorem (See Pointer 5.4) to verify that no eigenvalue of
A can be outside the unit circle.
• (More difﬁcult) It turns out that for this problem, A has four eigenvalues equal to 1,
and no other eigenvalue of A has magnitude 1. Using this fact, we can verify that
the limit of the sequence Ake1 as k →∞is a right eigenvector corresponding to
the eigenvalue λ = 1. (You may assume that the matrix has a complete set of right
eigenvectors u1,...,un that form a basis for the space of n ×1 vectors. Express e1 as
α1u1 +···+αnun, where α1,...,αn are some coefﬁcients, and then compute Ake1.)
Our Markov chain has an enormous number of states ((k + 3)p for p patients), but
many of these states provide more detail than we might need. For example, in Figure 19.3,

November 20, 2008 10:52
sccsbook
Sheet number 229 Page number 219
cyan magenta yellow black
A Markov Chain Model
219
POINTER 19.1. Further Reading.
The 1918 ﬂu epidemic killed more than 20 million people. Some investigators believe
that it may have ﬁrst taken hold in a US army base, but the disaster was worldwide, with
millions killed in India alone. Travel of soldiers in World War I aided the spread of the
infection. A book by Gina Kolata chronicles these events [94].
When doing Monte Carlo experiments, it is wise to use a high-quality pseudorandom
number generator in order to get valid results. The classic reference for understanding such
programs is Donald Knuth’s book [92].
To go beyond the simple models investigated in this chapter, see, for example, the
books by Britton [21] and by Hoppensteadt and Peskin [80] or the article by Zhuge [155].
Learn about Markov chain models and computing in the book by Stewart [142].
There are many approaches to aggregation of Markov chains. One starting point is
an article by Marek [105].
if we are in state C, we always make the transition to state D, so these two states can be
combined or aggregated without loss of information about infection totals. More impor-
tantly, states P and S represent different outcomes, but they are equivalent to us, since in
each case 67% of the population becomes infected.
By aggregating states, we can reduce the size of the problem. Sometimes this can
be done analytically, but when the model is too complicated (for instance, once mobility is
added), we can do it by simulation, gathering data to determine the probability of transitions
between aggregated states.
These simple Markov models can yield some insight into epidemics, but we have seen
that the work of the Monte Carlo experiment, or the number of states in the original Markov
chain, quickly grows with the size of the population. In the case study of Chapter 21 we
investigate an alternative set of models.
Meanwhile, you might want to modify the models to explore more realistic varia-
tions. You also might consider how to model related systems, such as spread of a fungus
in a tree farm, spread of contamination in a set of chicken coops, or spread of disease in a
dormitory when the students also interact at school.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 230 Page number 220
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 231 Page number 221
cyan magenta yellow black
Unit V
Ordinary Differential Equations
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 232 Page number 222
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 233 Page number 223
cyan magenta yellow black
223
In this unit we study initial value problems (IVPs) and boundary value problems
(BVPs) for ordinary differential equations (ODEs).
We ﬁrst review basic theory and algorithms for ODEs in Section 20.1, and then dis-
cuss Hamiltonian systems. Then we discuss some basics and some numerical methods for
differential-algebraic equations (DAEs) in Section 20.4. Section 20.5 focuses on boundary
value problems and their solution using shooting methods and ﬁnite difference methods. In
Chapter 21, we revisit the problem of modeling the spread of an epidemic, considered in
Chapter 19; this time we model the problem using differential equations. More experience
with stability and control of ODEs is given in Chapter 22, where we study a differential
equation modeling motion of a robot arm, investigating its positioning using a nonlinear
equation, and the energy required for positioning using optimization. Finite element meth-
ods for BVPs are discussed in Chapter 23.
BASICS: To understand this unit, the following background is helpful:
• The mean value theorem and Taylor series from calculus.
• Basic facts about differential equations. This information can be found in a basic
textbook on ODEs or in some specialized numerical textbooks such as [75] or [99].
• Numerical solution of ordinary differential equations by Euler’s method, discussed
in basic scientiﬁc computing textbooks.
MASTERY: After you have worked through this unit, you should be able to do the follow-
ing:
• Convert an ODE system to a “standard form” system.
• Use theorems to test whether there is a unique solution to an ODE.
• Determine whether an ODE is stable or stiff.
• Distinguish between local and global ODE error, estimate local error, and estimate a
step length that keeps local error below a given tolerance.
• Derive the Euler method or the backward Euler method from Taylor series.
• Explain why the backward Euler method is sometimes more effective than the Euler
method.
• Use Euler, backward Euler, or other Adams methods to solve differential equations.
• Plot ODE solutions vs. time, or make a phase plot of two components of a solution.
• Understand why predictor-corrector algorithms are used and be able to write one.
• Do order and stepsize control for an ODE method.
• Determine whether a numerical method for ODEs is stable.
• Know when to use the Gear methods instead of Adams or Runge–Kutta.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 234 Page number 224
cyan magenta yellow black
224
• Use a nonlinear equation solver to ﬁnd a parameter in an ODE that satisﬁes a given
condition.
• Deﬁne a Hamiltonian system and verify that a given system has a given Hamiltonian
function.
• Incorporate a conservation principle into an ODE system by adding an extra variable.
• Put a DAE in standard form and use theorems to test whether a unique solution exists.
• Given an approximation to y′ in terms of old function values, describe a numerical
method for solving a DAE, using a ﬁnite difference formula to approximate y′, and
then using a nonlinear equation solver to compute y at the next timestep.
• Use theorems to test whether a unique solution to a BVP exists.
• Program a shooting method to solve a BVP.
• Formulate a delay differential equation.
• Use ﬁnite difference or ﬁnite elements to solve a BVP.
• Check Lyapunov stability of a system described by an ODE.
• Determine parameters in an ODE that minimize an energy function.

November 20, 2008 10:52
sccsbook
Sheet number 235 Page number 225
cyan magenta yellow black
Chapter 20
Solution of Ordinary
Differential
Equations
In this chapter we study some algorithms for solving various types of ordinary differential
equation (ODE) problems. We’ll consider problems in which data values are known at
a single initial time (Section 20.1) as well as those for which values are known at two
different points in time or space (Section 20.5). In between, we’ll discuss problems that
have algebraic constraints (Section 20.4).
The goal is to understand the characteristics of the problems and the methods well
enough to choose an appropriate method and assess the results it returns.
The problems we consider are these:
Initial Value Problem (IVP) in standard form: Given a function f : [0,T]×Rm →Rm, and
an m ×1 vector of initial values y0, ﬁnd a function y : [0,T] →Rm satisfying
y′(t) = f(t,y(t)),
(20.1)
y(0) = y0 .
(20.2)
Higher-Order Initial Value Problem: Given a function g : [0,T]×RKm →Rm, and m × K
initial values u0, ﬁnd a function u : [0,T] →Rm satisfying
u(K)(t) = g(t,u(t),u′(t),...,u(K−1)(t)),
u( j)(0) = u0(:, j),
j = 0,..., K −1,
where u( j) denotes the jth derivative of u.
Boundary Value Problem (BVP): Given a function f : [0,T] × Rm × Rm →Rm, and two
m ×1 vectors of values u0 and uT , ﬁnd a function u : [0,T] →Rm satisfying
u′′(t) = f(t,u,u′),
u(0) = u0 ,
u(T) = uT .
225
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 236 Page number 226
cyan magenta yellow black
226
Chapter 20. Solution of Ordinary Differential Equations
POINTER 20.1. Existence and Uniqueness of Solutions to IVPs for ODEs.
Before computing a numerical approximation to the solution to our ODE, it is im-
portant to know that such a solution exists! One condition guaranteeing existence and
uniqueness of a continuous and differentiable solution on the interval [0,a] is that the func-
tion f be Lipschitz continuous, meaning that there exists a constant L so that for all points
t in [0,a] and for all points y andy we have the bound
∥f(t,y)−f(t,y)∥≤L∥y−y∥.
See standard textbooks such as [26, p. 251] for this and other existence results.
Differential-Algebraic Equation (DAE) in standard form: Given functions M : [0,T] →
Rm×m, A : [0,T] →Rm×m, f : [0,T] →Rm, and appropriate initial values y(0), ﬁnd a
function y : [0,T] →Rm satisfying
M(t)y′(t) = A(t)y(t)+f(t).
20.1
Initial Value Problems for Ordinary Differential
Equations
In this section, we review some standard ideas in the numerical solution of ODEs and dis-
cuss Hamiltonian systems.
20.1.1
Standard Form
We only work with initial value problems in standard form, as in (20.1), because that is
what most software needs. Note that y′ means the derivative with respect to t. In order to
make sure there is no confusion between components of a vector and partial derivatives,
in this chapter we denote the components of the vector y(t) by y( j)(t), so that writing our
equations component by component yields
y′
(1)(t) = f1(t, y(1)(t),..., y(m)(t)),
...
y′
(m)(t) = fm(t, y(1)(t),..., y(m)(t)),
with y(1)(0),..., y(m)(0) given numbers.
It is not essential that we start at t = 0; any value is ﬁne.
One famous system of ODEs is Volterra’s predator/prey model. We can think of
this as modeling a population of foxes, who eat rabbits, coexisting with a population of

November 20, 2008 10:52
sccsbook
Sheet number 237 Page number 227
cyan magenta yellow black
20.1. Initial Value Problems for Ordinary Differential Equations
227
rabbits with an inﬁnite food supply. If we denote the population of rabbits at time t by r(t)
and the population of foxes by f (t), then the model is
dr(t)
dt
= 2r(t)−αr(t) f (t),
d f (t)
dt
= −f (t)+αr(t) f (t),
r(0) = r0 ,
f (0) = f0 .
The parameter α is the encounter factor, with α = 0 meaning no interaction between
rabbits and foxes.
Let y(1)(t) = r(t) and y(2)(t) = f (t). Then we can write this ODE system in standard
form:
y′
(1)(t) = 2y(1)(t)−αy(1)(t)y(2)(t),
y′
(2)(t) = −y(2)(t)+αy(1)(t)y(2)(t).
The solution is not unique until we specify α and the initial population of rabbits and foxes.
CHALLENGE 20.1.
(a) Use one of MATLAB’s solvers (See Pointer 20.2) to explore the behavior of the Volterra
model for various values of α. Suppose that initially the population of rabbits is 20 and the
population of foxes is 10. Graph the solutions for 0 ≤t ≤2 for α = 10−2,10−1, and 1.
(b) Suppose we want to ﬁnd a value of α so that the ﬁnal population of rabbits is 4:
rα(2)−4 = 0.
Note that the result of our experiment in (a) tells us that there is such a value of α between
0.01 and 1. Write a program that uses ode45 along with the nonlinear equation solver
fzero to ﬁnd α.
(c) Repeat part (b), using the “Events” option in the solver to ﬁnd α.
Higher-order initial value problems, those involving derivatives of order greater than
ﬁrst, can be converted to standard form. For example, suppose
u′′(t) = g(t,u,u′),
where g is a given function. Let y(1)(t) = u(t) and y(2)(t) = u′(t). Then
u′(t) = y′
(1)(t) = y(2)(t),
u′′(t) = y′
(2)(t) = g(t, y(1), y(2)),
and we have a system in standard form.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 238 Page number 228
cyan magenta yellow black
228
Chapter 20. Solution of Ordinary Differential Equations
t
y
Figure 20.1. Parallel solutions to an ODE. This graph shows three solutions to
the same ODE but with different initial values y0. This ODE is on the stability boundary.
POINTER 20.2. ODE Solvers in MATLAB.
MATLAB has several solvers for differential equations, including:
ode23: Solves a nonstiff ODE using a low-order method.
ode45: Solves a nonstiff ODE using a medium-order method.
ode23s: Solves a stiff ODE using a low-order method.
The ODE solvers can do more complicated things, too; read the documentation carefully.
20.1.2
Solution Families and Stability
Given y′(t) = f(t,y(t)), the family of solutions is the set of all functions y that satisfy this
equation.
Let’s consider three examples:
ODE
Solution
Jacobian matrix
Illustration
Example 1.
y′(t) = et
y(t) = c −et
J(t) = 0
Figure 20.1
Example 2.
y′(t) = −y(t)
y(t) = ce−t
J(t) = −1
Figure 20.2
Example 3.
y′(t) = y(t)
y(t) = cet
J(t) = 1
Figure 20.3
In the table, c is an arbitrary constant, determined by the initial conditions, and the
Jacobian matrix J is an m ×m matrix with elements
Jkj (t,y(t)) = ∂fk(t,y)(t)
∂yj
,
k = 1,...,m, j = 1,...,m.

November 20, 2008 10:52
sccsbook
Sheet number 239 Page number 229
cyan magenta yellow black
20.1. Initial Value Problems for Ordinary Differential Equations
229
t
y
Figure 20.2. ODE solutions that get closer to each other over time. The ODE is stable.
t
y
Figure 20.3. ODE solutions that get further from each other. This ODE is unstable.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 240 Page number 230
cyan magenta yellow black
230
Chapter 20. Solution of Ordinary Differential Equations
For example, if
y′(t) =
 2y(1)(t)+3y2
(2)(t)
−6t +7y(2)(t)

,
then
J(t,y) =

2
6y(2)(t)
0
7

.
The Jacobian matrix of a single ODE is 1 ×1, hence scalar, as shown in the table above. In
this case,
J(t, y) = fy(t, y(t)) = ∂f (t, y)/∂y.
We say that a single ODE is
• stable at a point (ˆt, ˆy(ˆt)) if fy(ˆt, ˆy(ˆt)) < 0,
• unstable at a point (ˆt, ˆy(ˆt)) if fy(ˆt, ˆy(ˆt)) > 0,
• stiff at a point (ˆt, ˆy(ˆt)) if fy(ˆt, ˆy(ˆt)) << 0.
A system of ODEs is
• stable at a point (ˆt, ˆy(ˆt )) if the real parts of all the eigenvalues of the matrix J(ˆt, ˆy(ˆt ))
are negative,
• stiff at a point (ˆt, ˆy(ˆt )) if the real parts of more than one eigenvalue of J(ˆt, ˆy(ˆt ))
are negative and wildly different. In this case, the solution to the IVP is determined
by processes occurring on time scales that are radically different from each other,
and this forces numerical methods to take small timesteps in order to follow the
solution. Stiff problems are common, for example, in chemical reactions and weather
prediction.
Thus, stability is determined by the Jacobian matrix, which can change over time, so a
system can be stable for one time and unstable for another.
CHALLENGE 20.2.
Suppose we have a system of differential equations y′(t) = f(t,y(t)) with 3 compo-
nents and a Jacobian matrix J(t,y(t)) with eigenvalues 4 −t2, −t −it, and −t +it, where
i = √−1. For what values of t is the equation stable?
To illustrate the effects of stability, consider
y′(t) = Ay(t) =

a11
a12
a21
a22

y(t).
The solution is
y(t) = b1eλ1tz1 +b2eλ2tz2 ,
where λj and zj are eigenvalues and eigenvectors of A:
Az1 = λ1z1 ,
Az2 = λ2z2 .

November 20, 2008 10:52
sccsbook
Sheet number 241 Page number 231
cyan magenta yellow black
20.1. Initial Value Problems for Ordinary Differential Equations
231
0
1
2
3
4
5
6
7
8
9
10
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
t
y1(t)
Figure 20.4. Solution to the example stiff ODE problem. The red curve is the
desired solution, and the blue dashed curves are in the same solution family; they solve the
same ODE with different initial values.
Let
A =

−1001
999
999
−1001

.
Then y′(t) = Ay(t) has the Jacobian J = A with eigenvalues λ = −2,−2000, so this system
is stiff. Why does this trouble us? The solution is
y(t) = b1e−2t

1
1

+b2e−2000t

−1
1

,
where b1 and b2 are constants determined from the initial conditions. If y(1)(0) = 0 and
y(2)(0) = 2, then
b1 = 1, b2 = 1,
and the solution is shown in Figure 20.4. Notice that even after our solution is nearly con-
stant, other solutions in the family are changing rapidly. This causes trouble for numerical
methods since they introduce small perturbations in the solution and may jump from one
member of the solution family to another, as we will see in Figure 20.7. We can cope with
this difﬁculty of rapidly changing solutions by using an ODE solver designed to handle stiff
systems.
Note that stability for an ODE is the same as conditioning. Consider, for example,
the stable system y′(t) = −y(t) with y0 = 1. Then the solution is y(t) = e−t. A small
perturbation in initial condition to y0 = 1 + ϵ changes the solution to y(t) = (1 + ϵ)e−t,
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 242 Page number 232
cyan magenta yellow black
232
Chapter 20. Solution of Ordinary Differential Equations
POINTER 20.3. Stability vs. Conditioning.
The terminology used here differs somewhat from that discussed in Chapter 1. Usu-
ally we say that a problem is well-conditioned, not stable, if small changes in data lead to
small changes in the result. We use the term stability to refer to algorithms. Since the use
of the term stability in ODEs is older than the term conditioning, the standard terminology
for ODEs violates our convention.
Thus, stability of solution families is different from stability of numerical algorithms
used to solve them. Note that an algorithm that solves a well-conditioned (stable) problem
may or may not be numerically stable.
so the problem is well-conditioned. On the other hand, the unstable system y′(t) = y(t)
with y0 = 1 has the exact solution y(t) = et. A small perturbation to y0 = 1 + ϵ changes
the solution to y(t) = (1 + ϵ)et. Thus an arbitrarily small change in input leads to a very
different result for large t, and the problem is ill-conditioned. We’ll consider other ways to
measure stability in the case study of Chapter 22. Meanwhile, we investigate how a basic
solution algorithm, Euler’s method, works on stable and unstable problems.
20.2
Methods for Solving IVPs for ODEs
Now that we understand the characteristics of solutions to IVPs for ODEs, we introduce
some methods for their numerical solution.
20.2.1
Euler’s Method, Stability, and Error
We use Euler’s method to illustrate the basic ideas behind numerical methods for ODEs. It
is not a practical method because it is too slow, but it helps us understand the ideas. Three
derivations of the method yield insight. Suppose that for some value tn, we know the values
yn = y(tn) and fn = f (tn, yn). (Initially, n = 0, t0 = 0, and we have the required data.) We
use this information to step to a new point tn+1 = tn +h.
Approach 1: Geometry
Euler’s method can be derived from the left illustration in Figure 20.5. We have a function
value yn and a derivative value fn = f (tn, yn) at tn. From these we obtain an approximation
yn+1 by starting at yn and moving along a line with a slope of fn to t = tn+1.
Approach 2: Polynomial interpolation
Euler’s method can also be derived by determining the linear polynomial that matches the
function value and derivative of y at tn, and then evaluating it at t = tn+1.

November 20, 2008 10:52
sccsbook
Sheet number 243 Page number 233
cyan magenta yellow black
20.2. Methods for Solving IVPs for ODEs
233
0
0.02
0.04
0.06
0.08
0.1
0.12
0.14
0.16
0.18
0.2
0
0.2
0.4
0.6
0.8
1
t
y
0
0.02
0.04
0.06
0.08
0.1
0.12
0.14
0.16
0.18
0.2
0
0.2
0.4
0.6
0.8
1
1.2
t
y
Figure 20.5. Euler’s method (left) and the backward Euler method (right) for
solving an ODE. On the left, the blue curve is the true solution. An Euler step from t = 0,
y(0) = 1 with stepsize h = 0.2 steps to the point marked with a circle. The red dotted line
is tangent to the solution curve at t = 0, y(0) = 1, so its slope is f (0, y(0)). On the right, a
backward Euler step from t = 0, y(0) = 1 with stepsize h = 0.2 steps to the point marked
with a circle. The red dotted line passes through the point t = 0, y(0) = 1 and is tangent at
t = h to a solution curve (black dashed) for the same differential equation but with different
initial condition.
CHALLENGE 20.3.
Find the linear polynomial that passes through the point data (tn, yn) with slope fn,
and then evaluate it at tn+1.
Approach 3: Taylor series
From Taylor series we know that if y is smooth enough, then
y(t +h) = y(t)+hy′(t)+h2
2 y′′(ξ)
for some point t ≤ξ ≤t +h. Since
y′(t) = f (t, y(t)),
this gives the approximation
yn+1 = yn +h fn,
where h = tn+1 −tn. The difference between y(t + h) and yn+1 is O(h2). It takes 1/h
steps of Euler’s method with stepsize h to walk from t to t +1, so the error per unit time is
O(h1). Therefore, we say that Euler is a ﬁrst-order method.9
However we derive it, we deﬁne Euler’s method in Algorithm 20.1.
9The order of a method is always one less than the exponent of h in the error formula for a single step.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 244 Page number 234
cyan magenta yellow black
234
Chapter 20. Solution of Ordinary Differential Equations
Algorithm 20.1 Euler’s Method
Given: y0 and t0,t1,...,tN.
for n = 0,..., N −1,
hn = tn+1 −tn.
fn = f(tn,yn).
yn+1 = yn +hnfn .
end
CHALLENGE 20.4.
Apply Euler’s method to y′(t) = 1, y(0) = 0, using a stepsize of h = .1 to obtain
approximate values for y(0.1), y(0.2),..., y(1.0).
Stability of Euler’s method and the backward Euler method
In using a method like Euler’s for solving ODEs, there are three sources of error:
• rounding error: especially if the steps get too small.
• local error: the error introduced assuming that yn is the true value.
• global error: how far we have strayed from our original solution curve, assuming no
rounding error.
Consider a single ODE. For Euler’s method, Taylor series (Approach 3) tells us that
if yn is correct, then
y(tn+1)−yn+1 = h2
n
2 y′′(ξ),
where hn = tn+1 −tn. Therefore the local error is h2
n
2 y′′(ξ), which converges to zero as
hn →0.
But as we iterate with Euler’s method, yn has some error, so from the relations
yn+1 = yn +hn f (tn, yn)
and
y(tn+1) = y(tn)+hn f (tn, y(tn))+ h2
n
2 y′′(ξn),
we obtain the error formula
y(tn+1)−yn+1 = y(tn)−yn +hn( f (tn, y(tn))−f (tn, yn))+ h2
n
2 y′′(ξn).
In this expression, the plum-colored terms are global errors at times tn and tn+1, and the
red term is the local error. See Figure 20.6 for an illustration of local and global errors in
an ODE.
Using the mean value theorem, the blue term can be written as
hn( f (tn, y(tn))−f (tn, yn)) = hn fy(η)(y(tn)−yn),

November 20, 2008 10:52
sccsbook
Sheet number 245 Page number 235
cyan magenta yellow black
20.2. Methods for Solving IVPs for ODEs
235
slope= f(t1,y1)
slope = f(t0,y0)
Local error at t2
Global error
Local error at t1
t0
t1
t2
y0
y2
y1
Figure 20.6. Global errors accumulate. If we start on the solution curve at y0
and take an Euler step, we obtain the value y1, which is on a different curve in the solution
family, and the local error is proportional to the stepsize squared. A second step takes us
to y2, which is on yet another solution curve. The error in moving from y1 to y2 is still
proportional to the stepsize squared, but the global error can be much larger than the sum
of the two local errors.
where η is some point between tn and tn+1. Thus we have the expression
(global error)n+1 = (1 +hn fy(η)) (global error)n + (local error)n.
Therefore, the global errors are magniﬁed if
|1 +hn fy(η)| > 1,
and we say that the Euler method is unstable in this case. The stability interval for Euler’s
method, the values of hn for which the errors are not magniﬁed at a given value of t, is
deﬁned by
−2 < hn fy(t) < 0
for a single equation. For a system of equations, the stability region contains the values of
hn for which the eigenvalues of I+hnJ(t, y(t)) are in the unit circle.
In contrast, in the method called the backward Euler method we deﬁne yn+1 as the
solution to the equation
yn+1 = yn +hf(tn+1,yn+1).
The geometry of the method is illustrated on the right in Figure 20.5, and we try the algo-
rithm, summarized in Algorithm 20.2, in the next challenge.
Algorithm 20.2 The Backward Euler Method
Given: y0 and t0,t1,...tN.
for n = 0,..., N −1
Let hn = tn+1 −tn.
Solve for yn+1 in the nonlinear equation
yn+1 = yn +hn f (tn+1,yn+1).
end
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 246 Page number 236
cyan magenta yellow black
236
Chapter 20. Solution of Ordinary Differential Equations
CHALLENGE 20.5.
Let y′(t) = −y(t). Show that the backward Euler method computes
yn+1 = yn −hnyn+1.
Solve this equation for yn+1 and compute several iterates for y(0) = 1 and hn = 0.1.
To determine the error and stability for the backward Euler method, note that Taylor
series tells us that
y(t) = y(t +h)−hy′(t +h)+h2
2 y′′(ξ),
where ξ ∈[t,t + h]. Thus Taylor series says that the local error is h2
2 y′′(ξ). This is a
ﬁrst-order method, just like Euler’s method.
To determine the stability of the backward Euler method we again consider an ODE
with a single equation. We know that
y(tn+1) = y(tn)+hn f (tn+1, y(tn+1))+h2
n
2 y′′(ξn),
n = 0,1,2,...,
and
yn+1 = yn +hn f (tn+1, yn+1).
Therefore,
y(tn+1)−yn+1 = y(tn)−yn +hn( f (tn+1, y(tn+1))−f (tn+1, yn+1))+h2
n
2 y′′(ξn).
Again, the plum-colored terms are global errors, and the red term is the local error. Using
the mean value theorem, the blue term can be written as
hn( f (tn+1, y(tn+1))−f (tn+1, yn+1)) = hn fy(η)(y(tn+1)−yn+1).
Thus we have the expression
(1 −hn fy(η)) (global error)n+1 = (global error)n + (local error)n.
Therefore, the global errors are magniﬁed if
|1 −hn fy(η)| < 1,
and we say that the backward Euler method is unstable in this case. The stability interval
for the backward Euler method is
h fy(t) < 0 or h fy(t) > 2
for a single equation. For a system of equations, the stability region is the region where all
eigenvalues of I −hnJ(t,y(t)) are outside the unit circle. For example, backward Euler is
stable on the equation y′(t) = −y(t) for all positive h.

November 20, 2008 10:52
sccsbook
Sheet number 247 Page number 237
cyan magenta yellow black
20.2. Methods for Solving IVPs for ODEs
237
Let’s check stability for another method for solving ODEs.
CHALLENGE 20.6.
We want to solve the ODE
y′(t)+ay(t) = 0,
where a > 0 is a scalar, and y(0) is given. We apply the Crank–Nicholson method to the
ODE:
yn+1 −yn
h
+a yn+1 + yn
2
= 0,
where yn ≈y(nh) and h > 0 is the timestep. For what range of h values is the numerical
method stable?
Figure 20.7 gives a geometric illustration of the importance of stability in solving
ODEs.
20.2.2
Predictor-Corrector Methods
We could use our favorite nonlinear equation solver from Unit VI in Algorithm 20.2, but
this is expensive. In rare occasions, as in Challenge 20.5, the nonlinear equation can be
solved explicitly, but usually we use functional iteration, as shown in Algorithm 20.3. We
could repeat the CE steps if the value of yn+1 has not converged (although reducing the
stepsize is generally a safer cure). If repeated m times, we call this a PE(CE)m scheme.
Note that using this method usually fails to solve the nonlinear equation exactly, so this
adds an additional source of error.
Let’s see how this works on two examples.
Algorithm 20.3 Predictor-Corrector (PECE) Algorithm
Given: y0 and t0,t1,...tN.
for n = 0,..., N −1
P (predict): Guess yn+1 using a formula that only requires function values for times
earlier than tn+1 (perhaps using Euler’s method yn+1 = yn +hnfn).
E (evaluate): Evaluate fn+1 = f(tn+1,yn+1).
C (correct): Guess yn+1 using a formula that requires function values for times includ-
ing tn+1 (perhaps using the backward Euler method yn+1 = yn +hnfn+1).
E (evaluate): Evaluate fn+1 = f(tn+1,yn+1).
end
CHALLENGE 20.7.
Let
y′(t) = y2(t)−5t ,
y(0) = 1.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 248 Page number 238
cyan magenta yellow black
238
Chapter 20. Solution of Ordinary Differential Equations
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
−4
−3
−2
−1
0
1
2
3
4
t
y
Figure 20.7. A family of solutions to a stiff differential equation y′(t) = −4y(t).
The solution curve for y(0) = 1 is plotted in black, and other family members are plotted
in red. We use Euler’s method to approximate the true solution (marked with stars) by the
values marked with circles. Notice that as we step with Euler’s method, we move from one
solution curve to another, and these curves can be qualitatively quite different. Therefore,
our approximation, marked with blue circles, is quite different from the true solution. Lack
of stability led to a very poor estimate.
Apply a PECE scheme to this problem, using Euler and backward Euler with a stepsize
h = .1, to obtain an approximation for y(.1).
CHALLENGE 20.8.
Let
y′(t) = 10y2(t)−20,
y(0) = 1.
Apply a PECE scheme to this problem, using Euler and backward Euler with a stepsize
h = .1, to obtain an approximation for y(.1). What went wrong?

November 20, 2008 10:52
sccsbook
Sheet number 249 Page number 239
cyan magenta yellow black
20.2. Methods for Solving IVPs for ODEs
239
20.2.3
The Adams Family
Euler and backward Euler are the simplest examples of methods in the Adams family.
Explicit methods like Euler’s, which can be derived by polynomial interpolation at known
function values, give Adams–Bashforth formulas, while those that use one unknown func-
tion value give Adams–Moulton formulas. To derive Adams–Bashforth formulas, notice
that
y(tn+1) = y(tn)+
 tn+1
tn
f (t, y(t)) dt ,
and we can approximate the integrand by polynomial interpolation at the points
(tn, fn),...,(tn−k+1, fn−k+1)
for some integer k, as illustrated in Figure 20.8. For k = 1, this yields a fourth approach
to deriving Euler’s method: approximate the integral by the rectangle rule using the left
endpoint so that
yn+1 = yn +
 tn+1
tn
f (t, y(t)) dt ≈yn + f (tn, yn)(tn+1 −tn).
For Adams–Bashforth with k = 2, we interpolate the integrand by a polynomial of
degree 1, with
p(tn) = fn,
p(tn−1) = fn−1,
so letting hn = tn+1 −tn and hn−1 = tn −tn−1, we obtain
yn+1 = yn +
 tn+1
tn
fn−1 + fn −fn−1
tn −tn−1
(t −tn−1) dt
= yn +hn fn−1 + fn −fn−1
hn−1
(hn +hn−1)2 −h2
n−1
2
.
For Adams–Moulton, we approximate the integrand by polynomial interpolation at
the points
(tn+1, fn+1),...,(tn−k+2, fn−k+2)
for some integer k. For k = 1, we derive the backward Euler method from the approxima-
tion:
yn+1 = yn +
 tn+1
tn
f (t, y(t)) dt ≈yn + f (tn+1, yn+1)(tn+1 −tn).
For Adams–Moulton with k = 2, we interpolate the integrand by a polynomial of
degree 1, with
p(tn) = fn,
p(tn+1) = fn+1,
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 250 Page number 240
cyan magenta yellow black
240
Chapter 20. Solution of Ordinary Differential Equations
f0
f1
f2
f
t0
t1
t2
t3
t4
f3
quadratic polynomial
Want to compute this area.
Compute area under
quadratic instead.
f4
∧
f4
Figure 20.8. Third-order Adams methods. Adams–Bashforth approximates the
area under the curve from t = t3 to t = t4 by integrating the quadratic polynomial that
interpolates the curve using the data f1, f2, and f3. Adams–Moulton would interpolate
f2, f3, and an estimate of f4.
so we obtain
yn+1 = yn +
 tn+1
tn
fn+1 + fn −fn+1
tn −tn+1
(t −tn+1) dt
= yn + hn
2 ( fn+1 + fn),
which is a generalization of the trapezoidal rule for integration.
Adams methods use an Adams–Bashforth formula as a predictor and an Adams–
Moulton formula as a corrector in Algorithm 20.3. Some sample Adams formulas are
given in Table 20.1. Note that the two families share function evaluations, so for a PECE
scheme, the cost per step is only 2 evaluations of f , independent of k.
To make a PECE scheme practical, we need to add stepsize control and error esti-
mation.
20.2.4
Some Ingredients in Building a Practical ODE Solver
We have two tools to help us control the size of the local error:
• We can change the stepsize h.
• We can change the order k (where the local error is O(hk+1)).
Therefore, most ODE solvers ask the user for a tolerance parameter and try to keep the local
error below this tolerance. Note, as we saw in Figure 20.6, that controlling the local error
says nothing about control of global error, unless we know something about the stability of
the ODE.

November 20, 2008 10:52
sccsbook
Sheet number 251 Page number 241
cyan magenta yellow black
20.2. Methods for Solving IVPs for ODEs
241
Table 20.1. Some Adams formulas, assuming equal stepsizes h.
Some Adams–Bashforth Formulas:
Order
Local Error
yn+1 = yn +h fn
k = 1
h2
2 y(2)(η)
yn+1 = yn + h
2(3 fn −fn−1)
k = 2
5h3
12 y(3)(η)
yn+1 = yn + h
12(23 fn −16 fn−1 +5 fn−2)
k = 3
3h4
8 y(4)(η)
Some Adams–Moulton Formulas:
Order
Local Error
yn+1 = yn +h fn+1
k = 1
−h2
2 y(2)(η)
yn+1 = yn + h
2( fn + fn+1)
k = 2
−h3
12 y(3)(η)
yn+1 = yn + h
12(5 fn+1 +8 fn −fn−1)
k = 3
−h4
24 y(4)(η)
To control local error, we need to have a means of estimating it. For example, con-
sider the use of these formulas:
P
yP
n+1 = yn + hn
2 (3 fn −fn−1)
(Adams–Bashforth),
E
fn+1 = f (tn+1, yP
n+1),
C
yC
n+1 = yn + hn
2 ( fn + fn+1)
(Adams–Moulton),
E
fn+1 = f (tn+1, yC
n+1).
To estimate the local error in this method, we compute, using Table 20.1,
yP
n+1 −y(tn+1) = 5h3
n
12 y(3)(η1),
yC
n+1 −y(tn+1) = −h3
n
12 y(3)(η2),
where y(tn+1) is the solution to y′ = f (t, y) with y(tn) = yn rather than with y(0) = y0.
Therefore we see that
yP
n+1 −yC
n+1 = h3
n
12(5y(3)(η1)+ y(3)(η2)) ≈6h3
n
12 y(3)(η),
whose magnitude is about 6 times that of the local error in the corrector. (The points η1,
η2, and η are all in the interval [tn,tn+1].) This gives us a practical means for estimating
local error, since |yP
n+1 −yC
n+1| is computable: we now know that if |yP
n+1 −yC
n+1| is small
enough, then the local error should be small, but if it is big we should worry about the local
error.
Practical methods for solving ODEs use such estimates for the local error to determine
whether the current choice of stepsize hn is adequate. If the local error estimate is larger
than that requested by the user, the stepsize is usually halved, and the step is repeated. If
the local error estimate is much lower than requested, then the stepsize is doubled for the
next step. By using factors of two, old function values can be reused; see Figure 20.9.
Let’s get some practice with the idea of error estimation and stepsize control.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 252 Page number 242
cyan magenta yellow black
242
Chapter 20. Solution of Ordinary Differential Equations
tn-4
tn-3
tn-2
tn-1
tn
tn+1
tn-4
tn-3
tn-2
tn-1
tn
*
*
Figure 20.9. (Top) Given data at tn−4, tn−3, tn−2, tn−1, and tn, if we decide to
increase the stepsize in our Adams formula by a factor of 2, we can reuse the function
values at tn−4, tn−2, and tn to obtain an approximation at tn+1. (Bottom) If we reduce
the stepsize by factor of two, then we interpolate to approximate the function values at the
points marked with stars.
CHALLENGE 20.9.
Suppose we have used a PECE method with predictor of order 4 (i.e., local error is
proportional to O(h5), where h is the stepsize) and corrector of order 5. We want to keep
the local error less than τ. Estimate the local error and explain how to alter the stepsize if
necessary to achieve our local error criterion.
CHALLENGE 20.10.
Suppose we have used a PECE method with Adams–Bashforth and Adams–Moulton
formulas of order 3 to form two estimates of y(tn+1). How would you estimate the local
error in the Adams–Moulton formula? How would you use that estimate to change h in
order to keep the estimated local error less than a user-supplied local error tolerance τ
without taking steps smaller than necessary?
We also change the order of the method to control error and get ourselves started.
When we take our ﬁrst step with an Adams method, we need to use Euler’s method, because
we have no history. When we take our second step, we can use the second-order Adams
methods, because we have information about one old point. As we keep walking, we can
use higher-order methods, by saving information about old function values. But there is a
limit to the usefulness of history; generally, ﬁfth-order methods are about as high as we go,
and the order is kept smaller than this if the local error estimate indicates that the high-order
derivatives are large.
CHALLENGE 20.11. (Extra)
• Write MATLAB statements to start an Adams algorithm. Begin using Euler’s method,
and gradually increase the order of the method to 3. Note that to control the error,
the stepsizes are generally smaller when using lower-order methods.

November 20, 2008 10:52
sccsbook
Sheet number 253 Page number 243
cyan magenta yellow black
20.2. Methods for Solving IVPs for ODEs
243
POINTER 20.4. Controlling Error.
By changing h and k in our ODE solver, we control the local error. It is important to
note that the user really cares about global error, not local error, but this depends on the sta-
bility of the differential equation. To estimate the global error, we might perform sensitivity
analysis as discussed in the case study of Chapter 2, seeing how much the computed solu-
tion changes when the initial conditions are perturbed a bit. We might also experiment with
perturbations to f, but random noise introduced in f causes large-magnitude derivatives and
therefore small stepsizes in the ODE solver.
• Write MATLAB statements to estimate the error and decide whether to change h.
• Write MATLAB statements to decide whether to cut back to a lower-order method.
Note that PECE using the Adams formulas is relatively inexpensive, since, no matter
what the order of the method, we only need two new function evaluations per step. Thus
there is an advantage to using higher-order methods, since they allow a larger stepsize (and
thus fewer steps) with little additional work. One pitfall to watch for is that since PECE
provides an approximate solution to a nonlinear equation, we should suspect that we have
not solved very accurately if |y P
n+1 −yC
n+1| is large; in this case, the stepsize should be
reduced.
20.2.5
Solving Stiff Problems
The Adams family with PECE is good for nonstiff problems, but using this method to solve
a stiff problem may result in artiﬁcial oscillation. An illustration is given in Figure 20.7.
Instead, a Gear family of formulas is effective for stiff problems and can also be used for
nonstiff problems, although it is usually uses somewhat smaller stepsizes than the Adams
family. See Pointer 20.11.
20.2.6
An Alternative to Adams Formulas: Runge–Kutta
Runge–Kutta methods build on the idea we used in the Euler method of predicting a new
value by walking along a tangent to the curve. They just do it in a more complicated way.
For example, suppose we let
k1 = hn f (tn, yn),
k2 = hn f (tn +αh, yn +βk1),
yn+1 = yn +ak1 +bk2,
where we choose α,β,a,b to make the formula as accurate as possible.
We expand everything in Taylor series,
y(tn+1) = y(tn)+ y′(tn)hn + y′′(tn)h2
n
2 +O(h3
n),
(20.3)
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 254 Page number 244
cyan magenta yellow black
244
Chapter 20. Solution of Ordinary Differential Equations
and match as many terms as possible. Note that
y′(tn) = f (tn, yn) ≡f ,
y′′(tn) = ∂f
∂t (tn, yn)+ ∂f
∂y
∂y
∂t (tn, yn) ≡ft + fy f ,
so (20.3) can be written
y(tn+1) = y(tn)+ f hn +( ft + fy f )h2
n
2 +O(h3
n).
(20.4)
Now we expand k1 and k2:
k1 = hn f (tn, yn),
k2 = hn[ f (tn, yn)+αhn ft +βk1 fy+O(h2
n)]
= hn f (tn, yn)+αh2
n ft +βk1hn fy+O(h3
n),
so our Runge–Kutta method satisﬁes
yn+1 = yn +ak1 +bk2
= yn +ahn f +b(hn f +αh2
n ft +βhn f hn fy)+O(h3
n)
= yn +(a +b)hn f +αbh2
n ft +βbh2
n fy f +O(h3
n).
We want to match the coefﬁcients in this expansion to the coefﬁcients in the Taylor series
expansion of y in (20.4), so we set
a +b = 1,
αb = 1
2,
βb = 1
2.
There are many solutions (in fact, an inﬁnite number). One of them is Heun’s method:
a = 1
2,
b = 1
2,
α = 1,
β = 1.
This choice gives a second-order Runge–Kutta method. Note that the work per step is 2
evaluations of f.
The most useful Runge–Kutta method is one of order 4:
k1 = hnf(tn,yn),
k2 = hnf

tn + hn
2 ,yn + k1
2

,
k3 = hnf

tn + hn
2 ,yn + k2
2

,
k4 = hnf(tn +hn,yn +k3),
yn+1 = yn + 1
6(k1 +2k2 +2k3 +k4).

November 20, 2008 10:52
sccsbook
Sheet number 255 Page number 245
cyan magenta yellow black
20.3. Hamiltonian Systems
245
θ
m
Figure 20.10. Our simple harmonic oscillator, a pendulum. The pendulum is
suspended at the origin and the string has length r. As the pendulum moves, its position is
deﬁned by x(t) = p(t) = r sinθ(t), y(t) = q(t) = −r cosθ(t) for some function θ(t).
It requires 4 evaluations of f per step, and many pages for its derivation.
The fact that the Runge–Kutta methods use no old function values is both an advan-
tage and a disadvantage. In contrast to PECE methods, it is easy to change the stepsize,
since no old function values are needed. But PECE methods require only two function
evaluations per iteration, regardless of order, so the Runge–Kutta methods use more work
per iteration when the order is larger than 2.
20.3
Hamiltonian Systems
In some ODE systems, there is an associated conservation law, and if possible, we formu-
late the problem so that conservation is observed.
A Hamiltonian system is one for which there exists a scalar Hamiltonian function
H(y) so that
y′(t) = D∇yH(y(t)),
(20.5)
where D is a block-diagonal matrix with blocks equal to

0
1
−1
0

and ∇yH(y(t)) denotes the gradient of H with respect to the y variables.
For example, consider the pendulum pictured in Figure 20.10. The functions p(t)
and q(t) that deﬁne the position of the pendulum bob satisfy
q′(t) = ωp(t),
(20.6)
p′(t) = −ωq(t),
(20.7)
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 256 Page number 246
cyan magenta yellow black
246
Chapter 20. Solution of Ordinary Differential Equations
where ω > 0 is a ﬁxed parameter. The length r of the string does not change, so we might
want to preserve this invariance, or conservation law, in our numerical method, requiring
that the Hamiltonian of the system
H(t) = ω
2 (p2(t)+q2(t))
remain constant, as it does for the true solution. To verify (20.5) for this example, note that
if y(t) = [q(t), p(t)]T, then
∇yH(y(t)) =

ωq(t)
ωp(t)

,
so that
y′(t) = D∇yH(y(t)) =

0
1
−1
0

ωq(t)
ωp(t)

,
which is (20.6)-(20.7). Note that differentiating with respect to t gives
H ′(t) = ω
2 (2p(t)p′(t)+2q(t)q′(t))
= ω
2 (2p(t)(−ωq(t))+2q(t)(ωp(t)))
= 0,
so H(t) must be constant; in other words, the quantity H(t) is conserved or invariant. We
can verify this a different way by writing the general solution to the problem

q(t)
p(t)

=

cosωt
sinωt
−sinωt
cosωt

q(0)
p(0)

,
and computing p(t)2 +q(t)2. The eigenvalues of the matrix deﬁning the solution are imag-
inary numbers, so a small perturbation of the matrix can cause the quantity H(t) to either
grow or shrink, and this does not produce a useful estimate of p(t) and q(t). Therefore, in
solving systems involving Hamiltonians (conserved quantities), it is important to also build
conservation into the numerical method whenever possible.
If, as in the pendulum example, an ODE of the form
y′(t) = f(t,y(t)),
(20.8)
H(y(t)) = 0,
(20.9)
is overdetermined, with more equations than unknown functions, then we can rewrite it as
y′(t) = f(t,y(t))−G(y(t))z(t),
(20.10)
H(y(t)) = 0,
(20.11)
where z(t) is another function (added so that the system is not overdetermined) and G(y(t))
is a function whose derivative matrix is bounded away from singularity for all t. If we solve
system (20.10)–(20.11) exactly, then we get z(t) = 0 and we recover our original solution.
But if we solve it numerically, the conservation law H(y(t)) = 0 forces z(t) to be nonzero
to compensate for numerical errors.
For our pendulum, for example, we can choose G(y) = ωy and rewrite our harmonic
oscillator example as

November 20, 2008 10:52
sccsbook
Sheet number 257 Page number 247
cyan magenta yellow black
20.4. Differential-Algebraic Equations
247
POINTER 20.5. Warning about Hamiltonian Systems.
Sometimes, adding conservation to an ODE system makes the problem too expensive
to solve; for example, if the solution is rapidly oscillating, the conservation law forces very
small stepsizes.
q′(t) = ωp(t)−ωq(t)z(t),
(20.12)
p′(t) = −ωq(t)−ωp(t)z(t),
(20.13)
0 = ω
2 (p2(t)+q2(t)−r2).
(20.14)
Let’s consider another example of a Hamiltonian.
CHALLENGE 20.12.
Derive the Hamiltonian system for
H(y) = 1
2 y2
1(t)+ 1
2 y2
2(t)+ 1
2 y2
3(t)+ 1
2 y2
4(t)+ 1
2 y2
1(t)y2
2(t)y2
3(t)y2
4(t).
Adding an invariant, or conservation law, generally changes the ODE system to a
system that includes nonlinear equations not involving derivatives as in (20.12)-(20.14) –
a system of differential-algebraic equations (DAEs). Next we’ll consider a little of the
theory and computation of such DAEs.
20.4
Differential-Algebraic Equations
The general DAE has the form
F(t,y(t),y′(t)) = 0,
where F is a speciﬁed function. We’ll consider a special case in which the problem can be
written as
M(t)y′(t) = A(t)y(t)+f(t).
(20.15)
The matrix in front of the derivatives is called the mass matrix. In the next challenge we
convert a DAE to this standard form.
CHALLENGE 20.13.
Let the three variables u(t), v(t), and w(t) be related by
u′(t) = 7u(t)−6v(t)+4t ,
v′(t) = 4u(t)−2v(t),
u(t)+v(t)+w(t) = 24.
Convert this to a system of the form M(t)y′(t) = A(t)y(t)+f(t).
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 258 Page number 248
cyan magenta yellow black
248
Chapter 20. Solution of Ordinary Differential Equations
POINTER 20.6. Existence and Uniqueness of Solutions to DAEs.
DAEs are a combination of ODEs and algebraic (linear or nonlinear) equations, so the
subject of existence and uniqueness of solutions is somewhat complicated. We present a
set of conditions for the DAE
M(t)y′(t) = A(t)y(t)+f(t).
For any nonnegative integer ℓ, deﬁne the (ℓ+1)m ×(ℓ+1)m matrix
Pℓ(t) =
⎡
⎢⎢⎢⎢⎢⎣
M(t)
M′(t)−A(t)
M(t)
M′′(t)−2A′(t)
2M′(t)−A(t)
...
...
...
M(ℓ)(t)−ℓA(ℓ−1)(t)
...
...
ℓM′(t)−A(t)
M(t)
⎤
⎥⎥⎥⎥⎥⎦
,
where the (i, j) block below the diagonal contains
$ i−1
j−1
%
M(i−j) −
$ i−1
j
%
A(i−j−1). Deﬁne
the (ℓ+1)m ×(ℓ+1)m matrix
Nℓ(t) =
⎡
⎢⎢⎢⎣
A(t)
0
...
...
0
A′(t)
0
...
...
0
...
...
...
A(ℓ)(t)
0
...
...
0
⎤
⎥⎥⎥⎦.
Suppose that for some value of ℓ, there are integers ma and md, with ma +md = m, such
that for all values of t in the interval of interest:
• Pℓ(t) and Nℓ(t) are continuously differentiable.
• rank(Pℓ(t)) = (ℓ+1)m −ma, and the ma columns of some matrix Z(t) form a basis
for the null space of Pℓ(t)∗.
• Let Nℓ(t) = Z(t)∗Nℓ(t)[In,0,...,0]T . Then rank(Nℓ(t)) = ma, and the md columns
of some matrix T(t) form a basis for the null space of Nℓ(t).
• There exists W(t) of dimension m ×md such that rank(W(t)∗M(t)T(t)) = md.
• Z(t), T(t), and W(t) are continuously differentiable functions of t.
Then for every consistent initial condition the DAE has a unique solution. See Kunkel and
Mehrmann [97, Theorem 3.52] for proof of this result as well as results for more general
problems.
20.4.1
Some Basics
DAEs are classiﬁed by several parameters:

November 20, 2008 10:52
sccsbook
Sheet number 259 Page number 249
cyan magenta yellow black
20.4. Differential-Algebraic Equations
249
• ma is the number of algebraic conditions in the DAE.
• md is the number of differential conditions in the DAE, and ma +md = m.
• ℓis the strangeness of the DAE.
Often a fourth parameter is considered: the differential-index of a DAE is the number of
differentiations needed to convert the problem to an (explicit) system of ODEs. A system of
ODEs has differential-index 0, and a system of algebraic equations F(y) = 0 has differential-
index 1.
Existence and uniqueness of the solution to the DAE can be checked using the result
in Pointer 20.6. For example, if M(t) in equation (20.15) has full rank for all t, then ℓ= 0,
ma = 0, Z = [ ], and W = T = Im, and we have a system of ODEs. Alternatively, if M = 0
and A(t) is full rank, then ℓ= 0, ma = m, Z = Im, and W = T = [ ], and we have a system
of algebraic equations.
Let’s consider a problem with strangeness ℓ= 1.
CHALLENGE 20.14.
The nonstationary Stokes equation can be discretized in space to give the DAE
u′(t) = Cu(t)+Bp(t),
BT u(t) = 0,
where u(t) is an mu ×1 vector of ﬂuid velocities and p(t) is an mp ×1 vector of pressures,
with mp < mu. Suppose BT is a real full-rank matrix, and that the columns of the mu ×
(mu −mp) matrix X are a basis for its null space. Verify the hypotheses of Pointer 20.6 for
ℓ= 1.
There is a major difference between DAEs and ODEs: For ODEs, it is easy to count
how many initial conditions we need to uniquely determine the solution. For DAEs, it is
not so simple; initial conditions may be inconsistent with the problem. For example, the
equation
ey = 5
is (trivially) a DAE and, of course, nonlinear equations like this require no initial conditions
to specify the solution.
We now consider some numerical methods for solving DAEs.
20.4.2
Numerical Methods for DAEs
The main idea used to solve DAEs follows from what we know about data ﬁtting. If we
want to solve the DAE
F(t,y(t),y′(t)) = 0,
then we step from known values at t = tn,tn−1,...,tn−k to unknown values at t = tn+1 using
our favorite approximation scheme to replace y′(tn+1) by
y′(tn+1) ≈
k
	
j=0
αiy(tn+1−j).
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 260 Page number 250
cyan magenta yellow black
250
Chapter 20. Solution of Ordinary Differential Equations
POINTER 20.7. DAE Software.
The MATLAB ODE solvers, including ode23s, for example, handle some DAEs.
There are several high-quality packages speciﬁcally designed for DAEs, including:
• SUNDIALS from Lawrence Livermore National Laboratory (www.llnl.gov.
CASC/sundials),
• GELDA and
GENDA by Peter Kunkel and Volker Mehrmann (www.math.
tu-berlin.de/numerik/mt.NumMat).
Other software references can be found in [97].
This gives us a nonlinear equation to solve for our approximation yn+1 ≈y(tn+1):
F
⎛
⎝tn+1,yn+1,
k
	
j=0
αiy(tn+1−j)
⎞
⎠= 0.
In principle, we can solve this equation using our favorite method from Chapter 24 (Newton-
like, homotopy, etc.). In practice, there are a few complications:
• Stability is an important consideration. Usually a stiff method is used to ensure
numerical stability.
• The nonlinear equation may fail to have a solution.
• Even if a solution exists, the method for solving the nonlinear equation may fail to
converge.
• Automatic control of order and stepsize is even more difﬁcult than for ODEs.
The bottom line is that you should not try to write your own solver for DAEs. Use
high-quality software, as indicated in Pointer 20.7. We will use a MATLAB DAE solver in
Chapter 21.
20.5
Boundary Value Problems for ODEs
Up to now, the solution to our ODE has always been made unique by specifying values of
the variables at some ﬁxed time t0. We consider in this section boundary value problems,
for which values are speciﬁed at two different times.
For example, consider the problem of determining u(t) for t ∈(0,1) given that
u′′(t) = 6u′(t)−tu(t)+u2(t),
(20.18)
u(0) = 5,
(20.19)
u(1) = 2.
(20.20)

November 20, 2008 10:52
sccsbook
Sheet number 261 Page number 251
cyan magenta yellow black
20.5. Boundary Value Problems for ODEs
251
POINTER 20.8. Existence and Uniqueness of Solutions to BVPs for ODEs.
Consider a problem that can be expressed as
Au(t) = −(a(t)u′(t))′ +b(t)u′(t)+c(t)u(t) = f (t) for t ∈(0,1),
(20.16)
u(0) = u0,
u(1) = u1,
(20.17)
where a(t), b(t), c(t), and f (t) are given differentiable functions and u0 and u1 are given
numbers. The interval is set to t ∈(0,1), but this can be changed by rescaling.
It is important to know that the problem is well posed, in the sense that a unique
solution exists (with two continuous derivatives), and that small changes in the data lead
to small changes in the solution. There are various conditions on the coefﬁcients that
guarantee this. One set of sufﬁcient conditions is
• a(t) ≥a0 for t ∈[0,1], where a0 is a number greater than 0.
• c(t) ≥0 for t ∈[0,1].
•
# 1
0 | f (t)|2dt is ﬁnite.
For further information, consult a standard textbook such as [99, Chap. 2].
If we convert this to a system of ﬁrst order equations, we let y(1)(t) = u(t), y(2)(t) = u′(t)
and obtain
y′
(1)(t) = y(2)(t)
(20.21)
y′
(2)(t) = 6y(2)(t)−ty(1)(t)+ y2
(1)(t),
(20.22)
y(1)(0) = 5,
(20.23)
y(1)(1) = 2.
(20.24)
So we have values of y(1) at 0 and 1. If we had values of y(1) and y(2) at 0, we could use
our IVP methods. But now we have a boundary value problem. What can we do? There
are three alternatives:
• Adapt our IVP methods to this problem in a method called shooting.
• Develop new methods using ﬁnite differences.
• Develop new methods using ﬁnite elements.
We consider the ﬁrst two ideas in the following two sections, and ﬁnite element methods in
the case study of Chapter 23.
Before studying these methods, though, we illustrate the use of the ideas in Pointers
20.8 and 20.9 to obtain information about a BVP without actually solving the problem.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 262 Page number 252
cyan magenta yellow black
252
Chapter 20. Solution of Ordinary Differential Equations
POINTER 20.9. Bounds on Solutions to BVPs for ODEs.
Two facts about BVPs in the form (20.16)-(20.17)can help us compute bounds on the
solutions without computing the solutions themselves.
First, the maximum principle tells us that if
• the solution u exists and has two continuous derivatives on [0,1],
• f (t) ≤0 for t ∈(0,1),
then we can bound the solution:
• If c(t) = 0, then
max
t∈[0,1]u(t) = max(u0,u1).
• If c(t) ≥0 for t ∈(0,1), then
max
t∈[0,1]u(t)≤max(u0,u1,0).
Second, the monotonicity theorem for ODEs helps us compare solutions to different
ODEs without computing them. In particular, if
• u satisﬁes Au(t) = f (t) for t ∈[0,1], with u(0) = u0 and u(1) = u1,
• v satisﬁes Av(t) = g(t) for f ∈[0,1], with v(0) = v0 and v(1) = v1,
• f (t) ≤g(t) for t ∈[0,1],
• u0 ≤v0,
• u1 ≤v1,
then u(t) ≤v(t) for t ∈[0,1].
For further information, consult a standard textbook such as [99, Chap. 2].
CHALLENGE 20.15.
Consider the differential equation
−u′′(t)+8.125π cot((1 +t)π/8)u′(t)+π2u(t) = −3π2 on  = (0,1)
with boundary conditions u(0) = −2.0761, u(1) = −2.2929. Discuss the solution: Does
it exist? Is it unique? What are upper and lower bounds on the solution? Justify each of
your answers by citing a theorem and verifying its hypotheses. (Hint: One bound can be
obtained by comparing the solution to v(t) = −3.)

November 20, 2008 10:52
sccsbook
Sheet number 263 Page number 253
cyan magenta yellow black
20.5. Boundary Value Problems for ODEs
253
ODE solver
f
Initial conditions
y(1)(0) = 5
y(2)(0) = z
Obtain y(1)(1).
Return 
F(z) = y(1)(1) - 2.
Figure 20.11. The function evaluation F(z) for the nonlinear equation solver in
a shooting method to solve y′(t) = f(t,y(t)), y(1)(0) = 5, y(1)(1) = 2. We return the value
F(z) = y(1)(1)−2. When the computed value of y(1)(1) ≈2, then we have the correct initial
condition z.
20.5.1
Shooting Methods
When in doubt, guess. The idea behind shooting methods is to guess at the missing initial
values, solve the IVP using our favorite method, and then use the results to improve our
guess.
In fact, we recognize this as a nonlinear system of equations: to solve our example
problem (20.18)–(20.20), we want to solve the nonlinear equation
F(z) = 0,
where z is the value we give to y(2)(0) and F(z) is the difference between the value that
our (IVP) ODE solver returns for y(1)(1) and the desired value, 2. So a shooting method
involves using a nonlinear equation solver, as illustrated in Figure 20.11. In doing this we
evaluate F(z) by applying our favorite IVP-ODE solver to (20.21)–(20.23). Once we ﬁnd
the initial value z, then the IVP-ODE solver can estimate values u(t) for any t.
Some warnings:
• If the IVP is difﬁcult to solve (for example, stiff), then it is difﬁcult to get an accurate
estimate of z.
• Our function evaluation for the nonlinear equation F(z) = 0 is noisy: it includes all
of the rounding error and the global discretization error introduced by the IVP-ODE
solver. The resulting wiggles in the values of F can cause the nonlinear equation
solver to have trouble ﬁnding an accurate solution, and can also introduce multiple
solutions where there is really only one; see Figure 20.12.
• If the interval of integration is long, these difﬁculties can be overwhelming and we
need to go to more complicated methods; for example, multiple shooting.
Let’s see how shooting works.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 264 Page number 254
cyan magenta yellow black
254
Chapter 20. Solution of Ordinary Differential Equations
F(z)
Magnify
Figure 20.12. In a shooting method, the evaluation of the function is noisy. In-
stead of computing points on the (true) black curve, we compute points on the red curve.
Thus the computed function may have several zeros near the true solution.
CHALLENGE 20.16.
Let
a′′(t) = a2(t)−5a′(t),
a(0) = 5,
a(1) = 2.
Convert this to a system of the form y′ = f(t,y(t)) and write a MATLAB program that uses
a shooting method to solve it.
CHALLENGE 20.17.
Let
u′′(t) = −
!π
2
"2
(u(t)−t2)+2,
with u(0) = u(1) = 1. Write a MATLAB program to solve this problem using the shooting
method.
CHALLENGE 20.18. (Extra)
Write a program to solve the BVP (20.18)-(20.20) using ode45 and fzero.
20.5.2
Finite Difference Methods
Finite difference methods provide an alternative to shooting methods for BVPs. We derive
two ﬁnite difference formulas in the following exercise.

November 20, 2008 10:52
sccsbook
Sheet number 265 Page number 255
cyan magenta yellow black
20.5. Boundary Value Problems for ODEs
255
CHALLENGE 20.19.
Suppose u has 4 continuous derivatives. Prove that
u′(t) = u(t +h)−u(t −h)
2h
+O(h2),
u′′(t) = u(t −h)−2u(t)+u(t +h)
h2
+O(h2)
for small values of h.
Now return to our example problem in its original form (20.18)-(20.20). Given a
large number n (for example, n = 100), let h = 1/n and deﬁne
uj ≈u( jh),
j = 0,...,n.
Then using the formulas in Challenge 20.19 we can approximate our original equation
u′′(t) = 6u′(t)−tu(t)+u2(t)
at t = tj (0 < j < n) by
uj−1 −2uj +uj+1
h2
= 6uj+1 −uj−1
2h
−tjuj +u2
j .
Since we already know that
u0 ≈u(0) = 5,
un ≈u(1) = 2,
we have a system of n −1 nonlinear equations in n −1 unknowns with a tridiagonal coef-
ﬁcient matrix. Deﬁning
aj j
=
−2
h2 + jh,
j = 1,...,n −1,
aj, j+1
=
1
h2 −3
h ,
j = 1,...,n −2,
aj, j−1
=
1
h2 + 3
h ,
j = 2,...,n −1,
ajk
=
0,
k ̸= j, j −1, j +1,
we have
⎡
⎢⎢⎢⎢⎢⎣
a11
a12
a21
a22
a23
.
.
.
.
.
.
an−2,n−3
an−2,n−2
an−2,n−1
an−1,n−2
an−1,n−1
⎤
⎥⎥⎥⎥⎥⎦
⎡
⎢⎢⎢⎢⎢⎣
u1
u2
.
.
un−2
un−1
⎤
⎥⎥⎥⎥⎥⎦
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 266 Page number 256
cyan magenta yellow black
256
Chapter 20. Solution of Ordinary Differential Equations
=
⎡
⎢⎢⎢⎢⎢⎢⎣
−15
h −5
h2
0
.
.
0
6
h −2
h2
⎤
⎥⎥⎥⎥⎥⎥⎦
+
⎡
⎢⎢⎢⎢⎢⎢⎣
u2
1
u2
2
.
.
u2
n−2
u2
n−1
⎤
⎥⎥⎥⎥⎥⎥⎦
,
or
Au = b+
⎡
⎢⎢⎢⎢⎢⎢⎣
u2
1
u2
2
.
.
u2
n−2
u2
n−1
⎤
⎥⎥⎥⎥⎥⎥⎦
.
Now we can use our favorite method for nonlinear equations (Unit VI). If we don’t have
nonlinear terms, all we need to do is to solve a linear system (Unit II or VII).
Next we get some practice in forming the system of linear or nonlinear equations for
our ﬁnite difference method.
CHALLENGE 20.20.
Let
u′′(t) = u′(t)+6u(t)
with u(0) = 2 and u(1) = 3. Let h = 1/5, and write a set of ﬁnite difference equations that
approximate the solution to this problem at t = jh, j = 0,...,5.
CHALLENGE 20.21.
Suppose we solve the problem
u′′(t) = u′(t)−tu(t)+eu(t),
u(0) = 1,
u(1) = 0,
using the ﬁnite difference method, approximating ui ≈u(ih), where h = .01, i = 0,...,100.
We can use a nonlinear equation solver on the system F(u) = 0, where there are 99 un-
knowns and 99 equations. Write the equations for F(u).
20.6
Summary
Some tips for solving the problems considered in this chapter are given in Pointer 20.10.
In the next chapter we see how differential equations arise in models for problems such as
the spread of an epidemic.

November 20, 2008 10:52
sccsbook
Sheet number 267 Page number 257
cyan magenta yellow black
20.6. Summary
257
POINTER 20.10. Some Tips for Solving Differential Equations.
• IVPs for ODEs that arise in practice can be very difﬁcult to solve.
– When in doubt, use a stiff method.
– If there is a conservation law or Hamiltonian, make sure to incorporate it into
the formulation. (Otherwise, your user may be very unhappy with the numeri-
cal results.) But be aware that if you don’t do this in a smart way, it may cause
the ODE solver to take very small steps.
• We have just touched on the existence, uniqueness, and stability theory for ODEs and
DAEs. If you need to solve an important problem, be ready to study these issues
further before you go to the computer.
• Numerical solution of DAEs is still an evolving science, so watch the literature if you
are working in this ﬁeld.
• For BVPs, ﬁnite difference methods and ﬁnite element methods (Chapter 23) are the
most commonly used methods.
POINTER 20.11. Further Reading.
More information on numerical solution of ODEs can be found, for example, in Chap-
ter 9 of Van Loan’s book [148]. More Adams formulas are listed in Van Loan [148, p. 354].
The Gear family of formulas is discussed, for example, in [54] and used in the MAT-
LAB stiff ODE solvers whose names end in ‘s’.
DAEs are discussed in the books by Brenan, Campbell, and Petzold [17] and by
Kunkel and Mehrmann [97].
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 268 Page number 258
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 269 Page number 259
cyan magenta yellow black
Chapter 21 / Case Study
More Models of
Infection: It’s
Epidemic
In the case study of Chapter 19, we studied a model of the spread of an infection through a
hospital ward. The ward was small enough that we could track each patient as an individual.
When the size of the population becomes large, it becomes impractical to use that
kind of model, so in this case study we turn our attention to models which study the popu-
lation as a whole.
As before, we divide the population into three groups: At day t, I(t) is the proportion
of the population that is infected and S(t) is the proportion of the population that has never
been infected. These quantities satisfy 0 ≤I(t) ≤1 and 0 ≤S(t) ≤1 for t ≥0. The third
part, R(t), is the proportion of the population that was once infected but has now recovered,
and it can be derived from these two: R(t) = 1 −I(t)−S(t).
Models without Spatial Variation
In the models we studied before, the probability of an individual becoming infected de-
pended on the status of the individual’s neighbors. In the models in this section, we con-
sider all individuals to be neighbors. This is equivalent to assuming a well-mixed model,
in which all members of the population have contact with all others.
How might we model the three groups in the population? If the infection (or at least
the contagious phase of the infection) lasts k days, then we might assume as an approx-
imation that the rate of recovery is equal to the number infected divided by k. Thus, on
average, 1/k of the infected individuals recover each day.
Let τ be the proportion of encounters between an infected individual and a suscepti-
ble individual that transmit the infection. Then the rate of new infections should increase
as any of the parameters I, S, or τ increases, so we model this rate as τ I(t)S(t).
Next, we take the limit as the “timestep” t goes to zero, obtaining a system of ODEs.
This gives us a simple but interesting Model 1:
d I(t)
dt
= τ I(t)S(t)−I(t)/k ,
dS(t)
dt
= −τ I(t)S(t),
259
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 270 Page number 260
cyan magenta yellow black
260
Chapter 21. Case Study: More Models of Infection: It’s Epidemic
POINTER 21.1. Software.
The MATLAB function ode23s provides a good solver for the ODEs of Challenge
21.1. Most ODE software provides a mechanism for stopping the integration when some
quantity goes to zero; in ode23s this is done by using the Events property in an option
vector.
For Challenge 21.2, some ODE software, including ode23s, can be used to solve
some DAEs; in MATLAB, this is done using the Mass property in the option vector.
In MATLAB, some DDEs can be solved using dde23.
d R(t)
dt
= I(t)/k .
We start the model by assuming some proportion of infected individuals; for example,
I(0) = 0.005, S(0) = 1 −I(0), R(0) = 0.
CHALLENGE 21.1.
Solve Model 1 using ode23s for k = 4 and τ = .8 for t > 0 until either I(t) or S(t)
drops below 10−5. Plot I(t), S(t), and R(t) on a single graph. Report the proportion of the
population that became infected and the maximum difference between I(t) + S(t) + R(t)
and 1.
Instead of using the equation d R/dt = I/k, we could have used the conservation
principle
I(t)+ S(t)+ R(t) = 1
for all time. Substituting this for the d R/dt equation gives us an equivalent system of
differential-algebraic equations (DAEs), studied in Section 20.4, and we call this Model 2.
CHALLENGE 21.2.
Redo Challenge 21.1 using Model 2 instead of Model 1. One way to do this is to
differentiate the conservation principle and express the three equations of the model as
Mu′ = f(t,u), where M is a 3 × 3 matrix and u is a function of t with three components.
Another way is to use a DAE formulation.
There are many limitations in the model, but one of them is that the recovery rate is
proportional to the current number of infections. This means that we are not very faithful
to the hypothesis that each individual is infectious for k days. One way to model this more
closely is to use a delay differential equation (DDE). We modify Model 1 by specifying
that the rate of recovery at time t is equal to the rate of new infections at time t −k. This
gives us a new model, Model 3:
d I(t)
dt
= τ I(t)S(t)−τ I(t −k)S(t −k),

November 20, 2008 10:52
sccsbook
Sheet number 271 Page number 261
cyan magenta yellow black
Models that Include Spatial Variation
261
0
10
20
30
40
50
60
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
time
proportion of population
Solution from Ordinary Differential Equation Model
Infected
Susceptible
Recovered
0
10
20
30
40
50
60
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
time
proportion of population
Solution from Delay Differential Equation Model
Infected
Susceptible
Recovered
Figure 21.1. Results of our models. (Left) Proportion of individuals infected by
the epidemic from the ODE Model 1 or the DAE Model 2. (Right) Proportion of individuals
infected by the epidemic from the DDE Model 3.
dS(t)
dt
= −τ I(t)S(t),
d R(t)
dt
= τ I(t −k)S(t −k).
One disadvantage of this model is that we need to specify initial conditions not just at t = 0
but for −k ≤t ≤0, so it requires a lot more information. A second disadvantage is that the
functions I, S, and R are likely to have discontinuous derivatives (for example, at t = 0 and
t = k, as we switch from dependence on the initial conditions to dependence only on the
integration history). This causes solvers to do extra work at these points of discontinuity.
CHALLENGE 21.3.
Redo Challenge 21.1 with MATLAB’s dde23 using Model 3 instead of Model 1.
For t < 0, use the initial conditions
I(t) = 0, S(t) = 1, R(t) = 0,
and let I(0) = 0.005, S(0) = 1 −I(0), R(0) = 0. Note that these conditions match our
previous ones, but have a jump at t = 0. Compare the results of the three models, as
illustrated in Figure 21.1.
Models that Include Spatial Variation
Epidemics vary in space as well as time. They usually start in a single location and then
spread, based on interaction of infected individuals with neighbors, as in the models of
Chapter 19. The models of the previous section lose this characteristic. To recover it, we
now let S, I, and R depend on a spatial coordinate (x, y) as well as t and see what such a
model predicts.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 272 Page number 262
cyan magenta yellow black
262
Chapter 21. Case Study: More Models of Infection: It’s Epidemic
Since people move in space, we introduce a diffusion term that allows infected in-
dividuals to affect susceptible individuals that are close to them in space. Diffusion adds
a term δ((∂2I)/(∂x2)+(∂2I)/(∂y2))S to d I/dt, and subtracts the same term from dS/dt.
This produces differential equations analogous to Model 1:
∂I(t,x, y)
∂t
= τ I(t,x, y)S(t,x, y)−I(t,x, y)/k
+δ
∂2I(t,x, y)
∂x2
+ ∂2I(t,x, y)
∂y2

S(t,x, y),
∂S(t,x, y)
∂t
= −τ I(t,x, y)S(t,x, y)−δ
∂2I(t,x, y)
∂x2
+ ∂2I(t,x, y)
∂y2

S(t,x, y),
∂R(t,x, y)
∂t
= I(t,x, y)/k .
We assume that the initial values I(0,x, y) and S(0,x, y) are given, that we study
the problem for 0 ≤x ≤1, 0 ≤y ≤1, and t ≥0, and that there is no diffusion across the
boundaries x = 0, x = 1, y = 0, and y = 1.
To solve this problem, Model 4, we discretize and approximate the solution at the
points of a grid of size n × n. Let h = 1/(n −1) and let xi = ih, i = 0,...,n −1, and
yj = jh, j = 0,...,n −1. Our variables are our approximations I(t)ij ≈I(t,xi, yj) and
similarly for S(t)ij and R(t)ij .
CHALLENGE 21.4.
(a) Use Taylor series expansions to show that we can approximate
∂2I(t,xi, yj)
∂x2
= I(t,xi−1, yj)−2I(t,xi, yj)+ I(t,xi+1, yj)
h2
+O(h2).
A similar expression can be derived for ∂2I(t,xi, yj)/∂y2.
(b) Form a vector I(t) from the approximate values of I(t) by ordering the unknowns
as I00, I01,..., I0,n−1, I10, I11,..., I1,n−1,..., In−1,0, In−1,1,..., In−1,n−1, where Iij (t) =
I(t,xi, yj). In the same way, form the vectors S(t) and R(t) and derive the matrix A so that
our discretized equations become Model 4:
∂I(t)
∂t
= τI(t).∗S(t)−I(t)/k +δ(AI(t)).∗S(t),
∂S(t)
∂t
= −τI(t).∗S(t)−δ(AI(t)).∗S(t),
∂R(t)
∂t
=I(t)/k ,
where the notationI(t).∗S(t) means the vector formed by the product of each component of
I(t) with the corresponding component ofS(t). To form the approximation near the bound-
ary, assume that the (Neumann) boundary conditions imply that I(t,−h, y) = I(t,h, y),

November 20, 2008 10:52
sccsbook
Sheet number 273 Page number 263
cyan magenta yellow black
Models that Include Spatial Variation
263
I(t,1 +h, y) = I(t,1 −h, y) for 0 ≤y ≤1, and similarly for S and R. Make the same type
of assumption at the two other boundaries.
There are two ways to use this model. First, suppose we ﬁx the timestep t and
use Euler’s method to approximate the solution; this means we approximate the solution at
t +t by the solution at t, plus t times the derivative at t. This gives us an iteration
I(t +t) =I(t)+t(τI(t).∗S(t)−I(t)/k +δ(AI(t)).∗S(t)),
S(t +t) =S(t)+t(−τI(t).∗S(t)−δ(AI(t)).∗S(t)),
R(t +t) = R(t)+t(I(t)/k).
This model is very much in the spirit of the models we considered in the case study of
Chapter 19, except that it is deterministic rather than stochastic.
Alternatively, we could apply a more accurate ODE solver to this model, and we
investigate this in the next challenge.
CHALLENGE 21.5.
(a) Set n = 11 (so that h = 0.1), k = 4, τ = 0.8 and δ = 0.2 and use an ODE solver to
solve Model 4. For initial conditions, set S(0,x, y) = 1 and I(0,x, y) = R(0,x, y) = 0 at
each point (x, y), except that S(0,0.5,0.5) = I(0,0.5,0.5) = .5. (For simplicity, you need
only use I and S in the model, and you may derive R(t) from these quantities.) Stop the
simulation when either the average value of I(t) or S(t) drops below 10−5. Form a plot
similar to that of Challenge 21.1 by plotting the average value of I(t), S(t), and R(t) vs
time. Compare the results.
(b) Let’s vaccinate the susceptible population at a rate
νS(t,x, y)I(t,x, y)
I(t,x, y)+ S(t,x, y).
This rate is the derivative of the vaccinated population V (t,x, y) with respect to time,
and this term is subtracted from ∂S(t,x, y)/∂t. So now we model four segments of the
population: susceptible S(t), infected I(t), recovered R(t), and vaccinated V (t). Your
program can track three of these and derive the fourth from the conservation principle
S(t) + I(t) + R(t) + V(t) = 1. Run this model with ν = 0.7 and compare the results with
those of Model 4.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 274 Page number 264
cyan magenta yellow black
264
Chapter 21. Case Study: More Models of Infection: It’s Epidemic
POINTER 21.2. Further Reading.
Model 1 is the SIR model of Kermack and McKendrick, introduced in 1927. It is
discussed, for example, by Britton [21].
DDEs such as those in Challenge 21.3 arise in many applications, including circuit
analysis. To learn more about these problems, consult a textbook such as that by Bellman
and Cooke [12] or by Hale and Lunel [67].
Stochastic differential equations are an active area of research. Higham [77] gives a
good introduction to computational aspects and supplies references for further investiga-
tion.
The differential equations leading to Model 4 are presented, for example, by Callahan
[24], following a model with one space dimension given in [87].
If you want to experiment further with Model 4, incorporate the delay recovery term
in place of −I(t)/k.
CHALLENGE 21.6. (Extra)
Include a delay in Model 4. Solve the resulting DDE model numerically and compare
with the previous results.
In the models we used in the case study of Chapter 19, we incorporated some random-
ness to account for factors that were not explicitly modeled. We could also put randomness
into our differential equation models, resulting in stochastic differential equations. See
Pointer 21.2 for references on this subject.

November 20, 2008 10:52
sccsbook
Sheet number 275 Page number 265
cyan magenta yellow black
θ
m
Chapter 22 / Case Study
Robot Control:
Swinging Like a
Pendulum
(coauthored by Yalin E. Sagduyu)
Suppose we have a robot arm with a single joint, simply modeled as a damped driven
pendulum. It is amazing how such a trivial system illustrates so many difﬁcult concepts!
In this project, we study the stability and behavior of this robot arm and develop a strategy
to move the arm from one position to another using minimal energy.
The Model
We assume that the pendulum of length ℓhas a bob of mass m. Figure 22.1 shows the
pendulum’s position at some time t, with the variable θ(t) denoting the angle that the
pendulum makes with the vertical axis at that time. The angle is measured in radians. The
acceleration of the pendulum is proportional to the angular displacement from vertical, and
we model the drag due to friction with the air as being proportional to velocity. This yields
a second-order ordinary differential equation (ODE) for t ≥0:
mℓd2θ(t)
dt2
+cdθ(t)
dt
+mg sin(θ(t)) = u(t),
(22.1)
where g is the gravitational acceleration on an object at the surface of the earth, and c is
the damping (frictional) constant. The term u(t) deﬁnes the external force applied to the
pendulum. In this project, we consider what happens in three cases: no external force,
constant external force driving the pendulum to a ﬁnal state, and then a force designed to
minimize the energy needed to drive the robot arm from an initial position to an angle θf .
Stability and Controllability of the Robot Arm
The solution to equation (22.1) depends on relations among m, ℓ, c, g, and u(t) and ranges
from ﬁxed amplitude oscillations for the undamped case (c = 0) to decays (oscillatory or
265
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 276 Page number 266
cyan magenta yellow black
266
Chapter 22. Case Study: Robot Control: Swinging Like a Pendulum
θ
m
Figure 22.1. We move this robot arm (pendulum), shown here at a position θ(t).
strict) for the damped case (c > 0). Unfortunately, there is no simple analytical solution
to the pendulum equation in terms of elementary functions unless we linearize the term
sin(θ(t)) in (22.1) as θ(t), an approximation that is only valid for small values of θ(t).
Despite the limitations of the linear approximation, the linearization enables us to ﬁnd
analytical solutions and also to apply the results of linear control theory to the speciﬁc
problem of robot-arm control.
CHALLENGE 22.1.
Consider the undriven damped pendulum modeled by (22.1) with u(t) = 0 and
c > 0. Linearize the second-order nonlinear differential equation using the approximation
sin(θ(t))≈θ(t). Use the method in Section 20.1.1 to transform this equation into a ﬁrst order
system of ordinary differential equations of the form y′ = Ay, where A is a 2 × 2 matrix,
and the two components of the vector y(t) represent y(1)(t) = θ(t), and y(2)(t) = dθ(t)/dt.
Determine the eigenvalues of A. Show that the damped system is stable, whereas the
undamped system is not. (Recall from Section 20.1.2 that stability means that the real
part of each eigenvalue of A is negative.) Use the eigenvalue information to show how the
solutions behave in the damped and undamped systems.
Stability of the original differential equation (22.1) is more difﬁcult to analyze than
the stability of the linearized approximation to it, as we saw in Section 20.1.2. Lyapunov
stability occurs when the total energy of an unforced (undriven), dissipative mechanical
system decreases as the state of the system evolves in time. Therefore, the state vector
yT = [θ(t),dθ(t)/dt] approaches a constant value (steady state) corresponding to zero en-
ergy as time increases (i.e., y′(t) →0 as t →∞). According to Lyapunov’s formulation,

November 20, 2008 10:52
sccsbook
Sheet number 277 Page number 267
cyan magenta yellow black
Stability and Controllability of the Robot Arm
267
the equilibrium point y = 0 of a system described by the equation y′ = f(t,y) is globally
asymptotically stable if limt→∞y(t) = 0 for any choice of y(0).
Let y′ = f(t,y) and let ¯y be a steady state solution of this differential equation. Ter-
minology varies in the literature, but we use these deﬁnitions:
• A positive deﬁnite Lyapunov function v at ¯y(t) is a continuously differentiable
function into the set of nonnegative numbers. It satisﬁes v(¯y) = 0, v(y(t)) > 0 and
d
dt v(y(t)) ≤0
for all t > 0 and all y in a neighborhood of ¯y.
• An invariant set is a set for which the solution to the differential equation remains
in the set when the initial state is in the set.
Suppose v is a positive deﬁnite Lyapunov function for a steady state solution ¯y of y′ =
f(t,y). Then ¯y is stable. If in addition {y : dv(y(t))/dt = 0} contains no invariant sets other
than ¯y, then ¯y is asymptotically stable [13]. This result guides our analysis.
Finding a Lyapunov function for a given problem can be difﬁcult, but success yields
important information. For unstable systems, small perturbations in the application of the
external force can cause large changes in the behavior of the solution to the equation and
therefore to the pendulum behavior, so the robot arm might behave erratically. Therefore,
in practice we need to ensure that the system is stable.
CHALLENGE 22.2.
Consider the function
v(θ,dθ/dt) = (1 −cosθ)g
ℓ
+ 1
2
dθ
dt
2
for the pendulum described by (22.1). Show that it is a valid positive deﬁnite Lyapunov
function for the undriven model. Investigate the stability of the solution θ(t) = 0,dθ(t)/dt =
0 for undamped systems and damped systems.
Consider the ﬁrst-order system described by y′ = Ay+Bu, where A is an n×n matrix
and B is an n ×m matrix. The matrices A and B may depend on time t, but in our example
they do not. The system is controllable on t ∈[0,tf ] if given any initial state y(0) there
exists a continuous function u(t) such that the solution of y′ = Ay + Bu satisﬁes y(tf ) =
0. For controllability on any time interval, it is necessary and sufﬁcient that the n × nm
controllability matrix [B,AB,...,An−1B] have rank n on that interval, and the rank can be
computed using the methods in Chapter 5.
Controllability of the robot arm means that we can specify a force that drives it to
any desired position. We investigate the controllability of the linearized pendulum model.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 278 Page number 268
cyan magenta yellow black
268
Chapter 22. Case Study: Robot Control: Swinging Like a Pendulum
CHALLENGE 22.3.
Consider the linearized version of the driven (forced), damped pendulum system with
constant force term u. Transform the corresponding differential equation to a ﬁrst order
ODE system of the form y′ = Ay + Bu. Specify the matrices A and B and show that the
system is controllable for both the damped and undamped cases.
Numerical Solution of the Initial Value Problem
We now develop some intuition for the behavior of the original model and the linearized
model by comparing them under various experimental conditions.
For the numerical investigations in Challenges 22.4–22.6, assume that m = 1 kg,
ℓ= 1 m, and g = 9.81m/sec2, with c = 0 for the undamped case and c = 0.5 kg-m/sec for
the damped case.
First we investigate the effects of damping and of applied forces.
CHALLENGE 22.4.
For the initial conditions θ(0) = π/4 and dθ(0)/dt = 0, use an ODE solver to ﬁnd the
numerical solutions on the interval t = [0,30] for the nonlinear model (22.1) for
1. an undamped (c = 0), undriven (u = 0) pendulum,
2. a damped (c > 0), undriven (u = 0) pendulum, and
3. a damped (c > 0), driven pendulum with the applied forces u = mg sin(θf ), where
θf = π/8,π/4,π/3.
Repeat the same experiments for the linearized model of the pendulum and discuss
the difference in behavior of the solutions. It helps to plot θ(t) for the corresponding linear
and nonlinear models in the same ﬁgure, as in Figure 22.2.
Missing Data: Solution of the Boundary Value Problem
In Challenge 22.4, we solved the initial value problem, in which values of θ and dθ/dt
were given at time t = 0. In many cases, we do not have the initial value for dθ/dt; this
value might not be observable. The missing initial condition prevents us from applying
standard methods to solve initial value problems. Instead, we might have the value θ(tB) =
θB at some other time tB. Next we investigate two solution methods for this boundary
value problem.
Recall from Section 20.5.1 that the idea behind the shooting method is to guess at
the missing initial value z = dθ(0)/dt, integrate equation (1) using our favorite method, and
then use the results at the ﬁnal time tB to improve the guess. To do this systematically, we
use a nonlinear equation solver to solve the equation ρ(z) ≡θz(tB)−θB = 0, where θz(tB)

November 20, 2008 10:52
sccsbook
Sheet number 279 Page number 269
cyan magenta yellow black
Missing Data: Solution of the Boundary Value Problem
269
0
2
4
6
8
10
12
14
16
18
20
−1
−0.5
0
0.5
1
time (t)
θ (t)
Undamped Undriven Pendulum
0
2
4
6
8
10
12
14
16
18
20
−1
−0.5
0
0.5
1
time (t)
θ (t)
Damped Undriven Pendulum
Nonlinear model
Linear model
Nonlinear model
Linear model
Figure 22.2. The linear and nonlinear undriven models from Challenge 22.4.
is the value reported by an initial value problem ODE solver for θ(tB), given the initial
condition z = dθ(0)/dt.
The ﬁnite difference method of Section 20.5.2 is an alternate method to solve a
boundary value problem. Choose a small time increment h > 0 and replace the ﬁrst deriva-
tive in the linearized model of problem (1) by
dθ(t)
dt
≈θ(t +h)−θ(t −h)
2h
and second derivative by
d2θ(t)
dt2 ≈θ(t +h)−2θ(t)+θ(t −h)
h2
.
Let n = tB/h, and write the equation for each value θj ≈θ( jh), j = 1,...,n −1. The
boundary conditions can be stated as θ0 = θ(0), θn = θB. This method transforms the
linearized version of the second-order differential equation (22.1) to a system of n −1
linear equations with n −1 unknowns. Assuming the solution to this linear system exists,
we then use our favorite linear system solver to solve these equations.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 280 Page number 270
cyan magenta yellow black
270
Chapter 22. Case Study: Robot Control: Swinging Like a Pendulum
CHALLENGE 22.5.
Consider the linearized model with constant applied force u(t) = mg sin(π/8) and
damping constant c = 0.5. Suppose that we are given the boundary conditions θ(0) = π/32
and θ(10) = θB, where θB is the value of the solution when dθ(0)/dt = 0.
Apply the shooting method to ﬁnd the solutions to the damped, driven linearized
pendulum equation on the time interval t = [0,10]. Try different initial guesses for dθ(0)/dt
and compare the results.
Now use the ﬁnite difference method to solve this boundary value problem with
h = 0.01. Use your favorite linear system solver to solve the resulting linear system of
equations.
Compare the results of the shooting and ﬁnite difference methods with the solution
to the original initial value problem.
Controlling the Robot Arm
Finally, we investigate how to design a forcing function that drives the robot arm from an
initial position to some other desired position with the least expenditure of energy. We mea-
sure energy as the integral of the absolute force applied between time 0 and the convergence
time tc at which the arm reaches its destination:
ef =
 tc
0
|u(t)|dt .
CHALLENGE 22.6.
Consider the damped, driven pendulum with applied force
u(t) = mg sin(θf )+mℓbdθ(t)/dt,
where θf = π/3. This force is a particular closed-loop control with control parameter b,
and it drives the pendulum position to θf . The initial conditions are given as θ(0) = π/4
and dθ(0)/dt = 0. Assume c = 0.5 as the damping constant, tc = 5 sec as the time limit for
achieving the position θf , and h = 0.01 as the time step length for numerical solutions.
We call a parameter b successful if the pendulum position satisﬁes |θ(t)−θf | < 10−3
for 5 ≤t ≤10. Approximate the total energy by
ˆef ≈
5/h
	
k=1
|u(kh)|h .
Write a function that evaluates ˆef . The input to the function should be the control parame-
ters b and the output should be the approximate total consumed energy ˆef .
For stability of the closed-loop control system, we impose the constraint b < c/(mℓ),
which make the real parts of the eigenvalues (of the linearized version) of the system strictly
negative.

November 20, 2008 10:52
sccsbook
Sheet number 281 Page number 271
cyan magenta yellow black
Controlling the Robot Arm
271
POINTER 22.1. Further Reading.
For Challenge 22.1, consult Section 20.1.1 for converting second derivative equa-
tions to a system of equations involving only ﬁrst derivatives. An elementary linear algebra
textbook [102] discusses computation of the eigenvalues and eigenvectors of a 2 × 2 ma-
trix, and Section 20.1.2 gives an example of how to solve linear ODE systems once the
eigensystem is known.
An ODE textbook [101] can serve as a reference on Lyapunov stability, used in Chal-
lenge 22.2. Control theory textbooks [116, 128] discuss stability plus the concept of con-
trollability used in Challenge 22.3.
Challenge 22.6 relies on an ODE solver and a function for minimization of a function
of a single variable under bound constraints (e.g., MATLAB’s fminbnd).
Now use your favorite constrained minimization solver to select the control parameter
b to minimize the energy function ˆef (b). Display the optimal parameter and graph the
resulting θ(t).
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 282 Page number 272
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 283 Page number 273
cyan magenta yellow black
Chapter 23 / Case Study
Finite Differences
and Finite Elements:
Getting to Know You
Numerical solution of differential equations relies on two main methods: ﬁnite differences
and ﬁnite elements. In this case study, we explore the nuts and bolts of the two methods for
a simple two-point boundary value problem:
−(a(t)u′(t))′ +c(t)u(t) = f (t) for t ∈(0,1),
with the functions a, c, and f given and u(0) = u(1) = 0. We assume that a(t) ≥a0, where
a0 is a positive number, and c(t) ≥0 for t ∈[0,1]. Check Pointer 20.8 for conditions that
guarantee the existence of a unique solution for our problem.
The Finite Difference Method
Let’s rewrite our equation as
−a(t)u′′(t)−a′(t)u′(t)+c(t)u(t) = f (t)
(23.1)
and approximate each derivative of u by a ﬁnite difference:
u′(t) = u(t)−u(t −h)
h
+O(h),
u′′(t) = u(t −h)−2u(t)+u(t +h)
h2
+O(h2).
(We’ll compute a′(t) analytically, so we won’t need an approximation to it.)
The ﬁnite difference approach is to choose grid points tj = jh, where h = 1/(M −1)
for some large integer M, and solve for uj ≈u(tj) for j = 1,..., M −2. We write one
equation for each unknown, by substituting our ﬁnite difference approximations for u′′ and
u′ into (23.1), and then evaluating the equation at t = tj.
CHALLENGE 23.1.
Let M = 6, a(t) = 1, and c(t) = 0 and write the four ﬁnite difference equations for u
at t = .2,.4,.6, and .8.
273
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 284 Page number 274
cyan magenta yellow black
274
Chapter 23. Case Study: Finite Differences and Finite Elements
POINTER 23.1. Some Notes on the Challenges.
To debug your programs, it is helpful to experiment with the simplest test problem
and a small number of grid points. Look ahead to Challenge 23.6 for sample problems.
Challenge 23.2 uses the MATLAB function spdiags to construct a sparse matrix.
If you have never used sparse matrices in MATLAB, print the matrix A to see that the data
structure for it contains the row index, column index, and value for each nonzero element.
If you have never used spdiags, type help spdiags to see the documentation, and
then try it on your own data to see exactly how the matrix elements are deﬁned.
Use MATLAB’s quad to compute the integrals for the entries in the matrix and
right-hand side for the ﬁnite element formulations.
Before tackling the programming for Challenge 23.5 and 23.6, take some time to
understand exactly where the nonzeros are in the matrix, and exactly what intervals of
integration should be used. The programs are short, but it is easy to make mistakes if you
don’t understand what they compute.
In Challenge 23.7, we measure work by counting the number of multiplications. One
alternative is to count the number of ﬂoating-point computations, but this usually gives a
count of about twice the number of multiplications, since typically multiplications and
additions are paired in computations. Computing time is another very useful measure of
work, but it can be contaminated by the effects of other users or other processes on the
computer.
In determining and understanding the convergence rate in Challenge 23.7, plotting
the solutions or the error norms might be helpful.
Notice that the matrix constructed in Challenge 23.1 is tridiagonal. (See Pointer 5.2.)
The full matrix requires (M −2)2 storage locations, but, if we are careful, we can instead
store all of the data in O(M) locations by agreeing to store only the nonzero elements,
along with their row and column indices. This is a standard technique for storing sparse
matrices, those whose elements are mostly zero; see Chapter 27.
Let’s see how this ﬁnite difference method is implemented.
CHALLENGE 23.2.
The MATLAB function finitediff1.m, found on the website, implements the
ﬁnite difference method for our equation. The inputs are the parameter M and the functions
a, c, and f that deﬁne the equation. Each of these functions takes a vector of points as
input and returns a vector of function values. (The function a also returns a second vector
of values of a′.) The outputs of finitediff1.m are a vector ucomp of computed
estimates of u at the grid points tmesh, along with the matrix A and the right-hand side g
from which ucomp was computed, so that A ucomp = g.
Add documentation to the function finitediff1.m so that a user could easily
use it, understand the method, and modify the function if necessary. (See Section 4.1 for
advice on documentation.)

November 20, 2008 10:52
sccsbook
Sheet number 285 Page number 275
cyan magenta yellow black
The Finite Element Method
275
There is a mismatch in finitediff1.m between our approximation to u′′, which
is second order in h, and our approximation to u′, which is only ﬁrst order. We can compute
a better solution, for the same cost, by using a second-order (central difference) approxi-
mation to u′, so next we make this change to our function.
CHALLENGE 23.3.
Deﬁne a central difference approximation to the ﬁrst derivative by
u′(t) ≈u(t +h)−u(t −h)
2h
.
Modify the function of Challenge 23.2 to produce a function finitediff2.m that uses
this second-order accurate central difference approximation (studied in Challenge 20.19)
in place of the ﬁrst-order approximation.
The Finite Element Method
We’ll use a Galerkin method with ﬁnite elements to solve our problem. In particular, we
notice that
−(a(t)u′(t))′ +c(t)u(t) = f (t) for t ∈(0,1)
implies that
 1
0
(−(a(t)u′(t))′ +c(t)u(t))v(t) dt =
 1
0
f (t)v(t) dt
for all functions v. Now we use integration by parts on the ﬁrst term, recalling that our
boundary values are zero, to obtain the equation
 1
0
a(t)u′(t)v′(t)+c(t)u(t)v(t) dt =
 1
0
f (t)v(t) dt,
for all functions v. If a, c, and f are smooth functions (i.e., their ﬁrst few derivatives
exist), then the solution to our differential equation satisﬁes the boundary conditions and
has a ﬁrst derivative, with the integral of (u′(t))2 on [0,1] ﬁnite. We call the space of all
such functions H 1
0 , and that is also the space we draw v from.
How does this help us solve the differential equation? We choose a subspace Sh of
H 1
0 that contains functions that are good approximations to every function in H 1
0 , and we
look for a function uh ∈Sh so that
 1
0
a(t)u′
h(t)v′
h(t)+c(t)uh(t)vh(t) dt =
 1
0
f (t)vh(t) dt
for all functions vh ∈Sh. This gives us an approximate solution to our problem.
A common choice for Sh is the set of functions that are continuous and linear on
each interval [tj−1,tj] = [( j −1)h, jh], j = 1,..., M −1 (piecewise linear elements), where
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 286 Page number 276
cyan magenta yellow black
276
Chapter 23. Case Study: Finite Differences and Finite Elements
0
0.25
0.5
0.75
1
0
0.25
0.5
0.75
1
t
φ1
φ2
φ3
ψ1
ψ2
ψ3
ψ4
Figure 23.1. The nonzero pieces of the three linear (φ) and four quadratic (ψ)
basis functions for three interior grid points and four subintervals (M = 5).
h = 1/(M −1). We can construct our solution using any basis for Sh, but one basis is
particularly convenient: the set of hat functions φj, j = 1,..., M −2, where
φj(t) =
⎧
⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎩
t−tj−1
tj−tj−1 ,
t ∈[tj−1,tj],
t−tj+1
tj−tj+1 ,
t ∈[tj,tj+1],
0
otherwise.
These are designed to satisfy φj(tj) = 1 and φj(tk) = 0 if j ̸= k; see Figure 23.1 for an
illustration. Note that φj is nonzero only on the interval (tj−1,tj+1) (i.e., it has small
support), but it is deﬁned everywhere.
Then we can express our approximate solution uh as
uh(t) =
M−2
	
j=1
ujφj(t)
for some coefﬁcients uj, which happen to be approximate values for u(tj).
Deﬁne
a(u,v) =
 1
0
(a(t)u′(t)v′(t)+c(t)u(t)v(t)) dt,
( f ,v) =
 1
0
f (t)v(t) dt.
Then our solution u satisﬁes
a(u,v) = ( f ,v)

November 20, 2008 10:52
sccsbook
Sheet number 287 Page number 277
cyan magenta yellow black
The Finite Element Method
277
for all v ∈H 1
0 , and we demand that our approximate solution uh ∈Sh satisfy
a(uh,vh) = ( f ,vh)
for all vh ∈Sh. In Challenge 23.4, we reduce this to a linear system of equations that can
be solved for the coefﬁcients uj, and we implement our ideas in Challenge 23.5.
CHALLENGE 23.4.
(a) Since the functions φj form a basis for Sh, any function vh ∈Sh can be written as
vh(t) =
M−2
	
j=1
vjφj(t)
for some coefﬁcients vj. Show that if
a(uh,φj) = ( f ,φj)
(23.2)
for j = 1,..., M −2, then
a(uh,vh) = ( f ,vh)
for all vh ∈Sh.
(b) Putting the unknowns uj in a vector u we can write the system of equations resulting
from (23.2) as Au = g, where the ( j,k) entry in A is a(φj,φk) and the jth entry in g is
( f ,φj). Write this system of equations for M = 6, a(t) = 1, c(t) = 0, and compare with
your solution to Challenge 23.1.
CHALLENGE 23.5.
Write a function fe_linear.m that has the same inputs and outputs as
finitediff1.m but computes the ﬁnite element approximation to the solution using
piecewise linear elements. Remember to store A as a sparse matrix.
It can be shown that the computed solution is within O(h2) of the exact solution,
if the data is smooth enough. Better accuracy can be achieved if we use higher-order
elements; for example, piecewise quadratic elements would produce a result within O(h3)
for smooth data. A convenient basis for this set of elements is the piecewise linear basis
plus M −1 quadratic functions ψj that are zero outside [tj−1,tj] and satisfy
ψj(tj) = 0,
ψj(tj−1) = 0,
ψj(tj−1 +h/2) = 1
for j = 1,..., M −1. See Figure 23.1 for an illustration.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 288 Page number 278
cyan magenta yellow black
278
Chapter 23. Case Study: Finite Differences and Finite Elements
CHALLENGE 23.6.
Write a function fe_quadratic.m that has the same inputs and outputs as
finitediff1.m but computes the ﬁnite element approximation to the solution using
piecewise quadratic elements. In order to keep the number of unknowns comparable to
the number in the previous functions, let the number of intervals be m = ⌊M/2⌋. When
M = 10, for example, we have 5 quadratic basis functions (one for each subinterval)
and 4 linear ones (one for each interior grid point). If you order the basis elements as
ψ1,φ1,...,ψm−1,φm−1,ψm then the matrix A has 5 nonzero bands including the main di-
agonal. Compute one additional output uval which is the ﬁnite element approximation to
the solution at the m −1 interior grid points and the m midpoints of each interval, where
the 2m −1 equally spaced points are ordered smallest to largest. (In our previous methods,
this was equal to ucomp, but now the values at the midpoints of the intervals are a linear
combination of the linear and quadratic elements.)
Now we have four solution algorithms, so we deﬁne a set of functions for experimen-
tation:
u1(t) = t(1 −t)et,
u2(t) =
* u1(t)
if t ≤2/3,
t(1 −t)e2/3
if t > 2/3,
u3(t) =
* u1(t)
if t ≤2/3,
t(1 −t)
if t > 2/3,
a1(t) = 1,
a2(t) = 1 +t2,
a3(t) =
* a2(t)
if t ≤1/3,
t +7/9
if t > 1/3,
c1(t) = 0,
c2(t) = 2,
c3(t) = 2t.
For each particular choice of u, a, and c, we deﬁne f using (23.1).
CHALLENGE 23.7.
Use your four algorithms to solve 7 problems:
• a1 with cj ( j = 1,2,3) and true solution u1.
• aj ( j = 2,3) with c1 and true solution u1.
• a1 and c1 with true solution uj ( j = 2,3).
Compute three approximations for each algorithm and each problem, with the number of
unknowns in the problem chosen to be 9, 99, and 999. For each approximation, print

November 20, 2008 10:52
sccsbook
Sheet number 289 Page number 279
cyan magenta yellow black
The Finite Element Method
279
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
0.45
t
u
Computed solution
True solution
Figure 23.2. The “solution” to the seventh test problem. We compute an accurate
answer to a different problem.
∥ucomputed −utrue∥∞, where utrue is the vector of true values at the points jz, where
z = 1/10, 1/100, or 1/1000, respectively.
Discuss the results:
• How easy is it to program each of the four methods? Estimate how much work MAT-
LAB does to form and solve the linear systems. (The work to solve the tridiagonal
systems should be about 5M multiplications, and the work to solve the 5-diagonal
systems should be about 11M multiplications, so you just need to estimate the work
in forming each system.)
• For each problem, note the observed convergence rate r: if the error drops by a factor
of 10r when M is increased by a factor of 10, then the observed convergence rate is
r.
• Explain any deviations from the theoretical convergence rate: r = 1 and r = 2 for the
two ﬁnite difference implementations, and r = 2 and r = 3 for the ﬁnite element im-
plementations when measuring (u −uh,u −uh)1/2. The solution to the last problem
is shown in Figure 23.2.
In doing this work, we begin to understand the complexities of implementation of
ﬁnite difference and ﬁnite element methods. We have left out many features that a prac-
tical implementation should contain. In particular, the algorithm should be adaptive, es-
timating the error on each grid interval and subdividing the intervals (or raising the order
of polynomials) where the error is too high. This method can handle partial differential
equations, too. Luckily, there are good implementations of these methods for two- and
three-dimensional domains, so we don’t need to write our own.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 290 Page number 280
cyan magenta yellow black
280
Chapter 23. Case Study: Finite Differences and Finite Elements
POINTER 23.2. Further Reading.
A good introduction to the theory of ﬁnite difference and ﬁnite element methods is
given by Gockenbach [59]; for a more advanced treatment, see, for example, Larsson and
Thomée [99, Chap. 2, Section 4.1, Section 5.1].

November 20, 2008 10:52
sccsbook
Sheet number 291 Page number 281
cyan magenta yellow black
Unit VI
Nonlinear Equations and  
Continuation Methods
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 292 Page number 282
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 293 Page number 283
cyan magenta yellow black
283
The basic techniques for solving systems of nonlinear equations are drawn from those
for solving linear equations, optimization problems, and differential equations. In this
unit, we survey these techniques. First we survey Newton-like methods, related to those
discussed in Unit III for optimization problems. Then we consider a class of methods called
continuation methods that are useful for particularly difﬁcult problems.
Continuation methods are applied to a truss problem in Chapter 25. Then in Chapter
26 we solve a system of nonlinear equations to determine some parameters related to the
life cycle of a ﬂour beetle.
BASICS: To understand this unit, the following background is helpful:
• Properties of polynomial functions of a single variable x, such as how many roots
they have and the use of polynomials in modeling other functions.
• Numerical solution of a single nonlinear equation.
This background material can be found in a standard introductory textbook (e.g., [32, 148]).
MASTERY: After you have worked through this unit, you should be able to do the follow-
ing:
• Describe the methods used in fzero.
• Formulate a nonlinear equation as a least squares problem.
• Recognize polynomial equations and apply appropriate algorithms.
• Apply Newton’s method and Newton-like methods, with linesearch or trust region,
to solve nonlinear equations.
• Apply ﬁxed-point iterations to solve nonlinear equations, and realize that they are
very slow.
• Deﬁne homotopy.
• Write a program to ﬁnd the solution to a nonlinear equation using a continuation
method. Solve the intermediate problems using a nonlinear equation solver, or follow
the path using an ODE solver.
• Explain why continuation methods sometimes solve problems that standard nonlin-
ear equation solvers can’t.
• Identify cases in which continuation methods run into trouble (bifurcation, etc.).
• Use inverse interpolation to solve a single nonlinear equation.
• Use the theorems that guarantee a globally convergent continuation method.
• Determine the stability of a dynamical system (system of ODEs).
• Solve nonlinear least squares problems.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 294 Page number 284
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 295 Page number 285
cyan magenta yellow black
Chapter 24
Nonlinear Systems
24.1
The Problem
In this chapter we focus on solving nonlinear systems of equations.
Nonlinear system of equations: Given a function F : Rn →Rn, ﬁnd a point x ∈Rn such
that
F(x) = 0.
We call such a point a solution of the equation or a zero of F.
We’ll assume that n > 1; see Pointer 24.1 for methods for solving nonlinear equations
with a single variable. An important special case is polynomial root ﬁnding, in which F
is a polynomial in the variables x. An example is the system
x2y3 + xy = 2,
2xy2 + x2y + xy = 0.
In this case, x = [x, y]T. If a system is polynomial, then this feature should be exploited in
the solution algorithm, and there is special purpose software that ﬁnds all of the solutions,
including the complex ones, reliably. See Pointers 24.1 and 24.4.
Solving nonlinear equations is a close kin to solving optimization problems. The
main difference is that there is no natural merit function f (x) to use to measure our
progress.
From our study of optimization problems, we already have many techniques that help
us in solving nonlinear equations. The main algorithms for both problems are Newton’s
method and Newton-like methods, but there are some differences in how they are used.
We know that every solution to a differentiable optimization problem minx f (x) is the
solution to the nonlinear system of equations formed by setting the gradient g of f equal to
zero, and this is a system of nonlinear equations. General systems of nonlinear equations
lack two important features of the system g(x) = 0:
285
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 296 Page number 286
cyan magenta yellow black
286
Chapter 24. Nonlinear Systems
a
b
 
c
F
b
a
 
c
F
(a+b)/2
Figure 24.1. To solve the nonlinear equation F(z) = 0, the zeroin algorithm
uses the secant method when sufﬁcient progress is made, and bisection otherwise. We
begin with [a,b] as an interval bracketing the root, so that F(a)F(b) < 0. On the left, the
secant estimate c is the point where the line connecting the points (a, F(a)) and (b, F(b))
intersects the horizontal axis. We have a new bracketing interval [a,c], since F(a)F(c)< 0,
and it is much shorter than the old interval. On the right, the secant method yields a
bracketing interval [a,c], which is close in length to the initial interval, so zeroin would
use bisection instead, yielding an interval [(a + b)/2,b] of half the length of the original
interval.
POINTER 24.1. Software for One-Dimensional Problems.
The one-dimensional case (n = 1) is covered in elementary textbooks. The best soft-
ware for the general problem is some variant on Richard Brent’s zeroin [19], which
determines an interval that contains the solution and then reduces its length through a com-
bination of bisection and the secant method, as illustrated in Figure 24.1. The MATLAB
algorithm related to zeroin is called fzero. Sometimes a simple approach such as
inverse interpolation, considered in Challenge 24.5, is a useful method. If F(x) is a poly-
nomial, then very effective special purpose algorithms are available to ﬁnd all of the roots;
see, for example, [153, 86].
• Instead of the Hessian matrix of f , we have the Jacobian matrix J of ﬁrst deriva-
tives of F with elements
Jik(x) = ∂Fi(x)
∂xk
.
Unlike the Hessian matrix, the Jacobian matrix is generally not symmetric.
• Linesearches are more difﬁcult to guide, since we have no function f (x) by which
to measure progress. Some methods use ∥F(x)∥as a merit function, but there are
difﬁculties with this approach.
Our plan is to recall our discussion of nonlinear least squares problems and then
to study Newton-like methods (for easy systems of nonlinear equations) and continuation
methods (for hard problems). We’ll compare these methods in the case study of Chapter 25.

November 20, 2008 10:52
sccsbook
Sheet number 297 Page number 287
cyan magenta yellow black
24.2. Nonlinear Least Squares Problems
287
POINTER 24.2. Existence, Uniqueness, and Sensitivity of Solutions to Nonlinear
Equations.
There is no obvious property of F(x) = 0 that tells us whether or not a real solution
exists. For example, consider the equation F1(x) = x2
1 + x2
2 −r2, deﬁning a circle centered
at the origin, and the equation F2(x) = x2
1 + 2x2
2 −c2, deﬁning an ellipse with the same
center. Depending on the choice of r and c, we can have no (real) point that satisﬁes both
equations (e.g., r = 10,c = 1), 2 points (e.g., r = c = 1), or 4 points (e.g., r = 1,c = 2).
There are always 4 complex solution points, however, since this is a polynomial system
of equations, and a theorem of Bezoit tells us that if there are not an inﬁnite number of
solutions, then the number of real and complex solutions (counting multiplicities) is deter-
mined by multiplying the degrees of each equation. Since the highest-order term in each is
2, the degree of our system is 4.
One theory of existence of real solutions is based on contraction maps. If the func-
tion F(x) has a Lipschitz constant less than 1 for all x in a closed set, then there is a unique
point in that set satisfying x = F(x). Therefore if F(x) = F(x)+x is a contraction map on
a closed set, then F(x) = 0 has a unique solution in that set.
Sensitivity of solutions can be understood through Taylor series expansion. Suppose
x solves F(x) = 0. Then
F(y) = F(x)+J(η)(y−x) = J(η)(y−x),
where η is a point between x and y, so
∥(y−x)∥= ∥(J(η))−1F(y)∥.
If the norm of the residual F(y) is small, then ∥(y −x)∥will be small when J(η) is well
conditioned, so sensitivity of the zero to perturbations in F depends on the conditioning of
the Jacobian in the neighborhood of the solution.
24.2
Nonlinear Least Squares Problems
We can solve F(x) = 0 by solving the nonlinear least squares problem
min
x ∥F(x)∥2
2
using any of our methods from Chapter 9. We seek a minimizer that gives a function value
equal to zero. (There may be local minimizers that give a function value greater than zero.)
The advantages of this approach are that it uses all of our old machinery, and it can
also be used for overdetermined systems in which the number of equations is greater
than the number of variables. Often our system of equations arises from trying to ﬁt a
model to a set of data that have some errors; for example, in Section 5.3.4 we tried to ﬁt a
straight line x1 +tx2 to a set of 10 measurements of pollution data. This gave us a linear
least squares problem. If the variables in the model appear nonlinearly, for example as
x1tx2 +x3, then our problem becomes nonlinear least squares, and we again try to make the
model match the data as closely as possible. We studied such problems in the case studies
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 298 Page number 288
cyan magenta yellow black
288
Chapter 24. Nonlinear Systems
of Chapter 12 and 13. Alternate formulations of the data ﬁtting problem replace the 2-norm
with a 1-norm or ∞-norm.
The main disadvantage of the least squares approach is that derivatives are rather
expensive: if f (x) = ∥F(x)∥2, then
g(x) = 2J(x)T F(x),
H(x) = 2J(x)T J(x)+Z(x),
where Z(x) involves second derivatives of F. Thus evaluation of the gradient of f generally
requires O(n2) operations while the Hessian requires O(n3).
24.3
Newton-like Methods
Newton-like methods are the most popular algorithms for solving nonlinear equations.
24.3.1
Newton’s Method for Nonlinear Equations
Recall our general scheme for function minimization, Algorithm 9.1. The Newton search
direction was deﬁned by H(x(k))p(k) = −g(x(k)).
We derived Newton’s method by ﬁtting a quadratic function to a function that we
were trying to minimize. Equivalently, we can ﬁt a linear function to the gradient g:
g(x(k) + p)≈g(x(k))+H(x(k))p = 0 →H(x(k))p = −g(x(k)).
Similarly, for solving nonlinear equations, we derive Newton’s method by ﬁtting a linear
function to F:
F(x(k) + p)≈F(x(k))+J(x(k))p = 0 →J(x(k))p = −F(x(k)).
This gives us the search direction p(k). What about the stepsize αk? For nonlinear equa-
tions there is no notion of downhill and no natural notion of progress because there is no
function f . So we just eliminate the linesearch and set αk = 1, or else we use ∥F(x)∥to
measure progress. The resulting algorithm is Newton’s method for nonlinear equations:
Algorithm 24.1. Under some “standard assumptions” (second derivatives exist, the zero is
simple (i.e., the Jacobian matrix is nonsingular at the zero), etc.), the algorithm is guar-
anteed to converge to a solution if started close enough to it, and the convergence rate is
quadratic.
Algorithm 24.1 Newton’s Method for Solving Nonlinear Equations
Given: An initial guess x(0) for the solution.
Set k = 0.
while x(k) is not a good enough solution,
Find a direction p(k) by solving J(x(k))p(k) = −F(x(k)).
Set x(k+1) = x(k) +αkp(k), where αk is a scalar.
Set k = k +1.
end

November 20, 2008 10:52
sccsbook
Sheet number 299 Page number 289
cyan magenta yellow black
24.3. Newton-like Methods
289
Alternatively, we can apply a trust region method for solving nonlinear equations.
In this case we determine the step p(k) by solving the problem
min
p ∥F(x)+J(x)p∥
subject to
∥p∥≤h.
The objective function is a linear approximation to F(x + p), obtained from Taylor series.
Solving this problem leads to the Levenberg–Marquardt formula
(J(x)T J(x)+λI)p = −J(x)T F(x)
for an appropriate choice of the parameter λ. See Section 9.4 for a discussion of the choice
of norm and the choice of h.
We experiment with Newton’s method in the next challenge.
CHALLENGE 24.1.
Write MATLAB statements to apply 5 steps of Newton’s method to the problem
x2y3 + xy = 2,
2xy2 + x2y + xy = 0,
starting at the point x = 5, y = 4.
24.3.2
Alternatives to Newton’s Method
We have a variety of methods in the Newton family, just as we did for optimization, and
also slower but simpler ﬁxed-point iterations.
• Finite difference Newton method: If J is not available, we can approximate it using
ﬁnite differences. Again, as in optimization, this is not recommended; use the next
method instead.
• Inexact Newton method: Instead of solving the linear system J(x(k))p(k) = −F(x(k))
exactly, we can use an iterative method to obtain an approximate solution to this lin-
ear system. (See Chapter 28.) The usual choice of iterative method is GMRES, a
relative of conjugate gradients, and matrix-vector products are evaluated by differ-
encing F, just as discussed for the truncated Newton method of Section 9.5.2.
• Quasi-Newton methods: If storage is not a limitation, then instead of the inexact
Newton method, we can store and update an approximation to J. The usual formula
is Broyden’s method:
B(k+1) = B(k) + (y−B(k)s)sT
sT s
,
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 300 Page number 290
cyan magenta yellow black
290
Chapter 24. Nonlinear Systems
where y = F(x(k+1)) −F(x(k)) and s = x(k+1) −x(k). Then the secant condition,
discussed in Section 9.5.1, becomes
B(k+1)s = y,
and if sT v = 0, then Broyden’s method satisﬁes
B(k+1)v = B(k)v.
• Fixed-point iterations: These methods are related to stationary iterative methods,
used to solve linear systems of equations in Section 28.1. The idea is to reduce the
problem to solving a sequence of nonlinear equations in a single variable. As an
example, the nonlinear Gauss-Seidel iteration is given in Algorithm 24.2. These al-
gorithms are simple to program but very slow, since they make no use of derivatives.
Algorithm 24.2 Gauss–Seidel for Nonlinear Equations
Given: an initial guess x(0) for the system of nonlinear equations F(x) = 0.
Set k = 0.
while the solution is not good enough,
for j = 1,...,n,
Solve the jth equation Fj(x) = 0 for xj (k+1), keeping every variable except xj at its
most recently computed value (xℓ(k+1) if ℓ< j and x(k)
ℓ
if ℓ> j).
end
Set k = k +1.
end
In minimization using quasi-Newton methods, we used matrix updating techniques
to solve the linear system that determines the step; we do the same thing to solve F(x) = 0,
as discussed in the next two challenges.
CHALLENGE 24.2.
Consider the following function that computes a quasi-Newton direction for solving
the system of equations F(x) = 0:
function [p,B] = broyden(s,y,B,F)
% Given a previous Jacobian approximation
B,
% update it using s (the change in x)
% and y (the change in F)
% and then compute a Newton-like direction p.
B = B + (y-B*s)*s’/(s’*s);
p = -B \ F;

November 20, 2008 10:52
sccsbook
Sheet number 301 Page number 291
cyan magenta yellow black
24.4. Continuation Methods
291
The function is correct, but it is inefﬁcient. Identify two sources of the inefﬁciency and
propose remedies.
CHALLENGE 24.3.
In Broyden’s method for solving nonlinear equations, we need to solve a linear
system involving the n ×n matrix
B(k+1) = B(k) + (y−B(k)s)sT
sT s
.
Recall the Sherman–Morrison–Woodbury formula, discussed in the case study of Chap-
ter 7:
(A−ZVT )−1 = A−1 +A−1Z(I−VT A−1Z)−1VT A−1 .
If we have a way to solve linear systems involving B(k) using p multiplications, how long
would it take to solve a linear system involving B(k+1)?
As in the minimization case, we get a superlinear convergence rate for the Newton-
like methods if we start close enough to the solution and if the direction is (asymptotically)
close enough to the Newton direction. The ﬁxed-point iterations are generally easy to
implement, since they rely on a method to solve a nonlinear equation in a single variable,
but their convergence rate is only linear, not superlinear.
24.4
Continuation Methods
The superlinear convergenceresult for Newton’s method and its relatives is a major strength.
It says that once we are close enough to the solution, the method converges quite quickly.
But if we do not have a sufﬁciently good initial guess, then we might fail to converge at all,
and the same is true of ﬁxed-point iterations.
Continuation methods resolve this dilemma by always ensuring that we are close
enough to the solution to some problem, and gradually changing the problem to the one we
want to solve. Here is one way to do this:
The basic idea is that we want to solve F(x) = 0 but we might not have a good enough
initial guess to ensure (fast) convergence of Newton’s method. But we can choose some
easy problem Fa(x) = 0 for which we know the solution; for example, the solution to
Fa(x) = x −a = 0 is a. So we formulate a homotopy function
ρa(λ,x) = λF(x)+(1 −λ)Fa(x),
where λ is a scalar in the interval [0,1]. Note that the solution to ρa(0,x) = 0 is known
(for our example, it is just a), and the solution to ρa(1,x) = 0 is the solution to our desired
problem. This is just one way to construct such a ρa(λ,x).
Our solution strategy is to use an approximate solution to ρa(λ,x) = 0 for one value
of λ as the starting guess for the solution for a somewhat larger value of λ, thus ensuring
that the starting guess is good enough that Newton’s method performs well. If we iterate
this process, we can gradually increase λ to 1 and produce the solution to our original
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 302 Page number 292
cyan magenta yellow black
292
Chapter 24. Nonlinear Systems
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
λ
x(λ)
Figure 24.2. Paths of solutions in a continuation method. Ideally, all paths are
simple, as illustrated by the blue solid curve, but troubles can occur. Paths can have turning
points (black dotted), bifurcation points (red dot-dashed), or end points (green dashed), or
may wander to inﬁnity (magenta solid).
Algorithm 24.3 Continuation Method for Solving Nonlinear Equations
Given a function ρa, we set λ = 0 andx to the solution to Fa(x) = 0.
while λ < 1
Increase λ a little bit but keep λ ≤1.
Solve ρa(λ,x) = 0 using your favorite algorithm (Newton-like, etc.) withx as a start-
ing guess.
Call the solutionx.
end
Upon termination, we have computed x so that ρa(1,x) = 0, so x solves the problem
F(x) = 0.
problem. The basic algorithm is Algorithm 24.3. There are some worries in using this
method. We are essentially tracing out a path of solutions from λ = 0 to λ = 1, but this path
may be faulty, as illustrated in Figure 24.2.
• It may have turning points, which we can overcome by allowing λ to decrease
sometimes.
• It may bifurcate.
• The solution might fail to exist for some λ < 1, and then the path stops.
• The solution path might wander off to inﬁnity.
Therefore, the difﬁcult part of the theory is to construct ρa so that we can walk all
the way from λ = 0 to λ = 1 without failing to ﬁnd a solution at any intermediate step. We

November 20, 2008 10:52
sccsbook
Sheet number 303 Page number 293
cyan magenta yellow black
24.4. Continuation Methods
293
focus on methods that (almost always) construct a successful function ρa and that signal
failure, if it occurs, so that we can try a different function.
24.4.1
The Theory behind Continuation Methods
The solution path is well-behaved if ρ(λ,x) is transversal to zero. A function w is transver-
sal to zero on an open domain U if, for any point u ∈U such that w(u) = 0, the Jacobian
matrix at u has full rank. Note that the Jacobian matrix need not be square. Its dimensions
are length(w)× length(u).
The following challenge gives an example using this jargon.
CHALLENGE 24.4.
Consider using a continuation method to solve the problem
F(x) =

x2y3 + xy −2
2xy2 + x2y + xy

= 0.
Letting x = [x, y]T, our homotopy is
ρa(λ,x) = λF(x)+(1 −λ)(x−a).
(a) Compute the Jacobian matrix for ρa(λ,x).
(b) What needs to hold in order that the function ρa is transversal to zero on its domain?
Why is this likely to be true?
(c) Convince yourself that derivatives of all orders (ﬁrst, second, ...) exist for the functions
in this problem for [λ,x] ∈R3, since polynomials have an inﬁnite number of continuous
derivatives.
Our continuation method Algorithm 24.3 almost always works, thanks to a parame-
terized Sard’s theorem [151, Thm. 2.2]: Let U = Rn ×[0,1)×Rn and deﬁne a function
ρ : U →Rn that has two continuous derivatives and is transversal to zero on U. (We’ll call
its variables (a,λ,x), where x is a function of λ.) Choose a point a ∈Rn and deﬁne
ρa(λ,x) = ρ(a,λ,x).
Then the map ρa is transversal to zero on [0,1)×Rn for almost all a.
For almost all means except for a set of measure zero; i.e., if we choose a point a
at random, it has probability zero of giving a function ρa that is not transversal to zero on
[0,1)×Rn, and therefore probability zero of yielding a path that bifurcates or stops.
The parameterized Sard’s theorem gives us a recipe for a successful algorithm: Find
a function ρa(a,λ,x) that satisﬁes the assumptions of the parameterized Sard’s theorem.
Then choose a random value of a and follow the path from λ = 0 to λ = 1. If we encounter
a point that does not have a full-rank Jacobian, then we made an unlucky choice of a, so
we try again. Our algorithm traces out a solution path (λ,x(λ)), where ρa(λ,x(λ)) = 0.
Our solution path has a variety of other nice properties. If we also assume that the
equation ρa(0,x) = 0 has a unique solution x0 for any choice of a, then [151, Thm. 2.3] for
almost all a ∈Rn:
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 304 Page number 294
cyan magenta yellow black
294
Chapter 24. Nonlinear Systems
• The Jacobian matrix has (full) rank n at all points (λ,x).
• The path is smooth, does not intersect itself or any other solution path, and does not
bifurcate.
• The path has ﬁnite length in any compact subset of [0,1)×Rn.
• The path reaches the hyperplane λ = 1 as long as the Jacobians are bounded away
from rank-deﬁcient matrices. If the path does not reach λ = 1, then it goes to inﬁnity.
In summary, the path is very well-behaved! In fact, we can hope to walk along it.
The above result means that we almost always have a solution path that starts at λ = 0
and goes to our desired solution at λ = 1. But there may be a countable number of other
solution paths, some closed and some with two endpoints at λ = 1. So we need to be careful
not to step onto one of these other paths as we follow our good path.
Notes on the website illustrate how this theory can be used for one class of problems,
minimization of a convex function.
24.4.2
Following the Solution Path
To solve the nonlinear system of equations F(x) = 0, all we need to do is to follow the
solution path
ρa(λ,x) = λF(x)+(1 −λ)Fa(x) = 0
from λ = 0 to λ = 1. In some sense we don’t need to be too careful when following the
path—we don’t care about the values at any points in between λ = 0 and λ = 1. Unfortu-
nately, if we are not careful enough, we might jump to other solution paths that make no
progress.
In implementing the basic continuation method, Algorithm 24.3, there are two re-
maining issues: choosing the stepsize in λ and choosing the tolerance in the Newton-like
method. In practice, we aim to keep the increase in λ as big as possible (to minimize the
number of nonlinear systems we consider) while ensuring that x is a good enough initial
guess that the Newton-like method converges quickly. Similarly, we try to keep the toler-
ance as big as possible, to reduce the work in the Newton-like method, without losing track
of our path.
Issues of choosing a stepsize and tolerance are troublesome, and considerations are
similar to those in Chapter 20, for solving ordinary differential equations (ODEs). An al-
ternative to Algorithm 24.3 is to use our ODE machinery to solve the homotopy problem.
We do this by differentiating our path ρa(λ,x). We could differentiate with respect to λ,
but then the derivative would fail to exist at any turning point and we might get in trouble.
Instead, we’ll introduce a new independent variable and differentiate with respect to it. It
is most convenient to deﬁne s to be arc length and to write
ρa(λ(s),x(s)) = 0,
so
d
ds ρa(λ(s),x(s)) = 0.
We have the initial conditions
λ(0) = 0,
x(0) = a.

November 20, 2008 10:52
sccsbook
Sheet number 305 Page number 295
cyan magenta yellow black
24.4. Continuation Methods
295
When the solution path reaches λ(s) = 1, we are ﬁnished; the resulting x(s) solves our
nonlinear system. For uniqueness, we normalize so that
dλ
ds
2
+

dx
ds

2
= 1.
When Fa(x) = x−a, this system takes the form
dλ
ds F(x)+λJ(x)dx
ds −dλ
ds (x−a)+(1 −λ)dx
ds = 0,
dλ
ds
2
+
n
	
i=1
dxi
ds
2
= 1.
We summarize in Algorithm 24.4.
Algorithm 24.4 ODE-Continuation Method for Solving Nonlinear Equations
Solve the ODE
dλ
ds F(x)+λJ(x)dx
ds −dλ
ds (x−a)+(1 −λ)dx
ds = 0,
dλ
ds
2
+
n
	
i=1
dxi
ds
2
= 1,
with initial conditions λ(0) = 0 and x(0) = a.
When λ = 1, return the corresponding value x(1).
In principle, we could just plug the system into our favorite ODE solver, and this is
possible for prototyping algorithms, but in practice the ODE solver should be tailored to
this problem:
• If the arc length parameter s gets too long, restart with a new choice of a.
• Take care that we don’t wander too far from the solution path but that we don’t work
too hard in following it exactly.
• When the ODE solver passes the value λ = 1, use inverse interpolation, discussed
in the next challenge, to compute the value ˆs for which λ(ˆs) = 1.
CHALLENGE 24.5.
Inverse interpolation. Suppose we have a function f (t) and that we are given data
points (ti, fi), i = 1,...,n. Perhaps we choose to approximate f (t) by a function ˆf that is
a polynomial or a spline or a Fourier series. Then it is easy to compute an approximation
to f (t) for any given value of t by evaluating ˆf .
But suppose we want to ﬁnd an approximation to the solution to f (t) = 0. Our
function ˆf might be helpful if it is more easy to ﬁnd a solution to ˆf (t) = 0 than to ﬁnd a
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 306 Page number 296
cyan magenta yellow black
296
Chapter 24. Nonlinear Systems
POINTER 24.3. Software for Continuation Methods.
Hompack, by Layne Watson and co-workers, is a high-quality system for solving
nonlinear equations by continuation methods [153].
POINTER 24.4. Further Reading.
A thorough treatment of Newton’s method is given in a book by C. T. Kelley [88].
More variants on Newton’s method and ﬁxed-point iterations for solving nonlinear equa-
tions can be found in the classic book by Ortega and Rheinboldt [120].
Trust region methods for nonlinear equations are discussed, for example, in [28].
The foundation for continuation methods can be found in books by Allgower and
Georg [1] and T. Y. Li [103]. For more information on continuation (homotopy) methods,
consult papers by Watson [5, 151, 150, 152].
solution to f (t) = 0, but a better approach results from turning the graph of the problem on
its side.
If each of the values fi is distinct, then just as f is a function of t, it is also true that
t is a function of f . So let’s think of the data as ( fi,ti), i = 1,...,n, and let’s ﬁt a function
ˆt( f ) to this data. This is called inverse interpolation, since we obtain an approximation to
the function f −1(z) = t, and it is a useful method for solving a single nonlinear equation.
Now if we evaluate tcomp = ˆt(0), then tcomp is an approximate solution to f (t) = 0.
Write MATLAB statements to approximate the solution to an equation f (t) = 0 using
inverse interpolation with three function values (ti, fi), i = 1,...,3 given as input.

November 20, 2008 10:52
sccsbook
Sheet number 307 Page number 297
cyan magenta yellow black
B2
C1
C2
A1
A2
B1
Chapter 25 / Case Study
Variable-Geometry
Trusses: What’s Your
Angle?
Imagine that we have attached 3 members (beams) together to form a triangle (triangular
truss) A1B1C1. This is the base of a platform, shown in blue in Figure 25.1. Now take
3 more members and form a triangle A2B2C2 from them. This is the (red) “top” of the
platform (truss). We use 6 more ﬁxed-length members to attach the top to the bottom:
• Node (vertex) A1 is attached to B2 and C2.
• Node B1 is attached to A2 and C2.
• Node C1 is attached to A2 and B2.
Given the lengths of all of the members, our problem is to determine the (at most 16)
possible conﬁgurations of the resulting platform.
Computing the coordinates of the vertices is an exercise in geometry. As an example,
suppose that the members on the bottom all have length equal to ℓb and that the members
attaching the top to the bottom all have length ℓv. The bottom is an equilateral triangle with
each vertex having x, y, and z coordinates; we’ll ﬁx it to lie in the plane z = 0, with the
coordinates of the vertices deﬁned as
⎡
⎣
A1
B1
C1
⎤
⎦=
⎡
⎣
0,
0,
0
0,
ℓb,
0
ℓb cos(π/6),
ℓb sin(π/6),
0
⎤
⎦.
We could use the 9 coordinates of the top vertices as our variables, but this would introduce
a lot of redundancy into the equations. Instead we choose to work with three angles from
which the 9 coordinates can be computed. Let θC be the angle that triangle A1B1C2 makes
with the plane containing the bottom. We can compute the coordinates of C2 by considering
the right triangle with vertices C2, the vertical projection of C2 onto the plane of the bottom,
and the midpoint M1 = (A1+ B1)/2 of the member connecting A1 and B1. The length of the
hypotenuse is hC =

ℓ2v −∥M1 −B1∥2 (using information from the triangle B1M1C2). We
297
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 308 Page number 298
cyan magenta yellow black
298
Chapter 25. Case Study: Variable-Geometry Trusses
B2
C1
C2
A1
A2
B1
Figure 25.1. Truss from Watson example. The base, with nodes A1, B1, and C1,
is shown in blue and the top, with nodes A2, B2, and C2, in red. See the website for a
MATLAB ﬁle that generates a rotatable image.
see that relative to the midpoint M1, the y-coordinate of C2 is the same, the x-coordinate is
displaced by hC cos(θC), and the z-coordinate is displaced by hC sin(θC). Similar reasoning
leads to formulas for the coordinates of A2 and B2.
CHALLENGE 25.1.
Let θA be the angle that triangle A2B1C1 makes with the plane containing the bottom,
and similarly for θB and θC. Let dA = h A cosθA and similarly for dB and dC. Convince
yourself that the three nodes of the top of the platform have coordinates
⎡
⎣
A2
B2
C2
⎤
⎦=
⎡
⎣
(B1 +C1)/2
(A1 +C1)/2
(A1 + B1)/2
⎤
⎦+
⎡
⎣
dA cos(π/3),
dA sin(π/3),
h A sin(θA)
dB cos(−π/3),
dB sin(−π/3),
h B sin(θB)
dC,
0,
hC sin(θC)
⎤
⎦.
Now that we have the six nodes of the platform, we can verify that a given set of
angles θA,θB,θC yields a valid conﬁguration by checking that the resulting lengths of the
three members on top match the speciﬁed lengths ℓAB, ℓBC, and ℓAC:
F(θ) =
⎡
⎣
∥A2 −B2∥2 −ℓ2
AB
∥B2 −C2∥2 −ℓ2
BC
∥A2 −C2∥2 −ℓ2
AC
⎤
⎦=
⎡
⎣
0
0
0
⎤
⎦.
(25.1)
This is a system of three nonlinear equations in three variables, and we investigate how the
methods of Chapter 24 perform on it.

November 20, 2008 10:52
sccsbook
Sheet number 309 Page number 299
cyan magenta yellow black
299
Figure 25.2. Distinct conﬁgurations found for Platform C.
Our ﬁrst idea for an algorithm might be to solve the system by choosing some dif-
ferent starting guesses and running our favorite nonlinear equation solver on the problem,
starting from each of the guesses. A better idea might be to use a continuation method, but
this requires us to construct an easy function. We’ll experiment with two homotopies, one
derived from geometric reasoning and one derived from algebraic conversion to a polyno-
mial system of equations.
Notice that if we are given three angles, we can easily determine the lengths ˆℓAB,
ˆℓBC, and ˆℓAC of the top members. So we can construct a geometric homotopy that walks
from a truss with these lengths to one with the desired lengths. For each value of λ we
compute angles corresponding to the lengths
ℓj,λ = λℓj +(1 −λ)ˆℓj,
j = AB, BC, AC.
Let’s see how well it works.
CHALLENGE 25.2.
Use the geometric homotopy to solve four problems, with ℓv = 34.5, ℓb = 48, and
the lengths of the top members given by
Platform A:
35,
30,
40.
Platform B:
30,
30,
30.
Platform C:
35,
40,
45.
Platform D:
10,
10,
10.
In particular, compute the coordinates of the vertices of the top triangle and see how many
unique solutions you can ﬁnd.
For initial angles, use ˆθA = π/6, ˆθB = 7π/16, ˆθC = π/4, the negatives of these values,
these values plus π, and minus these values minus π, giving 64 points in all. Solve each
of the four problems, using the continuation algorithm started from the 64 initial angles.
Compare with using fsolve with these 64 starting points.
To construct a polynomial homotopy, we use a clever variable transformation [5,
4]. Notice that the three equations in (25.1) involve cos, sin, cos2, and sin2 of the three
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 310 Page number 300
cyan magenta yellow black
300
Chapter 25. Case Study: Variable-Geometry Trusses
POINTER 25.1. Further Reading.
This case study solves a problem taken from [4, 5]. Platforms such as these are
lightweight structures with multiple conﬁgurations that require little storage space. They
are used, for example, as building blocks for manipulator arms on spacecraft and for other
robots. Even more interesting is the analysis of a Stewart platform, in which the vertical
members have adjustable lengths. See, for example, http://en.wikipedia.org/
wiki/Stewart_platform.
unknown angles. If
tA = tan(θA/2),
then
cosθA = 1 −t2
A
1 +t2
A
, sinθA =
2tA
1 +t2
A
.
Making this substitution into (25.1) and then multiplying the ﬁrst and third equations by
(1 +t2
A)2 makes the system polynomial in the variable tA. Applying this same transforma-
tion for the other two variables gives us a system of three polynomial equations, each of
degree 4. A theorem of Bezoit tells us that there are 43 = 64 solutions, counting multiplic-
ities, although it turns out that in this problem 48 of them are inﬁnite and not of practical
use.
The authors [5, 4] suggest using a homotopy with a polynomial with the same struc-
ture: we want it to have 16 solutions with the highest-order terms involving the same
variables. But we need it to be solved easily; for example:
(x2
1 −ˆb)(x2
2 −ˆc) = 0,
(x2
2 −ˆa)(x2
3 −ˆb) = 0,
(x2
3 −ˆc)(x2
1 −ˆa) = 0,
where ˆa, ˆb, and ˆc are three numbers. Note that there are 16 real solutions to our easy prob-
lem: (±
√
ˆa,±
√
ˆc,±

ˆb) and (±

ˆb,±
√
ˆa,±
√
ˆc). If we call our real polynomial problem
p(x) = 0 and our easy problem q(x) = 0, then our homotopy becomes
ρ(λ,x) = λp(x)+(1 −λ)q(x).
We use this homotopy, started from each of the 16 solutions to the easy problem.
CHALLENGE 25.3.
Use the polynomial homotopy to compute conﬁgurations of the four platforms and
compare with using fsolve to solve q(x) = 0 with the same 64 initial guesses from Chal-
lenge 25.2, using, for example, ˆa = 1, ˆb = 4, and ˆc = 9.
In Figure 25.2 we display the conﬁgurations we found for Platform C. One lesson
to take from these experiments is that knowledge of the problem gives great insight into
potential solution algorithms, as illustrated by the geometric homotopy.

November 20, 2008 10:52
sccsbook
Sheet number 311 Page number 301
cyan magenta yellow black
Chapter 26 / Case Study
Beetles,
Cannibalism, and
Chaos: Analyzing a
Dynamical System
Model
The evolution of a system over time can be described by a set of equations called a dynam-
ical system. In this case study, we use a dynamical system to model the life cycle of ﬂour
beetles in order to estimate key biological parameters that describe their behavior.
If you open a container of ﬂour and see small red rods among the powder, you are
probably looking at confused beetles (Tribolium confusum) or red beetles (Tribolium cas-
taneum), pictured in Figure 26.1. These insects progress through several stages of life,
including egg (2–4 days), larva (approximately 14 days), pupa (approximately 14 days),
and adult (3 years or more). Their life cycle is complicated by one additional fact: they are
cannibalistic. Adults and larvae eat eggs, pupae, and immature adults, and adults also eat
larvae.
By using a dynamical system to model the ﬂour beetle’s life cycle, we can estimate
key parameters of biological signiﬁcance that describe their behavior. At the same time,
we illustrate some mathematical properties of dynamical systems.
The Model
To try to understand the population dynamics, entomologists have developed a model of
the beetles with three stages:
• L(t) is the number of (feeding) larvae at time t.
• P(t) is the number of nonfeeding larvae, pupae, and immature adults at time t.
• A(t) is the number of mature adults at time t.
We deﬁne ﬁve coefﬁcients of interaction, setting all other ones to zero:
• b > 0 is the average number of larvae recruited (i.e., tended) by each adult.
• 0 ≤μL ≤1 is the probability that a larva dies from a cause other than cannibalism.
301
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 312 Page number 302
cyan magenta yellow black
302
Chapter 26. Case Study: Beetles, Cannibalism, and Chaos
Figure 26.1. Red beetles. Actual length: approximately 3 mm. The image c⃝Alex
Wild, used with permission; all rights reserved.
• 0 ≤μA ≤1 is the probability that an adult dies from a cause other than cannibalism.
• e−cea A(t) is the probability that an egg is not eaten by an adult between time t and
time t + 1. The value cea (denoting interaction between eggs and adults) is a rate
constant.
• e−cel L(t) is the probability that an egg is not eaten by a larva between time t and time
t +1.
• e−cpa A(t) is the probability that a pupa is not eaten by an adult between time t and
time t +1.
The rate that adults eat larvae is small, and we set it to zero.
The model proposed by Dennis et al. [39] is10
L(t +1) = bA(t)exp(−cea A(t)−celL(t)),
(26.1)
P(t +1) = L(t)(1 −μL),
(26.2)
A(t +1) = P(t)exp(−cpa A(t))+ A(t)(1 −μA).
(26.3)
Time t is measured in 14-day units. Since L, P, and A can take on noninteger values, we
need to interpret their values as the average numbers of individuals over the 14-day period.
10The notation exp(y) means ey.

November 20, 2008 10:52
sccsbook
Sheet number 313 Page number 303
cyan magenta yellow black
Equilibria and Stability
303
CHALLENGE 26.1.
Let b = 11.6772, μL = 0.5129, cel = 0.0093, cea = 0.0110, cpa = 0.0178, L(0) = 70,
P(0) = 30, and A(0) = 70. To get some experience with this model, plot the populations
L, P, and A for 100 time units for three sets of data: μA = 0.1, 0.6, and 0.9. Describe the
behavior of the populations in these three cases as if you are speaking to someone who is
not looking at the graphs.
Equilibria and Stability
It is interesting to determine equilibria populations, values for the initial numbers of lar-
vae, pupae, and adults for which the population remains constant. We denote these as
Af ixed, L f ixed, and Pf ixed. Of course, one such solution is the extinction solution of
zero larvae, zero pupae, and zero adults. If cel = 0, then Dennis et al. provide a nonzero
solution, valid when b > μA/(1 −μL):
Af ixed = log(b(1 −μL)/μA)/(cea +cpa),
(26.4)
L f ixed = bAf ixed exp(−cea Af ixed),
(26.5)
Pf ixed = L f ixed(1 −μL).
(26.6)
An equilibrium solution is called stable if a colony of beetles with initial population A(0) ≈
Af ixed, L(0) ≈L f ixed, and P(0) ≈Pf ixed tends to approach these values as time passes;
otherwise the solution is unstable. Let xt be a vector with elements L(t), P(t), and A(t).
Then our equations (26.1) – (26.3) are
xt+1 = F(xt),
where
F(xt) =
⎡
⎣
bA(t)exp(−cea A(t)−celL(t)),
L(t)(1 −μL),
P(t)exp(−cpa A(t))+ A(t)(1 −μA)
⎤
⎦.
By Taylor series,
xt+1 = F(xt)≈xf ixed +J(xf ixed)(xt −xf ixed),
where J(xf ixed) is the Jacobian of F, i.e., the 3×3 matrix of partial derivatives. Therefore,
xt+1 −xf ixed≈J(xf ixed)(xt −xf ixed).
From Challenge 5.15, we conclude that the new point xt+1 tends to be closer to xf ixed
than xt is if all eigenvalues of the Jacobian, evaluated at xf ixed, are inside the unit circle.
Therefore, each equilibrium solution for our beetle problem can be labeled as stable or
unstable depending on whether or not the eigenvalues of the Jacobian matrix J(xf ixed) all
lie within the unit circle.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 314 Page number 304
cyan magenta yellow black
304
Chapter 26. Case Study: Beetles, Cannibalism, and Chaos
CHALLENGE 26.2.
Let μL = 0.5, μA = 0.5, cel = 0.01, cea = 0.01, and cpa = 0.01. Plot Af ixed, L f ixed,
and Pf ixed for b = 1.0,1.5,2.0,...,20.0. To compute these values for each b, use fsolve,
started from the solution with cel = 0, to solve the equations F(x) = F(x)−x = 0. Provide
fsolve with the Jacobian matrix for the function F, and on your plot, mark the b values
for stable equilibria with plus signs.
Stability and Bifurcation
Let’s investigate stability a bit more. We know that when b > μA/(1 −μL), equations
(26.4)–(26.6) give a constant solution to our population model. This means that if we
start the model with exactly these numbers of larvae, pupae, and adults, we expect the
population at each time to remain constant. Let’s see what happens numerically. We’ll
study the solution as a function of μA, with the other parameters set to a particular choice
of values. We want to know whether the solution for large values of t is constant, periodic,
or chaotic with no regular pattern. To decide this, we make a bifurcation diagram: we
run the LPA iteration (26.1)–(26.3) for various values of μA and plot the last 100 values of
the LPA iteration as a function of μA.
CHALLENGE 26.3.
(a) Let μL = 0.5128, cel = 0.0, cea = 0.01, and cpa = 0.09. For μA = 0.02,0.04,...,1.00,
use the LPA iteration (26.1) – (26.3) to determine the population for 250 time units. On a
single graph, plot the last 100 values as a function of μA to produce the bifurcation diagram.
(b) Determine the largest of the values μA = 0.02,0.04,...,1 for which the constant solu-
tion is stable (i.e., well-conditioned).
(c) Explain why the bifurcation diagram is not just a plot of L f ixed vs. μA when the system
is unstable.
(d) Give an example of a value of μA for which nearby solutions cycle between two ﬁxed
values. Give an example of a value of μA for which nearby solutions are chaotic (or at least
have a long cycle).
Nurturing vs. Cannibalism: Estimating the Parameters
Now that we understand some properties of our dynamical system model xt+1 = F(xt), we
use some observed data to try to determine the parameter values. Desharnais and Liu [43]
observed four colonies of red beetles for 266 days, making observations every 14 days.
With least squares, we can estimate the six parameters in our model using this data. Aside
from the initial values L(0), P(0), and A(0), Desharnais and Liu give us three data values

November 20, 2008 10:52
sccsbook
Sheet number 315 Page number 305
cyan magenta yellow black
Nurturing vs. Cannibalism: Estimating the Parameters
305
Lobserved(t), Pobserved(t), and Aobserved(t) for each time t = 1,...,19. Given values of
the six parameters in our model, we can compute predicted values of the populations at
each of these times, so we would like to determine parameters that minimize the difference
between the predictions and the observations. Since Desharnais and Liu tell us that errors
in the logs of the observed values are approximately equal, we minimize the least squares
function
19
	
t=1
(log(Lobserved(t))−log(Lpredicted(t)))2
+
19
	
t=1
(log(Pobserved(t))−log(Ppredicted(t)))2
+
19
	
t=1
(log(Aobserved(t))−log(Apredicted(t)))2,
where Lpredicted(t), Ppredicted(t), and Apredicted(t) denote the values obtained from (26.1)–
(26.3).
CHALLENGE 26.4.
(a) Use lsqnonlin to solve the least squares minimization problem, using each of the
four sets of data in beetledata.m. In each case, determine the six parameters (μL, μA,
cel, cea, cpa, and b). Set reasonable upper and lower bounds on the parameters, and perhaps
start the least squares iteration with the guess μL = μA = 0.5, cel = cea = cpa = 0.1, and
b = 10. Print the solution parameters and the corresponding residual norm.
(b) Compare your results with those computed by Dennis et al., found in param_dl in
beetledata.m. Include a plot that compares the predicted values with the observed
values.
When I asked 25 students to solve Challenge 26.4 with the data from the second
colony of beetles, they obtained 13 different answers, all of them different from mine!
Unfortunately, none of them gave a good ﬁt to the measured data. When solving a nonlinear
system of equations by formulating it as a nonlinear least squares problem, it is important
to realize that the function may be nonconvex, which means that there might be many local
minimizers. This makes it quite difﬁcult for an optimization routine like lsqnonlin to
ﬁnd the globally optimal solution. For difﬁcult optimization problems, it sometimes helps
to use a continuation method, so let’s try that.
CHALLENGE 26.5.
Consider the data for the second beetle colony. For each value b = 0.5,1.0,...,50.0,
minimize the least squares function by using lsqnonlin to solve for the ﬁve remaining
parameters. For each value of b after the ﬁrst, start the minimization from the solution
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 316 Page number 306
cyan magenta yellow black
306
Chapter 26. Case Study: Beetles, Cannibalism, and Chaos
POINTER 26.1. Further Reading.
The red ﬂour beetle is quite important; its genome was the ﬁrst beetle genome se-
quenced [83].
The lifespan and population data are taken from data of Desharnais and Liu [43]. The
dynamical systems model that we use was developed by Dennis, Desharnais, Cushing, and
Costantino [39]. The developers of the LPA model revisited the problem in [29].
An excellent introduction to dynamical systems, stability, and bifurcation diagrams
is given in a textbook by Scheinerman [134].
determined for the previous value of b. In what sense is this a continuation method? Plot
the square root of the least squares function vs. b, and determine the best set of parameters.
How sensitive is the function to small changes in b?
Perform further calculations to estimate the forward error (how sensitive the optimal
parameters are to small changes in the data) and the backward error (how sensitive the
model is to small changes in the parameters).
Dennis et al. evaluated the LPA model using a less demanding criterion; they just
compared the 1-step predictions of the model with the true values. (This is akin to a local
error evaluation for an ordinary differential equation model; we just ask how much error is
produced in a single step, assuming that correct values were given at the previous step.) It
would be interesting to repeat the sensitivity analysis under this error criterion.

November 20, 2008 10:52
sccsbook
Sheet number 317 Page number 307
cyan magenta yellow black
Unit VII
Sparse Matrix Computations, with Application 
to Partial Differential Equations
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 318 Page number 308
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 319 Page number 309
cyan magenta yellow black
309
In Unit II, we saw the importance of using the appropriate decomposition to solve
matrix problems. As the matrix becomes large, these decompositions become expensive. In
this unit, we concentrate on how the cost can be reduced if the matrix is sparse; i.e., if there
are many zeros. Such matrices arise in many applications but are particularly common in
ﬁnite difference and ﬁnite element models of partial differential equations, as introduced in
Chapter 23.
In Chapter 27 we consider reordering the equations and unknowns in a linear system
in order to reduce the number of nonzero elements in the matrix factors. Chapter 28 takes
a different approach, computing an approximate solution to a linear system or eigenvalue
problem without changing the matrix at all.
Four case studies illustrate the use of sparse matrices. In Chapter 29, we solve an op-
timization problem in order to understand the stresses on a twisted bar. Chapter 30 shows
how structure in some problems can be exploited to obtain a fast solver. Eigenvalue prob-
lems for differential equations are studied in Chapter 31. Finally, Chapter 32 introduces
multigrid methods, a useful technique for solving grid-based problems or for precondition-
ing Krylov subspace methods.
MASTERY: After you have worked through this unit, you should be able to do the follow-
ing:
• Convert a matrix from its (usual) dense representation to sparse format, and from
sparse format to dense.
• Determine which elements of a matrix ﬁll in when doing Cholesky decomposition.
• Determine which elements are in the proﬁle of a matrix.
• Given a sparse matrix, determine its graph. Given a graph, determine the sparsity of
the corresponding matrix.
• Apply our reordering strategies (Cuthill–McKee, minimum degree, and nested dis-
section) to a given graph.
• Apply the Gauss–Seidel iteration to a given system of linear equations (algebraically
or geometrically).
• Construct a basis for a Krylov subspace and, in particular, construct an orthogonal
basis.
• Explain why the Krylov methods terminate in at most n iterations with the exact
solution.
• Use the CG algorithm and its convergence results.
• Count the multiplications per iteration for the Arnoldi algorithm or the conjugate
gradient algorithm.
• Determine the storage requirements for the Arnoldi algorithm or the conjugate gra-
dient algorithm.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 320 Page number 310
cyan magenta yellow black
310
• Use the convergence results for GMRES.
Example: Show that if the preconditioned matrix has only 5 distinct eigenvalues,
then GMRES must terminate in at most 5 iterations with the true solution.
Example: Show that if the preconditioned matrix has 5 small clusters of eigenvalues,
then after 5 iterations, GMRES produces a good approximate solution if its eigenvec-
tor matrix is well-conditioned.
• Implement a preconditioning algorithm such as Gauss–Seidel.
• Identify iterative algorithms for ﬁnding some eigenvalues or singular values of a
sparse matrix.
• Solve optimization problems involving sparse matrices.
• Use the Schur decomposition to solve Sylvester equations.
• Write fast algorithms to solve problems whose eigenvectors are related to the Fourier
transform.
• Use matrix eigenvalue algorithms to approximate eigenvalues and eigenfunctions of
differential operators.
• Form a sequence of nested grids.
• Transfer values between grids in multigrid, given a restriction operator and an inter-
polation operator.
• Explain and use the V-cycle and nested grids algorithms.

November 20, 2008 10:52
sccsbook
Sheet number 321 Page number 311
cyan magenta yellow black
x   0   0
0   x   0
0   x   x
0   x   x
1
2
3
4
1
2
3
Chapter 27
Solving Sparse Linear
Systems: Taking the
Direct Approach
In this chapter, we explore the importance of wise ordering of equations and unknowns
when solving large, sparse systems of linear equations. Our examples are drawn from
solution of partial differential equations, and such problems are a prime source of such
linear systems. Nothing that we do is speciﬁc to these problems, though, and you may
prefer to work with a matrix from a standard test set (e.g., wathen from MATLAB’s
gallery function, or a matrix from the Matrix Market [106].
In addition to direct methods such as the Cholesky decomposition that we consider
in this chapter, we should consider the iterative methods discussed in the next chapter
whenever we have a sparse matrix problem.
27.1
Storing and Factoring Sparse Matrices
There are many possible storage schemes for sparse matrices. MATLAB chooses a typical
one: store the indices and values of the nonzero elements in column order, so
⎡
⎢⎣
2
0
0
0
0
5
7
0
1
0
6
0
0
0
0
8
⎤
⎥⎦
is stored as
(1,1)
2
(3,1)
1
(2,2)
5
(2,3)
7
(3,3)
6
(4,4)
8
.
Storing a sparse matrix in this way takes 3nz storage locations, where nz is the number of
nonzeros. For small matrices, there is not much difference in storage space between dense
and sparse storage schemes, but for problems with thousands or millions of unknowns, it
matters a lot! If we have a matrix that has only three nonzeros per row, for example, then
we require 9n locations to store it in sparse format rather than the n2 required for dense,
and these numbers are quite different for large n.
311
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 322 Page number 312
cyan magenta yellow black
312
Chapter 27. Solving Sparse Linear Systems
POINTER 27.1. Existence, Uniqueness, and Stability.
For results on existence, uniqueness, and stability of solutions to linear systems of
equations, least squares problems, and eigenvalues, see the pointers in Chapter 5.
If our problem involves a sparse matrix A, then we would want its LU or Cholesky
factors to be sparse, too, but this is not always the case. Consider, for example, a linear
system involving the “arrowhead” matrix
Ax ≡
⎡
⎢⎢⎢⎢⎢⎣
×
×
×
×
×
×
×
×
0
0
0
0
×
0
×
0
0
0
×
0
0
×
0
0
×
0
0
0
×
0
×
0
0
0
0
×
⎤
⎥⎥⎥⎥⎥⎦
⎡
⎢⎢⎢⎢⎢⎣
x1
x2
x3
x4
x5
x6
⎤
⎥⎥⎥⎥⎥⎦
=
⎡
⎢⎢⎢⎢⎢⎣
b1
b2
b3
b4
b5
b6
⎤
⎥⎥⎥⎥⎥⎦
≡b,
where × denotes a nonzero value (we don’t care what it is) and 0 denotes a zero. The
number of nonzeros is 3n −2. In the ﬁrst step of the LU decomposition, we add some
multiple of the ﬁrst row to every other row in order to put zeros in the off-diagonal elements
of column 1. Disaster! The matrix is now dense, with n(n −1)+1 nonzeros!
There is a simple ﬁx for this problem, though. Let’s rewrite our problem by moving
the ﬁrst column and the ﬁrst row to the end:
⎡
⎢⎢⎢⎢⎢⎣
×
0
0
0
0
×
0
×
0
0
0
×
0
0
×
0
0
×
0
0
0
×
0
×
0
0
0
0
×
×
×
×
×
×
×
×
⎤
⎥⎥⎥⎥⎥⎦
⎡
⎢⎢⎢⎢⎢⎣
x2
x3
x4
x5
x6
x1
⎤
⎥⎥⎥⎥⎥⎦
=
⎡
⎢⎢⎢⎢⎢⎣
b2
b3
b4
b5
b6
b1
⎤
⎥⎥⎥⎥⎥⎦
.
We have replaced A by PAPT , where
P =
⎡
⎢⎢⎢⎢⎢⎣
0
1
0
0
0
0
0
0
1
0
0
0
0
0
0
1
0
0
0
0
0
0
1
0
0
0
0
0
0
1
1
0
0
0
0
0
⎤
⎥⎥⎥⎥⎥⎦
is a permutation matrix. A permutation matrix is just an identity matrix with its rows
reordered, and this one can be represented by the reordering sequence r = [2,3,4,5,6,1].
In the next challenge, we see the dramatic effect that reordering has on sparsity.

November 20, 2008 10:52
sccsbook
Sheet number 323 Page number 313
cyan magenta yellow black
27.2. What Matrix Patterns Preserve Sparsity?
313
CHALLENGE 27.1.
(a) Verify that the reordered system has the same solution as the original one, and that
when we use Gauss elimination (or the Cholesky decomposition) on our reordered system,
no new nonzeros are produced. (In particular, the Cholesky factor has at most 2n −1
nonzeros.) Compare the work in factoring A with that for factoring PAPT .
(b) Show that our reordered system is
(PAPT )(Px) = Pb.
Reordering the variables and equations is a powerful tool for maintaining sparsity
during factorization, and we investigate some strategies for determining good permutations.
Notice that in order to preserve symmetry, we always pair P with PT in reordering A, but for
nonsymmetric problems it can be advantageous to choose a different column permutation
in place of PT .
27.2
What Matrix Patterns Preserve Sparsity?
Finding the reordering that minimizes the number of nonzeros in L for the Cholesky fac-
torization or U in the LU factorization is generally too expensive. Therefore, we rely on
heuristics that give us an inexpensive algorithm to ﬁnd a reordering but are not guaranteed
to produce an optimal ordering. Usually the heuristics do well, but sometimes they produce
a very bad reordering. The heuristics all aim to permute the matrix to a form that has little
ﬁll-in (new nonzeros produced in the factorization), so let’s investigate nonzero patterns
for which sparsity is preserved.
CHALLENGE 27.2.
(a) A matrix A is a band matrix with bandwidth ℓif ajk = 0 whenever | j −k| > ℓ. (An
important special case is that of a tridiagonal matrix, with ℓ= 1.) Show that the factor L
(or U) for A also has bandwidth ℓ.
(b) Deﬁne the proﬁle of a matrix to stretch from the ﬁrst nonzero in each column to the
main diagonal element in the column, and from the ﬁrst nonzero in each row to the main
diagonal element. For example, if
A =
⎡
⎢⎢⎢⎢⎢⎣
×
0
×
0
0
0
0
×
0
0
×
0
0
0
×
0
×
0
×
0
0
×
0
0
0
0
×
0
×
0
0
×
0
0
0
×
⎤
⎥⎥⎥⎥⎥⎦
,
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 324 Page number 314
cyan magenta yellow black
314
Chapter 27. Solving Sparse Linear Systems
then the proﬁle of A contains its nonzeros as well as those zeros marked with ⊗:
⎡
⎢⎢⎢⎢⎢⎣
×
0
×
0
0
0
0
×
⊗
0
×
0
0
0
×
0
×
0
×
⊗
⊗
×
⊗
0
0
0
×
⊗
×
0
0
×
⊗
⊗
⊗
×
⎤
⎥⎥⎥⎥⎥⎦
,
Show that the factor L for a symmetric matrix A has no nonzeros outside the proﬁle of A.
From Challenge 27.2 we conclude that a good reordering strategy might try to pro-
duce a reordered matrix with a small bandwidth or a small proﬁle.
27.3
Representing Sparsity Structure
The sparsity of a matrix can be encoded in a graph. For example, a symmetric matrix
A =
⎡
⎢⎢⎢⎢⎢⎣
×
0
×
0
0
0
0
×
0
0
×
×
×
0
×
0
×
0
0
0
0
×
0
0
0
×
×
0
×
0
0
×
0
0
0
×
⎤
⎥⎥⎥⎥⎥⎦
has upper-triangular nonzero off-diagonal elements a13,a25,a26,a35 and corresponds to a
graph with 6 nodes, one representing each row (or equivalently, each column), and four
edges, connecting nodes (1,3), (2,5), (2,6), and (3,5). (We omit the edges corresponding
to the main diagonal elements, and assume that these elements are nonzero. This is always
true for a positive deﬁnite matrix.)
In Figure 27.1 we draw the graph for the matrix S that is given in Figure 27.2, cor-
responding to the ﬁnite difference matrix for Poisson’s equation on the unit square, dis-
cretized with a 5 ×5 grid of unknowns. Notice that the degree of any node (the number of
edges it has) is at most 4, and that there are 4 nodes (nodes 1, 5, 21 and 25) of minimum
degree, which is 2.
The sparsity of a nonsymmetric matrix can also be represented by a graph. In this
case we use two sets of nodes, one for each row and one for each column, and draw an edge
from row node i to column node j when aij is nonzero. This is illustrated in Figure 27.3.
27.4
Some Reordering Strategies for Sparse Symmetric
Matrices
We now have the jargon and concepts necessary to discuss some reordering strategies. The
n ×n matrices A we consider in this section have three important properties:
• They are real symmetric (or complex Hermitian), so that element ajk = akj for
j,k = 1,...,n. This forces all of the eigenvalues to be real.

November 20, 2008 10:52
sccsbook
Sheet number 325 Page number 315
cyan magenta yellow black
27.4. Some Reordering Strategies for Sparse Symmetric Matrices
315
21
22
23
24
25
16
17
18
19
20
11
12
13
14
15
6
7
8
9
10
1
2
3
4
5
Figure 27.1. The graph corresponding to the matrix in Figure 27.2.
0
5
10
15
20
25
0
5
10
15
20
25
nz = 105
spy(S)
0
5
10
15
20
25
0
5
10
15
20
25
nz = 129
Cholesky factor of S
Figure 27.2. The sparsity pattern in the ﬁnite difference matrix S for Poisson’s
equation −uxx −uyy = f (x, y) on the unit square, discretized with a 5 × 5 grid of un-
knowns. The display was made with MATLAB’s spy function.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 326 Page number 316
cyan magenta yellow black
316
Chapter 27. Solving Sparse Linear Systems
x   0   0
0   x   0
0   x   x
0   x   x
1
2
3
4
1
2
3
Figure 27.3. A graph representing the sparsity of a general matrix. There is a
blue node for each row and a red node for each column.
• They are positive deﬁnite, so that all of the eigenvalues are positive.
• They are sparse, meaning that most of the matrix entries are zero, and the number
of nonzero elements grows as n rather than as n2 as the discretization is reﬁned.
The ﬁrst two properties ensure that if we perform Gauss elimination on the linear systems,
we never need to pivot for stability, interchanging rows of the matrix in order to put a larger
magnitude element on the main diagonal. Also, we can take advantage of the symmetry
of A and use the Cholesky decomposition of the matrix, factoring A = LL∗, where L is a
lower-triangular matrix. This requires half the work of Gauss elimination—but it is only
stable if A is positive deﬁnite.
Since we don’t need to pivot for stability, we are completely free to pivot to preserve
sparsity, and we’ll turn our attention to why this is necessary and how to do it effectively.
Strategy 1: Cuthill–McKee.
One of the oldest strategies is Cuthill–McKee, Algorithm
27.1, which uses the graph to order the rows and columns, working our way out from a
node of small degree.
Algorithm 27.1 Cuthill–McKee Reordering
Find a node with minimum degree and order it ﬁrst.
while some node remains unordered,
for each node that was ordered in the previous step,
Order all of the unordered nodes that are connected to it, in order of their degree.
end
end
Reverse Cuthill–McKee (doing a ﬁnal reordering from last to ﬁrst) often works even
better. The result of the ordering on matrix S is shown in Figure 27.4. The ordering tends
to give a matrix with small bandwidth.

November 20, 2008 10:52
sccsbook
Sheet number 327 Page number 317
cyan magenta yellow black
27.4. Some Reordering Strategies for Sparse Symmetric Matrices
317
0
5
10
15
20
25
0
5
10
15
20
25
nz = 105
S(r,r) after Cuthill−McKee ordering
0
5
10
15
20
25
0
5
10
15
20
25
nz = 115
chol(S(r,r)) after Cuthill−McKee ordering
Figure 27.4. The sparsity pattern after reordering S using reverse Cuthill–McKee.
0
5
10
15
20
25
0
5
10
15
20
25
nz = 105
S(r,r) after minimum degree ordering
0
5
10
15
20
25
0
5
10
15
20
25
nz = 116
chol(S(r,r)) after minimum degree ordering
Figure 27.5. The sparsity pattern after reordering S using the minimum degree algorithm.
Strategy 2: Minimum Degree.
The minimum degree strategy, Algorithm 27.2, is a
greedy strategy that removes nodes from the graph in order of degree. This strategy works
rather well in practice but it is relatively expensive, since the degree counts are updated
every time a node is deleted. In Figure 27.5, we see the results on our matrix S. The
reordering gives small proﬁle but not small bandwidth.
Algorithm 27.2 Minimum Degree Reordering
while some node remains unordered,
Choose a node that has minimum degree in the current graph, and order that node
next, removing it from the graph. (If there is a tie, choose any of the candidates.)
end
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 328 Page number 318
cyan magenta yellow black
318
Chapter 27. Solving Sparse Linear Systems
Strategy 3: Nested Dissection.
Nested Dissection, Algorithm 27.3, is a recursive algo-
rithm that breaks the graph into pieces. For our example, we bisect the 5 × 5 grid graph
vertically with a red separator and then bisect the remaining two pieces horizontally with
blue separators. Nested dissection orders the nodes in the remaining pieces ﬁrst, followed
by the nodes in the separators, and produces the following renumbering:
1
2
17
5
6
3
4
18
7
8
22
23
19
24
25
9
10
20
13
14
11
12
21
15
16
.
The results are shown in Figure 27.6. The matrix looks quite disordered, but the number of
nonzeros in the factor is smaller than for our original ordering because the proﬁle is small.
Algorithm 27.3 Nested Dissection Reordering
Start with one “piece” containing the whole graph.
while some piece of the graph has a large number of nodes,
Consider one such piece.
Try to break it into two pieces plus a separator, with
•
approximately the same number of nodes in the two pieces,
•
no edges between the two pieces,
•
a small number of nodes in the separator.
end
Then order the nodes piece by piece.
Finally, order the nodes in the separators.
In the next challenge, we construct the graph for a sparse matrix and try these three
reorderings on it.
CHALLENGE 27.3.
Draw the graph corresponding to the matrix
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
×
0
0
0
×
0
0
0
0
0
0
×
0
0
0
0
0
×
0
×
0
0
×
0
×
0
0
0
×
0
0
0
0
×
0
×
×
0
×
×
×
0
×
0
×
0
0
0
0
0
0
0
0
×
0
×
×
0
0
×
0
0
0
×
0
×
×
0
×
0
0
×
0
0
0
0
0
×
0
0
0
0
×
×
0
0
×
0
×
0
0
×
0
×
0
×
0
0
0
×
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
.

November 20, 2008 10:52
sccsbook
Sheet number 329 Page number 319
cyan magenta yellow black
27.4. Some Reordering Strategies for Sparse Symmetric Matrices
319
0
5
10
15
20
25
0
5
10
15
20
25
nz = 105
S(r,r) after nested dissection ordering
0
5
10
15
20
25
0
5
10
15
20
25
nz = 115
chol(S(r,r)) after nested dissection ordering
Figure 27.6. The sparsity pattern after reordering S using nested dissection.
Try each of the three reorderings on this matrix. Compare the sparsity of the Cholesky
factors of the reordered matrices with the sparsity of the factor corresponding to the original
ordering.
Strategy 4: Eigenvector Partitioning.
This method, Algorithm 27.4, is less intuitive
and much more expensive, but it produces useful orderings. Unlike the previous strategies,
we cannot determine the ordering by hand computation, since it involves an eigenvector
computation. Because of the expense compared to our other strategies, it should probably
only be used on matrices that are to be used multiple times.
Algorithm 27.4 Eigenvector Partitioning
First we form an auxiliary matrix, the Laplacian of the graph corresponding to our
sparse matrix. This matrix B has the same size and sparsity pattern as A. It has −1 in
place of each nonzero off-diagonal element of A, and the main diagonal elements of
B are set so that each of the row sums is zero.
The matrix B is symmetric and (by Gerschgorin’s theorem) has no negative eigenvalues.
It has a zero eigenvalue (since Be = 0, where e is the vector of all ones). We compute
the eigenvector v corresponding to its next smallest eigenvalue.
Partition the graph into two pieces, one corresponding to nodes with positive entries in
v, and the other containing the remaining nodes.
If desired, repeat the algorithm recursively on each of the two subgraphs formed by this
partition.
Order the nodes piece by piece.
The eigenvector computation is accomplished, for example, by asking the Lanczos
algorithm (see Chapter 28) to produce approximations to the two smallest eigenvalues and
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 330 Page number 320
cyan magenta yellow black
320
Chapter 27. Solving Sparse Linear Systems
0
5
10
15
20
25
0
5
10
15
20
25
nz = 105
S(r,r) after eigenpartition ordering
0
5
10
15
20
25
0
5
10
15
20
25
nz = 133
chol(S(r,r)) after eigenpartition ordering
Figure 27.7. The sparsity pattern after reordering S using eigenpartitioning.
POINTER 27.2. Software for Reordering.
MATLAB’s symrcm implements the reverse Cuthill–McKee ordering. MATLAB’s
symamd is an approximate minimum degree permutation; symmmd is exact but more ex-
pensive. Nested dissection and the eigenvector orderings are not built-in, but MATLAB’s
eigs can be used for the eigenvector computation. (If eigs complains about a singular
matrix, send it the Laplacian plus a multiple of the identity; this shifts the eigenvalues but
preserves the eigenvectors.) These two orderings are also available in a toolbox written by
Gilbert and Teng [57, 56].
their eigenvectors. We are only interested in the signs of the entries in the eigenvectors, so
we don’t need much accuracy. The results of our example are shown in Figure 27.7. The
matrix again looks quite disordered, but the proﬁle remains rather small. This algorithm is
not very effective on this matrix.
Bigger problems show trends more clearly. Instead of a 5 × 5 grid, let’s consider a
50 ×50, giving a matrix of size n = 2500. Here is a summary of our results:
Ordering
Nonzeros in L
Original
274689
Rev Cuthill–McKee
189345
Minimum deg
68828
Nested dissection
89733
Eigenpartition
86639
For this very regular graph, minimum degree works the best.
Now that we have our candidate algorithms, we can evaluate them using some test
problems.

November 20, 2008 10:52
sccsbook
Sheet number 331 Page number 321
cyan magenta yellow black
27.5. Reordering Strategies for Nonsymmetric Matrices
321
CHALLENGE 27.4.
You have been hired as a consultant by our start-up company, PoissonIsUs.com, to
advise us on solving linear systems of equations. Our business is to solve elliptic partial
differential equations in 2 and 3 dimensions. We have limited venture capital funding, so
we are starting with a very speciﬁc mission: to solve the Poisson equation
−uxx −uyy = f (x, y)
when (x, y) ∈ ⊂R2, or
−uxx −uyy −uzz = f (x, y,z)
when (x, y,z) ∈ ⊂R3. The complete problem speciﬁcations also include information
about the behavior of the solution u on the boundary of .
The standard method for solving such problems is to discretize using either ﬁnite
differences or ﬁnite elements, and then solve the resulting system of linear equations. In
order to get accurate estimates of the solution, this system is made very large, involving
thousands or millions of unknowns, so it is important to be very efﬁcient in our solution
algorithm. Your job is to evaluate some alternatives.
For testing purposes, we have developed two problems that we believe typical of
those that our customers will provide. In the ﬁrst problem, the domain is a sector of a circle,
and the differential equation is discretized using an adaptive ﬁnite element grid. In the
second, the domain is a three-dimensional box with discretization using ﬁnite differences.
Use slit2.m and laplace3d.m (found on the website) with n = 15 to generate the
linear systems.
Solve the linear systems using as many reorderings as possible: original matrix, re-
verse Cuthill–McKee ordering, (approximate) minimum degree ordering, nested dissec-
tion ordering, eigenvector ordering. (See Pointer 27.2.) Make a table reporting, for each
method,
• time to solve the system (include reordering, factorization, forward and back substi-
tution.)
• storage for the matrix factors.
• the ﬁnal relative residual ∥b −Axcomputed∥2/∥b∥2. (These should all be well below
the errors due to discretization, and so they will not be a factor in your recommenda-
tion.)
If possible, run larger problems, too. Considering the two-dimensional and three-dimensional
problems separately, report to the CEO of PoissonIsUs.com the performance of the various
methods and your recommendation for what ordering to use.
27.5
Reordering Strategies for Nonsymmetric Matrices
If your linear system involves a matrix that is nonsymmetric, or symmetric but not pos-
itive deﬁnite, then reordering for the stability of the factorization must take priority over
reordering for sparsity. See Pointer 27.3 for references.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 332 Page number 322
cyan magenta yellow black
322
Chapter 27. Solving Sparse Linear Systems
POINTER 27.3. Further Reading.
For more information on sparse matrices, reordering strategies, and graph representa-
tion, George and Liu [55] discuss the symmetric positive deﬁnite case. Duff, Erisman, and
Reid [45] discuss the general case, including the complications added by stability consider-
ations. Timothy Davis’s book [35] gives a tutorial tour of a stripped-down but useful solver
for sparse linear systems. The eigenvector partitioning method is not considered in these
references; it is discussed by Pothen, Simon, and Liou [125], and an intuitive approach to
it is given by Demmel [38].
When problems get very large, even a good reordering strategy does not enable us to
keep the LU or Cholesky factors in memory, and iterative methods must be considered as
an alternative. We’ll discuss them in Chapter 28.

November 20, 2008 10:52
sccsbook
Sheet number 333 Page number 323
cyan magenta yellow black
Chapter 28
Iterative Methods for
Linear Systems
Solving a linear system of equations is one of the easiest computational tasks imaginable.
But sometimes when the matrix is very large, the algorithms we learned in linear algebra
class or in Chapter 5 take too long, and we need to use a different type of method. In this
chapter, we investigate these iterative methods.
In direct methods such as Gauss elimination, the LU and Cholesky decomposition,
or even Cramer’s rule, we have a ﬁxed set of operations that yield (using exact arithmetic)
the exact solutionx to the linear system Ax = b. The cost is predictable: O(n!) for Cramer’s
rule and O(n3) for the other two methods, if the n × n matrix A is dense (i.e., has only a
few zeros). In Chapter 27, we investigated how to make direct methods faster if A is
sparse (having many zeros), but sometimes even this is not enough to make direct methods
practical for a large problem.
The idea behind iterative methods is to start from an initial guess x(0) for the solution
to Ax = b and construct a sequence of guesses {x(0),x(1),x(2),...} converging to x. (Often,
x(0) = 0, but good use can be made of an estimate obtained using other information about
the problem or from the known solution to a similar problem.) In contrast to direct methods,
iterative methods yield only an approximate solution to the linear system, and although the
cost per iteration is ﬁxed, usually proportional to the cost of multiplying a vector by A, the
number of iterations is not precisely known.
Large sparse systems of linear equations arise in many contexts, but in this chapter
we use as an example a ﬁnite element model of the steady state heat distribution in two
thin plates: a square one and the one shown in Figure 28.1. See the Pointer 28.2 for other
examples.
We’ll consider two classes of methods, stationary iterative methods and Krylov
subspace methods, and discuss accelerating the Krylov methods using preconditioners.
323
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 334 Page number 324
cyan magenta yellow black
324
Chapter 28. Iterative Methods for Linear Systems
Figure 28.1. The thin plate for the second example problem is a square with a
hole cut out of it.
28.1
Stationary Iterative Methods (SIMs)
These methods grew up in the engineering literature. They were very popular in the 1960s
and are still used sometimes. Today, they are almost never the best algorithms (because
they take too many iterations), but we will see in Challenge 28.5 that they are useful pre-
conditioners for Krylov subspace methods.
One of the most common SIMs is Gauss–Seidel, also called successive displace-
ments. We discussed its use for nonlinear systems of equations in Section 24.3.2. For
linear systems, it is derived by solving the ith equation of Ax = b for ˆxi:
ˆxi = (bi−
i−1
	
j=1
aij ˆxj−
n
	
j=i+1
aij ˆxj)/aii,
i = 1,...,n.
(28.1)
Notice that we must require A to have nonzeros on its main diagonal. We don’t knowx, but
we can use our latest information on the right-hand side of this equation to get an updated
guess for xi. This yields Algorithm 28.1.
Algorithm 28.1 The Gauss–Seidel Algorithm (One Step)
Given x(k), construct x(k+1) by
x(k+1)
i
=
⎛
⎝bi−
i−1
	
j=1
aij x(k+1)
j
−
n
	
j=i+1
aij x(k)
j
⎞
⎠/aii,
i = 1,...,n.

November 20, 2008 10:52
sccsbook
Sheet number 335 Page number 325
cyan magenta yellow black
28.1. Stationary Iterative Methods (SIMs)
325
We continue the algorithm until either the residual b −Ax(k) is small enough, or
the change x(k+1) −x(k) is small enough, or a maximum number of iterations k has been
performed.
The algorithm is very easy to program! We only need to store one x vector, and let
the most recent guess overwrite the old. We should only use terms in (28.1) corresponding
to the nonzeros in A; otherwise the work per iteration is O(n2) instead of O(nz), where nz
is the number of nonzeros in A.
If A is nonsingular and the iteration converges, it converges to x, but convergence is
not guaranteed. Convergence depends on the properties of A. If we partition A as L+D+
U, where D contains the diagonal entries, U contains the entries above the diagonal, and L
contains the entries below the diagonal, then we can express the iteration as
(D+L)x(k+1) = b−Ux(k).
This form of the algorithm is sometimes useful for computation, and it is essential for
analyzing convergence, since we can express the iteration as
Mx(k+1) = b+Nx(k),
splitting the matrix A into M−N, with M = D+L and N = −U. Equivalently,
x(k+1) = Gx(k) +c,
where G = M−1N is a matrix that depends on A and c = M−1b is a vector that depends on
A and b. Also observe that the true solution x satisﬁes x = Gx + c. Subtracting, we see
that the error e(k) = x(k) −x satisﬁes
e(k+1) = Ge(k),
and it can be shown (See Challenge 5.15) that the error converges to zero for any initial x(0)
if and only if all of the eigenvalues of G lie inside the unit circle. Many conditions on A
have been found that guarantee convergence of these methods, but it is better to use faster
methods. To convince ourselves of this, let’s try the method on our sample problems so we
can compare with better methods later.
CHALLENGE 28.1.
Use Gauss–Seidel to solve the linear systems of equations generated by the MATLAB
function generateproblem found on the website. (Set the input parameter kappa
to zero, and note that you only need a part of the structure generated by this function:
the matrices mesh(k).A, the right-hand-side vectors mesh(k).b, and the convergence
tolerance mesh(k).tol.) Use an initial guess x(0) = 0. The mathematical model of
heat distribution is not exact, so we can stop the iteration when the norm of the residual is
somewhat smaller than the error in the model. We approximate this by stopping when the
norm of the residual has been reduced by a factor of mesh(k).tol. As the number of
unknowns in the linear system grows, this error decreases. Graph the number of iterations
and the solution time as a function of the number of unknowns, choosing a range of problem
sizes appropriate for your computer. (Number of iterations is not a very good measure for
comparing algorithms, since the work per iteration is so different for the different methods
we study.) Compare the time and storage with that for direct solution of the linear systems.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 336 Page number 326
cyan magenta yellow black
326
Chapter 28. Iterative Methods for Linear Systems
28.2
From SIMs to Krylov Subspace Methods
Stationary iterative methods such as Gauss–Seidel have an interesting property. If x(0) = 0,
then
x(1) = c
and
x(2) = Gx(1) +c
= Gc+c.
Therefore, x(2) is a linear combination of c and Gc; in other words,
x(2) ∈span{c,Gc}.
It is easy to show that the pattern continues:
x(k) ∈span{c,Gc,G2c,...,Gk−1c} ≡Kk(G,c),
and we call Kk(G,c) a Krylov subspace.
The work per iteration in Gauss–Seidel and other stationary iterative methods is pri-
marily the work involved in multiplying a vector by G. So it is natural to ask whether the
Gauss-Seidel choice for x(k) is the best choice in the Krylov subspace, or whether we might
do better without much extra work or storage.
First we need to deﬁne “best.” There are two common approaches:
• The variational approach: Choose x(k) ∈Kk(G,c) to minimize the distance be-
tween x(k) andx.
• The projection approach (also called the Galerkin approach): Choose x(k) ∈Kk(G,c)
to make the residual r(k) = b−Ax(k) orthogonal to every vector in Kk(G,c).
Note that each subspace Kk contains the previous one. If the Krylov subspace does
not expand, then the iteration terminates, fortunately with the exact solution. If it does
expand, then after k iterations, we have minimized over, or projected against, a subspace
of dimension k. Thus, after at most n iterations, Krylov subspace iterations terminate with
the true solution! This ﬁnite termination property is appealing but less useful than it might
seem, since we think of applying these methods when n is so large (tens of thousands,
millions, billions) that we can’t afford more than a few hundred iterations.
To make the algorithm practical, we need two ingredients. First, a very clever choice
of basis vectors for Kk keeps the work per iteration small and provides enough numerical
stability so that we can run for many iterations. The “right” choice is an orthogonal basis
in order to preserve numerical stability. Second, a clever choice of G ensures that we
converge in a small number of iterations, before the work and the accumulated numerical
error overwhelm us.
There are many Krylov subspace methods (See Pointer 28.2) but we focus ﬁrst on
one that is useful when A is symmetric and positive deﬁnite. Such matrices arise in many
practical situations: for example, in discretizations of self-adjoint elliptic partial differen-
tial equations such as the ones in our examples. This Krylov subspace method is called

November 20, 2008 10:52
sccsbook
Sheet number 337 Page number 327
cyan magenta yellow black
28.2. From SIMs to Krylov Subspace Methods
327
(preconditioned) conjugate gradients (PCG). It is both a minimization algorithm, in the
energy norm
∥x −x∥A ≡[(x−x)T A(x−x)]1/2,
and a projection algorithm, making the residual b −Ax(k) orthogonal to the Krylov sub-
space. There is a very compact and practical form for the algorithm, in which we keep only
the latest x-vector, the latest residual vector r, and two other vectors z and p. We present
Algorithm 28.2 using a splitting matrix M as a preconditioner. The choice of M deter-
mines G = M−1N and can be as simple as taking M = I. We discuss other choices in the
next section.
Algorithm 28.2 Algorithm PCG for Solving Ax = b
Given: symmetric positive deﬁnite matrices A and M, a vector b, an initial guess x, and
a tolerance tol.
Let r = b−Ax, solve Mz = r for z, and let γ = rT z, p = z, and ρ = ∥r∥.
for k = 0,1,..., until ∥r∥/ρ < tol,
α = γ/(pT Ap)
x = x+αp
r = r−αAp
Solve Mz = r for z.
ˆγ = rT z
β = ˆγ /γ , γ = ˆγ
p = z+βp
end
The PCG algorithm is quite remarkable: it solves a linear system—exactly—in at
most n steps, and the only use of the matrix A is in forming matrix-vector products! The
choice of the scalar parameter α at each iteration ensures that the minimization and projec-
tion properties hold. The choice of β ensures that the direction vector p is A-conjugate to
all previous vectors (i.e., pT
i Apj = 0 for i ̸= j). The algorithm derives its name from this
conjugacy, plus the choice of the negative gradient of the function f (x) = 1
2xT Ax −xT b
as the initial direction. The vectors p form a basis for the Krylov subspace, as do the
(orthogonal) residual vectors r.
Let’s compare the performance of this algorithm with that of Gauss–Seidel on our
two problems.
CHALLENGE 28.2.
Use PCG to solve the linear systems of equations considered in Challenge 28.1. Use
an initial guess x(0) = 0 and set M = I. Graph the number of iterations and the solution
time as a function of the number of unknowns and compare this and the storage with the
results of Challenge 28.1.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 338 Page number 328
cyan magenta yellow black
328
Chapter 28. Iterative Methods for Linear Systems
28.3
Preconditioning CG
The matrix M is called the preconditioner, and our next task is to understand what it does
and why we might need it. Using the energy norm, we have a bound on the error after k
iterations of PCG:
∥x(k) −x∥A ≤2
+
κ(G)−1

κ(G)+1
,k
∥x(0) −x∥A,
where κ(G) is the ratio of the largest and smallest eigenvalues of G = I−G = I−M−1N =
M−1A.
This gives us three guidelines for choosing a preconditioning matrix M:
• We require that M be symmetric and positive deﬁnite.
• For fast iterations, we need to be able to solve linear systems involving M very
quickly, since this must be done once per iteration.
• To make the number of iterations small, we want M to be a good approximation to
A. For example, it is good if the eigenvalues of G lie in a small interval.
Note that the linear system Mz = r is typically solved using a direct method, so the closer
M is to A, the closer we are to solving Ax = b using a direct method. In fact, if M = A, then
N = 0 and the iteration converges in a single iteration; we have created a direct method. So
the art of preconditioning is the trade-off between work per iteration (minimized by taking
M = I) and the number of iterations (minimized by taking M = A). Common choices of
preconditioning matrices M include the following:
• M = the diagonal of A. This often reduces the effects of poor scaling in the problem
formulation.
• M = a banded piece of A.
• M = an incomplete decomposition of A, leaving out inconvenient elements (the in-
complete Cholesky preconditioner).
• M−1 = a sparse approximation to A−1 (the sparse approximate inverse precondi-
tioner (SAIP)).
• M = a matrix related to A either physically or algebraically. For example, if A is
a discretization of a differential operator, M might be a discretization of a related
operator that is easier to solve, or M might be the block diagonal piece of the matrix
after ordering for nested dissection.
• M might be the matrix from any stationary iterative method (SIM) or from multigrid
(discussed in the case study of Chapter 32).
Let’s try the Incomplete Cholesky preconditioners on our problems.

November 20, 2008 10:52
sccsbook
Sheet number 339 Page number 329
cyan magenta yellow black
28.3. Preconditioning CG
329
CHALLENGE 28.3.
Use PCG to solve the linear systems of equations considered in Challenge 28.1. Use
an initial guess x(0) = 0 and set M to be incomplete Cholesky preconditioners generated by
cholinc with various choices for its parameters droptol and opts. Compare with the
results of Challenges 28.1 and 28.2, but remember that time-per-iteration is very different
for the different algorithms.
It takes a bit of thought to decide how to use our SIM preconditioners. The search
direction p in PCG is built from the preconditioned residual. We need to express the step
taken by a SIM in terms of the residual, and we do this algebra in the next challenge.
CHALLENGE 28.4.
Consider our SIM
Mx(k+1) = Nx(k) +b
or
x(k+1) = M−1Nx(k) +M−1b.
Show that if r(k) = b −Ax(k), then
x(k+1) = x(k) +M−1r(k),
and therefore the step taken by the SIM is
x(k+1) −x(k) = M−1r(k).
Using Challenge 28.4, we can compute M−1r in the PCG algorithm by taking one
step of the SIM starting from the latest PCG iterate, returning the change in x as M−1r.
One complication remains: the Gauss Seidel matrix M is not symmetric. In order to
use Gauss–Seidel as a preconditioner for PCG, we perform a double iteration, considering
the equations in order 1,...,n and then again in order n,...,1. This is called the symmetric
Gauss–Seidel iteration, given in Algorithm 28.3.
Algorithm 28.3 The Symmetric Gauss–Seidel Algorithm (One Step)
Given x(k), construct x(k+1) by
x(k+1/2)
i
=
⎛
⎝bi−
i−1
	
j=1
aij x(k+1/2)
j
−
n
	
j=i+1
aij x(k)
j
⎞
⎠/aii,
i = 1,2,...,n.
x(k+1)
i
=
⎛
⎝bi−
i−1
	
j=1
aij x(k+1/2)
j
−
n
	
j=i+1
aij x(k+1)
j
⎞
⎠/aii,
i = n,n −1,...,1.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 340 Page number 330
cyan magenta yellow black
330
Chapter 28. Iterative Methods for Linear Systems
CHALLENGE 28.5.
Use PCG to solve the linear systems of equations considered in Challenge 28.1. Use
an initial guess x(0) = 0 and set M to be the symmetric Gauss–Seidel preconditioner. Com-
pare with the results of Challenges 28.1, 28.2, and 28.3.
The preconditioners that we consider depend on the ordering of the unknowns and
equations. We can use the reorderings from Chapter 27 to try to improve our results.
CHALLENGE 28.6.
Repeat your experiments after reordering the matrices using the approximate mini-
mum degree (AMD) reordering. Compare the results of all experiments.
The matrices in the challenges considered in this chapter arise from discretizing an
elliptic partial differential equation whose domain is a two-dimensional region. When the
region is three-dimensional, the problem sizes grow even faster, and storage rapidly be-
comes an issue for the Cholesky algorithm.
Our preconditioners did not take advantage of the origin of the problem. Often, the
more you know about the underlying problem, the better you can solve it. With a clever
choice of preconditioners for this collection of matrices, the number of iterations for PCG
is independent of mesh size. We consider such multigrid methods in the case study of
Chapter 32.
28.4
Krylov Methods for Symmetric Indeﬁnite Matrices
and for Normal Equations
If the matrix A is symmetric but indeﬁnite, with both positive and negative eigenvalues, or
if we aren’t sure whether the symmetric matrix is positive deﬁnite or not, then the Krylov
variant called SYMMLQ [123] is the algorithm of choice.
Quite frequently, the matrix A for our problem has been created by forming A = BT B
for some matrix B. A matrix of this form is guaranteed to be symmetric and positive semi-
deﬁnite. If B is sparse and has many columns, we surely do not want to form A, since it is
likely to be much more dense. Luckily, CG does not require the matrix to be formed, only
that we can form matrix vector products, and we can do this as BT (Bp) for any given vector
p. Such problems often arise from considering the normal equations arising from solving
the least squares problem
min
x ∥Bx−d∥2
2
by setting the derivative of the function ∥Bx −d∥2
2 to zero. Special algorithms have been
written for problems like these; in particular, LSQR [122] is an efﬁcient and stable variant.

November 20, 2008 10:52
sccsbook
Sheet number 341 Page number 331
cyan magenta yellow black
28.5. Krylov Methods for Nonsymmetric Matrices
331
28.5
Krylov Methods for Nonsymmetric Matrices
Conjugate gradients has many desirable properties. It is both a minimization and a pro-
jection method, and the iteration can be performed by storing only a few vectors, whose
number does not grow with n. For general matrices, no method has all of these properties.
Instead, there are two families of methods.
One family uses the Arnoldi basis. This requires storing and computing with k
vectors at the kth iteration, so iterations slow down as k increases. The linear system solver
based on minimization is called GMRES, while that based on projection is called Arnoldi
(like the basis). Because of the cost, these methods are normally restarted periodically,
discarding the basis and using the current residual to form another Krylov subspace.
Construction of the Arnoldi basis requires the deﬁnition of a matrix G = M−1A and
an initial basis vector which we take to be c = M−1(b −Ax). At iteration j, the next
vector in the orthonormal basis v1,v2,...,vj is the component of Gvj that is orthogonal to
v1,...,vj. We discuss using Gram–Schmidt orthogonalization to construct the basis, but
Householder can also be used. Our ﬁrst basis vector is v1 = z/∥z∥. Now suppose that we
have j orthonormal basis vectors v1,...,vj for Kj(G,c). Then z = Gvj ∈Kj+1(G,c). If
z ∈Kj(G,c), the Arnoldi construction terminates (and we can use our basis vectors to ﬁnd
an exact solution to the linear system). If z is not in this subspace, then we deﬁne the next
orthonormal basis vector by the process of Gram–Schmidt orthogonalization:
vj+1 = (z−h1, jv1 −···−hj, jvj)/hj+1, j,
where hi, j = v∗
i z (i = 1,..., j) and hj+1, j is chosen so that v∗
j+1vj+1 = 1. In matrix form,
we can express this relation as
Gvj =
 v1
v2
...
vj+1

⎡
⎢⎢⎢⎣
h1, j
h2, j
...
hj+1, j
⎤
⎥⎥⎥⎦,
so after k steps we have
GVk = Vk+1Hk,
(28.2)
where Hk is a (k + 1) × k matrix with entries hij (zero if i > j + 1) and Vk is n × k and
contains the ﬁrst k basis vectors as its columns. Algorithm 28.4 constructs the Arnoldi
basis. Note that we compute Gv by ﬁrst computing Av and then by solving a linear system
involving the matrix M, since forming G is generally inefﬁcient in time and storage.
Equation (28.2) is very important: Since the algorithm ordinarily terminates with a
zero vector after n vectors have been formed,11 we have actually factored our matrix
G = VnHnVn−1.
Therefore, the matrix Hn is closely related to G: it is formed by a similarity transform and
therefore has the same eigenvalues. In fact, the leading (k + 1) × k or k × k piece of Hn
(available after k steps) is in some sense a good approximation to G, and we exploit this
fact in the GMRES algorithm and when we need approximate eigenvalues of G.
11The set of vectors for which the algorithm terminates earlier than this has measure zero.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 342 Page number 332
cyan magenta yellow black
332
Chapter 28. Iterative Methods for Linear Systems
Algorithm 28.4 Constructing the Arnoldi Basis
[Vm+1,Hm] = Arnoldi(m,G,c)
Given: a positive integer m, a matrix G, and a vector c.
Use m steps of Gram–Schmidt orthogonalization (Algorithm 5.2), with a1 = c and aj =
Gqj−1, to compute a n ×(m +1) matrix Q and an (m +1)×(m +1) matrix R.
Let Hm be columns 2 through m +1 of R and let Vm+1 = Q.
Algorithm 28.5 Algorithm RESTARTED GMRES for Solving Ax = b
Given: nonsingular matrices A and M, a vector b, an initial guess x, a restart parameter
m, and a tolerance tol.
Let r = b−Ax and ρ = ∥r∥.
while ∥r∥> tol ∗ρ,
Determine z by solving Mz = r.
[Vm+1,Hm] = Arnoldi(m,G,z), where G = M−1A (not explicitly formed).
Solve H∗
mHmy = H∗
mV∗
m+1z.
Set x = x+Vmy and r = r−A(Vmy).
end
The RESTARTED GMRES algorithm is given in Algorithm 28.5. It generates Arnoldi
basis vectors from the starting vector z that satisﬁes Mz = b −Ax. Then it solves the least
squares problem
min
y ∥z−GVmy∥
and adds Vmy on to the current iterate, thus reducing the residual norm ∥r∥. Making use
of the facts that GVm = Vm+1Hm and VT
m+1Vm+1 = I, the normal equations deﬁning the
solution to the least squares problem can be written as
H∗
mHmy = H∗
mV∗
m+1z,
and these equations can be solved efﬁciently using a Givens version of the QR decomposi-
tion of Hm, since Hm is already upper Hessenberg.
The convergence of GMRES depends on the eigenvalues λj of G. Among all polyno-
mials of degree m with constant coefﬁcient equal to 1, choose the one with the minimum
maximum value at the eigenvalues and call that value ϵ:
ϵ =
min
p(0)=1
degree(p)≤m
max
j=1,...,n |p(λj)|.
After one cycle of GMRES, updating xnew = xold +Vmy, we have the residual bound
∥rnew∥≤ϵκ(U)∥rold∥,
where U is the matrix of eigenvectors of G and κ(U) = ∥U∥2∥U−1∥2 is the ratio of largest
to smallest singular values of U. Unfortunately if the matrix of eigenvectors is very ill-
conditioned, then ϵκ(U) may be greater than 1, making the bound useless.

November 20, 2008 10:52
sccsbook
Sheet number 343 Page number 333
cyan magenta yellow black
28.6. Computing Eigendecompositions and SVDs with Krylov Methods
333
POINTER 28.1. Solving Large Eigenvalue Problems.
Problems such as stress analysis of large structures and energy analysis of molecular
conﬁgurations lead to very large eigenvalue problems. Surprisingly, the largest eigenvalue
computations are performed for information retrieval. Google, for example, uses a ma-
trix of size equal to the number of webpages on the Internet (in the billions) to compute
PageRanks R⃝of each page. These PageRanks are used to determine which websites are
returned in response to a query [15].
Restarted GMRES (with m < n) can stagnate on some problems, repeatedly comput-
ing the same iterate x. (Taking m = n, cannot fail but is generally too expensive.) This
is unfortunate, but in such a case, the algorithm can be run again with a different starting
guess or a different preconditioner M.
A second family of Krylov methods for solving nonsymmetric problems uses the
Lanczos basis. Like CG, the computations can be done by storing only a few vectors, but
in the nonsymmetric case, occasionally the iteration breaks down, producing a zero vector
before the solution is found. (GMRES does not break down.) The linear system solver based
on minimization is called MR (or QMR), while that based on projection is called BI-CG.
28.6
Computing Eigendecompositions and SVDs with
Krylov Methods
The residuals in the CG method are orthogonal, as are the vectors in the Arnoldi basis.
Suppose that we take n steps of our iteration (impractical, but interesting conceptually).
Then (in exact arithmetic) the CG or the Arnoldi-based methods terminate with the exact
solution to our linear system. But, rather remarkably, as we saw in Section 28.5, we have
also secretly computed a matrix decomposition. If we let V be the matrix whose columns
are the basis vectors normalized to length 1 and let M = I, then V∗AV is tridiagonal for
CG and upper-Hessenberg (zeros below the ﬁrst subdiagonal) for Arnoldi, and, because we
have computed a similarity transform, the eigenvalues are the same as those of A. The
entries in V∗AV are derived from the scalar parameters computed in CG or Arnoldi.
Now we are never going to take n steps of CG or Arnoldi, but after k steps, we have
computed Vk (the ﬁrst k columns of V) and the upper k ×k block of V∗AV. We can obtain
good approximations to some of the eigenvalues of A by using the QR algorithm from
Section 5.5 to ﬁnd the eigenvalues and eigenvectors of this rather small k × k matrix. If
λ is an eigenvalue and w is an eigenvector of the small matrix, then λ is an approximate
eigenvalue of A with approximate eigenvector Vkw.
If this sounds complicated, it is! It is necessary to incorporate many tricks and safe-
guards, including selective reorthogonalization against eigenvectors that have already con-
verged and implicit restarting to keep k small. As usual, it is important to choose high-
quality software like eigs to do this computation.
The Lanczos basis yields approximations to singular values rather than eigenvalues,
and high-quality sofware like MATLAB’s svds is available.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 344 Page number 334
cyan magenta yellow black
334
Chapter 28. Iterative Methods for Linear Systems
POINTER 28.2. Further Reading.
Ortega [119] gives a good introduction to SIMs such as Jacobi, Gauss-Seidel, and
successive over-relaxation (SOR).
Saad’s book [132] on Krylov subspace methods is an excellent reference for algo-
rithms such as PCG, GMRES, MR, QMR, Arnoldi, and BI-CG. MATLAB has implementa-
tions of several of these algorithms, and implementations of SYMMLQ and LSQR are also
available [122, 123].
In some situations, it is a good idea to let the preconditioner M
change at each iteration, resulting in an algorithm called ﬂexible-GMRES [132].
MATLAB functions eigs and svds use Krylov subspace methods to compute
eigenvalue-eigenvector pairs and singular value-vector triplets [100, 140].
The mesh depicted in Figure 28.1 was produced by the distmesh system of Persson
and Strang [124].
Interesting sparse matrices for further experimentation can be found in the gallery
function in MATLAB, the Matrix Market [106], or Davis’s collection [36].

November 20, 2008 10:52
sccsbook
Sheet number 345 Page number 335
cyan magenta yellow black
Chapter 29 / Case Study
Elastoplastic Torsion:
Twist and Stress
This case study focuses on the stress induced in a rod by twisting it. We’ll investigate
two situations: ﬁrst, when the stress is small enough that the rod behaves elastically, and
second, when we pass the elastic-plastic boundary. The solution to our problem involves
repeated solution of sparse systems of linear equations.
Consider a long rod made of metal, plastic, rubber, or some other homogeneous
material mounted on a wall, as shown in Figure 29.1 (left). Hold the rod at the end and twist
counterclockwise, as shown in the ﬁgure (right). This torsion (twisting) causes stresses in
the rod. If the force we apply is small enough, then the rod behaves as an elastic body, and
when we release it, it returns to its original state. But if we apply a lot of twisting force,
we eventually change the structure of the rod; some portion of it behaves plastically and is
permanently changed. If the whole rod behaves elastically, or if it all behaves plastically,
then modeling is rather easy. More difﬁcult cases occur when there is a mixture of elastic
and plastic behavior, and in this problem we investigate the behavior of the rod over a full
range of torsion.
The Elastic Model
As usual in mathematical modeling, we make simplifying assumptions to make the compu-
tation tractable. We assume that the torsional force is evenly distributed throughout the rod,
and that the rod has uniform cross sections. Under these circumstances, we can understand
the system by modeling the stress in any single cross section. We’ll call the interior of the
two-dimensional cross section  and its boundary .
The standard elastic model involves the stress function u(x, y) on , where the quan-
tities −∂u(x, y)/∂x and ∂u(x, y)/∂y are the stress components. If we set the net force to
zero at each point in the cross-section, we obtain
∇2u ≡∂2u
∂x2 + ∂2u
∂y2 ≡uxx +uyy = −2Gθ
in ,
u = 0 on ,
335
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 346 Page number 336
cyan magenta yellow black
336
Chapter 29. Case Study: Elastoplastic Torsion: Twist and Stress
Figure 29.1. A rod before torsion is applied (left) and after (right).
where G is the shear modulus of the material and θ (radians) is the angle of twist per unit
length. In order to guarantee existence of a smooth solution to our problem, we’ll assume
that the boundary  is smooth; in fact, in our experiments,  is an ellipse.
An alternate equivalent formulation is derived from minimizing an energy function
E(u) = 1
2
 

∥∇u(x, y)∥dxdy −2Gθ
 

u(x, y)dxdy.
The magnitude of the gradient ∥∇u(x, y)∥=

(∂u(x, y)/∂x)2+(∂u(x, y)/∂y)2 is the
shear stress at the point (x, y), an important physical quantity. At any point where the shear
stress exceeds the yield stress σ0, the material becomes plastic, and our standard model is
no longer valid.
For simple geometries (e.g., a circle), we can solve this problem analytically. But,
for the sake of generality and in preparation for the more difﬁcult elastoplastic problem, we
consider numerical methods. Discretization by ﬁnite differences would be a possibility,
but the geometry makes the ﬂexibility of ﬁnite elements attractive. The case study of
Chapter 23 gave a simple example of their use. We can use a ﬁnite element package to
formulate the matrix K that approximates the operator −∇2u on , and also assemble the
right-hand side b so that the solution to the linear system Ku = b is the approximation
to u(x, y) at the nodes (xi, yi) of the ﬁnite element mesh. Since the boundary  and the
forcing function −2Gθ are smooth, we expect optimal order approximation of the ﬁnite
element solution to the true solution as the mesh is reﬁned: for piecewise linear elements
on triangles, for example, this means that the error is O(h2), where h is a measure of the
size of the triangles.
In Challenge 29.1, we see what this model predicts for the sheer stress on our rod.
CHALLENGE 29.1.
Suppose that the cross-section  of the rod is the interior of a circle of radius one,
and let G = 5 and θ = 1. Use a ﬁnite element package to approximate the stress function.
Plot the approximate solution and describe what it says about the stress. Solve again using
a ﬁner mesh and estimate the error in your approximation 1/2uT Ku−bT u to E(u).

November 20, 2008 10:52
sccsbook
Sheet number 347 Page number 337
cyan magenta yellow black
The Elastoplastic Model
337
Note that by symmetry, we could reduce our computational domain in Challenge 29.1
to a quarter circle, setting the normal derivative of u along the two straight edges to zero.
The Elastoplastic Model
As the value of θ is increased, the maximum value of the shear stress ∥∇u(x, y)∥increases,
eventually exceeding the yield stress of the rod, and then our model breaks down because
the rod is no longer behaving elastically. We can extend our model to this case by adding
constraints: we still minimize the energy function, but we don’t allow stresses larger than
the yield stress:
min
u
E(u)
∥∇u(x, y)∥≤σ0, (x, y) ∈
u = 0 on 
The new constraints ∥∇u(x, y)∥≤σ0 are nonlinear, but we can reduce them to linear by
a simple observation: if we start at the boundary and work our way in, we see that the
constraint is equivalent to saying that |u(x, y)| is bounded by σ0 times the (shortest) distance
from (x, y) to the boundary.
So the next (and most challenging) ingredient in solving our problem is an algorithm
for determining these distances. In the next two challenges, we develop and implement
such an algorithm.
CHALLENGE 29.2.
Derive an algorithm for ﬁnding the distance d(z) between a given point z = [z1,z2]T
and a ellipse. In other words, solve the problem
min
x,y (x −z1)2 +(y −z2)2
subject to
! x
α
"2
+
 y
β
2
= 1
for given parameters α and β. Note that the distance is the square root of the optimal value
of the objective function (x −z1)2 +(y −z2)2. The problem can be solved using Lagrange
multipliers, as a calculus student would. You need only consider points z on or inside the
ellipse, but handle all of the special cases: α = β, z has a zero coordinate, etc.
In Challenge 29.2, we see that a rather simple sounding mathematical problem be-
comes complicated when we handle the special cases properly. When we consider the
fact that computers do their arithmetic inexactly, we see that an algorithm for computing
distances to an ellipse must also account for difﬁculties encountered, for example, when a
component of z is near zero, and we face the difﬁculties of this algorithm in Challenge 29.3.
Implementing reliable software requires a great deal of attention to details.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 348 Page number 338
cyan magenta yellow black
338
Chapter 29. Case Study: Elastoplastic Torsion: Twist and Stress
CHALLENGE 29.3.
Program your distance algorithm, document it, and produce a convincing validation
of the implementation by designing a suitable set of tests and discussing the results. Use a
reliable rootﬁnder such as fzero to solve the nonlinear equation.
Now we have the elements in place to solve our elastoplastic torsion problem. We
discretize E(u) using ﬁnite elements, and we use our distance function to form the con-
straints, resulting in the problem
min
u 1/2uT Ku−bT u
−σ0d ≤u≤σ0d,
where di = d(xi, yi) and the ith component of u approximates the solution at (xi, yi). Be-
cause the matrix K is symmetric positive deﬁnite (due to the elliptic nature of the differ-
ential equation), the solution to the problem exists and is unique. This is a quadratic
programming problem. Algorithms for solving it include active set strategies and the
newer interior-point methods; see Chapter 10.
CHALLENGE 29.4.
Solve the elastoplastic problem on a mesh that you estimate gives an error of less
than 0.1 in the function E(u). Use the parameters G = 1, σ0 = 1, and β = 1. Let αθ = 0,
0.25, 0.50,...,5 and β/α = 1, 0.8, 0.65, 0.5, 0.2. Plot a few representative solutions. On
a separate graph, for each value of β/α, plot a curve T/(σ0α3) vs Gαθ/σ0, where T is the
estimate of the torque, the integral of u over the domain . (This gives you 5 curves, one
for each value of β/α.) On the same plot, separate the elastic solutions (those for which no
variable is at its bound) from the elastoplastic ones. Estimate the errors in the data points
of your plot.
We solved this problem on a rod with a simple cross-section. Think about how you
could extend our methods to more complicated shapes!

November 20, 2008 10:52
sccsbook
Sheet number 349 Page number 339
cyan magenta yellow black
The Elastoplastic Model
339
POINTER 29.1. Further Reading.
This case study comes from a paper coauthored by Wei H. Yang [117] in 1978. At
that time, we worked very hard to develop memory- and time-efﬁcient algorithms to solve
the elastoplastic problem so that we wouldn’t need a supercomputer. Now, sufﬁcient com-
putational resources are available in laptops.
Selvadurai [136, Sec. 9.9] gives an excellent derivation of the elastic model equation.
He also discusses the history of the model, noting that there were several incorrect models
before Barre de Saint-Venant proposed a correct one.
The solution to Challenge 29.1 requires access to a package to generate ﬁnite element
meshes and stiffness matrices. A stand-alone package such as PLTMG [6] or MATLAB’s
PDE Toolbox routines (initmesh, refinemesh, assempde, pdeplot) can be
used. An introduction to ﬁnite element formulations can be found, for example, in books
by Bathe [8] and Brenner and Scott [18].
For Challenge 29.4, you need a quadratic programming algorithm, such as MAT-
LAB’s quadprog from the Optimization Toolbox. Quadratic programming is discussed
in textbooks such as that by Bazaraa, Sherali, and Shetty [9].
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 350 Page number 340
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 351 Page number 341
cyan magenta yellow black
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
Chapter 30 / Case Study
Fast Solvers and
Sylvester Equations:
Both Sides Now
In Chapter 27, we considered large sparse systems of linear equations. One conclusion we
can draw from that study is that it is very important to exploit structure in our matrix in
order to keep storage and computational costs low. In that chapter we exploited sparsity;
now we consider a set of problems that have an additional type of structure.
Among the problems considered in Chapter 27 was the Poisson equation
−uxx −uyy = f (x, y)
with (x, y) ∈ ⊂R2, and with appropriate boundary conditions speciﬁed. One strategy
was to discretize the equation by choosing mesh points. We write an equation for each
mesh point by approximating the derivatives uxx and uyy by ﬁnite differences. This gives a
system of linear equations Au = f to solve for estimates of the value of u each of the mesh
points.
In one of our examples,  was a unit square with the mesh points chosen so that they
were equally spaced, and we were given zero boundary conditions. If we have a 5×5 grid
of mesh points, for example, we might order them as in Figure 30.1. If we let xj = jh and
yk = kh, with h = 1/6 = 1/(n +1), then we create two vectors
u ≈[u(x1, y1),...,u(xn, y1),u(x1, y2),...,u(xn, y2),...,u(x1, yn),...,u(xn, yn)]T ,
f = [ f (x1, y1),..., f (xn, y1), f (x1, y2),..., f (xn, y2),..., f (x1, yn),..., f (xn, yn)]T ,
and write our approximation to −uxx at all of the mesh points as
Axu ≡1
h2
⎡
⎢⎢⎢⎣
T
0
0
0
0
0
T
0
0
0
0
0
T
0
0
0
0
0
T
0
0
0
0
0
T
⎤
⎥⎥⎥⎦u.
341
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 352 Page number 342
cyan magenta yellow black
342
Chapter 30. Case Study: Fast Solvers and Sylvester Equations
POINTER 30.1. Exploiting Problem Structure.
In this case study, we use the structure of a problem with n2 unknowns to reduce the
amount of computation from O(n6) (using the Cholesky decomposition) to O(n4) (exploit-
ing sparsity) and then to O(n3) (using the Sylvester structure), a substantial savings when
n is large. Then, knowing just a bit more about the structure of the problem allows further
reduction, to O(n2 log2 n)when n is a power of 2. Since we are computing n2 answers, this
is close to optimal, and it illustrates the value of exploiting every possible bit of structure
in our problems.
In this equation, the ith component of the 25×1 vector u is our approximation to u at the
ith mesh point. The matrix 0 is a 5 ×5 matrix of zeros, and the matrix T is deﬁned by
T =
⎡
⎢⎢⎢⎣
2
−1
0
0
0
−1
2
−1
0
0
0
−1
2
−1
0
0
0
−1
2
−1
0
0
0
−1
2
⎤
⎥⎥⎥⎦.
Similarly, our approximation to −uyy at all of the mesh points is
Ayu ≡1
h2
⎡
⎢⎢⎢⎣
2I
−I
0
0
0
−I
2I
−I
0
0
0
−I
2I
−I
0
0
0
−I
2I
−I
0
0
0
−I
2I
⎤
⎥⎥⎥⎦u,
where I is the identity matrix of dimension 5 ×5. So, we want to solve the linear system
(Ax +Ay)u = f.
(30.1)
This gives us a problem with a sparse matrix, and since our usual grids are n ×n where n
is much bigger than 5, it is important to exploit the sparsity.
But in this particular problem—an equally-spaced grid over a square (or a rectangle)—
there is even more structure that we can exploit, and in the next challenge we see how to
write our problem in a more compact form.
CHALLENGE 30.1.
Show that equation (30.1) can be written as
(ByU+UBx) = F,
(30.2)
where the matrix entry ujk is our approximation to u(xj, yk), fjk = f (xj, yk), and By =
Bx = (1/h2)T.

November 20, 2008 10:52
sccsbook
Sheet number 353 Page number 343
cyan magenta yellow black
343
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
Figure 30.1. The mesh points for our problem.
Equation (30.2) is called a Sylvester equation. (It is also a Lyapunov equation
since By = BT
x .) It looks daunting because the unknowns U appear on both the left and the
right sides of other matrices. But, as we just showed, the problem is equivalent to a system
of linear equations. The advantage of the Sylvester equation formulation is that it gives us
a compact representation of our problem in terms of the data matrix F and two tridiagonal
matrices of dimension n. (In fact, since Bx = By, we really have only one tridiagonal
matrix.) One way to solve our problem efﬁciently is by using the Schur decomposition
of a matrix. We’ll consider this algorithm in the next challenge, developing both a row-
oriented and a column-oriented algorithm. As we saw in Chapter 3, the choice between
these algorithms depends on how the elements of the matrix are arranged in the computer
memory.
CHALLENGE 30.2.
(a) Consider the Sylvester equation LU + UR = C, where L is lower triangular and R is
upper triangular. Show that we can easily determine the elements of the matrix U either
row by row or column by column. How many multiplications does this algorithm require?
(b) By examining your algorithm, determine conditions on the main diagonal elements of
L and R (i.e., the eigenvalues) that are necessary and sufﬁcient to ensure that a solution to
the Sylvester equation exists.
(c) Now suppose that we want to solve the Sylvester equation AU+UB = C, where A, B,
and C of dimension n × n are given. (A and B are unrelated to the previously described
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 354 Page number 344
cyan magenta yellow black
344
Chapter 30. Case Study: Fast Solvers and Sylvester Equations
matrices.) Let A = WLW∗and B = YRY∗, where WW∗= W∗W = I, YY∗= Y∗Y = I, L is
lower triangular, and R is upper triangular. (This is called a Schur decomposition of the
two matrices.) Show that we can solve the Sylvester equation by applying the algorithm
derived in part (a) to the equation LU+UR = C, where U = W∗UY and C = W∗CY.
The reason for using the Schur decomposition in the previous problem is that the most
compact form we can achieve using a unitary matrix transformation is triangular form. We
consider only unitary transforms in order to preserve stability. One disadvantage of the
Schur algorithm applied to real nonsymmetric matrices is that we need to do complex
arithmetic, and the resulting computed matrix U may have small imaginary part due to
rounding error, even though the true matrix is guaranteed to be real.
We could solve (30.2) using the eigendecomposition in place of the Schur decompo-
sition. This is less efﬁcient for general matrices but more efﬁcient when Bx and By have
eigenvectors related to the vectors of the discrete Fourier transform, as in our case, and it
is stable for symmetric matrices, since in that case the eigenvector matrix is real orthogo-
nal. In fact, the Schur decomposition reduces to the eigendecomposition when A and B are
real symmetric, since the matrices L and R are then also symmetric and therefore diagonal.
Let’s see how we can sometimes efﬁciently solve our problem using an eigendecomposi-
tion.
Suppose that Bx and By are any two real symmetric matrices that have the same
eigenvectors, so that
Bx = VxVT and By = VyVT ,
where the columns of V are the eigenvectors (normalized to length 1) and the entries of
the diagonal matrices x and y are the eigenvalues. (Note that since Bx and By are
symmetric, the columns of V are orthogonal so that VT V = VVT = I.) Substituting our
eigendecompositions, equation (30.2) becomes
VyVT U+UVxVT = F,
and multiplying this equation by VT on the left and by V on the right, we obtain
yVT UV+VT UVx = VT FV.
Letting Y = VT UV, we have an algorithm:
• Form the matrix F = VT FV.
• Solve the equation yY+Yx = F, where x and y are diagonal.
• Form the matrix U = VYVT .
CHALLENGE 30.3.
Determine a way to implement the second step of the algorithm using only O(n2)
arithmetic operations.
Since we have n2 entries of U to compute in solving our problem, the second step is
optimal order, so the efﬁciency of the algorithm depends on the implementation of the ﬁrst

November 20, 2008 10:52
sccsbook
Sheet number 355 Page number 345
cyan magenta yellow black
345
and third steps. In general, each matrix-matrix product of n × n matrices takes O(n3) op-
erations, so our complete algorithm would also take O(n3). In some special cases, though,
the matrix products can be computed more quickly, and this is the case for our Poisson
problem, as we see in the next challenge.
CHALLENGE 30.4.
(a) The eigenvalues and eigenvectors of Bx are known. Denote the elements of the vector
vj by
vkj = αj sin kjπ
n +1,
where αj is chosen so that ∥vj∥= 1. Show that Bxvj = λjvj, where λj = (2−2cos jπ
n+1)/h2,
for j = 1,2,...,n.
(b) Show that multiplication by the matrix V or VT can be accomplished by a discrete
Fourier (sine) transform or inverse Fourier (sine) transform of length n, where the discrete
sine transform of a vector x is deﬁned by
yk =
n
	
j=1
xj sin( jkπ/(n +1)).
This can be accomplished in O(n log2 n) operations if n is a power of 2 and in some larger
but still modest number of operations if n is a composite number with many factors.
Using the multiplication algorithm from Challenge 30.4, we can solve equation (30.2)
in O(n2 log2 n) operations when n is a power of 2, considerably less than the O(n3) oper-
ations generally required, or the O(n4) required for the sparse Cholesky decomposition
applied to our original matrix problem! (The reordering strategies discussed in Chapter 27
would reduce the factorization complexity somewhat but would not achieve O(n2 log2 n).)
CHALLENGE 30.5.
Write a well-documented program to solve the discretization of the differential equa-
tion using the Schur-based algorithm of Challenge 30.2 and using the algorithm developed
in Challenge 30.4. (Debug the Schur-based algorithm using randomly generated real non-
symmetric matrices.) Test your algorithms for n = 2p, with p = 2,...,9 choosing the true
solution matrix U randomly. Compare the results of the two algorithms with backslash for
accuracy and time.
In MATLAB, the functions dst and idst from the PDE Toolbox are useful in
solving this problem. If the PDE Toolbox is not available, the results of a fast Fourier
transform can be manipulated to obtain the desired result. Also of use is schur, which
has an option to return either an upper-triangular (and possibly complex) factor or a real
block upper-triangular factor with 1 ×1 or 2 ×2 blocks on the main diagonal.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 356 Page number 346
cyan magenta yellow black
346
Chapter 30. Case Study: Fast Solvers and Sylvester Equations
POINTER 30.2. Further Reading.
The method used in Challenge 30.4 can be extended. There are fast solvers for solv-
ing 3-d Poisson problems, for problems on rectangles, circles, and other simple domains,
and for problems with different boundary conditions [144].
The Schur algorithm for the Sylvester equation is due to Bartels and Stewart [7].
When we discuss number of operations, we consider the traditional algorithms for
matrix product. There are faster versions (e.g., that of Strassen) but Miller showed that the
stability is not as good [107]; see [79, Sec. 23.2.2].
The Sylvester equation also arises in state space design in control theory [33] and in
image processing [69]. In fact, our Kronecker product problem in Chapter 6 can be written
as a Sylvester equation [69, Sec. 4.4.2].

November 20, 2008 10:52
sccsbook
Sheet number 357 Page number 347
cyan magenta yellow black
Chapter 31 / Case Study
Eigenvalues:
Valuable Principles
In this case study, we study eigenvalue problems arising from partial differential equations.
Eigenvalues can help us solve a differential equation analytically, and they can also pro-
vide valuable information about the behavior of a physical system. We’ll study properties
of eigenvalues and use these properties to design a drum with a particular fundamental
frequency of vibration.
What Is an Eigenvalue of an Operator?
To begin, recall that an eigenvector of a matrix is a vector w with the property that multi-
plication of the vector by the matrix simply scales the vector. The scale factor λ is called
an eigenvalue, or principal value of the matrix.
The eigensystem (eigenvalues and eigenvectors) of A has several nice properties,
summarized in Pointers 5.1 and 5.6. When the eigenvalues are distinct, the eigenvectors
are unique, except that they can be multiplied by any nonzero number. The eigenvectors
are linearly independent, so they form a basis for Rn. In fact, if A is real symmetric or
complex Hermitian, then eigenvectors corresponding to distinct eigenvalues are orthogonal.
In this case, the smallest eigenvalue is the value of the function
min
w̸=0
wT Aw
wT w .
The other eigenvalues can also be characterized as solutions to minimization problems (or
maximization problems).
Now, instead of a matrix, let’s consider a differential operator. As an example, deﬁne
Au = −u′′
for x ∈ = (0,1), and require that u satisfy the boundary conditions u(0) = u(1) = 0.
Notice that for j = 1,2,...,
Asin( jπx) = ( jπ)2sin( jπx).
347
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 358 Page number 348
cyan magenta yellow black
348
Chapter 31. Case Study: Eigenvalues: Valuable Principles
In other words, we have found functions wj(x) = sin( jπx), called eigenfunctions of A,
that satisfy the zero boundary conditions and have the special property that applying A just
scales the function. We call the scale factor the eigenvalue of A, and we can abbreviate the
relation as
Awj = λjwj,
where λj = ( jπ)2.
Let H be the set of functions w that are zero on the boundary of , and for which
the integrals over  of |w|2 and ∥∇w∥2 exist. All of the properties that we listed for
eigenvectors also hold for eigenfunctions:
• When the eigenvalues are distinct, the eigenfunctions are unique, except that they
can be multiplied by any nonzero number.
• Deﬁne an inner product
(u,v) =


u(x)v(x)dx.
We say that A is self-adjoint (i.e., symmetric) if (u,Av) = (Au,v) for all choices of
functions u and v in H. In such a case, eigenfunctions wm and wℓcorresponding to
distinct eigenvalues are orthogonal, meaning that (wm,wℓ) = 0.
• The eigenfunctions are linearly independent, so they form a basis for functions de-
ﬁned on  that satisfy the zero boundary conditions.
• For self-adjoint problems, the smallest eigenvalue solves the minimization problem
min
w∈H,w̸=0
(w,Aw)
(w,w) .
(31.1)
Let’s ﬁnd the eigenvalues for a particular two-dimensional problem.
CHALLENGE 31.1.
Deﬁne the domain  = (0,b)×(0,b). Consider the elliptic partial differential equa-
tion
−uxx(x, y)−uyy(x, y) = λu(x, y)
for (x, y) ∈, with u(x, y) = 0 on the boundary of .
Show that the function
wmℓ(x, y) = sin(mπx/b)sin(ℓπy/b),
where m and ℓare positive integers, satisﬁes the differential equation and the boundary
conditions. Determine the corresponding eigenvalue λmℓ.

November 20, 2008 10:52
sccsbook
Sheet number 359 Page number 349
cyan magenta yellow black
How Can We Compute Approximations to the Eigenvalues?
349
How Can We Compute Approximations to the Eigenvalues?
Suppose we want to compute approximations to the eigenvalues and eigenfunctions of
Au = −∇·(a∇u)
on the domain , with u = 0 on the boundary of . Assume that a > 0 is a smooth func-
tion. In Challenge 27.4, we computed an approximate solution to a differential equation by
replacing it by a matrix problem. Here we do the same thing:
• Replace A by Ah, where Ah is the ﬁnite difference or ﬁnite element approximation
to −∇· (a∇u). The parameter h describes the mesh size for the ﬁnite difference
approximation or the triangle diameter for the ﬁnite element approximation.
• Use the eigenvalues λk,h of Ah as approximations to the eigenvalues of A. Since A
has an inﬁnite number of eigenvalues and Ah has ﬁnitely many, we can’t hope to get
good approximations to all eigenvalues of A, but the smallest ones should be well
approximated.
• For ﬁnite differences, the eigenvectors of Ah contain approximate values of the
eigenfunctions at the mesh points.
• For ﬁnite elements, the eigenvectors of Ah contain coefﬁcients in an expansion of an
approximation to the eigenfunction in the ﬁnite element basis.
Suppose  is a convex polygon and we use a piecewise linear ﬁnite element ap-
proximation. Let λk,h be the kth eigenvalue of Ah and let λk be the kth eigenvalue of A
(ascending order). Then there exist constants C and h0, depending on k, such that when h
is small enough,
λk ≤λk,h ≤λk +Ch2.
CHALLENGE 31.2.
In this challenge, we study the elliptic eigenvalue problem −∇· (∇u) = λu on the
square (−1,1) × (−1,1) with zero boundary conditions. We know the true eigenvalues
from Challenge 31.1, so we can determine how well the discrete approximation performs.
(a) Form a ﬁnite difference or ﬁnite element approximation to the problem and ﬁnd the
eigenfunctions corresponding to the 5 smallest eigenvalues. A few of them are pictured in
Figure 31.1.
• Describe in words the shape of each of these eigenfunctions. How does the shape
change as the eigenvalue increases?
• Theory tells us that we have good approximations with a coarse grid only for the
eigenfunctions corresponding to the smallest eigenvalues. How does the shape of the
eigenfunctions make this result easier to understand?
(b) Create 5 plots, for eigenvalues 1, 6, 11, 16, and 21, of the error in the approximate
eigenvalue vs. 1/h2. (Use at least 4 different matrix sizes, with the ﬁnest h < 1/50.)
• What convergence rate do you observe for each eigenvalue?
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 360 Page number 350
cyan magenta yellow black
350
Chapter 31. Case Study: Eigenvalues: Valuable Principles
Figure 31.1.
Eigenfunctions corresponding to the eigenvalues λ = 4.9348,
12.3370, 12.3370 (top row) and λ = 19.7392, 24.6740, 24.6740 (bottom row). For mul-
tiple eigenvalues, the choice of basis functions for the eigenfunctions is not unique.
• How does it compare with the theoretical convergence rate?
• Explain any discrepancy.
• Are all of the eigenvalues well-approximated by coarse meshes?
Some Useful Properties of Eigenvalues
Eigenvalues of elliptic operators have many useful properties. We’ll consider two of them
in the next challenge.
CHALLENGE 31.3.
(a) Suppose  is a domain in Rn. Suppose Aw = λw in  with w = 0 on the boundary,
where A is the self-adjoint operator
Aw = −∇·(a∇w)
and a = [a1,a2] > [0,0]. Prove that λ1 ≥0. Hint: Use integration by parts to replace
(w,Aw) by


a(x)∇w(x)·∇w(x)dx.
(b) Suppose we have two domains  ⊆˜. Prove that λ1() ≥λ1( ˜). Hint: Notice that the
eigenfunction for  can be extended to be a candidate for the minimization problem for ˜.

November 20, 2008 10:52
sccsbook
Sheet number 361 Page number 351
cyan magenta yellow black
How Are Eigenvalues and Eigenfunctions Used?
351
POINTER 31.1. Software.
MATLAB’s pdetool provides ﬁnite element algorithms to solve Challenges 31.2
and 31.4. You may want to make use of initmesh, refinemesh, pdeeig, squareg,
and squareb1.
In Challenge 31.4, you are solving a nonlinear equation: ﬁnd a value of α so that
the smallest eigenvalue (which is a function of α) equals a given value. The eigenvalue
is a monotonic function of α, increasing as α increases, and a root ﬁnder like MATLAB’s
fzero, discussed in Chapter 24, can be used.
POINTER 31.2. Further Reading.
A good introduction to the eigenvalues of differential operators and theory of ﬁnite
difference and ﬁnite element methods is given by Gockenbach [59]; for a more advanced
treatment, see, for example, Larsson and Thomée [99].
How Are Eigenvalues and Eigenfunctions Used?
The eigenvalues and eigenfunctions are useful mathematical quantities. If the eigensystem
for a differential operator on a domain  can be computed analytically, then the solution
to the differential equation involving that operator and that domain can be expressed as a
linear combination of the eigenfunctions, and it is then relatively simple to determine the
coefﬁcients.
The eigenvalues and eigenfunctions are also useful physical quantities. Suppose we
model the vibration of a drum with surface  through the problem
−utt −c2∇·(∇u) = 0 in .
We impose the boundary conditions u(x,t) = 0 for x on the boundary of  for all t > 0,
holding the edge of the drum ﬁxed against its rim. The eigenvalues λj of ∇·(∇u) determine
the characteristic frequencies of vibration of the drum, and c√λ1/(2π) is sometimes
called the fundamental frequency. If we excite the drum so that it vibrates according to
the corresponding eigenfunction, then the vibration persists.
By Challenge 31.3, we know, for example, that the fundamental frequency of a square
drum ˜ of size a ×a is no higher than that of a circular drum  of diameter a since  ⊂˜.
CHALLENGE 31.4.
Determine the dimension of a square drum that has fundamental frequency equal to
1 when c = 1. Use numerical methods to ﬁnd an elliptical domain αx2 + 2αy2 < 1 with
the same fundamental frequency.
You might repeat Challenge 31.4 for domains of different shapes, or for different
differential operators.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 362 Page number 352
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 363 Page number 353
cyan magenta yellow black
Chapter 32
Multigrid Methods:
Managing Massive
Meshes
In Chapter 28, we investigated iterative methods for solving large, sparse linear systems of
equations. We saw that the Gauss–Seidel method was intolerably slow, but various forms
of preconditioned conjugate gradient algorithms (PCG) gave us reasonable results.
The test problems we used were discretizations of elliptic partial differential equa-
tions, and for these problems, there is a faster class of methods, called multigrid algo-
rithms. Surprisingly, the Gauss–Seidel method (or some variant) is one of the two main
ingredients in these algorithms!
To introduce the ideas, let’s drop back to a somewhat simpler problem, a special case
of one that we considered in Chapter 23.
A Simple Example
Suppose we want to solve the differential equation
−uxx(x) = f (x)
on the domain x ∈[0,1], with u(0) = u(1) = 0. We know from Chapter 23 that we can
approximate the solution by deﬁning a grid or mesh xj = jh, where h = 1/(n + 1) for
some integer n. Then we can determine approximate values uj ≈u(xj), j = 1,...,n, using
ﬁnite difference or ﬁnite element approximations. If we choose ﬁnite differences, then
we have
−uxx(xj) ≈−uj−1 +2uj −uj+1
h2
,
so we obtain a system of equations Au = f with f = [ f (x1),..., f (xn)]T , u = [u1,...,un]T ,
and A equal to the n ×n tridiagonal matrix
A = 1
h2
⎡
⎢⎢⎢⎢⎣
2
−1
−1
2
−1
...
...
...
−1
2
−1
−1
2
⎤
⎥⎥⎥⎥⎦
.
353
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 364 Page number 354
cyan magenta yellow black
354
Chapter 32. Multigrid Methods: Managing Massive Meshes
Recall that in the Gauss–Seidel method of (28.1), we take an initial guess u(0) for the
solution and then update the guess by cycling through the equations, solving equation i for
the ith variable ui, so that given u(k), our next guess u(k+1) becomes
u(k+1)
i
=
⎛
⎝fi−
i−1
	
j=1
aiju(k+1)
j
−
n
	
j=i+1
aij u(k)
j
⎞
⎠/aii,
i = 1,...,n.
In our case, this reduces to
u(k+1)
i
= h2( fi +u(k+1)
i−1
+u(k)
i+1)/2,
i = 1,...,n,
where we deﬁne u(k)
0 = u(k)
n+1 = 0 for all k.
It is easy to see how Gauss–Seidel can be very slow on a problem like this. Suppose,
for example, that we take u(0) = 0 and that f is zero except for a 1 in its last position. Then
u(1) is zero except for its last entry, u(2) is zero except for its last two entries, and it takes n
iterations to get a guess that has a nonzero ﬁrst entry. Since the true solution has nonzeros
everywhere, this is not good!
The problem is that although Gauss–Seidel is good at ﬁxing the solution locally, the
information is propagated much too slowly globally, across the entire solution vector.
So if we are going to use Gauss–Seidel effectively, we need to couple it with a method
that has good global properties.
A Multigrid Algorithm
When we set up our problem, we chose a value of n, probably guided by the knowledge
that the error in the ﬁnite-difference approximation is proportional to h2. There is a whole
family of approximations, deﬁned by different choices of h, and we denote the system of
equations obtained using a grid length h = 1/(n +1) by
Ahuh = fh.
The grids on the interval [0,1] corresponding to h = 1/2, 1/4, 1/8, and 1/16 are shown in
Figure 32.1.
A large value of h gives a coarse grid. The dimension n of the resulting linear system
of equations is very small, though, so we can solve it fast using either a direct or an iterative
method. Our computed solution uh has the same overall shape as the true solution u but
loses a lot of local detail. In contrast, if we use a very ﬁne grid with a small value of h,
then the linear system of equations is very large and much more expensive to solve, but our
computed solution uh is very close to u.
In order to get the best of both worlds, we might use a coarse-grid solution as an
initial guess for the Gauss–Seidel iteration on a ﬁner grid. To do this, we must set values
for points in the ﬁner grid that are not in the coarse grid. If someone gave us a solution
to the system corresponding to h, then we could obtain an approximate solution for the
system corresponding to h/2 by interpolating those values:
• For points in the ﬁner grid that are common to the coarser grid, we just take their
values.

November 20, 2008 10:52
sccsbook
Sheet number 365 Page number 355
cyan magenta yellow black
A Multigrid Algorithm
355
0
1
1/2
Figure 32.1. Four levels of nested grids on the interval [0,1]. The coarsest grid,
with h = 1/2, consists of the blue points. Adding the red points gives h = 1/4. Including
the black points gives h = 1/8, and including all of the points gives the ﬁnest grid, with
h = 1/16.
• For points in the ﬁner grid that are midpoints of two points in the coarser grid, we
take the average of these two values.
This deﬁnes an interpolation operator Ph that takes values in a grid with parameter h
and produces values in the grid with parameter h/2. For example, because our boundary
conditions are zero,
P1/8 =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
1/2
0
0
0
0
0
0
1
0
0
0
0
0
0
1/2
1/2
0
0
0
0
0
0
1
0
0
0
0
0
0
1/2
1/2
0
0
0
0
0
0
1
0
0
0
0
0
0
1/2
1/2
0
0
0
0
0
0
1
0
0
0
0
0
0
1/2
1/2
0
0
0
0
0
0
1
0
0
0
0
0
0
1/2
1/2
0
0
0
0
0
0
1
0
0
0
0
0
0
1/2
1/2
0
0
0
0
0
0
1
0
0
0
0
0
0
1/2
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
.
The process of solving the problems on the sequence of nested grids gives us a nested
iteration algorithm, Algorithm 32.1, for our sample problem. The termination tolerance
for the ∞-norm of the residual fh −Ah ˜uh on grid h should be proportional to h2, since that
matches the size of the truncation error. This algorithm runs from coarse grid to ﬁnest and
is useful (although rather silly for one-dimensional problems). But there is a better way.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 366 Page number 356
cyan magenta yellow black
356
Chapter 32. Multigrid Methods: Managing Massive Meshes
Algorithm 32.1 Nested Iteration
Set k = 1, h = 1/2, and ˜uh = 0.
while the approximation is not good enough,
Set k = k +1, n = 2k −1, and h = 1/(n +1).
Form the matrix Ah and the right-hand side fh, and use the Gauss–Seidel iteration,
with the initial guess P2h ˜u2h, to compute an approximate solution ˜uh to Ahuh = fh.
end
The V-Cycle
We can do better if we run from ﬁnest grid to coarsest grid and then back to ﬁnest. This
algorithm has 3 ingredients:
• An iterative method that converges quickly if most of the error is high frequency—
oscillating rapidly—which happens when the overall shape of the solution is already
identiﬁed. Gauss–Seidel generally works well.
• A way to transfer values from a coarse grid to a ﬁne one—interpolation or prolon-
gation.
• A way to transfer values from a ﬁne grid to a coarse one—restriction.
We let Rh be the operator takes values on grid h/2 and produces values on grid h.
We already have matrices Ph for interpolation, and (for technical reasons related to
preserving the self-adjointness of the problems considered here) we choose Rh = PT
h .
We deﬁne the V-cycle idea recursively in Algorithm 32.2. In using this algorithm,
we can deﬁne A2h = R2hAhP2h. This deﬁnition is key to extending the multigrid algorithm
beyond problems that have a geometric grid; see Pointer 32.1 for a reference on these
algebraic multigrid methods. But for now, let’s see how it works on our original problem.
Algorithm 32.2 V-Cycle
vh = V-cycle(vh, Ah, fh, η1,η2)
if h is the coarsest grid parameter then
Compute vh to solve Ahvh = fh and return.
end
Perform η1 Gauss–Seidel iterations on Ahuh = fh using vh as the initial guess, ob-
taining an approximate solution that we still call vh.
Let v2h = V-cycle(0, A2h, R2h( fh −Ahvh), η1,η2).
Set vh = vh +P2hv2h.
Perform η2 Gauss–Seidel iterations on Ahuh = fh using vh as the initial guess, obtaining
an approximate solution that we still call vh.

November 20, 2008 10:52
sccsbook
Sheet number 367 Page number 357
cyan magenta yellow black
Cost of Multigrid
357
CHALLENGE 32.1.
Work through the V-cycle algorithm to see exactly what computations it performs on
our simple example for the sequence of grids deﬁned in Figure 32.1. Estimate the amount
of work, measured by the number of ﬂoating-point multiplications performed.
The standard multigrid algorithm repeats the V-cycle until convergence and is given
in Algorithm 32.3.
Algorithm 32.3 Standard Multigrid Algorithm for Solving Ahuh = fh
Initialize uh = 0.
while the termination criteria are not satisﬁed,
Compute uh = V-cycle(0,Ah,rh,η1,η2), where rh = fh −Ahuh.
Update uh = uh +uh.
end
Cost of Multigrid
Guided by Challenge 32.1, we can estimate the work for multigrid applied to a more gen-
eral problem. One step of the Gauss–Seidel iteration on a grid of size h costs about nz(h)
multiplications, where nz(h) is the number of nonzeros in Ah. We’ll call nz(h) multiplica-
tions a work unit.
Note that nz(h) ≈2nz(2h) since A2h has about half as many rows as Ah. So per-
forming one Gauss–Seidel step on each grid h,h/2,...,1 costs less than nz(h)(1 + 1/2 +
1/4 +···) = 2nz(h) multiplications ≡2 work units.
So the cost of a V-Cycle is at most 2 times the cost of (η1 +η2) Gauss–Seidel itera-
tions on the ﬁnest grid plus a modest amount of additional computational overhead. Is it
just as efﬁcient in storage?
CHALLENGE 32.2.
Convince yourself that the storage necessary for all of the matrices and vectors is also
a modest multiple of the storage necessary for the ﬁnest grid.
We know that stationary iterative methods like Gauss–Seidel are usually very slow
(take many iterations), so the success of multigrid relies on the fact that we need only a few
iterations on each grid, because the error is mostly local. Thus the total amount of work to
solve the full problem to a residual of size O(h2) is a small number of work units.
Since it is rather silly to use anything other than sparse Gauss elimination to solve
a system involving a tridiagonal matrix, we won’t implement the algorithm for our one-
dimensional problem. Note, though, that our algorithm readily extends to higher dimen-
sions; we just need to deﬁne Ah and Ph for a nested set of grids in order to use the multigrid
V-cycle algorithm.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 368 Page number 358
cyan magenta yellow black
358
Chapter 32. Multigrid Methods: Managing Massive Meshes
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Blue coarse grid
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Red fine grid
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Black finest grid
Figure 32.2. The blue gridpoints (top left) deﬁne the coarse grid. The blue and the
red gridpoints (top right) deﬁne the ﬁner grid. The blue, red, and black gridpoints (bottom)
deﬁne the ﬁnest grid.
Multigrid for Two-Dimensional Problems
Our ﬁrst challenge in applying multigrid to two-dimensional problems is to develop a
sequence of nested grids.
Since we discussed ﬁnite difference methods for the one-
dimensional problem, let’s focus on ﬁnite element methods for the two-dimensional prob-
lem, using a triangular grid and piecewise-linear basis functions.
It is most convenient to start from a coarse grid and obtain our ﬁnest grid through
successive reﬁnements. Consider the grid in Figure 32.2 that divides the unit square into
8 triangles with height h = 1/2. The grid points are marked in blue. Consider taking the
midpoints of each side of one of triangles and drawing the triangle with those points as
vertices. If we do this for each triangle, we obtain the red grid points in Figure 32.2 and
the red triangles. Each of the original blue triangles has been replaced by 4 triangles, each
having 1 or 3 red sides, and each triangle has height h = 1/4. If we repeat this process, we
obtain the black grid points of Figure 32.2 and a grid length h = 1/8.
Writing a program for grid reﬁnement on a general triangular grid takes a bit of effort;
see refine.m on the website.
Interpolating from one grid to the next ﬁner one is easy. For example, given the
blue grid values, we obtain values for the blue and red grid by following two rules: blue
gridpoints retain their values, and red grid values are deﬁned as the average of the nearest
two values on the blue edge containing it. As before, we take the restriction operator to be
the transpose of the interpolation operator.

November 20, 2008 10:52
sccsbook
Sheet number 369 Page number 359
cyan magenta yellow black
Multigrid for Two-Dimensional Problems
359
So we have all the machinery necessary to apply multigrid to two-dimensional prob-
lems, and we experiment with it in the next challenge.
CHALLENGE 32.3.
Write a program that applies the multigrid V-cycle iteration to the two-dimensional
problems used in Chapter 28. The MATLAB program generateproblem.m produces
a structure called mesh which contains, in addition to the matrices and right-hand side
information, the operators P and the coordinates p of the grid points. The differential
equation is
−uxx(x, y)−uyy(x, y)+κu(x, y) = f (x, y)
for (x, y) ∈[−1,1] × [−1,1] (myproblem=1) or for this domain with a hole cut out
(myproblem=2). The boundary conditions are that u is zero on the boundary of the
square, and (for the second case) the normal derivative is zero at the boundary of the hole.
Set κ = 0 and compare the time for solving the problem using multigrid to the methods
deﬁned in Chapter 28.
If the partial differential equation is elliptic, as it is for κ ≥0, it is not too hard to
achieve convergence in a small number of work units. In fact, multigrid experts would
say that if we don’t achieve it, then we have chosen either the iteration or the interpola-
tion/restriction pair “incorrectly.” For problems that are not elliptic, though, things get a bit
more complicated, as we see in the next challenge.
CHALLENGE 32.4.
Repeat your experiment from Challenge 32.3, but use κ = 10 and 100 and then κ =
−10 and −100. (When κ ̸= 0, the differential equation is called the Helmholtz equation.)
The differential equation remains elliptic for positive κ but not for negative. How was
convergence of multigrid affected?
We see that the problem is much harder to solve for negative values of κ. There are
two reasons for this: ﬁrst, the matrix Ah is no longer positive deﬁnite, so we lose a lot of
nice structure, and second, ﬁner grids are necessary to represent the solution accurately. In
order to restore convergence in a small number of work units for the nonelliptic problem,
we must make the algorithm more complicated; for example, we might use multigrid as a
preconditioner for a Krylov subspace method, bringing us back to the methods used in the
Chapter 28. More information about this can be found in the references in Pointer 32.1.
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 370 Page number 360
cyan magenta yellow black
360
Chapter 32. Multigrid Methods: Managing Massive Meshes
POINTER 32.1. Further Reading.
The multigrid idea dates back to R. P. Fedorenko in 1964. A good introduction is
given in a tutorial by Briggs, Henson, and McCormick [20]. “Multigrid” ideas are use-
ful even when there is no natural geometric “grid” underlying the problem; the resulting
method is called algebraic multigrid and is brieﬂy discussed in [20].
It is also useful to use multigrid if only a portion of the grid is reﬁned from one level
to the next; for example, we might want to reﬁne only in regions in which the solution is
rapidly changing, where the current grid does not capture its behavior accurately enough.
These adaptive methods are also discussed in [20].
One multigrid approach to solving the Helmholtz equation with negative κ is given
in [46].

November 20, 2008 10:52
sccsbook
Sheet number 371 Page number 361
cyan magenta yellow black
Bibliography
[1] E.L. Allgower and K. Georg. Introduction to Numerical Continuation Methods.
SIAM, Philadelphia, PA, 2003. (Cited on p. 296.)
[2] E. Anderson, Z. Bai, C. Bischof, S. Blackford, J. Demmel, J. Dongarra, J. Du Croz,
A. Greenbaum, S. Hammarling, A. McKenney, and D. Sorensen. LAPACK Users’
Guide, Third Edition. SIAM, Philadelphia, 1999. (Cited on pp. 38, 78, 79.)
[3] Douglas Arnold.
Some disasters attributable to bad numerical computing.
http://www.ima.umn.edu/~arnold/disasters/disasters.html.
Retrieved May 2008. (Cited on p. 14.)
[4] V. Arun. The Solution of Variable-Geometry Truss Problems Using New Homotopy
Continuation Methods. PhD thesis, Mechanical Engineering Department, Virginia
Polytechnic Institute and State University, Blacksburg, Virginia, September 1990.
(Cited on pp. 299, 300, 300.)
[5] V. Arun, C. F. Reinholtz, and L. T. Watson. Application of new homotopy contin-
uation techniques to variable geometry trusses. J. Mech. Des., 114:422–428, 1992.
(Cited on pp. 296, 299, 300, 300.)
[6] Randolph E. Bank.
Software: Pltmg 10.0.
http://scicomp.ucsd.edu/
~reb/software.html), 2007. Retrieved May 2008. (Cited on p. 339.)
[7] R. Bartels and G. W. Stewart. Algorithm 432: The solution of the matrix equation
AX −X B = C. Communications of the ACM, 15(9):820–826, 1972.
(Cited on
p. 346.)
[8] K.-J. Bathe. Finite Element Procedures. Prentice Hall, Englewood Cliffs, NJ, 1996.
(Cited on p. 339.)
[9] Mokhtar S. Bazaraa, Hanif D. Sherali, and C. M. Shetty. Nonlinear Programming:
Theory and Algorithms, Third Edition. Wiley Interscience, New York, 2006. (Cited
on p. 339.)
[10] Isabel Beichl, Dianne P. O’Leary, and Francis Sullivan. Approximating the number
of monomer-dimer coverings in periodic lattices. Physical Review E, 64:016701.1–
6, 2001. (Cited on p. 202.)
361
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 372 Page number 362
cyan magenta yellow black
362
Bibliography
[11] Isabel Beichl and Francis Sullivan. The importance of importance sampling. Com-
puting in Science and Engineering, 1(2):71–73, March-April 1999.
(Cited on
pp. 202, 212.)
[12] A. Bellen and M. Zennaro. Numerical Methods for Delay Differential Equations.
Oxford Science Pub., 2003. (Cited on p. 264.)
[13] Edward Beltrami. Mathematics for Dynamic Modeling, Second Edition. Academic
Press, Boston, MA, 1998. (Cited on p. 267.)
[14] Jon Bentley. Programming Pearls, Second Edition. Addison-Wesley, Reading, MA,
2000. (Cited on p. 43.)
[15] Michael W. Berry and Murray Browne. Understanding Search Engines: Mathemat-
ical Modeling and Text Retrieval, Second Edition. SIAM, Philadelphia, PA, 2005.
(Cited on p. 333.)
[16] Åke Björck. Numerical Methods for Least Squares Problems. SIAM Press, Philadel-
phia, PA, 1996. (Cited on p. 66.)
[17] K. E. Brenan, S. L. Campbell, and L. R. Petzold. Numerical Solution of Initial-
Value Problems in Differential-Algebraic Equations, volume 14 of Classics in Ap-
plied Mathematics. SIAM, Philadelphia, PA, 1995. Revised and corrected reprint of
the 1989 original. (Cited on p. 257.)
[18] Susanne C. Brenner and L. Ridgeway Scott. The Mathematical Theory of Finite
Element Methods, Third Edition. Springer, New York, 2008. (Cited on p. 339.)
[19] R. P. Brent. Algorithms for Minimization without Derivatives. Prentice-Hall, Engle-
wood Cliffs, NJ, 1973. Reprinted by Dover, 2002. (Cited on p. 286.)
[20] William L. Briggs, Van Emden Henson, and Steve F. McCormick.
A Multigrid
Tutorial, Second Edition. SIAM, Philadelphia, PA, 2000. (Cited on p. 360.)
[21] Nicholas F. Britton. Essential Mathematical Biology. Springer UndergraduateMath-
ematics Series. Springer-Verlag London Ltd., London, 2003.
(Cited on pp. 219,
264.)
[22] C. G. Broyden. Quasi-Newton methods. In W. Murray, editor, Numerical Methods
for Unconstrained Optimization, pages 87–106. Academic Press, New York, 1972.
(Cited on p. 133.)
[23] Russel E. Caﬂisch. Monte Carlo and quasi-Monte Carlo methods. Acta Numerica,
7:1–49, 1998. (Cited on pp. 202, 212, 212.)
[24] James Callahan.
The spread of a contagious illness.
http://www.math.
smith.edu/~callahan/ili/pde.html,1996. Retrieved May 2008. (Cited
on p. 264.)
[25] A. H. A. Clayton and W. H. Sawyer. Site-speciﬁc tryptophan dynamics in class A
amphipathic helical peptides at a phospholipid bilayer interface. Biophysical Jour-
nal, 79:1066–1073, 2000. (Cited on p. 168.)

November 20, 2008 10:52
sccsbook
Sheet number 373 Page number 363
cyan magenta yellow black
Bibliography
363
[26] Earl A. Coddington. An Introduction to Ordinary Differential Equations. Prentice-
Hall, Englewood Cliffs, NJ, 1961. (Cited on p. 226.)
[27] Thomas F. Coleman and Arun Verma. Admit-1: automatic differentiation and MAT-
LAB interface toolbox. ACM Trans. Math. Softw., 26(1):150–175, 2000. (Cited on
p. 122.)
[28] A.R. Conn, N.I.M. Gould, and P.L. Toint. Trust-Region Methods. SIAM, Philadel-
phia, PA, 2000. (Cited on pp. 133, 296.)
[29] R. F. Costantino, Robert A. Desharnais, J. M. Cushing, Brian Dennis, Shandelle M.
Henson, and Aaron A. King. Nonlinear stochastic population dynamics: The ﬂour
beetle Tribolium as an effective tool of discovery. Advances in Ecological Research,
37:101–141, 2005. (Cited on p. 306.)
[30] D. Coppersmith and S. Winograd. Matrix multiplication via arithmetic progressions.
J. Symbolic Comput., 9:251–280, 1990. (Cited on p. 37.)
[31] Patrick Cousot. Methods and logics for proving programs. In J. van Leeuwen, editor,
Handbook of Theoretical Computer Science, Vol B: Formal Models and Semantics,
pages 843–993. North Holland, Amsterdam, The Netherlands, 1990. Chapter 15.
(Cited on p. 43.)
[32] Germund Dahlquist and Åke Björck. Numerical Methods in Scientiﬁc Computing,
Volume 1. SIAM, Philadelphia, PA, 2008. (Cited on pp. 107, 212, 283.)
[33] Biswa Datta. Numerical Methods for Linear Control Systems. Elsevier Academic
Press, Boston, MA, 2004. (Cited on p. 346.)
[34] Ian Davidson. Understanding k-means non-hierarchical clustering. Technical re-
port, Computer Science Department, State University of New York, Albany, Tech-
nical Report 02-2, http://www.cs.albany.edu/~davidson/courses/
CSI635/UnderstandingK-MeansClustering.pdf, 2002. Retrieved Au-
gust 2007. (Cited on p. 155.)
[35] Timothy A. Davis. Direct Methods for Sparse Linear Systems. SIAM, Philadelphia,
PA, 2006. (Cited on p. 322.)
[36] Timothy A. Davis. University of Florida sparse matrix collection. http://www.
cise.ufl.edu/research/sparse/matrices,2007. Retrieved May 2008.
(Cited on p. 334.)
[37] James W. Demmel. Applied Numerical Linear Algebra. SIAM, Philadelphia, PA,
1997. (Cited on p. 70.)
[38] James W. Demmel. Lecture notes on spectral partitioning. http://www.cs.
berkeley.edu/~demmel/cs267/lecture20/lecture20.html, 1999.
Retrieved August 2007. (Cited on p. 322.)
[39] Brian Dennis, Robert A. Desharnais, J. M. Cushing, and R. F. Costantino. Nonlinear
demographic dynamics: Mathematical models, statistical methods, and biological
experiments. Ecological Monographs, 65:261–281, 1995. (Cited on pp. 302, 306.)
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 374 Page number 364
cyan magenta yellow black
364
Bibliography
[40] J. E. Dennis, Jr. and R. B. Schnabel. Least change secant updates for quasi-Newton
methods. SIAM Rev., 21(4):443–459, 1979. (Cited on p. 133.)
[41] J. E. Dennis, Jr. and Robert B. Schnabel. Numerical Methods for Unconstrained Op-
timization and Nonlinear Equations, volume 16 of Classics in Applied Mathematics.
SIAM, Philadelphia, PA, 1996. Corrected reprint of the 1983 original.
(Cited on
p. 133.)
[42] S. E. Derenzo, M. J. Weber, W. W. Moses, and C. Dujardin. Measurements of the
intrinsic rise times of common inorganic scintillators. IEEE Trans. Nucl. Sci., NS-
47:860–864, 2000. (Cited on p. 168.)
[43] Robert A. Desharnais and Laifu Liu. Stable demographic limit cycles in laboratory
populations of Tribolium castaneum. Journal of Animal Ecology, 56(3):885–906,
1987. (Cited on pp. 304, 306.)
[44] I. S. Dhillon, Y. Guan, and J. Kogan. Iterative clustering of high dimensional text
data augmented by local search. In Proceedings of the 2002 IEEE International
Conference on Data Mining, http://www.cs.utexas.edu/users/dml/
Software/gmeans.html, 2002. Retrieved August 2007. (Cited on p. 155.)
[45] I. S. Duff, A. M. Erisman, and J. K. Reid. Direct Methods for Sparse Matrices.
Oxford Press, 1986. (Cited on p. 322.)
[46] Howard C. Elman, Oliver G. Ernst, and Dianne P. O’Leary. A multigrid method
enhanced by Krylov subspace iteration for discrete Helmholtz equations. SIAM J.
Sci. Comput., 23:1291–1315, 2001. (Cited on p. 360.)
[47] Haw-ren Fang and Dianne P. O’Leary. Stable factorizations of symmetric tridiagonal
and triadic matrices. SIAM J. Matrix Anal. Appl., 28:576–595, 2006.
(Cited on
p. 133.)
[48] Ricardo Fierro, Gene H. Golub, Per Christian Hansen, and Dianne P. O’Leary. Reg-
ularization by truncated total least squares. SIAM J. Sci. Comput., 18:1223–1241,
1997. (Cited on p. 174.)
[49] George S. Fishman. Monte Carlo: Concepts, Algorithms and Applications. Springer,
London, 2003. (Cited on p. 30.)
[50] R. Fletcher. Practical Methods of Optimization, Second Edition. Wiley-Interscience,
New York, 2001. (Cited on pp. 116, 121, 122, 133.)
[51] Geoffrey C. Fox, Roy D. Williams, and Paul C. Messina. Parallel Computing Works.
Morgan Kaufmann, San Francisco, CA, 1994. (Cited on p. 212.)
[52] Keinosuke Fukunaga. Introduction to Statistical Pattern Recognition, Second Edi-
tion. Academic Press, Boston, MA, 1990. (Cited on p. 155.)
[53] Walter Gander. Heisenberg effects in computer arithmetic. http://www.inf.
ethz.ch/news/focus/res_focus/april_2005.
Retrieved May 2008.
(Cited on p. 14.)

November 20, 2008 10:52
sccsbook
Sheet number 375 Page number 365
cyan magenta yellow black
Bibliography
365
[54] C. W. Gear. Numerical Initial Value Problems in Ordinary Differential Equations.
Prentice-Hall, Englewood Cliffs, NJ, 1971. (Cited on p. 257.)
[55] Alan George and Joseph W. Liu. Computer Solution of Large Sparse Positive Deﬁ-
nite Systems. Prentice-Hall, Englewood Cliffs, NJ, 1981. (Cited on p. 322.)
[56] John R. Gilbert, Gary L. Miller, and Shang-Hua Teng. Geometric mesh partition-
ing: Implementation and experiments. SIAM J. Sci. Comput., 19:2091–2110, 1998.
(Cited on p. 320.)
[57] John R. Gilbert and Shang-Hua Teng. Mesh partitioning and graph separator tool-
box. http://www.cerfacs.fr/algor/Softs/MESHPART/, 2002. Re-
trieved May 2008. (Cited on p. 320.)
[58] P. E. Gill, G. H. Golub, W. Murray, and M. A. Saunders. Methods for modifying
matrix factorizations. Math. Comp., 28:505–535, 1974. (Cited on pp. 95, 126.)
[59] Mark S. Gockenbach. Partial Differential Equations. SIAM, Philadelphia, PA, 2002.
(Cited on pp. 280, 351.)
[60] Gene H. Golub. Some modiﬁed matrix eigenvalue problems. SIAM Rev., 15:318–
334, 1973. (Cited on p. 95.)
[61] Gene H. Golub, Per Christian Hansen, and Dianne P. O’Leary. Tikhonov regulariza-
tion and total least squares. SIAM J. Matrix Anal. Appl., 21:185–194, 1999. (Cited
on p. 174.)
[62] G.H. Golub and W. Kahan. Calculating the singular values and pseudo-inverse of a
matrix. SIAM J. Numer. Anal, 2(3):205–224, 1965. (Cited on p. 85.)
[63] Gene H. Golub and Victor Pereyra. Separable nonlinear least squares: the variable
projection method and its applications. Inverse Problems, 19:R1–R26, 2003. (Cited
on p. 168.)
[64] Gene H. Golub and Charles F. Van Loan. Matrix Computations, Third Edition. Johns
Hopkins Studies in the Mathematical Sciences. Johns Hopkins University Press, Bal-
timore, MD, 1996. (Cited on pp. 53, 56, 69, 79, 95, 103, 162.)
[65] Yuqian Guan. Gmeans—a clustering tool in ping-pong style. http://www.cs.
utexas.edu/users/dml/Software/gmeans.html,2002. Retrieved May
2008. (Cited on p. 155.)
[66] Mads Haahr. Random.org. http://www.random.org/, 1998. Retrieved May
2008. (Cited on p. 194.)
[67] Jack K. Hale and Sjoerd M. V. Lunel. Introduction to Functional-Differential Equa-
tions, volume 99 of Applied Mathematical Sciences. Springer-Verlag, New York,
1993. (Cited on p. 264.)
[68] Per Christian Hansen. Rank-Deﬁcient and Discrete Ill-Posed Problems.
SIAM,
Philadelphia, PA, 1998. (Cited on pp. 86, 174.)
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 376 Page number 366
cyan magenta yellow black
366
Bibliography
[69] Per Christian Hansen, James M. Nagy, and Dianne P. O’Leary. Deblurring Images:
Matrices, Spectra, and Filtering. SIAM, Philadelphia, PA, 2006. (Cited on pp. 84,
86, 346, 346.)
[70] Simon Haykin. Adaptive Filter Theory, Fourth Edition. Prentice-Hall, Englewood
Cliffs, NJ, 1996. (Cited on p. 103.)
[71] Michael Heath. Scientiﬁc Computing: An Introductory Survey, Second Edition. Mc-
Graw Hill, Boston, MA, 2002. (Cited on pp. xiii, xiv, 185.)
[72] Peter Hellekalek et al.
Random number generators.
http://random.mat.
sbg.ac.at/, 2006. Retrieved May 2008. (Cited on p. 194.)
[73] Richard W. Hendler, Lel A. Drachev, Salil Bose, and Manjoj K. Joshi. On the kinet-
ics of voltage formation in purple membranes of Halobacterium salinarium. Euro-
pean Journal of Biochemistry, 267:5879–5890, 2000. (Cited on p. 168.)
[74] John L. Hennessy and David A. Patterson. Computer Architecture: A Quantitative
Approach, Second Edition. Morgan Kaufmann, San Francisco, CA, 1996.
(Cited
on p. 38.)
[75] Peter Henrici. Discrete Variable Methods in Ordinary Differential Equations. John
Wiley & Sons, New York, 1962. (Cited on p. 223.)
[76] Magnus R. Hestenes and Eduard Stiefel. Methods of conjugate gradients for solving
linear systems. J. Research Nat. Bur. Standards, 49:409–436, 1952.
(Cited on
p. 127.)
[77] Desmond J. Higham.
An algorithmic introduction to numerical simulation of
stochastic differential equations.
SIAM Rev., 43(3):525–546, 2001.
(Cited on
p. 264.)
[78] Desmond J. Higham and Nicholas J. Higham. MATLAB Guide, Second Edition.
SIAM, Philadelphia, PA, 2005. (Cited on pp. 3, 43.)
[79] Nicholas J. Higham. Accuracy and Stability of Numerical Algorithms, Second Edi-
tion. SIAM Press, Philadelphia, PA, 2002. (Cited on pp. 22, 30, 37, 346.)
[80] Frank C. Hoppensteadt and Charles S. Peskin. Mathematics in Medicine and the
Life Sciences, volume 10 of Texts in Applied Mathematics. Springer-Verlag, New
York, 1992. (Cited on p. 219.)
[81] Roger A. Horn and Charles R. Johnson. Topics in Matrix Analysis. Cambridge
University Press, Cambridge, 1994. Corrected reprint of the 1991 original. (Cited
on p. 86.)
[82] Thomas Huckle.
Collection of software bugs.
http://www5.in.tum.de/
~huckle/bugse.html. Retrieved May 2008. (Cited on p. 14.)
[83] Human Genome Sequencing Center. Tribolium castaneum genome project. http:
//www.hgsc.bcm.tmc.edu/projects/tribolium/, 2007.
Retrieved
May 2008. (Cited on p. 306.)

November 20, 2008 10:52
sccsbook
Sheet number 377 Page number 367
cyan magenta yellow black
Bibliography
367
[84] Anil K. Jain and Richard C. Dubes. Algorithms for Clustering Data. Prentice Hall
Advanced Reference Series. Prentice-Hall, Englewood Cliffs, NJ, 1988. (Cited on
p. 155.)
[85] A. K. Jain, M. N. Murty, and P. J. Flynn. Data clustering: A review. ACM Comput.
Surv., 31(3):264–323, 1999. (Cited on p. 155.)
[86] M. A. Jenkins and J. F. Traub. Algorithm 419: zeros of a complex polynomial.
Communications of the ACM, 15(2):97–99, 1972. (Cited on p. 286.)
[87] D. S. Jones and B. D. Sleeman. Differential Equations and Mathematical Biol-
ogy. Chapman & Hall/CRC Mathematical Biology and Medicine Series. Chapman
& Hall/CRC, Boca Raton, FL, 2003. (Cited on p. 264.)
[88] C. T. Kelley. Solving Nonlinear Equations with Newton’s Method. SIAM, Philadel-
phia, PA, 2003. (Cited on p. 296.)
[89] Claire Kenyon, Dana Randall, and Alistair Sinclair. Approximating the number of
monomer-dimer coverings of a lattice.
J. Statist. Phys., 83(3-4):637–659, 1996.
(Cited on p. 202.)
[90] S. Kirkpatrick, C. D. Gelatt, and M. P. Vecchi. Optimization by simulated annealing.
Science, 220(4598):671–680, 1983. (Cited on p. 202.)
[91] Donald E. Knuth. The Art of Computer Programming. Vol. 1: Fundamental Algo-
rithms, Third Edition. Addison-Wesley Publishing Co., Reading, MA, 1997. (Cited
on p. 194.)
[92] Donald E. Knuth. The Art of Computer Programming. Vol. 2: Seminumerical Algo-
rithms, Third Edition. Addison-Wesley Publishing Co., Reading, MA, 1997. (Cited
on p. 219.)
[93] Donald E. Knuth. Literate Programming. Lecture Notes 27, Center for the Study of
Language and Information, Stanford, CA, 1992. (Cited on p. 43.)
[94] Gina Bari Kolata. Flu: The Story of the Great Inﬂuenza Pandemic of 1918 and the
Search for the Virus That Caused It. Farrar, Straus, and Giroux, New York, 1999.
(Cited on p. 219.)
[95] T.G. Kolda, R.M. Lewis, and V. Torczon. Optimization by direct search: New per-
spectives on some classical and modern methods. SIAM Rev., 45(3):385–482, 2003.
(Cited on p. 133.)
[96] Jack B. Kuipers. Quaternions and Rotation Sequences: A Primer with Applications
to Orbits, Aerospace and Virtual Reality. Princeton University Press, Princeton, NJ,
2002. (Cited on p. 162.)
[97] Peter Kunkel and V. Mehrmann. Differential-Algebraic Equations. Analysis and
Numerical Solution. European Mathematical Society. EMS Textbooks, 2006. (Cited
on pp. 248, 250, 257.)
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 378 Page number 368
cyan magenta yellow black
368
Bibliography
[98] David Lane, Joan Lu, Camille Peres, and Emily Zitek. Online statistics: An inter-
active multimedia course of study. http://onlinestatbook.com. Retrieved
May 2008. (Cited on pp. 185, 189.)
[99] Stig Larsson and Vidar Thomée.
Partial Differential Equations with Numerical
Methods, volume 45 of Texts in Applied Mathematics. Springer-Verlag, Berlin, 2003.
(Cited on pp. 223, 251, 252, 280, 351.)
[100] R.B. Lehoucq, D.C. Sorensen, and C. Yang.
ARPACK Users’ Guide: Solution
of Large-Scale Eigenvalue Problems with Implicitly Restarted Arnoldi Methods.
SIAM, Philadelphia, PA, 1998. (Cited on p. 334.)
[101] Walter Leighton. Ordinary Differential Equations. Wadsworth Publishing Co., Bel-
mont, CA, 1966. (Cited on p. 271.)
[102] Steven J. Leon. Linear Algebra with Applications, Sixth Edition. Prentice-Hall,
Englewood Cliffs, NJ, 2002. (Cited on p. 271.)
[103] T. Y. Li. Numerical Solution of Polynomial Systems by Homotopy Continuation
Methods. Handbook of Numerical Analysis, 11:209–304, 2003. (Cited on p. 296.)
[104] K. J. R. Liu, D. P. O’Leary, G. W. Stewart, and Y-J. J. Wu. URV ESPRIT for tracking
time-varying signals. IEEE Trans. Signal Proc., 42:3441–3448, 1994.
(Cited on
p. 103.)
[105] Ivo Marek. Iterative aggregation/disaggregation methods for computing some char-
acteristics of Markov chains. II. Fast convergence. Appl. Numer. Math., 45(1):11–28,
2003. (Cited on p. 219.)
[106] Mathematical and Computational Sciences Division. Matrix market. http://
math.nist.gov/MatrixMarket/. Retrieved May 2008. (Cited on pp. 311,
334.)
[107] W. Miller. Computational complexity and numerical stability. SIAM J. Comput.,
4(2):97–107, 1975. (Cited on p. 346.)
[108] Cleve B. Moler. Numerical Computing with MATLAB. SIAM, Philadelphia, PA,
2004. (Cited on pp. xiii, xiv.)
[109] A. M. Mood and F. A. Graybill. Introduction to the Theory of Statistics. McGraw-
Hill, New York, 1963. (Cited on p. 202.)
[110] R. E. Moore. Interval Analysis. Prentice-Hall, Englewood Cliffs, NJ, 1966. (Cited
on p. 30.)
[111] Stephen G. Nash and Ariela Sofer. Linear and Nonlinear Programming. McGraw-
Hill, Boston, MA, 1996. (Cited on pp. 30, 117, 125, 127, 133, 148.)
[112] M. Nauenberg, F. Kuttner, and M. Furman. Method for evaluating one-dimensional
path integrals. Physical Review A, 13(3):1185–1189,March 1976. (Cited on p. 212.)

November 20, 2008 10:52
sccsbook
Sheet number 379 Page number 369
cyan magenta yellow black
Bibliography
369
[113] C. R. Nave.
The energy distribution function.
http://hyperphysics.
phy-astr.gsu.edu/hbase/quantum/disfcn.html, 2005.
Retrieved
May 2008. (Cited on p. 189.)
[114] Arkadi Nemirovski. Lecture notes on interior point polynomial time methods in
convex programming. Technical Report ISYE 8813, Georgia Institute of Technology
School of Industrial and Systems Engineering, Spring 2004. (Cited on p. 148.)
[115] Jorge Nocedal and Stephen J. Wright. Numerical Optimization, Second Edition.
Springer, New York, 2006. (Cited on p. 148.)
[116] K. Ogata. Modern Control Engineering, Third Edition. Prentice-Hall, Englewood
Cliffs, NJ, 1996. (Cited on p. 271.)
[117] Dianne P. O’Leary and Wei H. Yang. Elasto-plastic torsion by quadratic program-
ming.
Computer Methods in Applied Mechanics and Engineering, 16:361–368,
1978. (Cited on p. 339.)
[118] Suely Oliveira and David Stewart. Writing Scientiﬁc Software: A Guide to Good
Style. Cambridge University Press, Cambridge, England, 2006. (Cited on p. 43.)
[119] James M. Ortega. Numerical Analysis: A Second Course. Academic Press, New
York, 1972. (Cited on pp. 53, 181, 334.)
[120] J. M. Ortega and W. C. Rheinboldt. Iterative Solution of Nonlinear Equations in
Several Variables. Academic Press, New York, 1970. (Cited on p. 296.)
[121] Michael L. Overton. Numerical Computing with IEEE Floating Point Arithmetic.
SIAM, Philadelphia, PA, 2001. (Cited on pp. 9, 10, 22.)
[122] C. C. Paige and M. A. Saunders.
LSQR: An algorithm for sparse linear
equations and sparse least squares.
ACM Trans. Math. Softw., 8:43–71, 1982.
http://www.stanford.edu/group/SOL/software/lsqr.html. (Cited on pp. 330, 334.)
[123] C. C. Paige and M. A. Saunders.
Solution of sparse indeﬁnite sys-
tems
of
linear equations.
SIAM J.
Numer.
Anal.,
12:617–629,
1975.
http://www.stanford.edu/group/SOL/software/symmlq.html.
(Cited on pp. 330,
334.)
[124] Per-Olof Persson and Gilbert Strang. A simple mesh generator in MATLAB. SIAM
Review, 46:329–345, 2004. (Cited on p. 334.)
[125] A. Pothen, H. Simon, and K.-P. Liou. Partitioning sparse matrices with eigenvectors
of graphs. SIAM J. Matrix Anal. Appl., 11:430–452, 1990. (Cited on p. 322.)
[126] Armin Pruessner and Dianne P. O’Leary. Blind deconvolution using a regularized
structured total least norm approach. SIAM J. Matrix Anal. Appl., 24:1018–1037,
2003. (Cited on p. 181.)
[127] R. Roy and T. Kailath. ESPRIT—estimation of signal parameters via rotational
invariance techniques. In IEEE Trans. ASSP, 34:984–995, 1989. (Cited on p. 103.)
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 380 Page number 370
cyan magenta yellow black
370
Bibliography
[128] W.J. Rugh. Linear System Theory, Second Edition. Prentice-Hall, Englewood Cliffs,
NJ, 1996. (Cited on p. 271.)
[129] Bert W. Rust. Fitting nature’s basic functions. Computing in Science and Engi-
neering. 3(5):84-89, 2001; 3(6):60–64, 2001; 4(4):72-77, 2002; 5(2):74-79, 2003.
(Cited on p. 168.)
[130] Bert W. Rust and Dianne P. O’Leary. Conﬁdence intervals for discrete approxi-
mations to ill-posed problems. Journal of Computational and Graphical Statistics,
3:67–96, 1994. (Cited on p. 30.)
[131] Bert W. Rust and Dianne P. O’Leary. Residual periodograms for choosing regu-
larization parameters for ill-posed problems. Inverse Problems, 24:034005, 2008.
(Cited on p. 84.)
[132] Yousef Saad. Iterative Methods for Sparse Linear Systems, Second Edition. SIAM,
Philadelphia, PA, 2003. (Cited on p. 334.)
[133] Hanan Samet. Foundations of Multidimensional and Metric Data Structures. Mor-
gan Kaufmann, San Francisco, CA, 2005. (Cited on p. 38.)
[134] Edward R. Scheinerman. Invitation to Dynamical Systems. Prentice-Hall, Engle-
wood Cliffs, NJ, 1996. http://www.ams.jhu.edu/~ers/invite.html.
Retrieved October 2008. (Cited on p. 306.)
[135] Gerhart I. Schuëller, Helmut J. Pradlwarter, and P. S. Koutsourelakis. A comparative
study of reliability estimation procedures for high dimensions. In 16th ASCE En-
gineering Mechanics Conference. Seattle, Washington, 2003. http://www.ce.
washington.edu/em2003/proceedings/papers/777.pdf. Retrieved
October 2008. (Cited on p. 212.)
[136] A. P. S. Selvadurai. Partial Differential Equations in Mechanics 2. Springer, New
York, 2000. (Cited on p. 339.)
[137] Richard I. Shrager and Richard W. Hendler. Some pitfalls in curve-ﬁtting and how
to avoid them: A case in point. J. Biochem. Biophys. Methods, 36:157–173, 1998.
(Cited on p. 168.)
[138] Smithsonian National Air and Space Museum.
How things ﬂy:
Roll, pitch,
and yaw. http://www.nasm.si.edu/exhibitions/gal109/NEWHTF/
HTF541B.HTM, 1996. Retrieved May 2008. (Cited on p. 162.)
[139] G. W. Stewart.
Matrix Algorithms, Volume 1: Basic Decompositions.
SIAM,
Philadelphia, PA, 1998. (Cited on pp. 53, 69, 78, 79.)
[140] G. W. Stewart. Matrix Algorithms, Volume 2: Eigensystems. SIAM, Philadelphia,
PA, 2001. (Cited on p. 334.)
[141] G. W. Stewart. An updating algorithm for subspace tracking. IEEE Trans. Signal
Proc., 40:1535–1541, 1992. (Cited on p. 103.)

November 20, 2008 10:52
sccsbook
Sheet number 381 Page number 371
cyan magenta yellow black
Bibliography
371
[142] William J. Stewart.
Introduction to the Numerical Solution of Markov Chains.
Princeton University Press, 1994. (Cited on p. 219.)
[143] Volker Strassen. Gaussian elimination is not optimal. Numer. Math., 13:354–356,
1969. (Cited on p. 37.)
[144] Paul N. Swarztrauber and Roland A. Sweet. Algorithm 541: Efﬁcient Fortran sub-
programs for the solution of separable elliptic partial differential equations. ACM
Trans. Math. Softw., 5(3):352–364, 1979. (Cited on p. 346.)
[145] Julius T. Tou and Rafael C. Gonzales. Pattern Recognition Principles. Addison-
Wesley Publishing Co., 1974. (Cited on p. 155.)
[146] Emanuele Trucco and Alessandro Verri. Introductory Techniques for 3-D Computer
Vision. Prentice-Hall, Englewood Cliffs, NJ, 1998. (Cited on p. 162.)
[147] Sabine Van Huffel and Joos Vanderwalle. The Total Least Squares Problem. SIAM,
Philadelphia, PA, 1991. (Cited on p. 174.)
[148] Charles F. Van Loan. Introduction to Scientiﬁc Computing, Second Edition. Prentice-
Hall, Englewood Cliffs, NJ, 2000. (Cited on pp. xiii, xiv, 3, 47, 107, 107, 212,
257, 257, 283.)
[149] Kees Vuik.
Some disasters caused by numerical errors.
http://ta.twi.
tudelft.nl/nw/users/vuik/wi211/disasters.html. Retrieved May
2008. (Cited on p. 14.)
[150] Layne T. Watson. Numerical linear algebra aspects of globally convergent homotopy
methods. SIAM Rev., 28(4):529–545, 1986. (Cited on p. 296.)
[151] Layne T. Watson. Probability-one homotropies in computational science, J. Comp.
Appl. Math., 140:785–807, 2002. (Cited on pp. 293, 296.)
[152] Layne T. Watson. Theory of globally convergent probability-one homotopies for
nonlinear programming. SIAM J. Optim., 11(3):761–780, 2000. (Cited on p. 296.)
[153] L. T. Watson, M. Sosonkina, R. C. Melville, A. P. Morgan, and H. F. Walker. Algo-
rithm 777: Hompack90: A suite of Fortran 90 codes for globally convergent homo-
topy algorithms. ACM Trans. Math. Softw., 23:514–549, 1997. (Cited on pp. 286,
296.)
[154] Eric Weisstein.
Euler angles.
http://mathworld.wolfram.com/
EulerAngles.html. Retrieved May 2008. (Cited on p. 162.)
[155] Hai Zhuge. Exploring an epidemic in an e-science environment. Communications
of the ACM, 48(9):109–114, 2005. (Cited on p. 219.)
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 382 Page number 372
cyan magenta yellow black

November 20, 2008 10:52
sccsbook
Sheet number 383 Page number 373
cyan magenta yellow black
Index
BI-CG, 333
BLAS, 38, 50
Level-1, 51
Level-2, 51
Level-3, 52
GELDA, 250
GENDA, 250
GMRES, 289, 331, 332
stagnation, 333
k-Means Algorithm, 152
LAPACK, 78, 79
LSQR , 330
MR, 333
PCG, 327
QMR, 333
SYMMLQ , 330
absolute error, 9
absolute orientation problem, 157
active constraint, 90, 137
active set strategies, 338
Adams family, 239
Adams–Bashforth, 239
Adams–Moulton, 239
aggregation of Markov chains, 218, 219
algebraic multigrid, 356, 360
annealing, 197
arc length, 294
Arnoldi, 331
Arnoldi basis, 331
array steering vectors, 98
Automatic differentiation, 122
axpy, 51
back substitution, 55
backslash, 55
backtracking linesearch, 119
backward error, 17, 23, 306
backward Euler method, 235
band matrix, 313
barrier function, 141
barrier parameter, 141
Basic Linear Algebra Subroutines, 37,
50
basis, 50
Bauer-Fike Theorem, 69
beetle, red ﬂour, 306
bifurcate, 292
bifurcation diagram, 304
binary arithmetic, 8
biological modeling, 301
bits, 8
bivariate, 189
blind deconvolution, 169, 175
boundary conditions, 269
boundary value problem, 250, 251
bracketing, 119
Broyden’s good method, 124
Broyden’s method, 289
cache, 32
cache line, 32
miss penalty, 34
Case Studies, x
catastrophic cancellation, 14, 15
central limit theorem, 191
chaos, 304
characteristic frequencies, 351
373
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 384 Page number 374
cyan magenta yellow black
374
Index
Cholesky decomposition, 56, 316
closed set, 144
closed-loop control, 270
clustering of data, 149
coarse grid, 354, 358
column-oriented algorithm, 32
compiler, 11
complementarity, 138
computational science, 7
computational scientist, 7
computer arithmetic, 5, 8, 31
ﬂoating-point precision, 11
IEEE ﬂoating-point standard, 10
numerical disasters, 14
printed values, 10
speed, 36
symbolic computation, 17
computer hardware, 3, 34
computer memory, 31
computer memory management, 32
computer software, 3, 39
correctness, 43
debugging, 42
design, 41, 43
documentation, 39, 43
efﬁciency, 43
overhead of function call, 193
validation, 42
computer word, 8
condition number, 20, 25, 30
cone, 144
conﬁdence interval, 28, 30
conﬁdence level, 28
conic convex optimization, 144
conjugate gradients, 289, 327
conservation law, 245, 257
constrained optimization problem, 135
constraint qualiﬁcation, 138
continuation method, 142, 146, 291,
296, 305
control system, 71, 265, 346
controllable, 267
convex, 110, 136, 144, 151
convolution, 83
Crank–Nicholson method, 237
Cuthill–McKee, 316
damped, 266
damped least squares, 83
data clustering problem, 149
k-means algorithm, 152, 155
pitfalls, 151, 153
data ﬁtting
ecological modeling, 301
exponential ﬁtting, 163, 168
rate constant, 165, 168
deblurring images, 81
defective, 77
degree of graph node, 314
delay differential equation (DDE), 260
dense matrix, 47
descent direction, 112
desk checks, 42
determinant, 50
deterministic, 187, 192
differential-algebraic equation, 226,
247, 260
index, 248
methods, 249
software, 250
standard form, 247
strangeness, 249
differential-index, 249
diffusion term, 262
dimers, 199
direct method, 311, 323, 328
direction
of negative curvature, 112, 113
of positive curvature, 113
of steepest ascent, 113
of steepest descent, 113, 127
direction of arrival, 97
Eigen-ESPRIT, 100
ESPRIT, 103
Music algorithm, 103
SVD-ESPRIT, 99
URV-ESPRIT, 103
discrepancy principle, 171
discrete Fourier (sine) transform, 345
discrete ill-posed problem, 81
discrete Newton, 123
discretize, 321
disk, 32

November 20, 2008 10:52
sccsbook
Sheet number 385 Page number 375
cyan magenta yellow black
Index
375
dot-product, 51
double-precision, 9
downhill direction, 112, 113
dual problem, 145
dual variable, 28, 137
dynamical system, 301, 306
bifurcation, 304, 306
equilibria, 303
parameter estimation, 304
stability, 303, 306
ecological modeling, 301
edge of a graph, 314
eigendecomposition, 68, 72, 79
Krylov subspace method, 333
eigenfunction, 348
eigenvalue, 49, 68, 99, 230, 347, 348,
351
minimax characterization, 347
Bauer-Fike Theorem, 69
existence, 69
Gerschgorin circle theorem, 56
Google, 333
Krylov subspace method, 334
operator, 347, 351
computing estimates, 349
properties, 350
uses, 351
perturbation, 69
updated matrix, 90
use in information retrieval, 333
Weilandt-Hoffman Theorem, 69
eigenvector, 69, 99, 347
perturbation, 69
elastic body, 335
elastoplastic torsion, 335
encounter factor, 227
energy norm, 327, 328
engineering, 7
epidemiology, 213, 219, 259
equilibria populations, 303
error, 5
backward, 17, 23
forward, 17, 23
measurement, 17
propagation, 14
sources, 5
errors-in-variables, 174
ESPRIT, 97, 103
Euler angles, 157
expected value, 190
exponential distribution, 188, 191
exponential windowing, 100
extinction solution, 303
family of solutions, 228
feasible direction, 140, 141
feasible solution, 135
ﬁll-in, 313
ﬁne grid, 354
ﬁnite difference, 251, 269, 273, 321,
349, 353
ﬁnite difference Newton method, 289
ﬁnite element, 251, 275, 321, 336, 349,
351, 353
mesh generation, 334, 339
ﬁnite-precision, 5
ﬁrst-kind integral equation, 83
ﬁrst-order optimality condition, 112,
137, 138
ﬁxed point, 72
ﬁxed-point arithmetic, 8
ﬁxed-point iterations, 289, 290
ﬂexible-GMRES, 334
ﬂoating-point arithmetic, 8
IEEE Standard, 10
precision, 11
printed values, 10
ﬂu epidemic of 1918, 219
forgetting factor, 100
forward error, 17, 23, 306
forward substitution, 55
free energy, 203
Frobenius norm, 25
full rank, 50
functional iteration, 237
fundamental frequency, 351
Galerkin method, 275, 326
gamma distribution, 188
Gauss elimination, 52
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 386 Page number 376
cyan magenta yellow black
376
Index
Gauss–Seidel, 290, 324, 329, 353
Gear family, 243
generalized eigenvalue problem, 99, 103
generating function, 200, 202
Gerschgorin circle theorem, 56
gimbal lock, 161
Givens rotation matrix, 58
global minimizer, 195
Goldstein–Armijo condition, 119
Google PageRank, 333
gradient, 111
Gram–Schmidt orthogonalization, 60,
331
graph
degree, 314
edge, 314
node, 314
grid, 353
grid points, 273
Hamiltonian system, 245, 247, 257
harmonic oscillator, 203
hat functions, 276
Helmholtz equation, 359
Hermitian, 51
Hessenberg matrix, 51
Hessian matrix, 111
high frequency, 356
high-order term, 55
higher-order elements, 277
homotopy function, 291
Hompack, 296
Householder transformation, 58, 61, 62,
331
IEEE standard ﬂoating-point arithmetic,
10
ill-conditioning, 20, 81
ill-posed problem, 81
Tikhonov method, 83
truncated SVD, 84
image deblurring, 81, 85, 174, 346
importance sampling, 208, 209
inexact Newton method, 289
initial value problem, 226
inner-product, 51
integral equation of the ﬁrst kind, 81, 83
interior-point methods, 139, 144, 338
interpolation operator, 355
interval analysis, 30
invariant, 267
invariant subspace, 69, 72
inverse interpolation, 295, 296
inverse problems, 81
iterative method, 311, 322, 323
Jacobian matrix, 228, 286
Jordan block, 77
Jordan canonical form, 77
kernel function, 83, 169
Kronecker product, 85, 86
Krylov subspace, 326
Krylov subspace method, 326
Arnoldi, 334
BI-CG, 334
eigendecomposition, 333, 334
ﬂexible-GMRES, 334
Galerkin, 326
GMRES, 332, 334
indeﬁnite matrix, 330
LSQR, 330, 334
MR, 334
normal equations, 330
PCG, 334
preconditioned conjugate gradients,
327
projection, 326
QMR, 334
SVD, 333
SYMMLQ, 330, 334
variational, 326
Lagrange multiplier, 24, 30, 136, 138
Lagrangian function, 136, 138
Lanczos basis, 333
Laplacian, 319
least change, 124
least squares, 84, 171, 304, 305, 330
damped, 83
data ﬁtting, 65
existence, 66

November 20, 2008 10:52
sccsbook
Sheet number 387 Page number 377
cyan magenta yellow black
Index
377
ill-conditioned, 74
iterative method
LSQR, 330
SYMMLQ, 330
Levenberg–Marquardt, 118, 289
Levenberg-Marquardt, 121
linear, 49, 163
nonlinear, 159, 160, 165, 287, 305
perturbation, 66, 168
rank-deﬁcient, 74
total least squares, 174
uniqueness, 66
updating with new data, 90
Varpro for separable problems, 168
left eigenvector, 68
left singular vector, 73
legacy code, 39
Levenberg–Marquardt, 118, 121, 289
linear conjugate gradients, 128, 329
linear control theory, 266
linear least squares, 287
linear programming, 27, 144, 178, 181
linear subspace
basis, 50
orthogonal basis, 50
orthonormal basis, 50
linear system, 49
condition number, 20, 25, 26
dense, 49
existence of solution, 53
iterative method
Arnoldi, 331
BI-CG, 333
conjugate gradients, 327
ﬂexible-GMRES, 334
Gauss–Seidel, 324
GMRES, 331, 332
indeﬁnite matrix, 330
Krylov subspace method, 326
MR, 333
nonsymmetric matrix, 331
normal equations, 330
preconditioning, 328
QMR, 333
restarting, 331
stationary iterative method, 72,
324
successive displacements, 324
symmetric Gauss–Seidel, 329
perturbation, 53
singular matrix, 53
sparse direct, 311
sparse iterative, 323
uniqueness of solution, 53
linearly independent, 347
Lipschitz continuous, 116, 196, 226, 287
local minimizer, 110, 195
low-order term, 55
LU, 52, 79
Lyapunov equation, 343
Lyapunov stability, 266
machine epsilon, 10
main memory, 32
mantissa, 9
marginal values, 24
Markov chain, 216, 219
aggregation, 219
Markov property, 216
mass matrix, 247
mathematical modeling, 3
blind deconvolution of images,
169, 175
control of robot, 265
direction-of-arrival problem, 97
elasticity, 339
elastoplastic torsion, 335
epidemiology, 259
Monte Carlo model, 213
ordinary differential equation
models, 259
partial differential equation
models, 261
error, 7
image deblurring, 81
population dynamics, 301
reaction rate, 163
structure comparison, 157
truss conﬁguration, 297
vibrational frequencies, 347
mathematics, 7
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 388 Page number 378
cyan magenta yellow black
378
Index
matrix
MATLAB’s gallery, 311, 334
condition number, 117
Davis collection, 334
determinant, 50
eigenvalue
Bauer-Fike Theorem, 69
existence, 69
Gerschgorin circle theorem, 56
perturbation, 69
Weilandt-Hoffman Theorem, 69
eigenvector
linear independence, 69
uniqueness, 69
generalized eigenvalue problem,
103
inverse, 116
linear algebra facts, 50
low-rank approximation with SVD,
75
Matrix Market, 311, 334
matrix structure, 51
minor, 50
norm, 25
relation to SVD, 73
null space, 50
range, 50
rank, 50
rank (numerical), 81
similarity transform, 50
singular, 51
stiffness matrix, 339
testing positive deﬁniteness, 56
transpose, 8
updating, 95
matrix decomposition, 49
Cholesky, 52
downdating, 87
eigendecomposition, 68, 71, 72, 79,
103
implicit updating, 92
Jordan canonical form, 77
LAPACK, 79
LU, 52, 79
matrix inverse, 77
QR, 57, 79
Givens Rotations, 58
Gram–Schmidt, 60
Householder, 62
uses, 62
rank-revealing QR (RR-QR), 67,
79
rank-revealing URV, 103
Schur decomposition, 344
singular value decomposition
(SVD), 72, 73, 74, 79, 103
software, 78
sparse, 311
summary, 78
updating, 87
matrix multiplication
Strassen algorithm, 37, 346
matrix norm, 25
matrix notation, 8
matrix structure, 342
Hermitian, 51
Hessenberg, 51
Kronecker product, 85, 86
orthogonal, 51
permutation, 51
positive deﬁnite, 51
symmetric, 51
tridiagonal, 51
unitary, 51
maximum principle, 252
mean, 189, 190
measurement error, 5
memory management, 32
merit function, 285
mesh, 353
minimizer, 109
minimum, 109
minimum degree, 317
minors, 50
mistakes, 6
modeling error, 5
moments, 189
monomers, 199
Monte Carlo, 187
counting, 195
estimation, 27, 30

November 20, 2008 10:52
sccsbook
Sheet number 389 Page number 379
cyan magenta yellow black
Index
379
importance sampling, 208
integration, 203, 206
method, 187
optimization, 195
random number generation, 219
sampling, 199
simulation, 213
stratiﬁed sampling, 212
multicore, 31
multigrid method, 328, 330, 353, 360
1-d problems, 354
2-d problems, 358
cost, 357
V-cycle, 356
multiple shooting, 253
Music algorithm, 103
NaN, 9
narrowband, 97
Nelder–Mead algorithm, 130
nested dissection, 318
nested grids, 358
nested iteration, 355
Newton direction, 115
Newton’s method
for nonlinear equations, 285, 288
for optimization, 114
Newton–Cotes, 204
no-change conditions, 124
node of a graph, 314
nonlinear conjugate gradients, 127
nonlinear equations, 285, 351
continuation method, 291
contraction map, 287
existence of solution, 287
ﬁnite-difference Newton method,
289
ﬁxed-point iterations, 290, 296
Gauss-Seidel, 290
homotopy software, 296
inexact Newton method, 289
methods for 1-dimensional
problems, 286
Newton’s method, 288, 296
polynomial system, 297
quasi-Newton method, 289
trust region method, 289, 296
uniqueness of solution, 287
nonlinear Gauss-Seidel, 290
nonlinear least squares, 132, 159, 160,
287
nonsingular, 51
nonstationary Stokes equation, 249
nonuniform, 188
normal distribution, 188, 191
normal equations, 330
normalize, 9
not-a-number, 9
null space, 50
numerical analysis, 7
numerical integration
Monte Carlo methods, 204, 206
importance sampling, 208
multidimensional
separable function, 206
multidimensional integrals by
nested quadrature, 205
numerical rank, 67, 81
observable, 268
optimization, 11
automatic differentiation, 122
computing Hessian matrices, 111
constrained, 135
active set methods, 90
algorithms for bound constraints,
121, 139
algorithms for linear equality
constraints, 140
barrier methods, 141
existence of solution, 138
interior-point methods, 144
linear inequality constraints, 90
linear programming, 144, 178,
181
optimality conditions: general
constraints, 138
optimality conditions: linear
constraints, 136
penalty methods, 141
quadratic programming, 339
sesitivity of solution, 136
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 390 Page number 380
cyan magenta yellow black
380
Index
discrete functions, 198
feasible point, 135
global minimizer, 110
local optimality, 135
Monte Carlo methods, 195
Newton direction through matrix
inverse, 116
simulated annealing, 196, 197, 202
traveling salesperson problem, 198
unconstrained, 109
algorithms, 113, 133
conjugate gradient, 127
descent direction, 119
existence of solution, 112
ﬁnite difference methods, 130
ﬁnite difference Newton
methods, 126
ﬁrst-derivative methods, 123
ﬁrst-order optimality conditions,
112
geometric optimality conditions,
112
Levenberg–Marquardt method,
118, 121
linesearch, 119
low-storage, 126
modiﬁed Cholesky method, 118,
133
modiﬁed Newton methods, 117
Newton’s method, 114, 116
no derivatives, 129
optimality conditions, 110
pattern search methods, 131
quasi-Newton method, 123, 133
second-order optimality
condition, 112
simplex-based methods, 130
steepest descent, 127
summary, 131
truncated Newton method, 128
trust region, 121, 133
uniqueness of solution, 110
order, 55
ordinary differential equation, 225
backward Euler method, 235
boundary value problem, 225, 250,
268
boundedness, 252
existence, 251
ﬁnite difference methods, 254
maximum principle, 252
shooting method, 253
uniqueness, 251
choice of method, 257
control, 271
conversion of higher-order
equations to standard form,
227
differential-algebraic equation, 247
dynamical system, 301
ﬁnite difference method, 273, 280
ﬁnite element method, 273, 280
Gear methods, 243
Hamiltonian system, 245, 247
higher order, 227
initial value problem, 225, 226, 268
Adams method, 239
adaptive method, 240, 243
Euler’s method, 232
existence of solution, 226
higher order, 225
predictor-corrector methods, 237
Runge-Kutta methods, 243
software, 228
stiff solvers, 257, 260
stiffness, 243
uniqueness of solution, 226
Lyapunov stability, 267, 271
methods, 257
monotonicity theorem, 252
multigrid method, 353
multilevel method, 353
order of method, 233, 240
PECE, 240
solution families, 228
stability, 228, 232, 303
stability interval, 235
stable, 230
stable method, 235
standard form, 226
stepsize control, 240

November 20, 2008 10:52
sccsbook
Sheet number 391 Page number 381
cyan magenta yellow black
Index
381
stiff, 230
stochastic, 264
unstable, 230
orientation of molecules, 157
orthogonal basis, 50, 63
orthogonal matrix, 51
orthogonal Procrustes problem, 159
orthonormal basis, 50
outlier, 151
overdetermined, 287
overﬂow, 9
PageRank, 333
parameterized Sard’s theorem, 293
partial differential equation
discretization, 262, 321
eigenvalue problem, 347
elastoplastic torsion, 335
Helmholtz equation, 360
multigrid method, 353, 360
software, 345, 351
stiffness matrix, 339
partial pivoting, 53
partition function, 203
pattern search method, 130
PE(CE)m, 237
PECE, 240
penalty function, 142
penalty parameter, 142
permutation matrix, 51, 52, 312
pitch, 157
pivot, 53, 316
pixels, 82
plastically, 335
polynomial equation, 285
existence of solution, 287
uniqueness of solution, 287
population dynamics, 301
equilibria, 303
stability, 303
positive deﬁnite, 51, 112, 316
positive deﬁnite Lyapunov function, 267
positive semideﬁnite, 112
positive spanning set, 131
potential energy, 196
preconditioned conjugate gradients, 327
preconditioner, 324, 327, 328
incomplete Cholesky, 328
multigrid, 328
sparse approximate inverse, 328
symmetric Gauss–Seidel, 329
primal-dual central path, 145
principal value, 347
probability, 187, 190
probability density function, 190
proﬁle, 313
prolongation, 356
pseudo-Monte Carlo, 187
pseudorandom, 187, 192
QR, 57, 79
QR iteration, 70
quadratic convergence, 116
quadratic model, 114
quadratic programming, 121, 338
quasi-Newton method, 123, 289
quasi-random numbers, 210
Quaternions, 161
random number
distribution, 188, 190
central limit theorem, 191
mean, 190
normal, 191
variance, 190
generation, 188
pseudorandom number, 192,
194, 219
quasi-random numbers, 210
importance sampling, 208, 209
quasi-random numbers, 212
stratiﬁed sampling, 212
testing, 193
range, 50
rank, 50
rank-1 matrix, 90
rank-revealing QR (RR-QR), 67, 79
rank-revealing URV, 102
rate, 117
rate constant, 163, 302
data ﬁtting, 165
sensitivity, 163
www.ebook3000.com

November 20, 2008 10:52
sccsbook
Sheet number 392 Page number 382
cyan magenta yellow black
382
Index
real symmetric, 314
rectangle rule, 83
rectangular windowing, 98
reduced costs, 24
registers, 32
regularization, 82, 86, 171, 181
Tikhonov method, 83, 174
truncated SVD, 84, 174
relative error, 9
residual, 19, 63
restriction operator, 356
Reverse Cuthill–McKee, 316
right eigenvectors, 68
right singular vectors, 73
robot arm, 265
control, 270
controllability, 265
stability, 265
roll, 157
root mean squared distance, 159
rotation, 58
rounding error, 42
rounding error, 5, 126
row-oriented algorithm, 32
RR-QR decomposition, 67
sampling, 187
scal, 51
Schur decomposition, 78, 343, 344
science, 7
scientiﬁc computing, 7
secant condition, 123, 290
second-order condition for optimality,
112, 139
second-order cone programming, 144
seed for random number generation, 192
self-adjoint, 348
semideﬁnite programming, 144
sensitivity analysis, 23
condition numbers, 24
conﬁdence intervals, 28
derivatives, 23
Monte Carlo experiments, 27
separator, 318
shadow price, 137
shear modulus, 336
shear stress, 336
Sherman–Morrison–Woodbury
Formula, 89, 91
shooting method, 251, 253, 268
signiﬁcand, 9
SIM, 72
similarity transform, 50, 70
simplex, 130
simplex algorithm for linear
programming, 90, 135
simplex method, 144
simulated annealing, 192, 197, 202
log cooling schedule, 199
simulation
differential equation, 259
Monte Carlo, 213
single-precision, 9
singular value decomposition, 73, 79, 99
Krylov subspace method, 333
low-rank approximation, 75
sum of rank-one matrices, 75
singular values, 73
small support, 83, 276
spaghetti code, 41
sparse, 309, 316
sparse matrix, 47, 274
decomposition, 312
ﬁll-in, 313
graph representation, 314
iterative method
Gauss–Seidel method, 334
Jacobi method, 334
Krylov subspace method, 334
SOR method, 334
stationary iterative method, 334
MATLAB functions, 274
reordering, 314
Cuthill–McKee, 316
eigenvector partitioning, 319
minimum degree, 317
nested dissection, 318
nonsymmetric matrix, 321, 322
software, 320
symmetric matrix, 322
storage, 311

November 20, 2008 10:52
sccsbook
Sheet number 393 Page number 383
cyan magenta yellow black
Index
383
stability, 95
of a control system, 71
of an algorithm, 20, 125
of an ODE, 230, 266
stable, 303
state in Markov chain, 216
state vector, 71, 266
stationary iterative method, 72, 324
statistical sampling, 199
correlation of samples, 201
statistics, 7
steady state, 218, 266
steepest descent, 127
stochastic, 187
stochastic differential equations, 264
strangeness, 249
Strassen algorithm, 37, 346
stress function, 335
successive displacements, 324
SUNDIALS, 250
superlinear convergence rate, 117
SVD, 73
Sylvester equation, 341, 343
Schur algorithm, 346
symbolic computation, 17, 30
symmetric, 51
symmetric Gauss–Seidel, 329
Taylor series, 112
Tikhonov method, 174
Tikhonov regularization, 83, 177
Toeplitz matrix, 175
torsion, 335
total least norm problems, 177
total least squares, 172, 174
structure constraints, 175
transition matrix, 217
transpose, 8
transversal to zero, 293
trapezoidal rule for integration, 240
traveling salesperson problem (TSP),
198
tridiagonal matrix, 51, 70, 313
truncation error, 5, 126
truss problem, 297
trust region, 121, 289
turning points, 292
two-point boundary value problem, 273
unconstrained optimization, 109
undamped, 265
underﬂow, 9
undriven damped pendulum, 266
uniform distribution, 188, 190
unit lower-triangular, 52
unitary matrix, 51
univariate, 188
unstable, 20, 267, 303
update techniques, 97
updating linear systems
matrix, 89
right-hand side, 89
uphill direction, 113
upper-Hessenberg, 51, 70
upper-triangular matrix, 52
URV, 102
URV-ESPRIT, 103
variable metric, 123
variable projection, 166
variance, 189, 190
vector norm, 25, 181
vector notation, 8
Volterra’s predator/prey model, 226
well-conditioned, 20
well-mixed, 259
windowing of data
exponential, 100
rectangular, 99
Wolfe–Powell condition, 119
work, 274
work unit, 357
yaw, 157
yield stress, 336
zero, 285
simple, 288
www.ebook3000.com

