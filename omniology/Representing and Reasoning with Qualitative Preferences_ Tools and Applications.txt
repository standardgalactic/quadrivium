Representing and 
Reasoning with 
Qualitative Preferences
Tools and Applications
Ganesh Ram Santhanam
Samik Basu
Vasant Honavar
SyntheSiS LectureS on ArtificiAL  
inteLLigence And MAchine LeArning
Ronald J. Brachman, William W. Cohen, and Peter Stone, Series Editors
MORGAN&CLAYPOOL PUBLISHERS


Representing and Reasoning
with Qualitative Preferences
Tools and Applications


Synthesis Lectures on Artiﬁcial
Intelligence and Machine
Learning
Editors
Ronald J. Brachman, Yahoo! Labs
William W. Cohen, Carnegie Mellon University
Peter Stone, University of Texas at Austin
Representing and Reasoning with Qualitative Preferences: Tools and Applications
Ganesh Ram Santhanam, Samik Basu, and Vasant Honavar
2015
Metric Learning
Aurélien Bellet, Amaury Habrard, and MarcSebban
2015
Graph-Based Semi-Supervised Learning
Amarnag Subramanya and Partha Pratim Talukdar
2014
Robot Learning from Human Teachers
Sonia Chernova and Andrea L. omaz
2014
General Game Playing
Michael Genesereth and Michael ielscher
2014
Judgment Aggregation: A Primer
Davide Grossi and Gabriella Pigozzi
2014
An Introduction to Constraint-Based Temporal Reasoning
Roman Barták, Robert A. Morris, and K. Brent Venable
2014

iv
Reasoning with Probabilistic and Deterministic Graphical Models: Exact Algorithms
Rina Dechter
2013
Introduction to Intelligent Systems in Traﬃc and Transportation
Ana L.C. Bazzan and Franziska Klügl
2013
A Concise Introduction to Models and Methods for Automated Planning
Hector Geﬀner and Blai Bonet
2013
Essential Principles for Autonomous Robotics
Henry Hexmoor
2013
Case-Based Reasoning: A Concise Introduction
Beatriz López
2013
Answer Set Solving in Practice
Martin Gebser, Roland Kaminski, Benjamin Kaufmann, and Torsten Schaub
2012
Planning with Markov Decision Processes: An AI Perspective
Mausam and Andrey Kolobov
2012
Active Learning
Burr Settles
2012
Computational Aspects of Cooperative Game eory
Georgios Chalkiadakis, Edith Elkind, and Michael Wooldridge
2011
Representations and Techniques for 3D Object Recognition and Scene Interpretation
Derek Hoiem and Silvio Savarese
2011
A Short Introduction to Preferences: Between Artiﬁcial Intelligence and Social Choice
Francesca Rossi, Kristen Brent Venable, and Toby Walsh
2011
Human Computation
Edith Law and Luis von Ahn
2011

v
Trading Agents
Michael P. Wellman
2011
Visual Object Recognition
Kristen Grauman and Bastian Leibe
2011
Learning with Support Vector Machines
Colin Campbell and Yiming Ying
2011
Algorithms for Reinforcement Learning
Csaba Szepesvári
2010
Data Integration: e Relational Logic Approach
Michael Genesereth
2010
Markov Logic: An Interface Layer for Artiﬁcial Intelligence
Pedro Domingos and Daniel Lowd
2009
Introduction to Semi-Supervised Learning
XiaojinZhu and Andrew B.Goldberg
2009
Action Programming Languages
Michael ielscher
2008
Representation Discovery using Harmonic Analysis
Sridhar Mahadevan
2008
Essentials of Game eory: A Concise Multidisciplinary Introduction
Kevin Leyton-Brown and Yoav Shoham
2008
A Concise Introduction to Multiagent Systems and Distributed Artiﬁcial Intelligence
Nikos Vlassis
2007
Intelligent Autonomous Robotics: A Robot Soccer Case Study
Peter Stone
2007

Copyright © 2016 by Morgan & Claypool
All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted in
any form or by any means—electronic, mechanical, photocopy, recording, or any other except for brief quotations
in printed reviews, without the prior permission of the publisher.
Representing and Reasoning with Qualitative Preferences: Tools and Applications
Ganesh Ram Santhanam, Samik Basu, and Vasant Honavar
www.morganclaypool.com
ISBN: 9781627058391
paperback
ISBN: 9781627058407
ebook
DOI 10.2200/S00689ED1V01Y201512AIM031
A Publication in the Morgan & Claypool Publishers series
SYNTHESIS LECTURES ON ARTIFICIAL INTELLIGENCE AND MACHINE LEARNING
Lecture #31
Series Editors: Ronald J. Brachman, Yahoo! Labs
William W. Cohen, Carnegie Mellon University
Peter Stone, University of Texas at Austin
Series ISSN
Print 1939-4608
Electronic 1939-4616

Representing and Reasoning with
Qualitative Preferences
Tools and Applications
Ganesh Ram Santhanam
Iowa State University
Samik Basu
Iowa State University
Vasant Honavar
Pennsylvania State University
SYNTHESIS LECTURES ON ARTIFICIAL INTELLIGENCE AND MACHINE
LEARNING #31
C
M
&
cLaypool
Morgan
publishers
&

ABSTRACT
is book provides a tutorial introduction to modern techniques for representing and reasoning
about qualitative preferences with respect to a set of alternatives. e syntax and semantics of
several languages for representing preference languages, including CP-nets, TCP-nets, CI-nets,
and CP-theories, are reviewed. Some key problems in reasoning about preferences are introduced,
including determining whether one alternative is preferred to another, or whether they are equiv-
alent, with respect to a given set of preferences. ese tasks can be reduced to model checking
in temporal logic. Speciﬁcally, an induced preference graph that represents a given set of prefer-
ences can be eﬃciently encoded using a Kripke Structure for Computational Tree Logic (CTL).
One can translate preference queries with respect to a set of preferences into an equivalent set of
formulae in CTL, such that the CTL formula is satisﬁed whenever the preference query holds.
is allows us to use a model checker to reason about preferences, i.e., answer preference queries,
and to obtain a justiﬁcation as to why a preference query is satisﬁed (or not) with respect to a
set of preferences. is book deﬁnes the notions of the equivalence of two sets of preferences,
including what it means for one set of preferences to subsume another, and shows how to an-
swer preferential equivalence and subsumption queries using model checking. Furthermore, this
book demontrates how to generate alternatives ordered by preference, along with providing ways
to deal with inconsistent preference speciﬁcations. A description of CRISNER—an open source
software implementation of the model checking approach to qualitative preference reasoning in
CP-nets, TCP-nets, and CP-theories is included, as well as examples illustrating its use.
KEYWORDS
preferences, qualitative preferences, preference reasoning, model checking, knowl-
edge representation, automated inference, decision support systems

ix
We dedicate this book to our respective parents, spouses,
children, teachers, mentors, and students.
Ganesh Ram Santhanam, Samik Basu, and Vasant Honavar


xi
Contents
Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xv
1
Qualitative Preferences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1
Motivating Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.1
Cyberdefense Policy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2
Education . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.3
Software Engineering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.4
Countermeasures for Network Security . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.5
Minimizing Credential Disclosure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2
Organization of the Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2
Qualitative Preference Languages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1
Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.1
Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.2
Succinct Preference Speciﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2
Qualitative Preference Languages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.1
Representing Qualitative Preferences . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.2
Preference Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.3
CP-nets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.4
TCP-nets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.5
CP-eories. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.6
CI-nets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.7
Relative Expressive Power . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3
Reasoning with Qualitative Preferences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.1
Ceteris Paribus Preference Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2
Semantics for a Preference Speciﬁcation as Induced Preference
Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
3.3
Dominance and Consistency in Qualitative Preference Languages . . . . . 29
4
Complexity of Reasoning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

xii
3
Model Checking and Computation Tree Logic . . . . . . . . . . . . . . . . . . . . . . . . . . 33
1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
2
Kripke Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3
Computation Tree Temporal Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
3.1
Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
3.2
Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
4
Model Checking Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
5
NuSMV Model Checker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
5.1
NuSMV Language & Counterexamples . . . . . . . . . . . . . . . . . . . . . . . . . 43
4
Dominance Testing via Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
1
Dominance Testing of Unconditional Preferences . . . . . . . . . . . . . . . . . . . . . . . 47
1.1
Syntax of L . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
1.2
Semantics of L . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
1.3
Properties of Unconditional Dominance Relation . . . . . . . . . . . . . . . . . . 49
1.4
Complexity of Dominance Testing in L . . . . . . . . . . . . . . . . . . . . . . . . . . 50
1.5
Expressiveness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2
Preference Reasoning via Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
2.1
Kripke Structure Encoding of Induced Preference Graph . . . . . . . . . . . . 53
2.2
Correctness of the Construction of K.P / . . . . . . . . . . . . . . . . . . . . . . . . 58
3
Answering Dominance Queries via Model Checking . . . . . . . . . . . . . . . . . . . . . 61
3.1
Verifying Dominance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
3.2
Extracting a Proof of Dominance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
3.3
Summary and Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
5
Verifying Preference Equivalence and Subsumption . . . . . . . . . . . . . . . . . . . . . . 65
1
Preference Equivalence and Preference Subsumption . . . . . . . . . . . . . . . . . . . . . 66
2
Data Structures to Represent Semantics of Two Sets of Preference . . . . . . . . . . 67
2.1
Inverse Induced Preference Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
2.2
Combined Induced Preference Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
3
Kripke Structure Encoding for Preference Equivalence and Subsumption . . . . 69
3.1
Modeling of Preference Semantics: Extension for Preference
Equivalence and Preference Subsumption Reasoning . . . . . . . . . . . . . . . 69
3.2
Encoding Combined Induced Preference Graph as Kripke Structure . . . 71
4
Querying K.P1; P2/ for Subsumption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.1
Extracting a Proof of Non-subsumption . . . . . . . . . . . . . . . . . . . . . . . . . 73
4.2
Verifying Preference Equivalence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
5
Discussion. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

xiii
6
Ordering Alternatives With Respect to Preference . . . . . . . . . . . . . . . . . . . . . . . 77
1
Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
1.1
Kripke Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
1.2
Objective: Computing an Ordered Sequence . . . . . . . . . . . . . . . . . . . . . . 80
2
Computation of Ordered alternative Sequence . . . . . . . . . . . . . . . . . . . . . . . . . . 81
2.1
Dealing with SCCs in Induced Preference Graph . . . . . . . . . . . . . . . . . . 81
2.2
Iterative Model Reﬁnement and Property Relaxation . . . . . . . . . . . . . . . 83
2.3
Sample Run of the Algorithm on Example in Figure 6.1(b) . . . . . . . . . . 87
2.4
Number of Model Checking Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
3
Properties of N-P. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
4
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
7
CRISNER: A Practically Eﬃcient Reasoner for Qualitative Preferences . . . . . 93
1
Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
1.1
Justiﬁcation of Query Answers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
1.2
Tool Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
1.3
Preference Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
2
XML Input Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
2.1
Deﬁning Preference Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
2.2
Specifying Conditional Preference Statements . . . . . . . . . . . . . . . . . . . . 95
2.3
Specifying Relative Importance Preferences . . . . . . . . . . . . . . . . . . . . . . . 96
3
Encoding Preferences as SMV Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
3.1
Encoding Preference Variables & Auxiliary Variables . . . . . . . . . . . . . . . 97
3.2
Encoding Preference Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
3.3
Justiﬁcation of Query Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
4
Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
4.1
Extending CRISNER . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.2
Scalability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
5
Concluding Remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
8
Postscript . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
A
SMV Model Listings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
1
SMV Model Listing for P CP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
2
Dominance Query and NuSMV Output for P CP . . . . . . . . . . . . . . . . . . . . . . 108
3
SMV Model Listing for P T CP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
4
Dominance Query and NuSMV Output for P T CP . . . . . . . . . . . . . . . . . . . . . 109

xiv
5
SMV Model Listing for P CP T . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
6
Dominance Query and NuSMV Output for P CP T . . . . . . . . . . . . . . . . . . . . . 110
B
Providing XML Input to CRISNER . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
1
XML Input Listing for P CP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
2
XML Input Listing for P T CP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
3
XML Input Listing for P CP T . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
C
SMV Models & CTL Queries for Preference Equivalence and Subsumption . 117
1
SMV Model for K.P CP ; P T CP / . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
2
SMV Model for K.P T CP ; P CP T / . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
3
SMV Model for K.P CP T ; P CP / . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
4
Preference Subsumption Query P T CP v P CP on K.P T CP ; P CP / . . . . . . . . 122
5
Preference Subsumption Query P CP v P T CP on K.P CP ; P T CP / . . . . . . . . 123
6
Preference Subsumption Query P T CP v P CP T on K.P T CP ; P CP T / . . . . . . 123
7
Preference Subsumption Query P CP T v P T CP on K.P CP T ; P T CP / . . . . . . 123
8
Preference Subsumption Query P CP v P CP T on K.P CP T ; P T CP / . . . . . . . 124
9
Preference Subsumption Query P CP T v P T CP on K.P CP T ; P CP / . . . . . . . 124
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
Authors’ Biographies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137

xv
Acknowledgments
e research on which this book is based was conducted at the department of Computer Sci-
ence at Iowa State University and the College of Information Sciences and Technology at the
Pennsylvania State University and was supported in part by the grants CCF 1143734 and CCF
0702758 from the National Science Foundation and by the Edward Frymoyer Endowed Chair
held by Vasant Honavar.
e authors are thankful to Zachary Oster at the Department of Computer Science, Uni-
versity of Wisconsin-Whitewater for his contribution to the tool during his doctoral research at
Iowa State University and for his help with work implementing algorithms presented in Chap-
ter 6. e authors are grateful to Ronen Brafman at the Department of Computer Science,
Ben-Gurion University, Israel for helping us clarify the semantics of CP-net and TCP-net for-
malisms. e authors are grateful to the anonymous reviewers whose comments helped improve
the manuscript and Mr. Michael B. Morgan of Morgan & Claypool Publishers and Dr. C.L.
Tondo for their assistance to us with the manuscript preparation and publication process.
Ganesh Ram Santhanam, Samik Basu, and Vasant Honavar
December 2015


1
C H A P T E R
1
Qualitative Preferences
e ability to represent and reason about preferences over a set of alternatives is central to rational
decision making. For example, suppose Jane wants a low-rent apartment in midtown Manhattan,
but no such apartment is available. Jane then has to settle for an apartment that is the most
preferred with respect to her personal preferences from among the ones that are available. To
complicate matters, Jane might have preferences with respect to the neighborhood, cost, and
many other attributes of the apartment (e.g., the number of bedrooms, availability of parking,
whether the apartment is on the ground ﬂoor, etc.). Furthermore, preferences with respect to
some of the attributes, e.g., cost, may be more important than preferences with respect to other
attributes.
Preferences have been the subject of study in many disciplines including economics, deci-
sion theory, social choice, and game theory. Artiﬁcial intelligence (AI) brings a fresh perspective
to the study of preferences. Speciﬁcally, AI is concerned with how to eﬃciently represent and
reason about preferences especially when the preferences involve multiple attributes, resulting in
a large combinatorial space of alternatives.
Preferences over a set of alternatives can be qualitative (e.g., relative ordering among al-
ternatives) or quantitative (e.g., numeric evaluation of each alternative) in nature. Qualitative
preferences are more general in the sense that they deﬁne a preference relation (typically some
kind of a partial order) over the set of alternatives, while quantitative preferences require more
precision and map the set of alternatives to a numeric scale through a utility function [38]. Tech-
niques for manipulating quantitative preferences have been well studied in the literature [54].
e seminal work of von Neumann and Morgenstern [62] provided an axiomatization of con-
straints over rational preferences and proved the existence of a quantitative utility function that
maps each outcome to a value on a numeric scale as a consequence of the resulting axioms. In
settings where quantitative preferences are available, the utility theory framework deﬁnes a utility
function [38, 54] that can be used to decide the most preferred outcomes based on principles such
as the maximization of expected utility.
However, in most real-world settings, quantitative preferences are simply unavailable. It is
often easier to elicit qualitative preferences [36, 91]: the agent simply needs to be able to rank the
alternatives. is is especially true in the case of conditional preferences. For example, while Jane
prefers a job with a high salary if she lives in Manhattan and can’t work from home, she is willing
to settle for a lower salary if she lives on Long Island and can work from home. It is problematic
to map qualitative preferences onto a numeric scale, because doing so is tantamount to injecting

2
1. QUALITATIVE PREFERENCES
information that is simply unavailable in the preferences expressed by the agent, and hence dis-
torts the agent’s preferences. Hence, much of the recent work on preference representation and
reasoning in AI focuses on qualitative preferences [35, 36, 40].
is book aims to provide a tutorial introduction to modern techniques for reasoning about
qualitative preferences with respect to a set of alternatives. Speciﬁcally, the focus will be on rea-
soning about the qualitative preferences of a single agent¹ based on model checking, a technique
that has been developed and successfully used at industry-scale for software program veriﬁcation.
1
MOTIVATING EXAMPLES
We proceed to describe some real-world examples of scenarios that call for techniques for repre-
senting and reasoning about qualitative preferences.
1.1
CYBERDEFENSE POLICY
Network security management involves balancing between making the network maximally avail-
able and safeguarding against attacks that exploit the vulnerabilities exposed due to the services
provided. e objective of a systems administrator or a cyberdefender managing a network is to
take preventive measures that mitigate the risk of vulnerabilities in the system being exploited
maliciously. Each vulnerability is typically associated with a set of attributes² that describe the
potential risks and threats that it poses to the network. e job of a cyberdefender is then to
make an informed decision as to which policies address vulnerabilities that pose the most serious
threats. In order to design a good defense policy, the cyberdefender would have to prioritize the
vulnerabilities based on the seriousness of threats they pose in terms of these attributes.
Consider three attributes describing the seriousness of threats posed by a vulnerability,
namely (a) attack complexity (A) with values “High” or “Low” (indicating whether the complexity
of attack required to exploit the vulnerability is high or low); (b) availability of exploit (E) with
values “Code-available” or “Code-unavailable” (indicating whether easy-to-use exploit code
is freely available or entirely theoretical); and (c) availability of ﬁx (F ) for the vulnerability with
values “Fix-Available” or “Fix-Unavailable” (indicating whether a ﬁx is readily available or
not).
e defender may consider certain vulnerabilities to be more serious than others, based on
certain priorities and tradeoﬀs over these attributes. For instance,
p1 A vulnerability whose exploit code is known to be available (E D Code-Available)
is of higher priority than one whose exploitability has not been proven yet (E D
Code-Unavailable).
¹Multi-agent decision making scenarios present additional challenges: Agents might have conﬂicting preferences. For example,
while Jane wants a low-rent apartment in midtown Manhattan, Jane’s husband John prefers a single family home on Long
Island. Further complications arise from uncertainty associated with the preferences or choices. However, preference reasoning
in the multi-agent setting and the treatment of uncertainty are beyond the scope of this book.
²e attributes may be provided by a database that maintains a list of known vulnerabilities and their characteristics such as
the National Vulnerability Database [66].

1. MOTIVATING EXAMPLES
3
p2 Vulnerabilities with low access complexity (A D Low) are “preferred” (more serious) com-
pared to those with High Access Complexity (A D High).
p3 Among vulnerabilities whose exploit codes are available (E D Code-Available), those for
which ﬁxes are unavailable (F D Fix-Unavailable) are more serious than those for which
oﬃcial ﬁxes are available (F D Fix-Available).
p0
2 Attack Complexity is more important in determining the seriousness of a vulnerability; and
it can be traded against the availability of exploit (E) in deciding which vulnerability is more
serious.
Note that, if as per the preferences³ described above, one vulnerability is preferred to an-
other, then the former is a more serious vulnerability possibly requiring the attention of the cy-
berdefender. e above preferences can be represented using compact graphical representation
languages such as CP-nets and TCP-nets; a CP-net for the preferences p1 : : : p3 is shown in
Figure 1.1(a), and a TCP-net for all the above preferences is shown in Figure 1.1(b). e objec-
tive of the defender is to prioritize the vulnerabilities that exist in the network based on the above
preferences. e priorities induced by the preferences p1 to p3 are depicted as a directed graph in
Figure 1.1(c) where the edges point toward vulnerabilities with higher priority (how these graphs
are computed will be described in detail in Chapter 4). e defense policy is to “handle” a vulner-
ability that is higher in the priority before the vulnerability that is lower in the priority ordering;
and hence obtaining an ordering of vulnerabilities based on their attributes is critical for providing
optimal cyberdefense.
1.2
EDUCATION
Consider a student who has just enrolled in a Masters degree in Sustainability at the Department
of Environmental Engineering in a university. e student is required to develop a program of
study (POS) that is a set of courses chosen from the course catalog consisting of all oﬀered gradu-
ate courses in the department. Each course may be classiﬁed into a subﬁeld within Sustainability,
such as Climate, Wildlife, Environmental Economics, or Energy. e catalog also lists the in-
structor and the number of credit hours each course is worth. e question of interest here is:
Among all sets of courses that satisfy the requirement of a POS, which is the most preferred for
the student?
Computing the preferred POS requires accounting for a student’s preferences over the var-
ious courses, expressed in terms of preferences over the attributes of the courses. For instance, the
student may prefer one instructor over another based on the student’s past experience or ratings of
the instructors he has gathered; or he may prefer courses with lower credit hours (higher number
of credit hours may indicate more diﬃculty); or the student may prefer to specialize in a particular
³e usage of the numbering p0
2 and p00
2 will be clear in the subsequent chapters. Intuitively, both p0
2 and p00
2 further qualify
the preference p2 as they discuss the condition under which p2 should be the deciding factor irrespective of the values of
other attributes such as E in p0
2, and E and F in p00
2.

4
1. QUALITATIVE PREFERENCES
F
E
A
E=Code-Available:
Fix-Unavailable ≻Fix-Available 
Low ≻High
Code-Available ≻Code-Unavailable
(a) CP-net
F
E
A
Fix-Unavailable 
Fix-Available 
Low 
High
Code-Available 
Code-Unavailable
E=Code-Available:
≻
≻
≻
(b) TCP-net
Code-Available, Low, Fix-Unavailable
Code-Available, Low, Fix-Available
Code-Available, High, Fix-Available
Code-Available, High, Fix-Unavailable
Code-Unavailable, Low, Fix-Unavailable
Code-Unavailable, Low, Fix-Available
Code-Unavailable, High, Fix-Available
Code-Unavailable, High, Fix-Unavailable
p1
p1
(c) Priorities induced on vulnerabilities by the preferences p1 to p3 represented as a CP-net in Figure 1.1(a)
Figure 1.1: Risk priorities of a cyberdefender.
Formal syntax and semantics for CP-nets and TCP-nets will be given in Chapter 2.
subﬁeld over other subﬁelds of Sustainability, and hence, for example, prefer courses in Climate
or Wildlife to Environmental Economics or Energy related courses. Given these preferences over
the course attributes, the student may want to select the most preferred courses from the catalog
to ﬁll in his program of study, which involves reasoning with qualitative preferences. Another
question is that given two programs of study consisting of diﬀerent sets of courses, the student
may want to know whether he should pick one in favor of the other. is brings up another in-
teresting aspect of reasoning with qualitative preferences—how would the student reason about
preferences over collections of objects (e.g., courses in this example)?

1. MOTIVATING EXAMPLES
5
1.3
SOFTWARE ENGINEERING
Consider the design of a software application that allows customers to search for and order books,
pay for the books that they ordered, and get the books shipped to a speciﬁed address. Func-
tional requirements specify the desired functionality of software; for instance, searching for books,
adding them to a cart, checking out using alternative payment options and choosing a shipping
method. ere are multiple implementations that could realize the desired functionality. e
question of interest to us from the point of view of preference reasoning is: Which is the most
preferred realization of the software design?
Answering the above question entails representing and reasoning with the preferences of
users (software architects), who might have preferences over alternative implementations based
on non-functional aspects such as security, cost, performance, traceability of transactions made
through the application, etc. Further, preferences over an attribute may depend on the preference
over other attributes. e following is a set of sample user preferences⁴ on the attributes of the
software implementation.
p1 Among implementations that are Secure, it is more important to have Cheaper transaction
costs and Performance, rather than just Traceability.
p2 Among implementations that do not satisfy the Traceability non-functional property
(NFP), Security is more important than Cheaper transaction costs.
Any design that satisﬁes all four aspects is trivially the most preferred design, and will be
consistent with both the above preferences of the architect. However, note that such an imple-
mentation that simultaneously optimizes all non-functional aspects may not be realizable due
to other constraints (e.g., two software components may be incompatible); then the question of
interest is—what is the most preferred realizable implementation?
1.4
COUNTERMEASURES FOR NETWORK SECURITY
Consider a scenario where a system administrator (defender) comes to know of certain vulnerabil-
ities in the network he is managing. e defender would like to deploy the set of countermeasures
that best mitigate the security concerns while not rendering the system unusable.
Determining the preferred sets of countermeasures requires accounting for the preferences
of the defender over various countermeasures that could be deployed in response to certain security
concerns. Suppose that the countermeasure options considered by the defender are: setting up a
ﬁrewall (FW), restricting the access privileges on the server (AP), increasing logging levels (LO),
and stopping the service all together (ST). In this example, deploying fewer countermeasures is
preferred to deploying more countermeasures, as each countermeasure incurs cost of deployment
and also aﬀects the system functionality as well as usability. An example set of preferences is given
below.
⁴See [68] for more details on this example.

6
1. QUALITATIVE PREFERENCES
p1 If FW is part of the defense strategy anyway, then AP is preferred to ST.
p2 If AP is included in the strategy but LO is not considered, then ST is preferred to FW.
p3 If LO is part of the strategy but not ST, then AP is preferred to FW.
p4 If LO is not part of the strategy, then including both FW and AP is preferred to ST.
p5 If ST is not considered, then including LO along with FW is preferred to AP.
e objective of the defender would be to obtain an ordering of countermeasure sets starting
from the most preferred one, so that he can identify the most preferred set of countermeasures
that satisﬁes the security concerns.
1.5
MINIMIZING CREDENTIAL DISCLOSURE
Consider a client who is interested in obtaining some ﬁnancial quote (e.g., auto and/or home
insurance, mortgage, etc.) using an online service. Suppose that there are multiple servers that
provide the required service, and each server’s access control policy requires a combination of
several credentials from the client before granting access to the service. e client may want to
obtain the quote from the service that requires the least sensitive credential information. Here,
the sensitivity of credentials as viewed by the client induces preferences over services that require
various subsets of these credentials.
Consider four such credentials: the client’s name, residential address, bank account number,
and bank routing number. e client may have qualitative preferences over the relative importance
of his credentials based on their sensitivity. e rationale behind these preferences is that the client
would like to make it impossible (or at least diﬃcult) for a third party to perform any ﬁnancial
transaction maliciously posing as the client. erefore, from the client’s perspective, the objective
is to choose the server that provides the desired ﬁnancial service by requiring the least sensitive
set of client credentials. Consider the following qualitative preferences speciﬁed by the client:
p1 If my bank account number is disclosed to the server, I would rather give my address than
my bank’s routing number to the server. is is because my bank account number along
with the bank routing number identiﬁes my bank account precisely, and hence it is highly
sensitive information compared to my bank account number and address.
p2 If I have to disclose my address without having to disclose my name, then I would prefer
giving my bank’s routing number over my bank account number. However, this preference
does not hold when I have to disclose my name along with my address, because the com-
bination of my name, address, and bank routing number is not any less sensitive than my
name, address, and bank account number. In both cases, a malicious party needs to guess
one of the credentials—bank account number or bank routing number—to gain access to
important ﬁnancial information.

2. ORGANIZATION OF THE BOOK
7
p3 Because I would like to protect as many details as possible regarding my bank account, when
I don’t have to disclose my bank account number I would provide my name and address
rather than my bank’s routing number.
Based on these preferences, the client may be interested in ﬁnding successively more sensitive sets
of credentials (starting from the empty set) and verify whether a set of credentials is suﬃcient to
satisfy the access control policy of a server providing the desired service. e idea is that any server
that accepts this least sensitive acceptable set of credentials may be selected to provide the service
to the client, as it poses the least risk of compromise to privacy. e client may also be interested
in knowing whether one set of credentials is riskier than another set to disclose to a server.
2
ORGANIZATION OF THE BOOK
e preceding examples motivate the need for eﬀective techniques for representing and reasoning
about qualitative preferences. In the last decade, several formal languages have been developed
for representing qualitative preferences, such as CP-nets [16], TCP-nets [18], CP-eories [94],
CI-nets [17]. However, an obstacle to using these languages for real-world applications is that
reasoning in these languages is generally hard. For example, testing whether one alternative is pre-
ferred to another with respect to even a simple language, namely CP-nets, is PSPACE-complete
[41]. Against this background, this book presents a suite of modern approaches to reasoning
with qualitative preferences that leverage recent advances in formal methods and model checking
[27, 76].
e book is organized as follows:
Chapter 2. is chapter reviews popular qualitative preference languages such as CP-nets,
TCP-nets, CI-nets, and CP-theories and gives their syntax and a well-studied se-
mantics called ceteris paribus⁵ semantics in a uniﬁed notation. e chapter introduces
two key preference reasoning tasks, namely, dominance testing and consistency test-
ing. e chapter introduces a key data structure for representing the semantics of
qualitative preferences, namely the induced preference graph. e chapter also dis-
cusses how preferences in the examples provided in Chapter 1 can be formalized
using these languages.
Chapter 3. is chapter provides an overview of model checking, which is a formal veriﬁcation
technique that has been successfully used in several applications. Model checking
forms the basis of the approaches presented in all the following chapters, and so
this chapter is a prerequisite for the rest of the book, except for the last chapter.
is chapter presents the syntax and semantics of a temporal logic that we will use
in subsequent chapters, and describes a data structure called the Kripke structure
used to succinctly express the semantics of temporal models. ose familiar with
temporal logic model checking and CTL can skip this chapter.
⁵Ceteris paribus is a Latin term for “all else being equal.”

8
1. QUALITATIVE PREFERENCES
Chapter 4. is chapter ﬁrst presents a way to deal with the intractability of preference reason-
ing tasks by restricting the expressivity of preferences. e chapter studies a language
in which preferences are always unconditional, provides its syntax and semantics,
and contrasts the semantics and expressivity of this language with other conditional
preference languages. e chapter shows how dominance testing becomes tractable
in polynomial time by the proposed restriction, and mentions applications where
such a preference language might be appropriate.
e second part of this chapter outlines a way to translate the induced preference
graph (which represents the semantics of a set of preferences) into a Kripke structure
(which succinctly stores the semantics of a temporal model) in a way that the prefer-
ence semantics is preserved in the Kripke structure. e latter part of the chapter also
describes how one can translate preference queries with respect to a set of preferences
into an equivalent set of formulas in the temporal logic CTL, such that the CTL
formula is satisﬁed whenever the preference query holds. e chapter also describes
a method to use the model checker to (whenever possible) obtain a justiﬁcation of
why a preference query is satisﬁed (or not) with respect to a set of preferences.
Chapter 5. is chapter deﬁnes the notions of the equivalence of two sets of preferences, and
what it means for one set of preferences to subsume another, along with their for-
mal semantics. is problem is interesting in settings where it is necessary to reason
about the preferences of multiple agents. e chapter proceeds to extend the tech-
nique presented in Chapter 4 in order to automatically verify preference equivalence
and preference subsumption with respect to two sets of preferences, and if the result
is negative, then how to extract an evidence justifying the result.
Chapter 6. is chapter extends the model checking techniques presented in Chapters 4 and 5
to obtain an ordering of alternatives starting from the most preferred alternatives to
the least preferred. e chapter also provides a uniform way of handling inconsis-
tencies in preferences, i.e., cyclic preferences over alternatives (e.g., A is preferred
to B, which is in turn preferred to A). e chapter also characterizes the ordering
computed by the method presented as a useful extension of the original preference
order induced by the stated preferences.
Chapter 7. is chapter describes a preference reasoner tool called CRISNER [80] that imple-
ments the model checking approach to qualitative preference reasoning in CP-nets,
TCP-nets, and CP-theories. e tool’s architecture, XML-based input and output
formats, and some details regarding realizing the techniques in this book using the
NuSMV model checker are discussed. e chapter concludes with a set of projects
one can work on, to extend the tool to support other preference languages and rea-
soning tasks.

2. ORGANIZATION OF THE BOOK
9
Chapter 8. e last chapter summarizes the book’s contents and presents directions for future
work extending the techniques for preference reasoning presented.
Appendices. e source code for the Kripke structures models translated from the example pref-
erence speciﬁcations, sample CTL queries corresponding to preference reasoning
tasks along with the respective traces from the NuSMV model checker, and sample
XML ﬁles used as input for the preference reasoning tool presented in Chapter 7 are
provided as reference for the readers. is will enable even those who do not have
access to the model checker to follow how the techniques work for the examples in
the book.
Readers will ﬁnd it useful to follow one of the following study plans based on their own
backgrounds and interests.
• e reader who is unfamiliar with qualitative preference languages, their syntax, and se-
mantics is advised to begin from Chapter 2 and proceed chapter by chapter up to the end
of the book for a complete study of all topics.
• Assuming that the reader is already familiar with the syntax of the qualitative preference
languages and their ceteris paribus semantics, one can begin with Chapter 4 and proceed
chapter-wise up to the end of the book for a detailed study of the model checking approach
to preference reasoning in these languages.
• For a reader who is interested only in an overview of the qualitative preference languages,
and is more eager to learn about trading oﬀexpresssivity for tractability of reasoning, it is
best to study Chapter 2 and move on to Chapter 4, particularly Section 1.
e reader is encouraged to refer to the appendices containing source code for many exam-
ples discussed in the book, and also to try out some of the SMV modeling and CTL veriﬁcation
exercises for a better understanding of the subject matter.


11
C H A P T E R
2
Qualitative Preference
Languages
In the previous chapter, we reviewed some real-world applications where preferences play a vital
role in choosing the most desirable alternative from among a set of candidates. User preferences
over the alternatives were expressed as a qualitative (relative) ordering over the set of attributes
and their respective values. is chapter aims to review some of the key formalisms for repre-
senting and reasoning with such qualitative preferences. We begin the chapter by introducing
qualitative preferences as binary relations over the set of alternatives. We review a broad class of
qualitative preference languages that allow users to express various kinds of preference relations
over attributes and their domains, and their semantics in terms of an induced preference graph
that encodes a partial order over set of alternatives with respect to a given set of preferences. We
will then deﬁne a set of reasoning tasks, e.g., checking whether one alternative dominates another
with respect to a given set of preferences. For a thorough review of the literature on qualitative
preference languages, the interested reader is encouraged to refer to [35].
1
PRELIMINARIES
Our aim is to represent and reason about the relative preference of outcomes or alternatives with
respect to a set of the user’s qualitative preferences.¹ We assume that in the general case, an alter-
native in a decision problem may be described in terms of a set of attributes or preference variables
(or simply variables) that the user cares about when making his choice. In the credentials example
in Section 1.5, the various subsets of user credentials form the set of alternatives; in the cyberde-
fense example in Section 1.1 each alternative is described in terms of a valuation to the three
variables describing a vulnerability. Formally, we use the following notations for the concepts just
described.
1.1
NOTATION
Let X D fxi j 0 < i  ng be a set of preference variables or attributes. For each xi 2 X let Di
be the set of possible values (i.e., domain) such that xi D vi 2 Di is a valid assignment to the
variable xi. We use ˚; 	, and ˝ (indexed, subscripted, or superscripted as necessary) to denote
subsets of X. e set O D fQ
xi2X Dig of assignments to variables in X is called the set of all
¹In the rest of the book, we will use the term “preference” for “qualitative preference,” unless otherwise mentioned.

12
2. QUALITATIVE PREFERENCE LANGUAGES
possible alternatives. e valuation of an alternative  2 O with respect to a variable xi 2 X is
denoted by .xi/ 2 Di. e set of assignments with respect to a subset ˚ D fxj1 : : : xjmg  X is
given by O˚ D f j Q
xi2˚ Dig, where  is an assignment to the variables in ˚, denoted by the
tuple  WD hv1; v2; : : : ; vmi, such that vi D .xi/ 2 Di for each xi 2 ˚.
Example 2.1
For the cyberdefense example in Section 1.1, the vulnerability that
has a freely available exploit code and a Fix-Available with a high access complex-
ity is denoted by the tuple hE D Code-Available; A D High; F D Fix-Availablei, or simply
hCode-Available; High; Fix-Availablei when the attributes can be inferred from the context.
Note that in a CI-net (see example in Section 1.3), the meaning of “attribute” is diﬀerent
from what it means in the context of a CP-net or TCP-net or CP-eory. When talking about
CI-nets, an attribute is a boolean property (binary variable), and is “true” in an alternative if
it is “satisﬁed” by the alternative. Each alternative is described by the set of attributes that are
included in (or properties satisﬁed by) it, and the preferences over alternatives are speciﬁed in
terms of the presence or absence of attributes in an alternative. To represent such alternatives
uniformly in terms of tuples of valuations of attributes as above, we will use a boolean variable for
each attribute, whose truth valuation denotes the inclusion of the attribute in the alternative.
Example 2.2
We denote an alternative that includes the attributes “Cheaper transaction costs”
(C) and “Performance” (R) (but not “Security” (S) and “Traceability” (T)) in the example in
Section 1.3 by
hC D true; R D true; S D false; T D falsei
As
a
notational
convenience,
in
such
settings
we
will
denote
an
alternative
that
includes the set
˚  X
of attributes, simply by the subset
˚. For example, the
above alternative will be represented as the set fC; Rg; the alternative that includes
only
“Security”
and
“Cheaper
transaction
costs”
is
denoted
as
fC; Sg
(rather
than
hC D true; R D false; S D true; T D falsei); and the preference (p1) represents the
preference of the alternative fC; R; Sg over the alternative fS; T g.
1.2
SUCCINCT PREFERENCE SPECIFICATION
Given a set O of n alternatives, a direct speciﬁcation of a binary preference relation  over O is
diﬃcult, as it requires the user to compare up to O.n2/ pairs of alternatives, which is prohibitive
in time because n is exponentially large. Hence, many preference languages allow for succinct
speciﬁcation of the preference relation over alternatives in terms of preference relations over the set
of attributes that describe the alternatives and their respective valuations (i.e., domains).
Preference Relations
Qualitative preference relations can be either (a) intra-variable prefer-
ence relations over valuations of an attribute; or (b) relative importance preference relations
over attributes. Note the subtle distinction between relative importance and intra-attribute

1. PRELIMINARIES
13
preferences—while relative importance speciﬁes a preference relation over the set of attributes,
individual intra-variable preferences with respect to each variable specify preference relations over
the set of valuations of that variable. A language that allows for speciﬁcation of relative importance
preferences independent of the speciﬁcation of the intra-variable preferences may enable succinct
representation of user preferences; however, it necessitates the development of techniques for rea-
soning about preferences over alternatives that combine both types of user preferences in a suitable
way.
For any ˚  X, we will use the notation ˚ to denote a preference relation over D˚, the
set of partial assignments to attributes in ˚. For a single attribute xi 2 X, the intra-attribute
preference relation over its valuations (Di) will be denoted by fxig or alternatively i . For
example, to formally specify that the valuation vi is preferred to the valuation v0
i for attribute
xi where vi; v0
i 2 Di, we will write xi D vi i xi D v0
i. We will use the notation B to indicate
relative importance between attributes or between sets of attributes.
Example 2.3 Intra-attribute Preference
In the example in Section 1.1, that Low access com-
plexity is preferred to High is an unconditional intra-attribute preference:
A D Low A A D High
In the same example, that a ﬁx to the vulnerability is unavailable is preferred to the case
when a Fix-Available is available, is a conditional intra-attribute preference:
E D Code-Available ) F D Fix-Unavailable F F D Fix-Available
Example 2.4 Relative Importance
at A is more important than E in the TCP-net in Sec-
tion 1.1 is an unconditional relative importance preference: A B E. In the same example with a
CP-theory, that A is more important than the set of attributes fE; F g is an example of One-Many
relative importance, i.e., fAg B fE; F g.
Further, the preference p1 in the Section 1.3 states conditional Many-One relative impor-
tance in a CI-net: among two sets of attributes that include S, fC; Rg B fT g meaning that one
that includes both C and R is preferred to one that includes only T .
Preference Statements
In all the above languages, preferences are expressed in terms of a set
P D fpig of preference statements. Each statement p either speciﬁes a binary relation over the
domain of a particular variable (intra-variable preference) or a binary relation over the set X
of preference variables (relative importance). e semantics of the preference languages deﬁne
how these succinct statements of preference are interpreted in order to determine the preference
over alternatives. Several diﬀerent preference semantics may be deﬁned for a given preference
language depending on how the stated preferences over the variables are interpreted and translated

14
2. QUALITATIVE PREFERENCE LANGUAGES
into preferences over alternatives; we focus on the most popular interpretation, namely the ceteris
paribus semantics. We will ﬁrst describe the representation scheme of CP-nets, TCP-nets, CP-
eories, and CI-nets, followed by their semantics.
2
QUALITATIVE PREFERENCE LANGUAGES
We consider members of the preference network family of languages that are popular, includ-
ing conditional preference networks (CP-nets) [16], generalized CP-nets (GCP-nets) [41], and
trade-oﬀenhanced conditional preference networks (TCP-nets) [18]. e above languages allow
user preferences to be modeled using an intuitive graphical representation scheme. We also con-
sider other qualitative preference languages such as conditional preference theories (CP-eories)
[94–96], and conditional importance networks (CI-nets) [17] that do not have a simple graph-
ical representation scheme, but allow preferences to be modeled in terms of a set of preference
statements. We do not consider UCP-nets [13], an extension of CP-nets that allow the represen-
tation of quantitative preferences (utility information) rather than simple qualitative preference
orderings.
2.1
REPRESENTING QUALITATIVE PREFERENCES
e need for representing such qualitative preferences in a succinct, user-friendly way has been
addressed by several authors in the past. Of particular relevance are conditional preference net-
works (CP-nets[16] and GCP-nets[41]) that allow the user to express a set of conditional pref-
erences over the domain of an attribute of the form “the valuation x1 is preferred to the valuation
x0
1 for attribute X1 under a given condition” (e.g., p1–p3 in the cyberdefense example of Sec-
tion 1.1). TCP-nets [18] further allow simple conditional relative importance preferences over
pairs of attributes of the form X1 is more important than X2 (e.g., p5). e above languages also
support preference input using a compact graphical representation scheme. Some other related
languages such as CI-nets and CP-eories allow statements of relative importance among sets
of attributes. In particular, CP-eories [96] allow statements of the form “X1 is more impor-
tant than fX2; X3g” (e.g., p6). CI-nets [17] allow unconditional and monotonic intra-attribute
preferences, and conditional relative importance preferences over sets of attributes of the form
“fX1; X2g is more important than fX3; X4g” (e.g., p7 can be expressed in a CI-net but not in the
other languages). e above preference languages allow the succinct expression of user preferences
over alternatives in terms of a preference speciﬁcation P , which is a set of preference statements p
over the preference variables V . e formal syntax and interpretation, as well as compact graphi-
cal representation schemes for preference speciﬁcations in these languages, are described in detail
later.

2. QUALITATIVE PREFERENCE LANGUAGES
15
ere are also other graphical models for representing qualitative preferences, notably pref-
erence trees (P-trees) and lexicographic preference trees (LP-trees) [11, 58, 59], as well as logic-
based models² that we do not discuss in this book.
Table2.1: Qualitative preference languages and the types of preference relations they allow to express.
e ﬁrst column describes the kind of preference relations that are supported (or not supported) by the
diﬀerent preference languages. A checkmark (X) indicates that the language allows the corresponding
preference relation to be expressed.  A CI-net allows only monotonic intra-variable preference.
Preference Relation Type
CP-net
TCP-net
CP-eory
CI-net
Unconditional
Intra-variable
Preference
X
X
X
X
Unconditional
Relative Importance
X
X
X
Conditional Intra-
variable Preference
X
X
X
Conditional
Relative Importance
X
X
X
One-Many Relative
Importance
X
X
Many-Many Relative
Importance
X
2.2
PREFERENCE SEMANTICS
e semantics of the preference languages deﬁne how these succinct statements of preference over
individual variables may be interpreted in order to determine the preference over alternatives.
A well-studied semantics for interpreting the user’s statements of preference in a preference
network is the ceteris paribus or “all else being equal” semantics.
• e ceteris paribus interpretation of an intra-attribute preference statement over the domain
of an attribute X rules that an alternative ˛ is preferred to another ˇ if and only if all other
attributes being equal, the assignment to X in ˛ is preferred to the assignment to X in ˇ.
• A relative importance statement of the form X is more important than Y is interpreted as
follows: An alternative is preferred to another if and only if it has preferred values for the
more important attribute X, all other attributes except Y being equal.
²For a more elaborate discussion on these other preference languages, please refer to [52].

16
2. QUALITATIVE PREFERENCE LANGUAGES
e second kind of (relative importance) preference is supported by TCP-nets, CI-nets, and
CP-theories. More expressive relative importance statements can be represented in CP-theories
and CI-nets:
• e statement “an attribute X over a set Y of other attributes” is interpreted as follows. An
alternative is preferred to another if and only if it has preferred values for the more important
attribute X, all other attributes except those in Y being equal.
e ceteris paribus semantics for a set of preference statements is given by an inducedprefer-
ence graph that is induced from the intra-variable and relative importance preference statements.
e nodes of this induced graph correspond to the set of all alternatives (i.e., the set of all assign-
ments to all preference variables). Each edge of the induced preference graph is directed from a
less preferred to a more preferred alternative, and computing the ceteris paribus semantics amounts
to making traversals on the induced preference graph. In terms of the induced preference graph,
an alternative dominates another if and only if there exists a path from the less preferred to the
more preferred alternative.
According to the ceteris paribus interpretation [15, 45] of preferences, each preference state-
ment p 2 P allows a set of changes to the valuation(s) of one or more variables in an alternative
ˇ in order to obtain a more preferred alternative ˛, while other variables remain ﬁxed. Such a
change is called an improving ﬂip.
Deﬁnition 2.5 Improving ﬂip.
Given a preference speciﬁcation P , there is said to be an im-
proving ﬂip from an outcome ˇ to another outcome ˛ if and only if there is some preference
statement p 2 P that induces the dominance of ˛ over ˇ according to the interpretation of the
intra-variable and relative importance preference statements in P , as given by the semantics of
the language of P .
Example 2.6
Improving ﬂip
For instance in Section 1.1, the alternative ˇ D hE D
Code-Unavailable; A D Low; F D Fix-Unavailablei can be changed to obtain a more pre-
ferred alternative ˛ D hE D Code-Available; A D Low; F D Fix-Unavailablei by modify-
ing the valuation of E in ˇ using preference statement p1. In other words, p1 induces an im-
proving ﬂip from ˇ to ˛.
e semantics of a preference speciﬁcation P in any of the above languages (namely, CP-
nets, TCP-nets, CP-eories, and CI-nets) is given in terms of a (strict) partial order  over the
alternatives, where ˛  ˇ if and only if there is a sequence of alternatives ˇ D 1; 2; : : : n D ˛
such that for all 1  i  n, there is an improving ﬂip from i to iC1 with respect to some p 2 P .
Such a sequence is called an improving ﬂipping sequence from ˇ to ˛.
e only diﬀerence in the semantics of CP-nets, TCP-nets, CP-eories, and CI-nets is
the deﬁnition of what constitutes a valid improving ﬂip. For example, CP-nets can represent only
intra-variable preferences over the valuations of one variable at a time, whereas TCP-nets can
additionally represent relative importance between a pair of variables at a time, and CP-eories

2. QUALITATIVE PREFERENCE LANGUAGES
17
allow relative importance of one variable over a set of variables at a time. As a result, the improving
ﬂips for CP-nets allow at most one variable to change at a time; those for TCP-nets allow at most
two variables to be changed at a time; and those for CP-eories allow multiple variables to be
changed at a time.
We now describe the representation scheme of CP-nets, TCP-nets, CP-eories, and CI-
nets and their improving ﬂipping sequence semantics.
2.3
CP-NETS
CP-nets [16] use a compact graphical model to specify the conditional intra-variable preferences
fxig individually for each variable xi. Each node in the graphical representation of a CP-net C
corresponds to a variable xi 2 X, and each dependency edge .xi; xj / in the graph captures the fact
that the intra-variable preference fxj g with respect to variable xj is dependent (or conditioned)
on the valuation of xi. For any variable xj, the variables fxi W .xi; xj /is an edgeg are called the
parent variables, denoted .xj /. Each node xi in the graph is associated with a conditional pref-
erence table that maps each possible assignment to the parents .xi/ to a total order over Di. An
acyclic CP-net is one that does not contain any cycles in the dependency graph. GCP-nets [41]
generalize CP-nets with binary variables in that they (a) allow conditional preference tables to be
partially deﬁned, i.e., the user may choose to specify neither vi fxig v0
i nor v0
i fxig vi for some
assignment to the parents .xi/; and (b) do not require the assignments to the parents .xi/ in
the conditional preference table of xi to be exhaustive, i.e., the mapping from the set of assign-
ments of .xi/ to partial orders over values of xi can be partial. CP-nets and GCP-nets can be
further generalized such that (a) each variable xi has an arbitrary domain Di; (b) conditional
preference table of each variable xi provides a partial (not necessarily complete) mapping from
some assignments of .xi/ to conditional preference relations fxig that are strict partial (not
necessarily total) orders over Di. In the rest of the book, we will use “CP-nets” to refer to such a
generalization of CP-nets and GCP-nets.
e preferences encoded in a CP-net can be equivalently expressed in terms of a set of
preference statements of the form:
% W xi D vi fxig xi D v0
i
where % 2 D.xi/  X, xi 2 X n ˚ and vi; v0
i 2 Di. When % D true, we simply write xi D
vi fxig xi D v0
i. en, each preference ordering fxig of Di under the condition % corresponds
to a row in the conditional preference table of xi in the CP-net.
Example 2.7
Figure 2.1(a) shows a CP-net over the set fE; A; F g of variables for the cyberde-
fense example (see Section 1.1). e conditional preference tables for each variable is shown as a
box next to the variable. Note that the conditional preference table of F is incomplete, i.e., the
ordering over the domain of F is partial when E takes the valuation Code-Unavailable, and it
is an acyclic CP-net because there is only one dependency edge from E to F . is CP-net can

18
2. QUALITATIVE PREFERENCE LANGUAGES
F
E
A
E=Code-Available:
Fix-Unavailable ≻Fix-Available 
Low ≻High
Code-Available ≻Code-Unavailable
(a) CP-net
F
E
A
Fix-Unavailable 
Fix-Available 
Low 
High
Code-Available 
Code-Unavailable
E=Code-Available:
≻
≻
≻
(b) TCP-net
≻
≻
≻
E=Code-Available:
(c) CP-eory
Figure 2.1: Risk priorities of a cyberdefender.
be equivalently expressed in terms of a preference speciﬁcation P CP consisting of the following
preference statements. An illustration of the actual partial order on the alternatives induced by
this CP-net will be given in Chapter 4.
p1. E D Code-Available E E D Code-Unavailable
p2. A D Low A A D High
p3. E D Code-Available W F D Fix-Unavailable F F D Fix-Available
2.4
TCP-NETS
TCP-nets [18] allow the users to specify pairwise relative importance among variables in addition
to conditional intra-variable preferences as in CP-nets. As in CP-nets, each node in the TCP-net
corresponds to a variable xi and is associated with a conditional preference table that (possibly
partially³) maps assignments to .xi/ to conditional preference relations fxig that are strict par-
tial orders over Di. e relative importance of a variable xi over xj is denoted by xi B xj, and
³e original deﬁnition of TCP-nets [18] requires this mapping to be total; however, we relax this condition, as the reasoning
techniques we develop later in the book can be applied to the more general deﬁnition.

2. QUALITATIVE PREFERENCE LANGUAGES
19
represented as another type of edge .xi; xj / in the TCP-net graph, diﬀerently from the condi-
tional dependency edges. Each relative importance edge could be either unconditional (directed
edge) or conditioned on a set of selector variables (analogous to parent variables in the case of
intra-variable preferences). Each edge .xi; xj / describing conditional relative importance is undi-
rected (because whether or not one variable is more important than the other could depend on the
conditions) and is associated with a conditional importance table (CIT, analogous to the condi-
tional preference table), mapping an assignment of the selector variables to either xi B xj or vice
versa. Note that this mapping may be partial, which means that the relative importance relation
between xi and xj may be speciﬁed only for certain values of the set of selector variables.
A TCP-net can be equivalently expressed in terms of a set of preference statements of the
form:
% W xi D vi fxig xi D v0
i Œ˝
where fxig; ˚ D .xi/ and ˝ are disjoint subsets of X, vi; v0
i 2 Di, % 2 D˚ and j˝j D 0 or 1.⁴
Speciﬁcally, the notation Œ˝ at the end of the above preference statement denotes the relative
importance of the variable xi over xj 2 ˝ if ˝ D fxj g (under the condition %), and when ˝ D
;, the statement expresses the conditional intra-attribute preferences for xi. When ˚ D ;, xi
is unconditionally more important than xj, and hence the corresponding relative importance
edge between xi and xj is directed from xi to xj; and when ˚ ¤ ;, the relative importance
edge between xi and xj is undirected (to allow diﬀerent importance relationships under diﬀerent
conditions).
Example 2.8
Figure 2.1(b) shows a TCP-net over the set fE; A; F g of variables for the cyberde-
fense example (see Section 1.1). e preference speciﬁcation P T CP representing this TCP-net
will include the preference statements p1 and p3 of the speciﬁcation P CP in Example 2.7 as
the intra-attribute preferences are common. However, the preference over valuations of A will be
represented diﬀerently in P T CP , due to the relative importance of A over E (dotted edge from
A to E); hence the preference statement p0
2 (which further elaborates on p2 in Section 1.1) in
P T CP will be as follows.
p0
2. A D Low A A D High ŒfEg
2.5
CP-THEORIES
CP-eories [96] extend TCP-nets by further allowing the speciﬁcation of the relative impor-
tance of one variable over a set of variables conditioned on another set of variables. A CP-eory
consists of statements of the form
% W xi D vi fxig xi D v0
i Œ˝
⁴Although ˝ is either an empty set or a singleton, we still choose to represent it as a subset of variables, as it makes it easier to
describe the next language, namely CP-theories, that allows for subsets of variables with more than one variable in ˝.

20
2. QUALITATIVE PREFERENCE LANGUAGES
where % is an assignment to the set ˚  X of variables that deﬁnes the condition under which
the preference holds, vi; v0
i 2 Di, ˝  X, and ˚; ˝; fxig and .X   ˚   ˝   fxig/ are disjoint.
Speciﬁcally, the notation Œ˝ at the end of the above preference statement denotes the relative
importance of the variable xi over the set ˝ of variables under the condition %. Note that CP-
nets can be expressed as CP-eories by ﬁxing ˝ D ; (i.e., j˝j D 0); and TCP-nets can be
expressed as CP-eories by ﬁxing j˝j D 0 or 1. In particular, suppose that a TCP-net contains
the statement xi B xj, and the intra-attribute preferences of xi are deﬁned by fxig, then the
same can be represented in terms of a set of CP-eory statements such that for each statement
% W xi D vi fxig xi D v0
i in the TCP-net, there is a new CP-eory statement % W xi D vi fxig
xi D v0
i Œfxj g.
Example 2.9
Figure 2.1(c) shows a CP-theory over the set fE; A; F g of variables for the cy-
berdefense example (see Section 1.1). e preference speciﬁcation P CP T representing this CP-
theory will include the preference statements p1 and p3 as in the speciﬁcations P CP and P T CP ;
and the preference over valuations of A will be represented in P CP T diﬀerently from P T CP due
to diﬀerence in the statement of relative importance of A over the set fE; F g (illustrated as dot-
ted edge in Figure 2.1(c)). Hence the preference statement p00
2 (which further elaborates on p2 in
Section 1.1) in P CP T will be as follows:
p00
2. A D Low A A D High ŒfE; F g
2.6
CI-NETS
CI-nets [17] allow for the speciﬁcation of more expressive relative importance preferences as
compared to TCP-nets, namely, conditional relative importance over arbitrary sets of variables
(as opposed to relative importance over just singletons). However, CI-nets place two restric-
tions on the intra-variable preferences: (a) the domains of the variables are binary, i.e., 8xi 2 X W
Di D ftrue; falseg; and (b) the intra-variable preferences are unconditional and monotonic,
i.e., 8xi 2 X W true fxig false.⁵ As a result, an alternative  corresponds to a subset of X, and
the set of all possible alternatives O corresponds to the powerset of X. A CI-net consists of state-
ments of the form: ˚C; ˚  W 	1  	2, which states that “among two alternatives that include
variables in ˚C and exclude variables in ˚ , the alternative that includes those in 	1 is preferred
to one that includes those in 	2.” Such set-based relative importance cannot be expressed in CP-
nets, TCP-nets, or CP-theories. On the other hand, CI-nets restrict intra-variable preferences
to be unconditional and monotonic, and hence they cannot express conditional intra-variable
preferences which is possible in TCP-nets and CP-nets.
Note that in CP-nets, TCP-nets, and CP-eories, each preference statement in the lan-
guage can be represented in terms of preferences over the valuations of a single attribute xi (and
⁵is order can be domain speciﬁc [68, 69].

2. QUALITATIVE PREFERENCE LANGUAGES
21
possibly the relative importance of that attribute over others by specifying a non-empty ˝). How-
ever, in the case of CI-nets such a representation is not always possible because each preference
statement may deﬁne the relative importance of a set (	1) of attributes over another (	2). Hence,
the above CI-net statement can be translated into the following preference statement:
% W .
^
xi2	1
xi D true ^
^
xj 2	2
xj D false/
	1[	2
.
^
xi2	1
xi D false ^
^
xj 2	2
xj D true/
where % is the partial assignment to ˚C [ ˚ , such that 8xi 2 ˚C W %.xi/ D true and 8xj 2
˚  W %.xj / D false. In the above, the preference relation 	1[	2 is over D	1[	2.
Example 2.10
e CI-net described in Example 1.3 is expressed in the following form.
p1. fSg; fg W fC; Rg  fT g
p2. fg; fT g W fSg  fCg
e above CI-net can be equivalently expressed in terms of the preference speciﬁcation
P CI consisting of the following preference statements.
p1. S D 1 W .C D 1 ^ R D 1 ^ T D 0/  .C D 0 ^ R D 0 ^ T D 1/
p2. T D 0 W .S D 1 ^ C D 0/  .S D 0 ^ C D 1/
Example 2.11
For the CI-net described in the countermeasure example in Section 1.4, let a WD
“Increase Logging Level,” b WD “Restrict Access Privilege,” c WD “Stop Service,” and d WD “Setup
a Firewall.” e following statements then constitute the preference speciﬁcation in that example.
p1. fdg; fg W fbg  fcg
p2. fbg; fag W fcg  fdg
p3. fag; fcg W fbg  fdg
p4. fg; fag W fb; dg  fcg
p5. fg; fcg W fa; dg  fbg
e formal representation of the above CI-net statements are as follows.
p1. d D 1 W .b D 1 ^ c D 0/  .b D 0 ^ c D 1/
p2. .b D 1 ^ a D 0/ W .c D 1 ^ d D 0/  .c D 0 ^ d D 1/
p3. .a D 1 ^ c D 0/ W .b D 1 ^ d D 0/  .b D 0 ^ d D 1/
p4. a D 0 W .b D 1 ^ d D 1 ^ c D 0/  .b D 0 ^ d D 0 ^ c D 1/
p5. c D 0 W .a D 1 ^ d D 1 ^ b D 0/  .a D 0 ^ d D 0 ^ b D 1/

22
2. QUALITATIVE PREFERENCE LANGUAGES
2.7
RELATIVE EXPRESSIVE POWER
In terms of expressive power, CP-nets is the least expressive formalism, allowing only intra-
attribute preferences with conditional dependencies among variables, and no relative importance
preferences. TCP-nets are more expressive than CP-nets [18], as they allow relative importance
preferences over individual variables in addition to CP-net language. CP-theories are more ex-
pressive than TCP-nets [93, 94] because they more generally allow speciﬁcation of intra-attribute
preferences with conditional dependencies, as well as speciﬁcation of relative importance of one
variable over a set of variables at the same time. CI-nets allow relative importance preference of
one set over another set that cannot be expressed in CP-nets, TCP-nets, or CP-theories. For
example, the statement p1 in the CI-net P CI cannot be expressed in CP-nets, TCP-nets, or
CP-theories. On the other hand, CI-nets restrict intra-variable preferences to be unconditional
and monotonic [17], and hence they cannot express conditional intra-variable preferences which
is possible in TCP-nets and CP-nets. For example, the statement p3 in the CP-net P CP cannot
be expressed in a CI-net. To summarize, CP-theories are more expressive than TCP-nets, which
are in turn more expressive than CP-nets; and CI-nets are neither more nor less expressive than
the other three languages.
3
REASONING WITH QUALITATIVE PREFERENCES
e preference languages discussed above allow the succinct expression of user preferences over
alternatives in terms of a set P D fpig of preference statements over the preference variables
X. e semantics of the preference languages deﬁne how these succinct statements of preferences
over individual variables may be interpreted in order to determine the preference over alternatives.
Several diﬀerent preference semantics may be deﬁned for a given preference language depending
on how the stated preferences over the variables are interpreted and translated into preferences
over alternatives.
3.1
CETERIS PARIBUS PREFERENCE SEMANTICS
e semantics of a preference speciﬁcation P over X is given in terms of the semantics of each
of its preference statements. Consider a preference statement p 2 P that speciﬁes the preference
of one valuation of a set ˚  X of variables over another, conditioned on some valuation % of
another set   X of variables. e ceteris paribus, or “all else being equal” interpretation [15, 45]
of p, induces the preference of one alternative over another if and only if (a) both alternatives
respect the condition on , i.e., agree on the respective valuations of each variable in , (b) both
alternatives agree on the valuation of X n ˚ n , the set of variables that do not appear in p,⁶ and
(c) the ﬁrst alternative is preferred to the second with respect to their respective valuations of ˚
as speciﬁed by the ˚ preference relation in p. Such an induced preference is called an improving
⁶ Ceteris paribus means “all else equal,” which is captured simply by the condition (b); however in the context of preference
reasoning, the ceteris paribus semantics requires the conditions (a) and (c) as well.

3. REASONING WITH QUALITATIVE PREFERENCES
23
ﬂip, i.e., the result of “ﬂipping” only the variables in ˚ from a less preferred assignment of ˚
to a more preferred assignment of ˚ according to the preference stated in p. In other words, an
improving ﬂip from one alternative to another induced by p corresponds to changing the valuation
of a set of variables in one alternative in order to obtain a preferred valuation for that set according
to the conditional preference speciﬁed in p.
Preference languages diﬀer in the types of preference statements they allow in a preference
speciﬁcation, namely intra-attribute preferences (all languages), relative importance preferences
over individual attributes (TCP-nets, CP-eories, CI-nets), or relative importance over sets
of attributes (CP-eories and CI-nets). Hence, we ﬁrst describe the semantics of each of these
types of preference statements in terms of the improving ﬂips they induce over pairs of alternatives,
and then describe the semantics of a preference speciﬁcation in any of the above languages in terms
of the ﬂips induced by its constituent preference statements.
Semantics for Intra-variable Preference Statements
Consider an intra-variable preference statement p of the form % W vi fxig v0
i, which can be spec-
iﬁed in all the languages we consider. Given two alternatives ˛; ˇ 2 O, the ceteris paribus inter-
pretation of the statement p induces an improving ﬂip from ˇ to ˛ if ˛ and ˇ diﬀer only in xi,
and ˛.xi/ D vi and ˇ.xi/ D v0
i. In other words for any statement p, the valuation of only one
variable can be ﬂipped at a time, and that to a more preferred valuation with respect to p, while
other variables remain ﬁxed.
Deﬁnition 2.12
Preference Semantics for Intra-attribute Preference [16].
Given an intra-
attribute preference statement p in a preference speciﬁcation P of the form % W xi D vi fxig
xi D v0
i where % 2 D˚; ˚ D .xi/  X and two alternatives ˛; ˇ 2 O, there is an improving ﬂip
from ˇ to ˛ in ı.P / induced by p if and only if
1. 9xi 2 X W ˛.xi/ D vi and ˇ.xi/ D v0
i,
2. 8xj 2 ˚ W ˛.xj / D ˇ.xj / D %.xj /, and
3. 8xk 2 X n fxig n ˚ W ˛.xk/ D ˇ.xk/.
In the above deﬁnition, the ﬁrst condition arises from the intra-attribute preference state-
ment xi; the second condition enforces the condition % in p that states that ˛ and ˇ should concur
on the parent variables of xi; and the third enforces the ceteris paribus condition that states that
˛ and ˇ should concur on all the other variables.
Example 2.13
In the CP-net for the cyberdefense example in Figure 2.1(a), the preference
statement p2 induces improving ﬂips from ˛ to ˇ whenever ˛.A/ D High, ˇ.A/ D Low, ˛.E/ D
ˇ.E/, and ˛.F / D ˇ.F /. In other words, p2 represents an intra-variable preference over A that
induces the following four improving ﬂips, with the valuations of E and F being ceteris paribus,
i.e., ﬁxed.

24
2. QUALITATIVE PREFERENCE LANGUAGES
• hCode-Unavailable; High; Fix-Unavailablei to hCode-Unavailable; Low; Fix-Unavailablei
• hCode-Available; High; Fix-Unavailablei to hCode-Available; Low; Fix-Unavailablei
• hCode-Unavailable; High; Fix-Availablei to hCode-Unavailable; Low; Fix-Availablei
• hCode-Available; High; Fix-Availablei to hCode-Available; Low; Fix-Availablei
On the other hand, the preference statement p3 induces only two ﬂips with the valuations
of A and E being ceteris paribus.
• hCode-Available; High; Fix-Availablei to hCode-Available; High; Fix-Unavailablei
• hCode-Available; Low; Fix-Availablei to hCode-Available; Low; Fix-Unavailablei
Because the conditional preference for F is partially speciﬁed in the conditional preference table,
alternatives are not comparable when E D Code-Unavailable.
Semantics for Statements of Relative Importance Preference over Attributes
TCP-nets and CP-eories allow the speciﬁcation of relative importance preference of one vari-
able over one or more variable respectively. We will treat CI-nets that allow speciﬁcation of rel-
ative importance preferences of a set of variables over another separately below, because CI-nets
represent attributes that are either present or absent in a given set.
TCP-nets and CP-eories
Coming back to TCP-nets and CP-eories, note that multiple
variables can change in the same improving ﬂip because a statement of relative importance of one
attribute over others means that the user is willing to improve the valuation of the more important
attribute at the expense of worsening the less important attribute(s).
Deﬁnition 2.14 Preference Semantics for Relative Importance of one Attribute over a Set [18,
94].
Given a relative importance preference statement p in a preference speciﬁcation P of the
form % W xi D vi fxig xi D v0
i Œ˝ where % 2 D˚; ˚  X and two alternatives ˛; ˇ 2 O, there
is an improving ﬂip from ˇ to ˛ in ı.P / induced by p if and only if
1. 9xi 2 X W ˛.xi/ D vi and ˇ.xi/ D v0
i,
2. 8xj 2 ˚ W ˛.xj / D ˇ.xj / D %.xj /, and
3. 8xk 2 X n fxig n ˝ n ˚ W ˛.xk/ D ˇ.xk/.
In the above deﬁnition, the ﬁrst condition arises from the preference statement p on xi; the
second condition enforces the condition % in p; and the third enforces the ceteris paribus condition
and allows for unrestricted changes to the attributes that are less important than xi (in ˝) when
this preference statement is applied.

3. REASONING WITH QUALITATIVE PREFERENCES
25
CI-nets
CI-nets allow relative importance of one set of attributes over another. Recall that a CI-
net statement p of the form ˚C; ˚  W 	1  	2 can be translated into the following preference
statement:
% W .
^
xi2	1
xi D true ^
^
xj 2	2
xj D false/
	1[	2
.
^
xi2	1
xi D false ^
^
xj 2	2
xj D true/
where % is the partial assignment to ˚C [ ˚ , such that 8xi 2 ˚C W %.xi/ D true and 8xj 2
˚  W %.xj / D false. In the above, the preference relation 	1[	2 is over D	1[	2, and ceteris
paribus condition is enforced on the set X n .˚C [ ˚  [ 	1 [ 	2/. Note that in the case of
the other languages, each preference statement deﬁned preferences (fxig) over the valuations
of a single attribute xi and possibly the relative importance of that attribute over others (˝).
However, in the case of CI-nets each preference statement may deﬁne the relative importance
of a set (	1) of attributes over another (	2), and hence it is represented by a preference relation
over the partial valuations of the set 	1 [ 	2 of attributes. For example, the preference p1 in
Section 1.3 speciﬁes the relative importance of fC; Rg over T when both alternatives include
S. In other words, the alternative hC D true; R D true; S D true; T D falsei is preferred
to hC D false; R D false; S D true; T D truei. e second preference p2 in the example
translates to the following preference statement.
T D false W S D true ^ C D false  S D false ^ C D true
with the attribute P (that does not ﬁgure in the statement) being ceteris paribus, i.e,
the two alternatives between whom the preference statement induces a preference agree
on the valuation of R. In other words, hC D false; R D true; S D true; T D falsei
is
preferred
to
hC D true; R D true; S D false; T D falsei
and
hC D false; R D false; S D true; T D falsei
is
preferred
to
hC D true; R D false; S D false; T D falsei. In addition the above preferences, the
CI-nets by default include monotonicity of intra-attribute preferences for each attribute. e
semantics for CI-nets was deﬁned by Bouveret et al. [17] in terms of the set notation as follows.
Deﬁnition 2.15 Preference Semantics for Relative Importance of a Set of Attributes over An-
other Set[17].
Given a relative importance preference statement p of the form ˚C; ˚  W 	1 
	2, and two alternatives ˛; ˇ 2 O, there is an improving ﬂip from ˇ to ˛ in ı.P / induced by p
if and only if either
1. .Monotonicity Flip/ ˛  ˇ; or
2. .Importance Flip/
(a) ˛  ˚C, ˇ  ˚C, ˛ \ ˚  D ˇ \ ˚  D ;;

26
2. QUALITATIVE PREFERENCE LANGUAGES
(b) ˛  	1, ˇ  	2, ˛ \ 	2 D ˇ \ 	1 D ;;
(c) if  D G˚ n .˚C [ ˚  [ 	1 [ 	2/ then  \ 	1 D  \ 	2.
In the above deﬁnition, the condition (1) states that the set is always preferred to its subset.
e condition (2) states that given two sets % and %0 both containing the elements in ˚C and not
containing those in ˚ , and if % contains the elements in 	1 and %0 contains those in 	2 then %
is preferred to %0, all others being equal (which is ensured by the condition (2.2)).
3.2
SEMANTICS FOR A PREFERENCE SPECIFICATION AS INDUCED
PREFERENCE GRAPHS
e semantics of a preference speciﬁcation in each of the preference languages CP-nets, TCP-
nets, CP-eories, and CI-nets is given in terms of an induced preference graph [16–18, 96] that
captures the set of all improving ﬂips induced by all its preference statements.
Deﬁnition 2.16 Induced Preference Graph.
Let P be a preference speciﬁcation consisting of
the set fpig of preference statements in any of the above languages over the set X of variables. e
induced preference graph ı.P / D G.A; E/ is constructed as follows. e nodes A correspond to the
set of all possible alternatives, i.e., complete assignments to all variables in X. Each directed edge
.ˇ; ˛/ 2 E from alternative ˇ to alternative ˛ is an improving ﬂip from ˇ to ˛, denoting that ˛
is preferred to ˇ according to the interpretation of some preference statement pi in P .
From the above deﬁnition, we observe that the only diﬀerence in the semantics of the
various preference languages we consider is the set of improving ﬂips that they induce between
alternatives in the induced preference graph.
Example 2.17
e induced preference graphs for the preference speciﬁcations P CP , P T CP ,
P CP T , and P CI are given in Figures 2.2, 2.3, 2.4, and 2.5 respectively. In the case of P CP ,
P T CP , and P CP T , each improving ﬂip (edge) that is induced by an intra-variable preference
statement (annotated by the preference statement number) is shown by a solid arrow. Each im-
proving ﬂip that is induced by a relative importance preference statement (shown using dotted
arrow) is annotated with the preference statement that induced the ﬂip. e arrows are directed
toward the preferred alternative in each ﬂip. Note that ı.P T CP ) contains improving ﬂips corre-
sponding to relative importance (p2 in P T CP ), which is not present in ı.P CP ).
In the case of the CI-net P CI, the induced preference graph ı.P CI/ includes ﬂips in-
duced by the (default) monotonicity rule (shown by solid arrows), and those induced by relative
importance statements in the speciﬁcation (shown by dotted arrows, annotated with the inducing
preference statement).
Remark 2.18
We have so far seen how preference speciﬁcations in the languages of CP-nets,
TCP-nets, CI-nets, and CP-theories can be expressed in the same syntactic framework, and the

3. REASONING WITH QUALITATIVE PREFERENCES
27
Code-Available, Low, Fix-Unavailable
Code-Available, Low, Fix-Available
Code-Available, High, Fix-Available
Code-Available, High, Fix-Unavailable
Code-Unavailable, Low, Fix-Unavailable
Code-Unavailable, Low, Fix-Available
Code-Unavailable, High, Fix-Available
Code-Unavailable, High, Fix-Unavailable
p1
p2
p2
p2
p2
p1
p1
p1
p3
p3
Figure 2.2: Induced preference graph ı.P CP / for the CP-net P CP .
Code-Available, Low, Fix-Unavailable
Code-Available, Low, Fix-Available
Code-Available, High, Fix-Available
Code-Available, High, Fix-Unavailable
Code-Unavailable, Low, Fix-Unavailable
Code-Unavailable, Low, Fix-Available
Code-Unavailable, High, Fix-Available
Code-Unavailable, High, Fix-Unavailable
p1
p'2
p'2
p'2
p'2
p1
p1
p1
p3
p3
p'2
p'2
Figure 2.3: Induced preference graph ı.P T CP / for the CP-net P T CP .

28
2. QUALITATIVE PREFERENCE LANGUAGES
Code-Available, Low, Fix-Unavailable
Code-Available, Low, Fix-Available
Code-Available, High, Fix-Available
Code-Available, High, Fix-Unavailable
Code-Unavailable, Low, Fix-Unavailable
Code-Unavailable, Low, Fix-Available
Code-Unavailable, High, Fix-Available
Code-Unavailable, High, Fix-Unavailable
p1
p''2
p''2
p''2
p''2
p1
p1
p1
p3
p3
p''2
p''2
p''2
p''2
p''2
Figure 2.4: Induced preference graph ı.P CP T / for the CP-net P CP T .
∅
Figure 2.5: Induced preference graph ı.P CI) for CI-net P CI.

3. REASONING WITH QUALITATIVE PREFERENCES
29
ceteris paribus preference semantics of any preference speciﬁcation in this framework. In the rest
of the chapter, we consider only preference speciﬁcations in the introduced framework, rather
than considering preference speciﬁcation with respect to a particular language. e strategies
we describe for preference reasoning and their implementation details will all be presented with
respect to arbitrary preference speciﬁcations in this framework.
3.3
DOMINANCE AND CONSISTENCY IN QUALITATIVE PREFERENCE
LANGUAGES
We now deﬁne the dominance of one alternative over another with respect to a preference speci-
ﬁcation P in terms of the improving ﬂips induced by the preference statements in P .
Deﬁnition 2.19 Improving Flipping Sequence.
Given a preference speciﬁcation P in any of
the above languages and two alternatives ˛ and ˇ, a sequence of alternatives from ˇ to ˛, namely
ˇ D 1; : : : n D ˛, where 1; : : : n are alternatives in O, is said to be an improving ﬂipping se-
quence [16–18, 94] with respect to (induced by) P from ˇ to ˛ if and only if for all i; i C 1 there
exists an improving ﬂip from i to iC1 in the induced preference graph ı.P /. We call n the
length of the improving ﬂipping sequence.
We observe that each path in the induced preference graph from one alternative to an-
other corresponds to an improving ﬂipping sequence. Moreover, there may be multiple distinct
improving ﬂipping sequences from one alternative to another.
Example 2.20
In
Figure
2.2,
there
is
only
one
improving
ﬂipping
sequence
of
length
1
in
ı.P CP /
from
ˇ D hCode-Available; High; Fix-Unavailablei
to
˛ D
hCode-Available; Low; Fix-Unavailablei. Figure 2.3 shows that there are two improving
ﬂipping sequences of lengths 1 and 2 from ˇ to ˛ in ı.P T CP / (including the one in ı.P CP /);
and Figure 2.4 shows that there are four improving ﬂipping sequences of lengths 1; 2; 2, and 3 in
ı.P CP T / from ˇ to ˛ (including those in ı.P CP / and ı.P T CP ).
Deﬁnition 2.21 Dominance.
Given a preference speciﬁcation P in any of the above languages
and two alternatives ˛ and ˇ, we say that ˛ is preferred to or dominates ˇ, denoted P ˆ ˛  ˇ, if
and only if there is an improving ﬂipping sequence with respect to P from ˇ to ˛.
Example 2.22 Dominance
Consider the TCP-net P CP .
hCode-Available; Low; Fix-UnavailableidominateshCode-Unavailable; High; Fix-Availablei
because of the following improving ﬂipping sequence:
hCode-Unavailable; High; Fix-Availablei ! hCode-Unavailable; Low; Fix-Availablei
! hCode-Available; Low; Fix-Availablei ! hCode-Available; Low; Fix-Unavailablei

30
2. QUALITATIVE PREFERENCE LANGUAGES
Many applications require the user preferences to induce an acyclic preference graph over
outcomes, as cycles indicate the notion of an outcome dominating (or being preferred to) itself.
Such preferences are said to be consistent.
Deﬁnition 2.23 Consistency.
A preference speciﬁcation P is said to be consistent if and only
if there exists no improving ﬂipping sequence (of length > 1) from any alternative to itself with
respect to P .
A consistent preference speciﬁcation P induces a strict partial order  on the set O of alter-
natives, or equivalently ı.P / is acyclic whenever P is consistent.
Example 2.24
Consistency
According to the above deﬁnition, all the example preference
speciﬁcations we have considered so far are consistent. Now consider changing the preference
on A in the TCP-net P T CP to include a conditional dependency on F . Let the resulting
TCP-net be P T CP
1
as shown in Figure 2.6(a). e corresponding induced preference graph is
shown in Figure 2.6(b). Observe that the improving ﬂips induced by the preference on A from
hCode-Unavailable; High; Fix-Availablei and hCode-Available; High; Fix-Availablei have been
reversed with this change (reversed ﬂips shown in bold), which induces cyclic preferences involv-
ing these alternatives. Hence, P T CP
1
is inconsistent.
In some settings, intentionally or unintentionally the stated preferences may induce cycles
in the induced preference graph. We deﬁne three possible relationships between outcomes that
are useful in such settings. Given two outcomes ˛ and ˇ: ˛ may be preferred to ˇ and not the other
way around, or ˛ may be preferred to ˇ and vice versa, or ˛ and ˇ are not preferred to each other.
Note that we are also considering relationships between outcomes resulting in inconsistencies in
preferences.
Deﬁnition 2.25
Preference, Indiﬀerence, and Equivalence.
Given the preference speciﬁca-
tion P ,
Preference. ˛ P ˇ if and only if there is an improving ﬂipping sequence with respect to
P from ˇ to ˛ but not from ˛ to ˇ. e existence of such a sequence corresponds to the
presence of a path from ˇ to ˛ in the induced preference graph.
Indiﬀerence. ˛ is indiﬀerent to ˇ and vice versa, denoted by ˛ 66P ˇ, if and only if there
is no improving ﬂipping sequence with respect to P from ˛ to ˇ nor from ˇ to ˛. In short,
there is no path between ˛ and ˇ in ı.P /.
Equivalence. ˛ and ˇ are equivalent, denoted by ˛ P ˇ, if and only if either ˛ D ˇ or
there are improving ﬂipping sequences from ˛ to ˇ and from ˇ to ˛. In short, ˛ and ˇ
belong to the same strongly connected component (SCC) in ı.P /.

3. REASONING WITH QUALITATIVE PREFERENCES
31
≻
≻
≻
≻
E=Code-Available:
(a) TCP-net P T CP
1
Code-Available, Low, Fix-Unavailable
Code-Available, Low, Fix-Available
Code-Available, High, Fix-Available
Code-Available, High, Fix-Unavailable
Code-Unavailable, Low, Fix-Unavailable
Code-Unavailable, Low, Fix-Available
Code-Unavailable, High, Fix-Available
Code-Unavailable, High, Fix-Unavailable
p1
p'2
p'2
p'2
p'2
p1
p1
p1
p3
p3
p'2
p'2
(b) Induced Preference Graph ı.P T CP
1
/
Figure 2.6: Inconsistent preference speciﬁcation.
Example 2.26
For
the
inconsistent
TCP-net’s
induced
preference
graph
in
Fig-
ure 2.6(b), hCode-Available, Low, Fix-Unavailablei is preferred to hCode-Unavailable,
High, Fix-Unavailablei; hCode-Available, High, Fix-Availablei and hCode-Unavailable,
Low, Fix-Availablei are equivalent; and hCode-Unavailable, High, Fix-Availablei and
hCode-Unavailable, High, Fix-Unavailablei are indiﬀerent according to the above deﬁni-
tion. hCode-Available, High, Fix-Availablei and hCode-Unavailable, Low, Fix-Availablei
are equivalent; and hCode-Unavailable, High, Fix-Availablei and hCode-Unavailable, High,
Fix-Unavailablei are indiﬀerent according to the above deﬁnition.

32
2. QUALITATIVE PREFERENCE LANGUAGES
4
COMPLEXITY OF REASONING
While it is useful to study qualitative preference languages due to their expressiveness, reasoning
with expressive preferences is hard. is is because while preference statements in these languages
are succinctly expressed (in terms of preferences among attributes and their valuations rather
than directly among the exponentially many alternatives), their semantics is expressed in terms
of reachability over the outcome space. In other words, the induced preference graph is exponen-
tial in the number of attributes and their domain sizes. In fact, Goldsmith et al. showed in [41]
that consistency testing and dominance testing (even for consistent preferences) are PSPACE-
complete for CP-nets, GCP-nets, and TCP-nets (even when the attributes have binary domains).
e same is true of CI-nets [17] and CP-eories [96]. Despite the fact that these languages are
very expressive and succinct in terms of the representation scheme, the hardness of the key rea-
soning tasks of consistency checking and dominance testing limits the use of the above preference
formalisms in practice.
Past work focused on identifying fragments of these languages, with corresponding restric-
tions on dependency structure of attributes (which restricts expressiveness), for which dominance
can even be computed in polynomial time [16, 34]. In the next chapter, we ﬁrst present a pref-
erence language that considers only unconditional preferences. Following that, we will turn our
focus to making dominance testing practical when such restrictions are not imposed. We will
focus on dominance testing as it is a basic building block⁷ for preference reasoning.
Speciﬁcally, we examine algorithms and techniques for answering dominance and other
preference reasoning queries using space and time that make their use feasible in practical appli-
cations. is requires the use of methods akin to what modern SAT solvers use to alleviate the
diﬃculty of solving boolean satisﬁability problems. e next chapter reviews model checking, a
technique that, given a model of a system, exhaustively and automatically checks whether the
model satisﬁes a given speciﬁcation. In the following chapters we show how preference reasoning
tasks can be formulated as model checking problems, allowing us to leverage the recent advances
in model checking to develop practical approaches to preference reasoning.
⁷All the other relationships between outcomes can be derived from dominance; for example, strict preference is one way dom-
inance, equivalence is two way dominance, and indiﬀerence corresponds to the case when neither holds.

33
C H A P T E R
3
Model Checking and
Computation Tree Logic
In Chapter 2, we discussed how preference queries for dominance and consistency can be an-
swered using the induced preference graph that captures the semantics of diﬀerent types of pref-
erence languages. We will present in Chapter 4 how the answers to these queries can be eﬀectively
computed and justiﬁed using the technique of model checking. In this chapter, we will present a
brief overview of model checking for a speciﬁc type of temporal logic: computation tree or branch-
ing tree temporal logic. We will focus on the aspects of model checking that are necessary for the
rest of the book—our presentation is, therefore, restricted to the context of this book.
• Computation-tree Temporal Logic (CTL): syntax and semantics
• Semantic model of CTL described as Kripke Structure
• Algorithm for checking whether Kripke structure is a semantic model of a given formula in
the CTL logic
• A model checking engine, NuSMV.
(Counter−example)
System (M)
Property (Φ)
Model Checker
Φ)
(M satisfies 
Yes
No
Figure 3.1: Process of model checking.
1
INTRODUCTION
Model Checking is an automated veriﬁcation technique, which relies on mathematical logic,
automata-theory, and graph algorithms to formally prove or disprove temporal properties of
(hardware or software) systems. Broadly speaking, model checking requires two inputs: a ﬁnite

34
3. MODEL CHECKING AND COMPUTATION TREE LOGIC
graph, describing the dynamics of the system under consideration, and a formula in a suitable
logic, temporal logic, describing the property to be veriﬁed. e semantics of the logical formula
is described over states or paths in a graph, i.e., given a property in such a logic, the models for
the property are graph structures. e objective of model checking is to ﬁnd whether the graph
describing the system dynamics is a model of the property and hence the name model checking.
Two important aspects that make model checking attractive for veriﬁcation purposes (besides
providing formal guarantees of correctness) are (a) automation and (b) post-mortem analysis that
brings out evidence as to how and why the provided input graph violated the property. Automa-
tion primarily stems from the fact that checking whether a ﬁnite graph representation of a system
is a model for property can be implemented eﬀectively using graph-exploration algorithms such
as depth-ﬁrst exploration and detection of strongly connected components [86]. e cause for
violation, referred to as counterexample, can be automatically generated as well—when an ex-
ploration identiﬁes the sub-graph that causes the graph being explored to not be a model of the
given property (i.e., violate the property). Such counterexamples help to identify the errors in the
system behavior or to understand whether or not the property being veriﬁed should be relaxed.
Figure 3.1 illustrates this process.
e birth of model checking in its current form is attributed to the seminal work by Clarke
and Emerson [28, 29] in 1981, and Queille and Sifakis [75] in 1982. However, work by many
others has contributed signiﬁcantly in developing the theory, the algorithms, and the implemen-
tation techniques used in model checking. For instance, the work by Pnueli on linear temporal
logic [73], the results from Tarski-Knaster ﬁxed point lemma [87], Kozen’s work on proposi-
tional mu-calculus [56], and the contributions of many in developing eﬃcient graph-exploration
and automata-theoretic techniques [12, 90], to name a few, played signiﬁcant roles in bringing
model checking (and formal veriﬁcation, in general) to the 21st century. While model checking
has inﬂuenced primarily the area of veriﬁcation of systems whose dynamics can be captured us-
ing ﬁnite graphs (even when the graphs have a very large number of states [22, 30, 60, 70]), a
number of new techniques and algorithms have been also developed, investigated, and deployed
for model checking systems (primarily software systems), whose behavior as a graph exhibits an
inﬁnite number of states (e.g., [1, 6, 8, 47–49, 74]).
In the following sections, we brieﬂy describe the basics of model checking that are relevant
in the context of this book.
2
KRIPKE STRUCTURE
Kripke structure [31] is a ﬁnite-state graph over entities and relations between entities, where
the states denote the entities and the transitions/directed edges denote the entity-to-entity re-
lationships. Such structures are often used to describe the semantics of modal logics where the
modalities express the type of relationships among entities.
In the context of model checking, Kripke structure represents the dynamics of system be-
havior over discrete time—the states correspond to the conﬁgurations of the system and the tran-

3. COMPUTATION TREE TEMPORAL LOGIC
35
Busy
0
s1
Idle
s
Figure 3.2: Kripke structure for printer.
sitions correspond to evolution of the system from one conﬁguration to another. Formally, a
Kripke structure description of a system is deﬁned as follows:
Deﬁnition 3.1 Kripke Structure.
A Kripke structure M D .S; S0; T; L/ is a ﬁnite-state graph
where S is a ﬁnite set of states, S0  S is a ﬁnite set of start states, T  S  S is a left-total tran-
sition relation such that 8s 2 S W 9s0 2 S W .s; s0/ 2 T and L W S ! P.AP / is a labeling function
that maps each state s 2 S to a subset of propositions from a set of propositions AP .
We will denote .s; s0/ 2 T as s ! s0 for all s; s0 2 S; we will call s the source state and s0
the destination of the transition. Note that in Kripke structure every state in the Kripke structure
has an outgoing transition. As a result, any path from any state in the Kripke structure can be of
inﬁnite length, where a path is described as a sequence of states such that each pair of successive
states in the sequence is related by T . For any state s 2 S, we will denote the set of all paths
starting from s as Path.s/. We will use  and  (with and without subscripts) to denote the a
path, Œ0 to denote the states from where the path starts, and Œi to denote the i-th state in the
path.
Example 3.2 Simple Printer Model
Consider the printer system described as a Kripke struc-
ture in Figure 3.2. It has two states: idle and busy. Initially, the printer is idle. e printer can
remain idle (self-loop) or can move to busy state. At the busy state, the printer can remain busy
or can move to idle state. e two states are denoted by s0 and s1, where s0 is the start state. e
label of the two states describe the “state” of the printer: L.s0/ D fidleg, L.s1/ D fbusyg. Note
that the Kripke structure of the printer is non-deterministic—the transitions from the states may
non-deterministically move the system to a diﬀerent state or to the state where it originated.
3
COMPUTATION TREE TEMPORAL LOGIC
Computation Tree Temporal Logic (CTL) [28] is a type of branching time logic which is used to
express properties of the system dynamics described as Kripke structure, taking into consideration
the branching behavior of the system; as noted before, the branching behavior comes into play due
to possible non-determinism in the Kripke structure. ese properties of interest can be viewed
as the evolution of the system starting from some state of its Kripke structure description. In the

36
3. MODEL CHECKING AND COMPUTATION TREE LOGIC
following, we present a brief overview of the syntax and semantics of the CTL followed by the
algorithms and complexity for verifying CTL properties against a given Kripke structure.
3.1
SYNTAX
e syntax of formula ' in CTL logic is described over propositional constant true, a set of
propositions AP (in propositional logic), boolean operators (e.g., ^; _; :), and a set of temporal
operators (EX; AX; EF; AF; EG; AG; EU; AU).
' ! true j AP j :' j ' ^ ' j ' _ ' j A j E 
 ! X' j F' j G' j ' U '
Intuitively, ' describes the properties over states in a Kripke structure and  denotes the properties
over paths in the Kripke structure. e property true is satisﬁed in all states of a Kripke structure.
e property over atomic propositions is satisﬁed only in the states which are labeled with the
proposition. e negation of a CTL property is satisﬁed in states which do not satisfy the CTL
property. e binary boolean operator ^ and _ have their natural semantics. e CTL property
using the temporal operators can be read as follows:
A : Along all paths
E : Exists a path
X : in neXt state
F : in Future state
G : Globally or in all states
U : Until
Note that, in a valid CTL property, the temporal operators are paired, where the ﬁrst element
in the pair is from fA; Eg and the second element is from fX; F; G; Ug. For instance, the property
AX.p/ is satisﬁed in a state s if and only if along all paths starting from s, in the next state, p is
satisﬁed. In similar fashion, the property EF.p/ is satisﬁed in a state s if and only if there exists a
path from s, in a future state, p is satisﬁed.
3.2
SEMANTICS
As indicated above, the semantics of CTL property is described over a set of states in the Kripke
structure that satisfy the property. We denote the semantics of the property ' in the context of a
Kripke structure M as ŒŒ'M. Formally, the semantics is described in Figure 3.3. For any s 2 ŒŒ'M,

3. COMPUTATION TREE TEMPORAL LOGIC
37
ŒŒtrueM D S
ŒŒpM D fs j s 2 S ^ p 2 L.s/g
ŒŒ:'M D S   ŒŒ'M
ŒŒ'1 ^ '2M D ŒŒ'1M \ ŒŒ'2M
ŒŒ'1 _ '2M D ŒŒ'1M [ ŒŒ'2M
ŒŒEX.'/M D fs j 9 2 Path.s/ W Œ1 2 ŒŒ'Mg
ŒŒAX.'/M D fs j 8 2 Path.s/ W Œ1 2 ŒŒ'Mg
ŒŒEF.'/M D fs j 9 2 Path.s/ W 9i  0 W Œi 2 ŒŒ'Mg
ŒŒAF.'/M D fs j 8 2 Path.s/ W 9i  0 W Œi 2 ŒŒ'Mg
ŒŒEG.'/M D fs j 9 2 Path.s/ W 8i  0 W Œi 2 ŒŒ'Mg
ŒŒAG.'/M D fs j 8 2 Path.s/ W 8i  0 W Œi 2 ŒŒ'Mg
ŒŒE.'1 U '2/M D fs j 9 2 Path.s/ W 9i  0 W Œi 2 ŒŒ'2M ^ 8j < i W Œj  2 ŒŒ'1Mg
ŒŒA.'1 U '2/M D fs j 8 2 Path.s/ W 9i  0 W Œi 2 ŒŒ'2M ^ 8j < i W Œj  2 ŒŒ'1Mg
Figure 3.3: Formal semantics of CTL with respect to Kripke structure M D .S; S0; T; L/.
we will also write M; s ˆ ' (in model M, the state s satisﬁes property '). (We will omit M from
the semantics-notation and satisﬁes-relation if the M is immediate from the context).
Example 3.3
Going back to Figure 3.2, the semantics of ŒŒEX.idle/ D fs0; s1g as both the
states has a path where in the next state the proposition idle is satisﬁed. On the other hand,
ŒŒAX.idle/ D ;.
Equivalences.
A number of equivalences between properties are immediate from the CTL
semantics. is paves the way for identifying an adequate set of CTL operators—the minimal set
of operators that is suﬃcient to express all possible CTL properties. For instance,
:EX.'/  AX.:'/
e proof is as follows.

38
3. MODEL CHECKING AND COMPUTATION TREE LOGIC
ŒŒ:EX.'/M
D
S   ŒŒEX.'/M
D
S   fs j 9 2 Path.s/ W Œ1 2 ŒŒ'Mg
D
fs j 8 2 Path.s/ W Œ1 2 S   ŒŒ'Mg
D
fs j 8 2 Path.s/ W Œ1 2 ŒŒ:'Mg
D
ŒŒAX.:'/M
e following equivalences hold as well. We leave the proofs as an exercise for the reader.
:EF.'/  AG.:'/
:EG.'/  AF.:'/
E.true U '/  EF.'/
A.true U '/  AF.'/
e equivalence of the negation of AU-property is more involved.
ŒŒ:A.'1 U '2/M
D
S   fs j 8 2 Path.s/ W 9i  0 W Œi 2 ŒŒ'2M ^ 8j < i W Œj  2 ŒŒ'1Mg
D
fs j 9 2 Path.s/ W 8i  0 W Œi 2 ŒŒ:'2M _ 9j < i W Œj 2 ŒŒ:'1Mg
erefore, a state s satisﬁes :A.'1 U '2/, i.e., s does not satisfy A.'1 U '2/ if and only if one of
the following holds for some path from s:
1. '2 is satisﬁed in none of the states in the path
2. '1 is not satisﬁed in all states before the ﬁrst state (in the path) that satisﬁes '2
e ﬁrst item can be expressed in CTL as EG.:'2/. e second item can be expressed in CTL as
E.:'2 U .:'1 ^ :'2//. erefore,
:A.'1 U '2/  EG.:'2/ _ E.:'2 U .:'1 ^ :'2//
Using the same logic, the negation of E.'1 U '2/ demands that along all paths from a state condi-
tion 1 or condition 2 is satisﬁed. Note that this implies in some paths condition 1 may be satisﬁed
and in some other condition 2 is satisﬁed (i.e., it is not necessary that the same condition is satis-
ﬁed in all the paths). Such a disjunctive condition over all paths from a state cannot be described
in CTL. As a result, the negation of EU-properties is not expressible in CTL using operators other
than EU.¹
Given the above equivalences, one of the adequate set of CTL operators is
f:; _; EX; EG; EUg. e temporal properties using
• AX can be expressed using : and EX
• AF can be expressed using : and EG
• AG can be expressed using : and EF
• EF can be expressed using EU
¹Formally proving the inadequacy of expressing negation of EU-properties using other CTL operators is beyond the scope of
this book. For details, the reader is referred to [5, 50].

4. MODEL CHECKING ALGORITHM
39
E(   U    )
p
p
q 
q 
p
p
E(   U    )
p
q 
p
p
EGp
EGp
EGp
EGp
p
p
p
p
EG
(a)
(b)
Figure 3.4: Illustration for the computation of the semantics for (a) E.p U q/ and (b) EG.p/.
4
MODEL CHECKING ALGORITHM
As noted before, model checking amounts to automatically verifying where the dynamic behavior
of a system conforms to a given (desired) property. More speciﬁcally, in model checking the system
behavior is described using Kripke structure and the properties of interest are expressed in the
temporal logic, such as CTL. In CTL model checking, the objective is to automatically verify
whether all start states of the Kripke structure (describing some system’s behavior) belongs to the
semantics of a given CTL property.
We consider the adequate set of CTL operators (as presented above) and present a brief
overview of the model checking algorithm for computing the semantics of CTL properties de-
scribed using the adequate set of operators. e steps of the algorithm are as follows. Given a
Kripke structure M and the CTL property ':
1. if ' D true, then the set of all states in M is returned as the result.
2. if ' D p (atomic proposition), then set of all states s in M where p 2 L.s/ is returned as
the result.
3. if ' D :'0, then the algorithm recursively computes the semantics of '0. Any state that is
not present in the semantics of '0 is returned as a result.
4. if ' D '1 _ '2, then the algorithm recursively computes the semantics of both '1 and '2.
e set of states obtained from the union of those semantics is returned as the result.
5. if ' D EX.'0/, then the algorithm computes the semantics of '0 and the set of all states,
which can reach a state in the semantics of '0 in one step, is returned as the result.

40
3. MODEL CHECKING AND COMPUTATION TREE LOGIC
6. if ' D E.'1 U '2/, then the algorithm ﬁrst computes the semantics of '2 and '1. e set
containing the states in the semantics of '2 and the ones that are in the semantics of '1 and
can reach states in the semantics of '2 is returned as the result. is computation involves
backward depth-ﬁrst exploration of M from the states in the semantics of '2.
7. if ' D EG.'0/, then the algorithm ﬁrst computes the semantics of '0 and removes all states
from M that are not the semantics. In the second step, strongly connected components over
the remaining states (say, S0) are computed. e set of all states among the S0 that can reach
these strongly connected components are returned as the result.
Figure 3.4 presents the backward exploration of Kripke structure for computing the semantics
of EU and EG-properties. e enclosed set of states at the bottom of Figure 3.4(a) satisﬁes the
proposition q, and therefore, satisﬁes the property E.p U q/. Backward exploration from this set of
states proceeds through the states that satisfy the proposition p. In case of EG.p/ (Figure 3.4(b)),
the exploration starts from the strongly connected component containing only the states that
satisfy p.
e time complexity of the model checking algorithm is O.j'j:.jSj C jT j//, where j'j de-
notes the size of the CTL property (controlling the number of recursive steps in the algorithm),
and jSj and jT j are the total number of states and transitions, respectively, in M. Each of the
algorithms can be explained as follows. e complexity of algorithm steps 1–4 is of the order
of jSj. e complexity of step 5 is jT j as it is necessary to explore all possible outgoing transi-
tions from every state in M. e complexity for each step 6 and 7 is of the order of jSj C jT j
owing to the complexity of depth-ﬁrst exploration and that of strongly connected component
computation [86].
We refer the readers to [50] and [5] for the details of CTL model checking algorithm.
5
NUSMV MODEL CHECKER
NuSMV [65], a variant of SMV [85], takes as input system behavior described as guarded state-
ments (enabled only when certain conditions expressed as a boolean formula are satisﬁed), tem-
poral properties expressed in the logic of CTL, and automatically translates the system behavior
into Kripke structure and model checks whether the start states of the structure satisfy the given
properties.
While the model checker relies on the algorithm described above for computing semantics
of CTL properties, it uses a special type of data structure to represent sets of states and transitions
in a compact, succinct, and canonical fashion. e data structure is referred to as the Binary
Decision Diagram (BDD) [2, 21], which has been eﬃciently and eﬀectively used to represent
propositional logic formulas. NuSMV (and SMV) utilizes this technique to represent sets of states
and transitions expressed as propositional logic formulas. All computations for model checking
are performed at the level of sets rather than explicitly at the level of entities (states or transitions)

5. NUSMV MODEL CHECKER
41
in a state. Such computations are referred to as symbolic or set-based and the model checker is
called “symbolic model veriﬁer.”
e technique for symbolic veriﬁcation was introduced in [22] and [60] to address specif-
ically the problem of verifying Kripke structure with very large state-space. Note that given a set
of propositions AP , the number of states in the Kripke structure can be potentially 2jAP j, i.e.,
the state-space could grow exponentially with respect to the number of the propositions. is
makes the algorithm for model checking prohibitively space ineﬃcient if every state is explicitly
saved. As labeling function maps each state to a set of propositions, a state can be described as
a conjunction of propositions that hold in that state, and the set of states can be described as a
disjunction of conjunctive formulas. It turns out that such logical representation of sets can be
compact and loss-less.
Consider for instance, a Kripke structure containing four states such that L.s0/ D
fpg; L.s1/ D fqg; L.s2/ D fp; qg; L.s3/ D ;. e set of all states can be represented by the
propositional constant true. e set fs0; s1; s2g is represented by p _ q.
A Binary Decision Diagram precisely represents propositional logic formulas. A BDD typ-
ically has one root and two leaf-nodes. e leaf-nodes are true and false nodes. Each intermediate
node (including the root) in the BDD is a propositional variable and its outgoing edges denote
its values: true or false. A path in the BDD from the root to the true leaf-node captures an as-
signment to the propositional variables for which the formula evaluates to true.
ere are two important features of BDD. First, it does not contain any redundant node. A
node is redundant if the valuation of the formula does not depend on the valuation of a variable at
that node for some truth-assignment of the other variables. Second, the BDD does not contain
any duplicate nodes. A node is duplicate of another (each corresponding to the same variable) if
their true and false edges lead to the same node in the decision diagram. e BDD with these
features is also referred to as Reduced Binary Decision Diagram.
Example 3.4
Consider the Kripke structure with four states: s0; s1; s2; s3. e transitions are
s0 ! s1; s1 ! s2; s2 ! s3; s3 ! s2. e labeling function maps the states to sets of propositions
that are satisﬁed in the states: L.s0/ D fpg; L.s1/ D fqg; L.s2/ D fp; qg; L.s3/ D ;. e propo-
sitional logic representation of this Kripke structure is as follows:
Œ.p ^ :q ^ :p0 ^ q0/ _ .:p ^ q ^ p0 ^ q0/ _ .p ^ q ^ :p0 ^ :q0/ _ .:p ^ :q ^ :p0 ^ :q0/
Each disjunct in the above formula describes a transition in the Kripke structure. For each tran-
sition, the propositions that are satisﬁed in the source-state belong to the set fp; qg, while the
propositions that are satisﬁed at the destination-state are denoted by their primed-version. For
instance, .p ^ :q ^ :p0 ^ q0/ denote the transition from a state where only p is satisﬁed to a
state where only q is satisﬁed.
Figure 3.5 illustrates the BDD representation of the transition relation. e dotted edges
from a node represent the case when the valuation of the variable at the node is considered to be
false; the solid edges correspond to the case when the variable is considered to be true. e leaf

42
3. MODEL CHECKING AND COMPUTATION TREE LOGIC
0
p
q
q
p’
p’
p’
q’
q’
1
Figure 3.5: BDD representation of transition relation for Example 3.4.
nodes indicate the value of the propositional logic formula for each assignment of the variables
(starting from the variable at the root node). For instance, if p and p0 are both true, then the
propositional logic formula evaluates to false.
In Figure 3.5, we used the ordering [p; q; p0; q0]. We leave it to the reader to draw the BDD
for the same propositional logic formula with the variable ordering [p; p0; q; q0].
e primary challenge in dealing with BDDs is in ﬁnding the order in which the variables
should be tested to obtain the most compact BDD representation of a propositional formula. e
problem, in general, is NP-complete [10]. A number of heuristics have been developed which rely
on domain-knowledge (or structure) of the propositional formula and/or on learning dynamically
the ordering of variables that is likely to result in smaller BDD [42].
Example 3.5
Consider the reduced ordered BDDs over the variables p; q; r and their primed
versions in the Figure 3.6. For clarity of the ﬁgures, only the edges leading to the “true”-valuation
(1 leaf-node) of the formula represented by the BDDs are presented.

5. NUSMV MODEL CHECKER
43
1
p
q
r
q’
q’
r’
r’
p’
p’
r’
p
1
q
q
r
r
r
r
p’
p’
p’
p’
p’
p’
p’
p’
q’
q’
q’
q’
r’
(a)
(b)
Figure 3.6: Impact of variable ordering on BDD size.
Careful observation will reveal that these two BDDs are representing the same propositional
formula, which is satisﬁable only when the valuation of the variable and their primed version are
equal (in terms of transition relation in a Kripke structure, this is a self-loop). e ordering used
in Figure 3.6(a) results in a BDD that is signiﬁcantly smaller (and less complex) compared to the
one resulting from the ordering used in Figure 3.6(b).
For details on Binary Decision Diagram and Symbolic Model Checking, please see Logic
in Computer Science [5, 50].
5.1
NUSMV LANGUAGE & COUNTEREXAMPLES
We refer the reader to review the NuSMV manual available at http://nusmv.fbk.eu/. Here we
present the basic features and constructs of the language that are necessary for explaining the
modeling strategy used in the subsequent chapters.
A NuSMV speciﬁcation of a system model consists of modules identiﬁed using the keyword
MODULE. Each module describes a process in the system and can be composed synchronously or
asynchronously. e top-level module is referred to as the main module, and every NuSMV spec-

44
3. MODEL CHECKING AND COMPUTATION TREE LOGIC
MODULE main
VAR
st: {0, 1};
-- 0: idle, 1: busy
ASSIGN
init(st) := 0;
-- initial state is 0
next(st) := case
st = 0: {0, 1}; -- if st is 0, then next value of st can be 0 or 1
st = 1: {0, 1};
TRUE : st;
-- if no other guard holds, the st value remains unchanged
esac;
SPEC---CTL specification
AX (idle)
Figure 3.7: Printer model in NuSMV.
iﬁcation must contain this module. Each module has several building blocks—each responsible
for describing certain features of the process represented by the module.
e VAR block declares the variables present in the module. In NuSMV, all variables have
ﬁnite-domain (e.g., enumerated type variables or boolean variables).
e ASSIGN block deals with initialization of the declared variables and with speciﬁcation
of how the variables can be updated for each transition in the module. e speciﬁcation of vari-
able updates are described using multiple guarded-assignments. For instance, in Figure 3.7, the
variable st is initialized to 0. e update speciﬁcations for this variable are described using three
guarded-assignments. If the value of the variable st in the current state is 0, then as a result of a
transition, the value of st in the destination state can be either 0 or 1.
It is not necessary to initialize all declared variables or to specify the updates to all declared
variables. For uninitialized variables, the model checker considers all possible initializations (as
per the variable domain) and similarly, for variables whose updates are not speciﬁed, the model
checker considers all possible value-updates.
For describing the CTL properties, NuSMV has a block SPEC. e syntax of CTL is the
same as the ones described in the previous sections. e model checker NuSMV considers all the
CTL properties described under SPEC and veriﬁes whether each one of them is satisﬁed by all
the start states of the speciﬁed model. If a property is not satisﬁed, the model checker generates
a counterexample illustrating the violation of the property.
Note that for properties of the form AG.'/, violation results in a counterexample described
as a sequence of states in the system-model ending in a state that satisﬁes :'. is is because
the counterexample must satisfy EF.:'/ (recall the equivalences between CTL properties). For
properties of the form AF.'/, violation results in a counterexample described as a sequence of
states in the system-model, where each state satisﬁes :' and the last state in the sequence has

5. NUSMV MODEL CHECKER
45
a transition back to some state in the sequence. is is because the counterexample must satisfy
EG.:'/. On the other hand, for the violation of properties EF.'/ and EG.'/ NuSMV simply
shows the start state that is responsible for the violation. is is because the counterexample
for both these types of properties are trees rooted at some start state (NuSMV developers have
decided to present one start state).


47
C H A P T E R
4
Dominance Testing via Model
Checking
We have discussed in Chapter 2 several preference languages where the basic building blocks are
conditional intra-variable preferences or CP-nets. We also saw that the complexity of dominance
testing, a fundamental preference reasoning task, is in general intractable. To cope with this hard-
ness, in this chapter we discuss how model checking can be used to compute dominance, and how
this approach is applicable to a broad class of conditional preference languages including CP-nets,
TCP-nets, CP-theories, and CI-nets.
Before we describe the model checking approach, a natural question arises—is there a re-
stricted preference language of unconditional preferences that is tractable and can be used in
place of CP-nets or TCP-nets? To address this question ﬁrst, Section 1 describes a preference
language [82] that restricts the language’s expressivity to unconditional preferences. While the
model checking approach is general and can also be used to reason about unconditional pref-
erence languages, we will see that there is merit in studying the unconditional case separately
because dominance testing can be done in polynomial time for the restricted case. Sections 2
and 3 then describe the details of the model checking approach to dominance testing.
1
DOMINANCE TESTING OF UNCONDITIONAL
PREFERENCES
We ﬁrst focus on unconditional preferences as a building block for expressing more complicated
preferences. We describe a simple preference language [82] that allows both intra-variable im-
portance preferences and relative importance preferences without conditions. We will see that
dominance testing in the language presented in the beginning of this chapter will be tractable in
polynomial time, in contrast to the languages considered so far, wherein it is intractable.
One can imagine several applications where preferences are unconditional. One example
is sustainable design [83], where a user may be interested in assessing the sustainability of al-
ternative designs of buildings, pavements, etc., that are assembled from multiple components.
Multi-attribute selection problems in engineering applications such as the selection of the best
materials for a mechanical design [3] or the selection of the best design for the construction of
pavements [79] are also candidates for application of the approach presented in this chapter.

48
4. DOMINANCE TESTING VIA MODEL CHECKING
We consider a qualitative preference language L for specifying (over a set X D fx1 : : : xng
of variables with domain Di for each xi): (a) unconditional intra-variable preferences i that are
strict partial orders (i.e., irreﬂexive and transitive relations) over Di; and (b) unconditional relative
importance preferences that are strict partial orders over X that can be used to express and reason
about preferences in settings such as the above.
1.1
SYNTAX OF L
Following the notation we introduced earlier, L includes unconditional preference statements of
the form x i x0ŒZ such that x; x0 2 Di, and fxig … Z. Here, the set Z of variables are relatively
less important than xi, i.e., xi B xj for each xj 2 Z. However, the language L does not include
statements specifying conditional relative importance. Additionally, because B is assumed to be
a binary (strict partial order) relation, jZj D 0 or 1.
We next consider several alternative semantics for the unconditional preference language
L in terms of a binary preference relation  (dominance) over alternatives, which is derived from
the input preferences {i} and B.
1.2
SEMANTICS OF L
We now specify the semantics for dominance in the language L. For the unconditional intra-
variable preferences (i for each xi) and relative importance preferences (B) speciﬁed in a pref-
erence speciﬁcation of L, we deﬁne dominance of ˛ over ˇ in terms of a ﬁrst order logic formula
parameterized by the alternatives ˛ and ˇ, and preferences i and B such that the satisﬁability of
the formula determines whether or not ˛ dominates ˇ. We denote by  the dominance relation
induced by the satisﬁability of the formula over alternatives.
We ﬁrst deﬁne a preference relation i (for each variable xi) that is derived from i, which
is necessary to give the semantics of L.
Deﬁnition 4.1
i.
8u; v 2 Di W u i v , u D v _ u i v
Note that since i is a strict partial order, i.e., irreﬂexive and transitive, it easy to show that
i is reﬂexive and transitive.
We next deﬁne the dominance between any pair of alternatives using a logic formula, for
unconditional intra-variable (i, i) and relative importance (B) preferences.
Deﬁnition 4.2 Dominance in L.
Given a preference speciﬁcation in L deﬁning intra-variable
preferences fig and relative importance preference B, and a pair of alternatives ˛ and ˇ, we say
that ˛ dominates ˇ, denoted ˛  ˇ whenever the following holds.
˛  ˇ ,
9xi W ˛.xi/ i ˇ.xi/^
8xk W .xk B xi _ xk B xi/
) ˛.xk/ k ˇ.xk/

1. DOMINANCE TESTING OF UNCONDITIONAL PREFERENCES
49
xi is called the witness of the relation.
Intuitively, this deﬁnition of dominance of ˛ over ˇ (i.e., ˛  ˇ) requires that with respect
to at least one attribute, namely the witness, ˛ is preferred to ˇ. Further, it requires that for all
attributes that are relatively more important or indiﬀerent (incomparable) with respect to relative
importance to the witness, ˛ either equals or is preferred to ˇ. In Example 4.11, ˛  ˇ, with x1
serving as the witness.
1.3
PROPERTIES OF UNCONDITIONAL DOMINANCE RELATION
We now proceed to analyze some properties of . Speciﬁcally, we would like to ensure that 
has two desirable properties of preference relations: irreﬂexivity and transitivity, which make it a
strict partial order. First, it is easy to see that  is irreﬂexive, due to the irreﬂexivity of i (since
it is a partial order).
Proposition 4.3 Irreﬂexivity of 
8˛ W ˛ 6 ˛.
e above proposition ensures that the dominance relation  is strict over compositions.
In other words, no composition is preferred over itself. Regarding transitivity, we observe that
 is not transitive when i and B are both arbitrary strict partial orders, as illustrated by the
following example.
Example 4.4
Let X D fx1; x2; x3; x4g, and for each xi 2 X W Di D fai; big with ai i bi.
Suppose that x1 B x3 and x2 B x4. Let ˛ D ha1; a2; b3; b4i, ˇ D hb1; a2; a3; b4i and  D
hb1; b2; a3; a4i. Clearly, we have ˛  ˇ (with x1 as witness), ˇ   (with x2 as witness), but
there is no witness for ˛  , i.e., ˛ 6  according to Deﬁnition 4.2.
Because transitivity of preference is a necessary condition for rational choice [39, 62], we
proceed to investigate the possibility of obtaining such a dominance relation by restricting B. In
particular, we ﬁnd that  is transitive when B is restricted to a special family of strict partial
orders, namely interval orders as deﬁned below.
Deﬁnition 4.5
Interval Order.
A binary relation R  X  X is an interval order iﬀit is ir-
reﬂexive and satisﬁes the ferrers axiom [37]: for all xi; xj ; xk; xl 2 X, we have:
.xi R xj ^ xk R xl/ ) .xi R xl _ xk R xj /
Restricting  to an interval order is necessary and suﬃcient for the transitivity of  as
stated below, which was proved in [84].
eorem 4.6
 is a strict partial order when intra-attribute preferences i are arbitrary strict
partial orders and relative importance B is an interval order.
e above theorem applies to all partially ordered intra-variable preferences and a wide
range of relative importance preferences including total orders, weak orders, and semi orders [37]
which are all interval orders. Having seen in Example 4.4 that the transitivity of  does not

50
4. DOMINANCE TESTING VIA MODEL CHECKING
Figure 4.1: A 2 ˚ 2 substructure, not an interval order.
necessarily hold when B is an arbitrary partial order, a natural question that arises here is whether
there is a condition weaker than the interval order restriction on B that still makes  transitive.
e answer turns out to be negative, which we show next. We make use of a characterization
of interval orders by Fishburn in [37], which states that B is an interval order if and only if
2 ˚ 2 ªB, where 2 ˚ 2 is a relational structure shown in Figure 4.1. In other words, B is an
interval order if and only if it has no subrelation whose structure is isomorphic to the partial order
structure shown in Figure 4.1.
eorem 4.7
For arbitrary partially ordered intra-attribute preferences  is transitive only if rel-
ative importance B is an interval order.
Proof. Assume that B is not an interval order. is is true if and only if 2 ˚ 2 B. However, we
showed in Example 4.4 that in such a case  is not transitive. Hence,  is transitive only if
relative importance B is an interval order.

e preceding theorem holds for a wide range of relative importance preferences, including
total orders, weak orders, and semi orders [37] which are all interval orders. Hence the language
L can be used for decision making in these settings.
1.4
COMPLEXITY OF DOMINANCE TESTING IN L
Dominance testing in L amounts to evaluating the satisﬁability of the quantiﬁed boolean formula
corresponding to ˛  ˇ (see Deﬁnition 4.2). is can be done in O
 m2.m4 C n4/
 time, where
m D jX j is number of variables and n D maxxi2XjDij is size of the domains of variables. is
is clearly polynomial time, and hence it makes L a useful alternative in settings where runtime
complexity is important, and where the preferences can be stated unconditionally.
1.5
EXPRESSIVENESS
We now compare the expressiveness of L to that of some CP-languages we have introduced
earlier. We use L‹ where ‹ corresponds to the language we want to compare L against, namely
CP (CP-nets), T CP (TCP-nets), CP T h (CP-theory), CI (CI-net). We make the following
observations:
• L is neither more expressive nor less expressive compared to LCP . L allows the expression
of relative importance while LCP does not; and LCP allows the expression of conditional
intra-variable preferences while L does not.

1. DOMINANCE TESTING OF UNCONDITIONAL PREFERENCES
51
• L is less expressive than LT CP because it does not allow the expression of conditional intra-
variable preferences and relative importance.
• When LT CP is restricted to unconditional intra-variable and unconditional relative impor-
tance preferences, its expressiveness is the same as that of L.
• LCP T h is more expressive than LCP and LT CP [93, 94], and therefore is more expressive
than L as well.
• LCI is neither more nor less expressive than L because the former can express relative im-
portance among sets of attributes (which the latter cannot) and the latter can express any
arbitrary intra-attribute preference relation over its variables (which the former cannot).
Comparing L with CP-eories
We will ﬁrst investigate the relationship between L and CP-theories, as some information about
the relationship between L and TCP-nets can be inferred from this. Santhanam et al. [82] showed
that the semantics of L is subsumed by the semantics of the CP-theories formalism.
eorem 4.8
e preference semantics of L is subsumed by the preference semantics of CP-theories,
i.e.,   .
e above establishes that  is included in . To determine whether the other side of
inclusion holds, we consider the following example.
Example 4.9
Consider again the example preferences from Example 4.4, where ˛ D
ha1; a2; b3; b4i, ˇ D hb1; a2; a3; b4i, and  D hb1; b2; a3; a4i with ˛  ˇ (with x1 as witness),
ˇ   (with x2 as witness), but ˛ 6  according to Deﬁnition 4.2. However, there exists a
sequence of improving ﬂips from  to ˛, namely , ˇ, ˛; hence ˛  .
e above example shows that    does not hold in general. However, observe that 
holds for each consecutive pair of alternatives in the swapping sequence. Hence, since  is tran-
sitive, it must be possible to show that   . e following result was proved by Santhanam
et al. [82] using eorem 4.6, which relates the interval order property of B to the transitivity of
.
eorem 4.10
e preference semantics of CP-theories are subsumed by the preference semantics of
L, i.e.,   , whenever the relative importance preference relation B is an interval order.
Comparing L with TCP-nets
We now investigate the relationship between ı and . In Example 4.4, , ˇ, ˛ forms an im-
proving ﬂipping sequence from  to ˛, resulting in ˛ ı . However, ˛ 6 . Since  holds for
each pair of consecutive alternatives in a ﬂipping sequence supporting a dominance ˛ ı ˇ, we

52
4. DOMINANCE TESTING VIA MODEL CHECKING
have ı when  is transitive. e other side of the inclusion is negated by Example 4.11,
where ˛  ˇ but ˛ 6ı ˇ.
Example 4.11
Let X D fX; Y; Zg and DX D fx1; x2g; DY D fy1; y2g; DZ D fz1; z2g. Sup-
pose that the intra-variable preferences are given by x1 X x2; y1 Y y2, and z1 Z z2, and the
relative importance among the variables is given by X B Y and X B Z. Given two alternatives
˛ D hx1; y2; z2i and ˇ D hx2; y1; z1i, there is no improving ﬂipping sequence from ˛ to ˇ or
vice versa with respect to TCP-net semantics. erefore, ˛ 6ı ˇ and ˇ 6ı ˛.
is shows that neither of the preference semantics of TCP-nets or L subsumes the other
in general; however when relative importance is an interval order, the preference semantics of
TCP-nets subsumes the preference semantics of L.
We so far described preference language L where all intra-variable and relative importance
preferences are unconditional, whose semantics for dominance is in the form of the satisfaction
of a quantiﬁed boolean formula (QBF). e complexity of checking whether a QBF formula is
satisﬁable can be done in polynomial time, which makes L a useful and tractable approximation
for the preference semantics of TCP-nets and CP-theories earlier discussed according to ceteris
paribus semantics introduced in Chapter 2. L is useful in several engineering applications such as
materials design [3], sustainable building design [83], and pavement engineering [79].
2
PREFERENCE REASONING VIA MODEL CHECKING
We now turn to the more general case of conditional preference languages. Recall from Chap-
ter 2 (see Deﬁnition 2.21) that an alternative ˛ dominates another alternative ˇ with respect to
preference speciﬁcation P if and only if the node corresponding to ˛ in the preference graph ı.P /
induced by P is reachable from the node corresponding to ˇ. at is, dominance can be decided
by performing reachability analysis of ı.P /. If the preference speciﬁcation P is consistent, then
the corresponding ı.P / is guaranteed to be acyclic because it represents an irreﬂexive and transi-
tive dominance relation on the set of outcomes. For the rest of the discussion in this chapter, we
will assume P to be consistent to make things simple to explain and understand, although the
same technique presented here will also work for dominance testing with inconsistent preferences.
As dominance can be decided via reachability analysis over (induced preference) graph, it
becomes a perfect candidate application for model checking tools such as NuSMV (see Chap-
ter 3). First, the interpretation of preference statements in the ceteris paribus languages or prefer-
ence semantics in the form of induced preference graph can be neatly represented using Kripke
structures [56] (for details see Chapter 3). Secondly, this encoding can be done without having to
construct the induced preference graph explicitly, because the set of (possibly exponential) ﬂips
induced by a preference statement can be succinctly and implicitly encoded in terms of change of
values of (state-)variables in the Kripke structure. irdly, as we will see, preference queries like
dominance testing, which can be cast as reachability testing on the induced preference graph, can
be easily translated into veriﬁable properties in a temporal logic language. Fourthly, we can take

2. PREFERENCE REASONING VIA MODEL CHECKING
53
advantage of existing algorithms and tools for verifying temporal properties of models to answer
preference queries like dominance. Finally, the model checker provides counterexamples to tem-
poral properties that are not veriﬁed, which gives us evidence from the preference semantics to
justify the answer. In this chapter, we will see all of the above aspects of model checking used in
preference reasoning.
e model checking approach for dominance testing we are about to describe involves
addressing two questions:
1. How to encode the preference statements as an input speciﬁcation of a system in a model
checker (we use NuSMV [26]) such that dynamics/evolution of the system (i.e., the Kripke
structure) explored by the model checker corresponds to the preference graph (ı.P /) in-
duced by the preference statements?
2. How to express a query regarding the dominance of an alternative (˛) with respect to another
(ˇ) in the form of a test of reachability of ˛ from ˇ in the Kripke structure corresponding
to the induced preference graph?
We encode the preference speciﬁcation P as the transition relations of a system speciﬁcation to
generate the Kripke model KP corresponding to ı.P / as follows. e preference variables of the
preference speciﬁcation P are mapped to the state variables of the KP in a model checker. e
improving ﬂips (see Deﬁnition 2.21, Chapter 2) are directly encoded as transition relations in
KP (in the language of the model checker). is ensures that the state space of the model KP
explored by the model checker corresponds to ı.P /.
Dominance queries over P are then encoded as temporal logic properties in Computation
Tree temporal logic (CTL; see Section 3 in Chapter 3) over the state space of the model KP . is
allows us to take advantage of all the specialized data structures (e.g., Binary Decision Diagrams
[21]) and algorithms available in the model checking engine to eﬃciently verify the satisﬁability
of the temporal logic properties (over temporal operator such as EF) on KP and as a result verify
dominance of outcomes in the corresponding induced preference graph ı.P /.
2.1
KRIPKE STRUCTURE ENCODING OF INDUCED PREFERENCE
GRAPH
Given a preference speciﬁcation P , the induced preference graph ı.P / is ﬁrst encoded as a Kripke
structure K.P / (see Section 2 in Chapter 3) which is the standard input model understood by
symbolic model checkers such as NuSMV and Cadence SMV.
e state space of K.P / is speciﬁed using the valuations of the set of preference variables,
namely X; we will often refer to them as state variables of the Kripke structure as each state s 2 S
in K.P / is deﬁned by a unique assignment to X. We will use sub/super-scripted versions of s
to represent speciﬁc states in K.P / and denote the valuation of xi 2 X in state s by s.xi/. e
central theme in our encoding of preference P as a Kripke structure K.P / relies on the following
two mappings between ı.P / to K.P /. First, for each node  2 A in ı.P / D G.A; E/, there is a

54
4. DOMINANCE TESTING VIA MODEL CHECKING
corresponding state s 2 S in K.P / such that for all preference variables xi 2 X, .xi/ D s.xi/.
us there are a total jSj D jAj D 2jXj number of states in ı.P / and K.P /. Second, the transition
relation T in K.P / is such that paths in K.P / correspond to paths in ı.P /.
Recall from the syntax and semantics of various preference languages (Chapter 2) that for
each preference statement p in P where the preference over a variable xi is speciﬁed, whether or
not p induces a ﬂip from one outcome (node in ı.P /) to another in ı.P / is constrained by sets
of conditions that ensure:
(a) valuations of xi in the source node is worse than that in the destination node (improving
ﬂip);
(b) valuations of parent variables of xi (variables on whose values the improvement of xi as per
p depends) in the source and destination nodes equal their valuations in p; and
(c) all variables other than xi and those that are less important than xi remain unchanged in
the destination node, according to the ceteris paribus principle.
Analogous to the deﬁnition of ﬂips in ı.P /, we deﬁne transitions between two states in
K.P / in terms of enabling conditions on the state variables xi in source and destination states.
According to the semantics of the input language of the model checker NuSMV, by default all
the state variables in the model are allowed to change non-deterministically, unless explicitly con-
strained by a guard condition. Hence, to be able to restrict transitions other than those satisfying
the above conditions, we use another set H of auxiliary variables his (corresponding to the xis)
to label the transitions between states:
hi D
8
ˆˆ<
ˆˆ:
0
)
value of xi must not change in a
transition in the Kripke structure K.P /
1
)
otherwise
.1/
In the above deﬁnition, the valuation hi D 0 on a transition restricts xi from changing in
the transition; and the valuation hi D 1 allows xi to (possibly) change in the transition. Hence,
by setting auxiliary variables H to a combination of values, we can specify guard conditions for xi
such that the transitions allowed in K.P / between states s and s0 (that correspond to nodes 
and 0 in ı.P /) are those that precisely correspond to the edges in ı.P / between  and 0.
Translating Preference Statements to Guard Conditions. Given a preference statement p in
a speciﬁcation P , we show how to generate the set of guards that deﬁne transition relations in
K.P / corresponding to the (improving) ﬂips in ı.P /. e guard condition G.p/ will consist of two
parts: (a) a constraint Allow.p/ on the assignment of X (including any conditional dependency
constraint % mentioned in p) that must be satisﬁed in the current state for any outgoing transition
induced by p;¹ and (b) a constraint Restrict.p/ on H (in the current state) which speciﬁes (by the
¹We say “transition induced by p” to refer a transition that corresponds to an improving ﬂip induced by p.

2. PREFERENCE REASONING VIA MODEL CHECKING
55
semantics above) which of the xjs must not change in a transition induced by p. In the following,
we deﬁne Allow.p/ and Restrict.p/ for the various types of preference statements.
i. Guards for Statements of Intra-attribute Preference.
For each preference statement p of
the form % W xi D vi xi xi D v0
i in a CP-net (see syntax of CP-nets in Section 2.3 of
Chapter 2), the guard condition with respect to p is as follows.
Allow.p/
WD
% ^ xi D v0
i ^ hi D 1
Restrict.p/
WD
V
xj 2Xnfxig hj D 0
In the above, as per Allow.p/, xi can change in any outgoing transition from the current
state in K.P / (hi D 1 in the current state) whenever the condition % in p is satisﬁed and the
valuation of xi has a less preferred valuation according to p in the current state (xi D v0
i).
All other variables xj remain unchanged in any such transition from the current state as per
Restrict.p/.
Example 4.12
Consider the cyberdefense CP-net example in Section 2.3, the preference
statement p2, i.e.,
true W A D Low A A D High
induces four improving ﬂips from ˛ to ˇ, i.e., whenever ˛.A/ D High, ˇ.A/ D Low,
˛.E/ D ˇ.E/, and ˛.F / D ˇ.F /. Note that here % D true because the preference is un-
conditional, i.e., it holds always, as long as the ceteris paribus condition on other variables
holds.
is is succinctly encoded as a guard within NuSMV’s input modeling language; Figure 4.2
shows part of a NuSMV model that encodes this preference statement. Note that the pref-
erence variables lower cased and auxiliary variables are named ha instead of ha etc. so as to
abide by NuSMV variable naming conventions. More information on the NuSMV model-
ing language constructs used is detailed later in the chapter.
next(a) :=
case
a=High & ha=1 & he=0 & hf=0 : Low;
TRUE : a;
esac;
Figure 4.2: Encoding of guard for intravariable preference p2 in CP-net P CP in the input language
of NuSMV model checker.
Similarly, Figure 4.3 shows the encoding of guard in NuSMV for p3 in P CP

56
4. DOMINANCE TESTING VIA MODEL CHECKING
E D Code-Available W F D Fix-Unavailable F F D Fix-Available
which is a preference on F conditioned on the value of E.
next(f) :=
case
e=Code-Available & f=Fix-Available & ha=0 & he=0 & hf=1 : Fix-Unavailable;
TRUE : f;
esac;
Figure 4.3: Encoding of guard for intravariable preference p3 in CP-net P CP in the input language
of NuSMV model checker.
ii. Guards for Statements of Relative Importance of an Attribute over a Set of Attributes.
Let p be a preference statement in a CP-theory of the form % W xi D vi fxig xi D v0
i Œ˝,
where % D .xi/. e set ˝ of variables that are relatively less important than xi (as per p)
must be allowed to take any value or change unrestrictedly simultaneously in any transition
where xi ﬂips to an improving valuation. In order to enable the simultaneous change in the
values of xi and each xj 2 ˝ in the same transition, we specify appropriate guard conditions
based on the valuations of the variable xi and that of each of the variables in the set ˝ as
follows.
Allow.p/
WD
% ^ xi D v0
i ^ hi D 1 ^
 V
xj 2˝ hj D 1

Restrict.p/
WD
V
xk2Xnfxign˝ hk D 0
In the above,
 V
xj 2˝ hj D 1

is the additional term from the previous case (for intra-
variable preference), which allows all variables less important than xi to be changed to any
value as long as the value of variable xi can be improved. is models relative importance
of xi over xj for all xj 2 ˝. e above guard conditions also give the guard condition for a
TCP-net preference statement, as TCP-nets are a special case of CP-theories with j˝j  1.
Example 4.13
Consider in the cyberdefense TCP-net P T CP (see Section 2.4) the pref-
erence statement p0
2, that expressed the relative importance of A over E in addition to the
intra-variable preference over A as in P CP .
true W A D Low A A D High ŒfEg
As p0
2 speciﬁes relative importance of A over E, it induces additional improving ﬂips from ˛
to ˇ whenever ˛.A/ D High, ˇ.A/ D Low, and ˛.F / D ˇ.F /, without requiring ˛.E/ D

2. PREFERENCE REASONING VIA MODEL CHECKING
57
ˇ.E/. Compare this with the preference statement p2 (see Section 2.3), which does not
have any relative importance constraint. Both p2 and p0
2 are unconditional preference; as a
result % D true. Figure 4.4 shows part of a NuSMV model that encodes p0
2 (compare this
with the encoding of p2 in Figure 4.2). e guards for the change in the values of e involving
ha=1 & hb=1 enable the ﬂips to be induced in ı.P T CP / due to p0
2. Note that, in addition
to the guarded transitions for e that correspond to modeling p0
2, there can be other guarded
transitions for e. For instance, the preference statement p1 (see Section 2.3) describes intra-
variable preference over the preference variable E, which will result in a guarded transition
in NuSMV:
next(e) :=
case
...
e=Code-Unavailable & ha=0 & he=1 & hf=0 : Code-Available;
-- intravariable preference.
...
esac;
next(a) :=
case
a=High & ha=1 & he=1 & hf=0 : Low; -- intravariable preference.
TRUE : a;
esac;
next(e) :=
case
a=High & ha=1 & he=1 & hf=0 : {Code-Available,Code-Unavailable};
-- relative
importance.
...
TRUE : e;
esac;
Figure 4.4: Encoding of guard for relative importance preference p0
2 in TCP-net P T CP in the input
language of NuSMV model checker.
iii. Guards for Statements of Relative Importance over Arbitrary Sets of Attributes. e improving
ﬂip induced by a preference statement p of the form ˚C; ˚  W 	1  	2 will ensure all
variables in the set 	1 are improved and those in 	2 are worsened (according to the CI-net
semantics, this amounts to trading oﬀelements in 	2 for those in 	1) in a transition, while
all other variables remain unchanged.
Let % D .V
xi2˚C xi D 1/ ^ .V
xj 2˚  xj D 0).

58
4. DOMINANCE TESTING VIA MODEL CHECKING
Allow.p/
WD
% ^ .V
xi2	1 xi D 0/ ^ .V
xj 2	2 xj D 1/
^ .V
xk2	i[	2 hk D 1/
Restrict.p/
WD
V
xj 2Xn.	1[	2/ hj D 0
e SMV model encoding the above guard conditions will follow a similar style to the CP-
net and TCP-net example given previously. We leave it as an exercise to the reader to apply
the above rules for the CI-net example in Example 2.5.
e Transition Relation of K.P /. Given a preference statement p in any of the ceteris paribus
languages, the guard condition that constrains changes to the valuation of preference variables in
any state in K.P / is given by G.p/ D Allow.p/ ^ Restrict.p/. A state s 2 S in K.P / is said
to satisfy the guard condition G.p/, denoted s ˆ G.p/, if and only if it respects the constraints
on all the xi’s and hi’s imposed by G.p/; and this implies the possibility of existence of outgoing
transitions from s corresponding to improving ﬂips in ı.P / induced by p. K.P /’s transitions are
modeled as a composition of all the guard conditions induced by the corresponding preference
statements of P .
e overall transition relation T of K.P / is speciﬁed as the union of the transitions² induced
by all the preference statements in P .
Figures 4.5, 4.6, and 4.7 show the Kripke structures K.P CP /, K.P T CP /, and K.P CP T h/
constructed from the CP-net P CP (see Section 2.3 and Figure 2.2) and TCP-net P T CP (see
Section 2.4, Figure 2.3) and CP-theory P CP T h (see Section 2.5 and Figure 2.4), respectively,
according to the above encoding.
e states are annotated with the values of the preference (or state) variables in the Kripke
structure. e transitions are annotated with the values of the boolean variables in H, denoting
which state variables must remain unchanged and which ones may change due to the transition.
e model checker non-deterministically sets the value of variables in H; as a result each state has
2jHj (corresponding to all possible combinations of values for variables in H) outgoing transitions
(in our example, jHj D 3). Note that some combinations of these values do not satisfy the guard
conditions corresponding to improving ﬂip; for those combinations of values of variables in H, the
transitions result in self-loops. For clariﬁcation of the diagrams, we have omitted the self-loops.
2.2
CORRECTNESS OF THE CONSTRUCTION OF K.P /
Note that the semantics of each preference statement in P is directly encoded as a set of guarded
transitions in K.P /. If there is a valid ﬂip from  to 0 in ı.P /, then there is a transition from
a corresponding state s to another state s0 in K.P /. In other words, the guard conditions enable
only the transitions in K.P / that correspond to valid ﬂips in ı.P /. Hence, the correctness of the
construction of K.P / with respect to modeling the induced preference graph ı.P / can be proved
²Note that a state s in K.P / may also contain transitions to itself (self-transitions) because hi D 1 does not necessarily imply
that xi will change; rather, it allows non-deterministic choice for the valuation of xi.

2. PREFERENCE REASONING VIA MODEL CHECKING
59
Code-Available, Low, Fix-Unavailable
Code-Available, Low, Fix-Available
Code-Available, High, Fix-Available
Code-Available, High, Fix-Unavailable
Code-Unavailable, Low, Fix-Unavailable
Code-Unavailable, Low, Fix-Available
Code-Unavailable, High, Fix-Available
Code-Unavailable, High, Fix-Unavailable
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
Figure 4.5: K.P CP /: Kripke structure encoding the semantics of P CP .
Code-Available, Low, Fix-Unavailable
Code-Available, Low, Fix-Available
Code-Available, High, Fix-Available
Code-Available, High, Fix-Unavailable
Code-Unavailable, Low, Fix-Unavailable
Code-Unavailable, Low, Fix-Available
Code-Unavailable, High, Fix-Available
Code-Unavailable, High, Fix-Unavailable
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
Figure 4.6: K.P T CP /: Kripke structure encoding the semantics of P T CP .

60
4. DOMINANCE TESTING VIA MODEL CHECKING
Code-Available, Low, Fix-Unavailable
Code-Available, Low, Fix-Available
Code-Available, High, Fix-Available
Code-Available, High, Fix-Unavailable
Code-Unavailable, Low, Fix-Unavailable
Code-Unavailable, Low, Fix-Available
Code-Unavailable, High, Fix-Available
Code-Unavailable, High, Fix-Unavailable
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
F
A
E
h
h
h
Figure 4.7: K.P CP T h/: Kripke structure encoding the semantics of P CP T h.
by the construction outlined so far or by contradiction. We simply formally state the main result
and leave the proof to be veriﬁed by the reader.
Dominance testing with respect to P is equivalent to reachability over ı.P /, i.e., 0  
with respect to P if and only if there is a path from  to 0 in ı.P / (see Deﬁnition 2.16). erefore,
to prove the correctness of the construction of K.P /, we show that there is a path (ﬂipping
sequence) from  to 0 in ı.P / if and only if there is a corresponding sequence of transitions
from a state s 2 S to a state s0 2 S0 in K.P /. is will ensure that the state space explored by
the model checker when given K.P / as input corresponds to ı.P /.
Let 
p ! 0 denote that p induces a ﬂip from  to 0, s ! s0 denote that a transition exists
from state s to a state s0 in K.P /, and s
? ! s0 denote that a sequence of transitions exists in K.P /
from s to s0.
eorem 4.14
(Correctness of Kripke Encoding) Let P D fp1; p2 : : :g be a preference speciﬁca-
tion over an outcome space O, and the corresponding Kripke structure K.P / D hS; S0; T; Li resulting
from the above encoding. en
81; 2 : : : n 2 O W

8i 2 Œ1; n   1 W i ¤ iC1

^

1
p1
 ! 2
p2
 ! : : :
pn 1
   ! n

,

9s1; s2; : : : sn 2 S W

8j W sj 2 Sj

^

s1
? ! s2
? ! : : :
? ! sn


3. ANSWERING DOMINANCE QUERIES VIA MODEL CHECKING
61
e above theorem implies that the induced preference graph ı.P / and K.P / are equivalent
with respect to reachability between any pair of distinct outcomes, i.e., they model the same set of
paths between all pairs of outcomes. e next question is then how does one use K.P / to answer
dominance (reachability) with respect to P without constructing ı.P /.
3
ANSWERING DOMINANCE QUERIES VIA MODEL
CHECKING
We have presented the encoding of preference statements as guarded transition relations in
NuSMV model checker. e complete listings of the Kripke structure encodings for some of
the example CP-nets, TCP-nets, CP-theories, and CI-nets are available in the Appendix A. We
now proceed to show how dominance queries with respect to a given preference speciﬁcation can
be described as temporal queries in the CTL Logic (see Chapter 3).
3.1
VERIFYING DOMINANCE
Given a Kripke structure K.P / that encodes the induced preference graph of a preference speci-
ﬁcation P , determining whether ˛ dominates ˇ with respect to P amounts to verifying whether
the states in K.P / corresponding ˇ can reach the states corresponding to ˛. e CTL property
that describes this reachability pattern is
'ˇ ! EF'˛
e formula '˛ and 'ˇ denote the conjunction of valuation of (preference) variables that are true
in the outcome ˛ and ˇ, respectively. erefore, the Kripke structure states, corresponding to ˛
and ˇ, satisfy '˛ and 'ˇ, respectively.
A state in the Kripke structure K.P / is said to satisfy the above formula if and only if
when the state satisﬁes 'ˇ (i.e., valuations of variables of X in that state correspond to those
in ˇ), there exists a path or a sequence of transitions sˇ D s1 ! s2 !    ! sn D s˛ (where
8xi 2 X W s˛.xi/ D ˛.xi/ and sˇ.xi/ D ˇ.xi/) such that n > 1. In short, a state in the Kripke
structure K.P / corresponding to ı.P / satisﬁes the above CTL formula if and only if ˛ dominates
ˇ with respect to P (eorem 4.14). We use the model checker NuSMV to verify the satisﬁability
of a CTL formula 'ˇ ! EF'˛.
Example 4.15
For the TCP-net P T CP
in Figure 2.1(b), the dominance of ˛ D
hCode-Unavailable, Low, Fix-Unavailablei
over
ˇ D hCode-Available, High, Fix-Availablei
corresponds to the satisﬁability of the CTL formula
' W .A D High ^ E D Code-Available ^ F D Fix-Available/ !
EF.A D Low ^ E D Code-Unavailable ^ F D Fix-Unavailable//:

62
4. DOMINANCE TESTING VIA MODEL CHECKING
Note that NuSMV asserts that a formula ' is veriﬁed only if every initial state satisﬁes '.
erefore, we initialize xi to ˛.xi/ for xi 2 fA; E; F g to restrict the start states to those corre-
sponding to the outcome ˛ in the encoded Kripke structure. We also initialize all the change
variables hi to 0, so that transitions corresponding to all possible improving ﬂips from ˛ in the
Kripke model are explored by the model checker non-deterministically.
In NuSMV, the satisﬁability of ' can be veriﬁed by the speciﬁcation SPEC ', and the
veriﬁcation returns ‘true’ in our example, thereby establishing that the dominance holds.
3.2
EXTRACTING A PROOF OF DOMINANCE
We can use the NuSMV model checker to obtain a proof that an alternative ˛ dominates another
alternative ˇ (i.e., an improving ﬂipping sequence from ˇ to ˛ exists) as follows. Suppose ˛ domi-
nates ˇ. is implies that the CTL formula % W 'ˇ ! EF'˛ holds, where 'ˇ and '˛ correspond to
the boolean formulas encoding the respective outcomes ˇ and ˛. Hence, in this case if we provide
the formula :% (i.e., :.'ˇ ! EF'˛/) as input to the model checker, the model checker will return
‘false’, and provide us with the sequence of states (as below) corresponding to the improving
ﬂipping sequence from ˇ to ˛. In our example, ˛ D hCode-Unavailable, Low, Fix-Unavailablei
dominates ˇ D hCode-Available, High, Fix-Availablei.
As a result, for the property expressed using the following
SPEC :.A D High ^ E D Code-Available ^ F D Fix-Available/ !
EF.A D Low ^ E D Code-Unavailable ^ F D Fix-Unavailable/
NuSMV returns the sequence of outcomes
hCode-Available, High, Fix-Availablei !
hCode-Available, High, Fix-Unavailablei !
hCode-Unavailable, Low, Fix-Unavailablei
as shown in Figure 4.8, which is a proof, i.e., improving ﬂipping sequence verifying the domi-
nance.
Figure 4.8 shows the output from the NuSMV model checker for the above CTL query.
Observe that the transition from state 1:1 to 1:2 is eﬀected by the semantics of the preference
statement p3; and that from state 1:2 to 1:3 is eﬀected by the semantics of the preference statement
p0
2.
e same approach as described above can be used to answer dominance queries for any of
the ceteris paribus preference languages such as CP-nets, CI-nets, and CP-theories. e sample
SMV models, CTL formulas for dominance queries, and the corresponding NuSMV output
traces are provided in Appendix A. An interested reader will see all the techniques discussed in
this chapter applied in those listings.

3. ANSWERING DOMINANCE QUERIES VIA MODEL CHECKING
63
-- specification
(
(
(a = High & e = Code-Available) & f = Fix-Available)
-> ! (EX (EF ((a = Low & e = Code-Unavailable) & f = Fix-Unavailable))
)
)
is false
-- as demonstrated by the following execution sequence
Trace Description: CTL Counterexample
Trace Type: Counterexample.
-> State: 1.1 <-
f = Fix-Available
a = High
e = Code-Available
start = TRUE
-> Input: 1.2 <-
ha = 0
he = 0
hf = 1
-> State: 1.2 <-
f = Fix-Unavailable
-> Input: 1.3 <-
ha = 1
he = 1
hf = 0
-> State: 1.3 <-
a = Low
e = Code-Unavailable
Figure 4.8: Output from NuSMV model checker on querying the Kripke model with the CTL for-
mula for the negation of dominance.
3.3
SUMMARY AND DISCUSSION
We have described the ﬁrst practical solution to the problem of determining whether an alterna-
tive dominates another with respect to a set of qualitative preferences. Our approach relies on a
reduction of the dominance testing problem to reachability analysis in a graph of alternatives. We
have provided an encoding of CP-nets, TCP-nets, and other languages in the form of a Kripke
structure for CTL.
We have shown how to: (a) directly and succinctly encode preference semantics as a Kripke
structure; (b) compute dominance by verifying CTL temporal properties against this Kripke struc-
ture; and (c) generate a proof of dominance. We have shown how to compute dominance using

64
4. DOMINANCE TESTING VIA MODEL CHECKING
NuSMV, a model checker for CTL. is approach to dominance testing via model checking
allows us to take advantage of continuing advances in model-checking.
Although our examples focused on TCP-nets, our approach can be applied to any prefer-
ence language for which the semantics is given in terms of the satisﬁability of graph properties
(including preference speciﬁcations that induce cyclic preferences). e presented approach can
be extended for other reasoning tasks such as ﬁnding whether a given alternative is the least (or
most) preferred among all the alternatives.
Although we have used the NuSMV model checker in this chapter, any model checker
that accepts a Kripke structure as input can be used to realize our approach to dominance testing.
Hence, it should be possible to take advantage of specialized techniques that have recently been
developed to improve the performance of model checkers [9, 25, 33, 53, 92].

65
C H A P T E R
5
Verifying Preference
Equivalence and Subsumption
In the previous chapter, we presented an encoding of preference semantics (induced preference
graph) as a system speciﬁcation and have discussed the use of model checking to test whether
one alternative dominates another with respect to a given set of preferences. In this chapter we
consider the problem of determining whether one set of preference statements is equivalent to
another or whether one set of preferences subsumes another. Preference equivalence and preference
subsumption testing ﬁnd application in determining the substitutability of preference proﬁles
[46] and in stable matching problems [43]. Other potential applications include matching or
ﬁnding users with similar preferences in recommender systems [88] and checking (dis)agreement
of preferences of a set of agents in group decision making [77].
We will extend the encoding strategy presented in the previous chapter and show how
model checking can be used to determine preference equivalence and subsumption in this chapter.
Our approach can be summarized as follows. Given the objective of verifying the preference
equivalence between the preference speciﬁcations P and P 0, in order to ensure that a dominance
is satisﬁed in P if and only if it is satisﬁed in P 0, we encode P and the inverse¹ of P 0 as one
Kripke structure. en we model check this Kripke structure against a CTL property which
essentially states that if a state s (i.e., an outcome) can reach s0 using the transitions resulting from
P then s0 can reach s as per P 0, and vice versa. Being based on model checking, the technique has
two primary advantages. First, for the preferences that are not equivalent, the counterexamples
generated by model checker as a result of violation of CTL property can directly present the
proof of non-equivalence; the proof includes some dominance relation satisﬁed in one preference
speciﬁcation and not in the other. Second, the encoding does not require that the preferences,
whose equivalence is to be veriﬁed, are expressed in the same language.
Because things get too complicated with modeling two sets of preferences in one data struc-
ture, we pick two simple CP-nets as running examples to discuss our approach to preference
equivalence testing and preference subsumption testing, instead of the examples introduced in
the ﬁrst chapter. We provide worked out examples of this approach for the cyberdefense exam-
ple introduced in Chapter 1 in an appendix. We note that while the running examples in this
chapter are simple CP-nets, the approach presented here is applicable TCP-nets, CI-nets, and
CP-theories as well.
¹˛ dominates ˇ in P 0 if and only if ˇ dominates ˛ in the inverse of P 0.

66
5. VERIFYING PREFERENCE EQUIVALENCE AND SUBSUMPTION
(a) CP-net P1
(b) Induced Preference Graph
ı.P1/
Figure 5.1: Example preference speciﬁcation: CP-net P1.
1
PREFERENCE EQUIVALENCE AND PREFERENCE
SUBSUMPTION
We now turn to the problem of verifying the preference equivalence and preference subsumption
relationships between two sets of preferences. We ﬁrst formally deﬁne preference equivalence and
preference subsumption.
Deﬁnition 5.1 Preference Equivalence and Preference Subsumption.
Let P1 and P2 be two
CP-nets over a set of variables V . Let 1? and 2? represent the transitive closures of the pref-
erence relations 1 and 2 induced by P1 and P2 respectively over the set of alternatives.
i. P1 is said to preference subsume P2, denoted P1 w P2 or P2 v P1, iﬀ8; 0 W  2 0 )
 1 0, or equivalently 1?  2?.
ii. P1 is said to be preference equivalent to P2, denoted P1  P2 iﬀP1 w P2 ^ P2 w P1.
In the above, equivalence and subsumption of P1 and P2 are deﬁned in terms of the tran-
sitive closures of the respective induced preferences, namely 1? and 2? that represent the set
of all improving ﬂipping sequences for P1 and P2, and not simply in terms of 1 and 2 that
represent only the set of improving ﬂips induced by the respective preference statements in P1
and P2. is is necessary because the dominance relation is transitive.
In other words, verifying the semantic equivalence of two sets P1 and P2 of preference
statements amounts to checking that for each edge from  to 0 in ı.P1/, there exists a corre-
sponding path from  to 0 in ı.P2/ and vice-versa. It is worth noting here that the above holds
for any preference language that has a ﬂipping-sequence based (ceteris paribus) semantics. Be-
cause dominance testing is PSPACE-complete for CP-nets [16], TCP-nets [18], CP-theories
[93], and CI-nets [17], preference equivalence testing (and preference subsumption testing) are
arguably PSPACE-complete for these preference languages.
Example 5.2
Figure 5.1 shows a CP-net P1 and its induced preference graph ı.P1/. Figure 5.2
shows a CP-net P2 with its induced preference graph ı.P2/. From the preference statements of P1

2. DATA STRUCTURES TO REPRESENT SEMANTICS OF TWO SETS OF PREFERENCE
67
(a) CP-net P2
(b) Induced Preference Graph
ı.P2/
Figure 5.2: Example preference speciﬁcation: CP-net P2.
and P2, it may appear that P2 subsumes P1, i.e., P1 v P2, because the only diﬀerence between
them is the preference over variable A: in P1 it is conditioned on b D 1, whereas in P2 it is
unconditional. On the other hand, it may not be as intuitive to conclude that P2 v P1. However,
this is indeed the case: P1 v P2 and P2 v P1, i.e., P1  P2, because the induced preference
graphs ı.P1/ and ı.P2/ are equivalent in terms of the reachability between any pair of alternatives.
e unconditional preference over A in P2 gives rise to an additional edge in ı.P2/ from Na Nb to
a Nb that has no corresponding edge in ı.P1/, but the same has a corresponding path in ı.P1/:
Na Nb ! Nab ! ab ! a Nb, which makes ı.P1/ and ı.P2/ (and hence P1 and P2) equivalent.
2
DATA STRUCTURES TO REPRESENT SEMANTICS OF
TWO SETS OF PREFERENCE
As we have outlined before, the central theme of our technique for equivalence and subsumption
veriﬁcation is to combine the preferences induced by one preference speciﬁcation with the inverse
of the other. e following sections detail the steps.
2.1
INVERSE INDUCED PREFERENCE GRAPH
We begin with deﬁning the inverse of an induced preference graph with respect to a preference
speciﬁcation P , which represents the inverse of the preference relation induced by P on the set
of outcomes.
Deﬁnition5.3 InverseInducedPreferenceGraph.
Given a preference speciﬁcation P , the in-
verse induced preference graph ı .P / is constructed by generating ı.P / and reversing the direction
of all the edges.
Example 5.4
Figure 5.3(a) and (b) show the inverse induced preference graphs ı .P1/ and
ı .P2/ for the CP-nets P1 and P2 shown in Figures 5.1 and 5.2 respectively.

68
5. VERIFYING PREFERENCE EQUIVALENCE AND SUBSUMPTION
(a) ı .P1/
(b) ı .P2/
Figure 5.3: Inverse induced preference graphs for CP-nets P1 and P2.
2.2
COMBINED INDUCED PREFERENCE GRAPH
Given two sets of preference statements P1 and P2, we ﬁrst consider preference subsumption test-
ing, i.e., verifying whether P1 v P2, since preference equivalence testing, i.e., checking whether
P1  P2 amounts to verifying whether P1 v P2 ^ P2 v P1. Verifying P1 v P2 amounts to ver-
ifying that for each edge .; 0/ in ı.P1/ there is a corresponding path from .; 0/ in ı.P2/. is
can be reduced to verifying a reachability property in a graph, namely the combined induced pref-
erence graph of P1 and P2, denoted ı.P1; P2/, that embeds the semantics of P1 and the inverse of
the semantics of P2.
Deﬁnition5.5 CombinedInducedPreferenceGraph.
Given two sets P1 and P2 of preference
statements over a set of variables V , the combined induced preference graph ı.P1; P2/ is a directed
graph G.N; E/ with a labeling function L that is constructed as follows. e nodes N correspond
to the set of alternatives generated by V . ere is an edge e;0 D .; 0/ 2 E if and only if there
is an edge from  to 0 in ı.P1/ or ı .P2/, and it is associated with a label
L.e;0/ D
8
ˆˆˆˆ<
ˆˆˆˆ:
f1g
if 0 1  and  62 0
f2g
if  2 0 and 0 61 
f1; 2g
if 0 1  and  2 0
.1/
Note that in the graph ı.P1; P2/, each edge .; 0/ 2 E corresponds to an improving ﬂip
from  to 0 induced by P1, a worsening ﬂip from  to 0 induced by P2, or both. Figure 5.4
shows the combined induced preference graph ı.P1; P2/ with respect to the CP-nets P1 and P2
shown in Figures 5.1 and 5.2 respectively, consisting of the edges in ı.P1/ (solid arrows, labeled
1) and those in ı .P2/ (dotted arrows, labeled 2).
Recall that verifying P1 v P2 is equivalent to verifying that for each edge .; 0/ in ı.P1/
there exists a corresponding path from .; 0/ in ı.P2/, or in other words, there exists a corre-

3. KRIPKESTRUCTUREENCODINGFORPREFERENCEEQUIVALENCEANDSUBSUMPTION
69
Figure 5.4: Combined induced preference graph ı.P1; P2/.
sponding path from .0; / in ı .P2/. erefore, in terms of the combined induced preference
graph ı.P1; P2/, the following proposition can be stated.
Proposition 5.6
Necessary and Suﬃcient Condition for Subsumption
P1 v P2 holds if and
only if: for each edge from  to 0 in ı.P1; P2/ that includes label f1g, there exists a path from 0 to 
such that each edge in the path includes the label f2g.
e above forms the basis of our model checking based approach to preference subsumption
testing.
3
KRIPKE STRUCTURE ENCODING FOR PREFERENCE
EQUIVALENCE AND SUBSUMPTION
In order to verify P1 v P2, we ﬁrst construct a Kripke structure K.P1; P2/ that encodes the
combined induced preference graph ı.P1; P2/. To achieve this, in the next subsection we will
recall modeling the induced preference graph of a single preference speciﬁcation as a Kripke
structure, and then extend it in the following subsection to be able to represent two preference
speciﬁcations in the same model.
3.1
MODELING OF PREFERENCE SEMANTICS: EXTENSION FOR
PREFERENCE EQUIVALENCE AND PREFERENCE SUBSUMPTION
REASONING
Recall from Chapter 4, the improving ﬂips as per preference statements are encoded as guarded
transition relations in a Kripke structure. Each state in the Kripke structure is identiﬁed by the
valuations of preference variables X, i.e., each state corresponds to an outcome. e guards on
the transitions correspond to the valuations of the variables in the source states and a set H of
boolean variables. e variables in H decided whether or not a preference variable value can
change as a result of the transition, and the variables in H are non-deterministically set by the
model checker. e encoding described in Chapter 4 ensured that for every sequence of improving
ﬂips in the induced preference graph ı.P / there is a sequence of transitions in the corresponding
Kripke structure K.P /, which allowed us to verify dominance by in turn verifying reachability in
the K.P /. Note that there are transitions in K.P / that result in self-loops because the value of

70
5. VERIFYING PREFERENCE EQUIVALENCE AND SUBSUMPTION
Figure 5.5: K.P1/: Kripke encoding for the semantics of P1.
variables in H (non-deterministically set by the model checker) does not satisfy the guards for
improving ﬂips; i.e., these self-loop transitions do not correspond to any improving ﬂips.
For the purpose of verifying equivalence and subsumption checking, we will need a new
boolean variable g (global change variable) to annotate the states in the Kripke structure. For
every transition between states s and t for which there exists some preference variable x such
that s.x/ ¤ t.x/, the value of g in t is set to 1. In other words, states s and t correspond to
diﬀerent outcomes in the induced preference graph, and these transitions correspond to improving
ﬂips between them. For all other transitions, the value of g is set to 0—these transitions do not
correspond to improving ﬂips. e introduction of the variable g changes the structure of K.P /,
without violating the key correctness property that for every improving ﬂipping sequence (of
outcomes) in the ı.P / there is a corresponding transition sequence in K.P /.
Example 5.7
Figure 5.5 shows the Kripke structure K.P1/ for the CP-net P1 in Figure 5.1 with
the newly introduced variable g. Note that due to the introduction of g, for each outcome, there
exist two states in the Kripke—they only diﬀer in the values of g; one with the g being true and
other with g being false. ese types of states are presented in the ﬁgure in grey boxes. For an
outcome , let us denote s
g as the state where g is true and s
Ng as the state where g is false. Note
that, for each set of values of variables in H that does not satisfy the conditions for improving
ﬂips, there is a transition from s
g to s
Ng and a self-loop on s
Ng. e transitions corresponding to
improving ﬂip connects the states corresponding to the worse outcome to the state corresponding
to the better outcome where the value of g is set to true; this is presented as transitions with source
grey box (representing that both states in the grey box are the source of the transition). For the
sake of clarity, we only annotate the transitions with the values of variables in H whenever the
transitions correspond to improving ﬂip.

3. KRIPKESTRUCTUREENCODINGFORPREFERENCEEQUIVALENCEANDSUBSUMPTION
71
Figure 5.6: Kripke structure K.P1; P2/ encoding the combined induced preference graph ı.P1; P2/.
3.2
ENCODING COMBINED INDUCED PREFERENCE GRAPH AS
KRIPKE STRUCTURE
We verify preference subsumption by verifying the condition of Proposition 5.6 using a Kripke
structure encoding K.P1; P2/ of ı.P1; P2/. To achieve this, we must be able to distinguish the
transitions in the model (corresponding to ﬂips) induced by P1 and P2. We use two global change
variables g1 and g2 to label the destination states of any transition as follows: g1 D 1 if the state
is reached via a transition induced by P1 and g2 D 1 if the state is reached via a transition induced
by P2 (more precisely the inverse of the given P2, as described in the preceding subsection).
e variables g1 and g2 are modeled as state variables, and hence the states S of K.P1; P2/
are deﬁned by the valuations of propositions PV D fxijxi 2 V g [ fg1; g2g. Hence, each outcome
or alternative  in ı.P1; P2/ corresponds to a set S D fsjs#V D g of states, where s#V denotes
the projection of a state s described by PV onto the set of variables fxijxi 2 V g  PV . e vari-
ables g1 and g2 are initialized to 0 in K.P1; P2/, whereas xi’s are uninitialized, i.e., the model
checker non-deterministically chooses and explores all possible combinations of assignments to
xi’s. Hence the set of start states S0 corresponds to the set of alternatives. e state space of
K.P1; P2/ for the running example in this chapter is illustrated below.
Example 5.8
Figure 5.6 shows the Kripke structure K.P1; P2/ corresponding to ı.P1; P2/ for
our running example. e start states are marked with transitions without any source state. For
clarity, the transitions between states corresponding to the same alternative are not marked, and
the valuations of input variables a0 and b0 are not shown in the transitions. States corresponding
to the same valuation of a and b are placed within dotted boxes. Further, transitions from the
set of all states in a dotted box to the same destination state with a diﬀerent valuation of a and b
(in a diﬀerent dotted box) are combinedly represented by a single arrow from dotted box to the

72
5. VERIFYING PREFERENCE EQUIVALENCE AND SUBSUMPTION
destination state, e.g., the arrow from the dotted box containing the states corresponding to Na Nb
indicates the presence of transitions from all states in the box to Nabg1 Ng2.
Recall that the encoding of ı.P1; P2/ as K.P1; P2/ is succinct in the sense that we do
not explicitly specify each node and edge in ı.P1; P2/ to construct the state space of K.P1; P2/;
instead we simply specify the preference statements as guarded transition relations of Kripke
structure and the model checker (using the power of non-determinism over the valuations of
variables in H) automatically constructs and explores the Kripke structure state-space as needed
(see Chapter 4 for details). e following holds by construction of K.P1; P2/ from ı.P1; P2/ as
just described.
Proposition 5.9
Given CP-nets P1 and P2, and the Kripke structure K.P1; P2/ D hS; S0; T; Li
.constructed from ı.P1; P2/ D G.N; E/ associated with labeling function L/,
1. 8; 0; i 2 f1; 2g W .; 0/ 2 E ^ L.e;0/  fig
) 9s ! s0 W s#V D  ^ s0
#V D
0 ^ s0.gi/ D 1.
2. 8s; s0 2 S W s ! s0 ^ s#V ¤ s0
#V
) 9i 2 f1; 2g; ; 0 W s#V D  ^ s0
#V D 0 ^ .; 0/ 2
E ^ L.e;0/  fig.
e full SMV source code listing for the Kripke structure K.P1; P2/ shown in Figure 5.6
is provided in Appendix C.
4
QUERYING K.P1; P2/ FOR SUBSUMPTION
We have already seen that verifying P1 v P2 is equivalent to verifying that for each edge from 
to 0 in ı.P1; P2/ that includes the label f1g, there exists a path from 0 to  such that each edge
in the path includes the label f2g (Proposition 5.6). Because the set of start states S0 in K.P1; P2/
corresponds to the set of alternatives in ı.P1; P2/, the above reduces to verifying the following
property in K.P1; P2/ by Proposition 5.9.
For each state s 2 S0 in K.P1; P2/, if there exists a transition to a state s0 with s0.g1/ D
1, then there exists a path s0 D s1 ! : : : ! sn ! s00 in K.P1; P2/ such that 81 < i 
n W si.g2/ D 1 and s#V D s00
#V .
Our objective is to express the above property in the language of Computation Tree Tempo-
ral Logic, CTL (Chapter 4), and automatically verify the temporal property with respect to
K.P1; P2/ using a model checker such as NuSMV. One interesting and subtle challenge in real-
izing our objective stems from the fact that the condition requires checking the existence of paths
starting from a state s and ending at a state s00 such that s#V D s00
#V . However, CTL allows the
speciﬁcation and veriﬁcation of temporal properties only with respect to states explored in the

4. QUERYING K.P1; P2/ FOR SUBSUMPTION
73
future, and therefore it is not possible to write a single temporal property in which the start state
s corresponds to all possible outcomes in the corresponding induced preference graph.²
We address this challenge by introducing a set of copy variables, namely x0
i ’s that are mod-
eled in SMV model checker as input variables in K.P1; P2/ and hence not stored as part of the
state. ey are initialized with the valuations of the respective xi’s at the start of model explo-
ration, and are constrained to remain invariant in the model; i.e., if the valuation of xi at a start
state s 2 S0 is vi, then x0
i remains equal to vi in all states along all paths starting from s. In
other words, if the model checker begins exploration at state s, then the propositional formula
 D V
i.xi D x0
i / can be used to refer to s#V . Proceeding further, the following CTL formula
encodes the condition for P1 v P2.
' W AX
 g1 ) EX E

g2 U . ^ g2/
 
Recall from the CTL semantics described in Chapter 3 for EX  , AX  , and E Œ 1U  2.
erefore, ' holds in K.P1; P2/ whenever the following holds. For each transition s ! s0 2 T
such that s0.g1/ D 1 (i.e., whenever AX g1 holds), there exists a transition s0 ! s00 (i.e., EX ) such
that s00 satisﬁes E

g2 U . ^ g2/
. at is, there is a path s00 D s00
1 ! s00
2 ! s00
k : : : ! s00
n such
that states till a state s00
n, where  also holds, is reached. Recall that propositional formula  is
satisﬁed in states where the valuations of the preference variables are the same as those in the
start state (denoted by s in this case; see above). Note that if there are no transitions s ! s0 such
that s0.g1/ D 1, then ' trivially holds in s. While the formula ' seems to imply that only one
particular improving ﬂip in P1 can be recovered using reverse ﬂips in P2, this is indeed without
loss of generality. is is because if each improving ﬂip in P1 is matched by reverse paths from P2,
then the transitive closure of improving ﬂips is also matched by reverse paths (using the transitive
closure reverse paths corresponding to each improving ﬂip). e following formalizes the fact
that K.P1; P2/ ˆ ' actually corresponds to the subsumption P1 v P2, and can be proved using
Propositions 5.6 and 5.9.
eorem 5.10
K.P1; P2/ satisﬁes ' if and only if P1 v P2.
4.1
EXTRACTING A PROOF OF NON-SUBSUMPTION
e model checker returns true whenever ' is satisﬁed, i.e., P1 v P2. Suppose that P1 6v P2.
e model checker will then return false, and provide the justiﬁcation/proof of unsatisﬁability,
essentially presenting a sequence that satisﬁes the negation of the ' (see above), which is:
:' W EX
 g1 ^ AX :E

g2 U . ^ g2/
 
²Note that it is necessary that s must be referenced without loss of generality, so that the single temporal property will force
the model checker to consider all possible start states as precisely those corresponding to the set of outcomes. If s cannot be
referenced without loss of generality, it will be necessary to pose an exponential number of queries to verify that the property
holds for each pair of outcomes, which is practically infeasible.

74
5. VERIFYING PREFERENCE EQUIVALENCE AND SUBSUMPTION
Figure 5.7: P3 and the graphs ı.P3/ and ı.P1; P3/:
e proof is presented in the form of a transition s ! s0 that corresponds to a ﬂip from  D s#V
to 0 D s0
#V such that (a) s0 satisﬁes g1 (implying that there is a path from s to s0 as per P1) and
(b) s0 satisﬁes AX :E

g2 U . ^ g2/
 (implying that there is no path from s0 back to any state
s00 with s00 #V D s #V as per P2). In other words, the transition s ! s0 corresponds to a ﬂip from
 to 0 induced by P1 but not by P2.
4.2
VERIFYING PREFERENCE EQUIVALENCE
P1  P2 can be computed by verifying both ' and the following formula in K.P1; P2/.
'0 W AX
 g2 ) EX E

g1 U . ^ g1/
 
Note that '0 veriﬁes P2 v P1. Hence by Deﬁnition 5.1, P1  P2 iﬀ' ^ '0 is veriﬁed in
K.P1; P2/.
In our running example (Figure 5.4), the formula ' ^ '0 is veriﬁed in K.P1; P2/, proving
that P1  P2. Now consider another CP-net P3 and its relationship with P1 shown in Figure 5.7.
Note that '0 is veriﬁed in K.P1; P3/, i.e., P3 v P1. However ' is not, and the model checker
returns false, with a path s ! s0 such that s#V D Na Nb and s0
#V D Nab, which corresponds to a ﬂip
induced by P1 but not by P3. is provides the proof for P1 6v P3 and hence for P1 6 P3.
In summary, our approach is generic and can be used to verify equivalence and subsump-
tion for any two sets of ceteris paribus statements, not necessarily expressed in the same prefer-
ence language. Given two sets of preference statements P1 and P2, if there are jV j nodes and
jEj edges in ı.P1; P2/, then there are O.jV j/ states and O.jEj/ transitions in K.P1; P2/ by
construction. Hence, the complexity of computing preference subsumption (and equivalence)
is .jV j C jEj/  j'j/ as per the CTL model checking complexity [27]. Preliminary experiments
indicate the feasibility of our approach for preferences expressed over up to 30 variables in a few
seconds.
5
DISCUSSION
We have used examples of CP-nets [14] to explain necessary concepts and techniques for prefer-
ence equivalence and preference subsumption checking; however, as in the case of Chapter 4, the
approach presented in this chapter is applicable to all languages based on ceteris paribus semantics,

5. DISCUSSION
75
i.e., those for which the semantics of the dominance relation can be given in terms of reachability
within a graph of alternatives, including TCP-nets, CP-theories, and CI-nets. We conducted
a preliminary feasibility study of our technique. e experiments indicate preferences expressed
over up to 30 variables can be analyzed in less than a minute.
e method presented in this chapter can be extended to identify the set of all dominance
relationships between alternatives in which the two sets of preferences diﬀer, i.e., all possible ways
one preference speciﬁcation diﬀers from another. In certain cases, this may be necessary to deduce
the “degree” of diﬀerences between preferences of two or more agents. Finding these diﬀerences
amounts to the following. First, we need to encode the proof of diﬀerence between preference
speciﬁcations as obtained via model checking as a temporal logic property. is can be achieved
easily as the proof of diﬀerence is a sequence of transitions that can be encoded using nesting
of EX-formulas. In the second step, we relax the CTL formula used for ﬁnding equivalence by
adding (disjunction) the proofs of diﬀerences that are already discovered. e veriﬁcation of the
relaxed CTL formula either returns true, i.e., the preference speciﬁcations are now equivalent
modulo the already discovered proofs of diﬀerences; or returns false, revealing that other proofs
of diﬀerences exist, which can be obtained by verifying the negation of the relaxed CTL formula
as explained in Section 4.1.


77
C H A P T E R
6
Ordering Alternatives With
Respect to Preference
So far, we have seen examples of preference reasoning tasks that reason about dominance over
pairs of alternatives or equivalence or subsumption of one preference speciﬁcation with respect
to another. In this chapter, consider the problem of ordering alternatives with respect to a given
set of preferences. is problem ﬁnds applications in a variety of settings. For example, in rec-
ommendation systems, a user might want to consider the second or third best alternative when
his most preferred alternative is unavailable for some reason; the amazon.com recommendation
engine might want to present the user with the next best set of items in order of the user’s prefer-
ences. Similarly, a policy maker might want to view the policies that are most preferred in order
of preference. is chapter focuses on computing such an ordering for preferences stated using
the ceteris paribus preference languages.
e problem of computing the next preferred alternative (ordering alternatives such that
more preferred solutions are ahead of those that are less preferred) with respect to qualitative
preferences has seen increased interest recently. Pilotto et. al. [71] introduced the problem of
computing the next best solution with respect to a CP-net in the context of the stable marriage
problem. Brafman et al. [19, 20] proved that ﬁnding the next-best solution in constraint satis-
faction problems (CSPs) [89] is easy under some conditions, although it is hard in general for
CSPs and weighted CSPs. Brafman et al. also show that the problem is easy in acyclic CP-nets
and constrained acyclic CP-nets under some conditions; however ﬁnding the next-best solution
with respect to general CP-nets (that can induce cyclic preferences among alternatives) is NP-
hard. e corresponding complexity for more expressive preference languages such as TCP-nets,
CI-nets, etc., have not yet been studied. Such algorithms are of importance in settings where
suboptimal solutions may lead to undesirable consequences such as economic loss, customer dis-
satisfaction, and/or compromise of personal privacy. Speciﬁcally, the problem of ﬁnding the next
best solutions respecting a set of preferences is also of central importance to evaluating skyline
queries with preferences in the database setting [23, 24, 44, 55] and query answering for semantic
search [63] using the ontological CP-net formalism [64].
1
OVERVIEW
In this chapter we show how to compute the next-preferred alternatives when the stated prefer-
ences can induce cyclic preferences between alternatives, which involves (a) automatically trans-

78
6. ORDERING ALTERNATIVES WITH RESPECT TO PREFERENCE
p1. fdg; fg W fbg  fcg
p2. fbg; fag W fcg  fdg
p3. fag; fcg W fbg  fdg
p4. fg; fag W fb; dg  fcg
p5. fg; fcg W fa; dg  fbg
a WD Increase Logging Level
b WD Restrict Access Privilege
c WD Stop Service
d WD Setup a Firewall
abcd
abc
abd
acd
bcd
ab
ac
ad
bc
bd
cd
a
b
c
d
Ø
Induced Preference Graph of SCCs (δSCC)
Level
φ0
1
3
4
5
6
φ
φ
φ
φ
φ
φ
(a)
(b)
Figure 6.1: (a) Example CI-net preference speciﬁcation, (b) induced preference graph ı.P /.
lating a preference speciﬁcation into the input model of NuSMV [26] model checker as we have
seen earlier (Chapter 4) and (b) iteratively modifying and verifying the original preference model
against a sequence of temporal properties (introduced in this chapter), whose counterexamples
correspond to the desired ordering of next preferred solutions. ere are two salient features of
the approach developed in this chapter. First, we characterize the ordering computed here in terms
of an extension of the partial order induced by the ceteris paribus semantics of the user preferences.
Second, the approach is applicable even when the user preferences are inconsistent, i.e., may induce
cycles in the preferences over solutions.
Example 6.1
Recall the example from Section 1.4 from Chapter 1 of ordering countermeasure
sets starting from the most preferred one to the least that satisfy the security concerns of an
administrator. e CI-net encoding of the preference statements for this example is given in
Example 2.11 in Chapter 2.
In the rest of the chapter, we will use this as a running example. Figure 6.1(b) shows the
corresponding induced preference graph. e dotted edges in the graph correspond to importance
ﬂips induced by the preference statements p1 to p5 and the solid edges correspond to monotonic-
ity ﬂips (see Chapter 2 Section 3.1). Note that there are two cycles—one is ab ! b ! ad ! ab;
and another is c ! bd ! bc ! c, i.e., the preferences are inconsistent. Further, according to

1. OVERVIEW
79
Figure 6.2: Kripke structure encoding for the semantics of example CI-net in Figure 6.1.
Deﬁnition 2.25 (see Chapter 2), b, ab, and ad are equivalent; similarly c, bd, and bc are equiv-
alent.
We sometimes use “P ˆ 1R2” for 1RP 2 as a notational convenience. Edges of strongly
connected components (SCCs) in Figure 6.1(b) resulting in equivalent alternatives are colored
black (bold).
1.1
KRIPKE ENCODING
We will use ideas from Chapters 4 and 5 on constructing a Kripke structure model of the prefer-
ence semantics of a preference speciﬁcation. A part of the Kripke structure encoding constructed
from the example CI-net in Figure 6.1 is shown in Figure 6.2. We recall some of the important
details of the encoding using the running example of this chapter.
Example6.2
Figure 6.2 presents a snapshot of the transitions to and from the states correspond-
ing to the alternatives c, bc, and bd. e labels in the states denote the variables that evaluate to
true. Pairs of states are grouped together in the ﬁgure to show that these pairs of states correspond

80
6. ORDERING ALTERNATIVES WITH RESPECT TO PREFERENCE
to one alternative in the corresponding induced preference graph ı.P /. e value of the global
change variable g (introduced in the previous chapter for modeling) distinguishes the states in
each pair: in one state of the pair the value of g is set to true and in the other it is set to false.
Note that, in each pair, the value of the variables corresponding to preference variables in V are
identical. We refer to the paired states as meta-states.
e transitions from both states in a meta-state is denoted by directed edges that start from
the boundary of meta-state. e destination of these edges are states in some other meta-states
where the value of g is true. ese edges are labeled with the h-variables to denote the value
of the preference variable (i.e., their presence or absence) that diﬀer between the source and the
destination states.
1.2
OBJECTIVE: COMPUTING AN ORDERED SEQUENCE
Computing an ordering of successively preferred alternatives with respect to a preference speciﬁ-
cation entails generating a sequence 01; 02; : : : ; 0m0; : : : 11; 12; : : : ; 1m1; : : : ; n1; : : : ; nmn
of alternatives where 8i 2 Œ0; n W ˚i D [mi
j D1fij g, and alternatives in ˚iC1 are not preferred to
any alternative in ˚i. We refer set ˚i as the set of non-dominated alternatives at level i – these
alternatives are not dominated by any other alternative in ˚iC1. For instance, as per Figure 6.1(b),
˚0 D f;g, ˚1 D fa; dg, and ˚2 D fb; ab; adg.
A possible solution to the above problem will involve construction of ı.P / (Figure 6.1(b))
and then generation of a DAG over SCCs in ı.P /. Construction of ı.P / will require considering
all possible alternatives and identifying the edges between them by considering all possible pairs
of alternatives in the context of the preference statements. Construction of a DAG over SCCs in
ı.P / can be done in time linear to the number of nodes and edges in ı.P /. Finally, this DAG
needs to be explored in a way such that alternatives are output in order starting from level ˚0
(top-level non-dominated set of alternatives). is can proceed by identifying the nodes in the
DAG that do not have outgoing edges; the alternatives in these nodes belong to ˚0. e DAG
is then updated by removing these nodes; and the next set of nodes are identiﬁed which do not
contain any outgoing edges—the alternatives in these nodes belong to ˚1. e disadvantage with
this approach to computing an ordered sequence of alternatives with respect to P is that the
complexity of constructing ı.P / is exponential in the number of preference variables. Moreover,
it may not be necessary to construct the entire ı.P / in order to generate an ordered sequence
of alternatives, especially if only a small number of alternatives from the top of the ordering
are needed. We next describe a model checking approach that generates an ordered sequence of
alternatives that respects P in an anytime fashion, i.e., a sequence of k alternatives generated up
to any given point represents the top-k alternatives with respect to P .

2. COMPUTATION OF ORDERED ALTERNATIVE SEQUENCE
81
2
COMPUTATION OF ORDERED ALTERNATIVE
SEQUENCE
e technique we will present involves automatic iterative updates to the Kripke structure as well
as veriﬁcation of carefully selected CTL temporal logic properties on these updates. In each itera-
tion, we will obtain a set of alternatives that are most preferred among the alternatives that are yet
to be output. In the following sections, we proceed by presenting certain properties of the induced
preference graph (Section 2.1), which forms the basis of our iterative algorithm (Section 2.2).
2.1
DEALING WITH SCCS IN INDUCED PREFERENCE GRAPH
As noted in Section 1.2, our objective is to obtain an ordered sequence of alternatives. e se-
quence is further organized as a sequence of sets of outcomes ˚0; ˚1; : : : ; ˚n, where
• the alternatives in ˚i are either equally preferred or are preferentially indiﬀerent (see Deﬁ-
nition 2.25), and
• the alternatives in ˚iC1 are not preferred to any alternative in ˚i.
Our iterative algorithm will generate ˚i at the i-th iteration. ˚i is referred to as the non-dominated
set at level i.
ere are two types of alternatives that belong to the i-th non-dominated set ˚i of alter-
natives.
Type I: alternatives in ˚i, denoted ˚I
i , that are not present in SCCs in the induced preference
graph ı.P /. ˚I
i D f j  2 ˚i ^ 80 2 ˚i W .0 ¤  ) 0 66 /g
Type II: alternatives in ˚i, denoted ˚II
i , that are indiﬀerent to the Type I alternatives and are
equivalent (equally preferred) to some other Type II alternative (i.e., belongs to an SCC in
ı.P /). ˚II
i D f j  2 ˚i ^ 90 2 ˚II
i W 0   ^ 8” 2 ˚I
i W .” 66 /g
Note that there is at most one Type I set (˚I
i ) and potentially multiple Type II sets (˚II
i D f˚II1
i
,
˚II2
i
, : : :}) at each level i. In particular, there are as many sets of Type II sets of alternatives in
level i as there are SCCs in ı.P / corresponding to that level, with ˚
IIj
i
corresponding to the j th
SCC at level i. Note that ˚i D ˚I
i [ .[j ˚
IIj
i
/.
Example 6.3
For instance, in Figure 6.1(b),
• ˚I
1 D fa; bg and j˚II
1 j D 0 (absence of Type II sets)
• ˚I
2 D fg (Type I set is empty) and ˚II1
2
D fb; ab; adg and j˚II
2 j D 1 (presence of one Type
II set).

82
6. ORDERING ALTERNATIVES WITH RESPECT TO PREFERENCE
We now state two characterizations of the Type I and Type II alternatives, which will be
helpful to explain our algorithm for generating alternatives in order.
Proposition 6.4
For the given preference speciﬁcation P , 8i > 0; 8 2 ˚I
i W
a) 90 2 ˚i 1 W 0  
b) 6 90 2 ˚k; k > i W 0  
Proposition 6.4a states that each alternative in ˚I
i has an edge in ı.P / (i.e., is strictly less pre-
ferred) to some alternative in ˚i 1. Proposition 6.4b states that there is no alternative in any level
greater than i to which there is an edge from any alternative in ˚I
i . ey state the necessary and
suﬃcient conditions for alternatives of Type I to belong to a level i: a Type I alternative must be
dominated by some alternative in level i   1, and must not be dominated by any alternative in a
level greater than i.
e conditions are similarly given for Type II sets of alternatives: at least one among a
set of (equivalent) alternatives in ˚II
i (that are involved in an SCC) must be dominated by some
alternative in ˚i 1; and none of the alternatives in the Type II set must be dominated by any
alternative in a level greater than i. ese are stated in Proposition 6.5.
Proposition 6.5
For any preference speciﬁcation P , 8i > 0 8j 8 2 ˚
IIj
i
W
a) 90 2 ˚
IIj
i
; 00 2 ˚i 1 W   0 ^ 00  0
b) 6 90 2 ˚k; k > i W 0  
e above propositions form the basis of our algorithm for computing an ordered sequence
of alternatives 01; 02; : : : ; 0m0; : : : 11; 12; : : : ; 1m1; : : : ; n1; : : : ; nmn with respect to a pref-
erence speciﬁcation P , such that 8i W ˚i D [mi
j D1fij g.
At this point, before we delve into the algorithmic details, we state an assumption on the
structure of the induced preference graph. is assumption allows us to present an algorithm
that works for a restricted set of induced preference graphs. As subsequently pointed out, this
assumption does not limit the generality of the algorithm itself.
Assumption 6.6
For any preference speciﬁcation P , the following hold for ˚0
a) e set ˚0 always includes empty-set
b) e set ˚0 is either a singleton set containing only ;, i.e., ˚I
0 D f;g and ˚II
0 D fg, or only
contains Type II elements, i.e., ˚I
0 D fg and ˚II
0 ¤ fg
e above assumption states that the most preferred set of alternatives with respect to P always
includes ;. Note that this is trivially true for all CI-nets, where the induced preference graph

2. COMPUTATION OF ORDERED ALTERNATIVE SEQUENCE
83
is a lattice over the alternatives. In an acyclic CI-net there is exactly one set at the top of the
lattice: either ; or the entire set of alternatives. For other CI-nets, if ; is involved in an SCC in
ı.P /, then all the alternatives in this SCC are equivalent to each other and to the alternative ;;
hence ˚0 includes all alternatives in this SCC as Type II set. Otherwise, ˚0 consists of just one
alternative–; which is the unique, most preferred alternative with respect to P . For preference
languages other than CI-nets, we could force the above assumption by introducing a dummy
binary preference variable xd which is also the most important of all variables with intra-variable
preference 1  0, which make the set of all alternatives with xd D 1 as the non-dominated set
at the top of the induced preference graph. Hence, the above assumption does not limit the
generality of the algorithm presented in the following subsection.
2.2
ITERATIVE MODEL REFINEMENT AND PROPERTY RELAXATION
Algorithm 1 computes an ordering of alternatives by model checking speciﬁc CTL properties
in a sequence and appropriately reﬁning the Kripke structure model (encoding the preference
semantics of a preference speciﬁcation) and temporal properties with respect to the model. We
proceed by ﬁrst describing some important temporal properties that we will utilize to obtain the
Type I and Type II elements at each level.
Property6.7
Consider the objective of ﬁnding the most preferred alternative (a Type I element).
e property to be veriﬁed is
EXg
(6.1)
EX describes a property for some (exists, E) path in the next state (X). at is, the property is
satisﬁed in all states in K.P / which can reach a state where g is set to true in one transition.
e state that does not satisfy the property corresponds to the alternative which is most preferred
because there is no transition from that state to another state where g is true—in other words,
there is no transition from that state that corresponds to monotonicity or importance ﬂips. e
model checker will automatically ﬁnd such a state as a counterexample witnessing the violation
of the property in Equation 6.1.
Property 6.8
Consider an alternative  that belongs to a Type II set. erefore, there exist some
alternatives that are equivalent to . e states corresponding to  in Kripke structure K.P / will,
therefore, have some edges to states corresponding to another alternative. e objective is to ﬁnd
at least one equivalent alternative, say, 0.
Recall that in K.P /, there are two states where the variables describing  are true and in
one of the two, the variable g is true. Let us denote these states as :g and g. In K.P /, there is
a transition from g to :g and a transition from :g to :g. e following temporal property
is not satisﬁed by the states where  holds and  is a Type II alternative.
 ) AX
(6.2)

84
6. ORDERING ALTERNATIVES WITH RESPECT TO PREFERENCE
In the above, AX describes the property for all paths (A) in next (X)states. at is, the property
states that from any state in K.P / where  holds, the state where  holds can be visited along all
paths via one transition. is is not true as  is Type II alternative and there exists a path where
in one step states satisfying  can reach some other state not satisfying . e model checker
can automatically ﬁnd such a path leading to a state not satisfying  as a counterexample proving
the violation of the property in Equation 6.2. e last state in the resultant counterexample path
corresponds to an alternative (e.g., 0) that is equivalent to .
Property 6.9
Consider the problem of verifying whether an alternative  is a Type II alternative.
For  to be a Type II alternative, all alternatives reachable from  should be able to reach  in
ı.P / (i.e.,  is part of cycle(s)); see Deﬁnition 2.25.
In the corresponding Kripke structure K.P /, this amounts to the fact that from all states
reachable from the states corresponding to , the states corresponding to  are reachable. is is
captured by the following CTL property.
 ) AGEF
(6.3)
In the above, AG denotes the property in all states (G) along all paths (A). e EF denotes the
property in some state in future (F) in some path (E). at is, the property in Equation 6.3 states
that for any state s where  holds ( )), in all reachable states (say, t), there exists a path from t
which eventually visits a state where  holds as well. e property is satisﬁed by  if and only if
 is a Type II alternative and there exists no other alternative strictly preferred to .
ere are three major steps in our algorithm for iteratively computing the order sequence
of alternatives from preference speciﬁcations.
Step 1. Computing ˚0
Step 2. Computing Type I alternative at ˚i for i > 0.
Step 3. Computing Type II alternatives at ˚i for i > 0.
At each step, the Kripke structure is updated and/or appropriate CTL properties (see Proper-
ties 6.7, 6.8, and 6.9) are veriﬁed. In the following, we present our algorithm in terms of these
steps.
Step 1: Computing ˚0. As noted in the Assumption 6.6, ; 2 ˚0. It can be the only Type I
alternative at ˚0 or it can be part of the Type II elements. Hence, we start with ˚0 D f;g and
verify the CTL property SCC.	/ WD .	 ) AX 	/ in K.P /, where 	 is initialized to ˚0 (Line 3
in Algorithm 1 and Algorithm 2). is property (see Property 6.8) is satisﬁed in K.P / if and
only if ; is not included in an SCC in ı.P /, i.e., ; is not a Type II alternative. is is the case in
example Figure 6.1(b) (˚0 D f;g).
On the other hand, if the property is not satisﬁed, the model checker returns a counterex-
ample (a state in K.P /) corresponding to an alternative 0, that is in an SCC including ; in ı.P /.

2. COMPUTATION OF ORDERED ALTERNATIVE SEQUENCE
85
Algorithm 1 Computing the next-preferred alternatives
1: procedure N-P
2:
i D 0
3:
˚i WDFind-Top-Cycle(;; KP )
4:
i D i C 1
5:
Remove states corr. to alternatives in ˚i 1 from KP
6:
if KP is empty then return
7:
˚i D fg
8:
Verify in KP the property nds.˚i/ W .EXg/ _ ˚i
9:
if counterexample (state corr. to ) is generated then
10:
Add  to ˚i; Goto Line 8
F Type I alternative
11:
else
F Check for Type II alternatives
12:
	 WD ˚i
F No more reconsidered as Type II
13:
Include states in KP corr. to alternatives in ˚i 1
14:
Verify cand-SCC.˚i 1; 	/ W .:EX ˚i 1/ _ 	 in KP
15:
if counterexample corr. to  is generated then
16:
if 90 2 	 W   0 then
F Ignore alternatives in levels > i
17:
	 WD 	 [ fg
18:
Goto Line 14
19:
end if
20:
Remove states corresponding to the set ˚i 1 from KP
21:
Verify verify-cand./ WD  ) AG.EF/ in KP
22:
if verify-cand./ holds then
23:
˚i WD ˚i [ Find-Top-Cycle(, KP )
F Compute SCC
24:
	 D 	 [ ˚i
F Set up for next SCCs
25:
else
26:
Add  to 	
F No more reconsidered for Type II
27:
Goto Line 13
28:
end if
29:
else Goto Line 4
F No Type II in ˚i; ˚i computed
30:
end if
31: end procedure
We add 0 to 	 (see Line 5 in Algorithm 2). We proceed to identify the other alternatives that
are present in this SCC. We iterate the model checking step using the property SCC.	/; note
that the property is relaxed as 	 now contains ; and 0.
e model checking and addition of counterexample to 	 (Lines 2–5 in Algorithm 2) are
iterated until the property is satisﬁed. is step corresponds to Lines 2–3 in Algorithm 1. We
next proceed to computing alternatives in ˚1; ˚2; : : : in order.
Step 2: Computing ˚I
i .i > 0/. We remove (Line 5 in Algorithm 1) the states in K.P / corre-
sponding to the alternatives present in ˚i 1 (using INVAR in the modeling language of NuSMV
and add an invariant corresponding to the negation of alternatives in ˚i 1 in the modeling lan-
guage of NuSMV).

86
6. ORDERING ALTERNATIVES WITH RESPECT TO PREFERENCE
Algorithm 2 Computing the Type II alternatives in an SCC
1: procedure F-T-C(, KP )
2:
	 WD fg
3:
Verify in KP the property SCC.	/ W 	 ) .AX 	/
4:
if counterexample corr. to 0 is generated then
F Type II alternative in a top SCC containing 
5:
Add 0 to 	; Goto Line 3
6:
else return 	
7: end procedure
We initialize a set ˚i to empty set. We then verify to ﬁnd non-dominating alternatives
using the property nds.˚i/ WD EX g _ ˚i in K.P /. Recall from Property 6.7, this property is
satisﬁed in states corresponding to alternatives which are dominated by (less preferred to) some
other alternative. If the property is not satisﬁed in K.P /, then the model checker returns a state as
a counterexample. is state corresponds to some alternative that is not dominated by any other
alternative at ˚i. e alternative is added to ˚i and the process is iterated to obtain all the Type
I alternatives in ˚i (see Lines 8–10 in Algorithm 1). Note that at each iteration, the property is
relaxed by including the already obtained alternatives in ˚i as a disjunct.
Following these step, in Figure 6.1(b), ˚I
1 D fa; dg is computed as Type I alternatives after
K.P / is updated by removing the states corresponding to alternatives in ˚0 D f;g.
Step 3: Computing alternatives in ˚II
i .i > 0/. Once ˚I
i has been computed, we check for the
existence of Type II alternatives, i.e., those that are involved in SCCs in ı.P /. ere may be
multiple Type II alternative sets ˚
IIj
i
, each one resulting from a non-trivial SCC at level i.
Step 3a: Computing alternatives in ˚
IIj
i
.i > 0/. We identify alternatives that have one or more
edges to some previous level alternatives in ı.P / (necessary condition for candidate alternatives
in ˚
IIj
i
—see Proposition 6.5a).
We ﬁrst include the states in K.P / corresponding to alternatives in ˚i 1 that were removed
after level i   1 was computed. We verify the property cand-SCC.˚i 1; 	/ W :.EX ˚i 1/ _ 	,
where 	 is the set of alternatives known not to belong to ˚
IIj
i
(initially it is set to f˚ig to avoid
considering Type I alternatives). e property is satisﬁed by states which correspond to alterna-
tives in 	 or which do not have any transition to states corresponding to alternatives in ˚i 1. In
the event the property is not satisﬁed, then the model checker obtains a state as a counterexample;
such a state does not correspond to alternatives in 	 and has a transition to a state correspond-
ing to the alternative in ˚i 1 (i.e., dominated by or less preferred to the alternatives in ˚i 1). In
short, the counterexample generated by the model checker corresponds to an alternative  that
satisﬁes the necessary condition (Proposition 6.5a) for being a candidate for ˚
IIj
i
. If cand-SCC is
satisﬁed, then there are no (more) Type II alternatives.
Let us denote the counterexample as . is candidate for Type II alternative  must also
satisfy the suﬃcient condition (Proposition 6.5b) before it can be included in ˚
IIj
i
. is can be

2. COMPUTATION OF ORDERED ALTERNATIVE SEQUENCE
87
veriﬁed by checking whether the alternative can also reach any alternative in level > i, in which
case the suﬃcient condition is violated. ere are two ways to check for this condition: is there
an alternative preferred to  as per (a) monotonicity or (b) importance ﬂips.
First, if the alternative is a superset of any alternative that is ruled out from ˚
IIj
i
(i.e., 	,
see Line 12), then the alternative belongs to ˚k with k > i (according to monotonicity ﬂip); see
Lines 16–18.
Second, if the above check fails, then we proceed to remove the states corresponding to
alternatives in ˚i 1 and verify the property verify-cand./ W  ) AGEF in K.P /. Recall from
Property 6.9, verify-cand is satisﬁed by states which belong to some SCC and cannot reach
any state outside the SCC. at is, if the property is not satisﬁed by states corresponding to ,
then there exists some alternative in ˚i that is preferred to  as per importance ﬂip and  is ruled
out from ˚
IIj
i
(Lines 21, 25, 26).
Otherwise,  belongs to ˚
IIj
i
and we proceed to obtain the rest of the alternatives in ˚
IIj
i
by invoking F-T-Cin Algorithm 2 (Lines 21, 22).
Step 3b: Computing ˚
IIjC1
i
. After ˚
IIj
i
is computed following Step 3a, we proceed to compute
other SCCs (alternatives in ˚
IIjC1
i
) at the current level. Step 3a is reiterated by discarding the
alternatives in ˚
IIj
i
that have already been computed (Line 23 in Algorithm 1).
Once the alternatives ˚i are obtained, we remove them from K.P / by adding invariant corre-
sponding to the negation of all the alternatives in ˚i. Steps 2, 3 are repeated to compute alterna-
tives in ˚iC1. is step corresponds to Lines 27, 4–5 in Algorithm 1.
2.3
SAMPLE RUN OF THE ALGORITHM ON EXAMPLE IN FIGURE 6.1(B)
e run starts with ˚0 containing ;. At Line 3, Find-Top-Cycle is invoked to ﬁnd any other
alternatives that are equivalent to ;. In our example, the property at Line 3 of Find-Top-Cycle
is satisﬁed (see discussion in Property 6.8).
e run proceeds to Line 5 and the states corresponding to ; are removed from the Kripke
structure (model reﬁnement) and ˚1 is initialized to empty set (Line 7). Next the Type I elements
of ˚1 are obtained from the counterexamples resulting from unsatisﬁability of the property at
Line 8 (see discussion in Property 6.7). All the Type I elements of ˚1 are obtained in Lines 8–10;
in our example, they are alternatives a and d.
Proceeding further, the next step is to obtain the ﬁrst set ˚II1
1
of Type II alternatives in
˚1. e alternatives that cannot be in ˚II1
1
are added to 	 (Line 12), i.e., 	 at this point is equal
to fa; dg. e ˚0 alternatives (the states corresponding to ;) are brought back in the Kripke
structure (Line 13). At Line 14, possible existence of Type II alternatives is checked using the
property cand-SCC. In our example, the property is not satisﬁed and the model checker obtains a
counterexample: a state which has a transition to some state corresponding to alternative ; in ˚0
and which does not correspond to any alternative (a and d) in 	. Let such a state correspond to
the alternative c (model checker can non-deterministically generate any valid counterexample).

88
6. ORDERING ALTERNATIVES WITH RESPECT TO PREFERENCE
Lines 16 check whether c is less preferred as per monotonicity to already obtained alternatives
a and d in 	. e alternative c passes that test and the run proceeds to check whether c is less
preferred to some other alternative that is not in ˚0. To prepare for this, ﬁrst states corresponding
to alternative ; in ˚0 is removed from the model (Line 19) and the property verify-cand is
veriﬁed. e property is not satisﬁed by states corresponding to alternative c as there exists a path
from such states to some other states (e.g., corresponding to alternative b) from where states
corresponding to c is not reachable. e alternative c is, therefore, added to 	 (Line 25) and the
execution iterates from Line 13 (Line 26).
In this iteration, let the counterexample state generated as a result of unsatisﬁability of
property at Line 8 correspond to alternative b. As with alternative c, alternative b also passes the
test that it is not dominated by the alternatives a and d via monotonicity. However, alternative
b does not satisfy the property at Line 20 as the states corresponding to b can reach the states
corresponding to alternative d and from there the states corresponding to b are not reachable.
erefore, b is discarded as well for Type II elements in ˚1. e iteration continues from Line 13
again and this time the property at Line 14 is satisﬁed and the execution goes to Line 27. is
marks the end of computing alternatives in ˚1.
In the next iteration, starting from Line 4 alternatives in ˚2 are computed. e ﬁrst step
is to ﬁnd Type I alternatives of ˚2. e property at Line 8 is satisﬁed as every existing state has
a transition to some state with g set to true. erefore, there is no Type I alternative in ˚2. e
run proceeds to Line 12 (	 being initialized to fg). e property at Line 14 is not satisﬁed and
the model checker generates a counterexample: a state corresponding to some alternative that has
an edge to alternatives a or d in ˚1. Let the model checker obtain the state corresponding to the
alternative b. e next steps (Lines 16–20) involve checking whether it is truly a Type II element
in ˚2. e alternative passes these tests, and alternatives involved in a cycle with b are generated
by invoking Find-Top-SCC at Line 22 with  equal to b. As a result, the alternatives ab and
ad are obtained and added as Type II alternatives to ˚2. e run moves to Line 13 again (from
Line 26) to check for existence of other Type II alternatives. e check fails as the property at
Line 14 is not satisﬁed and the execution proceeds to ﬁnd alternatives in ˚3.
e process terminates when all states in the Kripke structure have been removed and it is
empty (Line 6).
2.4
NUMBER OF MODEL CHECKING CALLS
e number of calls for model checking can be obtained as follows. Let there be L SCCs, and the
maximum size of the SCCs is M, then there are O.L  M/ calls to verify the property in Line 3
in Algorithm 2. Next suppose there are N levels in the preferred ordering and the maximum size
of Type I set at any level is j˚Ij, then the number of model checking calls to verify the property in
Line 8 of Algorithm 1 is O.N  j˚Ij/. Note that both these calls are inexpensive model checking
calls as they verify one-step properties (involving X-operator).

3. PROPERTIES OF NEXT-PREF
89
Finally, if there are n alternatives, then the properties at Lines 14 and 20 can be potentially
model checked against O.n/ alternatives. e worst case occurs when alternatives at level i have an
edge to some alternative at level i   1 and to some alternative at level i   2. e model checker can
potentially obtain counterexample alternatives from the lowest level after verifying the property at
Line 14. Such alternatives will fail the checks for verifying the suﬃcient conditions, i.e., will fail
the properties at Line 16 and Line 20. However, such special scenarios are likely to be infrequent
and as a result the calls to verify property at Line 20 will be minimal. Note that in the absence of
cycles, the algorithm can avoid Lines 11–26.
3
PROPERTIES OF NEXT-PREF
We prove that the sequence of sets ˚0 : : : ˚n corresponds to an optimistic minimal weak order
extension of the partial order represented by ı.P / over the alternatives. is property guarantees
that an alternative in the computed order is placed at the highest possible level in any weak order
extending the partial order represented by (the edge relation of) ı.P /. We use the following
deﬁnition of a weak order in terms of a sequence of pairwise disjoint subsets of O, inspired by the
characterization of weak orders by Bertet et al. [7].
Deﬁnition 6.10 Weak Order.
A binary relation R  O  O is a weak order on O if and only
if there exists a sequence ˚0 : : : ˚n of sets such that 8i < n W ˚i  O and the following hold:
(a) 8i < j W 8 2 ˚i; 0 2 ˚j W 0 6R ; (b) 8i < j W 9 2 ˚i; 90 2 ˚j W R0; and (c) 8; 0 2
˚i W . 6R 0 ^ 0 6R / _ .R0 ^ 0R/.

In the above, condition (c) requires that if two elements in O are in ˚i, they are either
incomparable (ﬁrst disjunct), or the relation R holds symmetrically for each other (second dis-
junct). is generalizes standard notions of strict and non-strict weak orders that allow only one
of the conditions.
Deﬁnition 6.11 Optimiztic Minimal Weak Order Extension.
Let R; R0  O  O such that
R is a partial order.
1. R0 is a weak order extension of R if and only if it is a weak order and R0  R.
2. R0 is a minimal weak order extension of R if and only if it is a weak order extension of R, and
there exists no weak order R00 extending R such that R00  R0. Equivalently,¹ R0 corresponds
to a sequence of subsets ˚0 : : : ˚n of O (Deﬁnition 6.10) s.t. 8i < n W 9 2 ˚i; 0 2 ˚iC1 W
R0.
3. R0 is an optimiztic minimal weak order extension of R if and only if it is a minimal weak or-
der extension, and it corresponds to a sequence ˚0; : : : ; ˚n where there exists no weak order
¹Minimal weak order extension was characterized by Bertet et al. [7].

90
6. ORDERING ALTERNATIVES WITH RESPECT TO PREFERENCE
extension R00 which corresponds to a sequence 	0; 	1; : : : 	m s.t.  2 ˚i ^  2 	j ^ j < i.

A minimal weak order extension of an order R is a weak order extension of R “closest”
to R. In an optimiztic minimal weak order extension of R, an element is placed at the highest
possible level in any weak order extending R. Similarly, one can describe pessimistic minimal
weak order extension of R, where the elements are placed at the lowest possible level in any weak
order extended R.
Consider the following partial order over elements fA; B; P; D; Eg:
A  E; B  E; P  D
(6.4)
ere are multiple minimal weak order extensions; some of them are presented below.
Order 1.
˚0 D fA; B; P; Dg;
˚1 D fEg
Order 2.
˚0 D fA; Bg;
˚1 D fP; D; Eg
Order 3.
˚0 D fA; P; Dg;
˚1 D fB; Eg
Note that Order 1 is the optimiztic minimal weak order extension of the partial order; the
elements are placed at the highest possible level. e Order 2, on the other hand, is one of the
pessimistic extensions; one where the elements are placed in the lowest possible levels.
Example6.12
For the running example in this chapter (see Figure 6.1(b)), note that the ordering
is as follows.
˚0 D ;; ˚1 D fa; dg; ˚2 D fb; ab; adg; ˚3 D fc; bd; bcg; ˚4 D fac; abd; cdg; ˚5 D
fabc; acd; bcdg; ˚6 D fabcdg
Consider an interesting case when the preference statements p3 and p5 are removed from
the preference speciﬁcation in Figure 6.1(a). en the corresponding induced preferences (im-
portance ﬂips) fa; dg  fbg and fa; bg  fa; dg would be removed from the induced preference
graph. In that case, the new optimiztic minimal weak order extension generated would be as
follows.
˚0 D ;; ˚1 D fa; b; dg; ˚2 D fab; adg; ˚3 D fc; bd; bcg; ˚4 D fac; abd; cdg; ˚5 D
fabc; acd; bcdg; ˚6 D fabcdg
In the above, b is promoted to ˚1 to maintain the optimiztic minimal weak order extension
property, although the ordering would remain a weak order extension even if b is placed between
˚1 and ˚2. Note that in general, minimality is important to ensure that the generated extension of
the partial order does not make any more distinction between alternatives than necessary. In other
words, if minimality is not present, then the extension computed may introduce arbitrary levels
in the weak order extension that are not warranted. An optimiztic minimal weak order extension

4. SUMMARY
91
ensures that the alternatives receive the maximum “ranking” possible in any given minimal weak
order extension. is would be useful in settings such as the security example in this chapter, as
well as in recommender systems where the user may want to obtain as many choices as possible
that are most preferred at any given level.
eorem 6.13 Correctness of Next-Pref (Algorithm 1).
Given a preference speciﬁcation P with
preference relation , N-Pgenerates the sequence of alternative sets ˚0; : : : ; ˚n, which corre-
sponds to the optimiztic minimal weak order extension of the partial order induced by P with preference
relation .
In this chapter, we focused on optimistic extension, as that intuitively provides users with the
largest number of non-dominating possibilities as early as possible. However, if a certain appli-
cation requires ﬁnding the pessimistic minimal weak order extension of a relation R, our algo-
rithm can do that as well. First, reverse the relation R to obtain R0, i.e., .A; B/ 2 R results in
.B; A/ 2 R0. en, using our algorithm, compute the optimiztic minimal weak order extension
of R0, the reverse of which is the pessimistic minimal weak order extension of R.
4
SUMMARY
We presented a generic model checking based technique to automatically compute a sequence
of next preferred alternatives with respect to preference speciﬁcations. Our approach involves
encoding the preference semantics directly as a Kripke model input of a model checker, along
with a novel strategy to iteratively reﬁne the Kripke model and to rewrite temporal properties to
be veriﬁed such that the model checker automatically outputs a sequence of alternatives in order of
preference. We also characterized the sequence as the optimiztic minimal weak order extension of
the partial order induced by the preferences. is property guarantees that an alternative is placed
at the highest possible level in any weak order respecting the preference semantics. To the best of
our knowledge, this is the ﬁrst approach to automatically compute a sequence of next preferred
alternatives even when the induced preference graph has cycles.


93
C H A P T E R
7
CRISNER: A Practically
Eﬃcient Reasoner for
Qualitative Preferences
In this chapter, we present CRISNER (Conditional & Relative Importance Statement Network
PrEference Reasoner),¹ a tool that provides exact and practically eﬃcient reasoning about quali-
tative preferences in popular CP-languages.² e tool uses a model checking engine to translate
preference speciﬁcations and queries into appropriate Kripke models and veriﬁable properties
over them respectively, as per techniques outlined in the earlier chapters of this book. e salient
features of CRISNER are: (1) exact and provably correct query answering for testing dominance,
consistency with respect to a preference speciﬁcation, and testing equivalence and subsumption
of two sets of preferences; (2) automatic generation of proofs evidencing the correctness of an-
swers produced by CRISNER to any of the above queries; (3) XML inputs and outputs that
make it portable and pluggable into other applications. We also describe the extensible architec-
ture of CRISNER, which can be extended to new preference formalisms based on ceteris paribus
semantics that may be developed in the future.
1
OVERVIEW
Given a preference speciﬁcation P , CRISNER ﬁrst succinctly encodes the induced prefer-
ence graph (IPG) ı.P / into a Kripke structure model KP in the language of the NuSMV
model checker (for details, please see Chapters 4 and 5). For reasoning with respect to each P ,
CRISNER generates the model KP only once. Subsequently for each preference query q posed
against P , CRISNER translates q into a temporal logic formula 'q in computation-tree tempo-
ral logic (CTL) (see Chapter 4) such that KP ˆ 'q if and only if q holds true according to the
ceteris paribus semantics of P . CRISNER then queries the model checker with the model KP
and 'q which either aﬃrms q or returns false with a counterexample. For answering queries re-
lated to equivalence and subsumption checking of two sets of preferences P1 and P2, CRISNER
constructs a combined IPG KP12 (see Chapter 5) and uses temporal queries in CTL to identify
whether every dominance that holds in P1 also holds in P2 and vice-versa.
¹CRISNER is available at http://www.ece.iastate.edu/~gsanthan/crisner.html. An earlier version of the tool,
“iPref-R,” is available at http://fmg.cs.iastate.edu/project-pages/preference-reasoner/.
²Henceforth, we will refer to the languages CP-nets, TCP-nets, and CP-theories collectively as “CP-languages” for brevity.

94
7. CRISNER:APRACTICALLYEFFICIENTREASONERFORQUALITATIVEPREFERENCES
1.1
JUSTIFICATION OF QUERY ANSWERS
e answers to queries computed by CRISNER are exact and provably correct for dominance,
consistency, equivalence, and subsumption queries. Because CRISNER uses the model checker
for answering queries, CRISNER is also able to provide proofs or justiﬁcations to queries that
returned false. CRISNER automatically builds proofs evidencing why the query did not hold
true, by collecting and examining the model checker’s counterexample and producing a sequence
of preference statements whose application proves the correctness of CRISNER’s result.
1.2
TOOL ARCHITECTURE
CRISNER is developed in pure Java and is domain agnostic in the sense that any set of variables
with any domain can be included in a preference speciﬁcation, although it is optimized for vari-
ables with binary domains. It accepts preference speciﬁcations and queries in an XML format,
which provides a common and generic syntax using which users can specify preferences for CP-
languages. e results (answers and proofs) for the corresponding queries are also saved in the
form XML, so that the results can be further transformed into vocabulary that is more easily
understandable by domain users. We describe the architecture of CRISNER and how it can be
extended to other ceteris paribus preference formalisms that may be developed in the future.
CRISNER has been in development for over two years, and to our knowledge, CRISNER
is one of the ﬁrst attempts to develop practical tools for hard qualitative preference reasoning prob-
lems. We hope that CRISNER inspires the use of qualitative preference formalisms in practical,
real world applications, and the development of further qualitative preference languages.
1.3
PREFERENCE QUERIES
Computing answers to preference queries with respect to a given preference speciﬁcation in the
ceteris paribus semantics amounts to making querying properties related to reachability on the
induced preference graph. We consider the following preference queries that have been imple-
mented in CRISNER in this chapter.
Given a preference speciﬁcation P
consisting of a set of preference statements
fp1; p2 : : : png, and two outcomes ˛; ˇ 2 O, (a) dominance testing (˛ P ˇ) asks whether there
is a sequence of improving ﬂips from ˇ to ˛ in ı.P / (see Chapter 4) ; and (b) consistency testing
asks whether the preferences induced by P are consistent, i.e., is there is a cycle in ı.P / (see Chap-
ter 6). Given two preference speciﬁcations P1; P2 and two outcomes ˛; ˇ 2 O, (c) preference
subsumption (P1 v P2) asks whether ˛ P1 ˇ ) ˛ P2 ˇ (see Chapter 5); and (d) preference
equivalence (P1  P2) asks whether P1 v P2 and P2 v P1 (see Chapter 5).
e technique for encoding P computing the answers to the various preference queries has
been covered in the above mentioned chapters respectively. e interested reader will ﬁnd it useful
to review and refer to these chapters for details on the modeling techniques and the formulation
of the corresponding temporal logic formulas.

2. XML INPUT LANGUAGE
95
2
XML INPUT LANGUAGE
CRISNER accepts a preference speciﬁcation for any of the CP-languages in an XML format. e
preference speciﬁcation consists of a declaration of the preference variables, their domains, and
a set of preference statements. Each preference statement is of the form discussed in Chapter 2,
and expresses an intra-variable and/or relative importance preference relation over the domain of
a variable.
2.1
DEFINING PREFERENCE VARIABLES
Figure 7.1 shows part of a preference speciﬁcation deﬁning variables and their domains. e
preference variable a has a binary domain with values 0 and 1, whereas x has a domain f0; 1; 2g.
Note that CRISNER supports domain valuations with string values that are combinations of
letters and numbers, as allowed by NuSMV.
<VARIABLE>
<NAME>a</NAME>
<DOMAIN-VALUE>0</DOMAIN-VALUE>
<DOMAIN-VALUE>1</DOMAIN-VALUE>
</VARIABLE>
(a)
<VARIABLE>
<NAME>x</NAME>
<DOMAIN-VALUE>0</DOMAIN-VALUE>
<DOMAIN-VALUE>1</DOMAIN-VALUE>
<DOMAIN-VALUE>2</DOMAIN-VALUE>
</VARIABLE>
(b)
Figure 7.1: XML encoding of deﬁnitions of preference variable a with domain size 2 and 3.
2.2
SPECIFYING CONDITIONAL PREFERENCE STATEMENTS
e listing in Figure 7.2 shows a portion of a preference speciﬁcation that declares preferences
over values of the variable c conditioned on the variables b and a respectively. e STATEMENT-ID
is an identiﬁer to a unique preference statement in a preference speciﬁcation. e VARIABLE tag
identiﬁes the variable on whose domain preferences are being speciﬁed. e CONDITION tag is used
to specify the condition for the preference statement as an assignment of the parent variable to
its domain value. Note that there can be multiple conditions, in which case there will be multiple
CONDITION tags, or no conditions (unconditional preference) as well in a preference statement. In
addition, there can also be multiple preferences for a variable, e.g., if there is a variable with domain
of 0; 1; 2 then to specify the total order 0  1  2 one would encode 0  1 as one preference
followed by 1  2. CRISNER requires that the variable names and their assignments match with
the preference variable declarations in the ﬁle; otherwise the tool reports an appropriate error
stating that the variable is not deﬁned in the preference speciﬁcation.

96
7. CRISNER:APRACTICALLYEFFICIENTREASONERFORQUALITATIVEPREFERENCES
<PREFERENCE-STATEMENT>
<STATEMENT-ID>p3</STATEMENT-ID>
<VARIABLE>c</VARIABLE>
<CONDITION>b=0</CONDITION>
<PREFERENCE>0:1</PREFERENCE>
</PREFERENCE-STATEMENT>
(a)
<PREFERENCE-STATEMENT>
<STATEMENT-ID>p4</STATEMENT-ID>
<VARIABLE>c</VARIABLE>
<CONDITION>a=0</CONDITION>
<PREFERENCE>1:0</PREFERENCE>
</PREFERENCE-STATEMENT>
(b)
Figure 7.2: XML encoding of conditional preference statements p3 and p4 in a CP-net.
2.3
SPECIFYING RELATIVE IMPORTANCE PREFERENCES
In order to allow speciﬁcation of relative importance of one variable over another, as in a TCP-
net, CRISNER allows the tag REGARDLESS-OF within a preference statement. Figure 7.3(a) de-
clares a preference statement that says (in addition to the fact that a D 0 a a D 1) that a is
relatively more important than b. In order to specify relative importance of one variable over a
set of other variables (simultaneously) as allowed by a CP-theory, the user can specify multiple
REGARDLESS-OF tags within the same preference statement. For instance, Figure 7.3(b) shows a
preference statement that declares that a is relatively more important than fb; cg.
<PREFERENCE-STATEMENT>
<STATEMENT-ID>p1</STATEMENT-ID>
<VARIABLE>a</VARIABLE>
<PREFERENCE>0:1</PREFERENCE>
<REGARDLESS-OF>b</REGARDLESS-OF>
</PREFERENCE-STATEMENT>
(a)
<PREFERENCE-STATEMENT>
<STATEMENT-ID>p1</STATEMENT-ID>
<VARIABLE>a</VARIABLE>
<PREFERENCE>0:1</PREFERENCE>
<REGARDLESS-OF>b</REGARDLESS-OF>
<REGARDLESS-OF>c</REGARDLESS-OF>
</PREFERENCE-STATEMENT>
(b)
Figure 7.3: XML encoding of conditional preference statements p3 and p4 in a CP-net.
e sample XML input ﬁle listings for the preference speciﬁcations used for the cyberde-
fense example from Chapter 1 are provided in Appendix B.
3
ENCODING PREFERENCES AS SMV MODELS
CRISNER encodes Kripke models for a preference speciﬁcation as described earlier in Chap-
ters 4, 5, and 6 for the corresponding preference reasoning tasks. Here we discuss speciﬁc con-
structs in the NuSMV model checker used by CRISNER for this encoding using the examples
introduced in this chapter.

3. ENCODING PREFERENCES AS SMV MODELS
97
3.1
ENCODING PREFERENCE VARIABLES & AUXILIARY VARIABLES
In order to encode the CP-net P1 in our earlier example, CRISNER generates the code for the
SMV model as shown in Figure 7.4. We explain the translation of a preference speciﬁcation into
an SMV model by CRISNER through this example.
CRISNER deﬁnes just the main module, with three variables corresponding to the pref-
erence variables in P1 and another variable g, which we will explain shortly. We overload a; b; c
to refer to variables in the Kripke model and variables in the preference speciﬁcation, hence val-
uations of a; b; c in a state s in the Kripke model respectively correspond to the valuations of the
preference variables a; b; c in the preference speciﬁcation P . e variables a; b; c are state vari-
ables in the SMV model, i.e., their valuations stored by the model checker for each state explored
during model checking.
e IVAR variables cha; chb; chc are modeled as input variables, i.e., their valuations are
not stored as part of each state. e model checker initializes them non-deterministically for
each state so that all paths are open for exploration by the model checker during veriﬁcation.
Each preference statement is translated into an appropriate guard condition for a transition in the
Kripke model, and the semantics of variables cha; chb; chc either allows or disallows the change
in the value of the corresponding preference variable a; b; c, in accordance with the improving
ﬂip semantics.
Identifying transitions corresponding to improving ﬂips. e additional g variable is deﬁned to
be true exactly when the model checker transitions from a state corresponding to one outcome
to a state corresponding to another outcome (not transitions between states corresponding to
the same outcome). Hence, we can conveniently refer to transitions in the Kripke models that
correspond to improving ﬂips by constraining g to have valuation 1 in the destination state.
Referencing start states explored by NuSMV. e FROZEN variables a_0, b_0, c_0 are con-
strained to be ﬁxed with the values of the variables a; b; c respectively at the start of the model
checking algorithm via the DEFINE and INIT constructs. is allows us to refer to the state non-
deterministically picked by the model checker as the start of model exploration using start. is
is used for computing consistency, preference subsumption, and preference equivalence.
3.2
ENCODING PREFERENCE STATEMENTS
Encoding Intra-variable Preferences. To encode an intra-variable preference statement for a
variable x with a condition  on the other variables, the next(x) construct encodes guards such
that the valuations of the other variables correspond to those in the condition , and valuation of
chx is 1 while all other ch variables are set to 0. As an example, next(a) includes a transition such
that c changes from 1 to 0 precisely when b D 0 and chc D 1 (cha D 0; chb D 0, allowing only c
to change in that transition), which corresponds to the improving ﬂip induced by p3 conditioned
on the value of a in the CP-net P1 (Figure 7.4).

98
7. CRISNER:APRACTICALLYEFFICIENTREASONERFORQUALITATIVEPREFERENCES
MODULE main
VAR
a : {0,1};
c : {0,1};
b : {0,1};
g : {0,1};
FROZENVAR
a_0 : {0,1};
b_0 : {0,1};
c_0 : {0,1};
IVAR
cha : {0,1};
chb : {0,1};
chc : {0,1};
DEFINE
start := a=a_0
& b=b_0 & c=c_0;
INIT start=TRUE;
ASSIGN
next(a) := case
a=1 & cha=1 & chb=0 & chc=0 : 0;
TRUE : a;
esac;
next(c) := case
c=1 & b=0 & cha=0 & chb=0 & chc=1 : 0;
TRUE : c;
esac;
next(b) := case
b=0 & c=0 & cha=0 & chb=1 & chc=0 : 1;
TRUE : b;
esac;
next(g) := case
a=1 & cha=1 & chb=0 & chc=0 : 1;
c=1 & b=0 & cha=0 & chb=0 & chc=1 : 1;
b=0 & c=0 & cha=0 & chb=1 & chc=0 : 1;
TRUE: 0;
esac;
Figure 7.4: SMV code for Kripke model encoding ı.P1/.
Encoding Relative Importance. For modeling relative importance preference statements, mul-
tiple IVAR variables can be assigned 1 in guard conditions such that the more important and less
important preference variables can change in the same transition—corresponding to an improv-
ing ﬂip for relative importance. For example, Figure 7.5 shows a snippet of the SMV code that
models the transitions arising from the relative importance of a over b as in the TCP-net P3
shown in Figure 2.1(a)(c). Note that cha and chb are set to 1 for the second guard condition of
next(b), allowing a to change to a preferred value trading oﬀb. In order to model relative im-
portance as in a CP-theory where one variable is more important than multiple others, a similar
encoding is used, except that all the corresponding ch variables are set to 1.
next(b) :=
case
b=0 & c=0 & cha=0 & chb=1 & chc=0 : 1;
a=1 & cha=1 & chb=1 & chc=0 : {0,1};
TRUE : b;
esac;
Figure 7.5: Encoding relative importance preferences for the TCP-net P3.

4. ARCHITECTURE
99
3.3
JUSTIFICATION OF QUERY RESULTS
In addition to answering preference queries posed against preference speciﬁcations, CRISNER
also provides a justiﬁcation of the result where appropriate. In order to obtain justiﬁcation,
CRISNER uses the counterexamples returned by the NuSMV model checker whenever a tem-
poral logic formula is not satisﬁed.
Extracting a Proof of Dominance. In the case of a dominance query, if CRISNER returns true,
we construct another temporal logic formula that states the negation of the dominance relation-
ship, which obtains a sequence of outcomes corresponding to an improving ﬂipping sequence
from the lesser preferred to the more preferred outcome from the model checker. Suppose that
we want to obtain proof that an alternative ˛ dominates another alternative ˇ. is means that
'ˇ ! EF'˛ holds. We then verify :.'ˇ ! EF'˛/, which obtains a sequence of states in the
Kripke model corresponding to an improving ﬂipping sequence from ˇ to ˛ from the model
checker corresponding to an improving ﬂipping sequence from ˇ to ˛ which serves as the proof
of dominance.
Extracting a Proof of Inconsistency.
In the case of a consistency query (see Section 1.3)
CRISNER returns a sequence of outcomes corresponding to an improving ﬂipping sequence
from an outcome to itself (indicating a cycle in the induced preference graph) whenever the pref-
erence speciﬁcation input is inconsistent.
Extracting a Proof of Non-subsumption.
For a preference subsumption query P1 v P2,
CRISNER provides an improving ﬂip from one outcome to another induced by P1 but not in-
duced by P2 whenever the query does not hold.
In the above, counterexamples returned by NuSMV are in terms of states and transitions in
the Kripke model; CRISNER parses and transforms the counterexamples back into a form that
relates to the preference variables, outcomes, and improving ﬂips in the induced preference graph
of the preference speciﬁcation, and saves it in an XML format.
4
ARCHITECTURE
CRISNER is built using the Java programming language.³ e architecture of CRISNER consists
of several components as depicted in Figure 7.8.
e XML parser is used to parse the preference speciﬁcations and preference queries input
by the user.⁴ e CP-language translator is a critical component that constructs the SMV code
for the Kripke model for the preference speciﬁcation input. It declares the necessary variables
with their domains, sets up the DEFINE, TRANS, and INIT constraints, and ﬁnally generates guard
conditions for enabling transitions corresponding to improving ﬂips induced by each preference
statement (as discussed in Chapter 4).
³ird party libraries used by CRISNER are listed in the project site [80].
⁴While currently CRISNER does not use XML schema or DTD to validate the XML input, we plan to enforce that in the
future.

100
7. CRISNER:APRACTICALLYEFFICIENTREASONERFORQUALITATIVEPREFERENCES
CRISNER provides two interfaces for preference reasoning. e ﬁrst is a simple com-
mand line menu-driven console interface where the user can provide either (a) one preference
speciﬁcation as input and then use the menu to pose dominance and consistency queries, or (b)
two preference speciﬁcations as input and pose a subsumption or equivalence query. e answer
(true/false) obtained and the justiﬁcation for the answer (where possible) is provided on the
console. Figure 7.6 shows the command line interface in which the user queries for consistency
and obtains a negative result along with a cycle in the induced preference graph as evidence.
Figure 7.7 shows a similar interaction of a user with CRISNER for preference equivalence test-
ing with respect to two preference speciﬁcations. Another way of using CRISNER is to specify
preference queries in an XML ﬁle that contains a dominance or consistency or preference equiv-
alence or subsumption query, and identiﬁes the preference speciﬁcation against which the query
should be executed. e query translator component parses queries speciﬁed in XML format and
provides it to the Reasoner component.
C:\> java -jar CRISNER-full.jar -s samples\cycle-cpnet.xml -m nusmv
Parsing preference specification ... samples\cycle-cpnet.xml
Reasoning options:
[1] Test Dominance
[2] Test Dominance Performance
[3] Test Consistency
[4] Test Subsumption*
[5] Test Equivalence*
[9] Exit
(* - For subsumption and equivalence, we currently require both specifications to have
the same set of preference variables and respective domains.)
Enter option: 3
Cycle found.
Sequence: [c = 1, a = 0, b = 0] -> [c = 0, a = 0, b = 0] -> [c = 1, a = 0, b = 0]
Result: FALSE; Proof: Sequence: [c = 1, a = 0, b = 0] -> [c = 0, a = 0, b = 0] -> [c =
1, a = 0, b = 0]
Figure 7.6: User interaction via command line interface to CRISNER to verify the consistency of a
preference speciﬁcation.
Further details about the XML tags and examples of preference speciﬁcation, preference
queries, and sample SMV code generated by CRISNER are available from CRISNER’s project
website http://www.ece.iastate.edu/~gsanthan/crisner.html. e same website also
contains a guide to navigating and using the menu-driven console user interface to CRISNER.

4. ARCHITECTURE
101
C:>java -jar CRISNER-full.jar -s samples\nocycle-cpnet.xml -m nusmv
Parsing preference specification ... samples\nocycle-cpnet.xml
Reasoning options:
[1] Test Dominance
[2] Test Dominance Performance
[3] Test Consistency
[4] Test Subsumption*
[5] Test Equivalence*
[9] Exit
(* - For subsumption and equivalence, we currently require both specifications to have
the same set of preference variables and respective domains.)
Enter option: 5
Please enter another XML preference specification to test equivalence:
Enter the location of the XML file: samples\nocycle-tcpnet.xml
Is nocycle-cpnet.xml subsumed by nocycle-tcpnet.xml ?
Subsumption holds.
Is nocycle-tcpnet.xml subsumed by nocycle-cpnet.xml ?
Subsumption does not hold.
false; nocycle-cpnet.xml is not equivalent to nocycle-tcpnet.xml
Figure 7.7: User interaction via command line interface to CRISNER to verify preference equiva-
lence.
e Reasoner is another critical component in CRISNER that constructs a temporal logic
formula corresponding to the preference query posed by the user, and invokes the NuSMV model
checker to verify the formula. e result and any counterexamples generated by the model checker
are parsed by the Results Translator, and saved in XML format by the XML Encoder. If a coun-
terexample is applicable to the preference query, then the Justiﬁer parses the XML output and
executes any followup queries on the model checker (e.g., veriﬁcation of the negation of the dom-
inance query) to provide the user with the appropriate proof.
4.1
EXTENDING CRISNER
CRISNER currently supports the CP-net, TCP-net, and CP-theory formalisms and can per-
form dominance, consistency, preference subsumption, and preference equivalence reasoning for
preference speciﬁcations in these languages. Some possible ways to extend the tool to support
other preference formalisms are given below.
Supporting Other Preference Languages. CRISNER can be extended to support another qual-
itative preference language, as long as the semantics of the language is described in terms of an
induced preference graph. In particular, the XML parser must be extended to support the syntax

102
7. CRISNER:APRACTICALLYEFFICIENTREASONERFORQUALITATIVEPREFERENCES
Figure 7.8: Architecture and components of CRISNER preference reasoner.
of the new language; and the CP-language translator must be extended to generate SMV code
according to the semantics of the new language. Support for the conditional importance network
or CI-net language (see Chapter 2, Section 2.6) can be added by implementing the encoding of
the CI-net semantics according to Section 2.1 of Chapter 4. One can think of supporting a new
preference formalism that allows expression of preferences of one partial assignment of variables
over another. In such a case, the CP-translator component can be extended to include a transla-
tion for such a preference statement into guard conditions in the Kripke model representing the
induced preference graph.
Supporting Other Preference Queries. CRISNER can also be extended to support new pref-
erence queries, for example, computing a weak order or total order extension of the partial order
induced by a preference speciﬁcation. In this case the Query Translator and Reasoner should be
extended to translate the new queries into one or more appropriate temporal logic formulas (as
described in [69]) and the Justiﬁer should be extended to construct and execute followup queries
that obtain proofs for the answers. e interested reader may try to implement the Next-Pref
algorithm presented in Chapter 6 for a better understanding of the model checking approach to
preference reasoning.
Adding Support for Other Model Checkers. CRISNER currently uses the NuSMV model
checker version 2.5.4 for verifying temporal queries speciﬁed in CTL. However, one may use
any other model checker which supports CTL in place of NuSMV, such as Cadence SMV [61].
e required change would then be to modify (a) the CP-translator module to generate Kripke
structure models that are compatible with the input language of the new model checker, and (b)

5. CONCLUDING REMARKS
103
the Results Translator to parse the traces of the new model checker and obtain results of the
speciﬁed queries.
AddingGUIsupport. CRISNER currently uses the console interface for user interaction, such as
specifying preference queries and reporting their results. Because CRISNER uses portable XML
formats for specifying inputs and reporting outputs of preference reasoning tasks, one may develop
a graphical user interface (GUI) front-end for CRISNER that binds to these XML formats.
Integrating such a GUI would be straightforward if the GUI is written to support the XML
formats of CRISNER.
4.2
SCALABILITY
While we have not yet performed a systematic experiment studying CRISNER’s runtime per-
formance for preference speciﬁcations of diﬀerent sizes (number of preference variables), our
preliminary tests have revealed that CRISNER answers dominance (including the computation
of justiﬁcation when applicable) in less than a minute on average for up to 30 variables on a 8GB
Corei7 Windows 7 desktop. Although CRISNER allows variables with domain size n > 2, the
model checking performance degrades quickly with increasing n; this can be alleviated by conﬁg-
uring the NuSMV model checker to use multi-way decision diagrams [4].
5
CONCLUDING REMARKS
We presented CRISNER, a tool for specifying and reasoning with qualitative preference lan-
guages such as CP-net, TCP-net and CP-theory. CRISNER translates preference speciﬁcations
and queries with respect to those provided in XML format into a Kripke structure and corre-
sponding temporal logic (CTL) queries in the input language of the NuSMV model checker.
Currently CRISNER supports dominance, consistency, preference equivalence, and subsumption
testing for the above languages. e obtained results from the model checker, including proofs of
dominance, inconsistency, or non-subsumption, are translated by CRISNER back in terms of the
vocabulary of the input preference speciﬁcation and saved in XML format. CRISNER’s archi-
tecture supports extension to other preference queries and preference languages such as CI-nets
whose semantics are in terms of the induced preference graph.


105
C H A P T E R
8
Postscript
e ability to represent and reason about preferences over a set of alternatives is central to rational
decision making. Preferences have been the subject of study in many disciplines including decision
theory [38, 54], social choice [78], game theory [67], and other subﬁelds of economics [62].
Artiﬁcial intelligence (AI) brings a fresh perspective to the study of preferences, and studies in
AI are concerned with how to eﬃciently represent and reason about preferences especially when
the preferences involve multiple attributes, resulting in a large combinatorial space of alternatives.
In this book, we have provided a tutorial introduction to modern techniques for reason-
ing about qualitative preferences with respect to a set of alternatives. We focused on CP-net,
TCP-net, CP-theory, and CI-net formalisms, and discussed their semantics according to the
ceteris paribus interpretation of preferences. Given the hardness of most reasoning tasks such as
dominance testing, preference equivalence, and subsumption testing, and ordering outcomes with
respect to a given set of preferences, we described an approach to reasoning with qualitative pref-
erences by translating them into a temporal logic model checking problem.
Our treatment has focused on reasoning about preferences of a single agent. In many set-
tings however, the preferences of multiple agents [32, 91] have to be considered in the decision
making process. is presents additional challenges: the preferences of diﬀerent agents may con-
ﬂict with each other. For example, while Jane wants a low-rent apartment in midtown Manhattan,
Jane’s husband John prefers a single family home on Long Island. One outcome could be pre-
ferred to another based on one agent’s preferences, while the opposite may be inferred from the
other agent’s preferences. Studies in the ﬁeld of social choice consider conﬂict resolution strate-
gies [72, 78] that minimally compromise individual preferences agents, or take advantage of the
organizational hierarchies that force the preferences of some agents to take precedence over the
preferences of others.
Our treatment has focused on preferences expressed directly over the alternatives and their
attributes. However, in many applications, the alternatives additionally have a compositional
structure: each alternative is composed of a collection of components that work together in order
to achieve a desired functionality, e.g., web services [81], team members [57], software systems
[68], buildings [83], plans [51], etc. A student wanting to design his program of study by choosing
a set of courses from the course catalog (see Section 1.2 from Chapter 1) also illustrates composi-
tional structure of alternatives. Recent work [84] has led to techniques for reasoning about pref-
erences over compositional systems by considering the preferences over attributes of alternatives
in terms of the preference over the attributes of their constituent components.

106
8. POSTSCRIPT
Further complications in reasoning about preferences arise from uncertainty associated with
the preferences or choices. Extending the methods described in this book to settings with uncer-
tainty remains an interesting area for further research.

107
A P P E N D I X
A
SMV Model Listings
Here we provide listings of the SMV models generated by the preference reasoning tool
CRISNER (see Chapter 7) for the preference speciﬁcations P CP , P T CP , and P CP T introduced
in Chapter 1 ﬁrst, and used in Chapters 2 and 4. Here you will also ﬁnd traces of output produced
by model checker NuSMV for speciﬁc CTL queries executed on these models. e reader will
ﬁnd this a useful reference especially when studying Chapters 4 and 7.
1
SMV MODEL LISTING FOR P CP
MODULE main
VAR
f : {Fix-Available,Fix-Unavailable};
a : {High,Low};
e : {Code-Available,Code-Unavailable};
IVAR
cha : {0,1};
che : {0,1};
chf : {0,1};
ASSIGN
next(f) :=
case
f=Fix-Available & e=Code-Available & cha=0 & che=0 & chf=1 : Fix-Unavailable;
-- #p3 : [e=Code-Available] => f=[Fix-Unavailable:Fix-Available]
>> [].
TRUE : f;
esac;
next(a) :=
case
a=High & cha=1 & che=0 & chf=0 : Low;
-- #p2 : null => a=[Low:High]
>> [].
TRUE : a;
esac;
next(e) :=
case
e=Code-Unavailable & cha=0 & che=1 & chf=0 : Code-Available;
-- #p1 : null => e=[Code-Available:Code-Unavailable]
>> [].
TRUE : e;
esac;

108
A. SMV MODEL LISTINGS
2
DOMINANCE QUERY AND NUSMV OUTPUT FOR P CP
SPEC (a=High & e=Code-Available & f=Fix-Available ->
!EX EF (a=Low & e=Code-Available & f=Fix-Unavailable))
-- specification (((a = High & e = Code-Available) & f = Fix-Available)
-> !(EX (EF ((a = Low & e = Code-Available) & f = Fix-Unavailable)))) is false.
-- as demonstrated by the following execution sequence.
Trace Description: CTL Counterexample
Trace Type: Counterexample
-> State: 1.1 <-
f = Fix-Available
a = High
e = Code-Available
-> Input: 1.2 <-
cha = 0
che = 0
chf = 1
-> State: 1.2 <-
f = Fix-Unavailable
-> Input: 1.3 <-
cha = 1
chf = 0
-> State: 1.3 <-
a = Low
3
SMV MODEL LISTING FOR P T CP
MODULE main
VAR
a : {High,Low};
e : {Code-Available,Code-Unavailable};
f : {Fix-Available,Fix-Unavailable};
IVAR
cha : {0,1};
che : {0,1};
chf : {0,1};
ASSIGN
next(a) :=
case
a=High & cha=1 & che=1 & chf=0 : Low;
-- #p'2 : [] => a=[Low:High]
>> [e].
TRUE : a;

4. DOMINANCE QUERY AND NUSMV OUTPUT FOR P T CP
109
esac;
next(e) :=
case
a=High & cha=1 & che=1 & chf=0 : {Code-Available,Code-Unavailable};
-- #p'2 : [] => a=[Low:High]
>> [e].
e=Code-Unavailable & cha=0 & che=1 & chf=0 : Code-Available;
-- #p1 : null => e=[Code-Available:Code-Unavailable]
>> [].
TRUE : e;
esac;
next(f) :=
case
f=Fix-Available & e=Code-Available & cha=0 & che=0 & chf=1 : Fix-Unavailable;
-- #p3 : [e=Code-Available] => f=[Fix-Unavailable:Fix-Available]
>> [].
TRUE : f;
esac;
4
DOMINANCE QUERY AND NUSMV OUTPUT FOR P T CP
SPEC (a=High & e=Code-Available & f=Fix-Available ->
!EX EF (a=Low & e=Code-Unavailable & f=Fix-Unavailable))
-- specification (((a = High & e = Code-Available) & f = Fix-Available)
-> !(EX (EF ((a = Low & e = Code-Unavailable) & f = Fix-Unavailable))))
is false
-- as demonstrated by the following execution sequence
Trace Description: CTL Counterexample
Trace Type: Counterexample
-> State: 1.1 <-
a = High
e = Code-Available
f = Fix-Available
-> Input: 1.2 <-
cha = 1
che = 0
chf = 0
-> State: 1.2 <-
-> Input: 1.3 <-
cha = 0
chf = 1
-> State: 1.3 <-
f = Fix-Unavailable
-> Input: 1.4 <-
cha = 1
che = 1
chf = 0
-> State: 1.4 <-
a = Low
e = Code-Unavailable

110
A. SMV MODEL LISTINGS
5
SMV MODEL LISTING FOR P CP T
MODULE main
VAR
f : {Fix-Available,Fix-Unavailable};
a : {High,Low};
e : {Code-Available,Code-Unavailable};
IVAR
cha : {0,1};
che : {0,1};
chf : {0,1};
ASSIGN
next(f) :=
case
a=High & cha=1 & che=1 & chf=1 : {Fix-Available,Fix-Unavailable};
-- #p''2 : [] => a=[Low:High]
>> [e, f].
f=Fix-Available & e=Code-Available & cha=0 & che=0 & chf=1 : Fix-Unavailable;
-- #p3 : [e=Code-Available] => f=[Fix-Unavailable:Fix-Available]
>> [].
TRUE : f;
esac;
next(a) :=
case
a=High & cha=1 & che=1 & chf=1 : Low;
-- #p''2 : [] => a=[Low:High]
>> [e, f].
TRUE : a;
esac;
next(e) :=
case
e=Code-Unavailable & cha=0 & che=1 & chf=0 : Code-Available;
-- #p1 : null => e=[Code-Available:Code-Unavailable]
>> [].
a=High & cha=1 & che=1 & chf=1 : {Code-Available,Code-Unavailable};
-- #p''2 : [] => a=[Low:High]
>> [e, f].
TRUE : e;
esac;
6
DOMINANCE QUERY AND NUSMV OUTPUT FOR P CP T
SPEC (a=High & e=Code-Unavailable & f=Fix-Unavailable ->
!EX EF (a=Low & e=Code-Available & f=Fix-Available))
-- specification (((a = High & e = Code-Unavailable) & f = Fix-Unavailable)
-> !(EX (EF ((a = Low & e = Code-Available) & f = Fix-Available))))
is false.
-- as demonstrated by the following execution sequence.

6. DOMINANCE QUERY AND NUSMV OUTPUT FOR P CP T
111
Trace Description: CTL Counterexample
Trace Type: Counterexample
-> State: 1.1 <-
f = Fix-Unavailable
a = High
e = Code-Unavailable
-> Input: 1.2 <-
cha = 0
che = 1
chf = 0
-> State: 1.2 <-
e = Code-Available
-> Input: 1.3 <-
cha = 1
chf = 1
-> State: 1.3 <-
f = Fix-Available
a = Low


113
A P P E N D I X
B
Providing XML Input to
CRISNER
Here we provide listings of the SMV models generated by the preference reasoning tool
CRISNER (see Chapter 7) for the preference speciﬁcations P CP , P T CP , and P CP T introduced
in Chapter 1 ﬁrst, and used in Chapters 2 and 4. e reader will ﬁnd this a useful reference to
build preference speciﬁcations that can be used to reason with CRISNER.
1
XML INPUT LISTING FOR P CP
<?xml version="1.0" encoding="us-ascii"?>
<PREFERENCE-SPECIFICATION>
<PREFERENCE-VARIABLE>
<VARIABLE-NAME>a</VARIABLE-NAME>
<DOMAIN-VALUE>Low</DOMAIN-VALUE>
<DOMAIN-VALUE>High</DOMAIN-VALUE>
</PREFERENCE-VARIABLE>
<PREFERENCE-VARIABLE>
<VARIABLE-NAME>e</VARIABLE-NAME>
<DOMAIN-VALUE>Code-Available</DOMAIN-VALUE>
<DOMAIN-VALUE>Code-Unavailable</DOMAIN-VALUE>
</PREFERENCE-VARIABLE>
<PREFERENCE-VARIABLE>
<VARIABLE-NAME>f</VARIABLE-NAME>
<DOMAIN-VALUE>Fix-Unavailable</DOMAIN-VALUE>
<DOMAIN-VALUE>Fix-Available</DOMAIN-VALUE>
</PREFERENCE-VARIABLE>
<PREFERENCE-STATEMENT>
<STATEMENT-ID>p1</STATEMENT-ID>
<PREFERENCE-VARIABLE>e</PREFERENCE-VARIABLE>
<PREFERENCE>Code-Available:Code-Unavailable</PREFERENCE>
</PREFERENCE-STATEMENT>
<PREFERENCE-STATEMENT>

114
B. PROVIDING XML INPUT TO CRISNER
<STATEMENT-ID>p2</STATEMENT-ID>
<PREFERENCE-VARIABLE>a</PREFERENCE-VARIABLE>
<PREFERENCE>Low:High</PREFERENCE>
</PREFERENCE-STATEMENT>
<PREFERENCE-STATEMENT>
<STATEMENT-ID>p3</STATEMENT-ID>
<PREFERENCE-VARIABLE>f</PREFERENCE-VARIABLE>
<CONDITION>e=Code-Available</CONDITION>
<PREFERENCE>Fix-Unavailable:Fix-Available</PREFERENCE>
</PREFERENCE-STATEMENT>
</PREFERENCE-SPECIFICATION>
2
XML INPUT LISTING FOR P T CP
<?xml version="1.0" encoding="us-ascii"?>
<PREFERENCE-SPECIFICATION>
<PREFERENCE-VARIABLE>
<VARIABLE-NAME>a</VARIABLE-NAME>
<DOMAIN-VALUE>Low</DOMAIN-VALUE>
<DOMAIN-VALUE>High</DOMAIN-VALUE>
</PREFERENCE-VARIABLE>
<PREFERENCE-VARIABLE>
<VARIABLE-NAME>e</VARIABLE-NAME>
<DOMAIN-VALUE>Code-Available</DOMAIN-VALUE>
<DOMAIN-VALUE>Code-Unavailable</DOMAIN-VALUE>
</PREFERENCE-VARIABLE>
<PREFERENCE-VARIABLE>
<VARIABLE-NAME>f</VARIABLE-NAME>
<DOMAIN-VALUE>Fix-Unavailable</DOMAIN-VALUE>
<DOMAIN-VALUE>Fix-Available</DOMAIN-VALUE>
</PREFERENCE-VARIABLE>
<PREFERENCE-STATEMENT>
<STATEMENT-ID>p1</STATEMENT-ID>
<PREFERENCE-VARIABLE>e</PREFERENCE-VARIABLE>
<PREFERENCE>Code-Available:Code-Unavailable</PREFERENCE>
</PREFERENCE-STATEMENT>
<PREFERENCE-STATEMENT>
<STATEMENT-ID>p'2</STATEMENT-ID>
<PREFERENCE-VARIABLE>a</PREFERENCE-VARIABLE>

3. XML INPUT LISTING FOR P CP T
115
<PREFERENCE>Low:High</PREFERENCE>
<REGARDLESS-OF>e</REGARDLESS-OF>
</PREFERENCE-STATEMENT>
<PREFERENCE-STATEMENT>
<STATEMENT-ID>p3</STATEMENT-ID>
<PREFERENCE-VARIABLE>f</PREFERENCE-VARIABLE>
<CONDITION>e=Code-Available</CONDITION>
<PREFERENCE>Fix-Unavailable:Fix-Available</PREFERENCE>
</PREFERENCE-STATEMENT>
</PREFERENCE-SPECIFICATION>
3
XML INPUT LISTING FOR P CP T
<?xml version="1.0" encoding="us-ascii"?>
<PREFERENCE-SPECIFICATION>
<PREFERENCE-VARIABLE>
<VARIABLE-NAME>a</VARIABLE-NAME>
<DOMAIN-VALUE>Low</DOMAIN-VALUE>
<DOMAIN-VALUE>High</DOMAIN-VALUE>
</PREFERENCE-VARIABLE>
<PREFERENCE-VARIABLE>
<VARIABLE-NAME>e</VARIABLE-NAME>
<DOMAIN-VALUE>Code-Available</DOMAIN-VALUE>
<DOMAIN-VALUE>Code-Unavailable</DOMAIN-VALUE>
</PREFERENCE-VARIABLE>
<PREFERENCE-VARIABLE>
<VARIABLE-NAME>f</VARIABLE-NAME>
<DOMAIN-VALUE>Fix-Unavailable</DOMAIN-VALUE>
<DOMAIN-VALUE>Fix-Available</DOMAIN-VALUE>
</PREFERENCE-VARIABLE>
<PREFERENCE-STATEMENT>
<STATEMENT-ID>p1</STATEMENT-ID>
<PREFERENCE-VARIABLE>e</PREFERENCE-VARIABLE>
<PREFERENCE>Code-Available:Code-Unavailable</PREFERENCE>
</PREFERENCE-STATEMENT>
<PREFERENCE-STATEMENT>
<STATEMENT-ID>p''2</STATEMENT-ID>
<PREFERENCE-VARIABLE>a</PREFERENCE-VARIABLE>
<PREFERENCE>Low:High</PREFERENCE>

116
B. PROVIDING XML INPUT TO CRISNER
<REGARDLESS-OF>e</REGARDLESS-OF>
<REGARDLESS-OF>f</REGARDLESS-OF>
</PREFERENCE-STATEMENT>
<PREFERENCE-STATEMENT>
<STATEMENT-ID>p3</STATEMENT-ID>
<PREFERENCE-VARIABLE>f</PREFERENCE-VARIABLE>
<CONDITION>e=Code-Available</CONDITION>
<PREFERENCE>Fix-Unavailable:Fix-Available</PREFERENCE>
</PREFERENCE-STATEMENT>
</PREFERENCE-SPECIFICATION>

117
A P P E N D I X
C
SMV Models & CTL Queries
for Preference Equivalence and
Subsumption
Here we provide listings of the SMV models generated by the preference reasoning tool
CRISNER (see Chapter 7) for the problem of reasoning about preference equivalence and sub-
sumption (see Chapter 5). e models presented here correspond to the Kripke structures en-
coding the combined induced preference graphs with respect to preference speciﬁcations P CP ,
P T CP , and P CP T introduced in Chapter 1.
1
SMV MODEL FOR K.P CP; P T CP/
MODULE main
VAR
f : {Fix-Available,Fix-Unavailable};
e : {Code-Available,Code-Unavailable};
a : {High,Low};
g1 : {0,1};
g2 : {0,1};
c__ : {0,1};
FROZENVAR
a_0 : {High,Low};
e_0 : {Code-Available,Code-Unavailable};
f_0 : {Fix-Available,Fix-Unavailable};
IVAR
cha : {0,1};
che : {0,1};
chf : {0,1};
DEFINE
change := cha=1 | che=1 | chf=1;
start := a=a_0 & e=e_0 & f=f_0;

118
C. SMVMODELS&CTLQUERIESFORPREFERENCEEQUIVALENCEANDSUBSUMPTION
TRANS !change -> c__=1;
TRANS change -> c__=0;
TRANS a_0=next(a_0) & e_0=next(e_0) & f_0=next(f_0);
INIT start=TRUE;
ASSIGN
next(f) :=
case
f=Fix-Available & e=Code-Available & cha=0 & che=0 & chf=1 : Fix-Unavailable;
-- #p3 : [e=Code-Available] => f=[Fix-Unavailable:Fix-Available
]
>> [].
f=Fix-Unavailable & e=Code-Available & cha=0 & che=0 & chf=1 : Fix-Available;
-- #p3 : [e=Code-Available] => f=[Fix-Unavailable:Fix-Available
]
>> [].
TRUE : f;
esac;
next(e) :=
case
e=Code-Unavailable & cha=0 & che=1 & chf=0 : Code-Available;
-- #p1 : null => e=[Code-Available:Code-Unavailable]
>> [].
a=Low & cha=1 & che=1 & chf=0 : {Code-Available,Code-Unavailable};
-- #p'2 : [] => a=[Low:High]
>> [e].
e=Code-Available & cha=0 & che=1 & chf=0 : Code-Unavailable;
-- #p1 : null => e=[Code-Available:Code-Unavailable]
>> [].
TRUE : e;
esac;
next(a) :=
case
a=High & cha=1 & che=0 & chf=0 : Low;
-- #p2 : null => a=[Low:High]
>> [].
a=Low & cha=1 & che=1 & chf=0 : High;
-- #p'2 : [] => a=[Low:High]
>> [e].
TRUE : a;
esac;
next(g1) :=
case
f=Fix-Available & e=Code-Available & cha=0 & che=0 & chf=1 : 1;
e=Code-Unavailable & cha=0 & che=1 & chf=0 : 1;
a=High & cha=1 & che=0 & chf=0 : 1;
TRUE: 0;
esac;
next(g2) :=
case
f=Fix-Unavailable & e=Code-Available & cha=0 & che=0 & chf=1 : 1;
a=Low & cha=1 & che=1 & chf=0 : 1;
e=Code-Available & cha=0 & che=1 & chf=0 : 1;
a=Low & cha=1 & che=1 & chf=0 : 1;

2. SMV MODEL FOR K.P T CP ; P CP T /
119
TRUE: 0;
esac;
2
SMV MODEL FOR K.P T CP; P CP T /
MODULE main
VAR
a : {High,Low};
e : {Code-Available,Code-Unavailable};
f : {Fix-Available,Fix-Unavailable};
g1 : {0,1};
g2 : {0,1};
c__ : {0,1};
FROZENVAR
a_0 : {High,Low};
e_0 : {Code-Available,Code-Unavailable};
f_0 : {Fix-Available,Fix-Unavailable};
IVAR
cha : {0,1};
che : {0,1};
chf : {0,1};
DEFINE
change := cha=1 | che=1 | chf=1;
start := a=a_0 & e=e_0 & f=f_0;
TRANS !change -> c__=1;
TRANS change -> c__=0;
TRANS a_0=next(a_0) & e_0=next(e_0) & f_0=next(f_0);
INIT start=TRUE;
ASSIGN
next(a) :=
case
a=High & cha=1 & che=1 & chf=0 : Low;
-- #p'2 : [] => a=[Low:High]
>> [e].
a=Low & cha=1 & che=1 & chf=1 : High;
-- #p''2 : [] => a=[Low:High]
>> [e, f].
TRUE : a;
esac;
next(e) :=
case
a=High & cha=1 & che=1 & chf=0 : {Code-Available,Code-Unavailable};

120
C. SMVMODELS&CTLQUERIESFORPREFERENCEEQUIVALENCEANDSUBSUMPTION
-- #p'2 : [] => a=[Low:High]
>> [e].
e=Code-Unavailable & cha=0 & che=1 & chf=0 : Code-Available;
-- #p1 : null => e=[Code-Available:Code-Unavailable]
>> [].
a=Low & cha=1 & che=1 & chf=1 : {Code-Available,Code-Unavailable};
-- #p''2 : [] => a=[Low:High]
>> [e, f].
e=Code-Available & cha=0 & che=1 & chf=0 : Code-Unavailable;
-- #p1 : null => e=[Code-Available:Code-Unavailable]
>> [].
TRUE : e;
esac;
next(f) :=
case
f=Fix-Available & e=Code-Available & cha=0 & che=0 & chf=1 : Fix-Unavailable;
-- #p3 : [e=Code-Available] => f=[Fix-Unavailable:Fix-Available
]
>> [].
a=Low & cha=1 & che=1 & chf=1 : {Fix-Available,Fix-Unavailable};
-- #p''2 : [] => a=[Low:High]
>> [e, f].
f=Fix-Unavailable & e=Code-Available & cha=0 & che=0 & chf=1 : Fix-Available;
-- #p3 : [e=Code-Available] => f=[Fix-Unavailable:Fix-Available
]
>> [].
TRUE : f;
esac;
next(g1) :=
case
a=High & cha=1 & che=1 & chf=0 : 1;
a=High & cha=1 & che=1 & chf=0 : 1;
e=Code-Unavailable & cha=0 & che=1 & chf=0 : 1;
f=Fix-Available & e=Code-Available & cha=0 & che=0 & chf=1 : 1;
TRUE: 0;
esac;
next(g2) :=
case
a=Low & cha=1 & che=1 & chf=1 : 1;
f=Fix-Unavailable & e=Code-Available & cha=0 & che=0 & chf=1 : 1;
a=Low & cha=1 & che=1 & chf=1 : 1;
a=Low & cha=1 & che=1 & chf=1 : 1;
e=Code-Available & cha=0 & che=1 & chf=0 : 1;
TRUE: 0;
esac;
3
SMV MODEL FOR K.P CP T ; P CP/
MODULE main
VAR
f : {Fix-Available,Fix-Unavailable};
a : {High,Low};
e : {Code-Available,Code-Unavailable};

3. SMV MODEL FOR K.P CP T ; P CP /
121
g1 : {0,1};
g2 : {0,1};
c__ : {0,1};
FROZENVAR
a_0 : {High,Low};
e_0 : {Code-Available,Code-Unavailable};
f_0 : {Fix-Available,Fix-Unavailable};
IVAR
cha : {0,1};
che : {0,1};
chf : {0,1};
DEFINE
change := cha=1 | che=1 | chf=1;
start := a=a_0 & e=e_0 & f=f_0;
TRANS !change -> c__=1;
TRANS change -> c__=0;
TRANS a_0=next(a_0) & e_0=next(e_0) & f_0=next(f_0);
INIT start=TRUE;
ASSIGN
next(f) :=
case
a=High & cha=1 & che=1 & chf=1 : {Fix-Available,Fix-Unavailable};
-- #p''2 : [] => a=[Low:High]
>> [e, f].
f=Fix-Available & e=Code-Available & cha=0 & che=0 & chf=1 : Fix-Unavailable;
-- #p3 : [e=Code-Available] => f=[Fix-Unavailable:Fix-Available
]
>> [].
f=Fix-Unavailable & e=Code-Available & cha=0 & che=0 & chf=1 : Fix-Available;
-- #p3 : [e=Code-Available] => f=[Fix-Unavailable:Fix-Available
]
>> [].
TRUE : f;
esac;
next(a) :=
case
a=High & cha=1 & che=1 & chf=1 : Low;
-- #p''2 : [] => a=[Low:High]
>> [e, f].
a=Low & cha=1 & che=0 & chf=0 : High;
-- #p2 : null => a=[Low:High]
>> [].
TRUE : a;
esac;
next(e) :=
case
a=High & cha=1 & che=1 & chf=1 : {Code-Available,Code-Unavailable};

122
C. SMVMODELS&CTLQUERIESFORPREFERENCEEQUIVALENCEANDSUBSUMPTION
-- #p''2 : [] => a=[Low:High]
>> [e, f].
e=Code-Unavailable & cha=0 & che=1 & chf=0 : Code-Available;
-- #p1 : null => e=[Code-Available:Code-Unavailable]
>> [].
e=Code-Available & cha=0 & che=1 & chf=0 : Code-Unavailable;
-- #p1 : null => e=[Code-Available:Code-Unavailable]
>> [].
TRUE : e;
esac;
next(g1) :=
case
a=High & cha=1 & che=1 & chf=1 : 1;
f=Fix-Available & e=Code-Available & cha=0 & che=0 & chf=1 : 1;
a=High & cha=1 & che=1 & chf=1 : 1;
a=High & cha=1 & che=1 & chf=1 : 1;
e=Code-Unavailable & cha=0 & che=1 & chf=0 : 1;
TRUE: 0;
esac;
next(g2) :=
case
a=Low & cha=1 & che=0 & chf=0 : 1;
e=Code-Available & cha=0 & che=1 & chf=0 : 1;
f=Fix-Unavailable & e=Code-Available & cha=0 & che=0 & chf=1 : 1;
TRUE: 0;
esac;
4
PREFERENCE SUBSUMPTION QUERY P T CP v P CP ON
K.P T CP; P CP/
-- specification .
AX ((g1 = 1 & c__ = 1)
-> EX E [ (g2 = 0 & g1 = 0) U E [ g2 = 1 U (start & g2 = 1) ]
] )
is false
-- as demonstrated by the following execution sequence
Trace Description: CTL Counterexample
Trace Type: Counterexample
-> State: 1.1 <-
a_0 = High
e_0 = Code-Available
f_0 = Fix-Unavailable
e = Code-Available
f = Fix-Unavailable
a = High
g1 = 0
g2 = 0
c__ = 0
start = TRUE
-> Input: 1.2 <-

5. PREFERENCE SUBSUMPTION QUERY P CP v P T CP ON K.P CP ; P T CP /
123
cha = 1
che = 1
chf = 0
change = TRUE
-> State: 1.2 <-
e = Code-Unavailable
a = Low
g1 = 1
c__ = 1
start = FALSE
5
PREFERENCE SUBSUMPTION QUERY P CP v P T CP ON
K.P CP; P T CP/
-- specification .
AX ((g1 = 1 & c__ = 1)
-> EX E [ (g2 = 0 & g1 = 0) U E [ g2 = 1 U (start & g2 = 1) ]
] )
is true
6
PREFERENCE SUBSUMPTION QUERY P T CP v P CP T ON
K.P T CP; P CP T /
-- specification .
AX ((g1 = 1 & c__ = 1)
-> EX E [ (g2 = 0 & g1 = 0) U E [ g2 = 1 U (start & g2 = 1) ]
] )
is true
7
PREFERENCE SUBSUMPTION QUERY P CP T v P T CP ON
K.P CP T ; P T CP/
-- specification .
AX ((g1 = 1 & c__ = 1)
-> EX E [ (g2 = 0 & g1 = 0) U E [ g2 = 1 U (start & g2 = 1) ]
] )
is false
-- as demonstrated by the following execution sequence
Trace Description: CTL Counterexample
Trace Type: Counterexample
-> State: 1.1 <-
a_0 = High
e_0 = Code-Unavailable
f_0 = Fix-Unavailable
f = Fix-Unavailable

124
C. SMVMODELS&CTLQUERIESFORPREFERENCEEQUIVALENCEANDSUBSUMPTION
e = Code-Unavailable
a = High
g1 = 0
g2 = 0
c__ = 0
start = TRUE
-> Input: 1.2 <-
cha = 1
che = 1
chf = 1
change = TRUE
-> State: 1.2 <-
f = Fix-Available
e = Code-Available
a = Low
g1 = 1
c__ = 1
start = FALSE
8
PREFERENCE SUBSUMPTION QUERY P CP v P CP T ON
K.P CP T ; P T CP/
-- specification .
AX ((g1 = 1 & c__ = 1)
-> EX E [ (g2 = 0 & g1 = 0) U E [ g2 = 1 U (start & g2 = 1) ]
] )
is true
9
PREFERENCE SUBSUMPTION QUERY P CP T v P T CP ON
K.P CP T ; P CP/
-- specification .
AX ((g1 = 1 & c__ = 1)
-> EX E [ (g2 = 0 & g1 = 0) U E [ g2 = 1 U (start & g2 = 1) ]
] )
is false
-- as demonstrated by the following execution sequence
Trace Description: CTL Counterexample
Trace Type: Counterexample
-> State: 1.1 <-
a_0 = High
e_0 = Code-Unavailable
f_0 = Fix-Unavailable
f = Fix-Unavailable
a = High
e = Code-Unavailable

9. PREFERENCE SUBSUMPTION QUERY P CP T v P T CP ON K.P CP T ; P CP /
125
g1 = 0
g2 = 0
c__ = 0
start = TRUE
-> Input: 1.2 <-
cha = 1
che = 1
chf = 1
change = TRUE
-> State: 1.2 <-
f = Fix-Available
a = Low
e = Code-Available
g1 = 1
c__ = 1
start = FALSE


127
Bibliography
[1] P. Abdulla, A. Bouajjani, and B. Jonsson. On-the-ﬂy analysis of systems with unbounded,
lossy ﬁfo channels. In A. Hu and M. Vardi, editors, Proceedings of the International Conference
on Computer Aided Veriﬁcation, volume 1427 of Lecture Notes in Computer Science, pages 305–
318. Springer Berlin Heidelberg, 1998. 34
[2] S. B. Akers. Binary decision diagrams. IEEE Transactions on Computers, 27(6):509–516,
June 1978. DOI: 10.1109/TC.1978.1675141. 40
[3] M. F. Ashby. Chapter 8 - case studies: Multiple constraints and conﬂicting objectives. In
M. F. Ashby, editor, Materials Selection in Mechanical Design (Fourth Edition), pages 217 –
242. Butterworth-Heinemann, Oxford, fourth edition, 2011. 47, 52
[4] J. Babar and A. Miner. Meddly: Multi-terminal and edge-valued decision diagram library.
In Seventh International Conference on the Quantitative Evaluation of Systems, pages 195–
196. IEEE, 2010. DOI: 10.1109/QEST.2010.34. 103
[5] C. Baier and J.-P. Katoen. Principles of Model Checking. MIT Press, 2008. 38, 40, 43
[6] T. Ball, V. Levin, and S. K. Rajamani. A decade of software model checking with SLAM.
Communications of the ACM, 54(7):68–76, 2011. DOI: 10.1145/1965724.1965743. 34
[7] K. Bertet, J. Gustedt, and M. Morvan. Weak-order extensions of an order. eoretical
Compuer Science, 304:249–268, 2003. DOI: 10.1016/S0304-3975(03)00132-4. 89
[8] D. Beyer and S. Löwe. Explicit-state software model checking based on cegar and in-
terpolation.
In Fundamental Approaches to Software Engineering, volume 7793 of Lec-
ture Notes in Computer Science, pages 146–162. Springer Berlin Heidelberg, 2013. DOI:
10.1109/TC.1978.1675141. 34
[9] A. Biere, A. Cimatti, E. M. Clarke, and Y. Zhu. Symbolic model checking without bdds.
In Proceeding of the International Conference on Tools and Algorithms for the Construction and
Analysis of Systems, LNCS 1579, pages 193–207. Springer, 1999. DOI: 10.1007/3-540-
49059-0_14. 64
[10] B. Bollig and I. Wegener. Improving the variable ordering of obdds is np-complete. IEEE
Transactions on Computers, 45(9):993–1002, Sep 1996. DOI: 10.1109/12.537122. 42

128
BIBLIOGRAPHY
[11] R. Booth, Y. Chevaleyre, J. Lang, J. Mengin, and C. Sombattheera. Learning conditionally
lexicographic preference relations. In Proceedings of the European Conference on Artiﬁcial
Intelligence, pages 269–274. IOS Press, 2010. 15
[12] D. Bosnacki and G. J. Holzmann. Improving spin’s partial-order reduction for breadth-ﬁrst
search. In Model Checking Software, 12th International SPIN Workshop, pages 91–105, 2005.
DOI: 10.1007/11537328_10. 34
[13] C. Boutilier, F. Bacchus, and R. I. Brafman. UCP-networks: A directed graphical repre-
sentation of conditional utilities. In Proceedings of International Conference in Uncertainty in
Artiﬁcial Intelligence, pages 56–64, 2001. 14
[14] C. Boutilier, R. I. Brafman, C. Domshlak, H. H. Hoos, and D. Poole. CP-nets: A tool for
representing and reasoning with conditional ceteris paribus preference statements. Journal
of Artiﬁcial Intelligence Research, 21:135–191, 2004. DOI: 10.1613/jair.1234. 74
[15] C. Boutilier, R. I. Brafman, H. H. Hoos, and D. Poole. Reasoning with conditional ceteris
paribus preference statements. In Proceedings of the International Conference on Uncertainty
in Artiﬁcial Intelligence, pages 71–80, 1999. 16, 22
[16] C. Boutilier, R. I. Brafman, H. H. Hoos, and D. Poole. Cp-nets: A tool for representing
and reasoning with conditional ceteris paribus preference statements. Joural of Artiﬁcial
Intelligence Research, 21:135–191, 2004. DOI: 10.1613/jair.1234. 7, 14, 17, 23, 26, 29, 32,
66
[17] S. Bouveret, U. Endriss, and J. Lang. Conditional importance networks: A graphical lan-
guage for representing ordinal, monotonic preferences over sets of goods. In Proceedings of
the International Joint Conference on Artiﬁcial Intelligence, pages 67–72, 2009. 7, 14, 20, 22,
25, 32, 66
[18] R. I. Brafman, C. Domshlak, and S. E. Shimony.
On graphical modeling of prefer-
ence and importance. Journal of Artiﬁcial Intelligence Research, 25:389–424, 2006. DOI:
10.1613/jair.1895. 7, 14, 18, 22, 24, 26, 29, 66
[19] R. I. Brafman, E. Pilotto, F. Rossi, D. Salvagnin, K. B. Venable, and T. Walsh. e next best
solution. In Proceedings of the National Conference on Artiﬁcial Intelligence, pages 1537–1540.
AAAI Press, 2011. 77
[20] R. I. Brafman, F. Rossi, D. Salvagnin, K. B. Venable, and T. Walsh. Finding the next solu-
tion in constraint- and preference-based knowledge representation formalisms. In Proceed-
ings of the International Conferences on Principles of Knowledge Representation and Reasoning,
pages 425–433. AAAI Press, 2010. 77

BIBLIOGRAPHY
129
[21] R. E. Bryant. Graph-based algorithms for boolean function manipulation. IEEE Trans-
actions on Computers, 35(8):677–691, Aug. 1986. DOI: 10.1109/TC.1986.1676819. 40,
53
[22] J. Burch, E. Clarke, K. McMillan, D. Dill, and L. Hwang. Symbolic model checking: 1020
states and beyond. In Logic in Computer Science, pages 428–439, Jun 1990. 34, 41
[23] J. Chomicki. Preference formulas in relational queries. ACM Transactions on Database
Systems, 28(4):427–466, 2003. DOI: 10.1145/958942.958946. 77
[24] J. Chomicki, P. Godfrey, J. Gryz, and D. Liang. Skyline with presorting: eory and opti-
mizations. In Intelligent Information Processing and Web Mining, pages 595–604. Springer,
2005. DOI: 10.1007/3-540-32392-9_72. 77
[25] G. Ciardo, G. Lüttgen, and R. Siminiceanu. Saturation: an eﬃcient iteration strategy for
symbolic state space generation. In Proceedings of the International Conference on Tools and Al-
gorithms for the Construction and Analysis of Systems, pages 328–342. Springer-Verlag, 2001.
DOI: 10.1007/3-540-45319-9_23. 64
[26] A. Cimatti, E. Clarke, E. Giunchiglia, F. Giunchiglia, M. Pistore, M. Roveri, R. Sebastiani,
and A. Tacchella. NuSMV Version 2: An OpenSource Tool for Symbolic Model Checking.
In Proceedings of the International Conference on Computer-Aided Veriﬁcation, Copenhagen,
Denmark, July 2002. Springer. DOI: 10.1007/3-540-45657-0_29. 53, 78
[27] E. Clarke, O. Grumberg, and D. Peled. Model Checking. MIT Press, January 2000. 7, 74
[28] E. M. Clarke and E. A. Emerson. Design and synthesis of synchronization skeletons using
branching-time temporal logic. In Logic of Programs, Workshop, pages 52–71. Springer-
Verlag, 1982. DOI: 10.1007/BFb0025774. 34, 35
[29] E. M. Clarke, E. A. Emerson, and A. P. Sistla. Automatic veriﬁcation of ﬁnite-state con-
current systems using temporal logic speciﬁcations. ACM Transactions on Programming
Languages and Systems, 8(2):244–263, 1986. DOI: 10.1145/5397.5399. 34
[30] E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-guided abstrac-
tion reﬁnement for symbolic model checking. Journal of ACM, 50(5):752–794, 2003. DOI:
10.1145/876638.876643. 34
[31] E. M. Clarke, O. Grumberg, and D. Peled. Model Checking. MIT Press, 1999. 34
[32] V. Conitzer. Making decisions based on the preferences of multiple agents. Communications
of the ACM, 53(3):84–94, 2010. DOI: 10.1145/1666420.1666442. 105
[33] B. Cook, D. Kroening, and N. Sharygina. Symbolic model checking for asynchronous
boolean programs. Model Checking Software, 10:75. DOI: 10.1007/11537328_9. 64

130
BIBLIOGRAPHY
[34] C. Domshlak and R. I. Brafman. CP-nets - reasoning and consistency testing. In Proceedings
of the International Conference on Principles of Knowledge Representation and Reasoning, pages
121–132, 2002. 32
[35] C. Domshlak, E. Hüllermeier, S. Kaci, and H. Prade. Preferences in ai: An overview. Ar-
tiﬁcial Intelligence, 175(7-8):1037–1052, 2011. DOI: 10.1016/j.artint.2011.03.004. 2, 11
[36] J. Doyle and R. H. omason. Background to qualitative decision theory. AI magazine,
20:55–68, 1999. 1, 2
[37] P. C. Fishburn. Interval graphs and interval orders. Discrete Mathematics, 55(2):135–149,
1985. DOI: 10.1016/0012-365X(85)90042-1. 49, 50
[38] S. French. Decision eory: An Introduction to the Mathematics of Rationality. Ellis Horwood
Limited, 1986. 1, 105
[39] S. French. Decision theory: An introduction to the mathematics of rationality. 1986. 49
[40] J. Goldsmith and U. Junker. Preference handling for artiﬁcial intelligence. AI Magazine,
29(4):9–12, 2008. 2
[41] J. Goldsmith, J. Lang, M. Truszczynski, and N. Wilson. e computational complexity of
dominance and consistency in CP-nets. Journal of Artiﬁcial Intelligence Research, 33:403–
432, 2008. DOI: 10.1613/jair.2627. 7, 14, 17, 32
[42] O. Grumberg, S. Livne, and S. Markovitch. Learning to order bdd variables in veriﬁcation.
Journal of Artiﬁcial Intelligence Research, 18:2003, 2003. DOI: 10.1613/jair.1096. 42
[43] D. Gusﬁeld and R. W. Irving. e Stable marriage problem - structure and algorithms. Foun-
dations of computing series. MIT Press, 1989. 65
[44] A. Hadjali, S. Kaci, and H. Prade. Database preferences queries–a possibilistic logic ap-
proach with symbolic priorities. In Foundations of Information and Knowledge Systems, pages
291–310. Springer, 2008. DOI: 10.1007/978-3-540-77684-0_20. 77
[45] S. O. Hansson. What is ceteris paribus preference? Journal of Philosophical Logic, 25(3):307–
332, 1996. DOI: 10.1007/BF00248152. 16, 22
[46] J. W. Hatﬁeld, N. Immorlica, and S. D. Kominers. Testing substitutability. Games and
Economic Behavior, 75(2):639–645, 2012. DOI: 10.1016/j.geb.2011.11.007. 65
[47] T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Lazy abstraction. In Proceedings
of the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages
58–70, New York, NY, USA, 2002. ACM. DOI: 10.1145/565816.503279. 34

BIBLIOGRAPHY
131
[48] G. J. Holzmann. Software model checking with SPIN. Advances in Computers, 65:78–109,
2005.
[49] G. J. Holzmann. Mars code. Communications of the ACM, 57(2):64–73, Feb. 2014. DOI:
10.1145/2560217.2560218. 34
[50] M. Huth and M. Ryan. Logic in Computer Science: modelling and reasoning about systems
(second edition). Cambridge University Press, 2004. 38, 40, 43
[51] A. Jorge, S. A. McIlraith, et al. Planning with preferences. AI Magazine, 29(4):25, 2009.
DOI: 10.1609/aimag.v29i4.2204. 105
[52] S. Kaci. Working with Preferences: Less Is More. Springer-Verlag Berlin Heidelberg, 1st
edition, 2011. DOI: 10.1007/978-3-642-17280-9. 15
[53] V. Kahlon, C. Wang, and A. Gupta. Monotonic partial order reduction: An optimal sym-
bolic partial order reduction technique. In Proceedings of the International Conference on
Computer Aided Veriﬁcation, pages 398–413. Springer-Verlag, 2009. DOI: 10.1007/978-3-
642-02658-4_31. 64
[54] R. L. Keeney and H. Raiﬀa. Decisions with Multiple Objectives: Preferences and Value Trade-
Oﬀs. Cambridge University Press, 1993. 1, 105
[55] W. Kießling. Foundations of preferences in database systems. In Proceedings of the Interna-
tional conference on Very Large Data Bases, pages 311–322. VLDB Endowment, 2002. DOI:
10.1016/B978-155860869-6/50035-4. 77
[56] D. Kozen. Results on the propositional -calculus. eoretical Computer Science, 27(3):333
– 354, 1983. DOI: 10.1016/0304-3975(82)90125-6. 34, 52
[57] T. Lappas, K. Liu, and E. Terzi. Finding a team of experts in social networks. In Proceedings
of the ACM SIGKDD international conference on Knowledge discovery and data mining, pages
467–476. ACM, 2009. DOI: 10.1145/1557019.1557074. 105
[58] X. Liu and M. Truszczynski. Preference trees: A language for representing and reason-
ing about qualitative preferences. In Multidisciplinary Workshop on Advances in Preference
Handling, pages 55–60, 2014. 15
[59] X. Liu and M. Truszczynski. Learning partial lexicographic preference trees over combi-
natorial domains. In Twenty-Ninth AAAI Conference on Artiﬁcial Intelligence, pages 1539–
1545. AAAI Press, 2015. 15
[60] K. L. McMillan. Symbolic Model Checking: An Approach to the State Explosion Problem. PhD
thesis, Carnegie Mellon University, Pittsburgh, PA, USA, 1992. 34, 41

132
BIBLIOGRAPHY
[61] K. L. McMillan.
Cadence SMV (software).
Release 10-11-02p1. Available at: http:
//www.kenmcmil.com/smv.html, 2002. 102
[62] O. Morgenstern and J. Von Neumann. eory of Games and Economic Behavior. Princeton
University Press, 1944. 1, 49, 105
[63] T. D. Noia, T. Lukasiewicz, M. V. Martinez, G. I. Simari, and O. Tifrea-Marciuska. Com-
puting k-rank answers with ontological cp-nets. In T. Lukasiewicz, R. Peñaloza, and A.-Y.
Turhan, editors, Proceedings of the Workshop on Logics for Reasoning about Preferences, Uncer-
tainty, and Vagueness, volume 1205 of CEUR Workshop Proceedings, pages 74–87. CEUR-
WS.org, 2014. 77
[64] T. D. Noia, T. Lukasiewicz, M. V. Martinez, G. I. Simari, and O. Tifrea-Marciuska. Onto-
logical CP-Nets, volume 8816 of Lecture Notes in Computer Science, pages 289–308. Springer,
2014. 77
[65] NuSMV: A new symbolic model checker. nusmv.fbk.edu. 40
[66] N. I. of Standards and Technology. Common vulnerability scoring system version 2. https:
//nvd.nist.gov/CVSS-v2-Calculator, 2015. [Online; accessed 15-June-2015]. 2
[67] M. Osborne. An introduction to game theory. Oxford University Press, New York, 2004. 105
[68] Z. J. Oster, G. R. Santhanam, and S. Basu. Automating analysis of qualitative prefer-
ences in goal-oriented requirements engineering.
In ASE, pages 448–451, 2011. DOI:
10.1109/ASE.2011.6100096. 5, 20, 105
[69] Z. J. Oster, G. R. Santhanam, S. Basu, and V. Honavar. Model checking of qualitative
sensitivity preferences to minimize credential disclosure. In FACS, pages 205–223, 2012.
DOI: 10.1007/978-3-642-35861-6_13. 20, 102
[70] D. Peled. All from one, one for all: on model checking using representatives. In Proceedings
of International Conference on Computer Aided Veriﬁcation, volume 697 of Lecture Notes in
Computer Science, pages 409–423. Springer Berlin Heidelberg, 1993. DOI: 10.1007/3-540-
56922-7_34. 34
[71] E. Pilotto, F. Rossi, K. B. Venable, and T. Walsh. Compact preference representation in
stable marriage problems. In Proceedings of the First International Conference on Algorithmic
Decision eory, pages 390–401, 2009. DOI: 10.1007/978-3-642-04428-1_34. 77
[72] M. S. Pini, F. Rossi, K. B. Venable, and T. Walsh. Aggregating partially ordered preferences.
Journal of Logic and Computation, 19(3):475–502, 2009. DOI: 10.1093/logcom/exn012. 105
[73] A. Pnueli. e temporal semantics of concurrent programs. In G. Kahn, editor, Semantics
of Concurrent Computation, volume 70 of Lecture Notes in Computer Science, pages 1–20.
Springer Berlin Heidelberg, 1979. 34

BIBLIOGRAPHY
133
[74] A. Pnueli, J. Xu, and L. Zuck. Liveness with (0; 1; 1)- counter abstraction. In E. Brinksma
and K. Larsen, editors, Proceedings of the International Conference on Computer Aided Veri-
ﬁcation, volume 2404 of Lecture Notes in Computer Science, pages 107–122. Springer Berlin
Heidelberg, 2002. 34
[75] J. Queille and J. Sifakis. Speciﬁcation and veriﬁcation of concurrent systems in cesar. In
M. Dezani-Ciancaglini and U. Montanari, editors, International Symposium on Program-
ming, volume 137 of Lecture Notes in Computer Science, pages 337–351. Springer Berlin
Heidelberg, 1982. 34
[76] J.-P. Queille and J. Sifakis. Speciﬁcation and veriﬁcation of concurrent systems in CESAR.
In International Symposium on Programming, pages 337 – 351. Springer Verlag, 1982. DOI:
10.1007/3-540-11494-7_22. 7
[77] F. Rossi, K. B. Venable, and T. Walsh. mcp nets: Representing and reasoning with prefer-
ences of multiple agents. In Proceedings of the National Conference on Artiﬁcial Intelligence,
pages 729–734. AAAI Press, 2004. 65
[78] F. Rossi, K. B. Venable, and T. Walsh. A short introduction to preferences : between artiﬁ-
cial intelligence and social choice / Francesca Rossi, Kristen Brent Venable, Toby Walsh. [S.l.] :
Morgan & Claypool Publishers, 2011. DOI: 10.2200/S00372ED1V01Y201107AIM014.
105
[79] G. Santhanam and K. Gopalakrishnan. Pavement life-cycle sustainability assessment and
interpretation using a novel qualitative decision procedure. Journal of Computing in Civil
Engineering, 27(5):544–554, 2013. DOI: 10.1061/(ASCE)CP.1943-5487.0000228. 47, 52
[80] G. R. Santhanam. Crisner a qualitative preference reasoner. http://fmg.cs.iastate
.edu/project-pages/preference-reasoner/, 2015. [Online; accessed 06-February-
2015]. 8, 99
[81] G. R. Santhanam, S. Basu, and V. Honavar. Tcp- compose?–a tcp-net based algorithm
for eﬃcient composition of web services using qualitative preferences. In Proceedings of
the International Conference on Service-Oriented Computing, pages 453–467. Springer, 2008.
DOI: 10.1007/978-3-540-89652-4_34. 105
[82] G. R. Santhanam, S. Basu, and V. Honavar. Eﬃcient dominance testing for unconditional
preferences.
In Proceedings of the International Conference on the Principles of Knowledge
Representation and Reasoning, pages 590–592. AAAI Press, 2010. 47, 51
[83] G. R. Santhanam, S. Basu, and V. Honavar. Identifying sustainable designs using prefer-
ences over sustainability attributes. In Papers from the Spring Symposium on Artiﬁcial Intel-
ligence and Sustainable Design, 2011. 47, 52, 105

134
BIBLIOGRAPHY
[84] G. R. Santhanam, S. Basu, and V. Honavar. Representing and reasoning with qualitative
preferences for compositional systems. Journal of Artiﬁcial Intelligence Research, 42:211–274,
2011. DOI: 10.1613/jair.3339. 49, 105
[85] e SMV system. http://www.cs.cmu.edu/~modelcheck/smv.html. 40
[86] R. Tarjan. Depth-ﬁrst search and linear graph algorithms. In Annual Symposium on Switch-
ing and Automata eory, pages 114–121, Oct 1971. DOI: 10.1109/SWAT.1971.10. 34,
40
[87] A. Tarski. A lattice-theoretical ﬁxpoint theorem and its applications. Paciﬁc Journal of
Mathematics, 5(2):285–309, 1955. DOI: 10.2140/pjm.1955.5.285. 34
[88] W. Trabelsi, N. Wilson, D. G. Bridge, and F. Ricci. Preference dominance reasoning for
conversational recommender systems: a comparison between a comparative preferences and
a sum of weights approach. International Journal on Artiﬁcial Intelligence Tools, 20(4):591–
616, 2011. DOI: 10.1142/S021821301100036X. 65
[89] E. Tsang. Foundations of Constraint Satisfaction: e Classic Text. BoD–Books on Demand,
2014. 77
[90] M. Y. Vardi and P. Wolper. An automata-theoretic approach to automatic program veriﬁ-
cation. In Symposium on Logic in Computer Science. IEEE Computer Society, 1986. DOI:
10.1007/3-540-50403-6_33. 34
[91] T. Walsh. Representing and reasoning with preferences. AI Magazine, 28(4):59, 2007.
DOI: 10.1609/aimag.v28i4.2068. 1, 105
[92] F. Wang. Eﬃcient data structure for fully symbolic veriﬁcation of real-time software sys-
tems. In Proceedings of the International Conference on Tools and Algorithms for the Con-
struction and Analysis of Systems, LNCS 1785, pages 157–171. Springer-Verlag, 2000. DOI:
10.1007/3-540-46419-0_12. 64
[93] N. Wilson.
Consistency and constrained optimisation for conditional preferences.
In
Proceedings of the European Conference on Artiﬁcial Intelligence, pages 888–894, 2004. DOI:
10.1016/j.artint.2010.11.018. 22, 51, 66
[94] N. Wilson. Extending CP-nets with stronger conditional preference statements. In Pro-
ceedings of the National Conference on Artiﬁcial Intelligence, pages 735–741, 2004. 7, 14, 22,
24, 29, 51
[95] N. Wilson. An eﬃcient upper approximation for conditional preference. In Proceedings of
the European Conference on Artiﬁcial Intelligence, pages 472–476, 2006.

BIBLIOGRAPHY
135
[96] N. Wilson. Computational techniques for a simple theory of conditional preferences. Ar-
tiﬁcial Intelligence, 175(7-8):1053–1091, 2011. DOI: 10.1016/j.artint.2010.11.018. 14, 19,
26, 32


137
Authors’ Biographies
GANESH RAM SANTHANAM
GaneshRamSanthanam is an Associate Scientist at the Department of Electrical and Computer
Engineering at Iowa State University. He received his Ph.D. in computer science from Iowa State
University in 2010. His research interests include knowledge representation and reasoning, com-
putational decision theory, software engineering, and cyber-security. His doctoral dissertation
focused on model checking-based approaches to reasoning with qualitative preferences, and pref-
erence reasoning for cyber-defense applications. He has published over 20 research articles on
these topics in major journals and conferences in artiﬁcial intelligence and software engineering.
SAMIK BASU
Samik Basu is a professor of computer science at Iowa State University. He received his Ph.D. in
computer science from the State University of New York at Stony Brook in 2003. His research
focuses on formal speciﬁcation and veriﬁcation of systems, and the application of logic-based
techniques to address safety, security, and optimization problems for software and network-based
systems. His research has been funded by several grants from the National Science Foundation.
He has published over 70 research articles in major journals and conferences.
VASANT HONAVAR
Vasant Honavar is professor of information sciences and technology and of computer science
at the Pennsylvania State University where he holds the Edward Frymoyer Endowed Chair,
and heads the artiﬁcial intelligence Research Laboratory and the Center for Big Data Analyt-
ics and Discovery Informatics. He received his Ph.D. specializing in artiﬁcial intelligence from
the University of Wisconsin at Madison in 1990. Honavar’s current research and teaching inter-
ests include artiﬁcial intelligence, machine learning, bioinformatics, big data analytics, discovery
informatics, social informatics, security informatics, and health informatics. Honavar has led re-
search projects funded by National Science Foundation, the National Institutes of Health, the
United States Department of Agriculture, and the Department of Defense that have resulted in
foundational research contributions (documented in over 250 peer-reviewed publications) in scal-
able approaches to building predictive models from large, distributed, semantically disparate data
(big data); constructing predictive models from sequence, image, text, multi-relational, graph-
structured data; eliciting causal information from multiple sources of observational and experi-

138
AUTHORS’ BIOGRAPHIES
mental data; selective sharing of knowledge across disparate knowledge bases; representing and
reasoning about preferences; composing complex services from components; and applications in
bioinformatics, social network informatics, health informatics, energy informatics, and security
informatics.

