www.allitebooks.com

RESS Essentials
A practical introduction to programming responsive 
websites using an innovative methodology in web 
design and development
Joanna Krenz- Kurowska
Jerzy Kurowski
     BIRMINGHAM - MUMBAI
www.allitebooks.com

RESS Essentials
Copyright © 2013 Packt Publishing
All rights reserved. No part of this book may be reproduced, stored in a retrieval 
system, or transmitted in any form or by any means, without the prior written 
permission of the publisher, except in the case of brief quotations embedded in 
critical articles or reviews.
Every effort has been made in the preparation of this book to ensure the accuracy 
of the information presented. However, the information contained in this book is 
sold without warranty, either express or implied. Neither the authors, nor Packt 
Publishing, and its dealers and distributors will be held liable for any damages 
caused or alleged to be caused directly or indirectly by this book.
Packt Publishing has endeavored to provide trademark information about all of the 
companies and products mentioned in this book by the appropriate use of capitals. 
However, Packt Publishing cannot guarantee the accuracy of this information.
First published: October 2013
Production Reference: 1181013
Published by Packt Publishing Ltd.
Livery Place
35 Livery Street
Birmingham B3 2PB, UK.
ISBN 978-1-84969-694-4
www.packtpub.com
Cover Image by Joanna Krenz-Kurowska (23dragons.com)
www.allitebooks.com

Credits
Authors
Joanna Krenz-Kurowska
Jerzy Kurowski
Reviewers
Arley McBlain
Marc Pàmpols
Acquisition Editors
Martin Bell
Gregory Wild
Commissioning Editor
Sruthi Kutty
Technical Editors
Gauri Dasgupta
Failsal Siddiqui
Copy Editors
Brandt D'Mello
Gladson Monteiro
Lavina Pereira
Adithi Shetty
Project Coordinator
Amigya Khurana
Proofreader
Sandra Hopper
Indexers
Mariammal Chettiyar
Priya Subramani
Production Coordinator 
Pooja Chiplunkar
Cover Work
Pooja Chiplunkar
www.allitebooks.com

About the Authors
Joanna Krenz-Kurowska has been working as a freelance graphic designer and 
web designer for 12 years. She lives in the mountains on the south-west of Poland. 
She spent the last few years working for clients on five continents, blogging about 
web design and technology for the 99designs community blog, winning dozens 
of web design contests and following her passions: art photography, running 
marathons, and graphic arts. She is a member of the art union New Mill Artists' 
Colony. Teaming up with Jerzy Kurowski, she creates complete digital products 
like websites or multimedia programs. She loves challenges like swimming in ice air 
holes, long-distance mountain running, or exploring new areas in web design. You 
can learn more about her on www.23dragons.com.
Jerzy Kurowski, after graduating from the Academy of Fine Arts in Krakow 
in 1993, became interested in computer graphics. At that time he primarily 
designed for print but simultaneously he learned authoring and programing 
multimedia. In 1998, he started to create products for the Internet, and overtime 
freelance web development gradually became his main source of income. Having 
worked with a plethora of technologies in his life, today he tries to focus on 
developing the engaging user web interfaces with the use of PHP, AS3, JS, CSS, and 
HTML. When he is not coding or designing, he lives a highlander's life in the Giant 
Mountains on the Polish-Czech border in Central Europe. Follow him on https://
twitter.com/JerzyKurowski.
www.allitebooks.com

About the Reviewers
Arley McBlain is a Lead Front End Developer at the Canadian web agency, 
Thrillworks Inc., and works with many notable clients including BlackBerry, 
Tim Hortons, and Suncor. Arley has been making websites for over 18 years with 
experience in many roles; but he is now focusing on responsive and mobile-friendly 
frontend development.
Arley's passion for this industry has him active on social media outlets, forums, and 
occasionally writing for web blogs like CSS Tricks, Six Revisions, and Web Design 
Depot. He blogs at arleym.com and tweets as @ArleyM.
Marc Pàmpols is a tech entrepreneur, developer, analyst, and project leader from 
Spain. He started working at a couple of small development companies for three 
years. Later he founded YoteConozco.com, a Spanish dating social network that 
reached more than 50,000 users.
From 2007 until today, he is working at an IT company (Semic S.A.), leading the 
development of Python and Plone websites for privately held companies and public 
administration. Marc has worked for clients, such as the Spanish Ministry of Culture, 
Government of Andorra, and Tarragona, Vic, and Cambrils City Councils. He always 
had a strong interest in both frontend and backend development.
I would like to thank my mum, dad, dog, co-workers, and my 
friends at bixo demoscene group for protecting me during the 
review of this book.
www.allitebooks.com

www.PacktPub.com
Support files, eBooks, discount offers and more
You might want to visit www.PacktPub.com for support files and downloads related 
to your book. 
Did you know that Packt offers eBook versions of every book published, with PDF 
and ePub files available? You can upgrade to the eBook version at www.PacktPub.
com and as a print book customer, you are entitled to a discount on the eBook copy. 
Get in touch with us at service@packtpub.com for more details.
At www.PacktPub.com, you can also read a collection of free technical articles, sign 
up for a range of free newsletters and receive exclusive discounts and offers on Packt 
books and eBooks.
TM
http://PacktLib.PacktPub.com 
Do you need instant solutions to your IT questions? PacktLib is Packt's online 
digital book library. Here, you can access, read and search across Packt's entire 
library of books. 
Why Subscribe?
•	
Fully searchable across every book published by Packt
•	
Copy and paste, print and bookmark content
•	
On demand and accessible via web browser
Free Access for Packt account holders
If you have an account with Packt at www.PacktPub.com, you can use this to access 
PacktLib today and view nine entirely free books. Simply use your login credentials 
for immediate access.
www.allitebooks.com

Table of Contents
Preface	
1
Chapter 1: Why Does RWD Change the Internet?	
5
The RESS idea	
6
Controversies	
7
"Separate mobile websites are a good thing"	
7
"RWD is too difficult"	
9
"RWD means degrading design"	
9
RWD benefits	
10
Freedom for designers	
10
Invest less, reach out to a larger audience	
11
Users	
11
Developers	
12
RWD evolution and experiments	
15
Summary	
16
Chapter 2: Sample RWD Setup for Client-Side Development	
17
Bootstrap custom compilation setup	
18
Testing the Bootstrap grid system	
19
Integrating Gridpak	
22
Implementing responsive design	
25
Summary	
30
Chapter 3: Server Side Setup – Device Detection Libraries	
31
The AGPL licensed "OnSite" version of the WURFL library	
33
The WURFL Cloud version	
39
YABFDL – Detector	
41
Summary	
43
www.allitebooks.com

Table of Contents
[ ii ]
Chapter 4: Sample RESS Page	
45
WURFL plus screen size detection	
46
Dave Olsen's Detector	
48
Pure JavaScript screen size test	
52
Utility functions	
58
Dave Olsen's Detector plus WURFL	
59
Summary	
62
Chapter 5: Responsive Images Client- and 
Server-Side Approaches	
63
Scaling responsive images is not linear	
64
Plain CSS and Media queries – a solution with limited 
browser support	
66
The <picture> tag proposition	
67
Picturefill that mimics the <picture> tag behavior with 
HTML5 and JS	
68
Automated creation of responsive images	
70
Server Side – using one of our example RESS systems	
72
Summary	
80
Chapter 6: Performance	
81
Optimizing website towards screen size or bandwidth?	
81
Optimizing images	
82
Optimizing image dimensions	
82
Optimizing image compression	
83
Optimizing the file format	
83
Avoiding the use of images	
84
Reducing the number of images	
84
Media queries optimization	
84
Testing	
85
Summary	
88
Chapter 7: Extending with jQuery	
89
Twitter Bootstrap components and plugins	
89
Responsive tables	
92
Converting a table to an accordion element with jQuery	
92
Masonry	
101
Summary	
102
www.allitebooks.com

Table of Contents
[ iii ]
Chapter 8: Employing a REST API for RWD	
103
REST API	
105
Slim PHP framework and integrating the RESS module	
105
Defining API with the Slim framework	
107
Gateway file and path setup	
107
Implementing routes	
108
Adding photos	
111
What is it good for?	
115
Summary	
116
Index	
117
www.allitebooks.com


Preface
RESS is a new methodology in the world of web design and development. 
It attempts to solve the problems that accompany the Responsive Web Design 
(RWD) approach to web design. RESS is still in its infancy, but it is growing at an 
exponential rate.
RESS Essentials shows you how to make server-side applications smarter and 
more aware of a visitor's environment limitations (device, screen size, and browser). 
This allows you to create faster and more reliable websites. Through this book, you 
will build a solid base of knowledge on RESS-related technologies, while the 
step-by-step tutorials will help you to create your own RESS system.
This book is an introduction to the RESS alchemy and gives you an incentive 
to build your own RESS lab. It will give you a broad overview of the multiple 
techniques used to code responsive websites in responsible ways. Beginning with 
an overview of RWD, you will learn the steps involved in setting up RWD for 
client-side development. You will then learn how to scale images using client and 
server-side technology. By the end of this book, you will have learned about the 
implementation of RESS application patterns, browser feature detection, and various 
RESS architectures. This book will also teach you how to use jQuery with some RWD 
design patterns and how to employ REST API for RWD pages.
What this book covers
Chapter 1, Why Does RWD Change the Internet?, is a brief description of Responsive 
Web Design history, its benefits, and the controversies it caused among web 
developers. It also gives a brief introduction to RESS.
Chapter 2, Sample RWD Setup for Client-Side Development, describes creating a sample 
responsive HTML document with the help of Twitter's Bootstrap framework and 
Gridpak tool.

Preface
[ 2 ]
Chapter 3, Server Side Setup – Device Detection Libraries, covers using WURF (OnSite 
and Cloud versions) and Dave Olsen's Detector library to detect device features.
Chapter 4, Sample RESS Page, explains four complete RESS solutions to get a device's 
information that can be used to build an appropriate version of an HTML document 
within server-side application.
Chapter 5, Responsive Images Client- and Server-Side Approaches, talks about several ways 
to deliver resolution-dependent images, such as the script from adaptive-images.com, 
the <picture> element polyfill, or the RESS solution from the previous chapter.
Chapter 6, Performance, explains optimization strategies and useful tools.
Chapter 7, Extending with jQuery, starts by integrating the Twitter Bootstrap carousel 
component with our RESS test system. Next it covers creating the jQuery plugin from 
scratch to make the table responsive by converting it into an accordion component 
below the screen width defined with the media query.
Chapter 8, Employing a REST API for RWD, explains how to create a REST API with 
a Slim PHP framework and an AJAX application integrated with our RESS module, 
which we created before.
What you need for this book
To run some examples from this book you need to have some kind of AMP 
(Apache, mySQL, PHP) environment. For those using Windows, the easiest way to 
go is to use the WAMP server in the default configuration. Links to the respective 
packages for other systems can be found at http://en.wikipedia.org/wiki/
List_of_Apache–MySQL–PHP_packages.
Who this book is for
This book is aimed primarily at web developers interested in writing 
applications that leverage both client-and server-side code to optimize 
content for various devices.
Conventions
In this book, you will find a number of styles of text that distinguish between 
different kinds of information. Here are some examples of these styles, and an 
explanation of their meaning.

Preface
[ 3 ]
Code words in text are shown as follows: "We can include other contexts through the 
use of the include directive."
A block of code is set as follows:
<picture alt="">
  <source media="(min-width: 45em)"
    srcset="large-1.jpg 1x, large-2.jpg 2x">
  <source media="(min-width: 18em)"
    srcset="med-1.jpg 1x, med-2.jpg 2x">
  <source srcset="small-1.jpg 1x, small-2.jpg 2x">
  <img src="small-1.jpg">
</picture>
New terms and important words are shown in bold. Words that you see on the 
screen, in menus or dialog boxes for example, appear in the text like this: "In the 
JavaScript components section, do not select any checkbox."
Warnings or important notes appear in a box like this.
Tips and tricks appear like this.
Reader feedback
Feedback from our readers is always welcome. Let us know what you think about 
this book—what you liked or may have disliked. Reader feedback is important for us 
to develop titles that you really get the most out of.
To send us general feedback, simply send an e-mail to feedback@packtpub.com, 
and mention the book title via the subject of your message.
If there is a topic that you have expertise in and you are interested in either writing 
or contributing to a book, see our author guide on www.packtpub.com/authors.
Customer support
Now that you are the proud owner of a Packt book, we have a number of things to 
help you to get the most from your purchase.

Preface
[ 4 ]
Downloading the example code
You can download the example code files for all Packt books you have purchased 
from your account at http://www.packtpub.com. If you purchased this book 
elsewhere, you can visit http://www.packtpub.com/support and register to have 
the files e-mailed directly to you.
Errata
Although we have taken every care to ensure the accuracy of our content, 
mistakes do happen. If you find a mistake in one of our books—maybe a mistake 
in the text or the code—we would be grateful if you would report this to us. 
By doing so, you can save other readers from frustration and help us improve 
subsequent versions of this book. If you find any errata, please report them by 
visiting http://www.packtpub.com/submit-errata, selecting your book, clicking 
on the errata submission form link, and entering the details of your errata. Once 
your errata are verified, your submission will be accepted and the errata will be 
uploaded on our website, or added to any list of existing errata, under the Errata 
section of that title. Any existing errata can be viewed by selecting your title from 
http://www.packtpub.com/support.
Piracy
Piracy of copyright material on the Internet is an ongoing problem across all media. 
At Packt, we take the protection of our copyright and licenses very seriously. If you 
come across any illegal copies of our works, in any form, on the Internet, please 
provide us with the location address or website name immediately so that we can 
pursue a remedy.
Please contact us at copyright@packtpub.com with a link to the suspected 
pirated material.
We appreciate your help in protecting our authors, and our ability to bring 
you valuable content.
Questions
You can contact us at questions@packtpub.com if you are having a problem with 
any aspect of the book, and we will do our best to address it.

Why Does RWD Change 
the Internet?
This book is about two phenomena in the world of contemporary web design and 
web development, RWD and RESS. RWD stands for Responsive Web Design and 
RESS means RWD with Server Side Components. Both are based on attempts to 
find a way to deliver content to multiple devices more easily, and efficiently while 
reducing development time and keeping application and data structures maintainable. 
The RWD concept appeared first in 2010 in an article by Ethan Marcotte (available at 
http://alistapart.com/article/responsive-web-design). He presented an 
approach that allows us to progressively enhance page design within different viewing 
contexts with the help of fluid grids, flexible images, and media queries. This approach 
was opposed to the one that separates websites geared toward specific devices. Instead 
of two or more websites (desktop and mobile), we could have one that adapts to all 
devices. The technical foundation of RWD (as proposed in Marcotte's article) consists 
of three things, fluid grids, flexible images, and media queries.
Illustration: Fluid (and responsive) grid adapts to device using both column width and column count

Why Does RWD Change the Internet?
[ 6 ]
Fluid grid is basically nothing more than a concept of dividing the monitor width into 
modular columns, often accompanied by some kind of a CSS framework (some of 
the best-known examples were the 960 grid system, blueprint, pure, 1140px grid, and 
elastic), that is, a base stylesheet that simplifies and standardizes writing 
website-specific CSS. What makes it fluid is the use of relative measurements like %, 
em, or rem. With changing the screen (or the window), the number of these columns 
changes (thanks to CSS statements enclosed in media queries). This allows us to adjust 
the design layout to device capabilities (screen width and pixel density in particular).
Images in such a layout become fluid by using a simple technique of setting width, 
x% or max-width, 100% in CSS, which causes the image to scale proportionally.
With those two methods and a little help from media queries, one can radically 
change the page layout and handle this enormous, up to 800 percent, difference 
between the thinnest and the widest screen (WQXGA's 2560px/iPhone's 320px). This 
is a big step forward and a good base to start creating One Web, that is, to use one 
URL to deliver content to all the devices. Unfortunately, that is not enough to achieve 
results that would provide an equally great experience and fast loading websites for 
everybody.
The RESS idea
Besides screen width, we may need to take into account other things such as 
bandwidth and pay-per-bandwidth plans, processor speed, available memory, 
level of HTML/CSS compatibility, monitoring color depth, and possible navigation 
methods (touch screen, buttons, and keyboard). On a practical level, it means 
we may have to optimize images and navigation patterns, and reduce page 
complexity for some devices. To make this possible, some Server Side solutions 
need to be engaged. We may use Server Side just for optimizing images. Server Side 
optimization lets us send pages with just some elements adjusted or a completely 
changed page; we can rethink the application structure to build a RESTful web 
interface and turn our Server Side application into a web service. The more we need 
to place responsibility for device optimization on the Server Side, the closer we get to 
the old way of disparate desktops and mobile web's separate mobile domains, such 
as iPhone, Android, or Windows applications.
There are many ways to build responsive websites but there is no golden rule to 
tell you which way is the best. It depends on the target audience, technical contexts, 
money, and time. Ultimately, the way to be chosen depends on the business 
decisions of the website owner.

Chapter 1
[ 7 ]
When we decide to employ Server Side logic to optimize components of a web page 
designed in a responsive way, we are going the RESS (Responsive Web Design 
with Server Side components) way. RESS was proposed by Luke Wroblewski on his 
blog as a result of his experiences on extending RWD with Server Side components. 
Essentially, the idea was based on storing IDs of resources (such as images) and 
serving different versions of the same resource, optimized for some defined classes 
of devices. Device detection and assigning them to respective classes can be based on 
libraries such as WURFL or YABFDL.
Controversies
It is worth noting that both of these approaches raised many controversies. 
Introducing RWD has broken some long-established rules or habits such as standard 
screen width (the famous 960px maximum page width limit). It has put in question 
the long-practiced ways of dealing with mobile web (such as separate desktop and 
mobile websites). It is no surprise that it raises both delight and rage. One can easily 
find people calling this fool's gold, useless, too difficult, a fad, amazing, future proof, 
and so on. Each of those opinions has a reason behind it, for better or worse.
A glimpse of the following opinions may help us understand some of the key 
benefits and issues related to RWD.
"Separate mobile websites are a good thing"
You may have heard this line in an article by Jason Grigsby, Css media query for mobile 
is fool's gold, available at http://blog.cloudfour.com/css-media-query-for-
mobile-is-fools-gold/.
Separate mobile websites allow reduction of bandwidth, prepare pages that are less 
CPU and memory intensive, and at the same time allow us to use some mobile-
only features such as geolocation. Also, not all mobile browsers are wise enough to 
understand media queries.

Why Does RWD Change the Internet?
[ 8 ]
That is generally true and media queries are not enough in most scenarios, but 
with some JavaScript (Peter-Paul Koch blog available at, http://www.quirksmode.
org/blog/archives/2010/08/combining_media.html#more, describes a method 
to exclude some page elements or change the page structure via JS paired with 
media queries), it is possible to overcome many of those problems. At the same 
time, making a separate mobile website introduces its own problems and requires 
significant additional investment that can easily get to tens or hundreds of times 
more than the RWD solution (detecting devices, changing application logic, writing 
separate templates, integrating, and testing the whole thing). Also, at the end of 
the day, your visitors may prefer the mobile version, but this doesn't have to be the 
case. Users are often accessing the same content via various devices and providing 
consistent experience across all of them becomes more and more important.
The preceding controversy is just a part of a wider discussion on channels to provide 
content on the Internet. RWD and RESS are relatively new kids on the block. For 
years, technologies to provide content for mobile devices were being built and used, 
from device-detection libraries to platform-specific applications (such as iStore, 
Google Play, and MS). When, in 2010, US smartphone users started to spend more 
time using their mobile apps than browsers (Mobile App Usage Further Dominates Web, 
Spurred by Facebook, at http://blog.flurry.com/bid/80241/Mobile-App-Usage-
Further-Dominates-Web-Spurred-by-Facebook), some hailed it as dangerous for 
the Web (Apps: The Web Is The Platform, available at http://blog.mozilla.org/
webdev/2012/09/14/apps-the-web-is-the-platform/). A closer look at stats 
reveals though, that most of this time was spent on playing games. No matter how 
much time kids can spend playing Angry Birds now, after more than two years from 
then, people still prefer to read the news via a browser rather than via native mobile 
applications. The Future of Mobile News report from October 2012 reveals that for 
accessing news, 61 percent mobile users prefer a browser while 28 percent would 
rather use apps (Future of Mobile News, http://www.journalism.org/analysis_
report/future_mobile_news). The British government is not keen on apps either, 
as they say, "Our position is that native apps are rarely justified" (UK Digital Cabinet 
Office blog, at http://digital.cabinetoffice.gov.uk/2013/03/12/were-not-
appy-not-appy-at-all/).
Recently, Tim Berners-Lee, the inventor of the Web, criticized closed world apps 
such as those released by Apple for threatening openness and universality that the 
architects of the Internet saw as central to its design. He explains it the following 
way, "When you make a link, you can link to anything. That means people must be 
able to put anything on the Web, no matter what computer they have, what software 
they use, or which human language they speak and regardless of whether they have 
a wired or a wireless Internet connection." This kind of thinking goes in line with the 
RWD/RESS philosophy to have one URL for the same content, no matter what way 
you'd like to access it. Nonetheless, it is just one of the reasons why RWD became so 
popular during the last year.

Chapter 1
[ 9 ]
"RWD is too difficult"
CSS coupled with JS can get really complex (some would say messy) and requires a 
lot of testing on all target browsers/platforms.
That is or was true. Building RWD websites requires good CSS knowledge and some 
battlefield experience in this field. But hey, learning is the most important skill in this 
industry. It actually gets easier and easier with new tools released nearly every week.
"RWD means degrading design"
Fluid layouts break the composition of the page; Mobile First and Progressive 
Enhancement mean, in fact, reducing design to a few simplistic and naive patterns.
Actually the Mobile First concept contains two concepts. One is 
design direction and the second is the structure of CSS stylesheets, 
in particular the order of media queries.
With regard to design direction, the Mobile First concept is meant to describe the 
sequence of designs. First the design for a mobile should be created and then for a 
desktop. While there are several good reasons for using this approach, one should 
never forget the basic truth that at the end of the day only the quality of designs 
matters, not the order they were created in.
With regard to the stylesheet structure, Mobile First means that we first write 
statements for small screens and then add statements for wider screens, such as 
@media screen and (min-width: 480px). It is a design principle meant to 
simplify the whole thing. It is assumed here that CSS for small screens is the simplest 
version, which will be progressively enhanced for larger screens. The idea is smart 
and helps to maintain a well-structured CSS but sometimes the opposite, the Desktop 
First approach, seems natural. Typical examples are tables with many columns. The 
Mobile First principle is not a religious dogma and should not be treated as such. As 
a side note, it remains an open question why this is still named Mobile First, while 
the new iPad-related statements should come here at the end (min-width: 2000px).
There are some examples of rather poor designs made by RWD celebrities. But there 
are also examples of great designs that happened, thanks to the freedom that RWD 
gave to the web design world.
www.allitebooks.com

Why Does RWD Change the Internet?
[ 10 ]
The rapid increase in Internet access via mobile devices during 2012 
made RWD one of the hottest topics in web design. The numbers 
vary across countries and websites but no matter what numbers 
you look at, one thing is certain, mobile is already big and will 
soon get even bigger (valuable stats on mobile use are available 
at http://www.thinkwithgoogle.com/mobileplanet/
en/). Statistics are not the only reason why Responsive Web 
Design became popular. Equally important are the benefits for web 
designers, users, website owners, and developers.
RWD benefits
Let's take a look at the advantages RWD and RESS can offer to members of each of 
their various user groups.
Freedom for designers
RWD for designers means the end of the standard-screen-width paradigm that ruled 
the Web for a long time. When I started web designing, standard screen width was 
considered to be 600px. Soon it reached 800px and stabilized for years at 1024px 
(960px standard available width for design).
Illustration – standard screen width
Following this "standard", the lowest screen width our visitors used to have, resulted 
in designs using only 50-75 percent of the screen real estate that most monitors could 
provide. The rest usually just had some nice background pattern.

Chapter 1
[ 11 ]
Responsive Web Design that had to adjust to various devices' resolutions made 
the "standard width" concept obsolete. If we do responsive design, why not use 
all the available space? Standard document 960px width uses less than 40% screen 
real estate on a monitor more than 2500px wide. Creating documents that use 100% 
available width allows us to create more engaging and interesting designs. Browsing 
the best web designs of 2012, one gets the impression that someone opened a box with 
fullscreen website designs that provide a cinematic or game-like experience (you can 
see that most of them provide fullscreen experience). This is just the beginning.
Invest less, reach out to a larger audience
This is probably the dream of any website owner.  RWD or RESS is not a silver bullet 
against all problems to provide content to devices. Each case should be carefully 
analyzed to find out what type of solution is best, or at least possible, in a particular 
circumstance. Having said that, in many typical applications it is the cheapest and 
the fastest way to web design. Additional costs of design, implementation, and 
testing will probably not be even comparable with the cost of creating several mobile 
website versions together with respective native applications (hybrid applications 
as described at http://www.wired.com/insights/2012/11/native-apps-vs-
mobile-web/).
The Web is a good thing for users, and they definitely prefer a browsable website 
over one they can hardly see on their smartphone/tablet.
Ability to link content is crucial for the Internet. Users expect links to work no matter 
how they access the Internet, and it is not possible to link to content inside some 
native apps. Browsing a mobile version of a website with desktop browsers or the 
opposite is not comfortable. It may happen though as a natural consequence of the 
nature of links.
Lowering budget constraint means that more websites can afford to optimize 
content for more devices, which will hopefully make the Web easier to browse 
on smartphones.
Users
It is hard to find statistics on how much consumers like or dislike responsive 
layouts. They don't care much about the technology involved. For them, experience 
is the only thing that matters. RESS is an approach, one of many, that may help in 
providing great experiences across devices. Of course it is important to provide this 
experience, instead of failing before we provide anything or providing unusable 
content. Whenever conversion of an existing website to responsive layout is 
considered, we need to understand the limitations and, when possible, overcome 
them with the use of Server Side components and JavaScript.

Why Does RWD Change the Internet?
[ 12 ]
After we are able to provide the user experiences we intended with our design, the 
benefits are obvious, which are as follows:
•	
On big screens, the web page finally uses the whole possible area, which 
enables a more engaging experience.
•	
On small screens, readability is guaranteed.
•	
Lowering costs of "going mobile" for website owners means that users 
will get more websites optimized for devices than it would be possible 
without RWD.
•	
Bandwidth issues can be solved with RESS.
•	
In many scenarios native applications or mobile websites can provide better 
a user experience, but before resigning from responsive solutions some 
questions should be asked such as, does this advantage justify the difference 
in the cost of development and maintaining separate versions of the website? 
Is our device detection kit really as reliable as we'd like to believe? And how 
future proof will this solution be? Borders between device classes (used to 
determine templates to device relations) are blurry and will fade even more 
with time.
Future proof is a buzzword often used by the RWD community as 
a selling point for RWD: www.techopedia.com states; in reality, 
very few things are truly future proof and that is the sad truth about 
all web things. RWD probably will be more future proof than native 
applications; the future will tell us. Nonetheless, it will be definitely 
cheaper to maintain RWD/RESS websites than native applications.
Developers
Most RWD critics come from the developers' community. This is surprising, but 
not very. Multiresolution design complexity adds to an everlasting tension between 
designers and developers. Implementing what the designer created in Photoshop is 
often a challenge for programmers, even without the necessity to make it fluidic and 
responsive. Besides that, RWD is a concept with no API or technical documentation 
to study. It introduces many problems, enough to mention responsive (adapting to 
resolution) images. The good news is that after two years of evolution we have some 
well-tested CSS frameworks, a growing number of JS libraries, and last but not least, 
responsive design principles, which are implemented in new versions of popular 
open-source content management platforms such as Drupal. In Drupal 8 there are 
several responsive elements. One of them is the Picture display formatter for image 
fields, being a Drupal way to implement the picture element proposal for HTML5, 
available at http://picture.responsiveimages.org/.

Chapter 1
[ 13 ]
On the list of tools a responsive design developer may need, respond.js (available 
at https://github.com/scottjehl/Respond) takes first place, a lightweight script 
that enables responsive design in browsers that don't support CSS3 media queries.
If you need a conditional resource, loading another JavaScript Modernizr (available 
at http://modernizr.com/) can help you.
There are many responsive Boilerplates to help you get started quickly. HTML5 
Boilerplate (available at www.html5boilerplate.com) is most often used and can be 
used as a starting point for almost every web project. It contains an HTML template 
with normalize.css that normalizes default stylesheets of various browsers, 
Modernizr script, and examples of best-practice server configuration files.
The base version is not a responsive CSS framework, as it doesn't impose on the 
developer any particular way to handle responsiveness, but you can also get it in two 
other flavors, Responsive or Bootstrap. Each of them proposes its own perspective 
on building the page structure. Responsive is a concept of three views and layout 
versions, mobile, intermediate, and large.
HTML5 Boilerplate Responsive features two columns and typographic settings optimized for readability 
It is perfect for fast, simple projects that don't require a complex layout.

Why Does RWD Change the Internet?
[ 14 ]
The Bootstrap version is a responsive framework based on a 12-column responsive 
grid. The 12-column internal structure of this version (and its possible applications) 
is explained in detail at http://getbootstrap.com/css/.
12 columns of default grid in HTML5 Boilerplate give some flexibility in planning the page 
Twelve columns allow us to create more complex layouts, but still it is a rather rigid 
system. Most designers would not be happy to have a fixed column number, with 
widths and margins defined for them. During the last five years, many tools and 
frameworks aimed at creating all kinds of grids on the Web appeared; ZURB CSS Grid 
Builder available at http://www.zurb.com/playground/css-grid-builder and 
Gridulator available at http://gridulator.com/ to name just two. A more extensive 
list can be found at http://www.thegridsystem.org/categories/tools/.
As flexibility and speed in creating responsive grids becomes one of the key issues 
in the web design / web development workflow, Adobe is trying its best to keep 
this market segment under its wings. It is hard not to admit that their tools lead the 
race. Inside Dreamweaver CS6 one can use a two-step process to streamline, creating 
responsive layouts.
At the first step it is possible to set up grids for three resolutions, with any number of 
columns on each screen width.
On the created framework, one can place content blocks and adjust their placement 
for each of three screen resolutions by dragging their edges.

Chapter 1
[ 15 ]
Generated code is based on HTML5 Boilerplate and can be manually tweaked. The 
Dreamweaver interface allows us to also build content blocks on a grid framework.
On 14 February 2013 Adobe released the public preview of a completely new tool: 
Edge Reflow (free at the time of writing this). Its sole purpose is to allow fast and 
easy creation of CSS and HTML for responsive layouts.
RWD evolution and experiments
Originally RWD consisted of three basic technologies used in a somewhat defined 
way, shown as follows:
•	
Fluid grids: Based on % measurements
•	
Flexible images: Scaled down with the CSS max-width trick
•	
Media queries made with philosophy Mobile First or Progressive 
Enhancement: That means code for the smallest screen was written first and 
then features for larger screens were added
The most important additions are the Modernizr and Respond.js libraries used in 
conjunction with a number of techniques to improve cross-browser compatibility.
Fluid grids should rather be named fluid and responsive in the original version. 
What is the difference? A fluid grid works like an old-fashioned fluid layout, 
that is, the columns' widths change when the browser window's width changes. 
A responsive grid responds to this change by changing the number of columns. 
In the original orthodox RWD concept, grids did both and the change was driven 
together by media queries and by the use of percentage values to set up layout.
For some people and projects this approach worked well but:
•	
Some were not happy with fluid columns and made "frameless grids" 
(available at http://framelessgrid.com/), a CSS grid system with columns 
of fixed width
•	
Some decided that it's better to use em or rem based scaling to take the 
resolution out of the equation and made The Goldilocks Approach an HTML 
and CSS Boilerplate (available at http://goldilocksapproach.com/)
•	
Some thought that breaking a grid into bricks instead of columns may 
be more funny and made Masonry (available at http://masonry.
desandro.com/)
•	
Some (authors of this book among them) are happy to write their media 
queries by hand and adjust layout when it is necessary in a way required by 
the design

Why Does RWD Change the Internet?
[ 16 ]
Last but not least RESS techniques emerged. Nobody really defined how RESS 
is supposed to work, besides that it couples RWD with Server Side components. 
A neat example of this kind of thinking is Adaptive Images (available at 
http://adaptive-images.com/), the PHP library that takes care of resizing 
images on the server. A similar solution was employed at Boston Globe, the huge 
news website being the flagship example of a complex RWD implementation.
Summary
The RESS idea can be described as Server Side optimizing page components for 
devices with the use of browser-features detection. In other words, RESS is an 
attempt to marry client-side responsive design achieved by using media queries 
and some JavaScript with Server Side logic. The purpose here is to make the whole 
system more efficient, and to overcome the constraints of a client-side application. 
These are vague statements and we need to be more precise before we can build 
any actual RESS systems. To know what RESS can do for us we have to know what 
problems we need to address and what Server Side infrastructure we have in place. 
RESS solutions are most often employed just for image optimization, but you could 
use it for serving the 3D Web GL version for those who can use it, FLASH for those 
who have it, CSS animations for those who see it, and so on.
The most underestimated RWD advantage is that it allows us to make better 
designs: designs that always use all the available screen width. This is the case 
for the first time since the very beginning of the Internet. The old way of making 
fluid layouts was a flawed solution that never grew out of childhood diseases. 
In the following chapter, we will build a really simple RWD example based on the 
HTML5 Boilerplate, using a responsive navigation component from H5BP (HTML5 
Boilerplate). We will not use the default grid system but replace it with one that we 
define ourselves with the Gridpak service.

Sample RWD Setup for 
Client-Side Development
To test and learn RWD and RESS concepts, we will build a demo website. In this 
chapter we are going to focus on client-side design and development. We will go 
through the process of implementing a simple design with practical application of 
RWD concepts such as fluid images, responsive grids, and media queries.
A sample responsive homepage design we are going to build in this chapter

Sample RWD Setup for Client-Side Development
[ 18 ]
During the process, we are going to look closer at HTML and CSS constructs often 
used to build responsive web pages. To implement our design, we will employ the 
often-used frontend framework, Twitter's Bootstrap, based on 12 fluid columns. 
We don't need most of its components (we are only going to use the responsive 
navigation bar), but we will seize the opportunity to get acquainted with this 
useful tool. Our design uses variable column count depending on the screen size. 
To achieve it, we may use the Gridpak tool, which lets us create complex variable 
column grids with an intuitive interface. Then we will learn how to integrate the two, 
the Gridpak grid and Bootstrap. Finally, we will add custom classes to format the 
document and fine tune the page look on various screen sizes by adjusting font sizes 
and fixing issues that might crop up.
Bootstrap custom compilation setup
To get a customized version of Twitter's Bootstrap, we go to http://getbootstrap.
com/customize/ where you can select which components you need and customize 
the LESS variables such as colors fonts. In the current version (3.0), the build script was 
improved and cleaned. Now it's easy to get a really lightweight setup. We just need 
basic styles and a responsive navigation bar. To get our custom build, first uncheck all 
the checkboxes. Then, in the Common CSS section, select the following checkbox:
•	
Forms: This is required by the Navbar component
In the Components section, select the following checkboxes:
•	
Navs
•	
Navbar
In the JavaScript components section, do not select any checkbox.
In the Utilities section, select the following checkboxes:
•	
Basic utilities
•	
Component animations (for JS)
Under the jQuery plugins header in the Linked to components section, do not select 
any checkbox.
Finally, in the Magic section, select the following checkboxes:
•	
Collapse
•	
Transitions (required for any kind of animation)

Chapter 2
[ 19 ]
Let's also get a version of Bootstrap with grids. To do this, we have to check Grid 
system in the Common CSS section.
We override the Bootstrap color settings with our own styles, so you can skip the 
following color setup section, and on the bottom of the page find the Compile and 
Download button. Let's name this version bootstrap_grid.zip.
Testing the Bootstrap grid system
The downloaded files are ZIP archives containing two directories (css and js) and 
some files inside each of them. First we'd like to see and test the default Bootstrap's 
grid system. So let's extract the bootstrap_grid.zip contents to the /assets/ 
subdirectory of our test website. I renamed the boostrap.css file inside the css 
directory to boostrap_grid.css and added grids_visual.css for styles necessary 
to visualize the grid in the browser. The file bootstrap_grids.html is an HTML 
document with markup describing a few rows of the Bootstrap grid system.
Files necessary to test Twitter's Bootstrap grids
The Bootstrap grid system consists of 12 columns that may be merged for some or all 
of its media queries defined for the following four stops:
•	
Extra small: For phones (<768px)
•	
Small: For tablets (≥768px)
•	
Medium: For desktops (≥992px)
•	
Large: For desktops (≥1200px)
www.allitebooks.com

Sample RWD Setup for Client-Side Development
[ 20 ]
It's worth noting that in this approach, everything smaller than 768 pixels is 
considered extra small.
Now we can create an HTML structure to preview and test Twitter's 
Bootstrap-responsive columns. In Version 3 of Twitter's Bootstrap, published in the 
middle of August 2013, several changes were introduced to allow more flexibility 
and simplify HTML at the same time.
The default 12-columns grid in Twitter's Bootstrap has fixed column count. Below 
768px columns turn to rows in a one-column layout, as shown in the following figure:
To do this, we create a simple document with the following code snippet:
<!DOCTYPE html>
  <head>
    <title>Sample grid</title>
    <link rel="stylesheet" href="css/bootstrap_grid.css">
    <link rel="stylesheet" href="css/grids_visual.css">
  </head>
  <body>
    <div class="row">
    <div class="col-md-1 magenta_bar"></div>
      [12 lines]
    <div class="col-md-1 magenta_bar"></div>
    </div>
The 12 rows in the code we just saw <div class="col-md-1 magenta_bar"></
div> placed inside <div class="row"> is a typical responsive row.

Chapter 2
[ 21 ]
Class col-md-1 means that the coloumn width of this div will be one in all the 
resolutions and will extend to fullscreen width below 768px. The next row in our 
document contains more complex formatting, shown as follows:
  <div class="row">
    <div class="col-md-4 col-sm-5  col-xs-6 magenta_bar">
    </div>
    <div class="col-md-4 col-sm-2  col-xs-6 magenta_bar">
    </div>
    <div class="col-md-4 col-sm-5  col-xs-12 magenta_bar">
    </div>
  </div>
  </body>
</html>
Assigning three classes such as col-md-4, col-sm-5, and col-xs-6 to our div 
column is explained as follows:
•	
col-md-4 means that it is four columns wide (33 percent) on medium and 
bigger screens
•	
col-sm-5 means that it is five columns wide (41.6667 percent) on small and 
bigger screens
•	
col-xs-6 means that it is six columns wide (50 percent) on extra small and 
bigger screens
The media queries are written in the Mobile First order, which means that statements 
for larger screens override those for smaller ones.
The document structure can be seen in the following image:

Sample RWD Setup for Client-Side Development
[ 22 ]
Integrating Gridpak
Flexibility of Twitter's Bootstrap grid system is improved in Version 3, but we 
will use a grid created with another grid-generation script; Gridpak (available at 
http://gridpak.com/) from Erskine Design is an amazing tool that allows us to 
create any grid for any media query stop with an intuitive interface. Its main 
features are as follows:
•	
Interactive creation of percent-based grids with variable column count
•	
Creating media query stops of any screen width
When you create a grid, you can download the following files:
•	
.png design templates for all the necessary steps
•	
.js script that draws the grid (the grid visibility can be turned on or off 
with the g key)
•	
.css file with media queries and grid columns (with column spans defined 
as span_x classes)
•	
.less and .scss files
A demo showing the setup of a grid application with some typical blocks
With Gridpak (available at www.gridpak.com), you can create grids with variable 
column count based on any screen size steps you define.
Sample I created with Grider has the following parameters:
•	
>320: Two columns
•	
320< and <799: Four columns
•	
800<: 12 columns

Chapter 2
[ 23 ]
The grid CSS from Gridpak is very lightweight and clear. It only has 3 KB and 
it is a nonminified version (a minified CSS or JS file is a version with comments, 
unnecessary spaces, and line breaks removed to reduce bandwidth). To create a 
sample RWD page, I will use both Bootstrap and Gridpak.
Twitter's Bootstrap, besides grids and reset styles, features a rich JavaScript 
component library. For this project, I need a responsive toolbar.
Responsive toolbar
The Bootstrap version without the grid system we created in the beginning of this 
chapter is the version we need now. The compile script is improved in this version 
and thanks to this, we had easily compiled a 27 KB version of boostrap.css.
New website directory structure

Sample RWD Setup for Client-Side Development
[ 24 ]
As a base for the HTML template, we can use the Gridpak sample file. The following 
code helps us link the updated CSS files in the header. site.css is an empty 
stylesheet for website-specific CSS.
<link rel="stylesheet" media="all" type="text/css" 
  href="assets/css/gridpak.css" />
<link rel="stylesheet" href="assets/css/bootstrap.css">
<link rel="stylesheet" href="assets/css/site.css">
I added a local copy of jQuery to speed up testing using the following code:
<script src="assets/js/jquery-1.10.2.min.js"></script>
Just before the end of the <body> element, we can inject the gridpack.js and 
bootstrap js files. Gridpack.js is used to generate a grid overlay on the page and 
is just a testing helper.
With the help of .png grid templates, I created a simple layout as shown in the 
following screenshot:
Fluid design we will code in this chapter

Chapter 2
[ 25 ]
Implementing responsive design
To start the implementation process, I exported image files in their largest size 
(maximum assumed page width will be 2500px) and started to create the document 
structure, shown as follows:
<div class="page">
<!-- here we need navigation -->
  <div class="row">
    <div class="front_main_photo_wrapper col"></div>
  </div>
  <div class="row">
    <div class="photo_block4 item1 col">
      <img src="assets/img/img_front1_big.jpg"></div>
    <div class="photo_block4 item2 col">
      <img src="assets/img/img_front2_big.jpg"></div>
    <div class="photo_block4 item3 col">
      <img src="assets/img/img_front3_big.jpg"></div>
    <div class="photo_block4 item4 col">
      <img src="assets/img/img_front4_big.jpg"></div>
  </div>
  <div class="row">
    <div class="footer col"></div>
  </div>
</div>
Note that images inside these blocks became fluid without any action from our side. 
This happens because of H5BP CSS defaults, shown as follows:
img {
  max-width: 100%;
[...]
}
Classes .row and .col are Gridpak classes that set columns, margins, and padding 
according to the settings we created on www.gridpak.com. The class .page is the 
main content wrapper that can be used to define margins around content if we need 
them. An alternative way to define such margins may be by setting up padding on 
body elements. Bootstrap uses the following way for screens below 767px:
@media (max-width: 767px) {
  body {
    padding-right: 20px;
    padding-left: 20px;
  }

Sample RWD Setup for Client-Side Development
[ 26 ]
I'd like to set the left and right margins at five percent. Setting up padding on the 
body is the simplest way but it's not really a reliable or flexible way for this purpose 
(explaining this in detail is beyond the scope of this book). Instead I would try to 
control the content width with the following statement:
.page,bodydiv#gridpak{
  width:90%;
  margin:0px auto;
  padding:0 5% 0 5%;
}
Of course, to make the preceding code work as expected, it is necessary to comment 
out or override the Bootstrap <body> padding.
Classes .photo_block4, .footer, and.front_main_photo_wrapper are custom 
semantic names, and we have to define them within the respective media queries. 
This means that for each of the defined media query steps, we should decide how 
many columns wide the particular page block element should be. In our example, the 
class photo_block4 will take the following size:
•	
3 columns in resolution 800px to infinity
•	
2 columns in resolution 320px to 800px
•	
2 columns in resolution 320px and lower
Its translation to code is shown as follows:
inside: (min-width: 0px) and (max-width: 319px)
.photo_block4{width:48.5%;} /*same as .span_2 */
inside: @media screen and (min-width: 320px) and 
  (max-width: 799px)
.photo_block4{width:23.5%;} /*same as .span_2 */
inside: @media screen and (min-width: 800px)
.photo_block4{width:24.25%;} /*same as .span_3 */
It works fine when the width is greater than 800px, where we have images in a row. 
There is however a problem when our four images are broken down into two or 
more rows. Gridpak uses the following CSS instruction to remove the left margin 
from the column class .col:
 .row .col:first-child {margin-left:0;}
We have to take care of this ourselves in each media query where we see the 
problem, shown as follows:
@media screen and (min-width: 320px) and 
  (max-width: 799px) {
  .row .col:first-child, .photo_block4.item3.col{
    margin-left:0;
  }

Chapter 2
[ 27 ]
On this screen size, we start a new row from item three. For max-width: 319px, 
we can just merge .photo_block4 definition with .span_2, as shown in the 
following code:
.span_2, .photo_block4 {
  margin-left:0;
  width:100%;
}
Now our blocks flow nicely across all resolutions. It's time to add some content 
using the following code:
<div class="main_photo">
  <img src="assets/img/photo_big.jpg">
</div>
The preceding HTML code is for the main photo. Please note that there is no .col 
class on the main photo div. In the original design, this photo extends to the full 
width of a container, <div class="page">. To avoid column padding, I just don't 
use the .col class. Actually, using Gridpak CSS for column padding is not very 
helpful in my design. But that is a good starting point and a reference when creating 
and coding design. At the end of the day, the code needs a cleanup, so I treat it as 
a part of the iterative process of building the page code. Most of the code in the 
bootstrap reduced.css can and should be removed before turning this example into 
a production code. Nonetheless, as we will use the Carousel component from this 
package, I leave it as is.
The following is the code for one of the blocks with a small photo:
<div class="photo_block4 item1 col">
  <img src="assets/img/img_front1_big.jpg">
    <h3>Rustical interiors</h3>
    <p>Loremipsum dolor sitamet, [...]. </p>
</div>

Sample RWD Setup for Client-Side Development
[ 28 ]
I don't describe CSS formatting for this block as it'd make this chapter unnecessarily 
long and complex. An issue related to CSS frameworks which is worth mentioning 
is the column padding problem. I needed the images above block headers to take 
full width using the .col class here, but this was an issue. To solve it, I override its 
default padding (coming from Grider stylesheet) in site.css by forcing all instances 
of photo_block4 div to have padding:0px. It is easier to add your own padding 
or margins to other elements of this block rather than trying to mess with negative 
margins. I just added the following code:
.photo_block4 p{
  padding:0px 5%;
}
.photo_block4 h3{
  padding:0px 3%;
}
Our page needs a top responsive navigation bar, which is obtained using the 
following code:
<div class="navbar navbar-inverse navbar-fixed-top">
  <div class="navbar-inner">
    <div class="page">
      <button type="button" class="btn btn-navbar" 
        data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="brand" href="#">Chatazapiecek</a>
      <div class="nav-collapse collapse">
        <ul class="nav">
          <li class="active"><a href="#">Home</a></li>
          <li><a href="#about">About</a></li>
          <li><a href="#contact">Contact</a></li>
        </ul>
      </div>
    </div>
  </div>
</div>

Chapter 2
[ 29 ]
The preceding code is based on a sample from http://twitter.github.com/
bootstrap/examples/starter-template.html. The Class .navbar-fixed-
top causes the navigation bar to stay attached to the top of the window on wide 
screens. <div class="page"> is the wrapper that constrains the navigation 
bar width to the same width as that of the page contents. The contents of <div 
class="nav-collapse collapse"> are collapsed on small screens while <button 
type="button" class="btn btn-navbar" data-toggle="collapse" data-
target=".nav-collapse"> is shown to allow expanding this section.
An issue related to the navigation bar formatting is that fixed positioning on wide 
screens results in hiding a part of the page below it. To compensate for this effect, we 
can simply add the following code:
@media screen and (min-width: 979px){
  body{
    padding-top:70px;
  }
}
In this way we added the body element's top padding within the same media query 
as the navigation bar position changes to fixed.
For the final touch, I slightly adjusted the header font size to improve the page look 
in some resolutions using the following code:
@media screen and (max-width: 1200px) {
  .photo_block4 h3{
    font-size:18px;
    line-height:22px;
    padding-bottom:8px;
    padding-top:8px;
  }
}
To see the final document, please refer to the current chapter's resources directory. 
The page has a grid overlay on top. To hide it, just press G on the keyboard.
www.allitebooks.com

Sample RWD Setup for Client-Side Development
[ 30 ]
Summary
In this chapter, we created a sample HTML document that adjusts its layout to 
the screen size. We used Twitter's Bootstrap framework for its reset styles, default 
formatting, and responsive components library (here we employed just a responsive 
toolbar), and integrated it with a responsive grid created with the Gridpak tool. 
We still have some unsolved problems here, the most important of them being 
images. They scale nicely in all resolutions; however, when providing for a 320px 
screen size, images that look nice in resolutions above 2000px are a waste of 
bandwidth, device memory, and processing power. To optimize this, we will take a 
look at our Server Side options such as device detection libraries.

Server Side Setup – Device 
Detection Libraries
In this chapter we will discuss device detection libraries—tools that may help you to 
improve user experience on various devices.
In the previous chapter we created a responsive web document that adapts to screen 
resolution, but we didn't solve at least two issues, listed as follows:
•	
We use the same images for very large and very small screens; this means 
that, for a device that has a screen 320 px wide, we will download the 2500 px 
wide version anyway
•	
Our JavaScript and CSS elements are quite large, modern, and demanding in 
terms of processing power, browser capability, and memory, which though 
fine for most modern bleeding edge devices are still bad for older 
and cheaper phones.
To deal with this, we are going to use one of the old ways—a device detection library.
The history of the mobile web goes back over 10 years. The very first phones capable 
of browsing the Web used WAP with XHTML Mobile Profile as the document 
markup language instead of "normal" HTML over HTTP. Those days, making 
a website for mobile devices without Server Side mobile detection was simply 
impossible. Hence, Server Side device detection toolkits became indispensable for 
mobile web developers. Those libraries rely on parsing user agent strings; they map 
this information to device and browser capabilities and group them into groups with 
similar levels of support for content to be served. The two most well-known device 
databases are DeviceAtlas (available at www.deviceatlas.com) and WURFL.

Server Side Setup – Device Detection Libraries
[ 32 ]
The traditional way to serve content to mobile devices is based on the 
following elements:
•	
Mobile websites, usually on subdomains such as m.example.com
•	
Integrating a device detection library to look up device capabilities and 
assign them to groups (device classes) based on XHTML-MP, HTML5, image 
support, and so on
•	
Templates optimized for each device class
•	
Adapting content to ensure it is appropriate for a particular device class 
(resizing images and other media)
Both WURFL and DeviceAtlas are commercial solutions. A short comparison is 
shown in the following table:
Details
WURFL
DeviceAtlas
Free version available?
Yes
No 
(14-day trial available)
Free version limitations
•	 The cloud version 
has only 2 
capabilities
•	 5.000 detections
Not Available
AGPL version available?
Yes, standalone version for 
PHP, .NET, and Java
No
Cloud version license plan pricing
0-500 USD/month
40-400 USD/month
OnSite version pricing
1,500-20,000 USD /month
Unknown
WURFL was, until Version 2.2, released under an open source/public domain 
license. As of August 30, 2011, it has dual license and updates are less frequent (the 
public version of the repository is updated once every 2-3 months). WURFL consists 
of two components, the resource file and APIs to access it. Dual license applies to 
standard APIs. The resource file is copyrighted by ScientiaMobile and commercial 
usage is strictly forbidden. The license also forbids any modification or use with non-
standard AGPL-licensed APIs.
Translating this to plain English, it means that you can hardly use the standalone 
WURFL AGPL version for anything more than testing. If you decided to publish 
your work online, and if you think that your use is strictly non-commercial, you'd be 
required to publish your whole website code.
This change in licensing was the reason why WURFL support was dropped in the 
Zend Framework. Nonetheless, we can download and test this solution for ourselves.

Chapter 3
[ 33 ]
The AGPL licensed "OnSite" version of 
the WURFL library
To download the WURFL file along with PHP APIs, go to http://sourceforge.
net/projects/wurfl/files/WURFL%20PHP/ and unpack the downloaded file 
(in my case it was wurfl-php-1.4.4.0.zip). You should see a directory structure 
as follows:
•	
docs\
•	
examples\
•	
tests\
•	
tools\
•	
WURFL\
Now we will integrate this with the web page created in Chapter 2, Sample RWD 
Setup for Client-Side Development. For the purpose of this example, I use the default 
setup for WampServer (available at http://www.wampserver.com). WampServer 
is a Windows web development environment based on the Apache server, MySQL 
database, and PHP. The web root is C:\wamp\www\. I created the h5bpdemo directory 
there, which will be our website's root directory. Our setup looks like the following:
•	
c:\wamp\www: The server document root
•	
c:\wamp\www\h5bpdemo\: The website base directory (website document 
root)
•	
http://127.0.0.1/h5bpdemo/: The HTTP website base directory
•	
http://h5bp.test/: The local domain http://h5bp.test/ is achieved by 
adding this line of code to C:\Windows\System32\drivers\etc\hosts:
127.0.0.1 h5bp.test
The following code is used to create the Vhost in c:\wamp\bin\apache\
apache2.2.22\conf\extra\httpd-vhosts.conf:
<VirtualHost *:80>
  ServerAdmin webmaster@dummy-host.example.com
  DocumentRoot "c:/wamp/www/h5bpdemo/"
  ServerName h5bp.test
</VirtualHost>
Also the following needs to be uncommented in c:\wamp\bin\apache\
apache2.2.22\conf\extra\httpd-vhosts.conf:
#Include conf/extra/httpd-vhosts.conf

Server Side Setup – Device Detection Libraries
[ 34 ]
Before I delve into details, I should define the purpose of the application I'm about 
to create. It should help me solve issues some visitors might have when they 
visit my website. So first I have to learn something about the devices my customers 
are using. I live in Europe and I assume my customers come from Europe too. 
To get some up-to-date statistics about the mobile browsers they use, I go to 
http://gs.statcounter.com and look for last month's mobile browser statistics. 
In these statistics, iPhone, Android, and Opera lead in March 2013. In some 
countries, around or over 10 percent usage is via Blackberry (UK 15 percent) and 
Nokia (Albania 10 percent). This is good news because all these are HTML-enabled 
browsers and we won't need any WML templates. Some of the code in the RWD 
sample uses JavaScript to manipulate document structure. I also used modern CSS to 
format the document. It may not work on some older devices. I decided to group my 
devices into the following three categories:
•	
Basic: XHTML with basic CSS
•	
Medium: XHTML with decent CSS and image support
•	
Advanced: HTML5 with CSS Level 3 and good JavaScript support 
(AJAX-manipulating DOM structure)
At the moment, I'm not going to deal with image resizing. There is a separate chapter 
devoted to that. Here I will just use the preceding three templates to adjust HTML 
and CSS markup and attach JavaScript only for devices that can really understand 
it. I'm going to test several solutions, and my application structure should allow for 
easy swapping from one library to another.
After copying files from the previous chapter, I added directories for the Server Side 
code, so it now is shown as follows:
•	
/app/: My Server Side application directory
•	
/app/bootstrap.php: The loader for the Server Side application
•	
/app/config.php: The general configuration file for this application
•	
/app/libs/: For Server Side libraries
•	
/app/libs/WURFL/: APIs from wurfl-php-1.4.4.0.zip
•	
/app/templates/: For partial templates
•	
/app/wurfl_onsite/: The directory for my app module based on 
standalone WURFL AGPL
•	
/app/wurfl_onsite/app.php: My class wrapper for WURFL API
•	
/app/wurfl_onsite/config.php: The configuration file for this module 
based on examples\demo\inc\wurfl_config_standard.php, which is in 
the official API package

Chapter 3
[ 35 ]
•	
/app/wurfl_onsite/resources/: The location for the WURFL file with 
device descriptions
•	
/app/wurfl_onsite/resources/storage/: Internal WURFL PHP API 
storage
•	
/app/wurfl_test.php: Test page using the WURFL PHP API
•	
/assets/: here we have all JavaScript, CSS, and images created in the 
previous chapter
The file wurfl_test.php will be the test page for our website WURFL library. 
Boostrap will help us to inject into this page the ability to detect the device class. To 
be able to change the device detection library without changing the Bootstrap code 
(and to be able to test at the same time), I created a very simple loader function inside 
bootstrap.php shown as:
function getDDLobject($library) {
  if ($library=='wurfl_onsite') //later I can add other
  {
    require_once APPLICATION_DIR.'wurfl_onsite/app.php';
    $DDLobject=new Mod_Wurfl_Onsite();
    return $DDLobject;
  }
}
Now in /wurfl_on_site.php, I can get $DDLobject (the device detection library 
object) by writing the following code:
include "app/bootstrap.php";
$DDLobject = getDDLobject('wurfl_onsite');
This object is an instance of a custom class that is a wrapper for provider APIs. 
It allows us to build our own classifications based on defined requirements. But 
to use it we need to first create our Mod_Wurfl_Onsite class. This will reside in 
APPLICATION_DIR. The constant 'wurfl_onsite/app.php'. The APPLICATION_DIR 
directory is defined in the application config file, /app/conf.php. The class uses a 
few internal member variables, shown in the following code:
protected $config;
protected $wurfl_config;
protected $wurfl_manager;
protected $wurfl_device;

Server Side Setup – Device Detection Libraries
[ 36 ]
$config is a convenience configuration data container that we pass to $this-
>config in the constructor shown in the following code:
function __construct() {
  include dirname(__FILE__)."/conf.php";
  $this->config=&$config;
  $this->createWurflObject();
}
In the constructor we load the configuration data from APPLICATION_DIR.'wurfl_
onsite/conf.php using the following code:
$config['MOD_DIR'] = APPLICATION_DIR.'wurfl_onsite/';
$config['MOD_NAME'] = 'wurfl_onsite/';
$config['WURFL_API_DIR'] = LIBRARIES_DIR.'WURFL/';
$config['WURFL_RESOURCES_DIR'] = 
  $config['MOD_DIR'].'resources/';
$config['WURFL_RESOURCE_FILE'] = 
  $config['WURFL_RESOURCES_DIR'].'wurfl.zip';
$config['WURFL_STORAGE_DIR'] = 
  $config['WURFL_RESOURCES_DIR'].'storage/';
$config['WURFL_CACHE_DIR'] = 
  $config['WURFL_STORAGE_DIR'].'cache/';
$config['WURFL_PERSISTENCE_DIR'] = 
  $config['WURFL_STORAGE_DIR'].'persistence/';
Basically these are the directories that WURFL uses. The OnSite version of WURFL 
parses the XML device description file contained in wurfl.zip to create a cache 
during the first launch. To use this data in the function createWurflObject(), 
we load the WURFL API (require_once ($this->config['WURFL_API_
DIR'].'Application.php ');), create WURFL_Configuration_InMemoryConfig, 
and assign to it the configuration data as shown in the following code:
function createWurflObject() {
  require_once ($this->config['WURFL_API_DIR'].
    'Application.php '); //load WURFL API
  $this->wurfl_config = new 
    WURFL_Configuration_InMemoryConfig();
  $this->wurfl_config->wurflFile($this->config[
    'WURFL_RESOURCE_FILE']);
  $this->wurfl_config->persistence('file', 
    array('dir' => $this->config['WURFL_PERSISTENCE_DIR']));
  $this->wurfl_config->cache('file', 
    array('dir' => $this->config['WURFL_CACHE_DIR'],
  'expiration' => 36000));
  $this->wurfl_config->matchMode('performance');
  // Set the match mode for the API ('performance' 
    or 'accuracy')
  $this->wurfl_config->allowReload(true);

Chapter 3
[ 37 ]
With all the necessary options assigned, we just pass this object to the WURFL_
WURFLManagerFactory constructor as shown in the following code:
$wurflManagerFactory = 
  new WURFL_WURFLManagerFactory($this->wurfl_config);
With the WURFL_WURFLManagerFactory instance, we can create the wurfl_manager 
instance and store it in our class variable as follows:
$this->wurfl_manager = $wurflManagerFactory->create();
}
We are now almost ready to read device capabilities. I created a method for this, 
named getDeviceClass(), as shown in the following code. It returns one of the 
four strings describing the device, that is, the name of one of our device groupings 
(classes) plus unsupported in case we are dealing with some really old device and 
can't use HTML at all (as we had originally decided to create only HTML versions).
function getDeviceClass() {
  $this->wurfl_device = 
    $this->wurfl_manager->getDeviceForHttpRequest($_SERVER);
  $xhtml_level = $this->wurfl_device-
    >getCapability('xhtml_support_level');
  if ($xhtml_level<0) {
    return 'unsupported';
  }
  if ($xhtml_level<3) {
    return 'basic';
  }
}
To start with, I pass the $_ SERVER PHP environment variable to the $this-
>wurfl_manager-> getDeviceForHttpRequest method. It returns to us the 
wurfl_device instance we can query for device capabilities. To do this we need to 
learn what capabilities we can ask for. There is a list of those available at http://
wurfl.sourceforge.net/help_doc.php. The capability xhtml_support_level is 
the easiest and most important from our point of view. Each of the capabilities may 
have a different set of possible values. xhtml_support_level has one of the six levels 
represented as an integer in the range [-1,4]. The description of the levels is as follows:
•	
Level -1: This means that there is no XHTML support of any kind.
•	
Level 0: This gives us basic XHTML support with no or very unreliable CSS 
support.
•	
Level 1: This has XHTML with some CSS support. Hyperlinks may not be 
colorable by CSS. The minimum screen  width is 120 pixels.

Server Side Setup – Device Detection Libraries
[ 38 ]
•	
Level 2: This is generally the same as level 1.
•	
Level 3: It has excellent CSS support.
•	
Level 4: It consists of Level 3 plus Ajax support.
I assigned the preceding levels to our groupings as shown in the following table:
Group name
Level
Comments
Unsupported
-1
Basic
0, 1, and 2
The template for the basic group can only 
contain very basic HTML.
Medium
3 and 4
It consists of level 3 and level 4 elements 
without confirmed and good JavaScript 
capabilities. For testing this I use two other 
capabilities, ajax_manipulate_dom and 
ajax_support_events. Originally I wanted 
to also use css_rounded_corners and css_
gradient but rounded corners turned out to 
be unreliable and css_gradient didn't work 
at all in the public version of the PHP API. 
The template for the medium group can be the 
same as for the advanced group but 
with removed jQuery and without 
JavaScript-related CSS.
Advanced
4
It consists of level 4 elements with ajax_
manipulate_dom and ajax_support_
events capabilities. The template for the 
advanced group remains unchanged.
According to the preceding table, testing for advanced and medium groups is 
slightly more complex, as shown in the following code:
if ($xhtml_level>=3) {
  $css_ajax_dom_support = 
    $this->wurfl_device->getCapability(
    'ajax_manipulate_dom');
  $css_ajax_events_support = 
    $this->wurfl_device->getCapability(
    'ajax_support_events');
  if(($xhtml_level==4)
    &&$css_ajax_events_support
    &&$css_ajax_dom_support) {
    return 'advanced';
  } else {
    return 'medium';
  }
}

Chapter 3
[ 39 ]
The WURFL Cloud version
There is a limited free offering from ScientaMobile that can be used commercially 
by microbusinesses. To get access to it, it is necessary to register at https://www.
scientiamobile.com/cloud/signup/free. After confirming the e-mail address, 
log in to http://www.scientiamobile.com, go to your account page, and after 
clicking on your account name, you can find your API key and download the client 
code. We can use two capabilities with the free account and we need to add them to 
our account. 
The Scientia mobile capabilities screen
Let's follow the Cloud Capabilities link on the left. On the Capabilities page, from 
the drop-down menu, select markup to drag xhtml_support_level to the Your 
Capabilities area. Then, similarly select Ajax in the drop-down menu and drag the 
capability ajax_manipulate_dom to the Your Capabilities area.
www.allitebooks.com

Server Side Setup – Device Detection Libraries
[ 40 ]
We assign the API key (copied from Account Settings | API keys) to a private 
member variable of our class, which is shown as follows:
class Mod_Wurfl_Cloud {
  private static $api_key = 
    '644333:XXXXXnUqrX6YsZfViS2cert3o0XXXXX';//instead of 
    this API key please use your own
Our createWurflObject method is much shorter now, as seen in the following 
code. There is no device factory class in the cloud API, and we only create the config 
object relying on defaults.
function createWurflObject() {
  require_once $this->config['WURFL_CLOUD_CLIENT_FILE'];
  $this->wurfl_config = new WurflCloud_Client_Config();
  $this->wurfl_config->api_key = self::$api_key;
}
The getDeviceClass method (shown in the following code) is almost the same as in 
the OnSite version, except we now use an instance of WurflCloud_Client_Client 
instead of WURFL_CustomDevice to query device features with getCapability 
instead of the getDeviceCapability method. We are also limited now to two 
capabilities, as we're using the free version.
function getDeviceClass() {
  $this->wurfl_client = new 
    WurflCloud_Client_Client($this->wurfl_config);
  $this->wurfl_client->detectDevice();
  $xhtml_level=$this->wurfl_client->getDeviceCapability('
    xhtml_support_level');
  if ($xhtml_level<0) {
    return 'unsuported';
  }
  if ($xhtml_level<3) {
    return 'basic';
  }
  if ($xhtml_level>=3) {
    $css_ajax_dom_support = 
      $this->wurfl_device->getCapability(
      'ajax_manipulate_dom'); // true/false
    if (($xhtml_level==4)&&$css_ajax_dom_support) {
      return 'advanced';
    } else {
      return 'medium';
    }
  }
}

Chapter 3
[ 41 ]
YABFDL – Detector
Detector or "yet another browser and feature- detection library" by Dave Olsen, 
available at https://github.com/dmolsen/Detector, represents quite a different 
approach to the same problem. Instead of relying on centrally updated, database-
binding UA strings to device capabilities, it uses JavaScript feature detection, stores 
collected information in the session variable, and saves it to the local cache. The most 
important features include:
•	
Combining Server Side and Client Side browser-feature detection
•	
A free, open, and very permissive license
•	
Automatically updates the device list upon unknown device visit
•	
The Detector relies on the JavaScript modernizr.js
Detector is in the Beta version and is not updated very often but is worth attention, 
especially when your target devices are JavaScript capable. The 5477 User Agent 
(UA) profiles registered by Detector until today seem modest in comparison to 
the 1,200,000 UA profiles in the 51degrees database (http://51degrees.mobi; 
51degrees is a solution similar to DeviceAtlas or WURFL), but Detector's autoupdate 
feature allows support to all browsers that are able to parse the modernizr.js script.
Detector's process of detecting browser features works in the following three steps:
•	
If there is an open session for this visitor, the feature list from the session 
variable is used
•	
If there is no valid session, the UA string is checked against a list of UAs that 
have already visited the website, and if a match is found, a related feature list 
is used
•	
If there is no match, Modernizr tests are being sent to the browser; the result 
is saved in a cookie, the page is reloaded, and the data is saved on the server
Detector is very easy to set up and integrate. After downloading Detector from 
https://github.com/dmolsen/Detector and extracting the ZIP file, we have to 
copy the contents of the Detector0XX/lib/Detector/ directory to our library's 
directory, app/libs/Detector. Following the pattern from the last example, we 
will also create the app/detector directory for conf.php and app.php. In this case 
conf.php needs to just hold the library directory, as shown in the following code:
$config['DETECTOR_API_DIR'] = LIBRARIES_DIR.'detector/';

Server Side Setup – Device Detection Libraries
[ 42 ]
Creating detector in the Mod_Detector class inside app.php is simple too, as 
shown in the following code:
function createDetector() {
  require_once ($this->config['DETECTOR_API_DIR'].
    'Detector.php');
  $this->detector_ua = $ua;
}
With $this->detector_ua, we can read device properties using the following code:
if($this->detector_ua->fontface) {
  echo '@font-face allowed';
}
Detector's CSS3 detected features list

Chapter 3
[ 43 ]
All device capability tests in Detector return only true or false. There is nothing 
resembling the xhtml_support_level WURFL capability. In fact, we should not 
expect any information about devices with no or very basic XHTML support from 
this library. Checking the strings of UA's registered on http://detector.dmolsen.
com/ against the WURFL xhtml_support_level feature shows that all of them have 
a value of 3.
At the same time, their level of support for CSS and HTML5 properties varies a 
lot and we can check it very precisely to learn, for example, whether a particular 
browser supports @font-face, text-shadow, CSS gradients, and so on.
Before using this library we need to take into account the following factors:
•	
Whether it is in Beta version and requires some real testing before it can be 
used in the production code
•	
Whether it is only for relatively modern phones, not those older than three 
years (it works only with browsers with JavaScript and cookies support)
Whether this library can be useful for us depends on the preceding factors.
The good news is that now, in March 2013, it should work for more than 90 percent 
of global mobile browsers, as can be seen at the following link:
http://gs.statcounter.com/#mobile_browser-ww-monthly-201202-201303
Detector works for UC browser too.
Summary
Using custom wrapper classes, we integrated three device detection libraries into 
a simple but consistent environment. Now we are ready to fine-tune our mobile 
groups and start building our RESS application. In the next chapter we will create 
four simple RESS solutions, each based on another library or method to detect 
User Agent features.


Sample RESS Page
In this chapter we focus on the information flow in an RESS application. We take a 
closer look at the possible strategies in building an RESS application and we create 
four sample scenarios based on WURFL, Detector, or just on simple JavaScript.
There is no strict definition of what an RESS system is, except that it uses a 
mixture of Server Side and Client Side device optimization. The idea is to build 
a pragmatic approach that allows better adjustment of RWD page components to 
some device classes.
We need to define the practical purposes of our RESS system, which are as follows:
1.	  Adjusting a document to device capabilities (HTML markup, CSS level, and 
JavaScript code). This particularly means:
°°
Creating simplistic markup for older devices, for those with very 
limited screen size, and for those with a slow processor, to ensure 
that the page is displayed on all devices that support any kind of 
HTML markup
°°
Optimization of markup for devices that support modern constructs
°°
Using jQuery components when it is possible
2.	 Adjusting media (images in our case) to device screen width.
3.	 Allowing manual selection of the page version (lower, if the customer wishes 
to reduce bandwidth to minimum possible value or higher, if the customer 
wishes to try the enhanced version).

Sample RESS Page
[ 46 ]
To fulfill the preceding tasks we can use various solutions. In this chapter we will 
discuss the following four approaches:
•	
WURFL plus screen size detection
•	
Dave Olsen's Detector
•	
The simplest possible approach, based only on JavaScript screen size 
detection and fallback to a simplistic page if this fails
•	
Dave Olsen's Detector plus WURFL
WURFL plus screen size detection
We use the same framework setup for our test RESS applications as we did in the 
previous chapter with device detection libraries. You can find it in the directory 
ress_cookie_wurfl with the class Ress_Cookie_Wurfl in app.php. I added a 
generalized apploader to bootstrap.php. The Apploader (application loader) in this 
case is just a function in bootstrap.php that takes the module name as an argument 
and returns a module class instance. We can now get the Ress_Cookie_Wurfl class 
instance from my test page ress_cookie_wurfl.php with the following line of code:
$RESS_app1 = loadApp('ress_cookie_wurfl');
We start processing the request by checking if a cookie exists and if it does, we save 
this value to a class variable, as in the following code:
if (array_key_exists('screen_width', $_COOKIE)) {
  $cookie_screen_width = $_COOKIE['screen_width'];
  $this->screen_width = $cookie_screen_width;
  $this->cookie_exists = true;
}
If for some reason we don't have a cookie, we use the following code:
else {
  $this->screen_width=$this->getWurflWidth();
}

Chapter 4
[ 47 ]
The getWurflWidth() function loads our custom Mod_Wurfl_Onsite class and 
checks the default screen width, as in the following code:
function getWurflWidth() {
  $this->wurfl_object = getDDLobject('wurfl_onsite');
  return $this->wurfl_object-
    >getDeviceCapability('resolution_width');
}
As bootstrap.php should already be loaded, we can use the getDDLobject() global 
function to load our Wurfl_Onsite library wrapper and read the default screen 
width based on the UA string.
To save the screen size in a cookie, it is enough to put a few lines of JavaScript 
like this:
<script type="text/javascript">
  var RESS_a = {};
  RESS_a.width = window.innerWidth;
  RESS_a.setCookie=function(name,value,days){
    var Cdate=new Date();
    Cdate.setDate(Cdate.getDate() + days);
    var c_value=value + ((days==null) ? "" : "; 
      expires ="+Cdate.toUTCString());
    document.cookie=name + "=" + c_value;
  }
  RESS_a.setCookie("screen_width",RESS_a.width,30)
</script>
With this code we create the RESS_a object, which allows us to separate our 
setCookie function from other JavaScript we might wish to attach to the page later.

Sample RESS Page
[ 48 ]
The following figure shows the information flow in this scenario. We are only 
interested in obtaining the actual screen width. Using WURFL just for this purpose 
seems both unreliable and overshot. In most cases, we could probably just rely on 
JavaScript or use some safe fallback in case it doesn't work. The problem is that we'd 
have to force reload a page (in a similar way that the Detector does in the following 
sample) risking getting into a reload loop.
Dave Olsen's Detector
The Detector library is an attempt to make device detection libraries based on the 
analysis of UA strings obsolete. The problem with this is that it needs to send the test 
page to a browser that supports JavaScript and has it turned on. In order to speed up 
the page loading, it employs the following two mechanisms:
•	
Using the server cache of UA string footprints (which ironically makes it, in a 
way, a UA string analysis library)
•	
Storing client information in both a session variable and a cookie

Chapter 4
[ 49 ]
The following figure illustrates information flow between the Detector and the 
browser. The HTTP request drawn on the left side represents the first and each 
consecutive "regular" request. The one drawn on the right side is sent from the test 
page and may occur as a second request when none of the conditions in the center 
of the figure is met. In other words when the user requests any page on the website, 
Detector tries to determine the following:
•	
If cookies and JavaScript are supported
•	
If this user visited this website before (browser data is then cached in a 
session variable)
•	
If the User Agent footprint and the relevant profile are cached in the system
If all these checks fail, Detector sends a test page instead of the regular one. The test 
page executes the reload and returns missing information in the next request. After 
the test request, the original (regular) page is sent to the browser.
www.allitebooks.com

Sample RESS Page
[ 50 ]
The first check (as shown in the preceding figure), does browser support JS and 
COOKIES, is based on checking for the nojs = true parameter using the 
following code:
(isset($_REQUEST["nojs"]) && ($_REQUEST["nojs"] == "true")) 
  || (isset($_REQUEST["nocookies"]) && 
  ($_REQUEST["nocookies"] == "true"
This may come the test for JavaScript support in the form of the following code:
<noscript><meta http-equiv='refresh' content='0; 
  url=".self::buildNoscriptLink()."'></noscript>
Or it may come from the JavaScript test for cookie support in the browser (in /app/
libs/Detector/lib/modernizr/cookieTest.js), using the following code:
function getCookie() {
  var i,x,y,ARRcookies=document.cookie.split(";");
  for (i=0;i<ARRcookies.length;i++)
    {x=ARRcookies[i].substr(0,ARRcookies[i].indexOf("="));
    y=ARRcookies[i].substr(ARRcookies[i].indexOf("=")+1);
    x=x.replace(/^\s+|\s+$/g,"");
    if (x == "testCookie") {
      return y;
    }
  }
}
document.cookie = "testCookie=testData";
var cookieRedirect = (window.location.href.match(/\?/)) 
  ? window.location.href + "&nocookies=true" : 
  window.location.href + "?nocookies=true";
The code is applied with the following statement (in the /app/libs/Detector/
Detector.php library):
if (getCookie() != 'testData') {
=window.location = cookieRedirect;
}
But a majority chunk of the JavaScript (besides Modernizr itself) is a function _mer 
based on the Modernizr server. It iterates Modernizr properties and encodes those 
that are recognized as browser properties to the cookie. After decoding them on the 
server-side, they are stored in the stdclass object and returned as the $ua variable 
in Detector.php.

Chapter 4
[ 51 ]
As with the other examples, I use the same module and 
directory structure that allows us to create a module 
class instance with the function loadApp($appName) 
from the file bootstrap.php.
To actually use the Detector library, I put the files downloaded from 
https://github.com/dmolsen/Detector to the app/libs/Detector directory. 
I then created the Ress_Detector class in the app/ress_detector/app.php file. 
This class is essentially nothing more than a simple wrapper for the Detector library 
that allows us to use some of its functions via an interface consistent with other 
examples. In the member function createDetector() called from the constructor, 
we include Detector.php and assign the $ua variable to the class property 
detector_ua, as in the following code:
  function createDetector() {
    require_once ($this->config['DETECTOR_API_DIR'].
      'Detector.php');//load WURFL API
    $this->detector_ua=&$ua;
  }
In this way we can easily pull Detector information of interest to us, anywhere inside 
the Ress_Detector class. Member functions of this class shown in the following 
code facilitate accessing browser properties via a consistent interface (by consistent 
interface, I mean here keeping the same signatures of the key methods in all the 
examples in this chapter. This allows easy swapping of detection modules without 
breaking the application).
function getDeviceClass() {
  return $this->detector_ua->family;
}
function getScreenWidth() {
  return $this->detector_ua->screenattributes->windowWidth;
}
function getDeviceCapability($name) {
  if(isset($this->detector_ua->$name))
  {
    return $this->detector_ua->$name;
  } else {
    return null;
  }
}

Sample RESS Page
[ 52 ]
All the preceding code in this section may be contained inside the template as in the 
following code:
<?php include "app/bootstrap.php";
$RESS_detector = loadApp('ress_detector');
?>
  <body>
    <p>device class: <?php echo $RESS_detector->
      getDeviceClass(); ?></p>
    <p>screen width: <?php echo $RESS_detector->
      getScreenWidth(); ?></p>
    <p>fontface: <?php $fontface = $RESS_detector->
      getDeviceCapability("fontface") ;
    echo $fontface?"supported":"not supported"; ?></p>
  </body>
Pure JavaScript screen size test
In this approach, we don't use any external libraries. We don't test for browser 
capabilities as in the first example; we are only concerned with the screen width. 
The purpose here is to create something simple and extendable at the same time. 
The PHP code for the two main classes have less than 100 lines, and a test page set 
to the browser for reload has less than 1.5 KB in a non-minified state with all the 
JavaScript included. You can use the code from this example as a starting point 
for building your own tests best suited to your situation, without worrying about 
third-party licenses or library updates. I tried to make it as simple and safe as 
possible. In case of any problems, the result of the check will change to the basic 
version and a 120 px screen width.

Chapter 4
[ 53 ]
The following figure shows the program flow; you can see that the logic is very 
similar to that of the Detector. This simplified version doesn't store UA profiles in 
the local cache.

Sample RESS Page
[ 54 ]
The application structure is built around the same framework as our other samples. 
Processing HTTP requests (checks for Cookies and so on) is moved to the constructor 
of a separate Request class, as in the following code:
class Request
{
//true when in $_GET exists any of parameters:
 testreload | nocookies | nojs
public $from_test_page;
// if has session containing screen_width var
public $has_session;
//(no cookies or no js - will not work for us) 
  defaults to true
public $simplistic_browser = true;
//does it have our cookie
public $has_cookie;
// very low default
public $screen_width = 120;
  function __construct() {
    if (@session_start() && isset($_SESSION)
    && array_key_exists('screen_width',$_SESSION)
    && ($_SESSION['screen_width'] >0))
    {
      $this->screen_width = $_SESSION['screen_width'];
      $this->has_session = true;
    }
    if (array_key_exists('screen_width',$_COOKIE)) {
      $this->screen_width = $_COOKIE["screen_width"];
      $_SESSION['screen_width'] = $this->screen_width;
      $this->has_session = true;
    }
//it is request from test page
    if (array_key_exists('testreload',$_GET))
    {
      $this->from_test_page = true;
      $this->simplistic_browser = false;
    }
    elseif (array_key_exists('nocookies',$_GET) || 
      array_key_exists('nojs',$_GET)) {
      $this->from_test_page = true;
    } else {
      $this->from_test_page = false;
    }
  }
}

Chapter 4
[ 55 ]
This code is pretty self-explanatory—we check for a session, then for a cookie, and 
then we verify if this was called from the test page and if the browser supports 
JavaScript and cookies. Writing JavaScript and HTML code inside class methods is 
ugly and hard to maintain; hence, I created the assets directory inside this module's 
directory. Inside it you can find the following files:
•	
test_page.js: JavaScript to be placed inside the header of our browser test 
page
•	
testpage.php: The HTML markup for our test page. Inside the HTML 
header section of this file we inject the contents of test_page.js
•	
cookie.js: The JavaScript code to be placed inside the HTML header of all 
pages on the website (to update the screen width with each request)
Code contained in the test_page.js file is supposed to save the screen width in 
a cookie, if that is possible, or redirect the page to the same address but with the 
?nocookies= true string appended to the URL (this way we send the nocookies 
variable of type string with value "true" as a URL parameter. In PHP we access it via 
the _GET array). Inside the cookie_enabled function shown in the following code, 
I used a simpler and more dependable method of detecting cookie support in the 
browser. First, checking whether the document cookie exists in the browser DOM 
and then if we can save anything there.
Please note that in the following code, the RESS_pure_js.cookie_enabled = 
function() construct is used instead of the plain function bakeCookie(). We do it 
this way to keep all our functions inside a separate namespace, ensuring that we will 
not get in conflict with some other JavaScript code that might (in the future) find a 
way of getting here.
var RESS_pure_js={};
RESS_pure_js.cookie_enabled = function()
{
  document.cookie = "testcookie";
  cookieEnabled = ("cookie" in document 
    && (document.cookie.length > 0 
    || (document.cookie = 
    "test").indexOf(document.cookie, "test") > -1));
  return cookieEnabled;
}
The function bakeCookie is called in the last line of test_page.js.

Sample RESS Page
[ 56 ]
Inside the RESS_pure_js.bakeCookie() function shown in the following code, we 
call cookie_enabled to check for browser cookie support. If the test fails, we reload 
the page but with the ?nocookies=true string appended to the URL. Actually, we 
append either the ?nocookies=true or the &nocookies=true string depending 
on whether the URL contains ? already or not. If the test passes, we save the screen 
width information inside the else section. If we'd like to save other information in 
the cookie too, we do it inside the same code block (the else section).
RESS_pure_js.bakeCookie = function(){
  if (!this.cookie_enabled())
  {
    var linkNoCookies=(window.location.href.match(/\?/)) 
      ? window.location.href + "&nocookies = true": 
      window.location.href + "?nocookies=true";
    window.location = linkNoCookies;
  } else {
    this.width = window.innerWidth;
    this.setCookie("screen_width", this.width, 30);
  }
}
The setCookie function is the same as in the previous example.
The JavaScript code from the test_page.js file is injected inside the HTML header 
element of testpage.php. We still need to check for JavaScript support with Meta 
refresh, exactly the same way as in the second approach (that is, Dave Olsen's 
Detector).
When the browser supports both JavaScript and Cookies, we refresh the page with 
JavaScript. Appending the ?testreload=true string to the URL adds testreload to 
the GET variables. The value of testreload is a string "true". Using this parameter 
ensures that HTTP requests from the test page can easily be recognized on the server 
side and the reload loop can be avoided. The following snippet demonstrates the 
JavaScript reload code:
function delayed_reload() {
  var linkReload = (window.location.href.match(/\?/)) 
    ? window.location.href + "&testreload=true" : 
    window.location.href + "?testreload=true";
  window.location = linkReload;
}
[...]
<body onLoad="setTimeout('delayed_reload()', 500)">

Chapter 4
[ 57 ]
The JavaScript that checks for the screen width inside the file cookie.js—the 
one that is attached to regular pages—is slightly different than the one on the test 
page. We don't do any redirects here; we just notify our server-side application if 
the window size has changed or not, hence removing code checking for cookies 
support, URL rewriting, and redirecting. Instead, as seen in the following code, there 
is the added onresize event to update information in the cookie, in case the user 
has changed the width of the window. It's being done with some delay. Updating 
cookies each 0.5 seconds seems enough and reduces unnecessary processor load.
var RESS_pure_js={};
RESS_pure_js.bakeCookie = function(){
  this.width = window.innerWidth;
  this.setCookie("screen_width", this.width, 30);
}
// setCookie function 
RESS_pure_js.setCookie=function(name,value,days) {
  var Cdate=new Date();
  Cdate.setDate(Cdate.getDate() + days);
  var c_value=value + ((days==null) ? "" : "; expires="+Cdate.
toUTCString());
  document.cookie=name + "=" + c_value;
}
RESS_pure_js.bakeCookie()
window.onresize = function(event) {
  setTimeout('RESS_pure_js.bakeCookie()', 500)
}
With such an in-depth understanding of the way we transmit information about 
the browser to the server and with the Request class instance created, all we need 
to do is ask for this information from our class Ress_Pure_Js (a module class that 
is instantiated in the "page file" via the calling function loadApp($appName) in 
bootstrap.php). The following methods of the Ress_Pure_Js class can provide us 
with the necessary information:
function getScreenWidth() {
  return $this->request->screen_width;
}
function getDeviceClass() {
  if ($this->request->simplistic_browser)
  {
    return 'basic';
  } else {
    return 'advanced';
  }
}

Sample RESS Page
[ 58 ]
We should not forget to create and send the test page in case we didn't do it yet with 
this visitor using the following code:
function __construct() {
  include dirname(__FILE__)."/conf.php";
  $this->config = &$config;
  $this->request = new Request();
  if (!$this->request->has_session && 
    !$this->request->from_test_page)
  {
    $this->build_test_page();
  }
}
private function build_test_page()
{
  $this->cookie_test_js = @file_get_contents ($this-
    >config['MOD_ASSETS_DIR']."test_page.js");
  $test_page_template =$this-
    >config['MOD_ASSETS_DIR']."testpage.php";
  include $test_page_template;
  exit;
}
In the build_test_page function we include testpage.php to execute it in the 
scope of this function and then with exit; we immediately send the output to 
the browser.
Utility functions
The getNoJsUrl function is a safe way to add a nojs=true parameter to the current 
URL, and it looks like this:
function getNoJsUrl()
{
  $get_parameters = array('nojs'=>'true');
  $get_parameters = array_merge($get_parameters,$_GET);
  list($clean_url) = explode("?", $_SERVER["REQUEST_URI"]);
  return $clean_url."?".http_build_query($get_parameters);
}

Chapter 4
[ 59 ]
Dave Olsen's Detector plus WURFL
With this approach we want to know all the details about HTML5 and CSS3 support 
that the Detector with its Modernizr test can provide us with, while at the same time 
we try to achieve the most stability and support for devices with little processing 
power. Throwing Modernizr into an old phone is useless as there is a high 
probability it may never finish loading. To avoid this situation, we assess a visitor's 
HTML capabilities by analyzing the UA string with WURFL. We use the xhtml_
support_level WURFL property. When it is equal to or higher than 3, we include 
Detector; otherwise, we rely on the default screen width obtained from WURFL.
The implementation here is very similar to our first example except that in place of 
the cookie with the screen size we use Detector.
We start by loading the wurfl_onsite module inside the constructor, as shown in 
the following code:
function __construct(){
[...]
  $this->wurfl_object=getDDLobject('wurfl_onsite');
  $this->run();
}
www.allitebooks.com

Sample RESS Page
[ 60 ]
Inside the run method, we use it to test for XHTML support, as shown in this code:
function run() {
  $xhtml_level = $this->wurfl_object
    ->getDeviceCapability('xhtml_support_level');
  if ($xhtml_level < 0)
  {
    $this->device_class = 'unsuported';
  }
  elseif ($xhtml_level < 3)
  {
    $this->device_class = 'basic';
  }
  elseif ($xhtml_level >= 3)
  {
    $this->createDetector();
    $this->device_class = $this->detector_ua->family;
  }
}
If the device seems to use modern DOM, we load the Detector using the 
following code:
function createDetector() {
  require_once ($this-
    >config['DETECTOR_API_DIR'].'Detector.php');
  if (is_object($ua))
  {
    $this->detector_ua = &$ua;
    $this->detector_loaded = true;
  }
}
The functions to read screen width and device capabilities with fallback to 
WURFL look like this:
function getWurflWidth() {
  return $this->wurfl_object-
    >getDeviceCapability('resolution_width');
}
function getScreenWidth() {
  if($this->detector_loaded) {
    return $this->detector_ua->screenattributes->windowWidth;
  } else {
    return $this->getWurflWidth();
  }
}

Chapter 4
[ 61 ]
function getDeviceCapability($name) {
  if ($this->detector_loaded && isset(
    $this->detector_ua->$name))
  {
    return $this->detector_ua->$name;
  }
  elseif($this->wurfl_object->isCapabilityDefined)
  {
    $this->wurfl_object->getDeviceCapability($name);
  } else {
  return null;
  }
}
One of the things worth noting in the preceding code is the way we created device 
classes. It is not homogenous. If we use the WURFL capability xhtml_support_
level, we set some device class name directly in the function body. But when we 
use $this->detector_ua->family;, the device, family or class, comes from the 
Detector library configuration in app\libs\Detector\config\families.json (as 
in the following snippet):
{
  "tablet": {
    "isTablet": true
  },
  "mobile-advanced": {
    "isMobile": true,
    "features": [ "csstransforms" ]
  },
  "mobile-basic": {
    "isMobile": true
  },
  "desktop": {
    "isComputer": true
}
}

Sample RESS Page
[ 62 ]
Summary
We created four complete solutions to get a device's information from the libraries or 
via JavaScript object detection, store this information in a session variable, and read 
from a page or template. Based on those examples, you can choose the solution that 
best suits your needs—whether it is simple screen size detection, good support for 
low-end or older devices, or complete analysis of support for HTML5/CSS3 features.
In the following chapter we will take a closer look at the available solutions for 
handling adaptive images. We will also employ one of the modules created in this 
chapter to tackle the responsive images issue.

Responsive Images 
Client- and Server-Side 
Approaches
This chapter describes ways to deal with image scaling. With RESS, we can optimize 
the server-side part of our application in many ways depending on its target. But the 
issues discussed most often—related to SS optimization of RWD page components—
are probably responsive images.
It is easy to add the following lines of code to a CSS file:
img {
  max-width: 100%;
}
This generally works. Most modern phones are able to resize a 3000px image to fit 
in a 300px wide screen, but it is neither a responsible nor a wise approach. Just think 
how much money it will cost your users. Mobile service providers love the pay-per-
transfer plans. When 10 KB costs 2 cents, then 1Mb is worth $2, and that may be a 
waste for just a few unoptimized images. So, not optimizing images may bother your 
users in two ways:
•	
It makes them wait longer for your page to load
•	
It may cost them more money than it would for resized images
It's no wonder that this issue has gained so much attention, and is considered one of 
the most pertinent areas of concern in the development of RWD websites.

Responsive Images Client- and Server-Side Approaches
[ 64 ]
There are several concepts floating around:
•	
.htaccess redirects all .jpg files to adaptive images. It is the .php script that 
automatically resizes images according to the $resolutions configuration.
•	
<picture> tag with multiple src attributes—this is actually just a concept 
described in http://www.w3.org/community/respimg/ and http://
picture.responsiveimages.org/.
•	
Picturefill, available at https://github.com/scottjehl/picturefill/, is 
a JavaScript-based solution that mimics <picture> tag logic while using the 
currently available HTML5 tags.
•	
For Drupal implementations of this similar approach use the information 
available at http://drupal.org/project/cs_adaptive_image or view 
the formatter for Drupal available at http://drupal.org/project/cs_
adaptive_image.
•	
Finally, we can easily use our four RESS receipts to serve image versions 
depending on the screen width. We can either use the screen-width 
parameter to automatically adjust image widths, or implement another 
system that would allow us to use other particular versions depending 
on screen size.
Scaling responsive images is not linear
Managing responsive images is more complex than relying on screen width. Scaling 
images is not a linear process, for the following reasons:
•	
Different screen widths often have a different column count
•	
Images may be cropped differently when being resized to fit different 
screen widths
The following figure shows how the scaling of images in RWD layouts is not linear:
Scaling images in RWD layouts is not linear

Chapter 5
[ 65 ]
Sometimes, as seen on the previous figure, on smaller screen widths, an image may 
appear bigger or equal to its size on wider screens. Also sometimes it is necessary to 
provide the image with different proportions or crop the image differently to keep it 
interesting in smaller sizes. The following figures show how plain scaling for lower 
resolution images doesn't work:
Plain scaling image for lower resolution doesn't always work. 
Details become unrecognizable

Responsive Images Client- and Server-Side Approaches
[ 66 ]
The elements in the preceding figures, after scaling down, become hard to recognize. 
The same photo looks better in a smaller resolution after cropping it to 
a tighter composition.
Cropping image for lower resolution helps to focus attention on its subject
Plain CSS and Media queries – a solution 
with limited browser support
One of simplest solutions could be the Cascading Style Sheets, level 2 (CSS2) 
content property. With a code like the following:
 @media only screen and (min-width: 501px) {
  img[src="img_front4_small.jpg"] {
    content: url("img_front4_big.jpg");
  }

Chapter 5
[ 67 ]
It might be possible to replace img_front4_small.jpg with img_front4_big.jpg. 
The relevant images (defined by content: statement) are being downloaded by the 
browser only when the media query condition is met. The brilliant simplicity of this 
concept is dimmed by the following two facts:
•	
This is now only possible in Chrome, Safari, and Opera. In theory, 
content is a part of the CSS2 specification that is relatively old and widely 
implemented. This use case is a special one though and it is not well 
supported. The same applies to CSS :before and :after pseudo elements. 
Its wide support doesn't apply to the img tag.
•	
CSS is really handy when it comes to managing content versions. To make 
any real use of this method within a Content Management System (CMS), 
with user generated content, one would have to create a framework that 
allows us to manage image versions easily.
The <picture> tag proposition
In 2012, some people created the Responsive Images Community Group in W3C 
Community and Business Groups (http://www.w3.org/community/respimg/) to 
create a proposal that adds new elements and attributes to the HTM5 specification. 
The intention of the proposal was to enable different sources of images, based on the 
browser and its display characteristics. An example of the <picture> tag might look 
like the following code:
<picture alt="">
  <source media="(min-width: 45em)"
    srcset="large-1.jpg 1x, large-2.jpg 2x">
  <source media="(min-width: 18em)"
    srcset="med-1.jpg 1x, med-2.jpg 2x">
  <source srcset="small-1.jpg 1x, small-2.jpg 2x">
  <img src="small-1.jpg">
</picture>
As of now, it doesn't seem likely that this will become a part of HTML5 any 
time soon.

Responsive Images Client- and Server-Side Approaches
[ 68 ]
Picturefill that mimics the <picture> tag 
behavior with HTML5 and JS
Picturefill is a polyfill (http://en.wikipedia.org/wiki/Polyfill) that 
mimics a proposed <picture> element using <span> or <div>. You can find it at 
https://github.com/scottjehl/picturefill/. To test it, we can use our sample 
site structure. After downloading a package from GitHub, I copied picturefill.
js and external/matchmedia.js into our /assets/js/ directory. Then I linked it 
from RWD_sample_picturefill.html, which is a copy of RWD_sample.html created 
in the first chapter. To link JavaScript code, just add the following lines of code:
<script src="assets/js/matchmedia.js"></script>
<script src="assets/js/picturefill.js"></script>
The file matchmedia.js contains the matchMedia() polyfill available at 
https://github.com/paulirish/matchMedia.js/ for testing media queries in JS, 
and it is necessary to support the media attributes across browsers.
Now, I have to manually create images for each resolution and replace the following 
line of code: 
<img src="assets/img/photo_big.jpg">
With the following snippet:
<div data-picture data-alt="Fall in przesieka">
  <div data-src="assets/img/picturefill/320_photo_big.jpg"></div>
  <div data-src="assets/img/picturefill/800_photo_big.jpg"
    data-media="(min-width: 400px)"></div>
  <div data-src="assets/img/picturefill/photo_big.jpg"
    data-media="(min-width: 800px)"></div>
  <!-- Fallback content for non-JS browsers. 
    Same img src as the initial, unqualified 
      source element. -->
  <noscript>
    <img src="assets/img/picturefill/photo_big.jpg" 
      alt="Fall in przesieka">
  </noscript>
</div>

Chapter 5
[ 69 ]
In the preceding code, we saw that the <div> tag with the data-picture attribute is 
a container for all image versions. The paths to images for each resolution are inside 
the data-src attribute of its child div elements. The data-media attribute contains 
a media query for each version. A similar pattern is used by https://github.com/
weblinc/picture, and is based on the Drupal available at http://drupal.org/
project/picture.
Drupal picture module screenshot
The preceding screenshot is a picture image module that relies on module 
breakpoints, and maps image style to breakpoints defined within a specific group. 
Both of those modules will be part of the upcoming Drupal 8 core.
There are several projects in Drupal that are focused on client-side 
responsive images.
Drupal adaptive image module screenshot

Responsive Images Client- and Server-Side Approaches
[ 70 ]
The screenshot we just saw is from Drupal's client-side adaptive image 
module available at http://drupal.org/project/cs_adaptive_image. 
It allows for linking image styles with client width—obtained from the document.
documentElement.clientWidth JavaScript object.
Automated creation of 
responsive images
We will take a closer look at the script by Matt Wilcox. You can download the recent 
version from the following website:
http://adaptive-images.com
This script relies on redirecting all requests for files (jpeg/gif/png) to 
adaptive-images.php. To use it, we need to set up at least three things:
1.	 Resolutions in adaptive-images.php—set values in the array as follows:
$resolutions = array(1200, 800, 480, 320);
This is the same as your media queries. Actually, you can add more if 
necessary. As we have media query stops only at 320px and 800px, I added 
1200px and 480px, which allows for resizing full-width images to this 
resolution.
Another variable in adaptive-images.php worthy of  some thought is:
$cache_path = "ai-cache";
This sets the path for generating resized images and has to be specified 
relative to the document root.
2.	 As we have images inside the assets directory, we need to either comment it 
out in the file .htaccess, as shown in the following line of code:
RewriteCond %{REQUEST_URI} !assets
Or change the directory name. If we have any images we'd like to protect 
from being automatically resized, we can add respective directories here in 
same way.
3.	 The script relies on the JavaScript cookie method for reading client screen 
size, or uses an alternative method based on a media queries trick. In its 
documentation, there are two versions of JavaScript snippets that you need 
to put in the head section of your document. The basic version is as follows:
document.cookie='resolution=
  '+Math.max(screen.width,screen.height)+'; path=/';

Chapter 5
[ 71 ]
It is based on a slightly different approach than the JavaScript methods we 
used in the last chapter. It uses a screen object instead of window. In other 
words, it relies on the width of the monitor and not on the width of the 
window. In the case of a phone or tablet, the length is taken into account. The 
advantage of this approach is that the images served will be large enough for 
the widest browser window possible on a tested device. At the same time, 
one could say it is a disadvantage, as on a browsed page, in portrait mode, 
images will be wider than the browser window width. One could advocate 
the benefits of each of the  solutions. For testing, it is easier to use window.
innerWidth and see the changes after resizing the window, and reloading 
the page rather than having to change the monitor. We could use something 
like the following code:
document.cookie='resolution='+window.innerWidth+'; path=/';
There is another JavaScript version that takes into account window.
devicePixelRatio. This property is implemented on Safari, Android 
WebKit, the current version of Chrome Android, the current version of 
Firefox, Opera Mobile, BlackBerry WebKit, QQ, Palm WebKit, and Dolfin. 
It depicts the relation between Device Independent Pixels (DIP) and actual 
physical pixels of the device. For example, the high resolution Retina display 
of a modern iPhone is equal to the value of 2.
document.cookie='resolution='+Math.max(screen.width,screen.
  height)+("devicePixelRatio" in window ? 
    ","+devicePixelRatio : ",1")+'; path=/';
Finally, there is an interesting concept of using media queries to set a cookie 
without JavaScript. It uses the following CSS snippet:
 @media only screen and (max-device-width: 479px) {
  html { background-image:url(ai-cookie.php?maxwidth=479); } }
And we can use a similar snippet for all necessary resolutions. To set the 
cookie via ai-cookie.php. This simple yet interesting concept to inform 
PHP about the screen or window resolution works pretty well in the current 
versions of major browsers. Some experimenting that show more consistent 
results, across browsers and hardware setups, are brought using max-width 
(window width) instead of max-device-width (screen width).
Versions of this script exist for C# and ColdFusion, as well as plugins for 
Drupal and Wordpress.

Responsive Images Client- and Server-Side Approaches
[ 72 ]
Server Side – using one of our example 
RESS systems
We will build a responsive image solution of our own, based on one of the samples 
created in Chapter 4, Sample RESS Page. The solution has the following aims:
•	
It should be able to serve images for any defined screen range.
•	
It should work with any image file format including transparent PNG.
•	
It allows for automated resizing with the possibility of manual override. 
The automated creation of images for smaller screen widths is a great 
feature, and indispensable in some workflows—like galleries with many 
images. On the other hand, in RWD layouts, it is better to optimize 
images for each resolution manually sometimes. This allows us to change 
proportions and focus our attention on an important part of the image, 
when we have limited screen real estate. Sometimes there should be 
different images for small screens, especially when there is text—banners 
and ads may be a good example.
Each of those aims has its advantages and disadvantages. We are now concerned 
mostly with the screen width for a particular template. We want the most accurate 
and up-to-date screen width we can have. These requirements are best fulfilled 
with the first and third solution from the last chapter—thanks to our custom cookie, 
which provides us with an updated window width with each request.
We will use the first approach, where we will rely on WURFL to create a fallback 
for devices with no JavaScript or Cookies. However, if we don't want this, we can 
switch to using our third approach with a pure JavaScript RESS receipt, by changing 
a single line in our page script in ress_responsive_images.php. Instead of the 
following code:
$RESS_obj = loadApp('ress_cookie_wurfl');
We can switch to a pure JS solution by writing the following:
$RESS_obj = loadApp('ress_pure_js');
Pure JS solution can be found in the attached code file: 
ress_responsive_images_pureJS.php

Chapter 5
[ 73 ]
But having this information is not enough. We will not provide image versions for 
every possible resolution. This just doesn't make sense—we have to decide how 
many versions are necessary and define resolution ranges for those specific versions. 
I prefer to use object interfaces for this, so instead of using the plain global variable 
$resolutions, I make a class Responsive_Images and set it up. The following code 
can be used to do the same:
$Responsive_Images = loadApp('responsive_images'); //this returns 
instance of Responsive_Images class
$Responsive_Images->setResolutions(array(1200, 800, 480, 320));
What numbers should we put into this array? Our best guess is to start from where 
our media query stops, as it is, when the layout changes and we may need other 
image versions. But that is just a hint and it really depends on our layout.
Lowering the resolution of images does not always result in smaller images, as we 
discussed at the beginning of this chapter. For example, in our RWD page layout 
we reduced the number of columns at consecutive media stops. This causes images 
to enlarge as the screen width gets smaller. The simplest solution is to check for the 
nearest, biggest, or equivalent resolution:
$Responsive_Images->setScreenWidth($RESS_obj->getScreenWidth());
The preceding code informs the $Responsive_Images object what 
the current screen width is; we can then ask for the current resolution, that is, the 
lowest value in $Responsive_Images->resolutions, which is higher or equal to 
the screen width:
$Responsive_Images->getCurrentResolution();
The getCurrentResolution function, in the line of code we just saw after initial 
checks, creates a copy of $this->resolutions, and removes all values lower than 
the screen width. It continues to find the lowest values of what has remained or 
returns the string max:
function getCurrentResolution() {
  if (!is_null($this->current_resolution)) {
    return $this->current_resolution; // we already have it
  }

Responsive Images Client- and Server-Side Approaches
[ 74 ]
As we will use this function repeatedly, let's first check if we have this value already 
by using the following code:
  if (is_null($this->screen_width)) { // we need screen width
    throw new Exception('first screen width has to be 
      set with $this->setScreenWidth.');
  }
  if (is_null($this->resolutions)) { // and we need resolutions
    throw new Exception('first resolutions have to be 
      set with $this->setResolutions 
        or via config ["RESOLUTIONS"].');
  }
$resolutions = $this->resolutions; // copy resolutions array
Delete resolutions lower than the screen width by using the following code:
  foreach ($resolutions as $k => $val) {
    if ($val < $this->screen_width) {
      unset($resolutions[$k]); // remove smaller
    }
  }
If there is no higher resolution in $resolutions, it indicates that we should use 
the original files; hence, we return max—that is, the name of the directory with the 
original images:
  if (empty($resolutions)) {
    return 'max'; // we are in max resolution
  }
Or we return a relevant resolution:
  else {
    return min($resolutions);
  }
}
I think that using directories to store image versions is more flexible than adding 
some prefix or suffix to file names. The following is the directory layout of our 
image library:
resp_images_root/max
  image1.jpg
resp_images_root/1200
  image1.jpg
resp_images_root/300
  image1.jpg
…

Chapter 5
[ 75 ]
The resp_images_root directory needs to be set up either via $config in app\
responsive_images\conf.php, or by setting it with the $Responsive_Images-
>setBaseImageDir($dir_name) function variable. The path should be set as an 
absolute server file system path.
In the config file it looks like this:
$config['IMG_BASE_DIR'] = ASSETS_DIR . 'resp_img/';
You can see that we have used a new constant named ASSETS_DIR. It comes from 
global config (the one loaded via bootstrap):
define ("SITE_ROOT_FS", dirname($_SERVER['SCRIPT_FILENAME']) . '/');
define ("ASSETS_DIR", SITE_ROOT_FS . 'assets' . '/');
As assets are relative to the HTTP site root, I use:
 dirname ($_SERVER['SCRIPT_FILENAME'])
To get site root directory which resides the page script requested by browser. Using 
function takes precedence over what could be set in the configuration file.
$Responsive_Images->setBaseImageDir(SITE_ROOT_FS . 'someotherdir/');
This directory should be accessible via HTTP, as we use file paths to serve images 
directly (not with PHP script, as it is in the case of the script by Matt Wilcox).
The /max directory holds the base versions of all images. Other (numeric) directories 
are for its derivatives. An image version is automatically created only when the two 
conditions are met; that is, the screen width is smaller than the image size and the 
derivative version does not exist.
To handle image resizing I used  a third-party function available at https://
github.com/maxim/smart_resize_image. I don't describe it here in detail as 
delving into PHP image handling functions is not the subject of this book. I applied 
to this function.
 First, I changed the default argument values:
$proportional       = true,
// $output             = 'return', this is not necessary in my case
$delete_original    = false,
Second, I added $targetfile as a second argument to use it to output a modified 
image to file:
$output=$targetfile;  

Responsive Images Client- and Server-Side Approaches
[ 76 ]
We only use this function to create a derivative file. The switch statement is used to 
select the output mode that needs to be commented out. You can find the modified 
function in the app/libs/smart_resize_image.function.php file.
The getImage function outputs the path to the image in a proper resolution for 
the current screen. It takes the $filename parameter, which contains the file path 
relative to the assets\resp_img\max\ directory, that holds the original images. 
If the relevant image doesn't exist and the source image is wider than the current 
screen width, the resized version is created.
function getImage($filename) {
  if (is_null($this->base_image_dir)) {
    throw new Exception('first base_image_dir have to
       be set with $this->setBaseImageDir($dir_name) 
        or via config["IMG_BASE_DIR"].');
  }
$this->base_image_dir needs to be set up before we do anything. If it is not set up, 
we throw an error:
  
  if(!$this->dirExists($this->base_image_dir)) {
    return false; // we should never get here anyway
  }
If it doesn't exist, the $this->dirExists function attempts to create it (actually 
not really necessary here, but if someone made a mistake let's make some use of 
it and create directory as a hint); the following code will check if the source 
image file exists:
  $image_source = $this->base_image_dir.'max/'.$filename;
  $img_file_exists = file_exists($image_source);
  if (!$img_file_exists) {
    throw new Exception('source file does not exists:
       max/'.$filename);
  }
If the source file exists, we build the path for a valid version. First, read the 
current resolution:
$current_resolution = $this->getCurrentResolution();
Next, build a file system path for this file by using the following code:
$dir_resolution_base=
  $this->base_image_dir.$current_resolution."/";
$target_img_file = $dir_resolution_base.$filename;

Chapter 5
[ 77 ]
And if it exists, we remove the SITE_ROOT_FS part of the path to get a path relative 
to the site root. If our site would get a more complex directory or HTTP path 
structure, we should probably build a full absolute HTTP URI.
if (file_exists($target_img_file)) {
  return str_replace(SITE_ROOT_FS, "", $target_img_file);
  }
In this way, we can always use the image we want to for every resolution. But if the 
source file resolution is smaller than the current screen size, we should return to the 
source file path, as shown in the following code:
$image_source_size = getimagesize($image_source);
$target_img_width = $target_img_file[0];
if(is_numeric($current_resolution)
  && $target_img_width <= $current_resolution) { 
    return str_replace(SITE_ROOT_FS, "", $image_source);
}
If a file does not exist and the source image width is wider than the screen width, 
let's try to resize it and save it. First we analyze if the $filename parameter contains 
any directories, and if it does, we recursively create a whole directory structure in the 
relevant resolution directory:
$img_pathinfo = pathinfo($filename);
if(!empty($img_pathinfo['dirname']) && $img_file_exists)
  // target directory
  {
  if(!$this->iteratorDirExists($img_pathinfo['dirname'])) {
    return false; // we should never get
    to this point anyway
  }
}
Now we include the file with the code to resize the images:
require_once(LIBRARIES_DIR."smart_resize_image.function.php");
if(is_numeric($current_resolution)) {
  $res=smart_resize_image(
    $image_source,
      $target_img_file,
        $current_resolution); // target image width
  return str_replace(
    SITE_ROOT_FS,
       "",
         $target_img_file);
}

Responsive Images Client- and Server-Side Approaches
[ 78 ]
Passing three parameters to the smart_resize_image function is enough to achieve 
what we need.
To test this solution, we can use the RWD code from the first chapter. We should first 
move the images from /asstes/img/ to assets/resp_img/max/. Then we use the 
HTML code from RWD_sample.html in ress_responsive_images.php. In all the 
image tags, we have to replace the actual path to the image with our function call. In 
place of:
<img src="assets/img/photo_big.jpg">
We can use:
<img src=
  "<?php echo $Responsive_Images->getImage("photo_big.jpg"); ?>">
Our sample with all images scaled proportionally

Chapter 5
[ 79 ]
The ability to manually override images for each resolution comes handy in 
situations like the one presented in the screenshot we just saw. All the images are 
nicely resized—in this case for 480px screen width—but the top image doesn't look 
proportionate. It would look better if it was cropped differently and placed a bit 
higher. Also, I used a certain trick that enhances the visual quality of a compressed 
.jpg while keeping its size relatively low. This can be achieved with maximum 
compression but also by oversizing the image. That's why I used an image that is 
3200px wide as my base version, while actually targeting a 2000px wide monitor.
Our sample with top image cut in a way that suits overall composition better
The smaller images on the other hand, in a 320px to 480px screen width 
range, are a maximum 210px wide. After a manual resize from 480px to 210px, 
the files dramatically lose weight—from 20 KB/22 KB each to 5 KB/6 KB 
each approximately.

Responsive Images Client- and Server-Side Approaches
[ 80 ]
Summary
Among all the ways of creating and managing responsive images, each has its 
pros and cons. Aside from the purely technical aspects, such as reliability or 
compatibility, an important factor is, ease of use and flexibility. We usually gain 
one of those at the expense of the other. The concept from adaptive-images.com 
with .htaccess redirecting images to script and automatic generation of other 
resolutions is easy to set up and requires no effort to maintain. The disadvantage 
here is the inability to adjust the images manually for small resolutions and fine 
tune their size. The <picture> tag polyfill provides great flexibility but requires 
a significant amount of work to maintain. Our RESS solution is an attempt to 
create a balanced approach. It creates automatically resized versions but allows 
for manual override.
In the next chapter, we will discuss optimizing the performance of responsive pages. 
You will learn about optimization purpose, methods, myths, and limits.

Performance
Before talking about performance, we need to ask ourselves what this word means 
to us. Is this a real page-loading speed, the weight of the page and assets to be 
loaded, the page rendering speed, or maybe the largest number of devices to be 
compliant with?
Optimizing website towards screen size 
or bandwidth?
Adaptive Images optimization, which we did in the last chapter, was based on 
one parameter—screen width. With mobiles and modern devices, this might not 
be optimal. Just imagine someone using the new iPad (or another tablet with a large 
screen) with a weak 3G connection, or worse, GPRS with a pay-per-bandwidth plan.
That is why web developers would love to see bandwidth media queries. Knowing 
when the connection is made via low bandwidth would allow sending of extremely 
compressed images, while when the connection comes via a fast connection, 
we could serve the best quality we have. The problem is that bandwidth media 
queries "doesn't seem to be something that can be accurately implemented in the 
near future," as stated by Yoav Weiss in the article titled Bandwidth Media Queries? 
We Don't Need 'Em! in the Smashing magazine (available at http://mobile.
smashingmagazine.com/2013/01/09/bandwidth-media-queries-we-dont-
need-em/) after detailed analysis of how the TCP connections work. When he says 
"not in the near future," it looks like a cautious way of saying "never," unless maybe 
those biological computers in the far future make our understanding of networking 
obsolete.
For now the only solution to this dilemma (besides optimizing everything as 
much as we can) seems to be giving the user a choice between low and high 
bandwidth versions.

Performance
[ 82 ]
Optimizing images
Optimizing the use of images on a web page has the following five flavors:
•	
Optimizing image dimensions
•	
Optimizing image compression
•	
Optimizing the file format
•	
Avoiding the use of images
•	
Reducing the number of images
Optimizing image dimensions
Bitmaps have always defined dimensions in pixels. It is best when those dimensions 
match the exact area occupied by the image on the screen—without resizing with 
HTML or CSS. Scaling down images is possible only in the fixed layout of an HTML 
page. In responsive pages, fluid image scaling with CSS is a routine. We can only 
approximately adjust the actual image dimensions to its displayed size. We talked 
in detail about existing solutions in Chapter 5, Responsive Images Client- and Server-
Side Approaches. The module responsive_images we created in that chapter allows 
adding image versions manually adjusted to each resolution. It has the following two 
advantages over purely automated generation (like the one used in the script from 
www.adaptive-images.com/):
•	
Usually most of the images used on the web page do not consume 
100 percent of the window width. Hence using the window width as 
a determinant for every image results in leaving many of those 
oversized. Manual image-size adjustment for each defined resolution 
allows setting more precise image dimensions. This in turn gives a 
huge gain in bandwidth savings and page-load speeds.
•	
The responsive_images module allows manual fine-tuning of 
image compression.

Chapter 6
[ 83 ]
Optimizing image compression
With Adobe Photoshop's Save for Web function you can interactively adjust 
compression parameters. "Interactively" is an important word here as proper 
optimization of compression parameters is an art of compromising between the 
file size and the perceived image quality. An interactive preview of the compressed 
picture allows swift selection of the best compression parameters.
When saving in JPG format via Photoshop's Save for Web 
function, make sure to select either the progressive or the 
optimized option.
Optimizing the file format
Selecting the right file format is probably a well-known subject for most readers of 
this book. Nonetheless, there are some relatively new extensions worth mentioning 
too. Let's summarize the key points as follows:
•	
Images with a limited color palette (when the number of colors can be 
reduced below 256) are usually best saved as 8-bit PNGs (the additional gain 
is the lossless compression).
•	
Photographic images should be saved as JPGs.
•	
Remove metadata when saving.
•	
Don't embed a color profile.
•	
Use 24-or 32-bit PNG images only when you really need an alpha 
transparency or when the file size is smaller than the same picture saved 
as an 8-bit PNG/JPG (it happens in rare cases—especially with small files).
•	
Use fonts for icons—web fonts are well supported now in browsers. 
We can use fonts not only as letters but also as easy, flexible, and well-
supported vector images. They can be easily scaled without losing quality 
and we can style them with CSS. An interesting source of free icons and a 
service that allows you to generate your own font is available at http://
icomoon.io/app/.
Scalable Vector Graphics (SVG) is supposed to replace Flash in handling vector 
graphics for the web, and in vector-based animation. Currently though, there are no 
good tools for that and browser support is not consistent enough. 

Performance
[ 84 ]
Avoiding the use of images
The CSS3 properties, such as border-radius, shadows, gradients, empower you 
to create many visual effects that were possible so far only with the use of bitmap 
images. If you don't know it yet, making rounded corners is possible now with a 
line of code. Tables filled with images died with dinosaurs a long time ago. 
If I recently didn't encounter some "modern" dot NET components that position 
their stuff by putting tables inside tables and so on, I wouldn't even believe it's 
worth mentioning.
Reducing the number of images
With the CSS background-image position trick, we can dramatically reduce 
the number of HTTP requests (which is one of the basic factors determining the 
page-load speed). The basic use cases for this technique are hover images and 
icons. The idea is that you use one image for multiple icons or states, and change 
the background-position CSS property to show different fragments of this image 
to the user. Something like:
<div class = "icon clock"></div>
<div class = "icon mouse"></div>
withcss:
.icon {
  width : 20px;
  height : 20px;
  background-image : url("icons.png");
}
.icon.clock {
  background-position : 20px 0px;
}
.icon.mouse {
  background-position : 40px 0px;
}
Media queries optimization
It is easy to get fooled by myths about media queries optimization. For example, it 
is a myth that splitting CSS into separate files included via @import statements as 
follows, reduces bandwidth by loading only necessary CSS code:
@import url("479style.ss")screen and (max-device-width: 479px); 
  @import url("767style.ss")screen and 
  (min-device-width: 480px) and (max-device-width: 767px);

Chapter 6
[ 85 ]
The truth is quite opposite. Such splitting of stylesheets into several files makes CSS 
easier to maintain but the browser downloads all the files. More HTTP requests 
certainly add overheads that slow down page loading.
Another myth I encountered is that all background images defined in a stylesheet 
are downloaded, even if they are inside media queries that do not apply to the 
current situation. That is not true. In the case of the following code, none of the major 
browsers download the test1.jpg image:
@media screen and (max-width: 800px)
{
  .photo_block4{background-image:url(test1.jpg);}
}
On the other hand, in the situation depicted by the following code the test1.jpg 
image is downloaded:
<div class="small">
  <imgsrc="test1.jpg">
</div>
The CSS applied here sets the display property to none on the element that is a 
parent of the image element:
@media screen and (max-width: 800px) {
  .small {display:none;}
}
The image is downloaded—probably due to the "so called" speculative parsing. 
When the browser encounters an image tag, it may immediately send a request 
for it—before it can know that it will not be necessary.
Testing
The fastest and easiest method is using the network panel in Firebug. Unfortunately, 
this is only good for testing on desktops. There are online services for testing 
the page-load speed available at http://www.webpagetest.org/. However, 
its methodology is undocumented and it is hard to rely on it when testing RESS 
applications. For example, in tests of pages built around the <picture> polyfill script 
(with iPhone 4 set as the target) the biggest images were always downloaded while 
with the RESS system in place during the first request, the smallest images were 
downloaded and during the second request the biggest images were downloaded.
 It seems that the WURFL screen width used during the first request returned 320 px, 
and the JavaScript later detected a large screen.

Performance
[ 86 ]
There is a widely advertised free mobile-testing tool available at http://mobitest.
akamai.com. Unfortunately, we encounter similar problems in testing RESS pages as 
in the previously mentioned service. It tests only the first page load, which makes it 
quite useless to test every page that reads the screen width with cookies.
The only method you can really rely on is testing your page on a 
device that is an assumed target or at least resembles it. To get some 
more insight, you may try the software available at http://html.
adobe.com/edge/inspect/ that allows simultaneous testing on 
several devices.
Nonetheless, using the network panel in Firebug provides valuable insights. The 
following figure shows a comparison of asset sizes in one of our RESS samples:
The figure shows a comparison of image and framework sizes based on the 
RESS example from the previous chapter. The CSS and JavaScript frameworks 
are Twitter Bootstrap and jQuery 1.10.2 minified. The file used in this example 
(ress_responsive_images_pureJS.php, attached to this chapter) should be placed 
in the same directory as ress_responsive_images.php from the previous chapter.

Chapter 6
[ 87 ]
It shows that optimal image compression is not the only aspect of optimizing 
page-loading time. Our example is quite modest in image use. Nonetheless, the 
preceding chart is a bit surprising. Below 1200 px screen width, the CSS and 
JavaScript are bigger than the images, and most of this code is already minified 
(this is not an average—usually CSS + JavaScript is 30 percent of the image's size).
"Every day, more than 99 human years are wasted because of uncompressed 
content," writes Arvind Jain and Jason Glasgow in the article Use compression to make 
the web faster (available at https://developers.google.com/speed/articles/
use-compression). Compressing HTML, JavaScript, and CSS can save a lot of 
bandwidth. The compression is not a developer's decision though. There are several 
factors that have to be fulfilled to make compression work. You can read more on 
this subject in the article at https://developers.google.com/speed/articles/
use-compression. We can use a host with compression enabled (or enable it 
ourselves, for example, by installing Google's PageSpeed Module for Nginx or 
Apache from https://developers.google.com/speed/pagespeed/module).
While struggling to compress all resources to reduce the total transfer size, it'd be 
good to know what the actual value we should achieve is. There is no good KB 
number anymore. In the older times of modem connections, 50 KB was considered 
such a good value for a complete page with all assets. But it was simple due to 
similar connection parameters used by most of the Internet users. The difference 
between GPRS, 3G, HSDPA, DSL, T3, and 4GLTE connections used nowadays 
is huge. Generally speaking, more and more users are using some kind of a fast 
connection. It is reflected in the HTTP archive stats, showing a quick increase in the 
total transfer size of an average webpage (available at http://httparchive.org/
trends.php) that reached 1585 KB on September 15, 2013.
However much  transfer size limits seem to be virtually lifted for many Internet 
users, they do exist. Also increased complexity of JavaScript, new CSS capabilities, 
and growing image dimensions slow down rendering time. We are able to know 
neither the user's bandwidth, nor other constraints like his mobile data plan. These 
are good reasons to allow the user to select a lighter version of a website that he will 
receive by default.

Performance
[ 88 ]
Summary
We discussed ways to optimize the total web-page transfer size and the 
reasons to do so. It is a broad subject and a good starting point to learn more is 
to start using Google's PageSpeed Insights Browser Extensions (available at 
https://developers.google.com/speed/pagespeed/insights_extensions). 
Note that the versions for Firefox and Chrome work a bit differently, so it may be 
worth looking at both. Besides the ability to quickly review possible page-speed 
delays, it provides tips on how to speed up your page. One should not take those 
tips as a religion. For example, a standard tip we will see on each responsive page is 
"Specify image dimensions"—something that we definitely shouldn't do in this case.
In the next chapter you will learn how to create and use  jQuery plugins, capable of 
turning elements of your page into interactive responsive components.

Extending with jQuery
With every month, more and more layout responsive patterns and responsive page 
components show up. The examples presented here show us how responsive plugins 
may help us solve problems commonly encountered when converting a website to a 
responsive design. Most of the responsive components rely on smart CSS but there 
are some that use jQuery plugins to improve usability.
Twitter Bootstrap components 
and plugins
In Twitter Bootstrap we already have several jQuery-based responsive components 
that we can use to improve navigation or enhance our page. A list of those may be 
found at http://getbootstrap.com/components/ accompanied by a list of jQuery 
plugins that support them (available at http://twitter.github.io/bootstrap/
javascript.html).
We already used responsive navigation in the first version of our page.
Let's implement a carousel. The new version of the script to customize Twitter 
Bootstrap allows us to use only the components we need. So far we didn't include 
carousel, so we have to download another Bootstrap version available at http://
getbootstrap.com/customize/. On this page select Carousel below the JavaScript 
components label, Carousel functionality below the jQuery plugins heading, and 
the Linked to components label. Besides that, select the same checkboxes as we did 
in Chapter 2, Sample RWD Setup for Client-Side Development. Then go to the bottom 
of the page and click on Compile and Download to get our customized build. The 
downloaded archive contains two directories (CSS and JavaScript). Unpack it into 
the assets/ directory (overwrite existing files if necessary). To see the working 
example, take a look at RWD_sample_carousell_ok.html. The downloaded CSS file 
should be linked inside <head> as follows:
<link rel="stylesheet" href="assets/css/bootstrap.css">

Extending with jQuery
[ 90 ]
The minified Bootstrap JavaScript file we link at the end of file (to speed up page 
loading), just before closing the </body> tag looks like the following code:
<script src="assets/js/bootstrap.min.js"></script>
After the preceding line of code, we initialize the carousel plugin as in the 
following code:
<script type="text/javascript">
  $(document).ready(function(){
    $('#myCarousel').carousel()
  });
</script>
Before loading the bootstrap.min.js file, we need to load the jQuery too. 
The following line should be placed above the line loading bootstrap.min.js:
<script src="assets/js/jquery-1.10.2.min.js"></script>
Having the plugin and styles linked, we can start writing the HTML code 
of the carousel. It is described in detail on http://getbootstrap.com/
javascript/#carousel.
We start from a <div> that will contain all carousel elements such as navigation, slides, 
and slide indicators. A good idea may be to use an id attribute to wrap the div class 
(as seen in the following code), so that we can later easily target the class from the 
script and use it in the data-target or href attributes of the navigation controls:
<div class="main_photo carousel slide" id="myCarousel">
The following ordered list creates circles indicating the current slide and allowing 
to navigate to any of them—note the data-target and data-slide-to 
HTML5 attributes:
  <ol class="carousel-indicators">
    <li data-target="#myCarousel" 
      data-slide-to="0" class="active"></li>
    <li data-target="#myCarousel" data-slide-to="1"></li>
    <li data-target="#myCarousel" data-slide-to="2"></li>
  </ol>

Chapter 7
[ 91 ]
The div variable of the class carousel-inner contains actual content for the slides, 
as seen in the following code:
  <div class="carousel-inner">
    <div class="active item">
      <img src="assets/img/photo_big.jpg"></div>
    <div class="item">
      <img src="assets/img/photo_big_winter.jpg"></div>
    <div class="item">
      <img src="assets/img/photo_big_forest2.jpg"></div>
  </div>
Finally, the code for the left and right navigation controls are as follows:
  <a class="carousel-control left"
    href="#myCarousel" data-slide="prev">&lsaquo;</a>
  <a class="carousel-control right"
    href="#myCarousel" data-slide="next">&rsaquo;</a>
</div>
To use this carousel with our RESS system from Chapter 5, Responsive Images Client- 
and Server-Side Approaches, we should only replace image URIs with a call to the 
$Responsive_Images->getImage method as follows:
<div class="carousel-inner">
  <div class="active item">
    <img src="<?php echo $Responsive_Images->
      getImage("photo_big.jpg"); ?>">
  </div>
  <div class="item">
    <img src="<?php echo $Responsive_Images->
      getImage("photo_big_winter.jpg"); ?>">
  </div>
  <div class="item">
    <img src="<?php echo $Responsive_Images->
      getImage("photo_big_forest2.jpg"); ?>">
  </div>
</div>

Extending with jQuery
[ 92 ]
Responsive tables
Tables are one of the common challenges faced in responsive design. Dozens of 
columns will never fit in a 320 px screen width. Responsive patterns for table 
layout include:
•	
Converting a table into a pie chart (works only with numeric values). 
The test page for a plugin that converts the table to a chart can be found at 
http://jsbin.com/emexa4.
•	
Hiding several columns as the screen width is reduced. A jQuery plugin 
doing that can be found at https://github.com/thepeg/MediaTable, 
with an example at http://consulenza-web.com/jquery/MediaTable/. 
The great feature of this plugin is that it allows the user to control which 
columns should be displayed by selecting them from a drop-down menu.
Converting a table to an accordion 
element with jQuery
I selected this concept to show a way of creating responsive elements with CSS 
and some jQuery code. The plugin we are about to create in this chapter is inspired 
by the CSS-tricks example of reformatting a table with CSS into a vertical layout 
(as demonstrated at http://css-tricks.com/examples/ResponsiveTables/
responsive.php). Our plugin will go a little further and will convert the table into 
an accordion type element. We start by stacking table cells vertically by converting 
rows, cells, and the table body to block elements inside the media query as follows:
@media screen and (max-width: 820px) {
  table.responsive td, table.responsive tr, table.responsive, 
    table.responsive tbody {
  display: block;
  }
We don't need the column headers (with the field names) in the accordion, so let's 
hide those with the following code statement:
table.responsive th{
  display: none;
}

Chapter 7
[ 93 ]
Instead of the <th> headers at the top of the table, we will add a field name to each 
row (this may sound cryptic but it should become clear when you open the file 
table_responsive_sample.html in a web browser and scale the browser window 
below 800 px width). To add a field name to each row (created from the <td> cell, 
replaced by injecting inline field names), we use the following code:
table.responsive td:nth-of-type(n+3):before {
  content: attr(data-col);
  margin-right: 8px;
  width: 30%;
  text-align: right;
  display: inline-block;
  font-weight: normal;
}
Injected field names are based on the data-col attribute value, which requires 
putting them in HTML as follows:
  <tr>
    <td data-col="first name">Niki</td>
    <td data-col="second name">Doe</td>
    <td data-col="age">34</td>
    <td data-col="city">Paris</td>
    <td data-col="weight">70kg</td>
    <td data-col="hair">blond</td>
  </tr>
This could be done directly in CSS by using the following code:
td:nth-of-type(1): before {
  content: "first column header";
}
The solution with the data-col attribute seems to be more flexible and easier to use, 
but that might depend on the use case.

Extending with jQuery
[ 94 ]
We used td:nth-of-type(n+3) as we started from the third cell in a row. The first 
two cells contain the first and the second name. I'd like to put them in one line to be 
used as a header as in the following code:
table.responsive td:nth-of-type(1), table    .responsive td:nth-of-
type(2) {
  float: left;
  border: none;
  font-weight: bold;
  font-size: 20px;
  height: 28px;
}
Responsive table: it changes to an accordion type element below 820 px window width
To ensure proper layout we need to use clearing elements after each <tr> tag and 
before every third <td> tag as follows:
table.responsive tr:after {
  content: "";
  width: 100%;
  clear: both;
  display: table;
}
table.responsive td:nth-of-type(3){
  clear: left;
}

Chapter 7
[ 95 ]
Use of the nth-of-type CSS pseudo-element is a great and simple way to 
differentiate between odd and even row styling, as seen in the following code:
table.responsive tr:nth-of-type(2n+1) {
  background-color: #e4e2c0;
  border-top: 1px solid #f6f5e3;
  width: 100%;
}
table.responsive tr:nth-of-type(2n) {
  background-color: #ffecb3;
  border-bottom:1px solid #d9c496;
  border-top:1px solid #f6f5e3;
}
Add background and borders to complete the styling of the third cell and the 
following table cells that became rows, as seen in the following code:
table.responsive td:nth-of-type(n+3) {
  background-color: #f8f2e5;
  border-top: 1px solid #fffbf2;
  border-right: 20px solid RGBA(255,255,255,0.3);
  border-left: 10px solid RGBA(255,255,255,0.3);
  font-weight: bold;
}
Now, as this is going to be an interactive element of the accordion type, we need 
some JavaScript. Ideally, we should be able to use it in a standard way as follows:
$(document).ready(function(){
  $(".responsive").table2accordion();
})
To achieve the mentioned points, let's make a jQuery plugin using a standard pattern 
as follows:
(function ( $ ) {
  var methods= {
    showRowCells:function() {
      return this.each(function() {
        //method code
      })
    },

Extending with jQuery
[ 96 ]
  };
  $.fn.table2accordion = function(method) {
    if ( methods[method]) {
      return methods[method].apply(this, 
        Array.prototype.slice.call(arguments, 1));
    } else if (typeof method === 'object' || ! method) {
      return methods.init.apply(this, arguments);
    } else {
      $.error('Method ' + method+ ' does not exist on jQuery.
table2accordion ');
    }
})(jQuery);
More on jQuery plugin design patterns can be found at 
http://docs.jquery.com/Plugins/Authoring.
The init method (commented on in the following page) tells us the most on how 
our plugin works. In the following code, we start by iterating each element in the 
current selector and returning the processed element to preserve chainability. The 
line var $this, data [...] allows easy access to plugin options.
var methods= {
  init:function(){
  console.info("table2accordion.init");
  return this.each(function(){
    var $this = $(this), data = 
      $this.data('table2accordion'); //standard construct
Continuing the init method call in the following code, let's hide all the cells starting 
from the third cell in each row by calling the hideRowCells method. The line of 
following code may seem a strange way to call a method inside a class. Nonetheless, 
what is important is that executing the plugin method on the processed element 
in this way allows us to receive proper object reference of the currently processed 
DOM element in $(this)—instead of reference to some ancestor DOM element in 
the current $this. In other words, we use the plugin chainability within the plugin 
method, and at the same time it allows us to maintain chainability (as other ways of 
doing this would limit the plugin's flexibility).
      $this.find("tr").table2accordion("hideRowCells");
In the following code we assign the click handler to the row:
      $this.find("tr").click(function(){

Chapter 7
[ 97 ]
The .data("opened") variable is used as a flag indicating if a particular <tr> tag 
is in the "opened" or "closed" state, as shown in the following code, and 
depending on it relevant methods are called and the value of $(this).
data("opened") is updated:
        if(!$(this).data("opened")) {
          $(this).data("opened",1);
          $(this).table2accordion("showRowCells");
        } else {
          $(this).data("opened",0);
          $(this).table2accordion("hideRowCells");
        }
      })
Actually, we could live without resizing the handler in most scenarios—usually 
the browser window is not being changed. But as we used the "max-width: 820 px" 
media query rather than "max-device-width", let's be consistent and at the same time 
provide a nice feature that demonstrates the layout change when the window resizes 
as follows:
      $(window).resize(function(){
In the following code please note the method we use to check if a particular media 
query was applied. Instead of looking for the screen size, we check indirectly by 
looking at the CSS property. In our case $this.css("display") relates to table.
responsive ,table.responsive tbody{display:block;}:
      if ($this.css("display") == "block") {
        $this.table2accordion("turn2accordion");
      } else {
        $this.table2accordion("turn2table");
      }
    });
  })
  },
The init method ends here.
The methods turn2table and turn2accordion essentially do nothing more than 
show or hide "data" table cells, as in the following code:
turn2accordion:function() {
  return this.each(function(){
    var $this = $(this), data = 
      $this.data('table2accordion');
    if($this.prop("tagName") == "TR")
    {

Extending with jQuery
[ 98 ]
Checking for data("opened") (as in the following code) allows some persistence. 
Scaling the window up and down leaves rows in the same "opened" or "closed" state 
they were in before.
      if($this.data("opened")) {
      $this.table2accordion("showRowCells");
      } else {
      $this.table2accordion("hideRowCells");}
    } else {
      $this.find("tr").table2accordion("turn2accordion");
    }
  })
},
turn2table:function() {
  return this.each(function() {
    var $this = $(this), 
      data = $this.data('table2accordion');
    if($this.prop("tagName") == "TR") {
      $this.find("td:nth-of-type(n+3)").css({
        "display":"table-cell"
      });
    } else {
      $this.find("tr").table2accordion("turn2table");
    }
  })
}
The following methods, hideRowCells and showRowCells, do the actual work of 
hiding and showing "data cells" in a row:
hideRowCells:function() {
  return this.each(function(){
    var $this = $(this), 
    data = $this.data('table2accordion');
    if(!($this.css("display") == "block" )) {
      return;
    }
Look for all the table cells and hide them using the following code:
  $this.find("td:nth-of-type(n+3)").css({"display":"none"});

Chapter 7
[ 99 ]
Accordion allows us to expand/collapse each row (it's not actually a row anymore 
as cells are stacked vertically; but because it is the HTML TR element, I still call it a 
row). To make our accordion more user friendly, we can show a plus/minus sign 
next to each header. Keeping the header look in sync with the row state (expanded/
collapsed) is easily achieved here by swapping classes. If the TR element is processed 
at the moment, we remove the expanded class and add the collapsed class instead, 
as in the following code:
  if($this.prop("tagName")=="TR") {
    $this.removeClass("expanded").addClass("collapsed");
  }
Otherwise (as seen inside the else block in the following code), to perform this 
operation we have to first find the TR elements (rows) that are descendants of 
the current element.
  else {
    $this.find("tr").removeClass("expanded").
      addClass("collapsed");
  }
  })
},
The algorithm for showing rows is as follows:
showRowCells:function() {
return this.each(function() {
  var $this = $(this), data = $this.data('table2accordion');
  if (!($this.css("display") == "block" )) {
    return;
  }
But we show cells instead of hiding them, using the following code:
  $this.find("td:nth-of-type(n+3)").css({
    "display":"block"
  });
  if($this.prop("tagName")=="TR") {
    $this.removeClass("collapsed").addClass("expanded");
  } else {
    $this.find("tr").removeClass("
      collapsed").addClass("expanded");
  }
})
},

Extending with jQuery
[ 100 ]
Adding and removing the expanded and collapsed CSS classes helps us in styling of 
the element, as seen in the following code:
  table.responsive tr {
    background-image: url("../img/plus_minus_transp42.png");
    background-position: right 0px;
    background-repeat: no-repeat;
  }
  table.responsive tr.collapsed:hover {
    background-position: right -42px;
  }
  table.responsive tr.expanded {
    background-position: right -84px;
  }
  table.responsive tr.expanded:hover {
    background-position: right -126px;
  }
As shown in the following figure, the image plus_minus_transp42.png (used as 
the background-image variable for table.responsive tr in the preceding code 
listing) contains all the versions of the plus and minus sign. Changing background-
position is all we need to style the state of the accordion rows.
Styling with a single image

Chapter 7
[ 101 ]
Masonry
Masonry is another jQuery plugin for a responsive, grid-based layout. It takes its 
name from positioning elements on a page such as "mason fitting stones in a wall". 
It represents quite a different approach to what a responsive layout is supposed to 
look and act like. Instead of scaling fluid columns, it repositions elements to best fit 
the page width.
It works best with designs based on a square module, but can be applied to other 
multicolumn setups too. Usually Masonry is used for designs where page building 
blocks repositioned by the plugin have a fixed size across all screen resolutions. 
Masonry can be found at http://masonry.desandro.com/. To use it, we only need 
to link the script jquery.masonry.min.js and initialize the plugin as follows:
<script src="jquery.masonry.min.js"></script>
$(function(){
$('#container').masonry({
  itemSelector: '.box',
  columnWidth: 100,
  isAnimated: !Modernizr.csstransitions
 });
});
In the preceding sample Masonry, we will use elements having the .box class that 
are descendants of the elements having a #container ID assigned. Additionally, the 
modernizr-transitions.js script is employed to animate boxes on the browser 
window size changes.
The following figure shows Masonry in action. The lower half is a screenshot of the 
page layout resized to 50% width as compared to the upper half of the image.

Extending with jQuery
[ 102 ]
Summary
In this chapter we looked at the ways jQuery may help RWD layouts. We created 
a jQuery plugin from scratch, and employed another one from the rich library of 
Twitter Boilerplate components and plugins.
In the following chapter, we will create an AJAX application consuming RESTful 
API created with a PHP Slim framework. Then we will integrate it with our RESS 
responsive images module.

Employing a REST API 
for RWD
AJAX (Asynchronous JavaScript and XML) was invented to satisfy the need 
for a more responsive and functional web application. AJAX, by utilizing 
XMLHttpRequest, allows asynchronous exchange of data with a server to update 
parts of a web page without reloading the whole page.
XMLHttpRequest (XHR) is a JavaScript API that allows you to 
make requests to a web server and load response data back to the 
script. Often, returned data is encoded in JSON format.
To build an AJAX application, we need some kind of API on the server side 
to respond to XHR. For some time now APIs inspired by the REST pattern are 
considered to be a good practice.
REST stands for "Representational State Transfer" and means an architectural style 
for distributed hypermedia systems. This concept was described in Roy Thomas 
Fielding's dissertation (available at http://www.ics.uci.edu/~fielding/pubs/
dissertation/rest_arch_style.htm) written in the year 2000. During the last 
13 years, "RESTful" has become a buzzword attached to nearly every modern web 
API. Fielding "frustrated by the number of people calling any HTTP-based interface 
a REST API" pointed out several rules that he deems required to call an API a REST 
API (available at http://roy.gbiv.com/untangled/2008/rest-apis-must-be-
hypertext-driven) and insisted that everyone either "adhere to them or choose 
some other buzzword for your API."

Employing REST API for RWD
[ 104 ]
REST is an architectural style described at a high level of abstraction. 
A RESTful web API is an API that uses HTTP methods GET, POST, PUT, 
and DELETE to perform operations on resources defined by a URL. For 
example, to read user information we can send the GET request to a URL 
like http://test.com/user/2, to delete the user we send the DELETE 
request to the same URL, and to replace existing user information with a 
new one we use the PUT method. There is more than this needed to make 
a web API a RESTful one. If you wish to learn more, take a look at the 
mentioned post by Fielding on REST and Hypertext.
It is relatively easy to add an RESS capability to AJAX applications as they already 
rely on client-server communication.
We will build a sample AJAX RESS application to manage landscape photos and 
allow different versions for different resolutions. Each photo has just two fields, 
country and location. We will give the users the ability to upload photos for each 
defined media query stop; if we don't upload an image, the application will generate 
a relevant file. The logic of managing photos is the same as in our RESS application 
from Chapter 5, Responsive Images Client- and Server-Side Approaches (folder app/
responsive_images) and we will employ that module. Data will be stored in a 
MySQL database.
A simple single table like the following will do for our purpose:
  'id' int(6) NOT NULL AUTO_INCREMENT,
  'file_name' varchar(255) NOT NULL,
  'location' text NOT NULL,
  'country' varchar(255) NOT NULL,
  PRIMARY KEY ('id')
MySQL (http://www.mysql.com/) is part of the WAMP 
server mentioned in Chapter 3, Server-Side Setup – Device Detection 
Libraries. To create a database, start the WAMP server and go to 
http://127.0.0.1/. On the WAMP start page you should find a link 
to phpmyadmin under Tools. After clicking on it you are directed to a 
login page. You should use your MySQL password; if you didn't set it 
yet you should be able to login with the username root and an empty 
password. Upon login, create a database named landscape and load 
SQL from the file app\rest_slim\photos.sql (via the import tab in 
phpmyadmin—after selecting a database on the left). You also need to 
update the MySQL credentials in app\rest_slim\conf.php.

Chapter 8
[ 105 ]
REST API
Our "RESTful" interface will consist of a few paths as follows:
•	
GET /photos: To load a list of all photos
•	
GET /photos/:id: To load photos and information
•	
GET /photos/country/:name: To load a list of all photos that belong 
to a country
•	
GET /photos/countries/: To load a list of all the countries
•	
POST /photos: To add a new photo
•	
DELETE /photos/:id: To delete a photo
Slim PHP framework and integrating the 
RESS module
We can use one of the many "RESTful" frameworks out there to speed up building 
our application. I decided to use Slim, available at http://www.slimframework.
com/, for its simplicity. To integrate it with our framework, we put the Slim library 
into the app\libs\ directory and load it from the rest_slim module. This module, 
consisting of the class Rest_Slim (in the app/rest_slim directory), will also load 
the Responsive_Images module and create database connections. The following 
constructor is responsible for creating the required environment:
private function __construct(){
First, let's read the configuration (as before) as follows:
  include dirname(__FILE__)."/conf.php";
  $this->config=&$config;
Next, we can load the Slim framework as follows:
  require_once($this->config['SLIM_PATH']);
  \Slim\Slim::registerAutoloader(); //register slim autoloader
  $this->slim=new \Slim\Slim();
Create the PDO database connection using the following code:
    self::$dbh = new PDO(
      "mysql:host=".$this->config['DB_HOST'].";
      dbname=".$this->config['DB_NAME'],
      $this->config['DB_USER'], $this->config['DB_PASS']);
    self::$dbh->setAttribute(
      PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

Employing REST API for RWD
[ 106 ]
We need the Responsive_Images module too; in the following code we load the 
module using the path defined in app/rest_slim/conf.php:
  if (file_exists($this->config['RESPONSIVE_IMAGES_PATH'])) {
    require_once($this->config['RESPONSIVE_IMAGES_PATH']);
  } else {
If loading the module file fails, we throw an error as follows (error handling could be 
smarter but it's a lot of code for a short chapter anyway):
    die("module responsive images is required - 
      check this path: ".$this->config
      ['RESPONSIVE_IMAGES_PATH']);
  }
  self::$responsive_images=new Responsive_Images();
The application will not work without knowing the resolutions for which we'd like 
to define image versions. In the following code, we pass the resolutions defined in 
the app/rest_slim/conf.php file to the Responsive_Images module:
  if(array_key_exists('RESOLUTIONS', $this->config)
    &&is_array($this->config['RESOLUTIONS'])
    &&!empty($this->config['RESOLUTIONS']))
  {
    $this->resolutions=$this->config['RESOLUTIONS'];
    self::$responsive_images->setResolutions(
      $this->resolutions);
  } else {
    $this->resolutions = array(320); // fallback
  }
Finally, we have to inform the Responsive_Images module about the current screen 
width. We get it from a cookie created in the same way as in Chapter 5, Responsive 
Images Client- and Server-Side Approaches but this time we read it with the help of the 
Slim framework as seen in the following code:
  self::$current_screen_width = 
    $this->slim->getCookie('screen_width');
  if(!self::$current_screen_width || 
    self::$current_screen_width <= 0)
  {
    self::$current_screen_width = 320; // some low fallback
  }
  self::$responsive_images->setScreenWidth(self::
    $current_screen_width); // set screen width - CRUCIAL
}

Chapter 8
[ 107 ]
To avoid loading all these again and again, making this class a singleton (using 
the singleton design pattern) seems like a good idea (that is why the constructor is 
private here). To get an instance, we use a typical singleton getInstance method as 
seen in the following code:
public static function getInstance()
{
  if (!self::$instance) {
    self::$instance = new Rest_Slim();
  }
  return self::$instance;
}
Defining API with the Slim framework
With the environment ready, we can easily define our API with the Slim framework 
as seen in the following code:
public function setRoutes()
{
  $this->slim->get('/photos', array($this, 'getPhotoList'));
  $this->slim->get('/photos/:id', array($this, 'getPhoto'));
  $this->slim->get('/photos/country/:name', 
    array($this, 'getCountryPhotos'));
  $this->slim->get('/photos/countries/', 
    array($this, 'getCountries'));
  $this->slim->post('/photos', array($this, 'addPhoto'));
  $this->slim->delete('/photos/:id', 
    array($this,'deletePhoto'));
}
Gateway file and path setup
The following code will be used in the gateway PHP file (ress_gateway/index.
php), which can be placed anywhere provided we can put the .htaccess file to 
redirect requests and at the same time define a proper base path in the JavaScript of 
the application:
include "../app/bootstrap.php";
require_once(APPLICATION_DIR."rest_slim/app.php");
$app = Rest_Slim::getInstance();
$app->setRoutes();
$app->run();

Employing REST API for RWD
[ 108 ]
To easily connect all the dots, we define the following methods:
public function getGatewayUrl()
{
  return $this->getRootUrl().$this->config['GATEWAY'].'/photos';
}
The output of the preceding function is consumed inside the JavaScript code 
as follows:
var rootURL = "<?php echo $this->getGatewayUrl(); ?>";
But we certainly can't call PHP from a .js file. We use the templates placed in the 
app\rest_slim\assets\ directory—ajax.php in this case. Then this file is loaded 
using the following code:
public function getJsApp()
{
  $ajaxAppPath = $this->config['MOD_ASSETS_DIR'].'ajax.php';
  ob_start();
  include $ajaxAppPath;
  $ajaxAppCode = ob_get_contents();
  ob_end_clean();
  return $ajaxAppCode;
}
Then we use it in the header section of our frontend file rest_slim_test.php 
(inside the HTML <head> element) as follows:
  <?php echo $app->getJsApp(); ?>
Implementing routes
To use the routes defined in setRoutes(), we call them using the jQuery .ajax() 
method as in the following code:
function findAll() {
  $.ajax({
    type: 'GET',
    url: rootURL,
    dataType: "json", // data type of response
    success: renderMenu
  });
}

Chapter 8
[ 109 ]
The preceding code is pretty much self-explanatory. The function findAll() called 
from the $(document).ready function loads the list of all the photos by sending the 
GET request to the /photos route and renders them using the renderMenu function. 
The PHP function getPhotoList() assigned to this route, reads all photos from the 
database as an array of stdClass objects, encodes them to JSON format, and sends 
them back using the following code:
public function getPhotoList()
{
  $sql = "select * FROM photos ORDER BY location";
  try {
    $stmt = self::$dbh->query($sql);
    $photos = $stmt->fetchAll(PDO::FETCH_OBJ);
    //var_dump($photos);
    echo '{"photo": ' . json_encode($photos) . '}'; //here we send 
JSON encoded data
  } catch(PDOException $e) {
    echo '{"error":{"text": ' . $e->getMessage() .'}}';
  }
}
On the client side, the renderMenu function receives this data in the data argument 
as seen in the following code:
function renderMenu(data) {
  var list = data == null ? [] : (data.photo instanceof 
    Array ? data.photo : [data.photo]);
  $('#leftmenu li').remove();
  $.each(list, function(index, photo) {
    $('#leftmenu').append('<li data-photoid="' 
      + photo.id + '">'+photo.location+'</li>');
  });
}
The menu, when rendered this way, allows using the route /photos/:id to load the 
image for the current screen size. First we need to have the event handler attached to 
#leftmenu li as seen in the following code:
$(document).on("click", "#leftmenu li", function(){
  getPhoto($(this).data('photoid'))
});

Employing REST API for RWD
[ 110 ]
The click handler calls the getPhoto function, which builds the AJAX request as seen 
in the following code:
function getPhoto(id) {
  $.ajax({
    type: 'GET',
    url: rootURL + '/' + id,
    dataType: "json", // data type of response
    success: showImage
  });
}
The route /photos/:id is mapped to the PHP function getPhoto($id), as seen in 
the following code, which loads the file name from the database and translates it to 
the image URL in the relevant resolution with the use of the Responsive_Images 
module (we loaded this to the self::$responsive_images element in 
the constructor):
public function getPhoto($id)
{
  $sql="SELECT * FROM photos WHERE id=:id";
  try {
    $stmt = self::$dbh->prepare($sql);
    $stmt->bindParam("id", $id);
    $stmt->execute();
    $photo = $stmt->fetchObject();
    $picture_path=$this->getRootUrl().self::
      $responsive_images->getImage($photo->file_name);
    $photo->picture_path = $picture_path;
    echo '{"photo": ' . json_encode($photo) . '}';
  } catch(PDOException $e) {
    echo '{"error" : {"text": ' . $e->getMessage() .'}}';
  }
}

Chapter 8
[ 111 ]
Please note that in the Responsive_Images module (loaded 
into self::$responsive_images) from Chapter 5, Responsive 
Images Client- and Server-Side Approaches, we use cookies and session 
variables. According to REST principles, the application state should 
not be stored or managed on the server (like session variables). 
Nonetheless, in our case cookie data is managed by the client and 
directly copied to the session variable for caching reasons. In other 
words, the application remains stateless between requests (stateless 
is referring here to the server itself).
Adding photos
These images are generated automatically when necessary, but we are going to 
allow the user to upload manually cropped images for each of the defined 
resolutions. To achieve this, we need to dynamically generate the file upload form. 
We will use the same technique as with the JavaScript code—with the PHP template 
included within the output buffer. The form template file at app/rest_slim/
assets/form_html.php is loaded via the getForm() method into rest_slim_test.
php using the following code:
<div id="form_wrapper" class="hidden">
  <?php echo $app->getForm(); ?>
</div>
Parsing the created photo form inside our class gives us the advantage of easy access 
to all class variables, as seen in the following code:
<h3>Create new photo</h3>
<p id="status"><span id="progress"></span></p>
<form id="landscape" enctype="multipart/form-data">
  <label>location</label>
  <textarea id="location" name="location"></textarea>
  <label>country</label>
  <input type="text" id="country" name="country" />
  <label>file for max width screen</label>
  <input type="file" id="photo" name="photo" />
<?php

Employing REST API for RWD
[ 112 ]
In the following code,	  we iterate the resolutions array to generate the upload 
field for each resolution:
if (is_array($this->resolutions)) { 
foreach($this->resolutions as $resolution) {?>
  <label>file for screen width equal 
    <?php echo $resolution; ?>px or less </label>
  <input type="file" id="photo<?php echo $resolution; ?>"
    name="photo<?php echo $resolution; ?>" />
  <?php }
}
?>
The create photo form allows uploading files for each resolution.

Chapter 8
[ 113 ]
The following function, called upon clicking on the HTML element with id="save", 
is supposed to upload files via XHR. It was impossible until HTML5 was used..
$('#save').click(function(){
We use the formData interface of XHR level2 as seen in the following code:
  var formData = new 
    FormData(document.getElementById("landscape"));
  $.ajax({
    url: rootURL,  // same path as reading photo but with POST
    type: 'POST',
    xhr: function() {  // custom xhr
      myXhr = $.ajaxSettings.xhr();
      if (myXhr.upload) { // check if upload property exists
By adding an event listener, as in the following code, we attach the 
progressHandlingFunction to progress the event function handling of the file 
upload progress:
        myXhr.upload.addEventListener('progress',
          progressHandlingFunction, false); 
      }
      return myXhr;
    },
Then, upon success or failure of the upload, we display the pop-up boxes as follows:
    success: function(data, textStatus, jqXHR) {
      alert('Photo created successfully');
    },
    error: function(jqXHR, textStatus, errorThrown) {
      alert('addPhoto error: ' + textStatus+errorThrown);
    },
The form data to be uploaded is as follows:
    data: formData,
    cache: false,
    contentType: false,
    processData: false
  });
});

Employing REST API for RWD
[ 114 ]
We need to use similar processing on the server side in the addPhoto() method 
mapped to POST /photos as seen in the following code:
public function addPhoto() {
  $req = $this->slim->request();
First we process the file for max resolution using the following code:
  if (array_key_exists('photo', $_FILES)
    &&$_FILES['photo']['error'] == 0) { // we got file
    $filename = $_FILES['photo']['name'];
We rely on the directory structure implied by the Responsive Images module as 
seen in the following code:
    $base_images_dir =
      self::$responsive_images->getBaseImageDir();
    $target=$base_images_dir."max/".$filename;
  move_uploaded_file($_FILES['photo']['tmp_name'], $target);]
Then we iterate $this->resolutions to the build form field names again, and save 
the uploaded files to relevant the directories using the following code:
    foreach($this->resolutions as $resolution) {
      $form_field_name = 'photo'.$resolution;
      if(array_key_exists($form_field_name, $_FILES)
        &&$_FILES[$form_field_name]['error'] == 0)
      {
        if(is_dir($base_images_dir.$resolution)) {
          move_uploaded_file($_FILES
            [$form_field_name]['tmp_name'], 
            $base_images_dir.$resolution."/".$filename);
        }
      }
    }
Getting the form values via a request object from the Slim framework can be seen in 
the following code:
    $location = $req->post('location');
    $country = $req->post('country');

Chapter 8
[ 115 ]
And finally, we insert the record into the database using the following code:
    $sql = "INSERT INTO photos (file_name, location, country) 
      VALUES (:file, :location, :country)";
    try {
      $stmt = self::$dbh->prepare($sql);  
      $stmt->bindParam("file", $filename);
      $stmt->bindParam("location", $location);
      $stmt->bindParam("country", $country);
      $stmt->execute();
    } catch(PDOException $e) {
      echo '{"error": {"text":'. $e->getMessage() .'}}';
    }
  }
}
There are two key points in the preceding example presented as follows:
1.	 It shows how to create a RESTful API and an AJAX application that uses it.
2.	 It demonstrates integrating this application with our RESS solution.
What is it good for?
Some say that REST "will power the future of the Internet" (http://www.phparch.
com/2012/02/what-will-power-the-future-of-the-internet-rest-or-
soap/). For several years we have been able to see the constantly increasing 
significance of client-side programming and the evolution of APIs powering them. 
PHP programmers cannot ignore this trend as it already influences the leading PHP 
frameworks, such as Symphony. Let me quote Fabien Potencier (http://fabien.
potencier.org/article/49/what-is-symfony2):
"I don't like MVC because the Web has evolved a lot in the recent years and some 
projects are much different than the projects we had some years ago. Sometimes, 
you just need a way to create a REST API. Sometimes, the logic is mostly in the 
browser and the server is just used to serve data (think backbone.js, for instance). 
And for these projects, you don't need an MVC framework."
So the simple answer could be that learning this pattern of building web applications 
is good to better understand where web programming is heading. In particular, it 
may be useful for creating smart and fast administration interfaces, for extending 
existing systems with flexible RESS capabilities, and for creating websites that 
immediately respond to user actions, something that was once called Rich Internet 
Applications (http://en.wikipedia.org/wiki/Rich_Internet_application).

Employing REST API for RWD
[ 116 ]
Summary
The sample application created in this chapter demonstrates how an AJAX 
application using the RESTful API created with the Slim PHP framework can be easily 
extended to include RESS features, such as responsive images. To test this, a MySQL 
database has to be created; the loaded SQL from app/rest_slim/photos.sql, and 
the database configuration in app/rest_slim/conf.php has to be updated too.

Index
Symbols
51degrees database
URL  41
$config  36
$DDLobject  35
$(document).ready function  109
$filename parameter  76, 77
$Responsive_Images object  73
.ajax() method  108
<picture> element  68
<picture> tag
about  67
URL  64
A
accordion element
responsive tables, converting to  92-100
Adaptive Images
URL  16
addPhoto() method  114
AJAX
about  103
building  103
Asynchronous JavaScript and XML. 
See  AJAX
B
bakeCookie() function  55, 56
Bootstrap
custom compilation setup  18
grid system, testing  19-21
URL  14, 18
browser features
detecting  41
build_test_page function  58
C
client-side adaptive image module
URL  70
Compile and Download button  19
components, Twitter Bootstrap
URL  89-91
config object  40
Content Management System (CMS)  67
controversies
separate mobile website  7
cookie.js file  55
createWurflObject method  40
D
data-picture attribute  69
data-src attribute  69
Detector
about  41-51
URL  41
with WURFL  59-61
developers
about  12-15
RWD evolution  16
RWD experiments  15, 16
DeviceAtlas
URL  31
versus WURFL  32
Device Independent Pixels (DIP)  71
display property  85
dissertation
URL  103
Drupal
URL  64, 69

[ 118 ]
E
Ethan Marcotte
URL  5
F
Fabien Potencier
URL  115
file format
optimizing  83
Flexible images  15
Fluid grids  15
frameless grids
URL  15
Future of Mobile News
URL  8
G
gateway file  107, 108
getCurrentResolution function  73
getDDLobject() global function  47
getDeviceCapability method  40
getDeviceClass method  37, 40
getForm() method  111
getImage function  76
getInstance method  107
getNoJsUrl function  58
getPhoto function  110
getWurflWidth() function  47
Goldilocks Approach
URL  15
Gridpak
integrating  22-24
URL  22
Gridpak, integrating
responsive design, implementing  25-29
Gridulator
URL  14
H
hideRowCells method  96, 98
HTML5
Picturefill, using with  68-70
HTML5 Boilerplate
URL  13
hybrid applications
URL  11
I
image
reducing  84
optimizing  82
image compression
optimizing  83
image dimensions
optimizing  82
image usage
avoiding  84
init method  96
J
JavaScript screen size
testing  52-58
jQuery plugin
about  89-91
URL  89
URL, for design pattern  96
used, for converting responsive 
tables  92-100
JS
Picturefill, using with  68-70
M
Masonry
about  101
URL  15, 101
matchMedia()  68
matchmedia.js
URL  68
Media queries made with philosophy Mo­
bile First. See  Progressive Enhance­
ment
media queries optimization  84, 85
mobile-testing tool
URL  86
Modernizr
URL  13

[ 119 ]
Mod_Wurfl_Onsite class  35
MySQL
URL  104
P
PageSpeed Module
URL  87
PDO database connection
creating  105
Peter-Paul Koch
URL  8
photos
adding  111-115
picture element
URL  12
Picturefill
URL  64, 68
with HTML5  68-70
with JS  68-70
Plain CSS  66, 67
polyfill
URL  68
Progressive Enhancement  15
R
renderMenu function  109
Representational State Transfer. See  REST
respond.js
URL  13
responsive design
implementing  25-29
responsive images
building  72-79
creating  70, 71
scaling  64, 65
responsive tables
about  92
converting, to accordion element with 
jQuery plugin  92-100
Responsive Web Design. See  RWD
Responsive Web Design with Server 
Side components. See  RESS
RESS  7
RESS module
integrating  105-107
REST  104
REST API
defining, with Slim framework  107
Slim framework  105
Slim PHP framework  106, 107
URL  103
Rich Internet Applications
URL  115
routes
implementing  108-111
run method  60
RWD
about  5
advantages  10, 11
design, degrading  9
Flexible images  15
Fluid grids  15
Progressive Enhancement  15
S
Scalable Vector Graphics (SVG)  83
ScientaMobile
URL  39
screen size
detection  46, 47
separate mobile website  7
setCookie function  47, 56
showRowCells method  98
Slim framework
about  105
API, defining with  107
URL  105
Slim PHP framework  106, 107
smart_resize_image function  78
stdClass object  109
T
test_page.js file  55
testpage.php file  55
The Web Is The Platform
URL  8
Twitter Bootstrap
components  89-91
jQuery plugin  89-91

[ 120 ]
U
UA string
analyzing, with WURFL  59-61
UK Digital Cabinet Office blog
URL  8
users  11, 12
W
WampServer
URL  33
web page
testing  85-87
website
image, optimizing  82
optimizing  81
window.devicePixelRatio property  71
WURFL
UA string, analyzing with  59-61
using  46, 47
versus DeviceAtlas  32
WURFL Cloud version  39, 40
WURFL file
downloading with PHP API, URL  33
WURFL library  33-37
WURFL_WURFLManagerFactory 
instance  37
X
XMLHttpRequest (XHR)  103
Z
ZURB CSS Grid Builder
URL  14

Thank you for buying 
RESS Essentials
About Packt Publishing
Packt, pronounced 'packed', published its first book "Mastering phpMyAdmin for Effective 
MySQL Management" in April 2004 and subsequently continued to specialize in publishing 
highly focused books on specific technologies and solutions.
Our books and publications share the experiences of your fellow IT professionals in adapting 
and customizing today's systems, applications, and frameworks. Our solution based books 
give you the knowledge and power to customize the software and technologies you're using 
to get the job done. Packt books are more specific and less general than the IT books you have 
seen in the past. Our unique business model allows us to bring you more focused information, 
giving you more of what you need to know, and less of what you don't.
Packt is a modern, yet unique publishing company, which focuses on producing quality, 
cutting-edge books for communities of developers, administrators, and newbies alike. 
For more information, please visit our website: www.packtpub.com.
Writing for Packt
We welcome all inquiries from people who are interested in authoring. Book proposals 
should be sent to author@packtpub.com. If your book idea is still at an early stage and you 
would like to discuss it first before writing a formal book proposal, contact us; one of our 
commissioning editors will get in touch with you. 
We're not just looking for published authors; if you have strong technical skills but no writing 
experience, our experienced editors can help you develop a writing career, or simply get some 
additional reward for your expertise.

Responsive Web Design by 
Example
ISBN:  978-1-849695-42-8            Paperback: 338 pages
Discover how you can easily create engaging, 
responsive websites with minimum hassle!
1.	
Rapidly develop and prototype responsive 
websites by utilizing powerful open source 
frameworks.
2.	
Focus less on the theory and more on results, 
with clear step-by-step instructions, previews, 
and examples to help you along the way.
3.	
Learn how you can utilize three of the most 
powerful responsive frameworks available today: 
Bootstrap, Skeleton, and Zurb Foundation.
Instant Responsive Web Design
ISBN: 978-1-849699-25-9            Paperback: 70 pages
Learn the important components of responsive web 
design and make your websites mobile-friendly
1.	
Learn something new in an Instant! A short, 
fast, focused guide delivering immediate 
results.
2.	
Learn how to make your websites beautiful on 
any device.
3.	
Understand the differences between various 
responsive philosophies.
4.	
Expand your skill set with the quickly growing 
mobile-first approach.
Please check www.PacktPub.com for information on our titles

Responsive Web Design with 
HTML5 and CSS3
ISBN: 978-1-849693-18-9             Paperback: 324 pages
Learn responsive design using HTML5 and CSS3 to 
adapt websites to any browser or screen size
1.	
Everything needed to code websites in HTML5 
and CSS3 that are responsive to every device or 
screen size.
2.	
Learn the main new features of HTML5 and 
use CSS3’s stunning new capabilities including 
animations, transitions and transformations .
3.	
Real world examples show how to 
progressively enhance a responsive design 
while providing fall backs for older browsers .
HTML5 and CSS3 Responsive 
Web Design Cookbook
ISBN: 978-1-849695-44-2            Paperback: 204 pages
Learn the secrets of developing responsive websites 
capable of interfacing with today's mobile Internet 
devices
1.	
Learn the fundamental elements of writing 
responsive website code for all stages of the 
development lifecycle.
2.	
Create the ultimate code writer’s resource using 
logical workflow layers.
3.	
Full of usable code for immediate use in your 
website projects.
Please check www.PacktPub.com for information on our titles

