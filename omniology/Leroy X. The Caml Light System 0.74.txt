The
Caml
Ligh
t
system
release
0.
Do
cumen
tation
and
user's
man
ual
Xa
vier
Lero
y
Decem
b
er
,
		
Cop
yrigh
t
c

		
Institut
National
de
Rec
herc
he
en
Informatique
et
Automatique



Con
ten
ts
I
Getting
started


Installation
instructions
	
.
The
Unix
v
ersion
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
The
Macin
tosh
v
ersion
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
The
MS-Windo
ws
v
ersion
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
I
I
The
Caml
Ligh
t
language
reference
man
ual


The
core
Caml
Ligh
t
language

.
Lexical
con
v
en
tions
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Global
names
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
V
alues
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
T
yp
e
expressions
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
Constan
ts
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
P
atterns
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
Expressions
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Global
denitions
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.	
Directiv
es
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.0
Mo
dule
implemen
tations
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Mo
dule
in
terfaces
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:


Language
extensions

.
Streams,
parsers,
and
prin
ters
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Guards
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Range
patterns
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Recursiv
e
denitions
of
v
alues
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Lo
cal
denitions
using
where
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Mutable
v
arian
t
t
yp
es
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
String
access
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Alternate
syn
tax
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.	
Inx
sym
b
ols
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.0
Directiv
es
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0



I
I
I
The
Caml
Ligh
t
commands


Batc
h
compilation
(camlc)

.
Ov
erview
of
the
compiler
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Options
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Mo
dules
and
the
le
system
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
Common
errors
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	

The
toplev
el
system
(camlligh
t)

.
Options
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
T
oplev
el
con
trol
functions
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
The
toplev
el
and
the
mo
dule
system
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Common
errors
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
Building
custom
toplev
el
systems:
camlmktop
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
Options
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:


The
run
time
system
(camlrun)

.
Ov
erview
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Options
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Common
errors
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:


The
librarian
(camllibr)

.
Ov
erview
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Options
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
T
urning
co
de
in
to
a
library
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:


Lexer
and
parser
generators
(camllex,
camly
acc)

.
Ov
erview
of
camllex
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Syn
tax
of
lexer
denitions
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Ov
erview
of
camlyacc
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Syn
tax
of
grammar
denitions
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Options
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
A
complete
example
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

	
The
debugger
(camldebug)
	
	.
Compiling
for
debugging
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
	.
In
v
o
cation
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
	.
Commands
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
	.
Executing
a
program
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

	.
Breakp
oin
ts
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

	.
The
call
stac
k
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

	.
Examining
v
ariable
v
alues
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

	.
Con
trolling
the
debugger
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

	.	
Miscellaneous
commands
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	


0
Proling
(camlpro)
	
0.
Compiling
for
proling
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
0.
Proling
an
execution
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
0.
Prin
ting
proling
information
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
0.
Kno
wn
bugs
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	

Using
Caml
Ligh
t
under
Emacs
	
.
Up
dating
y
our
.emacs
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
The
caml
editing
mo
de
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
Running
the
toplev
el
as
an
inferior
pro
cess
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
Running
the
debugger
as
an
inferior
pro
cess
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	

In
terfacing
C
with
Caml
Ligh
t
		
.
Ov
erview
and
compilation
information
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
		
.
The
value
t
yp
e
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
Represen
tation
of
Caml
Ligh
t
data
t
yp
es
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
Op
erations
on
v
alues
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
Living
in
harmon
y
with
the
garbage
collector
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
A
complete
example
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
IV
The
Caml
Ligh
t
library


The
core
library

.
bool:
b
o
olean
op
erations
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
builtin:
base
t
yp
es
and
constructors
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
char:
c
haracter
op
erations
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
eq:
generic
comparisons
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
exc:
exceptions
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
fchar:
c
haracter
op
erations,
without
sanit
y
c
hec
ks
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
float:
op
erations
on
oating-p
oin
t
n
um
b
ers
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
fstring:
string
op
erations,
without
sanit
y
c
hec
ks
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.	
fvect:
op
erations
on
v
ectors,
without
sanit
y
c
hec
ks
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.0
int:
op
erations
on
in
tegers
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
io:
buered
input
and
output
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
list:
op
erations
on
lists
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
pair:
op
erations
on
pairs
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
ref:
op
erations
on
references
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
stream:
op
erations
on
streams
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
string:
string
op
erations
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
vect:
op
erations
on
v
ectors
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:


The
standard
library

.
arg:
parsing
of
command
line
argumen
ts
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
baltree:
basic
balanced
binary
trees
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
filename:
op
erations
on
le
names
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0


.
format:
prett
y
prin
ting
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
gc:
memory
managemen
t
con
trol
and
statistics
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
genlex:
a
generic
lexical
analyzer
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
hashtbl:
hash
tables
and
hash
functions
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
lexing:
the
run-time
library
for
lexers
generated
b
y
camllex
:
:
:
:
:
:
:
:
:
:
:
:

.	
map:
asso
ciation
tables
o
v
er
ordered
t
yp
es
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.0
parsing:
the
run-time
library
for
parsers
generated
b
y
camly
acc
:
:
:
:
:
:
:
:
:
:

.
printexc:
a
catc
h-all
exception
handler
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
printf:
formatting
prin
ting
functions
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
queue:
queues
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
random:
pseudo-random
n
um
b
er
generator
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
set:
sets
o
v
er
ordered
t
yp
es
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
sort:
sorting
and
merging
lists
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
stack:
stac
ks
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
sys:
system
in
terface
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	

The
graphics
library

.
graphics:
mac
hine-indep
en
den
t
graphics
primitiv
es
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:


The
unix
library:
Unix
system
calls

.
unix:
in
terface
to
the
Unix
system
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:


The
n
um
library:
arbitrary-precision
rational
arithmetic
	
.
num:
op
erations
on
n
um
b
ers
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
arith_status:
ags
that
con
trol
rational
arithmetic
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	

The
str
library:
regular
expressions
and
string
pro
cessing
	
.
str:
regular
expressions
and
high-lev
el
string
pro
cessing
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
V
App
endix
0
	
F
urther
reading
0
	.
Programming
in
ML
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
	.
Descriptions
of
ML
dialects
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
	.
Implemen
ting
functional
programming
languages
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
	.
Applications
of
ML
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
Index
to
the
library
0
Index
of
k
eyw
ords


F
orew
ord
This
man
ual
do
cumen
ts
the
release
0.
of
the
Caml
Ligh
t
system.
It
is
organized
as
follo
ws.

P
art
I,
\Getting
started",
explains
ho
w
to
install
Caml
Ligh
t
on
y
our
mac
hine.

P
art
I
I,
\The
Caml
Ligh
t
language
reference
man
ual",
is
the
reference
description
of
the
Caml
Ligh
t
language.

P
art
I
I
I,
\The
Caml
Ligh
t
commands",
do
cumen
ts
the
Caml
Ligh
t
compiler,
toplev
el
system,
and
programming
utilities.

P
art
IV,
\The
Caml
Ligh
t
library",
describ
es
the
mo
dules
pro
vided
in
the
standard
library
.

P
art
V,
\App
endix",
con
tains
a
short
bibliograph
y
,
an
index
of
all
iden
tiers
dened
in
the
standard
library
,
and
an
index
of
Caml
Ligh
t
k
eyw
ords.
Con
v
en
tions
The
Caml
Ligh
t
system
comes
in
sev
eral
v
ersions:
for
Unix
mac
hines,
for
Macin
toshes,
and
for
PCs.
The
parts
of
this
man
ual
that
are
sp
ecic
to
one
v
ersion
are
presen
ted
as
sho
wn
b
elo
w:
Unix:
This
is
material
sp
ecic
to
the
Unix
v
ersion.
Mac:
This
is
material
sp
ecic
to
the
Macin
tosh
v
ersion.
PC:
This
is
material
sp
ecic
to
the
PC
v
ersion.
License
The
Caml
Ligh
t
system
is
cop
yrigh
t
c

		,
		0,
		,
		,
		,
		,
		,
		,
		
Institut
National
de
Rec
herc
he
en
Informatique
et
en
Automatique
(INRIA).
INRIA
holds
all
o
wnership
righ
ts
to
the
Caml
Ligh
t
system.
See
the
le
COPYRIGHT
in
the
distribution
for
the
cop
yrigh
t
notice.
The
Caml
Ligh
t
system
can
b
e
freely
redistributed.
More
precisely
,
INRIA
gran
ts
an
y
user
of
the
Caml
Ligh
t
system
the
righ
t
to
repro
duce
it,
pro
vided
that
the
copies
are
distributed
under
the
conditions
giv
en
in
the
COPYRIGHT
le.
The
presen
t
do
cumen
tation
is
distributed
under
the
same
conditions.



F
orew
ord
Av
ailabilit
y
b
y
FTP
The
complete
Caml
Ligh
t
distribution
resides
on
the
mac
hine
ftp.inria.fr.
The
distribution
les
can
b
e
transferred
b
y
anon
ymous
FTP:
Host:
ftp.inria.fr
(In
ternet
address
	.	..)
Login
name:
anonymous
P
assw
ord:
y
our
e-mail
address
Directory:
lang/caml-light
Files:
see
the
index
in
le
README

P
art
I
Getting
started



Chapter

Installation
instructions
This
c
hapter
explains
ho
w
to
install
Caml
Ligh
t
on
y
our
mac
hine.
.
The
Unix
v
ersion
Requiremen
ts.
An
y
mac
hine
that
runs
under
one
of
the
v
arious
a
v
ors
of
the
Unix
op
erating
system,
and
that
has
a
at,
non-segmen
ted,
-bit
or
-bit
address
space.
M
of
RAM,
M
of
free
disk
space.
The
graphics
library
requires
X
release

or
later.
Installation.
The
Unix
v
ersion
is
distributed
in
source
format,
as
a
compressed
tar
le
named
clunix.tar.gz.
T
o
extract,
mo
v
e
to
the
directory
where
y
ou
w
an
t
the
source
les
to
reside,
transfer
clunix.tar.gz
to
that
directory
,
and
execute
zcat
clunix.tar.gz
|
tar
xBf
-
This
extracts
the
source
les
in
the
curren
t
directory
.
The
le
INSTALL
con
tains
complete
instruc-
tions
on
ho
w
to
congure,
compile
and
install
Caml
Ligh
t.
Read
it
and
follo
w
the
instructions.
T
roublesho
oting.
See
the
le
INSTALL.
.
The
Macin
tosh
v
ersion
Requiremen
ts.
An
y
Macin
tosh
with
at
least
M
of
RAM
(M
is
recommended),
running
System

or
.
Ab
out
0K
of
free
space
on
the
disk.
The
parts
of
the
Caml
Ligh
t
system
that
supp
ort
batc
h
compilation
curren
tly
require
the
Macin
tosh
Programmer's
W
orkshop
(MPW)
v
ersion
..
MPW
is
Apple's
dev
elopmen
t
en
vironmen
t,
and
it
is
distributed
b
y
APD
A,
Apple's
Programmers
and
Dev
elop
ers
Asso
ciation.
See
the
le
READ
ME
in
the
distribution
for
APD
A's
address.
Installation.
Create
the
folder
where
the
Caml
Ligh
t
les
will
reside.
Double-clic
k
on
the
le
clmacbin.sea
from
the
distribution.
This
displa
ys
a
le
dialog
b
o
x.
Op
en
the
folder
where
the
Caml
Ligh
t
les
will
reside,
and
clic
k
on
the
Extract
button.
This
will
re-create
all
les
from
the
distribution
in
the
Caml
Ligh
t
folder.
T
o
test
the
installation,
double-clic
k
on
the
application
Caml
Light.
The
\Caml
Ligh
t
output"
windo
w
should
displa
y
something
lik
e
	

0
>
Caml
Light
version
0.
#
In
the
\Caml
Ligh
t
input"
windo
w,
en
ter
+;;
and
press
the
Return
k
ey
.
The
\Caml
Ligh
t
output"
windo
w
should
displa
y:
>
Caml
Light
version
0.
#+;;
-
:
int
=

#
Select
\Quit"
from
the
\File"
men
u
to
return
to
the
Finder.
If
y
ou
ha
v
e
MPW,
y
ou
can
install
the
batc
h
compilation
to
ols
as
follo
ws.
The
to
ols
and
scripts
from
the
tools
folder
m
ust
reside
in
a
place
where
MPW
will
nd
them
as
commands.
There
are
t
w
o
w
a
ys
to
ac
hiev
e
this
result:
either
cop
y
the
les
in
the
tools
folder
to
the
Tools
or
the
Scripts
folder
in
y
our
MPW
folder;
or
k
eep
the
les
in
the
tools
folder
and
add
the
follo
wing
line
to
y
our
UserStartup
le
(assuming
Caml
Ligh
t
resides
in
folder
Caml
Light
on
the
disk
named
My
HD):
Set
Commands
"{Commands},My
HD:Caml
Light:tools:"
In
either
case,
y
ou
no
w
ha
v
e
to
edit
the
camlc
script,
and
replace
the
string
Macintosh
HD:Caml
Light:lib:
(in
the
rst
line)
with
the
actual
pathname
of
the
lib
folder.
F
or
example,
if
y
ou
put
Caml
Ligh
t
in
folder
Caml
Light
on
the
disk
named
My
HD,
the
rst
line
of
camlc
should
read:
Set
stdlib
"My
HD:Caml
Light:lib:"
T
roublesho
oting.
Here
is
one
commonly
encoun
tered
problem.
Cannot
find
file
stream.zi
(Displa
y
ed
in
the
\Caml
Ligh
t
output"
windo
w,
with
an
alert
b
o
x
telling
y
ou
that
Caml
Ligh
t
has
terminated
abnormally
.)
This
is
an
installation
error.
The
folder
named
lib
in
the
distribution
m
ust
alw
a
ys
b
e
in
the
same
folder
as
the
Caml
Light
application.
It's
OK
to
mo
v
e
the
application
to
another
folder;
but
remem
b
er
to
mo
v
e
the
lib
directory
to
the
same
folder.
(T
o
return
to
the
Finder,
rst
select
\Quit"
from
the
\File"
men
u.)
.
The
MS-Windo
ws
v
ersion
Requiremen
ts.
A
PC
equipp
ed
with
a
0,
0
or
P
en
tium
pro
cessor,
running
MS
Windo
ws
.x,
Windo
ws
	
or
Windo
ws
NT.
Ab
out
M
of
free
space
on
the
disk.
A
t
least
M
of
RAM
is
recommended.
Installation.
The
MS-Windo
ws
v
ersion
is
distributed
as
a
self-extracting,
self-installing
arc
hiv
e
named
clwin.exe.
Simply
run
it
and
follo
w
the
steps
of
the
installation
program.

P
art
I
I
The
Caml
Ligh
t
language
reference
man
ual



Chapter

The
core
Caml
Ligh
t
language
F
orew
ord
This
do
cumen
t
is
in
tended
as
a
reference
man
ual
for
the
Caml
Ligh
t
language.
It
lists
all
language
constructs,
and
giv
es
their
precise
syn
tax
and
informal
seman
tics.
It
is
b
y
no
means
a
tutorial
in
tro
duction
to
the
language:
there
is
not
a
single
example.
A
go
o
d
w
orking
kno
wledge
of
the
language,
as
pro
vided
b
y
the
companion
tutorial
F
unctional
pr
o
gr
amming
using
Caml
Light,
is
assumed.
No
attempt
has
b
een
made
at
mathematical
rigor:
w
ords
are
emplo
y
ed
with
their
in
tuitiv
e
meaning,
without
further
denition.
As
a
consequence,
the
t
yping
rules
ha
v
e
b
een
left
out,
b
y
lac
k
of
the
mathematical
framew
ork
required
to
express
them,
while
they
are
denitely
part
of
a
full
formal
denition
of
the
language.
The
reader
in
terested
in
truly
formal
descriptions
of
languages
from
the
ML
family
is
referred
to
The
denition
of
Standar
d
ML
and
Commentary
on
Standar
d
ML,
b
y
Milner,
T
ofte
and
Harp
er,
MIT
Press.
W
arning
Sev
eral
implemen
tations
of
the
Caml
Ligh
t
language
are
a
v
ailable,
and
they
ev
olv
e
at
eac
h
re-
lease.
Consequen
tly
,
this
do
cumen
t
carefully
distinguishes
the
language
and
its
implemen
tations.
Implemen
tations
can
pro
vide
extra
language
constructs;
moreo
v
er,
all
p
oin
ts
left
unsp
ecied
in
this
reference
man
ual
can
b
e
in
terpreted
dieren
tly
b
y
the
implemen
tations.
The
purp
ose
of
this
reference
man
ual
is
to
sp
ecify
those
features
that
all
implemen
tations
m
ust
pro
vide.
Notations
The
syn
tax
of
the
language
is
giv
en
in
BNF-lik
e
notation.
T
erminal
sym
b
ols
are
set
in
t
yp
ewriter
fon
t
(like
this
).
Non-terminal
sym
b
ols
are
set
in
italic
fon
t
(lik
e
that).
Square
brac
k
ets
[:
:
:
]
denote
optional
comp
onen
ts.
Curly
brac
k
ets
f:
:
:
g
denotes
zero,
one
or
sev
eral
rep
etitions
of
the
enclosed
comp
onen
ts.
Curly
brac
k
et
with
a
trailing
plus
sign
f:
:
:
g
+
denote
one
or
sev
eral
rep
etitions
of
the
enclosed
comp
onen
ts.
P
aren
theses
(:
:
:
)
denote
grouping.



.
Lexical
con
v
en
tions
Blanks
The
follo
wing
c
haracters
are
considered
as
blanks:
space,
newline,
horizon
tal
tabulation,
carriage
return,
line
feed
and
form
feed.
Blanks
are
ignored,
but
they
separate
adjacen
t
iden
tiers,
literals
and
k
eyw
ords
that
w
ould
otherwise
b
e
confused
as
one
single
iden
tier,
literal
or
k
eyw
ord.
Commen
ts
Commen
ts
are
in
tro
duced
b
y
the
t
w
o
c
haracters
(*,
with
no
in
terv
ening
blanks,
and
terminated
b
y
the
c
haracters
*),
with
no
in
terv
ening
blanks.
Commen
ts
are
treated
as
blank
c
haracters.
Commen
ts
do
not
o
ccur
inside
string
or
c
haracter
literals.
Nested
commen
ts
are
correctly
handled.
Iden
tiers
iden
t
::=
letter
fletter
j
0
:
:
:
	
j
_g
letter
::=
A
:
:
:
Z
j
a
:
:
:
z
Iden
tiers
are
sequences
of
letters,
digits
and
_
(the
underscore
c
haracter),
starting
with
a
letter.
Letters
con
tain
at
least
the

lo
w
ercase
and
upp
ercase
letters
from
the
ASCI
I
set.
Implemen
tations
can
recognize
as
letters
other
c
haracters
from
the
extended
ASCI
I
set.
Iden
tiers
cannot
con
tain
t
w
o
adjacen
t
underscore
c
haracters
(__).
Implemen
tation
ma
y
limit
the
n
um
b
er
of
c
haracters
of
an
iden
tier,
but
this
limit
m
ust
b
e
ab
o
v
e

c
haracters.
All
c
haracters
in
an
iden
tier
are
meaningful.
In
teger
literals
in
teger-literal
::=
[-]
f0
:
:
:
	g
+
j
[-]
(0x
j
0X)
f0
:
:
:
	
j
A
:
:
:
F
j
a
:
:
:
fg
+
j
[-]
(0o
j
0O)
f0
:
:
:
g
+
j
[-]
(0b
j
0B)
f0
:
:
:
g
+
An
in
teger
literal
is
a
sequence
of
one
or
more
digits,
optionally
preceded
b
y
a
min
us
sign.
By
default,
in
teger
literals
are
in
decimal
(radix
0).
The
follo
wing
prexes
select
a
dieren
t
radix:
Prex
Radix
0x,
0X
hexadecimal
(radix
)
0o,
0O
o
ctal
(radix
)
0b,
0B
binary
(radix
)
(The
initial
0
is
the
digit
zero;
the
O
for
o
ctal
is
the
letter
O.)
Floating-p
oi
n
t
literals
oat-literal
::=
[-
]
f0
:
:
:
	g
+
[.
f0
:
:
:
	g]
[(e
j
E
)
[+
j
-]
f0
:
:
:
	g
+
]
Floating-p
oin
t
decimals
consist
in
an
in
teger
part,
a
decimal
part
and
an
exp
onen
t
part.
The
in
teger
part
is
a
sequence
of
one
or
more
digits,
optionally
preceded
b
y
a
min
us
sign.
The
decimal

Chapter
.
The
core
Caml
Ligh
t
language

part
is
a
decimal
p
oin
t
follo
w
ed
b
y
zero,
one
or
more
digits.
The
exp
onen
t
part
is
the
c
haracter
e
or
E
follo
w
ed
b
y
an
optional
+
or
-
sign,
follo
w
ed
b
y
one
or
more
digits.
The
decimal
part
or
the
exp
onen
t
part
can
b
e
omitted,
but
not
b
oth
to
a
v
oid
am
biguit
y
with
in
teger
literals.
Character
literals
c
har-literal
::=
`
regular-c
har
`
j
`
\
(\
j
`
j
n
j
t
j
b
j
r)
`
j
`
\
(0
:
:
:
	)
(0
:
:
:
	)
(0
:
:
:
	)
`
Character
literals
are
delimited
b
y
`
(bac
kquote)
c
haracters.
The
t
w
o
bac
kquotes
enclose
either
one
c
haracter
dieren
t
from
`
and
\,
or
one
of
the
escap
e
sequences
b
elo
w:
Sequence
Character
denoted
\\
bac
kslash
(\)
\`
bac
kquote
(`)
\n
newline
(LF)
\r
return
(CR)
\t
horizon
tal
tabulation
(T
AB)
\b
bac
kspace
(BS)
\ddd
the
c
haracter
with
ASCI
I
co
de
ddd
in
decimal
String
literals
string-literal
::=
"
fstring-c
haracter
g
"
string-c
haracter
::=
regular-c
har
j
\
(\
j
"
j
n
j
t
j
b
j
r)
j
\
(0
:
:
:
	)
(0
:
:
:
	)
(0
:
:
:
	)
String
literals
are
delimited
b
y
"
(double
quote)
c
haracters.
The
t
w
o
double
quotes
enclose
a
sequence
of
either
c
haracters
dieren
t
from
"
and
\,
or
escap
e
sequences
from
the
table
b
elo
w:
Sequence
Character
denoted
\\
bac
kslash
(\)
\"
double
quote
(")
\n
newline
(LF)
\r
return
(CR)
\t
horizon
tal
tabulation
(T
AB)
\b
bac
kspace
(BS)
\ddd
the
c
haracter
with
ASCI
I
co
de
ddd
in
decimal
Implemen
tations
m
ust
supp
ort
string
literals
up
to


 
c
haracters
in
length
(
c
harac-
ters).


Keyw
ords
The
iden
tiers
b
elo
w
are
reserv
ed
as
k
eyw
ords,
and
cannot
b
e
emplo
y
ed
otherwise:
and
as
begin
do
done
downto
else
end
exception
for
fun
function
if
in
let
match
mutable
not
of
or
prefix
rec
then
to
try
type
value
where
while
with
The
follo
wing
c
haracter
sequences
are
also
k
eyw
ords:
#
!
!=
&
(
)
*
*.
+
+.
,
-
-.
->
.
.(
/
/.
:
::
:=
;
;;
<
<.
<-
<=
<=.
<>
<>.
=
=.
==
>
>.
>=
>=.
@
[
[|
]
^
_
__
{
|
|]
}
'
Am
biguities
Lexical
am
biguities
are
resolv
ed
according
to
the
\longest
matc
h"
rule:
when
a
c
haracter
sequence
can
b
e
decomp
osed
in
to
t
w
o
tok
ens
in
sev
eral
dieren
t
w
a
ys,
the
decomp
osition
retained
is
the
one
with
the
longest
rst
tok
en.
.
Global
names
Global
names
are
used
to
denote
v
alue
v
ariables,
v
alue
constructors
(constan
t
or
non-constan
t),
t
yp
e
constructors,
and
record
lab
els.
In
ternally
,
a
global
name
consists
of
t
w
o
parts:
the
name
of
the
dening
mo
dule
(the
mo
dule
name),
and
the
name
of
the
global
inside
that
mo
dule
(the
lo
cal
name).
The
t
w
o
parts
of
the
name
m
ust
b
e
v
alid
iden
tiers.
Externally
,
global
names
ha
v
e
the
follo
wing
syn
tax:
global-name
::=
iden
t
j
iden
t
__
iden
t
The
form
iden
t
__
iden
t
is
called
a
qualied
name.
The
rst
iden
tier
is
the
mo
dule
name,
the
second
iden
tier
is
the
lo
cal
name.
The
form
iden
t
is
called
an
unqualied
name.
The
iden
tier
is
the
lo
cal
name;
the
mo
dule
name
is
omitted.
The
compiler
infers
this
mo
dule
name
follo
wing
the
completion
rules
giv
en
b
elo
w,
therefore
transforming
the
unqualied
name
in
to
a
full
global
name.
T
o
complete
an
unqualied
iden
tier,
the
compiler
c
hec
ks
a
list
of
mo
dules,
the
op
ened
mo
dules,
to
see
if
they
dene
a
global
with
the
same
lo
cal
name
as
the
unqualied
iden
tier.
When
one
is
found,
the
iden
tier
is
completed
in
to
the
full
name
of
that
global.
That
is,
the
compiler
tak
es
as
mo
dule
name
the
name
of
an
op
ened
mo
dule
that
denes
a
global
with
the
same
lo
cal
name
as
the
unqualied
iden
tier.
If
sev
eral
mo
dules
satisfy
this
condition,
the
one
that
comes
rst
in
the
list
of
op
ened
mo
dules
is
selected.
The
list
of
op
ened
mo
dules
alw
a
ys
includes
the
mo
dule
curren
tly
b
eing
compiled
(c
hec
k
ed
rst).
(In
the
case
of
a
toplev
el-based
implemen
tation,
this
is
the
mo
dule
where
all
toplev
el
denitions
are
en
tered.)
It
also
includes
a
n
um
b
er
of
standard
library
mo
dules
that
pro
vide
the
initial
en
vironmen
t

Chapter
.
The
core
Caml
Ligh
t
language

(c
hec
k
ed
last).
In
addition,
the
#open
and
#close
directiv
es
can
b
e
used
to
add
or
remo
v
e
mo
dules
from
that
list.
The
mo
dules
added
with
#open
are
c
hec
k
ed
after
the
mo
dule
curren
tly
b
eing
compiled,
but
b
efore
the
initial
standard
library
mo
dules.
v
ariable
::=
global-name
j
prefix
op
erator-name
op
erator-name
::=
+
j
-
j
*
j
/
j
mod
j
+.
j
-.
j
*.
j
/.
j
@
j
^
j
!
j
:=
j
=
j
<>
j
==
j
!=
j
!
j
<
j
<=
j
>
j
<=
j
<.
j
<=.
j
>.
j
<=.
cconstr
::=
global-name
j
[]
j
()
ncconstr
::=
global-name
j
prefix
::
t
yp
econstr
::=
global-name
lab
el
::=
global-name
Dep
ending
on
the
con
text,
global
names
can
stand
for
global
v
ariables
(v
ariable
),
constan
t
v
alue
constructors
(cconstr
),
non-constan
t
v
alue
constructors
(ncconst
),
t
yp
e
constructors
(t
yp
econstr
),
or
record
lab
els
(lab
el
).
F
or
v
ariables
and
v
alue
constructors,
sp
ecial
names
built
with
prefix
and
an
op
erator
name
are
recognized.
The
tok
ens
[]
and
()
are
also
recognized
as
built-in
constan
t
constructors
(the
empt
y
list
and
the
unit
v
alue).
The
syn
tax
of
the
language
restricts
lab
els
and
t
yp
e
constructors
to
app
ear
in
certain
p
ositions,
where
no
other
kind
of
global
names
are
accepted.
Hence
lab
els
and
t
yp
e
constructors
ha
v
e
their
o
wn
name
spaces.
V
alue
constructors
and
v
alue
v
ariables
liv
e
in
the
same
name
space:
a
global
name
in
v
alue
p
osition
is
in
terpreted
as
a
v
alue
constructor
if
it
app
ears
in
the
scop
e
of
a
t
yp
e
declaration
dening
that
constructor;
otherwise,
the
global
name
is
tak
en
to
b
e
a
v
alue
v
ariable.
F
or
v
alue
constructors,
the
t
yp
e
declaration
determines
whether
a
constructor
is
constan
t
or
not.
.
V
alues
This
section
describ
es
the
kinds
of
v
alues
that
are
manipulated
b
y
Caml
Ligh
t
programs.
..
Base
v
alues
In
teger
n
um
b
ers
In
teger
v
alues
are
in
teger
n
um
b
ers
from
 
0
to

0
 ,
that
is
 0
to
0.
Implemen
tations
ma
y
supp
ort
a
wider
range
of
in
teger
v
alues.
Floating-p
oi
n
t
n
um
b
ers
Floating-p
oin
t
v
alues
are
n
um
b
ers
in
oating-p
oin
t
represen
tation.
Ev
erything
ab
out
oating-p
oin
t
v
alues
is
implemen
tation-dep
end
en
t,
including
the
range
of
represen
table
n
um
b
ers,
the
n
um
b
er
of
signican
t
digits,
and
the
w
a
y
oating-p
oin
t
results
are
rounded.


Characters
Character
v
alues
are
represen
ted
as
-bit
in
tegers
b
et
w
een
0
and
.
Character
co
des
b
et
w
een
0
and

are
in
terpreted
follo
wing
the
ASCI
I
standard.
The
in
terpretation
of
c
haracter
co
des
b
et
w
een

and

is
implemen
tation-dep
ende
n
t.
Character
strings
String
v
alues
are
nite
sequences
of
c
haracters.
Implemen
tations
m
ust
supp
ort
strings
up
to


 
c
haracters
in
length
(
c
haracters).
Implemen
tations
ma
y
supp
ort
longer
strings.
..
T
uples
T
uples
of
v
alues
are
written
(v

;
:
:
:
;
v
n
),
standing
for
the
n-tuple
of
v
alues
v

to
v
n
.
T
uples
of
up
to


 
elemen
ts
(
elemen
ts)
m
ust
b
e
supp
orted,
though
implemen
tations
ma
y
supp
ort
tuples
with
more
elemen
ts.
..
Records
Record
v
alues
are
lab
eled
tuples
of
v
alues.
The
record
v
alue
written
fl
abel

=
v

;
:
:
:
;
l
abel
n
=
v
n
g
asso
ciates
the
v
alue
v
i
to
the
record
lab
el
l
abel
i
,
for
i
=

:
:
:
n.
Records
with
up
to


 
elds
(
elds)
m
ust
b
e
supp
orted,
though
implemen
tations
ma
y
supp
ort
records
with
more
elds.
..
Arra
ys
Arra
ys
are
nite,
v
ariable-sized
sequences
of
v
alues
of
the
same
t
yp
e.
Arra
ys
of
length
up
to


 
(
elemen
ts)
m
ust
b
e
supp
orted,
though
implemen
tations
ma
y
supp
ort
larger
arra
ys.
..
V
arian
t
v
alues
V
arian
t
v
alues
are
either
a
constan
t
constructor,
or
a
pair
of
a
non-constan
t
constructor
and
a
v
alue.
The
former
case
is
written
cconstr
;
the
latter
case
is
written
ncconstr
(v
),
where
v
is
said
to
b
e
the
argumen
t
of
the
non-constan
t
constructor
ncconstr
.
The
follo
wing
constan
ts
are
treated
lik
e
built-in
constan
t
constructors:
Constan
t
Constructor
false
the
b
o
olean
false
true
the
b
o
olean
true
()
the
\unit"
v
alue
[]
the
empt
y
list
..
F
unctions
F
unctional
v
alues
are
mappings
from
v
alues
to
v
alues.

Chapter
.
The
core
Caml
Ligh
t
language
	
.
T
yp
e
expressions
t
yp
expr
::=
'
iden
t
j
(
t
yp
expr
)
j
t
yp
expr
->
t
yp
expr
j
t
yp
expr
f*
t
yp
expr
g
+
j
t
yp
econstr
j
t
yp
expr
t
yp
econstr
j
(
t
yp
expr
f,
t
yp
expr
g
)
t
yp
econstr
The
table
b
elo
w
sho
ws
the
relativ
e
precedences
and
asso
ciativit
y
of
op
erators
and
non-closed
t
yp
e
constructions.
The
constructions
with
higher
precedences
come
rst.
Op
erator
Asso
ciativit
y
T
yp
e
constructor
application
{
*
{
->
righ
t
T
yp
e
expressions
denote
t
yp
es
in
denitions
of
data
t
yp
es
as
w
ell
as
in
t
yp
e
constrain
ts
o
v
er
patterns
and
expressions.
T
yp
e
v
ariables
The
t
yp
e
expression
'
iden
t
stands
for
the
t
yp
e
v
ariable
named
iden
t
.
In
data
t
yp
e
denitions,
t
yp
e
v
ariables
are
names
for
the
data
t
yp
e
parameters.
In
t
yp
e
constrain
ts,
they
represen
t
unsp
ecied
t
yp
es
that
can
b
e
instan
tiated
b
y
an
y
t
yp
e
to
satisfy
the
t
yp
e
constrain
t.
P
aren
thesized
t
yp
es
The
t
yp
e
expression
(
t
yp
expr
)
denotes
the
same
t
yp
e
as
t
yp
expr
.
F
unction
t
yp
es
The
t
yp
e
expression
t
yp
expr

->
t
yp
expr

denotes
the
t
yp
e
of
functions
mapping
argumen
ts
of
t
yp
e
t
yp
expr

to
results
of
t
yp
e
t
yp
expr

.
T
uple
t
yp
es
The
t
yp
e
expression
t
yp
expr

*
:
:
:
*
t
yp
expr
n
denotes
the
t
yp
e
of
tuples
whose
elemen
ts
b
elong
to
t
yp
es
t
yp
expr

;
:
:
:
t
yp
expr
n
resp
ectiv
ely
.
Constructed
t
yp
es
T
yp
e
constructors
with
no
parameter,
as
in
t
yp
econstr
,
are
t
yp
e
expressions.
The
t
yp
e
expression
t
yp
expr
t
yp
econstr
,
where
t
yp
econstr
is
a
t
yp
e
constructor
with
one
pa-
rameter,
denotes
the
application
of
the
unary
t
yp
e
constructor
t
yp
econstr
to
the
t
yp
e
t
yp
expr
.
The
t
yp
e
expression
(t
yp
expr

;
:
:
:
;
t
yp
expr
n
)
t
yp
econstr
,
where
t
yp
econstr
is
a
t
yp
e
construc-
tor
with
n
parameters,
denotes
the
application
of
the
n-ary
t
yp
e
constructor
t
yp
econstr
to
the
t
yp
es
t
yp
expr

through
t
yp
expr
n
.

0
.
Constan
ts
constan
t
::=
in
teger-literal
j
oat-literal
j
c
har-literal
j
string-literal
j
cconstr
The
syn
tactic
class
of
constan
ts
comprises
literals
from
the
four
base
t
yp
es
(in
tegers,
oating-
p
oin
t
n
um
b
ers,
c
haracters,
c
haracter
strings),
and
constan
t
constructors.
.
P
atterns
pattern
::=
iden
t
j
_
j
pattern
as
iden
t
j
(
pattern
)
j
(
pattern
:
t
yp
expr
)
j
pattern
|
pattern
j
constan
t
j
ncconstr
pattern
j
pattern
,
pattern
f,
patterng
j
{
lab
el
=
pattern
f;
lab
el
=
patterng
}
j
[
]
j
[
pattern
f;
patterng
]
j
pattern
::
pattern
The
table
b
elo
w
sho
ws
the
relativ
e
precedences
and
asso
ciativit
y
of
op
erators
and
non-closed
pattern
constructions.
The
constructions
with
higher
precedences
come
rst.
Op
erator
Asso
ciativit
y
Constructor
application
{
::
righ
t
,
{
|
left
as
{
P
atterns
are
templates
that
allo
w
selecting
data
structures
of
a
giv
en
shap
e,
and
binding
iden-
tiers
to
comp
onen
ts
of
the
data
structure.
This
selection
op
eration
is
called
pattern
matc
hing;
its
outcome
is
either
\this
v
alue
do
es
not
matc
h
this
pattern",
or
\this
v
alue
matc
hes
this
pattern,
resulting
in
the
follo
wing
bindings
of
iden
tiers
to
v
alues".
V
ariable
patterns
A
pattern
that
consists
in
an
iden
tier
matc
hes
an
y
v
alue,
binding
the
iden
tier
to
the
v
alue.
The
pattern
_
also
matc
hes
an
y
v
alue,
but
do
es
not
bind
an
y
iden
tier.

Chapter
.
The
core
Caml
Ligh
t
language

Alias
patterns
The
pattern
pattern

as
iden
t
matc
hes
the
same
v
alues
as
pattern

.
If
the
matc
hing
against
pattern

is
successful,
the
iden
tier
iden
t
is
b
ound
to
the
matc
hed
v
alue,
in
addition
to
the
bindings
p
erformed
b
y
the
matc
hing
against
pattern

.
P
aren
thesized
patterns
The
pattern
(
pattern

)
matc
hes
the
same
v
alues
as
pattern

.
A
t
yp
e
constrain
t
can
app
ear
in
a
paren
thesized
patterns,
as
in
(
pattern

:
t
yp
expr
).
This
constrain
t
forces
the
t
yp
e
of
pattern

to
b
e
compatible
with
t
yp
e
.
\Or"
patterns
The
pattern
pattern

|
pattern

represen
ts
the
logical
\or"
of
the
t
w
o
patterns
pattern

and
pattern

.
A
v
alue
matc
hes
pattern

|
pattern

either
if
it
matc
hes
pattern

or
if
it
matc
hes
pattern

.
The
t
w
o
sub-patterns
pattern

and
pattern

m
ust
con
tain
no
iden
tiers.
Hence
no
bindings
are
returned
b
y
matc
hing
against
an
\or"
pattern.
Constan
t
patterns
A
pattern
consisting
in
a
constan
t
matc
hes
the
v
alues
that
are
equal
to
this
constan
t.
V
arian
t
patterns
The
pattern
ncconstr
pattern

matc
hes
all
v
arian
ts
whose
constructor
is
equal
to
ncconstr
,
and
whose
argumen
t
matc
hes
pattern

.
The
pattern
pattern

::
pattern

matc
hes
non-empt
y
lists
whose
heads
matc
h
pattern

,
and
whose
tails
matc
h
pattern

.
This
pattern
b
eha
v
es
lik
e
prefix
::
(
pattern

,
pattern

).
The
pattern
[
pattern

;
:
:
:
;
pattern
n
]
matc
hes
lists
of
length
n
whose
elemen
ts
matc
h
pattern

:
:
:
pattern
n
,
resp
ectiv
ely
.
This
pattern
b
eha
v
es
lik
e
pattern

::
:
:
:
::
pattern
n
::
[].
T
uple
patterns
The
pattern
pattern

,
:
:
:
,
pattern
n
matc
hes
n-tuples
whose
comp
onen
ts
matc
h
the
patterns
pattern

through
pattern
n
.
That
is,
the
pattern
matc
hes
the
tuple
v
alues
(v

;
:
:
:
;
v
n
)
suc
h
that
pattern
i
matc
hes
v
i
for
i
=
;
:
:
:
;
n.
Record
patterns
The
pattern
{
lab
el

=
pattern

;
:
:
:
;
lab
el
n
=
pattern
n
}
matc
hes
records
that
dene
at
least
the
lab
els
lab
el

through
lab
el
n
,
and
suc
h
that
the
v
alue
asso
ciated
to
lab
el
i
matc
h
the
pattern
pattern
i
,
for
i
=
;
:
:
:
;
n.
The
record
v
alue
can
dene
more
lab
els
than
lab
el

:
:
:
lab
el
n
;
the
v
alues
asso
ciated
to
these
extra
lab
els
are
not
tak
en
in
to
accoun
t
for
matc
hing.


.
Expressions
expr
::=
iden
t
j
v
ariable
j
constan
t
j
(
expr
)
j
begin
expr
end
j
(
expr
:
t
yp
expr
)
j
expr
,
expr
f,
expr
g
j
ncconstr
expr
j
expr
::
expr
j
[
expr
f;
expr
g
]
j
[|
expr
f;
expr
g
|]
j
{
lab
el
=
expr
f;
lab
el
=
expr
g
}
j
expr
expr
j
prex-op
expr
j
expr
inx-op
expr
j
expr
.
lab
el
j
expr
.
lab
el
<-
expr
j
expr
.(
expr
)
j
expr
.(
expr
)
<-
expr
j
expr
&
expr
j
expr
or
expr
j
if
expr
then
expr
[else
expr
]
j
while
expr
do
expr
done
j
for
iden
t
=
expr
(to
j
downto
)
expr
do
expr
done
j
expr
;
expr
j
match
expr
with
simple-matc
hing
j
fun
m
ultiple-matc
hing
j
function
simple-matc
hing
j
try
expr
with
simple-matc
hing
j
let
[rec
]
let-binding
fand
let-binding
g
in
expr
simple-matc
hing
::=
pattern
->
expr
f|
pattern
->
expr
g
m
ultiple-matc
hing
::=
pattern-list
->
expr
f|
pattern-list
->
expr
g
pattern-list
::=
pattern
fpattern
g
let-binding
::=
pattern
=
expr
j
v
ariable
pattern-list
=
expr
prex-op
::=
-
j
-.
j
!
inx-op
::=
+
j
-
j
*
j
/
j
mod
j
+.
j
-.
j
*.
j
/.
j
**
j
@
j
^
j
!
j
:=
j
=
j
<>
j
==
j
!=
j
<
j
<=
j
>
j
>=
j
<.
j
<=.
j
>.
j
>=.
The
table
b
elo
w
sho
ws
the
relativ
e
precedences
and
asso
ciativit
y
of
op
erators
and
non-closed
constructions.
The
constructions
with
higher
precedence
come
rst.

Chapter
.
The
core
Caml
Ligh
t
language

Construction
or
op
erator
Asso
ciativit
y
!
{
.
.(
{
function
application
left
constructor
application
{
-
-.
(prex)
{
**
righ
t
mod
left
*
*.
/
/.
left
+
+.
-
-.
left
::
righ
t
@
^
righ
t
comparisons
(=
==
<
etc.)
left
not
{
&
left
or
left
,
{
<-
:=
righ
t
if
{
;
righ
t
let
match
fun
function
try
{
..
Simple
expressions
Constan
ts
Expressions
consisting
in
a
constan
t
ev
aluate
to
this
constan
t.
V
ariables
Expressions
consisting
in
a
v
ariable
ev
aluate
to
the
v
alue
b
ound
to
this
v
ariable
in
the
curren
t
ev
aluation
en
vironmen
t.
The
v
ariable
can
b
e
either
a
qualied
iden
tier
or
a
simple
iden
tier.
Qualied
iden
tiers
alw
a
ys
denote
global
v
ariables.
Simple
iden
tiers
denote
either
a
lo
cal
v
ariable,
if
the
iden
tier
is
lo
cally
b
ound,
or
a
global
v
ariable,
whose
full
name
is
obtained
b
y
qualifying
the
simple
iden
tier,
as
describ
ed
in
section
..
P
aren
thesized
expressions
The
expressions
(
expr
)
and
begin
expr
end
ha
v
e
the
same
v
alue
as
expr
.
Both
constructs
are
seman
tically
equiv
alen
t,
but
it
is
go
o
d
st
yle
to
use
begin
:
:
:
end
inside
con
trol
structures:
if
:
:
:
then
begin
:
:
:
;
:
:
:
end
else
begin
:
:
:
;
:
:
:
end
and
(
:
:
:
)
for
the
other
grouping
situations.
P
aren
thesized
expressions
can
con
tain
a
t
yp
e
constrain
t,
as
in
(
expr
:
t
yp
e
).
This
constrain
t
forces
the
t
yp
e
of
expr
to
b
e
compatible
with
t
yp
e
.


F
unction
abstraction
The
most
general
form
of
function
abstraction
is:
fun
pattern


:
:
:
pattern
m

->
expr

|
:
:
:
|
pattern

n
:
:
:
pattern
m
n
->
expr
n
This
expression
ev
aluates
to
a
functional
v
alue
with
m
curried
argumen
ts.
When
this
function
is
applied
to
m
v
alues
v

:
:
:
v
m
,
the
v
alues
are
matc
hed
against
eac
h
pattern
ro
w
pattern

i
:
:
:
pattern
m
i
for
i
from

to
n.
If
one
of
these
matc
hings
succeeds,
that
is
if
the
v
alue
v
j
matc
hes
the
pattern
pattern
j
i
for
all
j
=
;
:
:
:
;
m,
then
the
expression
expr
i
asso
ciated
to
the
selected
pattern
ro
w
is
ev
aluated,
and
its
v
alue
b
ecomes
the
v
alue
of
the
function
application.
The
ev
aluation
of
expr
i
tak
es
place
in
an
en
vironmen
t
enric
hed
b
y
the
bindings
p
erformed
during
the
matc
hing.
If
sev
eral
pattern
ro
ws
matc
h
the
argumen
ts,
the
one
that
o
ccurs
rst
in
the
function
denition
is
selected.
If
none
of
the
pattern
ro
ws
matc
hes
the
argumen
t,
the
exception
Match_failure
is
raised.
If
the
function
ab
o
v
e
is
applied
to
less
than
m
argumen
ts,
a
functional
v
alue
is
returned,
that
represen
ts
the
partial
application
of
the
function
to
the
argumen
ts
pro
vided.
This
partial
application
is
a
function
that,
when
applied
to
the
remaining
argumen
ts,
matc
hes
all
argumen
ts
against
the
pattern
ro
ws
as
describ
ed
ab
o
v
e.
Matc
hing
do
es
not
start
un
til
all
m
argumen
ts
ha
v
e
b
een
pro
vided
to
the
function;
hence,
partial
applications
of
the
function
to
less
than
m
argumen
ts
nev
er
raise
Match_failure.
All
pattern
ro
ws
in
the
function
b
o
dy
m
ust
con
tain
the
same
n
um
b
er
of
patterns.
A
v
ariable
m
ust
not
b
e
b
ound
more
than
once
in
one
pattern
ro
w.
F
unctions
with
only
one
argumen
t
can
b
e
dened
with
the
function
k
eyw
ord
instead
of
fun:
function
pattern

->
expr

|
:
:
:
|
pattern
n
->
expr
n
The
function
th
us
dened
b
eha
v
es
exactly
as
describ
ed
ab
o
v
e.
The
only
dierence
b
et
w
een
the
t
w
o
forms
of
function
denition
is
ho
w
a
parsing
am
biguit
y
is
resolv
ed.
The
t
w
o
forms
cconstr
pattern
(t
w
o
patterns
in
a
ro
w)
and
ncconstr
pattern
(one
pattern)
cannot
b
e
distinguished
syn
tactically
.
F
unction
denitions
in
tro
duced
b
y
fun
resolv
e
the
am
biguit
y
to
the
former
form;
function
denitions
in
tro
duced
b
y
function
resolv
e
it
to
the
latter
form
(the
former
form
mak
es
no
sense
in
this
case).
F
unction
application
F
unction
application
is
denoted
b
y
juxtap
osition
of
expressions.
The
expression
expr

expr

:
:
:
expr
n
ev
aluates
the
expressions
expr

to
expr
n
.
The
expression
expr

m
ust
ev
aluate
to
a
functional
v
alue,
whic
h
is
then
applied
to
the
v
alues
of
expr

;
:
:
:
;
expr
n
.
The
order
in
whic
h
the
expressions
expr

;
:
:
:
;
expr
n
are
ev
aluated
is
not
sp
ecied.
Lo
cal
denitions
The
let
and
let
rec
constructs
bind
v
ariables
lo
cally
.
The
construct

Chapter
.
The
core
Caml
Ligh
t
language

let
pattern

=
expr

and
:
:
:
and
pattern
n
=
expr
n
in
expr
ev
aluates
expr

:
:
:
expr
n
in
some
unsp
ecied
order,
then
matc
hes
their
v
alues
against
the
patterns
pattern

:
:
:
pattern
n
.
If
the
matc
hings
succeed,
expr
is
ev
aluated
in
the
en
vironmen
t
enric
hed
b
y
the
bindings
p
erformed
during
matc
hing,
and
the
v
alue
of
expr
is
returned
as
the
v
alue
of
the
whole
let
expression.
If
one
of
the
matc
hings
fails,
the
exception
Match_failure
is
raised.
An
alternate
syn
tax
is
pro
vided
to
bind
v
ariables
to
functional
v
alues:
instead
of
writing
iden
t
=
fun
pattern

:
:
:
pattern
m
->
expr
in
a
let
expression,
one
ma
y
instead
write
iden
t
pattern

:
:
:
pattern
m
=
expr
Both
forms
bind
iden
t
to
the
curried
function
with
m
argumen
ts
and
only
one
case,
pattern

:
:
:
pattern
m
->
expr
.
Recursiv
e
denitions
of
v
ariables
are
in
tro
duced
b
y
let
rec:
let
rec
pattern

=
expr

and
:
:
:
and
pattern
n
=
expr
n
in
expr
The
only
dierence
with
the
let
construct
describ
ed
ab
o
v
e
is
that
the
bindings
of
v
ariables
to
v
alues
p
erformed
b
y
the
pattern-matc
hing
are
considered
already
p
erformed
when
the
expressions
expr

to
expr
n
are
ev
aluated.
That
is,
the
expressions
expr

to
expr
n
can
reference
iden
tiers
that
are
b
ound
b
y
one
of
the
patterns
pattern

;
:
:
:
;
pattern
n
,
and
exp
ect
them
to
ha
v
e
the
same
v
alue
as
in
expr
,
the
b
o
dy
of
the
let
rec
construct.
The
recursiv
e
denition
is
guaran
teed
to
b
eha
v
e
as
describ
ed
ab
o
v
e
if
the
expressions
expr

to
expr
n
are
function
denitions
(fun
:
:
:
or
function
:
:
:
),
and
the
patterns
pattern

:
:
:
pattern
n
consist
in
a
single
v
ariable,
as
in:
let
rec
iden
t

=
fun
:
:
:
and
:
:
:
and
iden
t
n
=
fun
:
:
:
in
expr
This
denes
iden
t

:
:
:
iden
t
n
as
m
utually
recursiv
e
functions
lo
cal
to
expr
.
The
b
eha
vior
of
other
forms
of
let
rec
denitions
is
implemen
tation-dep
endent.
..
Con
trol
constructs
Sequence
The
expression
expr

;
expr

ev
aluates
expr

rst,
then
expr

,
and
returns
the
v
alue
of
expr

.
Conditional
The
expression
if
expr

then
expr

else
expr

ev
aluates
to
the
v
alue
of
expr

if
expr

ev
aluates
to
the
b
o
olean
true
,
and
to
the
v
alue
of
expr

if
expr

ev
aluates
to
the
b
o
olean
false
.
The
else
expr

part
can
b
e
omitted,
in
whic
h
case
it
defaults
to
else
().


Case
expression
The
expression
match
expr
with
pattern

->
expr

|
:
:
:
|
pattern
n
->
expr
n
matc
hes
the
v
alue
of
expr
against
the
patterns
pattern

to
pattern
n
.
If
the
matc
hing
against
pattern
i
succeeds,
the
asso
ciated
expression
expr
i
is
ev
aluated,
and
its
v
alue
b
ecomes
the
v
alue
of
the
whole
match
expression.
The
ev
aluation
of
expr
i
tak
es
place
in
an
en
vironmen
t
enric
hed
b
y
the
bindings
p
erformed
during
matc
hing.
If
sev
eral
patterns
matc
h
the
v
alue
of
expr
,
the
one
that
o
ccurs
rst
in
the
match
expression
is
selected.
If
none
of
the
patterns
matc
h
the
v
alue
of
expr
,
the
exception
Match_failure
is
raised.
Bo
olean
op
erators
The
expression
expr

&
expr

ev
aluates
to
true
if
b
oth
expr

and
expr

ev
aluate
to
true
;
otherwise,
it
ev
aluates
to
false
.
The
rst
comp
onen
t,
expr

,
is
ev
aluated
rst.
The
second
comp
onen
t,
expr

,
is
not
ev
aluated
if
the
rst
comp
onen
t
ev
aluates
to
false.
Hence,
the
expression
expr

&
expr

b
eha
v
es
exactly
as
if
expr

then
expr

else
false
.
The
expression
expr

or
expr

ev
aluates
to
true
if
one
of
expr

and
expr

ev
aluates
to
true
;
otherwise,
it
ev
aluates
to
false
.
The
rst
comp
onen
t,
expr

,
is
ev
aluated
rst.
The
second
comp
onen
t,
expr

,
is
not
ev
aluated
if
the
rst
comp
onen
t
ev
aluates
to
true
.
Hence,
the
expression
expr

or
expr

b
eha
v
es
exactly
as
if
expr

then
true
else
expr

.
Lo
ops
The
expression
while
expr

do
expr

done
rep
eatedly
ev
aluates
expr

while
expr

ev
aluates
to
true
.
The
lo
op
condition
expr

is
ev
aluated
and
tested
at
the
b
eginning
of
eac
h
iteration.
The
whole
while
:
:
:
done
expression
ev
aluates
to
the
unit
v
alue
().
The
expression
for
iden
t
=
expr

to
expr

do
expr

done
rst
ev
aluates
the
expressions
expr

and
expr

(the
b
oundaries)
in
to
in
teger
v
alues
n
and
p.
Then,
the
lo
op
b
o
dy
expr

is
rep
eatedly
ev
aluated
in
an
en
vironmen
t
where
the
lo
cal
v
ariable
named
iden
t
is
successiv
ely
b
ound
to
the
v
alues
n,
n
+
,
:
:
:
,
p
 ,
p.
The
lo
op
b
o
dy
is
nev
er
ev
aluated
if
n
>
p.
The
expression
for
iden
t
=
expr

downto
expr

do
expr

done
rst
ev
aluates
the
expressions
expr

and
expr

(the
b
oundaries)
in
to
in
teger
v
alues
n
and
p.
Then,
the
lo
op
b
o
dy
expr

is
rep
eatedly
ev
aluated
in
an
en
vironmen
t
where
the
lo
cal
v
ariable
named
iden
t
is
successiv
ely
b
ound
to
the
v
alues
n,
n
 ,
:
:
:
,
p
+
,
p.
The
lo
op
b
o
dy
is
nev
er
ev
aluated
if
n
<
p.
In
b
oth
cases,
the
whole
for
expression
ev
aluates
to
the
unit
v
alue
()
.

Chapter
.
The
core
Caml
Ligh
t
language

Exception
handling
The
expression
try
expr
with
pattern

->
expr

|
:
:
:
|
pattern
n
->
expr
n
ev
aluates
the
expression
expr
and
returns
its
v
alue
if
the
ev
aluation
of
expr
do
es
not
raise
an
y
exception.
If
the
ev
aluation
of
expr
raises
an
exception,
the
exception
v
alue
is
matc
hed
against
the
patterns
pattern

to
pattern
n
.
If
the
matc
hing
against
pattern
i
succeeds,
the
asso
ciated
expression
expr
i
is
ev
aluated,
and
its
v
alue
b
ecomes
the
v
alue
of
the
whole
try
expression.
The
ev
aluation
of
expr
i
tak
es
place
in
an
en
vironmen
t
enric
hed
b
y
the
bindings
p
erformed
during
matc
hing.
If
sev
eral
patterns
matc
h
the
v
alue
of
expr
,
the
one
that
o
ccurs
rst
in
the
try
expression
is
selected.
If
none
of
the
patterns
matc
hes
the
v
alue
of
expr
,
the
exception
v
alue
is
raised
again,
thereb
y
transparen
tly
\passing
through"
the
try
construct.
..
Op
erations
on
data
structures
Pro
ducts
The
expression
expr

,
:
:
:
,
expr
n
ev
aluates
to
the
n-tuple
of
the
v
alues
of
expressions
expr

to
expr
n
.
The
ev
aluation
order
for
the
sub
expressions
is
not
sp
ecied.
V
arian
ts
The
expression
ncconstr
expr
ev
aluates
to
the
v
arian
t
v
alue
whose
constructor
is
ncconstr
,
and
whose
argumen
t
is
the
v
alue
of
expr
.
F
or
lists,
some
syn
tactic
sugar
is
pro
vided.
The
expression
expr

::
expr

stands
for
the
constructor
prefix
::
applied
to
the
argumen
t
(
expr

,
expr

),
and
therefore
ev
aluates
to
the
list
whose
head
is
the
v
alue
of
expr

and
whose
tail
is
the
v
alue
of
expr

.
The
expression
[
expr

;
:
:
:
;
expr
n
]
is
equiv
alen
t
to
expr

::
:
:
:
::
expr
n
::
[],
and
therefore
ev
aluates
to
the
list
whose
elemen
ts
are
the
v
alues
of
expr

to
expr
n
.
Records
The
expression
{
lab
el

=
expr

;
:
:
:
;
lab
el
n
=
expr
n
}
ev
aluates
to
the
record
v
alue
{
lab
el

=
v

;
:
:
:
;
lab
el
n
=
v
n
},
where
v
i
is
the
v
alue
of
expr
i
for
i
=
;
:
:
:
;
n.
The
lab
els
lab
el

to
lab
el
n
m
ust
all
b
elong
to
the
same
record
t
yp
es;
all
lab
els
b
elonging
to
this
record
t
yp
e
m
ust
app
ear
exactly
once
in
the
record
expression,
though
they
can
app
ear
in
an
y
order.
The
order
in
whic
h
expr

to
expr
n
are
ev
aluated
is
not
sp
ecied.
The
expression
expr

.
lab
el
ev
aluates
expr

to
a
record
v
alue,
and
returns
the
v
alue
asso
ciated
to
lab
el
in
this
record
v
alue.
The
expression
expr

.
lab
el
<-
expr

ev
aluates
expr

to
a
record
v
alue,
whic
h
is
then
mo
died
in-place
b
y
replacing
the
v
alue
asso
ciated
to
lab
el
in
this
record
b
y
the
v
alue
of
expr

.
This
op
eration
is
p
ermitted
only
if
lab
el
has
b
een
declared
mutable
in
the
denition
of
the
record
t
yp
e.
The
whole
expression
expr

.
lab
el
<-
expr

ev
aluates
to
the
unit
v
alue
()
.


Arra
ys
The
expression
[|
expr

;
:
:
:
;
expr
n
|]
ev
aluates
to
a
n-elemen
t
arra
y
,
whose
elemen
ts
are
ini-
tialized
with
the
v
alues
of
expr

to
expr
n
resp
ectiv
ely
.
The
order
in
whic
h
these
expressions
are
ev
aluated
is
unsp
ecied.
The
expression
expr

.(
expr

)
is
equiv
alen
t
to
the
application
vect_item
expr

expr

.
In
the
initial
en
vironmen
t,
the
iden
tier
vect_item
resolv
es
to
a
built-in
function
that
returns
the
v
alue
of
elemen
t
n
um
b
er
expr

in
the
arra
y
denoted
b
y
expr

.
The
rst
elemen
t
has
n
um
b
er
0;
the
last
elemen
t
has
n
um
b
er
n
 ,
where
n
is
the
size
of
the
arra
y
.
The
exception
Invalid_argument
is
raised
if
the
access
is
out
of
b
ounds.
The
expression
expr

.(
expr

)
<-
expr

is
equiv
alen
t
to
vect_assign
expr

expr

expr

.
In
the
initial
en
vironmen
t,
the
iden
tier
vect_assign
resolv
es
to
a
built-in
function
that
mo
dies
in-place
the
arra
y
denoted
b
y
expr

,
replacing
elemen
t
n
um
b
er
expr

b
y
the
v
alue
of
expr

.
The
exception
Invalid_argument
is
raised
if
the
access
is
out
of
b
ounds.
The
built-in
function
returns
().
Hence,
the
whole
expression
expr

.(
expr

)
<-
expr

ev
aluates
to
the
unit
v
alue
().
This
b
eha
vior
of
the
t
w
o
constructs
expr

.(
expr

)
and
expr

.(
expr

)
<-
expr

ma
y
c
hange
if
the
meaning
of
the
iden
tiers
vect_item
and
vect_assign
is
c
hanged,
either
b
y
redenition
or
b
y
mo
dication
of
the
list
of
op
ened
mo
dules.
See
the
discussion
b
elo
w
on
op
erators.
..
Op
erators
The
op
erators
written
infix-op
in
the
grammar
ab
o
v
e
can
app
ear
in
inx
p
osition
(b
et
w
een
t
w
o
expressions).
The
op
erators
written
prefix-op
in
the
grammar
ab
o
v
e
can
app
ear
in
prex
p
osition
(in
fron
t
of
an
expression).
The
expression
prex-op
expr
is
in
terpreted
as
the
application
iden
t
expr
,
where
iden
t
is
the
iden
tier
asso
ciated
to
the
op
erator
prex-op
in
the
table
b
elo
w.
Similarly
,
the
expression
expr

inx-op
expr

is
in
terpreted
as
the
application
iden
t
expr

expr

,
where
iden
t
is
the
iden-
tier
asso
ciated
to
the
op
erator
inx-op
in
the
table
b
elo
w.
The
iden
tiers
written
iden
t
ab
o
v
e
are
then
ev
aluated
follo
wing
the
rules
in
section
...
In
the
initial
en
vironmen
t,
they
ev
aluate
to
built-in
functions
whose
b
eha
vior
is
describ
ed
in
the
table.
The
b
eha
vior
of
the
constructions
prex-op
expr
and
expr

inx-op
expr

ma
y
c
hange
if
the
meaning
of
the
iden
tiers
asso
ciated
to
prex-op
or
inx-op
is
c
hanged,
either
b
y
redenition
of
the
iden
tiers,
or
b
y
mo
dication
of
the
list
of
op
ened
mo
dules,
through
the
#open
and
#close
directiv
es.

Chapter
.
The
core
Caml
Ligh
t
language
	
Op
erator
Asso
ciated
Beha
vior
in
the
default
en
vironmen
t
iden
tier
+
prefix
+
In
teger
addition.
-
(inx)
prefix
-
In
teger
subtraction.
-
(prex)
minus
In
teger
negation.
*
prefix
*
In
teger
m
ultiplication.
/
prefix
/
In
teger
division.
Raise
Division_by_zero
if
second
argu-
men
t
is
zero.
The
result
is
unsp
ecied
if
either
argumen
t
is
negativ
e.
mod
prefix
mod
In
teger
mo
dulus.
Raise
Division_by_zero
if
second
argu-
men
t
is
zero.
The
result
is
unsp
ecied
if
either
argumen
t
is
negativ
e.
+.
prefix
+.
Floating-p
oin
t
addition.
-.
(inx)
prefix
-.
Floating-p
oin
t
subtraction.
-.
(prex)
minus_float
Floating-p
oin
t
negation.
*.
prefix
*.
Floating-p
oin
t
m
ultiplication.
/.
prefix
/.
Floating-p
oin
t
division.
Raise
Division_by_zero
if
second
argumen
t
is
zero.
**
prefix
**
Floating-p
oin
t
exp
onen
tiation.
@
prefix
@
List
concatenation.
^
prefix
^
String
concatenation.
!
prefix
!
Dereferencing
(return
the
curren
t
con
ten
ts
of
a
reference).
:=
prefix
:=
Reference
assignmen
t
(up
date
the
reference
giv
en
as
rst
argumen
t
with
the
v
alue
of
the
second
argumen
t).
=
prefix
=
Structural
equalit
y
test.
<>
prefix
<>
Structural
inequalit
y
test.
==
prefix
==
Ph
ysical
equalit
y
test.
!=
prefix
!=
Ph
ysical
inequalit
y
test.
<
prefix
<
T
est
\less
than"
on
in
tegers.
<=
prefix
<=
T
est
\less
than
or
equal
"
on
in
tegers.
>
prefix
>
T
est
\greater
than"
on
in
tegers.
>=
prefix
>=
T
est
\greater
than
or
equal"
on
in
tegers.
<.
prefix
<.
T
est
\less
than"
on
oating-p
oin
t
n
um
b
ers.
<=.
prefix
<=.
T
est
\less
than
or
equal
"
on
oating-p
oin
t
n
um
b
ers.
>.
prefix
>.
T
est
\greater
than"
on
oating-p
oin
t
n
um
b
ers.
>=.
prefix
>=.
T
est
\greater
than
or
equal"
on
oating-p
oin
t
n
um
b
ers.
The
b
eha
vior
of
the
+,
-,
*,
/,
mod,
+.,
-.,
*.
or
/.
op
erators
is
unsp
ecied
if
the
result
falls
outside
of
the
range
of
represen
table
in
tegers
or
oating-p
oin
t
n
um
b
ers,
resp
ectiv
ely
.
See
c
hapter

for
a
more
precise
description
of
the
b
eha
vior
of
the
op
erators
ab
o
v
e.
.
Global
denitions
This
section
describ
es
the
constructs
that
bind
global
iden
tiers
(v
alue
v
ariables,
v
alue
constructors,
t
yp
e
constructors,
record
lab
els).

0
..
T
yp
e
denitions
t
yp
e-denition
::=
type
t
yp
edef
fand
t
yp
edef
g
t
yp
edef
::=
t
yp
e-params
iden
t
=
constr-decl
f|
constr-decl
g
j
t
yp
e-params
iden
t
=
{
lab
el-decl
f;
lab
el-decl
g
}
j
t
yp
e-params
iden
t
==
t
yp
expr
j
t
yp
e-params
iden
t
t
yp
e-params
::=
nothing
j
'
iden
t
j
(
'
iden
t
f,
'
iden
t
g
)
constr-decl
::=
iden
t
j
iden
t
of
t
yp
expr
lab
el-decl
::=
iden
t
:
t
yp
expr
j
mutable
iden
t
:
t
yp
expr
T
yp
e
denitions
bind
t
yp
e
constructors
to
data
t
yp
es:
either
v
arian
t
t
yp
es,
record
t
yp
es,
t
yp
e
abbreviations,
or
abstract
data
t
yp
es.
T
yp
e
denitions
are
in
tro
duced
b
y
the
type
k
eyw
ord,
and
consist
in
one
or
sev
eral
simple
denitions,
p
ossibly
m
utually
recursiv
e,
separated
b
y
the
and
k
eyw
ord.
Eac
h
simple
denition
denes
one
t
yp
e
constructor.
A
simple
denition
consists
in
an
iden
tier,
p
ossibly
preceded
b
y
one
or
sev
eral
t
yp
e
parameters,
and
follo
w
ed
b
y
a
data
t
yp
e
description.
The
iden
tier
is
the
lo
cal
name
of
the
t
yp
e
constructor
b
eing
dened.
(The
mo
dule
name
for
this
t
yp
e
constructor
is
the
name
of
the
mo
dule
b
eing
compiled.)
The
optional
t
yp
e
parameters
are
either
one
t
yp
e
v
ariable
'
iden
t
,
for
t
yp
e
constructors
with
one
parameter,
or
a
list
of
t
yp
e
v
ariables
('
iden
t

;
:
:
:
;
'
iden
t
n
),
for
t
yp
e
constructors
with
sev
eral
parameters.
These
t
yp
e
parameters
can
app
ear
in
the
t
yp
e
expressions
of
the
righ
t-hand
side
of
the
denition.
V
arian
t
t
yp
es
The
t
yp
e
denition
t
yp
eparams
iden
t
=
constr-decl

|
:
:
:
|
constr-decl
n
denes
a
v
arian
t
t
yp
e.
The
constructor
declarations
constr-decl

;
:
:
:
;
constr-decl
n
describ
e
the
constructors
asso
ciated
to
this
v
arian
t
t
yp
e.
The
constructor
declaration
iden
t
of
t
yp
expr
declares
the
lo
cal
name
iden
t
(in
the
mo
dule
b
eing
compiled)
as
a
non-constan
t
constructor,
whose
argumen
t
has
t
yp
e
t
yp
expr
.
The
constructor
declaration
iden
t
declares
the
lo
cal
name
iden
t
(in
the
mo
dule
b
eing
compiled)
as
a
constan
t
constructor.
Record
t
yp
es
The
t
yp
e
denition
t
yp
eparams
iden
t
=
{
lab
el-decl

;
:
:
:
;
lab
el-decl
n
}
denes
a
record
t
yp
e.
The
lab
el
declarations
lab
el-decl

;
:
:
:
;
lab
el-decl
n
describ
e
the
lab
els
asso
ciated
to
this
record
t
yp
e.
The
lab
el
declaration
iden
t
:
t
yp
expr
declares
the
lo
cal
name
iden
t
in
the
mo
dule
b
eing
compiled
as
a
lab
el,
whose
argumen
t
has
t
yp
e
t
yp
expr
.
The
lab
el
declaration
mutable
iden
t
:
t
yp
expr
b
eha
v
es
similarly;
in
addition,
it
allo
ws
ph
ysical
mo
dication
o
v
er
the
argumen
t
to
this
lab
el.

Chapter
.
The
core
Caml
Ligh
t
language

T
yp
e
abbreviations
The
t
yp
e
denition
t
yp
eparams
iden
t
==
t
yp
expr
denes
the
t
yp
e
constructor
iden
t
as
an
abbrevi-
ation
for
the
t
yp
e
expression
t
yp
expr
.
Abstract
t
yp
es
The
t
yp
e
denition
t
yp
eparams
iden
t
denes
iden
t
as
an
abstract
t
yp
e.
When
app
earing
in
a
mo
d-
ule
in
terface,
this
denition
allo
ws
exp
orting
a
t
yp
e
constructor
while
hiding
ho
w
it
is
represen
ted
in
the
mo
dule
implemen
tation.
..
Exception
denitions
exception-deniti
on
::=
exception
constr-decl
fand
constr-decl
g
Exception
denitions
add
new
constructors
to
the
built-in
v
arian
t
t
yp
e
exn
of
exception
v
alues.
The
constructors
are
declared
as
for
a
denition
of
a
v
arian
t
t
yp
e.
.	
Directiv
e
s
directiv
e
::=
#
open
string
j
#
close
string
j
#
iden
t
string
Directiv
es
con
trol
the
b
eha
vior
of
the
compiler.
They
apply
to
the
remainder
of
the
curren
t
compilation
unit.
The
t
w
o
directiv
es
#open
and
#close
mo
dify
the
list
of
op
ened
mo
dules,
that
the
compiler
uses
to
complete
unqualied
iden
tiers,
as
describ
ed
in
section
..
The
directiv
e
#open
string
adds
the
mo
dule
whose
name
is
giv
en
b
y
the
string
constan
t
string
to
the
list
of
op
ened
mo
dules,
in
rst
p
osition.
The
directiv
e
#close
string
remo
v
es
the
rst
o
ccurrence
of
the
mo
dule
whose
name
is
giv
en
b
y
the
string
constan
t
string
from
the
list
of
op
ened
mo
dules.
Implemen
tations
can
pro
vide
other
directiv
es,
pro
vided
they
follo
w
the
syn
tax
#
iden
t
string
,
where
iden
t
is
the
name
of
the
directiv
e,
and
the
string
constan
t
string
is
the
argumen
t
to
the
directiv
e.
The
b
eha
vior
of
these
additional
directiv
es
is
implemen
tation-dep
ende
n
t.
.0
Mo
dule
impleme
n
tations
implemen
tation
::=
fimpl-phrase
;;
g
impl-phrase
::=
expr
j
v
alue-denition
j
t
yp
e-denition
j
exception-denition
j
directiv
e
v
alue-denition
::=
let
[rec
]
let-binding
fand
let-binding
g


A
mo
dule
implemen
tation
consists
in
a
sequence
of
implemen
tation
phrases,
terminated
b
y
double
semicolons.
An
implemen
tation
phrase
is
either
an
expression,
a
v
alue
denition,
a
t
yp
e
or
exception
denition,
or
a
directiv
e.
A
t
run-time,
implemen
tation
phrases
are
ev
aluated
sequen
tially
,
in
the
order
in
whic
h
they
app
ear
in
the
mo
dule
implemen
tation.
Implemen
tation
phrases
consisting
in
an
expression
are
ev
aluated
for
their
side-eects.
V
alue
denitions
bind
global
v
alue
v
ariables
in
the
same
w
a
y
as
a
let
:
:
:
in
:
:
:
expression
binds
lo
cal
v
ariables.
The
expressions
are
ev
aluated,
and
their
v
alues
are
matc
hed
against
the
left-hand
sides
of
the
=
sides,
as
explained
in
section
...
If
the
matc
hing
succeeds,
the
bindings
of
iden
tiers
to
v
alues
p
erformed
during
matc
hing
are
in
terpreted
as
bindings
to
the
global
v
alue
v
ariables
whose
lo
cal
name
is
the
iden
tier,
and
whose
mo
dule
name
is
the
name
of
the
mo
dule.
If
the
matc
hing
fails,
the
exception
Match_failure
is
raised.
The
scop
e
of
these
bindings
is
the
phrases
that
follo
w
the
v
alue
denition
in
the
mo
dule
implemen
tation.
T
yp
e
and
exception
denitions
in
tro
duce
t
yp
e
constructors,
v
arian
t
constructors
and
record
lab
els
as
describ
ed
in
sections
..
and
...
The
scop
e
of
these
denitions
is
the
phrases
that
follo
w
the
v
alue
denition
in
the
mo
dule
implemen
tation.
The
ev
aluation
of
an
implemen
tation
phrase
consisting
in
a
t
yp
e
or
exception
denition
pro
duces
no
eect
at
run-time.
Directiv
es
mo
dify
the
b
eha
vior
of
the
compiler
on
the
subsequen
t
phrases
of
the
mo
dule
im-
plemen
tation,
as
describ
ed
in
section
.	.
The
ev
aluation
of
an
implemen
tation
phrase
consisting
in
a
directiv
e
pro
duces
no
eect
at
run-time.
Directiv
es
apply
only
to
the
mo
dule
curren
tly
b
eing
compiled;
in
particular,
they
ha
v
e
no
eect
on
other
mo
dules
that
refer
to
globals
exp
orted
b
y
the
mo
dule
b
eing
compiled.
.
Mo
dule
in
terfaces
in
terface
::=
fin
tf-phrase
;;g
in
tf-phrase
::=
v
alue-declaration
j
t
yp
e-denition
j
exception-denition
j
directiv
e
v
alue-declaration
::=
value
iden
t
:
t
yp
expr
fand
iden
t
:
t
yp
expr
g
Mo
dule
in
terfaces
declare
the
global
ob
jects
(v
alue
v
ariables,
t
yp
e
constructors,
v
arian
t
con-
structors,
record
lab
els)
that
a
mo
dule
exp
orts,
that
is,
mak
es
a
v
ailable
to
other
mo
dules.
Other
mo
dules
can
refer
to
these
globals
using
qualied
iden
tiers
or
the
#open
directiv
e,
as
explained
in
section
..
A
mo
dule
in
terface
consists
in
a
sequence
of
in
terface
phrases,
terminated
b
y
double
semicolons.
An
in
terface
phrase
is
either
a
v
alue
declaration,
a
t
yp
e
denition,
an
exception
denition,
or
a
directiv
e.
V
alue
declarations
declare
global
v
alue
v
ariables
that
are
exp
orted
b
y
the
mo
dule
implemen
ta-
tion,
and
the
t
yp
es
with
whic
h
they
are
exp
orted.
The
mo
dule
implemen
tation
m
ust
dene
these
v
ariables,
with
t
yp
es
at
least
as
general
as
the
t
yp
es
declared
in
the
in
terface.
The
scop
e
of
the
bindings
for
these
global
v
ariables
extends
from
the
mo
dule
implemen
tation
itself
to
all
mo
dules
that
refer
to
those
v
ariables.

Chapter
.
The
core
Caml
Ligh
t
language

T
yp
e
or
exception
denitions
in
tro
duce
t
yp
e
constructors,
v
arian
t
constructors
and
record
la-
b
els
as
describ
ed
in
sections
..
and
...
Exception
denitions
and
t
yp
e
denitions
that
are
not
abstract
t
yp
e
declarations
also
tak
e
eect
in
the
mo
dule
implemen
tation;
that
is,
the
t
yp
e
construc-
tors,
v
arian
t
constructors
and
record
lab
els
they
dene
are
considered
b
ound
on
en
trance
to
the
mo
dule
implemen
tation,
and
can
b
e
referred
to
b
y
the
implemen
tation
phrases.
T
yp
e
denitions
that
are
not
abstract
t
yp
e
declarations
m
ust
not
b
e
redened
in
the
mo
dule
implemen
tation.
In
con
trast,
the
t
yp
e
constructors
that
are
declared
abstract
in
a
mo
dule
in
terface
m
ust
b
e
dened
in
the
mo
dule
implemen
tation,
with
the
same
names.
Directiv
es
mo
dify
the
b
eha
vior
of
the
compiler
on
the
subsequen
t
phrases
of
the
mo
dule
in
ter-
face,
as
describ
ed
in
section
.	.
Directiv
es
apply
only
to
the
in
terface
curren
tly
b
eing
compiled;
in
particular,
they
ha
v
e
no
eect
on
other
mo
dules
that
refer
to
globals
exp
orted
b
y
the
in
terface
b
eing
compiled.



Chapter

Language
extensions
This
c
hapter
describ
es
the
language
features
that
are
implemen
ted
in
Caml
Ligh
t,
but
not
describ
ed
in
the
Caml
Ligh
t
reference
man
ual.
In
con
trast
with
the
fairly
stable
k
ernel
language
that
is
describ
ed
in
the
reference
man
ual,
the
extensions
presen
ted
here
are
still
exp
erimen
tal,
and
ma
y
b
e
remo
v
ed
or
c
hanged
in
the
future.
.
Streams,
parsers,
and
prin
ters
Caml
Ligh
t
comprises
a
built-in
t
yp
e
for
str
e
ams
(p
ossibly
innite
sequences
of
elemen
ts,
that
are
ev
aluated
on
demand),
and
asso
ciated
stream
expressions,
to
build
streams,
and
stream
patterns,
to
destructure
streams.
Streams
and
stream
patterns
pro
vide
a
natural
approac
h
to
the
writing
of
recursiv
e-descen
t
parsers.
Streams
are
presen
ted
b
y
the
follo
wing
extensions
to
the
syn
tactic
classes
of
expressions:
expr
::=
:
:
:
j
[<
>]
j
[<
stream-comp
onen
t
f;
stream-comp
onen
tg
>]
j
function
stream-matc
hing
j
match
expr
with
stream-matc
hing
stream-comp
onen
t
::=
'
expr
j
expr
stream-matc
hing
::=
stream-pattern
->
expr
f|
stream-pattern
->
expr
g
stream-pattern
::=
[<
>]
j
[<
stream-comp-pat
f;
stream-comp-patg
>]
stream-comp-pat
::=
'
pattern
j
expr
pattern
j
iden
t
Stream
expressions
are
brac
k
eted
b
y
[<
and
>].
They
represen
t
the
concatenation
of
their
comp
onen
ts.
The
comp
onen
t
'
expr
represen
ts
the
one-elemen
t
stream
whose
elemen
t
is
the
v
alue



of
expr
.
The
comp
onen
t
expr
represen
ts
a
sub-stream.
F
or
instance,
if
b
oth
s
and
t
are
streams
of
in
tegers,
then
[<';
s;
t;
'>]
is
a
stream
of
in
tegers
con
taining
the
elemen
t
,
then
the
elemen
ts
of
s,
then
those
of
t,
and
nally
.
The
empt
y
stream
is
denoted
b
y
[<
>].
Unlik
e
an
y
other
kind
of
expressions
in
the
language,
stream
expressions
are
submitted
to
lazy
ev
aluation:
the
comp
onen
ts
are
not
ev
aluated
when
the
stream
is
built,
but
only
when
they
are
accessed
during
stream
matc
hing.
The
comp
onen
ts
are
ev
aluated
once,
the
rst
time
they
are
accessed;
the
follo
wing
accesses
reuse
the
v
alue
computed
the
rst
time.
Stream
patterns,
also
brac
k
eted
b
y
[<
and
>],
describ
e
initial
segmen
ts
of
streams.
In
particular,
the
stream
pattern
[<
>]
matc
hes
all
streams.
Stream
pattern
comp
onen
ts
are
matc
hed
against
the
corresp
onding
elemen
ts
of
a
stream.
The
comp
onen
t
'
pattern
matc
hes
the
corresp
onding
stream
elemen
t
against
the
pattern.
The
comp
onen
t
expr
pattern
applies
the
function
denoted
b
y
expr
to
the
curren
t
stream,
then
matc
hes
the
result
of
the
function
against
pattern
.
Finally
,
the
comp
onen
t
iden
t
simply
binds
the
iden
tier
to
the
stream
b
eing
matc
hed.
(The
curren
t
implemen
tation
limits
iden
t
to
app
ear
last
in
a
stream
pattern.)
Stream
matc
hing
pro
ceeds
destructiv
ely:
once
a
comp
onen
t
has
b
een
matc
hed,
it
is
discarded
from
the
stream
(b
y
in-place
mo
dication).
Stream
matc
hing
pro
ceeds
in
t
w
o
steps:
rst,
a
pattern
is
selected
b
y
matc
hing
the
stream
against
the
rst
comp
onen
ts
of
the
stream
patterns;
then,
the
follo
wing
comp
onen
ts
of
the
selected
pattern
are
c
hec
k
ed
against
the
stream.
If
the
follo
wing
comp
onen
ts
do
not
matc
h,
the
exception
Parse_error
is
raised.
There
is
no
bac
ktrac
king
here:
stream
matc
hing
commits
to
the
pattern
selected
according
to
the
rst
elemen
t.
If
none
of
the
rst
comp
onen
ts
of
the
stream
patterns
matc
h,
the
exception
Parse_failure
is
raised.
The
Parse_failure
exception
causes
the
next
alternativ
e
to
b
e
tried,
if
it
o
ccurs
during
the
matc
hing
of
the
rst
elemen
t
of
a
stream,
b
efore
matc
hing
has
committed
to
one
pattern.
See
F
unctional
pr
o
gr
amming
using
Caml
Light
for
a
more
gen
tle
in
tro
ductions
to
streams,
and
for
some
examples
of
their
use
in
writing
parsers.
A
more
formal
presen
tation
of
streams,
and
a
discussion
of
alternate
seman
tics,
can
b
e
found
in
Parsers
in
ML
b
y
Mic
hel
Maun
y
and
Daniel
de
Rauglaudre,
in
the
pro
ceedings
of
the
		
A
CM
conference
on
Lisp
and
F
unctional
Programming.
.
Guards
Cases
of
a
pattern
matc
hing
can
include
guard
expressions,
whic
h
are
arbitrary
b
o
olean
expressions
that
m
ust
ev
aluate
to
true
for
the
matc
h
case
to
b
e
selected.
Guards
o
ccur
just
b
efore
the
->
tok
en
and
are
in
tro
duced
b
y
the
when
k
eyw
ord:
match
expr
with
pattern

[when
cond

]
->
expr

|
:
:
:
|
pattern
n
[when
cond
n
]
->
expr
n
(Same
syn
tax
for
the
fun,
function,
and
try
:
:
:
with
constructs.)
During
matc
hing,
if
the
v
alue
of
expr
matc
hes
some
pattern
pattern
i
whic
h
has
a
guard
cond
i
,
then
the
expression
cond
i
is
ev
aluated
(in
an
en
vironmen
t
enric
hed
b
y
the
bindings
p
erformed
during
matc
hing).
If
cond
i
ev
aluates
to
true,
then
expr
i
is
ev
aluated
and
its
v
alue
returned
as
the
result
of
the
matc
hing,
as
usual.
But
if
cond
i
ev
aluates
to
false,
the
matc
hing
is
resumed
against
the
patterns
follo
wing
pattern
i
.

Chapter
.
Language
extensions

.
Range
patterns
In
patterns,
Caml
Ligh
t
recognizes
the
form
`
c
`
..
`
d
`
(t
w
o
c
haracter
constan
ts
separated
b
y
..)
as
a
shorthand
for
the
pattern
`
c
`
|
`
c

`
|
`
c

`
|
:
:
:
|
`
c
n
`
|
`
d
`
where
c

;
c

;
:
:
:
;
c
n
are
the
c
haracters
that
o
ccur
b
et
w
een
c
and
d
in
the
ASCI
I
c
haracter
set.
F
or
instance,
the
pattern
`0`..`	`
matc
hes
all
c
haracters
that
are
digits.
.
Recursiv
e
denitions
of
v
alues
Besides
let
rec
denitions
of
functional
v
alues,
as
describ
ed
in
the
reference
man
ual,
Caml
Ligh
t
supp
orts
a
certain
class
of
recursiv
e
denitions
of
non-functional
v
alues.
F
or
instance,
the
follo
wing
denition
is
accepted:
let
rec
x
=

::
y
and
y
=

::
x;;
and
correctly
binds
x
to
the
cyclic
list
:::::::::
:
:
,
and
y
to
the
cyclic
list
:::::::::
:
:
Informally
,
the
class
of
accepted
denitions
consists
of
those
denitions
where
the
dened
v
ariables
o
ccur
only
inside
function
b
o
dies
or
as
a
eld
of
a
data
structure.
Moreo
v
er,
the
patterns
in
the
left-hand
sides
m
ust
b
e
iden
tiers,
nothing
more
complex.
.
Lo
cal
denitions
using
where
A
p
ostx
syn
tax
for
lo
cal
denitions
is
pro
vided:
expr
::=
:
:
:
j
expr
where
[rec
]
let-binding
The
expression
expr
where
let-binding
b
eha
v
es
exactly
as
let
let-binding
in
expr
,
and
similarly
for
where
rec
and
let
rec.
.
Mutable
v
arian
t
t
yp
es
The
argumen
t
of
a
v
alue
constructor
can
b
e
declared
\m
utable"
when
the
v
arian
t
t
yp
e
is
dened:
type
foo
=
A
of
mutable
int
|
B
of
mutable
int
*
int
|
...
This
allo
ws
in-place
mo
dication
of
the
argumen
t
part
of
a
constructed
v
alue.
Mo
dication
is
p
erformed
b
y
a
new
kind
of
expressions,
written
iden
t
<-
expr
,
where
iden
t
is
an
iden
tier
b
ound
b
y
pattern-matc
hing
to
the
argumen
t
of
a
m
utable
constructor,
and
expr
denotes
the
v
alue
that
m
ust
b
e
stored
in
place
of
that
argumen
t.
Con
tin
uing
the
example
ab
o
v
e:


let
x
=
A

in
begin
match
x
with
A
y
->
y
<-

|
_
->
()
end;
x
returns
the
v
alue
A
.
The
notation
iden
t
<-
expr
w
orks
also
if
iden
t
is
an
iden
tier
b
ound
b
y
pattern-matc
hing
to
the
v
alue
of
a
m
utable
eld
in
a
record.
F
or
instance,
type
bar
=
{mutable
lbl
:
int};;
let
x
=
{lbl
=
}
in
begin
match
x
with
{lbl
=
y}
->
y
<-

end;
x
returns
the
v
alue
{lbl
=
}.
.
String
access
Extra
syn
tactic
constructs
are
pro
vided
to
access
and
mo
dify
c
haracters
in
strings:
expr
::=
:
:
:
j
expr
.[
expr
]
j
expr
.[
expr
]
<-
expr
The
expression
expr

.[
expr

]
is
equiv
alen
t
to
the
application
nth_char
expr

expr

.
In
the
initial
en
vironmen
t,
the
iden
tier
nth_char
resolv
es
to
a
built-in
function
that
returns
the
c
haracter
n
um
b
er
expr

in
the
string
denoted
b
y
expr

.
The
rst
elemen
t
has
n
um
b
er
0;
the
last
elemen
t
has
n
um
b
er
n
 ,
where
n
is
the
length
of
the
string.
The
exception
Invalid_argument
is
raised
if
the
access
is
out
of
b
ounds.
The
expression
expr

.[
expr

]
<-
expr

is
equiv
alen
t
to
set_nth_char
expr

expr

expr

.
In
the
initial
en
vironmen
t,
the
iden
tier
set_nth_char
resolv
es
to
a
built-in
function
that
mo
dies
in-place
the
string
denoted
b
y
expr

,
replacing
c
haracter
n
um
b
er
expr

b
y
the
v
alue
of
expr

.
The
exception
Invalid_argument
is
raised
if
the
access
is
out
of
b
ounds.
The
built-in
function
returns
().
.
Alternate
syn
tax
The
syn
tax
of
some
constructs
has
b
een
sligh
tly
relaxed:

An
optional
;
ma
y
terminate
a
sequence,
list
expression,
or
record
expression.
F
or
instance,
begin
e

;
e

;
end
is
syn
tactically
correct
and
synon
ymous
with
begin
e

;
e

end.

Similarly
,
an
optional
|
ma
y
b
egin
a
pattern-matc
hing
expression.
F
or
instance,
function
|
pat

->
expr

|
:
:
:
is
syn
tactically
correct
and
synon
ymous
with
function
pat

->
expr

|
:
:
:
.

The
tok
ens
&&
and
||
are
recognized
as
synon
ymous
for
&
(sequen
tial
\and")
and
or
(sequen-
tial
\or"),
resp
ectiv
ely
.

Chapter
.
Language
extensions
	
.	
Inx
sym
b
ols
Sequences
of
\op
erator
c
haracters",
suc
h
as
<=>
or
!!,
are
read
as
a
single
tok
en
from
the
inx-sym
b
ol
or
prex-sym
b
ol
class:
inx-sym
b
ol
::=
(=
j
<
j
>
j
@
j
^
j
|
j
&
j
~
j
+
j
-
j
*
j
/
j
$
j
%)
fop
erator-c
har
g
prex-sym
b
ol
::=
(!
j
?)
fop
erator-c
har
g
op
erator-c
har
::=
!
j
$
j
%
j
&
j
*
j
+
j
-
j
.
j
/
j
:
j
;
j
<
j
=
j
>
j
?
j
@
j
^
j
|
j
~
T
ok
ens
from
these
t
w
o
classes
generalize
the
built-in
inx
and
prex
op
erators
describ
ed
in
c
hap-
ter
:
expr
::=
:
:
:
j
prex-sym
b
ol
expr
j
expr
inx-sym
b
ol
expr
v
ariable
::=
:
:
:
j
prefix
prex-sym
b
ol
j
prefix
inx-sym
b
ol
No
#infix
directiv
e
(section
.0)
is
needed
to
giv
e
inx
sym
b
ols
their
inx
status.
The
precedences
and
asso
ciativities
of
inx
sym
b
ols
in
expressions
are
determined
b
y
their
rst
c
haracter(s):
sym
b
ols
b
eginning
with
**
ha
v
e
highest
precedence
(exp
onen
tiation),
follo
w
ed
b
y
sym
b
ols
b
eginning
with
*,
/
or
%
(m
ultiplication),
then
+
and
-
(addition),
then
@
and
^
(concatenation),
then
all
others
sym
b
ols
(comparisons).
The
up
dated
precedence
table
for
expressions
is
sho
wn
b
elo
w.
W
e
write
\*:
:
:
"
to
mean
\an
y
inx
sym
b
ol
starting
with
*".

0
Construction
or
op
erator
Asso
ciativit
y
!:
:
:
?:
:
:
{
.
.(
.[
{
function
application
left
constructor
application
{
-
-.
(prex)
{
**:
:
:
righ
t
*:
:
:
/:
:
:
%:
:
:
mod
left
+:
:
:
-:
:
:
left
::
righ
t
@:
:
:
^:
:
:
righ
t
comparisons
(=
==
<
etc.),
all
other
inx
sym
b
ols
left
not
{
&
&&
left
or
||
left
,
{
<-
:=
righ
t
if
{
;
righ
t
let
match
fun
function
try
{
Some
inx
and
prex
sym
b
ols
are
predened
in
the
default
en
vironmen
t
(see
c
hapters

and

for
a
description
of
their
b
eha
vior).
The
others
are
initially
un
b
ound
and
m
ust
b
e
b
ound
b
efore
use,
with
a
let
prefix
inx-sym
b
ol
=
expr
or
let
prefix
prex-sym
b
ol
=
expr
binding.
.0
Directiv
es
In
addition
to
the
standard
#open
and
#close
directiv
es,
Caml
Ligh
t
pro
vides
three
additional
directiv
es.
#infix
"
id
"
Change
the
lexical
status
of
the
iden
tier
id
:
in
the
remainder
of
the
compilation
unit,
id
is
recognized
as
an
inx
op
erator,
just
lik
e
+.
The
notation
prefix
id
can
b
e
used
to
refer
to
the
iden
tier
id
itself.
Expressions
of
the
form
expr

id
expr

are
parsed
as
the
application
prefix
id
expr

expr

.
The
argumen
t
to
the
#infix
directiv
e
m
ust
b
e
an
iden
tier,
that
is,
a
sequence
of
letters,
digits
and
underscores
starting
with
a
letter;
otherwise,
the
#infix
declaration
has
no
eect.
Example:
#infix
"union";;
let
prefix
union
=
fun
x
y
->
...
;;
[,]
union
[,];;
#uninfix
"
id
"
Remo
v
e
the
inx
status
attac
hed
to
the
iden
tier
id
b
y
a
previous
#infix
"
id
"
directiv
e.

Chapter
.
Language
extensions

#directory
"
dir-name
"
Add
the
named
directory
to
the
path
of
directories
searc
hed
for
compiled
mo
dule
in
terface
les.
This
is
equiv
alen
t
to
the
-I
command-line
option
to
the
batc
h
compiler
and
the
toplev
el
system.



P
art
I
I
I
The
Caml
Ligh
t
commands



Chapter

Batc
h
compilati
on
(camlc)
This
c
hapter
describ
es
ho
w
Caml
Ligh
t
programs
can
b
e
compiled
non-in
teractiv
ely
,
and
turned
in
to
standalone
executable
les.
This
is
ac
hiev
ed
b
y
the
command
camlc,
whic
h
compiles
and
links
Caml
Ligh
t
source
les.
Mac:
This
command
is
not
a
standalone
Macin
tosh
application.
T
o
run
camlc,
y
ou
need
the
Macin
tosh
Programmer's
W
orkshop
(MPW)
programming
en
vironmen
t.
The
programs
generated
b
y
camlc
are
also
MPW
to
ols,
not
standalone
Macin
tosh
applications.
.
Ov
erview
of
the
compiler
The
camlc
command
has
a
command-line
in
terface
similar
to
the
one
of
most
C
compilers.
It
accepts
sev
eral
t
yp
es
of
argumen
ts:
source
les
for
mo
dule
implemen
tations;
source
les
for
mo
dule
in
terfaces;
and
compiled
mo
dule
implemen
tations.

Argumen
ts
ending
in
.mli
are
tak
en
to
b
e
source
les
for
mo
dule
in
terfaces.
Mo
dule
in
terfaces
declare
exp
orted
global
iden
tiers,
dene
public
data
t
yp
es,
and
so
on.
F
rom
the
le
x.mli,
the
camlc
compiler
pro
duces
a
compiled
in
terface
in
the
le
x.zi.

Argumen
ts
ending
in
.ml
are
tak
en
to
b
e
source
les
for
mo
dule
implemen
tation.
Mo
d-
ule
implemen
tations
bind
global
iden
tiers
to
v
alues,
dene
priv
ate
data
t
yp
es,
and
con
tain
expressions
to
b
e
ev
aluated
for
their
side-eects.
F
rom
the
le
x.ml,
the
camlc
compiler
pro
duces
compiled
ob
ject
co
de
in
the
le
x.zo.
If
the
in
terface
le
x.mli
exists,
the
mo
dule
implemen
tation
x.ml
is
c
hec
k
ed
against
the
corresp
onding
compiled
in
terface
x.zi,
whic
h
is
assumed
to
exist.
If
no
in
terface
x.mli
is
pro
vided,
the
compilation
of
x.ml
pro
duces
a
compiled
in
terface
le
x.zi
in
addition
to
the
compiled
ob
ject
co
de
le
x.zo.
The
le
x.zi
pro
duced
corresp
onds
to
an
in
terface
that
exp
orts
ev
erything
that
is
dened
in
the
imple-
men
tation
x.ml.

Argumen
ts
ending
in
.zo
are
tak
en
to
b
e
compiled
ob
ject
co
de.
These
les
are
link
ed
together,
along
with
the
ob
ject
co
de
les
obtained
b
y
compiling
.ml
argumen
ts
(if
an
y),
and
the
Caml
Ligh
t
standard
library
,
to
pro
duce
a
standalone
executable
program.
The
order
in
whic
h
.zo
and
.ml
argumen
ts
are
presen
ted
on
the
command
line
is
relev
an
t:
global
iden
tiers
are
initialized
in
that
order
at
run-time,
and
it
is
a
link-time
error
to
use
a
global
iden
tier
b
efore



ha
ving
initialized
it.
Hence,
a
giv
en
x.zo
le
m
ust
come
b
efore
all
.zo
les
that
refer
to
iden
tiers
dened
in
the
le
x.zo.
The
output
of
the
linking
phase
is
a
le
con
taining
compiled
co
de
that
can
b
e
executed
b
y
the
Caml
Ligh
t
run
time
system:
the
command
named
camlrun.
If
caml.out
is
the
name
of
the
le
pro
duced
b
y
the
linking
phase,
the
command
camlrun
caml.out
ar
g

ar
g

:
:
:
ar
g
n
executes
the
compiled
co
de
con
tained
in
caml.out,
passing
it
as
argumen
ts
the
c
haracter
strings
ar
g

to
ar
g
n
.
(See
c
hapter

for
more
details.)
Unix:
On
most
Unix
systems,
the
le
pro
duced
b
y
the
linking
phase
can
b
e
run
directly
,
as
in:
./caml.out
ar
g

ar
g

:
:
:
ar
g
n
The
pro
duced
le
has
the
executable
bit
set,
and
it
manages
to
launc
h
the
b
yteco
de
in
ter-
preter
b
y
itself.
PC:
The
output
le
pro
duced
b
y
the
linking
phase
is
directly
executable,
pro
vided
it
is
giv
en
extension
.EXE.
Hence,
if
the
output
le
is
named
caml_out.exe,
y
ou
can
execute
it
with
the
command
caml_out
ar
g

ar
g

:
:
:
ar
g
n
Actually
,
the
pro
duced
le
caml_out.exe
is
a
tin
y
executable
le
prep
ended
to
the
b
yteco
de
le.
The
executable
simply
runs
the
camlrun
run
time
system
on
the
remainder
of
the
le.
(As
a
consequence,
this
is
not
a
standalone
executable:
it
still
requires
camlrun.exe
to
reside
in
one
of
the
directories
in
the
path.)
.
Options
The
follo
wing
command-line
options
are
recognized
b
y
camlc.
-c
Compile
only
.
Suppress
the
linking
phase
of
the
compilation.
Source
co
de
les
are
turned
in
to
compiled
les,
but
no
executable
le
is
pro
duced.
This
option
is
useful
to
compile
mo
dules
separately
.
-ccopt
option
P
ass
the
giv
en
option
to
the
C
compiler
and
link
er,
when
linking
in
\custom
run
time"
mo
de
(see
the
-custom
option).
F
or
instance,
-ccopt
-Ldir
causes
the
C
link
er
to
searc
h
for
C
libraries
in
directory
dir.
-custom
Link
in
\custom
run
time"
mo
de.
In
the
default
linking
mo
de,
the
link
er
pro
duces
b
yteco
de
that
is
in
tended
to
b
e
executed
with
the
shared
run
time
system,
camlrun.
In
the
custom
run
time
mo
de,
the
link
er
pro
duces
an
output
le
that
con
tains
b
oth
the
run
time
system
and
the
b
yteco
de
for
the
program.
The
resulting
le
is
considerably
larger,
but
it
can
b
e
executed
directly
,
ev
en
if
the
camlrun
command
is
not
installed.
Moreo
v
er,
the
\custom
run
time"
mo
de
enables
linking
Caml
Ligh
t
co
de
with
user-dened
C
functions,
as
describ
ed
in
c
hapter
.

Chapter
.
Batc
h
compilation
(camlc)

Unix:
Nev
er
strip
an
executable
pro
duced
with
the
-custom
option.
PC:
This
option
requires
the
DJGPP
p
ort
of
the
GNU
C
compiler
to
b
e
installed.
-g
Cause
the
compiler
to
pro
duce
additional
debugging
information.
During
the
linking
phase,
this
option
add
information
at
the
end
of
the
executable
b
yteco
de
le
pro
duced.
This
infor-
mation
is
required
b
y
the
debugger
camldebug
and
also
b
y
the
catc
h-all
exception
handler
from
the
standard
library
mo
dule
printexc.
During
the
compilation
of
an
implemen
tation
le
(.ml
le),
when
the
-g
option
is
set,
the
compiler
adds
debugging
information
to
the
.zo
le.
It
also
writes
a
.zix
le
that
describ
es
the
full
in
terface
of
the
.ml
le,
that
is,
all
t
yp
es
and
v
alues
dened
in
the
.ml
le,
including
those
that
are
lo
cal
to
the
.ml
le
(i.e.
not
declared
in
the
.mli
in
terface
le).
Used
in
conjunction
with
the
-g
option
to
the
toplev
el
system
(c
hapter
),
the
.zix
le
giv
es
access
to
the
lo
cal
v
alues
of
the
mo
dule,
making
it
p
ossible
to
prin
t
or
\trace"
them.
The
.zix
le
is
not
pro
duced
if
the
implemen
tation
le
has
no
explicit
in
terface,
since,
in
this
case,
the
mo
dule
has
no
lo
cal
v
alues.
-i
Cause
the
compiler
to
prin
t
the
declared
t
yp
es,
exceptions,
and
global
v
ariables
(with
their
inferred
t
yp
es)
when
compiling
an
implemen
tation
(.ml
le).
This
can
b
e
useful
to
c
hec
k
the
t
yp
es
inferred
b
y
the
compiler.
Also,
since
the
output
follo
ws
the
syn
tax
of
mo
dule
in
terfaces,
it
can
help
in
writing
an
explicit
in
terface
(.mli
le)
for
a
le:
just
redirect
the
standard
output
of
the
compiler
to
a
.mli
le,
and
edit
that
le
to
remo
v
e
all
declarations
of
unexp
orted
globals.
-I
dir
e
ctory
Add
the
giv
en
directory
to
the
list
of
directories
searc
hed
for
compiled
in
terface
les
(.zi)
and
compiled
ob
ject
co
de
les
(.zo).
By
default,
the
curren
t
directory
is
searc
hed
rst,
then
the
standard
library
directory
.
Directories
added
with
-I
are
searc
hed
after
the
curren
t
directory
,
but
b
efore
the
standard
library
directory
.
When
sev
eral
directories
are
added
with
sev
eral
-I
options
on
the
command
line,
these
directories
are
searc
hed
from
righ
t
to
left
(the
righ
tmost
directory
is
searc
hed
rst,
the
leftmost
is
searc
hed
last).
(Directories
can
also
b
e
added
to
the
searc
h
path
from
inside
the
programs
with
the
#directory
directiv
e;
see
c
hapter
.)
-lang
language-c
o
de
T
ranslate
the
compiler
messages
to
the
sp
ecied
language.
The
language-c
o
de
is
fr
for
F
renc
h,
es
for
Spanish,
de
for
German,
:
:
:
(See
the
le
camlmsgs.txt
in
the
Caml
Ligh
t
standard
library
directory
for
a
list
of
a
v
ailable
languages.)
When
an
unkno
wn
language
is
sp
ecied,
or
no
translation
is
a
v
ailable
for
a
message,
American
English
is
used
b
y
default.
-o
exe
c-le
Sp
ecify
the
name
of
the
output
le
pro
duced
b
y
the
link
er.
Unix:
The
default
output
name
is
a.out,
in
k
eeping
with
the
tradition.
PC:
The
default
output
name
is
caml_out.exe.
Mac:
The
default
output
name
is
Caml.Out.


-O
mo
dule-set
Sp
ecify
whic
h
set
of
standard
mo
dules
is
to
b
e
implicitly
\op
ened"
at
the
b
eginning
of
a
compilation.
There
are
three
mo
dule
sets
curren
tly
a
v
ailable:
cautious
pro
vides
the
standard
op
erations
on
in
tegers,
oating-p
oin
t
n
um
b
ers,
c
haracters,
strings,
arra
ys,
:
:
:
,
as
w
ell
as
exception
handling,
basic
input/output,
etc.
Op
erations
from
the
cautious
set
p
erform
range
and
b
ound
c
hec
king
on
string
and
arra
y
op
erations,
as
w
ell
as
v
arious
sanit
y
c
hec
ks
on
their
argumen
ts.
fast
pro
vides
the
same
op
erations
as
the
cautious
set,
but
without
sanit
y
c
hec
ks
on
their
argumen
ts.
Programs
compiled
with
-O
fast
are
therefore
sligh
tly
faster,
but
unsafe.
none
suppresses
all
automatic
op
ening
of
mo
dules.
Compilation
starts
in
an
almost
empt
y
en
vironmen
t.
This
option
is
not
of
general
use,
except
to
compile
the
standard
library
itself.
The
default
compilation
mo
de
is
-O
cautious.
See
c
hapter

for
a
complete
listing
of
the
mo
dules
in
the
cautious
and
fast
sets.
-p
Compile
and
link
in
proling
mo
de.
See
the
description
of
the
proler
camlpro
in
c
hapter
0.
-v
Prin
t
the
v
ersion
n
um
b
er
of
the
compiler.
-W
Prin
t
extra
w
arning
messages
for
the
follo
wing
ev
en
ts:

A
#open
directiv
e
is
useless
(no
iden
tier
in
the
op
ened
mo
dule
is
ev
er
referenced).

A
v
ariable
name
in
a
pattern
matc
hing
is
capitalized
(often
corresp
onds
to
a
missp
elled
constan
t
constructor).
Unix:
The
follo
wing
en
vironmen
t
v
ariable
is
also
consulted:
LANG
When
set,
con
trol
whic
h
language
is
used
to
prin
t
the
compiler
messages
(see
the
-lang
command-line
option).
PC:
The
follo
wing
option
is
also
supp
orted:
@r
esp
onse-le
Pro
cess
the
les
whose
names
are
listed
in
le
r
esp
onse-le,
just
as
if
these
names
app
eared
on
the
command
line.
File
names
in
r
esp
onse-le
are
separated
b
y
blanks
(spaces,
tabs,
newlines).
This
option
allo
ws
to
o
v
ercome
silly
limitations
on
the
length
of
the
command
line.
The
follo
wing
en
vironmen
t
v
ariables
are
also
consulted:
CAMLLIB
Con
tain
the
path
to
the
standard
library
directory
.

Chapter
.
Batc
h
compilation
(camlc)
	
LANG
When
set,
con
trol
whic
h
language
is
used
to
prin
t
the
compiler
messages
(see
the
-lang
command-line
option).
.
Mo
dules
and
the
le
system
This
short
section
is
in
tended
to
clarify
the
relationship
b
et
w
een
the
names
of
the
mo
dules
and
the
names
of
the
les
that
con
tain
their
compiled
in
terface
and
compiled
implemen
tation.
The
compiler
alw
a
ys
deriv
es
the
name
of
the
compiled
mo
dule
b
y
taking
the
base
name
of
the
source
le
(.ml
or
.mli
le).
That
is,
it
strips
the
leading
directory
name,
if
an
y
,
as
w
ell
as
the
.ml
or
.mli
sux.
The
pro
duced
.zi
and
.zo
les
ha
v
e
the
same
base
name
as
the
source
le;
hence,
the
compiled
les
pro
duced
b
y
the
compiler
alw
a
ys
ha
v
e
their
base
name
equal
to
the
name
of
the
mo
dule
they
describ
e
(for
.zi
les)
or
implemen
t
(for
.zo
les).
F
or
compiled
in
terface
les
(.zi
les),
this
in
v
arian
t
m
ust
b
e
preserv
ed
at
all
times,
since
the
compiler
relies
on
it
to
load
the
compiled
in
terface
le
for
the
mo
dules
that
are
used
from
the
mo
dule
b
eing
compiled.
Hence,
it
is
risky
and
generally
incorrect
to
rename
.zi
les.
It
is
admissible
to
mo
v
e
them
to
another
directory
,
if
their
base
name
is
preserv
ed,
and
the
correct
-I
options
are
giv
en
to
the
compiler.
Compiled
b
yteco
de
les
(.zo
les),
on
the
other
hand,
can
b
e
freely
renamed
once
created.
That's
b
ecause
-
.zo
les
con
tain
the
true
name
of
the
mo
dule
they
dene,
so
there
is
no
need
to
deriv
e
that
name
from
the
le
name;
-
the
link
er
nev
er
attempts
to
nd
b
y
itself
the
.zo
le
that
implemen
ts
a
mo
dule
of
a
giv
en
name:
it
relies
on
the
user
pro
viding
the
list
of
.zo
les
b
y
hand.
.
Common
errors
This
section
describ
es
and
explains
the
most
frequen
tly
encoun
tered
error
messages.
Cannot
nd
le
lename
The
named
le
could
not
b
e
found
in
the
curren
t
directory
,
nor
in
the
directories
of
the
searc
h
path.
The
lename
is
either
a
compiled
in
terface
le
(.zi
le),
or
a
compiled
b
yteco
de
le
(.zo
le).
If
lename
has
the
format
mo
d.zi,
this
means
y
ou
are
trying
to
compile
a
le
that
references
iden
tiers
from
mo
dule
mo
d,
but
y
ou
ha
v
e
not
y
et
compiled
an
in
terface
for
mo
dule
mo
d.
Fix:
compile
mo
d.mli
or
mo
d.ml
rst,
to
create
the
compiled
in
terface
mo
d.zi.
If
lename
has
the
format
mo
d.zo,
this
means
y
ou
are
trying
to
link
a
b
yteco
de
ob
ject
le
that
do
es
not
exist
y
et.
Fix:
compile
mo
d.ml
rst.
If
y
our
program
spans
sev
eral
directories,
this
error
can
also
app
ear
b
ecause
y
ou
ha
v
en't
sp
ecied
the
directories
to
lo
ok
in
to.
Fix:
add
the
correct
-I
options
to
the
command
line.
Corrupted
compiled
in
terface
le
lename
The
compiler
pro
duces
this
error
when
it
tries
to
read
a
compiled
in
terface
le
(.zi
le)
that
has
the
wrong
structure.
This
means
something
w
en
t
wrong
when
this
.zi
le
w
as
written:
the
disk
w
as
full,
the
compiler
w
as
in
terrupted
in
the
middle
of
the
le
creation,
and
so
on.
This
error
can
also
app
ear
if
a
.zi
le
is
mo
died
after
its
creation
b
y
the
compiler.
Fix:
remo
v
e
the
corrupted
.zi
le,
and
rebuild
it.

0
This
expression
has
t
yp
e
t

,
but
is
used
with
t
yp
e
t

This
is
b
y
far
the
most
common
t
yp
e
error
in
programs.
T
yp
e
t

is
the
t
yp
e
inferred
for
the
expression
(the
part
of
the
program
that
is
displa
y
ed
in
the
error
message),
b
y
lo
oking
at
the
expression
itself.
T
yp
e
t

is
the
t
yp
e
exp
ected
b
y
the
con
text
of
the
expression;
it
is
deduced
b
y
lo
oking
at
ho
w
the
v
alue
of
this
expression
is
used
in
the
rest
of
the
program.
If
the
t
w
o
t
yp
es
t

and
t

are
not
compatible,
then
the
error
ab
o
v
e
is
pro
duced.
In
some
cases,
it
is
hard
to
understand
wh
y
the
t
w
o
t
yp
es
t

and
t

are
incompatible.
F
or
instance,
the
compiler
can
rep
ort
that
\expression
of
t
yp
e
foo
cannot
b
e
used
with
t
yp
e
foo",
and
it
really
seems
that
the
t
w
o
t
yp
es
foo
are
compatible.
This
is
not
alw
a
ys
true.
Tw
o
t
yp
e
constructors
can
ha
v
e
the
same
name,
but
actually
represen
t
dieren
t
t
yp
es.
This
can
happ
en
if
a
t
yp
e
constructor
is
redened.
Example:
type
foo
=
A
|
B;;
let
f
=
function
A
->
0
|
B
->
;;
type
foo
=
C
|
D;;
f
C;;
This
result
in
the
error
message
\expression
C
of
t
yp
e
foo
cannot
b
e
used
with
t
yp
e
foo".
Incompatible
t
yp
es
with
the
same
names
can
also
app
ear
when
a
mo
dule
is
c
hanged
and
recompiled,
but
some
of
its
clien
ts
are
not
recompiled.
That's
b
ecause
t
yp
e
constructors
in
.zi
les
are
not
represen
ted
b
y
their
name
(that
w
ould
not
suce
to
iden
tify
them,
b
ecause
of
t
yp
e
redenitions),
but
b
y
unique
stamps
that
are
assigned
when
the
t
yp
e
declaration
is
compiled.
Consider
the
three
mo
dules:
mod.ml:
type
t
=
A
|
B;;
let
f
=
function
A
->
0
|
B
->
;;
mod.ml:
let
g
x
=

+
mod__f(x);;
mod.ml:
mod__g
mod__A;;
No
w,
assume
mod.ml
is
c
hanged
and
recompiled,
but
mod.ml
is
not
recompiled.
The
recom-
pilation
of
mod.ml
can
c
hange
the
stamp
assigned
to
t
yp
e
t.
But
the
in
terface
mod.zi
will
still
use
the
old
stamp
for
mod__t
in
the
t
yp
e
of
mod__g.
Hence,
when
compiling
mod.ml,
the
system
complains
that
the
argumen
t
t
yp
e
of
mod__g
(that
is,
mod__t
with
the
old
stamp)
is
not
compatible
with
the
t
yp
e
of
mod__A
(that
is,
mod__t
with
the
new
stamp).
Fix:
use
make
or
a
similar
to
ol
to
ensure
that
all
clien
ts
of
a
mo
dule
mo
d
are
recompiled
when
the
in
terface
mo
d.zi
c
hanges.
T
o
c
hec
k
that
the
Makefile
con
tains
the
righ
t
dep
endencies,
remo
v
e
all
.zi
les
and
rebuild
the
whole
program;
if
no
\Cannot
nd
le"
error
app
ears,
y
ou're
all
set.
The
t
yp
e
inferred
for
name,
that
is,
t,
con
tains
non-generalizable
t
yp
e
v
ariables
T
yp
e
v
ariables
('a,
'b,
:
:
:
)
in
a
t
yp
e
t
can
b
e
in
either
of
t
w
o
states:
generalized
(whic
h
means
that
the
t
yp
e
t
is
v
alid
for
all
p
ossible
instan
tiations
of
the
v
ariables)
and
not
gener-
alized
(whic
h
means
that
the
t
yp
e
t
is
v
alid
only
for
one
instan
tiation
of
the
v
ariables).
In
a

Chapter
.
Batc
h
compilation
(camlc)

let
binding
let
name
=
expr,
the
t
yp
e-c
hec
k
er
normally
generalizes
as
man
y
t
yp
e
v
ariables
as
p
ossible
in
the
t
yp
e
of
expr.
Ho
w
ev
er,
this
leads
to
unsoundness
(a
w
ell-t
yp
ed
program
can
crash)
in
conjunction
with
p
olymorphic
m
utable
data
structures.
T
o
a
v
oid
this,
general-
ization
is
p
erformed
at
let
bindings
only
if
the
b
ound
expression
expr
b
elongs
to
the
class
of
\syn
tactic
v
alues",
whic
h
includes
constan
ts,
iden
tiers,
functions,
tuples
of
syn
tactic
v
alues,
etc.
In
all
other
cases
(for
instance,
expr
is
a
function
application),
a
p
olymorphic
m
utable
could
ha
v
e
b
een
created
and
generalization
is
therefore
turned
o.
Non-generalized
t
yp
e
v
ariables
in
a
t
yp
e
cause
no
diculties
inside
a
giv
en
compilation
unit
(the
con
ten
ts
of
a
.ml
le,
or
an
in
teractiv
e
session),
but
they
cannot
b
e
allo
w
ed
in
t
yp
es
written
in
a
.zi
compiled
in
terface
le,
b
ecause
they
could
b
e
used
inconsisten
tly
in
other
compilation
units.
Therefore,
the
compiler
ags
an
error
when
a
.ml
implemen
tation
without
a
.mli
in
terface
denes
a
global
v
ariable
name
whose
t
yp
e
con
tains
non-generalized
t
yp
e
v
ariables.
There
are
t
w
o
solutions
to
this
problem:

Add
a
t
yp
e
constrain
t
or
a
.mli
in
terface
to
giv
e
a
monomorphic
t
yp
e
(without
t
yp
e
v
ariables)
to
name.
F
or
instance,
instead
of
writing
let
sort_int_list
=
sort
(prefix
<);;
(*
inferred
type
'a
list
->
'a
list,
with
'a
not
generalized
*)
write
let
sort_int_list
=
(sort
(prefix
<)
:
int
list
->
int
list);;

If
y
ou
really
need
name
to
ha
v
e
a
p
olymorphic
t
yp
e,
turn
its
dening
expression
in
to
a
function
b
y
adding
an
extra
parameter.
F
or
instance,
instead
of
writing
let
map_length
=
map
vect_length;;
(*
inferred
type
'a
vect
list
->
int
list,
with
'a
not
generalized
*)
write
let
map_length
lv
=
map
vect_length
lv;;
mo
d__name
is
referenced
b
efore
b
eing
dened
This
error
app
ears
when
trying
to
link
an
incomplete
or
incorrectly
ordered
set
of
les.
Either
y
ou
ha
v
e
forgotten
to
pro
vide
an
implemen
tation
for
the
mo
dule
named
mo
d
on
the
command
line
(t
ypically
,
the
le
named
mo
d.zo,
or
a
library
con
taining
that
le).
Fix:
add
the
missing
.ml
or
.zo
le
to
the
command
line.
Or,
y
ou
ha
v
e
pro
vided
an
implemen
tation
for
the
mo
dule
named
mo
d,
but
it
comes
to
o
late
on
the
command
line:
the
implemen
tation
of
mo
d
m
ust
come
b
efore
all
b
yteco
de
ob
ject
les
that
reference
one
of
the
global
v
ariables
dened
in
mo
dule
mo
d.
Fix:
c
hange
the
order
of
.ml
and
.zo
les
on
the
command
line.
Of
course,
y
ou
will
alw
a
ys
encoun
ter
this
error
if
y
ou
ha
v
e
m
utually
recursiv
e
functions
across
mo
dules.
That
is,
function
mod__f
calls
function
mod__g,
and
function
mod__g
calls
function
mod__f.
In
this
case,
no
matter
what
p
erm
utations
y
ou
p
erform
on
the
command
line,
the
program
will
b
e
rejected
at
link-time.
Fixes:

Put
f
and
g
in
the
same
mo
dule.

P
arameterize
one
function
b
y
the
other.
That
is,
instead
of
ha
ving


mod.ml:
let
f
x
=
...
mod__g
...
;;
mod.ml:
let
g
y
=
...
mod__f
...
;;
dene
mod.ml:
let
f
g
x
=
...
g
...
;;
mod.ml:
let
rec
g
y
=
...
mod__f
g
...
;;
and
link
mod
b
efore
mod.

Use
a
reference
to
hold
one
of
the
t
w
o
functions,
as
in
:
mod.ml:
let
forward_g
=
ref((fun
x
->
failwith
"forward_g")
:
<type>);;
let
f
x
=
...
!forward_g
...
;;
mod.ml:
let
g
y
=
...
mod__f
...
;;
mod__forward_g
:=
g;;
Una
v
ailable
C
primitiv
e
f
This
error
app
ears
when
trying
to
link
co
de
that
calls
external
functions
written
in
C
in
\default
run
time"
mo
de.
As
explained
in
c
hapter
,
suc
h
co
de
m
ust
b
e
link
ed
in
\custom
run
time"
mo
de.
Fix:
add
the
-custom
option,
as
w
ell
as
the
(nativ
e
co
de)
libraries
and
(nativ
e
co
de)
ob
ject
les
that
implemen
t
the
required
external
functions.

Chapter

The
toplev
el
system
(camlligh
t)
This
c
hapter
describ
es
the
toplev
el
system
for
Caml
Ligh
t,
that
p
ermits
in
teractiv
e
use
of
the
Caml
Ligh
t
system,
through
a
read-ev
al-prin
t
lo
op.
In
this
mo
de,
the
system
rep
eatedly
reads
Caml
Ligh
t
phrases
from
the
input,
then
t
yp
ec
hec
ks,
compile
and
ev
aluate
them,
then
prin
ts
the
inferred
t
yp
e
and
result
v
alue,
if
an
y
.
The
system
prin
ts
a
#
(sharp)
prompt
b
efore
reading
eac
h
phrase.
A
phrase
can
span
sev
eral
lines.
Phrases
are
delimited
b
y
;;
(the
nal
double-semicolon).
F
rom
the
standp
oin
t
of
the
mo
dule
system,
all
phrases
en
tered
at
toplev
el
are
treated
as
the
implemen
tation
of
a
mo
dule
named
top.
Hence,
all
toplev
el
denitions
are
en
tered
in
the
mo
dule
top.
Unix:
The
toplev
el
system
is
started
b
y
the
command
camllight.
Phrases
are
read
on
standard
input,
results
are
prin
ted
on
standard
output,
errors
on
standard
error.
End-of-le
on
standard
input
terminates
camllight
(see
also
the
quit
system
function
b
elo
w).
The
toplev
el
system
do
es
not
p
erform
line
editing,
but
it
can
easily
b
e
used
in
conjunction
with
an
external
line
editor
suc
h
as
fep;
just
run
fep
-emacs
camllight
or
fep
-vi
camllight.
Another
option
is
to
use
camllight
under
Gn
u
Emacs,
whic
h
giv
es
the
full
editing
p
o
w
er
of
Emacs
(see
the
directory
contrib/camlmode
in
the
distribution).
A
t
an
y
p
oin
t,
the
parsing,
compilation
or
ev
aluation
of
the
curren
t
phrase
can
b
e
in
ter-
rupted
b
y
pressing
ctrl-C
(or,
more
precisely
,
b
y
sending
the
intr
signal
to
the
camllight
pro
cess).
This
go
es
bac
k
to
the
#
prompt.
Mac:
The
toplev
el
system
is
presen
ted
as
the
standalone
Macin
tosh
application
Caml
Light.
This
application
do
es
not
require
the
Macin
tosh
Programmer's
W
orkshop
to
run.
Once
launc
hed
from
the
Finder,
the
application
op
ens
t
w
o
windo
ws,
\Caml
Ligh
t
Input"
and
\Caml
Ligh
t
Output".
Phrases
are
en
tered
in
the
\Caml
Ligh
t
Input"
windo
w.
The
\Caml
Ligh
t
Output"
windo
w
displa
ys
a
cop
y
of
the
input
phrases
as
they
are
pro
cessed
b
y
the
Caml
Ligh
t
toplev
el,
in
tersp
ersed
with
the
toplev
el
resp
onses.
The
\Return"
k
ey
sends
the
con
ten
ts
of
the
Input
windo
w
to
the
Caml
Ligh
t
toplev
el.
The
\En
ter"
k
ey
inserts
a
newline
without
sending
the
con
ten
ts
of
the
Input
windo
w.
(This
can
b
e
congured
with
the
\Preferences"
men
u
item.)
The
con
ten
ts
of
the
input
windo
w
can
b
e
edited
at
all
times,
with
the
standard
Macin
tosh
in
terface.
An
history
of
previously
en
tered
phrases
is
main
tained,
and
can
b
e
accessed
with
the
\Previous
en
try"
(command-P)
and
\Next
en
try"
(command-N)
men
u
items.



T
o
quit
the
Caml
Light
application,
either
select
\Quit"
from
the
\Files"
men
u,
or
use
the
quit
function
describ
ed
b
elo
w.
A
t
an
y
p
oin
t,
the
parsing,
compilation
or
ev
aluation
of
the
curren
t
phrase
can
b
e
in
terrupted
b
y
pressing
\command-p
erio
d",
or
b
y
selecting
the
item
\In
terrupt
Caml
Ligh
t"
in
the
\Caml
Ligh
t"
men
u.
This
go
es
bac
k
to
the
#
prompt.
PC:
The
toplev
el
system
is
presen
ted
as
a
Windo
ws
application
named
Camlwin.exe.
It
should
b
e
launc
hed
from
the
Windo
ws
le
manager
or
program
manager.
The
\T
erminal"
windo
ws
is
split
in
t
w
o
panes.
Phrases
are
en
tered
and
edited
in
the
b
ottom
pane.
The
top
pane
displa
ys
a
cop
y
of
the
input
phrases
as
they
are
pro
cessed
b
y
the
Caml
Ligh
t
toplev
el,
in
tersp
ersed
with
the
toplev
el
resp
onses.
The
\Return"
k
ey
sends
the
con
ten
ts
of
the
b
ottom
pane
to
the
Caml
Ligh
t
toplev
el.
The
\En
ter"
k
ey
inserts
a
newline
without
sending
the
con
ten
ts
of
the
Input
windo
w.
(This
can
b
e
congured
with
the
\Preferences"
men
u
item.)
The
con
ten
ts
of
the
input
windo
w
can
b
e
edited
at
all
times,
with
the
standard
Windo
ws
in
terface.
An
history
of
previously
en
tered
phrases
is
main
tained
and
displa
y
ed
in
a
separate
windo
w.
T
o
quit
the
Camlwin
application,
either
select
\Quit"
from
the
\File"
men
u,
or
use
the
quit
function
describ
ed
b
elo
w.
A
t
an
y
p
oin
t,
the
parsing,
compilation
or
ev
aluation
of
the
curren
t
phrase
can
b
e
in
terrupted
b
y
selecting
the
\In
terrupt
Caml
Ligh
t"
men
u
item.
This
go
es
bac
k
to
the
#
prompt.
A
text-only
v
ersion
of
the
toplev
el
system
is
a
v
ailable
under
the
name
caml.exe.
It
runs
under
MSDOS
as
w
ell
as
under
Windo
ws
in
a
DOS
windo
w.
No
editing
facilities
are
pro
vided.
.
Options
The
follo
wing
command-line
options
are
recognized
b
y
the
caml
or
camllight
commands.
-g
Start
the
toplev
el
system
in
debugging
mo
de.
This
mo
de
giv
es
access
to
v
alues
and
t
yp
es
that
are
lo
cal
to
a
mo
dule,
that
is,
not
exp
orted
b
y
the
in
terface
of
the
mo
dule.
When
debugging
mo
de
is
o,
these
lo
cal
ob
jects
are
not
accessible
(attempts
to
access
them
pro
duce
an
\Un
b
ound
iden
tier"
error).
When
debugging
mo
de
is
on,
these
ob
jects
b
ecome
visible,
just
lik
e
the
ob
jects
that
are
exp
orted
in
the
mo
dule
in
terface.
In
particular,
v
alues
of
abstract
t
yp
es
are
prin
ted
using
their
concrete
represen
tations,
and
the
functions
lo
cal
to
a
mo
dule
can
b
e
\traced"
(see
the
trace
function
in
section
.).
This
applies
only
to
the
mo
dules
that
ha
v
e
b
een
compiled
in
debugging
mo
de
(either
b
y
the
batc
h
compiler
with
the
-g
option,
or
b
y
the
toplev
el
system
in
debugging
mo
de),
that
is,
those
mo
dules
that
ha
v
e
an
asso
ciated
.zix
le.
-I
dir
e
ctory
Add
the
giv
en
directory
to
the
list
of
directories
searc
hed
for
compiled
in
terface
les
(.zi)
and
compiled
ob
ject
co
de
les
(.zo).
By
default,
the
curren
t
directory
is
searc
hed
rst,
then
the
standard
library
directory
.
Directories
added
with
-I
are
searc
hed
after
the
curren
t
directory
,

Chapter
.
The
toplev
el
system
(camlligh
t)

but
b
efore
the
standard
library
directory
.
When
sev
eral
directories
are
added
with
sev
eral
-I
options
on
the
command
line,
these
directories
are
searc
hed
from
righ
t
to
left
(the
righ
tmost
directory
is
searc
hed
rst,
the
leftmost
is
searc
hed
last).
Directories
can
also
b
e
added
to
the
searc
h
path
once
the
toplev
el
is
running
with
the
#directory
directiv
e;
see
c
hapter
.
-lang
language-c
o
de
T
ranslate
the
toplev
el
messages
to
the
sp
ecied
language.
The
language-c
o
de
is
fr
for
F
renc
h,
es
for
Spanish,
de
for
German,
:
:
:
(See
the
le
camlmsgs.txt
in
the
Caml
Ligh
t
standard
library
directory
for
a
list
of
a
v
ailable
languages.)
When
an
unkno
wn
language
is
sp
ecied,
or
no
translation
is
a
v
ailable
for
a
message,
American
English
is
used
b
y
default.
-O
mo
dule-set
Sp
ecify
whic
h
set
of
standard
mo
dules
is
to
b
e
implicitl
y
\op
ened"
when
the
toplev
el
starts.
There
are
three
mo
dule
sets
curren
tly
a
v
ailable:
cautious
pro
vides
the
standard
op
erations
on
in
tegers,
oating-p
oin
t
n
um
b
ers,
c
haracters,
strings,
arra
ys,
:
:
:
,
as
w
ell
as
exception
handling,
basic
input/output,
:
:
:
Op
erations
from
the
cautious
set
p
erform
range
and
b
ound
c
hec
king
on
string
and
v
ector
op
erations,
as
w
ell
as
v
arious
sanit
y
c
hec
ks
on
their
argumen
ts.
fast
pro
vides
the
same
op
erations
as
the
cautious
set,
but
without
sanit
y
c
hec
ks
on
their
argumen
ts.
Programs
compiled
with
-O
fast
are
therefore
sligh
tly
faster,
but
unsafe.
none
suppresses
all
automatic
op
ening
of
mo
dules.
Compilation
starts
in
an
almost
empt
y
en
vironmen
t.
This
option
is
not
of
general
use.
The
default
compilation
mo
de
is
-O
cautious.
See
c
hapter

for
a
complete
listing
of
the
mo
dules
in
the
cautious
and
fast
sets.
Unix:
The
follo
wing
en
vironmen
t
v
ariables
are
also
consulted:
LANG
When
set,
con
trol
whic
h
language
is
used
to
prin
t
the
compiler
messages
(see
the
-lang
command-line
option).
LC_CTYPE
If
set
to
iso_	_,
accen
ted
c
haracters
(from
the
ISO
Latin-
c
haracter
set)
in
string
and
c
haracter
literals
are
prin
ted
as
is;
otherwise,
they
are
prin
ted
as
decimal
escap
e
sequences
(\ddd).
.
T
oplev
el
con
trol
functions
The
standard
library
mo
dule
toplevel,
op
ened
b
y
default
when
the
toplev
el
system
is
launc
hed,
pro
vides
a
n
um
b
er
of
functions
that
con
trol
the
toplev
el
b
eha
vior,
load
les
in
memory
,
and
trace
program
execution.


value
quit
:
unit
->
unit
Exit
the
toplev
el
lo
op
and
terminate
the
camllight
command.
value
include
:
string
->
unit
Read,
compile
and
execute
source
phrases
from
the
giv
en
le.
The
.ml
extension
is
automatically
added
to
the
le
name,
if
not
presen
t.
This
is
textual
inclusion:
phrases
are
pro
cessed
just
as
if
they
w
ere
t
yp
ed
on
standard
input.
In
particular,
global
iden
tiers
dened
b
y
these
phrases
are
en
tered
in
the
mo
dule
named
top,
not
in
a
new
mo
dule.
value
load
:
string
->
unit
Load
in
memory
the
source
co
de
for
a
mo
dule
implemen
tation.
Read,
compile
and
execute
source
phrases
from
the
giv
en
le.
The
.ml
extension
is
automatically
added
if
not
presen
t.
The
load
function
b
eha
v
es
m
uc
h
lik
e
include,
except
that
a
new
mo
dule
is
created,
with
name
the
base
name
of
the
source
le
name.
Global
iden
tiers
dened
in
the
source
le
are
en
tered
in
this
mo
dule,
instead
of
the
top
mo
dule
as
in
the
case
of
include.
F
or
instance,
assuming
le
foo.ml
con
tains
the
single
phrase
let
bar
=
;;
executing
load
"foo"
denes
the
iden
tier
foo__bar
with
v
alue
.
Ca
v
eat:
the
loaded
mo
dule
is
not
automatically
op
ened:
the
iden
tier
bar
do
es
not
automatically
complete
to
foo__bar.
T
o
ac
hiev
e
this,
y
ou
m
ust
execute
the
directiv
e
#open
"foo"
afterw
ards.
value
compile
:
string
->
unit
Compile
the
source
co
de
for
a
mo
dule
implemen
tation
or
in
terface
(.ml
or
.mli
le).
Compilation
pro
ceeds
as
with
the
batc
h
compiler,
and
pro
duces
the
same
results
as
camlc
-c.
If
the
toplev
el
system
is
in
debugging
mo
de
(option
-g
or
function
debug_mode
b
elo
w),
the
compilation
is
also
p
erformed
in
debugging
mo
de,
as
when
giving
the
-g
option
to
the
batc
h
compiler.
The
result
of
the
compilation
is
left
in
les
(.zo,
.zi,
.zix).
The
compiled
co
de
is
not
loaded
in
memory
.
Use
load_object
to
load
a
.zo
le
pro
duced
b
y
compile.
value
load_object
:
string
->
unit
Load
in
memory
the
compiled
b
yteco
de
con
tained
in
the
giv
en
le.
The
.zo
extension
is
automatically
added
to
the
le
name,
if
not
presen
t.
The
b
yteco
de
le
has
b
een
pro
duced
either
b
y
the
standalone
compiler
camlc
or
b
y
the
compile
function.
Global
iden
tiers
dened
in
the
le
b
eing
loaded
are
en
tered
in
their
o
wn
mo
dule,
not
in
the
top
mo
dule,
just
as
with
the
load
function.
value
trace
:
string
->
unit
After
the
execution
of
trace
"foo",
all
calls
to
the
global
function
named
foo
will
b
e
\traced".
That
is,
the
argumen
t
and
the
result
are
displa
y
ed
for
eac
h
call,
as
w
ell
as
the
exceptions
escaping
out
of
foo,
either
raised
b
y
foo
itself,
or
raised
b
y
one
of
the
functions
called
from
foo.
If
foo
is
a
curried
function,
eac
h
argumen
t
is
prin
ted
as
it
is
passed
to
the
function.
Only
functions
implemen
ted
in
ML
can
b
e
traced;
system
primitiv
es
suc
h
as
string_length
or
user-supplied
C
functions
cannot.

Chapter
.
The
toplev
el
system
(camlligh
t)

value
untrace
:
string
->
unit
Executing
untrace
"foo"
stops
all
tracing
o
v
er
the
global
function
named
foo.
value
verbose_mode:
bool
->
unit
verbose_mode
true
causes
the
compile
function
to
prin
t
the
inferred
t
yp
es
and
other
information.
verbose_mode
false
rev
erts
to
the
default
silen
t
b
eha
vior.
value
install_printer
:
string
->
unit
install_printer
"printername"
registers
the
function
named
printername
as
a
prin
ter
for
ob
jects
whose
t
yp
es
matc
h
its
argumen
t
t
yp
e.
That
is,
the
toplev
el
lo
op
will
call
printername
when
it
has
suc
h
an
ob
ject
to
prin
t.
The
prin
ting
function
printername
m
ust
use
the
format
library
mo
dule
to
pro
duce
its
output,
otherwise
the
output
of
printername
will
not
b
e
correctly
lo
cated
in
the
v
alues
prin
ted
b
y
the
toplev
el
lo
op.
value
remove_printer
:
string
->
unit
remove_printer
"printername"
remo
v
es
the
function
named
printername
from
the
table
of
toplev
el
prin
ters.
value
set_print_depth
:
int
->
unit
set_print_depth
n
limits
the
prin
ting
of
v
alues
to
a
maximal
depth
of
n.
The
parts
of
v
alues
whose
depth
exceeds
n
are
prin
ted
as
...
(ellipsis).
value
set_print_length
:
int
->
unit
set_print_length
n
limits
the
n
um
b
er
of
v
alue
no
des
prin
ted
to
at
most
n.
Remaining
parts
of
v
alues
are
prin
ted
as
...
(ellipsis).
value
debug_mode:
bool
->
unit
Set
whether
extended
mo
dule
in
terfaces
m
ust
b
e
used
debug_mode
true
or
not
debug_mode
false.
Extended
mo
dule
in
terfaces
are
.zix
les
that
describ
e
the
actual
implemen
tation
of
a
mo
dule,
including
priv
ate
t
yp
es
and
v
ariables.
They
are
generated
when
compiling
with
camlc
-g,
or
with
the
compile
function
ab
o
v
e
when
debug_mode
is
true.
When
debug_mode
is
true,
toplev
el
phrases
can
refer
to
priv
ate
t
yp
es
and
v
ariables
of
mo
dules,
and
priv
ate
functions
can
b
e
traced
with
trace.
Setting
debug_mode
true
is
equiv
alen
t
to
starting
the
toplev
el
with
the
-g
option.
value
cd
:
string
->
unit
Change
the
curren
t
w
orking
directory
.
value
directory
:
string
->
unit
Add
the
giv
en
directory
to
the
searc
h
path
for
les.
Same
b
eha
vior
as
the
-I
option
or
the
#directory
directiv
e.


.
The
toplev
el
and
the
mo
dule
system
T
oplev
el
phrases
can
refer
to
iden
tiers
dened
in
mo
dules
other
than
the
top
mo
dule
with
the
same
mec
hanisms
as
for
separately
compiled
mo
dules:
either
b
y
using
qualied
iden
tiers
(modulename__localname)
,
or
b
y
using
unqualied
iden
tiers
that
are
automatically
completed
b
y
searc
hing
the
list
of
op
ened
mo
dules.
(See
section
..)
The
mo
dules
op
ened
at
startup
are
giv
en
in
the
do
cumen
tation
for
the
standard
library
.
Other
mo
dules
can
b
e
op
ened
with
the
#open
directiv
e.
Ho
w
ev
er,
b
efore
referencing
a
global
v
ariable
from
a
mo
dule
other
than
the
top
mo
dule,
a
denition
of
that
global
v
ariable
m
ust
ha
v
e
b
een
en
tered
in
memory
.
A
t
start-up,
the
toplev
el
system
con
tains
the
denitions
for
all
the
iden
tiers
in
the
standard
library
.
The
denitions
for
user
mo
dules
can
b
e
en
tered
with
the
load
or
load_object
functions
describ
ed
ab
o
v
e.
Referencing
a
global
v
ariable
for
whic
h
no
denition
has
b
een
pro
vided
b
y
load
or
load_object
results
in
the
error
\Identifier
foo_
_bar
is
referenced
before
being
defined".
Since
this
is
a
tric
ky
p
oin
t,
let
us
consider
some
examples.
.
The
library
function
sub_string
is
dened
in
mo
dule
string.
This
mo
dule
is
part
of
the
standard
library
,
and
is
one
of
the
mo
dules
automatically
op
ened
at
start-up.
Hence,
b
oth
phrases
sub_string
"qwerty"

;;
string__sub_string
"qwerty"

;;
are
correct,
without
ha
ving
to
use
#open,
load,
or
load_object.
.
The
library
function
printf
is
dened
in
mo
dule
printf.
This
mo
dule
is
part
of
the
standard
library
,
but
it
is
not
automatically
op
ened
at
start-up.
Hence,
the
phrase
printf__printf
"%s
%s"
"hello"
"world";;
is
correctly
executed,
while
printf
"%s
%s"
"hello"
"world";;
causes
the
error
\Variable
printf
is
unbound",
since
none
of
the
curren
tly
op
ened
mo
d-
ules
dene
a
global
with
lo
cal
name
printf.
Ho
w
ev
er,
#open
"printf";;
printf
"%s
%s"
"hello"
"world";;
executes
correctly
.
.
Assume
the
le
foo.ml
resides
in
the
curren
t
directory
,
and
con
tains
the
single
phrase
let
x
=
;;

Chapter
.
The
toplev
el
system
(camlligh
t)
	
When
the
toplev
el
starts,
references
to
x
will
cause
the
error
\Variable
x
is
unbound".
References
to
foo__x
will
cause
the
error
\Cannot
find
file
foo.zi",
since
the
t
yp
ec
hec
k
er
is
attempting
to
load
the
compiled
in
terface
for
mo
dule
foo
in
order
to
nd
the
t
yp
e
of
x.
T
o
load
in
memory
the
mo
dule
foo,
just
do:
load
"foo";;
Then,
references
to
foo__x
t
yp
ec
hec
k
and
ev
aluate
correctly
.
Since
load
do
es
not
op
en
the
mo
dule
it
loads,
references
to
x
will
still
fail
with
the
error
\Variable
x
is
unbound".
Y
ou
will
ha
v
e
to
do
#open
"foo";;
explicitly
,
for
x
to
complete
automatically
in
to
foo__x.
.
Finally
,
assume
the
le
foo.ml
ab
o
v
e
has
b
een
previously
compiled
with
the
camlc
-c
com-
mand.
The
curren
t
directory
therefore
con
tains
a
compiled
in
terface
foo.zi,
claiming
that
foo__x
is
a
global
v
ariable
with
t
yp
e
int,
and
a
compiled
b
yteco
de
le
foo.zo,
dening
foo__x
to
ha
v
e
the
v
alue
.
When
the
toplev
el
starts,
references
to
foo__x
will
cause
the
error
\foo_
_x
is
referenced
before
being
defined".
In
con
trast
with
case

ab
o
v
e,
the
t
yp
ec
hec
k
er
has
succeeded
in
nding
the
compiled
in
terface
for
mo
dule
foo.
But
execution
cannot
pro
ceed,
b
ecause
no
denition
for
foo__x
has
b
een
en
tered
in
memory
.
T
o
do
so,
execute:
load_object
"foo";;
This
loads
the
le
foo.zo
in
memory
,
therefore
dening
foo__x.
Then,
references
to
foo__x
ev
aluate
correctly
.
As
in
case

ab
o
v
e,
references
to
x
still
fail,
b
ecause
load_object
do
es
not
op
en
the
mo
dule
it
loads.
Again,
y
ou
will
ha
v
e
to
do
#open
"foo";;
explicitly
,
for
x
to
complete
automatically
in
to
foo__x.
.
Common
errors
This
section
describ
es
and
explains
the
most
frequen
tly
encoun
tered
error
messages.
Cannot
nd
le
lename
The
named
le
could
not
b
e
found
in
the
curren
t
directory
,
nor
in
the
directories
of
the
searc
h
path.
If
lename
has
the
format
mo
d.zi,
this
means
the
curren
t
phrase
references
iden
tiers
from
mo
dule
mo
d,
but
y
ou
ha
v
e
not
y
et
compiled
an
in
terface
for
mo
dule
mo
d.
Fix:
either
load
the
le
mo
d.ml,
whic
h
will
also
create
in
memory
the
compiled
in
terface
for
mo
dule
mo
d;
or
use
camlc
to
compile
mo
d.mli
or
mo
d.ml,
creating
the
compiled
in
terface
mo
d.zi,
b
efore
y
ou
start
the
toplev
el.

0
If
lename
has
the
format
mo
d.zo,
this
means
y
ou
are
trying
to
load
with
load_object
a
b
yteco
de
ob
ject
le
that
do
es
not
exist
y
et.
Fix:
compile
mo
d.ml
with
camlc
b
efore
y
ou
start
the
toplev
el.
Or,
use
load
instead
of
load_object
to
load
the
source
co
de
instead
of
a
compiled
ob
ject
le.
If
lename
has
the
format
mo
d.ml,
this
means
load
or
include
could
not
nd
the
sp
ecied
source
le.
Fix:
c
hec
k
the
sp
elling
of
the
le
name,
or
write
it
if
it
do
es
not
exist.
mo
d__name
is
referenced
b
efore
b
eing
dened
Y
ou
ha
v
e
neglected
to
load
in
memory
an
implemen
tation
for
a
mo
dule,
with
load
or
load_object.
This
is
explained
in
full
detail
in
section
.
ab
o
v
e.
Corrupted
compiled
in
terface
le
lename
See
section
..
Expression
of
t
yp
e
t

cannot
b
e
used
with
t
yp
e
t

See
section
..
The
t
yp
e
inferred
for
the
v
alue
name,
that
is,
t,
con
tains
t
yp
e
v
ariables
that
cannot
b
e
generaliz
See
section
..
.
Building
custom
toplev
el
systems:
camlmktop
The
camlmktop
command
builds
Caml
Ligh
t
toplev
els
that
con
tain
user
co
de
preloaded
at
start-up.
Mac:
This
command
is
not
a
v
ailable
in
the
Macin
tosh
v
ersion.
The
camlmktop
command
tak
es
as
argumen
t
a
set
of
.zo
les,
and
links
them
with
the
ob
ject
les
that
implemen
t
the
Caml
Ligh
t
toplev
el.
The
t
ypical
use
is:
camlmktop
-o
mytoplevel
foo.zo
bar.zo
gee.zo
This
creates
the
b
yteco
de
le
mytoplevel,
con
taining
the
Caml
Ligh
t
toplev
el
system,
plus
the
co
de
from
the
three
.zo
les.
T
o
run
this
toplev
el,
giv
e
it
as
argumen
t
to
the
camllight
command:
camllight
mytoplevel
This
starts
a
regular
toplev
el
lo
op,
except
that
the
co
de
from
foo.zo,
bar.zo
and
gee.zo
is
already
loaded
in
memory
,
just
as
if
y
ou
had
t
yp
ed:
load_object
"foo";;
load_object
"bar";;
load_object
"gee";;
on
en
trance
to
the
toplev
el.
The
mo
dules
foo,
bar
and
gee
are
not
op
ened,
though;
y
ou
still
ha
v
e
to
do
#open
"foo";;
y
ourself,
if
this
is
what
y
ou
wish.

Chapter
.
The
toplev
el
system
(camlligh
t)

.
Options
The
follo
wing
command-line
options
are
recognized
b
y
camlmktop.
-ccopt
option
P
ass
the
giv
en
option
to
the
C
compiler
and
link
er,
when
linking
in
\custom
run
time"
mo
de.
See
the
corresp
onding
option
for
camlc,
in
c
hapter
.
-custom
Link
in
\custom
run
time"
mo
de.
See
the
corresp
onding
option
for
camlc,
in
c
hapter
.
-g
Add
debugging
information
to
the
toplev
el
le
pro
duced,
whic
h
can
then
b
e
debugged
with
camldebug
(c
hapter
	).
-I
dir
e
ctory
Add
the
giv
en
directory
to
the
list
of
directories
searc
hed
for
compiled
ob
ject
co
de
les
(.zo).
-o
exe
c-le
Sp
ecify
the
name
of
the
toplev
el
le
pro
duced
b
y
the
link
er.
Unix:
The
default
is
camltop.out.
PC:
The
default
is
camltop.exe.
The
name
m
ust
ha
v
e
.exe
extension.



Chapter

The
run
time
system
(camlrun)
The
camlrun
command
executes
b
yteco
de
les
pro
duced
b
y
the
linking
phase
of
the
camlc
com-
mand.
Mac:
This
command
is
a
MPW
to
ol,
not
a
standalone
Macin
tosh
application.
.
Ov
erview
The
camlrun
command
comprises
three
main
parts:
the
b
yteco
de
in
terpreter,
that
actually
executes
b
yteco
de
les;
the
memory
allo
cator
and
garbage
collector;
and
a
set
of
C
functions
that
implemen
t
primitiv
e
op
erations
suc
h
as
input/output.
The
usage
for
camlrun
is:
camlrun
options
byte
c
o
de-exe
cutable
ar
g

...
ar
g
n
The
rst
non-option
argumen
t
is
tak
en
to
b
e
the
name
of
the
le
con
taining
the
executable
b
yteco
de.
(That
le
is
searc
hed
in
the
executable
path
as
w
ell
as
in
the
curren
t
directory
.)
The
remaining
argumen
ts
are
passed
to
the
Caml
Ligh
t
program,
in
the
string
arra
y
sys__command_line.
Elemen
t
0
of
this
arra
y
is
the
name
of
the
b
yteco
de
executable
le;
elemen
ts

to
n
are
the
remaining
argumen
ts
ar
g

to
ar
g
n
.
As
men
tioned
in
c
hapter
,
in
most
cases,
the
b
yteco
de
executable
les
pro
duced
b
y
the
camlc
command
are
self-executable,
and
manage
to
launc
h
the
camlrun
command
on
themselv
es
auto-
matically
.
That
is,
assuming
caml.out
is
a
b
yteco
de
executable
le,
caml.out
ar
g

...
ar
g
n
w
orks
exactly
as
camlrun
caml.out
ar
g

...
ar
g
n
Notice
that
it
is
not
p
ossible
to
pass
options
to
camlrun
when
in
v
oking
caml.out
directly
.



.
Options
The
follo
wing
command-line
option
is
recognized
b
y
camlrun.
-V
Prin
t
out
the
camlrun
v
ersion
n
um
b
er.
Exit
immediately
without
executing
an
y
b
yte-co
de
le.
The
follo
wing
en
vironmen
t
v
ariable
are
also
consulted:
CAMLRUNPARAM
Set
the
garbage
collection
parameters.
This
v
ariable
m
ust
b
e
a
sequence
of
parameter
sp
ec-
ications.
A
parameter
sp
ecication
is
an
option
letter
follo
w
ed
b
y
an
=
sign
and
a
decimal
n
um
b
er.
There
are
four
options,
corresp
onding
to
the
four
elds
of
the
control
record
do
cumen
ted
in
section
.:
s
(minor_heap_size)
Size
of
the
minor
heap.
i
(major_heap_increment)
Minim
um
size
incremen
t
for
the
ma
jor
heap.
o
(space_overhead)
The
ma
jor
GC
sp
eed
setting.
v
(verbose)
Whether
to
prin
t
GC
messages
or
not.
0
is
false;

is
true;
other
v
alues
ma
y
giv
e
unexp
ected
results.
F
or
example,
under
csh
the
command
setenv
CAMLRUNPARAM
's=0000
v='
tells
a
subsequen
t
camlrun
to
set
its
initial
minor
heap
size
to
ab
out

megab
yte
(on
a
-bit
mac
hine)
and
to
prin
t
its
GC
messages.
PATH
List
of
directories
searc
hed
to
nd
the
b
yteco
de
executable
le.
.
Common
errors
This
section
describ
es
and
explains
the
most
frequen
tly
encoun
tered
error
messages.
lename:
no
such
file
or
directory
If
lename
is
the
name
of
a
self-executable
b
yteco
de
le,
this
means
that
either
that
le
do
es
not
exist,
or
that
it
failed
to
run
the
camlrun
b
yteco
de
in
terpreter
on
itself.
The
second
p
ossibilit
y
indicates
that
Caml
Ligh
t
has
not
b
een
prop
erly
installed
on
y
our
system.
Cannot
exec
camlrun
(When
launc
hing
a
self-executable
b
yteco
de
le.)
The
camlrun
command
could
not
b
e
found
in
the
executable
path.
Chec
k
that
Caml
Ligh
t
has
b
een
prop
erly
installed
on
y
our
system.
Cannot
find
the
bytecode
file
The
le
that
camlrun
is
trying
to
execute
(e.g.
the
le
giv
en
as
rst
non-option
argumen
t
to
camlrun)
either
do
es
not
exist,
or
is
not
a
v
alid
executable
b
yteco
de
le.

Chapter
.
The
run
time
system
(camlrun)

Truncated
bytecode
file
The
le
that
camlrun
is
trying
to
execute
is
not
a
v
alid
executable
b
yteco
de
le.
Probably
it
has
b
een
truncated
or
mangled
since
created.
Erase
and
rebuild
it.
Uncaught
exception
The
program
b
eing
executed
con
tains
a
\stra
y"
exception.
That
is,
it
raises
an
exception
at
some
p
oin
t,
and
this
exception
is
nev
er
caugh
t.
This
causes
immediate
termination
of
the
program.
If
y
ou
wish
to
kno
w
whic
h
exception
th
us
escap
es,
use
the
printexc__f
function
from
the
standard
library
(and
don't
forget
to
link
y
our
program
with
the
-g
option).
Out
of
memory
The
program
b
eing
executed
requires
more
memory
than
a
v
ailable.
Either
the
program
builds
to
o
large
data
structures;
or
the
program
con
tains
to
o
man
y
nested
function
calls,
and
the
stac
k
o
v
ero
ws.
In
some
cases,
y
our
program
is
p
erfectly
correct,
it
just
requires
more
memory
than
y
our
mac
hine
pro
vides.
(This
happ
ens
quite
frequen
tly
on
small
micro
computers,
but
is
unlik
ely
on
Unix
mac
hines.)
In
other
cases,
the
\out
of
memory"
message
rev
eals
an
error
in
y
our
program:
non-terminating
recursiv
e
function,
allo
cation
of
an
excessiv
ely
large
arra
y
or
string,
attempts
to
build
an
innite
list
or
other
data
structure,
:
:
:
T
o
help
y
ou
diagnose
this
error,
run
y
our
program
with
the
-v
option
to
camlrun.
If
it
displa
ys
lots
of
\Growing
stack:
:
:
"
messages,
this
is
probably
a
lo
oping
recursiv
e
function.
If
it
displa
ys
lots
of
\Growing
heap:
:
:
"
messages,
with
the
heap
size
gro
wing
slo
wly
,
this
is
probably
an
attempt
to
construct
a
data
structure
with
to
o
man
y
(innitely
man
y?)
cells.
If
it
displa
ys
few
\Growing
heap:
:
:
"
messages,
but
with
a
h
uge
incremen
t
in
the
heap
size,
this
is
probably
an
attempt
to
build
an
excessiv
ely
large
arra
y
or
string.



Chapter

The
librarian
(camllibr)
Mac:
This
command
is
a
MPW
to
ol,
not
a
standalone
Macin
tosh
application.
.
Ov
erview
The
camllibr
program
pac
ks
in
one
single
le
a
set
of
b
yteco
de
ob
ject
les
(.zo
les).
The
resulting
le
is
also
a
b
yteco
de
ob
ject
le
and
also
has
the
.zo
extension.
It
can
b
e
passed
to
the
link
phase
of
the
camlc
compiler
in
replacemen
t
of
the
original
set
of
b
yteco
de
ob
ject
les.
That
is,
after
running
camllibr
-o
library.zo
mod.zo
mod.zo
mod.zi
mod.zo
all
calls
to
the
link
er
with
the
form
camlc
...
library.zo
...
are
exactly
equiv
alen
t
to
camlc
...
mod.zo
mod.zo
mod.zi
mod.zo
...
The
t
ypical
use
of
camllibr
is
to
build
a
library
comp
osed
of
sev
eral
mo
dules:
this
w
a
y
,
users
of
the
library
ha
v
e
only
one
.zo
le
to
sp
ecify
on
the
command
line
to
camlc,
instead
of
a
bunc
h
of
.zo
les,
one
p
er
mo
dule
con
tained
in
the
library
.
The
linking
phase
of
camlc
is
clev
er
enough
to
discard
the
co
de
corresp
onding
to
useless
phrases:
in
particular,
denitions
for
global
v
ariables
that
are
nev
er
used
after
their
denitions.
Hence,
there
is
no
problem
with
putting
man
y
mo
dules,
ev
en
rarely
used
ones,
in
to
one
single
library:
this
will
not
result
in
bigger
executables.
The
usage
for
camllibr
is:
camllibr
options
le

.zo
...
le
n
.zo
where
le

.zo
through
le
n
.zo
are
the
ob
ject
les
to
pac
k
together.
The
order
in
whic
h
these
le
names
are
presen
ted
on
the
command
line
is
relev
an
t:
the
compiled
phrases
con
tained
in
the
library
will
b
e
executed
in
that
order.
(Remem
b
er
that
it
is
a
link-time
error
to
refer
to
a
global
v
ariable
that
has
not
y
et
b
een
dened.)



.
Options
The
follo
wing
command-line
options
are
recognized
b
y
camllibr.
-I
dir
e
ctory
Add
the
giv
en
directory
to
the
list
of
directories
searc
hed
for
the
input
.zo
les.
By
default,
the
curren
t
directory
is
searc
hed
rst,
then
the
standard
library
directory
.
Directories
added
with
-I
are
searc
hed
after
the
curren
t
directory
,
but
b
efore
the
standard
library
directory
.
When
sev
eral
directories
are
added
with
sev
eral
-I
options
on
the
command
line,
these
direc-
tories
are
searc
hed
from
righ
t
to
left
(the
righ
tmost
directory
is
searc
hed
rst,
the
leftmost
is
searc
hed
last).
-o
libr
ary-name
Sp
ecify
the
name
of
the
output
le.
The
default
is
library.zo.
PC:
The
follo
wing
option
is
also
supp
orted:
@r
esp
onse-le
Pro
cess
the
les
whose
names
are
listed
in
le
r
esp
onse-le,
just
as
if
these
names
app
eared
on
the
command
line.
File
names
in
r
esp
onse-le
are
separated
b
y
blanks
(spaces,
tabs,
newlines).
This
option
allo
ws
to
o
v
ercome
silly
limitations
on
the
length
of
the
command
line.
.
T
urning
co
de
in
to
a
library
T
o
dev
elop
a
library
,
it
is
usually
more
con
v
enien
t
to
split
it
in
to
sev
eral
mo
dules,
that
reect
the
in
ternal
structure
of
the
library
.
F
rom
the
standp
oin
t
of
the
library
users,
ho
w
ev
er,
it
is
preferable
to
view
the
library
as
a
single
mo
dule,
with
only
one
in
terface
le
(.zi
le)
and
one
implemen
tation
le
(.zo
le):
linking
is
easier,
and
there
is
no
need
to
put
a
bunc
h
of
#open
directiv
es,
nor
to
ha
v
e
to
remem
b
er
the
in
ternal
structure
of
the
library
.
The
camllibr
command
allo
ws
ha
ving
a
single
.zo
le
for
the
whole
library
.
Here
is
ho
w
the
Caml
Ligh
t
mo
dule
system
can
b
e
used
(some
sa
y
\abused")
to
ha
v
e
a
single
.zi
le
for
the
whole
library
.
T
o
b
e
more
concrete,
assume
that
the
library
comprises
three
mo
dules,
windows,
images
and
buttons.
The
idea
is
to
add
a
fourth
mo
dule,
mylib,
that
re-exp
orts
the
public
parts
of
windows,
images
and
buttons.
The
in
terface
mylib.mli
con
tains
denitions
for
those
t
yp
es
that
are
public
(exp
orted
with
their
denitions),
declarations
for
those
t
yp
es
that
are
abstract
(exp
orted
without
their
denitions),
and
declarations
for
the
functions
that
can
b
e
called
from
the
user's
co
de:
(*
File
mylib.mli
*)
type
'a
option
=
None
|
Some
of
'a;;
(*
a
public
type
*)
type
window
and
image
and
button;;
(*
three
abstract
types
*)
value
new_window
:
int
->
int
->
window
(*
the
public
functions
*)
and
draw_image
:
image
->
window
->
int
->
int
->
unit
and
...
The
implemen
tation
of
the
mylib
mo
dule
simply
equates
the
abstract
t
yp
es
and
the
public
functions
to
the
corresp
onding
t
yp
es
and
functions
in
the
mo
dules
windows,
images
and
buttons:

Chapter
.
The
librarian
(camllibr)
	
(*
File
mylib.ml
*)
type
window
==
windows__win
and
image
==
images__pixmap
and
button
==
buttons__t;;
let
new_window
=
windows__open_window
and
draw_image
=
images__draw
and
...
The
les
windows.ml,
images.ml
and
buttons.ml
can
op
en
the
mylib
mo
dule,
to
access
the
public
t
yp
es
dened
in
the
in
terface
mylib.mli,
suc
h
as
the
option
t
yp
e.
Of
course,
these
mo
dules
m
ust
not
reference
the
abstract
t
yp
es
nor
the
public
functions,
to
a
v
oid
circularities.
T
yp
es
suc
h
as
windows__win
in
the
example
ab
o
v
e
can
b
e
exp
orted
b
y
the
windows
mo
dule
either
abstractly
or
concretely
(with
their
denition).
Often,
it
is
necessary
to
exp
ort
them
con-
cretely
,
b
ecause
the
other
mo
dules
in
the
library
(images,
buttons)
need
to
build
or
destructure
directly
v
alues
of
that
t
yp
e.
Ev
en
if
windows__win
is
exp
orted
concretely
b
y
the
windows
mo
dule,
that
t
yp
e
will
remain
abstract
to
the
library
user,
since
it
is
abstracted
b
y
the
public
in
terface
mylib.
The
actual
building
of
the
library
mylib
pro
ceeds
as
follo
ws:
camlc
-c
mylib.mli
#
create
mylib.zi
camlc
-c
windows.mli
windows.ml
images.mli
images.ml
camlc
-c
buttons.mli
buttons.ml
camlc
-c
mylib.ml
#
create
mylib.zo
mv
mylib.zo
tmplib.zo
#
renaming
to
avoid
overwriting
mylib.zo
camllibr
-o
mylib.zo
windows.zo
images.zo
buttons.zo
tmplib.zo
Then,
cop
y
mylib.zi
and
mylib.zo
to
a
place
accessible
to
the
library
users.
The
other
.zi
and
.zo
les
need
not
b
e
copied.

0

Chapter

Lexer
and
parser
generators
(camllex,
camly
acc)
This
c
hapter
describ
es
t
w
o
program
generators:
camllex,
that
pro
duces
a
lexical
analyzer
from
a
set
of
regular
expressions
with
asso
ciated
seman
tic
actions,
and
camlyacc,
that
pro
duces
a
parser
from
a
grammar
with
asso
ciated
seman
tic
actions.
These
program
generators
are
v
ery
close
to
the
w
ell-kno
wn
lex
and
yacc
commands
that
can
b
e
found
in
most
C
programming
en
vironmen
ts.
This
c
hapter
assumes
a
w
orking
kno
wledge
of
lex
and
yacc:
while
it
describ
es
the
input
syn
tax
for
camllex
and
camlyacc
and
the
main
dierences
with
lex
and
yacc,
it
do
es
not
explain
the
basics
of
writing
a
lexer
or
parser
description
in
lex
and
yacc.
Readers
unfamiliar
with
lex
and
yacc
are
referred
to
\Compilers:
principles,
tec
hniques,
and
to
ols"
b
y
Aho,
Sethi
and
Ullman
(Addison-W
esley
,
	),
\Compiler
design
in
C"
b
y
Holub
(Pren
tice-Hall,
		0),
or
\Lex
&
Y
acc",
b
y
Mason
and
Bro
wn
(O'Reilly
,
		0).
Streams
and
stream
matc
hing,
as
describ
ed
in
section
.,
pro
vide
an
alternativ
e
w
a
y
to
write
lexers
and
parsers.
The
stream
matc
hing
tec
hnique
is
more
p
o
w
erful
than
the
com
bination
of
camllex
and
camlyacc
in
some
cases
(higher-order
parsers),
but
less
p
o
w
erful
in
other
cases
(prece-
dences).
Cho
ose
whic
hev
er
approac
h
is
more
adapted
to
y
our
parsing
problem.
Mac:
These
commands
are
MPW
to
ol,
not
standalone
Macin
tosh
applications.
.
Ov
erview
of
camllex
The
camllex
command
pro
duces
a
lexical
analyzer
from
a
set
of
regular
expressions
with
attac
hed
seman
tic
actions,
in
the
st
yle
of
lex.
Assuming
the
input
le
is
lexer
:mll
,
executing
camllex
lexer.mll
pro
duces
Caml
Ligh
t
co
de
for
a
lexical
analyzer
in
le
lexer.ml.
This
le
denes
one
lexing
func-
tion
p
er
en
try
p
oin
t
in
the
lexer
denition.
These
functions
ha
v
e
the
same
names
as
the
en
try
p
oin
ts.
Lexing
functions
tak
e
as
argumen
t
a
lexer
buer,
and
return
the
seman
tic
attribute
of
the
corresp
onding
en
try
p
oin
t.
Lexer
buers
are
an
abstract
data
t
yp
e
implemen
ted
in
the
standard
library
mo
dule
lexing.
The
functions
create_lexer_channel,
create_lexer_string
and
create_lexer
from
mo
dule



lexing
create
lexer
buers
that
read
from
an
input
c
hannel,
a
c
haracter
string,
or
an
y
reading
function,
resp
ectiv
ely
.
(See
the
description
of
mo
dule
lexing
in
c
hapter
.)
When
used
in
conjunction
with
a
parser
generated
b
y
camlyacc,
the
seman
tic
actions
compute
a
v
alue
b
elonging
to
the
t
yp
e
token
dened
b
y
the
generated
parsing
mo
dule.
(See
the
description
of
camlyacc
b
elo
w.)
.
Syn
tax
of
lexer
denitions
The
format
of
lexer
denitions
is
as
follo
ws:
f
he
ader
g
rule
entryp
oint
=
parse
r
e
gexp
f
action
g
|
:
:
:
|
r
e
gexp
f
action
g
and
entryp
oint
=
parse
:
:
:
and
:
:
:
;;
Commen
ts
are
delimited
b
y
(*
and
*),
as
in
Caml
Ligh
t.
..
Header
The
he
ader
section
is
arbitrary
Caml
Ligh
t
text
enclosed
in
curly
braces.
It
can
b
e
omitted.
If
it
is
presen
t,
the
enclosed
text
is
copied
as
is
at
the
b
eginning
of
the
output
le.
T
ypically
,
the
header
section
con
tains
the
#open
directiv
es
required
b
y
the
actions,
and
p
ossibly
some
auxiliary
functions
used
in
the
actions.
..
En
try
p
oin
ts
The
names
of
the
en
try
p
oin
ts
m
ust
b
e
v
alid
Caml
Ligh
t
iden
tiers.
..
Regular
expressions
The
regular
expressions
are
in
the
st
yle
of
lex,
with
a
more
Caml-lik
e
syn
tax.
`
c
har
`
A
c
haracter
constan
t,
with
the
same
syn
tax
as
Caml
Ligh
t
c
haracter
constan
ts.
Matc
h
the
denoted
c
haracter.
_
Matc
h
an
y
c
haracter.
eof
Matc
h
the
end
of
the
lexer
input.
"
string
"
A
string
constan
t,
with
the
same
syn
tax
as
Caml
Ligh
t
string
constan
ts.
Matc
h
the
corre-
sp
onding
sequence
of
c
haracters.

Chapter
.
Lexer
and
parser
generators
(camllex,
camly
acc)

[
c
haracter-set
]
Matc
h
an
y
single
c
haracter
b
elonging
to
the
giv
en
c
haracter
set.
V
alid
c
haracter
sets
are:
single
c
haracter
constan
ts
`
c
`;
ranges
of
c
haracters
`
c

`
-
`
c

`
(all
c
haracters
b
et
w
een
c

and
c

,
inclusiv
e);
and
the
union
of
t
w
o
or
more
c
haracter
sets,
denoted
b
y
concatenation.
[
^
c
haracter-set
]
Matc
h
an
y
single
c
haracter
not
b
elonging
to
the
giv
en
c
haracter
set.
regexp
*
(Rep
etition.)
Matc
h
the
concatenation
of
zero
or
more
strings
that
matc
h
regexp
.
regexp
+
(Strict
rep
etition.)
Matc
h
the
concatenation
of
one
or
more
strings
that
matc
h
regexp
.
regexp
?
(Option.)
Matc
h
either
the
empt
y
string,
or
a
string
matc
hing
regexp
.
regexp

|
regexp

(Alternativ
e.)
Matc
h
an
y
string
that
matc
hes
either
regexp

or
regexp

regexp

regexp

(Concatenation.)
Matc
h
the
concatenation
of
t
w
o
strings,
the
rst
matc
hing
regexp

,
the
second
matc
hing
regexp

.
(
regexp
)
Matc
h
the
same
strings
as
regexp
.
Concerning
the
precedences
of
op
erators,
*
and
+
ha
v
e
highest
precedence,
follo
w
ed
b
y
?,
then
concatenation,
then
|
(alternation).
..
Actions
The
actions
are
arbitrary
Caml
Ligh
t
expressions.
They
are
ev
aluated
in
a
con
text
where
the
iden
tier
lexbuf
is
b
ound
to
the
curren
t
lexer
buer.
Some
t
ypical
uses
for
lexbuf,
in
conjunction
with
the
op
erations
on
lexer
buers
pro
vided
b
y
the
lexing
standard
library
mo
dule,
are
listed
b
elo
w.
lexing__get_lexeme
lexbuf
Return
the
matc
hed
string.
lexing__get_lexeme_char
lexbuf
n
Return
the
n
th
c
haracter
in
the
matc
hed
string.
The
rst
c
haracter
corresp
onds
to
n
=
0.
lexing__get_lexeme_start
lexbuf
Return
the
absolute
p
osition
in
the
input
text
of
the
b
eginning
of
the
matc
hed
string.
The
rst
c
haracter
read
from
the
input
text
has
p
osition
0.
lexing__get_lexeme_end
lexbuf
Return
the
absolute
p
osition
in
the
input
text
of
the
end
of
the
matc
hed
string.
The
rst
c
haracter
read
from
the
input
text
has
p
osition
0.


entryp
oint
lexbuf
(Where
entryp
oint
is
the
name
of
another
en
try
p
oin
t
in
the
same
lexer
denition.)
Recursiv
ely
call
the
lexer
on
the
giv
en
en
try
p
oin
t.
Useful
for
lexing
nested
commen
ts,
for
example.
.
Ov
erview
of
camlyacc
The
camlyacc
command
pro
duces
a
parser
from
a
con
text-free
grammar
sp
ecication
with
attac
hed
seman
tic
actions,
in
the
st
yle
of
yacc.
Assuming
the
input
le
is
g
r
ammar
:mly
,
executing
camlyacc
options
gr
ammar.mly
pro
duces
Caml
Ligh
t
co
de
for
a
parser
in
the
le
gr
ammar.ml,
and
its
in
terface
in
le
gr
ammar.mli.
The
generated
mo
dule
denes
one
parsing
function
p
er
en
try
p
oin
t
in
the
grammar.
These
functions
ha
v
e
the
same
names
as
the
en
try
p
oin
ts.
P
arsing
functions
tak
e
as
argumen
ts
a
lexical
analyzer
(a
function
from
lexer
buers
to
tok
ens)
and
a
lexer
buer,
and
return
the
seman
tic
attribute
of
the
corresp
onding
en
try
p
oin
t.
Lexical
analyzer
functions
are
usually
generated
from
a
lexer
sp
ecication
b
y
the
camllex
program.
Lexer
buers
are
an
abstract
data
t
yp
e
implemen
ted
in
the
standard
library
mo
dule
lexing.
T
ok
ens
are
v
alues
from
the
concrete
t
yp
e
token,
dened
in
the
in
terface
le
gr
ammar.mli
pro
duced
b
y
camlyacc.
.
Syn
tax
of
grammar
denitions
Grammar
denitions
ha
v
e
the
follo
wing
format:
%f
he
ader
%g
de
clar
ations
%%
rules
%%
tr
ailer
Commen
ts
are
enclosed
b
et
w
een
/*
and
*/
(as
in
C)
in
the
\declarations"
and
\rules"
sections,
and
b
et
w
een
(*
and
*)
(as
in
Caml)
in
the
\header"
and
\trailer"
sections.
..
Header
and
trailer
The
header
and
the
trailer
sections
are
Caml
Ligh
t
co
de
that
is
copied
as
is
in
to
le
gr
ammar.ml.
Both
sections
are
optional.
The
header
go
es
at
the
b
eginning
of
the
output
le;
it
usually
con
tains
#open
directiv
es
required
b
y
the
seman
tic
actions
of
the
rules.
The
trailer
go
es
at
the
end
of
the
output
le.
..
Declarations
Declarations
are
giv
en
one
p
er
line.
They
all
start
with
a
%
sign.

Chapter
.
Lexer
and
parser
generators
(camllex,
camly
acc)

%token
sym
b
ol
:
:
:
sym
b
ol
Declare
the
giv
en
sym
b
ols
as
tok
ens
(terminal
sym
b
ols).
These
sym
b
ols
are
added
as
constan
t
constructors
for
the
token
concrete
t
yp
e.
%token
<
t
yp
e
>
sym
b
ol
:
:
:
sym
b
ol
Declare
the
giv
en
sym
b
ols
as
tok
ens
with
an
attac
hed
attribute
of
the
giv
en
t
yp
e.
These
sym-
b
ols
are
added
as
constructors
with
argumen
ts
of
the
giv
en
t
yp
e
for
the
token
concrete
t
yp
e.
The
t
yp
e
part
is
an
arbitrary
Caml
Ligh
t
t
yp
e
expression,
except
that
all
t
yp
e
constructor
names
m
ust
b
e
fully
qualied
(e.g.
modname__typename)
for
all
t
yp
es
except
standard
built-in
t
yp
es,
ev
en
if
the
prop
er
#open
directiv
es
(e.g.
#open
"modname")
w
ere
giv
en
in
the
header
section.
That's
b
ecause
the
header
is
copied
only
to
the
.ml
output
le,
but
not
to
the
.mli
output
le,
while
the
t
yp
e
part
of
a
%token
declaration
is
copied
to
b
oth.
%start
sym
b
ol
:
:
:
sym
b
ol
Declare
the
giv
en
sym
b
ols
as
en
try
p
oin
ts
for
the
grammar.
F
or
eac
h
en
try
p
oin
t,
a
parsing
function
with
the
same
name
is
dened
in
the
output
mo
dule.
Non-terminals
that
are
not
declared
as
en
try
p
oin
ts
ha
v
e
no
suc
h
parsing
function.
Start
sym
b
ols
m
ust
b
e
giv
en
a
t
yp
e
with
the
%type
directiv
e
b
elo
w.
%type
<
t
yp
e
>
sym
b
ol
:
:
:
sym
b
ol
Sp
ecify
the
t
yp
e
of
the
seman
tic
attributes
for
the
giv
en
sym
b
ols.
This
is
mandatory
for
start
sym
b
ols
only
.
Other
non
terminal
sym
b
ols
need
not
b
e
giv
en
t
yp
es
b
y
hand:
these
t
yp
es
will
b
e
inferred
when
running
the
output
les
through
the
Caml
Ligh
t
compiler
(unless
the
-s
option
is
in
eect).
The
t
yp
e
part
is
an
arbitrary
Caml
Ligh
t
t
yp
e
expression,
except
that
all
t
yp
e
constructor
names
m
ust
b
e
fully
qualied
(e.g.
modname__typename)
for
all
t
yp
es
except
standard
built-in
t
yp
es,
ev
en
if
the
prop
er
#open
directiv
es
(e.g.
#open
"modname")
w
ere
giv
en
in
the
header
section.
That's
b
ecause
the
header
is
copied
only
to
the
.ml
output
le,
but
not
to
the
.mli
output
le,
while
the
t
yp
e
part
of
a
%token
declaration
is
copied
to
b
oth.
%left
sym
b
ol
:
:
:
sym
b
ol
%right
sym
b
ol
:
:
:
sym
b
ol
%nonassoc
sym
b
ol
:
:
:
sym
b
ol
Asso
ciate
precedences
and
asso
ciativities
to
the
giv
en
sym
b
ols.
All
sym
b
ols
on
the
same
line
are
giv
en
the
same
precedence.
They
ha
v
e
higher
precedence
than
sym
b
ols
declared
b
efore
in
a
%left,
%right
or
%nonassoc
line.
They
ha
v
e
lo
w
er
precedence
than
sym
b
ols
declared
after
in
a
%left,
%right
or
%nonassoc
line.
The
sym
b
ols
are
declared
to
asso
ciate
to
the
left
(%left),
to
the
righ
t
(%right),
or
to
b
e
non-asso
ciativ
e
(%nonassoc).
The
sym
b
ols
are
usually
tok
ens.
They
can
also
b
e
dumm
y
non
terminals,
for
use
with
the
%prec
directiv
e
inside
the
rules.


..
Rules
The
syn
tax
for
rules
is
as
usual:
nonterminal
:
symb
ol
:
:
:
symb
ol
f
semantic-action
g
|
:
:
:
|
symb
ol
:
:
:
symb
ol
f
semantic-action
g
;
Rules
can
also
con
tain
the
%prec
symb
ol
directiv
e
in
the
righ
t-hand
side
part,
to
o
v
erride
the
default
precedence
and
asso
ciativit
y
of
the
rule
with
the
precedence
and
asso
ciativit
y
of
the
giv
en
sym
b
ol.
Seman
tic
actions
are
arbitrary
Caml
Ligh
t
expressions,
that
are
ev
aluated
to
pro
duce
the
se-
man
tic
attribute
attac
hed
to
the
dened
non
terminal.
The
seman
tic
actions
can
access
the
seman
tic
attributes
of
the
sym
b
ols
in
the
righ
t-hand
side
of
the
rule
with
the
$
notation:
$
is
the
attribute
for
the
rst
(leftmost)
sym
b
ol,
$
is
the
attribute
for
the
second
sym
b
ol,
etc.
Actions
o
ccurring
in
the
middle
of
rules
are
not
supp
orted.
Error
reco
v
ery
is
not
implemen
ted.
.
Options
The
camlyacc
command
recognizes
the
follo
wing
options:
-v
Generate
a
description
of
the
parsing
tables
and
a
rep
ort
on
conicts
resulting
from
am
bigu-
ities
in
the
grammar.
The
description
is
put
in
le
gr
ammar.output.
-s
Generate
a
gr
ammar.ml
le
with
smaller
phrases.
Seman
tic
actions
are
presen
ted
in
the
gr
ammar.ml
output
le
as
one
large
v
ector
of
functions.
By
default,
this
v
ector
is
built
b
y
a
single
phrase.
When
the
grammar
is
large,
or
con
tains
complicated
seman
tic
actions,
the
resulting
phrase
ma
y
require
large
amoun
ts
of
memory
to
b
e
compiled
b
y
Caml
Ligh
t.
With
the
-s
option,
the
v
ector
of
actions
is
constructed
incremen
tally
,
one
phrase
p
er
action.
This
lo
w
ers
the
memory
requiremen
ts
for
the
compiler,
but
it
is
no
longer
p
ossible
to
infer
the
t
yp
es
of
non
terminal
sym
b
ols:
t
yp
ec
hec
king
is
turned
o
on
sym
b
ols
that
do
not
ha
v
e
a
t
yp
e
sp
ecied
b
y
a
%type
directiv
e.
-bpr
ex
Name
the
output
les
pr
ex.ml,
pr
ex.mli,
pr
ex.output,
instead
of
the
default
naming
con
v
en
tion.
.
A
complete
example
The
all-time
fa
v
orite:
a
desk
calculator.
This
program
reads
arithmetic
expressions
on
standard
input,
one
p
er
line,
and
prin
ts
their
v
alues.
Here
is
the
grammar
denition:
/*
File
parser.mly
*/
%token
<int>
INT
%token
PLUS
MINUS
TIMES
DIV

Chapter
.
Lexer
and
parser
generators
(camllex,
camly
acc)

%token
LPAREN
RPAREN
%token
EOL
%left
PLUS
MINUS
/*
lowest
precedence
*/
%left
TIMES
DIV
/*
medium
precedence
*/
%nonassoc
UMINUS
/*
highest
precedence
*/
%start
Main
/*
the
entry
point
*/
%type
<int>
Main
%%
Main:
Expr
EOL
{
$
}
;
Expr:
INT
{
$
}
|
LPAREN
Expr
RPAREN
{
$
}
|
Expr
PLUS
Expr
{
$
+
$
}
|
Expr
MINUS
Expr
{
$
-
$
}
|
Expr
TIMES
Expr
{
$
*
$
}
|
Expr
DIV
Expr
{
$
/
$
}
|
MINUS
Expr
%prec
UMINUS
{
-
$
}
;
Here
is
the
denition
for
the
corresp
onding
lexer:
(*
File
lexer.mll
*)
{
#open
"parser";;
(*
The
type
token
is
defined
in
parser.mli
*)
exception
Eof;;
}
rule
Token
=
parse
[`
`
`\t`]
{
Token
lexbuf
}
(*
skip
blanks
*)
|
[`\n`
]
{
EOL
}
|
[`0`-`	`]+
{
INT(int_of_string
(get_lexeme
lexbuf))
}
|
`+`
{
PLUS
}
|
`-`
{
MINUS
}
|
`*`
{
TIMES
}
|
`/`
{
DIV
}
|
`(`
{
LPAREN
}
|
`)`
{
RPAREN
}
|
eof
{
raise
Eof
}
;;
Here
is
the
main
program,
that
com
bines
the
parser
with
the
lexer:
(*
File
calc.ml
*)
try
let
lexbuf
=
lexing__create_lexer_chan
nel
std_in
in
while
true
do


let
result
=
parser__Main
lexer__Token
lexbuf
in
print_int
result;
print_newline();
flush
std_out
done
with
Eof
->
()
;;
T
o
compile
ev
erything,
execute:
camllex
lexer.mll
#
generates
lexer.ml
camlyacc
parser.mly
#
generates
parser.ml
and
parser.mli
camlc
-c
parser.mli
camlc
-c
lexer.ml
camlc
-c
parser.ml
camlc
-c
calc.ml
camlc
-o
calc
lexer.zo
parser.zo
calc.zo

Chapter
	
The
debugger
(camldebug)
This
c
hapter
describ
es
the
Caml
Ligh
t
source-lev
el
repla
y
debugger
camldebug.
Unix:
The
debugger
resides
in
the
directory
contrib/debugger
in
the
distribution.
It
requires
a
Unix
system
that
pro
vides
BSD
so
c
k
ets.
Mac:
The
debugger
is
not
a
v
ailable.
PC:
The
debugger
is
not
a
v
ailable.
	.
Compili
ng
for
debugging
Before
the
debugger
can
b
e
used,
the
program
m
ust
b
e
compiled
and
link
ed
with
the
-g
option:
all
.zo
les
that
are
part
of
the
program
should
ha
v
e
b
een
created
with
camlc
-g,
and
they
m
ust
b
e
link
ed
together
with
camlc
-g.
Compiling
with
-g
en
tails
no
p
enalt
y
on
the
running
time
of
programs:
.zo
les
and
b
yteco
de
executable
les
are
bigger
and
tak
e
sligh
tly
longer
to
pro
duce,
but
the
executable
les
run
at
exactly
the
same
sp
eed
as
if
they
had
b
een
compiled
without
-g.
It
is
therefore
p
erfectly
acceptable
to
compile
alw
a
ys
in
-g
mo
de.
	.
In
v
o
cation
	..
Starting
the
debugger
The
Caml
Ligh
t
debugger
is
in
v
ok
ed
b
y
running
the
program
camldebug
with
the
name
of
the
b
yteco
de
executable
le
as
argumen
t:
camldebug
pr
o
gr
am
The
follo
wing
command-line
options
are
recognized:
-stdlib
dir
e
ctory
Lo
ok
for
the
standard
library
les
in
dir
e
ctory
instead
of
in
the
default
directory
.
	

0
-s
so
cket
Use
so
cket
for
comm
unicating
with
the
debugged
program.
See
the
description
of
the
com-
mand
set
socket
(section
	..)
for
the
format
of
so
cket.
-c
c
ount
Set
the
maxim
um
n
um
b
er
of
c
hec
kp
oin
ts
to
c
ount.
-cd
dir
e
ctory
Run
the
debugger
program
from
the
w
orking
directory
dir
e
ctory,
instead
of
the
curren
t
di-
rectory
.
-emacs
T
ell
the
debugger
it
is
executing
under
Emacs.
(See
section
.
for
information
on
ho
w
to
run
the
debugger
under
Emacs.)
	..
Quitting
the
debugger
The
command
quit
exits
the
debugger.
Y
ou
can
also
exit
the
debugger
b
y
t
yping
an
end-of-le
c
haracter
(usually
ctrl-D).
T
yping
an
in
terrupt
c
haracter
(usually
ctrl-C)
will
not
exit
the
debugger,
but
will
terminate
the
action
of
an
y
debugger
command
that
is
in
progress
and
return
to
the
debugger
command
lev
el.
	.
Commands
A
debugger
command
is
a
single
line
of
input.
It
starts
with
a
command
name,
whic
h
is
follo
w
ed
b
y
argumen
ts
dep
ending
on
this
name.
Examples:
run
goto
000
set
arguments
arg
arg
A
command
name
can
b
e
truncated
as
long
as
there
is
no
am
biguit
y
.
F
or
instance,
go
000
is
understo
o
d
as
goto
000,
since
there
are
no
other
commands
whose
name
starts
with
go.
F
or
the
most
frequen
tly
used
commands,
am
biguous
abbreviations
are
allo
w
ed.
F
or
instance,
r
stands
for
run
ev
en
though
there
are
others
commands
starting
with
r.
Y
ou
can
test
the
v
alidit
y
of
an
abbreviation
using
the
help
command.
If
the
previous
command
has
b
een
successful,
a
blank
line
(t
yping
just
RET)
will
rep
eat
it.
	..
Getting
help
The
Caml
Ligh
t
debugger
has
a
simple
on-line
help
system,
whic
h
giv
es
a
brief
description
of
eac
h
command
and
v
ariable.
help
Prin
t
the
list
of
commands.
help
c
ommand
Giv
e
help
ab
out
the
command
c
ommand.

Chapter
	.
The
debugger
(camldebug)

help
set
variable,
help
show
variable
Giv
e
help
ab
out
the
v
ariable
variable.
The
list
of
all
debugger
v
ariables
can
b
e
obtained
with
help
set.
help
info
topic
Giv
e
help
ab
out
topic.
Use
help
info
to
get
a
list
of
kno
wn
topics.
	..
Accessing
the
debugger
state
set
variable
value
Set
the
debugger
v
ariable
variable
to
the
v
alue
value.
show
variable
Prin
t
the
v
alue
of
the
debugger
v
ariable
variable.
info
subje
ct
Giv
e
information
ab
out
the
giv
en
sub
ject.
F
or
instance,
info
breakpoints
will
prin
t
the
list
of
all
breakp
oin
ts.
	.
Executing
a
program
	..
Ev
en
ts
Ev
en
ts
are
\in
teresting"
lo
cations
in
the
source
co
de,
corresp
onding
to
the
b
eginning
or
end
of
ev
aluation
of
\in
teresting"
sub-expressions.
Ev
en
ts
are
the
unit
of
single-stepping
(stepping
go
es
to
the
next
or
previous
ev
en
t
encoun
tered
in
the
program
execution).
Also,
breakp
oin
ts
can
only
b
e
set
at
ev
en
ts.
Th
us,
ev
en
ts
pla
y
the
role
of
line
n
um
b
ers
in
debuggers
for
con
v
en
tional
languages.
During
program
execution,
a
coun
ter
is
incremen
ted
at
eac
h
ev
en
t
encoun
tered.
The
v
alue
of
this
coun
ter
is
referred
as
the
curr
ent
time.
Thanks
to
rev
erse
execution,
it
is
p
ossible
to
jump
bac
k
and
forth
to
an
y
time
of
the
execution.
Here
is
where
the
debugger
ev
en
ts
(written
.
/)
are
lo
cated
in
the
source
co
de:

F
ollo
wing
a
function
application:
(f
arg).
/

After
receiving
an
argumen
t
to
a
function:
fun
x.
/
y.
/
z
->
.
/
...
If
a
curried
function
is
dened
b
y
pattern-matc
hing
with
sev
eral
cases,
ev
en
ts
corresp
onding
to
the
passing
of
argumen
ts
are
displa
y
ed
on
the
rst
case
of
the
function,
b
ecause
pattern-
matc
hing
has
not
y
et
determined
whic
h
case
to
select:
fun
pat.
/
pat.
/
pat
->
.
/
...
|
...



On
eac
h
case
of
a
pattern-matc
hing
denition
(function,
match:
:
:
with
construct,
try:
:
:
with
construct):
function
pat
->
.
/
expr
|
...
|
patN
->
.
/
exprN

Bet
w
een
sub
expressions
of
a
sequence:
expr;
.
/
expr;
.
/
...;
.
/
exprN

In
the
t
w
o
branc
hes
of
a
conditional
expression:
if
cond
then
.
/
expr
else
.
/
expr

A
t
the
b
eginning
of
eac
h
iteration
of
a
lo
op:
while
cond
do
.
/
body
done
for
i
=
a
to
b
do
.
/
body
done
Exceptions:
A
function
application
follo
w
ed
b
y
a
function
return
is
replaced
b
y
the
compiler
b
y
a
jump
(tail-call
optimization).
In
this
case,
no
ev
en
t
is
put
after
the
function
application.
Also,
no
ev
en
t
is
put
after
a
function
application
when
the
function
is
a
primitiv
e
function
(written
in
C).
Finally
,
sev
eral
ev
en
ts
ma
y
corresp
ond
to
the
same
lo
cation
in
the
compiled
program.
Then,
the
debugger
cannot
distinguish
them,
and
selects
one
of
the
ev
en
ts
to
asso
ciate
with
the
giv
en
co
de
lo
cation.
The
ev
en
t
c
hosen
is
a
\function
application"
ev
en
t
if
there
is
one
at
that
lo
cation,
or
otherwise
the
ev
en
t
whic
h
app
ears
last
in
the
source.
This
heuristic
generally
pic
ks
the
\most
in
teresting"
ev
en
t
asso
ciated
with
the
co
de
lo
cation.
	..
Starting
the
debugged
program
The
debugger
starts
executing
the
debugged
program
only
when
needed.
This
allo
ws
setting
brea-
p
oin
ts
or
assigning
debugger
v
ariables
b
efore
execution
starts.
There
are
sev
eral
w
a
ys
to
start
execution:
run
Run
the
program
un
til
a
breakp
oin
t
is
hit,
or
the
program
terminates.
step
0
Load
the
program
and
stop
on
the
rst
ev
en
t.
goto
time
Load
the
program
and
execute
it
un
til
the
giv
en
time.
Useful
when
y
ou
already
kno
w
ap-
pro
ximately
at
what
time
the
problem
app
ears.
Also
useful
to
set
breakp
oin
ts
on
function
v
alues
that
ha
v
e
not
b
een
computed
at
time
0
(see
section
	.).
The
execution
of
a
program
is
aected
b
y
certain
information
it
receiv
es
when
the
debugger
starts
it,
suc
h
as
the
command-line
argumen
ts
to
the
program
and
its
w
orking
directory
.
The
debugger
pro
vides
commands
to
sp
ecify
this
information
(set
arguments
and
cd).
These
com-
mands
m
ust
b
e
used
b
efore
program
execution
starts.
If
y
ou
try
to
c
hange
the
argumen
ts
or
the
w
orking
directory
after
starting
y
our
program,
the
debugger
will
kill
the
program
(after
asking
for
conrmation).

Chapter
	.
The
debugger
(camldebug)

	..
Running
the
program
The
follo
wing
commands
execute
the
program
forw
ard
or
bac
kw
ard,
starting
at
the
curren
t
time.
The
execution
will
stop
either
when
sp
ecied
b
y
the
command
or
when
a
breakp
oin
t
is
encoun
tered.
run
Execute
the
program
forw
ard
from
curren
t
time.
Stops
at
next
breakp
oin
t
or
when
the
program
terminates.
reverse
Execute
the
program
bac
kw
ard
from
curren
t
time.
Mostly
useful
to
go
to
the
last
breakp
oin
t
encoun
tered
b
efore
the
curren
t
time.
step
[c
ount
]
Run
the
program
and
stop
at
the
next
ev
en
t.
With
an
argumen
t,
do
it
c
ount
times.
backstep
[c
ount
]
Run
the
program
bac
kw
ard
and
stop
at
the
previous
ev
en
t.
With
an
argumen
t,
do
it
c
ount
times.
next
[c
ount
]
Run
the
program
and
stop
at
the
next
ev
en
t,
skipping
o
v
er
function
calls.
With
an
argumen
t,
do
it
c
ount
times.
finish
Run
the
program
un
til
the
curren
t
function
returns.
	..
Time
tra
v
el
Y
ou
can
jump
directly
to
a
giv
en
time,
without
stopping
on
breakp
oin
ts,
using
the
goto
command.
As
y
ou
mo
v
e
through
the
program,
the
debugger
main
tains
an
history
of
the
successiv
e
times
y
ou
stop
at.
The
last
command
can
b
e
used
to
revisit
these
times:
eac
h
last
command
mo
v
es
one
step
bac
k
through
the
history
.
That
is
useful
mainly
to
undo
commands
suc
h
as
step
and
next.
goto
time
Jump
to
the
giv
en
time.
last
[c
ount
]
Go
bac
k
to
the
latest
time
recorded
in
the
execution
history
.
With
an
argumen
t,
do
it
c
ount
times.
set
history
size
Set
the
size
of
the
execution
history
.
	..
Killing
the
program
kill
Kill
the
program
b
eing
executed.
This
command
is
mainly
useful
if
y
ou
wish
to
recompile
the
program
without
lea
ving
the
debugger.


	.
Breakp
oin
ts
A
breakp
oin
t
causes
the
program
to
stop
whenev
er
a
certain
p
oin
t
in
the
program
is
reac
hed.
It
can
b
e
set
in
sev
eral
w
a
ys
using
the
break
command.
Breakp
oin
ts
are
assigned
n
um
b
ers
when
set,
for
further
reference.
break
Set
a
breakp
oin
t
at
the
curren
t
p
osition
in
the
program
execution.
The
curren
t
p
osition
m
ust
b
e
on
an
ev
en
t
(i.e.,
neither
at
the
b
eginning,
nor
at
the
end
of
the
program).
break
function
Set
a
breakp
oin
t
at
the
b
eginning
of
function.
This
w
orks
only
when
the
functional
v
alue
of
the
iden
tier
function
has
b
een
computed
and
assigned
to
the
iden
tier.
Hence
this
command
cannot
b
e
used
at
the
v
ery
b
eginning
of
the
program
execution,
when
all
iden
tiers
are
still
undened.
Moreo
v
er,
C
functions
are
not
recognized
b
y
the
debugger.
break
@
[mo
dule
]
line
Set
a
breakp
oin
t
in
mo
dule
mo
dule
(or
in
the
curren
t
mo
dule
if
mo
dule
is
not
giv
en),
at
the
rst
ev
en
t
of
line
line.
break
@
[mo
dule
]
line
c
olumn
Set
a
breakp
oin
t
in
mo
dule
mo
dule
(or
in
the
curren
t
mo
dule
if
mo
dule
is
not
giv
en),
at
the
ev
en
t
closest
to
line
line,
column
c
olumn.
break
@
[mo
dule
]
#
char
acter
Set
a
breakp
oin
t
in
mo
dule
mo
dule
at
the
ev
en
t
closest
to
c
haracter
n
um
b
er
char
acter.
break
addr
ess
Set
a
breakp
oin
t
at
the
co
de
address
addr
ess.
delete
[br
e
akp
oint-numb
ers
]
Delete
the
sp
ecied
breakp
oin
ts.
Without
argumen
t,
all
breakp
oin
ts
are
deleted
(after
asking
for
conrmation).
info
breakpoints
Prin
t
the
list
of
all
breakp
oin
ts.
	.
The
call
stac
k
Eac
h
time
the
program
p
erforms
a
function
application,
it
sa
v
es
the
lo
cation
of
the
application
(the
return
address)
in
a
blo
c
k
of
data
called
a
stac
k
frame.
The
frame
also
con
tains
the
lo
cal
v
ariables
of
the
caller
function.
All
the
frames
are
allo
cated
in
a
region
of
memory
called
the
call
stac
k.
The
command
backtrace
(or
bt)
displa
ys
parts
of
the
call
stac
k.
A
t
an
y
time,
one
of
the
stac
k
frames
is
\selected"
b
y
the
debugger;
sev
eral
debugger
commands
refer
implicitly
to
the
selected
frame.
In
particular,
whenev
er
y
ou
ask
the
debugger
for
the
v
alue
of
a
lo
cal
v
ariable,
the
v
alue
is
found
in
the
selected
frame.
The
commands
frame,
up
and
down
select
whic
hev
er
frame
y
ou
are
in
terested
in.
When
the
program
stops,
the
debugger
automatically
selects
the
curren
tly
executing
frame
and
describ
es
it
briey
as
the
frame
command
do
es.

Chapter
	.
The
debugger
(camldebug)

frame
Describ
e
the
curren
tly
selected
stac
k
frame.
frame
fr
ame-numb
er
Select
a
stac
k
frame
b
y
n
um
b
er
and
describ
e
it.
The
frame
curren
tly
executing
when
the
program
stopp
ed
has
n
um
b
er
0;
its
caller
has
n
um
b
er
;
and
so
on
up
the
call
stac
k.
backtrace
[c
ount
],
bt
[c
ount
]
Prin
t
the
call
stac
k.
This
is
useful
to
see
whic
h
sequence
of
function
calls
led
to
the
curren
tly
executing
frame.
With
a
p
ositiv
e
argumen
t,
prin
t
only
the
innermost
c
ount
frames.
With
a
negativ
e
argumen
t,
prin
t
only
the
outermost
-c
ount
frames.
up
[c
ount
]
Select
and
displa
y
the
stac
k
frame
just
\ab
o
v
e"
the
selected
frame,
that
is,
the
frame
that
called
the
selected
frame.
An
argumen
t
sa
ys
ho
w
man
y
frames
to
go
up.
down
[c
ount
]
Select
and
displa
y
the
stac
k
frame
just
\b
elo
w"
the
selected
frame,
that
is,
the
frame
that
w
as
called
b
y
the
selected
frame.
An
argumen
t
sa
ys
ho
w
man
y
frames
to
go
do
wn.
	.
Examining
v
ariable
v
alues
The
debugger
can
prin
t
the
curren
t
v
alue
of
a
program
v
ariable
(either
a
global
v
ariable
or
a
lo
cal
v
ariable
relativ
e
to
the
selected
stac
k
frame).
It
can
also
prin
t
selected
parts
of
a
v
alue
b
y
matc
hing
it
against
a
pattern.
V
ariable
names
can
b
e
sp
ecied
either
fully
qualied
(mo
dule-name__var-name)
or
unqualied
(var-name).
Unqualied
names
either
corresp
ond
to
lo
cal
v
ariables,
or
are
completed
in
to
fully
qualied
global
names
b
y
lo
oking
at
a
list
of
\op
ened"
mo
dules
that
dene
the
same
name
(see
section
	..
for
ho
w
to
op
en
mo
dules
in
the
debugger.)
The
completion
follo
ws
the
same
rules
as
in
the
Caml
Ligh
t
language
(see
section
.).
print
variables
Prin
t
the
v
alues
of
the
giv
en
v
ariables.
match
variable
p
attern
Matc
h
the
v
alue
of
the
giv
en
v
ariable
against
a
pattern,
and
prin
t
the
v
alues
b
ound
to
the
iden
tiers
in
the
pattern.
The
syn
tax
of
patterns
for
the
match
command
extends
the
one
for
Caml
Ligh
t
patterns:


pattern
::=
iden
t
j
_
j
(
pattern
)
j
ncconstr
pattern
j
pattern
,
pattern
f,
patterng
j
{
lab
el
=
pattern
f;
lab
el
=
patterng
}
j
[
]
j
[
pattern
f;
patterng
]
j
pattern
::
pattern
j
#
in
teger-literal
pattern
j
>
pattern
The
pattern
iden
t
,
where
iden
t
is
an
iden
tier,
matc
hes
an
y
v
alue,
and
binds
the
iden
tier
to
this
v
alue.
The
pattern
#
n
pattern
matc
hes
a
list,
a
v
ector
or
a
tuple
whose
n-th
elemen
t
matc
hes
pattern.
The
pattern
>
pattern
matc
hes
an
y
constructed
v
alue
whose
argumen
t
matc
hes
pattern
,
regardless
of
the
constructor;
it
is
a
shortcut
for
skipping
a
constructor.
Example:
assuming
the
v
alue
of
a
is
Constr{x
=
[;;;]},
the
command
match
a
>
{x
=
#

k}
prin
ts
k
=
.
set
print_depth
d
Limit
the
prin
ting
of
v
alues
to
a
maximal
depth
of
d.
set
print_length
l
Limit
the
prin
ting
of
v
alues
to
at
most
l
no
des
prin
ted.
	.
Con
trolling
the
debugger
	..
Setting
the
program
name
and
argumen
ts
set
program
le
Set
the
program
name
to
le.
set
arguments
ar
guments
Giv
e
ar
guments
as
command-line
argumen
ts
for
the
program.
A
shell
is
used
to
pass
the
argumen
ts
to
the
debugged
program.
Y
ou
can
therefore
use
wildcards,
shell
v
ariables,
and
le
redirections
inside
the
argumen
ts.
T
o
debug
programs
that
read
from
standard
input,
it
is
recommended
to
redirect
their
input
from
a
le
(using
set
arguments
<
input-file),
otherwise
input
to
the
program
and
input
to
the
debugger
are
not
prop
erly
separated.
	..
Ho
w
programs
are
loaded
The
loadingmode
v
ariable
con
trols
ho
w
the
program
is
executed.
set
loadingmode
direct
The
program
is
run
directly
b
y
the
debugger.
This
is
the
default
mo
de.

Chapter
	.
The
debugger
(camldebug)

set
loadingmode
runtime
The
debugger
execute
the
Caml
Ligh
t
run
time
camlrun
on
the
program.
Rarely
useful;
moreo
v
er
it
prev
en
ts
the
debugging
of
programs
compiled
in
\custom
run
time"
mo
de.
set
loadingmode
manual
The
user
starts
man
ually
the
program,
when
ask
ed
b
y
the
debugger.
Allo
ws
remote
debugging
(see
section
	..).
	..
Searc
h
path
for
les
The
debugger
searc
hes
for
source
les
and
compiled
in
terface
les
in
a
list
of
directories,
the
searc
h
path.
The
searc
h
path
initially
con
tains
the
curren
t
directory
.
and
the
standard
library
directory
.
The
directory
command
adds
directories
to
the
path.
Whenev
er
the
searc
h
path
is
mo
died,
the
debugger
will
clear
an
y
information
it
ma
y
ha
v
e
cac
hed
ab
out
the
les.
directory
dir
e
ctorynames
Add
the
giv
en
directories
to
the
searc
h
path.
These
directories
are
added
at
the
fron
t,
and
will
therefore
b
e
searc
hed
rst.
directory
Reset
the
searc
h
path.
This
requires
conrmation.
	..
W
orking
directory
Eac
h
time
a
program
is
started
in
the
debugger,
it
inherits
its
w
orking
directory
from
the
curren
t
w
orking
directory
of
the
debugger.
This
w
orking
directory
is
initially
whatev
er
it
inherited
from
its
paren
t
pro
cess
(t
ypically
the
shell),
but
y
ou
can
sp
ecify
a
new
w
orking
directory
in
the
debugger
with
the
cd
command
or
the
-cd
command-line
option.
cd
dir
e
ctory
Set
the
w
orking
directory
for
camldebug
to
dir
e
ctory.
pwd
Prin
t
the
w
orking
directory
for
camldebug.
	..
Mo
dule
managemen
t
Lik
e
the
Caml
Ligh
t
compiler,
the
debugger
main
tains
a
list
of
op
ened
mo
dules
in
order
to
resolv
es
v
ariable
name
am
biguities.
The
op
ened
mo
dules
also
aect
the
prin
ting
of
v
alues:
whether
fully
qualied
names
or
short
names
are
used
for
constructors
and
record
lab
els.
When
a
program
is
executed,
the
debugger
automatically
op
ens
the
mo
dules
of
the
standard
library
it
uses.
open
mo
dules
Op
en
the
giv
en
mo
dules.
close
mo
dules
Close
the
giv
en
mo
dules.


info
modules
List
the
mo
dules
used
b
y
the
program,
and
the
op
en
mo
dules.
	..
T
urning
rev
erse
execution
on
and
o
In
some
cases,
y
ou
ma
y
w
an
t
to
turn
rev
erse
execution
o.
This
sp
eeds
up
the
program
execution,
and
is
also
sometimes
useful
for
in
teractiv
e
programs.
Normally
,
the
debugger
tak
es
c
hec
kp
oin
ts
of
the
program
state
from
time
to
time.
That
is,
it
mak
es
a
cop
y
of
the
curren
t
state
of
the
program
(using
the
Unix
system
call
fork).
If
the
v
ariable
che
ckp
oints
is
set
to
off,
the
debugger
will
not
tak
e
an
y
c
hec
kp
oin
ts.
set
checkpoints
on/o
Select
whether
the
debugger
mak
es
c
hec
kp
oin
ts
or
not.
	..
Comm
unication
b
et
w
een
the
debugger
and
the
program
The
debugger
comm
unicate
with
the
program
b
eing
debugged
through
a
Unix
so
c
k
et.
Y
ou
ma
y
need
to
c
hange
the
so
c
k
et
name,
for
example
if
y
ou
need
to
run
the
debugger
on
a
mac
hine
and
y
our
program
on
another.
set
socket
so
cket
Use
so
cket
for
comm
unication
with
the
program.
so
cket
can
b
e
either
a
le
name,
or
an
In
ternet
p
ort
sp
ecication
host:p
ort,
where
host
is
a
host
name
or
an
In
ternet
address
in
dot
notation,
and
p
ort
is
a
p
ort
n
um
b
er
on
the
host.
On
the
debugged
program
side,
the
so
c
k
et
name
is
passed
either
b
y
the
-D
command
line
option
to
camlrun,
or
through
the
CAML_DEBUG_SOCKET
en
vironmen
t
v
ariable.
	..
Fine-tuning
the
debugger
Sev
eral
v
ariables
enables
to
ne-tune
the
debugger.
Reasonable
defaults
are
pro
vided,
and
y
ou
should
normally
not
ha
v
e
to
c
hange
them.
set
processcount
c
ount
Set
the
maxim
um
n
um
b
er
of
c
hec
kp
oin
ts
to
c
ount.
More
c
hec
kp
oin
ts
facilitate
going
far
bac
k
in
time,
but
use
more
memory
and
create
more
Unix
pro
cesses.
As
c
hec
kp
oin
ting
is
quite
exp
ensiv
e,
it
m
ust
not
b
e
done
to
o
often.
On
the
other
hand,
bac
kw
ard
execution
is
faster
when
c
hec
kp
oin
ts
are
tak
en
more
often.
In
particular,
bac
kw
ard
single-stepping
is
more
resp
onsiv
e
when
man
y
c
hec
kp
oin
ts
ha
v
e
b
een
tak
en
just
b
efore
the
curren
t
time.
T
o
ne-
tune
the
c
hec
kp
oin
ting
strategy
,
the
debugger
do
es
not
tak
e
c
hec
kp
oin
ts
at
the
same
frequency
for
long
displacemen
ts
(e.g.
run)
and
small
ones
(e.g.
step).
The
t
w
o
v
ariables
bigstep
and
smallstep
con
tain
the
n
um
b
er
of
ev
en
ts
b
et
w
een
t
w
o
c
hec
kp
oin
ts
in
eac
h
case.
set
bigstep
c
ount
Set
the
n
um
b
er
of
ev
en
ts
b
et
w
een
t
w
o
c
hec
kp
oin
ts
for
long
displacemen
ts.

Chapter
	.
The
debugger
(camldebug)
	
set
smallstep
c
ount
Set
the
n
um
b
er
of
ev
en
ts
b
et
w
een
t
w
o
c
hec
kp
oin
ts
for
small
displacemen
ts.
The
follo
wing
commands
displa
y
information
on
c
hec
kp
oin
ts
and
ev
en
ts:
info
checkpoints
Prin
t
a
list
of
c
hec
kp
oin
ts.
info
events
[mo
dule
]
Prin
t
the
list
of
ev
en
ts
in
the
giv
en
mo
dule
(the
curren
t
mo
dule,
b
y
default).
	.	
Miscell
aneous
commands
list
[mo
dule
]
[b
e
ginning
]
[end
]
List
the
source
of
mo
dule
mo
dule,
from
line
n
um
b
er
b
e
ginning
to
line
n
um
b
er
end.
By
default,
0
lines
of
the
curren
t
mo
dule
are
displa
y
ed,
starting
0
lines
b
efore
the
curren
t
p
osition.
source
lename
Read
debugger
commands
from
the
script
lename.

	0

Chapter
0
Proling
(camlpro)
This
c
hapter
describ
es
ho
w
the
execution
of
Caml
Ligh
t
programs
can
b
e
proled,
b
y
recording
ho
w
man
y
times
functions
are
called,
branc
hes
of
conditionals
are
tak
en,
:
:
:
Mac:
This
command
is
not
a
v
ailable.
PC:
This
command
is
not
a
v
ailable.
0.
Compiling
for
proling
Before
proling
an
execution,
the
program
m
ust
b
e
compiled
in
proling
mo
de,
using
the
-p
option
to
the
batc
h
compiler
camlc
(see
c
hapter
).
When
compiling
mo
dules
separately
,
the
-p
option
m
ust
b
e
giv
en
b
oth
when
compiling
the
mo
dules
(pro
duction
of
.zo
les)
and
when
linking
them
together.
The
amoun
t
of
proling
information
can
b
e
con
trolled
b
y
adding
one
or
sev
eral
letters
after
the
-p
option,
indicating
whic
h
parts
of
the
program
should
b
e
proled:
a
all
options
f
function
calls
:
a
coun
t
p
oin
t
is
set
at
the
b
eginning
of
function
b
o
dies
i
if
:
:
:
then
:
:
:
else
:
:
:
:
coun
t
p
oin
ts
are
set
in
b
oth
then
branc
h
and
else
branc
h
l
while,
for
lo
ops:
a
coun
t
p
oin
t
is
set
at
the
b
eginning
of
the
lo
op
b
o
dy
m
matc
h
branc
hes:
a
coun
t
p
oin
t
is
set
at
the
b
eginning
of
the
b
o
dy
of
eac
h
branc
h
t
try
:
:
:
with
:
:
:
branc
hes:
a
coun
t
p
oin
t
is
set
at
the
b
eginning
of
the
b
o
dy
of
eac
h
branc
h
F
or
instance,
compiling
with
-pfilm
proles
function
calls,
if:
:
:
then
:
:
:
else:
:
:
,
lo
ops
and
pattern
matc
hing.
The
-p
option
without
additional
letters
defaults
to
-pfm,
meaning
that
only
function
calls
and
pattern
matc
hing
are
proled.
	

	
0.
Proling
an
execution
Running
a
b
yteco
de
executable
le
that
has
b
een
compiled
and
link
ed
with
-p
records
the
execution
coun
ts
for
the
sp
ecied
parts
of
the
program
and
sa
v
es
them
in
a
le
called
camlpro.dump
in
the
curren
t
directory
.
More
precisely
,
the
dump
le
camlpro.dump
is
written
when
the
io__exit
function
is
called.
The
link
er,
called
with
the
-p
option,
adds
io__exit
0
as
the
last
phrase
of
the
b
yteco
de
executable,
in
case
the
original
program
nev
er
calls
io__exit.
Ho
w
ev
er,
if
the
program
terminates
with
an
uncaught
exception,
the
dump
le
will
not
b
e
pro
duced.
If
a
compatible
dump
le
already
exists
in
the
curren
t
directory
,
then
the
proling
information
is
accum
ulated
in
this
dump
le.
This
allo
ws,
for
instance,
the
proling
of
sev
eral
executions
of
a
program
on
dieren
t
inputs.
0.
Prin
ting
proling
information
The
camlpro
command
pro
duces
a
source
listing
of
the
program
mo
dules
where
execution
coun
ts
ha
v
e
b
een
inserted
as
commen
ts.
F
or
instance,
camlpro
foo.ml
prin
ts
the
source
co
de
for
the
foo
mo
dule,
with
commen
ts
indicating
ho
w
man
y
times
the
functions
in
this
mo
dule
ha
v
e
b
een
called.
Naturally
,
this
information
is
accurate
only
if
the
source
le
has
not
b
een
mo
died
since
the
proling
execution
to
ok
place.
The
follo
wing
options
are
recognized
b
y
camlpro:
compiler
options
-stdlib,
-I,
-include,
-O,
-open,
-i,
-lang
See
c
hapter

for
the
detailed
usage.
-f
dumple
Sp
ecies
an
alternate
dump
le
of
proling
information
-F
string
Sp
ecies
an
additional
string
to
b
e
output
with
proling
information.
By
default,
camlp
ro
will
annotate
progams
with
commen
ts
of
the
form
(*
n
*)
where
n
is
the
coun
ter
v
alue
for
a
proling
p
oin
t.
With
option
-F
s,
the
annotation
will
b
e
(*
sn
*).
An
additional
argumen
t
sp
ecies
the
output
le.
F
or
instance
camlpro
-f
../test/camlpro.dump
foo.ml
foo_profiled.ml
will
sa
v
e
the
annotated
program
in
le
foo_
profiled.ml.
Otherwise,
the
annotated
program
is
written
on
the
standard
output.
0.
Kno
wn
bugs
The
follo
wing
situation
(le
x.ml)

Chapter
0.
Proling
(camlpro)
	
let
a
=
;;
x__a
;;
will
break
the
proler.
More
precisely
,
one
should
a
v
oid
to
refer
to
sym
b
ols
of
the
curren
t
mo
dule
with
the
qualied
sym
b
ol
syn
tax.

	

Chapter

Using
Caml
Ligh
t
under
Emacs
This
c
hapter
describ
es
ho
w
Caml
Ligh
t
can
b
e
used
in
conjunction
with
Gn
u
Emacs
v
ersion
	
(v
ersion

is
also
partially
supp
orted).
Unix:
The
Emacs
Lisp
les
implemen
ting
the
Caml/Emacs
in
terface
are
in
contrib/camlmode
in
the
distribution.
Mac:
The
Caml/Emacs
in
terface
is
not
a
v
ailable.
PC:
The
Caml/Emacs
in
terface
is
not
a
v
ailable.
.
Up
dating
y
our
.emacs
The
follo
wing
initializations
m
ust
b
e
added
to
y
our
.emacs
le:
(setq
auto-mode-alist
(cons
'("\\.ml[iylp]?"
.
caml-mode)
auto-mode-alist))
(autoload
'caml-mode
"caml"
"Major
mode
for
editing
Caml
code."
t)
(autoload
'run-caml
"inf-caml"
"Run
an
inferior
Caml
process."
t)
(autoload
'camldebug
"camldebug"
"Run
the
Caml
debugger."
t)
.
The
caml
editing
mo
de
The
caml-mode
function
is
a
ma
jor
editing
mo
de
for
Caml
source
les.
It
pro
vides
the
correct
syn
tax
tables,
commen
t
syn
tax,
:
:
:
for
the
Caml
language.
An
extremely
crude
inden
tation
facilit
y
is
pro
vided,
as
w
ell
as
a
sligh
tly
enhanced
next-error
command
(to
displa
y
the
lo
cation
of
a
compilation
error).
The
follo
wing
k
ey
bindings
are
p
erformed:
TAB
(function
caml-indent-command)
A
t
the
b
eginning
of
a
line,
inden
t
that
line
lik
e
the
line
ab
o
v
e.
Successiv
e
TABs
increase
the
inden
tation
lev
el
b
y

spaces
(b
y
default;
can
b
e
set
with
the
caml-mode-indentation
v
ariable).
M-TAB
(function
caml-unindent-command)
Decrease
the
inden
tation
lev
el
of
the
curren
t
phrase.
	

	
C-x
`
(function
caml-next-error)
Displa
y
the
next
compilation
error,
just
as
next-error
do
es.
In
addition,
it
puts
the
p
oin
t
and
the
mark
around
the
exact
lo
cation
of
the
error
(the
sub
expression
that
caused
the
error).
Under
Emacs
	,
that
sub
expression
is
also
highligh
ted.
M-C-h
(function
caml-mark-phrase)
Mark
the
Caml
phrase
that
con
tains
the
p
oin
t:
the
p
oin
t
is
put
at
the
b
eginning
of
the
phrase
and
the
mark
at
the
end.
Phrases
are
delimited
b
y
;;
(the
nal
double-semicolon).
This
function
do
es
not
prop
erly
ignore
;;
inside
string
literals
or
commen
ts.
C-x
SPC
When
the
Caml
debugger
is
running
as
an
inferior
pro
cess
(section
.
b
elo
w),
set
a
break-
p
oin
t
at
the
curren
t
p
osition
of
the
p
oin
t.
M-C-x
or
C-c
C-e
(function
caml-eval-phrase)
When
a
Caml
toplev
el
is
running
as
an
inferior
pro
cess
(section
.
b
elo
w),
send
it
the
the
Caml
phrase
that
con
tains
the
p
oin
t.
The
phrase
will
then
b
e
ev
aluated
b
y
the
inferior
toplev
el
as
usual.
The
phrase
is
delimited
b
y
;;
as
describ
ed
for
the
caml-mark-phrase
command.
C-c
C-r
(function
caml-eval-region)
Send
the
region
to
a
Caml
toplev
el
running
in
an
inferior
pro
cess.
.
Running
the
toplev
el
as
an
inferior
pro
cess
M-x
run-caml
starts
a
Caml
toplev
el
with
input
and
output
in
an
Emacs
buer
named
*inferior-caml*.
This
giv
es
y
ou
the
full
p
o
w
er
of
Emacs
to
edit
the
input
to
the
Caml
toplev
el.
An
history
of
input
lines
is
main
tained,
as
in
Shell
mo
de.
This
includes
the
follo
wing
commands
(see
the
function
comint-mode
for
a
complete
description):
RET
Send
the
curren
t
line
to
the
toplev
el.
M-n
and
M-p
Mo
v
e
to
the
next
or
previous
line
in
the
history
.
M-r
and
M-s
Regexp
searc
h
in
the
history
.
C-c
C-c
Send
a
break
(in
terrupt
signal)
to
the
Caml
toplev
el.
Phrases
can
also
b
e
sen
t
to
the
Caml
toplev
el
for
ev
aluation
from
an
y
buer
in
Caml
mo
de,
using
M-C-x,
C-c
C-e
or
C-c
C-r.

Chapter
.
Using
Caml
Ligh
t
under
Emacs
	
.
Running
the
debugger
as
an
inferior
pro
cess
The
Caml
debugger
is
started
b
y
the
command
M-x
camldebug,
with
argumen
t
the
name
of
the
executable
le
pr
o
gname
to
debug.
Comm
unication
with
the
debugger
tak
es
place
in
an
Emacs
buer
named
*camldebug-pr
o
gname*.
The
editing
and
history
facilities
of
Shell
mo
de
are
a
v
ailable
for
in
teracting
with
the
debugger.
In
addition,
Emacs
displa
ys
the
source
les
con
taining
the
curren
t
ev
en
t
(the
curren
t
p
osi-
tion
in
the
program
execution)
and
highligh
ts
the
lo
cation
of
the
ev
en
t.
This
displa
y
is
up
dated
sync
hronously
with
the
debugger
action.
The
follo
wing
bindings
for
the
most
common
debugger
commands
are
a
v
ailable
in
the
*camldebug-pr
o
gname*
buer
(see
section
	.
for
a
full
explanation
of
the
commands):
M-r
run
command:
execute
the
program
forw
ard.
M-s
step
command:
execute
the
program
one
step
forw
ard.
M-b
back
command:
execute
the
program
one
step
bac
kw
ard.
M-l
last
command:
go
bac
k
one
step
in
the
command
history
.
C-c
>
down
command:
select
the
stac
k
frame
b
elo
w
the
curren
t
frame.
C-c
<
up
command:
select
the
stac
k
frame
ab
o
v
e
the
curren
t
frame.
C-c
C-f
finish
command:
run
till
the
curren
t
function
returns.
In
a
buer
in
Caml
editing
mo
de,
C-x
SPC
sets
a
breakp
oin
t
at
the
curren
t
p
osition
of
the
p
oin
t.

	

Chapter

In
terfacing
C
with
Caml
Ligh
t
This
c
hapter
describ
es
ho
w
user-dened
primitiv
es,
written
in
C,
can
b
e
added
to
the
Caml
Ligh
t
run
time
system
and
called
from
Caml
Ligh
t
co
de.
.
Ov
erview
and
compilation
information
..
Declaring
primitiv
es
User
primitiv
es
are
declared
in
a
mo
dule
in
terface
(a
.mli
le),
in
the
same
w
a
y
as
a
regular
ML
v
alue,
except
that
the
declaration
is
follo
w
ed
b
y
the
=
sign,
the
function
arit
y
(n
um
b
er
of
argumen
ts),
and
the
name
of
the
corresp
onding
C
function.
F
or
instance,
here
is
ho
w
the
input
primitiv
e
is
declared
in
the
in
terface
for
the
standard
library
mo
dule
io:
value
input
:
in_channel
->
string
->
int
->
int
->
int
=

"input"
Primitiv
es
with
sev
eral
argumen
ts
are
alw
a
ys
curried.
The
C
function
do
es
not
necessarily
ha
v
e
the
same
name
as
the
ML
function.
V
alues
th
us
declared
primitiv
e
in
a
mo
dule
in
terface
m
ust
not
b
e
implemen
ted
in
the
mo
dule
implemen
tation
(the
.ml
le).
They
can
b
e
used
inside
the
mo
dule
implemen
tation.
..
Impleme
n
ting
primitiv
es
User
primitiv
es
with
arit
y
n


are
implemen
ted
b
y
C
functions
that
tak
e
n
argumen
ts
of
t
yp
e
value,
and
return
a
result
of
t
yp
e
value.
The
t
yp
e
value
is
the
t
yp
e
of
the
represen
tations
for
Caml
Ligh
t
v
alues.
It
enco
des
ob
jects
of
sev
eral
base
t
yp
es
(in
tegers,
oating-p
oin
t
n
um
b
ers,
strings,
:
:
:
),
as
w
ell
as
Caml
Ligh
t
data
structures.
The
t
yp
e
value
and
the
asso
ciated
con
v
ersion
functions
and
macros
are
describ
ed
in
details
b
elo
w.
F
or
instance,
here
is
the
declaration
for
the
C
function
implemen
ting
the
input
primitiv
e:
value
input(channel,
buffer,
offset,
length)
value
channel,
buffer,
offset,
length;
{
...
}
		

00
When
the
primitiv
e
function
is
applied
in
a
Caml
Ligh
t
program,
the
C
function
is
called
with
the
v
alues
of
the
expressions
to
whic
h
the
primitiv
e
is
applied
as
argumen
ts.
The
v
alue
returned
b
y
the
function
is
passed
bac
k
to
the
Caml
Ligh
t
program
as
the
result
of
the
function
application.
User
primitiv
es
with
arit
y
greater
than

are
implemen
ted
b
y
C
functions
that
receiv
e
t
w
o
argumen
ts:
a
p
oin
ter
to
an
arra
y
of
Caml
Ligh
t
v
alues
(the
v
alues
for
the
argumen
ts),
and
an
in
teger
whic
h
is
the
n
um
b
er
of
argumen
ts
pro
vided:
value
prim_with_lots_of_args(argv
,
argn)
value
*
argv;
int
argn;
{
...
argv[0]
...;
/*
The
first
argument
*/
...
argv[]
...;
/*
The
seventh
argument
*/
}
Implemen
ting
a
user
primitiv
e
is
actually
t
w
o
separate
tasks:
on
the
one
hand,
deco
ding
the
argumen
ts
to
extract
C
v
alues
from
the
giv
en
Caml
Ligh
t
v
alues,
and
enco
ding
the
return
v
alue
as
a
Caml
Ligh
t
v
alue;
on
the
other
hand,
actually
computing
the
result
from
the
argumen
ts.
Except
for
v
ery
simple
primitiv
es,
it
is
often
preferable
to
ha
v
e
t
w
o
distinct
C
functions
to
implemen
t
these
t
w
o
tasks.
The
rst
function
actually
implemen
ts
the
primitiv
e,
taking
nativ
e
C
v
alues
as
argumen
ts
and
returning
a
nativ
e
C
v
alue.
The
second
function,
often
called
the
\stub
co
de",
is
a
simple
wrapp
er
around
the
rst
function
that
con
v
erts
its
argumen
ts
from
Caml
Ligh
t
v
alues
to
C
v
alues,
call
the
rst
function,
and
con
v
ert
the
returned
C
v
alue
to
Caml
Ligh
t
v
alue.
F
or
instance,
here
is
the
stub
co
de
for
the
input
primitiv
e:
value
input(channel,
buffer,
offset,
length)
value
channel,
buffer,
offset,
length;
{
return
Val_long(getblock((struc
t
channel
*)
channel,
&Byte(buffer,
Long_val(offset)),
Long_val(length)));
}
(Here,
Val_long,
Long_val
and
so
on
are
con
v
ersion
macros
for
the
t
yp
e
value,
that
will
b
e
describ
ed
later.)
The
hard
w
ork
is
p
erformed
b
y
the
function
getblock,
whic
h
is
declared
as:
long
getblock(channel,
p,
n)
struct
channel
*
channel;
char
*
p;
long
n;
{
...
}
T
o
write
C
co
de
that
op
erates
on
Caml
Ligh
t
v
alues,
the
follo
wing
include
les
are
pro
vided:

Chapter
.
In
terfacing
C
with
Caml
Ligh
t
0
Include
le
Pro
vides
mlvalues.h
denition
of
the
value
t
yp
e,
and
con
v
ersion
macros
alloc.h
allo
cation
functions
(to
create
structured
Caml
Ligh
t
ob
jects)
memory.h
miscellaneous
memory-related
functions
(for
in-place
mo
dication
of
structures,
etc).
These
les
reside
in
the
Caml
Ligh
t
standard
library
directory
(usually
/usr/local/lib/caml-light
).
..
Linking
C
co
de
with
Caml
Ligh
t
co
de
The
Caml
Ligh
t
run
time
system
comprises
three
main
parts:
the
b
yteco
de
in
terpreter,
the
mem-
ory
manager,
and
a
set
of
C
functions
that
implemen
t
the
primitiv
e
op
erations.
Some
b
yteco
de
instructions
are
pro
vided
to
call
these
C
functions,
designated
b
y
their
oset
in
a
table
of
functions
(the
table
of
primitiv
es).
In
the
default
mo
de,
the
Caml
Ligh
t
link
er
pro
duces
b
yteco
de
for
the
standard
run
time
system,
with
a
standard
set
of
primitiv
es.
References
to
primitiv
es
that
are
not
in
this
standard
set
result
in
the
\una
v
ailable
C
primitiv
e"
error.
In
the
\custom
run
time"
mo
de,
the
Caml
Ligh
t
link
er
scans
the
b
yteco
de
ob
ject
les
(.zo
les)
and
determines
the
set
of
required
primitiv
es.
Then,
it
builds
a
suitable
run
time
system,
b
y
calling
the
nativ
e
co
de
link
er
with:

the
table
of
the
required
primitiv
es

a
library
that
pro
vides
the
b
yteco
de
in
terpreter,
the
memory
manager,
and
the
standard
primitiv
es

libraries
and
ob
ject
co
de
les
(.o
les)
men
tioned
on
the
command
line
for
the
Caml
Ligh
t
link
er,
that
pro
vide
implemen
tations
for
the
user's
primitiv
es.
This
builds
a
run
time
system
with
the
required
primitiv
es.
The
Caml
Ligh
t
link
er
generates
b
yte-
co
de
for
this
custom
run
time
system.
The
b
yteco
de
is
app
ended
to
the
end
of
the
custom
run
time
system,
so
that
it
will
b
e
automatically
executed
when
the
output
le
(custom
run
time
+
b
yteco
de)
is
launc
hed.
T
o
link
in
\custom
run
time"
mo
de,
execute
the
camlc
command
with:

the
-custom
option

the
names
of
the
desired
Caml
Ligh
t
ob
ject
les
(.zo
les)

the
names
of
the
C
ob
ject
les
and
libraries
(.o
and
.a
les)
that
implemen
t
the
required
primitiv
es.
(Libraries
can
also
b
e
sp
ecied
with
the
usual
-l
syn
tax.)
.
The
value
t
yp
e
All
Caml
Ligh
t
ob
jects
are
represen
ted
b
y
the
C
t
yp
e
value,
dened
in
the
include
le
mlvalues.h,
along
with
macros
to
manipulate
v
alues
of
that
t
yp
e.
An
ob
ject
of
t
yp
e
value
is
either:

an
un
b
o
xed
in
teger

0

a
p
oin
ter
to
a
blo
c
k
inside
the
heap
(suc
h
as
the
blo
c
ks
allo
cated
through
one
of
the
alloc_*
functions
b
elo
w)

a
p
oin
ter
to
an
ob
ject
outside
the
heap
(e.g.,
a
p
oin
ter
to
a
blo
c
k
allo
cated
b
y
malloc,
or
to
a
C
v
ariable).
..
In
teger
v
alues
In
teger
v
alues
enco
de
-bit
signed
in
tegers.
They
are
un
b
o
xed
(unallo
cated).
..
Blo
c
ks
Blo
c
ks
in
the
heap
are
garbage-collected,
and
therefore
ha
v
e
strict
structure
constrain
ts.
Eac
h
blo
c
k
includes
a
header
con
taining
the
size
of
the
blo
c
k
(in
w
ords),
and
the
tag
of
the
blo
c
k.
The
tag
go
v
erns
ho
w
the
con
ten
ts
of
the
blo
c
ks
are
structured.
A
tag
lo
w
er
than
No_scan_tag
indicates
a
structured
blo
c
k,
con
taining
w
ell-formed
v
alues,
whic
h
is
recursiv
ely
tra
v
ersed
b
y
the
garbage
collector.
A
tag
greater
than
or
equal
to
No_scan_tag
indicates
a
ra
w
blo
c
k,
whose
con
ten
ts
are
not
scanned
b
y
the
garbage
collector.
F
or
the
b
enets
of
ad-ho
c
p
olymorphic
primitiv
es
suc
h
as
equalit
y
and
structured
input-output,
structured
and
ra
w
blo
c
ks
are
further
classied
according
to
their
tags
as
follo
ws:
T
ag
Con
ten
ts
of
the
blo
c
k
0
to
No_scan_tag
 
A
structured
blo
c
k
(an
arra
y
of
Caml
Ligh
t
ob
jects).
Eac
h
eld
is
a
value.
Closure_tag
A
closure
represen
ting
a
functional
v
alue.
The
rst
w
ord
is
a
p
oin
ter
to
a
piece
of
b
yteco
de,
the
second
w
ord
is
a
value
con
taining
the
en
vironmen
t.
String_tag
A
c
haracter
string.
Double_tag
A
double-precision
oating-p
oin
t
n
um
b
er.
Abstract_tag
A
blo
c
k
represen
ting
an
abstract
datat
yp
e.
Final_tag
A
blo
c
k
represen
ting
an
abstract
datat
yp
e
with
a
\naliza-
tion"
function,
to
b
e
called
when
the
blo
c
k
is
deallo
cated.
..
P
oin
ters
to
outside
the
heap
An
y
p
oin
ter
to
outside
the
heap
can
b
e
safely
cast
to
and
from
the
t
yp
e
value.
This
includes
p
oin
ters
returned
b
y
malloc,
and
p
oin
ters
to
C
v
ariables
obtained
with
the
&
op
erator.
.
Represen
tation
of
Caml
Ligh
t
data
t
yp
es
This
section
describ
es
ho
w
Caml
Ligh
t
data
t
yp
es
are
enco
ded
in
the
value
t
yp
e.

Chapter
.
In
terfacing
C
with
Caml
Ligh
t
0
..
A
tomic
t
yp
es
Caml
t
yp
e
Enco
ding
int
Un
b
o
xed
in
teger
v
alues.
char
Un
b
o
xed
in
teger
v
alues
(ASCI
I
co
de).
float
Blo
c
ks
with
tag
Double_tag.
string
Blo
c
ks
with
tag
String_tag.
..
Pro
duct
t
yp
es
T
uples
and
arra
ys
are
represen
ted
b
y
p
oin
ters
to
blo
c
ks,
with
tag
0.
Records
are
also
represen
ted
b
y
zero-tagged
blo
c
ks.
The
ordering
of
lab
els
in
the
record
t
yp
e
declaration
determines
the
la
y
out
of
the
record
elds:
the
v
alue
asso
ciated
to
the
lab
el
declared
rst
is
stored
in
eld
0
of
the
blo
c
k,
the
v
alue
asso
ciated
to
the
lab
el
declared
next
go
es
in
eld
,
and
so
on.
..
Concrete
t
yp
es
Constructed
terms
are
represen
ted
b
y
blo
c
ks
whose
tag
enco
de
the
constructor.
The
constructors
for
a
giv
en
concrete
t
yp
e
are
n
um
b
ered
from
0
to
the
n
um
b
er
of
constructors
min
us
one,
follo
wing
the
order
in
whic
h
they
app
ear
in
the
concrete
t
yp
e
declaration.
Constan
t
constructors
are
represen
ted
b
y
zero-sized
blo
c
ks
(atoms),
tagged
with
the
constructor
n
um
b
er.
Non-constan
t
constructors
declared
with
a
n-tuple
as
argumen
t
are
represen
ted
b
y
a
blo
c
k
of
size
n,
tagged
with
the
constructor
n
um
b
er;
the
n
elds
con
tain
the
comp
onen
ts
of
its
tuple
argumen
t.
Other
non-constan
t
constructors
are
represen
ted
b
y
a
blo
c
k
of
size
,
tagged
with
the
constructor
n
um
b
er;
the
eld
0
con
tains
the
v
alue
of
the
constructor
argumen
t.
Example:
Constructed
term
Represen
tation
()
Size
=
0,
tag
=
0
false
Size
=
0,
tag
=
0
true
Size
=
0,
tag
=

[]
Size
=
0,
tag
=
0
h::t
Size
=
,
tag
=
,
rst
eld
=
h,
second
eld
=
t
.
Op
erations
on
v
alues
..
Kind
tests

Is_int
(v
)
is
true
if
v
alue
v
is
an
immediate
in
teger,
false
otherwise

Is_block
(v
)
is
true
if
v
alue
v
is
a
p
oin
ter
to
a
blo
c
k,
and
false
if
it
is
an
immediate
in
teger.
..
Op
erations
on
in
tegers

Val_long
(l
)
returns
the
v
alue
enco
ding
the
long
int
l

Long_val
(v
)
returns
the
long
int
enco
ded
in
v
alue
v

0

Val_int
(i)
returns
the
v
alue
enco
ding
the
int
i

Int_val
(v
)
returns
the
int
enco
ded
in
v
alue
v
..
Accessing
blo
c
ks

Wosize_val
(v
)
returns
the
size
of
v
alue
v
,
in
w
ords,
excluding
the
header.

Tag_val
(v
)
returns
the
tag
of
v
alue
v
.

Field
(v
;
n)
returns
the
v
alue
con
tained
in
the
n
th
eld
of
the
structured
blo
c
k
v
.
Fields
are
n
um
b
ered
from
0
to
Wosize_val
(v
)
 .

Code_val
(v
)
returns
the
co
de
part
of
the
closure
v
.

Env_val
(v
)
returns
the
en
vironmen
t
part
of
the
closure
v
.

string_length
(v
)
returns
the
length
(n
um
b
er
of
c
haracters)
of
the
string
v
.

Byte
(v
;
n)
returns
the
n
th
c
haracter
of
the
string
v
,
with
t
yp
e
char.
Characters
are
n
um
b
ered
from
0
to
string_length
(v
)
 .

Byte_u
(v
;
n)
returns
the
n
th
c
haracter
of
the
string
v
,
with
t
yp
e
unsigned
char.
Characters
are
n
um
b
ered
from
0
to
string_length
(v
)
 .

String_val
(v
)
returns
a
p
oin
ter
to
the
rst
b
yte
of
the
string
v
,
with
t
yp
e
char
*.
This
p
oin
ter
is
a
v
alid
C
string:
there
is
a
n
ull
c
haracter
after
the
last
c
haracter
in
the
string.
Ho
w
ev
er,
Caml
Ligh
t
strings
can
con
tain
em
b
edded
n
ull
c
haracters,
that
will
confuse
the
usual
C
functions
o
v
er
strings.

Double_val
(v
)
returns
the
oating-p
oin
t
n
um
b
er
con
tained
in
v
alue
v
,
with
t
yp
e
double.
The
expressions
Field
(v
;
n),
Code_val
(v
),
Env_val
(v
),
Byte(v
;
n),
Byte_u
(v
;
n)
and
Double_val
(v
)
are
v
alid
l-v
alues.
Hence,
they
can
b
e
assigned
to,
resulting
in
an
in-place
mo
dication
of
v
alue
v
.
Assigning
directly
to
Field
(v
;
n)
m
ust
b
e
done
with
care
to
a
v
oid
confusing
the
garbage
collector
(see
b
elo
w).
..
Allo
cating
blo
c
ks
F
rom
the
standp
oin
t
of
the
allo
cation
functions,
blo
c
ks
are
divided
according
to
their
size
as
zero-
sized
blo
c
ks,
small
blo
c
ks
(with
size
less
than
or
equal
to
Max_young_wosize),
and
large
blo
c
ks
(with
size
greater
than
to
Max_young_wosize).
The
constan
t
Max_young_wosize
is
declared
in
the
include
le
mlvalues.h.
It
is
guaran
teed
to
b
e
at
least

(w
ords),
so
that
an
y
blo
c
k
with
constan
t
size
less
than
or
equal
to

can
b
e
assumed
to
b
e
small.
F
or
blo
c
ks
whose
size
is
computed
at
run-time,
the
size
m
ust
b
e
compared
against
Max_young_wosize
to
determine
the
correct
allo
cation
pro
cedure.

Atom
(t)
returns
an
\atom"
(zero-sized
blo
c
k)
with
tag
t.
Zero-sized
blo
c
ks
are
preallo
cated
outside
of
the
heap.
It
is
incorrect
to
try
and
allo
cate
a
zero-sized
blo
c
k
using
the
functions
b
elo
w.
F
or
instance,
Atom
(0)
represen
ts
(),
false
and
[];
Atom
()
represen
ts
true.
(As
a
con
v
enience,
mlvalues.h
denes
the
macros
Val_unit,
Val_false
and
Val_true.)

Chapter
.
In
terfacing
C
with
Caml
Ligh
t
0

alloc
(n;
t)
returns
a
fresh
small
blo
c
k
of
size
n

Max_young_wosize
w
ords,
with
tag
t.
If
this
blo
c
k
is
a
structured
blo
c
k
(i.e.
if
t
<
No_scan_tag
),
then
the
elds
of
the
blo
c
k
(initially
con
taining
garbage)
m
ust
b
e
initialized
with
legal
v
alues
(using
direct
assignmen
t
to
the
elds
of
the
blo
c
k)
b
efore
the
next
allo
cation.

alloc_tuple
(n)
returns
a
fresh
small
blo
c
k
of
size
n

Max_young_wosize
w
ords,
with
tag
0.
The
elds
of
this
blo
c
k
m
ust
b
e
lled
with
legal
v
alues
b
efore
the
next
allo
cation
or
mo
dication.

alloc_shr
(n;
t)
returns
a
fresh
blo
c
k
of
size
n,
with
tag
t.
The
size
of
the
blo
c
k
can
b
e
greater
than
Max_young_wosize.
(It
can
also
b
e
smaller,
but
in
this
case
it
is
more
ecien
t
to
call
alloc
instead
of
alloc_shr.)
If
this
blo
c
k
is
a
structured
blo
c
k
(i.e.
if
t
<
No_scan_tag
),
then
the
elds
of
the
blo
c
k
(initially
con
taining
garbage)
m
ust
b
e
initialized
with
legal
v
alues
(using
the
initialize
function
describ
ed
b
elo
w)
b
efore
the
next
allo
cation.

alloc_string
(n)
returns
a
string
v
alue
of
length
n
c
haracters.
The
string
initially
con
tains
garbage.

copy_string
(s)
returns
a
string
v
alue
con
taining
a
cop
y
of
the
n
ull-terminated
C
string
s
(a
char
*).

copy_double
(d)
returns
a
oating-p
oin
t
v
alue
initialized
with
the
double
d.

alloc_array
(f
;
a)
allo
cates
an
arra
y
of
v
alues,
calling
function
f
o
v
er
eac
h
elemen
t
of
the
input
arra
y
a
to
transform
it
in
to
a
v
alue.
The
arra
y
a
is
an
arra
y
of
p
oin
ters
terminated
b
y
the
n
ull
p
oin
ter.
The
function
f
receiv
es
eac
h
p
oin
ter
as
argumen
t,
and
returns
a
v
alue.
The
zero-tagged
blo
c
k
returned
b
y
alloc_array
(f
;
a)
is
lled
with
the
v
alues
returned
b
y
the
successiv
e
calls
to
f
.

copy_string_array
(p)
allo
cates
an
arra
y
of
strings,
copied
from
the
p
oin
ter
to
a
string
arra
y
p
(a
char
**).
..
Raising
exceptions
C
functions
cannot
raise
arbitrary
exceptions.
Ho
w
ev
er,
t
w
o
functions
are
pro
vided
to
raise
t
w
o
standard
exceptions:

failwith
(s),
where
s
is
a
n
ull-terminated
C
string
(with
t
yp
e
char
*),
raises
exception
Failure
with
argumen
t
s.

invalid_argument
(s),
where
s
is
a
n
ull-terminated
C
string
(with
t
yp
e
char
*),
raises
ex-
ception
Invalid_argument
with
argumen
t
s.
.
Living
in
harmon
y
with
the
garbage
collector
Un
used
blo
c
ks
in
the
heap
are
automatically
reclaimed
b
y
the
garbage
collector.
This
requires
some
co
op
eration
from
C
co
de
that
manipulates
heap-allo
cated
blo
c
ks.

0
Rule

After
a
structur
e
d
blo
ck
(a
blo
ck
with
tag
less
than
No_scan_tag)
is
al
lo
c
ate
d,
al
l
elds
of
this
blo
ck
must
b
e
l
le
d
with
wel
l-forme
d
values
b
efor
e
the
next
al
lo
c
ation
op
er
ation.
If
the
blo
ck
has
b
e
en
al
lo
c
ate
d
with
alloc
or
alloc_tuple,
l
ling
is
p
erforme
d
by
dir
e
ct
assignment
to
the
elds
of
the
blo
ck:
Field(v,
n)
=
v
n
;
If
the
blo
ck
has
b
e
en
al
lo
c
ate
d
with
alloc_shr,
l
ling
is
p
erforme
d
thr
ough
the
initialize
function:
initialize(&Field(v,
n),
v
n
);
The
next
allo
cation
can
trigger
a
garbage
collection.
The
garbage
collector
assumes
that
all
structured
blo
c
ks
con
tain
w
ell-formed
v
alues.
Newly
created
blo
c
ks
con
tain
random
data,
whic
h
generally
do
not
represen
t
w
ell-formed
v
alues.
If
y
ou
really
need
to
allo
cate
b
efore
the
elds
can
receiv
e
their
nal
v
alue,
rst
initialize
with
a
constan
t
v
alue
(e.g.
Val_long(0)),
then
allo
cate,
then
mo
dify
the
elds
with
the
correct
v
alue
(see
rule
).
Rule

L
o
c
al
variables
c
ontaining
values
must
b
e
r
e
gister
e
d
with
the
garb
age
c
ol
le
ctor
(using
the
Push_roots
and
Pop_roots
macr
os),
if
they
ar
e
to
survive
a
c
al
l
to
an
al
lo
c
ation
function.
Registration
is
p
erformed
with
the
Push_roots
and
Pop_roots
macros.
Push_roots(r,n)
declares
an
arra
y
r
of
n
v
alues
and
registers
them
with
the
garbage
collector.
The
v
alues
con
tained
in
r[0]
to
r[n-]
are
treated
lik
e
ro
ots
b
y
the
garbage
collector.
A
ro
ot
v
alue
has
the
follo
wing
prop
erties:
if
it
p
oin
ts
to
a
heap-allo
cated
blo
c
k,
this
blo
c
k
(and
its
con
ten
ts)
will
not
b
e
reclaimed;
moreo
v
er,
if
this
blo
c
k
is
relo
cated
b
y
the
garbage
collector,
the
ro
ot
v
alue
is
up
dated
to
p
oin
t
to
the
new
lo
cation
for
the
blo
c
k.
Push_roots(r,n)
m
ust
o
ccur
in
a
C
blo
c
k
exactly
b
et
w
een
the
last
lo
cal
v
ariable
declaration
and
the
rst
statemen
t
in
the
blo
c
k.
T
o
un-register
the
ro
ots,
Pop_roots()
m
ust
b
e
called
b
efore
the
C
blo
c
k
con
taining
Push_roots(r,n)
is
exited.
(Ro
ots
are
automatically
un-registered
if
a
Caml
exception
is
raised.)
Rule

Dir
e
ct
assignment
to
a
eld
of
a
blo
ck,
as
in
Field(v,
n)
=
w;
is
safe
only
if
v
is
a
blo
ck
new
ly
al
lo
c
ate
d
by
alloc
or
alloc_tuple;
that
is,
if
no
al
lo
c
ation
to
ok
plac
e
b
etwe
en
the
al
lo
c
ation
of
v
and
the
assignment
to
the
eld.
In
al
l
other
c
ases,
never
assign
dir
e
ctly.
If
the
blo
ck
has
just
b
e
en
al
lo
c
ate
d
by
alloc_shr,
use
initialize
to
assign
a
value
to
a
eld
for
the
rst
time:
initialize(&Field(v,
n),
w);
Otherwise,
you
ar
e
up
dating
a
eld
that
pr
eviously
c
ontaine
d
a
wel
l-forme
d
value;
then,
c
al
l
the
modify
function:
modify(&Field(v,
n),
w);
T
o
illustrate
the
rules
ab
o
v
e,
here
is
a
C
function
that
builds
and
returns
a
list
con
taining
the
t
w
o
in
tegers
giv
en
as
parameters:

Chapter
.
In
terfacing
C
with
Caml
Ligh
t
0
value
alloc_list_int(i,
i)
int
i,
i;
{
value
result;
Push_roots(r,
);
r[0]
=
alloc(,
);
/*
Allocate
a
cons
cell
*/
Field(r[0],
0)
=
Val_int(i);
/*
car
=
the
integer
i
*/
Field(r[0],
)
=
Atom(0);
/*
cdr
=
the
empty
list
[]
*/
result
=
alloc(,
);
/*
Allocate
the
other
cons
cell
*/
Field(result,
0)
=
Val_int(i);
/*
car
=
the
integer
i
*/
Field(result,
)
=
r[0];
/*
cdr
=
the
first
cons
cell
*/
Pop_roots();
return
result;
}
The
\cons"
cell
allo
cated
rst
needs
to
surviv
e
the
allo
cation
of
the
other
cons
cell;
hence,
the
v
alue
returned
b
y
the
rst
call
to
alloc
m
ust
b
e
stored
in
a
registered
ro
ot.
The
v
alue
returned
b
y
the
second
call
to
alloc
can
reside
in
the
un-registered
lo
cal
v
ariable
result,
since
w
e
w
on't
do
an
y
further
allo
cation
in
this
function.
In
the
example
ab
o
v
e,
the
list
is
built
b
ottom-up.
Here
is
an
alternate
w
a
y
,
that
pro
ceeds
top-do
wn.
It
is
less
ecien
t,
but
illustrates
the
use
of
modify.
value
alloc_list_int(i,
i)
int
i,
i;
{
value
tail;
Push_roots(r,
);
r[0]
=
alloc(,
);
/*
Allocate
a
cons
cell
*/
Field(r[0],
0)
=
Val_int(i);
/*
car
=
the
integer
i
*/
Field(r[0],
)
=
Val_int(0);
/*
A
dummy
value
tail
=
alloc(,
);
/*
Allocate
the
other
cons
cell
*/
Field(tail,
0)
=
Val_int(i);
/*
car
=
the
integer
i
*/
Field(tail,
)
=
Atom(0);
/*
cdr
=
the
empty
list
[]
*/
modify(&Field(r[0],
),
tail);
/*
cdr
of
the
result
=
tail
*/
Pop_roots();
return
r[0];
}
It
w
ould
b
e
incorrect
to
p
erform
Field(r[0],
)
=
tail
directly
,
b
ecause
the
allo
cation
of
tail
has
tak
en
place
since
r[0]
w
as
allo
cated.
.
A
complete
example
This
section
outlines
ho
w
the
functions
from
the
Unix
curses
library
can
b
e
made
a
v
ailable
to
Caml
Ligh
t
programs.
First
of
all,
here
is
the
in
terface
curses.mli
that
declares
the
curses
primitiv
es
and
data
t
yp
es:

0
type
window;;
(*
The
type
"window"
remains
abstract
*)
value
initscr:
unit
->
window
=

"curses_initscr"
and
endwin:
unit
->
unit
=

"curses_endwin"
and
refresh:
unit
->
unit
=

"curses_refresh"
and
wrefresh
:
window
->
unit
=

"curses_wrefresh"
and
newwin:
int
->
int
->
int
->
int
->
window
=

"curses_newwin"
and
mvwin:
window
->
int
->
int
->
unit
=

"curses_mvwin"
and
addch:
char
->
unit
=

"curses_addch"
and
mvwaddch:
window
->
int
->
int
->
char
->
unit
=

"curses_mvwaddch"
and
addstr:
string
->
unit
=

"curses_addstr"
and
mvwaddstr:
window
->
int
->
int
->
string
->
unit
=

"curses_mvwaddstr"
;;
(*
lots
more
omitted
*)
T
o
compile
this
in
terface:
camlc
-c
curses.mli
T
o
implemen
t
these
functions,
w
e
just
ha
v
e
to
pro
vide
the
stub
co
de;
the
core
functions
are
already
implemen
ted
in
the
curses
library
.
The
stub
co
de
le,
curses.o,
lo
oks
lik
e:
#include
<curses.h>
#include
<mlvalues.h>
value
curses_initscr(unit)
value
unit;
{
return
(value)
initscr();
/*
OK
to
coerce
directly
from
WINDOW
*
to
value
since
that's
a
block
created
by
malloc()
*/
}
value
curses_wrefresh(win)
value
win;
{
wrefresh((WINDOW
*)
win);
return
Val_unit;
}
value
curses_newwin(nlines,
ncols,
x0,
y0)
value
nlines,
ncols,
x0,
y0;
{
return
(value)
newwin(Int_val(nlines),
Int_val(ncols),
Int_val(x0),
Int_val(y0));
}
value
curses_addch(c)
value
c;
{

Chapter
.
In
terfacing
C
with
Caml
Ligh
t
0	
addch(Int_val(c));
/*
Characters
are
encoded
like
integers
*/
return
Val_unit;
}
value
curses_addstr(s)
value
s;
{
addstr(String_val(s));
return
Val_unit;
}
/*
This
goes
on
for
pages.
*/
(Actually
,
it
w
ould
b
e
b
etter
to
create
a
library
for
the
stub
co
de,
with
eac
h
stub
co
de
function
in
a
separate
le,
so
that
linking
w
ould
pic
k
only
those
functions
from
the
curses
library
that
are
actually
used.)
The
le
curses.c
can
b
e
compiled
with:
cc
-c
-I/usr/local/lib/caml-light
curses.c
or,
ev
en
simpler,
camlc
-c
curses.c
(When
passed
a
.c
le,
the
camlc
command
simply
calls
cc
on
that
le,
with
the
righ
t
-I
option.)
No
w,
here
is
a
sample
Caml
Ligh
t
program
test.ml
that
uses
the
curses
mo
dule:
#open
"curses";;
let
main_window
=
initscr
()
in
let
small_window
=
newwin
0

0
0
in
mvwaddstr
main_window
0

"Hello";
mvwaddstr
small_window


"world";
refresh();
for
i
=

to
00000
do
()
done;
endwin()
;;
T
o
compile
this
program,
run:
camlc
-c
test.ml
Finally
,
to
link
ev
erything
together:
camlc
-custom
-o
test
test.zo
curses.o
-lcurses

0

P
art
IV
The
Caml
Ligh
t
library



Chapter

The
core
library
This
c
hapter
describ
es
the
functions
pro
vided
b
y
the
Caml
Ligh
t
core
library
.
This
library
is
sp
ecial
in
t
w
o
w
a
ys:

It
is
automatically
link
ed
with
the
user's
ob
ject
co
de
les
b
y
the
camlc
command
(c
hapter
).
Hence,
the
globals
dened
b
y
these
libraries
can
b
e
used
in
standalone
programs
without
ha
ving
to
add
an
y
.zo
le
on
the
command
line
for
the
linking
phase.
Similarly
,
in
in
teractiv
e
use,
these
globals
can
b
e
used
in
toplev
el
phrases
without
ha
ving
to
load
an
y
.zo
le
in
memory
.

The
in
terfaces
for
the
mo
dules
b
elo
w
are
automatically
\op
ened"
when
a
compilation
starts,
or
when
the
toplev
el
system
is
launc
hed.
Hence,
it
is
p
ossible
to
use
unqualied
iden
tiers
to
refer
to
the
functions
pro
vided
b
y
these
mo
dules,
without
adding
#open
directiv
es.
Actually
,
the
list
of
automatically
op
ened
mo
dules
dep
end
on
the
-O
option
giv
en
to
the
compiler
or
to
the
toplev
el
system:
-O
option
Op
ened
mo
dules
(rev
erse
op
ening
order)
-O
cautious
(default)
io,
eq,
int,
float,
ref,
pair,
list,
vect,
char,
string,
bool,
exc,
stream,
builtin
-O
fast
io,
eq,
int,
float,
ref,
pair,
list,
fvect,
fchar,
fstring,
bool,
exc,
stream,
builtin
-O
none
builtin
Con
v
en
tions
F
or
easy
reference,
the
mo
dules
are
listed
b
elo
w
in
alphab
etical
order
of
mo
dule
names.
F
or
eac
h
mo
dule,
the
declarations
from
its
in
terface
le
are
prin
ted
one
b
y
one
in
t
yp
ewriter
fon
t,
follo
w
ed
b
y
a
short
commen
t.
All
mo
dules
and
the
iden
tiers
they
exp
ort
are
indexed
at
the
end
of
this
rep
ort.
.
bool:
b
o
olean
op
erations
value
prefix
&
:
bool
->
bool
->
bool



value
prefix
&&
:
bool
->
bool
->
bool
value
prefix
or
:
bool
->
bool
->
bool
value
prefix
||
:
bool
->
bool
->
bool
The
b
o
olean
and
is
written
e
&
e
or
e
&&
e.
The
b
o
olean
or
is
written
e
or
e
or
e
||
e.
Both
constructs
are
sequen
tial,
left-to-righ
t:
e
is
ev
aluated
only
if
needed.
Actually
,
e
&
e
is
equiv
alen
t
to
if
e
then
e
else
false,
and
e
or
e
is
equiv
alen
t
to
if
e
then
true
else
e.
value
prefix
not
:
bool
->
bool
The
b
o
olean
negation.
value
string_of_bool
:
bool
->
string
Return
a
string
represen
ting
the
giv
en
b
o
olean.
.
builtin:
base
t
yp
es
and
constructors
This
mo
dule
denes
some
t
yp
es
and
exceptions
for
whic
h
the
language
pro
vides
sp
ecial
syn
tax,
and
are
therefore
treated
sp
ecially
b
y
the
compiler.
type
int
type
float
type
string
type
char
The
t
yp
es
of
in
tegers,
oating-p
oin
t
n
um
b
ers,
c
haracter
strings,
and
c
haracters,
resp
ectiv
ely
.
type
exn
The
t
yp
e
of
exception
v
alues.
type
bool
=
false
|
true
The
t
yp
e
of
b
o
olean
v
alues.
type
'a
vect
The
t
yp
e
of
arra
ys
whose
elemen
ts
ha
v
e
t
yp
e
'a.
type
unit
=
()
The
t
yp
e
of
the
unit
v
alue.
type
'a
list
=
[]
|
prefix
::
of
'a
*
'a
list
The
t
yp
e
of
lists.
type
'a
option
=
None
|
Some
of
'a
The
t
yp
e
of
optional
v
alues.
exception
Match_failure
of
string
*
int
*
int
The
exception
raised
when
a
pattern-matc
hing
fails.
The
argumen
t
indicates
the
p
osition
in
the
source
co
de
of
the
pattern-matc
hing
(source
le
name,
p
osition
of
the
rst
c
haracter
of
the
matc
hing,
p
osition
of
the
last
c
haracter.

Chapter
.
The
core
library

.
char:
c
haracter
op
erations
value
int_of_char
:
char
->
int
Return
the
ASCI
I
co
de
of
the
argumen
t.
value
char_of_int
:
int
->
char
Return
the
c
haracter
with
the
giv
en
ASCI
I
co
de.
Raise
Invalid_argument
"char_of_int"
if
the
argumen
t
is
outside
the
range
0{.
value
string_of_char
:
char
->
string
Return
a
string
represen
ting
the
giv
en
c
haracter.
value
char_for_read
:
char
->
string
Return
a
string
represen
ting
the
giv
en
c
haracter,
with
sp
ecial
c
haracters
escap
ed
follo
wing
the
lexical
con
v
en
tions
of
Caml
Ligh
t.
.
eq:
generic
comparisons
value
prefix
=
:
'a
->
'a
->
bool
e
=
e
tests
for
structural
equalit
y
of
e
and
e.
Mutable
structures
(e.g.
references
and
arra
ys)
are
equal
if
and
only
if
their
curren
t
con
ten
ts
are
structurally
equal,
ev
en
if
the
t
w
o
m
utable
ob
jects
are
not
the
same
ph
ysical
ob
ject.
Equalit
y
b
et
w
een
functional
v
alues
raises
Invalid_argument.
Equalit
y
b
et
w
een
cyclic
data
structures
ma
y
not
terminate.
value
prefix
<>
:
'a
->
'a
->
bool
Negation
of
prefix
=.
value
prefix
<
:
'a
->
'a
->
bool
value
prefix
<=
:
'a
->
'a
->
bool
value
prefix
>
:
'a
->
'a
->
bool
value
prefix
>=
:
'a
->
'a
->
bool
Structural
ordering
functions.
These
functions
coincide
with
the
usual
orderings
o
v
er
in
teger,
string
and
oating-p
oin
t
n
um
b
ers,
and
extend
them
to
a
total
ordering
o
v
er
all
t
yp
es.
The
ordering
is
compatible
with
prefix
=.
As
in
the
case
of
prefix
=,
m
utable
structures
are
compared
b
y
con
ten
ts.
Comparison
b
et
w
een
functional
v
alues
raises
Invalid_argument.
Comparison
b
et
w
een
cyclic
structures
ma
y
not
terminate.
value
compare:
'a
->
'a
->
int
compare
x
y
returns
0
if
x=y,
a
negativ
e
in
teger
if
x<y,
and
a
p
ositiv
e
in
teger
if
x>y.
The
same
restrictions
as
for
=
apply
.
compare
can
b
e
used
as
the
comparison
function
required
b
y
the
set
and
map
mo
dules.


value
min:
'a
->
'a
->
'a
Return
the
smaller
of
the
t
w
o
argumen
ts.
value
max:
'a
->
'a
->
'a
Return
the
greater
of
the
t
w
o
argumen
ts.
value
prefix
==
:
'a
->
'a
->
bool
e
==
e
tests
for
ph
ysical
equalit
y
of
e
and
e.
On
in
tegers
and
c
haracters,
it
is
the
same
as
structural
equalit
y
.
On
m
utable
structures,
e
==
e
is
true
if
and
only
if
ph
ysical
mo
dication
of
e
also
aects
e.
On
non-m
utable
structures,
the
b
eha
vior
of
prefix
==
is
implemen
tation-dep
enden
t,
except
that
e
==
e
implies
e
=
e.
value
prefix
!=
:
'a
->
'a
->
bool
Negation
of
prefix
==.
.
exc:
exceptions
value
raise
:
exn
->
'a
Raise
the
giv
en
exception
v
alue.
A
few
general-purp
ose
predened
exceptions.
exception
Out_of_memory
Raised
b
y
the
garbage
collector,
when
there
is
insucien
t
memory
to
complete
the
computation.
exception
Invalid_argument
of
string
Raised
b
y
library
functions
to
signal
that
the
giv
en
argumen
ts
do
not
mak
e
sense.
exception
Failure
of
string
Raised
b
y
library
functions
to
signal
that
they
are
undened
on
the
giv
en
argumen
ts.
exception
Not_found
Raised
b
y
searc
h
functions
when
the
desired
ob
ject
could
not
b
e
found.
exception
Exit
This
exception
is
not
raised
b
y
an
y
library
function.
It
is
pro
vided
for
use
in
y
our
programs.
value
failwith
:
string
->
'a
Raise
exception
Failure
with
the
giv
en
string.
value
invalid_arg
:
string
->
'a
Raise
exception
Invalid_argument
with
the
giv
en
string.

Chapter
.
The
core
library

.
fchar:
c
haracter
op
erations,
without
sanit
y
c
hec
ks
This
mo
dule
implemen
ts
the
same
functions
as
the
char
mo
dule,
but
do
es
not
p
erform
b
ound
c
hec
ks
on
the
argumen
ts
of
the
functions.
The
functions
are
therefore
faster
than
those
in
the
char
mo
dule,
but
calling
these
functions
with
incorrect
parameters
(that
is,
parameters
that
w
ould
cause
the
Invalid_argument
exception
to
b
e
raised
b
y
the
corresp
onding
functions
in
the
char
mo
dule)
can
crash
the
program.
.
float:
op
erations
on
oating-p
oin
t
n
um
b
ers
value
int_of_float
:
float
->
int
T
runcate
the
giv
en
oat
to
an
in
teger
v
alue.
The
result
is
unsp
ecied
if
it
falls
outside
the
range
of
represen
table
in
tegers.
value
float_of_int
:
int
->
float
Con
v
ert
an
in
teger
to
oating-p
oin
t.
value
minus
:
float
->
float
value
minus_float
:
float
->
float
Unary
negation.
value
prefix
+
:
float
->
float
->
float
value
prefix
+.
:
float
->
float
->
float
value
add_float
:
float
->
float
->
float
Addition.
value
prefix
-
:
float
->
float
->
float
value
prefix
-.
:
float
->
float
->
float
value
sub_float
:
float
->
float
->
float
Subtraction.
value
prefix
*
:
float
->
float
->
float
value
prefix
*.
:
float
->
float
->
float
value
mult_float
:
float
->
float
->
float
Pro
duct.
value
prefix
/
:
float
->
float
->
float
value
prefix
/.
:
float
->
float
->
float
value
div_float
:
float
->
float
->
float
Division.


value
prefix
**
:
float
->
float
->
float
value
prefix
**.
:
float
->
float
->
float
value
power
:
float
->
float
->
float
Exp
onen
tiation.
value
eq_float
:
float
->
float
->
bool
value
prefix
=.
:
float
->
float
->
bool
Floating-p
oin
t
equalit
y
.
Equiv
alen
t
to
generic
equalit
y
,
just
faster.
value
neq_float
:
float
->
float
->
bool
value
prefix
<>.
:
float
->
float
->
bool
Negation
of
eq_float.
value
prefix
<.
:
float
->
float
->
bool
value
lt_float
:
float
->
float
->
bool
value
prefix
>.
:
float
->
float
->
bool
value
gt_float
:
float
->
float
->
bool
value
prefix
<=.
:
float
->
float
->
bool
value
le_float
:
float
->
float
->
bool
value
prefix
>=.
:
float
->
float
->
bool
value
ge_float
:
float
->
float
->
bool
Usual
comparisons
b
et
w
een
oating-p
oin
t
n
um
b
ers.
value
acos
:
float
->
float
value
asin
:
float
->
float
value
atan
:
float
->
float
value
atan
:
float
->
float
->
float
value
cos
:
float
->
float
value
cosh
:
float
->
float
value
exp
:
float
->
float
value
log
:
float
->
float
value
log0
:
float
->
float
value
sin
:
float
->
float
value
sinh
:
float
->
float
value
sqrt
:
float
->
float
value
tan
:
float
->
float
value
tanh
:
float
->
float
Usual
transcenden
tal
functions
on
oating-p
oin
t
n
um
b
ers.
value
ceil
:
float
->
float
value
floor
:
float
->
float
Round
the
giv
en
oat
to
an
in
teger
v
alue.
floor
f
returns
the
greatest
in
teger
v
alue
less
than
or
equal
to
f.
ceil
f
returns
the
least
in
teger
v
alue
greater
than
or
equal
to
f.

Chapter
.
The
core
library
	
value
abs_float
:
float
->
float
Return
the
absolute
v
alue
of
the
argumen
t.
value
mod_float
:
float
->
float
->
float
fmod
a
b
returns
the
remainder
of
a
with
resp
ect
to
b.
value
frexp
:
float
->
float
*
int
frexp
f
returns
the
pair
of
the
signican
t
and
the
exp
onen
t
of
f
(when
f
is
zero,
the
signican
t
x
and
the
exp
onen
t
n
of
f
are
equal
to
zero;
when
f
is
non-zero,
they
are
dened
b
y
f
=
x
*.

**
n).
value
ldexp
:
float
->
int
->
float
ldexp
x
n
returns
x
*.

**
n.
value
modf
:
float
->
float
*
float
modf
f
returns
the
pair
of
the
fractional
and
in
tegral
part
of
f.
value
string_of_float
:
float
->
string
Con
v
ert
the
giv
en
oat
to
its
decimal
represen
tation.
value
float_of_string
:
string
->
float
Con
v
ert
the
giv
en
string
to
a
oat,
in
decimal.
The
result
is
unsp
ecied
if
the
giv
en
string
is
not
a
v
alid
represen
tation
of
a
oat.
.
fstring:
string
op
erations,
without
sanit
y
c
hec
ks
This
mo
dule
implemen
ts
the
same
functions
as
the
string
mo
dule,
but
do
es
not
p
erform
b
ound
c
hec
ks
on
the
argumen
ts
of
the
functions.
The
functions
are
therefore
faster
than
those
in
the
string
mo
dule,
but
calling
these
functions
with
incorrect
parameters
(that
is,
parameters
that
w
ould
cause
the
Invalid_argument
exception
to
b
e
raised
b
y
the
corresp
onding
functions
in
the
string
mo
dule)
can
crash
the
program.
.	
fvect:
op
erations
on
v
ectors,
without
sanit
y
c
hec
ks
This
mo
dule
implemen
ts
the
same
functions
as
the
vect
mo
dule,
but
do
es
not
p
erform
b
ound
c
hec
ks
on
the
argumen
ts
of
the
functions.
The
functions
are
therefore
faster
than
those
in
the
vect
mo
dule,
but
calling
these
functions
with
incorrect
parameters
(that
is,
parameters
that
w
ould
cause
the
Invalid_argument
exception
to
b
e
raised
b
y
the
corresp
onding
functions
in
the
vect
mo
dule)
can
crash
the
program.

0
.0
int:
op
erations
on
in
tegers
In
tegers
are

bits
wide
(or

bits
on
-bit
pro
cessors).
All
op
erations
are
tak
en
mo
dulo


(or


).
They
do
not
fail
on
o
v
ero
w.
exception
Division_by_zero
value
minus
:
int
->
int
value
minus_int
:
int
->
int
Unary
negation.
Y
ou
can
write
-e
instead
of
minus
e.
value
succ
:
int
->
int
succ
x
is
x+.
value
pred
:
int
->
int
pred
x
is
x-.
value
prefix
+
:
int
->
int
->
int
value
add_int
:
int
->
int
->
int
Addition.
value
prefix
-
:
int
->
int
->
int
value
sub_int
:
int
->
int
->
int
Subtraction.
value
prefix
*
:
int
->
int
->
int
value
mult_int
:
int
->
int
->
int
Multiplication.
value
prefix
/
:
int
->
int
->
int
value
div_int
:
int
->
int
->
int
value
prefix
quo
:
int
->
int
->
int
In
teger
division.
Raise
Division_by_zero
if
the
second
argumen
t
is
0.
Giv
e
unpredictable
results
if
either
argumen
t
is
negativ
e.
value
prefix
mod
:
int
->
int
->
int
Remainder.
Raise
Division_by_zero
if
the
second
argumen
t
is
0.
Giv
e
unpredictable
results
if
either
argumen
t
is
negativ
e.
value
eq_int
:
int
->
int
->
bool
In
teger
equalit
y
.
Equiv
alen
t
to
generic
equalit
y
,
just
faster.
value
neq_int
:
int
->
int
->
bool
Negation
of
eq_int.

Chapter
.
The
core
library

value
lt_int
:
int
->
int
->
bool
value
gt_int
:
int
->
int
->
bool
value
le_int
:
int
->
int
->
bool
value
ge_int
:
int
->
int
->
bool
Usual
comparisons
b
et
w
een
in
tegers.
value
abs
:
int
->
int
Return
the
absolute
v
alue
of
the
argumen
t.
value
max_int
:
int
value
min_int
:
int
The
greatest
and
smallest
in
teger
v
alues.
Bit
wise
op
erations
value
prefix
land
:
int
->
int
->
int
Bit
wise
logical
and.
value
prefix
lor
:
int
->
int
->
int
Bit
wise
logical
or.
value
prefix
lxor
:
int
->
int
->
int
Bit
wise
logical
exclusiv
e
or.
value
lnot
:
int
->
int
Bit
wise
complemen
t
value
prefix
lsl
:
int
->
int
->
int
value
lshift_left
:
int
->
int
->
int
n
lsl
m,
or
equiv
alen
tly
lshift_left
n
m,
shifts
n
to
the
left
b
y
m
bits.
value
prefix
lsr
:
int
->
int
->
int
n
lsr
m
shifts
n
to
the
righ
t
b
y
m
bits.
This
is
a
logical
shift:
zero
es
are
inserted
regardless
of
sign.
value
prefix
asr
:
int
->
int
->
int
value
lshift_right
:
int
->
int
->
int
n
asr
m,
or
equiv
alen
tly
lshift_right
n
m,
shifts
n
to
the
righ
t
b
y
m
bits.
This
is
an
arithmetic
shift:
the
sign
bit
is
replicated.


Con
v
ersion
functions
value
string_of_int
:
int
->
string
Con
v
ert
the
giv
en
in
teger
to
its
decimal
represen
tation.
value
int_of_string
:
string
->
int
Con
v
ert
the
giv
en
string
to
an
in
teger,
in
decimal
(b
y
default)
or
in
hexadecimal,
o
ctal
or
binary
if
the
string
b
egins
with
0x,
0o
or
0b.
Raise
Failure
"int_of_string"
if
the
giv
en
string
is
not
a
v
alid
represen
tation
of
an
in
teger.
.
io:
buered
input
and
output
type
in_channel
type
out_channel
The
abstract
t
yp
es
of
input
c
hannels
and
output
c
hannels.
exception
End_of_file
Raised
when
an
op
eration
cannot
complete,
b
ecause
the
end
of
the
le
has
b
een
reac
hed.
value
stdin
:
in_channel
value
std_in
:
in_channel
value
stdout
:
out_channel
value
std_out
:
out_channel
value
stderr
:
out_channel
value
std_err
:
out_channel
The
standard
input,
standard
output,
and
standard
error
output
for
the
pro
cess.
std_in,
std_out
and
std_err
are
resp
ectiv
ely
synon
ymous
with
stdin,
stdout
and
stderr.
value
exit
:
int
->
'a
Flush
all
p
ending
writes
on
std_out
and
std_err,
and
terminate
the
pro
cess,
returning
the
giv
en
status
co
de
to
the
op
erating
system
(usually
0
to
indicate
no
errors,
and
a
small
p
ositiv
e
in
teger
to
indicate
failure.)
This
function
should
b
e
called
at
the
end
of
all
standalone
programs
that
output
results
on
std_out
or
std_err;
otherwise,
the
program
ma
y
app
ear
to
pro
duce
no
output,
or
its
output
ma
y
b
e
truncated.
Output
functions
on
standard
output
value
print_char
:
char
->
unit
Prin
t
the
c
haracter
on
standard
output.

Chapter
.
The
core
library

value
print_string
:
string
->
unit
Prin
t
the
string
on
standard
output.
value
print_int
:
int
->
unit
Prin
t
the
in
teger,
in
decimal,
on
standard
output.
value
print_float
:
float
->
unit
Prin
t
the
oating-p
oin
t
n
um
b
er,
in
decimal,
on
standard
output.
value
print_endline
:
string
->
unit
Prin
t
the
string,
follo
w
ed
b
y
a
newline
c
haracter,
on
standard
output.
value
print_newline
:
unit
->
unit
Prin
t
a
newline
c
haracter
on
standard
output,
and
ush
standard
output.
This
can
b
e
used
to
sim
ulate
line
buering
of
standard
output.
Output
functions
on
standard
error
value
prerr_char
:
char
->
unit
Prin
t
the
c
haracter
on
standard
error.
value
prerr_string
:
string
->
unit
Prin
t
the
string
on
standard
error.
value
prerr_int
:
int
->
unit
Prin
t
the
in
teger,
in
decimal,
on
standard
error.
value
prerr_float
:
float
->
unit
Prin
t
the
oating-p
oin
t
n
um
b
er,
in
decimal,
on
standard
error.
value
prerr_endline
:
string
->
unit
Prin
t
the
string,
follo
w
ed
b
y
a
newline
c
haracter
on
standard
error
and
ush
standard
error.


Input
functions
on
standard
input
value
read_line
:
unit
->
string
Flush
standard
output,
then
read
c
haracters
from
standard
input
un
til
a
newline
c
haracter
is
encoun
tered.
Return
the
string
of
all
c
haracters
read,
without
the
newline
c
haracter
at
the
end.
value
read_int
:
unit
->
int
Flush
standard
output,
then
read
one
line
from
standard
input
and
con
v
ert
it
to
an
in
teger.
Raise
Failure
"int_of_string"
if
the
line
read
is
not
a
v
alid
represen
tation
of
an
in
teger.
value
read_float
:
unit
->
float
Flush
standard
output,
then
read
one
line
from
standard
input
and
con
v
ert
it
to
a
oating-p
oin
t
n
um
b
er.
The
result
is
unsp
ecied
if
the
line
read
is
not
a
v
alid
represen
tation
of
a
oating-p
oin
t
n
um
b
er.
General
output
functions
value
open_out
:
string
->
out_channel
Op
en
the
named
le
for
writing,
and
return
a
new
output
c
hannel
on
that
le,
p
ositionned
at
the
b
eginning
of
the
le.
The
le
is
truncated
to
zero
length
if
it
already
exists.
It
is
created
if
it
do
es
not
already
exists.
Raise
sys__Sys_error
if
the
le
could
not
b
e
op
ened.
value
open_out_bin
:
string
->
out_channel
Same
as
open_out,
but
the
le
is
op
ened
in
binary
mo
de,
so
that
no
translation
tak
es
place
during
writes.
On
op
erating
systems
that
do
not
distinguish
b
et
w
een
text
mo
de
and
binary
mo
de,
this
function
b
eha
v
es
lik
e
open_out.
value
open_out_gen
:
sys__open_flag
list
->
int
->
string
->
out_channel
open_out_gen
mode
rights
filename
op
ens
the
le
named
filename
for
writing,
as
ab
o
v
e.
The
extra
argumen
t
mode
sp
ecify
the
op
ening
mo
de
(see
sys__open).
The
extra
argumen
t
rights
sp
ecies
the
le
p
ermissions,
in
case
the
le
m
ust
b
e
created
(see
sys__open).
open_out
and
open_out_bin
are
sp
ecial
cases
of
this
function.
value
open_descriptor_out
:
int
->
out_channel
open_descriptor_out
fd
returns
a
buered
output
c
hannel
writing
to
the
le
descriptor
fd.
The
le
descriptor
fd
m
ust
ha
v
e
b
een
previously
op
ened
for
writing,
else
the
b
eha
vior
is
undened.
value
flush
:
out_channel
->
unit
Flush
the
buer
asso
ciated
with
the
giv
en
output
c
hannel,
p
erforming
all
p
ending
writes
on
that
c
hannel.
In
teractiv
e
programs
m
ust
b
e
careful
ab
out
ushing
std_out
and
std_err
at
the
righ
t
time.

Chapter
.
The
core
library

value
output_char
:
out_channel
->
char
->
unit
W
rite
the
c
haracter
on
the
giv
en
output
c
hannel.
value
output_string
:
out_channel
->
string
->
unit
W
rite
the
string
on
the
giv
en
output
c
hannel.
value
output
:
out_channel
->
string
->
int
->
int
->
unit
output
chan
buff
ofs
len
writes
len
c
haracters
from
string
buff,
starting
at
oset
ofs,
to
the
output
c
hannel
chan.
Raise
Invalid_argument
"output"
if
ofs
and
len
do
not
designate
a
v
alid
substring
of
buff.
value
output_byte
:
out_channel
->
int
->
unit
W
rite
one
-bit
in
teger
(as
the
single
c
haracter
with
that
co
de)
on
the
giv
en
output
c
hannel.
The
giv
en
in
teger
is
tak
en
mo
dulo
.
value
output_binary_int
:
out_channel
->
int
->
unit
W
rite
one
in
teger
in
binary
format
on
the
giv
en
output
c
hannel.
The
only
reliable
w
a
y
to
read
it
bac
k
is
through
the
input_binary_int
function.
The
format
is
compatible
across
all
mac
hines
for
a
giv
en
v
ersion
of
Caml
Ligh
t.
value
output_value
:
out_channel
->
'a
->
unit
W
rite
the
represen
tation
of
a
structured
v
alue
of
an
y
t
yp
e
to
a
c
hannel.
Circularities
and
sharing
inside
the
v
alue
are
detected
and
preserv
ed.
The
ob
ject
can
b
e
read
bac
k,
b
y
the
function
input_value.
The
format
is
compatible
across
all
mac
hines
for
a
giv
en
v
ersion
of
Caml
Ligh
t.
value
output_compact_value
:
out_channel
->
'a
->
unit
Same
as
output_value,
but
uses
a
dieren
t
format,
whic
h
o
ccupies
less
space
on
the
le,
but
tak
es
more
time
to
generate
and
read
bac
k.
value
seek_out
:
out_channel
->
int
->
unit
seek_out
chan
pos
sets
the
curren
t
writing
p
osition
to
pos
for
c
hannel
chan.
This
w
orks
only
for
regular
les.
On
les
of
other
kinds
(suc
h
as
terminals,
pip
es
and
so
c
k
ets),
the
b
eha
vior
is
unsp
ecied.
value
pos_out
:
out_channel
->
int
Return
the
curren
t
writing
p
osition
for
the
giv
en
c
hannel.
value
out_channel_length
:
out_channel
->
int
Return
the
total
length
(n
um
b
er
of
c
haracters)
of
the
giv
en
c
hannel.
This
w
orks
only
for
regular
les.
On
les
of
other
kinds,
the
result
is
meaningless.
value
close_out
:
out_channel
->
unit
Close
the
giv
en
c
hannel,
ushing
all
buered
write
op
erations.
The
b
eha
vior
is
unsp
ecied
if
an
y
of
the
functions
ab
o
v
e
is
called
on
a
closed
c
hannel.


General
input
functions
value
open_in
:
string
->
in_channel
Op
en
the
named
le
for
reading,
and
return
a
new
input
c
hannel
on
that
le,
p
ositionned
at
the
b
eginning
of
the
le.
Raise
sys__Sys_error
if
the
le
could
not
b
e
op
ened.
value
open_in_bin
:
string
->
in_channel
Same
as
open_in,
but
the
le
is
op
ened
in
binary
mo
de,
so
that
no
translation
tak
es
place
during
reads.
On
op
erating
systems
that
do
not
distinguish
b
et
w
een
text
mo
de
and
binary
mo
de,
this
function
b
eha
v
es
lik
e
open_in.
value
open_in_gen
:
sys__open_flag
list
->
int
->
string
->
in_channel
open_in_gen
mode
rights
filename
op
ens
the
le
named
filename
for
reading,
as
ab
o
v
e.
The
extra
argumen
ts
mode
and
rights
sp
ecify
the
op
ening
mo
de
and
le
p
ermissions
(see
sys__open).
open_in
and
open_in_bin
are
sp
ecial
cases
of
this
function.
value
open_descriptor_in
:
int
->
in_channel
open_descriptor_in
fd
returns
a
buered
input
c
hannel
reading
from
the
le
descriptor
fd.
The
le
descriptor
fd
m
ust
ha
v
e
b
een
previously
op
ened
for
reading,
else
the
b
eha
vior
is
undened.
value
input_char
:
in_channel
->
char
Read
one
c
haracter
from
the
giv
en
input
c
hannel.
Raise
End_of_file
if
there
are
no
more
c
haracters
to
read.
value
input_line
:
in_channel
->
string
Read
c
haracters
from
the
giv
en
input
c
hannel,
un
til
a
newline
c
haracter
is
encoun
tered.
Return
the
string
of
all
c
haracters
read,
without
the
newline
c
haracter
at
the
end.
Raise
End_of_file
if
the
end
of
the
le
is
reac
hed
at
the
b
eginning
of
line.
value
input
:
in_channel
->
string
->
int
->
int
->
int
input
chan
buff
ofs
len
attempts
to
read
len
c
haracters
from
c
hannel
chan,
storing
them
in
string
buff,
starting
at
c
haracter
n
um
b
er
ofs.
It
returns
the
actual
n
um
b
er
of
c
haracters
read,
b
et
w
een
0
and
len
(inclusiv
e).
A
return
v
alue
of
0
means
that
the
end
of
le
w
as
reac
hed.
A
return
v
alue
b
et
w
een
0
and
len
exclusiv
e
means
that
no
more
c
haracters
w
ere
a
v
ailable
at
that
time;
input
m
ust
b
e
called
again
to
read
the
remaining
c
haracters,
if
desired.
Exception
Invalid_argument
"input"
is
raised
if
ofs
and
len
do
not
designate
a
v
alid
substring
of
buff.
value
really_input
:
in_channel
->
string
->
int
->
int
->
unit
really_input
chan
buff
ofs
len
reads
len
c
haracters
from
c
hannel
chan,
storing
them
in
string
buff,
starting
at
c
haracter
n
um
b
er
ofs.
Raise
End_of_file
if
the
end
of
le
is
reac
hed
b
efore
len
c
haracters
ha
v
e
b
een
read.
Raise
Invalid_argument
"really_input"
if
ofs
and
len
do
not
designate
a
v
alid
substring
of
buff.

Chapter
.
The
core
library

value
input_byte
:
in_channel
->
int
Same
as
input_char,
but
return
the
-bit
in
teger
represen
ting
the
c
haracter.
Raise
End_of_file
if
an
end
of
le
w
as
reac
hed.
value
input_binary_int
:
in_channel
->
int
Read
an
in
teger
enco
ded
in
binary
format
from
the
giv
en
input
c
hannel.
See
output_binary_int.
Raise
End_of_file
if
an
end
of
le
w
as
reac
hed
while
reading
the
in
teger.
value
input_value
:
in_channel
->
'a
Read
the
represen
tation
of
a
structured
v
alue,
as
pro
duced
b
y
output_value
or
output_compact_value,
and
return
the
corresp
onding
v
alue.
This
is
not
t
yp
e-safe.
The
t
yp
e
of
the
returned
ob
ject
is
not
'a
prop
erly
sp
eaking:
the
returned
ob
ject
has
one
unique
t
yp
e,
whic
h
cannot
b
e
determined
at
compile-time.
The
programmer
should
explicitly
giv
e
the
exp
ected
t
yp
e
of
the
returned
v
alue,
using
the
follo
wing
syn
tax:
(input_value
chan
:
type).
The
b
eha
vior
is
unsp
ecied
if
the
ob
ject
in
the
le
do
es
not
b
elong
to
the
giv
en
t
yp
e.
value
seek_in
:
in_channel
->
int
->
unit
seek_in
chan
pos
sets
the
curren
t
reading
p
osition
to
pos
for
c
hannel
chan.
This
w
orks
only
for
regular
les.
On
les
of
other
kinds,
the
b
eha
vior
is
unsp
ecied.
value
pos_in
:
in_channel
->
int
Return
the
curren
t
reading
p
osition
for
the
giv
en
c
hannel.
value
in_channel_length
:
in_channel
->
int
Return
the
total
length
(n
um
b
er
of
c
haracters)
of
the
giv
en
c
hannel.
This
w
orks
only
for
regular
les.
On
les
of
other
kinds,
the
result
is
meaningless.
value
close_in
:
in_channel
->
unit
Close
the
giv
en
c
hannel.
An
ything
can
happ
en
if
an
y
of
the
functions
ab
o
v
e
is
called
on
a
closed
c
hannel.
.
list:
op
erations
on
lists
value
list_length
:
'a
list
->
int
Return
the
length
(n
um
b
er
of
elemen
ts)
of
the
giv
en
list.
value
prefix
@
:
'a
list
->
'a
list
->
'a
list
List
concatenation.


value
hd
:
'a
list
->
'a
Return
the
rst
elemen
t
of
the
giv
en
list.
Raise
Failure
"hd"
if
the
list
is
empt
y
.
value
tl
:
'a
list
->
'a
list
Return
the
giv
en
list
without
its
rst
elemen
t.
Raise
Failure
"tl"
if
the
list
is
empt
y
.
value
rev
:
'a
list
->
'a
list
List
rev
ersal.
value
map
:
('a
->
'b)
->
'a
list
->
'b
list
map
f
[a;
...;
an]
applies
function
f
to
a,
...,
an,
and
builds
the
list
[f
a;
...;
f
an]
with
the
results
returned
b
y
f.
value
do_list
:
('a
->
unit)
->
'a
list
->
unit
do_list
f
[a;
...;
an]
applies
function
f
in
turn
to
a;
...;
an,
discarding
all
the
results.
It
is
equiv
alen
t
to
begin
f
a;
f
a;
...;
f
an;
()
end.
value
it_list
:
('a
->
'b
->
'a)
->
'a
->
'b
list
->
'a
it_list
f
a
[b;
...;
bn]
is
f
(...
(f
(f
a
b)
b)
...)
bn.
value
list_it
:
('a
->
'b
->
'b)
->
'a
list
->
'b
->
'b
list_it
f
[a;
...;
an]
b
is
f
a
(f
a
(...
(f
an
b)
...)).
value
map
:
('a
->
'b
->
'c)
->
'a
list
->
'b
list
->
'c
list
map
f
[a;
...;
an]
[b;
...;
bn]
is
[f
a
b;
...;
f
an
bn].
Raise
Invalid_argument
"map"
if
the
t
w
o
lists
ha
v
e
dieren
t
lengths.
value
do_list
:
('a
->
'b
->
unit)
->
'a
list
->
'b
list
->
unit
do_list
f
[a;
...;
an]
[b;
...;
bn]
calls
in
turn
f
a
b;
...;
f
an
bn,
discarding
the
results.
Raise
Invalid_argument
"do_list"
if
the
t
w
o
lists
ha
v
e
dieren
t
lengths.
value
it_list
:
('a
->
'b
->
'c
->
'a)
->
'a
->
'b
list
->
'c
list
->
'a
it_list
f
a
[b;
...;
bn]
[c;
...;
cn]
is
f
(...
(f
(f
a
b
c)
b
c)
...)
bn
cn.
Raise
Invalid_argument
"it_list"
if
the
t
w
o
lists
ha
v
e
dieren
t
lengths.
value
list_it
:
('a
->
'b
->
'c
->
'c)
->
'a
list
->
'b
list
->
'c
->
'c
list_it
f
[a;
...;
an]
[b;
...;
bn]
c
is
f
a
b
(f
a
b
(...
(f
an
bn
c)
...)).
Raise
Invalid_argument
"list_it"
if
the
t
w
o
lists
ha
v
e
dieren
t
lengths.

Chapter
.
The
core
library
	
value
flat_map
:
('a
->
'b
list)
->
'a
list
->
'b
list
flat_map
f
[l;
...;
ln]
is
(f
l)
@
(f
l)
@
...
@
(f
ln).
value
for_all
:
('a
->
bool)
->
'a
list
->
bool
for_all
p
[a;
...;
an]
is
(p
a)
&
(p
a)
&
...
&
(p
an).
value
exists
:
('a
->
bool)
->
'a
list
->
bool
exists
p
[a;
...;
an]
is
(p
a)
or
(p
a)
or
...
or
(p
an).
value
mem
:
'a
->
'a
list
->
bool
mem
a
l
is
true
if
and
only
if
a
is
structurally
equal
(see
mo
dule
eq)
to
an
elemen
t
of
l.
value
memq
:
'a
->
'a
list
->
bool
memq
a
l
is
true
if
and
only
if
a
is
ph
ysically
equal
(see
mo
dule
eq)
to
an
elemen
t
of
l.
value
except
:
'a
->
'a
list
->
'a
list
except
a
l
returns
the
list
l
where
the
rst
elemen
t
structurally
equal
to
a
has
b
een
remo
v
ed.
The
list
l
is
returned
unc
hanged
if
it
do
es
not
con
tain
a.
value
exceptq
:
'a
->
'a
list
->
'a
list
Same
as
except,
with
ph
ysical
equalit
y
instead
of
structural
equalit
y
.
value
subtract
:
'a
list
->
'a
list
->
'a
list
subtract
l
l
returns
the
list
l
where
all
elemen
ts
structurally
equal
to
one
of
the
elemen
ts
of
l
ha
v
e
b
een
remo
v
ed.
value
union
:
'a
list
->
'a
list
->
'a
list
union
l
l
app
ends
b
efore
list
l
all
the
elemen
ts
of
list
l
that
are
not
structurally
equal
to
an
elemen
t
of
l.
value
intersect
:
'a
list
->
'a
list
->
'a
list
intersect
l
l
returns
the
list
of
the
elemen
ts
of
l
that
are
structurally
equal
to
an
elemen
t
of
l.
value
index
:
'a
->
'a
list
->
int
index
a
l
returns
the
p
osition
of
the
rst
elemen
t
of
list
l
that
is
structurally
equal
to
a.
The
head
of
the
list
has
p
osition
0.
Raise
Not_found
if
a
is
not
presen
t
in
l.
value
assoc
:
'a
->
('a
*
'b)
list
->
'b
assoc
a
l
returns
the
v
alue
asso
ciated
with
k
ey
a
in
the
list
of
pairs
l.
That
is,
assoc
a
[
...;
(a,b);
...]
=
b
if
(a,b)
is
the
leftmost
binding
of
a
in
list
l.
Raise
Not_found
if
there
is
no
v
alue
asso
ciated
with
a
in
the
list
l.
value
assq
:
'a
->
('a
*
'b)
list
->
'b
Same
as
assoc,
but
use
ph
ysical
equalit
y
instead
of
structural
equalit
y
to
compare
k
eys.
value
mem_assoc
:
'a
->
('a
*
'b)
list
->
bool
Same
as
assoc,
but
simply
return
true
if
a
binding
exists,
and
false
if
no
bindings
exist
for
the
giv
en
k
ey
.

0
.
pair:
op
erations
on
pairs
value
fst
:
'a
*
'b
->
'a
Return
the
rst
comp
onen
t
of
a
pair.
value
snd
:
'a
*
'b
->
'b
Return
the
second
comp
onen
t
of
a
pair.
value
split
:
('a
*
'b)
list
->
'a
list
*
'b
list
T
ransform
a
list
of
pairs
in
to
a
pair
of
lists:
split
[(a,b);
...;
(an,bn)]
is
([a;
...;
an],
[b;
...;
bn])
value
combine
:
'a
list
*
'b
list
->
('a
*
'b)
list
T
ransform
a
pair
of
lists
in
to
a
list
of
pairs:
combine
([a;
...;
an],
[b;
...;
bn])
is
[(a,b);
...;
(an,bn)].
Raise
Invalid_argument
"combine"
if
the
t
w
o
lists
ha
v
e
dieren
t
lengths.
value
map_combine
:
('a
*
'b
->
'c)
->
'a
list
*
'b
list
->
'c
list
map_combine
f
([a;
...;
an],
[b;
...;
bn])
is
[f
(a,
b);
...;
f
(an,
bn)].
Raise
invalid_argument
"map_combine"
if
the
t
w
o
lists
ha
v
e
dieren
t
lengths.
value
do_list_combine
:
('a
*
'b
->
unit)
->
'a
list
*
'b
list
->
unit
do_list_combine
f
([a;
...;
an],
[b;
...;
bn])
calls
in
turn
f
(a,
b);
...;
f
(an,
bn),
discarding
the
results.
Raise
Invalid_argument
"do_list_combine"
if
the
t
w
o
lists
ha
v
e
dieren
t
lengths.
.
ref:
op
erations
on
references
type
'a
ref
=
ref
of
mutable
'a
The
t
yp
e
of
references
(m
utable
indirection
cells)
con
taining
a
v
alue
of
t
yp
e
'a.
value
prefix
!
:
'a
ref
->
'a
!r
returns
the
curren
t
con
ten
ts
of
reference
r.
Could
b
e
dened
as
fun
(ref
x)
->
x.
value
prefix
:=
:
'a
ref
->
'a
->
unit
r
:=
a
stores
the
v
alue
of
a
in
reference
r.
value
incr
:
int
ref
->
unit
Incremen
t
the
in
teger
con
tained
in
the
giv
en
reference.
Could
b
e
dened
as
fun
r
->
r
:=
succ
!r.
value
decr
:
int
ref
->
unit
Decremen
t
the
in
teger
con
tained
in
the
giv
en
reference.
Could
b
e
dened
as
fun
r
->
r
:=
pred
!r.

Chapter
.
The
core
library

.
stream:
op
erations
on
streams
type
'a
stream
The
t
yp
e
of
streams
con
taining
v
alues
of
t
yp
e
'a.
exception
Parse_failure
Raised
b
y
parsers
when
none
of
the
rst
comp
onen
t
of
the
stream
patterns
is
accepted
exception
Parse_error
Raised
b
y
parsers
when
the
rst
comp
onen
t
of
a
stream
pattern
is
accepted,
but
one
of
the
follo
wing
comp
onen
ts
is
rejected
value
stream_next
:
'a
stream
->
'a
stream_next
s
returns
the
rst
elemen
t
of
stream
s,
and
remo
v
es
it
from
the
stream.
Raise
Parse_failure
if
the
stream
is
empt
y
.
value
stream_from
:
(unit
->
'a)
->
'a
stream
stream_from
f
returns
the
stream
whic
h
fetc
hes
its
terminals
using
the
function
f.
This
function
could
b
e
dened
as:
let
rec
stream_from
f
=
[<
'f();
stream_from
f
>]
but
is
implemen
ted
more
ecien
tly
.
value
stream_of_string
:
string
->
char
stream
stream_of_string
s
returns
the
stream
of
the
c
haracters
in
string
s.
value
stream_of_channel
:
in_channel
->
char
stream
stream_of_channel
ic
returns
the
stream
of
c
haracters
read
on
c
hannel
ic.
value
do_stream
:
('a
->
unit)
->
'a
stream
->
unit
do_stream
f
s
scans
the
whole
stream
s,
applying
the
function
f
in
turn
to
eac
h
terminal
encoun
tered
value
stream_check
:
('a
->
bool)
->
'a
stream
->
'a
stream_check
p
returns
the
parser
whic
h
returns
the
rst
terminal
of
the
stream
if
the
predicate
p
returns
true
on
this
terminal,
and
raises
Parse_failure
otherwise.
value
end_of_stream
:
'a
stream
->
unit
Return
()
i
the
stream
is
empt
y
,
and
raise
Parse_failure
otherwise.
value
stream_get
:
'a
stream
->
'a
*
'a
stream
stream_get
s
return
the
rst
elemen
t
of
the
stream
s,
and
a
stream
con
taining
the
remaining
elemen
ts
of
s.
Raise
Parse_failure
if
the
stream
is
empt
y
.
The
stream
s
is
not
mo
died.
This
function
mak
es
it
p
ossible
to
access
a
stream
non-destructiv
ely
.


.
string:
string
op
erations
value
string_length
:
string
->
int
Return
the
length
(n
um
b
er
of
c
haracters)
of
the
giv
en
string.
value
nth_char
:
string
->
int
->
char
nth_char
s
n
returns
c
haracter
n
um
b
er
n
in
string
s.
The
rst
c
haracter
is
c
haracter
n
um
b
er
0.
The
last
c
haracter
is
c
haracter
n
um
b
er
string_length
s
-
.
Raise
Invalid_argument
"nth_char"
if
n
is
ouside
the
range
0
to
(string_length
s
-
).
Y
ou
can
also
write
s.[n]
instead
of
nth_char
s
n.
value
set_nth_char
:
string
->
int
->
char
->
unit
set_nth_char
s
n
c
mo
dies
string
s
in
place,
replacing
the
c
haracter
n
um
b
er
n
b
y
c.
Raise
Invalid_argument
"set_nth_char"
if
n
is
ouside
the
range
0
to
(string_length
s
-
).
Y
ou
can
also
write
s.[n]
<-
c
instead
of
set_nth_char
s
n
c.
value
prefix
^
:
string
->
string
->
string
s
^
s
returns
a
fresh
string
con
taining
the
concatenation
of
the
strings
s
and
s.
value
concat
:
string
list
->
string
Return
a
fresh
string
con
taining
the
concatenation
of
all
the
strings
in
the
argumen
t
list.
value
sub_string
:
string
->
int
->
int
->
string
sub_string
s
start
len
returns
a
fresh
string
of
length
len,
con
taining
the
c
haracters
n
um
b
er
start
to
start
+
len
-

of
string
s.
Raise
Invalid_argument
"sub_string"
if
start
and
len
do
not
designate
a
v
alid
substring
of
s;
that
is,
if
start
<
0,
or
len
<
0,
or
start
+
len
>
string_length
s.
value
create_string
:
int
->
string
create_string
n
returns
a
fresh
string
of
length
n.
The
string
initially
con
tains
arbitrary
c
haracters.
value
make_string
:
int
->
char
->
string
make_string
n
c
returns
a
fresh
string
of
length
n,
lled
with
the
c
haracter
c.
value
fill_string
:
string
->
int
->
int
->
char
->
unit
fill_string
s
start
len
c
mo
dies
string
s
in
place,
replacing
the
c
haracters
n
um
b
er
start
to
start
+
len
-

b
y
c.
Raise
Invalid_argument
"fill_string"
if
start
and
len
do
not
designate
a
v
alid
substring
of
s.

Chapter
.
The
core
library

value
blit_string
:
string
->
int
->
string
->
int
->
int
->
unit
blit_string
s
o
s
o
len
copies
len
c
haracters
from
string
s,
starting
at
c
haracter
n
um
b
er
o,
to
string
s,
starting
at
c
haracter
n
um
b
er
o.
It
w
orks
correctly
ev
en
if
s
and
s
are
the
same
string,
and
the
source
and
destination
c
h
unks
o
v
erlap.
Raise
Invalid_argument
"blit_string"
if
o
and
len
do
not
designate
a
v
alid
substring
of
s,
or
if
o
and
len
do
not
designate
a
v
alid
substring
of
s.
value
replace_string
:
string
->
string
->
int
->
unit
replace_string
dest
src
start
copies
all
c
haracters
from
the
string
src
in
to
the
string
dst,
starting
at
c
haracter
n
um
b
er
start
in
dst.
Raise
Invalid_argument
"replace_string"
if
cop
ying
w
ould
o
v
ero
w
string
dest.
value
eq_string
:
string
->
string
->
bool
value
neq_string
:
string
->
string
->
bool
value
le_string
:
string
->
string
->
bool
value
lt_string
:
string
->
string
->
bool
value
ge_string
:
string
->
string
->
bool
value
gt_string
:
string
->
string
->
bool
Comparison
functions
(lexicographic
ordering)
b
et
w
een
strings.
value
compare_strings
:
string
->
string
->
int
General
comparison
b
et
w
een
strings.
compare_strings
s
s
returns
0
if
s
and
s
are
equal,
or
else
-
if
s
is
a
prex
of
s,
or

if
s
is
a
prex
of
s,
or
else
-
if
s
is
lexicographically
b
efore
s,
or

if
s
is
lexicographically
b
efore
s.
value
string_for_read
:
string
->
string
Return
a
cop
y
of
the
argumen
t,
with
sp
ecial
c
haracters
represen
ted
b
y
escap
e
sequences,
follo
wing
the
lexical
con
v
en
tions
of
Caml
Ligh
t.
value
index_char:
string
->
char
->
int
index_char
s
c
returns
the
p
osition
of
the
leftmost
o
ccurrence
of
c
haracter
c
in
string
s.
Raise
Not_found
if
c
do
es
not
o
ccur
in
s.
value
rindex_char:
string
->
char
->
int
rindex_char
s
c
returns
the
p
osition
of
the
righ
tmost
o
ccurrence
of
c
haracter
c
in
string
s.
Raise
Not_found
if
c
do
es
not
o
ccur
in
s.
value
index_char_from:
string
->
int
->
char
->
int
value
rindex_char_from:
string
->
int
->
char
->
int
Same
as
index_char
and
rindex_char,
but
start
searc
hing
at
the
c
haracter
p
osition
giv
en
as
second
argumen
t.
index_char
s
c
is
equiv
alen
t
to
index_char_from
s
0
c,
and
rindex_char
s
c
to
rindex_char_from
s
(string_length
s
-
)
c.


.
vect:
op
erations
on
v
ectors
value
vect_length
:
'a
vect
->
int
Return
the
length
(n
um
b
er
of
elemen
ts)
of
the
giv
en
v
ector.
value
vect_item
:
'a
vect
->
int
->
'a
vect_item
v
n
returns
the
elemen
t
n
um
b
er
n
of
v
ector
v.
The
rst
elemen
t
has
n
um
b
er
0.
The
last
elemen
t
has
n
um
b
er
vect_length
v
-
.
Raise
Invalid_argument
"vect_item"
if
n
is
outside
the
range
0
to
(vect_length
v
-
).
Y
ou
can
also
write
v.(n)
instead
of
vect_item
v
n.
value
vect_assign
:
'a
vect
->
int
->
'a
->
unit
vect_assign
v
n
x
mo
dies
v
ector
v
in
place,
replacing
elemen
t
n
um
b
er
n
with
x.
Raise
Invalid_argument
"vect_assign"
if
n
is
outside
the
range
0
to
vect_length
v
-
.
Y
ou
can
also
write
v.(n)
<-
x
instead
of
vect_assign
v
n
x.
value
make_vect
:
int
->
'a
->
'a
vect
make_vect
n
x
returns
a
fresh
v
ector
of
length
n,
initialized
with
x.
All
the
elemen
ts
of
this
new
v
ector
are
initially
ph
ysically
equal
to
x
(see
mo
dule
eq).
Consequen
tly
,
if
x
is
m
utable,
it
is
shared
among
all
elemen
ts
of
the
v
ector,
and
mo
difying
x
through
one
of
the
v
ector
en
tries
will
mo
dify
all
other
en
tries
at
the
same
time.
value
make_matrix
:
int
->
int
->
'a
->
'a
vect
vect
make_matrix
dimx
dimy
e
returns
a
t
w
o-dimensional
arra
y
(a
v
ector
of
v
ectors)
with
rst
dimension
dimx
and
second
dimension
dimy.
All
the
elemen
ts
of
this
new
matrix
are
initially
ph
ysically
equal
to
e.
The
elemen
t
(x,y)
of
a
matrix
m
is
accessed
with
the
notation
m.(x).(y).
value
init_vect
:
int
->
(int
->
'a)
->
'a
vect
init_vect
n
f
returns
a
fresh
arra
y
of
length
n,
with
elemen
t
n
um
b
er
i
equal
to
f
i.
value
concat_vect
:
'a
vect
->
'a
vect
->
'a
vect
concat_vect
v
v
returns
a
fresh
v
ector
con
taining
the
concatenation
of
v
ectors
v
and
v.
value
sub_vect
:
'a
vect
->
int
->
int
->
'a
vect
sub_vect
v
start
len
returns
a
fresh
v
ector
of
length
len,
con
taining
the
elemen
ts
n
um
b
er
start
to
start
+
len
-

of
v
ector
v.
Raise
Invalid_argument
"sub_vect"
if
start
and
len
do
not
designate
a
v
alid
sub
v
ector
of
v;
that
is,
if
start
<
0,
or
len
<
0,
or
start
+
len
>
vect_length
v.
value
copy_vect
:
'a
vect
->
'a
vect
copy_vect
v
returns
a
cop
y
of
v,
that
is,
a
fresh
v
ector
con
taining
the
same
elemen
ts
as
v.

Chapter
.
The
core
library

value
fill_vect
:
'a
vect
->
int
->
int
->
'a
->
unit
fill_vect
v
ofs
len
x
mo
dies
the
v
ector
v
in
place,
storing
x
in
elemen
ts
n
um
b
er
ofs
to
ofs
+
len
-
.
Raise
Invalid_argument
"fill_vect"
if
ofs
and
len
do
not
designate
a
v
alid
sub
v
ector
of
v.
value
blit_vect
:
'a
vect
->
int
->
'a
vect
->
int
->
int
->
unit
blit_vect
v
o
v
o
len
copies
len
elemen
ts
from
v
ector
v,
starting
at
elemen
t
n
um
b
er
o,
to
v
ector
v,
starting
at
elemen
t
n
um
b
er
o.
It
w
orks
correctly
ev
en
if
v
and
v
are
the
same
v
ector,
and
the
source
and
destination
c
h
unks
o
v
erlap.
Raise
Invalid_argument
"blit_vect"
if
o
and
len
do
not
designate
a
v
alid
sub
v
ector
of
v,
or
if
o
and
len
do
not
designate
a
v
alid
sub
v
ector
of
v.
value
list_of_vect
:
'a
vect
->
'a
list
list_of_vect
v
returns
the
list
of
all
the
elemen
ts
of
v,
that
is:
[v.(0);
v.();
...;
v.(vect_length
v
-
)].
value
vect_of_list
:
'a
list
->
'a
vect
vect_of_list
l
returns
a
fresh
v
ector
con
taining
the
elemen
ts
of
l.
value
map_vect
:
('a
->
'b)
->
'a
vect
->
'b
vect
map_vect
f
v
applies
function
f
to
all
the
elemen
ts
of
v,
and
builds
a
v
ector
with
the
results
returned
b
y
f:
[|
f
v.(0);
f
v.();
...;
f
v.(vect_length
v
-
)
|].
value
map_vect_list
:
('a
->
'b)
->
'a
vect
->
'b
list
map_vect_list
f
v
applies
function
f
to
all
the
elemen
ts
of
v,
and
builds
a
list
with
the
results
returned
b
y
f:
[
f
v.(0);
f
v.();
...;
f
v.(vect_length
v
-
)
].
value
do_vect
:
('a
->
unit)
->
'a
vect
->
unit
do_vect
f
v
applies
function
f
in
turn
to
all
the
elemen
ts
of
v,
discarding
all
the
results:
f
v.(0);
f
v.();
...;
f
v.(vect_length
v
-
);
().



Chapter

The
standard
library
This
c
hapter
describ
es
the
functions
pro
vided
b
y
the
Caml
Ligh
t
standard
library
.
Just
as
the
mo
dules
from
the
core
library
,
the
mo
dules
from
the
standard
library
are
automatically
link
ed
with
the
user's
ob
ject
co
de
les
b
y
the
camlc
command.
Hence,
the
globals
dened
b
y
these
libraries
can
b
e
used
in
standalone
programs
without
ha
ving
to
add
an
y
.zo
le
on
the
command
line
for
the
linking
phase.
Similarly
,
in
in
teractiv
e
use,
these
globals
can
b
e
used
in
toplev
el
phrases
without
ha
ving
to
load
an
y
.zo
le
in
memory
.
Unlik
e
the
mo
dules
from
the
core
library
,
the
mo
dules
from
the
standard
library
are
not
auto-
matically
\op
ened"
when
a
compilation
starts,
or
when
the
toplev
el
system
is
launc
hed.
Hence
it
is
necessary
to
use
qualied
iden
tiers
to
refer
to
the
functions
pro
vided
b
y
these
mo
dules,
or
to
add
#open
directiv
es.
Con
v
en
tions
F
or
easy
reference,
the
mo
dules
are
listed
b
elo
w
in
alphab
etical
order
of
mo
dule
names.
F
or
eac
h
mo
dule,
the
declarations
from
its
in
terface
le
are
prin
ted
one
b
y
one
in
t
yp
ewriter
fon
t,
follo
w
ed
b
y
a
short
commen
t.
All
mo
dules
and
the
iden
tiers
they
exp
ort
are
indexed
at
the
end
of
this
rep
ort.
.
arg:
parsing
of
command
line
argumen
ts
This
mo
dule
pro
vides
a
general
mec
hanism
for
extracting
options
and
argumen
ts
from
the
command
line
to
the
program.
Syn
tax
of
command
lines:
A
k
eyw
ord
is
a
c
haracter
string
starting
with
a
-.
An
option
is
a
k
eyw
ord
alone
or
follo
w
ed
b
y
an
argumen
t.
There
are
four
t
yp
es
of
k
eyw
ords:
Unit,
String,
In
t,
and
Float.
Unit
k
eyw
ords
do
not
tak
e
an
argumen
t.
String,
In
t,
and
Float
k
eyw
ords
tak
e
the
follo
wing
w
ord
on
the
command
line
as
an
argumen
t.
Argumen
ts
not
preceded
b
y
a
k
eyw
ord
are
called
anon
ymous
argumen
ts.
Examples
(cmd
is
assumed
to
b
e
the
command
name):
cmd
-flag
(a
unit
option)



cmd
-int

(an
in
t
option
with
argumen
t
)
cmd
-string
foobar
(a
string
option
with
argumen
t
"foobar")
cmd
-float
.
(a
oat
option
with
argumen
t
.)
cmd



(three
anon
ymous
argumen
ts:
"",
"",
and
"")
cmd


-flag

-string
bar

(four
anon
ymous
argumen
ts,
a
unit
option,
and
a
string
option
with
argumen
t
"bar")
type
spec
=
String
of
(string
->
unit)
|
Int
of
(int
->
unit)
|
Unit
of
(unit
->
unit)
|
Float
of
(float
->
unit)
The
concrete
t
yp
e
describing
the
b
eha
vior
asso
ciated
with
a
k
eyw
ord.
value
parse
:
(string
*
spec)
list
->
(string
->
unit)
->
unit
parse
speclist
anonfun
parses
the
command
line,
calling
the
functions
in
speclist
whenev
er
appropriate,
and
anonfun
on
anon
ymous
argumen
ts.
The
functions
are
called
in
the
same
order
as
they
app
ear
on
the
command
line.
The
strings
in
the
(string
*
spec)
list
are
k
eyw
ords
and
m
ust
start
with
a
-,
else
they
are
ignored.
F
or
the
user
to
b
e
able
to
sp
ecify
anon
ymous
argumen
ts
starting
with
a
-,
include
for
example
("--",
String
anonfun)
in
speclist.
exception
Bad
of
string
F
unctions
in
speclist
or
anonfun
can
raise
Bad
with
an
error
message
to
reject
in
v
alid
argumen
ts.
.
baltree:
basic
balanced
binary
trees
This
mo
dule
implemen
ts
balanced
ordered
binary
trees.
All
op
erations
o
v
er
binary
trees
are
applicativ
e
(no
side-eects).
The
set
and
map
mo
dules
are
based
on
this
mo
dule.
This
mo
dules
giv
es
a
more
direct
access
to
the
in
ternals
of
the
binary
tree
implemen
tation
than
the
set
and
map
abstractions,
but
is
more
delicate
to
use
and
not
as
safe.
F
or
adv
anced
users
only
.
type
'a
t
=
Empty
|
Node
of
'a
t
*
'a
*
'a
t
*
int
The
t
yp
e
of
trees
con
taining
elemen
ts
of
t
yp
e
'a.
Empty
is
the
empt
y
tree
(con
taining
no
elemen
ts).
type
'a
contents
=
Nothing
|
Something
of
'a
Used
with
the
functions
modify
and
split,
to
represen
t
the
presence
or
the
absence
of
an
elemen
t
in
a
tree.

Chapter
.
The
standard
library
	
value
add:
('a
->
int)
->
'a
->
'a
t
->
'a
t
add
f
x
t
inserts
the
elemen
t
x
in
to
the
tree
t.
f
is
an
ordering
function:
f
y
m
ust
return
0
if
x
and
y
are
equal
(or
equiv
alen
t),
a
negativ
e
in
teger
if
x
is
smaller
than
y,
and
a
p
ositiv
e
in
teger
if
x
is
greater
than
y.
The
tree
t
is
returned
unc
hanged
if
it
already
con
tains
an
elemen
t
equiv
alen
t
to
x
(that
is,
an
elemen
t
y
suc
h
that
f
y
is
0).
The
ordering
f
m
ust
b
e
consisten
t
with
the
orderings
used
to
build
t
with
add,
remove,
modify
or
split
op
erations.
value
contains:
('a
->
int)
->
'a
t
->
bool
contains
f
t
c
hec
ks
whether
t
con
tains
an
elemen
t
satisfying
f,
that
is,
an
elemen
t
x
suc
h
that
f
x
is
0.
f
is
an
ordering
function
with
the
same
constrain
ts
as
for
add.
It
can
b
e
coarser
(iden
tify
more
elemen
ts)
than
the
orderings
used
to
build
t,
but
m
ust
b
e
consisten
t
with
them.
value
find:
('a
->
int)
->
'a
t
->
'a
Same
as
contains,
except
that
find
f
t
returns
the
elemen
t
x
suc
h
that
f
x
is
0,
or
raises
Not_found
if
none
has
b
een
found.
value
remove:
('a
->
int)
->
'a
t
->
'a
t
remove
f
t
remo
v
es
one
elemen
t
x
of
t
suc
h
that
f
x
is
0.
f
is
an
ordering
function
with
the
same
constrain
ts
as
for
add.
t
is
returned
unc
hanged
if
it
do
es
not
con
tain
an
y
elemen
t
satisfying
f.
If
sev
eral
elemen
ts
of
t
satisfy
f,
only
one
is
remo
v
ed.
value
modify:
('a
->
int)
->
('a
contents
->
'a
contents)
->
'a
t
->
'a
t
General
insertion/mo
dication/deleti
on
function.
modify
f
g
t
searc
hs
t
for
an
elemen
t
x
satisfying
the
ordering
function
f.
If
one
is
found,
g
is
applied
to
Something
x;
if
g
returns
Nothing,
the
elemen
t
x
is
remo
v
ed;
if
g
returns
Something
y,
the
elemen
t
y
replaces
x
in
the
tree.
(It
is
assumed
that
x
and
y
are
equiv
alen
t,
in
particular,
that
f
y
is
0.)
If
the
tree
do
es
not
con
tain
an
y
x
satisfying
f,
g
is
applied
to
Nothing;
if
it
returns
Nothing,
the
tree
is
returned
unc
hanged;
if
it
returns
Something
x,
the
elemen
t
x
is
inserted
in
the
tree.
(It
is
assumed
that
f
x
is
0.)
The
functions
add
and
remove
are
sp
ecial
cases
of
modify,
sligh
tly
more
ecien
t.
value
split:
('a
->
int)
->
'a
t
->
'a
t
*
'a
contents
*
'a
t
split
f
t
returns
a
triple
(less,
elt,
greater)
where
less
is
a
tree
con
taining
all
elemen
ts
x
of
t
suc
h
that
f
x
is
negativ
e,
greater
is
a
tree
con
taining
all
elemen
ts
x
of
t
suc
h
that
f
x
is
p
ositiv
e,
and
elt
is
Something
x
if
t
con
tains
an
elemen
t
x
suc
h
that
f
x
is
0,
and
Nothing
otherwise.
value
compare:
('a
->
'a
->
int)
->
'a
t
->
'a
t
->
int
Compare
t
w
o
trees.
The
rst
argumen
t
f
is
a
comparison
function
o
v
er
the
tree
elemen
ts:
f
e
e
is
zero
if
the
elemen
ts
e
and
e
are
equal,
negativ
e
if
e
is
smaller
than
e,
and
p
ositiv
e
if
e
is
greater
than
e.
compare
f
t
t
compares
the
fringes
of
t
and
t
b
y
lexicographic
extension
of
f.

0
.
filename:
op
erations
on
le
names
value
current_dir_name
:
string
The
con
v
en
tional
name
for
the
curren
t
directory
(e.g.
.
in
Unix).
value
concat
:
string
->
string
->
string
concat
dir
file
returns
a
le
name
that
designates
le
file
in
directory
dir.
value
is_absolute
:
string
->
bool
Return
true
if
the
le
name
is
absolute
or
starts
with
an
explicit
reference
to
the
curren
t
directory
(./
or
../
in
Unix),
and
false
if
it
is
relativ
e
to
the
curren
t
directory
.
value
check_suffix
:
string
->
string
->
bool
check_suffix
name
suff
returns
true
if
the
lename
name
ends
with
the
sux
suff.
value
chop_suffix
:
string
->
string
->
string
chop_suffix
name
suff
remo
v
es
the
sux
suff
from
the
lename
name.
The
b
eha
vior
is
undened
if
name
do
es
not
end
with
the
sux
suff.
value
basename
:
string
->
string
value
dirname
:
string
->
string
Split
a
le
name
in
to
directory
name
/
base
le
name.
concat
(dirname
name)
(basename
name)
returns
a
le
name
whic
h
is
equiv
alen
t
to
name.
Moreo
v
er,
after
setting
the
curren
t
directory
to
dirname
name
(with
sys__chdir),
references
to
basename
name
(whic
h
is
a
relativ
e
le
name)
designate
the
same
le
as
name
b
efore
the
call
to
chdir.
.
format:
prett
y
prin
ting
This
mo
dule
implemen
ts
a
prett
y-prin
ting
facilit
y
to
format
text
within
\prett
y-prin
ting
b
o
xes".
The
prett
y-prin
ter
breaks
lines
at
sp
ecied
break
hin
ts,
and
inden
ts
lines
according
to
the
b
o
x
structure.
Rule
of
th
um
b
for
casual
users:
use
simple
b
o
xes
(as
obtained
b
y
open_box
0);
use
simple
break
hin
ts
(as
obtained
b
y
print_cut
()
that
outputs
a
simple
break
hin
t,
or
b
y
print_space
()
that
ouputs
a
space
indicating
a
break
hin
t);
once
a
b
o
x
is
op
ened,
displa
y
its
material
with
basic
prin
ting
functions
(e.
g.
print_int
and
print_string);
when
the
material
for
a
b
o
x
has
b
een
prin
ted,
call
close_box
()
to
close
the
b
o
x;
at
the
end
of
y
our
routine,
ev
aluate
print_newline
()
to
close
all
remaining
b
o
xes
and
ush
the
prett
y-prin
ter.

Chapter
.
The
standard
library

Y
ou
ma
y
alternativ
ely
consider
this
mo
dule
as
pro
viding
an
extension
to
the
printf
facilit
y:
y
ou
can
simply
add
prett
y-prin
ting
annotations
to
y
our
regular
prin
tf
formats,
as
explained
b
elo
w
in
the
do
cumen
tation
of
the
function
fprintf.
The
b
eha
viour
of
prett
y-prin
ting
commands
is
unsp
ecied
if
there
is
no
op
ened
prett
y-prin
ting
b
o
x.
Eac
h
b
o
x
op
ened
via
one
of
the
open_
functions
b
elo
w
m
ust
b
e
closed
using
close_box
for
prop
er
formatting.
Otherwise,
some
of
the
material
prin
ted
in
the
b
o
xes
ma
y
not
b
e
output,
or
ma
y
b
e
formatted
incorrectly
.
In
case
of
in
teractiv
e
use,
the
system
closes
all
op
ened
b
o
xes
and
ushes
all
p
ending
text
(as
with
the
print_newline
function)
after
eac
h
phrase.
Eac
h
phrase
is
therefore
executed
in
the
initial
state
of
the
prett
y-prin
ter.
Bo
xes
value
open_box
:
int
->
unit
open_box
d
op
ens
a
new
prett
y-prin
ting
b
o
x
with
oset
d.
This
b
o
x
is
the
general
purp
ose
prett
y-prin
ting
b
o
x.
Material
in
this
b
o
x
is
displa
y
ed
\horizon
tal
or
v
ertical":
break
hin
ts
inside
the
b
o
x
ma
y
lead
to
a
new
line,
if
there
is
no
more
ro
om
on
the
line
to
prin
t
the
remainder
of
the
b
o
x,
or
if
a
new
line
ma
y
lead
to
a
new
inden
tation
(demonstrating
the
inden
tation
of
the
b
o
x).
When
a
new
line
is
prin
ted
in
the
b
o
x,
d
is
added
to
the
curren
t
inden
tation.
value
close_box
:
unit
->
unit
Close
the
most
recen
tly
op
ened
prett
y-prin
ting
b
o
x.
F
ormatting
functions
value
print_string
:
string
->
unit
print_string
str
prin
ts
str
in
the
curren
t
b
o
x.
value
print_as
:
int
->
string
->
unit
print_as
len
str
prin
ts
str
in
the
curren
t
b
o
x.
The
prett
y-prin
ter
formats
str
as
if
it
w
ere
of
length
len.
value
print_int
:
int
->
unit
Prin
t
an
in
teger
in
the
curren
t
b
o
x.
value
print_float
:
float
->
unit
Prin
t
a
oating
p
oin
t
n
um
b
er
in
the
curren
t
b
o
x.
value
print_char
:
char
->
unit
Prin
t
a
c
haracter
in
the
curren
t
b
o
x.
value
print_bool
:
bool
->
unit
Prin
t
an
b
o
olean
in
the
curren
t
b
o
x.


Break
hin
ts
value
print_space
:
unit
->
unit
print_space
()
is
used
to
separate
items
(t
ypically
to
prin
t
a
space
b
et
w
een
t
w
o
w
ords).
It
indicates
that
the
line
ma
y
b
e
split
at
this
p
oin
t.
It
either
prin
ts
one
space
or
splits
the
line.
It
is
equiv
alen
t
to
print_break

0.
value
print_cut
:
unit
->
unit
print_cut
()
is
used
to
mark
a
go
o
d
break
p
osition.
It
indicates
that
the
line
ma
y
b
e
split
at
this
p
oin
t.
It
either
prin
ts
nothing
or
splits
the
line.
This
allo
ws
line
splitting
at
the
curren
t
p
oin
t,
without
prin
ting
spaces
or
adding
inden
tation.
It
is
equiv
alen
t
to
print_break
0
0.
value
print_break
:
int
->
int
->
unit
Insert
a
break
hin
t
in
a
prett
y-prin
ting
b
o
x.
print_break
nspaces
offset
indicates
that
the
line
ma
y
b
e
split
(a
newline
c
haracter
is
prin
ted)
at
this
p
oin
t,
if
the
con
ten
ts
of
the
curren
t
b
o
x
do
es
not
t
on
one
line.
If
the
line
is
split
at
that
p
oin
t,
offset
is
added
to
the
curren
t
inden
tation.
If
the
line
is
not
split,
nspaces
spaces
are
prin
ted.
value
print_flush
:
unit
->
unit
Flush
the
prett
y
prin
ter:
all
op
ened
b
o
xes
are
closed,
and
all
p
ending
text
is
displa
y
ed.
value
print_newline
:
unit
->
unit
Equiv
alen
t
to
print_flush
follo
w
ed
b
y
a
new
line.
value
force_newline
:
unit
->
unit
F
orce
a
newline
in
the
curren
t
b
o
x.
Not
the
normal
w
a
y
of
prett
y-prin
ting,
y
ou
should
prefer
break
hin
ts.
value
print_if_newline
:
unit
->
unit
Execute
the
next
formatting
command
if
the
preceding
line
has
just
b
een
split.
Otherwise,
ignore
the
next
formatting
command.
Margin
value
set_margin
:
int
->
unit
set_margin
d
sets
the
v
alue
of
the
righ
t
margin
to
d
(in
c
haracters):
this
v
alue
is
used
to
detect
line
o
v
ero
ws
that
leads
to
split
lines.
Nothing
happ
ens
if
d
is
smaller
than

or
bigger
than
									.
value
get_margin
:
unit
->
int
Return
the
p
osition
of
the
righ
t
margin.

Chapter
.
The
standard
library

Maxim
um
inden
tation
limit
value
set_max_indent
:
int
->
unit
set_max_indent
d
sets
the
v
alue
of
the
maxim
um
inden
tation
limit
to
d
(in
c
haracters):
once
this
limit
is
reac
hed,
b
o
xes
are
rejected
to
the
left,
if
they
do
not
t
on
the
curren
t
line.
Nothing
happ
ens
if
d
is
smaller
than

or
bigger
than
									.
value
get_max_indent
:
unit
->
int
Return
the
v
alue
of
the
maxim
um
inden
tation
limit
(in
c
haracters).
F
ormatting
depth:
maxim
um
n
um
b
er
of
b
o
xes
allo
w
ed
b
efore
ellipsis
value
set_max_boxes
:
int
->
unit
set_max_boxes
max
sets
the
maxim
um
n
um
b
er
of
b
o
xes
sim
ultaneously
op
ened.
Material
inside
b
o
xes
nested
deep
er
is
prin
ted
as
an
ellipsis
(more
precisely
as
the
text
returned
b
y
get_ellipsis_text
()).
Nothing
happ
ens
if
max
is
not
greater
than
.
value
get_max_boxes
:
unit
->
int
Return
the
maxim
um
n
um
b
er
of
b
o
xes
allo
w
ed
b
efore
ellipsis.
value
over_max_boxes
:
unit
->
bool
T
est
the
maxim
um
n
um
b
er
of
b
o
xes
allo
w
ed
ha
v
e
already
b
een
op
ened.
Adv
anced
formatting
value
open_hbox
:
unit
->
unit
open_hbox
()
op
ens
a
new
prett
y-prin
ting
b
o
x.
This
b
o
x
is
\horizon
tal":
the
line
is
not
split
in
this
b
o
x
(new
lines
ma
y
still
o
ccur
inside
b
o
xes
nested
deep
er).
value
open_vbox
:
int
->
unit
open_vbox
d
op
ens
a
new
prett
y-prin
ting
b
o
x
with
oset
d.
This
b
o
x
is
\v
ertical":
ev
ery
break
hin
t
inside
this
b
o
x
leads
to
a
new
line.
When
a
new
line
is
prin
ted
in
the
b
o
x,
d
is
added
to
the
curren
t
inden
tation.
value
open_hvbox
:
int
->
unit
open_hvbox
d
op
ens
a
new
prett
y-prin
ting
b
o
x
with
oset
d.
This
b
o
x
is
\horizon
tal-v
ertical":
it
b
eha
v
es
as
an
\horizon
tal"
b
o
x
if
it
ts
on
a
single
line,
otherwise
it
b
eha
v
es
as
a
\v
ertical"
b
o
x.
When
a
new
line
is
prin
ted
in
the
b
o
x,
d
is
added
to
the
curren
t
inden
tation.
value
open_hovbox
:
int
->
unit
open_hovbox
d
op
ens
a
new
prett
y-prin
ting
b
o
x
with
oset
d.
This
b
o
x
is
\horizon
tal
or
v
ertical":
break
hin
ts
inside
this
b
o
x
ma
y
lead
to
a
new
line,
if
there
is
no
more
ro
om
on
the
line
to
prin
t
the
remainder
of
the
b
o
x.
When
a
new
line
is
prin
ted
in
the
b
o
x,
d
is
added
to
the
curren
t
inden
tation.


T
abulations
value
open_tbox
:
unit
->
unit
Op
en
a
tabulation
b
o
x.
value
close_tbox
:
unit
->
unit
Close
the
most
recen
tly
op
ened
tabulation
b
o
x.
value
print_tbreak
:
int
->
int
->
unit
Break
hin
t
in
a
tabulation
b
o
x.
print_tbreak
spaces
offset
mo
v
es
the
insertion
p
oin
t
to
the
next
tabulation
(spaces
b
eing
added
to
this
p
osition).
Nothing
o
ccurs
if
insertion
p
oin
t
is
already
on
a
tabulation
mark.
If
there
is
no
next
tabulation
on
the
line,
then
a
newline
is
prin
ted
and
the
insertion
p
oin
t
mo
v
es
to
the
rst
tabulation
of
the
b
o
x.
If
a
new
line
is
prin
ted,
offset
is
added
to
the
curren
t
inden
tation.
value
set_tab
:
unit
->
unit
Set
a
tabulation
mark
at
the
curren
t
insertion
p
oin
t.
value
print_tab
:
unit
->
unit
print_tab
()
is
equiv
alen
t
to
print_tbreak
(0,0).
Ellipsis
value
set_ellipsis_text
:
string
->
unit
Set
the
text
of
the
ellipsis
prin
ted
when
to
o
man
y
b
o
xes
are
op
ened
(a
single
dot,
.,
b
y
default).
value
get_ellipsis_text
:
unit
->
string
Return
the
text
of
the
ellipsis.
Redirecting
formatter
output
value
set_formatter_out_channel
:
out_channel
->
unit
Redirect
the
prett
y-prin
ter
output
to
the
giv
en
c
hannel.
value
set_formatter_output_functi
ons
:
(string
->
int
->
int
->
unit)
->
(unit
->
unit)
->
unit
set_formatter_output_fu
nctions
out
flush
redirects
the
prett
y-prin
ter
output
to
the
functions
out
and
flush.
The
out
function
p
erforms
the
prett
y-prin
ter
output.
It
is
called
with
a
string
s,
a
start
p
osition
p,
and
a
n
um
b
er
of
c
haracters
n;
it
is
supp
osed
to
output
c
haracters
p
to
p+n-
of
s.
The
flush
function
is
called
whenev
er
the
prett
y-prin
ter
is
ushed
using
print_flush
or
print_newline.
value
get_formatter_output_functi
ons
:
unit
->
(string
->
int
->
int
->
unit)
*
(unit
->
unit)
Return
the
curren
t
output
functions
of
the
prett
y-prin
ter.

Chapter
.
The
standard
library

Multiple
formatted
output
type
formatter
Abstract
data
t
yp
e
corresp
onding
to
a
prett
y-prin
ter
and
all
its
mac
hinery
.
Dening
new
prett
y-prin
ters
p
ermits
the
output
of
material
in
parallel
on
sev
eral
c
hannels.
P
arameters
of
the
prett
y-prin
ter
are
lo
cal
to
the
prett
y-prin
ter:
margin,
maxim
um
inden
tation
limit,
maxim
um
n
um
b
er
of
b
o
xes
sim
ultaneously
op
ened,
ellipsis,
and
so
on,
are
sp
ecic
to
eac
h
prett
y-prin
ter
and
ma
y
b
e
xed
indep
enden
tly
.
A
new
formatter
is
obtained
b
y
calling
the
make_formatter
function.
value
std_formatter
:
formatter
The
standard
formatter
used
b
y
the
formatting
functions
ab
o
v
e.
It
is
dened
using
make_formatter
with
output
function
output
stdout
and
ushing
function
fun
()
->
flush
stdout.
value
err_formatter
:
formatter
A
formatter
to
use
with
formatting
functions
b
elo
w
for
output
to
standard
error.
It
is
dened
using
make_formatter
with
output
function
output
stderr
and
ushing
function
fun
()
->
flush
stderr.
value
make_formatter
:
(string
->
int
->
int
->
unit)
->
(unit
->
unit)
->
formatter
make_formatter
out
flush
returns
a
new
formatter
that
writes
according
to
the
output
function
out,
and
ushing
function
flush.
Hence,
a
formatter
to
out
c
hannel
oc
is
returned
b
y
make_formatter
(output
oc)
(fun
()
->
flush
oc).
value
pp_open_hbox
:
formatter
->
unit
->
unit
value
pp_open_vbox
:
formatter
->
int
->
unit
value
pp_open_hvbox
:
formatter
->
int
->
unit
value
pp_open_hovbox
:
formatter
->
int
->
unit
value
pp_open_box
:
formatter
->
int
->
unit
value
pp_close_box
:
formatter
->
unit
->
unit
value
pp_print_string
:
formatter
->
string
->
unit
value
pp_print_as
:
formatter
->
int
->
string
->
unit
value
pp_print_int
:
formatter
->
int
->
unit
value
pp_print_float
:
formatter
->
float
->
unit
value
pp_print_char
:
formatter
->
char
->
unit
value
pp_print_bool
:
formatter
->
bool
->
unit
value
pp_print_break
:
formatter
->
int
->
int
->
unit
value
pp_print_cut
:
formatter
->
unit
->
unit
value
pp_print_space
:
formatter
->
unit
->
unit
value
pp_force_newline
:
formatter
->
unit
->
unit
value
pp_print_flush
:
formatter
->
unit
->
unit
value
pp_print_newline
:
formatter
->
unit
->
unit
value
pp_print_if_newline
:
formatter
->
unit
->
unit


value
pp_open_tbox
:
formatter
->
unit
->
unit
value
pp_close_tbox
:
formatter
->
unit
->
unit
value
pp_print_tbreak
:
formatter
->
int
->
int
->
unit
value
pp_set_tab
:
formatter
->
unit
->
unit
value
pp_print_tab
:
formatter
->
unit
->
unit
value
pp_set_margin
:
formatter
->
int
->
unit
value
pp_get_margin
:
formatter
->
unit
->
int
value
pp_set_max_indent
:
formatter
->
int
->
unit
value
pp_get_max_indent
:
formatter
->
unit
->
int
value
pp_set_max_boxes
:
formatter
->
int
->
unit
value
pp_get_max_boxes
:
formatter
->
unit
->
int
value
pp_over_max_boxes
:
formatter
->
unit
->
bool
value
pp_set_ellipsis_text
:
formatter
->
string
->
unit
value
pp_get_ellipsis_text
:
formatter
->
unit
->
string
value
pp_set_formatter_out_channe
l
:
formatter
->
out_channel
->
unit
value
pp_set_formatter_output_fun
ctions
:
formatter
->
(string
->
int
->
int
->
unit)
->
(unit
->
unit)
->
unit
value
pp_get_formatter_output_fun
ctions
:
formatter
->
unit
->
(string
->
int
->
int
->
unit)
*
(unit
->
unit)
The
basic
functions
to
use
with
formatters.
These
functions
are
the
basic
ones:
usual
functions
op
erating
on
the
standard
formatter
are
dened
via
partial
ev
aluation
of
these
primitiv
es.
F
or
instance,
print_string
is
equal
to
pp_print_string
std_formatter.
value
fprintf
:
formatter
->
('a,
formatter,
unit)
format
->
'a
fprintf
ff
format
arg
...
argN
formats
the
argumen
ts
arg
to
argN
according
to
the
format
string
format,
and
outputs
the
resulting
string
on
the
formatter
ff.
The
format
is
a
c
haracter
string
whic
h
con
tains
three
t
yp
es
of
ob
jects:
plain
c
haracters
and
con
v
ersion
sp
ecications
as
sp
ecied
in
the
printf
mo
dule,
and
prett
y-prin
ting
indications.
The
prett
y-prin
ting
indication
c
haracters
are
in
tro
duced
b
y
a
@
c
haracter,
and
their
meanings
are:
[:
op
en
a
prett
y-prin
ting
b
o
x.
The
t
yp
e
and
oset
of
the
b
o
x
ma
y
b
e
optionally
sp
ecied
with
the
follo
wing
syn
tax:
the
<
c
haracter,
follo
w
ed
b
y
an
optional
b
o
x
t
yp
e
indication,
then
an
optional
in
teger
oset,
and
the
closing
>
c
haracter.
Bo
x
t
yp
e
is
one
of
h,
v,
hv,
or
hov,
whic
h
stand
resp
ectiv
ely
for
an
horizon
tal,
v
ertical,
\horizon
tal-v
ertical"
and
\horizon
tal
or
v
ertical"
b
o
x.
]:
close
the
most
recen
tly
op
ened
prett
y-prin
ting
b
o
x.
,:
output
a
go
o
d
break
as
with
print_cut
().
:
output
a
space,
as
with
print_space
().
\n:
force
a
newline,
as
with
force_newline
().
;:
output
a
go
o
d
break
as
with
print_break.
The
nspaces
and
offset
parameters
of
the
break
ma
y
b
e
optionally
sp
ecied
with
the
follo
wing
syn
tax:
the
<
c
haracter,
follo
w
ed
b
y
an
in
teger
nspaces
v
alue,
then
an
in
teger
oset,
and
a
closing
>
c
haracter.
.:
ush
the
prett
y
prin
ter
as
with
print_newline
().
@:
a
plain
@
c
haracter.

Chapter
.
The
standard
library

value
printf
:
('a,
formatter,
unit)
format
->
'a
Same
as
fprintf,
but
output
on
std_formatter.
value
eprintf:
('a,
formatter,
unit)
format
->
'a
Same
as
fprintf,
but
output
on
err_formatter.
.
gc:
memory
managemen
t
con
trol
and
statistics
type
stat
=
{
minor_words
:
int;
promoted_words
:
int;
major_words
:
int;
minor_collections
:
int;
major_collections
:
int;
heap_words
:
int;
heap_chunks
:
int;
live_words
:
int;
live_blocks
:
int;
free_words
:
int;
free_blocks
:
int;
largest_words
:
int;
fragments
:
int
}
The
memory
managemen
t
coun
ters
are
returned
in
a
stat
record.
All
the
n
um
b
ers
are
computed
since
the
start
of
the
program.
The
elds
of
this
record
are:
minor_words
Num
b
er
of
w
ords
allo
cated
in
the
minor
heap.
promoted_words
Num
b
er
of
w
ords
allo
cated
in
the
minor
heap
that
surviv
ed
a
minor
collection
and
w
ere
mo
v
ed
to
the
ma
jor
heap.
major_words
Num
b
er
of
w
ords
allo
cated
in
the
ma
jor
heap,
including
the
promoted
w
ords.
minor_collections
Num
b
er
of
minor
collections.
major_collections
Num
b
er
of
ma
jor
collection
cycles,
not
coun
ting
the
curren
t
cycle.
heap_words
T
otal
size
of
the
ma
jor
heap,
in
w
ords.
heap_chunks
Num
b
er
of
times
the
ma
jor
heap
size
w
as
increased.
live_words
Num
b
er
of
w
ords
of
liv
e
data
in
the
ma
jor
heap,
including
the
header
w
ords.
live_blocks
Num
b
er
of
liv
e
ob
jects
in
the
ma
jor
heap.
free_words
Num
b
er
of
w
ords
in
the
free
list.
free_blocks
Num
b
er
of
ob
jects
in
the
free
list.
largest_words
Size
(in
w
ords)
of
the
largest
ob
ject
in
the
free
list.
fragments
Num
b
er
of
w
asted
w
ords
due
to
fragmen
tation.
These
are
-w
ords
free
blo
c
ks
placed
b
et
w
een
t
w
o
liv
e
ob
jects.
They
cannot
b
e
inserted
in
the
free
list,
th
us
they
are
not
a
v
ailable
for
allo
cation.


The
total
amoun
t
of
memory
allo
cated
b
y
the
program
is
(in
w
ords)
minor_words
+
major_words
-
promoted_words.
Multiply
b
y
the
w
ord
size
(
on
a
-bit
mac
hine,

on
a
-bit
mac
hine)
to
get
the
n
um
b
er
of
b
ytes.
type
control
=
{
mutable
minor_heap_size
:
int;
mutable
major_heap_increment
:
int;
mutable
space_overhead
:
int;
mutable
verbose
:
bool
}
The
GC
parameters
are
giv
en
as
a
control
record.
The
elds
are:
minor_heap_size
The
size
(in
w
ords)
of
the
minor
heap.
Changing
this
parameter
will
trigger
a
minor
collection.
major_heap_increment
The
minim
um
n
um
b
er
of
w
ords
to
add
to
the
ma
jor
heap
when
increasing
it.
space_overhead
The
ma
jor
GC
sp
eed
is
computed
from
this
parameter.
This
is
the
p
ercen
tage
of
heap
space
that
will
b
e
"w
asted"
b
ecause
the
GC
do
es
not
immediatly
collect
unreac
hable
ob
jects.
The
GC
will
w
ork
more
(use
more
CPU
time
and
collect
ob
jects
more
eagerly)
if
space_overhead
is
smaller.
The
computation
of
the
GC
sp
eed
assumes
that
the
amoun
t
of
liv
e
data
is
constan
t.
verbose
This
ag
con
trols
the
GC
messages
on
standard
error
output.
value
stat
:
unit
->
stat
Return
the
curren
t
v
alues
of
the
memory
managemen
t
coun
ters
in
a
stat
record.
value
print_stat
:
io__out_channel
->
unit
Prin
t
the
curren
t
v
alues
of
the
memory
managemen
t
coun
ters
(in
h
uman-readable
form)
in
to
the
c
hannel
argumen
t.
value
get
:
unit
->
control
Return
the
curren
t
v
alues
of
the
GC
parameters
in
a
control
record.
value
set
:
control
->
unit
set
r
c
hanges
the
GC
parameters
according
to
the
control
record
r.
The
normal
usage
is:
let
r
=
gc__get
()
in
(*
Get
the
current
parameters.
*)
r.verbose
<-
true;
(*
Change
some
of
them.
*)
gc__set
r
(*
Set
the
new
values.
*)
value
minor
:
unit
->
unit
T
rigger
a
minor
collection.

Chapter
.
The
standard
library
	
value
major
:
unit
->
unit
Finish
the
curren
t
ma
jor
collection
cycle.
value
full_major
:
unit
->
unit
Finish
the
curren
t
ma
jor
collection
cycle
and
p
erform
a
complete
new
cycle.
This
will
collect
all
curren
tly
unreac
hable
ob
jects.
.
genlex:
a
generic
lexical
analyzer
This
mo
dule
implemen
ts
a
simple
\standard"
lexical
analyzer,
presen
ted
as
a
function
from
c
haracter
streams
to
tok
en
streams.
It
implemen
ts
roughly
the
lexical
con
v
en
tions
of
Caml,
but
is
parameterized
b
y
the
set
of
k
eyw
ords
of
y
our
language.
type
token
=
Kwd
of
string
|
Ident
of
string
|
Int
of
int
|
Float
of
float
|
String
of
string
|
Char
of
char
The
t
yp
e
of
tok
ens.
The
lexical
classes
are:
Int
and
Float
for
in
teger
and
oating-p
oin
t
n
um
b
ers;
String
for
string
literals,
enclosed
in
double
quotes;
Char
for
c
haracter
literals,
enclosed
in
bac
kquotes;
Ident
for
iden
tiers
(either
sequences
of
letters,
digits,
underscores
and
quotes,
or
sequences
of
\op
erator
c
haracters"
suc
h
as
+,
*,
etc);
and
Kwd
for
k
eyw
ords
(either
iden
tiers
or
single
\sp
ecial
c
haracters"
suc
h
as
(,
},
etc).
value
make_lexer:
string
list
->
(char
stream
->
token
stream)
Construct
the
lexer
function.
The
rst
argumen
t
is
the
list
of
k
eyw
ords.
An
iden
tier
s
is
returned
as
Kwd
s
if
s
b
elongs
to
this
list,
and
as
Ident
s
otherwise.
A
sp
ecial
c
haracter
s
is
returned
as
Kwd
s
if
s
b
elongs
to
this
list,
and
cause
a
lexical
error
(exception
Parse_error)
otherwise.
Blanks
and
newlines
are
skipp
ed.
Commen
ts
delimited
b
y
(*
and
*)
are
skipp
ed
as
w
ell,
and
can
b
e
nested.
Example:
a
lexer
suitable
for
a
desk
calculator
is
obtained
b
y
let
lexer
=
make_lexer
["+";"-";"*";"/";"let";"="
;
"(";
")"]
The
asso
ciated
parser
w
ould
b
e
a
function
from
token
stream
to,
for
instance,
int,
and
w
ould
ha
v
e
rules
suc
h
as:

0
let
parse_expr
=
function
[<
'Int
n
>]
->
n
|
[<
'Kwd
"(";
parse_expr
n;
'Kwd
")"
>]
->
n
|
[<
parse_expr
n;
(parse_remainder
n)
n
>]
->
n
and
parse_remainder
n
=
function
[<
'Kwd
"+";
parse_expr
n
>]
->
n+n
|
...
.
hashtbl:
hash
tables
and
hash
functions
Hash
tables
are
hashed
asso
ciation
tables,
with
in-place
mo
dication.
type
('a,
'b)
t
The
t
yp
e
of
hash
tables
from
t
yp
e
'a
to
t
yp
e
'b.
value
new
:
int
->
('a,'b)
t
new
n
creates
a
new,
empt
y
hash
table,
with
initial
size
n.
The
table
gro
ws
as
needed,
so
n
is
just
an
initial
guess.
Better
results
are
said
to
b
e
ac
hiev
ed
when
n
is
a
prime
n
um
b
er.
Raise
Invalid_argument
"hashtbl__new"
if
n
is
less
than
.
value
clear
:
('a,
'b)
t
->
unit
Empt
y
a
hash
table.
value
add
:
('a,
'b)
t
->
'a
->
'b
->
unit
add
tbl
x
y
adds
a
binding
of
x
to
y
in
table
tbl.
Previous
bindings
for
x
are
not
remo
v
ed,
but
simply
hidden.
That
is,
after
p
erforming
remove
tbl
x,
the
previous
binding
for
x,
if
an
y
,
is
restored.
(This
is
the
seman
tics
of
asso
ciation
lists.)
value
find
:
('a,
'b)
t
->
'a
->
'b
find
tbl
x
returns
the
curren
t
binding
of
x
in
tbl,
or
raises
Not_found
if
no
suc
h
binding
exists.
value
find_all
:
('a,
'b)
t
->
'a
->
'b
list
find_all
tbl
x
returns
the
list
of
all
data
asso
ciated
with
x
in
tbl.
The
curren
t
binding
is
returned
rst,
then
the
previous
bindings,
in
rev
erse
order
of
in
tro
duction
in
the
table.
value
remove
:
('a,
'b)
t
->
'a
->
unit
remove
tbl
x
remo
v
es
the
curren
t
binding
of
x
in
tbl,
restoring
the
previous
binding
if
it
exists.
It
do
es
nothing
if
x
is
not
b
ound
in
tbl.

Chapter
.
The
standard
library

value
do_table
:
('a
->
'b
->
unit)
->
('a,
'b)
t
->
unit
do_table
f
tbl
applies
f
to
all
bindings
in
table
tbl,
discarding
all
the
results.
f
receiv
es
the
k
ey
as
rst
argumen
t,
and
the
asso
ciated
v
alue
as
second
argumen
t.
Eac
h
binding
is
presen
ted
exactly
once
to
f.
The
order
in
whic
h
the
bindings
are
passed
to
f
is
unpredictable,
except
that
successiv
e
bindings
for
the
same
k
ey
are
presen
ted
in
rev
erse
c
hronological
order
(most
recen
t
rst).
value
do_table_rev
:
('a
->
'b
->
unit)
->
('a,
'b)
t
->
unit
Same
as
do_table,
except
that
successiv
e
bindings
for
the
same
k
ey
are
presen
ted
in
c
hronological
order
(oldest
rst).
The
p
olymorphic
hash
primitiv
e
value
hash
:
'a
->
int
hash
x
asso
ciates
a
p
ositiv
e
in
teger
to
an
y
v
alue
of
an
y
t
yp
e.
It
is
guaran
teed
that
if
x
=
y,
then
hash
x
=
hash
y.
Moreo
v
er,
hash
alw
a
ys
terminates,
ev
en
on
cyclic
structures.
value
hash_param
:
int
->
int
->
'a
->
int
hash_param
n
m
x
computes
a
hash
v
alue
for
x,
with
the
same
prop
erties
as
for
hash.
The
t
w
o
extra
parameters
n
and
m
giv
e
more
precise
con
trol
o
v
er
hashing.
Hashing
p
erforms
a
depth-rst,
righ
t-to-left
tra
v
ersal
of
the
structure
x,
stopping
after
n
meaningful
no
des
w
ere
encoun
tered,
or
m
no
des,
meaningful
or
not,
w
ere
encoun
tered.
Meaningful
no
des
are:
in
tegers;
oating-p
oin
t
n
um
b
ers;
strings;
c
haracters;
b
o
oleans;
and
constan
t
constructors.
Larger
v
alues
of
m
and
n
means
that
more
no
des
are
tak
en
in
to
accoun
t
to
compute
the
nal
hash
v
alue,
and
therefore
collisions
are
less
lik
ely
to
happ
en.
Ho
w
ev
er,
hashing
tak
es
longer.
The
parameters
m
and
n
go
v
ern
the
tradeo
b
et
w
een
accuracy
and
sp
eed.
.
lexing:
the
run-time
library
for
lexers
generated
b
y
camllex
Lexer
buers
type
lexbuf
=
{
refill_buff
:
lexbuf
->
unit;
lex_buffer
:
string;
mutable
lex_abs_pos
:
int;
mutable
lex_start_pos
:
int;
mutable
lex_curr_pos
:
int;
mutable
lex_last_pos
:
int;
mutable
lex_last_action
:
lexbuf
->
obj
}
The
t
yp
e
of
lexer
buers.
A
lexer
buer
is
the
argumen
t
passed
to
the
scanning
functions
dened
b
y
the
generated
scanners.
The
lexer
buer
holds
the
curren
t
state
of
the
scanner,
plus
a
function
to
rell
the
buer
from
the
input.


value
create_lexer_channel
:
in_channel
->
lexbuf
Create
a
lexer
buer
on
the
giv
en
input
c
hannel.
create_lexer_channel
inchan
returns
a
lexer
buer
whic
h
reads
from
the
input
c
hannel
inchan,
at
the
curren
t
reading
p
osition.
value
create_lexer_string
:
string
->
lexbuf
Create
a
lexer
buer
whic
h
reads
from
the
giv
en
string.
Reading
starts
from
the
rst
c
haracter
in
the
string.
An
end-of-input
condition
is
generated
when
the
end
of
the
string
is
reac
hed.
value
create_lexer
:
(string
->
int
->
int)
->
lexbuf
Create
a
lexer
buer
with
the
giv
en
function
as
its
reading
metho
d.
When
the
scanner
needs
more
c
haracters,
it
will
call
the
giv
en
function,
giving
it
a
c
haracter
string
s
and
a
c
haracter
coun
t
n.
The
function
should
put
n
c
haracters
or
less
in
s,
starting
at
c
haracter
n
um
b
er
0,
and
return
the
n
um
b
er
of
c
haracters
pro
vided.
A
return
v
alue
of
0
means
end
of
input.
F
unctions
for
lexer
seman
tic
actions
The
follo
wing
functions
can
b
e
called
from
the
seman
tic
actions
of
lexer
denitions
(the
ML
co
de
enclosed
in
braces
that
computes
the
v
alue
returned
b
y
lexing
functions).
They
giv
e
access
to
the
c
haracter
string
matc
hed
b
y
the
regular
expression
asso
ciated
with
the
seman
tic
action.
These
functions
m
ust
b
e
applied
to
the
argumen
t
lexbuf,
whic
h,
in
the
co
de
generated
b
y
camllex,
is
b
ound
to
the
lexer
buer
passed
to
the
parsing
function.
value
get_lexeme
:
lexbuf
->
string
get_lexeme
lexbuf
returns
the
string
matc
hed
b
y
the
regular
expression.
value
get_lexeme_char
:
lexbuf
->
int
->
char
get_lexeme_char
lexbuf
i
returns
c
haracter
n
um
b
er
i
in
the
matc
hed
string.
value
get_lexeme_start
:
lexbuf
->
int
get_lexeme_start
lexbuf
returns
the
p
osition
in
the
input
stream
of
the
rst
c
haracter
of
the
matc
hed
string.
The
rst
c
haracter
of
the
stream
has
p
osition
0.
value
get_lexeme_end
:
lexbuf
->
int
get_lexeme_end
lexbuf
returns
the
p
osition
in
the
input
stream
of
the
c
haracter
follo
wing
the
last
c
haracter
of
the
matc
hed
string.
The
rst
c
haracter
of
the
stream
has
p
osition
0.

Chapter
.
The
standard
library

.	
map:
asso
ciation
tables
o
v
er
ordered
t
yp
es
This
mo
dule
implemen
ts
applicativ
e
asso
ciation
tables,
also
kno
wn
as
nite
maps
or
dictionaries,
giv
en
a
total
ordering
function
o
v
er
the
k
eys.
All
op
erations
o
v
er
maps
are
purely
applicativ
e
(no
side-eects).
The
implemen
tation
uses
balanced
binary
trees,
and
therefore
searc
hing
and
insertion
tak
e
time
logarithmic
in
the
size
of
the
map.
type
('a,
'b)
t
The
t
yp
e
of
maps
from
t
yp
e
'a
to
t
yp
e
'b.
value
empty:
('a
->
'a
->
int)
->
('a,
'b)
t
The
empt
y
map.
The
argumen
t
is
a
total
ordering
function
o
v
er
the
set
elemen
ts.
This
is
a
t
w
o-argumen
t
function
f
suc
h
that
f
e
e
is
zero
if
the
elemen
ts
e
and
e
are
equal,
f
e
e
is
strictly
negativ
e
if
e
is
smaller
than
e,
and
f
e
e
is
strictly
p
ositiv
e
if
e
is
greater
than
e.
Examples:
a
suitable
ordering
function
for
t
yp
e
int
is
prefix
-.
Y
ou
can
also
use
the
generic
structural
comparison
function
eq__compare.
value
add:
'a
->
'b
->
('a,
'b)
t
->
('a,
'b)
t
add
x
y
m
returns
a
map
con
taining
the
same
bindings
as
m,
plus
a
binding
of
x
to
y.
Previous
bindings
for
x
in
m
are
not
remo
v
ed,
but
simply
hidden:
they
reapp
ear
after
p
erforming
a
remove
op
eration.
(This
is
the
seman
tics
of
asso
ciation
lists.)
value
find:'a
->
('a,
'b)
t
->
'b
find
x
m
returns
the
curren
t
binding
of
x
in
m,
or
raises
Not_found
if
no
suc
h
binding
exists.
value
remove:
'a
->
('a,
'b)
t
->
('a,
'b)
t
remove
x
m
returns
a
map
con
taining
the
same
bindings
as
m
except
the
curren
t
binding
for
x.
The
previous
binding
for
x
is
restored
if
it
exists.
m
is
returned
unc
hanged
if
x
is
not
b
ound
in
m.
value
iter:
('a
->
'b
->
unit)
->
('a,
'b)
t
->
unit
iter
f
m
applies
f
to
all
bindings
in
map
m,
discarding
the
results.
f
receiv
es
the
k
ey
as
rst
argumen
t,
and
the
asso
ciated
v
alue
as
second
argumen
t.
The
order
in
whic
h
the
bindings
are
passed
to
f
is
unsp
ecied.
Only
curren
t
bindings
are
presen
ted
to
f:
bindings
hidden
b
y
more
recen
t
bindings
are
not
passed
to
f.
.0
parsing:
the
run-time
library
for
parsers
generated
b
y
camly
acc
value
symbol_start
:
unit
->
int
value
symbol_end
:
unit
->
int
symbol_start
and
symbol_end
are
to
b
e
called
in
the
action
part
of
a
grammar
rule
only
.
They
return
the
p
osition
of
the
string
that
matc
hes
the
left-hand
side
of
the
rule:
symbol_start()
returns
the
p
osition
of
the
rst
c
haracter;
symbol_end()
returns
the
p
osition
of
the
last
c
haracter,
plus
one.
The
rst
c
haracter
in
a
le
is
at
p
osition
0.


value
rhs_start:
int
->
int
value
rhs_end:
int
->
int
Same
as
symbol_start
and
symbol_end
ab
o
v
e,
but
return
the
p
osition
of
the
string
matc
hing
the
nth
item
on
the
righ
t-hand
side
of
the
rule,
where
n
is
the
in
teger
parameter
to
lhs_start
and
lhs_end.
n
is

for
the
leftmost
item.
value
clear_parser
:
unit
->
unit
Empt
y
the
parser
stac
k.
Call
it
just
after
a
parsing
function
has
returned,
to
remo
v
e
all
p
oin
ters
from
the
parser
stac
k
to
structures
that
w
ere
built
b
y
seman
tic
actions
during
parsing.
This
is
optional,
but
lo
w
ers
the
memory
requiremen
ts
of
the
programs.
exception
Parse_error
Raised
when
a
parser
encoun
ters
a
syn
tax
error.
.
printexc:
a
catc
h-all
exception
handler
value
f:
('a
->
'b)
->
'a
->
'b
printexc__f
fn
x
applies
fn
to
x
and
returns
the
result.
If
the
ev
aluation
of
fn
x
raises
an
y
exception,
the
name
of
the
exception
is
prin
ted
on
standard
error
output,
and
the
programs
ab
orts
with
exit
co
de
.
T
ypical
use
is
printexc__f
main
(),
where
main,
with
t
yp
e
unit->unit,
is
the
en
try
p
oin
t
of
a
standalone
program,
to
catc
h
and
prin
t
stra
y
exceptions.
F
or
printexc__f
to
w
ork
prop
erly
,
the
program
m
ust
ha
v
e
b
een
link
ed
with
the
-g
option.
.
printf:
formatting
prin
ting
functions
type
('a,
'b,
'c)
format
The
t
yp
e
of
format
strings.
'a
is
the
t
yp
e
of
the
parameters
of
the
string,
'c
is
the
result
t
yp
e
for
the
printf-st
yle
function,
and
'b
is
the
t
yp
e
of
the
rst
argumen
t
giv
en
to
%a
and
%t
prin
ting
functions.
value
fprintf:
out_channel
->
('a,
out_channel,
unit)
format
->
'a
fprintf
outchan
format
arg
...
argN
formats
the
argumen
ts
arg
to
argN
according
to
the
format
string
format,
and
outputs
the
resulting
string
on
the
c
hannel
outchan.
The
format
is
a
c
haracter
string
whic
h
con
tains
t
w
o
t
yp
es
of
ob
jects:
plain
c
haracters,
whic
h
are
simply
copied
to
the
output
c
hannel,
and
con
v
ersion
sp
ecications,
eac
h
of
whic
h
causes
con
v
ersion
and
prin
ting
of
one
argumen
t.
Con
v
ersion
sp
ecications
consist
in
the
%
c
haracter,
follo
w
ed
b
y
optional
ags
and
eld
widths,
follo
w
ed
b
y
one
con
v
ersion
c
haracter.
The
con
v
ersion
c
haracters
and
their
meanings
are:
d
or
i:
con
v
ert
an
in
teger
argumen
t
to
signed
decimal

Chapter
.
The
standard
library

u:
con
v
ert
an
in
teger
argumen
t
to
unsigned
decimal
x:
con
v
ert
an
in
teger
argumen
t
to
unsigned
hexadecimal,
using
lo
w
ercase
letters.
X:
con
v
ert
an
in
teger
argumen
t
to
unsigned
hexadecimal,
using
upp
ercase
letters.
s:
insert
a
string
argumen
t
c:
insert
a
c
haracter
argumen
t
f:
con
v
ert
a
oating-p
oin
t
argumen
t
to
decimal
notation,
in
the
st
yle
dddd.ddd
e
or
E:
con
v
ert
a
oating-p
oin
t
argumen
t
to
decimal
notation,
in
the
st
yle
d.ddd
e+-dd
(man
tissa
and
exp
onen
t)
g
or
G:
con
v
ert
a
oating-p
oin
t
argumen
t
to
decimal
notation,
in
st
yle
f
or
e,
E
(whic
hev
er
is
more
compact)
b:
con
v
ert
a
b
o
olean
argumen
t
to
the
string
true
or
false
a:
user-dened
prin
ter.
T
ak
es
t
w
o
argumen
ts
and
apply
the
rst
one
to
outchan
(the
curren
t
output
c
hannel)
and
to
the
second
argumen
t.
The
rst
argumen
t
m
ust
therefore
ha
v
e
t
yp
e
out_channel
->
'b
->
unit
and
the
second
'b.
The
output
pro
duced
b
y
the
function
is
therefore
inserted
in
the
output
of
fprintf
at
the
curren
t
p
oin
t.
t:
same
as
%a,
but
tak
es
only
one
argumen
t
(with
t
yp
e
out_channel
->
unit)
and
apply
it
to
outchan.
Refer
to
the
C
library
printf
function
for
the
meaning
of
ags
and
eld
width
sp
eciers.
If
to
o
few
argumen
ts
are
pro
vided,
prin
ting
stops
just
b
efore
con
v
erting
the
rst
missing
argumen
t.
value
printf:
('a,
out_channel,
unit)
format
->
'a
Same
as
fprintf,
but
output
on
std_out.
value
eprintf:
('a,
out_channel,
unit)
format
->
'a
Same
as
fprintf,
but
output
on
std_err.
value
sprintf:
('a,
unit,
string)
format
->
'a
Same
as
fprintf,
except
that
the
result
of
the
formatting
is
returned
as
a
string
instead
of
b
eing
written
on
a
c
hannel.
value
fprint:
out_channel
->
string
->
unit
Prin
t
the
giv
en
string
on
the
giv
en
output
c
hannel,
without
an
y
formatting.
This
is
the
same
function
as
output_string
of
mo
dule
io.
value
print:
string
->
unit
Prin
t
the
giv
en
string
on
std_out,
without
an
y
formatting.
This
is
the
same
function
as
print_string
of
mo
dule
io.
value
eprint:
string
->
unit
Prin
t
the
giv
en
string
on
std_err,
without
an
y
formatting.
This
is
the
same
function
as
prerr_string
of
mo
dule
io.


.
queue:
queues
This
mo
dule
implemen
ts
queues
(FIF
Os),
with
in-place
mo
dication.
type
'a
t
The
t
yp
e
of
queues
con
taining
elemen
ts
of
t
yp
e
'a.
exception
Empty
Raised
when
take
is
applied
to
an
empt
y
queue.
value
new:
unit
->
'a
t
Return
a
new
queue,
initially
empt
y
.
value
add:
'a
->
'a
t
->
unit
add
x
q
adds
the
elemen
t
x
at
the
end
of
the
queue
q.
value
take:
'a
t
->
'a
take
q
remo
v
es
and
returns
the
rst
elemen
t
in
queue
q,
or
raises
Empty
if
the
queue
is
empt
y
.
value
peek:
'a
t
->
'a
peek
q
returns
the
rst
elemen
t
in
queue
q,
without
remo
ving
it
from
the
queue,
or
raises
Empty
if
the
queue
is
empt
y
.
value
clear
:
'a
t
->
unit
Discard
all
elemen
ts
from
a
queue.
value
length:
'a
t
->
int
Return
the
n
um
b
er
of
elemen
ts
in
a
queue.
value
iter:
('a
->
unit)
->
'a
t
->
unit
iter
f
q
applies
f
in
turn
to
all
elemen
ts
of
q,
from
the
least
recen
tly
en
tered
to
the
most
recen
tly
en
tered.
The
queue
itself
is
unc
hanged.

Chapter
.
The
standard
library

.
random:
pseudo-random
n
um
b
er
generator
value
init
:
int
->
unit
Initialize
the
generator,
using
the
argumen
t
as
a
seed.
The
same
seed
will
alw
a
ys
yield
the
same
sequence
of
n
um
b
ers.
value
full_init
:
int
vect
->
unit
Same
as
init
but
tak
es
more
data
as
seed.
It
is
not
useful
to
giv
e
more
than

in
tegers.
value
int
:
int
->
int
random__int
bound
returns
a
random
n
um
b
er
b
et
w
een
0
(inclusiv
e)
and
bound
(exclusiv
e).
bound
m
ust
b
e
p
ositiv
e
and
smaller
than

0
.
value
float
:
float
->
float
random__float
bound
returns
a
random
n
um
b
er
b
et
w
een
0
(inclusiv
e)
and
bound
(exclusiv
e).
.
set:
sets
o
v
er
ordered
t
yp
es
This
mo
dule
implemen
ts
the
set
data
structure,
giv
en
a
total
ordering
function
o
v
er
the
set
elemen
ts.
All
op
erations
o
v
er
sets
are
purely
applicativ
e
(no
side-eects).
The
implemen
tation
uses
balanced
binary
trees,
and
is
therefore
reasonably
ecien
t:
insertion
and
mem
b
ership
tak
e
time
logarithmic
in
the
size
of
the
set,
for
instance.
type
'a
t
The
t
yp
e
of
sets
con
taining
elemen
ts
of
t
yp
e
'a.
value
empty:
('a
->
'a
->
int)
->
'a
t
The
empt
y
set.
The
argumen
t
is
a
total
ordering
function
o
v
er
the
set
elemen
ts.
This
is
a
t
w
o-argumen
t
function
f
suc
h
that
f
e
e
is
zero
if
the
elemen
ts
e
and
e
are
equal,
f
e
e
is
strictly
negativ
e
if
e
is
smaller
than
e,
and
f
e
e
is
strictly
p
ositiv
e
if
e
is
greater
than
e.
Examples:
a
suitable
ordering
function
for
t
yp
e
int
is
prefix
-.
Y
ou
can
also
use
the
generic
structural
comparison
function
eq__compare.
value
is_empty:
'a
t
->
bool
T
est
whether
a
set
is
empt
y
or
not.
value
mem:
'a
->
'a
t
->
bool
mem
x
s
tests
whether
x
b
elongs
to
the
set
s.


value
add:
'a
->
'a
t
->
'a
t
add
x
s
returns
a
set
con
taining
all
elemen
ts
of
s,
plus
x.
If
x
w
as
already
in
s,
s
is
returned
unc
hanged.
value
remove:
'a
->
'a
t
->
'a
t
remove
x
s
returns
a
set
con
taining
all
elemen
ts
of
s,
except
x.
If
x
w
as
not
in
s,
s
is
returned
unc
hanged.
value
union:
'a
t
->
'a
t
->
'a
t
value
inter:
'a
t
->
'a
t
->
'a
t
value
diff:
'a
t
->
'a
t
->
'a
t
Union,
in
tersection
and
set
dierence.
value
equal:
'a
t
->
'a
t
->
bool
equal
s
s
tests
whether
the
sets
s
and
s
are
equal,
that
is,
con
tain
the
same
elemen
ts.
value
compare:
'a
t
->
'a
t
->
int
T
otal
ordering
b
et
w
een
sets.
Can
b
e
used
as
the
ordering
function
for
doing
sets
of
sets.
value
elements:
'a
t
->
'a
list
Return
the
list
of
all
elemen
ts
of
the
giv
en
set.
The
elemen
ts
app
ear
in
the
list
in
some
non-sp
ecied
order.
value
iter:
('a
->
unit)
->
'a
t
->
unit
iter
f
s
applies
f
in
turn
to
all
elemen
ts
of
s,
and
discards
the
results.
The
elemen
ts
of
s
are
presen
ted
to
f
in
a
non-sp
ecied
order.
value
fold:
('a
->
'b
->
'b)
->
'a
t
->
'b
->
'b
fold
f
s
a
computes
(f
xN
...
(f
x
(f
x
a))...),
where
x
...
xN
are
the
elemen
ts
of
s.
The
order
in
whic
h
elemen
ts
of
s
are
presen
ted
to
f
is
not
sp
ecied.
value
choose:
'a
t
->
'a
Return
one
elemen
t
of
the
giv
en
set,
or
raise
Not_found
if
the
set
is
empt
y
.
Whic
h
elemen
t
is
c
hosen
is
not
sp
ecied,
but
equal
elemen
ts
will
b
e
c
hosen
for
equal
sets.
.
sort:
sorting
and
merging
lists
value
sort
:
('a
->
'a
->
bool)
->
'a
list
->
'a
list
Sort
a
list
in
increasing
order
according
to
an
ordering
predicate.
The
predicate
should
return
true
if
its
rst
argumen
t
is
less
than
or
equal
to
its
second
argumen
t.
value
merge
:
('a
->
'a
->
bool)
->
'a
list
->
'a
list
->
'a
list
Merge
t
w
o
lists
according
to
the
giv
en
predicate.
Assuming
the
t
w
o
argumen
t
lists
are
sorted
according
to
the
predicate,
merge
returns
a
sorted
list
con
taining
the
elemen
ts
from
the
t
w
o
lists.
The
b
eha
vior
is
undened
if
the
t
w
o
argumen
t
lists
w
ere
not
sorted.

Chapter
.
The
standard
library
	
.
stack:
stac
ks
This
mo
dule
implemen
ts
stac
ks
(LIF
Os),
with
in-place
mo
dication.
type
'a
t
The
t
yp
e
of
stac
ks
con
taining
elemen
ts
of
t
yp
e
'a.
exception
Empty
Raised
when
pop
is
applied
to
an
empt
y
stac
k.
value
new:
unit
->
'a
t
Return
a
new
stac
k,
initially
empt
y
.
value
push:
'a
->
'a
t
->
unit
push
x
s
adds
the
elemen
t
x
at
the
top
of
stac
k
s.
value
pop:
'a
t
->
'a
pop
s
remo
v
es
and
returns
the
topmost
elemen
t
in
stac
k
s,
or
raises
Empty
if
the
stac
k
is
empt
y
.
value
clear
:
'a
t
->
unit
Discard
all
elemen
ts
from
a
stac
k.
value
length:
'a
t
->
int
Return
the
n
um
b
er
of
elemen
ts
in
a
stac
k.
value
iter:
('a
->
unit)
->
'a
t
->
unit
iter
f
s
applies
f
in
turn
to
all
elemen
ts
of
s,
from
the
elemen
t
at
the
top
of
the
stac
k
to
the
elemen
t
at
the
b
ottom
of
the
stac
k.
The
stac
k
itself
is
unc
hanged.
.
sys:
system
in
terface
This
mo
dule
pro
vides
a
simple
in
terface
to
the
op
erating
system.
exception
Sys_error
of
string
Raised
b
y
some
functions
in
the
sys
and
io
mo
dules,
when
the
underlying
system
calls
fail.
The
argumen
t
to
Sys_error
is
a
string
describing
the
error.
The
texts
of
the
error
messages
are
implemen
tation-dep
enden
t,
and
should
not
b
e
relied
up
on
to
catc
h
sp
ecic
system
errors.

0
value
command_line
:
string
vect
The
command
line
argumen
ts
giv
en
to
the
pro
cess.
The
rst
elemen
t
is
the
command
name
used
to
in
v
ok
e
the
program.
value
interactive:
bool
T
rue
if
w
e're
running
under
the
toplev
el
system.
F
alse
if
w
e're
running
as
a
standalone
program.
type
file_perm
==
int
value
s_irusr
:
file_perm
value
s_iwusr
:
file_perm
value
s_ixusr
:
file_perm
value
s_irgrp
:
file_perm
value
s_iwgrp
:
file_perm
value
s_ixgrp
:
file_perm
value
s_iroth
:
file_perm
value
s_iwoth
:
file_perm
value
s_ixoth
:
file_perm
value
s_isuid
:
file_perm
value
s_isgid
:
file_perm
value
s_irall
:
file_perm
value
s_iwall
:
file_perm
value
s_ixall
:
file_perm
Access
p
ermissions
for
les.
r
is
reading
p
ermission,
w
is
writing
p
ermission,
x
is
execution
p
ermission.
usr
means
p
ermissions
for
the
user
o
wning
the
le,
grp
for
the
group
o
wning
the
le,
oth
for
others.
isuid
and
isgid
are
for
set-user-id
and
set-group-id
les,
resp
ectiv
ely
.
The
remaining
are
com
binations
of
the
p
ermissions
ab
o
v
e.
type
open_flag
=
O_RDONLY
(*
open
read-only
*)
|
O_WRONLY
(*
open
write-only
*)
|
O_RDWR
(*
open
for
reading
and
writing
*)
|
O_APPEND
(*
open
for
appending
*)
|
O_CREAT
(*
create
the
file
if
nonexistent
*)
|
O_TRUNC
(*
truncate
the
file
to
0
if
it
exists
*)
|
O_EXCL
(*
fails
if
the
file
exists
*)
|
O_BINARY
(*
open
in
binary
mode
*)
|
O_TEXT
(*
open
in
text
mode
*)
The
commands
for
open.
value
exit
:
int
->
'a
T
erminate
the
program
and
return
the
giv
en
status
co
de
to
the
op
erating
system.
In
con
trast
with
the
function
exit
from
mo
dule
io,
this
exit
function
do
es
not
ush
the
standard
output
and
standard
error
c
hannels.

Chapter
.
The
standard
library

value
open
:
string
->
open_flag
list
->
file_perm
->
int
Op
en
a
le.
The
second
argumen
t
is
the
op
ening
mo
de.
The
third
argumen
t
is
the
p
ermissions
to
use
if
the
le
m
ust
b
e
created.
The
result
is
a
le
descriptor
op
ened
on
the
le.
value
close
:
int
->
unit
Close
a
le
descriptor.
value
remove
:
string
->
unit
Remo
v
e
the
giv
en
le
name
from
the
le
system.
value
rename
:
string
->
string
->
unit
Rename
a
le.
The
rst
argumen
t
is
the
old
name
and
the
second
is
the
new
name.
value
getenv
:
string
->
string
Return
the
v
alue
asso
ciated
to
a
v
ariable
in
the
pro
cess
en
vironmen
t.
Raise
Not_found
if
the
v
ariable
is
un
b
ound.
value
chdir
:
string
->
unit
Change
the
curren
t
w
orking
directory
of
the
pro
cess.
Note
that
there
is
no
easy
w
a
y
of
getting
the
curren
t
w
orking
directory
from
the
op
erating
system.
value
system_command
:
string
->
int
Execute
the
giv
en
shell
command
and
return
its
exit
co
de.
value
time
:
unit
->
float
Return
the
pro
cessor
time,
in
seconds,
used
b
y
the
program
since
the
b
eginning
of
execution.
exception
Break
Exception
Break
is
raised
on
user
in
terrupt
if
catch_break
is
on.
value
catch_break
:
bool
->
unit
catch_break
go
v
erns
whether
user
in
terrupt
terminates
the
program
or
raises
the
Break
exception.
Call
catch_break
true
to
enable
raising
Break,
and
catch_break
false
to
let
the
system
terminate
the
program
on
user
in
terrupt.



Chapter

The
graphics
library
This
c
hapter
describ
es
the
p
ortable
graphics
primitiv
es
that
come
standard
in
the
implemen
tation
of
Caml
Ligh
t
on
micro-computers.
Unix:
On
Unix
w
orkstations
running
the
X
windo
ws
system,
an
implemen
tation
of
the
graphics
primitiv
es
is
a
v
ailable
in
the
directory
contrib/libgraph
in
the
distribution.
See
the
le
README
in
this
directory
for
information
on
building
and
using
camlgraph,
a
toplev
el
system
that
includes
the
graphics
primitiv
es,
and
linking
standalone
programs
with
the
library
.
Dra
wing
tak
es
place
in
a
separate
windo
w
that
is
created
when
open_graph
is
called.
Mac:
The
graphics
primitiv
e
are
a
v
ailable
from
the
standalone
application
that
runs
the
toplev
el
system.
They
are
not
a
v
ailable
from
programs
compiled
b
y
camlc
and
run
under
the
MPW
shell.
Dra
wing
tak
es
place
in
a
separate
windo
w,
that
can
b
e
made
visible
with
the
\Sho
w
graphics
windo
w"
men
u
en
try
.
PC:
The
graphics
primitiv
e
are
a
v
ailable
from
the
Windo
ws
application
that
runs
the
toplev
el
system.
They
are
not
a
v
ailable
from
programs
compiled
b
y
camlc
and
run
in
a
DOS
command
windo
w.
Dra
wing
tak
es
place
in
a
separate
windo
w.
The
screen
co
ordinates
are
in
terpreted
as
sho
wn
in
the
gure
b
elo
w.
Notice
that
the
co
ordinate
system
used
is
the
same
as
in
mathematics:
y
increases
from
the
b
ottom
of
the
screen
to
the
top
of
the
screen,
and
angles
are
measured
coun
terclo
c
kwise
(in
degrees).
Dra
wing
is
clipp
ed
to
the
screen.
-
x

y
Screen
size_x()
size_y()
pixel
at
(x;
y
)
x
y



Here
are
the
graphics
mo
de
sp
ecications
supp
orted
b
y
open_graph
on
the
v
arious
implemen
tations
of
this
library
.
Unix:
The
argumen
t
to
open_graph
has
the
format
"display-name
ge
ometry
",
where
display-name
is
the
name
of
the
X-windo
ws
displa
y
to
connect
to,
and
ge
ometry
is
a
standard
X-windo
ws
geometry
sp
ecication.
The
t
w
o
comp
onen
ts
are
separated
b
y
a
space.
Either
can
b
e
omitted,
or
b
oth.
Examples:
open_graph
"foo:0"
connects
to
the
displa
y
foo:0
and
creates
a
windo
w
with
the
default
geometry
open_graph
"foo:0
00x00+0-0"
connects
to
the
displa
y
foo:0
and
creates
a
windo
w
00
pixels
wide
b
y
00
pixels
tall,
at
lo
cation
(0;
0)
open_graph
"
00x00+0-0"
connects
to
the
default
displa
y
and
creates
a
windo
w
00
pixels
wide
b
y
00
pixels
tall,
at
lo
cation
(0;
0)
open_graph
""
connects
to
the
default
displa
y
and
creates
a
windo
w
with
the
default
geometry
.
Mac:
The
argumen
t
to
open_graph
is
ignored.
PC:
The
argumen
t
to
open_graph
has
the
format
"widthxheight"
or
"widthxheight+x+y",
where
width
and
height
are
the
initial
dimensions
of
the
graphics
windo
ws,
and
x
and
y
are
the
p
osition
of
the
upp
er-left
corner
of
the
graphics
windo
w.
If
omitted,
(width,height)
default
to
(00,00)
and
(x,y)
default
to
(0,
0).
.
graphics:
mac
hine-indep
e
nden
t
graphics
primitiv
es
exception
Graphic_failure
of
string
Raised
b
y
the
functions
b
elo
w
when
they
encoun
ter
an
error.
Initializations
value
open_graph:
string
->
unit
Sho
w
the
graphics
windo
w
or
switc
h
the
screen
to
graphic
mo
de.
The
graphics
windo
w
is
cleared.
The
string
argumen
t
is
used
to
pass
optional
information
on
the
desired
graphics
mo
de,
the
graphics
windo
w
size,
and
so
on.
Its
in
terpretation
is
implemen
tation-dep
endent.
If
the
empt
y
string
is
giv
en,
a
sensible
default
is
selected.
value
close_graph:
unit
->
unit
Delete
the
graphics
windo
w
or
switc
h
the
screen
bac
k
to
text
mo
de.

Chapter
.
The
graphics
library

value
clear_graph
:
unit
->
unit
Erase
the
graphics
windo
w.
value
size_x
:
unit
->
int
value
size_y
:
unit
->
int
Return
the
size
of
the
graphics
windo
w.
Co
ordinates
of
the
screen
pixels
range
o
v
er
0
..
size_x()-
and
0
..
size_y()-.
Dra
wings
outside
of
this
rectangle
are
clipp
ed,
without
causing
an
error.
The
origin
(0,0)
is
at
the
lo
w
er
left
corner.
Colors
type
color
==
int
A
color
is
sp
ecied
b
y
its
R,
G,
B
comp
onen
ts.
Eac
h
comp
onen
t
is
in
the
range
0...
The
three
comp
onen
ts
are
pac
k
ed
in
an
int:
0xRRGGBB,
where
RR
are
the
t
w
o
hexadecimal
digits
for
the
red
comp
onen
t,
GG
for
the
green
comp
onen
t,
BB
for
the
blue
comp
onen
t.
value
rgb:
int
->
int
->
int
->
color
rgb
r
g
b
returns
the
in
teger
enco
ding
the
color
with
red
comp
onen
t
r,
green
comp
onen
t
g,
and
blue
comp
onen
t
b.
r,
g
and
b
are
in
the
range
0...
value
set_color
:
color
->
unit
Set
the
curren
t
dra
wing
color.
value
black
:
color
value
white
:
color
value
red
:
color
value
green
:
color
value
blue
:
color
value
yellow
:
color
value
cyan
:
color
value
magenta
:
color
Some
predened
colors.
value
background:
color
value
foreground:
color
Default
bac
kground
and
foreground
colors
(usually
,
either
blac
k
foreground
on
a
white
bac
kground
or
white
foreground
on
a
blac
k
bac
kground).
clear_graph
lls
the
screen
with
the
background
color.
The
initial
dra
wing
color
is
foreground.


P
oin
t
and
line
dra
wing
value
plot
:
int
->
int
->
unit
Plot
the
giv
en
p
oin
t
with
the
curren
t
dra
wing
color.
value
point_color
:
int
->
int
->
color
Return
the
color
of
the
giv
en
p
oin
t.
value
moveto
:
int
->
int
->
unit
P
osition
the
curren
t
p
oin
t.
value
current_point
:
unit
->
int
*
int
Return
the
p
osition
of
the
curren
t
p
oin
t.
value
lineto
:
int
->
int
->
unit
Dra
w
a
line
with
endp
oin
ts
the
curren
t
p
oin
t
and
the
giv
en
p
oin
t,
and
mo
v
e
the
curren
t
p
oin
t
to
the
giv
en
p
oin
t.
value
draw_arc
:
int
->
int
->
int
->
int
->
int
->
int
->
unit
draw_arc
x
y
rx
ry
a
a
dra
ws
an
elliptical
arc
with
cen
ter
x,y,
horizon
tal
radius
rx,
v
ertical
radius
ry,
from
angle
a
to
angle
a
(in
degrees).
The
curren
t
p
oin
t
is
unc
hanged.
value
draw_ellipse
:
int
->
int
->
int
->
int
->
unit
draw_ellipse
x
y
rx
ry
dra
ws
an
ellipse
with
cen
ter
x,y,
horizon
tal
radius
rx
and
v
ertical
radius
ry.
The
curren
t
p
oin
t
is
unc
hanged.
value
draw_circle
:
int
->
int
->
int
->
unit
draw_circle
x
y
r
dra
ws
a
circle
with
cen
ter
x,y
and
radius
r.
The
curren
t
p
oin
t
is
unc
hanged.
value
set_line_width
:
int
->
unit
Set
the
width
of
p
oin
ts
and
lines
dra
wn
with
the
functions
ab
o
v
e.
Under
X
Windo
ws,
set_line_width
0
selects
a
width
of

pixel
and
a
faster,
but
less
precise
dra
wing
algorithm
than
the
one
used
when
set_line_width

is
sp
ecied.
T
ext
dra
wing
value
draw_char
:
char
->
unit
value
draw_string
:
string
->
unit
Dra
w
a
c
haracter
or
a
c
haracter
string
with
lo
w
er
left
corner
at
curren
t
p
osition.
After
dra
wing,
the
curren
t
p
osition
is
set
to
the
lo
w
er
righ
t
corner
of
the
text
dra
wn.
value
set_font
:
string
->
unit
value
set_text_size
:
int
->
unit
Set
the
fon
t
and
c
haracter
size
used
for
dra
wing
text.
The
in
terpretation
of
the
argumen
ts
to
set_font
and
set_text_size
is
implemen
tation-dep
enden
t.
value
text_size
:
string
->
int
*
int
Return
the
dimensions
of
the
giv
en
text,
if
it
w
ere
dra
wn
with
the
curren
t
fon
t
and
size.

Chapter
.
The
graphics
library

Filling
value
fill_rect
:
int
->
int
->
int
->
int
->
unit
fill_rect
x
y
w
h
lls
the
rectangle
with
lo
w
er
left
corner
at
x,y,
width
w
and
heigth
h,
with
the
curren
t
color.
value
fill_poly
:
(int
*
int)
vect
->
unit
Fill
the
giv
en
p
olygon
with
the
curren
t
color.
The
arra
y
con
tains
the
co
ordinates
of
the
v
ertices
of
the
p
olygon.
value
fill_arc
:
int
->
int
->
int
->
int
->
int
->
int
->
unit
Fill
an
elliptical
pie
slice
with
the
curren
t
color.
The
parameters
are
the
same
as
for
draw_arc.
value
fill_ellipse
:
int
->
int
->
int
->
int
->
unit
Fill
an
ellipse
with
the
curren
t
color.
The
parameters
are
the
same
as
for
draw_ellipse.
value
fill_circle
:
int
->
int
->
int
->
unit
Fill
a
circle
with
the
curren
t
color.
The
parameters
are
the
same
as
for
draw_circle.
Images
type
image
The
abstract
t
yp
e
for
images,
in
in
ternal
represen
tation.
Externally
,
images
are
represen
ted
as
matrices
of
colors.
value
transp
:
color
In
matrices
of
colors,
this
color
represen
t
a
\transparen
t"
p
oin
t:
when
dra
wing
the
corresp
onding
image,
all
pixels
on
the
screen
corresp
onding
to
a
transparen
t
pixel
in
the
image
will
not
b
e
mo
died,
while
other
p
oin
ts
will
b
e
set
to
the
color
of
the
corresp
onding
p
oin
t
in
the
image.
This
allo
ws
sup
erimp
osing
an
image
o
v
er
an
existing
bac
kground.
value
make_image
:
color
vect
vect
->
image
Con
v
ert
the
giv
en
color
matrix
to
an
image.
Eac
h
sub-arra
y
represen
ts
one
horizon
tal
line.
All
sub-arra
ys
m
ust
ha
v
e
the
same
length;
otherwise,
exception
Graphic_failure
is
raised.
value
dump_image
:
image
->
color
vect
vect
Con
v
ert
an
image
to
a
color
matrix.
value
draw_image
:
image
->
int
->
int
->
unit
Dra
w
the
giv
en
image
with
lo
w
er
left
corner
at
the
giv
en
p
oin
t.


value
get_image
:
int
->
int
->
int
->
int
->
image
Capture
the
con
ten
ts
of
a
rectangle
on
the
screen
as
an
image.
The
parameters
are
the
same
as
for
fill_rect.
value
create_image
:
int
->
int
->
image
create_image
w
h
returns
a
new
image
w
pixels
wide
and
h
pixels
tall,
to
b
e
used
in
conjunction
with
blit_image.
The
initial
image
con
ten
ts
are
random.
value
blit_image
:
image
->
int
->
int
->
unit
blit_image
img
x
y
copies
screen
pixels
in
to
the
image
img,
mo
difying
img
in-place.
The
pixels
copied
are
those
inside
the
rectangle
with
lo
w
er
left
corner
at
x,y,
and
width
and
heigh
t
equal
to
those
of
the
image.
Mouse
and
k
eyb
oard
ev
en
ts
type
status
=
{
mouse_x
:
int;
(*
X
coordinate
of
the
mouse
*)
mouse_y
:
int;
(*
Y
coordinate
of
the
mouse
*)
button
:
bool;
(*
true
if
a
mouse
button
is
pressed
*)
keypressed
:
bool;
(*
true
if
a
key
has
been
pressed
*)
key
:
char
}
(*
the
character
for
the
key
pressed
*)
T
o
rep
ort
ev
en
ts.
type
event
=
Button_down
(*
A
mouse
button
is
pressed
*)
|
Button_up
(*
A
mouse
button
is
released
*)
|
Key_pressed
(*
A
key
is
pressed
*)
|
Mouse_motion
(*
The
mouse
is
moved
*)
|
Poll
(*
Don't
wait;
return
immediately
*)
T
o
sp
ecify
ev
en
ts
to
w
ait
for.
value
wait_next_event
:
event
list
->
status
W
ait
un
til
one
of
the
ev
en
ts
sp
ecied
in
the
giv
en
ev
en
t
list
o
ccurs,
and
return
the
status
of
the
mouse
and
k
eyb
oard
at
that
time.
If
Poll
is
giv
en
in
the
ev
en
t
list,
return
immediately
with
the
curren
t
status.
If
the
mouse
cursor
is
outside
of
the
graphics
windo
w,
the
mouse_x
and
mouse_y
elds
of
the
ev
en
t
are
outside
the
range
0..size_x()-,
0..size_y()-.
Keypresses
are
queued,
and
dequeued
one
b
y
one
when
the
Key_pressed
ev
en
t
is
sp
ecied.

Chapter
.
The
graphics
library
	
Mouse
and
k
eyb
oard
p
olling
value
mouse_pos
:
unit
->
int
*
int
Return
the
p
osition
of
the
mouse
cursor,
relativ
e
to
the
graphics
windo
w.
If
the
mouse
cursor
is
outside
of
the
graphics
windo
w,
mouse_pos()
returns
a
p
oin
t
outside
of
the
range
0..size_x()-,
0..size_y()-.
value
button_down
:
unit
->
bool
Return
true
if
the
mouse
button
is
pressed,
false
otherwise.
value
read_key
:
unit
->
char
W
ait
for
a
k
ey
to
b
e
pressed,
and
return
the
corresp
onding
c
haracter.
Keypresses
are
queued.
value
key_pressed
:
unit
->
bool
Return
true
if
a
k
eypress
is
a
v
ailable;
that
is,
if
read_key
w
ould
not
blo
c
k.
Sound
value
sound
:
int
->
int
->
unit
sound
freq
dur
pla
ys
a
sound
at
frequency
freq
(in
hertz)
for
a
duration
dur
(in
milliseconds).
On
the
Macin
tosh,
the
frequency
is
rounded
to
the
nearest
note
in
the
equal-temp
ered
scale.

0

Chapter

The
unix
library:
Unix
system
calls
The
unix
library
(distributed
in
contrib/libunix)
mak
es
man
y
Unix
system
calls
and
system-
related
library
functions
a
v
ailable
to
Caml
Ligh
t
programs.
This
c
hapter
describ
es
briey
the
functions
pro
vided.
Refer
to
sections

and

of
the
Unix
man
ual
for
more
details
on
the
b
eha
vior
of
these
functions.
Not
all
functions
are
pro
vided
b
y
all
Unix
v
arian
ts.
If
some
functions
are
not
a
v
ailable,
they
will
raise
Invalid_arg
when
called.
Programs
that
use
the
unix
library
m
ust
b
e
link
ed
in
\custom
run
time"
mo
de,
as
follo
ws:
camlc
-custom
other
options
unix.zo
other
les
-lunix
F
or
in
teractiv
e
use
of
the
unix
library
,
run
camllight
camlunix.
Mac:
This
library
is
not
a
v
ailable.
PC:
This
library
is
not
a
v
ailable.
.
unix:
in
terface
to
the
Unix
system
Error
rep
ort
type
error
=
ENOERR
|
EPERM
(*
Not
owner
*)
|
ENOENT
(*
No
such
file
or
directory
*)
|
ESRCH
(*
No
such
process
*)
|
EINTR
(*
Interrupted
system
call
*)
|
EIO
(*
I/O
error
*)
|
ENXIO
(*
No
such
device
or
address
*)
|
EBIG
(*
Arg
list
too
long
*)
|
ENOEXEC
(*
Exec
format
error
*)
|
EBADF
(*
Bad
file
number
*)
|
ECHILD
(*
No
children
*)
|
EAGAIN
(*
No
more
processes
*)



|
ENOMEM
(*
Not
enough
core
*)
|
EACCES
(*
Permission
denied
*)
|
EFAULT
(*
Bad
address
*)
|
ENOTBLK
(*
Block
device
required
*)
|
EBUSY
(*
Mount
device
busy
*)
|
EEXIST
(*
File
exists
*)
|
EXDEV
(*
Cross-device
link
*)
|
ENODEV
(*
No
such
device
*)
|
ENOTDIR
(*
Not
a
directory*)
|
EISDIR
(*
Is
a
directory
*)
|
EINVAL
(*
Invalid
argument
*)
|
ENFILE
(*
File
table
overflow
*)
|
EMFILE
(*
Too
many
open
files
*)
|
ENOTTY
(*
Not
a
typewriter
*)
|
ETXTBSY
(*
Text
file
busy
*)
|
EFBIG
(*
File
too
large
*)
|
ENOSPC
(*
No
space
left
on
device
*)
|
ESPIPE
(*
Illegal
seek
*)
|
EROFS
(*
Read-only
file
system
*)
|
EMLINK
(*
Too
many
links
*)
|
EPIPE
(*
Broken
pipe
*)
|
EDOM
(*
Argument
too
large
*)
|
ERANGE
(*
Result
too
large
*)
|
EWOULDBLOCK
(*
Operation
would
block
*)
|
EINPROGRESS
(*
Operation
now
in
progress
*)
|
EALREADY
(*
Operation
already
in
progress
*)
|
ENOTSOCK
(*
Socket
operation
on
non-socket
*)
|
EDESTADDRREQ
(*
Destination
address
required
*)
|
EMSGSIZE
(*
Message
too
long
*)
|
EPROTOTYPE
(*
Protocol
wrong
type
for
socket
*)
|
ENOPROTOOPT
(*
Protocol
not
available
*)
|
EPROTONOSUPPORT
(*
Protocol
not
supported
*)
|
ESOCKTNOSUPPORT
(*
Socket
type
not
supported
*)
|
EOPNOTSUPP
(*
Operation
not
supported
on
socket
*)
|
EPFNOSUPPORT
(*
Protocol
family
not
supported
*)
|
EAFNOSUPPORT
(*
Address
family
not
supported
by
protocol
family
*)
|
EADDRINUSE
(*
Address
already
in
use
*)
|
EADDRNOTAVAIL
(*
Can't
assign
requested
address
*)
|
ENETDOWN
(*
Network
is
down
*)
|
ENETUNREACH
(*
Network
is
unreachable
*)
|
ENETRESET
(*
Network
dropped
connection
on
reset
*)
|
ECONNABORTED
(*
Software
caused
connection
abort
*)
|
ECONNRESET
(*
Connection
reset
by
peer
*)
|
ENOBUFS
(*
No
buffer
space
available
*)
|
EISCONN
(*
Socket
is
already
connected
*)

Chapter
.
The
unix
library:
Unix
system
calls

|
ENOTCONN
(*
Socket
is
not
connected
*)
|
ESHUTDOWN
(*
Can't
send
after
socket
shutdown
*)
|
ETOOMANYREFS
(*
Too
many
references:
can't
splice
*)
|
ETIMEDOUT
(*
Connection
timed
out
*)
|
ECONNREFUSED
(*
Connection
refused
*)
|
ELOOP
(*
Too
many
levels
of
symbolic
links
*)
|
ENAMETOOLONG
(*
File
name
too
long
*)
|
EHOSTDOWN
(*
Host
is
down
*)
|
EHOSTUNREACH
(*
No
route
to
host
*)
|
ENOTEMPTY
(*
Directory
not
empty
*)
|
EPROCLIM
(*
Too
many
processes
*)
|
EUSERS
(*
Too
many
users
*)
|
EDQUOT
(*
Disc
quota
exceeded
*)
|
ESTALE
(*
Stale
NFS
file
handle
*)
|
EREMOTE
(*
Too
many
levels
of
remote
in
path
*)
|
EIDRM
(*
Identifier
removed
*)
|
EDEADLK
(*
Deadlock
condition.
*)
|
ENOLCK
(*
No
record
locks
available.
*)
|
ENOSYS
(*
Function
not
implemented
*)
|
EUNKNOWNERR
The
t
yp
e
of
error
co
des.
exception
Unix_error
of
error
*
string
*
string
Raised
b
y
the
system
calls
b
elo
w
when
an
error
is
encoun
tered.
The
rst
comp
onen
t
is
the
error
co
de;
the
second
comp
onen
t
is
the
function
name;
the
third
comp
onen
t
is
the
string
parameter
to
the
function,
if
it
has
one,
or
the
empt
y
string
otherwise.
value
error_message
:
error
->
string
Return
a
string
describing
the
giv
en
error
co
de.
value
handle_unix_error
:
('a
->
'b)
->
'a
->
'b
handle_unix_error
f
x
applies
f
to
x
and
returns
the
result.
If
the
exception
Unix_error
is
raised,
it
prin
ts
a
message
describing
the
error
and
exits
with
co
de
.
In
terface
with
the
paren
t
pro
cess
value
environment
:
unit
->
string
vect
Return
the
pro
cess
en
vironmen
t,
as
an
arra
y
of
strings
with
the
format
\v
ariable=v
alue".
See
also
sys__getenv.


Pro
cess
handling
type
process_status
=
WEXITED
of
int
|
WSIGNALED
of
int
*
bool
|
WSTOPPED
of
int
The
termination
status
of
a
pro
cess.
WEXITED
means
that
the
pro
cess
terminated
normally
b
y
exit;
the
argumen
t
is
the
return
co
de.
WSIGNALED
means
that
the
pro
cess
w
as
killed
b
y
a
signal;
the
rst
argumen
t
is
the
signal
n
um
b
er,
the
second
argumen
t
indicates
whether
a
\core
dump"
w
as
p
erformed.
WSTOPPED
means
that
the
pro
cess
w
as
stopp
ed
b
y
a
signal;
the
argumen
t
is
the
signal
n
um
b
er.
type
wait_flag
=
WNOHANG
|
WUNTRACED
Flags
for
waitopt
and
waitpid.
WNOHANG
means
do
not
blo
c
k
if
no
c
hild
has
died
y
et,
but
immediately
return
with
a
pid
equal
to
0.
WUNTRACED
means
rep
ort
also
the
c
hildren
that
receiv
e
stop
signals.
value
execv
:
string
->
string
vect
->
unit
execv
prog
args
execute
the
program
in
le
prog,
with
the
argumen
ts
args,
and
the
curren
t
pro
cess
en
vironmen
t.
value
execve
:
string
->
string
vect
->
string
vect
->
unit
Same
as
execv,
except
that
the
third
argumen
t
pro
vides
the
en
vironmen
t
to
the
program
executed.
value
execvp
:
string
->
string
vect
->
unit
Same
as
execv,
except
that
the
program
is
searc
hed
in
the
path.
value
fork
:
unit
->
int
F
ork
a
new
pro
cess.
The
returned
in
teger
is
0
for
the
c
hild
pro
cess,
the
pid
of
the
c
hild
pro
cess
for
the
paren
t
pro
cess.
value
wait
:
unit
->
int
*
process_status
W
ait
un
til
one
of
the
c
hildren
pro
cesses
die,
and
return
its
pid
and
termination
status.
value
waitopt
:
wait_flag
list
->
int
*
process_status
Same
as
wait,
but
tak
es
a
list
of
options
to
a
v
oid
blo
c
king,
or
also
rep
ort
stopp
ed
c
hildren.
The
pid
returned
is
0
if
no
c
hild
has
c
hanged
status.
value
waitpid
:
wait_flag
list
->
int
->
int
*
process_status
Same
as
waitopt,
but
w
aits
for
the
pro
cess
whose
pid
is
giv
en.
Negativ
e
pid
argumen
ts
represen
t
pro
cess
groups.

Chapter
.
The
unix
library:
Unix
system
calls

value
system
:
string
->
process_status
Execute
the
giv
en
command,
w
ait
un
til
it
terminates,
and
return
its
termination
status.
The
string
is
in
terpreted
b
y
the
shell
/bin/sh
and
therefore
can
con
tain
redirections,
quotes,
v
ariables,
etc.
The
result
WEXITED

indicates
that
the
shell
couldn't
b
e
executed.
value
getpid
:
unit
->
int
Return
the
pid
of
the
pro
cess.
value
getppid
:
unit
->
int
Return
the
pid
of
the
paren
t
pro
cess.
value
nice
:
int
->
int
Change
the
pro
cess
priorit
y
.
The
in
teger
argumen
t
is
added
to
the
\nice"
v
alue.
(Higher
v
alues
of
the
\nice"
v
alue
mean
lo
w
er
priorities.)
Return
the
new
nice
v
alue.
Basic
le
input/output
type
file_descr
The
abstract
t
yp
e
of
le
descriptors.
value
stdin
:
file_descr
value
stdout
:
file_descr
value
stderr
:
file_descr
File
descriptors
for
standard
input,
standard
output
and
standard
error.
type
open_flag
=
O_RDONLY
(*
Open
for
reading
*)
|
O_WRONLY
(*
Open
for
writing
*)
|
O_RDWR
(*
Open
for
reading
and
writing
*)
|
O_NDELAY
(*
Open
in
non-blocking
mode
*)
|
O_APPEND
(*
Open
for
append
*)
|
O_CREAT
(*
Create
if
nonexistent
*)
|
O_TRUNC
(*
Truncate
to
0
length
if
existing
*)
|
O_EXCL
(*
Fail
if
existing
*)
The
ags
to
open.
type
file_perm
==
int
The
t
yp
e
of
le
access
righ
ts.
value
open
:
string
->
open_flag
list
->
file_perm
->
file_descr
Op
en
the
named
le
with
the
giv
en
ags.
Third
argumen
t
is
the
p
ermissions
to
giv
e
to
the
le
if
it
is
created.
Return
a
le
descriptor
on
the
named
le.


value
close
:
file_descr
->
unit
Close
a
le
descriptor.
value
read
:
file_descr
->
string
->
int
->
int
->
int
read
fd
buff
start
len
reads
len
c
haracters
from
descriptor
fd,
storing
them
in
string
buff,
starting
at
p
osition
ofs
in
string
buff.
Return
the
n
um
b
er
of
c
haracters
actually
read.
value
write
:
file_descr
->
string
->
int
->
int
->
int
write
fd
buff
start
len
writes
len
c
haracters
to
descriptor
fd,
taking
them
from
string
buff,
starting
at
p
osition
ofs
in
string
buff.
Return
the
n
um
b
er
of
c
haracters
actually
written.
In
terfacing
with
the
standard
input/output
library
(mo
dule
io).
value
in_channel_of_descr
:
file_descr
->
in_channel
Create
an
input
c
hannel
reading
from
the
giv
en
descriptor.
value
out_channel_of_descr
:
file_descr
->
out_channel
Create
an
output
c
hannel
writing
on
the
giv
en
descriptor.
value
descr_of_in_channel
:
in_channel
->
file_descr
Return
the
descriptor
corresp
onding
to
an
input
c
hannel.
value
descr_of_out_channel
:
out_channel
->
file_descr
Return
the
descriptor
corresp
onding
to
an
output
c
hannel.
Seeking
and
truncating
type
seek_command
=
SEEK_SET
|
SEEK_CUR
|
SEEK_END
P
ositioning
mo
des
for
lseek.
SEEK_SET
indicates
p
ositions
relativ
e
to
the
b
eginning
of
the
le,
SEEK_CUR
relativ
e
to
the
curren
t
p
osition,
SEEK_END
relativ
e
to
the
end
of
the
le.
value
lseek
:
file_descr
->
int
->
seek_command
->
int
Set
the
curren
t
p
osition
for
a
le
descriptor
value
truncate
:
string
->
int
->
unit
T
runcates
the
named
le
to
the
giv
en
size.
value
ftruncate
:
file_descr
->
int
->
unit
T
runcates
the
le
corresp
onding
to
the
giv
en
descriptor
to
the
giv
en
size.

Chapter
.
The
unix
library:
Unix
system
calls

File
statistics
type
file_kind
=
S_REG
(*
Regular
file
*)
|
S_DIR
(*
Directory
*)
|
S_CHR
(*
Character
device
*)
|
S_BLK
(*
Block
device
*)
|
S_LNK
(*
Symbolic
link
*)
|
S_FIFO
(*
Named
pipe
*)
|
S_SOCK
(*
Socket
*)
type
stats
=
{
st_dev
:
int;
(*
Device
number
*)
st_ino
:
int;
(*
Inode
number
*)
st_kind
:
file_kind;
(*
Kind
of
the
file
*)
st_perm
:
file_perm;
(*
Access
rights
*)
st_nlink
:
int;
(*
Number
of
links
*)
st_uid
:
int;
(*
User
id
of
the
owner
*)
st_gid
:
int;
(*
Group
id
of
the
owner
*)
st_rdev
:
int;
(*
Device
minor
number
*)
st_size
:
int;
(*
Size
in
bytes
*)
st_atime
:
int;
(*
Last
access
time
*)
st_mtime
:
int;
(*
Last
modification
time
*)
st_ctime
:
int
}
(*
Last
status
change
time
*)
The
informations
returned
b
y
the
stat
calls.
value
stat
:
string
->
stats
Return
the
information
for
the
named
le.
value
lstat
:
string
->
stats
Same
as
stat,
but
in
case
the
le
is
a
sym
b
olic
link,
return
the
information
for
the
link
itself.
value
fstat
:
file_descr
->
stats
Return
the
information
for
the
le
asso
ciated
with
the
giv
en
descriptor.
Op
erations
on
le
names
value
unlink
:
string
->
unit
Remo
v
es
the
named
le
value
rename
:
string
->
string
->
unit
rename
old
new
c
hanges
the
name
of
a
le
from
old
to
new.
value
link
:
string
->
string
->
unit
link
source
dest
creates
a
hard
link
named
dest
to
the
le
named
new.


File
p
ermissions
and
o
wnership
type
access_permission
=
R_OK
(*
Read
permission
*)
|
W_OK
(*
Write
permission
*)
|
X_OK
(*
Execution
permission
*)
|
F_OK
(*
File
exists
*)
Flags
for
the
access
call.
value
chmod
:
string
->
file_perm
->
unit
Change
the
p
ermissions
of
the
named
le.
value
fchmod
:
file_descr
->
file_perm
->
unit
Change
the
p
ermissions
of
an
op
ened
le.
value
chown
:
string
->
int
->
int
->
unit
Change
the
o
wner
uid
and
o
wner
gid
of
the
named
le.
value
fchown
:
file_descr
->
int
->
int
->
unit
Change
the
o
wner
uid
and
o
wner
gid
of
an
op
ened
le.
value
umask
:
int
->
int
Set
the
pro
cess
creation
mask,
and
return
the
previous
mask.
value
access
:
string
->
access_permission
list
->
unit
Chec
k
that
the
pro
cess
has
the
giv
en
p
ermissions
o
v
er
the
named
le.
Raise
Unix_error
otherwise.
File
descriptor
hac
king
value
fcntl_int
:
file_descr
->
int
->
int
->
int
In
terface
to
fcntl
in
the
case
where
the
argumen
t
is
an
in
teger.
The
rst
in
teger
argumen
t
is
the
command
co
de;
the
second
is
the
in
teger
parameter.
value
fcntl_ptr
:
file_descr
->
int
->
string
->
int
In
terface
to
fcntl
in
the
case
where
the
argumen
t
is
a
p
oin
ter.
The
in
teger
argumen
t
is
the
command
co
de.
A
p
oin
ter
to
the
string
argumen
t
is
passed
as
argumen
t
to
the
command.

Chapter
.
The
unix
library:
Unix
system
calls
	
Directories
value
mkdir
:
string
->
file_perm
->
unit
Create
a
directory
with
the
giv
en
p
ermissions.
value
rmdir
:
string
->
unit
Remo
v
e
an
empt
y
directory
.
value
chdir
:
string
->
unit
Change
the
pro
cess
w
orking
directory
.
value
getcwd
:
unit
->
string
Return
the
name
of
the
curren
t
w
orking
directory
.
type
dir_handle
The
t
yp
e
of
descriptors
o
v
er
op
ened
directories.
value
opendir
:
string
->
dir_handle
Op
en
a
descriptor
on
a
directory
value
readdir
:
dir_handle
->
string
Return
the
next
en
try
in
a
directory
.
Raise
End_of_file
when
the
end
of
the
directory
has
b
een
reac
hed.
value
rewinddir
:
dir_handle
->
unit
Rep
osition
the
descriptor
to
the
b
eginning
of
the
directory
value
closedir
:
dir_handle
->
unit
Close
a
directory
descriptor.
Pip
es
and
redirections
value
pipe
:
unit
->
file_descr
*
file_descr
Create
a
pip
e.
The
rst
comp
onen
t
of
the
result
is
op
ened
for
reading,
that's
the
exit
to
the
pip
e.
The
second
comp
onen
t
is
op
ened
for
writing,
that's
the
en
trace
to
the
pip
e.
value
dup
:
file_descr
->
file_descr
Duplicate
a
descriptor.
value
dup
:
file_descr
->
file_descr
->
unit
dup
fd
fd
duplicates
fd
to
fd,
closing
fd
if
already
op
ened.

0
value
open_process_in:
string
->
in_channel
value
open_process_out:
string
->
out_channel
value
open_process:
string
->
in_channel
*
out_channel
High-lev
el
pip
e
and
pro
cess
managemen
t.
These
functions
run
the
giv
en
command
in
parallel
with
the
program,
and
return
c
hannels
connected
to
the
standard
input
and/or
the
standard
output
of
the
command.
The
command
is
in
terpreted
b
y
the
shell
/bin/sh
(cf.
system).
W
arning:
writes
on
c
hannels
are
buered,
hence
b
e
careful
to
call
flush
at
the
righ
t
times
to
ensure
correct
sync
hronization.
value
close_process_in:
in_channel
->
process_status
value
close_process_out:
out_channel
->
process_status
value
close_process:
in_channel
*
out_channel
->
process_status
Close
c
hannels
op
ened
b
y
open_process_in,
open_process_out
and
open_process,
resp
ectiv
ely
,
w
ait
for
the
asso
ciated
command
to
terminate,
and
return
its
termination
status.
Sym
b
olic
links
value
symlink
:
string
->
string
->
unit
symlink
source
dest
creates
the
le
dest
as
a
sym
b
olic
link
to
the
le
source.
value
readlink
:
string
->
string
Read
the
con
ten
ts
of
a
link.
Named
pip
es
value
mkfifo
:
string
->
file_perm
->
unit
Create
a
named
pip
e
with
the
giv
en
p
ermissions.
Sp
ecial
les
value
ioctl_int
:
file_descr
->
int
->
int
->
int
In
terface
to
ioctl
in
the
case
where
the
argumen
t
is
an
in
teger.
The
rst
in
teger
argumen
t
is
the
command
co
de;
the
second
is
the
in
teger
parameter.
value
ioctl_ptr
:
file_descr
->
int
->
string
->
int
In
terface
to
ioctl
in
the
case
where
the
argumen
t
is
a
p
oin
ter.
The
in
teger
argumen
t
is
the
command
co
de.
A
p
oin
ter
to
the
string
argumen
t
is
passed
as
argumen
t
to
the
command.

Chapter
.
The
unix
library:
Unix
system
calls

P
olling
value
select
:
file_descr
list
->
file_descr
list
->
file_descr
list
->
float
->
file_descr
list
*
file_descr
list
*
file_descr
list
W
ait
un
til
some
input/output
op
erations
b
ecome
p
ossible
on
some
c
hannels.
The
three
list
argumen
ts
are,
resp
ectiv
ely
,
a
set
of
descriptors
to
c
hec
k
for
reading
(rst
argumen
t),
for
writing
(second
argumen
t),
or
for
exceptional
conditions
(third
argumen
t).
The
fourth
argumen
t
is
the
maximal
timeout,
in
seconds;
a
negativ
e
fourth
argumen
t
means
no
timeout
(un
b
ounded
w
ait).
The
result
is
comp
osed
of
three
sets
of
descriptors:
those
ready
for
reading
(rst
comp
onen
t),
ready
for
writing
(second
comp
onen
t),
and
o
v
er
whic
h
an
exceptional
condition
is
p
ending
(third
comp
onen
t).
Lo
c
king
type
lock_command
=
F_ULOCK
(*
Unlock
a
region
*)
|
F_LOCK
(*
Lock
a
region,
and
block
if
already
locked
*)
|
F_TLOCK
(*
Lock
a
region,
or
fail
if
already
locked
*)
|
F_TEST
(*
Test
a
region
for
other
process'
locks
*)
Commands
for
lockf.
value
lockf
:
file_descr
->
lock_command
->
int
->
unit
lockf
fd
cmd
size
puts
a
lo
c
k
on
a
region
of
the
le
op
ened
as
fd.
The
region
starts
at
the
curren
t
read/write
p
osition
for
fd
(as
set
b
y
lseek),
and
extends
size
b
ytes
forw
ard
if
size
is
p
ositiv
e,
size
b
ytes
bac
kw
ards
if
size
is
negativ
e,
or
to
the
end
of
the
le
if
size
is
zero.
Signals
type
signal
=
SIGHUP
(*
hangup
*)
|
SIGINT
(*
interrupt
*)
|
SIGQUIT
(*
quit
*)
|
SIGILL
(*
illegal
instruction
(not
reset
when
caught)
*)
|
SIGTRAP
(*
trace
trap
(not
reset
when
caught)
*)
|
SIGABRT
(*
used
by
abort
*)
|
SIGEMT
(*
EMT
instruction
*)
|
SIGFPE
(*
floating
point
exception
*)
|
SIGKILL
(*
kill
(cannot
be
caught
or
ignored)
*)
|
SIGBUS
(*
bus
error
*)
|
SIGSEGV
(*
segmentation
violation
*)
|
SIGSYS
(*
bad
argument
to
system
call
*)
|
SIGPIPE
(*
write
on
a
pipe
with
no
one
to
read
it
*)


|
SIGALRM
(*
alarm
clock
*)
|
SIGTERM
(*
software
termination
signal
from
kill
*)
|
SIGURG
(*
urgent
condition
on
IO
channel
*)
|
SIGSTOP
(*
sendable
stop
signal
not
from
tty
*)
|
SIGTSTP
(*
stop
signal
from
tty
*)
|
SIGCONT
(*
continue
a
stopped
process
*)
|
SIGCHLD
(*
to
parent
on
child
stop
or
exit
*)
|
SIGIO
(*
input/output
possible
signal
*)
|
SIGXCPU
(*
exceeded
CPU
time
limit
*)
|
SIGXFSZ
(*
exceeded
file
size
limit
*)
|
SIGVTALRM
(*
virtual
time
alarm
*)
|
SIGPROF
(*
profiling
time
alarm
*)
|
SIGWINCH
(*
window
changed
*)
|
SIGLOST
(*
resource
lost
(eg,
record-lock
lost)
*)
|
SIGUSR
(*
user
defined
signal

*)
|
SIGUSR
(*
user
defined
signal

*)
The
t
yp
e
of
signals.
type
signal_handler
=
Signal_default
(*
Default
behavior
for
the
signal
*)
|
Signal_ignore
(*
Ignore
the
signal
*)
|
Signal_handle
of
(unit
->
unit)
(*
Call
the
given
function
when
the
signal
occurs.
*)
The
b
eha
vior
on
receipt
of
a
signal
value
kill
:
int
->
signal
->
unit
Send
a
signal
to
the
pro
cess
with
the
giv
en
pro
cess
id.
value
signal
:
signal
->
signal_handler
->
unit
Set
the
b
eha
vior
to
b
e
tak
en
on
receipt
of
the
giv
en
signal.
value
pause
:
unit
->
unit
W
ait
un
til
a
non-ignored
signal
is
deliv
ered.
Time
functions
type
process_times
=
{
tms_utime
:
float;
(*
User
time
for
the
process
*)
tms_stime
:
float;
(*
System
time
for
the
process
*)
tms_cutime
:
float;
(*
User
time
for
the
children
processes
*)
tms_cstime
:
float
}
(*
System
time
for
the
children
processes
*)
The
execution
times
(CPU
times)
of
a
pro
cess.

Chapter
.
The
unix
library:
Unix
system
calls

type
tm
=
{
tm_sec
:
int;
(*
Seconds
0..	
*)
tm_min
:
int;
(*
Minutes
0..	
*)
tm_hour
:
int;
(*
Hours
0..
*)
tm_mday
:
int;
(*
Day
of
month
..
*)
tm_mon
:
int;
(*
Month
of
year
0..
*)
tm_year
:
int;
(*
Year
-
	00
*)
tm_wday
:
int;
(*
Day
of
week
(Sunday
is
0)
*)
tm_yday
:
int;
(*
Day
of
year
0..
*)
tm_isdst
:
bool
}
(*
Daylight
time
savings
in
effect
*)
The
t
yp
e
represen
ting
w
allclo
c
k
time
and
calendar
date.
value
time
:
unit
->
int
Return
the
curren
t
time
since
00:00:00
GMT,
Jan.
,
	0,
in
seconds.
value
gettimeofday
:
unit
->
float
Same
as
time,
but
with
resolution
b
etter
than

second.
value
gmtime
:
int
->
tm
Con
v
ert
a
time
in
seconds,
as
returned
b
y
time,
in
to
a
date
and
a
time.
Assumes
Green
wic
h
meridian
time
zone.
value
localtime
:
int
->
tm
Con
v
ert
a
time
in
seconds,
as
returned
b
y
time,
in
to
a
date
and
a
time.
Assumes
the
lo
cal
time
zone.
value
alarm
:
int
->
int
Sc
hedule
a
SIGALRM
signals
after
the
giv
en
n
um
b
er
of
seconds.
value
sleep
:
int
->
unit
Stop
execution
for
the
giv
en
n
um
b
er
of
seconds.
value
times
:
unit
->
process_times
Return
the
execution
times
of
the
pro
cess.
value
utimes
:
string
->
int
->
int
->
unit
Set
the
last
access
time
(second
arg)
and
last
mo
dication
time
(third
arg)
for
a
le.
Times
are
expressed
in
seconds
from
00:00:00
GMT,
Jan.
,
	0.


User
id,
group
id
value
getuid
:
unit
->
int
Return
the
user
id
of
the
user
executing
the
pro
cess.
value
geteuid
:
unit
->
int
Return
the
eectiv
e
user
id
under
whic
h
the
pro
cess
runs.
value
setuid
:
int
->
unit
Set
the
real
user
id
and
eectiv
e
user
id
for
the
pro
cess.
value
getgid
:
unit
->
int
Return
the
group
id
of
the
user
executing
the
pro
cess.
value
getegid
:
unit
->
int
Return
the
eectiv
e
group
id
under
whic
h
the
pro
cess
runs.
value
setgid
:
int
->
unit
Set
the
real
group
id
and
eectiv
e
group
id
for
the
pro
cess.
value
getgroups
:
unit
->
int
vect
Return
the
list
of
groups
to
whic
h
the
user
executing
the
pro
cess
b
elongs.
type
passwd_entry
=
{
pw_name
:
string;
pw_passwd
:
string;
pw_uid
:
int;
pw_gid
:
int;
pw_gecos
:
string;
pw_dir
:
string;
pw_shell
:
string
}
Structure
of
en
tries
in
the
passwd
database.
type
group_entry
=
{
gr_name
:
string;
gr_passwd
:
string;
gr_gid
:
int;
gr_mem
:
string
vect
}
Structure
of
en
tries
in
the
groups
database.
value
getlogin
:
unit
->
string
Return
the
login
name
of
the
user
executing
the
pro
cess.

Chapter
.
The
unix
library:
Unix
system
calls

value
getpwnam
:
string
->
passwd_entry
Find
an
en
try
in
passwd
with
the
giv
en
name,
or
raise
Not_found.
value
getgrnam
:
string
->
group_entry
Find
an
en
try
in
group
with
the
giv
en
name,
or
raise
Not_found.
value
getpwuid
:
int
->
passwd_entry
Find
an
en
try
in
passwd
with
the
giv
en
user
id,
or
raise
Not_found.
value
getgrgid
:
int
->
group_entry
Find
an
en
try
in
group
with
the
giv
en
group
id,
or
raise
Not_found.
In
ternet
addresses
type
inet_addr
The
abstract
t
yp
e
of
In
ternet
addresses.
value
inet_addr_of_string
:
string
->
inet_addr
value
string_of_inet_addr
:
inet_addr
->
string
Con
v
ersions
b
et
w
een
string
with
the
format
XXX.YYY.ZZZ.TTT
and
In
ternet
addresses.
inet_addr_of_string
raises
Failure
when
giv
en
a
string
that
do
es
not
matc
h
this
format.
So
c
k
ets
type
socket_domain
=
PF_UNIX
(*
Unix
domain
*)
|
PF_INET
(*
Internet
domain
*)
The
t
yp
e
of
so
c
k
et
domains.
type
socket_type
=
SOCK_STREAM
(*
Stream
socket
*)
|
SOCK_DGRAM
(*
Datagram
socket
*)
|
SOCK_RAW
(*
Raw
socket
*)
|
SOCK_SEQPACKET
(*
Sequenced
packets
socket
*)
The
t
yp
e
of
so
c
k
et
kinds,
sp
ecifying
the
seman
tics
of
comm
unications.
type
sockaddr
=
ADDR_UNIX
of
string
|
ADDR_INET
of
inet_addr
*
int
The
t
yp
e
of
so
c
k
et
addresses.
ADDR_UNIX
name
is
a
so
c
k
et
address
in
the
Unix
domain;
name
is
a
le
name
in
the
le
system.
ADDR_INET(addr,port)
is
a
so
c
k
et
address
in
the
In
ternet
domain;
addr
is
the
In
ternet
address
of
the
mac
hine,
and
port
is
the
p
ort
n
um
b
er.


type
shutdown_command
=
SHUTDOWN_RECEIVE
(*
Close
for
receiving
*)
|
SHUTDOWN_SEND
(*
Close
for
sending
*)
|
SHUTDOWN_ALL
(*
Close
both
*)
The
t
yp
e
of
commands
for
shutdown.
type
msg_flag
=
MSG_OOB
|
MSG_DONTROUTE
|
MSG_PEEK
The
ags
for
recv,
recvfrom,
send
and
sendto.
value
socket
:
socket_domain
->
socket_type
->
int
->
file_descr
Create
a
new
so
c
k
et
in
the
giv
en
domain,
and
with
the
giv
en
kind.
The
third
argumen
t
is
the
proto
col
t
yp
e;
0
selects
the
default
proto
col
for
that
kind
of
so
c
k
ets.
value
socketpair
:
socket_domain
->
socket_type
->
int
->
file_descr
*
file_descr
Create
a
pair
of
unnamed
so
c
k
ets,
connected
together.
value
accept
:
file_descr
->
file_descr
*
sockaddr
Accept
connections
on
the
giv
en
so
c
k
et.
The
returned
descriptor
is
a
so
c
k
et
connected
to
the
clien
t;
the
returned
address
is
the
address
of
the
connecting
clien
t.
value
bind
:
file_descr
->
sockaddr
->
unit
Bind
a
so
c
k
et
to
an
address.
value
connect
:
file_descr
->
sockaddr
->
unit
Connect
a
so
c
k
et
to
an
address.
value
listen
:
file_descr
->
int
->
unit
Set
up
a
so
c
k
et
for
receiving
connection
requests.
The
in
teger
argumen
t
is
the
maximal
n
um
b
er
of
p
ending
requests.
value
shutdown
:
file_descr
->
shutdown_command
->
unit
Sh
utdo
wn
a
so
c
k
et
connection.
SHUTDOWN_SEND
as
second
argumen
t
causes
reads
on
the
other
end
of
the
connection
to
return
an
end-of-le
condition.
SHUTDOWN_RECEIVE
causes
writes
on
the
other
end
of
the
connection
to
return
a
closed
pip
e
condition
(SIGPIPE
signal).
value
getsockname
:
file_descr
->
sockaddr
Return
the
address
of
the
giv
en
so
c
k
et.

Chapter
.
The
unix
library:
Unix
system
calls

value
getpeername
:
file_descr
->
sockaddr
Return
the
address
of
the
host
connected
to
the
giv
en
so
c
k
et.
value
recv
:
file_descr
->
string
->
int
->
int
->
msg_flag
list
->
int
value
recvfrom
:
file_descr
->
string
->
int
->
int
->
msg_flag
list
->
int
*
sockaddr
Receiv
e
data
from
an
unconnected
so
c
k
et.
value
send
:
file_descr
->
string
->
int
->
int
->
msg_flag
list
->
int
value
sendto
:
file_descr
->
string
->
int
->
int
->
msg_flag
list
->
sockaddr
->
int
Send
data
o
v
er
an
unconnected
so
c
k
et.
High-lev
el
net
w
ork
connection
functions
value
open_connection
:
sockaddr
->
in_channel
*
out_channel
Connect
to
a
serv
er
at
the
giv
en
address.
Return
a
pair
of
buered
c
hannels
connected
to
the
serv
er.
Remem
b
er
to
call
flush
on
the
output
c
hannel
at
the
righ
t
times
to
ensure
correct
sync
hronization.
value
shutdown_connection
:
in_channel
->
unit
\Sh
ut
do
wn"
a
connection
established
with
open_connection;
that
is,
transmit
an
end-of-le
condition
to
the
serv
er
reading
on
the
other
side
of
the
connection.
value
establish_server
:
(in_channel
->
out_channel
->
unit)
->
sockaddr
->
unit
Establish
a
serv
er
on
the
giv
en
address.
The
function
giv
en
as
rst
argumen
t
is
called
for
eac
h
connection
with
t
w
o
buered
c
hannels
connected
to
the
clien
t.
A
new
pro
cess
is
created
for
eac
h
connection.
The
function
establish_server
nev
er
returns
normally
.
Host
and
proto
col
databases
type
host_entry
=
{
h_name
:
string;
h_aliases
:
string
vect;
h_addrtype
:
socket_domain;
h_addr_list
:
inet_addr
vect
}
Structure
of
en
tries
in
the
hosts
database.
type
protocol_entry
=
{
p_name
:
string;
p_aliases
:
string
vect;
p_proto
:
int
}
Structure
of
en
tries
in
the
protocols
database.


type
service_entry
=
{
s_name
:
string;
s_aliases
:
string
vect;
s_port
:
int;
s_proto
:
string
}
Structure
of
en
tries
in
the
services
database.
value
gethostname
:
unit
->
string
Return
the
name
of
the
lo
cal
host.
value
gethostbyname
:
string
->
host_entry
Find
an
en
try
in
hosts
with
the
giv
en
name,
or
raise
Not_found.
value
gethostbyaddr
:
inet_addr
->
host_entry
Find
an
en
try
in
hosts
with
the
giv
en
address,
or
raise
Not_found.
value
getprotobyname
:
string
->
protocol_entry
Find
an
en
try
in
protocols
with
the
giv
en
name,
or
raise
Not_found.
value
getprotobynumber
:
int
->
protocol_entry
Find
an
en
try
in
protocols
with
the
giv
en
proto
col
n
um
b
er,
or
raise
Not_found.
value
getservbyname
:
string
->
string
->
service_entry
Find
an
en
try
in
services
with
the
giv
en
name,
or
raise
Not_found.
value
getservbyport
:
int
->
string
->
service_entry
Find
an
en
try
in
services
with
the
giv
en
service
n
um
b
er,
or
raise
Not_found.
T
erminal
in
terface
The
follo
wing
functions
implemen
t
the
POSIX
standard
terminal
in
terface.
They
pro
vide
con
trol
o
v
er
async
hronous
comm
unication
p
orts
and
pseudo-terminals.
Refer
to
the
termios
man
page
for
a
complete
description.
type
terminal_io
=
{
Input
mo
des:

Chapter
.
The
unix
library:
Unix
system
calls
	
mutable
c_ignbrk:
bool;
(*
Ignore
the
break
condition.
*)
mutable
c_brkint:
bool;
(*
Signal
interrupt
on
break
condition.
*)
mutable
c_ignpar:
bool;
(*
Ignore
characters
with
parity
errors.
*)
mutable
c_parmrk:
bool;
(*
Mark
parity
errors.
*)
mutable
c_inpck:
bool;
(*
Enable
parity
check
on
input.
*)
mutable
c_istrip:
bool;
(*
Strip
th
bit
on
input
characters.
*)
mutable
c_inlcr:
bool;
(*
Map
NL
to
CR
on
input.
*)
mutable
c_igncr:
bool;
(*
Ignore
CR
on
input.
*)
mutable
c_icrnl:
bool;
(*
Map
CR
to
NL
on
input.
*)
mutable
c_ixon:
bool;
(*
Recognize
XON/XOFF
characters
on
input.
*)
mutable
c_ixoff:
bool;
(*
Emit
XON/XOFF
chars
to
control
input
flow.
*)
Output
mo
des:
mutable
c_opost:
bool;
(*
Enable
output
processing.
*)
Con
trol
mo
des:
mutable
c_obaud:
int;
(*
Output
baud
rate
(0
means
close
connection).*)
mutable
c_ibaud:
int;
(*
Input
baud
rate.
*)
mutable
c_csize:
int;
(*
Number
of
bits
per
character
(-).
*)
mutable
c_cstopb:
int;
(*
Number
of
stop
bits
(-).
*)
mutable
c_cread:
bool;
(*
Reception
is
enabled.
*)
mutable
c_parenb:
bool;
(*
Enable
parity
generation
and
detection.
*)
mutable
c_parodd:
bool;
(*
Specify
odd
parity
instead
of
even.
*)
mutable
c_hupcl:
bool;
(*
Hang
up
on
last
close.
*)
mutable
c_clocal:
bool;
(*
Ignore
modem
status
lines.
*)
Lo
cal
mo
des:
mutable
c_isig:
bool;
(*
Generate
signal
on
INTR,
QUIT,
SUSP.
*)
mutable
c_icanon:
bool;
(*
Enable
canonical
processing
(line
buffering
and
editing)
*)
mutable
c_noflsh:
bool;
(*
Disable
flush
after
INTR,
QUIT,
SUSP.
*)
mutable
c_echo:
bool;
(*
Echo
input
characters.
*)
mutable
c_echoe:
bool;
(*
Echo
ERASE
(to
erase
previous
character).
*)
mutable
c_echok:
bool;
(*
Echo
KILL
(to
erase
the
current
line).
*)
mutable
c_echonl:
bool;
(*
Echo
NL
even
if
c_echo
is
not
set.
*)
Con
trol
c
haracters:
mutable
c_vintr:
char;
(*
Interrupt
character
(usually
ctrl-C).
*)
mutable
c_vquit:
char;
(*
Quit
character
(usually
ctrl-\).
*)
mutable
c_verase:
char;
(*
Erase
character
(usually
DEL
or
ctrl-H).
*)
mutable
c_vkill:
char;
(*
Kill
line
character
(usually
ctrl-U).
*)
mutable
c_veof:
char;
(*
End-of-file
character
(usually
ctrl-D).
*)
mutable
c_veol:
char;
(*
Alternate
end-of-line
char.
(usually
none).
*)
mutable
c_vmin:
int;
(*
Minimum
number
of
characters
to
read

	0
before
the
read
request
is
satisfied.
*)
mutable
c_vtime:
int;
(*
Maximum
read
wait
(in
0.s
units).
*)
mutable
c_vstart:
char;
(*
Start
character
(usually
ctrl-Q).
*)
mutable
c_vstop:
char
(*
Stop
character
(usually
ctrl-S).
*)
}
value
tcgetattr:
file_descr
->
terminal_io
Return
the
status
of
the
terminal
referred
to
b
y
the
giv
en
le
descriptor.
type
setattr_when
=
TCSANOW
|
TCSADRAIN
|
TCSAFLUSH
value
tcsetattr:
file_descr
->
setattr_when
->
terminal_io
->
unit
Set
the
status
of
the
terminal
referred
to
b
y
the
giv
en
le
descriptor.
The
second
argumen
t
indicates
when
the
status
c
hange
tak
es
place:
immediately
(TCSANOW),
when
all
p
ending
output
has
b
een
transmitted
(TCSADRAIN),
or
after
ushing
all
input
that
has
b
een
receiv
ed
but
not
read
(TCSAFLUSH).
TCSADRAIN
is
recommended
when
c
hanging
the
output
parameters;
TCSAFLUSH,
when
c
hanging
the
input
parameters.
value
tcsendbreak:
file_descr
->
int
->
unit
Send
a
break
condition
on
the
giv
en
le
descriptor.
The
second
argumen
t
is
the
duration
of
the
break,
in
0.s
units;
0
means
standard
duration
(0.s).
value
tcdrain:
file_descr
->
unit
W
aits
un
til
all
output
written
on
the
giv
en
le
descriptor
has
b
een
transmitted.
type
flush_queue
=
TCIFLUSH
|
TCOFLUSH
|
TCIOFLUSH
value
tcflush:
file_descr
->
flush_queue
->
unit
Discard
data
written
on
the
giv
en
le
descriptor
but
not
y
et
transmitted,
or
data
receiv
ed
but
not
y
et
read,
dep
ending
on
the
second
argumen
t:
TCIFLUSH
ushes
data
receiv
ed
but
not
read,
TCOFLUSH
ushes
data
written
but
not
transmitted,
and
TCIOFLUSH
ushes
b
oth.
type
flow_action
=
TCOOFF
|
TCOON
|
TCIOFF
|
TCION
value
tcflow:
file_descr
->
flow_action
->
unit
Susp
end
or
restart
reception
or
transmission
of
data
on
the
giv
en
le
descriptor,
dep
ending
on
the
second
argumen
t:
TCOOFF
susp
ends
output,
TCOON
restarts
output,
TCIOFF
transmits
a
STOP
c
haracter
to
susp
end
input,
and
TCION
transmits
a
ST
AR
T
c
haracter
to
restart
input.

Chapter

The
n
um
library:
arbitrary-precision
rational
arithmetic
The
num
library
(distributed
in
contrib/libnum)
implemen
ts
exact-precision
rational
arithmetic.
It
is
built
up
on
the
state-of-the-art
BigNum
arbitrary-precision
in
teger
arithmetic
pac
k
age,
and
therefore
ac
hiev
es
v
ery
high
p
erformance.
The
functions
pro
vided
in
this
library
are
fully
do
cumen
ted
in
The
CAML
Numb
ers
R
efer-
enc
e
Manual
b
y
V
al

erie
M

enissier-Morain,
tec
hnical
rep
ort
,
INRIA,
july
		
(a
v
ailable
b
y
anon
ymous
FTP
from
ftp.inria.fr,
directory
INRIA/publications/RT,
le
RT-0.ps.Z).
A
summary
of
the
functions
is
giv
en
b
elo
w.
Programs
that
use
the
num
library
m
ust
b
e
link
ed
in
\custom
run
time"
mo
de,
as
follo
ws:
camlc
-custom
other
options
nums.zo
other
les
-lnums
F
or
in
teractiv
e
use
of
the
num
library
,
run
camllight
camlnum.
Mac:
This
library
is
not
a
v
ailable.
PC:
This
library
is
a
v
ailable
b
y
default
in
the
standard
run
time
system
and
in
the
toplev
el
system.
Programs
that
use
this
library
can
b
e
link
ed
normally
,
without
the
-custom
option.
.
num:
op
erations
on
n
um
b
ers
Num
b
ers
(t
yp
e
num)
are
arbitrary-precision
rational
n
um
b
ers,
plus
the
sp
ecial
elemen
ts
/0
(innit
y)
and
0/0
(undened).
type
num
=
Int
of
int
|
Big_int
of
big_int
|
Ratio
of
ratio
The
t
yp
e
of
n
um
b
ers.
value
normalize_num
:
num
->
num
value
numerator_num
:
num
->
num
value
denominator_num
:
num
->
num
	

	
Arithmetic
op
erations
value
prefix
+/
:
num
->
num
->
num
value
add_num
:
num
->
num
->
num
Addition
value
minus_num
:
num
->
num
Unary
negation.
value
prefix
-/
:
num
->
num
->
num
value
sub_num
:
num
->
num
->
num
Subtraction
value
prefix
*/
:
num
->
num
->
num
value
mult_num
:
num
->
num
->
num
Multiplication
value
square_num
:
num
->
num
Squaring
value
prefix
//
:
num
->
num
->
num
value
div_num
:
num
->
num
->
num
Division
value
quo_num
:
num
->
num
->
num
value
mod_num
:
num
->
num
->
num
Euclidean
division:
quotien
t
and
remainder
value
prefix
**/
:
num
->
num
->
num
value
power_num
:
num
->
num
->
num
Exp
onen
tiation
value
is_integer_num
:
num
->
bool
T
est
if
a
n
um
b
er
is
an
in
teger
value
integer_num
:
num
->
num
value
floor_num
:
num
->
num
value
round_num
:
num
->
num
value
ceiling_num
:
num
->
num
Appro
ximate
a
n
um
b
er
b
y
an
in
teger.
floor_num
n
returns
the
largest
in
teger
smaller
or
equal
to
n.
ceiling_num
n
returns
the
smallest
in
teger
bigger
or
equal
to
n.
integer_num
n
returns
the
in
teger
closest
to
n.
In
case
of
ties,
rounds
to
w
ards
zero.
round_num
n
returns
the
in
teger
closest
to
n.
In
case
of
ties,
rounds
o
zero.

Chapter
.
The
n
um
library:
arbitrary-precision
rational
arithmetic
	
value
sign_num
:
num
->
int
Return
-,
0
or

according
to
the
sign
of
the
argumen
t.
value
prefix
=/
:
num
->
num
->
bool
value
prefix
</
:
num
->
num
->
bool
value
prefix
>/
:
num
->
num
->
bool
value
prefix
<=/
:
num
->
num
->
bool
value
prefix
>=/
:
num
->
num
->
bool
value
prefix
<>/
:
num
->
num
->
bool
value
eq_num
:
num
->
num
->
bool
value
lt_num
:
num
->
num
->
bool
value
le_num
:
num
->
num
->
bool
value
gt_num
:
num
->
num
->
bool
value
ge_num
:
num
->
num
->
bool
Usual
comparisons
b
et
w
een
n
um
b
ers
value
compare_num
:
num
->
num
->
int
Return
-,
0
or

if
the
rst
argumen
t
is
less
than,
equal
to,
or
greater
than
the
second
argumen
t.
value
max_num
:
num
->
num
->
num
value
min_num
:
num
->
num
->
num
Return
the
greater
(resp.
the
smaller)
of
the
t
w
o
argumen
ts.
value
abs_num
:
num
->
num
Absolute
v
alue.
value
succ_num:
num
->
num
succ
n
is
n+
value
pred_num:
num
->
num
pred
n
is
n-
value
incr_num:
num
ref
->
unit
incr
r
is
r:=!r+,
where
r
is
a
reference
to
a
n
um
b
er.
value
decr_num:
num
ref
->
unit
decr
r
is
r:=!r-,
where
r
is
a
reference
to
a
n
um
b
er.

	
Co
ercions
with
strings
value
string_of_num
:
num
->
string
Con
v
ert
a
n
um
b
er
to
a
string,
using
fractional
notation.
value
approx_num_fix
:
int
->
num
->
string
value
approx_num_exp
:
int
->
num
->
string
Appro
ximate
a
n
um
b
er
b
y
a
decimal.
The
rst
argumen
t
is
the
required
precision.
The
second
argumen
t
is
the
n
um
b
er
to
appro
ximate.
approx_fix
uses
decimal
notation;
the
rst
argumen
t
is
the
n
um
b
er
of
digits
after
the
decimal
p
oin
t.
approx_exp
uses
scien
tic
(exp
onen
tial)
notation;
the
rst
argumen
t
is
the
n
um
b
er
of
digits
in
the
man
tissa.
value
num_of_string
:
string
->
num
Con
v
ert
a
string
to
a
n
um
b
er.
Co
ercions
b
et
w
een
n
umerical
t
yp
es
value
int_of_num
:
num
->
int
value
num_of_int
:
int
->
num
value
nat_of_num
:
num
->
nat__nat
value
num_of_nat
:
nat__nat
->
num
value
num_of_big_int
:
big_int
->
num
value
big_int_of_num
:
num
->
big_int
value
ratio_of_num
:
num
->
ratio
value
num_of_ratio
:
ratio
->
num
value
float_of_num
:
num
->
float
value
num_of_float
:
float
->
num
value
sys_print_num
:
int
->
string
->
num
->
string
->
unit
value
print_num
:
num
->
unit
.
arith_
status:
ags
that
con
trol
rational
arithmetic
value
arith_status:
unit
->
unit
Prin
t
the
curren
t
status
of
the
arithmetic
ags.
value
get_error_when_null_denomin
ator
:
unit
->
bool
value
set_error_when_null_denomin
ator
:
bool
->
unit
Get
or
set
the
ag
null_denominator.
When
on,
attempting
to
create
a
rational
with
a
n
ull
denominator
raises
an
exception.
When
o,
rationals
with
n
ull
denominators
are
accepted.
Initially:
on.

Chapter
.
The
n
um
library:
arbitrary-precision
rational
arithmetic
	
value
get_normalize_ratio
:
unit
->
bool
value
set_normalize_ratio
:
bool
->
unit
Get
or
set
the
ag
normalize_ratio.
When
on,
rational
n
um
b
ers
are
normalized
after
eac
h
op
eration.
When
o,
rational
n
um
b
ers
are
not
normalized
un
til
prin
ted.
Initially:
o.
value
get_normalize_ratio_when_pr
inting
:
unit
->
bool
value
set_normalize_ratio_when_pr
inting
:
bool
->
unit
Get
or
set
the
ag
normalize_ratio_when_printi
ng.
When
on,
rational
n
um
b
ers
are
normalized
b
efore
b
eing
prin
ted.
When
o,
rational
n
um
b
ers
are
prin
ted
as
is,
without
normalization.
Initially:
on.
value
get_approx_printing
:
unit
->
bool
value
set_approx_printing
:
bool
->
unit
Get
or
set
the
ag
approx_printing.
When
on,
rational
n
um
b
ers
are
prin
ted
as
a
decimal
appro
ximation.
When
o,
rational
n
um
b
ers
are
prin
ted
as
a
fraction.
Initially:
o.
value
get_floating_precision
:
unit
->
int
value
set_floating_precision
:
int
->
unit
Get
or
set
the
parameter
floating_precision.
This
parameter
is
the
n
um
b
er
of
digits
displa
y
ed
when
approx_printing
is
on.
Initially:
.

	

Chapter

The
str
library:
regular
expressions
and
string
pro
cessing
The
str
library
(distributed
in
contrib/libstr)
pro
vides
high-lev
el
string
pro
cessing
functions,
some
based
on
regular
expressions.
It
is
in
tended
to
supp
ort
the
kind
of
le
pro
cessing
that
is
usually
p
erformed
with
scripting
languages
suc
h
as
awk,
perl
or
sed.
Programs
that
use
the
str
library
m
ust
b
e
link
ed
in
\custom
run
time"
mo
de,
as
follo
ws:
camlc
-custom
other
options
str.zo
other
les
-lstr
F
or
in
teractiv
e
use
of
the
str
library
,
run
camllight
camlstr.
Mac:
This
library
is
not
a
v
ailable.
PC:
This
library
is
not
a
v
ailable.
.
str:
regular
expressions
and
high-lev
el
string
pro
cessing
Regular
expressions
type
regexp
The
t
yp
e
of
compiled
regular
expressions.
value
regexp:
string
->
regexp
Compile
a
regular
expression.
The
syn
tax
for
regular
expressions
is
the
same
as
in
Gn
u
Emacs.
The
sp
ecial
c
haracters
are
\$^.*+?[].
The
follo
wing
constructs
are
recognized:
.
matc
hes
an
y
c
haracter
except
newline
*
(p
ostx)
matc
hes
the
previous
expression
zero,
one
or
sev
eral
times
+
(p
ostx)
matc
hes
the
previous
expression
one
or
sev
eral
times
?
(p
ostx)
matc
hes
the
previous
expression
once
or
not
at
all
[..]
c
haracter
set;
ranges
are
denoted
with
-,
as
in
a-z;
an
initial
^,
as
in
^0-	,
complemen
ts
the
set
	

	
^
matc
hes
at
b
eginning
of
line
$
matc
hes
at
end
of
line
\|
(inx)
alternativ
e
b
et
w
een
t
w
o
expressions
\(..\)
grouping
and
naming
of
the
enclosed
expression
\
the
text
matc
hed
b
y
the
rst
\(...\)
expression
(\
for
the
second
expression,
etc)
\b
matc
hes
w
ord
b
oundaries
\
quotes
sp
ecial
c
haracters.
value
regexp_case_fold:
string
->
regexp
Same
as
regexp,
but
the
compiled
expression
will
matc
h
text
in
a
case-insensitiv
e
w
a
y:
upp
ercase
and
lo
w
ercase
letters
will
b
e
considered
equiv
alen
t.
String
matc
hing
and
searc
hing
value
string_match:
regexp
->
string
->
int
->
bool
string_match
r
s
start
tests
whether
the
c
haracters
in
s
starting
at
p
osition
start
matc
h
the
regular
expression
r.
The
rst
c
haracter
of
a
string
has
p
osition
0,
as
usual.
value
search_forward:
regexp
->
string
->
int
->
int
search_forward
r
s
start
searc
hs
the
string
s
for
a
substring
matc
hing
the
regular
expression
r.
The
searc
h
starts
at
p
osition
start
and
pro
ceeds
to
w
ards
the
end
of
the
string.
Return
the
p
osition
of
the
rst
c
haracter
of
the
matc
hed
substring,
or
raise
Not_found
if
no
substring
matc
hes.
value
search_backward:
regexp
->
string
->
int
->
int
Same
as
search_forward,
but
the
searc
h
pro
ceeds
to
w
ards
the
b
eginning
of
the
string.
value
matched_string:
string
->
string
matched_string
s
returns
the
substring
of
s
that
w
as
matc
hed
b
y
the
latest
string_match,
search_forward
or
search_backward.
The
user
m
ust
mak
e
sure
that
the
parameter
s
is
the
same
string
that
w
as
passed
to
the
matc
hing
or
searc
hing
function.
value
match_beginning:
unit
->
int
value
match_end:
unit
->
int
match_beginning()
returns
the
p
osition
of
the
rst
c
haracter
of
the
substring
that
w
as
matc
hed
b
y
string_match,
search_forward
or
search_backward.
match_end()
returns
the
p
osition
of
the
c
haracter
follo
wing
the
last
c
haracter
of
the
matc
hed
substring.
value
matched_group:
int
->
string
->
string
matched_group
n
s
returns
the
substring
of
s
that
w
as
matc
hed
b
y
the
nth
group
\(...\)
of
the
regular
expression
during
the
latest
string_match,
search_forward
or
search_backward.
The
user
m
ust
mak
e
sure
that
the
parameter
s
is
the
same
string
that
w
as
passed
to
the
matc
hing
or
searc
hing
function.

Chapter
.
The
str
library:
regular
expressions
and
string
pro
cessing
		
value
group_beginning:
int
->
int
value
group_end:
int
->
int
group_beginning
n
returns
the
p
osition
of
the
rst
c
haracter
of
the
substring
that
w
as
matc
hed
b
y
the
nth
group
of
the
regular
expression.
group_end
n
returns
the
p
osition
of
the
c
haracter
follo
wing
the
last
c
haracter
of
the
matc
hed
substring.
Replacemen
t
value
global_replace:
regexp
->
string
->
string
->
string
global_replace
regexp
repl
s
returns
a
string
iden
tical
to
s,
except
that
all
substrings
of
s
that
matc
h
regexp
ha
v
e
b
een
replaced
b
y
repl.
The
replacemen
t
text
repl
can
con
tain
\,
\,
etc;
these
sequences
will
b
e
replaced
b
y
the
text
matc
hed
b
y
the
corresp
onding
group
in
the
regular
expression.
\0
stands
for
the
text
matc
hed
b
y
the
whole
regular
expression.
value
replace_first:
regexp
->
string
->
string
->
string
Same
as
global_replace,
except
that
only
the
rst
substring
matc
hing
the
regular
expression
is
replaced.
value
global_substitute:
regexp
->
(string
->
string)
->
string
->
string
global_substitute
regexp
subst
s
returns
a
string
iden
tical
to
s,
except
that
all
substrings
of
s
that
matc
h
regexp
ha
v
e
b
een
replaced
b
y
the
result
of
function
subst.
The
function
subst
is
called
once
for
eac
h
matc
hing
substring,
and
receiv
es
s
(the
whole
text)
as
argumen
t.
value
substitute_first:
regexp
->
(string
->
string)
->
string
->
string
Same
as
global_substitute,
except
that
only
the
rst
substring
matc
hing
the
regular
expression
is
replaced.
Splitting
value
split:
regexp
->
string
->
string
list
split
r
s
splits
s
in
to
substrings,
taking
as
delimiters
the
substrings
that
matc
h
r,
and
returns
the
list
of
substrings.
F
or
instance,
split
(regexp
"[
\t]+")
s
splits
s
in
to
blank-separated
w
ords.
value
bounded_split:
regexp
->
string
->
int
->
string
list
Same
as
split,
but
splits
in
to
at
most
n
substrings,
where
n
is
the
extra
in
teger
parameter.

00
Joining
value
concat:
string
list
->
string
Same
as
string__concat:
catenate
a
list
of
string.
value
join:
string
->
string
list
->
string
Catenate
a
list
of
string.
The
rst
argumen
t
is
a
separator,
whic
h
is
inserted
b
et
w
een
the
strings.
Extracting
substrings
value
string_before:
string
->
int
->
string
string_before
s
n
returns
the
substring
of
all
c
haracters
of
s
that
precede
p
osition
n
(excluding
the
c
haracter
at
p
osition
n).
value
string_after:
string
->
int
->
string
string_after
s
n
returns
the
substring
of
all
c
haracters
of
s
that
follo
w
p
osition
n
(including
the
c
haracter
at
p
osition
n).
value
first_chars:
string
->
int
->
string
first_chars
s
n
returns
the
rst
n
c
haracters
of
s.
This
is
the
same
function
as
string_before.
value
last_chars:
string
->
int
->
string
last_chars
s
n
returns
the
last
n
c
haracters
of
s.
F
ormatting
value
format:
('a,
unit,
string)
printf__format
->
'a
Same
as
printf__sprintf.

P
art
V
App
endix
0


Chapter
	
F
urther
reading
F
or
the
in
terested
reader,
w
e
list
b
elo
w
some
references
to
b
o
oks
and
rep
orts
related
(sometimes
lo
osely)
to
Caml
Ligh
t.
	.
Programming
in
ML
The
b
o
oks
b
elo
w
are
programming
courses
taugh
t
in
ML.
Their
main
goal
is
to
teac
h
programming,
not
to
describ
e
ML
in
full
details
|
though
most
con
tain
fairly
go
o
d
in
tro
ductions
to
the
ML
language.
Some
of
those
b
o
oks
use
the
Standard
ML
dialect
instead
of
the
Caml
dialect,
so
y
ou
will
ha
v
e
to
k
eep
in
mind
the
dierences
in
syn
tax
and
in
seman
tics.

Pierre
W
eis
and
Xa
vier
Lero
y
.
L
e
langage
Caml.
In
ter

Editions,
		.
The
natural
companion
to
this
man
ual,
pro
vided
y
ou
read
F
renc
h.
This
b
o
ok
is
a
step-b
y-
step
in
tro
duction
to
programming
in
Caml,
and
presen
ts
man
y
realistic
examples
of
Caml
programs.

Guy
Cousineau
and
Mic
hel
Maun
y
.
Appr
o
che
fonctionnel
le
de
la
pr
o
gr
ammation.
Ediscience,
		.
Another
Caml
programming
course
written
in
F
renc
h,
with
man
y
original
examples.

La
wrence
C.
P
aulson.
ML
for
the
working
pr
o
gr
ammer.
Cam
bridge
Univ
ersit
y
Press,
		.
A
go
o
d
in
tro
duction
to
programming
in
Standard
ML.
Dev
elops
a
theorem
pro
v
er
as
a
com-
plete
example.
Con
tains
a
presen
tation
of
the
mo
dule
system
of
Standard
ML.

Jerey
D.
Ullman.
Elements
of
ML
pr
o
gr
amming.
Pren
tice
Hall,
		.
Another
go
o
d
in
tro
duction
to
programming
in
Standard
ML.
No
realistic
examples,
but
a
v
ery
detailed
presen
tation
of
the
language
constructs.

Ry
an
Stansifer.
ML
primer.
Pren
tice-Hall,
		.
A
short,
but
nice
in
tro
duction
to
programming
in
Standard
ML.

Th

er

ese
Accart
Hardin
and
V

eronique
Donzeau-Gouge
Vigui

e.
Conc
epts
et
outils
de
la
pr
o-
gr
ammation.
Du
fonctionnel

a
l'imp

er
atif
ave
c
Caml
et
A
da.
In
ter

Editions,
		.
0

0
A
rst
course
in
programming,
that
rst
in
tro
duces
the
main
programming
notions
in
Caml,
then
sho
ws
them
underlying
Ada.
In
tended
for
b
eginners;
slo
w-paced
for
the
others.

Rac
hel
Harrison.
A
bstr
act
Data
T
yp
es
in
Standar
d
ML.
John
Wiley
&
Sons,
		.
A
presen
tation
of
Standard
ML
from
the
standp
oin
t
of
abstract
data
t
yp
es.
Uses
in
tensiv
ely
the
Standard
ML
mo
dule
system.

Harold
Ab
elson
and
Gerald
Ja
y
Sussman.
Structur
e
and
Interpr
etation
of
Computer
Pr
o-
gr
ams.
The
MIT
press,
	.
(F
renc
h
translation:
Structur
e
et
interpr

etation
des
pr
o
gr
ammes
informatiques,
In
ter

Editions,
		.)
An
outstanding
course
on
programming,
taugh
t
in
Sc
heme,
the
mo
dern
dialect
of
Lisp.
W
ell
w
orth
reading,
ev
en
if
y
ou
are
more
in
terested
in
ML
than
in
Lisp.
	.
Descriptions
of
ML
dialects
The
b
o
oks
and
rep
orts
b
elo
w
are
descriptions
of
v
arious
programming
languages
from
the
ML
family
.
They
assume
some
familiarit
y
with
ML.

Xa
vier
Lero
y
and
Pierre
W
eis.
Manuel
de
r

ef

er
enc
e
du
langage
Caml.
In
ter

Editions,
		.
The
F
renc
h
edition
of
the
presen
t
reference
man
ual
and
user's
man
ual.

Rob
ert
Harp
er.
Intr
o
duction
to
Standar
d
ML.
T
ec
hnical
rep
ort
ECS-LF
CS--,
Univ
ersit
y
of
Edin
burgh,
	.
An
o
v
erview
of
Standard
ML,
including
the
mo
dule
system.
T
erse,
but
still
readable.

Robin
Milner,
Mads
T
ofte
and
Rob
ert
Harp
er.
The
denition
of
Standar
d
ML.
The
MIT
press,
		0.
A
complete
formal
denition
of
Standard
ML,
in
the
framew
ork
of
structured
op
erational
se-
man
tics.
This
b
o
ok
is
probably
the
most
mathematically
precise
denition
of
a
programming
language
ev
er
written.
It
is
hea
vy
on
formalism
and
extremely
terse,
so
ev
en
readers
who
are
thoroughly
familiar
with
ML
will
ha
v
e
ma
jor
diculties
with
it.

Robin
Milner
and
Mads
T
ofte.
Commentary
on
Standar
d
ML.
The
MIT
Press,
		.
A
commen
tary
on
the
b
o
ok
ab
o
v
e,
that
attempts
to
explain
the
most
delicate
parts
and
motiv
ate
the
design
c
hoices.
Easier
to
read
than
the
Denition,
but
still
rather
in
v
olving.

Guy
Cousineau
and
G

erard
Huet.
The
CAML
primer.
T
ec
hnical
rep
ort
,
INRIA,
		0.
A
short
description
of
the
original
Caml
system,
from
whic
h
Caml
Ligh
t
has
ev
olv
ed.
Some
familiarit
y
with
Lisp
is
assumed.

Pierre
W
eis
et
al.
The
CAML
r
efer
enc
e
manual,
version
...
T
ec
hnical
rep
ort
,
INRIA,
		0.
The
man
ual
for
the
original
Caml
system,
from
whic
h
Caml
Ligh
t
has
ev
olv
ed.

Chapter
	.
F
urther
reading
0

Mic
hael
J.
Gordon,
Arth
ur
J.
Milner
and
Christopher
P
.
W
adsw
orth.
Edinbur
gh
LCF.
Lecture
Notes
in
Computer
Science
v
olume
,
Springer-V
erlag,
		.
This
is
the
rst
published
description
of
the
ML
language,
at
the
time
when
it
w
as
nothing
more
than
the
con
trol
language
for
the
LCF
system,
a
theorem
pro
v
er.
This
b
o
ok
is
no
w
obsolete,
since
the
ML
language
has
m
uc
h
ev
olv
ed
since
then;
but
it
is
still
of
historical
in
terest.

P
aul
Hudak,
Simon
P
eyton-Jones
and
Philip
W
adler.
R
ep
ort
on
the
pr
o
gr
amming
language
Haskel
l,
version
..
T
ec
hnical
rep
ort,
Y
ale
Univ
ersit
y
,
		.
Hask
ell
is
a
purely
functional
language
with
lazy
seman
tics
that
shares
man
y
imp
ortan
t
p
oin
ts
with
ML
(full
functionalit
y
,
p
olymorphic
t
yping),
but
has
in
teresting
features
of
its
o
wn
(dynamic
o
v
erloading,
also
called
t
yp
e
classes).
	.
Implemen
ti
ng
functional
programming
languages
The
references
b
elo
w
are
in
tended
for
those
who
are
curious
to
learn
ho
w
a
language
lik
e
Caml
Ligh
t
is
compiled
and
implemen
ted.

Xa
vier
Lero
y
.
The
ZINC
exp
eriment:
an
e
c
onomic
al
implementation
of
the
ML
language.
T
ec
hnical
rep
ort
,
INRIA,
		0.
(Av
ailable
b
y
anon
ymous
FTP
on
ftp.inria.fr.)
A
description
of
the
ZINC
implemen
tation,
the
protot
yp
e
ML
implemen
tation
that
has
ev
olv
ed
in
to
Caml
Ligh
t.
Large
parts
of
this
rep
ort
still
apply
to
the
curren
t
Caml
Ligh
t
system,
in
particular
the
description
of
the
execution
mo
del
and
abstract
mac
hine.
Other
parts
are
no
w
obsolete.
Y
et
this
rep
ort
still
giv
es
a
complete
o
v
erview
of
the
implemen
tation
tec
hniques
used
in
Caml
Ligh
t.

Simon
P
eyton-Jones.
The
implementation
of
functional
pr
o
gr
amming
languages.
Pren
tice-
Hall,
	.
(F
renc
h
translation:
Mise
en
uvr
e
des
langages
fonctionnels
de
pr
o
gr
ammation,
Masson,
		0.)
An
excellen
t
description
of
the
implemen
tation
of
purely
functional
languages
with
lazy
se-
man
tics,
using
the
tec
hnique
kno
wn
as
graph
reduction.
The
part
of
the
b
o
ok
that
deals
with
the
transformation
from
ML
to
enric
hed
lam
b
da-calculus
directly
applies
to
Caml
Ligh
t.
Y
ou
will
nd
a
go
o
d
description
of
ho
w
pattern-matc
hing
is
compiled
and
ho
w
t
yp
es
are
inferred.
The
remainder
of
the
b
o
ok
do
es
not
apply
directly
to
Caml
Ligh
t,
since
Caml
Ligh
t
is
not
purely
functional
(it
has
side-eects),
has
strict
seman
tics,
and
do
es
not
use
graph
reduction
at
all.

Andrew
W.
App
el.
Compiling
with
c
ontinuations.
Cam
bridge
Univ
ersit
y
Press,
		.
A
complete
description
of
an
optimizing
compiler
for
Standard
ML,
based
on
an
in
termediate
represen
tation
called
con
tin
uation-passing
st
yle.
Sho
ws
ho
w
man
y
adv
anced
program
opti-
mizations
can
b
e
applied
to
ML.
Not
directly
relev
an
t
to
the
Caml
Ligh
t
system,
since
Caml
Ligh
t
do
es
not
use
con
tin
uation-passing
st
yle
at
all,
and
mak
es
little
attempts
at
optimizing
programs.

0
	.
Applications
of
ML
The
follo
wing
rep
orts
sho
w
ML
at
w
ork
in
v
arious,
sometimes
unexp
ected,
areas.

Emman
uel
Chailloux
and
Guy
Cousineau.
The
ML
gr
aph
primer.
T
ec
hnical
rep
ort
	-,

Ecole
Normale
Sup

erieure,
		.
(Av
ailable
b
y
anon
ymous
FTP
on
ftp.ens.fr.)
Describ
es
a
Caml
Ligh
t
library
that
pro
duces
P
ostscript
pictures
through
high-lev
el
dra
wing
functions.

Xa
vier
Lero
y
.
Pr
o
gr
ammation
du
syst

eme
Unix
en
Caml
Light.
T
ec
hnical
rep
ort
,
INRIA,
		.
(Av
ailable
b
y
anon
ymous
FTP
on
ftp.inria.fr.)
A
Unix
systems
programming
course,
demonstrating
the
use
of
the
Caml
Ligh
t
library
that
giv
es
access
to
Unix
system
calls.

John
H.
Repp
y
.
Concurr
ent
pr
o
gr
amming
with
events
|
The
c
oncurr
ent
ML
manual.
Cornell
Univ
ersit
y
,
		0.
(Av
ailable
b
y
anon
ymous
FTP
on
research.att.com.)
Concurren
t
ML
extends
Standard
ML
of
New
Jersey
with
concurren
t
pro
cesses
that
comm
u-
nicate
through
c
hannels
and
ev
en
ts.

Jeannette
M.
Wing,
Man
uel
F
aehndric
h,
J.
Gregory
Morrisett
and
Scottt
Nettles.
Extensions
to
Standar
d
ML
to
supp
ort
tr
ansactions.
T
ec
hnical
rep
ort
CMU-CS-	-,
Carnegie-Mellon
Univ
ersit
y
,
		.
(Av
ailable
b
y
anon
ymous
FTP
on
reports.adm.cs.cmu.edu.
)
Ho
w
to
in
tegrate
the
basic
database
op
erations
to
Standard
ML.

Emden
R.
Gansner
and
John
H.
Repp
y
.
eXene.
Bell
Labs,
		.
(Av
ailable
b
y
anon
ymous
FTP
on
research.att.com.)
An
in
terface
b
et
w
een
Standard
ML
of
New
Jersey
and
the
X
Windo
ws
windo
wing
system.

Index
to
the
library
!
(inx),
0
!=
(inx),

&
(inx),

&&
(inx),

*
(inx),
,
0
**
(inx),

**.
(inx),

**/
(inx),
	
*.
(inx),

*/
(inx),
	
+
(inx),
,
0
+.
(inx),

+/
(inx),
	
-
(inx),
,
0
-.
(inx),

-/
(inx),
	
/
(inx),
,
0
/.
(inx),

//
(inx),
	
<
(inx),

<.
(inx),

</
(inx),
	
<=
(inx),

<=.
(inx),

<=/
(inx),
	
<>
(inx),

<>.
(inx),

<>/
(inx),
	
=
(inx),

=.
(inx),

=/
(inx),
	
==
(inx),

>
(inx),

>.
(inx),

>/
(inx),
	
>=
(inx),

>=.
(inx),

>=/
(inx),
	
@
(inx),

^
(inx),

||
(inx),

abs,

abs_float,
	
abs_num,
	
accept,

access,

acos,

add,
	,
0,
,
,

add_float,

add_int,
0
add_num,
	
alarm,

approx_num_exp,
	
approx_num_fix,
	
arg
(mo
dule),

arith_status,
	
arith_status
(mo
dule),
	
asin,

asr
(inx),

assoc,
	
assq,
	
atan,

atan,

background,

Bad
(exception),

baltree
(mo
dule),

basename,
0
big_int_of_num,
	
bind,

black,

blit_image,

blit_string,

0

0
blit_vect,

blue,

bool
(mo
dule),

bounded_split,
		
Break
(exception),

builtin
(mo
dule),

button_down,
	
catch_break,

cd,

ceil,

ceiling_num,
	
char
(mo
dule),

char_for_read,

char_of_int,

chdir,
,
	
check_suffix,
0
chmod,

choose,

chop_suffix,
0
chown,

clear,
0,
,
	
clear_graph,

clear_parser,

close,
,

close_box,

close_graph,

close_in,

close_out,

close_process,
0
close_process_in,
0
close_process_out,
0
close_tbox,

closedir,
	
combine,
0
command_line,
0
compare,
,
	,

compare_num,
	
compare_strings,

compile,

concat,
,
0,
00
concat_vect,

connect,

contains,
	
copy_vect,

cos,

cosh,

create_image,

create_lexer,

create_lexer_channel,

create_lexer_string,

create_string,

current_dir_name,
0
current_point,

cyan,

debug_mode,

decr,
0
decr_num,
	
denominator_num,
	
descr_of_in_channel,

descr_of_out_channel,

diff,

directory,

dirname,
0
div_float,

div_int,
0
div_num,
	
Division_by_zero
(exception),
0
do_list,

do_list,

do_list_combine,
0
do_stream,

do_table,

do_table_rev,

do_vect,

draw_arc,

draw_char,

draw_circle,

draw_ellipse,

draw_image,

draw_string,

dump_image,

dup,
	
dup,
	
elements,

empty,
,

Empty
(exception),
,
	
End_of_file
(exception),

end_of_stream,


Index
to
the
library
0	
environment,

eprint,

eprintf,
,

eq
(mo
dule),

eq_float,

eq_int,
0
eq_num,
	
eq_string,

equal,

err_formatter,

error_message,

establish_server,

exc
(mo
dule),

except,
	
exceptq,
	
execv,

execve,

execvp,

exists,
	
exit,
,
0
Exit
(exception),

exp,

Failure
(exception),

failwith,

fchar
(mo
dule),

fchmod,

fchown,

fcntl_int,

fcntl_ptr,

filename
(mo
dule),
0
fill_arc,

fill_circle,

fill_ellipse,

fill_poly,

fill_rect,

fill_string,

fill_vect,

find,
	,
0,

find_all,
0
first_chars,
00
flat_map,
	
float,

float
(mo
dule),

float_of_int,

float_of_num,
	
float_of_string,
	
floor,

floor_num,
	
flush,

fold,

for_all,
	
force_newline,

foreground,

fork,

format,
00
format
(mo
dule),
0
fprint,

fprintf,
,

frexp,
	
fst,
0
fstat,

fstring
(mo
dule),
	
ftruncate,

full_init,

full_major,
	
fvect
(mo
dule),
	
gc
(mo
dule),

ge_float,

ge_int,

ge_num,
	
ge_string,

genlex
(mo
dule),
	
get,

get_approx_printing,
	
get_ellipsis_text,

get_error_when_null_deno
minator
,
	
get_floating_precision,
	
get_formatter_output_fun
ctions,

get_image,

get_lexeme,

get_lexeme_char,

get_lexeme_end,

get_lexeme_start,

get_margin,

get_max_boxes,

get_max_indent,

get_normalize_ratio,
	
get_normalize_ratio_when
_printi
ng,
	

0
getcwd,
	
getegid,

getenv,

geteuid,

getgid,

getgrgid,

getgrnam,

getgroups,

gethostbyaddr,

gethostbyname,

gethostname,

getlogin,

getpeername,

getpid,

getppid,

getprotobyname,

getprotobynumber,

getpwnam,

getpwuid,

getservbyname,

getservbyport,

getsockname,

gettimeofday,

getuid,

global_replace,
		
global_substitute,
		
gmtime,

Graphic_failure
(exception),

graphics
(mo
dule),

green,

group_beginning,
		
group_end,
		
gt_float,

gt_int,

gt_num,
	
gt_string,

handle_unix_error,

hash,

hash_param,

hashtbl
(mo
dule),
0
hd,

in_channel_length,

in_channel_of_descr,

include,

incr,
0
incr_num,
	
index,
	
index_char,

index_char_from,

inet_addr_of_string,

init,

init_vect,

input,

input_binary_int,

input_byte,

input_char,

input_line,

input_value,

install_printer,

int,

int
(mo
dule),
0
int_of_char,

int_of_float,

int_of_num,
	
int_of_string,

integer_num,
	
inter,

interactive,
0
intersect,
	
invalid_arg,

Invalid_argument
(exception),

io
(mo
dule),

ioctl_int,
0
ioctl_ptr,
0
is_absolute,
0
is_empty,

is_integer_num,
	
it_list,

it_list,

iter,
,
,
,
	
join,
00
key_pressed,
	
kill,

land
(inx),

last_chars,
00
ldexp,
	
le_float,


Index
to
the
library

le_int,

le_num,
	
le_string,

length,
,
	
lexing
(mo
dule),

lineto,

link,

list
(mo
dule),

list_it,

list_it,

list_length,

list_of_vect,

listen,

lnot,

load,

load_object,

localtime,

lockf,

log,

log0,

lor
(inx),

lseek,

lshift_left,

lshift_right,

lsl
(inx),

lsr
(inx),

lstat,

lt_float,

lt_int,

lt_num,
	
lt_string,

lxor
(inx),

magenta,

major,
	
make_formatter,

make_image,

make_lexer,
	
make_matrix,

make_string,

make_vect,

map,

map
(mo
dule),

map,

map_combine,
0
map_vect,

map_vect_list,

match_beginning,
	
match_end,
	
Match_failure
(exception),
{,

matched_group,
	
matched_string,
	
max,

max_int,

max_num,
	
mem,
	,

mem_assoc,
	
memq,
	
merge,

min,

min_int,

min_num,
	
minor,

minus,
,
0
minus_float,

minus_int,
0
minus_num,
	
mkdir,
	
mkfifo,
0
mod
(inx),
0
mod_float,
	
mod_num,
	
modf,
	
modify,
	
mouse_pos,
	
moveto,

mult_float,

mult_int,
0
mult_num,
	
nat_of_num,
	
neq_float,

neq_int,
0
neq_string,

new,
0,
,
	
nice,

normalize_num,
	
not
(inx),

Not_found
(exception),

nth_char,



num
(mo
dule),
	
num_of_big_int,
	
num_of_float,
	
num_of_int,
	
num_of_nat,
	
num_of_ratio,
	
num_of_string,
	
numerator_num,
	
open,
,

open_box,

open_connection,

open_descriptor_in,

open_descriptor_out,

open_graph,

open_hbox,

open_hovbox,

open_hvbox,

open_in,

open_in_bin,

open_in_gen,

open_out,

open_out_bin,

open_out_gen,

open_process,
0
open_process_in,
0
open_process_out,
0
open_tbox,

open_vbox,

opendir,
	
or
(inx),

out_channel_length,

out_channel_of_descr,

Out_of_memory
(exception),

output,

output_binary_int,

output_byte,

output_char,

output_compact_value,

output_string,

output_value,

over_max_boxes,

pair
(mo
dule),
0
parse,

Parse_error
(exception),
,

Parse_failure
(exception),

parsing
(mo
dule),

pause,

peek,

pipe,
	
plot,

point_color,

pop,
	
pos_in,

pos_out,

power,

power_num,
	
pp_close_box,

pp_close_tbox,

pp_force_newline,

pp_get_ellipsis_text,

pp_get_formatter_output_
functio
ns,

pp_get_margin,

pp_get_max_boxes,

pp_get_max_indent,

pp_open_box,

pp_open_hbox,

pp_open_hovbox,

pp_open_hvbox,

pp_open_tbox,

pp_open_vbox,

pp_over_max_boxes,

pp_print_as,

pp_print_bool,

pp_print_break,

pp_print_char,

pp_print_cut,

pp_print_float,

pp_print_flush,

pp_print_if_newline,

pp_print_int,

pp_print_newline,

pp_print_space,

pp_print_string,

pp_print_tab,

pp_print_tbreak,

pp_set_ellipsis_text,

pp_set_formatter_out_cha
nnel,

pp_set_formatter_output_
functio
ns,

pp_set_margin,


Index
to
the
library

pp_set_max_boxes,

pp_set_max_indent,

pp_set_tab,

pred,
0
pred_num,
	
prerr_char,

prerr_endline,

prerr_float,

prerr_int,

prerr_string,

print,

print_as,

print_bool,

print_break,

print_char,
,

print_cut,

print_endline,

print_float,
,

print_flush,

print_if_newline,

print_int,
,

print_newline,
,

print_num,
	
print_space,

print_stat,

print_string,
,

print_tab,

print_tbreak,

printexc
(mo
dule),

printf,
,

printf
(mo
dule),

push,
	
queue
(mo
dule),

quit,

quo
(inx),
0
quo_num,
	
raise,

random
(mo
dule),

ratio_of_num,
	
read,

read_float,

read_int,

read_key,
	
read_line,

readdir,
	
readlink,
0
really_input,

recv,

recvfrom,

red,

ref
(mo
dule),
0
regexp,
	
regexp_case_fold,
	
remove,
	,
0,
,
,

remove_printer,

rename,
,

replace_first,
		
replace_string,

rev,

rewinddir,
	
rgb,

rhs_end,

rhs_start,

rindex_char,

rindex_char_from,

rmdir,
	
round_num,
	
s_irall,
0
s_irgrp,
0
s_iroth,
0
s_irusr,
0
s_isgid,
0
s_isuid,
0
s_iwall,
0
s_iwgrp,
0
s_iwoth,
0
s_iwusr,
0
s_ixall,
0
s_ixgrp,
0
s_ixoth,
0
s_ixusr,
0
search_backward,
	
search_forward,
	
seek_in,

seek_out,

select,

send,

sendto,



set,

set
(mo
dule),

set_approx_printing,
	
set_color,

set_ellipsis_text,

set_error_when_null_denomi
nator,
	
set_floating_precision,
	
set_font,

set_formatter_out_channel,

set_formatter_output_funct
ions,

set_line_width,

set_margin,

set_max_boxes,

set_max_indent,

set_normalize_ratio,
	
set_normalize_ratio_when_p
rinting
,
	
set_nth_char,

set_print_depth,

set_print_length,

set_tab,

set_text_size,

setgid,

setuid,

shutdown,

shutdown_connection,

sign_num,
	
signal,

sin,

sinh,

size_x,

size_y,

sleep,

snd,
0
socket,

socketpair,

sort,

sort
(mo
dule),

sound,
	
split,
0,
	,
		
sprintf,

sqrt,

square_num,
	
stack
(mo
dule),
	
stat,
,

std_err,

std_formatter,

std_in,

std_out,

stderr,
,

stdin,
,

stdout,
,

str
(mo
dule),
	
stream
(mo
dule),

stream_check,

stream_from,

stream_get,

stream_next,

stream_of_channel,

stream_of_string,

string
(mo
dule),

string_after,
00
string_before,
00
string_for_read,

string_length,

string_match,
	
string_of_bool,

string_of_char,

string_of_float,
	
string_of_inet_addr,

string_of_int,

string_of_num,
	
sub_float,

sub_int,
0
sub_num,
	
sub_string,

sub_vect,

substitute_first,
		
subtract,
	
succ,
0
succ_num,
	
symbol_end,

symbol_start,

symlink,
0
sys
(mo
dule),
	
Sys_error
(exception),
	
sys_print_num,
	
system,

system_command,

take,


Index
to
the
library

tan,

tanh,

tcdrain,
	0
tcflow,
	0
tcflush,
	0
tcgetattr,
	0
tcsendbreak,
	0
tcsetattr,
	0
text_size,

time,
,

times,

tl,

toplevel
(mo
dule),

trace,

transp,

truncate,

umask,

union,
	,

unix
(mo
dule),

Unix_error
(exception),

unlink,

untrace,

utimes,

vect
(mo
dule),

vect_assign,

vect_item,

vect_length,

vect_of_list,

verbose_mode,

wait,

wait_next_event,

waitopt,

waitpid,

white,

write,

yellow,


Index
of
k
eyw
ords
and,
se
e
let,
type,
exception,
value,
where
as,

begin,
,

do,
se
e
while,
for
done,
se
e
while,
for
downto,
se
e
for
else,
se
e
if
end,
,

exception,
,

for,
,

fun,

function,
,

if,
,

in,
se
e
let
let,
,

match,
,
,

mutable,
0,

not,

of,
se
e
type,
exception
or,
,

prefix,
,
,
	
rec,
se
e
let,
where
then,
se
e
if
to,
se
e
for
try,
,

type,
0,

value,

when,

where,

while,

with,
se
e
match,
try


