A Categorical Programming Language
Tatsuya Hagino
Doctor of Philosophy
University of Edinburgh
1987

Authorâ€™s address:
Tatsuya Hagino
Data Processing Center
Kyoto University
Kyoto 606
Japan

Abstract
A theory of data types and a programming language based on category theory are
presented.
Data types play a crucial role in programming. They enable us to write programs easily
and elegantly. Various programming languages have been developed, each of which may
use diï¬€erent kinds of data types. Therefore, it becomes important to organize data
types systematically so that we can understand the relationship between one data type
and another and investigate future directions which lead us to discover exciting new
data types.
There have been several approaches to systematically organize data types: algebraic
speciï¬cation methods using algebras, domain theory using complete partially ordered
sets and type theory using the connection between logics and data types. Here, we use
category theory. Category theory has proved to be remarkably good at revealing the
nature of mathematical objects, and we use it to understand the true nature of data
types in programming.
We organize data types under a new categorical notion of F, G-dialgebras which is
an extension of the notion of adjunctions as well as that of T-algebras. T-algebras
are also used in domain theory, but while domain theory needs some primitive data
types, like products, to start with, we do not need any. Products, coproducts and
exponentiations (i.e. function spaces) are deï¬ned exactly like in category theory using
adjunctions. F, G-dialgebras also enable us to deï¬ne the natural number object, the
object for ï¬nite lists and other familiar data types in programming. Furthermore, their
symmetry allows us to have the dual of the natural number object and the object for
inï¬nite lists (or lazy lists).
We also introduce a functional programming language in a categorical style. It has
no primitive data types nor primitive control structures.
Data types are declared
using F, G-dialgebras and each data type is associated with its own control structure.
For example, natural numbers are associated with primitive recursion. We deï¬ne the
meaning of the language operationally by giving a set of reduction rules.
We also
prove that any computation in this programming language terminates using Taitâ€™s
computability method.
A speciï¬cation language to describe categories is also included.
It is used to give
a formal semantics to F, G-dialgebras as well as to give a basis to the categorical
programming language we introduce.
ii

Acknowledgements
The greatest thanks go to Professor Rod Burstall who, ï¬rst of all, accepted me as a
Ph. D. student, then, supervised me during my Ph. D. study and, further, gave me
an opportunity to continue working in Edinburgh. He gave me not only useful advices
but also much-needed mental support. I would also thank to his wife, Sissi Burstall,
who invited me to their house often and made my stay in Edinburgh very pleasant.
I am also grateful to Professor Reiji Nakajima for having encouraged me to come
to Edinburgh and to Professor Heisuke Hironaka for having helped me to solve the
ï¬nancial problem for studying in Edinburgh.
Many lectures I attended in the ï¬rst year enlightened me a lot: domain theory, op-
erational semantics, denotational semantics, algebraic speciï¬cation, category theory,
and so on. I did not know what category theory really is before I came to Edinburgh.
Thanks to Andrzej Tarlecki, Edmund Robinson and John Cartmell for having helped
me to overcome the initial diï¬ƒculty of category theory. John Cartmell also helped me
a lot through discussions in the early stage of the thesis. I am also in debt to Furio
Honsell who introduced me to Taitâ€™s method for proving normalization theorems of
lambda calculi when I stuck in the normalization proof of CPL. Many other people in
Edinburgh helped me with their comments and through discussions. I would especially
like to thank Bob McKay and Paul Taylor for reading the early drafts and discovering
some disastrous mistakes.
This thesis is written using LaTEX on a Sun workstation and printed by an Apple
LaserWriter. I would like to thank George Cleland and Hugh Stabler for providing
wonderful computing facilities and software to Laboratory of Foundation of Computer
Science.
My Ph. D. study at the University of Edinburgh has been funded by the Educational
Project for Japanese Mathematical Scientists, Harvard University, by the Overseas Re-
search Students Award and by the Science and Engineering Research Council Research
Fellowship.
iii

Contents
1
Introduction
1
1.1
Backgrounds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.1.1
Algebraic Speciï¬cation Methods . . . . . . . . . . . . . . . . . .
2
1.1.2
Domain Theory . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.2
Basic Category Theory . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.3
Development of Categorical Data Types
. . . . . . . . . . . . . . . . .
7
1.4
In This Thesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
1.5
Comparison with Other Works . . . . . . . . . . . . . . . . . . . . . . .
15
2
Categorical Speciï¬cation Language
17
2.1
A Functorial Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
2.2
Signatures of Categorical Speciï¬cation Language . . . . . . . . . . . . .
26
2.3
Structures of Categorical Speciï¬cation Language . . . . . . . . . . . . .
31
2.4
Functorial Calculus (revisit) . . . . . . . . . . . . . . . . . . . . . . . .
32
2.5
Sentences and Satisfaction Relation of Categorical Speciï¬cation Language 38
2.6
Free Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
3
Categorical Data Types
44
3.1
What are Categorical Data Types? . . . . . . . . . . . . . . . . . . . .
44
3.2
Data Type Declarations in Categorical Data Types
. . . . . . . . . . .
53
3.3
Examples of Categorical Data Types
. . . . . . . . . . . . . . . . . . .
56
3.3.1
Terminal and Initial Objects . . . . . . . . . . . . . . . . . . . .
56
iv

3.3.2
Products and CoProducts . . . . . . . . . . . . . . . . . . . . .
57
3.3.3
Exponentials
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
3.3.4
Natural Number Object
. . . . . . . . . . . . . . . . . . . . . .
60
3.3.5
Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
62
3.3.6
Final Co-Algebras (Inï¬nite Lists and Co-Natural Number Object) 63
3.3.7
Automata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
3.3.8
Obscure Categorical Data Types
. . . . . . . . . . . . . . . . .
69
3.4
Semantics of Categorical Data Types . . . . . . . . . . . . . . . . . . .
70
3.5
Existence of Left and Right . . . . . . . . . . . . . . . . . . . . . . . .
74
4
Computation and Categorical Data Types
78
4.1
Reduction Rules for Categorical Programming Language . . . . . . . .
79
4.2
An Example of using Reduction Rules
. . . . . . . . . . . . . . . . . .
92
4.3
Well-Deï¬nedness and Normalization Theorem for Reduction Rules . . .
96
4.4
Properties of Computable Objects . . . . . . . . . . . . . . . . . . . . .
108
4.5
Reduction Rules for Full Evaluation . . . . . . . . . . . . . . . . . . . .
112
5
Application of Categorical Data Types
115
5.1
An implementation of Categorical Programming Language . . . . . . . 115
5.2
Typed Lambda Calculus . . . . . . . . . . . . . . . . . . . . . . . . . .
120
5.3
ML and Categorical Programming Language . . . . . . . . . . . . . . .
124
Conclusions
128
Bibliography
131
v

Chapter 1
Introduction
This is an exploration of data types through category theory. It is an attempt to achieve
better understanding of data types, their uniform classiï¬cation, and discovery of a new
world of data types. Data types have been with us since the very ï¬rst programming
languages. Even some machine languages now have some concept of data types, but
early programming languages had only a ï¬xed number of data types, like integers, reals
and strings, and/or a ï¬xed number of data type constructors, like array constructors
and record constructors. When we gradually realized how important data types were,
programming languages started having richer and richer data types.
A number of
programming languages now allow us to deï¬ne our own data types. Some might even
say that the richer they are, the better the programming languages are. Programming
languages can be classiï¬ed by the way how they handle data types.
There is no question about the importance of data types. Much research in this area
has produced various kinds of data types, so varied that one cannot capture them all.
We now need to systematically organize data types. We want to know the connection
between one data type and another. We want to know the reason why those data types
are with us and while some other data types are not. After getting a clear view of data
types, we might ï¬nd the future direction to discover other important data types.
There have been already some attempts to organize data types. We can name some of
the important ones: Domain theory is one, algebraic speciï¬cation is another and type
theory is one where a lot of research is going on at the moment. In this thesis, we
will present yet another attempt to organize data types. We do so by using category
theory. We call our data types Categorical Data Types (or CDT for short).
One might ask â€œWhy category theory?â€ Category theory is known as highly abstract
mathematics. Some call it abstract nonsense. It chases abstract arrows and diagrams,
proves nothing but about those arrows and diagrams, rarely talks about what arrows
are for and often concepts go beyond oneâ€™s imagination. However, when this â€˜abstract
nonsenseâ€™ works, it is like magic. One may discover a simple theorem actually means
very deep things and some concepts beautifully unify and connect things which are
unrelated before.
1

CHAPTER 1. INTRODUCTION
2
In ordinary mathematics, whether we are aware or not, we are in the world of set
theory. Mathematics has been so well developed with set theory that we can hardly
do anything without it. Therefore, it is very natural that semantics of programming
languages is generally based on set theory. Note that it is often said that most of
programming languages do not have set theoretic semantics and, therefore, domain
theory has been developed, but this does not contradict with â€œsemantics based on set
theoryâ€, because domain theory itself is based on set theory. A domain is a set with
certain properties.
Set theory is a powerful tool, but sometimes this power disï¬gures beautiful objects
so that we cannot directly see their natural properties. For example, in set theory it
is not easy to see either the duality between injective and surjective functions or the
duality between cartesian products and disjoint sums. It is in category theory that
these dualities come out clearly. Category theory concentrates on the outer behaviour
of objects. It does not care what is in an object, whereas set theory is all about what is
in an object. It is interesting to know that seeing from the outside reveals the nature of
an object more naturally than seeing its inside. For example, one of the most important
concepts discovered by category theory is adjunction (or adjoint situation), which is
strikingly simple but very beautiful and uniï¬es various concepts under the same name.
Our slogan is: â€œcategory theory can provide a better and more natural understanding of
mathematical objects than set theoryâ€, so we use it to guide our tour around the world
of data types. Note that we do not mean to abandon set theory by this. We will still
heavily rely on it, but our intuition should not be obstructed by it.
1.1
Backgrounds
1.1.1
Algebraic Speciï¬cation Methods
Algebraic speciï¬cation methods were ï¬rst developed to describe what programs do.
They are not like operational semantics or denotational semantics. These semantics
also describe what programs do but in a diï¬€erent way. They describe it by giving
meaning to each part of programs. They need to know how programs are written, that
is, they need actual codes. Whereas, algebraic speciï¬cation methods never talk about
how programs are implemented. They describe their behaviour abstractly viewing from
outside.
This abstract view point, seeing from outside, led to the discovery of abstract data
types (see e.g. [Goguen, Thatcher and Wagner 78]).
It is interesting to know that
algebraic speciï¬cation methods were started to describe programs but it also developed
a theory of data types. Since algebraic speciï¬cation methods try to describe things
from an outside point of view, they cannot talk about the concrete nature of data types
which programs handle. Therefore, the data types also needed to be abstracted and,
thus, abstract data types have been developed. We may divide algebraic speciï¬cation

CHAPTER 1. INTRODUCTION
3
methods into two: speciï¬cation of data types and speciï¬cation of programs.
Speciï¬cation
of Programs
Speciï¬cation of Data Types
Algebraic Speciï¬cation
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
@
@
@
@
@
@
@
@
@
@
@@
It is the former, speciï¬cation of data types, that concerns us in this thesis.
Algebraic speciï¬cation methods got their method of describing data types from abstract
algebras in mathematics. Mathematicians have been using abstract algebras for about
a century. Abstract algebras are only concerned with concrete real algebras insofar as
they satisfy some laws. For example, a set with a binary operation is a group when the
operation is associative, there is an identity and every element is invertible. A real set
and a real operation can be anything, integers and +, general linear matrixes and their
multiplication, and so on. Any theorem established for general groups can be applied
to any real groups. There are various kinds of abstract algebras: groups, rings, ï¬elds,
and so on. Those abstract algebras can be presented uniformly by universal algebras.
Algebraic speciï¬cation methods use a many-sorted version of universal algebras.
NaÂ¨Ä±vely speaking, an algebraic speciï¬cation is a triple (S, Î£, E), where S is a set of
sorts, Î£ is a Sâˆ—Ã— S-indexed set of operations and E is a set of equations over Î£.
For example, in an algebraic speciï¬cation language CLEAR [Burstall and Goguen 80,
Burstall and Goguen 82] a speciï¬cation of lists may be as follows.
constant List =
theory
sorts element, list
opns nil : list
cons : element, list -> list
head : list -> element
tail : list -> list
eqns all e : element, l : list, head(cons(e,l)) = e
all e : element, l : list, tail(cons(e,l)) = l
endth
S is { element, list }, Î£list is { nil }, Î£list element is { head }, and so on. E consists
of the two equations above.
There are several problems about this speciï¬cation as we will see immediately after we
say what a speciï¬cation means. An algebraic speciï¬cation (S, Î£, E) deï¬nes a class of
many sorted algebras each of which, say A, consists of an S-sorted set |A| and functions
fA: |A|s1 Ã— . . . Ã— |A|sn âˆ’â†’|A|s for each f âˆˆÎ£s1...sns which satisfy the equations in E.

CHAPTER 1. INTRODUCTION
4
The ï¬rst problem of the above speciï¬cation is that not only lists satisfy it but also
many of other data types as well. There is actually no way to make it describe only
lists so long as we stick to ï¬rst order methods. We need something of second order.
The way algebraic speciï¬cation methods usually obtain this is to put data constraints.
We rely on the categorical fact that the initial algebra is unique up to isomorphism. In
this case, we put a data constraint onto the sort â€˜listâ€™, but not to â€˜elementâ€™ because
if we put a data constraint onto â€˜elementâ€™ then the â€˜elementâ€™ sort would be empty.
The second problem is that â€˜headâ€™ and â€˜tailâ€™ are partial functions. The speciï¬cation
does not say what is â€˜head(nil)â€™ or what is â€˜tail(nil)â€™. In order to ï¬x this problem,
we have to introduce, for example, error algebras or go into partial algebras.
The third problem is that although we put a data constraint on â€˜listâ€™ it is not im-
mediately obvious that â€˜nilâ€™ and â€˜consâ€™ can construct all the lists. Some algebraic
speciï¬cation languages do distinguish these constructors from the others.
The fourth problem is about the sort â€˜elementâ€™. We actually need it as a parameter.
When we use this speciï¬cation, â€˜elementâ€™ denotes a particular data type deï¬ned by
another speciï¬cation and we need a way to plug in any speciï¬cation of â€˜elementâ€™
into this speciï¬cation. Actually, CLEAR has this facility. â€˜Listâ€™ can be deï¬ned as
â€˜procedureâ€™ taking parametrized type â€˜elementâ€™. However, this new speciï¬cation no
longer corresponds to a class of algebras but to something one level higher.
Many other problems there might be, but most of them have been solved in one way
or another. The important point we would like to make is that the naÂ¨Ä±ve idea of
algebraic speciï¬cation = universal algebra
does not work well and we have to put a lot of other ideas into algebraic speciï¬cation
methods. One might wonder why so many complications are needed to deï¬ne everyday
objects like lists.
In CDT, we stick to the very simple relation
categorical data type = F, G-dialgebra
F, G-dialgebras can be seen as an extension of universal algebras (see section 3.1). We
do not need to introduce meta arguments or any other complicated ideas into CDT in
order to deï¬ne lists or other basic data types.
1.1.2
Domain Theory
Domain theory was started with denotational semantics [Stoy 77, Scott 76]. In order
to give denotational semantics to programs, we need several domains to which the
denotations are mapped. Those domains are often interwoven and recursively deï¬ned.
The most famous example of this is the following D.
D âˆ¼= D â†’D

CHAPTER 1. INTRODUCTION
5
This domain D was necessary to give denotational semantics to the untyped lambda
calculus. In general, we would like to solve the following domain equation:
D âˆ¼= F(D)
where F(D) is a domain expression involving D.
Though domains are mathematical objects and not necessarily representable in com-
puters, the idea of recursively deï¬ned data types has been adopted into several pro-
gramming languages. For example, we can have a domain L for lists of A elements by
solving1
L âˆ¼= 1 + A Ã— L,
and in the original version of ML [Gordon, Milner and Wordsworth 79], we could deï¬ne
the data type for lists just like the same.
abstype â€™a list = unit + â€™a # â€™a list
with ...
On the other hand, some domains cannot be represented in the same way. For example,
we can have a domain I for inï¬nite lists of A elements by solving
I âˆ¼= A Ã— IâŠ¥
where IâŠ¥is the lifting of I by adding the new least element, but we cannot deï¬ne
inï¬nite lists in ML in a similar way.
Comparing with algebraic speciï¬cation methods, in domain theory we can deï¬ne data
types easily and there is no complication of parametrized data types, but we have some
diï¬ƒculty of deï¬ning operations over data types. In algebraic speciï¬cation methods we
deï¬ne operations together with data types, but in domain theory we have to deï¬ne
them using the isomorphisms of domain equations.
If an algebraic speciï¬cation (S, Î£, E) has no equational constraints (i.e. E = âˆ…), the
initial algebra can be given by solving the following domain equations.
|A|s âˆ¼=
X
fâˆˆÎ£s1...sns
|A|s1 Ã— . . . Ã— |A|sn
By this connection, we can see the possibility of combining algebraic speciï¬cation
methods and domain theory together. Actually, data types in the current Standard
ML [Milner 84, Harper, MacQueen and Milner 86] are deï¬ned in this mixed fashion
(see also section 5.3).
Categorically, we can go the other way round. If F(D) is a covariant functor, the
initial ï¬xed point of F(D) can be characterized as the initial F-algebra. A F-algebra
is a categorical generalization of an ordinary algebra. The main idea we borrow from
domain theory is this connection between initial ï¬xed points and initial algebras.
1We have to say what kind of domains we are dealing with. Let us say in this thesis that a domain is
a complete partially ordered set with the least element and a function between domains needs to be
continuous and strict.

CHAPTER 1. INTRODUCTION
6
After becoming familiar with category theory, one can notice the dual connection be-
tween ï¬nal ï¬xed points and ï¬nal co-algebras. People rarely talked about them until
recently [Arbib and Manes 80]. One of the reasons is that co-algebras are not so pop-
ular and another reason is that ï¬nal ï¬xed points are often the same as initial ï¬xed
points in domain theory. However, in CDT we will use this dual connection as well.
Final co-algebras give us some very intersting data types like inï¬nite lists. We deï¬ned
inï¬nite lists by the initial ï¬xed point of
I âˆ¼= A Ã— IâŠ¥
Actually, what we were doing using the lifting IâŠ¥is to get the ï¬nal ï¬xed point of
I âˆ¼= A Ã— I.
1.2
Basic Category Theory
This section is to roughly introduce some categorical concepts we will use in the rest of
this thesis. The author refers to category theory text books like [Mac Lane 71], [Arbib
and Manes 75] and [Lambek and Scott 86] for a more detailed account of category
theory.
A category C is given by
â‹„a collection of objects |C|,
â‹„for any pair of objects A and B, a collection HomC(A, B) of morphisms from
domain A to codomain B, (we write f: A â†’B for f âˆˆHomC(A, B))
â‹„for any objects A, B and C, an operation called composition denoted by â€˜â—¦â€™ from
HomC(B, C) Ã— HomC(A, B) to HomC(A, C) which is associative,
(f â—¦g) â—¦h = f â—¦(g â—¦h)
â‹„for any object A, an identity morphism IA: A â†’A such that for any f: B â†’A
and any g: A â†’C
IA â—¦f = f
and
g â—¦IA = g
Two objects A and B are called isomorphic if there are two morphisms f: A â†’B and
g: B â†’A such that
f â—¦g = IB
and
g â—¦f = IA.
f and g are called isomorphisms.
The opposite category Cop of a category C is deï¬ned by reversing the direction of all
the morphisms in C.
HomCop(A, B) = HomC(B, A)
We may write Cop morphism f op: A â†’B for C morphism f: B â†’A.
The product category C Ã— D of a category C and a category D is given as

CHAPTER 1. INTRODUCTION
7
â‹„a C Ã— D object is âŸ¨A, BâŸ©for a C object A and a D object B
â‹„a C Ã— D morphism from âŸ¨A, BâŸ©to âŸ¨Aâ€², Bâ€²âŸ©is âŸ¨f, gâŸ©for a C morphism f: A â†’B
and a D morphism g: A â†’B.
A covariant functor F from a category C to a category D (we write F: C â†’D) is given
by
â‹„associating a D object F(A) for every C object A
â‹„associating a D morphism F(f): F(A) â†’F(B) for every C morphism f: A â†’B
such that
F(IA) = IF(A)
and
F(f â—¦g) = F(f) â—¦F(g)
A contravariant functor is deï¬ned in a similar way except that F(f): F(B) â†’F(A).
A natural transformation Î± from a covariant functor F: C â†’D to a covariant functor
G: C â†’D (we write Î±: F
Â·â†’G) is given by
â‹„associating a D morphism Î±A: F(A) â†’G(A) for every C object A such that for
any C morphism f: A â†’B the following diagram commutes.
F(A)
Î±A
G(A)
-
F(f)
Â¥
Â¨Â§?
G(f)
?
?
F(B)
Î±B
-G(B)
When every Î±A is an isomorphism, we call Î± natural isomorphism.
Two functors F: C â†’D and G: D â†’C are called adjoints if there exists a natural
isomorphism
ÏˆA,B: HomD(F(A), B)
âˆ¼
=
âˆ’â†’HomC(A, G(B)).
F is called the left adjoint functor of G and G is called the right adjoint functor of F.
We also call ÏˆA,B (or its inverse Ïˆâˆ’1
A,B) factorizer or mediating morphism.
1.3
Development of Categorical Data Types
The motivation of CDT was to adopt the categorical way of deï¬ning data types into
speciï¬cation languages. Anybody educated using set theory has quite a shock when
he ï¬rst sees the way category theory works. It gives a totally diï¬€erent point of view
to things which are familiar. Things which were vaguely connected suddenly are ï¬tted
into systematic places. It seems that the nature of things is ï¬nally revealed.
There are many beautiful concepts discovered through category theory, but here we
concentrate only one of them, namely adjunction (or adjoint situation). In [Mac Lane
71], one will ï¬nd many equivalent forms of the deï¬nition of adjunction (we gave one of
them in section 1.2). One may be ï¬rst at a loss for chosing the deï¬nition. Adjunction

CHAPTER 1. INTRODUCTION
8
is so versatile that it can be seen in a number of diï¬€erent forms and it is sometimes
diï¬ƒcult to understand it if one sticks to a particular form of the deï¬nition. The form
is not important if the spirit is understood. Adjunction can be regarded as a property
of two functors or because of the unique correspondence between two functors it can
be seen as deï¬ning one of them from the other. It is the latter which is important to us
because it is a typical way of deï¬ning things in category theory. Let us see an example.
Using set theory, we can deï¬ne what the product of two sets is, what the product of two
groups is, what the product of two topological spaces is, and so on. Each deï¬nition
is obviously deferent from the others but all of them are called by the same name,
product. Why is that so? Is there any common property which all the diï¬€erent kinds
of products should satisfy? Can we give the general deï¬nition of product? Category
theory can give an aï¬ƒrmative answer to these questions. The categorical deï¬nition of
products is
For object A and B, the product A Ã— B is an object such that there are
two morphisms
Ï€1: A Ã— B âˆ’â†’A
and
Ï€2: A Ã— B âˆ’â†’B
and for any given two morphisms
f: C âˆ’â†’A
and
g: C âˆ’â†’B
there is a unique morphism h: C âˆ’â†’AÃ—B such that the following diagram
commutes.
A
A Ã— B
B
Ï€1
Ï€2

-
C
f
g
h
Â¥
Â¨Â§?
Â¥
Â¨Â§?
@
@
@
@
@
@
@
@
I
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡

6
It is easily shown that any two objects satisfy this deï¬nition are isomorphic.
We may write âŸ¨f, gâŸ©for h.
This deï¬nition is general enough to cover the deï¬nition of products for sets, groups,
topological spaces, and so on. We no longer need to deï¬ne products for each individual
case.
The generality should not be bound only in mathematics. Why should it not equally
be appropriate to the deï¬nition of products in programming languages? The product
data type of type A and type B is usually deï¬ned as a type of records whose ï¬rst
component is of type A and the second one is of type B, but this deï¬nition is like one
in set theory. It assumes too much about how elements of data types are represented.
It is not acceptable as an abstract description of the product data type. If the product
data type is deï¬ned as an abstract data type, how can we present it?

CHAPTER 1. INTRODUCTION
9
We can directly adopt the categorical deï¬nition of products. There are ï¬ve ingredients
in the deï¬nition.
1.
two given objects A and B,
2.
the object A Ã— B we are deï¬ning,
3.
two morphisms Ï€1: A Ã— B âˆ’â†’A and Ï€2: A Ã— B âˆ’â†’B,
4.
âŸ¨f, gâŸ©: C âˆ’â†’A Ã— B for f: C âˆ’â†’A and g: C âˆ’â†’B, and
5.
the commutative diagram.
We may write these down as follows
object A Ã— B is
Ï€1: A Ã— B âˆ’â†’A
Ï€2: A Ã— B âˆ’â†’B
âŸ¨f, gâŸ©: C âˆ’â†’A Ã— B for f: C âˆ’â†’A and g: C âˆ’â†’B
where
Ï€1 â—¦âŸ¨f, gâŸ©= f
Ï€2 â—¦âŸ¨f, gâŸ©= g
Ï€1 â—¦h = f âˆ§Ï€2 â—¦h = g â‡’h = âŸ¨f, gâŸ©
end object.
(âˆ—)
Can we call this a categorical deï¬nition of the product data type constructor? Although
this is an exact copy of the categorical deï¬nition, it has somehow lost the spirit of
category theory; its beauty; its simplicity. The categorical deï¬nition of products we
gave is in a disguised form of adjunction. The deï¬nition could have been suï¬ƒcient
to just say that the product functor is the right adjoint of the diagonal functor. The
previous deï¬nition expands this into plain words so that there are a lot of duplications.
One of them is that the type of âŸ¨, âŸ©can be deduced from the type of Ï€1 and Ï€2. If f
and g has the same type as Ï€1 and Ï€2 except replacing AÃ—B by C, âŸ¨f, gâŸ©is a morphism
from C to A Ã— B. Another duplication is that the commutative diagram can also be
deduced from the rest. There are no other trivial ways to make diagrams involving
Ï€1, Ï€2, f, g and âŸ¨f, gâŸ©. Therefore, the deï¬nition of product data types can be written
simply as
object A Ã— B is
Ï€1: A Ã— B âˆ’â†’A
Ï€2: A Ã— B âˆ’â†’B
end object.
This supplies the minimal information to get back to (âˆ—). Now, we have to use the fact
that A Ã— B is deï¬ned by adjunction (it was not necessary in (âˆ—)). Let us indicate this
by saying it is a right object as well as declaring âŸ¨, âŸ©.
right object A Ã— B with âŸ¨, âŸ©is
Ï€1: A Ã— B âˆ’â†’A
Ï€2: A Ã— B âˆ’â†’B
end object
This is the declaration of the product data type constructor in CDT (except for minor
changes).

CHAPTER 1. INTRODUCTION
10
Let us examine the generality and simplicity of this declaration mechanism through
examples. Let us try exponentials BA. The functor â€¢A is deï¬ned as the right adjoint
functor of â€¢ Ã— A. The deï¬nition in CDT is
right object BA with curry( ) is
eval: BA Ã— A âˆ’â†’B
end object
We can derive the usual deï¬nition of exponentials from this deï¬nition. First, the type
of curry( ) should be
f: C Ã— A âˆ’â†’B
curry(f): C âˆ’â†’BA
.
The type of f is obtained from the type of â€˜evalâ€™ just replacing BA by C. The commu-
tative diagram which curry(f) gives can be obtained by connecting
BA Ã— A
-
eval
B
and
C Ã— A
-
f
B
by curry(f): C âˆ’â†’BA. The only way to connect them together results
C Ã— A
curry(f) Ã— A
f
BA Ã— A
B
eval
-
6
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡

The morphism denoted by curry(f) is the unique one which makes this diagram com-
mute. Thus, we recovered the ordinary deï¬nition of exponentials.
We said â€˜right objectâ€™ for products and exponentials. It is natural to think that we also
have â€˜left objectâ€™ as dual. The dual of products are coproducts. Let us deï¬ne them in
CDT.
left object A + B with [ , ] is
Î½1: A âˆ’â†’A + B
Î½2: B âˆ’â†’A + B
end object
The type of [ , ] can be obtained from the type of Î½1 and Î½2.
f: A âˆ’â†’C
g: B âˆ’â†’C
[f, g]: A + B âˆ’â†’C
Note that [f, g] goes from A + B to C not the other way round as it would be if it
were a right object. The name â€˜left objectâ€™ came from the fact that A + B is in the left
hand side of âˆ’â†’. Remember that A Ã— B was in the right hand side of âˆ’â†’for âŸ¨, âŸ©.

CHAPTER 1. INTRODUCTION
11
A natural way of connecting f and g with Î½1 and Î½2 by [f, g] gives us the ordinary
commutative diagram which [f, g] should satisfy.
A
A + B
B
Î½1
Î½2
-

C
f
g
[f, g]
Â¥
Â¨Â§?
Â¥
Â¨Â§?
@
@
@
@
@
@
@
@
R
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Âª
?
We demonstrated that we can express basic categorical constructs in CDT. Those
constructs, or data types, are primitives in ordinary programming languages. Can we
declare more familiar data types? In fact, the â€˜left objectâ€™ declaration gives all those
which can be deï¬ned by algebraic methods with no equations. â€˜Without equationsâ€™
seems that we cannot deï¬ne much, but actually it gives us all the important data types
of ordinary programming languages. For example, natural numbers can be deï¬ned as
left object nat with pr( , ) is
zero: 1 âˆ’â†’nat
succ: nat âˆ’â†’nat
end object
This is very much like a speciï¬cation of natural numbers in algebraic speciï¬cation
methods except that we do not have the predecessor function or plus or times and that
we have something called pr( , ). From analogy of the types of [ , ] and âŸ¨, âŸ©, the type
of pr( , ) should be
f: 1 âˆ’â†’C
g: C âˆ’â†’C
pr(f, g): nat âˆ’â†’C
.
We also obtain the diagram characterizing â€˜natâ€™ as we did for products and others.
1
zero
nat
succ
nat
f
Â¥
Â¨Â§?
pr(f, g)
Â¥
Â¨Â§?
pr(f, g)
C
C
g
-
-
@
@
@
@
@
@
@
@
R
-
?
?
This is exactly the deï¬nition of â€˜natâ€™ being a natural number object in category theory
and it is well-known that we can deï¬ne all the primitive recursive functions using
pr( , ). For example, the addition function can be deï¬ned by
add def
= eval â—¦âŸ¨pr(curry(Ï€2), curry(succ â—¦eval)) â—¦Ï€1, Ï€2âŸ©.

CHAPTER 1. INTRODUCTION
12
As another example, we give the deï¬nition of lists in CDT. It is
left object list(A) with prl( , ) is
nil: 1 âˆ’â†’list(A)
cons: A Ã— list(A) âˆ’â†’list(A)
end object
The type of prl( , ) is
f: 1 âˆ’â†’C
g: A Ã— C âˆ’â†’C
prl(f, g): list(A) âˆ’â†’C
.
The diagram is
1
list(A)
A Ã— list(A)
B
A Ã— B
nil
cons
f
Â¥
Â¨Â§?
prl(f, g)
Â¥
Â¨Â§?
IA Ã— prl(f, g)
g
-
@
@
@
@
@
@
@
@
R


?
?
Remember that our deï¬nition of lists in CLEAR had â€˜headâ€™ and â€˜tailâ€™, but we do not
declare them here. We can deï¬ne them by prl( , ).
head def
= prl(Î½2, Î½1 â—¦Ï€1)
: list(A) âˆ’â†’A + 1
tail def
= [Î½1 â—¦Ï€2, Î½2] â—¦prl(Î½2, Î½1 â—¦âŸ¨Ï€1, [cons, nil]âŸ©)
: list(A) âˆ’â†’list(A) + 1
â€˜Without equationsâ€™ is not a disadvantage to deï¬ne everyday data types.
By the connection between initial ï¬xed points and F-algebras, we can deï¬ne the initial
ï¬xed point D of a covariant functor F(X) as follows.
left object D with Ïˆ( ) is
Î±: F(D) âˆ’â†’D
end object
Î± gives one direction of the isomorphism between D and F(D), and Ïˆ( ) gives unique
arrows.
F(D)
Î±
D
-
F(Ïˆ(f))
Â¥
Â¨Â§?
Ïˆ(f)
?
?
F(A)
f
-
A
We have been using â€˜left objectâ€™ more than â€˜right objectâ€™, but they are dual and there
are equally as many right objects as left objects. Just they are not familiar in ordinary

CHAPTER 1. INTRODUCTION
13
programming languages. For example, the following deï¬nition gives the data type for
inï¬nite lists.
right object inï¬‚ist(A) with fold( , ) is
hd: inï¬‚ist(A) âˆ’â†’A
tl: inï¬‚ist(A) âˆ’â†’inï¬‚ist(A)
end object
This gives the ï¬nal ï¬xed point of I âˆ¼= A Ã— I.
We have devised, based on category theory, a simple way of deï¬ning data types. The
next question is whether we can adopt this method into ordinary programming lan-
guages. The answer is negative. Although what we can deï¬ne in this way is far less
than what we can deï¬ne using algebraic speciï¬cation languages with equations, we still
have some strange things that can be deï¬ned in this way. Let us see an example. We
deï¬ned list(A) as a parametrized data type but in fact it is a functor.
list(f): list(A) âˆ’â†’list(B)
for a morphism f: A âˆ’â†’B is often called map function. In LISP it is â€˜MAPCARâ€™
and in ML it is â€˜mapâ€™. The general declaration mechanism of CDT allows us to deï¬ne
the left and right adjoint functors of list(A) which could not exist in the world of
programming. We need to put a restriction to prevent these objects. The restriction
will come out of a notion of computability in our setting. Interestingly, it turns out
the category should be
cartesian closed + initial ï¬xed points + ï¬nal ï¬xed points
We might see the similarity between this and the connection of lambda calculus and
cartesian closed categories.
By putting this computability restriction, we can regard CDT as not only a device of
deï¬ning data types but also a programming language. We program in a categorical
fashion; there are no concrete data but morphisms; programs are also morphisms;
there are no variables in programs. The computation in this language is reduction
from morphisms to canonical ones. For example, we can reduce
add â—¦âŸ¨succ â—¦zero, succ â—¦zeroâŸ©â‡’succ â—¦succ â—¦zero
which corresponds to the calculation of 1 + 1 = 2.
We summerize the characteristics of CDT as follows.
1. CDT uses categorical characterization of data types.
We do not need to say
things explicitly. All the equations are automatically generated for deï¬nitions.
2. CDT needs no primitive data types. Ordinary programming languages (e.g. PAS-
CAL, LISP, ML) have primitive data types: natural numbers, lists, records, and
so on, but CDT does not. They can be deï¬ned. Thus, CDT is analogous to
algebraic speciï¬cation methods where we can specify them as well. However,
algebraic speciï¬cation methods cannot specify higher order data types (i.e. func-
tion spaces or exponentials in a categorical term) nor can they specify products
without using equations.

CHAPTER 1. INTRODUCTION
14
3. CDT can not only deï¬ne products without explicitly mentioning equations but
also can deï¬ne exponentials.
4. CDT is symmetric in the sense that we can deï¬ne initial algebras (or initial ï¬xed
points) as well as ï¬nal co-algebras (or ï¬nal ï¬xed points).
5. Algebraic speciï¬cation methods use initiality implicitly and do not use the unique
homomorphisms between the initial algebras and the others, whereas CDT has
explicit access to the unique morphisms. This gives the power of programming
without going though equational characterization as it is necessary in algebraic
speciï¬cation methods.
6. Domain theory does not use the initiality explicitly either. The reason for this
is that recursion in ordinary programming languages provide all the power of
programming.
7. CDT deï¬nes functors.
Functors are thought to be parametrized data types.
Algebraic speciï¬cation methods usually introduce parametrization later, but in
CDT functorial behaviour of parametrized data types is treated at the base level.
1.4
In This Thesis
The theory of categorical data types is divided into three: Categorical Speciï¬cation
Language, Categorical Data Types and Categorical Programming Language.
Categorical
Programming Language
Categorical Data Types
Categorical Speciï¬cation Language
Chapter 2 is about Categorical Speciï¬cation Language (CSL for short).
CSL is a
speciï¬cation language. It is an extension of ordinary algebraic speciï¬cation languages.
Whereas algebraic speciï¬cations specify algebras, it speciï¬es categories. In order to
specify categories, CSL has to handle functors, natural transformations and factorizers
(or mediating morphisms). A CSL signature declares some functor names and their
types (i.e. variances), some natural transformation names and their types and some
factorizer names and their types. A CSL sentence is a conditional equation of functors,
natural transformations and factorizers. A CSL model is a category equipped with
functors, natural transformations and factorizers which have right types as are speciï¬ed
in the signature and which satisfy the sentences.
Chapter 3 gives the main idea of Categorical Data Types. The diï¬€erence between
CSL and CDT is that whereas CSL declares functors, natural transformations and

CHAPTER 1. INTRODUCTION
15
factorizers separately and connects them by sentences, CDT declare them together in
a style of adjoint declarations. The semantics of CDT will be given informally in terms
of F, G-algebras and formally in terms of CSL. There are some examples of data types
we can deï¬ne in CDT.
Chapter 4 is about Categorical Programming Language (CPL for short). CPL is a
functional programming language which adopts the categorical declaration mechanism
of data types from CDT. In order to deï¬ne the notion of computation in CPL, we
have to put some restrictions to CDT. We will introduce the notion of elements and
canonical elements and present reduction rules to reduce elements to their equivalent
canonical elements. We will also prove that any reduction in CPL terminates using
Taitâ€™s computability method.
Each of those three languages, CSL, CDT and CPL, characterizes a category of data
types in diï¬€erent ways.
Syntax
Semantics
CSL
Signature and Sentences
Models
CDT
Adjoint Declarations
Freeness and Co-Freeness
CPL
Restricted Adjoint Declarations
Operational
In chapter 5, we will investigate the real consequences of our study in CDT. Section 5.1
is about an implementation of CPL as a real programming language. Section 5.2 is
about the connection between CDT and typed lambda calculi, and ï¬nally in section 5.3
we will attempt to extend ML incorporating the CDT data type declaration mechanism.
1.5
Comparison with Other Works
Systematic studies of data types have already been carried out by various people in
various contexts: ADJ in the context of initial algebras [Goguen, Thatcher and Wagner
78], Plotkin, Smyth and Lehmann in the context of domains [Lehmann and Smyth 81,
Smyth and Plotkin 82] and Martin-LÂ¨of in the context of type theory [Martin-LÂ¨of 79].
This thesis is about a study of the same subject in the context of category theory. We
do not try to extend the traditional approaches as Parasaya-Ghomi did for algebraic
speciï¬cation methods to include higher order types [Parasaya-Ghomi 82], nor do we try
to unify two approaches together like [Dybjer 83], but we just directly use categorical
methods of deï¬ning things.
Categorical Programming Language in chapter 4 might resemble Categorical Abstract
Machine (CAM) by Curien [Curien 86], but he is only interested in cartesian closed
categories whereas CPL deals with a class of diï¬€erent categories. Moreover, the reduc-
tion rules in CPL is systematically generated for products, coproducts, exponentials,
natural numbers, and so on. We do not give any special reduction rules for any data
types we deï¬ne. CPL can be seen as
CPL = CAM + initial data types + ï¬nal data types.

CHAPTER 1. INTRODUCTION
16
Actually, CAM can be absorbed into â€˜initial data typesâ€™ and â€˜ï¬nal data typesâ€™, so in
CPL we do not need to start with a particular set of reduction rules for cartesian closed
categories. CPL has an ability to deï¬ne cartesian closed categories and the introduction
of data types also gives the control structure over those data types. Here is another
slogan: â€œcontrol structures in programming languages come out of the structure of data
typesâ€.
Data Types
Control Structures
boolean
â†”
if statement
disjoint union
â†”
case statement
natural number
â†”
primitive recursion, for statement
product
â†”
pairing
function space
â†”
function call
Barr and Wells uses sketches in [Barr and Wells 85] to describe algebras categorically.
It is more powerful than ordinary algebraic speciï¬cation methods because sketches can
use any kind of limits whereas algebraic speciï¬cation methods uses only products. It
is interesting to investigate CSL by sketches.

Chapter 2
Categorical Speciï¬cation Language
CDT can be seen from various points of view and can be presented in many ways.
In this chapter, we present it as a speciï¬cation language for categories (we call the
speciï¬cation language Categorical Speciï¬cation Language or CSL for short). This is not
the way originated, and it is diï¬ƒcult to recognize natural properties of data types in
this way. We will give an alternative and more intuitive deï¬nition of CDT in chapter 3.
However, the aim of CSL is to give mathematically rigorous background for the more
intuitive presentation of CDT.
In applicative functional programming languages like ML, it is natural to see that their
data types and functions form a category; each data type is an object; each function
is a morphism; we have an identity function; and two functions can be composed in
a usual way. We can also treat other programming languages including procedural
ones semantically as deï¬ning domains and functions, and we can see that they form a
category. These categories associated with programming languages reï¬‚ect the charac-
teristics of the programming languages. Thus, the study of data types can be carried
out by examining these categories. CSL is a speciï¬cation language for these categories.
Usually, a category is given by deï¬ning what an object consists of (e.g. a set for Set,
the category of sets) and what a morphism between objects is (e.g. a set function for
Set), but this is not the way CSL works. We are trying to understand a category
in an abstract manner; we do not say what an object is; instead, we specify how it
is constructed through its relationship among other objects. We saw in chapter 1 an
ML data type for lists and it was a parameterized data type.
We can now see it
as a data type constructor; given a data type it constructs a new data type for the
lists of the given data type. Categorically, constructors of objects are functors and
they provide structures for categories. Remember that a cartesian closed category is a
category with three functors, the terminal (constant) functor, the product functor and
the exponential functor. Thus, CSL speciï¬es a category equipped with some functors.
Because the properties of functors are often described in terms of their interaction with
natural transformations and factorizers (e.g. the binary product functor is explained
with two natural transformations, Ï€1 and Ï€2, and factorizer âŸ¨, âŸ©), CSL also speciï¬es
natural transformations and factorizers.
17

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
18
Let us make a comparison with algebraic speciï¬cation languages like CLEAR [Burstall
and Goguen 80, Burstall and Goguen 82]. An algebraic speciï¬cation consists of decla-
rations of some sorts and some operations on these sorts. Sorts are their data types.
A model of an algebraic speciï¬cation is a many-sorted algebra. On the other hand, a
CSL speciï¬cation consists of declarations of some functors, some natural transforma-
tions between them and some factorizers. Functors correspond to sorts, and natural
transformations and factorizers correspond to operations. A model of a CSL speciï¬ca-
tion is a category equipped with some functors, some natural transformations between
them and some factorizers. It is abstract in the sense that the speciï¬cation does not
distinguish between equivalent categories (an algebraic speciï¬cation does not distin-
guish isomorphic algebras). Note that, in general, the various models of a speciï¬cation
are not equivalent (e.g. not all the cartesian categories are equivalent).
As CSL speciï¬es functors, the treatment of parametrized data types is diï¬€erent from
algebraic speciï¬cation languages. It speciï¬es one level higher objects. The concept of
parameterized data types and how to combine them play very essential roles in algebraic
speciï¬cation languages, but parameterized data types are treated in their meta-level
(one level higher than the level treating algebras), that is speciï¬cations themselves are
parameterized rather than dealing with parameterized sorts in speciï¬cations. In CSL,
on the other hand, parameterized data types are the basic objects in speciï¬cations.
In one speciï¬cation, several parameterized data types can be declared and their re-
lationship is directly speciï¬ed. Therefore, combining speciï¬cations does not play as
important a role as it does in algebraic speciï¬cation languages.
Our goal in this chapter is to deï¬ne the speciï¬cation language CSL. In section 2.1,
we will introduce several notations for dealing with functors which will be necessary
later. In section 2.2, we will deï¬ne the CSL signatures and in section 2.3 the CSL
structures. The deï¬nition of CSL sentences and the CSL satisfaction relation will be
in section 2.5 which follows section 2.4 in which we will introduce expressions involving
natural transformations and factorizers. Finally, in section 2.6 we will show that there
is an initial CSL structure for each CSL theory.
2.1
A Functorial Calculus
Before giving the deï¬nition of CSL signatures, we will look at some aspects of functors.
This will be a kind of a functorial calculus though not as abstract as [Kelly 72] is. [Kelly
72] develops a calculus of combining functors as we will do in this section, but for the
purpose of solving the coherence problems, and he treats many variable functors quite
extensively. However, he does not say much about mixed variant functors which we
are interested in. We will also generalize variances to include free-variance and ï¬xed-
variance for uniform treatment.
Functors are very much like ordinary functions except that functors have variances.
Let F be a unary functor C â†’C and G be a binary functor C Ã— C â†’C. Then, we can

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
19
combine them to get more complex functors:
G(F(X), Y )
F(G(X, F(Y )))
G(F(X), G(X, Y ))
. . .
We call them functorial expressions. Of course, not every such expression denotes a
functor. For example, G(X, X) is not a proper functor if G is covariant in one argument
and contravariant in the other. It is a functor if G is covariant in both arguments or
contravariant in both arguments, or if G does not depend on one of the arguments.
In order to cope with these situations uniformly, we introduce two new variances: ï¬xed-
variance and free-variance. We say that a functor F(X) is ï¬xed-variant in X if F is
not functorial in X, that is, F maps objects to objects, but not morphisms. We also
say that a functor F(X) is free-variant in X if F does not depend on X. Therefore,
when G: C Ã— C â†’C is covariant in the ï¬rst argument and contravariant in the second,
G(X, X) is a ï¬xed-variant functor.
Let us introduce the symbols for variances.
Deï¬nition 2.1.1: Let Var be the set of variances {+, âˆ’, âŠ¥, âŠ¤}: + for covariance,
âˆ’for contravariance, âŠ¥for free-variance and âŠ¤for ï¬xed-variance. []
The next deï¬nition is extending the notion of opposite categories.
Deï¬nition 2.1.2: Let C be a category.
1. C+ is C itself.
2. Câˆ’is the opposite category of C.
3. CâŠ¥is the category which has only one object and only one morphism (i.e. the
identity of the one object). We may call the category one point category.
4. CâŠ¤is the category which has the same objects as C but no morphisms except
identities. []
In this way, we can regard the variances as functions mapping categories to categories
(i.e. Cat â†’Cat, where Cat is the category of (small) categories) or we can even
regard them as a monoid acting on Cat.
Deï¬nition 2.1.3: âŸ¨Var, â€¢âŸ©is a commutative monoid with unit +, where the monoid
operation â€¢: Var Ã— Var â†’Var is deï¬ned by the following table.
â€¢ âŠ¥+ âˆ’âŠ¤
âŠ¥âŠ¥âŠ¥âŠ¥âŠ¥
+ âŠ¥+ âˆ’âŠ¤
âˆ’âŠ¥âˆ’+ âŠ¤
âŠ¤âŠ¥âŠ¤âŠ¤âŠ¤
[]

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
20
Proposition 2.1.4: âŸ¨Var, â€¢âŸ©is a monoid acting on Cat, that is, Cuâ€¢v = (Cu)v for any
u, v âˆˆVar.
Proof: We have to show (Câˆ’)âˆ’= C (i.e. the opposite of opposite is itself) and so on,
but they are trivial. []
Since we will deal with many variable functors and they are functors from products
of categories C Ã— Â· Â· Â· Ã— C to a category C, Var action for product categories should be
investigated.
Proposition 2.1.5: Var action on Cat distributes over products, that is, for any
categories C and D
(C Ã— D)u âˆ¼= Cu Ã— Du.
Proof: In case u is âˆ’, it says that the opposite of the product category is isomorphic
to the product of the opposite categories and it is the case because âŸ¨f, gâŸ©op: âŸ¨A, BâŸ©â†’
âŸ¨C, DâŸ©â‡â‡’âŸ¨f, gâŸ©: âŸ¨C, DâŸ©â†’âŸ¨A, BâŸ©â‡â‡’f: C â†’A and g: D â†’B â‡â‡’f op: A â†’C
and gop: B â†’D â‡â‡’âŸ¨f op, gopâŸ©: âŸ¨A, BâŸ©â†’âŸ¨C, DâŸ©. The other cases are trivial. []
We need one more preparation before talking about mixed variant functors. The cate-
gory CâŠ¤can be embedded into C+ as well as into Câˆ’and they themselves are embedded
into CâŠ¥, that is we have the following embedding functors.
C+
â†™
â†–
CâŠ¥
CâŠ¤
â†–
â†™
Câˆ’
We introduce a partial order on Var to respect these embeddings.
Deï¬nition 2.1.6: âŠ‘is a partial order on Var such that âŠ¥âŠ‘+ âŠ‘âŠ¤and âŠ¥âŠ‘âˆ’âŠ‘âŠ¤. []
From the deï¬nition, it is clear that
Proposition 2.1.7: If u âŠ‘v, there is an embedding functor eu,v: Cv â†’Cu. []
Now we can start talking about mixed variant functors and their calculus. As a function
is associated with an arity (simply a natural number), a mixed variant functor over a
particular category C is associated with a varity which is a sequence of variances. For
example, binary functor G: C Ã— C â†’C which is contravariant in the ï¬rst argument and
covariant in the second is a functor with a varity âˆ’+.
Deï¬nition 2.1.8: A mixed variant functor F of varity v1 . . . vn is a (covariant) functor
from Cv1 Ã— Â· Â· Â· Ã— Cvn to C. []
When we are given a Varâˆ—-indexed set Î“ of primitive mixed variant functors, where
F âˆˆÎ“v1...vn is a functor of varity v1 . . . vn, we would like to establish how to combine
these primitive functors and get more complex functors like H(G(X, Y ), F(X)).
Firstly, we extend the action of variances on categories to that on functors. For exam-
ple, from a contravariant functor F: Câˆ’â†’C we get a covariant functor F âˆ’: C â†’Câˆ’as
F âˆ’(f: A â†’B) def
= F(f op: B â†’A).

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
21
Deï¬nition 2.1.9: For a functor F: C â†’D,
1. a functor F +: C+ â†’D+ is F itself,
2. a functor F âˆ’: Câˆ’â†’Dâˆ’is given by F âˆ’(A) = A for an object A in C and
F âˆ’(f op) = F(f)op for a morphism f in C,
3. a functor F âŠ¥: CâŠ¥â†’DâŠ¥is the identity functor since both CâŠ¥and DâŠ¥are the one
point category, and
4. a functor F âŠ¤: CâŠ¤â†’DâŠ¤has the same object mapping as F but no morphism
mapping.
F: C â†’D
F âŠ¤: CâŠ¤â†’DâŠ¤
F âˆ’: Câˆ’â†’Dâˆ’
F âŠ¥: CâŠ¥â†’DâŠ¥

>
-
ZZZZZZ
~
[]
This deï¬nition is forced from the deï¬nition of Cu, so Var action has more structure.
Proposition 2.1.10: For a functor F: C â†’D, (F u)v = F uâ€¢v.
Proof: We have to check this for all the combinations of u and v.
For example,
(F âˆ’)âŠ¤= F âŠ¤is true because F âˆ’only changes the mapping of morphisms but (F âˆ’)âŠ¤
forgets it. []
We have the two propositions which give us the basis for combining mixed variant
functors.
Proposition 2.1.11: For functors F: Cu1 Ã— Â· Â· Â· Ã— Cun â†’Cv1 Ã— Â· Â· Â· Ã— Cvm and G: Cv1 Ã—
Â· Â· Â· Ã— Cvm â†’C (i.e. varity v1 . . . vm), G â—¦F is a functor of Cu1 Ã— Â· Â· Â· Ã— Cun â†’C (i.e.
varity u1 . . . un).
Cu1 Ã— Â· Â· Â· Ã— Cun
F
Cv1 Ã— Â· Â· Â· Ã— Cvm
G
C
-
-
Proof: Trivial from the deï¬nition of composition of functors. []

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
22
Proposition 2.1.12: For functors F1: Cu1 Ã—Â· Â· Â·Ã—Cun â†’Cv1, . . . , Fm: Cu1 Ã—Â· Â· Â·Ã—Cun â†’
Cvm, âŸ¨F1, . . . , FmâŸ©is a functor of Cu1 Ã— Â· Â· Â· Ã— Cun â†’Cv1 Ã— Â· Â· Â· Ã— Cvm.
Cu1 Ã— Â· Â· Â· Ã— Cun
F1
...
Fi
...
Fm
Cv1
...
Cvi
...
Cvm
Â©Â©Â©Â©Â©Â©Â©
Â©
*
-
HHHHHHH
H
j
â‡’
Cu1 Ã— Â· Â· Â· Ã— CunâŸ¨F1, . . . , FmâŸ©Cv1 Ã— Â· Â· Â· Ã— Cvm
-
Proof: It is trivial from the deï¬nition of products in Cat. []
The two propositions allow us to combine functors only if the source and target cate-
gories match exactly. For example, F: C â†’C and G: Câˆ’â†’C cannot be composed into
G â—¦F. Therefore, we have to ï¬rst convert functors of Cv1 Ã— Â· Â· Â· Ã— Cvn â†’C into those
of Cvâ€²
1 Ã— Â· Â· Â· Ã— Cvâ€²
n â†’Cu. There are two ways to do so.
Firstly, from deï¬nition 2.1.9, functor F of varity v1 . . . vn, that is F is a functor of
Cv1 Ã— Â· Â· Â· Ã— Cvn â†’C, into
F u: (Cv1 Ã— Â· Â· Â· Ã— Cvn)u â†’Cu âˆ¼= Cv1â€¢u Ã— Â· Â· Â· Ã— Cvnâ€¢u â†’Cu
The isomorphism is from proposition 2.1.5 and proposition 2.1.4.
The other way of conversion is using embedding functors and coercing functors into
greater variances (e.g. covariant functor can be a ï¬xed variant functor).
Deï¬nition 2.1.13: If u1 âŠ‘v1, . . . , un âŠ‘vn and F is a functor of varity u1 . . . un, we
can coerce it to a functor of varity v1 . . . vn by
F|v1...vn
u1...un
def
= F â—¦(eu1,v1 Ã— Â· Â· Â· Ã— eun,vn).
Cv1 Ã— Â· Â· Â· Ã— Cvn
eu1,v1 Ã— Â· Â· Â· Ã— eun,vn
Cu1 Ã— Â· Â· Â· Ã— Cun
F
C
?
-
We may write F|v1...vn when u1 . . . un is obvious. []
Let us now deï¬ne the composition of mixed variant functors.
Deï¬nition 2.1.14: Let F be a functor of varity u1 . . . un and G1, . . . , Gn be functors
of varity v11 . . . v1m, . . . , vn1 . . . vnm, respectively. Then we have a functor F[G1, . . . , Gn]

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
23
of varity w1 . . . wm where wi
def
= u1 â€¢ v1i âŠ”Â· Â· Â· âŠ”un â€¢ vni1. The deï¬nition of the functor is
F[G1, . . . , Gn] def
= F â—¦âŸ¨Gu1
1 |w1...wm, . . . , Gun
n |w1...wmâŸ©
Proof of well-deï¬nedness: Gi is a functor of Cvi1 Ã— Â· Â· Â· Ã— Cvim â†’C. Gui
i is a functor
of Cuiâ€¢vi1 Ã— Â· Â· Â· Ã— Cuiâ€¢vim â†’Cui. Since ui â€¢ vi1 âŠ‘w1, . . . , ui â€¢ vim âŠ‘wm, from deï¬ni-
tion 2.1.13 Gui
i |w1...wm is a functor of Cw1 Ã— Â· Â· Â· Ã— Cwm â†’Cui. From proposition 2.1.12
âŸ¨Gu1|w1...wm, . . . , Gun|w1...wmâŸ©is a functor of Cw1Ã—Â· Â· Â·Ã—Cwm â†’Cu1Ã—Â· Â· Â·Ã—Cun. Therefore,
from proposition 2.1.11,
F â—¦âŸ¨Gu1|w1...wm, . . . , Gun|w1...wmâŸ©: Cw1 Ã— Â· Â· Â· Ã— Cwm â†’C
is a functor of varity w1 . . . wm. []
The variances of G1, . . . , Gn are appropriately modiï¬ed according to the varity of F
and then the least upper bound is taken so that we can pair them together.
We need some lemmas to show the associativity of the composition.
Lemma 2.1.15: Let u âŠ‘v and F be a functor of varity w1 . . . wn.
1. For any w, u â€¢ w âŠ‘v â€¢ w and (eu,v)w = euâ€¢w,vâ€¢w.
2. The following diagram commutes.
Cvâ€¢w1 Ã— Â· Â· Â· Ã— Cvâ€¢wn
ew1
u,v Ã— Â· Â· Â· Ã— ewn
u,v
Cuâ€¢w1 Ã— Â· Â· Â· Ã— Cuâ€¢wn
F v
Â¥
Â¨Â§?
F u
Cv
eu,v
Cv
-
-
?
?
In other words, the action of Var on functors is natural with respect to the partial
order âŠ‘.
3. eu,v â—¦F v = F u|w1â€¢v...wnâ€¢v
4. F|u1...un|v1...vn = F|u1âŠ”v1...unâŠ”vn
5. (F â—¦G)u = F u â—¦Gu
6. âŸ¨F1, . . . , FnâŸ©u = âŸ¨F u
1 , . . . , F u
n âŸ©
7. (F|v1...vn)u = F u|v1â€¢u...vnâ€¢u
1Var is a commutative semiring with unit: âŠ”as its addition and â€¢ as its multiplication. If we express
varities as vectors, then varity of F[G1, . . . , Gn] can be computed by the following matrix multiplica-
tion.
(w1, . . . , wm) = (u1, . . . , un)
ï£«
ï£¬
ï£­
v11 . . . v1m
...
...
...
vn1 . . . vnm
ï£¶
ï£·
ï£¸

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
24
Proof: We have to check any pairs of u and v 1 and 2 hold from the deï¬nitions. 3
follows 2. 4, 5 and 6 are easy to show and 7 follows them.
(F|v1...vn)u = (F â—¦(ew1,v1 Ã— Â· Â· Â· Ã— ewn,vn))u
= F u â—¦(ew1,v1 Ã— Â· Â· Â· Ã— ewn,vn)u = F u â—¦((ew1,v1)u Ã— Â· Â· Â· Ã— (ewn,vn)u)
= F u â—¦(ew1â€¢u,v1â€¢u Ã— Â· Â· Â· Ã— ewnâ€¢u,vnâ€¢u) = F u|v1â€¢u...vnâ€¢u
[]
Proposition 2.1.16: Let F, G1, . . . , Gn and H1, . . . , Hm be functors of the following
varities:
F: u1 . . . un
G1: v11 . . . v1m,
. . .
, Gn: vn1 . . . vnm
H1: w11 . . . w1l,
. . .
, Hn: wm1 . . . wml
Then, the following equality between functors holds:
(F[G1, . . . , Gn])[H1, . . . , Hm] = F[G1[H1, . . . , Hm], . . . , Gn[H1, . . . , Hm]].
Proof: Let varity a1 . . . am, b11 . . . b1l, . . . , bn1 . . . bnl and c1 . . . cl be
(a1, . . . , am) def
= (u1, . . . , un)
ï£«
ï£¬
ï£¬
ï£­
v11 . . . v1m
... ...
...
vn1 . . . vnm
ï£¶
ï£·
ï£·
ï£¸,
ï£«
ï£¬
ï£¬
ï£­
b11 . . . b1l
... ... ...
bn1 . . . bnl
ï£¶
ï£·
ï£·
ï£¸
def
=
ï£«
ï£¬
ï£¬
ï£­
v11 . . . v1m
... ...
...
vn1 . . . vnm
ï£¶
ï£·
ï£·
ï£¸
ï£«
ï£¬
ï£¬
ï£­
w11 . . . w1l
...
...
...
wm1 . . . wml
ï£¶
ï£·
ï£·
ï£¸,
and
(c1, . . . , cl) def
= (u1, . . . , un)
ï£«
ï£¬
ï£¬
ï£­
v11 . . . v1m
... ...
...
vn1 . . . vnm
ï£¶
ï£·
ï£·
ï£¸
ï£«
ï£¬
ï£¬
ï£­
w11 . . . w1l
...
...
...
wm1 . . . wml
ï£¶
ï£·
ï£·
ï£¸.
Then,
(F[G1, . . . , Gn])[H1, . . . , Hm]
= F â—¦âŸ¨Gu1
1 |a1...am, . . . , Gun
n |a1...amâŸ©â—¦âŸ¨Ha1
1 |c1...cl, . . . , Ham
m |c1...clâŸ©
= F â—¦âŸ¨Gu1
1 |a1...am â—¦âŸ¨Ha1
1 |c1...cl, . . .âŸ©, . . .âŸ©
= F â—¦âŸ¨Gu1
1 â—¦(ev11â€¢u1,a1 Ã— Â· Â· Â· Ã— ev1mâ€¢u1,am) â—¦âŸ¨Ha1
1 |c1...cl, . . .âŸ©, . . .âŸ©
= F â—¦âŸ¨Gu1
1 â—¦âŸ¨ev11â€¢u1,a1 â—¦Ha1
1 |c1...cl, . . .âŸ©, . . .âŸ©
= F â—¦âŸ¨Gu1
1 â—¦âŸ¨Hv11â€¢u1|w11â€¢v1â€¢u1...w1lâ€¢v1â€¢u1|c1...cl, . . .âŸ©, . . .âŸ©
= F â—¦âŸ¨Gu1
1 â—¦âŸ¨Hv11â€¢u1|c1...cl, . . .âŸ©, . . .âŸ©
whereas
F[G1[H1, . . . , Hm], . . . , Gn[H1, . . . , Hm]]
= F â—¦âŸ¨(G1 â—¦âŸ¨Hv11
1 |b11...b1l, . . . , Hv1m
m |b11...b1lâŸ©)u1|c1...cl, . . .âŸ©
= F â—¦âŸ¨Gu1
1 â—¦âŸ¨Hv11â€¢u1
1
|b11â€¢u1...b1lâ€¢u1|c1...cl, . . .âŸ©, . . .âŸ©
= F â—¦âŸ¨Gu1
1 â—¦âŸ¨Hv11â€¢u1
1
|c1...cl, . . .âŸ©, . . .âŸ©
Therefore, the proposition holds. []

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
25
Mixed variant functors form an algebraic theory but with an extra structure. Mixed
variant functors are functions between four sorts, +, âˆ’, âŠ¥and âŠ¤.
Finally, we can show what functorial expressions like H(G(X, Y ), F(X)) mean. Let Î“
be a Varâˆ—-indexed set of primitive functor names2. Then, we deï¬ne
FE(Î“) def
= the set of terms constructed from Î“ and variables like term al-
gebras.
CFE(Î“) def
= { Î»(X1, . . . , Xn).E | E âˆˆFE(Î“) and X1, . . . , Xn includes all the
variables in E }
We call elements of FE(Î“) functorial expressions over Î“ and call elements of CFE(Î“)
closed functorial expressions over Î“. As we can convert any lambda closed term in a
term algebra to a morphism in the corresponding algebraic theory, we can convert any
closed functorial expression into functors. Let Î¾ be an assignment of functor symbols
in Î“v1...vn to real functors of varity v1 . . . vn in C, that is, Î¾ is a Varâˆ—-indexed function
such that
Î¾v1...vn: Î“v1...vn â†’Funct(Cv1 Ã— Â· Â· Â· Ã— Cvn, C)
where Funct(D, E) is the category of functors from D to E. We may write Î¾F for
Î¾v1...vn(F). We can extend assignment Î¾ to that over CFE(Î“) as follows
Î¾(Î»(X1, . . . , Xn).E) def
= Î¾X1,...,Xn(E)
where Î¾X1,...,Xn assigns expressions in FE(Î“) which have X1, . . . , Xn as variables to
functors of n variables and is deï¬ned by
Î¾X1,...,Xn(Xi) def
= Î n
i : CâŠ¥Ã— Â· Â· Â· C+ Ã— Â· Â· Â· CâŠ¥â†’C
Î¾X1,...,Xn(F(E1, . . . , En)) def
= Î¾F[Î¾X1,...,Xn(E1), . . . , Î¾X1,...,Xn(En)]
where Î n
i is the ith projection of the n fold product of C.
Example 2.1.17: Let Î“ consist of a unary functor symbol F which is covariant, a
functor symbol G of varity ++ and a functor symbol H of varity âˆ’+. Let Î¾ be an
assignment of Î“. Then, Î»(X, Y ).H(G(X, Y ), F(X)) denotes the following functor by
Î¾.
Î¾(Î»(X, Y ).H(G(X, Y ), F(X))) = Î¾H[Î¾G[Î 2
1, Î 2
2], Î¾F[Î 2
1]]
The varity of Î 2
1 is +âŠ¥, that of Î¾F is + and, therefore, from deï¬nition 2.1.14, Î¾F[Î 2
1]
has varity +âŠ¥. The varity of Î 2
1 is +âŠ¥, that of Î 2
2 is âŠ¥+, that of Î¾G is ++ and from
deï¬nition 2.1.14 the varity of Î¾G[Î 2
1, Î 2
2] is
(+, +)
Ãƒ
+ âŠ¥
âŠ¥+
!
= (+ â€¢ + âŠ”+ â€¢ âŠ¥, + â€¢ âŠ¥âŠ”+ â€¢ +) = (+ âŠ”âŠ¥, âŠ¥âŠ”+) = (+, +)
Finally, the varity of the whole functor is
(âˆ’, +)
Ãƒ
+ +
+ âŠ¥
!
= (âˆ’â€¢ + âŠ”+ â€¢ +, âˆ’â€¢ + âŠ”+ â€¢ âŠ¥) = (âˆ’âŠ”+, âˆ’âŠ”âŠ¥) = (âŠ¤, âˆ’),
so it is ï¬xed-variant in X and contravariant in Y . []
2From now on, we distinguish names (or symbols) from what they denote.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
26
The last proposition in this section is to establish the relationship between the syn-
tactic substitution of functorial expressions and the composition of functors deï¬ned in
deï¬nition 2.1.14.
Proposition 2.1.18: Let
Î»(X1, . . . , Xn).E
and
Î»(Y1, . . . , Ym).E1, . . . , Î»(Y1, . . . , Ym).En
be closed functorial expressions. Then,
Î¾(Î»(X1, . . . , Xn).E)[Î¾(Î»(Y1, . . . , Ym).E1), . . . , Î¾(Î»(Y1, . . . , Ym).En)]
= Î¾(Î»(Y1, . . . , Ym).E[E1/X1, . . . , En/Xn])
where E[E1/X1, . . . , En/Xn] is E in which X1, . . . , Xn are replaced by E1, . . . , En,
respectively.
Proof: We can easily prove it by structural induction on E using proposition 2.1.16 []
From this correspondence, for closed functorial expression K of n variables and L1, . . . , Ln
of m variables, we write
K[L1, . . . , Ln]
for a closed functorial expression of m variables which is obtained by replacing n
variables in K by L1, . . . , Ln. Then, the proposition is
Î¾(K[L1, . . . , Ln]) = Î¾K[Î¾L1, . . . , Î¾Ln].
2.2
Signatures of Categorical Speciï¬cation
Language
A speciï¬cation normally consists of a signature, which says what kind of sorts there
are and what kinds of operations there are, and a set of sentences (or equations), which
give properties of the operations. A speciï¬cation deï¬nes a class of models which have
what the signature says and satisï¬es the sentences. Therefore, in order to deï¬ne a
speciï¬cation language, we have to deï¬ne what its signatures are, what its sentences
are and what its models are. However, it is often convenient to deï¬ne, ï¬rst, models
without being constrained by sentences and, then, deï¬ne a satisfaction relation between
a statement and a model determining whether the statement is true in the model or
not. A model which satisï¬es all the sentences is called a theory model. See institutions
[Goguen and Burstall 83] for a categorical abstract deï¬nition of what speciï¬cation
languages are.
A CSL signature will be divided into three parts; in the ï¬rst part, we will declare some
names for functors, which will serve as parameterized data types (or data type con-
structors); in the second part, we will declare some names for natural transformations,
which will serve as polymorphic functions over the parameterized data types; and in
the third part, we will declare some names for factorizers (or mediating morphisms),
which will be necessary to put initial or ï¬nal constrains on the data types.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
27
The ï¬rst part can be presented as a Varâˆ—-indexed set Î“. F in Î“v1...vn is said to have
varity v1 . . . vn. We may write F(v1, . . . , vn) to indicate this.
Î“ looks almost like an equational signature for algebraic speciï¬cation languages. It
is as if Var were the set of sorts and Î“ were a set of operations over the sorts. The
only diï¬€erence is that Î“ is not a Varâˆ—Ã—Var-indexed set but simply a Varâˆ—-indexed set.
This is because we can apply Var to functors to get other functors as we explained in
deï¬nition 2.1.9, so it is suï¬ƒcient to give Î“ as a Varâˆ—-indexed set.
Note that Î“ is one sorted.
Each signature describes only one category.
However,
because we are dealing with one level higher objects, it has the power to describe more
than one data type (or sort) inside one signature. We will illustrate this later in this
section.
In the second part, a CSL signature introduces some symbols for natural transforma-
tions. Normally, a natural transformation is deï¬ned as follows: given two functors
F, G: C â†’D, a natural transformation Î±: F
Â·â†’G is a function which assigns to each
A âˆˆ|C| a morphism Î±A: F(A) â†’G(A) such that for any morphism f: A â†’B in C the
following diagram commutes.
F(A)
Î±A
G(A)
-
F(f)
Â¥
Â¨Â§?
G(f)
?
?
F(B)
Î±B
-G(B)
As we have seen in section 2.1, closed functorial expressions provide more complicated
functors constructed from primitive functors in Î“. Let Î› be CFE(Î“). We index the set
of natural transformations by two closed functorial expressions, that is, the second part
of a CSL signature is given by a Î›Ã—Î›-indexed set âˆ†; Î± âˆˆâˆ†K,L will denote a natural
transformation Î¾K
Â·â†’Î¾L, where Î¾K and Î¾L will be the denotations of K and L,
respectively. We may write Î±: K
Â·â†’L to indicate this. Since a natural transformation
should go between functors of the same number of variables, âˆ†K,L should be empty
when K and L have diï¬€erent number of variables. Even if they have the same number
of variables, their variances may be diï¬€erent. In that case, we take the least upper
bound of two variances.
The third and the ï¬nal part of a CSL signature introduces symbols for factorizers (or
mediating morphisms). In general, a factorizer is an isomorphism associated with an
adjunction. If F 7âˆ’G where F: C â†’D and G: D â†’C, the factorizer Ïˆ gives the
following natural isomorphism between hom sets.
Ïˆ: HomD(F(A), B)
âˆ¼
=
âˆ’â†’HomC(A, G(B))
For example, the factorizer associated with the binary product functor â€˜prodâ€™ (: CÃ—C â†’
C) is â€˜pairâ€™ which gives for any two morphisms f: C â†’A and g: C â†’B a morphism

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
28
pair(f, g): C â†’prod(A, B). We can write this situation as the following rule.
C
f
âˆ’â†’A
C
g
âˆ’â†’B
C
pair(f,g)
âˆ’âˆ’âˆ’âˆ’âˆ’â†’prod(A, B)
In CSL, factorizers are given by a (Î›Ã—Î›)âˆ—Ã—(Î›Ã—Î›)-indexed set Î¨ (Î› = CFE(Î“)). The
index (Î›Ã—Î›)âˆ—speciï¬es the type of morphisms to which a factorizer can be applied and
the index Î›Ã—Î› speciï¬es the type of morphisms obtained by applying the factorizer. For
Ïˆ âˆˆÎ¨âŸ¨K1,L1âŸ©...âŸ¨Km,LmâŸ©,âŸ¨K,LâŸ©,
we may write it as the following rule.
f1: K1 â†’L1
. . .
fm: Km â†’Lm
Ïˆ(f1, . . . , fm): K â†’L
where f1, . . . , fn are auxiliary names of morphisms introduced for this rule. As we have
restricted the indexed set âˆ†, Î¨ should be indexed by functors of the same number of
variables, and also we take the least upper bound of the variances and regard it as the
overall variance.
Hence, we come to the deï¬nition of CSL signatures.
Deï¬nition 2.2.1: A CSL signature is a triple âŸ¨Î“, âˆ†, Î¨âŸ©, where Î“ is a Varâˆ—-indexed
set, âˆ†is a Î›Ã—Î›-indexed set (where Î› = CFE(Î“)) for natural transformations and Î¨
is a (Î›Ã—Î›)âˆ—Ã—(Î›Ã—Î›)-indexed set for factorizers. As a restriction to the triple, âˆ†K,L should
be empty if K and L has the diï¬€erent number of variables and Î¨âŸ¨âŸ¨K1,L1âŸ©...âŸ¨Km,LmâŸ©,âŸ¨K,LâŸ©âŸ©
should also be empty if Ki, Li, K and L do not have the same number of variables. []
As an example, we will give a CSL signature for cartesian closed categories.
Example 2.2.2: A cartesian closed category can be characterized as a category having
three special functors: terminal object â€˜1â€™ (which is a constant functor), binary product
â€˜prodâ€™ and exponential â€˜expâ€™. Therefore,
Î“() = {1},
Î“++ = {prod},
Î“âˆ’+ = {exp},
where â€˜()â€™ denotes the empty string in Varâˆ—. The rest of Î“s are empty. We sometimes
write the index set Î“ as
{1, prod(+, +), exp(âˆ’, +)}.
The product functor â€˜prodâ€™ is associated with two natural transformations which give
projection morphisms.
Ï€1: Î»(X, Y ).prod(X, Y )
Â·â†’Î»(X, Y ).X
Ï€2: Î»(X, Y ).prod(X, Y )
Â·â†’Î»(X, Y ).Y
If there is no ambiguity, we may write them by listing their components as follows:
Ï€1A,B: prod(A, B) â†’A
Ï€2A,B: prod(A, B) â†’B

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
29
Functors (Î“)
1
prod(+, +)
exp(âˆ’, +)
Natural Transformations (âˆ†)
Ï€1: prod(A, B) â†’A
Ï€2: prod(A, B) â†’B
ev: prod(exp(A, B), A) â†’B
Factorizers (Î¨)
!: A â†’1
f: C â†’A
g: C â†’B
pair(f, g): C â†’prod(A, B)
h: prod(C, A) â†’B
curry(h): C â†’exp(A, B)
Figure 2.1: CSL Signature for Cartesian Closed Categories
We might even omit subscripts from Ï€1A,B and Ï€2A,B. The exponential functor â€˜expâ€™ is
associated with one natural transformation which gives evaluation morphisms.
ev: Î»(X, Y ).prod(exp(X, Y ), X)
Â·â†’Î»(X, Y ).Y
Note that the variance of these two functors is âŠ¤+. Therefore, âˆ†is
âˆ†Î»(X,Y ).prod(X,Y ),Î»(X,Y ).X
= {Ï€1}
âˆ†Î»(X,Y ).prod(X,Y ),Î»(X,Y ).Y
= {Ï€2}
âˆ†Î»(X,Y ).prod(exp(X,Y ),X),Î»(X,Y ).Y = {ev}
For any other combinations of closed functorial expression K and L, âˆ†K,L is empty.
Finally, there are three factorizers for the three functors: â€˜!â€™ for â€˜1â€™, â€˜pairâ€™ for â€˜prodâ€™
and â€˜curryâ€™ for â€˜expâ€™.
!: Î»(X).X â†’Î»(X).1
f: Î»(X, Y, Z).Z â†’Î»(X, Y, Z).X
g: Î»(X, Y, Z).Z â†’Î»(X, Y, Z).Y
pair(f, g): Î»(X, Y, Z).Z â†’Î»(X, Y, Z).prod(X, Y )
h: Î»(X, Y, Z).prod(Z, X) â†’Î»(X, Y, Z).Y
curry(h): Î»(X, Y, Z).Z â†’Î»(X, Y, Z).exp(X, Y )
If there is no ambiguity, we might write these rules down as in ï¬gure 2.1, where we
summarize the deï¬nition of the CSL signature for cartesian closed categories. We will
omit the tedious formal deï¬nition of Î¨ as an indexed set. []
As we mentioned earlier, a CSL signature is one sorted, but because it handles higher
objects, it is no less powerful than a many sorted equational signature. Let us demon-
strate this. An equational signature is given by a pair âŸ¨S, Î£âŸ©where S is a set (of sort
names) and Î£ is an Sâˆ—Ã—S-indexed set (of operator names). We will translate it to a
corresponding CSL signature âŸ¨Î“, âˆ†, Î¨âŸ©. Since functors play a role of sorts, we declare
a constant functor for each sort in S.
Î“() = S,

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
30
and we have a binary product functor to deal with sequences of sorts,3 and the terminal
object for constants.
Î“++ = { prod }
and
Î“() = { 1 }
Operations will be translated to natural transformations:
for each operation o âˆˆ
Î£s1...sn,s, we have a natural transformation of the same name.
o: prod(s1, prod(. . . , prod(snâˆ’1, sn))) â†’s
that is,
âˆ†Î»().prod(s1,prod(...,prod(snâˆ’1,sn))),Î»().s = Î£s1...sn,s
We also have two projections for â€˜prodâ€™ in âˆ†and Î¨ has only one factorizer â€˜pairâ€™ for
pairing. It is easy to see that the CSL signature âŸ¨Î“, âˆ†, Î¨âŸ©corresponds to the equational
signature âŸ¨S, Î£âŸ©.
Proposition 2.2.3: A many-sorted equational signature can be represented by a CSL
signature. []
It is interesting to know that we represented a many-sorted equational signature by a
category with products because an algebraic theory can exactly be given as a category
with products [Lawvere 63].
Let us make CSL signatures form a category by extending a pre-CSL signature mor-
phism in a natural way. Intuitively, a signature morphism (not only in CSL but in
general) does some renamings of symbols and/or some mergings of symbols.
Deï¬nition 2.2.4: A CSL signature morphism Ïƒ from a CSL signature âŸ¨Î“, âˆ†, Î¨âŸ©to a
CSL signature âŸ¨Î“â€², âˆ†â€², Î¨â€²âŸ©is a triple âŸ¨Ïƒâ€², Ïƒâ€²â€², Ïƒâ€²â€²â€²âŸ©consisting of
1. a Varâˆ—-indexed function Ïƒâ€²
v1...vn: Î“v1...vn â†’Î“â€²
v1...vn for mapping functor names,
2. a Î›Ã—Î›-indexed function (where Î› = CFE(Î“)) Ïƒâ€²â€²
K,L: âˆ†K,L â†’âˆ†â€²
Ïƒâ€²K,Ïƒâ€²L for mapping
natural transformation names, and
3. a (Î›Ã—Î›)âˆ—Ã—(Î›Ã—Î›)-indexed function
Ïƒâ€²â€²â€²
âŸ¨âŸ¨K1,L1âŸ©...âŸ¨Km,LmâŸ©,âŸ¨K,LâŸ©âŸ©:
Î¨âŸ¨âŸ¨K1,L1âŸ©...âŸ¨Km,LmâŸ©,âŸ¨K,LâŸ©âŸ©â†’Î¨â€²
âŸ¨âŸ¨Ïƒâ€²K1,Ïƒâ€²L1âŸ©...âŸ¨Ïƒâ€²Km,Ïƒâ€²LmâŸ©,âŸ¨Ïƒâ€²K,Ïƒâ€²LâŸ©âŸ©
for mapping factorizer names.
We often write ÏƒF for Ïƒâ€²
v1...vn(F), ÏƒÎ± for Ïƒâ€²â€²
K,L(Î±) and ÏƒÏˆ for Ïƒâ€²â€²â€²
âŸ¨âŸ¨K1,L1âŸ©...,âŸ¨K,LâŸ©âŸ©(Ïˆ). []
Deï¬nition 2.2.5: The category of CSL signatures CSig has CSL signatures as its ob-
jects and CSL signature morphisms as its morphisms. The identity morphism on a CSL
signature âŸ¨Î“, âˆ†, Î¨âŸ©consists of the corresponding identity functions for the components
and the composition of CSL morphisms is given by combining the component-wise
compositions as indexed functions. This clearly forms a category. []
3We could have n-ary product functors for all natural numbers as well, but since we can represent them
using a binary one, we only declare the binary one.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
31
2.3
Structures of Categorical Speciï¬cation Lan-
guage
In this section, we will deï¬ne CSL structures. A CSL signature speciï¬es symbols for
functors, natural transformations and factorizers, so intuitively, a CSL structure is a
category associated with these functors, natural transformations and factorizers.
Deï¬nition 2.3.1: Given a CSL signature âŸ¨Î“, âˆ†, Î¨âŸ©, a CSL structure âŸ¨C, Î¾âŸ©is a small
category C together with an assignment Î¾
1. Î¾ assigns each functor name of varity v1 . . . vn to a functor Cv1 Ã— Â· Â· Â· Ã— Cvn â†’C.4
As we have seen in section 2.1, Î¾ can be extended to the assignment of closed
functorial expressions to functors.
2. Î¾ assigns each natural transformation name Î± âˆˆâˆ†K,L, where K and L are closed
functorial expressions of n variables, to a set of C morphisms
Î¾Î±A1,...,An: Î¾K(A1, . . . , An) â†’Î¾L(A1, . . . , An)
for arbitrary C objects A1, . . . , An.5
3. Each factorizer symbol Ïˆ âˆˆÎ¨âŸ¨âŸ¨K1,L1âŸ©...,âŸ¨K,LâŸ©âŸ©, where K1, L1,. . . , Km, Lm, K, L are
closed functorial expressions of n variables, is assigned to a set of Set functions
Î¾ÏˆA1,...,An:
m
Y
i=1
HomC(Î¾Ki(A1, . . . , An), Î¾Li(A1, . . . , An))
â†’HomC(Î¾K(A1, . . . , An), Î¾L(A1, . . . , An))
for arbitrary C objects A1, . . . , An. []
Note that we do not assign a natural transformation symbol to a natural transfor-
mation, but it is mapped to a set of morphisms and whether they form a natural
transformation or not is left to be stated by equations.
Example 2.3.2: Let âŸ¨Î“, âˆ†, Î¨âŸ©be the CSL signature for cartesian closed categories
deï¬ned in example 2.2.2. Then, any cartesian closed category is a CSL structure of
this signature by obvious assignment of the symbols to the functors, natural transfor-
mations and factorizers. However, the converse is not true. We can have a category
4We could say Î¾ is a Var
âˆ—-indexed function
Î¾v1...vn: Î“v1...vn â†’Funct(Cv1 Ã— Â· Â· Â· Ã— Cvn, C).
5We could express it as a Î›Ã—Î›-indexed function (where Î› = CFE(Î“))
Î¾K,L: âˆ†K,L â†’Nat(Î¾K|âŠ¤...âŠ¤, Î¾L|âŠ¤...âŠ¤).

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
32
which has three functors, three natural-transformation-look-alikes and three factorizer-
look-alikes. CSL structures do not require mapping natural transformation symbols
to natural transformations but only to a set of morphisms, nor do they require map-
ping factorizer symbols to factorizers. The factorizer-look-alikes may not give unique
morphisms or may not commute some diagrams. []
CSL structure morphisms are deï¬ned simply as a kind of homomorphisms. They keep
the structure nicely.
Deï¬nition 2.3.3: Given a CSL signature âŸ¨Î“, âˆ†, Î¨âŸ©, a CSL structure morphism from
a CSL structure âŸ¨C, Î¾âŸ©to another âŸ¨D, Î¶âŸ©is a covariant functor T: C â†’D such that
1. for any F in Î“v1...vn
T â—¦Î¾F = Î¶F â—¦(T v1 Ã— Â· Â· Â· Ã— T vn)
holds,
Cv1 Ã— Â· Â· Â· Ã— Cvn
T v1 Ã— Â· Â· Â· Ã— T vn
Dv1 Ã— Â· Â· Â· Ã— Dvn
Î¾F
Â¥
Â¨Â§?
Î¶F
C
D
?
-
- ?
2. for any Î± âˆˆâˆ†K,L and for any C objects A1, . . . , An
T(Î¾Î±A1,...,An) = Î¶Î±T(A1),...,T(An),
and
3. for any Ïˆ âˆˆÎ¨âŸ¨K1,L1âŸ©...âŸ¨Km,LmâŸ©,âŸ¨K,LâŸ©, for any C objects A1, . . . , An and for any C
morphisms fi: Î¾Ki(A1, . . . , An) â†’Î¾Li(A1, . . . , An) (i = 1, . . . , m),
T(Î¾ÏˆA1,...,An(f1, . . . , fm)) = Î¶ÏˆT(A1),...,T(An)(T(f1), . . . , T(fm)). []
Hence, the category of CSL structures is:
Deï¬nition 2.3.4: For a CSL signature âŸ¨Î“, âˆ†, Î¨âŸ©, the category of CSL structures,
CMod(âŸ¨Î“, âˆ†, Î¨âŸ©), has CSL structures as objects and CSL structure morphisms as
morphisms; the identity morphism on âŸ¨C, Î¾âŸ©is the identity functor IC and the compo-
sition of morphisms is the composition of their underlying functors. []
2.4
Functorial Calculus (revisit)
In section 2.1 we saw functorial expressions denote functors. In this section we will see
an expression involving natural transformation symbols and factorizer symbols denote

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
33
a set of morphisms.6 For example, under the signature of cartesian closed categories
given in example 2.2.2, what should the following expression denote?
Ï€1 â—¦prod(curry(Ï€2), I)
We even have a problem for expressions like Ï€1â—¦Ï€2 because Ï€1 and Ï€2 are not projections
of the same product: Ï€2 is of prod(A, prod(B, C)) and Ï€1 is of prod(B, C). Actually,
natural transformations are polymorphic like ML functions are.7
As we deï¬ned in
deï¬nition 2.3.1, Ï€1 denotes a set of morphisms.
Î¾Ï€1A,B: Î¾prod(A, B) â†’A
We have to ï¬gure out for each occurrence of Ï€1 what A and B are.
Deï¬nition 2.4.1: For a CSL signature âŸ¨Î“, âˆ†, Î¨âŸ©, we have a set Exp(Î“, âˆ†, Î¨) of CSL
expressions deï¬ned by the following BNF.
e : : = I | e1 â—¦e2 | Î± | Ïˆ(e1, . . . , em) | F(e1, . . . , en) | f
where Î± âˆˆâˆ†, Ïˆ âˆˆÎ¨ and f is a variable for morphisms.
We also have a set
AExp(Î“, âˆ†, Î¨) of CSL annotated expressions deï¬ned by the following BNF.
e : : = I[K] | e1 â—¦e2 | Î±[K1, . . . , Kn] | Ïˆ[K1, . . . , Kn](e1, . . . , em) |
F(e1, . . . , en) | f
where K1, . . . , Kn are closed functorial expressions over Î“. []
It is trivial to see that for each annotated expression there is a corresponding expres-
sion (i.e. forgetting all the annotations, [. . .]), which we call skeleton of the annotated
expression. We are going to type-check an expression ï¬rst and, then, we determine its
denotation. Annotated expressions are used to remember the type-checking informa-
tion inside expressions. We will give the typing rules for annotated expressions and
show that every expression has the most general annotated expression and we take the
type of this annotated expression as the type of the expression.
First, we deï¬ne the notion of uniï¬cation.
Deï¬nition 2.4.2: A closed functorial expression K of n variables is said to be more
general than a closed functorial expression Kâ€² of m variables if there are closed func-
torial expressions K1, . . . , Kn of m variables such that
K[K1, . . . , Kn] â‰¡Kâ€²
6Some may want it to denote a natural transformation, but the treatment of factorizers seems very
complicated to do so.
7Conversely, ML polymorphic functions are natural transformations. The author has not yet seen the
deï¬nite statement of this, but it is a folklore among computer scientists dealing with category theory.
This fact is rarely used in practice, but it sometimes helps to understand the behaviour of polymorphic
functions. For example, any ML function f of type Î±list â†’int should never depend on elements in
the list but only to the length of list. As another example, if f is of type Î±list â†’Î±list and if we apply
it to an integer list [1, 4, 3, 5] and get [5, 1, 3], we know the result of applying f to [2, 8, 6, 10] (each
element is doubled) without actually applying it. The result should be [10, 2, 6], i.e. each element of
the result is doubled as well.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
34
where â‰¡is the equivalence relation ignoring variable renaming. (Trivially, K â‰¡Kâ€²
implies Î¾K = Î¾Kâ€².) []
Deï¬nition 2.4.3: Closed functorial expressions K and L are said to be uniï¬able when
there is a closed functorial expression Kâ€² such that Kâ€² is less general than K as well
as L. []
Proposition 2.4.4: If closed functorial expressions K and L are uniï¬able, then there
is a most general uniï¬cation, that is, there exist K1, . . . , Kn and L1, . . . , Lm such that
K[K1, . . . , Kn] â‰¡L[L1, . . . , Lm] and for any Kâ€² which is less general than K and Kâ€²
there are Kâ€²
1, . . . , Kâ€²
l such that Kâ€² â‰¡K[K1, . . . , Kn][Kâ€²
1, . . . , Kâ€²
l].
Proof: Same as ordinary uniï¬cation of terms. []
Let us now deï¬ne the type of annotated expressions.
Deï¬nition 2.4.5: Let âŸ¨Î“, âˆ†, Î¨âŸ©be a CSL signature. An annotated expression e has a
type Ï âŠ¢e: K â†’L when it can be derived from the following rules, where Ï is a given
assignment of each morphism variable to its type and K and L are closed functorial
expressions.
1. For the identity, Ï âŠ¢I[K]: K â†’K.
2. For the composition,
Ï âŠ¢e1: Kâ€² â†’L
Ï âŠ¢e2: K â†’Kâ€²
Ï âŠ¢e1 â—¦e2: K â†’L
.
3. For a natural transformation Î± âˆˆâˆ†K,L, where K and L are of n variables,
Ï âŠ¢Î±[K1, . . . , Kn]: K[K1, . . . , Kn] â†’L[K1, . . . , Kn]
4. For a factorizer Ïˆ âˆˆÎ¨âŸ¨âŸ¨K1,L1âŸ©...âŸ¨Km,LmâŸ©,âŸ¨K,LâŸ©âŸ©, where Ki, Li, K, L are of n variables,
Ï âŠ¢ei: Ki[Kâ€²
1, . . . , Kâ€²
n] â†’Li[Kâ€²
1, . . . , Kâ€²
n]
Ï âŠ¢Ïˆ[Kâ€²
1, . . . , Kâ€²
n](e1, . . . , em): K[Kâ€²
1, . . . , Kâ€²
n] â†’L[Kâ€²
1, . . . , Kâ€²
n]
5. For a functor F âˆˆÎ“v1...vn
Ï âŠ¢ei: Ki
vi
âˆ’â†’Li
Ï âŠ¢F(e1, . . . , en): F[K1, . . . , Kn] â†’F[L1, . . . , Ln]
where ei: Ki
vi
âˆ’â†’Li is ei: Ki â†’Li if vi is + or âŠ¥, ei: Li â†’Ki if vi is âˆ’and
I: Ki â†’Ki if vi is âŠ¤.
6. For a morphism variable f, Ï âŠ¢f: Ï(f). []

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
35
Deï¬nition 2.4.6: We say an annotated expression e is more general than eâ€² if there
exist closed functorial expressions K1, . . . , Kn such that eâ€² â‰¡e[K1, . . . , Kn], where
e[K1, . . . , Kn] is e with all its annotations being composed with K1, . . . , Kn, e.g. Î±[L1, . . . , Lm][K1, .
is Î±[L1[K1, . . . , Kn], . . . , Lm[K1, . . . , Kn]]. []
Proposition 2.4.7: If an annotated expression e has a type Ï âŠ¢e: K â†’L, e[K1, . . . , Kn]
has the following type.
Ï[K1, . . . , Kn] âŠ¢e[K1, . . . , Kn]: K[K1, . . . , Kn] â†’L[K1, . . . , Kn]
where Ï[K1, . . . , Kn](f) is Kâ€²[K1, . . . , Kn] â†’Lâ€²[K1, . . . , Kn] when Ï(f) is Kâ€² â†’Lâ€².
Proof: It can easily proved from deï¬nition 2.4.5 by structural induction on e. []
Proposition 2.4.8: Let e âˆˆExp(Î“, âˆ†, Î¨) be an expression of a CSL signature âŸ¨Î“, âˆ†, Î¨âŸ©.
If there exists an annotated expression eâ€² whose skeleton is e and if it has a type, then
there exists a most general annotated expression which has a type and whose skeleton
is e.
Proof: It can be proved by structural induction on e. Here, we present an algorithm
of calculating a most general annotated expression.
1. If e is I, the most general annotated expression is I[I], where I is the identity
closed functorial expression Î»(X).X.
2. If e is e1 â—¦e2, from induction hypothesis, we have the most general annotated
expressions for e1 and e2.
Ï1 âŠ¢eâ€²
1: K â†’Kâ€²
Ï2 âŠ¢eâ€²
2: L â†’Lâ€²
We unify K with Lâ€² achieving K[K1, . . . , Kn] â‰¡Lâ€²[L1, . . . , Lm]. The most general
annotated expression for e and its type is
Ï âŠ¢eâ€²
1[K1, . . . , Kn] â—¦eâ€²
2[L1, . . . , Lm]: L[L1, . . . , Lm] â†’Kâ€²[K1, . . . , Kn]
where Ï is the result of combining Ï1[K1, . . . , Kn] and Ï2[L1, . . . , Lm].
3. If e is a natural transformation Î± âˆˆâˆ†K,L, the most general annotated expression
and its type is
Ï âŠ¢Î±[Î n
1, . . . , Î n
n]: K â†’L,
where Î n
i is the closed functorial expression Î»(X1, . . . , Xn).Xi.
4. If e is Ïˆ(e1, . . . , em) for a factorizer Ïˆ âˆˆÎ¨âŸ¨âŸ¨K1,L1âŸ©...,âŸ¨K,LâŸ©âŸ©, from induction hypoth-
esis, we have annotated expressions eâ€²
i such that
Ïi âŠ¢eâ€²
i: Kâ€²
i â†’Lâ€²
i.
We unify Kâ€²
i with Ki and Lâ€²
i with Li. If the uniï¬cation is successful, we have the
most general annotated expression for e.
Ï âŠ¢Ïˆ[J1, . . . , Jn](eâ€²
1[Jâ€²
11, . . .], . . . , eâ€²
m[Jâ€²
1m, . . .]):
K[J1, . . . , Jn] â†’L[J1, . . . , Jn]

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
36
where J1, . . . , Jn, Jâ€²
11, . . . are the substitution for Ki and Li obtained from the
uniï¬cation and Ï is the result of combining Ïi[Jâ€²
1i, . . .].
5. If e is F(e1, . . . , en), let the most general annotated expressions for ei be
Ïi âŠ¢eâ€²
i: Ki
vi
âˆ’â†’Li.
Then, the most general annotated expression for e and its type is
Ï âŠ¢F(eâ€²
1, . . . , eâ€²
n): F[K1, . . . , Kn] â†’F[L1, . . . , Ln].
6. If e is a morphism variable f, its most general annotated expression is itself and
has the following type.
Ï âŠ¢f: Î»(X, Y ).X â†’Î»(X, Y ).Y
[]
From this proposition,
Deï¬nition 2.4.9: We deï¬ne the type of an expression e âˆˆExp(Î“, âˆ†, Î¨) to be the
type of the most general annotated expression eâ€² whose skeleton is e. []
Let us ï¬nally deï¬ne the denotation of expressions in Exp(Î“, âˆ†, Î¨) when a CSL struc-
ture âŸ¨C, Î¾âŸ©is given. Since each expression e is associated uniquely to the most general
annotated expression eâ€² by proposition 2.4.8, we can deï¬ne the denotation of e to be
that of eâ€² and deï¬ne the denotation of annotated expressions.
Deï¬nition 2.4.10: Let âŸ¨Î“, âˆ†, Î¨âŸ©be a CSL signature and âŸ¨C, Î¾âŸ©be a CSL structure.
For an annotated expression e âˆˆAExp(Î“, âˆ†, Î¨) of type Ï âŠ¢e: K â†’L (where K and
L are of l variables), we deï¬ne its denotation, Î¾e, to be a set of morphisms
(Î¾e)A1,...,Al: Î¾K(A1, . . . , Al) â†’Î¾L(A1, . . . , An)
for any C objects A1, . . . , Al and for any morphism variable assignment Ï‰ (where
Ï‰(f, A1, . . . , Al) gives a morphism of type Î¾Kâ€²(A1, . . . , Al) â†’Î¾Lâ€²(A1, . . . , Al) when
Ï(f) is Kâ€² â†’Lâ€²).
1. For the identity,
(Î¾I[K])A1,...,Al
def
= IÎ¾K[A1,...,Al]
2. For compositions,
(Î¾e1 â—¦e2)A1,...,Al
def
= (Î¾e1)A1,...,Al â—¦(Î¾e2)A1,...,Al
3. For natural transformations,
(Î¾Î±[K1, . . . , Kn])A1,...,Al
def
= Î¾Î±Î¾K1(A1,...,Al),...,Î¾Kn(A1,...,Al)

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
37
4. For factorizers,
(Î¾Ïˆ[K1, . . . , Kn](e1, . . . , em))A1,...,Al
def
=
ÏˆÎ¾K1(A1,...,Al),...,Î¾Kn(A1,...,Al)((Î¾e1)A1,...,Al, . . . , (Î¾em)A1,...,Al)
5. For functors,
(Î¾F(e1, . . . , en))A1,...,Al
def
= Î¾F((Î¾e1)A1,...,Al, . . . , (Î¾en)A1,...,Al)
6. For morphism variables,
(Î¾f)A1,...,An
def
= Ï‰(f, A1, . . . , Al)
Proof of well-deï¬nedness: We have to show, for example, for a natural transforma-
tion Î± âˆˆâˆ†K,L, (Î¾Î±[K1, . . . , Kn])A1,...,Al is a morphism from
Î¾K[K1, . . . , Kn](A1, . . . , Al)
to
Î¾L[K1, . . . , Kn](A1, . . . , Al).
This holds because from deï¬nition 2.3.1 Î¾Î±Î¾K1(A1,...,Al),...,Î¾Kn(A1,...,Al) is a morphism from
Î¾K(Î¾K1(A1, . . . , Al), . . .)) to Î¾L(Î¾K1(A1, . . . , Al), . . .) and from proposition 2.1.18 it is
from Î¾K[K1, . . . , Kn](A1, . . . , Al) to Î¾L[K1, . . . , Kn](A1, . . . , Al). []
Example 2.4.11: Let âŸ¨Î“, âˆ†, Î¨âŸ©be a CSL signature for cartesian closed categories
presented in example 2.2.2 and âŸ¨C, Î¾âŸ©be a CSL structure of this signature where C is
a cartesian closed category and Î¾ is the standard assignment (i.e. the product symbol
to the product functor and so on). Let us ï¬nd out the denotation of ev â—¦pair(f, Ï€2).
First, we have to ï¬nd out the corresponding most general annotated expression and its
type by the algorithm used to prove proposition 2.4.8.
1. ev â—¦pair(f, Ï€2) is given by composing ev and pair(f, Ï€2), so we need to calculate
the most general annotated expressions for these two sub-expressions ï¬rst.
(a) ev is a natural transformation, and its most general annotated expression is
Ï1 âŠ¢ev[Î 2
1, Î 2
2]: prod[exp, Î 2
1] â†’Î 2
2.
(b) pair(f, Ï€2) is given by applying the factorizer pair to f and Ï€2.
i. â€˜fâ€™ is a morphism variable, its most general annotated expression is
Ï2 âŠ¢f: Î 2
1 â†’Î 2
2.
ii. Ï€2 is a natural transformation, and its most general annotated expres-
sion is
Ï3 âŠ¢Ï€2[Î 2
1, Î 2
1]: prod â†’Î 2
2.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
38
pair has the type
âŸ¨âŸ¨Î 3
3, Î 3
1âŸ©âŸ¨Î 3
3, Î 3
2âŸ©, âŸ¨Î 3
3, prod[Î 3
1, Î 3
2]âŸ©âŸ©
By uniï¬cation, we get the most general annotated expression for pair(f, Ï€2).
Ï4 âŠ¢pair[Î 3
3, Î 3
2, prod[Î 3
1, Î 3
2]](f, Ï€2[Î 3
1, Î 3
2]):
prod[Î 3
1, Î 3
2] â†’prod[Î 3
3, Î 3
2]
where Ï4 maps f to prod[Î 3
1, Î 3
2] â†’Î 3
3.
Unifying prod[Î 3
3, Î 3
2] and prod[exp, Î 2
1], we get the most general annotated ex-
pression for ev â—¦pair(f, Ï€2).
Ï5 âŠ¢ev[Î 3
2, Î 3
3] â—¦pair[exp[Î 3
2, Î 3
3], Î 3
2, prod[Î 3
1, Î 3
2]](f, Ï€2[Î 3
1, Î 3
2])
: prod[Î 3
1, Î 3
2] â†’Î 3
3
where Ï5 maps f to prod[Î 3
1, Î 3
2] â†’exp[Î 3
2, Î 3
3].
From deï¬nition 2.4.10, the denotation of this annotated expression is a set of morphisms
for objects A, B and C and a morphism variable assignment
Ï‰(f, A, B, C): Î¾prod(A, B) â†’Î¾exp(B, C).
1. (Î¾ev[Î 3
2, Î 3
3])A,B,C = Î¾evB,C
2. (Î¾f)A,B,C = Ï‰(f, A, B, C)
3. (Î¾Ï€2[Î 3
1, Î 3
2])A,B,C = Î¾Ï€2A,B
4. (Î¾pair[. . .](f, Ï€2[. . .]))A,B,C =
Î¾pairÎ¾exp(B,C),B,Î¾prod(A,B)(Ï‰(f, A, B, C), Î¾Ï€2A,B)
5. (Î¾ev[. . .] â—¦pair[. . .](f, Ï€2[. . .]))A,B,C =
Î¾evB,C â—¦Î¾pairÎ¾exp(B,C),B,Î¾prod(A,B)(Ï‰(f, A, B, C), Î¾Ï€2A,B)
Therefore, the denotation of ev â—¦pair(f, Ï€2) is
Î¾evB,C â—¦Î¾pairÎ¾exp(B,C),B,Î¾prod(A,B)(Ï‰(f, A, B, C), Î¾Ï€2A,B)
[]
2.5
Sentences and Satisfaction Relation of Cate-
gorical Speciï¬cation Language
In this section, we will ï¬nish deï¬ning the speciï¬cation language CSL at last. First, we
deï¬ne what a CSL sentence is.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
39
Deï¬nition 2.5.1: A CSL conditional equation is a sequence of CSL expression pairs
and a CSL expression pair. We usually write it as
e1 = eâ€²
1 âˆ§. . . âˆ§en = eâ€²
n â‡’e = eâ€²,
or simply e = eâ€² if the preceding sequence is empty. To be typed, it needs to share the
same morphism variable environment, ei and eâ€²
i have to have the same type and e and
eâ€² have to have the same type. We may write the types as follows:
Ï âŠ¢e1 = eâ€²
1: K1 â†’L1 âˆ§. . . âˆ§en = eâ€²
n: Kn â†’Ln â‡’e = eâ€²: K â†’L
We write CEq(Î“, âˆ†, Î¨) for the set of all the CSL conditional equations which can be
typed. []
The CSL conditional equations are the CSL sentences. We now have to deï¬ne the
satisfaction relation for CSL. We have separately deï¬ned what CSL structures are
and what CSL conditional equations are. The satisfaction relation connects these two
together so that we can say a CSL conditional equation holds or not in a particular
CSL structure.
Deï¬nition 2.5.2: Let âŸ¨Î“, âˆ†, Î¨âŸ©be a CSL signature. A CSL structure âŸ¨C, Î¾âŸ©satisï¬es
a CSL conditional equation
e1 = eâ€²
1 âˆ§. . . âˆ§en = eâ€²
n â‡’e = eâ€²
having a type
Ï âŠ¢e1 = eâ€²
1: K1 â†’L1 âˆ§. . . âˆ§en = eâ€²
n: Kn â†’Ln â‡’e = eâ€²: K â†’L,
if and only if for any objects A1, . . . , Al and any morphism variable assignment Ï‰ we
have either
1. a CSL equation ei = eâ€²
i such that (Î¾ei)A1,...,Al Ì¸= (Î¾eâ€²
i)A1,...,Al, or
2. (Î¾e)A1,...,Al = (Î¾eâ€²)A1,...,Al.
We will write
âŸ¨C, Î¾âŸ©|= e1 = eâ€²
1 âˆ§. . . âˆ§en = eâ€²
n â‡’e = eâ€²
when âŸ¨C, Î¾âŸ©satisï¬es this CSL conditional equation. []
We have deï¬ned the speciï¬cation language, CSL: CSL signatures, CSL structures, CSL
conditional equations and CSL satisfaction relation. We could have deï¬ned it as an
institution (see [Goguen and Burstall 83]) by deï¬ning CMod as a contravariant functor
and showing CSL satisfaction condition.
Finally, let us ï¬nish presenting the CSL theory (i.e. a pair of CSL signature and CSL
conditional equations) of cartesian closed categories.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
40
Example 2.5.3: We have presented the signature for cartesian closed categories in ex-
ample 2.2.2 (or ï¬gure 2.1), so all we have to do is to list the CSL conditional equations.
(Note that they are not conditional for this example.)
1.f = !
2.1 = I
3.pair(Ï€1, Ï€2) = I
4.Ï€1 â—¦pair(f, g) = f
5.Ï€2 â—¦pair(f, g) = g
6.pair(f, g) â—¦h = pair(f â—¦h, g â—¦h)
7.prod(f, g) = pair(f â—¦Ï€1, g â—¦Ï€2)
8.curry(ev) = I
9.ev â—¦curry(prod(f, I)) = f
10.curry(f) â—¦g = curry(f â—¦prod(g, I))
11.exp(f, g) = curry(g â—¦eval â—¦prod(f, I))
The naturality of Ï€1, Ï€2 and ev can be derived from these equations. For example, the
naturality of Ï€1 is shown by
Ï€1 â—¦prod(f, g) = Ï€1 â—¦pair(f â—¦Ï€1, g â—¦Ï€2) = f â—¦Ï€1.
[]
2.6
Free Categories
One of the major advantages of algebraic speciï¬cation methods using equations or
conditional equations over other speciï¬cation methods is that any theory has an initial
model (i.e. the initial object in the category of models which satisfy the theory). This
also holds for CSL, and in this section, we will construct an initial structure for a CSL
theory. Remember that a CSL structure is a pair of a category and an interpretation.
The category of an initial CSL structure corresponds to a so-called free category.
Given a CSL signature âŸ¨Î“, âˆ†, Î¨âŸ©and a set Î˜ of CSL conditional equations, we are
going to deï¬ne a special category C and an interpretation Î¾. For simplicity, we assume
that Î“ does not contain any free-variant functors. (We can always get such a signature
by discarding free-variant arguments. This does not aï¬€ect its semantics at all.)
Deï¬nition 2.6.1: We say that a closed functorial expression is ground if it has no
variables, that is, its basic form is Î»().E. We take ground closed functorial expressions
as the objects of C. []
The deï¬nition of morphisms of C is a little bit more complicated, so we deï¬ne them
step by step.
Deï¬nition 2.6.2: A ground annotated expression is an annotated expression such
that

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
41
1. all the annotation, [K1, . . . , Kn] consists of ground closed functorial expressions,
and
2. it does not contain any morphism variables. []
Proposition 2.6.3: If a ground annotated expression e has a type Ï âŠ¢e: K â†’L, and
both K and L are ground functorial expressions.
Proof: We can easily prove it from deï¬nition 2.4.5 by structural induction. []
The following will give us the basis of the morphisms in C.
Deï¬nition 2.6.4: For ground closed functorial expressions K and L, we deï¬ne
GExp(K, L) def
= { e | e is ground and âˆ…âŠ¢e: K â†’L } []
To make GExp proper morphisms, we introduce a family of equivalence relations â‰¡
indexed by a pair of ground functorial expressions. Each â‰¡K,L is an equivalence relation
on GExp(K, L).
Deï¬nition 2.6.5: We deï¬ne â‰¡to be the smallest relation satisfying the following
conditions. (In the following, to simplify the presentation, we omit indexes of â‰¡if
there is no ambiguity.)
1. â‰¡is an equivalence relation, that is, reï¬‚exive, symmetric and transitive.
2. If e1 â‰¡K,L eâ€²
1 and e2 â‰¡Kâ€²,K eâ€²
2, then e1 â—¦e2 â‰¡Kâ€²,L eâ€²
1 â—¦eâ€²
2.
3. If e âˆˆGExp(K, L), then I[L] â—¦e â‰¡e and e â—¦I[K] â‰¡e.
4. For a functor symbol F âˆˆÎ“v1...vn, if e1 â‰¡eâ€²
1, . . . and en â‰¡eâ€²
n, then F(e1, . . . , en) â‰¡
F(eâ€²
1, . . . , eâ€²
n).
5. For a factorizer symbol Ïˆ âˆˆÎ¨âŸ¨âŸ¨Kâ€²
1,Lâ€²
1âŸ©...âŸ¨Kâ€²
l,Lâ€²
lâŸ©,âŸ¨Kâ€²,Lâ€²âŸ©âŸ©and ground functorial expres-
sions K1, . . . , Kn, if e1 â‰¡eâ€²
1, . . . and el â‰¡eâ€²
l, then
Ïˆ[K1, . . . , Kn](e1, . . . , el) â‰¡Ïˆ[K1, . . . , Kn](eâ€²
1, . . . , eâ€²
l).
6. Finally, for a conditional CSL equation e1 = eâ€²
1 âˆ§. . . âˆ§en = eâ€²
n â‡’e = eâ€² âˆˆÎ˜
whose type is
Ï âŠ¢e1 = eâ€²
1: Kâ€²
1 â†’Lâ€²
1 âˆ§. . . âˆ§en = eâ€²
n: Kâ€²
n â†’Lâ€²
n â‡’e = eâ€²: Kâ€² â†’Lâ€²
with Ï(fi) is Kâ€²â€²
i â†’Lâ€²â€²
i , ground functorial expressions K1, . . . , Km, and ground
annotated expressions
eâ€²â€²
i âˆˆGExp(Kâ€²â€²
i [K1, . . . , Km], Lâ€²â€²
i [K1, . . . , Km]),
if for all j = 1, . . . , n
(ej[K1, . . . , Km])[eâ€²â€²
1, . . . , eâ€²â€²
l /f1, . . . , fl] â‰¡
(eâ€²
j[K1, . . . , Km])[eâ€²â€²
1, . . . , eâ€²â€²
l /f1, . . . , fl],

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
42
then
(e[K1, . . . , Km])[eâ€²â€²
1, . . . , eâ€²â€²
l /f1, . . . , fl] â‰¡
(eâ€²[K1, . . . , Km])[eâ€²â€²
1, . . . , eâ€²â€²
l /f1, . . . , fl]. []
We can now deï¬ne the morphisms of C.
Deï¬nition 2.6.1 (continued): The C morphisms from K to L are the equivalence
classes of GExp(K, L) by â‰¡K,L, or simply,
HomC(K, L) def
= GExp(K, L)/â‰¡K,L.
We write âŸ¨eâŸ©for the equivalence class to which e belongs. []
Proposition 2.6.6: C is a category.
Proof: The identity morphism of a C object K is given by âŸ¨I[K]âŸ©. The composition
of âŸ¨eâŸ©: K â†’L and âŸ¨eâ€²âŸ©: Kâ€² â†’K is deï¬ned by
âŸ¨eâŸ©â—¦âŸ¨eâ€²âŸ©def
= âŸ¨e â—¦eâ€²âŸ©.
The composition is trivially associative, and the satisï¬ability of the absorption rules of
the identities is guaranteed by the third condition of the equivalence relation â‰¡deï¬ned
in deï¬nition 2.6.5. []
Let us deï¬ne an interpretation Î¾ so that âŸ¨C, Î¾âŸ©is a CSL structure of the CSL signature
âŸ¨Î“, âˆ†, Î¨âŸ©.
Deï¬nition 2.6.7: The deï¬nition of Î¾ is divided into three.
1. For a functor symbol F âˆˆÎ“v1...vn, Î¾F is a functor Cv1...vn â†’C deï¬ned by
Î¾F(K1, . . . , Kn) def
= F[K1, . . . , Kn)],
and
Î¾F(âŸ¨e1âŸ©, . . . , âŸ¨enâŸ©) def
= âŸ¨F(e1, . . . , en)âŸ©.
2. For a natural transformation symbol Î± âˆˆâˆ†K,L, Î¾Î± is
Î¾Î±K1,...,Kn
def
= âŸ¨Î±[K1, . . . , Kn]âŸ©.
3. Finally, for a factorizer symbol Ïˆ âˆˆÎ¨âŸ¨âŸ¨K1,L1âŸ©...âŸ¨Kn,LnâŸ©,âŸ¨K,LâŸ©âŸ©, Î¾Ïˆ is
Î¾ÏˆKâ€²
1,...,Kâ€²n(âŸ¨e1âŸ©, . . . , âŸ¨enâŸ©) def
= âŸ¨Ïˆ[Kâ€²
1, . . . , Kâ€²
n](e1, . . . , en)âŸ©. []
Proposition 2.6.8: âŸ¨C, Î¾âŸ©is a CSL structure of âŸ¨Î“, âˆ†, Î¨âŸ©. Moreover, it is a theory
structure of the CSL theory given by the set Î˜ of CSL conditional equations.
Proof: The condition 6 in deï¬nition 2.6.5 makes it satisfy the conditional equations. []

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
43
We have constructed a special CSL structure âŸ¨C, Î¾âŸ©, and we will next show that it
is the initial object in the full-subcategory of CMod(âŸ¨Î“, âˆ†, Î¨âŸ©) of all the structures
satisfying Î˜.
Theorem 2.6.9: For any CSL structure satisfying Î˜, there is a unique CSL structure
morphism from âŸ¨C, Î¾âŸ©.
Proof: Let âŸ¨D, Î¶âŸ©be an arbitrary CSL structure satisfying Î˜. Using the denotation
of annotated expressions on this structure (see deï¬nition 2.4.10), we deï¬ne a functor
T from C to D as follows:
T(K) def
= Î¶K
and
T(âŸ¨eâŸ©) def
= Î¶e.
Note that, since K is a ground functorial expression Î¶K is an D object, and that,
since e is a ground annotated expression, Î¶e is a D morphism (it does not need objects
A1, . . . , Am or a morphism variable assignment Ï‰). It is easy to see that T is a (co-
variant) functor (note that we have to show the well-deï¬nedness ï¬rst). It is also not
so diï¬ƒcult to show that T is a CSL structure morphism and that it is the unique one
from âŸ¨C, Î¾âŸ©to âŸ¨D, Î¶âŸ©(simply extending the result on algebraic speciï¬cations). []
The advantage of working in an initial CSL structure is that, if we show that a con-
ditional equation holds in the initial one, then we automatically know that it holds in
any CSL structure. In chapter 4, we will deï¬ne the symbolic computation in categories
and it can be regarded as the computation in free categories.

Chapter 3
Categorical Data Types
In chapter 2, we introduced categorical data types from a point of view of a speciï¬cation
language deï¬ning categories. Although the speciï¬cation language CSL is a rigorous
language, it is rather tedious and categoritians may never deï¬ne categories in that way.
In this chapter, we will give another presentation of categorical data types, which will
be simpler and more intuitive. This is also the way Categorical Data Types originated.
Note that we are not discarding CSL completely and that the semantics of categorical
data types will be given in terms of CSL.
Section 3.1 is an extended introduction to categorical data types. We will investigate
some conventional data types and introduce a new uniform categorical way of deï¬ning
data types.
In section 3.2, we will make this new way into the CDT declaration
mechanism. Section 3.3 will give various examples of CDT declarations. In section 3.4,
CDT declarations will be connected to CSL theories, and ï¬nally in section 3.5 we will
give a construction of CDT data types.
3.1
What are Categorical Data Types?
The need for pairs of two (or more) items of data often arises when we write programs.
It is often the case that a function or procedure takes more than one argument and this
means that a pair (or a record) of data needs to be passed to the function or procedure.
In another situation, we may want to declare a new data type whose element is a pair
of elements of other data types. In PASCAL, we can deï¬ne such data types using its
record . . . end construct. For example, intchar whose element is a pair of an integer
and a character can be declared as:
type intchar = record
first: integer;
second: char
end;
In ML, this can be done by
44

CHAPTER 3. CATEGORICAL DATA TYPES
45
type intchar = int * string;
(where since ML does not have a type for representing characters, we have to use
â€˜stringâ€™ type whose element is a sequence of characters). These two languages have
the means of constructing data types of pairs from already-existing data types. Let
us call the constructors product type constructors. Most of the current programming
languages have product type constructors in one way or another as their built-in primi-
tives because they are so essential that we can even say that no programming language
is complete without them.
In order to understand the nature of product type constructors, let us suppose a pro-
gramming language which does not have them as primitives and that we have to deï¬ne
them in terms of others. This might mean that we need in the language some kind
of one level higher operations which can deï¬ne not types but type constructors. Let
us refer to an algebraic speciï¬cation language CLEAR,1 and see its ability to deï¬ne a
product type constructor.
constant Triv =
theory
sort element
endth
procedure Prod(A:Triv,B:Triv) =
theory
data sort prod
opns pair: element of A,element of B -> prod
pi1 : prod -> element of A
pi2 : prod -> element of B
eqns all a:element of A,b:element of B,
pi1(pair(a,b)) = a
all a:element of A,b:element of B,
pi2(pair(a,b)) = b
endth
This deï¬nes an algebra P of three sorts: two â€˜elementâ€™ sorts (let us call them â€˜A-elementâ€™
and â€˜B-elementâ€™ to distinguish them) and a â€˜prodâ€™ sort. The underlying set |P|prod is
the (set) product of two sets |P|Aâˆ’element and |P|Bâˆ’element. The declaration also deï¬nes
three operations (or functions), â€˜pairâ€™, â€˜pi1â€™ and â€˜pi2â€™, satisfying the two equations
listed. Note that the following equation can be proved using induction on â€˜prodâ€™ sort
(we have the induction principle on this sort because of the initial data constraint).
all x: prod, pair(pi1(x),pi2(x)) = x
An algebraic speciï¬cation language like CLEAR is powerful enough to allow us to
deï¬ne all kinds of type constructors (including ordinary data types as constant type
constructors) in a uniform way without having any particular primitives. However,
1CLEAR can be institution independent, but here we refer the one that uses the equational algebraic
institution.

CHAPTER 3. CATEGORICAL DATA TYPES
46
because of its use of equations, we cannot adopt its declaration mechanism in ordinary
programming languages.2 We might be puzzled that we need equations even to deï¬ne
such very basic data types as products.
Let us ï¬nd whether there is any other ways of deï¬ning product type constructors by
examining the foundation, namely mathematics. Modern mathematics uses set theory
extensively because of its power. Set theory does not have a product type constructor
as its primitive construct either, so it is deï¬ned by means of other constructs. For sets
A and B, their (set) product is deï¬ned as:
A Ã— B def
= { (x, y) | x âˆˆA, y âˆˆB }
where (x, y) is really an abbreviation of {{x} {x y}}. Although this looks very simple,
it actually needs some work to show from the axioms of set theory that this is actually
a set. Set theory uses the power of ï¬rst order logic so heavily that it is much harder to
put the set theory formalism into a programming language than to put the algebraic
speciï¬cation formalism. As an example, let Ï†(x) be a ï¬rst order formula. Then, from
the comprehension axiom (or the replacement axiom), we have the set
{ x âˆˆA | Ï†(x) }
where A is a set. Ï†(x) can be anything expressible by ï¬rst order logic (using quantiï¬ers
and negations), and this is too much powerful to investigate the basic property of data
types.
It disï¬gures the beauty behind this powerful deï¬nition mechanism and we
cannot see through it easily.
Set theory has achieved a ï¬rm position as the foundation of mathematics, but there are
some alternatives. Category theory is one of them. It has been proved that category
theory has a remarkable ability to disclose true nature of mathematical objects. For
example, a product constructor (or categorically a functor C Ã— C â†’C) is beautifully
characterized as the right adjoint of the diagonal functor C â†’C Ã— C.3 Expanding the
deï¬nition of adjunctions, this means that we have the following natural isomorphism:
HomC(C, A) Ã— HomC(C, B) â‰ƒHomC(C, prod(A, B))
(âˆ—)
(natural in A, B and C). We use â€˜prodâ€™ for the product functor to follow the notation
we use later. The isomorphic function from the left-hand side to the right-hand side is
the factorizer of this adjunction and we write â€˜pairâ€™ for it. We can rewrite this adjoint
situation as the following rule:
C
f
âˆ’â†’A
C
g
âˆ’â†’B
C
pair(f,g)
âˆ’âˆ’âˆ’âˆ’âˆ’â†’prod(A, B)
(âˆ—âˆ—)
Given two morphisms f: C â†’A and g: C â†’B, pair(f, g) give a morphism of C â†’
prod(A, B). This correspondence is one-to-one and is natural in A, B and C.
2There is a programming language OBJ [Goguen and Tardo 79] which treats equations as a kind of
programs (as rewrite rules).
3There may be more than one right adjoint of the diagonal functor, but they are isomorphic. Therefore,
we say â€˜theâ€™ right adjoint rather than â€˜aâ€™ right adjoint.

CHAPTER 3. CATEGORICAL DATA TYPES
47
Comparing with the product type constructor â€˜Prodâ€™ deï¬ned by CLEAR, we have the
same â€˜pairâ€™ though the previous one takes two elements as the arguments and this one
takes two morphisms instead, and now we can ï¬nd the things corresponding to two
projections â€˜pi1â€™ and â€˜pi2â€™ as well. Replacing C by prod(A, B) in (âˆ—), we get:
HomC(prod(A, B), A) Ã— HomC(prod(A, B), B) â‰ƒ
HomC(prod(A, B), prod(A, B)).
We have a very special morphism in HomC(prod(A, B), prod(A, B)), namely the iden-
tity. Because of the isomorphism, there exist unique morphisms of prod(A, B) â†’A
and prod(A, B) â†’B which are mapped to the identity by â€˜pairâ€™, and these are the
projections. We name them â€˜pi1â€™ and â€˜pi2â€™ as well. Because of the very way they are
deï¬ned, it is trivial that
pair(pi1, pi2) = I.
(+)
Furthermore, from the naturality in C of (âˆ—), we have the rule
C
pair(f,g)
âˆ’âˆ’âˆ’âˆ’âˆ’â†’prod(A, B)
pi1
âˆ’âˆ’â†’A
C
pair(f,g)
âˆ’âˆ’âˆ’âˆ’âˆ’â†’prod(A, B)
pi2
âˆ’âˆ’â†’B
C
pair(f,g)
âˆ’âˆ’âˆ’âˆ’âˆ’â†’prod(A, B)
pair(pi1,pi2)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’prod(A, B)
,
and, if we express it by equations and use (+),
pair(pi1 â—¦pair(f, g), pi2 â—¦pair(f, g)) = pair(pi1, pi2) â—¦pair(f, g) = pair(f, g).
Since â€˜pairâ€™ is isomorphic, we can conclude that the following equations hold:
pi1 â—¦pair(f, g) = f
and
pi2 â—¦pair(f, g) = g.
These are exactly the ones which we listed when deï¬ning â€˜Prodâ€™ in CLEAR. Note that
this time they are derived equations. By saying that â€˜prodâ€™ is the right adjoint to
the diagonal functor, we get these equations automatically. This shows how neat the
categorical deï¬nition is.
Another advantage of categorical deï¬nition is that we can form the dual deï¬nition
easily. We deï¬ned the product functor as the right adjoint of the diagonal functor.
Then, it is natural to ask what is the left adjoint of the diagonal functor. It is the
coproduct functor C Ã— C â†’C. In the category of sets, the copoduct of two sets A and
B is their disjoint sum
A + B def
= { 0 } Ã— A
[
{ 1 } Ã— B.
It is not easy to see in set theory that this is the dual of A Ã— B. In PASCAL, we
can deï¬ne coproducts by means of variant record. In ML, we used to have a built-in
coproduct type constructor â€˜+â€™, but the new Standard ML does not. Instead, â€˜+â€™ can
be deï¬ned by the following â€˜datatypeâ€™ declaration.
datatype â€™a + â€™b = in1 of â€™a | in2 of â€™b;

CHAPTER 3. CATEGORICAL DATA TYPES
48
We cannot deï¬ne the product type constructor by a â€˜datatypeâ€™ declaration in ML, but
we can deï¬ne its dual. ML looks non-symmetric from this. In CLEAR, we can deï¬ne
a coproduct type constructor as follows:
Procedure CoProd(A:Triv,B:Triv) =
theory
data sort coprod
opns in1: element of A -> coprod
in2: element of B -> coprod
endth
Again, this cannot be seen as the dual of â€˜Prodâ€™ we deï¬ned earlier; here we do not
use equations; we have only two operations whereas we had three. This shows that
CLEAR is not symmetric either.
Now, in category theory, the coproduct functor C Ã— C â†’C which we call â€˜coprodâ€™ is
deï¬ned by the dual of (âˆ—), by just changing the direction of arrows.
HomC(A, C) Ã— HomC(B, C) â‰ƒHomC(coprod(A, B), C)
We name the isomorphic function going from the left-hand side to the right-hand side
â€˜caseâ€™ (we could call it â€˜copairâ€™ to emphasize the duality to â€˜pairâ€™, but, since it plays
a role of â€˜caseâ€™ statements of ML or C (or PASCAL), we call it â€˜caseâ€™). Writing the
adjunction as a rule,
A
f
âˆ’â†’C
B
g
âˆ’â†’C
coprod(A, B)
case(f,g)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’C
.
Two injections in1: A â†’coprod(A, B) and in2: B â†’coprod(A, B) are deï¬ned as the
morphisms which â€˜caseâ€™ maps to the identity of coprod(A, B). As before, we can derive
some equations easily.
From what we have looked at, it seems a good idea to design a category theory based
(programming or speciï¬cation) language which has the ability to deï¬ne functors by
means of adjunctions. Since it is convenient to introduce names for unit natural trans-
formations and factorizers at the same time, we regard an adjunction as a triple of a
functor, a unit natural transformation and a factorizer (see, for example, [Mac Lane
71] for many equivalent ways of deï¬ning adjunctions). Therefore, a category theory
based language may have the following two forms of declaring new functors:
let âŸ¨F, Î±, ÏˆâŸ©be right adjoint of G
let âŸ¨F, Î±, ÏˆâŸ©be left adjoint of G
where G is a functor we already have, F is the new functor we are deï¬ning, Î± is the
associated unit natural transformation and Ïˆ is the associated factorizer. One problem
is that we need to have some primitive functors with which we start. We deï¬nitely
need diagonal functors for we want to deï¬ne product and coproduct functors. In order
to deï¬ne the natural number object (which is a constant functor), we need a pretty
complicated functor G. The problem is how to represent such G.

CHAPTER 3. CATEGORICAL DATA TYPES
49
Let us investigate how other languages and theories deï¬ne the data type of natural
numbers. In set theory, it has the axiom of inï¬nity which says the existence of natural
numbers. This may look rather artiï¬cial. In PASCAL, there is no intuitively easy way
to deï¬ne it. In ML, though it is a built-in data type for eï¬ƒciency, we could deï¬ne it
as:
datatype nat = zero | succ of nat;
Note the recursiveness in this deï¬nition. Essentially, we need some kind of recursiveness
to deï¬ne a data type of natural numbers. In CLEAR, one can deï¬ne it as
constant Nat =
theory
data sort nat
opns zero: nat
succ: nat -> nat
endth
This is very much similar to the one in ML, though we often think that the CLEAR
deï¬nition is based on the initial algebra semantics whereas the ML deï¬nition is based
on domain theory. In domain theory, a data type of natural numbers can be deï¬ned
as the solution of the following domain equation
N âˆ¼= 1 + N.
(âˆ—)
The initial solution of (âˆ—) can be calculated as a colimit of a sequence of domains, but
we do not go into its detail here. As a connection to the initial algebra semantics,
the initial solution can be characterized as the initial T-algebra, where T is a functor
T(X) def
= 1 + X in this case. In general, given a category and an endo-functor T, we
can form a category of T-algebras.
Deï¬nition 3.1.1: For a category C and an endo-functor T: C â†’C, the category of
T-algebras is deï¬ned
1. its objects are pairs âŸ¨A, fâŸ©where A is a C object and f is a C morphism T(A) â†’A,
and
2. its morphisms h: âŸ¨A, fâŸ©â†’âŸ¨B, gâŸ©are C morphisms h: A â†’B which make the
following diagram commute.
T(A)
f
A
-
T(h)
Â¥
Â¨Â§?
h
?
?
T(B)
g
- B
Note that this is a weaker version of the category of T-algebras deï¬ned in many category
theory books (e.g. [Mac Lane 71]) where T needs to be a monad. []

CHAPTER 3. CATEGORICAL DATA TYPES
50
We can dualize deï¬nition 3.1.1 to deï¬ne T-coalgebras. However, in the theory of cate-
gorical data types (â€˜CDT theoryâ€™ for short), we combine the two deï¬nitions together.
Deï¬nition 3.1.2: Let C and D be categories and both F and G be functors from C
to D. We deï¬ne an F, G-dialgebra4 as
1. its objects are pairs âŸ¨A, fâŸ©where A is a C object and f is a D morphism of
F(A) â†’G(A), and
2. its morphisms h: âŸ¨A, fâŸ©â†’âŸ¨B, gâŸ©are C morphisms h: A â†’B such that the
following diagram commutes.
F(A)
f
G(A)
-
F(h)
Â¥
Â¨Â§?
G(h)
?
?
F(B)
g
-G(B)
In the case where F or G is contravariant, we have to modify the direction of
some arrows.
It is easy to show that it is a category; let us write DAlg(F, G) for it. Note that
DAlg(T, I) is the category of T-algebras and DAlg(I, T) is the category of T-coalgebras. []
This is a very simple extension of deï¬nition 3.1.1, yet its symmetry and dividing the
source category from the target one give us greater freedom. With T-algebras, we
need to use the coproduct functor to deï¬ne the domain of natural numbers, but by
F, G-dialgebra we do not. Let C be any category and D be its product C Ã— C. We
deï¬ne the functors F and G as
F(A) def
= âŸ¨1, AâŸ©
and
G(A) def
= âŸ¨A, AâŸ©.
Let âŸ¨nat, âŸ¨zero, succâŸ©âŸ©be the initial F, G-dialgebra. From the deï¬nition, â€˜natâ€™ is a C
object, â€˜zeroâ€™ is a C morphism of 1 â†’nat and â€˜succâ€™ is a C morphism of nat â†’nat.
The initiality means that for any DAlg(F, G) object âŸ¨A, âŸ¨f, gâŸ©âŸ©there exists a unique
DAlg(F, G) morphism h: âŸ¨nat, âŸ¨zero, succâŸ©âŸ©â†’âŸ¨A, âŸ¨f, gâŸ©âŸ©. If we spell out the deï¬nition,
this means that for any C object A and any C morphisms f: 1 â†’A and g: A â†’A there
exists a unique C morphism h: nat â†’A which makes the following diagram commute.
1
zero
nat
succ
nat
f
Â¥
Â¨Â§?
h
Â¥
Â¨Â§?
h
A
A
g
-
-
@
@
@
@
@
@
@
@
R
-
?
?
4The name dialgebra was suggested by Bob McKay.

CHAPTER 3. CATEGORICAL DATA TYPES
51
This is exactly the deï¬nition of â€˜natâ€™ being a natural number object in category theory.
To get further generality of F, G-dialgebras, we parametrize F and G.
Deï¬nition 3.1.3: Let C, D and E be categories, and let F: CÃ—D â†’E and G: CÃ—Dâˆ’â†’
E be functors. We deï¬ne âŸ¨Left[F, G](A), Î·AâŸ©for a D object A to be the initial object
in the category DAlg(F( Â· , A), G( Â· , A)). Dually, we deï¬ne âŸ¨Right[F, G](A), ÏµAâŸ©
to be the ï¬nal object. We may write Right(A) for Right[F, G](A) and Left(A) for
Left[F, G](A) if the context makes F and G clear. []
Proposition 3.1.4: If Left[F, G](A) exists for every object A âˆˆ|D|, Left[F, G] de-
notes a functor D â†’C (i.e. we can extend it to D morphisms). Dually, if Right[F, G](A)
exists for every A âˆˆ|D|, Right[F, G] denotes a functor Dâˆ’â†’C.
Proof: We ï¬rst need to deï¬ne what Left[F, G](f) is for a D morphism f: A â†’B. We
deï¬ne it as the morphism h: Left(A) â†’Left(B) which ï¬lls in the following diagram.
F(Left(A), A)
Î·A
G(Left(A), A)
âŸ¨Left(A), Î·AâŸ©
F(h, I)
G(h, I)
h
F(Left(B), A)
G(Left(B), A)
âŸ¨Left(B), G(I, f) â—¦Î·B â—¦F(I, f)âŸ©
F(I, f)
G(I, f)
F(Left(B), B)
Î·B
G(Left(B), B)
-
?
?
?
?
6
-
The unique existence of the morphism is provided because âŸ¨Left(A), Î·AâŸ©is the initial
object of DAlg(F( Â· , A), G( Â· , A)). In other words, Left(f) is the unique morphism
which satisï¬es
G(Left(f), f) â—¦Î·B â—¦F(Left(f), f) = Î·A.
Let us check that Left is in fact a functor. Trivially,
G(I, I) â—¦Î·A â—¦F(I, I) = Î·A.
Therefore, Left(IA) = ILeft(A). For morphisms f: A â†’B and g: B â†’C,
G(Left(g) â—¦Left(f), g â—¦f) â—¦Î·C â—¦F(Left(g) â—¦Left(f), g â—¦f)
= G(Left(f), f) â—¦G(Left(g), g) â—¦Î·C â—¦F(Left(g), g) â—¦F(Left(f), f)
= G(Left(f), f) â—¦Î·B â—¦F(Left(f), f)
= Î·A

CHAPTER 3. CATEGORICAL DATA TYPES
52
Therefore, Left(g) â—¦Left(f) = Left(g â—¦f).
F(Left(A), A)
G(Left(A), A)
F(Left(B), B)
G(Left(B), B)
F(Left(C), C)
G(Left(C), C)
Î·A
Î·B
Î·C
F(Left(f), f)
G(Left(f), f)
F(Left(g), g)
G(Left(g), g)
F(Left(g â—¦f), g â—¦f)
G(Left(g â—¦f), g â—¦f)
-
-
-
?
?
?
?
-

Dually, we can prove that Right is a functor. []
â€˜Leftâ€™ and â€˜Rightâ€™ may suggest a connection with left and right adjoint functors. In
fact,
Proposition 3.1.5: For a functor F: C â†’D, its left adjoint functor can be denoted
by
Left[Î»(X, Y ).Y, Î»(X, Y ).F(X)]
and, dually, its right adjoint functor can be denoted by
Right[Î»(X, Y ).F(X), Î»(X, Y ).Y ].
Proof: Let us only check the left adjoint case. We see Î»(X, Y ).Y as a functor C Ã—D â†’
D and Î»(X, Y ).F(X) as a functor CÃ—Dâˆ’â†’D. From deï¬nition 3.1.3, Left is a functor
D â†’C. If we spell out the condition of âŸ¨Left(A), Î·AâŸ©being the initial algebra, it
means that for any C object B and a C morphism f: A â†’F(B) there exists a unique
C morphism h: Left(A) â†’B such that the following diagram commutes.
A
Î·A
F(Left(A))
Left(A)
A
F(B)
B
f
Â¥
Â¨Â§?
F(h)
h
-
-
?
?
This is exactly the condition of Left being the left adjoint functor of F. Dually, we
can prove that Right[Î»(X, Y ).F(X), Î»(X, Y ).Y ] is the right adjoint. []
Hence, deï¬nition 3.1.2 of F, G-dialgebras covers both T-algebras and adjoints so that
it enables us to deï¬ne products, coproducts, natural number object, and so on in a
uniform way.

CHAPTER 3. CATEGORICAL DATA TYPES
53
3.2
Data Type Declarations in
Categorical Data Types
In the previous section, we have looked at some ways of deï¬ning data types in some
languages. In this section, we will introduce how to deï¬ne data types in CDT.
If we were only interested in functors, only Left[F, G] and Right[F, G] deï¬ned in the
previous section would be needed, but we do want morphisms (or natural transforma-
tions) and factorizers which will make up some kind of programs, the meaning of which
we will examine in chapter 4 (e.g. how to execute them).
Left[F, G] and Right[F, G] have been deï¬ned for functors F: C Ã— D â†’E and G: C Ã—
Dâˆ’â†’E, where C, D and E are some categories. Remember the aim of CDT; we
would like to deï¬ne (or specify, or study) a category of data types. Therefore, C, D
and E should somehow be related to this category. The simplest we can think of is that
they are the product categories of this category and all the functors are in the form of
Cs â†’C, where s is a sequence of variances (i.e. s âˆˆVarâˆ—) and Cv1...vn def
= Cv1 Ã—Â· Â· Â·Ã—Cvn.
In order to simplify the presentation, let us use the vector notation and write, for
example, âƒ—F for a sequence of functors âŸ¨F1, . . . , FnâŸ©where all of them have the same
type Cs â†’C, that is, âƒ—F is a functor of Cs â†’Cn.
From deï¬nition 3.1.3, for âƒ—F: C Ã—Cs â†’Cn and âƒ—G: C Ã—Câˆ’â€¢s â†’Cn, Left[F, G] is a functor
Cs â†’C and Right[F, G] is a functor Câˆ’â€¢s â†’C, where u â€¢ v1 . . . vn
def
= u â€¢ v1 . . . u â€¢ vn.
Hence, we come to the deï¬nition of CDT declarations.
Deï¬nition 3.2.1: In CDT theory, there are two forms of declaring new functors. One
is to deï¬ne a functor L: Cs â†’C by
left object L( âƒ—X) with Ïˆ is
âƒ—Î±: âƒ—F(L, âƒ—X) â†’âƒ—G(L, âƒ—X)
end object
(âˆ—)
and the other is to deï¬ne a functor R: Câˆ’â€¢s â†’C by
right object R( âƒ—X) with Ïˆ is
âƒ—Î±: âƒ—F(R, âƒ—X) â†’âƒ—G(R, âƒ—X)
end object
where âƒ—X is a sequence âŸ¨X1, . . . , XnâŸ©of variables, Ïˆ is the associated factorizer, âƒ—Î± is
a sequence âŸ¨Î±1, . . . , Î±mâŸ©of the associated natural transformations, and âƒ—F and âƒ—G are
sequences âŸ¨F1, . . . , FmâŸ©and âŸ¨G1, . . . , GmâŸ©, respectively, of functors which we have as
primitives or we have already deï¬ned and whose type is Fi: C Ã— Cs â†’C and Gi: C Ã—
Câˆ’â€¢s â†’C, respectively. Semantically, L is Left[âƒ—F, âƒ—G] and R is Right[âƒ—F, âƒ—G]. We may
call L left functor or left object and R right functor or right object. []

CHAPTER 3. CATEGORICAL DATA TYPES
54
If we expand the deï¬nition of Left, (âˆ—) deï¬nes for any C objects âƒ—A = âŸ¨A1, . . . , AnâŸ©an
object L( âƒ—A) and a morphism
âƒ—F(L( âƒ—A), âƒ—A)
-
âƒ—Î± âƒ—A
âƒ—G(L( âƒ—A), âƒ—A),
and for any object B and a sequence of morphisms âƒ—f: âƒ—F(B, âƒ—A) â†’âƒ—G(B, âƒ—A), Ïˆ(âƒ—f) denotes
the unique morphism which makes the following diagram commute.
âƒ—F(L( âƒ—A), âƒ—A)
âƒ—Î± âƒ—A
âƒ—G(L( âƒ—A), âƒ—A)
L( âƒ—A)
âƒ—F(Ïˆ(âƒ—f), âƒ—A)
Â¥
Â¨Â§?
âƒ—G(Ïˆ(âƒ—f), âƒ—A)
Ïˆ(âƒ—f)
âƒ—F(B, âƒ—A)
âƒ—f
âƒ—G(B, âƒ—A)
B
-
-
?
?
?
In deï¬nition 3.2.1, it is not immediately clear what kind of âƒ—F and âƒ—G is allowed. We
vaguely stated that they are primitive or have been deï¬ned already. In order to clarify
this point, we go back to CSL and regard a CDT declaration as an extension of a given
CSL signature.
Deï¬nition 3.2.2: Let âŸ¨Î“, âˆ†, Î¨âŸ©be a CSL signature. A CDT declaration D âˆˆDecl
is given by the following BNF expression.
D : : = { left | right } object F(X1, . . . , Xn) with Ïˆ is
Î±1: E1 â†’Eâ€²
1
. . .
Î±m: Em â†’Eâ€²
m
end object
where F is a new functor symbol, Ïˆ is a new factorizer symbol, Î±1, . . . , am are new
natural transformation symbols, and Ei and Eâ€²
i (i = 1, . . . , m) are well-formed functo-
rial expressions (under this signature âŸ¨Î“, âˆ†, Î¨âŸ©) whose variables are X1, . . . , Xn and F
(here we use F as a formal parameter like we use its function name inside a function
body in PASCAL). []
We need to put restriction on the variance of F in the functorial expressions such that
for each i = 1, . . . , m
1. the variance of F in Ei should be either covariant or free,
2. the variance of F in Eâ€²
i should also be either covariant or free, and
3. either the variance of F in Ei should be covariant or that in Eâ€²
i should be covariant.
We could have allowed F to be contravariant (as indeed the original deï¬nition of CDT
did), but it turned out that the generality by contravariance was of very little use,

CHAPTER 3. CATEGORICAL DATA TYPES
55
so, because it simpliï¬es the following argument, we restrict ourselves only to covariant
functors. The third condition above is to make the extension consistent (each Î±i should
somehow relate to the functor we are declaring).
Let us calculate the variance of F. If the variance of Î»(F, X1, . . . , Xn).Ei is visi (vi âˆˆ
Var for the variance of F and si âˆˆVarâˆ—for the variance of X1, . . . , Xn) and that of
Î»(F, X1, . . . , Xn).Eâ€²
i is vâ€²
isâ€²
i, Î»(F, X1, . . . , Xn).Ei denotes a functor Cvi Ã— Csi â†’C and
Î»(F, X1, . . . , Xn).Eâ€²
i denotes a functor Cvâ€²
i Ã— Csâ€²
i â†’C. The restriction above states that
vi âŠ”vâ€²
i = +. From proposition 3.1.4, the variance of F in case that it is declared by a
left CDT declaration should be
m
G
i=1
si âŠ”âˆ’â€¢ sâ€²
i,
(âˆ—)
and in case that it is declared by a right one, the variance should be
m
G
i=1
âˆ’â€¢ si âŠ”sâ€²
i,
(âˆ—âˆ—)
where Varâˆ—is a partially ordered set with the ordering given by u1 . . . un âŠ‘v1 . . . vn if
and only if u1 âŠ‘v1, . . . and un âŠ‘vn.
Deï¬nition 3.2.2 (continued): A CDT declaration gives an extension of CSL signa-
ture.
âŸ¨Î“, âˆ†, Î¨âŸ©,â†’âŸ¨Î“ âˆª{ F }, âˆ†âˆª{ Î±1, . . . , Î±m }, Î¨ âˆª{ Ïˆ }âŸ©
where the variance of F is given by (âˆ—) or (âˆ—âˆ—), the type of Î±i is
Î»(X1, . . . , Xn).Ei[F(X1, . . . , Xn)/F]
Â·â†’Î»(X1, . . . , Xn).Eâ€²
i[F(X1, . . . , Xn)/F],
and the type of Ïˆ is
fi: Î»(X, X1, . . . , Xn).Ei[X/F] â†’Î»(X, X1, . . . , Xn).Eâ€²
i[X/F]
(i = 1, . . . , m)
Ïˆ(f1, . . . , fm): Î»(X, X1, . . . , Xn).F(X1, . . . , Xn) â†’Î»(X, X1, . . . , Xn).X
by a left CDT declaration and
fi: Î»(X, X1, . . . , Xn).Ei[X/F] â†’Î»(X, X1, . . . , Xn).Eâ€²
i[X/F]
(i = 1, . . . , m)
Ïˆ(f1, . . . , fm): Î»(X, X1, . . . , Xn).X â†’Î»(X, X1, . . . , Xn).F(X1, . . . , Xn)
by a right one. []
We will see in section 3.4 a CDT declaration as a CSL theory extension so that the
semantics of a CDT declaration can be given by a CSL structure.

CHAPTER 3. CATEGORICAL DATA TYPES
56
3.3
Examples of Categorical Data Types
In this section, we will present several examples of categorical data types declared by
left object F(X1, . . . , Xn) with Ïˆ is
Î±1: E1 â†’Eâ€²
1
. . .
Î±m: Em â†’Eâ€²
m
end object
(âˆ—)
for left objects and by
right object F(X1, . . . , Xn) with Ïˆ is
Î±1: E1 â†’Eâ€²
1
. . .
Î±m: Em â†’Eâ€²
m
end object
(âˆ—âˆ—)
for right objects.
3.3.1
Terminal and Initial Objects
Let us start with an empty CSL signature âŸ¨âˆ…, âˆ…, âˆ…âŸ©. The simplest case of (âˆ—) and (âˆ—âˆ—)
is when n = m = 0. If we consider the case when n = m = 0 in (âˆ—âˆ—), we get the
declaration of the terminal object.
right object 1 with !
end object
(We omitted the keyword â€˜isâ€™ to make the declaration look nicer.) From the deï¬nition,
this deï¬nes an object â€˜1â€™ and for any object A there is a unique morphism â€˜!â€™ from A
to â€˜1â€™.
A
-
!
1
Therefore, it really is the terminal object.
Dually, if we change the keyword â€˜rightâ€™ to â€˜leftâ€™ in the deï¬nition of the terminal object,
we get the deï¬nition of the initial object.
left object 0 with !!
end object
The factorizer â€˜!!â€™ gives a unique morphism from â€˜0â€™ to any object A.
0
-
!!
A

CHAPTER 3. CATEGORICAL DATA TYPES
57
3.3.2
Products and CoProducts
Next, we deï¬ne products and coproducts. The binary product functor can be declared
as the following right object.
right object prod(X, Y ) with pair is
pi1: prod â†’X
pi2: prod â†’Y
end object
From deï¬nition 3.2.2, this deï¬nes a functor symbol â€˜prodâ€™ whose variance is â€˜++â€™ (i.e.
covariant in both arguments), two natural transformation symbols â€˜pi1â€™ and â€˜pi2â€™ whose
types are
pi1: Î»(X, Y ).prod(X, Y )
Â·â†’Î»(X, Y ).X
pi2: Î»(X, Y ).prod(X, Y )
Â·â†’Î»(X, Y ).Y
and a factorizer symbol â€˜pairâ€™ whose type is
f: Î»(Z, X, Y ).Z â†’Î»(Z, X, Y ).X
g: Î»(Z, X, Y ).Z â†’Î»(Z, X, Y ).Y
pair(f, g): Î»(Z, X, Y ).Z â†’Î»(Z, X, Y ).prod(X, Y )
.
If we write this down in a more understandable way, it becomes the familiar deï¬nition
of the binary product, that is â€˜prodâ€™ has two unit morphisms
A
prod(A, B)
B
pi1
pi2

-
and pair(f, g) gives the unique morphism for any morphisms f: C â†’A and g: C â†’B
such that the following diagram commutes.
A
prod(A, B)
B
pi1
pi2

-
C
f
g
pair(f, g)
Â¥
Â¨Â§?
Â¥
Â¨Â§?
@
@
@
@
@
@
@
@
I
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡

6
Note that the CDT declaration of the binary product functor is very similar to the
â€˜Prodâ€™ theory in CLEAR deï¬ned in 3.1. One of the diï¬€erences is that in CLEAR â€˜pairâ€™
is treated as a function in the same class as â€˜pi1â€™ and â€˜pi2â€™ but in CDT â€˜pairâ€™ is quite
diï¬€erent from â€˜pi1â€™ and â€˜pi2â€™. Another one is that in CLEAR â€˜Prodâ€™ is declared as the
initial algebra so it is close to CDTâ€™s left object but in CDT â€˜prodâ€™ is naturally a right
object because the product functor is the right adjoint of the diagonal functor.

CHAPTER 3. CATEGORICAL DATA TYPES
58
Dually, we can deï¬ne the binary coproduct functor as a left object.
left object coprod(X, Y ) with case is
in1: X â†’coprod
in2: Y â†’coprod
end object
Again, this declaration looks very close to the one in CLEAR (deï¬ned in section 3.1),
but note that we have â€˜caseâ€™ in CDT so that we can use it to write programs or to
specify some properties.
Just writing the situation as a diagram,
A
coprod(A, B)
B
in1
in2
-

C
f
g
case(f, g)
Â¥
Â¨Â§?
Â¥
Â¨Â§?
@
@
@
@
@
@
@
@
R
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Âª
?
3.3.3
Exponentials
One of the objections against algebraic speciï¬cation methods is that it cannot handle
function spaces. CDTâ€™s declaration mechanism looks very close to that of algebraic
speciï¬cation methods, but CDT is based on category theory not on many-sorted alge-
bras, and in category theory function spaces can be deï¬ned as exponentials. For objects
A and B, the exponential of B by A is written as exp(A, B)5 satisï¬es the following
natural isomorphism.
HomC(prod(C, A), B) â‰ƒHomC(C, exp(A, B))
In other words, The functor exp(A, Â· ) is the right adjoint of prod( Â· , A). We write
â€˜curryâ€™ for the factorizer and â€˜evalâ€™ for the counit natural transformation. Then, for
any object C and any morphism f: prod(C, A) â†’B, curry(f) is the unique morphism
from exp(A, B) to C such that the following diagram commutes.
C
exp(A, B)
curry(f)
?
prod(C, A)
prod(exp(A, B), A)
B
prod(curry(f), I)
f
Â¥
Â¨Â§?
eval
ZZZZZZZZZZ
~
-
?
5Many category theory books use the notation BA for the exponential of B by A.

CHAPTER 3. CATEGORICAL DATA TYPES
59
The reason why the exponentials are function spaces is that their global elements are
just morphisms.6
HomC(1, exp(A, B)) â‰ƒHomC(prod(1, A), B) â‰ƒHomC(A, B)
Let us write down the deï¬nition as a CDT declaration.
Assume a CSL signature
âŸ¨Î“, âˆ†, Î¨âŸ©which contains the deï¬nition of the binary product functor as we deï¬ned in
subsection 3.3.2. Then, the exponential functor can be declared as follows.
right object exp(X, Y ) with curry is
eval: prod(exp, X) â†’Y
end object
This is so far the most complicated CDT declaration. In the previous examples, functo-
rial expressions Ei and Eâ€²
i in (âˆ—) and (âˆ—âˆ—) are all simply variables. From deï¬nition 3.2.2,
the CDT declaration above deï¬nes a functor symbol â€˜expâ€™ of type âˆ’+, a natural trans-
formation â€˜evalâ€™ of type
Î»(X, Y ).prod(exp(X, Y ), X)
Â·â†’Î»(X, Y ).Y
and a factorizer â€˜curryâ€™ of type
f: Î»(Z, X, Y ).prod(Z, X) â†’Î»(Z, X, Y ).Y
curry(f): Î»(Z, X, Y ).Z â†’Î»(Z, X, Y ).exp(X, Y )
.
These types are what we expect them to be from the exponential adjunction. Let us
once more convince ourselves that the semantics by F, G-dialgebras really deï¬nes the
exponentials. âŸ¨exp(A, B), evalA,BâŸ©is the ï¬nal F, G-dialgebra where F(C) def
= prod(C, A)
and G(C) def
= B. This means that, for any âŸ¨C, fâŸ©where C is an object and f is a
morphism of F(C) â†’G(C), curry(f) is the unique morphism of
âŸ¨exp(A, B), evalA,BâŸ©â†’âŸ¨C, fâŸ©.
From deï¬nition 3.1.2 of F, G-dialgebras, curry(f) is the unique morphism C â†’exp(A, B)
which makes the following diagram commute.
F(C) = prod(C, A)
B = G(C)
f
F(exp(A, B)) = prod(exp(A, B), A)
B = G(exp(A, B))
evalA,B
F(curry(f)) = prod(curry(f), I)
Â¥
Â¨Â§?
I = G(curry(f))
-
-
?
This is exactly the condition of â€˜expâ€™ being the exponential functor.
6A global element of an object A is a morphism from the terminal object to A.

CHAPTER 3. CATEGORICAL DATA TYPES
60
The declaration of the exponential functor in CDT very much looks like a declaration
in a algebraic speciï¬cation language (e.g. in CLEAR), but, as is well-known, we cannot
deï¬ne function spaces as algebras. The essential diï¬€erence lies in that â€˜expâ€™ is a right
object, in other words, deï¬ned by the terminal data constraint rather than the initial
one which CLEAR uses and in the availability of the factorizer â€˜curryâ€™. If we deï¬ne
â€˜curryâ€™ as an ordinary function (or an ML function), its type is
(C Ã— A â†’B) â†’(C â†’(A â†’B))
and this could never be a type of algebraic functions (i.e. functions deï¬ned by algebraic
speciï¬cation methods).
3.3.4
Natural Number Object
As we have already shown that the natural number object can be given by â€˜Leftâ€™, let
us write it down as a CDT declaration. Although we can deï¬ne the natural number
object if we have only the terminal object, it is often very convenient to assume that
a CSL signature âŸ¨Î“, âˆ†, Î¨âŸ©contains not only the terminal object but also the product
functor and the exponential functor. The declaration of the natural number object as
a CDT is
left object nat with pr is
zero: 1 â†’nat
succ: nat â†’nat
end object
which deï¬nes a constant functor (i.e. an object) â€˜natâ€™ with two morphisms â€˜zeroâ€™ and
â€˜succâ€™.
1
nat
zero
succ
-


6
In addition, the factorizer â€˜prâ€™ (standing for primitive recursion) gives for any mor-
phisms f: 1 â†’A and g: A â†’A a unique morphism pr(f, g): nat â†’A such that the
following diagram commutes.
1
zero
nat
succ
nat
f
Â¥
Â¨Â§?
pr(f, g)
Â¥
Â¨Â§?
pr(f, g)
A
A
g
-
-
@
@
@
@
@
@
@
@
R
-
?
?
As is well-known (e.g. [Goldblatt 79] chapter 13), â€˜prâ€™ provides us to deï¬ne any primitive
recursive function.

CHAPTER 3. CATEGORICAL DATA TYPES
61
Deï¬nition 3.3.1: For a category C with the natural number object â€˜natâ€™, the terminal
object â€˜1â€™ and the binary product functor â€˜prodâ€™, a morphism f is primitive recursive
(on natural numbers) if it can be generated after ï¬nitely many steps by means of the
following rules:
1. f = Inat: nat â†’nat,
2. f = zero: 1 â†’nat,
3. f = succ: nat â†’nat,
4. f = pi1: prod(nat, nat) â†’nat,
5. f = pi2: prod(nat, nat) â†’nat,
6. f = g â—¦pair(h, k): A â†’nat for primitive recursive morphisms
g: prod(nat, nat) â†’nat, h: A â†’nat and k: A â†’nat,
7. f = g â—¦prod(h, k): prod(A, B) â†’nat for primitive recursive morphisms
g: prod(nat, nat) â†’nat, h: A â†’nat and k: B â†’nat, and
8. f: prod(nat, A) â†’nat satisfying
(a) f â—¦pair(zero â—¦!, I) = g, and
(b) f â—¦pair(succ â—¦pi1, pi2) = h â—¦pair(f, I)
for primitive recursive g: A â†’nat and h: prod(nat, prod(nat, A)) â†’nat. []
This is a straight copy of the standard deï¬nition of primitive recursive functions on
natural numbers.
Proposition 3.3.2: If a cartesian closed category C has the natural number object,
it has all the primitive recursive morphisms.
Proof: It is suï¬ƒce to show that there exists a morphism f: prod(nat, A) â†’nat for
any morphisms g: A â†’nat and h: prod(nat, prod(nat, A)) â†’nat such that
1. f â—¦pair(zero â—¦!, I) = g, and
2. f â—¦pair(succ â—¦pi1, pi2) = h â—¦pair(f, I).
There is a morphism k: nat â†’prod(exp(A, nat), nat) such that the following diagram
commutes.
1
nat
nat
prod(exp(A, nat), nat)
prod(exp(A, nat), nat)
zero
succ
k
k
gâ€²
hâ€²
Â¥
Â¨Â§?
Â¥
Â¨Â§?
-
-
@
@
@
@
@
@@
R
?
?
-

CHAPTER 3. CATEGORICAL DATA TYPES
62
where gâ€² and hâ€² are
gâ€² def
= pair(curry(g â—¦pi2), zero)
hâ€² def
= pair( curry(h â—¦pair( eval â—¦pair( pi2,
pi1 â—¦pi1),
pi2 â—¦pi1)),
succ â—¦pi2).
Therefore, k is pr(gâ€², hâ€²). Then, f def
= eval â—¦prod(pi1 â—¦k, I). We can easily show that
this is what we wanted. []
For example, the morphism â€˜addâ€™ corresponding to the addition function of natural
numbers can be given as
add def
= eval â—¦prod(pr(curry(pi2), curry(succ â—¦eval)), I).
It corresponds to the following usual deï¬nition of â€˜addâ€™.
add(0, y) = y
add(x + 1, y) = add(x, y) + 1
Furthermore, we can easily prove categorically that â€˜addâ€™ satisï¬es familiar laws like
commutativity (categorically add â—¦pair(pi2, pi1) = add) and so on.
3.3.5
Lists
We have deï¬ned the data type of natural numbers in the previous subsection. Another
algebraic data type which is often used in programming is the data type of lists. In
CDT, the data type of lists is deï¬ned as follows:
left object list(X) with prl is
nil: 1 â†’list
cons: prod(X, list) â†’list
end object
We needed to assume a CSL signature having the terminal object and the product
functor. The declaration above deï¬nes a one argument covariant functor â€˜listâ€™, two
natural transformations
nil: Î»(X).1
Â·â†’Î»(X).list(X)
and
cons: Î»(X).prod(X, list(X))
Â·â†’Î»(X).list(X)
and a factorizer â€˜prlâ€™ (standing for primitive recursion on list) whose type is
f: Î»(Y, X).1 â†’Î»(Y, X).Y
g: Î»(Y, X).prod(X, Y ) â†’Î»(Y, X).Y
prl(f, g): Î»(Y, X).list(X) â†’Î»(Y, X).Y
.

CHAPTER 3. CATEGORICAL DATA TYPES
63
As usual, we can express the situation as a diagram.
1
list(A)
prod(A, list(A))
B
prod(A, B)
nil
cons
f
Â¥
Â¨Â§?
prl(f, g)
Â¥
Â¨Â§?
prod(I, prl(f, g))
g
-
@
@
@
@
@
@
@
@
R


?
?
A global element of list(A) is normally constructed from â€˜nilâ€™ and â€˜consâ€™. For example,
list(nat) has
cons â—¦pair(succ â—¦zero, cons â—¦pair(succ â—¦succ â—¦zero, nil))
as a global element (in plain words, this element is the list of 1 and 2). â€˜nilâ€™ and â€˜consâ€™
are usually called constructors of â€˜listâ€™. We can see in general to deï¬ne an algebraic
CDT by listing its constructors. Destructors are deï¬ned using factorizers. In the case
of â€˜listâ€™, â€˜hdâ€™ (head) and â€˜tlâ€™ (tail) can be deï¬ned as follows.
hd def
= prl(in2, in1 â—¦pi1)
tl def
= coprod(pi2, I) â—¦prl(in2, in1 â—¦prod(I, case(cons, nil)))
Note that we have to deï¬ne â€˜hdâ€™ and â€˜tlâ€™ as total functions (in a sense). The type
of â€˜hdâ€™ is list(A) â†’coprod(A, 1) and is not list(A) â†’A.
The type of â€˜tlâ€™ is also
list(A) â†’coprod(list(A), 1). The type â€˜1â€™ is for error (like âŠ¥in a domain) and, for
example, hd â—¦nil = in2.
As â€˜listâ€™ is a covariant functor, for a morphism f: A â†’B list(f): list(A) â†’list(B)
transforms a list of A elements to a list of B elements by applying f to each element.
For example, list(succ): list(nat) â†’list(nat) increments every element in a given list
by one. In general, we have the following equations:
list(f) = prl(nil, cons â—¦prod(f, I))
list(f) â—¦nil = nil
list(f) â—¦cons â—¦pair(x, l) = cons â—¦pair(f â—¦x, list(f) â—¦l)
â€˜listâ€™ corresponds to â€˜mapâ€™ function in ML and â€˜MAPCARâ€™ in LISP.
3.3.6
Final Co-Algebras (Inï¬nite Lists and Co-Natural Num-
ber Object)
The objects we deï¬ned in the preceding subsections are all familiar either in category
theory or in programming languages. Particularly, we have seen in subsection 3.3.4
and 3.3.5 the natural number object and the data type of lists, which are typical initial
algebras. Recently, several works have been done about ï¬nal coalgebras, which are

CHAPTER 3. CATEGORICAL DATA TYPES
64
the dual of initial algebras (see [Arbib and Manes 80]). From their symmetry of CDT
declarations, we can easily deï¬ne ï¬nal coalgebras in CDT as well as initial algebras.
Let us dualize the declaration of the natural number object deï¬ned in subsection 3.3.4
by
left object nat with pr is
zero: 1 â†’nat
succ: nat â†’nat
end object
If we simply replace â€˜leftâ€™ by â€˜rightâ€™ and change the direction of arrows, we get
right object conat with copr is
cozero: nat â†’1
cosucc: nat â†’nat
end object
Unfortunately, this is not an exciting object. We can prove that â€˜conatâ€™ is isomorphic
to the terminal object as follows: from the uniqueness of terminal objects up to isomor-
phism in any category, we simply need to show that â€˜1â€™ is the terminal F, G-dialgebra
for these particular F and G, that is, for any object A and morphisms f: A â†’1 and
g: A â†’A, there exists a unique morphism h: A â†’1 such that the following diagram
commutes.
A
g
A
h
Â¥
Â¨Â§?
h
Â¥
Â¨Â§?
f
1
1
1
cosucc
cozero
-
-
-
@
@
@
@
@
@
@
@
R
?
?
Indeed, we have this unique morphism A â†’1 because â€˜1â€™ is the terminal object and
the above diagram trivially commutes.
Although the exact dual of the natural number object is not an interesting thing, we
can modify it to get a CDT data type of inï¬nite lists.
right object inï¬‚ist(X) with fold is
head: inï¬‚ist â†’X
tail: inï¬‚ist â†’inï¬‚ist
end object

CHAPTER 3. CATEGORICAL DATA TYPES
65
The diagram of explaining â€˜inï¬‚istâ€™ is
B
B
fold(f, g)
fold(f, g)
f
Â¥
Â¨Â§?
Â¥
Â¨Â§?
inï¬‚ist(A)
inï¬‚ist(A)
A
tail
head
-
-
-
@
@
@
@
@
@
@
@
R
g
?
?
Since the functor â€˜inï¬‚istâ€™ is not so familiar in category theory or in conventional pro-
gramming languages, let us ï¬nd out what it is in the category of sets. We expect it to
be a set of inï¬nite lists in some sense.
Proposition 3.3.3: In the category of sets, for a set A, inï¬‚ist(A) is the following set
of Ï‰-inï¬nite sequences of elements in A.
{ (x0, x1, . . . , xn, . . .) | xi âˆˆA }
Proof: We deï¬ne â€˜headâ€™ and â€˜tailâ€™ as follows:
head((x0, x1, . . . , xn, . . .)) def
= x0
tail((x0, x1, . . . , xn, . . .)) def
= (x1, x2, . . . , xn+1, . . .)
Let fold(f, g)(x) be a sequence (h0(x), h1(x), . . . , hn(x), . . .) for functions f: B â†’A and
g: B â†’B. The commutativity of the diagram above forces the following equations.
h0(x) = f(x)
(h1(x), h2(x), . . . , hn+1(x), . . .) = (h0(x), h1(x), . . . , hn(x), . . .)
Therefore, fold(f, g)(x) is uniquely determined as
fold(f, g)(x) def
= (f(x), f(g(x)), . . . , f(gn(x)), . . .)
[]
Hence, at least in the category of sets, inï¬‚ist(A) is really the data type of inï¬nite lists
of A elements.
More generally,
Proposition 3.3.4: In a cartesian closed category C with the natural number object,
inï¬‚ist(A) is isomorphic to exp(nat, A).
Proof: Let us deï¬ne h: exp(nat, A) â†’inï¬‚ist(A) to be the ï¬ll-in morphism of the
following diagram.
exp(nat, A)
tailâ€²
exp(nat, A)
h
Â¥
Â¨Â§?
h
headâ€²
Â¥
Â¨Â§?
inï¬‚ist(A)
tail
inï¬‚ist(A)
head
A
-
-
-
@
@
@
@
@
@
@
@
R
?
?

CHAPTER 3. CATEGORICAL DATA TYPES
66
where â€˜headâ€²â€™ and â€˜tailâ€²â€™ are
headâ€² def
= eval â—¦pair(I, zero â—¦!),
tailâ€² def
= curry(eval â—¦prod(I, succ)).
We deï¬ne hâ€²: inï¬‚ist(A) â†’exp(nat, A) to be
hâ€² def
= curry(eval â—¦pair(pr(curry(head â—¦pi2), exp(tail, I)) â—¦pi2, pi1)).
After some calculation, we can show that h â—¦hâ€² = I and hâ€² â—¦h = I, so inï¬‚ist(A) is
isomorphic to exp(nat, A). []
This proposition tells us that
inï¬‚ist(A) âˆ¼= A Ã— A Ã— Â· Â· Â· Ã— A Ã— Â· Â· Â· âˆ¼=
âˆ
Y
i=1
A.
Indeed, this is the dual of Pâˆ
i=1 A, the special case of which is the natural number
object, nat âˆ¼=
Pâˆ
i=1 1.
We started this subsection by considering the dual of the natural number object. It
led us to the CDT data type of inï¬nite lists. We still have a diï¬€erent question whether
there is a ï¬nal coalgebra which resembles a data type of natural numbers. The answer
is yes. The following right object deï¬nes a CDT data type of natural numbers plus
alpha.
right object conat with copr is
pred: conat â†’coprod(1, conat)
end object
The situation can be written as a diagram
A
f
coprod(1, A)
copr(f)
Â¥
Â¨Â§?
coprod(1, copr(f))
conat
pred
coprod(1, conat)
-
-
?
?
The natural transformation â€˜predâ€™ is the predecessor function and there is a morphism
from â€˜natâ€™ to â€˜conatâ€™ given by
copr(pr(in1, in2 â—¦case(zero, succ)))
which we expect to be injective, but so far the author has been able neither to prove
it nor to give a counter example.
Note that there is always a morphism from the
left object to its corresponding right object. â€˜Conatâ€™ has an interesting extra element,
namely the inï¬nity (âˆ). The ground element to denote it is
inï¬nity def
= copr(in2)

CHAPTER 3. CATEGORICAL DATA TYPES
67
It is easy to prove that the predecessor of the inï¬nity is itself (i.e. pred â—¦inï¬nity =
in2 â—¦inï¬nity).
In the category of sets, â€˜conatâ€™ is really the set of natural numbers and the inï¬nity.
Proposition 3.3.5: In Set, â€˜conatâ€™ is â€˜nat âˆª{ âˆ}â€™.
Proof: The predecessor function is deï¬ned as usual. Roughly speaking, for any func-
tion f: A â†’coprod(1, A), copr(f)(x) is the number of applications of f to x to get the
element of 1
copr(f)(x) = n
where
f n(x) âˆˆ1,
and, if it never results in the element of 1, copr(f)(x) = âˆ. We can easily show that
this is the unique function which makes the â€˜conatâ€™ diagram commute. []
Therefore, in the category of sets, â€˜conatâ€™ is isomorphic to â€˜natâ€™, but this is not the
case for all the categories. There are some categories where â€˜conatâ€™ and â€˜natâ€™ are not
isomorphic.
Proposition 3.3.6: In category TRF of subsets of natural numbers as objects and
total recursive functions as morphisms, there exists the natural number object but does
not exist the co-natural number object.
Proof: TRFâ€™s terminal object, initial object, product functor and coproduct functor
are all the same as those of Set. For example, injections â€˜in1â€™ and â€˜in2â€™ for coprod(A, B)
are trivially total and recursive, and for any two total recursive functions f: A â†’C
and g: B â†’C case(f, g) is also total recursive function. We can write it down as a
kind of program.
case(f, g)(x) def
= if x âˆˆA then f(x)
else g(x)
The natural number object â€˜natâ€™ in TRF is also the ordinary set of natural numbers.
â€˜Zeroâ€™ and â€˜succâ€™ are total recursive functions from the very deï¬nition of recursive
functions and for f: 1 â†’A and g: A â†’A of total recursive functions, pr(f, g) can be
written as the following program.
pr(f, g)(n) def
= if n = 0 then f()
else g(pr(f, g)(n âˆ’1))
which deï¬nes a total recursive function.
However, we cannot have the co-natural number object in TRF. The program of
copr(f) for a total recursive function f: A â†’coprod(1, A) can only be
copr(f)(x) def
= if f(x) âˆˆ1 then 0
else copr(f)(f(x)) + 1
which is recursive but not total. []
There is also a category which has both â€˜natâ€™ and â€˜conatâ€™ and in which they are non-
isomorphic. We will show this in chapter 4.
From the point of view of ï¬nding ï¬xed points of functors, â€˜natâ€™ is the initial ï¬xed point
of F(X) def
= 1 + X and â€˜conatâ€™ is the ï¬nal ï¬xed point of the same functor.

CHAPTER 3. CATEGORICAL DATA TYPES
68
3.3.7
Automata
The declarations of initial algebras and ï¬nal coalgebras do not use the full power of the
CDT declaration mechanism. Their unit and counit natural transformations always
have the form
Î±: E â†’F
for initial algebras and have the form
Î±: F â†’E
for ï¬nal coalgebras, where E is any functorial expression but F is a variable (more
specially, the variable which denotes the object we declare).
Therefore, all we are
doing is just listing constructors for initial algebras and listing destructors for ï¬nal
coalgebras. We will see what kinds of form deï¬ne sensible functors in section 3.5. So
far, the only exception was the exponentials.
We will see another example in this
subsection.
One of the interesting applications of category theory to computer science is to au-
tomata theory. [Arbib and Manes 75] presents the category Dyn(I) of I-dynamics
whose object is
Q Ã— I
-
Î´
Q,
where Q is the set of states, I is the set of inputs and Î´ is a dynamics which is a
function determining the next state of the automaton according to the current state
and input.
From this, we can construct a categorical data type of automata.
right object dyn(I) with univ is
next: prod(dyn, I) â†’dyn
end object
Note that our dyn(I) for an object I is just an object; it is not a category like Dyn(I)
is. The diagram which explains this right object is
prod(Q, I)
Î´
Q
prod(univ(Î´), I)
Â¥
Â¨Â§?
univ(Î´)
prod(dyn(I), I)
next
dyn
-
-
?
?
For any dynamics Î´: prod(Q, I) â†’Q and an initial state q0: 1 â†’Q, we get an automa-
ton
1
-
univ(Î´) â—¦q0
dyn(I)

CHAPTER 3. CATEGORICAL DATA TYPES
69
as a global element of dyn(I). Though we can put this automaton into the next state by
applying â€˜nextâ€™, we are never ever able to see its behaviour from the outside. Moreover,
because of this non-observability, we can easily prove that dyn(I) is in fact isomorphic
to the terminal object. In order to make â€˜dynâ€™ a more sensible object, we need to add
an output function. The new categorical data type of automata is7
right object dynâ€²(I, O) with univâ€² is
nextâ€²: prod(dynâ€², I) â†’dynâ€²
outputâ€²: dynâ€² â†’O
end object
For any dynamics Î´: prod(Q, I) â†’Q, any output function Î²: Q â†’O and an initial
state q0: 1 â†’Q, we have a global element in dynâ€²(I, O)
1
-
univâ€²(Î´, Î²) â—¦q0 dynâ€²(I, O).
We can obtain its next state by applying â€˜nextâ€²â€™ and its output by â€˜outputâ€²â€™. In addition,
the following proposition holds.
Proposition 3.3.7: In a cartesian closed category, the categorical data type of Moore
automata, dynâ€²(I, O), is isomorphic to exp(list(I), O).
Proof: By deï¬ning two morphisms between them and proving that they form an
isomorphism. []
3.3.8
Obscure Categorical Data Types
We have deï¬ned more or less familiar data types as categorical data types in the
preceding subsections. One might ask whether CDT can deï¬ne any data types which
are unable to be deï¬ned in other languages or methods. The data type of automata is
such an example and we can invent similar examples more, but still they are familiar
(or we are just trying to express our familiar data types in CDT). In fact, CDT allows
us very obscure data types, some of which may not be conceptualized in the human
brain (at least not in the authorâ€™s brain).
From the prime requirement of CDT, it can deï¬ne right and left adjoint functors of
any existing functors, and in subsection 3.3.5, we deï¬ned â€˜listâ€™ as a covariant functor,
so that we can declare its left and right adjoint functors in CDT as follows.
left object ladjlist(X) with Ïˆ is
Î±: X â†’list(ladjlist)
end object
7The original deï¬nition we used was
right object dynâ€²(I, O) with univâ€² is
nextâ€²: prod(dynâ€², I) â†’prod(dynâ€², O)
end object
which gave us the categorical data type of Mealy automata. The current deï¬nition gives us the data
type of Moore automata.

CHAPTER 3. CATEGORICAL DATA TYPES
70
right object radjlist(X) with Ïˆâ€² is
Î±â€²: list(radjlist) â†’X
end object
Some questions arise immediately after deï¬ning these data types: are they familiar
data types, and are they in any way useful? The answers to the both questions are
unfortunately negative. For the left adjoint,
Proposition 3.3.8: In a cartesian closed category, â€˜ladjlist(A)â€™ for any object A is
isomorphic to the initial object.
Proof: It is easy to show that the initial object makes the characteristic diagram of
â€˜ladjlistâ€™ commute. Note that in a cartesian closed category â€˜list(0)â€™ is isomorphic to
the terminal object so that the unit morphism of â€˜ladjlistâ€™ is the unique morphism to
the terminal object. []
The right adjoint functor is more harmful than the left one.
Proposition 3.3.9: A cartesian closed category with â€˜radjlistâ€™ degenerates (i.e. all the
objects are isomorphic).
Proof: We have the following morphism from the initial object.
1
nil
âˆ’âˆ’â†’list(radjlist(0))
Î±â€²
âˆ’âˆ’â†’0
Then, it is easy to show that the terminal object is isomorphic to the initial one. This
further implies that any object in the category is isomorphic to the initial object.
A âˆ¼= prod(A, 1) âˆ¼= prod(A, 0) âˆ¼= 0
[]
Most of the left and right adjoint functors of conventional data types follow the same
pattern as â€˜listâ€™, that is, they are either trivial or destructive, so they are useless.
Hence, a natural question to ask ourselves is that what kind of categorical data types
are useful. But what is the formal criteria of useful data types? We have not yet
deï¬ned this. We will come back to this in chapter 4 and see it from a point of view of
computability of categorical data types.
3.4
Semantics of Categorical Data Types
In deï¬nition 3.2.2, we associated a CDT declaration to a CSL signature extension (an
injective morphism in CSig). In this section, we will see it as a CSL theory extension
and give the precise semantics of CDT declarations.
First, from our informal intention of CDT declarations we have to ï¬gure out the CSL
statements which characterize them. A CDT declaration
left object L(X1, . . . , Xn) with Ïˆ is
Î±1: E1 â†’Eâ€²
1
Â· Â· Â·
Î±m: Em â†’Eâ€²
m
end object

CHAPTER 3. CATEGORICAL DATA TYPES
71
is the syntactic form of deï¬ning the functor L = Left[âƒ—F, âƒ—G], where âƒ—F and âƒ—G are corre-
sponding functors for E1, . . . , Em and Eâ€²
1, . . . , Eâ€²
m, respectively. âŸ¨L( âƒ—A), âƒ—Î±âŸ©is the initial
object of DAlg(âƒ—F, âƒ—G) and Ïˆ is its mediating morphism, that is, for any morphisms
âƒ—f: âƒ—F(B, âƒ—A) â†’âƒ—G(B, âƒ—A), Ïˆ(âƒ—f) gives a unique morphism from L( âƒ—A) to B such that the
following diagram commutes.
âƒ—F(L( âƒ—A), âƒ—A)
âƒ—Î± âƒ—A
âƒ—G(L( âƒ—A), âƒ—A)
L( âƒ—A)
âƒ—F(Ïˆ(âƒ—f), âƒ—A)
Â¥
Â¨Â§?
âƒ—G(Ïˆ(âƒ—f), âƒ—A)
Ïˆ(âƒ—f)
âƒ—F(B, âƒ—A)
âƒ—f
âƒ—G(B, âƒ—A)
B
-
-
?
?
?
The commutativity of this diagram can be expressed as the following equation:
âƒ—G(Ïˆ(âƒ—f), âƒ—A) â—¦âƒ—Î± = âƒ—f â—¦âƒ—F(Ïˆ(âƒ—f), âƒ—A),
(âˆ—)
and the uniqueness can be expressed as the following conditional equation:
âƒ—G(h, âƒ—A) â—¦âƒ—Î± = âƒ—f â—¦âƒ—F(h, âƒ—A) â‡’h = Ïˆ(âƒ—f)
(âˆ—âˆ—)
The two equations say everything about L, âƒ—Î± and Ïˆ. Let us now translate them to CSL
statements in âŸ¨Î“âˆª{L}, âˆ†âˆª{Î±1, . . . , Î±m}, Î¨âˆª{Ïˆ}âŸ©so as to give complete description of
the CDT declaration above in CSL. (âˆ—) corresponds to the following m CSL equations:
Eâ€²
i[Ïˆ(f1, . . . , fm)/L] â—¦Î±i = fi â—¦Ei[Ïˆ(f1, . . . , fm)/L]8
(LEQi)
(i = 1, . . . , m) and (âˆ—âˆ—) corresponds to the following conditional CSL equation.
Eâ€²
1[g/L] â—¦Î±1 = f1 â—¦E1[g/L] âˆ§. . .
âˆ§Eâ€²
m[g/L] â—¦Î±m = fm â—¦Em[g/L] â‡’g = Ïˆ(f1, . . . , fm)
(LCEQ)
In addition, we should have a CSL equation expressing functors by factorizers and
natural transformations. We can extract such an equation from proposition 3.1.4.
L(h1, . . . , hn) =
Ïˆ(Eâ€²
1[hi/Xi] â—¦Î±1 â—¦E1[hi/Xi], . . . , Eâ€²
m[hi/Xi] â—¦Î±m â—¦Em[hi/Xi])9
(LFEQ)
Therefore, the semantics of CDT declaration can be given as a CSL theory extension
as follows.
8Ei[Ïˆ(f1, . . . , fm)/L] means replacing the variable L by Ïˆ(f1, . . . , fm) and replacing the other variables
X1, . . . , Xn by the identities, that is it is a shorthand for
Ei[Ïˆ(f1, . . . , fm)/L, I/X1, . . . , I/Xn].
9E1[hi/Xi] is a shorthand for E1[I/L, h1/X1, . . . , hn/Xn].

CHAPTER 3. CATEGORICAL DATA TYPES
72
Deï¬nition 3.4.1: Given a CSL theory âŸ¨Î“, âˆ†, Î¨, Î˜âŸ©, a CDT declaration
left object L(X1, . . . , Xn) with Ïˆ is
Î±1: E1 â†’Eâ€²
1
Â· Â· Â·
Î±m: Em â†’Eâ€²
m
end object,
where Ei and Eâ€²
i (i = 1, . . . , m) are CSL functorial expressions over âŸ¨Î“, âˆ†, Î¨âŸ©whose
variables are X1, . . . , Xn and L, is associated with a CSL theory morphism
ÏƒL: âŸ¨Î“, âˆ†, Î¨, Î˜âŸ©â†’âŸ¨Î“ âˆª{L}, âˆ†âˆª{Î±1, . . . , Î±m}, Î¨ âˆª{Ïˆ},
Î˜ âˆª{LEQ1, . . . , LEQm, LCEQ, LFEQ}âŸ©
where the types of L, Î±1, . . . , Î±m and Ïˆ are as given in deï¬nition 3.2.2. Dually, we can
associate to a right object R
right object R(X1, . . . , Xn) with Ïˆ is
Î±1: E1 â†’Eâ€²
1
Â· Â· Â·
Î±m: Em â†’Eâ€²
m
end object,
a CSL theory morphism ÏƒR.
ÏƒR: âŸ¨Î“, âˆ†, Î¨, Î˜âŸ©â†’âŸ¨Î“ âˆª{R}, âˆ†âˆª{Î±1, . . . , Î±m}, Î¨ âˆª{Ïˆ},
Î˜ âˆª{REQ1, . . . , REQm, RCEQ, RFEQ}âŸ©
where REQi, RCEQ and RFEQ are
Î±i â—¦Ei[Ïˆ(f1, . . . , fm)/R] = Eâ€²
i[Ïˆ(f1, . . . , fm)/R] â—¦fi
(REQi)
Î±1 â—¦E1[g/R] = Eâ€²
1[g/R] â—¦f1 âˆ§. . .
âˆ§Î±m â—¦Em[g/R] = Eâ€²
m[g/R] â—¦fm â‡’g = Ïˆ(f1, . . . , fm)
(RCEQ)
R(h1, . . . , hn) =
Ïˆ(Eâ€²
1[h1/Xi] â—¦Î±1 â—¦E1[hi/Xi], . . . , Eâ€²
m[hi/Xi] â—¦Î±m â—¦Em[hi/Xi])
(RFEQ)
[]
Example 3.4.2: Let âŸ¨Î“, âˆ†, Î¨, Î˜âŸ©be the CSL theory of cartesian closed categories (see
examples 2.2.2 and 2.5.3). On top of this, as we have seen in section 3.3.4, we can deï¬ne
a natural number object by
left object nat with pr is
zero: 1 â†’nat
succ: nat â†’nat
end object.

CHAPTER 3. CATEGORICAL DATA TYPES
73
The CSL statements characterizing this object are
pr(f, g) â—¦zero = f
(LEQnat,1)
pr(f, g) â—¦succ = g â—¦pr(f, g)
(LEQnat,2)
h â—¦zero = f âˆ§h â—¦succ = g â—¦h â‡’h = pr(f, g)
(LCEQnat)
The CSL extension Ïƒnat associated with the declaration above is:
âŸ¨Î“, âˆ†, Î¨âŸ©
Ïƒnat
âˆ’âˆ’âˆ’â†’âŸ¨Î“ âˆª{nat}, âˆ†âˆª{zero, succ}, Î¨ âˆª{pr},
Î˜ âˆª{LEQnat,1, LEQnat,2, LCEQnat}âŸ©[]
Thus, each CDT declaration can be associated with a CSL theory extension. This can
be thought as a semantics of CDT declarations. However, it is sometimes convenient
to regard their semantics to be real categories.
Deï¬nition 3.4.3: A sequence of CDT declarations D1, . . . , Dl deï¬nes a sequence of
CSL theory extensions starting from the empty CSL theory.
âŸ¨âˆ…, âˆ…, âˆ…, âˆ…âŸ©
ÏƒD1
âˆ’âˆ’âˆ’â†’âŸ¨Î“1, âˆ†1, Î¨1, Î˜1âŸ©
ÏƒD2
âˆ’âˆ’âˆ’â†’Â· Â· Â·
ÏƒDl
âˆ’âˆ’âˆ’â†’âŸ¨Î“l, âˆ†l, Î¨l, Î˜lâŸ©
We deï¬ne a CSL structure of the CDT declaration sequence D1, . . . , Dl to be a category
which is a CSL theory structure of âŸ¨Î“l, âˆ†l, Î¨l, Î˜lâŸ©, and the free structure of D1, . . . , Dl
to be the free category of this CSL theory (see section 2.6). []
If we do not rely on any ways of deï¬ning functors other than CDT declarations and if
we do not accept any pre-deï¬ned functors, it is inevitable to start with the empty CSL
theory. We have deï¬ned cartesian closed categories as a CSL theory in examples 2.2.2
and 2.5.3, but we can do so in CDT starting from the empty theory by just declaring the
terminal object (see subsection 3.3.1), products (see subsection 3.3.2) and exponentials
(see subsection 3.3.3). The advantage of the latter is that we neither need to think
about equations nor need to do tedious typing of functors, natural transformations or
factorizers. These things come out automatically, so it is easy to deï¬ne categories and
there is less chance to make mistakes.
We have introduced CDT declarations from Left and Right, but we could not connect
them formally. Now, after having models of CDT as categories, we can do so.
Proposition 3.4.4: Let âŸ¨C, Î¾âŸ©be a CSL structure of a CDT declaration sequence D1,
. . . , Dl. If Di is
left object L(X1, . . . , Xn) with Ïˆ is
Î±1: E1 â†’Eâ€²
1
Â· Â· Â·
Î±m: Em â†’Eâ€²
m
end object
then Î¾L = Left(âƒ—F, âƒ—G) where
âƒ—F def
= âŸ¨Î¾Î»(L, X1, . . . , Xn).E1, . . . , Î¾Î»(L, X1, . . . , Xn).EmâŸ©
âƒ—G def
= âŸ¨Î»(L, X1, . . . , Xn).Eâ€²
1, . . . , Î»(L, X1, . . . , Xn).Eâ€²
mâŸ©.

CHAPTER 3. CATEGORICAL DATA TYPES
74
Name
CDT Declaration
CSL Statements
Terminal
right object 1 with !
end object
f = !
Initial
left object 0 with !!
end object
f = !!
Products
right object prod(X, Y ) with pair is
pi1: prod â†’X
pi2: prod â†’Y
end object
pi1 â—¦pair(f, g) = f
pi2 â—¦pair(f, g) = g
h = pair(pi1 â—¦h, pi2 â—¦h)
prod(f, g) = pair(f â—¦pi1, g â—¦pi2)
Coproducts
left object coprod(X, Y ) with case is
in1: X â†’coprod
in2: Y â†’coprod
end object
case(f, g) â—¦in1 = f
case(f, g) â—¦in2 = g
h = case(h â—¦in1, h â—¦in2)
coprod(f, g) = case(in1 â—¦f, in2 â—¦g)
Exponentials
right object exp(X, Y ) with curry is
eval: prod(exp, X) â†’Y
end object
eval â—¦prod(curry(f),I) = f
h = curry(eval â—¦prod(h,I))
exp(f, g) = curry(g â—¦eval â—¦prod(I, f))
NNO
left object nat with pr is
zero: 1 â†’nat
succ: nat â†’nat
end object
pr(f, g) â—¦zero = f
pr(f, g) â—¦succ = g â—¦pr(f, g)
h â—¦succ = g â—¦h â‡’h = pr(h â—¦zero, g)
Lists
left object list(X) with prl is
nil: 1 â†’list
cons: prod(X, list) â†’list
end object
prl(f, g) â—¦nil = f
prl(f, g) â—¦cons = prod(I, prl(f, g)) â—¦g
h â—¦cons = prod(I, h) â—¦g â‡’
h = prl(h â—¦nil, g)
list(f) = prl(nil, cons â—¦prod(f,I))
Inï¬nite Lists
right object inï¬‚ist(X) with fold is
head: inï¬‚ist â†’X
tail: inï¬‚ist â†’inï¬‚ist
end object
head â—¦fold(f, g) = f
tail â—¦fold(f, g) = fold(f, g) â—¦g
tail â—¦h = g â—¦h â‡’h = fold(head â—¦h, g)
inï¬‚ist(f) = fold(f â—¦head, tail)
Co-NNO
right object conat with copr is
pred: conat â†’coprod(1, conat)
end object
pred â—¦copr(f) = coprod(I, copr(f)) â—¦f
h â—¦pred = f â—¦coprod(I, h) â‡’
h = copr(f)
Automata
right object dynâ€²(I, O) with univâ€² is
nextâ€²: prod(dynâ€², I) â†’dynâ€²
outputâ€²: dynâ€² â†’O
end object
nextâ€² â—¦prod(univâ€²(f, g),I) = univâ€²(f, g) â—¦f
outputâ€² â—¦univâ€²(f, g) = g
nextâ€² â—¦prod(h,I) = h â—¦f â‡’
h = univâ€²(f, outputâ€² â—¦h)
Figure 3.1: CDT Objects
The similar thing holds for right CDT declarations.
Proof: Trivial, because we set the CSL statements so that this proposition holds. []
Finally, in this section, let us summarize the objects we have deï¬ned in this chapter
and their characteristic CSL statements in ï¬gure 3.1.
3.5
Existence of Left and Right
In section 3.1, we have introduced functors Left[F, G] and Right[F, G] with the con-
dition which characterizes them, but we did not consider whether such functors exist
or not. In this section, we study them mathematically and present a condition of the
existence.
Let us recall the standard construction of initial T-algebras (see, for example, [Scott
76, Lehmann and Smyth 81]).
Proposition 3.5.1: For a Ï‰-cocomplete category C (i.e. it has colimit of any Ï‰-chain

CHAPTER 3. CATEGORICAL DATA TYPES
75
diagram) and an endo-functor T: C â†’C which is Ï‰-cocontinuous (i.e. it preserves
colimit of any Ï‰-chain diagram), its initial T-algebra is given by the colimit of the
following Ï‰-chain diagram.10
0
!!
âˆ’â†’T(0)
T(!!)
âˆ’âˆ’âˆ’â†’T 2(0)
T 2(!!)
âˆ’âˆ’âˆ’âˆ’â†’Â· Â· Â·
T nâˆ’1(!!)
âˆ’âˆ’âˆ’âˆ’âˆ’â†’T n(0)
T n(!!)
âˆ’âˆ’âˆ’âˆ’â†’Â· Â· Â· []
As we presented in section 3.1, Left[F, G] is a generalization of initial T-algebras, where
F is a functor of C Ã— D â†’E and G is of C Ã— Dâˆ’â†’E. We will reduce the existence
problem of Left to that of corresponding T-algebras. For a D object A, from its deï¬ni-
tion âŸ¨Left[F, G](A), Î·AâŸ©is the initial object in the category DAlg(F( Â· , A), G( Â· , A)),
so
F(Left[F, G](A), A)
-
Î·A
G(Left[F, G](A), A)
Now, if G( Â· , A) has a left adjoint functor, say H( Â· , A): E â†’C, this morphism Î·A has
its one-to-one corresponding morphism
H(F(Left[F, G](A), A), A)
- Left[F, G](A).
This means that Left[F, G](A) is a T-algebra, where T(B) def
= H(F(B, A), A), and we
naturally expect this T-algebra to be special. It really is the initial T-algebra, so we
can formulate the following theorem.
Theorem 3.5.2: Let F: C Ã— D â†’E and G: C Ã— Dâˆ’â†’E be functors. If
1. C is Ï‰-cocomplete,
2. for each D object A, GA
def
= G( Â· , A): C â†’E has a left adjoint HA: E â†’C, and
3. for each D object A, FA
def
= F( Â· , A): C â†’E is Ï‰-cocontinuous,
then Left[F, G](A) exists in C and
Left[F, G](A) = colimit
n
(HA â—¦FA)n(0)
Proof: Since a left adjoint is cocontinuous, TA
def
= HA â—¦FA is Ï‰-cocontinuous if FA
is so. All we have to show is that the initial TA-algebra gives the initial object of
DAlg(FA, GA), and the rest follows from proposition 3.5.1.
Let the initial TA-algebra be I paired with a morphism
HA(FA(I))
-
Î¹
I.
10In general, this sequence might not converge at Ï‰. In such a case, we may extend the sequence up to
any ordinal such that
1. T Î±+1(0) = T(T Î±(0)), and
2. T Î²(0) = colimit
Î±<Î²
T Î±(0) for a limit ordinal Î² (treating 0 as a limit ordinal).

CHAPTER 3. CATEGORICAL DATA TYPES
76
For an object âŸ¨B, fâŸ©in DAlg(FA, GA)
FA(B)
-
f
GA(B)
we have to construct the unique morphism from I to B which makes a certain diagram
commute. To do so, let us name the factorizer of the adjunction HA 7âˆ’GA Ïˆ, that is,
Ïˆ is the natural isomorphism HomC(HA(C), D)
âˆ¼
=
âˆ’â†’HomE(C, GA(D)). Then, Ïˆâˆ’1(f)
gives a TA-algebra
HA(FA(B))
-
Ïˆâˆ’1(f)
B
and since âŸ¨I, Î¹âŸ©is the initial TA-algebra, there exists a unique morphism g: I â†’B such
that the following diagram commutes.
HA(FA(I))
Î¹
I
HA(FA(g))
Â¥
Â¨Â§?
g
HA(FA(B))
Ïˆâˆ’1(f)
B
-
?
?
-
(âˆ—)
The naturality of Ïˆ converts this diagram to the following commutative diagram.
FA(I)
Ïˆ(Î¹)
GA(I)
-
FA(g)
Â¥
Â¨Â§?
GA(g)
?
?
FA(B)
f
- GA(B)
(âˆ—âˆ—)
(i.e. Ïˆ(g â—¦Î¹) = GA(g) â—¦Ïˆ(Î¹) and Ïˆ(Ïˆâˆ’1(f) â—¦HA(FA(g))) = f â—¦FA(g)). That showed
the existence of g. The uniqueness of g is no more diï¬ƒcult. If g: I â†’B satisï¬es (âˆ—âˆ—),
then by applying Ïˆâˆ’1 we get (âˆ—) back again and so there g should be unique. []
Example 3.5.3: Trivially, if E is C and G: C Ã— Dâˆ’â†’C is the projection functor, GA
is the identity which has the left adjoint HA which is also the identity functor. In this
case, the above theorem is essentially stating the same thing as proposition 3.5.1. []
Example 3.5.4: Another simple case is that E is C Ã— C and GA is the diagonal
functor.
Its left adjoint is the binary coproduct functor.
FA: C â†’C Ã— C can be

CHAPTER 3. CATEGORICAL DATA TYPES
77
decomposed into F â€²
A and F â€²â€²
A both of which are functors of C Ã— D â†’C such that
FA(B) = âŸ¨F â€²
A(B), F â€²â€²
A(B)âŸ©. The theorem states that Left[F, G](A) is the initial TA-
algebra where TA(B)
def
= F â€²
A(B) + F â€²â€²
A(B).
This explains that our natural number
object in subsection 3.3.4 is the initial T-algebra where T(B) def
= 1 + B. []
Theorem 3.5.2 has its dual form for Right[F, G].
Theorem 3.5.5: Let F: C Ã— D â†’E and G: C Ã— Dâˆ’â†’E be functors. If
1. C is Ï‰-complete,
2. for each D object A, FA
def
= F( Â· , A): C â†’E has a right adjoint KA: E â†’C, and
3. for each D object A, GA
def
= G( Â· , A): C â†’E is Ï‰-continuous,
then Right[F, G](A) exists in C and
Right[F, G](A) = limit
n (KA â—¦FA)n(1)
[]
Example 3.5.6: As an application of this theorem, let us calculate dynâ€²(I, O). For
this, we should take D to be C Ã— Câˆ’, E to be C Ã— C, F: C Ã— C Ã— Câˆ’â†’C Ã— C to be
F(A, I, O) def
= âŸ¨A Ã— I, AâŸ©and G: C Ã— Câˆ’Ã— C â†’C Ã— C to be G(A, I, O) def
= âŸ¨A, OâŸ©.
FI,O has a right adjoint HI,O(D, E) def
= exp(I, D)Ã—E. Therefore, dynâ€²(I, O) is the ï¬nal
TI,O-coalgebra, where TI,O(A) def
= HI,O(GI,O(A)) = exp(I, A)Ã—O. Now, let us calculate
limit
n
T n
I,O(1).
T 0
I,O(1) âˆ¼= 1
T 1
I,O(1) âˆ¼= exp(I, 1) Ã— O âˆ¼= O âˆ¼= exp(1, O)
T 2
I,O(1) âˆ¼= TI,O(O) âˆ¼= exp(I, O) Ã— O âˆ¼= exp(1 + I, O)
T 3
I,O(1) âˆ¼= exp(I, exp(1 + I, O)) Ã— O
âˆ¼= exp(I Ã— (1 + I), O) Ã— O
âˆ¼= exp(1 + I + I2, O)
Â· Â· Â·
T n
I,O(1) âˆ¼= exp(1 + I + I2 + Â· Â· Â· + Inâˆ’1, O)
Â· Â· Â·
Therefore, dynâ€²(I, O) âˆ¼= limit
n
T n
I,O(1) âˆ¼= exp(1 + I + I2 + Â· Â· Â· , O) âˆ¼= exp(list(I), O). []

Chapter 4
Computation and Categorical Data
Types
In chapter 2 section 2.4, we introduced CSL expressions Exp(Î“, âˆ†, Î¨) which denote
polymorphic functions in CSL structures. In this chapter, we will see them as programs
and see how they can be executed. One of the ways to treat speciï¬cations as programs
is to regard equations as rewrite rules, but in our case, CSL statements are in general
conditional equations and, therefore, it is quite diï¬ƒcult to treat them as rewrite rules.
Furthermore general rewriting cannot be regarded as real computation unless rules are
Church-Rosser, otherwise, rewriting is more close to theorem proving.
There is no other way so long as we are dealing with CSL speciï¬cations. Remember
that CSL was introduced in order to give semantics to categorical data types we have
investigated in chapter 3. In CDT theory, we are not dealing with arbitrary CSL spec-
iï¬cations, but some special ones, ones which are associated with CDT declarations.
Therefore, we have much more hope for executing these special CSL speciï¬cations
than arbitrary ones. For example, cartesian closed categories are, as is well-known,
connected to lambda calculus which is a model of computation, so we can put some
evaluation mechanism into them. [Curien 86], for example, has developed such a sys-
tem. A diï¬€erence of our approach from his is that we do not restrict ourselves only to
cartesian closed categories. One of the main aims of CDT is to study categories formed
by programming languages, and we should not presume any structure in the categories
without proper reasons. We can only accept the cartesian closed structure in CDT if
this is necessary for putting the concept of computation to it. As we will see later in
this chapter, our categories are cartesian closed (with some extra structure), and by
then we should know why the cartesian closed structure is necessary.
CSL expressions in section 2.4 and the CDT declaration mechanism in chapter 3 give
us the basis of Categorical Programming Language (CPL) to which we will devote
this chapter. CPL tries to extract the computable part of CDT. As we have seen in
subsection 3.3.8, CDT in general allows us to deï¬ne very strange objects which have
no concept of being computable. We are going to put restrictions to the form of CDT
declarations in CPL.
78

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
79
Therefore, in CPL, we can declare data types by CDT (with restrictions). As we have
seen in section 3.4, this will determine a CSL in which we can have CSL expressions
introduced in section 2.4.
CSL expressions are the programs in CPL. There is no
diï¬€erence between programs and data. From the categorical point of view, there is
nothing inside objects, that is, there are no data inside data types. CSL expressions
whose domain is the terminal object are called CPL elements. The execution in CPL
is essentially a reduction of a CPL element to a canonical irreducible CPL element.
Following the result of this chapter, CPL will not only exist on paper, but also can be
implemented. This will be presented in chapter 5.
In section 4.1 we introduce a restriction to objects we can declare in CPL and a set of
reduction rules for CPL computation. In section 4.2 we see an example of computation
in CPL. In section 4.3 we prove that any computation in CPL terminates (i.e. the
reductions are normalizing) by Taitâ€™s computability method. In section 4.4 we show
some properties about objects in CPL and, ï¬nally, section 4.5 gives another set of
reduction rules for CPL computation which reduces CPL elements into intuitively
more canonical elements.
4.1
Reduction Rules for Categorical Programming
Language
In this section, we will present some basic deï¬nitions together with the reduction rules
for CPL. Let us assume in the following discussion that we have deï¬ned categorical
data types by a sequence of CDT declarations, D1, . . . , Dl, and that we have obtained
the corresponding CSL, âŸ¨Î“, âˆ†, Î¨, Î˜âŸ©as in deï¬nition 3.4.3.
In ordinary programming languages, we distinguish programs and data. We feed data
into a program; it processes the data and then outputs the result data. We cannot
feed a program into another program and data cannot process other data or programs.
However, it is true that data are a special kind of programs, very simple ones. We can
write data directly into programs as initialization statements or as assignments. For
example, natural numbers like 1, 132, 59, etc. are data as well as constants in programs.
In some languages like LISP, there is no diï¬€erence between data and programs at all.
CPL is not as liberated as LISP, but both data and programs are morphisms and data
are just special morphisms having a special domain object.
As we know, category theory deals with the external structure of objects rather than
their inner structure so it is not proper to think about data inside objects. However,
we do sometimes need something similar to elements in set theory. We say elements in
category theory are morphisms whose domain is the terminal object.
1
e
âˆ’â†’A
We say e is an element of A. If we think in the category of sets (Set), â€˜1â€™ is the one-
point set and a morphism from the one-point set to a set corresponds to an element in

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
80
the set.
HomSet(1, A) âˆ¼= A
Hence, the deï¬nition of elements in CPL is:
Deï¬nition 4.1.1: Given a CSL signature âŸ¨Î“, âˆ†, Î¨âŸ©, a CPL element e is a CSL expres-
sion with no morphism variables whose domain type is the terminal object.
Ï âŠ¢e: Î»(X1, . . . , Xn).1 â†’K
(see section 2.4 for typing). In case n = 0 which is very often the case, we may write
âŠ¢e: 1 â†’E where E is a functorial expression without variables. We also say that e is
an element of E. []
In order for this deï¬nition to be sensible, we need to have the terminal object in our
category. For simplicity, we assume that D1 is the CDT declaration of the terminal
object as is presented in subsection 3.3.1.
Though this deï¬nition is a natural way of deï¬ning elements in category theory, it
introduces non-symmetry in CPL. Remember that CDT is meant to be symmetric:
e.g. if we have an object of natural numbers, we should have its dual, an object of
co-natural numbers, and so on. Since we treat â€˜1â€™ as a special object and the elements
in CPL are deï¬ned in this way, we destroy the beauty of symmetry. We will see the
consequence of this shortly.
Example 4.1.2: Assume that we have deï¬ned all the objects in section 3.3. Then
succ â—¦zero,
pi2 â—¦pair(succ â—¦zero, nil),
eval â—¦prod(pr(curry(pi2), curry(succ â—¦eval)), I) â—¦pair(succ â—¦succ â—¦zero, succ â—¦zero)
are all CPL elements. []
As we can see from this example, we cannot regard all the elements as data. â€˜succâ—¦zeroâ€™
and â€˜pair(succ â—¦zero, nil)â€™ can be data, but â€˜pi1 â—¦pair(succ â—¦zero, nil)â€™ cannot be. We
call special data-like CPL elements canonical CPL elements. The deï¬nition is:
Deï¬nition 4.1.3: A canonical CPL element is a CPL element which wholly consists
of natural transformations introduced by left objects and factorizers by right objects.
Formally, a canonical CPL element, c âˆˆCE, is deï¬ned by
c : : = I | Î±L â—¦c | ÏˆR(e1, . . . , en) â—¦c
where Î±L is a natural transformation of a left object and ÏˆR is a factorizer of a right
object. Note we often do not write I at the tail of canonical elements. []
From this deï¬nition, â€˜pairâ€™ and â€˜curryâ€™ can form canonical elements, but â€˜pi1â€™, â€˜pi2â€™ or
â€˜evalâ€™ cannot. So for the right objects, factorizers are the means of creating canonical
elements. On the other hand, â€˜zeroâ€™, â€˜succâ€™ and â€˜consâ€™ can form canonical elements,

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
81
but not â€˜prâ€™ or â€˜caseâ€™. So for the left objects, natural transformations are the means of
creating canonical elements.
Canonical
Non-Canonical
left object
natural transformations
e.g. zero, succ, nil, cons
factorizers
e.g. case, pr, prl
right object
factorzers
e.g. pair, curry
natural transformations
e.g. pi1, pi2, eval
Deï¬nition 4.1.3 is beautifully symmetrical as we hoped from the symmetry of CDT.
In addition, if we look at the canonical elements in other programming languages, we
note that â€˜pairâ€™ corresponds to making pairs of data, â€˜curryâ€™ corresponds to lambda
abstraction and both create canonical things (i.e. we cannot process them any more as
themselves), and also we note that â€˜prâ€™ and â€˜caseâ€™ are programming constructs corre-
sponding to primitive recursive deï¬nitions and case statements and they can never be
data. Therefore, deï¬nition 4.1.3 ï¬ts well with the usual notion of data.
Of course, this is not the only deï¬nition of canonical elements. It deï¬nes quite lazy
canonical elements. It does not care what are inside factorizers. For example,
pair(pi1 â—¦pair(succ â—¦zero, nil), zero)
is a canonical element of â€˜prod(nat, nat)â€™ from this deï¬nition. Some might not want to
call it canonical because it is equal to another canonical element
pair(succ â—¦zero, zero)
which looks more canonical. However, this is because â€˜prodâ€™ is a rather special object.
In general, expressions inside factorizers may not be elements, so we cannot demand
them to be canonical (or we have to treat product-like objects special). One might still
accept this easily since canonical elements in Martin-LÂ¨ofâ€™s type theory are similar to
ours, but another queer aspect of our deï¬nition is that we accept
pair(pi2, pi1) â—¦pair(succ, I) â—¦zero
as a canonical element. It is equal to the following element
pair(pi2 â—¦pair(succ, I) â—¦zero, pi1 â—¦pair(succ, I) â—¦zero),
but this is again because of the special property of â€˜prodâ€™. In general
ÏˆR(e1, . . . , en) â—¦c
is not equal to something in the form of ÏˆR(eâ€²
1, . . . , eâ€²
n). For example, we cannot always
ï¬nd other simpler canonical elements which is equal to â€˜fold(f, g) â—¦câ€™ (where â€˜foldâ€™ is
the factorizer of â€˜inï¬‚istâ€™).
There are many views of computation, but in CPL computation is the reduction of an
element to a canonical element equal to the given element.
e â‡’c

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
82
Since the reduction is not straightforward, we want to do step-by-step reduction. There-
fore, we modify the above form of reduction to the following one.
âŸ¨e, câŸ©â‡’câ€²
This means that a CSL expression e applied to a CPL canonical element c is reduced
to a CPL canonical element câ€². It is like calculating the result of applying an element
c to a function e. Obviously, e â—¦c should be semantically equal to câ€². Since a CPL
element is a morphism from the terminal object and â€˜Iâ€™ is its canonical element, if we
want to reduce an arbitrary CPL element e we can ask for the following reduction.
âŸ¨e, IâŸ©â‡’c
In the following, we assume that the associativity of â€˜â—¦â€™ (the composition of morphisms)
has been taken care by some means so that in our rules we do not consider it. We
also assume that there are no functors in CPL elements because we can always replace
them with factorizers and natural transformations. For example,
eval â—¦prod(curry(succ), nil)
is equivalent to
eval â—¦pair(curry(succ) â—¦pi1, nil â—¦pi2).
Let us now deï¬ne rules for the reductions. The simplest one is for identities. Since Iâ—¦c
is equal to c, we should have the following rule.
âŸ¨I, câŸ©â‡’c
(IDENT)
Next, for the composition, we naturally have
âŸ¨e2, câŸ©â‡’câ€²â€²
âŸ¨e1, câ€²â€²âŸ©â‡’câ€²
âŸ¨e1 â—¦e2, câŸ©â‡’câ€²
(COMP)
In case that e is a natural transformation introduced by a left object or a factorizer
introduced by a right object, the rule is easy because the composition of e with a
canonical element is canonical by deï¬nition 4.1.3.
âŸ¨Î±L, câŸ©â‡’Î±L â—¦c
(L-NAT)
âŸ¨ÏˆR(e1, . . . , en), câŸ©â‡’ÏˆR(e1, . . . , en) â—¦c
(R-FACT)
For example, âŸ¨succ, zeroâŸ©â‡’succ â—¦zero and
âŸ¨curry(pi2), pair(zero, succ â—¦zero)âŸ©â‡’curry(pi2) â—¦pair(zero, succ â—¦zero).
Diï¬ƒculty comes in for the other cases, i.e. when e is a natural transformation of a right
object or a factorizer of a left object. Let us ï¬rst consider the case for a factorizer ÏˆL
introduced by the following left object.
left object L(X) with ÏˆL is
Î±L: E(L, X) â†’Eâ€²(L, X)
end object

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
83
From the property of this object, we have a CSL equation
Eâ€²(ÏˆL(e), I) â—¦Î±L = e â—¦E(ÏˆL(e), I).
An instance of this equation is â€˜pr(f, g)â—¦succ = g â—¦pr(f, g)â€™, and in this case we should
have a rewrite rule from â€˜pr(f, g)â—¦succâ€™ to â€˜g â—¦pr(f, g)â€™. Therefore, in general we might
have the following rule.
âŸ¨e â—¦E(ÏˆL(e), I), câŸ©â‡’câ€²
âŸ¨Eâ€²(ÏˆL(e), I), Î±L â—¦câŸ©â‡’câ€²
However, this rule is not what we wanted. We wanted a rule for âŸ¨ÏˆL(e), câ€²â€²âŸ©â‡’câ€²â€²â€². In
order that the above rule to be a one we want, Eâ€²(L, X) should be simply L, and we
get
âŸ¨e â—¦E(ÏˆL(e), I), câŸ©â‡’câ€²
âŸ¨ÏˆL(e), Î±L â—¦câŸ©â‡’câ€²
.
(L-FACT)
The restriction that demands Eâ€²(L, X) should be L is the ï¬rst restriction we put onto
objects in order to obtain the CPL computation rules. The left objects introduced in
chapter 3, initial object, coproducts, natural number object and lists, all satisfy this
restriction except the left adjoint functor of â€˜listâ€™ which we do not expect to be in the
world of computation. If Eâ€²(L, X) is something other than L, we are allowing to have
the left adjoint Lâ€² of Eâ€²( Â· , X) by
left object Lâ€²(X, Y ) with ÏˆLâ€² is
Î±Lâ€²: Y â†’Eâ€²(LLâ€², X)
end object.
In familiar categories (e.g. the category of sets), a functor F: C â†’C hardly has a left
adjoint: e.g. the product functor â€¢ Ã— A does not have one, nor does the coproduct
functor â€¢ + A.
As an example of L-FACT, let us write the rules for the factorizer associated with the
natural number object. There are two rules for two natural transformations, â€˜zeroâ€™ and
â€˜succâ€™.
âŸ¨e, câŸ©â‡’câ€²
âŸ¨pr(e, eâ€²), zero â—¦câŸ©â‡’câ€²
âŸ¨eâ€² â—¦pr(e, eâ€²), câŸ©â‡’câ€²
âŸ¨pr(e, eâ€²), succ â—¦câŸ©â‡’câ€²
Let us now consider the last case, the case for the reduction rule of a natural transfor-
mation Î±R introduced by the following right object declaration.
right object R(X) with ÏˆR is
Î±R: E(R, X) â†’Eâ€²(R, X)
end object
From the property of this object, we have a CSL equation
Î±R â—¦E(ÏˆR(e), I) = Eâ€²(ÏˆR(e), I) â—¦e.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
84
An instance of this equation is â€˜pi1 â—¦pair(f, g) = fâ€™, and in this case we should have a
rule to rewrite â€˜pi1 â—¦pair(f, g)â€™ to â€˜fâ€™. Therefore, in general we have a rule rewriting
from the left-hand side to the right-hand side as the following rule.
âŸ¨Eâ€²(ÏˆR(e), I) â—¦e, câŸ©â‡’câ€²
âŸ¨Î±R, E(ÏˆR(e), I) â—¦câŸ©â‡’câ€²
However, this rule is not quite right because E(ÏˆR(e), I) â—¦c is not a canonical element.
We cannot have functors in canonical elements. Therefore, what the rule should really
look like is
c = E(ÏˆR(e), I) â—¦câ€²â€²
âŸ¨Eâ€²(ÏˆR(e), I) â—¦e, câ€²â€²âŸ©â‡’câ€²
âŸ¨Î±R, câŸ©â‡’câ€²
.
(+)
We now have a diï¬€erent problem of ï¬nding out an expression e and a canonical element
câ€²â€² from a given canonical element c such that
c = E(ÏˆR(e), I) â—¦câ€²â€².
Since we are dealing with computation, we need a mechanical way of solving this
problem. Let us introduce another form of reduction rules.
âŸ¨c, E, RâŸ©; âŸ¨ÏˆR(e), câ€²â€²âŸ©
(âˆ—)
such that c = E(ÏˆR(e), I)â—¦câ€²â€² where E is a functorial expression in which R is a variable.
By these rules, we can rewrite the rule (+) to
âŸ¨c, E(R, X), RâŸ©; âŸ¨ÏˆR(e), câ€²â€²âŸ©
âŸ¨Eâ€²(ÏˆR(e), I) â—¦e, câ€²â€²âŸ©â‡’câ€²
âŸ¨Î±R, câŸ©â‡’câ€²
.
(R-NAT)
We now have to list the rules for (âˆ—). If E is simply R itself, c should be E(ÏˆR(e), I) â—¦
câ€²â€² = ÏˆR(e) â—¦câ€²â€². Therefore, the rule should be
âŸ¨ÏˆR(e) â—¦câ€²â€², R, RâŸ©; âŸ¨ÏˆR(e), câ€²â€²âŸ©.
(R-NAT-V)
Next, if E(R, X) does not depend on R, c is E(ÏˆR(e), I) â—¦câ€²â€² = câ€²â€², so the rule may be
âŸ¨c, E, RâŸ©; âŸ¨ÏˆR(e), câŸ©,
but where does ÏˆR(e) come from? We cannot determine e. Therefore, E(R, X) must
not be independent from R (i.e. E(R, X) should not be free of R).
The case left is when E(R, X) is not a variable but a real functorial expression. Let it
be
F( Ë†E1(R, X), . . . , Ë†En(R, X)),
(1)
where F is a functor name. In this case, the equation we are solving is
c = F( Ë†E1(ÏˆR(e), I), . . . , Ë†En(ÏˆR(e), I)) â—¦câ€²â€².
(2)
Since functors are always represented by their associated factorizers, the equation looks
like
c = ÏˆF(Â· Â· Â· â—¦Ë†E1(ÏˆR(e), I) â—¦Â· Â· Â· â—¦Ë†En(ÏˆR(e), I) â—¦Â· Â· Â·) â—¦câ€²â€².
(3)

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
85
As we can see, we might have to pick up the same ÏˆR(e) from more than one place
and this would be a trouble.
Because ÏˆR(e) is a general CSL expression and we
cannot do theorem proving to show two CSL expressions are equal when doing the
CPL computation. Therefore, we need to restrict that ÏˆR(e) should appear only once
in (3). In order for this, we have to ï¬rst restrict that only one Ë†Ei in (2) contains
R. Without loss of generality, we can assume it is Ë†E1(R, X), and since we are only
interested in the ï¬rst argument of F, we assume that F is a unary functor and E(R, X)
is F( Ë†E(R, X)). Now (2) looks like
c = F( Ë†E(ÏˆR(e), I)) â—¦câ€²â€²,
(2â€²)
but still (3) might have more than one ÏˆR(e) because when we expand functors by
factorizers using (LFEQ) or (RFEQ) in deï¬nition 3.4.1, we might duplicate ÏˆR(e).
Before stating the restriction to guarantee the no-duplication of ÏˆR(e), let us note that
F should be a functor introduced by a right object declaration. This is because, if we
look at the equation (3), c is a canonical element consisting of left natural transforma-
tions and right factorizers, so ÏˆF should be a right factorizer. Let the following be the
declaration of F.
right object F(Y ) with ÏˆF is
Î²1: ËœE1(F, Y ) â†’ËœEâ€²
1(F, Y )
Â· Â· Â·
Î²m: ËœEm(F, Y ) â†’ËœEâ€²
m(F, Y )
end object
(4)
From the equation (RFEQ) in deï¬nition 3.4.1, (3) really is
c = ÏˆF( ËœEâ€²
1(I, Ë†E(ÏˆR(e), I)) â—¦Î²1 â—¦ËœE1(I, Ë†E(ÏˆR(e), I)),
Â· Â· Â·
ËœEâ€²
m(I, Ë†E(ÏˆR(e), I)) â—¦Î²m â—¦ËœEm(I, Ë†E(ÏˆR(e), I)) ) â—¦câ€²â€²
(3â€²)
In order that ÏˆR(e) should appear only once in this equation, Y should appear only
once in one of ËœEi and ËœEâ€²
i. In order to show that Y should not be in one of ËœEâ€²
i, let F be
simply
right object F(Y ) with ÏˆF is
Î²: Y â†’F
end object.
(4â€²)
(3) becomes
c = ÏˆF(Î² â—¦Ë†E(ÏˆR(e), I)) â—¦câ€²â€².
We may demand that c should be ÏˆF(Ë†e) â—¦Ë†c and ï¬nd ÏˆR(e) such that
Ë†e = Î² â—¦Ë†E(ÏˆR(e), I),
but how can we solve this equation? In general, we need theorem proving for this. We
should have reduced the problem recursively into
âŸ¨Ë‡c, Ë‡E, RâŸ©; âŸ¨ÏˆR(e), Ë‡câŸ©,

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
86
but there is no way to do this if Y appears in one of ËœEi, because Ë†e should never be an
element. The typing rule in deï¬nition 3.2.2 gives us
Ë†e: Y â†’Z
ÏˆF(Ë†e): Z â†’F(Y )
and we cannot choose Y to be the terminal object. If Y and F were the other way
round in (4â€²), we could choose Z to be the terminal object to make Ë†e an element.
Therefore, if Y is in one of ËœEâ€²
i in (4), we have a possibility of reducing the problem of
solving (3â€²) into a smaller problem of the same kind. Without losing generality, we can
assume that Y only appears in ËœEâ€²
1 in (4). Now, (3â€²) is
c = ÏˆF( ËœEâ€²
1(I, Ë†E(ÏˆR(e), I)) â—¦Î²1, Î²2, . . . , Î²m) â—¦câ€²â€².
(3â€²â€²)
We demand c to be ÏˆF(Ë†e1, Ë†e2, . . . , Ë†em) â—¦Ë†c, so (3â€²â€²) is further rewritten to
ÏˆF(Ë†e1, Ë†e2, . . . , Ë†em) â—¦Ë†c = ÏˆF( ËœEâ€²
1(I, Ë†E(ÏˆR(e), I)) â—¦Î²1, Î²2, . . . , Î²m) â—¦câ€²â€².
(3â€²â€²â€²)
Here, we cannot jump to the conclusion that Ë†e1 is ËœEâ€²
1(I, Ë†E(ÏˆR(e), I)) â—¦Î²1, Ë†e2 is Î²2,
. . . , and Ë†c is câ€²â€², because a part of Ë†c may well contribute to form ËœEâ€²
1(I, Ë†E(ÏˆR(e), I)).
What is desirable is that we could rewrite ÏˆF(Ë†e1, Ë†e2, . . . , Ë†em) â—¦Ë†c to ÏˆF(Ë†eâ€²
1, Ë†eâ€²
2, . . . , Ë†eâ€²
m)
like pair(f, g) â—¦h = pair(f â—¦h, g â—¦h). This is possible when each ËœEâ€²
i in (4) does not
depend on F.
Proposition 4.1.4: Let R be a right object deï¬ned by
right object R(X1, . . . , Xn) with ÏˆR is
Î±1: E1(R, X1, . . . , Xn) â†’Eâ€²
1(X1, . . . , Xn)
Â· Â· Â·
Î±m: Em(R, X1, . . . , Xn) â†’Eâ€²
m(X1, . . . , Xn)
end object
(note that Eâ€²
i does not depend on R), then
ÏˆR(e1, . . . , em) â—¦eâ€² = ÏˆR(e1 â—¦E1(eâ€², I, . . . , I), . . . , em â—¦Em(eâ€², I, . . . , I))
(REQC)
Proof: From (RCEQ) in deï¬nition 3.4.1,
Î±1 â—¦E1(ÏˆR(e1, . . . , em) â—¦eâ€², I, . . . , I) = f1 âˆ§
Â· Â· Â·
Î±m â—¦Em(ÏˆR(e1, . . . , em) â—¦eâ€², I, . . . , I) = fm âˆ§
â‡’ÏˆR(e1, . . . , em) â—¦eâ€² = ÏˆR(f1, . . . , fm).
Using (REQi) and the fact that Ei is covariant in R, we get
e1 â—¦E1(eâ€², I, . . . , I) = f1 âˆ§. . . âˆ§em â—¦Em(eâ€², I, . . . , I) = fm
â‡’ÏˆR(e1, . . . , em) â—¦eâ€² = ÏˆR(f1, . . . , fm).
Therefore,
ÏˆR(e1, . . . , em) â—¦câ€² = ÏˆR(e1 â—¦E1(eâ€², I, . . . , I), . . . , em â—¦Em(eâ€², I, . . . , I)). []

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
87
We call this kind of right objects unconditioned. The name indicates that the objects
are characterized without using conditional CSL equations. In fact, (REQi), (REQC),
(RFEQ) and the following (REQI) characterize the unconditioned right objects.1
ÏˆR(Î±1, . . . , Î±m) = I
(REQI)
Therefore, we assume that in (4) F does not appear in any of ËœEâ€²
i. As we have already
assumed that Y appears only in ËœEâ€²
1, (4) now looks like
right object F(Y ) with ÏˆF is
Î²1: ËœE1(F) â†’ËœEâ€²
1(Y )
Î²2: ËœE2(F) â†’ËœEâ€²
2
Â· Â· Â·
Î²m: ËœEm(F) â†’ËœEâ€²
m
end object
( ËœEâ€²
2, . . . , ËœEâ€²
m do not depend on F or Y in this case, but in general F might have
parameters other than Y and they can appear in ËœEâ€²
2, . . . , ËœEâ€²
m), and (3) is
ÏˆF(Ë†e1 â—¦ËœE1(Ë†c), Ë†e2 â—¦ËœEe(Ë†c), . . . , Ë†em â—¦ËœEm(Ë†c))
= ÏˆF( ËœEâ€²
1( Ë†E(ÏˆR(e), I)) â—¦Î²1 â—¦ËœE1(câ€²â€²), Î²2 â—¦ËœE2(câ€²â€²), . . . , Î²m â—¦ËœEm(câ€²â€²)).
(Ë†3)
If, furthermore, the ï¬rst argument of ÏˆF is an element, we can reduce the problem of
solving (3) into
Ë†e1 â—¦ËœE1(Ë†c) = ËœEâ€²
1( Ë†E(ÏˆR(e), I)) â—¦Î²1 â—¦ËœE1(câ€²â€²).
(5)
Since Ë†e1 â—¦ËœE1(Ë†c) is an element, we can ask its canonical element and it becomes almost
like the original object (3) except E is replaced. Let us see the typing rule for ÏˆF
deï¬ned in deï¬nition 3.2.2.
f1: ËœE1(Z) â†’ËœEâ€²
1(Y )
. . .
ÏˆF(f1, . . .): Z â†’F(Y )
Since ÏˆF in (Ë†3) is making an element, Z above should be the terminal object 1. In
order that f1 above is also an element, ËœE1(Z) (or ËœE1(1) because Z is 1) should also
the terminal object. Because ËœE1(Z) cannot be independent from Z, ËœE1(Z) should be
simply Z. Therefore, (5) is
Ë†e1 â—¦Ë†c = ËœEâ€²
1( Ë†E(ÏˆR(e), I)) â—¦Î²1 â—¦câ€²â€².
(5â€²)
As Ë†e1 â—¦Ë†c is an element, we can ask its canonical element by
âŸ¨Ë†e1, Ë†câŸ©â‡’Ë†câ€²,
(6)
and we can also ask to solve
Ë†câ€² = ËœEâ€²
1( Ë†E(ÏˆR(e), I)) â—¦Ë†câ€²â€²
(7)
1We can deï¬ne unconditioned left objects as dual.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
88
by
âŸ¨Ë†câ€², ËœEâ€²
1( Ë†E(R, X)), RâŸ©; âŸ¨ÏˆR(e), Ë†câ€²â€²âŸ©.
If we set câ€²â€² to be
ÏˆF(Ë†câ€²â€², Ë†e2 â—¦Ë†E2(Ë†c), . . . , Ë†em â—¦Ë†Em(Ë†c)),
(Ë†3) is satisï¬ed from (REQi) in deï¬nition 3.4.1.
ËœEâ€²
1( Ë†E(ÏˆR(e), I)) â—¦Î²1 â—¦ËœE1(câ€²â€²)
= ËœEâ€²
1( Ë†E(ÏˆR(e), I)) â—¦Î²1 â—¦ËœE1(ÏˆF(Ë†câ€²â€², Ë†e2 â—¦Ë†E2(Ë†c), . . . , Ë†em â—¦Ë†Em(Ë†c)))
= ËœEâ€²
1( Ë†E(ÏˆR(e), I)) â—¦Î²1 â—¦Ë†câ€²â€²
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .(from (REQi))
= Ë†câ€²
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (from (7))
= Ë†e1 â—¦Ë†c
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (from (6))
Î²i â—¦ËœEi(câ€²â€²)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (i = 2, . . . , m)
= Î²i â—¦ËœEi(ÏˆF(Ë†câ€²â€², Ë†e2 â—¦Ë†E2(Ë†c), . . . , Ë†em â—¦Ë†Em(Ë†c)))
= Ë†ei â—¦ËœEi(Ë†c)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (from (REQi))
Therefore, we got the following rule.
âŸ¨Ë†e1, Ë†câŸ©â‡’Ë†câ€²
âŸ¨Ë†câ€², ËœEâ€²
1( Ë†E(R, X)), RâŸ©; âŸ¨ÏˆR(e), Ë†câ€²â€²âŸ©
âŸ¨ÏˆF(Ë†e1, Ë†e2, . . . , Ë†em) â—¦Ë†c, F( Ë†E(R, X)), RâŸ©
; âŸ¨ÏˆR(e), ÏˆF(Ë†câ€²â€², Ë†e2 â—¦ËœE2(Ë†c), . . . , Ë†em â—¦Ë†Em(Ë†c))âŸ©
(R-NAT-F)
As an example of the rules (R-FACT), (R-NAT), (R-NAT-V) and (R-NAT-F), let us
write the rules for the exponentials. The CDT declaration of the exponentials is
right object exp(X, Y ) with curry is
eval: prod(exp, X) â†’Y
end object
as we have seen in subsection 3.3.3. The rule (R-FACT) is simply
âŸ¨curry(e), câŸ©â‡’curry(e) â—¦c,
and the rule (R-NAT) is
âŸ¨c, prod(exp, X), expâŸ©; âŸ¨curry(e), câ€²â€²âŸ©
âŸ¨e, câ€²â€²âŸ©â‡’câ€²
âŸ¨eval, câŸ©â‡’câ€²
.
The rule (R-NAT-V) is simply
âŸ¨curry(e) â—¦câ€²â€², exp, expâŸ©; âŸ¨curry(e), câ€²â€²âŸ©,
and, ï¬nally, the rule (R-NAT-F) is
âŸ¨Ë†e1, Ë†câŸ©â‡’Ë†câ€²
âŸ¨Ë†câ€², exp, expâŸ©; âŸ¨curry(e), Ë†câ€²â€²âŸ©
âŸ¨pair(Ë†e1, Ë†e2) â—¦Ë†c, prod(exp, X), expâŸ©; âŸ¨curry(e), pair(Ë†câ€²â€², Ë†e2 â—¦Ë†c)âŸ©
.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
89
We may simplify the last three rules and have the next one instead.
âŸ¨e1, câŸ©â‡’curry(e) â—¦câ€²â€²
âŸ¨e, pair(câ€²â€², e2 â—¦c)âŸ©â‡’câ€²
âŸ¨eval, pair(e1, e2) â—¦câŸ©â‡’câ€²
We will see an example using these rules in the next section.
In order to obtain (R-NAT-F), we have put several restrictions to the right object
declaration. To state the restrictions formally, let us introduce the notion â€˜productiveâ€™.
Deï¬nition 4.1.5: Functorial expressions which are productive in X are generated by
the following two rules.
1. X itself is a functorial expression productive in X.
2. If P(Y1, . . . , Yn) is a functor which is productive in Yi and E is a functorial
expression productive in X, P(E1, . . . , Eiâˆ’1, Ei, Ei+1, . . . , En) is productive in X,
where E1, . . . , Eiâˆ’1, Ei+1, . . . , En are functorial expressions which do not contain
X.
A functor P(Y1, . . . , Yn) is called productive in its i-th argument Yi when P is declared
as a right object and its declaration
right object P(Y1, . . . , Yn) with ÏˆP is
Î±P,1: EP,1(P, Y1, . . . , Yn) â†’Eâ€²
P,1(P, Y1, . . . , Yn)
Â· Â· Â·
Î±P,m: EP,m(P, Y1, . . . , Yn) â†’Eâ€²
P,m(P, Y1, . . . , Yn)
end object
satisï¬es
1. P is unconditioned (i.e. P does not appear in Eâ€²
P,1, . . . , Eâ€²
P,m),
2. Yi does not appear in EP,1, . . . , EP,m,
3. Yi appears only one of Eâ€²
P,1, . . . , Eâ€²
P,m, so let us assume that it appears in Eâ€²
P,j
only,
4. EP,j is simply P, and
5. Eâ€²
P,j is a functorial expression productive in Yi.
Therefore, the declaration above may look more like
right object P(Y1, . . . , Yi, . . . , Yn) with ÏˆP is
Î±P,1: EP,1(P, Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn) â†’
Eâ€²
P,1(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn)
Â· Â· Â·
Î±P,j: P â†’Eâ€²
P,j(Y1, . . . , Yiâˆ’1, Yi, Yi+1, . . . , Yn)
Â· Â· Â·
Î±P,m: EP,m(P, Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn) â†’
Eâ€²
P,m(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn)
end object
(P)

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
90
Î±P,j may be called projection to Yi. []
The functor â€˜prodâ€™ is a typical productive functor. It is productive in its both ar-
guments. The functor â€˜expâ€™ is not productive in any of its arguments. A functorial
expression â€˜prod(prod(X, exp(Y, Z)), prod(X, U))â€™ is productive in U but not in X or
Y or Z.
Deï¬nition 4.1.6: A right object R is called computable if its declaration
right object R(X1, . . . , Xn) with ÏˆR is
Î±R,1: ER,1(R, X1, . . . , Xn) â†’Eâ€²
R,1(R, X1, . . . , Xn)
Â· Â· Â·
Î±R,m: ER,m(R, X1, . . . , Xn) â†’Eâ€²
R,m(R, X1, . . . , Xn)
end object
(RC)
satisï¬es that ER,1, . . . , ER,m are functorial expressions productive in R. We also call a
left object L computable when its declaration is
left object L(X1, . . . , Xn) with ÏˆL is
Î±L,1: EL,1(L, X1, . . . , Xn) â†’L
Â· Â· Â·
Î±L,m: EL,m(L, X1, . . . , Xn) â†’L
end object
(LC)
[]
The reduction rules we have deï¬ned in this section work when all the objects we deï¬ne
are computable, and all the objects declared in section 3.3 are computable except the
obscure ones in subsection 3.3.8. Obviously, we did not want to have those obscure
objects in our datatype system and the computability constraint gets rid of them. In
other words, the categories which are deï¬ned by declaring computable objects cannot
be richer than cartesian closed category with recursive objects. Note that we did not
make the restriction in the beginning. We had the ability to declare a lot of other
objects, but it turned out that in order to be able to discuss the computability in
CDT, the categories should be cartesian closed with recursive objects. This signiï¬es
the importance of cartesian closed categories in computer science yet again (e.g. the
models of typed lambda calculus correspond to cartesian closed categories).
Note that not all the productive objects are computable by the deï¬nition 4.1.5, but
from now on we only treat computable objects, so productive objects mean computable
productive objects.
Deï¬nition 4.1.7: Let D1, . . . , Dl be a sequence of CDT declarations deï¬ning only
computable objects and let âŸ¨Î“, âˆ†, Î¨, Î˜âŸ©be the corresponding CSL theory deï¬ned by
deï¬nition 3.4.3. Then, we can have computation rules for CPL elements over the CSL
signature âŸ¨Î“, âˆ†, Î¨âŸ©. The computation rules are divided into two: those in the form of
âŸ¨e, câŸ©â‡’câ€²

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
91
where c and câ€² are canonical elements and e and c can be composed (i.e. e â—¦c is an
element), and those in the form of
âŸ¨c, E, RâŸ©; âŸ¨ÏˆR(e1, . . . , em), câ€²âŸ©
where c and câ€² are canonical elements, R is a right functor name, E is a functorial
expression productive in R and, if c is an element of Eâ€², E should be more general than
Eâ€².
1. IDENT
âŸ¨I, câŸ©â‡’c
2. COMP
âŸ¨e2, câŸ©â‡’câ€²â€²
âŸ¨e1, câ€²â€²âŸ©â‡’câ€²
âŸ¨e1 â—¦e2, câŸ©â‡’câ€²
3. L-NAT
âŸ¨Î±L,j, câŸ©â‡’Î±L,j â—¦c
4. R-FACT
âŸ¨ÏˆR(e1, . . . , em), câŸ©â‡’ÏˆR(e1, . . . , em) â—¦c
5. L-FACT
âŸ¨ej â—¦EL,j[ÏˆL(e1, . . . , em)/L], câŸ©â‡’câ€²
âŸ¨ÏˆL(e1, . . . , em), Î±L,j â—¦câŸ©â‡’câ€²
6. R-NAT
âŸ¨c, ER,j, RâŸ©; âŸ¨ÏˆR(e1, . . . , em), câ€²â€²âŸ©
âŸ¨Eâ€²
R,j[ÏˆR(e1, . . . , em)/R] â—¦ej, câ€²â€²âŸ©â‡’câ€²
âŸ¨Î±R,j, câŸ©â‡’câ€²
7. R-NAT-V
âŸ¨ÏˆR(e1, . . . , em) â—¦câ€²â€², R, RâŸ©; âŸ¨ÏˆR(e1, . . . , em), câ€²â€²âŸ©
8. R-NAT-F
R âˆˆEi
Yi âˆˆEâ€²
P,j
âŸ¨Ë†ej, câŸ©â‡’câ€²
âŸ¨câ€², Eâ€²
P,j[Ei/Yi], RâŸ©; âŸ¨ÏˆR(e1, . . . , emâ€²), câ€²â€²âŸ©
âŸ¨ÏˆP(Ë†e1, . . . , Ë†em) â—¦c, P(E1, . . . , En), RâŸ©;
âŸ¨ÏˆR(e1, . . . , emâ€²), ÏˆP(Ë†e1 â—¦EP,1[c/P], . . . ,
Ë†ejâˆ’1 â—¦EP,jâˆ’1[c/P], câ€²â€², Ë†ej+1 â—¦EP,j+1[c/P], . . . , Ë†em â—¦EP,m[c/P])âŸ©
where the objects L, R and P are deï¬ned as (LC), (RC) and (P), respectively, and
R âˆˆEi means that R appears in a functorial expression Ei. []
We have to show that the rules are well-formed, but we have to show their soundness
at the same time. We will do this in section 4.3 as well as showing that every reduction
terminates (in other words, every element is normalizable by these rules).

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
92
4.2
An Example of using Reduction Rules
In this section, we will see an example computation in CPL using the reduction rules
deï¬ned in the previous section. Since computation by hand is very tiresome, we do
only one example, but we will see some more examples of CPL computation done by
a computer in chapter 5.
Let us assume that we have declared the terminal object as in subsection 3.3.1, prod-
ucts as in subsection 3.3.2, exponentials as in subsection 3.3.3 and natural number
object as in subsection 3.3.4. We can write down instances of the reduction rules in
deï¬nition 4.1.7 as follows.
âŸ¨I, câŸ©â‡’c
(IDENT)
âŸ¨e2, câŸ©â‡’câ€²â€²
âŸ¨e1, câ€²â€²âŸ©â‡’câ€²
âŸ¨e1 â—¦e2, câŸ©â‡’câ€²
(COMP)
For the terminal object, we have
âŸ¨!, câŸ©â‡’! â—¦c.
(R-FACT!)
For products, we have
âŸ¨pair(e1, e2), câŸ©â‡’pair(e1, e2) â—¦c,
(R-FACTpair)
âŸ¨c, R, RâŸ©; âŸ¨pair(e1, e2), câ€²â€²âŸ©
âŸ¨e1, câ€²â€²âŸ©â‡’câ€²
âŸ¨pi1, câŸ©â‡’câ€²
,
(R-NATpi1)
and
âŸ¨pair(e1, e2) â—¦c, prod, prodâŸ©; âŸ¨pair(e1, e2), câŸ©.
(R-NAT-Vprod)
If we combine (R-NATpi1) and (R-NAT-Vprod) together, we get a familiar rule
âŸ¨e1, câŸ©â‡’câ€²
âŸ¨pi1, pair(e1, e2) â—¦câŸ©â‡’câ€²
.
(R-NATâ€²
pi1)
Similarly, for â€˜pi2â€™, we have
âŸ¨e2, câŸ©â‡’câ€²
âŸ¨pi2, pair(e1, e2) â—¦câŸ©â‡’câ€²
.
(R-NATâ€²
pi2)
For exponentials, as we have seen in the previous section, we have the following two
rules.
âŸ¨curry(e), câŸ©â‡’curry(e) â—¦c
(R-FACTcurry)
âŸ¨e1, câŸ©â‡’curry(e) â—¦câ€²â€²
âŸ¨e, pair(câ€²â€², e2 â—¦c)âŸ©â‡’câ€²
âŸ¨eval, pair(e1, e2) â—¦câŸ©â‡’câ€²
(R-NATâ€²
eval)
For natural number object, we have
âŸ¨zero, câŸ©â‡’zero â—¦c,
(L-NATzero)
âŸ¨succ, câŸ©â‡’succ â—¦c,
(L-NATsucc)

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
93
âŸ¨e1, câŸ©â‡’câ€²
âŸ¨pr(e1, e2), zero â—¦câŸ©â‡’câ€²
,
(L-FACTzero)
and
âŸ¨e2 â—¦pr(e1, e2), câŸ©â‡’câ€²
âŸ¨pr(e1, e2), succ â—¦câŸ©â‡’câ€²
.
(L-FACTsucc)
Now let us try to calculate â€˜1 + 1â€™ in CPL. The addition function is deï¬ned in subsec-
tion 3.3.4 as
add = eval â—¦prod(pr(curry(pi2), curry(succ â—¦eval)), I).
If we expand â€˜prodâ€™ by â€˜pairâ€™, we get
add = eval â—¦pair(pr(curry(pi2), curry(succ â—¦eval)) â—¦pi1, pi2).
Therefore, the calculation â€˜1 + 1â€™ corresponds to the following reduction.
âŸ¨eval â—¦pair(pr(curry(pi2), curry(succ â—¦eval)) â—¦pi1, pi2),
pair(succ â—¦zero, succ â—¦zero)âŸ©â‡’c
(1)
From (COMP),
âŸ¨pair(pr(curry(pi2), curry(succ â—¦eval)) â—¦pi1, pi2),
pair(succ â—¦zero, succ â—¦zero)âŸ©â‡’c1
âŸ¨eval, c1âŸ©â‡’c
âŸ¨eval â—¦pair(pr(curry(pi2), curry(succ â—¦eval)) â—¦pi1, pi2),
pair(succ â—¦zero, succ â—¦zero)âŸ©â‡’c
From (R-FACTpair), c1 is
pair(pr(curry(pi2, curry(succ â—¦eval) â—¦pi1, pi2) â—¦pair(succ â—¦zero, succ â—¦zero),
so we need to calculate
âŸ¨eval, pair(pr(curry(pi2, curry(succ â—¦eval) â—¦pi1, pi2)â—¦
pair(succ â—¦zero, succ â—¦zero)âŸ©â‡’c.
From (R-NATâ€²
eval),
âŸ¨pr(curry(pi2), curry(succ â—¦eval)) â—¦pi1,
pair(succ â—¦zero, succ â—¦zero)âŸ©â‡’curry(e1) â—¦c2
âŸ¨e1, pair(c2, pi2 â—¦pair(succ â—¦zero, succ â—¦zero))âŸ©â‡’c
âŸ¨eval, pair(pr(curry(pi2, curry(succ â—¦eval) â—¦pi1, pi2)â—¦
pair(succ â—¦zero, succ â—¦zero)âŸ©â‡’c.
(2)
From (COMP),
âŸ¨pi1, pair(succ â—¦zero, succ â—¦zero)âŸ©â‡’c3
âŸ¨pr(curry(pi2), curry(succ â—¦eval)), c3âŸ©â‡’curry(e1) â—¦c2
âŸ¨pr(curry(pi2), curry(succ â—¦eval)) â—¦pi1,
pair(succ â—¦zero, succ â—¦zero)âŸ©â‡’curry(e1) â—¦c2
(3)

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
94
From (R-NATâ€²
pi1),
âŸ¨succ â—¦zero, !âŸ©â‡’c3
âŸ¨pi1, pair(succ â—¦zero, succ â—¦zero)âŸ©â‡’c3
,
and from (L-NATzero) and (L-NATsucc), c3 is
succ â—¦zero â—¦!.
Going back to (3), we need to calculate
âŸ¨pr(curry(pi2), curry(succ â—¦eval)), succ â—¦zero â—¦!âŸ©â‡’curry(e1) â—¦c2.
From (L-FACTsucc),
âŸ¨curry(succ â—¦eval) â—¦pr(curry(pi2), curry(succ â—¦eval)),
zero â—¦!âŸ©â‡’curry(e1) â—¦c2
âŸ¨pr(curry(pi2), curry(succ â—¦eval)), succ â—¦zero â—¦!âŸ©â‡’curry(e1) â—¦c2
and from (COMP)
âŸ¨pr(curry(pi2), curry(succ â—¦eval)), zero â—¦!âŸ©â‡’c4
âŸ¨curry(succ â—¦eval), c4âŸ©â‡’curry(e2) â—¦c2
âŸ¨curry(succ â—¦eval) â—¦pr(curry(pi2),
curry(succ â—¦eval)), zero â—¦!âŸ©â‡’curry(e1) â—¦c2
(4)
From (L-FACTzero),
âŸ¨curry(pi2), !âŸ©â‡’c4
âŸ¨pr(curry(pi2), curry(succ â—¦eval)), zero â—¦!âŸ©â‡’c4
and from (R-FACTcurry), c4 is â€˜curry(pi2) â—¦!â€™. Going back to (4), e1 is â€˜succ â—¦evalâ€™ and
c2 is curry(pi2) â—¦!. Therefore, going back to (2), we now have to calculate
âŸ¨succ â—¦eval, pair(curry(pi2) â—¦!, pi2 â—¦pair(succ â—¦zero, succ â—¦zero))âŸ©â‡’c.
From (COMP),
âŸ¨eval, pair(curry(pi2) â—¦!,
pi2 â—¦pair(succ â—¦zero, succ â—¦zero))âŸ©â‡’c5
âŸ¨succ, c5âŸ©â‡’c
âŸ¨succ â—¦eval, pair(curry(pi2) â—¦!,
pi2 â—¦pair(succ â—¦zero, succ â—¦zero))âŸ©â‡’c
(5)
From (R-NATâ€²
eval),
âŸ¨curry(pi2) â—¦!, !âŸ©â‡’curry(e2) â—¦c6
âŸ¨e2, pair(c6, pi2 â—¦pair(succ â—¦zero, succ â—¦zero))âŸ©â‡’c5
âŸ¨eval, pair(curry(pi2) â—¦!, pi2 â—¦pair(succ â—¦zero, succ â—¦zero))âŸ©â‡’c5

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
95
From (R-FACT!) and (R-FACTcurry), e2 is â€˜pi2â€™ and c6 is â€˜! â—¦!â€™, so we have
âŸ¨pi2, pair(! â—¦!, pi2 â—¦pair(succ â—¦zero, succ â—¦zero))âŸ©â‡’c5
From (R-NATâ€²
pi2),
âŸ¨pi2 â—¦pair(succ â—¦zero, succ â—¦zero), !âŸ©â‡’c5
âŸ¨pi2, pair(! â—¦!, pi2 â—¦pair(succ â—¦zero, succ â—¦zero))âŸ©â‡’c5
From (COMP),
âŸ¨pair(succ â—¦zero, succ â—¦zero), !âŸ©â‡’c6
âŸ¨pi2, c6âŸ©â‡’c5
âŸ¨pi2 â—¦pair(succ â—¦zero, succ â—¦zero), !âŸ©â‡’c5
From (R-FACTpair), c6 is
pair(succ â—¦zero, succ â—¦zero) â—¦!,
so we have
âŸ¨pi2, pair(succ â—¦zero, succ â—¦zero) â—¦!âŸ©â‡’c5
and (R-NATâ€²
pi2)
âŸ¨succ â—¦zero, !âŸ©â‡’c5
âŸ¨pi2, pair(succ â—¦zero, succ â—¦zero) â—¦!âŸ©â‡’c5
By using (L-NATzero) and (L-NATsucc), c5 is
succ â—¦zero â—¦!.
Now, we go back to (5) and we need to calculate
âŸ¨succ, succ â—¦zero â—¦!âŸ©â‡’c,
but this is straightforward from (L-NATsucc) and c is
succ â—¦succ â—¦zero â—¦!.
Therefore, the reduction (1) is
âŸ¨eval â—¦pair(pr(curry(pi2), curry(succ â—¦eval)) â—¦pi1, pi2),
pair(succ â—¦zero, succ â—¦zero)âŸ©â‡’succ â—¦succ â—¦zero â—¦!
that is, we have shown â€˜1 + 1â€™ is â€˜2â€™ in CPL.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
96
4.3
Well-Deï¬nedness and Normalization Theorem
for Reduction Rules
In section 4.1, we discussed what is computation in CPL and obtained a set of reduction
rules (deï¬nition 4.1.7). Usual questions to be asked when we get reduction rules are,
ï¬rstly, whether they are well-deï¬ned or not and, secondly, whether they are normalizing
or not. In this section, we will answer both questions aï¬ƒrmatively.
Let us assume in this section that we are working in a CSL theory âŸ¨Î“, âˆ†, Î¨, Î˜âŸ©which is
obtained by a sequence of CDT declarations, D1, . . . , Dl, each of which is a computable
object declaration.
First, we prove the well-deï¬nedness of the reduction rules.
Theorem 4.3.1: Well-Deï¬nedness Theorem: Let e â—¦c be an element in âŸ¨Î“, âˆ†, Î¨âŸ©
and c be a canonical element. If from the rules listed in deï¬nition 4.1.7 we deduce
âŸ¨e, câŸ©â‡’câ€²,
then câ€² is a canonical element and eâ—¦c = câ€² holds in âŸ¨Î“, âˆ†, Î¨, Î˜âŸ©(or in any CSL theory
structure of this).
Proof: We prove at the same time that for a canonical element c, a right functor R,
a functorial expression E productive in R which is more general than the type of c, if
the rules in deï¬nition 4.1.7 deduce
âŸ¨c, E, RâŸ©; âŸ¨e, câ€²âŸ©,
then e is ÏˆR(e1, . . . , em) for some e1, . . . , en, câ€² is a canonical element and c = E[Ïˆ(e1, . . . , em)/R]â—¦
câ€² holds in âŸ¨Î“, âˆ†, Î¨, Î˜âŸ©.
The proof is done by mathematical induction on the length of reduction, so all we have
to do is to check each reduction rule.
1. IDENT
âŸ¨I, câŸ©â‡’c
It is trivial from I â—¦c = c.
2. COMP
âŸ¨e2, câŸ©â‡’câ€²â€²
âŸ¨e1, câ€²â€²âŸ©â‡’câ€²
âŸ¨e1 â—¦e2, câŸ©â‡’câ€²
From the induction hypothesis câ€² is canonical and câ€² = e1 â—¦câ€²â€² = e1 â—¦e2 â—¦c.
3. L-NAT
âŸ¨Î±L,j, câŸ©â‡’Î±L,j â—¦c
It is trivial since Î±L,j â—¦c is a canonical element.
4. R-FACT
âŸ¨ÏˆR(e1, . . . , em), câŸ©â‡’ÏˆR(e1, . . . , em) â—¦c
It is again trivial since ÏˆR(e1, . . . , em) â—¦c is a canonical element.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
97
5. L-FACT
âŸ¨ej â—¦EL,j[ÏˆL(e1, . . . , em)/L], câŸ©â‡’câ€²
âŸ¨ÏˆL(e1, . . . , em), Î±L,j â—¦câŸ©â‡’câ€²
If Î±L,j â—¦c is canonical, c is canonical, and from (LEQj)
ej â—¦EL,j[ÏˆL(e1, . . . , em)/L] â—¦c = ÏˆL(e1, . . . , em) â—¦Î±L,j â—¦c.
Therefore, the premise of the rule is well-formed, so from the induction hypothesis
câ€² is canonical, and
câ€² = ej â—¦EL,j[ÏˆL(e1, . . . , em)/L] â—¦c = ÏˆL(e1, . . . , em) â—¦Î±L,j â—¦c.
6. R-NAT
âŸ¨c, ER,j, RâŸ©; âŸ¨ÏˆR(e1, . . . , em), câ€²â€²âŸ©
âŸ¨Eâ€²
R,j[ÏˆR(e1, . . . , em)/R] â—¦ej, câ€²â€²âŸ©â‡’câ€²
âŸ¨Î±R,j, câŸ©â‡’câ€²
Since Î±R,j can be composed with c and Î±R,j has the type ER,j â†’Eâ€²
R,j, c is an
element of a functorial expression not more general than ER,j. From the induction
hypothesis, câ€²â€² is a canonical element and
ER,j[ÏˆR(e1, . . . , em)/R] â—¦câ€²â€² = c.
Therefore,
Î±R,j â—¦c
= Î±R,j â—¦ER,j[ÏˆR(e1, . . . , em)/R] â—¦câ€²â€²
. . . . . . . . . . . . . . . . . . . . . . . . (from (REQj))
= Eâ€²
R,j[ÏˆR(e1, . . . , em)/R] â—¦ej â—¦câ€²â€²
. . . . . . . . . . . . . . . . . . . . . . . (from hypothesis)
= c.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (from hypothesis)
7. R-NAT-V
âŸ¨ÏˆR(e1, . . . , em) â—¦câ€²â€², R, RâŸ©; âŸ¨ÏˆR(e1, . . . , em), câ€²â€²âŸ©
R is a variable, so it is more general than anything, so the rule is well-formed.
Since ÏˆR(e1, . . . , em) â—¦câ€²â€² is a canonical element, so is câ€²â€².
8. R-NAT-F
R âˆˆEi
Yi âˆˆEâ€²
P,j
âŸ¨Ë†ej, câŸ©â‡’câ€²
âŸ¨câ€², Eâ€²
P,j[Ei/Yi], RâŸ©; âŸ¨ÏˆR(e1, . . . , emâ€²), câ€²â€²âŸ©
âŸ¨ÏˆP(Ë†e1, . . . , Ë†em) â—¦c, P(E1, . . . , En), RâŸ©;
âŸ¨ÏˆR(e1, . . . , emâ€²), ÏˆP(Ë†e1 â—¦EP,1[c/P], . . . ,
Ë†ejâˆ’1 â—¦EP,jâˆ’1[c/P], câ€²â€², Ë†ej+1 â—¦EP,j+1[c/P], . . . , Ë†em â—¦EP,m[c/P])âŸ©
ÏˆP(Ë†e1, . . .) â—¦c = ÏˆP(Ë†e1 â—¦EP,1[c/P], . . .) and from the typing rule of ÏˆP, Ë†ej â—¦
EP,j[c/P] = Ë†ejâ—¦c is an element of a functorial expression which is not more general

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
98
than Eâ€²
P,j[E1/Y1, . . .] which is not more general than Eâ€²
P,j[Ei/Yi]. Therefore, the
premises of the rule are well-formed and
Ë†ej â—¦EP,j[c/P]
= Ë†ej â—¦c
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (EP,j is simply P)
= câ€²
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (from âŸ¨Ë†ej, câŸ©â‡’câ€²)
= Eâ€²
P,j[Ei/Yi][ÏˆR(e1, . . .)/R] â—¦câ€²â€².
. . . . . . . . . . .(from âŸ¨câ€², Eâ€²
P,j[Ei/Yi], RâŸ©; . . .)
Therefore,
P(E1, . . .)[ÏˆR(e1, . . .)/R] â—¦ÏˆP(Ë†e1 â—¦EP,1[c/P], . . . , câ€²â€², . . .)
= ÏˆP(Î±P,1, . . . , Eâ€²
P,j[Ei/Yi][ÏˆR(e1, . . .)/R], . . .)
â—¦ÏˆP(Ë†e1 â—¦EP,1[c/P], . . . , câ€²â€², . . .)
. . . . . . . . . . . (expand P)
= ÏˆP(Ë†e1 â—¦EP,1[c/P], . . . , Eâ€²
P,j[Ei/Yi][ÏˆR(e1, . . .)/R] â—¦câ€²â€², . . .)
. . . . . . . . . . . . . . . . . . . . . . . . . . .(from 4.1.4 and (REQk))
= ÏˆP(Ë†e1 â—¦EP,1[c/P], . . . , Ë†ej â—¦EP,j[c/P], . . .)
. . . . . . . . . . . . . . . . . . . (from above)
= ÏˆP(Ë†e1, . . . , Ë†em) â—¦c.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .(from 4.1.4)
Of course, ÏˆP(Ë†e1 â—¦EP,1[c/P], . . . , câ€²â€², . . .) is a canonical element.
We have proved the theorem as well as shown the well-formedness of the reduction
rules. []
Next, we prove the normalization, that is to prove the following theorem.
Theorem 4.3.2: Normalization Theorem: For a canonical element c and a CSL
expression e whose domain is compatible with the codomain of c (i.e. we can have e â—¦c
as an element), there is a canonical element câ€² such that
âŸ¨e, câŸ©â‡’câ€²
by the rules listed in deï¬nition 4.1.7. []
Before proving this theorem, we need some preparation. Note that the theorem proves
the two things together: the existence of câ€² and the reducibility of âŸ¨e, câŸ©â‡’câ€². Therefore,
from the existence part, we will have the following corollary.
Corollary 4.3.3: For any element e in âŸ¨Î“, âˆ†, Î¨âŸ©, there is a canonical element c such
that e = c holds in âŸ¨Î“, âˆ†, Î¨, Î˜âŸ©. []
Showing the reducibility can be regarded as showing the termination of computation
in CPL. So, every program terminates in CPL. This is what we expected because we
only use primitive recursions.
First, we show a property of canonical elements.
Proposition 4.3.4: A canonical element of R(E1, . . . , En) for a right object R deï¬ned
by (RC) has the following form.
ÏˆR(e1, . . . , em) â—¦c

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
99
where c is another canonical element.
On the other hand, a canonical element of L(E1, . . . , En) for a left object L deï¬ned by
(LC) has the following form.
Î±L,j â—¦c
where c is another canonical element.
Proof: A canonical element only consists of natural transformations of left objects
and factorizers of right objects. Therefore, a canonical element should look like either
Î±L,j â—¦c
or
ÏˆR(e1, . . . , em) â—¦c.
From the typing rules in section 2.4, the ï¬rst one always gives an element of L(E1, . . . , En)
and the second one gives an element of R(E1, . . . , En). []
From this proposition, we can see that whenever we have
âŸ¨e, câŸ©
or
âŸ¨c, E, RâŸ©
we can always apply exactly one of the rules in deï¬nition 4.1.7. In other words, the
computation in CPL is never stuck and deterministic. We can always proceed to the
next computation step.
We are going to prove the normalization theorem by the computability method due to
Tait [Tait 67]. This method is often used to show normalization of various systems
especially that of lambda calculi (see, for example, [Stenlund 72] and [Lambek and
Scott 86]) where two kinds of induction are used: induction on types and induction on
structures. The method usually goes for lambda calculi as follows:
1. Deï¬ne the notion of computable terms inductively on types.
2. Show that any computable term is normalizable.
3. Show that all the terms are computable by induction on terms.
4. Therefore, any term is normalizable.
The notion of computable terms is stronger than that of normalizable terms, but we
need this stronger notion (which is a part of the essence of the Tait computability
method) to carry out the normalization proof. The computability predicate also divide
the two inductions involved in the proof clearly. In our case, the normalization proof
goes as follows.
1. We deï¬ne the notion of computable canonical elements inductively on types. In-
tuitively, a canonical element c is computable if
(a) Î±L â—¦c is computable if c is computable.
(b) ÏˆR(e) â—¦c is computable if there is a reduction âŸ¨Î±R, ÏˆR(e) â—¦câŸ©â‡’câ€² such that
câ€² is computable, that is all the components of ÏˆR(e) â—¦c are computable.
2. We deï¬ne the notion of calculability for expressions (we could have called it
computability as well as is conventional in proofs about lambda calculi, but we
distinguish them for clarity). An expression e is calculable if for any computable
canonical element c there is a reduction âŸ¨e, câŸ©â‡’câ€² such that câ€² is computable.
Note that an expression e is normalizable if for any canonical element e there
is a reduction âŸ¨e, câŸ©â‡’c, whereas e is calculable if there is a reduction for any
computable canonical element. Therefore, it should be easier to prove that an
expression is calculable than to prove it is normalizable.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
100
3. We will prove that all the expressions are calculable by structural induction.
4. As an easy corollary, we can show that any canonical element is computable.
5. Finally, we prove that all the reductions are normalizing.
First, let us assign for each n-ary functor F a function which given sets C1 . . . , Cn
of canonical elements of type E1, . . . , En gives a set of canonical elements C of type
F(E1, . . . , En). We write ËœF for the function (i.e. C = ËœF(C1, . . . , Cn)). ËœF is monotonic
in the ith argument if F is covariant in the ith argument, and ËœF is anti-monotonic in
the ith argument if F is contravariant in the ith argument.
Deï¬nition 4.3.5:
1. For a left object2
left object L(X) with ÏˆL is
Î±L: EL(L, X) â†’L
end object,
ËœL(C) is the minimal ï¬xed point of the following monotonic function:
S 7âˆ’â†’{ Î±L â—¦c | c âˆˆËœEL(S, C) }
The minimal ï¬xed point can be calculated as the least upper bound of the fol-
lowing ascending chain:
ËœL0(C) âŠ†ËœL1(C) âŠ†Â· Â· Â· âŠ†ËœLn(C) âŠ†ËœLn+1(C) âŠ†Â· Â· Â· âŠ†ËœLÏ‰(C) âŠ†Â· Â· Â·
where ËœL0(C) is âˆ…and
ËœLÎ²+1(C) def
= { Î±L â—¦c | c âˆˆËœEL(ËœLÎ²(C), C) }.
2. For a right object
right object R(X) with ÏˆR is
Î±R: R â†’Eâ€²
R(R, X)
end object,
ËœR(C) is the maximal ï¬xed point of the following monotonic function:
S 7âˆ’â†’{ ÏˆR(e) â—¦c | âŸ¨Î±R, ÏˆR(e) â—¦câŸ©â‡’câ€² such that câ€² âˆˆËœEâ€²
R(S, C) }
The maximal ï¬xed point can be calculated as the greatest lower bound of the
following descending chain:
ËœR0(C) âŠ‡ËœR1(C) âŠ‡Â· Â· Â· âŠ‡ËœRn(C) âŠ‡ËœRn+1(C) âŠ‡Â· Â· Â· âŠ‡ËœRÏ‰(C) âŠ‡Â· Â· Â·
where ËœR0(C) is the set of all the canonical elements of R(E) (where C is a set of
canonical elements of type E) and
ËœRÎ²+1(C) def
= { ÏˆR(e) â—¦c |
âŸ¨Î±R, ÏˆR(e) â—¦câŸ©â‡’câ€² such that câ€² âˆˆËœEâ€²
R( ËœRÎ²(C), C) }.
2For simplicity, we deï¬ne this for a simple left object, but the general case should be obvious.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
101
3. For a right object3
right object Râ€²(X) with ÏˆRâ€² is
Î±Râ€²: prod(R, ERâ€²(X)) â†’Eâ€²
Râ€²(Râ€², X)
end object,
ËœRâ€²(C) is the maximal ï¬xed point of the following monotonic function:
S 7âˆ’â†’{ ÏˆRâ€²(e) â—¦c | For any câ€² âˆˆËœERâ€²(C) âŸ¨Î±Râ€², pair(ÏˆRâ€²(e)â—¦c, câ€²)âŸ©â‡’câ€²â€²
such that câ€²â€² âˆˆËœEâ€²
Râ€²(S, C) }
We can similarly deï¬ne ËœRâ€²
Î²(C).
Well-deï¬nedness: We have to show that ËœF is monotonic or anti-monotonic according
to the variance of F. We prove this by induction on the order of declaration of objects.
1. If F is the left object L above and covariant, we show that ËœLÎ² is monotonic by
induction on Î². ËœL0 is trivially monotonic. ËœLÎ²+1(C) is
{ Î±L â—¦c | c âˆˆËœEL(ËœLÎ²(C), C) }.
From the induction hypothesis ËœLÎ² is monotonic. Since EL(L, X) is covariant in
both L and X, from the other induction hypothesis ËœEL is monotonic. Therefore,
ËœEL(ËœLÎ²(C), C) is monotonic in C, and ËœLÎ²+1 is monotonic. Hence, ËœL is monotonic.
Similarly, we can show that ËœL is anti-monotonic if L is contravariant.
2. If F is the right object R above and covariant, we show that ËœRÎ² is monotonic by
induction on Î². ËœR0 is trivially monotonic. ËœRÎ²+1(C) is
{ ÏˆR(e) â—¦c | âŸ¨Î±R, ÏˆR(e) â—¦câŸ©â‡’câ€² âˆ§câ€² âˆˆËœEâ€²
R( ËœRÎ²(C), C) }.
From the induction hypothesis, ËœRÎ² is monotonic, and from the other induction
hypothesis, ËœEâ€²
R is monotonic in both arguments. Therefore, ËœRÎ²+1 is monotonic,
and by induction ËœR is monotonic. We can similarly show that ËœR is anti-monotonic
if R is contravariant.
3. If F is the right object Râ€² above and covariant, we show that ËœRâ€²
Î² is monotonic
by induction on Î². ËœRâ€²
0 is trivially monotonic. ËœRâ€²
Î²+1(C) is
{ ÏˆRâ€²(e) â—¦c | âˆ€câ€² âˆˆËœERâ€²(C) âŸ¨Î±Râ€², pair(ÏˆRâ€²(e) â—¦c, câ€²)âŸ©â‡’câ€²â€² âˆ§
câ€²â€² âˆˆËœEâ€²
Râ€²( ËœRâ€²
Î²(C), C) }.
From the induction hypothesis, ËœRâ€²
Î² is monotonic, and from the other induction hy-
pothesis, ËœERâ€² is anti-monotonic and ËœEâ€²
Râ€² is monotonic in both arguments. There-
fore, ËœRâ€²
Î²+1 is monotonic, and by induction ËœRâ€² is monotonic. We can similarly
show that ËœRâ€² is anti-monotonic if Râ€² is contravariant. []
3For a right object R, since the domain of Î±R: ER(R, X) â†’Eâ€²
R(R, X) needs to be productive in R,
there are basically these two cases: when ER(R, X) is R and when it is prod(R, Eâ€²â€²(X)).

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
102
We now deï¬ne the notion of computability and calculability.
Deï¬nition 4.3.6: The set â„¦F(E1,...,En) of computable canonical elements of type F(E1, . . . , En)
is deï¬ned inductively by ËœF(â„¦E1, . . . , â„¦En). []
Deï¬nition 4.3.7: An CSL expression e of type E â†’Eâ€² is called calculable with respect
to C â†’Câ€² for C âŠ†â„¦E and Câ€² âŠ†â„¦Eâ€² if for any c in C there is a reduction âŸ¨e, câŸ©â‡’câ€²
such that câ€² is in Câ€². When e is calculable with respect to â„¦E â†’â„¦Eâ€², we simply say
that e is calculable. []
Example 4.3.8:
1. For the terminal object â€˜1â€™
right object 1 with !
end object,
since there is no natural transformation, any canonical element is computable.
Let us use â‹†to denote an arbitrary element of Ëœ1.
2. For the left object â€˜natâ€™ of natural numbers
left object nat with pr is
zero: 1 â†’nat
succ: nat â†’nat
end object,
g
nat0 is âˆ…. g
nat1 is
{ zero â—¦c, succ â—¦câ€² | c âˆˆËœ1 âˆ§câ€² âˆˆg
nat0 } = { zero â—¦â‹†}.
Similarly g
nat2 consists of zero â—¦â‹†and succ â—¦zero â—¦â‹†. In general, g
natn is the set
of n elements corresponding to a set of 0, 1, 2, . . . , and n âˆ’1. Therefore, g
nat is
the set of all the canonical elements of nat.
3. For the right object â€˜prodâ€™ of products
right object prod(X, Y ) with pair is
pi1: prod â†’X
pi2: prod â†’Y
end object,
a canonical element pair(e1, e2) â—¦c is computable if there are reductions
âŸ¨pi1, pair(e1, e2) â—¦câŸ©â‡’c1
and
âŸ¨pi2, pair(e1, e2) â—¦câŸ©â‡’c2
such that c1 and c2 are computable, that is a canonical element of prod is com-
putable if its components are computable. Since the reductions above are equiv-
alent to âŸ¨e1, câŸ©â‡’c1 and âŸ¨e2, câŸ©â‡’c2, if c is computable and e1 and e2 are
calculable, pair(e1, e2) â—¦c is computable.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
103
4. For the right object â€˜expâ€™ of exponentials
right object exp(X, Y ) with curry is
eval: prod(exp, X) â†’Y
end object,
a canonical element curry(e) â—¦c of type exp(E, Eâ€²) is computable, if for any
computable canonical element câ€² of type Eâ€² there is a reduction
âŸ¨eval, pair(curry(e) â—¦c, câ€²)âŸ©â‡’câ€²â€²
and câ€²â€² is computable. The reduction is equivalent to âŸ¨e, pair(c, câ€²)âŸ©â‡’câ€²â€². Since
pair(c, câ€²) is computable, there is such a reduction if e is calculable. Remember
that curry(e) corresponds to the closure of e (or lambda closed term of e) so that
we can say that a closure is calculable if the application with canonical elements
always results canonical elements. This exactly corresponds to the deï¬nition of
computability for lambda expressions (see [Stenlund 72]).
5. For the right object â€˜inï¬‚istâ€™ of inï¬nite lists
right object inï¬‚ist(X) with fold is
head: inï¬‚ist â†’X
tail: inï¬‚ist â†’inï¬‚ist
end object,
let us ï¬gure out the computable canonical elements of type inï¬‚ist(nat).
g
inï¬‚ist0(â„¦nat)
is the set of all the canonical elements of type inï¬‚ist(nat).
g
inï¬‚ist1(â„¦nat) is
{ fold(e1, e2) â—¦c | âŸ¨head, fold(e1, e2) â—¦câŸ©â‡’c1 âˆ§c1 âˆˆâ„¦nat âˆ§
âŸ¨tail, fold(e1, e2) â—¦câŸ©â‡’c2 âˆ§c2 âˆˆ
g
inï¬‚ist0(â„¦nat) }
= { fold(e1, e2) â—¦c | âŸ¨e1, câŸ©â‡’c1 âˆ§âŸ¨fold(e1, e2) â—¦e2, câŸ©â‡’c2 }.
Therefore, if e1 and e2 are calculable and c is computable, fold(e1, e2) â—¦c is
in
g
inï¬‚ist1(â„¦nat). We can inductively show that it is in any
g
inï¬‚istÎ²(â„¦nat), and,
therefore, it is in
g
inï¬‚ist(â„¦nat).
6. For the left object of ordinals
left object ord with pro is
ozero: 1 â†’ord
sup: exp(nat, ord) â†’ord
end object,
g
ord0 is empty, g
ord1 is { ozero â—¦â‹†}, and
g
ord2
= { sup â—¦c, ozero â—¦â‹†| c âˆˆg
exp(g
nat, g
ord1) }
= { sup â—¦curry(e) â—¦c, ozero â—¦â‹†| âˆ€câ€² âˆˆg
nat âŸ¨e, pair(c, câ€²)âŸ©â‡’câ€²â€² âˆ§
câ€²â€² âˆˆg
ord1 }
= { sup â—¦curry(e) â—¦c, ozero â—¦â‹†| âˆ€câ€² âˆˆâ„¦nat âŸ¨e, pair(c, câ€²)âŸ©â‡’ozero â—¦â‹†}.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
104
In general,
g
ordÎ²+1 = { sup â—¦curry(e) â—¦c, ozero â—¦â‹†|
âˆ€câ€² âˆˆâ„¦nat âŸ¨e, pair(c, câ€²)âŸ©â‡’câ€²â€² âˆ§câ€²â€² âˆˆg
ordÎ² }
Therefore, a canonical element sup â—¦curry(e) â—¦c is computable if the following
reductions always exist:
âŸ¨e, pair(c, c1)âŸ©â‡’sup â—¦curry(e1) â—¦câ€²
1
âŸ¨e1, pair(câ€²
1, c2)âŸ©â‡’sup â—¦curry(e2) â—¦câ€²
2
âŸ¨e2, pair(câ€²
2, c3)âŸ©â‡’sup â—¦curry(e3) â—¦câ€²
3
Â· Â· Â·
âŸ¨eÎ², pair(câ€²
Î², cÎ²+1)âŸ©â‡’ozero â—¦â‹†
[]
The next proposition intuitively means that functors preserve the structure of data.
For example, when the functor â€˜listâ€™ (or map in ML and MAPCAR in LISP) is applied to
a list, it only changes the components of the list and preserves the length.
Proposition 4.3.9: Let F be n-ary functor, and e1, . . . , en be CSL expressions cal-
culable with respect to Ci â†’Câ€²
i.
Then F(e1, . . . , en) is calculable with respect to
ËœF(Câ€²â€²
1, . . . , Câ€²â€²
n) â†’ËœF(Câ€²â€²â€²
1 , . . . , Câ€²â€²â€²
n ), where Câ€²â€²
i is Ci and Câ€²â€²â€²
i is Câ€²
i if F is covariant in the
ith argument and Câ€²â€²
i is Câ€²
i and Câ€²â€²â€²
i is Ci if F is contravariant in the ith argument.
Proof: We prove this by induction on the order of declarations of objects.
1. Let F be a left object declared by
left object L(X) with ÏˆL is
Î±L: EL(L, X) â†’L
end object
which is covariant in X, e be a CSL expression which is calculable with respect
to C â†’Câ€². We prove that L(e) is calculable with respect to ËœLÎ²(C) â†’ËœLÎ²(Câ€²)
by induction on Î². Trivially, L(e) is calculable with respect to ËœL0(C) â†’ËœL0(C)
because ËœL0(C) is empty. Assume we have proved that L(e) is calculable with
respect to ËœLÎ²(C) â†’ËœLÎ²(Câ€²). An element of ËœLÎ²+1(C) is Î±L â—¦c such that c âˆˆ
ËœEL(ËœLÎ²(C), C). From L-FACT we get
âŸ¨Î±L â—¦EL(I, e) â—¦EL(L(e), I), câŸ©â‡’câ€²
âŸ¨Î±L â—¦EL(I, e) â—¦EL(ÏˆL(Î±L â—¦EL(I, c)), I), câŸ©â‡’câ€²
âŸ¨ÏˆL(Î±L â—¦EL(I, e)), Î±L â—¦câŸ©â‡’câ€²
âŸ¨L(e), Î±L â—¦câŸ©â‡’Î±L â—¦câ€²
Since EL(L, X) consists of functors declared before L, from the induction hypoth-
esis, EL(L(e), I) is calculable with respect to ËœEL(ËœLÎ²(C), C) â†’ËœEL(ËœLÎ²(Câ€²), C) and
EL(I, e) is calculable with respect to ËœEL(ËœLÎ²(Câ€²), C) â†’ËœEL(ËœLÎ²(Câ€²), Câ€²). There-
fore, there is a reduction
âŸ¨EL(I, e) â—¦EL(L(e), I), câŸ©â‡’câ€²

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
105
such that câ€² is in ËœEL(ËœLÎ²(Câ€²), Câ€²). From deï¬nition 4.3.5, Î±L â—¦câ€² is in ËœLÎ²+1(Câ€²).
Hence, L(e) is calculable with respect to ËœLÎ²+1(C) â†’ËœLÎ²+1(Câ€²). By induction,
L(e) is calculable with respect to ËœLÎ²(C) â†’ËœLÎ²(Câ€²) for any Î², and, therefore, L(e)
is calculable with respect to ËœL(C) â†’ËœL(Câ€²). When L(X) is contravariant, we can
similarly prove that L(e) is calculable with respect to ËœL(Câ€²) â†’ËœL(C).
2. Let F be a right object declared by
right object R(X) with ÏˆR is
Î±R: R â†’Eâ€²
R(R, X)
end object
which is covariant, and e be a CSL expression which is calculable with respect to
C â†’Câ€². We prove that R(e) is calculable with respect to ËœRÎ²(C) â†’ËœRÎ²(Câ€²) by
induction on Î². From R-FACT, we have
âŸ¨R(e), câŸ©â‡’ÏˆR(Eâ€²
R(I, e) â—¦Î±R) â—¦c.
Trivially, R(e) is calculable with respect to ËœR0(C) â†’ËœR0(Câ€²) because ËœR0(Câ€²) is
the set of all the canonical elements of R. Assume we have proved that R(e) is
calculable with respect to ËœRÎ²(C) â†’ËœRÎ²(Câ€²). An element of ËœRÎ²+1(C) is ÏˆR(eâ€²)â—¦câ€²
such that there is a reduction âŸ¨Î±R, ÏˆR(eâ€²) â—¦câ€²âŸ©â‡’câ€²â€² and câ€²â€² is in ËœEâ€²
R( ËœRÎ²(C), C).
We will show that the following canonical element is in ËœRÎ²+1(Câ€²):
ÏˆR(Eâ€²
R(I, e) â—¦Î±R) â—¦ÏˆR(eâ€²) â—¦câ€²
(âˆ—)
From R-NAT, we have
âŸ¨Eâ€²
R(R(e), I) â—¦Eâ€²
R(I, e), câ€²â€²âŸ©â‡’câ€²â€²â€²
âŸ¨Eâ€²
R(R(e), I) â—¦Eâ€²
R(I, e) â—¦Î±R, ÏˆR(eâ€²) â—¦câ€²âŸ©â‡’câ€²â€²â€²
âŸ¨Eâ€²
R(ÏˆR(Eâ€²
R(I, c) â—¦Î±R), I), Eâ€²
R(I, e) â—¦Î±R, ÏˆR(eâ€²) â—¦câ€²âŸ©â‡’câ€²â€²â€²
âŸ¨Î±R, ÏˆR(Eâ€²
R(I, e) â—¦Î±R) â—¦ÏˆR(eâ€²) â—¦câ€²âŸ©â‡’câ€²â€²â€²
Since Eâ€²
R(R, X) consists of functors declared before R, Eâ€²
R(R(e), I) â—¦Eâ€²
R(I, e) is
calculable with respect to ËœEâ€²
R( ËœRÎ²(C), C) â†’ËœEâ€²
R( ËœRÎ²(Câ€²), Câ€²) from the induction
hypothesis. Therefore, câ€²â€²â€² is in ËœEâ€²
R( ËœRÎ²(Câ€²), Câ€²), and from deï¬nition 4.3.5, (âˆ—) is
in ËœRÎ²+1(C). Therefore, by induction, R(e) is calculable with respect to ËœRÎ²(C) â†’
ËœRÎ²(Câ€²) for any Î², so it is calculable with respect to ËœR(C) â†’ËœR(Câ€²). When R(X)
is contravariant, we can similarly prove that R(e) is calculable with respect to
ËœR(Câ€²) â†’ËœR(C).
3. If F be a right object declared by
right object Râ€²(X) with ÏˆRâ€² is
Î±Râ€²: prod(Râ€², ERâ€²(X)) â†’Eâ€²
R(R, X)
end object,
we can similarly prove that R(e) is calculable with respect to ËœR(C) â†’ËœR(Câ€²) (or
with respect to ËœR(Câ€²) â†’ËœR(C) when R(X) is contravariant). []

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
106
In the following few lemmas, we are to prove all the expressions are calculable.
Lemma 4.3.10: I is calculable.
Proof: We have to show that for any computable canonical element c there is a
reduction of âŸ¨I, câŸ©â‡’câ€² and that câ€² is computable. This is immediate from the reduction
rule IDENT and that câ€² is c []
Lemma 4.3.11: If both e1 and e2 are calculable, so is e1 â—¦e2.
Proof: For any computable canonical element câ€™ we have the following reduction from
COMP:
âŸ¨e2, câŸ©â‡’câ€²â€²
âŸ¨e1, câ€²â€²âŸ©â‡’câ€²
âŸ¨e1 â—¦e2, câŸ©â‡’câ€²
Since e2 is calculable, there is a reduction for âŸ¨e2, câŸ©â‡’câ€²â€² so that câ€²â€² is computable.
Since e1 is calculable, there is a reduction for âŸ¨e1, câ€²â€²âŸ©â‡’câ€² so that câ€² is computable.
Therefore, there is a reduction for âŸ¨e1 â—¦e2, câŸ©â‡’câ€² so that câ€² is computable. []
Lemma 4.3.12: For any natural transformation Î±L of a left object L, Î±L is calculable.
Proof: For any computable canonical element c, we have the following reduction by
L-NAT:
âŸ¨Î±L, câŸ©â‡’Î±L â—¦c
From deï¬nition 4.3.6, Î±L â—¦c is computable. Therefore, Î±L is calculable. []
Lemma 4.3.13: For any natural transformation Î±R of a right object R, Î±R is calcu-
lable.
Proof: Let R be
right object R(X) with ÏˆR is
Î±R: R â†’Eâ€²
R(R, X)
end object,
and c be a computable canonical element R(E). For any Î², c is in ËœRÎ²+1(â„¦E). From
deï¬nition 4.3.5, there exists a reduction âŸ¨Î±R, câŸ©â‡’câ€² such that câ€² is in ËœEâ€²
R( ËœRÎ²(â„¦E), â„¦E).
Because the result of reductions does not depend on Î², câ€² is in
ËœEâ€²
R(
\
Î²
ËœRÎ²(â„¦E), â„¦E) = ËœEâ€²
R( ËœR(â„¦E), â„¦E) = â„¦Eâ€²
R(R(E),E).
Therefore, Î±R is calculable. We can similarly prove that for a right object
right object Râ€²(X) with ÏˆRâ€² is
Î±Râ€²: prod(Râ€², ERâ€²(X)) â†’Eâ€²
Râ€²(Râ€², X)
end object,
Î±Râ€² is calculable. []
Lemma 4.3.14: If e is calculable, so is ÏˆL(e) where L is a left object and ÏˆL is its
factorizer.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
107
Proof: Let L be
left object L(X) with ÏˆL is
Î±L: EL(L, X) â†’L
end object,
and e: EL(E, Eâ€²) â†’E be a calculable CSL expression. We will prove that ÏˆL(e) is
calculable with respect to ËœLÎ²(â„¦Eâ€²) â†’â„¦E by induction on Î². Trivially, it is calculable
with respect to ËœL0(â„¦Eâ€²) â†’â„¦E because ËœL0(â„¦Eâ€²) is empty. Assume we have proved that
ÏˆL(e) is calculable with respect to ËœLÎ²(â„¦Eâ€²) â†’â„¦E. An element in ËœLÎ²+1(â„¦Eâ€²) is Î±L â—¦c
for c which is in ËœEL(ËœLÎ²(â„¦Eâ€²), â„¦Eâ€²). From L-FACT, we get
âŸ¨EL(ÏˆL(e), I), câŸ©â‡’câ€²â€²
âŸ¨e, câ€²â€²âŸ©â‡’câ€²
âŸ¨e â—¦EL(ÏˆL(e), I), câŸ©â‡’câ€²
âŸ¨ÏˆL(e), Î±L â—¦câŸ©â‡’câ€²
From proposition 4.3.9 and the induction hypothesis, EL(ÏˆL(e), I) is calculable with re-
spect to ËœEL(ËœLÎ²(â„¦Eâ€²), â„¦Eâ€²) â†’ËœEL(â„¦E, â„¦Eâ€²), and there is a reduction âŸ¨EL(ÏˆL(e), I), câŸ©â‡’
câ€²â€². Since e is calculable, there is a reduction âŸ¨e, câ€²â€²âŸ©â‡’câ€² such that câ€² is in â„¦E. Therefore,
ÏˆR(e) is calculable with respect to ËœLÎ²+1(â„¦Eâ€²) â†’â„¦E, and by induction it is calculable
with respect to ËœLÎ²(â„¦Eâ€²) â†’â„¦E for any Î². Because â„¦L(Eâ€²) = ËœL(â„¦Eâ€²) is S
Î² ËœLÎ²(â„¦Eâ€²), we
have proved that ÏˆL(e) is calculable. []
Lemma 4.3.15: If e is calculable, so is ÏˆR(e) where R is a right object and ÏˆR is its
factorizer.
Proof: Let R be
right object R(X) with ÏˆR is
Î±R: R â†’Eâ€²
R(R, X)
end object,
and e be a CSL expression of type E â†’Eâ€²
R(E, Eâ€²). We are to prove that ÏˆR(e): E â†’
R(Eâ€²) is calculable.
Since â„¦R(Eâ€²) = ËœR(â„¦Eâ€²) is T
Î² ËœRÎ²(â„¦Eâ€²), we prove that ÏˆR(e) is
calculable with respect to â„¦E â†’ËœRÎ²(â„¦Eâ€²) by induction on Î². Trivially, it is calculable
with respect to â„¦E â†’ËœR0(â„¦Eâ€²) because for any c âˆˆâ„¦E we have âŸ¨ÏˆR(e), câŸ©â‡’ÏˆR(e) â—¦c
and ËœR0(â„¦Eâ€²) is the set of all the canonical elements of type R(Eâ€²). Assume we have
proved that ÏˆR(e) is calculable with respect to â„¦E â†’ËœRÎ²(â„¦Eâ€²). For any c âˆˆâ„¦E we
have âŸ¨ÏˆR(e), câŸ©â‡’ÏˆR(e) â—¦c. From R-NAT, we get
âŸ¨e, câŸ©â‡’câ€²â€²
âŸ¨Eâ€²
R(ÏˆR(e), I), câ€²â€²âŸ©â‡’câ€²
âŸ¨Î±R, ÏˆR(e) â—¦câŸ©â‡’câ€²
.
Since e is calculable, there is a reduction âŸ¨e, câŸ©â‡’câ€²â€² and câ€²â€² is in ËœEâ€²
R(â„¦E, â„¦Eâ€²). As
we assumed that ÏˆR(e) is calculable with respect to â„¦E â†’ËœRÎ²(â„¦Eâ€²), Eâ€²
R(ÏˆR(e), I) is
calculable with respect to ËœEâ€²
R(â„¦E, â„¦Eâ€²) â†’ËœEâ€²
R( ËœRÎ²(â„¦Eâ€²), â„¦Eâ€²) from proposition 4.3.9.
Therefore, there is a reduction âŸ¨Eâ€²
R(ÏˆR(e), I)câ€²â€²âŸ©â‡’câ€² and câ€² is in ËœEâ€²
R( ËœRÎ²(â„¦Eâ€²), â„¦Eâ€²).
From deï¬nition 4.3.5, ÏˆR(e) â—¦c is in ËœRÎ²+1(â„¦Eâ€²), so ÏˆR(e) is calculable with respect
to â„¦E â†’ËœRÎ²+1(â„¦Eâ€²), and by induction it is calculable with respect to â„¦E â†’ËœRÎ²(â„¦Eâ€²)
for any Î². Therefore, it is calculable with respect to â„¦E â†’ËœR(â„¦Eâ€²). We can similarly

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
108
prove that for a right object
right object Râ€²(X) with ÏˆRâ€² is
Î±Râ€²: prod(Râ€², ERâ€²(X)) â†’Eâ€²
Râ€²(Râ€², X)
end object,
ÏˆRâ€²(e) is calculable. []
Theorem 4.3.16: Any CSL expression e is calculable.
Proof: This is proved by structural induction and each case follows from the lemmas,
4.3.10, 4.3.11, 4.3.12, 4.3.13, 4.3.14 and 4.3.15. []
Corollary 4.3.17: Any canonical element is computable.
Proof: As a canonical element c is a CSL expression, and therefore, from theo-
rem 4.3.16 it is calculable. Because any canonical element of the terminal object 1
is computable, specially I is computable. Therefore, there is a reduction âŸ¨c, IâŸ©â‡’câ€²
such that câ€² is computable. Trivially, câ€² is c (using L-NAT, R-FACT and COMP), so c
is computable. []
We now ï¬nish this section by proving the normalization theorem.
Proof of Normalization 4.3.2: From theorem 4.3.16, any expression e is calculable,
and from corollary 4.3.17, any canonical element is computable. Therefore, from the
deï¬nition 4.3.7 of calculable expressions, there is a reduction âŸ¨e, câŸ©â‡’câ€². []
4.4
Properties of Computable Objects
In section 4.1, we saw that we have to restrict ourselves to computable objects (deï¬ni-
tion 4.1.6) in order to introduce our notion of computability into CDT. Let us see in
this section some of the properties which these particular objects enjoy.
First, we show that computable left objects are ï¬xed points of some domain equations.
Theorem 4.4.1: Let L be a computable left object declared as follows.
left object L(X1, . . . , Xn) with ÏˆL is
Î±L,1: EL,1(L, X1, . . . , Xn) â†’L
Â· Â· Â·
Î±L,m: EL,m(L, X1, . . . , Xn) â†’L
end object
Then, the following isomorphism holds in any CSL structure which has L and coprod-
ucts.
L(X1, . . . , Xn) âˆ¼=
m
X
j=1
EL,j(L(X1, . . . , Xn), X1, . . . , Xn)

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
109
where Pm
j=1 is the m-ary coproduct. Furthermore, if A is an object which satisï¬es
A âˆ¼=
m
X
j=1
EL,j(A, X1, . . . , Xn),
there is a unique morphism h from L(X1, . . . , Xn) to A such that the following diagram
commutes.
m
X
j=1
EL,j(A, X1, . . . , Xn)
âˆ¼=
A
m
X
j=1
EL,j(h, X1, . . . , Xn)
Â¥
Â¨Â§?
h
m
X
j=1
EL,j(L(X1, . . . , Xn), X1, . . . , Xn)
âˆ¼=
L(X1, . . . , Xn)
-
-
?
?
Proof: For simplicity, we prove the isomorphism in case L does not have any param-
eters (i.e. n = 0). Therefore, the isomorphism we prove is
L âˆ¼=
m
X
j=1
EL,j(L).
Let f be a morphism
[Î±L,1, . . . , Î±L,m]
where [ , . . . , ] is the factorizer of Pm
j=1. f is a morphism from Pm
j=1 EL,j(L) to L. Let
g be a morphism
ÏˆL(Î½1 â—¦EL,1(f), . . . , Î½m â—¦EL,m(f))
where Î½j is the j-th injection of Pm
j=1 . g is a morphism from L to Pm
j=1 EL,j(L). We
show that f is the inverse of g. Let us ï¬rst show that f â—¦g = I.
f â—¦g â—¦Î±L,j
= f â—¦Î½j â—¦EL,j(f) â—¦EL,j(g) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (from (LEQj))
= Î±L,j â—¦EL,j(f) â—¦EL,j(g)
= Î±L,j â—¦EL,j(f â—¦g). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .(EL,j(L) is covariant)
From (LCEQ),
f â—¦g = ÏˆR(Î±L,1, . . . , Î±L,m) = I.
The second equality holds again from (LCEQ). Next we show that g â—¦f = I.
g â—¦f
= [g â—¦Î±L,1, . . . , g â—¦Î±L,m]
= [Î½1 â—¦EL,1(f â—¦g), . . . , Î½m â—¦EL,m(f â—¦g)]
= [Î½1 â—¦EL,1(I), . . . , Î½m â—¦EL,m(I)]
= [Î½1, . . . , Î½m]
= I

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
110
Therefore, L âˆ¼=
Pm
j=1 EL,j(L). For any object A which satisï¬es A âˆ¼=
Pm
j=1 EL,j(A), let
i be the isomorphism from Pm
j=1 EL,j(A) to A, then the unique morphism is given by
ÏˆR(i â—¦Î½1, . . . , i â—¦Î½m).
It is easy to see the diagram commutes from (LEQj) and the uniqueness from (LCEQ). []
If we apply this theorem to the objects we deï¬ned in chapter 3, we get the following
isomorphisms.
nat âˆ¼= 1 + nat
list(X) âˆ¼= 1 + prod(X, list(X))
We can see the exact correspondence to domain theory. In domain theory, the domain
of natural numbers and that of lists are deï¬ned as the minimal domains which satisï¬es
the above isomorphisms.
By duality principle, we have the dual theorem of theorem 4.4.1.
Theorem 4.4.2: Let R be a computable right object declared as follows.
right object R(X1, . . . , Xn) with ÏˆR is
Î±R,1: R â†’Eâ€²
R,1(R, X1, . . . , Xn)
Â· Â· Â·
Î±R,m: R â†’Eâ€²
R,m(R, X1, . . . , Xn)
end object
Then, the following isomorphism holds in any CSL structure which has R and products.
R(X1, . . . , Xn) âˆ¼=
m
Y
j=1
Eâ€²
R,j(R(X1, . . . , Xn), X1, . . . , Xn)
where Qm
j=1 is the m-ary product. Furthermore, if A is an object which satisï¬es
A âˆ¼=
m
Y
j=1
Eâ€²
R,j(A, X1, . . . , Xn),
there is a unique morphism h from A to R(X1, . . . , Xn) such that the following diagram
commutes.
R(X1, . . . , Xn)
A
h
âˆ¼=
âˆ¼=
Â¥
Â¨Â§?
m
Y
j=1
Eâ€²
R,j(R(X1, . . . , Xn), X1, . . . , Xn)
m
Y
j=1
Eâ€²
R,j(h, X1, . . . , Xn)
m
Y
j=1
Eâ€²
R,j(A, X1, . . . , Xn)
-
-
?
?
Proof: By duality. []

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
111
We can see that the inï¬nite list deï¬ned in subsection 3.3.6 is the maximal ï¬xed point
of the following domain equation.
inï¬‚ist(X) âˆ¼= X Ã— inï¬‚ist(X)
The next theorem states that productive objects deï¬ne products.
Theorem 4.4.3: Let P(Y1, . . . , Yn) be a functor which is productive in Yi. Then, there
is a functor F(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn) such that
P(Y1, . . . , Yn) âˆ¼= Yi Ã— F(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn)
Proof: First, note that it is easy to extend the theorem to productive functorial
expressions by simply applying the theorem repeatedly. Let us prove the theorem by
induction on the order of declaration of productive objects. Let the declaration of P
to be as follows.
right object P(Y1, . . . , Yi, . . . , Yn) with ÏˆP is
Î±P,1: EP,1(P, Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn) â†’Eâ€²
P,1(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn)
Â· Â· Â·
Î±P,j: P â†’Eâ€²
P,j(Y1, . . . , Yiâˆ’1, Yi, Yi+1, . . . , Yn)
Â· Â· Â·
Î±P,m: EP,m(P, Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn) â†’Eâ€²
P,m(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn)
end object
By induction hypothesis and from what we note at the beginning of the proof, there is
a functor F â€²(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn) such that
Eâ€²
P,j(Y1, . . . , Yn) âˆ¼= Yi Ã— F â€²(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn).
Since P is a computable object as well, EP,k(P, Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn) is productive
in P. Therefore, from induction hypothesis there are functors
Gk(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn)
such that
EP,k(P, Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn) âˆ¼= P Ã— Gk(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn).
Using exponentials, the above deï¬nition of P is essentially the same as
right object P(Y1, . . . , Yi, . . . , Yn) with ÏˆP is
Î±P,1: P â†’exp(G1(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn),
Eâ€²
P,1(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn))
Â· Â· Â·
Î±P,j: P â†’Yi Ã— F â€²(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn)
Â· Â· Â·
Î±P,m: P â†’exp(Gm(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn),
Eâ€²
P,m(Y1, . . . , Yiâˆ’1, Yi+1, . . . , Yn))
end object

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
112
From theorem 4.4.2, we have
P(Y1, . . . , Yn) âˆ¼= Yi Ã— F â€²(Y1, . . .) Ã—
m
Y
k=1
kÌ¸=j
exp(Gk(Y1, . . .), Eâ€²
P,k(Y1, . . .)).
F â€²(Y1, . . .)Ã—Qm
k=1
kÌ¸=j exp(Gk(Y1, . . .), Eâ€²
P,k(Y1, . . .)) does not depend on Yi. We have proved
the theorem. []
From this theorem, we can always make the declaration of computable objects into
an equivalent declaration to which we can apply theorem 4.4.2.
For example, the
declaration of the object for automata in subsection 3.3.7 was
right object dynâ€²(I, O) with univâ€² is
nextâ€²: prod(dynâ€², I) â†’dynâ€²
outputâ€²: dynâ€² â†’O
end object
to which we cannot apply theorem 4.4.2, but the above declaration is equivalent to the
following one.
right object dynâ€²(I, O) with univâ€² is
nextâ€²: dynâ€² â†’exp(I, dynâ€²)
outputâ€²: dynâ€² â†’O
end object
Then, from theorem 4.4.2 we can see dynâ€²(I, O) as the maximal ï¬xed point of the
following domain equation.
dynâ€²(I, O) âˆ¼= exp(I, dynâ€²(I, O)) Ã— O
4.5
Reduction Rules for Full Evaluation
In section 4.1 we presented a set of reduction rules which can reduce any element to a
canonical element. However, the notion of canonical element (deï¬nition 4.1.3) was quite
weak (or sloppy), and the canonical elements we get out of reductions sometimes not
acceptable as â€˜canonicalâ€™. We can deï¬ne a more reï¬ned notion of canonical elements.
Deï¬nition 4.5.1: A canonical element is called uncondition, if it is generated by the
following rule.
p : : = I | Î±L,j â—¦p | ÏˆR(e1, . . . , em) â—¦p | ÏˆC(. . . , ej, . . . , pk, . . .)
where R is not a unconditioned right object, C is a unconditioned object
right object C(X1, . . . , Xn) with ÏˆC is
Â· Â· Â·
Î±C,j: EC,j(C, X1, . . . , Xn) â†’Eâ€²
C,j(X1, . . . , Xn)
Â· Â· Â·
Î±C,k: C â†’Eâ€²
C,k(X1, . . . , Xn)
Â· Â· Â·
end object

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
113
and if EC,k(C, X1, . . . , Xn) is simply C then the kth argument of ÏˆC needs to be a
unconditioned canonical element. []
For example,
pair(succ, I) â—¦zero
and
pair(pi1 â—¦pair(succ â—¦zero, nil), zero)
are canonical elements but not unconditioned. Their equivalent unconditioned canon-
ical element is â€˜pair(succ â—¦zero, zero)â€™.
We can deï¬ne reduction rules which only produce unconditioned canonical elements as
result.
Deï¬nition 4.5.2: The form of reduction rules is
âŸ¨e, pâŸ©â‡’â‡’pâ€²
where e is a CSL expression and p is a unconditioned canonical element whose domain
is compatible with the domain of e.
1. FULL-IDENT
âŸ¨I, pâŸ©â‡’â‡’p
2. FULL-COMP
âŸ¨e2, pâŸ©â‡’â‡’pâ€²â€²
âŸ¨e1, pâ€²â€²âŸ©â‡’â‡’pâ€²
âŸ¨e1 â—¦e2, pâŸ©â‡’â‡’pâ€²
3. FULL-L-NAT
âŸ¨Î±L,j, pâŸ©â‡’â‡’Î±L,j â—¦p
4. FULL-R-FACT
âŸ¨ÏˆR(e1, . . . , em), pâŸ©â‡’â‡’ÏˆR(e1, . . . , em) â—¦p
where R is not a unconditioned right object.
5. FULL-C-FACT
âŸ¨ej, pâŸ©â‡’â‡’eâ€²
j
or
eâ€²
j â‰¡ej â—¦EC,j[p/C]
âŸ¨ÏˆC(e1, . . . , em), pâŸ©â‡’â‡’ÏˆC(eâ€²
1, . . . , eâ€²
m)
where C is a unconditioned right object and eâ€²
j is either the result of evaluating
âŸ¨ej, pâŸ©or ej â—¦EC,j[p/C] depending of whether EC,j is simply C or not.
6. FULL-L-FACT
âŸ¨ej â—¦EL,j[ÏˆL(e1, . . . , em)/L], pâŸ©â‡’â‡’pâ€²
âŸ¨ÏˆL(e1, . . . , em), Î±L,j â—¦pâŸ©â‡’â‡’pâ€²

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
114
7. FULL-R-NAT
âŸ¨Eâ€²
R,j[ÏˆR(e1, . . . , em)/R] â—¦ej, ÏˆP(. . . , p, . . .)âŸ©â‡’â‡’pâ€²
âŸ¨Î±R,j, ÏˆP(. . . , ÏˆR(e1, . . . , em) â—¦p, . . .)âŸ©â‡’â‡’pâ€²
In writing down this rule, ÏˆP(. . . , ÏˆR(e1, . . . , em) â—¦p, . . .) is rather inaccurate. It
means picking up ÏˆR(e1, . . . , em) according to the occurrence of R in ER,j. ÏˆPâ€™s
are nested as productive objects Pâ€™s are in ER,j. For example, the rule for â€˜pi1â€™
of object â€˜prodâ€™ is
âŸ¨p1, IâŸ©â‡’â‡’pâ€²
âŸ¨pi1, pair(p1, p2)âŸ©â‡’â‡’pâ€²
.
Eprod,1 is simply â€˜prodâ€™, so there is no ÏˆCâ€™s. The rule for â€˜evalâ€™ of object â€˜expâ€™ is
âŸ¨e, pair(I, p)âŸ©â‡’â‡’pâ€²
âŸ¨eval, pair(curry(e), p)âŸ©â‡’â‡’pâ€²
.
Remember that Eexp,1 is â€˜prod(exp, X)â€™.
Let us call the new system FULL and the previous system deï¬ned in deï¬nition 4.1.7
LAZY. []
As we have proved theorem 4.3.1, we can easily show that FULL system is well-deï¬ned.
In addition, we can show that the reduction in FULL system is stronger than that in
LAZY system, that is,
Proposition 4.5.3: If âŸ¨e, pâŸ©â‡’â‡’pâ€² in FULL system, then âŸ¨e, pâŸ©â‡’câ€² in LAZY sys-
tem. []
On the other hand, since a FULL reduction is nothing but the repeated application of
LAZY reductions, we have the normalization theorem.
Theorem 4.5.4: For a unconditioned canonical element p and a CSL expression e
whose domain is compatible with the codomain of p, there is a unconditioned canonical
element pâ€² such that
âŸ¨e, pâŸ©â‡’â‡’pâ€²
in FULL reduction system. []

Chapter 5
Application of Categorical Data
Types
In this chapter we see some applications of CDT and CPL. We have concentrated on
category theory in the previous chapters and it is sometimes hard to relate our results
to others if they are not familiar with category theory. The author is not claiming that
it is better to use category theory in practice. Category theory is used as a guiding
principle to see things without being obscured by inessentials. Therefore, once one
establishes some results using category theory, it is very interesting to see what it
means in other terms and we might get some deep insight.
In section 5.1, we will see an implementation of CPL. In section 5.2, we will examine the
connection between CDT and typed lambda calculi and in section 5.3 we will propose
a new ML which is obtained by combining the current ML and CPL.
5.1
An implementation of
Categorical Programming Language
In chapter 4, we introduced a programming language CPL and its computation rules.
A CPL system has been implemented using Franz Lisp. In the section, we will demon-
strate the system and see some examples of reductions which it can manage.
When the system is started, it prints the following message and waits for user com-
mands.
Categorical Programming Language (version 3)
cpl>
First, we have to declare some objects because the system does not know any objects
when it is started. The very ï¬rst object we declare is the terminal object. We use edit
command to enter its declaration.
115

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
116
cpl>edit
| right object 1 with !
| end object;
right object 1 defined
cpl>
Note that user inputs are in italic font. We deï¬ne products, exponentials and natural
number object as well.
The declarations are exactly the same as we presented in
chapter 3 (except that to make output shorter we use â€˜sâ€™ for successor and â€˜0â€™ for zero).
cpl>edit
| right object prod(a,b) with pair is
|
pi1: prod -> a
|
pi2: prod -> b
| end object;
right object prod(+,+) defined
cpl>edit
| right object exp(a,b) with curry is
|
eval: prod(exp,a) -> b
| end object;
right object exp(-,+) defined
cpl>edit
| left object nat with pr is
|
0: 1 -> nat
|
s: nat -> nat
| end object;
left object nat defined
cpl>edit
| left object coprod(a,b) with case is
|
in1: a -> coprod
|
in2: b -> coprod
| end object;
left object coprod(+,+) defined
cpl>
Each time we declare an object the system remembers its factorizer and natural trans-
formations as well as the functor associated with. In the above transaction, â€˜prod(+,+)â€™
indicates that system recongnized â€˜prodâ€™ as a covariant functor of two arguments
whereas â€˜exp(-,+)â€™ indicates that â€˜expâ€™ is a functor which is contravariant in the ï¬rst
argument and covariant in the second. The variance is calculated as we formulated in
section 3.2. The system can type CSL expressions using the rules in section 2.4. For
example, we can ask the type of â€˜pair(pi2,eval)â€™.
cpl>show pair(pi2,eval)
pair(pi2,ev)
: prod(exp(*b,*a),*b) -> prod(*b,*a)
cpl>
where â€˜*aâ€™ and â€˜*bâ€™ are variables for objects, or we can see them as a kind of type
variables in ML; â€˜pair(pi2,eval)â€™ is a polymorphic function in this sense.
As we have done in section 4.2, we can ask to the system to calculate â€˜1+1â€™ using â€˜simpâ€™
command.
cpl>simp eval.pair(pr(curry(pi2),curry(s.eval)).pi1,pi2).pair(s.0,s.0)

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
117
s.s.0
:1 -> nat
cpl>
Note that the composition â€˜â—¦â€™ is typed as â€˜.â€™. The system applied reduction rules to
get the following reduction:
âŸ¨eval.pair(. . .).pair(s.0, s.0), IâŸ©â‡’s.s.0.
We can see how the system deduced the reduction by enabling the trace mode.
cpl>set trace on
cpl>simp eval.pair(pr(curry(pi2),curry(s.eval)).pi1,pi2).pair(s.0,s.0)
0:eval.pair(pr(curry(pi2),curry(s.eval)).pi1,pi2).pair(s.0,s.0)*
1:eval.pair(pr(curry(pi2),curry(s.eval)).pi1,pi2)*pair(s.0,s.0)
2:eval*pair(pr(curry(pi2),curry(s.eval)).pi1,pi2).pair(s.0,s.0)
3[1]:pr(curry(pi2),curry(s.eval)).pi1*pair(s.0,s.0)
4[1]:pr(curry(pi2),curry(s.eval)).s.0*id
5[1]:pr(curry(pi2),curry(s.eval)).s*0
6[1]:pr(curry(pi2),curry(s.eval))*s.0
7[1]:curry(s.eval).pr(curry(pi2),curry(s.eval))*0
8[1]:curry(s.eval).curry(pi2).!*
9[1]:curry(s.eval).curry(pi2)*!
10[1]:curry(s.eval)*curry(pi2).!
11[1]:*curry(s.eval).curry(pi2).!
12:s.eval*pair(curry(pi2).!,pi2.pair(s.0,s.0))
13[1]:curry(pi2).!*
14[1]:curry(pi2)*!
15[1]:*curry(pi2).!
16:s.pi2*pair(!,pi2.pair(s.0,s.0))
17:s.pi2.pair(s.0,s.0)*id
18:s.pi2*pair(s.0,s.0)
19:s.s.0*id
20:s.s*0
21:s*s.0
22:*s.s.0
s.s.0
:1 -> nat
cpl>
Each line has the following form:
step number [ depth of computation ]: expression âˆ—canonical element
It indicates the following reduction:
âŸ¨expression , canonical element âŸ©â‡’. . .
Step 0 denotes the reduction of
âŸ¨eval.pair(pr(curry(pi2), curry(s.eval)).pi1, pi2).pair(s.0, s.0), IâŸ©â‡’. . ..
(+)
Step 1 is obtained from R-FACT rule (and R-COMP); the reduction (+) is the same
as the reduction of
âŸ¨eval.pair(pr(curry(pi2), curry(s.eval)).pi1, pi2), pair(s.0, s.0)âŸ©â‡’. . ..

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
118
Again from R-FACT, this reduction is the same as
âŸ¨eval, pair(pr(curry(pi2), curry(s.eval)).pi1, pi2).pair(s.0, s.0)âŸ©â‡’. . ..
(++)
which is step 2. From R-NAT, we have to calculate
âŸ¨pair(pr(curry(pi2), curry(s.eval)).pi1, pi2).pair(s.0, s.0),
prod(exp, a), expâŸ©; âŸ¨curry(. . .), . . .âŸ©.
In order to do this, from R-NAT-F we have to calculate
âŸ¨pr(curry(pi2), curry(s.eval)).pi1, pair(s.0, s.0)âŸ©â‡’. . .
(â€ )
This reduction is carried out from step 3 to step 12 and we get
âŸ¨pr(curry(pi2), curry(s.eval)).pi1, pair(s.0, s.0)âŸ©â‡’curry(s.eval).curry(pi2).!.
Note that from step 3 to 4 it did the reduction
âŸ¨pi1, pair(s.0, s.0)âŸ©â‡’s.0,
and from step 6 to 7 it used L-FACT and did the reduction
âŸ¨curry(s.eval).pr(curry(pi1), curry(s.eval)), 0âŸ©â‡’. . .
âŸ¨pr(curry(pi2), curry(s.eval)), s.0âŸ©â‡’. . .
.
Therefore, (â€ ) is
âŸ¨pr(curry(pi2), curry(s.eval)).pi1, pair(s.0, s.0)âŸ©â‡’âŸ¨curry(s.eval), curry(pi2).!âŸ©,
and from R-NAT the reduction of (++) is the same as
âŸ¨s.eval, pair(curry(pi2).!, pi2.pair(s.0, s.0))âŸ©â‡’. . ..
The rest of the steps are done similarly.
It is inconvenient to write down the deï¬nition of the addition every time we want to
add something. Therefore, the system has the facility to give names to morphisms.
For example, we can name the addition function â€˜addâ€™ and use it as follows:
cpl>let add=eval.pair(pr(curry(pi2),curry(s.eval)).pi1,pi2)
add : prod(nat,nat) -> nat defined
cpl>simp add.pair(s.0,s.s.0)
s.s.s.0
:1 -> nat
We can deï¬ne the multiplication and factorial functions.
cpl>let mult=eval.prod(pr(curry(0.!),curry(add.pair(eval,pi2))),id)
mult : prod(nat,nat) -> nat defined
cpl>let fact=pi1.pr(pair(s.0,0),pair(mult.pair(s.pi2,pi1),s.pi2))
fact : nat -> nat defined
cpl>simp mult.pair(s.s.0,s.s.s.0)
s.s.s.s.s.s.0
:1 -> nat
cpl>simp fact.s.s.s.s.0
s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.0.!
:1 -> nat
cpl>
Let us next deï¬ne the object for lists.

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
119
cpl>edit
| left object list(p) with prl is
|
nil:1->list
|
cons:prod(p,list)->list
| end object;
left object list(+) defined
cpl>edit
| let append=eval.prod(prl(curry(pi2),
|
curry(cons.pair(pi1.pi1,eval.pair(pi2.pi1,pi2)))),
|
id);
append : prod(list(*a),list(*a)) -> list(*a) defined
cpl>let reverse=prl(nil,append.pair(pi2,cons.pair(pi1,nil.!)))
reverse : list(*a) -> list(*a) defined
cpl>let hd=prl(in2,in1.pi1)
hd : list(*a) -> coprod(*a,1) defined
cpl>let hdp=case(hd,in2)
hdp : coprod(list(*a),1) -> coprod(*a,1) defined
cpl>let tl=case(in1.pi2,in2).prl(in2,in1.pair(pi1,case(cons,nil).pi2))
tl : list(*a) -> coprod(list(*a),1) defined
cpl>let tlp=case(tl,in2)
tlp : coprod(list(*a),1) -> coprod(list(*a),1) defined
cpl>let seq=pi2.pr(pair(0,nil),pair(s.pi1,cons))
seq : nat -> list(nat) defined
cpl>
The morphism â€˜seqâ€™ returns a list of length n for a given natural number n such that
the list consists of the descending sequence of natural numbers, n âˆ’1, n âˆ’2, . . . , 2, 1, 0.
We can try it in the system.
cpl>simp seq.s.s.s.0
cons.pair(s.pi1,cons).pair(s.pi1,cons).pair(0,nil).!
:1 -> list(nat)
cpl>
The result dose not look like the sequence of 2, 1 and 0, but this is because our deï¬nition
of canonical element (deï¬nition 4.1.3) is weak. We can ask the system to reduce an
element to unconditioned canonical elements (see deï¬nition 4.5.1) using reduction rules
listed in deï¬nition 4.5.2.
cpl>simp full seq.s.s.s.0
cons.pair(s.s.0.!,cons.pair(s.0.!,cons.pair(0.!,nil.!)))
:1 -> list(nat)
cpl>
Now, it looks more like the sequence of 2, 1, and 0. We may continue to do some more
reductions about lists.
cpl>simp hd.seq.s.s.s.0
in1.s.s.0.!
:1 -> coprod(nat,1)
cpl>simp hd.nil
in2.!
:1 -> coprod(*a,1)
cpl>simp hdp.tl.seq.s.s.s.0
in1.s.0.!

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
120
:1 -> coprod(nat,1)
cpl>simp full append.pair(seq.s.s.0,seq.s.s.s.0)
cons.pair(s.0.!,cons.pair(0.!,cons.pair(s.s.0.!,cons.pair(s.0.!,cons.
pair(0.!,nil.!)))))
:1 -> list(nat)
cpl>simp full reverse.it
cons.pair(0.!,cons.pair(s.0.!,cons.pair(s.s.0.!,cons.pair(0.!,cons.
pair(s.0.!,nil.!)))))
:1 -> list(nat)
cpl>
where â€˜itâ€™ denotes the result of the immediately-preceding reduction.
Let us next experiment with inï¬nite lists.
cpl>edit
| right object inï¬‚ist(a) with fold is
|
head: inï¬‚ist -> a
|
tail: inï¬‚ist -> inï¬‚ist
| end object;
right object inflist(+) defined
cpl>let incseq=fold(id,s).0
incseq : 1 -> inflist(nat) defined
cpl>simp head.incseq
0
:1 -> nat
cpl>simp head.tail.tail.tail.incseq
s.s.s.0
:1 -> nat
cpl>let alt=fold(head.pi1,pair(pi2,tail.pi1))
alt : prod(inflist(*a),inflist(*a)) -> inflist(*a)
cpl>let infseq=fold(id,id).0
infseq : 1 -> inflist(nat)
cpl>simp head.tail.tail.alt.pair(incseq,infseq)
s.0
:1 -> nat
cpl>
where â€˜incseqâ€™ is the inï¬nite increasing sequence 0, 1, 2, 3, 4, . . . , and â€˜infseqâ€™ is
the inï¬nite sequence of 0s. We can merge two inï¬nite lists by â€˜altâ€™ which picks up
elements alternatively from the two inï¬nite lists.
5.2
Typed Lambda Calculus
In this section, we will investigate connection between CPL and typed lambda calculi.
Lambda calculi were invented to mathematically formalize the notion of computation.
Typed lambda calculi (ï¬rst order) are an important part of lambda calculi and are
studied in various ways. Usually a typed lambda calculus starts with a ï¬xed number
of ground types and allows only â†’as type constructors. For example, [Stenlund 72]
treats natural numbers and ordinals, and [Troelstra 73] deals with one level higher
ordinals.
An interesting question is â€œWhat kind of types can be added to lambda

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
121
calculi?â€ Natural numbers, ordinals, lists, . . . . We will show in this section that any
data types we can deï¬ne in CPL can be added into typed lambda calculi.
We are to deï¬ne a typed lambda calculus. As CPL does not have any ground objects
to start with, our lambda calculus does not have any ground types either. Instead it
has two ways of constructing types, one corresponding to forming left objects and the
other corresponding to forming right objects.
Deï¬nition 5.2.1: The syntax of our lambda calculus is given as follows.
1. An enumerable set TVar of type variables. Ï, Î½, . . . âˆˆTVar.
2. The set Type of types is deï¬ned by the following rules.
Ï âˆˆTVar
Ï âˆˆÎ“
Î“ âŠ¢Ï âˆˆType
âˆ…âŠ¢Ïƒ âˆˆType
Î“ âŠ¢Ï„ âˆˆType
Î“ âŠ¢Ïƒ â†’Ï„ âˆˆType
Î“ âˆª{ Ï } âŠ¢Ïƒ1 âˆˆType
. . .
Î“ âˆª{ Ï } âŠ¢Ïƒn âˆˆType
Î“ âŠ¢ÂµÏ.(Ïƒ1, . . . , Ïƒn) âˆˆType
Î“ âˆª{ Ï } âŠ¢Ïƒ1 âˆˆType
. . .
Î“ âˆª{ Ï } âŠ¢Ïƒn âˆˆType
Î“ âŠ¢ÂµÏ.(Ïƒ1, . . . , Ïƒn) âˆˆType
We use Ïƒ, Ï„, . . . for the meta-variables of Type. ÂµÏ.(Ïƒ1, . . . , Ïƒn) corresponds to
left objects and ÂµÏ.(Ïƒ1, . . . , Ïƒn) corresponds to right objects.
3. An enumerable set Var of variables. x, y, z, . . . âˆˆVar.
4. The set Term of terms and their types are deï¬ned by the following rules.
x âˆˆVar
x : Ïƒ âˆˆÎ“
Î“ âŠ¢x : Ïƒ
Î“ âˆª{ x : Ïƒ} âŠ¢t : Ï„
Î“ âŠ¢Î»xÏƒ.t : Ïƒ â†’Ï„
Î“ âŠ¢t1 : Ïƒ â†’Ï„
Î“ âŠ¢t2 : Ïƒ
Î“ âŠ¢t1t2 : Ï„
Î“ âŠ¢CÂµÏ.(Ïƒ1,...,Ïƒn),i : Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï] â†’ÂµÏ.(Ïƒ1, . . . , Ïƒn)
Î“ âŠ¢JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ : (Ïƒ1[Ï„/Ï] â†’Ï„) â†’. . . â†’(Ïƒn[Ï„/Ï] â†’Ï„) â†’
ÂµÏ.(Ïƒ1, . . . , Ïƒn) â†’Ï„
Î“ âŠ¢DÂµÏ.(Ïƒ1,...,Ïƒn),i : ÂµÏ.(Ïƒ1, . . . , Ïƒn) â†’Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï]
Î“ âŠ¢PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ : (Ï„ â†’Ïƒ1[Ï„/Ï]) â†’. . . â†’(Ï„ â†’Ïƒn[Ï„/Ï]) â†’
Ï„ â†’ÂµÏ.(Ïƒ1, . . . , Ïƒn)
CÂµÏ.(Ïƒ1,...,Ïƒn),i is the i-th constructor of ÂµÏ.(Ïƒ1, . . . , Ïƒn) and JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ is the
generalized iterator for it. DÂµÏ.(Ïƒ1,...,Ïƒn),i and PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ are the dual pairs. []

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
122
We have the usual reduction rules Î± and Î² and two delta rules. We write a â–·b for the
term a reducing to the term b by one step reduction and write a
â‹†â–·b for a reducing to
b by some steps. The two delta rules are:
JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„a1 . . . an(CÂµÏ.(Ïƒ1,...,Ïƒn),ib) â–·ai(Ïƒi[JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„a1 . . . an/Ï]b)
and
DÂµÏ.(Ïƒ1,...,Ïƒn),i(PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„a1 . . . anb) â–·Ïƒi[PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„a1 . . . an/Ï](aib)
where Ïƒ[t/Ï] is a term of type Ïƒ[Ï„/Ï] â†’Ïƒ[Ï…/Ï] when the type of t is Ï„ â†’Ï… and is
deï¬ned as follows.
1. If Ï does not appear in Ïƒ, then Ïƒ[t/Ï] â‰¡Î»xÏƒ.x.
2. Ï[t/Ï] â‰¡t.
3. (Ïƒ1 â†’Ïƒ2)[t/Ï] â‰¡Î»xÏƒ1â†’Ïƒ2[Ï„/Ï].Î»yÏƒ1.Ïƒ2[t/Ï](xy).
4. ÂµÎ½.(Ïƒ1, . . . , Ïƒn)[t/Ï] â‰¡JÂµÎ½.(Ïƒ1[Ï„/Ï],...),ÂµÎ½.(Ïƒ1[Ï…/Ï],...)a1 . . . an
where ai â‰¡Î»xÏƒi[Ï„/Ï][ÂµÎ½.(Ïƒ1[Ï…/Ï],...)/Î½].CÂµÎ½.(Ïƒ1[Ï„/Ï],...),i(Ïƒi[ÂµÎ½.(Ïƒ1[Ï…/Ï], . . .)/Î½][t/Ï]x).
5. ÂµÎ½.(Ïƒ1, . . . , Ïƒn)[t/Ï] â‰¡PÂµÎ½.(Ïƒ1[Ï…/Ï],...),ÂµÎ½.(Ïƒ1[Ï„/Ï],...)a1 . . . an
where ai â‰¡Î»xÂµÎ½.(Ïƒ1[Ï„/Ï],...).Ïƒi[ÂµÎ½.(Ïƒ1[Ï„/Ï], . . .)/Î½][t/Ï](DÂµÎ½.(Ïƒ1[Ï„/Ï],...),ix).
It looks very complicated but this is the faithful translation of Ïƒ[t/Ï] as Ïƒ being a
functor.
Let us see some types we can deï¬ne in our lambda calculus.
Example 5.2.2: The empty type can be deï¬ned as âˆ…â‰¡ÂµÏ.(), and one point type can
be deï¬ned as 1 â‰¡ÂµÏ.(). We denote the element of 1 as âˆ—â‰¡P1,1â†’1Î»x1.x. []
Example 5.2.3: The product of two types, Ïƒ and Ï„ can be deï¬ned as ÏƒÃ—Ï„ â‰¡ÂµÏ.(Ïƒ, Ï„).
We have two projections.
Ï€1 â‰¡DÏƒÃ—Ï„,1
: Ïƒ Ã— Ï„ â†’Ïƒ
Ï€2 â‰¡DÏƒÃ—Ï„,2
: Ïƒ Ã— Ï„ â†’Ï„
If a is a term of type Ïƒ and b is a term of type Ï„, we can deï¬ne a term âŸ¨a, bâŸ©of type
Ïƒ Ã— Ï„.
âŸ¨a, bâŸ©â‰¡PÏƒÃ—Ï„(Î»x1.a)(Î»x1.b)âˆ—
: Ïƒ Ã— Ï„
We have the following reduction.
Ï€1âŸ¨a, bâŸ©â‰¡DÏƒÃ—Ï„,1(PÏƒÃ—Ï„,1(Î»x.a)(Î»x.b)âˆ—) â–·(Î»x.x)((Î»x.a)âˆ—)
â‹†â–·a
Similarly, we can show that Ï€2âŸ¨a, bâŸ©
â‹†â–·b. []
Example 5.2.4: Dually, the coproduct of Ïƒ and Ï„ is deï¬ned as Ïƒ + Ï„ â‰¡ÂµÏ.(Ïƒ, Ï„).
Two injections are deï¬ned as follows.
Î¹1 â‰¡CÏƒ+Ï„,1
: Ïƒ â†’Ïƒ + Ï„
Î¹2 â‰¡CÏƒ+Ï„,2
: Ï„ â†’Ïƒ + Ï„
JÏƒ+Ï„,Î½ satisï¬es the following reductions.
JÏƒ+Ï„,Î½ab(Î¹1c) â‰¡JÏƒ+Ï„,Î½ab(CÏƒ+Ï„,1c) â–·a((Î»x.x)c) â–·ac
JÏƒ+Ï„,Î½ab(Î¹2c)
â‹†â–·bc
[]

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
123
Example 5.2.5: Let us deï¬ne the natural numbers in our lambda calculus.
The
deï¬nition of type is
Ï‰ â‰¡ÂµÏ.(1, Ï).
Zero and the successor function are deï¬ned by
0 â‰¡CÏ‰,1âˆ—
: Ï‰
s â‰¡CÏ‰,2
: Ï‰ â†’Ï‰
J gives us almost the ordinary well-known iterator but its type is
JÏ‰,Ïƒ
: (1 â†’Ïƒ) â†’(Ïƒ â†’Ïƒ) â†’Ï‰ â†’Ïƒ.
We can deï¬ne the ordinary one by this JÏ‰,Ïƒ as follows.
ËœJÏƒ â‰¡Î»x.Î»y.Î»n.JÏ‰,Ïƒ(Î»z.x)yn
: Ïƒ â†’(Ïƒ â†’Ïƒ) â†’Ï‰ â†’Ïƒ
It satisï¬es the usual reductions:
ËœJÏƒab0
â‹†â–·JÏ‰,Ïƒ(Î»z.a)b(CÏ‰,1âˆ—) â–·(Î»z.a)((Î»x.x)âˆ—)
â‹†â–·a
and
ËœJÏƒab(sn)
â‹†â–·JÏ‰,Ïƒ(Î»z.a)b(CÏ‰,2n) â–·b(JÏ‰,Ïƒ(Î»z.a)bn) â‰ˆb( ËœJÏƒabn)
where â‰ˆis the equivalence relation generated by
â‹†â–·. Using ËœJÏƒ, we can deï¬ne all the
primitive recursive functions. For example, the addition function can be deï¬ne as
add â‰¡Î»n.Î»m. ËœJÏ‰msn
: Ï‰ â†’Ï‰ â†’Ï‰.
[]
Example 5.2.6: As [Stenlund 72] and [Troelstra 73], we can deï¬ne the type for or-
dinals by â„¦â‰¡ÂµÏ.(1, Ï‰ â†’Ï). We only check whether our deï¬nition of the iterator
coincides with the ordinary one.
â„¦â‰¡ÂµÏ.(1, Ï‰ â†’Ï)
0â„¦â‰¡Câ„¦,1âˆ—
: â„¦
sup â‰¡Câ„¦,2
: (Ï‰ â†’â„¦) â†’Ï‰
Jâ„¦,Ïƒ
: (1 â†’Ïƒ) â†’((Ï‰ â†’Ïƒ) â†’Ïƒ) â†’â„¦â†’Ïƒ
Jâ„¦,Ïƒ(Î»x.a)b0â„¦â–·(Î»x.a)((Î»x.x)âˆ—)
â‹†â–·a
Jâ„¦,Ïƒ(Î»x.a)b(sup t) â–·b((Ï‰ â†’Ï)[Jâ„¦,Ïƒ(Î»x.a)b/Ï]t)
â‰¡b((Î»y.Î»z.Jâ„¦,Ïƒ(Î»x.a)b(yz))t) â–·b(Î»z.Jâ„¦,Ïƒ(Î»x.a)b(tz))
[]
Example 5.2.7: Finally, the type for ï¬nite lists can be deï¬ned by
LÏƒ â‰¡ÂµÏ.(1, Ïƒ Ã— Ï)

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
124
with
nil â‰¡CLÏƒ,1âˆ—
: LÏƒ
cons â‰¡CLÏƒ,2
: Ïƒ Ã— LÏƒ â†’LÏƒ
JLÏƒ,Ï„
: (1 â†’Ï„) â†’(Ïƒ Ã— Ï„ â†’Ï„) â†’LÏƒ â†’Ï„
whereas the type for inï¬nite lists can be deï¬ned by IÏƒ â‰¡ÂµÏ.(Ïƒ, Ï) with
head â‰¡DIÏƒ,1
: IÏƒ â†’Ïƒ
tail â‰¡DIÏƒ,2
: IÏƒ â†’IÏƒ
PIÏƒ,Ï„
: (Ï„ â†’Ïƒ) â†’(Ï„ â†’Ï„) â†’Ï„ â†’IÏƒ
head(PIÏƒ,Ï„abc)
â‹†â–·ac
tail(PIÏƒ,Ï„abc)
â‹†â–·PIÏƒ,Ï„ab(bc)
[]
After ï¬nishing this section, the author is communicate with [Mendler 86] where recur-
sive types are introduced into ï¬rst-order and second-order typed lambda calculi. He
uses least ï¬xed points and greatest ï¬xed points as we do, but their recursion combinator
R has a diï¬€erent type from ours.
M: (Ï â†’Ï„) â†’Ïƒ â†’Ï„
RÏƒ,Ï„(M[ÂµÏ.Ïƒ/Ï]): ÂµÏ.Ïƒ â†’Ï„
The author cannot give a clear connection between our iterator and his. In addition,
he takes ï¬xed points over a single type expression and, therefore, he needs some basic
type constructors like 1 and +, whereas in our lambda calculus there are no basic type
constructors.
5.3
ML and Categorical Programming
Language
We might say that ML is based on (ï¬rst order) typed lambda calculi as we might say
that LISP is based on untyped lambda calculi. The type structure of ML depends on the
version of ML we are talking about. If we are talking about the original ML developed
with LCF [Gordon, Milner and Wordsworth 79], it had some base types, product,
disjoint sum, integer, etc. , and had ability to introduce new types via recursively
deï¬ned type equations. For example, the data type for binary trees whose leaves are
integers were deï¬ned as
absrectype btree = int + (btree # btree)
with leaf n = absbtree(inl n)
and node(t1,t2) = absbtree(inr(t1,t2))
and isleaf t = isl(repbtree t)
and leafvalue t = outl(repbtree t)
and left t = fst(outr(repbtree t))
and right t = snd(outr(repbtree t));;

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
125
Here, we needed the coproduct type constructor â€˜+â€™ as a primitive. We could not do
without it, whereas â€˜intâ€™ can be deï¬ned in terms of others primitives (ML has it as a
primitive type just because of eï¬ƒciency).
At the next evolution of ML which yielded the current Standard ML [Milner 84, Harper,
MacQueen and Milner 86], we discovered that the coproduct type constructor is no
longer needed as a primitive. Standard ML has a â€˜datatypeâ€™ declaration mechanism by
which the coproduct type constructor can be deï¬ned.
datatype â€™a + â€™b = inl of â€™a | inr of â€™b;
A datatype declaration lists the constructors of the deï¬ning type. An element of â€˜â€™a
+ â€™bâ€™ can be obtained by either applying â€˜inlâ€™ to an element of â€˜â€™aâ€™ or applying â€˜inrâ€™
to an element of â€˜â€™bâ€™. We can deï¬ne the data type for binary trees in Standard ML as
follows.
datatype btree = leaf of int | node of btree * btree;
The symbol â€˜|â€™ is just like â€˜+â€™, but we shifted from the object level of the language
to the syntax level. Note that we no longer need the separate deï¬nition of â€˜leafâ€™ or
â€˜nodeâ€™. We can deï¬ne the other functions using case statements.
exception btree;
fun isleaf t = case t of
leaf _ => true
| node _ => false;
fun leafvalue t = case t of
leaf n => n
| node _ => raise btree;
fun left t = case t of
leaf _ => raise btree
| node(t1,t2) => t1;
fun right t = case t of
leaf _ => raise btree
| node(t1,t2) => t2;
We got rid of the coproduct type constructor from the primitives, but Standard ML
still needs the product type constructor. From a category theoretic point of view, we
can sense asymmetry in the type structure of Standard ML. Let us remember that
CPL (or the lambda calculus deï¬ned in section 5.2) needs neither the coproduct type
constructor nor the product type constructor as a primitive. We should be able to
introduce the symmetry of CPL into ML. Let us proceed to the next stage of the ML

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
126
evolution and deï¬ne Symmetric ML.
Primitives
Declaration Mechanism
ML
->, unit, #, +
abstype
Standard ML
->, unit, *
datatype
Symmetric ML
->
datatype, codatatype
CPL
left object, right object
ML Evolution
Remember that datatype declarations correspond to left object declarations. We list
constructors for types. In order to get rid of the product type constructor from prim-
itives, we should have a declaration mechanism which corresponds to the right object
declaration mechanism. Its syntax is
codatatype TypeParam TypeId =
Id is TypeExp & ... & Id is TypeExp;
A codatatype declaration introduces a type by listing its destructors. The product
type constructor can be deï¬ned as follows.
codatatype â€™a * â€™b = fst is â€™a & snd is â€™b;
where â€˜fst : â€™a * â€™b -> â€™aâ€™ gives the projection function to the ï¬rst component and
â€˜snd : â€™a * â€™b -> â€™bâ€™ gives the projection function to the second component. If the
declaration is recursive, we do not take the initial ï¬xed point of the type equation but
the ï¬nal ï¬xed point. This is ï¬rstly because of symmetry and secondly because the
initial ï¬xed points are often trivial. Because of this, we can deï¬ne inï¬nite objects by
codatatype declarations. For example, the following declaration gives us the data type
for inï¬nite lists.
codatatype â€™a inflist = head is â€™a & tail is â€™a inflist;
If we took the initial ï¬xed point, we would get the empty data type.
Obviously we have destructors for co-data types because we declare them, but how can
we construct data for co-data types? We had case statements for data types, so we
have â€˜mergeâ€™ statements as dual. Its syntax is
merge Destructor <= Exp & ... & Destructor <= Exp
For example, the function â€˜pairâ€™ which makes a pair of given two elements can be
deï¬ned as follows.
fun pair(x,y) = merge fst <= x & snd <= y;
As a more complicated example, we might deï¬ne a function which combines two inï¬nite
lists together.
fun comb(l1,l2) = merge head <= head l1
& tail <= comb(l2,tail l1);

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
127
It is now clear that, if elements of co-data types are just records and â€˜mergeâ€™ creates
records after evaluating expressions, this â€˜combâ€™ function never terminates because it
tries to sweep the entire inï¬nite lists which cannot be done in ï¬nite time. We need
lazyness in the evaluation mechanism. An element of â€˜inflistâ€™ is a record of two com-
ponents but each component is a closure whose computation leads to a value. A â€˜mergeâ€™
statement creates a record consisting of these records. Therefore, the declaration of
â€˜inflistâ€™ is not like
datatype â€™a inflist = something of â€™a * â€™a inflist;
but is closer to
datatype â€™a inflist = something of (unit -> â€™a) *
(unit -> â€™a inflist);
and â€˜headâ€™, â€˜tail and â€˜combâ€™ are like
fun head(something(x,l)) = x();
fun tail(something(x,l)) = l();
fun comb(l1,l2) = something(fn () => head l1,
fn () => comb(l2,tail l1));
Note that, as we use pattern matching to declare functions over data types, we can also
use it to declare functions over co-data types. For example, an alternative deï¬nition
of â€˜combâ€™ may be
fun head comb(l1,_) = head l1
& tail comb(l1,l2) = comb(l2,tail l1);

Conclusions
We have looked at a categorical approach to the theory of data types.
The goal
of this thesis was to develop CPL (Categorical Programming Language) which is a
programming language in a categorical style and which has a categorical way of deï¬ning
data types.
CSL (Categorical Speciï¬cation Language) was actually developed later than CDT (Cat-
egorical Data Types) and CPL. At ï¬rst, CDT was given its semantics without depend-
ing on CSL. We could have carried out the thesis without CSL, but CSL provides the
syntactic materials for CDT and CPL so we would have still needed those parts. CSL
is very much like an ordinary algebraic speciï¬cation language, but it is not trivial in
two senses: the treatment of functors and the treatment of natural transformations.
Functors are very similar to functions but variances make them special and interesting.
Natural transformations are essentially polymorphic functions, so if there had been a
speciï¬cation language for polymorphic functions, we might not have needed to struggle
for developing CSL. It might be interesting to investigate what polymorphic algebraic
speciï¬cation languages can be.
CSL is equational. Much of category theory can be presented equationally so that
CSL is good enough in this sense, but presenting categorical concepts equationally
loses half of the essential meaning. For example, although the adjoint situation can be
explained equationally, its essence is something more. This is why, the author believes,
there are so many equivalent forms of deï¬ning the adjoint situation. Therefore, it is
nice to have a speciï¬cation language which can naturally express categorical concepts.
Sketches [Barr and Wells 85] are more categorical than equations, so it might be an
idea to use sketches in CSL.
CDT is the heart of the thesis. It was developed after the author ï¬rst studied category
theory and tried to express categorical deï¬nitions in algebraic speciï¬cation languages.
As we have seen in chapter 3, algebraic speciï¬cation languages can express categor-
ical deï¬nitions but not naturally.
CDT succeeded to deï¬ne some basic categorical
deï¬nitions like products, coproducts, exponentials, natural numbers and so on more
naturally, but it cannot deï¬ne, for example, pullbacks or more complicated categorical
concepts. One of the suggestions to extend CDT is to allow equations inside the CDT
128

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
129
declarations. In this way, we may deï¬ne pullbacks as follows:
right object pullback(f: A â†’C, g: B â†’C) with pbpair is
Ï€1: pullback â†’A
Ï€2: pullback â†’B
where
f â—¦Ï€1 = g â—¦Ï€2
end object
The declaration should be read as follows:
1. For any morphisms f: A â†’C and g: B â†’C, pullback(f, g) is an object and it is
associated with two morphisms
Ï€1: pullback(f, g) â†’A
and
Ï€2: pullback(f, g) â†’B
such that f â—¦Ï€1 = g â—¦Ï€2.
2. For any morphisms h: D â†’A and k: D â†’B such that f â—¦h = g â—¦k, there exists
a unique morphism pbpair(h, k): D â†’pullback(f, g) such that
Ï€1 â—¦pbpair(h, k) = h
and
Ï€2 â—¦pbpair(h, k) = k
Note that â€˜pullbackâ€™ is no longer a simple functor but takes two morphisms. We can
similarly deï¬ne pushouts, equalizers, co-equalizers and so on. In fact, we can deï¬ne
any ï¬nite limit or colimit. Since limits and colimits are something to do with diagrams,
it seems natural to introduce the declaration mechanism of diagrams. For example, we
may have a diagram consisting of three objects and two morphisms as follows:
diagram el is
objects A, B, C
morphisms f: A â†’C, g: B â†’C
end diagram
Then, â€˜pullbackâ€™ can be regarded as taking an â€˜elâ€™ diagram as its parameter, and it is
a functor from the category of â€˜elâ€™ diagrams. This extension is becoming very much
similar to the parametrization mechanism in algebraic speciï¬cation languages. Dia-
grams correspond to so-called loose speciï¬cations, and object declarations correspond
to parametrized speciï¬cations (or procedures in CLEARâ€™s terminology) which take a
speciï¬cation which matches as a parameter and return a new speciï¬cation. It is very
interesting to investigate the possibility of CDT with equations along this line as a
ï¬rst class speciï¬cation language. CDT we presented in this thesis was bounded by the
restriction of computability. If we introduce equations, it becomes increasingly diï¬ƒcult
to connect them to computing. If we had â€˜pullbackâ€™ in CDT, we would have to prove
f â—¦k = gâ—¦h before using pbpair(k, h). Therefore, the programming would involve some
proving.
CDT and CSL are essentially one sorted systems (here sort = category), and some
would like to extend them to many sorted systems. We could have extended them
here, but since our main goal in this thesis was to understand data types, we were

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
130
interested in only one category, the category of data types, and so CDT and CSL were
single sorted. Our approach is very close to that of domain theory which mainly deals
only one category, the category of domains. On the other hand, algebraic speciï¬cation
methods deal with many categories. Each speciï¬cation is associated with a category.
However, they are still related in some sense because they all are algebras over the
category of sets (or some other underlying category). As we mentioned above, if we
extend CDT with the diagram declarations, we will have to deal with a lot of diï¬€erent
categories of diagrams, and it will be interesting to ï¬nd out what F, G-dialgebras can
give us in this context.
CPL is a functional programming language without variables. It may look like FP
proposed by John Backus because FP also has no variables. However, CPL is based
on category theory and it has an ability to declare data types by means of CDT. CPL
does not need any primitives to start with. One of the reasons for not having variables
is that category theory is abstract in the sense that objects are simply points and only
their outer behaviour is concerned. However, we could have variables for morphisms.
For example, we might want to have
twice(f) def
= f â—¦f
which takes a morphism f: A â†’A and returns a morphism of A â†’A. The current
CPL system cannot handle it and we have to write it like
twice def
= eval â—¦pair(Ï€1, eval)
which is a morphism from exp(A, A) to exp(A, A). This deï¬nition is not self-explanatory.
It is evident that we need morphism variables in CPL for easier use. Note that twice(f)
can simply be a macro because deï¬nitions can never be recursive.
We proposed in chapter 5 to make CPL more like an ordinary functional programming
language. It has datatype declarations as well as co-datatype declarations. It is left for
the future to actually implement the language. It is interesting to see how to handle
(or represent) lazy data types.
Since CPL is an applicative language and has the possibility of executing programs in
parallel as well as the possibility of partial evaluation, some kind of special hardware
can be invented to execute CPL programs fast.
The future plan of CDT and CPL would be to extend CDT to cope with equations
and to develop a total programming environment in which users can deï¬ne things
categorically, reason (or prove) their properties categorically, execute some programs
categorically.

Bibliography
[Arbib and Manes 75] Arbib, M. A. and Manes, E. G. (1975): Arrows, Structures, and
Functors â€” The Categorical Imperative â€”. Academic Press.
[Arbib and Manes 80] Arbib, M. A. and Manes, E. G. (1980): The Greatest Fixed
Points Approach to Data Types. In proceedings of Third Workshop Meeting on Cat-
egorical and Algebraic Methods in Computer Science and System Theory, Dortmund,
West Germany.
[Barr and Wells 85] Barr, M. and Wells, C. (1985): A Series of Comprehensive Studies
in Mathematics Volume 278: Toposes, Triples and Theories. Springer-Verlag.
[Burstall and Goguen 77] Burstall, R. M. and Goguen, J. A. (1977): Putting Theories
Together to Make Speciï¬cation. In Proceedings of 5th International Joint Conference
on Artiï¬cial Intelligence. pp. 1045â€“1058.
[Burstall and Goguen 80] Burstall, R. M. and Goguen, J. A. (1980): The Semantics of
Clear: A Speciï¬cation Language. Internal Report CSR-65-80, Department of Com-
puter Science, University of Edinburgh.
[Burstall and Goguen 81] Burstall, R. M. and Goguen, J.A. (1981): An Informal In-
troduction to Speciï¬cations using Clear. In The Correctness Problem in Computer
Sciences, Academic Press, pp. 185â€“213.
[Burstall and Goguen 82] Burstall, R. M. and Goguen, J.A. (1982): Algebras, Theories
and Freeness: an Introduction for Computer Scientists. Internal Report CSR-65-80,
Department of Computer Science, University of Edinburgh.
[Burstall and Lampson 84] Burstall, R. M. and Lampson, B. (1984): A Kernel Lan-
guage for Abstract Data Types and Modules. In Lecture Notes in Computer Science,
Volume 173, pp. 1â€“50.
[Curien 86] Curien, P-L. (1986): Categorical Combinators, Sequential Algorithms and
Functional Programming. Research Notes in Theoretical Computer Science, Pitman.
[Dybjer 83] Dybjer, P. (1983): Category-Theoretic logics and Algebras of Programs.
Ph. D. thesis, Department of Computer Sciences, Chalmers University of Technology.
University of Gothenburg.
[Goguen and Burstall 83] Goguen, J. A. and Burstall, R. M. (1983): Introducing In-
stitutions. In proceedings of Logic of Programming Workshop.
[Goguen and Tardo 79] Goguen, J. A. and Tardo, J. (1979): An Introduction to OBJ:
A Language for Writing and Testing Software Speciï¬cations. In Speciï¬cation of Re-
liable Software, IEEE, pp. 170â€“189.
[Goguen, Thatcher and Wagner 78] Goguen, J. A., Thatcher, J. W. and Wagner, E.
G. (1978): An Initial Algebra Approach to the Speciï¬cation, Correctness and Imple-
mentation of Abstract Data Types. In Current Trends in Programming Methodology,
prentice-Hall, pp. 80â€“149.
131

BIBLIOGRAPHY
132
[Gordon, Milner and Wordsworth 79] Gordon, M. J., Milner, A. J. and Wordsworth,
C. P. (1979): Edinburgh LCF. Lecture Notes in Computer Science, Volume 78.
[Goldblatt 79] Goldblatt, R. (1979): Topoi: The Categorical Analysis of Logic. Studies
in Logic and Foundation of Mathematics, Volume 98, North-Holand.
[Harper, MacQueen and Milner 86] Harper, R., MacQueen, D. and Milner, R. (1986):
Standard ML. LFCS Report Series, ECS-LFSC-86-2. Department of Computer Sci-
ence, University of Edinburgh.
[Kelly 72] Kelly, G. M. (1972): Many-Variable Functorial Calculus I. In Lecture Notes
in Mathematics, Volume 281, Springer-Verlag, pp. 66â€“105.
[Lambek and Scott 86] Lambek, J. and Scott, P. J. (1986): Introduction to Higher-
Order Categorical Logic. Cambridge Studies in Advanced Mathematics, Volume 7.
[Lawvere 63] Lawvere, F. W. (1963): Functorial Semantics of Algebraic Theories. In
Proceedings of the National Academy of Science, Volume 50, pp. 869â€“872.
[Lehmann and Smyth 81] Lehmann, D. and Smyth, M. (1981): Algebraic Speciï¬cation
of Data Types â€“ A Synthetic Approach â€“. Mathematical System Theory, Volume 14,
pp. 97â€“139.
[Mac Lane 71] Mac Lane, S. (1971): Categories for the Working Mathematician. Grad-
uate Texts in Mathematics 5, Springer-Verlag.
[Manes 76] Manes, E. G. (1976): Algebraic Theories. Graduate Texts in Mathematics
26, Springer-Verlag.
[Martin-LÂ¨of 79] Martin-LÂ¨of, P. (1979): Constructive Mathematics and Computer Pro-
gramming. Paper presented in 6th International Congress for Logic, Methodology
and Philosophy of Science.
[Mendler 86] Mendler N. P. (1986): First- and Second-Order Lambda Calculi with Re-
cursive Types. Technical Report TR 86-764, Department of Computer Science, Cor-
nell University.
[Milner 84] Milner, R. (1984): The Standard ML Core Language. Internal Report CSR-
168-84, Department of Computer Science, University of Edinburgh.
[Parasaya-Ghomi 82] Parasaya-Ghomi, K. (1982): Higher Order Abstract Data Types.
Ph. D. Thesis, Department of Computer Science, UCLA.
[Plotkin 81] Plotkin, G. D. (1981): A Structural Approach to Operational Semantics.
Technical Report DAIMI FNâ€“19, Computer Science Department, ËšArhus University.
[Rydeheard 81] Rydeheard, D. E. (1981): Application of Category Theory to Program-
ming and Program Speciï¬cation. Ph. D. thesis, University of Edinburgh.
[Rydeheard and Burstall 86] Rydeheard, D. E. and Burstall, R. M. (1986): Computa-
tional Category Theory.
[Scott 76] Scott, D. (1976): Data Types as Lattices. SIAM Journal of Computing,
Volume 5, pp. 552â€“587.
[Smyth and Plotkin 82] Smyth, M. B. and Plotkin, G. D. (1982):
The Category-
Theoretic Solution of Recursive Domain Equations. SIAM Journal of Computing,
Volume 11.
[Stenlund 72] Stenlund, S. (1972): Combinators, Î»-Terms and Proof Theory. D. Reidel,
Dordrecht.
[Stoy 77] Stoy, J. E. (1977): The Scott-Strachey Approach to Programming Language
Theory. MIT Press.
[Tait 67] Tait, W. (1967): Intentional Interpretation of Functionals of Finite Type I.
Journal of Symbolic Logic, 32, pp. 198â€“212.

BIBLIOGRAPHY
133
[Troelstra 73] Troelstra, A. S. (1973):
Mathematical Investigation of Intuitionistic
Arithmetic and Analysis. Lecture Notes in Mathematics, Volume 344, Springer-
Verlag.

Declaration
This thesis has been written by myself, and the work is my own.
Edinburgh, 1 June 1987
Tatsuya Hagino

