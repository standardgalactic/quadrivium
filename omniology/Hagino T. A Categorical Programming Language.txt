A Categorical Programming Language
Tatsuya Hagino
Doctor of Philosophy
University of Edinburgh
1987

Author’s address:
Tatsuya Hagino
Data Processing Center
Kyoto University
Kyoto 606
Japan

Abstract
A theory of data types and a programming language based on category theory are
presented.
Data types play a crucial role in programming. They enable us to write programs easily
and elegantly. Various programming languages have been developed, each of which may
use diﬀerent kinds of data types. Therefore, it becomes important to organize data
types systematically so that we can understand the relationship between one data type
and another and investigate future directions which lead us to discover exciting new
data types.
There have been several approaches to systematically organize data types: algebraic
speciﬁcation methods using algebras, domain theory using complete partially ordered
sets and type theory using the connection between logics and data types. Here, we use
category theory. Category theory has proved to be remarkably good at revealing the
nature of mathematical objects, and we use it to understand the true nature of data
types in programming.
We organize data types under a new categorical notion of F, G-dialgebras which is
an extension of the notion of adjunctions as well as that of T-algebras. T-algebras
are also used in domain theory, but while domain theory needs some primitive data
types, like products, to start with, we do not need any. Products, coproducts and
exponentiations (i.e. function spaces) are deﬁned exactly like in category theory using
adjunctions. F, G-dialgebras also enable us to deﬁne the natural number object, the
object for ﬁnite lists and other familiar data types in programming. Furthermore, their
symmetry allows us to have the dual of the natural number object and the object for
inﬁnite lists (or lazy lists).
We also introduce a functional programming language in a categorical style. It has
no primitive data types nor primitive control structures.
Data types are declared
using F, G-dialgebras and each data type is associated with its own control structure.
For example, natural numbers are associated with primitive recursion. We deﬁne the
meaning of the language operationally by giving a set of reduction rules.
We also
prove that any computation in this programming language terminates using Tait’s
computability method.
A speciﬁcation language to describe categories is also included.
It is used to give
a formal semantics to F, G-dialgebras as well as to give a basis to the categorical
programming language we introduce.
ii

Acknowledgements
The greatest thanks go to Professor Rod Burstall who, ﬁrst of all, accepted me as a
Ph. D. student, then, supervised me during my Ph. D. study and, further, gave me
an opportunity to continue working in Edinburgh. He gave me not only useful advices
but also much-needed mental support. I would also thank to his wife, Sissi Burstall,
who invited me to their house often and made my stay in Edinburgh very pleasant.
I am also grateful to Professor Reiji Nakajima for having encouraged me to come
to Edinburgh and to Professor Heisuke Hironaka for having helped me to solve the
ﬁnancial problem for studying in Edinburgh.
Many lectures I attended in the ﬁrst year enlightened me a lot: domain theory, op-
erational semantics, denotational semantics, algebraic speciﬁcation, category theory,
and so on. I did not know what category theory really is before I came to Edinburgh.
Thanks to Andrzej Tarlecki, Edmund Robinson and John Cartmell for having helped
me to overcome the initial diﬃculty of category theory. John Cartmell also helped me
a lot through discussions in the early stage of the thesis. I am also in debt to Furio
Honsell who introduced me to Tait’s method for proving normalization theorems of
lambda calculi when I stuck in the normalization proof of CPL. Many other people in
Edinburgh helped me with their comments and through discussions. I would especially
like to thank Bob McKay and Paul Taylor for reading the early drafts and discovering
some disastrous mistakes.
This thesis is written using LaTEX on a Sun workstation and printed by an Apple
LaserWriter. I would like to thank George Cleland and Hugh Stabler for providing
wonderful computing facilities and software to Laboratory of Foundation of Computer
Science.
My Ph. D. study at the University of Edinburgh has been funded by the Educational
Project for Japanese Mathematical Scientists, Harvard University, by the Overseas Re-
search Students Award and by the Science and Engineering Research Council Research
Fellowship.
iii

Contents
1
Introduction
1
1.1
Backgrounds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.1.1
Algebraic Speciﬁcation Methods . . . . . . . . . . . . . . . . . .
2
1.1.2
Domain Theory . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.2
Basic Category Theory . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.3
Development of Categorical Data Types
. . . . . . . . . . . . . . . . .
7
1.4
In This Thesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
1.5
Comparison with Other Works . . . . . . . . . . . . . . . . . . . . . . .
15
2
Categorical Speciﬁcation Language
17
2.1
A Functorial Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
2.2
Signatures of Categorical Speciﬁcation Language . . . . . . . . . . . . .
26
2.3
Structures of Categorical Speciﬁcation Language . . . . . . . . . . . . .
31
2.4
Functorial Calculus (revisit) . . . . . . . . . . . . . . . . . . . . . . . .
32
2.5
Sentences and Satisfaction Relation of Categorical Speciﬁcation Language 38
2.6
Free Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
3
Categorical Data Types
44
3.1
What are Categorical Data Types? . . . . . . . . . . . . . . . . . . . .
44
3.2
Data Type Declarations in Categorical Data Types
. . . . . . . . . . .
53
3.3
Examples of Categorical Data Types
. . . . . . . . . . . . . . . . . . .
56
3.3.1
Terminal and Initial Objects . . . . . . . . . . . . . . . . . . . .
56
iv

3.3.2
Products and CoProducts . . . . . . . . . . . . . . . . . . . . .
57
3.3.3
Exponentials
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
3.3.4
Natural Number Object
. . . . . . . . . . . . . . . . . . . . . .
60
3.3.5
Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
62
3.3.6
Final Co-Algebras (Inﬁnite Lists and Co-Natural Number Object) 63
3.3.7
Automata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
3.3.8
Obscure Categorical Data Types
. . . . . . . . . . . . . . . . .
69
3.4
Semantics of Categorical Data Types . . . . . . . . . . . . . . . . . . .
70
3.5
Existence of Left and Right . . . . . . . . . . . . . . . . . . . . . . . .
74
4
Computation and Categorical Data Types
78
4.1
Reduction Rules for Categorical Programming Language . . . . . . . .
79
4.2
An Example of using Reduction Rules
. . . . . . . . . . . . . . . . . .
92
4.3
Well-Deﬁnedness and Normalization Theorem for Reduction Rules . . .
96
4.4
Properties of Computable Objects . . . . . . . . . . . . . . . . . . . . .
108
4.5
Reduction Rules for Full Evaluation . . . . . . . . . . . . . . . . . . . .
112
5
Application of Categorical Data Types
115
5.1
An implementation of Categorical Programming Language . . . . . . . 115
5.2
Typed Lambda Calculus . . . . . . . . . . . . . . . . . . . . . . . . . .
120
5.3
ML and Categorical Programming Language . . . . . . . . . . . . . . .
124
Conclusions
128
Bibliography
131
v

Chapter 1
Introduction
This is an exploration of data types through category theory. It is an attempt to achieve
better understanding of data types, their uniform classiﬁcation, and discovery of a new
world of data types. Data types have been with us since the very ﬁrst programming
languages. Even some machine languages now have some concept of data types, but
early programming languages had only a ﬁxed number of data types, like integers, reals
and strings, and/or a ﬁxed number of data type constructors, like array constructors
and record constructors. When we gradually realized how important data types were,
programming languages started having richer and richer data types.
A number of
programming languages now allow us to deﬁne our own data types. Some might even
say that the richer they are, the better the programming languages are. Programming
languages can be classiﬁed by the way how they handle data types.
There is no question about the importance of data types. Much research in this area
has produced various kinds of data types, so varied that one cannot capture them all.
We now need to systematically organize data types. We want to know the connection
between one data type and another. We want to know the reason why those data types
are with us and while some other data types are not. After getting a clear view of data
types, we might ﬁnd the future direction to discover other important data types.
There have been already some attempts to organize data types. We can name some of
the important ones: Domain theory is one, algebraic speciﬁcation is another and type
theory is one where a lot of research is going on at the moment. In this thesis, we
will present yet another attempt to organize data types. We do so by using category
theory. We call our data types Categorical Data Types (or CDT for short).
One might ask “Why category theory?” Category theory is known as highly abstract
mathematics. Some call it abstract nonsense. It chases abstract arrows and diagrams,
proves nothing but about those arrows and diagrams, rarely talks about what arrows
are for and often concepts go beyond one’s imagination. However, when this ‘abstract
nonsense’ works, it is like magic. One may discover a simple theorem actually means
very deep things and some concepts beautifully unify and connect things which are
unrelated before.
1

CHAPTER 1. INTRODUCTION
2
In ordinary mathematics, whether we are aware or not, we are in the world of set
theory. Mathematics has been so well developed with set theory that we can hardly
do anything without it. Therefore, it is very natural that semantics of programming
languages is generally based on set theory. Note that it is often said that most of
programming languages do not have set theoretic semantics and, therefore, domain
theory has been developed, but this does not contradict with “semantics based on set
theory”, because domain theory itself is based on set theory. A domain is a set with
certain properties.
Set theory is a powerful tool, but sometimes this power disﬁgures beautiful objects
so that we cannot directly see their natural properties. For example, in set theory it
is not easy to see either the duality between injective and surjective functions or the
duality between cartesian products and disjoint sums. It is in category theory that
these dualities come out clearly. Category theory concentrates on the outer behaviour
of objects. It does not care what is in an object, whereas set theory is all about what is
in an object. It is interesting to know that seeing from the outside reveals the nature of
an object more naturally than seeing its inside. For example, one of the most important
concepts discovered by category theory is adjunction (or adjoint situation), which is
strikingly simple but very beautiful and uniﬁes various concepts under the same name.
Our slogan is: “category theory can provide a better and more natural understanding of
mathematical objects than set theory”, so we use it to guide our tour around the world
of data types. Note that we do not mean to abandon set theory by this. We will still
heavily rely on it, but our intuition should not be obstructed by it.
1.1
Backgrounds
1.1.1
Algebraic Speciﬁcation Methods
Algebraic speciﬁcation methods were ﬁrst developed to describe what programs do.
They are not like operational semantics or denotational semantics. These semantics
also describe what programs do but in a diﬀerent way. They describe it by giving
meaning to each part of programs. They need to know how programs are written, that
is, they need actual codes. Whereas, algebraic speciﬁcation methods never talk about
how programs are implemented. They describe their behaviour abstractly viewing from
outside.
This abstract view point, seeing from outside, led to the discovery of abstract data
types (see e.g. [Goguen, Thatcher and Wagner 78]).
It is interesting to know that
algebraic speciﬁcation methods were started to describe programs but it also developed
a theory of data types. Since algebraic speciﬁcation methods try to describe things
from an outside point of view, they cannot talk about the concrete nature of data types
which programs handle. Therefore, the data types also needed to be abstracted and,
thus, abstract data types have been developed. We may divide algebraic speciﬁcation

CHAPTER 1. INTRODUCTION
3
methods into two: speciﬁcation of data types and speciﬁcation of programs.
Speciﬁcation
of Programs
Speciﬁcation of Data Types
Algebraic Speciﬁcation
¡
¡
¡
¡
¡
¡
¡
¡
¡
¡
¡
¡
@
@
@
@
@
@
@
@
@
@
@@
It is the former, speciﬁcation of data types, that concerns us in this thesis.
Algebraic speciﬁcation methods got their method of describing data types from abstract
algebras in mathematics. Mathematicians have been using abstract algebras for about
a century. Abstract algebras are only concerned with concrete real algebras insofar as
they satisfy some laws. For example, a set with a binary operation is a group when the
operation is associative, there is an identity and every element is invertible. A real set
and a real operation can be anything, integers and +, general linear matrixes and their
multiplication, and so on. Any theorem established for general groups can be applied
to any real groups. There are various kinds of abstract algebras: groups, rings, ﬁelds,
and so on. Those abstract algebras can be presented uniformly by universal algebras.
Algebraic speciﬁcation methods use a many-sorted version of universal algebras.
Na¨ıvely speaking, an algebraic speciﬁcation is a triple (S, Σ, E), where S is a set of
sorts, Σ is a S∗× S-indexed set of operations and E is a set of equations over Σ.
For example, in an algebraic speciﬁcation language CLEAR [Burstall and Goguen 80,
Burstall and Goguen 82] a speciﬁcation of lists may be as follows.
constant List =
theory
sorts element, list
opns nil : list
cons : element, list -> list
head : list -> element
tail : list -> list
eqns all e : element, l : list, head(cons(e,l)) = e
all e : element, l : list, tail(cons(e,l)) = l
endth
S is { element, list }, Σlist is { nil }, Σlist element is { head }, and so on. E consists
of the two equations above.
There are several problems about this speciﬁcation as we will see immediately after we
say what a speciﬁcation means. An algebraic speciﬁcation (S, Σ, E) deﬁnes a class of
many sorted algebras each of which, say A, consists of an S-sorted set |A| and functions
fA: |A|s1 × . . . × |A|sn −→|A|s for each f ∈Σs1...sns which satisfy the equations in E.

CHAPTER 1. INTRODUCTION
4
The ﬁrst problem of the above speciﬁcation is that not only lists satisfy it but also
many of other data types as well. There is actually no way to make it describe only
lists so long as we stick to ﬁrst order methods. We need something of second order.
The way algebraic speciﬁcation methods usually obtain this is to put data constraints.
We rely on the categorical fact that the initial algebra is unique up to isomorphism. In
this case, we put a data constraint onto the sort ‘list’, but not to ‘element’ because
if we put a data constraint onto ‘element’ then the ‘element’ sort would be empty.
The second problem is that ‘head’ and ‘tail’ are partial functions. The speciﬁcation
does not say what is ‘head(nil)’ or what is ‘tail(nil)’. In order to ﬁx this problem,
we have to introduce, for example, error algebras or go into partial algebras.
The third problem is that although we put a data constraint on ‘list’ it is not im-
mediately obvious that ‘nil’ and ‘cons’ can construct all the lists. Some algebraic
speciﬁcation languages do distinguish these constructors from the others.
The fourth problem is about the sort ‘element’. We actually need it as a parameter.
When we use this speciﬁcation, ‘element’ denotes a particular data type deﬁned by
another speciﬁcation and we need a way to plug in any speciﬁcation of ‘element’
into this speciﬁcation. Actually, CLEAR has this facility. ‘List’ can be deﬁned as
‘procedure’ taking parametrized type ‘element’. However, this new speciﬁcation no
longer corresponds to a class of algebras but to something one level higher.
Many other problems there might be, but most of them have been solved in one way
or another. The important point we would like to make is that the na¨ıve idea of
algebraic speciﬁcation = universal algebra
does not work well and we have to put a lot of other ideas into algebraic speciﬁcation
methods. One might wonder why so many complications are needed to deﬁne everyday
objects like lists.
In CDT, we stick to the very simple relation
categorical data type = F, G-dialgebra
F, G-dialgebras can be seen as an extension of universal algebras (see section 3.1). We
do not need to introduce meta arguments or any other complicated ideas into CDT in
order to deﬁne lists or other basic data types.
1.1.2
Domain Theory
Domain theory was started with denotational semantics [Stoy 77, Scott 76]. In order
to give denotational semantics to programs, we need several domains to which the
denotations are mapped. Those domains are often interwoven and recursively deﬁned.
The most famous example of this is the following D.
D ∼= D →D

CHAPTER 1. INTRODUCTION
5
This domain D was necessary to give denotational semantics to the untyped lambda
calculus. In general, we would like to solve the following domain equation:
D ∼= F(D)
where F(D) is a domain expression involving D.
Though domains are mathematical objects and not necessarily representable in com-
puters, the idea of recursively deﬁned data types has been adopted into several pro-
gramming languages. For example, we can have a domain L for lists of A elements by
solving1
L ∼= 1 + A × L,
and in the original version of ML [Gordon, Milner and Wordsworth 79], we could deﬁne
the data type for lists just like the same.
abstype ’a list = unit + ’a # ’a list
with ...
On the other hand, some domains cannot be represented in the same way. For example,
we can have a domain I for inﬁnite lists of A elements by solving
I ∼= A × I⊥
where I⊥is the lifting of I by adding the new least element, but we cannot deﬁne
inﬁnite lists in ML in a similar way.
Comparing with algebraic speciﬁcation methods, in domain theory we can deﬁne data
types easily and there is no complication of parametrized data types, but we have some
diﬃculty of deﬁning operations over data types. In algebraic speciﬁcation methods we
deﬁne operations together with data types, but in domain theory we have to deﬁne
them using the isomorphisms of domain equations.
If an algebraic speciﬁcation (S, Σ, E) has no equational constraints (i.e. E = ∅), the
initial algebra can be given by solving the following domain equations.
|A|s ∼=
X
f∈Σs1...sns
|A|s1 × . . . × |A|sn
By this connection, we can see the possibility of combining algebraic speciﬁcation
methods and domain theory together. Actually, data types in the current Standard
ML [Milner 84, Harper, MacQueen and Milner 86] are deﬁned in this mixed fashion
(see also section 5.3).
Categorically, we can go the other way round. If F(D) is a covariant functor, the
initial ﬁxed point of F(D) can be characterized as the initial F-algebra. A F-algebra
is a categorical generalization of an ordinary algebra. The main idea we borrow from
domain theory is this connection between initial ﬁxed points and initial algebras.
1We have to say what kind of domains we are dealing with. Let us say in this thesis that a domain is
a complete partially ordered set with the least element and a function between domains needs to be
continuous and strict.

CHAPTER 1. INTRODUCTION
6
After becoming familiar with category theory, one can notice the dual connection be-
tween ﬁnal ﬁxed points and ﬁnal co-algebras. People rarely talked about them until
recently [Arbib and Manes 80]. One of the reasons is that co-algebras are not so pop-
ular and another reason is that ﬁnal ﬁxed points are often the same as initial ﬁxed
points in domain theory. However, in CDT we will use this dual connection as well.
Final co-algebras give us some very intersting data types like inﬁnite lists. We deﬁned
inﬁnite lists by the initial ﬁxed point of
I ∼= A × I⊥
Actually, what we were doing using the lifting I⊥is to get the ﬁnal ﬁxed point of
I ∼= A × I.
1.2
Basic Category Theory
This section is to roughly introduce some categorical concepts we will use in the rest of
this thesis. The author refers to category theory text books like [Mac Lane 71], [Arbib
and Manes 75] and [Lambek and Scott 86] for a more detailed account of category
theory.
A category C is given by
⋄a collection of objects |C|,
⋄for any pair of objects A and B, a collection HomC(A, B) of morphisms from
domain A to codomain B, (we write f: A →B for f ∈HomC(A, B))
⋄for any objects A, B and C, an operation called composition denoted by ‘◦’ from
HomC(B, C) × HomC(A, B) to HomC(A, C) which is associative,
(f ◦g) ◦h = f ◦(g ◦h)
⋄for any object A, an identity morphism IA: A →A such that for any f: B →A
and any g: A →C
IA ◦f = f
and
g ◦IA = g
Two objects A and B are called isomorphic if there are two morphisms f: A →B and
g: B →A such that
f ◦g = IB
and
g ◦f = IA.
f and g are called isomorphisms.
The opposite category Cop of a category C is deﬁned by reversing the direction of all
the morphisms in C.
HomCop(A, B) = HomC(B, A)
We may write Cop morphism f op: A →B for C morphism f: B →A.
The product category C × D of a category C and a category D is given as

CHAPTER 1. INTRODUCTION
7
⋄a C × D object is ⟨A, B⟩for a C object A and a D object B
⋄a C × D morphism from ⟨A, B⟩to ⟨A′, B′⟩is ⟨f, g⟩for a C morphism f: A →B
and a D morphism g: A →B.
A covariant functor F from a category C to a category D (we write F: C →D) is given
by
⋄associating a D object F(A) for every C object A
⋄associating a D morphism F(f): F(A) →F(B) for every C morphism f: A →B
such that
F(IA) = IF(A)
and
F(f ◦g) = F(f) ◦F(g)
A contravariant functor is deﬁned in a similar way except that F(f): F(B) →F(A).
A natural transformation α from a covariant functor F: C →D to a covariant functor
G: C →D (we write α: F
·→G) is given by
⋄associating a D morphism αA: F(A) →G(A) for every C object A such that for
any C morphism f: A →B the following diagram commutes.
F(A)
αA
G(A)
-
F(f)
¥
¨§?
G(f)
?
?
F(B)
αB
-G(B)
When every αA is an isomorphism, we call α natural isomorphism.
Two functors F: C →D and G: D →C are called adjoints if there exists a natural
isomorphism
ψA,B: HomD(F(A), B)
∼
=
−→HomC(A, G(B)).
F is called the left adjoint functor of G and G is called the right adjoint functor of F.
We also call ψA,B (or its inverse ψ−1
A,B) factorizer or mediating morphism.
1.3
Development of Categorical Data Types
The motivation of CDT was to adopt the categorical way of deﬁning data types into
speciﬁcation languages. Anybody educated using set theory has quite a shock when
he ﬁrst sees the way category theory works. It gives a totally diﬀerent point of view
to things which are familiar. Things which were vaguely connected suddenly are ﬁtted
into systematic places. It seems that the nature of things is ﬁnally revealed.
There are many beautiful concepts discovered through category theory, but here we
concentrate only one of them, namely adjunction (or adjoint situation). In [Mac Lane
71], one will ﬁnd many equivalent forms of the deﬁnition of adjunction (we gave one of
them in section 1.2). One may be ﬁrst at a loss for chosing the deﬁnition. Adjunction

CHAPTER 1. INTRODUCTION
8
is so versatile that it can be seen in a number of diﬀerent forms and it is sometimes
diﬃcult to understand it if one sticks to a particular form of the deﬁnition. The form
is not important if the spirit is understood. Adjunction can be regarded as a property
of two functors or because of the unique correspondence between two functors it can
be seen as deﬁning one of them from the other. It is the latter which is important to us
because it is a typical way of deﬁning things in category theory. Let us see an example.
Using set theory, we can deﬁne what the product of two sets is, what the product of two
groups is, what the product of two topological spaces is, and so on. Each deﬁnition
is obviously deferent from the others but all of them are called by the same name,
product. Why is that so? Is there any common property which all the diﬀerent kinds
of products should satisfy? Can we give the general deﬁnition of product? Category
theory can give an aﬃrmative answer to these questions. The categorical deﬁnition of
products is
For object A and B, the product A × B is an object such that there are
two morphisms
π1: A × B −→A
and
π2: A × B −→B
and for any given two morphisms
f: C −→A
and
g: C −→B
there is a unique morphism h: C −→A×B such that the following diagram
commutes.
A
A × B
B
π1
π2

-
C
f
g
h
¥
¨§?
¥
¨§?
@
@
@
@
@
@
@
@
I
¡
¡
¡
¡
¡
¡
¡
¡

6
It is easily shown that any two objects satisfy this deﬁnition are isomorphic.
We may write ⟨f, g⟩for h.
This deﬁnition is general enough to cover the deﬁnition of products for sets, groups,
topological spaces, and so on. We no longer need to deﬁne products for each individual
case.
The generality should not be bound only in mathematics. Why should it not equally
be appropriate to the deﬁnition of products in programming languages? The product
data type of type A and type B is usually deﬁned as a type of records whose ﬁrst
component is of type A and the second one is of type B, but this deﬁnition is like one
in set theory. It assumes too much about how elements of data types are represented.
It is not acceptable as an abstract description of the product data type. If the product
data type is deﬁned as an abstract data type, how can we present it?

CHAPTER 1. INTRODUCTION
9
We can directly adopt the categorical deﬁnition of products. There are ﬁve ingredients
in the deﬁnition.
1.
two given objects A and B,
2.
the object A × B we are deﬁning,
3.
two morphisms π1: A × B −→A and π2: A × B −→B,
4.
⟨f, g⟩: C −→A × B for f: C −→A and g: C −→B, and
5.
the commutative diagram.
We may write these down as follows
object A × B is
π1: A × B −→A
π2: A × B −→B
⟨f, g⟩: C −→A × B for f: C −→A and g: C −→B
where
π1 ◦⟨f, g⟩= f
π2 ◦⟨f, g⟩= g
π1 ◦h = f ∧π2 ◦h = g ⇒h = ⟨f, g⟩
end object.
(∗)
Can we call this a categorical deﬁnition of the product data type constructor? Although
this is an exact copy of the categorical deﬁnition, it has somehow lost the spirit of
category theory; its beauty; its simplicity. The categorical deﬁnition of products we
gave is in a disguised form of adjunction. The deﬁnition could have been suﬃcient
to just say that the product functor is the right adjoint of the diagonal functor. The
previous deﬁnition expands this into plain words so that there are a lot of duplications.
One of them is that the type of ⟨, ⟩can be deduced from the type of π1 and π2. If f
and g has the same type as π1 and π2 except replacing A×B by C, ⟨f, g⟩is a morphism
from C to A × B. Another duplication is that the commutative diagram can also be
deduced from the rest. There are no other trivial ways to make diagrams involving
π1, π2, f, g and ⟨f, g⟩. Therefore, the deﬁnition of product data types can be written
simply as
object A × B is
π1: A × B −→A
π2: A × B −→B
end object.
This supplies the minimal information to get back to (∗). Now, we have to use the fact
that A × B is deﬁned by adjunction (it was not necessary in (∗)). Let us indicate this
by saying it is a right object as well as declaring ⟨, ⟩.
right object A × B with ⟨, ⟩is
π1: A × B −→A
π2: A × B −→B
end object
This is the declaration of the product data type constructor in CDT (except for minor
changes).

CHAPTER 1. INTRODUCTION
10
Let us examine the generality and simplicity of this declaration mechanism through
examples. Let us try exponentials BA. The functor •A is deﬁned as the right adjoint
functor of • × A. The deﬁnition in CDT is
right object BA with curry( ) is
eval: BA × A −→B
end object
We can derive the usual deﬁnition of exponentials from this deﬁnition. First, the type
of curry( ) should be
f: C × A −→B
curry(f): C −→BA
.
The type of f is obtained from the type of ‘eval’ just replacing BA by C. The commu-
tative diagram which curry(f) gives can be obtained by connecting
BA × A
-
eval
B
and
C × A
-
f
B
by curry(f): C −→BA. The only way to connect them together results
C × A
curry(f) × A
f
BA × A
B
eval
-
6
¡
¡
¡
¡
¡
¡
¡

The morphism denoted by curry(f) is the unique one which makes this diagram com-
mute. Thus, we recovered the ordinary deﬁnition of exponentials.
We said ‘right object’ for products and exponentials. It is natural to think that we also
have ‘left object’ as dual. The dual of products are coproducts. Let us deﬁne them in
CDT.
left object A + B with [ , ] is
ν1: A −→A + B
ν2: B −→A + B
end object
The type of [ , ] can be obtained from the type of ν1 and ν2.
f: A −→C
g: B −→C
[f, g]: A + B −→C
Note that [f, g] goes from A + B to C not the other way round as it would be if it
were a right object. The name ‘left object’ came from the fact that A + B is in the left
hand side of −→. Remember that A × B was in the right hand side of −→for ⟨, ⟩.

CHAPTER 1. INTRODUCTION
11
A natural way of connecting f and g with ν1 and ν2 by [f, g] gives us the ordinary
commutative diagram which [f, g] should satisfy.
A
A + B
B
ν1
ν2
-

C
f
g
[f, g]
¥
¨§?
¥
¨§?
@
@
@
@
@
@
@
@
R
¡
¡
¡
¡
¡
¡
¡
¡
ª
?
We demonstrated that we can express basic categorical constructs in CDT. Those
constructs, or data types, are primitives in ordinary programming languages. Can we
declare more familiar data types? In fact, the ‘left object’ declaration gives all those
which can be deﬁned by algebraic methods with no equations. ‘Without equations’
seems that we cannot deﬁne much, but actually it gives us all the important data types
of ordinary programming languages. For example, natural numbers can be deﬁned as
left object nat with pr( , ) is
zero: 1 −→nat
succ: nat −→nat
end object
This is very much like a speciﬁcation of natural numbers in algebraic speciﬁcation
methods except that we do not have the predecessor function or plus or times and that
we have something called pr( , ). From analogy of the types of [ , ] and ⟨, ⟩, the type
of pr( , ) should be
f: 1 −→C
g: C −→C
pr(f, g): nat −→C
.
We also obtain the diagram characterizing ‘nat’ as we did for products and others.
1
zero
nat
succ
nat
f
¥
¨§?
pr(f, g)
¥
¨§?
pr(f, g)
C
C
g
-
-
@
@
@
@
@
@
@
@
R
-
?
?
This is exactly the deﬁnition of ‘nat’ being a natural number object in category theory
and it is well-known that we can deﬁne all the primitive recursive functions using
pr( , ). For example, the addition function can be deﬁned by
add def
= eval ◦⟨pr(curry(π2), curry(succ ◦eval)) ◦π1, π2⟩.

CHAPTER 1. INTRODUCTION
12
As another example, we give the deﬁnition of lists in CDT. It is
left object list(A) with prl( , ) is
nil: 1 −→list(A)
cons: A × list(A) −→list(A)
end object
The type of prl( , ) is
f: 1 −→C
g: A × C −→C
prl(f, g): list(A) −→C
.
The diagram is
1
list(A)
A × list(A)
B
A × B
nil
cons
f
¥
¨§?
prl(f, g)
¥
¨§?
IA × prl(f, g)
g
-
@
@
@
@
@
@
@
@
R


?
?
Remember that our deﬁnition of lists in CLEAR had ‘head’ and ‘tail’, but we do not
declare them here. We can deﬁne them by prl( , ).
head def
= prl(ν2, ν1 ◦π1)
: list(A) −→A + 1
tail def
= [ν1 ◦π2, ν2] ◦prl(ν2, ν1 ◦⟨π1, [cons, nil]⟩)
: list(A) −→list(A) + 1
‘Without equations’ is not a disadvantage to deﬁne everyday data types.
By the connection between initial ﬁxed points and F-algebras, we can deﬁne the initial
ﬁxed point D of a covariant functor F(X) as follows.
left object D with ψ( ) is
α: F(D) −→D
end object
α gives one direction of the isomorphism between D and F(D), and ψ( ) gives unique
arrows.
F(D)
α
D
-
F(ψ(f))
¥
¨§?
ψ(f)
?
?
F(A)
f
-
A
We have been using ‘left object’ more than ‘right object’, but they are dual and there
are equally as many right objects as left objects. Just they are not familiar in ordinary

CHAPTER 1. INTRODUCTION
13
programming languages. For example, the following deﬁnition gives the data type for
inﬁnite lists.
right object inﬂist(A) with fold( , ) is
hd: inﬂist(A) −→A
tl: inﬂist(A) −→inﬂist(A)
end object
This gives the ﬁnal ﬁxed point of I ∼= A × I.
We have devised, based on category theory, a simple way of deﬁning data types. The
next question is whether we can adopt this method into ordinary programming lan-
guages. The answer is negative. Although what we can deﬁne in this way is far less
than what we can deﬁne using algebraic speciﬁcation languages with equations, we still
have some strange things that can be deﬁned in this way. Let us see an example. We
deﬁned list(A) as a parametrized data type but in fact it is a functor.
list(f): list(A) −→list(B)
for a morphism f: A −→B is often called map function. In LISP it is ‘MAPCAR’
and in ML it is ‘map’. The general declaration mechanism of CDT allows us to deﬁne
the left and right adjoint functors of list(A) which could not exist in the world of
programming. We need to put a restriction to prevent these objects. The restriction
will come out of a notion of computability in our setting. Interestingly, it turns out
the category should be
cartesian closed + initial ﬁxed points + ﬁnal ﬁxed points
We might see the similarity between this and the connection of lambda calculus and
cartesian closed categories.
By putting this computability restriction, we can regard CDT as not only a device of
deﬁning data types but also a programming language. We program in a categorical
fashion; there are no concrete data but morphisms; programs are also morphisms;
there are no variables in programs. The computation in this language is reduction
from morphisms to canonical ones. For example, we can reduce
add ◦⟨succ ◦zero, succ ◦zero⟩⇒succ ◦succ ◦zero
which corresponds to the calculation of 1 + 1 = 2.
We summerize the characteristics of CDT as follows.
1. CDT uses categorical characterization of data types.
We do not need to say
things explicitly. All the equations are automatically generated for deﬁnitions.
2. CDT needs no primitive data types. Ordinary programming languages (e.g. PAS-
CAL, LISP, ML) have primitive data types: natural numbers, lists, records, and
so on, but CDT does not. They can be deﬁned. Thus, CDT is analogous to
algebraic speciﬁcation methods where we can specify them as well. However,
algebraic speciﬁcation methods cannot specify higher order data types (i.e. func-
tion spaces or exponentials in a categorical term) nor can they specify products
without using equations.

CHAPTER 1. INTRODUCTION
14
3. CDT can not only deﬁne products without explicitly mentioning equations but
also can deﬁne exponentials.
4. CDT is symmetric in the sense that we can deﬁne initial algebras (or initial ﬁxed
points) as well as ﬁnal co-algebras (or ﬁnal ﬁxed points).
5. Algebraic speciﬁcation methods use initiality implicitly and do not use the unique
homomorphisms between the initial algebras and the others, whereas CDT has
explicit access to the unique morphisms. This gives the power of programming
without going though equational characterization as it is necessary in algebraic
speciﬁcation methods.
6. Domain theory does not use the initiality explicitly either. The reason for this
is that recursion in ordinary programming languages provide all the power of
programming.
7. CDT deﬁnes functors.
Functors are thought to be parametrized data types.
Algebraic speciﬁcation methods usually introduce parametrization later, but in
CDT functorial behaviour of parametrized data types is treated at the base level.
1.4
In This Thesis
The theory of categorical data types is divided into three: Categorical Speciﬁcation
Language, Categorical Data Types and Categorical Programming Language.
Categorical
Programming Language
Categorical Data Types
Categorical Speciﬁcation Language
Chapter 2 is about Categorical Speciﬁcation Language (CSL for short).
CSL is a
speciﬁcation language. It is an extension of ordinary algebraic speciﬁcation languages.
Whereas algebraic speciﬁcations specify algebras, it speciﬁes categories. In order to
specify categories, CSL has to handle functors, natural transformations and factorizers
(or mediating morphisms). A CSL signature declares some functor names and their
types (i.e. variances), some natural transformation names and their types and some
factorizer names and their types. A CSL sentence is a conditional equation of functors,
natural transformations and factorizers. A CSL model is a category equipped with
functors, natural transformations and factorizers which have right types as are speciﬁed
in the signature and which satisfy the sentences.
Chapter 3 gives the main idea of Categorical Data Types. The diﬀerence between
CSL and CDT is that whereas CSL declares functors, natural transformations and

CHAPTER 1. INTRODUCTION
15
factorizers separately and connects them by sentences, CDT declare them together in
a style of adjoint declarations. The semantics of CDT will be given informally in terms
of F, G-algebras and formally in terms of CSL. There are some examples of data types
we can deﬁne in CDT.
Chapter 4 is about Categorical Programming Language (CPL for short). CPL is a
functional programming language which adopts the categorical declaration mechanism
of data types from CDT. In order to deﬁne the notion of computation in CPL, we
have to put some restrictions to CDT. We will introduce the notion of elements and
canonical elements and present reduction rules to reduce elements to their equivalent
canonical elements. We will also prove that any reduction in CPL terminates using
Tait’s computability method.
Each of those three languages, CSL, CDT and CPL, characterizes a category of data
types in diﬀerent ways.
Syntax
Semantics
CSL
Signature and Sentences
Models
CDT
Adjoint Declarations
Freeness and Co-Freeness
CPL
Restricted Adjoint Declarations
Operational
In chapter 5, we will investigate the real consequences of our study in CDT. Section 5.1
is about an implementation of CPL as a real programming language. Section 5.2 is
about the connection between CDT and typed lambda calculi, and ﬁnally in section 5.3
we will attempt to extend ML incorporating the CDT data type declaration mechanism.
1.5
Comparison with Other Works
Systematic studies of data types have already been carried out by various people in
various contexts: ADJ in the context of initial algebras [Goguen, Thatcher and Wagner
78], Plotkin, Smyth and Lehmann in the context of domains [Lehmann and Smyth 81,
Smyth and Plotkin 82] and Martin-L¨of in the context of type theory [Martin-L¨of 79].
This thesis is about a study of the same subject in the context of category theory. We
do not try to extend the traditional approaches as Parasaya-Ghomi did for algebraic
speciﬁcation methods to include higher order types [Parasaya-Ghomi 82], nor do we try
to unify two approaches together like [Dybjer 83], but we just directly use categorical
methods of deﬁning things.
Categorical Programming Language in chapter 4 might resemble Categorical Abstract
Machine (CAM) by Curien [Curien 86], but he is only interested in cartesian closed
categories whereas CPL deals with a class of diﬀerent categories. Moreover, the reduc-
tion rules in CPL is systematically generated for products, coproducts, exponentials,
natural numbers, and so on. We do not give any special reduction rules for any data
types we deﬁne. CPL can be seen as
CPL = CAM + initial data types + ﬁnal data types.

CHAPTER 1. INTRODUCTION
16
Actually, CAM can be absorbed into ‘initial data types’ and ‘ﬁnal data types’, so in
CPL we do not need to start with a particular set of reduction rules for cartesian closed
categories. CPL has an ability to deﬁne cartesian closed categories and the introduction
of data types also gives the control structure over those data types. Here is another
slogan: “control structures in programming languages come out of the structure of data
types”.
Data Types
Control Structures
boolean
↔
if statement
disjoint union
↔
case statement
natural number
↔
primitive recursion, for statement
product
↔
pairing
function space
↔
function call
Barr and Wells uses sketches in [Barr and Wells 85] to describe algebras categorically.
It is more powerful than ordinary algebraic speciﬁcation methods because sketches can
use any kind of limits whereas algebraic speciﬁcation methods uses only products. It
is interesting to investigate CSL by sketches.

Chapter 2
Categorical Speciﬁcation Language
CDT can be seen from various points of view and can be presented in many ways.
In this chapter, we present it as a speciﬁcation language for categories (we call the
speciﬁcation language Categorical Speciﬁcation Language or CSL for short). This is not
the way originated, and it is diﬃcult to recognize natural properties of data types in
this way. We will give an alternative and more intuitive deﬁnition of CDT in chapter 3.
However, the aim of CSL is to give mathematically rigorous background for the more
intuitive presentation of CDT.
In applicative functional programming languages like ML, it is natural to see that their
data types and functions form a category; each data type is an object; each function
is a morphism; we have an identity function; and two functions can be composed in
a usual way. We can also treat other programming languages including procedural
ones semantically as deﬁning domains and functions, and we can see that they form a
category. These categories associated with programming languages reﬂect the charac-
teristics of the programming languages. Thus, the study of data types can be carried
out by examining these categories. CSL is a speciﬁcation language for these categories.
Usually, a category is given by deﬁning what an object consists of (e.g. a set for Set,
the category of sets) and what a morphism between objects is (e.g. a set function for
Set), but this is not the way CSL works. We are trying to understand a category
in an abstract manner; we do not say what an object is; instead, we specify how it
is constructed through its relationship among other objects. We saw in chapter 1 an
ML data type for lists and it was a parameterized data type.
We can now see it
as a data type constructor; given a data type it constructs a new data type for the
lists of the given data type. Categorically, constructors of objects are functors and
they provide structures for categories. Remember that a cartesian closed category is a
category with three functors, the terminal (constant) functor, the product functor and
the exponential functor. Thus, CSL speciﬁes a category equipped with some functors.
Because the properties of functors are often described in terms of their interaction with
natural transformations and factorizers (e.g. the binary product functor is explained
with two natural transformations, π1 and π2, and factorizer ⟨, ⟩), CSL also speciﬁes
natural transformations and factorizers.
17

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
18
Let us make a comparison with algebraic speciﬁcation languages like CLEAR [Burstall
and Goguen 80, Burstall and Goguen 82]. An algebraic speciﬁcation consists of decla-
rations of some sorts and some operations on these sorts. Sorts are their data types.
A model of an algebraic speciﬁcation is a many-sorted algebra. On the other hand, a
CSL speciﬁcation consists of declarations of some functors, some natural transforma-
tions between them and some factorizers. Functors correspond to sorts, and natural
transformations and factorizers correspond to operations. A model of a CSL speciﬁca-
tion is a category equipped with some functors, some natural transformations between
them and some factorizers. It is abstract in the sense that the speciﬁcation does not
distinguish between equivalent categories (an algebraic speciﬁcation does not distin-
guish isomorphic algebras). Note that, in general, the various models of a speciﬁcation
are not equivalent (e.g. not all the cartesian categories are equivalent).
As CSL speciﬁes functors, the treatment of parametrized data types is diﬀerent from
algebraic speciﬁcation languages. It speciﬁes one level higher objects. The concept of
parameterized data types and how to combine them play very essential roles in algebraic
speciﬁcation languages, but parameterized data types are treated in their meta-level
(one level higher than the level treating algebras), that is speciﬁcations themselves are
parameterized rather than dealing with parameterized sorts in speciﬁcations. In CSL,
on the other hand, parameterized data types are the basic objects in speciﬁcations.
In one speciﬁcation, several parameterized data types can be declared and their re-
lationship is directly speciﬁed. Therefore, combining speciﬁcations does not play as
important a role as it does in algebraic speciﬁcation languages.
Our goal in this chapter is to deﬁne the speciﬁcation language CSL. In section 2.1,
we will introduce several notations for dealing with functors which will be necessary
later. In section 2.2, we will deﬁne the CSL signatures and in section 2.3 the CSL
structures. The deﬁnition of CSL sentences and the CSL satisfaction relation will be
in section 2.5 which follows section 2.4 in which we will introduce expressions involving
natural transformations and factorizers. Finally, in section 2.6 we will show that there
is an initial CSL structure for each CSL theory.
2.1
A Functorial Calculus
Before giving the deﬁnition of CSL signatures, we will look at some aspects of functors.
This will be a kind of a functorial calculus though not as abstract as [Kelly 72] is. [Kelly
72] develops a calculus of combining functors as we will do in this section, but for the
purpose of solving the coherence problems, and he treats many variable functors quite
extensively. However, he does not say much about mixed variant functors which we
are interested in. We will also generalize variances to include free-variance and ﬁxed-
variance for uniform treatment.
Functors are very much like ordinary functions except that functors have variances.
Let F be a unary functor C →C and G be a binary functor C × C →C. Then, we can

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
19
combine them to get more complex functors:
G(F(X), Y )
F(G(X, F(Y )))
G(F(X), G(X, Y ))
. . .
We call them functorial expressions. Of course, not every such expression denotes a
functor. For example, G(X, X) is not a proper functor if G is covariant in one argument
and contravariant in the other. It is a functor if G is covariant in both arguments or
contravariant in both arguments, or if G does not depend on one of the arguments.
In order to cope with these situations uniformly, we introduce two new variances: ﬁxed-
variance and free-variance. We say that a functor F(X) is ﬁxed-variant in X if F is
not functorial in X, that is, F maps objects to objects, but not morphisms. We also
say that a functor F(X) is free-variant in X if F does not depend on X. Therefore,
when G: C × C →C is covariant in the ﬁrst argument and contravariant in the second,
G(X, X) is a ﬁxed-variant functor.
Let us introduce the symbols for variances.
Deﬁnition 2.1.1: Let Var be the set of variances {+, −, ⊥, ⊤}: + for covariance,
−for contravariance, ⊥for free-variance and ⊤for ﬁxed-variance. []
The next deﬁnition is extending the notion of opposite categories.
Deﬁnition 2.1.2: Let C be a category.
1. C+ is C itself.
2. C−is the opposite category of C.
3. C⊥is the category which has only one object and only one morphism (i.e. the
identity of the one object). We may call the category one point category.
4. C⊤is the category which has the same objects as C but no morphisms except
identities. []
In this way, we can regard the variances as functions mapping categories to categories
(i.e. Cat →Cat, where Cat is the category of (small) categories) or we can even
regard them as a monoid acting on Cat.
Deﬁnition 2.1.3: ⟨Var, •⟩is a commutative monoid with unit +, where the monoid
operation •: Var × Var →Var is deﬁned by the following table.
• ⊥+ −⊤
⊥⊥⊥⊥⊥
+ ⊥+ −⊤
−⊥−+ ⊤
⊤⊥⊤⊤⊤
[]

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
20
Proposition 2.1.4: ⟨Var, •⟩is a monoid acting on Cat, that is, Cu•v = (Cu)v for any
u, v ∈Var.
Proof: We have to show (C−)−= C (i.e. the opposite of opposite is itself) and so on,
but they are trivial. []
Since we will deal with many variable functors and they are functors from products
of categories C × · · · × C to a category C, Var action for product categories should be
investigated.
Proposition 2.1.5: Var action on Cat distributes over products, that is, for any
categories C and D
(C × D)u ∼= Cu × Du.
Proof: In case u is −, it says that the opposite of the product category is isomorphic
to the product of the opposite categories and it is the case because ⟨f, g⟩op: ⟨A, B⟩→
⟨C, D⟩⇐⇒⟨f, g⟩: ⟨C, D⟩→⟨A, B⟩⇐⇒f: C →A and g: D →B ⇐⇒f op: A →C
and gop: B →D ⇐⇒⟨f op, gop⟩: ⟨A, B⟩→⟨C, D⟩. The other cases are trivial. []
We need one more preparation before talking about mixed variant functors. The cate-
gory C⊤can be embedded into C+ as well as into C−and they themselves are embedded
into C⊥, that is we have the following embedding functors.
C+
↙
↖
C⊥
C⊤
↖
↙
C−
We introduce a partial order on Var to respect these embeddings.
Deﬁnition 2.1.6: ⊑is a partial order on Var such that ⊥⊑+ ⊑⊤and ⊥⊑−⊑⊤. []
From the deﬁnition, it is clear that
Proposition 2.1.7: If u ⊑v, there is an embedding functor eu,v: Cv →Cu. []
Now we can start talking about mixed variant functors and their calculus. As a function
is associated with an arity (simply a natural number), a mixed variant functor over a
particular category C is associated with a varity which is a sequence of variances. For
example, binary functor G: C × C →C which is contravariant in the ﬁrst argument and
covariant in the second is a functor with a varity −+.
Deﬁnition 2.1.8: A mixed variant functor F of varity v1 . . . vn is a (covariant) functor
from Cv1 × · · · × Cvn to C. []
When we are given a Var∗-indexed set Γ of primitive mixed variant functors, where
F ∈Γv1...vn is a functor of varity v1 . . . vn, we would like to establish how to combine
these primitive functors and get more complex functors like H(G(X, Y ), F(X)).
Firstly, we extend the action of variances on categories to that on functors. For exam-
ple, from a contravariant functor F: C−→C we get a covariant functor F −: C →C−as
F −(f: A →B) def
= F(f op: B →A).

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
21
Deﬁnition 2.1.9: For a functor F: C →D,
1. a functor F +: C+ →D+ is F itself,
2. a functor F −: C−→D−is given by F −(A) = A for an object A in C and
F −(f op) = F(f)op for a morphism f in C,
3. a functor F ⊥: C⊥→D⊥is the identity functor since both C⊥and D⊥are the one
point category, and
4. a functor F ⊤: C⊤→D⊤has the same object mapping as F but no morphism
mapping.
F: C →D
F ⊤: C⊤→D⊤
F −: C−→D−
F ⊥: C⊥→D⊥

>
-
ZZZZZZ
~
[]
This deﬁnition is forced from the deﬁnition of Cu, so Var action has more structure.
Proposition 2.1.10: For a functor F: C →D, (F u)v = F u•v.
Proof: We have to check this for all the combinations of u and v.
For example,
(F −)⊤= F ⊤is true because F −only changes the mapping of morphisms but (F −)⊤
forgets it. []
We have the two propositions which give us the basis for combining mixed variant
functors.
Proposition 2.1.11: For functors F: Cu1 × · · · × Cun →Cv1 × · · · × Cvm and G: Cv1 ×
· · · × Cvm →C (i.e. varity v1 . . . vm), G ◦F is a functor of Cu1 × · · · × Cun →C (i.e.
varity u1 . . . un).
Cu1 × · · · × Cun
F
Cv1 × · · · × Cvm
G
C
-
-
Proof: Trivial from the deﬁnition of composition of functors. []

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
22
Proposition 2.1.12: For functors F1: Cu1 ×· · ·×Cun →Cv1, . . . , Fm: Cu1 ×· · ·×Cun →
Cvm, ⟨F1, . . . , Fm⟩is a functor of Cu1 × · · · × Cun →Cv1 × · · · × Cvm.
Cu1 × · · · × Cun
F1
...
Fi
...
Fm
Cv1
...
Cvi
...
Cvm
©©©©©©©
©
*
-
HHHHHHH
H
j
⇒
Cu1 × · · · × Cun⟨F1, . . . , Fm⟩Cv1 × · · · × Cvm
-
Proof: It is trivial from the deﬁnition of products in Cat. []
The two propositions allow us to combine functors only if the source and target cate-
gories match exactly. For example, F: C →C and G: C−→C cannot be composed into
G ◦F. Therefore, we have to ﬁrst convert functors of Cv1 × · · · × Cvn →C into those
of Cv′
1 × · · · × Cv′
n →Cu. There are two ways to do so.
Firstly, from deﬁnition 2.1.9, functor F of varity v1 . . . vn, that is F is a functor of
Cv1 × · · · × Cvn →C, into
F u: (Cv1 × · · · × Cvn)u →Cu ∼= Cv1•u × · · · × Cvn•u →Cu
The isomorphism is from proposition 2.1.5 and proposition 2.1.4.
The other way of conversion is using embedding functors and coercing functors into
greater variances (e.g. covariant functor can be a ﬁxed variant functor).
Deﬁnition 2.1.13: If u1 ⊑v1, . . . , un ⊑vn and F is a functor of varity u1 . . . un, we
can coerce it to a functor of varity v1 . . . vn by
F|v1...vn
u1...un
def
= F ◦(eu1,v1 × · · · × eun,vn).
Cv1 × · · · × Cvn
eu1,v1 × · · · × eun,vn
Cu1 × · · · × Cun
F
C
?
-
We may write F|v1...vn when u1 . . . un is obvious. []
Let us now deﬁne the composition of mixed variant functors.
Deﬁnition 2.1.14: Let F be a functor of varity u1 . . . un and G1, . . . , Gn be functors
of varity v11 . . . v1m, . . . , vn1 . . . vnm, respectively. Then we have a functor F[G1, . . . , Gn]

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
23
of varity w1 . . . wm where wi
def
= u1 • v1i ⊔· · · ⊔un • vni1. The deﬁnition of the functor is
F[G1, . . . , Gn] def
= F ◦⟨Gu1
1 |w1...wm, . . . , Gun
n |w1...wm⟩
Proof of well-deﬁnedness: Gi is a functor of Cvi1 × · · · × Cvim →C. Gui
i is a functor
of Cui•vi1 × · · · × Cui•vim →Cui. Since ui • vi1 ⊑w1, . . . , ui • vim ⊑wm, from deﬁni-
tion 2.1.13 Gui
i |w1...wm is a functor of Cw1 × · · · × Cwm →Cui. From proposition 2.1.12
⟨Gu1|w1...wm, . . . , Gun|w1...wm⟩is a functor of Cw1×· · ·×Cwm →Cu1×· · ·×Cun. Therefore,
from proposition 2.1.11,
F ◦⟨Gu1|w1...wm, . . . , Gun|w1...wm⟩: Cw1 × · · · × Cwm →C
is a functor of varity w1 . . . wm. []
The variances of G1, . . . , Gn are appropriately modiﬁed according to the varity of F
and then the least upper bound is taken so that we can pair them together.
We need some lemmas to show the associativity of the composition.
Lemma 2.1.15: Let u ⊑v and F be a functor of varity w1 . . . wn.
1. For any w, u • w ⊑v • w and (eu,v)w = eu•w,v•w.
2. The following diagram commutes.
Cv•w1 × · · · × Cv•wn
ew1
u,v × · · · × ewn
u,v
Cu•w1 × · · · × Cu•wn
F v
¥
¨§?
F u
Cv
eu,v
Cv
-
-
?
?
In other words, the action of Var on functors is natural with respect to the partial
order ⊑.
3. eu,v ◦F v = F u|w1•v...wn•v
4. F|u1...un|v1...vn = F|u1⊔v1...un⊔vn
5. (F ◦G)u = F u ◦Gu
6. ⟨F1, . . . , Fn⟩u = ⟨F u
1 , . . . , F u
n ⟩
7. (F|v1...vn)u = F u|v1•u...vn•u
1Var is a commutative semiring with unit: ⊔as its addition and • as its multiplication. If we express
varities as vectors, then varity of F[G1, . . . , Gn] can be computed by the following matrix multiplica-
tion.
(w1, . . . , wm) = (u1, . . . , un)



v11 . . . v1m
...
...
...
vn1 . . . vnm




CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
24
Proof: We have to check any pairs of u and v 1 and 2 hold from the deﬁnitions. 3
follows 2. 4, 5 and 6 are easy to show and 7 follows them.
(F|v1...vn)u = (F ◦(ew1,v1 × · · · × ewn,vn))u
= F u ◦(ew1,v1 × · · · × ewn,vn)u = F u ◦((ew1,v1)u × · · · × (ewn,vn)u)
= F u ◦(ew1•u,v1•u × · · · × ewn•u,vn•u) = F u|v1•u...vn•u
[]
Proposition 2.1.16: Let F, G1, . . . , Gn and H1, . . . , Hm be functors of the following
varities:
F: u1 . . . un
G1: v11 . . . v1m,
. . .
, Gn: vn1 . . . vnm
H1: w11 . . . w1l,
. . .
, Hn: wm1 . . . wml
Then, the following equality between functors holds:
(F[G1, . . . , Gn])[H1, . . . , Hm] = F[G1[H1, . . . , Hm], . . . , Gn[H1, . . . , Hm]].
Proof: Let varity a1 . . . am, b11 . . . b1l, . . . , bn1 . . . bnl and c1 . . . cl be
(a1, . . . , am) def
= (u1, . . . , un)




v11 . . . v1m
... ...
...
vn1 . . . vnm



,




b11 . . . b1l
... ... ...
bn1 . . . bnl




def
=




v11 . . . v1m
... ...
...
vn1 . . . vnm








w11 . . . w1l
...
...
...
wm1 . . . wml



,
and
(c1, . . . , cl) def
= (u1, . . . , un)




v11 . . . v1m
... ...
...
vn1 . . . vnm








w11 . . . w1l
...
...
...
wm1 . . . wml



.
Then,
(F[G1, . . . , Gn])[H1, . . . , Hm]
= F ◦⟨Gu1
1 |a1...am, . . . , Gun
n |a1...am⟩◦⟨Ha1
1 |c1...cl, . . . , Ham
m |c1...cl⟩
= F ◦⟨Gu1
1 |a1...am ◦⟨Ha1
1 |c1...cl, . . .⟩, . . .⟩
= F ◦⟨Gu1
1 ◦(ev11•u1,a1 × · · · × ev1m•u1,am) ◦⟨Ha1
1 |c1...cl, . . .⟩, . . .⟩
= F ◦⟨Gu1
1 ◦⟨ev11•u1,a1 ◦Ha1
1 |c1...cl, . . .⟩, . . .⟩
= F ◦⟨Gu1
1 ◦⟨Hv11•u1|w11•v1•u1...w1l•v1•u1|c1...cl, . . .⟩, . . .⟩
= F ◦⟨Gu1
1 ◦⟨Hv11•u1|c1...cl, . . .⟩, . . .⟩
whereas
F[G1[H1, . . . , Hm], . . . , Gn[H1, . . . , Hm]]
= F ◦⟨(G1 ◦⟨Hv11
1 |b11...b1l, . . . , Hv1m
m |b11...b1l⟩)u1|c1...cl, . . .⟩
= F ◦⟨Gu1
1 ◦⟨Hv11•u1
1
|b11•u1...b1l•u1|c1...cl, . . .⟩, . . .⟩
= F ◦⟨Gu1
1 ◦⟨Hv11•u1
1
|c1...cl, . . .⟩, . . .⟩
Therefore, the proposition holds. []

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
25
Mixed variant functors form an algebraic theory but with an extra structure. Mixed
variant functors are functions between four sorts, +, −, ⊥and ⊤.
Finally, we can show what functorial expressions like H(G(X, Y ), F(X)) mean. Let Γ
be a Var∗-indexed set of primitive functor names2. Then, we deﬁne
FE(Γ) def
= the set of terms constructed from Γ and variables like term al-
gebras.
CFE(Γ) def
= { λ(X1, . . . , Xn).E | E ∈FE(Γ) and X1, . . . , Xn includes all the
variables in E }
We call elements of FE(Γ) functorial expressions over Γ and call elements of CFE(Γ)
closed functorial expressions over Γ. As we can convert any lambda closed term in a
term algebra to a morphism in the corresponding algebraic theory, we can convert any
closed functorial expression into functors. Let ξ be an assignment of functor symbols
in Γv1...vn to real functors of varity v1 . . . vn in C, that is, ξ is a Var∗-indexed function
such that
ξv1...vn: Γv1...vn →Funct(Cv1 × · · · × Cvn, C)
where Funct(D, E) is the category of functors from D to E. We may write ξF for
ξv1...vn(F). We can extend assignment ξ to that over CFE(Γ) as follows
ξ(λ(X1, . . . , Xn).E) def
= ξX1,...,Xn(E)
where ξX1,...,Xn assigns expressions in FE(Γ) which have X1, . . . , Xn as variables to
functors of n variables and is deﬁned by
ξX1,...,Xn(Xi) def
= Πn
i : C⊥× · · · C+ × · · · C⊥→C
ξX1,...,Xn(F(E1, . . . , En)) def
= ξF[ξX1,...,Xn(E1), . . . , ξX1,...,Xn(En)]
where Πn
i is the ith projection of the n fold product of C.
Example 2.1.17: Let Γ consist of a unary functor symbol F which is covariant, a
functor symbol G of varity ++ and a functor symbol H of varity −+. Let ξ be an
assignment of Γ. Then, λ(X, Y ).H(G(X, Y ), F(X)) denotes the following functor by
ξ.
ξ(λ(X, Y ).H(G(X, Y ), F(X))) = ξH[ξG[Π2
1, Π2
2], ξF[Π2
1]]
The varity of Π2
1 is +⊥, that of ξF is + and, therefore, from deﬁnition 2.1.14, ξF[Π2
1]
has varity +⊥. The varity of Π2
1 is +⊥, that of Π2
2 is ⊥+, that of ξG is ++ and from
deﬁnition 2.1.14 the varity of ξG[Π2
1, Π2
2] is
(+, +)
Ã
+ ⊥
⊥+
!
= (+ • + ⊔+ • ⊥, + • ⊥⊔+ • +) = (+ ⊔⊥, ⊥⊔+) = (+, +)
Finally, the varity of the whole functor is
(−, +)
Ã
+ +
+ ⊥
!
= (−• + ⊔+ • +, −• + ⊔+ • ⊥) = (−⊔+, −⊔⊥) = (⊤, −),
so it is ﬁxed-variant in X and contravariant in Y . []
2From now on, we distinguish names (or symbols) from what they denote.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
26
The last proposition in this section is to establish the relationship between the syn-
tactic substitution of functorial expressions and the composition of functors deﬁned in
deﬁnition 2.1.14.
Proposition 2.1.18: Let
λ(X1, . . . , Xn).E
and
λ(Y1, . . . , Ym).E1, . . . , λ(Y1, . . . , Ym).En
be closed functorial expressions. Then,
ξ(λ(X1, . . . , Xn).E)[ξ(λ(Y1, . . . , Ym).E1), . . . , ξ(λ(Y1, . . . , Ym).En)]
= ξ(λ(Y1, . . . , Ym).E[E1/X1, . . . , En/Xn])
where E[E1/X1, . . . , En/Xn] is E in which X1, . . . , Xn are replaced by E1, . . . , En,
respectively.
Proof: We can easily prove it by structural induction on E using proposition 2.1.16 []
From this correspondence, for closed functorial expression K of n variables and L1, . . . , Ln
of m variables, we write
K[L1, . . . , Ln]
for a closed functorial expression of m variables which is obtained by replacing n
variables in K by L1, . . . , Ln. Then, the proposition is
ξ(K[L1, . . . , Ln]) = ξK[ξL1, . . . , ξLn].
2.2
Signatures of Categorical Speciﬁcation
Language
A speciﬁcation normally consists of a signature, which says what kind of sorts there
are and what kinds of operations there are, and a set of sentences (or equations), which
give properties of the operations. A speciﬁcation deﬁnes a class of models which have
what the signature says and satisﬁes the sentences. Therefore, in order to deﬁne a
speciﬁcation language, we have to deﬁne what its signatures are, what its sentences
are and what its models are. However, it is often convenient to deﬁne, ﬁrst, models
without being constrained by sentences and, then, deﬁne a satisfaction relation between
a statement and a model determining whether the statement is true in the model or
not. A model which satisﬁes all the sentences is called a theory model. See institutions
[Goguen and Burstall 83] for a categorical abstract deﬁnition of what speciﬁcation
languages are.
A CSL signature will be divided into three parts; in the ﬁrst part, we will declare some
names for functors, which will serve as parameterized data types (or data type con-
structors); in the second part, we will declare some names for natural transformations,
which will serve as polymorphic functions over the parameterized data types; and in
the third part, we will declare some names for factorizers (or mediating morphisms),
which will be necessary to put initial or ﬁnal constrains on the data types.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
27
The ﬁrst part can be presented as a Var∗-indexed set Γ. F in Γv1...vn is said to have
varity v1 . . . vn. We may write F(v1, . . . , vn) to indicate this.
Γ looks almost like an equational signature for algebraic speciﬁcation languages. It
is as if Var were the set of sorts and Γ were a set of operations over the sorts. The
only diﬀerence is that Γ is not a Var∗×Var-indexed set but simply a Var∗-indexed set.
This is because we can apply Var to functors to get other functors as we explained in
deﬁnition 2.1.9, so it is suﬃcient to give Γ as a Var∗-indexed set.
Note that Γ is one sorted.
Each signature describes only one category.
However,
because we are dealing with one level higher objects, it has the power to describe more
than one data type (or sort) inside one signature. We will illustrate this later in this
section.
In the second part, a CSL signature introduces some symbols for natural transforma-
tions. Normally, a natural transformation is deﬁned as follows: given two functors
F, G: C →D, a natural transformation α: F
·→G is a function which assigns to each
A ∈|C| a morphism αA: F(A) →G(A) such that for any morphism f: A →B in C the
following diagram commutes.
F(A)
αA
G(A)
-
F(f)
¥
¨§?
G(f)
?
?
F(B)
αB
-G(B)
As we have seen in section 2.1, closed functorial expressions provide more complicated
functors constructed from primitive functors in Γ. Let Λ be CFE(Γ). We index the set
of natural transformations by two closed functorial expressions, that is, the second part
of a CSL signature is given by a Λ×Λ-indexed set ∆; α ∈∆K,L will denote a natural
transformation ξK
·→ξL, where ξK and ξL will be the denotations of K and L,
respectively. We may write α: K
·→L to indicate this. Since a natural transformation
should go between functors of the same number of variables, ∆K,L should be empty
when K and L have diﬀerent number of variables. Even if they have the same number
of variables, their variances may be diﬀerent. In that case, we take the least upper
bound of two variances.
The third and the ﬁnal part of a CSL signature introduces symbols for factorizers (or
mediating morphisms). In general, a factorizer is an isomorphism associated with an
adjunction. If F 7−G where F: C →D and G: D →C, the factorizer ψ gives the
following natural isomorphism between hom sets.
ψ: HomD(F(A), B)
∼
=
−→HomC(A, G(B))
For example, the factorizer associated with the binary product functor ‘prod’ (: C×C →
C) is ‘pair’ which gives for any two morphisms f: C →A and g: C →B a morphism

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
28
pair(f, g): C →prod(A, B). We can write this situation as the following rule.
C
f
−→A
C
g
−→B
C
pair(f,g)
−−−−−→prod(A, B)
In CSL, factorizers are given by a (Λ×Λ)∗×(Λ×Λ)-indexed set Ψ (Λ = CFE(Γ)). The
index (Λ×Λ)∗speciﬁes the type of morphisms to which a factorizer can be applied and
the index Λ×Λ speciﬁes the type of morphisms obtained by applying the factorizer. For
ψ ∈Ψ⟨K1,L1⟩...⟨Km,Lm⟩,⟨K,L⟩,
we may write it as the following rule.
f1: K1 →L1
. . .
fm: Km →Lm
ψ(f1, . . . , fm): K →L
where f1, . . . , fn are auxiliary names of morphisms introduced for this rule. As we have
restricted the indexed set ∆, Ψ should be indexed by functors of the same number of
variables, and also we take the least upper bound of the variances and regard it as the
overall variance.
Hence, we come to the deﬁnition of CSL signatures.
Deﬁnition 2.2.1: A CSL signature is a triple ⟨Γ, ∆, Ψ⟩, where Γ is a Var∗-indexed
set, ∆is a Λ×Λ-indexed set (where Λ = CFE(Γ)) for natural transformations and Ψ
is a (Λ×Λ)∗×(Λ×Λ)-indexed set for factorizers. As a restriction to the triple, ∆K,L should
be empty if K and L has the diﬀerent number of variables and Ψ⟨⟨K1,L1⟩...⟨Km,Lm⟩,⟨K,L⟩⟩
should also be empty if Ki, Li, K and L do not have the same number of variables. []
As an example, we will give a CSL signature for cartesian closed categories.
Example 2.2.2: A cartesian closed category can be characterized as a category having
three special functors: terminal object ‘1’ (which is a constant functor), binary product
‘prod’ and exponential ‘exp’. Therefore,
Γ() = {1},
Γ++ = {prod},
Γ−+ = {exp},
where ‘()’ denotes the empty string in Var∗. The rest of Γs are empty. We sometimes
write the index set Γ as
{1, prod(+, +), exp(−, +)}.
The product functor ‘prod’ is associated with two natural transformations which give
projection morphisms.
π1: λ(X, Y ).prod(X, Y )
·→λ(X, Y ).X
π2: λ(X, Y ).prod(X, Y )
·→λ(X, Y ).Y
If there is no ambiguity, we may write them by listing their components as follows:
π1A,B: prod(A, B) →A
π2A,B: prod(A, B) →B

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
29
Functors (Γ)
1
prod(+, +)
exp(−, +)
Natural Transformations (∆)
π1: prod(A, B) →A
π2: prod(A, B) →B
ev: prod(exp(A, B), A) →B
Factorizers (Ψ)
!: A →1
f: C →A
g: C →B
pair(f, g): C →prod(A, B)
h: prod(C, A) →B
curry(h): C →exp(A, B)
Figure 2.1: CSL Signature for Cartesian Closed Categories
We might even omit subscripts from π1A,B and π2A,B. The exponential functor ‘exp’ is
associated with one natural transformation which gives evaluation morphisms.
ev: λ(X, Y ).prod(exp(X, Y ), X)
·→λ(X, Y ).Y
Note that the variance of these two functors is ⊤+. Therefore, ∆is
∆λ(X,Y ).prod(X,Y ),λ(X,Y ).X
= {π1}
∆λ(X,Y ).prod(X,Y ),λ(X,Y ).Y
= {π2}
∆λ(X,Y ).prod(exp(X,Y ),X),λ(X,Y ).Y = {ev}
For any other combinations of closed functorial expression K and L, ∆K,L is empty.
Finally, there are three factorizers for the three functors: ‘!’ for ‘1’, ‘pair’ for ‘prod’
and ‘curry’ for ‘exp’.
!: λ(X).X →λ(X).1
f: λ(X, Y, Z).Z →λ(X, Y, Z).X
g: λ(X, Y, Z).Z →λ(X, Y, Z).Y
pair(f, g): λ(X, Y, Z).Z →λ(X, Y, Z).prod(X, Y )
h: λ(X, Y, Z).prod(Z, X) →λ(X, Y, Z).Y
curry(h): λ(X, Y, Z).Z →λ(X, Y, Z).exp(X, Y )
If there is no ambiguity, we might write these rules down as in ﬁgure 2.1, where we
summarize the deﬁnition of the CSL signature for cartesian closed categories. We will
omit the tedious formal deﬁnition of Ψ as an indexed set. []
As we mentioned earlier, a CSL signature is one sorted, but because it handles higher
objects, it is no less powerful than a many sorted equational signature. Let us demon-
strate this. An equational signature is given by a pair ⟨S, Σ⟩where S is a set (of sort
names) and Σ is an S∗×S-indexed set (of operator names). We will translate it to a
corresponding CSL signature ⟨Γ, ∆, Ψ⟩. Since functors play a role of sorts, we declare
a constant functor for each sort in S.
Γ() = S,

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
30
and we have a binary product functor to deal with sequences of sorts,3 and the terminal
object for constants.
Γ++ = { prod }
and
Γ() = { 1 }
Operations will be translated to natural transformations:
for each operation o ∈
Σs1...sn,s, we have a natural transformation of the same name.
o: prod(s1, prod(. . . , prod(sn−1, sn))) →s
that is,
∆λ().prod(s1,prod(...,prod(sn−1,sn))),λ().s = Σs1...sn,s
We also have two projections for ‘prod’ in ∆and Ψ has only one factorizer ‘pair’ for
pairing. It is easy to see that the CSL signature ⟨Γ, ∆, Ψ⟩corresponds to the equational
signature ⟨S, Σ⟩.
Proposition 2.2.3: A many-sorted equational signature can be represented by a CSL
signature. []
It is interesting to know that we represented a many-sorted equational signature by a
category with products because an algebraic theory can exactly be given as a category
with products [Lawvere 63].
Let us make CSL signatures form a category by extending a pre-CSL signature mor-
phism in a natural way. Intuitively, a signature morphism (not only in CSL but in
general) does some renamings of symbols and/or some mergings of symbols.
Deﬁnition 2.2.4: A CSL signature morphism σ from a CSL signature ⟨Γ, ∆, Ψ⟩to a
CSL signature ⟨Γ′, ∆′, Ψ′⟩is a triple ⟨σ′, σ′′, σ′′′⟩consisting of
1. a Var∗-indexed function σ′
v1...vn: Γv1...vn →Γ′
v1...vn for mapping functor names,
2. a Λ×Λ-indexed function (where Λ = CFE(Γ)) σ′′
K,L: ∆K,L →∆′
σ′K,σ′L for mapping
natural transformation names, and
3. a (Λ×Λ)∗×(Λ×Λ)-indexed function
σ′′′
⟨⟨K1,L1⟩...⟨Km,Lm⟩,⟨K,L⟩⟩:
Ψ⟨⟨K1,L1⟩...⟨Km,Lm⟩,⟨K,L⟩⟩→Ψ′
⟨⟨σ′K1,σ′L1⟩...⟨σ′Km,σ′Lm⟩,⟨σ′K,σ′L⟩⟩
for mapping factorizer names.
We often write σF for σ′
v1...vn(F), σα for σ′′
K,L(α) and σψ for σ′′′
⟨⟨K1,L1⟩...,⟨K,L⟩⟩(ψ). []
Deﬁnition 2.2.5: The category of CSL signatures CSig has CSL signatures as its ob-
jects and CSL signature morphisms as its morphisms. The identity morphism on a CSL
signature ⟨Γ, ∆, Ψ⟩consists of the corresponding identity functions for the components
and the composition of CSL morphisms is given by combining the component-wise
compositions as indexed functions. This clearly forms a category. []
3We could have n-ary product functors for all natural numbers as well, but since we can represent them
using a binary one, we only declare the binary one.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
31
2.3
Structures of Categorical Speciﬁcation Lan-
guage
In this section, we will deﬁne CSL structures. A CSL signature speciﬁes symbols for
functors, natural transformations and factorizers, so intuitively, a CSL structure is a
category associated with these functors, natural transformations and factorizers.
Deﬁnition 2.3.1: Given a CSL signature ⟨Γ, ∆, Ψ⟩, a CSL structure ⟨C, ξ⟩is a small
category C together with an assignment ξ
1. ξ assigns each functor name of varity v1 . . . vn to a functor Cv1 × · · · × Cvn →C.4
As we have seen in section 2.1, ξ can be extended to the assignment of closed
functorial expressions to functors.
2. ξ assigns each natural transformation name α ∈∆K,L, where K and L are closed
functorial expressions of n variables, to a set of C morphisms
ξαA1,...,An: ξK(A1, . . . , An) →ξL(A1, . . . , An)
for arbitrary C objects A1, . . . , An.5
3. Each factorizer symbol ψ ∈Ψ⟨⟨K1,L1⟩...,⟨K,L⟩⟩, where K1, L1,. . . , Km, Lm, K, L are
closed functorial expressions of n variables, is assigned to a set of Set functions
ξψA1,...,An:
m
Y
i=1
HomC(ξKi(A1, . . . , An), ξLi(A1, . . . , An))
→HomC(ξK(A1, . . . , An), ξL(A1, . . . , An))
for arbitrary C objects A1, . . . , An. []
Note that we do not assign a natural transformation symbol to a natural transfor-
mation, but it is mapped to a set of morphisms and whether they form a natural
transformation or not is left to be stated by equations.
Example 2.3.2: Let ⟨Γ, ∆, Ψ⟩be the CSL signature for cartesian closed categories
deﬁned in example 2.2.2. Then, any cartesian closed category is a CSL structure of
this signature by obvious assignment of the symbols to the functors, natural transfor-
mations and factorizers. However, the converse is not true. We can have a category
4We could say ξ is a Var
∗-indexed function
ξv1...vn: Γv1...vn →Funct(Cv1 × · · · × Cvn, C).
5We could express it as a Λ×Λ-indexed function (where Λ = CFE(Γ))
ξK,L: ∆K,L →Nat(ξK|⊤...⊤, ξL|⊤...⊤).

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
32
which has three functors, three natural-transformation-look-alikes and three factorizer-
look-alikes. CSL structures do not require mapping natural transformation symbols
to natural transformations but only to a set of morphisms, nor do they require map-
ping factorizer symbols to factorizers. The factorizer-look-alikes may not give unique
morphisms or may not commute some diagrams. []
CSL structure morphisms are deﬁned simply as a kind of homomorphisms. They keep
the structure nicely.
Deﬁnition 2.3.3: Given a CSL signature ⟨Γ, ∆, Ψ⟩, a CSL structure morphism from
a CSL structure ⟨C, ξ⟩to another ⟨D, ζ⟩is a covariant functor T: C →D such that
1. for any F in Γv1...vn
T ◦ξF = ζF ◦(T v1 × · · · × T vn)
holds,
Cv1 × · · · × Cvn
T v1 × · · · × T vn
Dv1 × · · · × Dvn
ξF
¥
¨§?
ζF
C
D
?
-
- ?
2. for any α ∈∆K,L and for any C objects A1, . . . , An
T(ξαA1,...,An) = ζαT(A1),...,T(An),
and
3. for any ψ ∈Ψ⟨K1,L1⟩...⟨Km,Lm⟩,⟨K,L⟩, for any C objects A1, . . . , An and for any C
morphisms fi: ξKi(A1, . . . , An) →ξLi(A1, . . . , An) (i = 1, . . . , m),
T(ξψA1,...,An(f1, . . . , fm)) = ζψT(A1),...,T(An)(T(f1), . . . , T(fm)). []
Hence, the category of CSL structures is:
Deﬁnition 2.3.4: For a CSL signature ⟨Γ, ∆, Ψ⟩, the category of CSL structures,
CMod(⟨Γ, ∆, Ψ⟩), has CSL structures as objects and CSL structure morphisms as
morphisms; the identity morphism on ⟨C, ξ⟩is the identity functor IC and the compo-
sition of morphisms is the composition of their underlying functors. []
2.4
Functorial Calculus (revisit)
In section 2.1 we saw functorial expressions denote functors. In this section we will see
an expression involving natural transformation symbols and factorizer symbols denote

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
33
a set of morphisms.6 For example, under the signature of cartesian closed categories
given in example 2.2.2, what should the following expression denote?
π1 ◦prod(curry(π2), I)
We even have a problem for expressions like π1◦π2 because π1 and π2 are not projections
of the same product: π2 is of prod(A, prod(B, C)) and π1 is of prod(B, C). Actually,
natural transformations are polymorphic like ML functions are.7
As we deﬁned in
deﬁnition 2.3.1, π1 denotes a set of morphisms.
ξπ1A,B: ξprod(A, B) →A
We have to ﬁgure out for each occurrence of π1 what A and B are.
Deﬁnition 2.4.1: For a CSL signature ⟨Γ, ∆, Ψ⟩, we have a set Exp(Γ, ∆, Ψ) of CSL
expressions deﬁned by the following BNF.
e : : = I | e1 ◦e2 | α | ψ(e1, . . . , em) | F(e1, . . . , en) | f
where α ∈∆, ψ ∈Ψ and f is a variable for morphisms.
We also have a set
AExp(Γ, ∆, Ψ) of CSL annotated expressions deﬁned by the following BNF.
e : : = I[K] | e1 ◦e2 | α[K1, . . . , Kn] | ψ[K1, . . . , Kn](e1, . . . , em) |
F(e1, . . . , en) | f
where K1, . . . , Kn are closed functorial expressions over Γ. []
It is trivial to see that for each annotated expression there is a corresponding expres-
sion (i.e. forgetting all the annotations, [. . .]), which we call skeleton of the annotated
expression. We are going to type-check an expression ﬁrst and, then, we determine its
denotation. Annotated expressions are used to remember the type-checking informa-
tion inside expressions. We will give the typing rules for annotated expressions and
show that every expression has the most general annotated expression and we take the
type of this annotated expression as the type of the expression.
First, we deﬁne the notion of uniﬁcation.
Deﬁnition 2.4.2: A closed functorial expression K of n variables is said to be more
general than a closed functorial expression K′ of m variables if there are closed func-
torial expressions K1, . . . , Kn of m variables such that
K[K1, . . . , Kn] ≡K′
6Some may want it to denote a natural transformation, but the treatment of factorizers seems very
complicated to do so.
7Conversely, ML polymorphic functions are natural transformations. The author has not yet seen the
deﬁnite statement of this, but it is a folklore among computer scientists dealing with category theory.
This fact is rarely used in practice, but it sometimes helps to understand the behaviour of polymorphic
functions. For example, any ML function f of type αlist →int should never depend on elements in
the list but only to the length of list. As another example, if f is of type αlist →αlist and if we apply
it to an integer list [1, 4, 3, 5] and get [5, 1, 3], we know the result of applying f to [2, 8, 6, 10] (each
element is doubled) without actually applying it. The result should be [10, 2, 6], i.e. each element of
the result is doubled as well.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
34
where ≡is the equivalence relation ignoring variable renaming. (Trivially, K ≡K′
implies ξK = ξK′.) []
Deﬁnition 2.4.3: Closed functorial expressions K and L are said to be uniﬁable when
there is a closed functorial expression K′ such that K′ is less general than K as well
as L. []
Proposition 2.4.4: If closed functorial expressions K and L are uniﬁable, then there
is a most general uniﬁcation, that is, there exist K1, . . . , Kn and L1, . . . , Lm such that
K[K1, . . . , Kn] ≡L[L1, . . . , Lm] and for any K′ which is less general than K and K′
there are K′
1, . . . , K′
l such that K′ ≡K[K1, . . . , Kn][K′
1, . . . , K′
l].
Proof: Same as ordinary uniﬁcation of terms. []
Let us now deﬁne the type of annotated expressions.
Deﬁnition 2.4.5: Let ⟨Γ, ∆, Ψ⟩be a CSL signature. An annotated expression e has a
type ρ ⊢e: K →L when it can be derived from the following rules, where ρ is a given
assignment of each morphism variable to its type and K and L are closed functorial
expressions.
1. For the identity, ρ ⊢I[K]: K →K.
2. For the composition,
ρ ⊢e1: K′ →L
ρ ⊢e2: K →K′
ρ ⊢e1 ◦e2: K →L
.
3. For a natural transformation α ∈∆K,L, where K and L are of n variables,
ρ ⊢α[K1, . . . , Kn]: K[K1, . . . , Kn] →L[K1, . . . , Kn]
4. For a factorizer ψ ∈Ψ⟨⟨K1,L1⟩...⟨Km,Lm⟩,⟨K,L⟩⟩, where Ki, Li, K, L are of n variables,
ρ ⊢ei: Ki[K′
1, . . . , K′
n] →Li[K′
1, . . . , K′
n]
ρ ⊢ψ[K′
1, . . . , K′
n](e1, . . . , em): K[K′
1, . . . , K′
n] →L[K′
1, . . . , K′
n]
5. For a functor F ∈Γv1...vn
ρ ⊢ei: Ki
vi
−→Li
ρ ⊢F(e1, . . . , en): F[K1, . . . , Kn] →F[L1, . . . , Ln]
where ei: Ki
vi
−→Li is ei: Ki →Li if vi is + or ⊥, ei: Li →Ki if vi is −and
I: Ki →Ki if vi is ⊤.
6. For a morphism variable f, ρ ⊢f: ρ(f). []

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
35
Deﬁnition 2.4.6: We say an annotated expression e is more general than e′ if there
exist closed functorial expressions K1, . . . , Kn such that e′ ≡e[K1, . . . , Kn], where
e[K1, . . . , Kn] is e with all its annotations being composed with K1, . . . , Kn, e.g. α[L1, . . . , Lm][K1, .
is α[L1[K1, . . . , Kn], . . . , Lm[K1, . . . , Kn]]. []
Proposition 2.4.7: If an annotated expression e has a type ρ ⊢e: K →L, e[K1, . . . , Kn]
has the following type.
ρ[K1, . . . , Kn] ⊢e[K1, . . . , Kn]: K[K1, . . . , Kn] →L[K1, . . . , Kn]
where ρ[K1, . . . , Kn](f) is K′[K1, . . . , Kn] →L′[K1, . . . , Kn] when ρ(f) is K′ →L′.
Proof: It can easily proved from deﬁnition 2.4.5 by structural induction on e. []
Proposition 2.4.8: Let e ∈Exp(Γ, ∆, Ψ) be an expression of a CSL signature ⟨Γ, ∆, Ψ⟩.
If there exists an annotated expression e′ whose skeleton is e and if it has a type, then
there exists a most general annotated expression which has a type and whose skeleton
is e.
Proof: It can be proved by structural induction on e. Here, we present an algorithm
of calculating a most general annotated expression.
1. If e is I, the most general annotated expression is I[I], where I is the identity
closed functorial expression λ(X).X.
2. If e is e1 ◦e2, from induction hypothesis, we have the most general annotated
expressions for e1 and e2.
ρ1 ⊢e′
1: K →K′
ρ2 ⊢e′
2: L →L′
We unify K with L′ achieving K[K1, . . . , Kn] ≡L′[L1, . . . , Lm]. The most general
annotated expression for e and its type is
ρ ⊢e′
1[K1, . . . , Kn] ◦e′
2[L1, . . . , Lm]: L[L1, . . . , Lm] →K′[K1, . . . , Kn]
where ρ is the result of combining ρ1[K1, . . . , Kn] and ρ2[L1, . . . , Lm].
3. If e is a natural transformation α ∈∆K,L, the most general annotated expression
and its type is
ρ ⊢α[Πn
1, . . . , Πn
n]: K →L,
where Πn
i is the closed functorial expression λ(X1, . . . , Xn).Xi.
4. If e is ψ(e1, . . . , em) for a factorizer ψ ∈Ψ⟨⟨K1,L1⟩...,⟨K,L⟩⟩, from induction hypoth-
esis, we have annotated expressions e′
i such that
ρi ⊢e′
i: K′
i →L′
i.
We unify K′
i with Ki and L′
i with Li. If the uniﬁcation is successful, we have the
most general annotated expression for e.
ρ ⊢ψ[J1, . . . , Jn](e′
1[J′
11, . . .], . . . , e′
m[J′
1m, . . .]):
K[J1, . . . , Jn] →L[J1, . . . , Jn]

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
36
where J1, . . . , Jn, J′
11, . . . are the substitution for Ki and Li obtained from the
uniﬁcation and ρ is the result of combining ρi[J′
1i, . . .].
5. If e is F(e1, . . . , en), let the most general annotated expressions for ei be
ρi ⊢e′
i: Ki
vi
−→Li.
Then, the most general annotated expression for e and its type is
ρ ⊢F(e′
1, . . . , e′
n): F[K1, . . . , Kn] →F[L1, . . . , Ln].
6. If e is a morphism variable f, its most general annotated expression is itself and
has the following type.
ρ ⊢f: λ(X, Y ).X →λ(X, Y ).Y
[]
From this proposition,
Deﬁnition 2.4.9: We deﬁne the type of an expression e ∈Exp(Γ, ∆, Ψ) to be the
type of the most general annotated expression e′ whose skeleton is e. []
Let us ﬁnally deﬁne the denotation of expressions in Exp(Γ, ∆, Ψ) when a CSL struc-
ture ⟨C, ξ⟩is given. Since each expression e is associated uniquely to the most general
annotated expression e′ by proposition 2.4.8, we can deﬁne the denotation of e to be
that of e′ and deﬁne the denotation of annotated expressions.
Deﬁnition 2.4.10: Let ⟨Γ, ∆, Ψ⟩be a CSL signature and ⟨C, ξ⟩be a CSL structure.
For an annotated expression e ∈AExp(Γ, ∆, Ψ) of type ρ ⊢e: K →L (where K and
L are of l variables), we deﬁne its denotation, ξe, to be a set of morphisms
(ξe)A1,...,Al: ξK(A1, . . . , Al) →ξL(A1, . . . , An)
for any C objects A1, . . . , Al and for any morphism variable assignment ω (where
ω(f, A1, . . . , Al) gives a morphism of type ξK′(A1, . . . , Al) →ξL′(A1, . . . , Al) when
ρ(f) is K′ →L′).
1. For the identity,
(ξI[K])A1,...,Al
def
= IξK[A1,...,Al]
2. For compositions,
(ξe1 ◦e2)A1,...,Al
def
= (ξe1)A1,...,Al ◦(ξe2)A1,...,Al
3. For natural transformations,
(ξα[K1, . . . , Kn])A1,...,Al
def
= ξαξK1(A1,...,Al),...,ξKn(A1,...,Al)

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
37
4. For factorizers,
(ξψ[K1, . . . , Kn](e1, . . . , em))A1,...,Al
def
=
ψξK1(A1,...,Al),...,ξKn(A1,...,Al)((ξe1)A1,...,Al, . . . , (ξem)A1,...,Al)
5. For functors,
(ξF(e1, . . . , en))A1,...,Al
def
= ξF((ξe1)A1,...,Al, . . . , (ξen)A1,...,Al)
6. For morphism variables,
(ξf)A1,...,An
def
= ω(f, A1, . . . , Al)
Proof of well-deﬁnedness: We have to show, for example, for a natural transforma-
tion α ∈∆K,L, (ξα[K1, . . . , Kn])A1,...,Al is a morphism from
ξK[K1, . . . , Kn](A1, . . . , Al)
to
ξL[K1, . . . , Kn](A1, . . . , Al).
This holds because from deﬁnition 2.3.1 ξαξK1(A1,...,Al),...,ξKn(A1,...,Al) is a morphism from
ξK(ξK1(A1, . . . , Al), . . .)) to ξL(ξK1(A1, . . . , Al), . . .) and from proposition 2.1.18 it is
from ξK[K1, . . . , Kn](A1, . . . , Al) to ξL[K1, . . . , Kn](A1, . . . , Al). []
Example 2.4.11: Let ⟨Γ, ∆, Ψ⟩be a CSL signature for cartesian closed categories
presented in example 2.2.2 and ⟨C, ξ⟩be a CSL structure of this signature where C is
a cartesian closed category and ξ is the standard assignment (i.e. the product symbol
to the product functor and so on). Let us ﬁnd out the denotation of ev ◦pair(f, π2).
First, we have to ﬁnd out the corresponding most general annotated expression and its
type by the algorithm used to prove proposition 2.4.8.
1. ev ◦pair(f, π2) is given by composing ev and pair(f, π2), so we need to calculate
the most general annotated expressions for these two sub-expressions ﬁrst.
(a) ev is a natural transformation, and its most general annotated expression is
ρ1 ⊢ev[Π2
1, Π2
2]: prod[exp, Π2
1] →Π2
2.
(b) pair(f, π2) is given by applying the factorizer pair to f and π2.
i. ‘f’ is a morphism variable, its most general annotated expression is
ρ2 ⊢f: Π2
1 →Π2
2.
ii. π2 is a natural transformation, and its most general annotated expres-
sion is
ρ3 ⊢π2[Π2
1, Π2
1]: prod →Π2
2.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
38
pair has the type
⟨⟨Π3
3, Π3
1⟩⟨Π3
3, Π3
2⟩, ⟨Π3
3, prod[Π3
1, Π3
2]⟩⟩
By uniﬁcation, we get the most general annotated expression for pair(f, π2).
ρ4 ⊢pair[Π3
3, Π3
2, prod[Π3
1, Π3
2]](f, π2[Π3
1, Π3
2]):
prod[Π3
1, Π3
2] →prod[Π3
3, Π3
2]
where ρ4 maps f to prod[Π3
1, Π3
2] →Π3
3.
Unifying prod[Π3
3, Π3
2] and prod[exp, Π2
1], we get the most general annotated ex-
pression for ev ◦pair(f, π2).
ρ5 ⊢ev[Π3
2, Π3
3] ◦pair[exp[Π3
2, Π3
3], Π3
2, prod[Π3
1, Π3
2]](f, π2[Π3
1, Π3
2])
: prod[Π3
1, Π3
2] →Π3
3
where ρ5 maps f to prod[Π3
1, Π3
2] →exp[Π3
2, Π3
3].
From deﬁnition 2.4.10, the denotation of this annotated expression is a set of morphisms
for objects A, B and C and a morphism variable assignment
ω(f, A, B, C): ξprod(A, B) →ξexp(B, C).
1. (ξev[Π3
2, Π3
3])A,B,C = ξevB,C
2. (ξf)A,B,C = ω(f, A, B, C)
3. (ξπ2[Π3
1, Π3
2])A,B,C = ξπ2A,B
4. (ξpair[. . .](f, π2[. . .]))A,B,C =
ξpairξexp(B,C),B,ξprod(A,B)(ω(f, A, B, C), ξπ2A,B)
5. (ξev[. . .] ◦pair[. . .](f, π2[. . .]))A,B,C =
ξevB,C ◦ξpairξexp(B,C),B,ξprod(A,B)(ω(f, A, B, C), ξπ2A,B)
Therefore, the denotation of ev ◦pair(f, π2) is
ξevB,C ◦ξpairξexp(B,C),B,ξprod(A,B)(ω(f, A, B, C), ξπ2A,B)
[]
2.5
Sentences and Satisfaction Relation of Cate-
gorical Speciﬁcation Language
In this section, we will ﬁnish deﬁning the speciﬁcation language CSL at last. First, we
deﬁne what a CSL sentence is.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
39
Deﬁnition 2.5.1: A CSL conditional equation is a sequence of CSL expression pairs
and a CSL expression pair. We usually write it as
e1 = e′
1 ∧. . . ∧en = e′
n ⇒e = e′,
or simply e = e′ if the preceding sequence is empty. To be typed, it needs to share the
same morphism variable environment, ei and e′
i have to have the same type and e and
e′ have to have the same type. We may write the types as follows:
ρ ⊢e1 = e′
1: K1 →L1 ∧. . . ∧en = e′
n: Kn →Ln ⇒e = e′: K →L
We write CEq(Γ, ∆, Ψ) for the set of all the CSL conditional equations which can be
typed. []
The CSL conditional equations are the CSL sentences. We now have to deﬁne the
satisfaction relation for CSL. We have separately deﬁned what CSL structures are
and what CSL conditional equations are. The satisfaction relation connects these two
together so that we can say a CSL conditional equation holds or not in a particular
CSL structure.
Deﬁnition 2.5.2: Let ⟨Γ, ∆, Ψ⟩be a CSL signature. A CSL structure ⟨C, ξ⟩satisﬁes
a CSL conditional equation
e1 = e′
1 ∧. . . ∧en = e′
n ⇒e = e′
having a type
ρ ⊢e1 = e′
1: K1 →L1 ∧. . . ∧en = e′
n: Kn →Ln ⇒e = e′: K →L,
if and only if for any objects A1, . . . , Al and any morphism variable assignment ω we
have either
1. a CSL equation ei = e′
i such that (ξei)A1,...,Al ̸= (ξe′
i)A1,...,Al, or
2. (ξe)A1,...,Al = (ξe′)A1,...,Al.
We will write
⟨C, ξ⟩|= e1 = e′
1 ∧. . . ∧en = e′
n ⇒e = e′
when ⟨C, ξ⟩satisﬁes this CSL conditional equation. []
We have deﬁned the speciﬁcation language, CSL: CSL signatures, CSL structures, CSL
conditional equations and CSL satisfaction relation. We could have deﬁned it as an
institution (see [Goguen and Burstall 83]) by deﬁning CMod as a contravariant functor
and showing CSL satisfaction condition.
Finally, let us ﬁnish presenting the CSL theory (i.e. a pair of CSL signature and CSL
conditional equations) of cartesian closed categories.

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
40
Example 2.5.3: We have presented the signature for cartesian closed categories in ex-
ample 2.2.2 (or ﬁgure 2.1), so all we have to do is to list the CSL conditional equations.
(Note that they are not conditional for this example.)
1.f = !
2.1 = I
3.pair(π1, π2) = I
4.π1 ◦pair(f, g) = f
5.π2 ◦pair(f, g) = g
6.pair(f, g) ◦h = pair(f ◦h, g ◦h)
7.prod(f, g) = pair(f ◦π1, g ◦π2)
8.curry(ev) = I
9.ev ◦curry(prod(f, I)) = f
10.curry(f) ◦g = curry(f ◦prod(g, I))
11.exp(f, g) = curry(g ◦eval ◦prod(f, I))
The naturality of π1, π2 and ev can be derived from these equations. For example, the
naturality of π1 is shown by
π1 ◦prod(f, g) = π1 ◦pair(f ◦π1, g ◦π2) = f ◦π1.
[]
2.6
Free Categories
One of the major advantages of algebraic speciﬁcation methods using equations or
conditional equations over other speciﬁcation methods is that any theory has an initial
model (i.e. the initial object in the category of models which satisfy the theory). This
also holds for CSL, and in this section, we will construct an initial structure for a CSL
theory. Remember that a CSL structure is a pair of a category and an interpretation.
The category of an initial CSL structure corresponds to a so-called free category.
Given a CSL signature ⟨Γ, ∆, Ψ⟩and a set Θ of CSL conditional equations, we are
going to deﬁne a special category C and an interpretation ξ. For simplicity, we assume
that Γ does not contain any free-variant functors. (We can always get such a signature
by discarding free-variant arguments. This does not aﬀect its semantics at all.)
Deﬁnition 2.6.1: We say that a closed functorial expression is ground if it has no
variables, that is, its basic form is λ().E. We take ground closed functorial expressions
as the objects of C. []
The deﬁnition of morphisms of C is a little bit more complicated, so we deﬁne them
step by step.
Deﬁnition 2.6.2: A ground annotated expression is an annotated expression such
that

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
41
1. all the annotation, [K1, . . . , Kn] consists of ground closed functorial expressions,
and
2. it does not contain any morphism variables. []
Proposition 2.6.3: If a ground annotated expression e has a type ρ ⊢e: K →L, and
both K and L are ground functorial expressions.
Proof: We can easily prove it from deﬁnition 2.4.5 by structural induction. []
The following will give us the basis of the morphisms in C.
Deﬁnition 2.6.4: For ground closed functorial expressions K and L, we deﬁne
GExp(K, L) def
= { e | e is ground and ∅⊢e: K →L } []
To make GExp proper morphisms, we introduce a family of equivalence relations ≡
indexed by a pair of ground functorial expressions. Each ≡K,L is an equivalence relation
on GExp(K, L).
Deﬁnition 2.6.5: We deﬁne ≡to be the smallest relation satisfying the following
conditions. (In the following, to simplify the presentation, we omit indexes of ≡if
there is no ambiguity.)
1. ≡is an equivalence relation, that is, reﬂexive, symmetric and transitive.
2. If e1 ≡K,L e′
1 and e2 ≡K′,K e′
2, then e1 ◦e2 ≡K′,L e′
1 ◦e′
2.
3. If e ∈GExp(K, L), then I[L] ◦e ≡e and e ◦I[K] ≡e.
4. For a functor symbol F ∈Γv1...vn, if e1 ≡e′
1, . . . and en ≡e′
n, then F(e1, . . . , en) ≡
F(e′
1, . . . , e′
n).
5. For a factorizer symbol ψ ∈Ψ⟨⟨K′
1,L′
1⟩...⟨K′
l,L′
l⟩,⟨K′,L′⟩⟩and ground functorial expres-
sions K1, . . . , Kn, if e1 ≡e′
1, . . . and el ≡e′
l, then
ψ[K1, . . . , Kn](e1, . . . , el) ≡ψ[K1, . . . , Kn](e′
1, . . . , e′
l).
6. Finally, for a conditional CSL equation e1 = e′
1 ∧. . . ∧en = e′
n ⇒e = e′ ∈Θ
whose type is
ρ ⊢e1 = e′
1: K′
1 →L′
1 ∧. . . ∧en = e′
n: K′
n →L′
n ⇒e = e′: K′ →L′
with ρ(fi) is K′′
i →L′′
i , ground functorial expressions K1, . . . , Km, and ground
annotated expressions
e′′
i ∈GExp(K′′
i [K1, . . . , Km], L′′
i [K1, . . . , Km]),
if for all j = 1, . . . , n
(ej[K1, . . . , Km])[e′′
1, . . . , e′′
l /f1, . . . , fl] ≡
(e′
j[K1, . . . , Km])[e′′
1, . . . , e′′
l /f1, . . . , fl],

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
42
then
(e[K1, . . . , Km])[e′′
1, . . . , e′′
l /f1, . . . , fl] ≡
(e′[K1, . . . , Km])[e′′
1, . . . , e′′
l /f1, . . . , fl]. []
We can now deﬁne the morphisms of C.
Deﬁnition 2.6.1 (continued): The C morphisms from K to L are the equivalence
classes of GExp(K, L) by ≡K,L, or simply,
HomC(K, L) def
= GExp(K, L)/≡K,L.
We write ⟨e⟩for the equivalence class to which e belongs. []
Proposition 2.6.6: C is a category.
Proof: The identity morphism of a C object K is given by ⟨I[K]⟩. The composition
of ⟨e⟩: K →L and ⟨e′⟩: K′ →K is deﬁned by
⟨e⟩◦⟨e′⟩def
= ⟨e ◦e′⟩.
The composition is trivially associative, and the satisﬁability of the absorption rules of
the identities is guaranteed by the third condition of the equivalence relation ≡deﬁned
in deﬁnition 2.6.5. []
Let us deﬁne an interpretation ξ so that ⟨C, ξ⟩is a CSL structure of the CSL signature
⟨Γ, ∆, Ψ⟩.
Deﬁnition 2.6.7: The deﬁnition of ξ is divided into three.
1. For a functor symbol F ∈Γv1...vn, ξF is a functor Cv1...vn →C deﬁned by
ξF(K1, . . . , Kn) def
= F[K1, . . . , Kn)],
and
ξF(⟨e1⟩, . . . , ⟨en⟩) def
= ⟨F(e1, . . . , en)⟩.
2. For a natural transformation symbol α ∈∆K,L, ξα is
ξαK1,...,Kn
def
= ⟨α[K1, . . . , Kn]⟩.
3. Finally, for a factorizer symbol ψ ∈Ψ⟨⟨K1,L1⟩...⟨Kn,Ln⟩,⟨K,L⟩⟩, ξψ is
ξψK′
1,...,K′n(⟨e1⟩, . . . , ⟨en⟩) def
= ⟨ψ[K′
1, . . . , K′
n](e1, . . . , en)⟩. []
Proposition 2.6.8: ⟨C, ξ⟩is a CSL structure of ⟨Γ, ∆, Ψ⟩. Moreover, it is a theory
structure of the CSL theory given by the set Θ of CSL conditional equations.
Proof: The condition 6 in deﬁnition 2.6.5 makes it satisfy the conditional equations. []

CHAPTER 2. CATEGORICAL SPECIFICATION LANGUAGE
43
We have constructed a special CSL structure ⟨C, ξ⟩, and we will next show that it
is the initial object in the full-subcategory of CMod(⟨Γ, ∆, Ψ⟩) of all the structures
satisfying Θ.
Theorem 2.6.9: For any CSL structure satisfying Θ, there is a unique CSL structure
morphism from ⟨C, ξ⟩.
Proof: Let ⟨D, ζ⟩be an arbitrary CSL structure satisfying Θ. Using the denotation
of annotated expressions on this structure (see deﬁnition 2.4.10), we deﬁne a functor
T from C to D as follows:
T(K) def
= ζK
and
T(⟨e⟩) def
= ζe.
Note that, since K is a ground functorial expression ζK is an D object, and that,
since e is a ground annotated expression, ζe is a D morphism (it does not need objects
A1, . . . , Am or a morphism variable assignment ω). It is easy to see that T is a (co-
variant) functor (note that we have to show the well-deﬁnedness ﬁrst). It is also not
so diﬃcult to show that T is a CSL structure morphism and that it is the unique one
from ⟨C, ξ⟩to ⟨D, ζ⟩(simply extending the result on algebraic speciﬁcations). []
The advantage of working in an initial CSL structure is that, if we show that a con-
ditional equation holds in the initial one, then we automatically know that it holds in
any CSL structure. In chapter 4, we will deﬁne the symbolic computation in categories
and it can be regarded as the computation in free categories.

Chapter 3
Categorical Data Types
In chapter 2, we introduced categorical data types from a point of view of a speciﬁcation
language deﬁning categories. Although the speciﬁcation language CSL is a rigorous
language, it is rather tedious and categoritians may never deﬁne categories in that way.
In this chapter, we will give another presentation of categorical data types, which will
be simpler and more intuitive. This is also the way Categorical Data Types originated.
Note that we are not discarding CSL completely and that the semantics of categorical
data types will be given in terms of CSL.
Section 3.1 is an extended introduction to categorical data types. We will investigate
some conventional data types and introduce a new uniform categorical way of deﬁning
data types.
In section 3.2, we will make this new way into the CDT declaration
mechanism. Section 3.3 will give various examples of CDT declarations. In section 3.4,
CDT declarations will be connected to CSL theories, and ﬁnally in section 3.5 we will
give a construction of CDT data types.
3.1
What are Categorical Data Types?
The need for pairs of two (or more) items of data often arises when we write programs.
It is often the case that a function or procedure takes more than one argument and this
means that a pair (or a record) of data needs to be passed to the function or procedure.
In another situation, we may want to declare a new data type whose element is a pair
of elements of other data types. In PASCAL, we can deﬁne such data types using its
record . . . end construct. For example, intchar whose element is a pair of an integer
and a character can be declared as:
type intchar = record
first: integer;
second: char
end;
In ML, this can be done by
44

CHAPTER 3. CATEGORICAL DATA TYPES
45
type intchar = int * string;
(where since ML does not have a type for representing characters, we have to use
‘string’ type whose element is a sequence of characters). These two languages have
the means of constructing data types of pairs from already-existing data types. Let
us call the constructors product type constructors. Most of the current programming
languages have product type constructors in one way or another as their built-in primi-
tives because they are so essential that we can even say that no programming language
is complete without them.
In order to understand the nature of product type constructors, let us suppose a pro-
gramming language which does not have them as primitives and that we have to deﬁne
them in terms of others. This might mean that we need in the language some kind
of one level higher operations which can deﬁne not types but type constructors. Let
us refer to an algebraic speciﬁcation language CLEAR,1 and see its ability to deﬁne a
product type constructor.
constant Triv =
theory
sort element
endth
procedure Prod(A:Triv,B:Triv) =
theory
data sort prod
opns pair: element of A,element of B -> prod
pi1 : prod -> element of A
pi2 : prod -> element of B
eqns all a:element of A,b:element of B,
pi1(pair(a,b)) = a
all a:element of A,b:element of B,
pi2(pair(a,b)) = b
endth
This deﬁnes an algebra P of three sorts: two ‘element’ sorts (let us call them ‘A-element’
and ‘B-element’ to distinguish them) and a ‘prod’ sort. The underlying set |P|prod is
the (set) product of two sets |P|A−element and |P|B−element. The declaration also deﬁnes
three operations (or functions), ‘pair’, ‘pi1’ and ‘pi2’, satisfying the two equations
listed. Note that the following equation can be proved using induction on ‘prod’ sort
(we have the induction principle on this sort because of the initial data constraint).
all x: prod, pair(pi1(x),pi2(x)) = x
An algebraic speciﬁcation language like CLEAR is powerful enough to allow us to
deﬁne all kinds of type constructors (including ordinary data types as constant type
constructors) in a uniform way without having any particular primitives. However,
1CLEAR can be institution independent, but here we refer the one that uses the equational algebraic
institution.

CHAPTER 3. CATEGORICAL DATA TYPES
46
because of its use of equations, we cannot adopt its declaration mechanism in ordinary
programming languages.2 We might be puzzled that we need equations even to deﬁne
such very basic data types as products.
Let us ﬁnd whether there is any other ways of deﬁning product type constructors by
examining the foundation, namely mathematics. Modern mathematics uses set theory
extensively because of its power. Set theory does not have a product type constructor
as its primitive construct either, so it is deﬁned by means of other constructs. For sets
A and B, their (set) product is deﬁned as:
A × B def
= { (x, y) | x ∈A, y ∈B }
where (x, y) is really an abbreviation of {{x} {x y}}. Although this looks very simple,
it actually needs some work to show from the axioms of set theory that this is actually
a set. Set theory uses the power of ﬁrst order logic so heavily that it is much harder to
put the set theory formalism into a programming language than to put the algebraic
speciﬁcation formalism. As an example, let φ(x) be a ﬁrst order formula. Then, from
the comprehension axiom (or the replacement axiom), we have the set
{ x ∈A | φ(x) }
where A is a set. φ(x) can be anything expressible by ﬁrst order logic (using quantiﬁers
and negations), and this is too much powerful to investigate the basic property of data
types.
It disﬁgures the beauty behind this powerful deﬁnition mechanism and we
cannot see through it easily.
Set theory has achieved a ﬁrm position as the foundation of mathematics, but there are
some alternatives. Category theory is one of them. It has been proved that category
theory has a remarkable ability to disclose true nature of mathematical objects. For
example, a product constructor (or categorically a functor C × C →C) is beautifully
characterized as the right adjoint of the diagonal functor C →C × C.3 Expanding the
deﬁnition of adjunctions, this means that we have the following natural isomorphism:
HomC(C, A) × HomC(C, B) ≃HomC(C, prod(A, B))
(∗)
(natural in A, B and C). We use ‘prod’ for the product functor to follow the notation
we use later. The isomorphic function from the left-hand side to the right-hand side is
the factorizer of this adjunction and we write ‘pair’ for it. We can rewrite this adjoint
situation as the following rule:
C
f
−→A
C
g
−→B
C
pair(f,g)
−−−−−→prod(A, B)
(∗∗)
Given two morphisms f: C →A and g: C →B, pair(f, g) give a morphism of C →
prod(A, B). This correspondence is one-to-one and is natural in A, B and C.
2There is a programming language OBJ [Goguen and Tardo 79] which treats equations as a kind of
programs (as rewrite rules).
3There may be more than one right adjoint of the diagonal functor, but they are isomorphic. Therefore,
we say ‘the’ right adjoint rather than ‘a’ right adjoint.

CHAPTER 3. CATEGORICAL DATA TYPES
47
Comparing with the product type constructor ‘Prod’ deﬁned by CLEAR, we have the
same ‘pair’ though the previous one takes two elements as the arguments and this one
takes two morphisms instead, and now we can ﬁnd the things corresponding to two
projections ‘pi1’ and ‘pi2’ as well. Replacing C by prod(A, B) in (∗), we get:
HomC(prod(A, B), A) × HomC(prod(A, B), B) ≃
HomC(prod(A, B), prod(A, B)).
We have a very special morphism in HomC(prod(A, B), prod(A, B)), namely the iden-
tity. Because of the isomorphism, there exist unique morphisms of prod(A, B) →A
and prod(A, B) →B which are mapped to the identity by ‘pair’, and these are the
projections. We name them ‘pi1’ and ‘pi2’ as well. Because of the very way they are
deﬁned, it is trivial that
pair(pi1, pi2) = I.
(+)
Furthermore, from the naturality in C of (∗), we have the rule
C
pair(f,g)
−−−−−→prod(A, B)
pi1
−−→A
C
pair(f,g)
−−−−−→prod(A, B)
pi2
−−→B
C
pair(f,g)
−−−−−→prod(A, B)
pair(pi1,pi2)
−−−−−−−−→prod(A, B)
,
and, if we express it by equations and use (+),
pair(pi1 ◦pair(f, g), pi2 ◦pair(f, g)) = pair(pi1, pi2) ◦pair(f, g) = pair(f, g).
Since ‘pair’ is isomorphic, we can conclude that the following equations hold:
pi1 ◦pair(f, g) = f
and
pi2 ◦pair(f, g) = g.
These are exactly the ones which we listed when deﬁning ‘Prod’ in CLEAR. Note that
this time they are derived equations. By saying that ‘prod’ is the right adjoint to
the diagonal functor, we get these equations automatically. This shows how neat the
categorical deﬁnition is.
Another advantage of categorical deﬁnition is that we can form the dual deﬁnition
easily. We deﬁned the product functor as the right adjoint of the diagonal functor.
Then, it is natural to ask what is the left adjoint of the diagonal functor. It is the
coproduct functor C × C →C. In the category of sets, the copoduct of two sets A and
B is their disjoint sum
A + B def
= { 0 } × A
[
{ 1 } × B.
It is not easy to see in set theory that this is the dual of A × B. In PASCAL, we
can deﬁne coproducts by means of variant record. In ML, we used to have a built-in
coproduct type constructor ‘+’, but the new Standard ML does not. Instead, ‘+’ can
be deﬁned by the following ‘datatype’ declaration.
datatype ’a + ’b = in1 of ’a | in2 of ’b;

CHAPTER 3. CATEGORICAL DATA TYPES
48
We cannot deﬁne the product type constructor by a ‘datatype’ declaration in ML, but
we can deﬁne its dual. ML looks non-symmetric from this. In CLEAR, we can deﬁne
a coproduct type constructor as follows:
Procedure CoProd(A:Triv,B:Triv) =
theory
data sort coprod
opns in1: element of A -> coprod
in2: element of B -> coprod
endth
Again, this cannot be seen as the dual of ‘Prod’ we deﬁned earlier; here we do not
use equations; we have only two operations whereas we had three. This shows that
CLEAR is not symmetric either.
Now, in category theory, the coproduct functor C × C →C which we call ‘coprod’ is
deﬁned by the dual of (∗), by just changing the direction of arrows.
HomC(A, C) × HomC(B, C) ≃HomC(coprod(A, B), C)
We name the isomorphic function going from the left-hand side to the right-hand side
‘case’ (we could call it ‘copair’ to emphasize the duality to ‘pair’, but, since it plays
a role of ‘case’ statements of ML or C (or PASCAL), we call it ‘case’). Writing the
adjunction as a rule,
A
f
−→C
B
g
−→C
coprod(A, B)
case(f,g)
−−−−−−→C
.
Two injections in1: A →coprod(A, B) and in2: B →coprod(A, B) are deﬁned as the
morphisms which ‘case’ maps to the identity of coprod(A, B). As before, we can derive
some equations easily.
From what we have looked at, it seems a good idea to design a category theory based
(programming or speciﬁcation) language which has the ability to deﬁne functors by
means of adjunctions. Since it is convenient to introduce names for unit natural trans-
formations and factorizers at the same time, we regard an adjunction as a triple of a
functor, a unit natural transformation and a factorizer (see, for example, [Mac Lane
71] for many equivalent ways of deﬁning adjunctions). Therefore, a category theory
based language may have the following two forms of declaring new functors:
let ⟨F, α, ψ⟩be right adjoint of G
let ⟨F, α, ψ⟩be left adjoint of G
where G is a functor we already have, F is the new functor we are deﬁning, α is the
associated unit natural transformation and ψ is the associated factorizer. One problem
is that we need to have some primitive functors with which we start. We deﬁnitely
need diagonal functors for we want to deﬁne product and coproduct functors. In order
to deﬁne the natural number object (which is a constant functor), we need a pretty
complicated functor G. The problem is how to represent such G.

CHAPTER 3. CATEGORICAL DATA TYPES
49
Let us investigate how other languages and theories deﬁne the data type of natural
numbers. In set theory, it has the axiom of inﬁnity which says the existence of natural
numbers. This may look rather artiﬁcial. In PASCAL, there is no intuitively easy way
to deﬁne it. In ML, though it is a built-in data type for eﬃciency, we could deﬁne it
as:
datatype nat = zero | succ of nat;
Note the recursiveness in this deﬁnition. Essentially, we need some kind of recursiveness
to deﬁne a data type of natural numbers. In CLEAR, one can deﬁne it as
constant Nat =
theory
data sort nat
opns zero: nat
succ: nat -> nat
endth
This is very much similar to the one in ML, though we often think that the CLEAR
deﬁnition is based on the initial algebra semantics whereas the ML deﬁnition is based
on domain theory. In domain theory, a data type of natural numbers can be deﬁned
as the solution of the following domain equation
N ∼= 1 + N.
(∗)
The initial solution of (∗) can be calculated as a colimit of a sequence of domains, but
we do not go into its detail here. As a connection to the initial algebra semantics,
the initial solution can be characterized as the initial T-algebra, where T is a functor
T(X) def
= 1 + X in this case. In general, given a category and an endo-functor T, we
can form a category of T-algebras.
Deﬁnition 3.1.1: For a category C and an endo-functor T: C →C, the category of
T-algebras is deﬁned
1. its objects are pairs ⟨A, f⟩where A is a C object and f is a C morphism T(A) →A,
and
2. its morphisms h: ⟨A, f⟩→⟨B, g⟩are C morphisms h: A →B which make the
following diagram commute.
T(A)
f
A
-
T(h)
¥
¨§?
h
?
?
T(B)
g
- B
Note that this is a weaker version of the category of T-algebras deﬁned in many category
theory books (e.g. [Mac Lane 71]) where T needs to be a monad. []

CHAPTER 3. CATEGORICAL DATA TYPES
50
We can dualize deﬁnition 3.1.1 to deﬁne T-coalgebras. However, in the theory of cate-
gorical data types (‘CDT theory’ for short), we combine the two deﬁnitions together.
Deﬁnition 3.1.2: Let C and D be categories and both F and G be functors from C
to D. We deﬁne an F, G-dialgebra4 as
1. its objects are pairs ⟨A, f⟩where A is a C object and f is a D morphism of
F(A) →G(A), and
2. its morphisms h: ⟨A, f⟩→⟨B, g⟩are C morphisms h: A →B such that the
following diagram commutes.
F(A)
f
G(A)
-
F(h)
¥
¨§?
G(h)
?
?
F(B)
g
-G(B)
In the case where F or G is contravariant, we have to modify the direction of
some arrows.
It is easy to show that it is a category; let us write DAlg(F, G) for it. Note that
DAlg(T, I) is the category of T-algebras and DAlg(I, T) is the category of T-coalgebras. []
This is a very simple extension of deﬁnition 3.1.1, yet its symmetry and dividing the
source category from the target one give us greater freedom. With T-algebras, we
need to use the coproduct functor to deﬁne the domain of natural numbers, but by
F, G-dialgebra we do not. Let C be any category and D be its product C × C. We
deﬁne the functors F and G as
F(A) def
= ⟨1, A⟩
and
G(A) def
= ⟨A, A⟩.
Let ⟨nat, ⟨zero, succ⟩⟩be the initial F, G-dialgebra. From the deﬁnition, ‘nat’ is a C
object, ‘zero’ is a C morphism of 1 →nat and ‘succ’ is a C morphism of nat →nat.
The initiality means that for any DAlg(F, G) object ⟨A, ⟨f, g⟩⟩there exists a unique
DAlg(F, G) morphism h: ⟨nat, ⟨zero, succ⟩⟩→⟨A, ⟨f, g⟩⟩. If we spell out the deﬁnition,
this means that for any C object A and any C morphisms f: 1 →A and g: A →A there
exists a unique C morphism h: nat →A which makes the following diagram commute.
1
zero
nat
succ
nat
f
¥
¨§?
h
¥
¨§?
h
A
A
g
-
-
@
@
@
@
@
@
@
@
R
-
?
?
4The name dialgebra was suggested by Bob McKay.

CHAPTER 3. CATEGORICAL DATA TYPES
51
This is exactly the deﬁnition of ‘nat’ being a natural number object in category theory.
To get further generality of F, G-dialgebras, we parametrize F and G.
Deﬁnition 3.1.3: Let C, D and E be categories, and let F: C×D →E and G: C×D−→
E be functors. We deﬁne ⟨Left[F, G](A), ηA⟩for a D object A to be the initial object
in the category DAlg(F( · , A), G( · , A)). Dually, we deﬁne ⟨Right[F, G](A), ϵA⟩
to be the ﬁnal object. We may write Right(A) for Right[F, G](A) and Left(A) for
Left[F, G](A) if the context makes F and G clear. []
Proposition 3.1.4: If Left[F, G](A) exists for every object A ∈|D|, Left[F, G] de-
notes a functor D →C (i.e. we can extend it to D morphisms). Dually, if Right[F, G](A)
exists for every A ∈|D|, Right[F, G] denotes a functor D−→C.
Proof: We ﬁrst need to deﬁne what Left[F, G](f) is for a D morphism f: A →B. We
deﬁne it as the morphism h: Left(A) →Left(B) which ﬁlls in the following diagram.
F(Left(A), A)
ηA
G(Left(A), A)
⟨Left(A), ηA⟩
F(h, I)
G(h, I)
h
F(Left(B), A)
G(Left(B), A)
⟨Left(B), G(I, f) ◦ηB ◦F(I, f)⟩
F(I, f)
G(I, f)
F(Left(B), B)
ηB
G(Left(B), B)
-
?
?
?
?
6
-
The unique existence of the morphism is provided because ⟨Left(A), ηA⟩is the initial
object of DAlg(F( · , A), G( · , A)). In other words, Left(f) is the unique morphism
which satisﬁes
G(Left(f), f) ◦ηB ◦F(Left(f), f) = ηA.
Let us check that Left is in fact a functor. Trivially,
G(I, I) ◦ηA ◦F(I, I) = ηA.
Therefore, Left(IA) = ILeft(A). For morphisms f: A →B and g: B →C,
G(Left(g) ◦Left(f), g ◦f) ◦ηC ◦F(Left(g) ◦Left(f), g ◦f)
= G(Left(f), f) ◦G(Left(g), g) ◦ηC ◦F(Left(g), g) ◦F(Left(f), f)
= G(Left(f), f) ◦ηB ◦F(Left(f), f)
= ηA

CHAPTER 3. CATEGORICAL DATA TYPES
52
Therefore, Left(g) ◦Left(f) = Left(g ◦f).
F(Left(A), A)
G(Left(A), A)
F(Left(B), B)
G(Left(B), B)
F(Left(C), C)
G(Left(C), C)
ηA
ηB
ηC
F(Left(f), f)
G(Left(f), f)
F(Left(g), g)
G(Left(g), g)
F(Left(g ◦f), g ◦f)
G(Left(g ◦f), g ◦f)
-
-
-
?
?
?
?
-

Dually, we can prove that Right is a functor. []
‘Left’ and ‘Right’ may suggest a connection with left and right adjoint functors. In
fact,
Proposition 3.1.5: For a functor F: C →D, its left adjoint functor can be denoted
by
Left[λ(X, Y ).Y, λ(X, Y ).F(X)]
and, dually, its right adjoint functor can be denoted by
Right[λ(X, Y ).F(X), λ(X, Y ).Y ].
Proof: Let us only check the left adjoint case. We see λ(X, Y ).Y as a functor C ×D →
D and λ(X, Y ).F(X) as a functor C×D−→D. From deﬁnition 3.1.3, Left is a functor
D →C. If we spell out the condition of ⟨Left(A), ηA⟩being the initial algebra, it
means that for any C object B and a C morphism f: A →F(B) there exists a unique
C morphism h: Left(A) →B such that the following diagram commutes.
A
ηA
F(Left(A))
Left(A)
A
F(B)
B
f
¥
¨§?
F(h)
h
-
-
?
?
This is exactly the condition of Left being the left adjoint functor of F. Dually, we
can prove that Right[λ(X, Y ).F(X), λ(X, Y ).Y ] is the right adjoint. []
Hence, deﬁnition 3.1.2 of F, G-dialgebras covers both T-algebras and adjoints so that
it enables us to deﬁne products, coproducts, natural number object, and so on in a
uniform way.

CHAPTER 3. CATEGORICAL DATA TYPES
53
3.2
Data Type Declarations in
Categorical Data Types
In the previous section, we have looked at some ways of deﬁning data types in some
languages. In this section, we will introduce how to deﬁne data types in CDT.
If we were only interested in functors, only Left[F, G] and Right[F, G] deﬁned in the
previous section would be needed, but we do want morphisms (or natural transforma-
tions) and factorizers which will make up some kind of programs, the meaning of which
we will examine in chapter 4 (e.g. how to execute them).
Left[F, G] and Right[F, G] have been deﬁned for functors F: C × D →E and G: C ×
D−→E, where C, D and E are some categories. Remember the aim of CDT; we
would like to deﬁne (or specify, or study) a category of data types. Therefore, C, D
and E should somehow be related to this category. The simplest we can think of is that
they are the product categories of this category and all the functors are in the form of
Cs →C, where s is a sequence of variances (i.e. s ∈Var∗) and Cv1...vn def
= Cv1 ×· · ·×Cvn.
In order to simplify the presentation, let us use the vector notation and write, for
example, ⃗F for a sequence of functors ⟨F1, . . . , Fn⟩where all of them have the same
type Cs →C, that is, ⃗F is a functor of Cs →Cn.
From deﬁnition 3.1.3, for ⃗F: C ×Cs →Cn and ⃗G: C ×C−•s →Cn, Left[F, G] is a functor
Cs →C and Right[F, G] is a functor C−•s →C, where u • v1 . . . vn
def
= u • v1 . . . u • vn.
Hence, we come to the deﬁnition of CDT declarations.
Deﬁnition 3.2.1: In CDT theory, there are two forms of declaring new functors. One
is to deﬁne a functor L: Cs →C by
left object L( ⃗X) with ψ is
⃗α: ⃗F(L, ⃗X) →⃗G(L, ⃗X)
end object
(∗)
and the other is to deﬁne a functor R: C−•s →C by
right object R( ⃗X) with ψ is
⃗α: ⃗F(R, ⃗X) →⃗G(R, ⃗X)
end object
where ⃗X is a sequence ⟨X1, . . . , Xn⟩of variables, ψ is the associated factorizer, ⃗α is
a sequence ⟨α1, . . . , αm⟩of the associated natural transformations, and ⃗F and ⃗G are
sequences ⟨F1, . . . , Fm⟩and ⟨G1, . . . , Gm⟩, respectively, of functors which we have as
primitives or we have already deﬁned and whose type is Fi: C × Cs →C and Gi: C ×
C−•s →C, respectively. Semantically, L is Left[⃗F, ⃗G] and R is Right[⃗F, ⃗G]. We may
call L left functor or left object and R right functor or right object. []

CHAPTER 3. CATEGORICAL DATA TYPES
54
If we expand the deﬁnition of Left, (∗) deﬁnes for any C objects ⃗A = ⟨A1, . . . , An⟩an
object L( ⃗A) and a morphism
⃗F(L( ⃗A), ⃗A)
-
⃗α ⃗A
⃗G(L( ⃗A), ⃗A),
and for any object B and a sequence of morphisms ⃗f: ⃗F(B, ⃗A) →⃗G(B, ⃗A), ψ(⃗f) denotes
the unique morphism which makes the following diagram commute.
⃗F(L( ⃗A), ⃗A)
⃗α ⃗A
⃗G(L( ⃗A), ⃗A)
L( ⃗A)
⃗F(ψ(⃗f), ⃗A)
¥
¨§?
⃗G(ψ(⃗f), ⃗A)
ψ(⃗f)
⃗F(B, ⃗A)
⃗f
⃗G(B, ⃗A)
B
-
-
?
?
?
In deﬁnition 3.2.1, it is not immediately clear what kind of ⃗F and ⃗G is allowed. We
vaguely stated that they are primitive or have been deﬁned already. In order to clarify
this point, we go back to CSL and regard a CDT declaration as an extension of a given
CSL signature.
Deﬁnition 3.2.2: Let ⟨Γ, ∆, Ψ⟩be a CSL signature. A CDT declaration D ∈Decl
is given by the following BNF expression.
D : : = { left | right } object F(X1, . . . , Xn) with ψ is
α1: E1 →E′
1
. . .
αm: Em →E′
m
end object
where F is a new functor symbol, ψ is a new factorizer symbol, α1, . . . , am are new
natural transformation symbols, and Ei and E′
i (i = 1, . . . , m) are well-formed functo-
rial expressions (under this signature ⟨Γ, ∆, Ψ⟩) whose variables are X1, . . . , Xn and F
(here we use F as a formal parameter like we use its function name inside a function
body in PASCAL). []
We need to put restriction on the variance of F in the functorial expressions such that
for each i = 1, . . . , m
1. the variance of F in Ei should be either covariant or free,
2. the variance of F in E′
i should also be either covariant or free, and
3. either the variance of F in Ei should be covariant or that in E′
i should be covariant.
We could have allowed F to be contravariant (as indeed the original deﬁnition of CDT
did), but it turned out that the generality by contravariance was of very little use,

CHAPTER 3. CATEGORICAL DATA TYPES
55
so, because it simpliﬁes the following argument, we restrict ourselves only to covariant
functors. The third condition above is to make the extension consistent (each αi should
somehow relate to the functor we are declaring).
Let us calculate the variance of F. If the variance of λ(F, X1, . . . , Xn).Ei is visi (vi ∈
Var for the variance of F and si ∈Var∗for the variance of X1, . . . , Xn) and that of
λ(F, X1, . . . , Xn).E′
i is v′
is′
i, λ(F, X1, . . . , Xn).Ei denotes a functor Cvi × Csi →C and
λ(F, X1, . . . , Xn).E′
i denotes a functor Cv′
i × Cs′
i →C. The restriction above states that
vi ⊔v′
i = +. From proposition 3.1.4, the variance of F in case that it is declared by a
left CDT declaration should be
m
G
i=1
si ⊔−• s′
i,
(∗)
and in case that it is declared by a right one, the variance should be
m
G
i=1
−• si ⊔s′
i,
(∗∗)
where Var∗is a partially ordered set with the ordering given by u1 . . . un ⊑v1 . . . vn if
and only if u1 ⊑v1, . . . and un ⊑vn.
Deﬁnition 3.2.2 (continued): A CDT declaration gives an extension of CSL signa-
ture.
⟨Γ, ∆, Ψ⟩,→⟨Γ ∪{ F }, ∆∪{ α1, . . . , αm }, Ψ ∪{ ψ }⟩
where the variance of F is given by (∗) or (∗∗), the type of αi is
λ(X1, . . . , Xn).Ei[F(X1, . . . , Xn)/F]
·→λ(X1, . . . , Xn).E′
i[F(X1, . . . , Xn)/F],
and the type of ψ is
fi: λ(X, X1, . . . , Xn).Ei[X/F] →λ(X, X1, . . . , Xn).E′
i[X/F]
(i = 1, . . . , m)
ψ(f1, . . . , fm): λ(X, X1, . . . , Xn).F(X1, . . . , Xn) →λ(X, X1, . . . , Xn).X
by a left CDT declaration and
fi: λ(X, X1, . . . , Xn).Ei[X/F] →λ(X, X1, . . . , Xn).E′
i[X/F]
(i = 1, . . . , m)
ψ(f1, . . . , fm): λ(X, X1, . . . , Xn).X →λ(X, X1, . . . , Xn).F(X1, . . . , Xn)
by a right one. []
We will see in section 3.4 a CDT declaration as a CSL theory extension so that the
semantics of a CDT declaration can be given by a CSL structure.

CHAPTER 3. CATEGORICAL DATA TYPES
56
3.3
Examples of Categorical Data Types
In this section, we will present several examples of categorical data types declared by
left object F(X1, . . . , Xn) with ψ is
α1: E1 →E′
1
. . .
αm: Em →E′
m
end object
(∗)
for left objects and by
right object F(X1, . . . , Xn) with ψ is
α1: E1 →E′
1
. . .
αm: Em →E′
m
end object
(∗∗)
for right objects.
3.3.1
Terminal and Initial Objects
Let us start with an empty CSL signature ⟨∅, ∅, ∅⟩. The simplest case of (∗) and (∗∗)
is when n = m = 0. If we consider the case when n = m = 0 in (∗∗), we get the
declaration of the terminal object.
right object 1 with !
end object
(We omitted the keyword ‘is’ to make the declaration look nicer.) From the deﬁnition,
this deﬁnes an object ‘1’ and for any object A there is a unique morphism ‘!’ from A
to ‘1’.
A
-
!
1
Therefore, it really is the terminal object.
Dually, if we change the keyword ‘right’ to ‘left’ in the deﬁnition of the terminal object,
we get the deﬁnition of the initial object.
left object 0 with !!
end object
The factorizer ‘!!’ gives a unique morphism from ‘0’ to any object A.
0
-
!!
A

CHAPTER 3. CATEGORICAL DATA TYPES
57
3.3.2
Products and CoProducts
Next, we deﬁne products and coproducts. The binary product functor can be declared
as the following right object.
right object prod(X, Y ) with pair is
pi1: prod →X
pi2: prod →Y
end object
From deﬁnition 3.2.2, this deﬁnes a functor symbol ‘prod’ whose variance is ‘++’ (i.e.
covariant in both arguments), two natural transformation symbols ‘pi1’ and ‘pi2’ whose
types are
pi1: λ(X, Y ).prod(X, Y )
·→λ(X, Y ).X
pi2: λ(X, Y ).prod(X, Y )
·→λ(X, Y ).Y
and a factorizer symbol ‘pair’ whose type is
f: λ(Z, X, Y ).Z →λ(Z, X, Y ).X
g: λ(Z, X, Y ).Z →λ(Z, X, Y ).Y
pair(f, g): λ(Z, X, Y ).Z →λ(Z, X, Y ).prod(X, Y )
.
If we write this down in a more understandable way, it becomes the familiar deﬁnition
of the binary product, that is ‘prod’ has two unit morphisms
A
prod(A, B)
B
pi1
pi2

-
and pair(f, g) gives the unique morphism for any morphisms f: C →A and g: C →B
such that the following diagram commutes.
A
prod(A, B)
B
pi1
pi2

-
C
f
g
pair(f, g)
¥
¨§?
¥
¨§?
@
@
@
@
@
@
@
@
I
¡
¡
¡
¡
¡
¡
¡
¡

6
Note that the CDT declaration of the binary product functor is very similar to the
‘Prod’ theory in CLEAR deﬁned in 3.1. One of the diﬀerences is that in CLEAR ‘pair’
is treated as a function in the same class as ‘pi1’ and ‘pi2’ but in CDT ‘pair’ is quite
diﬀerent from ‘pi1’ and ‘pi2’. Another one is that in CLEAR ‘Prod’ is declared as the
initial algebra so it is close to CDT’s left object but in CDT ‘prod’ is naturally a right
object because the product functor is the right adjoint of the diagonal functor.

CHAPTER 3. CATEGORICAL DATA TYPES
58
Dually, we can deﬁne the binary coproduct functor as a left object.
left object coprod(X, Y ) with case is
in1: X →coprod
in2: Y →coprod
end object
Again, this declaration looks very close to the one in CLEAR (deﬁned in section 3.1),
but note that we have ‘case’ in CDT so that we can use it to write programs or to
specify some properties.
Just writing the situation as a diagram,
A
coprod(A, B)
B
in1
in2
-

C
f
g
case(f, g)
¥
¨§?
¥
¨§?
@
@
@
@
@
@
@
@
R
¡
¡
¡
¡
¡
¡
¡
¡
ª
?
3.3.3
Exponentials
One of the objections against algebraic speciﬁcation methods is that it cannot handle
function spaces. CDT’s declaration mechanism looks very close to that of algebraic
speciﬁcation methods, but CDT is based on category theory not on many-sorted alge-
bras, and in category theory function spaces can be deﬁned as exponentials. For objects
A and B, the exponential of B by A is written as exp(A, B)5 satisﬁes the following
natural isomorphism.
HomC(prod(C, A), B) ≃HomC(C, exp(A, B))
In other words, The functor exp(A, · ) is the right adjoint of prod( · , A). We write
‘curry’ for the factorizer and ‘eval’ for the counit natural transformation. Then, for
any object C and any morphism f: prod(C, A) →B, curry(f) is the unique morphism
from exp(A, B) to C such that the following diagram commutes.
C
exp(A, B)
curry(f)
?
prod(C, A)
prod(exp(A, B), A)
B
prod(curry(f), I)
f
¥
¨§?
eval
ZZZZZZZZZZ
~
-
?
5Many category theory books use the notation BA for the exponential of B by A.

CHAPTER 3. CATEGORICAL DATA TYPES
59
The reason why the exponentials are function spaces is that their global elements are
just morphisms.6
HomC(1, exp(A, B)) ≃HomC(prod(1, A), B) ≃HomC(A, B)
Let us write down the deﬁnition as a CDT declaration.
Assume a CSL signature
⟨Γ, ∆, Ψ⟩which contains the deﬁnition of the binary product functor as we deﬁned in
subsection 3.3.2. Then, the exponential functor can be declared as follows.
right object exp(X, Y ) with curry is
eval: prod(exp, X) →Y
end object
This is so far the most complicated CDT declaration. In the previous examples, functo-
rial expressions Ei and E′
i in (∗) and (∗∗) are all simply variables. From deﬁnition 3.2.2,
the CDT declaration above deﬁnes a functor symbol ‘exp’ of type −+, a natural trans-
formation ‘eval’ of type
λ(X, Y ).prod(exp(X, Y ), X)
·→λ(X, Y ).Y
and a factorizer ‘curry’ of type
f: λ(Z, X, Y ).prod(Z, X) →λ(Z, X, Y ).Y
curry(f): λ(Z, X, Y ).Z →λ(Z, X, Y ).exp(X, Y )
.
These types are what we expect them to be from the exponential adjunction. Let us
once more convince ourselves that the semantics by F, G-dialgebras really deﬁnes the
exponentials. ⟨exp(A, B), evalA,B⟩is the ﬁnal F, G-dialgebra where F(C) def
= prod(C, A)
and G(C) def
= B. This means that, for any ⟨C, f⟩where C is an object and f is a
morphism of F(C) →G(C), curry(f) is the unique morphism of
⟨exp(A, B), evalA,B⟩→⟨C, f⟩.
From deﬁnition 3.1.2 of F, G-dialgebras, curry(f) is the unique morphism C →exp(A, B)
which makes the following diagram commute.
F(C) = prod(C, A)
B = G(C)
f
F(exp(A, B)) = prod(exp(A, B), A)
B = G(exp(A, B))
evalA,B
F(curry(f)) = prod(curry(f), I)
¥
¨§?
I = G(curry(f))
-
-
?
This is exactly the condition of ‘exp’ being the exponential functor.
6A global element of an object A is a morphism from the terminal object to A.

CHAPTER 3. CATEGORICAL DATA TYPES
60
The declaration of the exponential functor in CDT very much looks like a declaration
in a algebraic speciﬁcation language (e.g. in CLEAR), but, as is well-known, we cannot
deﬁne function spaces as algebras. The essential diﬀerence lies in that ‘exp’ is a right
object, in other words, deﬁned by the terminal data constraint rather than the initial
one which CLEAR uses and in the availability of the factorizer ‘curry’. If we deﬁne
‘curry’ as an ordinary function (or an ML function), its type is
(C × A →B) →(C →(A →B))
and this could never be a type of algebraic functions (i.e. functions deﬁned by algebraic
speciﬁcation methods).
3.3.4
Natural Number Object
As we have already shown that the natural number object can be given by ‘Left’, let
us write it down as a CDT declaration. Although we can deﬁne the natural number
object if we have only the terminal object, it is often very convenient to assume that
a CSL signature ⟨Γ, ∆, Ψ⟩contains not only the terminal object but also the product
functor and the exponential functor. The declaration of the natural number object as
a CDT is
left object nat with pr is
zero: 1 →nat
succ: nat →nat
end object
which deﬁnes a constant functor (i.e. an object) ‘nat’ with two morphisms ‘zero’ and
‘succ’.
1
nat
zero
succ
-


6
In addition, the factorizer ‘pr’ (standing for primitive recursion) gives for any mor-
phisms f: 1 →A and g: A →A a unique morphism pr(f, g): nat →A such that the
following diagram commutes.
1
zero
nat
succ
nat
f
¥
¨§?
pr(f, g)
¥
¨§?
pr(f, g)
A
A
g
-
-
@
@
@
@
@
@
@
@
R
-
?
?
As is well-known (e.g. [Goldblatt 79] chapter 13), ‘pr’ provides us to deﬁne any primitive
recursive function.

CHAPTER 3. CATEGORICAL DATA TYPES
61
Deﬁnition 3.3.1: For a category C with the natural number object ‘nat’, the terminal
object ‘1’ and the binary product functor ‘prod’, a morphism f is primitive recursive
(on natural numbers) if it can be generated after ﬁnitely many steps by means of the
following rules:
1. f = Inat: nat →nat,
2. f = zero: 1 →nat,
3. f = succ: nat →nat,
4. f = pi1: prod(nat, nat) →nat,
5. f = pi2: prod(nat, nat) →nat,
6. f = g ◦pair(h, k): A →nat for primitive recursive morphisms
g: prod(nat, nat) →nat, h: A →nat and k: A →nat,
7. f = g ◦prod(h, k): prod(A, B) →nat for primitive recursive morphisms
g: prod(nat, nat) →nat, h: A →nat and k: B →nat, and
8. f: prod(nat, A) →nat satisfying
(a) f ◦pair(zero ◦!, I) = g, and
(b) f ◦pair(succ ◦pi1, pi2) = h ◦pair(f, I)
for primitive recursive g: A →nat and h: prod(nat, prod(nat, A)) →nat. []
This is a straight copy of the standard deﬁnition of primitive recursive functions on
natural numbers.
Proposition 3.3.2: If a cartesian closed category C has the natural number object,
it has all the primitive recursive morphisms.
Proof: It is suﬃce to show that there exists a morphism f: prod(nat, A) →nat for
any morphisms g: A →nat and h: prod(nat, prod(nat, A)) →nat such that
1. f ◦pair(zero ◦!, I) = g, and
2. f ◦pair(succ ◦pi1, pi2) = h ◦pair(f, I).
There is a morphism k: nat →prod(exp(A, nat), nat) such that the following diagram
commutes.
1
nat
nat
prod(exp(A, nat), nat)
prod(exp(A, nat), nat)
zero
succ
k
k
g′
h′
¥
¨§?
¥
¨§?
-
-
@
@
@
@
@
@@
R
?
?
-

CHAPTER 3. CATEGORICAL DATA TYPES
62
where g′ and h′ are
g′ def
= pair(curry(g ◦pi2), zero)
h′ def
= pair( curry(h ◦pair( eval ◦pair( pi2,
pi1 ◦pi1),
pi2 ◦pi1)),
succ ◦pi2).
Therefore, k is pr(g′, h′). Then, f def
= eval ◦prod(pi1 ◦k, I). We can easily show that
this is what we wanted. []
For example, the morphism ‘add’ corresponding to the addition function of natural
numbers can be given as
add def
= eval ◦prod(pr(curry(pi2), curry(succ ◦eval)), I).
It corresponds to the following usual deﬁnition of ‘add’.
add(0, y) = y
add(x + 1, y) = add(x, y) + 1
Furthermore, we can easily prove categorically that ‘add’ satisﬁes familiar laws like
commutativity (categorically add ◦pair(pi2, pi1) = add) and so on.
3.3.5
Lists
We have deﬁned the data type of natural numbers in the previous subsection. Another
algebraic data type which is often used in programming is the data type of lists. In
CDT, the data type of lists is deﬁned as follows:
left object list(X) with prl is
nil: 1 →list
cons: prod(X, list) →list
end object
We needed to assume a CSL signature having the terminal object and the product
functor. The declaration above deﬁnes a one argument covariant functor ‘list’, two
natural transformations
nil: λ(X).1
·→λ(X).list(X)
and
cons: λ(X).prod(X, list(X))
·→λ(X).list(X)
and a factorizer ‘prl’ (standing for primitive recursion on list) whose type is
f: λ(Y, X).1 →λ(Y, X).Y
g: λ(Y, X).prod(X, Y ) →λ(Y, X).Y
prl(f, g): λ(Y, X).list(X) →λ(Y, X).Y
.

CHAPTER 3. CATEGORICAL DATA TYPES
63
As usual, we can express the situation as a diagram.
1
list(A)
prod(A, list(A))
B
prod(A, B)
nil
cons
f
¥
¨§?
prl(f, g)
¥
¨§?
prod(I, prl(f, g))
g
-
@
@
@
@
@
@
@
@
R


?
?
A global element of list(A) is normally constructed from ‘nil’ and ‘cons’. For example,
list(nat) has
cons ◦pair(succ ◦zero, cons ◦pair(succ ◦succ ◦zero, nil))
as a global element (in plain words, this element is the list of 1 and 2). ‘nil’ and ‘cons’
are usually called constructors of ‘list’. We can see in general to deﬁne an algebraic
CDT by listing its constructors. Destructors are deﬁned using factorizers. In the case
of ‘list’, ‘hd’ (head) and ‘tl’ (tail) can be deﬁned as follows.
hd def
= prl(in2, in1 ◦pi1)
tl def
= coprod(pi2, I) ◦prl(in2, in1 ◦prod(I, case(cons, nil)))
Note that we have to deﬁne ‘hd’ and ‘tl’ as total functions (in a sense). The type
of ‘hd’ is list(A) →coprod(A, 1) and is not list(A) →A.
The type of ‘tl’ is also
list(A) →coprod(list(A), 1). The type ‘1’ is for error (like ⊥in a domain) and, for
example, hd ◦nil = in2.
As ‘list’ is a covariant functor, for a morphism f: A →B list(f): list(A) →list(B)
transforms a list of A elements to a list of B elements by applying f to each element.
For example, list(succ): list(nat) →list(nat) increments every element in a given list
by one. In general, we have the following equations:
list(f) = prl(nil, cons ◦prod(f, I))
list(f) ◦nil = nil
list(f) ◦cons ◦pair(x, l) = cons ◦pair(f ◦x, list(f) ◦l)
‘list’ corresponds to ‘map’ function in ML and ‘MAPCAR’ in LISP.
3.3.6
Final Co-Algebras (Inﬁnite Lists and Co-Natural Num-
ber Object)
The objects we deﬁned in the preceding subsections are all familiar either in category
theory or in programming languages. Particularly, we have seen in subsection 3.3.4
and 3.3.5 the natural number object and the data type of lists, which are typical initial
algebras. Recently, several works have been done about ﬁnal coalgebras, which are

CHAPTER 3. CATEGORICAL DATA TYPES
64
the dual of initial algebras (see [Arbib and Manes 80]). From their symmetry of CDT
declarations, we can easily deﬁne ﬁnal coalgebras in CDT as well as initial algebras.
Let us dualize the declaration of the natural number object deﬁned in subsection 3.3.4
by
left object nat with pr is
zero: 1 →nat
succ: nat →nat
end object
If we simply replace ‘left’ by ‘right’ and change the direction of arrows, we get
right object conat with copr is
cozero: nat →1
cosucc: nat →nat
end object
Unfortunately, this is not an exciting object. We can prove that ‘conat’ is isomorphic
to the terminal object as follows: from the uniqueness of terminal objects up to isomor-
phism in any category, we simply need to show that ‘1’ is the terminal F, G-dialgebra
for these particular F and G, that is, for any object A and morphisms f: A →1 and
g: A →A, there exists a unique morphism h: A →1 such that the following diagram
commutes.
A
g
A
h
¥
¨§?
h
¥
¨§?
f
1
1
1
cosucc
cozero
-
-
-
@
@
@
@
@
@
@
@
R
?
?
Indeed, we have this unique morphism A →1 because ‘1’ is the terminal object and
the above diagram trivially commutes.
Although the exact dual of the natural number object is not an interesting thing, we
can modify it to get a CDT data type of inﬁnite lists.
right object inﬂist(X) with fold is
head: inﬂist →X
tail: inﬂist →inﬂist
end object

CHAPTER 3. CATEGORICAL DATA TYPES
65
The diagram of explaining ‘inﬂist’ is
B
B
fold(f, g)
fold(f, g)
f
¥
¨§?
¥
¨§?
inﬂist(A)
inﬂist(A)
A
tail
head
-
-
-
@
@
@
@
@
@
@
@
R
g
?
?
Since the functor ‘inﬂist’ is not so familiar in category theory or in conventional pro-
gramming languages, let us ﬁnd out what it is in the category of sets. We expect it to
be a set of inﬁnite lists in some sense.
Proposition 3.3.3: In the category of sets, for a set A, inﬂist(A) is the following set
of ω-inﬁnite sequences of elements in A.
{ (x0, x1, . . . , xn, . . .) | xi ∈A }
Proof: We deﬁne ‘head’ and ‘tail’ as follows:
head((x0, x1, . . . , xn, . . .)) def
= x0
tail((x0, x1, . . . , xn, . . .)) def
= (x1, x2, . . . , xn+1, . . .)
Let fold(f, g)(x) be a sequence (h0(x), h1(x), . . . , hn(x), . . .) for functions f: B →A and
g: B →B. The commutativity of the diagram above forces the following equations.
h0(x) = f(x)
(h1(x), h2(x), . . . , hn+1(x), . . .) = (h0(x), h1(x), . . . , hn(x), . . .)
Therefore, fold(f, g)(x) is uniquely determined as
fold(f, g)(x) def
= (f(x), f(g(x)), . . . , f(gn(x)), . . .)
[]
Hence, at least in the category of sets, inﬂist(A) is really the data type of inﬁnite lists
of A elements.
More generally,
Proposition 3.3.4: In a cartesian closed category C with the natural number object,
inﬂist(A) is isomorphic to exp(nat, A).
Proof: Let us deﬁne h: exp(nat, A) →inﬂist(A) to be the ﬁll-in morphism of the
following diagram.
exp(nat, A)
tail′
exp(nat, A)
h
¥
¨§?
h
head′
¥
¨§?
inﬂist(A)
tail
inﬂist(A)
head
A
-
-
-
@
@
@
@
@
@
@
@
R
?
?

CHAPTER 3. CATEGORICAL DATA TYPES
66
where ‘head′’ and ‘tail′’ are
head′ def
= eval ◦pair(I, zero ◦!),
tail′ def
= curry(eval ◦prod(I, succ)).
We deﬁne h′: inﬂist(A) →exp(nat, A) to be
h′ def
= curry(eval ◦pair(pr(curry(head ◦pi2), exp(tail, I)) ◦pi2, pi1)).
After some calculation, we can show that h ◦h′ = I and h′ ◦h = I, so inﬂist(A) is
isomorphic to exp(nat, A). []
This proposition tells us that
inﬂist(A) ∼= A × A × · · · × A × · · · ∼=
∞
Y
i=1
A.
Indeed, this is the dual of P∞
i=1 A, the special case of which is the natural number
object, nat ∼=
P∞
i=1 1.
We started this subsection by considering the dual of the natural number object. It
led us to the CDT data type of inﬁnite lists. We still have a diﬀerent question whether
there is a ﬁnal coalgebra which resembles a data type of natural numbers. The answer
is yes. The following right object deﬁnes a CDT data type of natural numbers plus
alpha.
right object conat with copr is
pred: conat →coprod(1, conat)
end object
The situation can be written as a diagram
A
f
coprod(1, A)
copr(f)
¥
¨§?
coprod(1, copr(f))
conat
pred
coprod(1, conat)
-
-
?
?
The natural transformation ‘pred’ is the predecessor function and there is a morphism
from ‘nat’ to ‘conat’ given by
copr(pr(in1, in2 ◦case(zero, succ)))
which we expect to be injective, but so far the author has been able neither to prove
it nor to give a counter example.
Note that there is always a morphism from the
left object to its corresponding right object. ‘Conat’ has an interesting extra element,
namely the inﬁnity (∞). The ground element to denote it is
inﬁnity def
= copr(in2)

CHAPTER 3. CATEGORICAL DATA TYPES
67
It is easy to prove that the predecessor of the inﬁnity is itself (i.e. pred ◦inﬁnity =
in2 ◦inﬁnity).
In the category of sets, ‘conat’ is really the set of natural numbers and the inﬁnity.
Proposition 3.3.5: In Set, ‘conat’ is ‘nat ∪{ ∞}’.
Proof: The predecessor function is deﬁned as usual. Roughly speaking, for any func-
tion f: A →coprod(1, A), copr(f)(x) is the number of applications of f to x to get the
element of 1
copr(f)(x) = n
where
f n(x) ∈1,
and, if it never results in the element of 1, copr(f)(x) = ∞. We can easily show that
this is the unique function which makes the ‘conat’ diagram commute. []
Therefore, in the category of sets, ‘conat’ is isomorphic to ‘nat’, but this is not the
case for all the categories. There are some categories where ‘conat’ and ‘nat’ are not
isomorphic.
Proposition 3.3.6: In category TRF of subsets of natural numbers as objects and
total recursive functions as morphisms, there exists the natural number object but does
not exist the co-natural number object.
Proof: TRF’s terminal object, initial object, product functor and coproduct functor
are all the same as those of Set. For example, injections ‘in1’ and ‘in2’ for coprod(A, B)
are trivially total and recursive, and for any two total recursive functions f: A →C
and g: B →C case(f, g) is also total recursive function. We can write it down as a
kind of program.
case(f, g)(x) def
= if x ∈A then f(x)
else g(x)
The natural number object ‘nat’ in TRF is also the ordinary set of natural numbers.
‘Zero’ and ‘succ’ are total recursive functions from the very deﬁnition of recursive
functions and for f: 1 →A and g: A →A of total recursive functions, pr(f, g) can be
written as the following program.
pr(f, g)(n) def
= if n = 0 then f()
else g(pr(f, g)(n −1))
which deﬁnes a total recursive function.
However, we cannot have the co-natural number object in TRF. The program of
copr(f) for a total recursive function f: A →coprod(1, A) can only be
copr(f)(x) def
= if f(x) ∈1 then 0
else copr(f)(f(x)) + 1
which is recursive but not total. []
There is also a category which has both ‘nat’ and ‘conat’ and in which they are non-
isomorphic. We will show this in chapter 4.
From the point of view of ﬁnding ﬁxed points of functors, ‘nat’ is the initial ﬁxed point
of F(X) def
= 1 + X and ‘conat’ is the ﬁnal ﬁxed point of the same functor.

CHAPTER 3. CATEGORICAL DATA TYPES
68
3.3.7
Automata
The declarations of initial algebras and ﬁnal coalgebras do not use the full power of the
CDT declaration mechanism. Their unit and counit natural transformations always
have the form
α: E →F
for initial algebras and have the form
α: F →E
for ﬁnal coalgebras, where E is any functorial expression but F is a variable (more
specially, the variable which denotes the object we declare).
Therefore, all we are
doing is just listing constructors for initial algebras and listing destructors for ﬁnal
coalgebras. We will see what kinds of form deﬁne sensible functors in section 3.5. So
far, the only exception was the exponentials.
We will see another example in this
subsection.
One of the interesting applications of category theory to computer science is to au-
tomata theory. [Arbib and Manes 75] presents the category Dyn(I) of I-dynamics
whose object is
Q × I
-
δ
Q,
where Q is the set of states, I is the set of inputs and δ is a dynamics which is a
function determining the next state of the automaton according to the current state
and input.
From this, we can construct a categorical data type of automata.
right object dyn(I) with univ is
next: prod(dyn, I) →dyn
end object
Note that our dyn(I) for an object I is just an object; it is not a category like Dyn(I)
is. The diagram which explains this right object is
prod(Q, I)
δ
Q
prod(univ(δ), I)
¥
¨§?
univ(δ)
prod(dyn(I), I)
next
dyn
-
-
?
?
For any dynamics δ: prod(Q, I) →Q and an initial state q0: 1 →Q, we get an automa-
ton
1
-
univ(δ) ◦q0
dyn(I)

CHAPTER 3. CATEGORICAL DATA TYPES
69
as a global element of dyn(I). Though we can put this automaton into the next state by
applying ‘next’, we are never ever able to see its behaviour from the outside. Moreover,
because of this non-observability, we can easily prove that dyn(I) is in fact isomorphic
to the terminal object. In order to make ‘dyn’ a more sensible object, we need to add
an output function. The new categorical data type of automata is7
right object dyn′(I, O) with univ′ is
next′: prod(dyn′, I) →dyn′
output′: dyn′ →O
end object
For any dynamics δ: prod(Q, I) →Q, any output function β: Q →O and an initial
state q0: 1 →Q, we have a global element in dyn′(I, O)
1
-
univ′(δ, β) ◦q0 dyn′(I, O).
We can obtain its next state by applying ‘next′’ and its output by ‘output′’. In addition,
the following proposition holds.
Proposition 3.3.7: In a cartesian closed category, the categorical data type of Moore
automata, dyn′(I, O), is isomorphic to exp(list(I), O).
Proof: By deﬁning two morphisms between them and proving that they form an
isomorphism. []
3.3.8
Obscure Categorical Data Types
We have deﬁned more or less familiar data types as categorical data types in the
preceding subsections. One might ask whether CDT can deﬁne any data types which
are unable to be deﬁned in other languages or methods. The data type of automata is
such an example and we can invent similar examples more, but still they are familiar
(or we are just trying to express our familiar data types in CDT). In fact, CDT allows
us very obscure data types, some of which may not be conceptualized in the human
brain (at least not in the author’s brain).
From the prime requirement of CDT, it can deﬁne right and left adjoint functors of
any existing functors, and in subsection 3.3.5, we deﬁned ‘list’ as a covariant functor,
so that we can declare its left and right adjoint functors in CDT as follows.
left object ladjlist(X) with ψ is
α: X →list(ladjlist)
end object
7The original deﬁnition we used was
right object dyn′(I, O) with univ′ is
next′: prod(dyn′, I) →prod(dyn′, O)
end object
which gave us the categorical data type of Mealy automata. The current deﬁnition gives us the data
type of Moore automata.

CHAPTER 3. CATEGORICAL DATA TYPES
70
right object radjlist(X) with ψ′ is
α′: list(radjlist) →X
end object
Some questions arise immediately after deﬁning these data types: are they familiar
data types, and are they in any way useful? The answers to the both questions are
unfortunately negative. For the left adjoint,
Proposition 3.3.8: In a cartesian closed category, ‘ladjlist(A)’ for any object A is
isomorphic to the initial object.
Proof: It is easy to show that the initial object makes the characteristic diagram of
‘ladjlist’ commute. Note that in a cartesian closed category ‘list(0)’ is isomorphic to
the terminal object so that the unit morphism of ‘ladjlist’ is the unique morphism to
the terminal object. []
The right adjoint functor is more harmful than the left one.
Proposition 3.3.9: A cartesian closed category with ‘radjlist’ degenerates (i.e. all the
objects are isomorphic).
Proof: We have the following morphism from the initial object.
1
nil
−−→list(radjlist(0))
α′
−−→0
Then, it is easy to show that the terminal object is isomorphic to the initial one. This
further implies that any object in the category is isomorphic to the initial object.
A ∼= prod(A, 1) ∼= prod(A, 0) ∼= 0
[]
Most of the left and right adjoint functors of conventional data types follow the same
pattern as ‘list’, that is, they are either trivial or destructive, so they are useless.
Hence, a natural question to ask ourselves is that what kind of categorical data types
are useful. But what is the formal criteria of useful data types? We have not yet
deﬁned this. We will come back to this in chapter 4 and see it from a point of view of
computability of categorical data types.
3.4
Semantics of Categorical Data Types
In deﬁnition 3.2.2, we associated a CDT declaration to a CSL signature extension (an
injective morphism in CSig). In this section, we will see it as a CSL theory extension
and give the precise semantics of CDT declarations.
First, from our informal intention of CDT declarations we have to ﬁgure out the CSL
statements which characterize them. A CDT declaration
left object L(X1, . . . , Xn) with ψ is
α1: E1 →E′
1
· · ·
αm: Em →E′
m
end object

CHAPTER 3. CATEGORICAL DATA TYPES
71
is the syntactic form of deﬁning the functor L = Left[⃗F, ⃗G], where ⃗F and ⃗G are corre-
sponding functors for E1, . . . , Em and E′
1, . . . , E′
m, respectively. ⟨L( ⃗A), ⃗α⟩is the initial
object of DAlg(⃗F, ⃗G) and ψ is its mediating morphism, that is, for any morphisms
⃗f: ⃗F(B, ⃗A) →⃗G(B, ⃗A), ψ(⃗f) gives a unique morphism from L( ⃗A) to B such that the
following diagram commutes.
⃗F(L( ⃗A), ⃗A)
⃗α ⃗A
⃗G(L( ⃗A), ⃗A)
L( ⃗A)
⃗F(ψ(⃗f), ⃗A)
¥
¨§?
⃗G(ψ(⃗f), ⃗A)
ψ(⃗f)
⃗F(B, ⃗A)
⃗f
⃗G(B, ⃗A)
B
-
-
?
?
?
The commutativity of this diagram can be expressed as the following equation:
⃗G(ψ(⃗f), ⃗A) ◦⃗α = ⃗f ◦⃗F(ψ(⃗f), ⃗A),
(∗)
and the uniqueness can be expressed as the following conditional equation:
⃗G(h, ⃗A) ◦⃗α = ⃗f ◦⃗F(h, ⃗A) ⇒h = ψ(⃗f)
(∗∗)
The two equations say everything about L, ⃗α and ψ. Let us now translate them to CSL
statements in ⟨Γ∪{L}, ∆∪{α1, . . . , αm}, Ψ∪{ψ}⟩so as to give complete description of
the CDT declaration above in CSL. (∗) corresponds to the following m CSL equations:
E′
i[ψ(f1, . . . , fm)/L] ◦αi = fi ◦Ei[ψ(f1, . . . , fm)/L]8
(LEQi)
(i = 1, . . . , m) and (∗∗) corresponds to the following conditional CSL equation.
E′
1[g/L] ◦α1 = f1 ◦E1[g/L] ∧. . .
∧E′
m[g/L] ◦αm = fm ◦Em[g/L] ⇒g = ψ(f1, . . . , fm)
(LCEQ)
In addition, we should have a CSL equation expressing functors by factorizers and
natural transformations. We can extract such an equation from proposition 3.1.4.
L(h1, . . . , hn) =
ψ(E′
1[hi/Xi] ◦α1 ◦E1[hi/Xi], . . . , E′
m[hi/Xi] ◦αm ◦Em[hi/Xi])9
(LFEQ)
Therefore, the semantics of CDT declaration can be given as a CSL theory extension
as follows.
8Ei[ψ(f1, . . . , fm)/L] means replacing the variable L by ψ(f1, . . . , fm) and replacing the other variables
X1, . . . , Xn by the identities, that is it is a shorthand for
Ei[ψ(f1, . . . , fm)/L, I/X1, . . . , I/Xn].
9E1[hi/Xi] is a shorthand for E1[I/L, h1/X1, . . . , hn/Xn].

CHAPTER 3. CATEGORICAL DATA TYPES
72
Deﬁnition 3.4.1: Given a CSL theory ⟨Γ, ∆, Ψ, Θ⟩, a CDT declaration
left object L(X1, . . . , Xn) with ψ is
α1: E1 →E′
1
· · ·
αm: Em →E′
m
end object,
where Ei and E′
i (i = 1, . . . , m) are CSL functorial expressions over ⟨Γ, ∆, Ψ⟩whose
variables are X1, . . . , Xn and L, is associated with a CSL theory morphism
σL: ⟨Γ, ∆, Ψ, Θ⟩→⟨Γ ∪{L}, ∆∪{α1, . . . , αm}, Ψ ∪{ψ},
Θ ∪{LEQ1, . . . , LEQm, LCEQ, LFEQ}⟩
where the types of L, α1, . . . , αm and ψ are as given in deﬁnition 3.2.2. Dually, we can
associate to a right object R
right object R(X1, . . . , Xn) with ψ is
α1: E1 →E′
1
· · ·
αm: Em →E′
m
end object,
a CSL theory morphism σR.
σR: ⟨Γ, ∆, Ψ, Θ⟩→⟨Γ ∪{R}, ∆∪{α1, . . . , αm}, Ψ ∪{ψ},
Θ ∪{REQ1, . . . , REQm, RCEQ, RFEQ}⟩
where REQi, RCEQ and RFEQ are
αi ◦Ei[ψ(f1, . . . , fm)/R] = E′
i[ψ(f1, . . . , fm)/R] ◦fi
(REQi)
α1 ◦E1[g/R] = E′
1[g/R] ◦f1 ∧. . .
∧αm ◦Em[g/R] = E′
m[g/R] ◦fm ⇒g = ψ(f1, . . . , fm)
(RCEQ)
R(h1, . . . , hn) =
ψ(E′
1[h1/Xi] ◦α1 ◦E1[hi/Xi], . . . , E′
m[hi/Xi] ◦αm ◦Em[hi/Xi])
(RFEQ)
[]
Example 3.4.2: Let ⟨Γ, ∆, Ψ, Θ⟩be the CSL theory of cartesian closed categories (see
examples 2.2.2 and 2.5.3). On top of this, as we have seen in section 3.3.4, we can deﬁne
a natural number object by
left object nat with pr is
zero: 1 →nat
succ: nat →nat
end object.

CHAPTER 3. CATEGORICAL DATA TYPES
73
The CSL statements characterizing this object are
pr(f, g) ◦zero = f
(LEQnat,1)
pr(f, g) ◦succ = g ◦pr(f, g)
(LEQnat,2)
h ◦zero = f ∧h ◦succ = g ◦h ⇒h = pr(f, g)
(LCEQnat)
The CSL extension σnat associated with the declaration above is:
⟨Γ, ∆, Ψ⟩
σnat
−−−→⟨Γ ∪{nat}, ∆∪{zero, succ}, Ψ ∪{pr},
Θ ∪{LEQnat,1, LEQnat,2, LCEQnat}⟩[]
Thus, each CDT declaration can be associated with a CSL theory extension. This can
be thought as a semantics of CDT declarations. However, it is sometimes convenient
to regard their semantics to be real categories.
Deﬁnition 3.4.3: A sequence of CDT declarations D1, . . . , Dl deﬁnes a sequence of
CSL theory extensions starting from the empty CSL theory.
⟨∅, ∅, ∅, ∅⟩
σD1
−−−→⟨Γ1, ∆1, Ψ1, Θ1⟩
σD2
−−−→· · ·
σDl
−−−→⟨Γl, ∆l, Ψl, Θl⟩
We deﬁne a CSL structure of the CDT declaration sequence D1, . . . , Dl to be a category
which is a CSL theory structure of ⟨Γl, ∆l, Ψl, Θl⟩, and the free structure of D1, . . . , Dl
to be the free category of this CSL theory (see section 2.6). []
If we do not rely on any ways of deﬁning functors other than CDT declarations and if
we do not accept any pre-deﬁned functors, it is inevitable to start with the empty CSL
theory. We have deﬁned cartesian closed categories as a CSL theory in examples 2.2.2
and 2.5.3, but we can do so in CDT starting from the empty theory by just declaring the
terminal object (see subsection 3.3.1), products (see subsection 3.3.2) and exponentials
(see subsection 3.3.3). The advantage of the latter is that we neither need to think
about equations nor need to do tedious typing of functors, natural transformations or
factorizers. These things come out automatically, so it is easy to deﬁne categories and
there is less chance to make mistakes.
We have introduced CDT declarations from Left and Right, but we could not connect
them formally. Now, after having models of CDT as categories, we can do so.
Proposition 3.4.4: Let ⟨C, ξ⟩be a CSL structure of a CDT declaration sequence D1,
. . . , Dl. If Di is
left object L(X1, . . . , Xn) with ψ is
α1: E1 →E′
1
· · ·
αm: Em →E′
m
end object
then ξL = Left(⃗F, ⃗G) where
⃗F def
= ⟨ξλ(L, X1, . . . , Xn).E1, . . . , ξλ(L, X1, . . . , Xn).Em⟩
⃗G def
= ⟨λ(L, X1, . . . , Xn).E′
1, . . . , λ(L, X1, . . . , Xn).E′
m⟩.

CHAPTER 3. CATEGORICAL DATA TYPES
74
Name
CDT Declaration
CSL Statements
Terminal
right object 1 with !
end object
f = !
Initial
left object 0 with !!
end object
f = !!
Products
right object prod(X, Y ) with pair is
pi1: prod →X
pi2: prod →Y
end object
pi1 ◦pair(f, g) = f
pi2 ◦pair(f, g) = g
h = pair(pi1 ◦h, pi2 ◦h)
prod(f, g) = pair(f ◦pi1, g ◦pi2)
Coproducts
left object coprod(X, Y ) with case is
in1: X →coprod
in2: Y →coprod
end object
case(f, g) ◦in1 = f
case(f, g) ◦in2 = g
h = case(h ◦in1, h ◦in2)
coprod(f, g) = case(in1 ◦f, in2 ◦g)
Exponentials
right object exp(X, Y ) with curry is
eval: prod(exp, X) →Y
end object
eval ◦prod(curry(f),I) = f
h = curry(eval ◦prod(h,I))
exp(f, g) = curry(g ◦eval ◦prod(I, f))
NNO
left object nat with pr is
zero: 1 →nat
succ: nat →nat
end object
pr(f, g) ◦zero = f
pr(f, g) ◦succ = g ◦pr(f, g)
h ◦succ = g ◦h ⇒h = pr(h ◦zero, g)
Lists
left object list(X) with prl is
nil: 1 →list
cons: prod(X, list) →list
end object
prl(f, g) ◦nil = f
prl(f, g) ◦cons = prod(I, prl(f, g)) ◦g
h ◦cons = prod(I, h) ◦g ⇒
h = prl(h ◦nil, g)
list(f) = prl(nil, cons ◦prod(f,I))
Inﬁnite Lists
right object inﬂist(X) with fold is
head: inﬂist →X
tail: inﬂist →inﬂist
end object
head ◦fold(f, g) = f
tail ◦fold(f, g) = fold(f, g) ◦g
tail ◦h = g ◦h ⇒h = fold(head ◦h, g)
inﬂist(f) = fold(f ◦head, tail)
Co-NNO
right object conat with copr is
pred: conat →coprod(1, conat)
end object
pred ◦copr(f) = coprod(I, copr(f)) ◦f
h ◦pred = f ◦coprod(I, h) ⇒
h = copr(f)
Automata
right object dyn′(I, O) with univ′ is
next′: prod(dyn′, I) →dyn′
output′: dyn′ →O
end object
next′ ◦prod(univ′(f, g),I) = univ′(f, g) ◦f
output′ ◦univ′(f, g) = g
next′ ◦prod(h,I) = h ◦f ⇒
h = univ′(f, output′ ◦h)
Figure 3.1: CDT Objects
The similar thing holds for right CDT declarations.
Proof: Trivial, because we set the CSL statements so that this proposition holds. []
Finally, in this section, let us summarize the objects we have deﬁned in this chapter
and their characteristic CSL statements in ﬁgure 3.1.
3.5
Existence of Left and Right
In section 3.1, we have introduced functors Left[F, G] and Right[F, G] with the con-
dition which characterizes them, but we did not consider whether such functors exist
or not. In this section, we study them mathematically and present a condition of the
existence.
Let us recall the standard construction of initial T-algebras (see, for example, [Scott
76, Lehmann and Smyth 81]).
Proposition 3.5.1: For a ω-cocomplete category C (i.e. it has colimit of any ω-chain

CHAPTER 3. CATEGORICAL DATA TYPES
75
diagram) and an endo-functor T: C →C which is ω-cocontinuous (i.e. it preserves
colimit of any ω-chain diagram), its initial T-algebra is given by the colimit of the
following ω-chain diagram.10
0
!!
−→T(0)
T(!!)
−−−→T 2(0)
T 2(!!)
−−−−→· · ·
T n−1(!!)
−−−−−→T n(0)
T n(!!)
−−−−→· · · []
As we presented in section 3.1, Left[F, G] is a generalization of initial T-algebras, where
F is a functor of C × D →E and G is of C × D−→E. We will reduce the existence
problem of Left to that of corresponding T-algebras. For a D object A, from its deﬁni-
tion ⟨Left[F, G](A), ηA⟩is the initial object in the category DAlg(F( · , A), G( · , A)),
so
F(Left[F, G](A), A)
-
ηA
G(Left[F, G](A), A)
Now, if G( · , A) has a left adjoint functor, say H( · , A): E →C, this morphism ηA has
its one-to-one corresponding morphism
H(F(Left[F, G](A), A), A)
- Left[F, G](A).
This means that Left[F, G](A) is a T-algebra, where T(B) def
= H(F(B, A), A), and we
naturally expect this T-algebra to be special. It really is the initial T-algebra, so we
can formulate the following theorem.
Theorem 3.5.2: Let F: C × D →E and G: C × D−→E be functors. If
1. C is ω-cocomplete,
2. for each D object A, GA
def
= G( · , A): C →E has a left adjoint HA: E →C, and
3. for each D object A, FA
def
= F( · , A): C →E is ω-cocontinuous,
then Left[F, G](A) exists in C and
Left[F, G](A) = colimit
n
(HA ◦FA)n(0)
Proof: Since a left adjoint is cocontinuous, TA
def
= HA ◦FA is ω-cocontinuous if FA
is so. All we have to show is that the initial TA-algebra gives the initial object of
DAlg(FA, GA), and the rest follows from proposition 3.5.1.
Let the initial TA-algebra be I paired with a morphism
HA(FA(I))
-
ι
I.
10In general, this sequence might not converge at ω. In such a case, we may extend the sequence up to
any ordinal such that
1. T α+1(0) = T(T α(0)), and
2. T β(0) = colimit
α<β
T α(0) for a limit ordinal β (treating 0 as a limit ordinal).

CHAPTER 3. CATEGORICAL DATA TYPES
76
For an object ⟨B, f⟩in DAlg(FA, GA)
FA(B)
-
f
GA(B)
we have to construct the unique morphism from I to B which makes a certain diagram
commute. To do so, let us name the factorizer of the adjunction HA 7−GA ψ, that is,
ψ is the natural isomorphism HomC(HA(C), D)
∼
=
−→HomE(C, GA(D)). Then, ψ−1(f)
gives a TA-algebra
HA(FA(B))
-
ψ−1(f)
B
and since ⟨I, ι⟩is the initial TA-algebra, there exists a unique morphism g: I →B such
that the following diagram commutes.
HA(FA(I))
ι
I
HA(FA(g))
¥
¨§?
g
HA(FA(B))
ψ−1(f)
B
-
?
?
-
(∗)
The naturality of ψ converts this diagram to the following commutative diagram.
FA(I)
ψ(ι)
GA(I)
-
FA(g)
¥
¨§?
GA(g)
?
?
FA(B)
f
- GA(B)
(∗∗)
(i.e. ψ(g ◦ι) = GA(g) ◦ψ(ι) and ψ(ψ−1(f) ◦HA(FA(g))) = f ◦FA(g)). That showed
the existence of g. The uniqueness of g is no more diﬃcult. If g: I →B satisﬁes (∗∗),
then by applying ψ−1 we get (∗) back again and so there g should be unique. []
Example 3.5.3: Trivially, if E is C and G: C × D−→C is the projection functor, GA
is the identity which has the left adjoint HA which is also the identity functor. In this
case, the above theorem is essentially stating the same thing as proposition 3.5.1. []
Example 3.5.4: Another simple case is that E is C × C and GA is the diagonal
functor.
Its left adjoint is the binary coproduct functor.
FA: C →C × C can be

CHAPTER 3. CATEGORICAL DATA TYPES
77
decomposed into F ′
A and F ′′
A both of which are functors of C × D →C such that
FA(B) = ⟨F ′
A(B), F ′′
A(B)⟩. The theorem states that Left[F, G](A) is the initial TA-
algebra where TA(B)
def
= F ′
A(B) + F ′′
A(B).
This explains that our natural number
object in subsection 3.3.4 is the initial T-algebra where T(B) def
= 1 + B. []
Theorem 3.5.2 has its dual form for Right[F, G].
Theorem 3.5.5: Let F: C × D →E and G: C × D−→E be functors. If
1. C is ω-complete,
2. for each D object A, FA
def
= F( · , A): C →E has a right adjoint KA: E →C, and
3. for each D object A, GA
def
= G( · , A): C →E is ω-continuous,
then Right[F, G](A) exists in C and
Right[F, G](A) = limit
n (KA ◦FA)n(1)
[]
Example 3.5.6: As an application of this theorem, let us calculate dyn′(I, O). For
this, we should take D to be C × C−, E to be C × C, F: C × C × C−→C × C to be
F(A, I, O) def
= ⟨A × I, A⟩and G: C × C−× C →C × C to be G(A, I, O) def
= ⟨A, O⟩.
FI,O has a right adjoint HI,O(D, E) def
= exp(I, D)×E. Therefore, dyn′(I, O) is the ﬁnal
TI,O-coalgebra, where TI,O(A) def
= HI,O(GI,O(A)) = exp(I, A)×O. Now, let us calculate
limit
n
T n
I,O(1).
T 0
I,O(1) ∼= 1
T 1
I,O(1) ∼= exp(I, 1) × O ∼= O ∼= exp(1, O)
T 2
I,O(1) ∼= TI,O(O) ∼= exp(I, O) × O ∼= exp(1 + I, O)
T 3
I,O(1) ∼= exp(I, exp(1 + I, O)) × O
∼= exp(I × (1 + I), O) × O
∼= exp(1 + I + I2, O)
· · ·
T n
I,O(1) ∼= exp(1 + I + I2 + · · · + In−1, O)
· · ·
Therefore, dyn′(I, O) ∼= limit
n
T n
I,O(1) ∼= exp(1 + I + I2 + · · · , O) ∼= exp(list(I), O). []

Chapter 4
Computation and Categorical Data
Types
In chapter 2 section 2.4, we introduced CSL expressions Exp(Γ, ∆, Ψ) which denote
polymorphic functions in CSL structures. In this chapter, we will see them as programs
and see how they can be executed. One of the ways to treat speciﬁcations as programs
is to regard equations as rewrite rules, but in our case, CSL statements are in general
conditional equations and, therefore, it is quite diﬃcult to treat them as rewrite rules.
Furthermore general rewriting cannot be regarded as real computation unless rules are
Church-Rosser, otherwise, rewriting is more close to theorem proving.
There is no other way so long as we are dealing with CSL speciﬁcations. Remember
that CSL was introduced in order to give semantics to categorical data types we have
investigated in chapter 3. In CDT theory, we are not dealing with arbitrary CSL spec-
iﬁcations, but some special ones, ones which are associated with CDT declarations.
Therefore, we have much more hope for executing these special CSL speciﬁcations
than arbitrary ones. For example, cartesian closed categories are, as is well-known,
connected to lambda calculus which is a model of computation, so we can put some
evaluation mechanism into them. [Curien 86], for example, has developed such a sys-
tem. A diﬀerence of our approach from his is that we do not restrict ourselves only to
cartesian closed categories. One of the main aims of CDT is to study categories formed
by programming languages, and we should not presume any structure in the categories
without proper reasons. We can only accept the cartesian closed structure in CDT if
this is necessary for putting the concept of computation to it. As we will see later in
this chapter, our categories are cartesian closed (with some extra structure), and by
then we should know why the cartesian closed structure is necessary.
CSL expressions in section 2.4 and the CDT declaration mechanism in chapter 3 give
us the basis of Categorical Programming Language (CPL) to which we will devote
this chapter. CPL tries to extract the computable part of CDT. As we have seen in
subsection 3.3.8, CDT in general allows us to deﬁne very strange objects which have
no concept of being computable. We are going to put restrictions to the form of CDT
declarations in CPL.
78

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
79
Therefore, in CPL, we can declare data types by CDT (with restrictions). As we have
seen in section 3.4, this will determine a CSL in which we can have CSL expressions
introduced in section 2.4.
CSL expressions are the programs in CPL. There is no
diﬀerence between programs and data. From the categorical point of view, there is
nothing inside objects, that is, there are no data inside data types. CSL expressions
whose domain is the terminal object are called CPL elements. The execution in CPL
is essentially a reduction of a CPL element to a canonical irreducible CPL element.
Following the result of this chapter, CPL will not only exist on paper, but also can be
implemented. This will be presented in chapter 5.
In section 4.1 we introduce a restriction to objects we can declare in CPL and a set of
reduction rules for CPL computation. In section 4.2 we see an example of computation
in CPL. In section 4.3 we prove that any computation in CPL terminates (i.e. the
reductions are normalizing) by Tait’s computability method. In section 4.4 we show
some properties about objects in CPL and, ﬁnally, section 4.5 gives another set of
reduction rules for CPL computation which reduces CPL elements into intuitively
more canonical elements.
4.1
Reduction Rules for Categorical Programming
Language
In this section, we will present some basic deﬁnitions together with the reduction rules
for CPL. Let us assume in the following discussion that we have deﬁned categorical
data types by a sequence of CDT declarations, D1, . . . , Dl, and that we have obtained
the corresponding CSL, ⟨Γ, ∆, Ψ, Θ⟩as in deﬁnition 3.4.3.
In ordinary programming languages, we distinguish programs and data. We feed data
into a program; it processes the data and then outputs the result data. We cannot
feed a program into another program and data cannot process other data or programs.
However, it is true that data are a special kind of programs, very simple ones. We can
write data directly into programs as initialization statements or as assignments. For
example, natural numbers like 1, 132, 59, etc. are data as well as constants in programs.
In some languages like LISP, there is no diﬀerence between data and programs at all.
CPL is not as liberated as LISP, but both data and programs are morphisms and data
are just special morphisms having a special domain object.
As we know, category theory deals with the external structure of objects rather than
their inner structure so it is not proper to think about data inside objects. However,
we do sometimes need something similar to elements in set theory. We say elements in
category theory are morphisms whose domain is the terminal object.
1
e
−→A
We say e is an element of A. If we think in the category of sets (Set), ‘1’ is the one-
point set and a morphism from the one-point set to a set corresponds to an element in

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
80
the set.
HomSet(1, A) ∼= A
Hence, the deﬁnition of elements in CPL is:
Deﬁnition 4.1.1: Given a CSL signature ⟨Γ, ∆, Ψ⟩, a CPL element e is a CSL expres-
sion with no morphism variables whose domain type is the terminal object.
ρ ⊢e: λ(X1, . . . , Xn).1 →K
(see section 2.4 for typing). In case n = 0 which is very often the case, we may write
⊢e: 1 →E where E is a functorial expression without variables. We also say that e is
an element of E. []
In order for this deﬁnition to be sensible, we need to have the terminal object in our
category. For simplicity, we assume that D1 is the CDT declaration of the terminal
object as is presented in subsection 3.3.1.
Though this deﬁnition is a natural way of deﬁning elements in category theory, it
introduces non-symmetry in CPL. Remember that CDT is meant to be symmetric:
e.g. if we have an object of natural numbers, we should have its dual, an object of
co-natural numbers, and so on. Since we treat ‘1’ as a special object and the elements
in CPL are deﬁned in this way, we destroy the beauty of symmetry. We will see the
consequence of this shortly.
Example 4.1.2: Assume that we have deﬁned all the objects in section 3.3. Then
succ ◦zero,
pi2 ◦pair(succ ◦zero, nil),
eval ◦prod(pr(curry(pi2), curry(succ ◦eval)), I) ◦pair(succ ◦succ ◦zero, succ ◦zero)
are all CPL elements. []
As we can see from this example, we cannot regard all the elements as data. ‘succ◦zero’
and ‘pair(succ ◦zero, nil)’ can be data, but ‘pi1 ◦pair(succ ◦zero, nil)’ cannot be. We
call special data-like CPL elements canonical CPL elements. The deﬁnition is:
Deﬁnition 4.1.3: A canonical CPL element is a CPL element which wholly consists
of natural transformations introduced by left objects and factorizers by right objects.
Formally, a canonical CPL element, c ∈CE, is deﬁned by
c : : = I | αL ◦c | ψR(e1, . . . , en) ◦c
where αL is a natural transformation of a left object and ψR is a factorizer of a right
object. Note we often do not write I at the tail of canonical elements. []
From this deﬁnition, ‘pair’ and ‘curry’ can form canonical elements, but ‘pi1’, ‘pi2’ or
‘eval’ cannot. So for the right objects, factorizers are the means of creating canonical
elements. On the other hand, ‘zero’, ‘succ’ and ‘cons’ can form canonical elements,

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
81
but not ‘pr’ or ‘case’. So for the left objects, natural transformations are the means of
creating canonical elements.
Canonical
Non-Canonical
left object
natural transformations
e.g. zero, succ, nil, cons
factorizers
e.g. case, pr, prl
right object
factorzers
e.g. pair, curry
natural transformations
e.g. pi1, pi2, eval
Deﬁnition 4.1.3 is beautifully symmetrical as we hoped from the symmetry of CDT.
In addition, if we look at the canonical elements in other programming languages, we
note that ‘pair’ corresponds to making pairs of data, ‘curry’ corresponds to lambda
abstraction and both create canonical things (i.e. we cannot process them any more as
themselves), and also we note that ‘pr’ and ‘case’ are programming constructs corre-
sponding to primitive recursive deﬁnitions and case statements and they can never be
data. Therefore, deﬁnition 4.1.3 ﬁts well with the usual notion of data.
Of course, this is not the only deﬁnition of canonical elements. It deﬁnes quite lazy
canonical elements. It does not care what are inside factorizers. For example,
pair(pi1 ◦pair(succ ◦zero, nil), zero)
is a canonical element of ‘prod(nat, nat)’ from this deﬁnition. Some might not want to
call it canonical because it is equal to another canonical element
pair(succ ◦zero, zero)
which looks more canonical. However, this is because ‘prod’ is a rather special object.
In general, expressions inside factorizers may not be elements, so we cannot demand
them to be canonical (or we have to treat product-like objects special). One might still
accept this easily since canonical elements in Martin-L¨of’s type theory are similar to
ours, but another queer aspect of our deﬁnition is that we accept
pair(pi2, pi1) ◦pair(succ, I) ◦zero
as a canonical element. It is equal to the following element
pair(pi2 ◦pair(succ, I) ◦zero, pi1 ◦pair(succ, I) ◦zero),
but this is again because of the special property of ‘prod’. In general
ψR(e1, . . . , en) ◦c
is not equal to something in the form of ψR(e′
1, . . . , e′
n). For example, we cannot always
ﬁnd other simpler canonical elements which is equal to ‘fold(f, g) ◦c’ (where ‘fold’ is
the factorizer of ‘inﬂist’).
There are many views of computation, but in CPL computation is the reduction of an
element to a canonical element equal to the given element.
e ⇒c

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
82
Since the reduction is not straightforward, we want to do step-by-step reduction. There-
fore, we modify the above form of reduction to the following one.
⟨e, c⟩⇒c′
This means that a CSL expression e applied to a CPL canonical element c is reduced
to a CPL canonical element c′. It is like calculating the result of applying an element
c to a function e. Obviously, e ◦c should be semantically equal to c′. Since a CPL
element is a morphism from the terminal object and ‘I’ is its canonical element, if we
want to reduce an arbitrary CPL element e we can ask for the following reduction.
⟨e, I⟩⇒c
In the following, we assume that the associativity of ‘◦’ (the composition of morphisms)
has been taken care by some means so that in our rules we do not consider it. We
also assume that there are no functors in CPL elements because we can always replace
them with factorizers and natural transformations. For example,
eval ◦prod(curry(succ), nil)
is equivalent to
eval ◦pair(curry(succ) ◦pi1, nil ◦pi2).
Let us now deﬁne rules for the reductions. The simplest one is for identities. Since I◦c
is equal to c, we should have the following rule.
⟨I, c⟩⇒c
(IDENT)
Next, for the composition, we naturally have
⟨e2, c⟩⇒c′′
⟨e1, c′′⟩⇒c′
⟨e1 ◦e2, c⟩⇒c′
(COMP)
In case that e is a natural transformation introduced by a left object or a factorizer
introduced by a right object, the rule is easy because the composition of e with a
canonical element is canonical by deﬁnition 4.1.3.
⟨αL, c⟩⇒αL ◦c
(L-NAT)
⟨ψR(e1, . . . , en), c⟩⇒ψR(e1, . . . , en) ◦c
(R-FACT)
For example, ⟨succ, zero⟩⇒succ ◦zero and
⟨curry(pi2), pair(zero, succ ◦zero)⟩⇒curry(pi2) ◦pair(zero, succ ◦zero).
Diﬃculty comes in for the other cases, i.e. when e is a natural transformation of a right
object or a factorizer of a left object. Let us ﬁrst consider the case for a factorizer ψL
introduced by the following left object.
left object L(X) with ψL is
αL: E(L, X) →E′(L, X)
end object

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
83
From the property of this object, we have a CSL equation
E′(ψL(e), I) ◦αL = e ◦E(ψL(e), I).
An instance of this equation is ‘pr(f, g)◦succ = g ◦pr(f, g)’, and in this case we should
have a rewrite rule from ‘pr(f, g)◦succ’ to ‘g ◦pr(f, g)’. Therefore, in general we might
have the following rule.
⟨e ◦E(ψL(e), I), c⟩⇒c′
⟨E′(ψL(e), I), αL ◦c⟩⇒c′
However, this rule is not what we wanted. We wanted a rule for ⟨ψL(e), c′′⟩⇒c′′′. In
order that the above rule to be a one we want, E′(L, X) should be simply L, and we
get
⟨e ◦E(ψL(e), I), c⟩⇒c′
⟨ψL(e), αL ◦c⟩⇒c′
.
(L-FACT)
The restriction that demands E′(L, X) should be L is the ﬁrst restriction we put onto
objects in order to obtain the CPL computation rules. The left objects introduced in
chapter 3, initial object, coproducts, natural number object and lists, all satisfy this
restriction except the left adjoint functor of ‘list’ which we do not expect to be in the
world of computation. If E′(L, X) is something other than L, we are allowing to have
the left adjoint L′ of E′( · , X) by
left object L′(X, Y ) with ψL′ is
αL′: Y →E′(LL′, X)
end object.
In familiar categories (e.g. the category of sets), a functor F: C →C hardly has a left
adjoint: e.g. the product functor • × A does not have one, nor does the coproduct
functor • + A.
As an example of L-FACT, let us write the rules for the factorizer associated with the
natural number object. There are two rules for two natural transformations, ‘zero’ and
‘succ’.
⟨e, c⟩⇒c′
⟨pr(e, e′), zero ◦c⟩⇒c′
⟨e′ ◦pr(e, e′), c⟩⇒c′
⟨pr(e, e′), succ ◦c⟩⇒c′
Let us now consider the last case, the case for the reduction rule of a natural transfor-
mation αR introduced by the following right object declaration.
right object R(X) with ψR is
αR: E(R, X) →E′(R, X)
end object
From the property of this object, we have a CSL equation
αR ◦E(ψR(e), I) = E′(ψR(e), I) ◦e.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
84
An instance of this equation is ‘pi1 ◦pair(f, g) = f’, and in this case we should have a
rule to rewrite ‘pi1 ◦pair(f, g)’ to ‘f’. Therefore, in general we have a rule rewriting
from the left-hand side to the right-hand side as the following rule.
⟨E′(ψR(e), I) ◦e, c⟩⇒c′
⟨αR, E(ψR(e), I) ◦c⟩⇒c′
However, this rule is not quite right because E(ψR(e), I) ◦c is not a canonical element.
We cannot have functors in canonical elements. Therefore, what the rule should really
look like is
c = E(ψR(e), I) ◦c′′
⟨E′(ψR(e), I) ◦e, c′′⟩⇒c′
⟨αR, c⟩⇒c′
.
(+)
We now have a diﬀerent problem of ﬁnding out an expression e and a canonical element
c′′ from a given canonical element c such that
c = E(ψR(e), I) ◦c′′.
Since we are dealing with computation, we need a mechanical way of solving this
problem. Let us introduce another form of reduction rules.
⟨c, E, R⟩; ⟨ψR(e), c′′⟩
(∗)
such that c = E(ψR(e), I)◦c′′ where E is a functorial expression in which R is a variable.
By these rules, we can rewrite the rule (+) to
⟨c, E(R, X), R⟩; ⟨ψR(e), c′′⟩
⟨E′(ψR(e), I) ◦e, c′′⟩⇒c′
⟨αR, c⟩⇒c′
.
(R-NAT)
We now have to list the rules for (∗). If E is simply R itself, c should be E(ψR(e), I) ◦
c′′ = ψR(e) ◦c′′. Therefore, the rule should be
⟨ψR(e) ◦c′′, R, R⟩; ⟨ψR(e), c′′⟩.
(R-NAT-V)
Next, if E(R, X) does not depend on R, c is E(ψR(e), I) ◦c′′ = c′′, so the rule may be
⟨c, E, R⟩; ⟨ψR(e), c⟩,
but where does ψR(e) come from? We cannot determine e. Therefore, E(R, X) must
not be independent from R (i.e. E(R, X) should not be free of R).
The case left is when E(R, X) is not a variable but a real functorial expression. Let it
be
F( ˆE1(R, X), . . . , ˆEn(R, X)),
(1)
where F is a functor name. In this case, the equation we are solving is
c = F( ˆE1(ψR(e), I), . . . , ˆEn(ψR(e), I)) ◦c′′.
(2)
Since functors are always represented by their associated factorizers, the equation looks
like
c = ψF(· · · ◦ˆE1(ψR(e), I) ◦· · · ◦ˆEn(ψR(e), I) ◦· · ·) ◦c′′.
(3)

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
85
As we can see, we might have to pick up the same ψR(e) from more than one place
and this would be a trouble.
Because ψR(e) is a general CSL expression and we
cannot do theorem proving to show two CSL expressions are equal when doing the
CPL computation. Therefore, we need to restrict that ψR(e) should appear only once
in (3). In order for this, we have to ﬁrst restrict that only one ˆEi in (2) contains
R. Without loss of generality, we can assume it is ˆE1(R, X), and since we are only
interested in the ﬁrst argument of F, we assume that F is a unary functor and E(R, X)
is F( ˆE(R, X)). Now (2) looks like
c = F( ˆE(ψR(e), I)) ◦c′′,
(2′)
but still (3) might have more than one ψR(e) because when we expand functors by
factorizers using (LFEQ) or (RFEQ) in deﬁnition 3.4.1, we might duplicate ψR(e).
Before stating the restriction to guarantee the no-duplication of ψR(e), let us note that
F should be a functor introduced by a right object declaration. This is because, if we
look at the equation (3), c is a canonical element consisting of left natural transforma-
tions and right factorizers, so ψF should be a right factorizer. Let the following be the
declaration of F.
right object F(Y ) with ψF is
β1: ˜E1(F, Y ) →˜E′
1(F, Y )
· · ·
βm: ˜Em(F, Y ) →˜E′
m(F, Y )
end object
(4)
From the equation (RFEQ) in deﬁnition 3.4.1, (3) really is
c = ψF( ˜E′
1(I, ˆE(ψR(e), I)) ◦β1 ◦˜E1(I, ˆE(ψR(e), I)),
· · ·
˜E′
m(I, ˆE(ψR(e), I)) ◦βm ◦˜Em(I, ˆE(ψR(e), I)) ) ◦c′′
(3′)
In order that ψR(e) should appear only once in this equation, Y should appear only
once in one of ˜Ei and ˜E′
i. In order to show that Y should not be in one of ˜E′
i, let F be
simply
right object F(Y ) with ψF is
β: Y →F
end object.
(4′)
(3) becomes
c = ψF(β ◦ˆE(ψR(e), I)) ◦c′′.
We may demand that c should be ψF(ˆe) ◦ˆc and ﬁnd ψR(e) such that
ˆe = β ◦ˆE(ψR(e), I),
but how can we solve this equation? In general, we need theorem proving for this. We
should have reduced the problem recursively into
⟨ˇc, ˇE, R⟩; ⟨ψR(e), ˇc⟩,

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
86
but there is no way to do this if Y appears in one of ˜Ei, because ˆe should never be an
element. The typing rule in deﬁnition 3.2.2 gives us
ˆe: Y →Z
ψF(ˆe): Z →F(Y )
and we cannot choose Y to be the terminal object. If Y and F were the other way
round in (4′), we could choose Z to be the terminal object to make ˆe an element.
Therefore, if Y is in one of ˜E′
i in (4), we have a possibility of reducing the problem of
solving (3′) into a smaller problem of the same kind. Without losing generality, we can
assume that Y only appears in ˜E′
1 in (4). Now, (3′) is
c = ψF( ˜E′
1(I, ˆE(ψR(e), I)) ◦β1, β2, . . . , βm) ◦c′′.
(3′′)
We demand c to be ψF(ˆe1, ˆe2, . . . , ˆem) ◦ˆc, so (3′′) is further rewritten to
ψF(ˆe1, ˆe2, . . . , ˆem) ◦ˆc = ψF( ˜E′
1(I, ˆE(ψR(e), I)) ◦β1, β2, . . . , βm) ◦c′′.
(3′′′)
Here, we cannot jump to the conclusion that ˆe1 is ˜E′
1(I, ˆE(ψR(e), I)) ◦β1, ˆe2 is β2,
. . . , and ˆc is c′′, because a part of ˆc may well contribute to form ˜E′
1(I, ˆE(ψR(e), I)).
What is desirable is that we could rewrite ψF(ˆe1, ˆe2, . . . , ˆem) ◦ˆc to ψF(ˆe′
1, ˆe′
2, . . . , ˆe′
m)
like pair(f, g) ◦h = pair(f ◦h, g ◦h). This is possible when each ˜E′
i in (4) does not
depend on F.
Proposition 4.1.4: Let R be a right object deﬁned by
right object R(X1, . . . , Xn) with ψR is
α1: E1(R, X1, . . . , Xn) →E′
1(X1, . . . , Xn)
· · ·
αm: Em(R, X1, . . . , Xn) →E′
m(X1, . . . , Xn)
end object
(note that E′
i does not depend on R), then
ψR(e1, . . . , em) ◦e′ = ψR(e1 ◦E1(e′, I, . . . , I), . . . , em ◦Em(e′, I, . . . , I))
(REQC)
Proof: From (RCEQ) in deﬁnition 3.4.1,
α1 ◦E1(ψR(e1, . . . , em) ◦e′, I, . . . , I) = f1 ∧
· · ·
αm ◦Em(ψR(e1, . . . , em) ◦e′, I, . . . , I) = fm ∧
⇒ψR(e1, . . . , em) ◦e′ = ψR(f1, . . . , fm).
Using (REQi) and the fact that Ei is covariant in R, we get
e1 ◦E1(e′, I, . . . , I) = f1 ∧. . . ∧em ◦Em(e′, I, . . . , I) = fm
⇒ψR(e1, . . . , em) ◦e′ = ψR(f1, . . . , fm).
Therefore,
ψR(e1, . . . , em) ◦c′ = ψR(e1 ◦E1(e′, I, . . . , I), . . . , em ◦Em(e′, I, . . . , I)). []

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
87
We call this kind of right objects unconditioned. The name indicates that the objects
are characterized without using conditional CSL equations. In fact, (REQi), (REQC),
(RFEQ) and the following (REQI) characterize the unconditioned right objects.1
ψR(α1, . . . , αm) = I
(REQI)
Therefore, we assume that in (4) F does not appear in any of ˜E′
i. As we have already
assumed that Y appears only in ˜E′
1, (4) now looks like
right object F(Y ) with ψF is
β1: ˜E1(F) →˜E′
1(Y )
β2: ˜E2(F) →˜E′
2
· · ·
βm: ˜Em(F) →˜E′
m
end object
( ˜E′
2, . . . , ˜E′
m do not depend on F or Y in this case, but in general F might have
parameters other than Y and they can appear in ˜E′
2, . . . , ˜E′
m), and (3) is
ψF(ˆe1 ◦˜E1(ˆc), ˆe2 ◦˜Ee(ˆc), . . . , ˆem ◦˜Em(ˆc))
= ψF( ˜E′
1( ˆE(ψR(e), I)) ◦β1 ◦˜E1(c′′), β2 ◦˜E2(c′′), . . . , βm ◦˜Em(c′′)).
(ˆ3)
If, furthermore, the ﬁrst argument of ψF is an element, we can reduce the problem of
solving (3) into
ˆe1 ◦˜E1(ˆc) = ˜E′
1( ˆE(ψR(e), I)) ◦β1 ◦˜E1(c′′).
(5)
Since ˆe1 ◦˜E1(ˆc) is an element, we can ask its canonical element and it becomes almost
like the original object (3) except E is replaced. Let us see the typing rule for ψF
deﬁned in deﬁnition 3.2.2.
f1: ˜E1(Z) →˜E′
1(Y )
. . .
ψF(f1, . . .): Z →F(Y )
Since ψF in (ˆ3) is making an element, Z above should be the terminal object 1. In
order that f1 above is also an element, ˜E1(Z) (or ˜E1(1) because Z is 1) should also
the terminal object. Because ˜E1(Z) cannot be independent from Z, ˜E1(Z) should be
simply Z. Therefore, (5) is
ˆe1 ◦ˆc = ˜E′
1( ˆE(ψR(e), I)) ◦β1 ◦c′′.
(5′)
As ˆe1 ◦ˆc is an element, we can ask its canonical element by
⟨ˆe1, ˆc⟩⇒ˆc′,
(6)
and we can also ask to solve
ˆc′ = ˜E′
1( ˆE(ψR(e), I)) ◦ˆc′′
(7)
1We can deﬁne unconditioned left objects as dual.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
88
by
⟨ˆc′, ˜E′
1( ˆE(R, X)), R⟩; ⟨ψR(e), ˆc′′⟩.
If we set c′′ to be
ψF(ˆc′′, ˆe2 ◦ˆE2(ˆc), . . . , ˆem ◦ˆEm(ˆc)),
(ˆ3) is satisﬁed from (REQi) in deﬁnition 3.4.1.
˜E′
1( ˆE(ψR(e), I)) ◦β1 ◦˜E1(c′′)
= ˜E′
1( ˆE(ψR(e), I)) ◦β1 ◦˜E1(ψF(ˆc′′, ˆe2 ◦ˆE2(ˆc), . . . , ˆem ◦ˆEm(ˆc)))
= ˜E′
1( ˆE(ψR(e), I)) ◦β1 ◦ˆc′′
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .(from (REQi))
= ˆc′
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (from (7))
= ˆe1 ◦ˆc
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (from (6))
βi ◦˜Ei(c′′)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (i = 2, . . . , m)
= βi ◦˜Ei(ψF(ˆc′′, ˆe2 ◦ˆE2(ˆc), . . . , ˆem ◦ˆEm(ˆc)))
= ˆei ◦˜Ei(ˆc)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (from (REQi))
Therefore, we got the following rule.
⟨ˆe1, ˆc⟩⇒ˆc′
⟨ˆc′, ˜E′
1( ˆE(R, X)), R⟩; ⟨ψR(e), ˆc′′⟩
⟨ψF(ˆe1, ˆe2, . . . , ˆem) ◦ˆc, F( ˆE(R, X)), R⟩
; ⟨ψR(e), ψF(ˆc′′, ˆe2 ◦˜E2(ˆc), . . . , ˆem ◦ˆEm(ˆc))⟩
(R-NAT-F)
As an example of the rules (R-FACT), (R-NAT), (R-NAT-V) and (R-NAT-F), let us
write the rules for the exponentials. The CDT declaration of the exponentials is
right object exp(X, Y ) with curry is
eval: prod(exp, X) →Y
end object
as we have seen in subsection 3.3.3. The rule (R-FACT) is simply
⟨curry(e), c⟩⇒curry(e) ◦c,
and the rule (R-NAT) is
⟨c, prod(exp, X), exp⟩; ⟨curry(e), c′′⟩
⟨e, c′′⟩⇒c′
⟨eval, c⟩⇒c′
.
The rule (R-NAT-V) is simply
⟨curry(e) ◦c′′, exp, exp⟩; ⟨curry(e), c′′⟩,
and, ﬁnally, the rule (R-NAT-F) is
⟨ˆe1, ˆc⟩⇒ˆc′
⟨ˆc′, exp, exp⟩; ⟨curry(e), ˆc′′⟩
⟨pair(ˆe1, ˆe2) ◦ˆc, prod(exp, X), exp⟩; ⟨curry(e), pair(ˆc′′, ˆe2 ◦ˆc)⟩
.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
89
We may simplify the last three rules and have the next one instead.
⟨e1, c⟩⇒curry(e) ◦c′′
⟨e, pair(c′′, e2 ◦c)⟩⇒c′
⟨eval, pair(e1, e2) ◦c⟩⇒c′
We will see an example using these rules in the next section.
In order to obtain (R-NAT-F), we have put several restrictions to the right object
declaration. To state the restrictions formally, let us introduce the notion ‘productive’.
Deﬁnition 4.1.5: Functorial expressions which are productive in X are generated by
the following two rules.
1. X itself is a functorial expression productive in X.
2. If P(Y1, . . . , Yn) is a functor which is productive in Yi and E is a functorial
expression productive in X, P(E1, . . . , Ei−1, Ei, Ei+1, . . . , En) is productive in X,
where E1, . . . , Ei−1, Ei+1, . . . , En are functorial expressions which do not contain
X.
A functor P(Y1, . . . , Yn) is called productive in its i-th argument Yi when P is declared
as a right object and its declaration
right object P(Y1, . . . , Yn) with ψP is
αP,1: EP,1(P, Y1, . . . , Yn) →E′
P,1(P, Y1, . . . , Yn)
· · ·
αP,m: EP,m(P, Y1, . . . , Yn) →E′
P,m(P, Y1, . . . , Yn)
end object
satisﬁes
1. P is unconditioned (i.e. P does not appear in E′
P,1, . . . , E′
P,m),
2. Yi does not appear in EP,1, . . . , EP,m,
3. Yi appears only one of E′
P,1, . . . , E′
P,m, so let us assume that it appears in E′
P,j
only,
4. EP,j is simply P, and
5. E′
P,j is a functorial expression productive in Yi.
Therefore, the declaration above may look more like
right object P(Y1, . . . , Yi, . . . , Yn) with ψP is
αP,1: EP,1(P, Y1, . . . , Yi−1, Yi+1, . . . , Yn) →
E′
P,1(Y1, . . . , Yi−1, Yi+1, . . . , Yn)
· · ·
αP,j: P →E′
P,j(Y1, . . . , Yi−1, Yi, Yi+1, . . . , Yn)
· · ·
αP,m: EP,m(P, Y1, . . . , Yi−1, Yi+1, . . . , Yn) →
E′
P,m(Y1, . . . , Yi−1, Yi+1, . . . , Yn)
end object
(P)

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
90
αP,j may be called projection to Yi. []
The functor ‘prod’ is a typical productive functor. It is productive in its both ar-
guments. The functor ‘exp’ is not productive in any of its arguments. A functorial
expression ‘prod(prod(X, exp(Y, Z)), prod(X, U))’ is productive in U but not in X or
Y or Z.
Deﬁnition 4.1.6: A right object R is called computable if its declaration
right object R(X1, . . . , Xn) with ψR is
αR,1: ER,1(R, X1, . . . , Xn) →E′
R,1(R, X1, . . . , Xn)
· · ·
αR,m: ER,m(R, X1, . . . , Xn) →E′
R,m(R, X1, . . . , Xn)
end object
(RC)
satisﬁes that ER,1, . . . , ER,m are functorial expressions productive in R. We also call a
left object L computable when its declaration is
left object L(X1, . . . , Xn) with ψL is
αL,1: EL,1(L, X1, . . . , Xn) →L
· · ·
αL,m: EL,m(L, X1, . . . , Xn) →L
end object
(LC)
[]
The reduction rules we have deﬁned in this section work when all the objects we deﬁne
are computable, and all the objects declared in section 3.3 are computable except the
obscure ones in subsection 3.3.8. Obviously, we did not want to have those obscure
objects in our datatype system and the computability constraint gets rid of them. In
other words, the categories which are deﬁned by declaring computable objects cannot
be richer than cartesian closed category with recursive objects. Note that we did not
make the restriction in the beginning. We had the ability to declare a lot of other
objects, but it turned out that in order to be able to discuss the computability in
CDT, the categories should be cartesian closed with recursive objects. This signiﬁes
the importance of cartesian closed categories in computer science yet again (e.g. the
models of typed lambda calculus correspond to cartesian closed categories).
Note that not all the productive objects are computable by the deﬁnition 4.1.5, but
from now on we only treat computable objects, so productive objects mean computable
productive objects.
Deﬁnition 4.1.7: Let D1, . . . , Dl be a sequence of CDT declarations deﬁning only
computable objects and let ⟨Γ, ∆, Ψ, Θ⟩be the corresponding CSL theory deﬁned by
deﬁnition 3.4.3. Then, we can have computation rules for CPL elements over the CSL
signature ⟨Γ, ∆, Ψ⟩. The computation rules are divided into two: those in the form of
⟨e, c⟩⇒c′

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
91
where c and c′ are canonical elements and e and c can be composed (i.e. e ◦c is an
element), and those in the form of
⟨c, E, R⟩; ⟨ψR(e1, . . . , em), c′⟩
where c and c′ are canonical elements, R is a right functor name, E is a functorial
expression productive in R and, if c is an element of E′, E should be more general than
E′.
1. IDENT
⟨I, c⟩⇒c
2. COMP
⟨e2, c⟩⇒c′′
⟨e1, c′′⟩⇒c′
⟨e1 ◦e2, c⟩⇒c′
3. L-NAT
⟨αL,j, c⟩⇒αL,j ◦c
4. R-FACT
⟨ψR(e1, . . . , em), c⟩⇒ψR(e1, . . . , em) ◦c
5. L-FACT
⟨ej ◦EL,j[ψL(e1, . . . , em)/L], c⟩⇒c′
⟨ψL(e1, . . . , em), αL,j ◦c⟩⇒c′
6. R-NAT
⟨c, ER,j, R⟩; ⟨ψR(e1, . . . , em), c′′⟩
⟨E′
R,j[ψR(e1, . . . , em)/R] ◦ej, c′′⟩⇒c′
⟨αR,j, c⟩⇒c′
7. R-NAT-V
⟨ψR(e1, . . . , em) ◦c′′, R, R⟩; ⟨ψR(e1, . . . , em), c′′⟩
8. R-NAT-F
R ∈Ei
Yi ∈E′
P,j
⟨ˆej, c⟩⇒c′
⟨c′, E′
P,j[Ei/Yi], R⟩; ⟨ψR(e1, . . . , em′), c′′⟩
⟨ψP(ˆe1, . . . , ˆem) ◦c, P(E1, . . . , En), R⟩;
⟨ψR(e1, . . . , em′), ψP(ˆe1 ◦EP,1[c/P], . . . ,
ˆej−1 ◦EP,j−1[c/P], c′′, ˆej+1 ◦EP,j+1[c/P], . . . , ˆem ◦EP,m[c/P])⟩
where the objects L, R and P are deﬁned as (LC), (RC) and (P), respectively, and
R ∈Ei means that R appears in a functorial expression Ei. []
We have to show that the rules are well-formed, but we have to show their soundness
at the same time. We will do this in section 4.3 as well as showing that every reduction
terminates (in other words, every element is normalizable by these rules).

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
92
4.2
An Example of using Reduction Rules
In this section, we will see an example computation in CPL using the reduction rules
deﬁned in the previous section. Since computation by hand is very tiresome, we do
only one example, but we will see some more examples of CPL computation done by
a computer in chapter 5.
Let us assume that we have declared the terminal object as in subsection 3.3.1, prod-
ucts as in subsection 3.3.2, exponentials as in subsection 3.3.3 and natural number
object as in subsection 3.3.4. We can write down instances of the reduction rules in
deﬁnition 4.1.7 as follows.
⟨I, c⟩⇒c
(IDENT)
⟨e2, c⟩⇒c′′
⟨e1, c′′⟩⇒c′
⟨e1 ◦e2, c⟩⇒c′
(COMP)
For the terminal object, we have
⟨!, c⟩⇒! ◦c.
(R-FACT!)
For products, we have
⟨pair(e1, e2), c⟩⇒pair(e1, e2) ◦c,
(R-FACTpair)
⟨c, R, R⟩; ⟨pair(e1, e2), c′′⟩
⟨e1, c′′⟩⇒c′
⟨pi1, c⟩⇒c′
,
(R-NATpi1)
and
⟨pair(e1, e2) ◦c, prod, prod⟩; ⟨pair(e1, e2), c⟩.
(R-NAT-Vprod)
If we combine (R-NATpi1) and (R-NAT-Vprod) together, we get a familiar rule
⟨e1, c⟩⇒c′
⟨pi1, pair(e1, e2) ◦c⟩⇒c′
.
(R-NAT′
pi1)
Similarly, for ‘pi2’, we have
⟨e2, c⟩⇒c′
⟨pi2, pair(e1, e2) ◦c⟩⇒c′
.
(R-NAT′
pi2)
For exponentials, as we have seen in the previous section, we have the following two
rules.
⟨curry(e), c⟩⇒curry(e) ◦c
(R-FACTcurry)
⟨e1, c⟩⇒curry(e) ◦c′′
⟨e, pair(c′′, e2 ◦c)⟩⇒c′
⟨eval, pair(e1, e2) ◦c⟩⇒c′
(R-NAT′
eval)
For natural number object, we have
⟨zero, c⟩⇒zero ◦c,
(L-NATzero)
⟨succ, c⟩⇒succ ◦c,
(L-NATsucc)

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
93
⟨e1, c⟩⇒c′
⟨pr(e1, e2), zero ◦c⟩⇒c′
,
(L-FACTzero)
and
⟨e2 ◦pr(e1, e2), c⟩⇒c′
⟨pr(e1, e2), succ ◦c⟩⇒c′
.
(L-FACTsucc)
Now let us try to calculate ‘1 + 1’ in CPL. The addition function is deﬁned in subsec-
tion 3.3.4 as
add = eval ◦prod(pr(curry(pi2), curry(succ ◦eval)), I).
If we expand ‘prod’ by ‘pair’, we get
add = eval ◦pair(pr(curry(pi2), curry(succ ◦eval)) ◦pi1, pi2).
Therefore, the calculation ‘1 + 1’ corresponds to the following reduction.
⟨eval ◦pair(pr(curry(pi2), curry(succ ◦eval)) ◦pi1, pi2),
pair(succ ◦zero, succ ◦zero)⟩⇒c
(1)
From (COMP),
⟨pair(pr(curry(pi2), curry(succ ◦eval)) ◦pi1, pi2),
pair(succ ◦zero, succ ◦zero)⟩⇒c1
⟨eval, c1⟩⇒c
⟨eval ◦pair(pr(curry(pi2), curry(succ ◦eval)) ◦pi1, pi2),
pair(succ ◦zero, succ ◦zero)⟩⇒c
From (R-FACTpair), c1 is
pair(pr(curry(pi2, curry(succ ◦eval) ◦pi1, pi2) ◦pair(succ ◦zero, succ ◦zero),
so we need to calculate
⟨eval, pair(pr(curry(pi2, curry(succ ◦eval) ◦pi1, pi2)◦
pair(succ ◦zero, succ ◦zero)⟩⇒c.
From (R-NAT′
eval),
⟨pr(curry(pi2), curry(succ ◦eval)) ◦pi1,
pair(succ ◦zero, succ ◦zero)⟩⇒curry(e1) ◦c2
⟨e1, pair(c2, pi2 ◦pair(succ ◦zero, succ ◦zero))⟩⇒c
⟨eval, pair(pr(curry(pi2, curry(succ ◦eval) ◦pi1, pi2)◦
pair(succ ◦zero, succ ◦zero)⟩⇒c.
(2)
From (COMP),
⟨pi1, pair(succ ◦zero, succ ◦zero)⟩⇒c3
⟨pr(curry(pi2), curry(succ ◦eval)), c3⟩⇒curry(e1) ◦c2
⟨pr(curry(pi2), curry(succ ◦eval)) ◦pi1,
pair(succ ◦zero, succ ◦zero)⟩⇒curry(e1) ◦c2
(3)

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
94
From (R-NAT′
pi1),
⟨succ ◦zero, !⟩⇒c3
⟨pi1, pair(succ ◦zero, succ ◦zero)⟩⇒c3
,
and from (L-NATzero) and (L-NATsucc), c3 is
succ ◦zero ◦!.
Going back to (3), we need to calculate
⟨pr(curry(pi2), curry(succ ◦eval)), succ ◦zero ◦!⟩⇒curry(e1) ◦c2.
From (L-FACTsucc),
⟨curry(succ ◦eval) ◦pr(curry(pi2), curry(succ ◦eval)),
zero ◦!⟩⇒curry(e1) ◦c2
⟨pr(curry(pi2), curry(succ ◦eval)), succ ◦zero ◦!⟩⇒curry(e1) ◦c2
and from (COMP)
⟨pr(curry(pi2), curry(succ ◦eval)), zero ◦!⟩⇒c4
⟨curry(succ ◦eval), c4⟩⇒curry(e2) ◦c2
⟨curry(succ ◦eval) ◦pr(curry(pi2),
curry(succ ◦eval)), zero ◦!⟩⇒curry(e1) ◦c2
(4)
From (L-FACTzero),
⟨curry(pi2), !⟩⇒c4
⟨pr(curry(pi2), curry(succ ◦eval)), zero ◦!⟩⇒c4
and from (R-FACTcurry), c4 is ‘curry(pi2) ◦!’. Going back to (4), e1 is ‘succ ◦eval’ and
c2 is curry(pi2) ◦!. Therefore, going back to (2), we now have to calculate
⟨succ ◦eval, pair(curry(pi2) ◦!, pi2 ◦pair(succ ◦zero, succ ◦zero))⟩⇒c.
From (COMP),
⟨eval, pair(curry(pi2) ◦!,
pi2 ◦pair(succ ◦zero, succ ◦zero))⟩⇒c5
⟨succ, c5⟩⇒c
⟨succ ◦eval, pair(curry(pi2) ◦!,
pi2 ◦pair(succ ◦zero, succ ◦zero))⟩⇒c
(5)
From (R-NAT′
eval),
⟨curry(pi2) ◦!, !⟩⇒curry(e2) ◦c6
⟨e2, pair(c6, pi2 ◦pair(succ ◦zero, succ ◦zero))⟩⇒c5
⟨eval, pair(curry(pi2) ◦!, pi2 ◦pair(succ ◦zero, succ ◦zero))⟩⇒c5

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
95
From (R-FACT!) and (R-FACTcurry), e2 is ‘pi2’ and c6 is ‘! ◦!’, so we have
⟨pi2, pair(! ◦!, pi2 ◦pair(succ ◦zero, succ ◦zero))⟩⇒c5
From (R-NAT′
pi2),
⟨pi2 ◦pair(succ ◦zero, succ ◦zero), !⟩⇒c5
⟨pi2, pair(! ◦!, pi2 ◦pair(succ ◦zero, succ ◦zero))⟩⇒c5
From (COMP),
⟨pair(succ ◦zero, succ ◦zero), !⟩⇒c6
⟨pi2, c6⟩⇒c5
⟨pi2 ◦pair(succ ◦zero, succ ◦zero), !⟩⇒c5
From (R-FACTpair), c6 is
pair(succ ◦zero, succ ◦zero) ◦!,
so we have
⟨pi2, pair(succ ◦zero, succ ◦zero) ◦!⟩⇒c5
and (R-NAT′
pi2)
⟨succ ◦zero, !⟩⇒c5
⟨pi2, pair(succ ◦zero, succ ◦zero) ◦!⟩⇒c5
By using (L-NATzero) and (L-NATsucc), c5 is
succ ◦zero ◦!.
Now, we go back to (5) and we need to calculate
⟨succ, succ ◦zero ◦!⟩⇒c,
but this is straightforward from (L-NATsucc) and c is
succ ◦succ ◦zero ◦!.
Therefore, the reduction (1) is
⟨eval ◦pair(pr(curry(pi2), curry(succ ◦eval)) ◦pi1, pi2),
pair(succ ◦zero, succ ◦zero)⟩⇒succ ◦succ ◦zero ◦!
that is, we have shown ‘1 + 1’ is ‘2’ in CPL.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
96
4.3
Well-Deﬁnedness and Normalization Theorem
for Reduction Rules
In section 4.1, we discussed what is computation in CPL and obtained a set of reduction
rules (deﬁnition 4.1.7). Usual questions to be asked when we get reduction rules are,
ﬁrstly, whether they are well-deﬁned or not and, secondly, whether they are normalizing
or not. In this section, we will answer both questions aﬃrmatively.
Let us assume in this section that we are working in a CSL theory ⟨Γ, ∆, Ψ, Θ⟩which is
obtained by a sequence of CDT declarations, D1, . . . , Dl, each of which is a computable
object declaration.
First, we prove the well-deﬁnedness of the reduction rules.
Theorem 4.3.1: Well-Deﬁnedness Theorem: Let e ◦c be an element in ⟨Γ, ∆, Ψ⟩
and c be a canonical element. If from the rules listed in deﬁnition 4.1.7 we deduce
⟨e, c⟩⇒c′,
then c′ is a canonical element and e◦c = c′ holds in ⟨Γ, ∆, Ψ, Θ⟩(or in any CSL theory
structure of this).
Proof: We prove at the same time that for a canonical element c, a right functor R,
a functorial expression E productive in R which is more general than the type of c, if
the rules in deﬁnition 4.1.7 deduce
⟨c, E, R⟩; ⟨e, c′⟩,
then e is ψR(e1, . . . , em) for some e1, . . . , en, c′ is a canonical element and c = E[ψ(e1, . . . , em)/R]◦
c′ holds in ⟨Γ, ∆, Ψ, Θ⟩.
The proof is done by mathematical induction on the length of reduction, so all we have
to do is to check each reduction rule.
1. IDENT
⟨I, c⟩⇒c
It is trivial from I ◦c = c.
2. COMP
⟨e2, c⟩⇒c′′
⟨e1, c′′⟩⇒c′
⟨e1 ◦e2, c⟩⇒c′
From the induction hypothesis c′ is canonical and c′ = e1 ◦c′′ = e1 ◦e2 ◦c.
3. L-NAT
⟨αL,j, c⟩⇒αL,j ◦c
It is trivial since αL,j ◦c is a canonical element.
4. R-FACT
⟨ψR(e1, . . . , em), c⟩⇒ψR(e1, . . . , em) ◦c
It is again trivial since ψR(e1, . . . , em) ◦c is a canonical element.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
97
5. L-FACT
⟨ej ◦EL,j[ψL(e1, . . . , em)/L], c⟩⇒c′
⟨ψL(e1, . . . , em), αL,j ◦c⟩⇒c′
If αL,j ◦c is canonical, c is canonical, and from (LEQj)
ej ◦EL,j[ψL(e1, . . . , em)/L] ◦c = ψL(e1, . . . , em) ◦αL,j ◦c.
Therefore, the premise of the rule is well-formed, so from the induction hypothesis
c′ is canonical, and
c′ = ej ◦EL,j[ψL(e1, . . . , em)/L] ◦c = ψL(e1, . . . , em) ◦αL,j ◦c.
6. R-NAT
⟨c, ER,j, R⟩; ⟨ψR(e1, . . . , em), c′′⟩
⟨E′
R,j[ψR(e1, . . . , em)/R] ◦ej, c′′⟩⇒c′
⟨αR,j, c⟩⇒c′
Since αR,j can be composed with c and αR,j has the type ER,j →E′
R,j, c is an
element of a functorial expression not more general than ER,j. From the induction
hypothesis, c′′ is a canonical element and
ER,j[ψR(e1, . . . , em)/R] ◦c′′ = c.
Therefore,
αR,j ◦c
= αR,j ◦ER,j[ψR(e1, . . . , em)/R] ◦c′′
. . . . . . . . . . . . . . . . . . . . . . . . (from (REQj))
= E′
R,j[ψR(e1, . . . , em)/R] ◦ej ◦c′′
. . . . . . . . . . . . . . . . . . . . . . . (from hypothesis)
= c.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (from hypothesis)
7. R-NAT-V
⟨ψR(e1, . . . , em) ◦c′′, R, R⟩; ⟨ψR(e1, . . . , em), c′′⟩
R is a variable, so it is more general than anything, so the rule is well-formed.
Since ψR(e1, . . . , em) ◦c′′ is a canonical element, so is c′′.
8. R-NAT-F
R ∈Ei
Yi ∈E′
P,j
⟨ˆej, c⟩⇒c′
⟨c′, E′
P,j[Ei/Yi], R⟩; ⟨ψR(e1, . . . , em′), c′′⟩
⟨ψP(ˆe1, . . . , ˆem) ◦c, P(E1, . . . , En), R⟩;
⟨ψR(e1, . . . , em′), ψP(ˆe1 ◦EP,1[c/P], . . . ,
ˆej−1 ◦EP,j−1[c/P], c′′, ˆej+1 ◦EP,j+1[c/P], . . . , ˆem ◦EP,m[c/P])⟩
ψP(ˆe1, . . .) ◦c = ψP(ˆe1 ◦EP,1[c/P], . . .) and from the typing rule of ψP, ˆej ◦
EP,j[c/P] = ˆej◦c is an element of a functorial expression which is not more general

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
98
than E′
P,j[E1/Y1, . . .] which is not more general than E′
P,j[Ei/Yi]. Therefore, the
premises of the rule are well-formed and
ˆej ◦EP,j[c/P]
= ˆej ◦c
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (EP,j is simply P)
= c′
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (from ⟨ˆej, c⟩⇒c′)
= E′
P,j[Ei/Yi][ψR(e1, . . .)/R] ◦c′′.
. . . . . . . . . . .(from ⟨c′, E′
P,j[Ei/Yi], R⟩; . . .)
Therefore,
P(E1, . . .)[ψR(e1, . . .)/R] ◦ψP(ˆe1 ◦EP,1[c/P], . . . , c′′, . . .)
= ψP(αP,1, . . . , E′
P,j[Ei/Yi][ψR(e1, . . .)/R], . . .)
◦ψP(ˆe1 ◦EP,1[c/P], . . . , c′′, . . .)
. . . . . . . . . . . (expand P)
= ψP(ˆe1 ◦EP,1[c/P], . . . , E′
P,j[Ei/Yi][ψR(e1, . . .)/R] ◦c′′, . . .)
. . . . . . . . . . . . . . . . . . . . . . . . . . .(from 4.1.4 and (REQk))
= ψP(ˆe1 ◦EP,1[c/P], . . . , ˆej ◦EP,j[c/P], . . .)
. . . . . . . . . . . . . . . . . . . (from above)
= ψP(ˆe1, . . . , ˆem) ◦c.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .(from 4.1.4)
Of course, ψP(ˆe1 ◦EP,1[c/P], . . . , c′′, . . .) is a canonical element.
We have proved the theorem as well as shown the well-formedness of the reduction
rules. []
Next, we prove the normalization, that is to prove the following theorem.
Theorem 4.3.2: Normalization Theorem: For a canonical element c and a CSL
expression e whose domain is compatible with the codomain of c (i.e. we can have e ◦c
as an element), there is a canonical element c′ such that
⟨e, c⟩⇒c′
by the rules listed in deﬁnition 4.1.7. []
Before proving this theorem, we need some preparation. Note that the theorem proves
the two things together: the existence of c′ and the reducibility of ⟨e, c⟩⇒c′. Therefore,
from the existence part, we will have the following corollary.
Corollary 4.3.3: For any element e in ⟨Γ, ∆, Ψ⟩, there is a canonical element c such
that e = c holds in ⟨Γ, ∆, Ψ, Θ⟩. []
Showing the reducibility can be regarded as showing the termination of computation
in CPL. So, every program terminates in CPL. This is what we expected because we
only use primitive recursions.
First, we show a property of canonical elements.
Proposition 4.3.4: A canonical element of R(E1, . . . , En) for a right object R deﬁned
by (RC) has the following form.
ψR(e1, . . . , em) ◦c

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
99
where c is another canonical element.
On the other hand, a canonical element of L(E1, . . . , En) for a left object L deﬁned by
(LC) has the following form.
αL,j ◦c
where c is another canonical element.
Proof: A canonical element only consists of natural transformations of left objects
and factorizers of right objects. Therefore, a canonical element should look like either
αL,j ◦c
or
ψR(e1, . . . , em) ◦c.
From the typing rules in section 2.4, the ﬁrst one always gives an element of L(E1, . . . , En)
and the second one gives an element of R(E1, . . . , En). []
From this proposition, we can see that whenever we have
⟨e, c⟩
or
⟨c, E, R⟩
we can always apply exactly one of the rules in deﬁnition 4.1.7. In other words, the
computation in CPL is never stuck and deterministic. We can always proceed to the
next computation step.
We are going to prove the normalization theorem by the computability method due to
Tait [Tait 67]. This method is often used to show normalization of various systems
especially that of lambda calculi (see, for example, [Stenlund 72] and [Lambek and
Scott 86]) where two kinds of induction are used: induction on types and induction on
structures. The method usually goes for lambda calculi as follows:
1. Deﬁne the notion of computable terms inductively on types.
2. Show that any computable term is normalizable.
3. Show that all the terms are computable by induction on terms.
4. Therefore, any term is normalizable.
The notion of computable terms is stronger than that of normalizable terms, but we
need this stronger notion (which is a part of the essence of the Tait computability
method) to carry out the normalization proof. The computability predicate also divide
the two inductions involved in the proof clearly. In our case, the normalization proof
goes as follows.
1. We deﬁne the notion of computable canonical elements inductively on types. In-
tuitively, a canonical element c is computable if
(a) αL ◦c is computable if c is computable.
(b) ψR(e) ◦c is computable if there is a reduction ⟨αR, ψR(e) ◦c⟩⇒c′ such that
c′ is computable, that is all the components of ψR(e) ◦c are computable.
2. We deﬁne the notion of calculability for expressions (we could have called it
computability as well as is conventional in proofs about lambda calculi, but we
distinguish them for clarity). An expression e is calculable if for any computable
canonical element c there is a reduction ⟨e, c⟩⇒c′ such that c′ is computable.
Note that an expression e is normalizable if for any canonical element e there
is a reduction ⟨e, c⟩⇒c, whereas e is calculable if there is a reduction for any
computable canonical element. Therefore, it should be easier to prove that an
expression is calculable than to prove it is normalizable.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
100
3. We will prove that all the expressions are calculable by structural induction.
4. As an easy corollary, we can show that any canonical element is computable.
5. Finally, we prove that all the reductions are normalizing.
First, let us assign for each n-ary functor F a function which given sets C1 . . . , Cn
of canonical elements of type E1, . . . , En gives a set of canonical elements C of type
F(E1, . . . , En). We write ˜F for the function (i.e. C = ˜F(C1, . . . , Cn)). ˜F is monotonic
in the ith argument if F is covariant in the ith argument, and ˜F is anti-monotonic in
the ith argument if F is contravariant in the ith argument.
Deﬁnition 4.3.5:
1. For a left object2
left object L(X) with ψL is
αL: EL(L, X) →L
end object,
˜L(C) is the minimal ﬁxed point of the following monotonic function:
S 7−→{ αL ◦c | c ∈˜EL(S, C) }
The minimal ﬁxed point can be calculated as the least upper bound of the fol-
lowing ascending chain:
˜L0(C) ⊆˜L1(C) ⊆· · · ⊆˜Ln(C) ⊆˜Ln+1(C) ⊆· · · ⊆˜Lω(C) ⊆· · ·
where ˜L0(C) is ∅and
˜Lβ+1(C) def
= { αL ◦c | c ∈˜EL(˜Lβ(C), C) }.
2. For a right object
right object R(X) with ψR is
αR: R →E′
R(R, X)
end object,
˜R(C) is the maximal ﬁxed point of the following monotonic function:
S 7−→{ ψR(e) ◦c | ⟨αR, ψR(e) ◦c⟩⇒c′ such that c′ ∈˜E′
R(S, C) }
The maximal ﬁxed point can be calculated as the greatest lower bound of the
following descending chain:
˜R0(C) ⊇˜R1(C) ⊇· · · ⊇˜Rn(C) ⊇˜Rn+1(C) ⊇· · · ⊇˜Rω(C) ⊇· · ·
where ˜R0(C) is the set of all the canonical elements of R(E) (where C is a set of
canonical elements of type E) and
˜Rβ+1(C) def
= { ψR(e) ◦c |
⟨αR, ψR(e) ◦c⟩⇒c′ such that c′ ∈˜E′
R( ˜Rβ(C), C) }.
2For simplicity, we deﬁne this for a simple left object, but the general case should be obvious.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
101
3. For a right object3
right object R′(X) with ψR′ is
αR′: prod(R, ER′(X)) →E′
R′(R′, X)
end object,
˜R′(C) is the maximal ﬁxed point of the following monotonic function:
S 7−→{ ψR′(e) ◦c | For any c′ ∈˜ER′(C) ⟨αR′, pair(ψR′(e)◦c, c′)⟩⇒c′′
such that c′′ ∈˜E′
R′(S, C) }
We can similarly deﬁne ˜R′
β(C).
Well-deﬁnedness: We have to show that ˜F is monotonic or anti-monotonic according
to the variance of F. We prove this by induction on the order of declaration of objects.
1. If F is the left object L above and covariant, we show that ˜Lβ is monotonic by
induction on β. ˜L0 is trivially monotonic. ˜Lβ+1(C) is
{ αL ◦c | c ∈˜EL(˜Lβ(C), C) }.
From the induction hypothesis ˜Lβ is monotonic. Since EL(L, X) is covariant in
both L and X, from the other induction hypothesis ˜EL is monotonic. Therefore,
˜EL(˜Lβ(C), C) is monotonic in C, and ˜Lβ+1 is monotonic. Hence, ˜L is monotonic.
Similarly, we can show that ˜L is anti-monotonic if L is contravariant.
2. If F is the right object R above and covariant, we show that ˜Rβ is monotonic by
induction on β. ˜R0 is trivially monotonic. ˜Rβ+1(C) is
{ ψR(e) ◦c | ⟨αR, ψR(e) ◦c⟩⇒c′ ∧c′ ∈˜E′
R( ˜Rβ(C), C) }.
From the induction hypothesis, ˜Rβ is monotonic, and from the other induction
hypothesis, ˜E′
R is monotonic in both arguments. Therefore, ˜Rβ+1 is monotonic,
and by induction ˜R is monotonic. We can similarly show that ˜R is anti-monotonic
if R is contravariant.
3. If F is the right object R′ above and covariant, we show that ˜R′
β is monotonic
by induction on β. ˜R′
0 is trivially monotonic. ˜R′
β+1(C) is
{ ψR′(e) ◦c | ∀c′ ∈˜ER′(C) ⟨αR′, pair(ψR′(e) ◦c, c′)⟩⇒c′′ ∧
c′′ ∈˜E′
R′( ˜R′
β(C), C) }.
From the induction hypothesis, ˜R′
β is monotonic, and from the other induction hy-
pothesis, ˜ER′ is anti-monotonic and ˜E′
R′ is monotonic in both arguments. There-
fore, ˜R′
β+1 is monotonic, and by induction ˜R′ is monotonic. We can similarly
show that ˜R′ is anti-monotonic if R′ is contravariant. []
3For a right object R, since the domain of αR: ER(R, X) →E′
R(R, X) needs to be productive in R,
there are basically these two cases: when ER(R, X) is R and when it is prod(R, E′′(X)).

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
102
We now deﬁne the notion of computability and calculability.
Deﬁnition 4.3.6: The set ΩF(E1,...,En) of computable canonical elements of type F(E1, . . . , En)
is deﬁned inductively by ˜F(ΩE1, . . . , ΩEn). []
Deﬁnition 4.3.7: An CSL expression e of type E →E′ is called calculable with respect
to C →C′ for C ⊆ΩE and C′ ⊆ΩE′ if for any c in C there is a reduction ⟨e, c⟩⇒c′
such that c′ is in C′. When e is calculable with respect to ΩE →ΩE′, we simply say
that e is calculable. []
Example 4.3.8:
1. For the terminal object ‘1’
right object 1 with !
end object,
since there is no natural transformation, any canonical element is computable.
Let us use ⋆to denote an arbitrary element of ˜1.
2. For the left object ‘nat’ of natural numbers
left object nat with pr is
zero: 1 →nat
succ: nat →nat
end object,
g
nat0 is ∅. g
nat1 is
{ zero ◦c, succ ◦c′ | c ∈˜1 ∧c′ ∈g
nat0 } = { zero ◦⋆}.
Similarly g
nat2 consists of zero ◦⋆and succ ◦zero ◦⋆. In general, g
natn is the set
of n elements corresponding to a set of 0, 1, 2, . . . , and n −1. Therefore, g
nat is
the set of all the canonical elements of nat.
3. For the right object ‘prod’ of products
right object prod(X, Y ) with pair is
pi1: prod →X
pi2: prod →Y
end object,
a canonical element pair(e1, e2) ◦c is computable if there are reductions
⟨pi1, pair(e1, e2) ◦c⟩⇒c1
and
⟨pi2, pair(e1, e2) ◦c⟩⇒c2
such that c1 and c2 are computable, that is a canonical element of prod is com-
putable if its components are computable. Since the reductions above are equiv-
alent to ⟨e1, c⟩⇒c1 and ⟨e2, c⟩⇒c2, if c is computable and e1 and e2 are
calculable, pair(e1, e2) ◦c is computable.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
103
4. For the right object ‘exp’ of exponentials
right object exp(X, Y ) with curry is
eval: prod(exp, X) →Y
end object,
a canonical element curry(e) ◦c of type exp(E, E′) is computable, if for any
computable canonical element c′ of type E′ there is a reduction
⟨eval, pair(curry(e) ◦c, c′)⟩⇒c′′
and c′′ is computable. The reduction is equivalent to ⟨e, pair(c, c′)⟩⇒c′′. Since
pair(c, c′) is computable, there is such a reduction if e is calculable. Remember
that curry(e) corresponds to the closure of e (or lambda closed term of e) so that
we can say that a closure is calculable if the application with canonical elements
always results canonical elements. This exactly corresponds to the deﬁnition of
computability for lambda expressions (see [Stenlund 72]).
5. For the right object ‘inﬂist’ of inﬁnite lists
right object inﬂist(X) with fold is
head: inﬂist →X
tail: inﬂist →inﬂist
end object,
let us ﬁgure out the computable canonical elements of type inﬂist(nat).
g
inﬂist0(Ωnat)
is the set of all the canonical elements of type inﬂist(nat).
g
inﬂist1(Ωnat) is
{ fold(e1, e2) ◦c | ⟨head, fold(e1, e2) ◦c⟩⇒c1 ∧c1 ∈Ωnat ∧
⟨tail, fold(e1, e2) ◦c⟩⇒c2 ∧c2 ∈
g
inﬂist0(Ωnat) }
= { fold(e1, e2) ◦c | ⟨e1, c⟩⇒c1 ∧⟨fold(e1, e2) ◦e2, c⟩⇒c2 }.
Therefore, if e1 and e2 are calculable and c is computable, fold(e1, e2) ◦c is
in
g
inﬂist1(Ωnat). We can inductively show that it is in any
g
inﬂistβ(Ωnat), and,
therefore, it is in
g
inﬂist(Ωnat).
6. For the left object of ordinals
left object ord with pro is
ozero: 1 →ord
sup: exp(nat, ord) →ord
end object,
g
ord0 is empty, g
ord1 is { ozero ◦⋆}, and
g
ord2
= { sup ◦c, ozero ◦⋆| c ∈g
exp(g
nat, g
ord1) }
= { sup ◦curry(e) ◦c, ozero ◦⋆| ∀c′ ∈g
nat ⟨e, pair(c, c′)⟩⇒c′′ ∧
c′′ ∈g
ord1 }
= { sup ◦curry(e) ◦c, ozero ◦⋆| ∀c′ ∈Ωnat ⟨e, pair(c, c′)⟩⇒ozero ◦⋆}.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
104
In general,
g
ordβ+1 = { sup ◦curry(e) ◦c, ozero ◦⋆|
∀c′ ∈Ωnat ⟨e, pair(c, c′)⟩⇒c′′ ∧c′′ ∈g
ordβ }
Therefore, a canonical element sup ◦curry(e) ◦c is computable if the following
reductions always exist:
⟨e, pair(c, c1)⟩⇒sup ◦curry(e1) ◦c′
1
⟨e1, pair(c′
1, c2)⟩⇒sup ◦curry(e2) ◦c′
2
⟨e2, pair(c′
2, c3)⟩⇒sup ◦curry(e3) ◦c′
3
· · ·
⟨eβ, pair(c′
β, cβ+1)⟩⇒ozero ◦⋆
[]
The next proposition intuitively means that functors preserve the structure of data.
For example, when the functor ‘list’ (or map in ML and MAPCAR in LISP) is applied to
a list, it only changes the components of the list and preserves the length.
Proposition 4.3.9: Let F be n-ary functor, and e1, . . . , en be CSL expressions cal-
culable with respect to Ci →C′
i.
Then F(e1, . . . , en) is calculable with respect to
˜F(C′′
1, . . . , C′′
n) →˜F(C′′′
1 , . . . , C′′′
n ), where C′′
i is Ci and C′′′
i is C′
i if F is covariant in the
ith argument and C′′
i is C′
i and C′′′
i is Ci if F is contravariant in the ith argument.
Proof: We prove this by induction on the order of declarations of objects.
1. Let F be a left object declared by
left object L(X) with ψL is
αL: EL(L, X) →L
end object
which is covariant in X, e be a CSL expression which is calculable with respect
to C →C′. We prove that L(e) is calculable with respect to ˜Lβ(C) →˜Lβ(C′)
by induction on β. Trivially, L(e) is calculable with respect to ˜L0(C) →˜L0(C)
because ˜L0(C) is empty. Assume we have proved that L(e) is calculable with
respect to ˜Lβ(C) →˜Lβ(C′). An element of ˜Lβ+1(C) is αL ◦c such that c ∈
˜EL(˜Lβ(C), C). From L-FACT we get
⟨αL ◦EL(I, e) ◦EL(L(e), I), c⟩⇒c′
⟨αL ◦EL(I, e) ◦EL(ψL(αL ◦EL(I, c)), I), c⟩⇒c′
⟨ψL(αL ◦EL(I, e)), αL ◦c⟩⇒c′
⟨L(e), αL ◦c⟩⇒αL ◦c′
Since EL(L, X) consists of functors declared before L, from the induction hypoth-
esis, EL(L(e), I) is calculable with respect to ˜EL(˜Lβ(C), C) →˜EL(˜Lβ(C′), C) and
EL(I, e) is calculable with respect to ˜EL(˜Lβ(C′), C) →˜EL(˜Lβ(C′), C′). There-
fore, there is a reduction
⟨EL(I, e) ◦EL(L(e), I), c⟩⇒c′

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
105
such that c′ is in ˜EL(˜Lβ(C′), C′). From deﬁnition 4.3.5, αL ◦c′ is in ˜Lβ+1(C′).
Hence, L(e) is calculable with respect to ˜Lβ+1(C) →˜Lβ+1(C′). By induction,
L(e) is calculable with respect to ˜Lβ(C) →˜Lβ(C′) for any β, and, therefore, L(e)
is calculable with respect to ˜L(C) →˜L(C′). When L(X) is contravariant, we can
similarly prove that L(e) is calculable with respect to ˜L(C′) →˜L(C).
2. Let F be a right object declared by
right object R(X) with ψR is
αR: R →E′
R(R, X)
end object
which is covariant, and e be a CSL expression which is calculable with respect to
C →C′. We prove that R(e) is calculable with respect to ˜Rβ(C) →˜Rβ(C′) by
induction on β. From R-FACT, we have
⟨R(e), c⟩⇒ψR(E′
R(I, e) ◦αR) ◦c.
Trivially, R(e) is calculable with respect to ˜R0(C) →˜R0(C′) because ˜R0(C′) is
the set of all the canonical elements of R. Assume we have proved that R(e) is
calculable with respect to ˜Rβ(C) →˜Rβ(C′). An element of ˜Rβ+1(C) is ψR(e′)◦c′
such that there is a reduction ⟨αR, ψR(e′) ◦c′⟩⇒c′′ and c′′ is in ˜E′
R( ˜Rβ(C), C).
We will show that the following canonical element is in ˜Rβ+1(C′):
ψR(E′
R(I, e) ◦αR) ◦ψR(e′) ◦c′
(∗)
From R-NAT, we have
⟨E′
R(R(e), I) ◦E′
R(I, e), c′′⟩⇒c′′′
⟨E′
R(R(e), I) ◦E′
R(I, e) ◦αR, ψR(e′) ◦c′⟩⇒c′′′
⟨E′
R(ψR(E′
R(I, c) ◦αR), I), E′
R(I, e) ◦αR, ψR(e′) ◦c′⟩⇒c′′′
⟨αR, ψR(E′
R(I, e) ◦αR) ◦ψR(e′) ◦c′⟩⇒c′′′
Since E′
R(R, X) consists of functors declared before R, E′
R(R(e), I) ◦E′
R(I, e) is
calculable with respect to ˜E′
R( ˜Rβ(C), C) →˜E′
R( ˜Rβ(C′), C′) from the induction
hypothesis. Therefore, c′′′ is in ˜E′
R( ˜Rβ(C′), C′), and from deﬁnition 4.3.5, (∗) is
in ˜Rβ+1(C). Therefore, by induction, R(e) is calculable with respect to ˜Rβ(C) →
˜Rβ(C′) for any β, so it is calculable with respect to ˜R(C) →˜R(C′). When R(X)
is contravariant, we can similarly prove that R(e) is calculable with respect to
˜R(C′) →˜R(C).
3. If F be a right object declared by
right object R′(X) with ψR′ is
αR′: prod(R′, ER′(X)) →E′
R(R, X)
end object,
we can similarly prove that R(e) is calculable with respect to ˜R(C) →˜R(C′) (or
with respect to ˜R(C′) →˜R(C) when R(X) is contravariant). []

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
106
In the following few lemmas, we are to prove all the expressions are calculable.
Lemma 4.3.10: I is calculable.
Proof: We have to show that for any computable canonical element c there is a
reduction of ⟨I, c⟩⇒c′ and that c′ is computable. This is immediate from the reduction
rule IDENT and that c′ is c []
Lemma 4.3.11: If both e1 and e2 are calculable, so is e1 ◦e2.
Proof: For any computable canonical element c’ we have the following reduction from
COMP:
⟨e2, c⟩⇒c′′
⟨e1, c′′⟩⇒c′
⟨e1 ◦e2, c⟩⇒c′
Since e2 is calculable, there is a reduction for ⟨e2, c⟩⇒c′′ so that c′′ is computable.
Since e1 is calculable, there is a reduction for ⟨e1, c′′⟩⇒c′ so that c′ is computable.
Therefore, there is a reduction for ⟨e1 ◦e2, c⟩⇒c′ so that c′ is computable. []
Lemma 4.3.12: For any natural transformation αL of a left object L, αL is calculable.
Proof: For any computable canonical element c, we have the following reduction by
L-NAT:
⟨αL, c⟩⇒αL ◦c
From deﬁnition 4.3.6, αL ◦c is computable. Therefore, αL is calculable. []
Lemma 4.3.13: For any natural transformation αR of a right object R, αR is calcu-
lable.
Proof: Let R be
right object R(X) with ψR is
αR: R →E′
R(R, X)
end object,
and c be a computable canonical element R(E). For any β, c is in ˜Rβ+1(ΩE). From
deﬁnition 4.3.5, there exists a reduction ⟨αR, c⟩⇒c′ such that c′ is in ˜E′
R( ˜Rβ(ΩE), ΩE).
Because the result of reductions does not depend on β, c′ is in
˜E′
R(
\
β
˜Rβ(ΩE), ΩE) = ˜E′
R( ˜R(ΩE), ΩE) = ΩE′
R(R(E),E).
Therefore, αR is calculable. We can similarly prove that for a right object
right object R′(X) with ψR′ is
αR′: prod(R′, ER′(X)) →E′
R′(R′, X)
end object,
αR′ is calculable. []
Lemma 4.3.14: If e is calculable, so is ψL(e) where L is a left object and ψL is its
factorizer.

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
107
Proof: Let L be
left object L(X) with ψL is
αL: EL(L, X) →L
end object,
and e: EL(E, E′) →E be a calculable CSL expression. We will prove that ψL(e) is
calculable with respect to ˜Lβ(ΩE′) →ΩE by induction on β. Trivially, it is calculable
with respect to ˜L0(ΩE′) →ΩE because ˜L0(ΩE′) is empty. Assume we have proved that
ψL(e) is calculable with respect to ˜Lβ(ΩE′) →ΩE. An element in ˜Lβ+1(ΩE′) is αL ◦c
for c which is in ˜EL(˜Lβ(ΩE′), ΩE′). From L-FACT, we get
⟨EL(ψL(e), I), c⟩⇒c′′
⟨e, c′′⟩⇒c′
⟨e ◦EL(ψL(e), I), c⟩⇒c′
⟨ψL(e), αL ◦c⟩⇒c′
From proposition 4.3.9 and the induction hypothesis, EL(ψL(e), I) is calculable with re-
spect to ˜EL(˜Lβ(ΩE′), ΩE′) →˜EL(ΩE, ΩE′), and there is a reduction ⟨EL(ψL(e), I), c⟩⇒
c′′. Since e is calculable, there is a reduction ⟨e, c′′⟩⇒c′ such that c′ is in ΩE. Therefore,
ψR(e) is calculable with respect to ˜Lβ+1(ΩE′) →ΩE, and by induction it is calculable
with respect to ˜Lβ(ΩE′) →ΩE for any β. Because ΩL(E′) = ˜L(ΩE′) is S
β ˜Lβ(ΩE′), we
have proved that ψL(e) is calculable. []
Lemma 4.3.15: If e is calculable, so is ψR(e) where R is a right object and ψR is its
factorizer.
Proof: Let R be
right object R(X) with ψR is
αR: R →E′
R(R, X)
end object,
and e be a CSL expression of type E →E′
R(E, E′). We are to prove that ψR(e): E →
R(E′) is calculable.
Since ΩR(E′) = ˜R(ΩE′) is T
β ˜Rβ(ΩE′), we prove that ψR(e) is
calculable with respect to ΩE →˜Rβ(ΩE′) by induction on β. Trivially, it is calculable
with respect to ΩE →˜R0(ΩE′) because for any c ∈ΩE we have ⟨ψR(e), c⟩⇒ψR(e) ◦c
and ˜R0(ΩE′) is the set of all the canonical elements of type R(E′). Assume we have
proved that ψR(e) is calculable with respect to ΩE →˜Rβ(ΩE′). For any c ∈ΩE we
have ⟨ψR(e), c⟩⇒ψR(e) ◦c. From R-NAT, we get
⟨e, c⟩⇒c′′
⟨E′
R(ψR(e), I), c′′⟩⇒c′
⟨αR, ψR(e) ◦c⟩⇒c′
.
Since e is calculable, there is a reduction ⟨e, c⟩⇒c′′ and c′′ is in ˜E′
R(ΩE, ΩE′). As
we assumed that ψR(e) is calculable with respect to ΩE →˜Rβ(ΩE′), E′
R(ψR(e), I) is
calculable with respect to ˜E′
R(ΩE, ΩE′) →˜E′
R( ˜Rβ(ΩE′), ΩE′) from proposition 4.3.9.
Therefore, there is a reduction ⟨E′
R(ψR(e), I)c′′⟩⇒c′ and c′ is in ˜E′
R( ˜Rβ(ΩE′), ΩE′).
From deﬁnition 4.3.5, ψR(e) ◦c is in ˜Rβ+1(ΩE′), so ψR(e) is calculable with respect
to ΩE →˜Rβ+1(ΩE′), and by induction it is calculable with respect to ΩE →˜Rβ(ΩE′)
for any β. Therefore, it is calculable with respect to ΩE →˜R(ΩE′). We can similarly

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
108
prove that for a right object
right object R′(X) with ψR′ is
αR′: prod(R′, ER′(X)) →E′
R′(R′, X)
end object,
ψR′(e) is calculable. []
Theorem 4.3.16: Any CSL expression e is calculable.
Proof: This is proved by structural induction and each case follows from the lemmas,
4.3.10, 4.3.11, 4.3.12, 4.3.13, 4.3.14 and 4.3.15. []
Corollary 4.3.17: Any canonical element is computable.
Proof: As a canonical element c is a CSL expression, and therefore, from theo-
rem 4.3.16 it is calculable. Because any canonical element of the terminal object 1
is computable, specially I is computable. Therefore, there is a reduction ⟨c, I⟩⇒c′
such that c′ is computable. Trivially, c′ is c (using L-NAT, R-FACT and COMP), so c
is computable. []
We now ﬁnish this section by proving the normalization theorem.
Proof of Normalization 4.3.2: From theorem 4.3.16, any expression e is calculable,
and from corollary 4.3.17, any canonical element is computable. Therefore, from the
deﬁnition 4.3.7 of calculable expressions, there is a reduction ⟨e, c⟩⇒c′. []
4.4
Properties of Computable Objects
In section 4.1, we saw that we have to restrict ourselves to computable objects (deﬁni-
tion 4.1.6) in order to introduce our notion of computability into CDT. Let us see in
this section some of the properties which these particular objects enjoy.
First, we show that computable left objects are ﬁxed points of some domain equations.
Theorem 4.4.1: Let L be a computable left object declared as follows.
left object L(X1, . . . , Xn) with ψL is
αL,1: EL,1(L, X1, . . . , Xn) →L
· · ·
αL,m: EL,m(L, X1, . . . , Xn) →L
end object
Then, the following isomorphism holds in any CSL structure which has L and coprod-
ucts.
L(X1, . . . , Xn) ∼=
m
X
j=1
EL,j(L(X1, . . . , Xn), X1, . . . , Xn)

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
109
where Pm
j=1 is the m-ary coproduct. Furthermore, if A is an object which satisﬁes
A ∼=
m
X
j=1
EL,j(A, X1, . . . , Xn),
there is a unique morphism h from L(X1, . . . , Xn) to A such that the following diagram
commutes.
m
X
j=1
EL,j(A, X1, . . . , Xn)
∼=
A
m
X
j=1
EL,j(h, X1, . . . , Xn)
¥
¨§?
h
m
X
j=1
EL,j(L(X1, . . . , Xn), X1, . . . , Xn)
∼=
L(X1, . . . , Xn)
-
-
?
?
Proof: For simplicity, we prove the isomorphism in case L does not have any param-
eters (i.e. n = 0). Therefore, the isomorphism we prove is
L ∼=
m
X
j=1
EL,j(L).
Let f be a morphism
[αL,1, . . . , αL,m]
where [ , . . . , ] is the factorizer of Pm
j=1. f is a morphism from Pm
j=1 EL,j(L) to L. Let
g be a morphism
ψL(ν1 ◦EL,1(f), . . . , νm ◦EL,m(f))
where νj is the j-th injection of Pm
j=1 . g is a morphism from L to Pm
j=1 EL,j(L). We
show that f is the inverse of g. Let us ﬁrst show that f ◦g = I.
f ◦g ◦αL,j
= f ◦νj ◦EL,j(f) ◦EL,j(g) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (from (LEQj))
= αL,j ◦EL,j(f) ◦EL,j(g)
= αL,j ◦EL,j(f ◦g). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .(EL,j(L) is covariant)
From (LCEQ),
f ◦g = ψR(αL,1, . . . , αL,m) = I.
The second equality holds again from (LCEQ). Next we show that g ◦f = I.
g ◦f
= [g ◦αL,1, . . . , g ◦αL,m]
= [ν1 ◦EL,1(f ◦g), . . . , νm ◦EL,m(f ◦g)]
= [ν1 ◦EL,1(I), . . . , νm ◦EL,m(I)]
= [ν1, . . . , νm]
= I

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
110
Therefore, L ∼=
Pm
j=1 EL,j(L). For any object A which satisﬁes A ∼=
Pm
j=1 EL,j(A), let
i be the isomorphism from Pm
j=1 EL,j(A) to A, then the unique morphism is given by
ψR(i ◦ν1, . . . , i ◦νm).
It is easy to see the diagram commutes from (LEQj) and the uniqueness from (LCEQ). []
If we apply this theorem to the objects we deﬁned in chapter 3, we get the following
isomorphisms.
nat ∼= 1 + nat
list(X) ∼= 1 + prod(X, list(X))
We can see the exact correspondence to domain theory. In domain theory, the domain
of natural numbers and that of lists are deﬁned as the minimal domains which satisﬁes
the above isomorphisms.
By duality principle, we have the dual theorem of theorem 4.4.1.
Theorem 4.4.2: Let R be a computable right object declared as follows.
right object R(X1, . . . , Xn) with ψR is
αR,1: R →E′
R,1(R, X1, . . . , Xn)
· · ·
αR,m: R →E′
R,m(R, X1, . . . , Xn)
end object
Then, the following isomorphism holds in any CSL structure which has R and products.
R(X1, . . . , Xn) ∼=
m
Y
j=1
E′
R,j(R(X1, . . . , Xn), X1, . . . , Xn)
where Qm
j=1 is the m-ary product. Furthermore, if A is an object which satisﬁes
A ∼=
m
Y
j=1
E′
R,j(A, X1, . . . , Xn),
there is a unique morphism h from A to R(X1, . . . , Xn) such that the following diagram
commutes.
R(X1, . . . , Xn)
A
h
∼=
∼=
¥
¨§?
m
Y
j=1
E′
R,j(R(X1, . . . , Xn), X1, . . . , Xn)
m
Y
j=1
E′
R,j(h, X1, . . . , Xn)
m
Y
j=1
E′
R,j(A, X1, . . . , Xn)
-
-
?
?
Proof: By duality. []

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
111
We can see that the inﬁnite list deﬁned in subsection 3.3.6 is the maximal ﬁxed point
of the following domain equation.
inﬂist(X) ∼= X × inﬂist(X)
The next theorem states that productive objects deﬁne products.
Theorem 4.4.3: Let P(Y1, . . . , Yn) be a functor which is productive in Yi. Then, there
is a functor F(Y1, . . . , Yi−1, Yi+1, . . . , Yn) such that
P(Y1, . . . , Yn) ∼= Yi × F(Y1, . . . , Yi−1, Yi+1, . . . , Yn)
Proof: First, note that it is easy to extend the theorem to productive functorial
expressions by simply applying the theorem repeatedly. Let us prove the theorem by
induction on the order of declaration of productive objects. Let the declaration of P
to be as follows.
right object P(Y1, . . . , Yi, . . . , Yn) with ψP is
αP,1: EP,1(P, Y1, . . . , Yi−1, Yi+1, . . . , Yn) →E′
P,1(Y1, . . . , Yi−1, Yi+1, . . . , Yn)
· · ·
αP,j: P →E′
P,j(Y1, . . . , Yi−1, Yi, Yi+1, . . . , Yn)
· · ·
αP,m: EP,m(P, Y1, . . . , Yi−1, Yi+1, . . . , Yn) →E′
P,m(Y1, . . . , Yi−1, Yi+1, . . . , Yn)
end object
By induction hypothesis and from what we note at the beginning of the proof, there is
a functor F ′(Y1, . . . , Yi−1, Yi+1, . . . , Yn) such that
E′
P,j(Y1, . . . , Yn) ∼= Yi × F ′(Y1, . . . , Yi−1, Yi+1, . . . , Yn).
Since P is a computable object as well, EP,k(P, Y1, . . . , Yi−1, Yi+1, . . . , Yn) is productive
in P. Therefore, from induction hypothesis there are functors
Gk(Y1, . . . , Yi−1, Yi+1, . . . , Yn)
such that
EP,k(P, Y1, . . . , Yi−1, Yi+1, . . . , Yn) ∼= P × Gk(Y1, . . . , Yi−1, Yi+1, . . . , Yn).
Using exponentials, the above deﬁnition of P is essentially the same as
right object P(Y1, . . . , Yi, . . . , Yn) with ψP is
αP,1: P →exp(G1(Y1, . . . , Yi−1, Yi+1, . . . , Yn),
E′
P,1(Y1, . . . , Yi−1, Yi+1, . . . , Yn))
· · ·
αP,j: P →Yi × F ′(Y1, . . . , Yi−1, Yi+1, . . . , Yn)
· · ·
αP,m: P →exp(Gm(Y1, . . . , Yi−1, Yi+1, . . . , Yn),
E′
P,m(Y1, . . . , Yi−1, Yi+1, . . . , Yn))
end object

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
112
From theorem 4.4.2, we have
P(Y1, . . . , Yn) ∼= Yi × F ′(Y1, . . .) ×
m
Y
k=1
k̸=j
exp(Gk(Y1, . . .), E′
P,k(Y1, . . .)).
F ′(Y1, . . .)×Qm
k=1
k̸=j exp(Gk(Y1, . . .), E′
P,k(Y1, . . .)) does not depend on Yi. We have proved
the theorem. []
From this theorem, we can always make the declaration of computable objects into
an equivalent declaration to which we can apply theorem 4.4.2.
For example, the
declaration of the object for automata in subsection 3.3.7 was
right object dyn′(I, O) with univ′ is
next′: prod(dyn′, I) →dyn′
output′: dyn′ →O
end object
to which we cannot apply theorem 4.4.2, but the above declaration is equivalent to the
following one.
right object dyn′(I, O) with univ′ is
next′: dyn′ →exp(I, dyn′)
output′: dyn′ →O
end object
Then, from theorem 4.4.2 we can see dyn′(I, O) as the maximal ﬁxed point of the
following domain equation.
dyn′(I, O) ∼= exp(I, dyn′(I, O)) × O
4.5
Reduction Rules for Full Evaluation
In section 4.1 we presented a set of reduction rules which can reduce any element to a
canonical element. However, the notion of canonical element (deﬁnition 4.1.3) was quite
weak (or sloppy), and the canonical elements we get out of reductions sometimes not
acceptable as ‘canonical’. We can deﬁne a more reﬁned notion of canonical elements.
Deﬁnition 4.5.1: A canonical element is called uncondition, if it is generated by the
following rule.
p : : = I | αL,j ◦p | ψR(e1, . . . , em) ◦p | ψC(. . . , ej, . . . , pk, . . .)
where R is not a unconditioned right object, C is a unconditioned object
right object C(X1, . . . , Xn) with ψC is
· · ·
αC,j: EC,j(C, X1, . . . , Xn) →E′
C,j(X1, . . . , Xn)
· · ·
αC,k: C →E′
C,k(X1, . . . , Xn)
· · ·
end object

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
113
and if EC,k(C, X1, . . . , Xn) is simply C then the kth argument of ψC needs to be a
unconditioned canonical element. []
For example,
pair(succ, I) ◦zero
and
pair(pi1 ◦pair(succ ◦zero, nil), zero)
are canonical elements but not unconditioned. Their equivalent unconditioned canon-
ical element is ‘pair(succ ◦zero, zero)’.
We can deﬁne reduction rules which only produce unconditioned canonical elements as
result.
Deﬁnition 4.5.2: The form of reduction rules is
⟨e, p⟩⇒⇒p′
where e is a CSL expression and p is a unconditioned canonical element whose domain
is compatible with the domain of e.
1. FULL-IDENT
⟨I, p⟩⇒⇒p
2. FULL-COMP
⟨e2, p⟩⇒⇒p′′
⟨e1, p′′⟩⇒⇒p′
⟨e1 ◦e2, p⟩⇒⇒p′
3. FULL-L-NAT
⟨αL,j, p⟩⇒⇒αL,j ◦p
4. FULL-R-FACT
⟨ψR(e1, . . . , em), p⟩⇒⇒ψR(e1, . . . , em) ◦p
where R is not a unconditioned right object.
5. FULL-C-FACT
⟨ej, p⟩⇒⇒e′
j
or
e′
j ≡ej ◦EC,j[p/C]
⟨ψC(e1, . . . , em), p⟩⇒⇒ψC(e′
1, . . . , e′
m)
where C is a unconditioned right object and e′
j is either the result of evaluating
⟨ej, p⟩or ej ◦EC,j[p/C] depending of whether EC,j is simply C or not.
6. FULL-L-FACT
⟨ej ◦EL,j[ψL(e1, . . . , em)/L], p⟩⇒⇒p′
⟨ψL(e1, . . . , em), αL,j ◦p⟩⇒⇒p′

CHAPTER 4. COMPUTATION AND CATEGORICAL DATA TYPES
114
7. FULL-R-NAT
⟨E′
R,j[ψR(e1, . . . , em)/R] ◦ej, ψP(. . . , p, . . .)⟩⇒⇒p′
⟨αR,j, ψP(. . . , ψR(e1, . . . , em) ◦p, . . .)⟩⇒⇒p′
In writing down this rule, ψP(. . . , ψR(e1, . . . , em) ◦p, . . .) is rather inaccurate. It
means picking up ψR(e1, . . . , em) according to the occurrence of R in ER,j. ψP’s
are nested as productive objects P’s are in ER,j. For example, the rule for ‘pi1’
of object ‘prod’ is
⟨p1, I⟩⇒⇒p′
⟨pi1, pair(p1, p2)⟩⇒⇒p′
.
Eprod,1 is simply ‘prod’, so there is no ψC’s. The rule for ‘eval’ of object ‘exp’ is
⟨e, pair(I, p)⟩⇒⇒p′
⟨eval, pair(curry(e), p)⟩⇒⇒p′
.
Remember that Eexp,1 is ‘prod(exp, X)’.
Let us call the new system FULL and the previous system deﬁned in deﬁnition 4.1.7
LAZY. []
As we have proved theorem 4.3.1, we can easily show that FULL system is well-deﬁned.
In addition, we can show that the reduction in FULL system is stronger than that in
LAZY system, that is,
Proposition 4.5.3: If ⟨e, p⟩⇒⇒p′ in FULL system, then ⟨e, p⟩⇒c′ in LAZY sys-
tem. []
On the other hand, since a FULL reduction is nothing but the repeated application of
LAZY reductions, we have the normalization theorem.
Theorem 4.5.4: For a unconditioned canonical element p and a CSL expression e
whose domain is compatible with the codomain of p, there is a unconditioned canonical
element p′ such that
⟨e, p⟩⇒⇒p′
in FULL reduction system. []

Chapter 5
Application of Categorical Data
Types
In this chapter we see some applications of CDT and CPL. We have concentrated on
category theory in the previous chapters and it is sometimes hard to relate our results
to others if they are not familiar with category theory. The author is not claiming that
it is better to use category theory in practice. Category theory is used as a guiding
principle to see things without being obscured by inessentials. Therefore, once one
establishes some results using category theory, it is very interesting to see what it
means in other terms and we might get some deep insight.
In section 5.1, we will see an implementation of CPL. In section 5.2, we will examine the
connection between CDT and typed lambda calculi and in section 5.3 we will propose
a new ML which is obtained by combining the current ML and CPL.
5.1
An implementation of
Categorical Programming Language
In chapter 4, we introduced a programming language CPL and its computation rules.
A CPL system has been implemented using Franz Lisp. In the section, we will demon-
strate the system and see some examples of reductions which it can manage.
When the system is started, it prints the following message and waits for user com-
mands.
Categorical Programming Language (version 3)
cpl>
First, we have to declare some objects because the system does not know any objects
when it is started. The very ﬁrst object we declare is the terminal object. We use edit
command to enter its declaration.
115

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
116
cpl>edit
| right object 1 with !
| end object;
right object 1 defined
cpl>
Note that user inputs are in italic font. We deﬁne products, exponentials and natural
number object as well.
The declarations are exactly the same as we presented in
chapter 3 (except that to make output shorter we use ‘s’ for successor and ‘0’ for zero).
cpl>edit
| right object prod(a,b) with pair is
|
pi1: prod -> a
|
pi2: prod -> b
| end object;
right object prod(+,+) defined
cpl>edit
| right object exp(a,b) with curry is
|
eval: prod(exp,a) -> b
| end object;
right object exp(-,+) defined
cpl>edit
| left object nat with pr is
|
0: 1 -> nat
|
s: nat -> nat
| end object;
left object nat defined
cpl>edit
| left object coprod(a,b) with case is
|
in1: a -> coprod
|
in2: b -> coprod
| end object;
left object coprod(+,+) defined
cpl>
Each time we declare an object the system remembers its factorizer and natural trans-
formations as well as the functor associated with. In the above transaction, ‘prod(+,+)’
indicates that system recongnized ‘prod’ as a covariant functor of two arguments
whereas ‘exp(-,+)’ indicates that ‘exp’ is a functor which is contravariant in the ﬁrst
argument and covariant in the second. The variance is calculated as we formulated in
section 3.2. The system can type CSL expressions using the rules in section 2.4. For
example, we can ask the type of ‘pair(pi2,eval)’.
cpl>show pair(pi2,eval)
pair(pi2,ev)
: prod(exp(*b,*a),*b) -> prod(*b,*a)
cpl>
where ‘*a’ and ‘*b’ are variables for objects, or we can see them as a kind of type
variables in ML; ‘pair(pi2,eval)’ is a polymorphic function in this sense.
As we have done in section 4.2, we can ask to the system to calculate ‘1+1’ using ‘simp’
command.
cpl>simp eval.pair(pr(curry(pi2),curry(s.eval)).pi1,pi2).pair(s.0,s.0)

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
117
s.s.0
:1 -> nat
cpl>
Note that the composition ‘◦’ is typed as ‘.’. The system applied reduction rules to
get the following reduction:
⟨eval.pair(. . .).pair(s.0, s.0), I⟩⇒s.s.0.
We can see how the system deduced the reduction by enabling the trace mode.
cpl>set trace on
cpl>simp eval.pair(pr(curry(pi2),curry(s.eval)).pi1,pi2).pair(s.0,s.0)
0:eval.pair(pr(curry(pi2),curry(s.eval)).pi1,pi2).pair(s.0,s.0)*
1:eval.pair(pr(curry(pi2),curry(s.eval)).pi1,pi2)*pair(s.0,s.0)
2:eval*pair(pr(curry(pi2),curry(s.eval)).pi1,pi2).pair(s.0,s.0)
3[1]:pr(curry(pi2),curry(s.eval)).pi1*pair(s.0,s.0)
4[1]:pr(curry(pi2),curry(s.eval)).s.0*id
5[1]:pr(curry(pi2),curry(s.eval)).s*0
6[1]:pr(curry(pi2),curry(s.eval))*s.0
7[1]:curry(s.eval).pr(curry(pi2),curry(s.eval))*0
8[1]:curry(s.eval).curry(pi2).!*
9[1]:curry(s.eval).curry(pi2)*!
10[1]:curry(s.eval)*curry(pi2).!
11[1]:*curry(s.eval).curry(pi2).!
12:s.eval*pair(curry(pi2).!,pi2.pair(s.0,s.0))
13[1]:curry(pi2).!*
14[1]:curry(pi2)*!
15[1]:*curry(pi2).!
16:s.pi2*pair(!,pi2.pair(s.0,s.0))
17:s.pi2.pair(s.0,s.0)*id
18:s.pi2*pair(s.0,s.0)
19:s.s.0*id
20:s.s*0
21:s*s.0
22:*s.s.0
s.s.0
:1 -> nat
cpl>
Each line has the following form:
step number [ depth of computation ]: expression ∗canonical element
It indicates the following reduction:
⟨expression , canonical element ⟩⇒. . .
Step 0 denotes the reduction of
⟨eval.pair(pr(curry(pi2), curry(s.eval)).pi1, pi2).pair(s.0, s.0), I⟩⇒. . ..
(+)
Step 1 is obtained from R-FACT rule (and R-COMP); the reduction (+) is the same
as the reduction of
⟨eval.pair(pr(curry(pi2), curry(s.eval)).pi1, pi2), pair(s.0, s.0)⟩⇒. . ..

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
118
Again from R-FACT, this reduction is the same as
⟨eval, pair(pr(curry(pi2), curry(s.eval)).pi1, pi2).pair(s.0, s.0)⟩⇒. . ..
(++)
which is step 2. From R-NAT, we have to calculate
⟨pair(pr(curry(pi2), curry(s.eval)).pi1, pi2).pair(s.0, s.0),
prod(exp, a), exp⟩; ⟨curry(. . .), . . .⟩.
In order to do this, from R-NAT-F we have to calculate
⟨pr(curry(pi2), curry(s.eval)).pi1, pair(s.0, s.0)⟩⇒. . .
(†)
This reduction is carried out from step 3 to step 12 and we get
⟨pr(curry(pi2), curry(s.eval)).pi1, pair(s.0, s.0)⟩⇒curry(s.eval).curry(pi2).!.
Note that from step 3 to 4 it did the reduction
⟨pi1, pair(s.0, s.0)⟩⇒s.0,
and from step 6 to 7 it used L-FACT and did the reduction
⟨curry(s.eval).pr(curry(pi1), curry(s.eval)), 0⟩⇒. . .
⟨pr(curry(pi2), curry(s.eval)), s.0⟩⇒. . .
.
Therefore, (†) is
⟨pr(curry(pi2), curry(s.eval)).pi1, pair(s.0, s.0)⟩⇒⟨curry(s.eval), curry(pi2).!⟩,
and from R-NAT the reduction of (++) is the same as
⟨s.eval, pair(curry(pi2).!, pi2.pair(s.0, s.0))⟩⇒. . ..
The rest of the steps are done similarly.
It is inconvenient to write down the deﬁnition of the addition every time we want to
add something. Therefore, the system has the facility to give names to morphisms.
For example, we can name the addition function ‘add’ and use it as follows:
cpl>let add=eval.pair(pr(curry(pi2),curry(s.eval)).pi1,pi2)
add : prod(nat,nat) -> nat defined
cpl>simp add.pair(s.0,s.s.0)
s.s.s.0
:1 -> nat
We can deﬁne the multiplication and factorial functions.
cpl>let mult=eval.prod(pr(curry(0.!),curry(add.pair(eval,pi2))),id)
mult : prod(nat,nat) -> nat defined
cpl>let fact=pi1.pr(pair(s.0,0),pair(mult.pair(s.pi2,pi1),s.pi2))
fact : nat -> nat defined
cpl>simp mult.pair(s.s.0,s.s.s.0)
s.s.s.s.s.s.0
:1 -> nat
cpl>simp fact.s.s.s.s.0
s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.0.!
:1 -> nat
cpl>
Let us next deﬁne the object for lists.

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
119
cpl>edit
| left object list(p) with prl is
|
nil:1->list
|
cons:prod(p,list)->list
| end object;
left object list(+) defined
cpl>edit
| let append=eval.prod(prl(curry(pi2),
|
curry(cons.pair(pi1.pi1,eval.pair(pi2.pi1,pi2)))),
|
id);
append : prod(list(*a),list(*a)) -> list(*a) defined
cpl>let reverse=prl(nil,append.pair(pi2,cons.pair(pi1,nil.!)))
reverse : list(*a) -> list(*a) defined
cpl>let hd=prl(in2,in1.pi1)
hd : list(*a) -> coprod(*a,1) defined
cpl>let hdp=case(hd,in2)
hdp : coprod(list(*a),1) -> coprod(*a,1) defined
cpl>let tl=case(in1.pi2,in2).prl(in2,in1.pair(pi1,case(cons,nil).pi2))
tl : list(*a) -> coprod(list(*a),1) defined
cpl>let tlp=case(tl,in2)
tlp : coprod(list(*a),1) -> coprod(list(*a),1) defined
cpl>let seq=pi2.pr(pair(0,nil),pair(s.pi1,cons))
seq : nat -> list(nat) defined
cpl>
The morphism ‘seq’ returns a list of length n for a given natural number n such that
the list consists of the descending sequence of natural numbers, n −1, n −2, . . . , 2, 1, 0.
We can try it in the system.
cpl>simp seq.s.s.s.0
cons.pair(s.pi1,cons).pair(s.pi1,cons).pair(0,nil).!
:1 -> list(nat)
cpl>
The result dose not look like the sequence of 2, 1 and 0, but this is because our deﬁnition
of canonical element (deﬁnition 4.1.3) is weak. We can ask the system to reduce an
element to unconditioned canonical elements (see deﬁnition 4.5.1) using reduction rules
listed in deﬁnition 4.5.2.
cpl>simp full seq.s.s.s.0
cons.pair(s.s.0.!,cons.pair(s.0.!,cons.pair(0.!,nil.!)))
:1 -> list(nat)
cpl>
Now, it looks more like the sequence of 2, 1, and 0. We may continue to do some more
reductions about lists.
cpl>simp hd.seq.s.s.s.0
in1.s.s.0.!
:1 -> coprod(nat,1)
cpl>simp hd.nil
in2.!
:1 -> coprod(*a,1)
cpl>simp hdp.tl.seq.s.s.s.0
in1.s.0.!

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
120
:1 -> coprod(nat,1)
cpl>simp full append.pair(seq.s.s.0,seq.s.s.s.0)
cons.pair(s.0.!,cons.pair(0.!,cons.pair(s.s.0.!,cons.pair(s.0.!,cons.
pair(0.!,nil.!)))))
:1 -> list(nat)
cpl>simp full reverse.it
cons.pair(0.!,cons.pair(s.0.!,cons.pair(s.s.0.!,cons.pair(0.!,cons.
pair(s.0.!,nil.!)))))
:1 -> list(nat)
cpl>
where ‘it’ denotes the result of the immediately-preceding reduction.
Let us next experiment with inﬁnite lists.
cpl>edit
| right object inﬂist(a) with fold is
|
head: inﬂist -> a
|
tail: inﬂist -> inﬂist
| end object;
right object inflist(+) defined
cpl>let incseq=fold(id,s).0
incseq : 1 -> inflist(nat) defined
cpl>simp head.incseq
0
:1 -> nat
cpl>simp head.tail.tail.tail.incseq
s.s.s.0
:1 -> nat
cpl>let alt=fold(head.pi1,pair(pi2,tail.pi1))
alt : prod(inflist(*a),inflist(*a)) -> inflist(*a)
cpl>let infseq=fold(id,id).0
infseq : 1 -> inflist(nat)
cpl>simp head.tail.tail.alt.pair(incseq,infseq)
s.0
:1 -> nat
cpl>
where ‘incseq’ is the inﬁnite increasing sequence 0, 1, 2, 3, 4, . . . , and ‘infseq’ is
the inﬁnite sequence of 0s. We can merge two inﬁnite lists by ‘alt’ which picks up
elements alternatively from the two inﬁnite lists.
5.2
Typed Lambda Calculus
In this section, we will investigate connection between CPL and typed lambda calculi.
Lambda calculi were invented to mathematically formalize the notion of computation.
Typed lambda calculi (ﬁrst order) are an important part of lambda calculi and are
studied in various ways. Usually a typed lambda calculus starts with a ﬁxed number
of ground types and allows only →as type constructors. For example, [Stenlund 72]
treats natural numbers and ordinals, and [Troelstra 73] deals with one level higher
ordinals.
An interesting question is “What kind of types can be added to lambda

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
121
calculi?” Natural numbers, ordinals, lists, . . . . We will show in this section that any
data types we can deﬁne in CPL can be added into typed lambda calculi.
We are to deﬁne a typed lambda calculus. As CPL does not have any ground objects
to start with, our lambda calculus does not have any ground types either. Instead it
has two ways of constructing types, one corresponding to forming left objects and the
other corresponding to forming right objects.
Deﬁnition 5.2.1: The syntax of our lambda calculus is given as follows.
1. An enumerable set TVar of type variables. ρ, ν, . . . ∈TVar.
2. The set Type of types is deﬁned by the following rules.
ρ ∈TVar
ρ ∈Γ
Γ ⊢ρ ∈Type
∅⊢σ ∈Type
Γ ⊢τ ∈Type
Γ ⊢σ →τ ∈Type
Γ ∪{ ρ } ⊢σ1 ∈Type
. . .
Γ ∪{ ρ } ⊢σn ∈Type
Γ ⊢µρ.(σ1, . . . , σn) ∈Type
Γ ∪{ ρ } ⊢σ1 ∈Type
. . .
Γ ∪{ ρ } ⊢σn ∈Type
Γ ⊢µρ.(σ1, . . . , σn) ∈Type
We use σ, τ, . . . for the meta-variables of Type. µρ.(σ1, . . . , σn) corresponds to
left objects and µρ.(σ1, . . . , σn) corresponds to right objects.
3. An enumerable set Var of variables. x, y, z, . . . ∈Var.
4. The set Term of terms and their types are deﬁned by the following rules.
x ∈Var
x : σ ∈Γ
Γ ⊢x : σ
Γ ∪{ x : σ} ⊢t : τ
Γ ⊢λxσ.t : σ →τ
Γ ⊢t1 : σ →τ
Γ ⊢t2 : σ
Γ ⊢t1t2 : τ
Γ ⊢Cµρ.(σ1,...,σn),i : σi[µρ.(σ1, . . . , σn)/ρ] →µρ.(σ1, . . . , σn)
Γ ⊢Jµρ.(σ1,...,σn),τ : (σ1[τ/ρ] →τ) →. . . →(σn[τ/ρ] →τ) →
µρ.(σ1, . . . , σn) →τ
Γ ⊢Dµρ.(σ1,...,σn),i : µρ.(σ1, . . . , σn) →σi[µρ.(σ1, . . . , σn)/ρ]
Γ ⊢Pµρ.(σ1,...,σn),τ : (τ →σ1[τ/ρ]) →. . . →(τ →σn[τ/ρ]) →
τ →µρ.(σ1, . . . , σn)
Cµρ.(σ1,...,σn),i is the i-th constructor of µρ.(σ1, . . . , σn) and Jµρ.(σ1,...,σn),τ is the
generalized iterator for it. Dµρ.(σ1,...,σn),i and Pµρ.(σ1,...,σn),τ are the dual pairs. []

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
122
We have the usual reduction rules α and β and two delta rules. We write a ▷b for the
term a reducing to the term b by one step reduction and write a
⋆▷b for a reducing to
b by some steps. The two delta rules are:
Jµρ.(σ1,...,σn),τa1 . . . an(Cµρ.(σ1,...,σn),ib) ▷ai(σi[Jµρ.(σ1,...,σn),τa1 . . . an/ρ]b)
and
Dµρ.(σ1,...,σn),i(Pµρ.(σ1,...,σn),τa1 . . . anb) ▷σi[Pµρ.(σ1,...,σn),τa1 . . . an/ρ](aib)
where σ[t/ρ] is a term of type σ[τ/ρ] →σ[υ/ρ] when the type of t is τ →υ and is
deﬁned as follows.
1. If ρ does not appear in σ, then σ[t/ρ] ≡λxσ.x.
2. ρ[t/ρ] ≡t.
3. (σ1 →σ2)[t/ρ] ≡λxσ1→σ2[τ/ρ].λyσ1.σ2[t/ρ](xy).
4. µν.(σ1, . . . , σn)[t/ρ] ≡Jµν.(σ1[τ/ρ],...),µν.(σ1[υ/ρ],...)a1 . . . an
where ai ≡λxσi[τ/ρ][µν.(σ1[υ/ρ],...)/ν].Cµν.(σ1[τ/ρ],...),i(σi[µν.(σ1[υ/ρ], . . .)/ν][t/ρ]x).
5. µν.(σ1, . . . , σn)[t/ρ] ≡Pµν.(σ1[υ/ρ],...),µν.(σ1[τ/ρ],...)a1 . . . an
where ai ≡λxµν.(σ1[τ/ρ],...).σi[µν.(σ1[τ/ρ], . . .)/ν][t/ρ](Dµν.(σ1[τ/ρ],...),ix).
It looks very complicated but this is the faithful translation of σ[t/ρ] as σ being a
functor.
Let us see some types we can deﬁne in our lambda calculus.
Example 5.2.2: The empty type can be deﬁned as ∅≡µρ.(), and one point type can
be deﬁned as 1 ≡µρ.(). We denote the element of 1 as ∗≡P1,1→1λx1.x. []
Example 5.2.3: The product of two types, σ and τ can be deﬁned as σ×τ ≡µρ.(σ, τ).
We have two projections.
π1 ≡Dσ×τ,1
: σ × τ →σ
π2 ≡Dσ×τ,2
: σ × τ →τ
If a is a term of type σ and b is a term of type τ, we can deﬁne a term ⟨a, b⟩of type
σ × τ.
⟨a, b⟩≡Pσ×τ(λx1.a)(λx1.b)∗
: σ × τ
We have the following reduction.
π1⟨a, b⟩≡Dσ×τ,1(Pσ×τ,1(λx.a)(λx.b)∗) ▷(λx.x)((λx.a)∗)
⋆▷a
Similarly, we can show that π2⟨a, b⟩
⋆▷b. []
Example 5.2.4: Dually, the coproduct of σ and τ is deﬁned as σ + τ ≡µρ.(σ, τ).
Two injections are deﬁned as follows.
ι1 ≡Cσ+τ,1
: σ →σ + τ
ι2 ≡Cσ+τ,2
: τ →σ + τ
Jσ+τ,ν satisﬁes the following reductions.
Jσ+τ,νab(ι1c) ≡Jσ+τ,νab(Cσ+τ,1c) ▷a((λx.x)c) ▷ac
Jσ+τ,νab(ι2c)
⋆▷bc
[]

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
123
Example 5.2.5: Let us deﬁne the natural numbers in our lambda calculus.
The
deﬁnition of type is
ω ≡µρ.(1, ρ).
Zero and the successor function are deﬁned by
0 ≡Cω,1∗
: ω
s ≡Cω,2
: ω →ω
J gives us almost the ordinary well-known iterator but its type is
Jω,σ
: (1 →σ) →(σ →σ) →ω →σ.
We can deﬁne the ordinary one by this Jω,σ as follows.
˜Jσ ≡λx.λy.λn.Jω,σ(λz.x)yn
: σ →(σ →σ) →ω →σ
It satisﬁes the usual reductions:
˜Jσab0
⋆▷Jω,σ(λz.a)b(Cω,1∗) ▷(λz.a)((λx.x)∗)
⋆▷a
and
˜Jσab(sn)
⋆▷Jω,σ(λz.a)b(Cω,2n) ▷b(Jω,σ(λz.a)bn) ≈b( ˜Jσabn)
where ≈is the equivalence relation generated by
⋆▷. Using ˜Jσ, we can deﬁne all the
primitive recursive functions. For example, the addition function can be deﬁne as
add ≡λn.λm. ˜Jωmsn
: ω →ω →ω.
[]
Example 5.2.6: As [Stenlund 72] and [Troelstra 73], we can deﬁne the type for or-
dinals by Ω≡µρ.(1, ω →ρ). We only check whether our deﬁnition of the iterator
coincides with the ordinary one.
Ω≡µρ.(1, ω →ρ)
0Ω≡CΩ,1∗
: Ω
sup ≡CΩ,2
: (ω →Ω) →ω
JΩ,σ
: (1 →σ) →((ω →σ) →σ) →Ω→σ
JΩ,σ(λx.a)b0Ω▷(λx.a)((λx.x)∗)
⋆▷a
JΩ,σ(λx.a)b(sup t) ▷b((ω →ρ)[JΩ,σ(λx.a)b/ρ]t)
≡b((λy.λz.JΩ,σ(λx.a)b(yz))t) ▷b(λz.JΩ,σ(λx.a)b(tz))
[]
Example 5.2.7: Finally, the type for ﬁnite lists can be deﬁned by
Lσ ≡µρ.(1, σ × ρ)

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
124
with
nil ≡CLσ,1∗
: Lσ
cons ≡CLσ,2
: σ × Lσ →Lσ
JLσ,τ
: (1 →τ) →(σ × τ →τ) →Lσ →τ
whereas the type for inﬁnite lists can be deﬁned by Iσ ≡µρ.(σ, ρ) with
head ≡DIσ,1
: Iσ →σ
tail ≡DIσ,2
: Iσ →Iσ
PIσ,τ
: (τ →σ) →(τ →τ) →τ →Iσ
head(PIσ,τabc)
⋆▷ac
tail(PIσ,τabc)
⋆▷PIσ,τab(bc)
[]
After ﬁnishing this section, the author is communicate with [Mendler 86] where recur-
sive types are introduced into ﬁrst-order and second-order typed lambda calculi. He
uses least ﬁxed points and greatest ﬁxed points as we do, but their recursion combinator
R has a diﬀerent type from ours.
M: (ρ →τ) →σ →τ
Rσ,τ(M[µρ.σ/ρ]): µρ.σ →τ
The author cannot give a clear connection between our iterator and his. In addition,
he takes ﬁxed points over a single type expression and, therefore, he needs some basic
type constructors like 1 and +, whereas in our lambda calculus there are no basic type
constructors.
5.3
ML and Categorical Programming
Language
We might say that ML is based on (ﬁrst order) typed lambda calculi as we might say
that LISP is based on untyped lambda calculi. The type structure of ML depends on the
version of ML we are talking about. If we are talking about the original ML developed
with LCF [Gordon, Milner and Wordsworth 79], it had some base types, product,
disjoint sum, integer, etc. , and had ability to introduce new types via recursively
deﬁned type equations. For example, the data type for binary trees whose leaves are
integers were deﬁned as
absrectype btree = int + (btree # btree)
with leaf n = absbtree(inl n)
and node(t1,t2) = absbtree(inr(t1,t2))
and isleaf t = isl(repbtree t)
and leafvalue t = outl(repbtree t)
and left t = fst(outr(repbtree t))
and right t = snd(outr(repbtree t));;

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
125
Here, we needed the coproduct type constructor ‘+’ as a primitive. We could not do
without it, whereas ‘int’ can be deﬁned in terms of others primitives (ML has it as a
primitive type just because of eﬃciency).
At the next evolution of ML which yielded the current Standard ML [Milner 84, Harper,
MacQueen and Milner 86], we discovered that the coproduct type constructor is no
longer needed as a primitive. Standard ML has a ‘datatype’ declaration mechanism by
which the coproduct type constructor can be deﬁned.
datatype ’a + ’b = inl of ’a | inr of ’b;
A datatype declaration lists the constructors of the deﬁning type. An element of ‘’a
+ ’b’ can be obtained by either applying ‘inl’ to an element of ‘’a’ or applying ‘inr’
to an element of ‘’b’. We can deﬁne the data type for binary trees in Standard ML as
follows.
datatype btree = leaf of int | node of btree * btree;
The symbol ‘|’ is just like ‘+’, but we shifted from the object level of the language
to the syntax level. Note that we no longer need the separate deﬁnition of ‘leaf’ or
‘node’. We can deﬁne the other functions using case statements.
exception btree;
fun isleaf t = case t of
leaf _ => true
| node _ => false;
fun leafvalue t = case t of
leaf n => n
| node _ => raise btree;
fun left t = case t of
leaf _ => raise btree
| node(t1,t2) => t1;
fun right t = case t of
leaf _ => raise btree
| node(t1,t2) => t2;
We got rid of the coproduct type constructor from the primitives, but Standard ML
still needs the product type constructor. From a category theoretic point of view, we
can sense asymmetry in the type structure of Standard ML. Let us remember that
CPL (or the lambda calculus deﬁned in section 5.2) needs neither the coproduct type
constructor nor the product type constructor as a primitive. We should be able to
introduce the symmetry of CPL into ML. Let us proceed to the next stage of the ML

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
126
evolution and deﬁne Symmetric ML.
Primitives
Declaration Mechanism
ML
->, unit, #, +
abstype
Standard ML
->, unit, *
datatype
Symmetric ML
->
datatype, codatatype
CPL
left object, right object
ML Evolution
Remember that datatype declarations correspond to left object declarations. We list
constructors for types. In order to get rid of the product type constructor from prim-
itives, we should have a declaration mechanism which corresponds to the right object
declaration mechanism. Its syntax is
codatatype TypeParam TypeId =
Id is TypeExp & ... & Id is TypeExp;
A codatatype declaration introduces a type by listing its destructors. The product
type constructor can be deﬁned as follows.
codatatype ’a * ’b = fst is ’a & snd is ’b;
where ‘fst : ’a * ’b -> ’a’ gives the projection function to the ﬁrst component and
‘snd : ’a * ’b -> ’b’ gives the projection function to the second component. If the
declaration is recursive, we do not take the initial ﬁxed point of the type equation but
the ﬁnal ﬁxed point. This is ﬁrstly because of symmetry and secondly because the
initial ﬁxed points are often trivial. Because of this, we can deﬁne inﬁnite objects by
codatatype declarations. For example, the following declaration gives us the data type
for inﬁnite lists.
codatatype ’a inflist = head is ’a & tail is ’a inflist;
If we took the initial ﬁxed point, we would get the empty data type.
Obviously we have destructors for co-data types because we declare them, but how can
we construct data for co-data types? We had case statements for data types, so we
have ‘merge’ statements as dual. Its syntax is
merge Destructor <= Exp & ... & Destructor <= Exp
For example, the function ‘pair’ which makes a pair of given two elements can be
deﬁned as follows.
fun pair(x,y) = merge fst <= x & snd <= y;
As a more complicated example, we might deﬁne a function which combines two inﬁnite
lists together.
fun comb(l1,l2) = merge head <= head l1
& tail <= comb(l2,tail l1);

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
127
It is now clear that, if elements of co-data types are just records and ‘merge’ creates
records after evaluating expressions, this ‘comb’ function never terminates because it
tries to sweep the entire inﬁnite lists which cannot be done in ﬁnite time. We need
lazyness in the evaluation mechanism. An element of ‘inflist’ is a record of two com-
ponents but each component is a closure whose computation leads to a value. A ‘merge’
statement creates a record consisting of these records. Therefore, the declaration of
‘inflist’ is not like
datatype ’a inflist = something of ’a * ’a inflist;
but is closer to
datatype ’a inflist = something of (unit -> ’a) *
(unit -> ’a inflist);
and ‘head’, ‘tail and ‘comb’ are like
fun head(something(x,l)) = x();
fun tail(something(x,l)) = l();
fun comb(l1,l2) = something(fn () => head l1,
fn () => comb(l2,tail l1));
Note that, as we use pattern matching to declare functions over data types, we can also
use it to declare functions over co-data types. For example, an alternative deﬁnition
of ‘comb’ may be
fun head comb(l1,_) = head l1
& tail comb(l1,l2) = comb(l2,tail l1);

Conclusions
We have looked at a categorical approach to the theory of data types.
The goal
of this thesis was to develop CPL (Categorical Programming Language) which is a
programming language in a categorical style and which has a categorical way of deﬁning
data types.
CSL (Categorical Speciﬁcation Language) was actually developed later than CDT (Cat-
egorical Data Types) and CPL. At ﬁrst, CDT was given its semantics without depend-
ing on CSL. We could have carried out the thesis without CSL, but CSL provides the
syntactic materials for CDT and CPL so we would have still needed those parts. CSL
is very much like an ordinary algebraic speciﬁcation language, but it is not trivial in
two senses: the treatment of functors and the treatment of natural transformations.
Functors are very similar to functions but variances make them special and interesting.
Natural transformations are essentially polymorphic functions, so if there had been a
speciﬁcation language for polymorphic functions, we might not have needed to struggle
for developing CSL. It might be interesting to investigate what polymorphic algebraic
speciﬁcation languages can be.
CSL is equational. Much of category theory can be presented equationally so that
CSL is good enough in this sense, but presenting categorical concepts equationally
loses half of the essential meaning. For example, although the adjoint situation can be
explained equationally, its essence is something more. This is why, the author believes,
there are so many equivalent forms of deﬁning the adjoint situation. Therefore, it is
nice to have a speciﬁcation language which can naturally express categorical concepts.
Sketches [Barr and Wells 85] are more categorical than equations, so it might be an
idea to use sketches in CSL.
CDT is the heart of the thesis. It was developed after the author ﬁrst studied category
theory and tried to express categorical deﬁnitions in algebraic speciﬁcation languages.
As we have seen in chapter 3, algebraic speciﬁcation languages can express categor-
ical deﬁnitions but not naturally.
CDT succeeded to deﬁne some basic categorical
deﬁnitions like products, coproducts, exponentials, natural numbers and so on more
naturally, but it cannot deﬁne, for example, pullbacks or more complicated categorical
concepts. One of the suggestions to extend CDT is to allow equations inside the CDT
128

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
129
declarations. In this way, we may deﬁne pullbacks as follows:
right object pullback(f: A →C, g: B →C) with pbpair is
π1: pullback →A
π2: pullback →B
where
f ◦π1 = g ◦π2
end object
The declaration should be read as follows:
1. For any morphisms f: A →C and g: B →C, pullback(f, g) is an object and it is
associated with two morphisms
π1: pullback(f, g) →A
and
π2: pullback(f, g) →B
such that f ◦π1 = g ◦π2.
2. For any morphisms h: D →A and k: D →B such that f ◦h = g ◦k, there exists
a unique morphism pbpair(h, k): D →pullback(f, g) such that
π1 ◦pbpair(h, k) = h
and
π2 ◦pbpair(h, k) = k
Note that ‘pullback’ is no longer a simple functor but takes two morphisms. We can
similarly deﬁne pushouts, equalizers, co-equalizers and so on. In fact, we can deﬁne
any ﬁnite limit or colimit. Since limits and colimits are something to do with diagrams,
it seems natural to introduce the declaration mechanism of diagrams. For example, we
may have a diagram consisting of three objects and two morphisms as follows:
diagram el is
objects A, B, C
morphisms f: A →C, g: B →C
end diagram
Then, ‘pullback’ can be regarded as taking an ‘el’ diagram as its parameter, and it is
a functor from the category of ‘el’ diagrams. This extension is becoming very much
similar to the parametrization mechanism in algebraic speciﬁcation languages. Dia-
grams correspond to so-called loose speciﬁcations, and object declarations correspond
to parametrized speciﬁcations (or procedures in CLEAR’s terminology) which take a
speciﬁcation which matches as a parameter and return a new speciﬁcation. It is very
interesting to investigate the possibility of CDT with equations along this line as a
ﬁrst class speciﬁcation language. CDT we presented in this thesis was bounded by the
restriction of computability. If we introduce equations, it becomes increasingly diﬃcult
to connect them to computing. If we had ‘pullback’ in CDT, we would have to prove
f ◦k = g◦h before using pbpair(k, h). Therefore, the programming would involve some
proving.
CDT and CSL are essentially one sorted systems (here sort = category), and some
would like to extend them to many sorted systems. We could have extended them
here, but since our main goal in this thesis was to understand data types, we were

CHAPTER 5. APPLICATION OF CATEGORICAL DATA TYPES
130
interested in only one category, the category of data types, and so CDT and CSL were
single sorted. Our approach is very close to that of domain theory which mainly deals
only one category, the category of domains. On the other hand, algebraic speciﬁcation
methods deal with many categories. Each speciﬁcation is associated with a category.
However, they are still related in some sense because they all are algebras over the
category of sets (or some other underlying category). As we mentioned above, if we
extend CDT with the diagram declarations, we will have to deal with a lot of diﬀerent
categories of diagrams, and it will be interesting to ﬁnd out what F, G-dialgebras can
give us in this context.
CPL is a functional programming language without variables. It may look like FP
proposed by John Backus because FP also has no variables. However, CPL is based
on category theory and it has an ability to declare data types by means of CDT. CPL
does not need any primitives to start with. One of the reasons for not having variables
is that category theory is abstract in the sense that objects are simply points and only
their outer behaviour is concerned. However, we could have variables for morphisms.
For example, we might want to have
twice(f) def
= f ◦f
which takes a morphism f: A →A and returns a morphism of A →A. The current
CPL system cannot handle it and we have to write it like
twice def
= eval ◦pair(π1, eval)
which is a morphism from exp(A, A) to exp(A, A). This deﬁnition is not self-explanatory.
It is evident that we need morphism variables in CPL for easier use. Note that twice(f)
can simply be a macro because deﬁnitions can never be recursive.
We proposed in chapter 5 to make CPL more like an ordinary functional programming
language. It has datatype declarations as well as co-datatype declarations. It is left for
the future to actually implement the language. It is interesting to see how to handle
(or represent) lazy data types.
Since CPL is an applicative language and has the possibility of executing programs in
parallel as well as the possibility of partial evaluation, some kind of special hardware
can be invented to execute CPL programs fast.
The future plan of CDT and CPL would be to extend CDT to cope with equations
and to develop a total programming environment in which users can deﬁne things
categorically, reason (or prove) their properties categorically, execute some programs
categorically.

Bibliography
[Arbib and Manes 75] Arbib, M. A. and Manes, E. G. (1975): Arrows, Structures, and
Functors — The Categorical Imperative —. Academic Press.
[Arbib and Manes 80] Arbib, M. A. and Manes, E. G. (1980): The Greatest Fixed
Points Approach to Data Types. In proceedings of Third Workshop Meeting on Cat-
egorical and Algebraic Methods in Computer Science and System Theory, Dortmund,
West Germany.
[Barr and Wells 85] Barr, M. and Wells, C. (1985): A Series of Comprehensive Studies
in Mathematics Volume 278: Toposes, Triples and Theories. Springer-Verlag.
[Burstall and Goguen 77] Burstall, R. M. and Goguen, J. A. (1977): Putting Theories
Together to Make Speciﬁcation. In Proceedings of 5th International Joint Conference
on Artiﬁcial Intelligence. pp. 1045–1058.
[Burstall and Goguen 80] Burstall, R. M. and Goguen, J. A. (1980): The Semantics of
Clear: A Speciﬁcation Language. Internal Report CSR-65-80, Department of Com-
puter Science, University of Edinburgh.
[Burstall and Goguen 81] Burstall, R. M. and Goguen, J.A. (1981): An Informal In-
troduction to Speciﬁcations using Clear. In The Correctness Problem in Computer
Sciences, Academic Press, pp. 185–213.
[Burstall and Goguen 82] Burstall, R. M. and Goguen, J.A. (1982): Algebras, Theories
and Freeness: an Introduction for Computer Scientists. Internal Report CSR-65-80,
Department of Computer Science, University of Edinburgh.
[Burstall and Lampson 84] Burstall, R. M. and Lampson, B. (1984): A Kernel Lan-
guage for Abstract Data Types and Modules. In Lecture Notes in Computer Science,
Volume 173, pp. 1–50.
[Curien 86] Curien, P-L. (1986): Categorical Combinators, Sequential Algorithms and
Functional Programming. Research Notes in Theoretical Computer Science, Pitman.
[Dybjer 83] Dybjer, P. (1983): Category-Theoretic logics and Algebras of Programs.
Ph. D. thesis, Department of Computer Sciences, Chalmers University of Technology.
University of Gothenburg.
[Goguen and Burstall 83] Goguen, J. A. and Burstall, R. M. (1983): Introducing In-
stitutions. In proceedings of Logic of Programming Workshop.
[Goguen and Tardo 79] Goguen, J. A. and Tardo, J. (1979): An Introduction to OBJ:
A Language for Writing and Testing Software Speciﬁcations. In Speciﬁcation of Re-
liable Software, IEEE, pp. 170–189.
[Goguen, Thatcher and Wagner 78] Goguen, J. A., Thatcher, J. W. and Wagner, E.
G. (1978): An Initial Algebra Approach to the Speciﬁcation, Correctness and Imple-
mentation of Abstract Data Types. In Current Trends in Programming Methodology,
prentice-Hall, pp. 80–149.
131

BIBLIOGRAPHY
132
[Gordon, Milner and Wordsworth 79] Gordon, M. J., Milner, A. J. and Wordsworth,
C. P. (1979): Edinburgh LCF. Lecture Notes in Computer Science, Volume 78.
[Goldblatt 79] Goldblatt, R. (1979): Topoi: The Categorical Analysis of Logic. Studies
in Logic and Foundation of Mathematics, Volume 98, North-Holand.
[Harper, MacQueen and Milner 86] Harper, R., MacQueen, D. and Milner, R. (1986):
Standard ML. LFCS Report Series, ECS-LFSC-86-2. Department of Computer Sci-
ence, University of Edinburgh.
[Kelly 72] Kelly, G. M. (1972): Many-Variable Functorial Calculus I. In Lecture Notes
in Mathematics, Volume 281, Springer-Verlag, pp. 66–105.
[Lambek and Scott 86] Lambek, J. and Scott, P. J. (1986): Introduction to Higher-
Order Categorical Logic. Cambridge Studies in Advanced Mathematics, Volume 7.
[Lawvere 63] Lawvere, F. W. (1963): Functorial Semantics of Algebraic Theories. In
Proceedings of the National Academy of Science, Volume 50, pp. 869–872.
[Lehmann and Smyth 81] Lehmann, D. and Smyth, M. (1981): Algebraic Speciﬁcation
of Data Types – A Synthetic Approach –. Mathematical System Theory, Volume 14,
pp. 97–139.
[Mac Lane 71] Mac Lane, S. (1971): Categories for the Working Mathematician. Grad-
uate Texts in Mathematics 5, Springer-Verlag.
[Manes 76] Manes, E. G. (1976): Algebraic Theories. Graduate Texts in Mathematics
26, Springer-Verlag.
[Martin-L¨of 79] Martin-L¨of, P. (1979): Constructive Mathematics and Computer Pro-
gramming. Paper presented in 6th International Congress for Logic, Methodology
and Philosophy of Science.
[Mendler 86] Mendler N. P. (1986): First- and Second-Order Lambda Calculi with Re-
cursive Types. Technical Report TR 86-764, Department of Computer Science, Cor-
nell University.
[Milner 84] Milner, R. (1984): The Standard ML Core Language. Internal Report CSR-
168-84, Department of Computer Science, University of Edinburgh.
[Parasaya-Ghomi 82] Parasaya-Ghomi, K. (1982): Higher Order Abstract Data Types.
Ph. D. Thesis, Department of Computer Science, UCLA.
[Plotkin 81] Plotkin, G. D. (1981): A Structural Approach to Operational Semantics.
Technical Report DAIMI FN–19, Computer Science Department, ˚Arhus University.
[Rydeheard 81] Rydeheard, D. E. (1981): Application of Category Theory to Program-
ming and Program Speciﬁcation. Ph. D. thesis, University of Edinburgh.
[Rydeheard and Burstall 86] Rydeheard, D. E. and Burstall, R. M. (1986): Computa-
tional Category Theory.
[Scott 76] Scott, D. (1976): Data Types as Lattices. SIAM Journal of Computing,
Volume 5, pp. 552–587.
[Smyth and Plotkin 82] Smyth, M. B. and Plotkin, G. D. (1982):
The Category-
Theoretic Solution of Recursive Domain Equations. SIAM Journal of Computing,
Volume 11.
[Stenlund 72] Stenlund, S. (1972): Combinators, λ-Terms and Proof Theory. D. Reidel,
Dordrecht.
[Stoy 77] Stoy, J. E. (1977): The Scott-Strachey Approach to Programming Language
Theory. MIT Press.
[Tait 67] Tait, W. (1967): Intentional Interpretation of Functionals of Finite Type I.
Journal of Symbolic Logic, 32, pp. 198–212.

BIBLIOGRAPHY
133
[Troelstra 73] Troelstra, A. S. (1973):
Mathematical Investigation of Intuitionistic
Arithmetic and Analysis. Lecture Notes in Mathematics, Volume 344, Springer-
Verlag.

Declaration
This thesis has been written by myself, and the work is my own.
Edinburgh, 1 June 1987
Tatsuya Hagino

