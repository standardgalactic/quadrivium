
Index
Warnings
Copyright Notes
Course Presentation
Course Content:
Conclusions:
LESSON 1 - Introduction
The Basics of Robotics: Degrees of Freedom (DOF)
and Electric Drives.
We prepare our Laboratory
A little Physics to get you started: Force, Momentum
and Torque.
The MG996R Servomotor.
The importance of testing Servos and initial
configuration.
Project 01 - The Servo Tester
Project 02 - The Servo Tester with Arduino
Final thoughts on Project 02:
LESSON 2 - Assembly of the Robotic Arm.
Components of the Robotic Arm
Video-Assembly of the Robot Arm
Assembly of the Base of the Robotic Arm
Arm Assembly
Assembly of the Robotic Arm Elbow
Robotic Arm Wrist Assembly
Assembly of the Forearm of the Robotic Arm

Project 03 - Work Space Definition of the Robot Arm
with Arduino
LESSON 3 - Piloting a Robot Arm with 6DOF
Potentiometer Controller
Project 04: Hello World of the Robot Arm.
Considerations on Robot Arm's Project 04 Hello
World.
LESSON 4 - Bluetooth wireless communication
with Arduino
General Description of Bluetooth Standard
The HC-05 Bluetooth Module for Arduino
Bidirectional logic level converter
HC-05 Bluetooth module in configuration mode and
AT commands
Project 05: Configuration mode of the HC-05
Bluetooth Module .
Analysis of the Project 05 sketch - Configuration of
the HC-05 Bluetooth module.
Procedure for HC-05 Bluetooth Module Configuration
Mode.
Main AT commands for configuring the HC-05
Bluetooth module
Project 06: Using HC-05 with Arduino. Switch mode .
Analysis of the Project 06 sketch - Use of HC-05 with
Arduino. Switch Mode
Project 07: Data exchange between Smartphone
and Arduino via BT with HC-05
Analysis of Project 07 sketch - Data exchange
between Smartphone and Arduino with HC-05

Development Environment Installation Processing
Project 08: Data exchange between PC and Arduino
via BT with HC-05
Analysis of Project 08 sketch - Data exchange
between PC and Arduino via BT with HC-05
LESSON 5 - Controlling a Robot Arm via BT with
PC and Arduino UNO
Project 09: Control and Command Robot Arm via LV
with PC and HC-05.
Analysis of Project 09 sketches - Control and
Command Robot Arm via LV.
Controlling a Robot Arm with PCA9685 Controller
and Arduino UNO
Description of Servomotor Control Board PCA9865
Project 10: Use of the PCA9685 Board in Servomotor
Control.
Analysis of the Project 10 sketch - Testing of the
PCA9685 board
Project 11: Robot arm controlled by PCA9685 board
Analysis of Project 11 sketches - Robot arm
controlled by PCA9685 board
LESSON 6 - Controlling a Robot Arm via BT with
HC-05 and PCA9685
Project 12: Control and Command Robot Arm via LV
with PCA9685.
Analysis of Project 12 sketches - Control and
Command Robot Arm via LV.
PS2 Controller and Arduino UNO
Project 13: Using PS2 Controller with Arduino

Analysis of the Project 13 sketch - Using the PS2
Controller with Arduino
Project 14: Robot arm driven with PS2 Controller &
Arduino
Analysis of Project 14 sketch - Robot arm driven
with PS2 Controller

Warnings
Regarding safety aspects, since the projects are
based on very low voltage power supply delivered
from the pc's usb port or from supporting batteries or
power supplies with maximum 9V output, there are
no particular electrical risks. However, it should be
pointed out that any short-circuits caused during the
exercise could produce damage to the pc, furniture
and in extreme cases even burns, for this reason
whenever a circuit is assembled, or modifications are
made on it, it will be necessary to do so in the
absence of power supply and at the end of the
exercise it will be necessary to disconnect the circuit
by removing both the usb cable connecting to the pc
and 
any 
batteries 
from 
the 
appropriate
compartments or external power connectors. In
addition, again for safety reasons, it is strongly
recommended to carry out the projects on insulating
and heat-resistant mats that can be purchased in any
electronics store or even on specialized websites.
At the end of the drills, hands should be washed, as
electronic components may have processing residues
that could cause harm if ingested or if in contact with
eyes, mouth, skin, etc. Although the individual
projects have been tested and safe, those who
decide to follow what is stated in this document
assume full responsibility for what might happen in
the execution of the drills provided in it. For younger
and/or first-time students in the field of Electronics, it
is recommended that the exercises be performed
with the help and in the presence of an adult.

Copyright Notes
All trademarks shown belong to their rightful owners;
third party trademarks, product names, trade names,
corporate names and company names mentioned
may be trademarks of their respective owners or
registered trademarks of other companies and have
been used for explanatory purposes only and for the
benefit of the owner, without any purpose of
infringement of the Copyright rights in force. What is
reported in this document is the property of Roberto
Francavilla, Italian and European copyright laws are
applicable to it - any texts taken from other sources
are also protected by Copyright and owned by their
respective Owners. All information and content (text,
graphics and images, etc.) reported are, to the best
of 
my 
knowledge, 
in 
the 
public 
domain. 
If,
unintentionally, copyrighted or infringing material
has been posted please notify me by email at
info@bemaker.org and I will promptly remove it.
Roberto Francavilla

Course Presentation
Welcome to the fascinating world of robotics! If
you've always wanted to build and pilot a robotic
arm, you've come to the right place. "Exploring
Robotics with Arduino" is a detailed guide that will
take you through a journey full of discovery,
combining theory and practice to bring your own
robotic arm to life.
Course Content:
Essential Theory; Before getting into the details
of hands-on projects, you will gain a solid
understanding of the theory behind piloting a six-
degree-of-freedom robotic arm. You will learn the
fundamental concepts of kinematics and control
needed to make your robot move accurately.
Practical Projects; Fourteen practical projects
will show you how to pilot a robot arm, and in
particular:
Bluetooth Control: Using the Bluetooth
module, you will learn how to operate the
robotic arm via an app on a smartphone or
tablet. This project will introduce you to
remote control and wireless communication.
PCA9685 Control Board Piloting: With this
control 
board, 
you 
will 
explore 
new
possibilities for movement and precision in
robot arm piloting. You will learn how to

configure and use the PCA9685 to achieve
smooth and precise movements.
PS2 Controller: Using a PS2 controller, you
will bring your robotic arm under your
command. This project will show you how to
interface the PS2 controller with Arduino for
intuitive and immediate control of your robot.
Video-Projects: Each project is accompanied by a
detailed video that will guide you step by step
through the process of building and piloting the
robotic arm. Links at the end of each tutorial will
allow you to easily access the videos and related
codes used.
Use of Processing: We will use Processing to
create graphical representations of the robot's
movements, 
making 
learning 
even 
more
engaging and providing a visual understanding of
theoretical concepts.
Conclusions:
With "Exploring Robotics with Arduino," you will not
only learn how to build and drive a robotic arm, but
you will also gain a solid knowledge base that will
allow you to further explore the world of robotics and
automation. Whether you are a curious beginner or
an electronics expert looking for new challenges in

robotics, this book will be your guide into the world of
robotics with Arduino.
Get ready to bring your ideas to life and explore the
future of technology with "Exploring Robotics with
Arduino"!

LESSON 1 - Introduction
The new Course is dedicated to an extraordinary
robotic tooling that has applications in so many
fields, 
from 
the 
automotive 
industry 
to
pharmaceuticals, storage, etc., and that is the
"Robotic Arm" or also called in English "Robot Arm."
Obviously, for our studies, we will use a "simplified"
robotic arm for educational purposes, but this does
not detract from the fact that its functionality and
programming logic is quite similar to industrial-type
robotic arms.
In particular, the Course will explain the main
features of the operation of a robotic arm and its
programming to achieve all the movements we need.

The basic knowledge required is about the Arduino
platform, so if you have gaps in this regard, they can
be filled by viewing my Basic Course on Arduino.
For those who wish to purchase a robot arm and
immerse themselves in exciting robotics projects,
before doing so I suggest you watch the videos at the
links in Lesson 2.

The Basics of Robotics: Degrees of Freedom
(DOF) and Electric Drives.
Movements, limb movements, torso rotation.... are
the movements that enable a robot to perform those
activities that we want it to do in order to perform the
assigned (programmed) task.
Let us give an example to better understand the
concept of motion by analyzing one of the most
widely used robots in industrial processes for mass
production: the Puma Robot.

This robot, which is nothing more than a mechanical
arm, is widely used in the automotive industry for
welding, painting, moving heavy components, placing
components in precise locations in assemblies and
storage, etc.
From this we understand how the first question robot
designers ask is: what should our Robot do ?
The complexity in designing a Robot lies in the
number of motions to be given and consequently the
number of "motion joints" to be inserted; in the
particular case of the figure, there are six.
But how do we determine how many joints to insert?

The answer lies in determining whether our working
point should be able to move in space, or on a plane,
or a line.
Suppose a rigid body can
only translate along its axis (straight line), such a
possibility of motion is called in Mechanics "degree
of freedom," obviously the other motions that
cannot be made are said to be constrained.
Thus, in this case the motion is characterized by only
one degree of freedom.

In the case represented by the figure on the right,
however, we have that the body can translate along
the abscissae and along the ordinates, that is, it can
move in a plane, so the body is characterized by
having two degrees of freedom.
In this other case (see figure
at left) the body moves rigidly in space, so it is
characterized 
by 
having 
three 
degrees 
of
freedom.

In Physics, but also and particularly in Mechanics, the
position in space of a rigid (solid) body can be
identified by six variables (three of translation
and three of rotation) called degrees of freedom.
Obviously, reproducing by means of a single piece of
equipment the position in space of a body is
impossible (...at least with current technological
knowledge!), 
because 
there 
are 
"constraints"
imposed by the motion-generating equipment, which
are normally electrical drives.
This is why the Puma
Robot has six pivot joints (six electric drives),
because the movement that enables each pivot joint,
as shown in the figure, in turn enables the working
point that is at the end of the arm, to reach "any"
point in space and its relative position is always
known.

Electric drive (or also called Power Drive System:
PDS) is defined as a system that converts electrical
energy into mechanical energy with the help of
power and control electronic equipment.
The motors used for electric drives are shown in the
diagram below.Obviously, I do not wish to teach a
course in Electric Machinery, but I just wish to show
you the significant number of electric motors we
have available to us in order to give the mechanical
motion we want.

For our purposes and applications with Arduino we
generally use two types of drives: Stepper motors
and servo motors.
After this first theoretical part that is also a tad
challenging, but necessary to give us a minimal
foundation 
in 
robotics, 
we 
move 
on 
to 
the
construction of our laboratory.

We prepare our Laboratory
There are several models of robotic arm currently on
the market, the major differences between the
various proposed KITs are: the degrees of freedom
(DOF) of the arm, the material from which the robotic
arms are made, and the type of servomotors used to
give the robotic arm movements.
Obviously, the above characteristics translate into
cost, and the cost of a robotic arm KIT can range from
a few tens of euros to a few hundred euros, so before
purchasing keep in mind that the choice must first
and foremost take into account how far we wish to go
in studying the robotic arm.
Since the Course aims to provide all those basic tools
that one needs to know in order to then venture
independently into this amazing world, for this
purpose we will use a robotic arm with an aluminum
frame, 6 degrees of freedom and with servomotors of
the MG996R type.

The trickiest part in choosing, as you will see later in
the lesson, is the choice of servomotors also because
they are very expensive components.
In addition to our robotic arm we will need a
stabilized power supply with a DC output voltage
possibly variable, via potentiometer, between 5V and
12V and current output of at least 2A-3A. Finally we
need our microcontroller, which initially will be an
Arduino Uno R3.

A little Physics to get you started: Force,
Momentum and Torque.
Before we venture to fiddle with our robotic arm, as
usual, I would also like to introduce those theoretical
aspects derived from the STEM disciplines that
characterize all my Courses. In particular, I would like
to give some principles of Physics that will be used to
better understand what we will see during the study
of the robotic arm.
In particular, we will focus on Mechanical Physics,
which consists of the study of the motion of bodies
and the causes that determine it. It is divided into
three specific areas:  
-                  Kinematics; which deals with the study of
motion independently of its causes;
-                  Dynamics; for the study of motion and its
causes;
-         Statics; for the study of equilibrium conditions.

Analyzing the figure above from a Statics point of
view, we can observe that the man (or even a
woman!) is lifting a 5 kg weight and holding it
suspended in the air.
Let 
us 
analyze 
this 
situation 
by 
making
approximations that simplify the analysis but still
help us understand the fundamental concepts we
need. Let us assume that the entire arm has zero
weight, so the only force acting on the arm is the
weight force of the object lifted by the hand. From
this representation it is easy to see that to keep the
object lifted I will have to react with my arm with an
equal and opposite force.
But what does it mean to react with an equal and
opposite force?
We schematize the above by adding the possibility of
rotating the arm at shoulder height by adding a pivot
joint.

So the weight force tends to rotate our arm
clockwise, creating a "Momentum" denoted "M" at
the center of our joint equal to the product of weight
force "P" and arm "b."
M = P x b
So to keep the weight lifted my muscles must create,
in the rotational joint (also called the "hinge"), a "Mr"
moment (Moment of Reaction) of opposite direction.
Now the next question is, what about the robotic
arms, who as of now?
The answer is simple: the Servomotor.

For servomotors, but more generally for electrical
machines, on datasheets, we generally do not speak
of "Momentum of a force," but of "Torque" (in some
rare cases of Torque Moment).In fact, Torque is
defined as the action, on an axis of rotation, of two
coplanar and parallel forces and having opposite
directions spaced "r" apart. The Moment generated
by the Pair of Forces is given by the product:
Mr = F x r
With these basic notions of Physics, it is therefore
already 
possible 
to 
make 
several 
important
considerations, for since our robotic arm will have to
move weights with the hand (i.e., at the tip of the
arm), the longer the robotic arm or the heavier the
object, the more torque the servomotor will have to
have in order to move the object itself.

In the above analysis we did not consider the weight
of the arm, which already in itself, depending on the
material it is made of, introduces an additional force
and therefore moment that must be won in order to
make it move.
At each rotational joint we have to insert a
servomotor, 
and 
having 
a 
higher-performance
servomotor also means that the power supply
available from the Arduino is not sufficient to power
the servomotors, so an external power supply will be
used with a voltage that must be compatible with the
maximum voltage allowed by the servomotor itself.

The MG996R Servomotor.
We have seen the importance of choosing the right
servomotor in the previous section, now let's look in
detail at its operation by focusing on the one that is
normally 
used 
for 
educational 
robotic 
arm
applications, namely the MG996R.
Below is an excerpt from its data sheet:

Let us see what kind of information is provided to us
by the servomotor manufacturer. First of all we are
given information about the dimensions, these of
course are very important especially if we buy the
servomotors separately from the robotic arm, in fact
we need to check the compatibility of the available
slots and attachment points on the components with
the dimensions of the motors.
Then we are told that the supply voltage (operating
voltage) can be between 4.8V and 7.2V, and the
supplier also tells us what is the maximum torque

that the servomotor can release, indicating it as stall
torque (English: stall torque).
We are also given an indication of the maximum
current at the maximum torque, and with the colors
of the cables, we are also given an indication of how
to connect the servomotor.
It should be kept well in mind that all Servomotors
are considered Electric Drives in that they consist
of an electric motor that converts electrical energy
into mechanical motion, have a sensor system to
return feedback to the control system that corrects
and adapts the movements of the electric motor so
that it responds properly.
Let's resume the quick schematization already seen
in the previous section:
The sensors normally used to measure and release
feedback to the Servomotor control system are either
Potentiometers (in which case you have analog type
control) or Encoders (in which case you have digital
type control).

The figure above shows what an analog-controlled
Servo with Potentiometer looks like, while the figure
below shows a typical digitally controlled Servo Motor
with Encoder.
Well! At this point, after this description of the
Servomotor, let's learn how to use it properly.
Already in Lesson 6 of the Basic Arduino Course, we
learned how to program the SG90 servomotor, I invite
you to go and review the lesson because we will do
more here and still start from a minimum knowledge
base.

The importance of testing Servos and initial
configuration.
Before the robotic arm is assembled, it is absolutely
necessary to test the proper operation of each
servomotor and especially to establish the initial
configuration (i.e., the initial rotation angle) of the
rotor. In fact, since servos have a minimum and a
maximum angle of rotation, it is possible that by
misplacing the rotor and attaching it to the arm, the
correct rotation may not be achieved because it is
prevented by the physical interference created
between the various parts of the assembled arm,
forcing us to disassemble everything.
To do this we can go two ways, either create a servo
test sketch and use Arduino as a tester, or purchase a
servo tester.
We will see both solutions and the one we are best
satisfied with, we will use.

Project 01 - The Servo Tester
The Servo-tester is a small device that you can buy
on major market places for a few euros, has two
predefined connection verses, and you can test up to
three servos at once (but, personally, I do not
recommend it).
It has three modes of operation Man = manual, i.e.,
turning the potentiometer generates the rotation of
the rotor, Neutral = neutral, i.e., the rotor positions
itself at half of its maximum rotation and finally Auto
= automatic, the servo rotates by predefined steps
going from its minimum to maximum value and with
the potentiometer you adjust the speed (which
obviously depends on the type of servo). To switch
from one mode to another there is a switch at the
lower left indicated by Select and the mode chosen is
indicated by an LED that lights up.
For this project we need:

Very important is to follow the correct connection of
the power poles otherwise you risk burning out the
servo tester which has no protection for this (in fact I
burned one).
The scheme to be used is as follows:
[For the video related to the project click here].
Project 02 - The Servo Tester with Arduino

The purpose of this project is to reproduce the
functionality of the servo tester, seen in the previous
project, with Arduino and perhaps add a few more
functions that don't hurt.
For this project we need:

The wiring diagram is:

The Mounting Pattern:
The sketch is:
/*
BeMaker.org - ROBOTIC ARM.
Project 02 - SERVO-TESTER
*/
#include <Servo.h> // Call Servo.h librery
Servo ServoMotor; // Create an object called ServoMotor
int LedMan = 7; //select the pin for Manual Mode
int LedNet = 6; //select the pin for Neutral Mode
int LedAut = 5; //select the pin for Auto Mode
int PinhButton =10; //select the pin for Button Pushed check
int PinServo = 11; //select the pin for Servo Signal
int PushButton = 0; //status button pushed

int value_A0 = 0; //Potentiometer value
int map_A0 = 0; //Potentiometer value mapped to digital
value
int selection = 1; //Case selection
int max_angle = 0;
int neutral_value=0;
void setup() {
  Serial.begin(9600);
    pinMode(PinServo, OUTPUT);
    pinMode(LedMan, OUTPUT);
    pinMode(LedNet, OUTPUT);
    pinMode(LedAut, OUTPUT);
    pinMode(PinhButton,INPUT_PULLUP);
    ServoMotor.attach(PinServo);
    ServoCaratteristics();
}
void loop() {
  switch (selection) {
    case 1:
      digitalWrite(LedMan, HIGH); //Led_Man ON
      digitalWrite(LedNet, LOW); //Led_Neu OFF
      digitalWrite(LedAut, LOW); //Led_Auto OFF
      PushButton=digitalRead(PinhButton);
      delay(200);
      if (PushButton!=0) selection = 2;
      value_A0 = analogRead(A0);
      map_A0 = map(value_A0, 0, 1023, 0, max_angle);
      ServoMotor.write(map_A0);
      Serial.print("Max Servo Rotation Angle =");
      Serial.print(max_angle);
      Serial.print(" ");
      Serial.print("Current rotation Servo =");
      Serial.print(map_A0);
      Serial.println(" ");

    break;
    case 2:
      digitalWrite(LedMan, LOW); //Led_Man OFF
      digitalWrite(LedNet, HIGH); //Led_Neu ON
      digitalWrite(LedAut, LOW); //Led_Auto OFF
      PushButton=digitalRead(PinhButton);
      delay(200);
      if (PushButton!=0) selection = 3;
      neutral_value=max_angle/2;
      ServoMotor.write(neutral_value);
      Serial.print("Neutral Angle Servo (at half of the
maximum value) =");
      Serial.print(neutral_value);
      Serial.println(" ");
    break;
    case 3:
      digitalWrite(LedMan, LOW); //Led_Man OFF
      digitalWrite(LedNet, LOW); //Led_Neu OFF
      digitalWrite(LedAut, HIGH); //Led_Auto ON
        for(int i=1;i<=max_angle;i++){
            PushButton=digitalRead(PinhButton);
            if (PushButton!=0) {selection = 1;}
              value_A0 = analogRead(A0);
              map_A0 = map(value_A0, 0, 1023, 1, 10);   
              ServoMotor.write(i);
              delay(3*map_A0);
        }
        for(int i=max_angle;i>=1;i--){
            PushButton=digitalRead(PinhButton);
            if (PushButton!=0) {selection = 1;}
              value_A0 = analogRead(A0);
              map_A0 = map(value_A0, 0, 1023, 1, 10);   
              ServoMotor.write(i);
              delay(3*map_A0);
        }
      break;

}
}
void ServoCaratteristics() {
  int t=0;
  int p=0;
  for(int i=1;i<=359;i++){
    t=t+1;
    if (t<6){
      digitalWrite(LedMan, HIGH); //Led_Man ON
      digitalWrite(LedNet, HIGH); //Led_Neu ON
      digitalWrite(LedAut, HIGH); //Led_Auto ON
        p=0;
      }
    else {
      digitalWrite(LedMan, LOW); //Led_Man ON
      digitalWrite(LedNet, LOW); //Led_Neu ON
      digitalWrite(LedAut, LOW); //Led_Auto ON
        p=p+1;
        if (p>6) t=0;
}
    if (max_angle >= i-1){
      ServoMotor.write(i);
      max_angle = ServoMotor.read();
      delay(30);
}
  }
}
Final thoughts on Project 02:
Basically with this project we reproduce what is the
functionality of the servo-tester device seen in the
previous project, but using Arduino. Since we have a
microcontroller at our disposal, of course, we also
make it do other things to our servo tester-in fact, at

startup an automatic routine starts that determines
the maximum angle of rotation that the servo can
make. Based on that maximum angle, which can be
read if we open the serial port window (serial
monitor), the next functions are executed : Man,
Neutral and Auto.
Interesting is the adjustment by potentiometer of the
speed of execution of the auto feature.
[For the video related to the project click here].
[For the sketch related to the project click here].

LESSON 2 - Assembly of the Robotic
Arm.
This lesson is dedicated to the assembly of the
Robotic Arm. Let me preface this by saying that it is
not a very simple operation, but at the end, when
you finish, you will surely feel very satisfied and
proud...
Since I have purchased a robotic arm from DOIT, I will
use the description and assembly sequence given by
them and will add, from time to time, some
comments, but mostly suggestions to try to prevent,
as 
much 
as 
possible, 
assembly 
errors 
that
unfortunately sometimes emerge only at the end
when you start giving the first movements to the arm
itself.
The reference site of the Shenzhen DOIT Doctors
of Intelligence & Technology is at this link

Consider that DOIT sells its products mainly on e-
commerce platforms such as Aliexpress.
Below, after checking the components, I give you the
links of the video-assembly I performed for the DOIT
robot arm, it is divided into three parts otherwise the
video would have been too long, however the
assembly is also given in the following paragraphs
with photos and all the tips I mentioned earlier.
Components of the Robotic Arm
At the following link you can see the unboxing of the
Robot Arm.
[For video related to unboxing click here].
Pictured below are all the various parts we will need
to assemble:


Regarding servomotors, I personally used MG996Rs,
the number of servomotors depends on the degrees
of freedom we wish to create, since I also purchased
the gripper (which we will see later) the number of
total servomotors is 7.
Video-Assembly of the Robot Arm
At the following links you can find the video-assembly
with all the tests I suggest doing to check the correct
assembly of the Robot Arm from time to time.
[For video related to assembly Part 1 - click here].
[For video related to assembly Part 2 - click here].
[For video related to assembly Part 3 - click here].
As you will see from the videos, in assembling and
testing the robot arm from time to time it also leads
to further consideration and correction of what were

my initial purchasing choices, so I suggest you watch
them.

Assembly of the Base of the Robotic Arm
Obviously the assembly depends very much on what
you have purchased
It starts with the assembly of the base:
The spacers are mounted and the nuts for locking the
horizontal ball bearing (also called washer) are
prepared.

Be careful, the flat side of the hex nut should face the
base of the bearing to hold it in place, basically the
bearing should fit into the four nuts and remain
stationary.

We move on to attach the attachment bracket on the
first servomotor, which will be the one used to rotate
the base.

This servomotor must have 90° angle of repose, so
before assembly, make sure the rotor is in the correct
position using what was learned in Lesson 1.

At this point, the assembly of the base is completed
by inserting the bearing balls and securing the base
support in the subframe, so that the ball bearing is
enclosed between the two parts, one of which will be
fixed and the other will rotate due to the action of the
servomotor.
WARNING:
Since the washer (the horizontal bearing) is held in
compression by the two elements that are attached
by the central screw to the rotor, if this screw is
tightened too much, the washer turns out to be very
compressed and thus the rotation of the arm base
will be very difficult. On the contrary, if it is not
tightened properly, the balls come out of their seats
and thus do not allow the correct movement. So you

need to find the right tightening of the screw, I
personally to also improve the movement of the fifth
wheel added in a couple of drops of oil after
tightening. Another thing that needs to be said is that
with the use of the arm, the screw tends to unscrew,
so arm yourself with holy patience and every now
and then check that it is tightened to the right point.

Arm Assembly

Also in assembling this servomotor, pay attention to
the angle of rotation at rest.






Assembly of the Robotic Arm Elbow







Robotic Arm Wrist Assembly



Assembly of the Forearm of the Robotic Arm


At this point it remains to assemble the gripping
accessories; I purchased two types:
-         The claw pliers
-         The suction cups
For these accessories we will see later how to
assemble and use them.
Now we move on to the testing phase of the servo
motors of the assembled robotic arm and begin to
see about understanding how the "Work Space" of a
robotic arm is defined.
Project 03 - Work Space Definition of the Robot
Arm with Arduino

The purpose of this project is twofold, the first is to
verify the proper operation of the servomotors
assembled on the robotic arm, in fact we need to
verify that our robotic arm can move smoothly . First,
we name the servos as shown in the figure:

Also shown on the figure above are, in different
colors, the various movements that individual servos
allow the Robotic Arm to make.
The second purpose of the project is to define the
Minimum Angle of Rotation and Maximum Angle of
Rotation of each individual Servomotor of the Robot
Arm, so that we can understand what movements the
arm will be able to make and thus in what space it
will be able to operate (hence the definition of Work
Space or Work Space).
We will talk more about the Work Space later, for now
let us proceed to implement the design to determine
the maximum and minimum rotations.
At this point we move on to project implementation,
for this project we need:

The wiring diagram is shown below:
Instead, the assembly diagram is as shown below:

Before proceeding, some suggestions:
[Note 1]
Obviously instead of the SG90 servomotor, shown in
the figure, we are going to connect and test each of
the individual servomotors of the Robotic Arm. After
installing the sketch on Arduino, open the serial
monitor and you will find three values on the screen:
the potentiometer value indicating the current
rotation sent to the servomotor, the maximum
rotation of the servomotor under test, and the
minimum rotation. To have the latter values stored,
rotate the arm with the potentiometer to its
maximum achievable angle and then to its minimum.
[Note 2]
During testing, keep the base of the robot arm firmly
in place otherwise you risk that with the movement it

will fall and then with the rotation of the arm you will
damage some servos or even the aluminum structure
of the arm itself. If you want to remedy this
inconvenience, I suggest you buy a good solid wood
base on which to fasten the robot arm base, or, as I
did, I went to a craftsman who works with iron and at
an expense of about 15 euros I had an iron base
made weighing about 1 kg on which to bolt the robot
arm.
The sketch to be installed on Arduino is as follows:
/*
BeMaker.org - ROBOTIC ARM.
Project 03 - MINIMUM AND MAXIMUM SERVO ROTATION OF
THE ASSEMBLED ARM.
*/
#include <Servo.h> // Call Servo.h librery
Servo ServoMotor; // Create an object called ServoMotor
int PinServo = 11; //select the pin for Servo Signal
int value_A0 = 0; //Potentiometer value
int map_A0 = 0; //Potentiometer value mapped to digital
value
int max_angle = 0; //Maximum angle value
int min_angle = 180; //Minimum angle value
int angle = 0;
void setup() {
    Serial.begin(9600);
    pinMode(PinServo, OUTPUT);
    ServoMotor.attach(PinServo);
}

void loop() {
  value_A0 = analogRead(A0);
  map_A0 = map(value_A0, 0, 1023, 0, 180);
  ServoMotor.write(map_A0);
  angle = ServoMotor.read();
  if (angle >= max_angle) max_angle=angle;
  if (angle <= min_angle) min_angle=angle;          
  Serial.print("Angle required by Potentiometer =");
  Serial.print(map_A0);
  Serial.print(" ");
  Serial.print("Max Servo Rotation =");
  Serial.print(max_angle);
  Serial.print(" ");
  Serial.print("Min Servo Rotation =");
  Serial.println(min_angle);
}
The project allows not only to test the individual
servos in the arm but also to see what are the
maximum permissible rotations of the arm, in fact,
for example, from the project video we see that Servo
3, the one that rotates the forearm, theoretically
would have a range of 0 to 180°, but this is because
Servo 2 does not turn out to be powered and
therefore with the rotation of the forearm there is
also the rotation of the arm (the one induced by
Servo 2), in reality, and we will also see this later,
when Servo 2 is powered and therefore will keep the
rotation of the arm locked in its defined position,
Servo 3 will have a rotation variation ranging from a
minimum of 37° to a maximum of 159°. 
[For the video related to the project click here].

[For the sketch related to the project click here].

LESSON 3 - Piloting a Robot Arm with
6DOF Potentiometer Controller
With this Lesson we begin to see how you can control
the movements of a robotic arm, of course we will
start with the simplest methods until we push on to
really interesting ways.
This mode of control of the Robot Arm is derived from
the potentiometer control of servos already seen in
the initial part of the Course for the initial
adjustment, precisely, of servos. It basically uses a
shield with six potentiometers and is called "6DOF
Controller with Potentiometers," obviously being 6
potentiometers, we are able to drive six servos
(hence the name 6DOF, remember DOF stands for
Degrees Of Freedom ). The shield mounts on top of

Arduio Uno R3 to form a sandwich (you make the PINs
align and it can only be mounted from one direction).
The power supply for the six servos is, of course,
external via appropriate power supply (always
remember that 6 servomotors draw a current that
Arduino will never be able to deliver, so the external
power supply is essential).
At this point, schematizing our robot arm as in the
figure 
below 
and 
tapping 
the 
names 
of 
the
servomotors according to the motion they produce,
we have:
-         S1 - BASIC ROTATION
-         S2 - ARM ROTATION
-         S3 - ROTATION 1 FOREARM
-         S4 - ROTATION 2 FOREARM
-         S5 - ROTATION 1 WRIST
-         S6 - ROTATION 2 WRIST

- 
 
 
 
 
 
 
 
  S7 - OPENING/CLOSING CLAMP (NOT
REPRESENTED GRAPHICALLY)
The connections of individual servos will be made
based on the indications on the shield (see figure
below).
-         Controller 1 ---> A0 --> Servo 1
-         Controller 2 ---> A1 --> Servo 2
-         Controller 3 ---> A2 --> Servo 3
-         Controller 4 ---> A3 --> Servo 4
-         Controller 5 ---> A4 --> Servo 5
-         Controller 6 ---> A5 --> Servo 6

-         Signal S Servo 1 ---> PIN Dig. 3
-         Signal S Servo 2 ---> PIN Dig. 5
-         Signal S Servo 3 ---> PIN Dig. 6
-         Signal S Servo 4 ---> PIN Dig. 9
-         Signal S Servo 5 ---> PIN Dig. 10
-         Signal S Servo 6 ---> PIN Dig. 11
As you can see, the control PINs of the servos, as
well as the analog PINs of the potentiometers, are
already predefined by the shield (WARNING: NOT
ALL SHIELDS REPRESENT SUCH INFORMATION,
HOWEVER, IT IS A STANDARD), so in the sketch you
will need to refer to the PINs already defined.
Project 04: Hello World of the Robot Arm.
This first Robot Arm control project is basically
comparable 
to 
the 
initial 
projects 
of 
a 
new
experience, and therefore I wanted to call it the Hello
World of the Robot Arm. It is a very simple project
that allows us to drive the Robot Arm in manual
mode by acting on the potentiometers on the shield.

For this project we need:
The wiring diagram (in the case of using 6 separate
potentiometers) is as follows:

The assembly diagram (in the case of using 6
separate potentiometers) to be made is as follows:

Once the circuit is assembled, the sketch to be
written and uploaded to Arduino is:
/*
BeMaker.org - ROBOTIC ARM.
Project 04 - HELLO WORLD
*/
#include <Servo.h> // Call Servo.h librery
Servo ServoMotor1; // Create an object called ServoMotor1
Servo ServoMotor2; // Create an object called ServoMotor2
Servo ServoMotor3; // Create an object called ServoMotor3
Servo ServoMotor4; // Create an object called ServoMotor4
Servo ServoMotor5; // Create an object called ServoMotor5
Servo ServoMotor6; // Create an object called ServoMotor6
int PinServo1 = 3; //select the pin for Servo Signal
int PinServo2 = 5; //select the pin for Servo Signal
int PinServo3 = 6; //select the pin for Servo Signal
int PinServo4 = 9; //select the pin for Servo Signal
int PinServo5 = 10; //select the pin for Servo Signal

int PinServo6 = 11; //select the pin for Servo Signal
int value_A0 = 0; //Potentiometer value
int map_A0 = 0; //Potentiometer value mapped to digital
value
int value_A1 = 0; //Potentiometer value
int map_A1 = 0; //Potentiometer value mapped to digital
value
int value_A2 = 0; //Potentiometer value
int map_A2 = 0; //Potentiometer value mapped to digital
value
int value_A3 = 0; //Potentiometer value
int map_A3 = 0; //Potentiometer value mapped to digital
value
int value_A4 = 0; //Potentiometer value
int map_A4 = 0; //Potentiometer value mapped to digital
value
int value_A5 = 0; //Potentiometer value
int map_A5 = 0; //Potentiometer value mapped to digital
value
void setup() {
    Serial.begin(9600);
    pinMode(PinServo1, OUTPUT);
    ServoMotor1.attach(PinServo1);
    pinMode(PinServo2, OUTPUT);
    ServoMotor2.attach(PinServo2);
    pinMode(PinServo3, OUTPUT);
    ServoMotor3.attach(PinServo3);
    pinMode(PinServo4, OUTPUT);
    ServoMotor4.attach(PinServo4);
    pinMode(PinServo5, OUTPUT);
    ServoMotor5.attach(PinServo5);
    pinMode(PinServo6, OUTPUT);
    ServoMotor6.attach(PinServo6);
}

void loop() {
  value_A0 = analogRead(A0);
  map_A0 = map(value_A0, 0, 1023, 0, 180);
  ServoMotor1.write(map_A0);
  value_A1 = analogRead(A1);
  map_A1 = map(value_A1, 0, 1023, 0, 180);
  ServoMotor2.write(map_A1);
  value_A2 = analogRead(A2);
  map_A2 = map(value_A2, 0, 1023, 0, 180);
  ServoMotor3.write(map_A2);
  value_A3 = analogRead(A3);
  map_A3 = map(value_A3, 0, 1023, 0, 180);
  ServoMotor4.write(map_A3);
  value_A4 = analogRead(A4);
  map_A4 = map(value_A4, 0, 1023, 0, 180);
  ServoMotor5.write(map_A4);
  value_A5 = analogRead(A5);
  map_A5 = map(value_A5, 0, 1023, 0, 180);
  ServoMotor6.write(map_A5);
}
Once the sketch is loaded, proceed with powering the
servos and then you can have fun driving the arm by
operating the various potentiometers.
Considerations on Robot Arm's Project 04 Hello
World.
I would like to highlight here some of my personal
observations that came up during the realization of
the project. First of all, during the assembly phase it
was necessary to add extensions to the servo cables,
when you do this, I recommend utmost attention to
the colors of the cables you connect, always

remember that the orange cable is the signal, the red
one is the power and the brown one is the GND, so
the cables you are going to connect make sure that
they are then correctly connected on the control
shield.
Another aspect that I would like to point out is the
supply voltage, theoretically it should be 5 V for the
servos, but I noticed that my power supply could not
deliver the necessary current to the servos that were
running and the servos tended to overheat due to the
high current required, so try raising the voltage.
Obviously this depends on the maximum voltage
allowed by your servo motors, in my case I tried
supplying power at about 7 V (with maximum voltage
of about 7.5V) and things went much better,
especially for the S3 servo that allows the forearm to
bend. I noticed that the S3 servo is the most stressed
mechanically and therefore also electrically.
A final point should be made about the controller, in
fact, potentiometers, especially those of less than
excellent quality (like the ones I used), produce a
nonlinear, sometimes jerky output signal, especially
for certain positions, this obviously affects the
movement of the arm, which is not smooth and
homogeneous.
[For the video related to the project click here].
[For the sketch related to the project click here].

LESSON 
4 
- 
Bluetooth 
wireless
communication with Arduino
In this Lesson we will learn how to wirelessly connect
our Arduino with other devices via Bluetooth.
For this control mode, we will use the HC-05 Module,
which basically allows Arduino to communicate with
the outside world (bidirectionally) via Bluetooth.
Since the use of the HC-05 Module with Arduino
opens up multiple scenarios for really interesting
projects, before we look at how to drive a robotic arm
in Bluetooth mode, let's focus on this module and its
use with Arduino by devoting an entire Lesson of the
Course to it.
General Description of Bluetooth Standard
The Bluetooth communication standard is used for
wireless 
personal 
area 
network 
(WPAN) 
data
transmission. It is a standard that has found
tremendous success because it is cheap and secure
and allows information to be exchanged between

different devices via a short-range radio frequency.
The connection is made between different devices in
the area covered by the radio signal (up to a few tens
of meters). These devices can be, for example,
smartphones, tablets, PCs, printers, headphones,...
and even our Arduino.
Now, it is not my intention to explain and go into the
technical details of Bluetooth (abbreviated: BT)
communications since you can find countless videos
and articles on the Internet that do so, so I will just
give a rough and also very superficial description of
it, just to give you an idea and to transfer to you the
most important information.
The 
principle 
of 
communication 
between 
LV-
connected devices is what is known as Master /
Slave, that is, the master device scans in its own
range and once it detects a second device, it asks for
the possibility of connection. The slave grants the
connection and the two devices connect forming a
network called a piconet. The connection is of the
paring type, that is, the device, once active in
communication with another device, is no longer
available to another different communication.

Because of what has been explained above, within a
piconet there will be at least one master device,
which is the device that takes care of everything
related to clock synchronization, while the other
devices that are synchronized to the master are
called slaves.
With BT there is the possibility of being able to
connect Arduino to any device (PC, Smartphone,
etc..) and already there are Apps, especially in the
Android and Windows world, that allow this in an easy
way.

The HC-05 Bluetooth Module for Arduino
The module is basically the one shown in the photo
(the "basically" is because you can find modules with
small differences on the market; I happened, for
example, to buy a module that did not have the
button to enter AT mode, but since I found it very
useful I suggest you buy it with the button, otherwise
you will need to substantially modify the sketch and
connections provided in the project that follows).
On the front is clearly visible the "Enable" button
which is used to enter the Module configuration mode
(red arrow) and also visible is the LED which,
depending on its blinking speed, gives us indications
(green arrow):
-                  Constant fast blinking: Means the module is
turned on and is ready to connect to other

devices.
-         No. 1 blink every about 2 seconds: the Module is
in configuration mode (or also called AT mode),
that is, it is waiting to receive commands in AT
Mode (AT commands are commands sent in
ATtention 
Mode 
that 
are 
basically 
serial
commands).
-                  LED on steady, means the HC-05 module is
connected in a piconet network.
Let us turn to the back of the HC-05 form:

As you can see there are 6 PINs:
EN: the pin if put in LOW state (or not connected)
disables the configuration mode, if put HIGH or the
key is pressed, it enters configuration mode. AT
commands must be sent for configuration (for
examples and list of AT commands you can refer to
the most commonly used commands given in the
table below.
VCC: is the power supply pin whose voltage can be
between 3.6 V and 6 V. It can be powered directly by
Arduino at 5 V.
GND: the ground (earth) to be connected to the GND
of the Arduino
TXD: serial output of the module, to be connected to
the RX of Arduino and operates at 3.3V.
RXD: serial input of the module, to be connected to
the TX of Arduino and operates at 3.3V.
STATE: The pin switches from the LOW state to the
HIGH state when the module is connected via
Bluetooth; if connected to an Arduino Input PIN, it
can be used to handle an event related to the
Bluetooth connection.
The "EN" and "STATE" PINs are normally not used.
Special attention should be paid to the working
voltage of the Tx and Rx signals, which as also
indicated by the module manufacturer, work at 3.3V,
while Arduino has a working voltage of the PINs at
5V.

To overcome this drawback and thus not jeopardize
the functionality of the LV module, it is necessary to
use a so-called " Bi-Directional Logic Level Converter
" or also called "Bi-Directional Level Shifter" or simply
"Bi-Directional Level Converter."
Bidirectional logic level converter
First, let us say that the application of the Level
Converter is suitable for all those devices (such as
Arduino) that work on 5V logic signals that need to
be connected to sensors, or displays, that instead
work with 3.3V logic.
The Converter is in breakout format and is a
bidirectional logic level converter, the one in the
photo is 4-channel designed for I2C. The converter
has 4 BSS138 FETs with 10K pull-up and works with
signals (LV side) as low as 1.8V, while for the HV side
up to 10V. The Converter also works with Serial SPI
type communication with frequency below 2 MHz.
It is commercially available in the fully assembled
and tested version with 4 complete bidirectional
conversion lines and 2 6-pin headers already
soldered, or with the headers to be soldered.

The operation of the module is very simple, all it does
is to take the 3.3V signal and convert it into a 5V
signal and vice versa, so the module is characterized
by having two sides, one 3.3V and the other 5V. The
one in the picture is a module capable of converting
4 separate channels, so in our case, since we only
need to convert the two Rx and Tx channels, it is just
fine.
The 5V side is identifiable by the abbreviation "HV...,"
and the 3.3V side "LV...." Connecting the module with
Arduino and the possible sensor/display/module to
3.3V logic signals is very simple:

HC-05 Bluetooth module in configuration mode
and AT commands
Let us say right away that the module, when it is
newly purchased already has a default configuration
that meets our needs and in particular:
-         Device name: HC-05
-         Mode of use as: Slave
-         Baud rate of: 9600 baud
-         Pin-Password: 1234
However, sometimes we need to change the settings,
either to change the name, or to change the PIN of
the password, or even the mode of operation, not as
Slave, but as Master.
To do this requires adopting a specific procedure that
is not always described in a timely and precise
manner and which I will instead attempt to do with
the following project.

Project 05: Configuration mode of the HC-05
Bluetooth Module .
First of all I will tell you that configuring the HC-05
Bluetooth Module through AT commands, once you
understand the procedure, is really very easy to do.
The difficulty is in the procedure, mainly because it is
not fully and exhaustively described either by the
module vendor or even in the various videos that are
posted on the net on that subject.
Arduino Uno R3
Dupont
male - male
cables
USB
connection
cable
HC-05
Bluetooth
module
(with EN
button)

Bi-Directional
Level Shifter
For this project we need:
The scheme to be carried out is as follows:

I would like to point out first of all that the 3.3V
voltage for the "LV" side of the converter I took
directly from Arduino which provides that voltage
level, then I would like to point out that the Tx signal
of the HC-05 is connected to the LV1 of the Converter
and the corresponding HV1 of the converter is to be
connected to PIN 6 of Arduino which will be defined
as Rx. Basically, the Tx of the HC-05 module should
be connected to the Rx of Arduino, in fact the module
transmits and Arduino receives. Opposite thing for
the Rx signal of the HC Module which should be
connected to LV2 of the converter and then the
corresponding HV2 of the converter is connected to
PIN 7 of Arduino which will be defined as Tx, therefore
the HC-05 Module Receives and Arduino Transmits.
The GND is the same for Arduino, the Converter and
the HC-05 module, as well as the 5V voltage, is taken
from Arduino and goes to power the HC-05 Module
and the "HV" side of the Converter.
The sketch to be uploaded to Arduino is as follows:
/*
BeMaker.org - ROBOTIC ARM.
Project 05 - MODE CONFIGURATION OF HC-05 BLUETOOTH
MODULE.
*/
#include <SoftwareSerial.h> //Retrieve the SoftwareSerial
library.
#define RxPin 6 //Define PIN 6 as Rx
#define TxPin 7 //Define PIN 7 as Tx
SoftwareSerial btSerial(RxPin,TxPin); //The Rx and Tx
definitions apply.

#define btBAUD 38400 //Define communication speed.
void setup() {
  Serial.begin(btBAUD); //Apply the communication speed to
the serial port.
  delay(100);
  btSerial.begin(btBAUD); //Apply the communication speed
to the HC-05 Module.
  delay(100);
  Serial.println("ready...");
}
void loop() {
  if (btSerial.available()){ //Write what you read from the HC-
05 port.
    Serial.write(btSerial.read());
  }
  if (Serial.available()){ //Write what you read from the serial
port.
    btSerial.write(Serial.read());
  }
}
Analysis of the Project 05 sketch -
Configuration of the HC-05 Bluetooth module.
I would like to point out just one thing about the
sketch that is very important to the success of the
project: when you have to bring the HC-05 Module
into Configuration mode, it is necessary that the
communication Baud Rate is the one used in the
Factory Configuration, normally it is 38400 Baud, pay
attention to the Datasheet issued by the supplier.
Procedure for HC-05 Bluetooth Module
Configuration Mode.

1)       Connect the Arduino to the PC using the USB
cable. This way we are going to power our circuit,
and you will see that the HC-05 module will have
the LED flashing quickly.
2)    Load the sketch to Arduino, of course first make
sure that Arduino is connected to the correct
COM port.
3)       Open the Serial Monitor by clicking on the lens
icon in the upper right corner of the IDE, or by
simultaneously 
clicking 
CTRL+SHIFT+M 
and
selecting in the lower right corner: "38400 baud"
and "Both (NL & CR)" .
4)       If everything went as it should, "ready..." will
appear on the Serial Monitor window.

5)    At this point, disconnect only the HC-05 module
power cable and while holding down the EN
button, reconnect the power cable.
Once the power is reconnected you can release
the EN button and you will see that the HC-05
LED will flash much more slowly, about every two
seconds.
We have entered AT Command Mode and thus
Configuration Mode. To be sure, go to the Seriare

Monitor and type in the command bar: AT
And press enter, you will see that the HC-05
Module will respond to you with OK
Main AT commands for configuring the HC-05
Bluetooth module
The following are the most commonly used AT
commands, obviously those that I personally consider
the most important commands, if you are interested
in knowing others, however, then you can safely
search the internet with the search key "AT
commands for HC-05" :
AT
command
s
Function of the command
AT
Returns OK if the AT connection is
operational
AT + reset
Resets the Module and you exit the
configuration mode
AT +
version
Firmware version
AT + orgl
Returns to factory default settings and
exits configuration mode
AT + addr
To find out the Address of the form

AT + name
Asks or sets the name of the device
AT + rname It asks for the name of the device we
are connected to
AT + role
Queries or sets the role of the device
(1=Master / 0=Slave)
AT + iac
Asks or sets access code requests
AT + pswd
Asks or sets pin password
[For the video related to the project click here].
[For the sketch related to the project click here].

Project 06: Using HC-05 with Arduino. Switch
mode .
Once we understand how to configure our HC-05, we
move on to see how to employ it with Arduino. This
project is very, very simple, but it can be considered
as a basis for much more complex applications.
Basically, through our smartphone, or tablet (but it
could be any device capable of connecting via BT),
we can drive Arduino and turn it into a remote-
controlled switch, for example to turn on lights.
First of all, it should be pointed out that Apple
smartphones since they use the BLE communication
standard, 
or 
Bluetooth 
Low 
Energy 
are 
not
compatible with the HC-05, so we will necessarily
have to use Android and Windows devices.
For this project we will use a very flexible and
programmable generic Android APP that I found very
interesting especially to develop and test some of my
own projects, of course if we want something specific,
we can always make our own APP with the many
tools that can be retrieved on the net.
The APP is called "Arduino bluetooth controller" and
can be downloaded and installed on your Android
device from Google Play at the following link:
https://play.google.com/store/apps/details?
id=com.giumig.apps.bluetoothserialmonitor&hl=it&gl
=US

It is very intuitive and allows us to use Arduino in four
different modes:
-         Joystick
-         Switch
-         Dimmer
-         Data exchange terminal
Once the APP is installed on our mobile device, we
move on to the actual project.
For this project we need:
Arduino Uno R3
Dupont
male - male
cables
USB
connection
cable
HC-05
Bluetooth
module
(with EN
button)

Bi-Directional
Level Shifter
LED
220 Ohm
resistor
The mounting scheme is almost identical to that of
the previous project, only the LED and resistor need
to be added:

The sketch to be uploaded to Arduino is as follows:
/*
BeMaker.org - ROBOTIC ARM.
Project 06 - USE OF HC-05 WITH ARDUINO. SWITCH MODE.
*/
#include <SoftwareSerial.h> //Retrieve the SoftwareSerial
library.
#define RxPin 6 //Define PIN 6 as Rx
#define TxPin 7 //Define PIN 7 as Tx
#define LED_PIN 5 //Define the PIN to which the LED is
connected.
SoftwareSerial btSerial(RxPin,TxPin); //The Rx and Tx
definitions apply.
#define btBAUD 9600 //Define communication speed.
void setup() {
  Serial.begin(btBAUD); //Apply the communication speed to
the serial port.
  delay(100);
  btSerial.begin(btBAUD); //Apply the communication speed
to the HC-05 Module.
  delay(100);
  pinMode(LED_PIN, OUTPUT); //Indicate that the PIN of the
LED is in OUTPUT
  Serial.println("ready...");
}
void loop() {
  if (btSerial.available()){ //Condition met when there is data
on the port of HC-05
    char inChar = btSerial.read();
    Serial.print("Incoming command from mobile device ");
    if (inChar == 'a'){ //Turn on the LED when the character
'a' arrives
      digitalWrite(LED_PIN, HIGH);

      Serial.println("LED: ON");     
    }
    if(inChar == 's'){ //Stop the LED when the character 's'
arrives
      digitalWrite(LED_PIN, LOW);
      Serial.println("LED: OFF");
    }
}
}
At this point we move on to our mobile device, which
in my case is my Tablet on which I installed the APP
and then boot. Having opened the APP we obviously
have to connect the HC-05, so we start the device
search and once we find our HC-05 we are given
indication to connect, for the connection we are
asked for the password which will be "1234".
At this point we have our AP communicating with HC-
05.


Let us then proceed to configure our switch, with 'a'
and 's' for on and off, mind you that to memorize the
letter, once you have typed the letter of interest you
need to click on the green tick button, it works as a
confirmation command, an OK in short.
Once the switch is configured, we return to the main
switch screen and at this point pressing the virtual
button on our switch on the Tablet will turn the LED
on and off.
Analysis of the Project 06 sketch - Use of HC-05
with Arduino. Switch Mode

There are two things I would like to point out to you,
the first is that I have restored the speed to 9600
baud, both for the Arduino port and the Bluetooth
port, and the second is that as you can see from the
code:
if (btSerial.available()){ //Condition met when there is data
on the port of HC-05
the sketch only considers any data coming from the
outside to Arduino and does not handle any data that
should leave from Arduino to the outside.
[For the video related to the project click here].
[For the sketch related to the project click here].

Project 07: Data exchange between
Smartphone and Arduino via BT with HC-05
With this project we take a very significant step
forward from the point of view of using the HC-05
Bluetooth module. In fact, we will use Terminal Mode
on our Smartphone, or Tablet, to query Arduino and
have it return, using a DHT11, the temperature and
humidity present in the monitored environment.
You can easily see the importance of such a feature
illustrated in the project, for example, we can put
Arduino with the various sensors connected in an
inaccessible environment and then through a wireless
BT link, query Arduino to give us returns on the
quantities 
measured 
by 
the 
various 
sensors
connected to it. In addition, I also paid attention to
power saving, in fact the DHT11 sensor module is
activated only when it is interrogated, the rest of the

time it turns out to be off. So the applications are
really countless.

For this project we need:
Arduino Uno
R3
Dupont
male - male
cables
USB
connection
cable
HC-05
Bluetooth
module
(with EN
button)
Bi-Directional
Level Shifter
LED
220 Ohm
resistor
DHT11
sensor
module
The mounting scheme is almost identical to that of
the previous project, we only need to add in addition
to the LED and resistor, the DHT11 sensor module
and in particular:

As can be seen from the schematic, the power supply
for the DHT11 sensor module is connected to digital
PIN 3 of the Arduino, which delivers the required 5 V
when placed in a HIGH state.
The sketch to upload to Arduino is:
/*
BeMaker.org - ROBOTIC ARM.
Project 07 - USE OF HC-05 WITH ARDUINO. TERMINAL MODE.
*/
#include <SoftwareSerial.h> //Retrieve the SoftwareSerial
library.

#define RxPin 6 //Define PIN 6 as Rx
#define TxPin 7 //Define PIN 7 as Tx
#define LED_PIN 5 //Define the PIN to which the LED is
connected.
SoftwareSerial btSerial(RxPin,TxPin); //The Rx and Tx
definitions apply.
#define btBAUD 9600 //Define communication speed.
#include "DHT.h" //Recall library for DHT11
#define DHT_alim 3 //Define the PIN from which I feed the
DHT11
#define DHTPIN 4 //Define the PIN to which the DHT signal
is connected.
#define DHTTYPE DHT11 // Type DHT 11
DHT dht(DHTPIN, DHTTYPE); //DHT object creation.
float h;
float t;
void setup() {
  Serial.begin(btBAUD); //Apply the communication speed to
the serial port.
  delay(100);
  btSerial.begin(btBAUD); //Apply the communication speed
to the HC-05 Module.
  delay(100);
  pinMode(DHT_alim, OUTPUT); //Indicate that the power PIN
of DHT11 is in OUTPUT
  pinMode(LED_PIN, OUTPUT); //Indicate that the PIN of the
LED is in OUTPUT
  digitalWrite(DHT_alim, LOW); //Suppress the default PIN
  digitalWrite(LED_PIN, LOW); //Outputs the default PIN
  dht.begin();
  delay(100);
  Serial.println("ready...");
}

void loop() {
  if (btSerial.available()){ //Condition met when there is data
on the port of HC-05
    char inChar = btSerial.read();
    Serial.print("Incoming command from mobile device ");
    if (inChar == 'a'){ //Turn on the LED when the character
'a' arrives
      digitalWrite(LED_PIN, HIGH); //Light up the LED.
      digitalWrite(DHT_alim, HIGH); //Activating the DHT11
      Serial.println("DHT11: ON... please wait for
measurements");
      delay(3000); // Wait a few seconds between
measurements.
      h = dht.readHumidity(); // Read humidity as % (the
default)
      t = dht.readTemperature(); // Read temperature as
Celsius (the default)
      Serial.print(F("Humidity: "));
      btSerial.print("Humidity: ");
      Serial.print(h);
      btSerial.print(h);
      Serial.print(F("% Temperature: "));
      btSerial.print("% Temperature: ");
      Serial.print(t);
      btSerial.print(t);
      Serial.println(F("°C "));
      btSerial.println("°C ");   
    }
    if(inChar == 's'){ //Stop the LED when the character 's'
arrives
      digitalWrite(LED_PIN, LOW); //Stop the LED
      digitalWrite(DHT_alim, LOW); //Stop the DHT11
      Serial.println("DHT11: OFF");
      btSerial.println("DHT11: OFF");
    }
  }

  if (Serial.available()){ //Condition met when there is data
on the Serial port
    btSerial.write(Serial.read());
  }
}
Analysis of Project 07 sketch - Data exchange
between Smartphone and Arduino with HC-05
As you can see, the sketch is very similar to the
previous one, obviously the part concerning the
DHT11 has been implemented, with the call of the
relevant library that must obviously be loaded first if
it does not already exist, and the part concerning the
release 
of 
information 
by 
Arduino 
once 
the
temperature and humidity values have been read.
The readings are triggered only when the sensor is
turned on and are "printed" both on the serial
monitor and "written" and sent to the LV serial port.
The last "if" in the sketch allows, in case of
maintenance, text to be written in the text bar of the
serial monitor and by pressing enter it appears on the
mobile device connected via BT in terminal mode.
Since I used it during the development of the sketch,
I thought it useful to leave this option as well.
[For the video related to the project click here].
[For the sketch related to the project click here].

Development Environment Installation
Processing
Before proceeding with the next project, it is a good
idea 
to 
install 
the 
Processing 
development
environment, which is a very similar environment to
the Arduino IDE and also allows you to create some
really important graphical interfaces that we will use
with our robot arm.
Without going into the technical details of Processing
because there will be a Course dedicated to this
other development environment, let me just tell you
that in making the Arduino IDE, inspiration was found
precisely from the Processing IDE, so you can very
well understand the similarities that can exist
between the Arduino IDE and one of the most popular
graphical environments as Processing is.
So go to the site :
https://processing.org/
The page appears to you:

Click on Download Processing and the page is
accessed:

Choose the version according to your operating
system (in my case it is 64-bit Windows):
It is downloaded Processing in its latest version (in
this case, 3).
Processing is an Open Source program and is
therefore free, but if you wish you can make a
donation, which I recommend, to keep it updated
with new features.
The version I downloaded is processing-3.5.3-
windows64.zipper, unzip it and run the installer.
Click twice consecutively on the "processing" file and
the installation starts:

A message appears after installation saying that files
created with processing version 2 may not work,
continue and click Get Start. At this point the
Processing window opens. At this point you can
momentarily close it.

Project 08: Data exchange between PC and
Arduino via BT with HC-05
We continue with another data exchange project, this
time between a PC and Arduino via Bluetooth using
the HC-05 module. These are projects to learn new
things and preparatory to what we will need in
subsequent projects, so follow them you will need
them!
Basically, this project is almost identical to the
previous one, the two major differences between
these two projects, that is, between Project 07 and
Project 08, is that in the latter we will use a PC as the
interface and make a graphical APP using Processing
to interface with Arduino, for this reason, and here
the second difference, we will have to slightly modify
the sketch on Arduino to make the data sent by
Arduino itself readable by Processing.

So the purpose of the project is always to detect
humidity and temperature of a room via the DHT11
sensor module and transmit them to the PC, when
required, via BT with the HC-05.

For this project we need:
Arduino Uno
R3
Dupont
male - male
cables
USB
connection
cable
HC-05
Bluetooth
module
(with EN
button)
Bi-Directional
Level Shifter
LED
220 Ohm
resistor
DHT11
sensor
module
The assembly scheme is identical to that of the
previous project:

The sketch to upload to Arduino is:
/*
BeMaker.org - ROBOTIC ARM.
Project 08 - DATA EXCHANGE BETWEEN PC AND ARDUINO
VIA BT WITH HC-05.
*/
#include <SoftwareSerial.h> //Retrieve the SoftwareSerial
library.
#define RxPin 6 //Define PIN 6 as Rx
#define TxPin 7 //Define PIN 7 as Tx
#define LED_PIN 5 //Define the PIN to which the LED is
connected.
SoftwareSerial btSerial(RxPin,TxPin); //The Rx and Tx
definitions apply.
#define btBAUD 9600 //Define BT communication speed.
#define srBAUD 9600 //Define Serial communication speed.
#include "DHT.h" //Recall library for DHT11

#define DHT_alim 3 //Define the PIN from which I feed the
DHT11
#define DHTPIN 4 //Define the PIN to which the DHT signal
is connected.
#define DHTTYPE DHT11 // Type DHT 11
DHT dht(DHTPIN, DHTTYPE); //DHT object creation.
float h;
float t;
int state = 0;
void setup() {
  Serial.begin(srBAUD); //Apply the communication speed to
the serial port.
  delay(100);
  btSerial.begin(btBAUD); //Apply the communication speed
to the HC-05 Module.
  delay(100);
  pinMode(DHT_alim, OUTPUT); //Indicate that the power PIN
of DHT11 is in OUTPUT
  pinMode(LED_PIN, OUTPUT); //Indicate that the PIN of the
LED is in OUTPUT
  digitalWrite(DHT_alim, LOW); //Suppress the default PIN
  digitalWrite(LED_PIN, LOW); //Outputs the default PIN
  dht.begin();
  delay(100);
  Serial.println("ready...");
}
void loop() {
  if (btSerial.available()){ //Condition met when there is data
on the port of HC-05
    char inChar = btSerial.read();
    Serial.print("Incoming command from mobile device ");
    if (inChar == 'a'){ //Turn on the LED when the character
'a' arrives
      digitalWrite(LED_PIN, HIGH); //Light up the LED.

      digitalWrite(DHT_alim, HIGH); //Activating the DHT11
      Serial.println("DHT11: ON... please wait for
measurements");
      delay(3000); // Wait a few seconds between
measurements.
      h = dht.readHumidity(); // Read humidity as % (the
default)
      t = dht.readTemperature(); // Read temperature as
Celsius (the default)
      Serial.print(F("Humidity: "));
      Serial.print(h);
      Serial.print(F("% Temperature: "));
      Serial.print(t);
      Serial.println(F("°C "));
      //Predisposition data packet that are sent to the BT
      btSerial.print("ON"); //data transmitted to processing
      btSerial.print(";"); //data transmitted to processing
      btSerial.print(h); //data transmitted to processing
      btSerial.print(";"); //data transmitted to processing
      btSerial.print(t); //data transmitted to processing
      btSerial.println(";"); //data transmitted to processing
    }
    if(inChar == 's'){ //Stop the LED when the character 's'
arrives
      digitalWrite(LED_PIN, LOW); //Stop the LED
      digitalWrite(DHT_alim, LOW); //Stop the DHT11
      Serial.println("DHT11: OFF");
      //Predisposition data packet that are sent to the BT
      btSerial.print("OFF"); //data transmitted to processing
      btSerial.print(";"); //data transmitted to processing
      btSerial.print("NA"); //data transmitted to processing
      btSerial.print(";"); //data transmitted to processing
      btSerial.print("NA"); //data transmitted to processing
      btSerial.println(";"); //data transmitted to processing      
    }
  }

}
Instead, the sketch to be uploaded to Processing is:
/*
BeMaker.org - ROBOTIC ARM.
Project 08 - DATA EXCHANGE BETWEEN PC AND ARDUINO
VIA BT WITH HC-05
*/
import processing.serial.*; //Recall serial port library in
Processing
Serial myPort; //Create myPort object
String Package; //Defines the variable Package as a string of
characters it receives from Arduino
String State; //Defines the State variable as a string that will
be extracted from the string Package
String Moisture; //Defines the variable Moisture as a string
that will be extracted from the string Package
String Temperature; //Defines the variable Temperature as a
string that will be extracted from the string Package
int m; //Define the variable m as an integer that identifies
the first character of the substringa
int n; //Define the variable n as an integer that identifies the
position of the ";" as the last character of the substringa
void setup(){
size(450, 500); //Creates a window 450x500
myPort = new Serial(this, "COM9", 9600); // Serial
communication initialization (for Arduino Uno: 9600, port
depends on PC)
myPort.bufferUntil('\n'); // Defines the terminal character
of the string to be read
myPort.write('s'); //The character 's' is sent to the BT port
to make sure we start from a known condition
}
void serialEvent (Serial myPort){ // Checks whether there is
data on the serial port

Package = myPort.readStringUntil('\n'); //Looks at the
string coming from Arduino and puts it into the Package
variable
}
void draw(){
background(255, 255, 0); //Background color: Yellow
fill(0, 0, 255); //Fill color: Blue
stroke(0); //Outline color: Black
strokeWeight(5); //Thickness outline
rect(50, 100, 150, 50, 10); //Draw rectangle key ON
rect(250, 100, 150, 50, 10); //Draw rectangle key OFF
fill(255); //Text color: Binary
textSize(23); //Text Size (default font:Arial)
text("DHT11 ON",65, 135); //Place written "DHT11 ON" in
the ON rectangle
text("DHT11 OFF", 262, 135); //Place written "DHT11 OFF"
in the OFF rectangle
textSize(30); //text size
fill(33); //Text color: Dark gray almost black
text("Arduino says:", 135, 200); //Position text "Arduino
says:"
textSize(16); //text size
text("WWW.BEMAKER.ORG", 150, 450); //Position text
"WWW.BEMAKER.ORG"
textSize(25); //text size
// Data decoding process from Arduino
//In this section, the received string is parsed and the
substrings defined above are extracted: Status, Humidity,
and Temperature
if (Package.length() > 0) { //If Package has a length
greater than zero, that is, if there is character content then
we start with extraction
m = 0; //the first character of the substringa is at position
0

n = Package.indexOf(";"); //the last character of the
substringa is at the position identified by the end substringa
State = Package.substring(m, n); //The State substring
goes from position 0 to position n of the first ";"
m=n+1; //the first character of the new substringa is at
position n+1, that is, the one following the ";"
n = Package.indexOf(";", n+1); //the new location of the
second ";" is obviously searched after the first one already
previously found
Humidity = Package.substring(m, n); //The substringa
Humidity goes from the previous position n+1 to the new
position n of the second ";"
m=n+1; //the first character of the new substringa is at
position n+1, that is, the one following the second ";"
n = Package.indexOf(";", n+1); //the new position of the
third ";" is obviously searched after the second one already
previously found
Temperature 
= 
Package.substring(m, 
n);//The
Temperature substring goes from the previous position n+1
to the new position n of the third ";"
}
text("DHT11: ", 155, 240); //Arduino tells us whether
DHT11 is on or off
text(Status, 255, 240); //Position text received from
Arduino on the status of DHT11
text("Humidity % : ", 50, 300); //Arduino tells us the
humidity detected by the DHT11, when it is off it returns NA
i.e. Not Available
text(Humidity, 260, 300); // Position text received from
Arduino about the status of DHT11
text("Temperature °C : ", 50, 360); //Arduino tells us the
temperature detected by the DHT11, when it is off it returns
NA i.e. Not Available
text(Temperature, 260, 360); // Position text received from
Arduino about the status of DHT11

// When the ON button is pressed
if(mousePressed && mouseX>50 && mouseX<200 &&
mouseY>100 && mouseY<150){
myPort.write('a'); //The character 'a' is sent to the LV port
stroke(255,0,0); //The outline of the key is colored Red
strokeWeight(10); //the thickness of the outline becomes
from 10
noFill(); //NoFill (transparent)
rect(50, 100, 150, 50, 10); //rectangle of the ON button
delay(2000);
}
// When the OFF key is pressed
if(mousePressed && mouseX>250 && mouseX<400 &&
mouseY>100 && mouseY<150){
myPort.write('s'); //The character 's' is sent to the LV port
stroke(255,0,0); //The outline of the key is colored Red
strokeWeight(10); //the thickness of the outline becomes
from 10
noFill(); //NoFill (transparent)
rect(250, 100, 150, 50, 10); //rectangle of the OFF button
delay(2000);
}
}
Analysis of Project 08 sketch - Data exchange
between PC and Arduino via BT with HC-05
For both sketches, for both the one to be uploaded to
Arduino and Processing, each line of code is
commented so I encourage you to read the various
comments, however in summary: Arduino reads the
values measured by the DHT11 and creates a string
of data separated by ";" and sent to the serial port

where the BT is connected. Processing receives that
string and decomposes it into substrings and then
uses its individual parts to print the received data.
I just want to point out two important things to you,
otherwise you risk that the project will not work for
you:
1)    The communication speed for Arduino Uno on the
BT serial port is good to set it to 9600 baud
2)    In the line:
myPort = new Serial(this, "COM9", 9600);
you need to enter the communication COM
port with which your PC connects with the BT HC-05
Module. To find out which port to transcribe in the
Processing code, first proceed to pair the PC to the
Module via BT, go to settings and choose other BT
devices and Add BT device:
The result will be that the HC-05 module will be
added among the associated devices. Still in the

same section scroll down and click on More BT
Options:
The window below appears, click on COM Ports:

And the window below appears with the directions we
need:

As you can observe in my case the communication
port is COM 9.
[For the video related to the project click here].
[For the sketch for the project to be uploaded to
Arduino click here].
[For the sketch related to the project for Processing
click here].

LESSON 5 - Controlling a Robot Arm
via BT with PC and Arduino UNO
After Lesson 4 which was devoted to insights and
projects on the use of the HC-05 Module, with this
Lesson we resume our projects for the control and
command of a Robot Arm. I would like to point out
that the experiences seen will be applied in part in
future projects and in any case will be very useful for
your future projects.
Before moving on to the actual lesson, I wanted to
make you aware of some modifications I made to my
Robot Arm that became necessary as I saw that the
performance of the arm was not what I had hoped
for, in fact since the assembly phase of the arm I had
noticed 
that 
there 
were 
undersized 
elements,
particularly the servomotors that produced the
motion indicated by S2 and S3.
Our Robot Arm can be represented as follows:
-         S1 - BASIC ROTATION

-         S2 - ARM ROTATION
-         S3 - ROTATION 1 FOREARM
-         S4 - ROTATION 2 FOREARM
-         S5 - ROTATION 1 WRIST
-         S6 - ROTATION 2 WRIST
- 
 
 
 
 
 
 
 
  S7 - OPENING/CLOSING CLAMP (NOT
REPRESENTED GRAPHICALLY)
Because of what was said earlier, referring to Lesson
2 on Assembly, I modified the two servo motors S2
and S3, replacing them and thus changing from two
MG 906Rs to two TD 8120MGs, which are able to
develop much higher torque and thus more suitable
for the type of Robot Arm used.
Below are the characteristics of the two servos
compared:
 
As you can see, I replaced a servo with a torque of
about 10 kg∙cm , with one that has practically twice
as much.
Returning to our lesson, then, we have that to move
a robot arm like the one I purchased at 7DOF, we
need, considering also the servo used to move the
grippers, a total of 7 servo motors, this is not a large
number for Arduino, as we have 14 digital PINs that

we can use. In fact, the following project shows you
how, with the appropriate libraries, we can manage
the 7 servo motors directly from Arduino.

Project 09: Control and Command Robot Arm
via LV with PC and HC-05.
Processing will also be used for this project to create
a fantastic graphical user interface that graphically
reports in 3D on the monitor the movements
commanded to Arduino to drive our robotic arm.
Obviously, like any of my projects, it is to be
considered only as a starting point for your
developments and improvements as well.
Arduino Uno
R3
Dupont M -
M and M - F
Cables
USB
connection
cable
HC-05
Bluetooth
Module

Bi-Directional
Level Shifter
7DOF
Robot Arm
LED + 220
Ohm
resistor
No. 
2
base
plates
400 holes
For this project we need:
We are going to implement what is represented by
the assembly diagrams below, as you can well
observe they are basically two separate systems, I
will represent them separately also to improve the
reading, 
one 
dealing 
with 
the 
Bluetooth
communication and the other with the command and
control of the robot arm, the two circuits are mounted
on the two separate bases and then both will
interface with Arduino. Powering the 7 servo motors
is done through a stabilized power supply with 5V
voltage.
Let us look at the schematic to be made for the
Bluetooth communication part with the HC-05. As you
can see, it is essentially identical to what was done
for Project 5

As for the schematic to be made to control the arm
servomotors, you can refer to the diagram below. As
you can see, since I handle all connections with a
400-hole board, to receive confirmation that the
board is powered, I inserted an LED (with its own
protection 
resistor) 
between 
the 
positive 
and
negative of the board itself.

When assembling the circuits, pay attention to the
colors of the servo wires (brown = GND, red = Vcc,
and orange = Signal), and also since you will surely
need extension cords, make sure that at the junction
points you do not have cable detachments by putting
paper tape on them.
Note: In order for the two circuits to have the same
ground reference, the two negatives of the headers
must be connected. Care should be taken: if you do
not have a good power supply, such a connection
may cause the PC to go into protection, so in this
case you need to keep them separate (for the PC,
just unplug it from the mains for 10-15 sec and plug
it back in). 
The sketch to be uploaded to Arduino is as follows:
/*
BeMaker.org - ROBOTIC ARM.

Project 09 - CONTROL OF A ROBOT ARM WITH PC VIA BT
WITH HC-05 AND ARDUINO.
https://bemaker.org/
*/
#include <SoftwareSerial.h> //Retrieve the SoftwareSerial
library.
#define RxPin 6 //Define PIN 6 as Rx
#define TxPin 7 //Define PIN 7 as Tx
#include <Servo.h> //Recalls the Motor Control Library.
#define PIN_SERVO1 3 //Control servo 1 Base to PIN 3
#define PIN_SERVO2 4 //Control servo 2 Arm at PIN 4
#define PIN_SERVO3 8 //Control servo 3 Forward to PIN 8
#define PIN_SERVO4 9 //Servo control 4 Forearm rotation at
PIN 9
#define PIN_SERVO5 10 //Servo control 5 Rotation. Pulse to
PIN 10
#define PIN_SERVO6 11 //Servo control 6 Rotaz. Clamp to
PIN 11
#define PIN_SERVO7 12 //Control Servo 7 Closing Clamp at
PIN 12
SoftwareSerial btSerial(RxPin,TxPin); //The Rx and Tx
definitions apply.
#define btBAUD 9600 //Define BT communication speed.
#define srBAUD 9600 //Define Serial communication speed.
//Variables and functions
Servo ServoMotor1; //Creates an object named ServoMotor1
Servo ServoMotor2; //Creates an object named ServoMotor2
Servo ServoMotor3; //Creates an object named ServoMotor3
Servo ServoMotor4; //Creates an object named ServoMotor4
Servo ServoMotor5; //Creates an object called ServoMotor5
Servo ServoMotor6; //Creates an object named ServoMotor6
Servo ServoMotor7; //Creates an object named ServoMotor7
int Rotation;

String NewRotation;
char PrimoCar;
int Rot;
void setup() {
  ServoMotor1.attach(PIN_SERVO1); //Say that ServoMotor1
is attached to PIN 3
  ServoMotor2.attach(PIN_SERVO2); //Say that ServoMotor2
is attached to PIN 4
  ServoMotor3.attach(PIN_SERVO3); //Say that ServoMotor3
is attached to PIN 8
  ServoMotor4.attach(PIN_SERVO4); //Say that ServoMotor3
is attached to PIN 9
  ServoMotor5.attach(PIN_SERVO5); //Say that ServoMotor3
is attached to PIN 10
  ServoMotor6.attach(PIN_SERVO6); //Say that ServoMotor3
is attached to PIN 11
  ServoMotor7.attach(PIN_SERVO7); //Say that ServoMotor3
is attached to PIN 12
  Rotation=90;
  Serial.begin(srBAUD); //Apply the communication speed to
the serial port.
  delay(100);
  btSerial.begin(btBAUD); //Apply the communication speed
to the HC-05 Module.
  delay(100);
  Serial.println("ready...");
}
void loop() {
     while(btSerial.available()) //Condition true when there is
data on the port of HC-05
   {
      String inString = btSerial.readStringUntil('\n');
      char PrimoCar = inString.charAt(0);
      NewRotation=inString.substring(1);

      int Rotation = NewRotation.toInt();
      Serial.print(inString); Serial.print(" ");
Serial.print(FirstCar); Serial.print(" ");
Serial.println(Rotation);
      switch (PrimoCar) {
      case ('A'):
            ServoMotor1.write(Rotation);
      break;
      case ('B'):
            ServoMotor2.write(Rotation);
      break;
      case ('C'):
            ServoMotor3.write(Rotation);
      break;
      case ('D'):
            ServoMotor4.write(Rotation);
      break;
      case ('E'):
            ServoMotor5.write(Rotation);
      break;
      case ('F'):
            ServoMotor6.write(Rotation);
      break;
      case ('G'):
            ServoMotor7.write(Rotation);
      break;
      case ('P'):
            btSerial.println("Arduino says: I'm ready!...");
            Serial.println("Arduino says: I'm ready!...");
      break;
      }
   }
   delay(100);
}

The sketch to be opened in Processing on the PC is as
follows:
/*
BeMaker.org - ROBOTIC ARM.
Project 09 - ARM CONTROL VIA BT WITH PC AND ARDUINE
WITH HC-05
*/
import processing.serial.*; //Import the library for serial
communications
Serial myPort; //Define the myPort object.
String State; //Defines the State variable as a string that will
give indications on Arduino
int vel=2; //Multiplicative factor angles of rotation
float rotationS1; //Define the rotation variable of S1
float rotationS2; //Define the rotation variable of S2
float rotationS3; //Define the rotation variable of S3
float rotationS4; //Define the rotation variable of S4
float rotationS5; //Define the rotation variable of S5
float rotationS6; //Define the rotation variable of S6
float rotationS7; //Define the rotation variable of S7
void setup() {
String portName = "COM10"; //Associate the COM port
actually used for communication - see Lesson 4 of the
Course for how to do it
myPort = new Serial(this, portName, 9600); //Creating and
Setting the Port
myPort.bufferUntil('\n'); // Defines the terminal character
of the string to be read
size( 1500, 800, P3D ); //Create a 3D window x=1500,
y=800 z= undefined
ambientLight(0,0,255); //Add a diffuse white ambient light
pointLight(255, 0, 0, width/2, height/2, 400); //Add a white
light fixture to the middle length of the window to give the

shadows for depth
noStroke(); //Not defining the contours of the solids I am
going to draw
rotationS1=PI/2; //Servo S1 BASE at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180  
rotationS2=PI/2; //Servo S2 Arm at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180
rotationS3=PI/2; //Servo S3 AvanBracket at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
rotationS4=PI/2; //Servo S4 AvanBracket rotation at rest is
at 90° so it rotates from 0 to 90 and from 90 to 180
rotationS5=PI/2; //Servo S5 Rotation Wrist at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
rotationS6=PI/2; //Servo S6 Rotation Pliers at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
rotationS7=PI/2; //Servo S7 gripper grip at rest is at 90° so
it rotates from 0 to 90 and from 90 to 180
myPort.write(("Pp")+'\n'); //The string 'Pp' is sent to the LV
port to make sure we start from a known condition
delay(100);
}
void serialEvent (Serial myPort){ // Checks whether there is
data on the serial port
Status = myPort.readStringUntil('\n'); //Looks at the string
coming from Arduino and puts it in the Package variable
}
void draw() {
background(0);
lights();
//Position text by site
fill(255); //Select the color White    
textSize(18); //text size

text("WWW.BEMAKER.ORG", 
50, 
780); 
//Position 
text
"WWW.BEMAKER.ORG"
text(State, 500, 780); //Position text State
//Position the text for the command key legend.
textSize(30); //text size
text("LEGEND," 1200, 50); //Position text "LEGEND"
text("a = S1 <-", 1100, 100); //Position text "S1 <-"
text("s = S1 ->", 1330, 100); //Position text "S1 <-"
text("e = S2 ^", 1100, 200); //Position text "e = S2 ^"
text("d = S2 v", 1330, 200); //Position text "d = S2 v"
text("r = S3 ^", 1100, 300); //Position text "e = S3 ^"
text("f = S3 v", 1330, 300); //Position text "d = S3 v"
text("t = S4 <-", 1100, 400); //Position text "e = S4 ^"
text("g = S4 ->", 1330, 400); //Position text "d = S4 v"
text("y = S5 ^", 1100, 500); //Position text "e = S5 ^"
text("h = S5 v", 1330, 500); //Position text "d = S5 v"
text("u = S6 <-", 1100, 600); //Position text "e = S6 <-"
text("j = S6 ->", 1330, 600); //Position text "d = S6 ->"
text("k = S7 <->", 1100, 700); //Position text "d = S7 <->"
text("l = S7 >-<", 1330, 700); //Position text "d = S7 >-<"
// Drawing the Robot Arm in 3D
//Draw the base
translate(300,700,0); //Move the drawing reference to the
right (x) by 200, down (y) by 600, and z=0
rotateY(rotationS1); //Rotate along the y-axis
fill(0,127,255); //Select the color blue
box(60); //Draw to the new coordinates a cube of side 60
//Design the arm rotation joint.
translate( 0,-60,0 ); //Move the reference only upward
along the y
fill(255,0,0); //Select the color Red
rotateX( rotateS2 ); //Rotate along the X axis
sphere(30); //Draw a sphere
//Draw the arm

translate( 0,0,140 ); //Move the reference only upward
along z
fill(255,255,0); //Select the color Yellow
box( 60, 60, 220 ); //Draw a parallelepiped 60x60x220
//Design the forearm pivot joint.
translate( 0,0,140 ); //Move the reference only upward
along z
fill(255,0,0); //Select the color Red
rotateX( rotateS3 ); //Rotate along the X axis
rotateZ( rotateS4 ); //Rotate along the z axis
sphere(30); //Draw a sphere
//Drawing the forearm.
translate( 0,0,-110 ); //Move the reference only upward
along z
fill(255,255,0); //Select the color Yellow
box( 60, 60, 150 ); //Draw a parallelepiped 60x60x220
//Drawing the wrist rotation joint.
translate( 0,0,-110 ); //Move the reference only upward
along z
fill(255,0,0); //Select the color Red
rotateY( rotationS5 ); //Rotate along the y axis
rotateZ( rotationS6 ); //Rotate along the z axis
sphere(30); //Draw a sphere
//Draw the lower clamp
translate( 0,-75,0 ); //Move the reference only upward
along the z
fill(70,70,70); //Select the color Red
box( 20, 130, 20 ); //Draw a parallelepiped
//Drawing the rotation joint of the upper gripper
translate( 0,40,0 ); //Move the reference only upward along
z
fill(255,0,0); //Select the color Red
rotateX( rotationS7 ); //Rotate along the x-axis
sphere(10); //Draw a sphere
//Draw the upper clamp

translate( 0,50,0 ); //Move the reference only upward along
z
fill(70,70,70); //Select the color Red
rotateX( -PI/2 ); //Rotate along the X axis.
box( 20, 20, 80 ); //Draw a parallelepiped
translate( 0,-40,40 ); //Move the reference only upward
along the z
fill(70,70,70); //Select the color Red
rotateX( PI/2 ); //Rotate along the X axis.
box( 20, 20, 80 ); //Draw a parallelepiped
}
void keyPressed() {
if (key == 's') {
rotationS1=rotationS1+(vel*PI/180);
float grad_rot_1= map(rotationS1, 0, PI, 0, 180);
String a1="A";
int a2 = parseInt(grad_rot_1);
String textA = a1+a2;
myPort.write((textA)+'\n');
print("Rotation Servo 1 = "); print(rotationS1); print(" ");
print(grad_rot_1); print(" "); println(textA); //debug
}
else if (key == 'a') {
rotationS1=rotationS1-(vel*PI/180);
float grad_rot_1= map(rotationS1, 0, PI, 0, 180);
String a1="A";
int a2 = parseInt(grad_rot_1);
String textA = a1+a2;
myPort.write((textA)+'\n');
print("Rotation Servo 1 = "); print(rotationS1); print(" ");
print(grad_rot_1); print(" "); println(textA); //debug
}
if (key == 'e') {
rotationS2=rotationS2+(vel*PI/180);
float grad_rot_2= map(rotationS2, 0, PI, 0, 180);

String b1="B";
int b2 = parseInt(grad_rot_2);
String textB = b1+b2;
myPort.write((textB)+'\n');
print("Rotation Servo 2 = "); print(rotationS2); print(" ");
print(grad_rot_2); print(" "); println(textB); //debug
}
else if (key == 'd') {
rotationS2=rotationS2-(vel*PI/180);
float grad_rot_2= map(rotationS2, 0, PI, 0, 180);
String b1="B";
int b2 = parseInt(grad_rot_2);
String textB = b1+b2;
myPort.write((textB)+'\n');
print("Rotation Servo 2 = "); print(rotationS2); print(" ");
print(grad_rot_2); print(" "); println(textB); //debug
}
if (key == 'r') {
rotationS3=rotationS3+(vel*PI/180);
float grad_rot_3= map(rotationS3, 0, PI, 0, 180);
String c1="C";
int c2 = parseInt(grad_rot_3);
String textC = c1+c2;
myPort.write((textC)+'\n');
print("Rotation Servo 3 = "); print(rotationS3); print(" ");
print(grad_rot_3); print(" "); println(textC); //debug
}
else if (key == 'f') {
rotationS3=rotationS3-(vel*PI/180);
float grad_rot_3= map(rotationS3, 0, PI, 0, 180);
String c1="C";
int c2 = parseInt(grad_rot_3);
String textC = c1+c2;
myPort.write((textC)+'\n');

print("Rotation Servo 3 = "); print(rotationS3); print(" ");
print(grad_rot_3); print(" "); println(textC); //debug
}
if (key == 'g') {
rotationS4=rotationS4+(vel*PI/180);
float grad_rot_4= map(rotationS4, 0, PI, 0, 180);
String d1="D";
int d2 = parseInt(grad_rot_4);
String textD = d1+d2;
myPort.write((textD)+'\n');
print("Rotation Servo 4 = "); print(rotationS4); print(" ");
print(grad_rot_4); print(" "); println(textD); //debug
}
else if (key == 't') {
rotationS4=rotationS4-(vel*PI/180);
float grad_rot_4= map(rotationS4, 0, PI, 0, 180);
String d1="D";
int d2 = parseInt(grad_rot_4);
String textD = d1+d2;
myPort.write((textD)+'\n');
print("Rotation Servo 4 = "); print(rotationS4); print(" ");
print(grad_rot_4); print(" "); println(textD); //debug
}
if (key == 'h') {
rotationS5=rotationS5+(vel*PI/180);
float grad_rot_5= map(rotationS5, 0, PI, 0, 180);
String e1="E";
int e2 = parseInt(grad_rot_5);
String textE = e1+e2;
myPort.write((textE)+'\n');
print("Servo rotation 5 = "); print(rotationS5); print(" ");
print(grad_rot_5); print(" "); println(textE); //debug
}
else if (key == 'y') {
rotationS5=rotationS5-(vel*PI/180);

float grad_rot_5= map(rotationS5, 0, PI, 0, 180);
String e1="E";
int e2 = parseInt(grad_rot_5);
String textE = e1+e2;
myPort.write((textE)+'\n');
print("Servo rotation 5 = "); print(rotationS5); print(" ");
print(grad_rot_5); print(" "); println(textE); //debug
}
if (key == 'u') {
rotationS6=rotationS6+(vel*PI/180);
float grad_rot_6= map(rotationS6, 0, PI, 0, 180);
String f1="F";
int f2 = parseInt(grad_rot_6);
String textF = f1+f2;
myPort.write((textF)+'\n');
print("Servo rotation 6 = "); print(rotationS6); print(" ");
print(grad_rot_6); print(" "); println(textF); //debug
}
else if (key == 'j') {
rotationS6=rotationS6-(vel*PI/180);
float grad_rot_6= map(rotationS6, 0, PI, 0, 180);
String f1="F";
int f2 = parseInt(grad_rot_6);
String textF = f1+f2;
myPort.write((textF)+'\n');
print("Servo rotation 6 = "); print(rotationS6); print(" ");
print(grad_rot_6); print(" "); println(textF); //debug
}
if (key == 'k') {
rotationS7=rotationS7+(vel*PI/180);
float grad_rot_7= map(rotationS7, 0, PI, 0, 180);
String g1="G";
int g2 = parseInt(grad_rot_7);
String textG = g1+g2;
myPort.write((textG)+'\n');

print("Servo rotation 7 = "); print(rotationS7); print(" ");
print(grad_rot_7); print(" "); println(textG); //debug
}
else if (key == 'l') {
rotationS7=rotationS7-(vel*PI/180);
float grad_rot_7= map(rotationS7, 0, PI, 0, 180);
String g1="G";
int g2 = parseInt(grad_rot_7);
String textG = g1+g2;
myPort.write((textG)+'\n');
print("Servo rotation 7 = "); print(rotationS7); print(" ");
print(grad_rot_7); print(" "); println(textG); //debug
}
}
Analysis of Project 09 sketches - Control and
Command Robot Arm via LV.
The sketches do not present any particular difficulties
worthy of note, only the one for Processing required
me a lot of patience in the construction of the 3D
graphical representation of the arm and in particular
in the use of the " translate( x,y,z ); " that is, the
instruction that allows the shifting of the Cartesian
axis references useful later in the realization of the
complex figures.
[For the video related to the project click here].
[For the sketch for the project to be uploaded to
Arduino click here].
[For the sketch related to the project for Processing
click here].

Controlling a Robot Arm with PCA9685
Controller and Arduino UNO
An alternative method for controlling the servo
motors of the Robot Arm is using a specific board
made by NXP Semiconductors whose trade name is
PCA9685, so we return to wired, or also called wired,
control. This board was created to drive LEDs with
PWM signals, but it can be used safely for servos as
well.
On major marketplaces the PCA9685 board can be
found already assembled and is similar to this one in
the photo:
It is possible to form "chains" of control boards
connected in series to increase the number of
available PWM PINs, all of which are managed via
I2C.To do this, the address of the board needs to be
changed, and to change it, small soldering needs to
be done at the top right where it says "I2C Address,"
specifically:

(In the diagrams above some examples of I2C
address modification)
Description of Servomotor Control Board
PCA9865
The single PCA9685 board is capable of controlling,
independently, up to 16 output channels, and the
signal type is PWM, with a resolution of 12 bits (i.e.,
4096 levels, as opposed to Arduino's 256) and is
applicable, as we mentioned, for controlling both
robot servomotors and LEDs.
The communication protocol is I2C and can be used
not 
only 
with 
Arduino 
but 
also 
with 
other
microcontrollers that have such an interface.
The main features are:
➢       3 V to 5.5 V power supply

➢             I2C bus (default address 0x40 modifiable with
appropriate jumpers)
➢       16 channels of 12-bit output (4096 values)
➢       PWM frequency programmable from 24Hz up to
1526 Hz
➢       each output channel delivers max 25mA at 5V
➢       duty cycle 0% - 100%
➢       All outputs work at the same set frequency.
Let us analyze the individual PINs.
Power PIN:
GND - ground, or earth and are all connected to each
other.
VCC - Power PIN directly connected to PCA9685
(power supply can range from 3 to 5 VDC) .
V+ - these pins are all in common. V+ is optional and
is used only to supply power to any connected
servomotors (usually a voltage of 5/6 VDC is used,
but up to 12 VDC can be used).
Control PIN:

SCL - I2C clock; can be used with 3V or 5V logic and
already has a 10k pullup resistor connected to VCC.
SDA - I2C data; and has the same characteristics as
the SCL pin.
OE - Output Enable; can be used to disable all
outputs. If put high it disables them, if put low it
enables them. Normally it is put low with a resistor.
This pin is optional and you can also not use it.
Output ports:
There are 16 output ports available. Each port has 3
PINs: V +, GND and the PWM output. Each PWM
works completely independently, but they must all
have the same frequency. So, for example, since a
1.0 KHz frequency is usually used for LEDs, but a 60
Hz frequency is usually used for servomotors, you
cannot use some output ports for LEDs at 1.0 KHz
and others at 60 Hz for servomotors.
The maximum current per PWM PIN that can be
delivered is 25 mA-more than enough for the signal
to the servomotor. Already 220 ohm resistors are
connected in series with the outputs if you wish to
use the board to control LEDs.
There are also different Shields for Arduino, again
with the PCA9685, below are two examples:

Let us now see how to connect the PCA9685 board to
Arduino. The connection is very simple, let's look at
the PIN out of Arduino (figure below)
and we note that PINs D18 and D19 are the SDA and
SCL respectively for I2C communications, some
people use to connect the SDA and SCL respectively
on the analog PINs and in particular on A4 and A5, as
they are replicas of PINs D18 and D19, but I am a

traditionalist, so I will connect them to the classic
PINs D18 and D10.
As for the GND and Vcc of the board, however, they
should be connected to the GND of the Arduino and
the 5V of the Arduino itself, respectively.
To connect in "chain" or even in said in "series"
multiple PCA9685 boards, we need to report the
terminal connections as shown in the figure below.
The single servo power supply will have to be
external (the figure shows only two boards, but
obviously it should be replicated in case we need to
connect more boards):
Project 10: Use of the PCA9685 Board in
Servomotor Control.

This first project, with the use of the PCA9685 board,
we devote it to getting to know the board and doing
some practice with the coding part, in fact the use of
the board requires the "Adafruit PWM Servo Drive
library" which you can install through the "Library
Manager" and once the library is installed, you can
load the example sketch from the path:
"File" -> "Examples" -> "Adafruit PWM Servo Driver
Library" -> "servo"
analyzing the example file you will realize that it is
possible to manage the board in every component,
obviously we will stop at a higher level, leaving to
each of you the curiosity to experiment and deepen
the topic. The project, however, will put us in a
position to know enough about the coding part to
make the best use of the PCA9685.

Arduino Uno R3
Dupont
female to
male cables
USB
connection
cable
PCA9685
16-
channel
PWM
servo
controller
board
No. 2 or more
SG90 servos
For this project we need:
The scheme to be carried out is as follows:

In my case I have only two SG90 servos, so I
connected the two servos on ports 0 and 1, if you
have more than two connect them in numerical
order.
The sketch to be uploaded to Arduino is as follows:
/*
BeMaker.org - COURSE ON THE ROBOTIC ARM.
Project 10 - TESTING THE PCA9685 CARD WITH ARDUIN.
https://bemaker.org/
*/
#include <Wire.h> //Loads the Wire library for I2C
comuication.
#include <Adafruit_PWMServoDriver.h> //Loads Adafruit's
servo control library with PCA9685
// The default address of PCA9685 is 0x40

Adafruit_PWMServoDriver myservo =
Adafruit_PWMServoDriver(); //This method directs
commands to the default board, 0x40
//Adafruit_PWMServoDriver myservo =
Adafruit_PWMServoDriver(0x41); // with this method you
direct commands to the specific board, 0x41
// In this section we set the parameters dependent on the
servos we use. Be careful you can damage the servos.
#define SERVOMIN 150 //SG90 // The default Adafruit value
is 150 and represents the minimum pulse duration that
corresponds 0° (the value can vary from 0 to 4095)
#define SERVOMAX 650 //SG90 // The default Adafruit value
is 600 and represents the duration of the maximum pulse
that corresponds 180° (the value can vary from 0 to 4095)
#define SERVO_FREQ 60 //Value of the default frequency set
by Adafruit is 50. For SG90s, 60 Hz is used.
int servonum = 0; //we define the servonum variable as
integer and assign it the value 0
int numeroservo = 2; //define a variable indicating how
many servos are connected to the PCA9685 board
int rotation = 0; //I'll define a variable where I'll enter the
pulse length that tells me the rotation
void setup() {
  Serial.begin(9600); //Initialize the serial port of the IDE.
  Serial.println("SERVO TEST WITH PCA9685"); //Let's write
the sentence indicated between ""
  delay(50); //Introduce a delay to settle the initialization
  myservo.begin(); //Initialize the myservo object.
  //myservo.setOscillatorFrequency(27000000); //We set the
frequency of the oscillator present on the PCA9685 board. It
can also be omitted by default it goes to the maximum
value.
  myservo.setPWMFreq(SERVO_FREQ); // Let's set the analog
frequency for servomotors

  delay(50); //Introduce a delay to settle the initialization
  Serial.println("Card PCA9685 ready ..."); //Let's write the
sentence indicated between ""
}
void loop() {
  // We drive the servo with the function setPWM(n_servo,
on, off) where n_servo is the servo or output number, on
and off the pulse start and pulse end instants
  for (rotation = SERVOMIN; rotation < SERVOMAX;
rotation++) { //With the for loop I send the various servo
rotation angles
    myservo.setPWM(servonum, 0, rotation); //servonum is
the servo number, 0 is the pulse start time and rotation is
the pulse end value
    int degrees = map(rotation,SERVOMIN,SERVOMAX,0,180);
//map the pulse length value in degrees of rotation 
    Serial.print("Servo driven no. "); Serial.print(servonum);
    Serial.print(" Rotation ° :"); Serial.println(degrees);
  }
  delay(10);
  for (rotation = SERVOMAX; rotation > SERVOMIN; rotation-
-) { //With the for loop I send the various angles of rotation
of the servos
    myservo.setPWM(servonum, 0, rotation); //servonum is
the servo number, 0 is the pulse start time and rotation is
the pulse end value
    int degrees = map(rotation,SERVOMIN,SERVOMAX,0,180);
//map the pulse length value in degrees of rotation 
    Serial.print(" Rotation ° :"); Serial.println(degrees);
  }
  delay(10);
  servonum++;
  if (servonum > numeroservo-1) servonum = 0; // Perform
test on only one connected servo at a time
}

Analysis of the Project 10 sketch - Testing of
the PCA9685 board
Each line of the sketch is commented, so you will find
no difficulty in understanding what the individual
instructions do; however, I just want to point out two
things:
1)       The SERVOMIN and SERVOMAX parameters depend
on the servos used for your project, personally I
ran the project with SG90s of Chinese origin and
the values used in the sketch worked, perhaps in
your case you will have to change them in both
the minimum and maximum value to make the
servo 
make 
the 
correct 
expected 
rotation,
remember that these are values ranging from 0
to 4095.
2)       The variable numeroservo needs to be assigned
the total number of servos that have been
connected to the PCA9685 board, this is so that
all the ports involved are activated cyclically.
[For the video related to the project click here].
[For the sketch related to the project click here].

Project 11: Robot arm controlled by PCA9685
board
After getting acquainted with the PCA0685 board with
the previous project, let us move on to the control of
our Robot Arm. For this project we will use a
previously 
used 
GUI, 
obviously 
modifying 
it
appropriately. The GUI will be with Processing, a
development environment that is very similar to the
Arduino IDE, in fact we can say that they are the
same family since the Arduino IDE stems from the
Processing IDE.
You will realize the ease of use of the PCA9685 as
soon as you complete the circuit assembly and view
the sketch for Arduino, the same cannot be said for
the sketch on Processing for the 3D graphical user
interface, which instead took me several hours of
work also to fix some bugs present in the previous
version, now all fixed.

For this project we need:
Arduino Uno R3
Dupont
Cables F - M
USB
connection
cable
PCA9685
16-
channel
PWM
servo
controller
board
7DOF Robot
Arm

The scheme to be carried out is as follows:
The 5V battery (which uses the same graphics as a
9V battery) indicates that the board requires an
external 5V power supply. In fact, as mentioned
several times, including in previous Lessons, Arduino
cannot power all the servomotors used by the Robot
Arm so an external power supply is required.
The sketch to be uploaded to Arduino is as follows:
/*
BeMaker.org - COURSE ON THE ROBOTIC ARM.
Project 11 - ROBOT ARM CONTROLLED BY PCA9685 AND
ARDUINO
https://bemaker.org/
*/
#include <Wire.h> //Loads the Wire library for I2C
comuication.

#include <Adafruit_PWMServoDriver.h> //Loads Adafruit's
servo control library with PCA9685
// The default address of PCA9685 is 0x40
Adafruit_PWMServoDriver myservo =
Adafruit_PWMServoDriver(); //This method directs
commands to the default board, 0x40
// In this section we set the parameters dependent on the
servos we use. Be careful you can damage the servos.
#define SERVOMIN 150 //SG90 // The default Adafruit value
is 150 and represents the minimum pulse duration that
corresponds 0° (the value can vary from 0 to 4095)
#define SERVOMAX 650 //SG90 // The default Adafruit value
is 600 and represents the duration of the maximum pulse
that corresponds 180° (the value can vary from 0 to 4095)
#define SERVO_FREQ 60 //Value of the default frequency set
by Adafruit is 50. For SG90s, 60 Hz is used.
int Rotation = 0; //I'll define a variable where I'll enter the
pulse length that tells me the rotation
String NewRotation; //variable for capturing the string
char PrimoCar; //variable for string capture
int ServoMotor1=0; //Creates a variable called ServoMotor1
int ServoMotor2=1; //Creates a variable called ServoMotor2
int ServoMotor3=2; //Creates a variable called ServoMotor3
int ServoMotor4=3; //Creates a variable called ServoMotor4
int ServoMotor5=4; //Creates a variable called ServoMotor5
int ServoMotor6=5; //Creates a variable called ServoMotor6
int ServoMotor7=6; //Creates a variable called ServoMotor7
void setup() {
  Serial.begin(9600); //Initialize the serial port of the IDE.
  delay(50); //Introducing a delay to settle the initialization
  myservo.begin(); //Initialize the myservo object.
  myservo.setPWMFreq(SERVO_FREQ); // Let's set the analog
frequency for servomotors

  delay(50); //Introducing a delay to settle the initialization
}
void loop() {
     if(Serial.available()>0) //Condition true when there is
data on the SERIAL port
      {
        String inString = Serial.readStringUntil('\n');
        char PrimoCar = inString.charAt(0);
        NewRotation=inString.substring(1);
        Rotation = NewRotation.toInt();
        Rotation = map(Rotation,0, 180,
SERVOMIN,SERVOMAX); //map the pulse length value in
degrees of rotation 
        switch (PrimoCar) {
        case ('A'):
          myservo.setPWM(ServoMotor1, 0, Rotation); //Pilot the
first servo according to the angles arriving on the serial port
        break;
        case ('B'):
          myservo.setPWM(ServoMotor2, 0, Rotation); //Pilot the
second servo according to the angles arriving on the serial
port
        break;
        case ('C'):
          myservo.setPWM(ServoMotor3, 0, Rotation); //Pilot the
third servo according to the angles arriving on the serial
port
        break;
        case ('D'):
          myservo.setPWM(ServoMotor4, 0, Rotation); //Pilot the
fourth servo according to the angles arriving on the serial
port
        break;
        case ('E'):

          myservo.setPWM(ServoMotor5, 0, Rotation); //Pilot the
fifth servo according to the angles arriving on the serial port
        break;
        case ('F'):
          myservo.setPWM(ServoMotor6, 0, Rotation); //Pilot the
sixth servo according to the angles arriving on the serial
port
        break;
        case ('G'):
          myservo.setPWM(ServoMotor7, 0, Rotation); //Pilot the
seventh servo according to the angles arriving on the serial
port
        break;
        //debug
        case ('P'):
          Serial.print("Arduino says: I'm ready!...");
        break;
        }
      }
    delay(10);  
}
As for the sketch for Processing:
/*
BeMaker.org - ROBOTIC ARM.
Project 11 - ROBOT ARM CONTROLLED BY PCA9685 AND
ARDUINO
*/
import processing.serial.*; //Import the library for serial
communications
Serial myPort; //Define the myPort object.
String State = ""; //Defines the State variable as a string
that will give indications on Arduino
float vel=0.5; //Multiplicative factor angles of rotation
float rotationS1 = 0.0; //Define the rotation variable of S1

float rotationS2 = 0.0; //Define the rotation variable of S2
float rotationS3 = 0.0; //Define the rotation variable of S3
float rotationS4 = 0.0; //Define the rotation variable of S4
float rotationS5 = 0.0; //Define the rotation variable of S5
float rotationS6 = 0.0; //Define the rotation variable of S6
float rotationS7 = 0.0; //Define the rotation variable of S7
int 
grad_rot_1 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees
int 
grad_rot_2 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees
int 
grad_rot_3 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees
int 
grad_rot_4 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees
int 
grad_rot_5 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees
int 
grad_rot_6 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees
int 
grad_rot_7 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees
String textA = ""; //Define a string variable.
String textB = ""; //Define a string variable.
String textC = ""; //Define a string variable.
String textD = ""; //Define a string variable.
String textE = ""; //Define a string variable.
String textF = ""; //Define a string variable.
String textG = ""; //Define a string variable.
void setup() {
String portName = "COM8"; //Associate the COM port
actually used for communication - see Lesson 4 of the
Course for how to do it
myPort = new Serial(this, portName, 9600); //Creating and
Setting the Port

myPort.bufferUntil('\n'); // Defines the terminal character
of the string to be read
size( 1600, 900, P3D ); //Create a 3D window x=1500,
y=800 z= undefined
ambientLight(0,0,255); //Add a diffuse white ambient light
pointLight(255, 0, 0, width/2, height/2, 400); //Add a white
light fixture to the middle length of the window to give the
shadows for depth
noStroke(); //Not defining the contours of the solids I am
going to draw
rotationS1=PI/2; //Servo S1 BASE at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180  
rotationS2=PI/2; //Servo S2 Arm at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180
rotationS3=PI/2; //Servo S3 AvanBracket at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
rotationS4=PI/2; //Servo S4 AvanBracket rotation at rest is
at 90° so it rotates from 0 to 90 and from 90 to 180
rotationS5=PI/2; //Servo S5 Rotation Wrist at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
rotationS6=PI/2; //Servo S6 Rotation Pliers at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
rotationS7=PI/2; //Servo S7 gripper grip at rest is at 90° so
it rotates from 0 to 90 and from 90 to 180
myPort.write(("Pp")+'\n'); //The string 'Pp' is sent to the LV
port to make sure we start from a known condition
delay(100);
}
void draw() {
background(0);
lights();
if (myPort.available() > 0) {
State = myPort.readStringUntil('\n'); //Looks at the string
coming from Arduino and puts it into the state variable

if (State != null) { //debug
text(State, 400, 880); //Position text State
print(State);
}
}
DrawLegenda();
//CONTROLS WHEN THE LEFT MOUSE BUTTON IS PRESSED
ON A GIVEN RECTANGLE
//1090,70,180,50 - Xgra: rad = 180 : pi
if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 && mouseY>70 && mouseY<70+50){
IlluminaTasto(1090,70,180,50);
rotationS1 = RotationJointPos(rotationS1);
grad_rot_1 = parseInt(rotationS1 * 180 / PI);
String a1="A";
int a2 = parseInt(grad_rot_1);
textA = a1+a2;   
myPort.write((textA)+'\n');
print("Rotation Servo 1 = "); print(rotationS1); print(" ");
print(grad_rot_1); print(" "); println(textA); //debug
delay(10);
}
//1320,70,180,50
if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 && mouseY>70 && mouseY<70+50){
IlluminaTasto(1320,70,180,50);
rotationS1 = RotationJointNeg(rotationS1);
grad_rot_1 = parseInt(rotationS1 * 180 / PI);
String a1="A";
int a2 = parseInt(grad_rot_1);
String textA = a1+a2;
myPort.write((textA)+'\n');

print("Rotation Servo 1 = "); print(rotationS1); print(" ");
print(grad_rot_1); print(" "); println(textA); //debug
delay(10);
}
//1090,170,180,50
if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 
&& 
mouseY>170 
&&
mouseY<170+50){
IlluminaTasto(1090,170,180,50);
rotationS2 = RotationJointPos(rotationS2);
grad_rot_2 = parseInt(rotationS2 * 180 / PI);
String b1="B";
int b2 = parseInt(grad_rot_2);
String textB = b1+b2;
myPort.write((textB)+'\n');
print("Rotation Servo 2 = "); print(rotationS2); print(" ");
print(grad_rot_2); print(" "); println(textB); //debug
delay(10);
}
//1320,170,180,50
if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 
&& 
mouseY>170 
&&
mouseY<170+50){
IlluminaTasto(1320,170,180,50);
rotationS2 = RotationJointNeg(rotationS2);
grad_rot_2 = parseInt(rotationS2 * 180 / PI);
String b1="B";
int b2 = parseInt(grad_rot_2); stroke(255,0,0); //The
outline of the key is colored Red
String textB = b1+b2;
myPort.write((textB)+'\n');
print("Rotation Servo 2 = "); print(rotationS2); print(" ");
print(grad_rot_2); print(" "); println(textB); //debug
delay(10);
}

//1090,270,180,50
if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 
&& 
mouseY>270 
&&
mouseY<270+50){
IlluminaTasto(1090,270,180,50);
rotationS3 = RotationJointPos(rotationS3);
grad_rot_3 = parseInt(rotationS3 * 180 / PI);
String c1="C";
int c2 = parseInt(grad_rot_3);
String textC = c1+c2;
myPort.write((textC)+'\n');
print("Rotation Servo 3 = "); print(rotationS3); print(" ");
print(grad_rot_3); print(" "); println(textC); //debug
delay(10);
}
//1320,270,180,50
if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 
&& 
mouseY>270 
&&
mouseY<270+50){
IlluminaTasto(1320,270,180,50);
rotationS3 = RotationJointNeg(rotationS3);
grad_rot_3 = parseInt(rotationS3 * 180 / PI);
String c1="C";
int c2 = parseInt(grad_rot_3);
String textC = c1+c2;
myPort.write((textC)+'\n');
print("Rotation Servo 3 = "); print(rotationS3); print(" ");
print(grad_rot_3); print(" "); println(textC); //debug
delay(10);
}
//1090,370,180,50
if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 
&& 
mouseY>370 
&&
mouseY<370+50){
IlluminaTasto(1090,370,180,50);

rotationS4 = RotationJointPos(rotationS4);
grad_rot_4 = parseInt(rotationS4 * 180 / PI);
String d1="D";
int d2 = parseInt(grad_rot_4);
String textD = d1+d2;
myPort.write((textD)+'\n');
print("Rotation Servo 4 = "); print(rotationS4); print(" ");
print(grad_rot_4); print(" "); println(textD); //debug
delay(10);
}
//1320,370,180,50
if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 
&& 
mouseY>370 
&&
mouseY<370+50){
IlluminaTasto(1320,370,180,50);
rotationS4 = RotationJointNeg(rotationS4);
grad_rot_4 = parseInt(rotationS4 * 180 / PI);
String d1="D";
int d2 = parseInt(grad_rot_4);
String textD = d1+d2;
myPort.write((textD)+'\n');
print("Rotation Servo 4 = "); print(rotationS4); print(" ");
print(grad_rot_4); print(" "); println(textD); //debug
delay(10);
}
//1090,470,180,50
if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 
&& 
mouseY>470 
&&
mouseY<470+50){
IlluminaTasto(1090,470,180,50);
rotationS5 = RotationJointPos(rotationS5);
grad_rot_5 = parseInt(rotationS5 * 180 / PI);
String e1="E";
int e2 = parseInt(grad_rot_5);
String textE = e1+e2;

myPort.write((textE)+'\n');
print("Servo rotation 5 = "); print(rotationS5); print(" ");
print(grad_rot_5); print(" "); println(textE); //debug
delay(10);
}
//1320,470,180,50
if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 
&& 
mouseY>470 
&&
mouseY<470+50){
IlluminaTasto(1320,470,180,50);
rotationS5 = RotationJointNeg(rotationS5);
grad_rot_5 = parseInt(rotationS5 * 180 / PI);
String e1="E";
int e2 = parseInt(grad_rot_5);
String textE = e1+e2;
myPort.write((textE)+'\n');
print("Servo rotation 5 = "); print(rotationS5); print(" ");
print(grad_rot_5); print(" "); println(textE); //debug
delay(10);
}
//1090,570,180,50
if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 
&& 
mouseY>570 
&&
mouseY<570+50){
IlluminaTasto(1090,570,180,50);
rotationS6 = RotationJointPos(rotationS6);
grad_rot_6 = parseInt(rotationS6 * 180 / PI);
String f1="F";
int f2 = parseInt(grad_rot_6);
String textF = f1+f2;
myPort.write((textF)+'\n');
print("Servo rotation 6 = "); print(rotationS6); print(" ");
print(grad_rot_6); print(" "); println(textF); //debug
delay(10);
}

//1320,570,180,50
if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 
&& 
mouseY>570 
&&
mouseY<570+50){
IlluminaTasto(1320,570,180,50);
rotationS6 = RotationJointNeg(rotationS6);
grad_rot_6 = parseInt(rotationS6 * 180 / PI);
String f1="F";
int f2 = parseInt(grad_rot_6);
String textF = f1+f2;
myPort.write((textF)+'\n');
print("Servo rotation 6 = "); print(rotationS6); print(" ");
print(grad_rot_6); print(" "); println(textF); //debug
delay(10);
}
//1090,670,180,50
if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 
&& 
mouseY>670 
&&
mouseY<670+50){
IlluminaTasto(1090,670,180,50);
rotationS7 = RotationJointPos(rotationS7);
grad_rot_7 = parseInt(rotationS7 * 180 / PI);
String g1="G";
int g2 = parseInt(grad_rot_7);
String textG = g1+g2;
myPort.write((textG)+'\n');
print("Servo rotation 7 = "); print(rotationS7); print(" ");
print(grad_rot_7); print(" "); println(textG); //debug
delay(10);
}
//1320,670,180,50
if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 
&& 
mouseY>670 
&&
mouseY<670+50){
IlluminaTasto(1320,670,180,50);

rotationS7 = RotationJointNeg(rotationS7);
grad_rot_7 = parseInt(rotationS7 * 180 / PI);
String g1="G";
int g2 = parseInt(grad_rot_7);
String textG = g1+g2;
myPort.write((textG)+'\n');
print("Servo rotation 7 = "); print(rotationS7); print(" ");
print(grad_rot_7); print(" "); println(textG); //debug
delay(10);
}
//1205,770,180,50 - RESET KEY
if(mousePressed 
&& 
mouseX>1205 
&&
mouseX<1205+180 
&& 
mouseY>770 
&&
mouseY<770+50){
IlluminaTasto(1205,770,180,50);
KeyReset();
rotationS1=PI/2; //Servo S1 BASE at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180  
rotationS2=PI/2; //Servo S2 Arm at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180
rotationS3=PI/2; //Servo S3 AvanBracket at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
rotationS4=PI/2; //Servo S4 AvanBracket rotation at rest
is at 90° so it rotates from 0 to 90 and from 90 to 180
rotationS5=PI/2; //Servo S5 Rotation Wrist at rest is at
90° so it rotates from 0 to 90 and from 90 to 180
rotationS6=PI/2; //Servo S6 Rotation Pliers at rest is at
90° so it rotates from 0 to 90 and from 90 to 180
rotationS7=PI/2; //Servo S7 gripper grip at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
}
DrawArm();
}
void KeyReset() {

String textA = "A90";
myPort.write((textA)+'\n');
print("Servo rotation 1 = "); print(PI/2); print(" ");
print(90); print(" "); println(textA); //debug
delay(200);
String textB = "B90";
myPort.write((textB)+'\n');
print("Servo rotation 2 = "); print(PI/2); print(" ");
print(90); print(" "); println(textB); //debug
delay(200);
String textC = "C90";
myPort.write((textC)+'\n');
print("Servo rotation 3 = "); print(PI/2); print(" ");
print(90); print(" "); println(textC); //debug
delay(200);
String textD = "D90";
myPort.write((textD)+'\n');
print("Servo rotation 4 = "); print(PI/2); print(" ");
print(90); print(" "); println(textD); //debug
delay(200);
String textE = "E90";
myPort.write((textE)+'\n');
print("Servo rotation 5 = "); print(PI/2); print(" ");
print(90); print(" "); println(testoE); //debug
delay(200);
String textF = "F90";
myPort.write((textF)+'\n');
print("Servo rotation 6 = "); print(PI/2); print(" ");
print(90); print(" "); println(textF); //debug
delay(200);
String textG = "G90";

myPort.write((textG)+'\n');
print("Servo rotation 7 = "); print(PI/2); print(" ");
print(90); print(" "); println(textG); //debug
delay(200);
}
void DrawLegenda() {
//Position text by site
fill(255); //Select the color White    
textSize(20); //text size
text("WWW.BEMAKER.ORG", 
50, 
880); 
//Position 
text
"WWW.BEMAKER.ORG"
// text(State, 500, 880); //Position text State
//Position text for command mouse click legend.
textSize(30); //text size
fill(255); //Select the color White    
text("CLICK MOUSE," 1200, 50); //Position text "LEGEND"
//first line
fill(0,123,184); //Select the color White    
rect(1090,70,180,50);
fill(255); //Select the color White    
text("a = S1 <-", 1100, 100); //Position text "S1 <-"
fill(0,123,184); //Select the color White    
rect(1320,70,180,50);
fill(255); //Select the color White    
text("s = S1 ->", 1330, 100); //Position text "S1 <-"
//second line
fill(0,123,184); //Select the color White    
rect(1090,170,180,50);
fill(255); //Select the color White    
text("e = S2 v", 1100, 200); //Position text "e = S2 ^"
fill(0,123,184); //Select the color White    
rect(1320,170,180,50);
fill(255); //Select the color White    

text("d = S2 ^", 1330, 200); //Position text "d = S2 v"
//third line
fill(0,123,184); //Select the color White    
rect(1090,270,180,50);
fill(255); //Select the color White    
text("r = S3 ^", 1100, 300); //Position text "e = S3 ^"
fill(0,123,184); //Select the color White    
rect(1320,270,180,50);
fill(255); //Select the color White    
text("f = S3 v", 1330, 300); //Position text "d = S3 v"
//fourth line
fill(0,123,184); //Select the color White    
rect(1090,370,180,50);
fill(255); //Select the color White    
text("t = S4 <-", 1100, 400); //Position text "e = S4 ^"
fill(0,123,184); //Select the color White    
rect(1320,370,180,50);
fill(255); //Select the color White    
text("g = S4 ->", 1330, 400); //Position text "d = S4 v"
//fifth line
fill(0,123,184); //Select the color White    
rect(1090,470,180,50);
fill(255); //Select the color White    
text("y = S5 <-", 1100, 500); //Position text "e = S5 ^"
fill(0,123,184); //Select the color White    
rect(1320,470,180,50);
fill(255); //Select the color White    
text("h = S5 ->", 1330, 500); //Position text "d = S5 v"
//sixth line
fill(0,123,184); //Select the color White    
rect(1090,570,180,50);
fill(255); //Select the color White    
text("u = S6 <-", 1100, 600); //Position text "e = S6 <-"
fill(0,123,184); //Select the color White    

rect(1320,570,180,50);
fill(255); //Select the color White    
text("j = S6 ->", 1330, 600); //Position text "d = S6 ->"
//seventh line
fill(0,123,184); //Select the color White    
rect(1090,670,180,50);
fill(255); //Select the color White    
text("k = S7 <->", 1100, 700); //Position text "d = S7 <->"
fill(0,123,184); //Select the color White    
rect(1320,670,180,50);
fill(255); //Select the color White    
text("l = S7 >-<", 1330, 700); //Position text "d = S7 >-<"
//eighth line
fill(0,123,184); //Select the color White    
rect(1205,770,180,50);
fill(255); //Select the color White    
text("RESET," 1250, 800); //Position text "d = S7 <->"
fill(255); //Select the color White    
}
void DrawArm() {
// Drawing the Robot Arm in 3D
//Draw the base
noStroke();
translate(300,700,0); //Move the drawing reference to the
right (x) by 200, down (y) by 600, and z=0
rotateY(rotationS1); //Rotate along the y-axis
fill(0,127,255); //Select the color blue
box(60); //Draw to the new coordinates a cube of side 60
//Design the arm rotation joint.
translate( 0,-60,0 ); //Move the reference only upward
along the y
fill(255,0,0); //Select the color Red
rotateX( PI-rotationS2 ); //Rotate along the X axis.
sphere(30); //Draw a sphere

//Draw the arm
translate( 0,0,140 ); //Move the reference only upward
along z
fill(255,255,0); //Select the color Yellow
box( 60, 60, 220 ); //Draw a parallelepiped 60x60x220
//Design the forearm pivot joint.
translate( 0,0,140 ); //Move the reference only upward
along z
fill(255,0,0); //Select the color Red
rotateX( rotateS3 ); //Rotate along the X axis
rotateZ( rotateS4 ); //Rotate along the z axis
sphere(30); //Draw a sphere
//Drawing the forearm.
translate( 0,0,-110 ); //Move the reference only upward
along z
fill(255,255,0); //Select the color Yellow
box( 60, 60, 150 ); //Draw a parallelepiped 60x60x220
//Drawing the wrist rotation joint.
translate( 0,0,-110 ); //Move the reference only upward
along z
fill(255,0,0); //Select the color Red
rotateX( rotateS5 ); //Rotate along the y-axis
rotateY( rotationS6 ); //Rotate along the z axis
sphere(30); //Draw a sphere
//Draw the lower clamp
translate( 0,-70,0 ); //Move the reference only upward
along z
fill(70,70,70); //Select the color Red
box( 20, 130, 20 ); //Draw a parallelepiped
//Drawing the rotation joint of the upper gripper
translate( 0,35,0 ); //Move the reference only upward along
z
fill(255,0,0); //Select the color Red
rotateX( PI-rotationS7 ); //Rotate along the x-axis
sphere(10); //Draw a sphere

//Draw the upper clamp
translate( 0,50,0 ); //Move the reference only upward along
z
fill(70,70,70); //Select the color Red
rotateX( -PI/2 ); //Rotate along the X axis.
box( 20, 20, 80 ); //Draw a parallelepiped
translate( 0,-40,40 ); //Move the reference only upward
along the z
fill(70,70,70); //Select the color Red
rotateX( PI/2 ); //Rotate along the X axis.
box( 20, 20, 80 ); //Draw a parallelepiped 
}
void IlluminateKey(int xa, int xb, int xc, int xd) {
stroke(255,0,0); //The outline of the key is colored Red
strokeWeight(10); //the thickness of the outline becomes
from 10
noFill(); //NoFill (transparent)
rect(xa,xb,xc,xd); //rectangle of the ON button
}
float RotationPos(float rg1) {
rg1 = rg1+(vel*PI/180); //calculating the joint rotation in
radians, incrementing it one grad at a time
int rg2 = parseInt(rg1 * 180/PI); //convert values from rad
to grad
if (rg2<0){ //limit rotations for values <0
rg2 = 0; //insert a zero value even when you want to give
a negative rotation with the mouse
rg1 = 0.0;   
} else if (rg2>180){ //limit rotations for values >180°
rg2 = 180; //insert 180 degrees even when you want to
give a greater rotation with the muose
rg1 = PI;
}

return rg1;
}
float RotationNeg(float rg1) {
rg1 = rg1-(vel*PI/180); //calculate the joint rotation in
radians, incrementing it one step at a time
int rg2 = parseInt(rg1 * 180/PI); //convert values from rad
to grad
if (rg2<0){ //limit rotations for values <0
rg2 = 0; //insert a zero value even when you want to give
a negative rotation with the mouse
rg1 = 0.0;   
} else if (rg2>180){ //limit rotations for values >180°
rg2 = 180; //insert 180 degrees even when you want to
give a greater rotation with the muose
rg1 = PI;
}
return rg1;
}
Analysis of Project 11 sketches - Robot arm
controlled by PCA9685 board
Let us first analyze the sketch for Arduino; each line
of the sketch is commented, so you will find no
difficulty 
in 
understanding 
what 
the 
individual
instructions do. The Project 11 sketch, as you can
see, is basically identical to the sketch in the previous
project, the only noticeable difference is that in the
current one, having to discriminate which servomotor
the commands arrive at, once the command string
sent by Processing is captured, there is the
"switch...case..." that directs the command to the
correct servomotor.

The sketch for Processing, for obvious reasons, is
much more complex, but only for the graphical
construction 
of 
the 
arm 
and 
for 
having 
the
movements correctly represented. In fact, in this
regard, I realized, while developing Project 11, that
the sketch for Processing from Project 09, where a 3D
Robot Arm is always represented, had bugs, in
particular, the movements of the servo motors of the
arm (servo 2) and the gripper (servo 7) were not
represented correctly. In this version of the sketch,
these bugs have been corrected.
Let us see from a logic flow point of view how the
sketch was structured:

PS: since I already know someone will complain about
not using the standard symbology of Logic Flow
Diagrams for software development, the current
representation is to keep the diagram size contained
and thus make it more readable.
From the sketch for Processing, then we observe that
we have two types of functions, one that follows the

actions in it once called and the other that instead, in
addition to performing the actions, also returns a
value that is then assigned to a variable. This second
type 
of 
function 
generally 
are 
those 
of 
a
mathematical type, where there is a need to have
more 
or 
less 
complex 
calculations 
performed,
perhaps even calling other functions, and then return
with "result" a value. In the sketch we can see that to
this type of function belong the two functions called:
-         RotationJointPos
-         RotationJointNeg
For these two functions, called by also assigning a
parameter, you have the calculation of the current
rotation required of the servos.
While for functions:
-         DrawLegend
-         IlluminaButton
-         DrawArm
-         Reset key
These once called perform their task and then it ends
there, the whole thing.
With this project ends Lesson 5, of course, as I always
say, my project proposals are only meant to tickle
your curiosity and should be seen not as end points,
but as starting points, so if you have any suggestions
or if you feel like improving what I have proposed,
feel free to do so and if you need any help contact
me at info@bemaker.org.

[For the video related to the project click here].
[For the sketch for the project to be uploaded to
Arduino click here].
[For the sketch related to the project for Processing
click here].

LESSON 6 - Controlling a Robot Arm
via BT with HC-05 and PCA9685
We continue in the wake of the previous lessons
showing the various ways to control the Robot Arm
and see in this lesson how to combine the use of the
PCA9685 board for servo motor control and the HC-
05 
Bluetooth 
module 
for 
wireless 
connection
between PC and Arduino.
From a hardware point of view we will use well-known
objects so there is nothing to go into, while from a
software point of view we will have to update both
the sketch on Arduino and the one on Processing.
Let's not waste any more time let's go straight to
action and then to Project 12.
Project 12: Control and Command Robot Arm
via LV with PCA9685.

Processing will also be used for this project to create
a fantastic graphical user interface that reports in 3D
all the movements of our robotic arm that we control
through Arduino.
Project Description 12: We will issue commands by
left-clicking on buttons on the graphical page
reproduced with Processing on a PC that is connected
via the HC-05 Bluetooth module to Arduino. To verify
the commands coming from the first PC we will
connect a second PC to Arduino via USB so that the
various commands received will be reproduced on
the serial monitor. Then connected to Arduino via I2C
is the PCA9685 Servormotor Controller board, which
will sort the commands to the individual servomotors
and power them. Obviously, like any of my projects, it
is to be considered only as a starting point for your
developments and improvements as well.
Arduino Uno
R3
Dupont M -
M and M - F
Cables
USB
connection
cable
HC-05
Bluetooth
Module
Bi-Directional
7DOF Robot
PCA9685 16-
No. 
1

Level Shifter
Arm
channel PWM
servo
controller
board
baseplate
s 
400
holes
For this project we need:
We are going to implement what is represented by
the assembly diagrams below, as you can well
observe they are basically two separate systems, I
will represent them separately also to make them
easier to read, one diagram deals with the Bluetooth
communication and the other with the command and
control of the robot arm through the PCA9685. The
power supply to the 7 servo motors is done through a
stabilized power supply with 5V voltage that goes to
the PCA9685 which in turn will sort the power to the
individual servos.
Let us look at the schematic to be made for the
Bluetooth communication part with the HC-05. As you
can see, it is essentially identical to what was done
for Project 5

Regarding the scheme to be made to control the arm
servo motors, you can refer to the diagram below:

When assembling the circuits, pay attention to the
colors of the servo wires (brown = GND, red = Vcc,
and orange = Signal), and also since you will surely
need extension cords, make sure that at the junction
points you do not have cable detachments by putting
paper tape on them.
The sketch to be uploaded to Arduino is as follows:
/*
BeMaker.org - COURSE ON THE ROBOTIC ARM.
Project 12 - ROBOT ARM CONTROLLED BY PCA9685 AND
ARDUINO VIA BT.
https://bemaker.org/
*/

#include <Wire.h> //Loads the Wire library for I2C
comuication.
#include <Adafruit_PWMServoDriver.h> //Loads Adafruit's
servo control library with PCA9685
#include <SoftwareSerial.h> //Retrieve the SoftwareSerial
library.
// In this section we set the parameters dependent on the
servos we use. Be careful you can damage the servos.
#define RxPin 6 //Define PIN 6 as Rx
#define TxPin 7 //Define PIN 7 as Tx#define SERVOMIN 150
//SG90 // The default Adafruit value is 150 and represents
the duration of the minimum pulse that corresponds 0° (the
value can vary from 0 to 4095)
#define SERVOMIN 150 //SG90 // The default Adafruit value
is 150 and represents the minimum pulse duration that
corresponds 0° (the value can vary from 0 to 4095)
#define SERVOMAX 650 //SG90 // The default Adafruit value
is 600 and represents the duration of the maximum pulse
that corresponds 180° (the value can vary from 0 to 4095)
#define SERVO_FREQ 60 //Value of the default frequency set
by Adafruit is 50. For SG90s, 60 Hz is used.
// The default address of PCA9685 is 0x40
Adafruit_PWMServoDriver myservo =
Adafruit_PWMServoDriver(); //This method directs
commands to the default board, 0x40
SoftwareSerial btSerial(RxPin,TxPin); //The Rx and Tx
definitions apply.
int Rotation = 0; //I'll define a variable where I'll enter the
pulse length that tells me the rotation
String NewRotation; //variable for capturing the string
char PrimoCar; //variable for string capture
int ServoMotor1=0; //Creates a variable called ServoMotor1
int ServoMotor2=1; //Creates a variable called ServoMotor2

int ServoMotor3=2; //Creates a variable called ServoMotor3
int ServoMotor4=3; //Creates a variable called ServoMotor4
int ServoMotor5=4; //Creates a variable called ServoMotor5
int ServoMotor6=5; //Creates a variable called ServoMotor6
int ServoMotor7=6; //Creates a variable called ServoMotor7
void setup() {
  Serial.begin(9600); //Initialize the serial port of the IDE.
  delay(50); //Introduce a delay to settle the initialization
  btSerial.begin(9600); //Apply the communication speed to
the HC-05 Module.
  delay(50); //Introduce a delay to settle the initialization
  myservo.begin(); //Initialize the myservo object.
  myservo.setPWMFreq(SERVO_FREQ); // Let's set the analog
frequency for servomotors
  delay(50); //Introduce a delay to settle the initialization
  Serial.println("Arduino ready...");
}
void loop() {
     if(btSerial.available()>0) //Condition true when there is
data on the SERIAL port
      {
        String inString = btSerial.readStringUntil('\n');
        Serial.println(inString);
        char PrimoCar = inString.charAt(0);
        NewRotation=inString.substring(1);
        Rotation = NewRotation.toInt();
        Rotation = map(Rotation,0, 180,
SERVOMIN,SERVOMAX); //map the pulse length value in
degrees of rotation 
        switch (PrimoCar) {
        case ('A'):
          myservo.setPWM(ServoMotor1, 0, Rotation); //Pilot the
first servo according to the angles arriving on the serial port
        break;

        case ('B'):
          myservo.setPWM(ServoMotor2, 0, Rotation); //Pilot the
second servo according to the angles arriving on the serial
port
        break;
        case ('C'):
          myservo.setPWM(ServoMotor3, 0, Rotation); //Pilot the
third servo according to the angles arriving on the serial
port
        break;
        case ('D'):
          myservo.setPWM(ServoMotor4, 0, Rotation); //Pilot the
fourth servo according to the angles arriving on the serial
port
        break;
        case ('E'):
          myservo.setPWM(ServoMotor5, 0, Rotation); //Pilot the
fifth servo according to the angles arriving on the serial port
        break;
        case ('F'):
          myservo.setPWM(ServoMotor6, 0, Rotation); //Pilot the
sixth servo according to the angles arriving on the serial
port
        break;
        case ('G'):
          myservo.setPWM(ServoMotor7, 0, Rotation); //Pilot the
seventh servo according to the angles arriving on the serial
port
        break;
        //debug
        case ('P'):
          btSerial.println("Arduino says: I'm ready!...");
        break;
        }
      }
    delay(10);  

}
The sketch to be opened in Processing on the PC is as
follows:
/*
BeMaker.org - COURSE ON THE ROBOTIC ARM.
Project 12 - ARM CONTROL VIA BT WITH HC-05 AND
PCA9685
https://bemaker.org/
*/
import processing.serial.*; //Import the library for serial
communications
Serial myPort; //Define the myPort object.
String State = ""; //Defines the State variable as a string
that will give indications on Arduino
//String Package; //Defines the variable Package as a
character string that it receives from Arduino
float vel=0.5; //Multiplicative factor angles of rotation
float rotationS1 = 0.0; //Define the rotation variable of S1
float rotationS2 = 0.0; //Define the rotation variable of S2
float rotationS3 = 0.0; //Define the rotation variable of S3
float rotationS4 = 0.0; //Define the rotation variable of S4
float rotationS5 = 0.0; //Define the rotation variable of S5
float rotationS6 = 0.0; //Define the rotation variable of S6
float rotationS7 = 0.0; //Define the rotation variable of S7
int 
grad_rot_1 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees
int 
grad_rot_2 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees
int 
grad_rot_3 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees
int 
grad_rot_4 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees

int 
grad_rot_5 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees
int 
grad_rot_6 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees
int 
grad_rot_7 
= 
0; 
//Define 
the 
integer 
variable
representing the corresponding rotation in degrees
String textA = ""; //Define a string variable.
String textB = ""; //Define a string variable.
String textC = ""; //Define a string variable.
String textD = ""; //Define a string variable.
String textE = ""; //Define a string variable.
String textF = ""; //Define a string variable.
String textG = ""; //Define a string variable.
String Pp = "Pp"; //Define a string variable.
void setup() {
String portName = "COM10"; //Associate the COM port
actually used for communication - see Lesson 4 of the
Course for how to do it
myPort = new Serial(this, portName, 9600); //Creating and
Setting the Port
myPort.bufferUntil('\n'); // Defines the terminal character
of the string to be read
myPort.write ((Pp)+'\n'); //The string 'Pp' is sent to the LV
port to make sure we start from a known condition
delay(100);
//Setting 
3D 
graphical 
environment 
and 
assigning
variables
size( 1600, 900, P3D ); //Create a 3D window x=1500,
y=800 z= undefined
ambientLight(0,0,255); //Add a diffuse white ambient light
pointLight(255, 0, 0, width/2, height/2, 400); //Add a white
light fixture to the middle length of the window to give the
shadows for depth

noStroke(); //Not defining the contours of the solids I am
going to draw
rotationS1=PI/2; //Servo S1 BASE at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180  
rotationS2=PI/2; //Servo S2 Arm at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180
rotationS3=PI/2; //Servo S3 AvanBracket at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
rotationS4=PI/2; //Servo S4 AvanBracket rotation at rest is
at 90° so it rotates from 0 to 90 and from 90 to 180
rotationS5=PI/2; //Servo S5 Rotation Wrist at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
rotationS6=PI/2; //Servo S6 Rotation Pliers at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
rotationS7=PI/2; //Servo S7 gripper grip at rest is at 90° so
it rotates from 0 to 90 and from 90 to 180
if (myPort.available() > 0) { //Checks whether there is data
on the serial port
State = myPort.readStringUntil('\n'); //Looks at the string
coming from Arduino and puts it into the state variable
}
}
void draw() {
background(0);
lights();
DrawLegenda();
//CONTROLS WHEN THE LEFT MOUSE BUTTON IS PRESSED
ON A GIVEN RECTANGLE
//1090,70,180,50 - Xgra: rad = 180 : pi
if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 && mouseY>70 && mouseY<70+50){
IlluminaTasto(1090,70,180,50);
rotationS1 = RotationJointPos(rotationS1);
grad_rot_1 = parseInt(rotationS1 * 180 / PI);

String a1="A";
int a2 = parseInt(grad_rot_1);
textA = a1+a2;   
myPort.write((textA)+'\n');
print("Rotation Servo 1 = "); print(rotationS1); print(" ");
print(grad_rot_1); print(" "); println(textA); //debug
delay(10);
}
//1320,70,180,50
if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 && mouseY>70 && mouseY<70+50){
IlluminaTasto(1320,70,180,50);
rotationS1 = RotationJointNeg(rotationS1);
grad_rot_1 = parseInt(rotationS1 * 180 / PI);
String a1="A";
int a2 = parseInt(grad_rot_1);
String textA = a1+a2;
myPort.write((textA)+'\n');
print("Rotation Servo 1 = "); print(rotationS1); print(" ");
print(grad_rot_1); print(" "); println(textA); //debug
delay(10);
}
//1090,170,180,50
if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 
&& 
mouseY>170 
&&
mouseY<170+50){
IlluminaTasto(1090,170,180,50);
rotationS2 = RotationJointPos(rotationS2);
grad_rot_2 = parseInt(rotationS2 * 180 / PI);
String b1="B";
int b2 = parseInt(grad_rot_2);
String textB = b1+b2;
myPort.write((textB)+'\n');
print("Rotation Servo 2 = "); print(rotationS2); print(" ");
print(grad_rot_2); print(" "); println(textB); //debug

delay(10);
}
//1320,170,180,50
if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 
&& 
mouseY>170 
&&
mouseY<170+50){
IlluminaTasto(1320,170,180,50);
rotationS2 = RotationJointNeg(rotationS2);
grad_rot_2 = parseInt(rotationS2 * 180 / PI);
String b1="B";
int b2 = parseInt(grad_rot_2); stroke(255,0,0); //The
outline of the key is colored Red
String textB = b1+b2;
myPort.write((textB)+'\n');
print("Rotation Servo 2 = "); print(rotationS2); print(" ");
print(grad_rot_2); print(" "); println(textB); //debug
delay(10);
}
//1090,270,180,50
if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 
&& 
mouseY>270 
&&
mouseY<270+50){
IlluminaTasto(1090,270,180,50);
rotationS3 = RotationJointPos(rotationS3);
grad_rot_3 = parseInt(rotationS3 * 180 / PI);
String c1="C";
int c2 = parseInt(grad_rot_3);
String textC = c1+c2;
myPort.write((textC)+'\n');
print("Rotation Servo 3 = "); print(rotationS3); print(" ");
print(grad_rot_3); print(" "); println(textC); //debug
delay(10);
}
//1320,270,180,50

if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 
&& 
mouseY>270 
&&
mouseY<270+50){
IlluminaTasto(1320,270,180,50);
rotationS3 = RotationJointNeg(rotationS3);
grad_rot_3 = parseInt(rotationS3 * 180 / PI);
String c1="C";
int c2 = parseInt(grad_rot_3);
String textC = c1+c2;
myPort.write((textC)+'\n');
print("Rotation Servo 3 = "); print(rotationS3); print(" ");
print(grad_rot_3); print(" "); println(textC); //debug
delay(10);
}
//1090,370,180,50
if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 
&& 
mouseY>370 
&&
mouseY<370+50){
IlluminaTasto(1090,370,180,50);
rotationS4 = RotationJointPos(rotationS4);
grad_rot_4 = parseInt(rotationS4 * 180 / PI);
String d1="D";
int d2 = parseInt(grad_rot_4);
String textD = d1+d2;
myPort.write((textD)+'\n');
print("Rotation Servo 4 = "); print(rotationS4); print(" ");
print(grad_rot_4); print(" "); println(textD); //debug
delay(10);
}
//1320,370,180,50
if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 
&& 
mouseY>370 
&&
mouseY<370+50){
IlluminaTasto(1320,370,180,50);
rotationS4 = RotationJointNeg(rotationS4);

grad_rot_4 = parseInt(rotationS4 * 180 / PI);
String d1="D";
int d2 = parseInt(grad_rot_4);
String textD = d1+d2;
myPort.write((textD)+'\n');
print("Rotation Servo 4 = "); print(rotationS4); print(" ");
print(grad_rot_4); print(" "); println(textD); //debug
delay(10);
}
//1090,470,180,50
if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 
&& 
mouseY>470 
&&
mouseY<470+50){
IlluminaTasto(1090,470,180,50);
rotationS5 = RotationJointPos(rotationS5);
grad_rot_5 = parseInt(rotationS5 * 180 / PI);
String e1="E";
int e2 = parseInt(grad_rot_5);
String textE = e1+e2;
myPort.write((textE)+'\n');
print("Servo rotation 5 = "); print(rotationS5); print(" ");
print(grad_rot_5); print(" "); println(textE); //debug
delay(10);
}
//1320,470,180,50
if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 
&& 
mouseY>470 
&&
mouseY<470+50){
IlluminaTasto(1320,470,180,50);
rotationS5 = RotationJointNeg(rotationS5);
grad_rot_5 = parseInt(rotationS5 * 180 / PI);
String e1="E";
int e2 = parseInt(grad_rot_5);
String textE = e1+e2;
myPort.write((textE)+'\n');

print("Servo rotation 5 = "); print(rotationS5); print(" ");
print(grad_rot_5); print(" "); println(textE); //debug
delay(10);
}
//1090,570,180,50
if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 
&& 
mouseY>570 
&&
mouseY<570+50){
IlluminaTasto(1090,570,180,50);
rotationS6 = RotationJointPos(rotationS6);
grad_rot_6 = parseInt(rotationS6 * 180 / PI);
String f1="F";
int f2 = parseInt(grad_rot_6);
String textF = f1+f2;
myPort.write((textF)+'\n');
print("Servo rotation 6 = "); print(rotationS6); print(" ");
print(grad_rot_6); print(" "); println(textF); //debug
delay(10);
}
//1320,570,180,50
if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 
&& 
mouseY>570 
&&
mouseY<570+50){
IlluminaTasto(1320,570,180,50);
rotationS6 = RotationJointNeg(rotationS6);
grad_rot_6 = parseInt(rotationS6 * 180 / PI);
String f1="F";
int f2 = parseInt(grad_rot_6);
String textF = f1+f2;
myPort.write((textF)+'\n');
print("Servo rotation 6 = "); print(rotationS6); print(" ");
print(grad_rot_6); print(" "); println(textF); //debug
delay(10);
}
//1090,670,180,50

if(mousePressed 
&& 
mouseX>1090 
&&
mouseX<1090+180 
&& 
mouseY>670 
&&
mouseY<670+50){
IlluminaTasto(1090,670,180,50);
rotationS7 = RotationJointPos(rotationS7);
grad_rot_7 = parseInt(rotationS7 * 180 / PI);
String g1="G";
int g2 = parseInt(grad_rot_7);
String textG = g1+g2;
myPort.write((textG)+'\n');
print("Servo rotation 7 = "); print(rotationS7); print(" ");
print(grad_rot_7); print(" "); println(textG); //debug
delay(10);
}
//1320,670,180,50
if(mousePressed 
&& 
mouseX>1320 
&&
mouseX<1320+180 
&& 
mouseY>670 
&&
mouseY<670+50){
IlluminaTasto(1320,670,180,50);
rotationS7 = RotationJointNeg(rotationS7);
grad_rot_7 = parseInt(rotationS7 * 180 / PI);
String g1="G";
int g2 = parseInt(grad_rot_7);
String textG = g1+g2;
myPort.write((textG)+'\n');
print("Servo rotation 7 = "); print(rotationS7); print(" ");
print(grad_rot_7); print(" "); println(textG); //debug
delay(10);
}
//1205,770,180,50 - RESET KEY
if(mousePressed 
&& 
mouseX>1205 
&&
mouseX<1205+180 
&& 
mouseY>770 
&&
mouseY<770+50){
IlluminaTasto(1205,770,180,50);
KeyReset();

rotationS1=PI/2; //Servo S1 BASE at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180  
rotationS2=PI/2; //Servo S2 Arm at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180
rotationS3=PI/2; //Servo S3 AvanBracket at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
rotationS4=PI/2; //Servo S4 AvanBracket rotation at rest
is at 90° so it rotates from 0 to 90 and from 90 to 180
rotationS5=PI/2; //Servo S5 Rotation Wrist at rest is at
90° so it rotates from 0 to 90 and from 90 to 180
rotationS6=PI/2; //Servo S6 Rotation Pliers at rest is at
90° so it rotates from 0 to 90 and from 90 to 180
rotationS7=PI/2; //Servo S7 gripper grip at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
}
DrawArm();
}
void KeyReset() {
String textA = "A90";
myPort.write((textA)+'\n');
print("Servo rotation 1 = "); print(PI/2); print(" ");
print(90); print(" "); println(textA); //debug
delay(200);
String textB = "B90";
myPort.write((textB)+'\n');
print("Servo rotation 2 = "); print(PI/2); print(" ");
print(90); print(" "); println(textB); //debug
delay(200);
String textC = "C90";
myPort.write((textC)+'\n');
print("Servo rotation 3 = "); print(PI/2); print(" ");
print(90); print(" "); println(textC); //debug
delay(200);

String textD = "D90";
myPort.write((textD)+'\n');
print("Servo rotation 4 = "); print(PI/2); print(" ");
print(90); print(" "); println(textD); //debug
delay(200);
String textE = "E90";
myPort.write((textE)+'\n');
print("Servo rotation 5 = "); print(PI/2); print(" ");
print(90); print(" "); println(testoE); //debug
delay(200);
String textF = "F90";
myPort.write((textF)+'\n');
print("Servo rotation 6 = "); print(PI/2); print(" ");
print(90); print(" "); println(textF); //debug
delay(200);
String textG = "G90";
myPort.write((textG)+'\n');
print("Servo rotation 7 = "); print(PI/2); print(" ");
print(90); print(" "); println(textG); //debug
delay(200);
}
void DrawLegenda() {
//Position text by site
fill(255); //Select the color White    
textSize(20); //text size
text("WWW.BEMAKER.ORG", 
50, 
880); 
//Position 
text
"WWW.BEMAKER.ORG"
if (State != null) { //debug
text(State, 400, 880); //Position text State
} else {

text("I didn't get the OK from Arduino... check!", 400,
880); //Position text Status
}
//Position text for command mouse click legend.
textSize(30); //text size
fill(255); //Select the color White    
text("CLICK MOUSE," 1200, 50); //Position text "LEGEND"
//first line
fill(0,123,184); //Select the color White    
rect(1090,70,180,50);
fill(255); //Select the color White    
text("a = S1 <-", 1100, 100); //Position text "S1 <-"
fill(0,123,184); //Select the color White    
rect(1320,70,180,50);
fill(255); //Select the color White    
text("s = S1 ->", 1330, 100); //Position text "S1 <-"
//second line
fill(0,123,184); //Select the color White    
rect(1090,170,180,50);
fill(255); //Select the color White    
text("e = S2 v", 1100, 200); //Position text "e = S2 ^"
fill(0,123,184); //Select the color White    
rect(1320,170,180,50);
fill(255); //Select the color White    
text("d = S2 ^", 1330, 200); //Position text "d = S2 v"
//third line
fill(0,123,184); //Select the color White    
rect(1090,270,180,50);
fill(255); //Select the color White    
text("r = S3 ^", 1100, 300); //Position text "e = S3 ^"
fill(0,123,184); //Select the color White    
rect(1320,270,180,50);
fill(255); //Select the color White    
text("f = S3 v", 1330, 300); //Position text "d = S3 v"

//fourth line
fill(0,123,184); //Select the color White    
rect(1090,370,180,50);
fill(255); //Select the color White    
text("t = S4 <-", 1100, 400); //Position text "e = S4 ^"
fill(0,123,184); //Select the color White    
rect(1320,370,180,50);
fill(255); //Select the color White    
text("g = S4 ->", 1330, 400); //Position text "d = S4 v"
//fifth line
fill(0,123,184); //Select the color White    
rect(1090,470,180,50);
fill(255); //Select the color White    
text("y = S5 <-", 1100, 500); //Position text "e = S5 ^"
fill(0,123,184); //Select the color White    
rect(1320,470,180,50);
fill(255); //Select the color White    
text("h = S5 ->", 1330, 500); //Position text "d = S5 v"
//sixth line
fill(0,123,184); //Select the color White    
rect(1090,570,180,50);
fill(255); //Select the color White    
text("u = S6 <-", 1100, 600); //Position text "e = S6 <-"
fill(0,123,184); //Select the color White    
rect(1320,570,180,50);
fill(255); //Select the color White    
text("j = S6 ->", 1330, 600); //Position text "d = S6 ->"
//seventh line
fill(0,123,184); //Select the color White    
rect(1090,670,180,50);
fill(255); //Select the color White    
text("k = S7 <->", 1100, 700); //Position text "d = S7 <->"
fill(0,123,184); //Select the color White    
rect(1320,670,180,50);

fill(255); //Select the color White    
text("l = S7 >-<", 1330, 700); //Position text "d = S7 >-<"
//eighth line
fill(0,123,184); //Select the color White    
rect(1205,770,180,50);
fill(255); //Select the color White    
text("RESET," 1250, 800); //Position text "d = S7 <->"
fill(255); //Select the color White    
}
void DrawArm() {
// Drawing the Robot Arm in 3D
//Draw the base
noStroke();
translate(300,700,0); //Move the drawing reference to the
right (x) by 200, down (y) by 600, and z=0
rotateY(rotationS1); //Rotate along the y-axis
fill(0,127,255); //Select the color blue
box(60); //Draw to the new coordinates a cube of side 60
//Design the arm rotation joint.
translate( 0,-60,0 ); //Move the reference only upward
along the y
fill(255,0,0); //Select the color Red
rotateX( PI-rotationS2 ); //Rotate along the X axis.
sphere(30); //Draw a sphere
//Draw the arm
translate( 0,0,140 ); //Move the reference only upward
along z
fill(255,255,0); //Select the color Yellow
box( 60, 60, 220 ); //Draw a parallelepiped 60x60x220
//Design the forearm pivot joint.
translate( 0,0,140 ); //Move the reference only upward
along z
fill(255,0,0); //Select the color Red
rotateX( rotateS3 ); //Rotate along the X axis

rotateZ( rotateS4 ); //Rotate along the z axis
sphere(30); //Draw a sphere
//Drawing the forearm.
translate( 0,0,-110 ); //Move the reference only upward
along z
fill(255,255,0); //Select the color Yellow
box( 60, 60, 150 ); //Draw a parallelepiped 60x60x220
//Drawing the wrist rotation joint.
translate( 0,0,-110 ); //Move the reference only upward
along the z
fill(255,0,0); //Select the color Red
rotateX( rotateS5 ); //Rotate along the y-axis
rotateY( rotationS6 ); //Rotate along the z axis
sphere(30); //Draw a sphere
//Draw the lower clamp
translate( 0,-70,0 ); //Move the reference only upward
along z
fill(70,70,70); //Select the color Red
box( 20, 130, 20 ); //Draw a parallelepiped
//Drawing the rotation joint of the upper gripper
translate( 0,35,0 ); //Move the reference only upward along
z
fill(255,0,0); //Select the color Red
rotateX( PI-rotationS7 ); //Rotate along the x-axis
sphere(10); //Draw a sphere
//Draw the upper clamp
translate( 0,50,0 ); //Move the reference only upward along
z
fill(70,70,70); //Select the color Red
rotateX( -PI/2 ); //Rotate along the X axis.
box( 20, 20, 80 ); //Draw a parallelepiped
translate( 0,-40,40 ); //Move the reference only upward
along the z
fill(70,70,70); //Select the color Red
rotateX( PI/2 ); //Rotate along the X axis.

box( 20, 20, 80 ); //Draw a parallelepiped 
}
void IlluminateKey(int xa, int xb, int xc, int xd) {
stroke(255,0,0); //The outline of the key is colored Red
strokeWeight(10); //the thickness of the outline becomes
from 10
noFill(); //NoFill (transparent)
rect(xa,xb,xc,xd); //rectangle of the ON button
}
float RotationPos(float rg1) {
rg1 = rg1+(vel*PI/180); //calculating the joint rotation in
radians, incrementing it one grad at a time
int rg2 = parseInt(rg1 * 180/PI); //convert values from rad
to grad
if (rg2<0){ //limit rotations for values <0
rg2 = 0; //insert a zero value even when you want to give
a negative rotation with the mouse
rg1 = 0.0;   
} else if (rg2>180){ //limit rotations for values >180°
rg2 = 180; //insert 180 degrees even when you want to
give a greater rotation with the muose
rg1 = PI;
}
return rg1;
}
float RotationNeg(float rg1) {
rg1 = rg1-(vel*PI/180); //calculate the joint rotation in
radians, incrementing it one step at a time
int rg2 = parseInt(rg1 * 180/PI); //convert values from rad
to grad
if (rg2<0){ //limit rotations for values <0
rg2 = 0; //insert a zero value even when you want to give
a negative rotation with the mouse

rg1 = 0.0;   
} else if (rg2>180){ //limit rotations for values >180°
rg2 = 180; //insert 180 degrees even when you want to
give a greater rotation with the muose
rg1 = PI;
}
return rg1;
}
Analysis of Project 12 sketches - Control and
Command Robot Arm via LV.
The sketches do not present any particular difficulties
worthy of note, moreover, they are nothing more
than readjustments considering what has already
been done in previous projects. This is obviously a
positive aspect to consider, because it is easy to see
how the projects that are proposed in these Course
lectures are like so many bricks with which we then
move on to more advanced projects that significantly
increase the various functionalities.
[For the video project click here].
[For the video related to the project click here].
[For the sketch for the project to be uploaded to
Arduino click here].
[For the sketch related to the project for Processing
click here].

PS2 Controller and Arduino UNO
An alternative method for controlling the servo
motors of the Robot Arm that we will see in the next
projects in Lesson 6 is using the Playstation
Gamepad, specifically the PS2 Controller. Actually the
PS2 Controller can be used for several projects, but I
leave any further uses of it with Arduino to your
imagination.
Not having the Playstation, for the execution of the
projects and to study its operation, I had to buy a
new one, indeed, doing a search on the Internet I saw
that the PS2 Controller is also sold already including
an adapter module for Arduino.
I personally purchased a PS2 Controller from DOIT, a
wireless 
type, 
with 
2.4 
GHz 
operating 
radio
frequency. I report some photos of the purchase:


As you can see from the photos, the adapter module
for Arduino is nothing more than a female connector
for the PS2 Controller's wireless module to which a
breakout board has been soldered, making available
the PINs that will be used to interface with Arduino.
If you do not have this interface module do not
despair, you can easily make one yourself, but you
will need to do some soldering, below I will put the
picture with the various PINs:

The PINs colored blue are the ones that will need to
be made available to Arduino. Pay attention to the
power supply for the wireless module is 3.3V.
Interfacing the PS2 Gamepad to Arduino requires a
specific library called: Arduino-PS2X.
The buttons available on the Gamepad with the
names assigned in the library are:

The PS2 Controller uses an SPI-type communication
protocol, or Serial Peripheral Interface normally over
2.4 GHz radio frequency.
On the DOIT website https://www.vvdoit.com/ they
suggest the following link:
In addition, again from the DOIT website we are
provided with some information on precautions to be
taken when connecting, as well as some general
information, which I give below translated from
English and especially from the experiments I did:
-                 Power to the Gamepad is indicated by the red
LED on the controller, in case it is off, check that
the switch on the front is in the ON position:
-                 The interface module also has a red LED that
when lit indicates correct power supply;
-         When the LEDs are not fully lit, then it means that
there are likely power problems (first check that

the gamepad has charged batteries, the batteries
used are AAA type).
-         If the red LED on the Gamepad flashes, it means
there is no connection between the gamepad and
the receiving station.
-                  Once the connection between Gamepad and
receiver module is made, the LED stops flashing
and remains steady red;
-         If the connection between gamepad and receiver
module does not occur at the time of power on, try
pressing the "START" button on the Gamepad or
any other button to trigger communication;
-         Be very careful in supplying power to the receiver
module, both for the supply voltage (3.3V) and the
sign.

Project 13: Using PS2 Controller with Arduino
This first project using the Gamepad we devote to
learning about the PS2 Controller connected to
Arduino and getting some practice with the coding
part.
To use the PS2 Controller with Arduino we need the
Arduino-PS2X library which you can download by
clicking on the following link Arduino-PS2X .
Clicking on the proposed link will take you to an area
on Github, as shown below:

Click on Code and in the drop-down menu that
appears, click on Download ZIP
Once you have downloaded the .zipper file, unzip it
and copy the entire PS2X_lib directory located within
Arduino-PS2X-master, 
into 
the 
Arduino 
libraries
directory, 
which 
by 
default 
is 
located 
in
Documents/Arduino/.

At this point you can open the IDE and it will show
the new library installed.
Let's move on to the project. For this project we need:
Arduino Uno
R3 or
compatible
PS2 Wireless
Remote
Controller
Dupont
male -
female
cables (for
possible
extension
cords)
USB connection
cable

No. 1
baseplates
400 holes
Pay attention to the supply voltage of the receiver
module which is 3.3V . The diagram to be made is as
follows:
Descriptive version links:
Receiver
Module
Arduino PINs
CLK
->
D12
CS
->
D10
CMD
->
D11
DAT
->
D13

VCC
->
3,3V
GND
->
GND
The sketch to be uploaded to Arduino is as follows:
/*
BeMaker.org - COURSE ON THE ROBOTIC ARM.
Project 13 - GAMEPAD PS2 CONTROLLER & ARDUINO
https://bemaker.org/
*/
#include <PS2X_lib.h> //let's get the library for handling the
ps2 controller
#define PS2_DAT 13 //PIN TO WHICH THE DATA IS
CONNECTED.
#define PS2_CMD 11 //PIN TO WHICH COMMAND IS
CONNECTED.
#define PS2_SEL 10 //PIN TO WHICH THE CS IS CONNECTED.
#define PS2_CLK 12 //PIN TO WHICH THE CLOCK IS
CONNECTED.
#define pressures true //system variable, I assign it the
value true for the type of my Gamepad
#define rumble false //system variable, I assign it the value
false for the type of my Gamepad
PS2X ps2x; // I create the PS2 Controller class.
//Initialize the variables used
int error = 0;
byte type = 0;
byte vibrate = 0;
void setup(){
  Serial.begin(9600); //I initialize the port
  delay(100); //Introduce a delay to give time

  error = ps2x.config_gamepad(PS2_CLK, PS2_CMD,
PS2_SEL, PS2_DAT, pressures, rumble);//insert into a
variable error the value returned by the called function
  delay(100); //Introduce a delay to give time
  if (error ==0) { //check if there were errors in the process
    type = ps2x.readType();
    Serial.print("Controller type: ");
    Serial.println(type);  
  }
}
void loop() {
    ps2x.read_gamepad(false, vibrate); //recalls the function
and stays on standby until a gamepad key is pressed
    if(ps2x.Button(PSB_START)) { //Series of ifs that identifies
the button pressed on the gamepad
      Serial.println("Start has been pressed");}
    if(ps2x.Button(PSB_SELECT)) {
      Serial.println("Select was pressed");}
    if(ps2x.Button(PSB_PAD_UP)) { //will be TRUE as long as
button is pressed
      Serial.print("It was pressed go to the top of:");
      Serial.println(ps2x.Analog(PSAB_PAD_UP), DEC);}
    if(ps2x.Button(PSB_PAD_RIGHT)){
      Serial.print("It was pressed go to the Right of: ");
      Serial.println(ps2x.Analog(PSAB_PAD_RIGHT), DEC);}
    if(ps2x.Button(PSB_PAD_LEFT)){
      Serial.print("It was pressed go left of: ");
      Serial.println(ps2x.Analog(PSAB_PAD_LEFT), DEC);}
    if(ps2x.Button(PSB_PAD_DOWN)){
      Serial.print("It was pressed go to Bottom of: ");
      Serial.println(ps2x.Analog(PSAB_PAD_DOWN), DEC);}   
    if(ps2x.Button(PSB_L1)){
      Serial.println("L1 was pressed");}
    if(ps2x.Button(PSB_R1)){
      Serial.println("R1 was pressed");}

    if(ps2x.Button(PSB_L2)){
      Serial.println("L2 was pressed");}
    if(ps2x.Button(PSB_R2)){
      Serial.println("R2 was pressed");}
    if(ps2x.Button(PSB_TRIANGLE)){
      Serial.println("Triangle was pressed");}
    if(ps2x.ButtonPressed(PSB_CIRCLE)){               
      Serial.println("Circle was pressed");}
    if(ps2x.NewButtonState(PSB_CROSS)){               
      Serial.println("X was pressed");}
    if(ps2x.ButtonReleased(PSB_SQUARE)){              
      Serial.println("Square was pressed");}     
  delay(50);  
}
Analysis of the Project 13 sketch - Using the
PS2 Controller with Arduino
Each line of the sketch is commented out, so you will
find no difficulty in understanding what the individual
instructions do. As you can see, the project sketch
was derived by lightening the example one and
adapting it to our needs.
[For the video related to the project click here].
[For the sketch related to the project click here].

Project 14: Robot arm driven with PS2
Controller & Arduino
For the development of this project we will combine
the knowledge gained for the PCA0685 board and
what we have learned about the PS2 Controller
Gamepad. We will directly pilot a Robot Arm via
Gamepad. The control method we will use is that with
a few buttons on the Gamepad we select the servo
we want to drive and then with the down, up, right
and left buttons, we will instead drive the rotation of
the selected servo.
The fgure below shows the association between
Gamepad and Servo keys with their movements:

For this project we need:
Arduino
Uno R3 or
compatible
Robotic Arm
Dupont
male -
female
cables (for
possible
extension
cords)
USB
connection
cable
External
Power
Supply for

Robot Arm
Servomotors
5-7 V max
2A
PS2
Wireless
Remote
Controller
PCA9685 16-
channel PWM
servo controller
board
No. 1
baseplate
s 400
holes
The scheme to be carried out is as follows:
For better understanding of the connections, let us
also report them descriptively and tabularly:
PS2 Receiver
Arduino PINs

Module
CLK
->
D12
CS
->
D10
CMD
->
D11
DAT
->
D13
VCC
->
3,3V
GND
->
GND
Tab
PCA9685
Arduino PINs
GND
->
GND
SCL
->
SCL
SDA
->
SDA
VCC
->
5 V
Regarding the servo PINs on the PCA9685 Board, the
individual servo motors of the robot arm should be
connected to them as shown in the figure, paying
attention to the colors I remember: orange-colored
wire - signal, red-colored wire - Vcc, and brown-
colored wire - GND.
For the sketch to be uploaded to Arduino:
/*
BeMaker.org - COURSE ON THE ROBOTIC ARM.
Project 14 - ROBOT ARM CONTROLLED BY PS2 CONTROLLER
& PCA9685
https://bemaker.org/
*/
#include <Wire.h> //Loads the Wire library for I2C
comuication.

#include <Adafruit_PWMServoDriver.h> //Loads Adafruit's
servo control library with PCA9685
#include <PS2X_lib.h> //let's get the library for handling the
ps2 controller
// In this section, the communication parameters of the PS2
controller are set.
#define PS2_DAT 13 //PIN TO WHICH THE DATA IS
CONNECTED.
#define PS2_CMD 11 //PIN TO WHICH COMMAND IS
CONNECTED.
#define PS2_SEL 10 //PIN TO WHICH THE CS IS CONNECTED.
#define PS2_CLK 12 //PIN TO WHICH THE CLOCK IS
CONNECTED.
#define pressures true
#define rumble false
// In this section we set the parameters dependent on the
servos we use. Be careful you can damage the servos.
#define SERVOMIN 150 //SG90 // The default Adafruit value
is 150 and represents the minimum pulse duration that
corresponds 0° (the value can vary from 0 to 4095)
#define SERVOMAX 650 //SG90 // The default Adafruit value
is 600 and represents the duration of the maximum pulse
that corresponds 180° (the value can vary from 0 to 4095)
#define SERVO_FREQ 60 //Value of the default frequency set
by Adafruit is 50. For SG90s, 60 Hz is used.
// The default address of PCA9685 is 0x40
Adafruit_PWMServoDriver myservo =
Adafruit_PWMServoDriver(); //This method directs
commands to the default board, 0x40
PS2X ps2x; // I create the PS2 Controller class.
int error = 0;
byte type = 0;
byte vibrate = 0;
int ServoMotor1=0; //Creates a variable called ServoMotor1

int ServoMotor2=1; //Creates a variable called ServoMotor2
int ServoMotor3=2; //Creates a variable called ServoMotor3
int ServoMotor4=3; //Creates a variable called ServoMotor4
int ServoMotor5=4; //Creates a variable called ServoMotor5
int ServoMotor6=5; //Creates a variable called ServoMotor6
int ServoMotor7=6; //Creates a variable called ServoMotor7
int Rotation1=90; //Servo S1 BASE at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180  
int Rotation2=90; //Servo S2 Arm at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180
int Rotation3=90; //Servo S3 AvanBracket at rest is at 90° so
it rotates from 0 to 90 and from 90 to 180
int Rotation4=90; //Servo S4 AvanBracket rotation at rest is
at 90° so it rotates from 0 to 90 and from 90 to 180
int Rotation5=90; //Servo S5 Rotation Wrist at rest is at 90°
so it rotates from 0 to 90 and 90 to 180
int Rotation6=90; //Servo S6 Rotation Clamp at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
int Rotation7=90; //Servo S7 gripper socket at rest is at 90°
so it rotates from 0 to 90 and from 90 to 180
int rot1 = map(Rotation1,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos
int rot2 = map(Rotation2,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos
int rot3 = map(Rotation3,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos
int rot4 = map(Rotation4,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos
int rot5 = map(Rotation5,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos
int rot6 = map(Rotation6,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos
int rot7 = map(Rotation7,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos
int Selection=1;

int check=0;
void setup() {
  Serial.begin(9600); //Initialize the serial port of the IDE.
  delay(50); //Introduce a delay to settle the initialization
  myservo.begin(); //Initialize the myservo object.
  myservo.setPWMFreq(SERVO_FREQ); // Let's set the analog
frequency for servomotors
  delay(50); //Introduce a delay to settle the initialization
  error = ps2x.config_gamepad(PS2_CLK, PS2_CMD,
PS2_SEL, PS2_DAT, pressures, rumble);
  delay(500); //Introducing a delay to give time
  if (error ==0) {
    type = ps2x.readType();
    Serial.print("Controller type: ");
    Serial.println(type);  
}
  Serial.println("Arduino ready...");
  myservo.setPWM(ServoMotor1, 0, rot1); //Pilot the first
servo by sending it a 90° rotation
  delay(150); //Introduce a delay to settle the initialization
  myservo.setPWM(ServoMotor2, 0, rot2); //Pilot the second
servo by sending it a 90° rotation
  delay(150); //Introduce a delay to settle the initialization
  myservo.setPWM(ServoMotor3, 0, rot3); //Power the third
servo by sending it a 90° rotation
  delay(150); //Introduce a delay to settle the initialization
  myservo.setPWM(ServoMotor4, 0, rot4); //Power the fourth
servo by sending it a 90° rotation
  delay(150); //Introduce a delay to settle the initialization
  myservo.setPWM(ServoMotor5, 0, rot5); //Power the fifth
servo by sending it a 90° rotation
  delay(150); //Introduce a delay to settle the initialization
  myservo.setPWM(ServoMotor6, 0, rot6); //Power the sixth
servo by sending it a 90° rotation
  delay(150); //Introduce a delay to settle the initialization

  myservo.setPWM(ServoMotor7, 0, rot7); //Power the
seventh servo by sending it a 90° rotation
  delay(150); //Introduce a delay to settle the initialization
  Serial.println("Robot Arm ready...");
  delay(300);
}
void loop() {
    ps2x.read_gamepad(false, vibrate);
    if(ps2x.Button(PSB_TRIANGLE)){
      Serial.println("Key pressed: Triangle. Servo Selected:
Servo1 - Base");
      Selection=1;
    }
    if(ps2x.ButtonPressed(PSB_CIRCLE)){               
      Serial.println("Key pressed: Circle. Servo Selected:
Servo2 - Arm");
      Selection=2;
    }
    if(ps2x.NewButtonState(PSB_CROSS)){               
      Serial.println("Key pressed: X. Servo Selected: Servo3 -
ForwardBracket");
      Selection=3;
    }
    if(ps2x.ButtonReleased(PSB_SQUARE)){              
      Serial.println("Key pressed: Square. Servo Selected:
Servo4 - Rot. ForwardBracket");
      Selection=4;
}
    if(ps2x.Button(PSB_R1)){
      Serial.println("Key pressed: R1. Servo Selected: Servo5 -
Wrist Rotation");
      Selection=5;
    }
    if(ps2x.Button(PSB_R2)){

      Serial.println("Key pressed: R2. Servo Selected: Servo6 -
Caliper Rotation");
      Selection=6;
    }
    if(ps2x.Button(PSB_L1)){
      Serial.println("Key pressed: L1. Servo Selected: Servo7 -
Clamp");
      Selection=7;
    }
    if(check!=1) {
      if(ps2x.Button(PSB_START)) {
        check=1;
        Serial.println("Key pressed: START. All Servo in Resting
condition");
        Selection=8;
      }
    }
    switch (Selection) {
        case (8):
          Rotation1=90; //Servo S1 BASE at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180   
          Rotation2=90; //Servo S2 Arm at rest is at 90° so it
rotates from 0 to 90 and from 90 to 180
          Rotation3=90; //Servo S3 AvanBracket at rest is at
90° so it rotates from 0 to 90 and from 90 to 180
          Rotation4=90; //Servo S4 AvanBracket rotation at rest
is at 90° so it rotates from 0 to 90 and from 90 to 180
          Rotation5=90; //Servo S5 Rotation Wrist at rest is at
90° so it rotates from 0 to 90 and from 90 to 180
          Rotation6=90; //Servo S6 Rotation Pliers at rest is at
90° so it rotates from 0 to 90 and from 90 to 180
          Rotation7=90; //Servo S7 gripper socket at rest is at
90° so it rotates from 0 to 90 and from 90 to 180
          rot1 = map(Rotation1,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos

          rot2 = map(Rotation2,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos
          rot3 = map(Rotation3,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos
          rot4 = map(Rotation4,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos
          rot5 = map(Rotation5,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos
          rot6 = map(Rotation6,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos
          rot7 = map(Rotation7,0,180,SERVOMIN, SERVOMAX);
//Rimps rotation in degrees into values for servos     
          myservo.setPWM(ServoMotor1, 0, rot1); //Pilot the
first servo by sending it a 90° rotation
          delay(150); //Introduce a delay to settle the
initialization
          myservo.setPWM(ServoMotor2, 0, rot2); //Pilot the
second servo by sending it a 90° rotation
          delay(150); //Introduce a delay to settle the
initialization
          myservo.setPWM(ServoMotor3, 0, rot3); //Power the
third servo by sending it a 90° rotation
          delay(150); //Introduce a delay to settle the
initialization
          myservo.setPWM(ServoMotor4, 0, rot4); //Power the
fourth servo by sending it a 90° rotation
          delay(150); //Introduce a delay to settle the
initialization
          myservo.setPWM(ServoMotor5, 0, rot5); //Power the
fifth servo by sending it a 90° rotation
          delay(150); //Introduce a delay to settle the
initialization
          myservo.setPWM(ServoMotor6, 0, rot6); //Power the
sixth servo by sending it a 90° rotation
          delay(150); //Introduce a delay to settle the
initialization

          myservo.setPWM(ServoMotor7, 0, rot7); //Power the
seventh servo by sending it a 90° rotation
          delay(150); //Introduce a delay to settle the
initialization
          check=0;
          Selection=1;
          Serial.println("Robot Arm ready...");
        break;      
        case (1):
            if(ps2x.Button(PSB_PAD_RIGHT)){
              Serial.println("Rotate to the right... ");
              Rotation1=Rotation1+1;
              rot1 = map(Rotation1,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos
}
            if(ps2x.Button(PSB_PAD_LEFT)){
              Serial.println("Rotate left... ");
              Rotation1=Rotation1-1;
              rot1 = map(Rotation1,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos
}
            myservo.setPWM(ServoMotor1, 0, rot1); //Pilot the
first servo according to the angles arriving on the serial port
        break;
        case (2):
            if(ps2x.Button(PSB_PAD_UP)){
              Serial.println("Rotate up... ");
              Rotation2=Rotation2+1;
              rot2 = map(Rotation2,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos
}
            if(ps2x.Button(PSB_PAD_DOWN)){
              Serial.println("Rotate down... ");

              Rotation2=Rotation2-1;
              rot2 = map(Rotation2,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos
}
            myservo.setPWM(ServoMotor2, 0, rot2); //Pilot the
second servo according to the angles arriving on the serial
port
        break;
        case (3):
            if(ps2x.Button(PSB_PAD_UP)){
              Serial.println("Rotate up... ");
              Rotation3=Rotation3+1;
              rot3 = map(Rotation3,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos
}
            if(ps2x.Button(PSB_PAD_DOWN)){
              Serial.println("Rotate down... ");
              Rotation3=Rotation3-1;
              rot3 = map(Rotation3,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos
}
            myservo.setPWM(ServoMotor3, 0, rot3); //Pilot the
third servo according to the angles arriving on the serial
port
        break;
        cases (4):
            if(ps2x.Button(PSB_PAD_RIGHT)){
              Serial.println("Rotate to the right... ");
              Rotation4=Rotation4+1;
              rot4 = map(Rotation4,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos
}

            if(ps2x.Button(PSB_PAD_LEFT)){
              Serial.println("Rotate left... ");
              Rotation4=Rotation4-1;
              rot4 = map(Rotation4,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos
}
            myservo.setPWM(ServoMotor4, 0, rot4); //Pilot the
fourth servo according to the angles arriving on the serial
port
        break;
        case (5):
            if(ps2x.Button(PSB_PAD_RIGHT)){
              Serial.println("Rotate to the right... ");
              Rotation5=Rotation5+1;
              rot5 = map(Rotation5,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos
}
            if(ps2x.Button(PSB_PAD_LEFT)){
              Serial.println("Rotate left... ");
              Rotation5=Rotation5-1;
              rot5 = map(Rotation5,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos
}
            myservo.setPWM(ServoMotor5, 0, rot5); //Pilot the
fifth servo according to the angles arriving on the serial port
        break;
        houses (6):
            if(ps2x.Button(PSB_PAD_RIGHT)){
              Serial.println("Rotate to the right... ");
              Rotation6=Rotation6+1;
              rot6 = map(Rotation6,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos

}
            if(ps2x.Button(PSB_PAD_LEFT)){
              Serial.println("Rotate left... ");
              Rotation6=Rotation6-1;
              rot6 = map(Rotation6,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos
}
            myservo.setPWM(ServoMotor6, 0, rot6); //Pilot the
sixth servo according to the angles arriving on the serial
port
        break;
        case (7):
            if(ps2x.Button(PSB_PAD_RIGHT)){
              Serial.println("Rotate to the right... ");
              Rotation7=Rotation7+1;
              rot7 = map(Rotation7,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos
}
            if(ps2x.Button(PSB_PAD_LEFT)){
              Serial.println("Rotate left... ");
              Rotation7=Rotation7-1;
              rot7 = map(Rotation7,0,180,SERVOMIN,
SERVOMAX); //Rimps rotation in degrees into values for
servos
}
            myservo.setPWM(ServoMotor7, 0, rot7); //Pilot the
seventh servo according to the angles arriving on the serial
port
        break;
        }
  delay(10);  
  }

Analysis of Project 14 sketch - Robot arm
driven with PS2 Controller
At first glance it looks complicated, but in reality the
sketch consists only of control loops with "ifs" and
that's it! In fact, wanting to schematize in a trivial
way what our sketch does, we can represent it like
this:
Each line of the sketch is commented, so you will find
no difficulty in understanding what the individual
instructions do.
With this project ends Lesson 6, of course, as I always
say, my project proposals are only to tickle your

curiosity and should be seen not as end points, but as
starting points, so if you have any suggestions or if
you feel like improving what I have proposed, feel
free to do so and if you need any help contact me at
info@bemaker.org.
[For the video related to the project click here].
[For the sketch related to the project click here].

