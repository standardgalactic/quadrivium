
This is an electronic version of the print textbook. Due to electronic rights restrictions, some third party content 
may be suppressed. Editorial review has deemed that any suppressed content does not materially affect the overall 
learning experience. The publisher reserves the right to remove content from this title at any time if subsequent 
rights restrictions require it. For valuable information on pricing, previous editions, changes to
current editions, and alternate formats, please visit www.cengage.com/highered to search by
ISBN#, author, title, or keyword for materials in your areas of interest.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Introduction to the Theory of
omputatio
C
N
Third Edition
michael sipser
Australia • Brazil • Japan • Korea • Mexico • Singapore • Spain • United Kingdom • United States
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Introduction to the Theory of 
Computation, Third Edition
Michael Sipser
Editor-in-Chief: Marie Lee
Senior Product Manager:  
Alyssa Pratt
Associate Product Manager: 
Stephanie Lorenz
Content Project Manager:  
Jennifer Feltri-George
Art Director: GEX Publishing Services
Associate Marketing Manager: 
Shanna Shelton
Cover Designer: Wing-ip Ngan,  
Ink design, inc
Cover Image Credit: @Superstock
© 2013 Cengage Learning
ALL RIGHTS RESERVED. No part of this work covered by the copy-
right herein may be reproduced, transmitted, stored or used in any 
form or by any means graphic, electronic, or mechanical, including 
but not limited to photocopying, recording, scanning, digitizing, tap-
ing, Web distribution, information networks, or information storage 
and retrieval systems, except as permitted under Section 107 or 108 
of the 1976 United States Copyright Act, without the prior written 
permission of the publisher.States Copyright Act, without the prior 
written permission of the publisher.
Library of Congress Control Number: 2012938665
ISBN-13: 978-1-133-18779-0
ISBN-10: 1-133-18779-X
Cengage Learning
20 Channel Center Street
Boston, MA 02210
USA
Cengage Learning is a leading provider of customized learning solu-
tions with office locations around the globe, including Singapore, the 
United Kingdom, Australia, Mexico, Brazil, and Japan. Locate your 
local office at: international.cengage.com/region
Cengage Learning products are represented in Canada by Nelson 
Education, Ltd.
For your lifelong learning solutions, visit www.cengage.com
Cengage Learning reserves the right to revise this publication and 
make changes from time to time in its content without notice. 
The programs in this book are for instructional purposes only.
They have been tested with care, but are not guaranteed for any 
particular intent beyond educational purposes. The author and 
the publisher do not offer any warranties or representations, 
nor do they accept any liabilities with respect to the programs.
Printed in the United States of America  
1 2 3 4 5 6 7 8 16 15 14 13 12
For product information and technology assistance, contact us at  
Cengage Learning Customer & Sales Support,  
1-800-354-9706 
For permission to use material from this text or product, 
submit all requests online at cengage.com/permissions 
Further permissions questions can be emailed to 
permissionrequest@cengage.com
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

To Ina, Rachel, and Aaron
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

C O N T E N T S
Preface to the First Edition
xi
To the student . . . . . . . . . . . . . . . . . . . . . . . . . . .
xi
To the educator
. . . . . . . . . . . . . . . . . . . . . . . . . .
xii
The ﬁrst edition . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
Feedback to the author
. . . . . . . . . . . . . . . . . . . . . . xiii
Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . xiv
Preface to the Second Edition
xvii
Preface to the Third Edition
xxi
0
Introduction
1
0.1
Automata, Computability, and Complexity . . . . . . . . . . . . .
1
Complexity theory . . . . . . . . . . . . . . . . . . . . . . . . .
2
Computability theory . . . . . . . . . . . . . . . . . . . . . . .
3
Automata theory . . . . . . . . . . . . . . . . . . . . . . . . . .
3
0.2
Mathematical Notions and Terminology . . . . . . . . . . . . . .
3
Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
Sequences and tuples
. . . . . . . . . . . . . . . . . . . . . . .
6
Functions and relations . . . . . . . . . . . . . . . . . . . . . .
7
Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
Strings and languages . . . . . . . . . . . . . . . . . . . . . . .
13
Boolean logic . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
Summary of mathematical terms . . . . . . . . . . . . . . . . .
16
0.3
Deﬁnitions, Theorems, and Proofs . . . . . . . . . . . . . . . . .
17
Finding proofs . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
0.4
Types of Proof
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
Proof by construction . . . . . . . . . . . . . . . . . . . . . . .
21
Proof by contradiction . . . . . . . . . . . . . . . . . . . . . . .
21
Proof by induction . . . . . . . . . . . . . . . . . . . . . . . . .
22
Exercises, Problems, and Solutions . . . . . . . . . . . . . . . . . . .
25
v
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

vi
CONTENTS
Part One: Automata and Languages
29
1
Regular Languages
31
1.1
Finite Automata
. . . . . . . . . . . . . . . . . . . . . . . . . . .
31
Formal deﬁnition of a ﬁnite automaton
. . . . . . . . . . . . .
35
Examples of ﬁnite automata . . . . . . . . . . . . . . . . . . . .
37
Formal deﬁnition of computation
. . . . . . . . . . . . . . . .
40
Designing ﬁnite automata . . . . . . . . . . . . . . . . . . . . .
41
The regular operations
. . . . . . . . . . . . . . . . . . . . . .
44
1.2
Nondeterminism . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
Formal deﬁnition of a nondeterministic ﬁnite automaton . . . .
53
Equivalence of NFAs and DFAs
. . . . . . . . . . . . . . . . .
54
Closure under the regular operations . . . . . . . . . . . . . . .
58
1.3
Regular Expressions . . . . . . . . . . . . . . . . . . . . . . . . .
63
Formal deﬁnition of a regular expression
. . . . . . . . . . . .
64
Equivalence with ﬁnite automata . . . . . . . . . . . . . . . . .
66
1.4
Nonregular Languages . . . . . . . . . . . . . . . . . . . . . . . .
77
The pumping lemma for regular languages
. . . . . . . . . . .
77
Exercises, Problems, and Solutions . . . . . . . . . . . . . . . . . . .
82
2
Context-Free Languages
101
2.1
Context-Free Grammars . . . . . . . . . . . . . . . . . . . . . . . 102
Formal deﬁnition of a context-free grammar
. . . . . . . . . . 104
Examples of context-free grammars
. . . . . . . . . . . . . . . 105
Designing context-free grammars
. . . . . . . . . . . . . . . . 106
Ambiguity
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
Chomsky normal form
. . . . . . . . . . . . . . . . . . . . . . 108
2.2
Pushdown Automata . . . . . . . . . . . . . . . . . . . . . . . . . 111
Formal deﬁnition of a pushdown automaton . . . . . . . . . . . 113
Examples of pushdown automata . . . . . . . . . . . . . . . . . 114
Equivalence with context-free grammars . . . . . . . . . . . . . 117
2.3
Non-Context-Free Languages . . . . . . . . . . . . . . . . . . . . 125
The pumping lemma for context-free languages . . . . . . . . . 125
2.4
Deterministic Context-Free Languages . . . . . . . . . . . . . . . 130
Properties of DCFLs
. . . . . . . . . . . . . . . . . . . . . . . 133
Deterministic context-free grammars
. . . . . . . . . . . . . . 135
Relationship of DPDAs and DCFGs . . . . . . . . . . . . . . . 146
Parsing and LR(k) Grammars . . . . . . . . . . . . . . . . . . . 151
Exercises, Problems, and Solutions . . . . . . . . . . . . . . . . . . . 154
Part Two: Computability Theory
163
3
The Church–Turing Thesis
165
3.1
Turing Machines . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
Formal deﬁnition of a Turing machine . . . . . . . . . . . . . . 167
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

CONTENTS
vii
Examples of Turing machines . . . . . . . . . . . . . . . . . . . 170
3.2
Variants of Turing Machines . . . . . . . . . . . . . . . . . . . . . 176
Multitape Turing machines . . . . . . . . . . . . . . . . . . . . 176
Nondeterministic Turing machines . . . . . . . . . . . . . . . . 178
Enumerators . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
Equivalence with other models . . . . . . . . . . . . . . . . . . 181
3.3
The Deﬁnition of Algorithm
. . . . . . . . . . . . . . . . . . . . 182
Hilbert’s problems . . . . . . . . . . . . . . . . . . . . . . . . . 182
Terminology for describing Turing machines . . . . . . . . . . 184
Exercises, Problems, and Solutions . . . . . . . . . . . . . . . . . . . 187
4
Decidability
193
4.1
Decidable Languages . . . . . . . . . . . . . . . . . . . . . . . . . 194
Decidable problems concerning regular languages
. . . . . . . 194
Decidable problems concerning context-free languages . . . . . 198
4.2
Undecidability . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
The diagonalization method
. . . . . . . . . . . . . . . . . . . 202
An undecidable language
. . . . . . . . . . . . . . . . . . . . . 207
A Turing-unrecognizable language . . . . . . . . . . . . . . . . 209
Exercises, Problems, and Solutions . . . . . . . . . . . . . . . . . . . 210
5
Reducibility
215
5.1
Undecidable Problems from Language Theory
. . . . . . . . . . 216
Reductions via computation histories . . . . . . . . . . . . . . . 220
5.2
A Simple Undecidable Problem . . . . . . . . . . . . . . . . . . . 227
5.3
Mapping Reducibility
. . . . . . . . . . . . . . . . . . . . . . . . 234
Computable functions . . . . . . . . . . . . . . . . . . . . . . . 234
Formal deﬁnition of mapping reducibility . . . . . . . . . . . . 235
Exercises, Problems, and Solutions . . . . . . . . . . . . . . . . . . . 239
6
Advanced Topics in Computability Theory
245
6.1
The Recursion Theorem . . . . . . . . . . . . . . . . . . . . . . . 245
Self-reference
. . . . . . . . . . . . . . . . . . . . . . . . . . . 246
Terminology for the recursion theorem
. . . . . . . . . . . . . 249
Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
6.2
Decidability of logical theories
. . . . . . . . . . . . . . . . . . . 252
A decidable theory . . . . . . . . . . . . . . . . . . . . . . . . . 255
An undecidable theory . . . . . . . . . . . . . . . . . . . . . . . 257
6.3
Turing Reducibility . . . . . . . . . . . . . . . . . . . . . . . . . . 260
6.4
A Deﬁnition of Information . . . . . . . . . . . . . . . . . . . . . 261
Minimal length descriptions
. . . . . . . . . . . . . . . . . . . 262
Optimality of the deﬁnition . . . . . . . . . . . . . . . . . . . . 266
Incompressible strings and randomness
. . . . . . . . . . . . . 267
Exercises, Problems, and Solutions . . . . . . . . . . . . . . . . . . . 270
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

viii
CONTENTS
Part Three: Complexity Theory
273
7
Time Complexity
275
7.1
Measuring Complexity . . . . . . . . . . . . . . . . . . . . . . . . 275
Big-O and small-o notation . . . . . . . . . . . . . . . . . . . . 276
Analyzing algorithms
. . . . . . . . . . . . . . . . . . . . . . . 279
Complexity relationships among models . . . . . . . . . . . . . 282
7.2
The Class P . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284
Polynomial time . . . . . . . . . . . . . . . . . . . . . . . . . . 284
Examples of problems in P
. . . . . . . . . . . . . . . . . . . . 286
7.3
The Class NP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292
Examples of problems in NP . . . . . . . . . . . . . . . . . . . 295
The P versus NP question
. . . . . . . . . . . . . . . . . . . . 297
7.4
NP-completeness . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
Polynomial time reducibility . . . . . . . . . . . . . . . . . . . 300
Deﬁnition of NP-completeness . . . . . . . . . . . . . . . . . . 304
The Cook–Levin Theorem . . . . . . . . . . . . . . . . . . . . 304
7.5
Additional NP-complete Problems . . . . . . . . . . . . . . . . . 311
The vertex cover problem . . . . . . . . . . . . . . . . . . . . . 312
The Hamiltonian path problem
. . . . . . . . . . . . . . . . . 314
The subset sum problem
. . . . . . . . . . . . . . . . . . . . . 319
Exercises, Problems, and Solutions . . . . . . . . . . . . . . . . . . . 322
8
Space Complexity
331
8.1
Savitch’s Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . 333
8.2
The Class PSPACE
. . . . . . . . . . . . . . . . . . . . . . . . . 336
8.3
PSPACE-completeness
. . . . . . . . . . . . . . . . . . . . . . . 337
The TQBF problem . . . . . . . . . . . . . . . . . . . . . . . . 338
Winning strategies for games . . . . . . . . . . . . . . . . . . . 341
Generalized geography . . . . . . . . . . . . . . . . . . . . . . 343
8.4
The Classes L and NL . . . . . . . . . . . . . . . . . . . . . . . . 348
8.5
NL-completeness
. . . . . . . . . . . . . . . . . . . . . . . . . . 351
Searching in graphs . . . . . . . . . . . . . . . . . . . . . . . . 353
8.6
NL equals coNL . . . . . . . . . . . . . . . . . . . . . . . . . . . 354
Exercises, Problems, and Solutions . . . . . . . . . . . . . . . . . . . 356
9
Intractability
363
9.1
Hierarchy Theorems . . . . . . . . . . . . . . . . . . . . . . . . . 364
Exponential space completeness
. . . . . . . . . . . . . . . . . 371
9.2
Relativization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 376
Limits of the diagonalization method
. . . . . . . . . . . . . . 377
9.3
Circuit Complexity . . . . . . . . . . . . . . . . . . . . . . . . . . 379
Exercises, Problems, and Solutions . . . . . . . . . . . . . . . . . . . 388
10 Advanced Topics in Complexity Theory
393
10.1 Approximation Algorithms
. . . . . . . . . . . . . . . . . . . . . 393
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

CONTENTS
ix
10.2 Probabilistic Algorithms . . . . . . . . . . . . . . . . . . . . . . . 396
The class BPP . . . . . . . . . . . . . . . . . . . . . . . . . . . 396
Primality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399
Read-once branching programs . . . . . . . . . . . . . . . . . . 404
10.3 Alternation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
Alternating time and space
. . . . . . . . . . . . . . . . . . . . 410
The Polynomial time hierarchy . . . . . . . . . . . . . . . . . . 414
10.4 Interactive Proof Systems . . . . . . . . . . . . . . . . . . . . . . 415
Graph nonisomorphism . . . . . . . . . . . . . . . . . . . . . . 415
Deﬁnition of the model . . . . . . . . . . . . . . . . . . . . . . 416
IP = PSPACE
. . . . . . . . . . . . . . . . . . . . . . . . . . . 418
10.5 Parallel Computation
. . . . . . . . . . . . . . . . . . . . . . . . 427
Uniform Boolean circuits . . . . . . . . . . . . . . . . . . . . . 428
The class NC
. . . . . . . . . . . . . . . . . . . . . . . . . . . 430
P-completeness
. . . . . . . . . . . . . . . . . . . . . . . . . . 432
10.6 Cryptography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
Secret keys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
Public-key cryptosystems . . . . . . . . . . . . . . . . . . . . . 435
One-way functions . . . . . . . . . . . . . . . . . . . . . . . . . 435
Trapdoor functions
. . . . . . . . . . . . . . . . . . . . . . . . 437
Exercises, Problems, and Solutions . . . . . . . . . . . . . . . . . . . 439
Selected Bibliography
443
Index
448
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

P R E F A C E T O T H E
F I R S T E D I T I O N
TO THE STUDENT
Welcome!
You are about to embark on the study of a fascinating and important subject:
the theory of computation. It comprises the fundamental mathematical proper-
ties of computer hardware, software, and certain applications thereof. In study-
ing this subject, we seek to determine what can and cannot be computed, how
quickly, with how much memory, and on which type of computational model.
The subject has obvious connections with engineering practice, and, as in many
sciences, it also has purely philosophical aspects.
I know that many of you are looking forward to studying this material but
some may not be here out of choice. You may want to obtain a degree in com-
puter science or engineering, and a course in theory is required—God knows
why. After all, isn’t theory arcane, boring, and worst of all, irrelevant?
To see that theory is neither arcane nor boring, but instead quite understand-
able and even interesting, read on. Theoretical computer science does have
many fascinating big ideas, but it also has many small and sometimes dull details
that can be tiresome. Learning any new subject is hard work, but it becomes
easier and more enjoyable if the subject is properly presented. My primary ob-
jective in writing this book is to expose you to the genuinely exciting aspects of
computer theory, without getting bogged down in the drudgery. Of course, the
only way to determine whether theory interests you is to try learning it.
xi
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

xii
PREFACE TO THE FIRST EDITION
Theory is relevant to practice. It provides conceptual tools that practition-
ers use in computer engineering. Designing a new programming language for a
specialized application? What you learned about grammars in this course comes
in handy. Dealing with string searching and pattern matching? Remember ﬁnite
automata and regular expressions. Confronted with a problem that seems to re-
quire more computer time than you can afford? Think back to what you learned
about NP-completeness. Various application areas, such as modern cryptographic
protocols, rely on theoretical principles that you will learn here.
Theory also is relevant to you because it shows you a new, simpler, and more
elegant side of computers, which we normally consider to be complicated ma-
chines. The best computer designs and applications are conceived with elegance
in mind. A theoretical course can heighten your aesthetic sense and help you
build more beautiful systems.
Finally, theory is good for you because studying it expands your mind. Com-
puter technology changes quickly. Speciﬁc technical knowledge, though useful
today, becomes outdated in just a few years. Consider instead the abilities to
think, to express yourself clearly and precisely, to solve problems, and to know
when you haven’t solved a problem. These abilities have lasting value. Studying
theory trains you in these areas.
Practical considerations aside, nearly everyone working with computers is cu-
rious about these amazing creations, their capabilities, and their limitations. A
whole new branch of mathematics has grown up in the past 30 years to answer
certain basic questions. Here’s a big one that remains unsolved: If I give you a
large number—say, with 500 digits—can you ﬁnd its factors (the numbers that
divide it evenly) in a reasonable amount of time? Even using a supercomputer, no
one presently knows how to do that in all cases within the lifetime of the universe!
The factoring problem is connected to certain secret codes in modern cryptosys-
tems. Find a fast way to factor, and fame is yours!
TO THE EDUCATOR
This book is intended as an upper-level undergraduate or introductory gradu-
ate text in computer science theory. It contains a mathematical treatment of
the subject, designed around theorems and proofs. I have made some effort to
accommodate students with little prior experience in proving theorems, though
more experienced students will have an easier time.
My primary goal in presenting the material has been to make it clear and
interesting. In so doing, I have emphasized intuition and “the big picture” in the
subject over some lower level details.
For example, even though I present the method of proof by induction in
Chapter 0 along with other mathematical preliminaries, it doesn’t play an im-
portant role subsequently. Generally, I do not present the usual induction proofs
of the correctness of various constructions concerning automata. If presented
clearly, these constructions convince and do not need further argument. An in-
duction may confuse rather than enlighten because induction itself is a rather
sophisticated technique that many ﬁnd mysterious. Belaboring the obvious with
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PREFACE TO THE FIRST EDITION
xiii
an induction risks teaching students that a mathematical proof is a formal ma-
nipulation instead of teaching them what is and what is not a cogent argument.
A second example occurs in Parts Two and Three, where I describe algorithms
in prose instead of pseudocode. I don’t spend much time programming Turing
machines (or any other formal model). Students today come with a program-
ming background and ﬁnd the Church–Turing thesis to be self-evident. Hence
I don’t present lengthy simulations of one model by another to establish their
equivalence.
Besides giving extra intuition and suppressing some details, I give what might
be called a classical presentation of the subject material. Most theorists will ﬁnd
the choice of material, terminology, and order of presentation consistent with
that of other widely used textbooks. I have introduced original terminology in
only a few places, when I found the standard terminology particularly obscure
or confusing. For example, I introduce the term mapping reducibility instead of
many–one reducibility.
Practice through solving problems is essential to learning any mathemati-
cal subject. In this book, the problems are organized into two main categories
called Exercises and Problems. The Exercises review deﬁnitions and concepts.
The Problems require some ingenuity. Problems marked with a star are more
difﬁcult. I have tried to make the Exercises and Problems interesting challenges.
THE FIRST EDITION
Introduction to the Theory of Computation ﬁrst appeared as a Preliminary Edition
in paperback. The ﬁrst edition differs from the Preliminary Edition in several
substantial ways. The ﬁnal three chapters are new: Chapter 8 on space complex-
ity; Chapter 9 on provable intractability; and Chapter 10 on advanced topics in
complexity theory. Chapter 6 was expanded to include several advanced topics
in computability theory. Other chapters were improved through the inclusion
of additional examples and exercises.
Comments from instructors and students who used the Preliminary Edition
were helpful in polishing Chapters 0–7. Of course, the errors they reported have
been corrected in this edition.
Chapters 6 and 10 give a survey of several more advanced topics in com-
putability and complexity theories. They are not intended to comprise a cohesive
unit in the way that the remaining chapters are. These chapters are included to
allow the instructor to select optional topics that may be of interest to the serious
student. The topics themselves range widely. Some, such as Turing reducibility
and alternation, are direct extensions of other concepts in the book. Others, such
as decidable logical theories and cryptography, are brief introductions to large ﬁelds.
FEEDBACK TO THE AUTHOR
The internet provides new opportunities for interaction between authors and
readers. I have received much e-mail offering suggestions, praise, and criticism,
and reporting errors for the Preliminary Edition. Please continue to correspond!
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

xiv
PREFACE TO THE FIRST EDITION
I try to respond to each message personally, as time permits. The e-mail address
for correspondence related to this book is
sipserbook@math.mit.edu .
A web site that contains a list of errata is maintained. Other material may be
added to that site to assist instructors and students. Let me know what you
would like to see there. The location for that site is
http://math.mit.edu/~sipser/book.html .
ACKNOWLEDGMENTS
I could not have written this book without the help of many friends, colleagues,
and my family.
I wish to thank the teachers who helped shape my scientiﬁc viewpoint and
educational style. Five of them stand out. My thesis advisor, Manuel Blum, is
due a special note for his unique way of inspiring students through clarity of
thought, enthusiasm, and caring. He is a model for me and for many others.
I am grateful to Richard Karp for introducing me to complexity theory, to John
Addison for teaching me logic and assigning those wonderful homework sets,
to Juris Hartmanis for introducing me to the theory of computation, and to my
father for introducing me to mathematics, computers, and the art of teaching.
This book grew out of notes from a course that I have taught at MIT for
the past 15 years. Students in my classes took these notes from my lectures. I
hope they will forgive me for not listing them all. My teaching assistants over
the years—Avrim Blum, Thang Bui, Benny Chor, Andrew Chou, Stavros Cos-
madakis, Aditi Dhagat, Wayne Goddard, Parry Husbands, Dina Kravets, Jakov
Kuˇcan, Brian O’Neill, Ioana Popescu, and Alex Russell—helped me to edit and
expand these notes and provided some of the homework problems.
Nearly three years ago, Tom Leighton persuaded me to write a textbook on
the theory of computation. I had been thinking of doing so for some time, but
it took Tom’s persuasion to turn theory into practice. I appreciate his generous
advice on book writing and on many other things.
I wish to thank Eric Bach, Peter Beebee, Cris Calude, Marek Chrobak, Anna
Chefter, Guang-Ien Cheng, Elias Dahlhaus, Michael Fischer, Steve Fisk, Lance
Fortnow, Henry J. Friedman, Jack Fu, Seymour Ginsburg, Oded Goldreich,
Brian Grossman, David Harel, Micha Hofri, Dung T. Huynh, Neil Jones, H.
Chad Lane, Kevin Lin, Michael Loui, Silvio Micali, Tadao Murata, Chris-
tos Papadimitriou, Vaughan Pratt, Daniel Rosenband, Brian Scassellati, Ashish
Sharma, Nir Shavit, Alexander Shen, Ilya Shlyakhter, Matt Stallmann, Perry
Susskind, Y. C. Tay, Joseph Traub, Osamu Watanabe, Peter Widmayer, David
Williamson, Derick Wood, and Charles Yang for comments, suggestions, and
assistance as the writing progressed.
The following people provided additional comments that have improved
this book: Isam M. Abdelhameed, Eric Allender, Shay Artzi, Michelle Ather-
ton, Rolfe Blodgett, Al Briggs, Brian E. Brooks, Jonathan Buss, Jin Yi Cai,
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PREFACE TO THE FIRST EDITION
xv
Steve Chapel, David Chow, Michael Ehrlich, Yaakov Eisenberg, Farzan Fallah,
Shaun Flisakowski, Hjalmtyr Hafsteinsson, C. R. Hale, Maurice Herlihy, Vegard
Holmedahl, Sandy Irani, Kevin Jiang, Rhys Price Jones, James M. Jowdy, David
M. Martin Jr., Manrique Mata-Montero, Ryota Matsuura, Thomas Minka,
Farooq Mohammed, Tadao Murata, Jason Murray, Hideo Nagahashi, Kazuo
Ohta, Constantine Papageorgiou, Joseph Raj, Rick Regan, Rhonda A. Reumann,
Michael Rintzler, Arnold L. Rosenberg, Larry Roske, Max Rozenoer, Walter L.
Ruzzo, Sanatan Sahgal, Leonard Schulman, Steve Seiden, Joel Seiferas, Ambuj
Singh, David J. Stucki, Jayram S. Thathachar, H. Venkateswaran, Tom Whaley,
Christopher Van Wyk, Kyle Young, and Kyoung Hwan Yun.
Robert Sloan used an early version of the manuscript for this book in a class
that he taught and provided me with invaluable commentary and ideas from
his experience with it. Mark Herschberg, Kazuo Ohta, and Latanya Sweeney
read over parts of the manuscript and suggested extensive improvements. Shaﬁ
Goldwasser helped me with material in Chapter 10.
I received expert technical support from William Baxter at Superscript, who
wrote the LATEX macro package implementing the interior design, and from
Larry Nolan at the MIT mathematics department, who keeps things running.
It has been a pleasure to work with the folks at PWS Publishing in creat-
ing the ﬁnal product. I mention Michael Sugarman, David Dietz, Elise Kaiser,
Monique Calello, Susan Garland and Tanja Brull because I have had the most
contact with them, but I know that many others have been involved, too. Thanks
to Jerry Moore for the copy editing, to Diane Levy for the cover design, and to
Catherine Hawkes for the interior design.
I am grateful to the National Science Foundation for support provided under
grant CCR-9503322.
My father, Kenneth Sipser, and sister, Laura Sipser, converted the book di-
agrams into electronic form. My other sister, Karen Fisch, saved us in various
computer emergencies, and my mother, Justine Sipser, helped out with motherly
advice. I thank them for contributing under difﬁcult circumstances, including
insane deadlines and recalcitrant software.
Finally, my love goes to my wife, Ina, and my daughter, Rachel. Thanks for
putting up with all of this.
Cambridge, Massachusetts
Michael Sipser
October, 1996
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

P R E F A C E T O T H E
S E C O N D E D I T I O N
Judging from the email communications that I’ve received from so many of you,
the biggest deﬁciency of the ﬁrst edition is that it provides no sample solutions
to any of the problems. So here they are. Every chapter now contains a new
Selected Solutions section that gives answers to a representative cross-section of
that chapter’s exercises and problems. To make up for the loss of the solved
problems as interesting homework challenges, I’ve also added a variety of new
problems. Instructors may request an Instructor’s Manual that contains addi-
tional solutions by contacting the sales representative for their region designated
at www.course.com .
A number of readers would have liked more coverage of certain “standard”
topics, particularly the Myhill–Nerode Theorem and Rice’s Theorem. I’ve par-
tially accommodated these readers by developing these topics in the solved prob-
lems. I did not include the Myhill–Nerode Theorem in the main body of the text
because I believe that this course should provide only an introduction to ﬁnite
automata and not a deep investigation. In my view, the role of ﬁnite automata
here is for students to explore a simple formal model of computation as a prelude
to more powerful models, and to provide convenient examples for subsequent
topics. Of course, some people would prefer a more thorough treatment, while
others feel that I ought to omit all references to (or at least dependence on) ﬁnite
automata. I did not include Rice’s Theorem in the main body of the text because,
though it can be a useful “tool” for proving undecidability, some students might
xvii
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

xviii
PREFACE TO THE SECOND EDITION
use it mechanically without really understanding what is going on. Using reduc-
tions instead, for proving undecidability, gives more valuable preparation for the
reductions that appear in complexity theory.
I am indebted to my teaching assistants—Ilya Baran, Sergi Elizalde, Rui Fan,
Jonathan Feldman, Venkatesan Guruswami, Prahladh Harsha, Christos Kapout-
sis, Julia Khodor, Adam Klivans, Kevin Matulef, Ioana Popescu, April Rasala,
Sofya Raskhodnikova, and Iuliu Vasilescu—who helped me to craft some of
the new problems and solutions. Ching Law, Edmond Kayi Lee, and Zulﬁkar
Ramzan also contributed to the solutions. I thank Victor Shoup for coming up
with a simple way to repair the gap in the analysis of the probabilistic primality
algorithm that appears in the ﬁrst edition.
I appreciate the efforts of the people at Course Technology in pushing me
and the other parts of this project along, especially Alyssa Pratt and Aimee
Poirier.
Many thanks to Gerald Eisman, Weizhen Mao, Rupak Majumdar,
Chris Umans, and Christopher Wilson for their reviews. I’m indebted to Jerry
Moore for his superb job copy editing and to Laura Segel of ByteGraphics
(lauras@bytegraphics.com) for her beautiful rendition of the ﬁgures.
The volume of email I’ve received has been more than I expected. Hearing
from so many of you from so many places has been absolutely delightful, and I’ve
tried to respond to all eventually—my apologies for those I missed. I’ve listed
here the people who made suggestions that speciﬁcally affected this edition, but
I thank everyone for their correspondence:
Luca Aceto, Arash Afkanpour, Rostom Aghanian, Eric Allender, Karun Bak-
shi, Brad Ballinger, Ray Bartkus, Louis Barton, Arnold Beckmann, Mihir Bel-
lare, Kevin Trent Bergeson, Matthew Berman, Rajesh Bhatt, Somenath Biswas,
Lenore Blum, Mauro A. Bonatti, Paul Bondin, Nicholas Bone, Ian Bratt, Gene
Browder, Doug Burke, Sam Buss, Vladimir Bychkovsky, Bruce Carneal, Soma
Chaudhuri, Rong-Jaye Chen, Samir Chopra, Benny Chor, John Clausen, Alli-
son Coates, Anne Condon, Jeffrey Considine, John J. Crashell, Claude Crepeau,
Shaun Cutts, Susheel M. Daswani, Geoff Davis, Scott Dexter, Peter Drake,
Jeff Edmonds, Yaakov Eisenberg, Kurtcebe Eroglu, Georg Essl, Alexander T.
Fader, Farzan Fallah, Faith Fich, Joseph E. Fitzgerald, Perry Fizzano, David
Ford, Jeannie Fromer, Kevin Fu, Atsushi Fujioka, Michel Galley, K. Gane-
san, Simson Garﬁnkel, Travis Gebhardt, Peymann Gohari, Ganesh Gopalakr-
ishnan, Steven Greenberg, Larry Grifﬁth, Jerry Grossman, Rudolf de Haan,
Michael Halper, Nick Harvey, Mack Hendricks, Laurie Hiyakumoto, Steve
Hockema, Michael Hoehle, Shahadat Hossain, Dave Isecke, Ghaith Issa, Raj D.
Iyer, Christian Jacobi, Thomas Janzen, Mike D. Jones, Max Kanovitch, Aaron
Kaufman, Roger Khazan, Sarfraz Khurshid, Kevin Killourhy, Seungjoo Kim,
Victor Kuncak, Kanata Kuroda, Thomas Lasko, Suk Y. Lee, Edward D. Leg-
enski, Li-Wei Lehman, Kong Lei, Zsolt Lengvarszky, Jeffrey Levetin, Baekjun
Lim, Karen Livescu, Stephen Louie, TzerHung Low, Wolfgang Maass, Arash
Madani, Michael Manapat, Wojciech Marchewka, David M. Martin Jr., Anders
Martinson, Lyle McGeoch, Alberto Medina, Kurt Mehlhorn, Nihar Mehta, Al-
bert R. Meyer, Thomas Minka, Mariya Minkova, Daichi Mizuguchi, G. Allen
Morris III, Damon Mosk-Aoyama, Xiaolong Mou, Paul Muir, German Muller,
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PREFACE TO THE SECOND EDITION
xix
Donald Nelson, Gabriel Nivasch, Mary Obelnicki, Kazuo Ohta, Thomas M.
Oleson, Jr., Curtis Oliver, Owen Ozier, Rene Peralta, Alexander Perlis, Holger
Petersen, Detlef Plump, Robert Prince, David Pritchard, Bina Reed, Nicholas
Riley, Ronald Rivest, Robert Robinson, Christi Rockwell, Phil Rogaway, Max
Rozenoer, John Rupf, Teodor Rus, Larry Ruzzo, Brian Sanders, Cem Say, Kim
Schioett, Joel Seiferas, Joao Carlos Setubal, Geoff Lee Seyon, Mark Skandera,
Bob Sloan, Geoff Smith, Marc L. Smith, Stephen Smith, Alex C. Snoeren, Guy
St-Denis, Larry Stockmeyer, Radu Stoleru, David Stucki, Hisham M. Sueyllam,
Kenneth Tam, Elizabeth Thompson, Michel Toulouse, Eric Tria, Chittaranjan
Tripathy, Dan Trubow, Hiroki Ueda, Giora Unger, Kurt L. Van Etten, Jesir
Vargas, Bienvenido Velez-Rivera, Kobus Vos, Alex Vrenios, Sven Waibel, Marc
Waldman, Tom Whaley, Anthony Widjaja, Sean Williams, Joseph N. Wilson,
Chris Van Wyk, Guangming Xing, Vee Voon Yee, Cheng Yongxi, Neal Young,
Timothy Yuen, Kyle Yung, Jinghua Zhang, Lilla Zollei.
I thank Suzanne Balik, Matthew Kane, Kurt L. Van Etten, Nancy Lynch,
Gregory Roberts, and Cem Say for pointing out errata in the ﬁrst printing.
Most of all, I thank my family—Ina, Rachel, and Aaron—for their patience,
understanding, and love as I sat for endless hours here in front of my computer
screen.
Cambridge, Massachusetts
Michael Sipser
December, 2004
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

P R E F A C E T O T H E
T H I R D E D I T I O N
The third edition contains an entirely new section on deterministic context-free
languages. I chose this topic for several reasons. First of all, it ﬁlls an obvious
gap in my previous treatment of the theory of automata and languages. The
older editions introduced ﬁnite automata and Turing machines in deterministic
and nondeterministic variants, but covered only the nondeterministic variant of
pushdown automata. Adding a discussion of deterministic pushdown automata
provides a missing piece of the puzzle.
Second, the theory of deterministic context-free grammars is the basis for
LR(k) grammars, an important and nontrivial application of automata theory in
programming languages and compiler design. This application brings together
several key concepts, including the equivalence of deterministic and nondeter-
ministic ﬁnite automata, and the conversions between context-free grammars
and pushdown automata, to yield an efﬁcient and beautiful method for parsing.
Here we have a concrete interplay between theory and practice.
Last, this topic seems underserved in existing theory textbooks, considering
its importance as a genuine application of automata theory. I studied LR(k) gram-
mars years ago but without fully understanding how they work, and without
seeing how nicely they ﬁt into the theory of deterministic context-free languages.
My goal in writing this section is to give an intuitive yet rigorous introduction
to this area for theorists as well as practitioners, and thereby contribute to its
broader appreciation. One note of caution, however: Some of the material in
this section is rather challenging, so an instructor in a basic ﬁrst theory course
xxi
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

xxii
PREFACE TO THE THIRD EDITION
may prefer to designate it as supplementary reading. Later chapters do not de-
pend on this material.
Many people helped directly or indirectly in developing this edition. I’m in-
debted to reviewers Christos Kapoutsis and Cem Say who read a draft of the new
section and provided valuable feedback. Several individuals at Cengage Learning
assisted with the production, notably Alyssa Pratt and Jennifer Feltri-George.
Suzanne Huizenga copyedited the text and Laura Segel of ByteGraphics created
the new ﬁgures and modiﬁed some of the older ﬁgures.
I wish to thank my teaching assistants at MIT, Victor Chen, Andy Drucker,
Michael Forbes, Elena Grigorescu, Brendan Juba, Christos Kapoutsis, Jon Kel-
ner, Swastik Kopparty, Kevin Matulef, Amanda Redlich, Zack Remscrim, Ben
Rossman, Shubhangi Saraf, and Oren Weimann. Each of them helped me by
discussing new problems and their solutions, and by providing insight into how
well our students understood the course content. I’ve greatly enjoyed working
with such talented and enthusiastic young people.
It has been gratifying to receive email from around the globe. Thanks to all
for your suggestions, questions, and ideas. Here is a list of those correspondents
whose comments affected this edition:
Djihed Aﬁﬁ, Steve Aldrich, Eirik Bakke, Suzanne Balik, Victor Bandur, Paul
Beame, Elazar Birnbaum, Goutam Biswas, Rob Bittner, Marina Blanton, Rod-
ney Bliss, Promita Chakraborty, Lewis Collier, Jonathan Deber, Simon Dex-
ter, Matt Diephouse, Peter Dillinger, Peter Drake, Zhidian Du, Peter Fe-
jer, Margaret Fleck, Atsushi Fujioka, Valerio Genovese, Evangelos Georgiadis,
Joshua Grochow, Jerry Grossman, Andreas Guelzow, Hjalmtyr Hafsteinsson,
Arthur Hall III, Cihat Imamoglu, Chinawat Isradisaikul, Kayla Jacobs, Flem-
ming Jensen, Barbara Kaiser, Matthew Kane, Christos Kapoutsis, Ali Durlov
Khan, Edwin Sze Lun Khoo, Yongwook Kim, Akash Kumar, Eleazar Leal, Zsolt
Lengvarszky, Cheng-Chung Li, Xiangdong Liang, Vladimir Lifschitz, Ryan
Lortie, Jonathan Low, Nancy Lynch, Alexis Maciel, Kevin Matulef, Nelson
Max, Hans-Rudolf Metz, Mladen Mikˆsa, Sara Miner More, Rajagopal Nagara-
jan, Marvin Nakayama, Jonas Nyrup, Gregory Roberts, Ryan Romero, Santhosh
Samarthyam, Cem Say, Joel Seiferas, John Sieg, Marc Smith, John Steinberger,
Nuri Tas¸demir, Tamir Tassa, Mark Testa, Jesse Tjang, John Trammell, Hi-
roki Ueda, Jeroen Vaelen, Kurt L. Van Etten, Guillermo V´azquez, Phanisekhar
Botlaguduru Venkata, Benjamin Bing-Yi Wang, Lutz Warnke, David Warren,
Thomas Watson, Joseph Wilson, David Wittenberg, Brian Wongchaowart, Kis-
han Yerubandi, Dai Yi.
Above all, I thank my family—my wife, Ina, and our children, Rachel and
Aaron. Time is ﬁnite and ﬂeeting. Your love is everything.
Cambridge, Massachusetts
Michael Sipser
April, 2012
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

0
I N T R O D U C T I O N
We begin with an overview of those areas in the theory of computation that
we present in this course. Following that, you’ll have a chance to learn and/or
review some mathematical concepts that you will need later.
0.1
AUTOMATA, COMPUTABILITY, AND COMPLEXITY
This book focuses on three traditionally central areas of the theory of computa-
tion: automata, computability, and complexity. They are linked by the question:
What are the fundamental capabilities and limitations of computers?
This question goes back to the 1930s when mathematical logicians ﬁrst began
to explore the meaning of computation. Technological advances since that time
have greatly increased our ability to compute and have brought this question out
of the realm of theory into the world of practical concern.
In each of the three areas—automata, computability, and complexity—this
question is interpreted differently, and the answers vary according to the in-
terpretation. Following this introductory chapter, we explore each area in a
1
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2
CHAPTER 0 / INTRODUCTION
separate part of this book. Here, we introduce these parts in reverse order be-
cause by starting from the end you can better understand the reason for the
beginning.
COMPLEXITY THEORY
Computer problems come in different varieties; some are easy, and some are
hard. For example, the sorting problem is an easy one. Say that you need to
arrange a list of numbers in ascending order. Even a small computer can sort
a million numbers rather quickly. Compare that to a scheduling problem. Say
that you must ﬁnd a schedule of classes for the entire university to satisfy some
reasonable constraints, such as that no two classes take place in the same room
at the same time. The scheduling problem seems to be much harder than the
sorting problem. If you have just a thousand classes, ﬁnding the best schedule
may require centuries, even with a supercomputer.
What makes some problems computationally hard and others easy?
This is the central question of complexity theory. Remarkably, we don’t know
the answer to it, though it has been intensively researched for over 40 years.
Later, we explore this fascinating question and some of its ramiﬁcations.
In one important achievement of complexity theory thus far, researchers have
discovered an elegant scheme for classifying problems according to their com-
putational difﬁculty. It is analogous to the periodic table for classifying elements
according to their chemical properties. Using this scheme, we can demonstrate
a method for giving evidence that certain problems are computationally hard,
even if we are unable to prove that they are.
You have several options when you confront a problem that appears to be
computationally hard. First, by understanding which aspect of the problem is at
the root of the difﬁculty, you may be able to alter it so that the problem is more
easily solvable. Second, you may be able to settle for less than a perfect solution
to the problem. In certain cases, ﬁnding solutions that only approximate the
perfect one is relatively easy. Third, some problems are hard only in the worst
case situation, but easy most of the time. Depending on the application, you may
be satisﬁed with a procedure that occasionally is slow but usually runs quickly.
Finally, you may consider alternative types of computation, such as randomized
computation, that can speed up certain tasks.
One applied area that has been affected directly by complexity theory is the
ancient ﬁeld of cryptography. In most ﬁelds, an easy computational problem is
preferable to a hard one because easy ones are cheaper to solve. Cryptography
is unusual because it speciﬁcally requires computational problems that are hard,
rather than easy. Secret codes should be hard to break without the secret key
or password. Complexity theory has pointed cryptographers in the direction of
computationally hard problems around which they have designed revolutionary
new codes.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

0.2
MATHEMATICAL NOTIONS AND TERMINOLOGY
3
COMPUTABILITY THEORY
During the ﬁrst half of the twentieth century, mathematicians such as Kurt
G¨odel, Alan Turing, and Alonzo Church discovered that certain basic problems
cannot be solved by computers. One example of this phenomenon is the prob-
lem of determining whether a mathematical statement is true or false. This task
is the bread and butter of mathematicians. It seems like a natural for solution
by computer because it lies strictly within the realm of mathematics. But no
computer algorithm can perform this task.
Among the consequences of this profound result was the development of ideas
concerning theoretical models of computers that eventually would help lead to
the construction of actual computers.
The theories of computability and complexity are closely related. In com-
plexity theory, the objective is to classify problems as easy ones and hard ones;
whereas in computability theory, the classiﬁcation of problems is by those that
are solvable and those that are not. Computability theory introduces several of
the concepts used in complexity theory.
AUTOMATA THEORY
Automata theory deals with the deﬁnitions and properties of mathematical mod-
els of computation. These models play a role in several applied areas of computer
science. One model, called the ﬁnite automaton, is used in text processing, com-
pilers, and hardware design. Another model, called the context-free grammar, is
used in programming languages and artiﬁcial intelligence.
Automata theory is an excellent place to begin the study of the theory of
computation. The theories of computability and complexity require a precise
deﬁnition of a computer. Automata theory allows practice with formal deﬁnitions
of computation as it introduces concepts relevant to other nontheoretical areas
of computer science.
0.2
MATHEMATICAL NOTIONS AND TERMINOLOGY
As in any mathematical subject, we begin with a discussion of the basic mathe-
matical objects, tools, and notation that we expect to use.
SETS
A set is a group of objects represented as a unit. Sets may contain any type of
object, including numbers, symbols, and even other sets. The objects in a set are
called its elements or members. Sets may be described formally in several ways.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

4
CHAPTER 0 / INTRODUCTION
One way is by listing a set’s elements inside braces. Thus the set
S = {7, 21, 57}
contains the elements 7, 21, and 57. The symbols ∈and ̸∈denote set member-
ship and nonmembership. We write 7 ∈{7, 21, 57} and 8 ̸∈{7, 21, 57}. For two
sets A and B, we say that A is a subset of B, written A ⊆B, if every member of
A also is a member of B. We say that A is a proper subset of B, written A ⊊B,
if A is a subset of B and not equal to B.
The order of describing a set doesn’t matter, nor does repetition of its mem-
bers. We get the same set S by writing {57, 7, 7, 7, 21}. If we do want to take the
number of occurrences of members into account, we call the group a multiset
instead of a set. Thus {7} and {7, 7} are different as multisets but identical as
sets. An inﬁnite set contains inﬁnitely many elements. We cannot write a list of
all the elements of an inﬁnite set, so we sometimes use the “. . .” notation to mean
“continue the sequence forever.” Thus we write the set of natural numbers N
as
{1, 2, 3, . . .}.
The set of integers Z is written as
{ . . . , −2, −1, 0, 1, 2, . . .}.
The set with zero members is called the empty set and is written ∅. A set with
one member is sometimes called a singleton set, and a set with two members is
called an unordered pair.
When we want to describe a set containing elements according to some rule,
we write {n| rule about n}. Thus {n| n = m2 for some m ∈N} means the set of
perfect squares.
If we have two sets A and B, the union of A and B, written A∪B, is the set we
get by combining all the elements in A and B into a single set. The intersection
of A and B, written A ∩B, is the set of elements that are in both A and B. The
complement of A, written A, is the set of all elements under consideration that
are not in A.
As is often the case in mathematics, a picture helps clarify a concept. For sets,
we use a type of picture called a Venn diagram. It represents sets as regions
enclosed by circular lines. Let the set START-t be the set of all English words
that start with the letter “t”. For example, in the ﬁgure, the circle represents the
set START-t. Several members of this set are represented as points inside the
circle.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

0.2
MATHEMATICAL NOTIONS AND TERMINOLOGY
5
FIGURE
0.1
Venn diagram for the set of English words starting with “t”
Similarly, we represent the set END-z of English words that end with “z” in
the following ﬁgure.
FIGURE
0.2
Venn diagram for the set of English words ending with “z”
To represent both sets in the same Venn diagram, we must draw them so that
they overlap, indicating that they share some elements, as shown in the following
ﬁgure. For example, the word topaz is in both sets. The ﬁgure also contains a
circle for the set START-j. It doesn’t overlap the circle for START-t because no
word lies in both sets.
FIGURE
0.3
Overlapping circles indicate common elements
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6
CHAPTER 0 / INTRODUCTION
The next two Venn diagrams depict the union and intersection of sets A
and B.
FIGURE
0.4
Diagrams for (a) A ∪B and (b) A ∩B
SEQUENCES AND TUPLES
A sequence of objects is a list of these objects in some order. We usually designate
a sequence by writing the list within parentheses. For example, the sequence 7,
21, 57 would be written
(7, 21, 57).
The order doesn’t matter in a set, but in a sequence it does. Hence (7, 21, 57) is
not the same as (57, 7, 21). Similarly, repetition does matter in a sequence, but
it doesn’t matter in a set. Thus (7, 7, 21, 57) is different from both of the other
sequences, whereas the set {7, 21, 57} is identical to the set {7, 7, 21, 57}.
As with sets, sequences may be ﬁnite or inﬁnite. Finite sequences often are
called tuples. A sequence with k elements is a k-tuple. Thus (7, 21, 57) is a
3-tuple. A 2-tuple is also called an ordered pair.
Sets and sequences may appear as elements of other sets and sequences. For
example, the power set of A is the set of all subsets of A. If A is the set {0, 1},
the power set of A is the set { ∅, {0}, {1}, {0, 1} }. The set of all ordered pairs
whose elements are 0s and 1s is { (0, 0), (0, 1), (1, 0), (1, 1) }.
If A and B are two sets, the Cartesian product or cross product of A and
B, written A × B, is the set of all ordered pairs wherein the ﬁrst element is a
member of A and the second element is a member of B.
EXAMPLE
0.5
If A = {1, 2} and B = {x, y, z},
A × B = { (1, x), (1, y), (1, z), (2, x), (2, y), (2, z) }.
We can also take the Cartesian product of k sets, A1, A2, . . . , Ak, written
A1 × A2 × · · · × Ak. It is the set consisting of all k-tuples (a1, a2, . . . , ak) where
ai ∈Ai.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

0.2
MATHEMATICAL NOTIONS AND TERMINOLOGY
7
EXAMPLE
0.6
If A and B are as in Example 0.5,
A × B × A =

(1, x, 1), (1, x, 2), (1, y, 1), (1, y, 2), (1, z, 1), (1, z, 2),
(2, x, 1), (2, x, 2), (2, y, 1), (2, y, 2), (2, z, 1), (2, z, 2)
	
.
If we have the Cartesian product of a set with itself, we use the shorthand
k
z
}|
{
A × A × · · · × A = Ak.
EXAMPLE
0.7
The set N 2 equals N × N. It consists of all ordered pairs of natural numbers.
We also may write it as {(i, j)| i, j ≥1}.
FUNCTIONS AND RELATIONS
Functions are central to mathematics. A function is an object that sets up an
input–output relationship. A function takes an input and produces an output.
In every function, the same input always produces the same output. If f is a
function whose output value is b when the input value is a, we write
f(a) = b.
A function also is called a mapping, and, if f(a) = b, we say that f maps a to b.
For example, the absolute value function abs takes a number x as input and
returns x if x is positive and −x if x is negative. Thus abs(2) = abs(−2) =
2. Addition is another example of a function, written add. The input to the
addition function is an ordered pair of numbers, and the output is the sum of
those numbers.
The set of possible inputs to the function is called its domain. The outputs
of a function come from a set called its range. The notation for saying that f is
a function with domain D and range R is
f : D−→R.
In the case of the function abs, if we are working with integers, the domain and
the range are Z, so we write abs : Z−→Z. In the case of the addition function
for integers, the domain is the set of pairs of integers Z × Z and the range is Z,
so we write add : Z × Z−→Z. Note that a function may not necessarily use all
the elements of the speciﬁed range. The function abs never takes on the value
−1 even though −1 ∈Z. A function that does use all the elements of the range
is said to be onto the range.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8
CHAPTER 0 / INTRODUCTION
We may describe a speciﬁc function in several ways. One way is with a pro-
cedure for computing an output from a speciﬁed input. Another way is with a
table that lists all possible inputs and gives the output for each input.
EXAMPLE
0.8
Consider the function f : {0, 1, 2, 3, 4}−→{0, 1, 2, 3, 4}.
n
f(n)
0
1
1
2
2
3
3
4
4
0
This function adds 1 to its input and then outputs the result modulo 5. A number
modulo m is the remainder after division by m. For example, the minute hand
on a clock face counts modulo 60. When we do modular arithmetic, we deﬁne
Zm = {0, 1, 2, . . ., m −1}. With this notation, the aforementioned function f
has the form f : Z5−→Z5.
EXAMPLE
0.9
Sometimes a two-dimensional table is used if the domain of the function is the
Cartesian product of two sets. Here is another function, g: Z4 ×Z4−→Z4. The
entry at the row labeled i and the column labeled j in the table is the value of
g(i, j).
g
0
1
2
3
0
0
1
2
3
1
1
2
3
0
2
2
3
0
1
3
3
0
1
2
The function g is the addition function modulo 4.
When the domain of a function f is A1×· · ·×Ak for some sets A1, . . . , Ak, the
input to f is a k-tuple (a1, a2, . . . , ak) and we call the ai the arguments to f. A
function with k arguments is called a k-ary function, and k is called the arity of
the function. If k is 1, f has a single argument and f is called a unary function.
If k is 2, f is a binary function. Certain familiar binary functions are written
in a special inﬁx notation, with the symbol for the function placed between its
two arguments, rather than in preﬁx notation, with the symbol preceding. For
example, the addition function add usually is written in inﬁx notation with the
+ symbol between its two arguments as in a + b instead of in preﬁx notation
add(a, b).
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

0.2
MATHEMATICAL NOTIONS AND TERMINOLOGY
9
A predicate or property is a function whose range is {TRUE, FALSE}. For
example, let even be a property that is TRUE if its input is an even number and
FALSE if its input is an odd number. Thus even(4) = TRUE and even(5) =
FALSE.
A property whose domain is a set of k-tuples A × · · · × A is called a relation,
a k-ary relation, or a k-ary relation on A. A common case is a 2-ary relation,
called a binary relation. When writing an expression involving a binary rela-
tion, we customarily use inﬁx notation. For example, “less than” is a relation
usually written with the inﬁx operation symbol <. “Equality”, written with the
= symbol, is another familiar relation. If R is a binary relation, the statement
aRb means that aRb = TRUE. Similarly, if R is a k-ary relation, the statement
R(a1, . . . , ak) means that R(a1, . . . , ak) = TRUE.
EXAMPLE
0.10
In a children’s game called Scissors–Paper–Stone, the two players simultaneously
select a member of the set {SCISSORS, PAPER, STONE} and indicate their selec-
tions with hand signals. If the two selections are the same, the game starts over.
If the selections differ, one player wins, according to the relation beats.
beats
SCISSORS
PAPER
STONE
SCISSORS
FALSE
TRUE
FALSE
PAPER
FALSE
FALSE
TRUE
STONE
TRUE
FALSE
FALSE
From this table we determine that SCISSORS beats PAPER is TRUE and that
PAPER beats SCISSORS is FALSE.
Sometimes describing predicates with sets instead of functions is more con-
venient. The predicate P : D−→{TRUE, FALSE} may be written (D, S), where
S = {a ∈D| P(a) = TRUE}, or simply S if the domain D is obvious from the
context. Hence the relation beats may be written
{(SCISSORS, PAPER), (PAPER, STONE), (STONE, SCISSORS)}.
A special type of binary relation, called an equivalence relation, captures the
notion of two objects being equal in some feature. A binary relation R is an
equivalence relation if R satisﬁes three conditions:
1. R is reﬂexive if for every x, xRx;
2. R is symmetric if for every x and y, xRy implies yRx; and
3. R is transitive if for every x, y, and z, xRy and yRz implies xRz.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10
CHAPTER 0 / INTRODUCTION
EXAMPLE
0.11
Deﬁne an equivalence relation on the natural numbers, written ≡7. For i, j ∈N,
say that i ≡7 j, if i−j is a multiple of 7. This is an equivalence relation because it
satisﬁes the three conditions. First, it is reﬂexive, as i−i = 0, which is a multiple
of 7. Second, it is symmetric, as i −j is a multiple of 7 if j −i is a multiple of 7.
Third, it is transitive, as whenever i −j is a multiple of 7 and j −k is a multiple
of 7, then i −k = (i −j) + (j −k) is the sum of two multiples of 7 and hence a
multiple of 7, too.
GRAPHS
An undirected graph, or simply a graph, is a set of points with lines connecting
some of the points. The points are called nodes or vertices, and the lines are
called edges, as shown in the following ﬁgure.
FIGURE
0.12
Examples of graphs
The number of edges at a particular node is the degree of that node. In
Figure 0.12(a), all the nodes have degree 2. In Figure 0.12(b), all the nodes have
degree 3. No more than one edge is allowed between any two nodes. We may
allow an edge from a node to itself, called a self-loop, depending on the situation.
In a graph G that contains nodes i and j, the pair (i, j) represents the edge that
connects i and j. The order of i and j doesn’t matter in an undirected graph,
so the pairs (i, j) and (j, i) represent the same edge. Sometimes we describe
undirected edges with unordered pairs using set notation as in {i, j}. If V is the
set of nodes of G and E is the set of edges, we say G = (V, E). We can describe
a graph with a diagram or more formally by specifying V and E. For example, a
formal description of the graph in Figure 0.12(a) is
 {1, 2, 3, 4, 5}, {(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)}

,
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

0.2
MATHEMATICAL NOTIONS AND TERMINOLOGY
11
and a formal description of the graph in Figure 0.12(b) is
 {1, 2, 3, 4}, {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)}

.
Graphs frequently are used to represent data. Nodes might be cities and edges
the connecting highways, or nodes might be people and edges the friendships
between them. Sometimes, for convenience, we label the nodes and/or edges of
a graph, which then is called a labeled graph. Figure 0.13 depicts a graph whose
nodes are cities and whose edges are labeled with the dollar cost of the cheapest
nonstop airfare for travel between those cities if ﬂying nonstop between them is
possible.
FIGURE
0.13
Cheapest nonstop airfares between various cities
We say that graph G is a subgraph of graph H if the nodes of G are a subset
of the nodes of H, and the edges of G are the edges of H on the corresponding
nodes. The following ﬁgure shows a graph H and a subgraph G.
FIGURE
0.14
Graph G (shown darker) is a subgraph of H
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

12
CHAPTER 0 / INTRODUCTION
A path in a graph is a sequence of nodes connected by edges. A simple path
is a path that doesn’t repeat any nodes. A graph is connected if every two nodes
have a path between them. A path is a cycle if it starts and ends in the same node.
A simple cycle is one that contains at least three nodes and repeats only the ﬁrst
and last nodes. A graph is a tree if it is connected and has no simple cycles, as
shown in Figure 0.15. A tree may contain a specially designated node called the
root. The nodes of degree 1 in a tree, other than the root, are called the leaves
of the tree.
FIGURE
0.15
(a) A path in a graph, (b) a cycle in a graph, and (c) a tree
A directed graph has arrows instead of lines, as shown in the following ﬁgure.
The number of arrows pointing from a particular node is the outdegree of that
node, and the number of arrows pointing to a particular node is the indegree.
FIGURE
0.16
A directed graph
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

0.2
MATHEMATICAL NOTIONS AND TERMINOLOGY
13
In a directed graph, we represent an edge from i to j as a pair (i, j). The
formal description of a directed graph G is (V, E), where V is the set of nodes
and E is the set of edges. The formal description of the graph in Figure 0.16 is
 {1,2,3,4,5,6}, {(1,2), (1,5), (2,1), (2,4), (5,4), (5,6), (6,1), (6,3)}

.
A path in which all the arrows point in the same direction as its steps is called a
directed path. A directed graph is strongly connected if a directed path connects
every two nodes. Directed graphs are a handy way of depicting binary relations.
If R is a binary relation whose domain is D × D, a labeled graph G = (D, E)
represents R, where E = {(x, y)| xRy}.
EXAMPLE
0.17
The directed graph shown here represents the relation given in Example 0.10.
FIGURE
0.18
The graph of the relation beats
STRINGS AND LANGUAGES
Strings of characters are fundamental building blocks in computer science. The
alphabet over which the strings are deﬁned may vary with the application. For
our purposes, we deﬁne an alphabet to be any nonempty ﬁnite set. The members
of the alphabet are the symbols of the alphabet. We generally use capital Greek
letters Σ and Γ to designate alphabets and a typewriter font for symbols from an
alphabet. The following are a few examples of alphabets.
Σ1 = {0,1}
Σ2 = {a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z}
Γ = {0, 1, x, y, z}
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

14
CHAPTER 0 / INTRODUCTION
A string over an alphabet is a ﬁnite sequence of symbols from that alphabet,
usually written next to one another and not separated by commas. If Σ1 = {0,1},
then 01001 is a string over Σ1. If Σ2 = {a, b, c, . . . , z}, then abracadabra is a
string over Σ2. If w is a string over Σ, the length of w, written |w|, is the number
of symbols that it contains. The string of length zero is called the empty string
and is written ε. The empty string plays the role of 0 in a number system. If w
has length n, we can write w = w1w2 · · · wn where each wi ∈Σ. The reverse
of w, written wR, is the string obtained by writing w in the opposite order (i.e.,
wnwn−1 · · · w1). String z is a substring of w if z appears consecutively within w.
For example, cad is a substring of abracadabra.
If we have string x of length m and string y of length n, the concatenation
of x and y, written xy, is the string obtained by appending y to the end of x, as
in x1 · · · xmy1 · · · yn. To concatenate a string with itself many times, we use the
superscript notation xk to mean
k
z }| {
xx · · · x .
The lexicographic order of strings is the same as the familiar dictionary order.
We’ll occasionally use a modiﬁed lexicographic order, called shortlex order or
simply string order, that is identical to lexicographic order, except that shorter
strings precede longer strings. Thus the string ordering of all strings over the
alphabet {0,1} is
(ε, 0, 1, 00, 01, 10, 11, 000, . . .).
Say that string x is a preﬁx of string y if a string z exists where xz = y, and that
x is a proper preﬁx of y if in addition x ̸= y. A language is a set of strings. A
language is preﬁx-free if no member is a proper preﬁx of another member.
BOOLEAN LOGIC
Boolean logic is a mathematical system built around the two values TRUE and
FALSE. Though originally conceived of as pure mathematics, this system is now
considered to be the foundation of digital electronics and computer design. The
values TRUE and FALSE are called the Boolean values and are often represented
by the values 1 and 0. We use Boolean values in situations with two possibilities,
such as a wire that may have a high or a low voltage, a proposition that may be
true or false, or a question that may be answered yes or no.
We can manipulate Boolean values with the Boolean operations. The sim-
plest Boolean operation is the negation or NOT operation, designated with the
symbol ¬. The negation of a Boolean value is the opposite value. Thus ¬0 = 1
and ¬1 = 0. We designate the conjunction or AND operation with the sym-
bol ∧. The conjunction of two Boolean values is 1 if both of those values are 1.
The disjunction or OR operation is designated with the symbol ∨. The disjunc-
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

0.2
MATHEMATICAL NOTIONS AND TERMINOLOGY
15
tion of two Boolean values is 1 if either of those values is 1. We summarize this
information as follows.
0 ∧0 = 0
0 ∨0 = 0
¬0 = 1
0 ∧1 = 0
0 ∨1 = 1
¬1 = 0
1 ∧0 = 0
1 ∨0 = 1
1 ∧1 = 1
1 ∨1 = 1
We use Boolean operations for combining simple statements into more com-
plex Boolean expressions, just as we use the arithmetic operations + and × to
construct complex arithmetic expressions. For example, if P is the Boolean value
representing the truth of the statement “the sun is shining” and Q represents the
truth of the statement “today is Monday”, we may write P ∧Q to represent the
truth value of the statement “the sun is shining and today is Monday” and sim-
ilarly for P ∨Q with and replaced by or. The values P and Q are called the
operands of the operation.
Several other Boolean operations occasionally appear. The exclusive or, or
XOR, operation is designated by the ⊕symbol and is 1 if either but not both of
its two operands is 1. The equality operation, written with the symbol ↔, is 1
if both of its operands have the same value. Finally, the implication operation
is designated by the symbol →and is 0 if its ﬁrst operand is 1 and its second
operand is 0; otherwise, →is 1. We summarize this information as follows.
0 ⊕0 = 0
0 ↔0 = 1
0 →0 = 1
0 ⊕1 = 1
0 ↔1 = 0
0 →1 = 1
1 ⊕0 = 1
1 ↔0 = 0
1 →0 = 0
1 ⊕1 = 0
1 ↔1 = 1
1 →1 = 1
We can establish various relationships among these operations. In fact, we
can express all Boolean operations in terms of the AND and NOT operations, as
the following identities show. The two expressions in each row are equivalent.
Each row expresses the operation in the left-hand column in terms of operations
above it and AND and NOT.
P ∨Q
¬(¬P ∧¬Q)
P →Q
¬P ∨Q
P ↔Q
(P →Q) ∧(Q →P)
P ⊕Q
¬(P ↔Q)
The distributive law for AND and OR comes in handy when we manipulate
Boolean expressions. It is similar to the distributive law for addition and multi-
plication, which states that a × (b + c) = (a × b) + (a × c). The Boolean version
comes in two forms:
• P ∧(Q ∨R) equals (P ∧Q) ∨(P ∧R), and its dual
• P ∨(Q ∧R) equals (P ∨Q) ∧(P ∨R).
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

16
CHAPTER 0 / INTRODUCTION
SUMMARY OF MATHEMATICAL TERMS
Alphabet
A ﬁnite, nonempty set of objects called symbols
Argument
An input to a function
Binary relation
A relation whose domain is a set of pairs
Boolean operation
An operation on Boolean values
Boolean value
The values TRUE or FALSE, often represented by 1 or 0
Cartesian product
An operation on sets forming a set of all tuples of elements from
respective sets
Complement
An operation on a set, forming the set of all elements not present
Concatenation
An operation that joins strings together
Conjunction
Boolean AND operation
Connected graph
A graph with paths connecting every two nodes
Cycle
A path that starts and ends in the same node
Directed graph
A collection of points and arrows connecting some pairs of points
Disjunction
Boolean OR operation
Domain
The set of possible inputs to a function
Edge
A line in a graph
Element
An object in a set
Empty set
The set with no members
Empty string
The string of length zero
Equivalence relation A binary relation that is reﬂexive, symmetric, and transitive
Function
An operation that translates inputs into outputs
Graph
A collection of points and lines connecting some pairs of points
Intersection
An operation on sets forming the set of common elements
k-tuple
A list of k objects
Language
A set of strings
Member
An object in a set
Node
A point in a graph
Ordered pair
A list of two elements
Path
A sequence of nodes in a graph connected by edges
Predicate
A function whose range is {TRUE, FALSE}
Property
A predicate
Range
The set from which outputs of a function are drawn
Relation
A predicate, most typically when the domain is a set of k-tuples
Sequence
A list of objects
Set
A group of objects
Simple path
A path without repetition
Singleton set
A set with one member
String
A ﬁnite list of symbols from an alphabet
Symbol
A member of an alphabet
Tree
A connected graph without simple cycles
Union
An operation on sets combining all elements into a single set
Unordered pair
A set with two members
Vertex
A point in a graph
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

0.3
DEFINITIONS, THEOREMS, AND PROOFS
17
0.3
DEFINITIONS, THEOREMS, AND PROOFS
Theorems and proofs are the heart and soul of mathematics and deﬁnitions are
its spirit. These three entities are central to every mathematical subject, includ-
ing ours.
Deﬁnitions describe the objects and notions that we use. A deﬁnition may be
simple, as in the deﬁnition of set given earlier in this chapter, or complex as in
the deﬁnition of security in a cryptographic system. Precision is essential to any
mathematical deﬁnition. When deﬁning some object, we must make clear what
constitutes that object and what does not.
After we have deﬁned various objects and notions, we usually make math-
ematical statements about them.
Typically, a statement expresses that some
object has a certain property. The statement may or may not be true; but like a
deﬁnition, it must be precise. No ambiguity about its meaning is allowed.
A proof is a convincing logical argument that a statement is true. In mathe-
matics, an argument must be airtight; that is, convincing in an absolute sense. In
everyday life or in the law, the standard of proof is lower. A murder trial demands
proof “beyond any reasonable doubt.” The weight of evidence may compel the
jury to accept the innocence or guilt of the suspect. However, evidence plays
no role in a mathematical proof. A mathematician demands proof beyond any
doubt.
A theorem is a mathematical statement proved true. Generally we reserve the
use of that word for statements of special interest. Occasionally we prove state-
ments that are interesting only because they assist in the proof of another, more
signiﬁcant statement. Such statements are called lemmas. Occasionally a theo-
rem or its proof may allow us to conclude easily that other, related statements
are true. These statements are called corollaries of the theorem.
FINDING PROOFS
The only way to determine the truth or falsity of a mathematical statement is
with a mathematical proof. Unfortunately, ﬁnding proofs isn’t always easy. It
can’t be reduced to a simple set of rules or processes. During this course, you will
be asked to present proofs of various statements. Don’t despair at the prospect!
Even though no one has a recipe for producing proofs, some helpful general
strategies are available.
First, carefully read the statement you want to prove. Do you understand
all the notation? Rewrite the statement in your own words. Break it down and
consider each part separately.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

18
CHAPTER 0 / INTRODUCTION
Sometimes the parts of a multipart statement are not immediately evident.
One frequently occurring type of multipart statement has the form “P if and
only if Q”, often written “P iff Q”, where both P and Q are mathematical state-
ments. This notation is shorthand for a two-part statement. The ﬁrst part is “P
only if Q,” which means: If P is true, then Q is true, written P ⇒Q. The second
is “P if Q,” which means: If Q is true, then P is true, written P ⇐Q. The ﬁrst
of these parts is the forward direction of the original statement and the second
is the reverse direction. We write “P if and only if Q” as P ⇐⇒Q. To prove a
statement of this form, you must prove each of the two directions. Often, one of
these directions is easier to prove than the other.
Another type of multipart statement states that two sets A and B are equal.
The ﬁrst part states that A is a subset of B, and the second part states that B
is a subset of A. Thus one common way to prove that A = B is to prove that
every member of A also is a member of B, and that every member of B also is a
member of A.
Next, when you want to prove a statement or part thereof, try to get an in-
tuitive, “gut” feeling of why it should be true. Experimenting with examples is
especially helpful. Thus if the statement says that all objects of a certain type
have a particular property, pick a few objects of that type and observe that they
actually do have that property. After doing so, try to ﬁnd an object that fails to
have the property, called a counterexample. If the statement actually is true, you
will not be able to ﬁnd a counterexample. Seeing where you run into difﬁculty
when you attempt to ﬁnd a counterexample can help you understand why the
statement is true.
EXAMPLE
0.19
Suppose that you want to prove the statement for every graph G, the sum of the
degrees of all the nodes in G is an even number.
First, pick a few graphs and observe this statement in action. Here are two
examples.
 
         
 
         
Next, try to ﬁnd a counterexample; that is, a graph in which the sum is an odd
number.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

0.3
DEFINITIONS, THEOREMS, AND PROOFS
19
Can you now begin to see why the statement is true and how to prove it?
If you are still stuck trying to prove a statement, try something easier. Attempt
to prove a special case of the statement. For example, if you are trying to prove
that some property is true for every k > 0, ﬁrst try to prove it for k = 1. If you
succeed, try it for k = 2, and so on until you can understand the more general
case. If a special case is hard to prove, try a different special case or perhaps a
special case of the special case.
Finally, when you believe that you have found the proof, you must write it
up properly. A well-written proof is a sequence of statements, wherein each one
follows by simple reasoning from previous statements in the sequence. Carefully
writing a proof is important, both to enable a reader to understand it, and for
you to be sure that it is free from errors.
The following are a few tips for producing a proof.
• Be patient. Finding proofs takes time. If you don’t see how to do it right
away, don’t worry. Researchers sometimes work for weeks or even years to
ﬁnd a single proof.
• Come back to it. Look over the statement you want to prove, think about
it a bit, leave it, and then return a few minutes or hours later. Let the
unconscious, intuitive part of your mind have a chance to work.
• Be neat. When you are building your intuition for the statement you are
trying to prove, use simple, clear pictures and/or text. You are trying to
develop your insight into the statement, and sloppiness gets in the way of
insight. Furthermore, when you are writing a solution for another person
to read, neatness will help that person understand it.
• Be concise. Brevity helps you express high-level ideas without getting lost in
details. Good mathematical notation is useful for expressing ideas concisely.
But be sure to include enough of your reasoning when writing up a proof
so that the reader can easily understand what you are trying to say.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

20
CHAPTER 0 / INTRODUCTION
For practice, let’s prove one of DeMorgan’s laws.
THEOREM
0.20
For any two sets A and B, A ∪B = A ∩B.
First, is the meaning of this theorem clear? If you don’t understand the mean-
ing of the symbols ∪or ∩or the overbar, review the discussion on page 4.
To prove this theorem, we must show that the two sets A ∪B and A ∩B are
equal. Recall that we may prove that two sets are equal by showing that every
member of one set also is a member of the other and vice versa. Before looking
at the following proof, consider a few examples and then try to prove it yourself.
PROOF
This theorem states that two sets, A ∪B and A ∩B, are equal. We
prove this assertion by showing that every element of one also is an element of
the other and vice versa.
Suppose that x is an element of A ∪B. Then x is not in A ∪B from the
deﬁnition of the complement of a set. Therefore, x is not in A and x is not in B,
from the deﬁnition of the union of two sets. In other words, x is in A and x is in
B. Hence the deﬁnition of the intersection of two sets shows that x is in A ∩B.
For the other direction, suppose that x is in A ∩B. Then x is in both A and
B. Therefore, x is not in A and x is not in B, and thus not in the union of
these two sets. Hence x is in the complement of the union of these sets; in other
words, x is in A ∪B, which completes the proof of the theorem.
Let’s now prove the statement in Example 0.19.
THEOREM
0.21
For every graph G, the sum of the degrees of all the nodes in G is an even
number.
PROOF
Every edge in G is connected to two nodes. Each edge contributes 1
to the degree of each node to which it is connected. Therefore, each edge con-
tributes 2 to the sum of the degrees of all the nodes. Hence, if G contains e
edges, then the sum of the degrees of all the nodes of G is 2e, which is an even
number.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

0.4
TYPES OF PROOF
21
0.4
TYPES OF PROOF
Several types of arguments arise frequently in mathematical proofs. Here, we
describe a few that often occur in the theory of computation. Note that a proof
may contain more than one type of argument because the proof may contain
within it several different subproofs.
PROOF BY CONSTRUCTION
Many theorems state that a particular type of object exists. One way to prove
such a theorem is by demonstrating how to construct the object. This technique
is a proof by construction.
Let’s use a proof by construction to prove the following theorem. We deﬁne
a graph to be k-regular if every node in the graph has degree k.
THEOREM
0.22
For each even number n greater than 2, there exists a 3-regular graph with n
nodes.
PROOF
Let n be an even number greater than 2. Construct graph G = (V, E)
with n nodes as follows. The set of nodes of G is V = {0, 1, . . ., n −1}, and the
set of edges of G is the set
E = { {i, i + 1} | for 0 ≤i ≤n −2} ∪{ {n −1, 0} }
∪{ {i, i + n/2} | for 0 ≤i ≤n/2 −1}.
Picture the nodes of this graph written consecutively around the circumference
of a circle. In that case, the edges described in the top line of E go between
adjacent pairs around the circle. The edges described in the bottom line of E go
between nodes on opposite sides of the circle. This mental picture clearly shows
that every node in G has degree 3.
PROOF BY CONTRADICTION
In one common form of argument for proving a theorem, we assume that the
theorem is false and then show that this assumption leads to an obviously false
consequence, called a contradiction. We use this type of reasoning frequently in
everyday life, as in the following example.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

22
CHAPTER 0 / INTRODUCTION
EXAMPLE
0.23
Jack sees Jill, who has just come in from outdoors. On observing that she is
completely dry, he knows that it is not raining. His “proof” that it is not raining
is that if it were raining (the assumption that the statement is false), Jill would be
wet (the obviously false consequence). Therefore, it must not be raining.
Next, let’s prove by contradiction that the square root of 2 is an irrational
number. A number is rational if it is a fraction m
n , where m and n are integers;
in other words, a rational number is the ratio of integers m and n. For example,
2
3 obviously is a rational number. A number is irrational if it is not rational.
THEOREM
0.24
√
2 is irrational.
PROOF
First, we assume for the purpose of later obtaining a contradiction
that
√
2 is rational. Thus
√
2 = m
n ,
where m and n are integers. If both m and n are divisible by the same integer
greater than 1, divide both by the largest such integer. Doing so doesn’t change
the value of the fraction. Now, at least one of m and n must be an odd number.
We multiply both sides of the equation by n and obtain
n
√
2 = m.
We square both sides and obtain
2n2 = m2.
Because m2 is 2 times the integer n2, we know that m2 is even. Therefore, m,
too, is even, as the square of an odd number always is odd. So we can write
m = 2k for some integer k. Then, substituting 2k for m, we get
2n2 = (2k)2
= 4k2.
Dividing both sides by 2, we obtain
n2 = 2k2.
But this result shows that n2 is even and hence that n is even. Thus we have
established that both m and n are even. But we had earlier reduced m and n so
that they were not both even—a contradiction.
PROOF BY INDUCTION
Proof by induction is an advanced method used to show that all elements of
an inﬁnite set have a speciﬁed property. For example, we may use a proof by
induction to show that an arithmetic expression computes a desired quantity for
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

0.4
TYPES OF PROOF
23
every assignment to its variables, or that a program works correctly at all steps
or for all inputs.
To illustrate how proof by induction works, let’s take the inﬁnite set to be the
natural numbers, N = {1, 2, 3, . . . }, and say that the property is called P. Our
goal is to prove that P(k) is true for each natural number k. In other words, we
want to prove that P(1) is true, as well as P(2), P(3), P(4), and so on.
Every proof by induction consists of two parts, the basis and the induction
step. Each part is an individual proof on its own. The basis proves that P(1) is
true. The induction step proves that for each i ≥1, if P(i) is true, then so is
P(i + 1).
When we have proven both of these parts, the desired result follows—namely,
that P(i) is true for each i. Why? First, we know that P(1) is true because the
basis alone proves it. Second, we know that P(2) is true because the induction
step proves that if P(1) is true then P(2) is true, and we already know that P(1)
is true. Third, we know that P(3) is true because the induction step proves that
if P(2) is true then P(3) is true, and we already know that P(2) is true. This
process continues for all natural numbers, showing that P(4) is true, P(5) is
true, and so on.
Once you understand the preceding paragraph, you can easily understand
variations and generalizations of the same idea. For example, the basis doesn’t
necessarily need to start with 1; it may start with any value b. In that case, the
induction proof shows that P(k) is true for every k that is at least b.
In the induction step, the assumption that P(i) is true is called the induction
hypothesis. Sometimes having the stronger induction hypothesis that P(j) is
true for every j ≤i is useful. The induction proof still works because when we
want to prove that P(i + 1) is true, we have already proved that P(j) is true for
every j ≤i.
The format for writing down a proof by induction is as follows.
Basis: Prove that P(1) is true.
...
Induction step: For each i ≥1, assume that P(i) is true and use this assumption
to show that P(i + 1) is true.
...
Now, let’s prove by induction the correctness of the formula used to calculate
the size of monthly payments of home mortgages. When buying a home, many
people borrow some of the money needed for the purchase and repay this loan
over a certain number of years. Typically, the terms of such repayments stipulate
that a ﬁxed amount of money is paid each month to cover the interest, as well as
part of the original sum, so that the total is repaid in 30 years. The formula for
calculating the size of the monthly payments is shrouded in mystery, but actually
is quite simple. It touches many people’s lives, so you should ﬁnd it interesting.
We use induction to prove that it works, making it a good illustration of that
technique.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

24
CHAPTER 0 / INTRODUCTION
First, we set up the names and meanings of several variables. Let P be the
principal, the amount of the original loan. Let I > 0 be the yearly interest rate of
the loan, where I = 0.06 indicates a 6% rate of interest. Let Y be the monthly
payment. For convenience, we use I to deﬁne another variable M, the monthly
multiplier. It is the rate at which the loan changes each month because of the
interest on it. Following standard banking practice, the monthly interest rate is
one-twelfth of the annual rate so M = 1 + I/12, and interest is paid monthly
(monthly compounding).
Two things happen each month. First, the amount of the loan tends to in-
crease because of the monthly multiplier. Second, the amount tends to decrease
because of the monthly payment. Let Pt be the amount of the loan outstand-
ing after the tth month. Then P0 = P is the amount of the original loan,
P1 = MP0 −Y is the amount of the loan after one month, P2 = MP1 −Y is
the amount of the loan after two months, and so on. Now we are ready to state
and prove a theorem by induction on t that gives a formula for the value of Pt.
THEOREM
0.25
For each t ≥0,
Pt = PM t −Y
M t −1
M −1

.
PROOF
Basis: Prove that the formula is true for t = 0. If t = 0, then the formula states
that
P0 = PM 0 −Y
M 0 −1
M −1

.
We can simplify the right-hand side by observing that M 0 = 1. Thus we get
P0 = P,
which holds because we have deﬁned P0 to be P. Therefore, we have proved
that the basis of the induction is true.
Induction step: For each k ≥0, assume that the formula is true for t = k and
show that it is true for t = k + 1. The induction hypothesis states that
Pk = PM k −Y
M k −1
M −1

.
Our objective is to prove that
Pk+1 = PM k+1 −Y
M k+1 −1
M −1

.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

EXERCISES
25
We do so with the following steps. First, from the deﬁnition of Pk+1 from
Pk, we know that
Pk+1 = PkM −Y.
Therefore, using the induction hypothesis to calculate Pk,
Pk+1 =

PM k −Y
M k −1
M −1

M −Y.
Multiplying through by M and rewriting Y yields
Pk+1 = PM k+1 −Y
M k+1 −M
M −1

−Y
M −1
M −1

= PM k+1 −Y
M k+1 −1
M −1

.
Thus the formula is correct for t = k + 1, which proves the theorem.
Problem 0.15 asks you to use the preceding formula to calculate actual mort-
gage payments.
EXERCISES
0.1 Examine the following formal descriptions of sets so that you understand which
members they contain. Write a short informal English description of each set.
a. {1, 3, 5, 7, . . . }
b. { . . . , −4, −2, 0, 2, 4, . . . }
c. {n| n = 2m for some m in N}
d. {n| n = 2m for some m in N, and n = 3k for some k in N}
e. {w| w is a string of 0s and 1s and w equals the reverse of w}
f. {n| n is an integer and n = n + 1}
0.2 Write formal descriptions of the following sets.
a. The set containing the numbers 1, 10, and 100
b. The set containing all integers that are greater than 5
c. The set containing all natural numbers that are less than 5
d. The set containing the string aba
e. The set containing the empty string
f. The set containing nothing at all
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

26
CHAPTER 0 / INTRODUCTION
0.3 Let A be the set {x, y, z} and B be the set {x, y}.
a. Is A a subset of B?
b. Is B a subset of A?
c. What is A ∪B?
d. What is A ∩B?
e. What is A × B?
f. What is the power set of B?
0.4 If A has a elements and B has b elements, how many elements are in A × B?
Explain your answer.
0.5 If C is a set with c elements, how many elements are in the power set of C? Explain
your answer.
0.6 Let X be the set {1, 2, 3, 4, 5} and Y be the set {6, 7, 8, 9, 10}. The unary function
f : X−→Y and the binary function g: X × Y −→Y are described in the following
tables.
n
f(n)
1
6
2
7
3
6
4
7
5
6
g
6
7
8
9
10
1
10
10
10
10
10
2
7
8
9
10
6
3
7
7
8
8
9
4
9
8
7
6
10
5
6
6
6
6
6
a. What is the value of f(2)?
b. What are the range and domain of f?
c. What is the value of g(2, 10)?
d. What are the range and domain of g?
e. What is the value of g(4, f(4))?
0.7 For each part, give a relation that satisﬁes the condition.
a. Reﬂexive and symmetric but not transitive
b. Reﬂexive and transitive but not symmetric
c. Symmetric and transitive but not reﬂexive
0.8 Consider the undirected graph G=(V, E) where V , the set of nodes, is {1, 2, 3, 4}
and E, the set of edges, is {{1, 2}, {2, 3}, {1, 3}, {2, 4}, {1, 4}}.
Draw the
graph G. What are the degrees of each node? Indicate a path from node 3 to
node 4 on your drawing of G.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
27
0.9 Write a formal description of the following graph.
PROBLEMS
0.10 Find the error in the following proof that 2 = 1.
Consider the equation a = b. Multiply both sides by a to obtain a2 = ab. Subtract
b2 from both sides to get a2 −b2 = ab−b2. Now factor each side, (a + b)(a −b) =
b(a−b), and divide each side by (a−b) to get a+b = b. Finally, let a and b equal 1,
which shows that 2 = 1.
0.11 Let S(n) = 1 + 2 + · · · + n be the sum of the ﬁrst n natural numbers and let
C(n) = 13 + 23 + · · · + n3 be the sum of the ﬁrst n cubes. Prove the following
equalities by induction on n, to arrive at the curious conclusion that C(n) = S2(n)
for every n.
a. S(n) = 1
2n(n + 1).
b. C(n) = 1
4(n4 + 2n3 + n2) = 1
4n2(n + 1)2.
0.12 Find the error in the following proof that all horses are the same color.
CLAIM: In any set of h horses, all horses are the same color.
PROOF: By induction on h.
Basis: For h = 1. In any set containing just one horse, all horses clearly are the
same color.
Induction step: For k ≥1, assume that the claim is true for h = k and prove that
it is true for h = k + 1. Take any set H of k + 1 horses. We show that all the horses
in this set are the same color. Remove one horse from this set to obtain the set H1
with just k horses. By the induction hypothesis, all the horses in H1 are the same
color. Now replace the removed horse and remove a different one to obtain the set
H2. By the same argument, all the horses in H2 are the same color. Therefore, all
the horses in H must be the same color, and the proof is complete.
0.13 Show that every graph with two or more nodes contains two nodes that have equal
degrees.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

28
CHAPTER 0 / INTRODUCTION
A⋆0.14 Ramsey’s theorem. Let G be a graph. A clique in G is a subgraph in which every
two nodes are connected by an edge. An anti-clique, also called an independent
set, is a subgraph in which every two nodes are not connected by an edge. Show
that every graph with n nodes contains either a clique or an anti-clique with at least
1
2 log2 n nodes.
A0.15 Use Theorem 0.25 to derive a formula for calculating the size of the monthly pay-
ment for a mortgage in terms of the principal P, the interest rate I, and the number
of payments t. Assume that after t payments have been made, the loan amount is
reduced to 0. Use the formula to calculate the dollar amount of each monthly pay-
ment for a 30-year mortgage with 360 monthly payments on an initial loan amount
of $100,000 with a 5% annual interest rate.
SELECTED SOLUTIONS
0.14
Make space for two piles of nodes: A and B. Then, starting with the entire graph,
repeatedly add each remaining node x to A if its degree is greater than one half the
number of remaining nodes and to B otherwise, and discard all nodes to which x
isn’t (is) connected if it was added to A (B). Continue until no nodes are left. At
most half of the nodes are discarded at each of these steps, so at least log2 n steps
will occur before the process terminates. Each step adds a node to one of the piles,
so one of the piles ends up with at least 1
2 log2 n nodes. The A pile contains the
nodes of a clique and the B pile contains the nodes of an anti-clique.
0.15
We let Pt = 0 and solve for Y to get the formula: Y = PM t(M −1)/(M t −1).
For P = $100,000, I = 0.05, and t = 360, we have M = 1 + (0.05)/12. We use a
calculator to ﬁnd that Y ≈$536.82 is the monthly payment.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

P A R T O N E
A U T O M A T A
A N D
L A N G U A G E S
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1
R E G U L A R L A N G U A G E S
The theory of computation begins with a question: What is a computer? It is
perhaps a silly question, as everyone knows that this thing I type on is a com-
puter. But these real computers are quite complicated—too much so to allow us
to set up a manageable mathematical theory of them directly. Instead, we use an
idealized computer called a computational model. As with any model in science,
a computational model may be accurate in some ways but perhaps not in others.
Thus we will use several different computational models, depending on the fea-
tures we want to focus on. We begin with the simplest model, called the ﬁnite
state machine or ﬁnite automaton.
1.1
FINITE AUTOMATA
Finite automata are good models for computers with an extremely limited
amount of memory. What can a computer do with such a small memory? Many
useful things! In fact, we interact with such computers all the time, as they lie at
the heart of various electromechanical devices.
The controller for an automatic door is one example of such a device. Often
found at supermarket entrances and exits, automatic doors swing open when the
controller senses that a person is approaching. An automatic door has a pad
31
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

32
CHAPTER 1 / REGULAR LANGUAGES
in front to detect the presence of a person about to walk through the doorway.
Another pad is located to the rear of the doorway so that the controller can hold
the door open long enough for the person to pass all the way through and also
so that the door does not strike someone standing behind it as it opens. This
conﬁguration is shown in the following ﬁgure.
FIGURE
1.1
Top view of an automatic door
The controller is in either of two states: “OPEN” or “CLOSED,” representing
the corresponding condition of the door. As shown in the following ﬁgures,
there are four possible input conditions: “FRONT” (meaning that a person is
standing on the pad in front of the doorway), “REAR” (meaning that a person is
standing on the pad to the rear of the doorway), “BOTH” (meaning that people
are standing on both pads), and “NEITHER” (meaning that no one is standing
on either pad).
FIGURE
1.2
State diagram for an automatic door controller
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.1
FINITE AUTOMATA
33
input signal
NEITHER
FRONT
REAR
BOTH
CLOSED
CLOSED
OPEN
CLOSED
CLOSED
state
OPEN
CLOSED
OPEN
OPEN
OPEN
FIGURE
1.3
State transition table for an automatic door controller
The controller moves from state to state, depending on the input it receives.
When in the CLOSED state and receiving input NEITHER or REAR, it remains
in the CLOSED state. In addition, if the input BOTH is received, it stays CLOSED
because opening the door risks knocking someone over on the rear pad. But if
the input FRONT arrives, it moves to the OPEN state. In the OPEN state, if input
FRONT, REAR, or BOTH is received, it remains in OPEN. If input NEITHER
arrives, it returns to CLOSED.
For example, a controller might start in state CLOSED and receive the series
of input signals FRONT, REAR, NEITHER, FRONT, BOTH, NEITHER, REAR,
and NEITHER. It then would go through the series of states CLOSED (starting),
OPEN, OPEN, CLOSED, OPEN, OPEN, CLOSED, CLOSED, and CLOSED.
Thinking of an automatic door controller as a ﬁnite automaton is useful be-
cause that suggests standard ways of representation as in Figures 1.2 and 1.3.
This controller is a computer that has just a single bit of memory, capable of
recording which of the two states the controller is in. Other common devices
have controllers with somewhat larger memories. In an elevator controller, a
state may represent the ﬂoor the elevator is on and the inputs might be the sig-
nals received from the buttons. This computer might need several bits to keep
track of this information. Controllers for various household appliances such as
dishwashers and electronic thermostats, as well as parts of digital watches and
calculators, are additional examples of computers with limited memories. The
design of such devices requires keeping the methodology and terminology of
ﬁnite automata in mind.
Finite automata and their probabilistic counterpart Markov chains are useful
tools when we are attempting to recognize patterns in data. These devices are
used in speech processing and in optical character recognition. Markov chains
have even been used to model and predict price changes in ﬁnancial markets.
We will now take a closer look at ﬁnite automata from a mathematical per-
spective. We will develop a precise deﬁnition of a ﬁnite automaton, terminology
for describing and manipulating ﬁnite automata, and theoretical results that de-
scribe their power and limitations. Besides giving you a clearer understanding
of what ﬁnite automata are and what they can and cannot do, this theoreti-
cal development will allow you to practice and become more comfortable with
mathematical deﬁnitions, theorems, and proofs in a relatively simple setting.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

34
CHAPTER 1 / REGULAR LANGUAGES
In beginning to describe the mathematical theory of ﬁnite automata, we do
so in the abstract, without reference to any particular application. The following
ﬁgure depicts a ﬁnite automaton called M1.
FIGURE
1.4
A ﬁnite automaton called M1 that has three states
Figure 1.4 is called the state diagram of M1. It has three states, labeled q1, q2,
and q3. The start state, q1, is indicated by the arrow pointing at it from nowhere.
The accept state, q2, is the one with a double circle. The arrows going from one
state to another are called transitions.
When this automaton receives an input string such as 1101, it processes that
string and produces an output. The output is either accept or reject. We will
consider only this yes/no type of output for now to keep things simple. The
processing begins in M1’s start state. The automaton receives the symbols from
the input string one by one from left to right. After reading each symbol, M1
moves from one state to another along the transition that has that symbol as its
label. When it reads the last symbol, M1 produces its output. The output is
accept if M1 is now in an accept state and reject if it is not.
For example, when we feed the input string 1101 into the machine M1 in
Figure 1.4, the processing proceeds as follows:
1. Start in state q1.
2. Read 1, follow transition from q1 to q2.
3. Read 1, follow transition from q2 to q2.
4. Read 0, follow transition from q2 to q3.
5. Read 1, follow transition from q3 to q2.
6. Accept because M1 is in an accept state q2 at the end of the input.
Experimenting with this machine on a variety of input strings reveals that it
accepts the strings 1, 01, 11, and 0101010101. In fact, M1 accepts any string that
ends with a 1, as it goes to its accept state q2 whenever it reads the symbol 1. In
addition, it accepts strings 100, 0100, 110000, and 0101000000, and any string
that ends with an even number of 0s following the last 1. It rejects other strings,
such as 0, 10, 101000. Can you describe the language consisting of all strings
that M1 accepts? We will do so shortly.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.1
FINITE AUTOMATA
35
FORMAL DEFINITION OF A FINITE AUTOMATON
In the preceding section, we used state diagrams to introduce ﬁnite automata.
Now we deﬁne ﬁnite automata formally. Although state diagrams are easier to
grasp intuitively, we need the formal deﬁnition, too, for two speciﬁc reasons.
First, a formal deﬁnition is precise. It resolves any uncertainties about what
is allowed in a ﬁnite automaton. If you were uncertain about whether ﬁnite
automata were allowed to have 0 accept states or whether they must have ex-
actly one transition exiting every state for each possible input symbol, you could
consult the formal deﬁnition and verify that the answer is yes in both cases. Sec-
ond, a formal deﬁnition provides notation. Good notation helps you think and
express your thoughts clearly.
The language of a formal deﬁnition is somewhat arcane, having some simi-
larity to the language of a legal document. Both need to be precise, and every
detail must be spelled out.
A ﬁnite automaton has several parts. It has a set of states and rules for going
from one state to another, depending on the input symbol. It has an input al-
phabet that indicates the allowed input symbols. It has a start state and a set of
accept states. The formal deﬁnition says that a ﬁnite automaton is a list of those
ﬁve objects: set of states, input alphabet, rules for moving, start state, and accept
states. In mathematical language, a list of ﬁve elements is often called a 5-tuple.
Hence we deﬁne a ﬁnite automaton to be a 5-tuple consisting of these ﬁve parts.
We use something called a transition function, frequently denoted δ, to de-
ﬁne the rules for moving. If the ﬁnite automaton has an arrow from a state x
to a state y labeled with the input symbol 1, that means that if the automaton is
in state x when it reads a 1, it then moves to state y. We can indicate the same
thing with the transition function by saying that δ(x, 1) = y. This notation is a
kind of mathematical shorthand. Putting it all together, we arrive at the formal
deﬁnition of ﬁnite automata.
DEFINITION
1.5
A ﬁnite automaton is a 5-tuple (Q, Σ, δ, q0, F), where
1. Q is a ﬁnite set called the states,
2. Σ is a ﬁnite set called the alphabet,
3. δ: Q × Σ−→Q is the transition function,1
4. q0 ∈Q is the start state, and
5. F ⊆Q is the set of accept states.2
1Refer back to page 7 if you are uncertain about the meaning of δ: Q × Σ−→Q.
2Accept states sometimes are called ﬁnal states.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

36
CHAPTER 1 / REGULAR LANGUAGES
The formal deﬁnition precisely describes what we mean by a ﬁnite automa-
ton. For example, returning to the earlier question of whether 0 accept states is
allowable, you can see that setting F to be the empty set ∅yields 0 accept states,
which is allowable. Furthermore, the transition function δ speciﬁes exactly one
next state for each possible combination of a state and an input symbol. That an-
swers our other question afﬁrmatively, showing that exactly one transition arrow
exits every state for each possible input symbol.
We can use the notation of the formal deﬁnition to describe individual ﬁnite
automata by specifying each of the ﬁve parts listed in Deﬁnition 1.5. For exam-
ple, let’s return to the ﬁnite automaton M1 we discussed earlier, redrawn here
for convenience.
FIGURE
1.6
The ﬁnite automaton M1
We can describe M1 formally by writing M1 = (Q, Σ, δ, q1, F), where
1. Q = {q1, q2, q3},
2. Σ = {0,1},
3. δ is described as
0
1
q1
q1
q2
q2
q3
q2
q3
q2
q2,
4. q1 is the start state, and
5. F = {q2}.
If A is the set of all strings that machine M accepts, we say that A is the
language of machine M and write L(M) = A. We say that M recognizes A or
that M accepts A. Because the term accept has different meanings when we refer
to machines accepting strings and machines accepting languages, we prefer the
term recognize for languages in order to avoid confusion.
A machine may accept several strings, but it always recognizes only one lan-
guage.
If the machine accepts no strings, it still recognizes one language—
namely, the empty language ∅.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.1
FINITE AUTOMATA
37
In our example, let
A = {w| w contains at least one 1 and
an even number of 0s follow the last 1}.
Then L(M1) = A, or equivalently, M1 recognizes A.
EXAMPLES OF FINITE AUTOMATA
EXAMPLE
1.7
Here is the state diagram of ﬁnite automaton M2.
FIGURE
1.8
State diagram of the two-state ﬁnite automaton M2
In the formal description, M2 is
 {q1, q2}, {0,1}, δ, q1, {q2}

. The transition
function δ is
0
1
q1
q1
q2
q2
q1
q2.
Remember that the state diagram of M2 and the formal description of M2
contain the same information, only in different forms. You can always go from
one to the other if necessary.
A good way to begin understanding any machine is to try it on some sample
input strings. When you do these “experiments” to see how the machine is
working, its method of functioning often becomes apparent. On the sample
string 1101, the machine M2 starts in its start state q1 and proceeds ﬁrst to state
q2 after reading the ﬁrst 1, and then to states q2, q1, and q2 after reading 1, 0,
and 1. The string is accepted because q2 is an accept state. But string 110 leaves
M2 in state q1, so it is rejected. After trying a few more examples, you would see
that M2 accepts all strings that end in a 1. Thus L(M2) = {w| w ends in a 1}.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

38
CHAPTER 1 / REGULAR LANGUAGES
EXAMPLE
1.9
Consider the ﬁnite automaton M3.
FIGURE
1.10
State diagram of the two-state ﬁnite automaton M3
Machine M3 is similar to M2 except for the location of the accept state. As
usual, the machine accepts all strings that leave it in an accept state when it has
ﬁnished reading. Note that because the start state is also an accept state, M3
accepts the empty string ε. As soon as a machine begins reading the empty
string, it is at the end; so if the start state is an accept state, ε is accepted. In
addition to the empty string, this machine accepts any string ending with a 0.
Here,
L(M3) = {w| w is the empty string ε or ends in a 0}.
EXAMPLE
1.11
The following ﬁgure shows a ﬁve-state machine M4.
FIGURE
1.12
Finite automaton M4
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.1
FINITE AUTOMATA
39
Machine M4 has two accept states, q1 and r1, and operates over the alphabet
Σ = {a, b}. Some experimentation shows that it accepts strings a, b, aa, bb, and
bab, but not strings ab, ba, or bbba. This machine begins in state s, and after
it reads the ﬁrst symbol in the input, it goes either left into the q states or right
into the r states. In both cases, it can never return to the start state (in contrast
to the previous examples), as it has no way to get from any other state back to s.
If the ﬁrst symbol in the input string is a, then it goes left and accepts when the
string ends with an a. Similarly, if the ﬁrst symbol is a b, the machine goes right
and accepts when the string ends in b. So M4 accepts all strings that start and
end with a or that start and end with b. In other words, M4 accepts strings that
start and end with the same symbol.
EXAMPLE
1.13
Figure 1.14 shows the three-state machine M5, which has a four-symbol input
alphabet, Σ = {⟨RESET⟩, 0, 1, 2}. We treat ⟨RESET⟩as a single symbol.
FIGURE
1.14
Finite automaton M5
Machine M5 keeps a running count of the sum of the numerical input symbols
it reads, modulo 3. Every time it receives the ⟨RESET⟩symbol, it resets the count
to 0. It accepts if the sum is 0 modulo 3, or in other words, if the sum is a multiple
of 3.
Describing a ﬁnite automaton by state diagram is not possible in some cases.
That may occur when the diagram would be too big to draw or if, as in the next
example, the description depends on some unspeciﬁed parameter. In these cases,
we resort to a formal description to specify the machine.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

40
CHAPTER 1 / REGULAR LANGUAGES
EXAMPLE
1.15
Consider a generalization of Example 1.13, using the same four-symbol alpha-
bet Σ. For each i ≥1 let Ai be the language of all strings where the sum of the
numbers is a multiple of i, except that the sum is reset to 0 whenever the symbol
⟨RESET⟩appears. For each Ai we give a ﬁnite automaton Bi, recognizing Ai.
We describe the machine Bi formally as follows:
Bi = (Qi, Σ, δi, q0, {q0}),
where Qi is the set of i states {q0, q1, q2, . . . , qi−1}, and we design the transi-
tion function δi so that for each j, if Bi is in qj, the running sum is j, modulo i.
For each qj let
δi(qj, 0) = qj,
δi(qj, 1) = qk, where k = j + 1 modulo i,
δi(qj, 2) = qk, where k = j + 2 modulo i, and
δi(qj, ⟨RESET⟩) = q0.
FORMAL DEFINITION OF COMPUTATION
So far we have described ﬁnite automata informally, using state diagrams, and
with a formal deﬁnition, as a 5-tuple. The informal description is easier to grasp
at ﬁrst, but the formal deﬁnition is useful for making the notion precise, resolv-
ing any ambiguities that may have occurred in the informal description. Next we
do the same for a ﬁnite automaton’s computation. We already have an informal
idea of the way it computes, and we now formalize it mathematically.
Let M = (Q, Σ, δ, q0, F) be a ﬁnite automaton and let w = w1w2 · · · wn be
a string where each wi is a member of the alphabet Σ. Then M accepts w if a
sequence of states r0, r1, . . . , rn in Q exists with three conditions:
1. r0 = q0,
2. δ(ri, wi+1) = ri+1, for i = 0, . . . , n −1, and
3. rn ∈F.
Condition 1 says that the machine starts in the start state. Condition 2 says
that the machine goes from state to state according to the transition function.
Condition 3 says that the machine accepts its input if it ends up in an accept
state. We say that M recognizes language A if A = {w| M accepts w}.
DEFINITION
1.16
A language is called a regular language if some ﬁnite automaton
recognizes it.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.1
FINITE AUTOMATA
41
EXAMPLE
1.17
Take machine M5 from Example 1.13. Let w be the string
10⟨RESET⟩22⟨RESET⟩012.
Then M5 accepts w according to the formal deﬁnition of computation because
the sequence of states it enters when computing on w is
q0, q1, q1, q0, q2, q1, q0, q0, q1, q0,
which satisﬁes the three conditions. The language of M5 is
L(M5) = {w| the sum of the symbols in w is 0 modulo 3,
except that ⟨RESET⟩resets the count to 0}.
As M5 recognizes this language, it is a regular language.
DESIGNING FINITE AUTOMATA
Whether it be of automaton or artwork, design is a creative process. As such,
it cannot be reduced to a simple recipe or formula. However, you might ﬁnd
a particular approach helpful when designing various types of automata. That
is, put yourself in the place of the machine you are trying to design and then see
how you would go about performing the machine’s task. Pretending that you are
the machine is a psychological trick that helps engage your whole mind in the
design process.
Let’s design a ﬁnite automaton using the “reader as automaton” method just
described. Suppose that you are given some language and want to design a ﬁnite
automaton that recognizes it. Pretending to be the automaton, you receive an
input string and must determine whether it is a member of the language the
automaton is supposed to recognize. You get to see the symbols in the string
one by one. After each symbol, you must decide whether the string seen so far is
in the language. The reason is that you, like the machine, don’t know when the
end of the string is coming, so you must always be ready with the answer.
First, in order to make these decisions, you have to ﬁgure out what you need
to remember about the string as you are reading it. Why not simply remember
all you have seen? Bear in mind that you are pretending to be a ﬁnite automaton
and that this type of machine has only a ﬁnite number of states, which means
a ﬁnite memory. Imagine that the input is extremely long—say, from here to
the moon—so that you could not possibly remember the entire thing. You have
a ﬁnite memory—say, a single sheet of paper—which has a limited storage ca-
pacity. Fortunately, for many languages you don’t need to remember the entire
input. You need to remember only certain crucial information. Exactly which
information is crucial depends on the particular language considered.
For example, suppose that the alphabet is {0,1} and that the language consists
of all strings with an odd number of 1s. You want to construct a ﬁnite automaton
E1 to recognize this language. Pretending to be the automaton, you start getting
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

42
CHAPTER 1 / REGULAR LANGUAGES
an input string of 0s and 1s symbol by symbol. Do you need to remember the
entire string seen so far in order to determine whether the number of 1s is odd?
Of course not. Simply remember whether the number of 1s seen so far is even
or odd and keep track of this information as you read new symbols. If you read
a 1, ﬂip the answer; but if you read a 0, leave the answer as is.
But how does this help you design E1? Once you have determined the neces-
sary information to remember about the string as it is being read, you represent
this information as a ﬁnite list of possibilities. In this instance, the possibilities
would be
1. even so far, and
2. odd so far.
Then you assign a state to each of the possibilities. These are the states of E1, as
shown here.
FIGURE
1.18
The two states qeven and qodd
Next, you assign the transitions by seeing how to go from one possibility to
another upon reading a symbol. So, if state qeven represents the even possibility
and state qodd represents the odd possibility, you would set the transitions to ﬂip
state on a 1 and stay put on a 0, as shown here.
FIGURE
1.19
Transitions telling how the possibilities rearrange
Next, you set the start state to be the state corresponding to the possibility
associated with having seen 0 symbols so far (the empty string ε). In this case,
the start state corresponds to state qeven because 0 is an even number. Last, set
the accept states to be those corresponding to possibilities where you want to
accept the input string. Set qodd to be an accept state because you want to accept
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.1
FINITE AUTOMATA
43
when you have seen an odd number of 1s. These additions are shown in the
following ﬁgure.
FIGURE
1.20
Adding the start and accept states
EXAMPLE
1.21
This example shows how to design a ﬁnite automaton E2 to recognize the regu-
lar language of all strings that contain the string 001 as a substring. For example,
0010, 1001, 001, and 11111110011111 are all in the language, but 11 and 0000
are not. How would you recognize this language if you were pretending to
be E2? As symbols come in, you would initially skip over all 1s. If you come
to a 0, then you note that you may have just seen the ﬁrst of the three symbols
in the pattern 001 you are seeking. If at this point you see a 1, there were too
few 0s, so you go back to skipping over 1s. But if you see a 0 at that point, you
should remember that you have just seen two symbols of the pattern. Now you
simply need to continue scanning until you see a 1. If you ﬁnd it, remember that
you succeeded in ﬁnding the pattern and continue reading the input string until
you get to the end.
So there are four possibilities: You
1. haven’t just seen any symbols of the pattern,
2. have just seen a 0,
3. have just seen 00, or
4. have seen the entire pattern 001.
Assign the states q, q0, q00, and q001 to these possibilities. You can assign the
transitions by observing that from q reading a 1 you stay in q, but reading a 0 you
move to q0. In q0 reading a 1 you return to q, but reading a 0 you move to q00.
In q00 reading a 1 you move to q001, but reading a 0 leaves you in q00. Finally, in
q001 reading a 0 or a 1 leaves you in q001. The start state is q, and the only accept
state is q001, as shown in Figure 1.22.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

44
CHAPTER 1 / REGULAR LANGUAGES
FIGURE
1.22
Accepts strings containing 001
THE REGULAR OPERATIONS
In the preceding two sections, we introduced and deﬁned ﬁnite automata and
regular languages. We now begin to investigate their properties. Doing so will
help develop a toolbox of techniques for designing automata to recognize partic-
ular languages. The toolbox also will include ways of proving that certain other
languages are nonregular (i.e., beyond the capability of ﬁnite automata).
In arithmetic, the basic objects are numbers and the tools are operations for
manipulating them, such as + and ×. In the theory of computation, the ob-
jects are languages and the tools include operations speciﬁcally designed for
manipulating them. We deﬁne three operations on languages, called the reg-
ular operations, and use them to study properties of the regular languages.
DEFINITION
1.23
Let A and B be languages. We deﬁne the regular operations union,
concatenation, and star as follows:
• Union: A ∪B = {x| x ∈A or x ∈B}.
• Concatenation: A ◦B = {xy| x ∈A and y ∈B}.
• Star: A∗= {x1x2 . . . xk| k ≥0 and each xi ∈A}.
You are already familiar with the union operation. It simply takes all the
strings in both A and B and lumps them together into one language.
The concatenation operation is a little trickier. It attaches a string from A
in front of a string from B in all possible ways to get the strings in the new
language.
The star operation is a bit different from the other two because it applies to
a single language rather than to two different languages. That is, the star oper-
ation is a unary operation instead of a binary operation. It works by attaching
any number of strings in A together to get a string in the new language. Because
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.1
FINITE AUTOMATA
45
“any number” includes 0 as a possibility, the empty string ε is always a member
of A∗, no matter what A is.
EXAMPLE
1.24
Let the alphabet Σ be the standard 26 letters {a, b, . . . , z}. If A = {good, bad}
and B = {boy, girl}, then
A ∪B = {good, bad, boy, girl},
A ◦B = {goodboy, goodgirl, badboy, badgirl}, and
A∗= {ε, good, bad, goodgood, goodbad, badgood, badbad,
goodgoodgood, goodgoodbad, goodbadgood, goodbadbad, . . . }.
Let N = {1, 2, 3, . . .} be the set of natural numbers. When we say that N
is closed under multiplication, we mean that for any x and y in N, the product
x × y also is in N. In contrast, N is not closed under division, as 1 and 2 are
in N but 1/2 is not. Generally speaking, a collection of objects is closed under
some operation if applying that operation to members of the collection returns
an object still in the collection. We show that the collection of regular languages
is closed under all three of the regular operations. In Section 1.3, we show that
these are useful tools for manipulating regular languages and understanding the
power of ﬁnite automata. We begin with the union operation.
THEOREM
1.25
The class of regular languages is closed under the union operation.
In other words, if A1 and A2 are regular languages, so is A1 ∪A2.
PROOF IDEA
We have regular languages A1 and A2 and want to show that
A1 ∪A2 also is regular. Because A1 and A2 are regular, we know that some ﬁnite
automaton M1 recognizes A1 and some ﬁnite automaton M2 recognizes A2. To
prove that A1 ∪A2 is regular, we demonstrate a ﬁnite automaton, call it M, that
recognizes A1 ∪A2.
This is a proof by construction. We construct M from M1 and M2. Machine
M must accept its input exactly when either M1 or M2 would accept it in order
to recognize the union language. It works by simulating both M1 and M2 and
accepting if either of the simulations accept.
How can we make machine M simulate M1 and M2? Perhaps it ﬁrst simulates
M1 on the input and then simulates M2 on the input. But we must be careful
here! Once the symbols of the input have been read and used to simulate M1,
we can’t “rewind the input tape” to try the simulation on M2. We need another
approach.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

46
CHAPTER 1 / REGULAR LANGUAGES
Pretend that you are M. As the input symbols arrive one by one, you simulate
both M1 and M2 simultaneously. That way, only one pass through the input is
necessary. But can you keep track of both simulations with ﬁnite memory? All
you need to remember is the state that each machine would be in if it had read
up to this point in the input. Therefore, you need to remember a pair of states.
How many possible pairs are there? If M1 has k1 states and M2 has k2 states, the
number of pairs of states, one from M1 and the other from M2, is the product
k1 × k2. This product will be the number of states in M, one for each pair. The
transitions of M go from pair to pair, updating the current state for both M1 and
M2. The accept states of M are those pairs wherein either M1 or M2 is in an
accept state.
PROOF
Let M1 recognize A1, where M1 = (Q1, Σ, δ1, q1, F1), and
M2 recognize A2, where M2 = (Q2, Σ, δ2, q2, F2).
Construct M to recognize A1 ∪A2, where M = (Q, Σ, δ, q0, F).
1. Q = {(r1, r2)| r1 ∈Q1 and r2 ∈Q2}.
This set is the Cartesian product of sets Q1 and Q2 and is written Q1 ×Q2.
It is the set of all pairs of states, the ﬁrst from Q1 and the second from Q2.
2. Σ, the alphabet, is the same as in M1 and M2. In this theorem and in all
subsequent similar theorems, we assume for simplicity that both M1 and
M2 have the same input alphabet Σ. The theorem remains true if they
have different alphabets, Σ1 and Σ2. We would then modify the proof to
let Σ = Σ1 ∪Σ2.
3. δ, the transition function, is deﬁned as follows. For each (r1, r2) ∈Q and
each a ∈Σ, let
δ
 (r1, r2), a

=
 δ1(r1, a), δ2(r2, a)

.
Hence δ gets a state of M (which actually is a pair of states from M1 and
M2), together with an input symbol, and returns M’s next state.
4. q0 is the pair (q1, q2).
5. F is the set of pairs in which either member is an accept state of M1 or M2.
We can write it as
F = {(r1, r2)| r1 ∈F1 or r2 ∈F2}.
This expression is the same as F = (F1 × Q2) ∪(Q1 × F2). (Note that it is
not the same as F = F1 × F2. What would that give us instead?3)
3 This expression would deﬁne M’s accept states to be those for which both members of
the pair are accept states. In this case, M would accept a string only if both M1 and M2
accept it, so the resulting language would be the intersection and not the union. In fact,
this result proves that the class of regular languages is closed under intersection.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.2
NONDETERMINISM
47
This concludes the construction of the ﬁnite automaton M that recognizes
the union of A1 and A2. This construction is fairly simple, and thus its correct-
ness is evident from the strategy described in the proof idea. More complicated
constructions require additional discussion to prove correctness. A formal cor-
rectness proof for a construction of this type usually proceeds by induction. For
an example of a construction proved correct, see the proof of Theorem 1.54.
Most of the constructions that you will encounter in this course are fairly simple
and so do not require a formal correctness proof.
We have just shown that the union of two regular languages is regular, thereby
proving that the class of regular languages is closed under the union operation.
We now turn to the concatenation operation and attempt to show that the class
of regular languages is closed under that operation, too.
THEOREM
1.26
The class of regular languages is closed under the concatenation operation.
In other words, if A1 and A2 are regular languages then so is A1 ◦A2.
To prove this theorem, let’s try something along the lines of the proof of the
union case. As before, we can start with ﬁnite automata M1 and M2 recognizing
the regular languages A1 and A2. But now, instead of constructing automaton
M to accept its input if either M1 or M2 accept, it must accept if its input can
be broken into two pieces, where M1 accepts the ﬁrst piece and M2 accepts the
second piece. The problem is that M doesn’t know where to break its input
(i.e., where the ﬁrst part ends and the second begins). To solve this problem, we
introduce a new technique called nondeterminism.
1.2
NONDETERMINISM
Nondeterminism is a useful concept that has had great impact on the theory of
computation. So far in our discussion, every step of a computation follows in a
unique way from the preceding step. When the machine is in a given state and
reads the next input symbol, we know what the next state will be—it is deter-
mined. We call this deterministic computation. In a nondeterministic machine,
several choices may exist for the next state at any point.
Nondeterminism is a generalization of determinism, so every deterministic
ﬁnite automaton is automatically a nondeterministic ﬁnite automaton. As Fig-
ure 1.27 shows, nondeterministic ﬁnite automata may have additional features.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

48
CHAPTER 1 / REGULAR LANGUAGES
FIGURE
1.27
The nondeterministic ﬁnite automaton N1
The difference between a deterministic ﬁnite automaton, abbreviated DFA,
and a nondeterministic ﬁnite automaton, abbreviated NFA, is immediately ap-
parent. First, every state of a DFA always has exactly one exiting transition arrow
for each symbol in the alphabet. The NFA shown in Figure 1.27 violates that
rule. State q1 has one exiting arrow for 0, but it has two for 1; q2 has one arrow
for 0, but it has none for 1. In an NFA, a state may have zero, one, or many
exiting arrows for each alphabet symbol.
Second, in a DFA, labels on the transition arrows are symbols from the alpha-
bet. This NFA has an arrow with the label ε. In general, an NFA may have arrows
labeled with members of the alphabet or ε. Zero, one, or many arrows may exit
from each state with the label ε.
How does an NFA compute? Suppose that we are running an NFA on an input
string and come to a state with multiple ways to proceed. For example, say that
we are in state q1 in NFA N1 and that the next input symbol is a 1. After reading
that symbol, the machine splits into multiple copies of itself and follows all the
possibilities in parallel. Each copy of the machine takes one of the possible ways
to proceed and continues as before. If there are subsequent choices, the machine
splits again. If the next input symbol doesn’t appear on any of the arrows exiting
the state occupied by a copy of the machine, that copy of the machine dies, along
with the branch of the computation associated with it. Finally, if any one of these
copies of the machine is in an accept state at the end of the input, the NFA accepts
the input string.
If a state with an ε symbol on an exiting arrow is encountered, something
similar happens. Without reading any input, the machine splits into multiple
copies, one following each of the exiting ε-labeled arrows and one staying at the
current state. Then the machine proceeds nondeterministically as before.
Nondeterminism may be viewed as a kind of parallel computation wherein
multiple independent “processes” or “threads” can be running concurrently.
When the NFA splits to follow several choices, that corresponds to a process
“forking” into several children, each proceeding separately. If at least one of
these processes accepts, then the entire computation accepts.
Another way to think of a nondeterministic computation is as a tree of possi-
bilities. The root of the tree corresponds to the start of the computation. Every
branching point in the tree corresponds to a point in the computation at which
the machine has multiple choices. The machine accepts if at least one of the
computation branches ends in an accept state, as shown in Figure 1.28.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.2
NONDETERMINISM
49
FIGURE
1.28
Deterministic and nondeterministic computations with an accepting
branch
Let’s consider some sample runs of the NFA N1 shown in Figure 1.27. The
computation of N1 on input 010110 is depicted in the following ﬁgure.
FIGURE
1.29
The computation of N1 on input 010110
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

50
CHAPTER 1 / REGULAR LANGUAGES
On input 010110, start in the start state q1 and read the ﬁrst symbol 0. From
q1 there is only one place to go on a 0—namely, back to q1—so remain there.
Next, read the second symbol 1. In q1 on a 1 there are two choices: either stay in
q1 or move to q2. Nondeterministically, the machine splits in two to follow each
choice. Keep track of the possibilities by placing a ﬁnger on each state where a
machine could be. So you now have ﬁngers on states q1 and q2. An ε arrow exits
state q2 so the machine splits again; keep one ﬁnger on q2, and move the other
to q3. You now have ﬁngers on q1, q2, and q3.
When the third symbol 0 is read, take each ﬁnger in turn. Keep the ﬁnger
on q1 in place, move the ﬁnger on q2 to q3, and remove the ﬁnger that has been
on q3. That last ﬁnger had no 0 arrow to follow and corresponds to a process
that simply “dies.” At this point, you have ﬁngers on states q1 and q3.
When the fourth symbol 1 is read, split the ﬁnger on q1 into ﬁngers on states
q1 and q2, then further split the ﬁnger on q2 to follow the ε arrow to q3, and
move the ﬁnger that was on q3 to q4. You now have a ﬁnger on each of the four
states.
When the ﬁfth symbol 1 is read, the ﬁngers on q1 and q3 result in ﬁngers on
states q1, q2, q3, and q4, as you saw with the fourth symbol. The ﬁnger on state
q2 is removed. The ﬁnger that was on q4 stays on q4. Now you have two ﬁngers
on q4, so remove one because you only need to remember that q4 is a possible
state at this point, not that it is possible for multiple reasons.
When the sixth and ﬁnal symbol 0 is read, keep the ﬁnger on q1 in place,
move the one on q2 to q3, remove the one that was on q3, and leave the one on
q4 in place. You are now at the end of the string, and you accept if some ﬁnger is
on an accept state. You have ﬁngers on states q1, q3, and q4; and as q4 is an accept
state, N1 accepts this string.
What does N1 do on input 010? Start with a ﬁnger on q1. After reading the
0, you still have a ﬁnger only on q1; but after the 1 there are ﬁngers on q1, q2,
and q3 (don’t forget the ε arrow). After the third symbol 0, remove the ﬁnger
on q3, move the ﬁnger on q2 to q3, and leave the ﬁnger on q1 where it is. At this
point you are at the end of the input; and as no ﬁnger is on an accept state, N1
rejects this input.
By continuing to experiment in this way, you will see that N1 accepts all
strings that contain either 101 or 11 as a substring.
Nondeterministic ﬁnite automata are useful in several respects. As we will
show, every NFA can be converted into an equivalent DFA, and constructing
NFAs is sometimes easier than directly constructing DFAs. An NFA may be much
smaller than its deterministic counterpart, or its functioning may be easier to
understand.
Nondeterminism in ﬁnite automata is also a good introduction
to nondeterminism in more powerful computational models because ﬁnite au-
tomata are especially easy to understand. Now we turn to several examples of
NFAs.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.2
NONDETERMINISM
51
EXAMPLE
1.30
Let A be the language consisting of all strings over {0,1} containing a 1 in the
third position from the end (e.g., 000100 is in A but 0011 is not). The following
four-state NFA N2 recognizes A.
FIGURE
1.31
The NFA N2 recognizing A
One good way to view the computation of this NFA is to say that it stays in the
start state q1 until it “guesses” that it is three places from the end. At that point,
if the input symbol is a 1, it branches to state q2 and uses q3 and q4 to “check” on
whether its guess was correct.
As mentioned, every NFA can be converted into an equivalent DFA; but some-
times that DFA may have many more states. The smallest DFA for A contains
eight states. Furthermore, understanding the functioning of the NFA is much
easier, as you may see by examining the following ﬁgure for the DFA.
FIGURE
1.32
A DFA recognizing A
Suppose that we added ε to the labels on the arrows going from q2 to q3 and
from q3 to q4 in machine N2 in Figure 1.31. So both arrows would then have
the label 0, 1, ε instead of just 0, 1. What language would N2 recognize with this
modiﬁcation? Try modifying the DFA in Figure 1.32 to recognize that language.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

52
CHAPTER 1 / REGULAR LANGUAGES
EXAMPLE
1.33
The following NFA N3 has an input alphabet {0} consisting of a single symbol.
An alphabet containing only one symbol is called a unary alphabet.
FIGURE
1.34
The NFA N3
This machine demonstrates the convenience of having ε arrows. It accepts
all strings of the form 0k where k is a multiple of 2 or 3. (Remember that the
superscript denotes repetition, not numerical exponentiation.) For example, N3
accepts the strings ε, 00, 000, 0000, and 000000, but not 0 or 00000.
Think of the machine operating by initially guessing whether to test for a
multiple of 2 or a multiple of 3 by branching into either the top loop or the bot-
tom loop and then checking whether its guess was correct. Of course, we could
replace this machine by one that doesn’t have ε arrows or even any nondeter-
minism at all, but the machine shown is the easiest one to understand for this
language.
EXAMPLE
1.35
We give another example of an NFA in Figure 1.36. Practice with it to satisfy
yourself that it accepts the strings ε, a, baba, and baa, but that it doesn’t ac-
cept the strings b, bb, and babba. Later we use this machine to illustrate the
procedure for converting NFAs to DFAs.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.2
NONDETERMINISM
53
FIGURE
1.36
The NFA N4
FORMAL DEFINITION OF A
NONDETERMINISTIC FINITE AUTOMATON
The formal deﬁnition of a nondeterministic ﬁnite automaton is similar to that of
a deterministic ﬁnite automaton. Both have states, an input alphabet, a transition
function, a start state, and a collection of accept states. However, they differ in
one essential way: in the type of transition function. In a DFA, the transition
function takes a state and an input symbol and produces the next state. In an
NFA, the transition function takes a state and an input symbol or the empty string
and produces the set of possible next states. In order to write the formal deﬁnition,
we need to set up some additional notation. For any set Q we write P(Q) to be
the collection of all subsets of Q. Here P(Q) is called the power set of Q. For any
alphabet Σ we write Σε to be Σ ∪{ε}. Now we can write the formal description
of the type of the transition function in an NFA as δ: Q × Σε−→P(Q).
DEFINITION
1.37
A nondeterministic ﬁnite automaton is a 5-tuple (Q, Σ, δ, q0, F),
where
1. Q is a ﬁnite set of states,
2. Σ is a ﬁnite alphabet,
3. δ: Q × Σε−→P(Q) is the transition function,
4. q0 ∈Q is the start state, and
5. F ⊆Q is the set of accept states.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

54
CHAPTER 1 / REGULAR LANGUAGES
EXAMPLE
1.38
Recall the NFA N1:
The formal description of N1 is (Q, Σ, δ, q1, F), where
1. Q = {q1, q2, q3, q4},
2. Σ = {0,1},
3. δ is given as
0
1
ε
q1
{q1}
{q1, q2}
∅
q2
{q3}
∅
{q3}
q3
∅
{q4}
∅
q4
{q4}
{q4}
∅,
4. q1 is the start state, and
5. F = {q4}.
The formal deﬁnition of computation for an NFA is similar to that for a DFA.
Let N = (Q, Σ, δ, q0, F) be an NFA and w a string over the alphabet Σ. Then
we say that N accepts w if we can write w as w = y1y2 · · · ym, where each yi
is a member of Σε and a sequence of states r0, r1, . . . , rm exists in Q with three
conditions:
1. r0 = q0,
2. ri+1 ∈δ(ri, yi+1), for i = 0, . . . , m −1, and
3. rm ∈F.
Condition 1 says that the machine starts out in the start state. Condition 2 says
that state ri+1 is one of the allowable next states when N is in state ri and reading
yi+1. Observe that δ(ri, yi+1) is the set of allowable next states and so we say that
ri+1 is a member of that set. Finally, condition 3 says that the machine accepts
its input if the last state is an accept state.
EQUIVALENCE OF NFAS AND DFAS
Deterministic and nondeterministic ﬁnite automata recognize the same class of
languages. Such equivalence is both surprising and useful. It is surprising be-
cause NFAs appear to have more power than DFAs, so we might expect that NFAs
recognize more languages. It is useful because describing an NFA for a given
language sometimes is much easier than describing a DFA for that language.
Say that two machines are equivalent if they recognize the same language.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.2
NONDETERMINISM
55
THEOREM
1.39
Every nondeterministic ﬁnite automaton has an equivalent deterministic ﬁnite
automaton.
PROOF IDEA
If a language is recognized by an NFA, then we must show the
existence of a DFA that also recognizes it. The idea is to convert the NFA into an
equivalent DFA that simulates the NFA.
Recall the “reader as automaton” strategy for designing ﬁnite automata. How
would you simulate the NFA if you were pretending to be a DFA? What do you
need to keep track of as the input string is processed? In the examples of NFAs,
you kept track of the various branches of the computation by placing a ﬁnger
on each state that could be active at given points in the input. You updated the
simulation by moving, adding, and removing ﬁngers according to the way the
NFA operates. All you needed to keep track of was the set of states having ﬁngers
on them.
If k is the number of states of the NFA, it has 2k subsets of states. Each subset
corresponds to one of the possibilities that the DFA must remember, so the DFA
simulating the NFA will have 2k states. Now we need to ﬁgure out which will
be the start state and accept states of the DFA, and what will be its transition
function. We can discuss this more easily after setting up some formal notation.
PROOF
Let N = (Q, Σ, δ, q0, F) be the NFA recognizing some language A.
We construct a DFA M = (Q′, Σ, δ′, q0′, F ′) recognizing A. Before doing the full
construction, let’s ﬁrst consider the easier case wherein N has no ε arrows. Later
we take the ε arrows into account.
1. Q′ = P(Q).
Every state of M is a set of states of N. Recall that P(Q) is the set of
subsets of Q.
2. For R ∈Q′ and a ∈Σ, let δ′(R, a) = {q ∈Q| q ∈δ(r, a) for some r ∈R}.
If R is a state of M, it is also a set of states of N. When M reads a symbol
a in state R, it shows where a takes each state in R. Because each state may
go to a set of states, we take the union of all these sets. Another way to
write this expression is
δ′(R, a) =
[
r∈R
δ(r, a).4
3. q0′ = {q0}.
M starts in the state corresponding to the collection containing just the
start state of N.
4. F ′ = {R ∈Q′| R contains an accept state of N}.
The machine M accepts if one of the possible states that N could be in at
this point is an accept state.
4The notation
[
r∈R
δ(r, a) means: the union of the sets δ(r, a) for each possible r in R.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

56
CHAPTER 1 / REGULAR LANGUAGES
Now we need to consider the ε arrows. To do so, we set up an extra bit of
notation. For any state R of M, we deﬁne E(R) to be the collection of states
that can be reached from members of R by going only along ε arrows, including
the members of R themselves. Formally, for R ⊆Q let
E(R) = {q| q can be reached from R by traveling along 0 or more ε arrows}.
Then we modify the transition function of M to place additional ﬁngers on all
states that can be reached by going along ε arrows after every step. Replacing
δ(r, a) by E(δ(r, a)) achieves this effect. Thus
δ′(R, a) = {q ∈Q| q ∈E(δ(r, a)) for some r ∈R}.
Additionally, we need to modify the start state of M to move the ﬁngers ini-
tially to all possible states that can be reached from the start state of N along
the ε arrows. Changing q0′ to be E({q0}) achieves this effect. We have now
completed the construction of the DFA M that simulates the NFA N.
The construction of M obviously works correctly. At every step in the com-
putation of M on an input, it clearly enters a state that corresponds to the subset
of states that N could be in at that point. Thus our proof is complete.
Theorem 1.39 states that every NFA can be converted into an equivalent DFA.
Thus nondeterministic ﬁnite automata give an alternative way of characterizing
the regular languages. We state this fact as a corollary of Theorem 1.39.
COROLLARY
1.40
A language is regular if and only if some nondeterministic ﬁnite automaton rec-
ognizes it.
One direction of the “if and only if” condition states that a language is regular
if some NFA recognizes it. Theorem 1.39 shows that any NFA can be converted
into an equivalent DFA. Consequently, if an NFA recognizes some language, so
does some DFA, and hence the language is regular. The other direction of the
“if and only if” condition states that a language is regular only if some NFA rec-
ognizes it. That is, if a language is regular, some NFA must be recognizing it.
Obviously, this condition is true because a regular language has a DFA recogniz-
ing it and any DFA is also an NFA.
EXAMPLE
1.41
Let’s illustrate the procedure we gave in the proof of Theorem 1.39 for convert-
ing an NFA to a DFA by using the machine N4 that appears in Example 1.35. For
clarity, we have relabeled the states of N4 to be {1, 2, 3}. Thus in the formal
description of N4 = (Q, {a,b}, δ, 1, {1}), the set of states Q is {1, 2, 3} as shown
in Figure 1.42.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.2
NONDETERMINISM
57
To construct a DFA D that is equivalent to N4, we ﬁrst determine D’s states.
N4 has three states, {1, 2, 3}, so we construct D with eight states, one for each
subset of N4’s states. We label each of D’s states with the corresponding subset.
Thus D’s state set is

∅, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}
	
.
FIGURE
1.42
The NFA N4
Next, we determine the start and accept states of D. The start state is E({1}),
the set of states that are reachable from 1 by traveling along ε arrows, plus 1
itself. An ε arrow goes from 1 to 3, so E({1}) = {1, 3}. The new accept states
are those containing N4’s accept state; thus

{1}, {1,2}, {1,3}, {1,2,3}
	
.
Finally, we determine D’s transition function. Each of D’s states goes to one
place on input a and one place on input b. We illustrate the process of deter-
mining the placement of D’s transition arrows with a few examples.
In D, state {2} goes to {2,3} on input a because in N4, state 2 goes to both 2
and 3 on input a and we can’t go farther from 2 or 3 along ε arrows. State {2}
goes to state {3} on input b because in N4, state 2 goes only to state 3 on input
b and we can’t go farther from 3 along ε arrows.
State {1} goes to ∅on a because no a arrows exit it. It goes to {2} on b.
Note that the procedure in Theorem 1.39 speciﬁes that we follow the ε arrows
after each input symbol is read. An alternative procedure based on following the
ε arrows before reading each input symbol works equally well, but that method
is not illustrated in this example.
State {3} goes to {1,3} on a because in N4, state 3 goes to 1 on a and 1 in
turn goes to 3 with an ε arrow. State {3} on b goes to ∅.
State {1,2} on a goes to {2,3} because 1 points at no states with a arrows,
2 points at both 2 and 3 with a arrows, and neither points anywhere with ε ar-
rows. State {1,2} on b goes to {2,3}. Continuing in this way, we obtain the
diagram for D in Figure 1.43.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

58
CHAPTER 1 / REGULAR LANGUAGES
FIGURE
1.43
A DFA D that is equivalent to the NFA N4
We may simplify this machine by observing that no arrows point at states {1}
and {1, 2}, so they may be removed without affecting the performance of the
machine. Doing so yields the following ﬁgure.
FIGURE
1.44
DFA D after removing unnecessary states
CLOSURE UNDER THE REGULAR OPERATIONS
Now we return to the closure of the class of regular languages under the regular
operations that we began in Section 1.1. Our aim is to prove that the union,
concatenation, and star of regular languages are still regular. We abandoned the
original attempt to do so when dealing with the concatenation operation was too
complicated. The use of nondeterminism makes the proofs much easier.
First, let’s consider again closure under union. Earlier we proved closure
under union by simulating deterministically both machines simultaneously via
a Cartesian product construction. We now give a new proof to illustrate the
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.2
NONDETERMINISM
59
technique of nondeterminism. Reviewing the ﬁrst proof, appearing on page 45,
may be worthwhile to see how much easier and more intuitive the new proof is.
THEOREM
1.45
The class of regular languages is closed under the union operation.
PROOF IDEA
We have regular languages A1 and A2 and want to prove that
A1 ∪A2 is regular. The idea is to take two NFAs, N1 and N2 for A1 and A2, and
combine them into one new NFA, N.
Machine N must accept its input if either N1 or N2 accepts this input. The
new machine has a new start state that branches to the start states of the old ma-
chines with ε arrows. In this way, the new machine nondeterministically guesses
which of the two machines accepts the input. If one of them accepts the input,
N will accept it, too.
We represent this construction in the following ﬁgure. On the left, we in-
dicate the start and accept states of machines N1 and N2 with large circles and
some additional states with small circles. On the right, we show how to combine
N1 and N2 into N by adding additional transition arrows.
FIGURE
1.46
Construction of an NFA N to recognize A1 ∪A2
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

60
CHAPTER 1 / REGULAR LANGUAGES
PROOF
Let N1 = (Q1, Σ, δ1, q1, F1) recognize A1, and
N2 = (Q2, Σ, δ2, q2, F2) recognize A2.
Construct N = (Q, Σ, δ, q0, F) to recognize A1 ∪A2.
1. Q = {q0} ∪Q1 ∪Q2.
The states of N are all the states of N1 and N2, with the addition of a new
start state q0.
2. The state q0 is the start state of N.
3. The set of accept states F = F1 ∪F2.
The accept states of N are all the accept states of N1 and N2. That way, N
accepts if either N1 accepts or N2 accepts.
4. Deﬁne δ so that for any q ∈Q and any a ∈Σε,
δ(q, a) =









δ1(q, a)
q ∈Q1
δ2(q, a)
q ∈Q2
{q1, q2}
q = q0 and a = ε
∅
q = q0 and a ̸= ε.
Now we can prove closure under concatenation. Recall that earlier, without
nondeterminism, completing the proof would have been difﬁcult.
THEOREM
1.47
The class of regular languages is closed under the concatenation operation.
PROOF IDEA
We have regular languages A1 and A2 and want to prove that
A1 ◦A2 is regular. The idea is to take two NFAs, N1 and N2 for A1 and A2, and
combine them into a new NFA N as we did for the case of union, but this time
in a different way, as shown in Figure 1.48.
Assign N’s start state to be the start state of N1. The accept states of N1 have
additional ε arrows that nondeterministically allow branching to N2 whenever
N1 is in an accept state, signifying that it has found an initial piece of the input
that constitutes a string in A1. The accept states of N are the accept states of N2
only. Therefore, it accepts when the input can be split into two parts, the ﬁrst
accepted by N1 and the second by N2. We can think of N as nondeterministically
guessing where to make the split.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.2
NONDETERMINISM
61
FIGURE
1.48
Construction of N to recognize A1 ◦A2
PROOF
Let N1 = (Q1, Σ, δ1, q1, F1) recognize A1, and
N2 = (Q2, Σ, δ2, q2, F2) recognize A2.
Construct N = (Q, Σ, δ, q1, F2) to recognize A1 ◦A2.
1. Q = Q1 ∪Q2.
The states of N are all the states of N1 and N2.
2. The state q1 is the same as the start state of N1.
3. The accept states F2 are the same as the accept states of N2.
4. Deﬁne δ so that for any q ∈Q and any a ∈Σε,
δ(q, a) =









δ1(q, a)
q ∈Q1 and q ̸∈F1
δ1(q, a)
q ∈F1 and a ̸= ε
δ1(q, a) ∪{q2}
q ∈F1 and a = ε
δ2(q, a)
q ∈Q2.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

62
CHAPTER 1 / REGULAR LANGUAGES
THEOREM
1.49
The class of regular languages is closed under the star operation.
PROOF IDEA
We have a regular language A1 and want to prove that A∗
1 also
is regular. We take an NFA N1 for A1 and modify it to recognize A∗
1, as shown in
the following ﬁgure. The resulting NFA N will accept its input whenever it can
be broken into several pieces and N1 accepts each piece.
We can construct N like N1 with additional ε arrows returning to the start
state from the accept states. This way, when processing gets to the end of a piece
that N1 accepts, the machine N has the option of jumping back to the start state
to try to read another piece that N1 accepts. In addition, we must modify N
so that it accepts ε, which always is a member of A∗
1. One (slightly bad) idea is
simply to add the start state to the set of accept states. This approach certainly
adds ε to the recognized language, but it may also add other, undesired strings.
Exercise 1.15 asks for an example of the failure of this idea. The way to ﬁx it is
to add a new start state, which also is an accept state, and which has an ε arrow
to the old start state. This solution has the desired effect of adding ε to the
language without adding anything else.
FIGURE
1.50
Construction of N to recognize A∗
PROOF
Let N1 = (Q1, Σ, δ1, q1, F1) recognize A1.
Construct N = (Q, Σ, δ, q0, F) to recognize A∗
1.
1. Q = {q0} ∪Q1.
The states of N are the states of N1 plus a new start state.
2. The state q0 is the new start state.
3. F = {q0} ∪F1.
The accept states are the old accept states plus the new start state.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.3
REGULAR EXPRESSIONS
63
4. Deﬁne δ so that for any q ∈Q and any a ∈Σε,
δ(q, a) =















δ1(q, a)
q ∈Q1 and q ̸∈F1
δ1(q, a)
q ∈F1 and a ̸= ε
δ1(q, a) ∪{q1}
q ∈F1 and a = ε
{q1}
q = q0 and a = ε
∅
q = q0 and a ̸= ε.
1.3
REGULAR EXPRESSIONS
In arithmetic, we can use the operations + and × to build up expressions such as
(5 + 3) × 4 .
Similarly, we can use the regular operations to build up expressions describing
languages, which are called regular expressions. An example is:
(0 ∪1)0∗.
The value of the arithmetic expression is the number 32. The value of a regular
expression is a language. In this case, the value is the language consisting of all
strings starting with a 0 or a 1 followed by any number of 0s. We get this result by
dissecting the expression into its parts. First, the symbols 0 and 1 are shorthand
for the sets {0} and {1}. So (0 ∪1) means ({0} ∪{1}). The value of this part
is the language {0,1}. The part 0∗means {0}∗, and its value is the language
consisting of all strings containing any number of 0s. Second, like the × symbol
in algebra, the concatenation symbol ◦often is implicit in regular expressions.
Thus (0 ∪1)0∗actually is shorthand for (0 ∪1)◦0∗. The concatenation attaches
the strings from the two parts to obtain the value of the entire expression.
Regular expressions have an important role in computer science applications.
In applications involving text, users may want to search for strings that satisfy
certain patterns. Regular expressions provide a powerful method for describing
such patterns. Utilities such as awk and grep in UNIX, modern programming
languages such as Perl, and text editors all provide mechanisms for the descrip-
tion of patterns by using regular expressions.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

64
CHAPTER 1 / REGULAR LANGUAGES
EXAMPLE
1.51
Another example of a regular expression is
(0 ∪1)∗.
It starts with the language (0 ∪1) and applies the ∗operation. The value of
this expression is the language consisting of all possible strings of 0s and 1s. If
Σ = {0,1}, we can write Σ as shorthand for the regular expression (0∪1). More
generally, if Σ is any alphabet, the regular expression Σ describes the language
consisting of all strings of length 1 over this alphabet, and Σ∗describes the lan-
guage consisting of all strings over that alphabet. Similarly, Σ∗1 is the language
that contains all strings that end in a 1. The language (0Σ∗) ∪(Σ∗1) consists of
all strings that start with a 0 or end with a 1.
In arithmetic, we say that × has precedence over + to mean that when there
is a choice, we do the × operation ﬁrst. Thus in 2+3×4, the 3×4 is done before
the addition. To have the addition done ﬁrst, we must add parentheses to obtain
(2 + 3) × 4. In regular expressions, the star operation is done ﬁrst, followed by
concatenation, and ﬁnally union, unless parentheses change the usual order.
FORMAL DEFINITION OF A REGULAR EXPRESSION
DEFINITION
1.52
Say that R is a regular expression if R is
1. a for some a in the alphabet Σ,
2. ε,
3. ∅,
4. (R1 ∪R2), where R1 and R2 are regular expressions,
5. (R1 ◦R2), where R1 and R2 are regular expressions, or
6. (R∗
1), where R1 is a regular expression.
In items 1 and 2, the regular expressions a and ε represent the
languages {a} and {ε}, respectively. In item 3, the regular expres-
sion ∅represents the empty language. In items 4, 5, and 6, the
expressions represent the languages obtained by taking the union
or concatenation of the languages R1 and R2, or the star of the
language R1, respectively.
Don’t confuse the regular expressions ε and ∅. The expression ε represents
the language containing a single string—namely, the empty string—whereas ∅
represents the language that doesn’t contain any strings.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.3
REGULAR EXPRESSIONS
65
Seemingly, we are in danger of deﬁning the notion of a regular expression
in terms of itself. If true, we would have a circular deﬁnition, which would be
invalid. However, R1 and R2 always are smaller than R. Thus we actually are
deﬁning regular expressions in terms of smaller regular expressions and thereby
avoiding circularity. A deﬁnition of this type is called an inductive deﬁnition.
Parentheses in an expression may be omitted. If they are, evaluation is done
in the precedence order: star, then concatenation, then union.
For convenience, we let R+ be shorthand for RR∗. In other words, whereas
R∗has all strings that are 0 or more concatenations of strings from R, the lan-
guage R+ has all strings that are 1 or more concatenations of strings from R. So
R+ ∪ε = R∗. In addition, we let Rk be shorthand for the concatenation of k R’s
with each other.
When we want to distinguish between a regular expression R and the lan-
guage that it describes, we write L(R) to be the language of R.
EXAMPLE
1.53
In the following instances, we assume that the alphabet Σ is {0,1}.
1. 0∗10∗= {w| w contains a single 1}.
2. Σ∗1Σ∗= {w| w has at least one 1}.
3. Σ∗001Σ∗= {w| w contains the string 001 as a substring}.
4. 1∗(01+)∗= {w| every 0 in w is followed by at least one 1}.
5. (ΣΣ)∗= {w| w is a string of even length}.5
6. (ΣΣΣ)∗= {w| the length of w is a multiple of 3}.
7. 01 ∪10 = {01, 10}.
8. 0Σ∗0 ∪1Σ∗1 ∪0 ∪1 = {w| w starts and ends with the same symbol}.
9. (0 ∪ε)1∗= 01∗∪1∗.
The expression 0 ∪ε describes the language {0, ε}, so the concatenation
operation adds either 0 or ε before every string in 1∗.
10. (0 ∪ε)(1 ∪ε) = {ε, 0, 1, 01}.
11. 1∗∅= ∅.
Concatenating the empty set to any set yields the empty set.
12. ∅∗= {ε}.
The star operation puts together any number of strings from the language
to get a string in the result. If the language is empty, the star operation can
put together 0 strings, giving only the empty string.
5The length of a string is the number of symbols that it contains.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

66
CHAPTER 1 / REGULAR LANGUAGES
If we let R be any regular expression, we have the following identities. They
are good tests of whether you understand the deﬁnition.
R ∪∅= R.
Adding the empty language to any other language will not change it.
R ◦ε = R.
Joining the empty string to any string will not change it.
However, exchanging ∅and ε in the preceding identities may cause the equalities
to fail.
R ∪ε may not equal R.
For example, if R = 0, then L(R) = {0} but L(R ∪ε) = {0, ε}.
R ◦∅may not equal R.
For example, if R = 0, then L(R) = {0} but L(R ◦∅) = ∅.
Regular expressions are useful tools in the design of compilers for program-
ming languages. Elemental objects in a programming language, called tokens,
such as the variable names and constants, may be described with regular ex-
pressions. For example, a numerical constant that may include a fractional part
and/or a sign may be described as a member of the language
 + ∪- ∪ε
  D+ ∪D+.D∗∪D∗.D+
where D = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} is the alphabet of decimal digits. Examples
of generated strings are: 72, 3.14159, +7., and -.01.
Once the syntax of a programming language has been described with a regular
expression in terms of its tokens, automatic systems can generate the lexical
analyzer, the part of a compiler that initially processes the input program.
EQUIVALENCE WITH FINITE AUTOMATA
Regular expressions and ﬁnite automata are equivalent in their descriptive
power. This fact is surprising because ﬁnite automata and regular expressions
superﬁcially appear to be rather different. However, any regular expression can
be converted into a ﬁnite automaton that recognizes the language it describes,
and vice versa. Recall that a regular language is one that is recognized by some
ﬁnite automaton.
THEOREM
1.54
A language is regular if and only if some regular expression describes it.
This theorem has two directions. We state and prove each direction as a separate
lemma.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.3
REGULAR EXPRESSIONS
67
LEMMA
1.55
If a language is described by a regular expression, then it is regular.
PROOF IDEA
Say that we have a regular expression R describing some lan-
guage A. We show how to convert R into an NFA recognizing A. By Corol-
lary 1.40, if an NFA recognizes A then A is regular.
PROOF
Let’s convert R into an NFA N. We consider the six cases in the
formal deﬁnition of regular expressions.
1. R = a for some a ∈Σ. Then L(R) = {a}, and the following NFA recog-
nizes L(R).
Note that this machine ﬁts the deﬁnition of an NFA but not that of
a DFA because it has some states with no exiting arrow for each possible
input symbol. Of course, we could have presented an equivalent DFA here;
but an NFA is all we need for now, and it is easier to describe.
Formally, N =
 {q1, q2}, Σ, δ, q1, {q2}

, where we describe δ by saying
that δ(q1, a) = {q2} and that δ(r, b) = ∅for r ̸= q1 or b ̸= a.
2. R = ε. Then L(R) = {ε}, and the following NFA recognizes L(R).
Formally, N =
 {q1}, Σ, δ, q1, {q1}

, where δ(r, b) = ∅for any r and b.
3. R = ∅. Then L(R) = ∅, and the following NFA recognizes L(R).
Formally, N =
 {q}, Σ, δ, q, ∅

, where δ(r, b) = ∅for any r and b.
4. R = R1 ∪R2.
5. R = R1 ◦R2.
6. R = R∗
1.
For the last three cases, we use the constructions given in the proofs that the
class of regular languages is closed under the regular operations. In other words,
we construct the NFA for R from the NFAs for R1 and R2 (or just R1 in case 6)
and the appropriate closure construction.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

68
CHAPTER 1 / REGULAR LANGUAGES
That ends the ﬁrst part of the proof of Theorem 1.54, giving the easier di-
rection of the if and only if condition. Before going on to the other direction,
let’s consider some examples whereby we use this procedure to convert a regular
expression to an NFA.
EXAMPLE
1.56
We convert the regular expression (ab ∪a)∗to an NFA in a sequence of stages.
We build up from the smallest subexpressions to larger subexpressions until we
have an NFA for the original expression, as shown in the following diagram.
Note that this procedure generally doesn’t give the NFA with the fewest states.
In this example, the procedure gives an NFA with eight states, but the smallest
equivalent NFA has only two states. Can you ﬁnd it?
FIGURE
1.57
Building an NFA from the regular expression (ab ∪a)∗
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.3
REGULAR EXPRESSIONS
69
EXAMPLE
1.58
In Figure 1.59, we convert the regular expression (a ∪b)∗aba to an NFA. A few
of the minor steps are not shown.
FIGURE
1.59
Building an NFA from the regular expression (a ∪b)∗aba
Now let’s turn to the other direction of the proof of Theorem 1.54.
LEMMA
1.60
If a language is regular, then it is described by a regular expression.
PROOF IDEA
We need to show that if a language A is regular, a regular
expression describes it. Because A is regular, it is accepted by a DFA. We describe
a procedure for converting DFAs into equivalent regular expressions.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

70
CHAPTER 1 / REGULAR LANGUAGES
We break this procedure into two parts, using a new type of ﬁnite automaton
called a generalized nondeterministic ﬁnite automaton, GNFA. First we show
how to convert DFAs into GNFAs, and then GNFAs into regular expressions.
Generalized nondeterministic ﬁnite automata are simply nondeterministic ﬁ-
nite automata wherein the transition arrows may have any regular expressions as
labels, instead of only members of the alphabet or ε. The GNFA reads blocks of
symbols from the input, not necessarily just one symbol at a time as in an ordi-
nary NFA. The GNFA moves along a transition arrow connecting two states by
reading a block of symbols from the input, which themselves constitute a string
described by the regular expression on that arrow. A GNFA is nondeterministic
and so may have several different ways to process the same input string. It ac-
cepts its input if its processing can cause the GNFA to be in an accept state at the
end of the input. The following ﬁgure presents an example of a GNFA.
FIGURE
1.61
A generalized nondeterministic ﬁnite automaton
For convenience, we require that GNFAs always have a special form that meets
the following conditions.
• The start state has transition arrows going to every other state but no arrows
coming in from any other state.
• There is only a single accept state, and it has arrows coming in from every
other state but no arrows going to any other state. Furthermore, the accept
state is not the same as the start state.
• Except for the start and accept states, one arrow goes from every state to
every other state and also from each state to itself.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.3
REGULAR EXPRESSIONS
71
We can easily convert a DFA into a GNFA in the special form. We simply add a
new start state with an ε arrow to the old start state and a new accept state with ε
arrows from the old accept states. If any arrows have multiple labels (or if there
are multiple arrows going between the same two states in the same direction), we
replace each with a single arrow whose label is the union of the previous labels.
Finally, we add arrows labeled ∅between states that had no arrows. This last
step won’t change the language recognized because a transition labeled with ∅
can never be used. From here on we assume that all GNFAs are in the special
form.
Now we show how to convert a GNFA into a regular expression. Say that the
GNFA has k states. Then, because a GNFA must have a start and an accept state
and they must be different from each other, we know that k ≥2. If k > 2, we
construct an equivalent GNFA with k −1 states. This step can be repeated on
the new GNFA until it is reduced to two states. If k = 2, the GNFA has a single
arrow that goes from the start state to the accept state. The label of this arrow
is the equivalent regular expression. For example, the stages in converting a DFA
with three states to an equivalent regular expression are shown in the following
ﬁgure.
FIGURE
1.62
Typical stages in converting a DFA to a regular expression
The crucial step is constructing an equivalent GNFA with one fewer state
when k > 2. We do so by selecting a state, ripping it out of the machine, and
repairing the remainder so that the same language is still recognized. Any state
will do, provided that it is not the start or accept state. We are guaranteed that
such a state will exist because k > 2. Let’s call the removed state qrip.
After removing qrip we repair the machine by altering the regular expressions
that label each of the remaining arrows. The new labels compensate for the
absence of qrip by adding back the lost computations. The new label going from
a state qi to a state qj is a regular expression that describes all strings that would
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

72
CHAPTER 1 / REGULAR LANGUAGES
take the machine from qi to qj either directly or via qrip. We illustrate this
approach in Figure 1.63.
FIGURE
1.63
Constructing an equivalent GNFA with one fewer state
In the old machine, if
1. qi goes to qrip with an arrow labeled R1,
2. qrip goes to itself with an arrow labeled R2,
3. qrip goes to qj with an arrow labeled R3, and
4. qi goes to qj with an arrow labeled R4,
then in the new machine, the arrow from qi to qj gets the label
(R1)(R2)∗(R3) ∪(R4).
We make this change for each arrow going from any state qi to any state qj,
including the case where qi = qj. The new machine recognizes the original
language.
PROOF
Let’s now carry out this idea formally. First, to facilitate the proof,
we formally deﬁne the new type of automaton introduced. A GNFA is similar
to a nondeterministic ﬁnite automaton except for the transition function, which
has the form
δ:
 Q −{qaccept}

×
 Q −{qstart}

−→R.
The symbol R is the collection of all regular expressions over the alphabet Σ,
and qstart and qaccept are the start and accept states. If δ(qi, qj) = R, the arrow
from state qi to state qj has the regular expression R as its label. The domain
of the transition function is
 Q −{qaccept}

×
 Q −{qstart}

because an arrow
connects every state to every other state, except that no arrows are coming from
qaccept or going to qstart.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.3
REGULAR EXPRESSIONS
73
DEFINITION
1.64
A generalized nondeterministic ﬁnite automaton is a 5-tuple,
(Q, Σ, δ, qstart, qaccept), where
1. Q is the ﬁnite set of states,
2. Σ is the input alphabet,
3. δ:
 Q −{qaccept}

×
 Q −{qstart}

−→R is the transition
function,
4. qstart is the start state, and
5. qaccept is the accept state.
A GNFA accepts a string w in Σ∗if w = w1w2 · · · wk, where each wi is in Σ∗
and a sequence of states q0, q1, . . . , qk exists such that
1. q0 = qstart is the start state,
2. qk = qaccept is the accept state, and
3. for each i, we have wi ∈L(Ri), where Ri = δ(qi−1, qi); in other words, Ri
is the expression on the arrow from qi−1 to qi.
Returning to the proof of Lemma 1.60, we let M be the DFA for language
A. Then we convert M to a GNFA G by adding a new start state and a new
accept state and additional transition arrows as necessary. We use the procedure
CONVERT(G), which takes a GNFA and returns an equivalent regular expression.
This procedure uses recursion, which means that it calls itself. An inﬁnite loop
is avoided because the procedure calls itself only to process a GNFA that has
one fewer state. The case where the GNFA has two states is handled without
recursion.
CONVERT(G):
1. Let k be the number of states of G.
2. If k = 2, then G must consist of a start state, an accept state, and a single
arrow connecting them and labeled with a regular expression R.
Return the expression R.
3. If k > 2, we select any state qrip ∈Q different from qstart and qaccept and let
G′ be the GNFA (Q′, Σ, δ′, qstart, qaccept), where
Q′ = Q −{qrip},
and for any qi ∈Q′ −{qaccept} and any qj ∈Q′ −{qstart}, let
δ′(qi, qj) = (R1)(R2)∗(R3) ∪(R4),
for R1 = δ(qi, qrip), R2 = δ(qrip, qrip), R3 = δ(qrip, qj), and R4 = δ(qi, qj).
4. Compute CONVERT(G′) and return this value.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

74
CHAPTER 1 / REGULAR LANGUAGES
Next we prove that CONVERT returns a correct value.
CLAIM
1.65
For any GNFA G, CONVERT(G) is equivalent to G.
We prove this claim by induction on k, the number of states of the GNFA.
Basis: Prove the claim true for k = 2 states. If G has only two states, it can
have only a single arrow, which goes from the start state to the accept state. The
regular expression label on this arrow describes all the strings that allow G to get
to the accept state. Hence this expression is equivalent to G.
Induction step: Assume that the claim is true for k −1 states and use this as-
sumption to prove that the claim is true for k states. First we show that G and
G′ recognize the same language. Suppose that G accepts an input w. Then in an
accepting branch of the computation, G enters a sequence of states:
qstart, q1, q2, q3, . . . , qaccept.
If none of them is the removed state qrip, clearly G′ also accepts w. The reason
is that each of the new regular expressions labeling the arrows of G′ contains the
old regular expression as part of a union.
If qrip does appear, removing each run of consecutive qrip states forms an
accepting computation for G′. The states qi and qj bracketing a run have a new
regular expression on the arrow between them that describes all strings taking qi
to qj via qrip on G. So G′ accepts w.
Conversely, suppose that G′ accepts an input w. As each arrow between any
two states qi and qj in G′ describes the collection of strings taking qi to qj in G,
either directly or via qrip, G must also accept w. Thus G and G′ are equivalent.
The induction hypothesis states that when the algorithm calls itself recur-
sively on input G′, the result is a regular expression that is equivalent to G′
because G′ has k −1 states. Hence this regular expression also is equivalent to
G, and the algorithm is proved correct.
This concludes the proof of Claim 1.65, Lemma 1.60, and Theorem 1.54.
EXAMPLE
1.66
In this example, we use the preceding algorithm to convert a DFA into a regular
expression. We begin with the two-state DFA in Figure 1.67(a).
In Figure 1.67(b), we make a four-state GNFA by adding a new start state and
a new accept state, called s and a instead of qstart and qaccept so that we can draw
them conveniently. To avoid cluttering up the ﬁgure, we do not draw the arrows
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.3
REGULAR EXPRESSIONS
75
labeled ∅, even though they are present. Note that we replace the label a, b on
the self-loop at state 2 on the DFA with the label a∪b at the corresponding point
on the GNFA. We do so because the DFA’s label represents two transitions, one
for a and the other for b, whereas the GNFA may have only a single transition
going from 2 to itself.
In Figure 1.67(c), we remove state 2 and update the remaining arrow labels.
In this case, the only label that changes is the one from 1 to a. In part (b) it was
∅, but in part (c) it is b(a ∪b)∗. We obtain this result by following step 3 of the
CONVERT procedure. State qi is state 1, state qj is a, and qrip is 2, so R1 = b,
R2 = a ∪b, R3 = ε, and R4 = ∅. Therefore, the new label on the arrow from 1
to a is (b)(a ∪b)∗(ε) ∪∅. We simplify this regular expression to b(a ∪b)∗.
In Figure 1.67(d), we remove state 1 from part (c) and follow the same pro-
cedure. Because only the start and accept states remain, the label on the arrow
joining them is the regular expression that is equivalent to the original DFA.
FIGURE
1.67
Converting a two-state DFA to an equivalent regular expression
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

76
CHAPTER 1 / REGULAR LANGUAGES
EXAMPLE
1.68
In this example, we begin with a three-state DFA. The steps in the conversion are
shown in the following ﬁgure.
  
  
  
  
  
  
 
  
FIGURE
1.69
Converting a three-state DFA to an equivalent regular expression
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.4
NONREGULAR LANGUAGES
77
1.4
NONREGULAR LANGUAGES
To understand the power of ﬁnite automata, you must also understand their
limitations. In this section, we show how to prove that certain languages cannot
be recognized by any ﬁnite automaton.
Let’s take the language B = {0n1n| n ≥0}. If we attempt to ﬁnd a DFA
that recognizes B, we discover that the machine seems to need to remember
how many 0s have been seen so far as it reads the input. Because the number of
0s isn’t limited, the machine will have to keep track of an unlimited number of
possibilities. But it cannot do so with any ﬁnite number of states.
Next, we present a method for proving that languages such as B are not regu-
lar. Doesn’t the argument already given prove nonregularity because the number
of 0s is unlimited? It does not. Just because the language appears to require un-
bounded memory doesn’t mean that it is necessarily so. It does happen to be true
for the language B; but other languages seem to require an unlimited number of
possibilities, yet actually they are regular. For example, consider two languages
over the alphabet Σ = {0,1}:
C = {w| w has an equal number of 0s and 1s}, and
D = {w| w has an equal number of occurrences of 01 and 10 as substrings}.
At ﬁrst glance, a recognizing machine appears to need to count in each case,
and therefore neither language appears to be regular. As expected, C is not
regular, but surprisingly D is regular!6 Thus our intuition can sometimes lead
us astray, which is why we need mathematical proofs for certainty. In this section,
we show how to prove that certain languages are not regular.
THE PUMPING LEMMA FOR REGULAR LANGUAGES
Our technique for proving nonregularity stems from a theorem about regular
languages, traditionally called the pumping lemma. This theorem states that all
regular languages have a special property. If we can show that a language does
not have this property, we are guaranteed that it is not regular. The property
states that all strings in the language can be “pumped” if they are at least as
long as a certain special value, called the pumping length. That means each
such string contains a section that can be repeated any number of times with the
resulting string remaining in the language.
6See Problem 1.48.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

78
CHAPTER 1 / REGULAR LANGUAGES
THEOREM
1.70
Pumping lemma
If A is a regular language, then there is a number p (the
pumping length) where if s is any string in A of length at least p, then s may be
divided into three pieces, s = xyz, satisfying the following conditions:
1. for each i ≥0, xyiz ∈A,
2. |y| > 0, and
3. |xy| ≤p.
Recall the notation where |s| represents the length of string s, yi means that i
copies of y are concatenated together, and y0 equals ε.
When s is divided into xyz, either x or z may be ε, but condition 2 says that
y ̸= ε. Observe that without condition 2 the theorem would be trivially true.
Condition 3 states that the pieces x and y together have length at most p. It is an
extra technical condition that we occasionally ﬁnd useful when proving certain
languages to be nonregular. See Example 1.74 for an application of condition 3.
PROOF IDEA
Let M = (Q, Σ, δ, q1, F) be a DFA that recognizes A. We assign
the pumping length p to be the number of states of M. We show that any string
s in A of length at least p may be broken into the three pieces xyz, satisfying our
three conditions. What if no strings in A are of length at least p? Then our task
is even easier because the theorem becomes vacuously true: Obviously the three
conditions hold for all strings of length at least p if there aren’t any such strings.
If s in A has length at least p, consider the sequence of states that M goes
through when computing with input s. It starts with q1 the start state, then goes
to, say, q3, then, say, q20, then q9, and so on, until it reaches the end of s in state
q13. With s in A, we know that M accepts s, so q13 is an accept state.
If we let n be the length of s, the sequence of states q1, q3, q20, q9, . . . , q13 has
length n + 1. Because n is at least p, we know that n + 1 is greater than p, the
number of states of M. Therefore, the sequence must contain a repeated state.
This result is an example of the pigeonhole principle, a fancy name for the rather
obvious fact that if p pigeons are placed into fewer than p holes, some hole has
to have more than one pigeon in it.
The following ﬁgure shows the string s and the sequence of states that M
goes through when processing s. State q9 is the one that repeats.
   
  
  
  
  
  
FIGURE
1.71
Example showing state q9 repeating when M reads s
We now divide s into the three pieces x, y, and z. Piece x is the part of s
appearing before q9, piece y is the part between the two appearances of q9, and
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.4
NONREGULAR LANGUAGES
79
piece z is the remaining part of s, coming after the second occurrence of q9. So
x takes M from the state q1 to q9, y takes M from q9 back to q9, and z takes M
from q9 to the accept state q13, as shown in the following ﬁgure.
FIGURE
1.72
Example showing how the strings x, y, and z affect M
Let’s see why this division of s satisﬁes the three conditions. Suppose that we
run M on input xyyz. We know that x takes M from q1 to q9, and then the ﬁrst
y takes it from q9 back to q9, as does the second y, and then z takes it to q13.
With q13 being an accept state, M accepts input xyyz. Similarly, it will accept
xyiz for any i > 0. For the case i = 0, xyiz = xz, which is accepted for similar
reasons. That establishes condition 1.
Checking condition 2, we see that |y| > 0, as it was the part of s that occurred
between two different occurrences of state q9.
In order to get condition 3, we make sure that q9 is the ﬁrst repetition in the
sequence. By the pigeonhole principle, the ﬁrst p+1 states in the sequence must
contain a repetition. Therefore, |xy| ≤p.
PROOF
Let M = (Q, Σ, δ, q1, F) be a DFA recognizing A and p be the number
of states of M.
Let s = s1s2 · · · sn be a string in A of length n, where n ≥p. Let r1, . . . , rn+1
be the sequence of states that M enters while processing s, so ri+1 = δ(ri, si)
for 1 ≤i ≤n. This sequence has length n + 1, which is at least p + 1. Among
the ﬁrst p + 1 elements in the sequence, two must be the same state, by the
pigeonhole principle. We call the ﬁrst of these rj and the second rl. Because rl
occurs among the ﬁrst p+1 places in a sequence starting at r1, we have l ≤p+1.
Now let x = s1 · · · sj−1, y = sj · · · sl−1, and z = sl · · · sn.
As x takes M from r1 to rj, y takes M from rj to rj, and z takes M from rj
to rn+1, which is an accept state, M must accept xyiz for i ≥0. We know that
j ̸= l, so |y| > 0; and l ≤p+1, so |xy| ≤p. Thus we have satisﬁed all conditions
of the pumping lemma.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

80
CHAPTER 1 / REGULAR LANGUAGES
To use the pumping lemma to prove that a language B is not regular, ﬁrst as-
sume that B is regular in order to obtain a contradiction. Then use the pumping
lemma to guarantee the existence of a pumping length p such that all strings of
length p or greater in B can be pumped. Next, ﬁnd a string s in B that has length
p or greater but that cannot be pumped. Finally, demonstrate that s cannot be
pumped by considering all ways of dividing s into x, y, and z (taking condition 3
of the pumping lemma into account if convenient) and, for each such division,
ﬁnding a value i where xyiz ̸∈B. This ﬁnal step often involves grouping the
various ways of dividing s into several cases and analyzing them individually.
The existence of s contradicts the pumping lemma if B were regular. Hence B
cannot be regular.
Finding s sometimes takes a bit of creative thinking. You may need to hunt
through several candidates for s before you discover one that works. Try mem-
bers of B that seem to exhibit the “essence” of B’s nonregularity. We further
discuss the task of ﬁnding s in some of the following examples.
EXAMPLE
1.73
Let B be the language {0n1n|n ≥0}. We use the pumping lemma to prove that
B is not regular. The proof is by contradiction.
Assume to the contrary that B is regular. Let p be the pumping length given
by the pumping lemma. Choose s to be the string 0p1p. Because s is a member
of B and s has length more than p, the pumping lemma guarantees that s can be
split into three pieces, s = xyz, where for any i ≥0 the string xyiz is in B. We
consider three cases to show that this result is impossible.
1. The string y consists only of 0s. In this case, the string xyyz has more 0s
than 1s and so is not a member of B, violating condition 1 of the pumping
lemma. This case is a contradiction.
2. The string y consists only of 1s. This case also gives a contradiction.
3. The string y consists of both 0s and 1s. In this case, the string xyyz may
have the same number of 0s and 1s, but they will be out of order with some
1s before 0s. Hence it is not a member of B, which is a contradiction.
Thus a contradiction is unavoidable if we make the assumption that B is reg-
ular, so B is not regular. Note that we can simplify this argument by applying
condition 3 of the pumping lemma to eliminate cases 2 and 3.
In this example, ﬁnding the string s was easy because any string in B of
length p or more would work. In the next two examples, some choices for s
do not work so additional care is required.
EXAMPLE
1.74
Let C = {w| w has an equal number of 0s and 1s}. We use the pumping lemma
to prove that C is not regular. The proof is by contradiction.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

1.4
NONREGULAR LANGUAGES
81
Assume to the contrary that C is regular. Let p be the pumping length given
by the pumping lemma. As in Example 1.73, let s be the string 0p1p. With
s being a member of C and having length more than p, the pumping lemma
guarantees that s can be split into three pieces, s = xyz, where for any i ≥0 the
string xyiz is in C. We would like to show that this outcome is impossible. But
wait, it is possible! If we let x and z be the empty string and y be the string 0p1p,
then xyiz always has an equal number of 0s and 1s and hence is in C. So it seems
that s can be pumped.
Here condition 3 in the pumping lemma is useful. It stipulates that when
pumping s, it must be divided so that |xy| ≤p. That restriction on the way that
s may be divided makes it easier to show that the string s = 0p1p we selected
cannot be pumped. If |xy| ≤p, then y must consist only of 0s, so xyyz ̸∈C.
Therefore, s cannot be pumped. That gives us the desired contradiction.
Selecting the string s in this example required more care than in Exam-
ple 1.73. If we had chosen s = (01)p instead, we would have run into trouble
because we need a string that cannot be pumped and that string can be pumped,
even taking condition 3 into account. Can you see how to pump it? One way to
do so sets x = ε, y = 01, and z = (01)p−1. Then xyiz ∈C for every value of
i. If you fail on your ﬁrst attempt to ﬁnd a string that cannot be pumped, don’t
despair. Try another one!
An alternative method of proving that C is nonregular follows from our
knowledge that B is nonregular. If C were regular, C ∩0∗1∗also would be
regular. The reasons are that the language 0∗1∗is regular and that the class of
regular languages is closed under intersection, which we proved in footnote 3
(page 46). But C ∩0∗1∗equals B, and we know that B is nonregular from
Example 1.73.
EXAMPLE
1.75
Let F = {ww| w ∈{0,1}∗}. We show that F is nonregular, using the pumping
lemma.
Assume to the contrary that F is regular. Let p be the pumping length given
by the pumping lemma. Let s be the string 0p10p1. Because s is a member of
F and s has length more than p, the pumping lemma guarantees that s can be
split into three pieces, s = xyz, satisfying the three conditions of the lemma.
We show that this outcome is impossible.
Condition 3 is once again crucial because without it we could pump s if we
let x and z be the empty string. With condition 3 the proof follows because y
must consist only of 0s, so xyyz ̸∈F.
Observe that we chose s = 0p10p1 to be a string that exhibits the “essence” of
the nonregularity of F, as opposed to, say, the string 0p0p. Even though 0p0p is
a member of F, it fails to demonstrate a contradiction because it can be pumped.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

82
CHAPTER 1 / REGULAR LANGUAGES
EXAMPLE
1.76
Here we demonstrate a nonregular unary language. Let D = {1n2| n ≥0}.
In other words, D contains all strings of 1s whose length is a perfect square.
We use the pumping lemma to prove that D is not regular. The proof is by
contradiction.
Assume to the contrary that D is regular. Let p be the pumping length given
by the pumping lemma. Let s be the string 1p2. Because s is a member of D and
s has length at least p, the pumping lemma guarantees that s can be split into
three pieces, s = xyz, where for any i ≥0 the string xyiz is in D. As in the
preceding examples, we show that this outcome is impossible. Doing so in this
case requires a little thought about the sequence of perfect squares:
0, 1, 4, 9, 16, 25, 36, 49, . . .
Note the growing gap between successive members of this sequence. Large
members of this sequence cannot be near each other.
Now consider the two strings xyz and xy2z. These strings differ from each
other by a single repetition of y, and consequently their lengths differ by the
length of y. By condition 3 of the pumping lemma, |xy| ≤p and thus |y| ≤p.
We have |xyz| = p2 and so |xy2z| ≤p2 + p. But p2 + p < p2 +2p+1 = (p+1)2.
Moreover, condition 2 implies that y is not the empty string and so |xy2z| >
p2. Therefore, the length of xy2z lies strictly between the consecutive perfect
squares p2 and (p + 1)2. Hence this length cannot be a perfect square itself. So
we arrive at the contradiction xy2z ̸∈D and conclude that D is not regular.
EXAMPLE
1.77
Sometimes “pumping down” is useful when we apply the pumping lemma. We
use the pumping lemma to show that E = {0i1j| i > j} is not regular. The
proof is by contradiction.
Assume that E is regular. Let p be the pumping length for E given by the
pumping lemma. Let s = 0p+11p. Then s can be split into xyz, satisfying the
conditions of the pumping lemma. By condition 3, y consists only of 0s. Let’s
examine the string xyyz to see whether it can be in E. Adding an extra copy
of y increases the number of 0s. But, E contains all strings in 0∗1∗that have
more 0s than 1s, so increasing the number of 0s will still give a string in E. No
contradiction occurs. We need to try something else.
The pumping lemma states that xyiz ∈E even when i = 0, so let’s consider
the string xy0z = xz. Removing string y decreases the number of 0s in s. Recall
that s has just one more 0 than 1. Therefore, xz cannot have more 0s than 1s,
so it cannot be a member of E. Thus we obtain a contradiction.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

EXERCISES
83
EXERCISES
A1.1 The following are the state diagrams of two DFAs, M1 and M2. Answer the follow-
ing questions about each of these machines.
a. What is the start state?
b. What is the set of accept states?
c. What sequence of states does the machine go through on input aabb?
d. Does the machine accept the string aabb?
e. Does the machine accept the string ε?
A1.2 Give the formal description of the machines M1 and M2 pictured in Exercise 1.1.
1.3 The formal description of a DFA M is
 {q1, q2, q3, q4, q5}, {u, d}, δ, q3, {q3}

,
where δ is given by the following table. Give the state diagram of this machine.
u
d
q1
q1
q2
q2
q1
q3
q3
q2
q4
q4
q3
q5
q5
q4
q5
1.4 Each of the following languages is the intersection of two simpler languages. In
each part, construct DFAs for the simpler languages, then combine them using the
construction discussed in footnote 3 (page 46) to give the state diagram of a DFA
for the language given. In all parts, Σ = {a, b}.
a. {w| w has at least three a’s and at least two b’s}
Ab. {w| w has exactly two a’s and at least two b’s}
c. {w| w has an even number of a’s and one or two b’s}
Ad. {w| w has an even number of a’s and each a is followed by at least one b}
e. {w| w starts with an a and has at most one b}
f. {w| w has an odd number of a’s and ends with a b}
g. {w| w has even length and an odd number of a’s}
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

84
CHAPTER 1 / REGULAR LANGUAGES
1.5 Each of the following languages is the complement of a simpler language. In each
part, construct a DFA for the simpler language, then use it to give the state diagram
of a DFA for the language given. In all parts, Σ = {a, b}.
Aa. {w| w does not contain the substring ab}
Ab. {w| w does not contain the substring baba}
c. {w| w contains neither the substrings ab nor ba}
d. {w| w is any string not in a∗b∗}
e. {w| w is any string not in (ab+)∗}
f. {w| w is any string not in a∗∪b∗}
g. {w| w is any string that doesn’t contain exactly two a’s}
h. {w| w is any string except a and b}
1.6 Give state diagrams of DFAs recognizing the following languages. In all parts, the
alphabet is {0,1}.
a. {w| w begins with a 1 and ends with a 0}
b. {w| w contains at least three 1s}
c. {w| w contains the substring 0101 (i.e., w = x0101y for some x and y)}
d. {w| w has length at least 3 and its third symbol is a 0}
e. {w| w starts with 0 and has odd length, or starts with 1 and has even length}
f. {w| w doesn’t contain the substring 110}
g. {w| the length of w is at most 5}
h. {w| w is any string except 11 and 111}
i. {w| every odd position of w is a 1}
j. {w| w contains at least two 0s and at most one 1}
k. {ε, 0}
l. {w| w contains an even number of 0s, or contains exactly two 1s}
m. The empty set
n. All strings except the empty string
1.7 Give state diagrams of NFAs with the speciﬁed number of states recognizing each
of the following languages. In all parts, the alphabet is {0,1}.
Aa. The language {w| w ends with 00} with three states
b. The language of Exercise 1.6c with ﬁve states
c. The language of Exercise 1.6l with six states
d. The language {0} with two states
e. The language 0∗1∗0+ with three states
Af. The language 1∗(001+)∗with three states
g. The language {ε} with one state
h. The language 0∗with one state
1.8 Use the construction in the proof of Theorem 1.45 to give the state diagrams of
NFAs recognizing the union of the languages described in
a. Exercises 1.6a and 1.6b.
b. Exercises 1.6c and 1.6f.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

EXERCISES
85
1.9 Use the construction in the proof of Theorem 1.47 to give the state diagrams of
NFAs recognizing the concatenation of the languages described in
a. Exercises 1.6g and 1.6i.
b. Exercises 1.6b and 1.6m.
1.10 Use the construction in the proof of Theorem 1.49 to give the state diagrams of
NFAs recognizing the star of the languages described in
a. Exercise 1.6b.
b. Exercise 1.6j.
c. Exercise 1.6m.
A1.11 Prove that every NFA can be converted to an equivalent one that has a single accept
state.
1.12 Let D = {w| w contains an even number of a’s and an odd number of b’s and does
not contain the substring ab}. Give a DFA with ﬁve states that recognizes D and a
regular expression that generates D. (Suggestion: Describe D more simply.)
1.13 Let F be the language of all strings over {0,1} that do not contain a pair of 1s that
are separated by an odd number of symbols. Give the state diagram of a DFA with
ﬁve states that recognizes F. (You may ﬁnd it helpful ﬁrst to ﬁnd a 4-state NFA for
the complement of F.)
1.14
a. Show that if M is a DFA that recognizes language B, swapping the accept
and nonaccept states in M yields a new DFA recognizing the complement of
B. Conclude that the class of regular languages is closed under complement.
b. Show by giving an example that if M is an NFA that recognizes language
C, swapping the accept and nonaccept states in M doesn’t necessarily yield
a new NFA that recognizes the complement of C. Is the class of languages
recognized by NFAs closed under complement? Explain your answer.
1.15 Give a counterexample to show that the following construction fails to prove The-
orem 1.49, the closure of the class of regular languages under the star operation.7
Let N1 = (Q1, Σ, δ1, q1, F1) recognize A1. Construct N = (Q1, Σ, δ, q1, F) as
follows. N is supposed to recognize A∗
1.
a. The states of N are the states of N1.
b. The start state of N is the same as the start state of N1.
c. F = {q1} ∪F1.
The accept states F are the old accept states plus its start state.
d. Deﬁne δ so that for any q ∈Q1 and any a ∈Σε,
δ(q, a) =
(
δ1(q, a)
q ̸∈F1 or a ̸= ε
δ1(q, a) ∪{q1}
q ∈F1 and a = ε.
(Suggestion: Show this construction graphically, as in Figure 1.50.)
7In other words, you must present a ﬁnite automaton, N1, for which the constructed
automaton N does not recognize the star of N1’s language.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

86
CHAPTER 1 / REGULAR LANGUAGES
1.16 Use the construction given in Theorem 1.39 to convert the following two nonde-
terministic ﬁnite automata to equivalent deterministic ﬁnite automata.
1.17
a. Give an NFA recognizing the language (01 ∪001 ∪010)∗.
b. Convert this NFA to an equivalent DFA. Give only the portion of the DFA
that is reachable from the start state.
1.18 Give regular expressions generating the languages of Exercise 1.6.
1.19 Use the procedure described in Lemma 1.55 to convert the following regular ex-
pressions to nondeterministic ﬁnite automata.
a. (0 ∪1)∗000(0 ∪1)∗
b. (((00)∗(11)) ∪01)∗
c. ∅∗
1.20 For each of the following languages, give two strings that are members and two
strings that are not members—a total of four strings for each part. Assume the
alphabet Σ = {a,b} in all parts.
a. a∗b∗
b. a(ba)∗b
c. a∗∪b∗
d. (aaa)∗
e. Σ∗aΣ∗bΣ∗aΣ∗
f. aba ∪bab
g. (ε ∪a)b
h. (a ∪ba ∪bb)Σ∗
1.21 Use the procedure described in Lemma 1.60 to convert the following ﬁnite au-
tomata to regular expressions.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

EXERCISES
87
1.22 In certain programming languages, comments appear between delimiters such as
/# and #/. Let C be the language of all valid delimited comment strings. A mem-
ber of C must begin with /# and end with #/ but have no intervening #/. For
simplicity, assume that the alphabet for C is Σ = {a, b, /, #}.
a. Give a DFA that recognizes C.
b. Give a regular expression that generates C.
A1.23 Let B be any language over the alphabet Σ. Prove that B = B+ iff BB ⊆B.
1.24 A ﬁnite state transducer (FST) is a type of deterministic ﬁnite automaton whose
output is a string and not just accept or reject. The following are state diagrams of
ﬁnite state transducers T1 and T2.
Each transition of an FST is labeled with two symbols, one designating the input
symbol for that transition and the other designating the output symbol. The two
symbols are written with a slash, /, separating them. In T1, the transition from
q1 to q2 has input symbol 2 and output symbol 1. Some transitions may have
multiple input–output pairs, such as the transition in T1 from q1 to itself. When
an FST computes on an input string w, it takes the input symbols w1 · · · wn one by
one and, starting at the start state, follows the transitions by matching the input
labels with the sequence of symbols w1 · · · wn = w. Every time it goes along a
transition, it outputs the corresponding output symbol. For example, on input
2212011, machine T1 enters the sequence of states q1, q2, q2, q2, q2, q1, q1, q1 and
produces output 1111000. On input abbb, T2 outputs 1011. Give the sequence of
states entered and the output produced in each of the following parts.
a. T1 on input 011
b. T1 on input 211
c. T1 on input 121
d. T1 on input 0202
e. T2 on input b
f. T2 on input bbab
g. T2 on input bbbbbb
h. T2 on input ε
1.25 Read the informal deﬁnition of the ﬁnite state transducer given in Exercise 1.24.
Give a formal deﬁnition of this model, following the pattern in Deﬁnition 1.5
(page 35). Assume that an FST has an input alphabet Σ and an output alphabet Γ but
not a set of accept states. Include a formal deﬁnition of the computation of an FST.
(Hint: An FST is a 5-tuple. Its transition function is of the form δ: Q×Σ−→Q×Γ.)
1.26 Using the solution you gave to Exercise 1.25, give a formal description of the ma-
chines T1 and T2 depicted in Exercise 1.24.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

88
CHAPTER 1 / REGULAR LANGUAGES
1.27 Read the informal deﬁnition of the ﬁnite state transducer given in Exercise 1.24.
Give the state diagram of an FST with the following behavior. Its input and output
alphabets are {0,1}. Its output string is identical to the input string on the even
positions but inverted on the odd positions. For example, on input 0000111 it
should output 1010010.
1.28 Convert the following regular expressions to NFAs using the procedure given in
Theorem 1.54. In all parts, Σ = {a, b}.
a. a(abb)∗∪b
b. a+ ∪(ab)+
c. (a ∪b+)a+b+
1.29 Use the pumping lemma to show that the following languages are not regular.
Aa. A1 = {0n1n2n| n ≥0}
b. A2 = {www| w ∈{a, b}∗}
Ac. A3 = {a2n| n ≥0} (Here, a2n means a string of 2n a’s.)
1.30 Describe the error in the following “proof” that 0∗1∗is not a regular language. (An
error must exist because 0∗1∗is regular.) The proof is by contradiction. Assume
that 0∗1∗is regular. Let p be the pumping length for 0∗1∗given by the pumping
lemma. Choose s to be the string 0p1p. You know that s is a member of 0∗1∗, but
Example 1.73 shows that s cannot be pumped. Thus you have a contradiction. So
0∗1∗is not regular.
PROBLEMS
1.31 For any string w = w1w2 · · · wn, the reverse of w, written wR, is the string w in
reverse order, wn · · · w2w1. For any language A, let AR = {wR| w ∈A}.
Show that if A is regular, so is AR.
1.32 Let
Σ3 =
nh 0
0
0
i
,
h 0
0
1
i
,
h 0
1
0
i
, . . . ,
h 1
1
1
io
.
Σ3 contains all size 3 columns of 0s and 1s. A string of symbols in Σ3 gives three
rows of 0s and 1s. Consider each row to be a binary number and let
B = {w ∈Σ∗
3| the bottom row of w is the sum of the top two rows}.
For example,
h 0
0
1
i h 1
0
0
i h 1
1
0
i
∈B,
but
h 0
0
1
i h 1
0
1
i
̸∈B.
Show that B is regular. (Hint: Working with BR is easier. You may assume the
result claimed in Problem 1.31.)
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
89
1.33 Let
Σ2 =
 0
0

,
 0
1

,
 1
0

,
 1
1
	
.
Here, Σ2 contains all columns of 0s and 1s of height two. A string of symbols in
Σ2 gives two rows of 0s and 1s. Consider each row to be a binary number and let
C = {w ∈Σ∗
2| the bottom row of w is three times the top row}.
For example,
 0
0
 0
1
 1
1
 0
0

∈C, but
 0
1
 0
1
 1
0

̸∈C. Show that C is regular.
(You may assume the result claimed in Problem 1.31.)
1.34 Let Σ2 be the same as in Problem 1.33. Consider each row to be a binary number
and let
D = {w ∈Σ∗
2| the top row of w is a larger number than is the bottom row}.
For example,
 0
0
 1
0
 1
1
 0
0

∈D, but
 0
0
 0
1
 1
1
 0
0

̸∈D. Show that D is regular.
1.35 Let Σ2 be the same as in Problem 1.33. Consider the top and bottom rows to be
strings of 0s and 1s, and let
E = {w ∈Σ∗
2| the bottom row of w is the reverse of the top row of w}.
Show that E is not regular.
1.36 Let Bn = {ak| k is a multiple of n}. Show that for each n ≥1, the language Bn is
regular.
1.37 Let Cn = {x| x is a binary number that is a multiple of n}. Show that for each
n ≥1, the language Cn is regular.
1.38 An all-NFA M is a 5-tuple (Q, Σ, δ, q0, F) that accepts x ∈Σ∗if every possible
state that M could be in after reading input x is a state from F. Note, in contrast,
that an ordinary NFA accepts a string if some state among these possible states is an
accept state. Prove that all-NFAs recognize the class of regular languages.
1.39 The construction in Theorem 1.54 shows that every GNFA is equivalent to a GNFA
with only two states. We can show that an opposite phenomenon occurs for DFAs.
Prove that for every k > 1, a language Ak ⊆{0,1}∗exists that is recognized by a
DFA with k states but not by one with only k −1 states.
1.40 Recall that string x is a preﬁx of string y if a string z exists where xz = y, and that
x is a proper preﬁx of y if in addition x ̸= y. In each of the following parts, we
deﬁne an operation on a language A. Show that the class of regular languages is
closed under that operation.
Aa. NOPREFIX(A) = {w ∈A| no proper preﬁx of w is a member of A}.
b. NOEXTEND(A) = {w ∈A| w is not the proper preﬁx of any string in A}.
1.41 For languages A and B, let the perfect shufﬂe of A and B be the language
{w| w = a1b1 · · · akbk, where a1 · · · ak ∈A and b1 · · · bk ∈B, each ai, bi ∈Σ}.
Show that the class of regular languages is closed under perfect shufﬂe.
1.42 For languages A and B, let the shufﬂe of A and B be the language
{w| w = a1b1 · · · akbk, where a1 · · · ak ∈A and b1 · · · bk ∈B, each ai, bi ∈Σ∗}.
Show that the class of regular languages is closed under shufﬂe.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

90
CHAPTER 1 / REGULAR LANGUAGES
1.43 Let A be any language. Deﬁne DROP-OUT(A) to be the language containing all
strings that can be obtained by removing one symbol from a string in A. Thus,
DROP-OUT(A) = {xz| xyz ∈A where x, z ∈Σ∗, y ∈Σ}. Show that the class
of regular languages is closed under the DROP-OUT operation. Give both a proof
by picture and a more formal proof by construction as in Theorem 1.47.
A1.44 Let B and C be languages over Σ = {0, 1}. Deﬁne
B
1←C = {w∈B| for some y∈C, strings w and y contain equal numbers of 1s}.
Show that the class of regular languages is closed under the
1←operation.
⋆1.45 Let A/B = {w| wx ∈A for some x ∈B}. Show that if A is regular and B is any
language, then A/B is regular.
1.46 Prove that the following languages are not regular. You may use the pumping
lemma and the closure of the class of regular languages under union, intersection,
and complement.
a. {0n1m0n| m, n ≥0}
Ab. {0m1n| m ̸= n}
c. {w| w ∈{0,1}∗is not a palindrome}8
⋆d. {wtw| w, t ∈{0,1}+}
1.47 Let Σ = {1, #} and let
Y = {w| w = x1#x2# · · · #xk for k ≥0, each xi ∈1∗, and xi ̸= xj for i ̸= j}.
Prove that Y is not regular.
1.48 Let Σ = {0,1} and let
D = {w|w contains an equal number of occurrences of the substrings 01 and 10}.
Thus 101 ∈D because 101 contains a single 01 and a single 10, but 1010 ̸∈D
because 1010 contains two 10s and one 01. Show that D is a regular language.
1.49
a. Let B = {1ky| y ∈{0, 1}∗and y contains at least k 1s, for k ≥1}.
Show that B is a regular language.
b. Let C = {1ky| y ∈{0, 1}∗and y contains at most k 1s, for k ≥1}.
Show that C isn’t a regular language.
A1.50 Read the informal deﬁnition of the ﬁnite state transducer given in Exercise 1.24.
Prove that no FST can output wR for every input w if the input and output alpha-
bets are {0,1}.
1.51 Let x and y be strings and let L be any language. We say that x and y are distin-
guishable by L if some string z exists whereby exactly one of the strings xz and yz
is a member of L; otherwise, for every string z, we have xz ∈L whenever yz ∈L
and we say that x and y are indistinguishable by L. If x and y are indistinguishable
by L, we write x ≡L y. Show that ≡L is an equivalence relation.
8A palindrome is a string that reads the same forward and backward.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
91
A⋆1.52 Myhill–Nerode theorem. Refer to Problem 1.51. Let L be a language and let X
be a set of strings. Say that X is pairwise distinguishable by L if every two distinct
strings in X are distinguishable by L. Deﬁne the index of L to be the maximum
number of elements in any set that is pairwise distinguishable by L. The index of
L may be ﬁnite or inﬁnite.
a. Show that if L is recognized by a DFA with k states, L has index at most k.
b. Show that if the index of L is a ﬁnite number k, it is recognized by a DFA
with k states.
c. Conclude that L is regular iff it has ﬁnite index. Moreover, its index is the
size of the smallest DFA recognizing it.
1.53 Let Σ = {0, 1, +, =} and
ADD = {x=y+z| x, y, z are binary integers, and x is the sum of y and z}.
Show that ADD is not regular.
1.54 Consider the language F = {aibjck| i, j, k ≥0 and if i = 1 then j = k}.
a. Show that F is not regular.
b. Show that F acts like a regular language in the pumping lemma. In other
words, give a pumping length p and demonstrate that F satisﬁes the three
conditions of the pumping lemma for this value of p.
c. Explain why parts (a) and (b) do not contradict the pumping lemma.
1.55 The pumping lemma says that every regular language has a pumping length p, such
that every string in the language can be pumped if it has length p or more. If p is a
pumping length for language A, so is any length p′ ≥p. The minimum pumping
length for A is the smallest p that is a pumping length for A. For example, if
A = 01∗, the minimum pumping length is 2. The reason is that the string s = 0 is
in A and has length 1 yet s cannot be pumped; but any string in A of length 2 or
more contains a 1 and hence can be pumped by dividing it so that x = 0, y = 1,
and z is the rest. For each of the following languages, give the minimum pumping
length and justify your answer.
Aa. 0001∗
Ab. 0∗1∗
c. 001 ∪0∗1∗
Ad. 0∗1+0+1∗∪10∗1
e. (01)∗
f. ε
g. 1∗01∗01∗
h. 10(11∗0)∗0
i. 1011
j. Σ∗
⋆1.56 If A is a set of natural numbers and k is a natural number greater than 1, let
Bk(A) = {w| w is the representation in base k of some number in A}.
Here, we do not allow leading 0s in the representation of a number. For example,
B2({3, 5}) = {11, 101} and B3({3, 5}) = {10, 12}. Give an example of a set A for
which B2(A) is regular but B3(A) is not regular. Prove that your example works.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

92
CHAPTER 1 / REGULAR LANGUAGES
⋆1.57 If A is any language, let A 1
2 −be the set of all ﬁrst halves of strings in A so that
A 1
2 −= {x| for some y, |x| = |y| and xy ∈A}.
Show that if A is regular, then so is A 1
2 −.
⋆1.58 If A is any language, let A 1
3 −1
3 be the set of all strings in A with their middle thirds
removed so that
A 1
3 −1
3 = {xz| for some y, |x| = |y| = |z| and xyz ∈A}.
Show that if A is regular, then A 1
3 −1
3 is not necessarily regular.
⋆1.59 Let M = (Q, Σ, δ, q0, F) be a DFA and let h be a state of M called its “home”.
A synchronizing sequence for M and h is a string s ∈Σ∗where δ(q, s) = h for
every q ∈Q. (Here we have extended δ to strings, so that δ(q, s) equals the state
where M ends up when M starts at state q and reads input s.) Say that M is
synchronizable if it has a synchronizing sequence for some state h. Prove that if M
is a k-state synchronizable DFA, then it has a synchronizing sequence of length at
most k3. Can you improve upon this bound?
1.60 Let Σ = {a, b}. For each k ≥1, let Ck be the language consisting of all strings
that contain an a exactly k places from the right-hand end. Thus Ck = Σ∗aΣk−1.
Describe an NFA with k + 1 states that recognizes Ck in terms of both a state
diagram and a formal description.
1.61 Consider the languages Ck deﬁned in Problem 1.60. Prove that for each k, no DFA
can recognize Ck with fewer than 2k states.
1.62 Let Σ = {a, b}. For each k ≥1, let Dk be the language consisting of all strings
that have at least one a among the last k symbols. Thus Dk = Σ∗a(Σ ∪ε)k−1.
Describe a DFA with at most k+1 states that recognizes Dk in terms of both a state
diagram and a formal description.
⋆1.63
a. Let A be an inﬁnite regular language. Prove that A can be split into two
inﬁnite disjoint regular subsets.
b. Let B and D be two languages. Write B ⋐D if B ⊆D and D contains
inﬁnitely many strings that are not in B. Show that if B and D are two
regular languages where B ⋐D, then we can ﬁnd a regular language C
where B ⋐C ⋐D.
1.64 Let N be an NFA with k states that recognizes some language A.
a. Show that if A is nonempty, A contains some string of length at most k.
b. Show, by giving an example, that part (a) is not necessarily true if you replace
both A’s by A.
c. Show that if A is nonempty, A contains some string of length at most 2k.
d. Show that the bound given in part (c) is nearly tight; that is, for each k,
demonstrate an NFA recognizing a language Ak where Ak is nonempty and
where Ak’s shortest member strings are of length exponential in k. Come as
close to the bound in (c) as you can.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
93
⋆1.65 Prove that for each n > 0, a language Bn exists where
a. Bn is recognizable by an NFA that has n states, and
b. if Bn = A1 ∪· · · ∪Ak, for regular languages Ai, then at least one of the Ai
requires a DFA with exponentially many states.
1.66 A homomorphism is a function f : Σ−→Γ∗from one alphabet to strings over
another alphabet. We can extend f to operate on strings by deﬁning f(w) =
f(w1)f(w2) · · · f(wn), where w = w1w2 · · · wn and each wi ∈Σ. We further
extend f to operate on languages by deﬁning f(A) = {f(w)| w ∈A}, for any
language A.
a. Show, by giving a formal construction, that the class of regular languages
is closed under homomorphism. In other words, given a DFA M that rec-
ognizes B and a homomorphism f, construct a ﬁnite automaton M ′ that
recognizes f(B). Consider the machine M ′ that you constructed. Is it a
DFA in every case?
b. Show, by giving an example, that the class of non-regular languages is not
closed under homomorphism.
⋆1.67 Let the rotational closure of language A be RC(A) = {yx| xy ∈A}.
a. Show that for any language A, we have RC(A) = RC(RC(A)).
b. Show that the class of regular languages is closed under rotational closure.
⋆1.68 In the traditional method for cutting a deck of playing cards, the deck is arbitrarily
split two parts, which are exchanged before reassembling the deck. In a more
complex cut, called Scarne’s cut, the deck is broken into three parts and the middle
part in placed ﬁrst in the reassembly. We’ll take Scarne’s cut as the inspiration for
an operation on languages. For a language A, let CUT(A) = {yxz| xyz ∈A}.
a. Exhibit a language B for which CUT(B) ̸= CUT(CUT(B)).
b. Show that the class of regular languages is closed under CUT.
1.69 Let Σ = {0,1}. Let WWk = {ww| w ∈Σ∗and w is of length k}.
a. Show that for each k, no DFA can recognize WWk with fewer than 2k states.
b. Describe a much smaller NFA for WWk, the complement of WWk.
1.70 We deﬁne the avoids operation for languages A and B to be
A avoids B = {w| w ∈A and w doesn’t contain any string in B as a substring}.
Prove that the class of regular languages is closed under the avoids operation.
1.71 Let Σ = {0,1}.
a. Let A = {0ku0k| k ≥1 and u ∈Σ∗}. Show that A is regular.
b. Let B = {0k1u0k| k ≥1 and u ∈Σ∗}. Show that B is not regular.
1.72 Let M1 and M2 be DFAs that have k1 and k2 states, respectively, and then let
U = L(M1) ∪L(M2).
a. Show that if U ̸= ∅, then U contains some string s, where |s| < max(k1, k2).
b. Show that if U ̸= Σ∗, then U excludes some string s, where |s| < k1k2.
1.73 Let Σ = {0,1, #}. Let C = {x#xR#x| x ∈{0,1}∗}. Show that C is a CFL.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

94
CHAPTER 1 / REGULAR LANGUAGES
SELECTED SOLUTIONS
1.1
For M1: (a) q1; (b) {q2}; (c) q1, q2, q3, q1, q1; (d) No; (e) No
For M2: (a) q1; (b) {q1, q4}; (c) q1, q1, q1, q2, q4; (d) Yes; (e) Yes
1.2
M1 = ({q1, q2, q3}, {a, b}, δ1, q1, {q2}).
M2 = ({q1, q2, q3, q4}, {a, b}, δ2, q1, {q1, q4}).
The transition functions are
δ1
a
b
q1
q2
q1
q2
q3
q3
q3
q2
q1
δ2
a
b
q1
q1
q2
q2
q3
q4
q3
q2
q1
q4
q3
q4.
1.4
(b) The following are DFAs for the two languages {w| w has exactly two a’s} and
{w| w has at least two b’s}.
a
a
a,b
b
b
Combining them using the intersection construction gives the following DFA.
Though the problem doesn’t request you to simplify the DFA, certain states can be
combined to give the following DFA.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

SELECTED SOLUTIONS
95
(d) These are DFAs for the two languages {w| w has an even number of a’s} and
{w| each a in w is followed by at least one b}.
Combining them using the intersection construction gives the following DFA.
Though the problem doesn’t request you to simplify the DFA, certain states can be
combined to give the following DFA.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

96
CHAPTER 1 / REGULAR LANGUAGES
1.5
(a) The left-hand DFA recognizes {w| w contains ab}. The right-hand DFA recog-
nizes its complement, {w| w doesn’t contain ab}.
(b) This DFA recognizes {w| w contains baba}.
This DFA recognizes {w| w does not contain baba}.
1.7
(a)
(f)
1.11
Let N = (Q, Σ, δ, q0, F) be any NFA. Construct an NFA N ′ with a single accept
state that recognizes the same language as N. Informally, N ′ is exactly like N
except it has ε-transitions from the states corresponding to the accept states of
N, to a new accept state, qaccept. State qaccept has no emerging transitions. More
formally, N ′ = (Q ∪{qaccept}, Σ, δ′, q0, {qaccept}), where for each q ∈Q and a ∈Σε
δ′(q, a) =
(
δ(q, a)
if a ̸= ε or q ̸∈F
δ(q, a) ∪{qaccept}
if a = ε and q ∈F
and δ′(qaccept, a) = ∅for each a ∈Σε.
1.23
We prove both directions of the “iff.”
(→) Assume that B = B+ and show that BB ⊆B.
For every language BB ⊆B+ holds, so if B = B+, then BB ⊆B.
(←) Assume that BB ⊆B and show that B = B+.
For every language B ⊆B+, so we need to show only B+ ⊆B. If w ∈B+,
then w = x1x2 · · · xk where each xi ∈B and k ≥1. Because x1, x2 ∈B and
BB ⊆B, we have x1x2 ∈B. Similarly, because x1x2 is in B and x3 is in B, we
have x1x2x3 ∈B. Continuing in this way, x1 · · · xk ∈B. Hence w ∈B, and so
we may conclude that B+ ⊆B.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

SELECTED SOLUTIONS
97
The latter argument may be written formally as the following proof by induction.
Assume that BB ⊆B.
Claim: For each k ≥1, if x1, . . . , xk ∈B, then x1 · · · xk ∈B.
Basis: Prove for k = 1.
This statement is obviously true.
Induction step: For each k ≥1, assume that the claim is true for k and prove it to be
true for k + 1.
If x1, . . . , xk, xk+1 ∈B, then by the induction assumption, x1 · · · xk ∈B. There-
fore, x1 · · · xkxk+1 ∈BB, but BB ⊆B, so x1 · · · xk+1 ∈B. That proves the
induction step and the claim. The claim implies that if BB ⊆B, then B+ ⊆B.
1.29
(a) Assume that A1 = {0n1n2n| n ≥0} is regular. Let p be the pumping length
given by the pumping lemma. Choose s to be the string 0p1p2p. Because s is a
member of A1 and s is longer than p, the pumping lemma guarantees that s can
be split into three pieces, s = xyz, where for any i ≥0 the string xyiz is in A1.
Consider two possibilities:
1. The string y consists only of 0s, only of 1s, or only of 2s. In these cases, the
string xyyz will not have equal numbers of 0s, 1s, and 2s. Hence xyyz is not
a member of A1, a contradiction.
2. The string y consists of more than one kind of symbol. In this case, xyyz
will have the 0s, 1s, or 2s out of order. Hence xyyz is not a member of A1,
a contradiction.
Either way we arrive at a contradiction. Therefore, A1 is not regular.
(c) Assume that A3 = {a2n| n ≥0} is regular. Let p be the pumping length given
by the pumping lemma. Choose s to be the string a2p. Because s is a member of
A3 and s is longer than p, the pumping lemma guarantees that s can be split into
three pieces, s = xyz, satisfying the three conditions of the pumping lemma.
The third condition tells us that |xy| ≤p. Furthermore, p < 2p and so |y| < 2p.
Therefore, |xyyz| = |xyz|+|y| < 2p +2p = 2p+1. The second condition requires
|y| > 0 so 2p < |xyyz| < 2p+1. The length of xyyz cannot be a power of 2. Hence
xyyz is not a member of A3, a contradiction. Therefore, A3 is not regular.
1.40
(a) Let M = (Q, Σ, δ, q0, F) be a DFA recognizing A, where A is some regular
language. Construct M ′ = (Q′, Σ, δ′, q0
′, F ′) recognizing NOPREFIX(A) as
follows:
1. Q′ = Q.
2. For r ∈Q′ and a ∈Σ, deﬁne δ′(r, a) =
(
{δ(r, a)}
if r /∈F
∅
if r ∈F.
3. q0
′ = q0.
4. F ′ = F.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

98
CHAPTER 1 / REGULAR LANGUAGES
1.44
Let MB = (QB, Σ, δB, qB, FB) and MC = (QC, Σ, δC, qC, FC) be DFAs recog-
nizing B and C, respectively. Construct NFA M = (Q, Σ, δ, q0, F) that recognizes
B
1←C as follows. To decide whether its input w is in B
1←C, the machine
M checks that w ∈B, and in parallel nondeterministically guesses a string y that
contains the same number of 1s as contained in w and checks that y ∈C.
1. Q = QB × QC.
2. For (q, r) ∈Q and a ∈Σε, deﬁne
δ((q, r), a) =





{(δB(q, 0), r)}
if a = 0
{(δB(q, 1), δC(r, 1))}
if a = 1
{(q, δC(r, 0))}
if a = ε.
3. q0 = (qB, qC).
4. F = FB × FC.
1.46
(b) Let B = {0m1n| m ̸= n}. Observe that B ∩0∗1∗= {0k1k| k ≥0}. If B were
regular, then B would be regular and so would B ∩0∗1∗. But we already know that
{0k1k| k ≥0} isn’t regular, so B cannot be regular.
Alternatively, we can prove B to be nonregular by using the pumping lemma di-
rectly, though doing so is trickier. Assume that B = {0m1n| m ̸= n} is regular.
Let p be the pumping length given by the pumping lemma. Observe that p! is di-
visible by all integers from 1 to p, where p! = p(p −1)(p −2) · · · 1. The string
s = 0p1p+p! ∈B, and |s| ≥p. Thus the pumping lemma implies that s can be di-
vided as xyz with x = 0a, y = 0b, and z = 0c1p+p!, where b ≥1 and a+b+c = p.
Let s′ be the string xyi+1z, where i = p!/b. Then yi = 0p! so yi+1 = 0b+p!, and
so s′ = 0a+b+c+p!1p+p!. That gives s′ = 0p+p!1p+p! ̸∈B, a contradiction.
1.50
Assume to the contrary that some FST T outputs wR on input w. Consider the
input strings 00 and 01. On input 00, T must output 00, and on input 01, T must
output 10. In both cases, the ﬁrst input bit is a 0 but the ﬁrst output bits differ.
Operating in this way is impossible for an FST because it produces its ﬁrst output
bit before it reads its second input. Hence no such FST can exist.
1.52
(a) We prove this assertion by contradiction. Let M be a k-state DFA that recog-
nizes L. Suppose for a contradiction that L has index greater than k. That means
some set X with more than k elements is pairwise distinguishable by L. Because M
has k states, the pigeonhole principle implies that X contains two distinct strings x
and y, where δ(q0, x) = δ(q0, y). Here δ(q0, x) is the state that M is in after start-
ing in the start state q0 and reading input string x. Then, for any string z ∈Σ∗,
δ(q0, xz) = δ(q0, yz). Therefore, either both xz and yz are in L or neither are
in L. But then x and y aren’t distinguishable by L, contradicting our assumption
that X is pairwise distinguishable by L.
(b) Let X = {s1, . . . , sk} be pairwise distinguishable by L. We construct DFA
M = (Q, Σ, δ, q0, F) with k states recognizing L. Let Q = {q1, . . . , qk}, and
deﬁne δ(qi, a) to be qj, where sj ≡L sia (the relation ≡L is deﬁned in Prob-
lem 1.51). Note that sj ≡L sia for some sj ∈X; otherwise, X ∪sia would have
k + 1 elements and would be pairwise distinguishable by L, which would contra-
dict the assumption that L has index k. Let F = {qi| si ∈L}. Let the start
state q0 be the qi such that si ≡L ε. M is constructed so that for any state qi,
{s| δ(q0, s) = qi} = {s| s ≡L si}. Hence M recognizes L.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

SELECTED SOLUTIONS
99
(c) Suppose that L is regular and let k be the number of states in a DFA recognizing
L. Then from part (a), L has index at most k. Conversely, if L has index k, then
by part (b) it is recognized by a DFA with k states and thus is regular. To show that
the index of L is the size of the smallest DFA accepting it, suppose that L’s index
is exactly k. Then, by part (b), there is a k-state DFA accepting L. That is the
smallest such DFA because if it were any smaller, then we could show by part (a)
that the index of L is less than k.
1.55
(a) The minimum pumping length is 4. The string 000 is in the language but
cannot be pumped, so 3 is not a pumping length for this language. If s has length
4 or more, it contains 1s. By dividing s into xyz, where x is 000 and y is the ﬁrst 1
and z is everything afterward, we satisfy the pumping lemma’s three conditions.
(b) The minimum pumping length is 1. The pumping length cannot be 0 because
the string ε is in the language and it cannot be pumped. Every nonempty string in
the language can be divided into xyz, where x, y, and z are ε, the ﬁrst character,
and the remainder, respectively. This division satisﬁes the three conditions.
(d) The minimum pumping length is 3. The pumping length cannot be 2 because
the string 11 is in the language and it cannot be pumped. Let s be a string in the
language of length at least 3. If s is generated by 0∗1+0+1∗and s begins either 0
or 11, write s = xyz where x = ε, y is the ﬁrst symbol, and z is the remainder of
s. If s is generated by 0∗1+0+1∗and s begins 10, write s = xyz where x = 10, y is
the next symbol, and z is the remainder of s. Breaking s up in this way shows that
it can be pumped. If s is generated by 10∗1, we can write it as xyz where x = 1,
y = 0, and z is the remainder of s. This division gives a way to pump s.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2
C O N T E X T - F R E E
L A N G U A G E S
In Chapter 1 we introduced two different, though equivalent, methods of de-
scribing languages: ﬁnite automata and regular expressions. We showed that many
languages can be described in this way but that some simple languages, such as
{0n1n| n ≥0}, cannot.
In this chapter we present context-free grammars, a more powerful method
of describing languages. Such grammars can describe certain features that have
a recursive structure, which makes them useful in a variety of applications.
Context-free grammars were ﬁrst used in the study of human languages. One
way of understanding the relationship of terms such as noun, verb, and preposition
and their respective phrases leads to a natural recursion because noun phrases
may appear inside verb phrases and vice versa. Context-free grammars help us
organize and understand these relationships.
An important application of context-free grammars occurs in the speciﬁcation
and compilation of programming languages. A grammar for a programming lan-
guage often appears as a reference for people trying to learn the language syntax.
Designers of compilers and interpreters for programming languages often start
by obtaining a grammar for the language. Most compilers and interpreters con-
tain a component called a parser that extracts the meaning of a program prior to
generating the compiled code or performing the interpreted execution. A num-
ber of methodologies facilitate the construction of a parser once a context-free
grammar is available. Some tools even automatically generate the parser from
the grammar.
101
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

102
CHAPTER 2 / CONTEXT-FREE LANGUAGES
The collection of languages associated with context-free grammars are called
the context-free languages. They include all the regular languages and many
additional languages. In this chapter, we give a formal deﬁnition of context-free
grammars and study the properties of context-free languages. We also introduce
pushdown automata, a class of machines recognizing the context-free languages.
Pushdown automata are useful because they allow us to gain additional insight
into the power of context-free grammars.
2.1
CONTEXT-FREE GRAMMARS
The following is an example of a context-free grammar, which we call G1.
A →0A1
A →B
B →#
A grammar consists of a collection of substitution rules, also called produc-
tions. Each rule appears as a line in the grammar, comprising a symbol and
a string separated by an arrow. The symbol is called a variable. The string
consists of variables and other symbols called terminals. The variable symbols
often are represented by capital letters. The terminals are analogous to the in-
put alphabet and often are represented by lowercase letters, numbers, or special
symbols. One variable is designated as the start variable. It usually occurs on
the left-hand side of the topmost rule. For example, grammar G1 contains three
rules. G1’s variables are A and B, where A is the start variable. Its terminals are
0, 1, and #.
You use a grammar to describe a language by generating each string of that
language in the following manner.
1. Write down the start variable. It is the variable on the left-hand side of the
top rule, unless speciﬁed otherwise.
2. Find a variable that is written down and a rule that starts with that variable.
Replace the written down variable with the right-hand side of that rule.
3. Repeat step 2 until no variables remain.
For example, grammar G1 generates the string 000#111. The sequence of
substitutions to obtain a string is called a derivation. A derivation of string
000#111 in grammar G1 is
A ⇒0A1 ⇒00A11 ⇒000A111 ⇒000B111 ⇒000#111.
You may also represent the same information pictorially with a parse tree. An
example of a parse tree is shown in Figure 2.1.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.1
CONTEXT-FREE GRAMMARS
103
FIGURE
2.1
Parse tree for 000#111 in grammar G1
All strings generated in this way constitute the language of the grammar.
We write L(G1) for the language of grammar G1. Some experimentation with
the grammar G1 shows us that L(G1) is {0n#1n| n ≥0}. Any language that can
be generated by some context-free grammar is called a context-free language
(CFL). For convenience when presenting a context-free grammar, we abbreviate
several rules with the same left-hand variable, such as A →0A1 and A →B,
into a single line A →0A1 | B, using the symbol “ | ” as an “or”.
The following is a second example of a context-free grammar, called G2,
which describes a fragment of the English language.
⟨SENTENCE⟩→⟨NOUN-PHRASE⟩⟨VERB-PHRASE⟩
⟨NOUN-PHRASE⟩→⟨CMPLX-NOUN⟩| ⟨CMPLX-NOUN⟩⟨PREP-PHRASE⟩
⟨VERB-PHRASE⟩→⟨CMPLX-VERB⟩| ⟨CMPLX-VERB⟩⟨PREP-PHRASE⟩
⟨PREP-PHRASE⟩→⟨PREP⟩⟨CMPLX-NOUN⟩
⟨CMPLX-NOUN⟩→⟨ARTICLE⟩⟨NOUN⟩
⟨CMPLX-VERB⟩→⟨VERB⟩| ⟨VERB⟩⟨NOUN-PHRASE⟩
⟨ARTICLE⟩→a | the
⟨NOUN⟩→boy | girl | flower
⟨VERB⟩→touches | likes | sees
⟨PREP⟩→with
Grammar G2 has 10 variables (the capitalized grammatical terms written in-
side brackets); 27 terminals (the standard English alphabet plus a space charac-
ter); and 18 rules. Strings in L(G2) include:
a boy sees
the boy sees a flower
a girl with a flower likes the boy
Each of these strings has a derivation in grammar G2. The following is a deriva-
tion of the ﬁrst string on this list.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

104
CHAPTER 2 / CONTEXT-FREE LANGUAGES
⟨SENTENCE⟩⇒⟨NOUN-PHRASE⟩⟨VERB-PHRASE⟩
⇒⟨CMPLX-NOUN⟩⟨VERB-PHRASE⟩
⇒⟨ARTICLE⟩⟨NOUN⟩⟨VERB-PHRASE⟩
⇒a ⟨NOUN⟩⟨VERB-PHRASE⟩
⇒a boy ⟨VERB-PHRASE⟩
⇒a boy ⟨CMPLX-VERB⟩
⇒a boy ⟨VERB⟩
⇒a boy sees
FORMAL DEFINITION OF A CONTEXT-FREE GRAMMAR
Let’s formalize our notion of a context-free grammar (CFG).
DEFINITION
2.2
A context-free grammar is a 4-tuple (V, Σ, R, S), where
1. V is a ﬁnite set called the variables,
2. Σ is a ﬁnite set, disjoint from V , called the terminals,
3. R is a ﬁnite set of rules, with each rule being a variable and a
string of variables and terminals, and
4. S ∈V is the start variable.
If u, v, and w are strings of variables and terminals, and A →w is a rule of the
grammar, we say that uAv yields uwv, written uAv ⇒uwv. Say that u derives v,
written u
∗⇒v, if u = v or if a sequence u1, u2, . . . , uk exists for k ≥0 and
u ⇒u1 ⇒u2 ⇒. . . ⇒uk ⇒v.
The language of the grammar is {w ∈Σ∗| S
∗⇒w}.
In grammar G1, V = {A, B}, Σ = {0, 1, #}, S = A, and R is the collection
of the three rules appearing on page 102. In grammar G2,
V =

⟨SENTENCE⟩, ⟨NOUN-PHRASE⟩, ⟨VERB-PHRASE⟩,
⟨PREP-PHRASE⟩, ⟨CMPLX-NOUN⟩, ⟨CMPLX-VERB⟩,
⟨ARTICLE⟩, ⟨NOUN⟩, ⟨VERB⟩, ⟨PREP⟩
	
,
and Σ = {a, b, c, . . . , z, “ ”}. The symbol “ ” is the blank symbol, placed invisibly
after each word (a, boy, etc.), so the words won’t run together.
Often we specify a grammar by writing down only its rules. We can identify
the variables as the symbols that appear on the left-hand side of the rules and
the terminals as the remaining symbols. By convention, the start variable is the
variable on the left-hand side of the ﬁrst rule.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.1
CONTEXT-FREE GRAMMARS
105
EXAMPLES OF CONTEXT-FREE GRAMMARS
EXAMPLE
2.3
Consider grammar G3 = ({S}, {a, b}, R, S). The set of rules, R, is
S →aSb | SS | ε.
This grammar generates strings such as abab, aaabbb, and aababb. You can
see more easily what this language is if you think of a as a left parenthesis “(”
and b as a right parenthesis “)”. Viewed in this way, L(G3) is the language of
all strings of properly nested parentheses. Observe that the right-hand side of a
rule may be the empty string ε.
EXAMPLE
2.4
Consider grammar G4 = (V, Σ, R, ⟨EXPR⟩).
V is {⟨EXPR⟩, ⟨TERM⟩, ⟨FACTOR⟩} and Σ is {a, +, x, (, )}. The rules are
⟨EXPR⟩→⟨EXPR⟩+⟨TERM⟩| ⟨TERM⟩
⟨TERM⟩→⟨TERM⟩x⟨FACTOR⟩| ⟨FACTOR⟩
⟨FACTOR⟩→( ⟨EXPR⟩) | a
The two strings a+axa and (a+a)xa can be generated with grammar G4.
The parse trees are shown in the following ﬁgure.
FIGURE
2.5
Parse trees for the strings a+axa and (a+a)xa
A compiler translates code written in a programming language into another
form, usually one more suitable for execution. To do so, the compiler extracts
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

106
CHAPTER 2 / CONTEXT-FREE LANGUAGES
the meaning of the code to be compiled in a process called parsing. One rep-
resentation of this meaning is the parse tree for the code, in the context-free
grammar for the programming language. We discuss an algorithm that parses
context-free languages later in Theorem 7.16 and in Problem 7.45.
Grammar G4 describes a fragment of a programming language concerned
with arithmetic expressions. Observe how the parse trees in Figure 2.5 “group”
the operations. The tree for a+axa groups the x operator and its operands
(the second two a’s) as one operand of the + operator. In the tree for (a+a)xa,
the grouping is reversed. These groupings ﬁt the standard precedence of mul-
tiplication before addition and the use of parentheses to override the standard
precedence. Grammar G4 is designed to capture these precedence relations.
DESIGNING CONTEXT-FREE GRAMMARS
As with the design of ﬁnite automata, discussed in Section 1.1 (page 41), the
design of context-free grammars requires creativity. Indeed, context-free gram-
mars are even trickier to construct than ﬁnite automata because we are more
accustomed to programming a machine for speciﬁc tasks than we are to describ-
ing languages with grammars. The following techniques are helpful, singly or in
combination, when you’re faced with the problem of constructing a CFG.
First, many CFLs are the union of simpler CFLs. If you must construct a CFG for
a CFL that you can break into simpler pieces, do so and then construct individual
grammars for each piece. These individual grammars can be easily merged into
a grammar for the original language by combining their rules and then adding
the new rule S →S1 | S2 | · · · | Sk, where the variables Si are the start variables
for the individual grammars. Solving several simpler problems is often easier
than solving one complicated problem.
For example, to get a grammar for the language {0n1n|n ≥0}∪{1n0n|n ≥0},
ﬁrst construct the grammar
S1 →0S11 | ε
for the language {0n1n| n ≥0} and the grammar
S2 →1S20 | ε
for the language {1n0n| n ≥0} and then add the rule S →S1 | S2 to give the
grammar
S →S1 | S2
S1 →0S11 | ε
S2 →1S20 | ε.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.1
CONTEXT-FREE GRAMMARS
107
Second, constructing a CFG for a language that happens to be regular is easy
if you can ﬁrst construct a DFA for that language. You can convert any DFA into
an equivalent CFG as follows. Make a variable Ri for each state qi of the DFA.
Add the rule Ri →aRj to the CFG if δ(qi, a) = qj is a transition in the DFA. Add
the rule Ri →ε if qi is an accept state of the DFA. Make R0 the start variable of
the grammar, where q0 is the start state of the machine. Verify on your own that
the resulting CFG generates the same language that the DFA recognizes.
Third, certain context-free languages contain strings with two substrings that
are “linked” in the sense that a machine for such a language would need to re-
member an unbounded amount of information about one of the substrings to
verify that it corresponds properly to the other substring. This situation occurs
in the language {0n1n| n ≥0} because a machine would need to remember the
number of 0s in order to verify that it equals the number of 1s. You can construct
a CFG to handle this situation by using a rule of the form R →uRv, which gen-
erates strings wherein the portion containing the u’s corresponds to the portion
containing the v’s.
Finally, in more complex languages, the strings may contain certain structures
that appear recursively as part of other (or the same) structures. That situation
occurs in the grammar that generates arithmetic expressions in Example 2.4.
Any time the symbol a appears, an entire parenthesized expression might appear
recursively instead. To achieve this effect, place the variable symbol generating
the structure in the location of the rules corresponding to where that structure
may recursively appear.
AMBIGUITY
Sometimes a grammar can generate the same string in several different ways.
Such a string will have several different parse trees and thus several different
meanings. This result may be undesirable for certain applications, such as pro-
gramming languages, where a program should have a unique interpretation.
If a grammar generates the same string in several different ways, we say that
the string is derived ambiguously in that grammar. If a grammar generates some
string ambiguously, we say that the grammar is ambiguous.
For example, consider grammar G5:
⟨EXPR⟩→⟨EXPR⟩+⟨EXPR⟩| ⟨EXPR⟩x⟨EXPR⟩| ( ⟨EXPR⟩) | a
This grammar generates the string a+axa ambiguously. The following ﬁgure
shows the two different parse trees.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

108
CHAPTER 2 / CONTEXT-FREE LANGUAGES
FIGURE
2.6
The two parse trees for the string a+axa in grammar G5
This grammar doesn’t capture the usual precedence relations and so may
group the + before the × or vice versa. In contrast, grammar G4 generates
exactly the same language, but every generated string has a unique parse tree.
Hence G4 is unambiguous, whereas G5 is ambiguous.
Grammar G2 (page 103) is another example of an ambiguous grammar. The
sentence
the girl touches the boy with the flower
has two different
derivations. In Exercise 2.8 you are asked to give the two parse trees and observe
their correspondence with the two different ways to read that sentence.
Now we formalize the notion of ambiguity. When we say that a grammar
generates a string ambiguously, we mean that the string has two different parse
trees, not two different derivations. Two derivations may differ merely in the
order in which they replace variables yet not in their overall structure. To con-
centrate on structure, we deﬁne a type of derivation that replaces variables in a
ﬁxed order. A derivation of a string w in a grammar G is a leftmost derivation if
at every step the leftmost remaining variable is the one replaced. The derivation
preceding Deﬁnition 2.2 (page 104) is a leftmost derivation.
DEFINITION
2.7
A string w is derived ambiguously in context-free grammar G if
it has two or more different leftmost derivations. Grammar G is
ambiguous if it generates some string ambiguously.
Sometimes when we have an ambiguous grammar we can ﬁnd an unambigu-
ous grammar that generates the same language. Some context-free languages,
however, can be generated only by ambiguous grammars. Such languages are
called inherently ambiguous. Problem 2.29 asks you to prove that the language
{aibjck| i = j or j = k} is inherently ambiguous.
CHOMSKY NORMAL FORM
When working with context-free grammars, it is often convenient to have them
in simpliﬁed form.
One of the simplest and most useful forms is called the
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.1
CONTEXT-FREE GRAMMARS
109
Chomsky normal form. Chomsky normal form is useful in giving algorithms
for working with context-free grammars, as we do in Chapters 4 and 7.
DEFINITION
2.8
A context-free grammar is in Chomsky normal form if every rule is
of the form
A →BC
A →a
where a is any terminal and A, B, and C are any variables—except
that B and C may not be the start variable. In addition, we permit
the rule S →ε, where S is the start variable.
THEOREM
2.9
Any context-free language is generated by a context-free grammar in Chomsky
normal form.
PROOF IDEA
We can convert any grammar G into Chomsky normal form.
The conversion has several stages wherein rules that violate the conditions are
replaced with equivalent ones that are satisfactory. First, we add a new start
variable. Then, we eliminate all ε-rules of the form A →ε. We also eliminate
all unit rules of the form A →B. In both cases we patch up the grammar to be
sure that it still generates the same language. Finally, we convert the remaining
rules into the proper form.
PROOF
First, we add a new start variable S0 and the rule S0 →S, where
S was the original start variable. This change guarantees that the start variable
doesn’t occur on the right-hand side of a rule.
Second, we take care of all ε-rules. We remove an ε-rule A →ε, where A
is not the start variable. Then for each occurrence of an A on the right-hand
side of a rule, we add a new rule with that occurrence deleted. In other words,
if R →uAv is a rule in which u and v are strings of variables and terminals, we
add rule R →uv. We do so for each occurrence of an A, so the rule R →uAvAw
causes us to add R →uvAw, R →uAvw, and R →uvw. If we have the rule
R →A, we add R →ε unless we had previously removed the rule R →ε. We
repeat these steps until we eliminate all ε-rules not involving the start variable.
Third, we handle all unit rules. We remove a unit rule A →B. Then,
whenever a rule B →u appears, we add the rule A →u unless this was a unit
rule previously removed. As before, u is a string of variables and terminals. We
repeat these steps until we eliminate all unit rules.
Finally, we convert all remaining rules into the proper form. We replace each
rule A →u1u2 · · · uk, where k ≥3 and each ui is a variable or terminal symbol,
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

110
CHAPTER 2 / CONTEXT-FREE LANGUAGES
with the rules A →u1A1, A1 →u2A2, A2 →u3A3, . . . , and Ak−2 →uk−1uk.
The Ai’s are new variables. We replace any terminal ui in the preceding rule(s)
with the new variable Ui and add the rule Ui →ui.
EXAMPLE
2.10
Let G6 be the following CFG and convert it to Chomsky normal form by using
the conversion procedure just given. The series of grammars presented illus-
trates the steps in the conversion. Rules shown in bold have just been added.
Rules shown in gray have just been removed.
1.
The original CFG G6 is shown on the left. The result of applying the ﬁrst
step to make a new start variable appears on the right.
S →ASA | aB
A →B | S
B →b | ε
S0 →S
S →ASA | aB
A →B | S
B →b | ε
2.
Remove ε-rules B →ε, shown on the left, and A →ε, shown on the right.
S0 →S
S →ASA | aB | aaa
A →B | S | εεε
B →b | εεε
S0 →S
S →ASA | aB | a | SA | AS | S
A →B | S | εεε
B →b
3a.
Remove unit rules S →S, shown on the left, and S0 →S, shown on the
right.
S0 →S
S →ASA | aB | a | SA | AS | S
A →B | S
B →b
S0 →S | ASA | aaaB | aaa | SA | AS
S →ASA | aB | a | SA | AS
A →B | S
B →b
3b.
Remove unit rules A →B and A →S.
S0 →ASA | aB | a | SA | AS
S →ASA | aB | a | SA | AS
A →B | S | bbb
B →b
S0 →ASA | aB | a | SA | AS
S →ASA | aB | a | SA | AS
A →S | b | ASA | aaaB | aaa | SA | AS
B →b
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.2
PUSHDOWN AUTOMATA
111
4.
Convert the remaining rules into the proper form by adding additional vari-
ables and rules. The ﬁnal grammar in Chomsky normal form is equivalent to G6.
(Actually the procedure given in Theorem 2.9 produces several variables Ui and
several rules Ui →a. We simpliﬁed the resulting grammar by using a single
variable U and rule U →a.)
S0 →AA1 | UB | a | SA | AS
S →AA1 | UB | a | SA | AS
A →b | AA1 | UB | a | SA | AS
A1 →SA
U →a
B →b
2.2
PUSHDOWN AUTOMATA
In this section we introduce a new type of computational model called pushdown
automata. These automata are like nondeterministic ﬁnite automata but have an
extra component called a stack. The stack provides additional memory beyond
the ﬁnite amount available in the control. The stack allows pushdown automata
to recognize some nonregular languages.
Pushdown automata are equivalent in power to context-free grammars. This
equivalence is useful because it gives us two options for proving that a language is
context free. We can give either a context-free grammar generating it or a push-
down automaton recognizing it. Certain languages are more easily described in
terms of generators, whereas others are more easily described by recognizers.
The following ﬁgure is a schematic representation of a ﬁnite automaton. The
control represents the states and transition function, the tape contains the in-
put string, and the arrow represents the input head, pointing at the next input
symbol to be read.
FIGURE
2.11
Schematic of a ﬁnite automaton
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

112
CHAPTER 2 / CONTEXT-FREE LANGUAGES
With the addition of a stack component we obtain a schematic representation
of a pushdown automaton, as shown in the following ﬁgure.
FIGURE
2.12
Schematic of a pushdown automaton
A pushdown automaton (PDA) can write symbols on the stack and read them
back later. Writing a symbol “pushes down” all the other symbols on the stack.
At any time the symbol on the top of the stack can be read and removed. The
remaining symbols then move back up. Writing a symbol on the stack is of-
ten referred to as pushing the symbol, and removing a symbol is referred to as
popping it. Note that all access to the stack, for both reading and writing, may
be done only at the top. In other words a stack is a “last in, ﬁrst out” storage
device. If certain information is written on the stack and additional information
is written afterward, the earlier information becomes inaccessible until the later
information is removed.
Plates on a cafeteria serving counter illustrate a stack. The stack of plates
rests on a spring so that when a new plate is placed on top of the stack, the plates
below it move down. The stack on a pushdown automaton is like a stack of
plates, with each plate having a symbol written on it.
A stack is valuable because it can hold an unlimited amount of information.
Recall that a ﬁnite automaton is unable to recognize the language {0n1n|n ≥0}
because it cannot store very large numbers in its ﬁnite memory. A PDA is able to
recognize this language because it can use its stack to store the number of 0s it
has seen. Thus the unlimited nature of a stack allows the PDA to store numbers of
unbounded size. The following informal description shows how the automaton
for this language works.
Read symbols from the input. As each 0 is read, push it onto the stack. As
soon as 1s are seen, pop a 0 off the stack for each 1 read. If reading the
input is ﬁnished exactly when the stack becomes empty of 0s, accept the
input. If the stack becomes empty while 1s remain or if the 1s are ﬁnished
while the stack still contains 0s or if any 0s appear in the input following
1s, reject the input.
As mentioned earlier, pushdown automata may be nondeterministic. Deter-
ministic and nondeterministic pushdown automata are not equivalent in power.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.2
PUSHDOWN AUTOMATA
113
Nondeterministic pushdown automata recognize certain languages that no de-
terministic pushdown automata can recognize, as we will see in Section 2.4. We
give languages requiring nondeterminism in Examples 2.16 and 2.18. Recall
that deterministic and nondeterministic ﬁnite automata do recognize the same
class of languages, so the pushdown automata situation is different. We focus on
nondeterministic pushdown automata because these automata are equivalent in
power to context-free grammars.
FORMAL DEFINITION OF A PUSHDOWN AUTOMATON
The formal deﬁnition of a pushdown automaton is similar to that of a ﬁnite
automaton, except for the stack. The stack is a device containing symbols drawn
from some alphabet. The machine may use different alphabets for its input and
its stack, so now we specify both an input alphabet Σ and a stack alphabet Γ.
At the heart of any formal deﬁnition of an automaton is the transition func-
tion, which describes its behavior. Recall that Σε = Σ ∪{ε} and Γε = Γ ∪{ε}.
The domain of the transition function is Q × Σε × Γε. Thus the current state,
next input symbol read, and top symbol of the stack determine the next move of
a pushdown automaton. Either symbol may be ε, causing the machine to move
without reading a symbol from the input or without reading a symbol from the
stack.
For the range of the transition function we need to consider what to allow
the automaton to do when it is in a particular situation. It may enter some
new state and possibly write a symbol on the top of the stack. The function δ
can indicate this action by returning a member of Q together with a member
of Γε, that is, a member of Q × Γε. Because we allow nondeterminism in this
model, a situation may have several legal next moves. The transition function
incorporates nondeterminism in the usual way, by returning a set of members of
Q × Γε, that is, a member of P(Q × Γε). Putting it all together, our transition
function δ takes the form δ: Q × Σε × Γε−→P(Q × Γε).
DEFINITION
2.13
A pushdown automaton is a 6-tuple (Q, Σ, Γ, δ, q0, F), where Q, Σ,
Γ, and F are all ﬁnite sets, and
1. Q is the set of states,
2. Σ is the input alphabet,
3. Γ is the stack alphabet,
4. δ: Q × Σε × Γε−→P(Q × Γε) is the transition function,
5. q0 ∈Q is the start state, and
6. F ⊆Q is the set of accept states.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

114
CHAPTER 2 / CONTEXT-FREE LANGUAGES
A pushdown automaton M = (Q, Σ, Γ, δ, q0, F) computes as follows. It ac-
cepts input w if w can be written as w = w1w2 · · · wm, where each wi ∈Σε and
sequences of states r0, r1, . . . , rm ∈Q and strings s0, s1, . . . , sm ∈Γ∗exist that
satisfy the following three conditions. The strings si represent the sequence of
stack contents that M has on the accepting branch of the computation.
1. r0 = q0 and s0 = ε. This condition signiﬁes that M starts out properly, in
the start state and with an empty stack.
2. For i = 0, . . . , m −1, we have (ri+1, b) ∈δ(ri, wi+1, a), where si = at
and si+1 = bt for some a, b ∈Γε and t ∈Γ∗. This condition states that M
moves properly according to the state, stack, and next input symbol.
3. rm ∈F. This condition states that an accept state occurs at the input end.
EXAMPLES OF PUSHDOWN AUTOMATA
EXAMPLE
2.14
The following is the formal description of the PDA (page 112) that recognizes
the language {0n1n| n ≥0}. Let M1 be (Q, Σ, Γ, δ, q1, F), where
Q = {q1, q2, q3, q4},
Σ = {0,1},
Γ = {0, $},
F = {q1, q4}, and
δ is given by the following table, wherein blank entries signify ∅.
Input:
0
1
ε
Stack:
0
$
ε
0
$
ε
0
$
ε
q1
{(q2, $)}
q2
{(q2, 0)}
{(q3, ε)}
q3
{(q3, ε)}
{(q4, ε)}
q4
We can also use a state diagram to describe a PDA, as in Figures 2.15, 2.17,
and 2.19. Such diagrams are similar to the state diagrams used to describe ﬁnite
automata, modiﬁed to show how the PDA uses its stack when going from state
to state. We write “a,b →c” to signify that when the machine is reading an
a from the input, it may replace the symbol b on the top of the stack with a c.
Any of a, b, and c may be ε. If a is ε, the machine may make this transition
without reading any symbol from the input. If b is ε, the machine may make
this transition without reading and popping any symbol from the stack. If c
is ε, the machine does not write any symbol on the stack when going along this
transition.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.2
PUSHDOWN AUTOMATA
115
FIGURE
2.15
State diagram for the PDA M1 that recognizes {0n1n| n ≥0}
The formal deﬁnition of a PDA contains no explicit mechanism to allow the
PDA to test for an empty stack. This PDA is able to get the same effect by initially
placing a special symbol $ on the stack. Then if it ever sees the $ again, it knows
that the stack effectively is empty. Subsequently, when we refer to testing for an
empty stack in an informal description of a PDA, we implement the procedure in
the same way.
Similarly, PDAs cannot test explicitly for having reached the end of the input
string. This PDA is able to achieve that effect because the accept state takes effect
only when the machine is at the end of the input. Thus from now on, we assume
that PDAs can test for the end of the input, and we know that we can implement
it in the same manner.
EXAMPLE
2.16
This example illustrates a pushdown automaton that recognizes the language
{aibjck| i, j, k ≥0 and i = j or i = k}.
Informally, the PDA for this language works by ﬁrst reading and pushing
the a’s. When the a’s are done, the machine has all of them on the stack so
that it can match, them with either the b’s or the c’s. This maneuver is a bit
tricky because the machine doesn’t know in advance whether to match the a’s
with the b’s or the c’s. Nondeterminism comes in handy here.
Using its nondeterminism, the PDA can guess whether to match the a’s with
the b’s or with the c’s, as shown in Figure 2.17. Think of the machine as having
two branches of its nondeterminism, one for each possible guess. If either of
them matches, that branch accepts and the entire machine accepts. Problem 2.57
asks you to show that nondeterminism is essential for recognizing this language
with a PDA.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

116
CHAPTER 2 / CONTEXT-FREE LANGUAGES
FIGURE
2.17
State diagram for PDA M2 that recognizes
{aibjck| i, j, k ≥0 and i = j or i = k}
EXAMPLE
2.18
In this example we give a PDA M3 recognizing the language {wwR|w ∈{0,1}∗}.
Recall that wR means w written backwards. The informal description and state
diagram of the PDA follow.
Begin by pushing the symbols that are read onto the stack. At each point,
nondeterministically guess that the middle of the string has been reached and
then change into popping off the stack for each symbol read, checking to see that
they are the same. If they were always the same symbol and the stack empties at
the same time as the input is ﬁnished, accept; otherwise reject.
FIGURE
2.19
State diagram for the PDA M3 that recognizes {wwR| w ∈{0, 1}∗}
Problem 2.58 shows that this language requires a nondeterministic PDA.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.2
PUSHDOWN AUTOMATA
117
EQUIVALENCE WITH CONTEXT-FREE GRAMMARS
In this section we show that context-free grammars and pushdown automata are
equivalent in power. Both are capable of describing the class of context-free
languages. We show how to convert any context-free grammar into a pushdown
automaton that recognizes the same language and vice versa. Recalling that we
deﬁned a context-free language to be any language that can be described with a
context-free grammar, our objective is the following theorem.
THEOREM
2.20
A language is context free if and only if some pushdown automaton recognizes it.
As usual for “if and only if” theorems, we have two directions to prove. In
this theorem, both directions are interesting. First, we do the easier forward
direction.
LEMMA
2.21
If a language is context free, then some pushdown automaton recognizes it.
PROOF IDEA
Let A be a CFL. From the deﬁnition we know that A has a CFG,
G, generating it. We show how to convert G into an equivalent PDA, which we
call P.
The PDA P that we now describe will work by accepting its input w, if G gen-
erates that input, by determining whether there is a derivation for w. Recall that
a derivation is simply the sequence of substitutions made as a grammar generates
a string. Each step of the derivation yields an intermediate string of variables
and terminals. We design P to determine whether some series of substitutions
using the rules of G can lead from the start variable to w.
One of the difﬁculties in testing whether there is a derivation for w is in
ﬁguring out which substitutions to make. The PDA’s nondeterminism allows it
to guess the sequence of correct substitutions. At each step of the derivation, one
of the rules for a particular variable is selected nondeterministically and used to
substitute for that variable.
The PDA P begins by writing the start variable on its stack. It goes through a
series of intermediate strings, making one substitution after another. Eventually
it may arrive at a string that contains only terminal symbols, meaning that it has
used the grammar to derive a string. Then P accepts if this string is identical to
the string it has received as input.
Implementing this strategy on a PDA requires one additional idea. We need
to see how the PDA stores the intermediate strings as it goes from one to an-
other. Simply using the stack for storing each intermediate string is tempting.
However, that doesn’t quite work because the PDA needs to ﬁnd the variables in
the intermediate string and make substitutions. The PDA can access only the top
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

118
CHAPTER 2 / CONTEXT-FREE LANGUAGES
symbol on the stack and that may be a terminal symbol instead of a variable. The
way around this problem is to keep only part of the intermediate string on the
stack: the symbols starting with the ﬁrst variable in the intermediate string. Any
terminal symbols appearing before the ﬁrst variable are matched immediately
with symbols in the input string. The following ﬁgure shows the PDA P.
FIGURE
2.22
P representing the intermediate string 01A1A0
The following is an informal description of P.
1. Place the marker symbol $ and the start variable on the stack.
2. Repeat the following steps forever.
a. If the top of stack is a variable symbol A, nondeterministically select
one of the rules for A and substitute A by the string on the right-hand
side of the rule.
b. If the top of stack is a terminal symbol a, read the next symbol from
the input and compare it to a. If they match, repeat. If they do not
match, reject on this branch of the nondeterminism.
c. If the top of stack is the symbol $, enter the accept state. Doing so
accepts the input if it has all been read.
PROOF
We now give the formal details of the construction of the pushdown
automaton P = (Q, Σ, Γ, δ, qstart, F). To make the construction clearer, we use
shorthand notation for the transition function. This notation provides a way to
write an entire string on the stack in one step of the machine. We can simulate
this action by introducing additional states to write the string one symbol at a
time, as implemented in the following formal construction.
Let q and r be states of the PDA and let a be in Σε and s be in Γε. Say that
we want the PDA to go from q to r when it reads a and pops s. Furthermore, we
want it to push the entire string u = u1 · · · ul on the stack at the same time. We
can implement this action by introducing new states q1, . . . , ql−1 and setting the
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.2
PUSHDOWN AUTOMATA
119
transition function as follows:
δ(q, a, s) to contain (q1, ul),
δ(q1, ε, ε) = {(q2, ul−1)},
δ(q2, ε, ε) = {(q3, ul−2)},
...
δ(ql−1, ε, ε) = {(r, u1)}.
We use the notation (r, u) ∈δ(q, a, s) to mean that when q is the state of the
automaton, a is the next input symbol, and s is the symbol on the top of the
stack, the PDA may read the a and pop the s, then push the string u onto the
stack and go on to the state r. The following ﬁgure shows this implementation.
a s
xyz
a s
z
y
x
FIGURE
2.23
Implementing the shorthand (r, xyz) ∈δ(q, a, s)
The states of P are Q = {qstart, qloop, qaccept} ∪E, where E is the set of states
we need for implementing the shorthand just described. The start state is qstart.
The only accept state is qaccept.
The transition function is deﬁned as follows. We begin by initializing the
stack to contain the symbols $ and S, implementing step 1 in the informal de-
scription: δ(qstart, ε, ε) = {(qloop, S$)}. Then we put in transitions for the main
loop of step 2.
First, we handle case (a) wherein the top of the stack contains a variable. Let
δ(qloop, ε, A) = {(qloop, w)| where A →w is a rule in R}.
Second, we handle case (b) wherein the top of the stack contains a terminal.
Let δ(qloop, a, a) = {(qloop, ε)}.
Finally, we handle case (c) wherein the empty stack marker $ is on the top of
the stack. Let δ(qloop, ε, $) = {(qaccept, ε)}.
The state diagram is shown in Figure 2.24.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

120
CHAPTER 2 / CONTEXT-FREE LANGUAGES
FIGURE
2.24
State diagram of P
That completes the proof of Lemma 2.21.
EXAMPLE
2.25
We use the procedure developed in Lemma 2.21 to construct a PDA P1 from the
following CFG G.
S →aT b | b
T →T a | ε
The transition function is shown in the following diagram.
FIGURE
2.26
State diagram of P1
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.2
PUSHDOWN AUTOMATA
121
Now we prove the reverse direction of Theorem 2.20. For the forward di-
rection, we gave a procedure for converting a CFG into a PDA. The main idea
was to design the automaton so that it simulates the grammar. Now we want
to give a procedure for going the other way: converting a PDA into a CFG. We
design the grammar to simulate the automaton. This task is challenging because
“programming” an automaton is easier than “programming” a grammar.
LEMMA
2.27
If a pushdown automaton recognizes some language, then it is context free.
PROOF IDEA
We have a PDA P, and we want to make a CFG G that generates
all the strings that P accepts. In other words, G should generate a string if that
string causes the PDA to go from its start state to an accept state.
To achieve this outcome, we design a grammar that does somewhat more.
For each pair of states p and q in P, the grammar will have a variable Apq. This
variable generates all the strings that can take P from p with an empty stack to
q with an empty stack. Observe that such strings can also take P from p to q,
regardless of the stack contents at p, leaving the stack at q in the same condition
as it was at p.
First, we simplify our task by modifying P slightly to give it the following
three features.
1. It has a single accept state, qaccept.
2. It empties its stack before accepting.
3. Each transition either pushes a symbol onto the stack (a push move) or pops
one off the stack (a pop move), but it does not do both at the same time.
Giving P features 1 and 2 is easy. To give it feature 3, we replace each transition
that simultaneously pops and pushes with a two transition sequence that goes
through a new state, and we replace each transition that neither pops nor pushes
with a two transition sequence that pushes then pops an arbitrary stack symbol.
To design G so that Apq generates all strings that take P from p to q, starting
and ending with an empty stack, we must understand how P operates on these
strings. For any such string x, P’s ﬁrst move on x must be a push, because every
move is either a push or a pop and P can’t pop an empty stack. Similarly, the last
move on x must be a pop because the stack ends up empty.
Two possibilities occur during P’s computation on x.
Either the symbol
popped at the end is the symbol that was pushed at the beginning, or not. If
so, the stack could be empty only at the beginning and end of P’s computation
on x. If not, the initially pushed symbol must get popped at some point be-
fore the end of x and thus the stack becomes empty at this point. We simulate
the former possibility with the rule Apq →aArsb, where a is the input read at
the ﬁrst move, b is the input read at the last move, r is the state following p,
and s is the state preceding q. We simulate the latter possibility with the rule
Apq →AprArq, where r is the state when the stack becomes empty.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

122
CHAPTER 2 / CONTEXT-FREE LANGUAGES
PROOF
Say that P = (Q, Σ, Γ, δ, q0, {qaccept}) and construct G. The variables
of G are {Apq| p, q ∈Q}. The start variable is Aq0,qaccept. Now we describe G’s
rules in three parts.
1. For each p, q, r, s ∈Q, u ∈Γ, and a, b ∈Σε, if δ(p, a, ε) contains (r, u)
and δ(s, b, u) contains (q, ε), put the rule Apq →aArsb in G.
2. For each p, q, r ∈Q, put the rule Apq →AprArq in G.
3. Finally, for each p ∈Q, put the rule App →ε in G.
You may gain some insight for this construction from the following ﬁgures.
FIGURE
2.28
PDA computation corresponding to the rule Apq →AprArq
FIGURE
2.29
PDA computation corresponding to the rule Apq →aArsb
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.2
PUSHDOWN AUTOMATA
123
Now we prove that this construction works by demonstrating that Apq gener-
ates x if and only if (iff) x can bring P from p with empty stack to q with empty
stack. We consider each direction of the iff as a separate claim.
CLAIM
2.30
If Apq generates x, then x can bring P from p with empty stack to q with empty
stack.
We prove this claim by induction on the number of steps in the derivation of
x from Apq.
Basis: The derivation has 1 step.
A derivation with a single step must use a rule whose right-hand side contains no
variables. The only rules in G where no variables occur on the right-hand side
are App →ε. Clearly, input ε takes P from p with empty stack to p with empty
stack so the basis is proved.
Induction step: Assume true for derivations of length at most k, where k ≥1,
and prove true for derivations of length k + 1.
Suppose that Apq
∗⇒x with k + 1 steps. The ﬁrst step in this derivation is either
Apq ⇒aArsb or Apq ⇒AprArq. We handle these two cases separately.
In the ﬁrst case, consider the portion y of x that Ars generates, so x = ayb.
Because Ars
∗⇒y with k steps, the induction hypothesis tells us that P can go
from r on empty stack to s on empty stack. Because Apq →aArsb is a rule of
G, δ(p, a, ε) contains (r, u) and δ(s, b, u) contains (q, ε), for some stack symbol
u. Hence, if P starts at p with empty stack, after reading a it can go to state r
and push u onto the stack. Then reading string y can bring it to s and leave u
on the stack. Then after reading b it can go to state q and pop u off the stack.
Therefore, x can bring it from p with empty stack to q with empty stack.
In the second case, consider the portions y and z of x that Apr and Arq re-
spectively generate, so x = yz. Because Apr
∗⇒y in at most k steps and Arq
∗⇒z
in at most k steps, the induction hypothesis tells us that y can bring P from p
to r, and z can bring P from r to q, with empty stacks at the beginning and
end. Hence x can bring it from p with empty stack to q with empty stack. This
completes the induction step.
CLAIM
2.31
If x can bring P from p with empty stack to q with empty stack, Apq generates x.
We prove this claim by induction on the number of steps in the computation
of P that goes from p to q with empty stacks on input x.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

124
CHAPTER 2 / CONTEXT-FREE LANGUAGES
Basis: The computation has 0 steps.
If a computation has 0 steps, it starts and ends at the same state—say, p. So we
must show that App
∗⇒x. In 0 steps, P cannot read any characters, so x = ε. By
construction, G has the rule App →ε, so the basis is proved.
Induction step: Assume true for computations of length at most k, where k ≥0,
and prove true for computations of length k + 1.
Suppose that P has a computation wherein x brings p to q with empty stacks
in k + 1 steps. Either the stack is empty only at the beginning and end of this
computation, or it becomes empty elsewhere, too.
In the ﬁrst case, the symbol that is pushed at the ﬁrst move must be the same
as the symbol that is popped at the last move. Call this symbol u. Let a be
the input read in the ﬁrst move, b be the input read in the last move, r be the
state after the ﬁrst move, and s be the state before the last move. Then δ(p, a, ε)
contains (r, u) and δ(s, b, u) contains (q, ε), and so rule Apq →aArsb is in G.
Let y be the portion of x without a and b, so x = ayb. Input y can bring
P from r to s without touching the symbol u that is on the stack and so P can
go from r with an empty stack to s with an empty stack on input y. We have
removed the ﬁrst and last steps of the k + 1 steps in the original computation on
x so the computation on y has (k + 1) −2 = k −1 steps. Thus the induction
hypothesis tells us that Ars
∗⇒y. Hence Apq
∗⇒x.
In the second case, let r be a state where the stack becomes empty other than
at the beginning or end of the computation on x. Then the portions of the
computation from p to r and from r to q each contain at most k steps. Say that
y is the input read during the ﬁrst portion and z is the input read during the
second portion. The induction hypothesis tells us that Apr
∗⇒y and Arq
∗⇒z.
Because rule Apq →AprArq is in G, Apq
∗⇒x, and the proof is complete.
That completes the proof of Lemma 2.27 and of Theorem 2.20.
We have just proved that pushdown automata recognize the class of context-
free languages. This proof allows us to establish a relationship between the reg-
ular languages and the context-free languages. Because every regular language
is recognized by a ﬁnite automaton and every ﬁnite automaton is automatically
a pushdown automaton that simply ignores its stack, we now know that every
regular language is also a context-free language.
COROLLARY
2.32
Every regular language is context free.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.3
NON-CONTEXT-FREE LANGUAGES
125
FIGURE
2.33
Relationship of the regular and context-free languages
2.3
NON-CONTEXT-FREE LANGUAGES
In this section we present a technique for proving that certain languages are not
context free. Recall that in Section 1.4 we introduced the pumping lemma for
showing that certain languages are not regular. Here we present a similar pump-
ing lemma for context-free languages. It states that every context-free language
has a special value called the pumping length such that all longer strings in the
language can be “pumped.” This time the meaning of pumped is a bit more com-
plex. It means that the string can be divided into ﬁve parts so that the second and
the fourth parts may be repeated together any number of times and the resulting
string still remains in the language.
THE PUMPING LEMMA FOR CONTEXT-FREE LANGUAGES
THEOREM
2.34
Pumping lemma for context-free languages
If A is a context-free language,
then there is a number p (the pumping length) where, if s is any string in A of
length at least p, then s may be divided into ﬁve pieces s = uvxyz satisfying the
conditions
1. for each i ≥0, uvixyiz ∈A,
2. |vy| > 0, and
3. |vxy| ≤p.
When s is being divided into uvxyz, condition 2 says that either v or y is not
the empty string. Otherwise the theorem would be trivially true. Condition 3
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

126
CHAPTER 2 / CONTEXT-FREE LANGUAGES
states that the pieces v, x, and y together have length at most p. This technical
condition sometimes is useful in proving that certain languages are not context
free.
PROOF IDEA
Let A be a CFL and let G be a CFG that generates it. We must
show that any sufﬁciently long string s in A can be pumped and remain in A.
The idea behind this approach is simple.
Let s be a very long string in A. (We make clear later what we mean by “very
long.”) Because s is in A, it is derivable from G and so has a parse tree. The
parse tree for s must be very tall because s is very long. That is, the parse tree
must contain some long path from the start variable at the root of the tree to
one of the terminal symbols at a leaf. On this long path, some variable symbol R
must repeat because of the pigeonhole principle. As the following ﬁgure shows,
this repetition allows us to replace the subtree under the second occurrence of
R with the subtree under the ﬁrst occurrence of R and still get a legal parse tree.
Therefore, we may cut s into ﬁve pieces uvxyz as the ﬁgure indicates, and we
may repeat the second and fourth pieces and obtain a string still in the language.
In other words, uvixyiz is in A for any i ≥0.
FIGURE
2.35
Surgery on parse trees
Let’s now turn to the details to obtain all three conditions of the pumping
lemma. We also show how to calculate the pumping length p.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.3
NON-CONTEXT-FREE LANGUAGES
127
PROOF
Let G be a CFG for CFL A. Let b be the maximum number of symbols
in the right-hand side of a rule (assume at least 2). In any parse tree using this
grammar, we know that a node can have no more than b children. In other
words, at most b leaves are 1 step from the start variable; at most b2 leaves are
within 2 steps of the start variable; and at most bh leaves are within h steps of the
start variable. So, if the height of the parse tree is at most h, the length of the
string generated is at most bh. Conversely, if a generated string is at least bh + 1
long, each of its parse trees must be at least h + 1 high.
Say |V | is the number of variables in G. We set p, the pumping length, to be
b|V |+1. Now if s is a string in A and its length is p or more, its parse tree must
be at least |V | + 1 high, because b|V |+1 ≥b|V | + 1.
To see how to pump any such string s, let τ be one of its parse trees. If s has
several parse trees, choose τ to be a parse tree that has the smallest number of
nodes. We know that τ must be at least |V | + 1 high, so its longest path from
the root to a leaf has length at least |V | + 1. That path has at least |V | + 2 nodes;
one at a terminal, the others at variables. Hence that path has at least |V | + 1
variables. With G having only |V | variables, some variable R appears more than
once on that path. For convenience later, we select R to be a variable that repeats
among the lowest |V | + 1 variables on this path.
We divide s into uvxyz according to Figure 2.35. Each occurrence of R has
a subtree under it, generating a part of the string s. The upper occurrence of R
has a larger subtree and generates vxy, whereas the lower occurrence generates
just x with a smaller subtree. Both of these subtrees are generated by the same
variable, so we may substitute one for the other and still obtain a valid parse tree.
Replacing the smaller by the larger repeatedly gives parse trees for the strings
uvixyiz at each i > 1. Replacing the larger by the smaller generates the string
uxz. That establishes condition 1 of the lemma. We now turn to conditions 2
and 3.
To get condition 2, we must be sure that v and y are not both ε. If they were,
the parse tree obtained by substituting the smaller subtree for the larger would
have fewer nodes than τ does and would still generate s. This result isn’t possible
because we had already chosen τ to be a parse tree for s with the smallest number
of nodes. That is the reason for selecting τ in this way.
In order to get condition 3, we need to be sure that vxy has length at most p.
In the parse tree for s the upper occurrence of R generates vxy. We chose R so
that both occurrences fall within the bottom |V | + 1 variables on the path, and
we chose the longest path in the parse tree, so the subtree where R generates
vxy is at most |V | + 1 high. A tree of this height can generate a string of length
at most b|V |+1 = p.
For some tips on using the pumping lemma to prove that languages are not
context free, review the text preceding Example 1.73 (page 80) where we dis-
cuss the related problem of proving nonregularity with the pumping lemma for
regular languages.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

128
CHAPTER 2 / CONTEXT-FREE LANGUAGES
EXAMPLE
2.36
Use the pumping lemma to show that the language B = {anbncn| n ≥0} is not
context free.
We assume that B is a CFL and obtain a contradiction. Let p be the pumping
length for B that is guaranteed to exist by the pumping lemma. Select the string
s = apbpcp. Clearly s is a member of B and of length at least p. The pumping
lemma states that s can be pumped, but we show that it cannot. In other words,
we show that no matter how we divide s into uvxyz, one of the three conditions
of the lemma is violated.
First, condition 2 stipulates that either v or y is nonempty. Then we consider
one of two cases, depending on whether substrings v and y contain more than
one type of alphabet symbol.
1. When both v and y contain only one type of alphabet symbol, v does not
contain both a’s and b’s or both b’s and c’s, and the same holds for y. In
this case, the string uv2xy2z cannot contain equal numbers of a’s, b’s, and
c’s. Therefore, it cannot be a member of B. That violates condition 1 of
the lemma and is thus a contradiction.
2. When either v or y contains more than one type of symbol, uv2xy2z may
contain equal numbers of the three alphabet symbols but not in the correct
order. Hence it cannot be a member of B and a contradiction occurs.
One of these cases must occur. Because both cases result in a contradiction, a
contradiction is unavoidable. So the assumption that B is a CFL must be false.
Thus we have proved that B is not a CFL.
EXAMPLE
2.37
Let C = {aibjck|0 ≤i ≤j ≤k}. We use the pumping lemma to show that C is
not a CFL. This language is similar to language B in Example 2.36, but proving
that it is not context free is a bit more complicated.
Assume that C is a CFL and obtain a contradiction. Let p be the pumping
length given by the pumping lemma. We use the string s = apbpcp that we
used earlier, but this time we must “pump down” as well as “pump up.” Let
s = uvxyz and again consider the two cases that occurred in Example 2.36.
1. When both v and y contain only one type of alphabet symbol, v does not
contain both a’s and b’s or both b’s and c’s, and the same holds for y. Note
that the reasoning used previously in case 1 no longer applies. The reason
is that C contains strings with unequal numbers of a’s, b’s, and c’s as long
as the numbers are not decreasing. We must analyze the situation more
carefully to show that s cannot be pumped. Observe that because v and
y contain only one type of alphabet symbol, one of the symbols a, b, or c
doesn’t appear in v or y. We further subdivide this case into three subcases
according to which symbol does not appear.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.3
NON-CONTEXT-FREE LANGUAGES
129
a. The a’s do not appear. Then we try pumping down to obtain the string
uv0xy0z = uxz. That contains the same number of a’s as s does, but
it contains fewer b’s or fewer c’s. Therefore, it is not a member of C,
and a contradiction occurs.
b. The b’s do not appear. Then either a’s or c’s must appear in v or y be-
cause both can’t be the empty string. If a’s appear, the string uv2xy2z
contains more a’s than b’s, so it is not in C. If c’s appear, the string
uv0xy0z contains more b’s than c’s, so it is not in C. Either way, a
contradiction occurs.
c. The c’s do not appear. Then the string uv2xy2z contains more a’s or
more b’s than c’s, so it is not in C, and a contradiction occurs.
2. When either v or y contains more than one type of symbol, uv2xy2z will
not contain the symbols in the correct order. Hence it cannot be a member
of C, and a contradiction occurs.
Thus we have shown that s cannot be pumped in violation of the pumping
lemma and that C is not context free.
EXAMPLE
2.38
Let D = {ww| w ∈{0,1}∗}. Use the pumping lemma to show that D is not a
CFL. Assume that D is a CFL and obtain a contradiction. Let p be the pumping
length given by the pumping lemma.
This time choosing string s is less obvious.
One possibility is the string
0p10p1. It is a member of D and has length greater than p, so it appears to
be a good candidate. But this string can be pumped by dividing it as follows, so
it is not adequate for our purposes.
0p1
z
}|
{
000· · · 000
|
{z
}
u
0
|{z}
v
1
|{z}
x
0p1
z
}|
{
0
|{z}
y
000 · · · 0001
|
{z
}
z
Let’s try another candidate for s. Intuitively, the string 0p1p0p1p seems to
capture more of the “essence” of the language D than the previous candidate
did. In fact, we can show that this string does work, as follows.
We show that the string s = 0p1p0p1p cannot be pumped. This time we use
condition 3 of the pumping lemma to restrict the way that s can be divided. It
says that we can pump s by dividing s = uvxyz, where |vxy| ≤p.
First, we show that the substring vxy must straddle the midpoint of s. Other-
wise, if the substring occurs only in the ﬁrst half of s, pumping s up to uv2xy2z
moves a 1 into the ﬁrst position of the second half, and so it cannot be of the
form ww. Similarly, if vxy occurs in the second half of s, pumping s up to
uv2xy2z moves a 0 into the last position of the ﬁrst half, and so it cannot be of
the form ww.
But if the substring vxy straddles the midpoint of s, when we try to pump s
down to uxz it has the form 0p1i0j1p, where i and j cannot both be p. This
string is not of the form ww. Thus s cannot be pumped, and D is not a CFL.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

130
CHAPTER 2 / CONTEXT-FREE LANGUAGES
2.4
DETERMINISTIC CONTEXT-FREE LANGUAGES
As you recall, deterministic ﬁnite automata and nondeterministic ﬁnite automata
are equivalent in language recognition power.
In contrast, nondeterministic
pushdown automata are more powerful than their deterministic counterparts.
We will show that certain context-free languages cannot be recognized by deter-
ministic PDAs—these languages require nondeterministic PDAs. The languages
that are recognizable by deterministic pushdown automata (DPDAs) are called
deterministic context-free languages (DCFLs). This subclass of the context-free
languages is relevant to practical applications, such as the design of parsers in
compilers for programming languages, because the parsing problem is gener-
ally easier for DCFLs than for CFLs. This section gives a short overview of this
important and beautiful subject.
In deﬁning DPDAs, we conform to the basic principle of determinism: at each
step of its computation, the DPDA has at most one way to proceed according to
its transition function. Deﬁning DPDAs is more complicated than deﬁning DFAs
because DPDAs may read an input symbol without popping a stack symbol, and
vice versa. Accordingly, we allow ε-moves in the DPDA’s transition function even
though ε-moves are prohibited in DFAs. These ε-moves take two forms: ε-input
moves corresponding to δ(q, ε, x), and ε-stack moves corresponding to δ(q, a, ε).
A move may combine both forms, corresponding to δ(q, ε, ε). If a DPDA can
make an ε-move in a certain situation, it is prohibited from making a move in
that same situation that involves processing a symbol instead of ε. Otherwise
multiple valid computation branches might occur, leading to nondeterministic
behavior. The formal deﬁnition follows.
DEFINITION
2.39
A deterministic pushdown automaton is a 6-tuple (Q, Σ, Γ, δ, q0, F),
where Q, Σ, Γ, and F are all ﬁnite sets, and
1. Q is the set of states,
2. Σ is the input alphabet,
3. Γ is the stack alphabet,
4. δ: Q × Σε × Γε−→(Q × Γε) ∪{∅} is the transition function,
5. q0 ∈Q is the start state, and
6. F ⊆Q is the set of accept states.
The transition function δ must satisfy the following condition.
For every q ∈Q, a ∈Σ, and x ∈Γ, exactly one of the values
δ(q, a, x), δ(q, a, ε), δ(q, ε, x), and δ(q, ε, ε)
is not ∅.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.4
DETERMINISTIC CONTEXT-FREE LANGUAGES
131
The transition function may output either a single move of the form (r, y)
or it may indicate no action by outputting ∅. To illustrate these possibilities,
let’s consider an example. Suppose a DPDA M with transition function δ is in
state q, has a as its next input symbol, and has symbol x on the top of its stack.
If δ(q, a, x) = (r, y) then M reads a, pops x off the stack, enters state r, and
pushes y on the stack. Alternatively, if δ(q, a, x) = ∅then when M is in state q,
it has no move that reads a and pops x. In that case, the condition on δ requires
that one of δ(q, ε, x), δ(q, a, ε), or δ(q, ε, ε) is nonempty, and then M moves
accordingly. The condition enforces deterministic behavior by preventing the
DPDA from taking two different actions in the same situation, such as would be
the case if both δ(q, a, x) ̸= ∅and δ(q, a, ε) ̸= ∅. A DPDA has exactly one legal
move in every situation where its stack is nonempty. If the stack is empty, a DPDA
can move only if the transition function speciﬁes a move that pops ε. Otherwise
the DPDA has no legal move and it rejects without reading the rest of the input.
Acceptance for DPDAs works in the same way it does for PDAs. If a DPDA
enters an accept state after it has read the last input symbol of an input string,
it accepts that string. In all other cases, it rejects that string. Rejection occurs if
the DPDA reads the entire input but doesn’t enter an accept state when it is at the
end, or if the DPDA fails to read the entire input string. The latter case may arise
if the DPDA tries to pop an empty stack or if the DPDA makes an endless sequence
of ε-input moves without reading the input past a certain point.
The language of a DPDA is called a deterministic context-free language.
EXAMPLE
2.40
The language {0n1n| n ≥0} in Example 2.14 is a DCFL. We can easily modify its
PDA M1 to be a DPDA by adding transitions for any missing state, input symbol,
and stack symbol combinations to a “dead” state from which acceptance isn’t
possible.
Examples 2.16 and 2.18 give CFLs {aibjck| i, j, k ≥0 and i = j or i = k} and
{wwR| w ∈{0,1}∗}, which are not DCFLs. Problems 2.57 and 2.58 show that
nondeterminism is necessary for recognizing these languages.
Arguments involving DPDAs tend to be somewhat technical in nature, and
though we strive to emphasize the primary ideas behind the constructions, read-
ers may ﬁnd this section to be more challenging than other sections in the ﬁrst
few chapters. Later material in the book doesn’t depend on this section, so it
may be skipped if desired.
We’ll begin with a technical lemma that will simplify the discussion later on.
As noted, DPDAs may reject inputs by failing to read the entire input string, but
such DPDAs introduce messy cases. Fortunately, the next lemma shows that we
can convert a DPDA into one that avoids this inconvenient behavior.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

132
CHAPTER 2 / CONTEXT-FREE LANGUAGES
LEMMA
2.41
Every DPDA has an equivalent DPDA that always reads the entire input string.
PROOF IDEA
A DPDA may fail to read the entire input if it tries to pop an
empty stack or because it makes an endless sequence of ε-input moves. Call the
ﬁrst situation hanging and the second situation looping. We solve the hanging
problem by initializing the stack with a special symbol. If that symbol is later
popped from the stack before the end of the input, the DPDA reads to the end of
the input and rejects. We solve the looping problem by identifying the looping
situations, i.e., those from which no further input symbol is ever read, and re-
programming the DPDA so that it reads and rejects the input instead of looping.
We must adjust these modiﬁcations to accommodate the case where hanging or
looping occurs on the last symbol of the input. If the DPDA enters an accept state
at any point after it has read the last symbol, the modiﬁed DPDA accepts instead
of rejects.
PROOF
Let P = (Q, Σ, Γ, δ, q0, F) be a DPDA. First, add a new start state
qstart, an additional accept state qaccept, a new state qreject, as well as other new
states as described. Perform the following changes for for every r ∈Q, a ∈Σε,
and x, y ∈Γε.
First modify P so that, once it enters an accept state, it remains in accepting
states until it reads the next input symbol. Add a new accept state qa for every
q ∈Q. For each q ∈Q, if δ(q, ε, x) = (r, y), set δ(qa, ε, x) = (ra, y), and then if
q ∈F, also change δ so that δ(q, ε, x) = (ra, y). For each q ∈Q and a ∈Γ, if
δ(q, a, x) = (r, y) set δ(qa, a, x) = (r, y). Let F ′ be the set of new and old accept
states.
Next, modify P to reject when it tries to pop an empty stack, by initializing
the stack with a special new stack symbol $. If P subsequently detects $ while in
a non-accepting state, it enters qreject and scans the input to the end. If P detects
$ while in an accept state, it enters qaccept. Then, if any input remains unread, it
enters qreject and scans the input to the end. Formally, set δ(qstart, ε, ε) = (q0, $).
For x ∈Γ and δ(q, a, x) ̸= ∅, if q ̸∈F ′ then set δ(q, a, $) = (qreject, ε), and if
q ∈F ′ then set δ(q, a, $) = (qaccept, ε). For a ∈Σ, set δ(qreject, a, ε) = (qreject, ε)
and δ(qaccept, a, ε) = (qreject, ε).
Lastly, modify P to reject instead of making an endless sequence of ε-input
moves prior to the end of the input. For every q ∈Q and x ∈Γ, call (q, x)
a looping situation if, when P is started in state q with x ∈Γ on the top of the
stack, it never pops anything below x and it never reads an input symbol. Say
the looping situation is accepting if P enters an accept state during its subsequent
moves, and otherwise it is rejecting. If (q, x) is an accepting looping situation,
set δ(q, ε, x) = (qaccept, ε), whereas if (q, x) is a rejecting looping situation, set
δ(q, ε, x) = (qreject, ε).
For simplicity, we’ll assume henceforth that DPDAs read their input to the end.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.4
DETERMINISTIC CONTEXT-FREE LANGUAGES
133
PROPERTIES OF DCFLS
We’ll explore closure and nonclosure properties of the class of DCFLs, and use
these to exhibit a CFL that is not a DCFL.
THEOREM
2.42
The class of DCFLs is closed under complementation.
PROOF IDEA
Swapping the accept and non-accept states of a DFA yields a
new DFA that recognizes the complementary language, thereby proving that the
class of regular languages is closed under complementation. The same approach
works for DPDAs, except for one problem. The DPDA may accept its input by
entering both accept and non-accept states in a sequence of moves at the end of
the input string. Interchanging accept and non-accept states would still accept
in this case.
We ﬁx this problem by modifying the DPDA to limit when acceptance can
occur. For each symbol of the input, the modiﬁed DPDA can enter an accept
state only when it is about to read the next symbol. In other words, only reading
states—states that always read an input symbol—may be accept states. Then, by
swapping acceptance and non-acceptance only among these reading states, we
invert the output of the DPDA.
PROOF
First modify P as described in the proof of Lemma 2.41 and let
(Q, Σ, Γ, δ, q0, F) be the resulting machine. This machine always reads the en-
tire input string. Moreover, once enters an accept state, it remains in accept
states until it reads the next input symbol.
In order to carry out the proof idea, we need to identify the reading states.
If the DPDA in state q reads an input symbol a ∈Σ without popping the stack,
i.e., δ(q, a, ε) ̸= ∅, designate q to be a reading state. However, if it reads and also
pops, the decision to read may depend on the popped symbol, so divide that step
into two: a pop and then a read. Thus if δ(q, a, x) = (r, y) for a ∈Σ and x ∈Γ,
add a new state qx and modify δ so δ(q, ε, x) = (qx, ε) and δ(qx, a, ε) = (r, y).
Designate qx to be a reading state. The states qx never pop the stack, so their
action is independent of the stack contents. Assign qx to be an accept state if
q ∈F. Finally, remove the accepting state designation from any state which isn’t
a reading state. The modiﬁed DPDA is equivalent to P, but it enters an accept
state at most once per input symbol, when it is about to read the next symbol.
Now, invert which reading states are classiﬁed as accepting. The resulting
DPDA recognizes the complementary language.
This theorem implies that some CFLs are not DCFLs. Any CFL whose comple-
ment isn’t a CFL isn’t a DCFL. Thus A = {aibjck|i ̸= j or j ̸= k where i, j, k ≥0}
is a CFL but not a DCFL. Otherwise A would be a CFL, so the result of Problem 2.18
would incorrectly imply that A ∩a∗b∗c∗= {anbncn| n ≥0} is context free.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

134
CHAPTER 2 / CONTEXT-FREE LANGUAGES
Problem 2.53 asks you to show that the class of DCFLs isn’t closed under other
familiar operations such as union, intersection, star, and reversal.
To simplify arguments, we will occasionally consider endmarked inputs
whereby the special endmarker symbol ⊣⊣⊣is appended to the input string. Here
we add ⊣⊣⊣to the DPDA’s input alphabet. As we show in the next theorem, adding
endmarkers doesn’t change the power of DPDAs. However, designing DPDAs on
endmarked inputs is often easier because we can take advantage of knowing when
the input string ends. For any language A, we write the endmarked language
A⊣⊣⊣to be the collection of strings w⊣⊣⊣where w ∈A.
THEOREM
2.43
A is a DCFL if and only if A⊣⊣⊣is a DCFL.
PROOF IDEA
Proving the forward direction of this theorem is routine. Say
DPDA P recognizes A. Then DPDA P ′ recognizes A⊣⊣⊣by simulating P until P ′
reads ⊣⊣⊣. At that point, P ′ accepts if P had entered an accept state during the
previous symbol. P ′ doesn’t read any symbols after ⊣⊣⊣.
To prove the reverse direction, let DPDA P recognize A⊣⊣⊣and construct a
DPDA P ′ that recognizes A. As P ′ reads its input, it simulates P. Prior to read-
ing each input symbol, P ′ determines whether P would accept if that symbol
were ⊣⊣⊣. If so, P ′ enters an accept state. Observe that P may operate the stack
after it reads ⊣⊣⊣, so determining whether it accepts after reading ⊣⊣⊣may depend
on the stack contents. Of course, P ′ cannot afford to pop the entire stack at
every input symbol, so it must determine what P would do after reading ⊣⊣⊣, but
without popping the stack. Instead, P ′ stores additional information on the stack
that allows P ′ to determine immediately whether P would accept. This infor-
mation indicates from which states P would eventually accept while (possibly)
manipulating the stack, but without reading further input.
PROOF
We give proof details of the reverse direction only. As we described in
the proof idea, let DPDA P = (Q, Σ∪{⊣⊣⊣}, Γ, δ, q0, F) recognize A⊣⊣⊣and construct
a DPDA P ′ = (Q′, Σ, Γ′, δ′, q0′, F ′) that recognizes A. First, modify P so that
each of its moves does exactly one of the following operations: read an input
symbol; push a symbol onto the stack; or pop a symbol from the stack. Making
this modiﬁcation is straightforward by introducing new states.
P ′ simulates P, while maintaining a copy of its stack contents interleaved
with additional information on the stack. Every time P ′ pushes one of P’s stack
symbols, P ′ follows that by pushing a symbol that represents a subset of P’s
states. Thus we set Γ′ = Γ ∪P(Q). The stack in P ′ interleaves members of Γ
with members of P(Q). If R ∈P(Q) is the top stack symbol, then by starting
P in any one of R’s states, P will eventually accept without reading any more
input.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.4
DETERMINISTIC CONTEXT-FREE LANGUAGES
135
Initially, P ′ pushes the set R0 on the stack, where R0 contains every state
q such that when P is started in q with an empty stack, it eventually accepts
without reading any input symbols. Then P ′ begins simulating P. To simulate a
pop move, P ′ ﬁrst pops and discards the set of states that appears as the top stack
symbol, then it pops again to obtain the symbol that P would have popped at
this point, and uses it to determine the next move of P. Simulating a push move
δ(q, ε, ε) = (r, x), where P pushes x as it goes from state q to state r, goes as
follows. First P ′ examines the set of states R on the top of its stack, and then it
pushes x and after that the set S, where q ∈S if q ∈F or if δ(q, ε, x) = (r, ε) and
r ∈R. In other words, S is the set of states that are either accepting immediately,
or that would lead to a state in R after popping x. Lastly, P ′ simulates a read
move δ(q, a, ε) = (r, ε), by examining the set R on the top of the stack and
entering an accept state if r ∈R. If P ′ is at the end of the input string when
it enters this state, it will accept the input. If it is not at the end of the input
string, it will continue simulating P, so this accept state must also record P’s
state. Thus we create this state as a second copy of P’s original state, marking it
as an accept state in P ′.
DETERMINISTIC CONTEXT-FREE GRAMMARS
This section deﬁnes deterministic context-free grammars, the counterpart to
deterministic pushdown automata.
We will show that these two models are
equivalent in power, provided that we restrict our attention to endmarked lan-
guages, where all strings are terminated with ⊣⊣⊣. Thus the correspondence isn’t
quite as strong as we saw in regular expressions and ﬁnite automata, or in CFGs
and PDAs, where the generating model and the recognizing model describe ex-
actly the same class of languages without the need for endmarkers. However, in
the case of DPDAs and DCFGs, the endmarkers are necessary because equivalence
doesn’t hold otherwise.
In a deterministic automaton, each step in a computation determines the next
step. The automaton cannot make choices about how it proceeds because only a
single possibility is available at every point. To deﬁne determinism in a grammar,
observe that computations in automata correspond to derivations in grammars.
In a deterministic grammar, derivations are constrained, as you will see.
Derivations in CFGs begin with the start variable and proceed “top down”
with a series of substitutions according to the grammar’s rules, until the deriva-
tion obtains a string of terminals. For deﬁning DCFGs we take a “bottom up”
approach, by starting with a string of terminals and processing the derivation
in reverse, employing a series of reduce steps until reaching the start variable.
Each reduce step is a reversed substitution, whereby the string of terminals and
variables on the right-hand side of a rule is replaced by the variable on the cor-
responding left-hand side. The string replaced is called the reducing string. We
call the entire reversed derivation a reduction. Deterministic CFGs are deﬁned
in terms of reductions that have a certain property.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

136
CHAPTER 2 / CONTEXT-FREE LANGUAGES
More formally, if u and v are strings of variables and terminals, write u ↣v
to mean that v can be obtained from u by a reduce step. In other words, u ↣v
means the same as v ⇒u. A reduction from u to v is a sequence
u = u1 ↣u2 ↣. . . ↣uk = v
and we say that u is reducible to v, written u
∗↣v. Thus u
∗↣v whenever
v
∗⇒u. A reduction from u is a reduction from u to the start variable. In a
leftmost reduction, each reducing string is reduced only after all other reducing
strings that lie entirely to its left. With a little thought we can see that a leftmost
reduction is a rightmost derivation in reverse.
Here’s the idea behind determinism in CFGs. In a CFG with start variable S
and string w in its language, say that a leftmost reduction of w is
w = u1 ↣u2 ↣. . . ↣uk = S.
First, we stipulate that every ui determines the next reduce step and hence ui+1.
Thus w determines its entire leftmost reduction. This requirement implies only
that the grammar is unambiguous. To get determinism, we need to go further.
In each ui, the next reduce step must be uniquely determined by the preﬁx of
ui up through and including the reducing string h of that reduce step. In other
words, the leftmost reduce step in ui doesn’t depend on the symbols in ui to the
right of its reducing string.
Introducing terminology will help us make this idea precise. Let w be a string
in the language of CFG G, and let ui appear in a leftmost reduction of w. In
the reduce step ui ↣ui+1, say that rule T →h was applied in reverse. That
means we can write ui = xhy and ui+1 = xT y, where h is the reducing string,
x is the part of ui that appears leftward of h, and y is the part of ui that appears
rightward of h. Pictorially,
ui =
x
z
}|
{
x1 · · · xj
h
z
}|
{
h1 · · · hk
y
z }| {
y1 · · · yl ↣
x
z
}|
{
x1 · · · xj
T
z}|{
T
y
z }| {
y1 · · · yl = ui+1.
FIGURE
2.44
Expanded view of xhy ↣xT y
We call h, together with its reducing rule T →h, a handle of ui. In other
words, a handle of a string ui that appears in a leftmost reduction of w ∈L(G) is
the occurrence of the reducing string in ui, together with the reducing rule for
ui in this reduction. Occasionally we associate a handle with its reducing string
only, when we aren’t concerned with the reducing rule. A string that appears in
a leftmost reduction of some string in L(G) is called a valid string. We deﬁne
handles only for valid strings.
A valid string may have several handles, but only if the grammar is ambigu-
ous. Unambiguous grammars may generate strings by one parse tree only, and
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.4
DETERMINISTIC CONTEXT-FREE LANGUAGES
137
therefore the leftmost reductions, and hence the handles, are also unique. In
that case, we may refer to the handle of a valid string.
Observe that y, the portion of ui following a handle, is always a string of ter-
minals because the reduction is leftmost. Otherwise, y would contain a variable
symbol and that could arise only from a previous reduce step whose reducing
string was completely to the right of h. But then the leftmost reduction should
have reduced the handle at an earlier step.
EXAMPLE
2.45
Consider the grammar G1:
R →S | T
S →aSb | ab
T →aT bb | abb
Its language is B ∪C where B = {ambm| m ≥1} and C = {amb2m| m ≥1}.
In this leftmost reduction of the string aaabbb ∈L(G1), we’ve underlined the
handle at each step:
aaabbb ↣aaSbb ↣aSb ↣S ↣R.
Similarly, this is a leftmost reduction of the string aaabbbbbb:
aaabbbbbb ↣aaTbbbb ↣aTbb ↣T ↣R.
In both cases, the leftmost reduction shown happens to be the only reduction
possible; but in other grammars where several reductions may occur, we must
use a leftmost reduction to deﬁne the handles. Notice that the handles of aaabbb
and aaabbbbbb are unequal, even though the initial parts of these strings agree.
We’ll discuss this point in more detail shortly when we deﬁne DCFGs.
A PDA can recognize L(G1) by using its nondeterminism to guess whether its
input is in B or in C. Then, after it pushes the a’s on the stack, it pops the a’s and
matches each one with b or bb accordingly. Problem 2.55 asks you to show that
L(G1) is not a DCFL. If you try to make a DPDA that recognizes this language,
you’ll see that the machine cannot know in advance whether the input is in B or
in C so it doesn’t know how to match the a’s with the b’s. Contrast this grammar
with grammar G2:
R →1S | 2T
S →aSb | ab
T →aT bb | abb
where the ﬁrst symbol in the input provides this information. Our deﬁnition of
DCFGs must include G2 yet exclude G1.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

138
CHAPTER 2 / CONTEXT-FREE LANGUAGES
EXAMPLE
2.46
Let G3 be the following grammar:
S →T⊣⊣⊣
T →T (T ) | ε
This grammar illustrates several points. First, it generates an endmarked lan-
guage.
We will focus on endmarked languages later on when we prove the
equivalence between DPDAs and DCFGs. Second, ε handles may occur in re-
ductions, as indicated with short underscores in the leftmost reduction of the
string ()()⊣⊣⊣:
()()⊣⊣⊣↣T ( )()⊣⊣⊣↣T (T )()⊣⊣⊣↣T ( )⊣⊣⊣↣T (T )⊣⊣⊣↣T⊣⊣⊣↣S.
Handles play an important role in deﬁning DCFGs because handles determine
reductions. Once we know the handle of a string, we know the next reduce step.
To make sense of the coming deﬁnition, keep our goal in mind: we aim to deﬁne
DCFGs so that they correspond to DPDAs. We’ll establish that correspondence
by showing how to convert DCFGs to equivalent DPDAs, and vice versa. For this
conversion to work, the DPDA needs to ﬁnd handles so that it can ﬁnd reductions.
But ﬁnding a handle may be tricky. It seems that we need to know a string’s next
reduce step to identify its handle, but a DPDA doesn’t know the reduction in
advance. We’ll solve this by restricting handles in a DCFG so that the DPDA can
ﬁnd them more easily.
To motivate the deﬁnition, consider ambiguous grammars, where some
strings have several handles. Selecting a speciﬁc handle may require advance
knowledge of which parse tree derives the string, information that is certainly
unavailable to the DPDA. We’ll see that DCFGs are unambiguous so handles
are unique. However, uniqueness alone is unsatisfactory for deﬁning DCFGs as
grammar G1 in Example 2.45 shows.
Why don’t unique handles imply that we have a DCFG? The answer is evident
by examining the handles in G1. If w ∈B, the handle is ab, whereas if w ∈C, the
handle is abb. Though w determines which of these cases applies, discovering
which of ab or abb is the handle may require examining all of w, and a DPDA
hasn’t read the entire input when it needs to select the handle.
In order to deﬁne DCFGs that correspond to DPDAs, we impose a stronger
requirement on the handles. The initial part of a valid string, up to and including
its handle, must be sufﬁcient to determine the handle. Thus, if we are reading a
valid string from left to right, as soon as we read the handle we know we have it.
We don’t need to read beyond the handle in order to identify the handle. Recall
that the unread part of the valid string contains only terminals because the valid
string has been obtained by a leftmost reduction of an initial string of terminals,
and the unread part hasn’t been processed yet. Accordingly, we say that a handle
h of a valid string v = xhy is a forced handle if h is the unique handle in every
valid string xhˆy where ˆy ∈Σ∗.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.4
DETERMINISTIC CONTEXT-FREE LANGUAGES
139
DEFINITION
2.47
A deterministic context-free grammar is a context-free grammar
such that every valid string has a forced handle.
For simplicity, we’ll assume throughout this section on deterministic context-
free languages that the start variable of a CFG doesn’t appear on the right-hand
side of any rule and that every variable in a grammar appears in a reduction of
some string in the grammar’s language, i.e., grammars contain no useless vari-
ables.
Though our deﬁnition of DCFGs is mathematically precise, it doesn’t give any
obvious way to determine whether a CFG is deterministic. Next we’ll present a
procedure to do exactly that, called the DK-test. We’ll also use the construction
underlying the DK-test to enable a DPDA to ﬁnd handles, when we show how to
convert a DCFG to a DPDA.
The DK-test relies on one simple but surprising fact. For any CFG G we
can construct an associated DFA DK that can identify handles. Speciﬁcally, DK
accepts its input z if
1. z is the preﬁx of some valid string v = zy, and
2. z ends with a handle of v.
Moreover, each accept state of DK indicates the associated reducing rule(s). In
a general CFG, multiple reducing rules may apply, depending on which valid v
extends z. But in a DCFG, as we’ll see, each accept state corresponds to exactly
one reducing rule.
We will describe the DK-test after we’ve presented DK formally and estab-
lished its properties, but here’s the plan. In a DCFG, all handles are forced. Thus
if zy is a valid string with a preﬁx z that ends in a handle of zy, that handle is
unique, and it is also the handle for all valid strings zˆy. For these properties
to hold, each of DK’s accept states must be associated with a single handle and
hence with a single applicable reducing rule. Moreover, the accept state must
not have an outgoing path that leads to an accept state by reading a string in Σ∗.
Otherwise, the handle of zy would not be unique or it would depend on y. In
the DK-test, we construct DK and then conclude that G is deterministic if all of
its accept states have these properties.
To construct DFA DK, we’ll construct an equivalent NFA K and convert K to
DK1 via the subset construction introduced in Theorem 1.39. To understand
K, ﬁrst consider an NFA J that performs a simpler task. It accepts every input
string that ends with the right-hand side of any rule. Constructing J is easy. It
guesses which rule to use and it also guesses the point at which to start matching
the input with that rule’s right-hand side. As it matches the input, J keeps track
1The name DK is a mnemonic for “deterministic K” but it also stands for Donald Knuth,
who ﬁrst proposed this idea.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

140
CHAPTER 2 / CONTEXT-FREE LANGUAGES
of its progress through the chosen right-hand side. We represent this progress
by placing a dot in the corresponding point in the rule, yielding a dotted rule,
also called an item in some other treatments of this material. Thus for each rule
B →u1u2 · · · uk with k symbols on the right-hand side, we get k + 1 dotted
rules:
B →.u1u2 · · · uk
B →u1.u2 · · · uk
...
B →u1u2 · · ·.uk
B →u1u2 · · · uk.
Each of these dotted rules corresponds to one state of J. We indicate the state
associated with the dotted rule B →u.v with a box around it,


 
B →u.v . The
accept states


 


 
B →u. correspond to the completed rules that have the dot at
the end. We add a separate start state with a self-loop on all symbols and an
ε-move to


 
B →.u for each rule B →u. Thus J accepts if the match completes
successfully at the end of the input. If a mismatch occurs or if the end of the
match doesn’t coincide with the end of the input, this branch of J’s computation
rejects.
NFA K operates similarly, but it is more judicious about choosing a rule for
matching. Only potential reducing rules are allowed. Like J, its states cor-
respond to all dotted rules. It has a special start state that has an ε-move to


 
S1 →.u for every rule involving the start variable S1. On each branch of its
computation, K matches a potential reducing rule with a substring of the input.
If that rule’s right-hand side contains a variable, K may nondeterministically
switch to some rule that expands that variable. Lemma 2.48 formalizes this idea.
First we describe K in detail.
The transitions come in two varieties: shift-moves and ϵ-moves. The shift-
moves appear for every a that is a terminal or variable, and every rule B →uav:
B    u •av
B    ua •v
a
The ϵ-moves appear for all rules B →uCv and C →r:
B    u •Cv
C    •r
ε
The accept states are all


 


 
B →u. corresponding to a completed rule. Accept
states have no outgoing transitions and are written with a double box.
The next lemma and its corollary prove that K accepts all strings z that end
with handles for some valid extension of z. Because K is nondeterministic, we
say that it “may” enter a state to mean that K does enter that state on some
branch of its nondeterminism.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.4
DETERMINISTIC CONTEXT-FREE LANGUAGES
141
LEMMA
2.48
K may enter state


 
T →u.v on reading input z iff z = xu and xuvy is a valid
string with handle uv and reducing rule T →uv, for some y ∈Σ∗.
PROOF IDEA
K operates by matching a selected rule’s right-hand side with
a portion of the input. If that match completes successfully, it accepts. If that
right-hand side contains a variable C, either of two situations may arise. If C
is the next input symbol, then matching the selected rule simply continues. If
C has been expanded, the input will contain symbols derived from C, so K
nondeterministically selects a substitution rule for C and starts matching from
the beginning of the right-hand side of that rule. It accepts when the right-hand
side of the currently selected rule has been matched completely.
PROOF
First we prove the forward direction. Assume that K on w enters


 
T →u.v . Examine K’s path from its start state to


 
T →u.v . Think of the path
as runs of shift-moves separated by ε-moves. The shift-moves are transitions
between states sharing the same rule, shifting the dot rightward over symbols
read from the input. In the ith run, say that the rule is Si →uiSi+1vi, where
Si+1 is the variable expanded in the next run. The penultimate run is for rule
Sl →ulT vl, and the ﬁnal run has rule T →uv.
Input z must then equal u1u2 . . . ulu = xu because the strings ui and u were
the shift-move symbols read from the input. Letting y′ = vl . . . v2v1, we see that
xuvy′ is derivable in G because the rules above give the derivation as shown in
the parse tree illustrated in Figure 2.49.
…
…
S1
S2
S3
T
x
y’
u
v
…
x
FIGURE
2.49
Parse tree leading to xuvy′
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

142
CHAPTER 2 / CONTEXT-FREE LANGUAGES
To obtain a valid string, fully expand all variables that appear in y′ until each
variable derives some string of terminals, and call the resulting string y. The
string xuvy is valid because it occurs in a leftmost reduction of w ∈L(G), a
string of terminals obtained by fully expanding all variables in xuvy.
As is evident from the ﬁgure below, uv is the handle in the reduction and its
reducing rule is T →uv.
…
…
S1
S2
S3
T
x
y
u
v
…
x
FIGURE
2.50
Parse tree leading to valid string xuvy with handle uv
Now we prove the reverse direction of the lemma. Assume that string xuvy is
a valid string with handle uv and reducing rule T →uv. Show that K on input
xu may enter state


 
T →u.v .
The parse tree for xuvy appears in the preceding ﬁgure. It is rooted at the
start variable S1 and it must contain the variable T because T →uv is the ﬁrst
reduce step in the reduction of xuvy. Let S2, . . . , Sl be the variables on the path
from S1 to T as shown. Note that all variables in the parse tree that appear
leftward of this path must be unexpanded, or else uv wouldn’t be the handle.
In this parse tree, each Si leads to Si+1 by some rule Si →uiSi+1vi. Thus
the grammar must contain the following rules for some strings ui and vi.
S1 →u1S2v1
S2 →u2S3v2
...
Sl →ulT vl
T →uv
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.4
DETERMINISTIC CONTEXT-FREE LANGUAGES
143
K contains the following path from its start state to state


 
T →u.v on reading
input z = xu. First, K makes an ϵ-move to


 
S1 →.u1S2v1 . Then, while read-
ing the symbols of u1, it performs the corresponding shift-moves until it enters


 
S1 →u1.S2v1 at the end of u1. Then it makes an ε-move to


 
S2 →.u2S3v2 and
continues with shift-moves on reading u2 until it reaches


 
S2 →u2.S3v2 and so
on. After reading ul it enters


 
Sl →ul.Tvl which leads by an ϵ-move to


 
T →.uv
and ﬁnally after reading u it is in


 
T →u.v .
The following corollary shows that K accepts all strings ending with a handle
of some valid extension. It follows from Lemma 2.48 by taking u = h and v = ε.
COROLLARY
2.51
K may enter accept state


 


 
T →h. on input z iff z = xh and h is a handle of
some valid string xhy with reducing rule T →h.
Finally, we convert NFA K to DFA DK by using the subset construction in
the proof of Theorem 1.39 on page 55 and then removing all states that are un-
reachable from the start state. Each of DK’s states thus contains one or more
dotted rules. Each accept state contains at least one completed rule. We can ap-
ply Lemma 2.48 and Corollary 2.51 to DK by referring to the states that contain
the indicated dotted rules.
Now we are ready to describe the DK-test.
Starting with a CFG G, construct the associated DFA DK. Determine whether
G is deterministic by examining DK’s accept states. The DK-test stipulates that
every accept state contains
1. exactly one completed rule, and
2. no dotted rule in which a terminal symbol immediately follows the dot,
i.e., no dotted rule of the form B →u.av for a ∈Σ.
THEOREM
2.52
G passes the DK-test iff G is a DCFG.
PROOF IDEA
We’ll show that the DK-test passes if and only if all handles
are forced. Equivalently, the test fails iff some handle isn’t forced. First, suppose
that some valid string has an unforced handle. If we run DK on this string,
Corollary 2.51 says that DK enters an accept state at the end of the handle. The
DK-test fails because that accept state has either a second completed rule or an
outgoing path leading to an accept state, where the outgoing path begins with a
terminal symbol. In the latter case, the accept state would contain a dotted rule
with a terminal symbol following the dot.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

144
CHAPTER 2 / CONTEXT-FREE LANGUAGES
Conversely, if the DK-test fails because an accept state has two completed
rules, extend the associated string to two valid strings with differing handles at
that point. Similarly, if it has a completed rule and a dotted rule with a terminal
following the dot, employ Lemma 2.48 to get two valid extensions with differing
handles at that point. Constructing the valid extension corresponding to the
second rule is a bit delicate.
PROOF
Start with the forward direction. Assume that G isn’t deterministic
and show that it fails the DK-test. Take a valid string xhy that has an unforced
handle h. Hence some valid string xhy′ has a different handle ˆh ̸= h, where y′
is a string of terminals. We can thus write xhy′ as xhy′ = ˆxˆhˆy.
If xh = ˆxˆh, the reducing rules differ because h and ˆh aren’t the same handle.
Therefore, input xh sends DK to a state that contains two completed rules, a
violation of the DK-test.
If xh ̸= ˆxˆh, one of these extends the other. Assume that xh is the proper
preﬁx of ˆxˆh. The argument is the same with the strings interchanged and y in
place of y′, if ˆxˆh is the shorter string. Let q be the state that DK enters on input
xh. State q must be accepting because h is a handle of xhy. A transition arrow
must exit q because ˆxˆh sends DK to an accept state via q. Furthermore, that
transition arrow is labeled with a terminal symbol, because y′ ∈Σ+. Here y′ ̸= ε
because ˆxˆh extends xh. Hence q contains a dotted rule with a terminal symbol
immediately following the dot, violating the DK-test.
To prove the reverse direction, assume G fails the DK-test at some accept
state q, and show that G isn’t deterministic by exhibiting an unforced handle.
Because q is accepting, it has a completed rule T →h.. Let z be a string that
leads DK to q. Then z = xh where some valid string xhy has handle h with
reducing rule T →h, for y ∈Σ∗. Now we consider two cases, depending on
how the DK-test fails.
First, say q has another completed rule B →ˆh.. Then some valid string xhy′
must have a different handle ˆh with reducing rule B →ˆh. Therefore, h isn’t a
forced handle.
Second, say q contains a rule B →u.av where a ∈Σ. Because xh takes DK
to q, we have xh = ˆxu, where ˆxuavˆy is valid and has a handle uav with reducing
rule B →uav, for some ˆy ∈Σ∗. To show that h is unforced, fully expand all
variables in v to get the result v′ ∈Σ∗, then let y′ = av′ˆy and notice that y′ ∈Σ∗.
The following leftmost reduction shows that xhy′ is a valid string and h is not
the handle.
xhy′ = xhav′ˆy = ˆx uav′ ˆy
∗↣ˆx uav ˆy ↣ˆx B ˆy
∗↣S
where S is the start variable. We know that ˆx uav ˆy is valid and we can obtain
ˆx uav′ˆy from it by using a rightmost derivation so ˆx uav′ ˆy is also valid. More-
over, the handle of ˆx uav′ˆy either lies inside v′ (if v ̸= v′) or is uav (if v = v′).
In either case, the handle includes a or follows a and thus cannot be h because h
fully precedes a. Hence h isn’t a forced handle.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.4
DETERMINISTIC CONTEXT-FREE LANGUAGES
145
When building the DFA DK in practice, a direct construction may be faster
than ﬁrst constructing the NFA K. Begin by adding a dot at the initial point in
all rules involving the start variable and place these now-dotted rules into DK’s
start state. If a dot precedes a variable C in any of these rules, place dots at the
initial position in all rules that have C on the left-hand side and add these rules
to the state, continuing this process until no new dotted rules are obtained. For
any symbol c that follows a dot, add an outgoing edge labeled c to a new state
containing the dotted rules obtained by shifting the dot across the c in any of the
dotted rules where the dot precedes the c, and add rules corresponding to the
rules where a dot precedes a variable as before.
EXAMPLE
2.53
Here we illustrate how the DK-test fails for the following grammar.
S →E⊣⊣⊣
E →E + T | T
T →T x a | a
E
S    •E⊣
E   •E+T
E   •T
T    •T ×a
T    • a
S   E •⊣
E  E •+T
E   E+•T
T   •T×a
T   • a
T   a •
S   E⊣•
E   E+T •
T    T •×a
E   T •
T    T •×a
⊣
T   T ×• a
T
T   T ×a •
+
a
×
×
a
T
T   T ×a •
a
FIGURE
2.54
Example of a failed DK-test
Notice the two problematic states at the lower left and the second from the
top right, where an accept state contains a dotted rule where a terminal symbol
follows the dot.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

146
CHAPTER 2 / CONTEXT-FREE LANGUAGES
EXAMPLE
2.55
Here is the DFA DK showing that the grammar below is a DCFG.
S →T⊣⊣⊣
T →T (T ) | ε
S    •T ⊣
T    •T(T )
T    •
T    T (•T )
T    •T(T )
T    •
T
S    T •⊣
T    T •(T)
T
T    T (T •)
T    T •(T )
S    T ⊣•
⊣
T    (T )•
)
(
(
FIGURE
2.56
Example of a DK-test that passes
Observe that all accept states satisfy the DK-test conditions.
RELATIONSHIP OF DPDAS AND DCFGS
In this section we will show that DPDAs and DCFGs describe the same class of
endmarked languages.
First, we will demonstrate how to convert DCFGs to
equivalent DPDAs. This conversion works in all cases. Second, we will show
how to do the reverse conversion, from DPDAs to equivalent DCFGs. The latter
conversion works only for endmarked languages. We restrict the equivalence
to endmarked languages, because the models are not equivalent without this re-
striction. We showed earlier that endmarkers don’t affect the class of languages
that DPDAs recognize, but they do affect the class of languages that DCFGs gen-
erate. Without endmarkers, DCFGs generate only a subclass of the DCFLs—those
that are preﬁx-free (see Problem 2.52). Note that every endmarked language is
preﬁx-free.
THEOREM
2.57
An endmarked language is generated by a deterministic context-free grammar if
and only if it is deterministic context free.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.4
DETERMINISTIC CONTEXT-FREE LANGUAGES
147
We have two directions to prove. First we will show that every DCFG has an
equivalent DPDA. Then we will show that every DPDA that recognizes an end-
marked language has an equivalent DCFG. We handle these two directions in
separate lemmas.
LEMMA
2.58
Every DCFG has an equivalent DPDA.
PROOF IDEA
We show how to convert a DCFG G to an equivalent DPDA P.
P uses the DFA DK to operate as follows. It simulates DK on the symbols it reads
from the input until DK accepts. As shown in the proof of Theorem 2.52, DK’s
accept state indicates a speciﬁc dotted rule because G is deterministic, and that
rule identiﬁes a handle for some valid string extending the input it has seen so far.
Moreover, this handle applies to every valid extension because G is deterministic,
and in particular it will apply to the full input to P, if that input is in L(G). So
P can use this handle to identify the ﬁrst reduce step for its input string, even
though it has read only a part of its input at this point.
How does P identify the second and subsequent reduce steps? One idea is to
perform the reduce step directly on the input string, and then run the modiﬁed
input through DK as we did above. But the input can be neither modiﬁed nor
reread so this idea doesn’t work. Another approach would be to copy the input
to the stack and carry out the reduce step there, but then P would need to pop
the entire stack to run the modiﬁed input through DK and so the modiﬁed input
would not remain available for later steps.
The trick here is to store the states of DK on the stack, instead of storing the
input string there. Every time P reads an input symbol and simulates a move in
DK, it records DK’s state by pushing it on the stack. When it performs a reduce
step using reducing rule T →u, it pops |u| states off the stack, revealing the
state DK was in prior to reading u. It resets DK to that state, then simulates
it on input T and pushes the resulting state on the stack. Then P proceeds by
reading and processing input symbols as before.
When P pushes the start variable on the stack, it has found a reduction of its
input to the start variable, so it enters an accept state.
Next we prove the other direction of Theorem 2.57.
LEMMA
2.59
Every DPDA that recognizes an endmarked language has an equivalent DCFG.
PROOF IDEA
This proof is a modiﬁcation of the construction in Lemma 2.27
on page 121 that describes the conversion of a PDA P to an equivalent CFG G.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

148
CHAPTER 2 / CONTEXT-FREE LANGUAGES
Here P and G are deterministic. In the proof idea for Lemma 2.27, we altered
P to empty its stack and enter a speciﬁc accept state qaccept when it accepts. A
PDA cannot directly determine that it is at the end of its input, so P uses its
nondeterminism to guess that it is in that situation. We don’t want to introduce
nondeterminism in constructing DPDA P. Instead we use the assumption that
L(P) is endmarked. We modify P to empty its stack and enter qaccept when it
enters one of its original accept states after it has read the endmarker ⊣⊣⊣.
Next we apply the grammar construction to obtain G. Simply applying the
original construction to a DPDA produces a nearly deterministic grammar be-
cause the CFG’s derivations closely correspond to the DPDA’s computations. That
grammar fails to be deterministic in one minor, ﬁxable way.
The original construction introduces rules of the form Apq →AprArq and
these may cause ambiguity. These rules cover the case where Apq generates a
string that takes P from state p to state q with its stack empty at both ends,
and the stack empties midway. The substitution corresponds to dividing the
computation at that point. But if the stack empties several times, several divisions
are possible. Each of these divisions yields different parse trees, so the resulting
grammar is ambiguous. We ﬁx this problem by modifying the grammar to divide
the computation only at the very last point where the stack empties midway,
thereby removing this ambiguity. For illustration, a similar but simpler situation
occurs in the ambiguous grammar
S →T⊣⊣⊣
T →T T | (T ) | ε
which is equivalent to the unambiguous, and deterministic, grammar
S →T⊣⊣⊣
T →T (T ) | ε.
Next we show the modiﬁed grammar is deterministic by using the DK-test.
The grammar is designed to simulate the DPDA. As we proved in Lemma 2.27,
Apq generates exactly those strings on which P goes from state p on empty stack
to state q on empty stack. We’ll prove G’s determinism using P’s determinism
so we will ﬁnd it useful to deﬁne P’s computation on valid strings to observe
its action on handles. Then we can use P’s deterministic behavior to show that
handles are forced.
PROOF
Say that P = (Q, Σ, Γ, δ, q0, {qaccept}) and construct G. The start
variable is Aq0,qaccept. The construction on page 121 contains parts 1, 2, and 3,
repeated here for convenience.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.4
DETERMINISTIC CONTEXT-FREE LANGUAGES
149
1. For each p, q, r, s ∈Q, u ∈Γ, and a, b ∈Σε, if δ(p, a, ε) contains (r, u)
and δ(s, b, u) contains (q, ε), put the rule Apq →aArsb in G.
2. For each p, q, r ∈Q, put the rule Apq →AprArq in G.
3. For each p ∈Q, put the rule App →ε in G.
We modify the construction to avoid introducing ambiguity, by combining
rules of types 1 and 2 into a single type 1-2 rule that achieves the same effect.
1-2. For each p, q, r, s, t ∈Q, u ∈Γ, and a, b ∈Σε, if δ(r, a, ε) = (s, u) and
δ(t, b, u) = (q, ε), put the rule Apq →ApraAstb in G.
To see that the modiﬁed grammar generates the same language, consider any
derivation in the original grammar. For each substitution due to a type 2 rule
Apq →AprArq, we can assume that r is P’s state when it is at the rightmost point
where the stack becomes empty midway by modifying the proof of Claim 2.31
on page 123 to select r in this way. Then the subsequent substitution of Arq
must expand it using a type 1 rule Arq →aAstb. We can combine these two
substitutions into a single type 1-2 rule Apq →ApraAstb.
Conversely, in a derivation using the modiﬁed grammar, if we replace each
type 1-2 rule Apq →ApraAstb by the type 2 rule Apq →AprArq followed by
the type 1 rule Arq →aAstb, we get the same result.
Now we use the DK-test to show that G is deterministic. To do that, we’ll
analyze how P operates on valid strings by extending its input alphabet and tran-
sition function to process variable symbols in addition to terminal symbols. We
add all symbols Apq to P’s input alphabet and we extend its transition function δ
by deﬁning δ(p, Apq, ε) = (q, ε). Set all other transitions involving Apq to ∅. To
preserve P’s deterministic behavior, if P reads Apq from the input then disallow
an ε-input move.
The following claim applies to a derivation of any string w in L(G) such as
Aq0,qaccept = v0 ⇒v1 ⇒· · · ⇒vi ⇒· · · ⇒vk = w.
CLAIM
2.60
If P reads vi containing a variable Apq, it enters state p just prior to reading Apq.
The proof uses induction on i, the number of steps to derive vi from Aq0,qaccept.
Basis: i = 0.
In this case, vi = Aq0,qaccept and P starts in state q0 so the basis is true.
Induction step: Assume the claim for i and prove it for i + 1.
First consider the case where vi = xApqy and Apq is the variable substituted
in the step vi ⇒vi+1. The induction hypothesis implies that P enters state p
after it reads x, prior to reading symbol Apq. According to G’s construction the
substitution rules may be of two types:
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

150
CHAPTER 2 / CONTEXT-FREE LANGUAGES
1. Apq →ApraAstb or
2. App →ε.
Thus either vi+1 = xApraAstb y or vi+1 = x y, depending on which type of
rule was used. In the ﬁrst case, when P reads ApraAstb in vi+1, we know it
starts in state p, because it has just ﬁnished reading x. As P reads ApraAstb in
vi+1, it enters the sequence of states r, s, t, and q, due to the substitution rule’s
construction. Therefore, it enters state p just prior to reading Apr and it enters
state s just prior to reading Ast, thereby establishing the claim for these two
occurrences of variables. The claim holds on occurrences of variables in the y
part because, after P reads b it enters state q and then it reads string y. On input
vi, it also enters q just before reading y, so the computations agree on the y parts
of vi and vi+1. Obviously, the computations agree on the x parts. Therefore,
the claim holds for vi+1. In the second case, no new variables are introduced, so
we only need to observe that the computations agree on the x and y parts of vi
and vi+1. This proves the claim.
CLAIM
2.61
G passes the DK-test.
We show that each of DK’s accept states satisﬁes the DK-test requirements.
Select one of these accept states. It contains a completed rule R. This com-
pleted rule may have one of two forms:
1. Apq →ApraAstb.
2. App →.
In both situations, we need to show that the accept state cannot contain
a. another completed rule, and
b. a dotted rule that has a terminal symbol immediately after the dot.
We consider each of these four cases separately. In each case, we start by
considering a string z on which DK goes to the accept state we selected above.
Case 1a. Here R is a completed type 1-2 rule. For any rule in this accept state,
z must end with the symbols preceding the dot in that rule because DK goes to
that state on z. Hence the symbols preceding the dot must be consistent in all
such rules. These symbols are ApraAstb in R so any other type 1-2 completed
rule must have exactly the same symbols on the right-hand side. It follows that
the variables on the left-hand side must also agree, so the rules must be the same.
Suppose the accept state contains R and some type 3 completed ε-rule T .
From R we know that z ends with ApraAstb. Moreover, we know that P pops
its stack at the very end of z because a pop occurs at that point in R, due to
G’s construction. According to the way we build DK, a completed ε-rule in a
state must derive from a dotted rule that resides in the same state, where the dot
isn’t at the very beginning and the dot immediately precedes some variable. (An
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.4
DETERMINISTIC CONTEXT-FREE LANGUAGES
151
exception occurs at DK’s start state, where this dot may occur at the beginning
of the rule, but this accept state cannot be the start state because it contains a
completed type 1-2 rule.) In G, that means T derives from a type 1-2 dotted
rule where the dot precedes the second variable. From G’s construction a push
occurs just before the dot. This implies that P does a push move at the very end
of z, contradicting our previous statement. Thus the completed ε-rule T cannot
exist. Either way, a second completed rule of either type cannot occur in this
accept state.
Case 2a. Here R is a completed ε-rule App →.. We show that no other com-
pleted ε-rule Aqq →. can coexist with R. If it does, the preceding claim shows
that P must be in p after reading z and it must also be in q after reading z. Hence
p = q and therefore the two completed ε-rules are the same.
Case 1b. Here R is a completed type 1-2 rule. From Case 1a, we know that
P pops its stack at the end of z. Suppose the accept state also contains a dotted
rule T where a terminal symbol immediately follows the dot. From T we know
that P doesn’t pop its stack at the end of z. This contradiction shows that this
situation cannot arise.
Case 2b. Here R is a completed ε-rule.
Assume that the accept state also
contains a dotted rule T where a terminal symbol immediately follows the dot.
Because T is of type 1-2, a variable symbol immediately precedes the dot, and
thus z ends with that variable symbol. Moreover, after P reads z it is prepared
to read a non-ε input symbol because a terminal follows the dot. As in Case 1a,
the completed ε-rule R derives from a type 1-2 dotted rule S where the dot
immediately precedes the second variable. (Again this accept state cannot be
DK’s start state because the dot doesn’t occur at the beginning of T .) Thus some
symbol ˆa ∈Σε immediately precedes the dot in S and so z ends with ˆa. Either
ˆa ∈Σ or ˆa = ε, but because z ends with a variable symbol, ˆa ̸∈Σ so ˆa = ε.
Therefore, after P reads z but before it makes the ε-input move to process ˆa, it
is prepared to read an ε input. We also showed above that P is prepared to read
a non-ε input symbol at this point. But a DPDA isn’t allowed to make both an
ε-input move and a move that reads a non-ε input symbol at a given state and
stack, so the above situation is impossible. Thus this situation cannot occur.
PARSING AND LR(K) GRAMMARS
Deterministic context-free languages are of major practical importance. Their
algorithms for membership and parsing are based on DPDAs and are therefore ef-
ﬁcient, and they encompass a rich class of CFLs that include most programming
languages. However, DCFGs are sometimes inconvenient for expressing partic-
ular DCFLs. The requirement that all handles are forced is often an obstacle to
designing intuitive DCFGs.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

152
CHAPTER 2 / CONTEXT-FREE LANGUAGES
Fortunately, a broader class of grammars called the LR(k) grammars gives us
the best of both worlds. They are close enough to DCFGs to allow direct conver-
sion into DPDAs. Yet they are expressive enough for many applications.
Algorithms for LR(k) grammars introduce lookahead. In a DCFG, all handles
are forced. A handle depends only on the symbols in a valid string up through
and including the handle, but not on terminal symbols that follow the handle. In
an LR(k) grammar, a handle may also depend on symbols that follow the handle,
but only on the ﬁrst k of these. The acronym LR(k) stands for: Left to right input
processing, Rightmost derivations (or equivalently, leftmost reductions), and k
symbols of lookahead.
To make this precise, let h be a handle of a valid string v = xhy. Say that h is
forced by lookahead k if h is the unique handle of every valid string xhˆy where
ˆy ∈Σ∗and where y and ˆy agree on their ﬁrst k symbols. (If either string is
shorter than k, the strings must agree up to the length of the shorter one.)
DEFINITION
2.62
An LR
LR
LR(k) grammar is a context-free grammar such that the handle
of every valid string is forced by lookahead k.
Thus a DCFG is the same as an LR(0) grammar. We can show that for every k
we can convert LR(k) grammars to DPDAs. We’ve already shown that DPDAs are
equivalent to LR(0) grammars. Hence LR(k) grammars are equivalent in power for
all k and all describe exactly the DCFLs. The following example shows that LR(1)
grammars are more convenient than DCFGs for specifying certain languages.
To avoid cumbersome notation and technical details, we will show how to
convert LR(k) grammars to DPDAs only for the special case where k = 1. The
conversion in the general case works in essentially the same way.
To begin, we’ll present a variant of the DK-test, modiﬁed for LR(1) grammars.
We call it the DK-test with lookahead 1, or simply the DK1-test. As before,
we’ll construct an NFA, called K1 here, and convert it to a DFA DK1. Each of
K1’s states has a dotted rule T →u.v and now also a terminal symbol a, called
the lookahead symbol, shown as


 
T →u.v
a . This state indicates that K1 has
recently read the string u, which would be a part of a handle uv provided that v
follows after u and a follows after v.
The formal construction works much as before. The start state has an ε-move
to


 
S1 →.u
a for every rule involving the start variable S1 and every a ∈Σ.
The shift transitions take


 
T →u.xv
a to


 
T →ux.v
a on input x where x is
a variable symbol or terminal symbol. The ε-transitions take


 
T →u.Cv
a to


 
C →.r
b for each rule C →r, where b is the ﬁrst symbol of any string of
terminals that can be derived from v. If v derives ε, add b = a. The accept states
are all


 


 
B →u.
a for completed rules B →u. and a ∈Σ.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

2.4
DETERMINISTIC CONTEXT-FREE LANGUAGES
153
Let R1 be a completed rule with lookahead symbol a1, and let R2 be a dotted
rule with lookahead symbol a2. Say that R1 and R2 are consistent if
1. R2 is completed and a1 = a2, or
2. R2 is not completed and a1 immediately follows its dot.
Now we are ready to describe the DK1-test. Construct the DFA DK1. The test
stipulates that every accept state must not contain any two consistent dotted
rules.
THEOREM
2.63
G passes the DK1-test iff G is an LR(1) grammar.
PROOF IDEA
Corollary 2.51 still applies to DK1 because we can ignore the
lookahead symbols.
EXAMPLE
2.64
This example shows that the following grammar passes the DK1-test. Recall
that in Example 2.53 this grammar was shown to fail the DK-test. Hence it is an
example of a grammar that is LR(1) but not a DCFG.
S →E⊣⊣⊣
E →E + T | T
T →T x a | a
E
S    •E⊣
E   •E+T
E   •T
T    •T ×a
T    •a
a+×⊣
+⊣
+⊣
×+⊣
×+⊣
S   E•⊣
E  E •+T
a +×⊣
+⊣
E   E+•T
T   •T×a
T   • a
+⊣
×+⊣
×+⊣
T   a •
×+⊣
S   E⊣•
a +×⊣
E   E+T •
T    T •×a
+⊣
×+⊣
E   T •
T    T •×a
+⊣
×+⊣
⊣
T   T ×• a
×+⊣
T
T   T ×a •
×+⊣
+
a
×
×
a
T
a
FIGURE
2.65
Passing the DK1-test
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

154
CHAPTER 2 / CONTEXT-FREE LANGUAGES
THEOREM
2.66
An endmarked language is generated by an LR(1) grammar iff it is a DCFL.
We’ve already shown that every DCFL has an LR(0) grammar, because an LR(0)
grammar is the same as a DCFG. That proves the reverse direction of the the-
orem. What remains is the following lemma, which shows how to convert an
LR(1) grammar to a DPDA.
LEMMA
2.67
Every LR(1) grammar has an equivalent DPDA.
PROOF IDEA
We construct P1, a modiﬁed version of the DPDA P that we
presented in Lemma 2.67. P1 reads its input and simulates DK1, while using the
stack to keep track of the state DK1 would be in if all reduce steps were applied
to this input up to this point. Moreover, P1 reads 1 symbol ahead and stores this
lookahead information in its ﬁnite state memory. Whenever DK1 reaches an
accept state, P1 consults its lookahead to see whether to perform a reduce step,
and which step to do if several possibilities appear in this state. Only one option
can apply because the grammar is LR(1).
EXERCISES
2.1 Recall the CFG G4 that we gave in Example 2.4. For convenience, let’s rename its
variables with single letters as follows.
E →E + T | T
T →T x F | F
F →(E) | a
Give parse trees and derivations for each string.
a. a
b. a+a
c. a+a+a
d. ((a))
2.2
a. Use the languages A = {ambncn| m, n ≥0} and B = {anbncm| m, n ≥0}
together with Example 2.36 to show that the class of context-free languages
is not closed under intersection.
b. Use part (a) and DeMorgan’s law (Theorem 0.20) to show that the class of
context-free languages is not closed under complementation.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

EXERCISES
155
A2.3 Answer each part for the following context-free grammar G.
R →XRX | S
S →aT b | bT a
T →XT X | X | ε
X →a | b
a. What are the variables of G?
b. What are the terminals of G?
c. Which is the start variable of G?
d. Give three strings in L(G).
e. Give three strings not in L(G).
f. True or False: T ⇒aba.
g. True or False: T
∗⇒aba.
h. True or False: T ⇒T .
i. True or False: T
∗⇒T .
j. True or False: XXX
∗⇒aba.
k. True or False: X
∗⇒aba.
l. True or False: T
∗⇒XX.
m. True or False: T
∗⇒XXX.
n. True or False: S
∗⇒ε.
o. Give a description in English of
L(G).
2.4 Give context-free grammars that generate the following languages. In all parts, the
alphabet Σ is {0,1}.
Aa. {w| w contains at least three 1s}
b. {w| w starts and ends with the same symbol}
c. {w| the length of w is odd}
Ad. {w| the length of w is odd and its middle symbol is a 0}
e. {w| w = wR, that is, w is a palindrome}
f. The empty set
2.5 Give informal descriptions and state diagrams of pushdown automata for the lan-
guages in Exercise 2.4.
2.6 Give context-free grammars generating the following languages.
Aa. The set of strings over the alphabet {a,b} with more a’s than b’s
b. The complement of the language {anbn| n ≥0}
Ac. {w#x| wR is a substring of x for w, x ∈{0,1}∗}
d. {x1#x2# · · · #xk| k ≥1, each xi ∈{a, b}∗, and for some i and j, xi = xR
j }
A2.7 Give informal English descriptions of PDAs for the languages in Exercise 2.6.
A2.8 Show that the string
the girl touches the boy with the flower
has two
different leftmost derivations in grammar G2 on page 103. Describe in English the
two different meanings of this sentence.
2.9 Give a context-free grammar that generates the language
A = {aibjck| i = j or j = k where i, j, k ≥0}.
Is your grammar ambiguous? Why or why not?
2.10 Give an informal description of a pushdown automaton that recognizes the lan-
guage A in Exercise 2.9.
2.11 Convert the CFG G4 given in Exercise 2.1 to an equivalent PDA, using the proce-
dure given in Theorem 2.20.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

156
CHAPTER 2 / CONTEXT-FREE LANGUAGES
2.12 Convert the CFG G given in Exercise 2.3 to an equivalent PDA, using the procedure
given in Theorem 2.20.
2.13 Let G = (V, Σ, R, S) be the following grammar. V = {S, T, U}; Σ = {0, #}; and
R is the set of rules:
S →T T | U
T →0T | T 0 | #
U →0U00 | #
a. Describe L(G) in English.
b. Prove that L(G) is not regular.
2.14 Convert the following CFG into an equivalent CFG in Chomsky normal form,
using the procedure given in Theorem 2.9.
A →BAB | B | ε
B →00 | ε
2.15 Give a counterexample to show that the following construction fails to prove that
the class of context-free languages is closed under star. Let A be a CFL that is
generated by the CFG G = (V, Σ, R, S). Add the new rule S →SS and call the
resulting grammar G′. This grammar is supposed to generate A∗.
2.16 Show that the class of context-free languages is closed under the regular operations,
union, concatenation, and star.
2.17 Use the results of Exercise 2.16 to give another proof that every regular language is
context free, by showing how to convert a regular expression directly to an equiv-
alent context-free grammar.
PROBLEMS
A2.18
a. Let C be a context-free language and R be a regular language. Prove that
the language C ∩R is context free.
b. Let A = {w|w∈{a, b, c}∗and w contains equal numbers of a’s, b’s, and c’s}.
Use part (a) to show that A is not a CFL.
⋆2.19 Let CFG G be the following grammar.
S →aSb | bY | Y a
Y →bY | aY | ε
Give a simple description of L(G) in English. Use that description to give a CFG
for L(G), the complement of L(G).
2.20 Let A/B = {w| wx ∈A for some x ∈B}. Show that if A is context free and B is
regular, then A/B is context free.
⋆2.21 Let Σ = {a,b}. Give a CFG generating the language of strings with twice as many
a’s as b’s. Prove that your grammar is correct.
⋆2.22 Let C = {x#y| x, y ∈{0,1}∗and x ̸= y}. Show that C is a context-free language.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
157
⋆2.23 Let D = {xy|x, y ∈{0,1}∗and |x| = |y| but x ̸= y}. Show that D is a context-free
language.
⋆2.24 Let E = {aibj| i ̸= j and 2i ̸= j}. Show that E is a context-free language.
2.25 For any language A, let SUFFIX(A) = {v| uv ∈A for some string u}. Show that
the class of context-free languages is closed under the SUFFIX operation.
2.26 Show that if G is a CFG in Chomsky normal form, then for any string w ∈L(G)
of length n ≥1, exactly 2n −1 steps are required for any derivation of w.
⋆2.27 Let G = (V, Σ, R, ⟨STMT⟩) be the following grammar.
⟨STMT⟩→⟨ASSIGN⟩| ⟨IF-THEN⟩| ⟨IF-THEN-ELSE⟩
⟨IF-THEN⟩→if condition then ⟨STMT⟩
⟨IF-THEN-ELSE⟩→if condition then ⟨STMT⟩else ⟨STMT⟩
⟨ASSIGN⟩→a:=1
Σ = {if, condition, then, else, a:=1}
V = {⟨STMT⟩, ⟨IF-THEN⟩, ⟨IF-THEN-ELSE⟩, ⟨ASSIGN⟩}
G is a natural-looking grammar for a fragment of a programming language, but G
is ambiguous.
a. Show that G is ambiguous.
b. Give a new unambiguous grammar for the same language.
⋆2.28 Give unambiguous CFGs for the following languages.
a. {w| in every preﬁx of w the number of a’s is at least the number of b’s}
b. {w| the number of a’s and the number of b’s in w are equal}
c. {w| the number of a’s is at least the number of b’s in w}
⋆2.29 Show that the language A in Exercise 2.9 is inherently ambiguous.
2.30 Use the pumping lemma to show that the following languages are not context free.
a. {0n1n0n1n| n ≥0}
Ab. {0n#02n#03n| n ≥0}
Ac. {w#t| w is a substring of t, where w, t ∈{a, b}∗}
d. {t1#t2# · · · #tk| k ≥2, each ti ∈{a, b}∗, and ti = tj for some i ̸= j}
2.31 Let B be the language of all palindromes over {0,1} containing equal numbers of
0s and 1s. Show that B is not context free.
2.32 Let Σ = {1, 2, 3, 4} and C = {w ∈Σ∗| in w, the number of 1s equals the number
of 2s, and the number of 3s equals the number of 4s}. Show that C is not context
free.
⋆2.33 Show that F = {aibj| i = kj for some positive integer k} is not context free.
2.34 Consider the language B = L(G), where G is the grammar given in Exercise 2.13.
The pumping lemma for context-free languages, Theorem 2.34, states the exis-
tence of a pumping length p for B. What is the minimum value of p that works in
the pumping lemma? Justify your answer.
2.35 Let G be a CFG in Chomsky normal form that contains b variables. Show that if G
generates some string with a derivation having at least 2b steps, L(G) is inﬁnite.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

158
CHAPTER 2 / CONTEXT-FREE LANGUAGES
2.36 Give an example of a language that is not context free but that acts like a CFL in the
pumping lemma. Prove that your example works. (See the analogous example for
regular languages in Problem 1.54.)
⋆2.37 Prove the following stronger form of the pumping lemma, wherein both pieces v
and y must be nonempty when the string s is broken up.
If A is a context-free language, then there is a number k where, if s is any string in
A of length at least k, then s may be divided into ﬁve pieces, s = uvxyz, satisfying
the conditions:
a. for each i ≥0, uvixyiz ∈A,
b. v ̸= ε and y ̸= ε, and
c. |vxy| ≤k.
A2.38 Refer to Problem 1.41 for the deﬁnition of the perfect shufﬂe operation. Show that
the class of context-free languages is not closed under perfect shufﬂe.
2.39 Refer to Problem 1.42 for the deﬁnition of the shufﬂe operation. Show that the
class of context-free languages is not closed under shufﬂe.
⋆2.40 Say that a language is preﬁx-closed if all preﬁxes of every string in the language
are also in the language. Let C be an inﬁnite, preﬁx-closed, context-free language.
Show that C contains an inﬁnite regular subset.
⋆2.41 Read the deﬁnitions of NOPREFIX(A) and NOEXTEND(A) in Problem 1.40.
a. Show that the class of CFLs is not closed under NOPREFIX.
b. Show that the class of CFLs is not closed under NOEXTEND.
⋆2.42 Let Y = {w| w = t1#t2# · · · #tk for k ≥0, each ti ∈1∗, and ti ̸= tj whenever i̸= j}.
Here Σ = {1, #}. Prove that Y is not context free.
2.43 For strings w and t, write w ⊜t if the symbols of w are a permutation of the
symbols of t. In other words, w ⊜t if t and w have the same symbols in the same
quantities, but possibly in a different order.
For any string w, deﬁne SCRAMBLE(w) = {t| t ⊜w}. For any language A, let
SCRAMBLE(A) = {t| t ∈SCRAMBLE(w) for some w ∈A}.
a. Show that if Σ = {0,1}, then the SCRAMBLE of a regular language is con-
text free.
b. What happens in part (a) if Σ contains three or more symbols? Prove your
answer.
2.44 If A and B are languages, deﬁne A ⋄B = {xy| x ∈A and y ∈B and |x| = |y|}.
Show that if A and B are regular languages, then A ⋄B is a CFL.
⋆2.45 Let A = {wtwR| w, t ∈{0,1}∗and |w| = |t|}. Prove that A is not a CFL.
2.46 Consider the following CFG G:
S →SS | T
T →aT b | ab
Describe L(G) and show that G is ambiguous. Give an unambiguous grammar H
where L(H) = L(G) and sketch a proof that H is unambiguous.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
159
2.47 Let Σ = {0,1} and let B be the collection of strings that contain at least one 1 in
their second half. In other words, B = {uv| u ∈Σ∗, v ∈Σ∗1Σ∗and |u| ≥|v|}.
a. Give a PDA that recognizes B.
b. Give a CFG that generates B.
2.48 Let Σ = {0,1}. Let C1 be the language of all strings that contain a 1 in their
middle third. Let C2 be the language of all strings that contain two 1s in their
middle third. So C1 = {xyz| x, z ∈Σ∗and y ∈Σ∗1Σ∗, where |x| = |z| ≥|y|}
and C2 = {xyz| x, z ∈Σ∗and y ∈Σ∗1Σ∗1Σ∗, where |x| = |z| ≥|y|}.
a. Show that C1 is a CFL.
b. Show that C2 is not a CFL.
⋆2.49 We deﬁned the rotational closure of language A to be RC(A) = {yx| xy ∈A}.
Show that the class of CFLs is closed under rotational closure.
⋆2.50 We deﬁned the CUT of language A to be CUT(A) = {yxz| xyz ∈A}. Show that
the class of CFLs is not closed under CUT.
2.51 Show that every DCFG is an unambiguous CFG.
A⋆2.52 Show that every DCFG generates a preﬁx-free language.
⋆2.53 Show that the class of DCFLs is not closed under the following operations:
a. Union
b. Intersection
c. Concatenation
d. Star
e. Reversal
2.54 Let G be the following grammar:
S →T⊣⊣⊣
T →T aT b | T bT a | ε
a. Show that L(G) = {w⊣⊣⊣| w contains equal numbers of a’s and b’s}. Use a
proof by induction on the length of w.
b. Use the DK-test to show that G is a DCFG.
c. Describe a DPDA that recognizes L(G).
2.55 Let G1 be the following grammar that we introduced in Example 2.45. Use the
DK-test to show that G1 is not a DCFG.
R →S | T
S →aSb | ab
T →aT bb | abb
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

160
CHAPTER 2 / CONTEXT-FREE LANGUAGES
⋆2.56 Let A = L(G1) where G1 is deﬁned in Problem 2.55. Show that A is not a DCFL.
(Hint: Assume that A is a DCFL and consider its DPDA P. Modify P so that its
input alphabet is {a, b, c}. When it ﬁrst enters an accept state, it pretends that
c’s are b’s in the input from that point on. What language would the modiﬁed P
accept?)
⋆2.57 Let B = {aibjck| i, j, k ≥0 and i = j or i = k}. Prove that B is not a DCFL.
⋆2.58 Let C = {wwR| w ∈{0,1}∗}. Prove that C is not a DCFL. (Hint: Suppose that
when some DPDA P is started in state q with symbol x on the top of its stack, P
never pops its stack below x, no matter what input string P reads from that point
on. In that case, the contents of P’s stack at that point cannot affect its subsequent
behavior, so P’s subsequent behavior can depend only on q and x.)
⋆2.59 If we disallow ε-rules in CFGs, we can simplify the DK-test. In the simpliﬁed test,
we only need to check that each of DK’s accept states has a single rule. Prove that
a CFG without ε-rules passes the simpliﬁed DK-test iff it is a DCFG.
SELECTED SOLUTIONS
2.3
(a) R, X, S, T;
(b) a, b;
(c) R;
(d) Three strings in L(G) are ab, ba, and aab;
(e) Three strings not in L(G) are a, b, and ε;
(f) False;
(g) True;
(h) False;
(i) True; (j) True; (k) False; (l) True; (m) True; (n) False; (o) L(G) consists
of all strings over a and b that are not palindromes.
2.4
(a) S →R1R1R1R
R →0R | 1R | ε
(d) S →0 | 0S0 | 0S1 | 1S0 | 1S1
2.6
(a) S →T aT
T →TT | aT b | bT a | a | ε
T generates all strings with at least as
many a’s as b’s, and S forces an extra a.
(c) S →T X
T →0T 0 | 1T 1 | #X
X →0X | 1X | ε
2.7
(a) The PDA uses its stack to count the number of a’s minus the number of b’s. It
enters an accepting state whenever this count is positive. In more detail, it operates
as follows. The PDA scans across the input. If it sees a b and its top stack symbol
is an a, it pops the stack. Similarly, if it scans an a and its top stack symbol is a
b, it pops the stack. In all other cases, it pushes the input symbol onto the stack.
After the PDA ﬁnishes the input, if a is on top of the stack, it accepts. Otherwise it
rejects.
(c) The PDA scans across the input string and pushes every symbol it reads until
it reads a #. If a # is never encountered, it rejects. Then, the PDA skips over part
of the input, nondeterministically deciding when to stop skipping. At that point,
it compares the next input symbols with the symbols it pops off the stack. At any
disagreement, or if the input ﬁnishes while the stack is nonempty, this branch of
the computation rejects. If the stack becomes empty, the machine reads the rest of
the input and accepts.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

SELECTED SOLUTIONS
161
2.8
Here is one derivation:
⟨SENTENCE⟩→⟨NOUN-PHRASE⟩⟨VERB-PHRASE⟩→
⟨CMPLX-NOUN⟩⟨VERB-PHRASE⟩→
⟨ARTICLE⟩⟨NOUN⟩⟨VERB-PHRASE⟩→
The ⟨NOUN⟩⟨VERB-PHRASE⟩→
The girl ⟨VERB-PHRASE⟩→
The girl ⟨CMPLX-VERB⟩⟨PREP-PHRASE⟩→
The girl ⟨VERB⟩⟨NOUN-PHRASE⟩⟨PREP-PHRASE⟩→
The girl touches ⟨NOUN-PHRASE⟩⟨PREP-PHRASE⟩→
The girl touches ⟨CMPLX-NOUN⟩⟨PREP-PHRASE⟩→
The girl touches ⟨ARTICLE⟩⟨NOUN⟩⟨PREP-PHRASE⟩→
The girl touches the ⟨NOUN⟩⟨PREP-PHRASE⟩→
The girl touches the boy ⟨PREP-PHRASE⟩→
The girl touches the boy ⟨PREP⟩⟨CMPLX-NOUN⟩→
The girl touches the boy with ⟨CMPLX-NOUN⟩→
The girl touches the boy with ⟨ARTICLE⟩⟨NOUN⟩→
The girl touches the boy with the ⟨NOUN⟩→
The girl touches the boy with the flower
Here is another leftmost derivation:
⟨SENTENCE⟩→⟨NOUN-PHRASE⟩⟨VERB-PHRASE⟩→
⟨CMPLX-NOUN⟩⟨VERB-PHRASE⟩→
⟨ARTICLE⟩⟨NOUN⟩⟨VERB-PHRASE⟩→
The ⟨NOUN⟩⟨VERB-PHRASE⟩→
The girl ⟨VERB-PHRASE⟩→
The girl ⟨CMPLX-VERB⟩→
The girl ⟨VERB⟩⟨NOUN-PHRASE⟩→
The girl touches ⟨NOUN-PHRASE⟩→
The girl touches ⟨CMPLX-NOUN⟩⟨PREP-PHRASE⟩→
The girl touches ⟨ARTICLE⟩⟨NOUN⟩⟨PREP-PHRASE⟩→
The girl touches the ⟨NOUN⟩⟨PREP-PHRASE⟩→
The girl touches the boy ⟨PREP-PHRASE⟩→
The girl touches the boy ⟨PREP⟩⟨CMPLX-NOUN⟩→
The girl touches the boy with ⟨CMPLX-NOUN⟩→
The girl touches the boy with ⟨ARTICLE⟩⟨NOUN⟩→
The girl touches the boy with the ⟨NOUN⟩→
The girl touches the boy with the flower
Each of these derivations corresponds to a different English meaning. In the ﬁrst
derivation, the sentence means that the girl used the ﬂower to touch the boy. In
the second derivation, the boy is holding the ﬂower when the girl touches her.
2.18
(a) Let C be a context-free language and R be a regular language. Let P be the
PDA that recognizes C, and D be the DFA that recognizes R. If Q is the set of
states of P and Q′ is the set of states of D, we construct a PDA P ′ that recognizes
C ∩R with the set of states Q × Q′. P ′ will do what P does and also keep track of
the states of D. It accepts a string w if and only if it stops at a state q ∈FP × FD,
where FP is the set of accept states of P and FD is the set of accept states of D.
Since C ∩R is recognized by P ′, it is context free.
(b) Let R be the regular language a∗b∗c∗. If A were a CFL then A ∩R would be
a CFL by part (a). However, A ∩R = {anbncn| n ≥0}, and Example 2.36 proves
that A ∩R is not context free. Thus A is not a CFL.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

162
CHAPTER 2 / CONTEXT-FREE LANGUAGES
2.30
(b) Let B = {0n#02n#03n| n ≥0}. Let p be the pumping length given by the
pumping lemma. Let s = 0p#02p#03p. We show that s = uvxyz cannot be
pumped.
Neither v nor y can contain #, otherwise uv2xy2z contains more than two #s.
Therefore, if we divide s into three segments by #’s: 0p, 02p, and 03p, at least one
of the segments is not contained within either v or y. Hence uv2xy2z is not in B
because the 1 : 2 : 3 length ratio of the segments is not maintained.
(c) Let C = {w#t| w is a substring of t, where w, t ∈{a, b}∗}. Let p be the
pumping length given by the pumping lemma. Let s = apbp#apbp. We show that
the string s = uvxyz cannot be pumped.
Neither v nor y can contain #, otherwise uv0xy0z does not contain # and therefore
is not in C. If both v and y occur on the left-hand side of the #, the string uv2xy2z
cannot be in C because it is longer on the left-hand side of the #. Similarly, if both
strings occur on the right-hand side of the #, the string uv0xy0z cannot be in C
because it is again longer on the left-hand side of the #. If one of v and y is empty
(both cannot be empty), treat them as if both occurred on the same side of the # as
above.
The only remaining case is where both v and y are nonempty and straddle the #.
But then v consists of b’s and y consists of a’s because of the third pumping lemma
condition |vxy| ≤p. Hence, uv2xy2z contains more b’s on the left-hand side of
the #, so it cannot be a member of C.
2.38
Let A be the language {0k1k| k ≥0} and let B be the language {akb3k| k ≥0}.
The perfect shufﬂe of A and B is the language C = {(0a)k(0b)k(1b)2k| k ≥0}.
Languages A and B are easily seen to be CFLs, but C is not a CFL, as follows.
If C were a CFL, let p be the pumping length given by the pumping lemma, and
let s be the string (0a)p(0b)p(1b)2p. Because s is longer than p and s ∈C, we
can divide s = uvxyz satisfying the pumping lemma’s three conditions. Strings
in C are exactly one-fourth 1s and one-eighth a’s. In order for uv2xy2z to have
that property, the string vxy must contain both 1s and a’s. But that is impossible,
because the 1s and a’s are separated by 2p symbols in s yet the third condition says
that |vxy| ≤p. Hence C is not context free.
2.52
We use a proof by contradiction. Assume that w and wz are two unequal strings in
L(G), where G is a DCFG. Both are valid strings so both have handles, and these
handles must agree because we can write w = xhy and wz = xhyz = xhˆy where h
is the handle of w. Hence, the ﬁrst reduce steps of w and wz produce valid strings
u and uz, respectively. We can continue this process until we obtain S1 and S1z
where S1 is the start variable. However, S1 does not appear on the right-hand side
of any rule so we cannot reduce S1z. That gives a contradiction.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PART TWO
C O M P U T A B I L I T Y
T H E O R Y
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

3
T H E C H U R C H ----T U R I N G
T H E S I S
So far in our development of the theory of computation, we have presented sev-
eral models of computing devices. Finite automata are good models for devices
that have a small amount of memory. Pushdown automata are good models for
devices that have an unlimited memory that is usable only in the last in, ﬁrst out
manner of a stack. We have shown that some very simple tasks are beyond the
capabilities of these models. Hence they are too restricted to serve as models of
general purpose computers.
3.1
TURING MACHINES
We turn now to a much more powerful model, ﬁrst proposed by Alan Turing
in 1936, called the Turing machine. Similar to a ﬁnite automaton but with an
unlimited and unrestricted memory, a Turing machine is a much more accurate
model of a general purpose computer. A Turing machine can do everything
that a real computer can do. Nonetheless, even a Turing machine cannot solve
certain problems. In a very real sense, these problems are beyond the theoretical
limits of computation.
The Turing machine model uses an inﬁnite tape as its unlimited memory. It
has a tape head that can read and write symbols and move around on the tape.
165
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

166
CHAPTER 3 / THE CHURCH---TURING THESIS
Initially the tape contains only the input string and is blank everywhere else. If
the machine needs to store information, it may write this information on the
tape. To read the information that it has written, the machine can move its
head back over it. The machine continues computing until it decides to produce
an output. The outputs accept and reject are obtained by entering designated
accepting and rejecting states. If it doesn’t enter an accepting or a rejecting state,
it will go on forever, never halting.
FIGURE
3.1
Schematic of a Turing machine
The following list summarizes the differences between ﬁnite automata and
Turing machines.
1. A Turing machine can both write on the tape and read from it.
2. The read–write head can move both to the left and to the right.
3. The tape is inﬁnite.
4. The special states for rejecting and accepting take effect immediately.
Let’s introduce a Turing machine M1 for testing membership in the language
B = {w#w| w ∈{0,1}∗}. We want M1 to accept if its input is a member of B
and to reject otherwise. To understand M1 better, put yourself in its place by
imagining that you are standing on a mile-long input consisting of millions of
characters. Your goal is to determine whether the input is a member of B—that
is, whether the input comprises two identical strings separated by a # symbol.
The input is too long for you to remember it all, but you are allowed to move
back and forth over the input and make marks on it. The obvious strategy is
to zig-zag to the corresponding places on the two sides of the # and determine
whether they match. Place marks on the tape to keep track of which places
correspond.
We design M1 to work in that way. It makes multiple passes over the input
string with the read–write head. On each pass it matches one of the characters
on each side of the # symbol. To keep track of which symbols have been checked
already, M1 crosses off each symbol as it is examined. If it crosses off all the
symbols, that means that everything matched successfully, and M1 goes into an
accept state. If it discovers a mismatch, it enters a reject state. In summary, M1’s
algorithm is as follows.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

3.1
TURING MACHINES
167
M1 = “On input string w:
1.
Zig-zag across the tape to corresponding positions on either
side of the # symbol to check whether these positions contain
the same symbol. If they do not, or if no # is found, reject.
Cross off symbols as they are checked to keep track of which
symbols correspond.
2.
When all symbols to the left of the # have been crossed off,
check for any remaining symbols to the right of the #. If any
symbols remain, reject; otherwise, accept.”
The following ﬁgure contains several nonconsecutive snapshots of M1’s tape
after it is started on input 011000#011000.
FIGURE
3.2
Snapshots of Turing machine M1 computing on input 011000#011000
This description of Turing machine M1 sketches the way it functions but does
not give all its details. We can describe Turing machines in complete detail by
giving formal descriptions analogous to those introduced for ﬁnite and push-
down automata. The formal descriptions specify each of the parts of the formal
deﬁnition of the Turing machine model to be presented shortly. In actuality, we
almost never give formal descriptions of Turing machines because they tend to
be very big.
FORMAL DEFINITION OF A TURING MACHINE
The heart of the deﬁnition of a Turing machine is the transition function δ be-
cause it tells us how the machine gets from one step to the next. For a Turing
machine, δ takes the form: Q×Γ −→Q×Γ×{L, R}. That is, when the machine
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

168
CHAPTER 3 / THE CHURCH---TURING THESIS
is in a certain state q and the head is over a tape square containing a symbol a,
and if δ(q, a) = (r, b, L), the machine writes the symbol b replacing the a, and
goes to state r. The third component is either L or R and indicates whether the
head moves to the left or right after writing. In this case, the L indicates a move
to the left.
DEFINITION
3.3
A Turing machine is a 7-tuple, (Q, Σ, Γ, δ, q0, qaccept, qreject), where
Q, Σ, Γ are all ﬁnite sets and
1. Q is the set of states,
2. Σ is the input alphabet not containing the blank symbol ␣,
3. Γ is the tape alphabet, where ␣∈Γ and Σ ⊆Γ,
4. δ: Q × Γ−→Q × Γ × {L, R} is the transition function,
5. q0 ∈Q is the start state,
6. qaccept ∈Q is the accept state, and
7. qreject ∈Q is the reject state, where qreject ̸= qaccept.
A Turing machine M = (Q, Σ, Γ, δ, q0, qaccept, qreject) computes as follows. Ini-
tially, M receives its input w = w1w2 . . . wn ∈Σ∗on the leftmost n squares of
the tape, and the rest of the tape is blank (i.e., ﬁlled with blank symbols). The
head starts on the leftmost square of the tape. Note that Σ does not contain the
blank symbol, so the ﬁrst blank appearing on the tape marks the end of the input.
Once M has started, the computation proceeds according to the rules described
by the transition function. If M ever tries to move its head to the left off the
left-hand end of the tape, the head stays in the same place for that move, even
though the transition function indicates L. The computation continues until it
enters either the accept or reject states, at which point it halts. If neither occurs,
M goes on forever.
As a Turing machine computes, changes occur in the current state, the cur-
rent tape contents, and the current head location. A setting of these three items
is called a conﬁguration of the Turing machine. Conﬁgurations often are rep-
resented in a special way. For a state q and two strings u and v over the tape
alphabet Γ, we write u q v for the conﬁguration where the current state is q, the
current tape contents is uv, and the current head location is the ﬁrst symbol
of v. The tape contains only blanks following the last symbol of v. For example,
1011q701111 represents the conﬁguration when the tape is 101101111, the cur-
rent state is q7, and the head is currently on the second 0. Figure 3.4 depicts a
Turing machine with that conﬁguration.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

3.1
TURING MACHINES
169
FIGURE
3.4
A Turing machine with conﬁguration 1011q701111
Here we formalize our intuitive understanding of the way that a Turing ma-
chine computes. Say that conﬁguration C1 yields conﬁguration C2 if the Turing
machine can legally go from C1 to C2 in a single step. We deﬁne this notion
formally as follows.
Suppose that we have a, b, and c in Γ, as well as u and v in Γ∗and states qi
and qj. In that case, ua qi bv and u qj acv are two conﬁgurations. Say that
ua qi bv
yields
u qj acv
if in the transition function δ(qi, b) = (qj, c, L). That handles the case where the
Turing machine moves leftward. For a rightward move, say that
ua qi bv
yields
uac qj v
if δ(qi, b) = (qj, c, R).
Special cases occur when the head is at one of the ends of the conﬁguration.
For the left-hand end, the conﬁguration qi bv yields qj cv if the transition is left-
moving (because we prevent the machine from going off the left-hand end of the
tape), and it yields c qjv for the right-moving transition. For the right-hand end,
the conﬁguration ua qi is equivalent to ua qi ␣because we assume that blanks
follow the part of the tape represented in the conﬁguration. Thus we can handle
this case as before, with the head no longer at the right-hand end.
The start conﬁguration of M on input w is the conﬁguration q0 w, which
indicates that the machine is in the start state q0 with its head at the leftmost
position on the tape. In an accepting conﬁguration, the state of the conﬁguration
is qaccept. In a rejecting conﬁguration, the state of the conﬁguration is qreject.
Accepting and rejecting conﬁgurations are halting conﬁgurations and do not
yield further conﬁgurations. Because the machine is deﬁned to halt when in the
states qaccept and qreject, we equivalently could have deﬁned the transition function
to have the more complicated form δ: Q′ × Γ−→Q × Γ × {L, R}, where Q′ is Q
without qaccept and qreject. A Turing machine M accepts input w if a sequence of
conﬁgurations C1, C2, . . . , Ck exists, where
1. C1 is the start conﬁguration of M on input w,
2. each Ci yields Ci+1, and
3. Ck is an accepting conﬁguration.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

170
CHAPTER 3 / THE CHURCH---TURING THESIS
The collection of strings that M accepts is the language of M, or the lan-
guage recognized by M, denoted L(M).
DEFINITION
3.5
Call a language Turing-recognizable if some Turing machine
recognizes it.1
When we start a Turing machine on an input, three outcomes are possible.
The machine may accept, reject, or loop. By loop we mean that the machine simply
does not halt. Looping may entail any simple or complex behavior that never
leads to a halting state.
A Turing machine M can fail to accept an input by entering the qreject state
and rejecting, or by looping. Sometimes distinguishing a machine that is looping
from one that is merely taking a long time is difﬁcult. For this reason, we prefer
Turing machines that halt on all inputs; such machines never loop. These ma-
chines are called deciders because they always make a decision to accept or reject.
A decider that recognizes some language also is said to decide that language.
DEFINITION
3.6
Call a language Turing-decidable or simply decidable if some
Turing machine decides it.2
Next, we give examples of decidable languages. Every decidable language
is Turing-recognizable.
We present examples of languages that are Turing-
recognizable but not decidable after we develop a technique for proving un-
decidability in Chapter 4.
EXAMPLES OF TURING MACHINES
As we did for ﬁnite and pushdown automata, we can formally describe a partic-
ular Turing machine by specifying each of its seven parts. However, going to
that level of detail can be cumbersome for all but the tiniest Turing machines.
Accordingly, we won’t spend much time giving such descriptions. Mostly we
1It is called a recursively enumerable language in some other textbooks.
2It is called a recursive language in some other textbooks.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

3.1
TURING MACHINES
171
will give only higher level descriptions because they are precise enough for our
purposes and are much easier to understand. Nevertheless, it is important to
remember that every higher level description is actually just shorthand for its
formal counterpart. With patience and care we could describe any of the Turing
machines in this book in complete formal detail.
To help you make the connection between the formal descriptions and the
higher level descriptions, we give state diagrams in the next two examples. You
may skip over them if you already feel comfortable with this connection.
EXAMPLE
3.7
Here we describe a Turing machine (TM) M2 that decides A = {02n| n ≥0}, the
language consisting of all strings of 0s whose length is a power of 2.
M2 = “On input string w:
1.
Sweep left to right across the tape, crossing off every other 0.
2.
If in stage 1 the tape contained a single 0, accept.
3.
If in stage 1 the tape contained more than a single 0 and the
number of 0s was odd, reject.
4.
Return the head to the left-hand end of the tape.
5.
Go to stage 1.”
Each iteration of stage 1 cuts the number of 0s in half. As the machine sweeps
across the tape in stage 1, it keeps track of whether the number of 0s seen is even
or odd. If that number is odd and greater than 1, the original number of 0s in
the input could not have been a power of 2. Therefore, the machine rejects in
this instance. However, if the number of 0s seen is 1, the original number must
have been a power of 2. So in this case, the machine accepts.
Now we give the formal description of M2 = (Q, Σ, Γ, δ, q1, qaccept, qreject):
• Q = {q1, q2, q3, q4, q5, qaccept, qreject},
• Σ = {0}, and
• Γ = {0,x,␣}.
• We describe δ with a state diagram (see Figure 3.8).
• The start, accept, and reject states are q1, qaccept, and qreject, respectively.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

172
CHAPTER 3 / THE CHURCH---TURING THESIS
FIGURE
3.8
State diagram for Turing machine M2
In this state diagram, the label 0→␣,R appears on the transition from q1 to q2.
This label signiﬁes that when in state q1 with the head reading 0, the machine
goes to state q2, writes ␣, and moves the head to the right. In other words,
δ(q1,0) = (q2,␣,R). For clarity we use the shorthand 0→R in the transition from
q3 to q4, to mean that the machine moves to the right when reading 0 in state q3
but doesn’t alter the tape, so δ(q3,0) = (q4,0,R).
This machine begins by writing a blank symbol over the leftmost 0 on the
tape so that it can ﬁnd the left-hand end of the tape in stage 4. Whereas we
would normally use a more suggestive symbol such as # for the left-hand end
delimiter, we use a blank here to keep the tape alphabet, and hence the state
diagram, small. Example 3.11 gives another method of ﬁnding the left-hand end
of the tape.
Next we give a sample run of this machine on input 0000. The starting con-
ﬁguration is q10000. The sequence of conﬁgurations the machine enters appears
as follows; read down the columns and left to right.
q10000
␣q5x0x␣
␣xq5xx␣
␣q2000
q5␣x0x␣
␣q5xxx␣
␣xq300
␣q2x0x␣
q5␣xxx␣
␣x0q40
␣xq20x␣
␣q2xxx␣
␣x0xq3␣
␣xxq3x␣
␣xq2xx␣
␣x0q5x␣
␣xxxq3␣
␣xxq2x␣
␣xq50x␣
␣xxq5x␣
␣xxxq2␣
␣xxx␣qaccept
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

3.1
TURING MACHINES
173
EXAMPLE
3.9
The following is a formal description of M1 = (Q, Σ, Γ, δ, q1, qaccept, qreject), the
Turing machine that we informally described (page 167) for deciding the lan-
guage B = {w#w| w ∈{0,1}∗}.
• Q = {q1, . . . , q8, qaccept, qreject},
• Σ = {0,1,#}, and Γ = {0,1,#,x,␣}.
• We describe δ with a state diagram (see the following ﬁgure).
• The start, accept, and reject states are q1, qaccept, and qreject, respectively.
FIGURE
3.10
State diagram for Turing machine M1
In Figure 3.10, which depicts the state diagram of TM M1, you will ﬁnd the
label 0,1→R on the transition going from q3 to itself. That label means that the
machine stays in q3 and moves to the right when it reads a 0 or a 1 in state q3. It
doesn’t change the symbol on the tape.
Stage 1 is implemented by states q1 through q7, and stage 2 by the remaining
states. To simplify the ﬁgure, we don’t show the reject state or the transitions
going to the reject state. Those transitions occur implicitly whenever a state
lacks an outgoing transition for a particular symbol. Thus because in state q5
no outgoing arrow with a # is present, if a # occurs under the head when the
machine is in state q5, it goes to state qreject. For completeness, we say that the
head moves right in each of these transitions to the reject state.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

174
CHAPTER 3 / THE CHURCH---TURING THESIS
EXAMPLE
3.11
Here, a TM M3 is doing some elementary arithmetic. It decides the language
C = {aibjck| i × j = k and i, j, k ≥1}.
M3 = “On input string w:
1.
Scan the input from left to right to determine whether it is a
member of a+b+c+ and reject if it isn’t.
2.
Return the head to the left-hand end of the tape.
3.
Cross off an a and scan to the right until a b occurs. Shuttle
between the b’s and the c’s, crossing off one of each until all b’s
are gone. If all c’s have been crossed off and some b’s remain,
reject.
4.
Restore the crossed off b’s and repeat stage 3 if there is another
a to cross off. If all a’s have been crossed off, determine whether
all c’s also have been crossed off.
If yes, accept; otherwise,
reject.”
Let’s examine the four stages of M3 more closely. In stage 1, the machine
operates like a ﬁnite automaton. No writing is necessary as the head moves from
left to right, keeping track by using its states to determine whether the input is
in the proper form.
Stage 2 looks equally simple but contains a subtlety. How can the TM ﬁnd
the left-hand end of the input tape? Finding the right-hand end of the input
is easy because it is terminated with a blank symbol. But the left-hand end has
no terminator initially. One technique that allows the machine to ﬁnd the left-
hand end of the tape is for it to mark the leftmost symbol in some way when
the machine starts with its head on that symbol. Then the machine may scan
left until it ﬁnds the mark when it wants to reset its head to the left-hand end.
Example 3.7 illustrated this technique; a blank symbol marks the left-hand end.
A trickier method of ﬁnding the left-hand end of the tape takes advantage of
the way that we deﬁned the Turing machine model. Recall that if the machine
tries to move its head beyond the left-hand end of the tape, it stays in the same
place. We can use this feature to make a left-hand end detector. To detect
whether the head is sitting on the left-hand end, the machine can write a special
symbol over the current position while recording the symbol that it replaced in
the control. Then it can attempt to move the head to the left. If it is still over
the special symbol, the leftward move didn’t succeed, and thus the head must
have been at the left-hand end. If instead it is over a different symbol, some
symbols remained to the left of that position on the tape. Before going farther,
the machine must be sure to restore the changed symbol to the original.
Stages 3 and 4 have straightforward implementations and use several states
each.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

3.1
TURING MACHINES
175
EXAMPLE
3.12
Here, a TM M4 is solving what is called the element distinctness problem. It is given
a list of strings over {0,1} separated by #s and its job is to accept if all the strings
are different. The language is
E = {#x1#x2# · · · #xl| each xi ∈{0,1}∗and xi ̸= xj for each i ̸= j}.
Machine M4 works by comparing x1 with x2 through xl, then by comparing x2
with x3 through xl, and so on. An informal description of the TM M4 deciding
this language follows.
M4 = “On input w:
1.
Place a mark on top of the leftmost tape symbol. If that symbol
was a blank, accept. If that symbol was a #, continue with the
next stage. Otherwise, reject.
2.
Scan right to the next # and place a second mark on top of it. If
no # is encountered before a blank symbol, only x1 was present,
so accept.
3.
By zig-zagging, compare the two strings to the right of the
marked #s. If they are equal, reject.
4.
Move the rightmost of the two marks to the next # symbol to
the right. If no # symbol is encountered before a blank sym-
bol, move the leftmost mark to the next # to its right and the
rightmost mark to the # after that. This time, if no # is available
for the rightmost mark, all the strings have been compared, so
accept.
5.
Go to stage 3.”
This machine illustrates the technique of marking tape symbols. In stage 2,
the machine places a mark above a symbol, # in this case. In the actual imple-
mentation, the machine has two different symbols, # and
•#, in its tape alphabet.
Saying that the machine places a mark above a # means that the machine writes
the symbol
•# at that location. Removing the mark means that the machine writes
the symbol without the dot. In general, we may want to place marks over vari-
ous symbols on the tape. To do so, we merely include versions of all these tape
symbols with dots in the tape alphabet.
We conclude from the preceding examples that the described languages A,
B, C, and E are decidable. All decidable languages are Turing-recognizable, so
these languages are also Turing-recognizable. Demonstrating a language that is
Turing-recognizable but undecidable is more difﬁcult. We do so in Chapter 4.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

176
CHAPTER 3 / THE CHURCH---TURING THESIS
3.2
VARIANTS OF TURING MACHINES
Alternative deﬁnitions of Turing machines abound, including versions with mul-
tiple tapes or with nondeterminism. They are called variants of the Turing
machine model. The original model and its reasonable variants all have the
same power—they recognize the same class of languages. In this section, we de-
scribe some of these variants and the proofs of equivalence in power. We call this
invariance to certain changes in the deﬁnition robustness. Both ﬁnite automata
and pushdown automata are somewhat robust models, but Turing machines have
an astonishing degree of robustness.
To illustrate the robustness of the Turing machine model, let’s vary the type
of transition function permitted. In our deﬁnition, the transition function forces
the head to move to the left or right after each step; the head may not simply
stay put. Suppose that we had allowed the Turing machine the ability to stay put.
The transition function would then have the form δ: Q×Γ−→Q×Γ×{L, R, S}.
Might this feature allow Turing machines to recognize additional languages, thus
adding to the power of the model? Of course not, because we can convert any
TM with the “stay put” feature to one that does not have it. We do so by replacing
each stay put transition with two transitions: one that moves to the right and the
second back to the left.
This small example contains the key to showing the equivalence of TM vari-
ants. To show that two models are equivalent, we simply need to show that one
can simulate the other.
MULTITAPE TURING MACHINES
A multitape Turing machine is like an ordinary Turing machine with several
tapes. Each tape has its own head for reading and writing. Initially the input
appears on tape 1, and the others start out blank. The transition function is
changed to allow for reading, writing, and moving the heads on some or all of
the tapes simultaneously. Formally, it is
δ: Q × Γk−→Q × Γk × {L, R, S}k,
where k is the number of tapes. The expression
δ(qi, a1, . . . , ak) = (qj, b1, . . . , bk, L, R, . . . , L)
means that if the machine is in state qi and heads 1 through k are reading symbols
a1 through ak, the machine goes to state qj, writes symbols b1 through bk, and
directs each head to move left or right, or to stay put, as speciﬁed.
Multitape Turing machines appear to be more powerful than ordinary Turing
machines, but we can show that they are equivalent in power. Recall that two
machines are equivalent if they recognize the same language.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

3.2
VARIANTS OF TURING MACHINES
177
THEOREM
3.13
Every multitape Turing machine has an equivalent single-tape Turing machine.
PROOF
We show how to convert a multitape TM M to an equivalent single-
tape TM S. The key idea is to show how to simulate M with S.
Say that M has k tapes. Then S simulates the effect of k tapes by storing
their information on its single tape. It uses the new symbol # as a delimiter to
separate the contents of the different tapes. In addition to the contents of these
tapes, S must keep track of the locations of the heads. It does so by writing a tape
symbol with a dot above it to mark the place where the head on that tape would
be. Think of these as “virtual” tapes and heads. As before, the “dotted” tape
symbols are simply new symbols that have been added to the tape alphabet. The
following ﬁgure illustrates how one tape can be used to represent three tapes.
FIGURE
3.14
Representing three tapes with one
S = “On input w = w1 · · · wn:
1.
First S puts its tape into the format that represents all k tapes
of M. The formatted tape contains
#
•w1w2 · · · wn #
•␣#
•␣# · · · #.
2.
To simulate a single move, S scans its tape from the ﬁrst #,
which marks the left-hand end, to the (k + 1)st #, which marks
the right-hand end, in order to determine the symbols under
the virtual heads. Then S makes a second pass to update the
tapes according to the way that M’s transition function dictates.
3.
If at any point S moves one of the virtual heads to the right onto
a #, this action signiﬁes that M has moved the corresponding
head onto the previously unread blank portion of that tape. So
S writes a blank symbol on this tape cell and shifts the tape
contents, from this cell until the rightmost #, one unit to the
right. Then it continues the simulation as before.”
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

178
CHAPTER 3 / THE CHURCH---TURING THESIS
COROLLARY
3.15
A language is Turing-recognizable if and only if some multitape Turing machine
recognizes it.
PROOF
A Turing-recognizable language is recognized by an ordinary (single-
tape) Turing machine, which is a special case of a multitape Turing machine.
That proves one direction of this corollary. The other direction follows from
Theorem 3.13.
NONDETERMINISTIC TURING MACHINES
A nondeterministic Turing machine is deﬁned in the expected way. At any point
in a computation, the machine may proceed according to several possibilities.
The transition function for a nondeterministic Turing machine has the form
δ: Q × Γ−→P(Q × Γ × {L, R}).
The computation of a nondeterministic Turing machine is a tree whose branches
correspond to different possibilities for the machine. If some branch of the com-
putation leads to the accept state, the machine accepts its input. If you feel the
need to review nondeterminism, turn to Section 1.2 (page 47). Now we show
that nondeterminism does not affect the power of the Turing machine model.
THEOREM
3.16
Every nondeterministic Turing machine has an equivalent deterministic Turing
machine.
PROOF IDEA
We can simulate any nondeterministic TM N with a determin-
istic TM D. The idea behind the simulation is to have D try all possible branches
of N’s nondeterministic computation. If D ever ﬁnds the accept state on one of
these branches, D accepts. Otherwise, D’s simulation will not terminate.
We view N’s computation on an input w as a tree. Each branch of the tree
represents one of the branches of the nondeterminism. Each node of the tree
is a conﬁguration of N. The root of the tree is the start conﬁguration. The
TM D searches this tree for an accepting conﬁguration. Conducting this search
carefully is crucial lest D fail to visit the entire tree. A tempting, though bad,
idea is to have D explore the tree by using depth-ﬁrst search. The depth-ﬁrst
search strategy goes all the way down one branch before backing up to explore
other branches. If D were to explore the tree in this manner, D could go forever
down one inﬁnite branch and miss an accepting conﬁguration on some other
branch. Hence we design D to explore the tree by using breadth-ﬁrst search
instead. This strategy explores all branches to the same depth before going on
to explore any branch to the next depth. This method guarantees that D will
visit every node in the tree until it encounters an accepting conﬁguration.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

3.2
VARIANTS OF TURING MACHINES
179
PROOF
The simulating deterministic TM D has three tapes.
By Theo-
rem 3.13, this arrangement is equivalent to having a single tape. The machine
D uses its three tapes in a particular way, as illustrated in the following ﬁgure.
Tape 1 always contains the input string and is never altered. Tape 2 maintains a
copy of N’s tape on some branch of its nondeterministic computation. Tape 3
keeps track of D’s location in N’s nondeterministic computation tree.
FIGURE
3.17
Deterministic TM D simulating nondeterministic TM N
Let’s ﬁrst consider the data representation on tape 3. Every node in the tree
can have at most b children, where b is the size of the largest set of possible
choices given by N’s transition function. To every node in the tree we assign
an address that is a string over the alphabet Γb = {1, 2, . . ., b}. We assign the
address 231 to the node we arrive at by starting at the root, going to its 2nd child,
going to that node’s 3rd child, and ﬁnally going to that node’s 1st child. Each
symbol in the string tells us which choice to make next when simulating a step
in one branch in N’s nondeterministic computation. Sometimes a symbol may
not correspond to any choice if too few choices are available for a conﬁguration.
In that case, the address is invalid and doesn’t correspond to any node. Tape 3
contains a string over Γb. It represents the branch of N’s computation from the
root to the node addressed by that string unless the address is invalid. The empty
string is the address of the root of the tree. Now we are ready to describe D.
1. Initially, tape 1 contains the input w, and tapes 2 and 3 are empty.
2. Copy tape 1 to tape 2 and initialize the string on tape 3 to be ε.
3. Use tape 2 to simulate N with input w on one branch of its nondeterminis-
tic computation. Before each step of N, consult the next symbol on tape 3
to determine which choice to make among those allowed by N’s transition
function. If no more symbols remain on tape 3 or if this nondeterministic
choice is invalid, abort this branch by going to stage 4. Also go to stage 4
if a rejecting conﬁguration is encountered. If an accepting conﬁguration is
encountered, accept the input.
4. Replace the string on tape 3 with the next string in the string ordering.
Simulate the next branch of N’s computation by going to stage 2.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

180
CHAPTER 3 / THE CHURCH---TURING THESIS
COROLLARY
3.18
A language is Turing-recognizable if and only if some nondeterministic Turing
machine recognizes it.
PROOF
Any deterministic TM is automatically a nondeterministic TM, and so
one direction of this corollary follows immediately. The other direction follows
from Theorem 3.16.
We can modify the proof of Theorem 3.16 so that if N always halts on all
branches of its computation, D will always halt. We call a nondeterministic Tur-
ing machine a decider if all branches halt on all inputs. Exercise 3.3 asks you to
modify the proof in this way to obtain the following corollary to Theorem 3.16.
COROLLARY
3.19
A language is decidable if and only if some nondeterministic Turing machine
decides it.
ENUMERATORS
As we mentioned earlier, some people use the term recursively enumerable lan-
guage for Turing-recognizable language. That term originates from a type of
Turing machine variant called an enumerator. Loosely deﬁned, an enumera-
tor is a Turing machine with an attached printer. The Turing machine can use
that printer as an output device to print strings. Every time the Turing machine
wants to add a string to the list, it sends the string to the printer. Exercise 3.4 asks
you to give a formal deﬁnition of an enumerator. The following ﬁgure depicts a
schematic of this model.
FIGURE
3.20
Schematic of an enumerator
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

3.2
VARIANTS OF TURING MACHINES
181
An enumerator E starts with a blank input on its work tape. If the enumerator
doesn’t halt, it may print an inﬁnite list of strings. The language enumerated by
E is the collection of all the strings that it eventually prints out. Moreover, E
may generate the strings of the language in any order, possibly with repetitions.
Now we are ready to develop the connection between enumerators and Turing-
recognizable languages.
THEOREM
3.21
A language is Turing-recognizable if and only if some enumerator enumerates it.
PROOF
First we show that if we have an enumerator E that enumerates a
language A, a TM M recognizes A. The TM M works in the following way.
M = “On input w:
1.
Run E. Every time that E outputs a string, compare it with w.
2.
If w ever appears in the output of E, accept.”
Clearly, M accepts those strings that appear on E’s list.
Now we do the other direction. If TM M recognizes a language A, we can
construct the following enumerator E for A. Say that s1, s2, s3, . . . is a list of all
possible strings in Σ∗.
E = “Ignore the input.
1. Repeat the following for i = 1, 2, 3, . . . .
2.
Run M for i steps on each input, s1, s2, . . . , si.
3.
If any computations accept, print out the corresponding sj.”
If M accepts a particular string s, eventually it will appear on the list generated
by E. In fact, it will appear on the list inﬁnitely many times because M runs
from the beginning on each string for each repetition of step 1. This procedure
gives the effect of running M in parallel on all possible input strings.
EQUIVALENCE WITH OTHER MODELS
So far we have presented several variants of the Turing machine model and have
shown them to be equivalent in power. Many other models of general pur-
pose computation have been proposed. Some of these models are very much
like Turing machines, but others are quite different. All share the essential fea-
ture of Turing machines—namely, unrestricted access to unlimited memory—
distinguishing them from weaker models such as ﬁnite automata and pushdown
automata. Remarkably, all models with that feature turn out to be equivalent in
power, so long as they satisfy reasonable requirements.3
3For example, one requirement is the ability to perform only a ﬁnite amount of work in
a single step.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

182
CHAPTER 3 / THE CHURCH---TURING THESIS
To understand this phenomenon, consider the analogous situation for pro-
gramming languages. Many, such as Pascal and LISP, look quite different from
one another in style and structure. Can some algorithm be programmed in one
of them and not the others? Of course not—we can compile LISP into Pascal
and Pascal into LISP, which means that the two languages describe exactly the
same class of algorithms. So do all other reasonable programming languages.
The widespread equivalence of computational models holds for precisely the
same reason. Any two computational models that satisfy certain reasonable re-
quirements can simulate one another and hence are equivalent in power.
This equivalence phenomenon has an important philosophical corollary.
Even though we can imagine many different computational models, the class
of algorithms that they describe remains the same. Whereas each individual
computational model has a certain arbitrariness to its deﬁnition, the underlying
class of algorithms that it describes is natural because the other models arrive
at the same, unique class. This phenomenon has had profound implications for
mathematics, as we show in the next section.
3.3
THE DEFINITION OF ALGORITHM
Informally speaking, an algorithm is a collection of simple instructions for car-
rying out some task. Commonplace in everyday life, algorithms sometimes are
called procedures or recipes. Algorithms also play an important role in mathemat-
ics. Ancient mathematical literature contains descriptions of algorithms for a
variety of tasks, such as ﬁnding prime numbers and greatest common divisors.
In contemporary mathematics, algorithms abound.
Even though algorithms have had a long history in mathematics, the notion
of algorithm itself was not deﬁned precisely until the twentieth century. Before
that, mathematicians had an intuitive notion of what algorithms were, and relied
upon that notion when using and describing them. But that intuitive notion was
insufﬁcient for gaining a deeper understanding of algorithms. The following
story relates how the precise deﬁnition of algorithm was crucial to one important
mathematical problem.
HILBERT’S PROBLEMS
In 1900, mathematician David Hilbert delivered a now-famous address at the
International Congress of Mathematicians in Paris. In his lecture, he identiﬁed
23 mathematical problems and posed them as a challenge for the coming century.
The tenth problem on his list concerned algorithms.
Before describing that problem, let’s brieﬂy discuss polynomials. A polyno-
mial is a sum of terms, where each term is a product of certain variables and a
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

3.3
THE DEFINITION OF ALGORITHM
183
constant, called a coefﬁcient. For example,
6 · x · x · x · y · z · z = 6x3yz2
is a term with coefﬁcient 6, and
6x3yz2 + 3xy2 −x3 −10
is a polynomial with four terms, over the variables x, y, and z. For this discus-
sion, we consider only coefﬁcients that are integers. A root of a polynomial is an
assignment of values to its variables so that the value of the polynomial is 0. This
polynomial has a root at x = 5, y = 3, and z = 0. This root is an integral root
because all the variables are assigned integer values. Some polynomials have an
integral root and some do not.
Hilbert’s tenth problem was to devise an algorithm that tests whether a poly-
nomial has an integral root. He did not use the term algorithm but rather “a
process according to which it can be determined by a ﬁnite number of oper-
ations.”4 Interestingly, in the way he phrased this problem, Hilbert explicitly
asked that an algorithm be “devised.” Thus he apparently assumed that such an
algorithm must exist—someone need only ﬁnd it.
As we now know, no algorithm exists for this task; it is algorithmically unsolv-
able. For mathematicians of that period to come to this conclusion with their
intuitive concept of algorithm would have been virtually impossible. The intu-
itive concept may have been adequate for giving algorithms for certain tasks, but
it was useless for showing that no algorithm exists for a particular task. Proving
that an algorithm does not exist requires having a clear deﬁnition of algorithm.
Progress on the tenth problem had to wait for that deﬁnition.
The deﬁnition came in the 1936 papers of Alonzo Church and Alan Tur-
ing. Church used a notational system called the λ-calculus to deﬁne algorithms.
Turing did it with his “machines.” These two deﬁnitions were shown to be
equivalent. This connection between the informal notion of algorithm and the
precise deﬁnition has come to be called the Church–Turing thesis.
The Church–Turing thesis provides the deﬁnition of algorithm necessary to
resolve Hilbert’s tenth problem. In 1970, Yuri Matijasevi˘c, building on the work
of Martin Davis, Hilary Putnam, and Julia Robinson, showed that no algorithm
exists for testing whether a polynomial has integral roots. In Chapter 4 we de-
velop the techniques that form the basis for proving that this and other problems
are algorithmically unsolvable.
Intuitive notion
Turing machine
of algorithms
equals
algorithms
FIGURE
3.22
The Church–Turing thesis
4Translated from the original German.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

184
CHAPTER 3 / THE CHURCH---TURING THESIS
Let’s phrase Hilbert’s tenth problem in our terminology. Doing so helps to
introduce some themes that we explore in Chapters 4 and 5. Let
D = {p| p is a polynomial with an integral root}.
Hilbert’s tenth problem asks in essence whether the set D is decidable. The
answer is negative. In contrast, we can show that D is Turing-recognizable.
Before doing so, let’s consider a simpler problem. It is an analog of Hilbert’s
tenth problem for polynomials that have only a single variable, such as 4x3 −
2x2 + x −7. Let
D1 = {p| p is a polynomial over x with an integral root}.
Here is a TM M1 that recognizes D1:
M1 = “On input ⟨p⟩: where p is a polynomial over the variable x.
1.
Evaluate p with x set successively to the values 0, 1, −1, 2, −2, 3,
−3, . . . . If at any point the polynomial evaluates to 0, accept.”
If p has an integral root, M1 eventually will ﬁnd it and accept. If p does not have
an integral root, M1 will run forever. For the multivariable case, we can present
a similar TM M that recognizes D. Here, M goes through all possible settings of
its variables to integral values.
Both M1 and M are recognizers but not deciders. We can convert M1 to be
a decider for D1 because we can calculate bounds within which the roots of a
single variable polynomial must lie and restrict the search to these bounds. In
Problem 3.21 you are asked to show that the roots of such a polynomial must lie
between the values
± k cmax
c1
,
where k is the number of terms in the polynomial, cmax is the coefﬁcient with
the largest absolute value, and c1 is the coefﬁcient of the highest order term. If a
root is not found within these bounds, the machine rejects. Matijasevi˘c’s theorem
shows that calculating such bounds for multivariable polynomials is impossible.
TERMINOLOGY FOR DESCRIBING TURING MACHINES
We have come to a turning point in the study of the theory of computation. We
continue to speak of Turing machines, but our real focus from now on is on al-
gorithms. That is, the Turing machine merely serves as a precise model for the
deﬁnition of algorithm. We skip over the extensive theory of Turing machines
themselves and do not spend much time on the low-level programming of Tur-
ing machines. We need only to be comfortable enough with Turing machines to
believe that they capture all algorithms.
With that in mind, let’s standardize the way we describe Turing machine algo-
rithms. Initially, we ask: What is the right level of detail to give when describing
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

3.3
THE DEFINITION OF ALGORITHM
185
such algorithms? Students commonly ask this question, especially when prepar-
ing solutions to exercises and problems. Let’s entertain three possibilities. The
ﬁrst is the formal description that spells out in full the Turing machine’s states,
transition function, and so on. It is the lowest, most detailed level of description.
The second is a higher level of description, called the implementation descrip-
tion, in which we use English prose to describe the way that the Turing machine
moves its head and the way that it stores data on its tape. At this level we do not
give details of states or transition function. The third is the high-level description,
wherein we use English prose to describe an algorithm, ignoring the implemen-
tation details. At this level we do not need to mention how the machine manages
its tape or head.
In this chapter, we have given formal and implementation-level descriptions
of various examples of Turing machines. Practicing with lower level Turing ma-
chine descriptions helps you understand Turing machines and gain conﬁdence
in using them. Once you feel conﬁdent, high-level descriptions are sufﬁcient.
We now set up a format and notation for describing Turing machines. The in-
put to a Turing machine is always a string. If we want to provide an object other
than a string as input, we must ﬁrst represent that object as a string. Strings
can easily represent polynomials, graphs, grammars, automata, and any combi-
nation of those objects. A Turing machine may be programmed to decode the
representation so that it can be interpreted in the way we intend. Our nota-
tion for the encoding of an object O into its representation as a string is ⟨O⟩. If
we have several objects O1, O2, . . . , Ok, we denote their encoding into a single
string ⟨O1, O2, . . . , Ok⟩. The encoding itself can be done in many reasonable
ways. It doesn’t matter which one we pick because a Turing machine can always
translate one such encoding into another.
In our format, we describe Turing machine algorithms with an indented seg-
ment of text within quotes. We break the algorithm into stages, each usually
involving many individual steps of the Turing machine’s computation. We indi-
cate the block structure of the algorithm with further indentation. The ﬁrst line
of the algorithm describes the input to the machine. If the input description is
simply w, the input is taken to be a string. If the input description is the encod-
ing of an object as in ⟨A⟩, the Turing machine ﬁrst implicitly tests whether the
input properly encodes an object of the desired form and rejects it if it doesn’t.
EXAMPLE
3.23
Let A be the language consisting of all strings representing undirected graphs
that are connected. Recall that a graph is connected if every node can be reached
from every other node by traveling along the edges of the graph. We write
A = {⟨G⟩| G is a connected undirected graph}.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

186
CHAPTER 3 / THE CHURCH---TURING THESIS
The following is a high-level description of a TM M that decides A.
M = “On input ⟨G⟩, the encoding of a graph G:
1.
Select the ﬁrst node of G and mark it.
2.
Repeat the following stage until no new nodes are marked:
3.
For each node in G, mark it if it is attached by an edge to a
node that is already marked.
4.
Scan all the nodes of G to determine whether they all are
marked. If they are, accept; otherwise, reject.”
For additional practice, let’s examine some implementation-level details of
Turing machine M. Usually we won’t give this level of detail in the future and
you won’t need to either, unless speciﬁcally requested to do so in an exercise.
First, we must understand how ⟨G⟩encodes the graph G as a string. Consider
an encoding that is a list of the nodes of G followed by a list of the edges of G.
Each node is a decimal number, and each edge is the pair of decimal numbers
that represent the nodes at the two endpoints of the edge. The following ﬁgure
depicts such a graph and its encoding.
FIGURE
3.24
A graph G and its encoding ⟨G⟩
When M receives the input ⟨G⟩, it ﬁrst checks to determine whether the
input is the proper encoding of some graph. To do so, M scans the tape to be
sure that there are two lists and that they are in the proper form. The ﬁrst list
should be a list of distinct decimal numbers, and the second should be a list of
pairs of decimal numbers. Then M checks several things. First, the node list
should contain no repetitions; and second, every node appearing on the edge list
should also appear on the node list. For the ﬁrst, we can use the procedure given
in Example 3.12 for TM M4 that checks element distinctness. A similar method
works for the second check. If the input passes these checks, it is the encoding
of some graph G. This veriﬁcation completes the input check, and M goes on
to stage 1.
For stage 1, M marks the ﬁrst node with a dot on the leftmost digit.
For stage 2, M scans the list of nodes to ﬁnd an undotted node n1 and ﬂags
it by marking it differently—say, by underlining the ﬁrst symbol. Then M scans
the list again to ﬁnd a dotted node n2 and underlines it, too.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

EXERCISES
187
Now M scans the list of edges. For each edge, M tests whether the two
underlined nodes n1 and n2 are the ones appearing in that edge. If they are,
M dots n1, removes the underlines, and goes on from the beginning of stage 2.
If they aren’t, M checks the next edge on the list. If there are no more edges,
{n1, n2} is not an edge of G. Then M moves the underline on n2 to the next
dotted node and now calls this node n2. It repeats the steps in this paragraph
to check, as before, whether the new pair {n1, n2} is an edge. If there are no
more dotted nodes, n1 is not attached to any dotted nodes. Then M sets the
underlines so that n1 is the next undotted node and n2 is the ﬁrst dotted node
and repeats the steps in this paragraph. If there are no more undotted nodes, M
has not been able to ﬁnd any new nodes to dot, so it moves on to stage 4.
For stage 4, M scans the list of nodes to determine whether all are dotted.
If they are, it enters the accept state; otherwise, it enters the reject state. This
completes the description of TM M.
EXERCISES
3.1 This exercise concerns TM M2, whose description and state diagram appear in Ex-
ample 3.7. In each of the parts, give the sequence of conﬁgurations that M2 enters
when started on the indicated input string.
a. 0.
Ab. 00.
c. 000.
d. 000000.
3.2 This exercise concerns TM M1, whose description and state diagram appear in Ex-
ample 3.9. In each of the parts, give the sequence of conﬁgurations that M1 enters
when started on the indicated input string.
Aa. 11.
b. 1#1.
c. 1##1.
d. 10#11.
e. 10#10.
A3.3 Modify the proof of Theorem 3.16 to obtain Corollary 3.19, showing that a lan-
guage is decidable iff some nondeterministic Turing machine decides it. (You may
assume the following theorem about trees. If every node in a tree has ﬁnitely many
children and every branch of the tree has ﬁnitely many nodes, the tree itself has
ﬁnitely many nodes.)
3.4 Give a formal deﬁnition of an enumerator. Consider it to be a type of two-tape
Turing machine that uses its second tape as the printer. Include a deﬁnition of the
enumerated language.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

188
CHAPTER 3 / THE CHURCH---TURING THESIS
A3.5 Examine the formal deﬁnition of a Turing machine to answer the following ques-
tions, and explain your reasoning.
a. Can a Turing machine ever write the blank symbol ␣on its tape?
b. Can the tape alphabet Γ be the same as the input alphabet Σ?
c. Can a Turing machine’s head ever be in the same location in two successive
steps?
d. Can a Turing machine contain just a single state?
3.6 In Theorem 3.21, we showed that a language is Turing-recognizable iff some enu-
merator enumerates it. Why didn’t we use the following simpler algorithm for the
forward direction of the proof? As before, s1, s2, . . . is a list of all strings in Σ∗.
E = “Ignore the input.
1. Repeat the following for i = 1, 2, 3, . . . .
2.
Run M on si.
3.
If it accepts, print out si.”
3.7 Explain why the following is not a description of a legitimate Turing machine.
Mbad = “On input ⟨p⟩, a polynomial over variables x1, . . . , xk:
1.
Try all possible settings of x1, . . . , xk to integer values.
2.
Evaluate p on all of these settings.
3.
If any of these settings evaluates to 0, accept; otherwise, reject.”
3.8 Give implementation-level descriptions of Turing machines that decide the follow-
ing languages over the alphabet {0,1}.
Aa. {w| w contains an equal number of 0s and 1s}
b. {w| w contains twice as many 0s as 1s}
c. {w| w does not contain twice as many 0s as 1s}
PROBLEMS
3.9 Let a k-PDA be a pushdown automaton that has k stacks. Thus a 0-PDA is an
NFA and a 1-PDA is a conventional PDA. You already know that 1-PDAs are more
powerful (recognize a larger class of languages) than 0-PDAs.
a. Show that 2-PDAs are more powerful than 1-PDAs.
b. Show that 3-PDAs are not more powerful than 2-PDAs.
(Hint: Simulate a Turing machine tape with two stacks.)
A3.10 Say that a write-once Turing machine is a single-tape TM that can alter each tape
square at most once (including the input portion of the tape). Show that this variant
Turing machine model is equivalent to the ordinary Turing machine model. (Hint:
As a ﬁrst step, consider the case whereby the Turing machine may alter each tape
square at most twice. Use lots of tape.)
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
189
3.11 A Turing machine with doubly inﬁnite tape is similar to an ordinary Turing ma-
chine, but its tape is inﬁnite to the left as well as to the right. The tape is initially
ﬁlled with blanks except for the portion that contains the input. Computation is
deﬁned as usual except that the head never encounters an end to the tape as it
moves leftward. Show that this type of Turing machine recognizes the class of
Turing-recognizable languages.
3.12 A Turing machine with left reset is similar to an ordinary Turing machine, but the
transition function has the form
δ: Q × Γ−→Q × Γ × {R, RESET}.
If δ(q, a) = (r, b, RESET), when the machine is in state q reading an a, the ma-
chine’s head jumps to the left-hand end of the tape after it writes b on the tape and
enters state r. Note that these machines do not have the usual ability to move the
head one symbol left. Show that Turing machines with left reset recognize the class
of Turing-recognizable languages.
3.13 A Turing machine with stay put instead of left is similar to an ordinary Turing
machine, but the transition function has the form
δ: Q × Γ−→Q × Γ × {R, S}.
At each point, the machine can move its head right or let it stay in the same posi-
tion. Show that this Turing machine variant is not equivalent to the usual version.
What class of languages do these machines recognize?
3.14 A queue automaton is like a push-down automaton except that the stack is replaced
by a queue. A queue is a tape allowing symbols to be written only on the left-hand
end and read only at the right-hand end. Each write operation (we’ll call it a push)
adds a symbol to the left-hand end of the queue and each read operation (we’ll
call it a pull) reads and removes a symbol at the right-hand end. As with a PDA,
the input is placed on a separate read-only input tape, and the head on the input
tape can move only from left to right. The input tape contains a cell with a blank
symbol following the input, so that the end of the input can be detected. A queue
automaton accepts its input by entering a special accept state at any time. Show that
a language can be recognized by a deterministic queue automaton iff the language
is Turing-recognizable.
3.15 Show that the collection of decidable languages is closed under the operation of
Aa. union.
b. concatenation.
c. star.
d. complementation.
e. intersection.
3.16 Show that the collection of Turing-recognizable languages is closed under the op-
eration of
Aa. union.
b. concatenation.
c. star.
d. intersection.
e. homomorphism.
⋆3.17 Let B = {⟨M1⟩, ⟨M2⟩, . . .} be a Turing-recognizable language consisting of TM
descriptions. Show that there is a decidable language C consisting of TM descrip-
tions such that every machine described in B has an equivalent machine in C and
vice versa.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

190
CHAPTER 3 / THE CHURCH---TURING THESIS
⋆3.18 Show that a language is decidable iff some enumerator enumerates the language in
the standard string order.
⋆3.19 Show that every inﬁnite Turing-recognizable language has an inﬁnite decidable
subset.
⋆3.20 Show that single-tape TMs that cannot write on the portion of the tape containing
the input string recognize only regular languages.
3.21 Let c1xn + c2xn−1 + · · · + cnx + cn+1 be a polynomial with a root at x = x0. Let
cmax be the largest absolute value of a ci. Show that
|x0| < (n + 1)cmax
|c1| .
A3.22 Let A be the language containing only the single string s, where
s =
(
0
if life never will be found on Mars.
1
if life will be found on Mars someday.
Is A decidable? Why or why not? For the purposes of this problem, assume that
the question of whether life will be found on Mars has an unambiguous YES or NO
answer.
SELECTED SOLUTIONS
3.1
(b) q100, ␣q20, ␣xq3␣, ␣q5x␣, q5␣x␣, ␣q2x␣, ␣xq2␣, ␣x␣qaccept.
3.2
(a) q111, xq31, x1q3␣, x1␣qreject.
3.3
We prove both directions of the iff. First, if a language L is decidable, it can be
decided by a deterministic Turing machine, and that is automatically a nondeter-
ministic Turing machine.
Second, if a language L is decided by a nondeterministic TM N, we modify the
deterministic TM D that was given in the proof of Theorem 3.16 as follows.
Move stage 4 to be stage 5.
Add new stage 4: Reject if all branches of N’s nondeterminism have rejected.
We argue that this new TM D′ is a decider for L. If N accepts its input, D′ will
eventually ﬁnd an accepting branch and accept, too. If N rejects its input, all of
its branches halt and reject because it is a decider. Hence each of the branches has
ﬁnitely many nodes, where each node represents one step of N’s computation along
that branch. Therefore, N’s entire computation tree on this input is ﬁnite, by virtue
of the theorem about trees given in the statement of the exercise. Consequently,
D′ will halt and reject when this entire tree has been explored.
3.5
(a) Yes. The tape alphabet Γ contains ␣. A Turing machine can write any characters
in Γ on its tape.
(b) No. Σ never contains ␣, but Γ always contains ␣. So they cannot be equal.
(c) Yes. If the Turing machine attempts to move its head off the left-hand end of
the tape, it remains on the same tape cell.
(d) No. Any Turing machine must contain two distinct states: qaccept and qreject. So,
a Turing machine contains at least two states.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

SELECTED SOLUTIONS
191
3.8
(a) “On input string w:
1.
Scan the tape and mark the ﬁrst 0 that has not been marked. If
no unmarked 0 is found, go to stage 4. Otherwise, move the
head back to the front of the tape.
2.
Scan the tape and mark the ﬁrst 1 that has not been marked. If
no unmarked 1 is found, reject.
3.
Move the head back to the front of the tape and go to stage 1.
4.
Move the head back to the front of the tape. Scan the tape to see
if any unmarked 1s remain. If none are found, accept; otherwise,
reject.”
3.10
We ﬁrst simulate an ordinary Turing machine by a write-twice Turing machine.
The write-twice machine simulates a single step of the original machine by copying
the entire tape over to a fresh portion of the tape to the right-hand side of the
currently used portion. The copying procedure operates character by character,
marking a character as it is copied. This procedure alters each tape square twice:
once to write the character for the ﬁrst time, and again to mark that it has been
copied. The position of the original Turing machine’s tape head is marked on
the tape. When copying the cells at or adjacent to the marked position, the tape
content is updated according to the rules of the original Turing machine.
To carry out the simulation with a write-once machine, operate as before, except
that each cell of the previous tape is now represented by two cells. The ﬁrst of these
contains the original machine’s tape symbol and the second is for the mark used in
the copying procedure. The input is not presented to the machine in the format
with two cells per symbol, so the very ﬁrst time the tape is copied, the copying
marks are put directly over the input symbols.
3.15
(a) For any two decidable languages L1 and L2, let M1 and M2 be the TMs that
decide them. We construct a TM M ′ that decides the union of L1 and L2:
“On input w:
1.
Run M1 on w. If it accepts, accept.
2.
Run M2 on w. If it accepts, accept. Otherwise, reject.”
M ′ accepts w if either M1 or M2 accepts it. If both reject, M ′ rejects.
3.16
(a) For any two Turing-recognizable languages L1 and L2, let M1 and M2 be the
TMs that recognize them. We construct a TM M ′ that recognizes the union of L1
and L2:
“On input w:
1.
Run M1 and M2 alternately on w step by step. If either accepts,
accept. If both halt and reject, reject.”
If either M1 or M2 accepts w, M ′ accepts w because the accepting TM arrives to its
accepting state after a ﬁnite number of steps. Note that if both M1 and M2 reject
and either of them does so by looping, then M ′ will loop.
3.22
The language A is one of the two languages {0} or {1}. In either case, the language
is ﬁnite and hence decidable. If you aren’t able to determine which of these two
languages is A, you won’t be able to describe the decider for A. However, you can
give two Turing machines, one of which is A’s decider.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

4
D E C I D A B I L I T Y
In Chapter 3 we introduced the Turing machine as a model of a general purpose
computer and deﬁned the notion of algorithm in terms of Turing machines by
means of the Church–Turing thesis.
In this chapter we begin to investigate the power of algorithms to solve prob-
lems. We demonstrate certain problems that can be solved algorithmically and
others that cannot. Our objective is to explore the limits of algorithmic solv-
ability. You are probably familiar with solvability by algorithms because much of
computer science is devoted to solving problems. The unsolvability of certain
problems may come as a surprise.
Why should you study unsolvability? After all, showing that a problem is
unsolvable doesn’t appear to be of any use if you have to solve it. You need
to study this phenomenon for two reasons. First, knowing when a problem is
algorithmically unsolvable is useful because then you realize that the problem
must be simpliﬁed or altered before you can ﬁnd an algorithmic solution. Like
any tool, computers have capabilities and limitations that must be appreciated if
they are to be used well. The second reason is cultural. Even if you deal with
problems that clearly are solvable, a glimpse of the unsolvable can stimulate your
imagination and help you gain an important perspective on computation.
193
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

194
CHAPTER 4 / DECIDABILITY
4.1
DECIDABLE LANGUAGES
In this section we give some examples of languages that are decidable by al-
gorithms. We focus on languages concerning automata and grammars. For
example, we present an algorithm that tests whether a string is a member of a
context-free language (CFL). These languages are interesting for several reasons.
First, certain problems of this kind are related to applications. This problem of
testing whether a CFG generates a string is related to the problem of recogniz-
ing and compiling programs in a programming language. Second, certain other
problems concerning automata and grammars are not decidable by algorithms.
Starting with examples where decidability is possible helps you to appreciate the
undecidable examples.
DECIDABLE PROBLEMS CONCERNING
REGULAR LANGUAGES
We begin with certain computational problems concerning ﬁnite automata. We
give algorithms for testing whether a ﬁnite automaton accepts a string, whether
the language of a ﬁnite automaton is empty, and whether two ﬁnite automata are
equivalent.
Note that we chose to represent various computational problems by lan-
guages. Doing so is convenient because we have already set up terminology for
dealing with languages. For example, the acceptance problem for DFAs of testing
whether a particular deterministic ﬁnite automaton accepts a given string can be
expressed as a language, ADFA. This language contains the encodings of all DFAs
together with strings that the DFAs accept. Let
ADFA = {⟨B, w⟩| B is a DFA that accepts input string w}.
The problem of testing whether a DFA B accepts an input w is the same as the
problem of testing whether ⟨B, w⟩is a member of the language ADFA. Similarly,
we can formulate other computational problems in terms of testing membership
in a language. Showing that the language is decidable is the same as showing
that the computational problem is decidable.
In the following theorem we show that ADFA is decidable. Hence this theorem
shows that the problem of testing whether a given ﬁnite automaton accepts a
given string is decidable.
THEOREM
4.1
ADFA is a decidable language.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

4.1
DECIDABLE LANGUAGES
195
PROOF IDEA
We simply need to present a TM M that decides ADFA.
M = “On input ⟨B, w⟩, where B is a DFA and w is a string:
1.
Simulate B on input w.
2.
If the simulation ends in an accept state, accept. If it ends in a
nonaccepting state, reject.”
PROOF
We mention just a few implementation details of this proof. For
those of you familiar with writing programs in any standard programming lan-
guage, imagine how you would write a program to carry out the simulation.
First, let’s examine the input ⟨B, w⟩. It is a representation of a DFA B together
with a string w. One reasonable representation of B is simply a list of its ﬁve
components: Q, Σ, δ, q0, and F. When M receives its input, M ﬁrst determines
whether it properly represents a DFA B and a string w. If not, M rejects.
Then M carries out the simulation directly. It keeps track of B’s current
state and B’s current position in the input w by writing this information down
on its tape. Initially, B’s current state is q0 and B’s current input position is
the leftmost symbol of w. The states and position are updated according to the
speciﬁed transition function δ. When M ﬁnishes processing the last symbol of
w, M accepts the input if B is in an accepting state; M rejects the input if B is
in a nonaccepting state.
We can prove a similar theorem for nondeterministic ﬁnite automata. Let
ANFA = {⟨B, w⟩| B is an NFA that accepts input string w}.
THEOREM
4.2
ANFA is a decidable language.
PROOF
We present a TM N that decides ANFA. We could design N to operate
like M, simulating an NFA instead of a DFA. Instead, we’ll do it differently to
illustrate a new idea: Have N use M as a subroutine. Because M is designed
to work with DFAs, N ﬁrst converts the NFA it receives as input to a DFA before
passing it to M.
N = “On input ⟨B, w⟩, where B is an NFA and w is a string:
1.
Convert NFA B to an equivalent DFA C, using the procedure for
this conversion given in Theorem 1.39.
2.
Run TM M from Theorem 4.1 on input ⟨C, w⟩.
3.
If M accepts, accept; otherwise, reject.”
Running TM M in stage 2 means incorporating M into the design of N as a
subprocedure.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

196
CHAPTER 4 / DECIDABILITY
Similarly, we can determine whether a regular expression generates a given
string. Let AREX = {⟨R, w⟩| R is a regular expression that generates string w}.
THEOREM
4.3
AREX is a decidable language.
PROOF
The following TM P decides AREX.
P = “On input ⟨R, w⟩, where R is a regular expression and w is a string:
1.
Convert regular expression R to an equivalent NFA A by using
the procedure for this conversion given in Theorem 1.54.
2.
Run TM N on input ⟨A, w⟩.
3.
If N accepts, accept; if N rejects, reject.”
Theorems 4.1, 4.2, and 4.3 illustrate that, for decidability purposes, it is
equivalent to present the Turing machine with a DFA, an NFA, or a regular ex-
pression because the machine can convert one form of encoding to another.
Now we turn to a different kind of problem concerning ﬁnite automata:
emptiness testing for the language of a ﬁnite automaton. In the preceding three
theorems we had to determine whether a ﬁnite automaton accepts a particular
string. In the next proof we must determine whether or not a ﬁnite automaton
accepts any strings at all. Let
EDFA = {⟨A⟩| A is a DFA and L(A) = ∅}.
THEOREM
4.4
EDFA is a decidable language.
PROOF
A DFA accepts some string iff reaching an accept state from the start
state by traveling along the arrows of the DFA is possible. To test this condition,
we can design a TM T that uses a marking algorithm similar to that used in
Example 3.23.
T = “On input ⟨A⟩, where A is a DFA:
1.
Mark the start state of A.
2.
Repeat until no new states get marked:
3.
Mark any state that has a transition coming into it from any
state that is already marked.
4.
If no accept state is marked, accept; otherwise, reject.”
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

4.1
DECIDABLE LANGUAGES
197
The next theorem states that determining whether two DFAs recognize the
same language is decidable. Let
EQDFA = {⟨A, B⟩| A and B are DFAs and L(A) = L(B)}.
THEOREM
4.5
EQDFA is a decidable language.
PROOF
To prove this theorem, we use Theorem 4.4. We construct a new
DFA C from A and B, where C accepts only those strings that are accepted by
either A or B but not by both. Thus, if A and B recognize the same language,
C will accept nothing. The language of C is
L(C) =

L(A) ∩L(B)

∪

L(A) ∩L(B)

.
This expression is sometimes called the symmetric difference of L(A) and L(B)
and is illustrated in the following ﬁgure. Here, L(A) is the complement of L(A).
The symmetric difference is useful here because L(C) = ∅iff L(A) = L(B).
We can construct C from A and B with the constructions for proving the class
of regular languages closed under complementation, union, and intersection.
These constructions are algorithms that can be carried out by Turing machines.
Once we have constructed C, we can use Theorem 4.4 to test whether L(C) is
empty. If it is empty, L(A) and L(B) must be equal.
F = “On input ⟨A, B⟩, where A and B are DFAs:
1.
Construct DFA C as described.
2.
Run TM T from Theorem 4.4 on input ⟨C⟩.
3.
If T accepts, accept. If T rejects, reject.”
FIGURE
4.6
The symmetric difference of L(A) and L(B)
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

198
CHAPTER 4 / DECIDABILITY
DECIDABLE PROBLEMS CONCERNING
CONTEXT-FREE LANGUAGES
Here, we describe algorithms to determine whether a CFG generates a particular
string and to determine whether the language of a CFG is empty. Let
ACFG = {⟨G, w⟩| G is a CFG that generates string w}.
THEOREM
4.7
ACFG is a decidable language.
PROOF IDEA
For CFG G and string w, we want to determine whether G
generates w. One idea is to use G to go through all derivations to determine
whether any is a derivation of w. This idea doesn’t work, as inﬁnitely many
derivations may have to be tried. If G does not generate w, this algorithm would
never halt. This idea gives a Turing machine that is a recognizer, but not a
decider, for ACFG.
To make this Turing machine into a decider, we need to ensure that the al-
gorithm tries only ﬁnitely many derivations. In Problem 2.26 (page 157) we
showed that if G were in Chomsky normal form, any derivation of w has 2n −1
steps, where n is the length of w. In that case, checking only derivations with
2n −1 steps to determine whether G generates w would be sufﬁcient. Only
ﬁnitely many such derivations exist. We can convert G to Chomsky normal
form by using the procedure given in Section 2.1.
PROOF
The TM S for ACFG follows.
S = “On input ⟨G, w⟩, where G is a CFG and w is a string:
1.
Convert G to an equivalent grammar in Chomsky normal form.
2.
List all derivations with 2n−1 steps, where n is the length of w;
except if n = 0, then instead list all derivations with one step.
3.
If any of these derivations generate w, accept; if not, reject.”
The problem of determining whether a CFG generates a particular string is
related to the problem of compiling programming languages. The algorithm in
TM S is very inefﬁcient and would never be used in practice, but it is easy to de-
scribe and we aren’t concerned with efﬁciency here. In Part Three of this book,
we address issues concerning the running time and memory use of algorithms.
In the proof of Theorem 7.16, we describe a more efﬁcient algorithm for rec-
ognizing general context-free languages. Even greater efﬁciency is possible for
recognizing deterministic context-free languages.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

4.1
DECIDABLE LANGUAGES
199
Recall that we have given procedures for converting back and forth between
CFGs and PDAs in Theorem 2.20. Hence everything we say about the decidability
of problems concerning CFGs applies equally well to PDAs.
Let’s turn now to the emptiness testing problem for the language of a CFG.
As we did for DFAs, we can show that the problem of determining whether a CFG
generates any strings at all is decidable. Let
ECFG = {⟨G⟩| G is a CFG and L(G) = ∅}.
THEOREM
4.8
ECFG is a decidable language.
PROOF IDEA
To ﬁnd an algorithm for this problem, we might attempt to
use TM S from Theorem 4.7. It states that we can test whether a CFG generates
some particular string w. To determine whether L(G) = ∅, the algorithm might
try going through all possible w’s, one by one. But there are inﬁnitely many w’s
to try, so this method could end up running forever. We need to take a different
approach.
In order to determine whether the language of a grammar is empty, we need
to test whether the start variable can generate a string of terminals. The algo-
rithm does so by solving a more general problem. It determines for each variable
whether that variable is capable of generating a string of terminals. When the
algorithm has determined that a variable can generate some string of terminals,
the algorithm keeps track of this information by placing a mark on that variable.
First, the algorithm marks all the terminal symbols in the grammar. Then, it
scans all the rules of the grammar. If it ever ﬁnds a rule that permits some vari-
able to be replaced by some string of symbols, all of which are already marked,
the algorithm knows that this variable can be marked, too. The algorithm con-
tinues in this way until it cannot mark any additional variables.
The TM R
implements this algorithm.
PROOF
R = “On input ⟨G⟩, where G is a CFG:
1.
Mark all terminal symbols in G.
2.
Repeat until no new variables get marked:
3.
Mark any variable A where G has a rule A →U1U2 · · · Uk and
each symbol U1, . . . , Uk has already been marked.
4.
If the start variable is not marked, accept; otherwise, reject.”
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

200
CHAPTER 4 / DECIDABILITY
Next, we consider the problem of determining whether two context-free
grammars generate the same language. Let
EQCFG = {⟨G, H⟩| G and H are CFGs and L(G) = L(H)}.
Theorem 4.5 gave an algorithm that decides the analogous language EQDFA for
ﬁnite automata. We used the decision procedure for EDFA to prove that EQDFA
is decidable. Because ECFG also is decidable, you might think that we can use
a similar strategy to prove that EQCFG is decidable. But something is wrong
with this idea! The class of context-free languages is not closed under comple-
mentation or intersection, as you proved in Exercise 2.2. In fact, EQCFG is not
decidable. The technique for proving so is presented in Chapter 5.
Now we show that context-free languages are decidable by Turing machines.
THEOREM
4.9
Every context-free language is decidable.
PROOF IDEA
Let A be a CFL. Our objective is to show that A is decidable.
One (bad) idea is to convert a PDA for A directly into a TM. That isn’t hard to
do because simulating a stack with the TM’s more versatile tape is easy. The PDA
for A may be nondeterministic, but that seems okay because we can convert it
into a nondeterministic TM and we know that any nondeterministic TM can be
converted into an equivalent deterministic TM. Yet, there is a difﬁculty. Some
branches of the PDA’s computation may go on forever, reading and writing the
stack without ever halting. The simulating TM then would also have some non-
halting branches in its computation, and so the TM would not be a decider. A
different idea is necessary. Instead, we prove this theorem with the TM S that we
designed in Theorem 4.7 to decide ACFG.
PROOF
Let G be a CFG for A and design a TM MG that decides A. We build
a copy of G into MG. It works as follows.
MG = “On input w:
1.
Run TM S on input ⟨G, w⟩.
2.
If this machine accepts, accept; if it rejects, reject.”
Theorem 4.9 provides the ﬁnal link in the relationship among the four main
classes of languages that we have described so far: regular, context-free, decid-
able, and Turing-recognizable. Figure 4.10 depicts this relationship.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

4.2
UNDECIDABILITY
201
FIGURE
4.10
The relationship among classes of languages
4.2
UNDECIDABILITY
In this section, we prove one of the most philosophically important theorems of
the theory of computation: There is a speciﬁc problem that is algorithmically
unsolvable. Computers appear to be so powerful that you may believe that all
problems will eventually yield to them. The theorem presented here demon-
strates that computers are limited in a fundamental way.
What sorts of problems are unsolvable by computer?
Are they esoteric,
dwelling only in the minds of theoreticians? No! Even some ordinary prob-
lems that people want to solve turn out to be computationally unsolvable.
In one type of unsolvable problem, you are given a computer program and
a precise speciﬁcation of what that program is supposed to do (e.g., sort a list
of numbers). You need to verify that the program performs as speciﬁed (i.e.,
that it is correct). Because both the program and the speciﬁcation are mathe-
matically precise objects, you hope to automate the process of veriﬁcation by
feeding these objects into a suitably programmed computer. However, you will
be disappointed. The general problem of software veriﬁcation is not solvable by
computer.
In this section and in Chapter 5, you will encounter several computationally
unsolvable problems. We aim to help you develop a feeling for the types of
problems that are unsolvable and to learn techniques for proving unsolvability.
Now we turn to our ﬁrst theorem that establishes the undecidability of a spe-
ciﬁc language: the problem of determining whether a Turing machine accepts a
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

202
CHAPTER 4 / DECIDABILITY
given input string. We call it ATM by analogy with ADFA and ACFG. But, whereas
ADFA and ACFG were decidable, ATM is not. Let
ATM = {⟨M, w⟩| M is a TM and M accepts w}.
THEOREM
4.11
ATM is undecidable.
Before we get to the proof, let’s ﬁrst observe that ATM is Turing-recognizable.
Thus, this theorem shows that recognizers are more powerful than deciders.
Requiring a TM to halt on all inputs restricts the kinds of languages that it can
recognize. The following Turing machine U recognizes ATM.
U = “On input ⟨M, w⟩, where M is a TM and w is a string:
1.
Simulate M on input w.
2.
If M ever enters its accept state, accept; if M ever enters its
reject state, reject.”
Note that this machine loops on input ⟨M, w⟩if M loops on w, which is why
this machine does not decide ATM. If the algorithm had some way to determine
that M was not halting on w, it could reject in this case. However, an algorithm
has no way to make this determination, as we shall see.
The Turing machine U is interesting in its own right. It is an example of the
universal Turing machine ﬁrst proposed by Alan Turing in 1936. This machine
is called universal because it is capable of simulating any other Turing machine
from the description of that machine. The universal Turing machine played an
important early role in the development of stored-program computers.
THE DIAGONALIZATION METHOD
The proof of the undecidability of ATM uses a technique called diagonalization,
discovered by mathematician Georg Cantor in 1873. Cantor was concerned
with the problem of measuring the sizes of inﬁnite sets. If we have two inﬁnite
sets, how can we tell whether one is larger than the other or whether they are of
the same size? For ﬁnite sets, of course, answering these questions is easy. We
simply count the elements in a ﬁnite set, and the resulting number is its size. But
if we try to count the elements of an inﬁnite set, we will never ﬁnish! So we can’t
use the counting method to determine the relative sizes of inﬁnite sets.
For example, take the set of even integers and the set of all strings over {0,1}.
Both sets are inﬁnite and thus larger than any ﬁnite set, but is one of the two
larger than the other? How can we compare their relative size?
Cantor proposed a rather nice solution to this problem. He observed that two
ﬁnite sets have the same size if the elements of one set can be paired with the
elements of the other set. This method compares the sizes without resorting to
counting. We can extend this idea to inﬁnite sets. Here it is more precisely.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

4.2
UNDECIDABILITY
203
DEFINITION
4.12
Assume that we have sets A and B and a function f from A to B.
Say that f is one-to-one if it never maps two different elements to
the same place—that is, if f(a) ̸= f(b) whenever a ̸= b. Say that
f is onto if it hits every element of B—that is, if for every b ∈B
there is an a ∈A such that f(a) = b. Say that A and B are the same
size if there is a one-to-one, onto function f : A−→B. A function
that is both one-to-one and onto is called a correspondence. In a
correspondence, every element of A maps to a unique element of
B and each element of B has a unique element of A mapping to it.
A correspondence is simply a way of pairing the elements of A with
the elements of B.
Alternative common terminology for these types of functions is injective for
one-to-one, surjective for onto, and bijective for one-to-one and onto.
EXAMPLE
4.13
Let N be the set of natural numbers {1, 2, 3, . . .} and let E be the set of even
natural numbers {2, 4, 6, . . .}. Using Cantor’s deﬁnition of size, we can see that
N and E have the same size. The correspondence f mapping N to E is simply
f(n) = 2n. We can visualize f more easily with the help of a table.
n
f(n)
1
2
2
4
3
6
...
...
Of course, this example seems bizarre. Intuitively, E seems smaller than N be-
cause E is a proper subset of N. But pairing each member of N with its own
member of E is possible, so we declare these two sets to be the same size.
DEFINITION
4.14
A set A is countable if either it is ﬁnite or it has the same size as N.
EXAMPLE
4.15
Now we turn to an even stranger example. If we let Q = { m
n | m, n ∈N} be the
set of positive rational numbers, Q seems to be much larger than N. Yet these
two sets are the same size according to our deﬁnition. We give a correspondence
with N to show that Q is countable. One easy way to do so is to list all the
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

204
CHAPTER 4 / DECIDABILITY
elements of Q. Then we pair the ﬁrst element on the list with the number 1
from N, the second element on the list with the number 2 from N, and so on.
We must ensure that every member of Q appears only once on the list.
To get this list, we make an inﬁnite matrix containing all the positive ratio-
nal numbers, as shown in Figure 4.16. The ith row contains all numbers with
numerator i and the jth column has all numbers with denominator j. So the
number i
j occurs in the ith row and jth column.
Now we turn this matrix into a list. One (bad) way to attempt it would be to
begin the list with all the elements in the ﬁrst row. That isn’t a good approach
because the ﬁrst row is inﬁnite, so the list would never get to the second row.
Instead we list the elements on the diagonals, which are superimposed on the
diagram, starting from the corner. The ﬁrst diagonal contains the single element
1
1, and the second diagonal contains the two elements 2
1 and 1
2. So the ﬁrst
three elements on the list are 1
1, 2
1, and 1
2. In the third diagonal, a complication
arises. It contains 3
1, 2
2, and 1
3. If we simply added these to the list, we would
repeat 1
1 = 2
2. We avoid doing so by skipping an element when it would cause
a repetition. So we add only the two new elements 3
1 and 1
3. Continuing in this
way, we obtain a list of all the elements of Q.
FIGURE
4.16
A correspondence of N and Q
After seeing the correspondence of N and Q, you might think that any two
inﬁnite sets can be shown to have the same size. After all, you need only demon-
strate a correspondence, and this example shows that surprising correspondences
do exist. However, for some inﬁnite sets, no correspondence with N exists.
These sets are simply too big. Such sets are called uncountable.
The set of real numbers is an example of an uncountable set. A real number
is one that has a decimal representation. The numbers π = 3.1415926. . . and
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

4.2
UNDECIDABILITY
205
√
2 = 1.4142135. . . are examples of real numbers. Let R be the set of real
numbers. Cantor proved that R is uncountable. In doing so, he introduced the
diagonalization method.
THEOREM
4.17
R is uncountable.
PROOF
In order to show that R is uncountable, we show that no correspon-
dence exists between N and R. The proof is by contradiction. Suppose that a
correspondence f existed between N and R. Our job is to show that f fails to
work as it should. For it to be a correspondence, f must pair all the members of
N with all the members of R. But we will ﬁnd an x in R that is not paired with
anything in N, which will be our contradiction.
The way we ﬁnd this x is by actually constructing it. We choose each digit
of x to make x different from one of the real numbers that is paired with an
element of N. In the end, we are sure that x is different from any real number
that is paired.
We can illustrate this idea by giving an example. Suppose that the correspon-
dence f exists. Let f(1) = 3.14159. . . , f(2) = 55.55555. . . , f(3) = . . . ,
and so on, just to make up some values for f. Then f pairs the number 1 with
3.14159. . . , the number 2 with 55.55555. . . , and so on. The following table
shows a few values of a hypothetical correspondence f between N and R.
n
f(n)
1
3.14159. . .
2
55.55555. . .
3
0.12345. . .
4
0.50000. . .
...
...
We construct the desired x by giving its decimal representation. It is a num-
ber between 0 and 1, so all its signiﬁcant digits are fractional digits following the
decimal point. Our objective is to ensure that x ̸= f(n) for any n. To ensure
that x ̸= f(1), we let the ﬁrst digit of x be anything different from the ﬁrst
fractional digit 1 of f(1) = 3.14159. . . . Arbitrarily, we let it be 4. To ensure
that x ̸= f(2), we let the second digit of x be anything different from the second
fractional digit 5 of f(2) = 55.555555. . . . Arbitrarily, we let it be 6. The third
fractional digit of f(3) = 0.12345 . . . is 3, so we let x be anything different—
say, 4. Continuing in this way down the diagonal of the table for f, we obtain
all the digits of x, as shown in the following table. We know that x is not f(n)
for any n because it differs from f(n) in the nth fractional digit. (A slight prob-
lem arises because certain numbers, such as 0.1999. . . and 0.2000. . . , are equal
even though their decimal representations are different. We avoid this problem
by never selecting the digits 0 or 9 when we construct x.)
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

206
CHAPTER 4 / DECIDABILITY
n
f(n)
1
3.14159. . .
2
55.55555. . .
3
0.12345 . . .
4
0.50000 . . .
...
...
x = 0.4641 . . .
The preceding theorem has an important application to the theory of com-
putation.
It shows that some languages are not decidable or even Turing-
recognizable, for the reason that there are uncountably many languages yet only
countably many Turing machines. Because each Turing machine can recognize
a single language and there are more languages than Turing machines, some
languages are not recognized by any Turing machine. Such languages are not
Turing-recognizable, as we state in the following corollary.
COROLLARY
4.18
Some languages are not Turing-recognizable.
PROOF
To show that the set of all Turing machines is countable, we ﬁrst
observe that the set of all strings Σ∗is countable for any alphabet Σ. With only
ﬁnitely many strings of each length, we may form a list of Σ∗by writing down
all strings of length 0, length 1, length 2, and so on.
The set of all Turing machines is countable because each Turing machine M
has an encoding into a string ⟨M⟩. If we simply omit those strings that are not
legal encodings of Turing machines, we can obtain a list of all Turing machines.
To show that the set of all languages is uncountable, we ﬁrst observe that the
set of all inﬁnite binary sequences is uncountable. An inﬁnite binary sequence is an
unending sequence of 0s and 1s. Let B be the set of all inﬁnite binary sequences.
We can show that B is uncountable by using a proof by diagonalization similar
to the one we used in Theorem 4.17 to show that R is uncountable.
Let L be the set of all languages over alphabet Σ. We show that L is un-
countable by giving a correspondence with B, thus showing that the two sets are
the same size. Let Σ∗= {s1, s2, s3, . . .}. Each language A ∈L has a unique
sequence in B. The ith bit of that sequence is a 1 if si ∈A and is a 0 if si ̸∈A,
which is called the characteristic sequence of A. For example, if A were the lan-
guage of all strings starting with a 0 over the alphabet {0,1}, its characteristic
sequence χA would be
Σ∗= { ε,
0,
1,
00,
01,
10,
11, 000, 001, · · · } ;
A = {
0,
00,
01,
000, 001, · · · } ;
χA =
0
1
0
1
1
0
0
1
1
· · ·
.
The function f : L−→B, where f(A) equals the characteristic sequence of
A, is one-to-one and onto, and hence is a correspondence. Therefore, as B is
uncountable, L is uncountable as well.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

4.2
UNDECIDABILITY
207
Thus we have shown that the set of all languages cannot be put into a corre-
spondence with the set of all Turing machines. We conclude that some languages
are not recognized by any Turing machine.
AN UNDECIDABLE LANGUAGE
Now we are ready to prove Theorem 4.11, the undecidability of the language
ATM = {⟨M, w⟩| M is a TM and M accepts w}.
PROOF
We assume that ATM is decidable and obtain a contradiction. Sup-
pose that H is a decider for ATM. On input ⟨M, w⟩, where M is a TM and w is a
string, H halts and accepts if M accepts w. Furthermore, H halts and rejects if
M fails to accept w. In other words, we assume that H is a TM, where
H
 ⟨M, w⟩

=
(
accept
if M accepts w
reject
if M does not accept w.
Now we construct a new Turing machine D with H as a subroutine. This
new TM calls H to determine what M does when the input to M is its own
description ⟨M⟩. Once D has determined this information, it does the opposite.
That is, it rejects if M accepts and accepts if M does not accept. The following
is a description of D.
D = “On input ⟨M⟩, where M is a TM:
1.
Run H on input ⟨M, ⟨M⟩⟩.
2.
Output the opposite of what H outputs. That is, if H accepts,
reject; and if H rejects, accept.”
Don’t be confused by the notion of running a machine on its own description!
That is similar to running a program with itself as input, something that does
occasionally occur in practice. For example, a compiler is a program that trans-
lates other programs. A compiler for the language Python may itself be written
in Python, so running that program on itself would make sense. In summary,
D
 ⟨M⟩

=
(
accept
if M does not accept ⟨M⟩
reject
if M accepts ⟨M⟩.
What happens when we run D with its own description ⟨D⟩as input? In that
case, we get
D
 ⟨D⟩

=
(
accept
if D does not accept ⟨D⟩
reject
if D accepts ⟨D⟩.
No matter what D does, it is forced to do the opposite, which is obviously a
contradiction. Thus, neither TM D nor TM H can exist.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

208
CHAPTER 4 / DECIDABILITY
Let’s review the steps of this proof. Assume that a TM H decides ATM. Use H
to build a TM D that takes an input ⟨M⟩, where D accepts its input ⟨M⟩exactly
when M does not accept its input ⟨M⟩. Finally, run D on itself. Thus, the
machines take the following actions, with the last line being the contradiction.
• H accepts ⟨M, w⟩exactly when M accepts w.
• D rejects ⟨M⟩exactly when M accepts ⟨M⟩.
• D rejects ⟨D⟩exactly when D accepts ⟨D⟩.
Where is the diagonalization in the proof of Theorem 4.11? It becomes ap-
parent when you examine tables of behavior for TMs H and D. In these tables
we list all TMs down the rows, M1, M2, . . . , and all their descriptions across the
columns, ⟨M1⟩, ⟨M2⟩, . . . . The entries tell whether the machine in a given row
accepts the input in a given column. The entry is accept if the machine accepts
the input but is blank if it rejects or loops on that input. We made up the entries
in the following ﬁgure to illustrate the idea.
⟨M1⟩
⟨M2⟩
⟨M3⟩
⟨M4⟩
· · ·
M1
accept
accept
M2
accept
accept
accept
accept
M3
M4
accept
accept
· · ·
...
...
FIGURE
4.19
Entry i, j is accept if Mi accepts ⟨Mj⟩
In the following ﬁgure, the entries are the results of running H on inputs
corresponding to Figure 4.19. So if M3 does not accept input ⟨M2⟩, the entry
for row M3 and column ⟨M2⟩is reject because H rejects input ⟨M3, ⟨M2⟩⟩.
⟨M1⟩
⟨M2⟩
⟨M3⟩
⟨M4⟩
· · ·
M1
accept
reject
accept
reject
M2
accept
accept
accept
accept
M3
reject
reject
reject
reject
· · ·
M4
accept
accept
reject
reject
...
...
FIGURE
4.20
Entry i, j is the value of H on input ⟨Mi, ⟨Mj⟩⟩
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

4.2
UNDECIDABILITY
209
In the following ﬁgure, we added D to Figure 4.20. By our assumption, H is
a TM and so is D. Therefore, it must occur on the list M1, M2, . . . of all TMs.
Note that D computes the opposite of the diagonal entries. The contradiction
occurs at the point of the question mark where the entry must be the opposite
of itself.
⟨M1⟩
⟨M2⟩
⟨M3⟩
⟨M4⟩
· · ·
⟨D⟩
· · ·
M1
accept
reject
accept
reject
accept
M2
accept
accept
accept
accept
accept
M3
reject
reject
reject
reject
· · ·
reject
· · ·
M4
accept
accept
reject
reject
accept
...
...
...
D
reject
reject
accept
accept
?
...
...
...
FIGURE
4.21
If D is in the ﬁgure, a contradiction occurs at “?”
A TURING-UNRECOGNIZABLE LANGUAGE
In the preceding section, we exhibited a language—namely, ATM—that is un-
decidable.
Now we exhibit a language that isn’t even Turing-recognizable.
Note that ATM will not sufﬁce for this purpose because we showed that ATM
is Turing-recognizable (page 202). The following theorem shows that if both
a language and its complement are Turing-recognizable, the language is decid-
able. Hence for any undecidable language, either it or its complement is not
Turing-recognizable. Recall that the complement of a language is the language
consisting of all strings that are not in the language. We say that a language is co-
Turing-recognizable if it is the complement of a Turing-recognizable language.
THEOREM
4.22
A language is decidable iff it is Turing-recognizable and co-Turing-recognizable.
In other words, a language is decidable exactly when both it and its complement
are Turing-recognizable.
PROOF
We have two directions to prove. First, if A is decidable, we can easily
see that both A and its complement A are Turing-recognizable. Any decidable
language is Turing-recognizable, and the complement of a decidable language
also is decidable.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

210
CHAPTER 4 / DECIDABILITY
For the other direction, if both A and A are Turing-recognizable, we let M1
be the recognizer for A and M2 be the recognizer for A. The following Turing
machine M is a decider for A.
M = “On input w:
1.
Run both M1 and M2 on input w in parallel.
2.
If M1 accepts, accept; if M2 accepts, reject.”
Running the two machines in parallel means that M has two tapes, one for simu-
lating M1 and the other for simulating M2. In this case, M takes turns simulating
one step of each machine, which continues until one of them accepts.
Now we show that M decides A. Every string w is either in A or A. There-
fore, either M1 or M2 must accept w. Because M halts whenever M1 or M2
accepts, M always halts and so it is a decider. Furthermore, it accepts all strings
in A and rejects all strings not in A. So M is a decider for A, and thus A is
decidable.
COROLLARY
4.23
ATM is not Turing-recognizable.
PROOF
We know that ATM is Turing-recognizable. If ATM also were Turing-
recognizable, ATM would be decidable. Theorem 4.11 tells us that ATM is not
decidable, so ATM must not be Turing-recognizable.
EXERCISES
A4.1 Answer all parts for the following DFA M and give reasons for your answers.
a. Is ⟨M, 0100⟩∈ADFA?
b. Is ⟨M, 011⟩∈ADFA?
c. Is ⟨M⟩∈ADFA?
d. Is ⟨M, 0100⟩∈AREX?
e. Is ⟨M⟩∈EDFA?
f. Is ⟨M, M⟩∈EQDFA?
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
211
4.2 Consider the problem of determining whether a DFA and a regular expression are
equivalent. Express this problem as a language and show that it is decidable.
4.3 Let ALLDFA = {⟨A⟩| A is a DFA and L(A) = Σ∗}. Show that ALLDFA is decidable.
4.4 Let AεCFG = {⟨G⟩| G is a CFG that generates ε}. Show that AεCFG is decidable.
A4.5 Let ETM = {⟨M⟩| M is a TM and L(M) = ∅}. Show that ETM, the complement of
ETM, is Turing-recognizable.
4.6 Let X be the set {1, 2, 3, 4, 5} and Y be the set {6, 7, 8, 9, 10}. We describe the
functions f : X−→Y and g: X−→Y in the following tables. Answer each part
and give a reason for each negative answer.
n
f(n)
1
6
2
7
3
6
4
7
5
6
n
g(n)
1
10
2
9
3
8
4
7
5
6
Aa. Is f one-to-one?
b. Is f onto?
c. Is f a correspondence?
Ad. Is g one-to-one?
e. Is g onto?
f. Is g a correspondence?
4.7 Let B be the set of all inﬁnite sequences over {0,1}. Show that B is uncountable
using a proof by diagonalization.
4.8 Let T = {(i, j, k)| i, j, k ∈N}. Show that T is countable.
4.9 Review the way that we deﬁne sets to be the same size in Deﬁnition 4.12 (page 203).
Show that “is the same size” is an equivalence relation.
PROBLEMS
A4.10 Let INFINITEDFA = {⟨A⟩| A is a DFA and L(A) is an inﬁnite language}. Show
that INFINITEDFA is decidable.
4.11 Let INFINITE PDA = {⟨M⟩| M is a PDA and L(M) is an inﬁnite language}. Show
that INFINITEPDA is decidable.
A4.12 Let A = {⟨M⟩| M is a DFA that doesn’t accept any string containing an odd num-
ber of 1s}. Show that A is decidable.
4.13 Let A = {⟨R, S⟩| R and S are regular expressions and L(R) ⊆L(S)}. Show that
A is decidable.
A4.14 Let Σ = {0,1}. Show that the problem of determining whether a CFG generates
some string in 1∗is decidable. In other words, show that
{⟨G⟩| G is a CFG over {0,1} and 1∗∩L(G) ̸= ∅}
is a decidable language.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

212
CHAPTER 4 / DECIDABILITY
⋆4.15 Show that the problem of determining whether a CFG generates all strings in 1∗is
decidable. In other words, show that {⟨G⟩| G is a CFG over {0,1} and 1∗⊆L(G)}
is a decidable language.
4.16 Let A = {⟨R⟩| R is a regular expression describing a language containing at least
one string w that has 111 as a substring (i.e., w = x111y for some x and y)}. Show
that A is decidable.
4.17 Prove that EQDFA is decidable by testing the two DFAs on all strings up to a certain
size. Calculate a size that works.
⋆4.18 Let C be a language. Prove that C is Turing-recognizable iff a decidable language
D exists such that C = {x| ∃y (⟨x, y⟩∈D)}.
⋆4.19 Prove that the class of decidable languages is not closed under homomorphism.
4.20 Let A and B be two disjoint languages. Say that language C separates A and B if
A ⊆C and B ⊆C. Show that any two disjoint co-Turing-recognizable languages
are separable by some decidable language.
4.21 Let S = {⟨M⟩| M is a DFA that accepts wR whenever it accepts w}. Show that S
is decidable.
4.22 Let PREFIX-FREEREX = {⟨R⟩| R is a regular expression and L(R) is preﬁx-free}.
Show that PREFIX-FREEREX is decidable. Why does a similar approach fail to
show that PREFIX-FREECFG is decidable?
A⋆4.23 Say that an NFA is ambiguous if it accepts some string along two different com-
putation branches. Let AMBIGNFA = {⟨N⟩| N is an ambiguous NFA}. Show that
AMBIGNFA is decidable. (Suggestion: One elegant way to solve this problem is to
construct a suitable DFA and then run EDFA on it.)
4.24 A useless state in a pushdown automaton is never entered on any input string. Con-
sider the problem of determining whether a pushdown automaton has any useless
states. Formulate this problem as a language and show that it is decidable.
A⋆4.25 Let BALDFA = {⟨M⟩| M is a DFA that accepts some string containing an equal
number of 0s and 1s}. Show that BALDFA is decidable. (Hint: Theorems about
CFLs are helpful here.)
⋆4.26 Let PALDFA = {⟨M⟩| M is a DFA that accepts some palindrome}. Show that
PALDFA is decidable. (Hint: Theorems about CFLs are helpful here.)
⋆4.27 Let E = {⟨M⟩| M is a DFA that accepts some string with more 1s than 0s}. Show
that E is decidable. (Hint: Theorems about CFLs are helpful here.)
4.28 Let C = {⟨G, x⟩| G is a CFG x is a substring of some y ∈L(G)}. Show that C is
decidable. (Hint: An elegant solution to this problem uses the decider for ECFG.)
4.29 Let CCFG = {⟨G, k⟩| G is a CFG and L(G) contains exactly k strings where k ≥0
or k = ∞}. Show that CCFG is decidable.
4.30 Let A be a Turing-recognizable language consisting of descriptions of Turing ma-
chines, {⟨M1⟩, ⟨M2⟩, . . .}, where every Mi is a decider. Prove that some decidable
language D is not decided by any decider Mi whose description appears in A.
(Hint: You may ﬁnd it helpful to consider an enumerator for A.)
4.31 Say that a variable A in CFL G is usable if it appears in some derivation of some
string w ∈G. Given a CFG G and a variable A, consider the problem of testing
whether A is usable. Formulate this problem as a language and show that it is
decidable.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

SELECTED SOLUTIONS
213
4.32 The proof of Lemma 2.41 says that (q, x) is a looping situation for a DPDA P if
when P is started in state q with x ∈Γ on the top of the stack, it never pops
anything below x and it never reads an input symbol. Show that F is decidable,
where F = {⟨P, q, x⟩| (q, x) is a looping situation for P}.
SELECTED SOLUTIONS
4.1
(a) Yes. The DFA M accepts 0100.
(b) No. M doesn’t accept 011.
(c) No. This input has only a single component and thus is not of the correct form.
(d) No. The ﬁrst component is not a regular expression and so the input is not of
the correct form.
(e) No. M’s language isn’t empty.
(f) Yes. M accepts the same language as itself.
4.5
Let s1, s2, . . . be a list of all strings in Σ∗. The following TM recognizes ETM.
“On input ⟨M⟩, where M is a TM:
1. Repeat the following for i = 1, 2, 3, . . . .
2.
Run M for i steps on each input, s1, s2, . . . , si.
3.
If M has accepted any of these, accept. Otherwise, continue.”
4.6
(a) No, f is not one-to-one because f(1) = f(3).
(d) Yes, g is one-to-one.
4.10
The following TM I decides INFINITE DFA.
I = “On input ⟨A⟩, where A is a DFA:
1.
Let k be the number of states of A.
2.
Construct a DFA D that accepts all strings of length k or more.
3.
Construct a DFA M such that L(M) = L(A) ∩L(D).
4.
Test L(M) = ∅using the EDFA decider T from Theorem 4.4.
5.
If T accepts, reject; if T rejects, accept.”
This algorithm works because a DFA that accepts inﬁnitely many strings must ac-
cept arbitrarily long strings. Therefore, this algorithm accepts such DFAs. Con-
versely, if the algorithm accepts a DFA, the DFA accepts some string of length k or
more, where k is the number of states of the DFA. This string may be pumped in
the manner of the pumping lemma for regular languages to obtain inﬁnitely many
accepted strings.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

214
CHAPTER 4 / DECIDABILITY
4.12
The following TM decides A.
“On input ⟨M⟩:
1.
Construct a DFA O that accepts every string containing an odd
number of 1s.
2.
Construct a DFA B such that L(B) = L(M) ∩L(O).
3.
Test whether L(B) = ∅using the EDFA decider T from Theo-
rem 4.4.
4.
If T accepts, accept; if T rejects, reject.”
4.14
You showed in Problem 2.18 that if C is a context-free language and R is a regular
language, then C ∩R is context free. Therefore, 1∗∩L(G) is context free. The
following TM decides the language of this problem.
“On input ⟨G⟩:
1.
Construct CFG H such that L(H) = 1∗∩L(G).
2.
Test whether L(H) = ∅using the ECFG decider R from Theo-
rem 4.8.
3.
If R accepts, reject; if R rejects, accept.”
4.23
The following procedure decides AMBIGNFA. Given an NFA N, we design a DFA
D that simulates N and accepts a string iff it is accepted by N along two different
computational branches. Then we use a decider for EDFA to determine whether D
accepts any strings.
Our strategy for constructing D is similar to the NFA-to-DFA conversion in the
proof of Theorem 1.39. We simulate N by keeping a pebble on each active state.
We begin by putting a red pebble on the start state and on each state reachable
from the start state along ε transitions. We move, add, and remove pebbles in
accordance with N’s transitions, preserving the color of the pebbles. Whenever
two or more pebbles are moved to the same state, we replace its pebbles with a
blue pebble. After reading the input, we accept if a blue pebble is on an accept
state of N or if two different accept states of N have red pebbles on them.
The DFA D has a state corresponding to each possible position of pebbles. For
each state of N, three possibilities occur: It can contain a red pebble, a blue pebble,
or no pebble. Thus, if N has n states, D will have 3n states. Its start state, accept
states, and transition function are deﬁned to carry out the simulation.
4.25
The language of all strings with an equal number of 0s and 1s is a context-free
language, generated by the grammar S →1S0S | 0S1S | ε. Let P be the PDA that
recognizes this language. Build a TM M for BALDFA, which operates as follows.
On input ⟨B⟩, where B is a DFA, use B and P to construct a new PDA R that
recognizes the intersection of the languages of B and P. Then test whether R’s
language is empty. If its language is empty, reject; otherwise, accept.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

5
R E D U C I B I L I T Y
In Chapter 4 we established the Turing machine as our model of a general pur-
pose computer. We presented several examples of problems that are solvable
on a Turing machine and gave one example of a problem, ATM, that is compu-
tationally unsolvable. In this chapter we examine several additional unsolvable
problems. In doing so, we introduce the primary method for proving that prob-
lems are computationally unsolvable. It is called reducibility.
A reduction is a way of converting one problem to another problem in such a
way that a solution to the second problem can be used to solve the ﬁrst problem.
Such reducibilities come up often in everyday life, even if we don’t usually refer
to them in this way.
For example, suppose that you want to ﬁnd your way around a new city. You
know that doing so would be easy if you had a map. Thus, you can reduce the
problem of ﬁnding your way around the city to the problem of obtaining a map
of the city.
Reducibility always involves two problems, which we call A and B. If A re-
duces to B, we can use a solution to B to solve A. So in our example, A is the
problem of ﬁnding your way around the city and B is the problem of obtaining
a map. Note that reducibility says nothing about solving A or B alone, but only
about the solvability of A in the presence of a solution to B.
The following are further examples of reducibilities. The problem of travel-
ing from Boston to Paris reduces to the problem of buying a plane ticket between
the two cities. That problem in turn reduces to the problem of earning the
money for the ticket. And that problem reduces to the problem of ﬁnding a job.
215
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

216
CHAPTER 5 / REDUCIBILITY
Reducibility also occurs in mathematical problems. For example, the problem
of measuring the area of a rectangle reduces to the problem of measuring its
length and width. The problem of solving a system of linear equations reduces
to the problem of inverting a matrix.
Reducibility plays an important role in classifying problems by decidability,
and later in complexity theory as well. When A is reducible to B, solving A
cannot be harder than solving B because a solution to B gives a solution to A. In
terms of computability theory, if A is reducible to B and B is decidable, A also is
decidable. Equivalently, if A is undecidable and reducible to B, B is undecidable.
This last version is key to proving that various problems are undecidable.
In short, our method for proving that a problem is undecidable will be to
show that some other problem already known to be undecidable reduces to it.
5.1
UNDECIDABLE PROBLEMS FROM
LANGUAGE THEORY
We have already established the undecidability of ATM, the problem of deter-
mining whether a Turing machine accepts a given input. Let’s consider a related
problem, HALT TM, the problem of determining whether a Turing machine halts
(by accepting or rejecting) on a given input. This problem is widely known as the
halting problem. We use the undecidability of ATM to prove the undecidability
of the halting problem by reducing ATM to HALT TM. Let
HALT TM = {⟨M, w⟩| M is a TM and M halts on input w}.
THEOREM
5.1
HALT TM is undecidable.
PROOF IDEA
This proof is by contradiction. We assume that HALT TM is
decidable and use that assumption to show that ATM is decidable, contradicting
Theorem 4.11. The key idea is to show that ATM is reducible to HALT TM.
Let’s assume that we have a TM R that decides HALT TM. Then we use R to
construct S, a TM that decides ATM. To get a feel for the way to construct S,
pretend that you are S. Your task is to decide ATM. You are given an input of
the form ⟨M, w⟩. You must output accept if M accepts w, and you must output
reject if M loops or rejects on w. Try simulating M on w. If it accepts or rejects,
do the same. But you may not be able to determine whether M is looping, and
in that case your simulation will not terminate. That’s bad because you are a
decider and thus never permitted to loop. So this idea by itself does not work.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

5.1
UNDECIDABLE PROBLEMS FROM LANGUAGE THEORY
217
Instead, use the assumption that you have TM R that decides HALT TM. With
R, you can test whether M halts on w. If R indicates that M doesn’t halt on w,
reject because ⟨M, w⟩isn’t in ATM. However, if R indicates that M does halt on
w, you can do the simulation without any danger of looping.
Thus, if TM R exists, we can decide ATM, but we know that ATM is unde-
cidable. By virtue of this contradiction, we can conclude that R does not exist.
Therefore, HALT TM is undecidable.
PROOF
Let’s assume for the purpose of obtaining a contradiction that TM
R decides HALT TM. We construct TM S to decide ATM, with S operating as
follows.
S = “On input ⟨M, w⟩, an encoding of a TM M and a string w:
1.
Run TM R on input ⟨M, w⟩.
2.
If R rejects, reject.
3.
If R accepts, simulate M on w until it halts.
4.
If M has accepted, accept; if M has rejected, reject.”
Clearly, if R decides HALT TM, then S decides ATM. Because ATM is unde-
cidable, HALT TM also must be undecidable.
Theorem 5.1 illustrates our strategy for proving that a problem is undecid-
able. This strategy is common to most proofs of undecidability, except for the
undecidability of ATM itself, which is proved directly via the diagonalization
method.
We now present several other theorems and their proofs as further examples
of the reducibility method for proving undecidability. Let
ETM = {⟨M⟩| M is a TM and L(M) = ∅}.
THEOREM
5.2
ETM is undecidable.
PROOF IDEA
We follow the pattern adopted in Theorem 5.1. We assume
that ETM is decidable and then show that ATM is decidable—a contradiction.
Let R be a TM that decides ETM. We use R to construct TM S that decides ATM.
How will S work when it receives input ⟨M, w⟩?
One idea is for S to run R on input ⟨M⟩and see whether it accepts. If it does,
we know that L(M) is empty and therefore that M does not accept w. But if R
rejects ⟨M⟩, all we know is that L(M) is not empty and therefore that M accepts
some string—but we still do not know whether M accepts the particular string
w. So we need to use a different idea.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

218
CHAPTER 5 / REDUCIBILITY
Instead of running R on ⟨M⟩, we run R on a modiﬁcation of ⟨M⟩. We modify
⟨M⟩to guarantee that M rejects all strings except w, but on input w it works as
usual. Then we use R to determine whether the modiﬁed machine recognizes
the empty language. The only string the machine can now accept is w, so its
language will be nonempty iff it accepts w. If R accepts when it is fed a descrip-
tion of the modiﬁed machine, we know that the modiﬁed machine doesn’t accept
anything and that M doesn’t accept w.
PROOF
Let’s write the modiﬁed machine described in the proof idea using
our standard notation. We call it M1.
M1 = “On input x:
1.
If x ̸= w, reject.
2.
If x = w, run M on input w and accept if M does.”
This machine has the string w as part of its description. It conducts the test
of whether x = w in the obvious way, by scanning the input and comparing it
character by character with w to determine whether they are the same.
Putting all this together, we assume that TM R decides ETM and construct TM
S that decides ATM as follows.
S = “On input ⟨M, w⟩, an encoding of a TM M and a string w:
1.
Use the description of M and w to construct the TM M1 just
described.
2.
Run R on input ⟨M1⟩.
3.
If R accepts, reject; if R rejects, accept.”
Note that S must actually be able to compute a description of M1 from a
description of M and w. It is able to do so because it only needs to add extra
states to M that perform the x = w test.
If R were a decider for ETM, S would be a decider for ATM. A decider for
ATM cannot exist, so we know that ETM must be undecidable.
Another interesting computational problem regarding Turing machines con-
cerns determining whether a given Turing machine recognizes a language that
also can be recognized by a simpler computational model. For example, we let
REGULARTM be the problem of determining whether a given Turing machine
has an equivalent ﬁnite automaton. This problem is the same as determining
whether the Turing machine recognizes a regular language. Let
REGULARTM = {⟨M⟩| M is a TM and L(M) is a regular language}.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

5.1
UNDECIDABLE PROBLEMS FROM LANGUAGE THEORY
219
THEOREM
5.3
REGULARTM is undecidable.
PROOF IDEA
As usual for undecidability theorems, this proof is by reduction
from ATM. We assume that REGULARTM is decidable by a TM R and use this
assumption to construct a TM S that decides ATM. Less obvious now is how to
use R’s ability to assist S in its task. Nonetheless, we can do so.
The idea is for S to take its input ⟨M, w⟩and modify M so that the result-
ing TM recognizes a regular language if and only if M accepts w. We call the
modiﬁed machine M2. We design M2 to recognize the nonregular language
{0n1n| n ≥0} if M does not accept w, and to recognize the regular language Σ∗
if M accepts w. We must specify how S can construct such an M2 from M and
w. Here, M2 works by automatically accepting all strings in {0n1n| n ≥0}. In
addition, if M accepts w, M2 accepts all other strings.
Note that the TM M2 is not constructed for the purposes of actually running it
on some input—a common confusion. We construct M2 only for the purpose of
feeding its description into the decider for REGULARTM that we have assumed
to exist. Once this decider returns its answer, we can use it to obtain the answer
to whether M accepts w. Thus, we can decide ATM, a contradiction.
PROOF
We let R be a TM that decides REGULARTM and construct TM S to
decide ATM. Then S works in the following manner.
S = “On input ⟨M, w⟩, where M is a TM and w is a string:
1.
Construct the following TM M2.
M2 = “On input x:
1. If x has the form 0n1n, accept.
2. If x does not have this form, run M on input w and
accept if M accepts w.”
2.
Run R on input ⟨M2⟩.
3.
If R accepts, accept; if R rejects, reject.”
Similarly, the problems of testing whether the language of a Turing machine
is a context-free language, a decidable language, or even a ﬁnite language can
be shown to be undecidable with similar proofs. In fact, a general result, called
Rice’s theorem, states that determining any property of the languages recognized
by Turing machines is undecidable. We give Rice’s theorem in Problem 5.28.
So far, our strategy for proving languages undecidable involves a reduction
from ATM. Sometimes reducing from some other undecidable language, such
as ETM, is more convenient when we are showing that certain languages are
undecidable. Theorem 5.4 shows that testing the equivalence of two Turing
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

220
CHAPTER 5 / REDUCIBILITY
machines is an undecidable problem. We could prove it by a reduction from
ATM, but we use this opportunity to give an example of an undecidability proof
by reduction from ETM. Let
EQTM = {⟨M1, M2⟩| M1 and M2 are TMs and L(M1) = L(M2)}.
THEOREM
5.4
EQTM is undecidable.
PROOF IDEA
Show that if EQTM were decidable, ETM also would be decid-
able by giving a reduction from ETM to EQTM. The idea is simple. ETM is the
problem of determining whether the language of a TM is empty. EQTM is the
problem of determining whether the languages of two TMs are the same. If one
of these languages happens to be ∅, we end up with the problem of determining
whether the language of the other machine is empty—that is, the ETM problem.
So in a sense, the ETM problem is a special case of the EQTM problem wherein
one of the machines is ﬁxed to recognize the empty language. This idea makes
giving the reduction easy.
PROOF
We let TM R decide EQTM and construct TM S to decide ETM as
follows.
S = “On input ⟨M⟩, where M is a TM:
1.
Run R on input ⟨M, M1⟩, where M1 is a TM that rejects all
inputs.
2.
If R accepts, accept; if R rejects, reject.”
If R decides EQTM, S decides ETM. But ETM is undecidable by Theorem 5.2,
so EQTM also must be undecidable.
REDUCTIONS VIA COMPUTATION HISTORIES
The computation history method is an important technique for proving that
ATM is reducible to certain languages. This method is often useful when the
problem to be shown undecidable involves testing for the existence of some-
thing. For example, this method is used to show the undecidability of Hilbert’s
tenth problem, testing for the existence of integral roots in a polynomial.
The computation history for a Turing machine on an input is simply the se-
quence of conﬁgurations that the machine goes through as it processes the input.
It is a complete record of the computation of this machine.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

5.1
UNDECIDABLE PROBLEMS FROM LANGUAGE THEORY
221
DEFINITION
5.5
Let M be a Turing machine and w an input string. An accepting
computation history for M on w is a sequence of conﬁgurations,
C1, C2, . . . , Cl, where C1 is the start conﬁguration of M on w, Cl is
an accepting conﬁguration of M, and each Ci legally follows from
Ci−1 according to the rules of M. A rejecting computation his-
tory for M on w is deﬁned similarly, except that Cl is a rejecting
conﬁguration.
Computation histories are ﬁnite sequences. If M doesn’t halt on w, no accept-
ing or rejecting computation history exists for M on w. Deterministic machines
have at most one computation history on any given input. Nondeterministic ma-
chines may have many computation histories on a single input, corresponding
to the various computation branches. For now, we continue to focus on deter-
ministic machines. Our ﬁrst undecidability proof using the computation history
method concerns a type of machine called a linear bounded automaton.
DEFINITION
5.6
A linear bounded automaton is a restricted type of Turing machine
wherein the tape head isn’t permitted to move off the portion of
the tape containing the input. If the machine tries to move its head
off either end of the input, the head stays where it is—in the same
way that the head will not move off the left-hand end of an ordinary
Turing machine’s tape.
A linear bounded automaton is a Turing machine with a limited amount of
memory, as shown schematically in the following ﬁgure. It can only solve prob-
lems requiring memory that can ﬁt within the tape used for the input. Using a
tape alphabet larger than the input alphabet allows the available memory to be
increased up to a constant factor. Hence we say that for an input of length n, the
amount of memory available is linear in n—thus the name of this model.
FIGURE
5.7
Schematic of a linear bounded automaton
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

222
CHAPTER 5 / REDUCIBILITY
Despite their memory constraint, linear bounded automata (LBAs) are quite
powerful. For example, the deciders for ADFA, ACFG, EDFA, and ECFG all are
LBAs. Every CFL can be decided by an LBA. In fact, coming up with a decidable
language that can’t be decided by an LBA takes some work. We develop the
techniques to do so in Chapter 9.
Here, ALBA is the problem of determining whether an LBA accepts its input.
Even though ALBA is the same as the undecidable problem ATM where the Tur-
ing machine is restricted to be an LBA, we can show that ALBA is decidable. Let
ALBA = {⟨M, w⟩| M is an LBA that accepts string w}.
Before proving the decidability of ALBA, we ﬁnd the following lemma useful.
It says that an LBA can have only a limited number of conﬁgurations when a
string of length n is the input.
LEMMA
5.8
Let M be an LBA with q states and g symbols in the tape alphabet. There are
exactly qngn distinct conﬁgurations of M for a tape of length n.
PROOF
Recall that a conﬁguration of M is like a snapshot in the middle of its
computation. A conﬁguration consists of the state of the control, position of the
head, and contents of the tape. Here, M has q states. The length of its tape is n,
so the head can be in one of n positions, and gn possible strings of tape symbols
appear on the tape. The product of these three quantities is the total number of
different conﬁgurations of M with a tape of length n.
THEOREM
5.9
ALBA is decidable.
PROOF IDEA
In order to decide whether LBA M accepts input w, we simulate
M on w. During the course of the simulation, if M halts and accepts or rejects,
we accept or reject accordingly. The difﬁculty occurs if M loops on w. We need
to be able to detect looping so that we can halt and reject.
The idea for detecting when M is looping is that as M computes on w, it
goes from conﬁguration to conﬁguration. If M ever repeats a conﬁguration,
it would go on to repeat this conﬁguration over and over again and thus be
in a loop. Because M is an LBA, the amount of tape available to it is limited.
By Lemma 5.8, M can be in only a limited number of conﬁgurations on this
amount of tape. Therefore, only a limited amount of time is available to M
before it will enter some conﬁguration that it has previously entered. Detecting
that M is looping is possible by simulating M for the number of steps given by
Lemma 5.8. If M has not halted by then, it must be looping.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

5.1
UNDECIDABLE PROBLEMS FROM LANGUAGE THEORY
223
PROOF
The algorithm that decides ALBA is as follows.
L = “On input ⟨M, w⟩, where M is an LBA and w is a string:
1.
Simulate M on w for qngn steps or until it halts.
2.
If M has halted, accept if it has accepted and reject if it has
rejected. If it has not halted, reject.”
If M on w has not halted within qngn steps, it must be repeating a conﬁgura-
tion according to Lemma 5.8 and therefore looping. That is why our algorithm
rejects in this instance.
Theorem 5.9 shows that LBAs and TMs differ in one essential way: For LBAs
the acceptance problem is decidable, but for TMs it isn’t. However, certain other
problems involving LBAs remain undecidable. One is the emptiness problem
ELBA = {⟨M⟩| M is an LBA where L(M) = ∅}. To prove that ELBA is undecid-
able, we give a reduction that uses the computation history method.
THEOREM
5.10
ELBA is undecidable.
PROOF IDEA
This proof is by reduction from ATM. We show that if ELBA
were decidable, ATM would also be. Suppose that ELBA is decidable. How can
we use this supposition to decide ATM?
For a TM M and an input w, we can determine whether M accepts w by con-
structing a certain LBA B and then testing whether L(B) is empty. The language
that B recognizes comprises all accepting computation histories for M on w. If
M accepts w, this language contains one string and so is nonempty. If M does
not accept w, this language is empty. If we can determine whether B’s language
is empty, clearly we can determine whether M accepts w.
Now we describe how to construct B from M and w. Note that we need
to show more than the mere existence of B. We have to show how a Turing
machine can obtain a description of B, given descriptions of M and w.
As in the previous reductions we’ve given for proving undecidability, we con-
struct B only to feed its description into the presumed ELBA decider, but not to
run B on some input.
We construct B to accept its input x if x is an accepting computation history
for M on w. Recall that an accepting computation history is the sequence of
conﬁgurations, C1, C2, . . . , Cl that M goes through as it accepts some string w.
For the purposes of this proof, we assume that the accepting computation history
is presented as a single string with the conﬁgurations separated from each other
by the # symbol, as shown in Figure 5.11.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

224
CHAPTER 5 / REDUCIBILITY
# |
{z
}
C1
# |
{z
}
C2
# |
{z
}
C3
#
· · ·
# |
{z
}
Cl
#
FIGURE
5.11
A possible input to B
The LBA B works as follows. When it receives an input x, B is supposed to
accept if x is an accepting computation history for M on w. First, B breaks up
x according to the delimiters into strings C1, C2, . . . , Cl. Then B determines
whether the Ci’s satisfy the three conditions of an accepting computation history.
1. C1 is the start conﬁguration for M on w.
2. Each Ci+1 legally follows from Ci.
3. Cl is an accepting conﬁguration for M.
The start conﬁguration C1 for M on w is the string q0w1w2 · · · wn, where
q0 is the start state for M on w. Here, B has this string directly built in, so
it is able to check the ﬁrst condition. An accepting conﬁguration is one that
contains the qaccept state, so B can check the third condition by scanning Cl for
qaccept. The second condition is the hardest to check. For each pair of adjacent
conﬁgurations, B checks on whether Ci+1 legally follows from Ci. This step
involves verifying that Ci and Ci+1 are identical except for the positions under
and adjacent to the head in Ci. These positions must be updated according to the
transition function of M. Then B veriﬁes that the updating was done properly
by zig-zagging between corresponding positions of Ci and Ci+1. To keep track
of the current positions while zig-zagging, B marks the current position with
dots on the tape. Finally, if conditions 1, 2, and 3 are satisﬁed, B accepts its
input.
By inverting the decider’s answer, we obtain the answer to whether M accepts
w. Thus we can decide ATM, a contradiction.
PROOF
Now we are ready to state the reduction of ATM to ELBA. Suppose
that TM R decides ELBA. Construct TM S to decide ATM as follows.
S = “On input ⟨M, w⟩, where M is a TM and w is a string:
1.
Construct LBA B from M and w as described in the proof idea.
2.
Run R on input ⟨B⟩.
3.
If R rejects, accept; if R accepts, reject.”
If R accepts ⟨B⟩, then L(B) = ∅. Thus, M has no accepting computation
history on w and M doesn’t accept w. Consequently, S rejects ⟨M, w⟩. Similarly,
if R rejects ⟨B⟩, the language of B is nonempty. The only string that B can
accept is an accepting computation history for M on w. Thus, M must accept w.
Consequently, S accepts ⟨M, w⟩. Figure 5.12 illustrates LBA B.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

5.1
UNDECIDABLE PROBLEMS FROM LANGUAGE THEORY
225
FIGURE
5.12
LBA B checking a TM computation history
We can also use the technique of reduction via computation histories to es-
tablish the undecidability of certain problems related to context-free grammars
and pushdown automata. Recall that in Theorem 4.8 we presented an algo-
rithm to decide whether a context-free grammar generates any strings—that is,
whether L(G) = ∅. Now we show that a related problem is undecidable. It is the
problem of determining whether a context-free grammar generates all possible
strings. Proving that this problem is undecidable is the main step in showing
that the equivalence problem for context-free grammars is undecidable. Let
ALLCFG = {⟨G⟩| G is a CFG and L(G) = Σ∗}.
THEOREM
5.13
ALLCFG is undecidable.
PROOF
This proof is by contradiction. To get the contradiction, we assume
that ALLCFG is decidable and use this assumption to show that ATM is decidable.
This proof is similar to that of Theorem 5.10 but with a small extra twist: It is a
reduction from ATM via computation histories, but we modify the representation
of the computation histories slightly for a technical reason that we will explain
later.
We now describe how to use a decision procedure for ALLCFG to decide ATM.
For a TM M and an input w, we construct a CFG G that generates all strings if
and only if M does not accept w. So if M does accept w, G does not generate
some particular string. This string is—guess what—the accepting computation
history for M on w. That is, G is designed to generate all strings that are not
accepting computation histories for M on w.
To make the CFG G generate all strings that fail to be an accepting computa-
tion history for M on w, we utilize the following strategy. A string may fail to be
an accepting computation history for several reasons. An accepting computation
history for M on w appears as #C1#C2# · · · #Cl#, where Ci is the conﬁguration
of M on the ith step of the computation on w. Then, G generates all strings
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

226
CHAPTER 5 / REDUCIBILITY
1. that do not start with C1,
2. that do not end with an accepting conﬁguration, or
3. in which some Ci does not properly yield Ci+1 under the rules of M.
If M does not accept w, no accepting computation history exists, so all strings
fail in one way or another. Therefore, G would generate all strings, as desired.
Now we get down to the actual construction of G. Instead of constructing
G, we construct a PDA D. We know that we can use the construction given in
Theorem 2.20 (page 117) to convert D to a CFG. We do so because, for our
purposes, designing a PDA is easier than designing a CFG. In this instance, D will
start by nondeterministically branching to guess which of the preceding three
conditions to check. One branch checks on whether the beginning of the input
string is C1 and accepts if it isn’t. Another branch checks on whether the input
string ends with a conﬁguration containing the accept state, qaccept, and accepts
if it isn’t.
The third branch is supposed to accept if some Ci does not properly yield
Ci+1. It works by scanning the input until it nondeterministically decides that
it has come to Ci. Next, it pushes Ci onto the stack until it comes to the end as
marked by the # symbol. Then D pops the stack to compare with Ci+1. They
are supposed to match except around the head position, where the difference
is dictated by the transition function of M. Finally, D accepts if it discovers a
mismatch or an improper update.
The problem with this idea is that when D pops Ci off the stack, it is in
reverse order and not suitable for comparison with Ci+1. At this point, the twist
in the proof appears: We write the accepting computation history differently.
Every other conﬁguration appears in reverse order. The odd positions remain
written in the forward order, but the even positions are written backward. Thus,
an accepting computation history would appear as shown in the following ﬁgure.
#
−→
|
{z
}
C1
#
←−
|
{z
}
CR
2
#
−→
|
{z
}
C3
#
←−
|
{z
}
CR
4
#
· · ·
# |
{z
}
Cl
#
FIGURE
5.14
Every other conﬁguration written in reverse order
In this modiﬁed form, the PDA is able to push a conﬁguration so that when it
is popped, the order is suitable for comparison with the next one. We design D
to accept any string that is not an accepting computation history in the modiﬁed
form.
In Exercise 5.1 you can use Theorem 5.13 to show that EQCFG is undecidable.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

5.2
A SIMPLE UNDECIDABLE PROBLEM
227
5.2
A SIMPLE UNDECIDABLE PROBLEM
In this section we show that the phenomenon of undecidability is not conﬁned to
problems concerning automata. We give an example of an undecidable problem
concerning simple manipulations of strings. It is called the Post Correspondence
Problem, or PCP.
We can describe this problem easily as a type of puzzle. We begin with a col-
lection of dominos, each containing two strings, one on each side. An individual
domino looks like
h a
ab
i
and a collection of dominos looks like
h b
ca
i
,
h a
ab
i
,
hca
a
i
,
habc
c
i
.
The task is to make a list of these dominos (repetitions permitted) so that the
string we get by reading off the symbols on the top is the same as the string of
symbols on the bottom. This list is called a match. For example, the following
list is a match for this puzzle.
h a
ab
ih b
ca
ihca
a
ih a
ab
ihabc
c
i
Reading off the top string we get abcaaabc, which is the same as reading off the
bottom. We can also depict this match by deforming the dominos so that the
corresponding symbols from top and bottom line up.
For some collections of dominos, ﬁnding a match may not be possible. For
example, the collection
habc
ab
i
,
hca
a
i
,
hacc
ba
i
cannot contain a match because every top string is longer than the corresponding
bottom string.
The Post Correspondence Problem is to determine whether a collection of
dominos has a match. This problem is unsolvable by algorithms.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

228
CHAPTER 5 / REDUCIBILITY
Before getting to the formal statement of this theorem and its proof, let’s state
the problem precisely and then express it as a language. An instance of the PCP
is a collection P of dominos
P =
h t1
b1
i
,
h t2
b2
i
, . . . ,
h tk
bk
i
,
and a match is a sequence i1, i2, . . . , il, where ti1ti2 · · · til = bi1bi2 · · · bil. The
problem is to determine whether P has a match. Let
PCP = {⟨P⟩| P is an instance of the Post Correspondence Problem
with a match}.
THEOREM
5.15
PCP is undecidable.
PROOF IDEA
Conceptually this proof is simple, though it involves many de-
tails. The main technique is reduction from ATM via accepting computation
histories. We show that from any TM M and input w, we can construct an in-
stance P where a match is an accepting computation history for M on w. If we
could determine whether the instance has a match, we would be able to deter-
mine whether M accepts w.
How can we construct P so that a match is an accepting computation history
for M on w? We choose the dominos in P so that making a match forces a
simulation of M to occur. In the match, each domino links a position or positions
in one conﬁguration with the corresponding one(s) in the next conﬁguration.
Before getting to the construction, we handle three small technical points.
(Don’t worry about them too much on your initial reading through this con-
struction.) First, for convenience in constructing P, we assume that M on w
never attempts to move its head off the left-hand end of the tape. That requires
ﬁrst altering M to prevent this behavior. Second, if w = ε, we use the string ␣
in place of w in the construction. Third, we modify the PCP to require that a
match starts with the ﬁrst domino,
h t1
b1
i
.
Later we show how to eliminate this requirement. We call this problem the
Modiﬁed Post Correspondence Problem (MPCP). Let
MPCP = {⟨P⟩| P is an instance of the Post Correspondence Problem
with a match that starts with the ﬁrst domino}.
Now let’s move into the details of the proof and design P to simulate M on w.
PROOF
We let TM R decide the PCP and construct S deciding ATM. Let
M = (Q, Σ, Γ, δ, q0, qaccept, qreject),
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

5.2
A SIMPLE UNDECIDABLE PROBLEM
229
where Q, Σ, Γ, and δ are the state set, input alphabet, tape alphabet, and transi-
tion function of M, respectively.
In this case, S constructs an instance of the PCP P that has a match iff M
accepts w. To do that, S ﬁrst constructs an instance P ′ of the MPCP. We de-
scribe the construction in seven parts, each of which accomplishes a particular
aspect of simulating M on w. To explain what we are doing, we interleave the
construction with an example of the construction in action.
Part 1.
The construction begins in the following manner.
Put
h#
#q0w1w2 · · · wn#
i
into P ′ as the ﬁrst domino
h t1
b1
i
.
Because P ′ is an instance of the MPCP, the match must begin with this domino.
Thus, the bottom string begins correctly with C1 = q0w1w2 · · · wn, the ﬁrst
conﬁguration in the accepting computation history for M on w, as shown in the
following ﬁgure.
FIGURE
5.16
Beginning of the MPCP match
In this depiction of the partial match achieved so far, the bottom string con-
sists of #q0w1w2 · · · wn# and the top string consists only of #. To get a match, we
need to extend the top string to match the bottom string. We provide additional
dominos to allow this extension. The additional dominos cause M’s next conﬁg-
uration to appear at the extension of the bottom string by forcing a single-step
simulation of M.
In parts 2, 3, and 4, we add to P ′ dominos that perform the main part of
the simulation. Part 2 handles head motions to the right, part 3 handles head
motions to the left, and part 4 handles the tape cells not adjacent to the head.
Part 2.
For every a, b ∈Γ and every q, r ∈Q where q ̸= qreject,
if δ(q, a) = (r, b, R), put
hqa
br
i
into P ′.
Part 3.
For every a, b, c ∈Γ and every q, r ∈Q where q ̸= qreject,
if δ(q, a) = (r, b, L), put
hcqa
rcb
i
into P ′.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

230
CHAPTER 5 / REDUCIBILITY
Part 4.
For every a ∈Γ,
put
ha
a
i
into P ′.
Now we make up a hypothetical example to illustrate what we have built so
far. Let Γ = {0, 1, 2, ␣}. Say that w is the string 0100 and that the start state
of M is q0. In state q0, upon reading a 0, let’s say that the transition function
dictates that M enters state q7, writes a 2 on the tape, and moves its head to the
right. In other words, δ(q0, 0) = (q7, 2, R).
Part 1 places the domino
h#
#q00100#
i
=
h t1
b1
i
in P ′, and the match begins
In addition, part 2 places the domino
hq00
2q7
i
as δ(q0, 0) = (q7, 2, R) and part 4 places the dominos
h0
0
i
,
h1
1
i
,
h2
2
i
, and
h␣
␣
i
in P ′, as 0, 1, 2, and ␣are the members of Γ. Together with part 5, that allows
us to extend the match to
Thus, the dominos of parts 2, 3, and 4 let us extend the match by adding
the second conﬁguration after the ﬁrst one. We want this process to continue,
adding the third conﬁguration, then the fourth, and so on. For it to happen, we
need to add one more domino for copying the # symbol.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

5.2
A SIMPLE UNDECIDABLE PROBLEM
231
Part 5.
Put
h#
#
i
and
h #
␣#
i
into P ′.
The ﬁrst of these dominos allows us to copy the # symbol that marks the sep-
aration of the conﬁgurations. In addition to that, the second domino allows us
to add a blank symbol ␣at the end of the conﬁguration to simulate the inﬁnitely
many blanks to the right that are suppressed when we write the conﬁguration.
Continuing with the example, let’s say that in state q7, upon reading a 1, M
goes to state q5, writes a 0, and moves the head to the right. That is, δ(q7, 1) =
(q5, 0, R). Then we have the domino
hq71
0q5
i
in P ′.
So the latest partial match extends to
Then, suppose that in state q5, upon reading a 0, M goes to state q9, writes
a 2, and moves its head to the left. So δ(q5, 0) = (q9, 2, L). Then we have the
dominos
h0q50
q902
i
,
h1q50
q912
i
,
h2q50
q922
i
, and
h␣q50
q9␣2
i
.
The ﬁrst one is relevant because the symbol to the left of the head is a 0. The
preceding partial match extends to
Note that as we construct a match, we are forced to simulate M on input w.
This process continues until M reaches a halting state. If the accept state occurs,
we want to let the top of the partial match “catch up” with the bottom so that
the match is complete. We can arrange for that to happen by adding additional
dominos.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

232
CHAPTER 5 / REDUCIBILITY
Part 6.
For every a ∈Γ,
put
ha qaccept
qaccept
i
and
hqaccept a
qaccept
i
into P ′.
This step has the effect of adding “pseudo-steps” of the Turing machine after
it has halted, where the head “eats” adjacent symbols until none are left. Con-
tinuing with the example, if the partial match up to the point when the machine
halts in the accept state is
The dominos we have just added allow the match to continue:
Part 7.
Finally, we add the domino
hqaccept##
#
i
and complete the match:
That concludes the construction of P ′. Recall that P ′ is an instance of the
MPCP whereby the match simulates the computation of M on w. To ﬁnish
the proof, we recall that the MPCP differs from the PCP in that the match is
required to start with the ﬁrst domino in the list. If we view P ′ as an instance of
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

5.2
A SIMPLE UNDECIDABLE PROBLEM
233
the PCP instead of the MPCP, it obviously has a match, regardless of whether
M accepts w. Can you ﬁnd it? (Hint: It is very short.)
We now show how to convert P ′ to P, an instance of the PCP that still sim-
ulates M on w. We do so with a somewhat technical trick. The idea is to take
the requirement that the match starts with the ﬁrst domino and build it directly
into the problem instance itself so that it becomes enforced automatically. After
that, the requirement isn’t needed. We introduce some notation to implement
this idea.
Let u = u1u2 · · · un be any string of length n. Deﬁne ⋆u, u⋆, and ⋆u⋆to be
the three strings
⋆u
=
∗u1 ∗u2 ∗u3 ∗
· · ·
∗un
u⋆
=
u1 ∗u2 ∗u3 ∗
· · ·
∗un ∗
⋆u⋆
=
∗u1 ∗u2 ∗u3 ∗
· · ·
∗un ∗.
Here, ⋆u adds the symbol ∗before every character in u, u⋆adds one after each
character in u, and ⋆u⋆adds one both before and after each character in u.
To convert P ′ to P, an instance of the PCP, we do the following. If P ′ were
the collection
h t1
b1
i
,
h t2
b2
i
,
h t3
b3
i
, . . . ,
htk
bk
i
,
we let P be the collection
h ⋆t1
⋆b1⋆
i
,
h ⋆t1
b1⋆
i
,
h ⋆t2
b2⋆
i
,
h ⋆t3
b3⋆
i
, . . . ,
h ⋆tk
bk⋆
i
,
h∗3
3
i
.
Considering P as an instance of the PCP, we see that the only domino that
could possibly start a match is the ﬁrst one,
h ⋆t1
⋆b1⋆
i
,
because it is the only one where both the top and the bottom start with the same
symbol—namely, ∗. Besides forcing the match to start with the ﬁrst domino, the
presence of the ∗s doesn’t affect possible matches because they simply interleave
with the original symbols. The original symbols now occur in the even positions
of the match. The domino
h∗3
3
i
is there to allow the top to add the extra ∗at the end of the match.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

234
CHAPTER 5 / REDUCIBILITY
5.3
MAPPING REDUCIBILITY
We have shown how to use the reducibility technique to prove that various prob-
lems are undecidable. In this section we formalize the notion of reducibility.
Doing so allows us to use reducibility in more reﬁned ways, such as for prov-
ing that certain languages are not Turing-recognizable and for applications in
complexity theory.
The notion of reducing one problem to another may be deﬁned formally in
one of several ways. The choice of which one to use depends on the application.
Our choice is a simple type of reducibility called mapping reducibility.1
Roughly speaking, being able to reduce problem A to problem B by using
a mapping reducibility means that a computable function exists that converts
instances of problem A to instances of problem B. If we have such a conversion
function, called a reduction, we can solve A with a solver for B. The reason is
that any instance of A can be solved by ﬁrst using the reduction to convert it
to an instance of B and then applying the solver for B. A precise deﬁnition of
mapping reducibility follows shortly.
COMPUTABLE FUNCTIONS
A Turing machine computes a function by starting with the input to the function
on the tape and halting with the output of the function on the tape.
DEFINITION
5.17
A function f : Σ∗−→Σ∗is a computable function if some Turing
machine M, on every input w, halts with just f(w) on its tape.
EXAMPLE
5.18
All usual, arithmetic operations on integers are computable functions. For ex-
ample, we can make a machine that takes input ⟨m, n⟩and returns m + n, the
sum of m and n. We don’t give any details here, leaving them as exercises.
EXAMPLE
5.19
Computable functions may be transformations of machine descriptions. For
example, one computable function f takes input w and returns the description
of a Turing machine ⟨M ′⟩if w = ⟨M⟩is an encoding of a Turing machine M.
1It is called many–one reducibility in some other textbooks.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

5.3
MAPPING REDUCIBILITY
235
The machine M ′ is a machine that recognizes the same language as M, but
never attempts to move its head off the left-hand end of its tape. The function
f accomplishes this task by adding several states to the description of M. The
function returns ε if w is not a legal encoding of a Turing machine.
FORMAL DEFINITION OF MAPPING REDUCIBILITY
Now we deﬁne mapping reducibility.
As usual, we represent computational
problems by languages.
DEFINITION
5.20
Language A is mapping reducible to language B, written A ≤m B,
if there is a computable function f : Σ∗−→Σ∗, where for every w,
w ∈A ⇐⇒f(w) ∈B.
The function f is called the reduction from A to B.
The following ﬁgure illustrates mapping reducibility.
FIGURE
5.21
Function f reducing A to B
A mapping reduction of A to B provides a way to convert questions about
membership testing in A to membership testing in B. To test whether w ∈A,
we use the reduction f to map w to f(w) and test whether f(w) ∈B. The term
mapping reduction comes from the function or mapping that provides the means
of doing the reduction.
If one problem is mapping reducible to a second, previously solved problem,
we can thereby obtain a solution to the original problem. We capture this idea
in Theorem 5.22.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

236
CHAPTER 5 / REDUCIBILITY
THEOREM
5.22
If A ≤m B and B is decidable, then A is decidable.
PROOF
We let M be the decider for B and f be the reduction from A to B.
We describe a decider N for A as follows.
N = “On input w:
1.
Compute f(w).
2.
Run M on input f(w) and output whatever M outputs.”
Clearly, if w ∈A, then f(w) ∈B because f is a reduction from A to B. Thus,
M accepts f(w) whenever w ∈A. Therefore, N works as desired.
The following corollary of Theorem 5.22 has been our main tool for proving
undecidability.
COROLLARY
5.23
If A ≤m B and A is undecidable, then B is undecidable.
Now we revisit some of our earlier proofs that used the reducibility method
to get examples of mapping reducibilities.
EXAMPLE
5.24
In Theorem 5.1 we used a reduction from ATM to prove that HALT TM is un-
decidable. This reduction showed how a decider for HALT TM could be used to
give a decider for ATM. We can demonstrate a mapping reducibility from ATM
to HALT TM as follows. To do so, we must present a computable function f that
takes input of the form ⟨M, w⟩and returns output of the form ⟨M ′, w′⟩, where
⟨M, w⟩∈ATM if and only if ⟨M ′, w′⟩∈HALT TM.
The following machine F computes a reduction f.
F = “On input ⟨M, w⟩:
1.
Construct the following machine M ′.
M ′ = “On input x:
1. Run M on x.
2. If M accepts, accept.
3. If M rejects, enter a loop.”
2.
Output ⟨M ′, w⟩.”
A minor issue arises here concerning improperly formed input strings. If TM F
determines that its input is not of the correct form as speciﬁed in the input line
“On input ⟨M, w⟩:” and hence that the input is not in ATM, the TM outputs a
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

5.3
MAPPING REDUCIBILITY
237
string not in HALT TM. Any string not in HALT TM will do. In general, when we
describe a Turing machine that computes a reduction from A to B, improperly
formed inputs are assumed to map to strings outside of B.
EXAMPLE
5.25
The proof of the undecidability of the Post Correspondence Problem in Theo-
rem 5.15 contains two mapping reductions. First, it shows that ATM ≤m MPCP
and then it shows that MPCP ≤m PCP.
In both cases, we can easily ob-
tain the actual reduction function and show that it is a mapping reduction. As
Exercise 5.6 shows, mapping reducibility is transitive, so these two reductions
together imply that ATM ≤m PCP.
EXAMPLE
5.26
A mapping reduction from ETM to EQTM lies in the proof of Theorem 5.4. In
this case, the reduction f maps the input ⟨M⟩to the output ⟨M, M1⟩, where M1
is the machine that rejects all inputs.
EXAMPLE
5.27
The proof of Theorem 5.2 showing that ETM is undecidable illustrates the dif-
ference between the formal notion of mapping reducibility that we have deﬁned
in this section and the informal notion of reducibility that we used earlier in this
chapter. The proof shows that ETM is undecidable by reducing ATM to it. Let’s
see whether we can convert this reduction to a mapping reduction.
From the original reduction, we may easily construct a function f that takes
input ⟨M, w⟩and produces output ⟨M1⟩, where M1 is the Turing machine de-
scribed in that proof. But M accepts w iff L(M1) is not empty so f is a mapping
reduction from ATM to ETM. It still shows that ETM is undecidable because
decidability is not affected by complementation, but it doesn’t give a mapping
reduction from ATM to ETM. In fact, no such reduction exists, as you are asked
to show in Exercise 5.5.
The sensitivity of mapping reducibility to complementation is important
in the use of reducibility to prove nonrecognizability of certain languages.
We can also use mapping reducibility to show that problems are not Turing-
recognizable. The following theorem is analogous to Theorem 5.22.
THEOREM
5.28
If A ≤m B and B is Turing-recognizable, then A is Turing-recognizable.
The proof is the same as that of Theorem 5.22, except that M and N are recog-
nizers instead of deciders.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

238
CHAPTER 5 / REDUCIBILITY
COROLLARY
5.29
If A ≤m B and A is not Turing-recognizable, then B is not Turing-recognizable.
In a typical application of this corollary, we let A be ATM, the complement
of ATM. We know that ATM is not Turing-recognizable from Corollary 4.23.
The deﬁnition of mapping reducibility implies that A ≤m B means the same
as A ≤m B. To prove that B isn’t recognizable, we may show that ATM ≤m B.
We can also use mapping reducibility to show that certain problems are neither
Turing-recognizable nor co-Turing-recognizable, as in the following theorem.
THEOREM
5.30
EQTM is neither Turing-recognizable nor co-Turing-recognizable.
PROOF
First we show that EQTM is not Turing-recognizable. We do so by
showing that ATM is reducible to EQTM. The reducing function f works as
follows.
F = “On input ⟨M, w⟩, where M is a TM and w a string:
1.
Construct the following two machines, M1 and M2.
M1 = “On any input:
1. Reject.”
M2 = “On any input:
1. Run M on w. If it accepts, accept.”
2.
Output ⟨M1, M2⟩.”
Here, M1 accepts nothing. If M accepts w, M2 accepts everything, and so the
two machines are not equivalent. Conversely, if M doesn’t accept w, M2 accepts
nothing, and they are equivalent. Thus f reduces ATM to EQTM, as desired.
To show that EQTM is not Turing-recognizable, we give a reduction from
ATM to the complement of EQTM—namely, EQTM.
Hence we show that
ATM ≤m EQTM. The following TM G computes the reducing function g.
G = “On input ⟨M, w⟩, where M is a TM and w a string:
1.
Construct the following two machines, M1 and M2.
M1 = “On any input:
1. Accept.”
M2 = “On any input:
1. Run M on w.
2. If it accepts, accept.”
2.
Output ⟨M1, M2⟩.”
The only difference between f and g is in machine M1. In f, machine M1
always rejects, whereas in g it always accepts. In both f and g, M accepts w iff
M2 always accepts. In g, M accepts w iff M1 and M2 are equivalent. That is why
g is a reduction from ATM to EQTM.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

EXERCISES
239
EXERCISES
5.1 Show that EQCFG is undecidable.
5.2 Show that EQCFG is co-Turing-recognizable.
5.3 Find a match in the following instance of the Post Correspondence Problem.
h ab
abab
i
,
hb
a
i
,
haba
b
i
,
haa
a
i
5.4 If A ≤m B and B is a regular language, does that imply that A is a regular lan-
guage? Why or why not?
A5.5 Show that ATM is not mapping reducible to ETM. In other words, show that no
computable function reduces ATM to ETM. (Hint: Use a proof by contradiction,
and facts you already know about ATM and ETM.)
A5.6 Show that ≤m is a transitive relation.
A5.7 Show that if A is Turing-recognizable and A ≤m A, then A is decidable.
A5.8 In the proof of Theorem 5.15, we modiﬁed the Turing machine M so that it never
tries to move its head off the left-hand end of the tape. Suppose that we did not
make this modiﬁcation to M. Modify the PCP construction to handle this case.
PROBLEMS
5.9 Let T = {⟨M⟩| M is a TM that accepts wR whenever it accepts w}. Show that T
is undecidable.
A5.10 Consider the problem of determining whether a two-tape Turing machine ever
writes a nonblank symbol on its second tape when it is run on input w. Formulate
this problem as a language and show that it is undecidable.
A5.11 Consider the problem of determining whether a two-tape Turing machine ever
writes a nonblank symbol on its second tape during the course of its computation
on any input string. Formulate this problem as a language and show that it is
undecidable.
5.12 Consider the problem of determining whether a single-tape Turing machine ever
writes a blank symbol over a nonblank symbol during the course of its computation
on any input string. Formulate this problem as a language and show that it is
undecidable.
5.13 A useless state in a Turing machine is one that is never entered on any input string.
Consider the problem of determining whether a Turing machine has any useless
states. Formulate this problem as a language and show that it is undecidable.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

240
CHAPTER 5 / REDUCIBILITY
5.14 Consider the problem of determining whether a Turing machine M on an input
w ever attempts to move its head left when its head is on the left-most tape cell.
Formulate this problem as a language and show that it is undecidable.
5.15 Consider the problem of determining whether a Turing machine M on an input
w ever attempts to move its head left at any point during its computation on w.
Formulate this problem as a language and show that it is decidable.
5.16 Let Γ = {0, 1, ␣} be the tape alphabet for all TMs in this problem. Deﬁne the busy
beaver function BB: N −→N as follows. For each value of k, consider all k-state
TMs that halt when started with a blank tape. Let BB(k) be the maximum number
of 1s that remain on the tape among all of these machines. Show that BB is not a
computable function.
5.17 Show that the Post Correspondence Problem is decidable over the unary alphabet
Σ = {1}.
5.18 Show that the Post Correspondence Problem is undecidable over the binary alpha-
bet Σ = {0,1}.
5.19 In the silly Post Correspondence Problem, SPCP, the top string in each pair has the
same length as the bottom string. Show that the SPCP is decidable.
5.20 Prove that there exists an undecidable subset of {1}∗.
5.21 Let AMBIGCFG = {⟨G⟩| G is an ambiguous CFG}. Show that AMBIGCFG is unde-
cidable. (Hint: Use a reduction from PCP. Given an instance
P =
h t1
b1
i
,
h t2
b2
i
, . . . ,
h tk
bk
i
of the Post Correspondence Problem, construct a CFG G with the rules
S →T | B
T →t1T a1 | · · · | tkT ak | t1a1 | · · · | tkak
B →b1Ba1 | · · · | bkBak | b1a1 | · · · | bkak ,
where a1, . . . , ak are new terminal symbols. Prove that this reduction works.)
5.22 Show that A is Turing-recognizable iff A ≤m ATM.
5.23 Show that A is decidable iff A ≤m 0∗1∗.
5.24 Let J = {w| either w = 0x for some x ∈ATM, or w = 1y for some y ∈ATM }.
Show that neither J nor J is Turing-recognizable.
5.25 Give an example of an undecidable language B, where B ≤m B.
5.26 Deﬁne a two-headed ﬁnite automaton (2DFA) to be a deterministic ﬁnite automa-
ton that has two read-only, bidirectional heads that start at the left-hand end of the
input tape and can be independently controlled to move in either direction. The
tape of a 2DFA is ﬁnite and is just large enough to contain the input plus two ad-
ditional blank tape cells, one on the left-hand end and one on the right-hand end,
that serve as delimiters. A 2DFA accepts its input by entering a special accept state.
For example, a 2DFA can recognize the language {anbncn| n ≥0}.
a. Let A2DFA = {⟨M, x⟩| M is a 2DFA and M accepts x}. Show that A2DFA is
decidable.
b. Let E2DFA = {⟨M⟩| M is a 2DFA and L(M) = ∅}. Show that E2DFA is not
decidable.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
241
5.27 A two-dimensional ﬁnite automaton (2DIM-DFA) is deﬁned as follows. The input
is an m × n rectangle, for any m, n ≥2. The squares along the boundary of the
rectangle contain the symbol # and the internal squares contain symbols over the
input alphabet Σ. The transition function δ: Q × (Σ ∪{#})−→Q × {L, R, U, D}
indicates the next state and the new head position (Left, Right, Up, Down). The
machine accepts when it enters one of the designated accept states. It rejects if it
tries to move off the input rectangle or if it never halts. Two such machines are
equivalent if they accept the same rectangles. Consider the problem of determin-
ing whether two of these machines are equivalent. Formulate this problem as a
language and show that it is undecidable.
A⋆5.28 Rice’s theorem. Let P be any nontrivial property of the language of a Turing
machine. Prove that the problem of determining whether a given Turing machine’s
language has property P is undecidable.
In more formal terms, let P be a language consisting of Turing machine descrip-
tions where P fulﬁlls two conditions. First, P is nontrivial—it contains some, but
not all, TM descriptions. Second, P is a property of the TM’s language—whenever
L(M1) = L(M2), we have ⟨M1⟩∈P iff ⟨M2⟩∈P. Here, M1 and M2 are any
TMs. Prove that P is an undecidable language.
5.29 Show that both conditions in Problem 5.28 are necessary for proving that P is
undecidable.
5.30 Use Rice’s theorem, which appears in Problem 5.28, to prove the undecidability of
each of the following languages.
Aa. INFINITETM = {⟨M⟩| M is a TM and L(M) is an inﬁnite language}.
b. {⟨M⟩| M is a TM and 1011 ∈L(M)}.
c. ALLTM = {⟨M⟩| M is a TM and L(M) = Σ∗}.
5.31 Let
f(x) =
(
3x + 1
for odd x
x/2
for even x
for any natural number x. If you start with an integer x and iterate f, you obtain a
sequence, x, f(x), f(f(x)), . . . . Stop if you ever hit 1. For example, if x = 17, you
get the sequence 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1. Extensive computer
tests have shown that every starting point between 1 and a large positive integer
gives a sequence that ends in 1. But the question of whether all positive starting
points end up at 1 is unsolved; it is called the 3x + 1 problem.
Suppose that ATM were decidable by a TM H. Use H to describe a TM that is
guaranteed to state the answer to the 3x + 1 problem.
5.32 Prove that the following two languages are undecidable.
a. OVERLAPCFG = {⟨G, H⟩| G and H are CFGs where L(G) ∩L(H) ̸= ∅}.
(Hint: Adapt the hint in Problem 5.21.)
b. PREFIX-FREECFG = {⟨G⟩| G is a CFG where L(G) is preﬁx-free}.
5.33 Consider the problem of determining whether a PDA accepts some string of the
form {ww| w ∈{0,1}∗} . Use the computation history method to show that this
problem is undecidable.
5.34 Let X = {⟨M, w⟩| M is a single-tape TM that never modiﬁes the portion of the
tape that contains the input w}. Is X decidable? Prove your answer.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

242
CHAPTER 5 / REDUCIBILITY
5.35 Say that a variable A in CFG G is necessary if it appears in every derivation of some
string w ∈G. Let NECESSARY CFG = {⟨G, A⟩| A is a necessary variable in G}.
a. Show that NECESSARY CFG is Turing-recognizable.
b. Show that NECESSARY CFG is undecidable.
⋆5.36 Say that a CFG is minimal if none of its rules can be removed without changing the
language generated. Let MIN CFG = {⟨G⟩| G is a minimal CFG}.
a. Show that MIN CFG is T-recognizable.
b. Show that MIN CFG is undecidable.
SELECTED SOLUTIONS
5.5
Suppose for a contradiction that ATM ≤m ETM via reduction f. It follows from
the deﬁnition of mapping reducibility that ATM ≤m ETM via the same reduction
function f. However, ETM is Turing-recognizable (see the solution to Exercise 4.5)
and ATM is not Turing-recognizable, contradicting Theorem 5.28.
5.6
Suppose A ≤m B and B ≤m C. Then there are computable functions f and
g such that x ∈A ⇐⇒f(x) ∈B and y ∈B ⇐⇒g(y) ∈C. Consider the
composition function h(x) = g(f(x)). We can build a TM that computes h as
follows: First, simulate a TM for f (such a TM exists because we assumed that f
is computable) on input x and call the output y. Then simulate a TM for g on y.
The output is h(x) = g(f(x)). Therefore, h is a computable function. Moreover,
x ∈A ⇐⇒h(x) ∈C. Hence A ≤m C via the reduction function h.
5.7
Suppose that A ≤m A. Then A ≤m A via the same mapping reduction. Because A
is Turing-recognizable, Theorem 5.28 implies that A is Turing-recognizable, and
then Theorem 4.22 implies that A is decidable.
5.8
You need to handle the case where the head is at the leftmost tape cell and attempts
to move left. To do so, add dominos
h#qa
#rb
i
for every q, r ∈Q and a, b ∈Γ, where δ(q, a) = (r, b, L). Additionally, replace the
ﬁrst domino with
h#
##q0w1w2 · · · wn
i
to handle the case where the head attempts to move left in the very ﬁrst move.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

SELECTED SOLUTIONS
243
5.10
Let B = {⟨M, w⟩| M is a two-tape TM that writes a nonblank symbol on its second
tape when it is run on w}. Show that ATM reduces to B. Assume for the sake of
contradiction that TM R decides B. Then construct a TM S that uses R to decide
ATM.
S = “On input ⟨M, w⟩:
1.
Use M to construct the following two-tape TM T .
T = “On input x:
1. Simulate M on x using the ﬁrst tape.
2. If the simulation shows that M accepts, write a non-
blank symbol on the second tape.”
2.
Run R on ⟨T, w⟩to determine whether T on input w writes a
nonblank symbol on its second tape.
3.
If R accepts, M accepts w, so accept. Otherwise, reject.”
5.11
Let C = {⟨M⟩| M is a two-tape TM that writes a nonblank symbol on its second
tape when it is run on some input}. Show that ATM reduces to C. Assume for the
sake of contradiction that TM R decides C. Construct a TM S that uses R to decide
ATM.
S = “On input ⟨M, w⟩:
1.
Use M and w to construct the following two-tape TM Tw.
Tw = “On any input:
1. Simulate M on w using the ﬁrst tape.
2. If the simulation shows that M accepts, write a non-
blank symbol on the second tape.”
2.
Run R on ⟨Tw⟩to determine whether Tw ever writes a nonblank
symbol on its second tape.
3.
If R accepts, M accepts w, so accept. Otherwise, reject.”
5.28
Assume for the sake of contradiction that P is a decidable language satisfying the
properties and let RP be a TM that decides P. We show how to decide ATM using
RP by constructing TM S. First, let T∅be a TM that always rejects, so L(T∅) = ∅.
You may assume that ⟨T∅⟩̸∈P without loss of generality because you could pro-
ceed with P instead of P if ⟨T∅⟩∈P. Because P is not trivial, there exists a TM T
with ⟨T ⟩∈P. Design S to decide ATM using RP ’s ability to distinguish between
T∅and T .
S = “On input ⟨M, w⟩:
1.
Use M and w to construct the following TM Mw.
Mw = “On input x:
1. Simulate M on w. If it halts and rejects, reject.
If it accepts, proceed to stage 2.
2. Simulate T on x. If it accepts, accept.”
2.
Use TM RP to determine whether ⟨Mw⟩∈P. If YES, accept.
If NO, reject.”
TM Mw simulates T if M accepts w. Hence L(Mw) equals L(T ) if M accepts w
and ∅otherwise. Therefore, ⟨Mw⟩∈P iff M accepts w.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

244
CHAPTER 5 / REDUCIBILITY
5.30
(a) INFINITETM is a language of TM descriptions. It satisﬁes the two conditions
of Rice’s theorem. First, it is nontrivial because some TMs have inﬁnite languages
and others do not. Second, it depends only on the language. If two TMs recognize
the same language, either both have descriptions in INFINITETM or neither do.
Consequently, Rice’s theorem implies that INFINITETM is undecidable.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6
A D V A N C E D T O P I C S I N
C O M P U T A B I L I T Y
T H E O R Y
In this chapter we delve into four deeper aspects of computability theory: (1) the
recursion theorem, (2) logical theories, (3) Turing reducibility, and (4) descrip-
tive complexity. The topic covered in each section is mainly independent of the
others, except for an application of the recursion theorem at the end of the sec-
tion on logical theories. Part Three of this book doesn’t depend on any material
from this chapter.
6.1
THE RECURSION THEOREM
The recursion theorem is a mathematical result that plays an important role in
advanced work in the theory of computability. It has connections to mathemati-
cal logic, the theory of self-reproducing systems, and even computer viruses.
To introduce the recursion theorem, we consider a paradox that arises in the
study of life. It concerns the possibility of making machines that can construct
replicas of themselves. The paradox can be summarized in the following manner.
245
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

246
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
1. Living things are machines.
2. Living things can self-reproduce.
3. Machines cannot self-reproduce.
Statement 1 is a tenet of modern biology. We believe that organisms operate
in a mechanistic way. Statement 2 is obvious. The ability to self-reproduce
is an essential characteristic of every biological species. For statement 3, we
make the following argument that machines cannot self-reproduce. Consider
a machine that constructs other machines, such as an automated factory that
produces cars. Raw materials go in at one end, the manufacturing robots follow
a set of instructions, and then completed vehicles come out the other end.
We claim that the factory must be more complex than the cars produced, in
the sense that designing the factory would be more difﬁcult than designing a car.
This claim must be true because the factory itself has the car’s design within it,
in addition to the design of all the manufacturing robots. The same reasoning
applies to any machine A that constructs a machine B: A must be more complex
than B. But a machine cannot be more complex than itself. Consequently, no
machine can construct itself, and thus self-reproduction is impossible.
How can we resolve this paradox? The answer is simple: Statement 3 is in-
correct. Making machines that reproduce themselves is possible. The recursion
theorem demonstrates how.
SELF-REFERENCE
Let’s begin by making a Turing machine that ignores its input and prints out
a copy of its own description. We call this machine SELF. To help describe
SELF, we need the following lemma.
LEMMA
6.1
There is a computable function q: Σ∗−→Σ∗, where if w is any string, q(w) is
the description of a Turing machine Pw that prints out w and then halts.
PROOF
Once we understand the statement of this lemma, the proof is easy.
Obviously, we can take any string w and construct from it a Turing machine that
has w built into a table so that the machine can simply output w when started.
The following TM Q computes q(w).
Q = “On input string w:
1.
Construct the following Turing machine Pw.
Pw = “On any input:
1. Erase input.
2. Write w on the tape.
3. Halt.”
2.
Output ⟨Pw⟩.”
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6.1
THE RECURSION THEOREM
247
The Turing machine SELF is in two parts: A and B. We think of A and B
as being two separate procedures that go together to make up SELF. We want
SELF to print out ⟨SELF⟩= ⟨AB⟩.
Part A runs ﬁrst and upon completion passes control to B. The job of A is
to print out a description of B, and conversely the job of B is to print out a
description of A. The result is the desired description of SELF. The jobs are
similar, but they are carried out differently. We show how to get part A ﬁrst.
For A we use the machine P⟨B⟩, described by q
 ⟨B⟩

, which is the result of
applying the function q to ⟨B⟩. Thus, part A is a Turing machine that prints out
⟨B⟩. Our description of A depends on having a description of B. So we can’t
complete the description of A until we construct B.
Now for part B. We might be tempted to deﬁne B with q
 ⟨A⟩

, but that
doesn’t make sense! Doing so would deﬁne B in terms of A, which in turn is
deﬁned in terms of B. That would be a circular deﬁnition of an object in terms
of itself, a logical transgression. Instead, we deﬁne B so that it prints A by using
a different strategy: B computes A from the output that A produces.
We deﬁned ⟨A⟩to be q
 ⟨B⟩

. Now comes the tricky part: If B can obtain
⟨B⟩, it can apply q to that and obtain ⟨A⟩. But how does B obtain ⟨B⟩? It was
left on the tape when A ﬁnished! So B only needs to look at the tape to obtain
⟨B⟩. Then after B computes q
 ⟨B⟩

= ⟨A⟩, it combines A and B into a single
machine and writes its description ⟨AB⟩= ⟨SELF⟩on the tape. In summary,
we have:
A = P⟨B⟩, and
B = “On input ⟨M⟩, where M is a portion of a TM:
1.
Compute q
 ⟨M⟩

.
2.
Combine the result with ⟨M⟩to make a complete TM.
3.
Print the description of this TM and halt.”
This completes the construction of SELF, for which a schematic diagram is
presented in the following ﬁgure.
       
FIGURE
6.2
Schematic of SELF, a TM that prints its own description
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

248
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
If we now run SELF, we observe the following behavior.
1. First A runs. It prints ⟨B⟩on the tape.
2. B starts. It looks at the tape and ﬁnds its input, ⟨B⟩.
3. B calculates q
 ⟨B⟩

= ⟨A⟩and combines that with ⟨B⟩into a
TM description, ⟨SELF⟩.
4. B prints this description and halts.
We can easily implement this construction in any programming language to
obtain a program that outputs a copy of itself. We can even do so in plain En-
glish. Suppose that we want to give an English sentence that commands the
reader to print a copy of the same sentence. One way to do so is to say:
Print out this sentence.
This sentence has the desired meaning because it directs the reader to print a
copy of the sentence itself. However, it doesn’t have an obvious translation into
a programming language because the self-referential word “this” in the sentence
usually has no counterpart. But no self-reference is needed to make such a sen-
tence. Consider the following alternative.
Print out two copies of the following, the second one in quotes:
“Print out two copies of the following, the second one in quotes:”
In this sentence, the self-reference is replaced with the same construction used
to make the TM SELF. Part B of the construction is the clause:
Print out two copies of the following, the second one in quotes:
Part A is the same, with quotes around it. A provides a copy of B to B so B can
process that copy as the TM does.
The recursion theorem provides the ability to implement the self-referential
this into any programming language. With it, any program has the ability to refer
to its own description, which has certain applications, as you will see. Before
getting to that, we state the recursion theorem itself. The recursion theorem
extends the technique we used in constructing SELF so that a program can
obtain its own description and then go on to compute with it, instead of merely
printing it out.
THEOREM
6.3
Recursion theorem
Let T be a Turing machine that computes a function
t: Σ∗× Σ∗−→Σ∗.
There is a Turing machine R that computes a function
r: Σ∗−→Σ∗, where for every w,
r(w) = t
 ⟨R⟩, w

.
The statement of this theorem seems a bit technical, but it actually represents
something quite simple. To make a Turing machine that can obtain its own
description and then compute with it, we need only make a machine, called T
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6.1
THE RECURSION THEOREM
249
in the statement, that receives the description of the machine as an extra input.
Then the recursion theorem produces a new machine R, which operates exactly
as T does but with R’s description ﬁlled in automatically.
PROOF
The proof is similar to the construction of SELF. We construct a TM
R in three parts, A, B, and T , where T is given by the statement of the theorem;
a schematic diagram is presented in the following ﬁgure.
       
FIGURE
6.4
Schematic of R
Here, A is the Turing machine P⟨BT ⟩described by q
 ⟨BT ⟩

. To preserve
the input w, we redesign q so that P⟨BT ⟩writes its output following any string
preexisting on the tape. After A runs, the tape contains w⟨BT ⟩.
Again, B is a procedure that examines its tape and applies q to its contents.
The result is ⟨A⟩. Then B combines A, B, and T into a single machine and ob-
tains its description ⟨ABT ⟩= ⟨R⟩. Finally, it encodes that description together
with w, places the resulting string ⟨R, w⟩on the tape, and passes control to T .
TERMINOLOGY FOR THE RECURSION THEOREM
The recursion theorem states that Turing machines can obtain their own de-
scription and then go on to compute with it. At ﬁrst glance, this capability may
seem to be useful only for frivolous tasks such as making a machine that prints a
copy of itself. But, as we demonstrate, the recursion theorem is a handy tool for
solving certain problems concerning the theory of algorithms.
You can use the recursion theorem in the following way when designing Tur-
ing machine algorithms. If you are designing a machine M, you can include the
phrase “obtain own description ⟨M⟩” in the informal description of M’s algo-
rithm. Upon having obtained its own description, M can then go on to use it as
it would use any other computed value. For example, M might simply print out
⟨M⟩as happens in the TM SELF, or it might count the number of states in ⟨M⟩,
or possibly even simulate ⟨M⟩. To illustrate this method, we use the recursion
theorem to describe the machine SELF.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

250
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
SELF = “On any input:
1.
Obtain, via the recursion theorem, own description ⟨SELF⟩.
2.
Print ⟨SELF⟩.”
The recursion theorem shows how to implement the “obtain own descrip-
tion” construct. To produce the machine SELF, we ﬁrst write the following
machine T .
T = “On input ⟨M, w⟩:
1.
Print ⟨M⟩and halt.”
The TM T receives a description of a TM M and a string w as input, and it prints
the description of M. Then the recursion theorem shows how to obtain a TM R,
which on input w operates like T on input ⟨R, w⟩. Thus, R prints the description
of R—exactly what is required of the machine SELF.
APPLICATIONS
A computer virus is a computer program that is designed to spread itself among
computers. Aptly named, it has much in common with a biological virus. Com-
puter viruses are inactive when standing alone as a piece of code. But when
placed appropriately in a host computer, thereby “infecting” it, they can become
activated and transmit copies of themselves to other accessible machines. Vari-
ous media can transmit viruses, including the Internet and transferable disks. In
order to carry out its primary task of self-replication, a virus may contain the
construction described in the proof of the recursion theorem.
Let’s now consider three theorems whose proofs use the recursion theorem.
An additional application appears in the proof of Theorem 6.17 in Section 6.2.
First we return to the proof of the undecidability of ATM. Recall that we ear-
lier proved it in Theorem 4.11, using Cantor’s diagonal method. The recursion
theorem gives us a new and simpler proof.
THEOREM
6.5
ATM is undecidable.
PROOF
We assume that Turing machine H decides ATM, for the purpose of
obtaining a contradiction. We construct the following machine B.
B = “On input w:
1.
Obtain, via the recursion theorem, own description ⟨B⟩.
2.
Run H on input ⟨B, w⟩.
3.
Do the opposite of what H says. That is, accept if H rejects and
reject if H accepts.”
Running B on input w does the opposite of what H declares it does. Therefore,
H cannot be deciding ATM. Done!
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6.1
THE RECURSION THEOREM
251
The following theorem concerning minimal Turing machines is another ap-
plication of the recursion theorem.
DEFINITION
6.6
If M is a Turing machine, then we say that the length of the descrip-
tion ⟨M⟩of M is the number of symbols in the string describing M.
Say that M is minimal if there is no Turing machine equivalent to
M that has a shorter description. Let
MIN TM = {⟨M⟩| M is a minimal TM}.
THEOREM
6.7
MIN TM is not Turing-recognizable.
PROOF
Assume that some TM E enumerates MIN TM and obtain a contradic-
tion. We construct the following TM C.
C = “On input w:
1.
Obtain, via the recursion theorem, own description ⟨C⟩.
2.
Run the enumerator E until a machine D appears with a longer
description than that of C.
3.
Simulate D on input w.”
Because MIN TM is inﬁnite, E’s list must contain a TM with a longer descrip-
tion than C’s description. Therefore, step 2 of C eventually terminates with
some TM D that is longer than C. Then C simulates D and so is equivalent to it.
Because C is shorter than D and is equivalent to it, D cannot be minimal. But
D appears on the list that E produces. Thus, we have a contradiction.
Our ﬁnal application of the recursion theorem is a type of ﬁxed-point theo-
rem. A ﬁxed point of a function is a value that isn’t changed by application of
the function. In this case, we consider functions that are computable transforma-
tions of Turing machine descriptions. We show that for any such transformation,
some Turing machine exists whose behavior is unchanged by the transformation.
This theorem is called the ﬁxed-point version of the recursion theorem.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

252
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
THEOREM
6.8
Let t: Σ∗−→Σ∗be a computable function. Then there is a Turing machine
F for which t
 ⟨F⟩

describes a Turing machine equivalent to F. Here we’ll
assume that if a string isn’t a proper Turing machine encoding, it describes a
Turing machine that always rejects immediately.
In this theorem, t plays the role of the transformation, and F is the ﬁxed point.
PROOF
Let F be the following Turing machine.
F = “On input w:
1.
Obtain, via the recursion theorem, own description ⟨F⟩.
2.
Compute t
 ⟨F⟩

to obtain the description of a TM G.
3.
Simulate G on w.”
Clearly, ⟨F⟩and t
 ⟨F⟩

= ⟨G⟩describe equivalent Turing machines because
F simulates G.
6.2
DECIDABILITY OF LOGICAL THEORIES
Mathematical logic is the branch of mathematics that investigates mathematics
itself. It addresses questions such as: What is a theorem? What is a proof? What
is truth? Can an algorithm decide which statements are true? Are all true state-
ments provable? We’ll touch on a few of these topics in our brief introduction
to this rich and fascinating subject.
We focus on the problem of determining whether mathematical statements
are true or false and investigate the decidability of this problem. The answer
depends on the domain of mathematics from which the statements are drawn.
We examine two domains: one for which we can give an algorithm to decide
truth, and another for which this problem is undecidable.
First, we need to set up a precise language to formulate these problems. Our
intention is to be able to consider mathematical statements such as
1. ∀q ∃p ∀x,y

p>q ∧(x,y>1 →xy̸=p)

,
2. ∀a,b,c,n

(a,b,c>0 ∧n>2) →an+bn̸=cn 
, and
3. ∀q ∃p ∀x,y

p>q ∧(x,y>1 →(xy̸=p ∧xy̸=p+2))

.
Statement 1 says that inﬁnitely many prime numbers exist, which has been
known to be true since the time of Euclid, about 2,300 years ago. Statement 2 is
Fermat’s last theorem, which has been known to be true only since Andrew Wiles
proved it in 1994. Finally, statement 3 says that inﬁnitely many prime pairs1
exist. Known as the twin prime conjecture, it remains unsolved.
1Prime pairs are primes that differ by 2.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6.2
DECIDABILITY OF LOGICAL THEORIES
253
To consider whether we could automate the process of determining which of
these statements are true, we treat such statements merely as strings and deﬁne a
language consisting of those statements that are true. Then we ask whether this
language is decidable.
To make this a bit more precise, let’s describe the form of the alphabet of this
language:
{∧, ∨, ¬, (, ), ∀, ∃, x, R1, . . . , Rk}.
The symbols ∧, ∨, and ¬ are called Boolean operations; “(” and “)” are the
parentheses; the symbols ∀and ∃are called quantiﬁers; the symbol x is used to
denote variables;2 and the symbols R1, . . . , Rk are called relations.
A formula is a well-formed string over this alphabet. For completeness, we’ll
sketch the technical but obvious deﬁnition of a well-formed formula here, but
feel free to skip this part and go on to the next paragraph. A string of the form
Ri(x1, . . . , xk) is an atomic formula. The value j is the arity of the relation
symbol Ri. All appearances of the same relation symbol in a well-formed formula
must have the same arity. Subject to this requirement, a string φ is a formula if it
1. is an atomic formula,
2. has the form φ1 ∧φ2 or φ1 ∨φ2 or ¬φ1, where φ1 and φ2 are smaller
formulas, or
3. has the form ∃xi [ φ1 ] or ∀xi [ φ1 ], where φ1 is a smaller formula.
A quantiﬁer may appear anywhere in a mathematical statement. Its scope is
the fragment of the statement appearing within the matched pair of parentheses
or brackets following the quantiﬁed variable. We assume that all formulas are in
prenex normal form, where all quantiﬁers appear in the front of the formula. A
variable that isn’t bound within the scope of a quantiﬁer is called a free variable.
A formula with no free variables is called a sentence or statement.
EXAMPLE
6.9
Among the following examples of formulas, only the last one is a sentence.
1. R1(x1) ∧R2(x1, x2, x3)
2. ∀x1

R1(x1) ∧R2(x1, x2, x3)

3. ∀x1 ∃x2 ∃x3

R1(x1) ∧R2(x1, x2, x3)

Having established the syntax of formulas, let’s discuss their meanings. The
Boolean operations and the quantiﬁers have their usual meanings. But to deter-
mine the meaning of the variables and relation symbols, we need to specify two
items. One is the universe over which the variables may take values. The other
2If we need to write several variables in a formula, we use the symbols w, y, z, or x1, x2,
x3, and so on. We don’t list all the inﬁnitely many possible variables in the alphabet to
keep the alphabet ﬁnite. Instead, we list only the variable symbol x, and use strings of x’s
to indicate other variables, as in xx for x2, xxx for x3, and so on.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

254
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
is an assignment of speciﬁc relations to the relation symbols. As we described in
Section 0.2 (page 9), a relation is a function from k-tuples over the universe to
{TRUE, FALSE}. The arity of a relation symbol must match that of its assigned
relation.
A universe together with an assignment of relations to relation symbols is
called a model.3 Formally, we say that a model M is a tuple (U, P1, . . . , Pk),
where U is the universe and P1 through Pk are the relations assigned to symbols
R1 through Rk. We sometimes refer to the language of a model to be the
collection of formulas that use only the relation symbols the model assigns, and
that use each relation symbol with the correct arity. If φ is a sentence in the
language of a model, φ is either true or false in that model. If φ is true in a
model M, we say that M is a model of φ.
If you feel overwhelmed by these deﬁnitions, concentrate on our objective in
stating them. We want to set up a precise language of mathematical statements
so that we can ask whether an algorithm can determine which are true and which
are false. The following two examples should be helpful.
EXAMPLE
6.10
Let φ be the sentence ∀x ∀y

R1(x, y) ∨R1(y, x)

. Let model M1 = (N, ≤) be
the model whose universe is the natural numbers and that assigns the “less than
or equal” relation to the symbol R1. Obviously, φ is true in model M1 because
either a ≤b or b ≤a for any two natural numbers a and b. However, if M1
assigned “less than” instead of “less than or equal” to R1, then φ would not be
true because it fails when x and y are equal.
If we know in advance which relation will be assigned to Ri, we may use the
customary symbol for that relation in place of Ri with inﬁx notation rather than
preﬁx notation if customary for that symbol. Thus, with model M1 in mind, we
could write φ as ∀x ∀y

x≤y ∨y≤x

.
EXAMPLE
6.11
Now let M2 be the model whose universe is the real numbers R and that assigns
the relation PLUS to R1, where PLUS(a, b, c) = TRUE whenever a + b = c.
Then M2 is a model of ψ = ∀y ∃x

R1(x, x, y)

. However, if N were used for
the universe instead of R in M2, the sentence would be false.
As in Example 6.10, we may write ψ as ∀y ∃x

x + x = y

in place of
∀y ∃x

R1(x, x, y)

when we know in advance that we will be assigning the ad-
dition relation to R1.
As Example 6.11 illustrates, we can represent functions such as the addition
function by relations. Similarly, we can represent constants such as 0 and 1 by
relations.
3A model is also variously called an interpretation or a structure.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6.2
DECIDABILITY OF LOGICAL THEORIES
255
Now we give one ﬁnal deﬁnition in preparation for the next section. If M
is a model, we let the theory of M, written Th(M), be the collection of true
sentences in the language of that model.
A DECIDABLE THEORY
Number theory is one of the oldest branches of mathematics and also one of
its most difﬁcult. Many innocent-looking statements about the natural num-
bers with the plus and times operations have confounded mathematicians for
centuries, such as the twin prime conjecture mentioned earlier.
In one of the celebrated developments in mathematical logic, Alonzo Church,
building on the work of Kurt G¨odel, showed that no algorithm can decide in
general whether statements in number theory are true or false. Formally, we
write (N, +, ×) to be the model whose universe is the natural numbers4 with
the usual + and × relations. Church showed that Th(N, +, ×), the theory of
this model, is undecidable.
Before looking at this undecidable theory, let’s examine one that is decidable.
Let (N, +) be the same model, without the × relation. Its theory is Th(N, +).
For example, the formula ∀x ∃y

x + x = y

is true and is therefore a member
of Th(N, +), but the formula ∃y∀x

x + x = y

is false and is therefore not a
member.
THEOREM
6.12
Th(N, +) is decidable.
PROOF IDEA
This proof is an interesting and nontrivial application of the
theory of ﬁnite automata that we presented in Chapter 1. One fact about ﬁnite
automata that we use appears in Problem 1.32, (page 88) where you were asked
to show that they are capable of doing addition if the input is presented in a
special form. The input describes three numbers in parallel by representing one
bit of each number in a single symbol from an eight-symbol alphabet. Here we
use a generalization of this method to present i-tuples of numbers in parallel
using an alphabet with 2i symbols.
We give an algorithm that can determine whether its input, a sentence φ in
the language of (N, +), is true in that model. Let
φ = Q1x1 Q2x2 · · · Qlxl

ψ

,
where Q1, . . . , Ql each represents either ∃or ∀and ψ is a formula without quan-
tiﬁers that has variables x1, . . . , xl. For each i from 0 to l, deﬁne formula φi as
φi = Qi+1xi+1 Qi+2xi+2 · · · Qlxl

ψ

.
Thus φ0 = φ and φl = ψ.
4For convenience in this chapter, we change our usual deﬁnition of N to be {0, 1, 2, . . .}.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

256
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
Formula φi has i free variables. For a1, . . . , ai ∈N, write φi(a1, . . . , ai) to be
the sentence obtained by substituting the constants a1, . . . , ai for the variables
x1, . . . , xi in φi.
For each i from 0 to l, the algorithm constructs a ﬁnite automaton Ai that
recognizes the collection of strings representing i-tuples of numbers that make
φi true. The algorithm begins by constructing Al directly, using a generalization
of the method in the solution to Problem 1.32. Then, for each i from l down
to 1, it uses Ai to construct Ai−1. Finally, once the algorithm has A0, it tests
whether A0 accepts the empty string. If it does, φ is true and the algorithm
accepts.
PROOF
For i > 0, deﬁne the alphabet
Σi =
(" 0...
0
0
#
,
" 0...
0
1
#
,
" 0...
1
0
#
,
" 0...
1
1
#
, . . . ,
" 1...
1
1
#)
.
Hence Σi contains all size i columns of 0s and 1s. A string over Σi represents i
binary integers (reading across the rows). We also deﬁne Σ0 = {[ ]}, where [ ] is
a symbol.
We now present an algorithm that decides Th(N, +). On input φ, where
φ is a sentence, the algorithm operates as follows. Write φ and deﬁne φi for
each i from 0 to l, as in the proof idea. For each such i, construct a ﬁnite
automaton Ai from φi that accepts strings over Σi corresponding to i-tuples
a1, . . . , ai whenever φi(a1, . . . , ai) is true, as follows.
To construct the ﬁrst machine Al, observe that φl = ψ is a Boolean combi-
nation of atomic formulas. An atomic formula in the language of Th(N, +) is a
single addition. Finite automata can be constructed to compute any of these in-
dividual relations corresponding to a single addition and then combined to give
the automaton Al. Doing so involves the use of the regular language closure
constructions for union, intersection, and complementation to compute Boolean
combinations of the atomic formulas.
Next, we show how to construct Ai from Ai+1. If φi = ∃xi+1 φi+1, we con-
struct Ai to operate as Ai+1 operates, except that it nondeterministically guesses
the value of ai+1 instead of receiving it as part of the input.
More precisely, Ai contains a state for each Ai+1 state and a new start state.
Every time Ai reads a symbol


b1...
bi−1
bi


,
where every bj ∈{0,1} is a bit of the number aj, it nondeterministically guesses
z ∈{0,1} and simulates Ai+1 on the input symbol


b1...
bi−1
biz


.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6.2
DECIDABILITY OF LOGICAL THEORIES
257
Initially, Ai nondeterministically guesses the leading bits of ai+1 corresponding
to suppressed leading 0s in a1 through ai by nondeterministically branching
using ε-transitions from its new start state to all states that Ai+1 could reach
from its start state with input strings of the symbols
(" 0...
0
0
#
,
" 0...
0
1
#)
in Σi+1. Clearly, Ai accepts its input (a1, . . . , ai) if some ai+1 exists where Ai+1
accepts (a1, . . . , ai+1).
If φi = ∀xi+1 φi+1, it is equivalent to ¬∃xi+1¬ φi+1. Thus, we can construct
the ﬁnite automaton that recognizes the complement of the language of Ai+1,
then apply the preceding construction for the ∃quantiﬁer, and ﬁnally apply com-
plementation once again to obtain Ai.
Finite automaton A0 accepts any input iff φ0 is true. So the ﬁnal step of the
algorithm tests whether A0 accepts ε. If it does, φ is true and the algorithm
accepts; otherwise, it rejects.
AN UNDECIDABLE THEORY
As we mentioned earlier, Th(N, +, ×) is an undecidable theory. No algorithm
exists for deciding the truth or falsity of mathematical statements, even when re-
stricted to the language of (N, +, ×). This theorem has great importance philo-
sophically because it demonstrates that mathematics cannot be mechanized. We
state this theorem, but give only a brief sketch of its proof.
THEOREM
6.13
Th(N, +, ×) is undecidable.
Although it contains many details, the proof of this theorem is not difﬁcult
conceptually. It follows the pattern of the other proofs of undecidability pre-
sented in Chapter 4. We show that Th(N, +, ×) is undecidable by reducing ATM
to it, using the computation history method as previously described (page 220).
The existence of the reduction depends on the following lemma.
LEMMA
6.14
Let M be a Turing machine and w a string. We can construct from M and w a
formula φM,w in the language of (N, +, ×) that contains a single free variable x,
whereby the sentence ∃x φM,w is true iff M accepts w.
PROOF IDEA
Formula φM,w “says” that x is a (suitably encoded) accepting
computation history of M on w. Of course, x actually is just a rather large
integer, but it represents a computation history in a form that can be checked by
using the + and × operations.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

258
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
The actual construction of φM,w is too complicated to present here. It ex-
tracts individual symbols in the computation history with the + and × operations
to check that the start conﬁguration for M on w is correct, that each conﬁgura-
tion legally follows from the one preceding it, and that the last conﬁguration is
accepting.
PROOF OF THEOREM 6.13
We give a mapping reduction from ATM to
Th(N, +, ×).
The reduction constructs the formula φM,w from the input
⟨M, w⟩by using Lemma 6.14. Then it outputs the sentence ∃x φM,w.
Next, we sketch the proof of Kurt G¨odel’s celebrated incompleteness theorem.
Informally, this theorem says that in any reasonable system of formalizing the
notion of provability in number theory, some true statements are unprovable.
Loosely speaking, the formal proof π of a statement φ is a sequence of state-
ments, S1, S2, . . . , Sl, where Sl = φ. Each Si follows from the preceding state-
ments and certain basic axioms about numbers, using simple and precise rules
of implication. We don’t have space to deﬁne the concept of proof; but for our
purposes, assuming the following two reasonable properties of proofs will be
enough.
1. The correctness of a proof of a statement can be checked by machine.
Formally, {⟨φ, π⟩| π is a proof of φ} is decidable.
2. The system of proofs is sound. That is, if a statement is provable (i.e., has a
proof), it is true.
If a system of provability satisﬁes these two conditions, the following three the-
orems hold.
THEOREM
6.15
The collection of provable statements in Th(N, +, ×) is Turing-recognizable.
PROOF
The following algorithm P accepts its input φ if φ is provable. Al-
gorithm P tests each string as a candidate for a proof π of φ, using the proof
checker assumed in provability property 1. If it ﬁnds that any of these candi-
dates is a proof, it accepts.
Now we can use the preceding theorem to prove our version of the incom-
pleteness theorem.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6.2
DECIDABILITY OF LOGICAL THEORIES
259
THEOREM
6.16
Some true statement in Th(N, +, ×) is not provable.
PROOF
We give a proof by contradiction. We assume to the contrary that all
true statements are provable. Using this assumption, we describe an algorithm
D that decides whether statements are true, contradicting Theorem 6.13.
On input φ, algorithm D operates by running algorithm P given in the proof
of Theorem 6.15 in parallel on inputs φ and ¬φ. One of these two statements
is true and thus by our assumption is provable. Therefore, P must halt on one
of the two inputs. By provability property 2, if φ is provable, then φ is true; and
if ¬φ is provable, then φ is false. So algorithm D can decide the truth or falsity
of φ.
In the ﬁnal theorem of this section, we use the recursion theorem to give
an explicit sentence in the language of (N, +, ×) that is true but not provable.
In Theorem 6.16 we demonstrated the existence of such a sentence but didn’t
actually describe one, as we do now.
THEOREM
6.17
The sentence ψunprovable, as described in the proof, is unprovable.
PROOF IDEA
Construct a sentence that says “This sentence is not provable,”
using the recursion theorem to obtain the self-reference.
PROOF
Let S be a TM that operates as follows.
S = “On any input:
1.
Obtain own description ⟨S⟩via the recursion theorem.
2.
Construct the sentence ψ = ¬∃c

φS,0

, using Lemma 6.14.
3.
Run algorithm P from the proof of Theorem 6.15 on input ψ.
4.
If stage 3 accepts, accept.”
Let ψunprovable be the sentence ψ described in stage 2 of algorithm S. That
sentence is true iff S doesn’t accept 0 (the string 0 was selected arbitrarily).
If S ﬁnds a proof of ψunprovable, S accepts 0, and the sentence would thus be
false. A false sentence cannot be provable, so this situation cannot occur. The
only remaining possibility is that S fails to ﬁnd a proof of ψunprovable and so S
doesn’t accept 0. But then ψunprovable is true, as we claimed.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

260
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
6.3
TURING REDUCIBILITY
We introduced the reducibility concept in Chapter 5 as a way of using a solution
to one problem to solve other problems. Thus, if A is reducible to B, and we
ﬁnd a solution to B, we can obtain a solution to A. Subsequently, we described
mapping reducibility, a speciﬁc form of reducibility. But does mapping reducibility
capture our intuitive concept of reducibility in the most general way? It doesn’t.
For example, consider the two languages ATM and ATM. Intuitively, they
are reducible to one another because a solution to either could be used to solve
the other by simply reversing the answer. However, we know that ATM is not
mapping reducible to ATM because ATM is Turing-recognizable but ATM isn’t.
Here we present a very general form of reducibility, called Turing reducibility,
which captures our intuitive concept of reducibility more closely.
DEFINITION
6.18
An oracle for a language B is an external device that is capable of
reporting whether any string w is a member of B. An oracle Turing
machine is a modiﬁed Turing machine that has the additional ca-
pability of querying an oracle. We write M B to describe an oracle
Turing machine that has an oracle for language B.
We aren’t concerned with the way the oracle determines its responses. We use
the term oracle to connote a magical ability and consider oracles for languages
that aren’t decidable by ordinary algorithms, as the following example shows.
EXAMPLE
6.19
Consider an oracle for ATM. An oracle Turing machine with an oracle for ATM
can decide more languages than an ordinary Turing machine can. Such a ma-
chine can (obviously) decide ATM itself, by querying the oracle about the input.
It can also decide ETM, the emptiness testing problem for TMs with the following
procedure called T ATM.
T ATM = “On input ⟨M⟩, where M is a TM:
1.
Construct the following TM N.
N = “On any input:
1. Run M in parallel on all strings in Σ∗.
2. If M accepts any of these strings, accept.”
2.
Query the oracle to determine whether ⟨N, 0⟩∈ATM.
3.
If the oracle answers NO, accept; if YES, reject.”
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6.4
A DEFINITION OF INFORMATION
261
If M’s language isn’t empty, N will accept every input and, in particular, in-
put 0. Hence the oracle will answer YES, and T ATM will reject. Conversely, if
M’s language is empty, T ATM will accept. Thus T ATM decides ETM. We say that
ETM is decidable relative to ATM. That brings us to the deﬁnition of Turing
reducibility.
DEFINITION
6.20
Language A is Turing reducible to language B, written A ≤T B, if
A is decidable relative to B.
Example 6.19 shows that ETM is Turing reducible to ATM. Turing reducibility
satisﬁes our intuitive concept of reducibility as shown by the following theorem.
THEOREM
6.21
If A ≤T B and B is decidable, then A is decidable.
PROOF
If B is decidable, then we may replace the oracle for B by an actual
procedure that decides B. Thus, we may replace the oracle Turing machine that
decides A by an ordinary Turing machine that decides A.
Turing reducibility is a generalization of mapping reducibility. If A ≤m B,
then A ≤T B because the mapping reduction may be used to give an oracle
Turing machine that decides A relative to B.
An oracle Turing machine with an oracle for ATM is very powerful. It can
solve many problems that are not solvable by ordinary Turing machines. But
even such a powerful machine cannot decide all languages (see Exercise 6.4).
6.4
A DEFINITION OF INFORMATION
The concepts algorithm and information are fundamental in computer science.
While the Church–Turing thesis gives a universally applicable deﬁnition of al-
gorithm, no equally comprehensive deﬁnition of information is known. Instead
of a single, universal deﬁnition of information, several deﬁnitions are used—
depending upon the application. In this section we present one way of deﬁning
information, using computability theory.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

262
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
We start with an example. Consider the information content of the following
two binary sequences.
A = 0101010101010101010101010101010101010101
B = 1110010110100011101010000111010011010111
Intuitively, sequence A contains little information because it is merely a repe-
tition of the pattern 01 twenty times. In contrast, sequence B appears to contain
more information.
We can use this simple example to illustrate the idea behind the deﬁnition of
information that we present. We deﬁne the quantity of information contained in
an object to be the size of that object’s smallest representation or description. By
a description of an object, we mean a precise and unambiguous characterization
of the object so that we may recreate it from the description alone. Thus, se-
quence A contains little information because it has a small description, whereas
sequence B apparently contains more information because it seems to have no
concise description.
Why do we consider only the shortest description when determining an ob-
ject’s quantity of information? We may always describe an object, such as a
string, by placing a copy of the object directly into the description. Thus, we
can obviously describe the preceding string B with a table that is 40 bits long
containing a copy of B. This type of description is never shorter than the object
itself and doesn’t tell us anything about its information quantity. However, a de-
scription that is signiﬁcantly shorter than the object implies that the information
contained within it can be compressed into a small volume, and so the amount
of information can’t be very large. Hence the size of the shortest description
determines the amount of information.
Now we formalize this intuitive idea. Doing so isn’t difﬁcult, but we must do
some preliminary work. First, we restrict our attention to objects that are binary
strings. Other objects can be represented as binary strings, so this restriction
doesn’t limit the scope of the theory. Second, we consider only descriptions
that are themselves binary strings. By imposing this requirement, we may easily
compare the length of the object with the length of its description. In the next
section, we consider the type of description that we allow.
MINIMAL LENGTH DESCRIPTIONS
Many types of description language can be used to deﬁne information. Selecting
which language to use affects the characteristics of the deﬁnition. Our descrip-
tion language is based on algorithms.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6.4
A DEFINITION OF INFORMATION
263
One way to use algorithms to describe strings is to construct a Turing machine
that prints out the string when it is started on a blank tape and then represent
that Turing machine itself as a string. Thus, the string representing the Turing
machine is a description of the original string. A drawback to this approach is
that a Turing machine cannot represent a table of information concisely with its
transition function. To represent a string of n bits, you might use n states and
n rows in the transition function table. That would result in a description that
is excessively long for our purpose. Instead, we use the following more concise
description language.
We describe a binary string x with a Turing machine M and a binary input
w to M. The length of the description is the combined length of representing
M and w. We write this description with our usual notation for encoding sev-
eral objects into a single binary string ⟨M, w⟩. But here we must pay additional
attention to the encoding operation ⟨· , ·⟩because we need to produce a concise
result. We deﬁne the string ⟨M, w⟩to be ⟨M⟩w, where we simply concatenate
the binary string w onto the end of the binary encoding of M. The encoding
⟨M⟩of M may be done in any standard way, except for the subtlety that we de-
scribe in the next paragraph. (Don’t worry about this subtle point on your ﬁrst
reading of this material. For now, skip past the next paragraph and the following
ﬁgure.)
When concatenating w onto the end of ⟨M⟩to yield a description of x, you
might run into trouble if the point at which ⟨M⟩ends and w begins is not dis-
cernible from the description itself. Otherwise, several ways of partitioning the
description ⟨M⟩w into a syntactically correct TM and an input may occur, and
then the description would be ambiguous and hence invalid. We avoid this prob-
lem by ensuring that we can locate the separation between ⟨M⟩and w in ⟨M⟩w.
One way to do so is to write each bit of ⟨M⟩twice, writing 0 as 00 and 1 as 11,
and then follow it with 01 to mark the separation point. We illustrate this idea
in the following ﬁgure, depicting the description ⟨M, w⟩of some string x.
⟨M, w⟩= 11001111001100· · · 1100
delimiter
z}|{
01
|
{z
}
⟨M⟩
01101011· · · 010
|
{z
}
w
FIGURE
6.22
Example of the format of the description ⟨M, w⟩of some string x
Now that we have ﬁxed our description language, we are ready to deﬁne our
measure of the quantity of information in a string.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

264
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
DEFINITION
6.23
Let x be a binary string. The minimal description of x, written
d(x), is the shortest string ⟨M, w⟩where TM M on input w halts
with x on its tape.
If several such strings exist, select the lexi-
cographically ﬁrst among them. The descriptive complexity5of x,
written K(x), is
K(x) = |d(x)|.
In other words, K(x) is the length of the minimal description of x. The
deﬁnition of K(x) is intended to capture our intuition for the amount of infor-
mation in the string x. Next we establish some simple results about descriptive
complexity.
THEOREM
6.24
∃c ∀x

K(x) ≤|x| + c

This theorem says that the descriptive complexity of a string is at most a ﬁxed
constant more than its length. The constant is a universal one, not dependent
on the string.
PROOF
To prove an upper bound on K(x) as this theorem claims, we need
only demonstrate some description of x that is no longer than the stated bound.
Then the minimal description of x may be shorter than the demonstrated de-
scription, but not longer.
Consider the following description of the string x. Let M be a Turing ma-
chine that halts as soon as it is started. This machine computes the identity
function—its output is the same as its input. A description of x is simply ⟨M⟩x.
Letting c be the length of ⟨M⟩completes the proof.
Theorem 6.24 illustrates how we use the input to the Turing machine to rep-
resent information that would require a signiﬁcantly larger description if stored
instead by using the machine’s transition function. It conforms to our intuition
that the amount of information contained by a string cannot be (substantially)
more than its length. Similarly, intuition says that the information contained by
the string xx is not signiﬁcantly more than the information contained by x. The
following theorem veriﬁes this fact.
5Descriptive complexity is called Kolmogorov complexity or Kolmogorov–Chaitin com-
plexity in some treatments.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6.4
A DEFINITION OF INFORMATION
265
THEOREM
6.25
∃c ∀x

K(xx) ≤K(x) + c

PROOF
Consider the following Turing machine M, which expects an input
of the form ⟨N, w⟩, where N is a Turing machine and w is an input for it.
M = “On input ⟨N, w⟩, where N is a TM and w is a string:
1.
Run N on w until it halts and produces an output string s.
2.
Output the string ss.”
A description of xx is ⟨M⟩d(x). Recall that d(x) is a minimal description of x.
The length of this description is |⟨M⟩| + |d(x)|, which is c + K(x) where c is the
length of ⟨M⟩.
Next we examine how the descriptive complexity of the concatenation xy of
two strings x and y is related to their individual complexities. Theorem 6.24
might lead us to believe that the complexity of the concatenation is at most the
sum of the individual complexities (plus a ﬁxed constant), but the cost of com-
bining two descriptions leads to a greater bound, as described in the following
theorem.
THEOREM
6.26
∃c ∀x,y

K(xy) ≤2K(x) + K(y) + c

PROOF
We construct a TM M that breaks its input w into two separate de-
scriptions. The bits of the ﬁrst description d(x) are all doubled and terminated
with string 01 before the second description d(y) appears, as described in the
text preceding Figure 6.22. Once both descriptions have been obtained, they are
run to obtain the strings x and y and the output xy is produced.
The length of this description of xy is clearly twice the complexity of x plus
the complexity of y plus a ﬁxed constant for describing M. This sum is
2K(x) + K(y) + c,
and the proof is complete.
We may improve this theorem somewhat by using a more efﬁcient method
of indicating the separation between the two descriptions. One way avoids dou-
bling the bits of d(x). Instead we prepend the length of d(x) as a binary integer
that has been doubled to differentiate it from d(x). The description still contains
enough information to decode it into the two descriptions of x and y, and it now
has length at most
2 log2(K(x)) + K(x) + K(y) + c.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

266
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
Further small improvements are possible. However, as Problem 6.26 asks you to
show, we cannot reach the bound K(x) + K(y) + c.
OPTIMALITY OF THE DEFINITION
Now that we have established some of the elementary properties of descriptive
complexity and you have had a chance to develop some intuition, we discuss
some features of the deﬁnitions.
Our deﬁnition of K(x) has an optimality property among all possible ways
of deﬁning descriptive complexity with algorithms. Suppose that we consider a
general description language to be any computable function p: Σ∗−→Σ∗and
deﬁne the minimal description of x with respect to p, written dp(x), to be the
ﬁrst string s where p(s) = x, in the standard string order. Thus, s is lexico-
graphically ﬁrst among the shortest descriptions of x. Deﬁne Kp(x) = |dp(x)|.
For example, consider a programming language such as Python (encoded into
binary) as the description language. Then dPython(x) would be the minimal
Python program that outputs x, and KPython(x) would be the length of the min-
imal program.
The following theorem shows that any description language of this type is
not signiﬁcantly more concise than the language of Turing machines and inputs
that we originally deﬁned.
THEOREM
6.27
For any description language p, a ﬁxed constant c exists that depends only on p,
where
∀x

K(x) ≤Kp(x) + c

.
PROOF IDEA
We illustrate the idea of this proof by using the Python exam-
ple. Suppose that x has a short description w in Python. Let M be a TM that
can interpret Python and use the Python program for x as M’s input w. Then
⟨M, w⟩is a description of x that is only a ﬁxed amount larger than the Python
description of x. The extra length is for the Python interpreter M.
PROOF
Take any description language p and consider the following Turing
machine M.
M = “On input w:
1.
Output p(w).”
Then ⟨M⟩dp(x) is a description of x whose length is at most a ﬁxed constant
greater than Kp(x). The constant is the length of ⟨M⟩.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6.4
A DEFINITION OF INFORMATION
267
INCOMPRESSIBLE STRINGS AND RANDOMNESS
Theorem 6.24 shows that a string’s minimal description is never much longer
than the string itself. Of course for some strings, the minimal description may
be much shorter if the information in the string appears sparsely or redundantly.
Do some strings lack short descriptions? In other words, is the minimal de-
scription of some strings actually as long as the string itself? We show that such
strings exist. These strings can’t be described any more concisely than simply
writing them out explicitly.
DEFINITION
6.28
Let x be a string. Say that x is c-compressible if
K(x) ≤|x| −c.
If x is not c-compressible, we say that x is incompressible by c.
If x is incompressible by 1, we say that x is incompressible.
In other words, if x has a description that is c bits shorter than its length,
x is c-compressible. If not, x is incompressible by c. Finally, if x doesn’t have
any description shorter than itself, x is incompressible. We ﬁrst show that in-
compressible strings exist, and then we discuss their interesting properties. In
particular, we show that incompressible strings look like strings that are obtained
from random coin tosses.
THEOREM
6.29
Incompressible strings of every length exist.
PROOF IDEA
The number of strings of length n is greater than the number
of descriptions of length less than n. Each description describes at most one
string. Therefore, some string of length n is not described by any description of
length less than n. That string is incompressible.
PROOF
The number of binary strings of length n is 2n. Each description is a
binary string, so the number of descriptions of length less than n is at most the
sum of the number of strings of each length up to n −1, or
X
0≤i≤n−1
2i = 1 + 2 + 4 + 8 + · · · + 2n−1 = 2n −1.
The number of short descriptions is less than the number of strings of length n.
Therefore, at least one string of length n is incompressible.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

268
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
COROLLARY
6.30
At least 2n −2n−c+1 + 1 strings of length n are incompressible by c.
PROOF
We extend the proof of Theorem 6.29. Every c-compressible string
has a description of length at most n −c.
No more than 2n−c+1 −1 such
descriptions can occur.
Therefore, at most 2n−c+1 −1 of the 2n strings of
length n may have such descriptions. The remaining strings, numbering at least
2n −(2n−c+1 −1), are incompressible by c.
Incompressible strings have many properties that we would expect to ﬁnd in
randomly chosen strings. For example, we can show that any incompressible
string of length n has roughly an equal number of 0s and 1s, and that the length
of its longest run of 0s is approximately log2 n, as we would expect to ﬁnd in
a random string of that length. Proving such statements would take us too far
aﬁeld into combinatorics and probability, but we will prove a theorem that forms
the basis for these statements.
That theorem shows that any computable property that holds for “almost all”
strings also holds for all sufﬁciently long incompressible strings. As we men-
tioned in Section 0.2, a property of strings is simply a function f that maps
strings to {TRUE, FALSE}. We say that a property holds for almost all strings if
the fraction of strings of length n on which it is FALSE approaches 0 as n grows
large. A randomly chosen long string is likely to satisfy a computable property
that holds for almost all strings. Therefore, random strings and incompressible
strings share such properties.
THEOREM
6.31
Let f be a computable property that holds for almost all strings. Then, for any
b > 0, the property f is FALSE on only ﬁnitely many strings that are incompress-
ible by b.
PROOF
Let M be the following algorithm.
M = “On input i, a binary integer:
1.
Find the ith string s where f(s) = FALSE, in the standard string
order.
2.
Output string s.”
We can use M to obtain short descriptions of strings that fail to have property
f as follows. For any such string x, let ix be the position or index of x on a list of
all strings that fail to have property f, in the standard string order (i.e., by length
and lexicographically within each length). Then ⟨M, ix⟩is a description of x.
The length of this description is |ix| + c, where c is the length of ⟨M⟩. Because
few strings fail to have property f, the index of x is small and its description is
correspondingly short.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

6.4
A DEFINITION OF INFORMATION
269
Fix any number b > 0. Select n such that at most a 1/2b+c+1 fraction of
strings of length n or less fail to have property f. All sufﬁciently large n satisfy
this condition because f holds for almost all strings. Let x be a string of length
n that fails to have property f. We have 2n+1 −1 strings of length n or less, so
ix ≤2n+1 −1
2b+c+1
≤2n−b−c.
Therefore, |ix| ≤n−b−c, so the length of ⟨M, ix⟩is at most (n−b−c)+c = n−b,
which implies that
K(x) ≤n −b.
Thus every sufﬁciently long x that fails to have property f is compressible by b.
Hence only ﬁnitely many strings that fail to have property f are incompressible
by b, and the theorem is proved.
At this point, exhibiting some examples of incompressible strings would be
appropriate. However, as Problem 6.23 asks you to show, the K measure of
complexity is not computable. Furthermore, no algorithm can decide in general
whether strings are incompressible, by Problem 6.24. Indeed, by Problem 6.25,
no inﬁnite subset of them is Turing-recognizable. So we have no way to ob-
tain long incompressible strings and would have no way to determine whether
a string is incompressible even if we had one. The following theorem describes
certain strings that are nearly incompressible, although it doesn’t provide a way
to exhibit them explicitly.
THEOREM
6.32
For some constant b, for every string x, the minimal description d(x) of x is
incompressible by b.
PROOF
Consider the following TM M:
M = “On input ⟨R, y⟩, where R is a TM and y is a string:
1.
Run R on y and reject if its output is not of the form ⟨S, z⟩.
2.
Run S on z and halt with its output on the tape.”
Let b be |⟨M⟩| + 1. We show that b satisﬁes the theorem. Suppose to the
contrary that d(x) is b-compressible for some string x. Then
|d(d(x))| ≤|d(x)| −b.
But then ⟨M⟩d(d(x)) is a description of x whose length is at most
|⟨M⟩| + |d(d(x))| ≤(b −1) + (|d(x)| −b) = |d(x)| −1.
This description of x is shorter than d(x), contradicting the latter’s minimality.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

270
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
EXERCISES
6.1 Give an example in the spirit of the recursion theorem of a program in a real pro-
gramming language (or a reasonable approximation thereof ) that prints itself out.
6.2 Show that any inﬁnite subset of MIN TM is not Turing-recognizable.
A6.3 Show that if A ≤T B and B ≤T C, then A ≤T C.
6.4 Let ATM
′ = {⟨M, w⟩| M is an oracle TM and M ATM accepts w}. Show that ATM
′
is undecidable relative to ATM.
A6.5 Is the statement ∃x ∀y

x+y=y

a member of Th(N, +)? Why or why not? What
about the statement ∃x ∀y

x+y=x

?
PROBLEMS
6.6 Describe two different Turing machines, M and N, where M outputs ⟨N⟩and N
outputs ⟨M⟩, when started on any input.
6.7 In the ﬁxed-point version of the recursion theorem (Theorem 6.8), let the trans-
formation t be a function that interchanges the states qaccept and qreject in Turing
machine descriptions. Give an example of a ﬁxed point for t.
⋆6.8 Show that EQTM ̸≤m EQTM.
A6.9 Use the recursion theorem to give an alternative proof of Rice’s theorem in Prob-
lem 5.28.
A6.10 Give a model of the sentence
φeq = ∀x

R1(x, x)

∧∀x,y

R1(x, y) ↔R1(y, x)

∧∀x,y,z

(R1(x, y) ∧R1(y, z)) →R1(x, z)

.
⋆6.11 Let φeq be deﬁned as in Problem 6.10. Give a model of the sentence
φlt = φeq
∧∀x,y

R1(x, y) →¬R2(x, y)

∧∀x,y

¬R1(x, y) →(R2(x, y) ⊕R2(y, x))

∧∀x,y,z

(R2(x, y) ∧R2(y, z)) →R2(x, z)

∧∀x ∃y

R2(x, y)

.
A6.12 Let (N, <) be the model with universe N and the “less than” relation. Show that
Th(N, <) is decidable.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
271
6.13 For each m > 1 let Zm = {0, 1, 2, . . . , m −1}, and let Fm = (Zm, +, ×) be the
model whose universe is Zm and that has relations corresponding to the + and
× relations computed modulo m. Show that for each m, the theory Th(Fm) is
decidable.
6.14 Show that for any two languages A and B, a language J exists, where A ≤T J and
B ≤T J.
6.15 Show that for any language A, a language B exists, where A ≤T B and B ̸≤T A.
⋆6.16 Prove that there exist two languages A and B that are Turing-incomparable—that
is, where A ̸≤T B and B ̸≤T A.
⋆6.17 Let A and B be two disjoint languages. Say that language C separates A and B
if A ⊆C and B ⊆C. Describe two disjoint Turing-recognizable languages that
aren’t separable by any decidable language.
6.18 Show that EQTM is recognizable by a Turing machine with an oracle for ATM.
6.19 In Corollary 4.18, we showed that the set of all languages is uncountable. Use this
result to prove that languages exist that are not recognizable by an oracle Turing
machine with an oracle for ATM.
6.20 Recall the Post Correspondence Problem that we deﬁned in Section 5.2 and its
associated language PCP. Show that PCP is decidable relative to ATM.
6.21 Show how to compute the descriptive complexity of strings K(x) with an oracle
for ATM.
6.22 Use the result of Problem 6.21 to give a function f that is computable with an
oracle for ATM, where for each n, f(n) is an incompressible string of length n.
6.23 Show that the function K(x) is not a computable function.
6.24 Show that the set of incompressible strings is undecidable.
6.25 Show that the set of incompressible strings contains no inﬁnite subset that is
Turing-recognizable.
⋆6.26 Show that for any c, some strings x and y exist, where K(xy) > K(x) + K(y) + c.
6.27 Let S = {⟨M⟩| M is a TM and L(M) = {⟨M⟩} }. Show that neither S nor S is
Turing-recognizable.
6.28 Let R ⊆N k be a k-ary relation. Say that R is deﬁnable in Th(N, +) if we can
give a formula φ with k free variables x1, . . . , xk such that for all a1, . . . , ak ∈N,
φ(a1, . . . , ak) is true exactly when a1, . . . , ak ∈R. Show that each of the following
relations is deﬁnable in Th(N, +).
Aa. R0 = {0}
b. R1 = {1}
c. R= = {(a, a)| a ∈N}
d. R< = {(a, b)| a, b ∈N and a < b}
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

272
CHAPTER 6 / ADVANCED TOPICS IN COMPUTABILITY THEORY
SELECTED SOLUTIONS
6.3
Say that M B
1 decides A and M C
2 decides B. Use an oracle TM M3, where M C
3
decides A. Machine M3 simulates M1. Every time M1 queries its oracle about
some string x, machine M3 tests whether x ∈B and provides the answer to M1.
Because machine M3 doesn’t have an oracle for B and cannot perform that test
directly, it simulates M2 on input x to obtain that information. Machine M3 can
obtain the answer to M2’s queries directly because these two machines use the same
oracle, C.
6.5
The statement ∃x ∀y

x+y=y

is a member of Th(N, +) because that statement
is true for the standard interpretation of + over the universe N. Recall that we
use N = {0, 1, 2, . . .} in this chapter and so we may use x = 0. The statement
∃x ∀y

x+y=x

is not a member of Th(N, +) because that statement isn’t true in
this model. For any value of x, setting y = 1 causes x+y=x to fail.
6.9
Assume for the sake of contradiction that some TM X decides a property P, and P
satisﬁes the conditions of Rice’s theorem. One of these conditions says that TMs A
and B exist where ⟨A⟩∈P and ⟨B⟩̸∈P. Use A and B to construct TM R:
R = “On input w:
1.
Obtain own description ⟨R⟩using the recursion theorem.
2.
Run X on ⟨R⟩.
3.
If X accepts ⟨R⟩, simulate B on w.
If X rejects ⟨R⟩, simulate A on w.”
If ⟨R⟩∈P, then X accepts ⟨R⟩and L(R) = L(B). But ⟨B⟩̸∈P, contradicting
⟨R⟩∈P, because P agrees on TMs that have the same language. We arrive at
a similar contradiction if ⟨R⟩̸∈P. Therefore, our original assumption is false.
Every property satisfying the conditions of Rice’s theorem is undecidable.
6.10
The statement φeq gives the three conditions of an equivalence relation. A model
(A, R1), where A is any universe and R1 is any equivalence relation over A, is a
model of φeq. For example, let A be the integers Z and let R1 = {(i, i)| i ∈Z}.
6.12
Reduce Th(N, <) to Th(N, +), which we’ve already shown to be decidable. Show
how to convert a sentence φ1 over the language of (N, <) to a sentence φ2 over
the language of (N, +) while preserving truth or falsity in the respective models.
Replace every occurrence of i < j in φ1 with the formula ∃k

(i+k=j)∧(k+k̸=k)

in φ2, where k is a different new variable each time.
Sentence φ2 is equivalent to φ1 because “i is less than j” means that we can add
a nonzero value to i and obtain j. Putting φ2 into prenex-normal form, as re-
quired by the algorithm for deciding Th(N, +), requires a bit of additional work.
The new existential quantiﬁers are brought to the front of the sentence. To do
so, these quantiﬁers must pass through Boolean operations that appear in the sen-
tence. Quantiﬁers can be brought through the operations of ∧and ∨without
change. Passing through ¬ changes ∃to ∀and vice versa. Thus, ¬∃k ψ becomes
the equivalent expression ∀k ¬ψ, and ¬∀k ψ becomes ∃k ¬ψ.
6.28
(a) R0 is deﬁnable in Th(N, +) by φ0(x) = ∀y[x + y = y].
(c) R= is deﬁnable in Th(N, +) by φ=(u, v) = ∀x[φ0(x) →x+u=v].
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PART THREE
C O M P L E X I T Y
T H E O R Y
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7
T I M E C O M P L E X I T Y
Even when a problem is decidable and thus computationally solvable in prin-
ciple, it may not be solvable in practice if the solution requires an inordinate
amount of time or memory. In this ﬁnal part of the book, we introduce com-
putational complexity theory—an investigation of the time, memory, or other
resources required for solving computational problems. We begin with time.
Our objective in this chapter is to present the basics of time complexity theory.
First we introduce a way of measuring the time used to solve a problem. Then we
show how to classify problems according to the amount of time required. After
that we discuss the possibility that certain decidable problems require enormous
amounts of time, and how to determine when you are faced with such a problem.
7.1
MEASURING COMPLEXITY
Let’s begin with an example. Take the language A = {0k1k| k ≥0}. Obviously,
A is a decidable language. How much time does a single-tape Turing machine
need to decide A? We examine the following single-tape TM M1 for A. We give
275
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

276
CHAPTER 7 / TIME COMPLEXITY
the Turing machine description at a low level, including the actual head motion
on the tape so that we can count the number of steps that M1 uses when it runs.
M1 = “On input string w:
1.
Scan across the tape and reject if a 0 is found to the right of a 1.
2.
Repeat if both 0s and 1s remain on the tape:
3.
Scan across the tape, crossing off a single 0 and a single 1.
4.
If 0s still remain after all the 1s have been crossed off, or if 1s
still remain after all the 0s have been crossed off, reject. Other-
wise, if neither 0s nor 1s remain on the tape, accept.”
We will analyze the algorithm for TM M1 deciding A to determine how much
time it uses. First, we introduce some terminology and notation for this purpose.
The number of steps that an algorithm uses on a particular input may depend
on several parameters. For instance, if the input is a graph, the number of steps
may depend on the number of nodes, the number of edges, and the maximum
degree of the graph, or some combination of these and/or other factors. For
simplicity, we compute the running time of an algorithm purely as a function
of the length of the string representing the input and don’t consider any other
parameters. In worst-case analysis, the form we consider here, we consider the
longest running time of all inputs of a particular length. In average-case anal-
ysis, we consider the average of all the running times of inputs of a particular
length.
DEFINITION
7.1
Let M be a deterministic Turing machine that halts on all in-
puts. The running time or time complexity of M is the function
f : N −→N, where f(n) is the maximum number of steps that M
uses on any input of length n. If f(n) is the running time of M,
we say that M runs in time f(n) and that M is an f(n) time Tur-
ing machine. Customarily we use n to represent the length of the
input.
BIG-O AND SMALL-O NOTATION
Because the exact running time of an algorithm often is a complex expression,
we usually just estimate it. In one convenient form of estimation, called asymp-
totic analysis, we seek to understand the running time of the algorithm when
it is run on large inputs. We do so by considering only the highest order term
of the expression for the running time of the algorithm, disregarding both the
coefﬁcient of that term and any lower order terms, because the highest order
term dominates the other terms on large inputs.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.1
MEASURING COMPLEXITY
277
For example, the function f(n) = 6n3 + 2n2 + 20n + 45 has four terms
and the highest order term is 6n3. Disregarding the coefﬁcient 6, we say that
f is asymptotically at most n3. The asymptotic notation or big-O notation for
describing this relationship is f(n) = O(n3). We formalize this notion in the
following deﬁnition. Let R+ be the set of nonnegative real numbers.
DEFINITION
7.2
Let f and g be functions f, g: N −→R+. Say that f(n) = O(g(n))
if positive integers c and n0 exist such that for every integer n ≥n0,
f(n) ≤c g(n).
When f(n) = O(g(n)), we say that g(n) is an upper bound for
f(n), or more precisely, that g(n) is an asymptotic upper bound for
f(n), to emphasize that we are suppressing constant factors.
Intuitively, f(n) = O(g(n)) means that f is less than or equal to g if we
disregard differences up to a constant factor.
You may think of O as rep-
resenting a suppressed constant.
In practice, most functions f that you are
likely to encounter have an obvious highest order term h. In that case, write
f(n) = O(g(n)), where g is h without its coefﬁcient.
EXAMPLE
7.3
Let f1(n) be the function 5n3 +2n2 +22n+6. Then, selecting the highest order
term 5n3 and disregarding its coefﬁcient 5 gives f1(n) = O(n3).
Let’s verify that this result satisﬁes the formal deﬁnition. We do so by letting
c be 6 and n0 be 10. Then, 5n3 + 2n2 + 22n + 6 ≤6n3 for every n ≥10.
In addition, f1(n) = O(n4) because n4 is larger than n3 and so is still an
asymptotic upper bound on f1.
However, f1(n) is not O(n2). Regardless of the values we assign to c and n0,
the deﬁnition remains unsatisﬁed in this case.
EXAMPLE
7.4
The big-O interacts with logarithms in a particular way. Usually when we use
logarithms, we must specify the base, as in x = log2 n. The base 2 here indicates
that this equality is equivalent to the equality 2x = n. Changing the value of
the base b changes the value of logb n by a constant factor, owing to the identity
logb n = log2 n/ log2 b. Thus, when we write f(n) = O(log n), specifying the
base is no longer necessary because we are suppressing constant factors anyway.
Let f2(n) be the function 3n log2 n + 5n log2 log2 n + 2. In this case, we have
f2(n) = O(n log n) because log n dominates log log n.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

278
CHAPTER 7 / TIME COMPLEXITY
Big-O notation also appears in arithmetic expressions such as the expression
f(n) = O(n2) + O(n). In that case, each occurrence of the O symbol represents
a different suppressed constant. Because the O(n2) term dominates the O(n)
term, that expression is equivalent to f(n) = O(n2). When the O symbol occurs
in an exponent, as in the expression f(n) = 2O(n), the same idea applies. This
expression represents an upper bound of 2cn for some constant c.
The expression f(n) = 2O(log n) occurs in some analyses. Using the identity
n = 2log2 n and thus nc = 2c log2 n, we see that 2O(log n) represents an upper
bound of nc for some c. The expression nO(1) represents the same bound in a
different way because the expression O(1) represents a value that is never more
than a ﬁxed constant.
Frequently, we derive bounds of the form nc for c greater than 0. Such bounds
are called polynomial bounds. Bounds of the form 2(nδ) are called exponential
bounds when δ is a real number greater than 0.
Big-O notation has a companion called small-o notation. Big-O notation says
that one function is asymptotically no more than another. To say that one func-
tion is asymptotically less than another, we use small-o notation. The difference
between the big-O and small-o notations is analogous to the difference between
≤and <.
DEFINITION
7.5
Let f and g be functions f, g: N −→R+. Say that f(n) = o(g(n))
if
lim
n→∞
f(n)
g(n) = 0.
In other words, f(n) = o(g(n)) means that for any real number
c > 0, a number n0 exists, where f(n) < c g(n) for all n ≥n0.
EXAMPLE
7.6
The following are easy to check.
1. √n = o(n).
2. n = o(n log log n).
3. n log log n = o(n log n).
4. n log n = o(n2).
5. n2 = o(n3).
However, f(n) is never o(f(n)).
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.1
MEASURING COMPLEXITY
279
ANALYZING ALGORITHMS
Let’s analyze the TM algorithm we gave for the language A = {0k1k|k ≥0}. We
repeat the algorithm here for convenience.
M1 = “On input string w:
1.
Scan across the tape and reject if a 0 is found to the right of a 1.
2.
Repeat if both 0s and 1s remain on the tape:
3.
Scan across the tape, crossing off a single 0 and a single 1.
4.
If 0s still remain after all the 1s have been crossed off, or if 1s
still remain after all the 0s have been crossed off, reject. Other-
wise, if neither 0s nor 1s remain on the tape, accept.”
To analyze M1, we consider each of its four stages separately. In stage 1,
the machine scans across the tape to verify that the input is of the form 0∗1∗.
Performing this scan uses n steps. As we mentioned earlier, we typically use n
to represent the length of the input. Repositioning the head at the left-hand
end of the tape uses another n steps. So the total used in this stage is 2n steps.
In big-O notation, we say that this stage uses O(n) steps. Note that we didn’t
mention the repositioning of the tape head in the machine description. Using
asymptotic notation allows us to omit details of the machine description that
affect the running time by at most a constant factor.
In stages 2 and 3, the machine repeatedly scans the tape and crosses off a 0
and 1 on each scan. Each scan uses O(n) steps. Because each scan crosses off
two symbols, at most n/2 scans can occur. So the total time taken by stages 2
and 3 is (n/2)O(n) = O(n2) steps.
In stage 4, the machine makes a single scan to decide whether to accept or
reject. The time taken in this stage is at most O(n).
Thus, the total time of M1 on an input of length n is O(n) + O(n2) + O(n),
or O(n2). In other words, its running time is O(n2), which completes the time
analysis of this machine.
Let’s set up some notation for classifying languages according to their time
requirements.
DEFINITION
7.7
Let t: N −→R+ be a function. Deﬁne the time complexity class,
TIME(t(n)), to be the collection of all languages that are decid-
able by an O(t(n)) time Turing machine.
Recall the language A = {0k1k| k ≥0}. The preceding analysis shows that
A ∈TIME(n2) because M1 decides A in time O(n2) and TIME(n2) contains all
languages that can be decided in O(n2) time.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

280
CHAPTER 7 / TIME COMPLEXITY
Is there a machine that decides A asymptotically more quickly? In other
words, is A in TIME(t(n)) for t(n) = o(n2)? We can improve the running
time by crossing off two 0s and two 1s on every scan instead of just one because
doing so cuts the number of scans by half. But that improves the running time
only by a factor of 2 and doesn’t affect the asymptotic running time. The fol-
lowing machine, M2, uses a different method to decide A asymptotically faster.
It shows that A ∈TIME(n log n).
M2 = “On input string w:
1.
Scan across the tape and reject if a 0 is found to the right of a 1.
2.
Repeat as long as some 0s and some 1s remain on the tape:
3.
Scan across the tape, checking whether the total number of
0s and 1s remaining is even or odd. If it is odd, reject.
4.
Scan again across the tape, crossing off every other 0 starting
with the ﬁrst 0, and then crossing off every other 1 starting
with the ﬁrst 1.
5.
If no 0s and no 1s remain on the tape, accept.
Otherwise,
reject.”
Before analyzing M2, let’s verify that it actually decides A. On every scan
performed in stage 4, the total number of 0s remaining is cut in half and any
remainder is discarded. Thus, if we started with 13 0s, after stage 4 is executed a
single time, only 6 0s remain. After subsequent executions of this stage, 3, then
1, and then 0 remain. This stage has the same effect on the number of 1s.
Now we examine the even/odd parity of the number of 0s and the number
of 1s at each execution of stage 3. Consider again starting with 13 0s and 13
1s. The ﬁrst execution of stage 3 ﬁnds an odd number of 0s (because 13 is an
odd number) and an odd number of 1s. On subsequent executions, an even
number (6) occurs, then an odd number (3), and an odd number (1). We do not
execute this stage on 0 0s or 0 1s because of the condition on the repeat loop
speciﬁed in stage 2. For the sequence of parities found (odd, even, odd, odd), if
we replace the evens with 0s and the odds with 1s and then reverse the sequence,
we obtain 1101, the binary representation of 13, or the number of 0s and 1s at
the beginning. The sequence of parities always gives the reverse of the binary
representation.
When stage 3 checks to determine that the total number of 0s and 1s re-
maining is even, it actually is checking on the agreement of the parity of the 0s
with the parity of the 1s. If all parities agree, the binary representations of the
numbers of 0s and of 1s agree, and so the two numbers are equal.
To analyze the running time of M2, we ﬁrst observe that every stage takes
O(n) time.
We then determine the number of times that each is executed.
Stages 1 and 5 are executed once, taking a total of O(n) time. Stage 4 crosses
off at least half the 0s and 1s each time it is executed, so at most 1 + log2 n iter-
ations of the repeat loop occur before all get crossed off. Thus the total time of
stages 2, 3, and 4 is (1 + log2 n)O(n), or O(n log n). The running time of M2 is
O(n) + O(n log n) = O(n log n).
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.1
MEASURING COMPLEXITY
281
Earlier we showed that A ∈TIME(n2), but now we have a better bound—
namely, A ∈TIME(n log n). This result cannot be further improved on single-
tape Turing machines. In fact, any language that can be decided in o(n log n)
time on a single-tape Turing machine is regular, as Problem 7.49 asks you to
show.
We can decide the language A in O(n) time (also called linear time) if the
Turing machine has a second tape. The following two-tape TM M3 decides A in
linear time. Machine M3 operates differently from the previous machines for A.
It simply copies the 0s to its second tape and then matches them against the 1s.
M3 = “On input string w:
1.
Scan across tape 1 and reject if a 0 is found to the right of a 1.
2.
Scan across the 0s on tape 1 until the ﬁrst 1. At the same time,
copy the 0s onto tape 2.
3.
Scan across the 1s on tape 1 until the end of the input. For each
1 read on tape 1, cross off a 0 on tape 2. If all 0s are crossed off
before all the 1s are read, reject.
4.
If all the 0s have now been crossed off, accept. If any 0s remain,
reject.”
This machine is simple to analyze. Each of the four stages uses O(n) steps, so
the total running time is O(n) and thus is linear. Note that this running time is
the best possible because n steps are necessary just to read the input.
Let’s summarize what we have shown about the time complexity of A, the
amount of time required for deciding A. We produced a single-tape TM M1
that decides A in O(n2) time and a faster single tape TM M2 that decides A in
O(n log n) time. The solution to Problem 7.49 implies that no single-tape TM
can do it more quickly. Then we exhibited a two-tape TM M3 that decides A in
O(n) time. Hence the time complexity of A on a single-tape TM is O(n log n),
and on a two-tape TM it is O(n). Note that the complexity of A depends on the
model of computation selected.
This discussion highlights an important difference between complexity the-
ory and computability theory. In computability theory, the Church–Turing thesis
implies that all reasonable models of computation are equivalent—that is, they
all decide the same class of languages. In complexity theory, the choice of model
affects the time complexity of languages. Languages that are decidable in, say,
linear time on one model aren’t necessarily decidable in linear time on another.
In complexity theory, we classify computational problems according to their
time complexity. But with which model do we measure time? The same language
may have different time requirements on different models.
Fortunately, time requirements don’t differ greatly for typical deterministic
models. So, if our classiﬁcation system isn’t very sensitive to relatively small
differences in complexity, the choice of deterministic model isn’t crucial. We
discuss this idea further in the next several sections.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

282
CHAPTER 7 / TIME COMPLEXITY
COMPLEXITY RELATIONSHIPS AMONG MODELS
Here we examine how the choice of computational model can affect the time
complexity of languages. We consider three models: the single-tape Turing ma-
chine; the multitape Turing machine; and the nondeterministic Turing machine.
THEOREM
7.8
Let t(n) be a function, where t(n) ≥n. Then every t(n) time multitape Turing
machine has an equivalent O(t2(n)) time single-tape Turing machine.
PROOF IDEA
The idea behind the proof of this theorem is quite simple.
Recall that in Theorem 3.13, we showed how to convert any multitape TM into
a single-tape TM that simulates it. Now we analyze that simulation to determine
how much additional time it requires. We show that simulating each step of
the multitape machine uses at most O(t(n)) steps on the single-tape machine.
Hence the total time used is O(t2(n)) steps.
PROOF
Let M be a k-tape TM that runs in t(n) time. We construct a single-
tape TM S that runs in O(t2(n)) time.
Machine S operates by simulating M, as described in Theorem 3.13. To
review that simulation, we recall that S uses its single tape to represent the con-
tents on all k of M’s tapes. The tapes are stored consecutively, with the positions
of M’s heads marked on the appropriate squares.
Initially, S puts its tape into the format that represents all the tapes of M
and then simulates M’s steps. To simulate one step, S scans all the information
stored on its tape to determine the symbols under M’s tape heads. Then S makes
another pass over its tape to update the tape contents and head positions. If one
of M’s heads moves rightward onto the previously unread portion of its tape, S
must increase the amount of space allocated to this tape. It does so by shifting a
portion of its own tape one cell to the right.
Now we analyze this simulation. For each step of M, machine S makes two
passes over the active portion of its tape. The ﬁrst obtains the information nec-
essary to determine the next move and the second carries it out. The length
of the active portion of S’s tape determines how long S takes to scan it, so we
must determine an upper bound on this length. To do so, we take the sum of the
lengths of the active portions of M’s k tapes. Each of these active portions has
length at most t(n) because M uses t(n) tape cells in t(n) steps if the head moves
rightward at every step, and even fewer if a head ever moves leftward. Thus, a
scan of the active portion of S’s tape uses O(t(n)) steps.
To simulate each of M’s steps, S performs two scans and possibly up to k
rightward shifts. Each uses O(t(n)) time, so the total time for S to simulate one
of M’s steps is O(t(n)).
Now we bound the total time used by the simulation. The initial stage, where
S puts its tape into the proper format, uses O(n) steps. Afterward, S simulates
each of the t(n) steps of M, using O(t(n)) steps, so this part of the simulation
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.1
MEASURING COMPLEXITY
283
uses t(n) × O(t(n)) = O(t2(n)) steps. Therefore, the entire simulation of M
uses O(n) + O(t2(n)) steps.
We have assumed that t(n) ≥n (a reasonable assumption because M could
not even read the entire input in less time). Therefore, the running time of S is
O(t2(n)) and the proof is complete.
Next, we consider the analogous theorem for nondeterministic single-tape
Turing machines. We show that any language that is decidable on such a ma-
chine is decidable on a deterministic single-tape Turing machine that requires
signiﬁcantly more time. Before doing so, we must deﬁne the running time of
a nondeterministic Turing machine. Recall that a nondeterministic Turing ma-
chine is a decider if all its computation branches halt on all inputs.
DEFINITION
7.9
Let N be a nondeterministic Turing machine that is a decider. The
running time of N is the function f : N −→N, where f(n) is the
maximum number of steps that N uses on any branch of its com-
putation on any input of length n, as shown in the following ﬁgure.
  
  
FIGURE
7.10
Measuring deterministic and nondeterministic time
The deﬁnition of the running time of a nondeterministic Turing machine is
not intended to correspond to any real-world computing device. Rather, it is a
useful mathematical deﬁnition that assists in characterizing the complexity of an
important class of computational problems, as we demonstrate shortly.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

284
CHAPTER 7 / TIME COMPLEXITY
THEOREM
7.11
Let t(n) be a function, where t(n) ≥n. Then every t(n) time nondeterministic
single-tape Turing machine has an equivalent 2O(t(n)) time deterministic single-
tape Turing machine.
PROOF
Let N be a nondeterministic TM running in t(n) time. We construct a
deterministic TM D that simulates N as in the proof of Theorem 3.16 by search-
ing N’s nondeterministic computation tree. Now we analyze that simulation.
On an input of length n, every branch of N’s nondeterministic computation
tree has a length of at most t(n). Every node in the tree can have at most b
children, where b is the maximum number of legal choices given by N’s transition
function. Thus, the total number of leaves in the tree is at most bt(n).
The simulation proceeds by exploring this tree breadth ﬁrst. In other words,
it visits all nodes at depth d before going on to any of the nodes at depth d + 1.
The algorithm given in the proof of Theorem 3.16 inefﬁciently starts at the root
and travels down to a node whenever it visits that node. But eliminating this
inefﬁciency doesn’t alter the statement of the current theorem, so we leave it
as is. The total number of nodes in the tree is less than twice the maximum
number of leaves, so we bound it by O(bt(n)). The time it takes to start from the
root and travel down to a node is O(t(n)). Therefore, the running time of D is
O(t(n)bt(n)) = 2O(t(n)).
As described in Theorem 3.16, the TM D has three tapes. Converting to a
single-tape TM at most squares the running time, by Theorem 7.8. Thus, the
running time of the single-tape simulator is (2O(t(n)))
2 = 2O(2t(n)) = 2O(t(n))
and the theorem is proved.
7.2
THE CLASS P
Theorems 7.8 and 7.11 illustrate an important distinction. On the one hand, we
demonstrated at most a square or polynomial difference between the time com-
plexity of problems measured on deterministic single-tape and multitape Turing
machines. On the other hand, we showed at most an exponential difference be-
tween the time complexity of problems on deterministic and nondeterministic
Turing machines.
POLYNOMIAL TIME
For our purposes, polynomial differences in running time are considered to be
small, whereas exponential differences are considered to be large. Let’s look at
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.2
THE CLASS P
285
why we chose to make this separation between polynomials and exponentials
rather than between some other classes of functions.
First, note the dramatic difference between the growth rate of typically oc-
curring polynomials such as n3 and typically occurring exponentials such as 2n.
For example, let n be 1000, the size of a reasonable input to an algorithm. In
that case, n3 is 1 billion, a large but manageable number, whereas 2n is a num-
ber much larger than the number of atoms in the universe. Polynomial time
algorithms are fast enough for many purposes, but exponential time algorithms
rarely are useful.
Exponential time algorithms typically arise when we solve problems by ex-
haustively searching through a space of solutions, called brute-force search. For
example, one way to factor a number into its constituent primes is to search
through all potential divisors. The size of the search space is exponential, so
this search uses exponential time. Sometimes brute-force search may be avoided
through a deeper understanding of a problem, which may reveal a polynomial
time algorithm of greater utility.
All reasonable deterministic computational models are polynomially equiv-
alent. That is, any one of them can simulate another with only a polynomial
increase in running time. When we say that all reasonable deterministic models
are polynomially equivalent, we do not attempt to deﬁne reasonable. However,
we have in mind a notion broad enough to include models that closely approxi-
mate running times on actual computers. For example, Theorem 7.8 shows that
the deterministic single-tape and multitape Turing machine models are polyno-
mially equivalent.
From here on we focus on aspects of time complexity theory that are unaf-
fected by polynomial differences in running time. Ignoring these differences
allows us to develop a theory that doesn’t depend on the selection of a partic-
ular model of computation. Remember, our aim is to present the fundamental
properties of computation, rather than properties of Turing machines or any other
special model.
You may feel that disregarding polynomial differences in running time is ab-
surd. Real programmers certainly care about such differences and work hard just
to make their programs run twice as quickly. However, we disregarded constant
factors a while back when we introduced asymptotic notation. Now we propose
to disregard the much greater polynomial differences, such as that between time
n and time n3.
Our decision to disregard polynomial differences doesn’t imply that we con-
sider such differences unimportant. On the contrary, we certainly do consider
the difference between time n and time n3 to be an important one. But some
questions, such as the polynomiality or nonpolynomiality of the factoring prob-
lem, do not depend on polynomial differences and are important, too.
We
merely choose to focus on this type of question here. Ignoring the trees to see
the forest doesn’t mean that one is more important than the other—it just gives
a different perspective.
Now we come to an important deﬁnition in complexity theory.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

286
CHAPTER 7 / TIME COMPLEXITY
DEFINITION
7.12
P is the class of languages that are decidable in polynomial time on
a deterministic single-tape Turing machine. In other words,
P =
[
k
TIME(nk).
The class P plays a central role in our theory and is important because
1. P is invariant for all models of computation that are polynomially equiva-
lent to the deterministic single-tape Turing machine, and
2. P roughly corresponds to the class of problems that are realistically solv-
able on a computer.
Item 1 indicates that P is a mathematically robust class. It isn’t affected by the
particulars of the model of computation that we are using.
Item 2 indicates that P is relevant from a practical standpoint.
When a
problem is in P, we have a method of solving it that runs in time nk for some
constant k. Whether this running time is practical depends on k and on the
application. Of course, a running time of n100 is unlikely to be of any practical
use. Nevertheless, calling polynomial time the threshold of practical solvability
has proven to be useful. Once a polynomial time algorithm has been found for
a problem that formerly appeared to require exponential time, some key insight
into it has been gained and further reductions in its complexity usually follow,
often to the point of actual practical utility.
EXAMPLES OF PROBLEMS IN P
When we present a polynomial time algorithm, we give a high-level description
of it without reference to features of a particular computational model. Doing so
avoids tedious details of tapes and head motions. We follow certain conventions
when describing an algorithm so that we can analyze it for polynomiality.
We continue to describe algorithms with numbered stages. Now we must
be sensitive to the number of Turing machine steps required to implement each
stage, as well as to the total number of stages that the algorithm uses.
When we analyze an algorithm to show that it runs in polynomial time, we
need to do two things. First, we have to give a polynomial upper bound (usu-
ally in big-O notation) on the number of stages that the algorithm uses when it
runs on an input of length n. Then, we have to examine the individual stages
in the description of the algorithm to be sure that each can be implemented in
polynomial time on a reasonable deterministic model. We choose the stages
when we describe the algorithm to make this second part of the analysis easy to
do. When both tasks have been completed, we can conclude that the algorithm
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.2
THE CLASS P
287
runs in polynomial time because we have demonstrated that it runs for a poly-
nomial number of stages, each of which can be done in polynomial time, and the
composition of polynomials is a polynomial.
One point that requires attention is the encoding method used for problems.
We continue to use the angle-bracket notation ⟨·⟩to indicate a reasonable en-
coding of one or more objects into a string, without specifying any particular
encoding method. Now, a reasonable method is one that allows for polyno-
mial time encoding and decoding of objects into natural internal representations
or into other reasonable encodings. Familiar encoding methods for graphs, au-
tomata, and the like all are reasonable. But note that unary notation for encoding
numbers (as in the number 17 encoded by the unary string 11111111111111111)
isn’t reasonable because it is exponentially larger than truly reasonable encod-
ings, such as base k notation for any k ≥2.
Many computational problems you encounter in this chapter contain encod-
ings of graphs. One reasonable encoding of a graph is a list of its nodes and
edges. Another is the adjacency matrix, where the (i, j)th entry is 1 if there is
an edge from node i to node j and 0 if not. When we analyze algorithms on
graphs, the running time may be computed in terms of the number of nodes
instead of the size of the graph representation. In reasonable graph represen-
tations, the size of the representation is a polynomial in the number of nodes.
Thus, if we analyze an algorithm and show that its running time is polynomial
(or exponential) in the number of nodes, we know that it is polynomial (or expo-
nential) in the size of the input.
The ﬁrst problem concerns directed graphs. A directed graph G contains
nodes s and t, as shown in the following ﬁgure. The PATH problem is to deter-
mine whether a directed path exists from s to t. Let
PATH = {⟨G, s, t⟩| G is a directed graph that has a directed path from s to t}.
FIGURE
7.13
The PATH problem: Is there a path from s to t?
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

288
CHAPTER 7 / TIME COMPLEXITY
THEOREM
7.14
PATH ∈P.
PROOF IDEA
We prove this theorem by presenting a polynomial time algo-
rithm that decides PATH. Before describing that algorithm, let’s observe that a
brute-force algorithm for this problem isn’t fast enough.
A brute-force algorithm for PATH proceeds by examining all potential paths
in G and determining whether any is a directed path from s to t. A potential path
is a sequence of nodes in G having a length of at most m, where m is the number
of nodes in G. (If any directed path exists from s to t, one having a length of at
most m exists because repeating a node never is necessary.) But the number of
such potential paths is roughly mm, which is exponential in the number of nodes
in G. Therefore, this brute-force algorithm uses exponential time.
To get a polynomial time algorithm for PATH, we must do something that
avoids brute force. One way is to use a graph-searching method such as breadth-
ﬁrst search. Here, we successively mark all nodes in G that are reachable from s
by directed paths of length 1, then 2, then 3, through m. Bounding the running
time of this strategy by a polynomial is easy.
PROOF
A polynomial time algorithm M for PATH operates as follows.
M = “On input ⟨G, s, t⟩, where G is a directed graph with nodes s and t:
1.
Place a mark on node s.
2.
Repeat the following until no additional nodes are marked:
3.
Scan all the edges of G. If an edge (a, b) is found going from
a marked node a to an unmarked node b, mark node b.
4.
If t is marked, accept. Otherwise, reject.”
Now we analyze this algorithm to show that it runs in polynomial time. Ob-
viously, stages 1 and 4 are executed only once. Stage 3 runs at most m times
because each time except the last it marks an additional node in G. Thus, the
total number of stages used is at most 1 + 1 + m, giving a polynomial in the size
of G.
Stages 1 and 4 of M are easily implemented in polynomial time on any rea-
sonable deterministic model. Stage 3 involves a scan of the input and a test of
whether certain nodes are marked, which also is easily implemented in polyno-
mial time. Hence M is a polynomial time algorithm for PATH.
Let’s turn to another example of a polynomial time algorithm. Say that two
numbers are relatively prime if 1 is the largest integer that evenly divides them
both. For example, 10 and 21 are relatively prime, even though neither of them
is a prime number by itself, whereas 10 and 22 are not relatively prime because
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.2
THE CLASS P
289
both are divisible by 2. Let RELPRIME be the problem of testing whether two
numbers are relatively prime. Thus
RELPRIME = {⟨x, y⟩| x and y are relatively prime}.
THEOREM
7.15
RELPRIME ∈P.
PROOF IDEA
One algorithm that solves this problem searches through all
possible divisors of both numbers and accepts if none are greater than 1. How-
ever, the magnitude of a number represented in binary, or in any other base k
notation for k ≥2, is exponential in the length of its representation. Therefore,
this brute-force algorithm searches through an exponential number of potential
divisors and has an exponential running time.
Instead, we solve this problem with an ancient numerical procedure, called
the Euclidean algorithm, for computing the greatest common divisor.
The
greatest common divisor of natural numbers x and y, written gcd(x, y), is the
largest integer that evenly divides both x and y. For example, gcd(18, 24) = 6.
Obviously, x and y are relatively prime iff gcd(x, y) = 1. We describe the Eu-
clidean algorithm as algorithm E in the proof. It uses the mod function, where
x mod y is the remainder after the integer division of x by y.
PROOF
The Euclidean algorithm E is as follows.
E = “On input ⟨x, y⟩, where x and y are natural numbers in binary:
1.
Repeat until y = 0:
2.
Assign x ←x mod y.
3.
Exchange x and y.
4.
Output x.”
Algorithm R solves RELPRIME, using E as a subroutine.
R = “On input ⟨x, y⟩, where x and y are natural numbers in binary:
1.
Run E on ⟨x, y⟩.
2.
If the result is 1, accept. Otherwise, reject.”
Clearly, if E runs correctly in polynomial time, so does R and hence we only
need to analyze E for time and correctness. The correctness of this algorithm is
well known so we won’t discuss it further here.
To analyze the time complexity of E, we ﬁrst show that every execution of
stage 2 (except possibly the ﬁrst) cuts the value of x by at least half. After stage 2
is executed, x < y because of the nature of the mod function. After stage 3,
x > y because the two have been exchanged. Thus, when stage 2 is subsequently
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

290
CHAPTER 7 / TIME COMPLEXITY
executed, x > y. If x/2 ≥y, then x mod y < y ≤x/2 and x drops by at least
half. If x/2 < y, then x mod y = x −y < x/2 and x drops by at least half.
The values of x and y are exchanged every time stage 3 is executed, so each
of the original values of x and y are reduced by at least half every other time
through the loop. Thus, the maximum number of times that stages 2 and 3 are
executed is the lesser of 2 log2 x and 2 log2 y. These logarithms are proportional
to the lengths of the representations, giving the number of stages executed as
O(n). Each stage of E uses only polynomial time, so the total running time is
polynomial.
The ﬁnal example of a polynomial time algorithm shows that every context-
free language is decidable in polynomial time.
THEOREM
7.16
Every context-free language is a member of P.
PROOF IDEA
In Theorem 4.9, we proved that every CFL is decidable. To
do so, we gave an algorithm for each CFL that decides it. If that algorithm runs
in polynomial time, the current theorem follows as a corollary. Let’s recall that
algorithm and ﬁnd out whether it runs quickly enough.
Let L be a CFL generated by CFG G that is in Chomsky normal form. From
Problem 2.26, any derivation of a string w has 2n−1 steps, where n is the length
of w because G is in Chomsky normal form. The decider for L works by trying
all possible derivations with 2n −1 steps when its input is a string of length n. If
any of these is a derivation of w, the decider accepts; if not, it rejects.
A quick analysis of this algorithm shows that it doesn’t run in polynomial
time. The number of derivations with k steps may be exponential in k, so this
algorithm may require exponential time.
To get a polynomial time algorithm, we introduce a powerful technique called
dynamic programming. This technique uses the accumulation of information
about smaller subproblems to solve larger problems. We record the solution to
any subproblem so that we need to solve it only once. We do so by making a
table of all subproblems and entering their solutions systematically as we ﬁnd
them.
In this case, we consider the subproblems of determining whether each vari-
able in G generates each substring of w. The algorithm enters the solution to
this subproblem in an n × n table. For i ≤j, the (i, j)th entry of the table con-
tains the collection of variables that generate the substring wiwi+1 · · · wj. For
i > j, the table entries are unused.
The algorithm ﬁlls in the table entries for each substring of w. First it ﬁlls
in the entries for the substrings of length 1, then those of length 2, and so on.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.2
THE CLASS P
291
It uses the entries for the shorter lengths to assist in determining the entries for
the longer lengths.
For example, suppose that the algorithm has already determined which vari-
ables generate all substrings up to length k. To determine whether a variable A
generates a particular substring of length k+1, the algorithm splits that substring
into two nonempty pieces in the k possible ways. For each split, the algorithm
examines each rule A →BC to determine whether B generates the ﬁrst piece
and C generates the second piece, using table entries previously computed. If
both B and C generate the respective pieces, A generates the substring and so
is added to the associated table entry. The algorithm starts the process with the
strings of length 1 by examining the table for the rules A →b.
PROOF
The following algorithm D implements the proof idea. Let G be
a CFG in Chomsky normal form generating the CFL L. Assume that S is the
start variable. (Recall that the empty string is handled specially in a Chomsky
normal form grammar. The algorithm handles the special case in which w = ε
in stage 1.) Comments appear inside double brackets.
D = “On input w = w1 · · · wn:
1.
For w = ε, if S →ε is a rule, accept; else, reject.
[[ w = ε case ]]
2.
For i = 1 to n:
[[ examine each substring of length 1 ]]
3.
For each variable A:
4.
Test whether A →b is a rule, where b = wi.
5.
If so, place A in table(i, i).
6.
For l = 2 to n:
[[ l is the length of the substring ]]
7.
For i = 1 to n −l + 1:
[[ i is the start position of the substring ]]
8.
Let j = i + l −1.
[[ j is the end position of the substring ]]
9.
For k = i to j −1:
[[ k is the split position ]]
10.
For each rule A →BC:
11.
If table(i, k) contains B and table(k + 1, j) contains
C, put A in table(i, j).
12.
If S is in table(1, n), accept; else, reject.”
Now we analyze D. Each stage is easily implemented to run in polynomial
time. Stages 4 and 5 run at most nv times, where v is the number of variables in
G and is a ﬁxed constant independent of n; hence these stages run O(n) times.
Stage 6 runs at most n times. Each time stage 6 runs, stage 7 runs at most n
times. Each time stage 7 runs, stages 8 and 9 run at most n times. Each time
stage 9 runs, stage 10 runs r times, where r is the number of rules of G and
is another ﬁxed constant. Thus stage 11, the inner loop of the algorithm, runs
O(n3) times. Summing the total shows that D executes O(n3) stages.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

292
CHAPTER 7 / TIME COMPLEXITY
7.3
THE CLASS NP
As we observed in Section 7.2, we can avoid brute-force search in many problems
and obtain polynomial time solutions. However, attempts to avoid brute force
in certain other problems, including many interesting and useful ones, haven’t
been successful, and polynomial time algorithms that solve them aren’t known
to exist.
Why have we been unsuccessful in ﬁnding polynomial time algorithms for
these problems? We don’t know the answer to this important question. Perhaps
these problems have as yet undiscovered polynomial time algorithms that rest
on unknown principles. Or possibly some of these problems simply cannot be
solved in polynomial time. They may be intrinsically difﬁcult.
One remarkable discovery concerning this question shows that the complex-
ities of many problems are linked. A polynomial time algorithm for one such
problem can be used to solve an entire class of problems. To understand this
phenomenon, let’s begin with an example.
A Hamiltonian path in a directed graph G is a directed path that goes through
each node exactly once. We consider the problem of testing whether a directed
graph contains a Hamiltonian path connecting two speciﬁed nodes, as shown in
the following ﬁgure. Let
HAMPATH = {⟨G, s, t⟩| G is a directed graph
with a Hamiltonian path from s to t}.
FIGURE
7.17
A Hamiltonian path goes through every node exactly once
We can easily obtain an exponential time algorithm for the HAMPATH prob-
lem by modifying the brute-force algorithm for PATH given in Theorem 7.14.
We need only add a check to verify that the potential path is Hamiltonian. No
one knows whether HAMPATH is solvable in polynomial time.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.3
THE CLASS NP
293
The HAMPATH problem has a feature called polynomial veriﬁability that is
important for understanding its complexity. Even though we don’t know of a fast
(i.e., polynomial time) way to determine whether a graph contains a Hamiltonian
path, if such a path were discovered somehow (perhaps using the exponential
time algorithm), we could easily convince someone else of its existence simply
by presenting it. In other words, verifying the existence of a Hamiltonian path
may be much easier than determining its existence.
Another polynomially veriﬁable problem is compositeness. Recall that a nat-
ural number is composite if it is the product of two integers greater than 1 (i.e., a
composite number is one that is not a prime number). Let
COMPOSITES = {x| x = pq, for integers p, q > 1}.
We can easily verify that a number is composite—all that is needed is a divisor
of that number. Recently, a polynomial time algorithm for testing whether a
number is prime or composite was discovered, but it is considerably more com-
plicated than the preceding method for verifying compositeness.
Some problems may not be polynomially veriﬁable.
For example, take
HAMPATH, the complement of the HAMPATH problem. Even if we could
determine (somehow) that a graph did not have a Hamiltonian path, we don’t
know of a way for someone else to verify its nonexistence without using the
same exponential time algorithm for making the determination in the ﬁrst place.
A formal deﬁnition follows.
DEFINITION
7.18
A veriﬁer for a language A is an algorithm V , where
A = {w| V accepts ⟨w, c⟩for some string c}.
We measure the time of a veriﬁer only in terms of the length of w,
so a polynomial time veriﬁer runs in polynomial time in the length
of w. A language A is polynomially veriﬁable if it has a polynomial
time veriﬁer.
A veriﬁer uses additional information, represented by the symbol c in Deﬁni-
tion 7.18, to verify that a string w is a member of A. This information is called a
certiﬁcate, or proof, of membership in A. Observe that for polynomial veriﬁers,
the certiﬁcate has polynomial length (in the length of w) because that is all the
veriﬁer can access in its time bound. Let’s apply this deﬁnition to the languages
HAMPATH and COMPOSITES.
For the HAMPATH problem, a certiﬁcate for a string ⟨G, s, t⟩∈HAMPATH
simply is a Hamiltonian path from s to t. For the COMPOSITES problem, a
certiﬁcate for the composite number x simply is one of its divisors. In both
cases, the veriﬁer can check in polynomial time that the input is in the language
when it is given the certiﬁcate.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

294
CHAPTER 7 / TIME COMPLEXITY
DEFINITION
7.19
NP is the class of languages that have polynomial time veriﬁers.
The class NP is important because it contains many problems of practical in-
terest. From the preceding discussion, both HAMPATH and COMPOSITES are
members of NP. As we mentioned, COMPOSITES is also a member of P, which
is a subset of NP; but proving this stronger result is much more difﬁcult. The
term NP comes from nondeterministic polynomial time and is derived from an
alternative characterization by using nondeterministic polynomial time Turing
machines. Problems in NP are sometimes called NP-problems.
The following is a nondeterministic Turing machine (NTM) that decides the
HAMPATH problem in nondeterministic polynomial time. Recall that in Def-
inition 7.9, we deﬁned the time of a nondeterministic machine to be the time
used by the longest computation branch.
N1 = “On input ⟨G, s, t⟩, where G is a directed graph with nodes s and t:
1.
Write a list of m numbers, p1, . . . , pm, where m is the number
of nodes in G. Each number in the list is nondeterministically
selected to be between 1 and m.
2.
Check for repetitions in the list. If any are found, reject.
3.
Check whether s = p1 and t = pm. If either fail, reject.
4.
For each i between 1 and m −1, check whether (pi, pi+1) is an
edge of G. If any are not, reject. Otherwise, all tests have been
passed, so accept.”
To analyze this algorithm and verify that it runs in nondeterministic poly-
nomial time, we examine each of its stages. In stage 1, the nondeterministic
selection clearly runs in polynomial time. In stages 2 and 3, each part is a simple
check, so together they run in polynomial time. Finally, stage 4 also clearly runs
in polynomial time. Thus, this algorithm runs in nondeterministic polynomial
time.
THEOREM
7.20
A language is in NP iff it is decided by some nondeterministic polynomial time
Turing machine.
PROOF IDEA
We show how to convert a polynomial time veriﬁer to an
equivalent polynomial time NTM and vice versa. The NTM simulates the ver-
iﬁer by guessing the certiﬁcate. The veriﬁer simulates the NTM by using the
accepting branch as the certiﬁcate.
PROOF
For the forward direction of this theorem, let A ∈NP and show that
A is decided by a polynomial time NTM N. Let V be the polynomial time veriﬁer
for A that exists by the deﬁnition of NP. Assume that V is a TM that runs in time
nk and construct N as follows.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.3
THE CLASS NP
295
N = “On input w of length n:
1.
Nondeterministically select string c of length at most nk.
2.
Run V on input ⟨w, c⟩.
3.
If V accepts, accept; otherwise, reject.”
To prove the other direction of the theorem, assume that A is decided by a
polynomial time NTM N and construct a polynomial time veriﬁer V as follows.
V = “On input ⟨w, c⟩, where w and c are strings:
1.
Simulate N on input w, treating each symbol of c as a descrip-
tion of the nondeterministic choice to make at each step (as in
the proof of Theorem 3.16).
2.
If this branch of N’s computation accepts, accept; otherwise,
reject.”
We deﬁne the nondeterministic time complexity class NTIME(t(n)) as anal-
ogous to the deterministic time complexity class TIME(t(n)).
DEFINITION
7.21
NTIME(t(n)) = {L| L is a language decided by an O(t(n)) time
nondeterministic Turing machine}.
COROLLARY
7.22
NP = S
k NTIME(nk).
The class NP is insensitive to the choice of reasonable nondeterministic com-
putational model because all such models are polynomially equivalent. When
describing and analyzing nondeterministic polynomial time algorithms, we fol-
low the preceding conventions for deterministic polynomial time algorithms.
Each stage of a nondeterministic polynomial time algorithm must have an obvi-
ous implementation in nondeterministic polynomial time on a reasonable non-
deterministic computational model.
We analyze the algorithm to show that
every branch uses at most polynomially many stages.
EXAMPLES OF PROBLEMS IN NP
A clique in an undirected graph is a subgraph, wherein every two nodes are
connected by an edge. A k-clique is a clique that contains k nodes. Figure 7.23
illustrates a graph with a 5-clique.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

296
CHAPTER 7 / TIME COMPLEXITY
FIGURE
7.23
A graph with a 5-clique
The clique problem is to determine whether a graph contains a clique of a
speciﬁed size. Let
CLIQUE = {⟨G, k⟩| G is an undirected graph with a k-clique}.
THEOREM
7.24
CLIQUE is in NP.
PROOF IDEA
The clique is the certiﬁcate.
PROOF
The following is a veriﬁer V for CLIQUE.
V = “On input ⟨⟨G, k⟩, c⟩:
1.
Test whether c is a subgraph with k nodes in G.
2.
Test whether G contains all edges connecting nodes in c.
3.
If both pass, accept; otherwise, reject.”
ALTERNATIVE PROOF
If you prefer to think of NP in terms of nonde-
terministic polynomial time Turing machines, you may prove this theorem by
giving one that decides CLIQUE. Observe the similarity between the two proofs.
N = “On input ⟨G, k⟩, where G is a graph:
1.
Nondeterministically select a subset c of k nodes of G.
2.
Test whether G contains all edges connecting nodes in c.
3.
If yes, accept; otherwise, reject.”
Next, we consider the SUBSET-SUM problem concerning integer arithmetic.
We are given a collection of numbers x1, . . . , xk and a target number t. We want
to determine whether the collection contains a subcollection that adds up to t.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.3
THE CLASS NP
297
Thus,
SUBSET-SUM = {⟨S, t⟩| S = {x1, . . . , xk}, and for some
{y1, . . . , yl} ⊆{x1, . . . , xk}, we have Σyi = t}.
For example, ⟨{4, 11, 16, 21, 27}, 25⟩∈SUBSET-SUM because 4 + 21 = 25.
Note that {x1, . . . , xk} and {y1, . . . , yl} are considered to be multisets and so
allow repetition of elements.
THEOREM
7.25
SUBSET-SUM is in NP.
PROOF IDEA
The subset is the certiﬁcate.
PROOF
The following is a veriﬁer V for SUBSET-SUM.
V = “On input ⟨⟨S, t⟩, c⟩:
1.
Test whether c is a collection of numbers that sum to t.
2.
Test whether S contains all the numbers in c.
3.
If both pass, accept; otherwise, reject.”
ALTERNATIVE PROOF
We can also prove this theorem by giving a nonde-
terministic polynomial time Turing machine for SUBSET-SUM as follows.
N = “On input ⟨S, t⟩:
1.
Nondeterministically select a subset c of the numbers in S.
2.
Test whether c is a collection of numbers that sum to t.
3.
If the test passes, accept; otherwise, reject.”
Observe that the complements of these sets, CLIQUE and SUBSET-SUM,
are not obviously members of NP. Verifying that something is not present seems
to be more difﬁcult than verifying that it is present. We make a separate com-
plexity class, called coNP, which contains the languages that are complements
of languages in NP. We don’t know whether coNP is different from NP.
THE P VERSUS NP QUESTION
As we have been saying, NP is the class of languages that are solvable in polyno-
mial time on a nondeterministic Turing machine; or, equivalently, it is the class
of languages whereby membership in the language can be veriﬁed in polynomial
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

298
CHAPTER 7 / TIME COMPLEXITY
time. P is the class of languages where membership can be tested in polyno-
mial time. We summarize this information as follows, where we loosely refer to
polynomial time solvable as solvable “quickly.”
P = the class of languages for which membership can be decided quickly.
NP = the class of languages for which membership can be veriﬁed quickly.
We have presented examples of languages, such as HAMPATH and CLIQUE,
that are members of NP but that are not known to be in P. The power of polyno-
mial veriﬁability seems to be much greater than that of polynomial decidability.
But, hard as it may be to imagine, P and NP could be equal. We are unable to
prove the existence of a single language in NP that is not in P.
The question of whether P = NP is one of the greatest unsolved problems
in theoretical computer science and contemporary mathematics. If these classes
were equal, any polynomially veriﬁable problem would be polynomially decid-
able. Most researchers believe that the two classes are not equal because people
have invested enormous effort to ﬁnd polynomial time algorithms for certain
problems in NP, without success. Researchers also have tried proving that the
classes are unequal, but that would entail showing that no fast algorithm exists
to replace brute-force search. Doing so is presently beyond scientiﬁc reach. The
following ﬁgure shows the two possibilities.
FIGURE
7.26
One of these two possibilities is correct
The best deterministic method currently known for deciding languages in NP
uses exponential time. In other words, we can prove that
NP ⊆EXPTIME =
[
k
TIME(2nk),
but we don’t know whether NP is contained in a smaller deterministic time com-
plexity class.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.4
NP-COMPLETENESS
299
7.4
NP-COMPLETENESS
One important advance on the P versus NP question came in the early 1970s
with the work of Stephen Cook and Leonid Levin. They discovered certain
problems in NP whose individual complexity is related to that of the entire class.
If a polynomial time algorithm exists for any of these problems, all problems in
NP would be polynomial time solvable. These problems are called NP-complete.
The phenomenon of NP-completeness is important for both theoretical and
practical reasons.
On the theoretical side, a researcher trying to show that P is unequal to NP
may focus on an NP-complete problem. If any problem in NP requires more
than polynomial time, an NP-complete one does. Furthermore, a researcher
attempting to prove that P equals NP only needs to ﬁnd a polynomial time al-
gorithm for an NP-complete problem to achieve this goal.
On the practical side, the phenomenon of NP-completeness may prevent
wasting time searching for a nonexistent polynomial time algorithm to solve
a particular problem. Even though we may not have the necessary mathematics
to prove that the problem is unsolvable in polynomial time, we believe that P is
unequal to NP. So proving that a problem is NP-complete is strong evidence of
its nonpolynomiality.
The ﬁrst NP-complete problem that we present is called the satisﬁability
problem. Recall that variables that can take on the values TRUE and FALSE are
called Boolean variables (see Section 0.2). Usually, we represent TRUE by 1 and
FALSE by 0. The Boolean operations AND, OR, and NOT, represented by the
symbols ∧, ∨, and ¬, respectively, are described in the following list. We use the
overbar as a shorthand for the ¬ symbol, so x means ¬ x.
0 ∧0 = 0
0 ∨0 = 0
0 = 1
0 ∧1 = 0
0 ∨1 = 1
1 = 0
1 ∧0 = 0
1 ∨0 = 1
1 ∧1 = 1
1 ∨1 = 1
A Boolean formula is an expression involving Boolean variables and opera-
tions. For example,
φ = (x ∧y) ∨(x ∧z)
is a Boolean formula. A Boolean formula is satisﬁable if some assignment of 0s
and 1s to the variables makes the formula evaluate to 1. The preceding formula is
satisﬁable because the assignment x = 0, y = 1, and z = 0 makes φ evaluate to 1.
We say the assignment satisﬁes φ. The satisﬁability problem is to test whether a
Boolean formula is satisﬁable. Let
SAT = {⟨φ⟩| φ is a satisﬁable Boolean formula}.
Now we state a theorem that links the complexity of the SAT problem to the
complexities of all problems in NP.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

300
CHAPTER 7 / TIME COMPLEXITY
THEOREM
7.27
SAT ∈P iff P = NP.
Next, we develop the method that is central to the proof of this theorem.
POLYNOMIAL TIME REDUCIBILITY
In Chapter 5, we deﬁned the concept of reducing one problem to another. When
problem A reduces to problem B, a solution to B can be used to solve A. Now
we deﬁne a version of reducibility that takes the efﬁciency of computation into
account. When problem A is efﬁciently reducible to problem B, an efﬁcient
solution to B can be used to solve A efﬁciently.
DEFINITION
7.28
A function f : Σ∗−→Σ∗is a polynomial time computable function
if some polynomial time Turing machine M exists that halts with
just f(w) on its tape, when started on any input w.
DEFINITION
7.29
Language A is polynomial time mapping reducible,1or simply poly-
nomial time reducible, to language B, written A ≤P B, if a polyno-
mial time computable function f : Σ∗−→Σ∗exists, where for every
w,
w ∈A ⇐⇒f(w) ∈B.
The function f is called the polynomial time reduction of A to B.
Polynomial time reducibility is the efﬁcient analog to mapping reducibility
as deﬁned in Section 5.3. Other forms of efﬁcient reducibility are available, but
polynomial time reducibility is a simple form that is adequate for our purposes
so we won’t discuss the others here. Figure 7.30 illustrates polynomial time
reducibility.
1It is called polynomial time many–one reducibility in some other textbooks.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.4
NP-COMPLETENESS
301
FIGURE
7.30
Polynomial time function f reducing A to B
As with an ordinary mapping reduction, a polynomial time reduction of A to
B provides a way to convert membership testing in A to membership testing in
B—but now the conversion is done efﬁciently. To test whether w ∈A, we use
the reduction f to map w to f(w) and test whether f(w) ∈B.
If one language is polynomial time reducible to a language already known to
have a polynomial time solution, we obtain a polynomial time solution to the
original language, as in the following theorem.
THEOREM
7.31
If A ≤P B and B ∈P, then A ∈P.
PROOF
Let M be the polynomial time algorithm deciding B and f be the
polynomial time reduction from A to B. We describe a polynomial time algo-
rithm N deciding A as follows.
N = “On input w:
1.
Compute f(w).
2.
Run M on input f(w) and output whatever M outputs.”
We have w ∈A whenever f(w) ∈B because f is a reduction from A to B.
Thus, M accepts f(w) whenever w ∈A. Moreover, N runs in polynomial time
because each of its two stages runs in polynomial time. Note that stage 2 runs in
polynomial time because the composition of two polynomials is a polynomial.
Before demonstrating a polynomial time reduction, we introduce 3SAT, a
special case of the satisﬁability problem whereby all formulas are in a special
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

302
CHAPTER 7 / TIME COMPLEXITY
form. A literal is a Boolean variable or a negated Boolean variable, as in x or x.
A clause is several literals connected with ∨s, as in (x1 ∨x2 ∨x3 ∨x4). A Boolean
formula is in conjunctive normal form, called a cnf-formula, if it comprises
several clauses connected with ∧s, as in
(x1 ∨x2 ∨x3 ∨x4) ∧(x3 ∨x5 ∨x6) ∧(x3 ∨x6).
It is a 3cnf-formula if all the clauses have three literals, as in
(x1 ∨x2 ∨x3) ∧(x3 ∨x5 ∨x6) ∧(x3 ∨x6 ∨x4) ∧(x4 ∨x5 ∨x6).
Let 3SAT = {⟨φ⟩| φ is a satisﬁable 3cnf-formula}. If an assignment satisﬁes a
cnf-formula, each clause must contain at least one literal that evaluates to 1.
The following theorem presents a polynomial time reduction from the 3SAT
problem to the CLIQUE problem.
THEOREM
7.32
3SAT is polynomial time reducible to CLIQUE.
PROOF IDEA
The polynomial time reduction f that we demonstrate from
3SAT to CLIQUE converts formulas to graphs.
In the constructed graphs,
cliques of a speciﬁed size correspond to satisfying assignments of the formula.
Structures within the graph are designed to mimic the behavior of the variables
and clauses.
PROOF
Let φ be a formula with k clauses such as
φ = (a1 ∨b1 ∨c1) ∧(a2 ∨b2 ∨c2) ∧
· · ·
∧(ak ∨bk ∨ck).
The reduction f generates the string ⟨G, k⟩, where G is an undirected graph
deﬁned as follows.
The nodes in G are organized into k groups of three nodes each called the
triples, t1, . . . , tk. Each triple corresponds to one of the clauses in φ, and each
node in a triple corresponds to a literal in the associated clause. Label each node
of G with its corresponding literal in φ.
The edges of G connect all but two types of pairs of nodes in G. No edge
is present between nodes in the same triple, and no edge is present between
two nodes with contradictory labels, as in x2 and x2. Figure 7.33 illustrates this
construction when φ = (x1 ∨x1 ∨x2) ∧(x1 ∨x2 ∨x2) ∧(x1 ∨x2 ∨x2).
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.4
NP-COMPLETENESS
303
FIGURE
7.33
The graph that the reduction produces from
φ = (x1 ∨x1 ∨x2) ∧(x1 ∨x2 ∨x2) ∧(x1 ∨x2 ∨x2)
Now we demonstrate why this construction works. We show that φ is satisﬁ-
able iff G has a k-clique.
Suppose that φ has a satisfying assignment. In that satisfying assignment, at
least one literal is true in every clause. In each triple of G, we select one node
corresponding to a true literal in the satisfying assignment. If more than one
literal is true in a particular clause, we choose one of the true literals arbitrarily.
The nodes just selected form a k-clique. The number of nodes selected is k
because we chose one for each of the k triples. Each pair of selected nodes is
joined by an edge because no pair ﬁts one of the exceptions described previously.
They could not be from the same triple because we selected only one node per
triple. They could not have contradictory labels because the associated literals
were both true in the satisfying assignment. Therefore, G contains a k-clique.
Suppose that G has a k-clique. No two of the clique’s nodes occur in the same
triple because nodes in the same triple aren’t connected by edges. Therefore,
each of the k triples contains exactly one of the k clique nodes. We assign truth
values to the variables of φ so that each literal labeling a clique node is made
true. Doing so is always possible because two nodes labeled in a contradictory
way are not connected by an edge and hence both can’t be in the clique. This
assignment to the variables satisﬁes φ because each triple contains a clique node
and hence each clause contains a literal that is assigned TRUE. Therefore, φ is
satisﬁable.
Theorems 7.31 and 7.32 tell us that if CLIQUE is solvable in polynomial time,
so is 3SAT. At ﬁrst glance, this connection between these two problems appears
quite remarkable because, superﬁcially, they are rather different. But polynomial
time reducibility allows us to link their complexities. Now we turn to a deﬁnition
that will allow us similarly to link the complexities of an entire class of problems.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

304
CHAPTER 7 / TIME COMPLEXITY
DEFINITION OF NP-COMPLETENESS
DEFINITION
7.34
A language B is NP-complete if it satisﬁes two conditions:
1. B is in NP, and
2. every A in NP is polynomial time reducible to B.
THEOREM
7.35
If B is NP-complete and B ∈P, then P = NP.
PROOF
This theorem follows directly from the deﬁnition of polynomial time
reducibility.
THEOREM
7.36
If B is NP-complete and B ≤P C for C in NP, then C is NP-complete.
PROOF
We already know that C is in NP, so we must show that every A in
NP is polynomial time reducible to C. Because B is NP-complete, every lan-
guage in NP is polynomial time reducible to B, and B in turn is polynomial
time reducible to C. Polynomial time reductions compose; that is, if A is poly-
nomial time reducible to B and B is polynomial time reducible to C, then A
is polynomial time reducible to C. Hence every language in NP is polynomial
time reducible to C.
THE COOK---LEVIN THEOREM
Once we have one NP-complete problem, we may obtain others by polynomial
time reduction from it. However, establishing the ﬁrst NP-complete problem is
more difﬁcult. Now we do so by proving that SAT is NP-complete.
THEOREM
7.37
SAT is NP-complete.2
This theorem implies Theorem 7.27.
2An alternative proof of this theorem appears in Section 9.3.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.4
NP-COMPLETENESS
305
PROOF IDEA
Showing that SAT is in NP is easy, and we do so shortly. The
hard part of the proof is showing that any language in NP is polynomial time
reducible to SAT.
To do so, we construct a polynomial time reduction for each language A in NP
to SAT. The reduction for A takes a string w and produces a Boolean formula φ
that simulates the NP machine for A on input w. If the machine accepts, φ has
a satisfying assignment that corresponds to the accepting computation. If the
machine doesn’t accept, no assignment satisﬁes φ. Therefore, w is in A if and
only if φ is satisﬁable.
Actually constructing the reduction to work in this way is a conceptually
simple task, though we must cope with many details. A Boolean formula may
contain the Boolean operations AND, OR, and NOT, and these operations form
the basis for the circuitry used in electronic computers. Hence the fact that we
can design a Boolean formula to simulate a Turing machine isn’t surprising. The
details are in the implementation of this idea.
PROOF
First, we show that SAT is in NP. A nondeterministic polynomial
time machine can guess an assignment to a given formula φ and accept if the
assignment satisﬁes φ.
Next, we take any language A in NP and show that A is polynomial time
reducible to SAT. Let N be a nondeterministic Turing machine that decides A
in nk time for some constant k. (For convenience, we actually assume that N
runs in time nk −3; but only those readers interested in details should worry
about this minor point.) The following notion helps to describe the reduction.
A tableau for N on w is an nk ×nk table whose rows are the conﬁgurations of
a branch of the computation of N on input w, as shown in the following ﬁgure.
FIGURE
7.38
A tableau is an nk × nk table of conﬁgurations
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

306
CHAPTER 7 / TIME COMPLEXITY
For convenience later, we assume that each conﬁguration starts and ends with
a # symbol. Therefore, the ﬁrst and last columns of a tableau are all #s. The ﬁrst
row of the tableau is the starting conﬁguration of N on w, and each row follows
the previous one according to N’s transition function. A tableau is accepting if
any row of the tableau is an accepting conﬁguration.
Every accepting tableau for N on w corresponds to an accepting computation
branch of N on w. Thus, the problem of determining whether N accepts w is
equivalent to the problem of determining whether an accepting tableau for N
on w exists.
Now we get to the description of the polynomial time reduction f from A to
SAT. On input w, the reduction produces a formula φ. We begin by describing
the variables of φ. Say that Q and Γ are the state set and tape alphabet of N,
respectively. Let C = Q ∪Γ ∪{#}. For each i and j between 1 and nk and for
each s in C, we have a variable, xi,j,s.
Each of the (nk)2 entries of a tableau is called a cell. The cell in row i and
column j is called cell[i, j] and contains a symbol from C. We represent the
contents of the cells with the variables of φ. If xi,j,s takes on the value 1, it
means that cell[i, j] contains an s.
Now we design φ so that a satisfying assignment to the variables does corre-
spond to an accepting tableau for N on w. The formula φ is the AND of four
parts: φcell ∧φstart ∧φmove ∧φaccept. We describe each part in turn.
As we mentioned previously, turning variable xi,j,s on corresponds to placing
symbol s in cell[i, j]. The ﬁrst thing we must guarantee in order to obtain a cor-
respondence between an assignment and a tableau is that the assignment turns
on exactly one variable for each cell. Formula φcell ensures this requirement by
expressing it in terms of Boolean operations:
φcell =
^
1≤i,j≤nk
 _
s∈C
xi,j,s

∧
 ^
s,t∈C
s̸=t
(xi,j,s ∨xi,j,t)

.
The symbols V and W stand for iterated AND and OR. For example, the
expression in the preceding formula
_
s∈C
xi,j,s
is shorthand for
xi,j,s1 ∨xi,j,s2 ∨· · · ∨xi,j,sl
where C = {s1, s2, . . . , sl}. Hence φcell is actually a large expression that con-
tains a fragment for each cell in the tableau because i and j range from 1 to nk.
The ﬁrst part of each fragment says that at least one variable is turned on in the
corresponding cell. The second part of each fragment says that no more than
one variable is turned on (literally, it says that in each pair of variables, at least
one is turned off) in the corresponding cell. These fragments are connected by
∧operations.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.4
NP-COMPLETENESS
307
The ﬁrst part of φcell inside the brackets stipulates that at least one variable
that is associated with each cell is on, whereas the second part stipulates that no
more than one variable is on for each cell. Any assignment to the variables that
satisﬁes φ (and therefore φcell) must have exactly one variable on for every cell.
Thus, any satisfying assignment speciﬁes one symbol in each cell of the table.
Parts φstart, φmove, and φaccept ensure that these symbols actually correspond to an
accepting tableau as follows.
Formula φstart ensures that the ﬁrst row of the table is the starting conﬁgu-
ration of N on w by explicitly stipulating that the corresponding variables are
on:
φstart = x1,1,# ∧x1,2,q0∧
x1,3,w1 ∧x1,4,w2 ∧. . . ∧x1,n+2,wn∧
x1,n+3,␣∧. . . ∧x1,nk−1,␣∧x1,nk,# .
Formula φaccept guarantees that an accepting conﬁguration occurs in the
tableau. It ensures that qaccept, the symbol for the accept state, appears in one
of the cells of the tableau by stipulating that one of the corresponding variables
is on:
φaccept =
_
1≤i,j≤nk
xi,j,qaccept.
Finally, formula φmove guarantees that each row of the tableau corresponds to
a conﬁguration that legally follows the preceding row’s conﬁguration according
to N’s rules. It does so by ensuring that each 2 × 3 window of cells is legal.
We say that a 2 × 3 window is legal if that window does not violate the actions
speciﬁed by N’s transition function. In other words, a window is legal if it might
appear when one conﬁguration correctly follows another.3
For example, say that a, b, and c are members of the tape alphabet, and q1
and q2 are states of N. Assume that when in state q1 with the head reading an a,
N writes a b, stays in state q1, and moves right; and that when in state q1 with
the head reading a b, N nondeterministically either
1. writes a c, enters q2, and moves to the left, or
2. writes an a, enters q2, and moves to the right.
Expressed formally, δ(q1, a) = {(q1,b,R)} and δ(q1, b) = {(q2,c,L), (q2,a,R)}.
Examples of legal windows for this machine are shown in Figure 7.39.
3We could give a precise deﬁnition of legal window here, in terms of the transition func-
tion. But doing so is quite tedious and would distract us from the main thrust of the
proof argument. Anyone desiring more precision should refer to the related analysis in
the proof of Theorem 5.15, the undecidability of the Post Correspondence Problem.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

308
CHAPTER 7 / TIME COMPLEXITY
(a)
a
q1
b
q2
a
c
(b)
a
q1
b
a
a
q2
(c)
a
a
q1
a
a
b
(d)
#
b
a
#
b
a
(e)
a
b
a
a
b
q2
(f)
b
b
b
c
b
b
FIGURE
7.39
Examples of legal windows
In Figure 7.39, windows (a) and (b) are legal because the transition function
allows N to move in the indicated way. Window (c) is legal because, with q1
appearing on the right side of the top row, we don’t know what symbol the head
is over. That symbol could be an a, and q1 might change it to a b and move to the
right. That possibility would give rise to this window, so it doesn’t violate N’s
rules. Window (d) is obviously legal because the top and bottom are identical,
which would occur if the head weren’t adjacent to the location of the window.
Note that # may appear on the left or right of both the top and bottom rows
in a legal window. Window (e) is legal because state q1 reading a b might have
been immediately to the right of the top row, and it would then have moved to
the left in state q2 to appear on the right-hand end of the bottom row. Finally,
window (f) is legal because state q1 might have been immediately to the left of
the top row, and it might have changed the b to a c and moved to the left.
The windows shown in the following ﬁgure aren’t legal for machine N.
(a)
a
b
a
a
a
a
(b)
a
q1
b
q2
a
a
(c)
b
q1
b
q2
b
q2
FIGURE
7.40
Examples of illegal windows
In window (a), the central symbol in the top row can’t change because a state
wasn’t adjacent to it. Window (b) isn’t legal because the transition function spec-
iﬁes that the b gets changed to a c but not to an a. Window (c) isn’t legal because
two states appear in the bottom row.
CLAIM
7.41
If the top row of the tableau is the start conﬁguration and every window in the
tableau is legal, each row of the tableau is a conﬁguration that legally follows the
preceding one.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.4
NP-COMPLETENESS
309
We prove this claim by considering any two adjacent conﬁgurations in the
tableau, called the upper conﬁguration and the lower conﬁguration. In the up-
per conﬁguration, every cell that contains a tape symbol and isn’t adjacent to
a state symbol is the center top cell in a window whose top row contains no
states. Therefore, that symbol must appear unchanged in the center bottom of
the window. Hence it appears in the same position in the bottom conﬁguration.
The window containing the state symbol in the center top cell guarantees that
the corresponding three positions are updated consistently with the transition
function. Therefore, if the upper conﬁguration is a legal conﬁguration, so is the
lower conﬁguration, and the lower one follows the upper one according to N’s
rules. Note that this proof, though straightforward, depends crucially on our
choice of a 2 × 3 window size, as Problem 7.41 shows.
Now we return to the construction of φmove. It stipulates that all the windows
in the tableau are legal. Each window contains six cells, which may be set in
a ﬁxed number of ways to yield a legal window. Formula φmove says that the
settings of those six cells must be one of these ways, or
φmove =
^
1≤i<nk, 1<j<nk
 the (i, j)-window is legal

.
The (i, j)-window has cell[i, j] as the upper central position. We replace the
text “the (i, j)-window is legal” in this formula with the following formula. We
write the contents of six cells of a window as a1, . . . , a6.
_
a1,...,a6
is a legal window
 xi,j−1,a1 ∧xi,j,a2 ∧xi,j+1,a3 ∧xi+1,j−1,a4 ∧xi+1,j,a5 ∧xi+1,j+1,a6

Next, we analyze the complexity of the reduction to show that it operates in
polynomial time. To do so, we examine the size of φ. First, we estimate the
number of variables it has. Recall that the tableau is an nk × nk table, so it
contains n2k cells. Each cell has l variables associated with it, where l is the
number of symbols in C. Because l depends only on the TM N and not on the
length of the input n, the total number of variables is O(n2k).
We estimate the size of each of the parts of φ. Formula φcell contains a ﬁxed-
size fragment of the formula for each cell of the tableau, so its size is O(n2k).
Formula φstart has a fragment for each cell in the top row, so its size is O(nk).
Formulas φmove and φaccept each contain a ﬁxed-size fragment of the formula for
each cell of the tableau, so their size is O(n2k). Thus, φ’s total size is O(n2k).
That bound is sufﬁcient for our purposes because it shows that the size of φ
is polynomial in n. If it were more than polynomial, the reduction wouldn’t
have any chance of generating it in polynomial time. (Actually, our estimates are
low by a factor of O(log n) because each variable has indices that can range up
to nk and so may require O(log n) symbols to write into the formula, but this
additional factor doesn’t change the polynomiality of the result.)
To see that we can generate the formula in polynomial time, observe its highly
repetitive nature. Each component of the formula is composed of many nearly
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

310
CHAPTER 7 / TIME COMPLEXITY
identical fragments, which differ only at the indices in a simple way. Therefore,
we may easily construct a reduction that produces φ in polynomial time from the
input w.
Thus, we have concluded the proof of the Cook–Levin theorem, showing
that SAT is NP-complete. Showing the NP-completeness of other languages
generally doesn’t require such a lengthy proof. Instead, NP-completeness can be
proved with a polynomial time reduction from a language that is already known
to be NP-complete. We can use SAT for this purpose; but using 3SAT, the
special case of SAT that we deﬁned on page 302, is usually easier. Recall that
the formulas in 3SAT are in conjunctive normal form (cnf) with three literals
per clause. First, we must show that 3SAT itself is NP-complete. We prove this
assertion as a corollary to Theorem 7.37.
COROLLARY
7.42
3SAT is NP-complete.
PROOF
Obviously 3SAT is in NP, so we only need to prove that all languages
in NP reduce to 3SAT in polynomial time. One way to do so is by showing
that SAT polynomial time reduces to 3SAT. Instead, we modify the proof of
Theorem 7.37 so that it directly produces a formula in conjunctive normal form
with three literals per clause.
Theorem 7.37 produces a formula that is already almost in conjunctive nor-
mal form. Formula φcell is a big AND of subformulas, each of which contains a
big OR and a big AND of ORs. Thus, φcell is an AND of clauses and so is already
in cnf. Formula φstart is a big AND of variables. Taking each of these variables
to be a clause of size 1, we see that φstart is in cnf. Formula φaccept is a big OR
of variables and is thus a single clause. Formula φmove is the only one that isn’t
already in cnf, but we may easily convert it into a formula that is in cnf as follows.
Recall that φmove is a big AND of subformulas, each of which is an OR of ANDs
that describes all possible legal windows. The distributive laws, as described in
Chapter 0, state that we can replace an OR of ANDs with an equivalent AND of
ORs. Doing so may signiﬁcantly increase the size of each subformula, but it can
only increase the total size of φmove by a constant factor because the size of each
subformula depends only on N. The result is a formula that is in conjunctive
normal form.
Now that we have written the formula in cnf, we convert it to one with three
literals per clause. In each clause that currently has one or two literals, we repli-
cate one of the literals until the total number is three. In each clause that has
more than three literals, we split it into several clauses and add additional vari-
ables to preserve the satisﬁability or nonsatisﬁability of the original.
For example, we replace clause (a1 ∨a2 ∨a3 ∨a4), wherein each ai is a literal,
with the two-clause expression (a1 ∨a2 ∨z) ∧(z ∨a3 ∨a4), wherein z is a new
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.5
ADDITIONAL NP-COMPLETE PROBLEMS
311
variable. If some setting of the ai’s satisﬁes the original clause, we can ﬁnd some
setting of z so that the two new clauses are satisﬁed and vice versa. In general, if
the clause contains l literals,
(a1 ∨a2 ∨· · · ∨al),
we can replace it with the l −2 clauses
(a1 ∨a2 ∨z1) ∧(z1 ∨a3 ∨z2) ∧(z2 ∨a4 ∨z3) ∧· · · ∧(zl−3 ∨al−1 ∨al).
We may easily verify that the new formula is satisﬁable iff the original formula
was, so the proof is complete.
7.5
ADDITIONAL NP-COMPLETE PROBLEMS
The phenomenon of NP-completeness is widespread. NP-complete problems
appear in many ﬁelds. For reasons that are not well understood, most naturally
occurring NP-problems are known either to be in P or to be NP-complete. If
you seek a polynomial time algorithm for a new NP-problem, spending part of
your effort attempting to prove it NP-complete is sensible because doing so may
prevent you from working to ﬁnd a polynomial time algorithm that doesn’t exist.
In this section, we present additional theorems showing that various lan-
guages are NP-complete. These theorems provide examples of the techniques
that are used in proofs of this kind. Our general strategy is to exhibit a polyno-
mial time reduction from 3SAT to the language in question, though we some-
times reduce from other NP-complete languages when that is more convenient.
When constructing a polynomial time reduction from 3SAT to a language, we
look for structures in that language that can simulate the variables and clauses in
Boolean formulas. Such structures are sometimes called gadgets. For example,
in the reduction from 3SAT to CLIQUE presented in Theorem 7.32, individual
nodes simulate variables and triples of nodes simulate clauses. An individual
node may or may not be a member of the clique, corresponding to a variable
that may or may not be true in a satisfying assignment. Each clause must contain
a literal that is assigned TRUE. Correspondingly, each triple must contain a
node in the clique (in order to reach the target size). The following corollary to
Theorem 7.32 states that CLIQUE is NP-complete.
COROLLARY
7.43
CLIQUE is NP-complete.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

312
CHAPTER 7 / TIME COMPLEXITY
THE VERTEX COVER PROBLEM
If G is an undirected graph, a vertex cover of G is a subset of the nodes where
every edge of G touches one of those nodes. The vertex cover problem asks
whether a graph contains a vertex cover of a speciﬁed size:
VERTEX-COVER = {⟨G, k⟩| G is an undirected graph that
has a k-node vertex cover}.
THEOREM
7.44
VERTEX-COVER is NP-complete.
PROOF IDEA
To show that VERTEX-COVER is NP-complete, we must
show that it is in NP and that all NP-problems are polynomial time reducible
to it.
The ﬁrst part is easy; a certiﬁcate is simply a vertex cover of size k.
To prove the second part, we show that 3SAT is polynomial time reducible to
VERTEX-COVER. The reduction converts a 3cnf-formula φ into a graph G and
a number k, so that φ is satisﬁable whenever G has a vertex cover with k nodes.
The conversion is done without knowing whether φ is satisﬁable. In effect, G
simulates φ. The graph contains gadgets that mimic the variables and clauses of
the formula. Designing these gadgets requires a bit of ingenuity.
For the variable gadget, we look for a structure in G that can participate in
the vertex cover in either of two possible ways, corresponding to the two pos-
sible truth assignments to the variable. The variable gadget contains two nodes
connected by an edge. That structure works because one of these nodes must
appear in the vertex cover. We arbitrarily associate TRUE and FALSE with these
two nodes.
For the clause gadget, we look for a structure that induces the vertex cover to
include nodes in the variable gadgets corresponding to at least one true literal in
the clause. The gadget contains three nodes and additional edges so that any ver-
tex cover must include at least two of the nodes, or possibly all three. Only two
nodes would be required if one of the variable gadget nodes helps by covering
an edge, as would happen if the associated literal satisﬁes that clause. Other-
wise, three nodes would be required. Finally, we chose k so that the sought-after
vertex cover has one node per variable gadget and two nodes per clause gadget.
PROOF
Here are the details of a reduction from 3SAT to VERTEX-COVER
that operates in polynomial time. The reduction maps a Boolean formula φ to a
graph G and a value k. For each variable x in φ, we produce an edge connecting
two nodes. We label the two nodes in this gadget x and x. Setting x to be TRUE
corresponds to selecting the node labeled x for the vertex cover, whereas FALSE
corresponds to the node labeled x.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.5
ADDITIONAL NP-COMPLETE PROBLEMS
313
The gadgets for the clauses are a bit more complex. Each clause gadget is a
triple of nodes that are labeled with the three literals of the clause. These three
nodes are connected to each other and to the nodes in the variable gadgets that
have the identical labels. Thus, the total number of nodes that appear in G is
2m + 3l, where φ has m variables and l clauses. Let k be m + 2l.
For example, if φ = (x1 ∨x1 ∨x2) ∧(x1 ∨x2 ∨x2) ∧(x1 ∨x2 ∨x2), the
reduction produces ⟨G, k⟩from φ, where k = 8 and G takes the form shown in
the following ﬁgure.
FIGURE
7.45
The graph that the reduction produces from
φ = (x1 ∨x1 ∨x2) ∧(x1 ∨x2 ∨x2) ∧(x1 ∨x2 ∨x2)
To prove that this reduction works, we need to show that φ is satisﬁable if and
only if G has a vertex cover with k nodes. We start with a satisfying assignment.
We ﬁrst put the nodes of the variable gadgets that correspond to the true literals
in the assignment into the vertex cover. Then, we select one true literal in every
clause and put the remaining two nodes from every clause gadget into the vertex
cover. Now we have a total of k nodes. They cover all edges because every vari-
able gadget edge is clearly covered, all three edges within every clause gadget are
covered, and all edges between variable and clause gadgets are covered. Hence
G has a vertex cover with k nodes.
Second, if G has a vertex cover with k nodes, we show that φ is satisﬁable
by constructing the satisfying assignment. The vertex cover must contain one
node in each variable gadget and two in every clause gadget in order to cover the
edges of the variable gadgets and the three edges within the clause gadgets. That
accounts for all the nodes, so none are left over. We take the nodes of the vari-
able gadgets that are in the vertex cover and assign TRUE to the corresponding
literals. That assignment satisﬁes φ because each of the three edges connecting
the variable gadgets with each clause gadget is covered, and only two nodes of
the clause gadget are in the vertex cover. Therefore, one of the edges must be
covered by a node from a variable gadget and so that assignment satisﬁes the
corresponding clause.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

314
CHAPTER 7 / TIME COMPLEXITY
THE HAMILTONIAN PATH PROBLEM
Recall that the Hamiltonian path problem asks whether the input graph contains
a path from s to t that goes through every node exactly once.
THEOREM
7.46
HAMPATH is NP-complete.
PROOF IDEA
We showed that HAMPATH is in NP in Section 7.3. To show
that every NP-problem is polynomial time reducible to HAMPATH, we show
that 3SAT is polynomial time reducible to HAMPATH. We give a way to convert
3cnf-formulas to graphs in which Hamiltonian paths correspond to satisfying
assignments of the formula. The graphs contain gadgets that mimic variables
and clauses. The variable gadget is a diamond structure that can be traversed in
either of two ways, corresponding to the two truth settings. The clause gadget
is a node. Ensuring that the path goes through each clause gadget corresponds
to ensuring that each clause is satisﬁed in the satisfying assignment.
PROOF
We previously demonstrated that HAMPATH is in NP, so all that
remains to be done is to show 3SAT ≤P HAMPATH. For each 3cnf-formula φ,
we show how to construct a directed graph G with two nodes, s and t, where a
Hamiltonian path exists between s and t iff φ is satisﬁable.
We start the construction with a 3cnf-formula φ containing k clauses,
φ = (a1 ∨b1 ∨c1) ∧(a2 ∨b2 ∨c2) ∧· · · ∧(ak ∨bk ∨ck),
where each a, b, and c is a literal xi or xi. Let x1, . . . , xl be the l variables of φ.
Now we show how to convert φ to a graph G. The graph G that we construct
has various parts to represent the variables and clauses that appear in φ.
We represent each variable xi with a diamond-shaped structure that contains
a horizontal row of nodes, as shown in the following ﬁgure. Later we specify the
number of nodes that appear in the horizontal row.
FIGURE
7.47
Representing the variable xi as a diamond structure
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.5
ADDITIONAL NP-COMPLETE PROBLEMS
315
We represent each clause of φ as a single node, as follows.
FIGURE
7.48
Representing the clause cj as a node
The following ﬁgure depicts the global structure of G. It shows all the ele-
ments of G and their relationships, except the edges that represent the relation-
ship of the variables to the clauses that contain them.
FIGURE
7.49
The high-level structure of G
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

316
CHAPTER 7 / TIME COMPLEXITY
Next, we show how to connect the diamonds representing the variables to the
nodes representing the clauses. Each diamond structure contains a horizontal
row of nodes connected by edges running in both directions. The horizontal
row contains 3k +1 nodes in addition to the two nodes on the ends belonging to
the diamond. These nodes are grouped into adjacent pairs, one for each clause,
with extra separator nodes next to the pairs, as shown in the following ﬁgure.
FIGURE
7.50
The horizontal nodes in a diamond structure
If variable xi appears in clause cj, we add the following two edges from the
jth pair in the ith diamond to the jth clause node.
FIGURE
7.51
The additional edges when clause cj contains xi
If xi appears in clause cj, we add two edges from the jth pair in the ith dia-
mond to the jth clause node, as shown in Figure 7.52.
After we add all the edges corresponding to each occurrence of xi or xi in
each clause, the construction of G is complete. To show that this construction
works, we argue that if φ is satisﬁable, a Hamiltonian path exists from s to t; and,
conversely, if such a path exists, φ is satisﬁable.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.5
ADDITIONAL NP-COMPLETE PROBLEMS
317
FIGURE
7.52
The additional edges when clause cj contains xi
Suppose that φ is satisﬁable. To demonstrate a Hamiltonian path from s to
t, we ﬁrst ignore the clause nodes. The path begins at s, goes through each
diamond in turn, and ends up at t. To hit the horizontal nodes in a diamond,
the path either zig-zags from left to right or zag-zigs from right to left; the
satisfying assignment to φ determines which. If xi is assigned TRUE, the path
zig-zags through the corresponding diamond. If xi is assigned FALSE, the path
zag-zigs. We show both possibilities in the following ﬁgure.
FIGURE
7.53
Zig-zagging and zag-zigging through a diamond, as determined by the
satisfying assignment
So far, this path covers all the nodes in G except the clause nodes. We can
easily include them by adding detours at the horizontal nodes. In each clause,
we select one of the literals assigned TRUE by the satisfying assignment.
If we selected xi in clause cj, we can detour at the jth pair in the ith diamond.
Doing so is possible because xi must be TRUE, so the path zig-zags from left to
right through the corresponding diamond. Hence the edges to the cj node are
in the correct order to allow a detour and return.
Similarly, if we selected xi in clause cj, we can detour at the jth pair in the
ith diamond because xi must be FALSE, so the path zag-zigs from right to left
through the corresponding diamond. Hence the edges to the cj node again are
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

318
CHAPTER 7 / TIME COMPLEXITY
in the correct order to allow a detour and return. (Note that each true literal in a
clause provides an option of a detour to hit the clause node. As a result, if several
literals in a clause are true, only one detour is taken.) Thus, we have constructed
the desired Hamiltonian path.
For the reverse direction, if G has a Hamiltonian path from s to t, we demon-
strate a satisfying assignment for φ. If the Hamiltonian path is normal—that is, it
goes through the diamonds in order from the top one to the bottom one, except
for the detours to the clause nodes—we can easily obtain the satisfying assign-
ment. If the path zig-zags through the diamond, we assign the corresponding
variable TRUE; and if it zag-zigs, we assign FALSE. Because each clause node ap-
pears on the path, by observing how the detour to it is taken, we may determine
which of the literals in the corresponding clause is TRUE.
All that remains to be shown is that a Hamiltonian path must be normal.
Normality may fail only if the path enters a clause from one diamond but returns
to another, as in the following ﬁgure.
  
FIGURE
7.54
This situation cannot occur
The path goes from node a1 to c; but instead of returning to a2 in the same
diamond, it returns to b2 in a different diamond. If that occurs, either a2 or a3
must be a separator node. If a2 were a separator node, the only edges entering
a2 would be from a1 and a3. If a3 were a separator node, a1 and a2 would be
in the same clause pair, and hence the only edges entering a2 would be from a1,
a3, and c. In either case, the path could not contain node a2. The path cannot
enter a2 from c or a1 because the path goes elsewhere from these nodes. The
path cannot enter a2 from a3 because a3 is the only available node that a2 points
at, so the path must exit a2 via a3. Hence a Hamiltonian path must be normal.
This reduction obviously operates in polynomial time and the proof is complete.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.5
ADDITIONAL NP-COMPLETE PROBLEMS
319
Next, we consider an undirected version of the Hamiltonian path problem,
called UHAMPATH. To show that UHAMPATH is NP-complete, we give a
polynomial time reduction from the directed version of the problem.
THEOREM
7.55
UHAMPATH is NP-complete.
PROOF
The reduction takes a directed graph G with nodes s and t, and con-
structs an undirected graph G′ with nodes s′ and t′. Graph G has a Hamiltonian
path from s to t iff G′ has a Hamiltonian path from s′ to t′. We describe G′ as
follows.
Each node u of G, except for s and t, is replaced by a triple of nodes uin, umid,
and uout in G′. Nodes s and t in G are replaced by nodes sout = s′ and tin = t′ in
G′. Edges of two types appear in G′. First, edges connect umid with uin and uout.
Second, an edge connects uout with vin if an edge goes from u to v in G. That
completes the construction of G′.
We can demonstrate that this construction works by showing that G has a
Hamiltonian path from s to t iff G′ has a Hamiltonian path from sout to tin. To
show one direction, we observe that a Hamiltonian path P in G,
s, u1, u2, . . . , uk, t,
has a corresponding Hamiltonian path P ′ in G′,
sout, uin
1 , umid
1 , uout
1 , uin
2 , umid
2
, uout
2 , . . . , tin.
To show the other direction, we claim that any Hamiltonian path in G′ from
sout to tin must go from a triple of nodes to a triple of nodes, except for the start
and ﬁnish, as does the path P ′ we just described. That would complete the proof
because any such path has a corresponding Hamiltonian path in G. We prove
the claim by following the path starting at node sout. Observe that the next node
in the path must be uin
i for some i because only those nodes are connected to sout.
The next node must be umid
i
because no other way is available to include umid
i
in
the Hamiltonian path. After umid
i
comes uout
i
because that is the only other node
to which umid
i
is connected. The next node must be uin
j for some j because no
other available node is connected to uout
i . The argument then repeats until tin is
reached.
THE SUBSET SUM PROBLEM
Recall the SUBSET-SUM problem deﬁned on page 297. In that problem, we
were given a collection of numbers x1, . . . , xk together with a target number t,
and were to determine whether the collection contains a subcollection that adds
up to t. We now show that this problem is NP-complete.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

320
CHAPTER 7 / TIME COMPLEXITY
THEOREM
7.56
SUBSET-SUM is NP-complete.
PROOF IDEA
We have already shown that SUBSET-SUM is in NP in The-
orem 7.25. We prove that all languages in NP are polynomial time reducible
to SUBSET-SUM by reducing the NP-complete language 3SAT to it. Given
a 3cnf-formula φ, we construct an instance of the SUBSET-SUM problem that
contains a subcollection summing to the target t if and only if φ is satisﬁable.
Call this subcollection T .
To achieve this reduction, we ﬁnd structures of the SUBSET-SUM problem
that represent variables and clauses. The SUBSET-SUM problem instance that
we construct contains numbers of large magnitude presented in decimal nota-
tion. We represent variables by pairs of numbers and clauses by certain positions
in the decimal representations of the numbers.
We represent variable xi by two numbers, yi and zi. We prove that either yi
or zi must be in T for each i, which establishes the encoding for the truth value
of xi in the satisfying assignment.
Each clause position contains a certain value in the target t, which imposes a
requirement on the subset T . We prove that this requirement is the same as the
one in the corresponding clause—namely, that one of the literals in that clause
is assigned TRUE.
PROOF
We already know that SUBSET-SUM ∈NP, so we now show that
3SAT ≤P SUBSET-SUM.
Let φ be a Boolean formula with variables x1, . . . , xl and clauses c1, . . . , ck.
The reduction converts φ to an instance of the SUBSET-SUM problem ⟨S, t⟩,
wherein the elements of S and the number t are the rows in the table in Fig-
ure 7.57, expressed in ordinary decimal notation. The rows above the double
line are labeled
y1, z1, y2, z2, . . . , yl, zl
and
g1, h1, g2, h2, . . . , gk, hk
and constitute the elements of S. The row below the double line is t.
Thus, S contains one pair of numbers, yi, zi, for each variable xi in φ. The
decimal representation of these numbers is in two parts, as indicated in the table.
The left-hand part comprises a 1 followed by l −i 0s. The right-hand part
contains one digit for each clause, where the digit of yi in column cj is 1 if clause
cj contains literal xi, and the digit of zi in column cj is 1 if clause cj contains
literal xi. Digits not speciﬁed to be 1 are 0.
The table is partially ﬁlled in to illustrate sample clauses, c1, c2, and ck:
(x1 ∨x2 ∨x3) ∧(x2 ∨x3 ∨· · · ) ∧· · · ∧(x3 ∨· · · ∨· · · ).
Additionally, S contains one pair of numbers, gj, hj, for each clause cj. These
two numbers are equal and consist of a 1 followed by k −j 0s.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

7.5
ADDITIONAL NP-COMPLETE PROBLEMS
321
Finally, the target number t, the bottom row of the table, consists of l 1s
followed by k 3s.
1
2
3
4
· · ·
l
c1
c2
· · ·
ck
y1
1
0
0
0
· · ·
0
1
0
· · ·
0
z1
1
0
0
0
· · ·
0
0
0
· · ·
0
y2
1
0
0
· · ·
0
0
1
· · ·
0
z2
1
0
0
· · ·
0
1
0
· · ·
0
y3
1
0
· · ·
0
1
1
· · ·
0
z3
1
0
· · ·
0
0
0
· · ·
1
...
...
...
...
...
...
yl
1
0
0
· · ·
0
zl
1
0
0
· · ·
0
g1
1
0
· · ·
0
h1
1
0
· · ·
0
g2
1
· · ·
0
h2
1
· · ·
0
...
...
...
gk
1
hk
1
t
1
1
1
1
· · ·
1
3
3
· · ·
3
FIGURE
7.57
Reducing 3SAT to SUBSET-SUM
Next, we show why this construction works. We demonstrate that φ is satis-
ﬁable iff some subset of S sums to t.
Suppose that φ is satisﬁable. We construct a subset of S as follows. We select
yi if xi is assigned TRUE in the satisfying assignment, and zi if xi is assigned
FALSE. If we add up what we have selected so far, we obtain a 1 in each of the
ﬁrst l digits because we have selected either yi or zi for each i. Furthermore, each
of the last k digits is a number between 1 and 3 because each clause is satisﬁed
and so contains between 1 and 3 true literals. We additionally select enough of
the g and h numbers to bring each of the last k digits up to 3, thus hitting the
target.
Suppose that a subset of S sums to t. We construct a satisfying assignment
to φ after making several observations. First, all the digits in members of S are
either 0 or 1. Furthermore, each column in the table describing S contains at
most ﬁve 1s. Hence a “carry” into the next column never occurs when a subset
of S is added. To get a 1 in each of the ﬁrst l columns, the subset must have
either yi or zi for each i, but not both.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

322
CHAPTER 7 / TIME COMPLEXITY
Now we make the satisfying assignment. If the subset contains yi, we assign
xi TRUE; otherwise, we assign it FALSE. This assignment must satisfy φ because
in each of the ﬁnal k columns, the sum is always 3. In column cj, at most 2 can
come from gj and hj, so at least 1 in this column must come from some yi or
zi in the subset. If it is yi, then xi appears in cj and is assigned TRUE, so cj
is satisﬁed. If it is zi, then xi appears in cj and xi is assigned FALSE, so cj is
satisﬁed. Therefore, φ is satisﬁed.
Finally, we must be sure that the reduction can be carried out in polynomial
time. The table has a size of roughly (k + l)2 and each entry can be easily
calculated for any φ. So the total time is O(n2) easy stages.
EXERCISES
7.1 Answer each part TRUE or FALSE.
a. 2n = O(n).
b. n2 = O(n).
Ac. n2 = O(n log2 n).
Ad. n log n = O(n2).
e. 3n = 2O(n).
f. 22n = O(22n).
7.2 Answer each part TRUE or FALSE.
a. n = o(2n).
b. 2n = o(n2).
Ac. 2n = o(3n).
Ad. 1 = o(n).
e. n = o(log n).
f. 1 = o(1/n).
7.3 Which of the following pairs of numbers are relatively prime? Show the calcula-
tions that led to your conclusions.
a. 1274 and 10505
b. 7289 and 8029
7.4 Fill out the table described in the polynomial time algorithm for context-free lan-
guage recognition from Theorem 7.16 for string w = baba and CFG G:
S →RT
R →T R | a
T →T R | b
7.5 Is the following formula satisﬁable?
(x ∨y) ∧(x ∨y) ∧(x ∨y) ∧(x ∨y)
7.6 Show that P is closed under union, concatenation, and complement.
7.7 Show that NP is closed under union and concatenation.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
323
7.8 Let CONNECTED = {⟨G⟩| G is a connected undirected graph}. Analyze the
algorithm given on page 185 to show that this language is in P.
7.9 A triangle in an undirected graph is a 3-clique. Show that TRIANGLE ∈P, where
TRIANGLE = {⟨G⟩| G contains a triangle}.
7.10 Show that ALLDFA is in P.
7.11 In both parts, provide an analysis of the time complexity of your algorithm.
a. Show that EQDFA ∈P.
b. Say that a language A is star-closed if A = A∗. Give a polynomial time
algorithm to test whether a DFA recognizes a star-closed language. (Note
that EQNFA is not known to be in P.)
7.12 Call graphs G and H isomorphic if the nodes of G may be reordered so that it is
identical to H. Let ISO = {⟨G, H⟩| G and H are isomorphic graphs}. Show that
ISO ∈NP.
PROBLEMS
7.13 Let
MODEXP = {⟨a, b, c, p⟩| a, b, c, and p are positive binary integers
such that ab ≡c
(mod p)}.
Show that MODEXP ∈P. (Note that the most obvious algorithm doesn’t run in
polynomial time. Hint: Try it ﬁrst where b is a power of 2.)
7.14 A permutation on the set {1, . . . , k} is a one-to-one, onto function on this set.
When p is a permutation, pt means the composition of p with itself t times. Let
PERM-POWER = {⟨p, q, t⟩| p = qt where p and q are permutations
on {1, . . . , k} and t is a binary integer}.
Show that PERM-POWER ∈P. (Note that the most obvious algorithm doesn’t
run within polynomial time. Hint: First try it where t is a power of 2.)
7.15 Show that P is closed under the star operation. (Hint: Use dynamic programming.
On input y = y1 · · · yn for yi ∈Σ, build a table indicating for each i ≤j whether
the substring yi · · · yj ∈A∗for any A ∈P.)
A7.16 Show that NP is closed under the star operation.
7.17 Let UNARY-SSUM be the subset sum problem in which all numbers are repre-
sented in unary. Why does the NP-completeness proof for SUBSET-SUM fail to
show UNARY-SSUM is NP-complete? Show that UNARY-SSUM ∈P.
7.18 Show that if P = NP, then every language A ∈P, except A = ∅and A = Σ∗, is
NP-complete.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

324
CHAPTER 7 / TIME COMPLEXITY
⋆7.19 Show that PRIMES = {m| m is a prime number in binary} ∈NP. (Hint: For
p > 1, the multiplicative group Z∗
p = {x| x is relatively prime to p and 1 ≤x < p}
is both cyclic and of order p −1 iff p is prime. You may use this fact without
justifying it. The stronger statement PRIMES ∈P is now known to be true, but it
is more difﬁcult to prove.)
7.20 We generally believe that PATH is not NP-complete. Explain the reason behind
this belief. Show that proving PATH is not NP-complete would prove P ̸= NP.
7.21 Let G represent an undirected graph. Also let
SPATH = {⟨G, a, b, k⟩| G contains a simple path of
length at most k from a to b},
and
LPATH = {⟨G, a, b, k⟩| G contains a simple path of
length at least k from a to b}.
a. Show that SPATH ∈P.
b. Show that LPATH is NP-complete.
7.22 Let DOUBLE-SAT = {⟨φ⟩| φ has at least two satisfying assignments}. Show that
DOUBLE-SAT is NP-complete.
A7.23 Let HALF-CLIQUE = {⟨G⟩| G is an undirected graph having a complete sub-
graph with at least m/2 nodes, where m is the number of nodes in G}. Show that
HALF-CLIQUE is NP-complete.
7.24 Let CNFk = {⟨φ⟩| φ is a satisﬁable cnf-formula where each variable appears in at
most k places}.
a. Show that CNF2 ∈P.
b. Show that CNF3 is NP-complete.
7.25 Let CNFH = {⟨φ⟩| φ is a satisﬁable cnf-formula where each clause contains any
number of literals, but at most one negated literal}. Show that CNFH ∈P.
7.26 Let φ be a 3cnf-formula. An ̸=-assignment to the variables of φ is one where
each clause contains two literals with unequal truth values. In other words, an
̸=-assignment satisﬁes φ without assigning three true literals in any clause.
a. Show that the negation of any ̸=-assignment to φ is also an ̸=-assignment.
b. Let ̸=SAT be the collection of 3cnf-formulas that have an ̸=-assignment.
Show that we obtain a polynomial time reduction from 3SAT to ̸=SAT by
replacing each clause ci
(y1 ∨y2 ∨y3)
with the two clauses
(y1 ∨y2 ∨zi)
and
(zi ∨y3 ∨b),
where zi is a new variable for each clause ci, and b is a single additional new
variable.
c. Conclude that ̸=SAT is NP-complete.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
325
7.27 A cut in an undirected graph is a separation of the vertices V into two disjoint
subsets S and T . The size of a cut is the number of edges that have one endpoint
in S and the other in T . Let
MAX-CUT = {⟨G, k⟩| G has a cut of size k or more}.
Show that MAX-CUT is NP-complete.
You may assume the result of Prob-
lem 7.26. (Hint: Show that ̸=SAT ≤P MAX-CUT. The variable gadget for
variable x is a collection of 3c nodes labeled with x and another 3c nodes labeled
with x, where c is the number of clauses. All nodes labeled x are connected with
all nodes labeled x. The clause gadget is a triangle of three edges connecting three
nodes labeled with the literals appearing in the clause. Do not use the same node
in more than one clause gadget. Prove that this reduction works.)
7.28 You are given a box and a collection of cards as indicated in the following ﬁgure.
Because of the pegs in the box and the notches in the cards, each card will ﬁt in the
box in either of two ways. Each card contains two columns of holes, some of which
may not be punched out. The puzzle is solved by placing all the cards in the box
so as to completely cover the bottom of the box (i.e., every hole position is blocked
by at least one card that has no hole there). Let PUZZLE = {⟨c1, . . . , ck⟩| each ci
represents a card and this collection of cards has a solution}. Show that PUZZLE
is NP-complete.
7.29 A coloring of a graph is an assignment of colors to its nodes so that no two adjacent
nodes are assigned the same color. Let
3COLOR = {⟨G⟩| G is colorable with 3 colors}.
Show that 3COLOR is NP-complete. (Hint: Use the following three subgraphs.)
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

326
CHAPTER 7 / TIME COMPLEXITY
7.30 Let SET-SPLITTING = {⟨S, C⟩| S is a ﬁnite set and C = {C1, . . . , Ck} is a
collection of subsets of S, for some k > 0, such that elements of S can be colored
red or blue so that no Ci has all its elements colored with the same color}. Show
that SET-SPLITTING is NP-complete.
7.31 Consider the following scheduling problem. You are given a list of ﬁnal exams
F1, . . . , Fk to be scheduled, and a list of students S1, . . . , Sl. Each student is taking
some speciﬁed subset of these exams. You must schedule these exams into slots so
that no student is required to take two exams in the same slot. The problem is to
determine if such a schedule exists that uses only h slots. Formulate this problem
as a language and show that this language is NP-complete.
7.32 This problem is inspired by the single-player game Minesweeper, generalized to an
arbitrary graph. Let G be an undirected graph, where each node either contains
a single, hidden mine or is empty. The player chooses nodes, one by one. If the
player chooses a node containing a mine, the player loses. If the player chooses an
empty node, the player learns the number of neighboring nodes containing mines.
(A neighboring node is one connected to the chosen node by an edge.) The player
wins if and when all empty nodes have been so chosen.
In the mine consistency problem, you are given a graph G along with numbers labeling
some of G’s nodes. You must determine whether a placement of mines on the
remaining nodes is possible, so that any node v that is labeled m has exactly m
neighboring nodes containing mines. Formulate this problem as a language and
show that it is NP-complete.
A7.33 In the following solitaire game, you are given an m × m board. On each of its
m2 positions lies either a blue stone, a red stone, or nothing at all. You play by
removing stones from the board until each column contains only stones of a sin-
gle color and each row contains at least one stone. You win if you achieve this
objective. Winning may or may not be possible, depending upon the initial con-
ﬁguration. Let SOLITAIRE = {⟨G⟩| G is a winnable game conﬁguration}. Prove
that SOLITAIRE is NP-complete.
7.34 Recall, in our discussion of the Church–Turing thesis, that we introduced the lan-
guage D = {⟨p⟩| p is a polynomial in several variables having an integral root}. We
stated, but didn’t prove, that D is undecidable. In this problem, you are to prove a
different property of D—namely, that D is NP-hard. A problem is NP-hard if all
problems in NP are polynomial time reducible to it, even though it may not be in
NP itself. So you must show that all problems in NP are polynomial time reducible
to D.
7.35 A subset of the nodes of a graph G is a dominating set if every other node of G is
adjacent to some node in the subset. Let
DOMINATING-SET = {⟨G, k⟩| G has a dominating set with k nodes}.
Show that it is NP-complete by giving a reduction from VERTEX-COVER.
⋆7.36 Show that the following problem is NP-complete. You are given a set of states Q =
{q0, q1, . . . , ql} and a collection of pairs {(s1, r1), . . . , (sk, rk)} where the si are
distinct strings over Σ = {0, 1}, and the ri are (not necessarily distinct) members
of Q. Determine whether a DFA M = (Q, Σ, δ, q0, F) exists where δ(q0, si) = ri
for each i. Here, δ(q, s) is the state that M enters after reading s, starting at state q.
(Note that F is irrelevant here.)
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
327
7.37 Let U = {⟨M, x, #t⟩| NTM M accepts x within t steps on at least one branch}.
Note that M isn’t required to halt on all branches. Show that U is NP-complete.
⋆7.38 Show that if P = NP, a polynomial time algorithm exists that produces a satisfying
assignment when given a satisﬁable Boolean formula. (Note: The algorithm you
are asked to provide computes a function; but NP contains languages, not func-
tions. The P = NP assumption implies that SAT is in P, so testing satisﬁability is
solvable in polynomial time. But the assumption doesn’t say how this test is done,
and the test may not reveal satisfying assignments. You must show that you can ﬁnd
them anyway. Hint: Use the satisﬁability tester repeatedly to ﬁnd the assignment
bit-by-bit.)
⋆7.39 Show that if P = NP, you can factor integers in polynomial time. (See the note in
Problem 7.38.)
A⋆7.40 Show that if P = NP, a polynomial time algorithm exists that takes an undirected
graph as input and ﬁnds a largest clique contained in that graph. (See the note in
Problem 7.38.)
7.41 In the proof of the Cook–Levin theorem, a window is a 2 × 3 rectangle of cells.
Show why the proof would have failed if we had used 2 × 2 windows instead.
⋆7.42 Consider the algorithm MINIMIZE, which takes a DFA M as input and outputs
DFA M ′.
MINIMIZE = “On input ⟨M⟩, where M = (Q, Σ, δ, q0, A) is a DFA:
1.
Remove all states of M that are unreachable from the start state.
2.
Construct the following undirected graph G whose nodes are
the states of M.
3.
Place an edge in G connecting every accept state with every
nonaccept state. Add additional edges as follows.
4.
Repeat until no new edges are added to G:
5.
For every pair of distinct states q and r of M and every a ∈Σ:
6.
Add the edge (q, r) to G if (δ(q, a), δ(r, a)) is an edge of G.
7.
For each state q, let [q] be the collection of states
[q] = {r ∈Q| no edge joins q and r in G}.
8.
Form a new DFA M ′ = (Q′, Σ, δ′, q0′, A′) where
Q′ = {[q]| q ∈Q} (if [q] = [r], only one of them is in Q′),
δ′([q], a) = [δ(q, a)] for every q ∈Q and a ∈Σ,
q0′ = [q0], and
A′ = {[q]| q ∈A}.
9.
Output ⟨M ′⟩.”
a. Show that M and M ′ are equivalent.
b. Show that M ′ is minimal—that is, no DFA with fewer states recognizes the
same language. You may use the result of Problem 1.52 without proof.
c. Show that MINIMIZE operates in polynomial time.
7.43 For a cnf-formula φ with m variables and c clauses, show that you can construct
in polynomial time an NFA with O(cm) states that accepts all nonsatisfying assign-
ments, represented as Boolean strings of length m. Conclude that P ̸= NP implies
that NFAs cannot be minimized in polynomial time.
⋆7.44 A 2cnf-formula is an AND of clauses, where each clause is an OR of at most two
literals. Let 2SAT = {⟨φ⟩| φ is a satisﬁable 2cnf-formula}. Show that 2SAT ∈P.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

328
CHAPTER 7 / TIME COMPLEXITY
7.45 Modify the algorithm for context-free language recognition in the proof of The-
orem 7.16 to give a polynomial time algorithm that produces a parse tree for a
string, given the string and a CFG, if that grammar generates the string.
7.46 Say that two Boolean formulas are equivalent if they have the same set of variables
and are true on the same set of assignments to those variables (i.e., they describe
the same Boolean function). A Boolean formula is minimal if no shorter Boolean
formula is equivalent to it. Let MIN-FORMULA be the collection of minimal
Boolean formulas. Show that if P = NP, then MIN-FORMULA ∈P.
7.47 The difference hierarchy DiP is deﬁned recursively as
a. D1P = NP and
b. DiP = {A| A = B \ C for B in NP and C in Di−1P}.
(Here B \ C = B ∩C.)
For example, a language in D2P is the difference of two NP languages. Sometimes
D2P is called DP (and may be written DP). Let
Z = {⟨G1, k1, G2, k2⟩| G1 has a k1-clique and G2 doesn’t have a k2-clique}.
Show that Z is complete for DP. In other words, show that Z is in DP and every
language in DP is polynomial time reducible to Z.
⋆7.48 Let MAX-CLIQUE = {⟨G, k⟩| a largest clique in G is of size exactly k}. Use the
result of Problem 7.47 to show that MAX-CLIQUE is DP-complete.
⋆7.49 Let f : N −→N be any function where f(n) = o(n log n). Show that TIME(f(n))
contains only the regular languages.
⋆7.50 Call a regular expression star-free if it does not contain any star operations. Then,
let EQSF−REX = {⟨R, S⟩| R and S are equivalent star-free regular expressions}.
Show that EQSF−REX is in coNP. Why does your argument fail for general regular
expressions?
⋆7.51 This problem investigates resolution, a method for proving the unsatisﬁability of
cnf-formulas. Let φ = C1 ∧C2 ∧· · · ∧Cm be a formula in cnf, where the Ci are its
clauses. Let C = {Ci| Ci is a clause of φ}. In a resolution step, we take two clauses
Ca and Cb in C, which both have some variable x occurring positively in one of
the clauses and negatively in the other. Thus, Ca = (x ∨y1 ∨y2 ∨· · · ∨yk) and
Cb = (x ∨z1 ∨z2 ∨· · · ∨zl), where the yi and zi are literals. We form the new
clause (y1 ∨y2 ∨· · · ∨yk ∨z1 ∨z2 ∨· · · ∨zl) and remove repeated literals. Add
this new clause to C. Repeat the resolution steps until no additional clauses can be
obtained. If the empty clause ( ) is in C, then declare φ unsatisﬁable.
Say that resolution is sound if it never declares satisﬁable formulas to be unsatisﬁ-
able. Say that resolution is complete if all unsatisﬁable formulas are declared to be
unsatisﬁable.
a. Show that resolution is sound and complete.
b. Use part (a) to show that 2SAT ∈P.
⋆7.52 Show that P is closed under homomorphism iff P = NP.
⋆7.53 Let A ⊆1∗be any unary language. Show that if A is NP-complete, then P = NP.
(Hint: Consider a polynomial time reduction f from SAT to A. For a formula φ,
let φ0100 be the reduced formula where variables x1, x2, x3, and x4 in φ are set to
the values 0, 1, 0, and 0, respectively. What happens when you apply f to all of
these exponentially many reduced formulas?)
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

SELECTED SOLUTIONS
329
7.54 In a directed graph, the indegree of a node is the number of incoming edges and
the outdegree is the number of outgoing edges. Show that the following problem
is NP-complete. Given an undirected graph G and a designated subset C of G’s
nodes, is it possible to convert G to a directed graph by assigning directions to each
of its edges so that every node in C has indegree 0 or outdegree 0, and every other
node in G has indegree at least 1?
SELECTED SOLUTIONS
7.1
(c) FALSE; (d) TRUE.
7.2
(c) TRUE; (d) TRUE.
7.16
Let A∈NP. Construct NTM M to decide A∗in nondeterministic polynomial time.
M = “On input w:
1.
Nondeterministically divide w into pieces w = x1x2 · · · xk.
2.
For each xi, nondeterministically guess the certiﬁcates that
show xi ∈A.
3.
Verify all certiﬁcates if possible, then accept.
Otherwise, if veriﬁcation fails, reject.”
7.23
We give a polynomial time mapping reduction from CLIQUE to HALF-CLIQUE.
The input to the reduction is a pair ⟨G, k⟩and the reduction produces the graph
⟨H⟩as output where H is as follows. If G has m nodes and k = m/2, then H = G.
If k < m/2, then H is the graph obtained from G by adding j nodes, each con-
nected to every one of the original nodes and to each other, where j = m −2k.
Thus, H has m + j = 2m −2k nodes. Observe that G has a k-clique iff H has a
clique of size k + j = m −k, and so ⟨G, k⟩∈CLIQUE iff ⟨H⟩∈HALF-CLIQUE.
If k > m/2, then H is the graph obtained by adding j nodes to G without any
additional edges, where j = 2k −m. Thus, H has m + j = 2k nodes, and so
G has a k-clique iff H has a clique of size k. Therefore, ⟨G, k⟩∈CLIQUE iff
⟨H⟩∈HALF-CLIQUE. We also need to show HALF-CLIQUE ∈NP. The certiﬁ-
cate is simply the clique.
7.33
First, SOLITAIRE ∈NP because we can verify that a solution works, in polynomial
time. Second, we show that 3SAT ≤P SOLITAIRE. Given φ with m variables
x1, . . . , xm and k clauses c1, . . . , ck, construct the following k × m game G. We
assume that φ has no clauses that contain both xi and xi because such clauses may
be removed without affecting satisﬁability.
If xi is in clause cj, put a blue stone in row cj, column xi. If xi is in clause cj, put a
red stone in row cj, column xi. We can make the board square by repeating a row
or adding a blank column as necessary without affecting solvability. We show that
φ is satisﬁable iff G has a solution.
(→) Take a satisfying assignment. If xi is true (false), remove the red (blue) stones
from the corresponding column. So stones corresponding to true literals remain.
Because every clause has a true literal, every row has a stone.
(←) Take a game solution. If the red (blue) stones were removed from a column,
set the corresponding variable true (false). Every row has a stone remaining, so
every clause has a true literal. Therefore, φ is satisﬁed.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

330
CHAPTER 7 / TIME COMPLEXITY
7.40
If you assume that P = NP, then CLIQUE ∈P, and you can test whether G con-
tains a clique of size k in polynomial time, for any value of k. By testing whether G
contains a clique of each size, from 1 to the number of nodes in G, you can deter-
mine the size t of a maximum clique in G in polynomial time. Once you know t,
you can ﬁnd a clique with t nodes as follows. For each node x of G, remove x and
calculate the resulting maximum clique size. If the resulting size decreases, replace
x and continue with the next node. If the resulting size is still t, keep x perma-
nently removed and continue with the next node. When you have considered all
nodes in this way, the remaining nodes are a t-clique.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8
S P A C E C O M P L E X I T Y
In this chapter, we consider the complexity of computational problems in terms
of the amount of space, or memory, that they require. Time and space are two
of the most important considerations when we seek practical solutions to many
computational problems. Space complexity shares many of the features of time
complexity and serves as a further way of classifying problems according to their
computational difﬁculty.
As we did with time complexity, we need to select a model for measuring the
space used by an algorithm. We continue with the Turing machine model for
the same reason that we used it to measure time. Turing machines are mathe-
matically simple and close enough to real computers to give meaningful results.
DEFINITION
8.1
Let M be a deterministic Turing machine that halts on all inputs.
The space complexity of M is the function f : N −→N, where f(n)
is the maximum number of tape cells that M scans on any input of
length n. If the space complexity of M is f(n), we also say that M
runs in space f(n).
If M is a nondeterministic Turing machine wherein all branches
halt on all inputs, we deﬁne its space complexity f(n) to be the
maximum number of tape cells that M scans on any branch of its
computation for any input of length n.
331
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

332
CHAPTER 8 / SPACE COMPLEXITY
We typically estimate the space complexity of Turing machines by using
asymptotic notation.
DEFINITION
8.2
Let f : N −→R+ be a function.
The space complexity classes,
SPACE(f(n)) and NSPACE(f(n)), are deﬁned as follows.
SPACE(f(n)) = {L| L is a language decided by an O(f(n)) space
deterministic Turing machine}.
NSPACE(f(n)) = {L| L is a language decided by an O(f(n)) space
nondeterministic Turing machine}.
EXAMPLE
8.3
In Chapter 7, we introduced the NP-complete problem SAT. Here, we show
that SAT can be solved with a linear space algorithm. We believe that SAT
cannot be solved with a polynomial time algorithm, much less with a linear time
algorithm, because SAT is NP-complete. Space appears to be more powerful
than time because space can be reused, whereas time cannot.
M1 = “On input ⟨φ⟩, where φ is a Boolean formula:
1.
For each truth assignment to the variables x1, . . . , xm of φ:
2.
Evaluate φ on that truth assignment.
3.
If φ ever evaluated to 1, accept; if not, reject.”
Machine M1 clearly runs in linear space because each iteration of the loop
can reuse the same portion of the tape. The machine needs to store only the
current truth assignment, and that can be done with O(m) space. The number
of variables m is at most n, the length of the input, so this machine runs in space
O(n).
EXAMPLE
8.4
Here, we illustrate the nondeterministic space complexity of a language. In the
next section, we show how determining the nondeterministic space complex-
ity can be useful in determining its deterministic space complexity. Consider
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8.1
SAVITCH’S THEOREM
333
the problem of testing whether a nondeterministic ﬁnite automaton accepts all
strings. Let
ALLNFA = {⟨A⟩| A is an NFA and L(A) = Σ∗}.
We give a nondeterministic linear space algorithm that decides the complement
of this language, ALLNFA. The idea behind this algorithm is to use nondeter-
minism to guess a string that is rejected by the NFA, and to use linear space to
keep track of which states the NFA could be in at a particular time. Note that
this language is not known to be in NP or in coNP.
N = “On input ⟨M⟩, where M is an NFA:
1.
Place a marker on the start state of the NFA.
2.
Repeat 2q times, where q is the number of states of M:
3.
Nondeterministically select an input symbol and change the
positions of the markers on M’s states to simulate reading
that symbol.
4.
Accept if stages 2 and 3 reveal some string that M rejects; that
is, if at some point none of the markers lie on accept states of
M. Otherwise, reject.”
If M rejects any strings, it must reject one of length at most 2q because in
any longer string that is rejected, the locations of the markers described in the
preceding algorithm would repeat. The section of the string between the rep-
etitions can be removed to obtain a shorter rejected string. Hence N decides
ALLNFA. (Note that N accepts improperly formed inputs, too.)
The only space needed by this algorithm is for storing the location of the
markers and the repeat loop counter, and that can be done with linear space.
Hence the algorithm runs in nondeterministic space O(n). Next, we prove a
theorem that provides information about the deterministic space complexity of
ALLNFA.
8.1
SAVITCH’S THEOREM
Savitch’s theorem is one of the earliest results concerning space complexity. It
shows that deterministic machines can simulate nondeterministic machines by
using a surprisingly small amount of space. For time complexity, such a simu-
lation seems to require an exponential increase in time. For space complexity,
Savitch’s theorem shows that any nondeterministic TM that uses f(n) space can
be converted to a deterministic TM that uses only f 2(n) space.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

334
CHAPTER 8 / SPACE COMPLEXITY
THEOREM
8.5
Savitch’s theorem
For any1 function f : N −→R+, where f(n) ≥n,
NSPACE(f(n)) ⊆SPACE(f 2(n)).
PROOF IDEA
We need to simulate an f(n) space NTM deterministically. A
naive approach is to proceed by trying all the branches of the NTM’s computation,
one by one. The simulation needs to keep track of which branch it is currently
trying so that it is able to go on to the next one. But a branch that uses f(n)
space may run for 2O(f(n)) steps and each step may be a nondeterministic choice.
Exploring the branches sequentially would require recording all the choices used
on a particular branch in order to be able to ﬁnd the next branch. Therefore,
this approach may use 2O(f(n)) space, exceeding our goal of O(f 2(n)) space.
Instead, we take a different approach by considering the following more gen-
eral problem. We are given two conﬁgurations of the NTM, c1 and c2, together
with a number t, and we test whether the NTM can get from c1 to c2 within t steps
using only f(n) space. We call this problem the yieldability problem. By solv-
ing the yieldability problem, where c1 is the start conﬁguration, c2 is the accept
conﬁguration, and t is the maximum number of steps that the nondeterministic
machine can use, we can determine whether the machine accepts its input.
We give a deterministic, recursive algorithm that solves the yieldability prob-
lem. It operates by searching for an intermediate conﬁguration cm, and recur-
sively testing whether (1) c1 can get to cm within t/2 steps, and (2) whether cm
can get to c2 within t/2 steps. Reusing the space for each of the two recursive
tests allows a signiﬁcant savings of space.
This algorithm needs space for storing the recursion stack. Each level of the
recursion uses O(f(n)) space to store a conﬁguration. The depth of the recur-
sion is log t, where t is the maximum time that the nondeterministic machine
may use on any branch. We have t = 2O(f(n)), so log t = O(f(n)). Hence the
deterministic simulation uses O(f 2(n)) space.
PROOF
Let N be an NTM deciding a language A in space f(n). We construct
a deterministic TM M deciding A. Machine M uses the procedure CANYIELD,
which tests whether one of N’s conﬁgurations can yield another within a speci-
ﬁed number of steps. This procedure solves the yieldability problem described
in the proof idea.
Let w be a string considered as input to N. For conﬁgurations c1 and c2 of
N, and integer t, CANYIELD(c1, c2, t) outputs accept if N can go from conﬁg-
uration c1 to conﬁguration c2 in t or fewer steps along some nondeterministic
1On page 351, we show that Savitch’s theorem also holds whenever f(n) ≥log n.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8.1
SAVITCH’S THEOREM
335
path. If not, CANYIELD outputs reject. For convenience, we assume that t is a
power of 2.
CANYIELD = “On input c1, c2, and t:
1.
If t = 1, then test directly whether c1 = c2 or whether c1 yields
c2 in one step according to the rules of N. Accept if either test
succeeds; reject if both fail.
2.
If t > 1, then for each conﬁguration cm of N using space f(n):
3.
Run CANYIELD(c1, cm, t
2).
4.
Run CANYIELD(cm, c2, t
2).
5.
If steps 3 and 4 both accept, then accept.
6.
If haven’t yet accepted, reject.”
Now we deﬁne M to simulate N as follows. We ﬁrst modify N so that when
it accepts, it clears its tape and moves the head to the leftmost cell—thereby
entering a conﬁguration called caccept. We let cstart be the start conﬁguration of
N on w. We select a constant d so that N has no more than 2df(n) conﬁgurations
using f(n) tape, where n is the length of w. Then we know that 2df(n) provides
an upper bound on the running time of any branch of N on w.
M = “On input w:
1.
Output the result of CANYIELD(cstart, caccept, 2df(n)).”
Algorithm CANYIELD obviously solves the yieldability problem, and hence
M correctly simulates N. We need to analyze it to verify that M works within
O(f 2(n)) space.
Whenever CANYIELD invokes itself recursively, it stores the current stage
number and the values of c1, c2, and t on a stack so that these values may be
restored upon return from the recursive invocation. Each level of the recursion
thus uses O(f(n)) additional space. Furthermore, each level of the recursion
divides the size of t in half. Initially t starts out equal to 2df(n), so the depth
of the recursion is O(log 2df(n)) or O(f(n)). Therefore, the total space used is
O(f 2(n)), as claimed.
One technical difﬁculty arises in this argument because algorithm M needs to
know the value of f(n) when it calls CANYIELD. We can handle this difﬁculty
by modifying M so that it tries f(n) = 1, 2, 3, . . . . For each value f(n) = i, the
modiﬁed algorithm uses CANYIELD to determine whether the accept conﬁgu-
ration is reachable. In addition, it uses CANYIELD to determine whether N uses
at least space i + 1 by testing whether N can reach any of the conﬁgurations of
length i+1 from the start conﬁguration. If the accept conﬁguration is reachable,
M accepts; if no conﬁguration of length i + 1 is reachable, M rejects; and other-
wise, M continues with f(n) = i + 1. (We could have handled this difﬁculty in
another way by assuming that M can compute f(n) within O(f(n)) space, but
then we would need to add that assumption to the statement of the theorem.)
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

336
CHAPTER 8 / SPACE COMPLEXITY
8.2
THE CLASS PSPACE
By analogy with the class P, we deﬁne the class PSPACE for space complexity.
DEFINITION
8.6
PSPACE is the class of languages that are decidable in polynomial
space on a deterministic Turing machine. In other words,
PSPACE =
[
k
SPACE(nk).
We deﬁne NPSPACE, the nondeterministic counterpart to PSPACE, in
terms of the NSPACE classes. However, PSPACE = NPSPACE by virtue of
Savitch’s theorem because the square of any polynomial is still a polynomial.
In Examples 8.3 and 8.4, we showed that SAT is in SPACE(n) and that
ALLNFA is in coNSPACE(n) and hence, by Savitch’s theorem, in SPACE(n2)
because the deterministic space complexity classes are closed under complement.
Therefore, both languages are in PSPACE.
Let’s examine the relationship of PSPACE with P and NP. We observe that
P ⊆PSPACE because a machine that runs quickly cannot use a great deal of
space. More precisely, for t(n) ≥n, any machine that operates in time t(n) can
use at most t(n) space because a machine can explore at most one new cell at each
step of its computation. Similarly, NP ⊆NPSPACE, and so NP ⊆PSPACE.
Conversely, we can bound the time complexity of a Turing machine in terms
of its space complexity. For f(n) ≥n, a TM that uses f(n) space can have at most
f(n) 2O(f(n)) different conﬁgurations, by a simple generalization of the proof of
Lemma 5.8 on page 222. A TM computation that halts may not repeat a conﬁgu-
ration. Therefore, a TM2 that uses space f(n) must run in time f(n) 2O(f(n)), so
PSPACE ⊆EXPTIME = S
k TIME(2nk).
We summarize our knowledge of the relationships among the complexity
classes deﬁned so far in the series of containments
P ⊆NP ⊆PSPACE = NPSPACE ⊆EXPTIME.
We don’t know whether any of these containments is actually an equality.
Someone may yet discover a simulation like the one in Savitch’s theorem that
merges some of these classes into the same class. However, in Chapter 9 we
prove that P ̸= EXPTIME. Therefore, at least one of the preceding contain-
ments is proper, but we are unable to say which!
Indeed, most researchers
2The requirement here that f(n) ≥n is generalized later to f(n) ≥log n when we
introduce TMs that use sublinear space on page 350.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8.3
PSPACE-COMPLETENESS
337
believe that all the containments are proper. The following diagram depicts
the relationships among these classes, assuming that all are different.
FIGURE
8.7
Conjectured relationships among P, NP, PSPACE, and EXPTIME
8.3
PSPACE-COMPLETENESS
In Section 7.4, we introduced the category of NP-complete languages as rep-
resenting the most difﬁcult languages in NP. Demonstrating that a language is
NP-complete provides strong evidence that the language is not in P. If it were,
P and NP would be equal. In this section, we introduce the analogous notion
PSPACE-completeness for the class PSPACE.
DEFINITION
8.8
A language B is PSPACE-complete if it satisﬁes two conditions:
1. B is in PSPACE, and
2. every A in PSPACE is polynomial time reducible to B.
If B merely satisﬁes condition 2, we say that it is PSPACE-hard.
In deﬁning PSPACE-completeness, we use polynomial time reducibility as
given in Deﬁnition 7.29. Why don’t we deﬁne a notion of polynomial space
reducibility and use that instead of polynomial time reducibility? To understand
the answer to this important question, consider our motivation for deﬁning com-
plete problems in the ﬁrst place.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

338
CHAPTER 8 / SPACE COMPLEXITY
Complete problems are important because they are examples of the most
difﬁcult problems in a complexity class. A complete problem is most difﬁcult
because any other problem in the class is easily reduced into it. So if we ﬁnd an
easy way to solve the complete problem, we can easily solve all other problems in
the class. The reduction must be easy, relative to the complexity of typical prob-
lems in the class, for this reasoning to apply. If the reduction itself were difﬁcult
to compute, an easy solution to the complete problem wouldn’t necessarily yield
an easy solution to the problems reducing to it.
Therefore, the rule is: Whenever we deﬁne complete problems for a com-
plexity class, the reduction model must be more limited than the model used for
deﬁning the class itself.
THE TQBF PROBLEM
Our ﬁrst example of a PSPACE-complete problem involves a generalization of
the satisﬁability problem. Recall that a Boolean formula is an expression that
contains Boolean variables, the constants 0 and 1, and the Boolean operations ∧,
∨, and ¬. We now introduce a more general type of Boolean formula.
The quantiﬁers ∀(for all) and ∃(there exists) make frequent appearances in
mathematical statements. Writing the statement ∀x φ means that for every value
for the variable x, the statement φ is true. Similarly, writing the statement ∃x φ
means that for some value of the variable x, the statement φ is true. Sometimes,
∀is referred to as the universal quantiﬁer and ∃as the existential quantiﬁer.
We say that the variable x immediately following the quantiﬁer is bound to the
quantiﬁer.
For example, considering the natural numbers, the statement ∀x [x + 1 > x]
means that the successor x + 1 of every natural number x is greater than
the number itself. Obviously, this statement is true. However, the statement
∃y [y + y = 3] obviously is false. When interpreting the meaning of statements
involving quantiﬁers, we must consider the universe from which the values are
drawn. In the preceding cases, the universe comprised the natural numbers; but
if we took the real numbers instead, the existentially quantiﬁed statement would
become true.
Statements may contain several quantiﬁers, as in ∀x ∃y [y > x]. For the uni-
verse of the natural numbers, this statement says that every natural number has
another natural number larger than it. The order of the quantiﬁers is impor-
tant. Reversing the order, as in the statement ∃y ∀x [y > x], gives an entirely
different meaning—namely, that some natural number is greater than all others.
Obviously, the ﬁrst statement is true and the second statement is false.
A quantiﬁer may appear anywhere in a mathematical statement. It applies to
the fragment of the statement appearing within the matched pair of parentheses
or brackets following the quantiﬁed variable. This fragment is called the scope
of the quantiﬁer. Often, it is convenient to require that all quantiﬁers appear at
the beginning of the statement and that each quantiﬁer’s scope is everything fol-
lowing it. Such statements are said to be in prenex normal form. Any statement
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8.3
PSPACE-COMPLETENESS
339
may be put into prenex normal form easily. We consider statements in this form
only, unless otherwise indicated.
Boolean formulas with quantiﬁers are called quantiﬁed Boolean formulas.
For such formulas, the universe is {0, 1}. For example,
φ = ∀x ∃y

(x ∨y) ∧(x ∨y)

is a quantiﬁed Boolean formula. Here, φ is true, but it would be false if the
quantiﬁers ∀x and ∃y were reversed.
When each variable of a formula appears within the scope of some quantiﬁer,
the formula is said to be fully quantiﬁed. A fully quantiﬁed Boolean formula
is sometimes called a sentence and is always either true or false. For example,
the preceding formula φ is fully quantiﬁed. However, if the initial part, ∀x, of
φ were removed, the formula would no longer be fully quantiﬁed and would be
neither true nor false.
The TQBF problem is to determine whether a fully quantiﬁed Boolean for-
mula is true or false. We deﬁne the language
TQBF = {⟨φ⟩| φ is a true fully quantiﬁed Boolean formula}.
THEOREM
8.9
TQBF is PSPACE-complete.
PROOF IDEA
To show that TQBF is in PSPACE, we give a straightforward
algorithm that assigns values to the variables and recursively evaluates the truth
of the formula for those values. From that information, the algorithm can deter-
mine the truth of the original quantiﬁed formula.
To show that every language A in PSPACE reduces to TQBF in polynomial
time, we begin with a polynomial space-bounded Turing machine for A. Then
we give a polynomial time reduction that maps a string to a quantiﬁed Boolean
formula φ that encodes a simulation of the machine on that input. The formula
is true iff the machine accepts.
As a ﬁrst attempt at this construction, let’s try to imitate the proof of the
Cook–Levin theorem, Theorem 7.37. We can construct a formula φ that simu-
lates M on an input w by expressing the requirements for an accepting tableau.
A tableau for M on w has width O(nk), the space used by M, but its height is
exponential in nk because M can run for exponential time. Thus, if we were to
represent the tableau with a formula directly, we would end up with a formula
of exponential size. However, a polynomial time reduction cannot produce an
exponential-size result, so this attempt fails to show that A ≤P TQBF.
Instead, we use a technique related to the proof of Savitch’s theorem to con-
struct the formula. The formula divides the tableau into halves and employs the
universal quantiﬁer to represent each half with the same part of the formula.
The result is a much shorter formula.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

340
CHAPTER 8 / SPACE COMPLEXITY
PROOF
First, we give a polynomial space algorithm deciding TQBF.
T = “On input ⟨φ⟩, a fully quantiﬁed Boolean formula:
1.
If φ contains no quantiﬁers, then it is an expression with only
constants, so evaluate φ and accept if it is true; otherwise, reject.
2.
If φ equals ∃x ψ, recursively call T on ψ, ﬁrst with 0 substituted
for x and then with 1 substituted for x. If either result is accept,
then accept; otherwise, reject.
3.
If φ equals ∀x ψ, recursively call T on ψ, ﬁrst with 0 substituted
for x and then with 1 substituted for x. If both results are ac-
cept, then accept; otherwise, reject.”
Algorithm T obviously decides TQBF. To analyze its space complexity, we
observe that the depth of the recursion is at most the number of variables. At
each level we need only store the value of one variable, so the total space used is
O(m), where m is the number of variables that appear in φ. Therefore, T runs
in linear space.
Next, we show that TQBF is PSPACE-hard. Let A be a language decided by
a TM M in space nk for some constant k. We give a polynomial time reduction
from A to TQBF.
The reduction maps a string w to a quantiﬁed Boolean formula φ that is true
iff M accepts w. To show how to construct φ, we solve a more general problem.
Using two collections of variables denoted c1 and c2 representing two conﬁgu-
rations and a number t > 0, we construct a formula φc1,c2,t. If we assign c1 and
c2 to actual conﬁgurations, the formula is true iff M can go from c1 to c2 in at
most t steps. Then we can let φ be the formula φcstart,caccept,h, where h = 2df(n) for
a constant d, chosen so that M has no more than 2df(n) possible conﬁgurations
on an input of length n. Here, let f(n) = nk. For convenience, we assume that
t is a power of 2.
The formula encodes the contents of conﬁguration cells as in the proof of the
Cook–Levin theorem. Each cell has several variables associated with it, one for
each tape symbol and state, corresponding to the possible settings of that cell.
Each conﬁguration has nk cells and so is encoded by O(nk) variables.
If t = 1, we can easily construct φc1,c2,t. We design the formula to say that
either c1 equals c2, or c2 follows from c1 in a single step of M. We express
the equality by writing a Boolean expression saying that each of the variables
representing c1 contains the same Boolean value as the corresponding variable
representing c2. We express the second possibility by using the technique pre-
sented in the proof of the Cook–Levin theorem. That is, we can express that
c1 yields c2 in a single step of M by writing Boolean expressions stating that
the contents of each triple of c1’s cells correctly yields the contents of the corre-
sponding triple of c2’s cells.
If t > 1, we construct φc1,c2,t recursively. As a warm-up, let’s try one idea that
doesn’t quite work and then ﬁx it. Let
φc1,c2,t = ∃m1

φc1,m1, t
2 ∧φm1,c2, t
2

.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8.3
PSPACE-COMPLETENESS
341
The symbol m1 represents a conﬁguration of M. Writing ∃m1 is shorthand for
∃x1, . . . , xl, where l = O(nk) and x1, . . . , xl are the variables that encode m1.
So this construction of φc1,c2,t says that M can go from c1 to c2 in at most t steps
if some intermediate conﬁguration m1 exists, whereby M can go from c1 to m1
in at most t
2 steps and then from m1 to c2 in at most t
2 steps. Then we construct
the two formulas φc1,m1, t
2 and φm1,c2, t
2 recursively.
The formula φc1,c2,t has the correct value; that is, it is TRUE whenever M
can go from c1 to c2 within t steps. However, it is too big. Every level of the
recursion involved in the construction cuts t in half but roughly doubles the size
of the formula. Hence we end up with a formula of size roughly t. Initially
t = 2df(n), so this method gives an exponentially large formula.
To reduce the size of the formula, we use the ∀quantiﬁer in addition to the ∃
quantiﬁer. Let
φc1,c2,t = ∃m1 ∀(c3,c4)∈{(c1,m1), (m1,c2)}

φc3,c4, t
2

.
The introduction of the new variables representing the conﬁgurations c3 and c4
allows us to “fold” the two recursive subformulas into a single subformula, while
preserving the original meaning. By writing ∀(c3,c4) ∈{(c1,m1), (m1,c2)}, we
indicate that the variables representing the conﬁgurations c3 and c4 may take the
values of the variables of c1 and m1 or of m1 and c2, respectively, and that the
resulting formula φc3,c4, t
2 is true in either case. We may replace the construct
∀x ∈{y,z} [ . . . ] with the equivalent construct ∀x [ (x = y ∨x = z) →. . . ] to
obtain a syntactically correct quantiﬁed Boolean formula. Recall that in Sec-
tion 0.2, we showed that Boolean implication (→) and Boolean equality (=) can
be expressed in terms of AND and NOT. Here, for clarity, we use the symbol =
for Boolean equality instead of the equivalent symbol ↔used in Section 0.2.
To calculate the size of the formula φcstart,caccept,h, where h = 2df(n), we note
that each level of the recursion adds a portion of the formula that is linear in the
size of the conﬁgurations and is thus of size O(f(n)). The number of levels of
the recursion is log(2df(n)), or O(f(n)). Hence the size of the resulting formula
is O(f 2(n)).
WINNING STRATEGIES FOR GAMES
For the purposes of this section, a game is loosely deﬁned to be a competition
in which opposing parties attempt to achieve some goal according to prespec-
iﬁed rules. Games appear in many forms, from board games such as chess to
economic and war games that model corporate or societal conﬂict.
Games are closely related to quantiﬁers. A quantiﬁed statement has a corre-
sponding game; conversely, a game often has a corresponding quantiﬁed state-
ment. These correspondences are helpful in several ways. For one, expressing a
mathematical statement that uses many quantiﬁers in terms of the correspond-
ing game may give insight into the statement’s meaning. For another, expressing
a game in terms of a quantiﬁed statement aids in understanding the complexity
of the game. To illustrate the correspondence between games and quantiﬁers,
we turn to an artiﬁcial game called the formula game.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

342
CHAPTER 8 / SPACE COMPLEXITY
Let φ = ∃x1 ∀x2 ∃x3 · · · Qxk [ ψ ] be a quantiﬁed Boolean formula in prenex
normal form. Here, Q represents either a ∀or an ∃quantiﬁer. We associate a
game with φ as follows. Two players, called Player A and Player E, take turns
selecting the values of the variables x1, . . . , xk. Player A selects values for the
variables that are bound to ∀quantiﬁers, and Player E selects values for the
variables that are bound to ∃quantiﬁers. The order of play is the same as that
of the quantiﬁers at the beginning of the formula. At the end of play, we use the
values that the players have selected for the variables and declare that Player E
has won the game if ψ, the part of the formula with the quantiﬁers stripped off,
is now TRUE. Player A has won if ψ is now FALSE.
EXAMPLE
8.10
Say that φ1 is the formula
∃x1 ∀x2 ∃x3

(x1 ∨x2) ∧(x2 ∨x3) ∧(x2 ∨x3)

.
In the formula game for φ1, Player E picks the value of x1, then Player A picks
the value of x2, and ﬁnally Player E picks the value of x3.
To illustrate a sample play of this game, we begin by representing the Boolean
value TRUE with 1 and FALSE with 0, as usual. Let’s say that Player E picks
x1 = 1, then Player A picks x2 = 0, and ﬁnally Player E picks x3 = 1. With
these values for x1, x2, and x3, the subformula
(x1 ∨x2) ∧(x2 ∨x3) ∧(x2 ∨x3)
is 1, so Player E has won the game. In fact, Player E may always win this game by
selecting x1 = 1 and then selecting x3 to be the negation of whatever Player A
selects for x2. We say that Player E has a winning strategy for this game. A
player has a winning strategy for a game if that player wins when both sides play
optimally.
Now let’s change the formula slightly to get a game in which Player A has a
winning strategy. Let φ2 be the formula
∃x1 ∀x2 ∃x3

(x1 ∨x2) ∧(x2 ∨x3) ∧(x2 ∨x3)

.
Player A now has a winning strategy because no matter what Player E selects
for x1, Player A may select x2 = 0, thereby falsifying the part of the formula
appearing after the quantiﬁers, whatever Player E’s last move may be.
We next consider the problem of determining which player has a winning
strategy in the formula game associated with a particular formula. Let
FORMULA-GAME = {⟨φ⟩| Player E has a winning strategy in
the formula game associated with φ}.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8.3
PSPACE-COMPLETENESS
343
THEOREM
8.11
FORMULA-GAME is PSPACE-complete.
PROOF IDEA
FORMULA-GAME is PSPACE-complete for a simple reason.
It is the same as TQBF. To see that FORMULA-GAME = TQBF, observe that a
formula is TRUE exactly when Player E has a winning strategy in the associated
formula game. The two statements are different ways of saying the same thing.
PROOF
The formula φ = ∃x1 ∀x2 ∃x3 · · · [ ψ ] is TRUE when some setting
for x1 exists such that for any setting of x2, a setting of x3 exists such that, and so
on . . . , where ψ is TRUE under the settings of the variables. Similarly, Player E
has a winning strategy in the game associated with φ when Player E can make
some assignment to x1 such that for any setting of x2, Player E can make an
assignment to x3 such that, and so on . . . , where ψ is TRUE under these settings
of the variables.
The same reasoning applies when the formula doesn’t alternate between ex-
istential and universal quantiﬁers. If φ has the form ∀x1, x2, x3 ∃x4, x5 ∀x6 [ ψ ],
Player A would make the ﬁrst three moves in the formula game to assign values
to x1, x2, and x3; then Player E would make two moves to assign x4 and x5; and
ﬁnally Player A would assign a value x6.
Hence φ ∈TQBF exactly when φ ∈FORMULA-GAME, and the theorem
follows from Theorem 8.9.
GENERALIZED GEOGRAPHY
Now that we know that the formula game is PSPACE-complete, we can es-
tablish the PSPACE-completeness or PSPACE-hardness of some other games
more easily. We’ll begin with a generalization of the game geography and later
discuss games such as chess, checkers, and GO.
Geography is a child’s game in which players take turns naming cities from
anywhere in the world. Each city chosen must begin with the same letter that
ended the previous city’s name. Repetition isn’t permitted. The game starts with
some designated starting city and ends when some player loses because he or she
is unable to continue. For example, if the game starts with Peoria, then Amherst
might legally follow (because Peoria ends with the letter a, and Amherst begins
with the letter a), then Tucson, then Nashua, and so on until one player gets
stuck and thereby loses.
We can model this game with a directed graph whose nodes are the cities of
the world. We draw an arrow from one city to another if the ﬁrst can lead to the
second according to the game rules. In other words, the graph contains an edge
from a city X to a city Y if city X ends with the same letter that begins city Y. We
illustrate a portion of the geography graph in Figure 8.12.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

344
CHAPTER 8 / SPACE COMPLEXITY
FIGURE
8.12
Portion of the graph representing the geography game
When the rules of geography are interpreted for this graphic representation,
one player starts by selecting the designated start node and then the players take
turns picking nodes that form a simple path in the graph. The requirement that
the path be simple (i.e., doesn’t use any node more than once) corresponds to the
requirement that a city may not be repeated. The ﬁrst player unable to extend
the path loses the game.
In generalized geography, we take an arbitrary directed graph with a des-
ignated start node instead of the graph associated with the actual cities. For
example, the following graph is an example of a generalized geography game.
FIGURE
8.13
A sample generalized geography game
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8.3
PSPACE-COMPLETENESS
345
Say that Player I is the one who moves ﬁrst and Player II second. In this
example, Player I has a winning strategy as follows. Player I starts at node 1,
the designated start node. Node 1 points only at nodes 2 and 3, so Player I’s
ﬁrst move must be one of these two choices. He chooses 3. Now Player II must
move, but node 3 points only to node 5, so she is forced to select node 5. Then
Player I selects 6, from choices 6, 7, and 8. Now Player II must play from node 6,
but it points only to node 3, and 3 was previously played. Player II is stuck and
thus Player I wins.
If we change the example by reversing the direction of the edge between
nodes 3 and 6, Player II has a winning strategy. Can you see it? If Player I starts
out with node 3 as before, Player II responds with 6 and wins immediately, so
Player I’s only hope is to begin with 2. In that case, however, Player II responds
with 4. If Player I now takes 5, Player II wins with 6. If Player I takes 7, Player II
wins with 9. No matter what Player I does, Player II can ﬁnd a way to win, so
Player II has a winning strategy.
The problem of determining which player has a winning strategy in a gener-
alized geography game is PSPACE-complete. Let
GG = {⟨G, b⟩| Player I has a winning strategy for the generalized
geography game played on graph G starting at node b}.
THEOREM
8.14
GG is PSPACE-complete.
PROOF IDEA
A recursive algorithm similar to the one used for TQBF in
Theorem 8.9 determines which player has a winning strategy. This algorithm
runs in polynomial space and so GG ∈PSPACE.
To prove that GG is PSPACE-hard, we give a polynomial time reduction
from FORMULA-GAME to GG. This reduction converts a formula game to
a generalized geography graph so that play on the graph mimics play in the
formula game. In effect, the players in the generalized geography game are
really playing an encoded form of the formula game.
PROOF
The following algorithm decides whether Player I has a winning
strategy in instances of generalized geography; in other words, it decides GG.
We show that it runs in polynomial space.
M = “On input ⟨G, b⟩, where G is a directed graph and b is a node of G:
1.
If b has outdegree 0, reject because Player I loses immediately.
2.
Remove node b and all connected arrows to get a new graph G′.
3.
For each of the nodes b1, b2, . . . , bk that b originally pointed at,
recursively call M on ⟨G′, bi⟩.
4.
If all of these accept, Player II has a winning strategy in the
original game, so reject. Otherwise, Player II doesn’t have a
winning strategy, so Player I must; therefore, accept.”
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

346
CHAPTER 8 / SPACE COMPLEXITY
The only space required by this algorithm is for storing the recursion stack.
Each level of the recursion adds a single node to the stack, and at most m levels
occur, where m is the number of nodes in G. Hence the algorithm runs in linear
space.
To establish the PSPACE-hardness of GG, we show that FORMULA-GAME
is polynomial time reducible to GG. The reduction maps the formula
φ = ∃x1 ∀x2 ∃x3 · · · Qxk [ ψ ]
to an instance ⟨G, b⟩of generalized geography. Here we assume for simplicity
that φ’s quantiﬁers begin and end with ∃, and that they strictly alternate between
∃and ∀. A formula that doesn’t conform to this assumption may be converted
to a slightly larger one that does by adding extra quantiﬁers binding otherwise
unused or “dummy” variables. We assume also that ψ is in conjunctive normal
form (see Problem 8.12).
The reduction constructs a geography game on a graph G where optimal play
mimics optimal play of the formula game on φ. Player I in the geography game
takes the role of Player E in the formula game, and Player II takes the role of
Player A.
The structure of graph G is partially shown in the following ﬁgure. Play starts
at node b, which appears at the top left-hand side of G. Underneath b, a sequence
of diamond structures appears, one for each of the variables of φ. Before getting
to the right-hand side of G, let’s see how play proceeds on the left-hand side.
FIGURE
8.15
Partial structure of the geography game simulating the formula game
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8.3
PSPACE-COMPLETENESS
347
Play starts at b. Player I must select one of the two edges going from b. These
edges correspond to Player E’s possible choices at the beginning of the formula
game. The left-hand choice for Player I corresponds to TRUE for Player E in the
formula game and the right-hand choice to FALSE. After Player I has selected
one of these edges—say, the left-hand one—Player II moves. Only one outgoing
edge is present, so this move is forced. Similarly, Player I’s next move is forced
and play continues from the top of the second diamond. Now two edges again
are present, but Player II gets the choice. This choice corresponds to Player A’s
ﬁrst move in the formula game. As play continues in this way, Players I and II
choose a rightward or leftward path through each of the diamonds.
After play passes through all the diamonds, the head of the path is at the
bottom node in the last diamond, and it is Player I’s turn because we assumed
that the last quantiﬁer is ∃. Player I’s next move is forced. Then they are at node
c in Figure 8.15 and Player II makes the next move.
This point in the geography game corresponds to the end of play in the
formula game. The chosen path through the diamonds corresponds to an as-
signment to φ’s variables. Under that assignment, if ψ is TRUE, Player E wins
the formula game; and if ψ is FALSE, Player A wins. The structure on the right-
hand side of the following ﬁgure guarantees that Player I can win if Player E has
won, and that Player II can win if Player A has won.
FIGURE
8.16
Full structure of the geography game simulating the formula game, where
φ = ∃x1 ∀x2 · · · ∃xk [(x1 ∨x2 ∨x3) ∧(x2 ∨x3 ∨· · · ) ∧· · · ∧(
)]
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

348
CHAPTER 8 / SPACE COMPLEXITY
At node c, Player II may choose a node corresponding to one of ψ’s clauses.
Then Player I may choose a node corresponding to a literal in that clause.
The nodes corresponding to unnegated literals are connected to the left-hand
(TRUE) sides of the diamond for associated variables, and similarly for negated
literals and right-hand (FALSE) sides as shown in Figure 8.16.
If ψ is FALSE, Player II may win by selecting the unsatisﬁed clause. Any
literal that Player I may then pick is FALSE and is connected to the side of the
diamond that hasn’t yet been played. Thus Player II may play the node in the
diamond, but then Player I is unable to move and loses. If ψ is TRUE, any clause
that Player II picks contains a TRUE literal. Player I selects that literal after
Player II’s move. Because the literal is TRUE, it is connected to the side of the
diamond that has already been played, so Player II is unable to move and loses.
In Theorem 8.14, we showed that no polynomial time algorithm exists for
optimal play in generalized geography unless P = PSPACE. We’d like to prove
a similar theorem regarding the difﬁculty of computing optimal play in board
games such as chess, but an obstacle arises. Only a ﬁnite number of different
game positions may occur on the standard 8 × 8 chess board. In principle, all
these positions may be placed in a table, along with a best move in each position.
The table would be too large to ﬁt inside our galaxy but, being ﬁnite, could be
stored in the control of a Turing machine (or even that of a ﬁnite automaton!).
Thus, the machine would be able to play optimally in linear time, using table
lookup. Perhaps at some time in the future, methods that can quantify the com-
plexity of ﬁnite problems will be developed. But current methods are asymptotic
and hence apply only to the rate of growth of the complexity as the problem size
increases—not to any ﬁxed size. Nevertheless, we can give some evidence for
the difﬁculty of computing optimal play for many board games by generaliz-
ing them to an n × n board. Such generalizations of chess, checkers, and GO
have been shown to be PSPACE-hard or hard for even larger complexity classes,
depending on the details of the generalization.
8.4
THE CLASSES L AND NL
Until now, we have considered only time and space complexity bounds that are
at least linear—that is, bounds where f(n) is at least n. Now we examine smaller,
sublinear space bounds. In time complexity, sublinear bounds are insufﬁcient for
reading the entire input, so we don’t consider them here. In sublinear space com-
plexity, the machine is able to read the entire input but it doesn’t have enough
space to store the input. To consider this situation meaningfully, we must modify
our computational model.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8.4
THE CLASSES L AND NL
349
We introduce a Turing machine with two tapes: a read-only input tape, and a
read/write work tape. On the read-only tape, the input head can detect symbols
but not change them. We provide a way for the machine to detect when the head
is at the left-hand and right-hand ends of the input. The input head must remain
on the portion of the tape containing the input. The work tape may be read and
written in the usual way. Only the cells scanned on the work tape contribute to
the space complexity of this type of Turing machine.
Think of a read-only input tape as a CD-ROM, a device used for input on
many personal computers. Often, the CD-ROM contains more data than the
computer can store in its main memory. Sublinear space algorithms allow the
computer to manipulate the data without storing all of it in main memory.
For space bounds that are at least linear, the two-tape TM model is equivalent
to the standard one-tape model (see Exercise 8.1). For sublinear space bounds,
we use only the two-tape model.
DEFINITION
8.17
L is the class of languages that are decidable in logarithmic space
on a deterministic Turing machine. In other words,
L = SPACE(log n).
NL is the class of languages that are decidable in logarithmic space
on a nondeterministic Turing machine. In other words,
NL = NSPACE(log n).
We focus on log n space instead of, say, √n or log2 n space, for several rea-
sons that are similar to those for our selection of polynomial time and space
bounds. Logarithmic space is just large enough to solve a number of interesting
computational problems, and it has attractive mathematical properties such as
robustness even when the machine model and input encoding method change.
Pointers into the input may be represented in logarithmic space, so one way to
think about the power of log space algorithms is to consider the power of a ﬁxed
number of input pointers.
EXAMPLE
8.18
The language A = {0k1k| k ≥0} is a member of L. In Section 7.1, on page 275
we described a Turing machine that decides A by zig-zagging back and forth
across the input, crossing off the 0s and 1s as they are matched. That algorithm
uses linear space to record which positions have been crossed off, but it can be
modiﬁed to use only log space.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

350
CHAPTER 8 / SPACE COMPLEXITY
The log space TM for A cannot cross off the 0s and 1s that have been matched
on the input tape because that tape is read-only. Instead, the machine counts
the number of 0s and, separately, the number of 1s in binary on the work tape.
The only space required is that used to record the two counters. In binary, each
counter uses only logarithmic space and hence the algorithm runs in O(log n)
space. Therefore, A ∈L.
EXAMPLE
8.19
Recall the language
PATH = {⟨G, s, t⟩| G is a directed graph that has a directed path from s to t}
deﬁned in Section 7.2. Theorem 7.14 shows that PATH is in P, but that the
algorithm given uses linear space. We don’t know whether PATH can be solved
in logarithmic space deterministically, but we do know a nondeterministic log
space algorithm for PATH.
The nondeterministic log space Turing machine deciding PATH operates by
starting at node s and nondeterministically guessing the nodes of a path from s
to t. The machine records only the position of the current node at each step on
the work tape, not the entire path (which would exceed the logarithmic space
requirement).
The machine nondeterministically selects the next node from
among those pointed at by the current node. It repeats this action until it reaches
node t and accepts, or until it has gone on for m steps and rejects, where m is
the number of nodes in the graph. Thus, PATH is in NL.
Our earlier claim that any f(n) space bounded Turing machine also runs in
time 2O(f(n)) is no longer true for very small space bounds. For example, a
Turing machine that uses O(1) (i.e., constant) space may run for n steps. To
obtain a bound on the running time that applies for every space bound f(n), we
give the following deﬁnition.
DEFINITION
8.20
If M is a Turing machine that has a separate read-only input tape
and w is an input, a conﬁguration of M on w is a setting of the
state, the work tape, and the positions of the two tape heads. The
input w is not a part of the conﬁguration of M on w.
If M runs in f(n) space and w is an input of length n, the number of conﬁgu-
rations of M on w is n2O(f(n)). To explain this result, let’s say that M has c states
and g tape symbols. The number of strings that can appear on the work tape is
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8.5
NL-COMPLETENESS
351
gf(n). The input head can be in one of n positions, and the work tape head can
be in one of f(n) positions. Therefore, the total number of conﬁgurations of M
on w, which is an upper bound on the running time of M on w, is cnf(n)gf(n),
or n2O(f(n)).
We focus almost exclusively on space bounds f(n) that are at least log n. Our
earlier claim that the time complexity of a machine is at most exponential in
its space complexity remains true for such bounds because n2O(f(n)) is 2O(f(n))
when f(n) ≥log n.
Recall that Savitch’s theorem shows that we can convert nondeterministic TMs
to deterministic TMs and increase the space complexity f(n) by only a squaring,
provided that f(n) ≥n. We can extend Savitch’s theorem to hold for sublinear
space bounds down to f(n) ≥log n. The proof is identical to the original one
we gave on page 334, except that we use Turing machines with a read-only input
tape; and instead of referring to conﬁgurations of N, we refer to conﬁgurations
of N on w. Storing a conﬁguration of N on w uses log(n2O(f(n))) = log n +
O(f(n)) space. If f(n) ≥log n, the storage used is O(f(n)) and the remainder
of the proof remains the same.
8.5
NL-COMPLETENESS
As we mentioned in Example 8.19, the PATH problem is known to be in NL but
isn’t known to be in L. We believe that PATH doesn’t belong to L, but we don’t
know how to prove this conjecture. In fact, we don’t know of any problem in
NL that can be proven to be outside L. Analogous to the question of whether
P = NP, we have the question of whether L = NL.
As a step toward resolving the L versus NL question, we can exhibit certain
languages that are NL-complete. As with complete languages for other com-
plexity classes, the NL-complete languages are examples of languages that are,
in a certain sense, the most difﬁcult languages in NL. If L and NL are different,
all NL-complete languages don’t belong to L.
As with our previous deﬁnitions of completeness, we deﬁne an NL-complete
language to be one that is in NL and to which any other language in NL is
reducible. However, we don’t use polynomial time reducibility here because, as
you will see, all problems in NL are solvable in polynomial time. Therefore,
every two problems in NL except ∅and Σ∗are polynomial time reducible to one
another (see the discussion of polynomial time reducibility in the deﬁnition of
PSPACE-completeness on page 337). Hence polynomial time reducibility is too
strong to differentiate problems in NL from one another. Instead we use a new
type of reducibility called log space reducibility.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

352
CHAPTER 8 / SPACE COMPLEXITY
DEFINITION
8.21
A log space transducer is a Turing machine with a read-only input
tape, a write-only output tape, and a read/write work tape. The
head on the output tape cannot move leftward, so it cannot read
what it has written. The work tape may contain O(log n) symbols.
A log space transducer M computes a function f : Σ∗−→Σ∗, where
f(w) is the string remaining on the output tape after M halts when
it is started with w on its input tape. We call f a log space com-
putable function. Language A is log space reducible to language B,
written A ≤L B, if A is mapping reducible to B by means of a log
space computable function f.
Now we are ready to deﬁne NL-completeness.
DEFINITION
8.22
A language B is NL-complete if
1. B ∈NL, and
2. every A in NL is log space reducible to B.
If one language is log space reducible to another language already known to
be in L, the original language is also in L, as the following theorem demonstrates.
THEOREM
8.23
If A ≤L B and B ∈L, then A ∈L.
PROOF
A tempting approach to the proof of this theorem is to follow the
model presented in Theorem 7.31, the analogous result for polynomial time re-
ducibility. In that approach, a log space algorithm for A ﬁrst maps its input w to
f(w), using the log space reduction f, and then applies the log space algorithm
for B. However, the storage required for f(w) may be too large to ﬁt within the
log space bound, so we need to modify this approach.
Instead, A’s machine MA computes individual symbols of f(w) as requested
by B’s machine MB. In the simulation, MA keeps track of where MB’s input
head would be on f(w). Every time MB moves, MA restarts the computation
of f on w from the beginning and ignores all the output except for the desired
location of f(w). Doing so may require occasional recomputation of parts of
f(w) and so is inefﬁcient in its time complexity. The advantage of this method
is that only a single symbol of f(w) needs to be stored at any point, in effect
trading time for space.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8.5
NL-COMPLETENESS
353
COROLLARY
8.24
If any NL-complete language is in L, then L = NL.
SEARCHING IN GRAPHS
THEOREM
8.25
PATH is NL-complete.
PROOF IDEA
Example 8.19 shows that PATH is in NL, so we only need to
show that PATH is NL-hard. In other words, we must show that every language
A in NL is log space reducible to PATH.
The idea behind the log space reduction from A to PATH is to construct a
graph that represents the computation of the nondeterministic log space Turing
machine for A. The reduction maps a string w to a graph whose nodes cor-
respond to the conﬁgurations of the NTM on input w. One node points to a
second node if the corresponding ﬁrst conﬁguration can yield the second con-
ﬁguration in a single step of the NTM. Hence the machine accepts w whenever
some path from the node corresponding to the start conﬁguration leads to the
node corresponding to the accepting conﬁguration.
PROOF
We show how to give a log space reduction from any language A in
NL to PATH. Let’s say that NTM M decides A in O(log n) space. Given an
input w, we construct ⟨G, s, t⟩in log space, where G is a directed graph that
contains a path from s to t if and only if M accepts w.
The nodes of G are the conﬁgurations of M on w. For conﬁgurations c1 and
c2 of M on w, the pair (c1, c2) is an edge of G if c2 is one of the possible next
conﬁgurations of M starting from c1. More precisely, if M’s transition function
indicates that c1’s state together with the tape symbols under its input and work
tape heads can yield the next state and head actions to make c1 into c2, then
(c1, c2) is an edge of G. Node s is the start conﬁguration of M on w. Machine
M is modiﬁed to have a unique accepting conﬁguration, and we designate this
conﬁguration to be node t.
This mapping reduces A to PATH because whenever M accepts its input,
some branch of its computation accepts, which corresponds to a path from the
start conﬁguration s to the accepting conﬁguration t in G. Conversely, if some
path exists from s to t in G, some computation branch accepts when M runs on
input w, and M accepts w.
To show that the reduction operates in log space, we give a log space trans-
ducer that outputs ⟨G, s, t⟩on input w. We describe G by listing its nodes and
edges. Listing the nodes is easy because each node is a conﬁguration of M on w
and can be represented in c log n space for some constant c. The transducer se-
quentially goes through all possible strings of length c log n, tests whether each
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

354
CHAPTER 8 / SPACE COMPLEXITY
is a legal conﬁguration of M on w, and outputs those that pass the test. The
transducer lists the edges similarly. Log space is sufﬁcient for verifying that a
conﬁguration c1 of M on w can yield conﬁguration c2 because the transducer
only needs to examine the actual tape contents under the head locations given
in c1 to determine that M’s transition function would give conﬁguration c2 as
a result. The transducer tries all pairs (c1, c2) in turn to ﬁnd which qualify as
edges of G. Those that do are added to the output tape.
One immediate spinoff of Theorem 8.25 is the following corollary, which
states that NL is a subset of P.
COROLLARY
8.26
NL ⊆P.
PROOF
Theorem 8.25 shows that any language in NL is log space reducible
to PATH.
Recall that a Turing machine that uses space f(n) runs in time
n 2O(f(n)), so a reducer that runs in log space also runs in polynomial time.
Therefore, any language in NL is polynomial time reducible to PATH, which
in turn is in P, by Theorem 7.14. We know that every language that is polyno-
mial time reducible to a language in P is also in P, so the proof is complete.
Though log space reducibility appears to be highly restrictive, it is adequate
for most reductions in complexity theory because these are usually computa-
tionally simple. For example, in Theorem 8.9 we showed that every PSPACE
problem is polynomial time reducible to TQBF. The highly repetitive formu-
las that these reductions produce may be computed using only log space, and
therefore we may conclude that TQBF is PSPACE-complete with respect to log
space reducibility. This conclusion is important because Corollary 9.6 shows
that NL ⊊PSPACE. This separation and log space reducibility imply that
TQBF ̸∈NL.
8.6
NL EQUALS CONL
This section contains one of the most surprising results known concerning the
relationships among complexity classes. The classes NP and coNP are generally
believed to be different. At ﬁrst glance, the same appears to hold for the classes
NL and coNL. The fact that NL equals coNL, as we are about to prove, shows
that our intuition about computation still has many gaps in it.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

8.6
NL EQUALS CONL
355
THEOREM
8.27
NL = coNL.
PROOF IDEA
We show that PATH is in NL, and thereby establish that ev-
ery problem in coNL is also in NL, because PATH is NL-complete. The NL
algorithm M that we present for PATH must have an accepting computation
whenever the input graph G does not contain a path from s to t.
First, let’s tackle an easier problem. Let c be the number of nodes in G that
are reachable from s. We assume that c is provided as an input to M and show
how to use c to solve PATH. Later we show how to compute c.
Given G, s, t, and c, the machine M operates as follows. One by one, M
goes through all the m nodes of G and nondeterministically guesses whether
each one is reachable from s. Whenever a node u is guessed to be reachable, M
attempts to verify this guess by guessing a path of length m or less from s to u. If
a computation branch fails to verify this guess, it rejects. In addition, if a branch
guesses that t is reachable, it rejects. Machine M counts the number of nodes
that have been veriﬁed to be reachable. When a branch has gone through all
of G’s nodes, it checks that the number of nodes that it veriﬁed to be reachable
from s equals c, the number of nodes that actually are reachable, and rejects if
not. Otherwise, this branch accepts.
In other words, if M nondeterministically selects exactly c nodes reachable
from s, not including t, and proves that each is reachable from s by guessing the
path, M knows that the remaining nodes, including t, are not reachable, so it can
accept.
Next, we show how to calculate c, the number of nodes reachable from s. We
describe a nondeterministic log space procedure whereby at least one computa-
tion branch has the correct value for c and all other branches reject.
For each i from 0 to m, we deﬁne Ai to be the collection of nodes that are at
a distance of i or less from s (i.e., that have a path of length at most i from s).
So A0 = {s}, each Ai ⊆Ai+1, and Am contains all nodes that are reachable
from s. Let ci be the number of nodes in Ai. We next describe a procedure that
calculates ci+1 from ci. Repeated application of this procedure yields the desired
value of c = cm.
We calculate ci+1 from ci, using an idea similar to the one presented earlier
in this proof sketch. The algorithm goes through all the nodes of G, determines
whether each is a member of Ai+1, and counts the members.
To determine whether a node v is in Ai+1, we use an inner loop to go through
all the nodes of G and guess whether each node is in Ai. Each positive guess is
veriﬁed by guessing the path of length at most i from s. For each node u veriﬁed
to be in Ai, the algorithm tests whether (u, v) is an edge of G. If it is an edge,
v is in Ai+1. Additionally, the number of nodes veriﬁed to be in Ai is counted.
At the completion of the inner loop, if the total number of nodes veriﬁed to be
in Ai is not ci, all Ai have not been found, so this computation branch rejects.
If the count equals ci and v has not yet been shown to be in Ai+1, we conclude
that it isn’t in Ai+1. Then we go on to the next v in the outer loop.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

356
CHAPTER 8 / SPACE COMPLEXITY
PROOF
Here is an algorithm for PATH. Let m be the number of nodes of G.
M = “On input ⟨G, s, t⟩:
1.
Let c0 = 1.
[[ A0 = {s} has 1 node ]]
2.
For i = 0 to m −1:
[[ compute ci+1 from ci ]]
3.
Let ci+1 = 1.
[[ ci+1 counts nodes in Ai+1 ]]
4.
For each node v ̸= s in G:
[[ check if v ∈Ai+1 ]]
5.
Let d = 0.
[[ d re-counts Ai ]]
6.
For each node u in G:
[[ check if u ∈Ai ]]
7.
Nondeterministically either perform or skip these steps:
8.
Nondeterministically follow a path of length at most i
from s and reject if it doesn’t end at u.
9.
Increment d.
[[ veriﬁed that u ∈Ai ]]
10.
If (u, v) is an edge of G, increment ci+1 and go to
stage 5 with the next v.
[[ veriﬁed that v ∈Ai+1 ]]
11.
If d ̸= ci, then reject.
[[ check whether found all Ai ]]
12.
Let d = 0.
[[ cm now known; d re-counts Am ]]
13.
For each node u in G:
[[ check if u ∈Am ]]
14.
Nondeterministically either perform or skip these steps:
15.
Nondeterministically follow a path of length at most m
from s and reject if it doesn’t end at u.
16.
If u = t, then reject.
[[ found path from s to t ]]
17.
Increment d.
[[ veriﬁed that u ∈Am ]]
18.
If d ̸= cm, then reject.
[[ check whether found all of Am ]]
Otherwise, accept.”
This algorithm only needs to store m, u, v, ci, ci+1, d, i, and a pointer to the
head of a path at any given time. Hence it runs in log space. (Note that M
accepts improperly formed inputs, too.)
We summarize our present knowledge of the relationships among several
complexity classes as follows:
L ⊆NL = coNL ⊆P ⊆NP ⊆PSPACE.
We don’t know whether any of these containments are proper, although we
prove NL ⊊PSPACE in Corollary 9.6. Consequently, either coNL ⊊P or
P ⊊PSPACE must hold, but we don’t know which one does! Most researchers
conjecture that all these containments are proper.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

EXERCISES
357
EXERCISES
8.1 Show that for any function f : N −→R+, where f(n) ≥n, the space complexity
class SPACE(f(n)) is the same whether you deﬁne the class by using the single-
tape TM model or the two-tape read-only input TM model.
8.2 Consider the following position in the standard tic-tac-toe game.
×
⃝
⃝
⃝
⃝
⃝
⃝
×
Let’s say that it is the ×-player’s turn to move next. Describe a winning strategy
for this player. (Recall that a winning strategy isn’t merely the best move to make
in the current position. It also includes all the responses that this player must make
in order to win, however the opponent moves.)
8.3 Consider the following generalized geography game wherein the start node is the
one with the arrow pointing in from nowhere. Does Player I have a winning strat-
egy? Does Player II? Give reasons for your answers.
8.4 Show that PSPACE is closed under the operations union, complementation, and
star.
A8.5 Show that ADFA ∈L.
8.6 Show that any PSPACE-hard language is also NP-hard.
A8.7 Show that NL is closed under the operations union, concatenation, and star.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

358
CHAPTER 8 / SPACE COMPLEXITY
PROBLEMS
8.8 Let EQREX = {⟨R, S⟩| R and S are equivalent regular expressions}. Show that
EQREX ∈PSPACE.
8.9 A ladder is a sequence of strings s1, s2, . . . , sk, wherein every string differs from
the preceding one by exactly one character. For example, the following is a ladder
of English words, starting with “head” and ending with “free”:
head, hear, near, fear, bear, beer, deer, deed, feed, feet, fret, free.
Let LADDERDFA = {⟨M, s, t⟩| M is a DFA and L(M) contains a ladder of strings,
starting with s and ending with t}. Show that LADDERDFA is in PSPACE.
8.10 The Japanese game go-moku is played by two players, “X” and “O,” on a 19 × 19
grid. Players take turns placing markers, and the ﬁrst player to achieve ﬁve of her
markers consecutively in a row, column, or diagonal is the winner. Consider this
game generalized to an n × n board. Let
GM = {⟨B⟩| B is a position in generalized go-moku,
where player “X” has a winning strategy}.
By a position we mean a board with markers placed on it, such as may occur in the
middle of a play of the game, together with an indication of which player moves
next. Show that GM ∈PSPACE.
8.11 Show that if every NP-hard language is also PSPACE-hard, then PSPACE = NP.
8.12 Show that TQBF restricted to formulas where the part following the quantiﬁers is
in conjunctive normal form is still PSPACE-complete.
8.13 Deﬁne ALBA = {⟨M, w⟩| M is an LBA that accepts input w}. Show that ALBA is
PSPACE-complete.
⋆8.14 The cat-and-mouse game is played by two players, “Cat” and “Mouse,” on an arbi-
trary undirected graph. At a given point, each player occupies a node of the graph.
The players take turns moving to a node adjacent to the one that they currently
occupy. A special node of the graph is called “Hole.” Cat wins if the two players
ever occupy the same node. Mouse wins if it reaches the Hole before the preceding
happens. The game is a draw if a situation repeats (i.e., the two players simultane-
ously occupy positions that they simultaneously occupied previously, and it is the
same player’s turn to move).
HAPPY-CAT = {⟨G, c, m, h⟩| G, c, m, h are respectively a graph, and
positions of the Cat, Mouse, and Hole, such that
Cat has a winning strategy if Cat moves ﬁrst}.
Show that HAPPY-CAT is in P. (Hint: The solution is not complicated and doesn’t
depend on subtle details in the way the game is deﬁned. Consider the entire game
tree. It is exponentially big, but you can search it in polynomial time.)
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

PROBLEMS
359
8.15 Consider the following two-person version of the language PUZZLE that was de-
scribed in Problem 7.28. Each player starts with an ordered stack of puzzle cards.
The players take turns placing the cards in order in the box and may choose which
side faces up. Player I wins if all hole positions are blocked in the ﬁnal stack, and
Player II wins if some hole position remains unblocked. Show that the problem of
determining which player has a winning strategy for a given starting conﬁguration
of the cards is PSPACE-complete.
8.16 Read the deﬁnition of MIN-FORMULA in Problem 7.46.
a. Show that MIN-FORMULA ∈PSPACE.
b. Explain why this argument fails to show that MIN-FORMULA ∈coNP:
If φ ̸∈MIN-FORMULA, then φ has a smaller equivalent formula. An NTM
can verify that φ ∈MIN-FORMULA by guessing that formula.
8.17 Let A be the language of properly nested parentheses. For example, (()) and
(()(()))() are in A, but )( is not. Show that A is in L.
⋆8.18 Let B be the language of properly nested parentheses and brackets. For example,
([()()]()[]) is in B but ([)] is not. Show that B is in L.
⋆8.19 The game of Nim is played with a collection of piles of sticks. In one move, a
player may remove any nonzero number of sticks from a single pile. The players
alternately take turns making moves. The player who removes the very last stick
loses. Say that we have a game position in Nim with k piles containing s1, . . . , sk
sticks. Call the position balanced if each column of bits contains an even number
of 1s when each of the numbers si is written in binary, and the binary numbers are
written as rows of a matrix aligned at the low order bits. Prove the following two
facts.
a. Starting in an unbalanced position, a single move exists that changes the
position into a balanced one.
b. Starting in a balanced position, every single move changes the position into
an unbalanced one.
Let NIM = {⟨s1, . . . , sk⟩| each si is a binary number and Player I has a winning
strategy in the Nim game starting at this position}. Use the preceding facts about
balanced positions to show that NIM ∈L.
8.20 Let MULT = {a#b#c| a, b, c are binary natural numbers and a × b = c}. Show
that MULT ∈L.
8.21 For any positive integer x, let xR be the integer whose binary representation is
the reverse of the binary representation of x. (Assume no leading 0s in the binary
representation of x.) Deﬁne the function R+ : N −→N where R+(x) = x + xR.
a. Let A2 = {⟨x, y⟩| R+(x) = y}. Show A2 ∈L.
b. Let A3 = {⟨x, y⟩| R+(R+(x)) = y}. Show A3 ∈L.
8.22
a. Let ADD = {⟨x, y, z⟩| x, y, z > 0 are binary integers and x + y = z}. Show
that ADD ∈L.
b. Let PAL-ADD = {⟨x, y⟩| x, y > 0 are binary integers where x + y is an
integer whose binary representation is a palindrome}. (Note that the binary
representation of the sum is assumed not to have leading zeros. A palin-
drome is a string that equals its reverse.) Show that PAL-ADD ∈L.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

360
CHAPTER 8 / SPACE COMPLEXITY
⋆8.23 Deﬁne UCYCLE = {⟨G⟩| G is an undirected graph that contains a simple cycle}.
Show that UCYCLE ∈L. (Note: G may be a graph that is not connected.)
⋆8.24 For each n, exhibit two regular expressions, R and S, of length poly(n), where
L(R) ̸= L(S), but where the ﬁrst string on which they differ is exponentially long.
In other words, L(R) and L(S) must be different, yet agree on all strings of length
up to 2ϵn for some constant ϵ > 0.
8.25 An undirected graph is bipartite if its nodes may be divided into two sets so that
all edges go from a node in one set to a node in the other set. Show that a graph is
bipartite if and only if it doesn’t contain a cycle that has an odd number of nodes.
Let BIPARTITE = {⟨G⟩| G is a bipartite graph}. Show that BIPARTITE ∈NL.
8.26 Deﬁne UPATH to be the counterpart of PATH for undirected graphs. Show that
BIPARTITE ≤L UPATH. (Note: In fact, we can prove UPATH ∈L, and therefore
BIPARTITE ∈L, but the algorithm [62] is too difﬁcult to present here.)
8.27 Recall that a directed graph is strongly connected if every two nodes are connected
by a directed path in each direction. Let
STRONGLY-CONNECTED = {⟨G⟩| G is a strongly connected graph}.
Show that STRONGLY-CONNECTED is NL-complete.
8.28 Let BOTH NFA = {⟨M1, M2⟩| M1 and M2 are NFAs where L(M1) ∩L(M2) ̸= ∅}.
Show that BOTH NFA is NL-complete.
8.29 Show that ANFA is NL-complete.
8.30 Show that EDFA is NL-complete.
⋆8.31 Show that 2SAT is NL-complete.
8.32 Let CNFH1 = {⟨φ⟩| φ is a satisﬁable cnf-formula where each clause contains
any number of positive literals and at most one negated literal.
Furthermore,
each negated literal has at most one occurrence in φ}. Show that CNFH1 is NL-
complete.
⋆8.33 Give an example of an NL-complete context-free language.
A⋆8.34 Deﬁne CYCLE = {⟨G⟩| G is a directed graph that contains a directed cycle}. Show
that CYCLE is NL-complete.
SELECTED SOLUTIONS
8.5
Construct a TM M to decide ADFA. When M receives input ⟨A, w⟩, a DFA and a
string, M simulates A on w by keeping track of A’s current state and its current
head location, and updating them appropriately. The space required to carry out
this simulation is O(log n) because M can record each of these values by storing a
pointer into its input.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

SELECTED SOLUTIONS
361
8.7
Let A1 and A2 be languages that are decided by NL-machines N1 and N2. Con-
struct three Turing machines: N∪deciding A1 ∪A2;
N◦deciding A1 ◦A2;
and N∗deciding A∗
1. Each of these machines operates as follows.
Machine N∪nondeterministically branches to simulate N1 or to simulate N2. In
either case, N∪accepts if the simulated machine accepts.
Machine N◦nondeterministically selects a position on the input to divide it into
two substrings.
Only a pointer to that position is stored on the work tape—
insufﬁcient space is available to store the substrings themselves. Then N◦simulates
N1 on the ﬁrst substring, branching nondeterministically to simulate N1’s nonde-
terminism. On any branch that reaches N1’s accept state, N◦simulates N2 on the
second substring. On any branch that reaches N2’s accept state, N◦accepts.
Machine N∗has a more complex algorithm, so we describe its stages.
N∗= “On input w:
1.
Initialize two input position pointers p1 and p2 to 0, the position
immediately preceding the ﬁrst input symbol.
2.
Accept if no input symbols occur after p2.
3.
Move p2 forward to a nondeterministically selected position.
4.
Simulate N1 on the substring of w from the position following
p1 to the position at p2, branching nondeterministically to sim-
ulate N1’s nondeterminism.
5.
If this branch of the simulation reaches N1’s accept state, copy
p2 to p1 and go to stage 2. If N1 rejects on this branch, reject.”
8.34
Reduce PATH to CYCLE. The idea behind the reduction is to modify the PATH
problem instance ⟨G, s, t⟩by adding an edge from t to s in G. If a path exists from
s to t in G, a directed cycle will exist in the modiﬁed G. However, other cycles may
exist in the modiﬁed G because they may already be present in G. To handle that
problem, ﬁrst change G so that it contains no cycles. A leveled directed graph is
one where the nodes are divided into groups, A1, A2, . . . , Ak, called levels, and only
edges from one level to the next higher level are permitted. Observe that a leveled
graph is acyclic. The PATH problem for leveled graphs is still NL-complete, as the
following reduction from the unrestricted PATH problem shows. Given a graph G
with two nodes s and t, and m nodes in total, produce the leveled graph G′ whose
levels are m copies of G’s nodes. Draw an edge from node i at each level to node j
in the next level if G contains an edge from i to j. Additionally, draw an edge from
node i in each level to node i in the next level. Let s′ be the node s in the ﬁrst level
and let t′ be the node t in the last level. Graph G contains a path from s to t iff G′
contains a path from s′ to t′. If you modify G′ by adding an edge from t′ to s′, you
obtain a reduction from PATH to CYCLE. The reduction is computationally sim-
ple, and its implementation in logspace is routine. Furthermore, a straightforward
procedure shows that CYCLE ∈NL. Hence CYCLE is NL-complete.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

9
I N T R A C T A B I L I T Y
Certain computational problems are solvable in principle, but the solutions re-
quire so much time or space that they can’t be used in practice. Such problems
are called intractable.
In Chapters 7 and 8, we introduced several problems thought to be intractable
but none that have been proven to be intractable. For example, most people
believe the SAT problem and all other NP-complete problems are intractable,
although we don’t know how to prove that they are. In this chapter, we give
examples of problems that we can prove to be intractable.
In order to present these examples, we develop several theorems that relate
the power of Turing machines to the amount of time or space available for
computation. We conclude the chapter with a discussion of the possibility of
proving that problems in NP are intractable and thereby solving the P versus
NP question. First, we introduce the relativization technique and use it to argue
that certain methods won’t allow us to achieve this goal. Then, we discuss cir-
cuit complexity theory, an approach taken by researchers that has shown some
promise.
363
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

364
CHAPTER 9 / INTRACTABILITY
9.1
HIERARCHY THEOREMS
Common sense suggests that giving a Turing machine more time or more space
should increase the class of problems that it can solve. For example, Turing
machines should be able to decide more languages in time n3 than they can in
time n2. The hierarchy theorems prove that this intuition is correct, subject to
certain conditions described below. We use the term hierarchy theorem because
these theorems prove that the time and space complexity classes aren’t all the
same—they form a hierarchy whereby the classes with larger bounds contain
more languages than do the classes with smaller bounds.
The hierarchy theorem for space complexity is slightly simpler than the one
for time complexity, so we present it ﬁrst. We begin with the following technical
deﬁnition.
DEFINITION
9.1
A function f : N −→N, where f(n) is at least O(log n), is called
space constructible if the function that maps the string 1n to the
binary representation of f(n) is computable in space O(f(n)).1
In other words, f is space constructible if some O(f(n)) space TM exists that
always halts with the binary representation of f(n) on its tape when started on
input 1n. Fractional functions such as n log2 n and √n are rounded down to the
next lower integer for the purposes of time and space constructibility.
EXAMPLE
9.2
All commonly occurring functions that are at least O(log n) are space con-
structible, including the functions log2 n, n log2 n, and n2.
For example, n2 is space constructible because a machine may take its input
1n, obtain n in binary by counting the number of 1s, and output n2 by using any
standard method for multiplying n by itself. The total space used is O(n), which
is certainly O(n2).
When showing functions f(n) that are o(n) to be space constructible, we use
a separate read-only input tape, as we did when we deﬁned sublinear space com-
plexity in Section 8.4. For example, such a machine can compute the function
that maps 1n to the binary representation of log2 n as follows. It ﬁrst counts the
number of 1s in its input in binary, using its work tape as it moves its head along
the input tape. Then, with n in binary on its work tape, it can compute log2 n
by counting the number of bits in the binary representation of n.
1Recall that 1n means a string of n 1s.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

9.1
HIERARCHY THEOREMS
365
The role of space constructibility in the space hierarchy theorem may be un-
derstood from the following situation. If f(n) and g(n) are two space bounds,
where f(n) is asymptotically larger than g(n), we would expect a machine to be
able to decide more languages in f(n) space than in g(n) space. However, sup-
pose that f(n) exceeds g(n) by only a very small and hard to compute amount.
Then, the machine may not be able to use the extra space proﬁtably because even
computing the amount of extra space may require more space than is available.
In this case, a machine may not be able to compute more languages in f(n) space
than it can in g(n) space. Stipulating that f(n) is space constructible avoids this
situation and allows us to prove that a machine can compute more than it would
be able to in any asymptotically smaller bound, as the following theorem shows.
THEOREM
9.3
Space hierarchy theorem
For any space constructible function f : N −→N,
a language A exists that is decidable in O(f(n)) space but not in o(f(n)) space.
PROOF IDEA
We must demonstrate a language A that has two properties.
The ﬁrst says that A is decidable in O(f(n)) space. The second says that A isn’t
decidable in o(f(n)) space.
We describe A by giving an algorithm D that decides it. Algorithm D runs in
O(f(n)) space, thereby ensuring the ﬁrst property. Furthermore, D guarantees
that A is different from any language that is decidable in o(f(n)) space, thereby
ensuring the second property. Language A is different from languages we have
discussed previously in that it lacks a nonalgorithmic deﬁnition. Therefore, we
cannot offer a simple mental picture of A.
In order to ensure that A not be decidable in o(f(n)) space, we design D to
implement the diagonalization method that we used to prove the unsolvability
of the acceptance problem ATM in Theorem 4.11 on page 202. If M is a TM
that decides a language in o(f(n)) space, D guarantees that A differs from M’s
language in at least one place. Which place? The place corresponding to a
description of M itself.
Let’s look at the way D operates. Roughly speaking, D takes its input to be
the description of a TM M. (If the input isn’t the description of any TM, then D’s
action is inconsequential on this input, so we arbitrarily make D reject.) Then,
D runs M on the same input—namely, ⟨M⟩—within the space bound f(n). If
M halts within that much space, D accepts iff M rejects. If M doesn’t halt,
D just rejects. So if M runs within space f(n), D has enough space to ensure
that its language is different from M’s. If not, D doesn’t have enough space to
ﬁgure out what M does. But fortunately D has no requirement to act differently
from machines that don’t run in o(f(n)) space, so D’s action on this input is
inconsequential.
This description captures the essence of the proof but omits several impor-
tant details. If M runs in o(f(n)) space, D must guarantee that its language is
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

366
CHAPTER 9 / INTRACTABILITY
different from M’s language. But even when M runs in o(f(n)) space, it may use
more than f(n) space for small n, when the asymptotic behavior hasn’t “kicked
in” yet. Possibly, D might not have enough space to run M to completion on
input ⟨M⟩, and hence D will miss its one opportunity to avoid M’s language. So,
if we aren’t careful, D might end up deciding the same language that M decides,
and the theorem wouldn’t be proved.
We can ﬁx this problem by modifying D to give it additional opportunities
to avoid M’s language. Instead of running M only when D receives input ⟨M⟩,
it runs M whenever it receives an input of the form ⟨M⟩10∗; that is, an input
of the form ⟨M⟩followed by a 1 and some number of 0s. Then, if M really is
running in o(f(n)) space, D will have enough space to run it to completion on
input ⟨M⟩10k for some large value of k because the asymptotic behavior must
eventually kick in.
One last technical point arises. When D runs M on some string, M may get
into an inﬁnite loop while using only a ﬁnite amount of space. But D is supposed
to be a decider, so we must ensure that D doesn’t loop while simulating M. Any
machine that runs in space o(f(n)) uses only 2o(f(n)) time. We modify D so that
it counts the number of steps used in simulating M. If this count ever exceeds
2f(n), then D rejects.
PROOF
The following O(f(n)) space algorithm D decides a language A that
is not decidable in o(f(n)) space.
D = “On input w:
1.
Let n be the length of w.
2.
Compute f(n) using space constructibility and mark off this
much tape. If later stages ever attempt to use more, reject.
3.
If w is not of the form ⟨M⟩10∗for some TM M, reject.
4.
Simulate M on w while counting the number of steps used in
the simulation. If the count ever exceeds 2f(n), reject.
5.
If M accepts, reject. If M rejects, accept.”
In stage 4, we need to give additional details of the simulation in order to
determine the amount of space used. The simulated TM M has an arbitrary tape
alphabet and D has a ﬁxed tape alphabet, so we represent each cell of M’s tape
with several cells on D’s tape. Therefore, the simulation introduces a constant
factor overhead in the space used. In other words, if M runs in g(n) space, then
D uses d g(n) space to simulate M for some constant d that depends on M.
Machine D is a decider because each of its stages can run for a limited time.
Let A be the language that D decides. Clearly, A is decidable in space O(f(n))
because D does so. Next, we show that A is not decidable in o(f(n)) space.
Assume to the contrary that some Turing machine M decides A in space g(n),
where g(n) is o(f(n)). As mentioned earlier, D can simulate M, using space
d g(n) for some constant d. Because g(n) is o(f(n)), some constant n0 exists,
where d g(n) < f(n) for all n ≥n0. Therefore, D’s simulation of M will run to
completion so long as the input has length n0 or more. Consider what happens
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

9.1
HIERARCHY THEOREMS
367
when D is run on input ⟨M⟩10n0. This input is longer than n0, so the simulation
in stage 4 will complete. Therefore, D will do the opposite of M on the same in-
put. Hence M doesn’t decide A, which contradicts our assumption. Therefore,
A is not decidable in o(f(n)) space.
COROLLARY
9.4
For any two functions f1, f2: N −→N, where f1(n) is o(f2(n)) and f2 is space
constructible, SPACE(f1(n)) ⊊SPACE(f2(n)).2
This corollary allows us to separate various space complexity classes. For
example, we can show that the function nc is space constructible for any natu-
ral number c. Hence for any two natural numbers c1 < c2, we can prove that
SPACE(nc1) ⊊SPACE(nc2). With a bit more work, we can show that nc is
space constructible for any rational number c > 0 and thereby extend the pre-
ceding containment to hold for any rational numbers 0 ≤c1 < c2. Observing
that two rational numbers c1 and c2 always exist between any two real numbers
ϵ1 < ϵ2 such that ϵ1 < c1 < c2 < ϵ2, we obtain the following additional corollary
demonstrating a ﬁne hierarchy within the class PSPACE.
COROLLARY
9.5
For any two real numbers 0 ≤ϵ1 < ϵ2,
SPACE(nϵ1) ⊊SPACE(nϵ2).
We can also use the space hierarchy theorem to separate two space complexity
classes we previously encountered.
COROLLARY
9.6
NL ⊊PSPACE.
PROOF
Savitch’s theorem shows that NL ⊆SPACE(log2 n), and the space
hierarchy theorem shows that SPACE(log2 n) ⊊SPACE(n). Hence the corol-
lary follows.
As we observed on page 354, this separation shows that TQBF ̸∈NL because
TQBF is PSPACE-complete with respect to log space reducibility.
2Recall that A ⊊B means A is a proper (i.e., not equal) subset of B.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

368
CHAPTER 9 / INTRACTABILITY
Now we establish the main objective of this chapter: proving the existence of
problems that are decidable in principle but not in practice—that is, problems
that are decidable but intractable. Each of the SPACE(nk) classes is contained
within the class SPACE(nlog n), which in turn is strictly contained within the
class SPACE(2n). Therefore, we obtain the following additional corollary sepa-
rating PSPACE from EXPSPACE = S
k SPACE(2nk).
COROLLARY
9.7
PSPACE ⊊EXPSPACE.
This corollary establishes the existence of decidable problems that are in-
tractable, in the sense that their decision procedures must use more than poly-
nomial space. The languages themselves are somewhat artiﬁcial—interesting
only for the purpose of separating complexity classes. We use these languages
to prove the intractability of other, more natural, languages after we discuss the
time hierarchy theorem.
DEFINITION
9.8
A function t: N −→N, where t(n) is at least O(n log n), is called
time constructible if the function that maps the string 1n to the
binary representation of t(n) is computable in time O(t(n)).
In other words, t is time constructible if some O(t(n)) time TM exists that
always halts with the binary representation of t(n) on its tape when started on
input 1n.
EXAMPLE
9.9
All commonly occurring functions that are at least n log n are time constructible,
including the functions n log n, n√n, n2, and 2n.
For example, to show that n√n is time constructible, we ﬁrst design a TM
to count the number of 1s in binary. To do so, the TM moves a binary counter
along the tape, incrementing it by 1 for every input position, until it reaches
the end of the input. This part uses O(n log n) steps because O(log n) steps are
used for each of the n input positions. Then, we compute ⌊n√n⌋in binary from
the binary representation of n. Any reasonable method of doing so will work in
O(n log n) time because the length of the numbers involved is O(log n).
The time hierarchy theorem is an analog for time complexity to Theorem 9.3.
For technical reasons that will appear in its proof, the time hierarchy theorem
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

9.1
HIERARCHY THEOREMS
369
is slightly weaker than the one we proved for space. Whereas any space con-
structible asymptotic increase in the space bound enlarges the class of languages
decidable therein, for time we must further increase the time bound by a log-
arithmic factor in order to guarantee that we can obtain additional languages.
Conceivably, a tighter time hierarchy theorem is true; but at present, we don’t
know how to prove it. This aspect of the time hierarchy theorem arises because
we measure time complexity with single-tape Turing machines. We can prove
tighter time hierarchy theorems for other models of computation.
THEOREM
9.10
Time hierarchy theorem
For any time constructible function t: N −→N,
a language A exists that is decidable in O(t(n)) time but not decidable in time
o(t(n)/ log t(n)).
PROOF IDEA
This proof is similar to the proof of Theorem 9.3. We con-
struct a TM D that decides a language A in time O(t(n)), whereby A cannot be
decided in o(t(n)/ log t(n)) time. Here, D takes an input w of the form ⟨M⟩10∗
and simulates M on input w, making sure not to use more than t(n) time. If M
halts within that much time, D gives the opposite output.
The important difference in the proof concerns the cost of simulating M
while, at the same time, counting the number of steps that the simulation is us-
ing. Machine D must perform this timed simulation efﬁciently so that D runs
in O(t(n)) time while accomplishing the goal of avoiding all languages decid-
able in o(t(n)/ log t(n)) time. For space complexity, the simulation introduced
a constant factor overhead, as we observed in the proof of Theorem 9.3. For
time complexity, the simulation introduces a logarithmic factor overhead. The
larger overhead for time is the reason for the appearance of the 1/ log t(n) factor
in the statement of this theorem. If we had a way of simulating a single-tape
TM by another single-tape TM for a prespeciﬁed number of steps, using only a
constant factor overhead in time, we would be able to strengthen this theorem
by changing o(t(n)/ log t(n)) to o(t(n)). No such efﬁcient simulation is known.
PROOF
The following O(t(n)) time algorithm D decides a language A that
is not decidable in o(t(n)/ log t(n)) time.
D = “On input w:
1.
Let n be the length of w.
2.
Compute t(n) using time constructibility and store the value
⌈t(n)/ log t(n)⌉in a binary counter. Decrement this counter
before each step used to carry out stages 4 and 5. If the counter
ever hits 0, reject.
3.
If w is not of the form ⟨M⟩10∗for some TM M, reject.
4.
Simulate M on w.
5.
If M accepts, then reject. If M rejects, then accept.”
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

370
CHAPTER 9 / INTRACTABILITY
We examine each of the stages of this algorithm to determine the running
time. Stages 1, 2, and 3 can be performed within O(t(n)) time.
In stage 4, every time D simulates one step of M, it takes M’s current state
together with the tape symbol under M’s tape head and looks up M’s next action
in its transition function so that it can update M’s tape appropriately. All three
of these objects (state, tape symbol, and transition function) are stored on D’s
tape somewhere. If they are stored far from each other, D will need many steps
to gather this information each time it simulates one of M’s steps. Instead, D
always keeps this information close together.
We can think of D’s single tape as organized into tracks. One way to get two
tracks is by storing one track in the odd positions and the other in the even posi-
tions. Alternatively, the two-track effect may be obtained by enlarging D’s tape
alphabet to include each pair of symbols: one from the top track and the second
from the bottom track. We can get the effect of additional tracks similarly. Note
that multiple tracks introduce only a constant factor overhead in time, provided
that only a ﬁxed number of tracks are used. Here, D has three tracks.
One of the tracks contains the information on M’s tape, and a second contains
its current state and a copy of M’s transition function. During the simulation,
D keeps the information on the second track near the current position of M’s
head on the ﬁrst track. Every time M’s head position moves, D shifts all the
information on the second track to keep it near the head. Because the size of the
information on the second track depends only on M and not on the length of
the input to M, the shifting adds only a constant factor to the simulation time.
Furthermore, because the required information is kept close together, the cost
of looking up M’s next action in its transition function and updating its tape is
only a constant. Hence if M runs in g(n) time, D can simulate it in O(g(n))
time.
At every step in stage 4, D must decrement the step counter it originally set in
stage 2. Here, D can do so without adding excessively to the simulation time by
keeping the counter in binary on a third track and moving it to keep it near the
present head position. This counter has a magnitude of about t(n)/ log t(n), so
its length is log(t(n)/ log t(n)), which is O(log t(n)). Hence the cost of updating
and moving it at each step adds a log t(n) factor to the simulation time, thus
bringing the total running time to O(t(n)). Therefore, A is decidable in time
O(t(n)).
To show that A is not decidable in o(t(n)/ log t(n)) time, we use an argument
similar to one used in the proof of Theorem 9.3. Assume to the contrary that
TM M decides A in time g(n), where g(n) is o(t(n)/ log t(n)). Here, D can sim-
ulate M, using time d g(n) for some constant d. If the total simulation time (not
counting the time to update the step counter) is at most t(n)/ log t(n), the sim-
ulation will run to completion. Because g(n) is o(t(n)/ log t(n)), some constant
n0 exists where d g(n) < t(n)/ log t(n) for all n ≥n0. Therefore, D’s simula-
tion of M will run to completion as long as the input has length n0 or more.
Consider what happens when we run D on input ⟨M⟩10n0. This input is longer
than n0, so the simulation in stage 4 will complete. Therefore, D will do the
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

9.1
HIERARCHY THEOREMS
371
opposite of M on the same input. Hence M doesn’t decide A, which contradicts
our assumption. Therefore, A is not decidable in o(t(n)/ log t(n)) time.
We establish analogs to Corollaries 9.4, 9.5, and 9.7 for time complexity.
COROLLARY
9.11
For any two functions t1, t2 : N −→N, where t1(n) is o(t2(n)/ log t2(n)) and
t2 is time constructible, TIME(t1(n)) ⊊TIME(t2(n)).
COROLLARY
9.12
For any two real numbers 1 ≤ϵ1 < ϵ2, we have TIME(nϵ1) ⊊TIME(nϵ2).
COROLLARY
9.13
P ⊊EXPTIME.
EXPONENTIAL SPACE COMPLETENESS
We can use the preceding results to demonstrate that a speciﬁc language is ac-
tually intractable. We do so in two steps. First, the hierarchy theorems tell us
that a Turing machine can decide more languages in EXPSPACE than it can
in PSPACE. Then, we show that a particular language concerning generalized
regular expressions is complete for EXPSPACE and hence can’t be decided in
polynomial time or even in polynomial space.
Before getting to their generalization, let’s brieﬂy review the way we intro-
duced regular expressions in Deﬁnition 1.52. They are built up from the atomic
expressions ∅, ε, and members of the alphabet, by using the regular operations
union, concatenation, and star, denoted ∪, ◦, and ∗, respectively. From Prob-
lem 8.8, we know that we can test the equivalence of two regular expressions in
polynomial space.
We show that by allowing regular expressions with more operations than the
usual regular operations, the complexity of analyzing the expressions may grow
dramatically. Let ↑be the exponentiation operation. If R is a regular expression
and k is a nonnegative integer, writing R ↑k is equivalent to the concatenation
of R with itself k times. We also write Rk as shorthand for R ↑k. In other
words,
Rk = R ↑k =
k
z
}|
{
R ◦R ◦· · · ◦R .
Generalized regular expressions allow the exponentiation operation in addition
to the usual regular operations. Obviously, these generalized regular expressions
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

372
CHAPTER 9 / INTRACTABILITY
still generate the same class of regular languages as do the standard regular ex-
pressions because we can eliminate the exponentiation operation by repeating
the base expression. Let
EQREX↑= {⟨Q, R⟩| Q and R are equivalent regular
expressions with exponentiation}.
To show that EQREX↑is intractable, we demonstrate that it is complete for the
class EXPSPACE. Any EXPSPACE-complete problem cannot be in PSPACE,
much less in P. Otherwise, EXPSPACE would equal PSPACE, contradicting
Corollary 9.7.
DEFINITION
9.14
A language B is EXPSPACE-complete if
1. B ∈EXPSPACE, and
2. every A in EXPSPACE is polynomial time reducible to B.
THEOREM
9.15
EQREX↑is EXPSPACE-complete.
PROOF IDEA
In measuring the complexity of deciding EQREX↑, we assume
that all exponents are written as binary integers. The length of an expression is
the total number of symbols that it contains.
We sketch an EXPSPACE algorithm for EQREX↑. To test whether two ex-
pressions with exponentiation are equivalent, we ﬁrst use repetition to eliminate
exponentiation, then convert the resulting expressions to NFAs. Finally, we use
an NFA equivalence testing procedure similar to the one used for deciding the
complement of ALLNFA in Example 8.4.
To show that a language A in EXPSPACE is polynomial time reducible to
EQREX↑, we utilize the technique of reductions via computation histories that
we introduced in Section 5.1. The construction is similar to the construction
given in the proof of Theorem 5.13.
Given a TM M for A, we design a polynomial time reduction mapping an in-
put w to a pair of expressions, R1 and R2, that are equivalent exactly when M
accepts w. The expressions R1 and R2 simulate the computation of M on w. Ex-
pression R1 simply generates all strings over the alphabet consisting of symbols
that may appear in computation histories. Expression R2 generates all strings
that are not rejecting computation histories. So if the TM accepts its input, no
rejecting computation histories exist, and expressions R1 and R2 generate the
same language. Recall that a rejecting computation history is the sequence of
conﬁgurations that the machine enters in a rejecting computation on the input.
See page 220 in Section 5.1 for a review of computation histories.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

9.1
HIERARCHY THEOREMS
373
The difﬁculty in this proof is that the size of the expressions constructed must
be polynomial in n (so that the reduction can run in polynomial time), whereas
the simulated computation may have exponential length. The exponentiation
operation is useful here to represent the long computation with a relatively short
expression.
PROOF
First, we present a nondeterministic algorithm for testing whether
two NFAs are inequivalent.
N = “On input ⟨N1, N2⟩, where N1 and N2 are NFAs:
1.
Place a marker on each of the start states of N1 and N2.
2.
Repeat 2q1+q2 times, where q1 and q2 are the numbers of states
in N1 and N2:
3.
Nondeterministically select an input symbol and change the
positions of the markers on the states of N1 and N2 to simu-
late reading that symbol.
4.
If at any point a marker was placed on an accept state of one
of the ﬁnite automata and not on any accept state of the other
ﬁnite automaton, accept. Otherwise, reject.”
If automata N1 and N2 are equivalent, N clearly rejects because it only ac-
cepts when it determines that one machine accepts a string that the other does
not accept. If the automata are not equivalent, some string is accepted by one
machine and not by the other. Some such string must be of length at most 2q1+q2.
Otherwise, consider using the shortest such string as the sequence of nondeter-
ministic choices. Only 2q1+q2 different ways exist to place markers on the states
of N1 and N2; so in a longer string, the positions of the markers would repeat.
By removing the portion of the string between the repetitions, a shorter such
string would be obtained. Hence algorithm N would guess this string among its
nondeterministic choices and would accept. Thus, N operates correctly.
Algorithm N runs in nondeterministic linear space. Thus, Savitch’s theorem
provides a deterministic O(n2) space algorithm for this problem. Next, we use
the deterministic form of this algorithm to design the following algorithm E
that decides EQREX↑.
E = “On input ⟨R1, R2⟩, where R1 and R2 are regular expressions with
exponentiation:
1.
Convert R1 and R2 to equivalent regular expressions B1 and B2
that use repetition instead of exponentiation.
2.
Convert B1 and B2 to equivalent NFAs N1 and N2, using the
conversion procedure given in the proof of Lemma 1.55.
3.
Use the deterministic version of algorithm N to determine
whether N1 and N2 are equivalent.”
Algorithm E obviously is correct. To analyze its space complexity, we ob-
serve that using repetition to replace exponentiation may increase the length
of an expression by a factor of 2l, where l is the sum of the lengths of the ex-
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

374
CHAPTER 9 / INTRACTABILITY
ponents. Thus, expressions B1 and B2 have a length of at most n2n, where
n is the input length. The conversion procedure of Lemma 1.55 increases the
size linearly, and hence NFAs N1 and N2 have at most O(n2n) states. Thus,
with input size O(n2n), the deterministic version of algorithm N uses space
O((n2n)2) = O(n222n). Hence EQREX↑is decidable in exponential space.
Next, we show that EQREX↑is EXPSPACE-hard. Let A be a language that
is decided by TM M running in space 2(nk) for some constant k. The reduction
maps an input w to a pair of regular expressions, R1 and R2. Expression R1 is ∆∗
where if Γ and Q are M’s tape alphabet and states, ∆= Γ∪Q∪{#} is the alphabet
consisting of all symbols that may appear in a computation history. We construct
expression R2 to generate all strings that aren’t rejecting computation histories
of M on w. Of course, M accepts w iff M on w has no rejecting computation
histories. Therefore, the two expressions are equivalent iff M accepts w. The
construction is as follows.
A rejecting computation history for M on w is a sequence of conﬁgura-
tions separated by # symbols. We use our standard encoding of conﬁgurations
whereby a symbol corresponding to the current state is placed to the left of the
current head position. We assume that all conﬁgurations have length 2(nk) and
are padded on the right by blank symbols if they otherwise would be too short.
The ﬁrst conﬁguration in a rejecting computation history is the start conﬁgu-
ration of M on w. The last conﬁguration is a rejecting conﬁguration. Each
conﬁguration must follow from the preceding one according to the rules speci-
ﬁed in the transition function.
A string may fail to be a rejecting computation in several ways: It may fail
to start or end properly, or it may be incorrect somewhere in the middle. Ex-
pression R2 equals Rbad-start ∪Rbad-window ∪Rbad-reject, where each subexpression
corresponds to one of the three ways a string may fail.
We construct expression Rbad-start to generate all strings that fail to start with
the start conﬁguration C1 of M on w, as follows. Conﬁguration C1 looks like
q0w1w2 · · · wn␣␣· · · ␣#. We write Rbad-start as the union of several subexpres-
sions to handle each part of C1:
Rbad-start = S0 ∪S1 ∪· · · ∪Sn ∪Sb ∪S#.
Expression S0 generates all strings that don’t start with q0. We let S0 be the
expression ∆−q0 ∆∗. The notation ∆−q0 is shorthand for writing the union of
all symbols in ∆except q0.
Expression S1 generates all strings that don’t contain w1 in the second po-
sition. We let S1 be ∆∆−w1 ∆∗. In general, for 1 ≤i ≤n, expression Si is
∆i ∆−wi ∆∗. Thus, Si generates all strings that contain any symbols in the ﬁrst
i positions, any symbol except wi in position i+1, and any string of symbols fol-
lowing position i+1. Note that we have used the exponentiation operation here.
Actually, at this point, exponentiation is more of a convenience than a necessity
because we could have instead repeated the symbol ∆i times without exces-
sively increasing the length of the expression. But in the next subexpression,
exponentiation is crucial to keeping the size polynomial.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

9.1
HIERARCHY THEOREMS
375
Expression Sb generates all strings that fail to contain a blank symbol in some
position n + 2 through 2(nk). We could introduce subexpressions Sn+2 through
S2(nk) for this purpose, but then expression Rbad-start would have exponential
length. Instead, we let
Sb = ∆n+1 (∆∪ε)2(nk)−n−2 ∆−␣∆∗.
Thus, Sb generates strings that contain any symbols in the ﬁrst n + 1 positions,
any symbols in the next t positions, where t can range from 0 to 2(nk) −n −2,
and any symbol except blank in the next position.
Finally, S# generates all strings that don’t have a # symbol in position 2(nk)+1.
Let S# be ∆(2(nk)) ∆−# ∆∗.
Now that we have completed the construction of Rbad-start, we turn to the
next piece, Rbad-reject. It generates all strings that don’t end properly; that is,
strings that fail to contain a rejecting conﬁguration. Any rejecting conﬁguration
contains the state qreject, so we let
Rbad-reject = ∆∗
−qreject.
Thus, Rbad-reject generates all strings that don’t contain qreject.
Finally, we construct Rbad-window, the expression that generates all strings
whereby one conﬁguration does not properly lead to the next conﬁguration.
Recall that in the proof of the Cook–Levin theorem, we determined that one
conﬁguration legally yields another whenever every three consecutive symbols
in the ﬁrst conﬁguration correctly yield the corresponding three symbols in the
second conﬁguration according to the transition function. Hence, if one conﬁg-
uration fails to yield another, the error will be apparent from an examination of
the appropriate six symbols. We use this idea to construct Rbad-window:
Rbad-window =
[
bad(abc,def )
∆∗abc ∆(2(nk)−2) def ∆∗,
where bad(abc, def ) means that abc doesn’t yield def according to the transition
function. The union is taken only over such symbols a, b, c, d, e, and f in ∆.
The following ﬁgure illustrates the placement of these symbols in a computation
history.
FIGURE
9.16
Corresponding places in adjacent conﬁgurations
To calculate the length of R2, we determine the length of the exponents that
appear in it. Several exponents of magnitude roughly 2(nk) appear, and their
total length in binary is O(nk). Therefore, the length of R2 is polynomial in n.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

376
CHAPTER 9 / INTRACTABILITY
9.2
RELATIVIZATION
The proof that EQREX↑is intractable rests on the diagonalization method. Why
don’t we show that SAT is intractable in the same way? Possibly we could use
diagonalization to show that a nondeterministic polynomial time TM can decide
a language that is provably not in P. In this section, we introduce the method
of relativization to give strong evidence against the possibility of solving the P
versus NP question by using a proof by diagonalization.
In the relativization method, we modify our model of computation by giv-
ing the Turing machine certain information essentially for “free.” Depending
on which information is actually provided, the TM may be able to solve some
problems more easily than before.
For example, suppose that we grant the TM the ability to solve the satisﬁability
problem in a single step, for any size Boolean formula. Never mind how this feat
is accomplished—imagine an attached “black box” that gives the machine this
capability. We call the black box an oracle to emphasize that it doesn’t necessarily
correspond to any physical device. Obviously, the machine could use the oracle
to solve any NP problem in polynomial time, regardless of whether P equals
NP, because every NP problem is polynomial time reducible to the satisﬁability
problem. Such a TM is said to be computing relative to the satisﬁability problem;
hence the term relativization.
In general, an oracle can correspond to any particular language, not just the
satisﬁability problem. The oracle allows the TM to test membership in the lan-
guage without actually having to compute the answer itself. We formalize this
notion shortly. You may recall that we introduced oracles in Section 6.3. There,
we deﬁned them for the purpose of classifying problems according to the de-
gree of unsolvability. Here, we use oracles to understand better the power of the
diagonalization method.
DEFINITION
9.17
An oracle for a language A is a device that is capable of reporting
whether any string w is a member of A. An oracle Turing machine
M A is a modiﬁed Turing machine that has the additional capability
of querying an oracle for A. Whenever M A writes a string on a
special oracle tape, it is informed whether that string is a member
of A in a single computation step.
Let PA be the class of languages decidable with a polynomial
time oracle Turing machine that uses oracle A. Deﬁne the class
NPA similarly.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

9.2
RELATIVIZATION
377
EXAMPLE
9.18
As we mentioned earlier, polynomial time computation relative to the satisﬁa-
bility problem contains all of NP. In other words, NP ⊆PSAT. Furthermore,
coNP ⊆PSAT because PSAT, being a deterministic complexity class, is closed
under complementation.
EXAMPLE
9.19
Just as PSAT contains languages that we believe are not in P, the class NPSAT
contains languages that we believe are not in NP. The complement of the lan-
guage MIN-FORMULA that we deﬁned in Problem 7.46 on page 328 provides
one such example.
MIN-FORMULA doesn’t seem to be in NP (though whether it actually be-
longs to NP is not known). However, MIN-FORMULA is in NPSAT because a
nondeterministic polynomial time oracle Turing machine with a SAT oracle can
test whether φ is a member, as follows. First, the inequivalence problem for two
Boolean formulas is solvable in NP, and hence the equivalence problem is in
coNP because a nondeterministic machine can guess the assignment on which
the two formulas have different values. Then, the nondeterministic oracle ma-
chine for MIN-FORMULA nondeterministically guesses the smaller equivalent
formula, tests whether it actually is equivalent, using the SAT oracle, and accepts
if it is.
LIMITS OF THE DIAGONALIZATION METHOD
The next theorem demonstrates oracles A and B for which PA and NPA are
provably different, and PB and NPB are provably equal. These two oracles are
important because their existence indicates that we are unlikely to resolve the P
versus NP question by using the diagonalization method.
At its core, the diagonalization method is a simulation of one Turing machine
by another. The simulation is done so that the simulating machine can deter-
mine the behavior of the other machine and then behave differently. Suppose
that both of these Turing machines were given identical oracles. Then, whenever
the simulated machine queries the oracle, so can the simulator; and therefore,
the simulation can proceed as before. Consequently, any theorem proved about
Turing machines by using only the diagonalization method would still hold if
both machines were given the same oracle.
In particular, if we could prove that P and NP were different by diagonaliz-
ing, we could conclude that they are different relative to any oracle as well. But
PB and NPB are equal, so that conclusion is false. Hence diagonalization isn’t
sufﬁcient to separate these two classes. Similarly, no proof that relies on a sim-
ple simulation could show that the two classes are the same because that would
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

378
CHAPTER 9 / INTRACTABILITY
show that they are the same relative to any oracle; but in fact, PA and NPA are
different.
THEOREM
9.20
1. An oracle A exists whereby PA ̸= NPA.
2. An oracle B exists whereby PB = NPB.
PROOF IDEA
Exhibiting oracle B is easy. Let B be any PSPACE-complete
problem such as TQBF.
We exhibit oracle A by construction. We design A so that a certain language
LA in NPA provably requires brute-force search, and so LA cannot be in PA.
Hence we can conclude that PA ̸= NPA. The construction considers every
polynomial time oracle machine in turn and ensures that each fails to decide the
language LA.
PROOF
Let B be TQBF. We have the series of containments
NPTQBF 1
⊆NPSPACE
2
⊆PSPACE
3
⊆PTQBF.
Containment 1 holds because we can convert the nondeterministic polynomial
time oracle TM to a nondeterministic polynomial space machine that computes
the answers to queries regarding TQBF instead of using the oracle. Contain-
ment 2 follows from Savitch’s theorem. Containment 3 holds because TQBF is
PSPACE-complete. Hence we conclude that PTQBF = NPTQBF.
Next, we show how to construct oracle A. For any oracle A, let LA be the
collection of all strings for which a string of equal length appears in A. Thus,
LA = {w| ∃x∈A [ |x|=|w| ]}.
Obviously, for any A, the language LA is in NPA.
To show LA is not in PA, we design A as follows. Let M1, M2, . . . be a list of
all polynomial time oracle TMs. We may assume for simplicity that Mi runs in
time ni. The construction proceeds in stages, where stage i constructs a part of
A, which ensures that M A
i doesn’t decide LA. We construct A by declaring that
certain strings are in A and others aren’t in A. Each stage determines the status
of only a ﬁnite number of strings. Initially, we have no information about A. We
begin with stage 1.
Stage i.
So far, a ﬁnite number of strings have been declared to be in or out
of A. We choose n greater than the length of any such string and large enough
that 2n is greater than ni, the running time of Mi. We show how to extend our
information about A so that M A
i accepts 1n whenever that string is not in LA.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

9.3
CIRCUIT COMPLEXITY
379
We run Mi on input 1n and respond to its oracle queries as follows. If Mi
queries a string y whose status has already been determined, we respond consis-
tently. If y’s status is undetermined, we respond NO to the query and declare y
to be out of A. We continue the simulation of Mi until it halts.
Now consider the situation from Mi’s perspective.
If it ﬁnds a string of
length n in A, it should accept because it knows that 1n is in LA. If Mi de-
termines that all strings of length n aren’t in A, it should reject because it knows
that 1n is not in LA. However, it doesn’t have enough time to ask about all
strings of length n, and we have answered NO to each of the queries it has made.
Hence when Mi halts and must decide whether to accept or reject, it doesn’t
have enough information to be sure that its decision is correct.
Our objective is to ensure that its decision is not correct. We do so by observ-
ing its decision and then extending A so that the reverse is true. Speciﬁcally, if
Mi accepts 1n, we declare all the remaining strings of length n to be out of A
and so determine that 1n is not in LA. If Mi rejects 1n, we ﬁnd a string of length
n that Mi hasn’t queried and declare that string to be in A to guarantee that 1n
is in LA. Such a string must exist because Mi runs for ni steps, which is fewer
than 2n, the total number of strings of length n. Either way, we have ensured
that M A
i doesn’t decide LA.
We ﬁnish stage i by arbitrarily declaring that any string of length at most n,
whose status remains undetermined at this point, is out of A. Stage i is com-
pleted and we proceed with stage i + 1.
We have shown that no polynomial time oracle TM decides LA with oracle A,
thereby proving the theorem.
In summary, the relativization method tells us that to solve the P versus NP
question, we must analyze computations, not just simulate them. In Section 9.3,
we introduce one approach that may lead to such an analysis.
9.3
CIRCUIT COMPLEXITY
Computers are built from electronic devices wired together in a design called a
digital circuit. We can also simulate theoretical models, such as Turing machines,
with the theoretical counterpart to digital circuits, called Boolean circuits. Two
purposes are served by establishing the connection between TMs and Boolean
circuits. First, researchers believe that circuits provide a convenient compu-
tational model for attacking the P versus NP and related questions. Second,
circuits provide an alternative proof of the Cook–Levin theorem that SAT is
NP-complete. We cover both topics in this section.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

380
CHAPTER 9 / INTRACTABILITY
DEFINITION
9.21
A Boolean circuit is a collection of gates and inputs connected by
wires. Cycles aren’t permitted. Gates take three forms: AND gates,
OR gates, and NOT gates, as shown schematically in the following
ﬁgure.
FIGURE
9.22
An AND gate, an OR gate, and a NOT gate
The wires in a Boolean circuit carry the Boolean values 0 and 1. The gates are
simple processors that compute the Boolean functions AND, OR, and NOT. The
AND function outputs 1 if both of its inputs are 1 and outputs 0 otherwise. The
OR function outputs 0 if both of its inputs are 0 and outputs 1 otherwise. The
NOT function outputs the opposite of its input; in other words, it outputs a 1 if
its input is 0 and a 0 if its input is 1. The inputs are labeled x1, . . . , xn. One of
the gates is designated the output gate. The following ﬁgure depicts a Boolean
circuit.
FIGURE
9.23
An example of a Boolean circuit
A Boolean circuit computes an output value from a setting of the inputs by
propagating values along the wires and computing the function associated with
the respective gates until the output gate is assigned a value. The following
ﬁgure shows a Boolean circuit computing a value from a setting of its inputs.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

9.3
CIRCUIT COMPLEXITY
381
FIGURE
9.24
An example of a Boolean circuit computing
We use functions to describe the input/output behavior of Boolean cir-
cuits. To a Boolean circuit C with n input variables, we associate a function
fC : {0,1}n−→{0,1}, where if C outputs b when its inputs x1, . . . , xn are set to
a1, . . . , an, we write fC(a1, . . . , an) = b. We say that C computes the function
fC. We sometimes consider Boolean circuits that have multiple output gates. A
function with k output bits computes a function whose range is {0,1}k.
EXAMPLE
9.25
The n-input parity function parityn : {0,1}n−→{0,1} outputs 1 if an odd num-
ber of 1s appear in the input variables. The circuit in Figure 9.26 computes
parity4, the parity function on 4 variables.
FIGURE
9.26
A Boolean circuit that computes the parity function on 4 variables
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

382
CHAPTER 9 / INTRACTABILITY
We plan to use circuits to test membership in languages once they have been
suitably encoded into {0,1}. One problem that occurs is that any particular
circuit can handle only inputs of some ﬁxed length, whereas a language may
contain strings of different lengths. So instead of using a single circuit to test
language membership, we use an entire family of circuits, one for each input
length, to perform this task. We formalize this notion in the following deﬁnition.
DEFINITION
9.27
A circuit family C is an inﬁnite list of circuits, (C0, C1, C2, . . .),
where Cn has n input variables. We say that C decides a language
A over {0,1} if for every string w,
w ∈A
iff
Cn(w) = 1,
where n is the length of w.
The size of a circuit is the number of gates that it contains. Two circuits
are equivalent if they have the same input variables and output the same value
on every input assignment. A circuit is size minimal if no smaller circuit is
equivalent to it. The problem of minimizing circuits has obvious engineering
applications but is very difﬁcult to solve in general. Even the problem of testing
whether a particular circuit is minimal does not appear to be solvable in P or in
NP. A circuit family is minimal if every Ci on the list is a minimal circuit. The
size complexity of a circuit family (C0, C1, C2, . . .) is the function f : N −→N,
where f(n) is the size of Cn. We may simply refer to the complexity of a circuit
family, instead of the size complexity, when it is clear that we are speaking about
size.
The depth of a circuit is the length (number of wires) of the longest path
from an input variable to the output gate. We deﬁne depth minimal circuits
and circuit families, and the depth complexity of circuit families, as we did with
circuit size. Circuit depth complexity is of particular interest in Section 10.5
concerning parallel computation.
DEFINITION
9.28
The circuit complexity of a language is the size complexity of a min-
imal circuit family for that language. The circuit depth complexity
of a language is deﬁned similarly, using depth instead of size.
EXAMPLE
9.29
We can easily generalize Example 9.25 to give circuits that compute the parity
function on n variables with O(n) gates. One way to do so is to build a binary
tree of gates that compute the XOR function, where the XOR function is the
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

9.3
CIRCUIT COMPLEXITY
383
same as the parity2 function, and then implement each XOR gate with two NOTs,
two ANDs, and one OR, as we did in that earlier example.
Let A be the language of strings that contain an odd number of 1s. Then A
has circuit complexity O(n).
The circuit complexity of a language is related to its time complexity. Any
language with small time complexity also has small circuit complexity, as the
following theorem shows.
THEOREM
9.30
Let t: N −→N be a function, where t(n) ≥n. If A ∈TIME(t(n)), then A has
circuit complexity O(t2(n)).
This theorem gives an approach to proving that P ̸= NP whereby we attempt
to show that some language in NP has more than polynomial circuit complexity.
PROOF IDEA
Let M be a TM that decides A in time t(n). (For simplicity, we
ignore the constant factor in O(t(n)), the actual running time of M.) For each
n, we construct a circuit Cn that simulates M on inputs of length n. The gates
of Cn are organized in rows, one for each of the t(n) steps in M’s computation
on an input of length n. Each row of gates represents the conﬁguration of M at
the corresponding step. Each row is wired into the previous row so that it can
calculate its conﬁguration from the previous row’s conﬁguration. We modify M
so that the input is encoded into {0,1}. Moreover, when M is about to accept,
it moves its head onto the leftmost tape cell and writes the ␣symbol on that cell
prior to entering the accept state. That way, we can designate a gate in the ﬁnal
row of the circuit to be the output gate.
PROOF
Let M = (Q, Σ, Γ, δ, q0, qaccept, qreject) decide A in time t(n), and let
w be an input of length n to M. Deﬁne a tableau for M on w to be a t(n) × t(n)
table whose rows are conﬁgurations of M. The top row of the tableau contains
the start conﬁguration of M on w. The ith row contains the conﬁguration at the
ith step of the computation.
For convenience, we modify the representation format for conﬁgurations in
this proof. Instead of the old format, described on page 168, where the state
appears to the left of the symbol that the head is reading, we represent both the
state and the tape symbol under the tape head by a single composite character.
For example, if M is in state q and its tape contains the string 1011 with the head
reading the second symbol from the left, the old format would be 1q011 and the
new format would be 1q011—where the composite character q0 represents both
q, the state, and 0, the symbol under the head.
Each entry of the tableau can contain a tape symbol (member of Γ) or a com-
bination of a state and a tape symbol (member of Q × Γ). The entry at the ith
row and jth column of the tableau is cell[i,j]. The top row of the tableau then
is cell[1, 1], . . . , cell[1, t(n)] and contains the starting conﬁguration.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

384
CHAPTER 9 / INTRACTABILITY
We make two assumptions about TM M in deﬁning the notion of a tableau.
First, as we mentioned in the proof idea, M accepts only when its head is on
the leftmost tape cell and that cell contains the ␣symbol. Second, once M has
halted, it stays in the same conﬁguration for all future time steps. So by looking
at the leftmost cell in the ﬁnal row of the tableau, cell[t(n), 1], we can determine
whether M has accepted. The following ﬁgure shows part of a tableau for M on
the input 0010.
 
 
FIGURE
9.31
A tableau for M on input 0010
The content of each cell is determined by certain cells in the preceding row.
If we know the values at cell[i −1, j −1], cell[i −1, j], and cell[i −1, j + 1], we
can obtain the value at cell[i, j] with M’s transition function. For example, the
following ﬁgure magniﬁes a portion of the tableau in Figure 9.31. The three top
symbols, 0, 0, and 1, are tape symbols without states, so the middle symbol must
remain a 0 in the next row, as shown.
Now we can begin to construct the circuit Cn. It has several gates for each
cell in the tableau. These gates compute the value at a cell from the values of the
three cells that affect it.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

9.3
CIRCUIT COMPLEXITY
385
To make the construction easier to describe, we add lights that show the out-
put of some of the gates in the circuit. The lights are for illustrative purposes
only and don’t affect the operation of the circuit.
Let k be the number of elements in Γ ∪(Q × Γ). We create k lights for
each cell in the tableau—one light for each member of Γ, and one light for each
member of (Q × Γ)—or a total of kt2(n) lights. We call these lights light[i, j, s],
where 1 ≤i, j ≤t(n) and s ∈Γ ∪(Q × Γ). The condition of the lights in a
cell indicates the contents of that cell. If light[i, j, s] is on, cell[i, j] contains the
symbol s. Of course, if the circuit is constructed properly, only one light would
be on per cell.
Let’s pick one of the lights—say, light[i, j, s] in cell[i, j]. This light should be
on if that cell contains the symbol s. We consider the three cells that can affect
cell[i, j] and determine which of their settings cause cell[i, j] to contain s. This
determination can be made by examining the transition function δ.
Suppose that if the cells cell[i −1, j −1], cell[i −1, j], and cell[i −1, j + 1]
contain a, b, and c, respectively, cell[i, j] contains s, according to δ. We wire the
circuit so that if light[i −1, j −1, a], light[i −1, j, b], and light[i −1, j + 1, c]
are on, then so is light[i, j, s]. We do so by connecting the three lights at the
i −1 level to an AND gate whose output is connected to light[i, j, s].
In general, several different settings (a1, b1, c1), (a2, b2, c2), . . . , (al, bl, cl) of
cell[i −1, j −1], cell[i −1, j], and cell[i −1, j + 1] may cause cell[i, j] to contain
s. In this case, we wire the circuit so that for each setting ai, bi, ci, the respective
lights are connected with an AND gate, and all the AND gates are connected with
an OR gate. This circuitry is illustrated in the following ﬁgure.
FIGURE
9.32
Circuitry for one light
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

386
CHAPTER 9 / INTRACTABILITY
The circuitry just described is repeated for each light, with a few exceptions
at the boundaries. Each cell at the left boundary of the tableau—that is, cell[i, 1]
for 1 ≤i ≤t(n)—has only two preceding cells that affect its contents. The
cells at the right boundary are similar. In these cases, we modify the circuitry to
simulate the behavior of TM M in this situation.
The cells in the ﬁrst row have no predecessors and are handled in a special
way. These cells contain the start conﬁguration and their lights are wired to
the input variables. Thus, light[1, 1, q01 ] is connected to input w1 because the
start conﬁguration begins with the start state symbol q0 and the head starts over
w1. Similarly, light[1, 1, q00 ] is connected through a NOT gate to input w1.
Furthermore, light[1, 2, 1], . . . , light[1, n, 1] are connected to inputs w2, . . . , wn,
and light[1, 2, 0], . . . , light[1, n, 0] are connected through NOT gates to inputs
w2, . . . , wn because the input string w determines these values. Additionally,
light[1, n + 1, ␣], . . . , light[1, t(n), ␣] are on because the remaining cells in the
ﬁrst row correspond to positions on the tape that initially are blank (␣). Finally,
all other lights in the ﬁrst row are off.
So far, we have constructed a circuit that simulates M through its t(n)th step.
All that remains to be done is to assign one of the gates to be the output gate of
the circuit. We know that M accepts w if it is in an accept state qaccept on a cell
containing ␣at the left-hand end of the tape at step t(n). So we designate the
output gate to be the one attached to light[t(n), 1, qaccept␣]. This completes the
proof of the theorem.
Besides linking circuit complexity and time complexity, Theorem 9.30 yields
an alternative proof of Theorem 7.27, the Cook–Levin theorem, as follows. We
say that a Boolean circuit is satisﬁable if some setting of the inputs causes the
circuit to output 1. The circuit-satisﬁability problem tests whether a circuit is
satisﬁable. Let
CIRCUIT-SAT = {⟨C⟩| C is a satisﬁable Boolean circuit}.
Theorem 9.30 shows that Boolean circuits are capable of simulating Turing ma-
chines. We use that result to show that CIRCUIT-SAT is NP-complete.
THEOREM
9.33
CIRCUIT-SAT is NP-complete.
PROOF
To prove this theorem, we must show that CIRCUIT-SAT is in NP,
and that any language A in NP is reducible to CIRCUIT-SAT. The ﬁrst is obvi-
ous. To do the second, we must give a polynomial time reduction f that maps
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

9.3
CIRCUIT COMPLEXITY
387
strings to circuits, where
f(w) = ⟨C⟩
implies that
w ∈A ⇐⇒Boolean circuit C is satisﬁable.
Because A is in NP, it has a polynomial time veriﬁer V whose input has the
form ⟨x, c⟩, where c may be the certiﬁcate showing that x is in A. To construct
f, we obtain the circuit simulating V using the method in Theorem 9.30. We
ﬁll in the inputs to the circuit that correspond to x with the symbols of w. The
only remaining inputs to the circuit correspond to the certiﬁcate c. We call this
circuit C and output it.
If C is satisﬁable, a certiﬁcate exists, so w is in A. Conversely, if w is in A, a
certiﬁcate exists, so C is satisﬁable.
To show that this reduction runs in polynomial time, we observe that in the
proof of Theorem 9.30, the construction of the circuit can be done in time that
is polynomial in n. The running time of the veriﬁer is nk for some k, so the size
of the circuit constructed is O(n2k). The structure of the circuit is quite simple
(actually, it is highly repetitious), so the running time of the reduction is O(n2k).
Now we show that 3SAT is NP-complete, completing the alternative proof
of the Cook–Levin theorem.
THEOREM
9.34
3SAT is NP-complete.
PROOF IDEA
3SAT is obviously in NP. We show that all languages in NP
reduce to 3SAT in polynomial time. We do so by reducing CIRCUIT-SAT to
3SAT in polynomial time. The reduction converts a circuit C to a formula φ,
whereby C is satisﬁable iff φ is satisﬁable. The formula contains one variable for
each variable and each gate in the circuit.
Conceptually, the formula simulates the circuit. A satisfying assignment for
φ contains a satisfying assignment to C. It also contains the values at each of
C’s gates in C’s computation on its satisfying assignment. In effect, φ’s satisfying
assignment “guesses” C’s entire computation on its satisfying assignment, and
φ’s clauses check the correctness of that computation. In addition, φ contains a
clause stipulating that C’s output is 1.
PROOF
We give a polynomial time reduction f from CIRCUIT-SAT to
3SAT. Let C be a circuit containing inputs x1, . . . , xl and gates g1, . . . , gm. The
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

388
CHAPTER 9 / INTRACTABILITY
reduction builds from C a formula φ with variables x1, . . . , xl, g1, . . . , gm. Each
of φ’s variables corresponds to a wire in C. The xi variables correspond to the
input wires, and the gi variables correspond to the wires at the gate outputs. We
relabel φ’s variables as w1, . . . , wl+m.
Now we describe φ’s clauses. We write φ’s clauses more intuitively using im-
plications. Recall that we can convert the implication operation (P →Q) to the
clause (P ∨Q). Each NOT gate in C with input wire wi and output wire wj is
equivalent to the expression
(wi →wj) ∧(wi →wj),
which in turn yields the two clauses
(wi ∨wj) ∧(wi ∨wj).
Observe that both clauses are satisﬁed iff an assignment is made to the variables
wi and wj corresponding to the correct functioning of the NOT gate.
Each AND gate in C with inputs wi and wj and output wk is equivalent to
((wi ∧wj) →wk) ∧((wi ∧wj) →wk) ∧((wi ∧wj) →wk) ∧((wi ∧wj) →wk),
which in turn yields the four clauses
(wi ∨wj ∨wk) ∧(wi ∨wj ∨wk) ∧(wi ∨wj ∨wk) ∧(wi ∨wj ∨wk).
Similarly, each OR gate in C with inputs wi and wj and output wk is equivalent
to
((wi ∧wj) →wk) ∧((wi ∧wj) →wk) ∧((wi ∧wj) →wk) ∧((wi ∧wj) →wk),
which in turn yields the four clauses
(wi ∨wj ∨wk) ∧(wi ∨wj ∨wk) ∧(wi ∨wj ∨wk) ∧(wi ∨wj ∨wk).
In each case, all four clauses are satisﬁed when an assignment is made to the
variables wi, wj, and wk, corresponding to the correct functioning of the gate.
Additionally, we add the clause (wm) to φ, where wm is C’s output gate.
Some of the clauses described contain fewer than three literals. We expand
such clauses to the desired size by repeating literals. For example, we expand
the clause (wm) to the equivalent clause (wm ∨wm ∨wm). That completes the
construction.
We brieﬂy argue that the construction works. If a satisfying assignment for
C exists, we obtain a satisfying assignment for φ by assigning the gi variables
according to C’s computation on this assignment. Conversely, if a satisfying as-
signment for φ exists, it gives an assignment for C because it describes C’s entire
computation where the output value is 1. The reduction can be done in poly-
nomial time because it is simple to compute and the output size is polynomial
(actually linear) in the size of the input.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

EXERCISES
389
EXERCISES
A9.1 Prove that TIME(2n) = TIME(2n+1).
A9.2 Prove that TIME(2n) ⊊TIME(22n).
A9.3 Prove that NTIME(n) ⊊PSPACE.
9.4 Show how the circuit depicted in Figure 9.26 computes on input 0110 by showing
the values computed by all of the gates, as we did in Figure 9.24.
9.5 Give a circuit that computes the parity function on three input variables and show
how it computes on input 011.
9.6 Prove that if A ∈P, then PA = P.
9.7 Give regular expressions with exponentiation that generate the following languages
over the alphabet {0,1}.
Aa. All strings of length 500
Ab. All strings of length 500 or less
Ac. All strings of length 500 or more
Ad. All strings of length different than 500
e. All strings that contain exactly 500 1s
f. All strings that contain at least 500 1s
g. All strings that contain at most 500 1s
h. All strings of length 500 or more that contain a 0 in the 500th position
i. All strings that contain two 0s that have at least 500 symbols between them
9.8 If R is a regular expression, let R{m,n} represent the expression
Rm ∪Rm+1 ∪· · · ∪Rn.
Show how to implement the R{m,n} operator, using the ordinary exponentiation
operator, but without “· · · ”.
9.9 Show that if NP = PSAT, then NP = coNP.
9.10 Problem 8.13 showed that ALBA is PSPACE-complete.
a. Do we know whether ALBA ∈NL? Explain your answer.
b. Do we know whether ALBA ∈P? Explain your answer.
9.11 Show that the language MAX-CLIQUE from Problem 7.48 is in PSAT.
PROBLEMS
9.12 Describe the error in the following fallacious “proof” that P ̸= NP. Assume that
P = NP and obtain a contradiction. If P = NP, then SAT ∈P and so for some k,
SAT ∈TIME(nk). Because every language in NP is polynomial time reducible
to SAT, you have NP ⊆TIME(nk). Therefore, P ⊆TIME(nk). But by the
time hierarchy theorem, TIME(nk+1) contains a language that isn’t in TIME(nk),
which contradicts P ⊆TIME(nk). Therefore, P ̸= NP.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

390
CHAPTER 9 / INTRACTABILITY
9.13 Consider the function pad : Σ∗× N −→Σ∗#∗that is deﬁned as follows.
Let
pad(s, l) = s#j, where j = max(0, l−m) and m is the length of s. Thus, pad(s, l)
simply adds enough copies of the new symbol # to the end of s so that the length
of the result is at least l. For any language A and function f : N −→N, deﬁne the
language pad(A, f) as
pad(A, f) = {pad(s, f(m))| where s ∈A and m is the length of s}.
Prove that if A ∈TIME(n6), then pad(A, n2) ∈TIME(n3).
9.14 Prove that if NEXPTIME ̸= EXPTIME, then P ̸= NP. You may ﬁnd the func-
tion pad, deﬁned in Problem 9.13, to be helpful.
A9.15 Deﬁne pad as in Problem 9.13.
a. Prove that for every A and natural number k, A ∈P iff pad(A, nk) ∈P.
b. Prove that P ̸= SPACE(n).
9.16 Prove that TQBF ̸∈SPACE(n1/3).
⋆9.17 Read the deﬁnition of a 2DFA (two-headed ﬁnite automaton) given in Prob-
lem 5.26. Prove that P contains a language that is not recognizable by a 2DFA.
9.18 Let EREX↑= {⟨R⟩| R is a regular expression with exponentiation and L(R) = ∅}.
Show that EREX↑∈P.
9.19 Deﬁne the unique-sat problem to be
USAT = {⟨φ⟩| φ is a Boolean formula that has a single satisfying assignment}.
Show that USAT ∈PSAT.
9.20 Prove that an oracle C exists for which NPC ̸= coNPC.
9.21 A k-query oracle Turing machine is an oracle Turing machine that is permitted to
make at most k queries on each input. A k-query oracle Turing machine M with
an oracle for A is written M A,k. Deﬁne PA,k to be the collection of languages that
are decidable by polynomial time k-query oracle Turing machines with an oracle
for A.
a. Show that NP ∪coNP ⊆PSAT,1.
b. Assume that NP ̸= coNP. Show that NP ∪coNP ⊊PSAT,1.
9.22 Suppose that A and B are two oracles. One of them is an oracle for TQBF, but you
don’t know which. Give an algorithm that has access to both A and B, and that is
guaranteed to solve TQBF in polynomial time.
9.23 Recall that you may consider circuits that output strings over {0,1} by designating
several output gates. Let add n : {0,1}2n−→{0,1}n+1 take two n bit binary inte-
gers and produce the n+ 1 bit sum. Show that you can compute the add n function
with O(n) size circuits.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

SELECTED SOLUTIONS
391
9.24 Deﬁne the function majorityn : {0,1}n−→{0,1} as
majorityn(x1, . . . , xn) =
(
0
P xi < n/2 ;
1
P xi ≥n/2 .
Thus, the majorityn function returns the majority vote of the inputs. Show that
majorityn can be computed with:
a. O(n2) size circuits.
b. O(n log n) size circuits. (Hint: Recursively divide the number of inputs in
half and use the result of Problem 9.23.)
⋆9.25 Deﬁne the function majorityn as in Problem 9.24. Show that it may be computed
with O(n) size circuits.
SELECTED SOLUTIONS
9.1
The time complexity classes are deﬁned in terms of the big-O notation, so constant
factors have no effect. The function 2n+1 is O(2n) and thus A ∈TIME(2n) iff
A ∈TIME(2n+1).
9.2
The containment TIME(2n) ⊆TIME(22n) holds because 2n ≤22n. The con-
tainment is proper by virtue of the time hierarchy theorem. The function 22n
is time constructible because a TM can write the number 1 followed by 2n 0s in
O(22n) time. Hence the theorem guarantees that a language A exists that can be
decided in O(22n) time but not in o(22n/ log 22n) = o(22n/2n) time. Therefore,
A ∈TIME(22n) but A ̸∈TIME(2n).
9.3
NTIME(n) ⊆NSPACE(n) because any Turing machine that operates in time
t(n) on every computation branch can use at most t(n) tape cells on every branch.
Furthermore, NSPACE(n) ⊆SPACE(n2) due to Savitch’s theorem. However,
SPACE(n2) ⊊SPACE(n3) because of the space hierarchy theorem. The result
follows because SPACE(n3) ⊆PSPACE.
9.7
(a) Σ500; (b) (Σ ∪ε)500; (c) Σ500Σ∗; (d) (Σ ∪ε)499 ∪Σ501Σ∗.
9.15
(a) Let A be any language and k ∈N. If A ∈P, then pad(A, nk) ∈P because you
can determine whether w ∈pad(A, nk) by writing w as s#l where s doesn’t contain
the # symbol, then testing whether |w| = |s|k; and ﬁnally testing whether s ∈A.
Implementing the ﬁrst test in polynomial time is straightforward. The second test
runs in time poly(|s|), and because |s| ≤|w|, the test runs in time poly(|w|) and
hence is in polynomial time. If pad(A, nk) ∈P, then A ∈P because you can
determine whether w ∈A by padding w with # symbols until it has length |w|k
and then testing whether the result is in pad(A, nk). Both of these actions require
only polynomial time.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

392
CHAPTER 9 / INTRACTABILITY
(b) Assume that P = SPACE(n). Let A be a language in SPACE(n2) but not
in SPACE(n) as shown to exist in the space hierarchy theorem. The language
pad(A, n2) ∈SPACE(n) because you have enough space to run the O(n2) space
algorithm for A, using space that is linear in the padded language. Because of the
assumption, pad(A, n2) ∈P, hence A ∈P by part (a), and hence A ∈SPACE(n),
due to the assumption once again. But that is a contradiction.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10
A D V A N C E D T O P I C S I N
C O M P L E X I T Y T H E O R Y
In this chapter, we brieﬂy introduce a few additional topics in complexity theory.
This subject is an active ﬁeld of research, and it has an extensive literature. This
chapter is a sample of more advanced developments, but is not a comprehensive
survey. In particular, two important topics that are beyond the scope of this book
are quantum computation and probabilistically checkable proofs. The Handbook
of Theoretical Computer Science [77] presents a survey of earlier work in complexity
theory.
This chapter contains sections on approximation algorithms, probabilistic
algorithms, interactive proof systems, parallel computation, and cryptography.
These sections are independent except that probabilistic algorithms are used in
the sections on interactive proof systems and cryptography.
10.1
APPROXIMATION ALGORITHMS
In certain problems called optimization problems, we seek the best solution
among a collection of possible solutions. For example, we may want to ﬁnd a
largest clique in a graph, a smallest vertex cover, or a shortest path connecting
two nodes. When an optimization problem is NP-hard, as is the case with the
393
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

394
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
ﬁrst two of these types of problems, no polynomial time algorithm exists that
ﬁnds the best solution unless P = NP.
In practice, we may not need the absolute best or optimal solution to a prob-
lem. A solution that is nearly optimal may be good enough and may be much
easier to ﬁnd. As its name implies, an approximation algorithm is designed to
ﬁnd such approximately optimal solutions.
For example, take the vertex cover problem that we introduced in Section 7.5.
There we presented the problem as the language VERTEX-COVER representing
a decision problem—one that has a yes/no answer.
In the optimization ver-
sion of this problem, called MIN-VERTEX-COVER, we aim to produce one of
the smallest vertex covers among all possible vertex covers in the input graph.
The following polynomial time algorithm approximately solves this optimiza-
tion problem. It produces a vertex cover that is never more than twice the size
of one of the smallest vertex covers.
A = “On input ⟨G⟩, where G is an undirected graph:
1.
Repeat the following until all edges in G touch a marked edge:
2.
Find an edge in G untouched by any marked edge.
3.
Mark that edge.
4.
Output all nodes that are endpoints of marked edges.”
THEOREM
10.1
A is a polynomial time algorithm that produces a vertex cover of G that is no
more than twice as large as a smallest vertex cover.
PROOF
A obviously runs in polynomial time. Let X be the set of nodes that
it outputs. Let H be the set of edges that it marks. We know that X is a vertex
cover because H contains or touches every edge in G, and hence X touches all
edges in G.
To prove that X is at most twice as large as a smallest vertex cover Y , we
establish two facts: X is twice as large as H, and H is not larger than Y . First,
every edge in H contributes two nodes to X, so X is twice as large as H. Second,
Y is a vertex cover, so every edge in H is touched by some node in Y . No such
node touches two edges in H because the edges in H do not touch each other.
Therefore, vertex cover Y is at least as large as H because Y contains a different
node that touches every edge in H. Hence X is no more than twice as large as Y .
MIN-VERTEX-COVER is an example of a minimization problem because
we aim to ﬁnd a smallest among the collection of possible solutions. In a maxi-
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.1
APPROXIMATION ALGORITHMS
395
mization problem, we seek a largest solution. An approximation algorithm for a
minimization problem is k-optimal if it always ﬁnds a solution that is not more
than k times optimal. The preceding algorithm is 2-optimal for the vertex cover
problem. For a maximization problem, a k-optimal approximation algorithm
always ﬁnds a solution that is at least 1
k times the size of the optimal.
The following is an approximation algorithm for a maximization problem
called MAX-CUT. A cut in an undirected graph is a separation of the vertices V
into two disjoint subsets S and T . A cut edge is an edge that goes between a node
in S and a node in T . An uncut edge is an edge that is not a cut edge. The size
of a cut is the number of cut edges. The MAX-CUT problem asks for a largest
cut in a graph G. As we showed in Problem 7.27, this problem is NP-complete.
The following algorithm approximates MAX-CUT within a factor of 2.
B = “On input ⟨G⟩, where G is an undirected graph with nodes V :
1.
Let S = ∅and T = V .
2.
If moving a single node, either from S to T or from T to S,
increases the size of the cut, make that move and repeat this
stage.
3.
If no such node exists, output the current cut and halt.”
This algorithm starts with a (presumably) bad cut and makes local improve-
ments until no further local improvement is possible. Although this procedure
won’t give an optimal cut in general, we show that it does give one that is at least
half the size of an optimal one.
THEOREM
10.2
B is a polynomial time, 2-optimal approximation algorithm for MAX-CUT.
PROOF
B runs in polynomial time because every execution of stage 2 in-
creases the size of the cut to a maximum of the total number of edges in G.
Now we show that B’s cut is at least half optimal. Actually, we show some-
thing stronger: B’s cut edges are at least half of all edges in G. Observe that at
every node of G, the number of cut edges is at least as large as the number of
uncut edges, or B would have shifted that node to the other side. We add up
the numbers of cut edges at every node. That sum is twice the total number of
cut edges because every cut edge is counted once for each of its two endpoints.
By the preceding observation, that sum must be at least the corresponding sum
of the numbers of uncut edges at every node. Thus, G has at least as many cut
edges as uncut edges. Therefore, the cut contains at least half of all edges.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

396
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
10.2
PROBABILISTIC ALGORITHMS
A probabilistic algorithm is an algorithm designed to use the outcome of a ran-
dom process. Typically, such an algorithm would contain an instruction to “ﬂip a
coin” and the result of that coin ﬂip would inﬂuence the algorithm’s subsequent
execution and output. Certain types of problems seem to be more easily solvable
by probabilistic algorithms than by deterministic algorithms.
How can making a decision by ﬂipping a coin ever be better than actually
calculating, or even estimating, the best choice in a particular situation? Some-
times, calculating the best choice may require excessive time, and estimating it
may introduce a bias that invalidates the result. For example, statisticians use
random sampling to determine information about the individuals in a large pop-
ulation, such as their tastes or political preferences. Querying all the individuals
might take too long, and querying a nonrandomly selected subset might tend to
give erroneous results.
THE CLASS BPP
We begin our formal discussion of probabilistic computation by deﬁning a model
of a probabilistic Turing machine. Then we give a complexity class associated
with efﬁcient probabilistic computation and a few examples.
DEFINITION
10.3
A probabilistic Turing machine M is a type of nondeterministic
Turing machine in which each nondeterministic step is called a
coin-ﬂip step and has two legal next moves. We assign a proba-
bility to each branch b of M’s computation on input w as follows.
Deﬁne the probability of branch b to be
Pr[ b ] = 2−k,
where k is the number of coin-ﬂip steps that occur on branch b.
Deﬁne the probability that M accepts w to be
Pr[M accepts w] =
X
b is an
accepting branch
Pr[ b ].
In other words, the probability that M accepts w is the probability that we
would reach an accepting conﬁguration if we simulated M on w by ﬂipping a
coin to determine which move to follow at each coin-ﬂip step. We let
Pr[M rejects w] = 1 −Pr[M accepts w].
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.2
PROBABILISTIC ALGORITHMS
397
When a probabilistic Turing machine decides a language, it must accept all
strings in the language and reject all strings out of the language as usual, except
that now we allow the machine a small probability of error. For 0 ≤ϵ < 1
2, we
say that M decides language A with error probability ϵ if
1. w ∈A implies Pr[M accepts w] ≥1 −ϵ, and
2. w ̸∈A implies Pr[M rejects w] ≥1 −ϵ.
In other words, the probability that we would obtain the wrong answer by sim-
ulating M is at most ϵ. We also consider error probability bounds that depend
on the input length n. For example, error probability ϵ = 2−n indicates an
exponentially small probability of error.
We are interested in probabilistic algorithms that run efﬁciently in time
and/or space. We measure the time and space complexity of a probabilistic Tur-
ing machine in the same way we do for a nondeterministic Turing machine: by
using the worst case computation branch on each input.
DEFINITION
10.4
BPP is the class of languages that are decided by probabilistic poly-
nomial time Turing machines with an error probability of 1
3.
We deﬁned this class with an error probability of 1
3, but any constant error
probability would yield an equivalent deﬁnition as long as it is strictly between 0
and 1
2 by virtue of the following ampliﬁcation lemma. It gives a simple way of
making the error probability exponentially small. Note that a probabilistic algo-
rithm with an error probability of 2−100 is far more likely to give an erroneous
result because the computer on which it runs has a hardware failure than because
of an unlucky toss of its coins.
LEMMA
10.5
Let ϵ be a ﬁxed constant strictly between 0 and 1
2. Then for any polynomial p(n),
a probabilistic polynomial time Turing machine M1 that operates with error
probability ϵ has an equivalent probabilistic polynomial time Turing machine
M2 that operates with an error probability of 2−p(n).
PROOF IDEA
M2 simulates M1 by running it a polynomial number of times
and taking the majority vote of the outcomes. The probability of error decreases
exponentially with the number of runs of M1 made.
Consider the case where ϵ = 1
3. It corresponds to a box that contains many
red and blue balls. We know that 2
3 of the balls are of one color and that the
remaining 1
3 are of the other color, but we don’t know which color is predomi-
nant. We can test for that color by sampling several—say, 100—balls at random
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

398
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
to determine which color comes up most frequently. Almost certainly, the pre-
dominant color in the box will be the most frequent one in the sample.
The balls correspond to branches of M1’s computation: red to accepting and
blue to rejecting. M2 samples the color by running M1. A calculation shows that
M2 errs with exponentially small probability if it runs M1 a polynomial number
of times and outputs the result that comes up most often.
PROOF
Given TM M1 deciding a language with an error probability of ϵ < 1
2
and a polynomial p(n), we construct a TM M2 that decides the same language
with an error probability of 2−p(n).
M2 = “On input x:
1.
Calculate k (see analysis below).
2.
Run 2k independent simulations of M1 on input x.
3.
If most runs of M1 accept, then accept; otherwise, reject.”
We bound1 the probability that M2 gives the wrong answer on an input x.
Stage 2 yields a sequence of 2k results from simulating M1, each result either
correct or wrong. If most of these results are correct, M2 gives the correct an-
swer. We bound the probability that at least half of these results are wrong.
Let S be any sequence of results that M2 might obtain in stage 2. Let PS
be the probability M2 obtains S. Say that S has c correct results and w wrong
results, so c + w = 2k. If c ≤w and M2 obtains S, then M2 outputs incorrectly.
We call such an S a bad sequence. Let ϵx be the probability that M1 is wrong on x.
If S is any bad sequence, then PS ≤(ϵx)w(1 −ϵx)c, which is at most ϵw(1 −ϵ)c
because ϵx ≤ϵ < 1
2 so ϵx(1 −ϵx) ≤ϵ(1 −ϵ), and because c ≤w. Furthermore,
ϵw(1 −ϵ)c is at most ϵk(1 −ϵ)k because k ≤w and ϵ < 1 −ϵ.
Summing PS for all bad sequences S gives the probability that M2 outputs
incorrectly. We have at most 22k bad sequences because 22k is the number of all
sequences. Hence
Pr

M2 outputs incorrectly on input x

=
X
bad S
PS ≤22k · ϵk(1 −ϵ)k = (4ϵ(1 −ϵ))k.
We’ve assumed ϵ <
1
2, so 4ϵ(1 −ϵ) < 1. Therefore, the above probability
decreases exponentially in k and so does M2’s error probability. To calculate a
speciﬁc value of k that allows us to bound M2’s error probability by 2−t for any
t ≥1, we let α = −log2(4ϵ(1 −ϵ)) and choose k ≥t/α. Then we obtain an
error probability of 2−p(n) within polynomial time.
1The analysis of the error probability follows from the Chernoff bound, a standard result
in probability theory. Here we give an alternative, self-contained calculation that avoids
any dependence on that result.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.2
PROBABILISTIC ALGORITHMS
399
PRIMALITY
A prime number is an integer greater than 1 that is not divisible by positive
integers other than 1 and itself. A nonprime number greater than 1 is called
composite. The ancient problem of testing whether an integer is prime or com-
posite has been the subject of extensive research. A polynomial time algorithm
for this problem is now known [4], but it is too difﬁcult to include here. In-
stead, we describe a much simpler probabilistic polynomial time algorithm for
primality testing.
One way to determine whether a number is prime is to try all possible integers
less than that number and see whether any are divisors, also called factors. That
algorithm has exponential time complexity because the magnitude of a number
is exponential in its length. The probabilistic primality testing algorithm that
we describe operates in a different manner entirely. It doesn’t search for factors.
Indeed, no probabilistic polynomial time algorithm for ﬁnding factors is known
to exist.
Before discussing the algorithm, we mention some notation from number
theory. All numbers in this section are integers. For any p greater than 1, we
say that two numbers are equivalent modulo p if they differ by a multiple of p.
If numbers x and y are equivalent modulo p, we write x ≡y (mod p). We let
x mod p be the smallest nonnegative y where x ≡y (mod p). Every number
is equivalent modulo p to some member of the set Zp = {0, . . ., p −1}. For
convenience, we let Z+
p = {1, . . ., p −1}. We may refer to the elements of these
sets by other numbers that are equivalent modulo p, as when we refer to p −1
by −1.
The main idea behind the algorithm stems from the following result, called
Fermat’s little theorem.
THEOREM
10.6
If p is prime and a ∈Z+
p , then ap−1 ≡1 (mod p).
For example, if p = 7 and a = 2, the theorem says that 2(7−1) mod 7 should be
1 because 7 is prime. The simple calculations
2(7−1) = 26 = 64
and
64 mod 7 = 1
conﬁrm this result. Suppose that we try p = 6 instead. Then
2(6−1) = 25 = 32
and
32 mod 6 = 2
give a result different from 1, implying by the theorem that 6 is not prime. Of
course, we already knew that. However, this method demonstrates that 6 is
composite without ﬁnding its factors. Problem 10.15 asks you to provide a proof
of this theorem.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

400
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
Think of the preceding theorem as providing a type of “test” for primality,
called a Fermat test. When we say that p passes the Fermat test at a, we mean
that ap−1 ≡1 (mod p). The theorem states that primes pass all Fermat tests for
a ∈Z+
p . We observed that 6 fails some Fermat test, so 6 isn’t prime.
Can we use the Fermat tests to give an algorithm for determining primality?
Almost. Call a number pseudoprime if it passes Fermat tests for all smaller a’s
relatively prime to it. With the exception of the infrequent Carmichael num-
bers, which are composite yet pass all Fermat tests, the pseudoprime numbers
are identical to the prime numbers. We begin by giving a very simple probabilis-
tic polynomial time algorithm that distinguishes primes from composites except
for the Carmichael numbers. Afterwards, we present and analyze the complete
probabilistic primality testing algorithm.
A pseudoprimality algorithm that goes through all Fermat tests would require
exponential time. The key to the probabilistic polynomial time algorithm is that
if a number is not pseudoprime, it fails at least half of all tests. (Just accept this
assertion for now. Problem 10.16 asks you to prove it.) The algorithm works by
trying several tests chosen at random. If any fail, the number must be composite.
The algorithm contains a parameter k that determines the error probability.
PSEUDOPRIME = “On input p:
1.
Select a1, . . . , ak randomly in Z+
p .
2.
Compute ap−1
i
mod p for each i.
3.
If all computed values are 1, accept; otherwise, reject.”
If p is pseudoprime, it passes all tests and the algorithm accepts with certainty.
If p isn’t pseudoprime, it passes at most half of all tests. In that case, it passes each
randomly selected test with probability at most 1
2. The probability that it passes
all k randomly selected tests is thus at most 2−k. The algorithm operates in
polynomial time because modular exponentiation is computable in polynomial
time (see Problem 7.13).
To convert the preceding algorithm to a primality algorithm, we introduce a
more sophisticated test that avoids the problem with the Carmichael numbers.
The underlying principle is that the number 1 has exactly two square roots,
1 and −1, modulo any prime p. For many composite numbers, including all
the Carmichael numbers, 1 has four or more square roots. For example, ±1 and
±8 are the four square roots of 1, modulo 21. If a number passes the Fermat test
at a, the algorithm ﬁnds one of its square roots of 1 at random and determines
whether that square root is 1 or −1. If it isn’t, we know that the number isn’t
prime.
We can obtain square roots of 1 if p passes the Fermat test at a because
ap−1 mod p = 1, and so a(p−1)/2 mod p is a square root of 1. If that value is
still 1, we may repeatedly divide the exponent by 2, so long as the resulting
exponent remains an integer, and see whether the ﬁrst number that is different
from 1 is −1 or some other number. We give a formal proof of the correctness of
the algorithm immediately following its description. Select k ≥1 as a parameter
that determines the maximum error probability to be 2−k.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.2
PROBABILISTIC ALGORITHMS
401
PRIME = “On input p:
1.
If p is even, accept if p = 2; otherwise, reject.
2.
Select a1, . . . , ak randomly in Z+
p .
3.
For each i from 1 to k:
4.
Compute ap−1
i
mod p and reject if different from 1.
5.
Let p −1 = s · 2l where s is odd.
6.
Compute the sequence as·20
i
, as·21
i
, as·22
i
, . . . , as·2l
i
modulo p.
7.
If some element of this sequence is not 1, ﬁnd the last element
that is not 1 and reject if that element is not −1.
8.
All tests have passed at this point, so accept.”
The following two lemmas show that algorithm PRIME works correctly. Obvi-
ously the algorithm is correct when p is even, so we only consider the case when
p is odd. Say that ai is a (compositeness) witness if the algorithm rejects at either
stage 4 or 7, using ai.
LEMMA
10.7
If p is an odd prime number, Pr

PRIME accepts p

= 1.
PROOF
We ﬁrst show that if p is prime, no witness exists and so no branch
of the algorithm rejects. If a were a stage 4 witness, (ap−1 mod p) ̸= 1 and
Fermat’s little theorem implies that p is composite. If a were a stage 7 witness,
some b exists in Z+
p , where b ̸≡±1 (mod p) and b2 ≡1 (mod p).
Therefore, b2 −1 ≡0 (mod p). Factoring b2 −1 yields
(b −1)(b + 1) ≡0
(mod p),
which implies that
(b −1)(b + 1) = cp
for some positive integer c. Because b ̸≡±1 (mod p), both b −1 and b + 1 are
strictly between 0 and p. Therefore, p is composite because a multiple of a prime
number cannot be expressed as a product of numbers that are smaller than it is.
The next lemma shows that the algorithm identiﬁes composite numbers with
high probability. First, we present an important elementary tool from number
theory. Two numbers are relatively prime if they have no common divisor other
than 1. The Chinese remainder theorem says that a one-to-one correspondence
exists between Zpq and Zp × Zq if p and q are relatively prime. Each number
r ∈Zpq corresponds to a pair (a, b), where a ∈Zp and b ∈Zq, such that
r ≡a
(mod p), and
r ≡b
(mod q).
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

402
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
LEMMA
10.8
If p is an odd composite number, Pr

PRIME accepts p

≤2−k.
PROOF
We show that if p is an odd composite number and a is selected ran-
domly in Z+
p ,
Pr

a is a witness

≥1
2
by demonstrating that at least as many witnesses as nonwitnesses exist in Z+
p .
We do so by ﬁnding a unique witness for each nonwitness.
In every nonwitness, the sequence computed in stage 6 is either all 1s or con-
tains −1 at some position, followed by 1s. For example, 1 itself is a nonwitness
of the ﬁrst kind, and −1 is a nonwitness of the second kind because s is odd and
(−1)s·20 ≡−1 and (−1)s·21 ≡1. Among all nonwitnesses of the second kind,
ﬁnd a nonwitness for which the −1 appears in the largest position in the se-
quence. Let h be that nonwitness and let j be the position of −1 in its sequence,
where the sequence positions are numbered starting at 0. Hence hs·2j ≡−1
(mod p).
Because p is composite, either p is the power of a prime or we can write p as
the product of q and r—two numbers that are relatively prime. We consider the
latter case ﬁrst. The Chinese remainder theorem implies that some number t
exists in Zp whereby
t ≡h
(mod q)
and
t ≡1
(mod r).
Therefore,
ts·2j ≡−1
(mod q)
and
ts·2j ≡1
(mod r).
Hence t is a witness because ts·2j ̸≡±1 (mod p) but ts·2j+1 ≡1 (mod p).
Now that we have one witness, we can get many more.
We prove that
dt mod p is a unique witness for each nonwitness d by making two observations.
First, ds·2j ≡±1 (mod p) and ds·2j+1 ≡1 (mod p) owing to the way j was cho-
sen. Therefore, dt mod p is a witness because (dt)s·2j ̸≡±1 and (dt)s·2j+1 ≡1
(mod p).
Second, if d1 and d2 are distinct nonwitnesses, d1t mod p ̸= d2t mod p. The
reason is that ts·2j+1 mod p = 1. Hence t · ts·2j+1−1 mod p = 1. Therefore, if
td1 mod p = td2 mod p, then
d1 = t · ts·2j+1−1d1 mod p = t · ts·2j+1−1d2 mod p = d2.
Thus, the number of witnesses must be as large as the number of nonwitnesses,
and we have completed the analysis for the case where p is not a prime power.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.2
PROBABILISTIC ALGORITHMS
403
For the prime power case, we have p = qe where q is prime and e > 1. Let
t = 1 + qe−1. Expanding tp using the binomial theorem, we obtain
tp = (1 + qe−1)p = 1 + p · qe−1 + multiples of higher powers of qe−1,
which is equivalent to 1 mod p. Hence t is a stage 4 witness because if tp−1 ≡1
(mod p), then tp ≡t ̸≡1 (mod p). As in the previous case, we use this one
witness to get many others. If d is a nonwitness, we have dp−1 ≡1 (mod p),
but then dt mod p is a witness. Moreover, if d1 and d2 are distinct nonwitnesses,
then d1t mod p ̸= d2t mod p. Otherwise,
d1 = d1 · t · tp−1 mod p = d2 · t · tp−1 mod p = d2.
Thus, the number of witnesses must be as large as the number of nonwitnesses
and the proof is complete.
The preceding algorithm and its analysis establishes the following theorem.
Let PRIMES = {n| n is a prime number in binary}.
THEOREM
10.9
PRIMES ∈BPP.
Note that the probabilistic primality algorithm has one-sided error. When
the algorithm outputs reject, we know that the input must be composite. When
the output is accept, we know only that the input could be prime or composite.
Thus, an incorrect answer can only occur when the input is a composite number.
The one-sided error feature is common to many probabilistic algorithms, so the
special complexity class RP is designated for it.
DEFINITION
10.10
RP is the class of languages that are decided by probabilistic poly-
nomial time Turing machines where inputs in the language are
accepted with a probability of at least 1
2, and inputs not in the lan-
guage are rejected with a probability of 1.
We can make the error probability exponentially small and maintain a poly-
nomial running time by using a probability ampliﬁcation technique similar to
(actually simpler than) the one we used in Lemma 10.5. Our earlier algorithm
shows that COMPOSITES ∈RP.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

404
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
READ-ONCE BRANCHING PROGRAMS
A branching program is a model of computation used in complexity theory and in
certain practical areas such as computer-aided design. This model represents a
decision process that queries the values of input variables and determines how
to proceed based on the answers to those queries. We represent this decision
process as a graph whose nodes correspond to the particular variable queried at
that point in the process.
In this section, we investigate the complexity of testing whether two branch-
ing programs are equivalent. In general, that problem is coNP-complete. If
we place a certain natural restriction on the class of branching programs, we
can give a probabilistic polynomial time algorithm for testing equivalence. This
algorithm is especially interesting for two reasons. First, no polynomial time
algorithm is known for this problem, so it provides an example of probabilism
apparently expanding the class of languages whereby membership can be tested
efﬁciently. Second, this algorithm introduces the technique of assigning non-
Boolean values to normally Boolean variables in order to analyze the behavior of
some Boolean function of those variables. That technique is used to great effect
in interactive proof systems, as we show in Section 10.4.
DEFINITION
10.11
A branching program is a directed acyclic2 graph where all nodes
are labeled by variables, except for two output nodes labeled 0 or 1.
The nodes that are labeled by variables are called query nodes.
Every query node has two outgoing edges: one labeled 0 and the
other labeled 1. Both output nodes have no outgoing edges. One
of the nodes in a branching program is designated the start node.
A branching program determines a Boolean function as follows. Take any
assignment to the variables appearing on its query nodes and, beginning at the
start node, follow the path determined by taking the outgoing edge from each
query node according to the value assigned to the indicated variable until one
of the output nodes is reached. The output is the label of that output node.
Figure 10.12 gives two examples of branching programs.
Branching programs are related to the class L in a way that is analogous to
the relationship between Boolean circuits and the class P. Problem 10.17 asks
you to show that a branching program with polynomially many nodes can test
membership in any language over {0,1} that is in L.
2A directed graph is acyclic if it has no directed cycles.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.2
PROBABILISTIC ALGORITHMS
405
FIGURE
10.12
Two read-once branching programs
Two branching programs are equivalent if they determine equal functions.
Problem 10.21 asks you to show that the problem of testing equivalence for
branching programs is coNP-complete. Here we consider a restricted form of
branching programs. A read-once branching program is one that can query each
variable at most one time on every directed path from the start node to an output
node. Both branching programs in Figure 10.12 have the read-once feature. Let
EQROBP = {⟨B1, B2⟩|B1 and B2 are equivalent read-once branching programs}.
THEOREM
10.13
EQROBP is in BPP.
PROOF IDEA
First, let’s try assigning random values to the variables x1
through xm that appear in B1 and B2, and evaluate these branching programs
on that setting. We accept if B1 and B2 agree on the assignment and reject oth-
erwise. However, this strategy doesn’t work because two inequivalent read-once
branching programs may disagree only on a single assignment out of the 2m
possible Boolean assignments to the variables. The probability that we would
select that assignment is exponentially small. Hence we would accept with high
probability even when B1 and B2 are not equivalent, and that is unsatisfactory.
Instead, we modify this strategy by randomly selecting a non-Boolean assign-
ment to the variables, and evaluate B1 and B2 in a suitably deﬁned manner. We
can then show that if B1 and B2 are not equivalent, the random evaluations will
likely be unequal.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

406
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
PROOF
We assign polynomials over x1, . . . , xm to the nodes and to the edges
of a read-once branching program B as follows. The constant function 1 is
assigned to the start node. If a node labeled x has been assigned polynomial
p, assign the polynomial xp to its outgoing 1-edge, and assign the polynomial
(1 −x)p to its outgoing 0-edge. If the edges incoming to some node have been
assigned polynomials, assign the sum of those polynomials to that node. Fi-
nally, the polynomial that has been assigned to the output node labeled 1 is also
assigned to the branching program itself. Now we are ready to present the prob-
abilistic polynomial time algorithm for EQROBP. Let F be a ﬁnite ﬁeld with at
least 3m elements.
D = “On input ⟨B1, B2⟩, two read-once branching programs:
1.
Select elements a1 through am at random from F.
2.
Evaluate the assigned polynomials p1 and p2 at a1 through am.
3.
If p1(a1, . . . , am) = p2(a1, . . . , am), accept; otherwise, reject.”
This algorithm runs in polynomial time because we can evaluate the polyno-
mial corresponding to a branching program without actually constructing the
polynomial. We show that the algorithm decides EQROBP with an error proba-
bility of at most 1
3.
Let’s examine the relationship between a read-once branching program B
and its assigned polynomial p. Observe that for any Boolean assignment to B’s
variables, all polynomials assigned to its nodes evaluate to either 0 or 1. The
polynomials that evaluate to 1 are those on the computation path for that as-
signment. Hence B and p agree when the variables take on Boolean values.
Similarly, because B is read-once, we may write p as a sum of product terms
y1y2 · · · ym, where each yi is xi, (1 −xi), or 1, and where each product term
corresponds to a path in B from the start node to the output node labeled 1.
The case of yi = 1 occurs when a path doesn’t contain variable xi.
Take each such product term of p containing a yi that is 1 and split it into the
sum of two product terms, one where yi = xi and the other where yi = (1 −xi).
Doing so yields an equivalent polynomial because 1 = xi + (1 −xi). Continue
splitting product terms until each yi is either xi or (1 −xi). The end result
is an equivalent polynomial q that contains a product term for each assignment
on which B evaluates to 1. Now we are ready to analyze the behavior of the
algorithm D.
First, we show that if B1 and B2 are equivalent, D always accepts. If the
branching programs are equivalent, they evaluate to 1 on exactly the same assign-
ments. Consequently, the polynomials q1 and q2 are equal because they contain
identical product terms. Therefore, p1 and p2 are equal on every assignment.
Second, we show that if B1 and B2 aren’t equivalent, D rejects with a proba-
bility of at least 2
3. This conclusion follows immediately from Lemma 10.15.
The preceding proof relies on the following lemmas concerning the proba-
bility of randomly ﬁnding a root of a polynomial as a function of the number of
variables it has, the degrees of its variables, and the size of the underlying ﬁeld.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.2
PROBABILISTIC ALGORITHMS
407
LEMMA
10.14
For every d ≥0, a degree-d polynomial p on a single variable x either has at
most d roots, or is everywhere equal to 0.
PROOF
We use induction on d.
Basis: Prove for d = 0. A polynomial of degree 0 is constant. If that constant is
not 0, the polynomial clearly has no roots.
Induction step: Assume true for d −1 and prove true for d. If p is a nonzero
polynomial of degree d with a root at a, the polynomial x −a divides p evenly.
Then p/(x −a) is a nonzero polynomial of degree d −1, and it has at most d −1
roots by virtue of the induction hypothesis.
LEMMA
10.15
Let F be a ﬁnite ﬁeld with f elements and let p be a nonzero polynomial on the
variables x1 through xm, where each variable has degree at most d. If a1 through
am are selected randomly in F, then Pr

p(a1, . . . , am) = 0

≤md/f.
PROOF
We use induction on m.
Basis: Prove for m = 1. By Lemma 10.14, p has at most d roots, so the proba-
bility that a1 is one of them is at most d/f.
Induction step: Assume true for m −1 and prove true for m. Let x1 be one of
p’s variables. For each i ≤d, let pi be the polynomial comprising the terms of p
containing xi
1, but where xi
1 has been factored out. Then
p = p0 + x1p1 + x2
1p2 + · · · + xd
1pd.
If p(a1, . . . , am) = 0, one of two cases arises. Either all pi evaluate to 0, or some
pi doesn’t evaluate to 0 and a1 is a root of the single variable polynomial obtained
by evaluating p0 through pd on a2 through am.
To bound the probability that the ﬁrst case occurs, observe that one of the pj
must be nonzero because p is nonzero. Then the probability that all pi evaluate
to 0 is at most the probability that pj evaluates to 0. By the induction hypothesis,
that is at most (m −1)d/f because pj has at most m −1 variables.
To bound the probability that the second case occurs, observe that if some pi
doesn’t evaluate to 0, then on the assignment of a2 through am, p reduces to a
nonzero polynomial in the single variable x1. The basis already shows that a1 is
a root of such a polynomial with a probability of at most d/f.
Therefore, the probability that a1 through am is a root of the polynomial is
at most (m −1)d/f + d/f = md/f.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

408
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
We conclude this section with one important point concerning the use of
randomness in probabilistic algorithms. In our analyses, we assume that these
algorithms are implemented using true randomness. True randomness may be
difﬁcult (or impossible) to obtain, so it is usually simulated with pseudorandom
generators, which are deterministic algorithms whose output appears random.
Although the output of any deterministic procedure can never be truly random,
some of these procedures generate results that have certain characteristics of
randomly generated results. Algorithms that are designed to use randomness
may work equally well with these pseudorandom generators, but proving that
they do is generally more difﬁcult. Indeed, sometimes probabilistic algorithms
may not work well with certain pseudorandom generators. Sophisticated pseu-
dorandom generators have been devised that produce results indistinguishable
from truly random results by any test that operates in polynomial time, under
the assumption that a one-way function exists. (See Section 10.6 for a discussion
of one-way functions.)
10.3
ALTERNATION
Alternation is a generalization of nondeterminism that has proven to be useful in
understanding relationships among complexity classes, and in classifying speciﬁc
problems according to their complexity. Using alternation, we may simplify
various proofs in complexity theory and exhibit a surprising connection between
the time and space complexity measures.
An alternating algorithm may contain instructions to branch a process into
multiple child processes, just as in a nondeterministic algorithm. The difference
between the two lies in the mode of determining acceptance. A nondeterministic
computation accepts if any one of the initiated processes accepts. When an alter-
nating computation divides into multiple processes, two possibilities arise. The
algorithm can designate that the current process accepts if any of the children
accept, or it can designate that the current process accepts if all of the children
accept.
Picture the difference between alternating and nondeterministic computation
with trees that represent the branching structure of the spawned processes. Each
node represents a conﬁguration in a process. In a nondeterministic computa-
tion, each node computes the OR operation of its children. That corresponds
to the usual nondeterministic acceptance mode whereby a process is accepting
if any of its children are accepting. In an alternating computation, the nodes
may compute the AND or OR operations as determined by the algorithm. That
corresponds to the alternating acceptance mode whereby a process is accepting
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.3
ALTERNATION
409
if all or any of its children accept. We deﬁne an alternating Turing machine as
follows.
DEFINITION
10.16
An alternating Turing machine is a nondeterministic Turing ma-
chine with an additional feature. Its states, except for qaccept and
qreject, are divided into universal states and existential states. When
we run an alternating Turing machine on an input string, we label
each node of its nondeterministic computation tree with ∧or ∨,
depending on whether the corresponding conﬁguration contains a
universal state or an existential state. We designate a node to be
accepting if it is labeled with ∧and all of its children are accepting,
or if it is labeled with ∨and any of its children are accepting. The
input is accepted if the start node is designated accepting.
The following ﬁgure shows nondeterministic and alternating computation
trees. We label the nodes of the alternating computation tree with ∧or ∨to
indicate which function of their children they compute.
FIGURE
10.17
Nondeterministic and alternating computation trees
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

410
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
ALTERNATING TIME AND SPACE
We deﬁne the time and space complexity of these machines in the same way that
we did for nondeterministic Turing machines: by taking the maximum time or
space used by any computation branch. We deﬁne the alternating time and space
complexity classes as follows.
DEFINITION
10.18
ATIME(t(n)) = {L| L is decided by an O(t(n)) time
alternating Turing machine}.
ASPACE(f(n)) = {L| L is decided by an O(f(n)) space
alternating Turing machine}.
We deﬁne AP, APSPACE, and AL to be the classes of languages that are
decided by alternating polynomial time, alternating polynomial space, and alter-
nating logarithmic space Turing machines, respectively.
EXAMPLE
10.19
A tautology is a Boolean formula that evaluates to 1 on every assignment to
its variables. Let TAUT = {⟨φ⟩| φ is a tautology}. The following alternating
algorithm shows that TAUT is in AP.
“On input ⟨φ⟩:
1.
Universally select all assignments to the variables of φ.
2.
For a particular assignment, evaluate φ.
3.
If φ evaluates to 1, accept; otherwise, reject.”
Stage 1 of this algorithm nondeterministically selects every assignment to φ’s
variables with universal branching. That requires all branches to accept in order
for the entire computation to accept. Stages 2 and 3 deterministically check
whether the assignment that was selected on a particular computation branch
satisﬁes the formula. Hence this algorithm accepts its input if it determines that
all assignments are satisfying.
Observe that TAUT is a member of coNP. In fact, any problem in coNP can
easily be shown to be in AP by using an algorithm similar to the preceding one.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.3
ALTERNATION
411
EXAMPLE
10.20
This example features a language in AP that isn’t known to be in NP or in
coNP. Recall the language MIN-FORMULA that we deﬁned in Problem 7.46
on page 328. The following algorithm shows that MIN-FORMULA is in AP.
“On input ⟨φ⟩:
1.
Universally select all formulas ψ that are shorter than φ.
2.
Existentially select an assignment to the variables of φ.
3.
Evaluate both φ and ψ on this assignment.
4.
Accept if the formulas evaluate to different values.
Reject if they evaluate to the same value.”
This algorithm starts with universal branching to select all shorter formulas
in stage 1 and then switches to existential branching to select an assignment
in stage 2. The term alternation stems from the ability to alternate, or switch,
between universal and existential branching.
Alternation allows us to make a remarkable connection between the time
and space measures of complexity. Roughly speaking, the following theorem
demonstrates an equivalence between alternating time and deterministic space
for polynomially related bounds, and another equivalence between alternating
space and deterministic time when the time bound is exponentially more than
the space bound.
THEOREM
10.21
For f(n) ≥n, we have ATIME(f(n)) ⊆SPACE(f(n)) ⊆ATIME(f 2(n)).
For f(n) ≥log n, we have ASPACE(f(n)) = TIME(2O(f(n))).
Consequently, AL = P, AP = PSPACE, and APSPACE = EXPTIME. The
proof of this theorem is in the following four lemmas.
LEMMA
10.22
For f(n) ≥n, we have ATIME(f(n)) ⊆SPACE(f(n)).
PROOF
We convert an alternating time O(f(n)) machine M to a determin-
istic space O(f(n)) machine S that simulates M as follows. On input w, the
simulator S performs a depth-ﬁrst search of M’s computation tree to determine
which nodes in the tree are accepting. Then S accepts if it determines that the
root of the tree, corresponding to M’s starting conﬁguration, is accepting.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

412
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
Machine S requires space for storing the recursion stack that is used in the
depth-ﬁrst search. Each level of the recursion stores one conﬁguration. The
recursion depth is M’s time complexity. Each conﬁguration uses O(f(n)) space,
and M’s time complexity is O(f(n)). Hence S uses O(f 2(n)) space.
We can improve the space complexity by observing that S does not need to
store the entire conﬁguration at each level of the recursion. Instead it records
only the nondeterministic choice that M made to reach that conﬁguration from
its parent. Then S can recover this conﬁguration by replaying the computation
from the start and following the recorded “signposts.” Making this change re-
duces the space usage to a constant at each level of the recursion. The total used
now is thus O(f(n)).
LEMMA
10.23
For f(n) ≥n, we have SPACE(f(n)) ⊆ATIME(f 2(n)).
PROOF
We start with a deterministic space O(f(n)) machine M and con-
struct an alternating machine S that uses time O(f 2(n)) to simulate it. The
approach is similar to that used in the proof of Savitch’s theorem (Theorem 8.5),
where we constructed a general procedure for the yieldability problem.
In the yieldability problem, we are given conﬁgurations c1 and c2 of M and
a number t. We must test whether M can get from c1 to c2 within t steps.
An alternating procedure for this problem ﬁrst branches existentially to guess a
conﬁguration cm midway between c1 and c2. Then it branches universally into
two processes: one that recursively tests whether c1 can get to cm within t/2
steps, and the other whether cm can get to c2 within t/2 steps.
Machine S uses this recursive alternating procedure to test whether the start
conﬁguration can reach an accepting conﬁguration within 2df(n) steps. Here,
d is selected so that M has no more than 2df(n) conﬁgurations within its space
bound.
The maximum time used on any branch of this alternating procedure is
O(f(n)) to write a conﬁguration at each level of the recursion, times the depth
of the recursion, which is log 2df(n) = O(f(n)). Hence this algorithm runs in
alternating time O(f 2(n)).
LEMMA
10.24
For f(n) ≥log n, we have ASPACE(f(n)) ⊆TIME(2O(f(n))).
PROOF
We construct a deterministic time 2O(f(n)) machine S to simulate an
alternating space O(f(n)) machine M. On input w, the simulator S constructs
the following graph of the computation of M on w. The nodes are the con-
ﬁgurations of M on w that use at most df(n) space, where d is the appropriate
constant factor for M. Edges go from a conﬁguration to those conﬁgurations it
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.3
ALTERNATION
413
can yield in a single move of M. After constructing the graph, S repeatedly scans
it and marks certain conﬁgurations as accepting. Initially, only the actual accept-
ing conﬁgurations of M are marked this way. A conﬁguration that performs
universal branching is marked accepting if all of its children are so marked, and
an existential conﬁguration is marked if any of its children are marked. Machine
S continues scanning and marking until no additional nodes are marked on a
scan. Finally, S accepts if the start conﬁguration of M on w is marked.
The number of conﬁgurations of M on w is 2O(f(n)) because f(n) ≥log n.
Therefore, the size of the conﬁguration graph is 2O(f(n)) and constructing it may
be done in 2O(f(n)) time. Scanning the graph once takes roughly the same time.
The total number of scans is at most the number of nodes in the graph because
each scan except for the ﬁnal one marks at least one additional node. Hence the
total time used is 2O(f(n)).
LEMMA
10.25
For f(n) ≥log n, we have ASPACE(f(n)) ⊇TIME(2O(f(n))).
PROOF
We show how to simulate a deterministic time 2O(f(n)) machine M
by an alternating Turing machine S that uses space O(f(n)). This simulation
is tricky because the space available to S is so much less than the size of M’s
computation. In this case, S has only enough space to store pointers into a
tableau for M on w, as depicted in the following ﬁgure.
FIGURE
10.26
A tableau for M on w
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

414
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
We use the representation for conﬁgurations as given in the proof of Theo-
rem 9.30, whereby a single symbol may represent both the state of the machine
and the content of the tape cell under the head. The contents of cell d in Fig-
ure 10.26 are then determined by the contents of its parents a, b, and c. (A cell
on the left or right boundary has only two parents.)
Simulator S operates recursively to guess and then verify the contents of the
individual cells of the tableau. To verify the contents of a cell d outside the ﬁrst
row, simulator S existentially guesses the contents of the parents, checks whether
their contents would yield d’s contents according to M’s transition function, and
then universally branches to verify these guesses recursively. If d were in the ﬁrst
row, S veriﬁes the answer directly because it knows M’s starting conﬁguration.
We assume that M moves its head to the left-hand end of the tape on acceptance,
so S can determine whether M accepts w by checking the contents of the lower
leftmost cell of the tableau. Hence S never needs to store more than a single
pointer to a cell in the tableau, so it uses space log 2O(f(n)) = O(f(n)).
THE POLYNOMIAL TIME HIERARCHY
Alternating machines provide a way to deﬁne a natural hierarchy of classes within
the class PSPACE.
DEFINITION
10.27
Let i be a natural number. A Σi-alternating Turing machine is
an alternating Turing machine that on every input and on every
computation branch contains at most i runs of universal or existen-
tial steps, starting with existential steps. A Πi-alternating Turing
machine is similar except that it starts with universal steps.
Deﬁne ΣiTIME(f(n)) to be the class of languages that a Σi-alternating
TM can decide in O(f(n)) time. Similarly, deﬁne the class ΠiTIME(f(n)) for
Πi-alternating Turing machines, and deﬁne the classes ΣiSPACE(f(n)) and
ΠiSPACE(f(n)) for space bounded alternating Turing machines. We deﬁne
the polynomial time hierarchy to be the collection of classes
ΣiP =
[
k
ΣiTIME(nk) and
ΠiP =
[
k
ΠiTIME(nk).
Deﬁne class PH = S
i ΣiP = S
i ΠiP. Clearly, NP = Σ1P and coNP = Π1P.
Additionally, MIN-FORMULA ∈Π2P.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.4
INTERACTIVE PROOF SYSTEMS
415
10.4
INTERACTIVE PROOF SYSTEMS
Interactive proof systems provide a way to deﬁne a probabilistic analog of the
class NP, much like probabilistic polynomial time algorithms provide a prob-
abilistic analog to P. The development of interactive proof systems has pro-
foundly affected complexity theory and has led to important advances in the
ﬁelds of cryptography and approximation algorithms. To get a feel for this new
concept, let’s revisit our intuition about NP.
The languages in NP are those whose members all have short certiﬁcates of
membership that can be easily checked. If you need to, go back to page 294
and review this formulation of NP. Let’s rephrase this formulation by creating
two entities: a Prover that ﬁnds the proofs of membership, and a Veriﬁer that
checks them. Think of the Prover as if it were convincing the Veriﬁer of w’s
membership in A. We require the Veriﬁer to be a polynomial time bounded
machine; otherwise, it could ﬁgure out the answer itself. We don’t impose any
computational bound on the Prover because ﬁnding the proof may be time-
consuming.
Take the SAT problem, for example. A Prover can convince a polynomial
time Veriﬁer that a formula φ is satisﬁable by supplying a satisfying assignment.
Can a Prover similarly convince a computationally limited Veriﬁer that a for-
mula is not satisﬁable? The complement of SAT is not known to be in NP, so
we can’t rely on the certiﬁcate idea. Nonetheless, the surprising answer is yes,
provided we give the Prover and Veriﬁer two additional features. First, they are
permitted to engage in a two-way dialog. Second, the Veriﬁer may be a prob-
abilistic polynomial time machine that reaches the correct answer with a high
degree of, but not absolute, certainty. Such a Prover and Veriﬁer constitute an
interactive proof system.
GRAPH NONISOMORPHISM
We illustrate the interactive proof concept through the elegant example of the
graph isomorphism problem. Call graphs G and H isomorphic if the nodes of G
may be reordered so that it is identical to H. Let
ISO = {⟨G, H⟩| G and H are isomorphic graphs}.
Although ISO is obviously in NP, extensive research has so far failed to demon-
strate either a polynomial time algorithm for this problem or a proof that it is
NP-complete. It is one of a relatively small number of naturally occurring lan-
guages in NP that haven’t been placed in either category.
Here, we consider the language that is complementary to ISO—namely, the
language NONISO = {⟨G, H⟩| G and H are not isomorphic graphs}. NONISO is
not known to be in NP because we don’t know how to provide short certiﬁcates
that graphs aren’t isomorphic. Nonetheless, when two graphs aren’t isomorphic,
a Prover can convince a Veriﬁer of this fact, as we will show.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

416
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
Suppose that we have two graphs: G1 and G2. If they are isomorphic, the
Prover can convince the Veriﬁer of this fact by presenting the isomorphism or
reordering. But if they aren’t isomorphic, how can the Prover convince the
Veriﬁer of that fact? Don’t forget: The Veriﬁer doesn’t necessarily trust the
Prover, so it isn’t enough for the Prover to declare that they aren’t isomorphic.
The Prover must convince the Veriﬁer. Consider the following short protocol.
The Veriﬁer randomly selects either G1 or G2 and then randomly reorders its
nodes to obtain a graph H. The Veriﬁer sends H to the Prover. The Prover must
respond by declaring whether G1 or G2 was the source of H. That concludes
the protocol.
If G1 and G2 were indeed nonisomorphic, the Prover could always carry out
the protocol because the Prover could identify whether H came from G1 or G2.
However, if the graphs were isomorphic, H might have come from either G1
or G2. So even with unlimited computational power, the Prover would have no
better than a 50–50 chance of getting the correct answer. Thus, if the Prover is
able to answer correctly consistently (say in 100 repetitions of the protocol), the
Veriﬁer has convincing evidence that the graphs are actually nonisomorphic.
DEFINITION OF THE MODEL
To deﬁne the interactive proof system model formally, we describe the Veriﬁer,
the Prover, and their interaction. You’ll ﬁnd it helpful to keep the graph non-
isomorphism example in mind. We deﬁne the Veriﬁer to be a function V that
computes its next transmission to the Prover from the message history sent so
far. The function V has three inputs:
1. Input string. The objective is to determine whether this string is a mem-
ber of some language. In the NONISO example, the input string encoded
the two graphs.
2. Random input. For convenience in making the deﬁnition, we provide
the Veriﬁer with a randomly chosen input string instead of the equivalent
capability to make probabilistic moves during its computation.
3. Partial message history. A function has no memory of the dialog that
has been sent so far, so we provide the memory externally via a string
representing the exchange of messages up to the present point. We use
the notation m1#m2# · · · #mi to represent the exchange of messages m1
through mi.
The Veriﬁer’s output is either the next message mi+1 in the sequence or accept
or reject, designating the conclusion of the interaction. Thus, V has the func-
tional form V : Σ∗× Σ∗× Σ∗−→Σ∗∪{accept, reject}.
V (w, r, m1# · · · #mi) = mi+1 means that the input string is w, the random
input is r, the current message history is m1 through mi, and the Veriﬁer’s next
message to the Prover is mi+1.
The Prover is a party with unlimited computational ability. We deﬁne it to
be a function P with two inputs:
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.4
INTERACTIVE PROOF SYSTEMS
417
1. Input string
2. Partial message history
The Prover’s output is the next message to the Veriﬁer. Formally, P has the form
P : Σ∗× Σ∗−→Σ∗.
P(w, m1# · · · #mi) = mi+1 means that the Prover sends mi+1 to the Veriﬁer
after having exchanged messages m1 through mi so far.
Next, we deﬁne the interaction between the Prover and the Veriﬁer. For par-
ticular strings w and r, we write (V ↔P)(w, r) = accept if a message sequence
m1 through mk exists for some k whereby
1. for 0 ≤i < k, where i is an even number, V (w, r, m1# · · · #mi) = mi+1;
2. for 0 < i < k, where i is an odd number, P(w, m1# · · · #mi) = mi+1; and
3. the ﬁnal message mk in the message history is accept.
To simplify the deﬁnition of the class IP, we assume that the lengths of the
Veriﬁer’s random input and each of the messages exchanged between the Veriﬁer
and the Prover are p(n) for some polynomial p that depends only on the Veriﬁer.
Furthermore, we assume that the total number of messages exchanged is at most
p(n). The following deﬁnition gives the probability that an interactive proof
system accepts an input string w. For any string w of length n, we deﬁne
Pr

V ↔P accepts w

= Pr

(V ↔P)(w, r) = accept

,
where r is a randomly selected string of length p(n).
DEFINITION
10.28
Say that language A is in IP if some polynomial time computable
function V exists such that for some (arbitrary) function P and for
every (arbitrary) function eP and for every string w,
1. w ∈A implies Pr

V ↔P accepts w

≥2
3, and
2. w ̸∈A implies Pr

V ↔eP accepts w

≤1
3.
In other words, if w ∈A then some Prover P (an “honest” Prover) causes the
Veriﬁer to accept with high probability; but if w ̸∈A, then no Prover (not even
a “crooked” Prover eP) causes the Veriﬁer to accept with high probability.
We may amplify the success probability of an interactive proof system by
repetition, as we did in Lemma 10.5, to make the error probability exponentially
small. Obviously, IP contains both the classes NP and BPP. We have also shown
that it contains the language NONISO, which is not known to be in either NP
or BPP. As we will next show, IP is a surprisingly large class, equal to the class
PSPACE.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

418
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
IP = PSPACE
In this section, we prove one of the more remarkable theorems in complexity
theory: the equality of the classes IP and PSPACE. Thus, for any language in
PSPACE, a Prover can convince a probabilistic polynomial time Veriﬁer about
the membership of a string in the language, even though a conventional proof
of membership might be exponentially long.
THEOREM
10.29
IP = PSPACE.
We divide the proof of this theorem into lemmas that establish containment
in each direction. The ﬁrst lemma shows IP ⊆PSPACE. Though a bit tech-
nical, the proof of this lemma is a standard simulation of an interactive proof
system by a polynomial space machine.
LEMMA
10.30
IP ⊆PSPACE.
PROOF
Let A be a language in IP. Assume that A’s Veriﬁer V exchanges
exactly p = p(n) messages when the input w has length n. We construct a
PSPACE machine that simulates V . First, for any string w, we deﬁne
Pr

V accepts w

= max
P
Pr

V ↔P accepts w

.
This value is at least 2
3 if w is in A, and is at most 1
3 if not. We show how
to calculate this value in polynomial space. Let Mj denote a message history
m1# · · · #mj. We generalize the deﬁnition of the interaction of V and P to start
with an arbitrary message stream Mj. We write (V ↔P)(w, r, Mj) = accept if
we can extend Mj with messages mj+1 through mp so that
1. for 0 ≤i < p, where i is an even number, V (w, r, m1# · · · #mi) = mi+1;
2. for j ≤i < p, where i is an odd number, P(w, m1# · · · #mi) = mi+1; and
3. the ﬁnal message mp in the message history is accept.
Observe that these conditions require that V ’s messages be consistent with the
messages already present in Mj. Further generalizing our earlier deﬁnitions, we
deﬁne
Pr

V ↔P accepts w starting at Mj

= Prr

(V ↔P)(w, r, Mj) = accept

.
Here, and for the remainder of this proof, the notation Prr means that the prob-
ability is taken over all strings r that are consistent with Mj. If no such r exist,
then deﬁne the probability to be 0. We then deﬁne
Pr

V accepts w starting at Mj

= max
P
Pr

V ↔P accepts w starting at Mj

.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.4
INTERACTIVE PROOF SYSTEMS
419
For every 0 ≤j ≤p and every message stream Mj, let NMj be deﬁned
inductively for decreasing j, starting from the base cases at j = p. For a message
stream Mp that contains p messages, let NMp = 1 if Mp is consistent with V ’s
messages for some string r and mp = accept. Otherwise, let NMp = 0.
For j < p and a message stream Mj, deﬁne NMj as follows.
NMj =
(
maxmj+1 NMj+1
odd j < p
wt-avgmj+1 NMj+1
even j < p
Here, wt-avgmj+1 NMj+1 means P
mj+1
 Prr

V (w, r, Mj) = mj+1

· NMj+1

.
The expression is the average of NMj+1, weighted by the probability that the
Veriﬁer sent message mj+1.
Let M0 be the empty message stream. We make two claims about the value
NM0. First, we can calculate NM0 in polynomial space. We do so recursively by
calculating NMj for every j and Mj. Calculating maxmj+1 is straightforward. To
calculate wt-avgmj+1, we go through all strings r of length p, and eliminate those
that cause the Veriﬁer to produce an output that is inconsistent with Mj. If no
strings r remain, then wt-avgmj+1 is 0. If some strings remain, we determine the
fraction of the remaining strings r that cause the Veriﬁer to output mj+1. Then
we weight NMj+1 by that fraction to compute the average value. The depth of
the recursion is p, and therefore only polynomial space is needed.
Second, NM0 equals Pr

V accepts w

, the value needed in order to deter-
mine whether w is in A. We prove this second claim by induction as follows.
CLAIM
10.31
For every 0 ≤j ≤p and every Mj,
NMj = Pr

V accepts w starting at Mj

.
We prove this claim by induction on j, where the basis occurs at j = p and the
induction proceeds from p down to 0.
Basis: Prove the claim for j = p. We know that mp is either accept or reject. If
mp is accept, NMp is deﬁned to be 1, and Pr

V accepts w starting at Mj

= 1
because the message stream already indicates acceptance, so the claim is true.
The case when mp is reject is similar.
Induction step: Assume that the claim is true for some j+1 ≤p and any message
stream Mj+1. Prove that it is true for j and any message stream Mj. If j is even,
mj+1 is a message from V to P. We then have the series of equalities:
NMj
1=
X
mj+1
 Prr

V (w, r, Mj) = mj+1

· NMj+1

2=
X
mj+1
 Prr

V (w, r, Mj) = mj+1

· Pr

V accepts w starting at Mj+1

3= Pr

V accepts w starting at Mj

.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

420
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
Equality 1 is the deﬁnition of NMj. Equality 2 is based on the induction hypoth-
esis. Equality 3 follows from the deﬁnition of Pr

V accepts w starting at Mj

.
Thus, the claim holds if j is even. If j is odd, mj+1 is a message from P to V .
We then have the series of equalities:
NMj
1= max
mj+1 NMj+1
2= max
mj+1 Pr

V accepts w starting at Mj+1

3= Pr

V accepts w starting at Mj

.
Equality 1 is the deﬁnition of NMj. Equality 2 uses the induction hypothesis.
We break equality 3 into two inequalities. We have ≤because the Prover that
maximizes the lower line could send the message mj+1 that maximizes the up-
per line. We have ≥because that same Prover cannot do any better than send
that same message. Sending anything other than a message that maximizes the
upper line would lower the resulting value. That proves the claim for odd j and
completes one direction of the proof of Theorem 10.29.
Now we prove the other direction of the theorem. The proof of this lemma
introduces a novel algebraic method of analyzing computation.
LEMMA
10.32
PSPACE ⊆IP.
Before getting to the proof of this lemma, we prove a weaker result that il-
lustrates the technique. Deﬁne the counting problem for satisﬁability to be the
language
#SAT = {⟨φ, k⟩| φ is a cnf-formula with exactly k satisfying assignments}.
THEOREM
10.33
#SAT ∈IP.
PROOF IDEA
This proof presents a protocol whereby the Prover persuades
the Veriﬁer that k is the actual number of satisfying assignments of a given cnf-
formula φ. Before getting to the protocol itself, let’s consider another protocol
that has some of the ﬂavor of the correct one but is unsatisfactory because it
requires an exponential time Veriﬁer. Say that φ has variables x1 through xm.
Let fi be the function where for 0 ≤i ≤m and a1, . . . , ai ∈{0, 1}, we set
fi(a1, . . . , ai) equal to the number of satisfying assignments of φ such that each
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.4
INTERACTIVE PROOF SYSTEMS
421
xj = aj for j ≤i. The constant function f0() is the number of satisfying assign-
ments of φ. The function fm(a1, . . . , am) is 1 if those ai’s satisfy φ; otherwise, it
is 0. An easy identity holds for every i < m and a1, . . . , ai:
fi(a1, . . . , ai) = fi+1(a1, . . . , ai, 0) + fi+1(a1, . . . , ai, 1).
The protocol for #SAT begins with phase 0 and ends with phase m + 1. The
input is the pair ⟨φ, k⟩.
Phase 0.
P sends f0() to V .
V checks that k = f0() and rejects if not.
Phase 1.
P sends f1(0) and f1(1) to V .
V checks that f0() = f1(0) + f1(1) and rejects if not.
Phase 2.
P sends f2(0,0), f2(0,1), f2(1,0), and f2(1,1) to V .
V checks that f1(0) = f2(0,0)+f2(0,1) and f1(1) = f2(1,0)+f2(1,1) and rejects
if not.
...
Phase m.
P sends fm(a1, . . . , am) for each assignment to the ai’s.
V checks the 2m−1 equations linking fm−1 with fm and rejects if any fail.
Phase m+1.
V checks that the values fm(a1, . . . , am) are correct for each
assignment to the ai’s by evaluating φ on each assignment. If all assignments are
correct, V accepts; otherwise, V rejects. That completes the description of the
protocol.
This protocol doesn’t provide a proof that #SAT is in IP because the Veriﬁer
must spend exponential time just to read the exponentially long messages that
the Prover sends. Let’s examine it for correctness anyway because that helps us
understand the next, more efﬁcient protocol.
Intuitively, a protocol decides a language A if a Prover can convince the Ver-
iﬁer of the membership of strings in A. In other words, if a string is a member
of A, some Prover can cause the Veriﬁer to accept with high probability. If the
string isn’t a member of A, no Prover—not even a crooked or devious one—can
cause the Veriﬁer to accept with more than low probability. We use the symbol
P to designate the Prover that correctly follows the protocol, and that thereby
makes V accept with high probability when the input is in A. We use the sym-
bol eP to designate any Prover that interacts with the Veriﬁer when the input
isn’t in A. Think of eP as an adversary—as though eP were attempting to make
V accept when V should reject. The notation eP is suggestive of a “crooked”
Prover.
In the #SAT protocol we just described, the Veriﬁer ignores its random input
and operates deterministically once the Prover has been selected. To prove the
protocol is correct, we establish two facts. First, if k is the correct number of sat-
isfying assignments for φ in the input ⟨φ, k⟩, some Prover P causes V to accept.
The Prover that gives accurate responses at every phase does the job. Second, if
k isn’t correct, every Prover eP causes V to reject. We argue this case as follows.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

422
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
If k is not correct and eP gives accurate responses, V rejects outright in phase 0
because f0() is the number of φ’s satisfying assignments and therefore f0() ̸= k.
To prevent V from rejecting in phase 0, eP must send an incorrect value for f0(),
denoted ef0(). Intuitively, ef0() is a lie about the value of f0(). As in real life, lies
beget lies, and eP is forced to continue lying about other values of fi in order to
avoid being caught during later phases. Eventually these lies catch up with eP in
phase m + 1, where V checks the values of fm directly.
More precisely, because ef0() ̸= f0(), at least one of the values f1(0) and f1(1)
that eP sends in phase 1 must be incorrect; otherwise, V rejects when it checks
whether f0() = f1(0) + f1(1). Let’s say that f1(0) is incorrect and call the value
that is sent instead ef1(0). Continuing in this way, we see that at every phase
eP must end up sending some incorrect value efi(a1, . . . , ai), or V would have
rejected by that point. But when V checks the incorrect value efm(a1, . . . , am)
in phase m + 1, it rejects anyway. Thus, we have shown that if k is incorrect, V
rejects no matter what eP does. Therefore, the protocol is correct.
The problem with this protocol is that the number of messages doubles with
every phase. This doubling occurs because the Veriﬁer requires the two values
fi+1(. . . , 0) and fi+1(. . . , 1) to conﬁrm the one value fi(. . .). If we could ﬁnd
a way for the Veriﬁer to conﬁrm a value of fi with only a single value of fi+1,
the number of messages wouldn’t grow at all. We can do so by extending the
functions fi to non-Boolean inputs and conﬁrming the single value fi+1(. . . , z)
for some z selected at random from a ﬁnite ﬁeld.
PROOF
Let φ be a cnf-formula with variables x1 through xm. In a technique
called arithmetization, we associate with φ a polynomial p(x1, . . . , xm) where
p mimics φ by simulating the Boolean ∧, ∨, and ¬ operations with the arith-
metic operations + and × as follows. If α and β are subformulas, we replace
expressions
α ∧β
with
αβ,
¬α
with
1 −α, and
α ∨β
with
α ∗β = 1 −(1 −α)(1 −β).
One observation regarding p that will be important to us later is that the
degree of any of its variables is not large. The operations αβ and α ∗β each
produce a polynomial whose degree is at most the sum of the degrees of the
polynomials for α and β. Thus, the degree of any variable is at most n, the
length of φ.
If p’s variables are assigned Boolean values, it agrees with φ on that assign-
ment. Evaluating p when the variables are assigned non-Boolean values has no
obvious interpretation in φ. However, the proof uses such assignments anyway
to analyze φ, much as the proof of Theorem 10.13 uses non-Boolean assign-
ments to analyze read-once branching programs. The variables range over a
ﬁnite ﬁeld F with q elements, where q is at least 2n.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.4
INTERACTIVE PROOF SYSTEMS
423
We use p to redeﬁne the functions fi that we deﬁned in the proof idea section.
For 0 ≤i ≤m and for a1, . . . , ai ∈F, let
fi(a1, . . . , ai) =
X
ai+1,...,am∈{0,1}
p(a1, . . . , am).
Observe that this redeﬁnition extends the original deﬁnition because the two
agree when a1 through ai take on Boolean values. Thus, f0() is still the num-
ber of satisfying assignments of φ. Each of the functions fi(x1, . . . , xi) can be
expressed as a polynomial in x1 through xi. The degree of each of these poly-
nomials is at most that of p.
Next, we present the protocol for #SAT. Initially, V receives input ⟨φ, k⟩and
arithmetizes φ to obtain polynomial p. All arithmetic is done in the ﬁeld F with
q elements, where q is a prime that is larger than 2n. (Finding such a prime q
requires an extra step, but we ignore this point here because the proof we give
shortly of the stronger result IP = PSPACE doesn’t require it.) A comment in
double brackets appears at the start of the description of each phase.
Phase 0.
[[ P sends f0(). ]]
P→V : P sends f0() to V .
V checks that k = f0(). V rejects if that fails.
Phase 1.
[[ P persuades V that f0() is correct if f1(r1) is correct. ]]
P→V : P sends the coefﬁcients of f1(z) as a polynomial in z.
V uses these coefﬁcients to evaluate f1(0) and f1(1).
V checks that f0() = f1(0) + f1(1) and rejects if not.
(Remember that all calculations are done over F.)
V →P : V selects r1 at random from F and sends it to P.
Phase 2.
[[ P persuades V that f1(r1) is correct if f2(r1, r2) is correct. ]]
P→V : P sends the coefﬁcients of f2(r1, z) as a polynomial in z.
V uses these coefﬁcients to evaluate f2(r1, 0) and f2(r1, 1).
V checks that f1(r1) = f2(r1, 0) + f2(r1, 1) and rejects if not.
V →P : V selects r2 at random from F and sends it to P.
...
Phase i.
[[ P persuades V that fi−1(r1, . . . , ri−1) is correct if fi(r1, . . . , ri) is correct. ]]
P→V : P sends the coefﬁcients of fi(r1, . . . , ri−1, z) as a polynomial in z.
V uses these coefﬁcients to evaluate fi(r1, . . . , ri−1, 0) and fi(r1, . . . , ri−1, 1).
V checks that fi−1(r1, . . . , ri−1) = fi(r1, . . . , ri−1, 0) + fi(r1, . . . , ri−1, 1) and
rejects if not.
V →P : V selects ri at random from F and sends it to P.
...
Phase m+1.
[[ V checks directly that fm(r1, . . . , rm) is correct. ]]
V evaluates p(r1, . . . , rm) to compare with the value V has for fm(r1, . . . , rm).
If they are equal, V accepts; otherwise, V rejects.
That completes the description of the protocol.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

424
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
Now we show that this protocol decides #SAT. First, if φ has k satisfying
assignments, V obviously accepts with certainty if Prover P follows the protocol.
Second, we show that if φ doesn’t have k assignments, no Prover can make it
accept with more than a low probability. Let eP be any Prover.
To prevent V from rejecting outright, eP must send an incorrect value ef0()
for f0() in phase 0. Therefore, in phase 1, one of the values that V calculates
for f1(0) and f1(1) must be incorrect. Thus, the coefﬁcients that eP sent for
f1(z) as a polynomial in z must be wrong. Let ef1(z) be the function that these
coefﬁcients represent instead. Next comes a key step of the proof.
When V picks a random r1 in F, we claim that ef1(r1) is unlikely to equal
f1(r1). For n ≥10, we show that
Pr
 ef1(r1) = f1(r1)

< n−2.
That bound on the probability follows from Lemma 10.14: A polynomial in
a single variable of degree at most d can have no more than d roots, unless it
always evaluates to 0. Therefore, any two polynomials in a single variable of
degree at most d can agree in at most d places, unless they agree everywhere.
Recall that the degree of the polynomial for f1 is at most n, and that V rejects
if the degree of the polynomial eP sends for ef1 is greater than n. We have al-
ready determined that these functions don’t agree everywhere, so Lemma 10.14
implies they can agree in at most n places. The size of F is greater than 2n. The
chance that r1 happens to be one of the places where the functions agree is at
most n/2n, which is less than n−2 for n ≥10.
To recap what we’ve shown so far, if ef0() is wrong, ef1’s polynomial must be
wrong, and then ef1(r1) would likely be wrong by virtue of the preceding claim.
In the unlikely event that ef1(r1) agrees with f1(r1), eP was “lucky” at this phase
and it will be able to make V accept (even though V should reject) by following
the instructions for P in the rest of the protocol.
Continuing further with the argument, if ef1(r1) were wrong, at least one of
the values V computes for f2(r1, 0) and f2(r1, 1) in phase 2 must be wrong, so
the coefﬁcients that eP sent for f2(r1, z) as a polynomial in z must be wrong. Let
ef2(r1, z) be the function these coefﬁcients represent instead. The polynomials
for f2(r1, z) and ef2(r1, z) have degree at most n. So as before, the probability
that they agree at a random r2 in F is at most n−2. Thus, when V picks r2 at
random, ef2(r1, r2) is likely to be wrong.
The general case follows in the same way to show that for each 1 ≤i ≤m, if
efi−1(r1, . . . , ri−1) ̸= fi−1(r1, . . . , ri−1),
then for n ≥10 and for ri chosen at random in F,
Pr
 efi(r1, . . . , ri) = fi(r1, . . . , ri)

≤n−2.
Thus, by giving an incorrect value for f0(), eP is probably forced to give incor-
rect values for f1(r1), f2(r1, r2), and so on to fm(r1, . . . , rm). The probability
that eP gets lucky because V selects an ri, where efi(r1, . . . , ri) = fi(r1, . . . , ri)
even though efi and fi are different in some phase, is at most the number of
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.4
INTERACTIVE PROOF SYSTEMS
425
phases m times n−2 or at most 1/n. If eP never gets lucky, it eventually sends
an incorrect value for fm(r1, . . . , rm). But V checks that value of fm directly
in phase m + 1 and will catch any error at that point. So if k is not the num-
ber of satisfying assignments of φ, no Prover can make the Veriﬁer accept with
probability greater than 1/n.
To complete the proof of the theorem, we need only show that the Veriﬁer
operates in probabilistic polynomial time, which is obvious from its description.
Next, we return to the proof of Lemma 10.32, that PSPACE ⊆IP. The
proof is similar to that of Theorem 10.33 except for an additional idea used here
to lower the degrees of polynomials that occur in the protocol.
PROOF IDEA
Let’s ﬁrst try the idea we used in the preceding proof and de-
termine where the difﬁculty occurs. To show that every language in PSPACE is
in IP, we need only show that the PSPACE-complete language TQBF is in IP.
Let ψ be a quantiﬁed Boolean formula of the form
ψ = Q1x1 Q2x2 · · · Qmxm [ φ ],
where φ is a cnf-formula and each Qi is ∃or ∀. We deﬁne functions fi as before,
except that now we take the quantiﬁers into account. For 0 ≤i ≤m and
a1, . . . , am ∈{0, 1}, let
fi(a1, . . . , ai) =
(
1
if Qi+1xi+1 · · · Qmxm [ φ(a1, . . . , ai) ] is true;
0
otherwise,
where φ(a1, . . . , ai) is φ with a1 through ai substituted for x1 through xi. Thus,
f0() is the truth value of ψ. We then have the arithmetic identities
Qi+1 = ∀:
fi(a1, . . . , ai) = fi+1(a1, . . . , ai, 0) · fi+1(a1, . . . , ai, 1)
and
Qi+1 = ∃:
fi(a1, . . . , ai) = fi+1(a1, . . . , ai, 0) ∗fi+1(a1, . . . , ai, 1).
Recall that we deﬁned x ∗y to be 1 −(1 −x)(1 −y).
A natural variation of the protocol for #SAT suggests itself where we extend
the fi’s to a ﬁnite ﬁeld and use the identities for quantiﬁers instead of the identi-
ties for summation. The problem with this idea is that when arithmetized, every
quantiﬁer may double the degree of the resulting polynomial. The degrees of
the polynomials might then grow exponentially large, which would require the
Veriﬁer to run for exponential time to process the exponentially many coefﬁ-
cients that the Prover would need to send to describe the polynomials.
To keep the degrees of the polynomials small, we introduce a reduction oper-
ation R that reduces the degrees of polynomials without changing their behavior
on Boolean inputs.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

426
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
PROOF
Let ψ = Qx1 · · · Qxm [ φ ] be a quantiﬁed Boolean formula, where φ
is a cnf-formula. To arithmetize ψ, we introduce the expression
ψ′ = Qx1 Rx1 Qx2 Rx1Rx2 Qx3 Rx1Rx2Rx3 · · · Qxm Rx1 · · · Rxm [ φ ].
Don’t worry about the meaning of Rxi for now. It is useful only for deﬁning the
functions fi. We rewrite ψ′ as
ψ′ = S1y1 S2y2 · · · Skyk [ φ ],
where each Si ∈{∀, ∃, R} and yi ∈{x1, . . . , xm}.
For each i ≤k, we deﬁne the function fi. We deﬁne fk(x1, . . . , xm) to be the
polynomial p(x1, . . . , xm) obtained by arithmetizing φ. For i < k, we deﬁne fi
in terms of fi+1:
Si+1 = ∀:
fi(. . .) = fi+1(. . . , 0) · fi+1(. . . , 1);
Si+1 = ∃:
fi(. . .) = fi+1(. . . , 0) ∗fi+1(. . . , 1);
Si+1 = R:
fi(. . . , a) = (1−a)fi+1(. . . , 0) + afi+1(. . . , 1).
If Si+1 is ∀or ∃, fi has one fewer input variable than fi+1 does. If Si+1 is R,
the two functions have the same number of input variables. Thus, function fi
will not, in general, depend on i variables. To avoid cumbersome subscripts, we
use “. . .” in place of a1 through aj for the appropriate values of j. Furthermore,
we reorder the inputs to the functions so that input variable yi+1 is the last
argument.
Note that the Rx operation on polynomials doesn’t change their values on
Boolean inputs. Therefore, f0() is still the truth value of ψ. However, note that
the Rx operation produces a result that is linear in x. We added Rx1 · · · Rxi
after Qixi in ψ′ in order to reduce the degree of each variable to 1 prior to the
squaring due to arithmetizing Qi.
Now we are ready to describe the protocol. All arithmetic operations in this
protocol are over a ﬁeld F of size at least n4, where n is the length of ψ. V can
ﬁnd a prime of this size on its own, so P doesn’t need to provide one.
Phase 0.
[[ P sends f0(). ]]
P→V : P sends f0() to V .
V checks that f0() = 1 and rejects if not.
...
Phase i.
[[ P persuades V that fi−1(r1 · · · ) is correct if fi(r1 · · · , r) is correct. ]]
P→V : P sends the coefﬁcients of fi(r1 · · · , z) as a polynomial in z.
(Here r1 · · · denotes a setting of the variables to the previously selected random
values r1, r2, . . . .)
V uses these coefﬁcients to evaluate fi(r1 · · · , 0) and fi(r1 · · · , 1).
V checks that these identities hold:
fi−1(r1 · · · ) =
(
fi(r1 · · · , 0) · fi(r1 · · · , 1)
Si = ∀,
fi(r1 · · · , 0) ∗fi(r1 · · · , 1)
Si = ∃,
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.5
PARALLEL COMPUTATION
427
and
fi−1(r1 · · · , r) = (1 −r)fi(r1 · · · , 0) + rfi(r1 · · · , 1)
Si = R.
If not, V rejects.
V →P : V picks a random r in F and sends it to P.
(When Si = R, this r replaces the previous r.)
Go to Phase i + 1, where P must persuade V that fi(r1 · · · , r) is correct.
...
Phase k+1.
[[ V checks directly that fk(r1, . . . , rm) is correct. ]]
V evaluates p(r1, . . . , rm) to compare with the value V has for fk(r1, . . . , rm). If
they are equal, V accepts; otherwise, V rejects.
That completes the description of the protocol.
Proving the correctness of this protocol is similar to proving the correctness
of the #SAT protocol. Clearly, if ψ is true, P can follow the protocol and V
will accept. If ψ is false, eP must lie at phase 0 by sending an incorrect value for
f0(). At phase i, if V has an incorrect value for fi−1(r1 · · · ), one of the values
fi(r1 · · · , 0) and fi(r1 · · · , 1) must be incorrect and the polynomial for fi must
be incorrect. Consequently, for a random r, the probability that eP gets lucky
at this phase because fi(r1 · · · , r) is correct is at most the polynomial degree
divided by the ﬁeld size or n/n4. The protocol proceeds for O(n2) phases, so
the probability that eP gets lucky at some phase is at most 1/n. If eP is never
lucky, V will reject at phase k + 1.
10.5
PARALLEL COMPUTATION
A parallel computer is one that can perform multiple operations simultaneously.
Parallel computers may solve certain problems much faster than sequential com-
puters, which can only do a single operation at a time. In practice, the distinc-
tion between the two is slightly blurred because most real computers (including
“sequential” ones) are designed to use some parallelism as they execute individ-
ual instructions. We focus here on massive parallelism whereby a huge number
(think of millions or more) of processing elements are actively participating in a
single computation.
In this section, we brieﬂy introduce the theory of parallel computation. We
describe one model of a parallel computer and use it to give examples of cer-
tain problems that lend themselves well to parallelization. We also explore the
possibility that parallelism may not be suitable for certain other problems.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

428
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
UNIFORM BOOLEAN CIRCUITS
One of the most popular models in theoretical work on parallel algorithms is
called the Parallel Random Access Machine or PRAM. In the PRAM model,
idealized processors with a simple instruction set patterned on actual computers
interact via a shared memory. In this short section we can’t describe PRAMs
in detail. Instead, we use an alternative model of parallel computer that we
introduced for another purpose in Chapter 9: Boolean circuits.
Boolean circuits have certain advantages and disadvantages as a parallel com-
putation model. On the positive side, the model is simple to describe, which
makes proofs easier. Circuits also bear an obvious resemblance to actual hard-
ware designs, and in that sense the model is realistic. On the negative side,
circuits are awkward to “program” because the individual processors are so weak.
Furthermore, we disallow cycles in our deﬁnition of Boolean circuits, in contrast
to circuits that we can actually build.
In the Boolean circuit model of a parallel computer, we take each gate to be an
individual processor, so we deﬁne the processor complexity of a Boolean circuit
to be its size. We consider each processor to compute its function in a single
time step, so we deﬁne the parallel time complexity of a Boolean circuit to be its
depth, or the longest distance from an input variable to the output gate.
Any particular circuit has a ﬁxed number of input variables, so we use cir-
cuit families as deﬁned in Deﬁnition 9.27 for deciding languages. We need to
impose a technical requirement on circuit families so that they correspond to
parallel computation models such as PRAMs, where a single machine is capable
of handling all input lengths. That requirement states that we can easily ob-
tain all members in a circuit family. This uniformity requirement is reasonable
because knowing that a small circuit exists for deciding certain elements of a
language isn’t very useful if the circuit itself is hard to ﬁnd. That leads us to the
following deﬁnition.
DEFINITION
10.34
A family of circuits (C0, C1, C2, . . .) is uniform if some log space
transducer T outputs ⟨Cn⟩when T ’s input is 1n.
Recall that Deﬁnition 9.28 deﬁned the size and depth complexity of languages
in terms of families of circuits of minimal size and depth. Here, we consider
the simultaneous size and depth of a single circuit family in order to identify how
many processors we need in order to achieve a particular parallel time complexity
or vice versa. Say that a language has simultaneous size–depth circuit complexity
at most (f(n), g(n)) if a uniform circuit family exists for that language with size
complexity f(n) and depth complexity g(n).
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.5
PARALLEL COMPUTATION
429
EXAMPLE
10.35
Let A be the language over {0,1} consisting of all strings with an odd number
of 1s. We can test membership in A by computing the parity function. We can
implement the two-input parity gate x⊕y with the standard AND, OR, and NOT
operations as (x ∧¬y) ∨(¬x ∧y). Let the inputs to the circuit be x1, . . . , xn.
One way to get a circuit for the parity function is to construct gates gi whereby
g1 = x1 and gi = xi ⊕gi−1 for i ≤n. This construction uses O(n) size and
depth.
Example 9.29 described another circuit for the parity function with O(n) size
and O(log n) depth by constructing a binary tree of ⊕gates. This construc-
tion is a signiﬁcant improvement because it uses exponentially less parallel time
than does the preceding construction. Thus, the size–depth complexity of A is
(O(n), O(log n)).
EXAMPLE
10.36
Recall that we may use circuits to compute functions that output strings. Con-
sider the Boolean matrix multiplication function. The input has 2m2 = n
variables representing two m × m matrices A = {aik} and B = {bik}. The
output is m2 values representing the m × m matrix C = {cik}, where
cik =
_
j
 aij ∧bjk

.
The circuit for this function has gates gijk that compute aij ∧bjk for each i,
j, and k. Additionally, for each i and k, the circuit contains a binary tree of ∨
gates to compute W
j gijk. Each such tree contains m −1 OR gates and has log m
depth. Consequently, these circuits for Boolean matrix multiplication have size
O(m3) = O(n3/2) and depth O(log n).
EXAMPLE
10.37
If A = {aij} is an m× m matrix, we let the transitive closure of A be the matrix
A ∨A2 ∨· · · ∨Am,
where Ai is the matrix product of A with itself i times and ∨is the bitwise OR
of the matrix elements. The transitive closure operation is closely related to the
PATH problem and hence to the class NL. If A is the adjacency matrix of a
directed graph G, Ai is the adjacency matrix of the graph with the same nodes
in which an edge indicates the presence of a path of length i in G. The transitive
closure of A is the adjacency matrix of the graph in which an edge indicates the
presence of a path of any length in G.
We can represent the computation of Ai with a binary tree of size i and depth
log i wherein a node computes the product of the two matrices below it. Each
node is computed by a circuit of O(n3/2) size and logarithmic depth. Hence
the circuit computing Am has size O(n2) and depth O(log2 n). We make cir-
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

430
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
cuits for each Ai, which adds another factor of m to the size and an additional
layer of O(log n) depth. Hence the size–depth complexity of transitive closure is
(O(n5/2), O(log2 n)).
THE CLASS NC
Many interesting problems have size–depth complexity (O(nk), O(logk n)) for
some constant k. Such problems may be considered to be highly parallelizable
with a moderate number of processors. That prompts the following deﬁnition.
DEFINITION
10.38
For i ≥1, let NCi be the class of languages that can be decided
by a uniform3 family of circuits with polynomial size and O(logi n)
depth. Let NC be the class of languages that are in NCi for some i.
Functions that are computed by such circuit families are called NCi
computable or NC computable.4
We explore the relationship of these complexity classes with other classes of
languages we have encountered. First, we make a connection between Turing
machine space and circuit depth. Problems that are solvable in logarithmic depth
are also solvable in logarithmic space. Conversely, problems that are solvable in
logarithmic space, even nondeterministically, are solvable in logarithmic squared
depth.
THEOREM
10.39
NC1 ⊆L.
PROOF
We sketch a log space algorithm to decide a language A in NC1. On
input w of length n, the algorithm can construct the description as needed of
the nth circuit in the uniform circuit family for A. Then the algorithm can
evaluate the circuit by using a depth-ﬁrst search from the output gate. Memory
for this search is needed only to record the path to the currently explored gate,
and to record any partial results that have been obtained along that path. The
circuit has logarithmic depth; hence only logarithmic space is required by the
simulation.
3Deﬁning uniformity in terms of log space transducers is standard for NCi when i ≥
2, but gives a nonstandard result for NC1 (which contains the standard class NC1 as
a subset). We give this deﬁnition anyway because it is simpler and adequate for our
purposes.
4Steven Cook coined the name NC for “Nick’s class” because Nick Pippenger was the
ﬁrst person to recognize its importance.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.5
PARALLEL COMPUTATION
431
THEOREM
10.40
NL ⊆NC2.
PROOF IDEA
Compute the transitive closure of the graph of conﬁgurations
of an NL-machine. Output the position corresponding to the presence of a path
from the start conﬁguration to the accept conﬁguration.
PROOF
Let A be a language that is decided by an NL machine M, where
A has been encoded into the {0,1} alphabet. We construct a uniform circuit
family (C0, C1, . . .) for A. To get Cn, we construct a graph G that is similar to
the computation graph for M on an input w of length n. We do not know the
input w when we construct the circuit—only its length n. The inputs to the
circuit are variables w1 through wn—each corresponding to a position in the
input.
Recall that a conﬁguration of M on w describes the state, the contents of
the work tape, and the positions of both the input and the work tape heads, but
does not include w itself. Hence the collection of conﬁgurations of M on w
does not actually depend on w—only on w’s length n. These polynomially many
conﬁgurations form the nodes of G.
The edges of G are labeled with the input variables wi. If c1 and c2 are two
nodes of G, and c1 indicates input head position i, we put edge (c1, c2) in G with
label wi (or wi) if c1 can yield c2 in a single step when the input head is reading
a 1 (or 0), according to M’s transition function. If c1 can yield c2 in a single step,
whatever the input head is reading, we put that edge in G unlabeled.
If we set the edges of G according to a string w of length n, a path exists from
the start conﬁguration to the accepting conﬁguration if and only if M accepts
w. Hence a circuit that computes the transitive closure of G and outputs the
position indicating the presence of such a path accepts exactly those strings in A
of length n. That circuit has polynomial size and O(log2 n) depth.
A log space transducer is capable of constructing G and therefore Cn on input
1n. See Theorem 8.25 for a more detailed description of a similar log space
transducer.
The class of problems solvable in polynomial time includes all the problems
solvable in NC, as the following theorem shows.
THEOREM
10.41
NC ⊆P.
PROOF
A polynomial time algorithm can run the log space transducer to
generate circuit Cn and simulate it on an input of length n.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

432
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
P-COMPLETENESS
Now we consider the possibility that all problems in P are also in NC. Equal-
ity between these classes would be surprising because it would imply that all
polynomial time solvable problems are highly parallelizable. We introduce the
phenomenon of P-completeness to give theoretical evidence that some problems
in P are inherently sequential.
DEFINITION
10.42
A language B is P-complete if
1. B ∈P, and
2. every A in P is log space reducible to B.
The next theorem follows in the spirit of Theorem 8.23 and has a similar
proof because NC circuit families can compute log space reductions. We leave
its proof as Exercise 10.3.
THEOREM
10.43
If A ≤L B and B is in NC, then A is in NC.
We show that the problem of circuit evaluation is P-complete. For a circuit
C and input setting x, we write C(x) to be the value of C on x. Let
CIRCUIT-VALUE = {⟨C, x⟩| C is a Boolean circuit and C(x) = 1}.
THEOREM
10.44
CIRCUIT-VALUE is P-complete.
PROOF
The construction given in Theorem 9.30 shows how to reduce any
language A in P to CIRCUIT-VALUE. On input w, the reduction produces a
circuit that simulates the polynomial time Turing machine for A. The input to
the circuit is w itself. The reduction can be carried out in log space because the
circuit it produces has a simple and repetitive structure.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.6
CRYPTOGRAPHY
433
10.6
CRYPTOGRAPHY
The practice of encryption, using secret codes for private communication, dates
back thousands of years.
During Roman times, Julius Caesar encoded mes-
sages to his generals to protect against the possibility of interception. More
recently, Alan Turing, the inventor of the Turing machine, led a group of British
mathematicians who broke the German code used in World War II for sending
instructions to U-boats patrolling the Atlantic Ocean. Governments still depend
on secret codes and invest a great deal of effort in devising codes that are hard to
break, and in ﬁnding weaknesses in codes that others use. These days, corpora-
tions and individuals use encryption to increase the security of their information.
Soon, nearly all electronic communication will be cryptographically protected.
In recent years, computational complexity theory has led to a revolution in
the design of secret codes. The ﬁeld of cryptography, as this area is known,
now extends well beyond secret codes for private communication and addresses
a broad range of issues concerning the security of information. For example, we
now have the technology to digitally “sign” messages to authenticate the identity
of the sender; to allow electronic elections whereby participants can vote over a
network and the results can be publicly tallied without revealing any individual’s
vote, while preventing multiple voting and other violations; and to construct new
kinds of secret codes that do not require the communicators to agree in advance
on the encryption and decryption algorithms.
Cryptography is an important practical application of complexity theory.
Digital cellular telephones, direct satellite television broadcast, and electronic
commerce over the Internet all depend on cryptographic measures to protect
information. Such systems will soon play a role in most people’s lives. Indeed,
cryptography has stimulated much research in complexity theory and in other
mathematical ﬁelds.
SECRET KEYS
Traditionally, when a sender wants to encrypt a message so that only a certain
recipient can decrypt it, the sender and receiver share a secret key. The secret
key is a piece of information that is used by the encrypting and decrypting algo-
rithms. Maintaining the secrecy of the key is crucial to the security of the code
because any person with access to the key can encrypt and decrypt messages.
A key that is too short may be discovered through a brute-force search of the
entire space of possible keys. Even a somewhat longer key may be vulnerable
to certain kinds of attack—we say more about that shortly. The only way to
get perfect cryptographic security is with keys that are as long as the combined
length of all messages sent.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

434
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
A key that is as long as the combined message length is called a one-time pad.
Essentially, every bit of a one-time pad key is used just once to encrypt a bit of
the message, and then that bit of the key is discarded. The main problem with
one-time pads is that they may be rather large if a signiﬁcant amount of commu-
nication is anticipated. For most purposes, one-time pads are too cumbersome
to be considered practical.
A cryptographic code that allows an unlimited amount of secure communica-
tion with keys of only moderate length is preferable. Interestingly, such codes
can’t exist in principle but paradoxically are used in practice. This type of code
can’t exist in principle because a key that is signiﬁcantly shorter than the com-
bined message length can be found by a brute-force search through the space of
possible keys. Therefore, a code that is based on such keys is breakable in princi-
ple. But therein lies the solution to the paradox. A code could provide adequate
security in practice anyway because brute-force search is extremely slow when
the key is moderately long—say, in the range of 100 bits. Of course, if the code
could be broken in some other, fast way, it is insecure and shouldn’t be used.
The difﬁculty lies in being sure that the code can’t be broken quickly.
We currently have no way of ensuring that a code with moderate-length keys
is actually secure. To guarantee that a code can’t be broken quickly, we’d need a
mathematical proof that, at the very least, ﬁnding the key can’t be done quickly.
However, such proofs seem beyond the capabilities of contemporary mathemat-
ics! The reason is that once a key is discovered, verifying its correctness is easily
done by inspecting the messages that have been decrypted with it. Therefore,
the key veriﬁcation problem can be formulated so as to be in P. If we could
prove that keys can’t be found in polynomial time, we would achieve a major
mathematical advance by proving that P is different from NP.
Because we are unable to prove mathematically that codes are unbreakable,
we rely instead on circumstantial evidence. In the past, evidence of a code’s qual-
ity was obtained by hiring experts who tried to break it. If they were unable to do
so, conﬁdence in its security increased. That approach has obvious deﬁciencies.
If someone has better experts than ours, or if we can’t trust our own experts, the
integrity of our code may be compromised. Nonetheless, this approach was the
only one available until recently and was used to support the reliability of widely
used codes such as the Data Encryption Standard (DES) that was sanctioned by
the U.S. National Institute of Standards and Technology.
Complexity theory provides another way to gain evidence for a code’s secu-
rity. We may show that the complexity of breaking the code is linked to the
complexity of some other problem for which compelling evidence of intractabil-
ity is already available. Recall that we have used NP-completeness to provide
evidence that certain problems are intractable. Reducing an NP-complete prob-
lem to the code-breaking problem would show that the code-breaking problem
was itself NP-complete. However, that doesn’t provide sufﬁcient evidence of
security because NP-completeness concerns worst-case complexity. A problem
may be NP-complete, yet easy to solve most of the time. Codes must almost al-
ways be difﬁcult to break, so we need to measure average-case complexity rather
than worst-case complexity.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.6
CRYPTOGRAPHY
435
One problem that is generally believed to be difﬁcult for the average case is
the problem of integer factorization. Top mathematicians have been interested
in factorization for centuries, but no one has yet discovered a fast procedure for
doing so. Certain modern codes have been built around the factoring problem
so that breaking the code corresponds to factoring a number. That constitutes
convincing evidence for the security of these codes because an efﬁcient way of
breaking such a code would lead to a fast factoring algorithm, which would be a
remarkable development in computational number theory.
PUBLIC-KEY CRYPTOSYSTEMS
Even when cryptographic keys are moderately short, their management still
presents an obstacle to their widespread use in conventional cryptography. One
problem is that every pair of parties that desires private communication needs to
establish a joint secret key for this purpose. Another problem is that each indi-
vidual needs to keep a secret database of all keys that have been so established.
The recent development of public-key cryptography provides an elegant solu-
tion to both problems. In a conventional or private-key cryptosystem, the same
key is used for both encryption and decryption. Compare that with the novel
public-key cryptosystem for which the decryption key is different from, and not
easily computed from, the encryption key.
Although it is a deceptively simple idea, separating the two keys has profound
consequences. Now each individual only needs to establish a single pair of keys:
an encryption key E and a decryption key D. The individual keeps D secret
but publicizes E. If another individual wants to send him a message, she looks
up E in the public directory, encrypts the message with it, and sends it to him.
The ﬁrst individual is the only one who knows D, so only he can decrypt that
message.
Certain public-key cryptosystems can also be used for digital signatures. If
an individual applies his secret decryption algorithm to a message before send-
ing it, anyone can check that it actually came from him by applying the public
encryption algorithm. He has thus effectively “signed” that message. This ap-
plication assumes that the encryption and decryption functions may be applied
in either order, as is the case with the RSA cryptosystem.
ONE-WAY FUNCTIONS
Now we brieﬂy investigate some of the theoretical underpinnings of the modern
theory of cryptography, called one-way functions and trapdoor functions. One of the
advantages of using complexity theory as a foundation for cryptography is that
it helps to clarify the assumptions being made when we argue about security. By
assuming the existence of a one-way function, we may construct secure private-
key cryptosystems. Assuming the existence of trapdoor functions allows us to
construct public-key cryptosystems. Both assumptions have additional theoret-
ical and practical consequences. We deﬁne these types of functions after some
preliminaries.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

436
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
A function f : Σ∗−→Σ∗is length-preserving if the lengths of w and f(w) are
equal for every w. A length-preserving function is a permutation if it never maps
two strings to the same place; that is, if f(x) ̸= f(y) whenever x ̸= y.
Recall the deﬁnition of a probabilistic Turing machine given in Section 10.2.
Let’s say that a probabilistic Turing machine M computes a probabilistic func-
tion M : Σ∗−→Σ∗, where if w is an input and x is an output, we assign
Pr

M(w) = x

to be the probability that M halts in an accept state with x on its tape when it is
started on input w. Note that M may sometimes fail to accept on input w, so
X
x∈Σ∗
Pr

M(w) = x

≤1.
Next, we get to the deﬁnition of a one-way function. Roughly speaking, a
function is one-way if it is easy to compute but nearly always hard to invert. In
the following deﬁnition, f denotes the easily computed one-way function and
M denotes the probabilistic polynomial time algorithm that we may think of as
trying to invert f. We deﬁne one-way permutations ﬁrst because that case is
somewhat simpler.
DEFINITION
10.45
A one-way permutation is a permutation f with the following two
properties.
1. It is computable in polynomial time.
2. For every probabilistic polynomial time TM M, every k, and
sufﬁciently large n, if we pick a random w of length n and run
M on input f(w),
PrM,w

M(f(w)) = w

≤n−k.
Here, PrM,w means that the probability is taken over the ran-
dom choices made by M and the random selection of w.
A one-way function is a length-preserving function f with the fol-
lowing two properties.
1. It is computable in polynomial time.
2. For every probabilistic polynomial time TM M, every k, and
sufﬁciently large n, if we pick a random w of length n and run
M on input f(w),
PrM,w

M(f(w)) = y, where f(y) = f(w)

≤n−k.
For one-way permutations, any probabilistic polynomial time algorithm has
only a small probability of inverting f; that is, it is unlikely to compute w from
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

10.6
CRYPTOGRAPHY
437
f(w). For one-way functions, any probabilistic polynomial time algorithm is
unlikely to be able to ﬁnd any y that maps to f(w).
EXAMPLE
10.46
The multiplication function mult is a candidate for a one-way function. We let
Σ = {0,1}; and for any w ∈Σ∗, we let mult(w) be the string representing the
product of the ﬁrst and second halves of w. Formally,
mult(w) = w1 · w2,
where w = w1w2 such that |w1| = |w2|, or |w1| = |w2| + 1 if |w| is odd. The
strings w1 and w2 are treated as binary numbers. We pad mult(w) with leading
0s so that it has the same length as w. Despite a great deal of research into
the integer factorization problem, no probabilistic polynomial time algorithm is
known that can invert mult, even on a polynomial fraction of inputs.
If we assume the existence of a one-way function, we may construct a private-
key cryptosystem that is provably secure. That construction is too complicated
to present here. Instead, we illustrate how to implement a different crypto-
graphic application with a one-way function.
One simple application of a one-way function is a provably secure password
system. In a typical password system, a user must enter a password to gain ac-
cess to some resource. The system keeps a database of users’ passwords in an
encrypted form. The passwords are encrypted to protect them if the database
is left unprotected either by accident or design. Password databases are often
left unprotected so that various application programs can read them and check
passwords. When a user enters a password, the system checks it for validity by
encrypting it to determine whether it matches the version stored in the database.
Obviously, an encryption scheme that is difﬁcult to invert is desirable because it
makes the unencrypted password difﬁcult to obtain from the encrypted form. A
one-way function is a natural choice for a password encryption function.
TRAPDOOR FUNCTIONS
We don’t know whether the existence of a one-way function alone is enough to
allow the construction of a public-key cryptosystem. To get such a construction,
we use a related object called a trapdoor function, which can be efﬁciently inverted
in the presence of special information.
First, we need to discuss the notion of a function that indexes a family of
functions. If we have a family of functions {fi} for i in Σ∗, we can represent
them by the single function f : Σ∗× Σ∗−→Σ∗, where f(i, w) = fi(w) for any i
and w. We call f an indexing function. Say that f is length-preserving if each of
the indexed functions fi is length preserving.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

438
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
DEFINITION
10.47
A trapdoor function f : Σ∗× Σ∗−→Σ∗is a length-preserving in-
dexing function that has an auxiliary probabilistic polynomial time
TM G and an auxiliary function h: Σ∗× Σ∗−→Σ∗. The trio f, G,
and h satisfy the following three conditions.
1. Functions f and h are computable in polynomial time.
2. For every probabilistic polynomial time TM E, and every k
and sufﬁciently large n, if we take a random output ⟨i, t⟩of G
on 1n and a random w ∈Σn, then
PrE,w

E(i, fi(w)) = y, where fi(y) = fi(w)

≤n−k.
3. For every n, every w of length n, and every output ⟨i, t⟩of G
that occurs with nonzero probability for some input to G,
h(t, fi(w)) = y, where fi(y) = fi(w).
The probabilistic TM G generates an index i of a function in the index family
while simultaneously generating a value t that allows fi to be inverted quickly.
Condition 2 says that fi is hard to invert in the absence of t. Condition 3 says
that fi is easy to invert when t is known. Function h is the inverting function.
EXAMPLE
10.48
Here, we describe the trapdoor function that underlies the well-known RSA
cryptosystem. We give its associated trio f, G, and h. The generator machine
G operates as follows. On input 1n, it selects two numbers of size n at random
and tests them for primality. If they aren’t prime, it repeats the selection until it
succeeds or until it reaches a prespeciﬁed timeout limit and reports failure. After
ﬁnding p and q, it computes N = pq and the value φ(N) = (p −1)(q −1). It se-
lects a random number e between 1 and φ(N), and checks whether that number
is relatively prime to φ(N). If not, the algorithm selects another number and re-
peats the check. Finally, the algorithm computes the multiplicative inverse d of e
modulo φ(N). Doing so is possible because the set of numbers in {1, . . ., φ(N)}
that are relatively prime to φ(N) forms a group under the operation of multipli-
cation modulo φ(N). Finally, G outputs ((N, e), d). The index to the function f
consists of the two numbers N and e. Let
fN,e(w) = we mod N.
The inverting function h is
h(d, x) = xd mod N.
Function h properly inverts because h(d, fN,e(w)) = wed mod N = w.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

EXERCISES
439
We can use a trapdoor function such as the RSA trapdoor function to con-
struct a public-key cryptosystem as follows. The public key is the index i gener-
ated by the probabilistic machine G. The secret key is the corresponding value t.
The encryption algorithm breaks the message m into blocks of size at most
log N. For each block w, the sender computes fi. The resulting sequence of
strings is the encrypted message. The receiver uses the function h to obtain the
original message from its encryption.
EXERCISES
10.1 Show that a circuit family with depth O(log n) is also a polynomial size circuit
family.
10.2 Show that 12 is not pseudoprime because it fails some Fermat test.
10.3 Prove that if A ≤L B and B is in NC, then A is in NC.
10.4 Show that the parity function with n inputs can be computed by a branching pro-
gram that has O(n) nodes.
10.5 Show that the majority function with n inputs can be computed by a branching
program that has O(n2) nodes.
10.6 Show that any function with n inputs can be computed by a branching program
that has O(2n) nodes.
A10.7 Show that BPP ⊆PSPACE.
PROBLEMS
10.8 Let A be a regular language over {0,1}. Show that A has size–depth complexity
(O(n), O(log n)).
⋆10.9 A Boolean formula is a Boolean circuit wherein every gate has only one output
wire. The same input variable may appear in multiple places of a Boolean formula.
Prove that a language has a polynomial size family of formulas iff it is in NC1.
Ignore uniformity considerations.
⋆10.10 A k-head pushdown automaton (k-PDA) is a deterministic pushdown automaton
with k read-only, two-way input heads and a read/write stack. Deﬁne the class
PDAk = {A| A is recognized by a k-PDA}. Show that P = S
k PDAk. (Hint:
Recall that P equals alternating log space.)
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

440
CHAPTER 10 / ADVANCED TOPICS IN COMPLEXITY THEORY
10.11 Let M be a probabilistic polynomial time Turing machine, and let C be a language
where for some ﬁxed 0 < ϵ1 < ϵ2 < 1,
a. w ̸∈C implies Pr[M accepts w] ≤ϵ1, and
b. w ∈C implies Pr[M accepts w] ≥ϵ2.
Show that C ∈BPP. (Hint: Use the result of Lemma 10.5.)
10.12 Show that if P = NP, then P = PH.
10.13 Show that if PH = PSPACE, then the polynomial time hierarchy has only ﬁnitely
many distinct levels.
10.14 Recall that NPSAT is the class of languages that are decided by nondeterminis-
tic polynomial time Turing machines with an oracle for the satisﬁability problem.
Show that NPSAT = Σ2P.
⋆10.15 Prove Fermat’s little theorem, which is given in Theorem 10.6. (Hint: Consider
the sequence a1, a2, . . . . What must happen, and how?)
A⋆10.16 Prove that for any integer p > 1, if p isn’t pseudoprime, then p fails the Fermat test
for at least half of all numbers in Z+
p .
10.17 Prove that if A is a language in L, a family of branching programs (B1, B2, . . .)
exists wherein each Bn accepts exactly the strings in A of length n and is bounded
in size by a polynomial in n.
10.18 Prove that if A is a regular language, a family of branching programs (B1, B2, . . .)
exists wherein each Bn accepts exactly the strings in A of length n and is bounded
in size by a constant times n.
10.19 Show that if NP ⊆BPP, then NP = RP.
10.20 Deﬁne a ZPP-machine to be a probabilistic Turing machine that is permitted
three types of output on each of its branches: accept, reject, and ?. A ZPP-machine
M decides a language A if M outputs the correct answer on every input string w
(accept if w ∈A and reject if w ̸∈A) with probability at least 2
3, and M never
outputs the wrong answer. On every input, M may output ? with probability at
most 1
3. Furthermore, the average running time over all branches of M on w must
be bounded by a polynomial in the length of w. Show that RP ∩coRP = ZPP,
where ZPP is the collection of languages that are recognized by ZPP-machines.
10.21 Let EQBP = {⟨B1, B2⟩| B1 and B2 are equivalent branching programs}. Show
that EQBP is coNP-complete.
10.22 Let BPL be the collection of languages that are decided by probabilistic log space
Turing machines with error probability 1
3. Prove that BPL ⊆P.
10.23 Let CNFH = {⟨φ⟩| φ is a satisﬁable cnf-formula where each clause contains any
number of literals, but at most one negated literal}. Problem 7.25 asked you to
show that CNFH ∈P. Now give a log-space reduction from CIRCUIT-VALUE to
CNFH to conclude that CNFH is P-complete.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

SELECTED SOLUTIONS
441
SELECTED SOLUTIONS
10.7
If M is a probabilistic TM that runs in polynomial time, we can modify M so that
it makes exactly nr coin tosses on each branch of its computation, for some con-
stant r. Thus, the problem of determining the probability that M accepts its input
string reduces to counting how many branches are accepting and comparing this
number with 2
32(nr). This count can be performed by using polynomial space.
10.16
Call a a witness if it fails the Fermat test for p; that is, if ap−1 ̸≡1 (mod p).
Let Z∗
p be all numbers in {1, . . . , p −1} that are relatively prime to p. If p isn’t
pseudoprime, it has a witness a in Z∗
p.
Use a to get many more witnesses. Find a unique witness in Z∗
p for each non-
witness.
If d ∈Z∗
p is a nonwitness, you have dp−1 ≡1 (mod p).
Hence
(da mod p)p−1 ̸≡1 (mod p) and so da mod p is a witness. If d1 and d2 are distinct
nonwitnesses in Z∗
p, then d1a mod p ̸= d2a mod p. Otherwise, (d1 −d2)a ≡0
(mod p), and thus (d1 −d2)a = cp for some integer c. But d1 and d2 are in Z∗
p,
and thus (d1 −d2) < p, so a = cp/(d1 −d2) and p have a factor greater than 1
in common, which is impossible because a and p are relatively prime. Thus, the
number of witnesses in Z∗
p must be as large as the number of nonwitnesses in Z∗
p,
and consequently at least half of the members of Z∗
p are witnesses.
Next, show that every member b of Z+
p that is not relatively prime to p is a witness.
If b and p share a factor, then be and p share that factor for any e > 0. Hence
bp−1 ̸≡1 (mod p). Therefore, you can conclude that at least half of the members
of Z+
p are witnesses.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Selected Bibliography
1. ADLEMAN, L. Two theorems on random polynomial time. In Proceedings
of the Nineteenth IEEE Symposium on Foundations of Computer Science (1978),
75–83.
2. ADLEMAN, L. M., AND HUANG, M. A. Recognizing primes in random
polynomial time. In Proceedings of the Nineteenth Annual ACM Symposium on
the Theory of Computing (1987), 462–469.
3. ADLEMAN, L. M., POMERANCE, C., AND RUMELY, R. S. On distinguish-
ing prime numbers from composite numbers.
Annals of Mathematics 117
(1983), 173–206.
4. AGRAWAL, M., KAYAL, N., AND SAXENA, N. PRIMES is in P. The Annals
of Mathematics, Second Series, vol. 160, no. 2 (2004), 781–793.
5. AHO, A. V., HOPCROFT, J. E., AND ULLMAN, J. D. Data Structures and
Algorithms. Addison-Wesley, 1982.
6. AHO, A. V., SETHI, R., AND ULLMAN, J. D. Compilers: Principles, Tech-
niques, Tools. Addison-Wesley, 1986.
7. AKL, S. G. The Design and Analysis of Parallel Algorithms. Prentice-Hall
International, 1989.
8. ALON, N., ERD ¨OS, P., AND SPENCER, J. H. The Probabilistic Method. John
Wiley & Sons, 1992.
9. ANGLUIN, D., AND VALIANT, L. G.
Fast probabilistic algorithms for
Hamiltonian circuits and matchings. Journal of Computer and System Sciences
18 (1979), 155–193.
10. ARORA, S., LUND, C., MOTWANI, R., SUDAN, M., AND SZEGEDY, M.
Proof veriﬁcation and hardness of approximation problems. In Proceedings
of the Thirty-third IEEE Symposium on Foundations of Computer Science (1992),
14–23.
11. BAASE, S. Computer Algorithms: Introduction to Design and Analysis. Addison-
Wesley, 1978.
12. BABAI, L. E-mail and the unexpected power of interaction. In Proceedings of
the Fifth Annual Conference on Structure in Complexity Theory (1990), 30–44.
13. BACH, E., AND SHALLIT, J. Algorithmic Number Theory, Vol. 1. MIT Press,
1996.
443
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

444
14. BALC ´AZAR, J. L., D´IAZ, J., AND GABARR ´O, J. Structural Complexity I, II.
EATCS Monographs on Theoretical Computer Science. Springer Verlag,
1988 (I) and 1990 (II).
15. BEAME, P. W., COOK, S. A., AND HOOVER, H. J. Log depth circuits for
division and related problems. SIAM Journal on Computing 15, 4 (1986),
994–1003.
16. BLUM, M., CHANDRA, A., AND WEGMAN, M. Equivalence of free boolean
graphs can be decided probabilistically in polynomial time. Information Pro-
cessing Letters 10 (1980), 80–82.
17. BRASSARD, G., AND BRATLEY, P. Algorithmics: Theory and Practice. Pren-
tice-Hall, 1988.
18. CARMICHAEL, R. D. On composite numbers p which satisfy the Fermat
congruence aP −1 ≡P
mod P. American Mathematical Monthly 19 (1912),
22–27.
19. CHOMSKY, N. Three models for the description of language. IRE Trans. on
Information Theory 2 (1956), 113–124.
20. COBHAM, A. The intrinsic computational difﬁculty of functions. In Pro-
ceedings of the International Congress for Logic, Methodology, and Philosophy of
Science, Y. Bar-Hillel, Ed., North-Holland, 1964, 24–30.
21. COOK, S. A. The complexity of theorem-proving procedures. In Proceedings
of the Third Annual ACM Symposium on the Theory of Computing (1971), 151–
158.
22. CORMEN, T., LEISERSON, C., AND RIVEST, R. Introduction to Algorithms.
MIT Press, 1989.
23. EDMONDS, J. Paths, trees, and ﬂowers. Canadian Journal of Mathematics 17
(1965), 449–467.
24. ENDERTON, H. B. A Mathematical Introduction to Logic. Academic Press,
1972.
25. EVEN, S. Graph Algorithms. Pitman, 1979.
26. FELLER, W. An Introduction to Probability Theory and Its Applications, Vol. 1.
John Wiley & Sons, 1970.
27. FEYNMAN, R. P., HEY, A. J. G., AND ALLEN, R. W. Feynman lectures on
computation. Addison-Wesley, 1996.
28. GAREY, M. R., AND JOHNSON, D. S. Computers and Intractability—A Guide
to the Theory of NP-completeness. W. H. Freeman, 1979.
29. GILL, J. T. Computational complexity of probabilistic Turing machines.
SIAM Journal on Computing 6, 4 (1977), 675–695.
30. G ¨ODEL, K. On formally undecidable propositions in Principia Mathematica
and related systems I. In The Undecidable, M. Davis, Ed., Raven Press, 1965,
4–38.
31. GOEMANS, M. X., AND WILLIAMSON, D. P. .878-approximation algo-
rithms for MAX CUT and MAX 2SAT. In Proceedings of the Twenty-sixth
Annual ACM Symposium on the Theory of Computing (1994), 422–431.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

445
32. GOLDWASSER, S., AND MICALI, S. Probabilistic encryption. Journal of
Computer and System Sciences (1984), 270–299.
33. GOLDWASSER, S., MICALI, S., AND RACKOFF, C. The knowledge com-
plexity of interactive proof-systems.
SIAM Journal on Computing (1989),
186–208.
34. GREENLAW, R., HOOVER, H. J., AND RUZZO, W. L. Limits to Parallel
Computation: P-completeness Theory. Oxford University Press, 1995.
35. HARARY, F. Graph Theory, 2d ed. Addison-Wesley, 1971.
36. HARTMANIS, J., AND STEARNS, R. E. On the computational complexity
of algorithms. Transactions of the American Mathematical Society 117 (1965),
285–306.
37. HILBERT, D.
Mathematical problems. Lecture delivered before the In-
ternational Congress of Mathematicians at Paris in 1900. In Mathematical
Developments Arising from Hilbert Problems, vol. 28. American Mathematical
Society, 1976, 1–34.
38. HOFSTADTER, D. R. Goedel, Escher, Bach: An Eternal Golden Braid. Basic
Books, 1979.
39. HOPCROFT, J. E., AND ULLMAN, J. D. Introduction to Automata Theory,
Languages and Computation. Addison-Wesley, 1979.
40. IMMERMAN, N. Nondeterminstic space is closed under complement. SIAM
Journal on Computing 17 (1988), 935–938.
41. JOHNSON, D. S. The NP-completeness column: Interactive proof systems
for fun and proﬁt. Journal of Algorithms 9, 3 (1988), 426–444.
42. KARP, R. M. Reducibility among combinatorial problems. In Complexity
of Computer Computations (1972), R. E. Miller and J. W. Thatcher, Eds.,
Plenum Press, 85–103.
43. KARP, R. M., AND LIPTON, R. J. Turing machines that take advice. EN-
SEIGN: L’Enseignement Mathematique Revue Internationale 28 (1982).
44. KNUTH, D. E. On the translation of languages from left to right. Informa-
tion and Control (1965), 607–639.
45. LAWLER, E. L. Combinatorial Optimization: Networks and Matroids. Holt,
Rinehart and Winston, 1991.
46. LAWLER, E. L., LENSTRA, J. K., RINOOY KAN, A. H. G., AND SHMOYS,
D. B. The Traveling Salesman Problem. John Wiley & Sons, 1985.
47. LEIGHTON, F. T. Introduction to Parallel Algorithms and Architectures: Array,
Trees, Hypercubes. Morgan Kaufmann, 1991.
48. LEVIN, L. Universal search problems (in Russian). Problemy Peredachi Infor-
matsii 9, 3 (1973), 115–116.
49. LEWIS, H., AND PAPADIMITRIOU, C. Elements of the Theory of Computation.
Prentice-Hall, 1981.
50. LI, M., AND VITANYI, P. Introduction to Kolmogorov Complexity and its Appli-
cations. Springer-Verlag, 1993.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

446
51. LICHTENSTEIN, D., AND SIPSER, M. GO is PSPACE hard. Journal of the
ACM (1980), 393–401.
52. LUBY, M. Pseudorandomness and Cryptographic Applications. Princeton Uni-
versity Press, 1996.
53. LUND, C., FORTNOW, L., KARLOFF, H., AND NISAN, N. Algebraic meth-
ods for interactive proof systems. Journal of the ACM 39, 4 (1992), 859–868.
54. MILLER, G. L. Riemann’s hypothesis and tests for primality. Journal of
Computer and System Sciences 13 (1976), 300–317.
55. NIVEN, I., AND ZUCKERMAN, H. S. An Introduction to the Theory of Num-
bers, 4th ed. John Wiley & Sons, 1980.
56. PAPADIMITRIOU, C. H. Computational Complexity. Addison-Wesley, 1994.
57. PAPADIMITRIOU, C. H., AND STEIGLITZ, K. Combinatorial Optimization
(Algorithms and Complexity). Prentice-Hall, 1982.
58. PAPADIMITRIOU, C. H., AND YANNAKAKIS, M. Optimization, approxi-
mation, and complexity classes. Journal of Computer and System Sciences 43, 3
(1991), 425–440.
59. POMERANCE, C. On the distribution of pseudoprimes. Mathematics of Com-
putation 37, 156 (1981), 587–593.
60. PRATT, V. R. Every prime has a succinct certiﬁcate. SIAM Journal on Com-
puting 4, 3 (1975), 214–220.
61. RABIN, M. O. Probabilistic algorithms. In Algorithms and Complexity: New
Directions and Recent Results, J. F. Traub, Ed., Academic Press (1976) 21–39.
62. REINGOLD, O. Undirected st-connectivity in log-space. Journal of the ACM
55, 4 (2008), 1–24.
63. RIVEST, R. L., SHAMIR, A., AND ADLEMAN, L. A method for obtaining
digital signatures and public key cryptosystems. Communications of the ACM
21, 2 (1978), 120–126.
64. ROCHE, E., AND SCHABES, Y. Finite-State Language Processing. MIT Press,
1997.
65. SCHAEFER, T. J.
On the complexity of some two-person perfect-infor-
mation games. Journal of Computer and System Sciences 16, 2 (1978), 185–225.
66. SEDGEWICK, R. Algorithms, 2d ed. Addison-Wesley, 1989.
67. SHAMIR, A. IP = PSPACE. Journal of the ACM 39, 4 (1992), 869–877.
68. SHEN, A. IP = PSPACE: Simpliﬁed proof. Journal of the ACM 39, 4 (1992),
878–880.
69. SHOR, P. W. Polynomial-time algorithms for prime factorization and dis-
crete logarithms on a quantum computer. SIAM Journal on Computing 26,
(1997), 1484–1509.
70. SIPSER, M. Lower bounds on the size of sweeping automata. Journal of
Computer and System Sciences 21, 2 (1980), 195–202.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

447
71. SIPSER, M. The history and status of the P versus NP question. In Proceed-
ings of the Twenty-fourth Annual ACM Symposium on the Theory of Computing
(1992), 603–618.
72. STINSON, D. R. Cryptography: Theory and Practice. CRC Press, 1995.
73. SZELEPCZ ´ENYI, R. The method of forced enumeration for nondetermin-
istic automata, Acta Informatica 26, (1988), 279–284.
74. TARJAN, R. E. Data structures and network algorithms, vol. 44 of CBMS-NSF
Regional Conference Series in Applied Mathematics, SIAM, 1983.
75. TURING, A. M.
On computable numbers, with an application to the
Entscheidungsproblem. In Proceedings, London Mathematical Society, (1936),
230–265.
76. ULLMAN, J. D., AHO, A. V., AND HOPCROFT, J. E. The Design and Analysis
of Computer Algorithms. Addison-Wesley, 1974.
77. VAN LEEUWEN, J., Ed. Handbook of Theoretical Computer Science A: Algo-
rithms and Complexity. Elsevier, 1990.
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

Index
N
(natural numbers), 4, 255
R
(real numbers), 185, 205
R+ (nonnegative real numbers), 277
∅
(empty set), 4
∈
(element), 4
̸∈
(not element), 4
⊆
(subset), 4
⊊
(proper subset), 4
∪
(union operation), 4, 44
∩
(intersection operation), 4
×
(Cartesian or cross product), 6
Z
(integers), 4
ε
(empty string), 14
wR (reverse of w), 14
¬
(negation operation), 14
∧
(conjunction operation), 14
∨
(disjunction operation), 14
⊕
(exclusive OR operation), 15
→
(implication operation), 15
↔
(equality operation), 15
⇐
(reverse implication), 18
⇒
(implication), 18
⇐⇒(logical equivalence), 18
◦
(concatenation operation), 44
∗
(star operation), 44
+
(plus operation), 65
P(Q) (power set), 53
Σ
(alphabet), 53
Σε
(Σ ∪{ε}), 53
⟨·⟩
(encoding), 185, 287
␣
(blank), 168
≤m (mapping reduction), 235
≤T
(Turing reduction), 261
≤L
(log space reduction), 352
≤P
(polynomial time reduction), 300
d(x) (minimal description), 264
Th(M) (theory of model), 255
K(x) (descriptive complexity), 264
∀
(universal quantiﬁer), 338
∃
(existential quantiﬁer), 338
↑
(exponentiation), 371
O(f(n)) (big-O notation), 277–278
o(f(n)) (small-o notation), 278
448
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

INDEX
449
Accept state, 34, 35
Acceptance problem
for CFG, 198
for DFA, 194
for LBA, 222
for NFA, 195
for TM, 202
Accepting computation history, 221
Accepting conﬁguration, 169
Accepts a language, meaning of, 36
ACFG, 198
Acyclic graph, 404
ADFA, 194
Adjacency matrix, 287
Adleman, Leonard M., 443, 446
Agrawal, Manindra, 443
Aho, Alfred V., 443, 447
Akl, Selim G., 443
ALBA, 222
Algorithm
complexity analysis, 276–281
decidability and undecidability,
193–210
deﬁned, 182–184
describing, 184–187
Euclidean, 289
polynomial time, 284–291
running time, 276
ALLCFG, 225
Allen, Robin W., 444
Alon, Noga, 443
Alphabet, deﬁned, 13
Alternating Turing machine, 409
Alternation, 408–414
Ambiguity, 107–108
Ambiguous
NFA, 212
grammar, 107, 240
Ampliﬁcation lemma, 397
AND operation, 14
ANFA, 195
Angluin, Dana, 443
Anti-clique, 28
Approximation algorithm, 393–395
AREX, 196
Argument, 8
Arithmetization, 422
Arity, 8, 253
Arora, Sanjeev, 443
ASPACE(f(n)), 410
Asymptotic analysis, 276
Asymptotic notation
big-O notation, 277–278
small-o notation, 278
Asymptotic upper bound, 277
ATIME(t(n)), 410
ATM, 202
Atomic formula, 253
Automata theory, 3, see also
Context-free language;
Regular language
Average-case analysis, 276
Baase, Sara, 443
Babai, Laszlo, 443
Bach, Eric, 443
Balc´azar, Jos´e Luis, 444
Basis of induction, 23
Beame, Paul W., 444
Big-O notation, 276–278
Bijective function, 203
Binary function, 8
Binary operation, 44
Binary relation, 9
Bipartite graph, 360
Blank symbol ␣, 168
Blum, Manuel, 444
Boolean circuit, 379–387
depth, 428
gate, 380
size, 428
uniform family, 428
wire, 380
Boolean formula, 299, 338
minimal, 328, 377, 411, 414
quantiﬁed, 339
Boolean logic, 14–15
Boolean matrix multiplication, 429
Boolean operation, 14, 253, 299
Boolean variable, 299
Bound variable, 338
Branching program, 404
read-once, 405
Brassard, Gilles, 444
Bratley, Paul, 444
Breadth-ﬁrst search, 284
Brute-force search, 285, 288, 292, 298
Cantor, Georg, 202
Carmichael number, 400
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

450
INDEX
Carmichael, R. D., 444
Cartesian product, 6, 46
CD-ROM, 349
Certiﬁcate, 293
CFG, see Context-free grammar
CFL, see Context-free language
Chaitin, Gregory J., 264
Chandra, Ashok, 444
Characteristic sequence, 206
Checkers, game of, 348
Chernoff bound, 398
Chess, game of, 348
Chinese remainder theorem, 401
Chomsky normal form, 108–111, 157,
198, 291
Chomsky, Noam, 444
Church, Alonzo, 3, 183, 255
Church–Turing thesis, 183–184, 281
CIRCUIT-SAT, 386
Circuit-satisﬁability problem, 386
CIRCUIT-VALUE, 432
Circular deﬁnition, 65
Clause, 302
Clique, 28, 296
CLIQUE, 296
Closed under, 45
Closure under complementation
context-free languages, non-, 154
deterministic context-free
languages, 133
P, 322
regular languages, 85
Closure under concatenation
context-free languages, 156
NP, 322
P, 322
regular languages, 47, 60
Closure under intersection
context-free languages, non-, 154
regular languages, 46
Closure under star
context-free languages, 156
NP, 323
P, 323
regular languages, 62
Closure under union
context-free languages, 156
NP, 322
P, 322
regular languages, 45, 59
CNF-formula, 302
Co-Turing-recognizable language, 209
Cobham, Alan, 444
Coefﬁcient, 183
Coin-ﬂip step, 396
Complement operation, 4
Completed rule, 140
Complexity class
ASPACE(f(n)), 410
ATIME(t(n)), 410
BPP, 397
coNL, 354
coNP, 297
EXPSPACE, 368
EXPTIME, 336
IP, 417
L, 349
NC, 430
NL, 349
NP, 292–298
NPSPACE, 336
NSPACE(f(n)), 332
NTIME(f(n)), 295
P, 284–291, 297–298
PH, 414
PSPACE, 336
RP, 403
SPACE(f(n)), 332
TIME(f(n)), 279
ZPP, 440
Complexity theory, 2
Composite number, 293, 399
Compositeness witness, 401
COMPOSITES, 293
Compressible string, 267
Computability theory, 3
decidability and undecidability,
193–210
recursion theorem, 245–252
reducibility, 215–239
Turing machines, 165–182
Computable function, 234
Computation history
context-free languages, 225–226
deﬁned, 220
linear bounded automata,
221–225
Post Correspondence Problem,
227–233
reducibility, 220–233
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

INDEX
451
Computational model, 31
Computer virus, 250
Concatenation of strings, 14
Concatenation operation, 44, 47, 60–61
Conﬁguration, 168, 169, 350
Conjunction operation, 14
Conjunctive normal form, 302
coNL, 354
Connected graph, 12, 185
coNP, 297
Context-free grammar
ambiguous, 107, 240
deﬁned, 104
Context-free language
decidability, 198–200
deﬁned, 103
deterministic, 131
efﬁcient decidability, 290–291
inherently ambiguous, 108
pumping lemma, 125–130
Cook, Stephen A., 299, 387, 430, 444
Cook–Levin theorem, 299–388
Cormen, Thomas, 444
Corollary, 17
Correspondence, 203
Countable set, 203
Counterexample, 18
Counting problem, 420
Cross product, 6
Cryptography, 433–439
Cut edge, 395
Cut, in a graph, 325, 395
Cycle, 12
Davis, Martin, 183
DCFG, see Deterministic context-free
grammar
Decidability, see also Undecidability
context-free language, 198–200
of ACFG, 198
of ADFA, 194
of AREX, 196
of ECFG, 199
of EQDFA, 197
regular language, 194–198
Decidable language, 170
Decider
deterministic, 170
nondeterministic, 180
Decision problem, 394
Deﬁnition, 17
Degree of a node, 10
DeMorgan’s laws, example of proof, 20
Depth complexity, 428
Derivation, 102
leftmost, 108
Derives, 104
Descriptive complexity, 264
Deterministic computation, 47
Deterministic context-free grammar,
139
Deterministic context-free language
deﬁned, 131
properties, 133
Deterministic ﬁnite automaton
acceptance problem, 194
deﬁned, 35
emptiness testing, 196
minimization, 327
Deterministic pushdown automaton,
131
deﬁned, 130
DFA, see Deterministic ﬁnite automaton
Diagonalization method, 202–209
D´ıaz, Josep, 444
Difference hierarchy, 328
Digital signatures, 435
Directed graph, 12
Directed path, 13
Disjunction operation, 14
Distributive law, 15
DK-test, 143
DK1-test, 152
Domain of a function, 7
Dotted rule, 140
DPDA, see Deterministic pushdown
automaton
Dynamic programming, 290
ECFG, 199
EDFA, 196
Edge of a graph, 10
Edmonds, Jack, 444
ELBA, 223
Element distinctness problem, 175
Element of a set, 3
Emptiness testing
for CFG, 199
for DFA, 196
for LBA, 223
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

452
INDEX
for TM, 217
Empty set, 4
Empty string, 14
Encoding, 185, 287
Enderton, Herbert B., 444
Endmarked language, 134
Enumerator, 180–181
EQCFG, 200
EQDFA, 197
EQREX↑, 372
EQTM
Turing-unrecognizability, 238
undecidability, 220
Equality operation, 15
Equivalence relation, 9
Equivalent machines, 54
Erd¨os, Paul, 443
Error probability, 397
ETM, 211
ETM, undecidability, 217
Euclidean algorithm, 289
Even, Shimon, 444
EXCLUSIVE OR operation, 15
Existential state, 409
Exponential bound, 278
Exponential, versus polynomial, 285
EXPSPACE, 368
EXPSPACE-completeness, 371–376
EXPTIME, 336
Factor of a number, 399
Feller, William, 444
Fermat test, 400
Fermat’s little theorem, 399
Feynman, Richard P., 444
Final state, 35
Finite automaton
automatic door example, 32
computation of, 40
decidability, 194–198
deﬁned, 35
designing, 41–44
transition function, 35
two-dimensional, 241
two-headed, 240
Finite state machine, see
Finite automaton
Finite state transducer, 87
Fixed point theorem, 251
Forced handle, 138
Formal proof, 258
Formula, 253, 299
FORMULA-GAME, 342
Fortnow, Lance, 446
Free variable, 253
FST, see Finite state transducer
Function, 7–10
argument, 8
binary, 8
computable, 234
domain, 7
one-to-one, 203
one-way, 436
onto, 7, 203
polynomial time computable, 300
range, 7
space constructible, 364
time constructible, 368
transition, 35
unary, 8
Gabarr´o, Joaquim, 444
Gadget in a completeness proof, 311
Game, 341
Garey, Michael R., 444
Gate in a Boolean circuit, 380
Generalized geography, 344
Generalized nondeterministic ﬁnite
automaton, 70–76
converting to a regular
expression, 71
deﬁned, 70, 73
Geography game, 343
GG (generalized geography), 345
Gill, John T., 444
GNFA, see Generalized
nondeterministic ﬁnite
automaton
GO, game of, 348
Go-moku, game of, 358
G¨odel, Kurt, 3, 255, 258, 444
Goemans, Michel X., 444
Goldwasser, Shaﬁ, 445
Graph
acyclic, 404
coloring, 325
cycle in, 12
degree, 10
directed, 12
edge, 10
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

INDEX
453
isomorphism problem, 323, 415
k-regular, 21
labeled, 11
node, 10
strongly connected, 13
sub-, 11
undirected, 10
vertex, 10
Greenlaw, Raymond, 445
Halting conﬁguration, 169
Halting problem, 216–217
unsolvability of, 216
HALT TM, 216
Hamiltonian path problem, 292
exponential time algorithm, 292
NP-completeness of, 314–319
polynomial time veriﬁer, 293
HAMPATH, 292, 314
Handle, 136
forced, 138
Harary, Frank, 445
Hartmanis, Juris, 445
Hey, Anthony J. G., 444
Hierarchy theorem, 364–371
space, 365
time, 369
High-level description of a Turing
machine, 185
Hilbert, David, 182, 445
Hofstadter, Douglas R., 445
Hoover, H. James, 444, 445
Hopcroft, John E., 443, 445, 447
Huang, Ming-Deh A., 443
iff, 18
Immerman, Neil, 445
Implementation description of a
Turing machine, 185
Implication operation, 15
Incompleteness theorem, 258
Incompressible string, 267
Indegree of a node, 12
Independent set, 28
Induction
basis, 23
proof by, 22–25
step, 23
Induction hypothesis, 23
Inductive deﬁnition, 65
Inﬁnite set, 4
Inﬁx notation, 8
Inherent ambiguity, 108
Inherently ambiguous context-free
language, 108
Injective function, 203
Integers, 4
Interactive proof system, 415–427
Interpretation, 254
Intersection operation, 4
IP, 417
ISO, 415
Isomorphic graphs, 323
Johnson, David S., 444, 445
k-ary function, 8
k-ary relation, 9
k-clique, 295
k-optimal approximation algorithm,
395
k-tuple, 6
Karloff, Howard, 446
Karp, Richard M., 445
Kayal, Neeraj, 443
Knuth, Donald E., 139, 445
Kolmogorov, Andrei N., 264
L, 349
Labeled graph, 11
Ladder, 358
Language
co-Turing-recognizable, 209
context-free, 103
decidable, 170
deﬁned, 14
deterministic context-free, 131
endmarked, 134
of a grammar, 103
recursively enumerable, 170
regular, 40
Turing-decidable, 170
Turing-recognizable, 170
Turing-unrecognizable, 209
Lawler, Eugene L., 445
LBA, see Linear bounded automaton
Leaf in a tree, 12
Leeuwen, Jan van, 447
Leftmost derivation, 108
Leighton, F. Thomson, 445
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

454
INDEX
Leiserson, Charles E., 444
Lemma, 17
Lenstra, Jan Karel, 445
Leveled graph, 361
Levin, Leonid A., 299, 387, 445
Lewis, Harry, 445
Lexical analyzer, 66
Lexicographic order, 14
Li, Ming, 445
Lichtenstein, David, 446
Linear bounded automaton, 221–225
Linear time, 281
Lipton, Richard J., 445
LISP, 182
Literal, 302
Log space computable function, 352
Log space reduction, 352, 432
Log space transducer, 352
Lookahead, 152
LR(k) grammar, 152
Luby, Michael, 446
Lund, Carsten, 443, 446
Majority function, 391
Many–one reducibility, 234
Mapping, 7
Mapping reducibility, 234–239
polynomial time, 300
Markov chain, 33
Match, 227
Matijasevi˘c, Yuri, 183
MAX-CLIQUE, 328, 389
MAX-CUT, 325
Maximization problem, 395
Member of a set, 3
Micali, Silvio, 445
Miller, Gary L., 446
MIN-FORMULA, 328, 359, 377, 411,
414
Minesweeper, 326
Minimal description, 264
Minimal formula, 328, 359, 377, 411,
414
Minimization of a DFA, 327
Minimization problem, 394
Minimum pumping length, 91
MIN TM, 251, 270
Model, 254
MODEXP, 323
Modulo operation, 8
Motwani, Rajeev, 443
Multiset, 4, 297
Multitape Turing machine, 176–178
Myhill–Nerode theorem, 91
Natural numbers, 4
NC, 430
Negation operation, 14
NFA, see Nondeterministic ﬁnite
automaton
Nim, game of, 359
Nisan, Noam, 446
Niven, Ivan, 446
NL, 349
NL-complete problem
PATH, 350
NL-completeness
deﬁned, 352
Node of a graph, 10
degree, 10
indegree, 12
outdegree, 12
Nondeterministic computation, 47
Nondeterministic ﬁnite automaton,
47–58
computation by, 48
deﬁned, 53
equivalence with deterministic
ﬁnite automaton, 55
equivalence with regular
expression, 66
Nondeterministic polynomial time, 294
Nondeterministic Turing machine,
178–180
space complexity of, 332
time complexity of, 283
NONISO, 415
NOT operation, 14
NP, 292–298
NP-complete problem
3SAT, 302, 387
CIRCUIT-SAT, 386
HAMPATH, 314
SUBSET-SUM, 320
3COLOR, 325
UHAMPATH, 319
VERTEX-COVER, 312
NP-completeness, 299–322
deﬁned, 304
NP-hard, 326
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

INDEX
455
NP-problem, 294
NPA, 376
NPSPACE, 336
NSPACE(f(n)), 332
NTIME(f(n)), 295
NTM, see Nondeterministic Turing
machine
o(f(n)) (small-o notation), 278
One-sided error, 403
One-time pad, 434
One-to-one function, 203
One-way function, 436
One-way permutation, 436
Onto function, 7, 203
Optimal solution, 394
Optimization problem, 393
OR operation, 14
Oracle, 260, 376
Oracle tape, 376
Ordered pair, 6
Outdegree of a node, 12
P, 284–291, 297–298
P-complete problem
CIRCUIT-VALUE, 432
P-completeness, 432
PA, 376
Pair
ordered, 6
unordered, 4
Palindrome, 90, 155
Papadimitriou, Christos H., 445, 446
Parallel computation, 427–432
Parallel random access machine, 428
Parity function, 381
Parse tree, 102
Parser, 101
Pascal, 182
Path
Hamiltonian, 292
in a graph, 12
simple, 12
PATH, 287, 350
PCP, see Post Correspondence Problem
PDA, see Pushdown automaton
Perfect shufﬂe operation, 89, 158
PH, 414
Pigeonhole principle, 78, 79, 126
Pippenger, Nick, 430
Polynomial, 182
Polynomial bound, 278
Polynomial time
algorithm, 284–291
computable function, 300
hierarchy, 414
veriﬁer, 293
Polynomial veriﬁability, 293
Polynomial, versus exponential, 285
Polynomially equivalent models, 285
Pomerance, Carl, 443, 446
Popping a symbol, 112
Post Correspondence Problem (PCP),
227–233
modiﬁed, 228
Power set, 6, 53
PRAM, 428
Pratt, Vaughan R., 446
Preﬁx notation, 8
Preﬁx of a string, 14, 89
Preﬁx-free language, 14, 212
Prenex normal form, 253, 339
Prime number, 293, 324, 399
Private-key cryptosystem, 435
Probabilistic algorithm, 396–408
Probabilistic function, 436
Probabilistic Turing machine, 396
Processor complexity, 428
Production, 102
Proof, 17
by construction, 21
by contradiction, 21–22
by induction, 22–25
ﬁnding, 17–20
necessity for, 77
Proper subset, 4
Prover, 416
Pseudoprime, 400
PSPACE, 336
PSPACE-complete problem
FORMULA-GAME, 342
GG, 345
TQBF, 339
PSPACE-completeness, 337–348
deﬁned, 337
PSPACE-hard, 337
Public-key cryptosystem, 435
Pumping lemma
for context-free languages,
125–130
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

456
INDEX
for regular languages, 77–82
Pumping length, 77, 91, 125
Pushdown automaton, 111–124
context-free grammars, 117–124
deﬁned, 113
deterministic, 131
examples, 114–116
schematic of, 112
Pushing a symbol, 112
Putnam, Hilary, 183
PUZZLE, 325, 359
Quantiﬁed Boolean formula, 339
Quantiﬁer, 338
in a logical sentence, 253
Query node in a branching program,
404
Rabin, Michael O., 446
Rackoff, Charles, 445
Ramsey’s theorem, 28
Range of a function, 7
Read-once branching program, 405
Real number, 204
Recognizes a language, meaning of, 36,
40
Recursion theorem, 245–252
ﬁxed-point version, 251
terminology for, 249
Recursive language, see
Decidable language
Recursively enumerable, see
Turing-recognizable
Recursively enumerable language, 170
Reduce step, 135
Reducibility, 215–239
mapping, 234–239
polynomial time, 300
via computation histories,
220–233
Reducing string, 135
Reduction
between problems, 215
function, 235
mapping, 235
reversed derivation, 135
Turing, 261
Reﬂexive relation, 9
Regular expression, 63–76
deﬁned, 64
equivalence to ﬁnite automaton,
66–76
examples of, 65
Regular language, 31–82
closure under concatenation, 47,
60
closure under intersection, 46
closure under star, 62
closure under union, 45, 59
decidability, 194–198
deﬁned, 40
Regular operation, 44
REGULARTM, 218
Reingold, Omer, 446
Rejecting computation history, 221
Rejecting conﬁguration, 169
Relation, 9, 253
binary, 9
Relatively prime, 288
Relativization, 376–379
RELPRIME, 289
Reverse of a string, 14
Rice’s theorem, 219, 241, 243, 270, 272
Rinooy Kan, A. H. G., 445
Rivest, Ronald L., 444, 446
Robinson, Julia, 183
Roche, Emmanuel, 446
Root
in a tree, 12
of a polynomial, 183
Rule in a context-free grammar, 102,
104
Rumely, Robert S., 443
Ruzzo, Walter L., 445
SAT, 304, 336
#SAT, 420
Satisﬁability problem, 299
Satisﬁable formula, 299
Savitch’s theorem, 333–335
Saxena, Nitin, 443
Schabes, Yves, 446
Schaefer, Thomas J., 446
Scope, 338
Scope, of a quantiﬁer, 253
Secret key, 433
Sedgewick, Robert, 446
Self-loop, 10
Self-reference, 246
Sentence, 339
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

INDEX
457
Sequence, 6
Sequential computer, 427
Set, 3
countable, 203
uncountable, 204
Sethi, Ravi, 443
Shallit, Jeffrey, 443
Shamir, Adi, 446
Shen, Alexander, 446
Shmoys, David B., 445
Shor, Peter W., 446
Shortlex order, 14
Shufﬂe operation, 89, 158
Simple path, 12
Singleton set, 4
Sipser, Michael, 446, 447
Size complexity, 428
Small-o notation, 278
SPACE(f(n)), 332
Space complexity, 331–361
Space complexity class, 332
Space complexity of
nondeterministic Turing machine,
332
Space constructible function, 364
Space hierarchy theorem, 365
Spencer, Joel H., 443
Stack, 111
Star operation, 44, 62–63, 323
Start conﬁguration, 169
Start state, 34
Start variable, in a context-free
grammar, 102, 104
State diagram
ﬁnite automaton, 34
pushdown automaton, 114
Turing machine, 172
Stearns, Richard E., 445
Steiglitz, Kenneth, 446
Stinson, Douglas R., 447
String, 14
String order, 14
Strongly connected graph, 13, 360
Structure, 254
Subgraph, 11
Subset of a set, 4
SUBSET-SUM, 296, 320
Substitution rule, 102
Substring, 14
Sudan, Madhu, 443
Surjective function, 203
Symmetric difference, 197
Symmetric relation, 9
Synchronizing sequence, 92
Szegedy, Mario, 443
Szelepcz´enyi, R´obert, 447
Tableau, 383
Tarjan, Robert E., 447
Tautology, 410
Term, in a polynomial, 182
Terminal, 102
Terminal in a context-free grammar,
104
Th(M), 255
Theorem, 17
Theory, of a model, 255
3COLOR, 325
3SAT, 302, 387
Tic-tac-toe, game of, 357
TIME(f(n)), 279
Time complexity, 275–322
analysis of, 276–281
of nondeterministic Turing
machine, 283
Time complexity class, 295
Time constructible function, 368
Time hierarchy theorem, 369
TM, see Turing machine
TQBF, 339
Transducer
ﬁnite state, 87
log space, 352
Transition, 34
Transition function, 35
Transitive closure, 429
Transitive relation, 9
Trapdoor function, 438
Tree, 12
leaf, 12
parse, 102
root, 12
Triangle in a graph, 323
Tuple, 6
Turing machine, 165–182
alternating, 409
comparison with ﬁnite
automaton, 166
deﬁned, 168
describing, 184–187
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

458
INDEX
examples of, 170–175
marking tape symbols, 174
multitape, 176–178
nondeterministic, 178–180
oracle, 260, 376
schematic of, 166
universal, 202
Turing reducibility, 260–261
Turing, Alan M., 3, 165, 183, 447
Turing-decidable language, 170
Turing-recognizable language, 170
Turing-unrecognizable language,
209–210
EQTM, 238
Two-dimensional ﬁnite automaton, 241
Two-headed ﬁnite automaton, 240
2DFA, see Two-headed ﬁnite automaton
2DIM-DFA, see Two-dimensional ﬁnite
automaton
2SAT, 327
Ullman, Jeffrey D., 443, 445, 447
Unary
alphabet, 52, 82, 240
function, 8
notation, 287, 323
operation, 44
Uncountable set, 204
Undecidability
diagonalization method, 202–209
of ATM, 202
of ELBA, 223
of EQTM, 220
of ETM, 217
of HALT TM, 216
of REGULARTM, 219
of EQCFG, 200
of Post Correspondence Problem,
228
via computation histories,
220–233
Undirected graph, 10
Union operation, 4, 44, 45, 59–60
Unit rule, 109
Universal quantiﬁer, 338
Universal state, 409
Universal Turing machine, 202
Universe, 253, 338
Unordered pair, 4
Useless state
in PDA, 212
in TM, 239
Valiant, Leslie G., 443
Valid string, 136
Variable
Boolean, 299
bound, 338
in a context-free grammar, 102,
104
start, 102, 104
Venn diagram, 4
Veriﬁer, 293, 416
Vertex of a graph, 10
VERTEX-COVER, 312
Virus, 250
Vitanyi, Paul, 445
Wegman, Mark, 444
Well-formed formula, 253
Williamson, David P., 444
Window, in a tableau, 307
Winning strategy, 342
Wire in a Boolean circuit, 380
Worst-case analysis, 276
XOR operation, 15, 383
Yannakakis, Mihalis, 446
Yields
for conﬁgurations, 169
for context-free grammars, 104
ZPP, 440
Zuckerman, Herbert S., 446
Copyright 2012 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the 
eBook and/or eChapter(s). Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional 
content at any time if subsequent rights restrictions require it.

