Комбинаторная логика
как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
 
 
 
Комментарий к слайду  
 
В данной лекции будут рассмотрены вопросы, относящиеся к истории развития, 
идеологии, математическому основанию и обзору возможностей комбинаторной логики – 
математической 
формализации, 
моделирующей 
языки 
функционального 
программирования и абстрактные вычислительные машины. 
 

 
Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Содержание лекции
1.
Определение комбинатора
2.
Комбинаторная логика как формальная система: алфавит, 
аксиомы, правила вывода
3.
Примеры комбинаторов
4.
Определение базиса. Основные базисы комбинаторной 
логики
5.
Приписывание типов комбинаторам. Выводимость типов 
6.
Примеры функций базисных комбинаторов на SML
7.
Библиография
 
 
Комментарий к слайду  
 
В ходе лекции будут рассмотрены важнейшие научные исследования, относящиеся к 
эволюции 
подходов 
к 
математическому 
моделированию 
ключевой 
сущности 
функционального подхода к программированию, а именно, функции. При этом будет 
особо 
отмечено 
то 
обстоятельство, 
что 
(типизированные) 
функции 
языков 
программирования естественным и интуитивно понятным образом моделируются 
посредством комбинаторов – ламбда-выражений специального вида (с приписанными им 
типами).   
 
Далее 
будет 
представлено 
формальное 
введение 
в 
типизированный 
вариант 
комбинаторной логики, первоначально предложенный Х. Карри. Изложение формальной 
теории будет производиться в традиционной для математики последовательности: 
алфавит, аксиомы и правила вывода. Затем будет обсуждаться понятие базисного набора 
комбинаторов: будут рассмотрены несколько вариантов базисов, включая минимально 
возможный. 
 
По результатам представленной теории будут сделаны выводы о преимуществах и 
недостатках 
комбинаторной 
логики 
для 
моделирования 
конструкций 
языков 
функционального программирования со строгой типизацией. При этом существенное 
внимание будет уделено формализации языка функционального программирования SML, 
который изучается на протяжении всего курса, в частности, вопросу выводимости типов. 
 
Лекция завершится обзором литературы для более глубокого исследования материала. 
 
 
 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Важнейшие работы  в комбинаторной логике
1920-е – М. Шенфинкель (Moses Shönfinkel) разработал 
формальную систему, основанную на объектах, 
подобных комбинаторам
1950-е – Х. Карри (Haskell B. Curry) создал комбинаторную 
логику как формальную систему
1960-е – Д. Тернер (David Turner) предложил использовать 
комбинаторы в качестве низкоуровневого кода для 
трансляторов языков функционального 
программирования
1960-е – П. Лендин (Peter Landin) создал абстрактную машину 
на состояниях, основанную на комбинаторном подходе
 
 
 
Комментарий к слайду  
 
Напомним ход эволюции теорий, лежащих в основе современного подхода к ламбда-
исчислению. 
 
Еще в 1924 году М. Шенфинкель (Moses Shönfinkel) разработал простую (simple) теорию 
функций, которая фактически являлась исчислением объектов-функций и предвосхитила 
появление ламбда-исчисления, а затем и комбинаторной логики. 
 
Позднее, в 50-х г.г., Х. Карри (Haskell Curry) предложил теорию функций без переменных 
(иначе называемых комбинаторами), известную в настоящее время как комбинаторная 
логика. Эта теория представляет собой формальный язык, аналогичный языку 
функционального программирования и позволяющий моделировать вычисления в среде 
абстрактных машин, в значительной мере схожих с виртуальной машиной .NET. 
 
В 60-х г.г. Д. Тернер (David Turner) предложил использовать комбинаторы в качестве 
низкоуровневого кода для трансляторов языков функционального программирования, т.е. 
предвосхитил появление абстрактных машин, использующих в качестве инструкций 
комбинаторы. 
 
Затем, уже в 60-х г.г. П. Лендин (Peter Landin) создал первую абстрактную машину на 
основе комбинаторной логики. Машина получила название SECD и формализовала 
вычисления на языке программирования ISWIM (If you See What I Mean), который 
впоследствии стал прообразом языка функционального программирования ML. Основным 
понятием для SECD-машины является понятие состояния. 
 
Уже в 70-е г.г. группой ученых института INRIA (Франция) была создана абстрактная 
машина, основанная на смене состояний и получившая название категориальной 
абстрактной машины, или, сокращенно, КАМ. КАМ основана на теории категорий в 
форме категориальной комбинаторной логики. С помощью КАМ был реализован еще 
один современный диалект ML, получивший название CaML. 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Определение комбинатора
Переменная x называется свободной в терме λx.A, если 
она не имеет вхождений в терм A; в противном случае 
переменная x называется связанной
Для составных термов связанность переменных 
определяется индукцией по построению.
Терм, не содержащий свободных переменных, 
называется комбинатором. 
 
 
 
Комментарий к слайду  
 
Важнейшим понятием для любой формы комбинаторной логики является понятие 
комбинатора. 
 
Для того, чтобы формально определить комбинатор, необходимо ввести понятие 
свободной и связанной переменной в ламбда-выражении. 
 
Переменная x называется свободной в ламбда-выражении (терме) вида λx.A, если она не 
имеет вхождений в терм A; в противном случае переменная x называется связанной.  
 
 
Для составных ламбда-выражений понятие связанной и свободной переменной 
определяется индукцией по построению с учетом возможных способов комбинирования, а 
именно, операций аппликации и абстракции. 
 
Теперь становится возможным дать лаконичное определение комбинатора. 
 
 
Ламбда-выражение 
(терм), 
не 
содержащее 
свободных 
переменных, 
называется 
комбинатором.  
 
 
 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Комбинаторная логика: основные компоненты
Алфавит – множество допустимых символов
Утверждения – правила образования терминальных 
символов
Аксиомы – элементарные утверждения, истинность 
которых принимается без доказательства
Правила вывода – правила преобразования одних 
символов (объектов) языка в другие
 
 
 
Комментарий к слайду  
 
Перейдем к описанию комбинаторной логики как формальной системы. Согласно 
математической практике, необходимо определить следующие элементы теории: 
• алфавит; 
• утверждения; 
• аксиомы; 
• правила вывода. 
 
Напомним, что под алфавитом  понимается множество символов, допустимых в нотации 
той или иной формализации. 
 
 
Утверждения 
устанавливают 
правила 
образования 
терминальных 
символов 
математической теории. 
 
 
Под аксиомами понимаются элементарные утверждения, которые считаются истинными 
без необходимости доказательства истинности. 
 
 
Правила вывода определяют правила преобразования одних символов (объектов), 
исследуемых в теории,  в другие объекты. 
 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Комбинаторная логика: алфавит
Константы: c1, c2, … - малые буквы латинского 
алфавита, возможно, с индексами
Переменные: x, y, … - малые буквы латинского 
алфавита, возможно, с индексами
Выражения (термы): M, N, … - заглавные буквы 
латинского алфавита, возможно, с индексами
Специальные символы: “(“, “)”
 
 
 
Комментарий к слайду  
 
Рассмотрим алфавит комбинаторной логики. 
 
Допускаются элементы четырех видов: 
1) константы; 
2) переменные; 
3) комбинаторные выражения (или, иначе, термы); 
4) специальные символы. 
 
При этом принимаются следующие обозначения. 
 
Константы c1, c2, … обозначаются малыми буквами латинского алфавита, возможно, с 
индексами. 
 
Переменные x, y, … обозначаются малыми буквами латинского алфавита, возможно, с 
индексами. 
 
Выражения (или, иначе, термы) M, N, … обозначаются заглавными буквами латинского 
алфавита, возможно, с индексами. 
 
Допускается использование следующих специальных символов (взяты в кавычки и 
разделены запятыми): “(“, “)”. 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Комбинаторная логика : построение термов
Термы определяются индукцией по построению.
Все переменные и константы являются термами.
Для любых термов M, N и переменной x верно, что
(MN) – терм.
При этом выражение (MN) обозначает  операцию 
аппликации (применения функции к аргументу)
Операции абстракции в комбинаторной логике не 
существует. 
Никакой другой набор символов не является термом.
 
 
 
Комментарий к слайду  
 
Рассмотрим далее порядок конструирования допустимых для заданного алфавита 
комбинаторных выражений, или, иначе, термов. 
 
Комбинаторные термы строятся по индукции (порядок построения можно считать 
определением) следующим образом. 
 
Базис индукции: любая переменная или константа является комбинаторным термом по 
определению. 
 
Шаг индукции: если M, N – произвольные комбинаторные термы и x – произвольная 
переменная, то справедливо, что: 
• выражение (MN) является допустимым комбинаторным термом. 
 
Заметим, что при этом комбинаторное выражение (MN) обозначает операцию аппликации 
(или применения функции к аргументу).  
 
Кроме того, примем, что никакой другой набор символов не является допустимым 
комбинаторным термом. 
 
 
 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Комбинаторная логика: аксиомы
Следующие аксиомы задают свойства отношения 
конвертируемости (приводимости одного терма к 
другому), обозначаемого символом “=”.
(I) Ix = x;
(K) Kxy = x;
(S) Sxyz = xz(yz).
Аксиома (I) соответствует функции тождества.
Аксиома (K) соответствует функции взятия первой
проекции.
 
 
 
Комментарий к слайду  
 
После определения алфавита и порядка построения допустимых комбинаторных 
выражений посредством операции аппликации, перечислим аксиомы комбинаторной 
логики. 
 
Отметим, что употребляемый ниже символ “=” понимается в комбинаторной логике как 
обозначение отношения конвертируемости, которым связываются соединенные этим 
значком комбинаторные термы. Конвертируемость двух комбинаторных термов означает, 
что один комбинаторный терм может быть преобразован к другому. Отношение 
конвертируемости моделирует переобозначения и во многих отношениях, как отмечалось 
ранее,  напоминает процесс программирования. 
 
Следующие аксиомы задают свойства отношения конвертируемости: 
 
 
(I) Ix = x; 
 
(K) Kxy = x; 
 
(S) Sxyz = xz(yz). 
 
 
 
 
Аксиома (I) означает существование комбинатора (функции) тождества, т.е. наличие 
тождественного преобразования, при котором любой аргумент отображается сам в себя. 
 
Аксиома (K) означает существование комбинатора (функции) взятия первой проекции, т.е. 
первого элемента упорядоченной пары или первого элемента списка. Интуитивно ясно, 
что эта аксиома близка языкам функционального программирования, оперирующим 
списками, и соответствует фундаментальной операции взятия головного (первого) 
элемента списка. 
 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Комбинаторная логика: правила вывода
Следующие правила вывода термов задают свойства 
отношения конвертируемости:
(μ) если a=b, то ca=cb; 
(ν) если a=b, то ac=bc; 
(ρ) a=a (рефлексивность);
(σ) если a=b, то b=a (симметричность);
(τ) если a=b и b=c, то a=c (транзитивность).
 
 
 
Комментарий к слайду  
 
 
Перечислим правила вывода комбинаторных термов, которые задают характеристики 
отношения конвертируемости: 
 
(μ) если a=b, то ca=cb;  
(ν) если a=b, то ac=bc;  
(ρ) a=a (рефлексивность); 
(σ) если a=b, то b=a (симметричность); 
(τ) если a=b и b=c, то a=c (транзитивность). 
 
Как видно из перечисленных выше свойств,  отношение конвертируемости обладает, в 
частности, свойствами рефлексивности, симметричности и транзитивности. Первое из 
только 
что 
перечисленных 
свойств 
означает 
конвертируемость 
произвольного 
комбинаторного выражения к самому себе, второе – двунаправленность вывода 
комбинаторных выражений посредством конверсии, а третье – возможность опускать 
промежуточные этапы конверсии для цепочек вывода. 
 
 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Соглашения об обозначениях
•
скобки для операции аппликации восстанавливаются по 
ассоциации влево:
X Y = (X Y), X Y Z = ((X Y) Z), …
•
избыточные скобки могут опускаться:
(X Y) = X Y, ((X Y) Z) = X Y Z, …
 
 
 
Комментарий к слайду  
 
К сожалению, относительная простота описания предыдущих этапов формальной теории 
комбинаторной логики (алфавита, аксиом и правил вывода) порождает довольно 
громоздкие выкладки при моделировании вычислений.  
 
В этой связи из соображения экономии пространства для вывода соотношений 
принимаются следующие умолчания, позволяющие значительно сократить запись и 
увеличить удобство прочтения и обработки комбинаторных термов. 
 
Во-первых, скобки для операции аппликации восстанавливаются по ассоциации влево, 
например:  
 
X Y = (X Y), X Y Z = ((X Y) Z), … 
 
Во-вторых, избыточные скобки могут опускаться, например:  
 
(X Y) = X Y, ((X Y) Z) = X Y Z, … 
 
 
 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Синтаксис комбинаторной логики
БНФ-описание комбинатора имеет вид:
<комбинатор> ::= K | S | (<комбинатор> <комбинатор>)
БНФ-описание терма комбинаторной логики, возможно, 
содержащего переменные, имеет вид:
<комбинаторный терм> ::= 
K | S | 
<переменная> | 
(<комбинаторный терм> <комбинаторный терм>)
 
 
Комментарий к слайду  
 
Под синтаксисом понимают это раздел описания формального математического языка или 
языка программирования, исследующий вид, форму и структуру конструкций, без учета 
их значения (или, иначе, семантики) или практической применимости (или, иначе, 
прагматики).  
 
Задать синтаксис языка возможно, перечислив описание его конструкций, например, с 
помощью форм Бэкуса-Наура или БНФ. БНФ созданы в 60-х г.г. Дж. Бэкусом (John 
Backus) и развиты П. Науром (Peter Naur) как метаязык для формализации синтаксиса 
языка 
программирования 
ALGOL 
60. 
Впоследствии 
БНФ 
получили 
широкое 
распространение и в настоящее время являются основной нотацией для формализации 
синтаксиса языков программирования (мы будем пользоваться БНФ для формализации 
синтаксиса 
языка 
программирования 
SML). 
В 
данной 
нотации 
символ 
«::=» 
интерпретируется словами «может иметь вид», а символ «|» – словом «или». 
Определяемое и определяющие понятия записываются в угловых скобках, первое – слева, 
а последние – справа от значка «::=». 
 
Формализуем синтаксис выражений комбинаторной логики (или комбинаторов). 
 
БНФ-описание комбинатора имеет вид: 
 
<комбинатор> ::= K | S | (<комбинатор> <комбинатор>) 
 
 
 
БНФ-описание терма комбинаторной логики, возможно, содержащего переменные, 
имеет вид: 
 
<комбинаторный терм> ::=  
 
K | S |  
 
<переменная> |  
 
(<комбинаторный терм> <комбинаторный терм>) 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Примеры комбинаторов 
I a = a (комбинатор тождества)
К ab = a (комбинатор-канцелятор, первая проекция)
S abc = ac(bc) (комбинатор-коннектор, связывание)
B abc = a(bc) (комбинатор композиции)
C abc = acb (комбинатор-пермутатор, перестановка)
W xy = xyy (комбинатор-дупликатор, дублирование)
 
 
 
Комментарий к слайду  
 
Проиллюстрируем 
представленную 
формальную 
систему 
комбинаторной 
логики 
необходимыми примерами комбинаторов. Рассмотрим характеристические соотношения 
для комбинаторов, которые впоследствии окажутся теоретически интересными и 
практически полезными в данном курсе (некоторые из соотношений совпадают с 
введенными ранее аксиомами):  
 
(I) 
I a = a;  
(K) 
К ab = a; 
(S) 
S abc = ac(bc);  
(B) 
B abc = a(bc);  
(C) 
C abc = acb; 
(W) 
W xy = xyy.  
 
Соотношение (I), как уже отмечалось, характеризует комбинатор тождества. 
 
Соотношение (K), как уже отмечалось, характеризует комбинатор первой проекции (иначе 
именуемый канцелятором, т.е. «отменяющим» «выполнение» всех «инструкций», кроме 
первой). 
 
Соотношение (S) характеризует комбинатор-коннектор, который определяет порядок 
«связывания» «инструкций» программы таким образом, что третья «инструкция» 
«распределяется» по паре из двух первых. 
 
Соотношение 
(B) 
характеризует 
комбинатор 
композиции, 
который 
образует 
последовательность 
комбинаторных 
термов 
и 
служит 
для 
объединения 
более 
элементарных «инструкций» в более сложные, а в итоге – в «программы». 
 
Соотношения  (C) и (W) определяют соответственно пермутацию (перестановку) и 
дублирование  аргументов. 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Редукция комбинаторов 
Редукция (преобразование для сокращения записи) 
комбинаторных термов возможна в соответствии с 
правилами вывода, аналогичным аксиомам (K) и (S).
Пример.
Рассмотрим комбинаторный терм S K K  x.
S K K  x   =
(по правилу S)
K x (K x) =
(по правилу K)
x.
Ответ: S K K x = x, откуда, с учетом аксиом и правила
(I), I = SKK.
 
 
 
Комментарий к слайду  
 
Напомним, что одной из основных причин возникновения ламбда-исчисления была 
необходимость исследовать возможность кратчайшей перезаписи выражения (функции) с 
сохранением эквивалентного значения. Для реализации этой возможности вводилось 
преобразование редукции ламбда-термов. 
 
Оказывается, что в комбинаторной логике наследуется возможность редукции. Поскольку 
она интересна теоретически (для сокращения выкладок) и полезна практически (для 
оптимизации программного кода абстрактных) машин, рассмотрим ее более подробно. 
 
В ходе исследований было выяснено, что редукция (преобразование для сокращения 
записи) комбинаторных термов возможна в соответствии с правилами вывода, 
аналогичными аксиомам (K) и (S). 
 
Проиллюстрируем моделирование механизма редукции следующим примером. 
 
Рассмотрим комбинаторный терм вида   
 
S K K  x. 
 
Пользуясь аксиомами (К) и (S), а также правилами вывода, произведем редукцию терма: 
 
 
 
S K K  x   = 
 
 
 
 
(по правилу S) 
 
 
K x (K x)  =  
 
 
 
(по правилу K) 
 
 
x. 
 
 
 
 
В результате получаем, что S K K  x = x, откуда, с учетом аксиом и правила (I), I = SKK. 
 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Базисы комбинаторов 
Множество (минимальной мощности) комбинаторов, 
через элементы которого выразим произвольный 
комбинатор, называется (минимальным) базисом.
Минимальный базис: {K,S}.
Другие примеры базисов: {I,K,S}; {I,B,C,S}; {B,W,K}.
Примеры.
Разложение термов в базисе {K,S}:
B = S(KS)K; W = SS(K(SKK)); C = S(BBS)(KK).
Разложение в базисе – аналог программирования.
 
 
 
Комментарий к слайду  
 
Как видно из предыдущего примера, одни комбинаторы можно выразить через другие.  
 
Возникает вопрос: существует ли некоторый конечный набор комбинаторов, посредством 
которого возможно выразить произвольный терм комбинаторной логики? Оказывается, 
что ответ на поставленный вопрос утвердительный, причем введенные аксиомы и правила 
вывода обеспечивают весьма лаконичный набор такого рода.  
 
Необходимость продолжения рассуждений приводит нас к понятию базиса. 
 
Множество (минимальной мощности) комбинаторов, через элементы которого выразим 
произвольный комбинатор, называется (минимальным) базисом. 
 
 
Как оказывается, можно доказать, что: 
1) базис термов для комбинаторной логики действительно существует (причем 
существует бесконечное множество возможных базисов); 
2) для любого базиса справедливо, что он обеспечивает представление произвольного 
комбинаторного терма (в силу свойства полноты, которым обладает система 
комбинаторной логики); 
3) минимальный базис состоит всего из двух «инструкций»-комбинаторов, например, 
{K,S}. 
 
Приведем еще несколько примеров базисов: {I,K,S}; {I,B,C,S}; {B,W,K}. 
 
 
Разложение термов в базисе {K,S} для ранее рассмотренных комбинаторов имеет вид: 
 
B = S(KS)K; W = SS(K(SKK)); C = S(BBS)(KK). 
 
 
Разложение в базисе аналогично программированию на языке базисных инструкций. 

 
Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Выводимость типов комбинаторов 
Тип a приписан комбинатору X тогда и только тогда, 
когда это утверждение получено из следующих аксиом 
(FI)
|— #(I) = (a, a),
(FK)
|— #(K) = (a, (b,a)) = (a, b, a),
(FS)
|— #(S) = ((a, (b, c)), ((a, b)(a, c)))
и правила вывода
(F) если |— #(X) = (a, b) и |— #(U) = a, то |— #(XU) = b.
Процедура контроля соответствия типов транслятора
языка программирования работает аналогичным образом.
 
 
 
Комментарий к слайду  
 
Оказывается, что комбинаторная логика обладает возможностью не только моделировать 
процесс 
реализации 
программного 
обеспечения 
на 
языке 
функционального 
программирования, но и прозрачно формализовать процедуру приписывания типов 
объектам этого языка.  
 
Под типом (или, иначе, сортом) будем понимать  относительно устойчивую и 
независимую 
совокупность 
элементов, 
которую 
можно 
выделить 
во 
всем 
рассматриваемом множестве (предметной области). Более подробно типизация языков 
программирования и теория типов будут рассмотрены нами в ходе следующей лекции. 
 
В случае комбинаторной логики будем считать, что тип a приписан комбинатору X тогда 
и только тогда, когда это утверждение получено из следующих аксиом 
  
(FI) 
  
|— #(I) = (a, a), 
(FK)  
|— #(K) = (a, (b,a)) = (a, b, a), 
(FS) 
 
|— #(S) = ((a, (b, c)), ((a, b)(a, c))) 
 
 
и правила вывода 
 
(F) 
если |— #(X) = (a, b) и |— #(U) = a, то |— #(XU) = b. 
 
 
Заметим, 
что 
процедура 
контроля 
соответствия 
типов 
транслятора 
языка 
программирования 
реализована 
сходным 
образом, 
причем 
в 
ней 
существенно 
используется механизм сопоставления с образцом. В языке программирования SML, 
кроме того, применятся механизм получения логического вывода о типе выражения, 
исходя из контекста его использования. Этот механизм, известный также как выводимость 
типов (type inference), адекватно моделируется в терминах комбинаторной логики. 
 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Реализация основных комбинаторов на SML
Приведем функции для базисных комбинаторов:
fun I x = x; 
(комбинатор тождества)
fun K x y = x; 
(комбинатор-канцелятор)
fun S x y z = x z (y z); 
(комбинатор-коннектор)
Произвольный терм комбинаторной логики выразим 
через приведенные базисные комбинаторы.
 
 
 
Комментарий к слайду  
 
В 
качестве 
иллюстрации 
естественности 
применения 
формальной 
системы 
комбинаторной логики для моделирования языка функционального программирования 
SML, приведем определения функций, реализующих характеристики некоторых из 
базисных комбинаторов: 
 
fun I x = x;  
 
 
 
 
fun K x y = x;  
 
 
 
 
fun S x y z = x z (y z); 
 
Реализация функций достаточно прозрачна и не требует пояснений.  
 
Заметим лишь, что функция I реализует комбинатор тождества I, функция K – 
комбинатор-канцелятор K, а функция S – комбинатор-коннектор S. 
 
Заметим в заключение, что произвольный терм комбинаторной логики выразим через 
приведенные базисные комбинаторы. 
 
 

Современные языки программирования и .NET: I семестр
Лекция 5: Комбинаторная логика как формальная система
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Библиография
1.
Schönfinkel M. ‘Über die Bausteine der matematischen 
Logik, Math. Annalen 92, pp. 305-316, 1924. 
2.
Curry H.B., Feys R. Combinatory logic, vol.I, North Holland, 
Amsterdam, 1958
3.
Hindley J.R., Seldin J.P. Introduction to combinators and λ-
calculus. London Mathematical Society Student Texts, 1, 
Cambridge University Press, 1986
4.
Hindley J.R. The principal type-scheme of an object in 
combinatory logic. Trans. Amer. Math. Soc., 146:29-60, 1969 
5.
Turner D.A. A new implementation technique for applicative 
languages. Software – Practice and Experience, 9:21-49, 1979
 
 
 
Комментарий к слайду  
 
К сожалению, в рамках времени, отведенных на одну лекцию, можно лишь в общих 
чертах охарактеризовать такую многоаспектную и гибкую теорию, как формальная 
система комбинаторной логики. Мы ограничились рассмотрением лишь наиболее 
существенных аспектов этой формализации языков функционального программирования, 
включая краткое знакомство с приписыванием типа и выводимостью типов.  
 
Для более детального ознакомления с особенностями, достижениями и проблемами в 
области комбинаторной логики рекомендуется следующий список литературы: 
 
1. Schönfinkel M. ‘Über die Bausteine der matematischen Logik, Math. Annalen 92, pp. 305-
316, 1924.  
 
2. Curry H.B., Feys R. Combinatory logic, vol.I, North Holland, Amsterdam, 1958 
 
3. Hindley J.R., Seldin J.P. Introduction to combinators and l-calculus. London Mathematical 
Society Student Texts, 1, Cambridge University Press, 1986 
 
4. Hindley J.R. The principal type-scheme of an object in combinatory logic. Trans. Amer. Math. 
Soc., 146:29-60, 1969  
 
5. Turner D.A. A new implementation technique for applicative languages. Software – Practice 
and Experience, 9:21-49, 1979 
 
Кратко остановимся на источниках. Работа [1] содержит обсуждение так называемых 
простых (simple) функций и предваряет появление комбинаторной логики. Работа [2] 
является энциклопедией формальной системы комбинаторной логики. Работа [3] 
связывает ламбда-исчисление и комбинаторную логику. Работа [4] описывает систему 
типизации комбинаторной логики. Работа [5] посвящена применению комбинаторов для 
практической реализации языков функционального программирования. 

