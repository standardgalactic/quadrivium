
Undergraduate Topics in Computer Science

Undergraduate Topics in Computer Science’ (UTiCS) delivers high-quality instructional content for un-
dergraduates studying in all areas of computing and information science. From core foundational and
theoretical material to ﬁnal-year topics and applications, UTiCS books take a fresh, concise, and modern
approach and are ideal for self-study or for a one- or two-semester course. The texts are all authored by
established experts in their ﬁelds, reviewed by an international advisory board, and contain numerous
examples and problems. Many include fully worked solutions.
Also in this series
Iain D. Craig
Object-Oriented Programming Languages: Interpretation
978-1-84628-773-2
Max Bramer
Principles of Data Mining
978-1-84628-765-7
Hanne Riis Nielson and Flemming Nielson
Semantics with Applications: An Appetizer
978-1-84628-691-9
Michael Kifer and Scott A. Smolka
Introduction to Operating System Design and Implementation: The OSP 2 Approcah
978-1-84628-842-5
Phil Brooke and Richard Paige
Practical Distributed Processing
978-1-84628-840-1
Frank Klawonn
Computer Graphics with Java
978-1-84628-847-0
David Salomon
A Concise Introduction to Data Compression
978-1-84800-071-1
David Makinson
Sets, Logic and Maths for Computing
978-1-84628-844-9
Orit Hazzan
Agile Software Engineering
978-1-84800-198-5
Pankaj Jalote
A Concise Introduction to Software Engineering
978-1-84800-301-9
Alan P. Parkes
A Concise Introduction to Languages and Machines
978-1-84800-120-6
Gilles Dowek
Principles of Programming Languages
978-1-84882-031-9

Frank Nielsen
A Concise and
Practical Introduction
to Programming
Algorithms in Java
1 3

Frank Nielsen
École Polytechnique
Paris
France
Sony Computer Science Laboratories, Inc.
Tokyo
Japan
Series editor
Ian Mackie, École Polytechnique, France
Advisory board
Samson Abramsky, University of Oxford, UK
Chris Hankin, Imperial College London, UK
Dexter Kozen, Cornell University, USA
Andrew Pitts, University of Cambridge, UK
Hanne Riis Nielson, Technical University of Denmark, Denmark
Steven Skiena, Stony Brook University, USA
Iain Stewart, University of Durham, UK
David Zhang, The Hong Kong Polytechnic University, Hong Kong
Undergraduate Topics in Computer Science ISSN 1863-7310
ISBN 978-1-84882-338-9
e-ISBN 978-1-84882-339-6
DOI 10.1007/978-1-84882-339-6
British Library Cataloguing in Publication Data
A catalogue record for this book is available from the British Library
Library of Congress Control Number: 2009921195
c⃝Springer-Verlag London Limited 2009
Apartfromanyfairdealingforthepurposesofresearchorprivatestudy,orcriticismorreview,aspermitted
under the Copyright, Designs and Patents Act 1988, this publication may only be reproduced, stored or
transmitted, in any form or by any means, with the prior permission in writing of the publishers, or in
the case of reprographic reproduction in accordance with the terms of licences issued by the Copyright
Licensing Agency. Enquiries concerning reproduction outside those terms should be sent to the publishers.
The use of registered names, trademarks, etc., in this publication does not imply, even in the absence of a
speciﬁc statement, that such names are exempt from the relevant laws and regulations and therefore free
for general use.
The publisher makes no representation, express or implied, with regard to the accuracy of the information
contained in this book and cannot accept any legal responsibility or liability for any errors or omissions
that may be made.
Printed on acid-free paper
Springer Science+Business Media
springer.com

To my family,
To Audrey and Julien.
“Dinosaur,” Julien, October 4th, 2008 (painting, 5 years old).

Preface
This concise textbook has been primarily designed for undergraduate students
as a very ﬁrst course in programming. The book requires no prior knowledge of
programming nor algorithms. It provides a gentle introduction to these topics.
The contents of this book have been organized into ten chapters split over two
parts, as follows:
– The ﬁrst part is concerned with getting ready to program basic tasks using
the modern language JavaTM. The fundamental notions of variables, expres-
sions, assignments with type checking are ﬁrst explained. We present the
conditional and loop statements that allow programmers to control the in-
struction work ﬂows. The concepts of functions with pass-by-value arguments
and recursion are explained. We proceed by presenting arrays and data en-
capsulation using objects, and insist on the notion of references for the latter.
– The second part of the book focuses on data-structures and algorithms. We
ﬁrst describe the fundamental sequential and bisection search techniques, and
analyze their respective eﬃciency using complexity analysis. Since the eﬀec-
tive bisection search requires sorted data, we then explain basic iterative and
recursive sorting algorithms. We follow by explaining linked lists and describe
common insertion/deletion/merge operations on them. We then introduce
the concept of abstract data-structures (illustrating them with queues and
stacks) and explain how to program them in Java using the object-oriented
style methods. Finally, the last chapter is an introduction to more evolved
algorithmic tasks that tackle combinatorial optimization problems.
The goal of this book is two-fold: Namely, during the ﬁrst part, novice pro-
grammers progressively learn the basic concepts underlying most imperative
programming languages using Java. The second part then introduces fresh pro-

viii
Preface
grammers with the very basic principles of thinking the algorithmic way, and
explain how to turn these algorithms into programs using the programming
concepts of Java. The book progressively conveys to the reader that “program-
ming” is in fact a complex task that consists of modeling a given problem,
designing algorithms and purposely structuring its data for solving the prob-
lem, coding the algorithm into a program, and ﬁnally, testing the program.
Each chapter of the book concludes with a set of exercises that lets students
practice notions covered by the chapter. The third part of the book consists of
an overall exam that allows readers to evaluate their assimilation level. A solu-
tion is provided. Exercises and sections that are recommended to be skimmed
through in a ﬁrst reading are indicated using the mark **.
Additional materials, including all Java source codes for each chapter, are avail-
able at the following book web page:
http:
//www.lix.polytechnique.fr/Labo/Frank.Nielsen/JavaProgramming/
Preface for Instructors
The Java programming curriculum (called INF311) from which this book has
been prepared has been taught at ´Ecole Polytechnique (Palaiseau, France) for
many years. Every year about 250 students enroll into the curriculum. For
most of them, it is their ﬁrst experience with the Java programming language.
Some of them have a prior programming experience using mathematical pack-
ages such as MapleTM which are interpreters. This yields an important source
of confusion not only from the standpoint of the language syntax but also
from the conceptual sides of using an imperative programming language. The
INF311 curriculum does not assume any prior programming experience and
concentrates on teaching the fundamental notions of programming an imper-
ative object-oriented language. This book is intended as a ﬁrst programming
course with two objectives in mind:
– Get a ﬁrsthand experience on programming basic algorithms using basic
features of Java, and
– Introduce the very ﬁrst fundamental concepts underlying computer science
(that is, complexity analysis, decidability, abstract data-structures, etc.).
The curriculum consists of ten lectures (each of them lasts 90 minutes) that
deal with the following topics:

Preface
ix
Lecture 1
Variables, expressions and assignments
(with an introduction to the science of computing)
Lecture 2
Conditional and loop statements
Lecture 3
Static functions and recursions
Lecture 4
Arrays
Lecture 5
Objects (data encapsulation without object methods)
Lecture 6
Rehearsal for mid-term programming exam
Lecture 7
Searching and sorting
Lecture 8
Linked lists
Lecture 9
Data-structures and object methods
Lecture 10
Combinatorial optimization algorithms
A ﬁrst course in programming without hands-on experience on writing pro-
grams by oneself is simply not conceivable. That is why each lecture is followed
by a two-hour programming training class to let students become familiar with
the notions covered during the lectures, and experience for themselves tracking
and correcting bugs.
To control the level of assimilation by students, we organize at mid-term of the
curriculum a two-hour programming exam that is semi-automatically checked
using scripts and Java input/output redirections. The ﬁnal exam is a two-hour
paper exam that focuses more on checking whether students understand the
basic data-structures and algorithms. A review exam with a detailed solution
is provided in Chapter 11 (page 227).
The pedagogic resources, which include slides of each lecture and recorded
videos of the lectures taught in the auditorium, are available at the following
web page:
http://www.enseignement.polytechnique.fr/informatique/INF311/
Frank Nielsen December 2008.
´Ecole Polytechnique (Palaiseau, France)
Sony Computer Science Laboratories, Inc. (Tokyo, Japan)
Acknowledgments
It is my great pleasure to acknowledge my colleagues, Professors Fran¸cois
Morain and Robert Cori at ´Ecole Polytechnique (France), who taught this
introductory course. I have greatly beneﬁted from their course materials but
more importantly from their feedback and advice. I express my deepest thanks
to Philippe Chassignet and the full team of teaching assistants for their shared

x
Preface
passion of letting students get their ﬁrst programs to compile and work; Many
thanks to Bogdan Cautis, Guillaume Chapuy, Philippe Chassignet, Etienne
Duris, Luca de F´eo, Yann Hendel, Andrey Ivanov, Vincent Jost, Marc Ka-
plan, Ga¨etan Laurent, David Monniaux, Giacomo Nannicini, Sylvain Pradalier,
St´ephane Redon Maria Naya Plasencia, Andrea Roeck, David Savourey, and
Olivier Serre.
This book became possible thanks to the warm encouragement and support
from Sony Computer Science Laboratories, Inc. I express my gratitude to
Dr. Mario Tokoro and Dr. Hiroaki Kitano, as well as all other members of
Sony Computer Science Laboratories, Inc.
I thank Ian Mackie for asking me to write this undergraduate textbook for the
Undergraduate Topics in Computer Science series on behalf of Springer-Verlag.
I apologize for any (involuntary) name omissions and remaining errors.
Finally my deepest thanks and love go to my family for their everlasting sup-
port.

Contents
List of Figures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .xvii
List of Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxi
Listings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxiii
Part I. Getting Started
1.
Expressions, Variables and Assignments . . . . . . . . . . . . . . . . . . . .
3
1.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.2
My ﬁrst Java programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.2.1
A minimalist program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.2.2
Hello World . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.3
Expressions and programs as calculators . . . . . . . . . . . . . . . . . . . . .
5
1.3.1
Arithmetic operations and priority order . . . . . . . . . . . . . .
6
1.3.2
Mathematical functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
1.3.3
Declaring constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.4
Commenting Java programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.5
Indenting programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.6
Variables, assignments and type checking . . . . . . . . . . . . . . . . . . . . 11
1.6.1
Variables for storing intermediate values. . . . . . . . . . . . . . . 12
1.6.2
Type checking for assignments and casting. . . . . . . . . . . . . 15
1.6.3
The inner mechanisms of assignments . . . . . . . . . . . . . . . . . 17

xii
Contents
1.7
Incrementing/decrementing variables . . . . . . . . . . . . . . . . . . . . . . . . 17
1.7.1
General mechanism for incrementation . . . . . . . . . . . . . . . . 17
1.7.2
Pre-incrementation and post-incrementation . . . . . . . . . . . 18
1.7.3
A calculator for solving quadratic equations . . . . . . . . . . . 19
1.8
Basics of Java input/output (I/O) . . . . . . . . . . . . . . . . . . . . . . . . . . 20
1.8.1
Computing does not mean displaying . . . . . . . . . . . . . . . . . 20
1.8.2
Keyboard input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
1.8.3
File redirections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
1.9
Bugs and the art of debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
1.10 Integrated development environments (IDEs) . . . . . . . . . . . . . . . . 26
1.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
1.11.1 Note to instructors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
1.11.2 First set of exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
2.
Conditional Structures and Loops . . . . . . . . . . . . . . . . . . . . . . . . . . 31
2.1
Instruction workﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
2.2
Conditional structures: Simple and multiple choices . . . . . . . . . . . 32
2.2.1
Branching conditions: if ... else ... . . . . . . . . . . . . . . 32
2.2.2
Ternary operator for branching instructions: Predicate
? A : B. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
2.2.3
Nested conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.2.4
Relational and logical operators for comparisons . . . . . . . . 36
2.2.5
Multiple choices: switch case . . . . . . . . . . . . . . . . . . . . . . . 39
2.3
Blocks and scopes of variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
2.3.1
Blocks of instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
2.3.2
Nested blocks and variable scopes . . . . . . . . . . . . . . . . . . . . 41
2.4
Looping structures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
2.4.1
Loop statement: while . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
2.4.2
Loop statement: do-while. . . . . . . . . . . . . . . . . . . . . . . . . . . 43
2.4.3
Loop statement: for . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
2.4.4
Boolean arithmetic expressions . . . . . . . . . . . . . . . . . . . . . . . 46
2.5
Unfolding loops and program termination . . . . . . . . . . . . . . . . . . . 47
2.5.1
Unfolding loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
2.5.2
Never ending programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
2.5.3
Loop equivalence to universal while structures . . . . . . . . . 48
2.5.4
Breaking loops at any time with break . . . . . . . . . . . . . . . . 48
2.5.5
Loops and program termination . . . . . . . . . . . . . . . . . . . . . . 48
2.6
Certifying programs: Syntax, compilation and numerical bugs . . 49
2.7
Parsing program arguments from the command line . . . . . . . . . . . 51
2.8
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

Contents
xiii
3.
Functions and Recursive Functions . . . . . . . . . . . . . . . . . . . . . . . . . 57
3.1
Advantages of programming functions . . . . . . . . . . . . . . . . . . . . . . . 57
3.2
Declaring and calling functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
3.2.1
Prototyping functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
3.2.2
Examples of basic functions. . . . . . . . . . . . . . . . . . . . . . . . . . 59
3.2.3
A more elaborate example: The iterative factorial function 60
3.2.4
Functions with conditional statements . . . . . . . . . . . . . . . . 61
3.3
Static (class) variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
3.4
Pass-by-value of function arguments . . . . . . . . . . . . . . . . . . . . . . . . 64
3.4.1
Basic argument passing mechanism . . . . . . . . . . . . . . . . . . . 64
3.4.2
Local memory and function call stack . . . . . . . . . . . . . . . . . 64
3.4.3
Side-eﬀects of functions: Changing the calling environment 67
3.4.4
Function signatures and function overloading . . . . . . . . . . 68
3.5
Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
3.5.1
Revisiting the factorial function: A recursive function . . . 71
3.5.2
Fibonacci sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
3.5.3
Logarithmic mean . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
3.6
Terminal recursion for program eﬃciency ** . . . . . . . . . . . . . . . . . 74
3.7
Recursion and graphics ** . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
3.8
Halting problem: An undecidable task . . . . . . . . . . . . . . . . . . . . . . . 77
3.9
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
4.
Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
4.1
Why do programmers need arrays? . . . . . . . . . . . . . . . . . . . . . . . . . 83
4.2
Declaring and initializing arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
4.2.1
Declaring arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
4.2.2
Creating and initializing arrays. . . . . . . . . . . . . . . . . . . . . . . 84
4.2.3
Retrieving the size of arrays: length . . . . . . . . . . . . . . . . . . 85
4.2.4
Index range of arrays and out-of-range exceptions . . . . . . 86
4.2.5
Releasing memory and garbage collector. . . . . . . . . . . . . . . 87
4.3
The fundamental concept of array references . . . . . . . . . . . . . . . . . 87
4.4
Arrays as function arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.5
Multi-dimensional arrays: Arrays of arrays . . . . . . . . . . . . . . . . . . . 93
4.5.1
Multi-dimensional regular arrays . . . . . . . . . . . . . . . . . . . . . 93
4.5.2
Multi-dimensional ragged arrays ** . . . . . . . . . . . . . . . . . . . 95
4.6
Arrays of strings and main function . . . . . . . . . . . . . . . . . . . . . . . . . 97
4.7
A basic application of arrays: Searching **. . . . . . . . . . . . . . . . . . . 99
4.8
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101

xiv
Contents
Part II. Data-Structures & Algorithms
5.
Objects and Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
5.1
Why do programmers need objects? . . . . . . . . . . . . . . . . . . . . . . . . 107
5.2
Declaring classes and creating objects . . . . . . . . . . . . . . . . . . . . . . . 108
5.2.1
Constructor and object creation . . . . . . . . . . . . . . . . . . . . . . 109
5.2.2
The common null object. . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
5.2.3
Static (class) functions with objects as arguments . . . . . . 111
5.3
Objects and references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
5.3.1
Copying objects: Cloning . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
5.3.2
Testing for object equality . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
5.4
Array of objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
5.5
Objects with array members . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
5.6
The standardized String objects . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
5.6.1
Declaring and assigning String variables . . . . . . . . . . . . . . 117
5.6.2
Length of a string: length(). . . . . . . . . . . . . . . . . . . . . . . . . 118
5.6.3
Equality test for strings: equals(String str) . . . . . . . . . 118
5.6.4
Comparing strings: Lexicographic order . . . . . . . . . . . . . . . 119
5.7
Revisiting a basic program skeleton . . . . . . . . . . . . . . . . . . . . . . . . . 122
5.8
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
6.
Searching and Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
6.1
Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
6.2
Searching information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
6.3
Sequential search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
6.3.1
Complexity of sequential search . . . . . . . . . . . . . . . . . . . . . . 131
6.3.2
Dynamically adding objects. . . . . . . . . . . . . . . . . . . . . . . . . . 131
6.3.3
Dichotomy/bisection search . . . . . . . . . . . . . . . . . . . . . . . . . . 133
6.4
Sorting arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
6.4.1
Sorting by selection: SelectionSort . . . . . . . . . . . . . . . . . . 135
6.4.2
Extending selection sort to objects . . . . . . . . . . . . . . . . . . . 136
6.4.3
Complexity of selection sorting . . . . . . . . . . . . . . . . . . . . . . . 138
6.5
QuickSort: Recursive sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
6.5.1
Complexity analysis of QuickSort . . . . . . . . . . . . . . . . . . . . . 140
6.6
Searching by hashing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
6.7
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
7.
Linked Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
7.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
7.2
Cells and lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
7.2.1
Illustrating the concepts of cells and lists . . . . . . . . . . . . . . 145

Contents
xv
7.2.2
List as an abstract data-structure . . . . . . . . . . . . . . . . . . . . 146
7.2.3
Programming linked lists in Java . . . . . . . . . . . . . . . . . . . . . 146
7.2.4
Traversing linked lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
7.2.5
Linked lists storing String elements . . . . . . . . . . . . . . . . . . . 148
7.2.6
Length of a linked list . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
7.2.7
Dynamic insertion: Adding an element to the list . . . . . . . 150
7.2.8
Pretty printer for linked lists . . . . . . . . . . . . . . . . . . . . . . . . . 151
7.2.9
Removing an element from a linked list . . . . . . . . . . . . . . . 151
7.2.10 Common mistakes when programming lists . . . . . . . . . . . . 153
7.3
Recursion on linked lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
7.4
Copying linked lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
7.5
Creating linked lists from arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
7.6
Sorting linked lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
7.6.1
Merging ordered lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
7.6.2
Recursive sorting of lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
7.7
Summary on linked lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
7.8
Application of linked lists: Hashing . . . . . . . . . . . . . . . . . . . . . . . . . 160
7.8.1
Open address hashing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
7.8.2
Solving collisions with linked lists . . . . . . . . . . . . . . . . . . . . 164
7.9
Comparisons of core data-structures . . . . . . . . . . . . . . . . . . . . . . . . 165
7.10 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
8.
Object-Oriented Data-Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
8.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
8.2
Queues: First in ﬁrst out (FIFO) . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
8.2.1
Queues as abstract data-structures: Interfaces . . . . . . . . . . 169
8.2.2
Basic queue implementation: Static functions . . . . . . . . . . 170
8.2.3
An application of queues: Set enumeration . . . . . . . . . . . . . 172
8.3
Priority queues and heaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
8.3.1
Retrieving the maximal element . . . . . . . . . . . . . . . . . . . . . . 175
8.3.2
Adding an element . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
8.3.3
Removing the topmost element . . . . . . . . . . . . . . . . . . . . . . . 177
8.4
Object-oriented data-structures: Methods . . . . . . . . . . . . . . . . . . . . 178
8.5
Revisiting object-oriented style data-structures . . . . . . . . . . . . . . 182
8.5.1
Object oriented priority queues . . . . . . . . . . . . . . . . . . . . . . 182
8.5.2
Object-oriented lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
8.6
Stacks: Last in ﬁrst out (LIFO) abstract data-structures . . . . . . . 185
8.6.1
Stack interface and an array implementation . . . . . . . . . . . 186
8.6.2
Implementing generic stacks with linked lists . . . . . . . . . . . 187
8.7
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189

xvi
Contents
9.
Paradigms for Optimization Problems . . . . . . . . . . . . . . . . . . . . . . 191
9.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
9.2
Exhaustive search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
9.2.1
Filling a knapsack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
9.2.2
Backtracking illustrated: The eight queens puzzle . . . . . . . 198
9.3
Greedy algorithms: Heuristics for guaranteed approximations . . 201
9.3.1
An approximate solution to the 0-1 knapsack problem. . . 201
9.3.2
A greedy algorithm for solving set cover problems . . . . . . 205
9.4
Dynamic programming: Optimal solution for the 0-1 knapsack
problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
9.5
Optimization paradigms: Overview of complexity analysis . . . . . 214
9.6
Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
10. The Science of Computing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
10.1 The digital world . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
10.2 Nature of computing? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
10.3 The digital equation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
10.4 Birth of algorithms and computers . . . . . . . . . . . . . . . . . . . . . . . . . . 222
10.5 Computer science in the 21st century . . . . . . . . . . . . . . . . . . . . . . . 223
Part III. Exam Review
11. Exam & Solution
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249

List of Figures
1.1
Implicit casting rules of primitive types . . . . . . . . . . . . . . . . . . . . . . . . . 16
1.2
Snapshot of the JCreator integrated development environment. . . . . 26
2.1
Visualizing unary, binary and ternary operators
. . . . . . . . . . . . . . . . . 34
2.2
A geometric interpretation of Euclid’s algorithm. Here, illustrated
for a = 65 and b = 25 (GCD(a, b) = 5) . . . . . . . . . . . . . . . . . . . . . . . . . . 43
2.3
Newton’s method for ﬁnding the root of a function . . . . . . . . . . . . . . . 44
3.1
Illustrating the function call stack: The function variables are allo-
cated into the local memory stack and are thus not visible to other
functions. The pass-by-value mechanism binds the function argu-
ments with the respective expression values at calling time . . . . . . . . . 65
3.2
Visualizing the local function call stack and the global memory for
program FunctionSideEffect.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
3.3
Visualizing the function call stack for the recursive factorial function. 72
3.4
Koch’s mathematical recursive snowﬂakes . . . . . . . . . . . . . . . . . . . . . . . 76
3.5
Sierpinski’s triangle fractal obtained by the program Sierpinski.java 78
4.1
A way to visualize arrays in Java, explained for the array declaration
and assignment: int [] v={2,3,1,2,7,1};.. . . . . . . . . . . . . . . . . . . . . . . . . . 89
4.2
Visualizing the structure of a ragged array in the global memory . . . 96
5.1
Visualizing the class ﬁelds and the object records when creating
object instances of a class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
5.2
Objects are non-primitive typed structures that are stored in the
program global memory and manipulated by references (and not by
values) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113

xviii
List of Figures
5.3
Testing for object equality using a tailored predicate that compares
ﬁeld by ﬁeld the objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
7.1
Creating a linked list by iteratively calling the static function
Insert. The arrows anchored at variable myList mean references
to objects of type ListString . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
7.2
Removing an element to the list by deconnecting its cell from the
other chained cells . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
8.1
A queue implemented using an array requires two indices to indicate
the last processed element and the ﬁrst free location . . . . . . . . . . . . . . 170
8.2
A heap is a binary tree specialized so that the keys of all children
are less than the keys of their parents . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
8.3
Adding element 25 to the heap: First, add a new node at the ﬁrst
immediate empty position; then eventually swap this node with its
parent until the heap property is recovered . . . . . . . . . . . . . . . . . . . . . . 176
8.4
Removing the maximal element of the heap: First, replace the root
by the last leaf node, and then potentially swap this node with its
current children until the heap property is recovered . . . . . . . . . . . . . . 177
9.1
Illustrating one of the 92 distinct solutions to the eight queen puzzle 198
9.2
The 0-1 knapsack problem consists of ﬁnding the set of items that
maximizes the overall utility while ﬁtting the knapsack capacity
. . . 202
9.3
Example of an instance of a set cover problem: (a) input range
space: set X
= {X1, ..., X12} of 12 elements and a collection
S = {{X1, X2}, {X5, X6}, {X9, X10}, {X2, X8}, {X6, X7, X10, X11},
{X1, X2, X3, X5, X9, X10, X11}, {X3, X4, X7, X8, X11, X12}} of 7 sub-
sets, and (b) optimal covering of size 3 since elements X1, X4 and
X6 are covered once by a diﬀerent subset . . . . . . . . . . . . . . . . . . . . . . . . 206
9.4
Set cover problem for urban radio network planning of mobile
phones: (a) Covering of 99 base transceiver stations, and (b) cover-
ing using only 19 base stations. Here, some redundant areas covered
more than four times . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
9.5
A bad instance for which the greedy set cover heuristic poorly be-
haves. This generic construction yields an approximation factor of
O(log n) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
10.1 In the digital world, all kinds of content is represented using univer-
sal binary strings. Furthermore, all this content can be appropriately
rendered using a universal computer. Nevertheless, for the consumer,
industry proposes many tailored devices . . . . . . . . . . . . . . . . . . . . . . . . . 220

List of Figures
xix
10.2 Once the content is available as a binary string we can apply generic
algorithms such as copying, compressing, transmitting or archiving
it without having to know, say, that it is a music or book string . . . . 221

List of Tables
1.1
Primitive data types of Java. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
7.1
Performance of various data-structures
. . . . . . . . . . . . . . . . . . . . . . . . . 165
9.1
Table of u(i, j) evaluations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
9.2
Extracting the solution from the dynamic programming table. Oi
and ¬Oi meaning that we selected/did not select object Oi, respec-
tively . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215

Listings
1.1
My ﬁrst Java program — A minimalist approach . . . . . . . . . . . . . .
3
1.2
The Hello World Java program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.3
Expression: Evaluating the volume of a 3D box. . . . . . . . . . . . . . . .
6
caption=Verbose program for calculating expressions . . . . . . . . . . . . . . .
6
1.4
Boolean expressions and boolean variable assignments. . . . . . . . . .
8
1.5
Program demonstrating the use of mathematical functions . . . . . .
9
1.6
Declaring constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
caption=Calculating the volume of a 3D box . . . . . . . . . . . . . . . . . . . . . . 10
1.7
Sketch of the balance sheet program . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.8
Balance sheet using integer variables . . . . . . . . . . . . . . . . . . . . . . . . . 12
1.9
Volume of a 3D box using double type variables . . . . . . . . . . . . . . 14
1.10 Java distinguishes upper/lower cases . . . . . . . . . . . . . . . . . . . . . . . . . 14
1.11 Variable names should not belong to the list of reserved keywords 16
1.12 A quadratic equation solver . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.13 Reading an integer value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.1
Quadratic equation solver with user input . . . . . . . . . . . . . . . . . . . . 33
2.2
Lazy evaluation of boolean predicates . . . . . . . . . . . . . . . . . . . . . . . . 38
2.3
Demonstration of the switch case statement . . . . . . . . . . . . . . . . . 40
2.4
Euclid’s Greatest Common Divisor (GCD). . . . . . . . . . . . . . . . . . . . 43
2.5
Newton’s approximation algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . 45
2.6
Cumulative sum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
2.7
Approaching π by Monte-Carlo simulation . . . . . . . . . . . . . . . . . . . . 46
2.8
Boolean arithmetic expression. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
2.9
Syracuse’s conjecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
2.10 Syntactically correct program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
2.11 Quadratic equation solver . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2.12 A simple numerical bug . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

xxiv
Listings
3.1
Basic program skeleton for deﬁning static functions . . . . . . . . . . . . 58
3.2
A basic demonstration class for deﬁning and calling static functions 59
3.3
Implementing the factorial function n! . . . . . . . . . . . . . . . . . . . . . . . 60
3.4
Function with branching structures . . . . . . . . . . . . . . . . . . . . . . . . . . 62
3.5
An example using a static (class) variable . . . . . . . . . . . . . . . . . . . . 63
3.6
Illustrating the function call stack . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
3.7
Pass-by-value does not change local variable of calling functions . 66
3.8
Toy example for illustrating how functions can change the envi-
ronment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
3.9
Function signatures and overloading . . . . . . . . . . . . . . . . . . . . . . . . . 69
3.10 Function signatures do not take into account the return type. . . . 70
3.11 Recursive implementation of the factorial function . . . . . . . . . . . . . 71
3.12 Displaying Fibonacci sequences using recursion . . . . . . . . . . . . . . . . 73
3.13 Logarithmic mean . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
3.14 Writing the factorial function using terminal recursion . . . . . . . . . 75
3.15 Fibonacci calculation using terminal recursion . . . . . . . . . . . . . . . . 75
3.16 Sierpinski’s fractal triangles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
3.17 Recursive Syracuse: Testing for termination . . . . . . . . . . . . . . . . . . . 78
3.18 Euclid’s greatest common divisor using recursion . . . . . . . . . . . . . . 80
4.1
Static array declarations and creations . . . . . . . . . . . . . . . . . . . . . . . 85
4.2
Arrays and index out of bounds exception . . . . . . . . . . . . . . . . . . . . 86
4.3
Arrays and references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
4.4
Assign an array reference to another array: Sharing common
elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
4.5
Printing the references of various typed arrays . . . . . . . . . . . . . . . . 89
4.6
Array argument in functions: Minimum element of an array . . . . . 90
4.7
Creating and reporting array information using functions . . . . . . . 91
4.8
Calculating the inner product of two vectors given as arrays . . . . 91
4.9
Function returning an array: Addition of vectors . . . . . . . . . . . . . . 92
4.10 Swapping array elements by calling a function . . . . . . . . . . . . . . . . 93
4.11 Matrix-vector product function. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
4.12 Creating multidimensional arrays and retrieving their dimensions 95
4.13 Writing to the output the arguments of the invoked main function 97
4.14 Array of strings in main . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
4.15 Sequential search: Exhaustive search on arrays . . . . . . . . . . . . . . . . 99
4.16 Binary search: Fast dichotomic search on sorted arrays . . . . . . . . . 100
4.17 Permuting strings and Java’s pass-by-reference . . . . . . . . . . . . . . . . 101
4.18 Bug in array declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
5.1
A class for storing dates with a constructor method . . . . . . . . . . . . 109
5.2
A small demonstration program using the Date class . . . . . . . . . . . 109
5.3
Objects as function parameters and returned results . . . . . . . . . . . 111

Listings
xxv
5.4
Testing the Date class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
5.5
Cloning objects: Two scenarii . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
5.6
Predicate for checking whether two dates of type Date are iden-
tical or not . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
5.7
The class XEvent and arrays of objects . . . . . . . . . . . . . . . . . . . . . . . 116
5.8
Lower/upper cases and ASCII codes of characters . . . . . . . . . . . . . 119
5.9
Lower-case to upper-case string conversion . . . . . . . . . . . . . . . . . . . . 120
5.10 Implementation of the lexicographic order on strings . . . . . . . . . . . 121
5.11 Reporting the lexicographically minimum string of the command
line arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
5.12 A more evolved basic skeleton program that also deﬁnes classes . 122
5.13 A class for polynomials. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
6.1
Structuring data of a dictionary into basic object elements . . . . . . 128
6.2
Linear search on objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
6.3
A demonstration program using the Person object array . . . . . . . 130
6.4
Adding new Person to the array . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
6.5
Bisection search on sorted arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
6.6
Sorting by selecting iteratively the minimum elements . . . . . . . . . . 135
6.7
Redeﬁning the predicate/swap primitives for sorting other types
of elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
6.8
Selection sort on a set of EventObject elements . . . . . . . . . . . . . . . 137
6.9
Experimentally calculating the worst-case complexity of selec-
tion sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
6.10 The partition procedure in QuickSort . . . . . . . . . . . . . . . . . . . . . . . . 139
6.11 Recursive sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
6.12 A demonstration code for hashing strings . . . . . . . . . . . . . . . . . . . . . 141
7.1
Declaration of a linked list . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
7.2
Linked list class with constructor and basic functions . . . . . . . . . . 147
7.3
Checking whether an element belongs to the list by traversing it. 148
7.4
Linked list storing String elements . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
7.5
Static (class) function computing the length of a list . . . . . . . . . . . 149
7.6
Inserting a new element to the list . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
7.7
Pretty printer for lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
7.8
Static function writing the structure of a linked list into a String
object. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
7.9
Removing an element from a list . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
7.10 Recursive function for computing the length of a list . . . . . . . . . . . 153
7.11 Recursive membership function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
7.12 Recursive display of a list . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
7.13 Reversed recursive display of a list . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
7.14 Copying iteratively a source list but reversing its order . . . . . . . . . 155

xxvi
Listings
7.15 Copying a source list by maintaining the original head-tail order 155
7.16 Merging two ordered linked lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
7.17 Recursively sorting an arbitrary linked list . . . . . . . . . . . . . . . . . . . . 159
7.18 Hashing a set of strings into a hash table . . . . . . . . . . . . . . . . . . . . . 161
7.19 A class for manipulating sparse polynomials . . . . . . . . . . . . . . . . . . 166
7.20 An example of signature function for the Karp-Rabin pattern
matching algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
8.1
A double queue with interface primitives implemented using
static functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
8.2
Enumerating set elements using queues. . . . . . . . . . . . . . . . . . . . . . . 172
8.3
Retrieving the maximal priority . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
8.4
Adding an element to the heap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
8.5
Removing the topmost element from the heap . . . . . . . . . . . . . . . . . 177
8.6
Linked list with static functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
8.7
Linked list with static functions attached to a Toolbox class . . . . 179
8.8
Static functions attached to a library class . . . . . . . . . . . . . . . . . . . . 180
8.9
Object methods for the list . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
8.10 Object-oriented method for computing the volume of a 3D box . . 182
8.11 Heap: Prototyping object methods . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
8.12 Linked list with object methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
8.13 Linked list the object-oriented style: Methods . . . . . . . . . . . . . . . . . 183
8.14 Demonstrating various calls of object methods . . . . . . . . . . . . . . . . 185
8.15 Stack implementation using an array . . . . . . . . . . . . . . . . . . . . . . . . . 186
8.16 Stack in action: A simple demonstration program . . . . . . . . . . . . . . 187
8.17 Minimal list implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
8.18 Implementing the stack interface using a linked list as its back-
bone data-structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
8.19 Demonstration program: Stacks using linked lists . . . . . . . . . . . . . . 189
9.1
Plain enumeration using nested loops . . . . . . . . . . . . . . . . . . . . . . . . 193
9.2
Enumerating all 2n binary number representations with n bits . . 194
9.3
Exhaustive search for the perfect ﬁlling of a knapsack . . . . . . . . . . 196
9.4
Adding a cut to the recursive exhaustive search . . . . . . . . . . . . . . . 197
9.5
Eight queen puzzle: Search with backtracking . . . . . . . . . . . . . . . . . 199
9.6
Check whether two queens are in mutually safe position or not . . 199
9.7
Check whether the i-th queen is safe wrt. the k-th queens, for
k < i . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
9.8
Solving the 8-queen puzzle. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
9.9
Greedy approximation algorithm for solving the 0-1 knapsack . . . 203
9.10 Initializing a set cover problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
9.11 Basic operations for supporting the greedy algorithm . . . . . . . . . . 208
9.12 Creating an instance of a set cover problem . . . . . . . . . . . . . . . . . . . 209

Listings
xxvii
9.13 Greedy algorithm for solving SCPs . . . . . . . . . . . . . . . . . . . . . . . . . . 209
9.14 Dynamic programming for solving the 0-1 knapsack. . . . . . . . . . . . 212
9.15 Extracting backward the optimal solution from the 2D table . . . . 213
exam/MysteriousProgram.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
11.1 The class Point3D . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
11.2 Class Atom with the bump predicate . . . . . . . . . . . . . . . . . . . . . . . . . . 231
11.3 Class Molecule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
11.4 Test program for Molecule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
11.5 The centroid of an Atom object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
11.6 The Molecule class equipped with the bump predicate . . . . . . . . . . 233
11.7 The various functions acting on Signal objects . . . . . . . . . . . . . . . 238
11.8 Nim game solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244

1
Expressions, Variables and Assignments
1.1 Introduction
In this chapter, we cover the very basics lying at the heart of every Java
program. That is, we introduce the minimalist program that forms the skeleton
common to all programs, and explain the programming cycle of writing,
compiling, editing and executing code. We provide an overview of the key
concepts of typed language and describe the primitive types of Java. Finally,
we present the syntax of arithmetic operators and give details on basic
input/output operations for writing our ﬁrst programs.
1.2 My ﬁrst Java programs
1.2.1 A minimalist program
When learning any new programming language, it is traditional to start by
ﬁrst looking at what programmers call the basic skeleton of any program.
This skeleton lets them gain some understanding of the language syntax and
presents the necessary wrapping code. First programs look often mystic, if not
weird, since they reveal at once some of the key syntax components of the
programming language. In its simplest form, consider the following “shortest”
Java program:
F. Nielsen, A Concise and Practical Introduction to Programming Algorithms in Java,
Undergraduate Topics in Computer Science, DOI 10.1007/978-1-84882-339-6 1,
c⃝Springer-Verlag London Limited, 2009

4
1. Expressions, Variables and Assignments
Program 1.1
My ﬁrst Java program — A minimalist approach
class
MyFirstProgram{
public
static void main ( String [
]
args )
{}
}
At ﬁrst, everything in the above code seems strange to novice programmers. In
fact, we will have to wait until Chapter 5 to get a full understanding of what
the ﬁrst two lines actually mean. For now let us ignore these lines. To execute
this program, we need to perform the following three steps:
– Type this program into any text editor1 and store this ﬁle under ﬁlename
MyFirstProgram.java. Extensions .java means that the ﬁle is a Java source
code. The name of the ﬁle should bear the name appearing after the class
keyword.
– Compile the program by typing at the console: javac MyFirstProgram.java.
This will generate a compiled ﬁle, called the bytecode, bearing the name
MyFirstProgram.class. Check in the directory2 that this ﬁle was created.
– Execute the program by typing the command java MyFirstProgram at the
console prompt. This will execute the bytecode of MyFirstProgram.class.
That is, it will run the program on the java virtual machine3 (JVM).
Well, the program ran correctly but produced no apparent result, so that it is
not very convincing to us that something really took place on the processor. In
fact, the main function of the program was called upon execution, and the set
of instructions contained inside the function was executed stepwise. Here, there
was nothing to execute since the body of the main function is empty; the body
of the main function is encapsulated into the program class MyFirstProgram
and is delimited by the opening/closing of braces {}, also called curly brackets.
So let us spice up this program by writing a message on the console output.
1.2.2 Hello World
The “Hello Word” program is the emblematic program for comparing at a
glance the syntax of diﬀerent programming languages. What we need to do is
to add a single instruction line inside the former program to display the message
1 Like Notepad under WindowsTM or Nedit in Linux-based KDE environments.
2 In Windows, type dir at the console prompt. In Unix, use the equivalent ls
command.
3 Java bytecode is cross-platform, which means that provided that there exists a JVM
implementation for the target machine, you will be able to run your bytecode on
that environment. This is one of the key strengths of Java in today’s market.

1.3 Expressions and programs as calculators
5
“Hello World.” Let us choose the program name to be HelloWorld.java. Then
we need to label the program class with that name too. To display a message,
we use the instruction System.out.println(message);. Instructions are followed by
a semi-colon “;” mark. Thus we get our slightly revised program:
Program 1.2
The Hello World Java program
class
HelloWorld{
public
static void main ( String [
]
args )
{
System . out . p r i n t l n ( "Hello World" ) ;
}
}
Again, let us go through the workﬂow of editing/compiling and running the
program as follows:
– Type this program and store it under ﬁlename HelloWorld.java.
– Compile this program by typing in the console: javac HelloWorld (im-
plicitly meaning javac HelloWorld.java). A bytecode HelloWorld.class
is produced in the same directory. The bytecode is not human readable, only
machine readable! Try to open the ﬁle and look at the strange sequence of
symbols that encode this compiled program. At this stage, it should be clear
that ﬁles ending with the extension .java are source codes, and ﬁles ending
with extensions .class are bytecodes.
– Execute the program by typing the command java HelloWorld (implicitly
meaning java HelloWorld.class) at the console prompt.
You will now get the result visible in the output console as follows:
Hello World
Congratulations, you successfully wrote your ﬁrst program. Let us now see how
to perform arithmetic calculations.
1.3 Expressions and programs as calculators
The ﬁrst program you may think of is to compute formulas4 for various input.
Assume, for example, we are given a 3D box with the following dimensions:
4 Historically, this objective was one of the very ﬁrst motivations for programming
languages. FORTRAN, which stands for FORmula TRANslation, is such an
example that was widely used by physicists for simulation purposes. Although
FORTRAN is nowadays a bit outdated, there is still a lot of legacy code running
daily (for example, weather forecasting).

6
1. Expressions, Variables and Assignments
50cm in width, 100cm in height and 20cm in depth. We simply do compute
the volume in cubic meters m3 by converting the dimension units into meter
equivalents and performing the product of these dimensions to get the volume.
Thus the volume of that 3D box is
0.5m × 1m × 0.2m = 0.1m3.
How do we program this? We simply need to evaluate the arithmetic expression
0.5 × 1 × 0.2
Program 1.3
Expression: Evaluating the volume of a 3D box
class VolumeBox{
public
static void main ( String [
]
args )
{
System . out . p r i n t l n ( 0 . 5 ∗1 ∗0 . 2 ) ;
}
}
Storing the above program into ﬁlename VolumeBox.java, compiling and
executing it, we get the expected output:
0.1
Thus we can calculate the value of any arithmetic expression, say the generic
myExpression expression, and display its value by executing the instruction
System.out.println(myExpression); Of course, this straight number alone is not
very informative, so it is better to display a message on the console telling
what the number really means. We do this by printing the message without
the return carriage (line return) using the instruction System.out.print.
class VerboseVolumeBox{
public
static void main ( String [
]
args )
{
System . out . print ( "Volume of the box (in cubic meters):" ) ;
System . out . p r i n t l n ( 0 . 5 ∗1 ∗0 . 2 ) ;
}
}
Compiling and running this program yields the better verbose output:
Volume of the box (in cubic meters):0.1
1.3.1 Arithmetic operations and priority order
The arithmetic operations used in expressions are:
– The addition (+)

1.3 Expressions and programs as calculators
7
– The subtraction (-)
– The multiplication (*)
– The division (/)
– The modulo (remainder, %)
These operations depend on the type of operands, and yield the usual bugs.
For example, consider the variable q deﬁned as:
int q=2/3;
This initializes the integer variable q to 0 since the division / is the Euclidean
division.5
Programmers have to take care with variable initializations, especially when
implicit casting occurs. To illustrate these points, consider the following code
snippet:
double qq=2/3;
double qqq=2/3.0;
Although variable qq is declared of type double the division operands 2 and 3
have been identiﬁed as integers so that the compiler will compute the Euclidean
division and get the integer 0, which will then be implicitly cast into a double
(see Figure 1.1): 0.0. However, when declaring and initializing double variable
qqq, since the second operand is of type double, the ﬁrst operand will be cast
into a double, and the double division will be performed yielding the expected
result: 0.6666666666666666.
The operators unambiguously satisfy priority rules so that parentheses may be
omitted when forming expressions for ease of reading. For example, consider the
expression 7+9*6. This expression admits two kinds of parentheses: (7+9)*6
and 7+(9*6). But since the multiplication has higher priority over the addition,
it is understood that the expression 7+9*6 is meant to be 7+(9*6), and
evaluates to 61.
As we will see in the next chapter, an important class of expressions are boolean
expressions, which are used in program control structures. Boolean expressions
admit only two outcomes: true or false. The most common logical operators
are && for AND and for OR. Thus for boolean variables a and b, the boolean
expression a&&b; is evaluated to true if and only if both a and b are true. The
following program presents the use of boolean expressions and boolean variable
assignments:
5 In Euclidean division, x/y computes the Euclidean ratio of x by y, and x%y
computes the remainder.

8
1. Expressions, Variables and Assignments
Program 1.4
Boolean expressions and boolean variable assignments
class
BooleanExpression {
public
static void main ( String [
]
args )
{
boolean a=true ;
boolean b=false ;
boolean expr1=a | | b ;
boolean expr2=a&&b ;
System . out . print ( "a||b=" ) ;
System . out . p r i n t l n ( expr1 ) ;
System . out . print ( "a&&b=" ) ;
System . out . p r i n t l n ( expr2 ) ;
}
}
Compiling and running this program, we get the following console output:
a||b=true
a&&b=false
Boolean expressions and their role in program workﬂows will be presented in
the next chapter.
1.3.2 Mathematical functions
In Java, mathematical functions including trigonometric sine and cosine
functions and constants are all encapsulated into the Math class. The most
usual functions6 are summarized in the table below:
6 Refer to the on-line documentation at http://java.sun.com/j2se/1.4.2/docs/
api/java/lang/Math.html for complete description of the available set of
functions.

1.3 Expressions and programs as calculators
9
Math.PI
π (3.141592...)
Math.E
e (2.71828...)
Math.abs(x)
x (absolute value)
Math.ceil(x)
⌈x⌉(ceil function)
Math.round(x)
round to nearest integer
Math.sqrt(x)
√x (square root function)
Math.log(x)
ln x (loge x)
Math.log10(x)
log10 x
Math.pow(x,y)
xy (power function)
Math.cos(x)
cos x (cosine function)
Math.sin(x)
sin x (sine function)
Math.tan(x)
tan x (tangent function)
The program below demonstrates a more elaborate program for computing a
formula:
Program 1.5
Program demonstrating the use of mathematical functions
class
MathFunction{
public
static void main ( String [
]
args )
{
double x=Math .E;
double fx=Math . log (x) ;
System . out . print ( "Is this precisely 1 or are there numerical
errors? " ) ;
System . out . p r i n t l n ( fx ) ;
x=Math . PI / 1 5 . 0 ;
fx=Math . sin (x) ∗Math . sin (x)+Math . cos (x) ∗Math . cos (x) ;
System . out . print ( "What about this trigonometric equality (
should be 1) ?" ) ;
System . out . p r i n t l n ( fx ) ;
}
}
The output of the program is:
Is this precisely 1 or are there numerical errors? 1.0
What about this trigonometric equality (should be 1) ?1.0000000000000002
Note that the constant Math.E is deﬁned as the double value that is closer than
any other to e. Observe that in the second case, we should mathematically have
the identity sin2 θ + cos2 θ = 1, but due to numerical imprecisions, we end up
only with a very close number: 1.0000000000000002.

10
1. Expressions, Variables and Assignments
1.3.3 Declaring constants
Constants are declared by prepending to the type of variables the keyword
static. That is, constants are immutable variables. Constants are also typed
too. For instance, we may wish to deﬁne our own approximation of the
mathematical constant π as follows:
final double PI = 3.14;
The declaration of constants should be made inside the body of the class (and
not inside functions).
Program 1.6
Declaring constants
class
ConstantDeclaration
{
final
static
int One=1;
final
static
int Two=2;
public
static void main ( String
[ ]
args )
{
int Three=One+Two;
System . out . p r i n t l n ( Three ) ;
}
}
1.4 Commenting Java programs
It is useful to comment programs to describe parts of the code and the various
input/output formats of programs. Not only does it become crucial for us when
revisiting a program months later, it also becomes absolutely necessary when
sharing a program with others. Java has two types of comments: single lines
and multiple lines illustrated as below:
// This is a single line comment
/* I can also write comments on
several lines
by using these delimiters */
Let
us
illustrate
the
comment
syntax
by
commenting
the
former
VerboseVolumeBox.java program:
/*
This program computes the volume of a 3D box
*/
class VerboseVolumeBox{

1.5 Indenting programs
11
public
static void main ( String [
]
args )
{
System . out . print ( "Volume of the box (in cubic meter):" ) ;
// Result is in cubic meter unit
System . out . p r i n t l n ( 0 . 5 ∗1 ∗0 . 2 ) ;
}
}
1.5 Indenting programs
Java source codes are parsed by the compiler javac, which checks the syntax
of the program and generates an overly optimized bytecode that is a low-level
machine-interpretable bytecode. Indenting a program consists of making the
source code prettier by adding a few extra spaces or return lines. Indenting
consists of applying several conventions like aligning columns of opening/closing
braces, etc. Code indentation does not change the bytecode. For example, the
following badly indented source code will produce the same bytecode although
it obfuscates its readibility.
class
NotIndentedVolumeBox{public
static void main ( String [
]
args ) {System . out . print ( "Volume of the box (in cubic
meter):" ) ; System . out . p r i n t l n ( 0 . 5 ∗1 ∗0 . 2 ) ;}}
As a rule of thumb, it is important for programmers to comment and indent
source codes well to improve their readibility. Indenting also helps browsing
lengthy source codes.
1.6 Variables, assignments and type checking
Suppose now that we would like to compute the balance of a set of credits
with a set of debits. We ﬁrst need to compute the total credit ﬁgure, then the
total debit ﬁgure and subtract these two ﬁgures to get the balance. Computing
the total credit and debit can be done and displayed using the former syntax
System.out.println(myExpression);. But what about the balance? For example,
consider we have two credit lines (say, 100 and 150 dollars), and three debit
lines (50, 25 and 100 dollars). Then, we would have the following code:
Program 1.7
Sketch of the balance sheet program
class
BalanceSheet {
public
static void main ( String [
]
args )

12
1. Expressions, Variables and Assignments
{
System . out . print ( "Total credit (in US dollars):\t" ) ;
System . out . p r i n t l n (100+150) ;
System . out . print ( "Total debit (in US dollars):\t" ) ;
System . out . p r i n t l n (50+25+100) ;
System . out . print ( "Balance:" ) ;
}
}
Running this program, we get:
Total credit (in US dollars):
250
Total debit (in US dollars):
175
Note that the \t inside the string "Total credit (in US dollars):\t" denotes
the tabulation character that allows one to nicely align the latter numbers. The
problem is to get the balance we need to subtract 175 from 250. Of course, this
could be computed and displayed with the instruction:
System.out.println((100+150)-(50+25+100));
...but this will not yield an eﬃcient approach since we would again compute the
two cumulative credit/debit sums. A much better strategy consists of storing
intermediate calculations in containers by using variables, as explained next.
1.6.1 Variables for storing intermediate values
In Java, variables are all typed. Java belongs to the large category of typed
programming languages. This means that we need to specify the type of
variables when declaring variables. To declare a variable named credit for
storing the overall credit modeled as an integer number, we use the syntax:
int credit;
Variables always need to be declared before use. By convention, we choose
in this textbook to declare all variables at the beginning of the main block
(delimited by the braces {}). In this application, we consider that credit/debit
numbers are natural numbers (integers), so that we declare the variable to be
of type int.
Program 1.8
Balance sheet using integer variables
class
BalanceSheet2 {
public
static void main ( String [
]
args )
{
int
c r e d i t ;
int
debit ;

1.6 Variables, assignments and type checking
13
c r e d i t =100+150;
System . out . print ( "Total credit (in US dollars):\t" ) ;
System . out . p r i n t l n ( c r e d i t ) ;
debit =50+25+100;
System . out . print ( "Total debit (in US dollars):\t" ) ;
System . out . p r i n t l n ( debit ) ;
System . out . print ( "Balance:" ) ;
System . out . p r i n t l n ( credit −debit ) ;
}
}
Running the above program, we get the console output:
Total credit (in US dollars):
250
Total debit (in US dollars):
175
Balance:75
In Java, we can choose to declare variables using one of the following primitive
types7: int (integer simple precision stored onto a machine word of 32 bits),
long (integer double precision stored onto two machine words, 64 bits), float
(simple precision real stored onto a machine word), double (double precision
real ), char (character encoding worldwide language characters using 16 bits8)
and boolean (two states: true or false). Table 1.1 lists the primitive types
of Java with their respective encoding representations and range of values. All
primitive types of Java are manipulated by value.
Boolean boolean
1 bit
true or false
Character char
2 bytes
UNICODE
Integer byte
1 byte
[−128, 128]
Integer short
2 bytes
[−32768, 32767]
Integer int
4 bytes
[−231 = −2147483648, 231 −1 = 21477483647]
Integer long
8 bytes
[−263 = −9223372036854775808, 263 −1 = 9223372036854775807]
Real float
4 bytes
[1.40129846432481707e −45f, 3.40282346638528860e + 38f]
Real double
8 bytes
[2.2250738585072014e −308d, 1.79769313486231570e + 308d]
Table 1.1
Primitive data types of Java.
We can also compactly declare and initialize variables at once as follows:
7 There is also the less used byte and short primitive types that we voluntarily omit
in this book.
8 Java uses the UNICODE standard for coding characters using 16 bits (2
bytes). This allows programmers to encode a wide range of characters including
Chinese/Korean and Japanese kanji. The traditional 8-bit ASCII encoding is
limited to the Roman alphabet.

14
1. Expressions, Variables and Assignments
int credit1=100, credit2=150;
int credit=credit1+credit2;
int debit1=50, debit2=25, debit3=100;
int debit=debit1+debit2+debit3;
int balance=credit-debit;
System.out.print("Balance:");
System.out.println(balance);
This example illustrates two constructions:
– Variable declaration and assignment to a constant (a basic expression — see
for example, variable credit1)
– Variable declaration and assignment to an arithmetic expression (see for
example, variable debit1).
As we have formerly seen, variables are useful for storing initial values. Thus
these variables play an important role in the initialization of programs. For
example, the former program for computing the volume of a 3D box can be
rewritten as:
Program 1.9
Volume of a 3D box using double type variables
class VerboseVolumeBox2{
public
static void main ( String [
]
args )
{
double width =0.5 ,
height =1.0 , depth =0.2;
System . out . print ( "Volume of the box (in cubic meter):" ) ;
System . out . p r i n t l n ( width∗height ∗depth ) ;
}
}
Java distinguishes upper from lower case in variable names, as exempliﬁed
below:
Program 1.10
Java distinguishes upper/lower cases
class
UpperLowerCase
{
public
static void main ( String
arguments [ ] )
{
int MyVar ;
// myvar variable is different from MyVar
int myvar ;
// Generate a syntax error at compile time:
// cannot find symbol variable myVar
System . out . p r i n t l n (myVar) ;
}
}
That is, Java is case-sensitive.

1.6 Variables, assignments and type checking
15
1.6.2 Type checking for assignments and casting
1.6.2.1 Type checking.
Whenever assigning a variable, the compiler javac
checks that the type of the expression coincides with the type of the variable.
If not, the compiler reports an error message and aborts (without generating
proper bytecode). For example, consider the code below:
class TypeError{
public static void main (String[ ] args)
{
double myFavoriteReal=3.141592;
int myFavoriteNat=2.71;
}
}
Compiling this code will generate an error as follow:
prompt%javac TypeError.java
TypeError.java:5: possible loss of precision
found
: double
required: int
int myFavoriteNat=2.71;
^
1 error
prompt%
That is, the compiler performed the type checking and found that the type
of the expression (here, the real constant 2.71 of type double) does not agree
with the type of the int variable myFavoriteNat. Typing provides an essential
safeguard mechanism for writing more coherent programs, that is programs
without obvious bugs.
1.6.2.2 Casting types.
We can eventually transform that real 2.71 by
truncating it into the integer 2 by a casting operation:
int myFavoriteNat=(int)2.71;
This results in a loss of precision, as noticed by the compiler.
In general, we can explicitly cast a type TypeExpr into a TypeVar using the
following syntax:
TypeVar myVar=(TypeExpr)(Expression);
Typed languages such as Java are useful to abstract notions and types of
variables characterizing semantic parameters. In college, we are familiar with
similar notions to assign quantity of the same units. For example, it does not
make sense to assign to a velocity (type m×s−1) an acceleration (type m×s−2).
In fact, some earlier casting operations were already carried out when declaring
and initializing constants:

16
1. Expressions, Variables and Assignments
double x=2; // implicit casting
int ->double
double x=(double) 2; // explicit casting
long x =2.0; // implicit casting double ->long
double x=2.0d ;
// The constant 2.0 is declared of type double
// add a ’d’ after the number
The implicit casting rules of primitive types are summarized in Figure 1.1.
byte
short
int
long
float
double
char
Figure 1.1
Implicit casting rules of primitive types
For example, consider the following code snippet that implicitly casts a
character (of type char) into its corresponding ASCII integer code:
char c=’X’;
int code=c;
System.out.println(code);
We get the ASCII code 88 for the capital letter ’X’.
There are slight restrictions on the names of variables that should not begin
with a digit, nor bear the name of a reserved keyword of the language. Trying
to use a reserved keyword for the name of a variable will result in a compiler
error as illustrated in the following code:
Program 1.11
Variable names should not belong to the list of reserved
keywords
class
ReservedKeyword
{public
static void main ( String
arg [ ] ) {
double x , y ;
// Generate a syntax error:
// "not a statement"
int import ;
}
}

1.7 Incrementing/decrementing variables
17
The list of reserved keywords for Java is: abstract, assert, boolean,
break, byte, case, catch, char, class, const, continue, default,
do, double, else, extends, false, final, finally, float, for,
goto, if, implements, import, instanceof, int, interface, long,
native, new, null, package, private, protected, public, return,
short, static, strictfp, super, switch, synchronized, this, throw,
throws, transient, true, try, void, volatile, while .
1.6.3 The inner mechanisms of assignments
The prototype instruction for assigning a variable var of type TypeVar is the
following atomic instruction:
var=Expression;
The compiler proceeds the following three steps:
– Evaluate the expression Expression into a value,
– Check that the type of the value coincides with the type of the variable
(type checking). If not, check whether some implicit casting rules apply (see
Figure 1.1). If types cannot coincide, then the compiler generates an error
message and aborts.
– Store the value of the expression at the memory location referenced by the
variable.
We further explain these two sides value/memory location of variables in the
next section dealing with special assignment instructions: variable increments.
1.7 Incrementing/decrementing variables
1.7.1 General mechanism for incrementation
Incrementing a variable x by an amount increment (that is, incrementing the
variable x by a step of width increment) consists of adding to the value of the
variable the value of the increment, and in storing the result at the memory
location referenced by variable x. Incrementing a variable without specifying
its amount means to add one to its value. Incrementation is thus nothing other
than a particular form of assignment where a variable appears on both sides of
the equality sign =:
x=x+increment;

18
1. Expressions, Variables and Assignments
The variable on the left hand side means “store at the memory location
referenced by that variable,” while the variable on the right hand side means
“get the value stored at the memory location referenced by that variable.” For
programmer novices, the instruction x=x+increment; is quite confusing at ﬁrst
since it makes no mathematical sense. Let us deconstruct the action taken by
the compiler when encountering such an instruction:
– Evaluate arithmetic expression x+increment:
– Perform type checking of increment with x (cast increment type if
necessary),
– Get the value xVal stored at memory location referenced by x,
– Get the value incrementVal stored at memory location referenced by
increment,
– Return the value xVal+incrementVal.
– Finally, store the expression value at memory location referenced by x.
Instead of writing x=x+increment, we can equivalently write this instruction
compactly using the following shortcut:
x+=increment
Similarly, we can decrement a variable by a given step as follows:
x-=increment
These basic shortcuts extend9 also to the / and ∗operators:
int y=1;
y*=3; // y=3, multiplication assignment
int z=12;
z/=2; // z=6, division assignment
int p=23;
p%=2; // p=1, modulo assignment
1.7.2 Pre-incrementation and post-incrementation
Often we need to add or subtract one to (the value of) a variable, say x. This
can be done as follows:
x=x+1;
x+=1; // compact form
x=x-1;
x-=1; // compact form
9 These shortcut instructions are, however, rarely used in practice.

1.7 Incrementing/decrementing variables
19
These incrementation instructions are so frequent that they can be ei-
ther written compactly as ++x or x++ (for pre-incrementation and post-
incrementation). Let us explain the diﬀerence between pre-incrementation and
post-incrementation:
Consider the following code:
i=2;
j=i++;
This gives the value 3 to i and 2 to j as we do a post-incrementation. That
is, we increment after having evaluated the expression i++. The above code is
equivalent to:
i=2;
j=i;
i=i+1; // or equivalently i+=1;
Alternatively, consider the pre-incrementation code:
i=2;
j=++i;
This code is equivalent to...
i=2;
i=i+1;
j=i;
... and thus both the values of i and j are equal to 3 in this case. The same
explanations hold for pre-decremention −−i and post-decrementation i−−.
Note that technically speaking the ++ syntax can be seen as a unary operator.
1.7.3 A calculator for solving quadratic equations
Let us put altogether the use of mathematical functions with variable initializa-
tions and assignments in a simple program that computes the roots b±
√
b2−4ac
2a
of a quadratic equation ax2 + bx + c = 0:
Program 1.12
A quadratic equation solver
class
QuadraticEquationSolver
{
public
static void main ( String [ ]
arg )
{
double a , b , c ;
a=Math . sqrt ( 3 . 0 ) ;
b=2.0;
c=−3.0;
double delta=b∗b−4.0∗a∗c ;
double root1 ,
root2 ;

20
1. Expressions, Variables and Assignments
root1= (−b−Math . sqrt ( delta ) ) /(2.0∗a ) ;
root2= (−b+Math . sqrt ( delta ) ) /(2.0∗a ) ;
System . out . p r i n t l n ( root1 ) ;
System . out . p r i n t l n ( root2 ) ;
System . out . p r i n t l n ( "Let us check the roots:" ) ;
System . out . p r i n t l n ( a∗root1 ∗root1+b∗root1+c ) ;
System . out . p r i n t l n ( a∗root2 ∗root2+b∗root2+c ) ;
}
}
Note that for this particular initialization, we have delta>0. Otherwise, there
are imaginary roots, and the program will crash in the Math.sqrt function.
1.8 Basics of Java input/output (I/O)
In this section, we quickly review the elementary instructions for reading or
writing on the console. We will then see how to redirect input/output from/to
ﬁles.
1.8.1 Computing does not mean displaying
In Java, one needs to explicitly display results on the console to read them back.
Printing the results on the console is one way to retrieve or export the results
of programs. This is very diﬀerent from most mathematical symbolic systems
such as Maple R⃝,10 which computes and displays results at once. For example,
in Maple computing 2 + 2 will not only compute the sum but also display the
result 4:
>2+2;
4
This is one frequent source of confusion for beginners who have had prior
“programming” experience with such mathematical packages. Remember that
in Java, we need to explicitly display results.
1.8.1.1 Displaying results on the console.
To display messages on the console
in Java, one invokes either System.out.println for writing a string message
with a return line, or System.out.print for writing a message without the
return line. One can also display integers, reals or strings. Since it is quite
cumbersome to write several System.out.print[ln] at a row like:
10 http://www.maplesoft.com/

1.8 Basics of Java input/output (I/O)
21
System.out.println("The value of x is ");
System.out.print(x);
To bypass these two instructions, one often uses string concatenations when
formatting messages compactly.
1.8.1.2 Displaying & String concatenations.
The former code is equivalent
to the following:
System.out.println("The value of x is "+x);
For novice programmers, this code looks like a magic expression for outputting
messages on the console. However, this can also at ﬁrst yield unexpected results
for beginners like:
int x=3;
System.out.println("value="+x+1);
Since the printed message on the console is 31, and not 4 as one would expect.
The correct result would have been obtained by setting parentheses around x+1
as follows:
System.out.println("value="+(x+1));
The trick is that the + between "value=" and (x+1) has a diﬀerent semantic
than the + in x+1. What happens is that in the former case, the argument
"value="+x+1 of System.out.println is evaluated following the priority order
rules. That is, the compiler cast the integer value x into a string “3” and
appends it to string “value=” giving the string “value=3.” Then the integer 1 is
converted into the string “1” and appended to “value=3” giving the ﬁnal string
“value=31.” Setting parenthesis around x + 1 let us change the priority order,
so that x + 1 is ﬁrst evaluated to give integer 4, and then string concatenation
are performed after casting the 4 into the corresponding string “4.”
The following program summarizes and exempliﬁes our discussion:
int a=1, b=−2;
System . out . print ( "a=" ) ;
System . out . print ( a ) ;
System . out . print ( " b=" ) ;
System . out . p r i n t l n (b) ;
System . out . p r i n t l n ( "a="+a+" b="+b) ;
String
s1="Lecture in" ,
s2=" Java" ;
String
s=s1+s2 ; // Perform explicit string concatenation
System . out . p r i n t l n ( s ) ;
1.8.2 Keyboard input
Programs often require users to give interactive parameters that play an
important role in initialization of programs. At each run, the program asks for

22
1. Expressions, Variables and Assignments
some user keyboard input to deliver the solution. Java I/O is quite elaborate
compared to other similar imperative languages like C++ because it has been
designed to ﬁt the object-oriented style that will be explained later on. For
now, consider reading input from the console using the following syntax:
Program 1.13
Reading an integer value
import java . u t i l . ∗;
class
KeyboardIntInput{
public
static void main ( String
[ ]
args )
{
Scanner
keyboard=new Scanner ( System . in ) ;
int
val ;
System . out . print ( "Enter an integer please:" ) ;
val=keyboard . nextInt () ;
System . out . print ( "I read the following value:" ) ;
System . out . p r i n t l n ( val ) ;
}
}
The output of a running session gives:
Enter an integer please:5
I read the following value:5
In the former code, we again used two magic lines, import java.util.∗; and
Scanner keyboard=new Scanner(System.in);, which will be fully explained later,
in the second part of this book.
We can similarly read float and double values using keyboard.nextFloat(); and
keyboard.nextDouble() instructions:
System . out . print ( "Enter a single -precision real please:" ) ;
v a l f=keyboard . nextFloat () ;
System . out . print ( "I read the following value:" ) ;
System . out . p r i n t l n ( v a l f ) ;
System . out . print ( "Enter a double precision please:" ) ;
vald=keyboard . nextDouble () ;
System . out . print ( "I read the following value:" ) ;
System . out . p r i n t l n ( vald ) ;
In case the above code snippet yields an error at run time, which is due to
the number formatting conventions 11, add the instruction keyboard.useLocale(
Locale.US);
11 In the US, real numbers are written using the a decimal dot “.” while in European
countries it is a decimal comma “,.” By default, Java is installed with the country
local settings.

1.8 Basics of Java input/output (I/O)
23
1.8.3 File redirections
Instead of writing messages to the console, one can redirect them to a text ﬁle
without changing the source code, using the > symbol in the command line.
For example consider the following toy program, which asks for an integer and
squares it:
import java . u t i l . ∗;
class
SmallProg{
public
static void main ( String
[ ]
args )
{
Scanner
keyboard=new Scanner ( System . in ) ;
int
val ;
System . out . print ( "Enter an integer please:" ) ;
val=keyboard . nextInt () ;
val∗=val ;
// squared the input value
System . out . p r i n t l n ( "Squared value="+val ) ;
}
}
Running the program from the console, we get:
prompt%java SmallProg
Enter an integer please:5
Squared value=25
Let us now store the output message into a text ﬁlename output.txt. We have
prompt%java SmallProg >output.txt
4
The above number 4 is the number input by the user when running the program.
Let us inspect the ﬁle named output.txt by opening it:
Enter an integer please:Squared value=16
Thus all messages printed out using the instruction System.out.print[ln] have
been redirected to ﬁlename output.txt. Similarly, we can set the input of a
program from a ﬁlename by redirecting the input from the command line using
the symbol <. Let us create a ﬁle input.txt containing the (string) value 4.
We can now execute the program by redirecting its input as follows:
prompt%java SmallProg <input.txt
Enter an integer please:Squared value=16
... or redirect both input/output:
prompt%java SmallProg <input.txt >output.txt
This will overwrite the former output ﬁle output.txt.

24
1. Expressions, Variables and Assignments
1.9 Bugs and the art of debugging
Writing programs that are syntaxically correct straight from the keyboard is
very rare. This seldom happens. This is why whatever textbook on Java one
may read, it will never replace the experience of programming. The experience
of programming consists of getting familiar with the way of thinking about the
architecture of a program and translating these thoughts into corresponding
language instructions. Sometimes a small typographic error in the source code
yields many subsequent listed errors by the compiler. Indeed, Java compiler
javac complains a lot and compiler comments are often verbose to help
programmers get to the point. Consider this program to train yourself to spot
the syntax errors:
class SyntaxBug{
public
static void main ( String
[ ]
args )
{
/*
Ask for a value
/
double val , fval;
fval=3*val*Val+2;
System.out.println("f(x)="+val);
}
}
Trying to compile this code will result in the following compiler error message:
prompt%javac SyntaxBug.java
SyntaxBug.java:5: unclosed comment
/*
^
SyntaxBug.java:13: reached end of file while parsing
}?
^
2 errors
Let us correct the multiple-line comment that lacks the closing ∗/
class SyntaxBug{
public static void main(String [] args)
{
/*
Ask for a value
/
double val, fval;
fval=3*val*Val+2;
System.out.println("f(x)="+val);

1.9 Bugs and the art of debugging
25
}
}
Recompiling this code will then reveal the uppercase mistyping of variable
Val. Once corrected, the program can ﬁnally be compiled into an executable
bytecode. This toy example emphasizes the incremental strategy for correcting
programs.
In general, correcting a program consists of ﬁrst making it syntactically correct
so that the compiler can indeed parse the code and generate a corresponding
bytecode. Then comes the task of making the program semantically correct.
That is, to test and better prove that the program indeed solves the problem in
all instances and not only on a particular test suite. This is a far more diﬃcult
and challenging task that has not yet been solved today. For very speciﬁc
codes like embarked codes on airplanes, there exist mathematical techniques12
to prove that these codes are indeed correct and resilient to all kinds of input.
But these techniques hold only for these very speciﬁc codes. So be prepared
in your programming life to discover bugs later on, even if you have already
successfully used some code for many years. Remember that unless you prove
your code, you cannot guarantee that it is crash-free.
Proving that a program is correct is all the more diﬃcult since numbers are
represented in machines using ﬁnite representations (4 or 8 bytes depending
on whether single or double precision is used). Thus usually remarkable
mathematical identities like elog x = log ex = x on variables may fail as they
do not detect potential overﬂow problems that yield not only incorrect result
but may potentially crash a system. For example, consider the two primitives
types for storing natural numbers in Java:
– int: the maximum machine-representable int is 231 −1.
– long: the maximum machine-representable long is 263 −1.
Let us now perform some incrementation instructions as follows:
class
OverflowBug{
public
static void main ( String
[ ]
args )
{
int n=2147483647; //2^31-1
int
nval=n+1;
System . out . p r i n t l n ( "If n="+n+" then n+1="+nval ) ;
long m=9223372036854775807L ;
// 2^63-1
long mval=m+1;
System . out . p r i n t l n ( "If m="+m+" then m+1="+mval ) ;
}
12 For example, the branch of so-called static analysis.

26
1. Expressions, Variables and Assignments
}
Note that we initialized the long variable m by appending a “L” to the long
digit to tell the compiler that this is a natural number using double precision.
Otherwise, the compiler would have complained that our integer (int) was too
big. Now, compile and execute this basic code to see the incoherent results:
prompt%java OverflowBug
If n=2147483647 then n+1=-2147483648
If m=9223372036854775807 then m+1=-9223372036854775808
One gets negative numbers, quite an unexpected result, isn’t it? Loosely
speaking, what happened is that the incrementation generated a carry that
was propagated to the sign bit of the number type (the 32th and 64th bit
respectively). These numbers were then decoded as negative numbers.
1.10 Integrated development environments
(IDEs)
Figure 1.2
Snapshot of the JCreator integrated development environment
Once you get used to programming basic java programs, it will become more
and more cumbersome to type the various compiler/execution commands. Even
simple programs with small mistyped characters may generate long lists of

1.11 Exercises
27
compiler errors that are diﬃcult to browse. Programmers often used what
is called an integrated development environment to increase the productivity
cycle of writing programs. The most famous one is called Eclipse13. It is
free of charge and used worldwide. Moreover, Eclipse is written using Java
itself. Another free recommended IDE is JCreator. Using these IDEs, it is
easy to compile and execute programs using the keyboard function F1-12 keys.
Moreover, when the compiler reports a list of bugs, one can just click on the
bug line to directly access the corresponding part of the source code. IDEs
also help nicely indent code and highlight reserved keywords with various user
personalized colors. It provides many functionalities (like expanding/shrinking
code capabilities) to help navigate into codes. For example, looking at
Figure 1.2, we would have found the bad closing comment even before compiling
that code since the code would not have been nicely colored: That is, some
instructions would have been colored using the comment green color instead of
the regular black color.
1.11 Exercises
1.11.1 Note to instructors
The exercise section is primarily designed for a two-hour machine session
with small groups of students. For some of the students, the ﬁrst session
will also be their very ﬁrst hands-on experience using a Unix OS machine;
Indeed, universities often provide a Linux-based park of consoles.14 It is thus
worthwhile describing the basic OS commands like cd, mkdir, pwd, ls, and job
task commands. For Windows users, we recommend the JCreator v3.5 free
integrated development environment.15
In this chapter, we have described the very basics for writing simple Java
programs that calculate formulas. We have provided an overview of the
framework for developing Java applications.
For this ﬁrst exercise session, it is thus worth spending some time to get students
familiar with the programming environment (usually on Windows or Linux
operating systems). For example, as a warm-up:
– Create a simple Java source code that computes and prints to the output
sin π
6 . Compile this code and execute it.
13 http://www.eclipse.org/
14 At
´Ecole
Polytechnique
(Paris,
France),
we
use
the
KDE
environment
(http://www.kde.org/) with the Nedit text editor (http://www.nedit.org/).
15 Available for download at http://www.jcreator.com/download.htm

28
1. Expressions, Variables and Assignments
– Edit the former ﬁle to add cos π
6 and check numerically whether sin2 π
6 +
cos2 π
6 = 1 or not, recompile the code, etc.
– Copy the ﬁle and rename it to implement another simple program that
computes, say, a triangle area, etc.
Then we suggest readers become familiar with input/output (I/O) ﬁle redirec-
tions (< and > symbols in command line) before proceeding to the following
exercises.
1.11.2 First set of exercises
Exercise 1.1 (Time conversion)
Write a program Convert.java that converts a given number of seconds
int seconds; into the format of hours, minutes and seconds. Print this
equivalent number of seconds using a formatting rule like HH:MM:SS.
Exercise 1.2 (Time conversion with user keyboard input)
Modify the previous program to read the number of seconds from the
console. Let us call this program ConvertIO.java. For example, the
program execution will yield the following session:
How many seconds? 4000
4000 s = 1 hour, 6 min and 40 sec
Create an input text ﬁle inputsec.txt that contains the line 4000, and
run the program by redirecting both input and output to text ﬁles:
prompt% java ConvertIO <inputsec.txt
...
prompt% java ConvertIO <inputsec.txt >result.txt
Exercise 1.3 (Time comparison)
Design a program that compares two time durations (in hour/min/sec
format) by ﬁrst converting them into their respective total number of sec-
onds, and then comparing the two delays using the if (booleanPredicate
) {} else {} conditional. This voluntarily anticipates the next chapter.
Write another program for comparing the two durations but without
converting them into a total number of seconds. Declare two boolean
values Smaller and Bigger both initialized to false. Then compare
the respective hours, and decide whether we need to assign one of these
boolean values to true or not. For hours matching, test the minutes,

1.11 Exercises
29
etc., up to the seconds. Finally, report on the console the outcome based
on these boolean values.
Exercise 1.4 (From a linear to a quadratic solver)
We consider a linear equation y = ax + b where a and b are given
parameters (using double type). Write a program that calculates the
root of ax+b = 0. That is, the y-intercept of the line with the x-axis. How
to extend it to quadratic equations ax2 + bx + c = 0? Observe numerical
rounding phenomena that emphasize that roots slightly diﬀer from their
mathematical roots because of ﬁnite precision of number representations.
Exercise 1.5 (Java syntax for constant declarations)
Explain why the program below does not compile. How should it be
modiﬁed in order to compile properly?
class
ConstantExercise
{
static
final
int MAX = 10;
public
static void main ( String
[ ]
args )
{
double
f i ;
static
final double GoldenRatio =(1.0d+Math . sqrt (5) ) / 2 . 0 ;
for ( int
i =0; i<MAX; i++)
{
f i=GoldenRatio∗Math . cos (2.0∗Math . PI∗i /(double)MAX) ;
System . out . p r i n t l n ( "i="+i+" f(i)="+f i ) ;
}
}
}

2
Conditional Structures and Loops
2.1 Instruction workﬂow
In this chapter, we start by describing how programmers can control the
execution paths of programs using various branching conditionals and looping
structures. These branching/looping statements act on blocks of instructions
that are sequential sets of instructions. We ﬁrst explain the single choice if
else and multiple choice switch case branching statements, and then describe
the structural syntaxes for repeating sequences of instructions using either the
for, while or do while loop statements. We illustrate these key conceptual
programming notions using numerous sample programs that emphasize the
program workﬂow outcomes. Throughout this chapter, the leitmotiv is that
the execution of a program yields a workﬂow of instructions. That is, for short:
Program runtime = Instruction workﬂow
F. Nielsen, A Concise and Practical Introduction to Programming Algorithms in Java,
Undergraduate Topics in Computer Science, DOI 10.1007/978-1-84882-339-6 2,
c⃝Springer-Verlag London Limited, 2009

32
2. Conditional Structures and Loops
2.2 Conditional structures: Simple and multiple
choices
2.2.1 Branching conditions: if ... else ...
Programs are not always as simple as plain sequences of instructions that are
executed step by step, one at a time on the processor. In other words, programs
are not usually mere monolithic blocks of instructions, but rather compact
structured sets of instruction blocks whose executions are decided on the ﬂy.
This gives a program a rich set of diﬀerent instruction workﬂows depending on
initial conditions.
Programmers often need to check the status of a computed intermediate
result to branch the program to such or such another block of instructions
to pursue the computation. The elementary branching condition structure in
many imperative languages, including Java, is the following if else instruction
statement:
if (booleanExpression)
{BlockA}
else
{BlockB}
The boolean expression booleanExpression in the if structure is ﬁrst
evaluated to either true or false. If the outcome is true then BlockA is
executed, otherwise it is BlockB that is selected (boolean expression evaluated
to false). Blocks of instructions are delimited using braces {...}. Although the
curly brackets are optional if there is only a single instruction, we recommend
you set them in order to improve code readibility. Thus, using a simple if
else statement, we observe that the same program can have diﬀerent execution
paths depending on its initial conditions. For example, consider the following
code that takes two given dates to compare their order. We use the branching
condition to display the appropriate console message as follows:
int h1
= . . . , m1 = . . . ,
s1
= . . . ;
// initial conditions
int h2
= . . . , m2 = . . . ,
s2
= . . . ;
// initial conditions
int
hs1 = 3600∗h1 + 60∗m1 + s1 ;
int
hs2 = 3600∗h2 + 60∗m2 + s2 ;
int d=hs2−hs1 ;
i f
(d>0) System . out . p r i n t l n ( "larger" ) ;
else
System . out . p r i n t l n ( "smaller or identical" ) ;
Note that there is no then keyword in the syntax of Java. Furthermore, the
else part in the conditional statement is optional:

2.2 Conditional structures: Simple and multiple choices
33
if (booleanExpression)
{BlockA}
Conditional structures allow one to perform various status checks on variables
to branch to the appropriate subsequent block of instructions. Let us revisit
the quadratic equation solver:
Program 2.1
Quadratic equation solver with user input
import java . u t i l . ∗;
class
QuadraticEquationRevisited
{
public
static void main ( String [ ]
arg )
{
Scanner
keyboard=new Scanner ( System . in ) ;
System . out . print ( "Enter a,b,c of equation ax^2+bx+c=0:" ) ;
double a=keyboard . nextDouble () ;
double b=keyboard . nextDouble () ;
double c=keyboard . nextDouble () ;
double delta=b∗b−4.0∗a∗c ;
double root1 ,
root2 ;
i f
( delta >=0)
{
root1= (−b−Math . sqrt ( delta ) ) /(2.0∗a ) ;
root2= (−b+Math . sqrt ( delta ) ) /(2.0∗a ) ;
System . out . p r i n t l n ( "Two real roots:"+root1+" "+root2 ) ;
}
else
{System . out . p r i n t l n ( "No real roots" ) ;}
}
}
In this example, we asserted that the computations of the roots root1 and
root2 are possible using the fact that the discriminant delta>=0 in the block
of instructions executed when expression delta>=0 is true. Running this
program twice with respective user keyboard input 1 2 3 and -1 2 3 yields
the following session:
Enter a,b,c of equation ax^2+bx+c=0:1 2 3
No real roots
Enter a,b,c of equation ax^2+bx+c=0:-1 2 3
Two real roots:3.0 -1.0
In the if else conditionals, the boolean expressions used to select the
appropriate branchings are also called boolean predicates.

34
2. Conditional Structures and Loops
2.2.2 Ternary operator for branching instructions:
Predicate ? A : B
In Java, there is also a special compact form of the if else conditional
used for variable assignments called a ternary operator. This ternary operator
Predicate ? A : B provided for branching assignments is illustrated in the
sample code below:
double x1=Math . PI ;
// constants defined in the Math class
double x2=Math .E;
double min=(x1>x2 ) ? x2
:
x1 ;
// min value
double
d i f f= ( x1>x2 ) ? x1−x2
:
x2−x1 ;
// absolute value
System . out . p r i n t l n (min+" difference with max="+d i f f ) ;
Executing this code, we get:
2.718281828459045 difference with max=0.423310825130748
The compact instruction
double min=(x1>x2)? x2 : x1;
...is therefore equivalent to:
double min;
if (x1>x2) min=x2;
else min=x1;
Figure 2.1 depicts the schema for unary, binary and ternary operators.
++
a
*
a
b
? :
Predicate a
b
Unary operator
Binary operator
Ternary operator
a++
a*b
(Predicate?
a :
b)
post-incrementation
multiplication
compact branching
Figure 2.1
Visualizing unary, binary and ternary operators

2.2 Conditional structures: Simple and multiple choices
35
2.2.3 Nested conditionals
Conditional structures may also be nested yielding various complex program
workﬂows. For example, we may further enhance the output message of our
former date comparison as follows:
int h1
= . . . , m1 = . . . ,
s1
= . . . ;
int h2
= . . . , m2 = . . . ,
s2
= . . . ;
int
hs1 = 3600∗h1 + 60∗m1 + s1 ;
int
hs2 = 3600∗h2 + 60∗m2 + s2 ;
int d=hs2−hs1 ;
i f
(d>0) {System . out . p r i n t l n ( "larger" ) ;}
else
{ i f
(d<0)
{System . out . p r i n t l n ( "smaller" ) ;}
else
{System . out . p r i n t l n ( "identical" ) ;}
}
Since these branching statements are all single instruction blocks, we can also
choose to remove the braces as follows:
if (d>0) System.out.println("larger");
else
if (d<0)
System.out.println("smaller");
else
System.out.println("identical");
However, we do not recommend it as it is a main source of errors to novice
programmers. Note that in Java there is no shortcut1 for else if. In Java, we
need to write plainly else if. There can be any arbitrary level of nested if
else conditional statements, as shown in the generic form below:
i f
( predicate1 )
{Block1}
else
{
i f
( predicate2 )
{Block2}
else
{
i f
( predicate3 )
{Block3}
else
{
. . .
}
}
1 In some languages such as Maple R
⃝, there exists a dedicated keyword like elif.

36
2. Conditional Structures and Loops
}
In general, we advise to always take care with boolean predicates that use
the equality tests == since there can be numerical round-oﬀerrors. Indeed,
remember that machine computations on reals are done using single or double
precision, and thus the result may be truncated to ﬁt the formatting of numbers.
Consider for example the following tiny example that illustrates numerical
imprecisions of programs:
class RoundOff
{
public
static void main ( String [ ]
arg )
{
double a=1.0d ;
double b=3.14d ;
double c=a+b ;
i f
( c==4.14) // Equality tests are dangerous!
{
System . out . p r i n t l n ( "Correct" ) ;
}
else
{
System . out . p r i n t l n ( "Incorrect. I branched on the wrong
block!!!" ) ;
System . out . p r i n t l n ( "a="+a+" b="+b+" a+b=c="+c ) ;
// unexpected behavior may follow...
}
}
}
Running this program, we get the surprising result caused by numerical
precision problems:
Incorrect. I branched on the wrong block!!!
a=1.0 b=3.14 a+b=c=4.140000000000001
This clearly demonstrates that equality tests == in predicates may be harmful.
2.2.4 Relational and logical operators for comparisons
The relational operators (also called comparison operators) that evaluate to
either true or false are the following ones:

2.2 Conditional structures: Simple and multiple choices
37
<
less than
<=
less than or equal to
>
greater than
>=
greater than or equal to
==
equal to
!=
not equal to
One of the most frequent programming errors is to use the equality symbol =
instead of the relational operator == to test for equalities:
int x=0;
if (x=1) System.out.println("x equals 1");
else
System.out.println("x is different from
1");
Fortunately, the compiler generates an error message since in that case types
boolean/int are incompatible when performing type checking in the expression
x=1. But beware that this will not be detected by the compiler in the case of
boolean variables:
boolean x=false;
if (x=true) System.out.println("x is true");
else
System.out.println("x is false");
In that case the predicate x=true contains an assignment x=true and the
evaluated value of the “expression” yields true, so that the program branches
on the instruction System.out.println("x is true");.
A boolean predicate may consist of several relation operators connected using
logical operators from the table:
&&
and
||
or
!
not
The logic truth tables of these connectors are given as:
&&
true
false
true
true
false
false
false
false
||
true
false
true
true
true
false
true
false
Whenever logical operators are used in predicates, the boolean expressions are
evaluated in a lazy fashion as follows:
– For the && connector, in Expr1 && Expr2 do not evaluate Expr2 if Expr1
is evaluated to false since we alreaady know that in that case that Expr1
&& Expr2 = false whatever the true/false outcome value of expression
Expr2.

38
2. Conditional Structures and Loops
– Similarly, for the || connector, in Expr1 || Expr2 do not evaluate Expr2 if
Expr1 is evaluated to true since we already know that in that case Expr1
|| Expr2 = true whatever the true/false value of expression Expr2.
The lazy evaluation of boolean predicates will become helpful when manipu-
lating arrays later on. For now, let us illustrate these notions with a simple
example:
Program 2.2
Lazy evaluation of boolean predicates
class
LazyEvaluation {
public
static void main ( String [ ]
args )
{
double x=3.14 , y =0.0;
boolean test1 ,
t e s t 2 ;
// Here division by zero yields a problem
// But this is prevented in the && by first checking
whether the denominator is
// zero or not
i f
(( y !=0.0) && (x/y>2.0) )
{// Do nothing
;
}
else
{// Block
t e s t 1 =(y !=0.0) ;
t e s t 2 =(x/y>2.0) ;
System . out . p r i n t l n ( "Test1:"+t e s t 1+" Test2:"+t e s t 2 ) ;
System . out . p r i n t l n ( "We did not evaluate x/y that is
equal to "+(x/y) ) ;
}
// Here , again we do not compute x/y since the first term
is true
i f
(( y==0.0)
| |
(x/y>2.0) )
{// Block
System . out . p r i n t l n ( "Actually , again , we did not
evaluate x/y that is equal to "+(x/y) ) ;
}
}
}
Running this program, we get the following console output:
Test1:false Test2:true
We did not evaluate x/y that is equal to Infinity
Actually, again, we did not evaluate x/y that is equal to Infinity

2.2 Conditional structures: Simple and multiple choices
39
2.2.5 Multiple choices: switch case
The nested if else conditional instructions presented in § 2.2.3 are somehow
diﬃcult to use in case one would like to check that a given variable is equal
to such or such a value. Indeed, nested blocks of instructions are diﬃcult to
properly visualize on the screen. In the case of multiple choices, it is better
to use the switch case structure that branches on the appropriate set of
instructions depending on the value of a given expression. For example, consider
the code:
class
ProgSwitch
{public
static void main ( String
arg [ ] ) {
System . out . print ( "Input a digit in [0..9]:" ) ;
Scanner
keyboard=new Scanner ( System . in ) ;
int n=keyboard . nextInt () ;
switch (n)
{
case
0:
System . out . p r i n t l n ( "zero" ) ;
break ;
case
1:
System . out . p r i n t l n ( "one" ) ;
break ;
case
2:
System . out . p r i n t l n ( "two" ) ;
break ;
case
3:
System . out . p r i n t l n ( "three" ) ;
break ;
default :
System . out . p r i n t l n ( "Above three!" ) ;
break ;
}}}
The conditional statement switch consider the elementary expression n of type
int and compare it successively with the ﬁrst case: case 0. This means that
if (n==0)Block1 else \{ ... \}. The set of instructions in a case should end
with the keyword break. Note that there is also the default case that contains
the set of instructions to execute when none of the former cases were met. The
formal syntax of the multiple choice switch case is thus:
switch ( TypedExpression )
{
case C1 :
SetOfInstructions1 ;
break ;
case C2 :
SetOfInstructions2 ;
break ;
. . .
case Cn:
SetOfInstructionsn ;
break ;
default :
SetOfDefaultInstructions ;
}
}

40
2. Conditional Structures and Loops
Multiple choice switch conditionals are often used by programmers for
displaying messages2:
Program 2.3
Demonstration of the switch case statement
int dd=3; // 0 for Monday , 6 for Sunday
switch (dd)
{
case
0:
System . out . p r i n t l n ( "Monday" ) ;
break ;
case
1:
System . out . p r i n t l n ( "Tuesday" ) ;
break ;
case
2:
System . out . p r i n t l n ( "Wednesday" ) ;
break ;
case
3:
System . out . p r i n t l n ( "Thursday" ) ;
break ;
case
4:
System . out . p r i n t l n ( "Friday" ) ;
break ;
case
5:
System . out . p r i n t l n ( "Saturday" ) ;
break ;
case
6:
System . out . p r i n t l n ( "Sunday" ) ;
break ;
default :
System . out . p r i n t l n ( "Out of scope!" ) ;
}
2.3 Blocks and scopes of variables
2.3.1 Blocks of instructions
A block of instructions is a set of instructions that is executed sequentially.
Blocks of instructions are delimited by braces, as shown below:
{
// This is a block
// (There are no control structures inside it)
Instruction1;
Instruction2;
...
}
A block is semantically interpreted as an atomic instruction at a macroscopic
level when parsing.
2 Or used for translating one type to another when used in functions

2.4 Looping structures
41
2.3.2 Nested blocks and variable scopes
Blocks can be nested. This naturally occurs in the case of if-else structures
that may internally contain other conditional structures. But this may also be
possible without conditional structures for controlling the scope of variables.
Indeed, variables deﬁned in a block are deﬁned for all its sub-blocks. Thus
a variable cannot be redeﬁned in a sub-block. Moreover variables deﬁned in
sub-blocks cannot be accessed by parent blocks as illustrated by the following
example:
class
NestedBlock
{
public
static void main ( String [ ]
arg )
{
int
i =3;
int
j =4;
System . out . p r i n t l n ( "i="+i+" j="+j ) ;
{
// Cannot redefine a variable i here
int
i i =5;
j++;
i −−;
}
System . out . p r i n t l n ( "i="+i+" j="+j ) ;
// Cannot access variable ii here
}
}
i=3 j=4
i=2 j=5
Finally note that single instructions in control structures such as if-else are
interpreted as implicit blocks where braces are omitted for code readibility.
2.4 Looping structures
Loop statements are fundamental structures for iterating a given sequence of
instructions, repeating a block of instructions. Java provides three kinds of
constructions for ease of programming, namely: while, for and do-while.
Theoretically speaking, these three diﬀerent constructions can all be emulated
with a while statement. We describe the semantic of each structure by
illustrating it with concrete examples.

42
2. Conditional Structures and Loops
2.4.1 Loop statement: while
The syntax of a while loop statement is as follows:
while (boolean_expression)
{block_instruction;}
This means that while the boolean expression is evaluated to true, the
sequence of instructions contained in the block instruction is executed.
Consider calculating the greatest common divisor (gcd for short) of two integers
a and b. That is, the largest common divisor c such that both a and b can be
divided by c. For example, the GCD of a = 30 and b = 105 is 15 since a = 2×3×
5 and b = 5×3×7. Euclid came up with a simple algorithm published for solving
this task. The algorithm was reported in his books Elements around3 300 BC.
Computing the GCD is an essential number operation that requires quite a
large amount of computation for large numbers. The GCD problem is related
to many hot topics of cryptographic systems nowadays. Euclid’s algorithm is
quite simple: If a = b then clearly the GCD of a and b is c = a = b. Otherwise,
consider the largest integer, say a without loss of generality, and observe the
important property that
GCD(a, b) = GCD(a −b, b).
Therefore, applying this equality reduces the total sum a + b, and at some
point, after k iterations, we will necessarily have ak = bk. Let us prove a
stronger result: GCD(a, b) = GCD(b, a mod b).
Proof
To see this, let us write a = qb + r where q is the quotient of the Euclidean
division and r its reminder. Any common divisor c of a and b is also a common
divisor of r: Indeed, suppose we have a = ca′ and b = cb′, then r = a −qb =
(a′ −qb′)c. Since all these numbers are integers, this implies that r is divisible
by c. It follows that the greatest common divisor g or a and b is also the greatest
common divisor of b and r.
Let us implement this routine using the while loop statement. The terminating
state is when a = b. Therefore, while a ̸= b (written in Java as a!=b), we retrieve
that smaller number to the larger number using a if conditional structure. This
gives the following source code:
3 It is alleged that the algorithm was likely already known in 500 BC.

2.4 Looping structures
43
Program 2.4
Euclid’s Greatest Common Divisor (GCD)
class GCD {
public
static void main ( String [ ]
arg )
{
int a ;
int b ;
while ( a!=b)
{
i f
(a>b) a=a−b ;
else b=b−a ;
}
System . out . p r i n t l n ( a ) ;
// or b since a=b
}
}
Running this program for a = 30 and b = 105 yields GCD(a, b) = 15.
Euclid’s algorithm has a nice geometric interpretation: Consider an initial
rectangle of width a and height b. Bisect this rectangle as follows: Choose
the smallest side, and remove a square of that side from the current rectangle.
Repeat this process until we get a square: The side length of that square is the
GCD of the initial numbers. Figure 2.2 depicts this “squaring” process.
Figure
2.2
A ge-
ometric interpretation
of Euclid’s algorithm.
Here,
illustrated
for
a = 65 and b = 25
(GCD(a, b) = 5)
2.4.2 Loop statement: do-while
Java provides another slightly diﬀerent syntax for making iterations: the do
loop statement. The diﬀerence with a while statement is that we execute at
least once the sequence of instructions in a do statement, whereas this might not
be the case of a while statement, depending on the evaluation of the boolean
predicate. The syntax of a do structure is as follows:

44
2. Conditional Structures and Loops
do
{block_instruction;}
while (boolean_expression);
That is, the boolean expression is evaluated after the block of instructions,
and not prior to its execution, as it is the case for while structures. Consider
computing the square root √a of a non-negative number a using Newton’s
method. Newton’s method ﬁnds the closest root to a given initial condition x0
of a smooth function by iterating the following process: Evaluate the tangent
equation of the function at x0, and intersect this tangent line with the x-axis:
This gives the new value x1. Repeat this process until the diﬀerence between
two successive steps go beyond a prescribed threshold (or alternatively, repeat
k times this process). For a given value xn, we thus ﬁnd the next value xn+1
by setting the y-ordinate of the tangent line at (xn, f(xn)) to 0:
y = f ′(xn)(x −xn) + f(xn) = 0.
x
y = f(x)
f
xn
xn+1
xn+1 = xn −
f(x)
f ′(xn)
f(xn)
y = f ′(xn)(x −xn) + f(xn)
Tangent line
xn+2
Figure 2.3
Newton’s method for ﬁnding the root of a function
It follows that we get:
xn+1 = xn −f(x)
f ′(xn).
Figure 2.3 illustrates this root ﬁnding process. Let us use Newton’s method to
calculate the square root function of a by ﬁnding the root of equation f(x) =
x2 −a. We implement the loop using a do structure as follows:

2.4 Looping structures
45
Program 2.5
Newton’s approximation algorithm
double a = 2.0 , x ,
xold ;
x = a ;
do{
xold = x ;
// compute one iteration
x = ( xold+a/ xold ) / 2 . 0 ;
System . out . p r i n t l n (x) ;
} while (Math . abs (x−xold ) > 1e −10) ;
1.5
1.4166666666666665
1.4142156862745097
1.4142135623746899
1.4142135623730949
Netwon’s method is provably converging very fast under mild assumptions.
2.4.3 Loop statement: for
Often programmers need to repeat a sequence of instructions by changing some
variables by a given increment step. Although this can be done using the former
while/do structures, Java provides a more convenient structure: the for loop.
The generic syntax of a for structure is as follows:
for(initialCondition; booleanPredicate; update)
{
block_instructions;
}
For example, consider computing the cumulative sum Sn of the ﬁrst n integers:
Sn =
n−1

i=0
i = n(n −1)
2
.
We have the recurrence equation: Sn = n −1 + Sn−1 with S0 = 0. Therefore to
compute this cumulative sum, we start in reverse from S0 and get Si by adding
i −1 to Si−1 for all i ∈{1, ..., n}. Let us use the for structure as follows:
Program 2.6
Cumulative sum
class ForLoop
{
public
static void main ( String
args [ ] )
{
int
i ,
n=10;
int cumulLoop=0;
for ( i =0; i<n ; i++) {cumulLoop+=i ;}

46
2. Conditional Structures and Loops
int cumul=(n∗(n−1)) /2;
// closed -form solution
System . out . p r i n t l n ( cumulLoop+" closed -form:"+cumul ) ;
}
}
To give yet another usage of the for loop, consider computing an approximation
of π by a Monte-Carlo simulation. We draw uniformly random points in a unit
square, and count the number of points falling inside the unit disk centered
inside the square. The ratio of the points falling inside this square to the overall
number of points gives a good approximation of π
4 . We draw a uniform random
number in [0, 1) in Java using the function random() of the Math class. This kind
of Monte-Carlo simulation is extremely useful to compute complex integrals,
and is often used in the ﬁnance industry. Let us give the code for approaching
π:
Program 2.7
Approaching π by Monte-Carlo simulation
class
MonteCarloPI
{
public
static void main ( String
[ ]
args )
{
int
i t e r = 10000000; // # iterations
int
h i t s = 0;
for
( int
i = 0;
i < i t e r ;
i++)
{
double rX = 2∗Math . random () −1 . 0 ;
double rY = 2∗Math . random () −1 . 0 ;
double
d i s t = rX∗rX + rY∗rY ;
i f
( d i s t <= 1 . 0 )
// falls inside the disk
h i t s ++;
}
double
r a t i o = (double) h i t s / i t e r ;
// Ratio of areas
double area = r a t i o
∗
4 . 0 ;
System . out . p r i n t l n ( "Estimation of PI: " + area+ " versus
library PI "+Math . PI ) ;
}
}
Unfortunately running this code gives a poor approximation of π since we get
only a few correct digits, even after drawing 107 points.
Estimation of PI: 3.1413544 versus library PI 3.141592653589793
2.4.4 Boolean arithmetic expressions
A category of arithmetic expressions that are especially useful for writing
predicates in loop structures are boolean expressions. Although they are not

2.5 Unfolding loops and program termination
47
usually used in plain assignments, they also make perfect sense as illustrated
by the program below:
Program 2.8
Boolean arithmetic expression
class
Boolean{
public
static void main ( String [ ]
args )
{
boolean b1 = (6−2) == 4;
boolean b2 = 22/7 == 3+1/7.0
;
boolean b3 = 22/7 == 3+ 1/7;
System . out . p r i n t l n ( b1 ) ;
// true
System . out . p r i n t l n ( b2 ) ;
// false
System . out . p r i n t l n ( b3 ) ;
// true
}
}
2.5 Unfolding loops and program termination
2.5.1 Unfolding loops
When executing a program that contains loop structures, we can unroll these
loops manually. Compilers actually do it sometimes to optimize the generated
bytecode.
2.5.2 Never ending programs
Once programmers ﬁrst experience loops, a major issue arises: Does the
program terminate? It is indeed quite easy to write never ending programs
by writing loops that execute forever as illustrated below:
int i=0;
while (true)
i++;
Always make sure when you write a for structure that the boolean expression
will evaluate to false at some stage. Take care to avoid mistyping problems
such as:
for(i=0;i>=0;i++)
; // common mistyping error in the boolean predicate
... and prefer to use curly brackets instead of the semi-colon for single-
instruction blocks:

48
2. Conditional Structures and Loops
for(i=0;i>=0;i++)
{ }
2.5.3 Loop equivalence to universal while structures
As mentioned earlier, the three loop structures in Java are all equivalent to a
universal while structure. These diﬀerent loop syntaxes are provided to help
programmers quickly write code.
for(instructionInit; booleanCondition; instructionUpdate) block instruction;
instructionInit;
while (booleanCondition)
block instruction3; instructionUpdate;
2.5.4 Breaking loops at any time with break
We can voluntarily escape loops at any time by using the keyword break. This
special instruction is useful for example when we ask users to input any given
number of data.
2.5.5 Loops and program termination
Consider the following sequence {ui}i of integers numbers as follows:
un+1 =
 un/2
if n is even,
3un + 1
otherwise.
,
initialized for any given u0 ∈N.
For example, let u0 = 14. Then u1 = 14, u2 = 7, u3 = 22, u4 = 11, u5 = 34,
u6 = 17, u7 = 52, u8 = 26, u9 = 13, u10 = 40, u11 = 20, u12 = 10, u13 = 5,
u14 = 16, u15 = 8, u16 = 4, u17 =2, u18 = 1. Once 1 is reached the sequence
cycles 1, 4, 2, 1, 4, 2 . . .. It is conjectured but not yet proved that for any u0 ≥1
the sequence reaches in a ﬁnite step number 1. We can numerically check that
this conjecture holds for a given number u0 = n using the following do loop
structure:
Program 2.9
Syracuse’s conjecture
do{
i f
(( n%2)==0)

2.6 Certifying programs: Syntax, compilation and numerical bugs
49
n/=2;// divide by 2
else
n=3∗n+1;
} while (n>1) ;
However one has not yet managed to successfully prove that this program will
eventually stop for any given n. It is a hard mathematical problem that is known
in the literature by the name of Syracuse’s conjecture or 3x + 1 problem.4
This simple toy problem raises the fundamental halting problem famous in
theoretical computer science. Loosely speaking, G¨odel proved that there is no
program that can decide whether any given program will stop after a ﬁnite
number of instructions or not. This important theoretical result, which is one
of the pillars of computer science, will be further explained using a simple
contradiction argument in Chapter 3.8.
2.6 Certifying programs: Syntax, compilation
and numerical bugs
A program that compiles without reporting any error message is a syntactically
correct program. Beware that because of the language ﬂexibility provided by
its high-level semantic, some obscure codes5 compile. These obscure codes are
often very diﬃcult for humans to understand. To get a ﬂavor, consider for
example the snippet:
Program 2.10
Syntactically correct program
int
i =3;
// syntax below is valid! guess its result?
int
var=i+++i ;
This program compiles and is valid since the expression i+++i is well-formed.
How did the compiler interpret it? Well, ﬁrst the compiler put parenthesis from
the operator priority rule: (i++)+i. Then it ﬁrst evaluated this expression by
performing the post-incrementation i++ (so that it returns 3 for this expression
but now i stores value 4). Finally, it adds to the value of i 3 so that we get
3 + 4 = 7.
Even when a simple human-readable program compiles, it becomes complex
for humans to check whether the input ﬁts all branching conditions. In other
words, are all input cases considered so that the program does not have to
4 See http://arxiv.org/abs/math/0608208/ for some annotated bibliographic
notes.
5 Hackers love them.

50
2. Conditional Structures and Loops
process “unexpected” data? This can turn out to be very diﬃcult to assert for
moderate-size programs. For example, consider the quadratic equation solver:
Program 2.11
Quadratic equation solver
import java . u t i l . ∗;
class
QuadraticEquationScanner
{
public
static void main ( String [ ]
arg )
{
double a , b , c ;
// choose a=1, b=1, c=1
Scanner
input=new Scanner ( System . in ) ;
input . useLocale ( Locale .
US) ;
a=input . nextDouble () ;
b=input . nextDouble () ;
c=input . nextDouble () ;
double delta=b∗b−4.0∗a∗c ;
double root1 ,
root2 ;
// BEWARE: potentially Not a Number (NaN) for neg.
discriminant!
root1= (−b−Math . sqrt ( delta ) ) /(2.0∗a ) ;
root2= (−b+Math . sqrt ( delta ) ) /(2.0∗a ) ;
System . out . p r i n t l n ( "root1="+root1+" root2="+root2 ) ;
}
}
The problem with that program is that we may compute roots of negative
numbers. Although mathematically this makes sense with imaginary numbers
C, this is not the case for the function Math.sqrt(). The function returns a
special number called NaN (standing for Not a Number) so that the two roots
may be equal to NaN. It is much better to avoid that case by ensuring with a
condition that delta is greater or equal to zero:
i f
( delta >=0.0d)
{
root1= (−b−Math . sqrt ( delta ) ) /(2.0∗a ) ;
root2= (−b+Math . sqrt ( delta ) ) /(2.0∗a ) ;
System . out . p r i n t l n ( "root1="+root1+" root2="+root2 ) ;
}
else
{System . out . p r i n t l n ( "Imaginary roots!" ) ;}
The rule of thumb is to write easy-to-read code and adopt conventions once and
for all. For example, always put a semi-colon at the end of instructions, even
if it is not required (atomic blocks). Always indent the source code to better
visualize nested structures with braces {}. Take particular care of equality test
== with assignment equal symbol = (type checking helps ﬁnd some anomalous
situations but not all of them).
Finally, let us insist that even if we considered all possible input cases and
wrote our codes keeping in mind that they must also be human-readable, it

2.7 Parsing program arguments from the command line
51
is impossible for us to consider all numerical imprecisions that can occur.6
Consider the following example:
Program 2.12
A simple numerical bug
// Constant
final double PI = 3 . 1 4 ;
int a=1;
double b=a+PI ;
i f
(b==4.14) // Equality test are dangerous !!!
System . out . p r i n t l n ( "Correct result" ) ;
else
{System . out . p r i n t l n ( "Incorrect result" ) ;
System . out . p r i n t l n ( "a="+a+" b="+b+" PI="+PI ) ;
}
This code is dangerous because, mathematically speaking, it is obvious that
a+b = 4.14 but because of the ﬁnite representation of numbers in machine (and
their various formatting), this simple addition yields an approximate result. In
practice, the ﬁrst lesson we learn is that we always need to very cautiously use
equality tests on reals. The second lesson is that proofs of programs should be
fully automated. This is a very active domain of theoretical computer science
that will bring novel solutions in the 21st century.
2.7 Parsing program arguments from the
command line
So far we have initialized programs either by interactively asking users to enter
initial values at the console, or by plugging these initial values directly into the
source code. The former approach means that we have high-latency programs
since user input is “slow.” The latter means that programs lack ﬂexibility since
we need to recompile the code every time we would like to test other initial
parameter conditions.
Fortunately, programs in Java can be executed with arguments given in the
command line. These arguments are stored in the array arg of the main
function:
public static void main (String[] args)
These arguments are stored as strings args[0], args[1], etc. Thus even if we
enter numbers like ”120” and ”28” in the command line:
6 Some software packages such as Astr´ee used in the airplane industry do that
automatically to certify code robustness. See http://www.astree.ens.fr/

52
2. Conditional Structures and Loops
prompt gcd 120 28
These numbers are in fact plain sequences of characters that are stored in
Java strings. Thus the program needs at ﬁrst to reinterpret these strings
into appropriate numbers (integers or reals), prior to assigning them to
variables. To parse a string and get its equivalent integer (int), one uses
Integer.parseInt(stringname);. For reals, to parse and create the cor-
responding float or double from a given string str, use the following
functions: Float.parseFloat(str) or Double.parseDouble(str). Let us
revisit Euclid’s GCD program by taking the two numbers a and b from the
program arguments:
class
gcd {
public
static void main ( String [ ]
arg )
{
// Parse arguments into integer parameters
int a= Integer . parseInt ( arg [ 0 ] ) ;
int b= Integer . parseInt ( arg [ 1 ] ) ;
System . out . p r i n t l n ( "Computing GCD("+a+","+b+")" ) ;
while ( a!=b)
{
i f
(a>b) a=a−b ;
else b=b−a ;
}
// Display to console
System . out . p r i n t l n ( "Greatest common divisor is "+a ) ;
}
}
Compiling and running this program yields:
prompt%java gcd 234652 3456222
Computing GCD(234652,3456222)
Greatest common divisor is 22
But there is more. In Chapter 1.8, we explained the basic mechanism of
input/output redirections (I/O redirections). Using I/O redirections with
program arguments yields an eﬃcient framework for executing and testing
programs. Let us export the result to a text ﬁle named result.txt:
prompt%java gcd 234652 3456222 >result.txt
Then we saved the texts previously written on the console to that ﬁle. We can
visualize its contents as follows:
prompt%more result.txt
Computing GCD(234652,3456222)
Greatest common divisor is 22
We are now ready to proceed to the next chapter concentrating on functions
and procedures.

2.8 Exercises
53
2.8 Exercises
Exercise 2.1 (Integer parity)
Write a program that interactively asks for an integer at the console
and reports its odd/even parity. Modify the code so that the program
ﬁrst asks the user how many times it would like to perform parity
computations, and then iteratively asks for a number, compute its parity,
and repeat until it has performed the required number of parity rounds.
Further modify this program so that now both input and output are
redirected into text ﬁles, say input.txt and output.txt.
Exercise 2.2 (Leap year)
A leap year is a year with 366 days that has a 29th February in its
calendar. Years whose division by 4 equals an integer are leap years
except for years that are evenly divisible by 100 unless they are also
evenly divisible by 400. Write a program that asks for a year and report
on whether it is a leap year or not. Modify this code so that the program
keeps asking for years, and compute its leap year property until the user
input −1.
Exercise 2.3 (Displaying triangles)
Write a program that asks for an integer n, and write on the output a
triangle as illustrated for the following example (with n = 5):
1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
1 2 3 4
1 2 3
1 2
1
Exercise 2.4 (Approximating a function minimum)
Let f(x) = sin(
25
x2−4x+6) −x
3 for x ∈[0, π] be a given function. Write a
program that takes as argument an integer n and returns the minimum
of f(x) on the range x ∈[0, π] evenly sampled by steps 1
n. Execute the
program for n = 10, n = 100 and n = 100000 and check that the root is
about −1.84318.
Exercise 2.5 (Computing √a numerically)
Consider Newton’s root ﬁnding method to compute
1
√a by choosing
function f(x) = a −
1
x2 . Show that we obtain the following sequence:

54
2. Conditional Structures and Loops
xn+1 = xn
2 (3 −ax2
n. Write the corresponding program. Does it converge
faster or slower than Newton’s method for f(x) = a −x2?
Exercise 2.6 (Variable scope)
Consider the following program:
class
ScopeExercise
{
public
static void main ( String [ ]
a )
{
int
j =5;
for ( int
i =0; i <10; i++)
System . out . p r i n t l n ( "i="+i ) ;
j+=i +10;
System . out . p r i n t l n ( "j="+j ) ;
}
}
Explain what is wrong with this program. How do we change the scope
of variable i in order to compile?
Exercise 2.7 (Chevalier DeMere and the birth of probability **)
In the 17th century, gambler Chevalier De M´er´e asked the following
question of Blaire Pascal and Pierre de Fermat: How can one compare
the following probabilities
– Getting at least one ace in four rolls of a dice,
– Getting at least one double ace using twenty-four rolls of two dices.
Chevalier De M´er´e thought that the second chance game was better but
lost constantly. Using the function Math.random() and loop statements,
experiment with the chance of winning for each game. After running
many trials (say, a million of them), observe that the empirical probabil-
ity of winning with the ﬁrst game is higher. Prove that the probability of
winning for the ﬁrst and second games are respectively
 5
6
4 and
 35
36
24.
Exercise 2.8 (Saint Petersburg paradox **)
The following game of chance was introduced by Nicolas Bernoulli: A
gamer pays a ﬁxed fee to play, and then a fair coin is tossed repeatedly
until, say, a tail ﬁrst appears. This ends the game. The pot starts at 1
euro and is doubled every time a head appears. The gamer wins whatever
is in the pot after the game ends. Show that you win 2k−1 euros if the
coin is tossed k times until the ﬁrst tail appears. The paradox is that
whatever the initial fee, it is worth playing this game. Indeed, prove that
the expected gain is ∞
k=1
1
2k 2k−1 = ∞
k=1
1
2 = ∞. Write a program

2.8 Exercises
55
that simulates this game, and try various initial fees and number of
rounds to see whether you are winning or not. (Note that this paradox
is mathematically explained by introducing an expected utility theory.)

3
Functions and Recursive Functions
3.1 Advantages of programming functions
The concept of functions in programming languages is quite diﬀerent from the
usual mathematical notions, although it bears some similarity. Therefore it can
be confusing at ﬁrst sight to make an explicit comparison. We rather prefer to
introduce the syntax of functions in Java, and show its two essential merits:
– Functions as subroutines for enhancing program modularity and code re-use,
– Functions deﬁned recursively by themselves for novel computation paradigms.
Last but not least, by introducing functions, we will explain the diﬀerence
between local (say, usual block variables) and global memory variables (say,
static class variables). Java passes arguments in functions by value only. This
is a major fundamental diﬀerence with C++ that allows both by-value and
by-reference variable passing. Finally, describing recursion will help us explain
the function call stack of Java where local variables are temporarily allocated.
F. Nielsen, A Concise and Practical Introduction to Programming Algorithms in Java,
Undergraduate Topics in Computer Science, DOI 10.1007/978-1-84882-339-6 3,
c⃝Springer-Verlag London Limited, 2009

58
3. Functions and Recursive Functions
3.2 Declaring and calling functions
3.2.1 Prototyping functions
Functions should always be declared inside the body of a class: The program
class (for now). The generic syntax for declaring a function F that takes N
arguments arg1, ..., argN of respective types Type1, ...,TypeN and return a
result of type TypeR is:
static TypeR F(Type1 arg1, Type2 arg2, ..., TypeN argN)
{
TypeR result;
block_of_instructions;
return result;
}
Procedures are special functions that do not return any result. In Java, this
is speciﬁed by using the void keyword for the function return type. Thus the
declaration of a procedure is as follows:
static void Proc(Type1 arg1, Type2 arg2, ..., TypeM argM)
{
block_of_instructions;
return;
}
The last instruction statement return; in the procedure Proc may be omitted.
We always put the keyword static in front of procedure/function declarations:
static void Proc. We will explain why this is necessary in Chapter 5 dealing
with objects and methods. Since procedures and functions shall be attached to
the body of class (that is, encapsulated into the class), we have basically the
following program skeleton:
Program 3.1
Basic program skeleton for deﬁning static functions
class
ProgramSkeleton{
static
TypeF F( Type1 arg1 ,
. . . ,
TypeN argN )
{
TypeF
r e s u l t ;
// Description
Block−of−i n s t r u c t i o n s ;
return
r e s u l t ;
}
static void Proc ( Type1 arg1 ,
Type2 arg2 ,
. . . ,
TypeM argM)
{
b l o c k i n s t r u c t i o n s ;
return ;
}

3.2 Declaring and calling functions
59
public
static void main ( String [ ]
arguments )
{ . . . }
}
Let us see some concrete examples.
3.2.2 Examples of basic functions
Let us create a demonstration program class FunctionDeclaration by typing
in the FunctionDeclaration.java text ﬁle the following code:
Program 3.2
A basic demonstration class for deﬁning and calling static
functions
class
FunctionDeclaration {
static
int
square ( int x)
{return x∗x ;}
static boolean isOdd ( int p)
{ i f
(( p%2)==0) return
false ;
else return true ;}
static double distance (double x ,
double y)
{ i f
(x>y) return x−y ;
else return y−x ;}
static void
display (double x ,
double y)
{System . out . p r i n t l n ( "("+x+","+y+")" ) ;
return ;
// return void
}
public
static void main ( String [ ]
args )
{
display (3 ,2) ;
display ( square (2) , distance (5 ,9) ) ;
int p=123124345;
i f
( isOdd (p) )
System . out . p r i n t l n ( "p is odd" ) ;
else
System . out . p r i n t l n ( "p is even" ) ;
}
}
Compiling and executing this code, we get:
(3.0,2.0)
(4.0,4.0)
p is odd

60
3. Functions and Recursive Functions
As shown in this example, the functions and procedures are deﬁned in the
scope of class FunctionDeclaration. These functions are called in the main
function of class FunctionDeclaration but this is not a restriction: Functions
can also be called inside the body of other functions. Observe that arguments
are expressions that may contain function calls themselves too, as in the
following example: display(square(2),distance(5,9));. This ﬁrst warm-
up example shows that functions/procedures help in writing code subroutines
and thus provide the basics for code modularity and code re-use. Code re-use
facilitates certiﬁcation and correctness of programs by breaking them down
into elementary units that can be proved more easily in turn.
Since functions are encapsulated into classes, we can call any arbitrary function
F declared in another class, say OtherClass, by using the syntax OtherClass.F.
We already used this syntax when calling mathematical functions such as
Math.cos(x); that are encapsulated into the class Math. Class Math is part
of a huge set of standardized Java application programming interfaces (APIs)
that come installed with the Java development kit (JDK). We can omit the
class name when calling a function provided that the function is declared
inside the body of the same class. This is the case of all functions of our
program FunctionDeclaration. For example, display(3,2); is equivalent
to the function call FunctionDeclaration.display(3,2);. Observe that the
main function of the program class is the default procedure called upon when
executing the program.
3.2.3 A more elaborate example: The iterative factorial
function
Let us now look at how implementing the factorial function
n! = 1 × 2 × ... × n =
n

i=1
i
for any given n ∈N+ (by convention 0! = 1)). Since the factorial function
does not belong to the basic static functions of the Math class, let us write our
own function factorial in a toolbox class named Toolbox. We use a while
statement for accumulating the multiplications n × ... × 1 as follows:
Program 3.3
Implementing the factorial function n!
class
Toolbox{
static
int
f a c t o r i a l ( int n)
{ int
r e s u l t =1;

3.2 Declaring and calling functions
61
while (n>0){
r e s u l t∗=n ;
// similar to result=result*n;
n−−;
}
return
r e s u l t ;
/
}
}
class
ExampleFactorial {
public
static void main ( String [ ]
args )
{
System . out . p r i n t l n ( "6!="+Toolbox . f a c t o r i a l (6) ) ;
}
}
Compiling and executing this program yields 6!=720.
3.2.4 Functions with conditional statements
The former distance function of § 3.2.2 takes two arguments x and y of type
double and returns the absolute value of their diﬀerence in a result of type
double. Let us recall the previous code...
static double distance(double x, double y)
{double result;
if (x>y) result=x-y;
else result=y-x;
return result;
}
This could have been rewritten more compactly as follows:
static double distance(double x, double y)
{if (x>y) return x-y;
else return y-x;}
In case functions or procedures use branching conditionals (such as if else
or switch case statements), we always have to make sure that whatever the
instruction workﬂow, the function will always reach an appropriate return
statement. The compiler checks all these diﬀerent execution paths and may
complain with a missing return statement message error if this property is
not met. For example, try to replace the distance function by this erroneous
code:
static double distance(double x, double y)
{double result;
if (x>y) result=x-y; // forgot voluntarily the return statement
else return y-x;}

62
3. Functions and Recursive Functions
As an other example, consider the following code snippet, which uses a switch
case statement:
Program 3.4
Function with branching structures
class
FunctionWithConditionalStatement {
public
static void main ( String [ ]
arguments )
{
double x=Math .E;
System . out . p r i n t l n ( "Choose function to evalute for x="+x)
;
System . out . print ( "(1) Identity , (2) Logarithm , (3) Sinus.
Your choice ?" ) ;
int
t=TC. l i r e I n t () ;
System . out . p r i n t l n ( "F(x)="+F( t , x) ) ;
}
// Observe that here we deliberately chose the function to
be declared after the main body
public
static double F( int
generator ,
double x)
{double v =0.0;
switch ( generator )
{
case
1: v=x ;
break ;
case
2: v=Math . log (x) ;
break ;
case
3: v=Math . sin (x) ;
break ;
}
return v ;
}
}
This is one very nice feature of typed programming languages that check that
all return paths of functions have appropriate return type TypeR (eventually
by implicitly casting types).
3.3 Static (class) variables
Once functions have been introduced, we see that variable declarations
potentially appear in the body of all respective functions, and are no longer
found only in the main function. The variable scopes are nevertheless restricted
to the body of the function delimited by the braces; These variables cannot be

3.3 Static (class) variables
63
accessed from outside the function bodies.
Suppose now that we would like to count the number of times a given function
is called. We need to declare a kind of persistent variable that we can attach
to the class encapsulating the function: These kinds of persistent variables are
called static variables. Using static variables, it becomes easy, say, to count the
overall number of function calls as illustrated by the following code:
Program 3.5
An example using a static (class) variable
class
StaticVariable {
static
int
nbfunccalls =0;
static
int
square ( int x)
{ nbfunccalls++;
return x∗x ;}
static boolean isOdd ( int p)
{ nbfunccalls++;
i f
(( p%2)==0) return
false ;
else return true ;}
static double distance (double x ,
double y)
{double
r e s u l t ;
nbfunccalls++;
i f
(x>y)
r e s u l t=x−y ;
else
r e s u l t=y−x ;
return
r e s u l t ;
}
static void
display (double x ,
double y)
{ nbfunccalls++;
System . out . p r i n t l n ( "("+x+","+y+")" ) ;
}
public
static void main ( String [ ]
args )
{
FunctionDeclaration . display (3 ,2) ;
display ( square (2) , distance (5 ,9) ) ;
int p=123124345;
i f
( isOdd (p) )
System . out . p r i n t l n ( "p is odd" ) ;
else
System . out . p r i n t l n ( "p is even" ) ;
System . out . p r i n t l n ( "Total number of function calls:"+
nbfunccalls ) ;
}
}
Running this program, we get the following message after completion:
Total number of function calls:4

64
3. Functions and Recursive Functions
Static variables are persistent variables attached to the class. These static
variables are stored in the global memory and can be accessed at any time from
any function. Thus static variables prove very useful for sharing information
between diﬀerent blocks of instructions encapsulated into functions.
3.4 Pass-by-value of function arguments
3.4.1 Basic argument passing mechanism
Whenever calling a function in Java, the arguments (which are potentially
arbitrarily complex expressions that may also include other function calls)
are evaluated sequentially. Java compiler javac then performs the necessary
implicit casting operations, if necessary, of these evaluated expressions, and
complain with error messages in case the types of evaluated expressions do not
match the deﬁnition types of function arguments. Thus a generic function call
prototyping syntax is as follows:
F(ExprArg1, ..., ExprArgN)
Even if the function F is called with plain variables as is usually the case (say,
function call F(var1, ..., varN)), these variables are in fact basic expressions
that are evaluated in this case to their stored values. Once the body of the
function is entered, there is no longer direct access to these variables. Executing
the function call thus amounts to executing this function where argument
variables and evaluated expressions have been binded:
static
TypeF F()
{
Type1 arg1=ExprArg1;
...
TypeN argN=ExprArgN;
// Body of the function
...
}
3.4.2 Local memory and function call stack
In Java, variables declared in instruction blocks are all created and stored in
the local memory of the corresponding function. This local memory is named
the function call stack. Whenever a function is called, the required memory for
the local variables is allocated into the function stack, and the arguments are
passed by value as illustrated in Figure 3.1. Whenever inside the body of the

3.4 Pass-by-value of function arguments
65
current function another function, say G, is called, the same mechanism applies:
First, local memory for storing all block variables declared in the function block
of G is allocated, and arguments are passed by value. Once G is completed, the
local memory allocated for its execution is released. These various levels of
nested function calls yield the function call stack.
static void main(String [] arg)
double y;//local memory
y=F(5);
System.out.println(”y=”+y);
static F(double x)
double result;// local memory
result=1.0+G(x*x);
return result;
static double G(double x)
double result;// local memory
result=Math.pow(x,2.5);
return result;
Function call stack
Binding:
Pass-by-value
x=5;
Binding:
Pass-by-value
x=25;
Figure 3.1
Illustrating the function call stack: The function variables are
allocated into the local memory stack and are thus not visible to other functions.
The pass-by-value mechanism binds the function arguments with the respective
expression values at calling time
Program 3.6
Illustrating the function call stack
class
FunctionStack {
static double G(double x)
{
double
r e s u l t ;
r e s u l t=Math . pow(x , 2 . 5 ) ;

66
3. Functions and Recursive Functions
return
r e s u l t ;
}
static double F(double x)
{
double
r e s u l t ;
r e s u l t =1.0+G(x∗x) ;
return
r e s u l t ;
}
public
static void main ( String [ ]
args )
{
double y ;
y=F( 5 . 0 ) ;
System . out . p r i n t l n ( "y="+y) ;
}
}
For example, considering the above program, the function call stack evolves as
follows:
Step
1
2
3
4
5
6
7
Action:
run
call
main
call
F
call
G
ﬁnish
G
ﬁnish
F
ﬁnish
main
Function
stack
∅
main
F
main
G
F
main
F
main
main
∅
Note that since arguments are passed by values, the local variables of the calling
functions are not changed. To emphasize this point, consider the following toy
sample program:
Program 3.7 Pass-by-value does not change local variable of calling functions
class
PassByValue{
static void F(double x)
{
x=3; // Here is the catch. Take care of pass -by-value.
System . out . p r i n t l n ( "Before exiting F, value of x:"+x) ;
}
public
static void main ( String [ ]
args )
{
double x=5;
F(x) ;
System . out . p r i n t l n ( "value of x:"+x) ;
}
}
We get from the pass-by-value mechanism the following output:
Before exiting F, value of x:3.0
value of x:5.0

3.4 Pass-by-value of function arguments
67
That is, when running the program PassByValue, the block of instructions in
the main procedure is executed as follows:
– Local variable x of main is assigned to value 5,
– Function F is called with basic expression x that is evaluated to 5 and passed
by value to F (expression/argument binding),
– Local variable x of F (not of main) is assigned to 3, and the message Before
exiting F, value of x:3.0 is displayed,
– Function F is completed, and its local allocated memory is removed from the
function stack,
– Message value of x:5.0 is displayed from the last instruction of the main
procedure.
In a similar way, swapping two integer variables cannot be achieved by the
following erroneous code since Java is pass-by-value:
public void badSwap(int var1, int var2)
{
int temp = var1;
var1 = var2;
var2 = temp;
} // at the end of this block, var1 and var2 keeps their original value
Loosely speaking, functions usually do not change the calling environment.
Function y=F(x) returns a result that is taken into account in the calling
environment. There are of course diﬀerent ways for functions and procedures
to alter the calling environment. This bears the name of side-eﬀect functions.
3.4.3 Side-eﬀects of functions: Changing the calling
environment
We have previously seen that functions can share the static (class) variables.
We gave an example where the overall number of function calls was updated
every time a function was called. This is one example of a function side-eﬀect
of calling functions: Changing the global environment. Let us give yet another
simple example to illustrate this point:
Program 3.8
Toy example for illustrating how functions can change the
environment
class
FunctionSideEffect {
static
int x=0;
static void F()

68
3. Functions and Recursive Functions
{
x++;
}
static void G()
{
−−x ;
}
public
static void main ( String [ ]
args )
{
F() ;
// x=1
G() ;
// x=0
F() ;
// x=1
System . out . p r i n t l n ( "value of x:"+x) ;
}
}
The program displays in the console: value of x:1. The various program
execution steps are visualized as shown in Figure 3.2. Note that in this diagram
we split the memory into two parts: The local function call stack memory
(function variables) and the global memory (static variables and referenced
structures). Thus in Java, we can voluntarily alter the calling environment
by handling arrays and other non-primitive user-deﬁned typed objects that are
manipulated by their references. We will explain in further detail these function
side-eﬀects in the following two chapters dealing with arrays and objects.
3.4.4 Function signatures and function overloading
Java is a typed programming language, and functions/procedures declared in
Java are also typed by their signature. The signature of the following declared
function:
static TypeR F(Type1 arg1, Type2 arg2, ..., TypeN argN)
{
TypeR result;
block_instructions;
return result;
}
is the Cartesian product of the type of its arguments:
Type1 × Type1 × TypeN.
In other words, the signatures of functions are their ordered sequence of
parameter types. Thus provided that functions have diﬀerent signatures, they
can actually bear potentially the same name; That is, a given function can be

3.4 Pass-by-value of function arguments
69
Local memory
(function call stack)
Global memory
(static variables, referenced structures)
main
F
F();
G();
F();
x++;
static int x=0;
Local memory
(function call stack)
Global memory
(static variables, referenced structures)
main
G
F();
G();
F();
–x;
static int x=1;
Local memory
(function call stack)
Global memory
(static variables, referenced structures)
main
F
F();
G();
F();
x++;
static int x=0;
x++;
–x;
x++;
Figure 3.2
Visualizing the local function call stack and the global memory
for program FunctionSideEffect.java
overloaded provided its argument types diﬀer from the original function. This is
useful in a number of situations where we would like to have a function perform
the same “function” on diﬀerent kinds of typed arguments, as illustrated by
the following program:
Program 3.9
Function signatures and overloading
class
PlusOne{

70
3. Functions and Recursive Functions
static double plusone ( int n)
{return n+1.0;
}
static double plusone (double x)
{return x +1.0;
}
static double plusone ( String
s )
{
return Double . parseDouble ( s ) +1.0;
}
public
static void main ( String [ ]
args )
{
System . out . p r i n t l n ( plusone (5) ) ;
System . out . p r i n t l n ( plusone ( 6 . 2 3 ) ) ;
System . out . p r i n t l n ( plusone ( "123.2" ) ) ;
}
}
We get the following output:
6.0
7.23
124.2
However Java does not take into account the type of the result for creating
signatures associated with functions, so that the following code will not properly
compile and generates the following error message:
plusone(int) is already defined in SignatureError static double
plusone(int n):
Program 3.10
Function signatures do not take into account the return type
class
SignatureError {
public
static
int
plusone ( int n)
{return n+1;}
public
static double plusone ( int n)
{return n+1.0;}
public
static void main ( String
args [ ] )
{} }
3.5 Recursion
Recursion is a powerful principle for writing functions that call themselves.
Recursion provides a methodology to get compact, simple and yet elegant
algorithms. Since these recursive functions call themselves, we shall take

3.5 Recursion
71
particularl care of the behavior of the function stack. In particular, we shall
focus on program/function termination by inspecting the terminal states that
correspond to the trivial cases that do not need to call functions.
3.5.1 Revisiting the factorial function: A recursive
function
We have seen in §3.2.3 an iterative algorithm for computing the factorial n! =
n × (n −1) × ... × 1. Let us now write the factorial function the recursive
way. First, we need to ﬁnd a recurrence equation for the factorial function. We
simply get this relationship as:
n! = n × (n −1) × ... × 1 = n × (n −1)!
with 0! = 1 by deﬁnition (terminal state).
Program 3.11
Recursive implementation of the factorial function
class
RecursiveFactorial
{
public
static
int
F a c t o r i a l ( int n)
{
i f
(n==0) return
1;
// Terminal stage
else return n∗F a c t o r i a l (n−1) ;
// Apply recurrence
equation
}
public
static void main ( String [ ]
arg )
{System . out . p r i n t l n ( "10!="+F a c t o r i a l (10) ) ;}
}
Compiling and executing this code, we get 10!=3628800. Does this recursive
function always terminate? For a given integer n ≥0, the function Factorial
calls itself until we reach at some stage the argument n = 0. Thus the function
stack has piled n+1 calls with the last call being Factorial(0). At this stage,
we enter the terminal stage and return 1. Factorial(1) can return its result
1 × 1 = 1 and it is removed from the stack. Then Factorial(2) can return its
result 2 × 1, and so on, until we return the result of Factorial(n). Figure 3.3
illustrates the pile on process of the function call stack until it reaches the
terminal state n = 0.
Note that if we call Factorial(-1), the program will pile-on the function
stack the function calls Factorial(-2), Factorial(-3), etc. and stop once
the function stack gets full, generating an overﬂow memory problem: A stack
overﬂow.

72
3. Functions and Recursive Functions
main
Factorial(10);
Factorial
return 10*Factorial(9);
Factorial
return 1*Factorial(0);
Factorial
return 1;
...
...
...
...
function call stack
Figure 3.3
Visualizing the function call
stack for the recursive factorial function.
3.5.2 Fibonacci sequences
Fibonacci sequences were introduced by Leonard de Pise1 as the following
sequence {Fi}i of natural numbers:
Fi =
 1
for i = 1 or i = 2,
Fi−1 + Fi−2
otherwise.
The ﬁrst Fibonacci numbers are given by 1, 1, 2, 3, 5, 8, 13, 21, 34, 55... Fibonacci
sequences are important for studying the characteristics of population growth
under a basic model. Let us explain this model for a population of male/female
rabbits:
– First, put a newly born pair of male/female rabbits in an enclosed ﬁeld.
– Assume that newly born rabbits take a month to become mature, after which
time...
– ... Each pair of mature rabbits produces a new pair of baby rabbits every
month.
1 Leonard de Pise (1170-1245) is better known as Fibonacci.

3.5 Recursion
73
The question Fibonacci originally raised was:
“How many pairs of rabbits will there be in the following months?”
Obviously at ﬁrst, we put a single pair of newly born rabbits and have the
ﬁrst month F1 = 1 (→terminal state). Then we need to wait for another
month for these rabbits to become mature so that F2 = 1 (→terminal state).
After which, the number of rabbits Fi at month i is the number of rabbits at
month i −1 plus the number of rabbits newly generated by mature rabbits.
The number of mature rabbits at month i is precisely Fi−2. Thus comes the
following recurrence relationship: Fi = Fi−1 +Fi−2 with F1 = F2 = 1 (terminal
states).
Program 3.12
Displaying Fibonacci sequences using recursion
class
FibonacciSequence {
public
static
int
Fibonacci ( int n)
{
i f
(n<=1) return
1;
else
return Fibonacci (n−1)+Fibonacci (n−2) ;
}
public
static void main ( String [ ]
args )
{ int
i ;
for ( i =0; i <=30; i++)
System . out . print ( Fibonacci ( i )+" " ) ;
}
}
Running the above program, we get the ﬁrst 31 Fibonacci numbers: 1 1 2 3 5
8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946
17711 28657 46368 75025 121 393 196418 317811 514229 832040
1346269
3.5.3 Logarithmic mean
The logarithmic mean is often used in engineering to measure temperature
diﬀerences. There are several non-equivalent deﬁnitions proposed in the
literature. Here, we consider for our programming purpose the following
recursive deﬁnition:
L(x1, ..., xn) = (n −1)L(x2, ..., xn) −L(x1, ..., xn−1)
log xn −log x1
,
with L(x) = x being the terminal case. Hence, for two elements x and y, we
have the logarithmic mean expressed as
L(x, y) =
x −y
log x −log y .

74
3. Functions and Recursive Functions
The recursive program below implements the logarithmic mean computation:
Program 3.13
Logarithmic mean
static double LogarithmicMean (double
[ ]
array ,
int
i ,
int
j )
{
// Terminal case: One element. The mean is always this
element
i f
( j−i ==0) return array [ i ] ;
else
{
int n=j−i +1;
return (n−1)∗( LogarithmicMean ( array , i +1, j )−LogarithmicMean (
array , i , j −1)) /(Math . log ( array [ j ] )−Math . log ( array [ i ] ) )
;
}
}
static double LogarithmicMean (double
[ ]
array )
{
return LogarithmicMean ( array , 0 , array . length −1) ;
}
3.6 Terminal recursion for program eﬃciency **
Although it is quite easy to write recursive functions once recurrence equations
and terminal states are clearly identiﬁed, the main drawback of using recursive
programs in practice is eﬃciency. Indeed, every time we call a function, the
Java Virtual Machine (JVM) has to allocate some local memory for the local
variables declared inside the body of the function. Then it has to perform the
pass-by-value of arguments. Another major issue is that the function stack
is limited in its size, and it is quite easy in practice to reach stack overﬂow
problems. Terminal recursion is a principle that solves these time and memory
problems while keeping the essence of recursion. A recursive function is said to
be terminal if and only if wherever the function calls itself it is with the following
simple expression f(...);. In other words, a function is terminal recursive if all
its return paths are of the form return f(...);. Terminal recursion is eﬀective
because it simply allows one to branch former arguments into new arguments by
performing various expression evaluations on parameters only. Therefore there
is no need to use the stack function calls, and no stack overﬂow problems are
occurring when using terminal recursion. In other words, arguments of terminal
recursive functions play the role of accumulators.
Let us reconsider the factorial recursive function:
if (n<=1) return 1; else
return n*f(n-1);

3.6 Terminal recursion for program eﬃciency **
75
...and write it using terminal recursion as follows:
Program 3.14
Writing the factorial function using terminal recursion
class
TerminalRecursionFactorial {
static
long FactorialRecTerminal ( int n ,
int
i ,
int
r e s u l t )
{
i f
(n==i ) return
r e s u l t ;
else
return FactorialRecTerminal (n , i +1, r e s u l t ∗( i +1)) ;
}
static
long FactorialLaunch ( int n)
{
i f
(n<=1) return n ;
else return FactorialRecTerminal (n , 1 , 1 ) ;
}
public
static void main ( String [ ]
args )
{
System . out . p r i n t l n ( "Factorial 10!="+FactorialLaunch (10) ) ;
}
}
Similarly, we can revisit the Fibonacci recursive program to write using terminal
recursion as follows:
Program 3.15
Fibonacci calculation using terminal recursion
class
FibonacciTerminalRecursion {
static
int
FibonacciRecTerm ( int n ,
int
i ,
int a ,
int b)
{
i f
(n==i ) return a ;
else return FibonacciRecTerm (n , i +1,a+b , a ) ;
}
static
int
FibonacciLaunch ( int n)
{ i f
(n<=1) return n ;
else return FibonacciRecTerm (n , 0 , 0 , 1 ) ;
}
public
static void main ( String [ ]
arg )
{
System . out . p r i n t l n ( "Fibonacci (7)="+FibonacciLaunch (7) ) ;
}
}

76
3. Functions and Recursive Functions
3.7 Recursion and graphics **
Beautiful recursive geometric patterns are often observed in nature. To give a
single example, consider the shapes of snowﬂakes: They look similar to Koch’s
mathematical snowﬂakes illustrated in Figure 3.4. These patterns are called
fractal patterns since they are deﬁned by a recursive process.
Figure 3.4
Koch’s mathematical
recursive snowﬂakes
One famous fractal mathematician is Waclaw Sierpinski (1882-1969), who
studied such recursive patterns. For example, the Sierpinski’s triangle recursive
pattern is given by the following simple rewriting rule:
Replace a given (parent) triangle by three (children) triangles deﬁned by the
midpoints of the edges of the parent triangle. Figure 3.5 shows Sierpinski’s
fractal triangle obtained after a few recursive graphics rewriting operations.
The ﬁgure was produced by the following more elaborate Java program which
recursively draws the fractal pattern using procedure sierpinski draw.
Program 3.16
Sierpinski’s fractal triangles
import javax . swing . ∗;
import java . awt . ∗;
public
class
S i e r p i n s k i
extends JFrame {
public
static
final
int WINDOW SIZE = 512;
public
static
final
int THRESHOLD=10; // stopping criterion
for recursion
public
static
int P1 x ,
P1 y ,
P2 x ,
P2 y ,
P3 x ,
P3 y ;
public
S i e r p i n s k i ()
{
super ( "Sierpinski" ) ;
s e t S i z e (WINDOW SIZE, WINDOW SIZE) ;
// A simple triangle
P1 x = ( int ) getSize () . getWidth () / 2 ; ;
P1 y = 40;
P2 x = 20;
P2 y = ( int ) getSize () . getHeight () −20;
P3 x = ( int ) getSize () . getWidth () −20;

3.8 Halting problem: An undecidable task
77
P3 y = ( int ) getSize () . getHeight () −20;
s e t V i s i b l e ( true ) ;
setDefaultCloseOperation (JFrame .
EXIT ON CLOSE) ;
}
// Compute the midpoint
public
Point
getMiddle ( Point p1 ,
Point p2 ) {
return new Point (( int ) ( p1 . getX () + p2 . getX () ) /2 ,
( int ) ( p1
. getY () + p2 . getY () ) /2) ;
}
public void paint ( Graphics g ) {
super . paint ( g ) ;
s i e r p i n s k i d r a w (new Point ( P1 x ,
P1 y ) ,new Point ( P2 x ,
P2 y ) , new Point ( P3 x , P3 y ) ) ;
}
public void
s i e r p i n s k i d r a w ( Point p1 ,
Point p2 ,
Point p3 ) {
//termination condition
i f
( p1 . distance ( p2 ) < THRESHOLD
&&
p1 . distance ( p3 ) <
THRESHOLD &&
p2 . distance ( p3 ) < THRESHOLD)
return ;
// stop recursion
//draw the current triangle
Graphics g = getGraphics () ;
g . drawLine (( int ) p1 . getX () ,( int ) p1 . getY () ,( int ) p2 . getX () ,(
int ) p2 . getY () ) ;
g . drawLine (( int ) p2 . getX () ,( int ) p2 . getY () ,( int ) p3 . getX () ,(
int ) p3 . getY () ) ;
g . drawLine (( int ) p3 . getX () ,( int ) p3 . getY () ,( int ) p1 . getX () ,(
int ) p1 . getY () ) ;
//recursively draw the 3 smaller corner triangles
Point m12 = getMiddle (p1 ,
p2 ) ;
Point m23 = getMiddle (p2 ,
p3 ) ;
Point m31 = getMiddle (p3 ,
p1 ) ;
// Recursive calls
s i e r p i n s k i d r a w (p1 , m12 , m31) ;
s i e r p i n s k i d r a w (p2 , m23 , m12) ;
s i e r p i n s k i d r a w (p3 , m31 , m23) ;
}
public
static void main ( String [ ]
args ) {
new S i e r p i n s k i () ;
}
}
3.8 Halting problem: An undecidable task
We have shown that recursion is a very powerful concept for writing compact
functions that calculates results using a recurrence relation with associated
terminal states. A major problem is to know whether all terminal states are
properly studied. Otherwise, the function might call itself forever, or at least

78
3. Functions and Recursive Functions
Figure 3.5
Sierpinski’s triangle
fractal obtained by the program
Sierpinski.java
until the function call stack gets full. However even if all terminal states are
scrupusously taken care of, it is impossible to prove that such a function will
terminate. This crucial limitation is known by the name of the halting problem
in computer science.
Even for simple recurrence relations, it is very challenging to mathematically
prove termination. For example, consider the Syracuse sequence of numbers
deﬁned in §2.5.5 as follows:
un+1 =
 un/2
if n is even,
3un + 1
otherwise.
,
initialized for any given u0 ∈N. It is conjectured but not yet proved that for any
u0 ≥1 the sequence reaches in a ﬁnite step number 1. The following program
tests experimentally the termination of the recursive function:
Program 3.17
Recursive Syracuse: Testing for termination
class
RecursiveSyracuse
{
public
static double Syracuse ( int n)
{
i f
(n==1) return
1;
else
i f
(n%2==0) return 1+Syracuse (n/2) ;
// even
else return (1+Syracuse (3∗n+1)/2) ;
}
public
static void main ( String [ ]
args )
{
for ( int
i =1; i <=10000;
i++)
{
System . out . p r i n t l n ( "Test termination for "+i ) ;
Syracuse ( i ) ;
}

3.9 Exercises
79
}
}
G¨odel2 formally proved that there is no program that can decide whether or
not any given program entered as an argument will stop after a ﬁnite number
of instructions. Indeed, loosely speaking, suppose that we have at our disposal
a “special” Java program Terminate(Prog) that returns true if and only if
a program Prog terminates, and false otherwise. Then we could design the
following function:
public static void UndecidableProg()
{
while(Terminate(UndecidableProg))
{}
}
Does the function UndecidableProg terminate or not? If it terminates, then
Terminate(UndecidableProg) is true, and the function loops forever, thus
not terminating. Or it does not terminate but Terminate(UndecidableProg)
is true so that it terminates. This yields a contradiction. Note that G¨odel’s
Proof of Incompleteness Theorem3 is way beyond this informal sketch.
3.9 Exercises
Exercise 3.1 (Computing function values)
Write a function that computes f(x) = √x + 1 for x of type double.
Test this function in the main program function by displaying the result
of calling f(2) and f(3). Then use a for loop statement to display f(i)
for i ∈{0, ..., 9}. Finally, modify this program to display f(x) for all
x ∈[0, 1) by increment of step size 0.1.
Exercise 3.2 (Power function and one of its properties)
Write a function power that takes two integer arguments a and b
(with b ≥0), and that returns the result ab. The exponentiation
shall be computed by accumulating b multiplications. Then use this
exponentiation function in the main program to compute ab for a and b
given interactively by the user.
For c, a non-negative integer, we have the following property: abc = abc.
Indeed, we have abc = ec log ab = ebc log a = abc. Write a function check
2 Kurt G¨odel (1906-1978).
3 http://en.wikipedia.org/wiki/Halting_problem

80
3. Functions and Recursive Functions
that uses former function power that returns true if and only if this
equality is numerically satisﬁed (and false otherwise). Modify the main
function so that the user can also input the value of c interactively at
the console. When might this inequality fail in your program?
Exercise 3.3 (Binary representation)
Give a recursive function DisplayBase2 that takes as its argument a
non-negative number, and report its binary decomposition. For example,
the binary decomposition of the decimal number 11 is 1011: (11)10 =
(1011)2. That is, we have the following unique decomposition: 11 =
1 × 23 + 0 × 22 + 1 × 21 + 1 × 20. This binary decomposition can be
obtained by successively dividing by 2 and taking the remainder 0 or 1
each time.
Exercise 3.4 (Euclid’s greatest common divisor)
Use the property that GCD(a, b) = GCD(b, a mod b) and GCD(a, 0) =
|a| for designing a recursive function static int GCD(int a, int b).
One can use the function Math.abs(x) of the Math class to calculate the
absolute value of a given number x. Visualize the recursive function calls
by displaying the various function call parameters a and b. Illustrate
the recursive calls and the function call stack for a = 15 and b = 21.
Compare your code with the following one that uses a ternary operator:
Program 3.18
Euclid’s greatest common divisor using recursion
static
int gcd ( int a ,
int b)
{
return ( b != 0 ? gcd (b ,
a % b)
:
a ) ;
}
Exercise 3.5 (Week day calendar)
The week day X of a given date given as M/D/Y (for month/day/year)
can be encoded as an integer X in range X ∈{0, ..., 6} with Sunday
being encoded by 0. The week day is calculated by the following intricate
formula:
X =

D + ⌊2.6 ∗M ′ −0.2⌋+ E +
	E
4

+
	S
4

−2S

mod 7,
where
(M ′, Y ′) =
 (M −2, Y )
if M > 2,
(M + 10, Y −1)
if M ≤2.
and Y ′ = 100S + E with 0 ≤E ≤100. Write a program that
takes as input a date formatted using the M/D/Y style and report

3.9 Exercises
81
the corresponding week day (”Sunday”, ..., ”Saturday”) to the output
console using a switch conditional statement.
Exercise 3.6 (Calculating sin nx and cos nx)
Write recursive functions sin(int n, double x) and cos(int n, double
x) that respectively compute sin nx and cos nx using the following
trigonometric formula:
sin(nx) = sin x cos(n −1)x + cos x sin(n −1)x,
cos(nx) = cos x cos(n −1)x −sin x sin(n −1)x.
(Hint: Consider sin 0 = 0 and cos 0 = 1 as the terminal cases.)
Exercise 3.7 (Palindrome **)
A palindrome is a word or phrase that can be read in either direction
like “radar” or “Was it a rat I saw.” Write an iterative function
CheckingPalindrome(String str) that checks whether a word/phrase
stored in str is a palindrome or not. One shall use the charAt(int
pos) method of the String class that reports the character of type
char located at position pos in the string. Checking whether a string
is a palindrome or not can also be done recursively as follows: A
word s is a palindrome if there exists a word w and a character c
such that s = cwc and w is a palindrome (of smaller length). Design
a recursive function CheckingPalindromeRec(String str, int left,
int right) that checks whether the portion of the string str delimited
by the index range left and right is a palindrome or not. Test
your program by calling the function CheckingPalindromeRec(str, 0,
str.length()-1);

4
Arrays
4.1 Why do programmers need arrays?
Arrays are useful for processing many data or generating many results at once
into a compact contiguous structure. Loosely speaking, array structures allow
one to manipulate many variables at once. An array is an indexed sequence
of components. In mathematics, one is familiar with variables bearing indices
like, for example, the vector coordinates xi or matrix elements mi,j. In most
programming languages, indices start at zero and not at one as is often the
case in mathematics. This simple 1-or-0 convention actually yields confusion
to many novice programmers, and is therefore an important source of bugs to
watch for.
4.2 Declaring and initializing arrays
4.2.1 Declaring arrays
In Java, arrays are also typed structures: For a given type, say TYPE, TYPE[] is
the type of arrays storing a collection of homogeneous elements of type TYPE.
Local arrays are declared within the body of functions (delimited by braces) as
follows:
int [ ] x; // array of integers
F. Nielsen, A Concise and Practical Introduction to Programming Algorithms in Java,
Undergraduate Topics in Computer Science, DOI 10.1007/978-1-84882-339-6 4,
c⃝Springer-Verlag London Limited, 2009

84
4. Arrays
boolean [ ] prime; // array of booleans
double [ ] coordinates; // arrays of reals formatted using double precision
Similarly, static class arrays are declared inside the body of a class using the
keyword static:
class Example{
static int [ ] x;
static boolean [ ] prime;
...
}
These (class) static array variables can then be used and shared by any function
of the class. In both local/class cases, arrays are allocated into the global
memory, and not into the function call stack. Only the references of arrays
may be stored into the function call stack for locally declared arrays.
4.2.2 Creating and initializing arrays
Arrays are created and initialized by default using the Java reserved keyword
new:
int [ ] x = new int[5];
boolean [ ] prime = new boolean[16];
The size of arrays needs to be speciﬁed:
x=new int [32];
The size of an array can also be given as an integer arithmetic expression like
2*n, etc:
x=new int [2*n+3];
Arrays can only be declared once but may eventually be created and initialized
several times. This recreation process overrides the former creation/initializa-
tion:
x=new int [2*n+3];
...
x=new int [4*n-2]; // overrides the former creation and initialization
By default, initialization of arrays is performed by Java by ﬁlling all its elements
with 0, or by casting this 0 to the equivalent array element type: For example,
false for booleans, 0.0d for double, 0.0f for float, etc. Initialization can
also be explicitly done by enumerating all its elements separated by comas “,”
within curly brackets {} as follows:
int [ ] prime={2, 3, 5, 7, 11, 13, 17, 19};
boolean prime[]={ false, true, true, true, false, true, false, true};

4.2 Declaring and initializing arrays
85
In that case, the size of the array is deduced from the number of elements in
the set, and should therefore not be explicitly speciﬁed. Nor shall there be an
explicit creation using the keyword new. Here are a few examples illustrating
static array declarations, creations and initializations. Arrays can be declared
within the body of a function or globally as a static variable of the class. To
illustrate global static arrays, consider the following program:
Program 4.1
Static array declarations and creations
class
ArrayDeclaration {
static
int
d i g i t
[ ] = {1 ,
2 ,
3 ,
4 ,
5 ,
6 ,
7 ,
8 ,
9 ,
0};
static double x
[ ] = {Math . PI , Math .E,
1.0 ,
0 . 0 } ;
static boolean prime []={
false ,
true ,
true ,
true ,
false ,
true ,
false ,
true ,
false ,
false
};
static
int y [ ] ;
static void MyFunction ( int n)
{
// Allocate an array of size n
y=new int [2∗n ] ;
}
public
static void main ( String [ ]
args )
{
MyFunction (15) ;
// We recreate and initialize array y;
MyFunction (20) ;
}
}
Observe that in this sample program, array y is created twice. In any case,
arrays are allocated and stored in the global memory, and not stored in the
local function call stack. Only the references of arrays are stored in the function
stack for arrays declared within functions (without the keyword static).
4.2.3 Retrieving the size of arrays: length
Arrays in Java carry additional information1 about themselves: Their types and
lengths. The size of an array array is accessed by using the keyword length,
post-appended to the array name with a “.” dot:
array.length
Observe that there are no parenthesis used in conjunction with the keyword
length.
static boolean prime []={
false ,
true ,
true ,
true ,
false ,
true
,
false ,
true ,
false ,
false
};
1 Technically speaking, we say that arrays in Java are reﬂexive since they contain
additional information. This is to contrast with arrays in C or C++ that are non-
reﬂexive since they contain only their components.

86
4. Arrays
System . out . p r i n t l n ( prime . length ) ;
We cannot change the size of arrays once initialized. For example, trying to force
the length of array array by setting array.length=23; will generate the fol-
lowing compiler message error: cannot assign a value to final variable
length.
4.2.4 Index range of arrays and out-of-range exceptions
Arrays created with the syntax array=new TYPE[Expression] have a ﬁxed
length determined at the instruction call time by evaluating the expression
Expression to its integer value, say l (with l=array.length). The elements
of that array are accessed by using an index ranging from 0 (lower bound) to
l −1 (upper bound):
array[0]
...
array[l-1]
A frequent programming error is to try to access an element that does not
belong to the array by giving an inappropriate index falling out of the range
[0, l −1]. The following program demonstrates that Java raises an exception if
we try to use out-of-range indices:
Program 4.2
Arrays and index out of bounds exception
class ArrayBound{
public
static void main ( String [ ]
args )
{
int
[
]
v ={0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8};
long
l=v . length ;
System . out . p r i n t l n ( "Size of array v:"+l ) ;
System . out . p r i n t l n (v [ 4 ] ) ;
System . out . p r i n t l n (v [ 1 2 ] ) ;
}
}
Running the above program yields the following console output:
Size of array v:9
4
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 12
at ArrayBound.main(ArrayBound.java:8)
That is, index out of bounds cannot be checked by the compiler and may
happen at any time when executing the program.
A subarray is a consecutive portion of an array: For example, array[3..7];.
Java does not provide language support for manipulating subarrays so that one
has to explicitly keep track of the lower and upper bounds of subarrays.

4.3 The fundamental concept of array references
87
4.2.5 Releasing memory and garbage collector
In Java, one does not need to explicitly release memory of unused memory
structures such as arrays. The Java virtual machine (JVM) does it fully
automatically using the garbage collector. Once the JVM detects that elements
of an array cannot be accessed anymore because the reference of that array
has been released by, say, the function call stack, the garbage collector will
free that memory. This is a key diﬀerence with another popular programming
language: C++. The garbage collector checks at any time whether elements of
a given array can still be accessed by some variables holding a reference to that
array or not. If not, the garbage collector releases that global memory and will
perform some memory cleaning operations. Nevertheless, we can also explicitly
indicate to the JVM that we do not want the array anymore by setting the
reference of that array to null, meaning that we erase the array reference:
int [] array=new int[32];
array=null; // explicitly indicate to the JVM to release the array
4.3 The fundamental concept of array references
Whether the array is declared as a local variable or as a global (static/class)
variable, all its elements are stored in the program global memory. That is, even
if local array variables are declared, created and initialized within a function,
their elements may still be accessed by the calling function once the function
is completed. This provides an essential mechanism for voluntarily having side-
eﬀect phenomena in functions that can therefore potentially change the (global)
program environment. An array variable array is dealt as a reference to that
array, a single machine word from which its indexed elements can be accessed.
The notion of reference for non-primitive types in Java is essential. It can
be quite delicate to grasp at ﬁrst for novice programmers but nevertheless
is essential. The main advantages of handling array variables (whatever their
sizes) as references (a single machine word using four bytes2) are as follows:
– References provide a mechanism for functions to access and modify elements
of arrays that are preserved when functions exit.
– When calling a function with array arguments, Java does not need to
allocate the full array on the function call stack, but rather pass a single
reference to that array. Therefore it is computationally and memory eﬃcient.
2 That is equivalently 32 bits to reference a given memory location.

88
4. Arrays
Furthermore, this pass-by-reference mechanism limits the risk of function
stack overﬂow.
To illustate the notion of array references, consider the following set of
instructions:
Program 4.3
Arrays and references
int
[
]
v = {0 ,
1 ,
2 ,
3 ,
4};
// That is, v[0]=0, v[1]=1, v[2]=2, v[3]=3, v[4]=4;
int
[
]
t =v ;
// Reference of t is assigned to the reference of v so that t
[i]=v[i]
t [2]++; // Post -incrementation: t[2]=v[2]=3
System . out . p r i n t l n ( t [2]++) ;
// Display 3 and increment t[2]=v[2]=4 now
The result displayed in the console is 3. In summary, an array is allocated as
a single contiguous memory block. An array variable stores a reference to the
array: This reference of the array links to the symbolic memory address of its
ﬁrst element (indexed by 0).
Program 4.4
Assign an array reference to another array: Sharing common
elements
class
ArrayReference {
public
static void main ( String [ ]
args )
{
int
[ ]
v ={0 ,1 ,2 ,3 ,4};
System . out . p r i n t l n ( "Reference of array u in memory:"+v) ;
System . out . p r i n t l n ( "Value of the 3rd element of array v:"
+v [ 2 ] ) ;
// Declare a new array and assign its reference to the
reference of array v
int
[ ]
t =v ;
System . out . p r i n t l n ( "Reference of array v in memory:"+v) ;
// same as u
System . out . p r i n t l n (v [ 2 ] ) ;
t [2]++;
System . out . p r i n t l n (v [ 2 ] ) ;
v[2]++;
System . out . p r i n t l n ( t [ 2 ] ) ;
}
}
Running this program, we notice that the reference of the array u coincides
with the reference of array v:
Reference of array u in memory:[I@3e25a5
Value of the 3rd element of array v:2
Reference of array v in memory:[I@3e25a5
2

4.3 The fundamental concept of array references
89
3
4
The I in [I@3e25a5 indicates that this is a reference to an array of integers.
The forefront letter varies according to the type of array elements as illustrated
by the following code:
Program 4.5
Printing the references of various typed arrays
class
ArrayDisplay {
public
static void main ( String [ ]
args )
{
int
[ ]
x=new int [ 1 0 ] ;
System . out . p r i n t l n (x) ;
double
[ ]
y=new double [ 2 0 ] ;
System . out . p r i n t l n (y) ;
float
[ ]
z=new float [ 5 ] ;
System . out . p r i n t l n ( z ) ;
boolean
[ ]
b=new boolean [ 7 ] ; System . out . p r i n t l n (b) ;
}
}
We get3:
[I@3e25a5
[D@19821f
[F@addbf1
[Z@42e816
v
[I
6
2
3
1
2
7
1
0
1
2
3
4
5
type
length
Figure
4.1
A way to visualize arrays in
Java, explained for the array declaration and
assignment: int [] v={2,3,1,2,7,1};.
One way to depict arrays is shown in Figure 4.1. Note that the length and type
of the array are indicated in this representation (reﬂexive arrays).
3 An array of strings has type [Ljava.lang.String;

90
4. Arrays
4.4 Arrays as function arguments
Functions and procedures can have arrays as arguments too. Remember that
arrays of element types TYPE are themselves of type TYPE [], so that the syntax
for declaring a function using an array argument and calling it is:
static void MyFunction(int [ ] x)
{...}
...
int [] v=new int[10];
// Calling the function with an array argument
MyFunction(v);
For example, consider implementing a function that returns the minimum
element of an array of integers provided as a function argument:
Program 4.6
Array argument in functions: Minimum element of an array
class ArrayMinimum{
static
int minArray ( int
[ ]
t )
{
int m=t [ 0 ] ;
for ( int
i =1; i<t . length ; ++i )
i f
( t [ i ]<m)
m=t [ i ] ;
return m;
}
public
static void main ( String [ ]
args )
{
int
[ ]
v=new int
[ 2 3 ] ;
for ( int
i =0; i <23; i++)
v [ i ]=( int ) (Math . random () ∗100) ;
// int from 0 to 99
System . out . p r i n t l n ( "The minimum of the array is :"+minArray
(v) ) ;
}
}
Since we initialize the array by ﬁlling it with random elements using the
Math.random() function, running the code several times may yield diﬀerent
outputs. For example, running the compiled bytecode three times in a row
yields the following results:
The minimum of the array is :4
The minimum of the array is :2
The minimum of the array is :1

4.4 Arrays as function arguments
91
We say that the code is non-deterministic because it uses some randomness4
provided by the function Math.random(). The following example demonstrates
that only references of arrays are passed by functions:
Program 4.7
Creating and reporting array information using functions
class
ArrayInFunction {
public
static void MyFunction ( int n)
{
int
array
[]=new int
[ n ] ;
int
i ;
InformationArray ( array ) ;
}
public
static void InformationArray ( int
[ ]
t )
{System . out . p r i n t l n ( "Size of array given in argument is:"+t
. length ) ;}
public
static void main ( String [ ]
args )
{
MyFunction (2312) ;
MyFunction (2008) ;
int x []=new int
[ 1 2 ] ;
}
}
Running the program, we get:
Size of array given in argument is:2312
Size of array given in argument is:2008
Arrays are useful structures for storing coordinates of vectors. Let us consider
programming the inner product of two vectors modeled as arrays. We end-up
with the following code:
Program 4.8
Calculating the inner product of two vectors given as arrays
class
VectorInnerProduct {
static double innerproduct ( int
[ ]
x ,
int
[ ]
y)
{
double sum=0.0;
System . out . p r i n t l n ( "Dim of vector x:"+x . length+ " Dim of
vector y:"+y . length ) ;
for ( int
i =0; i<x . length ; ++i )
sum=sum+x [ i ]∗y [ i ] ;
return sum ;
}
public
static void main ( String [ ]
args )
4 Since the randomness is emulated by some speciﬁc algorithms, we prefer to use the
term pseudo-randomness.

92
4. Arrays
{
int
dimension =30;
int
[ ]
v1 ,
v2 ;
v1=new int [ dimension ] ;
v2=new int [ dimension ] ;
for ( int
i =0; i<dimension ; i++)
{v1 [ i ]=( int ) (Math . random () ∗100) ; // random int [0,99]
v2 [ i ]=( int ) (Math . random () ∗100) ; // random int [0,99]
}
System . out . p r i n t l n ( "The inner product of v1 and v2 is "+
innerproduct ( v1 , v2 ) ) ;
}
}
Running this program, we get:
Dim of vector x:30 Dim of vector y:30
The inner product of v1 and v2 is 80108.0
Static (class) functions may also return an array as a result of their calculation.
A typical example is the addition of two vectors that yields another vector of
the same dimension:
Program 4.9
Function returning an array: Addition of vectors
class
VectorAddition {
static
int
[ ]
VectorAddition ( int
[ ]
u ,
int
[ ]
v)
{
int [ ]
r e s u l t=new int [ u . length ] ;
for ( int
i =0; i<u . length ; i++)
r e s u l t [ i ]=u [ i ]+v [ i ] ;
return
r e s u l t ;
}
public
static void main ( String [ ]
args )
{
int
[ ]
x={1, 2 ,
3};
int
[ ]
y={4, 5 ,
6};
int
[ ]
z= VectorAddition (x , y) ;
for ( int
i =0; i<z . length ; i++)
System . out . print ( z [ i ]+" " ) ;
}
}
The following example demonstrates how one can persistently modify inside a
function the contents of an array passed as an argument. That is, this array
element swapping program shows that the values of the elements of the array
can be changed after exiting the function.

4.5 Multi-dimensional arrays: Arrays of arrays
93
Program 4.10
Swapping array elements by calling a function
class
ModifyArray{
static void swap ( int
[ ]
t ,
int
i ,
int
j )
{
int tmp ;
tmp=t [ i ] ;
t [ i ]= t [ j ] ;
t [ j ]=tmp ;
}
static void DisplayArray ( int
[ ]
x)
{ for ( int
i =0; i<x . length ; i++)
System . out . print (x [ i ]+" " ) ;
System . out . p r i n t l n () ;
}
public
static void main ( String [ ]
args )
{
int
[ ]
t ={1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9};
DisplayArray ( t ) ;
swap ( t , 2 , 3 ) ;
DisplayArray ( t ) ;
}
}
We observe that the third and fourth element (corresponding respectively to
index 2 and 3) have indeed been swapped:
1 2 3 4 5 6 7 8 9
1 2 4 3 5 6 7 8 9
4.5 Multi-dimensional arrays: Arrays of arrays
4.5.1 Multi-dimensional regular arrays
We have so far considered linear arrays (also called 1D arrays). These 1D arrays
have proved useful for storing vector coordinates and processing arithmetic
operations on them (see, for example, the former scalar product and vector
addition programs). What about manipulating 2D matrices M = [mi,j] with n
rows and m columns? Of course, once the dimensions n and m are known, we
can map the elements mi,j of a 2D matrix to a 1D vector in Rn×m by linearizing
the matrix and using the following index correspondence:
(i, j) ⇔i × m + j.

94
4. Arrays
This index remapping5 is quite cumbersome to use in practice and may
yield various insidious bugs. Fortunately in Java, we can also create multi-
dimensional arrays easily; Java will perform the necessary index remapping
accordingly. A regular bi-dimensional array consists of n lines, each line being
itself an array of m elements. A 2D matrix of integers has type int [] [] and
is declared, created and initialized as follows:
int [ ] [ ] matrix;
matrix=new int[n][m];
By default at the initialization stage, the array matrix is ﬁlled up with all zero
elements. We can change the contents of this 2D array using two nested loops,
as follows:
for(int i=0; i<n; i++)
for(int j=0; j<m;j++)
matrix[i][j]=i*j+1;
These constructions extend to arbitrary array dimensions. For example, a 3D
array may be deﬁned as follows:
int [ ] [ ] [] volume;
volume=new double[depth][height][width];
Let us illustrate the manipulations of linear and bi-dimensional arrays by imple-
menting the matrix vector product operation. Observe the declaration/creation
and initialization of a 2D array by enumerating all its elements:
int [][] M={{1, 2, 3}, {4,5,6}, {7,8,9}};
Program 4.11
Matrix-vector product function
class
MatrixVectorProduct {
static
int
[ ]
MultiplyMatrixVector ( int
[ ] [ ]
mat ,
int
[ ]
v)
{
int [ ]
r e s u l t ;
r e s u l t=new int [ mat . length ] ;
for ( int
i =0; i<r e s u l t . length ; i++)
{
r e s u l t [ i ]=0;
for ( int
j =0; j<v . length ; j++)
r e s u l t [ i ]+= mat [ i ] [ j ]∗v [ j ] ;
}
return
r e s u l t ;
}
public
static void main ( String [ ]
args )
{
int
[ ] [ ] M={{1, 2 ,
3} ,
{4 ,5 ,6} ,
{7 ,8 ,9}};
int
[ ]
v={1 ,2 ,3};
5 We arbitrarily chose row major order. We can also choose the column major order.

4.5 Multi-dimensional arrays: Arrays of arrays
95
int
[ ]
z= MultiplyMatrixVector (M, v) ;
for ( int
i =0; i<z . length ; i++)
System . out . print ( z [ i ]+" " ) ;
}
}
Thus it is quite easy to write basic functions of linear algebra. Note that in Java,
it is not necessary6 to provide the function with the array dimensions since we
can retrieve these dimensions with the length keyword, as shown below:
Program
4.12
Creating multidimensional arrays and retrieving their
dimensions
class
MultidimArrays
{
static void f2D (double
[ ]
[ ]
tab )
{
System . out . p r i n t l n ( "Number of lines:"+tab . length ) ;
System . out . p r i n t l n ( "Number of columns:"+tab [ 0 ] . length ) ;
}
static void f3D (double
[ ]
[ ]
[ ]
tab )
{
System . out . p r i n t l n ( "Number of lines X:"+tab . length ) ;
System . out . p r i n t l n ( "Number of columns Y:"+tab [ 0 ] . length ) ;
System . out . p r i n t l n ( "Number of depths Z:"+tab [ 0 ] [ 0 ] . length ) ;
}
public
static void main ( String [ ]
args )
{
double
[ ]
[ ]
var=new double [ 3 ] [ 4 ] ;
f2D ( var ) ;
double
[ ]
[ ]
[ ]
tmp=new double [ 4 ] [ 5 ] [ 7 ] ;
f3D (tmp) ;
}
}
Running this program, we see that we correctly retrieved the 2D and 3D array
dimensions given as function arguments:
Number of lines:3
Number of columns:4
Number of lines X:4
Number of columns Y:5
Number of depths Z:7
4.5.2 Multi-dimensional ragged arrays **
Multi-dimensional arrays need not be regular: They can be completely irregular.
That is, a multi-dimensional array can also be deﬁned as a 1D array of arrays,
6 In the C programming language, one has to pass these dimensions as arguments.

96
4. Arrays
each array “element” being itself an array with its own dimensions. However,
these arrays should all store the same type of elements. To create such ragged
arrays, we ﬁrst need to declare the 1D array of arrays, and then proceed by
declaring each individual array using a loop statement. For example, to declare
and create a 2D ragged array of integers, we write the following statements:
ragged
[[I
5
[I
1
[I
5
Figure 4.2
Visualizing the
structure of a ragged array in
the global memory
int ragged[][] = new int[5][];
for (int i = 0; i < 5; i++)
{ragged[i] = new int[i + 1];}
The elements of the ragged arrays are either initialized by default (value zero)
or by using nested loops as follows:
for (int i = 0; i < 5; i++)
{for (int j = 0; j < ragged[i].length; j++)
{
ragged[i][j] = (int)(10*Math.random());
// random init.
}
}
Note that ragged[i] stores references7 to linear arrays of integers. To visualize
the entries of the ragged array, consider the following instructions:
System.out.println("type:"+ragged+" "+ragged.length);
for (int i = 0; i < 5; i++)
System.out.println("type:"+ragged[i]+" "+ragged[i].length);
7 In general, the type of elements contained in the ragged array may be retrieved
using array.getClass();

4.6 Arrays of strings and main function
97
We get the following output:
type:[[I@addbf1 5
type:[I@42e816 1
type:[I@9304b1 2
type:[I@190d11 3
type:[I@a90653 4
type:[I@de6ced 5
Observe that array ragged is printed as a bi-dimensional array of integers
using the “[[” notational convention: [[I@addbf1. Similarly to Figure 4.1, we
can visualize ragged arrays as depicted in Figure 4.2.
4.6 Arrays of strings and main function
Strings of type String are not primitive types of Java. Though they can
be constructed from literals and are immutable, strings are considered as
special Java objects. Strings are not arrays of characters char. In other words,
String ̸= char [].
These object notions shall be explained in the next chapter. We can also build
arrays of strings that are of type String [], and functions may have string
arrays as arguments. Actually, we are already very familiar with the main
function of all Java programs that take as argument an array of strings:
class ProgramName
{
public static void main(String[ ] args)
{
...
}
}
For example, the following program lists all string arguments given in the line
command when invoking the java virtual machine on the bytecode:
Program 4.13
Writing to the output the arguments of the invoked main
function
class
ParsingMain
{
public
static void main ( String [ ]
args )
{
for ( int
i =0; i<args . length ; i++)
System . out . p r i n t l n ( i+":"+args [ i ] ) ;
}
}

98
4. Arrays
After compiling this code, let us execute the bytecode using java as follows:
prompt%java ParsingMain Once upon a time there was a programming language
named Java!
0:Once
1:upon
2:a
3:time
4:there
5:was
6:a
7:programming
8:language
9:named
10:Java!
We can use the string array passed as argument of the main function of
programs, to process inputs. Since these elementary inputs are considered as
strings, we may eventually need to re-interpret them into the appropriate type
before processing them. For example, consider the following program that seeks
for the smallest integer entered in the arguments of the command line:
Program 4.14
Array of strings in main
class
ParseArgumentsMin{
public
static void main ( String [ ]
args )
{
int indexMin=0;
for ( int
i =1; i<args . length ; i++)
i f
( Integer . parseInt ( args [ indexMin ] )>Integer . parseInt (
args [ i ] ) )
indexMin=i ;
System . out . p r i n t l n ( "Maximum argument found at index:"+
indexMin+" :"+args [ indexMin ] ) ;
}
}
Compiling and running this program with argument strings “345”, “546”,
“234”, “2” and “45”, we get:
prompt%javac ParseArgumentsMinInt.java
prompt%java ParseArgumentsMin 345 546 234 2 45
Maximum argument found at index:3 :2
Once the strings are converted into corresponding integers using the library
function Integer.parseInt, we get the index of the smallest argument: 2.
Indeed args[3] corresponds to the string “2.”

4.7 A basic application of arrays: Searching **
99
4.7 A basic application of arrays: Searching **
Consider the following simple search problem encountered very day by in
programmers: We are given a set E of n integers E = {E1, ..., En}, and we
would like to know whether a given query element E belongs to that set or not:
That is mathematically for short, E ∈E?. This search task is essential to decide
whether we should add this element to the set or not. Let the data-structure
for storing the n elements of E be an array named array.
The sequential search inspects in turn all the array elements array[i] and
performs a comparison with the query element E to check for equality or not. If
for a given index position i the query element matches the array element (that
is, predicate array[i]==E is evaluated to true) then the element is found and
the index of its position in the array is reported. Otherwise, we need to browse
the full array before answering that E was not found in the array. This sequential
search approach is summarized by the following program:
Program 4.15
Sequential search: Exhaustive search on arrays
class
SequentialSearch {
static
int
SequentialSearch ( int
[ ]
array ,
int key )
{ int
i ;
for ( i =0; i<array . length ; i++)
i f
( array [ i ]==key )
return
i ;
return −1;
}
public
static void main ( String [ ]
args )
{
int
[ ]
v={1 ,6 ,9
,12
,45 ,
67 ,
76 ,
80 ,
95};
System . out . p r i n t l n ( "Seeking for element 6: Position "+
SequentialSearch (v , 6 ) ) ;
System . out . p r i n t l n ( "Seeking for element 80: Position "+
SequentialSearch (v , 8 0 ) ) ;
System . out . p r i n t l n ( "Seeking for element 33: Position "+
SequentialSearch (v , 3 3 ) ) ;
}
}
Running the program, we get the following output:
Seeking for element 6: Position 1
Seeking for element 80: Position 7
Seeking for element 33: Position -1
For query elements that are not present inside the array, we have to wait to
reach the end of array to return −1. This explains why this sequential search is

100
4. Arrays
also called the linear search since it takes time proportional to the array length.
The algorithmic question raised is to know whether there exists or not a faster
method? Observe that in the above program the array elements were ordered in
increasing order. We should try to use this extra property to speed-up the search
algorithm. The idea is to skip browsing some portions of the arrays for which
we know that the query element cannot be found for sure. Start with a search
interval [left, right] initialized with the extremal array indices: left= 0 and
right= n−1 where n denote the array length array.length. Let m denote the
index of the middle element of this range: m = (left + right)/2. Then execute
recursively the following steps:
– If array[m]==E then we are done, and we return index m,
– If array[m] <E, then if the element is inside the array, it is necessarily within
range [m + 1, right],
– If array[m] >E, then if the element is inside the array, it is necessarily within
range [left, m + 1].
The search algorithm terminates whenever we ﬁnd the element, or if at some
point left>right. In that latter case, we return index −1 for reporting that we
did not ﬁnd the query element. Thus the dichotomic search (also called binary
search) is a provably fast method for searching whether or not a query element
is inside a sorted array by successively halving the index range. The number of
steps required to answer an element membership is thus proportional to log2 n.
The dichotomic search is said to have logarithmic time complexity. These time
complexity notions will be further explained in Chapter 6. We summarize the
bisection search by the following code:
Program 4.16
Binary search: Fast dichotomic search on sorted arrays
class
BinarySearch {
static
int Dichotomy ( int
[ ]
array ,
int
l e f t ,
int
right ,
int
key )
{
i f
( l e f t >r i g h t )
return −1;
int m=( l e f t+r i g h t ) /2;
i f
( array [m]==key )
{return m;}
else
{
i f
( array [m]<key ) return Dichotomy ( array ,m+1, right ,
key ) ;
else
return Dichotomy ( array , l e f t ,m−1, key ) ;
}
}
static
int
DichotomicSearch ( int
[ ]
array ,
int key )
{return Dichotomy ( array , 0 , array . length −1, key ) ;}
public
static void main ( String [ ]
args )

4.8 Exercises
101
{
int
[ ]
v={1 ,6 ,9
,12
,45 ,
67 ,
76 ,
80 ,
95};
System . out . p r i n t l n ( "Seeking for element 6: Position "+
DichotomicSearch (v , 6 ) ) ;
System . out . p r i n t l n ( "Seeking for element 80: Position "+
DichotomicSearch (v , 8 0 ) ) ;
System . out . p r i n t l n ( "Seeking for element 33: Position "+
DichotomicSearch (v , 3 3 ) ) ;
}
}
We get the following console output:
Seeking for element 6: Position 1
Seeking for element 80: Position 7
Seeking for element 33: Position -1
4.8 Exercises
Exercise 4.1 (Array of strings)
Write a static function DisplayArray that reports the number of
elements in an array of strings, and displays in the console output
all string elements. Give another function DisplayReverseArray that
displays the array in reverse order.
Exercise 4.2 (Pass-by-value array arguments)
Explain why the following permute function does not work:
Program 4.17
Permuting strings and Java’s pass-by-reference
class ExoArray{
static void permute ( String
s1 ,
String
s2 )
{
String tmp=s1 ;
s1=s2 ;
s2=tmp ;
}
public
static void main ( String
args [ ] )
{
String
[ ]
array={"shark" , "dog" , "cat" , "crocodile" };
permute ( array [ 0 ] , array [ 1 ] ) ;
System . out . p r i n t l n ( array [0]+ " "+array [ 1 ] ) ;
}
}
Give a static function static void permute(String [] tab, int i,
int j) that allows one to permute the element at index position i with

102
4. Arrays
the element at index position j. Explain the fundamental diﬀerences with
the former permute function.
Exercise 4.3 (Searching for words in dictionary)
Consider a dictionary of words stored in a plain array of strings: String
[] dictionary. Write a function static boolean isInDictionary
that takes as argument a given word stored in a String variable, and
report whether the word is already deﬁned inside the dictionary or not.
Explain your choice for performing equality tests of words.
Exercise 4.4 (Cumulative sums: Sequential and recursive)
Write a function that takes a single array argument of elements of
type double, and returns its cumulative sum by iteratively adding the
elements altogether. Computing the cumulative sum of an array can also
be done recursively by using, for example, the following function proto-
type CumulativeSumRec(double array, int left, int right). Im-
plement this function and test it using CumulativeSumRec(array, 0,
array.length-1);
Exercise 4.5 (Chasing bugs)
The following program when executed yields the following exception:
Exception in thread "main" java.lang.NullPointerException
at BugArrayDeclaration.main(BugArrayDeclaration.java:8)
Program 4.18
Bug in array declaration
class
BugArrayDeclaration
{
public
static void main ( String
[ ]
t )
{
int
[ ]
array ;
int
[ ]
array2=null ;
array=array2 ;
array [0]=1;
}
}
Find the bug and correct the program so that it runs without any bug.
Exercise 4.6 (Sieve of Eratosthenes)
One wants to compute all prime integers falling within range [2, N] for
a prescribed integer N ∈N. The sieve of Eratosthenes algorithm uses a
boolean array to mark prime numbers, and proceeds as follows:

4.8 Exercises
103
– First, the smallest prime integer is 2. Strike oﬀ2 and all multiples of
2 in the array (setting the array elements to false),
– Retrieve the smallest remaining prime number p in the array (marked
with boolean true), and strike oﬀall multiples of p,
– Repeat the former step until we reach at some stage p >
√
N, and list
all prime integers.
Design a function static int[] Eratosthene(int N) that returns in
an integer array all prime numbers falling in range [2, N].
Exercise 4.7 (Image histogram)
Consider that an image with grey level ranging in [0, 255] has been
created and stored in the regular bi-dimensional data-structure byte
[] [] img;. How do we retrieve the image dimensions (width and
height) from this array? Give a procedure that calculates the histogram
distribution of the image. (Hint: Do not forget to perform the histogram
normalization so that the cumulative distribution of grey colors sums up
to 1.)
Exercise 4.8 (Ragged array for symmetric matrices)
A d-dimensional symmetric matrix M is such that Mi,j = Mj,i for all
1 ≤i, j ≤d. That is, matrix M equals its transpose matrix: M T = M.
Consider storing only the elements Mi,j with d ≥i ≥j ≥1 into a ragged
array: double [] [] symMatrix=new double [d][];. Write the array
allocation instructions that create a 1D array of length i for each row of
the symMatrix. Provides a static function that allows one to multiply two
such symmetric matrices stored in “triangular” bi-dimensional ragged
arrays.
Exercise 4.9 (Birthday paradox **)
In probability theory, the birthday paradox is a mathematically well-
explained phenomenon that states that the probability of having at least
two people in a group of n people having the same birthday is above 1
2
for n ≥23. For n = 57 the probability goes above 99%. Using the
Math.random() function and a boolean array for modeling the 365 days,
simulate the birthday paradox experiment of having at least two people
having the same birthday among a set of n people. Run this birthday
experiment many times to get empirical probabilities for various values
of n. Then show mathematically that the probability of having at least
two person’s birthdays falling the same day among a group of n people
is exactly 1 −
365!
365n(365−n)!.

5
Objects and Strings
5.1 Why do programmers need objects?
We have so far presented the basic primitive types (say, boolean, int and long,
float and double) of Java and explained how to build homogeneous arrays of
these primitive types. Objects are useful for two main reasons:
– (1) Objects allow one to encapsulate and structure a set of data,
– (2) Objects provide a set of functions called methods acting on the encapsu-
lated data.
For example, we would like to create objects for storing dates and write
an agenda program that manipulates these “date” objects. A date can be
deﬁned as a triplet of numbers, say MM/DD/YYYY for storing respectively the
month, day and year of the considered date. This triplet of numbers represents
the core data-structure of dates. The object-oriented programming framework
allows one to deﬁne and work on complex entities by encapsulating the various
concepts at the object level. For example, we may like to deﬁne the following
object entities:
– A data-structure for manipulating 2D colored points,
– A data-structure for manipulating students.
The various data encapsulated in objects are called records, and the variables
to access them are called ﬁelds. For a 2D colored point object, we may wish
F. Nielsen, A Concise and Practical Introduction to Programming Algorithms in Java,
Undergraduate Topics in Computer Science, DOI 10.1007/978-1-84882-339-6 5,
c⃝Springer-Verlag London Limited, 2009

108
5. Objects and Strings
to dispose of the point coordinates (x, y) and a triplet red/green/blue, say, for
encoding its color properties (R, G, B). For a student object, we may rather
deﬁne the following ﬁelds: Lastname, ﬁrstname, group, etc. Java is such an
object-oriented (OO) programming language.
We ﬁrst start by presenting how to deﬁne and create objects, and then describe
how to write non-static functions acting on the object’s records: methods.
Furthermore, we shall see how to create arrays of non-primitive elements: arrays
of objects. Finally, we will present the String class, which is a particular class
standardized in Java. We will quickly overview a set of methods that that class
oﬀers.
5.2 Declaring classes and creating objects
To create objects, we ﬁrst need to declare them by creating a new class for
structuring them. Objects are also typed structures: The class name deﬁnes
the type of objects. Once the object records are clearly identiﬁed in the design
stage, we create corresponding variable ﬁelds in the class by deﬁning variables
without using the keyword static. Fields are also called object variables and
do not have the leading keyword static. Thus to create an object for storing
dates, we ﬁrst deﬁne the corresponding class Date, which contains the ﬁelds
dd, mm and yyyy for storing respectively the day, month and year of the date.
The class declaration for Date is as follows:
class Date
{
int dd;
// field for day (no static keyword here!)
int mm;
// field for month
int yyyy; // field for year
}
Let us suppose that we created an object day of type Date. Then the variable
dd of Date (its record) and can be accessed by the programmer by writing
day.dd: That is, the record dd of the object day. Similarly, the month and year
object records are accessed by writing day.mm and day.yyyy.
An object storing records of students can be similarly created from a
corresponding class Student that encapsulates the various data attached to
a student identity. Fields may not be all of primitive types. For example, we
may also attach to a student object an array of double for storing his/her exam
marks. Thus we may come up with the following class structure for deﬁning
the class Student:
class Student
{

5.2 Declaring classes and creating objects
109
String Lastname;
String Firstname;
int Company;
double [ ] Marks;
...
}
5.2.1 Constructor and object creation
To use an object, we ﬁrst need to create it by instantiating the various ﬁelds
of the class by a special method called the constructor. We build an object
using the new keyword that will call the constructor method of the class. A
constructor is an object method bearing the class name. A constructor as all
other object methods is a non-static function. To access a record of an object
inside the current object, we use the keyword this. Thus this.field will
return the value of the field variable of the current object. The program
below shows how to deﬁne a class Date with its constructor:
Program 5.1
A class for storing dates with a constructor method
class Date
{
int dd ;
int mm;
int yyyy ;
// Constructor
Date ( int day ,
int month ,
int
year )
{ this . dd=day ;
this .mm=month ;
this . yyyy=year ;}
}
An object day of type Date is created by the following instruction:
Date day=new Date(23,12,1971);
The various records of that date object are accessed by day.dd, day.mm and
day.yyyy. The program below shows how to put altogether the newly created
class Date for encapsulating a date with the class program that creates an
object of this type and displays its various records:
Program 5.2
A small demonstration program using the Date class
class Date
{
int dd ;
int mm;
int yyyy ;

110
5. Objects and Strings
// Constructor (method)
Date ( int day ,
int month ,
int
year )
{
this . dd=day ;
this .mm=month ;
this . yyyy=year ;
}
}
class DemoDate{
public
static void main ( String [ ]
args )
{
Date day=new Date (23 ,12 ,1971) ;
System . out . p r i n t l n ( "Date:"+day . dd+"/"+day .mm+"/"+day . yyyy ) ;
}
}
A class may potentially supply several constructors provided that they all bear
diﬀerent signatures. For now, it is best to deﬁne a single constructor that
initializes all the ﬁelds of the object. Fields of the current object are accessed
by using the keyword this. Although it is not mandatory to use it explicitly
inside the constructor, we recommend initializing the object records in the
constructor by using this:
Date(int day, int month, int year)
{this.dd=day;
this.mm=month;
yyyy=year; // we omitted the keyword this here
}
Note that in cases where no constructor is provided, Java will use a default
constructor common to all objects. Fields can still be assigned after the object
creation as follows:
Date day=new Date();// default constructor called
day.yyyy=1971;
...
We can visualize the object creation and its relationship as depicted in
Figure 5.1.
5.2.2 The common null object
Similar to arrays, we can ﬁrst deﬁne object variables and create/initialize them
later. For example, consider the following code:
Date day;
...// do some instructions here
Date day=new Date(23,12,1971);

5.2 Declaring classes and creating objects
111
CLASS
OBJECT
OBJECT
records
methods
records
methods
ﬁelds
constructor
instance of
instance of
Figure 5.1
Visualizing the class ﬁelds
and the object records when creating
object instances of a class
Thus it might be the case that some instructions try to access the records
of an object that is not yet created or initialized. This will raise an excep-
tion nullPointerException and provoke an abnormal program termination.
Indeed, objects not yet created have by default value null. The null object
is common to all classes and is used as the default value of object variables
not yet created. To avoid nullPointerException exception, it is therefore
recommended to test whether the object is null or not, as follows:
Student stud=null;
...
if (stud!=null)
stud.group=2;
5.2.3 Static (class) functions with objects as arguments
Objects can also be parameters of functions. That is, a static function may
have both primitive and non-primitive type objects. The generic prototype of
a function having object arguments is:
static TypeF F(Object1 obj1, ..., ObjectN objN)
For example, we may declare the following class function static boolean
isBefore (Date d1, Date d2). Functions may also return an object as a
result as in static Date readDate(). The program below demonstrates these
ﬂexibilities:

112
5. Objects and Strings
Program 5.3
Objects as function parameters and returned results
class Date
{
int dd ;
int mm;
int yyyy ;
static
final
String [
]
months={
"January" , "February" , "March" , "April" , "May" ,
"June" , "July" , "August" , "September" , "October" ,
"November" , "December"
};
// Constructor
Date ( int day ,
int month ,
int
year )
{
this . dd=day ;
this .mm=month ;
this . yyyy=year ;
}
}
Observe the construction of a constant array of strings months using the
syntax static final String []. The keyword public can be omitted in this
textbook (except for the main program class function) since we do not deal with
object inheritance, another important concept of object-oriented programming
languages.
Program 5.4
Testing the Date class
class
TestDate{
static void Display ( Date d) {
System . out . p r i n t l n ( "The "+d . dd+" "+Date . months [ d .mm−1]+" of
"+d . yyyy ) ;
}
static boolean
i s B e f o r e ( Date d1 ,
Date d2 )
{
boolean
r e s u l t=true ;
i f
( d1 . yyyy>d2 . yyyy )
r e s u l t=false ;
i f
( d1 . yyyy==d2 . yyyy && d1 .mm>d2 .mm)
r e s u l t=false ;
i f
( d1 . yyyy==d2 . yyyy && d1 .mm==d2 .mm && d1 . dd>d2 . dd)
r e s u l t=
false ;
return
r e s u l t ;
}
public
static void main ( String [ ]
args )
{
Date day1=new Date (23 ,12 ,1971) ;
Display ( day1 ) ;
Date day2=new Date (23 ,6 ,1980) ;
System . out . p r i n t l n ( i s B e f o r e ( day1 , day2 ) ) ;

5.3 Objects and references
113
}
}
5.3 Objects and references
Variables of a given object type are allocated into the global memory, and
references to these memory structures are stored into the variables. This is to
contrast with variables of primitive types that are manipulated by value. Similar
to array variables, a variable of type object is a reference to that object. That
is, loosely speaking, the variable stores the memory address of this referenced
object. Thus when we write:
Date day1=new Date(23,12,1971);
Date day2=day1;
Display(day2);
day2.mm=6;
Display(day1);
We get:
Date:23/12/1971
Date:23/6/1971
main
day1=new ...
...
day2=day1;
day2.mm=6;
Date@
dd
mm
yyyy
global memory
local memory
(function call stack)
Figure
5.2
Objects
are
non-
primitive typed structures that are
stored in the program global mem-
ory and manipulated by references
(and not by values)
The date day1 is not copied to day2, but only their references are copied.
That is, the reference of day2 is assigned to the reference of day1 so that their
object records necessarily match since they refer to the same memory location
as depicted in Figure 5.2.

114
5. Objects and Strings
5.3.1 Copying objects: Cloning
To copy or clone an object to another one, we need to do it ﬁeld-wise. Otherwise
we will copy only the references (as it was the case for day2=day1). There are
two scenarii, depending on whether the second object has already been created
(formerly using the keyword new) or not:
Program 5.5
Cloning objects: Two scenarii
// Two Scenarii:
// Here , we assume that day2 has already been created...
day2 . dd=day1 . dd ;
day2 .mm=day1 .mm;
day2 . yyyy=day1 . yyyy ;
// day2 object has not yet been created...
static
Date Copy( date day1 )
{
Date newdate=new Date ( day1 . dd , day1 .mm, day1 . yyyy ) ;
return newdate ;
}
. . .
Date d2=Copy( d1 ) ;
Copying verbatim all records of one object to another object is also called deep
copying. Copying just their reference is shallow copying.
5.3.2 Testing for object equality
When writing programs, we often need to test for object equality. Do not use the
regular syntax == for object equality since it will only compare their references.
Of course, if references match then their ﬁelds also necessarily match. But the
general case is to have two objects created with their respective ﬁelds, for which
we would like to test for equality, ﬁeld by ﬁeld. Thus to physically compare
objects, we need to deﬁne and use a tailored predicate that checks the objects
ﬁeld by ﬁeld. For example, considering the Date objects, we may design the
following predicate:
Program 5.6
Predicate for checking whether two dates of type Date are
identical or not
static boolean isEqual ( Date d1 ,
Date d2 )
{
return ( d1 . dd == d2 . dd &&
d1 .mm == d2 .mm &&
d1 . yyyy== d2 . yyyy ) ;
}

5.4 Array of objects
115
Here is a test program for using the isEqual predicate:
public static void main(String[] args)
{
Date day1=new Date(23,12,1971);
Date day2=day1; // beware not copying here: shallow copying
Date day3=new Date(23,12,1971);
System.out.println(isEqual(day1,day3));
System.out.println(day1);
System.out.println(day2);
System.out.println(day3);
}
Running this program, we get the following console output:
true
Date@3e25a5
Date@3e25a5
Date@19821f
This shows that day1 and day3 are identical (that is, they match ﬁeld by
ﬁeld ) although their references are diﬀerent. Figure 5.3 illustrates the object
creations: Their references are stored into the local stack function and the
objects are stored into the global (persistent) memory.
global memory
local memory
(function call stack)
Date day1=new Date(23,12,1971);
Date day2=day1;
Date day3=new Date(23,12,1971);
...
Date@
dd=23
mm=12
yyyy=1971
Date@
dd=23
mm=12
yyyy=1971
Figure
5.3
Testing for object
equality using a tailored predicate
that compares ﬁeld by ﬁeld the
objects.
5.4 Array of objects
Since newly created classes also deﬁne new corresponding types, we can create
an array of objects. For example, to create an array of objects of type Date,
we use the following syntax:
Date [ ] tabDates=new Date[31];

116
5. Objects and Strings
When an array of objects is built, all its elements Date[i] are initialized to
the null object.1 Let us create a new kind of object for storing “events” that
are annotated dates, by deﬁning the class XEvent as follows:
public class XEvent
{
Date when;
String what;
// Constructor
public XEvent(Date d, String text)
{
this.when=d;
this.what=text;
}
}
We can now write a static class function static XEvent oldest(XEvent[]
tab) attached to the class TestXEvent for seeking in an array and reporting
the oldest event as follows:
Program 5.7
The class XEvent and arrays of objects
class
TestXEvent
{ static void Display (XEvent e )
{ System . out . print ( e . what+": " ) ;
e . when . Display () ;
}
static boolean
older (XEvent e1 ,
XEvent e2 )
{return Date . i s B e f o r e ( e1 . when , e2 . when) ;}
static XEvent
o l d e s t (XEvent [ ]
tab )
{
XEvent
r e s u l t=tab [ 0 ] ;
for ( int
i =1; i<tab . length;++ i )
i f
( older ( tab [ i ] , r e s u l t ) )
r e s u l t=tab [ i ] ;
return
r e s u l t ;
}
public
static void
main ( String
[ ]
args )
{
Date d1=new Date (26 ,6 ,2003) ;
XEvent e1=new XEvent(d1 , "Birthday Julien" ) ;
Date d2=new Date (20 ,11 ,2000) ;
XEvent e2=new XEvent(d2 , "Birthday Audrey" ) ;
Date d3=new Date (23 ,6 ,1971) ;
XEvent e3=new XEvent(d3 , "Birthday Me" ) ;
Display ( e1 ) ;
XEvent
[ ]
tabEvent=new XEvent [ 3 ] ;
tabEvent [0]= e1 ;
1 This can be interpreted as the equivalent of the zero initialization of primitive
types.

5.5 Objects with array members
117
tabEvent [1]= e2 ;
tabEvent [2]= e3 ;
System . out . print ( "Oldest person::" ) ;
Display ( o l d e s t ( tabEvent ) ) ;
}
}
Running this program yields the following console output:
Birthday Julien: 26 June 2003
Oldest person::Birthday Me: 23 June 1971
5.5 Objects with array members
Records of objects may also contain arrays. These arrays should always be built
by the object constructor as follows: new Type[sizeArrayExpression]. Thus
it is not necessary at compile time to know the array sizes provided that at
run time the expression sizeArrayExpression can be evaluated to an integer
value. In the chapter introduction, we mentioned that for student objects, we
would like to store their grades using an array of double. Another example is
a data-structure for polynomials that may be created using the following class:
class Polynome{
int degree;
double [ ] coefficients; // Array declaration
};
5.6 The standardized String objects
5.6.1 Declaring and assigning String variables
In Java, a string of characters is manipulated with an object of type String.
The String type does not belong to the primitive types (boolean, int, double,
etc.), but is rather a non-primitive object type. Therefore, a variable of type
String is a reference to that object in the global memory. Thus for the same
reasons as for the case of integers, the following badSwap function will not
swap the string variables since once the function is executed the values of p
and q (that is, the respective references) are kept unchanged: Java is pass-
by-value/reference only. For non-primitive types such as arrays, objects and
strings, the stored value is a reference.
static void badSwap(String p, String q)

118
5. Objects and Strings
{ String tmp;
tmp=p;
p=q;
q=tmp;}
To declare and initialize a string2, we proceed as follows
String title= "First Hands-on Programming!";
String anotherTitle=title;
...
title="Extreme programming sounds better!"; // String can be modified
To print a string, use the regular System.out.println() function:
System.out.println(title);
Java proposes many standard functions for eﬃciently manipulating strings. Let
us next review only the very fundamental functions that operate on String
objects.
5.6.2 Length of a string: length()
The length of a string object is deﬁned as its number of characters. The length
of a string is reported by calling the length() method on the String object,
as shown below:
String s= "Supercalifragilisticexpialidocious";
System.out.println(s.length());
We get 34, which is the longest invented word in a song from Mary Poppins
written by the Sherman Brothers in 1964. Observe that the syntax is diﬀerent
from arrays. For an array array, we get its length (that is, its number of
elements) by the following syntax: array.length. But for a string, we use the
method length() (with no argument, which explains the () parentheses).
5.6.3 Equality test for strings: equals(String str)
To test whether two strings s1 and s2 are identical or not, do not use the
regular == equality test for primitive types. Indeed testing whether two strings
are identical or not by using the comparison == will check whether the references
of these strings are identical or not. Instead, to test whether the contents of
2 Use
String
objects
only
for
moderate
length
strings,
otherwise
use
the
better
class
StringBuffer.
See
Java
API
at
http://java.sun.com/j2se/1.4.2/docs/api/java/lang/StringBuffer.html

5.6 The standardized String objects
119
the two strings are identical or not, use the method equals(str) with a string
argument str. Considers for example, the following sequence of instructions:
String s1="java";
String s2="JAVA";
System.out.println(s1.equals(s2));
We get false on the console output since Java is case-sensitive: That is, upper
cases are considered diﬀerent from lower cases in Java.
We can access the character of the string at position k−1 by calling the method
charAt(k). Again, indexes of characters range from 0 to the string length minus
one. For example, consider the following code:
String s= "3.14159265";
System.out.println(s.charAt(1));
Then the executed program writes the separation “.” on the console. We can
assign a character variable with that string character as follows:
char c=s.charAt(1);
5.6.4 Comparing strings: Lexicographic order
Before comparing strings of various lengths, we ﬁrst need to deﬁne what is
meant by the comparison of two elementary characters. The “distance” between
two characters is deﬁned as the span in the ASCII3 code table. Since Java is
case-sensitive, lower cases are diﬀerent from upper cases (they have diﬀerent
integer codes), and the same character appears twice in the ASCII table: once
for the upper case and once for the lower case. The following code demonstrates
the lower/upper case-sensitivity of Java:
Program 5.8
Lower/upper cases and ASCII codes of characters
char c1 , c2 ;
c1=’a’ ;
c2=’z’ ;
// Compare character code
i f
( c1<c2 )
{System . out . p r i n t l n ( c1+" is before "+c2 ) ;}
else
{System . out . p r i n t l n ( c1+" is after or equal to "+c2 ) ;}
int
codec1=c1 ;
// type casting/conversion
int
codec2=c2 ;
// type casting conversion
System . out . p r i n t l n ( "Code ASCII for "+c1+":"+codec1 ) ;
System . out . p r i n t l n ( "Code ASCII for "+c2+":"+codec2 ) ;
3 American
Standard
Code
for
Information
Interchange
(ASCII).
See
AmericanStandardCodeforInformationInterchange(ASCII).
In
fact,
Java
encodes characters using two bytes for encoding many diﬀerent language character
sets and kanjis. See UNICODE at http://en.wikipedia.org/wiki/Unicode

120
5. Objects and Strings
Running this code, we get
a is before z
Code ASCII for a:97
Code ASCII for z:122
One can convert a lower-case string to an upper-case string by performing the
following arithmetic operations on characters (with char⇔int casting):
Program 5.9
Lower-case to upper-case string conversion
static
String
LowerToUpper ( String
s )
{
String
r e s u l t="" ;
char c ;
for ( int
i =0; i<s . length () ; i++)
{
c=(char ) ( s . charAt ( i ) −32) ;
//32=2^5
r e s u l t+=c ;
//concatenation , append c to result
}
return
r e s u l t ;
}
. . .
String
s=LowerToUpper ( "convert a simple sentence" ) ;
To compare string s1 with string s2, we ﬁrst need to deﬁne a total order between
these strings so that we can report whatever the input strings whether
– s1 < s2,
– s1 = s2 or
– s1 > s2.
This total order is called the lexicographic order and is deﬁned for strings as
follows:
– If one string is a substring of another one, then report the length diﬀerence:
Positive or negative number. Zero if and only if the strings are exactly the
same.
– Otherwise, there necessarily exists an index where the two string characters
diﬀer. Report then the diﬀerence in ASCII code of these two diﬀerent
characters.
To lexicographically compare two strings in Java, use the method compareTo(str)
method as follows:
String u="Polyhedron", v="Polyhedral";
System.out.println(u.compareTo(v));
// => 14= ’o’-’a’=111-97;

5.6 The standardized String objects
121
p
o
l
y
h
e
d
r
o
n
p
o
l
y
h
e
d
r
a
l
System.out.println("o:"+(int)’o’);
System.out.println("a:"+(int)’a’);
int diff=’o’-’a’; // implicit casting char->int
System.out.println(diff);
We get:
o:111
a:97
14
Now consider the case of one string being the substring of another one:
String a="polyhedral",b="polyhedralization";
System.out.println(a.compareTo(b));
System.out.println(a.length()-b.length());
We ﬁnd both times −7. This is the diﬀerence between the length of string a
and the length of string b.
We can implement our own static function for performing the lexicographic
order on strings as follows:
Program 5.10
Implementation of the lexicographic order on strings
static
int
LexicographicOrder ( String p ,
String q)
{
int
i =0;
while ( i<p . length () && i<q . length () )
{ i f
(p . charAt ( i )==q . charAt ( i ) )
i ++;
else
return p . charAt ( i )−q . charAt ( i ) ;
}
return p . length ()−q . length () ;
}
As a ﬁnal example of the use of lexicographic order of strings in programs, let us
play again with the string array argument of the main function (public static
void main(String[ ] args)). The following program ﬁnds among the string
arguments of the main function the lexicographically smallest string:
Program 5.11
Reporting the lexicographically minimum string of the
command line arguments
class
ParsingArgument{
public
static void main ( String [ ]
args )
{
String minimum=args [ 0 ] ;
for ( int
i =1; i<args . length ; i++)

122
5. Objects and Strings
i f
(minimum . compareTo ( args [ i ] ) >0)
minimum=args [ i ] ;
System . out . p r i n t l n ( "Lexicographically minimum string is:"
+minimum) ;
}
}
For example, calling the above compiled program with arguments rock doll
dance dancing, we get:
prompt%java ParsingArgument rock doll dance dancing
Lexicographically minimum string is:dance
5.7 Revisiting a basic program skeleton
Let us close this chapter by writing a small skeleton program that deﬁnes a
new class and uses this class in the main function of the program class:
Program 5.12
A more evolved basic skeleton program that also deﬁnes
classes
class
Point
{
int x , y ;
Point ( int xx ,
int yy ) {x=xx ; y=yy ;}
} // end of class Point
class
Skeleton
{
// Static class variables
static
int
nbpoint =0;
static double x ;
static boolean
[ ]
prime ;
static
int
f1 ( int p) {return p /2;}
static
int
f2 ( int p) {return 2∗p ;}
public
static void Display ( Point p)
{System . out . p r i n t l n ( "("+p . x+","+p . y+")" ) ;}
public
static void main ( String
[ ]
argArray )
{
System . out . p r i n t l n ( f2 ( f1 (3) )+" versus (!=) "+f1 ( f2 (3) ) ) ;
Point p , q ;
p=new Point (2 ,1) ;
nbpoint++;
q=new Point (3 ,4) ;
nbpoint++;
Display (p) ;
Display (q) ;
} }

5.8 Exercises
123
Compiling and running this program, we obtain the following console output:
2 versus (!=) 3
(2,1)
(3,4)
5.8 Exercises
Exercise 5.1 (A class for storing supermarket product items)
In a supermarket, each product is typically labeled with:
– (1) a string depicting the product name,
– (2) a price tag, and
– (3) a date of validity that informs when the product expires.
Write a class Date for storing dates with a constructor that initializes
these various ﬁelds. Write another class Product for storing information
related to products that use the class Date. Store a collection of product
items into an array of Product elements. Given a product query element
Element, write a function that checks whether the product is inside the
array or not. The equality test shall be deﬁned by using the product
strings only. Write a function that, given a price range low and high,
reports all product items with prices falling inside this range. Finally,
describe a function that takes as its argument a given date, and report
all elements of the array expiring before this date.
Exercise 5.2 (Lexicographic order on 2D points)
Write a class Point2D for storing the (x, y) coordinates of points. We
would like to totally order points so that given two points P1 = (x1, y1)
and P2 = (x2, y2), P1 < P2 if and only if x1 < x2 or x1 = x2 and y1 <
y2. Write a predicate function static boolean LessThan(Point2D P1,
Point2D P2) that implements this lexicographic order. Consider now an
array of 2D points. Give a function that reports the smallest point deﬁned
with respect to that lexicographic order. Extend these functions to 3D
point sets stored in an array.
Exercise 5.3 (Lexicographic order for the Olympic games)
Design a class Medals for storing the number of gold, silver and bronze
medals of a given country. Provide a constructor for that class. Deﬁne
then a lexicographic order on two objects a and b of type Medals as
follows: a<b if and only if:

124
5. Objects and Strings
– the number of gold medals of a is less than the number of gold medals
of b, or
– the number of gold medals are identical but the number of silver
medals of a is less than the number of silver medals of b, or
– the number of gold and silver medals are identical but the number of
bronze medals of a is less than the number of silver medals of b.
Exercise 5.4 (A class for polynomials)
Consider deﬁning a class for storing polynomials of arbitrary degree as
follows:
Program 5.13
A class for polynomials
class
Polynomial
{
int
degree ;
long
[ ]
c o e f f i c i e n t ;
. . .
}
Observe that a polynomial of degree d has d + 1 coeﬃcients. Provide
a constructor Polynomial(int deg) for that class that initializes all
deg+1 coeﬃcients to zero. Then design and implement the following
static functions:
– A clone function static Polynomial copy(Polynomial source);
– A display procedure static void display(Polynomial source);
– An equality predicate:
static boolean equalTo(Polynomial P, Polynomial Q);
– A function static Polynomial derivative(Polynomial source);
that computes the derivative of a polynomial.
– A function static Polynomial add(Polynomial P, Polynomial Q);
that adds two polynomials. Similarly, a function that subtracts two
polynomials:
static Polynomial subtract(Polynomial P, Polynomial Q);
– A function static long evaluate(Polynomial source, long x);
that evaluates the polynomial at value x. What is the time complexity
of this function? Horner proposed a scheme for evaluating polynomials
using only d multiplications and d additions using the following
schema:
P(x) = (...((pdx + pd−1)x + pd−2)x + ...)x + p0

5.8 Exercises
125
Implement the Horner evaluation scheme in function static long
HornerScheme(Polynomial source, long x);
– A function static Polynomial multiply(Polynomial P, Polynomial
Q); for multiplying4 two polynomials. What is the time complexity of
that polynomial multiplication?
Exercise 5.5 (Chevalier de M´er´e’s probability games)
During the 17th century, gambler de M´er´e asked Blaise Pascal an
explanation for his game losses. His question was solved by Pascal
and Fermat, and yielded the foundations of the theory of probability.
Gamblers used to bet on the event of getting at least one ace in four
rolls of a dice. As a game variation, De M´er´e proposed to use two die
and roll them 24 times with a bet on having at least one double ace. De
M´er´e thought the games were equivalent but he lost consistently. Explain
why? Write a simulation program to empirically determine which one
dice/two die game is more likely to win.
Use the following classes:
import java . u t i l . Random ;
class
Dice
{
Random rand ;
Dice ()
{ rand=new Random() ;}
// Return the elementary outcome of tossing a dice: A
face between 1 and 6
int Toss ()
{return 1+rand . nextInt (6) ;}
}
// One dice , four rolls
class DeMereGame1
{
Dice
dice ;
DeMereGame1 ()
{ dice=new Dice () ;
}
// Return true if the gamer win and false otherwise
boolean Experiment ()
{ int
i ;
4 Note that we can perform faster multiplication of polynomials using the Karatsuba
algorithm (O(n1.585) time complexity) or the FFT algorithm (O(n log n)-time).

126
5. Objects and Strings
for ( i =1; i <=4; i++)
{ i f
( dice . Toss ()==6) return true ;
// win
}
return
false ;
// loose
}
}
class DeMereGame2
{
Dice
dice1 ,
dice2 ;
DeMereGame2 ()
{ dice1=new Dice () ; dice2=new Dice () ;}
boolean Experiment ()
{
int
i ;
for ( i =1; i <=24; i++)
{
i f
(( dice1 . Toss ()==6)&&(dice2 . Toss ()==6)) return true ;
// true
}
return
false ;
// loose
}
}

6
Searching and Sorting
6.1 Overview
We have quickly sketched in Chapter 4.7 the sequential and dichotomic/bisec-
tion search strategies to answer element membership queries: Does an element
already belong to the data-set or not? In this chapter, we further describe the
generic framework for inserting/deleting or modifying attributes of elements of
a data-set. We revisit the linear sequential and logarithmic bisection searches
on sets of complex data-structured elements: sets of objects. Since the bisection
search requires arrays to be totally ordered, and since raw arrays of elements
are very unlikely to be already sorted beforehand, we then present two methods
for sorting data-sets:
– (1) The selection sort, which iteratively selects the current smallest element
of remaining sub-arrays, and
– (2) The quicksort, which recursively sorts the arrays by partitioning elements.
Finally, to conclude this chapter, we present the hashing method that is often
used in practice to ﬁnd elements in almost constant time, and summarize the
time complexity of these various methods.
F. Nielsen, A Concise and Practical Introduction to Programming Algorithms in Java,
Undergraduate Topics in Computer Science, DOI 10.1007/978-1-84882-339-6 6,
c⃝Springer-Verlag London Limited, 2009

128
6. Searching and Sorting
6.2 Searching information
When organizing data into objects by deﬁning their records, we access the
various object attributes by deﬁning a key and additional ﬁelds. That is,
complex objects are accessed via their corresponding keys that represent
handles. We suppose that our data-sets ﬁt the local volatile memory so that
all objects can be loaded in the main memory without external input/output.
Further, we ﬁrst suppose static data-structures that are not updated. We will
later consider the more challenging problem of adding/removing or changing
object attributes dynamically.
To ﬁx ideas, consider searching for a word in a dictionary. The basic container
for storing information is the object that consists of a pair of “word” with its
corresponding “deﬁnition.” In Java, we thus declare the following class that
contains the two ﬁelds: word and definition:
class DictionaryEntry
{
String word;
String definition;
}
To create a dictionary, we ﬁrst create an array of DictionaryEntry elements,
and then assign to each element an entry of the dictionary. The following
program illustrates this process:
Program 6.1
Structuring data of a dictionary into basic object elements
class
DictionaryEntry
{
String
word ;
String
d e f i n i t i o n ;
DictionaryEntry ( String w,
String
def )
{ this . word=new String (w) ;
// Clone the strings
this . d e f i n i t i o n=new String ( def ) ;}
}
class
TestMyDictionary
{public
static void main ( String [ ]
args ) {
DictionaryEntry
[ ]
Dico =new DictionaryEntry [ 1 0 ] ;
Dico [0]=new DictionaryEntry ( "Java" , "A modern object -oriented
programming language" ) ;
Dico [1]=new DictionaryEntry ( "C++" , "An effective object -
oriented programming language" ) ;
Dico [2]=new DictionaryEntry ( "FORTRAN" , "FORTRAN stands for
FORmula TRANSlation. Often used for simulation." ) ;
//...
}
}

6.3 Sequential search
129
In practice, elementary data can be arbitrary complex. For example, consider
representing an individual. In that case, the key (handle) of objects can be
either the lastname or the ﬁrstname, and additional ﬁelds could be the address,
phone number, age, etc. Thus all information characterizing an individual can
be modeled by a class with the following set of attributes:
class Individual {
String Firstname;
String Lastname;
String Address;
String Phonenumber;
int Age;
boolean Sex;
}
Let us take a last geometric example for storing points. Each object denotes
then a 2D point, and the key can be the name attached to that point or the x
or y coordinates, etc. Further, additional information ﬁelds may be the point
color attribute, its name, etc. A class for storing points can thus be modeled
as:
class Color {int Red, Green, Blue;}
class Point2D
{
double x;
double y;
String name;
Color color;
}
6.3 Sequential search
Once the class for storing object records has been designed, we consider
representing a set of objects by an array of such objects. Objects are stored in
the array in any order. That is, the set of objects stored in the array is not
sorted into any particular order. To seek whether a given query object is inside
the array or not, we simply browse the array sequentially until we ﬁnd the
object, or we report that it has not been found inside the array. This explains
why the sequential search is also called the linear search since in the worst-case
we need to browse all the array elements to report that the query object was
not found. The basic primitive operation is to compare the key of the query
element with the respective keys of objects of the array. Let us consider a listing
of people, each person modeled by the following class:

130
6. Searching and Sorting
class Person{
String firstname, lastname; // key for searching
String phone; // additional fields go here
// Constructor
Person(String l, String f, String p)
{this.firstname=f; this.lastname=l; this.phone=p;}
};
Let us consider the keys of objects as the lastname and firstname attributes,
and report the phone number record of the object in case the object is found
in the array. The sequential search algorithm is implemented by the following
LinearSearch function:
Program 6.2
Linear search on objects
static
Person [ ]
array=new Person [ 5 ] ;
static
String
LinearSearch ( String
lastname ,
String
firstname )
{
for ( int
i =0; i<array . length ; i++)
{
i f
(( lastname . equals ( array [ i ] . lastname ) &&
( firstname . equals ( array [ i ] . firstname ) ) ) )
{return array [ i ] . phone ;}
}
return "Not found in my dictionary" ;
}
Observe that the predicate for checking whether the keys of the current object
with the given query is not a single == comparison test but rather uses the
String method equals to check that the string contents are identical. The
program below demonstrates the sequential search on an array of Person
initialized. Observe that the array is deﬁned as a static array so that its
data are attached to the program class and can therefore be accessed from the
various static functions of the class.
Program 6.3
A demonstration program using the Person object array
class
LinearSearchProgram {
static
Person [ ]
array=new Person [ 5 ] ;
static
String
LinearSearch ( String
lastname ,
String
firstname )
{ . . . }
public
static void main ( String
[ ]
args )
{
array [0]=new Person ( "Nielsen" , "Frank" , "0169364089" ) ;
array [1]=new Person ( "Nelson" , "Franck" , "04227745221" ) ;
array [2]=new Person ( "Durand" , "Paul" , "0381846245" ) ;
array [3]=new Person ( "Dupond" , "Jean" , "0256234512" ) ;

6.3 Sequential search
131
array [4]=new Person ( "Tanaka" , "Ken" , "+81 3 1234 4567" ) ;
System . out . p r i n t l n ( LinearSearch ( "Durand" , "Paul" ) ) ;
System . out . p r i n t l n ( LinearSearch ( "Tanaka" , "Ken" ) ) ;
System . out . p r i n t l n ( LinearSearch ( "Durand" , "Jean" ) ) ;
}
}
Compiling and running this program, we get:
0381846245
+81 3 1234 4567
Not found in my dictionary
0199989796
6.3.1 Complexity of sequential search
How eﬃcient is the LinearSearch function? Clearly the best-case is when the
query object keys match the keys of the objects stored at the ﬁrst position
of the array (index 0). The worst-case is when the query object keys do not
match the keys of all objects contained in the array. We then need to fully
browse the array, and it takes time proportional to the number of elements in
the array: its length. Let n denote the array size (n=array.size). Then we say
that the worst-case requires time proportional1 to n. In case the query object
is not found, we thus spend linear time. Now consider that the query keys
match some of the array elements. This element can be at index position 0 up
to n −1 with even probability. In case the matching keys are found at index i,
it takes time proportional to i. Thus a successful search requires on average a
time proportional to 1
n
n
i=1 i = (n+1)n
2n
= n+1
2 . Using the time complexity big
Oh-notation, we say that the average complexity time of a successful sequential
search is O(n).
6.3.2 Dynamically adding objects
It is rarely the case that our data-sets are ﬁxed once for all. They evolve with
time as some of the people may leave or others join. We thus need to update
the data-structure. Storing objects in arrays does not oﬀer much ﬂexibility.
For adding new people to the data-set we can ﬁrst create a large array and
keep an indicator of the position of the last inserted individual in the array.
To add new objects, we then add them to the free array cells and consequently
1 In computer science, we use the notation O(n) to denote this time complexity.

132
6. Searching and Sorting
increment the indicator index of the current number of elements. This dynamic
add operation code is summarized in the following listing:
Program 6.4
Adding new Person to the array
public
static
final
int
MAX ELEMENTS=100;
static
int
nbelements =0;
static
Person [ ]
array=new Person [MAX ELEMENTS] ;
static
String
LinearSearch ( String
lastname ,
String
firstname )
{
for ( int
i =0; i<nbelements ; i++)
{
i f
(( lastname . equals ( array [ i ] . lastname ) &&
( firstname . equals ( array [ i ] . firstname ) ) ) )
return array [ i ] . phone ;
}
return "Not found in my dictionary" ;
}
static void AddElement ( Person
obj )
{ i f
( nbelements<MAX ELEMENTS)
array [ nbelements++]=obj ;
// At most MAX_ELEMENTS -1 here
// nbelements is at most equal to MAX_ELEMENTS now
}
Let us illustrate the insertion operations by the following code:
public
static void main ( String
[ ]
args )
{
AddElement (new Person ( "Nielsen" , "Frank" , "0169334089" ) ) ;
AddElement (new Person ( "Nelson" , "Franck" , "04227745221" ) ) ;
AddElement (new Person ( "Durand" , "Paul" , "0381846245" ) ) ;
AddElement (new Person ( "Dupond" , "Jean" , "0256234512" ) ) ;
AddElement (new Person ( "Tanaka" , "Ken" , "+81 3 1234 4567" ) ) ;
System . out . p r i n t l n ( LinearSearch ( "Durand" , "Paul" ) ) ;
System . out . p r i n t l n ( LinearSearch ( "Tanaka" , "Ken" ) ) ;
System . out . p r i n t l n ( LinearSearch ( "Durand" , "Jean" ) ) ;
AddElement (new Person ( "Durand" , "Jean" , "0199989796" ) ) ;
System . out . p r i n t l n ( LinearSearch ( "Durand" , "Jean" ) ) ;
}
Running this code, we get the following console output:
0381846245
+81 3 1234 4567
Not found in my dictionary
0199989796
The main problems of handling a collection of objects by using array data-
structures are:
– We need to know a priori the maximum number of people (so that we do
not encounter an array overﬂow),

6.3 Sequential search
133
– We cannot remove inserted Person objects. The array data-structure is semi-
dynamic.
Furthermore, note that in practice we need to check if a person already belongs
to the array before eventually adding his/her records.
6.3.3 Dichotomy/bisection search
The dichotomy search is also called bisection search. The method was sketched
in chapter 4.7. To perform a bisection search, we need to have an array fully
sorted with respect to the object keys. The bisection search proceeds as follows:
Start with a search interval [left, right] initialized with left= 0 and right=
n −1 where n denote the array length array.length. Let m denote the index
of the middle element of this range: m = (left + right)/2. Then execute the
following recursive steps:
– If array[m]=E then we are done, and we return the index position m,
– If array[m] <E, then if the solution exists it is necessarily within range
[m + 1, right],
– If array[m]>E, then if the solution exists it is necessarily within range
[left, m + 1].
The search algorithm terminates whenever left>right. In that case, we
return index −1 for signaling that we did not ﬁnd the quey element. Thus
a dichotomic search (also called binary or bisection search) is a fast method for
searching whether a query element is inside a sorted array or not by successively
halving the index range. The number of steps required to answer an element
membership is thus proportional to log2 n. The dichotomic search is said to
have logarithmic complexity.
The bisection search code is as follows:
Program 6.5
Bisection search on sorted arrays
static
int Dichotomy ( int
[ ]
array ,
int
l e f t ,
int
right ,
int
key )
{
i f
( l e f t >r i g h t ) return −1;
int m=( l e f t+r i g h t ) /2;
// !!! Euclidean division !!!
i f
( array [m]==key ) return m;
else
{
i f
( array [m]<key ) return Dichotomy ( array ,m+1, right ,
key )
;

134
6. Searching and Sorting
else
return Dichotomy ( array , l e f t ,m−1, key ) ;
}
}
static
int
DichotomicSearch ( int
[ ]
array ,
int key )
{
return Dichotomy ( array , 0 , array . length −1, key ) ;
}
For example, here is a demonstration program that creates a sorted array of
integers and use the dichotomic search:
public
static void main ( String [ ]
args )
{
int
[ ]
v={1, 6 ,
9 , 12
,
45 ,
67 ,
76 ,
80 ,
95};
System . out . p r i n t l n ( "Seeking for element 6: Position "+
DichotomicSearch (v , 6 ) ) ;
//1
System . out . p r i n t l n ( "Seeking for element 80: Position "+
DichotomicSearch (v , 8 0 ) ) ; //7
System . out . p r i n t l n ( "Seeking for element 33: Position "+
DichotomicSearch (v , 3 3 ) ) ;
// -1
}
Running this program, the queries yield indices 1, 7 and −1, respectively. The
last −1 is a code for signaling that the number was not found in the array.
The dichotomic search is exponentially more eﬃcient than the linear search
since the ratio of their time complexity is: O(
n
log2 n). However to perform a
dichotomic search we need to have sorted arrays. Since it is usually not the
case, let us present now two common sorting methods: the selection sort and
the so-called quicksort.
6.4 Sorting arrays
Given an unsorted array of elements, consider the task of sorting all its elements
to get a sorted array in, say, increasing order. Formally, the only two primitive
operations considered for sorting arrays are:
– comparisons and
– element swapping operations.
For example, these basic operations are implemented as follows for integers:
static boolean GreaterThan(int a, int b)
{return (a>b);}
static void swap (int [] array, int i, int j)

6.4 Sorting arrays
135
{
int tmp=array[i];
array[i]=array[j];
array[j]=tmp;
}
Sorting is an entire area ﬁeld of computer science in itself with many algorithms
and remaining challenges to tackle. Next, we present two ﬂagship algorithms:
The selection sort and quicksort.
6.4.1 Sorting by selection: SelectionSort
The selection sort is very natural and proceeds as follows:
– First, seek for the smallest element of the array: This is the SELECTION
stage.
– Then, reiterate the minimum selection for the remaining sub-array:
array[1], ..., array[n-1]
That is, at stage i+1, the selection sort seeks for the smallest elements for the
sub-array
array[j], array[j+1], ..., array[n-1]
To program the selection sort, we use two nested loops:
– The inner loop selects and puts the smallest element in front of the current
array,
– The outer loop repeats the minimum selection/swap for all subarrays.
These steps are summarized in the source code below:
Program 6.6
Sorting by selecting iteratively the minimum elements
static void swap ( int
[ ]
array ,
int
i ,
int
j )
{ int tmp=array [ i ] ; array [ i ]= array [ j ] ; array [ j ]=tmp; }
static void
S e l e c t i o n S o r t ( int
[ ]
array )
{
int n=array . length ;
for ( int
i =0; i<n−1; i++){
for ( int
j=i +1; j<n ; j++){
i f
( GreaterThan ( array [ i ] , array [ j ] ) )
swap ( array , i , j ) ;}
}
}

136
6. Searching and Sorting
To use the selection sort routine, we ﬁrst create an array of integers, call the
static sort function, and then display the sorted array:
public
static void main ( String [ ]
args )
{
int
[ ]
array ={22 ,35 ,19 ,26 ,20 ,13 ,42 ,37 ,11 ,24};
S e l e c t i o n S o r t ( array ) ;
for ( int
i =0; i<array . length ; i++)
System . out . print ( array [ i ]+" " ) ;
System . out . p r i n t l n ( "" ) ;
}
We get the sorted array:
11 13 19 20 22 24 26 35 37 42
A more verbose output will display the status of the array at all stages:
Stage 1:11 35 22 26 20 19 42 37 13 24
Stage 2:11 13 35 26 22 20 42 37 19 24
Stage 3:11 13 19 35 26 22 42 37 20 24
Stage 4:11 13 19 20 35 26 42 37 22 24
Stage 5:11 13 19 20 22 35 42 37 26 24
Stage 6:11 13 19 20 22 24 42 37 35 26
Stage 7:11 13 19 20 22 24 26 42 37 35
Stage 8:11 13 19 20 22 24 26 35 42 37
Stage 9:11 13 19 20 22 24 26 35 37 42
Note that the sorting is performed in-place: That is, we do not need extra
memory to sort the input array. Furthermore, the minimum elements are
searched iteratively in sub-arrays: At stage i + 1, every time a new minimum
is found, it is swapped with the head array[i] of the sub-array.
6.4.2 Extending selection sort to objects
Our implementation of the selection sort program works only for integer arrays.
To extend it to arbitrary object types2, we need to adjust the two basic
primitives: predicate GreaterThan and swapping procedure swap to the type
of considered object type. To illustrate how these changes may be performed,
consider the following type EventObject for handling objects denoting events:
class EventObject
{
int year, month, day;
EventObject(int y, int m, int d)
2 In fact, Java provides a framework called the generics for this purpose that is
beyond the scope of this book.

6.4 Sorting arrays
137
{year=y; month=m; day=d;}
static void Display(EventObject obj)
{System.out.println(obj.year+"/"+obj.month+"/"+obj.day);}
}
Then the two primitives are redeﬁned as follows:
Program 6.7
Redeﬁning the predicate/swap primitives for sorting other
types of elements
static boolean GreaterThan ( EventObject a ,
EventObject b)
{return
((
a . year>b . year )
| |
(
( a . year==b . year ) && ( a . month>b . month) )
| |
(( a . year==b . year ) && ( a . month==b . month) && ( a . day>b . day ) )
)
;}
static void swap ( EventObject
[ ]
array ,
int
i ,
int
j )
{
EventObject tmp=array [ i ] ;
array [ i ]= array [ j ] ;
array [ j ]=tmp ;
}
Observe once again that for non-primitive types, we design a tailor >= predicate
since the usual predicate will only compare references on these objects. Let us
put the pieces altogether and demonstrate selection sorting on a set of events:
Program 6.8
Selection sort on a set of EventObject elements
static void
S e l e c t i o n S o r t ( EventObject
[ ]
array )
{
int n=array . length ;
for ( int
i =0; i<n−1; i++)
for ( int
j=i +1; j<n ; j++)
i f
( GreaterThan ( array [ i ] , array [ j ] ) )
swap ( array , i , j ) ;
}
public
static void main ( String [ ]
args )
{
EventObject
[ ]
array=new EventObject [ 5 ] ;
array [0]=new EventObject (2008 ,06 ,01) ;
array [1]=new EventObject (2005 ,04 ,03) ;
array [2]=new EventObject (2005 ,05 ,27) ;
array [3]=new EventObject (2005 ,04 ,01) ;
array [4]=new EventObject (2005 ,04 ,15) ;
S e l e c t i o n S o r t ( array ) ;
for ( int
i =0; i<array . length ; i++)
EventObject . Display ( array [ i ] ) ;
System . out . p r i n t l n ( "" ) ;

138
6. Searching and Sorting
}
We get the events properly sorted and displayed on the output console:
2005/4/1
2005/4/3
2005/4/15
2005/5/27
2008/6/1
6.4.3 Complexity of selection sorting
Let us now focus on the time complexity of performing a selection sort on
an array of n elements. We shall count only the basic primitive operations
GreatherThan and swap as constant operations, ignoring all other instructions
(for example, increment the loop index, etc). The worst-case scenario of
selection sort is to sort an input array that is sorted using the reverse order:
16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
1, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2
1, 2, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3
...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
Indeed, we need to ﬁnd the minimum of all sub-arrays in the outer loop. This
is done by swapping the current minimum with the current element whenever
the comparison predicate GreaterThan is true. For reverse order sorted arrays,
it takes 2(n + 1 −i) primitive operations at stage i since the GreaterThan is
always evaluated to true so that we need to perform the swapping. Thus the
overall worst-case complexity is n
i=1 2(n+1−i) = 2 n
i=1 i = n(n+1), which
is of the order of n2. Selection sort has quadratic complexity.
This can be checked experimentally by explicitly counting the number of
operations for sorting the reverse ordered array:
Program 6.9
Experimentally calculating the worst-case complexity of
selection sorting
class
SelectionSortComplexity
{
static
int
nboperations ;
static boolean GreaterThan ( int a ,
int b)
{ nboperations++; return (a>b) ;}
static void swap ( int
[ ]
array ,
int
i ,
int
j )
{
nboperations++;
int tmp=array [ i ] ; array [ i ]= array [ j ] ; array [ j ]=tmp; }
public
static void main ( String [ ]
args )
{

6.5 QuickSort: Recursive sorting
139
int
[ ]
array ={16 ,15 ,14 ,13 ,12 ,11 ,10 ,9 ,8 ,7 ,6 ,5 ,4 ,3 ,2 ,1};
nboperations =0;
S e l e c t i o n S o r t ( array ) ;
System . out . p r i n t l n ( "Number of operations:"+nboperations ) ;
int nb=2∗array . length ∗( array . length −1) /2;
System . out . p r i n t l n ( "Number of operations:"+nb) ;
}
}
We get (with 15 × 16 = 240):
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
Number of operations:240
Number of operations:240
6.5 QuickSort: Recursive sorting
Let us now turn to a fast expected sorting algorithm often used in practice:
QuickSort. QuickSort is a recursive sorting procedure that proceeds as follows:
– First, partition the elements according to the pivot array[0]:
– those smaller than the pivot stored in arrayleft,
– those greater than the pivot stored in arrayright,
– those equal to the pivot (in case of ties) stored in arraypivot.
– Then solve recursively the sorting in arrays arrayleft and arrayright, and
– Recompose the array as follows:
arrayleft arraypivot arrayright
Note that in this recursive algorithm, the terminal case is sorting a single
element. This is done trivially by doing nothing since a single element array is
a sorted array by deﬁnition. The partition procedure is done in-place without
using extra memory as follows:
Program 6.10
The partition procedure in QuickSort
static
int
p a r t i t i o n ( int
[ ]
array ,
int
l e f t ,
int
r i g h t )
{
int m=l e f t ;
// pivot
for ( int
i=l e f t +1; i<=r i g h t ; i++)
{
i f
( GreaterThan ( array [ l e f t ] , array [ i ] ) )
{
swap ( array , i ,m+1) ;

140
6. Searching and Sorting
m++;// we extend left side array
}
}
// place pivot now
swap ( array , l e f t ,m) ;
return m;
}
Once this partition has been done according to the pivot element, we simply
recurse on the left/right sub-arrays as follows:
Program 6.11
Recursive sorting
static void
quicksort ( int
[ ]
array ,
int
l e f t ,
int
r i g h t )
{
i f
( right >l e f t )
{
int
pivot=p a r t i t i o n ( array , l e f t , r i g h t ) ;
quicksort ( array , l e f t , pivot −1) ;
quicksort ( array , pivot +1, r i g h t ) ;
}
}
static void QuickSort ( int
[ ]
array )
{ quicksort ( array , 0 ,
array . length −1) ;}
6.5.1 Complexity analysis of QuickSort
Let us analyze the running time of QuickSort on an arbitrary array of size n:
– The worst-case running time is quadratic: O(n2),
– The expected running time is O(nlogn),
– The best case is linear O(n). It is reached whenever all elements are identical.
In theoretical computer science, we furthermore analyze lower bounds, which
are time complexity bounds that can not be beaten by any algorithm. It is
known that sorting requires of the order of n log n time (comparison operations)
whatever the method/algorithm. This lower bound complexity is denoted as
follows: Ω(n log n).
6.6 Searching by hashing
Hashing is a fundamental technique often used in practice since it is quite a
simple technique to implement that has excellent empirical performances. The

6.6 Searching by hashing
141
two underlying ideas of hashing are:
– Convert object elements X into integer numbers x by a conversion function
x=I(X). The problem is then to transform a set of n integers sparsely lying
in N into a compact array of size m much less than n (written as m << n).
– Use an array to store the elements. Since arrays are of prescribed sizes, use a
hashing function that operates some modulo operation to map an integer
x into its hash index h(x).
The main problem hashing techniques have to deal with are collisions. Collision
occurs whenever two objects X and Y have been hashed into the same index.
That is, h(I(X)) is identical to h(I(Y)). Often, the hashing function is taken
as h(k) = k mod m, where m is a prime number.
Finding good hashing functions that minimize the risk of collisions, and
adopting a good search/store policy in cases of collisions are the two challenging
tasks of hashing that we will describe in the next chapter. The following code
shows a basic skeleton for hashing strings. It does not solve collisions but rather
explicitly reports them on the console output.
static
int m=23;
static
int
String2Integer ( String
s )
{
int
r e s u l t =0;
for ( int
j =0; j<s . length () ; j++)
r e s u l t+=(int ) s . charAt ( j ) ;
return
r e s u l t ;
}
// Note that m is a static variable
static
int
HashFunction ( int
l )
{return
l%m;}
Program 6.12
A demonstration code for hashing strings
public
static void main ( String [ ]
args )
{
String
[ ]
animals={"cat" , "dog" , "parrot" , "horse" , "fish" ,
"shark" , "pelican" , "tortoise" , "whale" , "lion" ,
"flamingo" , "cow" , "snake" , "spider" , "bee" , "peacock" ,
"elephant" , "butterfly" };
int
i ;
String
[ ]
HashTable=new String [m] ;
for ( i =0; i<m; i++)
HashTable [ i ]=new String ( "-->" ) ;
for ( i =0; i<animals . length ; i++)
{ int
pos=HashFunction ( String2Integer ( animals [ i ] ) ) ;
HashTable [ pos]+=(" "+animals [ i ] ) ;

142
6. Searching and Sorting
}
for ( i =0; i<m; i++)
System . out . p r i n t l n ( "Position "+i+"\t"+HashTable [ i ] ) ;
}
Running this code, we get the following output:
Position 0
--> whale
Position 1
--> snake
Position 2
-->
Position 3
-->
Position 4
-->
Position 5
-->
Position 6
-->
Position 7
--> cow
Position 8
--> shark
Position 9
-->
Position 10
-->
Position 11
-->
Position 12
--> fish
Position 13
--> cat
Position 14
-->
Position 15
--> dog tortoise
Position 16
--> horse
Position 17
--> flamingo
Position 18
-->
Position 19
--> pelican
Position 20
--> parrot lion
Position 21
-->
Position 22
-->
We will further describe hashing techniques once the linked lists are introduced
in the next chapter.
6.7 Exercises
Exercise 6.1 (Sequential search)
Consider a collection of books in a library with each book modeled by its
(1) title, (2) author(s) and (3) ISBN unique number. Provide a class Book
with an appropriate constructor. Further equip this class with another
constructor that takes as its argument a Book object. Consider an array
of books Book [] array. Give a search function SequentialSearch
that given a query book element searches inside the array whether
the book is present or not by checking ISBN numbers. What is the
time complexity of this method? Design a function static Book []

6.7 Exercises
143
BookByAuthor(String str) that given a string storing an author name,
collects all books written by the author.
Exercise 6.2 (Selection sort and bisection search)
We would like to speed up the former search function for librarians
that manipulates large collections of books. Implement the selection sort
algorithm on arrays of Book elements using the order of ISBN numbers
(International Standard Book Numbers). What is the time complexity
of this sorting algorithm? Consider the books stored in a sorted array
according to their ISBNs. Provide a fast recursive dichotomic search
method for checking whether a book is inside the collection or not. What
is the time complexity of this bisection search?
Exercise 6.3 (QuickSort on arrays of strings)
Modify the QuickSort program so that it can operate on arrays of strings.
We shall use the lexicographic order deﬁned on strings. Measure the time
spent by the various sorting and searching methods using the function
System.nanoTime();

7
Linked Lists
7.1 Introduction
Linked lists allow us to structure input data sets into elementary units by
chopping the data-sets into its many individual elements that are stored in
corresponding cells. Cells are all chained together into a single thread of cells,
starting from the head to the tail. These chained cells can be manipulated
dynamically by either adding or removing elements. These operations can be
carried out eﬃciently (in constant time O(1)) by creating new cells or deleting
some cells of the list. Linked lists are therefore preferred to arrays whenever we
do not know a priori the input size. This is all the more interesting for sorting
and searching operations that consider dynamic data sets in practice.
7.2 Cells and lists
7.2.1 Illustrating the concepts of cells and lists
Consider an arbitrary set of objects O = {O1, ..., On} for which we would like to
create a linked list data-structure. A cell is an elementary structure consisting
of two ﬁelds:
– The ﬁrst ﬁeld is used for storing the considered object. Thus the ﬁrst ﬁeld
plays the role of container.
F. Nielsen, A Concise and Practical Introduction to Programming Algorithms in Java,
Undergraduate Topics in Computer Science, DOI 10.1007/978-1-84882-339-6 7,
c⃝Springer-Verlag London Limited, 2009

146
7. Linked Lists
– The second ﬁeld is used for storing the reference to the next cell. This allows
it to point to the next cell.
A linked list is a set of chained cells that has two distinguished cells: the head
and the tail. The head marks the beginning of the linked list. The tail does not
point to the next cell; it thus signals that it is the last cell of the chained cells.
That is, it stores the null reference signaling that the cell is a tail.
For example, consider the following linked list of 3 natural numbers 12 →99 →
37. We depict the associated chained cells as follows:
12
99
37
A cell can be interpreted as a pair of (container,reference)
Thus the above linked list can be parenthesized as (12 (99 (37 null))).
7.2.2 List as an abstract data-structure
The concept of lists is independent of the programming language. Lists belong
to the fundamental ways of structuring data. They can be deﬁned formally in
a generic setting as follows:
Constant
:
Empty list listEmpty (null in Java)
Operations:
Constructor
:
List x Object List x Object →List
Head
:
List →Object (not deﬁned for listEmpty)
Tail
:
List →List (not deﬁned for listEmpty)
isEmpty
:
List →Boolean
length
:
List →Integer
belongTo
:
List x Object →Boolean
7.2.3 Programming linked lists in Java
In Java, we need to create and declare a new type induced by a class for creating
and initializing elementary cells. Let us denote this class by List. For the sake of
simplicity, consider a linked list of integers. The cell container should therefore
be of type int, and the next ﬁeld shall refer to the next cell. That cell is also
of type List. It is enough to deﬁne a variable of type List for pointing to the
following cell. More precisely, that variable stores a reference in Java to that
cell (a machine word coded using 32 bits, 4 bytes). Thus we declare the linked
list structure by deﬁning the following class:

7.2 Cells and lists
147
Program 7.1
Declaration of a linked list
class
List
{ int
container ;
List
next ;}
We now need to provide:
– A proper constructor to initialize various objects of type List, and
– A few functions implementing the basic operations deﬁned by the abstract
framework of § 7.2.2.
Program 7.2
Linked list class with constructor and basic functions
public
class
List
{
int
container ;
List
next ;
// Constructor
List(head , tail)
List ( int
element ,
List
t a i l )
{ this . container=element ;
this . next=t a i l ;}
static boolean isEmpty ( List
l i s t )
{ i f
( l i s t==null ) return true ;
else return
false ;}
static
int head ( List
l i s t )
{return
l i s t . container ;}
static
List
t a i l ( List
l i s t )
{return
l i s t . next ;}
}
In Java, we do not need to explicitly free memory of cells not pointed by any
other variables (meaning unreachable) as the garbage collector takes care of
that. The type of the class List is recursive since it has one ﬁeld next that
deﬁnes a reference to the same type. That is, a recursive type is a data type
with ﬁelds that may contain other values of the same type. The recursive type
is self-referential.
7.2.4 Traversing linked lists
To search whether a given query element belongs to the elements stored in
the list or not, we ﬁrst start the exploration from the head cell of the list and
compare the integer ﬁeld of the cell with the query. If these integers match then
we successfully have found the element and return true. Otherwise, we chain

148
7. Linked Lists
to the next cell using the reference stored in ﬁeld next. We proceed cell-wise
until we eventually ﬁnd the element, or we reach the tail cell of the list that
has its next ﬁeld set to null.
Program 7.3
Checking whether an element belongs to the list by traversing
it
static boolean belongTo ( int
element ,
List
l i s t )
{
while ( l i s t != null )
{
i f
( element==l i s t . container )
return true ;
l i s t=l i s t . next ;
}
return
false ;
}
The time complexity of searching in a linked list of n cells is therefore linear
(O(n) using the big Oh-notation) since we need to fully explore the list to
report that it is not inside. Note that since Java is pass-by-value only (with a
pass-by-reference for non-primitive objects), at the end of calling static function
belongTo the reference of list remains unchanged.
7.2.5 Linked lists storing String elements
List can store arbitrary types of objects. For example, the list declaration of
storing String inside an individual cell is given below:
Program 7.4
Linked list storing String elements
class
L i s t S t r i n g
{
String name ;
L i s t S t r i n g
next ;
// reference
// Constructor
L i s t S t r i n g ( String tname ,
L i s t S t r i n g
t a i l )
{ this . name=tname ;
this . next=t a i l ;}
static boolean isEmpty ( L i s t S t r i n g
l i s t )
{return ( l i s t==null ) ;}
static
String
head ( L i s t S t r i n g
l i s t )
{return
l i s t . name ;
}
static
L i s t S t r i n g
t a i l ( L i s t S t r i n g
l i s t )
{return
l i s t . next ;}
}

7.2 Cells and lists
149
To detect whether or not a given string has already been inserted inside a linked
list, we traverse again the list but now performs the equality test of strings as
follows:
static boolean belongTo ( String
s ,
L i s t S t r i n g
l i s t )
{
while ( l i s t != null )
{// Use equals method of String that take a String as its
argument
i f
( s . equals ( l i s t . name) )
return true ;
l i s t=l i s t . next ;
}
return
false ;
}
7.2.6 Length of a linked list
The length of a linked list is deﬁned as its number of elements. To determine
the length of a given linked list, we browse the list starting from its head
until we reach the tail, incrementing by one every time we traverse a cell. The
static (class) function length takes as argument a reference to a list of strings:
a variable of type ListString.
Program 7.5
Static (class) function computing the length of a list
static
int
length ( L i s t S t r i n g
l i s t )
{
int
l =0;
while ( l i s t != null )
{ l ++;
l i s t=l i s t . next ;
}
return
l ;
}
Once again, observe that since Java is passing function arguments only
by value (using references for objects such as lists), at the end of the
function the original value (reference) of list is preserved although we perform
list =list .next; instructions inside the body of the function. Thus we can call
twice the static length function of class ListString; it will return the same length
(as expected).
System . out . p r i n t l n ( L i s t S t r i n g . length (u) ) ; // reference to list
u is kept preserved
System . out . p r i n t l n ( L i s t S t r i n g . length (u) ) ;

150
7. Linked Lists
7.2.7 Dynamic insertion: Adding an element to the list
To add an element to an unordered list, we create a new cell storing that
element and add that cell at the head. The static function Insert returns the
reference to the newly created head cell. In other words, we create a new cell
with its container assigned to the value of the element, and with its tail set
to the head of the former list. Note that the element can already have been
inserted.
Program 7.6
Inserting a new element to the list
static
L i s t S t r i n g
I n s e r t ( String
s ,
L i s t S t r i n g
l i s t )
{return new L i s t S t r i n g ( s , l i s t ) ;
}
Based on this function, we create a linked list by starting from the null cell
and inserting successive elements to the list head.
myList=null ;
myList=L i s t S t r i n g . I n s e r t ( "First" ,
myList ) ; //here , we
explicitly means the Insert function of class ListString
myList=new L i s t S t r i n g ( "Second" , myList ) ; //Since this code is
located inside the ListString body , we can remove the
class name
. . .
”First”
”Second”
null
”First”
null
myList
myList
myList=null;
myList=ListString.Insert(”First element”, myList);
myList=new ListString(”Second element”,myList);
Figure 7.1
Creating a linked list by iteratively calling the static function
Insert. The arrows anchored at variable myList mean references to objects of
type ListString

7.2 Cells and lists
151
7.2.8 Pretty printer for linked lists
Data-structures based on lists and algorithms processing lists are often more
diﬃcult to debug compared to similar algorithms based on arrays. Therefore,
it is useful to print at the output console the chained cell structure of a given
linked list. Procedure Display does this by traversing the list from its head.
Program 7.7
Pretty printer for lists
static void Display ( L i s t S t r i n g
l i s t )
{
while ( l i s t != null )
{
System . out . print ( l i s t . name+"-->" ) ;
l i s t=l i s t . next ;
}
System . out . p r i n t l n ( "null" ) ;
}
We print a list referenced by its head element myList by invoking the instruction
ListString .Display(myList); Instead of printing to the console at every cell
visited, we could also have created a String variable storing the displayed list
and return the string as output:
Program 7.8 Static function writing the structure of a linked list into a String
object
static
String
Display ( L i s t S t r i n g
l i s t )
{ String
r e s u l t="’"’
while(list!=null)
{
result+=list.name+"-->";
list=list.next;
}
result+="null";
return result;
}
We print the list by calling the static function System.out.println(ListString .
Display(myList));
7.2.9 Removing an element from a linked list
To remove an element from a linked list, we ﬁrst need to search for its position
in the linked list. If the element is found, we need to do a bit of list surgery to
branch the former cell reference next to the next cell element. If the source list
is empty (reference is null) or if the element is found at the head, we can easily

152
7. Linked Lists
handle these cases. Thus we remove an element from the list by deconnecting
its cell from the other chained cells as depicted by Figure 7.2.
name (v)
w=v.next
v
v.next=w.next
v
name (w)
name (w.next)
Container element matching the query s:
(w.name).equals(s) is true
name (v)
name (w.next)
Reference of the next ﬁeld of v
becomes the reference of the next ﬁeld of w
Figure 7.2 Removing an element to the list by deconnecting its cell from the
other chained cells
Program 7.9
Removing an element from a list
static
L i s t S t r i n g
Delete ( String
s ,
L i s t S t r i n g
l i s t )
{
// Case: list is empty
i f
( l i s t==null )
return null ;
// Case: element is at the head
i f
( l i s t . name . equals ( s ) )
return
l i s t . next ;
// Otherwise
L i s t S t r i n g
v=l i s t ;
L i s t S t r i n g w=l i s t . next ;
//tail
while ( w!= null && ! ( (w. name) . equals ( s ) )
)
{v=w; w=v . next ;}
// A bit of list surgery here
i f
(w!= null )
v . next=w. next ;
return
l i s t ;
}

7.3 Recursion on linked lists
153
7.2.10 Common mistakes when programming lists
Programming linked lists involves handling objects that deﬁne structure cells.
Since the tail is deﬁned as the cell having its next ﬁeld set to null, this can
cause a problem for some code like:
r e s u l t+=l i s t . name+"-->" ;
l i s t=l i s t . next ;
We need to be sure that variable list is never the object since we cannot
access ﬁelds of the null object. Trying to do so will raise an exception (called
here nullPointerException). Thus in general, take particular care when
performing tests like if (currentCell!=null) ... to detect whether the current
object currentCell is the null object or not, before accessing its ﬁelds. For
example, we better rewrite the static head function as follows:
static
int head ( List
l i s t )
{ i f
( l i s t != null )
return
l i s t . container ;
else
return −1; }
7.3 Recursion on linked lists
By its very nature deﬁned in the abstract framework, the “self-deﬁnition” of
lists yields practical recursive algorithms for designing various tasks. Codes for
these algorithms are usually very compact. For example, let us revisit the static
length function previously described above. We design a recursive function by
considering as a terminal case the null list that is of length 0. Otherwise we
return one plus the length of the linked list anchored at the tail for the current
cell. This gives the following compact code:
Program 7.10
Recursive function for computing the length of a list
static
int
lengthRec ( L i s t S t r i n g
l i s t )
{ // terminal case?
i f
( l i s t==null )
return
0;
else
return 1+lengthRec ( l i s t . next ) ;
}
Let us attach this static function on class ListString by inserting the code inside
the body of the class. Then we display at the output console the length of list

154
7. Linked Lists
myList by executing the following instruction:
System.out.println(ListString .lengthRec(myList));
Similarly, we can rewrite with a recursive the previous functions, such as the
belongToRec function that returns a boolean stating whether a given element
is inside a list or not:
Program 7.11
Recursive membership function
static boolean belongToRec ( String
s ,
L i s t S t r i n g
l i s t )
{
i f
( l i s t==null ) return
false ;
else
{
i f
( s . equals ( l i s t . name) )
return true ;
else
return belongToRec ( s , l i s t . next ) ;
}
}
The recursive display procedure is written as:
Program 7.12
Recursive display of a list
static void DisplayRec ( L i s t S t r i n g
l i s t )
{
i f
( l i s t==null )
System . out . p r i n t l n ( "null" ) ;
else
{
System . out . print ( l i s t . name+"-->" ) ;
DisplayRec ( l i s t . next ) ;
}
}
Note that if we choose to call function DisplayRec before printing on the console
the current cell by interchanging the two lines in the else-case as follows:
Program 7.13
Reversed recursive display of a list
static void DisplayRecRev ( L i s t S t r i n g
l i s t )
{
i f
( l i s t==null )
System . out . print ( "null" ) ;
else
{
DisplayRecRev ( l i s t . next ) ;
System . out . print ( "<--"+l i s t . name) ;
}
}
Then because of the mechanism of the function call stack, the list will be
displayed from the tail to its head. Indeed, the ﬁrst word written to the output

7.4 Copying linked lists
155
console is null since it is the terminal case. Then we pop the function call
stack and write the last cell name string, and so on.
L i s t S t r i n g
l=new L i s t S t r i n g ( "Paris" , null ) ;
l=new L i s t S t r i n g ( "Tokyo" , l ) ;
l=new L i s t S t r i n g ( "Berlin" , l ) ;
l=new L i s t S t r i n g ( "Porto" , l ) ;
l=new L i s t S t r i n g ( "Cambridge" , l ) ;
l=new L i s t S t r i n g ( "Roma" , l ) ;
L i s t S t r i n g . Display ( l ) ;
L i s t S t r i n g . DisplayRec ( l ) ;
L i s t S t r i n g . DisplayRecRev ( l ) ;
System . out . p r i n t l n ( "" ) ;
Roma-->Cambridge-->Porto-->Berlin-->Tokyo-->Paris-->null
Roma-->Cambridge-->Porto-->Berlin-->Tokyo-->Paris-->null
null<--Paris<--Tokyo<--Berlin<--Porto<--Cambridge<--Roma
7.4 Copying linked lists
Copying or cloning objects is an essential operation frequently used in
programs. To copy a list, we need to traverse the source list and create a
new cell every time we visit a list. The snippet code below copy a source list l:
Program 7.14
Copying iteratively a source list but reversing its order
static
L i s t S t r i n g
copy ( L i s t S t r i n g
l )
{
L i s t S t r i n g
r e s u l t=null ;
while ( l != null )
{
r e s u l t=new L i s t S t r i n g ( l . name , r e s u l t ) ;
l=l . next ;
}
return
r e s u l t ;
}
Note that the side-eﬀect of the iterative function copy is to reverse the order
of the linked list. Although it might not be important in some cases, we would
rather get a perfect list clone by using the following recursive procedure:
Program 7.15
Copying a source list by maintaining the original head-tail
order
static
L i s t S t r i n g
copyRec ( L i s t S t r i n g
l )

156
7. Linked Lists
{
i f
( l==null )
return null ;
else
return new L i s t S t r i n g ( l . name , copyRec ( l . next ) ) ;
}
7.5 Creating linked lists from arrays
So far we have handled large (static) data-sets into arrays that are contiguously
stored in the global memory. It is useful to start to build linked lists from arrays
that will support editing operations. Therefore, we create the helper function,
which creates a linked list from a String array as follows:
static
L i s t S t r i n g
Build ( String
[ ]
array )
{
L i s t S t r i n g
r e s u l t=null ;
// To ensure that list head is the first array element
decrement
// Iterate from largest to smallest index
for ( int
i=array . length −1; i >=0;i −−)
r e s u l t=new L i s t S t r i n g ( array [ i ] , r e s u l t ) ;
return
r e s u l t ;
}
Consider, for example, the following code snippet that shows how to use the
function Build:
String
[ ]
c o l o r s={"green" , "red" , "blue" , "purple" , "orange" ,
"yellow" };
L i s t S t r i n g
lColors=L i s t S t r i n g . Build ( c o l o r s ) ;
L i s t S t r i n g . Display ( lColors ) ;
The result displayed on the output console by executing the above instructions
is:
green-->red-->blue-->purple-->orange-->yellow-->null
7.6 Sorting linked lists
Given an arbitrarily ordered linked list, we wish to sort the list elements, say
in increasing order. We must ﬁrst consider a simpler problem that consists of

7.6 Sorting linked lists
157
merging two ordered lists without creating new cells. We will then make use of
this merging function to provide an eﬃcient sorting procedure.
7.6.1 Merging ordered lists
Let us consider two ordered linked lists u and v of arbitrary lengths with
corresponding cells storing integers in increasing order. That is, the sequence
of integers stored in cells from the head to the tail is increasing in both lists.
We would like to create a new linked list merging the elementary cells of u and
v in increasing order without creating any new cell. To make it plain, we need
to recycle the elementary cells already available in u and v when building the
merged list. To provide an illustrating example, the list merging operation will
give the following result:
u
3−−>6−−>8−−>null
v
2−−>4−−>5−−>7−−>9−−>null
Merge(u,v)
2−−>3−−>4−−>5−−>6−−>7−−>8−−>9−−>null
We consider the following class List that deﬁnes the basic blocks of integer
linked lists.
class
List
{
int
container ;
List
next ;
// Constructor
List(head , tail)
List ( int
element ,
List
t a i l )
{ this . container=element ;
this . next=t a i l ;}
// Insert element at the head of the list
List
i n s e r t ( int
e l )
{return new List ( el , this ) ;}
void Display ()
{ List u=this ;
while (u!=null )
{
System . out . print (u . container+"-->" ) ;
u=u . next ;
}
System . out . p r i n t l n ( "null" ) ;
}
}
So that the above two example integer linked lists are created in the main
procedure as follows:

158
7. Linked Lists
public
static void main ( String
[ ]
args )
{
List u=new List (8 , null ) ; u=u . i n s e r t (6) ; u=u . i n s e r t (3) ;
u . Display () ;
List
v=new List (9 , null ) ; v=v . i n s e r t (7) ; v=v . i n s e r t (5) ; v=v .
i n s e r t (4) ; v=v . i n s e r t (2) ;
v . Display () ;
}
The easy case for merging lists is whenever one of the lists is empty (meaning
that either u or v is equal to null). Indeed, in that case, we simply return the
other list (which might also be empty, in which case, both lists are empty).
Otherwise, both lists are considered non-empty, and we compare their head
elements u.container and v.container. Assume without loss of generality that
the integer of u.container is less than v.container. Then we need to set the
reference to the next ﬁeld of u to the result of merging the two ordered lists
with heads referenced by u.next and v. That is where recursion beautifully kicks
in. Of course, in case u.container>=v.container we do the converse. Hence, the
recursive function for merging two ordered lists is quite simple as shown below:
Program 7.16
Merging two ordered linked lists
static
List
mergeRec ( List u ,
List
v)
{
i f
(u==null ) return v ; // terminal case
i f
(v==null ) return u ; // terminal case
// Recursion
i f
(u . container <v . container )
{
u . next=mergeRec (u . next , v) ;
return u ;
}
else
{
v . next=mergeRec (u , v . next ) ;
return v ;
}
}
7.6.2 Recursive sorting of lists
Now consider sorting any arbitrary linked list using the above recursive merging
procedure. The sorting algorithm will not create any new cells but rather set
the next ﬁeld of every cell to the appropriate reference for linking appropriately
to the next cell.
We consider the following recursive sorting scheme: Split the initial list u in

7.6 Sorting linked lists
159
half and create from it two linked lists, say u1 and u2. Recursively sort both
sub-lists u1 and u2 of roughly half size, and merge them using the previous
recursive merging function. To split in half the source list u, we ﬁrst compute
the length of u and set u2 to the cell split met half way. We also need to create
the tail of u1 by explicitly setting the next ﬁeld of the previous cell (that we
call prevSplit) to null. Overall the sorting code for linked list is given below:
Program 7.17
Recursively sorting an arbitrary linked list
static
List
sortRec ( List u)
{
int
l=Length (u) ;
i f
( l <=1)
return u ;
else
{ int
i ,
l r ;
List
u1 ,
u2 ,
s p l i t ,
prevSplit ;
// references to cells
u1=u ;
prevSplit=s p l i t=u ;
i =0; l r=l /2;
while ( i<l r )
{ i ++;
prevSplit=s p l i t ;
s p l i t=s p l i t . next ;}
u2=s p l i t ;
// terminates with a null
prevSplit . next=null ;
// ensure u1 terminates with a null
return mergeRec (
sortRec ( u1 ) ,
sortRec ( u2 )
) ;
}
}
Let u be the following linked list:
20−−>19−−>21−−>23−−>17−−>15−−>1−−>6−−>9−−>2−−>3−−>null
Then executing the following code...
u . Display () ;
List
sortu=sortRec (u) ;
System . out . p r i n t l n ( "Sorted linked list:" ) ;
sortu . Display () ;
...will return the sorted linked list:
1-->2-->3-->6-->9-->15-->17-->19-->20-->21-->23-->null
Once again, we have only recycled the previously created cells by changing their
next ﬁeld. Procedures sortRec and mergeRec do not create new cell objects.

160
7. Linked Lists
Indeed, you can check that there are no new keywords in the body of these
functions.
7.7 Summary on linked lists
Linked lists allow one to consider fully dynamic data structures. It is, however,
quite useful to start building a list from a former array. A list object is nothing
more than a reference to the cell of the linked list, namely a reference to
the head of the list. We have presented singly chained linked list for
unidirectionally traversing elements from the head to the tail. It is also possible
to create doubly chained linked lists that contain in their class deﬁnition two
reference ﬁelds beyond the container: Say, prev and next references.
class
DoublyLinkedList
{ int
container ;
DoublyLinkedList
prev ,
next ;
}
Finally, notice that in Java, we do not need to free unused cells (for example
cells discarded when removing elements) since the garbage collector (GC) will
do it automatically on our behalf. Let us now consider an application using
linked lists: hashing.
7.8 Application of linked lists: Hashing
Hashing is a technique for storing a collection of homogeneous objects taken
from a gigantic space into a compact array. To make it more concrete, assume
we have to deal with a collection of strings of type String. The potential full
collection of strings is gigantic and is called the universe from which objects
are taken. If we consider a given set of n object, we would like to store them
eﬃciently in a data-structure so that we can insert new objects and search for
objects in almost constant time. The underpinning principle of hashing is to
ﬁrst transcode the string into an integer using a conversion procedure named
String2Integer.
static
int
String2Integer ( String
s )
{
int
r e s u l t =0;
// this is the method s.hashCode()
for ( int
j =0; j<s . length () ; j++)
r e s u l t=r e s u l t ∗31+s . charAt ( j ) ;

7.8 Application of linked lists: Hashing
161
return
r e s u l t ;}
Note that the above procedure is already implemented in Java in the String
class by the hashCode method. With that conversion procedure, two strings are
very likely to be converted into diﬀerent integers. Now we create a hash table
HashTable that is an array of given size m. Then we hash string s using its
corresponding integer k into an index h(k) of HashTable, ranging from 0 to m−
1 using a hash function h. This is done simply by taking the modulo operation
(symbol % in Java) of the integer resulting from the conversion procedure. In
order to avoid hashing strings into the same array cell, we choose m to be prime
(here, m = 23):
h(k) = k
mod m, where m is a prime number.
The code for hashing a set of strings is given below:
Program 7.18
Hashing a set of strings into a hash table
static
int m=23;
// Note that m is a static variable
static
int
HashFunction ( int
l )
{return
l%m;}
public
static void main ( String [ ]
args )
{
String
[ ]
animals={"cat" , "dog" , "parrot" , "horse" , "fish" ,
"shark" , "pelican" , "tortoise" , "whale" , "lion" ,
"flamingo" , "cow" , "snake" , "spider" , "bee" , "peacock" ,
"elephant" , "butterfly" };
int
i ;
String
[ ]
HashTable=new String [m] ;
for ( i =0; i<m; i++)
HashTable [ i ]=new String ( "-->" ) ;
for ( i =0; i<animals . length ; i++)
{ int
pos=HashFunction ( String2Integer ( animals [ i ] ) ) ;
HashTable [ pos]+=(" "+animals [ i ] ) ;
}
for ( i =0; i<m; i++)
System . out . p r i n t l n ( "Position "+i+"\t"+HashTable [ i ] ) ;
}
Compiling and executing the program, we get the following result:
Position 0
--> whale
Position 1
--> snake
Position 2
-->
Position 3
-->

162
7. Linked Lists
Position 4
-->
Position 5
-->
Position 6
-->
Position 7
--> cow
Position 8
--> shark
Position 9
-->
Position 10
-->
Position 11
-->
Position 12
--> fish
Position 13
--> cat
Position 14
-->
Position 15
--> dog tortoise
Position 16
--> horse
Position 17
--> flamingo
Position 18
-->
Position 19
--> pelican
Position 20
--> parrot lion
Position 21
-->
Position 22
-->
Observe that for some indices of the array, there have been two strings assigned
to that array cell. For example the dog and tortoise have been both assigned
to index 15, while parrot and lion have been assigned to index 20. This is
what is called ¸ollision phenomenon. For strings, we just solved this problem by
concatenating strings stored at the same position (for illustration purpose). In
the ideal case, if no collision happens, we can insert a new string in constant
time, and search for a given string in constant-time too. This hashing technique
is therefore eﬃcient compared to arrays/lists data-structures. This explains
why hashing is often used in real-world applications (and standardized in Java
API packages). Let us now see how to resolve the collision problems by using
two diﬀerent strategies: (1) the open address method, and (2) the chained list
method.
7.8.1 Open address hashing
Let us resolve hashing collisions using the open address scheme. The method
consists of ﬁrst computing the array index of the hashed string. Then two cases
occur:
– Either the hash table cell at that index is free, and then we store the string
there, or
– There is already a string stored at that index. Then we proceed starting from
that index to search for the ﬁrst free position of the hash table by iteratively
incrementing the index. We eventually ﬁnd that position and store the string
there.

7.8 Application of linked lists: Hashing
163
String
[ ]
HashTable=new String [m] ;
// By default HashTable[i]=null
for ( i =0; i<animals . length ; i++)
{
int
s2int=String2Integer ( animals [ i ] ) ;
int
pos=HashFunction ( s 2 i n t ) ;
while ( HashTable [ pos ]!= null )
pos=(pos+1)%m;
HashTable [ pos]=new String ( animals [ i ] ) ;
}
Position 0
whale
Position 1
snake
Position 2
bee
Position 3
spider
Position 4
butterfly
Position 5
null
Position 6
null
Position 7
cow
Position 8
shark
Position 9
null
Position 10
null
Position 11
null
Position 12
fish
Position 13
cat
Position 14
peacock
Position 15
dog
Position 16
horse
Position 17
tortoise
Position 18
flamingo
Position 19
pelican
Position 20
parrot
Position 21
lion
Position 22
elephant
To search whether a given string belongs to the hash table or not, we proceed
by ﬁrst converting it to an integer, hashing it to the hash array index, and
checking the value at that location. If there is nothing, we report that the
object is not present (all this in constant time). Otherwise, we iteratively visit
the cells by incrementing the index until we ﬁnd the string or we ﬁnd an empty
array cell.
The main drawback of open addressing is that we cannot insert for sure more
strings than the array size. In case we cannot upper bound the maximal number
of elements. It is better to consider an alternative technique for managing the
hash table. This is where linked lists kicked in.

164
7. Linked Lists
7.8.2 Solving collisions with linked lists
Instead of considering an array of strings as we previously did, we now consider
an array of linked lists. Each cell of the array will store a reference to the head
of the linked list it refers to. When there is hash collision, we just add the
element to the linked list of its hashed index. The code for initializing the hash
table and ﬁlling it with the data-set is given below:
L i s t S t r i n g
[ ]
HashTable=new L i s t S t r i n g [m] ;
for ( i =0; i<m; i++)
HashTable [ i ]= null ;
for ( i =0; i<animals . length ; i++)
{
int
s2int=String2Integer ( animals [ i ] ) ;
int
pos=HashFunction ( s 2 i n t ) ;
HashTable [ pos]= L i s t S t r i n g . I n s e r t ( animals [ i ] , HashTable [ pos ] ) ;
}
for ( i =0; i<m; i++)
L i s t S t r i n g . Display ( HashTable [ i ] ) ;
Executing the above code yields:
whale-->null
bee-->snake-->null
null
spider-->null
butterfly-->null
null
null
cow-->null
shark-->null
null
null
null
fish-->null
peacock-->cat-->null
null
tortoise-->dog-->null
horse-->null
flamingo-->null
null
pelican-->null
lion-->parrot-->null
elephant-->null
null

7.9 Comparisons of core data-structures
165
7.9 Comparisons of core data-structures
We have described several data-structures for organizing a collection of
objects that provide basic operations such as inserting/deleting and searching
whether a given query element belongs to the collection. We have seen that
arrays are well-suited to static data-sets but fail short in case we need to
delete/add elements. Linked lists have then be introduced for fully maintaining
the collection of elements. However, searching using linked lists could be
tricky. We ﬁnally combined both array and linked list technique in the
hashing framework showing clearly its advantages when no collisions occur.
The table 7.1 quickly summarizes the various time complexity operations of
respective data-structures.
Data-structure
Initialization
Search
Insert
Delete
Array
O(1)
O(n)
O(1)
O(n)
Sorted array
O(n log n)
O (log n)
O(n)
O(n)
Hashing
O(1)
Almost O(1)
Almost O(1)
Almost O(1)
(Chained list)
List
O(1)
O(n)
O(1)
O(n)
Table 7.1
Performance of various data-structures
7.10 Exercises
Exercise 7.1 (Linked lists for intervals)
Write a class Interval that stores the range min/max of intervals. Create
a linked list of intervals. Provide the usual functions: add, remove,
length and display.
Exercise 7.2 (Doubly linked lists)
A polygon is a piecewise linear non-self-intersecting closed curve. We
consider modeling a polygon by its set of vertices (2D points stored in
an array) with a linked list of vertex indices (integers). Write a class
Polygon with a constructor that takes as its argument an array of 2D
points describing the cyclic sequence of vertices. The linked list shall be
bidirectional using the prev and succ ﬁelds.

166
7. Linked Lists
Exercise 7.3 (Dynamic insertion for sorting)
Consider sorting an array Dictionary of strings by successively inserting
the array item Dictionary[i] into a linked list of Strings. Provide a
static function static StringList Sort(String [] array) that sorts the string
array into a linked list, and return its head element. What is the time
complexity of this sorting method?
Exercise 7.4 (Sparse polynomial representation)
Consider the following recursive type for representing sparse polynomials
(polynomials with many coeﬃcients set to zero):
Program 7.19
A class for manipulating sparse polynomials
class
SparsePolynomial
{
int
degree ;
double
c o e f f i c i e n t ;
SparsePolynomial
next ;
SparsePolynomial ( int d ,
double v ,
SparsePolynomial
poly )
{
this . degree=d ;
this . c o e f f i c i e n t=v ;
this . next=poly ;
}
}
Write the following static functions:
– static void Display(SparsePolynomial poly) that displays a poly-
nomial to the console,
– static SparsePolynomial Add(SparsePolynomial p,
SparsePolynomial q) that performs the addition of two polynomials
p and q,
– static SparsePolynomial Multiply(SparsePolynomial p,
SparsePolynomial q) that calculates the product of two polynomials
p and q.
Exercise 7.5 (String pattern matching)
Given two strings of characters stored in array of char, design a predicate
static boolean occurence(char [] T, char [] M, int i) that re-
ports whether string M is located at index i of string T. The arrays of char-
acters can be extracted from corresponding strings of type String using
the method toCharArray() (for example, String stringt="A simple

7.10 Exercises
167
test string";char [] T=stringt.toCharArray();). Deduce a naive
algorithm for reporting the potential occurences of M in T. Let m and t be
the respective length of arrays M and T. What is the time complexity of
this search procedure? Karp and Robin proposed an eﬀective linear time
algorithm that consists of using a signature function S. The principle is
as follows: Compute once for all the signature of the motif pattern M, and
get S(M). Then for all i, check whether the signature of T[i..i + m −1]
matches the signature of M. If signatures do not match then there
is no occurrence at that position. Otherwise, when signatures match,
we still need to check whether it is a true occurence or not. Give
an implementation of the Karp-Rabin algorithm using as a signature
function the sum of the character ASCII codes of an array:
Program 7.20
An example of signature function for the Karp-Rabin
pattern matching algorithm
static
long
signature ( char
[ ] X,
int m,
int
i )
{
long
r e s u l t =0;
for ( int
j=i ; j<i+m; j++)
r e s u l t+=X[ j ] ;
return
r e s u l t ;
}

8
Object-Oriented Data-Structures
8.1 Introduction
In this chapter, we describe the two most fundamental data-structures usually
encountered in applications: stacks and queues. We begin by explaining
the queue data-structures and their generalization to priority queues. We
then describe stacks. Furthermore, we introduce the notion of abstract data-
structures deﬁned by their prototype interfaces, and show how to program
these abstract data-structures using the object-oriented functionalities of Java.
We revisit some of the static functions handling data-structures covered in the
previous chapters into the OO paradigm by designing class methods that act
on objects themselves.
8.2 Queues: First in ﬁrst out (FIFO)
8.2.1 Queues as abstract data-structures: Interfaces
A queue is a generic abstract data type for storing incoming objects while
preserving their order of arrival. That is, incoming objects are time-stamped
and processed according to their arrival date. The basic operations that queues
F. Nielsen, A Concise and Practical Introduction to Programming Algorithms in Java,
Undergraduate Topics in Computer Science, DOI 10.1007/978-1-84882-339-6 8,
c⃝Springer-Verlag London Limited, 2009

170
8. Object-Oriented Data-Structures
support are detailed by the following interface:1
– add or queue: Add an element at the tail of the queue,
– process or remove: Process the ﬁrst element of the queue.
These queues are also equipped with a predicate empty that tells us whether
the queue is currently empty or not. Queues are one example of abstract
data-structures that can be implemented using various data-structures at their
backbone. We start from the most common implementation that uses arrays
of prescribed size: That is, arrays with sizes ﬁxed once for all. We manipulate
two indices in this array, say:
– freePlace: Denote the index of the ﬁrst free remaining place in the array.
– lastProcessed: Denote the index of the last processed object initially set to
−1).
Figure 8.1 illustrates these notations. The array acts as a buﬀer for storing the
incoming objects.
O1 O2 O3
lastProcessed freePlace
Figure 8.1 A queue implemented
using an array requires two indices
to indicate the last processed ele-
ment and the ﬁrst free location
8.2.2 Basic queue implementation: Static functions
We implement the add/process functions deﬁned in the interface of queues
using an array encapsulated into a tailored class. For example, let us consider
queues for incoming sequences of double numbers. Whenever we call a process
operation while the queue is empty, we choose by convention to return a special
code: Here, chosen as −1.0. The straightforward code for implementing these
add/process and empty operations is given below:
Program 8.1
A double queue with interface primitives implemented using
static functions
class QueueDouble
{
static
int
lastProcessed =−1;
static
int
f r e e P l a c e =0;
1 Java
provides
the
queue
interface
in
its
own
API
as
explained
in
http://java.sun.com/docs/books/tutorial/collections/interfaces/queue.html

8.2 Queues: First in ﬁrst out (FIFO)
171
// Max objects is set to 1000
static double [ ]
container=new double [ 1 0 0 0 ] ;
// Stack in FIFO order
static void add (double a )
{
i f
( freePlace <1000)
{ container [ f r e e P l a c e ]=a ;
f r e e P l a c e++;
}
}
// Process in FIFO order
static double process ()
{
i f
( freePlace −lastProcessed >1)
{
lastProcessed++;
return
container [ lastProcessed ] ;
}
else
return
−1.0; // code for impossible to process
}
public
static void main ( String [ ]
arg )
{
System . out . p r i n t l n ( "Queue demo:" ) ;
add ( 3 . 0 ) ;
add ( 5 . 0 ) ;
add ( 7 . 0 ) ;
System . out . p r i n t l n ( process () ) ;
System . out . p r i n t l n ( process () ) ;
System . out . p r i n t l n ( process () ) ;
System . out . p r i n t l n ( process () ) ;
System . out . p r i n t l n ( process () ) ;
}
}
Running the above code yields:
Queue demo:
3.0
5.0
7.0
-1.0
-1.0
As it can be seen from the output, queues ensure that ﬁrst-in elements are
indeed ﬁrst-out: That is, queues respect the order of arrival. Note that in this
implementation all functions are static functions attached to the program class.
Namely, they are class functions that access the buﬀer array deﬁned as a static
class array static double[] container.

172
8. Object-Oriented Data-Structures
8.2.3 An application of queues: Set enumeration
As a basic straightforward application of queues, consider the following
mathematical puzzle:
Let A ⊂N be a set of integers such that:
– 1 belongs to A, and
– If element a belongs to A, then 2a + 1 and 3a also belong to A.
For a given n, we are asked to display all integers less or equal to n that belong
to A. To solve this problem algorithmically, consider starting with a queue
initialized with element 1. We also use a boolean array to indicate whether
integer a belongs to A or not. That is, we mark elements of A by tagging them
using a boolean array. Initially, all elements except 1 are marked to false. Once
this initialization is completed, for each element a of the queue, we perform in
turn the following process:
– Compute 2a + 1, add this element to the queue if a is less than n and not
yet marked,
– Compute 3a, add this element to the queue if a is less than n and not yet
marked.
The algorithm terminates when the queue becomes empty, and we terminate
by displaying all marked elements: the set A restricted to integers less or equal
to n.
The listing below describes this simple application of queues:
Program 8.2
Enumerating set elements using queues
class QueueIntGame
{
final
static
int n=1000;
static
int
lastProcessed =−1;
static
int
f r e e P l a c e =0;
static
int [ ]
container=new int [ n ] ;
static boolean [ ]
mark=new boolean [ n ] ;
static void add ( int a )
{
i f
( freePlace <n)
{ container [ f r e e P l a c e ]=a ;
f r e e P l a c e++;
}
}
static boolean Empty()
{return
(( freePlace −lastProcessed )==1) ;
}
static void
process ()

8.3 Priority queues and heaps
173
{
int a ;
lastProcessed++;
a=container [ lastProcessed ] ;
i f
(a<n) mark [ a]=true ;
i f
(2∗a+1<n) add (2∗a+1) ;
i f
(3∗a<n) add (3∗a ) ;
}
public
static void main ( String [ ]
arg )
{ int
i ;
for ( i =0; i<n ; i++)
mark [ i ]= false ;
add (1) ;
while ( ! Empty() )
process () ;
for ( i =0; i<n ; i++)
{ i f
(mark [ i ] )
System . out . print ( i+" " ) ;}
System . out . p r i n t l n ( "" ) ;
}
}
Let us now run the program to list all integer elements less than 1000 and
belonging to A. We ﬁnd:
1 3 7 9 15 19 21 27 31 39 43 45 55 57 63 79 81 87 91 93 111 115
117 127 129 135 159 163 165 171 175 183 187 189 223 231 235 237
243 255 259 261 271 273 279 319 327 331 333 343 345 351 367 375
379 381 387 405 447 463 471 475 477 487 489 495 511 513 519 523
525 543 547 549 559 561 567 639 655 663 667 669 687 691 693 703
705 711 729 735 751 759 763 765 775 777 783 811 813 819 837 895
927 943 951 955 957 975 979 981 991 993 999
8.3 Priority queues and heaps
As we have already attested by ourselves in airports, queues that ensure
the ﬁrst in ﬁrst out property are true only for passengers belonging to the
same traveling class. Air ﬂight companies implement several grades for their
customers: Usually, it breaks down as economy, business and ﬁrst classes. A
ﬁrst class client arriving at any time will be served ﬁrst even if economy clients
stand in the line long before. But another ﬁrst class client will have to wait
until the ﬁrst ﬁrst class client goes on board to embark. This property of

174
8. Object-Oriented Data-Structures
lining up according to grades is informally what is called priority queues, a
generalization of queues2. These priority queues are yet another fundamental
abstract data type lying at the heart of operating systems for performing “nice”
job scheduling tasks. In a priority queue, it is always the object with highest
priority that goes out of the queue ﬁrst. In case several objects have the same
priorities, the time arrival is taken into account and we operate along the
guidelines of the queue then: “First in ﬁrst out” for all objects with the same
priority. For the case of a small ﬁxed number of priorities, we may implement
priority queues by declaring an array of queues. But this naive approach is
rather ineﬃcient and does not scale up with arbitrary large number of priority
numbers. There are several ways to implement generic priority queues but these
implementations basically all rely on the fundamental notion of heaps.
A heap is a special tree data-structure storing keys at its nodes. Heaps satisfy
the so-called heap property. The heap property is described as follows: For any
pair (P, Q) where Q is a child node of parent P, a heap must satisfy:
key(P) ≥key(Q).
Figure 8.2 depicts a heap. Observe that the maximal element of a heap is always
located at the root. This explains why heaps are related to priority queues since
it is straightforward to get the maximal priority by looking at the root. Heaps
are also complete binary trees, meaning that nodes are added from left to right
until the current level becomes complete (that is, saturated). We then create a
next level and start adding nodes from the left to right side. Figure 8.2 depicts
a heap. Observe that at a given layer the nodes are not ordered.
37
22
31
16
17
2
23
12
6
9
Figure 8.2 A heap is a binary tree specialized so that the keys of all children
are less than the keys of their parents
Heaps can themselves be compactly embedded into arrays since the binary tree
is perfect. For example, the heap of Figure 8.2 can be stored in an array by
2 In simple queues, elements have the same priority.

8.3 Priority queues and heaps
175
reading its keys from the root to the leaves, level by level. This is a serialization
operation. For the heap of Figure 8.2, we get the following sequence: 37, 22, 31,
16, 17, 2, 23, 12, 6, 9. This sequence implicitly encodes the perfect binary tree.
But this does not mean that any array of integers is a heap in disguise. Indeed,
remember that the heap property of child/parent keys should be satisﬁed. For
arrays, this core property translates as:
1 ≤i, j ≤n, j = i
2 ⇒array[j] ≥array[i].
(8.1)
Thus the data-structure for representing a heap embedded in an array is as
follows:
public
class Heap
{
int
s i z e ;
int
[ ]
label ;
static
final
int MAX SIZE=10000;
Heap ()
{
this . s i z e =0;
this . label=new int [MAX SIZE ] ;
}
Let us now see the various operations acting on the heap compactly encoded
into the array int [] label;
8.3.1 Retrieving the maximal element
As noticed earlier, the maximal key of a heap is necessarily stored at its root.
That is, the maximal priority is encoded in the ﬁrst cell of the array. Therefore,
the following static function returns the maximal element of a heap given as
argument:
Program 8.3
Retrieving the maximal priority
static
int maxHeap(Heap h)
{return h . label [ 0 ] ; }
8.3.2 Adding an element
To add an element to the heap, we just need to add it to the ﬁrst array position
not yet assigned: The ﬁrst free location of the array corresponds to adding a

176
8. Object-Oriented Data-Structures
leaf at the rightmost position of the last level of the tree. By doing so, we may,
however, violate the heap property of Eq. 8.1, so that we need to transform
this tree into a heap by swapping child-parent keys until we again get a heap.
For example, consider adding element 25 to the heap. Figure 8.3 depicts the
three stages:
– (1) add node 25 at the ﬁrst place available on the last level of the tree,
– (2) swap that node with parent element 17 (since 25 > 17),
– (3) swap again with parent element 22, and reach the ﬁnal heap status since
35 < 37.
Not a heap anymore! 25 > 17
37
22
31
16
17
2
23
12
6
9 25
37
22
31
16
17
2
23
12
6
9
25
17
swap
Not a heap anymore! 25 > 22
swap
Ok
37
22
31
16
17
2
23
12
6
9
25
17
swap
It is a heap: 25 < 37
Figure 8.3 Adding element 25 to the heap: First, add a new node at the ﬁrst
immediate empty position; then eventually swap this node with its parent until
the heap property is recovered
These basic step operations translate into corresponding operations on the
array implicitly encoding the heap as follows:
Program 8.4
Adding an element to the heap
static void addHeap ( int
element ,
Heap h)
{
h . label [ h . s i z e ]= element ;
h . s i z e ++;
int
i=h . s i z e ;
int
j=i /2;
while ( i >1 && h . label [ i ]>h . label [ j ] )
{
int tmp=h . label [ i ] ;
h . label [ i ]=h . label [ j ] ;
h . label [ j ]=tmp ;
i=j ;
// swap
j=i /2;
}
}

8.3 Priority queues and heaps
177
8.3.3 Removing the topmost element
We have previously seen that the maximal element is at the root of the heap.
Let us explain now how to remove and update the heap. When we remove the
maximal element located at the root (index 0 of the array), we choose the last
inserted node and put this node at the the root position. We now similarly
have to again ensure the heap property by eventually performing swapping
operations: If the value of the current root node is below the value of its right
child (the right subtree has less or exactly as many children as the left tree by
construction), then we swap that node with the selected child, and reiterate
until we reach the heap property. Figure 8.4 depicts these swapping operations
when removing the topmost element.
22
31
16
17
2
23
12
6
9
25
22
31
16
2
23
12
6
9
22
31
16
2
23
12
6
9
12
swap
37
22
31
16
17
2
23
12
6
9
25
17
17
17
25
25
17
22
31
16
2
23
12
6
9
12
25
17
swap
The heap property is now satisﬁed!
Figure 8.4
Removing the maximal element of the heap: First, replace the
root by the last leaf node, and then potentially swap this node with its current
children until the heap property is recovered
The portion of code performing this removal operation in the array encoding
the heap is as follows:
Program 8.5
Removing the topmost element from the heap
static
int removeHeap ( int
element ,
Heap h)
{
h . label [0]=h . label [ h . size −1];
h . size −−;
int
i =0, j , k , tmp ;

178
8. Object-Oriented Data-Structures
while (2∗i<=h . s i z e )
{
j =2∗i ;
i f
( j<h . s i z e && h . label [ j +1]>h . label [ j ] )
j++;
i f
(h . label [ i ]<h . label [ j ] )
{tmp=h . label [ i ] ;
h . label [ i ]=h . label [ j ] ;
h . label [ j ]=tmp ;
i=j ;}
else break ;
}
return h . label [ h . size −1];
}
8.4 Object-oriented data-structures: Methods
We have so far explained data-structures and their basic operations using the
basic concepts of arrays and linked lists. The functions manipulating these
elementary data-structures have been all static functions so far. That means
that we had to pass the data-structure as an argument of the function, or to
declare the arrays/linked list as static variables of the class to be reached by
functions. Although we attached these basic static functions to the class by
inserting their code into the body of the class, this was not necessary. For
example, we could have designed a class Toolbox that contains all functions
operating on data-structures. Let us reexamine the code dealing with the linked
list of the previous chapter:
Program 8.6
Linked list with static functions
class
List
{
int
container ;
List
next ;
// Constructor
List(head , tail)
List ( int
element ,
List
t a i l )
{ this . container=element ;
this . next=t a i l ;}
// Static function is used here
static
int head ( List
l i s t )
{return
l i s t . container ;}
}

8.4 Object-oriented data-structures: Methods
179
We can remove all static functions from the scope of the List body and attach
them to, say, a general-purpose class called Toolbox as follows:
Program 8.7
Linked list with static functions attached to a Toolbox class
class
List
{
int
container ;
List
next ;
// Constructor
List(head , tail)
List ( int
element ,
List
t a i l )
{ this . container=element ;
this . next=t a i l ;}
}
class
Toolbox{
static
int head ( List
l i s t )
{return
l i s t . container ;}
static
List
i n s e r t ( int s ,
List
l i s t )
{return new List ( s , l i s t ) ;
}
Then we could have created linked lists and called various related static
functions by invoking static functions of the Toolbox class. For example, let us
consider the following code snippet:
class
List
{
int
container ;
List
next ;
// Constructor
List(head , tail)
List ( int
element ,
List
t a i l )
{ this . container=element ;
this . next=t a i l ;}
}
class
Toolbox{
static
int head ( List
l i s t )
{return
l i s t . container ;}
static
List
i n s e r t ( int s ,
List
l i s t )
{return new List ( s , l i s t ) ;
}
}
class
StaticFunction
{
public
static void main ( String
[ ]
args )
{
List
myList=new List (3 , null ) ;
myList=Toolbox . i n s e r t (6 , Toolbox . i n s e r t (4 , myList ) ) ;

180
8. Object-Oriented Data-Structures
System . out . p r i n t l n ( "Head:"+Toolbox . head ( myList ) ) ;
}
}
Compiling and executing the program returns the expected result:
Head:6
Note that all usual mathematical functions such as exp (Math.exp), log
(Math.log), √(Math.sqrt), ... are deﬁned similarly, as static functions, in
the toolbox class Math. We can thus imitate this library behavior of classes by
attaching common functions to a Toolkit class:
Program 8.8
Static functions attached to a library class
class
Toolkit
{
static
final double PI =3.14;
static double Square (double x)
{return x∗x ;}
static double Cubic (double x)
{return x∗x∗x ;}
}
class
StaticFuncStyle
{
public
static void main ( String [ ]
s )
{
double radius =0.5;
double volSphere =(4/3.0) ∗Toolkit . PI∗Toolkit . Cubic ( radius ) ;
double areaDisk=Toolkit . PI∗Toolkit . Square ( radius ) ;
} }
A static function not accessing static class variables can therefore be attached
to any class3 but requires us to get as arguments the objects on which it
processes on. The advantage of attaching all static functions to the same class
as its argument object is that we can remove the class name. That is, if class
insert were attached to the List class, then instead of having the instruction
myList=Toolbox.insert(6,Toolbox.insert(4,myList));, we would have
simpliﬁed it as myList=insert(6,insert(4,myList));
On the other hand, a data-centric view will consider the object List on which
we can apply various processes called methods. These object methods do not
require us to give as an argument the object itself as it is understood that
these methods can access the object ﬁelds provided the function is a non-static
3 And can thus be loosely called class function.

8.4 Object-oriented data-structures: Methods
181
function: an object method. The object ﬁeld is accessed using the reserved
keyword this.
Program 8.9
Object methods for the list
class
ListObj
{
int
container ;
ListObj
next ;
ListObj ( int
element ,
ListObj
t a i l )
{ this . container=element ;
this . next=t a i l ;}
ListObj
i n s e r t ( int
s )
{return new ListObj ( s , this ) ;}
// Method
int head ()
{return this . container ;}
}
In the main procedure, we could have then used the following instructions:
ListObj
l i s t=new ListObj (7 , null ) ;
l i s t=l i s t . i n s e r t (4) ;
System . out . p r i n t l n ( "Head:"+l i s t . head () ) ;
In the remainder, we will adopt this object-oriented framework when designing
data-structures, as they correspond to a true data encapsulation.4 We will ﬁrst
present the (class) static function and then describe the corresponding object-
oriented data-structure.
As concisely mentioned in the introduction, we made a diﬀerence between data-
structures with static functions operating on them, and encapsulated methods
acting directly on the object itself. We shall further describe these concepts
of object-oriented programming and revisit former data-structures using that
framework (replacing static functions by equivalent object methods).
To start with, consider the following example where one has to compute
the volume of a 3D box. First, we deﬁne a Box object by writing its class
encapsulating its data members: width, height, and depth. So far, the usual
way to process a Box has been using static functions that were necessarily
attached to a class. So let us deﬁne the static double Volume(Box box)
function inside the body of the main class program. Note that this static
function needs a Box object as argument. The second (and much better way) to
program this functionality is to provide a method to the object that will dispose
of all the object ﬁelds at the time it is called. We access the various object ﬁelds
4 A second more advanced course will then purposely describe the public/private
keyword syntax.

182
8. Object-Oriented Data-Structures
using the keyword this. The example below illustrates the essential diﬀerence
between the two ways of programming the Volume functionality.
Program 8.10
Object-oriented method for computing the volume of a 3D
box
class Box
{
double width ,
height ,
depth ;
Box(double w,
double h ,
double d)
{
this . width=w;
this . height=h ;
this . depth=d ;
}
double Volume ()
{return this . width∗this . height ∗this . depth ;}
}
class
OOstyle
{
static double Volume(Box box )
{return box . width∗box . height ∗box . depth ;}
public
static void main ( String [ ]
s )
{
Box myBox=new Box (5 ,2 ,1) ;
System . out . p r i n t l n ( "Volume by static method:"+Volume(myBox) ) ;
System . out . p r i n t l n ( "Volume by object method:"+myBox . Volume () )
;
}
}
8.5 Revisiting object-oriented style
data-structures
8.5.1 Object oriented priority queues
The former maxHeap/add/removeTop static functions operating on the array
can thus be translated as equivalent methods acting on the object. A heap
object now declares the array as an object ﬁeld without that static keyword.
Therefore, we can build several heaps at a time. The prototypes for the heap
methods are as follows:

8.5 Revisiting object-oriented style data-structures
183
Program 8.11
Heap: Prototyping object methods
int maxHeap ()
{
return this . label [ 0 ] ;
}
void add ( int
element )
{
. . .
}
void removeTop ()
{
. . .
}
8.5.2 Object-oriented lists
Similarly, we can revisit the static functions formerly deﬁned on linked lists to
ﬁt the object-oriented programming paradigm as follows:
Program 8.12
Linked list with object methods
public
class
List
{
int
element ;
List
next ;
List ( int
el ,
List
l )
{
this . element=e l ;
this . next=l ;
}
static
List
EmptyList ()
{
return new List (0 , null ) ;
}
boolean isEmpty ()
{
return ( this . next==null ) ;
}
}
The other various functions of linked list interface are then redeﬁned as the
following object methods:

184
8. Object-Oriented Data-Structures
Program 8.13
Linked list the object-oriented style: Methods
int
length ()
{
List u=this ;
int
res =0;
while (u!=null )
{ res++;u=u . next ;}
return res −1;
}
boolean belongsTo ( int
e l )
{
List u=this . next ;
while (u!=null )
{
i f
( e l==u . element ) return true ;
u=u . next ;
}
return
false ;
}
void add ( int
e l )
{ List u=this . next ;
this . next=new List ( el , u) ;
}
void
d e l e t e ( int
e l )
{
List
v=this ;
List w=this . next ;
while (w!=null && w. element != e l )
{
v=w;
w=w. next ;
}
i f
(w!= null ) v . next=w. next ;
}
void
display ()
{
List u=this . next ;
while (u!=null )
{System . out . print (u . element+"->" ) ;
u=u . next ;}
System . out . p r i n t l n ( "null" ) ;
}
static
List
FromArray ( int
[ ]
array )
{
List u=EmptyList () ;
for ( int
i=array . length −1; i >=0; i −−)

8.6 Stacks: Last in ﬁrst out (LIFO) abstract data-structures
185
u . add ( array [ i ] ) ;
return u ;
}
A simple code demonstrating various calls of object methods is given below.
Observe that the data-structure is not passed as an argument since it is
encapsulated into the object as a ﬁeld.
Program 8.14
Demonstrating various calls of object methods
public
static void main ( String [ ]
args )
{
int
[ ]
array ={2 ,3 ,5 ,7 ,11 ,13 ,17 ,19 ,23};
List u=FromArray ( array ) ;
u . add (1) ;
u . display () ;
u . d e l e t e (5) ;
u . display () ;
System . out . p r i n t l n (u . belongsTo (17) ) ;
System . out . p r i n t l n (u . belongsTo (24) ) ;
}
The result displayed in the console output is:
1->2->3->5->7->11->13->17->19->23->null
1->2->3->7->11->13->17->19->23->null
true
false
8.6 Stacks: Last in ﬁrst out (LIFO) abstract
data-structures
Stacks are generic data-structures for storing incoming elements. However,
stacks depart from queues in the sense that the last arrived element is the
ﬁrst pulled out. This is why stacks are also called LIFO data-structures: Last
in ﬁrst out structures. The basic interface5 of a stack is described by the two
following methods:
– Push: Add an element into the stack,
5 Java
also
provides
in
its
API
a
generic
stack
implementation.
See
http://java.sun.com/j2se/1.4.2/docs/api/java/util/Stack.html

186
8. Object-Oriented Data-Structures
– Pull (or Pop): Remove the last inserted element from the stack.
These two basic methods of stacks can be implemented using various schemes.
We describe two of them to insist on the notion of abstract data-structures:
Arrays and linked lists.
8.6.1 Stack interface and an array implementation
We may implement a stack using an array. The array is declared as an object
ﬁeld with an index variable that indicates the position of the last inserted
element: the top of the stack. The Push/Pull primitives of the stack interface
are then implemented as follows:
Program 8.15
Stack implementation using an array
class
StackArray
{
int nbmax ;
int
index ;
int
[
]
array ;
// Constructors
StackArray ( int n)
{
this . nbmax=n ;
array=new int [ nbmax ] ;
index=−1;
System . out . p r i n t l n ( "Succesfully created a stack array object
..." ) ;
}
// Methods
void Push ( int
element )
{
i f
( index<nbmax−1)
array[++index ]= element ;
}
int
Pull ()
{
i f
( index>=0 ) return array [ index −−];
else return −1;
}
}
Let us store the above StackArray class into a corresponding Java source code
text ﬁle: StackArray.java. Then compile this code for manipulating stacks
using arrays:
prompt% javac StackArray.java

8.6 Stacks: Last in ﬁrst out (LIFO) abstract data-structures
187
A byte-code ﬁle named StackArray.class encapsulating the object character-
istics and its methods is produced into the current directory. We can now use
this bytecode and object interface into a demonstration program stored into
another text ﬁle, say DemoStack.java:
Program 8.16
Stack in action: A simple demonstration program
class DemoStack{
public
static void main ( String
[ ]
args )
{
StackArray myStack=new StackArray (10) ;
int
i ;
for ( i =0; i <10; i++)
myStack . Push ( i ) ;
for ( i =0; i <15; i++)
System . out . p r i n t l n ( myStack . Pull () ) ;
}
Compiling and running this demonstration program, we get the following
console output:
Succesfully created a stack array object...
9
8
7
6
5
4
3
2
1
0
-1
-1
-1
-1
-1
Let us now see how to implement the two methods of the stack interface using
another kind of data-structure for its backbone: linked lists.
8.6.2 Implementing generic stacks with linked lists
Instead of using an array, let us now use a linked list for storing incoming
elements. We ﬁrst recall the list declaration and its basic primitives:

188
8. Object-Oriented Data-Structures
Program 8.17
Minimal list implementation
class
List
{
int
element ;
List
next ;
// Constructor
List ( int
el ,
List
t a i l )
{
this . element=e l ;
this . next=t a i l ;
}
List
insertHead ( int
e l )
{
return new List ( el , this ) ;
}
}
Let us now use this linked list data-structure for supporting the methods
provided by the stack:
Program 8.18
Implementing the stack interface using a linked list as its
backbone data-structure
class
Stack
{
List
l i s t ;
Stack ()
{
l i s t=null ;
}
void Push ( int
e l )
{
i f
( l i s t != null )
l i s t=l i s t . insertHead ( e l ) ;
else
l i s t=new List ( el , null ) ;
}
int
Pull ()
{ int
val ;
i f
( l i s t != null )
{ val=l i s t . element ;
l i s t=l i s t . next ;}
else
val=−1;
return
val ;
}
}

8.7 Exercises
189
Finally, we can now run the same demonstration program as for arrays. The
result is identical since the semantic of the methods declared in the stack
interface is the same. We get the following Java program:
Program 8.19
Demonstration program: Stacks using linked lists
class
DemoStackList
{
public
static void main ( String
[ ]
args )
{
Stack myStack=new Stack () ;
int
i ;
for ( i =0; i <10; i++)
myStack . Push ( i ) ;
for ( i =0; i <15; i++)
System . out . p r i n t l n ( myStack . Pull () ) ;
}
}
In summary, objects provide a nice framework for encapsulating data. The
methods acting on object are non-static functions that can access the ﬁelds of
the current object. Thus methods can be interpreted as basic algorithms on
structured data.
8.7 Exercises
Exercise 8.1 (Stacks of strings)
Implement a stack for storing strings. Write static functions push and
pop. Then provide the equivalent methods for that class, and discuss the
advantages of using object methods.
Exercise 8.2 (Flood-ﬁlling binary images using stacks and queues)
Consider a binary image deﬁned by a bi-dimensional array of booleans:
boolean [] [] image;. Provide a function drawRectangle that draws
the border of a rectangle given by its bottom left corner and with/height
dimensions. Create a binary image by drawing at random n rectangle
borders using the function Math.random(). We would like to perform
the ﬂood-ﬁlling at image pixel (x, y). Implement the recursive function
FloodFillingStack by using a pixel stack. Similarly, implement the

190
8. Object-Oriented Data-Structures
recursive function FloodFillingQueue by using a queue. Which imple-
mentation technique is the most memory eﬃcient?
Exercise 8.3 (Sorting using a priority queues)
Consider sorting a set of strings stored initially in an array String []
array using a priority queue deﬁned with respect to the lexicographic
order on strings. Implement the priority queue for String elements.
Then sort the initial array of strings by ﬁrst inserting all strings into
the priority queue, and then successively retrieving them. What is the
time and memory complexity of sorting using priority queues?

9
Paradigms for Optimization Problems
9.1 Introduction
In this chapter, we consider fundamental optimization problems that occur in
many real-life applications. The few selected core optimization problems are
very representative of a broad class of mathematical problems encountered in
practice. A major characteristic of these problems is that they are all combi-
natorial by essence. This means that the optimization algorithms described in
the following are not approaching an optimal solution numerically (by say, a
Newton-like gradient descent method as seen previously in Chapter § 2), but
rather exploring and searching for exact solutions in large but ﬁnite discrete
conﬁguration spaces. The optimization techniques presented in the remainder
are broad enough that their underlying schemes can be used for solving various
problems; these diﬀerent kinds of solving methodologies are called paradigms
since they yield generic algorithms for tackling many similar problems.
We ﬁrst start by describing the naive brute force method, called exhaustive
search, which consists of visiting all positions of conﬁguration spaces. We
then show how plugging a few structural constraints emanating directly
from problems’ properties allows one to signiﬁcantly shrink the number of
inspected conﬁgurations using a so-called backtracking mechanism implicitly
implemented by recursion. As the size of problems grows, these exhaustive
search and backtracking algorithms unfortunately suﬀer from browsing these
gigantic domains. These exponentially large conﬁguration spaces are too costly
to explore, and solving these problems in practice become intractable. To
F. Nielsen, A Concise and Practical Introduction to Programming Algorithms in Java,
Undergraduate Topics in Computer Science, DOI 10.1007/978-1-84882-339-6 9,
c⃝Springer-Verlag London Limited, 2009

192
9. Paradigms for Optimization Problems
circumvent this inherent diﬃculty, we design faster algorithms that only report
approximate solutions instead of too-costly exact solutions. We end up by
presenting the most celebrated heuristic for getting guaranteed approximate
solutions: the greedy strategy. We exemplify the greedy methodology on
two problems: the knapsack and set cover problems,, which emphasize the
important fact that the same paradigm applied to these two distinct problems
yields diﬀerent approximation ratios.
9.2 Exhaustive search
The paradigm of exhaustive search consists merely in exploring the full
conﬁguration space by enumerating one by one all possible conﬁgurations,
and retaining the best one: the optimal solution. Eventually several optimal
solutions may exist. Exhaustive search is clearly the brute-force paradigm that
yields straightforward but often naive algorithms for solving a task at hand.
Let us explain its implementation by taking a case study: the knapsack.
9.2.1 Filling a knapsack
Consider a set O of n objects O1, ..., On with corresponding weights W1, ..., Wn.
Suppose that object Oi weights Wi, where Wi is measured in kilogram units
for all i ∈{1, ..., n}. Given a knapsack that can carry an overall weight W, we
are asked to enumerate all possible choices for fully ﬁlling this sack. Objects
can be chosen only once; There is no allowed multiplicity of objects. In other
words, we are asked to ﬁnd all possible object selections that yield an overall
weight of exactly W kilograms. W is called the capacity of the bag.
We can formulate this problem as computing
I∗=

I ⊆{1, ..., n},

i∈I
Wi = W

,
where I denote a subset of indices representing the object selection. That is,
ﬁnd all index subsets so that their corresponding object weights sum up to the
knapsack capacity.
If we were given a priori a ﬁxed number of objects n, we could simply check all
possible choices of selecting or not selecting objects by writing a sequence of
nested loops. For example, consider completely ﬁlling a knapsack of capacity
W = 11 by selecting objects in a set of n = 5 objects with the following

9.2 Exhaustive search
193
corresponding weights W1 = 3, W2 = 4, W3 = 5, W4 = 6 and W5 = 2. Let us
visualize the input as the following table:
Oi
1
2
3
4
5
Wi
3
4
5
6
3
The source code for fully exploring the combinatorial space of solutions by
programming nested loops is presented below:
Program 9.1
Plain enumeration using nested loops
class
KnapsackNestedLoops
{
public
static void main ( String
[ ]
argArray )
{
int W1=3, W2=4, W3=5, W4=6, W5=2; // respective weights
int W=11; // weight capacity of the knapsack
int bagWeight ; //
weight of ‘current’ configuration
for ( int
i1 =0; i1 <=1; i1++)
{ for ( int
i2 =0; i2 <=1; i2++)
{ for ( int
i3 =0; i3 <=1; i3++)
{ for ( int
i4 =0; i4 <=1; i4++)
{ for ( int
i5 =0; i5 <=1; i5++)
{
bagWeight=i1 ∗W1+i2 ∗W2+i3 ∗W3+i4 ∗W4+i5 ∗W5;
// Does the current selection match the sack
capacity
i f
( bagWeight==W)
{System . out . p r i n t l n ( "Solution:"+i1+" "+i2+" "+
i3+" "+i4+" "+i5 ) ;}
}
}
}
}
}
}
}
Compiling the code (using console command javac KnapsackNestedLoops.
java) and executing the above program (using console command java
KnapsackNestedLoops), we get all possible solutions, reported using true/false
memberships of objects:
Solution:0 0 1 1 0
Solution:0 1 1 0 1
Solution:1 0 0 1 1
That is, the ﬁrst solution 0 0 1 1 0 reads as select object O3 and O4 (but not
objects O1 nor O4): The subset {O3, O4} of O encoded by the index subset

194
9. Paradigms for Optimization Problems
{3, 4} (see Eq. 9.2.1). We check that we indeed have W3+W4 = 5+6 = 11 = W.
Thus the set of solutions can be read back from the bit memberships, as follows:
I∗= {{3, 4}, {2, 3, 5}, {1, 4, 5}} .
The exhaustive search algorithm seeks for all potential solutions by fully
exploring the conﬁguration space. Each conﬁguration is modeled by a set of
“loop indices” telling us whether or not we choose the corresponding object.
This shows that there are 2n possible conﬁgurations, ranging from the empty
set1 to the complete set O, encoded by the full set of indices {1, ..., n}. Observe
that if we were to add a sixth object, we would need to add another nested loop
directly inside the code in order to solve for solutions. This clearly stresses the
limits of the “nested loop” method since we clearly do not want to manually
edit the program source code every time we have a diﬀerent problem size to
solve. Furthermore, imagine if you were asked to write the nested loop program
for n = 100. That would be daunting. Therefore, the number of objects n shall
be considered as a parameter of the ﬁlling knapsack problem itself.
How do we cope with such a situation? We need to reconsider the conﬁguration
space, and model it appropriately. The potential solution space is modeled by
the power set 2O = {O′,
O′ ⊆O} that includes all possible subsets of O,
including the empty set. As highlighted above, to each subset O′ ⊆O, we
associate a binary signature b(O′) of length n such that the l-th bit is set to 1
(or boolean true state) if and only if object Oi belongs to O′. The conﬁguration
space is thus in a one-to-one mapping with the space of bit signatures: The
set of binary numbers of n bits (with evaluated values ranging from 0 to
2n −1). In other words, the binary signature depicts the conﬁguration number
whose binary representation is that signature. This shows that the size of the
conﬁguration space is 2n; It grows exponentially fast with n. Incrementing n
doubles the size of the conﬁguration space.
To perform an exhaustive search of the conﬁguration space for any arbitrary
value n of objects, we ﬁrst proceed by enumerating all possible binary
representation numbers with n bits. Enumerating all binary representations
with n bits can be done using the following recursive algorithms:
Program 9.2
Enumerating all 2n binary number representations with n bits
class
Enumeration
{
static void
display ( boolean
[ ]
tab )
{
for ( int
i =0; i<tab . length ; i++)
1 Obviously not a solution since its weight is trivially zero, but nevertheless
considered when browsing the conﬁguration space by these nested loops.

9.2 Exhaustive search
195
{ i f
( tab [ i ] )
System . out . print ( "1 " ) ;
else
System . out . print ( "0 " ) ;}
System . out . p r i n t l n ( "" ) ;
}
static void Enumerate ( boolean
[ ]
s e l e c t i o n ,
int
pos )
{
i f
( pos==s e l e c t i o n . length −1)
{ display ( s e l e c t i o n ) ;}
// terminal case , reach length n
else
{
pos++;
// Set the (pos+1)th bit to 1
s e l e c t i o n [ pos]=true ;
Enumerate ( s e l e c t i o n , pos ) ;
// Set the (pos+1)th bit to 0
s e l e c t i o n [ pos]= false ;
Enumerate ( s e l e c t i o n , pos ) ;
}
}
public
static void main ( String [ ]
args )
{
int n=4; int
i ;
// Binary representation of numbers
boolean
[ ]
s e l e c t=new boolean [ n ] ;
for ( i =0; i<n ; i++)
{ s e l e c t [ i ]= false ;}
// optional since array creation set it
to all zero
// Launching the enumeration from the first bit (index 0)
Enumerate ( s e l e c t , −1) ;
}
}
Running the program by executing the compiled byte code (javac Enumeration;
java Enumeration), we get the following output:
1 1 1 1
1 1 1 0
1 1 0 1
1 1 0 0
1 0 1 1
1 0 1 0
1 0 0 1
1 0 0 0
0 1 1 1
0 1 1 0
0 1 0 1
0 1 0 0
0 0 1 1

196
9. Paradigms for Optimization Problems
0 0 1 0
0 0 0 1
0 0 0 0
To solve the ﬁlling knapsack problem, we now need to check at the terminal
states whether the overall knapsack weight of currently selected objects matches
the capacity weight of the knapsack or not.
Program 9.3
Exhaustive search for the perfect ﬁlling of a knapsack
class KnapSack
{
final
static
int n=10; // 10 objects
static
int
[ ]
weight ={2 ,3 ,5 ,7 ,9 ,11 ,4 ,13 ,23 ,27};
static void
display ( boolean
[ ]
s e l e c t i o n ,
int
val )
{ String msg="" ;
for ( int
i =0; i<s e l e c t i o n . length ; i++)
{ i f
( s e l e c t i o n [ i ] )
msg=msg+weight [ i ]+" " ;}
System . out . p r i n t l n (msg+"="+val ) ;
}
static void solveKnapSack ( boolean
[ ]
chosen ,
int
goal ,
int
i ,
int
t o t a l )
{
i f
(( i>=chosen . length )&&(t o t a l != goal ) )
return ;
i f
( t o t a l==goal )
{ display ( chosen ,
goal ) ;}
else
{
chosen [ i ]=true ; // add item first and proceed
solveKnapSack ( chosen , goal , i +1, t o t a l+weight [ i ] ) ;
chosen [ i ]= false ;
// and then remove it and proceed
solveKnapSack ( chosen , goal , i +1, t o t a l ) ;
}
}
public
static void main ( String
[ ]
args )
{
int
totalweight =51;
boolean
[ ]
chosen=new boolean [ n ] ; // initialized to all false
solveKnapSack ( chosen ,
totalweight ,
0 ,
0) ;
}
}
All solutions are then properly listed as below:

9.2 Exhaustive search
197
2 3 5 7 11 23 =51
2 5 7 9 11 4 13 =51
2 5 4 13 27 =51
2 7 11 4 27 =51
2 9 4 13 23 =51
2 9 13 27 =51
3 5 7 9 4 23 =51
3 5 7 9 27 =51
3 5 7 13 23 =51
3 5 9 11 23 =51
7 4 13 27 =51
9 11 4 27 =51
11 4 13 23 =51
11 13 27 =51
Exhaustive search is not an eﬀective algorithmic technique since it fully explores
the solution space to retrieve all potential solutions. The solution space is indeed
a very sparse subset, a tiny fraction of the conﬁguration space. For example, we
found 14 solutions among a conﬁguration space of size 210 = 1024. Furthermore,
note that if all object weights add up to less than the capacity weight, we can
obviously avoid performing the search since we already know that there is no
possible solution. Thus the plain implementation of exhaustive search does
extra work.
In order to avoid some of the unnecessary explorations, we can implement a cut
in recursive function solveKnapSack. Indeed, if at some stage of the recursion,
we already know that the current bag weight exceeds the capacity, it is not
worth adding other remaining objects that can only add weight to the bag. We
can therefore stop the recursion at these stages. To measure how many times
this cut was applied in practice, we add a static (class) variable initialized at
zero: static int nbCut=0; The exploration procedure with the cut now reads
as:
Program 9.4
Adding a cut to the recursive exhaustive search
static void solveKnapSack ( boolean
[ ]
chosen ,
int
goal ,
int
i ,
int
t o t a l )
{
i f
( total >goal )
{nbCut++;
return ;
// cut recursive explorations
}
i f
(( i>=chosen . length )&&(t o t a l != goal ) )
return ;
i f
( t o t a l==goal )
{ display ( chosen ,
goal ) ;}
else
{
chosen [ i ]=true ; // add item first and proceed
solveKnapSack ( chosen , goal , i +1, t o t a l+weight [ i ] ) ;
chosen [ i ]= false ;
// and then remove it and proceed

198
9. Paradigms for Optimization Problems
solveKnapSack ( chosen , goal , i +1, t o t a l ) ;
}
}
Running this program, we ﬁnd that it reported 396 cuts.
9.2.2 Backtracking illustrated: The eight queens puzzle
The queen puzzle consists of placing eight queens on an 8×8 chessboard so that
the queens are in a mutually safe position. That is, none of the queens is able to
capture any other. Figure 9.1 graphically depicts such a solution. Historically,
ﬁnding whether there exist solutions was ﬁrst asked by German chess player
Max Bezzel in 1848. A brute force algorithm will enumerate all possible ways
of putting the eight queens on a chessboard. The exhaustive search paradigm
will thus explore...
 64
8

= 64 × 63 × ... × 57
8!
= 283, 274, 583, 552
...diﬀerent conﬁgurations: There are 64 choices for placing the ﬁrst queen, and
then 63 choices for the second, up to 57 = 64 −8 + 1 choices for placing the
last queen. Since queens are not distinguishable, we divide the former number
by the number of queen permutations: 8!.
Figure 9.1
Illustrating one of the 92 distinct
solutions to the eight queen puzzle
Thus a direct implementation of exhaustive search would not be eﬃcient since
the number of recursive calls is too important. We are going to exploit some
structural properties of the eight queen problem to guide the exploration.
Observe that trivially two queens cannot be located on the same row of
the chessboard. Therefore a much better exhaustive search will consider only
88 = 224 = 16, 777, 216 conﬁgurations (for each queen, there are only 8 potential

9.2 Exhaustive search
199
positions on its given row). Let the ith queen column position be stored in
an integer array queen. That is, the position of the ith queen is stored at
coordinates (i ,queen[i ]) (with queen indices ranging from 0 to 7 to follow Java
array conventions). Suppose we have already correctly placed l queens on the
ﬁrst l rows so that these l queens are pairwise safe. For the (l + 1)th queen
necessarily located at row l + 1, we are going to check in turn all column
positions, starting from column 0 up to column 7 until we ﬁnd a safe position
for the queen with respect to the previously located ones. Once such a position
found, we proceed to the next queen lying on the next line, and so on. Whenever
we reach at some point all column positions without ﬁnding a solution, then
we need to backtrack by increasing the column of the previous queen (located
at the row below the current queen), and so on. The recursive exploration with
backtracking is detailed in the source code below. The recursive procedure is
initially launched by calling in the main procedure function search(0).
Program 9.5
Eight queen puzzle: Search with backtracking
static boolean search ( int row )
{
boolean
r e s u l t=false ;
i f
( row==n)
{ displayChessboard () ;
nbsol++; }
else
{ int
j =0;
while ( ! r e s u l t && j<n)
{
i f
( safeMove (row , j ) )
{
queen [ row]= j ;
r e s u l t=search ( row+1) ;
}
// Backtracking here
j++; // explore all columns
}
}
return
r e s u l t ;
}
To check whether two queens are in mutually safe positions or not, we check
whether these two queens lie on the same row or column, or whether they share
a common diagonal. This can be compactly written as:
Program 9.6 Check whether two queens are in mutually safe position or not
static boolean wrongPos ( int
i1 ,
int
j1 ,
int
i2 ,
int
j2 )
{
return (
i1==i2
| |
j1==j2
| |
Math . abs ( i1−i2 ) == Math . abs ( j1−j2 )
) ;

200
9. Paradigms for Optimization Problems
}
It follows that we can check when we add the new i-th queen on the chessboard
whether its position is safe or not with respect to all others (k < i) as follows:
Program 9.7
Check whether the i-th queen is safe wrt. the k-th queens, for
k < i
static boolean safeMove ( int
i ,
int
j )
{boolean
r e s u l t=true ;
for ( int k=0;k<i ; k++)
r e s u l t=r e s u l t && ! wrongPos ( i , j , k , queen [ k ] ) ;
return
r e s u l t ;
}
Finally, let us give the exhaustive search procedure with the recursive
backtracking mechanism for the n queens, including a chessboard display
procedure called every time a solution is found:
Program 9.8
Solving the 8-queen puzzle
class Queen
{
static
final
int n=8;
static
int
[ ]
queen=new int [ n ] ;
// position (i,queen[i])
static
int
nbsol ;
static void displayChessboard ()
{
int
i , j ;
System . out . p r i n t l n ( "" ) ;
for ( i =0; i<n ; i++)
{
for ( j =0; j<n ; j++)
{
i f
( queen [ i ]!= j ) System . out . print ( "0" ) ;
else System . out . print ( "1" ) ;
}
System . out . p r i n t l n ( "" ) ;
}
}
static boolean wrongPos ( int
i1 ,
int
j1 ,
int
i2 ,
int
j2 ) { . . . }
static boolean safeMove ( int
i ,
int
j ) { . . . }
static boolean search ( int row ) { . . . }
public
static void main ( String
[ ]
arguments )
{
nbsol =0;
search (0) ;
System . out . p r i n t l n ( "Total number of solutions:"+nbsol ) ;
}

9.3 Greedy algorithms: Heuristics for guaranteed approximations
201
}
Compiling and running this program, we obtain the well-known 92 distinct
solutions that are displayed in the console using a 2D binary matrix indicating
the queen locations as shown below:
...
00000001
00100000
10000000
00000100
01000000
00001000
00000010
00010000
00000001
00010000
10000000
00100000
00000100
01000000
00000010
00001000
Total number of solutions:92
It turns out that only 12 of these solutions are non-naive since others can
be deduced from this reduced set of solutions by using rotation, ﬂipping or
symmetry operations. You can try the program on any arbitrary chessboard
size, say of width size n = 10, and observe the number of solutions (724 distinct
conﬁgurations for n = 10).
9.3 Greedy algorithms: Heuristics for
guaranteed approximations
9.3.1 An approximate solution to the 0-1 knapsack
problem
We revisit the former ﬁlling knapsack problem of § 9.2.1 where we are given
a set O of n objects O1, ..., On called items and a knapsack to ﬁll up to its
maximal weight capacity W. But this time we consider that each object Oi,
besides its weight Wi, has yet another attribute: Ui, its utility. The 0-1 knapsack

202
9. Paradigms for Optimization Problems
problem is a packing problem where one seeks for the best selection of objects
such that:
1. the overall sum of the selected objects is less or equal to the knapsack
capacity W, and
2. the overall utility of selected items is maximized.
This can be written mathematically as the following optimization problem:
max
I⊆{1,...,n}

i∈I
Ui,
(9.1)
such that

i∈I
Wi ≤W.
(9.2)
Figure 9.2 depicts an instance of the optimization knapsack problem.
Knapsack: Capacity 14 kg
12 kg
5 e
2 e
1 e
7 e
5 kg
2 kg
3 kg
???
10 e
4 kg
???
Figure 9.2 The 0-1 knapsack problem consists of ﬁnding the set of items that
maximizes the overall utility while ﬁtting the knapsack capacity
Exhaustively checking all 2n subsets of O (power sets 2O) as we did before
takes too long and faces intrinsic limitations as soon as n ∼30 −40, due to
the exponential size of the conﬁguration space. We prefer to design a heuristic
for the task that will report not an exact solution, but rather a guaranteed
approximation. The basic idea of the greedy algorithm is to ﬁrst choose the
object Ol that maximizes the ratio Gl =
Ui
Wi of utility Ul over its weight Wl,
remove this object from the set of items, and repeat until we reach the maximum
capacity W of the knapsack, or when we cannot add any more objects without

9.3 Greedy algorithms: Heuristics for guaranteed approximations
203
exceeding the capacity. This is a greedy approximation heuristic that selects
objects one by one. Once an object is taken it is not considered any more,
and the optimization heuristic proceeds with the remaining objects. A choice
is therefore deﬁnitive and irrevocable. The ratio factor of the utility over the
weight is called the gain of objects.
Consider solving a 0-1 knapsack with capacity W = 20 and the following set of
n = 10 (ten) items:
i
1
2
3
4
5
6
7
8
9
10
Ui
5
3
8
12
5
7
9
2
3
6
Wi
3
5
2
4
7
3
2
3
5
7
Gi
5
3
3
5
4
3
5
7
7
3
9
2
2
3
3
5
6
7
Program 9.9
Greedy approximation algorithm for solving the 0-1 knapsack
class
GreedyKnapsack
{
static
int n=10;
static
int
[ ] W={5, 3 ,
8 ,
12 ,
5 ,
7 ,
9 ,
2 ,
3 ,
6};
static
int
[ ] U={3, 5 ,
2 ,
4 ,
7 ,
3 ,
2 ,
3 ,
5 ,
7};
static
int wKnapsack=20;
// Greedy algorithm for approximating a best solution
public
static void main ( String
[ ]
argArray )
{
double [ ]
gain=new double [ n ] ;
double g ;
int
nSel =0;
int u=0;
int w=0;
int
i ,
winner ;
boolean
[ ]
chosen=new boolean [ n ] ;
System . out . p r i n t l n ( "Maximum weight of the knapsack:"+
wKnapsack ) ;
for ( i =0; i<n ; i++)
{
gain [ i ]=U[ i ] / ( double)W[ i ] ;
chosen [ i ]= false ;
}
while ( nSel<=n && w<wKnapsack )
{
g=0.0d ;
winner=−1;
for ( i =0; i<n ; i++)
{

204
9. Paradigms for Optimization Problems
i f
( ! chosen [ i ] && w+W[ i ]<=wKnapsack )
System . out . p r i n t l n ( i+" Weight "+W[ i ]+" Utility "+U[ i ]+"
Gain["+i+"]="+gain [ i ] ) ;
}
// Search best gain in the remaining collection of objects
for ( i =0; i<n ; i++)
i f
( ! chosen [ i ] && gain [ i ]>g && wKnapsack−(w+W[ i ] ) >=0)
{g=gain [ i ] ; winner=i ;}
// Can we add this object to the knapsack
i f
( winner!=−1 && w+W[ winner]<wKnapsack )
{
u+=U[ winner ] ;
w+=W[ winner ] ;
chosen [ winner]=true ;
nSel++;
System . out . p r i n t l n ( "Selected object "+winner+", updating
#weights="+w+" #utility="+u) ;
}
else break ;
}
}
}
Running the greedy knapsack heuristic on the set of above items, we get the
following output at the console:
Maximum weight of the knapsack:20
0 Weight 3 Utility 5 Gain[0]=1.6666666666666667
1 Weight 5 Utility 3 Gain[1]=0.6
2 Weight 2 Utility 8 Gain[2]=4.0
3 Weight 4 Utility 12 Gain[3]=3.0
4 Weight 7 Utility 5 Gain[4]=0.7142857142857143
5 Weight 3 Utility 7 Gain[5]=2.3333333333333335
6 Weight 2 Utility 9 Gain[6]=4.5
7 Weight 3 Utility 2 Gain[7]=0.6666666666666666
8 Weight 5 Utility 3 Gain[8]=0.6
9 Weight 7 Utility 6 Gain[9]=0.8571428571428571
Selected object 6, updating #weights=2 #utility=9
0 Weight 3 Utility 5 Gain[0]=1.6666666666666667
1 Weight 5 Utility 3 Gain[1]=0.6
2 Weight 2 Utility 8 Gain[2]=4.0
3 Weight 4 Utility 12 Gain[3]=3.0
4 Weight 7 Utility 5 Gain[4]=0.7142857142857143
5 Weight 3 Utility 7 Gain[5]=2.3333333333333335
7 Weight 3 Utility 2 Gain[7]=0.6666666666666666
8 Weight 5 Utility 3 Gain[8]=0.6
9 Weight 7 Utility 6 Gain[9]=0.8571428571428571
Selected object 2, updating #weights=4 #utility=17
0 Weight 3 Utility 5 Gain[0]=1.6666666666666667
1 Weight 5 Utility 3 Gain[1]=0.6
3 Weight 4 Utility 12 Gain[3]=3.0
4 Weight 7 Utility 5 Gain[4]=0.7142857142857143

9.3 Greedy algorithms: Heuristics for guaranteed approximations
205
5 Weight 3 Utility 7 Gain[5]=2.3333333333333335
7 Weight 3 Utility 2 Gain[7]=0.6666666666666666
8 Weight 5 Utility 3 Gain[8]=0.6
9 Weight 7 Utility 6 Gain[9]=0.8571428571428571
Selected object 3, updating #weights=8 #utility=29
0 Weight 3 Utility 5 Gain[0]=1.6666666666666667
1 Weight 5 Utility 3 Gain[1]=0.6
4 Weight 7 Utility 5 Gain[4]=0.7142857142857143
5 Weight 3 Utility 7 Gain[5]=2.3333333333333335
7 Weight 3 Utility 2 Gain[7]=0.6666666666666666
8 Weight 5 Utility 3 Gain[8]=0.6
9 Weight 7 Utility 6 Gain[9]=0.8571428571428571
Selected object 5, updating #weights=11 #utility=36
0 Weight 3 Utility 5 Gain[0]=1.6666666666666667
1 Weight 5 Utility 3 Gain[1]=0.6
4 Weight 7 Utility 5 Gain[4]=0.7142857142857143
7 Weight 3 Utility 2 Gain[7]=0.6666666666666666
8 Weight 5 Utility 3 Gain[8]=0.6
9 Weight 7 Utility 6 Gain[9]=0.8571428571428571
Selected object 0, updating #weights=14 #utility=41
1 Weight 5 Utility 3 Gain[1]=0.6
7 Weight 3 Utility 2 Gain[7]=0.6666666666666666
8 Weight 5 Utility 3 Gain[8]=0.6
Selected object 7, updating #weights=17 #utility=43
Here, the maximum utility reported for the input data set is 43. Let c∗denote
the best overall utility of an optimal solution and cG be the overall utility
reported by the greedy algorithm. Then Dantzig proved in 1957 that cG ≥c∗
2
(of course cG ≥c∗since an approximation can only be worse than an exact
solution). For the 0-1 knapsack problem, we say that greedy approximation
has an approximation factor of 2. Although the greedy heuristic proceeds by
greedily choosing the current best element and reiterating until completion, its
performance factor may vary according to the problem at hand. The following
set cover problem explained in the next section illustrates this important fact.
9.3.2 A greedy algorithm for solving set cover problems
The set cover problem (SCP for short) is yet another fundamental combinatorial
optimization problem that arises in many real-world applications. The problem
is deﬁned as follows; We are given a set X of n elements X = {X1, ..., Xn} and
a collection S of m subsets of X: S = {S1, ..., Sm} called ranges. The goal is to
select a minimum number of sets of S so that their union covers all elements
of X. That is, we are asked to solve the following mathematical optimization
problem:

206
9. Paradigms for Optimization Problems
min
I⊆{1,...,n} |I|
(9.3)
such that

i∈I
Si = X.
(9.4)
In the literature, the input pair (X, S) is called a range space.
(a)
X1
X2
X3
X4
X5
X6
X7
X8
X9
X10
X11
X12
S1
S2
S3
S4
S5
S6
S7
(b)
X1
X2
X3
X4
X5
X6
X7
X8
X9
X10
X11
X12
S3
S4
S7
Figure
9.3
Example
of
an
instance
of
a
set
cover
problem:
(a)
input
range
space:
set
X
=
{X1, ..., X12}
of
12
elements
and
a
collection S = {{X1, X2}, {X5, X6}, {X9, X10}, {X2, X8}, {X6, X7, X10, X11},
{X1, X2, X3, X5, X9, X10, X11}, {X3, X4, X7, X8, X11, X12}} of 7 subsets, and
(b) optimal covering of size 3 since elements X1, X4 and X6 are covered once
by a diﬀerent subset
As a real-world application of SCP, consider X denoting all grid elements of a
digital terrain, and Si denoting the grid cell covered by the ith base transceiver
station. In the telecommunication industry, the goal is to minimize the number
of selected base transceiver stations so that we can fully cover all grid cells
(that is, deserve set X). In practice, the problem is relaxed to the partial SCP
by requiring only a fraction of grid cells to be covered, and associating various
costs to selecting this or that base transceiver station. But this does not change
in any way the essence of the SCP. Figure 9.4 displays the result of solving a
(partial) set cover problem for this telecommunication problem on an urban
city scene.
Once again, the greedy heuristic previously sketched yields a simple optimiza-
tion algorithm for ﬁnding a covering: We choose the range of S that covers the
most number of elements of X, remove the covered elements from both X and
all subsets S, and reiterate until none of the grid elements remain. This greedy

9.3 Greedy algorithms: Heuristics for guaranteed approximations
207
Figure 9.4
Set cover problem for urban radio network planning of mobile
phones: (a) Covering of 99 base transceiver stations, and (b) covering using
only 19 base stations. Here, some redundant areas covered more than four
times
algorithm does not yield an optimal solution but guarantees an approximation
solution. Let c∗= |I∗| be the size of any optimal solution,2 and c = |IG| denote
the size of the solution reported by this greedy strategy. Then we have the
following bounds:
c∗≤cG ≤c∗(1 + log n).
To implement the greedy algorithm for the set cover problem, we ﬁrst need
to organize the data-structures for coding the range space (X, S). We choose
to represent subsets of X using a boolean incidence matrix B. Matrix element
B[i, j] is set to true if and only if element Xj belongs to set Si. The ranges are
therefore encoded in the matrix rows while columns depict element membership
in respective ranges. The basic code for creating and initializing an instance of
a set cover problem is given in the following class SetCover.
Program 9.10
Initializing a set cover problem
class
SetCover
{
int
nbelements ;
int
nbsubsets ;
boolean
[ ] [ ]
incidenceMatrix ;
SetCover ( int nn ,
int mm)
{
this . nbelements=nn ;
this . nbsubsets=mm;
incidenceMatrix=new boolean [ nbsubsets ] [ nbelements ] ;
2 Note that several solutions of same size may exist.
(a)
(b)

208
9. Paradigms for Optimization Problems
for ( int
i =0; i<nbsubsets ; i++)
for ( int
j =0; j<nbelements ; j++)
incidenceMatrix [ i ] [ j ]= false ;
}
void SetSubsets ( int
[ ]
[ ]
array )
{
for ( int
j =0; j<array . length ; j++)
{
for ( int
i =0; i<array [ j ] . length ; i++)
incidenceMatrix [ j ] [ array [ j ] [ i ]]= true ;
}
}
void Display ()
{
for ( int
i =0; i<nbsubsets ; i++){
for ( int
j =0; j<nbelements ; j++)
i f
( incidenceMatrix [ i ] [ j ] )
System . out . print ( "1" ) ;
else System . out . print ( "0" ) ;
System . out . p r i n t l n ( "" ) ;
}
}
}
The greedy algorithm described above needs:
1. To ﬁnd the set covering the greatest number of (not yet covered) elements,
2. To update the boolean incidence matrix once a maximal set of S has been
chosen.
We implement these basic operations by inserting the following code in the
body of class SetCover.
Program 9.11
Basic operations for supporting the greedy algorithm
// Number of covered element by subset i
int Cover ( int
i )
{
int nbEl=0;
for ( int
j =0; j<nbelements ; j++)
i f
( incidenceMatrix [ i ] [ j ] ) ++nbEl ;
return nbEl ;
}
// Report the current largest subset
int
LargestSubset ()
{
int
i ,
nbel , max,
s e l e c t ;
max=−1; s e l e c t =−1;
for ( i =0; i<nbsubsets ; i++)
{
nbel=Cover ( i ) ;
i f
( nbel>max) {max=nbel ;
s e l e c t=i ;}

9.3 Greedy algorithms: Heuristics for guaranteed approximations
209
}
return
s e l e c t ;
}
// Update the incidence matrix
void Update ( int
s e l )
{
int
i , j ;
for ( i =0; i<nbsubsets ; i++)
{
i f
( i != s e l )
{
for ( j =0; j<nbelements ; j++)
i f
( incidenceMatrix [ s e l ] [ j ] )
incidenceMatrix [ i ] [ j ]= false ;
}
}
for ( j =0; j<nbelements ; j++)
incidenceMatrix [ s e l ] [ j ]= false ;
}
An initial set cover problem is created by building a new object of type SetCover,
as follows:
Program 9.12
Creating an instance of a set cover problem
int
[ ]
[ ]
subsets
={{0 ,1 ,3} ,{2 ,3 ,4} ,
{0 ,2 ,5} ,{1 ,2 ,4} ,{3 ,4 ,5} ,{0 ,2}};
SetCover
setcover=new SetCover (6 ,6) ;
setcover . SetSubsets ( subsets ) ;
System . out . p r i n t l n ( "Set cover problem:" ) ;
setcover . Display () ;
Finally, The greedy set cover algorithm is concisely written as follows:
Program 9.13
Greedy algorithm for solving SCPs
static boolean
[ ]
GreedySCP( SetCover problem )
{
boolean
[ ]
r e s u l t=new boolean [ problem . nbsubsets ] ;
int
cover =0;
int
s e l e c t ;
for ( int
i =0; i<problem . nbsubsets ; i++)
r e s u l t [ i ]= false ;
while ( cover !=problem . nbelements )
{
// Choose largest not -yet covered subset
s e l e c t=problem . LargestSubset () ;
r e s u l t [ s e l e c t ]=true ;
// Update covered matrix
cover+=problem . Cover ( s e l e c t ) ;

210
9. Paradigms for Optimization Problems
// Update incidence matrix
problem . Update ( s e l e c t ) ;
System . out . p r i n t l n ( "Selected "+s e l e c t+" Number of covered
elements="+cover ) ;
problem . Display () ;
}
return
r e s u l t ;
}
Set cover problem:
110100
001110
101001
011010
000111
101000
Selected 0 Number of covered elements=3
000000
001010
001001
001010
000011
001000
Selected 1 Number of covered elements=5
000000
000000
000001
000000
000001
000000
Selected 2 Number of covered elements=6
000000
000000
000000
000000
000000
000000
Solution: 0 1 2
To see that a greedy algorithm yields a O(log n) approximation factor, consider
the SCP described in Figure 9.5. The two long subsets fully cover all elements,
but the greedy heuristic will pick up the rightmost largest subset of 8 elements,
and then the remaining largest subset of 4 elements, etc., until it picks the last
subset of two elements. This instance is plugged into the program by replacing
the former subsets array by:
int
[ ]
[ ]
subsets ={{0 ,1 ,2 ,3 ,4 ,5 ,6} ,{7 ,8 ,9 ,10 ,11 ,12 ,13} ,
{0 ,7} ,{1 ,2 ,8 ,9} ,{3 ,4 ,5 ,6 ,10 ,11 ,12 ,13}};
SetCover
setcover=new SetCover (14 ,5) ;

9.4 Dynamic programming: Optimal solution for the 0-1 knapsack problem
211
For this well-designed example, we have c∗= 2 but cG = log n
2 , showing the
upper bound of O(log n) approximation factor. Note that this approximation
factor depends on n, the problem size. Remember that the 0-1 knapsack the
same greedy heuristic yielded a constant approximation factor.
Figure 9.5
A bad instance for which the greedy set cover heuristic poorly
behaves. This generic construction yields an approximation factor of O(log n)
Although that we have noticed that the greedy set cover heuristic yields only
a O(log n) competitive ratio, it is striking to know that no other algorithm can
beat this simple heuristic provided that some problem complexity property
holds in computer science, related to the famous P ̸= NP? conjecture.
9.4 Dynamic programming: Optimal solution
for the 0-1 knapsack problem
To close this chapter on programming various combinatorial optimization
algorithms in Java, we will revisit the 0-1 knapsack problem. This time, we are
looking for an exact solution (not the constant factor approximation solution
we obtained from the greedy algorithm) without performing the prohibitive
exhaustive search. The conceptual idea to make this possible is to come up
with a mathematical recurrence relation that can then be used to incrementally
build a bi-dimensional table from which we can retrieve the solution. Loosely
speaking, the 2D table will store3 intermediate solutions. Consider u(i, j) the
utility function deﬁned by selecting items among the ﬁrst i objects with
an overall weight constraint of j units. The recurrence relation is found as
follows:
– u(1, w) = 0 if w < W1 (not enough room to put O1 in the sack) and u(1, w) =
U1 whenever w ≥W1.
3 Eventually, only a subset of the table may be computed by a process called
memoization in dynamic programming.

212
9. Paradigms for Optimization Problems
– At u(i, j) either we did not select the i-th element and then u(i, j) = u(i −
1, j), or we selected it and then we need to know the utility of u(i−1, j −Wi)
to compute the total utility Ui + u(i −1, j −Wi).
Thus we get the key recurrence relation:
u(i, j) =
 u(i, j) = 0 for j < W1, and u(i, j) = U1 for j ≥W1,
i = 1
u(i, j) = max{u(i −1, j) + u(i −1, i −Wi) + Ui},
i > 1.
(9.5)
Solving the knapsack problem by using dynamic programming consists of
building a 2D table of size n × (W + 1) (starting at weight 0) as follows:
Program 9.14
Dynamic programming for solving the 0-1 knapsack
static void SolveDP ()
{
int
i , j ;
array=new int [ nbObjects ] [ weightmax +1];
// initialize the first row
for ( j =0; j<=weightmax ; j++)
i f
( j<weight [ 0 ] )
array [ 0 ] [ j ]=0;
else
array [ 0 ] [ j ]= u t i l i t y [ 0 ] ;
// for all other rows
for ( i =1; i<nbObjects ; i++)
{
for ( j =0; j<=weightmax ; j++)
i f
( j−weight [ i ] <0)
array [ i ] [ j ]= array [ i −1][ j ] ;
else
array [ i ] [ j ]=max(
array [ i −1][ j ] ,
array [ i −1][ j−weight [ i ]]+ u t i l i t y [ i ] ) ;
}
}
The result of the optimization reads at the bottommost right cell of this array:
u(n, W). To illustrate this algorithm, consider the following input:
static
int
nbObjects =8;
static
int
[ ]
weight ={2 ,3 ,5 ,2 ,4 ,6 ,3 ,1};
static
int
[ ]
u t i l i t y ={5 ,8 ,14 ,6 ,13 ,17 ,10 ,4};
static
int weightmax=12;
static
int
[ ]
[ ]
array ;
Then procedure SolveDP builds and gets the table of u(i, j) evaluations (see
Table 9.1).
We now retrieve the solution from the table by beginning from the bottom
right cell: here, a maximum utility score of 38 for i = n = 8. If u(i, j) has the
same score as the precedent row u(i −1, j) then we deduce that object Oi was
not chosen. Otherwise, that means that we chose object Oi. Starting from the

9.4 Dynamic programming: Optimal solution for the 0-1 knapsack problem
213
Object Weight
0
1
2
3
4
5
6
7
8
9
10
11
12
u(i, j)
1
0
0
5
5
5
5
5
5
5
5
5
5
5
2
0
0
5
8
8
13
13
13
13
13
13
13
13
3
0
0
5
8
8
14
14
19
22
22
27
27
27
4
0
0
6
8
11
14
14
20
22
25
28
28
33
5
0
0
6
8
13
14
19
21
24
27
28
33
35
6
0
0
6
8
13
14
19
21
24
27
30
33
36
7
0
0
6
10
13
16
19
23
24
29
31
34
37
8
0
4
6
10
14
17
20
23
27
29
33
35
38
Table 9.1
Table of u(i, j) evaluations
last row, we thus deduce that we chose O8 because 37 ̸= 38; We now jump to
u(i −1, j −W8) and proceed similarly until we reach the ﬁrst row.
The code for retrieving the solution from the 2D table by reading backward is
thus:
Program 9.15
Extracting backward the optimal solution from the 2D table
static void InterpretArray ()
{
int
i , u ,w;
u=0;
w=weightmax ;
for ( i=nbObjects −1; i >=1;i −−)
{
i f
( array [ i ] [ w]!= array [ i −1][w] )
{System . out . print (( i +1)+" " ) ;
w=w−weight [ i ] ;
u=u+u t i l i t y [ i ] ;
}
}
i f
( array [ 0 ] [ w]!=0) ;
{System . out . p r i n t l n ( "1" ) ;
w=w−weight [ 0 ] ;
u=u+u t i l i t y [ 0 ] ;
}
System . out . p r i n t l n ( "Cross check:"+u+" remaining weight "+w) ;
}
Running this procedure on our toy example, we get:
Reading solution:
8 7 5 4 1

214
9. Paradigms for Optimization Problems
Cross check:38 remaining weight 0
We interpret the procedure extracting the result by manually running procedure
InterpretArray() in Table 9.2.
9.5 Optimization paradigms: Overview of
complexity analysis
In this chapter, we have presented four basic combinatorial optimization
problems:
1. plain knapsack ﬁlling problem,
2. eight queen puzzle,
3. set cover problem,
4. maximal utility knapsack problem.
For solving these tasks, we have considered heuristics for ﬁnding either an exact
or an approximation of the optimal solution. The properties of these generic
algorithms are quickly summarized below:
Exhaustive search. Explore the full conﬁguration space using a simple recursive
procedure, which usually requires exponential time for enumerating all
potential solutions.
Backtracking. Structure the space of a potential solution and incrementally
build the solution until we reach a dead end. Then backtrack by changing
the conﬁguration of previous states. Complexity does not asymptotically
change; it is still exponential in the worst case.
Greedy algorithm. Construct the solution iteratively by choosing at each step
the current best set. Greedy heuristics are polynomial in the input size.
The greedy SCP algorithm takes cubic time.
Dynamic programing. Build a table from a recurrence relation and extract the
solution by reading the table backward. The complexity is polynomial (that
is, requires O(Wn) time and space) if we consider W as a parameter.
Dynamic programming faces limitations when W is too large. We then
prefer to solve it using the constant 2-approximation greedy algorithm.
Finally, let us stress that even if the greedy heuristic seems a bit naive, computer
scientists do not have better algorithms on hand. Finding a better algorithm
is actually one of the hottest, if not the most challenging, open problem in

9.5 Optimization paradigms: Overview of complexity analysis
215
u(i, j)
0
1
2
3
4
5
6
7
8
9
10
11
12
Interpretation
1
0
0
5
5
5
5
5
5
5
5
5
5
5
O1 (u = 38, w = 0)
2
0
0
5
8
8
13
13
13
13
13
13
13
13
5 = 5 ⇒¬O2
3
0
0
5
8
8
14
14
19
22
22
27
27
27
5 = 5 ⇒¬O3
4
0
0
6
8
11
14
14
20
22
25
28
28
33
11 ̸= 8 ⇒O4 (u = 33, w = 2)
5
0
0
6
8
13
14
19
21
24
27
28
33
35
24 ̸= 22 ⇒O5 (u = 27, w = 4)
6
0
0
6
8
13
14
19
21
24
27
30
33
36
24 = 24 ⇒¬O6
7
0
0
6
10
13
16
19
23
24
29
31
34
37
34 ̸= 33 ⇒O7 (u = 14, w = 8)
8
0
4
6
10
14
17
20
23
27
29
33
35
38
38 ̸= 37 ⇒O8 (u = 4, w = 11)
Read back the table, starting at position u(8, 12)
(u=0, w=12)
Table 9.2
Extracting the solution from the dynamic programming table. Oi and ¬Oi meaning that we selected/did not
select object Oi, respectively

216
9. Paradigms for Optimization Problems
computer science related to the P ̸= NP? conjecture. Solving this conjecture
is one of the seven key challenges proposed by the Clay Mathematics Institute4
in its Millenium problem collection, with a rewarding of one million dollars.
9.6 Exercices
Exercise 9.1 (Binomial coeﬃcients and Pascal triangles)
The choose function
Cn,k =
 n
k

is the number of diﬀerent ways one can choose k objects among a set of
n objects. We have
 n
k

=
n!
(n −k)!k!
for 0 ≤k ≤n, where x! denotes the factorial of integer x. Binomial
coeﬃcients arise naturally in the polynomial expansion of
(x + 1)n =
n

k=0
 n
k

xk.
Scholar Blaise Pascal (1623-1662) used the following recurrence relation:
– Cn,k = Cn−1,k−1 + Cn−1,k, and
– Cn,n = Cn,0 = 1 (terminal states)
to compute coeﬃcients Cn,k in a triangle shape depicted as below for
n = 5. Rows are indexed by n, and columns by k ≤n.
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
– Give a plain recursive function for computing the Cn,k coeﬃcients,
and use that procedure to compute the Pascal triangle.
– Try running the program with n = 35. What happens? Please explain.
4 http://www.claymath.org/millennium/P_vs_NP/

9.6 Exercices
217
– Write a function public static int[] createNextLine(int[] line ) that takes
as a parameter a reference to an array of integers storing the values of
Cn−1,∗and returns a reference to a new array of integers containing
the values Cn,∗. Write a program for displaying the Pascal triangle of
size 35 with this method. What happens? Please explain and compare
with the fully recursive program. Deduce a simple program to display
Pascal triangles of any order.
Exercise 9.2 (Fibonacci sequences)
Fibonacci sequences are deﬁned by the recurrence relation F(n) = F(n−
1) + F(n −2) for n ≥2 and F(0) = 0, F(1) = 1, otherwise.
– Give a recursive function for computing arbitrary F(n).
– Using the memoization technique, create a static array static long[]
memo;, and procedures for ﬁlling the array and computing (returning)
a member of the sequence. What happens as n grows?
There exits a fast exponentiation method to compute Fibonacci numbers.
Indeed, prove that
 F(n + 1)
F(n)
F(n)
F(n −1)

=
 1
1
1
0
n
.
It follows that
 F(n + 1)
F(n)
F(n)
F(n −1)
2
=
 1 1
1 0
2n
=
 F(2n + 1)
F(2n)
F(2n)
F(2n −1)

.
Deduce that F(2n) = F(n) × (F(n) + 2F(n −1)) and F(2n −1) =
F(n)2 + F(n −1)2. Thus if n is even, then F(n) and F(n −1) can be
obtained directly from F(n/2) and F(n/2 −1). Similarly, if n is odd,
then we get F(n −1) and F(n −2), and F(n) is computed as the sum of
F(n −1) + F(n −2). Implement this algorithm using BigInteger number
instead of int to circumvent numerical problems.
Exercise 9.3 (Hitting set problem)
We are given a range space (X, R) of |X| = n elements X1, ..., Xn and
|R| = m subsets R1, ..., Rm. We are asked to ﬁnd a hitting set, that is a
subset X ′ ⊆X of elements so that each range Ri contains at least one
element of X ′.
– Design a greedy algorithm to ﬁnd a not too large hitting set.
– Show that hitting set problems are dual to set cover problems by
reversing the inclusion order. Show that the duality consists merely in
transposing the incidence matrix.

218
9. Paradigms for Optimization Problems
Exercise 9.4 (Discriminating set problem)
Given a range space (X, R) of |X| = n elements X1, ..., Xn and |R| = m
subsets R1, ..., Rm, we would like to ﬁnd a discriminating set X ′ ⊆X
such that ∀i, j, i ̸= jRi ∩X ′ ̸= Rj ∩X ′.
– Prove that ﬁnding a minimum size discriminating set X ′ amounts
to solving a hitting set problem for the set of pairwise symmetric
diﬀerences Ri△Rj = Ri\Rj ∪Rj\Ri. Design a greedy algorithm
for ﬁnding a not too large discriminating set. Deduce that memory
requirement is quadratic.
– Instead of explicitly computing the full set of symmetric diﬀerences of
ranges, design an algorithm that solves the hitting set problem using
only linear memory (but more time).

10
The Science of Computing
10.1 The digital world
During the last three decades (1978–2008), we have witnessed worldwide an
unprecedented revolution: the venue of the digital world. Nowadays there is no
doubt that digital music players or digital cameras have replaced their analog
counterparts forever (or at least until the next paradigm shift). But what are
the beneﬁts of this analog-to-digital wave since the industry is still working
hard to reach the recording/rendering qualities of some prior analog devices.
The ﬁrst merit of the digital world is to dissociate contents from its support.
Once digitized contents are all binary strings of zeros and ones, this “binariza-
tion” process harmonizes all former kinds of contents (books, musics, pictures
an videos) into a universal representation: strings of bits.
The second merit of this digital revolution is that there is a universal player:
the “computer.” Indeed, although there are a lot of dedicated devices in the
consumer electronic industry optimized for reading such or such a kind of
digital content, a “computer” can read/interpret and render appropriately all
these digitized contents. That is, the computer became the universal device.
Figure 10.1 illustrates this wave of universal content/universal players.
This raises the unsolved question of deﬁning what information is. A key
advantage of binarizing all contents is that we have at our disposal generic
algorithms for handling these binary strings that can be used whatever the
type of contents. Namely, we can indiﬀerently:
F. Nielsen, A Concise and Practical Introduction to Programming Algorithms in Java,
Undergraduate Topics in Computer Science, DOI 10.1007/978-1-84882-339-6 10,
c⃝Springer-Verlag London Limited, 2009

220
10. The Science of Computing
Figure 10.1
In the digital world, all kinds of content is represented using
universal binary strings. Furthermore, all this content can be appropriately
rendered using a universal computer. Nevertheless, for the consumer, industry
proposes many tailored devices
– copy,
– compress,
– transmit,
– archive,
– ...
binary strings without knowing, say, that it is a music binary string or a
book binary string. Figure 10.2 illustrates this powerful property of generic
algorithms that act on all kinds of digitalized contents.
One of the frequent questions to ask is why humans calculate using decimal
numbers using digits in {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} but computers only use bits,
digits in {0, 1}. The answer is whatever base you choose, provided that it has
at least two digits, you will get the same order of power to express compactly
numbers. Indeed, unary numeral systems require a linear number of signs to
express a number, while binary numeral systems only use log n of them. In other
words, the binary numeral system is exponentially more powerful at compacting
numbers than the unary numeral system.
In summary the digital world brought us these four advantages over the analog
world:

10.2 Nature of computing?
221
– Universal content representation: binary strings.
– Universal rendering device: the computer.
– Generic (universal) algorithms.
– Universal binary base representation.
Figure 10.2
Once the content is available as a binary string we can apply
generic algorithms such as copying, compressing, transmitting or archiving it
without having to know, say, that it is a music or book string
10.2 Nature of computing?
Deﬁning computing, ﬁnding its limitations and pondering whether nature is
doing computing of some sort are puzzling questions. In 1953, James Watson
and Francis Crick discovered the double-helix structure of DNA that encodes
genes. They received the Nobel Prize for this spectacular discovery. The
mechanism of DNA replication is well understood nowadays, and it is striking to
see that in genetics, DNA sequences are copied, transmitted and archived using
the same process carried out by the ribosome units. Historically speaking, it
was ﬁrst envisioned by Erwin Schroedinger1 in his remarkable essay “What
is life?” [5] published in 1944 that there should exist some “crystal” for
transmitting information from cells to cells. This “crystal” revealed itself a
decade later as the DNA.
1 Another winner of the Nobel prize in 1933.

222
10. The Science of Computing
10.3 The digital equation
Mark Weiser envisioned the era of ubiquitous computing, where computing
devices are omnipresent. We are experiencing more and more this life style
with the Internet and current cell phones. How is it that even if content was
binarized that computing became ubiquitous?
This is because of the digital equation:
Digital = Binary + Calculation
Indeed, consider pictures to illustrate this equation. At ﬁrst, pictures were
analog. We then digitized them into binary strings using various devices like
photo scanners. But nowadays, we are yet a stage beyond: We have entered
the era of computational photography. That is, photos are computed. You can
buy digital cameras that implement smile shutter or other functionalities that
could not exist in the analog era. The digital equation opened up a completely
unknown world. There is a novel momentum of the media: What is a (digital)
photo and how can we (computationally) capture/manipulate and share them?
Computing not only allows us to experience novel experiences with former
media, it also allows us to create brand new media that were quite unthinkable
in the analog world. For example, within a couple a decades our ﬂat TV will
certainly be for sure replaced by a networked 3D holographic display. This will
be possible not only because of hardware progress but also because a brand new
type of media will be captured and processed: geometry. To simplify, we may
say that the ﬁrst media era was sound (1970’s). Then came images (1980’s) and
videos (1990’s). The 21st century (2000) with the rise of geometry processing
will be about geometries (improperly called 3D videos). And who knows, this
digital equation could also be one of the hidden laws of Nature.
10.4 Birth of algorithms and computers
The birth of algorithms is allegedly credited to Al-Khwarizmi (790-840), a
Persian scholar working in the scientiﬁcally ﬂourishing city of Bagdad. Al-
Khwarizmi wrote important scientiﬁc treaties and is considered one of the
fathers of algebra (Al jabr). The word “algorithm” stems from the latinization
of “Algorithmi.” Indeed, Al-Khwarizmi was concerned with providing his
readers with generic pipelines to solve for solutions of quadratic equations.
A common misunderstanding is to associate computer science necessarily with
computers. Computer science is not about programming personal computers.
The diﬀerence engine, conceived by Charles Babbage in 1822, is one of the very

10.5 Computer science in the 21st century
223
ﬁrst computers. It was only physically built much later on. We refer to the
textbook of Cormen et al. [1] for a nice introductory overview of algorithms.
We emphasize that:
Computers = Computing Machineries
10.5 Computer science in the 21st century
Nowadays, computers (and computing) are omnipresent. The envisioned
ubiquitous computing of Mark Weiser (Xerox Parc chief scientist) is here.
Computers are abundant and versatile. They are abundant because we probably
carry dozens of CPUs without being conscious of them (cell phones, cameras,
music players, etc.). Furthermore, computing is impacting all traditional
sciences. It is now common to speak of computational sciences. For example,
biology is evolving as systems biology which allows researchers to perform a
rich set of simulation-prediction-experiences (and ﬁnally cross-validate these
numerical simulations in wet labs.
The science of computing is Computer Science (CS): Computer science raises
deep theoretical questions. We recommend the Harel’s book [3]: “Computers
Ltd.: What They Really Can’t Do.” Computer science also brings important
novel technologies. For example, in medical imaging a novel imaging technique
is called diﬀusion tensor magnetic resonance imagery, or DT-MRI. Computing
will deﬁnitively participate in the integration science of the 21st century.

11
Exam & Solution
The 2-hour exam below gives an overall review of the main concepts of
programming in Java. The four independent exercises are given with their
corresponding solutions.
Solution 11.1 (Mysterious recursive function)
– Consider the following program which compiles without any error:
public
class
MysteriousProgram {
public
static void
display ( int [ ]
tab ) {
for
( int
i = 0;
i < tab . length ;
i++)
System . out . print ( tab [ i ] + " " ) ;
System . out . p r i n t l n () ;
}
public
static void swap2 ( int a ,
int b) {
int tmp = a ;
a = b ;
b = tmp ;
}
public
static void swap3 ( int [ ]
tab ,
int
i ,
int
j ) {
int tmp = tab [ i ] ;
tab [ i ] = tab [ j ] ;
tab [ j ] = tmp ;
}
public
static void mysterious ( int [ ]
tab ,
int k) {
for
( int
j = k ;
j < tab . length ;
j++) {
swap3 ( tab ,
k ,
j ) ;
display ( tab ) ;
swap3 ( tab ,
k ,
j ) ;
}
}
F. Nielsen, A Concise and Practical Introduction to Programming Algorithms in Java,
Undergraduate Topics in Computer Science, DOI 10.1007/978-1-84882-339-6 11,
c⃝Springer-Verlag London Limited, 2009

228
11. Exam & Solution
public
static void mysteriousRecursive ( int [ ]
tab ,
int k) {
i f
(k == tab . length −1)
display ( tab ) ;
for
( int
j = k ;
j < tab . length ;
j++) {
swap3 ( tab ,
k ,
j ) ;
mysteriousRecursive ( tab ,
k + 1) ;
swap3 ( tab ,
k ,
j ) ;
}
}
public
static void
i n i t ( int [ ]
tab ) {
for
( int
i = 0;
i < tab . length ;
i++)
tab [ i ] = i + 1;
}
public
static void main ( String [ ]
args ) {
int n = Integer . parseInt ( args [ 0 ] ) ;
int [ ]
t = new int [ n ] ;
i n i t ( t ) ;
swap2 ( t [ 0 ] ,
t [ n −1 ] ) ;
mysterious ( t ,
0) ;
//
mysteriousRecursive(t, 0);
}
}
Once this code compiled, what is the result displayed in the console
output by invoking java MysteriousProgram 4? Describe explicitly the
program execution steps and its outcome for the general case (for any
given n > 0)
SOLUTION:
For n = 4, the program displays the following output:
1 2 3 4
2 1 3 4
3 2 1 4
4 2 3 1
Function init ﬁlls array t that is given by reference with values
ranging from 1 to n. Function swap2 performs a permutation on the
copied values of two array cells, and thus does not modify the original
array cells since it works with copies. The array contents order is
therefore preserved. In the mysterious function, the value of k does
not change and denote a cell array. Here, we use function swap3 that
allows one to exchange the contents of two array cells. At the ﬁrst loop
round, we exchange an array cell with itself. Then, we successively
exchange the contents of the cell with the contents of the following

11. Exam & Solution
229
cells, we display the array, and perform again a permutation to leave
the cells as before. Here, k = 0 and all values are successively put
in ﬁrst position. Notice that when the mysterious function ends, the
array order is thus reset to the original order.
– In the function main, we now replace the function call mysterious(t, 0);
by mysteriousRecursive(t, 0);.
After having recompiled the program, what is the console result
obtained by launching java MysteriousProgram 3?
Describe precisely the program execution steps and the obtained result
in general case (any given n > 0 )
SOLUTION:
For n = 3, calling mysteriousRecursive(t, 0); yields the following
output:
1 2 3
1 3 2
2 1 3
2 3 1
3 2 1
3 1 2
The program displays all permutations of the array. Remark: The
recursion always terminates since the body of the for loop is executed
only for k > tab.length-1. Proof goes by induction.
Solution 11.2 (Modeling molecules)
In this exercise, we are ﬁrst concerned with modeling molecules as arrays
of atoms, where each atom is deﬁned as a proper 3D sphere with a center
and a radius (the Van der Waals radius). We will then study how to
detect whether atoms and molecules collide or not.
– Design a class Point3D where each object is deﬁned as a 3D point
with coordinates x, y and z, all of type double. Further, provide this
class with a constructor Point3D(double x0, double y0, double z0)
that allows us to initialize a Point3D object.
– Write a static function double distance(Point3D p, Point3D q) that
takes as arguments two points p and q, and returns the Euclidean
distance ∥q −p∥between them. In order to compute the square func-
tion, we will use static double sqr(double x){ return x∗x; }, which is
also inserted inside the class Point3D.
To compute the square root, we’ll use function
static double
sqrt(double x) of the Math class.

230
11. Exam & Solution
– Give a static function Point3D add(Point3D p, Point3D q) that takes as
arguments two points p and q, and return a new point equal to p + q.
This function shall be inserted inside class Point3D.
– Give a static function void scale(Point3D p, double k) that multiplies
the coordinates of point p by scalar number k. That is, p becomes k.p.
This function shall be located inside class Point3D as well.
SOLUTION:
Program 11.1
The class Point3D
public
class
Point3D {
double x ,
y ,
z ;
public Point3D ( double x0
, double y0
, double z0 ) {
this
. x = x0 ;
this
. y = y0 ;
this
. z = z0 ;
}
static double sqr
( double x) { return x∗x ;
}
public
static double distance
( Point3D p ,
Point3D q)
{
return Math .
sqrt
( sqr
(q . x −p . x) + sqr
(q . y −p . y)
+ sqr (q . z −p . z ) ) ;
}
public
static
Point3D add ( Point3D p ,
Point3D q) {
return new Point3D (p . x + q . x ,
p . y + q . y ,
p . z + q . z ) ;
}
public
static void
s c a l e
( Point3D p ,
double k) {
p . x ∗= k ;
p . y ∗= k ;
p . z ∗= k ;
}
}
– Give a class Atom that allows us to deﬁne atoms with two object
ﬁelds:
– center of type Point3D denoting the location (x, y, z) of the center of
this atom, and
– radius of type double that encodes the radius of this atom.
Provide
a
constructor
Atom(double x, double y, double z, double
rad) to this class that initialize objects of this type.
Further, add to this class two constants
H RADIUS = 1.2 and
O RADIUS = 1.5 that represent the radii in˚angstr¨om for the hydrogen
and oxygen atoms, respectively.

11. Exam & Solution
231
– Write a static function boolean bump(Atom a, Atom b) that takes as
arguments two atoms a and b, and return true if and only if the
distance between their centers is strictly less than the sum of their
radii (this will represent a collision between two atoms). This function
shall be deﬁned inside the class Atom.
SOLUTION:
Program 11.2
Class Atom with the bump predicate
public
class Atom {
Point3D
center
;
double radius
;
public
static
final double H RADIUS = 1 . 2 ;
public
static
final double O RADIUS = 1 . 5 ;
public Atom ( double x ,
double y ,
double z ,
double rad
) {
this
.
center = new Point3D (x ,
y ,
z ) ;
this
.
radius = rad
;
}
public
static boolean bump ( Atom a , Atom b) {
return Point3D
.
distance
( a . center
, b .
center
)
< a .
radius + b .
radius
;
}
} // Temporary class; Shall be enhanced next
– Write a class Molecule that allows us to deﬁne a 3D molecule as an
array of atoms, and provide the class with a constructor that takes as
argument a reference to this array.
SOLUTION:
Program 11.3
Class Molecule
public
class
Molecule {
Atom
[ ]
atoms
;
public
Molecule
( Atom
[ ]
t ) {
this
.
atoms = t ;
}
}
– Using a new class Test, write a program that builds a water molecule
H20 with its oxygen atom located at (0, 0.4, 0) and the two hydrogen
atoms located at (0.76, −0.19, 0) and (−0.76, −0.19, 0) (units still
being ˚angstr¨om).

232
11. Exam & Solution
SOLUTION:
Program 11.4
Test program for Molecule
public
class
Test {
public
static void main (
String
[ ]
args
) {
Atom o = new Atom (0 ,
0.4
,
0 , Atom . O RADIUS ) ;
Atom h1 = new Atom (0.76
,
−0.19
,
0 , Atom . H RADIUS
) ;
Atom h2 = new Atom (
−0.76
,
−0.19
,
0 , Atom .
H RADIUS ) ;
Atom
[ ] H2O = { o ,
h1
, h2
};
Molecule mol = new Molecule
(H2O ) ;
}
}
– For each molecule, we are now going to build an enclosing ball that
will allow one to speed up the test for detecting potential collisions.
To simplify, assume the center of that sphere is set as the centroid of
atoms (barycenter of uniform weight). That is, we do not take into
account respective masses. See ﬁgure as below. We shall use object
Atom to represent such an enclosing ball.
• are atom centers. ◦denote the centroid (barycenter with uniform
weight).
Plain circles denote Van der Walls of respective atoms.
The enclosing sphere of a water molecule.
– Write a static function middle that takes as its argument an array of
atoms (assume non-void) and that returns the centroid of these atoms.
This function shall be inserted in the Atom class, and will use functions
add and scale of class Point3D. This function shall not modify the atom
coordinates of the array.

11. Exam & Solution
233
SOLUTION:
Program 11.5
The centroid of an Atom object
public
static
Point3D middle
( Atom
[ ]
t ) {
Point3D middle = t
[ 0 ] .
center
;
for
( int
i = 1;
i < t .
length
; ++i )
middle = Point3D
. add ( middle
,
t [ i ] .
center
) ;
Point3D
.
s c a l e
( middle
,
1.0/
t .
length
) ;
return middle
;
}
– Write a static function double maxDistance(Point3D p, Atom a) that
returns the maximal distance between point p and any point on the
sphere of atom a. This function shall be attached inside class Atom.
SOLUTION:
public
static double maxDistance
( Point3D p , Atom a )
{
return Point3D
.
distance
(p ,
a .
center
) + a .
radius
;
}
– Describe now how to modify class Molecule for building its enclosing
sphere and using it for checking for collisions. Note that if we do not
intersect the enclosing ball of a molecule, it is not necessary to check
for collisions of its atoms.
Write a static function boolean bump(Atom a, Molecule b) of class
Molecule that allows us to check whether atom a is colliding with at
least one of the atoms of molecule b or not.
Write a static function boolean bump(Molecule a, Molecule b) that
extends this test to two molecules.
SOLUTION:
Program 11.6
The Molecule class equipped with the bump predicate
public
class
Molecule {
Atom
[ ]
atoms
;
Atom sphere
;
public
Molecule
( Atom
[ ]
t ) {
this
.
atoms = t ;
Point3D
center = Atom .
middle
( atoms ) ;
double r = 0;
for
( int
i = 0;
i < atoms
.
length
; ++i ) {
double
r i = Atom .
maxDistance
( center
, atoms
[ i ] ) ;
i f
( r < r i )
r = r i ;

234
11. Exam & Solution
}
this
.
sphere = new Atom (
center
. x ,
center
. y ,
center
. z ,
r ) ;
}
public
static boolean bump ( Atom a ,
Molecule b) {
i f
( ! Atom . bump (a ,
b .
sphere
) )
return
false
;
for
( int
i = 0;
i < b .
atoms
.
length
; ++i )
i f
( Atom . bump (a ,
b .
atoms
[ i ] ) )
return true
;
return
false
;
}
public
static boolean bump (
Molecule a ,
Molecule b) {
i f
( ! Atom . bump ( a .
sphere
, b .
sphere
) )
return
false
;
for
( int
i = 0;
i < a .
atoms
.
length
; ++i )
i f
( bump ( a .
atoms
[ i ] ,
b) )
return true
;
return
false
;
}
}
Solution 11.3 (Coding electrical signals)
We are interested in modeling binary electrical signals with values
ranging in {false, true} that only change a ﬁnite number of times. These
changes occur only at clock ticks. Thus these events can be modeled as
positive integers that encode the numbers of clock ticks since the starting
time (time origin).
Such a signal is deﬁned by its initial value v0, and a sequence of strictly
increasing transition states τ1, . . . , τn ∈N . In ] −∞, τ1[, the signal has
value v0. In [τ1, τ2[, the signal takes value v1 = ¬v0 (where ¬x denotes
the logical negate function of x, written as !x in Java). In [τ2, τ3[, the
signal value is v2 = ¬v1, and so on (with vn = ¬vn−1 in time range
[τn, +∞[). A constant signal shall be represented by its value v0 and an
empty sequence (n = 0).
For example, the depicted signal corresponds to the initial value false
and the following sequence of transitions: τ1 = 1, τ2 = 3, τ3 = 4.

11. Exam & Solution
235
false
true
t=0
t=3
t=4
t=1
In the remainder, we shall use the following data structure:
class
Transition
{
int
time ;
Transition
next ;
Transition ( int time ,
Transition
next ) {
this . time = time ;
this . next = next ;
}
}
class
Signal
{
boolean
i n i t i a l V a l u e ;
Transition
t r a n s i t i o n s ;
Signal ( boolean value ,
Transition
t r a n s i t i o n s ) {
this . i n i t i a l V a l u e = value ;
this . t r a n s i t i o n s = t r a n s i t i o n s ;
}
}
Field initialValue denotes the object value of type Signal at about −∞.
Field transitions denotes the beginning of the linked list of transition
events for this signal. If that ﬁeld is set to null, this means that the
signal is constant. Otherwise, ﬁelds time of successive elements of the
linked list indicate the respective values τ1, . . . , τn, with τ1 denoting the
head. We insist on the fact that the sequence τi is strictly increasing.
For example, we can create the signal depicted above as:
Signal
s i g n a l 1 = new Signal ( false ,
new Transition (1 , new Transition (3 , new Transition (4 ,
null ) ) ) ) ;
In the following questions, the functions shall be all located inside the
body of a class, whose name can be arbitrarily chosen.

236
11. Exam & Solution
– Given a signal s, we ﬁrst wish to invert it: that is, to obtain its logical
negation. For example, the invert of signal1 is:
false
true
t=0
t=3
t=4
t=1
Write a function static Signal invert(Signal s) performing this process.
Your function shall not modify the original signal. That is, you need
to create a new Signal. The time complexity of this function should
not depend on the length of the transition states in s.
– Given a signal s and time tick t, we want to compute s(t) that
is the value (true or false) of the signal s at time t. Write an it-
erative function static boolean valueAt(Signal s, int time) performing
this task. You shall not modify signal s, and the time complexity
should be proportional to the number of transition states in s.
– We would like a function that displays a signal as a sequence of
intervals with respective values. For example,
−i n f −> +i n f
:
false
means that the signal uniformly takes value false. For signal1, the
display function shall produce the output:
−i n f −> 1.0
:
false
1.0 −> 3.0
:
true
3.0 −> 4.0
:
false
4.0 −> +i n f
:
true
Write such an iterative function static void print(Signal s).
– Given a signal s, we would like to produce another signal identical
to s but shifted in time by a step δ > 0. That is, we want a signal
with the same initial value but with transition states (τ ′
i) deﬁned by
τ ′
i = τi + δ , ∀i ∈{1, . . . , n}.
To illustrate this operation, the shifted signal of signal1 with δ = 3
produces the following result:

11. Exam & Solution
237
false
true
t=3
t=4
t=6
t=7
– Write a recursive function
static Transition shift (Transition t, int delta) that shall return a new
list of transition states, identical to t but with values shifted by delta.
You shall not modify the original list t.
Then give a function static Signal shift (Signal s, int delta).
– A Signal object that does not have a strictly increasing sequence of
transition states is not correct. In order to detect program errors, it
is useful to have a function static boolean isWellFormed(Signal s) that
returns true if and only if s is correct.
Write a recursive function using an auxiliary function. Time com-
plexity shall be linear to the list length of transition events stored in
s.
– The commutable exclusive or operation (XOR for short) that takes
two operands is deﬁned by the following logic table:
XOR
false
true
false
false
true
true
true
false
That is, b1 XOR b2 is true if and only if b1 = ¬b2 . In Java, it can be
written as b1 != b2.
We now want to compute the output signal of the XOR of two input
signals. We notice that at a given time step, if only one signal changes
then the result changes, and if both signals change at a same time,
then the result does not change.
Write
a
function
static Transition xorTransitions(Transition t1,
Transition t2) that returns a new transition state list that corresponds
to the output. This function shall not modify the source list t1 and t2,
but in some cases, it is possible to share a sub-list. The time complexity
shall be linear to the length of both lists.

238
11. Exam & Solution
Write now a function static Signal xorSignals(Signal s1, Signal s2).
SOLUTION:
Program 11.7
The various functions acting on Signal objects
public
class
WorkingSignals {
public
static
Signal
invert ( Signal
s ) {
return new Signal ( ! s . i n i t i a l V a l u e ,
s . t r a n s i t i o n s ) ;
}
public
static boolean valueAt ( Signal
s ,
int
time ) {
boolean v = s . i n i t i a l V a l u e ;
Transition
t = s . t r a n s i t i o n s ;
while ( t != null ) {
i f
( time < t . time )
return v ;
v = ! v ;
t = t . next ;
}
return v ;
}
public
static void
print ( Signal
s ) {
boolean v = s . i n i t i a l V a l u e ;
Transition
t = s . t r a n s i t i o n s ;
System . out . print ( "-inf -> " ) ;
while ( t != null ) {
System . out . p r i n t l n ( t . time + " : " + v) ;
System . out . print ( t . time + " -> " ) ;
v = ! v ;
t = t . next ;
}
System . out . p r i n t l n ( "+inf : " + v) ;
}
public
static
Transition
s h i f t ( Transition
t ,
int
delta ) {
i f
( t == null )
return null ;
else
return new Transition ( t . time + delta ,
s h i f t ( t . next ,
delta ) ) ;
}
public
static
Signal
s h i f t ( Signal
s ,
int
delta ) {
return new Signal ( s . i n i t i a l V a l u e ,
s h i f t ( s . t r a n s i t i o n s ,
delta ) ) ;
}
public
static boolean isWellFormed ( Transition
t ) {
i f
( t == null
| |
t . next == null )
return true ;

11. Exam & Solution
239
else
return ( t . time < t . next . time )
&& isWellFormed ( t . next ) ;
}
static boolean isWellFormed ( Signal
s ) {
return isWellFormed ( s . t r a n s i t i o n s ) ;
}
public
static
Transition
xorTransitions ( Transition
t1 ,
Transition
t2 )
{
i f
( t1 == null )
return t2 ;
else
i f
( t2 == null )
return t1 ;
else {
int
tt1 = t1 . time ;
int
tt2 = t2 . time ;
i f
( tt1 < tt2 )
return new Transition ( tt1 ,
xorTransitions ( t1 . next ,
t2 ) ) ;
else
i f
( tt2 < tt1 )
return new Transition ( tt2 ,
xorTransitions ( t1 ,
t2 . next ) ) ;
else
return
xorTransitions ( t1 . next ,
t2 . next ) ;
}
}
public
static
Signal
xorSignals ( Signal
s1 ,
Signal
s2 )
{
return new Signal (
( s1 . i n i t i a l V a l u e ) != ( s2 . i n i t i a l V a l u e ) ,
xorTransitions ( s1 . t r a n s i t i o n s ,
s2 . t r a n s i t i o n s ) ) ;
}
public
static boolean recValueAt ( boolean value ,
Transition
t ,
int
time ) {
i f
( t == null )
return value ;
else
i f
( time < t . time )
return value ;
else
return recValueAt ( ! value ,
t . next ,
time ) ;
}
public
static boolean recValueAt ( Signal
s ,
int
instant
) {
return recValueAt ( s . i n i t i a l V a l u e ,
s . t r a n s i t i o n s ,
instant ) ;
}

240
11. Exam & Solution
public
static
Signal
renverser ( Signal
s ) {
boolean v = s . i n i t i a l V a l u e ;
Transition
t = s . t r a n s i t i o n s ;
Transition
t2 = null ;
while ( t != null ) {
t2 = new Transition(−t . time ,
t2 ) ;
v = ! v ;
t = t . next ;
}
return new Signal (v ,
t2 ) ;
}
public
static void
testValues ( Signal
s ) {
int [ ]
t = { −1, 0 ,
1 ,
2 ,
4 , 6
};
for
( int
i = 0;
i < t . length ; ++i )
System . out . p r i n t l n ( t [ i ] + " : " + recValueAt ( s ,
t [
i ] ) + "
"
+ valueAt ( s ,
t [ i ] ) ) ;
}
public
static void
t e s t ( Signal
s ) {
print ( s ) ;
testValues ( s ) ;
System . out . p r i n t l n ( isWellFormed ( s ) ) ;
System . out . p r i n t l n () ;
}
public
static void
t e s t A l l ( Signal
s ) {
t e s t ( s ) ;
Signal
i s = invert ( s ) ;
t e s t ( i s ) ;
System . out . p r i n t l n ( "XOR" ) ;
print ( xorSignals ( s ,
i s ) ) ;
System . out . p r i n t l n () ;
Signal
i t = s h i f t ( is ,
1) ;
t e s t ( i t ) ;
System . out . p r i n t l n ( "XOR" ) ;
print ( xorSignals ( it ,
i s ) ) ;
System . out . p r i n t l n () ;
Signal
i r = renverser ( i t ) ;
t e s t ( i r ) ;
}
public
static void main ( String [ ]
args ) {
Signal
s1 = new Signal ( false ,
null ) ;
Signal
s2 = new Signal ( false , new Transition (10 , new
Transition (50 ,
null ) ) ) ;
Signal
s3 = new Signal ( true , new Transition (10 , new
Transition (15 ,
new Transition (30 ,
null ) ) ) ) ;
Signal
s i g n a l 1 = new Signal ( false ,
new Transition (1 , new Transition (3 , new

11. Exam & Solution
241
Transition (4 ,
null ) ) ) ) ;
System . out . p r i n t l n ( "\ns1" ) ;
t e s t A l l ( s1 ) ;
System . out . p r i n t l n ( "\ns2" ) ;
t e s t A l l ( s2 ) ;
System . out . p r i n t l n ( "\ns3" ) ;
t e s t A l l ( s3 ) ;
System . out . p r i n t l n ( "s2 ^ s3" ) ;
print ( xorSignals ( s2 ,
s3 ) ) ;
System . out . p r i n t l n ( "\nsigna1" ) ;
t e s t A l l ( s i g n a l 1 ) ;
}
}
Solution 11.4 (Nim game)
The game of Nim is a two-player game. We consider m bins (indexed
from 0 to m −1), with bin i containing xi fruits. A game conﬁguration
is therefore represented by an array of integers.
The two players are playing in turn. A player move consists of taking as
many as wished (but at least one) fruit(s) in a same bin. The winner
is the player who takes that last remaining fruit (hence all bins become
empty).
The outcome of this game is fully predictable: One of the two players
(depending on the initial bin conﬁguration and the ﬁrst player) has a
winning strategy whatever the second player does. We shall study here
this strategy.
We begin by writing two conversion functions as follows: The ﬁrst
function converts a number written in base 2 to a number written in
base 10. The second function is the reciprocal function: conversion from
base 10 to 2.
– An integer n represented in base 2 shall be modeled using an
integer array binaryRepresentation of length k storing the k bits.
We assume that all values in this array are equal to 0 or 1, and
binaryRepresentation[i] is the i-th bit of the decomposition of n in base
2:
n =
i<k

i=0
binaryRepresentation[i] ∗2i

242
11. Exam & Solution
Write a function
static int binaryToDecimal(int[] binaryRepresentation)
that
returns
the
integer
corresponding
to
the
binary
representation
of
binaryRepresentation
– Here, we assume that k is big enough, and we are given the function:
public
static
int [ ]
decimalToBinary ( int n ,
int k) {
int [ ]
binaryRepresentation = new int [ k ] ;
decimalToBinaryAux (n ,
0 ,
binaryRepresentation ) ;
return
binaryRepresentation ;
}
Write the recursive function decimalToBinaryAux
– In the following, given a number y and an integer k, chosen large
enough so that y can be written in base 2 using k bits, we denote by
y[i] the i-th bit of the binary decomposition of y. That is, we have
y =
k

i=0
y[i] ∗2i.
We consider the following function called Grundy that takes as its
argument a number of fruits in each bin and returns an integer
Grundy(x0, x2, . . . , xm−1) = a denoting the binary representation
deﬁned by a[i] =
m−1

l=0
xl[i]

mod 2.
For example, if we want to compute Grundy(6, 9, 1, 2), we ﬁrst write
6, 9, 1 and 2 using base 2 (using the same number of k bits),
and we compute the sum on each column modulo 2. This yields a
representation in base 2 of a. We then convert a in base 10.
6
=
0
1
1
0
9
=
1
0
0
1
1
=
0
0
0
1
2
=
0
0
1
0
a
=
1
1
0
0
Thus we have Grundy(6, 9, 1, 2) = a = 12.
– Write function static int Grundy(int[] decimalTab) that returns the
value of the Grundy function for the game conﬁguration stored in
array decimalTab

11. Exam & Solution
243
It is recommended to write a few auxiliary functions, as follows:
- compute the required number k of bits,
- build an array int [][] storing the binary decompositions of values
stored in decimalTab,
- compute the Grundy function in binary.
Those functions can be reused in the remainder.
– We shall make use of the following (admitted without proof) result:
Let a Nim game conﬁguration be denoted by x0, x1, . . . , xm−1 fruits
in respective bins. Then the current player has a winning strategy if
and only if Grundy(x0, . . . , xm−1) ̸= 0.
In case we have Grundy(x0, . . . , xm−1) ̸= 0, the winning move is
described by the following steps:
– We consider Grundy(x0, . . . , xm−1) in base 2, and we select the
maximum index j of a bit with value 1 in the decomposition. Such
a bit necessarily exits because of Grundy(x1, . . . , xm−1) ̸= 0.
– We search for an index i corresponding to a bin containing xi fruits,
where j denotes the bit index of the binary decomposition of xi with
corresponding bit value 1. Such an index i necessarily exists from
the Grundy function. Fruits will be removed from the bin i.
– We shall remove from bin i a number of fruits such that the
remaining number of fruits x′
i shall satisfy for all rank h:
x′
i[h] =

1 −xi[h]
if grundy[h] = 1
xi[h]
otherwise.
In the example given in the former question, the index j is 3 and the
bin to select fruits from has index 1 (containing 9 fruits). We remove
4 fruits so that it remains exactly 5 fruits.
– Write a function pick that takes as its argument an integer array
denoting a game conﬁguration, and returns an integer array of size
2: the ﬁrst integer shall report the index of the bin to select fruits
from, and the second integer shall give the number of fruits to remove
from the selected bin. In case the Grundy function is zero (we know we
are going to loose), we shall remove a fruit from the ﬁrst non-empty
bin.

244
11. Exam & Solution
SOLUTION:
Program 11.8
Nim game solution
public
class Nim {
public
static
int
binaryToDecimal (
int [ ]
binaryRepresentation ) {
int n = 0;
int p2 = 1;
for
( int
i =0;
i < binaryRepresentation . length ;
i++)
{
n = n + binaryRepresentation [ i ]
∗p2 ;
p2 = p2 ∗
2;
}
return n ;
}
public
static void decimalToBinaryAux ( int n ,
int
i ,
int [ ]
binaryRepresentation ) {
i f
(n > 0) {
binaryRepresentation [ i ] = n % 2;
decimalToBinaryAux (n/2 ,
i +1, binaryRepresentation )
;
}
}
public
static
int [ ]
decimalToBinary ( int n ,
int k) {
int [ ]
binaryRepresentation = new int [ k ] ;
decimalToBinaryAux (n ,
0 ,
binaryRepresentation ) ;
return
binaryRepresentation ;
}
public
static
int
getBinaryLength ( int [ ]
decimalTab ) {
// search the largest value
int max = decimalTab [ 0 ] ;
for
( int
i = 1;
i < decimalTab . length ;
i++) {
i f
( decimalTab [ i ] > max) {
max = decimalTab [ i ] ;
}
}
int k = 0;
int p = 1;
while (p <= max) {
++k ;
p ∗= 2;
}
return k ;
}
public
static
int [ ] [ ]
decomposition ( int [ ]
decimalTab )
{
int k = getBinaryLength ( decimalTab ) ;
int [ ] [ ]
binaryTab = new int [ decimalTab . length ] [ ] ;

11. Exam & Solution
245
for
( int
i = 0;
i < decimalTab . length ;
i++) {
binaryTab [ i ] = decimalToBinary ( decimalTab [ i ] ,
k) ;
}
return binaryTab ;
}
public
static
int [ ]
binaryGrundy ( int [ ] [ ]
binaryTab ) {
int k = binaryTab [ 0 ] . length ;
int [ ]
grundyBinaire = new int [ k ] ;
for
( int
j = 0;
j < k ;
j++) {
for
( int
i = 0;
i < binaryTab . length ;
i++) {
grundyBinaire [ j ] =
( grundyBinaire [ j ] + binaryTab [ i ] [ j ] ) % 2;
}
}
return grundyBinaire ;
}
public
static
int Grundy( int [ ]
decimalTab ) {
int [ ] [ ]
binaryTab = decomposition ( decimalTab ) ;
return binaryToDecimal ( binaryGrundy ( binaryTab ) ) ;
}
public
static
int [ ]
l o s e r P i c k ( int [ ]
decimalTab ) {
int
i = 0;
while ( decimalTab [ i ] == 0) {
i ++;
}
int [ ]
play = { i ,
1
};
return play ;
}
public
static
int [ ]
pick ( int [ ]
decimalTab ) {
int [ ] [ ]
binaryTab = decomposition ( decimalTab ) ;
int k = binaryTab [ 0 ] . length ;
int [ ]
grundyBin = binaryGrundy ( binaryTab ) ;
i f
( binaryToDecimal ( grundyBin ) == 0) {
return
l o s e r P i c k ( decimalTab ) ;
}
int
j = k −1;
while ( grundyBin [ j ] == 0) {
j −−;
}
int
i = 0;
while ( binaryTab [ i ] [ j ] == 0) {
i ++;
}
for
( int h = 0; h < grundyBin . length ;
h++) {
i f
( grundyBin [ h ] == 1) {
binaryTab [ i ] [ h ] = 1 −binaryTab [ i ] [ h ] ;
}
}

246
11. Exam & Solution
int [ ]
play = new int [ 2 ] ;
play [ 0 ] = i ;
play [ 1 ] = decimalTab [ i ] −
binaryToDecimal ( binaryTab [ i ] ) ;
return play ;
}
public
static void main ( String [ ]
args ) {
int [ ]
game = { 6 ,
9 ,
1 , 2
};
do {
int
tt = 0;
System . out . p r i n t l n () ;
for
( int
i = 0;
i < game . length ; ++i ) {
System . out . print (game [ i ] + " " ) ;
tt += game [ i ] ;
}
System . out . p r i n t l n () ;
i f
(
tt <= 0 )
break ;
System . out . p r i n t l n (Grundy(game) ) ;
int [ ]
play = pick (game) ;
System . out . p r i n t l n ( play [ 0 ] + " " + play [ 1 ] ) ;
game [ play [ 0 ] ] −= play [ 1 ] ;
} while ( true ) ;
}
}

Bibliography
[1] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and
Cliﬀord Stein. Introduction to Algorithms, Second Edition. McGraw-Hill
Science/Engineering/Math, July 2001.
[2] James Gosling, Bill Joy, Guy Steele, and Gilad Bracha. Java(TM) Language
Speciﬁcation, 3rd Edition. Addison-Wesley Professional, 2005.
[3] David Harel.
Computers Ltd.: What They Really Can’t Do.
Oxford
University Press, Inc., New York, NY, USA, 2000.
[4] Frank Nielsen. Visual Computing: Geometry, Graphics, and Vision. Charles
River Media/Thomson Delmar Learning, 2005.
[5] Erwin Schroedinger. What is Life - The Physical Aspect of the Living Cell.
Cambridge University Press., 1944.

Index
Numbers written in italic refer to the page where the corresponding entry is
described; numbers underlined refer to the deﬁnition; numbers in roman refer
to the pages where the entry is used.
byte, 13
short, 13
BigInteger, 217
Enumeration.java, 195
Knapsack.java, 196
KnapsackCut.java, 198
Maple, 20
Math.random(), 91
NaN, 50
Queen.java, 201
SequentialSearch.java,
99
SetCoverProblem.java,
210
Sierpinski.java, 78
String, 117
StringBuffer, 118
System.out.print, 6
System.out.println, 5
if else, 32
int, 12
isEqual, 115
java, 4
javac, 4
main, 4
null, 111
nullPointerException,
111, 153
removeHeap, 177
switch case, 39
this, 181
String
compareTo(str), 120
comparison, 119
main
default
procedure, 60
return paths, 74
static
constant, 10
accumulator, 74
algorithm
generic, 219
approximation
guaranteed
approximation,
202
approximation
factor, 205, 210
constant, 211
argument, 51
array, 83
length, 85
main argument, 98
class declaration,
84
creation, 84
creation (by
enumeration), 84
declaration, 83
function
argument, 90
function call
stack, 84
garbage
collector, 87
index, 86
index (range), 86
initialization, 84
initialization
(by default), 84
integer array, 199
local declaration,
83
multi-dimensional,
93
object, 115
object field, 117
out-of-range
exception, 86
ragged, 103
ragged
(multi-dimensional),
95
reference, 87
regular, 103

250
Index
side-effect
(environment),
87
size, 86
strings, 97
subarray, 86
swap, 93
type, 83
ASCII, 119
assignment
addition
assignment, 18
division
assignment, 18
modulo
assignment, 18
multiplication
assignment, 18
subtraction
assignment, 18
backtracking, 191, 199
binary
signature, 194
binary representation,
80
binomial coefficient,
216
block
block of
instructions, 31
boolean predicate,
33, 37
brace, 4
braces, 32
branching
conditional, 31
bytecode, 4, 5
C++, 57, 87
case sensitive, 14
case-sensitive, 119
casting, 15
cell, 145
choose function, 216
class
Math, 180
creation, 108
declaration, 108
method, 169, 180
code
non-deterministic,
91
comment, 10
competitive ratio, 211
compilation, 4
computer science, 78
conditional
if else, 35
nested, 35
conditional
statement, 35
conditional structure
multiple choice, 39
configuration
exponential
size, 202
console output, 119
constant, 10, 14
constructor, 109
copying
deep, 114
shallow, 114
crash-free, 25
curly bracket, 4
curly brackets, 32
Dantzig, 205
data-centric
algorithm, 180
Data-structure
Linked list, 145
data-structure
object-oriented,
178
data-structures
abstract, 169
Object
oriented, 169
queues, 169
date, 107
digital world, 219
display, 4
dynamic programming,
211
retrieve
solution, 212
eight queen
puzzle, 198
enumeration, 194
environment
calling, 67
side-effect, 67
Eratosthenes, 102
Euclid’s GCD, 80
execution path, 31
exhaustive search, 191
expression
basic, 14, 64
factorial, 60
Fibonacci sequence,
72, 217
FIFO, 169
file extension, 4
fractal, 76
function, 58
argument, 61
call, 64
call (class), 60
call stack, 57, 64
exponentiation, 79
factorial, 60
non-static
(=method), 108
overloading, 69
pass-by-value, 64
procedure, 58
static (class), 116
subroutine, 57
function call, 64
function call
stack, 57
function signature, 68
function stack, 65
G¨odel, 49, 79
garbage collector
(GC), 87
GCD, 42
halting problem,
49, 78
Hash
code, 161
function, 161
table, 161
hashing, 127, 140
heap, 174
removal, 177
heuristic, 192,
202, 214
greedy
approximation,
203
Horner scheme, 124
IDE, 27
indentation, 11
indenting, 11
index

Index
251
reflexive, 89
inheritance, 112
inner product, 91
instruction, 4
intractable, 191
Java Virtual
Machine, 4
JDK, 60
JVM, 4, 74, 87
keyboard input, 21
knapsack, 192
0-1 knapsack, 201
gain, 203
utility, 201
weight, 201
Koch’s snowflake, 76
language
C++, 22
imperative
language, 22
Java, 22
lazy evaluation, 37
left hand side, 18
lexicographic
order, 119, 120
linear algebra, 95
Linked list, 145
local memory, 64
logarithmic mean, 73
loop, 48
nested, 94
nested loops, 192
looping structure, 31
lower case, 14
Mark Weiser, 222
matrix
binary, 201
boolean
incidence
matrix, 207
Max Bezzel, 198
memoization, 211
memory
local, 64
method, 107, 108, 180
Newton’s method, 44
Newton’s root
finding, 44
Nim game, 241
object, 107
this, 110
cloning, 114
constructor,
109, 117
copying, 114
creation, 109
data-structure, 107
equality
predicate, 115
equality test, 114
field, 107
inheritance, 112
record, 107
reference, 113
OO, 169
operand, 7
operation, 7
operator
comparison, 36
lazy evaluation, 37
priority, 7
relational, 36
ternary, 34
unary, 19
optimization, 191
approximate
solution, 214
approximation, 192
approximation
factor, 210
approximation
ratio, 192
brute force
search, 192
combinatorial, 191
complexity, 214
configuration
space, 191
cut, 197
discriminating
set, 218
dynamic
programming, 211
exact solution, 214
exhaustive
search, 191
greedy
heuristic, 192
hitting set, 217
knapsack, 192
set cover
problem,
192, 205
overloading
(function), 69
palindrome, 81
paradigm, 191
programming,
object-oriented,
183
paradox
birthday, 103
Saint Petersburg,
54
parse, 25
parsing, 11
Pascal Blaise, 216
Pascal’s triangle, 216
pass-by-value, 64
polynomial, 124
post-incrementation,
19
power set, 194
pre-incrementation, 19
primitive type, 13
boolean, 13
byte, 13
char, 13
double, 13
float, 13
int, 13
long, 13
short, 13
priority order, 21
priority queue, 173
priority rule, 7
procedure, 58
processor, 4
program skeleton, 122
program termination,
48
pseudo-randomness, 91
queen, 198
queue, 169
priority queue, 173
quicksort, 127
range space, 206
ratio factor, 203
recurrence
relation, 211
recursion, 70

252
Index
accumulator, 74
efficiency, 74
factorial, 71
Fibonacci
sequence, 72
halting problem, 78
terminal, 74
terminal
state, 71, 196
recursive type, 147
reference, 87
return carriage, 6
scope, 60
variable, 62
search
binary, 99
bisection, 100
dichotomic, 99, 100
linear, 99
sequential, 99
selection sort, 127
set cover problem,
192, 205
range, 205
side-effect, 67
Sierpinski, 76
signature, 68
skeleton,
3
sorting
in-place, 136
quicksort, 127
selection sort, 127
source code, 5
stack
function, 65
overflow, 71
string, 107
string
concatenation,
21
substring, 120
systems biology, 223
tabulation, 12
ternary operator,
34, 80
tree
binary, 174
heap, 174
leaf, 174
root, 174
truth table, 37
type, 12
non-primitive, 68
primitive, 13
recursive, 147
signature
(function), 68
unary operator, 19
upper case, 14
variable, 12
binding, 64
object
variable, 108
persistent, 64
static, 62, 63, 197
vector
inner product, 91
Weiser, Mark, 223
workflow, 31

