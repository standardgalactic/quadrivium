Category Theory
Lecture Notes
for ESSLLI
Michael Barr
Department of Mathematics and Statistics
McGill University
Charles Wells
Department of Mathematics
Case Western Reserve University

c‚ÉùMichael Barr and Charles Wells, 1999

Contents
Preface
iv
1
Preliminaries
1
1.1
Graphs
1
1.2
Homomorphisms of graphs
2
2
Categories
4
2.1
Basic deÔ¨Ånitions
4
2.2
Functional programming languages as categories
6
2.3
Mathematical structures as categories
8
2.4
Categories of sets with structure
10
2.5
Categories of algebraic structures
11
2.6
Constructions on categories
13
3
Properties of objects and arrows
17
3.1
Isomorphisms
17
3.2
Terminal and initial objects
18
3.3
Monomorphisms and subobjects
19
3.4
Other types of arrow
22
4
Functors
26
4.1
Functors
26
4.2
Actions
30
4.3
Types of functors
32
4.4
Equivalences
34
5
Diagrams and naturality
37
5.1
Diagrams
37
5.2
Natural transformations
42
5.3
Natural transformations between functors
46
5.4
Natural transformations involving lists
47
5.5
Natural transformations of graphs
48
5.6
Combining natural transformations and functors
49
5.7
The Yoneda Lemma and universal elements
50
6
Products and sums
55
6.1
The product of two objects in a category
55
6.2
Notation for and properties of products
57
6.3
Finite products
64
6.4
Sums
69
6.5
Deduction systems as categories
71
7
Cartesian closed categories
73
7.1
Cartesian closed categories
73
7.2
Properties of cartesian closed categories
77
7.3
Typed Œª-calculus
79
7.4
Œª-calculus to category and back
80
iii

iv
Contents
8
Limits and colimits
82
8.1
Equalizers
82
8.2
The general concept of limit
83
8.3
Pullbacks
86
8.4
Coequalizers
88
8.5
Cocones
89
9
Adjoints
92
9.1
Free monoids
92
9.2
Adjoints
94
9.3
Further topics on adjoints
97
10 Triples
99
10.1
Triples
99
10.2
Factorizations of a triple
100
11 Toposes
102
11.1
DeÔ¨Ånition of topos
102
11.2
Properties of toposes
104
11.3
Presheaves
106
11.4
Sheaves
107
12 Categories with monoidal structure
111
12.1
Closed monoidal categories
111
12.2
Properties of A ‚àí‚ó¶C
114
12.3
‚àó-autonomous categories
115
12.4
Factorization systems
116
12.5
The Chu construction
117
Bibliography
119
Index
123

Preface
About these notes
These notes form a short summary of some major topics in category theory. They are a condensation
(with some rearrangement) of part of [Barr and Wells, 1999]. The chapter and section numbers in the
notes are not the same as those in the book.
About categories
Categories originally arose in mathematics out of the need of a formalism to describe the passage from
one type of mathematical structure to another. A category in this way represents a kind of mathematics,
and may be described as category as mathematical workspace.
A category is also a mathematical structure. As such, it is a common generalization of both ordered
sets and monoids (the latter are a simple type of algebraic structure that include transition systems as
examples), and questions motivated by those topics often have interesting answers for categories. This
is category as mathematical structure.
Finally, a category can be seen as a structure that formalizes a mathematician‚Äôs description of a type
of structure. This is the role of category as theory. Formal descriptions in mathematical logic are
traditionally given as formal languages with rules for forming terms, axioms and equations. Algebraists
long ago invented a formalism based on tuples, the method of signatures and equations, to describe
algebraic structures. Category theory provides another approach: the category is a theory and functors
with that category as domain are models of the theory.
Other categorical literature
All of the topics in these notes are covered in more depth, with applications to computing science, in
our text [Barr and Wells, 1999]. Most of the topics are also developed further, but without applications
to computing science, in [Barr and Wells, 1985], [Mac Lane, 1971], [McLarty, 1992], [Freyd and Sce-
drov, 1990] and [Borceux, 1994] Other texts speciÔ¨Åcally concerning applications to computing science
include [Asperti and Longo, 1991], [Crole, 1994], [Gunter, 1992], [Manes and Arbib, 1986], [Pierce, 1991],
[Rydeheard and Burstall, 1988] and [Walters, 1991]. Various aspects of the close relationship between
logic and categories (in their role as theories) are treated in [Makkai and Reyes, 1977], [Lambek and Scott,
1986], [Bell, 1988] and [Ad¬¥amek and RosiÀácky, 1994]. Recent collections of papers in computer science
which have many applications of category theory are [Pitt et al., 1986], [Pitt, Poign¬¥e and Rydeheard,
1987], [Ehrig et al., 1988], [Main et al., 1988], [Gray and Scedrov, 1989], [Pitt et al., 1989], [Pitt et al.,
1991], [Fourman, Johnstone and Pitts, 1992], [Seely, 1992], [Pitt, Rydeheard and Johnstone, 1995] and
[Moggi and Rosolini, 1997]. The reader may Ô¨Ånd useful the discussions of the uses of category theory in
computing science in [Goguen, 1991], [Fokkinga, 1992] and in the tutorials in [Pitt et al., 1986].
Michael Barr
Department of Mathematics
and Statistics
McGill University
805 Sherbrooke St. W.
Montr¬¥eal, Qu¬¥ebec
Canada H3P 1S4
barr@barrs.org
Charles Wells
Department of Mathematics
Case Western Reserve University
10900 Euclid Ave
Cleveland, OH 44106-7058
USA
charles@freude.com
http://www.math.mcgill.ca/Àúbarr
http://www.cwru.edu/artsci/math/wells/home.html
v

1. Preliminaries
1.1 Graphs
The type of graph that we discuss in this section is a speciÔ¨Åc version of directed graph, one that is well
adapted to category theory, namely what is often called a directed multigraph with loops. A graph is an
essential ingredient in the deÔ¨Ånition of commutative diagram, which is the categorist‚Äôs way of expressing
equations. The concept of graph is also a precursor to the concept of category itself: a category is, roughly
speaking, a graph in which paths can be composed.
1.1.1 DeÔ¨Ånition and notation
Formally, to specify a graph, you must specify its nodes (or
objects) and its arrows. Each arrow must have a speciÔ¨Åc source (or domain) node and target
(or codomain) node. The notation ‚Äòf : a ‚àí‚Üíb‚Äô means that f is an arrow and a and b are its source and
target, respectively. If the graph is small enough, it may be drawn with its nodes indicated by dots or
labels and each arrow by an actual arrow drawn from its source to its target.
There may be one or more arrows ‚Äì or none at all ‚Äì with given nodes as source and target. Moreover,
the source and target of a given arrow need not be distinct. An arrow with the same source and target
node will be called an endoarrow or endomorphism of that node.
We will systematically denote the collection of nodes of a graph G by G0 and the collection of arrows
by G1, and similarly with other letters (H has nodes H0, C has nodes C0, and so on). The nodes form
the zero-dimensional part of the graph and the arrows the one-dimensional part.
1.1.2 Example
Let G0 = {1, 2}, G1 = {a, b, c},
source(a) = target(a) = source(b) = target(c) = 1
and
target(b) = source(c) = 2
Then we can represent G as
1
2
R
a
-
b
 c
(1.1)
1.1.3 Example
The graph of sets and functions has all sets as nodes and all functions between
sets as arrows. The source of a function is its domain, and its target is its codomain. This is a large
graph: because of Russell‚Äôs paradox, its nodes and its arrows do not form sets.
1.1.4 Example
It is often convenient to picture a relation on a set as a graph. For example, let
A = {1, 2, 3}, B = {2, 3, 4} and
Œ± = {(1, 2), (2, 2), (2, 3), (1, 4)}
Then Œ± can be pictured as
1
2
-
3
-
4
?
R
(1.2)
Of course, graphs that arise this way never have more than one arrow with the same source and
target. Such graphs are called simple graphs.
1

2
Preliminaries
1.1.5 Example
A data structure can sometimes be represented by a graph. This graph represents the
set N of natural numbers in terms of zero and the successor function (adding 1):
1
n
-
0 R
succ
(1.3)
The name ‚Äò1‚Äô for the left node is the conventional notation to require that the node denote a singleton
set, that is, a set with exactly one element. One can give a formal mathematical meaning to the idea
that this graph generates the natural numbers; see [Barr and Wells, 1999], Section 4.7.6.
This informal idea of a graph representing a data type is the basis of the formal theory of sketches,
developed in [Barr and Wells, 1999]. In particular, Section 4.7.6 of that text gives a formal mathematical
meaning to the idea that the graph just given generates the natural numbers.
1.2 Homomorphisms of graphs
A homomorphism of graphs should preserve the abstract shape of the graph. A reasonable translation
of this vague requirement into a precise mathematical deÔ¨Ånition is as follows.
1.2.1 DeÔ¨Ånition
A homomorphism œÜ from a graph G to a graph H , denoted œÜ : G ‚àí‚ÜíH , is a
pair of functions œÜ0 : G0 ‚àí‚ÜíH0 and œÜ1 : G1 ‚àí‚ÜíH1 with the property that if u : m ‚àí‚Üín is an arrow of
G , then œÜ1(u) : œÜ0(m) ‚àí‚ÜíœÜ0(n) in H .
It is instructive to restate this deÔ¨Ånition using the source and target mappings: let sourceG : G1 ‚àí‚ÜíG0
be the source map that takes an arrow (element of G1) to its source, and similarly deÔ¨Åne targetG , sourceH
and targetH . Then the pair of maps œÜ0 : G0 ‚àí‚ÜíH0 and œÜ1 : G1 ‚àí‚ÜíH1 is a graph homomorphism if and
only if
sourceH
‚ó¶œÜ1 = œÜ0 ‚ó¶sourceG
and
targetH
‚ó¶œÜ1 = œÜ0 ‚ó¶targetG
1.2.2
Notation of the form a : B ‚àí‚ÜíC is overloaded in several ways. It can denote a set-theoretic
function, a graph homomorphism or an arrow in a graph. In fact, all three are instances of the third
since there is a large graph whose nodes are sets and arrows are functions (see 1.1.3) and another whose
nodes are (small) graphs and arrows are graph homomorphisms.
Another form of overloading is that if œÜ : G ‚àí‚ÜíH is a graph homomorphism, œÜ actually stands for
a pair of functions we here call œÜ0 : G0 ‚àí‚ÜíH0 and œÜ1 : G1 ‚àí‚ÜíH1. In fact, it is customary to omit the
subscripts and use œÜ for all three (the graph homomorphism as well as its components œÜ0 and œÜ1).
This does not lead to ambiguity in practice; in reading about graphs you are nearly always aware
of whether the author is talking about nodes or arrows. We will keep the subscripts in this section and
drop them thereafter.
1.2.3 Example
If G is any graph, the identity homomorphism idG : G ‚àí‚ÜíG is deÔ¨Åned by (idG )0 =
idG0 (the identity function on the set of nodes of G ) and (idG )1 = idG1.
1.2.4 Example
If G is the graph
1
2
-
3
-
4
?
R
(1.4)

1.2 Homomorphisms of graphs
3
and H is this graph,
S
F
-
Q
?
R
I
(1.5)
then there is a homomorphism œÜ : G ‚àí‚ÜíH for which œÜ0(1) = S, œÜ0(2) = œÜ0(3) = F and œÜ0(4) = Q, and
œÜ1 takes the loop on 2 and the arrow from 2 to 3 both to the upper loop on F; what œÜ1 does to the
other two arrows is forced by the deÔ¨Ånition of homomorphism. Because there are two loops on F there
are actually four possibilities for œÜ1 on arrows (while keeping œÜ0 Ô¨Åxed).
1.2.5 Example
If H is any graph with a node n and a loop u : n ‚àí‚Üín, then there is a homomorphism
from any graph G to H that takes every node of G to n and every arrow to u. This construction gives
two other homomorphisms from G to H in Example 1.2.4 besides the four mentioned there. (There are
still others.)
1.2.6 Notation
In an expression like ‚ÄòœÜ1(source)(f)‚Äô, œÜ1 is a function whose value at ‚Äòsource‚Äô is a
function that applies to an arrow f. As this illustrates, the application operation associates to the left.

2. Categories
A category is a graph with a rule for composing arrows head to tail to give another arrow. This rule
is subject to certain conditions, which we will give precisely in Section 2.1. The connection between
functional programming languages and categories is described in Section 2.2. Some special types of
categories are given in Section 2.3. Sections 2.4 and 2.5 are devoted to a class of examples of the kind
that originally motivated category theory. The reader may wish to read through these examples rapidly
rather than trying to understand every detail. Constructions that can be made with categories are
described in Section 2.6.
2.1 Basic deÔ¨Ånitions
Before we deÔ¨Åne categories, we need a preliminary deÔ¨Ånition.
2.1.1 DeÔ¨Ånition
Let k > 0. In a graph G , a path from a node x to a node y of length k is a sequence
(f1, f2, . . . , fk) of (not necessarily distinct) arrows for which
(i) source(fk) = x,
(ii) target(fi) = source(fi‚àí1) for i = 2, . . . , k, and
(iii) target(f1) = y.
By convention, for each node x there is a unique path of length 0 from x to x that is denoted (). It is
called the empty path at x.
Observe that if you draw a path as follows:
¬∑
fk
‚àí‚àí‚Üí¬∑
fk‚àí1
‚àí‚àí‚àí‚àí‚Üí¬∑ ¬∑ ¬∑
f2
‚àí‚àí‚Üí¬∑
f1
‚àí‚àí‚Üí¬∑
with the arrows going from left to right, fk will be on the left and the subscripts will go down from left
to right. We do it this way for consistency with composition (compare 2.1.3, C‚Äì1).
For any arrow f, (f) is a path of length 1.
2.1.2 DeÔ¨Ånition
The set of paths of length k in a graph G is denoted Gk.
In particular, G2, which will be used in the deÔ¨Ånition of category, is the set of pairs of arrows (g, f)
for which the target of f is the source of g. These are called composable pairs of arrows.
We have now assigned two meanings to G0 and G1. This will cause no conÔ¨Çict as G1 refers indiÔ¨Äerently
either to the collection of arrows of G or to the collection of paths of length 1, which is essentially the same
thing. Similarly, we use G0 to represent either the collection of nodes of G or the collection of empty paths,
of which there is one for each node. In each case we are using the same name for two collections that are
not the same but are in a natural one to one correspondence. Compare the use of ‚Äò2‚Äô to denote either the
integer or the real number. As this last remark suggests, one might want to keep the two meanings of G1
separate for purposes of implementing a graph as a data structure.
The one to one correspondences mentioned in the preceding paragraph were called ‚Äònatural‚Äô. The word is
used informally here, but in fact these correspondences are natural in the technical sense (See Section 5.3).
2.1.3 Categories
A category is a graph C together with two functions c : C2 ‚àí‚ÜíC1 and u : C0 ‚àí‚ÜíC1
with properties C‚Äì1 through C‚Äì4 below. (Recall that C2 is the set of paths of length 2.) The elements
of C0 are called objects and those of C1 are called arrows. The function c is called composition, and
if (g, f) is a composable pair, c(g, f) is written g ‚ó¶f and is called the composite of g and f. If A is an
object of C , u(A) is denoted idA, which is called the identity of the object A.
C‚Äì1 The source of g ‚ó¶f is the source of f and the target of g ‚ó¶f is the target of g.
C‚Äì2 (h ‚ó¶g) ‚ó¶f = h ‚ó¶(g ‚ó¶f) whenever either side is deÔ¨Åned.
C‚Äì3 The source and target of idA are both A.
4

2.1 Basic deÔ¨Ånitions
5
C‚Äì4 If f : A ‚àí‚ÜíB, then f ‚ó¶idA = idB ‚ó¶f = f.
The signiÔ¨Åcance of the fact that the composite c is deÔ¨Åned on G2 is that g ‚ó¶f is deÔ¨Åned if and only
if the source of g is the target of f. This means that composition is a function whose domain is an
equationally deÔ¨Åned subset of G1 √ó G1: the equation requires that the source of g equal the target of f.
It follows from this and C‚Äì1 that in C‚Äì2, one side of the equation is deÔ¨Åned if and only if the other side
is deÔ¨Åned.
In the category theory literature, idA is often written just A.
2.1.4 Terminology
In much of the categorical literature, ‚Äòmorphism‚Äô, ‚Äòdomain‚Äô and ‚Äòcodomain‚Äô are
more common than ‚Äòarrow‚Äô, ‚Äòsource‚Äô and ‚Äòtarget‚Äô. In these notes we usually use the language we have
just introduced of ‚Äòarrow‚Äô, ‚Äòsource‚Äô and ‚Äòtarget‚Äô. We will normally denote objects of categories by capital
letters but nodes of graphs (except when we think of a category as a graph) by lower case letters. Arrows
are always lower case.
In the computing science literature, the composite g ‚ó¶f is sometimes written f;g, a notation suggested
by the perception of a typed functional programming language as a category (see 2.2.1).
We have presented the concept of category as a two-sorted data structure; the sorts are the objects
and the arrows. Categories are sometimes presented as one-sorted ‚Äì arrows only. The objects can be
recovered from the fact that C‚Äì3 and C‚Äì4 together characterize idA (not hard to prove), so that there is
a one to one correspondence between the objects and the identity arrows idA.
2.1.5 DeÔ¨Ånition
A category is small if its objects and arrows constitute sets; otherwise it is large.
The category of sets and functions deÔ¨Åned in 2.1.11 below is an example of a large category. Although
one must in principle be wary in dealing with large classes, it is not in practice a problem; category
theorists have rarely, if ever, run into set-theoretic diÔ¨Éculties.
2.1.6 DeÔ¨Ånition
If A and B are two objects of a category C , then the set of all arrows of C that have
source A and target B is denoted HomC (A, B), or just Hom(A, B) if the category is clear from context.
Thus for each triple A, B, C of objects, composition induces a function
Hom(B, C) √ó Hom(A, B) ‚àí‚ÜíHom(A, C)
A set of the form Hom(A, B) is called a hom set. Other common notations for Hom(A, B) are C (A, B)
and C (AB).
2.1.7
The reference to the set of all arrows from A to B constitutes an assumption that they do indeed
form a set. A category with the property that Hom(A,B) is a set for all objects A and B is called locally
small. All categories in these notes are locally small.
2.1.8 DeÔ¨Ånition
For any path (f1, f2, . . . , fn) in a category C , deÔ¨Åne f1 ‚ó¶f2 ‚ó¶¬∑ ¬∑ ¬∑ ‚ó¶fn recursively by
f1 ‚ó¶f2 ‚ó¶¬∑ ¬∑ ¬∑ ‚ó¶fn = (f1 ‚ó¶f2 ‚ó¶¬∑ ¬∑ ¬∑ ‚ó¶fn‚àí1) ‚ó¶fn,
n > 2
2.1.9 Proposition
The general associative law. For any path
(f1, f2, . . . , fn)
in a category C and any integer k with 1 < k < n,
(f1 ‚ó¶¬∑ ¬∑ ¬∑ ‚ó¶fk) ‚ó¶(fk+1 ‚ó¶¬∑ ¬∑ ¬∑ ‚ó¶fn) = f1 ‚ó¶¬∑ ¬∑ ¬∑ ‚ó¶fn
In other words, you can unambiguously drop the parentheses.
In this proposition, the notation fk+1 ‚ó¶¬∑ ¬∑ ¬∑ ‚ó¶fn when k = n ‚àí1 means simply fn.
This is a standard fact for associative binary operations (see [Jacobson, 1974], Section 1.4) and can
be proved in exactly the same way for categories.

6
Categories
2.1.10 Little categories
The smallest category has no objects and (of course) no arrows. The next
smallest category has one object and one arrow, which must be the identity arrow. This category may be
denoted 1. Other categories that will be occasionally referred to are the categories 1+1 and 2 illustrated
below (the loops are identities). In both cases the choice of the composites is forced.
A
B
R
R
C
D
-
R
R
1 + 1
2
(2.1)
2.1.11 Categories of sets
The category of sets is the category whose objects are sets and whose
arrows are functions with composition of functions for c and the identity function from S to S for idS. The
statement that this is a category amounts to the statements that composition of functions is associative
and that each identity function idS : S ‚àí‚ÜíS satisÔ¨Åes f
‚ó¶idS = f and idS ‚ó¶g = g for all f with source
S and all g with target S. The fact that composition of functions is associative follows by using the
deÔ¨Ånition of functional composition repeatedly:
((h‚ó¶g)‚ó¶f)(x) = (h‚ó¶g)(f(x)) = h(g(f(x))) = h((g‚ó¶f)(x)) = (h‚ó¶(g‚ó¶f))(x)
The properties of the identity function follow from the deÔ¨Ånition.
In this text, the category of sets is denoted Set. There are other categories whose objects are sets,
as follows.
2.1.12 DeÔ¨Ånition
The category of Ô¨Ånite sets, denoted Fin, is the category whose objects are Ô¨Ånite
sets and whose arrows are all the functions between Ô¨Ånite sets.
2.1.13 DeÔ¨Ånition
A partial function from a set S to a set T is a function with domain S0 and
codomain T, where S0 is some subset of S. The category Pfn of sets and partial functions has all
sets as objects and all partial functions as arrows. If f : S ‚àí‚ÜíT and g : T ‚àí‚ÜíV are partial functions
with f deÔ¨Åned on S0 ‚äÜS and g deÔ¨Åned on T0 ‚äÜT, the composite g ‚ó¶f : S ‚àí‚ÜíV is the partial function
from S to V deÔ¨Åned on the subset {x ‚ààS0 | f(x) ‚ààT0} of S by the requirement (g ‚ó¶f)(x) = g(f(x)).
It is a worthwhile exercise to check that composition so deÔ¨Åned is associative.
2.1.14 DeÔ¨Ånition
Let Œ± be a relation from a set S to a set T and Œ≤ a relation from T to U. The
composite Œ≤ ‚ó¶Œ± is the relation from S to U deÔ¨Åned as follows: If x ‚ààS and z ‚ààU, (x, z) ‚ààŒ≤ ‚ó¶Œ± if and
only if there is an element y ‚ààT for which (x, y) ‚ààŒ± and (y, z) ‚ààŒ≤. With this deÔ¨Ånition of composition,
the category Rel of sets and relations has sets as objects and relations as arrows. The identity for
a set S is the diagonal relation ‚àÜS = {(x, x) | x ‚ààA}.
Other examples of categories whose objects are sets are the category of sets and injective functions
and the category of sets and surjective functions.
2.2 Functional programming languages
as categories
The intense interest in category theory among researchers in computing science in recent years is due in
part to the recognition that the constructions in functional programming languages make a functional
programming language look very much like a category. The fact that deduction systems are essentially
categories has also been useful in computing science.
In this section we describe the similarities between functional programming languages and categories
informally, and discuss some of the technical issues involved in making them precise. Deduction systems
are discussed in Section 6.5.

2.2 Functional programming languages
7
2.2.1 Functional programming languages
A functional programming language may be described
roughly as one that gives the user some primitive types and operations and some constructors from which
one can produce more complicated types and operations.
What a pure functional programming language in this sense does not have is variables or assign-
ment statements. One writes a program by applying constructors to the types, constants and functions.
‚ÄòRunning‚Äô a program consists of applying such an operator to constants of the input type to obtain a
value.
This is functional programming in the sense of the ‚Äòfunction-level programming‚Äô of Backus [1981a]
and [1981b]. (See also [Williams, 1982].) Another widely held point of view is that functional programming
means no assignment statements: variables may appear but are not assigned to. Most languages called
functional programming languages (for example Haskell and Miranda) are functional in this sense.
We will discuss Backus-style functional programming languages here. The lambda calculus, with
variables, is discussed in Chapter 7.
2.2.2 The category corresponding to a functional programming language
A functional pro-
gramming language has:
FPL‚Äì1 Primitive data types, given in the language.
FPL‚Äì2 Constants of each type.
FPL‚Äì3 Operations, which are functions between the types.
FPL‚Äì4 Constructors, which can be applied to data types and operations to produce derived data types
and operations of the language.
The language consists of the set of all operations and types derivable from the primitive data types
and primitive operations. The word ‚Äòprimitive‚Äô means given in the deÔ¨Ånition of the language rather than
constructed by a constructor. Some authors use the word ‚Äòconstructor‚Äô for the primitive operations.
2.2.3
If we make two assumptions about a functional programming language and one innocuous change,
we can see directly that a functional programming language L corresponds in a canonical way to a
category C(L).
A‚Äì1 We must assume that there is a do-nothing operation idA for each type A (primitive and con-
structed). When applied, it does nothing to the data.
A‚Äì2 We add to the language an additional type called 1, which has the property that from every type
A there is a unique operation to 1. We interpret each constant c of type A as an arrow c : 1 ‚àí‚ÜíA.
This incorporates the constants into the set of operations; they no longer appear as separate data.
A‚Äì3 We assume the language has a composition constructor: take an operation f that takes something
of type A as input and produces something of type B, and another operation g that has input of
type B and output of type C; then doing one after the other is a derived operation (or program)
typically denoted f; g, which has input of type A and output of type C.
Functional programming languages generally have do-nothing operations and composition construc-
tors, so A‚Äì1 and A‚Äì3 Ô¨Åt the concept as it appears in the literature. The language resulting from the
change in A‚Äì2 is operationally equivalent to the original language.
Composition must be associative in the sense that, if either of (f; g); h or f; (g; h) is deÔ¨Åned, then
so is the other and they are the same operation. We must also require, for f : A ‚àí‚ÜíB, that f; idB and
idA; f are deÔ¨Åned and are the same operation as f. That is, we impose the equations f; idB = f and
idA; f = f on the language. Both these requirements are reasonable in that in any implementation, the
two operations required to be the same would surely do the same thing.
2.2.4
Under those conditions, a functional programming language L has a category structure C(L) for
which:
FPC‚Äì1 The types of L are the objects of C(L).
FPC‚Äì2 The operations (primitive and derived) of L are the arrows of C(L).
FPC‚Äì3 The source and target of an arrow are the input and output types of the corresponding operation.
FPC‚Äì4 Composition is given by the composition constructor, written in the reverse order.

8
Categories
FPC‚Äì5 The identity arrows are the do-nothing operations.
The reader may wish to compare the discussion in [Pitt, 1986].
Observe that C(L) is a model of the language, not the language itself. For example, in the cate-
gory f; idB = f, but in the language f and f; idB are diÔ¨Äerent source programs. This is in contrast to
the treatment of languages using context free grammars: a context free grammar generates the actual
language.
2.2.5 Example
As a concrete example, we will suppose we have a simple such language with three
data types, NAT (natural numbers), BOOLEAN (true or false) and CHAR (characters). We give a description
of its operations in categorical style.
(i) NAT should have a constant 0 : 1 ‚àí‚ÜíNAT and an operation succ : NAT ‚àí‚ÜíNAT.
(ii) There should be two constants true, false : 1 ‚àí‚ÜíBOOLEAN and an operation ¬¨ subject to the
equations ¬¨ ‚ó¶true = false and ¬¨ ‚ó¶false = true.
(iii) CHAR should have one constant c : 1 ‚àí‚ÜíCHAR for each desired character c.
(iv) There should be two type conversion operations ord : CHAR ‚àí‚ÜíNAT and chr : NAT ‚àí‚ÜíCHAR. These
are subject to the equation chr ‚ó¶ord = idCHAR. (You can think of chr as operating modulo the
number of characters, so that it is deÔ¨Åned on all natural numbers.)
An example program is the arrow ‚Äònext‚Äô deÔ¨Åned to be the composite chr ‚ó¶succ ‚ó¶ord : CHAR ‚àí‚ÜíCHAR.
It calculates the next character in order. This arrow ‚Äònext‚Äô is an arrow in the category representing the
language, and so is any other composite of a sequence of operations.
2.2.6
The objects of the category C(L) of this language are the types NAT, BOOLEAN, CHAR and 1.
Observe that typing is a natural part of the syntax in this approach.
The arrows of C(L) consist of all programs, with two programs being identiÔ¨Åed if they must be the
same because of the equations. For example, the arrow
chr ‚ó¶succ ‚ó¶ord : CHAR ‚àí‚ÜíCHAR
just mentioned and the arrow
chr ‚ó¶succ ‚ó¶ord ‚ó¶chr ‚ó¶ord : CHAR ‚àí‚ÜíCHAR
must be the same because of the equation in (iv).
Observe that NAT has constants succ ‚ó¶succ ‚ó¶. . . ‚ó¶succ ‚ó¶0 where succ occurs zero or more times.
Composition in the category is composition of programs. Note that for composition to be well deÔ¨Åned,
if two composites of primitive operations are equal, then their composites with any other program must
be equal. For example, we must have
ord ‚ó¶(chr ‚ó¶succ ‚ó¶ord) = ord ‚ó¶(chr ‚ó¶succ ‚ó¶ord ‚ó¶chr ‚ó¶ord)
as arrows from CHAR to NAT. This is handled systematically in [Barr and Wells, 1999], Chapter 3.5, using
the quotient construction.
This discussion is incomplete, since at this point we have no way to introduce n-ary operations for
n > 1, nor do we have a way of specifying the Ô¨Çow of control. The Ô¨Årst will be remedied in Section 6.3.13.
Approaches to the second question are given in ([Barr and Wells, 1999] (sections 5.6 and 14.2), [Cockett,
1989], [Wagner, 1986a]).
2.3 Mathematical structures as categories
Certain common mathematical structures can be perceived as special types of categories.

2.3 Mathematical structures
9
2.3.1 Preordered and ordered sets
If S is a set, a subset Œ± ‚äÜS √ó S is called a binary relation
on S. It is often convenient to write xŒ±y as shorthand for (x, y) ‚ààŒ±. We say that Œ± is reÔ¨Çexive if xŒ±x
for all x ‚ààS and transitive if xŒ±y and yŒ±z implies xŒ±z for all x, y, z ‚ààS.
A set S with a reÔ¨Çexive, transitive relation Œ± on it is a structure (S, Œ±) called a preordered set.
This structure determines a category C(S, Œ±) deÔ¨Åned as follows.
CO‚Äì1 The objects of C(S, Œ±) are the elements of S.
CO‚Äì2 If x, y ‚ààS and xŒ±y, then C(S, Œ±) has exactly one arrow from x to y, denoted (y, x). (The reader
might have expected (x, y) here. This choice of notation Ô¨Åts better with the right-to-left compo-
sition that we use. Note that the domain of (y, x) is x and the codomain is y.)
CO‚Äì3 If x is not related by Œ± to y there is no arrow from x to y.
The identity arrows of C(S, Œ±) are those of the form (x, x); they belong to Œ± because it is reÔ¨Çexive. The
transitive property of Œ± is needed to ensure the existence of the composite described in 2.1.3, so that
(z, y) ‚ó¶(y, x) = (z, x).
2.3.2 Example
The category C(S, Œ±) for S = {C, D} and
Œ± = {‚ü®C, C‚ü©, ‚ü®C, D‚ü©, ‚ü®D, D‚ü©}
is the category 2 exhibited in (2.1), page 6.
2.3.3 Ordered sets
A preordered set (S, Œ±) for which Œ± is antisymmetric (that is xŒ±y and yŒ±x imply
x = y) is called an ordered set or poset (for ‚Äòpartially ordered set‚Äô). Two examples of posets are (R,‚â§),
the real numbers with the usual ordering, and for any set S, the poset (P(S), ‚äÜ), the set of subsets of
S with inclusion as ordering.
It is often quite useful and suggestive to think of a category as a generalized ordered set, and we will
refer to this perception to illuminate constructions we make later.
2.3.4 Semigroups
A semigroup is a set S together with an associative binary operation m : S √ó S
‚àí‚ÜíS. The set S is called the underlying set of the semigroup.
Normally for s and t in S, m(s, t) is written ‚Äòst‚Äô and called ‚Äòmultiplication‚Äô, but note that it does not
have to satisfy the commutative law; that is, we may have st Ã∏= ts. A commutative semigroup is a
semigroup whose multiplication is commutative.
It is standard practice to talk about ‚Äòthe semigroup S‚Äô, naming the semigroup by naming its under-
lying set. This will be done for other mathematical structures such as posets as well. Mathematicians
call this practice ‚Äòabuse of notation‚Äô. It is occasionally necessary to be more precise; that happens in this
text in Section 9.1.
2.3.5 Powers
We set s1 = s and, for any positive integer k, sk = ssk‚àí1. Such powers of an element
obey the laws sksn = sk+n and (sk)n = skn (for positive k and n). On the other hand, the law (st)k = sktk
requires commutativity.
2.3.6 Empty semigroup
We speciÔ¨Åcally allow the empty semigroup, which consists of the empty
set and the empty function from the empty set to itself. (Note that the cartesian product of the empty
set with itself is the empty set.) This is not done in most of the non-category theory literature; it will
become evident later (Section 8.5.2) why we should include the empty semigroup.
2.3.7 DeÔ¨Ånition
An identity element e for a semigroup S is an element of S that satisÔ¨Åes the
equation se = es = s for all s ‚ààS.
There can be at most one identity element in a semigroup.
2.3.8 DeÔ¨Ånition
A monoid is a semigroup with an identity element. It is commutative if its binary
operation is commutative.
It follows from the deÔ¨Ånition that a monoid is not allowed to be empty: it must contain an identity
element. It also follows that we can extend the notation in 2.3.5 to 0 by deÔ¨Åning x0 to be the identity
element of the monoid. The laws sksn = sk+n and (sk)n = skn then hold for all nonnegative k and n.

10
Categories
2.3.9 Examples
One example of a semigroup is the set of positive integers with addition as the
operation; this is a semigroup but not a monoid. If you include 0 you get a monoid.
The Kleene closure A‚àóof a set A is the set of strings (or lists) of Ô¨Ånite length of elements of A.
We write the lists in parentheses; for example (a, b, d, a) is an element of {a, b, c, d}‚àó. Some parts of the
computer science literature call these strings instead of lists and write them this way: ‚Äòabda‚Äô. A‚àóincludes
the empty list () and for each element a ‚ààA the list (a) of length one.
The operation of concatenation makes the Kleene closure a monoid F(A), called the free monoid
determined by A. The empty list is the identity element. We write concatenation as juxtaposition; thus
(a, b, d, a)(c, a, b) = (a, b, d, a, c, a, b)
Note that the underlying set of the free monoid is A‚àó, not A. In the literature, A is usually assumed
Ô¨Ånite, but the Kleene closure is deÔ¨Åned for any set A. The elements of A‚àóare lists of Ô¨Ånite length in any
case. When A is nonempty, A‚àóis an inÔ¨Ånite set.
The concept of freeness is a general concept applied to many kinds of structures. It is treated sys-
tematically in Chapter 9.
2.3.10 DeÔ¨Ånition
A submonoid of a monoid M is a subset S of M with the properties:
SM‚Äì1 The identity element of M is in S.
SM‚Äì2 If m, n ‚ààS then mn ‚ààS. (One says that S is closed under the operation.)
2.3.11 Examples
The natural numbers with addition form a submonoid of the integers with addition.
For another example, consider the integers with multiplication as the operation, so that 1 is the identity
element. Again the natural numbers form a submonoid, and so does the set of positive natural numbers,
since the product of two positive numbers is another one. Finally, the singleton set {0} is a subset of the
integers that is closed under multiplication, and it is a monoid, but it is not a submonoid of the integers
on multiplication because it does not contain the identity element 1.
2.3.12 Monoid as category
Any monoid M determines a category C(M).
CM‚Äì1 C(M) has one object, which we will denote ‚àó; ‚àócan be chosen arbitrarily. A simple uniform choice
is to take ‚àó= M.
CM‚Äì2 The arrows of C(M) are the elements of M with ‚àóas source and target.
CM‚Äì3 Composition is the binary operation on M.
(This construction is revisited in Section 4.4.)
Thus a category can be regarded as a generalized monoid, or a ‚Äòmonoid with many objects‚Äô. This
point of view has not been as fruitful in mathematics as the perception of a category as a generalized
poset. It does have some applications in computing science; see [Barr and Wells, 1999], Chapter 12.
2.3.13 Remark
Many categorists deÔ¨Åne a monoid to be a category with one object (compare 2.3.12)
and a preordered set to be a category in which every hom set is either empty or a singleton (com-
pare 2.3.1). This can be justiÔ¨Åed by the fact that the category of monoids and the category of one-object
categories are ‚Äòequivalent‚Äô as deÔ¨Åned in Section 4.4.
2.4 Categories of sets with structure
The typical use of categories has been to consider categories whose objects are sets with mathematical
structure and whose arrows are functions that preserve that structure. The deÔ¨Ånition of category is
an abstraction of basic properties of such systems. Typical examples have included categories whose
objects are spaces of some type and whose arrows are continuous (or diÔ¨Äerentiable) functions between
the spaces, and categories whose objects are algebraic structures of some speciÔ¨Åc type and whose arrows
are homomorphisms between them.
In this section we describe various categories of sets with structure. The following section considers
categories of semigroups and monoids.

2.5 Categories of algebraic structures
11
Note the contrast with Section 2.3, where we discussed certain mathematical structures as categories.
Here, we discuss categories whose objects are mathematical structures.
2.4.1 DeÔ¨Ånition
The category of graphs has graphs as objects and homomorphisms of graphs
(see 1.2.1) as arrows. It is denoted GRF. The category of graphs and homomorphisms between them is
denoted Grf.
Let us check that the composite of graph homomorphisms is a graph homomorphism (identities are
easy). Suppose œÜ : G ‚àí‚ÜíH and œà : H ‚àí‚ÜíK are graph homomorphisms, and suppose that u : m ‚àí‚Üín
in G . Then by deÔ¨Ånition œÜ1(u) : œÜ0(m) ‚àí‚ÜíœÜ0(n) in H , and so by deÔ¨Ånition
œà1(œÜ1(u)) : œà0(œÜ0(m)) ‚àí‚Üíœà0(œÜ0(n)) in K
Hence œà ‚ó¶œÜ is a graph homomorphism.
The identity homomorphism idG is the identity function for both nodes and arrows.
2.4.2 The category of posets
If (S, Œ±) and (T, Œ≤) are posets, a function f : S ‚àí‚ÜíT is monotone if
whenever xŒ±y in S, f(x)Œ≤f(y) in T.
The identity function on a poset is clearly monotone, and the composite of two monotone functions
is easily seen to be monotone, so that posets with monotone functions form a category. A variation on
this is to consider only strictly monotone functions, which are functions f with the property that if
xŒ±y and x Ã∏= y then f(x)Œ≤f(y) and f(x) Ã∏= f(y).
In 2.3.1, we saw how a single poset is a category. Now we are considering the category of posets.
We must give a few words of warning on terminology. The usual word in mathematical texts for what
we have called ‚Äòmonotone‚Äô is ‚Äòincreasing‚Äô or ‚Äòmonotonically increasing‚Äô. The word ‚Äòmonotone‚Äô is used for
a function that either preserves or reverses the order relation. That is, in mathematical texts a function
f : (X, Œ±) ‚àí‚Üí(T, Œ≤) is also called monotone if whenever xŒ±y in S, f(y)Œ≤f(x) in T.
2.5 Categories of algebraic structures
In this section, we discuss categories whose objects are semigroups or monoids. These are typical of
categories of algebraic structures; we have concentrated on semigroups and monoids because transition
systems naturally form monoids. The material in this section will come up primarily in examples later,
and need not be thoroughly understood in order to read the rest of the notes.
2.5.1 Homomorphisms of semigroups and monoids
If S and T are semigroups, a function h : S
‚àí‚ÜíT is a homomorphism if for all s, s‚Ä≤ ‚ààS, h(ss‚Ä≤) = h(s)h(s‚Ä≤).
A homomorphism of monoids is a semigroup homomorphism between monoids that preserves the
identity elements: if e is the identity element of the domain, h(e) must be the identity element of the
codomain.
2.5.2 Examples
The identity function on any monoid is a monoid homomorphism. If M is a monoid
and S is a submonoid (see 2.3.10), the inclusion function from S to M is a monoid homomorphism.
Another example is the function that takes an even integer to 0 and an odd integer to 1. This is a
monoid homomorphism from the monoid of integers on multiplication to the set {0, 1} on multiplication.
It is easy to see that identity functions are homomorphisms and homomorphisms compose to give
homomorphisms. Thus we have two categories: Sem is the category of semigroups and semigroup homo-
morphisms, and Mon is the category of monoids and monoid homomorphisms.
2.5.3 Example
Let S be a semigroup with element s. Let N+ denote the semigroup of positive integers
with addition as operation. There is a semigroup homomorphism p : N+ ‚àí‚ÜíS for which p(k) = sk. That
this is a homomorphism is just the statement sk+n = sksn (see 2.3.5).

12
Categories
2.5.4
A semigroup homomorphism between monoids need not preserve the identities. An example of
this involves the trivial monoid E with only one element e (which is perforce the identity element) and
the monoid of all integers with multiplication as the operation, which is a monoid with identity 1. The
function that takes the one element of E to 0 is a semigroup homomorphism that is not a monoid
homomorphism. And, by the way, even though {0} is a subsemigroup of the integers with multiplication
and even though it is actually a monoid, it is not a submonoid.
2.5.5 Inverses of homomorphisms
As an example of how to use the deÔ¨Ånition of homomorphism,
we show that the inverse of a bijective semigroup homomorphism is also a semigroup homomorphism.
Let f : S ‚àí‚ÜíT be a bijective semigroup homomorphism with inverse g. Let t, t‚Ä≤ ‚ààT. We have to show
that g(t)g(t‚Ä≤) = g(tt‚Ä≤). Since f is injective, it is suÔ¨Écient to show that
f(g(t)g(t‚Ä≤)) = f(g(tt‚Ä≤))
The right hand side is tt‚Ä≤ because g is the inverse of f, and the left hand side is
f(g(t)g(t‚Ä≤)) = f(g(t))f(g(t‚Ä≤))
because f is a homomorphism, but that is also tt‚Ä≤ since g is the inverse of f.
This sort of theorem is true of other algebraic structures, such as monoids. It is not true for posets.
2.5.6 Isomorphisms of semigroups
If a homomorphism of semigroups has an inverse that is a
homomorphism (equivalently, as we just saw, if it is bijective), we say that the homomorphism is an
isomorphism. In this case, the two semigroups in question have the same abstract structure and are
said to be isomorphic. As we will see later, the property of possessing an inverse is taken to deÔ¨Åne the
categorical notion of isomorphism (3.1.4).
It is important to understand that there may in general be many diÔ¨Äerent isomorphisms between
isomorphic semigroups. For example, there are two distinct isomorphisms between the monoid with
underlying set {0,1,2,3} and addition (mod4) as operation and the monoid with underlying set {1,2,3,4}
and multiplication (mod 5) as operation.
We now discuss two important types of examples of monoid homomorphisms that will reappear later
in the notes. The Ô¨Årst example is a basic property of free monoids.
2.5.7 Kleene closure induces homomorphisms
Let A and B denote sets, thought of as al-
phabets. Let f : A ‚àí‚ÜíB be any set function. We deÔ¨Åne f ‚àó: A‚àó‚àí‚ÜíB‚àóby f ‚àó (a1, a2, . . . , ak)

=
(f(a1), f(a2), . . . , f(ak)). In particular, f ‚àó() = () and for any a ‚ààA, f ‚àó(a) = f(a).
Then f ‚àóis a homomorphism of monoids, a requirement that, in this case, means it preserves identity
elements (by deÔ¨Ånition) and concatenation, which can be seen from the following calculation: Let a =
(a1, a2, . . . , am) and a‚Ä≤ = (a‚Ä≤
1, a‚Ä≤
2, . . . , a‚Ä≤
n) be lists in A‚àó. Concatenating them gives the list
aa‚Ä≤ = (a1, a2, . . . , am, a‚Ä≤
1, a‚Ä≤
2, . . . , a‚Ä≤
n)
Then
f ‚àó(a)f ‚àó(a‚Ä≤)
=
f ‚àó(a1, a2, . . . , am)f ‚àó(a‚Ä≤
1, a‚Ä≤
2, . . . , a‚Ä≤
n)
=
(f(a1), f(a2), . . . , f(am))(f(a‚Ä≤
1), f(a‚Ä≤
2), . . . , f(a‚Ä≤
n))
=
(f(a1), f(a2), . . . , f(am), f(a‚Ä≤
1), f(a‚Ä≤
2), . . . , f(a‚Ä≤
n))
=
f ‚àó(a1, a2, . . . , am, a‚Ä≤
1, a‚Ä≤
2, . . . , a‚Ä≤
n)
=
f ‚àó(aa‚Ä≤)
Thus any set function between sets induces a monoid homomorphism between the corresponding free
monoids. The reader may wish to verify that if f is an isomorphism then so is f ‚àó.
The function f ‚àóis called Œ±f in [Backus, 1981a] and in modern functional languages is usually called
map f or maplist f.
The other important example is a basic construction of number theory.

2.6 Constructions on categories
13
2.5.8 The remainder function
The set Z of all integers forms a monoid with respect to either
addition or multiplication. If k is any positive integer, the set Zk = {0, 1, . . . , k ‚àí1} of remainders of k
is also a monoid with respect to addition or multiplication (mod k). Here are more precise deÔ¨Ånitions.
2.5.9 DeÔ¨Ånition
Let k be a positive integer and n any integer. Then n mod k is the unique integer
r ‚ààZk for which there is an integer q such that n = qk + r and 0 ‚â§r < k.
It is not diÔ¨Écult to see that there is indeed a unique integer r with these properties.
DeÔ¨Åne an operation ‚Äò+k‚Äô of addition (mod k) by requiring that
r +k s = (r + s) mod k
The operation of addition of the contents of two registers in a microprocessor may be addition (mod k)
for k some power of 2 (often complicated by the presence of sign bits).
2.5.10 Proposition
(Zk, +k) is a monoid with identity 0.
We also have the following.
2.5.11 Proposition
The function n 7‚Üí(n mod k) is a monoid homomorphism from (Z,+) to (Zk,+k).
A similar deÔ¨Ånition and proposition can be given for multiplication.
2.6 Constructions on categories
If you are familiar with some branch of abstract algebra (for example the theory of semigroups, groups
or rings) then you know that given two structures of a given type (e.g., two semigroups), you can
construct a ‚Äòdirect product‚Äô structure, deÔ¨Åning the operations coordinatewise. Also, a structure may
have substructures, which are subsets closed under the operations, and quotient structures, formed from
equivalence classes modulo a congruence relation. Another construction that is possible in many cases is
the formation of a ‚Äòfree‚Äô structure of the given type for a given set.
All these constructions can be performed for categories. We will outline the constructions here,
except for quotients, which are covered in [Barr and Wells, 1999], Section 3.5. We will also describe
the construction of the slice category, which does not quite correspond to anything in abstract algebra
(although it is akin to the adjunction of a constant to a logical theory). You do not need to be familiar
with the constructions in other branches of abstract algebra, since they are all deÔ¨Åned from scratch here.
2.6.1 DeÔ¨Ånition
A subcategory D of a category C is a category for which:
S‚Äì1 All the objects of D are objects of C and all the arrows of D are arrows of C (in other words,
D0 ‚äÜC0 and D1 ‚äÜC1).
S‚Äì2 The source and target of an arrow of D are the same as its source and target in C (in other words,
the source and target maps for D are the restrictions of those for C ). It follows that for any objects
A and B of D, HomD(A, B) ‚äÜHomC (A, B).
S‚Äì3 If A is an object of D then its identity arrow idA in C is in D.
S‚Äì4 If f : A ‚àí‚ÜíB and g : B ‚àí‚ÜíC in D, then the composite (in C ) g ‚ó¶f is in D and is the composite in
D.
2.6.2 Examples
As an example, the category Fin of Ô¨Ånite sets and all functions between them is
a subcategory of Set, and in turn Set is a subcategory of the category of sets and partial functions
between sets (see 2.1.12 and 2.1.13). These examples illustrate two phenomena:
(i) If A and B are Ô¨Ånite sets, then HomFin(A, B) = HomSet(A, B). In other words, every arrow of
Set between objects of Fin is an arrow of Fin.

14
Categories
(ii) The category of sets and the category of sets and partial functions, on the other hand, have exactly
the same objects. The phenomenon of (i) does not occur here: there are generally many more partial
functions between two sets than there are full functions.
Example (i) motivates the following deÔ¨Ånition.
2.6.3 DeÔ¨Ånition
If D is a subcategory of C and for every pair of objects A, B of D, HomD(A, B) =
HomC (A, B), then D is a full subcategory of C .
Thus Fin is a full subcategory of Set but Set is not a full subcategory of the category of sets and
partial functions.
Example 2.6.2(ii) also motivates a (less useful) deÔ¨Ånition, as follows.
2.6.4 DeÔ¨Ånition
If D is a subcategory of C with the same objects, then D is a wide subcategory of
C .
Thus in the case of a wide subcategory, only the arrows are diÔ¨Äerent from those of the larger category.
In 3.1.8 we provide an improvement on this concept.
As an example, Set is a wide subcategory of the category Pfn of sets and partial functions.
2.6.5 Example
Among all the objects of the category of semigroups are the monoids, and among
all the semigroup homomorphisms between two monoids are those that preserve the identity. Thus the
category of monoids is a subcategory of the category of semigroups that is neither wide nor full (for the
latter, see 2.5.4).
As it stands, being a subcategory requires the objects and arrows of the subcategory to be identical
with some of the objects and arrows of the category containing it. This requires an uncategorical emphasis
on what something is instead of on the speciÔ¨Åcation it satisÔ¨Åes. We will return to this example in 3.3.14
and again in 4.1.8.
2.6.6 The product of categories
If C and D are categories, the product C √ó D is the category
whose objects are all ordered pairs (C, D) with C an object of C and D an object of D, and in which an
arrow (f, g) : (C, D) ‚àí‚Üí(C‚Ä≤, D‚Ä≤) is a pair of arrows f : C ‚àí‚ÜíC‚Ä≤ in C and g : D ‚àí‚ÜíD‚Ä≤ in D. The identity
of (C, D) is (idC, idD). If (f ‚Ä≤, g‚Ä≤) : (C‚Ä≤, D‚Ä≤) ‚àí‚Üí(C‚Ä≤‚Ä≤, D‚Ä≤‚Ä≤) is another arrow, then the composite is deÔ¨Åned
by
(f ‚Ä≤, g‚Ä≤) ‚ó¶(f, g) = (f ‚Ä≤ ‚ó¶f, g‚Ä≤ ‚ó¶g) : (C, D) ‚àí‚Üí(C‚Ä≤‚Ä≤, D‚Ä≤‚Ä≤)
2.6.7 The dual of a category
Given any category C , you can construct another category denoted
C op by reversing all the arrows. The dual or opposite C op of a category C is deÔ¨Åned by:
D‚Äì1 The objects and arrows of C op are the objects and arrows of C .
D‚Äì2 If f : A ‚àí‚ÜíB in C , then f : B ‚àí‚ÜíA in C op.
D‚Äì3 If h = g ‚ó¶f in C , then h = f ‚ó¶g in C op.
The meaning of D‚Äì2 is that source and target have been reversed. It is easy to see that the identity
arrows have to be the same in the two categories C and C op and that C‚Äì1 through C‚Äì4 of Section 2.1
hold, so that C op is a category.
2.6.8 Example
If M is a monoid, then the opposite of the category C(M) is the category determined
by a monoid M op; if xy = z in M, then yx = z in M op. (Hence if M is commutative then C(M) is its
own dual. Similar remarks may be made about the opposite of the category C(P) determined by a poset
P. The opposite of the poset (Z, ‚â§), for example, is (Z, ‚â•).

2.6 Constructions on categories
15
2.6.9
Both the construction of the product of two categories and the construction of the dual of a
category are purely formal constructions. Even though the original categories may have, for example,
structure-preserving functions of some kind as arrows, the arrows in the product category are simply
pairs of arrows of the original categories.
Consider Set, for example. Let A be the set of letters of the English alphabet. The function v : A
‚àí‚Üí{0, 1} that takes consonants to 0 and vowels to 1 is an arrow of Set. Then the arrow (idA, v) : (A, A)
‚àí‚Üí(A, {0, 1}) of Set √ó Set is not a function, not even a function of two variables; it is merely the arrow
of a product category and as such is an ordered pair of functions.
A similar remark applies to duals. In Setop, v is an arrow from {0, 1} to A. And that is all it is. It is
in particular not a function from {0, 1} to A.
Nevertheless, it is possible in some cases to prove that the dual of a familiar category is essentially
the same as some other familiar category. One such category is Fin, which is equivalent to the opposite
of the category of Ô¨Ånite Boolean algebras.
The product of categories is a formal way to make constructions dependent on more than one variable.
The major use we make of the concept of dual is that many of the deÔ¨Ånitions we make have another
meaning when applied to the dual of a category that is often of independent interest. The phrase dual
concept or dual notion is often used to refer to a concept or notion applied in the dual category.
2.6.10 Slice categories
If C is a category and A any object of C , the slice category C /A is described
this way:
SC‚Äì1 An object of C /A is an arrow f : C ‚àí‚ÜíA of C for some object C.
SC‚Äì2 An arrow of C /A from f : C ‚àí‚ÜíA to f ‚Ä≤ : C‚Ä≤ ‚àí‚ÜíA is an arrow h : C ‚àí‚ÜíC‚Ä≤ with the property that
f = f ‚Ä≤ ‚ó¶h.
SC‚Äì3 The composite of h : f ‚àí‚Üíf ‚Ä≤ and h‚Ä≤ : f ‚Ä≤ ‚àí‚Üíf ‚Ä≤‚Ä≤ is h‚Ä≤ ‚ó¶h.
It is necessary to show that h‚Ä≤ ‚ó¶h, as deÔ¨Åned in SC‚Äì2, satisÔ¨Åes the requirements of being an arrow
from f to f ‚Ä≤‚Ä≤. Let h : f ‚àí‚Üíf ‚Ä≤ and h‚Ä≤ : f ‚Ä≤ ‚àí‚Üíf ‚Ä≤‚Ä≤. This means f ‚Ä≤
‚ó¶h = f and f ‚Ä≤‚Ä≤
‚ó¶h‚Ä≤ = f ‚Ä≤. To show
that h‚Ä≤ ‚ó¶h : f ‚àí‚Üíf ‚Ä≤‚Ä≤ is an arrow of C /A, we must show that f ‚Ä≤‚Ä≤ ‚ó¶(h‚Ä≤ ‚ó¶h) = f. That follows from this
calculation:
f ‚Ä≤‚Ä≤ ‚ó¶(h‚Ä≤ ‚ó¶h) = (f ‚Ä≤‚Ä≤ ‚ó¶h‚Ä≤) ‚ó¶h = f ‚Ä≤ ‚ó¶h = f
The usual notation for arrows in C /A is deÔ¨Åcient: the same arrow h can satisfy f = f ‚Ä≤
‚ó¶h and
g = g‚Ä≤ ‚ó¶h with f Ã∏= g or f ‚Ä≤ Ã∏= g‚Ä≤ (or both). Then h : f ‚àí‚Üíf ‚Ä≤ and h : g ‚àí‚Üíg‚Ä≤ are diÔ¨Äerent arrows of C /A.
2.6.11 Example
Let (P, Œ±) be a poset and let C(P) be the corresponding category as in 2.3.1. For an
element x ‚ààP, the slice category C(P)/x is the category corresponding to the set of elements greater
than or equal to x. The dual notion of coslice gives the set of elements less than or equal to a given
element.
2.6.12
The importance of slice categories comes in part with their connection with indexing. An S-
indexed set is a set X together with a function œÑ : X ‚àí‚ÜíS. If x ‚ààX and œÑ(x) = s then we say x is of
type s, and we also refer to X as a typed set.
The terminology ‚ÄòS-indexed set‚Äô is that used by category theorists. Many mathematicians would cast
the discussion in terms of the collection {œÑ ‚àí1(s) | s ‚ààS} of subsets of X, which would be called a family
of sets indexed by S.
2.6.13 Example
The set G = G0 ‚à™G1 of objects and arrows of a graph G is an example of a typed
set, typed by the function œÑ : G ‚àí‚Üí{0, 1} that takes a node to 0 and an arrow to 1. Note that this
depends on the fact that a node is not an arrow: G0 and G1 are disjoint.
2.6.14 Indexed functions
A function from a set X typed by S to a set X‚Ä≤ typed by the same set S
that preserves the typing (takes an element of type s to an element of type s) is exactly an arrow of the
slice category Set/S. Such a function is called an indexed function or typed function. It has been
fruitful for category theorists to pursue this analogy by thinking of objects of any slice category C /A as
objects of C indexed by A.

16
Categories
2.6.15 Example
A graph homomorphism f : G ‚àí‚ÜíH corresponds to a typed function according
to the construction in Example 2.6.13. However, there are typed functions between graphs that are not
graph homomorphisms, for example the function from the graph (1.1), page 1, to the graph (1.3), page 2,
deÔ¨Åned by
1 7‚Üí1, 2 7‚Üín, a 7‚Üí0, b 7‚Üí0, c 7‚Üísucc
This is not a graph homomorphism because it does not preserve source and target.
2.6.16 The free category generated by a graph
For any given graph G there is a category F(G )
whose objects are the nodes of G and whose arrows are the paths in G . Composition is deÔ¨Åned by the
formula
(f1, f2, . . . , fk) ‚ó¶(fk+1, . . . , fn) = (f1, f2, . . . , fn)
This composition is associative, and for each object A, idA is the empty path from A to A. The category
F(G ) is called the free category generated by the graph G . It is also called the path category of
G .
2.6.17 Examples
The free category generated by the graph with one node and no arrows is the
category with one object and only the identity arrow, which is the empty path. The free category
generated by the graph with one node and one loop on the node is the free monoid with one generator
(Kleene closure of a one-letter alphabet); this is isomorphic with the nonnegative integers with + as
operation.
The free category generated by the graph in Example 1.1.5 has the following arrows
(a) An arrow id1 : 1 ‚àí‚Üí1.
(b) For each nonnegative integer k, the arrow succk : n ‚àí‚Üín. This is the path (succ, succ, . . . , succ) (k
occurrences of succ). This includes k = 0 which gives idn.
(c) For each nonnegative integer k, the arrow succk ‚ó¶0 : 1 ‚àí‚Üín. Here k = 0 gives 0 : 1 ‚àí‚Üín.
Composition obeys the rule succk ‚ó¶succm = succk+m.
2.6.18
It is useful to regard the free category generated by any graph as analogous to Kleene closure
(free monoid) generated by a set (as in 2.3.9). The paths in the free category correspond to the strings
in the Kleene closure. The diÔ¨Äerence is that you can concatenate any symbols together to get a string,
but arrows can be strung together only head to tail, thus taking into account the typing.
In 9.2.3 we give a precise technical meaning to the word ‚Äòfree‚Äô.

3. Properties of objects and
arrows in a category
The data in the deÔ¨Ånition of category can be used to deÔ¨Åne properties that the objects and arrows of
the category may have. A property that is deÔ¨Åned strictly in terms of the role the object or arrow has in
the category, rather than in terms of what it really is in any sense, is called a categorical deÔ¨Ånition.
Such deÔ¨Ånitions are abstract in the sense that a property a thing can have is deÔ¨Åned entirely in terms of
the external interactions of that thing with other entities.
The examples of categorical deÔ¨Ånitions in this chapter are of several simple concepts that can be
expressed directly in terms of the data used in the deÔ¨Ånition of category. Other concepts, such as limit,
naturality and adjunction, require deeper ideas that will be the subject of succeeding chapters.
3.1 Isomorphisms
In general, the word ‚Äòisomorphic‚Äô is used in a mathematical context to mean indistinguishable in form. We
have already used it in this way in 2.5.6. It turns out that it is possible to translate this into categorical
language in a completely satisfactory way. To do this, we Ô¨Årst need the concept of inverse.
3.1.1 DeÔ¨Ånition
Suppose f : A ‚àí‚ÜíB and g : B ‚àí‚ÜíA are arrows in a category for which f ‚ó¶g is the
identity arrow of B and g ‚ó¶f is the identity arrow of A. Then g is an inverse to f, and, of course, f is
an inverse to g.
3.1.2
As an example of how to use the deÔ¨Ånition of inverse, we show that if f : A ‚àí‚ÜíB has an inverse,
it has only one. Suppose g : B ‚àí‚ÜíA and h : B ‚àí‚ÜíA have the properties that g ‚ó¶f = h ‚ó¶f = idA and
f ‚ó¶g = f ‚ó¶h = idB. Then
g = g ‚ó¶idB = g ‚ó¶(f ‚ó¶h) = (g ‚ó¶f) ‚ó¶h = idA ‚ó¶h = h
Note that this does not use the full power of the hypothesis.
From this uniqueness, we can conclude that if f : A ‚àí‚ÜíA has an inverse, then (f ‚àí1)‚àí1 = f. Proof:
All four of the following equations are true by deÔ¨Ånition of inverse:
(i) f ‚àí1 ‚ó¶f = idA.
(ii) f ‚ó¶f ‚àí1 = idA.
(iii) f ‚àí1 ‚ó¶(f ‚àí1)‚àí1 = idA.
(iv) (f ‚àí1)‚àí1 ‚ó¶f ‚àí1 = idA.
It follows that both f and (f ‚àí1)‚àí1 are arrows g such that f ‚àí1
‚ó¶g = idA and g ‚ó¶f ‚àí1 = idA. Thus
f = (f ‚àí1)‚àí1 by uniqueness of the inverse of f ‚àí1.
3.1.3 Proposition
If f : A ‚àí‚ÜíB and g : B ‚àí‚ÜíC are isomorphisms in a category with inverses f ‚àí1 : B
‚àí‚ÜíA and g‚àí1 : C ‚àí‚ÜíB, then g ‚ó¶f is an isomorphism with inverse f ‚àí1 ‚ó¶g‚àí1.
The proof is omitted. This Proposition is sometimes called the ‚ÄòShoe‚ÄìSock Theorem‚Äô: to undo the
act of putting on your socks, then your shoes, you have to take oÔ¨Äyour shoes, then your socks.)
3.1.4 DeÔ¨Ånition
Suppose that C is a category and that A and B are two objects of C . An arrow
f : A ‚àí‚ÜíB is said to be an isomorphism if it has an inverse. In that case, we say that A is isomorphic
to B, written A ‚àº= B.
In a monoid, an element which is an isomorphism in the corresponding category is usually called
invertible.
3.1.5 DeÔ¨Ånition
An arrow f : A ‚àí‚ÜíA in a category (with the source and target the same) is called
an endomorphism. If it is invertible, it is called an automorphism.
17

18
Properties of objects and arrows
3.1.6 Examples
Any identity arrow in any category is an isomorphism (hence an automorphism). In
the category determined by a partially ordered set, the only isomorphisms are the identity arrows. If,
in the category determined by a monoid, every arrow is an isomorphism the monoid is called a group.
Because of this, a category in which every arrow is an isomorphism is called a groupoid.
In the category of semigroups and semigroup homomorphisms, and likewise in the category of monoids
and monoid homomorphisms, the isomorphisms are exactly the bijective homomorphisms. On the other
hand, in the category of posets and monotone maps, there are bijective homomorphisms that have no
inverse.
3.1.7 DeÔ¨Ånition
A property that objects of a category may have is preserved by isomorphisms
if for any object A with the property, any object isomorphic to A must also have the property.
3.1.8
From the categorist‚Äôs point of view there is no reason to distinguish between two isomorphic
objects in a category, since the interesting fact about a mathematical object is the way it relates to
other mathematical objects and two isomorphic objects relate to other objects in the same way. For
this reason, the concept of wide category (DeÔ¨Ånition 2.6.4) is not in the spirit of category theory. What
really should matter is whether the subcategory contains an isomorphic copy of every object in the big
category. This motivates the following deÔ¨Ånition.
3.1.9 DeÔ¨Ånition
A subcategory D of a category C is said to be a representative subcategory if
every object of C is isomorphic to some object of D.
3.1.10 Example
Let D be the category whose objects are the empty set and all sets of the form
{1, 2, . . . , n} for some positive integer n and whose arrows are all the functions between them. Then D
is a representative subcategory of Fin (DeÔ¨Ånition 2.1.12), since there is a bijection from any nonempty
Ô¨Ånite set to some set of the form {1, 2, . . . , n}. Note that D is also full in Fin.
3.2 Terminal and initial objects
An object T of a category C is called terminal if there is exactly one arrow A ‚àí‚ÜíT for each object A
of C . We usually denote the terminal object by 1 and the unique arrow A ‚àí‚Üí1 by ‚ü®‚ü©.
The dual notion (see 2.6.7), an object of a category that has a unique arrow to each object (including
itself), is called an initial object and is often denoted 0.
3.2.1 Examples
In the category of sets, the empty set is initial and any one-element set is terminal.
Thus the category of sets has a unique initial object but many terminal objects. The one-element monoid
is both initial and terminal in the category of monoids. In the category determined by a poset, an object
is initial if and only if it is an absolute minimum for the poset, and it is terminal if and only if it is
an absolute maximum. Since there is no largest or smallest whole number, the category determined by
the set of integers with its natural order (there is an arrow from m to n if and only if m ‚â§n) gives an
example of a category without initial or terminal object.
In the category of semigroups, the empty semigroup (see 2.3.6) is the initial object and any one-
element semigroup is a terminal object. On the other hand, the category of nonempty semigroups does
not have an initial object. Warning: To prove this, it is not enough to say that the initial object in the
category of semigroups is the empty semigroup and that semigroup is missing here! You have to show
that no other object can be the initial object in the smaller category. One way to do this is to let U be
the semigroup with two elements 1 and e with 1 ¬∑ e = e ¬∑ 1 = e, 1 ¬∑ 1 = 1 and e ¬∑ e = e. Then any nonempty
semigroup S has two homomorphisms to U: the constant function taking everything to 1 and the one
taking everything to e. Thus no nonempty semigroup S can be the initial object.
In the category of graphs and graph homomorphisms, the graph with one node and one arrow is the
terminal object.

3.3 Monomorphisms and subobjects
19
3.2.2 Proposition
Any two terminal (respectively initial) objects in a category are isomorphic.
Proof. Suppose T and T ‚Ä≤ are terminal objects. Since T is terminal, there is an arrow f : T ‚Ä≤ ‚àí‚ÜíT.
Similarly, there is an arrow g : T ‚àí‚ÜíT ‚Ä≤. The arrow f ‚ó¶g : T ‚àí‚ÜíT is an arrow with target T. Since T is
a terminal object of the category, there can be only one arrow from T to T. Thus it must be that f ‚ó¶g
is the identity of T. An analogous proof shows that g ‚ó¶f is the identity of T ‚Ä≤.
3.2.3 Constants
In Set, an element x of a set A is the image of a function from a singleton set to
A that takes the unique element of the singleton to x. Thus if we pick a speciÔ¨Åc singleton {‚àó} and call
it 1, the elements of the set A are in one to one correspondence with Hom(1, A), which is the set of
functions from the terminal object to A. Moreover, if f : A ‚àí‚ÜíB is a set function and x is an element of
A determining the function x : 1 ‚àí‚ÜíA, then the element f(x) of B is essentially the same thing as the
composite f
‚ó¶x : 1 ‚àí‚ÜíB. Because of this, the categorist typically thinks of an element x ‚ààA as being
the constant x : 1 ‚àí‚ÜíA.
An arrow 1 ‚àí‚ÜíA in a category, where 1 is the terminal object, is called a constant of type A. Thus
each element of a set is a constant in Set. On the other hand, each monoid M has just one constant 1
‚àí‚ÜíM in the category of monoids, since monoid homomorphisms must preserve the identity.
The more common name in the categorical literature for a constant is global element of A, a name
that comes from sheaf theory (see Section 11.4).
A terminal object is an object with exactly one arrow ‚ü®‚ü©: A ‚àí‚Üí1 to it from each object A. So the arrows to
1 are not interesting. Global elements are arrows from the terminal object. There may be none or many, so
they are interesting.
3.2.4
If 1 and 1‚Ä≤ are two terminal objects in a category and x : 1 ‚àí‚ÜíA and x‚Ä≤ : 1‚Ä≤ ‚àí‚ÜíA are two
constants with the property that x‚Ä≤ ‚ó¶‚ü®‚ü©= x (where ‚ü®‚ü©is the unique isomorphism from 1 to 1‚Ä≤), then
we regard x and x‚Ä≤ as the same constant. Think about this comment as it applies to elements in the
category of sets, with two diÔ¨Äerent choices of terminal object, and you will see why.
3.3 Monomorphisms and subobjects
3.3.1 Monomorphisms
A function f : A ‚àí‚ÜíB in Set is injective if for any x, y ‚ààA, if x Ã∏= y, then
f(x) Ã∏= f(y). A monomorphism is a particular type of arrow in a category which generalizes the concept of
injective function; in particular, a monomorphism in the category of sets is exactly an injective function.
If f is an arrow in an arbitrary category, we use the same deÔ¨Ånition, except for one change required
because the concept of ‚Äòelement‚Äô no longer makes sense.
3.3.2 DeÔ¨Ånition
f : A ‚àí‚ÜíB is a monomorphism if for any object T of the category and any arrows
x, y : T ‚àí‚ÜíA, if x Ã∏= y, then f ‚ó¶x Ã∏= f ‚ó¶y.
We often write f : A )‚àí‚ÜíB to indicate that f is a monomorphism and say that f is monic or that
f is mono.
In DeÔ¨Ånition 3.3.2 and many like it, what replaces the concept of element of A is an arbitrary arrow
into A. In this context, an arbitrary arrow a : T ‚àí‚ÜíA is called a variable element of A, parametrized
by T. When a is treated as a variable element and f has source A, one may write f(a) for f ‚ó¶a. Using
this notation, f is a monomorphism if for any variable elements x, y : T ‚àí‚ÜíA, if x Ã∏= y, then f(x) Ã∏= f(y).
The following theorem validates the claim that ‚Äòmonomorphism‚Äô is the categorical version of ‚Äòinjec-
tive‚Äô.
3.3.3 Theorem
In the category of sets, a function is injective if and only if it is a monomorphism.
Proof. Suppose f : A ‚àí‚ÜíB is injective, and let a, a‚Ä≤ : T ‚àí‚ÜíA be variable elements of A. If a Ã∏= a‚Ä≤ then
there is an (ordinary) element t ‚ààT for which a(t) Ã∏= a‚Ä≤(t). Then f(a(t)) Ã∏= f(a‚Ä≤(t)), so f
‚ó¶a Ã∏= f
‚ó¶a‚Ä≤.
Hence f is monic.
Conversely, suppose f is monic. Since global elements (see 3.2.3) are elements, this says that for
any global elements x, y : 1 ‚àí‚ÜíA with x Ã∏= y, f
‚ó¶x Ã∏= f
‚ó¶y, i.e., f(x) Ã∏= f(y), which means that f is
injective.

20
Properties of objects and arrows
3.3.4 Remark
An arrow that is a monomorphism in a category is a monomorphism in any subcategory
it happens to be in. However, an arrow can be a monomorphism in a subcategory of a category C without
being a monomorphism in C .
3.3.5 Examples
In most familiar categories of sets with structure and functions that preserve struc-
ture, the monomorphisms are exactly the injective functions. In particular, the monomorphisms in Mon
are the injective homomorphisms (proved in 3.3.6 below). This is evidence that DeÔ¨Ånition 3.3.2 is the
correct categorical deÔ¨Ånition generalizing the set-theoretic concept of injectivity.
In the category determined by a poset, every arrow is monic. A monic element of the category
determined by a monoid is generally called left cancellable.
An isomorphism in any category is a monomorphism. For suppose f is an isomorphism and f ‚ó¶x =
f ‚ó¶y. This calculation shows that x = y:
x = f ‚àí1 ‚ó¶f ‚ó¶x = f ‚àí1 ‚ó¶f ‚ó¶y = y
3.3.6
We now show that a monomorphism in the category of monoids is an injective homomorphism,
and conversely.
Let f : M ‚àí‚ÜíM ‚Ä≤ be a monoid homomorphism. Suppose it is injective. Let g, h : V ‚àí‚ÜíM be homo-
morphisms for which f ‚ó¶g = f ‚ó¶h. For any v ‚ààV , f(g(v)) = f(h(v)), so g(v) = h(v) since f is injective.
Hence g = h. It follows that f is a monomorphism. Essentially the same proof works in other categories
of structures and structure-preserving maps ‚Äì if the map is injective it is a monomorphism for the same
reason as in Set.
However, the converse deÔ¨Ånitely does not work that way. The proof for Set in Theorem 3.3.3 above
uses distinct global elements x and y, but a monoid need not have distinct global elements. For example,
let N denote the monoid of nonnegative integers with addition as operation. Then the only global element
of N on addition is 0. So we have to work harder to get a proof.
Suppose f is a monomorphism. Let x, y ‚ààM be distinct elements. Let px : N ‚àí‚ÜíM take k to xk
and similarly deÔ¨Åne py; px and py are homomorphisms since for all x, xk+n = xkxn (see 2.3.5 and the
discussion after DeÔ¨Ånition 3.3.2). Since x Ã∏= y, px and py are distinct homomorphisms. If f(x) = f(y)
then for all positive integers k,
f(px(k)) = f(xk) = f(x)k = f(y)k = f(yk) = f(py(k))
so that f ‚ó¶px = f ‚ó¶py which would mean that f is not a monomorphism. Thus we must have f(x) Ã∏= f(y)
so that f is injective.
The trick in the preceding paragraph was to Ô¨Ånd an object (N here) that allows one to distinguish
elements of the arbitrary monoid M. In Set, the corresponding object was the terminal object, but that
does not work for Mon: each monoid has exactly one global element because a map from the one-element
monoid must have the identity element as value.
We now state two propositions that give some elementary properties of monomorphisms.
3.3.7 Proposition
Suppose f : A ‚àí‚ÜíB and g : B ‚àí‚ÜíC in a category C . Then
(a) If f and g are monomorphisms, so is g ‚ó¶f.
(b) If g ‚ó¶f is a monomorphism, so is f.
Proof. We prove the second statement and leave the Ô¨Årst to you. Suppose g ‚ó¶f is a monomorphism. To
show that f is a monomorphism, assume f ‚ó¶x = f ‚ó¶y for some arrows x, y : C ‚àí‚ÜíA. Then
(g ‚ó¶f) ‚ó¶x = g ‚ó¶(f ‚ó¶x) = g ‚ó¶(f ‚ó¶y) = (g ‚ó¶f) ‚ó¶y
so, since g ‚ó¶f is a monomorphism, x = y.
3.3.8 Proposition
Let m : C ‚àí‚Üí0 be a monomorphism into an initial object. Then m is an isomorph-
ism.
Proof. Let i : 0 ‚àí‚ÜíC be the unique arrow given by deÔ¨Ånition of initial object. Then m ‚ó¶i and id0 are
both arrows from 0 to 0 and so must be the same. It remains to show that i ‚ó¶m = idC. This follows
from the fact that m ‚ó¶i ‚ó¶m = m ‚ó¶idC and that m is a monomorphism.

3.3 Monomorphisms and subobjects
21
3.3.9 Subobjects
The concept of subobject is intended to generalize the concept of subset of a set,
submonoid of a monoid, subcategory of a category, and so on. This idea cannot be translated exactly into
categorical terms, since the usual concept of subset violates the strict typing rules of category theory:
to go from a subset to a set requires a change of type, so there is no feasible way to say that the same
element x is in both a set and a subset of the set.
Because of this, any categorical deÔ¨Ånition of subobject will not give exactly the concept of subset
when applied to the category of sets. However, the usual deÔ¨Ånition of subobject (which we give here in
DeÔ¨Ånition 3.3.12) produces, in Set, a concept that is naturally equivalent to the concept of subset in a
strong sense that we will describe in 3.3.13. The deÔ¨Ånition, when applied to sets, deÔ¨Ånes subset in terms
of the inclusion function.
3.3.10
We need a preliminary idea. If f : A ‚àí‚ÜíB is an arrow in a category, and for some arrow g : C
‚àí‚ÜíB there is an arrow h : A ‚àí‚ÜíC for which f = g ‚ó¶h, we say f factors through g. This is because
the equation g ‚ó¶h = f can be solved for h.
The use of the word ‚Äòfactor‚Äô shows the explicit intention of categorists to work with functions in an algebraic
manner: a category is an algebra of functions.
Suppose f0 : C0 ‚àí‚ÜíC and f1 : C1 ‚àí‚ÜíC are monomorphisms in a category. Let us say that f0 ‚àºf1 if
each factors through the other.
3.3.11 Proposition
Let f0 ‚àºf1. Then the factors implied by the deÔ¨Ånition of ‚àºare unique and are
inverse isomorphisms. Moreover, the relation ‚àºis an equivalence relation on the collection of arrows
with target C.
Proof. The deÔ¨Ånition implies the existence of arrows g : C0 ‚àí‚ÜíC1 and h : C1 ‚àí‚ÜíC0 such that f1 ‚ó¶g = f0
and f0
‚ó¶h = f1. The arrows g and h are unique because f0 and f1 are monomorphisms. Moreover,
f1 ‚ó¶g ‚ó¶h = f0 ‚ó¶h = f1 = f1 ‚ó¶id; since f1 is a monomorphism, we conclude that g ‚ó¶h = id. Similarly,
h ‚ó¶g = id.
That ‚àºis reÔ¨Çexive follows by taking the factor to be the identity arrow, and it is symmetric by
deÔ¨Ånition. For transitivity, you get the required factor by composing the given factors; we leave the
details to you.
3.3.12 DeÔ¨Ånition
In a category C , a subobject of an object C is an equivalence class of mono-
morphisms under ‚àº. The subobject is a proper subobject if it does not contain idC.
Observe that it follows immediately from Proposition 3.3.8 that an initial object in a category has
no proper subobjects.
3.3.13 Subobjects in the category of sets
In Set, a monomorphism is an injection, so a subobject
is an equivalence class of injections. The following sequence of statements are each easy to prove and
together form a precise description of the connection between subobjects and subsets in the category
of sets. Similar remarks can be made about other categories of sets with structure, such as semigroups,
monoids or posets.
In these statements, S is a set.
(a) Let O be a subobject of S.
(i) Any two injections m : A ‚àí‚ÜíS and n : B ‚àí‚ÜíS in O have the same image; call the image I.
(ii) The inclusion i : I ‚àí‚ÜíS is equivalent to any injection in O, hence is an element of O.
(iii) If j : J ‚àí‚ÜíS is an inclusion of a subset J into S that is in O, then I = J and i = j.
(iv) Hence every subobject of S contains exactly one inclusion of a subset of S into S, and that
subset is the image of any element of O.
(b) Let i : T ‚àí‚ÜíS be the inclusion of a subset T of S into S.
(i) Since i is injective, it is an element of a subobject of S.
(ii) Since the subobjects are equivalence classes of an equivalence relation, they are disjoint, so i
is not in two subobjects.

22
Properties of objects and arrows
(iii) Hence the subsets of S with their inclusion maps form a complete set of class representatives
for the subobjects of S.
Thus subobjects, given by a categorical deÔ¨Ånition, are not the same as subsets, but each subset
determines and is determined by a unique subobject.
Because of this close relationship, one frequently says, of objects A and B in a category, ‚ÄòLet A be
a subobject of B‚Äô, meaning that one has in mind a certain equivalence class of monomorphisms that
in particular contains a monomorphism A )‚àí‚ÜíB. You should be aware that there may be many other
monomorphisms from A to B that are not in the equivalence class, just as from any subset A of a set B
there are generally many injective functions from A to B other than the inclusion.
3.3.14
As a consequence of the properties of the subobject construction, categorists take a diÔ¨Äerent
attitude toward substructures such as subsets and submonoids, as compared to many other mathemati-
cians. For them, A is a subobject or substructure of B if there is a monomorphism from A to B, and the
subobject is the equivalence class determined by that monomorphism. For example, let Z denote the set
of integers and R the set of real numbers. In calculus classes, Z is a subset of R; an integer actually is a
real number. For the categorist, it suÔ¨Éces that there be a monic (injective) map from Z to R.
That monic map is a kind of type conversion. (See [Reynolds, 1980] for a more general view.) An
integer need not actually be thought of as a real number, but there is a standard or canonical way
(translate this statement as ‚Äòa monic map‚Äô) to regard an integer as a real number. This mapping is
regarded by the categorist as an inclusion, even though in fact it may change what the integer really is.
In a computer language, converting an integer to a real may increase the storage allotted to it
and change its representation. Something similar happens in many approaches to the foundations of
mathematics, where real numbers are constructed from integers by a complicated process (Dedekind
cuts or Cauchy sequences), which results in an embedding of the integers in the real numbers. Just as for
computer languages, this embedding changes the form of an integer: instead of whatever it was before,
it is now a Dedekind cut (or Cauchy sequence).
In traditional texts on foundations, this construction had to be modiÔ¨Åed to replace the image of
each integer by the actual integer, so that the integers were actually inside the real numbers. From
the categorical point of view, this is an unnecessary complication. This change results in replacing a
monomorphism Z ‚àí‚ÜíR by an equivalent monomorphism (one that determines the same subobject).
From an operational point of view, the integers behave the same way whether this change is made or
not.
3.3.15 Categories and typing
In category theory, the inclusion map is usually made explicit. From
the computing science point of view, category theory is a very strongly typed language, more strongly
typed than any computer language. For example, the strict categorist will refer explicitly to the inclusion
map from the nonzero real numbers to the set of all real numbers when talking of division. In a computer
language this would correspond to having two diÔ¨Äerent types, REAL and NONZERO REAL, set up in such a
way that you can divide a REAL only by a NONZERO REAL. To multiply a REAL by a NONZERO REAL, the
strong typing would require you to convert the latter to a REAL Ô¨Årst.
To be sure, categorists themselves are not always so strict; but when they are not strict they are
aware of it. Nor is this discussion meant to imply that computer languages should have such strict typing:
rather, the intention is to illustrate the way category theory handles types.)
3.4 Other types of arrow
3.4.1 Epimorphisms
Epimorphisms in a category are the same as monomorphisms in the dual cat-
egory. So f : S ‚àí‚ÜíT is an epimorphism if for any arrows g, h : T ‚àí‚ÜíX, g ‚ó¶f = h ‚ó¶f implies g = h. An
epimorphism is said to be epic or an epi, and may be denoted with a double-headed arrow, as in f : S
‚àí‚Üí‚ÜíT.
3.4.2 Proposition
A set function is an epimorphism in Set if and only if it is surjective.

3.4 Other types of arrow
23
Proof. Suppose f : S ‚àí‚ÜíT is surjective, and g,h : T ‚àí‚ÜíX are two functions. If g Ã∏= h, then there is some
particular element t ‚ààT for which g(t) Ã∏= h(t). Since f is surjective, there is an element s ‚ààS for which
f(s) = t. Then g(f(s)) Ã∏= h(f(s)), so that g ‚ó¶f Ã∏= h ‚ó¶f.
Conversely, suppose f is not surjective. Then there is some t ‚ààT for which there is no s ‚ààS such
that f(s) = t. Now deÔ¨Åne two functions g : T ‚àí‚Üí{0, 1} and h : T ‚àí‚Üí{0, 1} as follows:
(i) g(x) = h(x) = 0 for all x in T except t.
(ii) g(t) = 0.
(iii) h(t) = 1.
Then g Ã∏= h but g ‚ó¶f = h ‚ó¶f, so f is not an epimorphism.
3.4.3
In contrast to the situation with monomorphisms, epimorphisms in categories of sets with struc-
ture are commonly not surjective. For example the nonnegative integers and the integers are both monoids
under addition, and the inclusion function i is a homomorphism which is certainly not surjective. How-
ever, it is an epimorphism. (Note that surjective homomorphisms in the category of monoids are always
epimorphisms.)
Here is the proof: any homomorphism h whose domain is the integers is determined completely by
its value h(1). For positive m, m = 1 + 1 + ¬∑ ¬∑ ¬∑ + 1, so
h(m) = h(1 + 1 + ¬∑ ¬∑ ¬∑ + 1) = h(1)h(1) ¬∑ ¬∑ ¬∑ h(1)
where we write the operation in the codomain as juxtaposition. Also, h(‚àí1) is the inverse of h(1), since
h(1)h(‚àí1) = h(‚àí1)h(1) = h(‚àí1 + 1) = h(0)
which must be the identity of the codomain. Since an element of a monoid can have only one inverse,
this means h(‚àí1) is uniquely determined by h(1). Then since every negative integer is a sum of ‚àí1‚Äôs,
the value of h at every negative integer is also determined by its value at 1.
Now suppose that g and h are two homomorphisms from the monoid of integers into the same
codomain. Then g and h are both determined by their value at 1. Since 1 is a positive integer, this means
that if g ‚ó¶i = h ‚ó¶i, then g = h. Thus i is an epimorphism.
3.4.4 Proposition
Let f : A ‚àí‚ÜíB and g : B ‚àí‚ÜíC. Then
(a) If f and g are epimorphisms, so is g ‚ó¶f.
(b) If g ‚ó¶f is an epimorphism, so is g.
Proof. This is the dual of Proposition 3.3.7.
3.4.5 Proposition
A homomorphism f : G ‚àí‚ÜíH of graphs is an epimorphism if and only if both
f0 : G0 ‚àí‚ÜíH0 and f1 : G1 ‚àí‚ÜíH1 are surjective.
The proof is omitted. A similar statement is true for monomorphisms of graphs.
3.4.6
In Set an arrow that is both monic and epic is bijective (Theorems 3.3.3 and 3.4.2), and hence an
isomorphism. In general, this need not happen. One example is the inclusion of N in Z in Mon described
in 3.4.3 (an inverse would also have to be an inverse in Set, but there isn‚Äôt one since the inclusion is
not bijective). An easier example is the arrow from C to D in the category 2 in (2.1). It is both monic
and epic (vacuously) but there is no arrow from D to C so it is not an isomorphism because there is no
arrow in the category that could be its inverse.
3.4.7
An arrow f : A ‚àí‚ÜíB in a category is an isomorphism if it has an inverse g : B ‚àí‚ÜíA which
must satisfy both the equations g ‚ó¶f = idA and f
‚ó¶g = idB. If it only satisÔ¨Åes the second equation,
f ‚ó¶g = idB, then f is a left inverse of g and (as you might expect) g is a right inverse of f.

24
Properties of objects and arrows
3.4.8 DeÔ¨Ånition
Suppose f has a right inverse g. Then f is called a split epimorphism (f is ‚Äúsplit
by g‚Äù) and g is called a split monomorphism.
A split epimorphism is indeed an epimorphism: if h ‚ó¶f = k ‚ó¶f and f has a right inverse g, then
h = h ‚ó¶f ‚ó¶g = k ‚ó¶f ‚ó¶g = k, which is what is required for f to be an epimorphism. A dual proof shows
that a split monomorphism is a monomorphism.
Using the usual axioms of set theory, every surjection in Set is a split epimorphism. For if f : A
‚àí‚ÜíB, then choose, for each b ‚ààB, some element a ‚ààA such that f(a) = b. The existence of such an a is
guaranteed by surjectivity. DeÔ¨Åne g(b) to be a. Then f(g(b)) = f(a) = b for any b ‚ààB, so f ‚ó¶g = idB.
The so-called axiom of choice is exactly what is required to make all those generally inÔ¨Ånitely many choices.
And in fact, one possible formulation of the axiom of choice is that every epimorphism split.
Epimorphisms in other categories may not be split. The function that includes the monoid of non-
negative integers on addition in the monoid of all the integers on addition, which we mentioned in 3.4.3,
certainly does not have a right inverse in the category of monoids, since it does not have a right inverse
in the category of sets. There are plenty of examples of epimorphisms of monoids which are surjective
which have no right inverse in the category of monoids, although of course they do in the category of
sets. One such epimorphism of monoids is the function that takes the integers mod 4 on addition to the
integers mod 2 on addition, with 0 and 2 going to 0 and 1 and 3 going to 1.
Unlike epis, which always split in the category of sets, monics in Set do not always split. Every arrow
out of the empty set is monic and, save for the identity of ‚àÖto itself, is not split. On the other hand,
every monic with nonempty source does split. We leave the details to you.
3.4.9 Hom sets
The elementary categorical deÔ¨Ånitions given in the last section and this one can all
be phrased in terms of hom set. In any category, Hom(A,B) is the set of arrows with source A and target
B.
Thus a terminal object 1 satisÔ¨Åes the requirement that Hom(A, 1) is a singleton set for every object
A, and an initial object 0 satisÔ¨Åes the dual requirement that Hom(0, A) is always a singleton. And
Hom(1, A) is the set of constants (global elements) of A.
3.4.10
If f : B ‚àí‚ÜíC, f induces a set function
Hom(A, f) : Hom(A, B) ‚àí‚ÜíHom(A, C)
deÔ¨Åned by composing by f on the left: for any g ‚ààHom(A,B), that is, for any g : A ‚àí‚ÜíB, Hom(A,f)(g) =
f ‚ó¶g, which does indeed go from A to C.
Similarly, for any object D, f : B ‚àí‚ÜíC induces a set function
Hom(f, D) : Hom(C, D) ‚àí‚ÜíHom(B, D)
(note the reversal) by requiring that Hom(f, D)(h) = h ‚ó¶f for h ‚ààHom(C, D).
In terms of these functions, we can state this proposition, which we leave to you to prove.
3.4.11 Proposition
An arrow f : B ‚àí‚ÜíC in a category
(i) is a monomorphism if and only if Hom(A, f) is injective for every object A;
(ii) is an epimorphism if and only if Hom(f, D) is injective (!) for every object D;
(iii) is a split monomorphism if and only if Hom(f, D) is surjective for every object D;
(iv) is a split epimorphism if and only if Hom(A, f) is surjective for every object A;
(v) is an isomorphism if and only if any one of the following equivalent conditions holds:
(a) it is both a split epi and a mono;
(b) it is both an epi and a split mono;
(c) Hom(A, f) is bijective for every object A;

3.4 Other types of arrow
25
(d) Hom(f, A) is bijective for every object A.
Although many categorical deÔ¨Ånitions can be given in terms of hom sets, no categorical deÔ¨Ånition must
be; in fact, some mathematicians consider category theory to be a serious alternative to set theory as a
foundation for mathematics (see many works of Lawvere, including [1963] and [1966] as well as [McLarty,
1989]) and for that purpose (which is not our purpose, of course), deÔ¨Ånition in terms of hom sets or any
other sets must be avoided.
3.4.12 Discussion
Categorical deÔ¨Ånitions, as illustrated in the simple ideas of the preceding sections,
provide a method of abstract speciÔ¨Åcation which has proved very useful in mathematics. They have, in
particular, clariÔ¨Åed concepts in many disparate branches of mathematics and provided as well a powerful
uniÔ¨Åcation of concepts across these branches.
The method of categorical deÔ¨Ånition is close in spirit to the modern attitude of computing science
that programs and data types should be speciÔ¨Åed abstractly before being implemented and that the
speciÔ¨Åcation should be kept conceptually distinct from the implementation. We believe that the method
of categorical deÔ¨Ånition is a type of abstract speciÔ¨Åcation which is suitable for use in many areas of
theoretical computing science. This is one of the major themes of this notes.
When a category C is a category of sets with structure, with the arrows being functions which
preserve the structure, a categorical deÔ¨Ånition of a particular property does not involve the elements (in
the standard sense of set theory) of the structure. Such deÔ¨Ånitions are said to be element-free, and
that has been regarded as a great advantage of category theory.
Nevertheless, as we have seen, some deÔ¨Ånitions can be phrased in terms of variable elements. This
allows us the option of using familiar modes of thinking about things in terms of elements even in general
categories. In the case of the deÔ¨Ånition of monomorphism 3.3.2, the deÔ¨Ånition phrased in terms of variable
elements is identical with the deÔ¨Ånition in Set. On the other hand, an epimorphism f (see 3.4.1) is a
variable element with the property that any two diÔ¨Äerent arrows out of its target must have diÔ¨Äerent
values at f. In some sense it is a variable element with a lot of variation. This is an example of a situation
where the variable element point of view is not very familiar.
The idea of variable element has much in common with the way mathematicians and physicists once
thought of variable quantities. Perhaps thirty years from now the variable element idea will be much
more pervasive and the idea that an epimorphism is an element with a lot of variation will be the natural
way to describe it.

4. Functors
A functor F from a category C to a category D is a graph homomorphism which preserves identities
and composition. It plays the same role as monoid homomorphisms for monoids and monotone maps
for posets: it preserves the structure that a category has. Functors have another signiÔ¨Åcance, however:
since one sort of thing a category can be is a mathematical workspace (see Preface), many of the most
useful functors used by mathematicians are transformations from one type of mathematics to another.
Less obvious, but perhaps more important, is the fact that many categories that are mathematically
interesting appear as categories whose objects are a natural class of functors into the category of sets.
4.1 Functors
A functor is a structure-preserving map between categories, in the same way that a homomorphism is a
structure-preserving map between graphs or monoids. Here is the formal deÔ¨Ånition.
4.1.1 DeÔ¨Ånition
A functor F : C ‚àí‚ÜíD is a pair of functions F0 : C0 ‚àí‚ÜíD0 and F1 : C1 ‚àí‚ÜíD1 for
which
F‚Äì1 If f : A ‚àí‚ÜíB in C , then F1(f) : F0(A) ‚àí‚ÜíF0(B) in D.
F‚Äì2 For any object A of C , F1(idA) = idF0(A).
F‚Äì3 If g ‚ó¶f is deÔ¨Åned in C , then F1(g) ‚ó¶F1(f) is deÔ¨Åned in D and F1(g ‚ó¶f) = F1(g) ‚ó¶F1(f).
By F‚Äì1, a functor is in particular a homomorphism of graphs. Following the practice for graph
homomorphisms, the notation is customarily overloaded (see 1.2.2): if A is an object, F(A) = F0(A) is
an object, and if f is an arrow, F(f) = F1(f) is an arrow. The notation for the constituents F0 : C0
‚àí‚ÜíD0 and F1 : C1 ‚àí‚ÜíD1 is not standard, and we will use it only for emphasis.
4.1.2 Example
It is easy to see that a monoid homomorphism f : M ‚àí‚ÜíN determines a functor
from C(M) to C(N) as deÔ¨Åned in 2.3.12. On objects, a homomorphism f must take the single object
of C(M) to the single object of C(N), and F‚Äì1 is trivially veriÔ¨Åed since all arrows in C(M) have the
same domain and codomain and similarly for C(N). Then F‚Äì2 and F‚Äì3 say precisely that f is a monoid
homomorphism. Conversely, every functor is determined in this way by a monoid homomorphism.
4.1.3 Example
Let us see what a functor from C(S, Œ±) to C(T, Œ≤) must be when (S, Œ±) and (T, Œ≤)
are posets as in 2.3.1. It is suggestive to write both relations Œ± and Œ≤ as ‚Äò‚â§‚Äô and the posets simply as S
and T. Then there is exactly one arrow from x to y in S (or in T) if and only if x ‚â§y; otherwise there
are no arrows from x to y.
Let f : S ‚àí‚ÜíT be the functor. F‚Äì1 says if there is an arrow from x to y, then there is an arrow from
f(x) to f(y); in other words,
if x ‚â§y then f(x) ‚â§f(y)
Thus f is a monotone map (see 2.4.2). F‚Äì2 and F‚Äì3 impose no additional conditions on f because they
each assert the equality of two speciÔ¨Åed arrows between two speciÔ¨Åed objects and in a poset as category
all arrows between two objects are equal.
4.1.4 The category of categories
The category Cat has all small categories as objects and all
functors between such categories as arrows. The composite of functors is their composite as graph
homomorphisms: if F : C ‚àí‚ÜíD and G : D ‚àí‚ÜíE , then G ‚ó¶F : C ‚àí‚ÜíE satisÔ¨Åes G ‚ó¶F(C) = G(F(C)) for
any object C of C , and G ‚ó¶F(f) = G(F(f)) for any arrow f of C . Thus (G ‚ó¶F)i = Gi ‚ó¶Fi for i = 0, 1.
We note that the composition circle is usually omitted when composing functors so that we write
GF(C) = G(F(C)).
It is sometimes convenient to refer to a category CAT which has all small categories and ordinary
large categories as objects, and functors between them. Since trying to have CAT be an object of itself
would raise delicate foundational questions, we do not attempt here a formal deÔ¨Ånition of CAT.
26

4.1 Functors
27
4.1.5 Properties of Cat
We note some properties without proof.
The initial category has no objects and, therefore, no arrows. The terminal category has just one
object and the identity arrow of that object. To any category C there is just one functor that takes every
object to that single object and every arrow to that one arrow.
A functor is a monomorphism in Cat if and only if it is injective on both objects and arrows. The
corresponding statement for epimorphisms is not true.
4.1.6 Example
If C is a category, the functor
P1 : C √ó C ‚àí‚ÜíC
(see 2.6.6) which takes an object (C, D) to C and an arrow (f, g) : (C, D) ‚àí‚Üí(C‚Ä≤, D‚Ä≤) to f is called the
Ô¨Årst projection. There is an analogous second projection functor P2 taking an object or arrow to its
second coordinate.
4.1.7 Example
Let 2 + 2 be the category that can be pictured as
0 ‚àí‚Üí1
1‚Ä≤ ‚àí‚Üí2
with no other nonidentity arrows, and the category 3 the one that looks like
0
1
-
2
@
@@
R
   	
(4.1)
DeÔ¨Åne the functor F : 2 + 2 ‚àí‚Üí3 to take 0 to 0, 1 and 1‚Ä≤ to 1, and 2 to 2. Then what it does on arrows
is forced.
Note that the image of F includes all of D except the composite arrow from 0 ‚àí‚Üí2. This example
shows that the image of a functor need not be a subcategory of the codomain category.
4.1.8 Example
The inclusion map of a subcategory is a functor. As we pointed out in 3.3.14, the
categorical point of view does not require that the object and arrows of a subcategory actually be
objects and arrows of the bigger category, only that there be a monomorphism from the subcategory
to the category. For example, Set is a subcategory of Rel: the monomorphic functor takes every set to
itself and each function f : S ‚àí‚ÜíT to its graph {(s, t) | t = f(s)}, which is indeed a relation from S to
T.
This approach has the strange result that two diÔ¨Äerent categories can each be regarded as subcate-
gories of the other one.
4.1.9 Underlying functors
Forgetting some of the structure in a category of structures and structure-
preserving functions gives a functor called an underlying functor or forgetful functor. The functor
U : Mon ‚àí‚ÜíSem which embeds the category of monoids into the category of semigroups by forgetting
that a monoid has an identity is an example of an underlying functor.
Another example is the functor which forgets all the structure of a semigroup. This is a functor
U : Sem ‚àí‚ÜíSet. There are lots of semigroups with the same set of elements; for example, the set
{0, 1, 2} is a semigroup on addition (mod 3) and also a diÔ¨Äerent semigroup on multiplication (mod 3).
The functor U applied to these two diÔ¨Äerent semigroups gives the same set, so U is not injective on
objects, in contrast to the forgetful functor from monoids to semigroups.
We will not give a formal deÔ¨Ånition of underlying functor. It is reasonable to expect any underlying
functor U to be faithful (see 4.3.2 below) and that if f is an isomorphism and U(f) is an identity arrow
then f is an identity arrow.
4.1.10 Example
A small graph has two underlying sets: its set of nodes and its set of arrows. Thus
there is an underlying functor U : Grf ‚àí‚ÜíSet √ó Set for which for a graph G , U(G ) = (G0, G1); an
arrowset functor A : Grf ‚àí‚ÜíSet which takes a graph to its set of arrows and a graph homomorphism
to the corresponding function from arrows to arrows; and a similarly deÔ¨Åned nodeset functor N : Grf
‚àí‚ÜíSet which takes a graph to its set of nodes.

28
Functors
4.1.11 Example
If you forget you can compose arrows in a category and you forget which arrows are
the identities, then you have remembered only that the category is a graph. This gives an underlying
functor U : Cat ‚àí‚ÜíGrf, since every functor is a graph homomorphism although not vice versa.
As for graphs, there are also set-of-objects and set-of-arrows functors O : Cat ‚àí‚ÜíSet and A : Cat
‚àí‚ÜíSet which take a category to its set of objects and set of arrows respectively, and a functor to the
appropriate set map.
4.1.12 Example
In 2.6.10, we described the notion of a slice category C /A based on a category C
and an object A. An object is an arrow B ‚àí‚ÜíA and an arrow from f : B ‚àí‚ÜíA to g : C ‚àí‚ÜíA is an arrow
h : B ‚àí‚ÜíC for which
g ‚ó¶h = f
There is a functor U : C /A ‚àí‚ÜíC that takes the object f : B ‚àí‚ÜíA to B and the arrow h from B ‚àí‚ÜíA
to C ‚àí‚ÜíA to h : B ‚àí‚ÜíC. This is called the underlying functor of the slice. In the case that C = Set, an
object T ‚àí‚ÜíS of Set/S for some set S is an S-indexed object, and the eÔ¨Äect of the underlying functor
is to forget the indexing.
4.1.13 Free functors
The free monoid functor from Set to the category of monoids takes a set
A to the free monoid F(A), which is the Kleene closure A‚àówith concatenation as operation (see 2.3.9),
and a function f : A ‚àí‚ÜíB to the function F(f) = f ‚àó: F(A) ‚àí‚ÜíF(B) deÔ¨Åned in 2.5.7.
To see that the free monoid functor is indeed a functor it is necessary to show that if f : A ‚àí‚ÜíB
and g : B ‚àí‚ÜíC, then F(g ‚ó¶f) : F(A) ‚àí‚ÜíF(C) is the same as F(g) ‚ó¶F(f), which is immediate from the
deÔ¨Ånition, and that it preserves identity arrows, which is also immediate.
The Kleene closure is itself a functor from Set to Set, taking A to A‚àóand f to f ‚àó. It is the composite
U ‚ó¶F of the underlying functor U : Mon ‚àí‚ÜíSet and the free functor F : Set ‚àí‚ÜíMon, but of course it
can be deÔ¨Åned independently of U and F.
4.1.14 Example
The free category on a graph is also the object part of a functor F : Grf ‚àí‚ÜíCat.
What it does to a graph is described in 2.6.16. Suppose œÜ : G ‚àí‚ÜíH is a graph homomorphism. The
objects of the free category on a graph are the nodes of the graph, so it is reasonable to deÔ¨Åne F(œÜ)0 = œÜ0.
Now suppose (fn, fn‚àí1, . . . , f1) is a path, that is, an arrow, in F(G ). Since functors preserve domain and
codomain, we can deÔ¨Åne F(œÜ)1(fn, fn‚àí1, . . . , f1) to be (œÜ1(fn), œÜ1(fn‚àí1), . . . , œÜ1(f1)) and know we get a
path in F(H ). That F preserves composition of paths is also clear.
4.1.15 The map-lifting property
The free category functor F : Grf ‚àí‚ÜíCat and also other free
functors, such as the free monoid functor (4.1.13), have a map lifting property called its universal
mapping property which will be seen in Section 9.2 as the deÔ¨Åning property of freeness. We will
describe the property for free categories since we use it later. The free monoid case is done in detail in
Proposition 9.1.2.
Let G be a graph and F(G ) the free category generated by G . There is a graph homomorphism with
the special name Œ∑G : G ‚àí‚ÜíU(F(G )) which includes a graph G into U(F(G )), the underlying graph of
the free category F(G ). The map (Œ∑G )0 is the identity, since the objects of F(G ) are the nodes of G . For
an arrow f of G , (Œ∑G )1(f) is the path (f) of length one. This is an inclusion arrow in the generalized
categorical sense of 3.3.14, since f and (f) are really two distinct entities.
4.1.16 Proposition
Let G be a graph and C a category. Then for every graph homomorphism h : G
‚àí‚ÜíU(C ), there is a unique functor bh : F(G ) ‚àí‚ÜíC with the property that U(bh) ‚ó¶Œ∑G = h.
Proof. If () is the empty path at an object a, we set bh() = ida. For an object a of F(G ) (that is, node
of G ), deÔ¨Åne bh(a) = h(a). And for a path (an, an‚àí1, . . . , a1), bh is ‚Äòmap h‚Äô:
bh(an, an‚àí1, . . . , a1) = (h(an), h(an‚àí1), . . . , h(a1))
As noted in 2.1.1, there is a unique empty path for each node a of G . Composing the empty path at
a with any path p from a to b gives p again, and similarly on the other side.

4.1 Functors
29
4.1.17 Powerset functors
Any set S has a powerset PS, the set of all subsets of S. There are three
diÔ¨Äerent functors F for which F0 takes a set to its powerset; they diÔ¨Äer on what they do to arrows. One
of them is fundamental in topos theory; that one we single out to be called the powerset functor.
If f : A ‚àí‚ÜíB is any set function and C is a subset of B, then the inverse image of C, denoted
f ‚àí1(C), is the set of elements of A which f takes into C: f ‚àí1(C) = {a ‚ààA | f(a) ‚ààC}. Thus f ‚àí1 is a
function from PB to PA.
Note that for a bijection f, the symbol f ‚àí1 is also used to denote the inverse function. Context makes
it clear which is meant, since the input to the inverse image function must be a subset of the codomain
of f, whereas the input to the actual inverse of a bijection must be an element of the codomain.
4.1.18 DeÔ¨Ånition
The powerset functor P : Setop ‚àí‚ÜíSet takes a set S to the powerset PS,
and a set function f : A ‚àí‚ÜíB (that is, an arrow from B to A in Setop) to the inverse image function
f ‚àí1 : PB ‚àí‚ÜíPA.
Although we will continue to use the notation f ‚àí1, it is denoted f ‚àóin much of the categorical
literature.
To check that P is a functor requires showing that id‚àí1
A
= idPA and that if g : B ‚àí‚ÜíC, then
(g ‚ó¶f)‚àí1 = f ‚àí1 ‚ó¶g‚àí1, where both compositions take place in Set.
4.1.19
A functor F : C op ‚àí‚ÜíD is also called a contravariant functor from C to D. As illustrated in
the preceding deÔ¨Ånition, the functor is often deÔ¨Åned in terms of arrows of C rather than of arrows of C op.
Opposite categories are most commonly used to provide a way of talking about contravariant functors
as ordinary (covariant) functors: the opposite category in this situation is a purely formal construction
of no independent interest (see 2.6.9).
4.1.20
The other two functors which take a set to its powerset are both covariant. The direct or
existential image functor takes f : A ‚àí‚ÜíB to the function f‚àó: PA ‚àí‚ÜíPB, where f‚àó(A0) = {f(x) |
x ‚ààA0}, the set of values of f on A0. The universal image functor takes A0 to those values of f which
come only from A0: formally, it takes f : A ‚àí‚ÜíB to f! : PA ‚àí‚ÜíPB, with
f!(A0) = {y ‚ààB | f(x) = y implies x ‚ààA0} = {y ‚ààB | f ‚àí1({y}) ‚äÜA0}
4.1.21 Hom functors
Let C be a category with an object C and an arrow f : A ‚àí‚ÜíB. In 3.4.10, we
deÔ¨Åned the function Hom(C, f) : Hom(C, A) ‚àí‚ÜíHom(C, B) by setting Hom(C, f)(g) = f
‚ó¶g for every
g ‚ààHom(C, A), that is for g : C ‚àí‚ÜíA. We use this function to deÔ¨Åne the covariant hom functor
Hom(C, ‚àí) : C ‚àí‚ÜíSet as follows:
HF‚Äì1 Hom(C, ‚àí)(A) = Hom(C, A) for each object A of C ;
HF‚Äì2 Hom(C, ‚àí)(f) = Hom(C, f) : Hom(C, A) ‚àí‚ÜíHom(C, B) for f : A ‚àí‚ÜíB.
The following calculations show that Hom(C, ‚àí) is a functor. For an object A, Hom(C, idA) :
Hom(C, A) ‚àí‚ÜíHom(C, A) takes an arrow f : C ‚àí‚ÜíA to idA ‚ó¶f = f; hence Hom(C, idA) = idHom(C,A).
Now suppose f : A ‚àí‚ÜíB and g : B ‚àí‚ÜíD. Then for any arrow k : C ‚àí‚ÜíA,

Hom(C, g) ‚ó¶Hom(C, f)

(k)
=
Hom(C, g)

Hom(C, f)(k)

=
Hom(C, g)(f ‚ó¶k)
=
g ‚ó¶(f ‚ó¶k)
=
(g ‚ó¶f) ‚ó¶k
=
Hom(C, g ‚ó¶f)(k)
In terms of variable elements, Hom(C, f) takes the variable elements of A with parameter set C to
the variable elements of B with parameter set C.
There is a distinct covariant hom functor Hom(C, ‚àí) for each object C. In this expression, C is a parameter
for a family of functors. The argument of each of these functors is indicated by the dash. An analogous
deÔ¨Ånition in calculus would be to deÔ¨Åne the function which raises a real number to the nth power as
f(‚àí) = (‚àí)n (here n is the parameter). One diÔ¨Äerence in the hom functor case is that the hom functor is
overloaded and so has to be deÔ¨Åned on two diÔ¨Äerent kinds of things: objects and arrows.

30
Functors
4.1.22 DeÔ¨Ånition
For a given object D, the contravariant hom functor
Hom(‚àí, D) : C op ‚àí‚ÜíSet
is deÔ¨Åned for each object A by
Hom(‚àí, D)(A) = Hom(A, D)
and for each arrow f : A ‚àí‚ÜíB,
Hom(‚àí, D)(f) = Hom(f, D) : Hom(B, D) ‚àí‚ÜíHom(A, D)
Thus if g : B ‚àí‚ÜíD, Hom(f, D)(g) = g ‚ó¶f.
4.1.23 DeÔ¨Ånition
The two-variable hom functor
Hom(‚àí, ‚àí) : C op √ó C ‚àí‚ÜíSet
takes a pair (C, D) of objects of C to Hom(C, D), and a pair (f, g) of arrows with f : C ‚àí‚ÜíA and g : B
‚àí‚ÜíD to
Hom(f, g) : Hom(A, B) ‚àí‚ÜíHom(C, D)
where for h : A ‚àí‚ÜíB,
Hom(f, g)(h) = g ‚ó¶h ‚ó¶f
which is indeed an arrow from C to D.
In this case we also use the product of categories as a formal construction to express functors of more
than one argument. From the categorical point of view, a functor always has one argument, which as in
the present case might well be an object in a product category (an ordered pair).
4.2 Actions
In this section, we discuss set-valued functors as a natural generalization of Ô¨Ånite state machines. Set-
valued functors also have theoretical importance in category theory because of the Yoneda Lemma
(Section 5.7).
4.2.1 Monoid actions
Let M be a monoid with identity 1 and let S be a set. An action of M on S
is a function Œ± : M √ó S ‚àí‚ÜíS for which
A‚Äì1 Œ±(1, s) = s for all s ‚ààS.
A‚Äì2 Œ±(mn, s) = Œ±(m, Œ±(n, s)) for all m, n ‚ààM and s ‚ààS.
It is customary in mathematics to write ms for Œ±(m, s); then the preceding requirements become
A‚Ä≤‚Äì1 1s = s for all s ‚ààS.
A‚Ä≤‚Äì2 (mn)s = m(ns) for all m, n ‚ààM and s ‚ààS.
When actions are written this way, S is also called an M-set. The same syntax ms for m ‚ààM and
s ‚ààS is used even when diÔ¨Äerent actions are involved. This notation is analogous to (and presumably
suggested by) the notation cv for scalar multiplication, where c is a scalar and v is a vector.
It is useful to think of the set S as a state space and the elements of M as acting to induce
transitions from one state to another.
4.2.2 Example
One major type of action by a monoid is the case when the state space is a vector
space and M is a collection of linear transformations closed under multiplication. However, in that case
the linear structure (the fact that states can be added and multiplied by scalars) is extra structure which
the deÔ¨Ånition above does not require. Our deÔ¨Ånition also does not require that there be any concept of
continuity of transitions. Thus, the deÔ¨Ånition is very general and can be regarded as a nonlinear, discrete
approach to state transition systems.
Less structure means, as always, that fewer theorems are true and fewer useful tools are available.
On the other hand, less structure means that more situations Ô¨Åt the axioms, so that the theorems that
are true and the tools that do exist work for more applications.

4.2 Actions
31
4.2.3 DeÔ¨Ånition
Let M be a monoid with actions on sets S and T. An equivariant map from S to
T is a function œÜ : S ‚àí‚ÜíT with the property that mœÜ(s) = œÜ(ms) for all m ‚ààM and s ‚ààS. The identity
function is an equivariant map and the composite of two equivariant maps is equivariant. This means
that for each monoid M, monoid actions and equivariant maps form a category M‚ÄìAct.
4.2.4 Actions as functors
Let Œ± be an action of a monoid M on a set S. Let C(M) denote the
category determined by M as in 2.3.12. The action Œ± determines a functor FŒ± : C(M) ‚àí‚ÜíSet deÔ¨Åned
by:
AF‚Äì1 FŒ±(‚àó) = S.
AF‚Äì2 FŒ±(m) = s 7‚ÜíŒ±(m, s) for m ‚ààM and s ‚ààS.
This observation will allow us to generalize actions to categories in 4.2.6.
4.2.5 Finite state machines
A particularly important example of a monoid action occurs in the
study of Ô¨Ånite state machines. Let A be a Ô¨Ånite set, the alphabet of the machine, whose elements may
be thought of as characters or tokens, and let S be another Ô¨Ånite set whose elements are to be thought
of as states. We assume there is a distinguished state s0 ‚ààS called the start state, and a function
œÜ : A √ó S ‚àí‚ÜíS deÔ¨Åning a transition to a state for each token in A and each state in S. Such a system
M = (A, S, s0, œÜ) is a Ô¨Ånite state machine. Note that there is no question of imposing axioms such as
A‚Äì1 and A‚Äì2 because A is not a monoid.
Any string w in A‚àóinduces a sequence of transitions in the machine M starting at the state s0 and
ending in some state s. Precisely, we deÔ¨Åne a function œÜ‚àó: A‚àó√ó S ‚àí‚ÜíS by:
FA‚Äì1 œÜ‚àó((), s) = s for s ‚ààS.
FA‚Äì2 œÜ‚àó((a)w, s) = œÜ(a, œÜ‚àó(w, s)) for any s ‚ààS, w ‚ààA‚àóand a ‚ààA.
Recall that the free monoid F(A) is the set A‚àówith concatenation as multiplication. The function
œÜ‚àóas just deÔ¨Åned is thus an action of F(A) on S. The identity of A‚àóis the empty word () and by FA‚Äì1,
œÜ‚àó((), a) = a for all a ‚ààA, so A‚Äì1 follows. As for A‚Äì2, if we assume that
œÜ‚àó(wv, m) = œÜ‚àó(w, œÜ‚àó(v, m))
for words w of length k, then
œÜ‚àó((a)wv, m) = œÜ(a, œÜ‚àó(wv, m))
= œÜ(a, œÜ‚àó(w, œÜ‚àó(v, m))) = œÜ‚àó((a)w, œÜ‚àó(v, m))
The Ô¨Årst and third equality are from the deÔ¨Ånition of œÜ, while the second is from the inductive hypothesis.
Finite state machines in the literature often have added structure. The state space may have a subset F of
acceptor states (or Ô¨Ånal states). The subset L of A‚àóof strings which drive the machine from the start
state to an acceptor state is then the set of strings, or language, which is recognized by the machine M .
This is the machine as recognizer. A compiler typically uses a Ô¨Ånite state machine to recognize identiÔ¨Åers
in the input Ô¨Åle.
Another approach is to assume that the machine outputs a string of symbols (not necessarily in the same
alphabet) for each state it enters or each transition it undergoes. This is the machine as transducer.
An elementary introduction to Ô¨Ånite state machines may be found in [Lewis and Papadimitriou, 1981]. Two
more advanced texts which use algebraic methods to study Ô¨Ånite state machines (primarily as recognizers)
are those by Eilenberg [1976] and Lallement [1979]. The latter book has many other applications of semigroup
theory as well.
4.2.6 Set-valued functors as actions
Suppose we wanted to extend the idea of an action by intro-
ducing typing. What would the result be?
To begin with, we would suppose that in addition to the state space S, there was a type set T and a
function type : S ‚àí‚ÜíT that assigned to each element s ‚ààS an element type(s) ‚ààT.
In describing the elements of M, one must say, for an m ‚ààM and s ‚ààS, what is type(ms). Moreover,
it seems that one might well want to restrict the types of the inputs on which a given m acts. In fact,
although it might not be strictly necessary in every case, it seems clear that we can, without loss of

32
Functors
generality, suppose that each m ‚ààM acts on only one kind of input and produces only one kind of
output. For if m acted on two types of output, we could replace m by two elements, one for each type.
Thus we can imagine that there are two functions we will call input and output from M to T for which
input(m) is the type of element that m acts on and output(m) is the type of m(s) for an element s of
type input(m).
In the untyped case, we had that M was a monoid, but here it is clearly appropriate to suppose that
m1 ‚àóm2 is deÔ¨Åned only when output(m2) = input(m1). It is reasonable to suppose that for each type t,
there is an operation 1t ‚ààM whose input and output types are t and such that for any m ‚ààM of input
type t, we have m ‚àó1t = m and for any m ‚ààM of output type t, we have 1t ‚àóm = m.
As for the action, we will evidently wish to suppose that when s ‚ààS has type t and m, m‚Ä≤ ‚ààM
have input types t, t‚Ä≤, respectively, and output types t‚Ä≤, t‚Ä≤‚Ä≤, respectively, then m‚Ä≤(m(s)) = (m‚Ä≤ ‚àóm)(s) and
1t(s) = s.
Now it will not have escaped the reader at this point that M and T together constitute a category C
whose objects are the elements of T and arrows are the elements of M. The input and output functions
are just the source and target arrows and the 1t are the identities.
M and S make up exactly the data of a set-valued functor on C . DeÔ¨Åne a functor F : C ‚àí‚ÜíSet by
letting F(t) = {s ‚ààS | type(s) = t}. If m is an arrow of C , that is an element of M, let its input and
output types be t and t‚Ä≤, respectively. Then for F to be a functor, we require a function F(m) : F(t)
‚àí‚ÜíF(t‚Ä≤). Naturally, we deÔ¨Åne F(m)(s) = ms, which indeed has type t‚Ä≤. The facts that F preserves
composition and identities are an easy consequence of the properties listed above.
This construction can be reversed. Let C be a small category and suppose we have a functor F :
C ‚àí‚ÜíSet for which F(C) and F(D) are disjoint whenever C and D are distinct objects of C (this
disjointness requirement is necessary to have a category, but can be forced by a simple modiÔ¨Åcation of F
‚Äì see Section 5.7). Then we can let T be the set of objects of C , M the set of arrows and S = S
t‚ààT F(t).
The rest of the deÔ¨Ånitions are evident and we leave them to the reader.
Thus if C is a small category, a functor F : C ‚àí‚ÜíSet is an action which generalizes the concept of
monoid acting on a set.
4.2.7 Example
For any given object C of a category C , the hom functor Hom(C, ‚àí) (see 4.1.21) is
a particular example of a set-valued functor. When the category C is a monoid, it is the action by left
multiplication familiar in semigroup theory. A theorem generalizing the Cayley theorem for groups is
true, too (see 5.7.5).
4.2.8 Variable sets
It may be useful to think of a set-valued functor F : C ‚àí‚ÜíSet as an action, not
on a typed set, but on a single variable set. The objects of C form a parameter space for the variation
of the set being acted upon. Another way of saying this is that each object of C is a point of view, that
the set being acted upon looks diÔ¨Äerent from diÔ¨Äerent points of view, and the arrows of C are changes
in point of view (as well as inducing transitions). See [Barr, McLarty and Wells, 1985].
4.3 Types of functors
Since Cat is a category, we already know about some types of functors. Thus a functor F : C ‚àí‚ÜíD is an
isomorphism if there is a functor G : D ‚àí‚ÜíC which is inverse to F. This implies that F is bijective on
objects and arrows and conversely a functor which is bijective on objects and arrows is an isomorphism.
We have already pointed out that a functor is a monomorphism in Cat if and only if it is injective
on both objects and arrows. Epimorphisms in Cat need not be surjective, since the example in 3.4.3 is
actually an epimorphism in Cat between the categories determined by the monoids.
4.3.1 Full and faithful
We will now consider properties of functors which are more intrinsic to Cat
than the examples just given.
Any functor F : C ‚àí‚ÜíD induces a set mapping
HomC (A, B) ‚àí‚ÜíHomD(F(A), F(B))
for each pair of objects A and B of C . This mapping takes an arrow f : A ‚àí‚ÜíB to F(f) : F(A) ‚àí‚ÜíF(B).

4.3 Types of functors
33
4.3.2 DeÔ¨Ånition
A functor F : C ‚àí‚ÜíD is faithful if the induced mapping is injective on every hom
set.
Thus if f : A ‚àí‚ÜíB and g : A ‚àí‚ÜíB are diÔ¨Äerent arrows, then F(f) Ã∏= F(g). However, it is allowed that
f : A ‚àí‚ÜíB and g : C ‚àí‚ÜíD may be diÔ¨Äerent arrows, with F(A) = F(C), F(B) = F(D) and F(f) = F(g),
provided that either A Ã∏= C or B Ã∏= D.
4.3.3 Example
Underlying functors are typically faithful. Two diÔ¨Äerent monoid homomorphisms be-
tween the same two monoids must be diÔ¨Äerent as set functions.
On the other hand, consider the set {0, 1, 2}. It has two diÔ¨Äerent monoid structures via addition and
multiplication (mod 3) (and many other monoid structures, too), but the two corresponding identity
homomorphisms are the same as set functions (have the same underlying function). Thus underlying
functors need not be injective.
4.3.4 DeÔ¨Ånition
A functor F : C ‚àí‚ÜíD is full if the induced mapping is surjective for every hom set.
A full functor need not be surjective on either objects or arrows. A full subcategory (2.6.3) is exactly
one whose embedding is a full and faithful functor.
That the underlying functor from the category of semigroups to the category of sets is not full says
exactly that not every set function between semigroups is a semigroup homomorphism. Note that this
functor is surjective on objects, since every set can be made into a semigroup by letting xy = x for every
pair x and y of elements.
4.3.5 Example
The functor F : C ‚àí‚ÜíD which takes A and B to C and X and Y to Z (and so is forced
on arrows) in the picture below (which omits identity arrows) is not full. That is because Hom(A, B)
is empty, but Hom(F(A), F(B)) = Hom(C, C) has an arrow in it ‚Äì the identity arrow. This functor is
faithful even though not injective, since two arrows between the same two objects do not get identiÔ¨Åed.
X
A
Y
B
Z
C
?
6
?
6
?
6
C
D
(4.2)
4.3.6 Preservation of properties
A functor F : C ‚àí‚ÜíD preserves a property P of arrows if
whenever f has property P, so does F(f).
4.3.7 Examples
The fact that a monomorphism in the category of monoids must be injective can
be worded as saying that the underlying functor preserves monomorphisms (since an injective function
in Set is a monomorphism). The statement that an epimorphism in Mon need not be surjective is the
same as saying that the underlying functor does not preserve epimorphisms.
As another example, consider the functor F : 2 ‚àí‚ÜíSet (2 is shown in (2.1), page 6) deÔ¨Åned by
C 7‚Üí{1, 2}, D 7‚Üí{3, 4} and the arrow from C to D going to the constant function 1 7‚Üí3, 2 7‚Üí3 from
F(C) to F(D). The arrow from C to D is monic and epic (vacuously) but its value in Set takes 1 and
2 both to 3, so is not injective and hence not a monomorphism. It is also not an epimorphism. Thus F
preserves neither monomorphisms nor epimorphisms.
The story is diÔ¨Äerent for isomorphisms. (Note that the arrow from C to D in 2 is not an isomorphism!)
4.3.8 Proposition
Every functor preserves isomorphisms.
Proof. This is because the concept of isomorphism is deÔ¨Åned in terms of equations involving composition
and identity. If f : A ‚àí‚ÜíB is an isomorphism with inverse g, then F(g) is the inverse of F(f). One of
the two calculations necessary to prove this is that F(g) ‚ó¶F(f) = F(g ‚ó¶f) = F(idA) = idF (A); the other
calculation is analogous.
In fact, an analogous proof shows that every functor preserves split monos and split epis.

34
Functors
4.3.9 DeÔ¨Ånition
A functor F : C ‚àí‚ÜíD reÔ¨Çects a property P of arrows if whenever F(f) has property
P then so does f (for any arrow that F takes to F(f)).
It follows from 2.5.5 and the deÔ¨Ånition of isomorphism (3.1.4) that a bijective semigroup homomorph-
ism must be an isomorphism. That is the same as saying that the underlying functor from Sem to Set
reÔ¨Çects isomorphisms. The same remark applies to Mon. The underlying functor from the category of
posets and monotone maps does not reÔ¨Çect isomorphisms.
A full and faithful functor reÔ¨Çects isomorphisms, but in fact it does a bit more than that, as described
by the following proposition.
4.3.10 Proposition
Let F : C ‚àí‚ÜíD be full and faithful, and suppose A and B are objects of C and
u : F(A) ‚àí‚ÜíF(B) is an isomorphism in D. Then there is a unique isomorphism f : A ‚àí‚ÜíB for which
F(f) = u.
Proof. By fullness, there are arrows f : A ‚àí‚ÜíB and g : B ‚àí‚ÜíA for which F(f) = u and F(g) = u‚àí1.
Then
F(g ‚ó¶f) = F(g) ‚ó¶F(f) = u‚àí1 ‚ó¶u = idF (A) = F(idA)
But F is faithful, so g ‚ó¶f = idA. A similar argument shows that f ‚ó¶g = idB, so that g is the inverse of
f.
4.3.11 Corollary
A full and faithful functor reÔ¨Çects isomorphisms.
4.3.12 Corollary
Let F : C ‚àí‚ÜíD be a full and faithful functor. If F(A) = F(B) for objects A and B
of C , then A and B are isomorphic.
Proof. Apply Proposition 4.3.10 to the identity arrow from F(A) to F(A) = F(B).
4.3.13
You can also talk about a functor preserving or reÔ¨Çecting a property of objects. For example,
since a terminal object in Mon is a one-element monoid and a one-element set is a terminal object, the
underlying functor from Mon to Set preserves terminal objects. It also reÔ¨Çects terminal objects. It does
not preserve initial objects, but it does reÔ¨Çect initial objects although vacuously: the empty set is the
only initial object in Set and the underlying set of a monoid cannot be empty since it must have an
identity element. We leave the details to you.
4.4 Equivalences
In this section we deÔ¨Åne what it means for two categories to be equivalent. The correct concept turns
out to be weaker than requiring that they be isomorphic ‚Äì that is, that there is a functor from one to
the other which has an inverse in Cat. In order to understand the issues involved, we Ô¨Årst take a close
look at the construction of the category corresponding to a monoid in Section 2.3.12. It turns out to be
a functor.
4.4.1 Monoids and one-object categories
For each monoid M we constructed a small category
C(M) in 2.3.12. We make the choice mentioned there that the one object of C(M) is M. Note that
although an element of C(M) is now an arrow from M to M, it is not a set function.
For each monoid homomorphism h : M ‚àí‚ÜíN, construct a functor C(h) : C(M) ‚àí‚ÜíC(N) as follows:
CF‚Äì1 On objects, C(h)(M) = N.
CF‚Äì2 C(h) must be exactly the same as h on arrows (elements of M).
It is straightforward to see that C(h) is a functor and that this construction makes C a functor
from Mon to the full subcategory of Cat of categories with exactly one object. We will denote this full
subcategory as Ooc.
There is also a functor U : Ooc ‚àí‚ÜíMon going the other way.
UO‚Äì1 For a category C with one object, U(C ) is the monoid whose elements are the arrows of C and
whose binary operation is the composition of C .

4.4 Equivalences
35
UO‚Äì2 If F : C ‚àí‚ÜíD is a functor between one-object categories, U(F) = F1, that is, the functor F on
arrows.
The functors U and C are not inverse to each other, and it is worthwhile to see in detail why.
The construction of C is in part arbitrary. We needed to regard each monoid as a category with one
object. The choice of the elements of M to be the arrows of the category is obvious, but what should
be the one object? We chose M itself, but we could have chosen some other thing, such as the set {e},
where e is the identity of M. The only real requirement is that it not be an element of M (such as its
identity) in order to avoid set-theoretic problems caused by the category being an element of itself. The
consequence is that we have given a functor C : Mon ‚àí‚ÜíOoc in a way which required arbitrary choices.
The arbitrary choice of one object for C(M) means that if we begin with a one-object category C ,
construct M = U(C ), and then construct C(M), the result will not be the same as C unless it happens
that the one object of C is M. Thus C ‚ó¶U Ã∏= idOoc, so that U is not the inverse of C. (In this case
U ‚ó¶C is indeed idMon.)
C is not surjective on objects, since not every small category with one object is in the image of C;
in fact a category D is C(M) for some monoid M only if the single object of D is actually a monoid
and the arrows of D are actually the arrows of that monoid. This is entirely contrary to the spirit of
category theory: we are talking about speciÔ¨Åc elements rather than specifying behavior. Indeed, in terms
of specifying behavior, the category of monoids and the category of small categories with one object
ought to be essentially the same thing.
The fact that C is not an isomorphism of categories is a signal that isomorphism is the wrong idea for
capturing the concept that two categories are essentially the same. However, every small category with
one object is isomorphic to one of those constructed as C(M) for some monoid M. This is the starting
point for the deÔ¨Ånition of equivalence.
4.4.2 DeÔ¨Ånition
A functor F : C ‚àí‚ÜíD is an equivalence of categories if there are:
E‚Äì1 A functor G : D ‚àí‚ÜíC .
E‚Äì2 A family uC : C ‚àí‚ÜíG(F(C)) of isomorphisms of C indexed by the objects of C with the property
that for every arrow f : C ‚àí‚ÜíC‚Ä≤ of C , G(F(f)) = uC‚Ä≤ ‚ó¶f ‚ó¶u‚àí1
C .
E‚Äì3 A family vD : D ‚àí‚ÜíF(G(D)) of isomorphisms of D indexed by the objects of D, with the property
that for every arrow g : D ‚àí‚ÜíD‚Ä≤ of D, F(G(g)) = vD‚Ä≤ ‚ó¶g ‚ó¶v‚àí1
D .
If F is an equivalence of categories, the functor G of E‚Äì1 is called a pseudo-inverse of F. That the
functor C of 4.4.1 is an equivalence (with pseudo-inverse U) is left as an exercise.
The idea behind the deÔ¨Ånition is that not only is every object of D isomorphic to an object in the
image of F, but the isomorphisms are compatible with the arrows of D; and similarly for C .
4.4.3 Example
An isomorphism of categories is an equivalence of categories, and its inverse is its
pseudo-inverse.
4.4.4 Example
Let C be the category with two objects A and B, their identities, and two other
arrows i : A ‚àí‚ÜíB and j : B ‚àí‚ÜíA that are inverse isomorphisms between the objects:
-
i
A
B

j
(4.3)
Let D = 1 be the category with one object E and its identity arrow. Then C and D are equivalent. The
unique functor from C to D has two pseudo-inverses, each taking the unique object of D to one of the
two isomorphic objects of C .
We give the details for one of these. Let F : C ‚àí‚ÜíD be the functor that takes A and B to E and
G : D ‚àí‚ÜíC the functor that takes E to A. The family required by E‚Äì2 consists of uA = idA and uB = j.
That required by E‚Äì3 consists of idE. We have for example
G(F(i)) = G(idE) = idA = j ‚ó¶i ‚ó¶idA = uB ‚ó¶i ‚ó¶uA
‚àí1
The other equations required by E‚Äì2 and E‚Äì3 are similar or easier.

36
Functors
4.4.5 Theorem
Let F : C ‚àí‚ÜíD be an equivalence of categories and G : D ‚àí‚ÜíC a pseudo-inverse to
F. Then F and G are full and faithful.
Proof. Actually, something more is true: if F and G are functors for which E‚Äì2 is true, then F is faithful.
For suppose f, f ‚Ä≤ : C ‚àí‚ÜíC‚Ä≤ in C and F(f) = F(f ‚Ä≤) in D. Then G(F(f)) = G(F(f ‚Ä≤)) in C , so that
f = u‚àí1
C‚Ä≤
‚ó¶G(F(f)) ‚ó¶uC = u‚àí1
C‚Ä≤
‚ó¶G(F(f ‚Ä≤)) ‚ó¶uC = f ‚Ä≤
Thus F is faithful. A symmetric argument shows that if E‚Äì3 is true then G is faithful.
Now suppose F : C ‚àí‚ÜíD is an equivalence of categories and G : D ‚àí‚ÜíC is a pseudo-inverse to F.
We now know that F and G are faithful. To show that F is full, suppose that g : F(C) ‚àí‚ÜíF(C‚Ä≤) in D.
We must Ô¨Ånd f : C ‚àí‚ÜíC‚Ä≤ in C for which F(f) = g. Let f = u‚àí1
C‚Ä≤
‚ó¶G(g) ‚ó¶uC. Then a calculation using
E‚Äì2 shows that G(F(f)) = G(g). Since G is faithful, F(f) = g.
Proposition 4.3.10 implies that an equivalence of categories does not take nonisomorphic objects to
isomorphic ones.
An alternative deÔ¨Ånition of equivalence sometimes given in the literature uses the concept of rep-
resentative functor. A functor F : C ‚àí‚ÜíD is representative if every object of D is isomorphic to an
object in the image of F. (Thus a subcategory is representative in the sense of DeÔ¨Ånition 3.1.9 if the
inclusion functor is representative.) Then a functor F : C ‚àí‚ÜíD is an equivalence if it is full, faithful, and
representative. This deÔ¨Ånition can be proved equivalent to ours. The proof requires the axiom of choice.
4.4.6 Inequivalence
For any property P of a category that can be deÔ¨Åned in terms of composition
and identities, if C and D are equivalent categories, then either they both have property P or neither
of them does. This is an imprecise statement; in particular, a property preserved by equivalence can
require that two arrows be the same but it cannot require that two objects be the same. A formal
language that expresses the properties preserved by equivalence is given by Freyd and Scedrov [1990],
sections 1.39‚Äì1.3(10). See also [Bergman and Berman, 1998].
Reference
added
This observation provides a way to show that two categories are not equivalent. For example, Set
and Mon are not equivalent because there is no arrow in Set from the terminal object to the initial
object, but in Mon the initial and terminal objects are isomorphic. Similarly Set and the category of
posets and monotone functions are not equivalent because there are only two nonisomorphic sets that
have only one automorphism (the empty set and a singleton set), but there are many nonisomorphic
posets that have only one automorphism, for example any two totally ordered Ô¨Ånite posets of diÔ¨Äerent
cardinality.

5. Diagrams and naturality
Commutative diagrams are the categorist‚Äôs way of expressing equations. Natural transformations are
maps between functors; one way to think of them is as a deformation of one construction (construed as
a functor) into another.
5.1 Diagrams
We begin with diagrams in a graph and discuss commutativity later.
5.1.1 DeÔ¨Ånition
Let I and G be graphs. A diagram in G of shape I is a homomorphism D : I
‚àí‚ÜíG of graphs. I is called the shape graph of the diagram D.
We have thus given a new name to a concept which was already deÔ¨Åned (not uncommon in mathe-
matics). A diagram is a graph homomorphism from a diÔ¨Äerent point of view.
5.1.2 Example
At Ô¨Årst glance, DeÔ¨Ånition 5.1.1 may seem to have little to do with what are informally
called diagrams, for example
A
B
-
f
C
h@@
R
g
  	
(5.1)
The connection is this: a diagram in the sense of DeÔ¨Ånition 5.1.1 is pictured on the page with a drawing
of nodes and arrows as for example in Diagram (5.1), which could be the picture of a diagram D with
shape graph
i
j
-
u
k
w@@
R
v
  	
(5.2)
deÔ¨Åned by D(i) = A, D(j) = B, D(k) = C, D(u) = f, D(v) = g and D(w) = h.
5.1.3 Example
Here is an example illustrating some subtleties involving the concept of diagram.
Let G be a graph with objects A, B and C (and maybe others) and arrows f : A ‚àí‚ÜíB, g : B ‚àí‚ÜíC and
h : B ‚àí‚ÜíB. Consider these two diagrams, where here we use the word ‚Äòdiagram‚Äô informally:
A
B
-
f
C
-
g
A
B
-
f R
h
(a)
(b)
(5.3)
These are clearly of diÔ¨Äerent shapes (again using the word ‚Äòshape‚Äô informally). But the diagram
A
B
-
f
B
-
h
(5.4)
is the same shape as (5.3)(a) even though as a graph it is the same as (5.3)(b).
To capture the diÔ¨Äerence thus illustrated between a graph and a diagram, we introduce two shape
graphs
1
2
-
u
3
-
v
1
2
-
u R
w
I
J
(5.5)
(where, as will be customary, we use numbers for the nodes of shape graphs). Now diagram (5.3)(a) is
37

38
Diagrams and naturality
seen to be the diagram D : I ‚àí‚ÜíG with D(1) = A, D(2) = B, D(3) = C, D(u) = f and D(v) = g;
whereas diagram (5.3)(b) is E : J ‚àí‚ÜíG with E(1) = A, E(2) = B, E(u) = f and E(w) = h. Moreover,
Diagram (5.4) is just like D (has the same shape), except that v goes to h and 3 goes to B.
5.1.4
Our deÔ¨Ånition in 5.1.1 of a diagram as a graph homomorphism, with the domain graph being
the shape, captures both the following ideas:
(i) A diagram can have repeated labels on its nodes and (although the examples did not show it) on
its arrows, and
(ii) Two diagrams can have the same labels on their nodes and arrows but be of diÔ¨Äerent shapes:
Diagrams (5.3)(b) and (5.4) are diÔ¨Äerent diagrams because they have diÔ¨Äerent shapes.
5.1.5 Commutative diagrams
When the target graph of a diagram is the underlying graph of a
category some new possibilities arise, in particular the concept of commutative diagram, which is the
categorist‚Äôs way of expressing equations.
In this situation, we will not distinguish in notation between the category and its underlying graph:
if I is a graph and C is a category we will refer to a diagram D : I ‚àí‚ÜíC .
We say that D is commutative (or commutes) provided for any nodes i and j of I and any two
paths
t1@
@
R
k1
i
s1  
l1
l2
-
t2
k2
-
s2
¬∑ ¬∑ ¬∑
-
¬∑ ¬∑ ¬∑
-
lm‚àí2
-
kn‚àí2
-
lm‚àí1
-
tm‚àí1
kn‚àí1
-
sn‚àí1
tm
  
j
sn
@
@
R
(5.6)
from i to j in I , the two paths
Dt1@
@
R
Dk1
Di
Ds1  
Dl1
Dl2
-
Dt2
Dk2
-
Ds2
¬∑ ¬∑ ¬∑
-
¬∑ ¬∑ ¬∑
-
Dlm‚àí2
-
Dkn‚àí2
-
Dlm‚àí1
-
Dtm‚àí1
Dkn‚àí1
-
Dsn‚àí1
Dtm
  
Dj
Dsn
@
@
R
(5.7)
compose to the same arrow in C . This means that
Dsn ‚ó¶Dsn‚àí1 ‚ó¶. . . ‚ó¶Ds1 = Dtm ‚ó¶Dtm‚àí1 ‚ó¶. . . ‚ó¶Dt1
5.1.6 Much ado about nothing
There is one subtlety to the deÔ¨Ånition of commutative diagram:
what happens if one of the numbers m or n in Diagram (5.7) should happen to be 0? If, say, m = 0,
then we interpret the above equation to be meaningful only if the nodes i and j are the same (you go
nowhere on an empty path) and the meaning in this case is that
Dsn ‚ó¶Dsn‚àí1 ‚ó¶. . . ‚ó¶Ds1 = idDi
(you do nothing on an empty path). In particular, a diagram D based on the graph
i
R
e
commutes if and only if D(e) is the identity arrow from D(i) to D(i).
Note, and note well, that both shape graphs
R
e
i
i
j
-
d
(a)
(b)

5.1 Diagrams
39
have models that one might think to represent by the diagram
R
f
A
but the diagram based on (a) commutes if and only if f = idA, while the diagram based on (b) commutes
automatically (no two nodes have more than one path between them so the commutativity condition is
vacuous).
We will always picture diagrams so that distinct nodes of the shape graph are represented by distinct
(but possibly identically labeled) nodes in the picture. Thus a diagram based on (b) in which d goes to
f and i and j both go to A will be pictured as
A
f
‚àí‚àí‚ÜíA
In consequence, one can always deduce the shape graph of a diagram from the way it is pictured, except
of course for the actual names of the nodes and arrows of the shape graph.
5.1.7 Examples of commutative diagrams ‚Äì and others
The prototypical commutative diagram
is the triangle
A
B
-
f
C
h@@
R
g
  	
(5.8)
that commutes if and only if h is the composite g
‚ó¶f. The reason this is prototypical is that any
commutative diagram ‚Äì unless it involves an empty path ‚Äì can be replaced by a set of commutative
triangles. This fact is easy to show and not particularly enlightening, so we are content to give an
example. The diagram
C
D
-
k
A
B
-
h
?
f
?
g
(5.9)
commutes if and only if the two diagrams
C
D
-
k
g ‚ó¶h
@
@
@@
R
A
?
f
A
B
-
h
k ‚ó¶f
@
@
@@
R
D
?
g
(5.10)
commute (in fact if and only if either one does).
5.1.8 Example
An arrow f : A ‚àí‚ÜíB is an isomorphism with inverse g : B ‚àí‚ÜíA if and only if
-
f
A
B
 g
(5.11)
commutes. The reason for this is that for this diagram to commute, the two paths () and (g,f) from A to
A must compose to the same value in the diagram, which means that g ‚ó¶f = idA. A similar observation
shows that f ‚ó¶g must be idB.

40
Diagrams and naturality
5.1.9 Graph homomorphisms by commutative diagrams
The deÔ¨Ånition of graph homomorph-
ism in 1.2.1 can be expressed by a commutative diagram. Let œÜ = (œÜ0, œÜ1) be a graph homomorphism
from G to H . For any arrow u : m ‚àí‚Üín in G , 1.2.1 requires that œÜ1(u) : œÜ0(m) ‚àí‚ÜíœÜ0(n) in H . This
says that œÜ0(source(u)) = source(œÜ1(u)), and a similar statement about targets. In other words, these
diagrams must commute:
G0
H0
-
œÜ0
G1
H1
-
œÜ1
?
source
?
source
G0
H0
-
œÜ0
G1
H1
-
œÜ1
?
target
?
target
(5.12)
In these two diagrams the two arrows labeled ‚Äòsource‚Äô are of course diÔ¨Äerent functions; one is the source
function for G and the other for H . A similar remark is true of ‚Äòtarget‚Äô.
5.1.10
This point of view provides a pictorial proof that the composite of two graph homomorphisms
is a graph homomorphism (see 2.4.1). If œÜ : G ‚àí‚ÜíH and œà : H ‚àí‚ÜíK are graph homomorphisms, then
to see that œà ‚ó¶œÜ is a graph homomorphism requires checking that the outside rectangle below commutes,
and similarly with target in place of source:
G0
H0
-
œÜ0
G1
H1
-
œÜ1
?
source
K0
-
œà0
K1
-
œà1
?
source
?
source
(5.13)
The outside rectangle commutes because the two squares commute. This can be checked by tracing
(mentally or with a Ô¨Ånger or pointer) the paths from G1 to K0 to verify that
source ‚ó¶œà1 ‚ó¶œÜ1 = œà0 ‚ó¶source ‚ó¶œÜ1
(5.14)
because the right square commutes, and that
œà0 ‚ó¶source ‚ó¶œÜ1 = œà0 ‚ó¶œÜ0 ‚ó¶source
(5.15)
because the left square commutes. The veriÔ¨Åcation process just described is called ‚Äòchasing the diagram‚Äô.
Of course, one can verify the required fact by writing the equations (5.14) and (5.15) down, but those
equations hide the source and target information given in Diagram (5.13) and thus provide a possibility of
writing an impossible composite down. For many people, Diagram (5.13) is much easier to remember than
equations (5.14) and (5.15). However, diagrams are more than informal aids; they are formally-deÔ¨Åned
mathematical objects just like automata and categories.
The proof in 2.6.10 that the composition of arrows in a slice gives another arrow in the category can
be represented by a similar diagram:
A
f@
@@
R
C
C‚Ä≤
-
h
C‚Ä≤‚Ä≤
-
h‚Ä≤
?
f ‚Ä≤
f ‚Ä≤‚Ä≤
   	
These examples are instances of pasting commutative diagrams together to get bigger ones.
5.1.11 Associativity by commutative diagrams
The fact that the multiplication in a monoid or
semigroup is associative can be expressed as the assertion that a certain diagram in Set commutes.
Let S be a semigroup. DeÔ¨Åne the following functions:
(i) mult : S √ó S ‚àí‚ÜíS satisÔ¨Åes mult(x, y) = xy.

5.1 Diagrams
41
(ii) S √ó mult : S √ó S √ó S ‚àí‚ÜíS √ó S satisÔ¨Åes
(S √ó mult)(x, y, z) = (x, yz)
(iii) mult √óS : S √ó S √ó S ‚àí‚ÜíS √ó S satisÔ¨Åes
(mult √óS)(x, y, z) = (xy, z)
That the following diagram commutes is exactly the associative law.
S √ó S
S
-
mult
S √ó S √ó S
S √ó S
-
S √ó mult
?
mult √óS
?
mult
(5.16)
5.1.12
Normally, associativity is expressed by the equation x(yz) = (xy)z for all x, y, z in the semi-
group. The commutative diagram expresses this same fact without the use of variables. Of course, we
did use variables in deÔ¨Åning the functions involved, but we remedy that deÔ¨Åciency in Chapter 6 when
we give a categorical deÔ¨Ånition of products.
Another advantage of using diagrams to express equations is that diagrams show the source and
target of the functions involved. This is not particularly compelling here but in other situations the
two-dimensional picture of the compositions involved makes it much easier to follow the discussion.
5.1.13 Functors by commutative diagrams
We express the deÔ¨Ånition of functor using commuta-
tive diagrams. Let C and D be categories with sets of objects C0 and D0, sets of arrows C1 and D1, and
sets of composable pairs of arrows C2 and D2, respectively. A functor F : C ‚àí‚ÜíD consists of functions
F0 : C0 ‚àí‚ÜíD0, F1 : C1 ‚àí‚ÜíD1 along with the uniquely determined function F2 : C2 ‚àí‚ÜíD2 such that
C1
C1
C2
proj1
    	
proj2
@
@
@@
R
D1
D1
D2
    	
@
@
@@
R
proj1
proj2
?
F1
?
F2
?
F1
commutes. In addition, the following diagrams must commute:
D1
D0
-
dom
C1
C0
-
dom
?
F1
?
F0
D1

cod
C1
 cod
?
F1
D2
D1
-
comp
C2
C1
-
comp
?
F2
?
F1
5.1.14 Diagrams as functors
In much of the categorical literature, a diagram in a category C is a
functor D : E ‚àí‚ÜíC where E is a category. Because of Proposition 4.1.16, a graph homomorphism into
a category extends uniquely to a functor based on the free category generated by the graph, so that
diagrams in our sense generate diagrams in the functorial sense. On the other hand, any functor is a
graph homomorphism on the underlying graph of its domain (although not conversely!), so that every
diagram in the sense of functor is a diagram in the sense of graph homomorphism.

42
Diagrams and naturality
5.2 Natural transformations
5.2.1 Unary operations
In Section 5.1 we saw that diagrams in a category are graph homomorph-
isms to the category from a diÔ¨Äerent point of view. Now we introduce a third way to look at graph
homomorphisms to a category, namely as models. To give an example, we need a deÔ¨Ånition.
5.2.2 DeÔ¨Ånition
A unary operation on a set S is a function u : S ‚àí‚ÜíS.
This deÔ¨Ånition is by analogy with the concept of binary operation on a set. A set with a unary
operation is a (very simple) algebraic structure, which we call a u-structure. If the set is S and the
operation is f : S ‚àí‚ÜíS, we say that (S, f) is a u-structure, meaning (S, f) denotes a u-structure whose
underlying set is S, and whose unary operation is f. This uses positional notation in much the same way
as procedures in many computer languages: the Ô¨Årst entry in the expression ‚Äò(S, f)‚Äô is the name of the
underlying set of the u-structure and the second entry is the name of its operation.
5.2.3
A homomorphism of u-structures should be a function which preserves the structure. There is
really only one deÔ¨Ånition that is reasonable for this idea: if (S, u) and (T, v) are u-structures, f : S
‚àí‚ÜíT is a homomorphism of u-structures if f(u(s)) = v(f(s)) for all s ‚ààS. Thus this diagram must
commute:
S
T
-
f
S
T
-
f
?
u
?
v
(5.17)
It is not diÔ¨Écult to show that the composite of two homomorphisms of u-structures is another one, and
that the identity map is a homomorphism, so that u-structures and homomorphisms form a category.
5.2.4 Models of graphs
We now use the concept of u-structure to motivate the third way of looking
at graph homomorphisms to a category.
5.2.5
Let U be the graph with one node u0 and one arrow e:
R
e
u0
Let us deÔ¨Åne a graph homomorphism D : U ‚àí‚ÜíSet as follows: D(u0) = R and D(e) = x 7‚Üíx2. Now
(R, x 7‚Üíx2) is a u-structure, and the notation we have introduced in 5.2.1 tells us that we have chosen R
to be its underlying set and x 7‚Üíx2 to be its unary operation. Except for the arbitrary names ‚Äòu0‚Äô and
‚Äòe‚Äô, the graph homomorphism D communicates the same information: ‚ÄòR is the particular set chosen to
be the value of u0, and x 7‚Üíx2 is the particular function chosen to be the value of e.‚Äô
In this sense, a u-structure is essentially the same thing as a diagram in Set of shape U : a u-structure
‚Äòmodels‚Äô the graph U . This suggests the following deÔ¨Ånition.
5.2.6 DeÔ¨Ånition
A model M of a graph G is a graph homomorphism M : G ‚àí‚ÜíSet.
A monoid can be deÔ¨Åned as a model involving a graph homomorphism (and other ingredients) using
the concept of Ô¨Ånite product (see [Barr and Wells, 1999], Chapter 7). We had to introduce u-structures
here to have an example for which we had the requisite techniques.
Both category theory and mathematical logic have concepts of ‚Äòmodel‚Äô. Both are formalisms attempting
to make precise the relationship between the (formal) description of a mathematical structure and the
structure itself. In logic, the precise description (the syntax) is given by a logical theory; in category theory
by sketches or by categories regarded as theories. Good introductions to various aspects of categorical logic
and model theory are given by [Makkai and Reyes, 1977], [Lambek and Scott, 1986], [Makkai and Par¬¥e,
1990] and [Ad¬¥amek and RosiÀácky, 1994].

5.2 Natural transformations
43
5.2.7 Example
As another example, consider this graph:
a
source
‚àí‚àí‚àí‚àí‚àí‚Üí
‚àí‚àí‚àí‚àí‚àí‚Üí
target
n
(5.18)
A model M of this graph consists of sets G0 = M(n) and G1 = M(a) together with functions source =
M(source) : G1 ‚àí‚ÜíG0 and target = M(target) : G1 ‚àí‚ÜíG0. To understand what this structure is, imagine
a picture in which there is a dot corresponding to each element of G0 and an arrow corresponding to
each element a ‚ààG1 which goes from the dot corresponding to source(a) to the one corresponding to
target(a). It should be clear that the picture so described is a graph and thus the graph (5.18) is a graph
whose models are graphs!
5.2.8 Models in arbitrary categories
The concept of model can be generalized to arbitrary cate-
gories: if C is any category, a model of G in C is a graph homomorphism from G to C . For example,
a model of the graph for u-structures in the category of posets and monotone maps is a poset and a
monotone map from the poset to itself.
In these notes, the bare word ‚Äòmodel‚Äô always means a model in Set.
5.2.9 Natural transformations between models of a graph
In a category, there is a natural
notion of an arrow from one model of a graph to another. This usually turns out to coincide with the
standard deÔ¨Ånition of homomorphism for that kind of structure.
5.2.10 DeÔ¨Ånition
Let D, E : G ‚àí‚ÜíC be two models of the same graph in a category. A natural
transformation Œ± : D ‚àí‚ÜíE is given by a family of arrows Œ±a of C indexed by the nodes of G such
that:
NT‚Äì1 Œ±a : Da ‚àí‚ÜíEa for each node a of G .
NT‚Äì2 For any arrow s : a ‚àí‚Üíb in G , the diagram
Db
Eb
-
Œ±b
Da
Ea
-
Œ±a
?
Ds
?
Es
(5.19)
commutes.
The commutativity of the diagram in NT‚Äì2 is referred to as the naturality condition on Œ±. The
arrow Œ±a for an object a is the component of the natural transformation Œ± at a.
Note that you talk about a natural transformation from D to E only if D and E have the same
domain (here G ) as well as the same codomain (here C ) and if, moreover, the codomain is a category.
In this situation, it is often convenient to write Œ± : D ‚àí‚ÜíE : G ‚àí‚ÜíC .
5.2.11 DeÔ¨Ånition
Let D, E and F be models of G in C , and Œ± : D ‚àí‚ÜíE and Œ≤ : E ‚àí‚ÜíF natural
transformations. The composite Œ≤ ‚ó¶Œ± : D ‚àí‚ÜíF is deÔ¨Åned componentwise: (Œ≤ ‚ó¶Œ±)a = Œ≤a ‚ó¶Œ±a.
5.2.12 Proposition
The composite of two natural transformations is also a natural transformation.
Proof. The diagram that has to be shown commutative is the outer rectangle of
Db
Eb
-
Œ±b
Da
Ea
-
Œ±a
?
Ds
?
Es
Fb
-
Œ≤b
Fa
-
Œ≤a
?
Fs
(5.20)
for each arrow s : a ‚àí‚Üíb in G . The rectangle commutes because the two squares do; the squares commute
as a consequence of the naturality of Œ± and Œ≤.

44
Diagrams and naturality
It is interesting that categorists began using modes of reasoning like that in the preceding proof because
objects of categories generally lacked elements; now one appreciates them for their own sake because they
allow element-free (and thus variable-free) arguments.
5.2.13
It is even easier to show that there is an identity natural transformation between any model D
and itself, deÔ¨Åned by (idD)a = idDa. We then have the following proposition, whose proof is straightfor-
ward.
5.2.14 Proposition
The models of a given graph G in a given category C , and the natural transfor-
mations between them, form a category. We denote this category by Mod(G , C ).
5.2.15 Example
The natural transformations between models in Set of the u-structure graph U
deÔ¨Åned in 5.2.5 are exactly the homomorphisms of u-structures deÔ¨Åned in 5.2.3. The graph described
in 5.2.5 has one object u0 and one arrow e, so that a natural transformation from a model D to a model
E has only one component which is a function from D(u0) to E(u0). If we set S = D(u0), u = D(e),
T = E(u0), v = E(e), and we deÔ¨Åne Œ±u0 = f, this is the single component of a natural transformation
from D to E. Condition NT‚Äì2 in 5.2.10 coincides in this case with the diagram in 5.2.3: the naturality
condition is the same as the deÔ¨Ånition of homomorphism of u-structures. It follows that the category of
u-structures and homomorphisms is essentially Mod(U , Set).
5.2.16 Example
A homomorphism of graphs is a natural transformation between models of the graph
a
source
‚àí‚àí‚àí‚àí‚àí‚Üí
‚àí‚àí‚àí‚àí‚àí‚Üí
target
n
The two graphs in Diagram (5.12) are the two necessary instances (one for the source and the other
for the target) of Diagram (5.19). In a similar way, Diagram (5.20), used to show that the composite of
two natural transformations is a natural transformation, reduces in this case to the commutativity of
Diagram (5.13): speciÔ¨Åcally, the only possibilities (other than those in which s is an identity arrow) for
a and b in Diagram (5.20) are a = a and b = n, giving two diagrams shaped like Diagram (5.20), one for
s = source (that is Diagram (5.13)) and the other for s = target.
5.2.17 Example
A model of the graph
0
1
-
u
(5.21)
in an arbitrary category C is essentially the same as an arrow in C (see 5.2.23 below). A natural
transformation from the model represented by the arrow f : A ‚àí‚ÜíB to the one represented by g : C
‚àí‚ÜíD is a pair of arrows h : A ‚àí‚ÜíC and k : B ‚àí‚ÜíD making a commutative diagram:
B
D
-
k
A
C
-
h
?
f
?
g
(5.22)
The component at 0 is h and the component at 1 is k. The category of models in C is called the arrow
category of C ; it is often denoted C ‚àí‚Üí.
5.2.18 Example
Let G be the graph with two nodes and no arrows, and C any category. Then
Mod(G , C ) is isomorphic to C √ó C .
5.2.19 Natural isomorphisms
A natural transformation Œ± : F ‚àí‚ÜíG : G ‚àí‚ÜíD is called a natural
isomorphism if there is a natural transformation Œ≤ : G ‚àí‚ÜíF which is an inverse to Œ± in the category
Mod(G , D). Natural isomorphisms are often called natural equivalences.

5.2 Natural transformations
45
5.2.20 Example
The arrow (h, k) : f ‚àí‚Üíg in the arrow category of a category C , as shown in (5.22),
is a natural isomorphism if and only if h and k are both isomorphisms in C . This is a special case of an
important fact about natural isomorphisms, which we now state.
5.2.21 Theorem
Suppose F : G ‚àí‚ÜíD and G : G ‚àí‚ÜíD are models of G in D and Œ± : F ‚àí‚ÜíG is a
natural transformation of models. Then Œ± is a natural isomorphism if and only if for each node a of G ,
Œ±a : F(a) ‚àí‚ÜíG(a) is an isomorphism of D.
Proof. Suppose Œ± has an inverse Œ≤ : G ‚àí‚ÜíF in Mod(G , D). Then for any node a, by DeÔ¨Ånition 5.2.11,
DeÔ¨Ånition 5.2.13, and the deÔ¨Ånition of inverse,
Œ±a ‚ó¶Œ≤a = (Œ± ‚ó¶Œ≤)a = idG a = idG(a)
and
Œ≤a ‚ó¶Œ±a = (Œ≤ ‚ó¶Œ±)a = idF a = idF (a)
which means that the arrow Œ≤a is the inverse of the arrow Œ±a, so that Œ±a is an isomorphism in D as
required.
Conversely, suppose that for each node a of G , Œ±a : F(a) ‚àí‚ÜíG(a) is an isomorphism of D. The
component of the inverse Œ≤ at a node a is deÔ¨Åned by letting Œ≤a = (Œ±a)‚àí1. This is the only possible
deÔ¨Ånition, but it must be shown to be natural. Let f : a ‚àí‚Üíb be an arrow of the domain of F and G.
Then we have
Ff ‚ó¶(Œ±a)‚àí1
=
(Œ±b)‚àí1 ‚ó¶(Œ±b) ‚ó¶Ff ‚ó¶(Œ±a)‚àí1
=
(Œ±b)‚àí1 ‚ó¶Gf ‚ó¶(Œ±a) ‚ó¶(Œ±a)‚àí1
=
(Œ±b)‚àí1 ‚ó¶Gf
which says that Œ≤ is natural. The second equality uses the naturality of Œ±.
5.2.22 Monic natural transformations
Let Œ± : F ‚àí‚ÜíG be a natural transformation between mod-
els of G in D. Suppose each component of Œ± is a monomorphism in D. Then it is easy to prove that Œ± is
a monomorphism in Mod(G , D). The converse is not true (see Section 4.2.21 of [Barr and Wells, 1999]).
5.2.23 ‚ÄòEssentially the same‚Äô
In 5.2.17, we said that a model in an arbitrary category C of the
graph (5.21) is ‚Äòessentially the same‚Äô as an arrow in C . This is common terminology and usually refers
implicitly to an equivalence of categories. We spell it out in this case.
Let us say that for a category C , C ‚Ä≤ is the category whose objects are the arrows of C and for which
an arrow from f to g is a pair (h, k) making Diagram (5.22) commute.
A model M of the graph (5.21) in a category C speciÔ¨Åes the objects M(0) and M(1) and the arrow
M(u). M(u) has domain M(0) and codomain M(1). But the domain and codomain of an arrow in a
category are uniquely determined by the arrow. So that the only necessary information is which arrow
M(u) is.
Now we can deÔ¨Åne a functor F : C ‚àí‚Üí‚àí‚ÜíC ‚Ä≤. On objects it take M to M(u). The remarks in the
preceding paragraph show that this map on objects is bijective. If M(u) = f and N(u) = g, an arrow
from M to N in C ‚àí‚Üíand an arrow from f to g in C ‚Ä≤ are the same thing ‚Äì a pair (h, k) making
Diagram (5.22) commute. So we say F is the identity on arrows. It is straightforward to see that F is
actually an isomorphism of categories.
In most texts, the arrow category C ‚àí‚Üíis deÔ¨Åned the way we deÔ¨Åned C ‚Ä≤.
When being careful, one would say as above that a model in C of the graph (5.21) is essentially the same
as an arrow in C , and that a u-structure is essentially the same as a model of U (as in 5.2.15). Frequently,
one says more bluntly that a model of (5.21) in C is an arrow in C and that a u-structure is a model of U
(and ‚Äòis an N-set‚Äô). This usage is perhaps based on the conception that the description ‚Äòmodel of (5.21) in
C ‚Äô and ‚Äòarrow in C ‚Äô are two ways of describing the same mathematical object, which exists independently
of any particular description. Not all mathematicians share this conception of mathematical objects.

46
Diagrams and naturality
5.3 Natural transformations
between functors
A functor is among other things a graph homomorphism, so a natural transformation between two func-
tors is a natural transformation of the corresponding graph homomorphisms. The following proposition
is an immediate consequence of 5.2.12.
5.3.1 Proposition
If C and D are categories, the functors from C to D form a category with natural
transformations as arrows.
We denote this category by Func(C , D). Other common notations for it are DC and [C , D]. Tennent
[1986] provides an exposition of the use of functor categories for programming language semantics.
Of course, the graph homomorphisms from C to D, which do not necessarily preserve the composition
of arrows in C , also form a category Mod(C , D) (see 5.2.14), of which Func(C , D) is a full subcategory.
A natural transformation from one functor to another is a special case of a natural transformation from
one graph homomorphism to another, so the ideas we have presented concerning natural transformations
between graph homomorphisms apply to natural transformations between functors as well. In particular,
Theorems 5.2.12 and 5.2.21 are true of natural transformations of functors.
If C is not a small category (see 2.1.5), then Func(C ,D) may not be locally small (see 2.1.7). This is a
rather esoteric question that will not concern us in these notes since we will have no occasion to form functor
categories of that sort.
We motivated the concept of natural transformation by considering models of graphs, and most of the
discussion in the rest of this section concerns that point of view. Historically, the concept Ô¨Årst arose for
functors and not from the point of view of models.
5.3.2 Examples
We have already described some examples of natural transformations, as summed
up in the following propositions.
In 4.1.15, we deÔ¨Åned the graph homomorphism Œ∑G : G ‚àí‚ÜíU(F(G )) which includes a graph G into
U(F(G )), the underlying graph of the free category F(G ).
5.3.3 Proposition
The family of arrows Œ∑G form a natural transformation from the identity functor
on Grf to U ‚ó¶F, where U is the underlying graph functor from Cat to Grf.
The proof is left as an exercise.
In 4.4.2, we deÔ¨Åned the concept of equivalence of categories.
5.3.4 Proposition
A functor F : C ‚àí‚ÜíD is an equivalence of categories with pseudo-inverse G : D
‚àí‚ÜíC if and only if G ‚ó¶F is naturally isomorphic to idC and F
‚ó¶G is naturally isomorphic to idD.
Proof. Conditions E‚Äì2 and E‚Äì3 of 4.4.2 can be recast as the statement that G(F(f)) ‚ó¶uC = uC‚Ä≤ ‚ó¶f and
that F(G(g)) ‚ó¶vD = vD‚Ä≤ ‚ó¶g, in other words that the following diagrams commute:
C‚Ä≤
G(F(C‚Ä≤))
-
uC‚Ä≤
C
G(F(C))
-
uC
?
f
?
G(F(f))
D‚Ä≤
F(G(D‚Ä≤))
-
vD‚Ä≤
D
F(G(D))
-
vD
?
g
?
F(G(g))
In this form, they are the statements that u is a natural transformation from idC to G ‚ó¶F and that v
is a natural transformation from idD ‚àí‚ÜíF
‚ó¶G. Since each component of u and each component of v is
an isomorphism, u and v are natural equivalences.
5.3.5 Example
Let Œ± : M √ó S ‚àí‚ÜíS and Œ≤ : M √ó T ‚àí‚ÜíT be two actions by a monoid M (see 4.2.1).
Let œÜ : S ‚àí‚ÜíT be an equivariant map. If F and G are the functors corresponding to Œ± and Œ≤, as deÔ¨Åned
in 4.2.4, then œÜ is the (only) component of a natural transformation from F to G. Conversely, the only
component of any natural transformation from F to G is an equivariant map between the corresponding
actions.

5.4 Natural transformations involving lists
47
5.3.6 Example
Let U : Mon ‚àí‚ÜíSet be the underlying functor from the category of monoids. DeÔ¨Åne
U √ó U : Mon ‚àí‚ÜíSet as follows:
(i) For a monoid M, (U √ó U)(M) = U(M) √ó U(M).
(ii) For a monoid homomorphism h : M ‚àí‚ÜíN,
(U √ó U)(h)(m, n) = (h(m), h(n))
Then monoid multiplication is a natural transformation from U √ó U to U. Formally: Let ¬µ : U √ó U
‚àí‚ÜíU be the family of maps whose value at a monoid M is the function ¬µM : U(M) √ó U(M) ‚àí‚ÜíU(M)
deÔ¨Åned by ¬µM(m, m‚Ä≤) = mm‚Ä≤, the product of m and m‚Ä≤ in M. Then ¬µ is a natural transformation. (The
function ¬µM is not in general a monoid homomorphism, unless M is commutative.)
It is instructive to see why ¬µ is a natural transformation. Let h : M ‚àí‚ÜíN be a monoid homomorphism.
We must show that the following diagram commutes:
(U √ó U)(N)
U(N)
-
¬µN
(U √ó U)(M)
U(M)
-
¬µM
?
(U √ó U)(h)
?
h
(5.23)
The top route takes an element (m,m‚Ä≤) ‚àà(U √óU)(M) to h(mm‚Ä≤). The lower route takes it to h(m)h(m‚Ä≤).
The commutativity of the diagram then follows from the fact that h is a homomorphism.
5.3.7 Example
Let C be a category. A subfunctor of a functor F : C ‚àí‚ÜíSet is a functor G : C
‚àí‚ÜíSet with the property that for each object C of C , G(C) ‚äÜF(C) and such that for each arrow f : C
‚àí‚ÜíC‚Ä≤ and each element x ‚ààGC, we have that Gf(x) = Ff(x). It is straightforward to check that the
inclusion function iC : G(C) ‚àí‚ÜíF(C) is a natural transformation.
5.3.8 Example
Let B be a Ô¨Åxed set. We deÔ¨Åne a functor R : Set op ‚àí‚ÜíSet such that for a set A,
R(A) = Rel(A, B), the set of relations from A to B. (A relation from A to B is essentially set of ordered
pairs in A √ó B.) For a set function F : A‚Ä≤ ‚àí‚ÜíA and relation Œ± ‚ààRel(A, B), deÔ¨Åne R(F)(Œ±) to be the
relation Œ±‚Ä≤ ‚ààRel(A‚Ä≤,B) deÔ¨Åned by a‚Ä≤Œ±‚Ä≤b if and only if F(a‚Ä≤)Œ±b. It is easy to see that this makes R : Set op
‚àí‚ÜíSet a functor. (Note that R(A) = Rel(A, B), but R is not HomRel(‚àí, B).)
For each A, let œÜA : Rel(A, B) ‚àí‚ÜíHom(A, PB) be the bijection that takes a relation Œ± from A to B
to the function that takes an element a ‚ààA to the set {b ‚ààB | aŒ±b}. (You should check that this is a
bijection.) If we check that the functions œÜA are the components of a natural transformation from R to
Hom(A, PB), the transformation will automatically be a natural isomorphism by Theorem 5.2.21. To
show that it is natural, let Œ± ‚ààRel(A, B) and a‚Ä≤ ‚ààA‚Ä≤. Then
Hom(F, PB) (œÜA(Œ±)(a‚Ä≤))
=
œÜA(Œ±) (F(a‚Ä≤))
=
{b | F(a‚Ä≤)Œ±b}
=
{b | a‚Ä≤Œ±‚Ä≤b}
=
œÜA‚Ä≤ (R(F)(a‚Ä≤))
as required.
This natural isomorphism can be taken to be the deÔ¨Åning property of a topos (Section 11.2.2).
5.3.9 Example
For each set S, let {}S : S ‚àí‚ÜíPS be the function which takes an element x of S to
the singleton subset {x}. Then {} is a natural transformation from the identity functor on Set to the
direct image powerset functor P. (See 4.1.17.)
However, {} is not a natural transformation from the identity functor on Set to the universal image
powerset functor (see 4.1.20), and it does not even make sense to ask whether it is a natural transfor-
mation to the inverse image powerset functor.
5.4 Natural transformations involving lists
Many of the operations on lists available in functional programming languages can be seen as natural
transformations involving the Kleene closure or list functor (4.1.13). x

48
Diagrams and naturality
5.4.1 Example
One can apply the Kleene closure twice to get the list of lists functor that takes a set
A to A‚àó‚àó. An element of A‚àó‚àóis a list of lists. For example, if A = {a,b}, one of the elements of A‚àó‚àóis w =
((a,b),(b,b,a),(),(a)). If f : A ‚àí‚ÜíB is a function, f ‚àó‚àótakes w to ((f(a),f(b)),(f(b),f(b),f(a)),(),(f(a))).
The operation of Ô¨Çattening a list simply concatenates the lists in the list; for example, Ô¨Çatten(w) =
(a, b, b, b, a, a). Of course, Ô¨Çatten is a distinct function for each set A; if we write Ô¨ÇattenA : A‚àó‚àó‚àí‚ÜíA‚àófor
each set A, then Ô¨Çatten is a natural transformation from ‚àó‚àóto ‚àó, as you can see by checking that this
diagram commutes for each function f : A ‚àí‚ÜíB:
B‚àó‚àó
B‚àó
-
Ô¨ÇattenB
A‚àó‚àó
A‚àó
-
Ô¨ÇattenA
?
f ‚àó‚àó
?
f ‚àó
(5.24)
5.4.2 Example
Another operation in functional programming languages consists of applying a binary
operation to a list. This is called reduce, apply or fold. We shall consider only the case when the binary
operation is associative. (When it is not associative, some choice is made about how to associate the list.)
This gives a natural transformation from F
‚ó¶U to idMon, where F : Set ‚àí‚ÜíMon is the free monoid
functor and U : Mon ‚àí‚ÜíSet is the underlying set functor. For example, if M is a monoid with elements
k, m and n, then reduce(k,k,n,m) = k2nm, the product of the list using the operation of M. In this case,
naturality means that for any monoid homomorphism h : M ‚àí‚ÜíN, h ‚ó¶reduceM = reduceN
‚ó¶F(U(h)),
which is easily checked.
Note that although both reduce and Ô¨Çatten take lists as arguments, reduceM is a monoid homo-
morphism with domain F(U(M)) (whose elements are lists), whereas Ô¨ÇattenA is a set function with
domain A‚àó‚àó. This is reÔ¨Çected by the fact that, when implemented in a programming language, reduce
takes an operation as well as a list as argument, but Ô¨Çatten takes only a list.
These and other list operations can often be generalized to sets of expressions instead of sets of
lists. In particular, Ô¨Çatten in this more general sense is one of the fundamental constituents of triples
(Section 10.1), namely ¬µ.
More about these ideas may be found in [Bird, 1986] and [Spivey, 1989].
5.5 Natural transformations of graphs
We now consider some natural transformations involving the category Grf of graphs and homomorphisms
of graphs.
5.5.1 Example
The map which takes an arrow of a graph to its source is a natural transformation from
A to N. (See 4.1.10.) The same is true for targets. Actually, every operation in any multisorted algebraic
structure gives a natural transformation. Example 5.3.6 was another example of this. See [Linton, 1969b],
[Linton, 1969a].
5.5.2 Example
In 4.1.10, we deÔ¨Åned the functor N : Grf ‚àí‚ÜíSet. It takes a graph G to its set G0 of
nodes and a homomorphism œÜ to œÜ0. Now pick a graph with one node ‚àóand no arrows and call it E .
Let V = HomGrf (E , ‚àí).
A graph homomorphism from the graph E to an arbitrary graph G is evidently determined by the
image of E and that can be any node of G . In other words, nodes of G are ‚Äòessentially the same thing‚Äô
as graph homomorphisms from E to G , that is, as the elements of the set V (G ).
We can deÔ¨Åne a natural transformation Œ± : V ‚àí‚ÜíN by deÔ¨Åning
Œ±G (f) = f0(‚àó)

5.6 Combining natural transformations and functors
49
where G is a graph and f : E ‚àí‚ÜíG is a graph homomorphism (arrow of Grf). There must be a naturality
diagram (5.19) for each arrow of the source category, which in this case is Grf. Thus to see that Œ± is
natural, we require that for each graph homomorphism g : G1 ‚àí‚ÜíG2, the diagram
NG1
NG2
-
Ng
V G1
V G2
-
V g
?
Œ±G1
?
Œ±G2
commutes. Now Ng is g0 (the node map of g) by deÔ¨Ånition, and the value of V (which is a hom functor)
at a homomorphism g composes g with a graph homomorphism from the graph E . Then we have, for a
homomorphism f : E ‚àí‚ÜíG1 (i.e., an element of the upper left corner of the diagram),
(Œ±G2 ‚ó¶V g)(f) = Œ±G2(g ‚ó¶f) = (g ‚ó¶f)0(‚àó)
while
(Ng ‚ó¶Œ±G1)(f) = Ng(f0(‚àó)) = g0(f0(‚àó))
and these are equal from the deÔ¨Ånition of composition of graph homomorphisms.
The natural transformation Œ± is in fact a natural isomorphism. This shows that N is naturally
isomorphic to a hom functor. Such functors are called ‚Äòrepresentable‚Äô, and are considered in greater
detail in 5.7.1.
5.5.3 Connected components
A node a can be connected to the node b of a graph G if it is
possible to get from a to b following a sequence of arrows of G in either direction. In order to state this
more precisely, let us say that an arrow a ‚Äòhas‚Äô a node n if n is the domain or the codomain (or both)
of a. Then a is connected to b means that there is a sequence (c0, c1, . . . , cn) of arrows of G with the
property that a is a node (either the source or the target) of c0, b is a node of cn, and for i = 1, . . . , n,
ci‚àí1 and ci have a node in common. We call such a sequence an undirected path between a and b.
It is a good exercise to see that ‚Äòbeing connected to‚Äô is an equivalence relation. (For reÔ¨Çexivity: a node
is connected to itself by the empty sequence.) An equivalence class of nodes with respect to this relation
is called a connected component of the graph G , and the set of connected components is called WG .
Connected components can be deÔ¨Åned for categories in the same way as for graphs. In that case, each
connected component is a full subcategory.
If f : G ‚àí‚ÜíH is a graph homomorphism and if two nodes a and b are in the same component of G ,
then f(a) and f(b) are in the same component of H ; this is because f takes an undirected path between
a and b to an undirected path between f(a) and f(b). Thus the arrow f induces a function Wf : WG
‚àí‚ÜíWH , namely the one which takes the component of a to the component of f(a); and this makes W
a functor from Grf to Set.
For a graph G , let Œ≤G : NG ‚àí‚ÜíWG be the set function which takes a node of G to the component
of G that contains that node. (The component is the value of Œ≤G at the node, not the codomain.) Then
Œ≤ : N ‚àí‚ÜíW is a natural transformation. It is instructive to check the commutativity of the requisite
diagram.
5.6 Combining natural transformations and functors
5.6.1 Composites of natural transformations
Let F : A ‚àí‚ÜíB and G : B ‚àí‚ÜíC be functors.
There is a composite functor G ‚ó¶F : A ‚àí‚ÜíC deÔ¨Åned in the usual way by G ‚ó¶F(A) = G(F(A)). Similarly,
let H, K and L be functors from A ‚àí‚ÜíB and Œ± : H ‚àí‚ÜíK and Œ≤ : K ‚àí‚ÜíL be natural transformations.
Recall that this means that for each object A of A , Œ±A : HA ‚àí‚ÜíKA and Œ≤A : KA ‚àí‚ÜíLA. Then as
in 5.2.11, we deÔ¨Åne Œ≤ ‚ó¶Œ± : H ‚àí‚ÜíL by
(Œ≤ ‚ó¶Œ±)A = Œ≤A ‚ó¶Œ±A
There is a second way of composing natural transformations. See [Barr and Wells, 1999], Section 4.5.

50
Diagrams and naturality
5.6.2 Functors and natural transformations
Things get more interesting when we mix functors
and natural transformations. For example, suppose we have three categories A , B and C , four functors,
two of them, F, G : A ‚àí‚ÜíB and the other two H, K : B ‚àí‚ÜíC , and two natural transformations Œ± : F
‚àí‚ÜíG and Œ≤ : H ‚àí‚ÜíK. We picture this situation as follows:
A
B
R
F

G
‚áìŒ±
C
R
H

K
‚áìŒ≤
(5.25)
5.6.3 DeÔ¨Ånition
The natural transformation Œ≤F : H ‚ó¶F ‚àí‚ÜíK ‚ó¶F is deÔ¨Åned by the formula (Œ≤F)A =
Œ≤(FA) for an object A of A .
The notation Œ≤(FA) means the component of the natural transformation Œ≤ at the object FA. This is
indeed an arrow from H(F(A)) ‚àí‚ÜíK(F(A)) as required. To show that Œ≤F is natural requires showing
that for an arrow f : A ‚àí‚ÜíA‚Ä≤ of A , the diagram
H(F(A‚Ä≤))
K(F(A‚Ä≤))
-
Œ≤FA‚Ä≤
H(F(A))
K(F(A))
-
Œ≤FA
?
H(F(f))
?
K(F(f))
(5.26)
commutes, but this is just the naturality diagram of Œ≤ applied to the arrow F(f) : F(A) ‚àí‚ÜíF(A‚Ä≤).
5.6.4 DeÔ¨Ånition
The natural transformation HŒ± : H
‚ó¶F ‚àí‚ÜíH
‚ó¶G is deÔ¨Åned by letting (HŒ±)A =
H(Œ±A) for an object A of A , that is the value of H applied to the arrow Œ±A.
To see that HŒ± thus deÔ¨Åned is natural requires showing that
H(F(A‚Ä≤))
H(G(A‚Ä≤))
-
H(Œ±A‚Ä≤)
H(F(A))
H(G(A))
-
H(Œ±A)
?
H(F(f))
?
H(G(f))
commutes. This diagram is obtained by applying the functor H to the naturality diagram of Œ±. Since
functors preserve commutative diagrams, the result follows.
Note that the proofs of naturality for Œ≤F and for HŒ± are quite diÔ¨Äerent. For example, the second
requires that H be a functor, while the Ô¨Årst works if F is merely an object function.
5.7 The Yoneda Lemma and
universal elements
For an arbitrary category C , the functors from C to Set are special because the hom functors Hom(C,‚àí)
for each object C of C are set-valued functors. In this section, we introduce the concept of representable
functor, the Yoneda Lemma, and universal elements, all of which are based on these hom functors. These
ideas have turned out to be fundamental tools for categorists. They are also closely connected with the
concept of adjunction, to be discussed later (note Theorem 9.3.2 and Proposition 9.3.6).
If you are familiar with group theory, it may be illuminating to realize that representable functors are
a generalization of the regular representation, and the Yoneda embedding is a generalization of Cayley‚Äôs
Theorem.
We have already considered set-valued functors as actions in Section 4.2.

5.7 Yoneda Lemma
51
5.7.1 Representable functors
A functor from a category C to the category of sets (a set-valued
functor) is said to be representable if it is naturally isomorphic to a hom functor; see 4.1.21. A
covariant functor is representable if it is naturally isomorphic to Hom(C, ‚àí) for some object C of C ; in
this case one says that C represents the functor. A contravariant functor is representable if it is naturally
isomorphic to Hom(‚àí, C) for some object C (and then C represents the contravariant functor).
We have already looked at one example of representable functor in some detail in 5.5.2, where we
showed that the set-of-nodes functor for graphs is represented by the graph with one node and no arrows.
The set-of-arrows functor is represented by the graph with two nodes and one arrow between them.
5.7.2 Example
The identity functor on Set is represented by the terminal object; in other words,
HomSet(1, ‚àí) is naturally isomorphic to the identity functor. This can be described by saying that ‚Äòa
set is its set of global elements.‚Äô
5.7.3 Example
The arrow functor A : Grf ‚àí‚ÜíSet of 4.1.10 is represented by the graph 2 which is
pictured as
1
2
-
e
5.7.4 Example
The set of objects of a small category is ‚Äòessentially the same thing‚Äô as the set of global
elements of the category (as an object of Cat). In other words, the set of objects functor is represented
by the terminal object of Cat, which is the category with one object and one arrow.
The set of arrows of a small category is the object part of a functor that is represented by the category
2, which is the graph 2 with the addition of two identity arrows.
5.7.5 The Yoneda embedding
Let C be a category. There is a functor Y : C op ‚àí‚ÜíFunc(C , Set),
the Yoneda functor, deÔ¨Åned as follows. Note that Y must take an object of C to a functor and an
arrow of C to a natural transformation.
Y‚Äì1 For an object C of C , Y (C) = Hom(C, ‚àí).
Y‚Äì2 If f : D ‚àí‚ÜíC in C and A is an object of C , then the component Y (f)A of Y (f) : Hom(C, ‚àí)
‚àí‚ÜíHom(D, ‚àí) is Hom(f, A) : Hom(C, A) ‚àí‚ÜíHom(D, A) (see 4.1.22).
Note that Y (C) is a covariant hom functor and that Y (f)A is a component of a contravariant hom
functor.
To see that Y (f) is a natural transformation requires checking that this diagram commutes for every
arrow k : A ‚àí‚ÜíB of C :
Hom(C, A)
Hom(C, B)
-
Hom(C, k)
Hom(D, A)
Hom(D, B)
-
Hom(D, k)
6
Y (f)A
6
Y (f)B
To see that it commutes, start with h : C ‚àí‚ÜíA, an arbitrary element of the lower left corner. The lower
route takes this to k ‚ó¶h, then to (k ‚ó¶h) ‚ó¶f. The upper route takes it to k ‚ó¶(h ‚ó¶f), so the fact that
the diagram commutes is simply a statement of the associative law. In a monoid, that this diagram
commutes is the statement that the function deÔ¨Åned by left multiplying by a given element commutes
with the function deÔ¨Åned by right multiplying by another given element.
Y (f) : Hom(C, ‚àí) ‚àí‚ÜíHom(D, ‚àí) is the induced natural transformation corresponding to f.
The main theorem concerning Y is the following.
5.7.6 Theorem
Y : C op ‚àí‚ÜíFunc(C , Set) is a full and faithful functor.
The fact that Y is full and faithful is encapsulated in the following remarkable corollary.

52
Diagrams and naturality
5.7.7 Corollary
Every natural transformation
Hom(C, ‚àí) ‚àí‚ÜíHom(D, ‚àí)
is given by composition with a unique arrow D ‚àí‚ÜíC. The natural transformation is an isomorphism
if and only if the corresponding arrow D ‚àí‚ÜíC is an isomorphism. In particular, if F : C ‚àí‚ÜíSet is
represented by both C and D, then C ‚àº= D.
This means that you can construct an arrow in a category by constructing a natural transformation
between hom functors. This is one of the most widely used techniques in category theory.
Proof. Theorem 5.7.6 is an immediate corollary of the Yoneda Lemma (5.7.11). We give a direct proof
here. This proof is an excellent exercise in manipulating natural transformations and hom sets.
Let f, g : D ‚àí‚ÜíC in C . The component
Y (f)C : Hom(C, C) ‚àí‚ÜíHom(D, C)
of the natural transformation Y (f) at C takes idC to f, and similarly Y (g)C takes idC to g. Thus if
f Ã∏= g, then Y (f)C Ã∏= Y (g)C, so that Y (f) Ã∏= Y (g). Thus Y is faithful.
We must show that Y is full. Given œÜ : Hom(C, ‚àí) ‚àí‚ÜíHom(D, ‚àí), we get the required f : D ‚àí‚ÜíC
by one of the basic tricks of category theory: we deÔ¨Åne f = œÜC(idC). The component of œÜ at C is a
function œÜC : Hom(C, C) ‚àí‚ÜíHom(D, C), so this deÔ¨Ånition makes sense.
To complete the proof, we must prove that if k : C ‚àí‚ÜíA is any arrow of C , then œÜA(k) = k ‚ó¶f : D
‚àí‚ÜíA. This follows from the fact that the following diagram commutes by naturality of œÜ:
Hom(D, C)
Hom(D, A)
-
Hom(D, k)
Hom(C, C)
Hom(C, A)
-
Hom(C, k)
?
œÜC
?
œÜA
If you start in the northwest corner with idC, the upper route takes you to œÜA(k) in the southeast corner,
whereas the lower route takes you to k ‚ó¶f, as required.
5.7.8
By replacing C by C op in Theorem 5.7.6, we derive a second Yoneda functor
J : C ‚àí‚ÜíFunc(C op, Set)
which is also full and faithful. For an object C of C , J(C) = Hom(‚àí, C), the contravariant hom functor.
If f : C ‚àí‚ÜíD in C and A is an object of C , then the component
J(f)A : Hom(A, C) ‚àí‚ÜíHom(A, D)
of the natural transformation J(f) : Hom(‚àí, C) ‚àí‚ÜíHom(‚àí, D) is
Hom(A, f) : Hom(A, C) ‚àí‚ÜíHom(A, D)
The fact that J is full and faithful means that an arrow from A to B of C can be uniquely deÔ¨Åned
by giving a natural transformation from Hom(‚àí, A) to Hom(‚àí, B). This statement is the dual of Corol-
lary 5.7.7. Such a natural transformation Œ± : Hom(‚àí,A) ‚àí‚ÜíHom(‚àí,B) has a component Œ±T : Hom(T,A)
‚àí‚ÜíHom(T, B) for each object T of C . The eÔ¨Äect of this is that you can deÔ¨Åne an arrow from A to B by
giving a function Œ±T : Hom(T, A) ‚àí‚ÜíHom(T, B) for each object T which prescribes a variable element
of B for each variable element of A (as described in 3.3.2), in such a way that for each f : T ‚Ä≤ ‚àí‚ÜíT, the
diagram
Hom(T ‚Ä≤, A)
Hom(T ‚Ä≤, B)
-
Œ±T ‚Ä≤
Hom(T, A)
Hom(T, B)
-
Œ±T
?
Hom(f, A)
?
Hom(f, B)
commutes. This can be summed up by saying, ‚ÄòAn arrow is induced by deÔ¨Åning its value on each variable
element of its domain, provided that the deÔ¨Ånition is natural with respect to change of parameters.‚Äô

5.7 Yoneda Lemma
53
5.7.9 Elements of a set-valued functor
Corollary 5.7.7 says that any natural transformation from
Hom(C, ‚àí) to Hom(D, ‚àí) is given by a unique arrow from D to C, that is, by an element of Hom(D, C),
which is Hom(D,‚àí)(C). Remarkably, the result remains true when Hom(D,‚àí) is replaced by an arbitrary
set-valued functor.
Suppose F : C ‚àí‚ÜíSet is a functor and C is an object of C . An element c ‚ààF(C) induces a natural
transformation from the representable functor Hom(C, ‚àí) to F by the formula
f 7‚ÜíF(f)(c)
(5.27)
That is, if f : C ‚àí‚ÜíC‚Ä≤ is an element of Hom(C,C‚Ä≤), the deÔ¨Ånition of functor requires an induced function
F(f) : F(C) ‚àí‚ÜíF(C‚Ä≤) and this function can be evaluated at c ‚ààF(C).
5.7.10 Proposition
Formula (5.27) deÔ¨Ånes a natural transformation
Hom(C, ‚àí) ‚àí‚ÜíF
Proof. Let Œ±C‚Ä≤ : Hom(C,C‚Ä≤) ‚àí‚ÜíF(C‚Ä≤) take f to F(f)(c) for c ‚ààF(C). We must show that for any g : C‚Ä≤
‚àí‚ÜíB,
Hom(C, B)
F(B)
-
Œ±B
Hom(C, C‚Ä≤)
F(C‚Ä≤)
-
Œ±C‚Ä≤
?
Hom(C, g)
?
F(g)
(5.28)
commutes. We have, for f ‚ààHom(C, C‚Ä≤),
Œ±B(Hom(C, g)(f)) = Œ±B(g ‚ó¶f) = F(g ‚ó¶f)(c)
= F(g)(F(f)(c)) = F(g)(Œ±C‚Ä≤(f))
as required.
5.7.11 Theorem
(Yoneda Lemma) Formula (5.27) deÔ¨Ånes a one to one correspondence between ele-
ments of F(C) and natural transformations
Hom(C, ‚àí) ‚àí‚ÜíF
Proof. Suppose that c and c‚Ä≤ are diÔ¨Äerent elements of F(C). Then the natural transformation corre-
sponding to c takes idC to c whereas the one corresponding to c‚Ä≤ takes idC to c‚Ä≤. Thus the mapping of
the Yoneda Lemma is injective.
Suppose Œ≤ : Hom(C, ‚àí) ‚àí‚ÜíF is a natural transformation. Then we have Œ≤C : Hom(C, C) ‚àí‚ÜíF(C).
Let c = Œ≤C(idC) ‚ààF(C). For any f : C ‚àí‚ÜíC‚Ä≤, the naturality of Œ≤ gives that
Œ≤C‚Ä≤(Hom(C, f)(idC)) = F(f)(Œ≤C)(idC)
The left hand side is Œ≤C‚Ä≤(f) and the right hand side is F(f)(c). Thus Œ≤ is the natural transformation
given by Formula (5.27), so that the mapping of the Yoneda Lemma is surjective.
5.7.12 DeÔ¨Ånition
Let F : C ‚àí‚ÜíSet be a functor and let c be an element of F(C) for some object C
of C . If the natural transformation from Hom(C, ‚àí) to F induced by c is an isomorphism, then c is a
universal element of F.
The existence of a universal element means that F is representable (see 5.7.1). The converse is also
true because a natural isomorphism Œ± : Hom(C,‚àí) ‚àí‚ÜíF is, from the Yoneda lemma, induced by a unique
element c of F(C) and by deÔ¨Ånition Œ± is an isomorphism if and only if c is universal.

54
Diagrams and naturality
5.7.13 Example
Let D : Set ‚àí‚ÜíSet be the functor for which for a set A, D(A) = A √ó A, and for a
function f : A ‚àí‚ÜíB, D(f) : A √ó A ‚àí‚ÜíB √ó B is the function deÔ¨Åned by D(f)(a1, a2) = (f(a1), f(a2)).
Then D is represented by {1, 2} (or any other two-element set). A universal object is (1, 2) (or any other
pair with distinct coordinates.) The natural isomorphism from Hom({1, 2}, A) to A √ó A takes a function
f : {1, 2} ‚àí‚ÜíA to the pair (f(1), f(2)). The inverse takes a pair (a1, a2) to the function f for which
f(i) = ai.
The unique element c given by the deÔ¨Ånition of universal element can be calculated using the following
fact.
5.7.14 Proposition
Let Œ± : Hom(C,‚àí) ‚àí‚ÜíF be a natural isomorphism. The unique element c ‚ààF(C)
inducing Œ± is Œ±C(idC).
Proof. For an arbitrary f : C ‚àí‚ÜíC‚Ä≤, Œ±C‚Ä≤(f) = F(f)(Œ±C(idC)) because this diagram must commute
(chase idC around the square):
Hom(C, C‚Ä≤)
F(C‚Ä≤)
-
Œ±C‚Ä≤
Hom(C, C)
F(C)
-
Œ±C
?
Hom(C, f)
?
F(f)
Then, by Formula (5.27), Œ±C(idC) must be the required unique element c.
A detailed example of the use of this construction is in the proof of Proposition 6.2.14.
5.7.15
The deÔ¨Ånition of universal element can be reworded in elementary terms using Formula (5.27),
as follows.
5.7.16 Proposition
Let F : C ‚àí‚ÜíSet be a functor, C an object of C and c an element of F(C).
Then c is a universal element of F if and only if for any object C‚Ä≤ of C and any element x ‚ààF(C‚Ä≤)
there is a unique arrow f : C ‚àí‚ÜíC‚Ä≤ of C for which x = F(f)(c).
Proof. If c is a universal element then the mapping (5.27) must be an isomorphism, hence every com-
ponent must be bijective by Theorem 5.2.21. This immediately ensures the existence and uniqueness of
the required arrow f. Conversely, the existence and uniqueness of f for each C‚Ä≤ and x ‚ààF(C‚Ä≤) means
that there is a bijection Œ±C‚Ä≤ : Hom(C, C‚Ä≤) ‚àí‚ÜíF(C‚Ä≤) for every C‚Ä≤ which takes f : C ‚àí‚ÜíC‚Ä≤ to F(f)(c). By
Proposition 5.7.10, these are the components of a natural transformation, which is therefore a natural
isomorphism by Theorem 5.2.21.
In the case of a functor F : C op ‚àí‚ÜíSet, c in F(C) is a universal element if for any object C‚Ä≤ of C
and any element x ‚ààF(C‚Ä≤) there is a unique arrow f : C‚Ä≤ ‚àí‚ÜíC for which x = F(f)(c).
5.7.17 Corollary
If c ‚ààF(C) and c‚Ä≤ ‚ààF(C‚Ä≤) are universal elements, then there is a unique isomorph-
ism f : C ‚àí‚ÜíC‚Ä≤ such that F(f)(c) = c‚Ä≤.
The proof is omitted.
Universal elements are considered again in Proposition 9.3.6. The exposition in [Mac Lane, 1971] uses
the concept of universal element (deÔ¨Åned in the manner of the preceding proposition) as the central idea
in discussing representable functors and adjunction.

6. Products and sums
This chapter introduces products, which are constructions allowing the deÔ¨Ånition of operations of arbi-
trary arity, and sums, which allow the speciÔ¨Åcation of alternatives. In Set, the product is essentially the
cartesian product, and the sum is disjoint union.
6.1 The product of two objects in a category
6.1.1 DeÔ¨Ånition
If S and T are sets, the cartesian product S √óT is the set of all ordered pairs with
Ô¨Årst coordinate in S and second coordinate in T; in other words, S √ó T = {(s, t) | s ‚ààS and t ‚ààT}. The
coordinates are functions proj1 : S √óT ‚àí‚ÜíS and proj2 : S √óT ‚àí‚ÜíT called the coordinate projections,
or simply projections.
We give a speciÔ¨Åcation of product of two objects in an arbitrary category which will have the cartesian
product in Set as a special case. This speciÔ¨Åcation is given in terms of the coordinate projections,
motivated by these two facts:
(i) you know an element of S √ó T by knowing what its two coordinates are, and
(ii) given any element of S and any element of T, there is an element of S √ó T with the given element
of S as Ô¨Årst coordinate and the given element of T as second coordinate.
6.1.2 The product of two objects
Let A and B be two objects in a category C . By a (not the)
product of A and B, we mean an object C together with arrows proj1 : C ‚àí‚ÜíA and proj2 : C ‚àí‚ÜíB
that satisfy the following condition.
6.1.3
For any object D and arrows q1 : D ‚àí‚ÜíA and q2 : D ‚àí‚ÜíB, there is a unique arrow q : D ‚àí‚ÜíC:
A
C

proj1
B
-
proj2
D
q1
    	
?
q
q2
@
@
@@
R
(6.1)
such that proj1 ‚ó¶q = q1 and proj2 ‚ó¶q = q2.
6.1.4 Product cones
The speciÔ¨Åcation above gives the product as C together with proj1 and proj2.
The corresponding diagram
A
B
C
proj1    	
proj2
@
@@
R
(6.2)
is called a product diagram or product cone, and the arrows proji are called the projections. These
projections are indexed by the set {1, 2}. The base of the cone is the diagram D : I ‚àí‚ÜíC , where I is
the discrete graph with two nodes 1 and 2 and no arrows. This amounts to saying that the base of the
cone is the ordered pair (A, B). The diagram
B
A
C
proj1    	
proj2
@
@@
R
(6.3)
is regarded as a diÔ¨Äerent product cone since its base is the diagram D with D(1) = B and D(2) = A.
55

56
Products and sums
By a type of synecdoche, one often says that an object (such as C above) ‚Äòis‚Äô a product of two other
objects (here A and B), leaving the projections implicit, but the projections are nevertheless part of the
structure we call ‚Äòproduct‚Äô.
Products can be based on discrete graphs with other shape graphs, having more elements (Section 6.3)
or having other sets of nodes, for example attributes of a data base such as {NAME, SALARY} (see 6.3.13).
In this case the projections would be projNAME and projSALARY.
The existence of the unique arrow q with the property given in 6.1.3 is called the universal mapping
property of the product. Any object construction which is deÔ¨Åned up to a unique isomorphism (see
Theorem 6.2.2) in terms of arrows into or out of it is often said to be deÔ¨Åned by a universal mapping
property.
6.1.5 Products in Set
If S and T are sets, then the cartesian product S √ó T, together with the
coordinate functions discussed in 6.1.1, is indeed a product of S and T in Set. For suppose we have a
set V and two functions q1 : V ‚àí‚ÜíS and q2 : V ‚àí‚ÜíT. The function q : V ‚àí‚ÜíS √ó T deÔ¨Åned by
q(v) = (q1(v), q2(v))
for v ‚ààV is the unique function satisfying 6.1.3. Since proji(q(v)) = qi(v) by deÔ¨Ånition, q makes (6.1)
commute with U = S √ó T, and it must be the only such function since the commutativity of (6.1)
determines that its value at v must be (q1(v), q2(v)).
We discuss products in Rel and in Pfn in 6.4.7.
6.1.6 Products in categories of sets with structure
In many, but not all, categories of sets with
structure, the product can be constructed by endowing the product set with the structure in an obvious
way.
6.1.7 Example
If S and T are semigroups, then we can make S √ó T into a semigroup by deÔ¨Åning the
multiplication
(s1, t1)(s2, t2) = (s1s2, t1t2)
We verify associativity by the calculation
[(s1, t1)(s2, t2)](s3, t3)
=
(s1s2, t1t2)(s3, t3)
=
((s1s2)s3, (t1t2)t3)
=
(s1(s2s3), t1(t2t3))
=
(s1, t1)(s2s3, t2t3)
=
(s1, t1)[(s2, t2)(s3, t3)]
(6.4)
Furthermore, this structure together with the coordinate projections satisÔ¨Åes the deÔ¨Ånition of product
in the category of semigroups. To see this requires showing two things:
(a) The arrows proj1 : S √ó T ‚àí‚ÜíS and proj2 : S √ó T ‚àí‚ÜíT are homomorphisms of semigroups.
(b) If q1 and q2 are semigroup homomorphisms, then so is the arrow q determined by 6.1.3.
It is necessary to show both because the deÔ¨Ånition of product in a category C requires that the arrows
occurring in Diagram (6.1) be arrows of the category, in this case, Sem.
Requirement (a) follows from this calculation:
proj1((s1, t1)(s2, t2)) = proj1(s1s2, t1t2) = s1s2
= proj1(s1, t1) proj1(s2, t2)
and similarly for proj2.
As for requirement (b), let R be another semigroup and q1 : R ‚àí‚ÜíS and q2 : R ‚àí‚ÜíT be homomorph-
isms. Then
‚ü®q1, q2‚ü©(r1r2) = (q1(r1r2), q2(r1r2)) = (q1(r1)q1(r2), q2(r1)q2(r2))
= (q1(r1), q2(r1))(q1(r2), q2(r2))
= ‚ü®q1, q2‚ü©(r1)‚ü®q1, q2‚ü©(r2)
A construction for products similar to that for semigroups works for most other categories of sets
with structure. Also, the product of categories as deÔ¨Åned in 2.6.6 is the product of the categories in Cat.
One example of a category of sets with structure which lacks products is the category of Ô¨Åelds.

6.2 Properties of products
57
6.1.8 Example
Let G and H be two graphs. The product G √ó H in the category of graphs and
homomorphisms is deÔ¨Åned as follows: (G √óH )0 = G0 √óH0. An arrow from (g,h) to (g‚Ä≤,h‚Ä≤) is a pair (a,b)
with a : g ‚àí‚Üíg‚Ä≤ in G and b : h ‚àí‚Üíh‚Ä≤ in H . The projections are the usual Ô¨Årst and second projections.
6.1.9 Products in posets
We have already seen in 2.3.1 that any poset (partially ordered set) has
a corresponding category structure C(P). Let P be a poset and x and y two objects of C(P) (that is,
elements of P). Let us see what, if anything, is their product. A product must be an element z together
with a pair of arrows z ‚àí‚Üíx and z ‚àí‚Üíy, which is just another way of saying that z ‚â§x and z ‚â§y. The
deÔ¨Ånition of product also requires that for any w ‚ààP, given an arrow w ‚àí‚Üíx and one w ‚àí‚Üíy, there is
an arrow w ‚àí‚Üíz.
This translates to
w ‚â§x and w ‚â§y implies w ‚â§z
which, together with the fact that z ‚â§x and z ‚â§y, characterizes z as the inÔ¨Åmum of x and y, often
denoted x‚àßy. Thus the existence of products in such a category is equivalent to the existence of inÔ¨Åmums.
In particular, we see that products generalize a well-known construction in posets. Note that a poset
that lacks inÔ¨Åmums provides an easy example of a category without products.
6.1.10 Proposition
If A is an object in a category with a terminal object 1, then
1
A
A
‚ü®‚ü©   	
idA
@
@@
R
is a product diagram.
Proof. A cone over A and 1 has to have this form, where f : B ‚àí‚ÜíA is any arrow.
A
A

idA
1
-
‚ü®‚ü©
B
f
    	
?
‚ü®‚ü©
@
@
@@
R
Clearly the only possible arrow in the middle is f.
6.2 Notation for and properties
of products
6.2.1
Consider sets S = {1, 2, 3}, T = {1, 2} and U = {1, 2, 3, 4, 5, 6}. DeÔ¨Åne proj1 : U ‚àí‚ÜíS and proj2 :
U ‚àí‚ÜíT by this table:
u
proj1(u)
proj2(u)
1
2
1
2
1
1
3
3
1
4
2
2
5
1
2
6
3
2
Since the middle and right columns give every possible combination of a number 1, 2 or 3 followed by a
number 1 or 2, it follows that U, together with proj1 and proj2, is a product of S and T. For example,
if q1 : V ‚àí‚ÜíS and q2 : V ‚àí‚ÜíT are given functions and q1(v) = 1, q2(v) = 2 for some v in V , then the
unique function q : V ‚àí‚ÜíU satisfying 6.1.3 must take v to 5.

58
Products and sums
In eÔ¨Äect, proj1 and proj2 code the ordered pairs in S √ó T into the set U. As you can see, any choice
of a six-element set U and any choice of proj1 and proj2 which gives a diÔ¨Äerent element of U for each
ordered pair in S √ó T gives a product of S and T.
This example shows that the categorical concept of product gives a more general construction than
the cartesian product construction for sets. One cannot talk about ‚Äòthe‚Äô product of two objects, but
only of ‚Äòa‚Äô product. However, the following theorem says that two products of the same two objects are
isomorphic in a strong sense.
6.2.2 Theorem
Let C be a category and let A and B be two objects of C . Suppose
A
B
C
   	
@
@
@
R
and
A
B
D
   	
@
@
@
R
are both product diagrams. Then there is an arrow, and only one, from C to D such that
A
B
C
   	
@
@@
R
D
@
@
@
I
   
?
‚àº=
(6.5)
commutes and this arrow is an isomorphism.
The proof we give is quite typical of the kind of reasoning common in category theory and is worth
studying, although not necessarily on Ô¨Årst reading.
Proof. Let the projections be p1 : C ‚àí‚ÜíA, p2 : C ‚àí‚ÜíB, q1 : D ‚àí‚ÜíA and q2 : D ‚àí‚ÜíB. In accordance
with 6.1.3, there are unique arrows p : C ‚àí‚ÜíD and q : D ‚àí‚ÜíC for which
p1 ‚ó¶q
=
q1
p2 ‚ó¶q
=
q2
q1 ‚ó¶p
=
p1
q2 ‚ó¶p
=
p2
(6.6)
Thus we already know there is exactly one arrow (namely p) making Diagram (6.5) commute; all that
is left to prove is that p is an isomorphism (with inverse q).
The arrow q ‚ó¶p : C ‚àí‚ÜíC satisÔ¨Åes
p1 ‚ó¶q ‚ó¶p = q1 ‚ó¶p = p1 = p1 ‚ó¶idC
p2 ‚ó¶q ‚ó¶p = q2 ‚ó¶p = p2 = p2 ‚ó¶idC
and by the uniqueness part of 6.1.3, it follows that q ‚ó¶p = idC. If we exchange the p‚Äôs and q‚Äôs, we similarly
conclude that p ‚ó¶q = idD and hence that p and q are isomorphisms which are inverse to each other.
The following proposition is a converse to Theorem 6.2.2. Its proof is left as an exercise.
6.2.3 Proposition
Let
A
B
C
proj1    	
proj2
@
@@
R
be a product diagram, and suppose that an object D is isomorphic to C by an isomorphism i : D ‚àí‚ÜíC.
Then
A
B
D
proj1 ‚ó¶i    	
proj2 ‚ó¶i
@
@@
R
is a product diagram.

6.2 Properties of products
59
6.2.4
Categorists specify the product of two sets by saying that all they care about an element of the
product is what its Ô¨Årst coordinate is and what its second coordinate is. Theorem 6.2.2 says that two
structures satisfying this speciÔ¨Åcation are isomorphic in a unique way.
The name ‚Äò(s, t)‚Äô represents the element of the product with Ô¨Årst coordinate s and second coordinate
t. In a diÔ¨Äerent realization of the product, ‚Äò(s, t)‚Äô represents the element of that product with Ô¨Årst
coordinate s and second coordinate t. The isomorphism of Theorem 6.2.2 maps the representation in the
Ô¨Årst realization of the product into a representation in the second. Moreover, the universal property of
product says that any name ‚Äò(s, t)‚Äô with s ‚ààS and t ‚ààT represents an element of the product: it is the
unique element x ‚ààS √ó T with proj1(x) = s and proj2(x) = t.
In traditional approaches to foundations, the concept of ordered pair (hence the product of two sets)
is deÔ¨Åned by giving a speciÔ¨Åc model (or what a computer scientist might call an implementation) of
the speciÔ¨Åcation. Such a deÔ¨Ånition makes the product absolutely unique instead of unique up to an
isomorphism. We recommend that the reader read the discussion of this point in [Halmos, 1960], Section
6, who gives a beautiful discussion of (what in present day language we call) the diÔ¨Äerence between a
speciÔ¨Åcation and an implementation.
In categories other than sets there may well be no standard implementation of products, so the
speciÔ¨Åcation given is necessary. In Chapter 11, we will discuss a category known as the category of
modest sets in which any construction requires the choice of a bijection between N and N √ó N. There
are many such, and there is no particular reason to choose one over another.
6.2.5 Notation for products
It is customary to denote a product of objects A and B of a category
as A √ó B. Precisely, the name A √ó B applied to an object means there is a product diagram
A
B
A √ó B
proj1    	
proj2
@
@@
R
(6.7)
Using the name ‚ÄòA √ó B‚Äô implies that there are speciÔ¨Åc, but unnamed, projections given for the product
structure.
If A = B, one writes A √ó A = A2 and calls it the cartesian square of A.
The notations A √ó B and A2 may be ambiguous, but because of Theorem 6.2.2, it does not matter
for categorical purposes which product the symbol refers to.
Even in the category of sets, you do not really know which set A √ó B is unless you pick a speciÔ¨Åc deÔ¨Ånition
of ordered pair, and the average mathematician does not normally need to give any thought to the deÔ¨Ånition
because what really matters is the universal property that says that an ordered pair is determined by its
values under the projections.
6.2.6 Binary operations
A binary operation on a set S is a function from S √óS to S. An example
is addition on the natural numbers, which is a function + : N √ó N ‚àí‚ÜíN. This and other familiar binary
operations are usually written in inÔ¨Åx notation; one writes 3 + 5 = 8, for example, instead of +(3, 5) = 8.
In mathematics texts, the value of an arbitrary binary operation m at a pair (x, y) is commonly denoted
xy, without any symbol at all.
Using the concept of categorical product, we can now deÔ¨Åne the concept of binary operation on any
object S of any category provided only that there is a product S √ó S: a binary operation on S is an
arrow S √ó S ‚àí‚ÜíS.
The associative law (xy)z = x(yz) can be described using a commutative diagram as illustrated
in 5.1.11. In that section, the diagram is a diagram in Set, but now it has a meaning in any category
with products. (The meaning of expressions such as mult √óS in arbitrary categories is given in 6.2.17
below.)
The more general concept of function of two variables can now be deÔ¨Åned in a categorical setting: an
arrow f : A√óB ‚àí‚ÜíC can be thought of as the categorical version of a function of two variables. This has
the consequence that a categorist thinks of a function such as f : R√óR ‚àí‚ÜíR deÔ¨Åned by f(x,y) = x2 +y2
as a function of one variable, but that variable is a structured variable (an ordered pair). The notation
we have been using would suggest that one write this as f((x, y)) instead of f(x, y), but no one does.

60
Products and sums
6.2.7
Suppose we are given a product diagram (6.7). For each pair of arrows f : C ‚àí‚ÜíA and g : C
‚àí‚ÜíB requirement 6.1.3 produces a unique q : C ‚àí‚ÜíA √ó B making the following diagram commute.
A
A √ó B

proj1
B
-
proj2
C
f
     	
?
q
g
@
@
@
@
@
R
(6.8)
In other words, it produces a function
œÄC : HomC (C, A) √ó HomC (C, B) ‚àí‚ÜíHomC (C, A √ó B)
Thus q = œÄC(f, g).
6.2.8 Proposition
The function œÄC is a bijection.
Proof. œÄC is injective, since if (f, g) and (f ‚Ä≤, g‚Ä≤) are elements of
HomC (C, A) √ó HomC (C, B)
both of which produce the same arrow q making Diagram (6.8) commute, then f = proj1 ‚ó¶q = f ‚Ä≤, and
similarly g = g‚Ä≤.
It is also surjective, since if r : C ‚àí‚ÜíA √ó B is any arrow of C , then it makes
A
A √ó B

proj1
B
-
proj2
C
proj1 ‚ó¶r
     	
?
r
proj2 ‚ó¶r
@
@
@
@
@
R
(6.9)
commute, and so is the image of the pair (proj1 ‚ó¶r, proj2 ‚ó¶r) under œÄC.
6.2.9
It is customary to write ‚ü®f, g‚ü©for œÄC(f, g). The arrow ‚ü®f, g‚ü©internally represents the pair of
arrows (f, g) of the category C . Proposition 6.2.8 says that the representation is good in the sense
that ‚ü®f, g‚ü©and (f, g) each determine the other. Proposition 6.2.14 below says that the notation ‚ü®f, g‚ü©is
compatible with composition.
6.2.10
In the case of two products for the same pair of objects, the isomorphism of 6.2.2 translates the
arrow named ‚ü®f, g‚ü©for one product into the arrow named ‚ü®f, g‚ü©for the other, in the following precise
sense.
6.2.11 Proposition
Suppose
A
B
C
p1    	
p2
@
@@
R
A
B
D
q1    	
q2
@
@@
R
and
are two product diagrams and œÜ : C ‚àí‚ÜíD is the unique isomorphism given by Theorem 6.2.2. Let f : E
‚àí‚ÜíA and g : E ‚àí‚ÜíB be given and let u : E ‚àí‚ÜíC, v : E ‚àí‚ÜíD be the unique arrows for which p1 ‚ó¶u =
q1 ‚ó¶v = f and p2 ‚ó¶u = q2 ‚ó¶v = g. Then œÜ ‚ó¶u = v.

6.2 Properties of products
61
Note that in the statement of the theorem, both u and v could be called ‚Äò‚ü®f, g‚ü©‚Äô, as described in 6.2.9.
The ambiguity occurs because the pair notation does not name which product of A and B is being used.
It is rare in practice to have two diÔ¨Äerent products of the same two objects under consideration at the
same time.
Proof. By 6.2.2, pi = qi ‚ó¶œÜ, i = 1, 2. Using this, we have q1 ‚ó¶œÜ ‚ó¶u = p1 ‚ó¶u = f and similarly q2 ‚ó¶œÜ ‚ó¶
u = g. Since v is the unique arrow which makes q1 ‚ó¶v = u and q2 ‚ó¶v = g, it follows that œÜ ‚ó¶u = v.
This theorem provides another point of view concerning elements (s, t) of a product S √ó T. As
described in 3.2.3, the element s may be represented by an arrow s : 1 ‚àí‚ÜíS, and similarly t by t : 1
‚àí‚ÜíT. Then the arrow ‚ü®s, t‚ü©: 1 ‚àí‚ÜíS √ó T represents the ordered pair (s, t) whichever realization of S √ó T
is chosen.
6.2.12 The switch map
Our notation A √ó B means that A √ó B is the vertex of a product cone with
base the discrete diagram D with D(1) = A and D(2) = B. Then B √ó A denotes the product given by
the diagram
B
A
B √ó A
p1    	
p2
@
@@
R
(6.10)
where we use p1 and p2 to avoid confusing them with the arrows proj1 and proj2 of Diagram (6.7). (Of
course, this is an ad hoc solution. If one had to deal with this situation a lot it would be necessary to
introduce notation such as projA,B
1
and projB,A
1
.) Then this is a product diagram:
A
B
B √ó A
p2    	
p1
@
@@
R
(6.11)
It follows from Theorem 6.2.2 that there is an isomorphism ‚ü®p2, p1‚ü©: B √ó A ‚àí‚ÜíA √ó B (called the switch
map) that commutes with the projections. Its inverse is ‚ü®proj2, proj1‚ü©: A √ó B ‚àí‚ÜíB √ó A.
6.2.13
To show that the notation ‚ü®q1, q2‚ü©is compatible with composition, we will show that the arrows
œÄC deÔ¨Åned in 6.2.7 are the components of a natural isomorphism. To state this claim formally, we
need to make HomC (C, A) √ó HomC (C, B) into a functor. This is analogous to the deÔ¨Ånition of the
contravariant hom functor. A and B are Ô¨Åxed and the varying object is C, so we deÔ¨Åne the functor
HomC (‚àí, A) √ó HomC (‚àí, B) as follows:
(i) [HomC (‚àí, A) √ó HomC (‚àí, B)](C) = HomC (C, A) √ó HomC (C, B), the set of pairs (g, h) of arrows
g : C ‚àí‚ÜíA and h : C ‚àí‚ÜíB.
(ii) For f : D ‚àí‚ÜíC, let HomC (f, A) √ó HomC (f, B) be the arrow
HomC (C, A) √ó HomC (C, B) ‚àí‚ÜíHomC (D, A) √ó HomC (D, B)
that takes a pair (g, h) to (g ‚ó¶f, h ‚ó¶f).
Now we can state the proposition.
6.2.14 Proposition
œÄC : HomC (C, A) √ó HomC (C, B) ‚àí‚ÜíHomC (C, A √ó B)
constitutes a natural isomorphism
œÄ : Hom(‚àí, A) √ó Hom(‚àí, B) ‚àí‚ÜíHom(‚àí, A √ó B)
Proof. We give a proof in detail of this proposition here, but you may want to skip it on Ô¨Årst reading, or
for that matter on Ô¨Åfteenth reading. We will not always give proofs of similar statements later (of which
there are many).
Let PA,B denote the functor Hom(‚àí,A)√óHom(‚àí,B). The projections p1 : A√óB ‚àí‚ÜíA and p2 : A√óB
‚àí‚ÜíB from the product form a pair (p1, p2) ‚ààPA,B(A √ó B).

62
Products and sums
6.2.15 Lemma
The pair (p1, p2) is a universal element for PA,B.
Proof. The pair Ô¨Åts the requirements of Proposition 5.7.16 by deÔ¨Ånition of product: if (q1,q2) ‚ààPA,B(V ),
in other words if q1 : C ‚àí‚ÜíA and q2 : C ‚àí‚ÜíB, there is a unique arrow q : C ‚àí‚ÜíA√óB such that pi ‚ó¶q = qi
for i = 1, 2. By 6.2.13(ii), PA,B(q)(p1, p2) = (q1, q2) as required.
Note that this gives an immediate proof of Theorem 6.2.2. See 9.2.3 for another point of view con-
cerning (p1, p2).
Continuing the proof of Proposition 6.2.14, it follows from Equation (5.27) that the natural iso-
morphism Œ± from HomC (‚àí, A √ó B) to PA,B induced by this universal element takes q : V ‚àí‚ÜíA √ó B to
(p1 ‚ó¶q, p2 ‚ó¶q), which is PA,B(q)(p1, p2). Then by deÔ¨Ånition of œÄ we have that Œ±C = (œÄC)‚àí1, so that œÄ is
the inverse of a natural isomorphism and so is a natural isomorphism.
It is not hard to give a direct proof of Proposition 6.2.14 using Proposition 6.2.8 and the deÔ¨Ånition
of natural transformation. That deÔ¨Ånition requires that the following diagram commute for each arrow
f : C ‚àí‚ÜíD:
Hom(D, A) √ó Hom(D, B)
Hom(D, A √ó B)
-
œÄD
Hom(C, A) √ó Hom(C, B)
Hom(C, A √ó B)
-
œÄD
6
6
(6.12)
In this diagram, the left arrow is deÔ¨Åned as in Section 6.2.13 and the right arrow is deÔ¨Åned as in
Section 4.1.22.
6.2.16
If f : C ‚àí‚ÜíD and q1 : D ‚àí‚ÜíA and q2 : D ‚àí‚ÜíB determine ‚ü®q1, q2‚ü©: D ‚àí‚ÜíA √ó B, then the
commutativity of (6.12) says exactly that
‚ü®q1 ‚ó¶f, q2 ‚ó¶f‚ü©= ‚ü®q1, q2‚ü©‚ó¶f
(6.13)
In this sense, the ‚ü®f, g‚ü©notation is compatible with composition.
Category theorists say that the single arrow ‚ü®q1,q2‚ü©is the internal pair of arrows with Ô¨Årst coordinate
q1 and second coordinate q2. The idea behind the word ‚Äòinternal‚Äô is that the category C is the workspace;
inside that workspace the arrow ‚ü®q1, q2‚ü©is the pair (q1, q2).
When you think of C as a structure and look at it from the outside, you would say that the arrow q
represents the external pair of arrows (q1, q2).
6.2.17 The cartesian product of arrows
The cartesian product construction for functions in sets
can also be given a categorical deÔ¨Ånition. Suppose that f : S ‚àí‚ÜíS‚Ä≤ and g : T ‚àí‚ÜíT ‚Ä≤ are given. Then the
composite arrows f ‚ó¶proj1 : S √óT ‚àí‚ÜíS‚Ä≤ and g ‚ó¶proj2 : S √óT ‚àí‚ÜíT ‚Ä≤ induce, by the deÔ¨Ånition of product,
an arrow denoted f √ó g : S √ó T ‚àí‚ÜíS‚Ä≤ √ó T ‚Ä≤ such that
S‚Ä≤
S‚Ä≤ √ó T ‚Ä≤

proj1
S
S √ó T
 proj1
?
f
T ‚Ä≤
-
proj2
T
-
proj2
?
g
?
f √ó g
(6.14)
commutes. Thus f √ó g = ‚ü®f ‚ó¶proj1, g ‚ó¶proj2‚ü©. It is characterized by the properties
proj1 ‚ó¶(f √ó g) = f ‚ó¶proj1;
proj2 ‚ó¶(f √ó g) = g ‚ó¶proj2
Note that we use proj1 and proj2 for the product projections among diÔ¨Äerent objects. This is standard
and rarely causes confusion since the domains and codomains of the other arrows determine them. We
will later call them p1 and p2, except for emphasis.
When one of the arrows f or g is an identity arrow, say f = idS, it is customary to write S √ó g for
idS √óg.
An invariance theorem similar to Proposition 6.2.11 is true of cartesian products of functions.

6.2 Properties of products
63
6.2.18 Proposition
Suppose the top and bottom lines of each diagram below are product cones, and
that m and n are the unique arrows making the diagrams commute. Let œà : P ‚àí‚ÜíQ and œÜ : C ‚àí‚ÜíD be
the unique isomorphisms given by Theorem 6.2.2. Then œÜ ‚ó¶m = n ‚ó¶œà.
A
C
 p1
S
P
 r1
?
h1
?
m
B
-
p2
T
-
r2
?
?
h2
A
D
 q1
S
Q
 s1
?
h1
?
n
B
-
q2
T
-
s2
?
?
h2
Proof. For i = 1, 2,
qi ‚ó¶œÜ ‚ó¶m ‚ó¶œà‚àí1
=
pi ‚ó¶m ‚ó¶œà‚àí1
=
hi ‚ó¶ri ‚ó¶œà‚àí1
=
hi ‚ó¶si ‚ó¶œà ‚ó¶œà‚àí1
=
hi ‚ó¶si
(6.15)
The Ô¨Årst equality is the property of œÜ given by Theorem 6.2.2, the second by deÔ¨Ånition of product
applied to C, and the third is the deÔ¨Åning property of œà. It follows that œÜ ‚ó¶m ‚ó¶œà‚àí1 is the unique arrow
determined by h1 ‚ó¶s1 : Q ‚àí‚ÜíA and h2 ‚ó¶s2 : Q ‚àí‚ÜíB and the fact that D is a product. But n is that
arrow, so that œÜ ‚ó¶m ‚ó¶œà‚àí1 = n, whence the theorem.
6.2.19 Products and composition
Let C be a category with products, and suppose fi : Ai ‚àí‚ÜíBi
and gi : Bi ‚àí‚ÜíCi for i = 1, 2, so that g1 ‚ó¶f1 and g2 ‚ó¶f2 are deÔ¨Åned. Then
(g1 ‚ó¶f1) √ó (g2 ‚ó¶f2) = (g1 √ó g2) ‚ó¶(f1 √ó f2) : A1 √ó A2 ‚àí‚ÜíC1 √ó C2
(6.16)
This follows from the fact that (g1 ‚ó¶f1) √ó (g2 ‚ó¶f2) is the unique arrow such that
proj1 ‚ó¶((g1 ‚ó¶f1) √ó (g2 ‚ó¶f2)) = (g1 ‚ó¶f1) ‚ó¶proj1
and
proj2 ‚ó¶((g1 ‚ó¶f1) √ó (g2 ‚ó¶f2)) = (g2 ‚ó¶f2) ‚ó¶proj2
Because Diagram (6.14) commutes, we have
proj1 ‚ó¶(g1 √ó g2) ‚ó¶(f1 √ó f2)
=
g1 ‚ó¶proj1 ‚ó¶(f1 √ó f2)
=
g1 ‚ó¶f1 ‚ó¶proj1 : A1 √ó A2 ‚àí‚ÜíC1
and similarly
proj2 ‚ó¶(g1 √ó g2) ‚ó¶(f1 √ó f2) = g2 ‚ó¶f2 ‚ó¶proj2 : A1 √ó A2 ‚àí‚ÜíC2
so the result follows from the uniqueness of (g1 ‚ó¶f1) √ó (g2 ‚ó¶f2).
This fact allows us to see that the product of two objects is the value of a functor. DeÔ¨Åne ‚àí√ó‚àí: C √óC
‚àí‚ÜíC as follows: choose, for each pair A and B of C , a product object A √ó B, and let (‚àí√ó ‚àí)(A, B) =
A √ó B and (‚àí√ó ‚àí)(f, g) = f √ó g. Equation (6.16) shows that this mapping preserves composition and
identities.
Another useful equation is the following, where we assume f : A ‚àí‚ÜíC, g : B ‚àí‚ÜíD, u : X ‚àí‚ÜíA and
v : X ‚àí‚ÜíB.
(f √ó g) ‚ó¶‚ü®u, v‚ü©= ‚ü®f ‚ó¶u, g ‚ó¶v‚ü©
(6.17)
The proof is left as an exercise.
6.2.20 Proposition
Let C and D be any categories. If D has products, then the functor category
Func(C , D) also has products.

64
Products and sums
Proof. The product is constructed by constructing the product at each value F(C) and G(C). Precisely,
given two functors F, G : C ‚àí‚ÜíD, the product in Func(C , D) of F and G is the functor F √ó G deÔ¨Åned
as follows. For an object C of C , (F √ó G)(C) = F(C) √ó G(C), the product of the sets F(C) and G(C)
in D. For an arrow f : C ‚àí‚ÜíD, (F √ó G)(f) = F(f) √ó G(f), the product of the arrows as deÔ¨Åned
in 6.2.17. The projection œÄ1 : F √ó G ‚àí‚ÜíF is the natural transformation whose component at C is
œÄ1C = pi : F(C) √ó G(C) ‚àí‚ÜíF(C), the product projection in D. For any f : C ‚àí‚ÜíD in C , the diagrams
FD √ó GD
FD
-
p1
FC√óGC
FC
-
p1
?
F(f)√óG(f)
?
F(f)
FD√óGD
GD
-
p2
FC√óGC
GC
-
p2
?
F(f)√óG(f)
?
G(f)
(6.18)
commute by deÔ¨Ånition of F(f)√óG(f) (6.2.17), so that œÄ1 and œÄ2 are natural transformations as required.
Given natural transformations Œ± : H ‚àí‚ÜíF and Œ≤ : H ‚àí‚ÜíG, we must deÔ¨Åne ‚ü®Œ±, Œ≤‚ü©: H ‚àí‚ÜíF √ó G. For
an object C, the component ‚ü®Œ±, Œ≤‚ü©C = ‚ü®Œ±C, Œ≤C‚ü©: H(C) ‚àí‚ÜíF(C) √ó Œ≤(C). To see that ‚ü®Œ±, Œ≤‚ü©is a natural
transformation, we must show that for any arrow f : C ‚àí‚ÜíD, this diagram commutes:
H(D)
F(D)√óG(D)
-
‚ü®Œ±, Œ≤‚ü©D
H(C)
F(C)√óG(C)
-
‚ü®Œ±, Œ≤‚ü©C
?
H(f)
?
F(f)√óG(f)
(6.19)
This follows from the following calculation:
(F(f) √ó G(f)) ‚ó¶‚ü®Œ±, Œ≤‚ü©C
=
(F(f) √ó G(f)) ‚ó¶‚ü®Œ±C, Œ≤C‚ü©
=
‚ü®F(f) ‚ó¶Œ±C, G(f) ‚ó¶Œ≤C‚ü©
=
‚ü®Œ±D ‚ó¶H(f), Œ≤D ‚ó¶H(f)‚ü©
=
‚ü®Œ±D, Œ≤D‚ü©‚ó¶H(f)
=
‚ü®Œ±, Œ≤‚ü©D ‚ó¶H(f)
in which the Ô¨Årst and last equalities are by deÔ¨Ånition of ‚ü®Œ±, Œ≤‚ü©, the second is by Equation (6.17), the
third because Œ± and Œ≤ are natural transformations, and the fourth by Equation (6.13).
Categorists say that this construction shows that Func(C ,D) has ‚Äòpointwise products‚Äô. This is the common
terminology, but it might be better to say it has ‚Äòobjectwise products‚Äô.
6.3 Finite products
Products of two objects, as discussed in the preceding sections, are called binary products. We can
deÔ¨Åne products of more than two objects by an obvious modiÔ¨Åcation of the deÔ¨Ånition.
For example, if A, B and C are three objects of a category, a product of them is an object A √ó B √ó C
together with three arrows:
A
B
C
A √ó B √ó C
p1
    	
?
p2
p3
@
@
@@
R
(6.20)
for which, given any other diagram
A
B
C
D
q1
    	
?
q2
q3
@
@
@@
R

6.3 Finite products
65
there exists a unique arrow q = ‚ü®q1, q2, q3‚ü©: D ‚àí‚ÜíA √ó B √ó C such that pi
‚ó¶q = qi, i = 1, 2, 3. A
diagram of the form (6.20) is called a ternary product diagram (or ternary product cone). The
general deÔ¨Ånition of product follows the same pattern.
6.3.1 DeÔ¨Ånition
A product of a list A1,A2,. . .,An of objects (not necessarily distinct) of a category
is an object V together with arrows pi : A ‚àí‚ÜíAi, for i = 1, . . . , n, with the property that given any
object B and arrows fi : B ‚àí‚ÜíAi, i = 1, . . . , n, there is a unique arrow ‚ü®f1, f2, . . . , fn‚ü©: B ‚àí‚ÜíA for
which pi ‚ó¶‚ü®f1, f2, . . . , fn‚ü©= fi, i = 1, . . . , n.
A product of such a list A1, A2, . . . , An is called an n-ary product when it is necessary to specify
the number of factors. Such a product may be denoted A1 √ó A2 √ó ¬∑ ¬∑ ¬∑ √ó An or Qn
i=1 Ai.
The following uniqueness theorem for general Ô¨Ånite products can be proved in the same way as
Theorem 6.2.2.
6.3.2 Theorem
Suppose A1,A2,. . .,An are objects of a category C and that A, with projections pi : A
‚àí‚ÜíAi, and B, with projections qi : B ‚àí‚ÜíAi, are products of these objects. Then there is a unique arrow
œÜ : A ‚àí‚ÜíB for which qi ‚ó¶œÜ = pi for i = 1, . . . , n. Moreover, œÜ is an isomorphism.
Propositions 6.2.3, 6.2.11 and 6.2.18 also generalize in the obvious way to n-ary products.
6.3.3 Binary products give ternary products
An important consequence of the deÔ¨Ånition of
ternary product is that in any category with binary products, and any objects A, B and C, either of
(A √ó B) √ó C and A √ó (B √ó C) can be taken as ternary products A √ó B √ó C with appropriate choice of
projections.
We prove this for (A √ó B) √ó C. Writing pi, i = 1, 2, for the projections which make A √ó B a product
of A and B and qi, i = 1, 2 for the projections which make (A √ó B) √ó C a product of A √ó B and C, we
claim that
C
(A √ó B) √ó C
q2
@
@
@
@
@
@
R
A
B
A √ó B
p1   	
p2
@
@
R
q1   	
is a product diagram with vertex (A √ó B) √ó C and projections p1 ‚ó¶q1 : (A √ó B) √ó C ‚àí‚ÜíA, p2 ‚ó¶q1 :
(A √ó B) √ó C ‚àí‚ÜíB, and q2 : (A √ó B) √ó C ‚àí‚ÜíC.
Suppose that f : D ‚àí‚ÜíA, g : D ‚àí‚ÜíB, and h : D ‚àí‚ÜíC are given. We must construct an arrow u : D
‚àí‚Üí(A √ó B) √ó C with the property that
(a) p1 ‚ó¶q1 ‚ó¶u = f,
(b) p2 ‚ó¶q1 ‚ó¶u = g, and
(c) q2 ‚ó¶u = h.
Recall that ‚ü®f, g‚ü©is the unique arrow making
A
A √ó B
p1
B
-
p2
D
f
    	
?
‚ü®f, g‚ü©
g
@
@
@@
R
(6.21)
commute. This induces a unique arrow u = ‚ü®‚ü®f, g‚ü©, h‚ü©making
A √ó B
(A √ó B) √ó C
q1
C
-
q2
D
‚ü®f, g‚ü©
      	
?
u
h
@
@
@
@
@
@
R
(6.22)

66
Products and sums
commute.
The fact that (a) through (c) hold can be read directly oÔ¨Äthese diagrams. For example, for (a),
p1 ‚ó¶q1 ‚ó¶u = p1 ‚ó¶‚ü®f, g‚ü©= f.
Finally, if u‚Ä≤ were another arrow making (a) through (c) hold, then we would have p1 ‚ó¶q1 ‚ó¶u‚Ä≤ = f
and p2 ‚ó¶q1 ‚ó¶u‚Ä≤ = g, so by uniqueness of v as deÔ¨Åned by (6.21), v = q1 ‚ó¶u‚Ä≤. Since q2 ‚ó¶u‚Ä≤ must be h, the
uniqueness of u in (6.22) means that u‚Ä≤ = u.
A generalization of this is stated in Proposition 6.3.10 below.
6.3.4
It follows from the discussion in 6.3.3 that the two objects (A √ó B) √ó C and A √ó (B √ó C) are
pairwise canonically isomorphic (to each other and to any other realization of the ternary product) in a
way that preserves the ternary product structure.
In elementary mathematics texts the point is often made that ‚Äòcartesian product is not associative‚Äô. When
you saw this you may have thought in your heart of hearts that (A√óB)√óC and A√ó(B √óC) are nevertheless
really the same. Well, now you know that they are really the same in a very strong sense: they satisfy the
same speciÔ¨Åcation and so carry exactly the same information. The only diÔ¨Äerence is in implementation.
6.3.5
If all the factors in an n-ary product are the same object A, the n-ary product A √ó A √ó ¬∑ ¬∑ ¬∑ √ó A is
denoted An. This suggests the possibility of deÔ¨Åning the nullary product A0 and the unary product
A1.
6.3.6
For nullary products, the deÔ¨Ånition is: given no objects of the category C , there should be an
object we will temporarily call T, with no arrows from it, such that for any other object B and no arrows
from B, there is a unique arrow from B to T subject to no commutativity condition.
When the language is sorted out, we see that a nullary product in C is simply an object T with
the property that every other object of the category has exactly one arrow to T. That is, T must be
a terminal object of the category, normally denoted 1. Thus, for any object A of the category, we take
A0 = 1. (Compare 5.1.6.)
6.3.7
A unary product A1 of a single object A should have an arrow p : A1 ‚àí‚ÜíA with the property
that given any object B and arrow q : B ‚àí‚ÜíA there is a unique arrow ‚ü®q‚ü©: B ‚àí‚ÜíA1 for which
B
A1
-
‚ü®q0‚ü©
q
@
@
@@
R
A
?
p
(6.23)
commutes. The identity id : A ‚àí‚ÜíA satisÔ¨Åes this speciÔ¨Åcation for p; given the arrow q : B ‚àí‚ÜíA, we let
‚ü®q‚ü©= q : B ‚àí‚ÜíA. The fact that id ‚ó¶‚ü®q‚ü©= q is evident, as is the uniqueness of ‚ü®q‚ü©. It follows that A1 can
always be taken to be A itself, with the identity arrow as the coordinate arrow.
It is straightforward to show that in general an object B is a unary product of A with coordinate
p : B ‚àí‚ÜíA if and only if p is an isomorphism.
There is therefore a conceptual distinction between A1 and A. In the category of sets, An is often
taken to be the set of strings of elements of A of length exactly n. As you may know, in some computer
languages, a string of characters of length one is not the same as a single character, mirroring the
conceptual distinction made in category theory.
6.3.8 DeÔ¨Ånition
A category has binary products if the product of any two objects exists. It has
canonical binary products if a speciÔ¨Åc product diagram is given for each pair of objects. Thus a
category with canonical binary products is a category with extra structure given for it. Precisely, a
canonical binary products structure on a category C is a function from C0 √ó C0 to the collection of
product diagrams in C which takes a pair (A, B) to a diagram of the form (6.2).
The fact that A and idA can be taken as a product diagram for any object A of any category means
that every category can be given a canonical unary product structure. This is why the distinction between
A and A1 can be and often is ignored.

6.3 Finite products
67
6.3.9 DeÔ¨Ånition
A category has Ô¨Ånite products or is a cartesian category if the product of any
Ô¨Ånite number of objects exists. This includes nullary products ‚Äì in particular, a category with Ô¨Ånite
products has a terminal object. The category has canonical Ô¨Ånite products if every Ô¨Ånite list of
objects has a speciÔ¨Åc given product.
The following proposition is proved using constructions generalizing those of 6.3.3.
6.3.10 Proposition
If a category has a terminal object and binary products, then it has Ô¨Ånite products.
6.3.11 Example
Let N be the set of nonnegative integers with the usual ordering. It is easy to see
that the category determined by (N, ‚â§) has all binary products but no terminal object.
6.3.12
Set, Grf and Cat all have Ô¨Ånite products. In fact, a choice of deÔ¨Ånition for ordered pairs in
Set provides canonical products not only for Set but also for Grf and Cat, since products in those
categories are built using cartesian products of sets.
6.3.13 Record types
To allow operations depending on several variables in a functional programming
language L (as discussed in 2.2.1), it is reasonable to assume that for any types A and B the language has
a record type P and two Ô¨Åeld selectors P.A : P ‚àí‚ÜíA and P.B : P ‚àí‚ÜíB. If we insist that the data in P be
determined completely by those two Ô¨Åelds, it follows that for any pair of operations f : X ‚àí‚ÜíA and g : X
‚àí‚ÜíB there ought to be a unique operation ‚ü®f, g‚ü©: X ‚àí‚ÜíP with the property that P.A ‚ó¶‚ü®f, g‚ü©= f and
P.B ‚ó¶‚ü®f, g‚ü©= g. This would make P the product of A and B with the selectors as product projections.
For example, a record type PERSON with Ô¨Åelds NAME and AGE could be represented as a product cone
whose base diagram is deÔ¨Åned on the discrete graph with two nodes NAME and AGE. If HUMAN is a variable
of type PERSON, then the Ô¨Åeld selector HUMAN.AGE implements the coordinate projection indexed by AGE.
This example is closer to the spirit of category theory than the cone in Diagram (6.2); there, the index
graph has nodes 1 and 2, which suggests an ordering of the nodes (and the projections) which is in fact
spurious.
Thus to say that one can always construct record types in a functional programming language L is
to say that the corresponding category C(L) has Ô¨Ånite products. (See Poign¬¥e, [1986].)
6.3.14 Functors that preserve products
Let F : A ‚àí‚ÜíB be a functor between categories. Suppose
that
A1
A2
A
p1
    	
p2
@
@
@@
R
(6.24)
is a (binary) product diagram in A . We say that F preserves the product if
FA1
FA2
FA
Fp1
    	
Fp2
@
@
@@
R
is a product diagram in B. It is important to note that F must preserve the diagram, not merely the
object A. It is possible for F to take A to an object which is isomorphic to a product, but do the wrong
thing on projections.
F preserves canonical products if A and B have canonical products and F preserves the canonical
product diagrams.
Similar deÔ¨Ånitions can be made about a product diagram of any family of objects. A functor is said
to preserve Ô¨Ånite products, respectively all products if it preserves every Ô¨Ånite product diagram,
respectively all product diagrams. Preserving canonical product diagrams is deÔ¨Åned analogously.
We have a proposition related to Proposition 6.3.10.

68
Products and sums
6.3.15 Proposition
If a functor preserves terminal objects and binary products, it preserves all Ô¨Ånite
products.
Two important examples of this is given by Propositions 6.3.16 and 6.3.17 below.
6.3.16 Proposition
Any covariant hom functor preserves products.
Proof. It is easy to prove that a covariant hom functor preserves terminal objects. Now suppose
A
B
A √ó B
p1   	
p2
@@
R
(6.25)
is a product diagram. We must show that for any object C,
Hom(C, A)
Hom(C, B)
Hom(C, A √ó B)
Hom(C, p1)
   	
Hom(C, p2)
@
@
@
R
(6.26)
is a product diagram in Set. In 6.2.7, we deÔ¨Åned the function
œÄC : Hom(C, A) √ó Hom(C, B) ‚àí‚ÜíHom(C, A √ó B)
which is a bijection that takes (f, g) to ‚ü®f, g‚ü©. Let q1 : Hom(C, A) √ó Hom(C, B) ‚àí‚ÜíHom(C, A) be the
Ô¨Årst coordinate function (f, g) 7‚Üíf in Set, and similarly for q2. Then
Hom(C, p1)‚ü®f, g‚ü©= p1 ‚ó¶‚ü®f, g‚ü©= f = q1(f, g)
and similarly Hom(C, p2)‚ü®f, g‚ü©= q2(f, g), so pi ‚ó¶œÄC = qi for i = 1, 2. Hence Diagram (6.26) is a product
diagram in Set by Proposition 6.2.3.
If F is a functor that preserves products, then any functor isomorphic to it preserves products (the
proof is an instructive diagram chase), so that it follows from Proposition 6.3.16 that any representable
functor preserves products.
6.3.17 Proposition
The second Yoneda embedding
J : C ‚àí‚ÜíFunc(C op, Set)
(see 5.7.8) preserves products.
Proof. By deÔ¨Ånition, J(C) = Hom(‚àí, C) for an object C of C , and if f : C ‚àí‚ÜíD, J(f) = Hom(‚àí, f) :
Hom(‚àí, C) ‚àí‚ÜíHom(‚àí, D). For each X in C ,
Hom(X, A)
Hom(X, B)
Hom(X, A)√ó Hom(X, B)
p1    	
p2
@
@@
R
(where p1 and p2 are the ordinary projections in Set) is a product cone in Set. Let
œÄ1 : Hom(‚àí, A)√ó Hom(‚àí, B) ‚àí‚ÜíHom(‚àí, A)
be the natural transformation whose component at X is p1, and similarly deÔ¨Åne œÄ2. Then by the proof
of Proposition 6.2.20,
Hom(‚àí, A)
Hom(‚àí, B)
Hom(‚àí, A)√ó Hom(‚àí, B)
œÄ1    	
œÄ2
@
@@
R

6.4 Sums
69
is a product cone in Func(C op, Set). It is easy to show that the diagram
Hom(‚àí, A)√ó Hom(‚àí, B)
Hom(‚àí, A√óB)
-
œÄ
Hom(‚àí, A)
œÄ1
@
@
@@
R
Hom(‚àí, p1)
    	
commutes, where œÄ is the natural transformation deÔ¨Åned in Proposition 6.2.14. A similar diagram for
œÄ2 also commutes. It now follows from Proposition 6.2.3 that
Hom(‚àí, A)
Hom(‚àí, B)
Hom(‚àí, A√óB)
Hom(‚àí, p1)    	
Hom(‚àí, p2)
@
@@
R
is a product diagram in Func(C op, Set), which is what is required to show that J preserves binary
products. It is easy to show that it preserves terminal objects.
6.4 Sums
A sum in a category is a product in the dual category. This deÔ¨Ånition spells that out:
6.4.1 DeÔ¨Ånition
The sum, also called the coproduct, A + B of two objects in a category consists
of an object called A + B together with arrows i1 : A ‚àí‚ÜíA + B and i2 : B ‚àí‚ÜíA + B such that given any
arrows f : A ‚àí‚ÜíC and g : B ‚àí‚ÜíC, there is a unique arrow ‚ü®f|g‚ü©: A + B ‚àí‚ÜíC for which
A + B
i1
@
@
@
@
@
R
A
C
-
f
B

g
6
‚ü®f|g‚ü©
i2
     	
commutes.
The arrows i1 and i2 are called the canonical injections or the inclusions even in categories other
than Set. These arrows need not be monomorphisms.
6.4.2
More generally, one can deÔ¨Åne the sum of any Ô¨Ånite or inÔ¨Ånite indexed set of objects in a
category. The sum of a family A1, . . . , An is denoted Pn
i=1 An or `n
i=1 An (the latter symbol is the
one typically used by those who call the sum the ‚Äòcoproduct‚Äô). Theorems such as Theorem 6.2.2 and
Propositions 6.2.3, 6.2.11 and 6.3.2 are stateable in the opposite category and give uniqueness theorems
for sums (this depends on the fact that isomorphisms are isomorphisms in the opposite category). The
functor represented by the sum of A and B is Hom(A, ‚àí) √ó Hom(B, ‚àí) and the universal element is the
pair of canonical injections. (Compare Proposition 6.2.14 and the discussion which follows.)
6.4.3 DeÔ¨Ånition
A binary discrete cocone in a category C is a diagram of the form
A
B
C
@
@
R
  	
It is a sum cocone if the two arrows shown make C a sum of A and B.

70
Products and sums
6.4.4
The notions of a category having sums or of having canonical sums, and that of a functor
preserving sums, are deÔ¨Åned in the same way as for products. The notion corresponding to f √ó g for two
arrows f and g is denoted f + g.
6.4.5 Sums in Set
In the category of sets, one can Ô¨Ånd a sum of two sets in the following way. If S
and T are sets, Ô¨Årst consider the case that S and T are disjoint. In that case the set S ‚à™T, together
with the inclusion functions S ‚àí‚ÜíS ‚à™T ‚Üê‚àíT is a sum cocone. Given f : S ‚àí‚ÜíC and g : T ‚àí‚ÜíC, then
‚ü®f|g‚ü©(s) = f(s) for s ‚ààS and ‚ü®f|g‚ü©(t) = g(t) for t ‚ààT. In this case, the graph of ‚ü®f|g‚ü©is the union of
the graphs of f and g.
In the general case, all we have to do is Ô¨Ånd sets S‚Ä≤ and T ‚Ä≤ isomorphic to S and T, respectively, that
are disjoint. The union of those two sets is a sum of S‚Ä≤ and T ‚Ä≤ which are the same, as far as mapping
properties, as S and T. The usual way this is done is as follows: let
S‚Ä≤ = S0 = {(s, 0) | s ‚ààS}
and
T ‚Ä≤ = T1 = {(t, 1) | t ‚ààT}
These sets are disjoint since the Ô¨Årst is a set of ordered pairs each of whose second entries is a 0, while the
second is a set of ordered pairs each of whose second entries is a 1. The arrow i1 : S ‚àí‚ÜíS‚Ä≤ ‚à™T ‚Ä≤ takes s to
(s, 0), and i2 takes t to (t, 1). If f : S ‚àí‚ÜíC and g : T ‚àí‚ÜíC, then ‚ü®f|g‚ü©(s, 0) = f(s) and ‚ü®f|g‚ü©(t, 1) = g(t).
Note that it will not do to write S0 = S √ó {0} and T1 = T √ó {1} since our speciÔ¨Åcation of products does not
force us to use ordered pairs and, in fact, S is itself a possible product of S with either {0} or {1}.
Our notation S + T for the disjoint union of two sets in Set conÔ¨Çicts with a common usage in which
S and T are sets of numbers and S + T denotes the set of all their sums. For this reason, many use the
notation S ‚®øT for what we call S + T. We will use the notation S + T here but will remind you by
referring to it as the disjoint union.
6.4.6 Sums and products in posets
The least upper bound or supremum of two elements x
and y in a poset is an element z with the property that x ‚â§z, y ‚â§z (z is thus an upper bound) and if
for some element w, x ‚â§w and y ‚â§w, then necessarily z ‚â§w (z is the ‚Äì necessarily unique ‚Äì least upper
bound). In the category corresponding to the poset, the supremum of two elements is their categorical
sum. We have already seen the dual idea of greatest lower bound or inÔ¨Åmum in 6.1.9.
A poset whose corresponding category has all Ô¨Ånite sums is called a sup semilattice or an upper
semilattice. The sup of s and t is generally denoted s ‚à®t and the minimum element (initial object)
is denoted 0. In this situation, the minimum element is often called ‚Äòbottom‚Äô. A poset with all Ô¨Ånite
products is similarly an inf semilattice or lower semilattice. A homomorphism of sup semilattices
is a function such that f(s ‚à®t) = f(s) ‚à®f(t). Such a function is monotone because if s ‚â§t then t = s ‚à®t.
A poset with both Ô¨Ånite sups and Ô¨Ånite infs is a lattice. Some authors assume only binary sups and
infs so that a lattice need not have a maximum or minimum element. A good source for the theory of
lattices is [Davey and Priestley, 1990].
6.4.7 Sums and products in Rel and Pfn
Let S and T be two sets. Their sum in Rel, the category
of sets and relations (2.1.14) and in Pfn, the category of sets and partial functions (2.1.13) is the same
as in Set: the disjoint union S + T. For Pfn, the canonical injections are the same as for Set, and for
Rel they are the graphs of the canonical injections for Set.
We will verify this for Rel (primarily to show the subtleties involved) and leave the claim for Pfn as
an exercise. Set i1 = {(s, (s, 0)) | s ‚ààS} and i2 = {(t, (t, 1)) | t ‚ààT}. For relations Œ± : S ‚àí‚ÜíX and Œ≤ : T
‚àí‚ÜíX, deÔ¨Åne
‚ü®Œ±|Œ≤‚ü©= {((s, 0), x) | for all (s, x) ‚ààŒ±} ‚à™{((t, 1), x) | for all (t, x) ‚ààŒ≤}
Then
‚ü®Œ±|Œ≤‚ü©‚ó¶i1
=
{(r, x) | ‚àÉz such that (r, z) ‚àài1 and (z, x) ‚àà‚ü®Œ±|Œ≤‚ü©}
=
{(r, x) | r ‚ààS and (r, (r, 0)) ‚àài1 and ((r, 0), x) ‚àà‚ü®Œ±|Œ≤‚ü©}
=
{(r, x) | r ‚ààS and ((r, 0), x) ‚àà‚ü®Œ±|Œ≤‚ü©}
=
{(r, x) | r ‚ààS and (r, x) ‚ààŒ±}
=
Œ±

6.5 Deduction systems as categories
71
and similarly for i2 and Œ≤.
Now suppose we omitted a particular element ((s0, 0), x0) from ‚ü®Œ±|Œ≤‚ü©. Since i1 has the functional
property, the only z for which (s0, z) ‚àài1 is (s0, 0), but then ((s0, 0), x0) /‚àà‚ü®Œ±|Œ≤‚ü©. On the other hand, if
we insert an extra element (r, x) into ‚ü®Œ±|Œ≤‚ü©, suppose without loss of generality that r = (s0, 0) for s ‚ààS
and (s, x) /‚ààŒ±. Then (s, (s0, 0)) ‚àài1 and ((s0, 0), x) ‚àà‚ü®Œ±|Œ≤‚ü©but (s, x) /‚ààŒ±. So ‚ü®Œ±, Œ≤‚ü©is the only relation
from the disjoint union S + T to X such that ‚ü®Œ±, Œ≤‚ü©‚ó¶i1 = Œ± and ‚ü®Œ±, Œ≤‚ü©‚ó¶i2 = Œ≤.
The product of two sets S and T in Rel is also the disjoint union S + T. It must be that because
that is the sum and Rel is isomorphic to Rel op. It follows that p1 = {((s, 0), s) | s ‚ààS} (the opposite
of the graph of i1) and similarly for p2.
The product of S and T in Pfn is quite diÔ¨Äerent: it is the disjoint union S √óT +S +T. The projection
p1 is deÔ¨Åned by
p1(r) =
( s
if r = (s, t) ‚ààS √ó T
r
if r ‚ààS
undeÔ¨Åned
otherwise
6.4.8 Finite sums in programming languages
In 6.3.13, we have described products in the cate-
gory corresponding to a programming language as records. Sums play a somewhat subtler role.
If A and B are types, the sum A+B can be thought of as the free variant or free union of the types A
and B. If we are to take this seriously, we have to consider the canonical structure maps i1 : A ‚àí‚ÜíA + B
and i2 : B ‚àí‚ÜíA + B. These are type conversions; i1 converts something of type A to something of the
union type. Such type conversions are not explicit in languages such as Pascal or C, because in those
languages, the free union is implemented in such a way that the type conversion i1 : A ‚àí‚ÜíA + B can
always be described as ‚Äòuse the same internal representation that it has when it is type A‚Äô. Thus in those
languages, the eÔ¨Äect of an operation with domain ‚ÄòA + B‚Äô is implementation-dependent.
Thus sums and products provide some elementary constructions for functional programming languages.
Still missing are some constructions such as IF. . . THEN. . . ELSE and WHILE loops or recursion which give the
language the full power of a Turing machine. IF. . . THEN. . . ELSE is discussed in Sections 5.7 and 9.6 of [Barr
and Wells, 1999]. Some approaches to recursion are discussed in Chapters 6.6 and 14.2 of [Barr and Wells,
1999]. Wagner [1986a, 1986b] discusses these constructions and others in the context of more traditional
imperative programming languages.
6.5 Deduction systems as categories
In this section, we describe brieÔ¨Çy the connection between formal logical systems and categories.
6.5.1
A deduction system has formulas and proofs. The informal idea is that the formulas are
statements, such as x ‚â§7, and the proofs are valid lines of reasoning starting with one formula and
ending with another; for example, it is valid in high school algebra (which is a deductive system) to
prove that if x ‚â§7 then 2x ‚â§14. We will write a proof p which assumes A and deduces B as p : A ‚àí‚ÜíB.
Typically, formal deduction systems deÔ¨Åne the formulas by some sort of context free grammar, a
typical rule of which might be: ‚ÄòIf A and B are formulas, then so is A ‚àßB‚Äô. The valid proofs are
composed of chains of applications of certain speciÔ¨Åed rules of inference, an example of which might
be: ‚ÄòFrom A ‚àßB it is valid to infer A‚Äô.
6.5.2 Assumptions on a deduction system
As in the case of functional programming languages
(see 2.2.4), certain simple assumptions on a deduction system, however it is deÔ¨Åned, produce a category.
DS‚Äì1 For any formula A there is a proof idA : A ‚àí‚ÜíA.
DS‚Äì2 Proofs can be composed: if you have proofs p : A ‚àí‚ÜíB and q : B ‚àí‚ÜíC then there is a valid proof
p; q : A ‚àí‚ÜíC.
DS‚Äì3 If p : A ‚àí‚ÜíB is a proof then p; idB and idA; p are both the same proof as p.

72
Products and sums
DS‚Äì4 If p, q and r are proofs, then (p; q); r must be the same proof as p; (q; r), which could be denoted
p; q; r.
These requirements clearly make a deduction system a category.
One could take a deduction system and impose the minimum requirements just given to produce a
category. One could on the other hand go all the way and make any two proofs A to B the same. In that
case, each arrow in the category stands for the usual notion of deducible. The choice of an intermediate
system of identiÔ¨Åcation could conceivably involve delicate considerations.
6.5.3 DeÔ¨Ånition
A conjunction calculus is a deduction system with a formula true and a formula
A ‚àßB for any formulas A and B, which satisÔ¨Åes CC‚Äì1 through CC‚Äì5 below for all A and B.
CC‚Äì1 There is a proof A ‚àí‚Üítrue.
CC‚Äì2 If u : A ‚àí‚Üítrue and v : A ‚àí‚Üítrue are proofs, then u = v.
CC‚Äì3 There are proofs p1 : A ‚àßB ‚àí‚ÜíA and p2 : A ‚àßB ‚àí‚ÜíB with the property that given any proofs
q1 : X ‚àí‚ÜíA and q2 : X ‚àí‚ÜíB there is a proof ‚ü®q1, q2‚ü©: X ‚àí‚ÜíA ‚àßB.
CC‚Äì4 For any proofs q1 : X ‚àí‚ÜíA and q2 : X ‚àí‚ÜíB, p1 ‚ó¶‚ü®q1, q2‚ü©= q1 and p2 ‚ó¶‚ü®q1, q2‚ü©= q2.
CC‚Äì5 For any proof h : Y ‚àí‚ÜíA ‚àßB, ‚ü®p1 ‚ó¶h, p2 ‚ó¶h‚ü©= h.
Similar constructions may be made using sums to get a disjunction calculus. Cartesian closed cat-
egories (the subject of Chapter 7) give an implication operator and quantiÔ¨Åers are supplied in a topos
(Chapter 11). These topics are pursued in detail in [Lambek and Scott, 1986], [Makkai and Reyes, 1977]
and [Bell, 1988].
Deductive systems typically involve a distributive law between ‚Äúand‚Äù and ‚Äúor‚Äù. A distributive cat-
egory is a category with products and sums that distribute over each other. Expositions of distributive
categories with applications to computing science may be found in in [Walters, 1991], [Cockett, 1993],
and [Barr and Wells, 1999], Section 5.7. See also [Walters, 1992].

7. Cartesian closed categories
A cartesian closed category is a type of category that as a formal system has the same expressive power
as a typed Œª-calculus. In Sections 7.1 and 7.2, we deÔ¨Åne cartesian closed categories and give some of
their properties. In Section 7.3, we describe the concept of typed Œª-calculus. Section 7.4 describes the
constructions involved in translating from one formalism to the other, without proof. Sections 7.1 and 7.2
are needed for Chapter 11. Monoidal closed categories, discussed in Chapter 12, are a generalization of
cartesian closed categories, but the discussion in Chapter 12 is independent of this chapter. Other than
for the chapters just mentioned, this chapter is not needed in the rest of these notes.
Most of the cartesian closed categories considered in computer science satisfy a stronger property,
that of being ‚Äòlocally cartesian closed‚Äô, meaning that every slice is cartesian closed. This is discussed in
Section 13.4 of [Barr and Wells, 1999].
A basic reference for cartesian closed categories and their connection with logic is [Lambek and
Scott, 1986]. See also [Huet, 1986] and [Mitchell and Scott, 1989]. The text by Gunter [1992] gives a
systematic treatment of programming language semantics in terms of the ideas of this chapter. Substantial
applications to computing may be found in [Cousineau, Curien and Mauny, 1985], [Curien, 1986], [Hagino,
1987b] and [Dybkjaer and Melton, 1993]. The construction of Ô¨Åxed points in cartesian closed categories
is discussed in [Barr and Wells, 1999], Section 6.6, and in [Barr, 1990], [Huwig and Poign¬¥e, 1990] and
[Backhouse et al., 1995].
In this chapter and later, we frequently use the name of an object to stand for the identity arrow on the
object: thus ‚ÄòA‚Äô means ‚ÄòidA‚Äô. This is common in the categorical literature because it saves typographical
clutter.
7.1 Cartesian closed categories
7.1.1 Functions of two variables
If S and T are sets, then an element of S √ó T can be viewed
interchangeably as a pair of elements, one from S and one from T, or as a single element of the product.
If V is another set, then a function f : S √óT ‚àí‚ÜíV can interchangeably be viewed as a function of a single
variable ranging over S √ó T or as a function of two variables, one from S and one from T. Conceptually,
we must distinguish between these two points of view, but they are equivalent.
In a more general category, the notion of function of two variables should be understood as meaning
an arrow whose domain is a product (see 6.2.6). Under certain conditions, such a function can be
converted to a function of one variable with values in a ‚Äòfunction object‚Äô. We now turn to the study of
this phenomenon.
7.1.2
To curry a function of two variables is to change it into a function of one variable whose values
are functions of one variable. Precisely, let S, T and V be sets and f : S √ó T ‚àí‚ÜíV a function. Let [S
‚àí‚ÜíT] denote the set of functions from S to T. Then there is a function Œªf : S ‚àí‚Üí[T ‚àí‚ÜíV ] deÔ¨Åned by
letting Œªf(s) be the function whose value at an element t ‚ààT is f(s, t). The passage from f to Œªf is
called currying f. As an example, the deÔ¨Ånition on arrows of the functor FŒ± obtained from a monoid
action as in 4.2.4 is obtained by currying Œ±.
In the other direction, if g : S ‚àí‚Üí[T ‚àí‚ÜíV ] is a function, it induces a function f : S √ó T ‚àí‚ÜíV deÔ¨Åned
by f(s, t) = [g(s)](t). This construction produces an inverse to Œª that determines an isomorphism
HomSet(S √ó T, V ) ‚àº= HomSet(S, [T ‚àí‚ÜíV ])
These constructions can readily be stated in categorical language. The result is a theory that is equivalent
to the typed Œª-calculus (in the sense of Section 7.3) and has several advantages over it.
7.1.3 DeÔ¨Ånition
A category C is called a cartesian closed category if it satisÔ¨Åes the following:
CCC‚Äì1 There is a terminal object 1.
CCC‚Äì2 Each pair of objects A and B of C has a product A √ó B with projections p1 : A √ó B ‚àí‚ÜíA and
p2 : A √ó B ‚àí‚ÜíB.
73

74
Cartesian closed categories
CCC‚Äì3 For every pair of objects A and B, there is an object [A ‚àí‚ÜíB] and an arrow eval : [A ‚àí‚ÜíB] √ó A
‚àí‚ÜíB with the property that for any arrow f : C √óA ‚àí‚ÜíB, there is a unique arrow Œªf : C ‚àí‚Üí[A
‚àí‚ÜíB] such that the composite
C √ó A
Œªf √ó A
‚àí‚àí‚àí‚àí‚àí‚àí‚Üí[A ‚àí‚ÜíB] √ó A
eval
‚àí‚àí‚àí‚àí‚ÜíB
is f.
7.1.4 Terminology
Traditionally, [A ‚àí‚ÜíB] has been denoted BA and called the exponential object,
and A is then called the exponent. The exponential notation is motivated by the following special case:
if C is the category of sets and n = {0, 1, . . . , n ‚àí1}, the standard set with n elements, then Bn is indeed
the set of n-tuples of elements of B.
In CCC‚Äì3, there is a diÔ¨Äerent arrow eval for each pair of objects A and B. When necessary, we will
write the arrow eval : [A ‚àí‚ÜíB] √ó A ‚àí‚ÜíB as evalA
B. This collection of arrows for a Ô¨Åxed A forms the
counit of an adjunction, as deÔ¨Åned in 9.2.5. Because of that, Œªf is often called the adjoint transpose
of f.
7.1.5
In view of Proposition 6.3.10, CCC‚Äì1 and CCC‚Äì2 could be replaced by the requirement that C
have Ô¨Ånite products. There is a slight notational problem in connection with this. We have used p1 and
p2 for the two projections of a binary product. We will now use
pj :
Y
Ai ‚àí‚ÜíAj
for j = 1, . . . , n to denote the jth projection from the n-ary product. This usage should not conÔ¨Çict with
the previous usage since it will always be clear what the domain is.
A related problem is this. Condition CCC‚Äì3 appears to treat the two factors of C √óA asymmetrically,
which is misleading since of course C √ó A ‚àº= A √ó C. Products are of indexed sets of objects (see 6.1.3)
not necessarily indexed by an ordered set, even though our notation appears to suggest otherwise. It
gets even worse with n-ary products, so we spell out the notation we use more precisely.
7.1.6 Proposition
In any cartesian closed category, for any objects A1,. . .,An and A and any i =
1,. . .,n, there is an object [Ai ‚àí‚ÜíA] and an arrow
eval : [Ai ‚àí‚ÜíA] √ó Ai ‚àí‚ÜíA
such that for any f : Q Aj ‚àí‚ÜíA, there is a unique arrow
Œªif :
Y
jÃ∏=i
Aj ‚àí‚Üí[Ai ‚àí‚ÜíA]
such that the following commutes:
[Ai ‚àí‚ÜíA] √ó Ai
A
-
eval
f
@
@
@
@
@
@
@
R
Q Aj
?
‚ü®Œªif ‚ó¶‚ü®p1, . . . , pi‚àí1, pi+1, . . . , pn‚ü©, pi‚ü©
In Set, Œªif gives a function from Ai to A for each (n ‚àí1)-tuple
(a1, a2, . . . , ai‚àí1, ai+1, . . . , an)

7.1 Cartesian closed categories
75
7.1.7 Evaluation as universal element
For Ô¨Åxed objects A and B of a cartesian closed category, let
FA,B denote the functor Hom(‚àí√ó A, B), so that if g : D ‚àí‚ÜíC, FA,B(g) : Hom(C √ó A, B) ‚àí‚ÜíHom(D √ó
A, B) takes f : C √ó A ‚àí‚ÜíB to f
‚ó¶(g √ó A). CCC‚Äì3 says that eval : [A ‚àí‚ÜíB] √ó A ‚àí‚ÜíB is a universal
element for FA,B. This is true for every object A and B and by Proposition 5.7.16 implies that the maps
f 7‚ÜíŒªf form a natural isomorphism of functors:
Hom(‚àí√ó A, B) ‚àº= Hom(‚àí, [A ‚àí‚ÜíB])
(7.1)
It follows that a category with Ô¨Ånite products can be a cartesian closed category in essentially only
one way. The following proposition makes this precise. It is a special case of the fact that adjoints are
essentially unique (see 9.3.4).
7.1.8 Proposition
Let C be a category with Ô¨Ånite products. Suppose that for every pair of objects A
and B, there are objects [A ‚àí‚ÜíB] and [A ‚àí‚ÜíB]‚Ä≤ and arrows eval : [A ‚àí‚ÜíB] √ó A ‚àí‚ÜíB and eval‚Ä≤ : [A
‚àí‚ÜíB]‚Ä≤ √ó A ‚àí‚ÜíB. Suppose these have the property that for any arrow f : C √ó A ‚àí‚ÜíB, there are unique
arrows Œªf : C ‚àí‚Üí[A ‚àí‚ÜíB], Œª‚Ä≤f : C ‚àí‚Üí[A ‚àí‚ÜíB]‚Ä≤ for which eval ‚ó¶(Œªf √ó A) = eval‚Ä≤ ‚ó¶(Œª‚Ä≤f √ó A) = f.
Then for all objects A and B, there is a unique arrow œÜ(A, B) : [A ‚àí‚ÜíB]‚Ä≤ ‚àí‚Üí[A ‚àí‚ÜíB] such that for
every arrow f : C √ó A ‚àí‚ÜíB the following diagrams commute:
eval
    
B
eval‚Ä≤
@
@
@@
R
[A ‚àí‚ÜíB]‚Ä≤ √ó A
[A ‚àí‚ÜíB] √ó A
?
œÜ(A, B) √ó A
Œªf
@
@
@@
R
[A ‚àí‚ÜíB]‚Ä≤
C
Œª‚Ä≤f
    
[A ‚àí‚ÜíB]
?
œÜ(A, B)
Moreover, œÜ is an isomorphism.
7.1.9 Example
The Ô¨Årst example of a cartesian closed category is the category of sets. For any sets A
and B, [A ‚àí‚ÜíB] is the set of functions from A to B, and evalA
B is the evaluation or apply function. The
meaning of Œªf is discussed above in 7.1.2. Note that in the case of Set, [A ‚àí‚ÜíB] is HomSet(A, B).
7.1.10 Example
A Boolean algebra B is a poset, so corresponds to a category C(B). This category
is a cartesian closed category. The terminal object of a Boolean algebra B is 1, so C(B) satisÔ¨Åes CCC‚Äì1.
Since B has the inÔ¨Åmum of any two elements, C(B) has binary products (see 6.1.9) and so satisÔ¨Åes
CCC‚Äì2.
To prove CCC‚Äì3, deÔ¨Åne [a ‚àí‚Üíb] to be ¬¨a ‚à®b. To show that evala
b exists requires showing that [a
‚àí‚Üíb] ‚àßa ‚â§b. This can be seen from the following calculation, which uses the distributive law:
[a ‚àí‚Üíb] ‚àßa
=
(¬¨a ‚à®b) ‚àßa
=
(¬¨a ‚àßa) ‚à®(b ‚àßa)
=
0 ‚à®(b ‚àßa) = b ‚àßa ‚â§b
The existence of the Œª function requires showing that if c ‚àßa ‚â§b then c ‚â§[a ‚àí‚Üíb] (the uniqueness of
Œªf and the fact that eval ‚ó¶Œªf √ó A = f are automatic since no hom set in the category determined by a
poset has more than one element). This follows from this calculation, assuming c ‚àßa ‚â§b:
c
=
c ‚àß1 = c ‚àß(a ‚à®¬¨a)
=
(c ‚àßa) ‚à®(c ‚àß¬¨a)
‚â§
b ‚à®(c ‚àß¬¨a) ‚â§b ‚à®¬¨a = [a ‚àí‚Üíb]

76
Cartesian closed categories
7.1.11 Example
A poset with all Ô¨Ånite (including empty) infs and sups that is cartesian closed as a
category is called a Heyting algebra. A Heyting algebra is thus a generalization of a Boolean algebra.
Heyting algebras correspond to intuitionistic logic in the way that Boolean algebras correspond to classi-
cal logic. A Heyting algebra is complete if it has sups of all subsets. We use this concept in Chapter 11.
A thorough exposition of the elementary properties of Heyting algebras may be found in [Mac Lane and
Moerdijk, 1992], section I.8.
7.1.12 Example
The category whose objects are graphs and arrows are homomorphisms of graphs is
also cartesian closed. If G and H are graphs, then the exponential [G ‚àí‚ÜíH ] (which must be a graph)
can be described as follows. Let No denote the graph consisting of a single node and no arrows and Ar
the graph with one arrow and two distinct nodes, the nodes being the source and the target of the arrow.
There are two embeddings of No into Ar, which we will call s, t : No ‚àí‚ÜíAr, that take the single node
to the source and target of the arrow of Ar, respectively. Then [G ‚àí‚ÜíH ] is the graph whose set of nodes
is the set Hom(G √ó No, H ) of graph homomorphisms from G √ó No to H and whose set of arrows is the
set Hom(G √óAr,H ) with the source and target functions given by Hom(G √ós,H ) and Hom(G √ót, H ),
respectively.
Note that in the case of graphs, the object [G ‚àí‚ÜíH ] is not the set Hom(G , H ) with the structure of
a graph imposed on it in some way. Since [G ‚àí‚ÜíH ] is an object of the category, it must be a graph; but
neither its set of objects nor its set of arrows is Hom(G , H ). In particular, to prove that a category of
sets with structure is not cartesian closed, it is not enough to prove that an attempt to put a structure
on the hom set must fail.
7.1.13 Example
If C is a small category then Func(C , Set) is a category; the objects are functors
and the arrows are natural transformations. (See 5.3.1.) The category Func(C , Set) is cartesian closed.
If F, G : C ‚àí‚ÜíSet are two functors, the product F √ó G was deÔ¨Åned in 6.2.20. The exponential object [F
‚àí‚ÜíG] is the following functor. For an object C, [F ‚àí‚ÜíG](C) is the set of natural transformations from
the functor Hom(C, ‚àí) √ó F to G. For f : C ‚àí‚ÜíD an arrow of C and Œ± : Hom(C, ‚àí) √ó F ‚àí‚ÜíG a natural
transformation, [F ‚àí‚ÜíG](f)(Œ±) has component at an object A that takes a pair (v, x) with v : D ‚àí‚ÜíA
and x ‚ààF(A) to the element Œ±A(v ‚ó¶f, x) of G(A). See [Mac Lane and Moerdijk, 1992], page 46 for a
proof of a more general theorem of which this is a special case.
Example 7.1.12 is a special case of this example. This also implies, for example, that the category of
u-structures described in 5.2.5 is cartesian closed, as is the arrow category of Set (see 5.2.17).
7.1.14 Example
The category Cat of small categories and functors is cartesian closed. In this case,
we have already given the construction in 5.3.1: for two categories C and D, [C ‚àí‚ÜíD] is the category
whose objects are functors from C to D and whose arrows are natural transformations between them.
If F : B √ó C ‚àí‚ÜíD is a functor, then ŒªF : B ‚àí‚Üí[C ‚àí‚ÜíD] is the functor deÔ¨Åned this way: if B is an
object of B, then for an object C of C , ŒªF(B)(C) = F(B, C), and for an arrow g : C ‚àí‚ÜíC‚Ä≤, ŒªF(B)(g)
is the arrow F(B, g) : (B, C) ‚àí‚Üí(B, C‚Ä≤) of D. For an arrow f : B ‚àí‚ÜíB‚Ä≤ of B, ŒªF(f) is the natural
transformation from ŒªF(B) to ŒªF(B‚Ä≤) with component ŒªF(f)(C) = F(f, C) at an object C of C . It is
instructive to check that this does give a natural transformation.
7.1.15 Example
(For those familiar with complete partial orders.) The category consisting of œâ-CPOs
and continuous functions is a cartesian closed category, although the subcategory of strict œâ-CPOs and
strict continuous maps is not. The category of continuous lattices and continuous functions between them
is cartesian closed; a readable proof is in [Scott, 1972], Section 3. Many other categories of domains have
been proposed for programming language semantics and many, but not all, are cartesian closed. More
about this is in [Scott, 1982], [Smyth, 1983], [Dybjer, 1986] and [Gunter, 1992].
7.1.16 Example
In 2.2.2 we described how to regard a functional programming language as a category.
If such a language is a cartesian closed category, then for any types A and B, there is a type [A ‚àí‚ÜíB]
of functions from A to B. Since that is a type, one can apply programs to data of that type: that is,
functions can be operated on by programs. This means that functions are on the same level as other
data, often described by saying ‚Äòfunctions are Ô¨Årst class objects‚Äô.
Proposition 7.1.8 puts strong constraints on making functions into Ô¨Årst class objects; if you make
certain reasonable requirements on your types [A ‚àí‚ÜíB], there is essentially only one way to do it.

7.2 Properties of cartesian closed categories
77
7.1.17 Example
When a deduction system (Section 6.5) is a cartesian closed category, the construc-
tions giving the exponential turn out to be familiar rules of logic.
Thus, if A and B are formulas, [A ‚àí‚ÜíB] is a formula; think of it as A implies B. Then eval is a proof
allowing the deduction of B from A and [A ‚àí‚ÜíB]; in other words, it is modus ponens. Given f : C √ó A
‚àí‚ÜíB, that is, given a proof that C and A together prove B, Œªf is a proof that deduces [A ‚àí‚ÜíB] from C.
This is the rule of detachment.
7.2 Properties of cartesian closed categories
Many nice properties follow from the assumption that a category is cartesian closed. Some of them
are easy consequences of theorems concerning adjunctions (Chapter 9). Others can be proved using the
Yoneda embedding. We now state some of these basic properties, with some of the proofs outlined.
Given f : B ‚àí‚ÜíC in a cartesian closed category, we have the composite
[A ‚àí‚ÜíB] √ó A
evalA
B
‚àí‚àí‚àí‚àí‚àí‚ÜíC
f
‚àí‚àí‚ÜíC
Given g : B ‚àí‚ÜíA we have
[A ‚àí‚ÜíC] √ó B
[A ‚àí‚ÜíC] √ó g
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí[A ‚àí‚ÜíC] √ó A
evalA
C
‚àí‚àí‚àí‚àí‚àí‚ÜíC
These are used in the following proposition.
7.2.1 Proposition
Let A be an object of a cartesian closed category C . There are functors F : C
‚àí‚ÜíC and G : C op ‚àí‚ÜíC for which
(i) F(B) = [A ‚àí‚ÜíB] for an object B, and for an arrow f : B ‚àí‚ÜíC,
F(f) = Œª(f ‚ó¶evalA
B) : [A ‚àí‚ÜíB] ‚àí‚Üí[A ‚àí‚ÜíC]
(ii) G(C) = [A ‚àí‚ÜíC] for an object C, and for an arrow g : B ‚àí‚ÜíA,
G(g) = Œª(evalA
C ‚ó¶[A ‚àí‚ÜíC] √ó g) : [A ‚àí‚ÜíC] ‚àí‚Üí[B ‚àí‚ÜíC]
The value of F at f : B ‚àí‚ÜíC is normally written
[A ‚àí‚Üíf] : [A ‚àí‚ÜíB] ‚àí‚Üí[A ‚àí‚ÜíC]
and the value of G at g : B ‚àí‚ÜíA is normally written
[g ‚àí‚ÜíC] : [A ‚àí‚ÜíC] ‚àí‚Üí[B ‚àí‚ÜíC]
These functors are called the internal hom functors of the cartesian closed category.
Proof. Preservation of the identity is straightforward. We will prove that F preserves composition. The
proof for G is similar. We must show that, for f : B ‚àí‚ÜíC and g : C ‚àí‚ÜíD, [A ‚àí‚Üíf] ‚ó¶[A ‚àí‚Üíg] = [A
‚àí‚Üíg ‚ó¶f]. By DeÔ¨Ånition 7.1.3, for any h : X ‚àí‚ÜíY , [A ‚àí‚Üíh] is the unique arrow such that
X
Y
-
h
[A ‚àí‚ÜíX] √ó A
[A ‚àí‚ÜíY ] √ó A
-
Œª(h ‚ó¶eval) √ó A
?
eval
?
eval

78
Cartesian closed categories
commutes. But then both squares in the following diagram commute, so the outer rectangle commutes,
so that [A ‚àí‚Üíg] ‚ó¶[A ‚àí‚Üíf] = [A ‚àí‚Üíg ‚ó¶f].
B
C
-
f
[A ‚àí‚ÜíB]√óA
[A ‚àí‚ÜíC]√óA
-
Œª(f ‚ó¶eval)√óA
?
eval
?
eval
D
-
g
[A ‚àí‚ÜíD]√óA
-
Œª(g ‚ó¶eval)√óA
?
eval
(7.2)
Now that we have Proposition 7.2.1, we can regard both Hom(C √ó A, B) and Hom(C, [A ‚àí‚ÜíB]) as
functors of any one of the three variables. Thus for Ô¨Åxed A and B, there are contravariant functors
Hom(‚àí√ó A, B) and Hom(‚àí, [A ‚àí‚ÜíB]) (we don‚Äôt need Proposition 7.2.1 to deÔ¨Åne these), and we have
already seen in 7.1.7 that these functors are naturally isomorphic. Because C √ó A ‚àº= A √ó C, A can be
treated in the same way as C. For Ô¨Åxed A and C there are covariant functors Hom(C √ó A, ‚àí) and
Hom(C, [A ‚àí‚Üí‚àí]), all deÔ¨Åned as composites of functors. The following proposition now follows from
Theorem 9.3.5. It is also not diÔ¨Écult to prove directly.
7.2.2 Proposition
The function f 7‚ÜíŒªf deÔ¨Ånes a natural isomorphism
Hom(C √ó A, ‚àí) ‚àí‚ÜíHom(C, [A ‚àí‚Üí‚àí])
The proposition below collects the ways in which [A ‚àí‚Üí‚àí] behaves like a hom functor.
7.2.3 Proposition
The following isomorphisms hold for any objects A, B and C in a cartesian closed
category. The last two isomorphisms hold whenever the requisite initial object or sum exists.
(i) [A ‚àí‚Üí1] ‚àº= 1.
(ii) [1 ‚àí‚ÜíA] ‚àº= A.
(iii) [A √ó B ‚àí‚ÜíC] ‚àº= [A ‚àí‚Üí[B ‚àí‚ÜíC]].
(iv) [A ‚àí‚ÜíB] √ó [A ‚àí‚ÜíC] ‚àº= [A ‚àí‚ÜíB √ó C].
(v) [0 ‚àí‚ÜíA] ‚àº= 1.
(vi) [A + B ‚àí‚ÜíC] ‚àº= [A ‚àí‚ÜíC] √ó [B ‚àí‚ÜíC].
It is instructive to rewrite these isomorphisms using the notation BA for the object [A ‚àí‚ÜíB].
These isomorphisms are ‚Äònatural in all the variables‚Äô. This means: Ô¨Åx all but one variable. Then
both sides of the isomorphism are functors in the remaining variable in a way analogous to what we
did for Proposition 7.2.2, and the isomorphism is a natural isomorphism between those functors. For
example, Ô¨Åxing A and C in item (iv), we have naturally isomorphic functors [A ‚àí‚Üí‚àí] √ó [A ‚àí‚ÜíC] and
[A ‚àí‚Üí(‚àí√ó C)]. Given f : B ‚àí‚ÜíB‚Ä≤, [A ‚àí‚Üíf] is an arrow as deÔ¨Åned in Proposition 7.2.1, and so [A
‚àí‚Üíf] √ó [A ‚àí‚ÜíC], meaning [A ‚àí‚Üíf] √ó id[A‚àí‚ÜíC], is the product of two arrows as in 6.2.17. [A ‚àí‚Üí(‚àí√ó C)]
is similarly deÔ¨Åned as a composite of functors.
Each of the isomorphisms in Proposition 7.2.3 can be proved by using fullness of the Yoneda embed-
ding (Theorem 5.7.6). We will prove (iii). For Ô¨Åxed objects B and C we have functors [‚àí√ó B ‚àí‚ÜíC] and
[‚àí‚àí‚Üí[B ‚àí‚ÜíC]] from C op to C . Then we have the following chain of natural isomorphisms.
Hom(1, [‚àí√ó B ‚àí‚ÜíC])
‚àº=
Hom(‚àí√ó B, C)
‚àº=
Hom(‚àí, [B ‚àí‚ÜíC])
‚àº=
Hom(1, [‚àí‚àí‚Üí[B ‚àí‚ÜíC]])
The second one is that of the isomorphism (7.1), page 75, and the Ô¨Årst and third are straightforward.
Now Theorem 5.7.6 gives an isomorphism from [‚àí√ó B ‚àí‚ÜíC] to [‚àí‚àí‚Üí[B ‚àí‚ÜíC]].

7.3 Typed Œª-calculus
79
7.2.4 Proposition
Let C be a cartesian closed category with objects A and B. Then
Œª(eval) = id[A‚àí‚ÜíB] : [A ‚àí‚ÜíB] ‚àí‚Üí[A ‚àí‚ÜíB]
Proof. By CCC‚Äì3, eval ‚ó¶((Œª(eval)) √ó A) = eval : [A ‚àí‚ÜíB] √ó A ‚àí‚ÜíB. By the uniqueness requirement of
CCC-3, (Œª(eval)) √ó A = [A ‚àí‚ÜíB] √ó A (the identity arrow) so the Ô¨Årst component of (Œª(eval) √ó A) must
be the identity.
7.3 Typed Œª-calculus
In order to describe the connection between cartesian closed categories and typed Œª-calculus, we give a
brief description of the latter. The material is essentially adapted from [Lambek and Scott, 1984] and
[Lambek and Scott, 1986]. It diÔ¨Äers from the latter reference in that we do not suppose the existence of
a (weak) natural numbers object. The brief discussion in [Lambek, 1986] may be helpful as an overview.
The standard reference on the Œª-calculus is [Barendregt, 1984], which emphasizes the untyped case.
There is a more general idea of typed Œª-calculus in the literature that includes the idea presented
here as one extreme. See [Hindley and Seldin, 1986], pp. 168Ô¨Ä.
7.3.1 DeÔ¨Ånition
A typed Œª-calculus is a formal theory consisting of types, terms, variables and
equations. To each term a, there corresponds a type A, called the type of a. We will write a ‚ààA to
indicate that a is a term of type A. These are subject to the following rules:
TL‚Äì1 There is a type 1.
TL‚Äì2 If A and B are types, then there are types A √ó B and [A ‚àí‚ÜíB].
TL‚Äì3 There is a term ‚àóof type 1.
TL‚Äì4 For each type A, there is a countable set of terms xA
i of type A called variables of type A.
TL‚Äì5 If a and b are terms of type A and B, respectively, there is a term (a, b) of type A √ó B.
TL‚Äì6 If c is a term of type A √ó B, there are terms proj1(c) and proj2(c) of type A and B, respectively.
TL‚Äì7 If a is a term of type A and f is a term of type [A ‚àí‚ÜíB], then there is a term f ‚Äòa of type B.
TL‚Äì8 If x is a variable of type A and œÜ(x) is a term of type B, then Œªx‚ààAœÜ(x) ‚àà[A ‚àí‚ÜíB].
The intended meaning of all the term-forming rules should be clear, with the possible exception of
f ‚Äòa which is to be interpreted as f applied to a. The notation œÜ(x) for the term in TL‚Äì8 means that œÜ is
a term that might contain the variable x. We will use the usual mathematical notation for substitution:
if we have called a term œÜ(x), then œÜ(a) is the term obtained by substituting a for every occurrence
of x in the term. In the literature on the Œª-calculus, more elaborate notations for substitution are used
because they are necessary in complex calculations.
In much of the literature, the symbol ‚Äò is omitted; f ‚Äòa would be written fa.
7.3.2
Before stating the equations, we need some deÔ¨Ånitions. We omit, as usual, unnecessary subscripts.
If x is a variable, then x is free in the term x. If an occurrence of x is free in either of the terms a
or b, then that occurrence of x is free in (a, b). If x occurs freely in either f or a, then that occurrence
of x is free in f ‚Äòa. On the other hand, every occurrence of x is not free (and is called bound) in ŒªxœÜ(x).
The term a is substitutable for x in œÜ(x) if no occurrence of a variable in a becomes bound when
every occurrence of x in œÜ(x) (if any) is replaced by a. A term is called closed if no variable is free in it.
7.3.3
The equations take the form a =X a‚Ä≤, where a and a‚Ä≤ are terms of the same type and X is a
Ô¨Ånite set of variables among which are all variables occurring freely in either a or a‚Ä≤.
TL‚Äì9
The relation =X is reÔ¨Çexive, symmetric and transitive.
TL‚Äì10 If a is a term of type 1, then a ={} ‚àó.
TL‚Äì11 If X ‚äÜY , then a =X a‚Ä≤ implies a =Y a‚Ä≤.
TL‚Äì12 a =X a‚Ä≤ implies f ‚Äòa =X f ‚Äòa‚Ä≤.

80
Cartesian closed categories
TL‚Äì13 f =X f ‚Ä≤ implies f ‚Äòa =X f ‚Ä≤ ‚Äòa.
TL‚Äì14 œÜ(x) =X‚à™{x} œÜ‚Ä≤(x) implies ŒªxœÜ(x) =X ŒªxœÜ‚Ä≤(x).
TL‚Äì15 proj1(a, b) =X a; proj2(a, b) =X b, for a ‚ààA and b ‚ààB.
TL‚Äì16 c =X (proj1(c), proj2(c)), for c ‚ààA √ó B.
TL‚Äì17 ŒªxœÜ(x)‚Äòa =X œÜ(a), if a is substitutable for x in œÜ(x) and œÜ(a) is gotten by replacing every free
occurrence of x by a in œÜ(x).
TL‚Äì18 Œªx‚ààA(f ‚Äòx) =X f provided x /‚ààX (and is thus not free in f).
TL‚Äì19 Œªx‚ààAœÜ(x) =X Œªx‚Ä≤‚ààAœÜ(x‚Ä≤) if x‚Ä≤ is substitutable for x in œÜ(x) and x‚Ä≤ is not free in œÜ(x) and vice
versa.
It is important to understand that the expression a =X a‚Ä≤ does not imply that the terms a and a‚Ä≤ are
equal. Two terms are equal only if they are identical. The symbol ‚Äò=X‚Äô may be understood as meaning
that in any formal interpretation of the calculus, the denotation of the two terms must be the same.
It should be emphasized that these type and term-forming rules and equations are not exhaustive.
There may and generally will be additional types, terms and equations. It is simply that a typed Œª-
calculus must have at least the types, terms and equations described above.
We will usually abbreviate proj1 and proj2 by p1 and p2.
7.4 Œª-calculus to category and back
Both of the concepts of typed Œª-calculus and cartesian closed category are adapted to understanding the
calculus of functions of several variables, so it is not surprising that they are equivalent. In this section
and the next, we describe the constructions which give this equivalence.
7.4.1 DeÔ¨Ånition of the category
Given a typed Œª-calculus L , the objects of the category C(L )
are the types of L . An arrow from an object A to an object B is an equivalence class of terms of type B
with one free variable of type A (which need not actually occur in the terms).
The equivalence relation is the least reÔ¨Çexive, symmetric, transitive relation induced by saying that
two such terms œÜ(x) and œà(y) are equivalent if œÜ and œà are both of the same type, x and y are both of
the same type, x is substitutable for y in œà, and œÜ(x) ={x} œà(x), where œà(x) is obtained from œà(y) by
substituting x for every occurrence of y.
The reason we need equivalence classes is that any two variables of the same type must correspond
to the same arrow, the identity, of that object to itself. If Œªx‚ààAx : 1 ‚àí‚Üí[A ‚àí‚ÜíA] is to name the identity
arrow of A for any variable x ‚ààA, as is intuitively evident, then the arrow corresponding to a variable
x of type A must be the identity of A.
The equivalence relation also makes two terms containing a variable of type 1 equivalent (because of
TL‚Äì10), thus ensuring that 1 will be a terminal object of the category.
7.4.2
Suppose œÜ is a term of type B with at most one free variable x of type A and œà is a term of
type C with at most one free variable y of type B. Note that by replacing, if necessary, x by a variable
that is not bound in œà, we can assume that œÜ is substitutable for y in œà. We then deÔ¨Åne the composite
of the corresponding arrows to be the arrow which is the equivalence class of the term œà(œÜ) obtained by
substituting œÜ for x in œà.
7.4.3 Proposition
The category C(L ) is a cartesian closed category.
We will not prove this here. The construction we have given follows Lambek and Scott [1986], who
give a proof.
We do not need to say what the cartesian closed structure on C(L ) is by virtue of Proposition 7.1.8.
Nevertheless, the construction is the obvious one. A √ó B with proj1 and proj2 is the product of A and
B, and [A ‚àí‚ÜíB] is the exponential object. If œÜ(x) determines an arrow f : C √ó A ‚àí‚ÜíB, then x must be
a variable of type C √ó A. Using TL‚Äì15, we can substitute (z, y) for x in œÜ, getting œÜ(z, y) where z is of
type C and y is of type A. Then Œªf is the equivalence class of ŒªzœÜ(z, y).
Note if z and y actually occur in œÜ(z, y), then it is not in any equivalence class, since it has two free
variables.

7.4 Œª-calculus to category and back
81
7.4.4 Example
We will exhibit some calculations that verify two of the properties of a cartesian closed
category as an example of how the deÔ¨Ånition of C(L ) works.
Let L be a typed Œª-calculus. DeÔ¨Åne
Œõ : HomC(L )(C √ó A ‚àí‚ÜíB) ‚àí‚ÜíHomC(L )(C ‚àí‚Üí[A ‚àí‚ÜíB])
as follows: for [œÜ(u)] : C √ó A ‚àí‚ÜíB (so that u is a variable of type C √ó A), Œõ([œÜ(u)]) = ŒªxœÜ((z, x)), where
z is a variable of type C and x is a variable of type A. DeÔ¨Åne
Œì : HomC(L )(C ‚àí‚Üí[A ‚àí‚ÜíB]) ‚àí‚ÜíHomC(L )(C √ó A ‚àí‚ÜíB)
as follows: for [œà(z)] : C ‚àí‚Üí[A ‚àí‚ÜíB], Œì([œà(z)]) = œà(proj1 u)‚Äòproj2 u, where u is a variable of type C √óA.
Then Œõ and Œì are inverse functions.
We will show one direction of the veriÔ¨Åcation and leave the other as an exercise. The following
calculation uses TL‚Äì18 and the fact that x does not occur in œÜ(z) because by deÔ¨Ånition of arrow in
C(L ), œÜ(z) contains only one variable and that is not x.
Œõ(Œì(œà(z)))
=
Œõ(œà(proj1 u)‚Äò proj2 u)
=
Œªx(œà(proj1(z, x))‚Äò proj2(z, x))
=X
Œªxœà(z)‚Äòx
=X
œà(z)
For another example, let A and B be types in a Œª-calculus L . Then in C(L ), eval : [A ‚àí‚ÜíB] √ó A
‚àí‚ÜíB can be taken to be the equivalence class of the term (proj1 u)‚Äò(proj2 u), where u is a variable of
type [A ‚àí‚ÜíB] √ó A.
To prove this, we must show that for f : C √ó A ‚àí‚ÜíB, eval ‚ó¶(Œªf √ó A) = f. First note that Œªf √ó A =
‚ü®Œªf ‚ó¶p1, p2‚ü©: C √óA ‚àí‚Üí[A ‚àí‚ÜíB]√óA. (See 6.2.17.) Now let z be a variable of type C, y a variable of type
A which is not in X, and suppose f is determined by a term œÜ(z,y) of type B. Then Œªf √óA is represented
by (ŒªyœÜ(z, y) ‚ó¶z, y) =X (ŒªyœÜ(z, y), y) by deÔ¨Ånition of composition in C(L ). Then eval ‚ó¶(Œªf √ó A) is
(p1(ŒªyœÜ(z, y), y))‚Äòp2(ŒªyœÜ(z, y), y) =X ŒªyœÜ(z, y)‚Äòy
by TL‚Äì15 and the easily-proved fact that if a =X a‚Ä≤ and b =X b‚Ä≤ then (a, b) =X (a‚Ä≤, b‚Ä≤). Since y /‚ààX,
this is ŒªyœÜ(z, y) by TL‚Äì18.
7.4.5 Cartesian closed category to Œª-calculus
Let C be a cartesian closed category. We will
suppose that it has been equipped with given Ô¨Ånite products (including, of course, their projections).
This means that with each Ô¨Ånite indexed set of objects {Ai}, i ‚ààI, there is a given product cone with
its projections pi : Q
i‚ààI Ai ‚àí‚ÜíAi.
The internal language of C is a typed Œª-calculus L(C ). We will describe this Œª-calculus by following
DeÔ¨Ånition 7.3.1.
The types of L(C ) are the objects of C . The types required by TL‚Äì1 and TL‚Äì2 are the objects 1,
A √ó B and [A ‚àí‚ÜíB]. We will assume there is a countable set of variables xA
i of type A for each object
A as required by TL‚Äì4. The terms are deÔ¨Åned by TL‚Äì3 through TL‚Äì8, and equality by TL‚Äì9 through
TL‚Äì19.
7.4.6 Theorem
Let C be a cartesian closed category with internal language L . Then C(L ) is a
category equivalent to C .
Lambek and Scott [1986] prove much more than this. They deÔ¨Åne what it means for languages to
be equivalent and show that if you start with a typed Œª-calculus, construct the corresponding category,
and then construct the internal language, the language and the original typed Œª-calculus are equivalent.
They state this in a more powerful way in the language of adjunctions.

8. Limits and colimits
A limit is the categorical version of the concept of an equationally deÔ¨Åned subset of a product. For
example, a circle of radius 1 is the subset of R √ó R (R is the set of real numbers) satisfying the equation
x2 + y2 = 1. Another example is the set of pairs of arrows in a category for which the target of the Ô¨Årst
is the source of the second: this is the set of pairs for which the composition operation is deÔ¨Åned.
A diÔ¨Äerent kind of example is division of one integer by another, which requires that the second
argument be nonzero. This can be made an equational condition by building in a Boolean type and
a test; the equation then becomes [y = 0] = false. (This can also be handled using Ô¨Ånite sums: see
Section 5.7 of [Barr and Wells, 1999].) A colimit is similarly the categorical version of a quotient of a
sum by an equivalence relation.
This chapter discusses Ô¨Ånite limits and colimits in detail, concentrating on certain useful special
cases. InÔ¨Ånite limits and colimits are widely used in mathematics, but they are conceptually similar to
the Ô¨Ånite case, and are not described here.
8.1 Equalizers
If S and T are sets and f, g : S ‚àí‚ÜíT are functions, it is a familiar fact that we can form the subset
Eq(f, g) ‚äÜS consisting of all elements s ‚ààS for which f(s) = g(s). This concept can be made into a
categorical concept by changing it to a speciÔ¨Åcation which turns out to determine a subobject. We will
look more closely at the construction in Set to see how to make the general categorical construction.
Suppose that j : Eq(f, g) ‚àí‚ÜíS is the inclusion function: j(u) = u for u ‚ààEq(f, g). Let h : V ‚àí‚ÜíS be
a function. Then h factors through j : Eq(f, g) ‚àí‚ÜíS if and only if the image of the function h lies in the
subset Eq(f, g) (see 3.3.10). This is the key to the categorical speciÔ¨Åcation of Eq(f, g), DeÔ¨Ånition 8.1.2
below.
8.1.1 DeÔ¨Ånition
Two arrows f : A ‚àí‚ÜíB and g : A ‚àí‚ÜíB of a category (having the same domain and
the same codomain) are a parallel pair of arrows. An arrow h with the property that f ‚ó¶h = g ‚ó¶h is
said to equalize f and g.
8.1.2 DeÔ¨Ånition
Let C be a category and f, g : A ‚àí‚ÜíB be a parallel pair of arrows. An equalizer
of f and g is an object E together with an arrow j : E ‚àí‚ÜíA with the following properties:
EQ‚Äì1 f ‚ó¶j = g ‚ó¶j.
EQ‚Äì2 For each arrow h : C ‚àí‚ÜíA such that f
‚ó¶h = g ‚ó¶h, there is an arrow k : C ‚àí‚ÜíE, and only one,
such that j ‚ó¶k = h.
Frequently, E is referred to as an equalizer of f and g without referring to j. Nevertheless, j is a
crucial part of the data.
8.1.3 Examples of equalizers
In Set, an equalizer E of the functions (x,y) 7‚Üíx2 +y2 and (x,y) 7‚Üí1
from R √ó R to R is the circle x2 + y2 = 1. The arrow j : E ‚àí‚ÜíR √ó R is the inclusion.
Given a graph G , the inclusion of the set of loops in the graph is an equalizer of the source and target
functions. This equalizer will be empty if the graph has no loops.
A theorem like Theorem 6.2.2 is true of equalizers as well.
8.1.4 Proposition
If j : E ‚àí‚ÜíA and j‚Ä≤ : E‚Ä≤ ‚àí‚ÜíA are both equalizers of f, g : A ‚àí‚ÜíB, then there is a
unique isomorphism i : E ‚àí‚ÜíE‚Ä≤ for which j‚Ä≤ ‚ó¶i = j.
Proof. We give two proofs. The Ô¨Årst uses the concept of universal element. Let C be the category
containing the equalizers given. Let F : C op ‚àí‚ÜíSet be the functor for which F(C) = {u : C ‚àí‚ÜíA | f ‚ó¶
u = g ‚ó¶u}, the set of arrows from C which equalize f and g. If h : D ‚àí‚ÜíC let F(h)(u) = u ‚ó¶h. This
makes sense, because if u ‚ààF(C), then f ‚ó¶u ‚ó¶h = g ‚ó¶u ‚ó¶h, so u ‚ó¶h ‚ààF(D). Note that this makes F a
82

8.2 The general concept of limit
83
subfunctor of the contravariant hom functor Hom(‚àí, A). The deÔ¨Ånition of an equalizer of f and g can
be restated this way: an equalizer of f and g is an element j ‚ààF(E) for some object E such that for
any u ‚ààF(C) there is a unique arrow k : C ‚àí‚ÜíE such that F(k)(j) = u. This means j is a universal
element of F, so by Corollary 5.7.17, any two equalizers j ‚ààF(E) and j‚Ä≤ ‚ààF(E‚Ä≤) are isomorphic by a
unique arrow i : E ‚àí‚ÜíE‚Ä≤ such that F(i)(j‚Ä≤) = j. That is, j = j‚Ä≤ ‚ó¶i, as required.
This method of constructing a functor of which the given limit is a universal element is a standard
method in category theory. We have already seen it used in the proof of Proposition 6.2.14 and in the
discussion of the uniqueness of eval in 7.1.7.
Here is a direct proof not using universal elements: the fact that f ‚ó¶j‚Ä≤ = g ‚ó¶j‚Ä≤ implies the existence
of a unique arrow h : E‚Ä≤ ‚àí‚ÜíE such that j‚Ä≤ = j ‚ó¶h. The fact that f
‚ó¶j = g ‚ó¶j implies the existence
of a unique arrow h‚Ä≤ : E ‚àí‚ÜíE‚Ä≤ such that j = j‚Ä≤ ‚ó¶h‚Ä≤. Then j ‚ó¶h ‚ó¶h‚Ä≤ = j‚Ä≤ ‚ó¶h‚Ä≤ = j = j ‚ó¶idE and the
uniqueness part of the deÔ¨Ånition of equalizer implies that h ‚ó¶h‚Ä≤ = idE. By symmetry, h‚Ä≤ ‚ó¶h = idE‚Ä≤.
8.1.5 Proposition
Let j : E ‚àí‚ÜíA be an equalizer of the pair of arrows f, g : A ‚àí‚ÜíB. Then j is a
monomorphism. Moreover, any two equalizers of f and g belong to the same subobject of A.
Proof. To see that j is monic, suppose h, k : C ‚àí‚ÜíE with j ‚ó¶h = j ‚ó¶k = l. Then f ‚ó¶l = f ‚ó¶j ‚ó¶k = g ‚ó¶
j ‚ó¶k so there is a unique arrow m : C ‚àí‚ÜíE with j ‚ó¶m = l. But both h and k are such arrows and so
h = k.
Now suppose j and j‚Ä≤ are equalizers of f and g. In the notation of Proposition 8.1.4, i and i‚àí1 are
the arrows required by the deÔ¨Ånition of subobject in 3.3.12, since j‚Ä≤ ‚ó¶i = j and j ‚ó¶i‚àí1 = j‚Ä≤.
8.1.6
More generally, if f1, . . . , fn are all arrows from A to B, then an object E together with an arrow
j : E ‚àí‚ÜíA is an equalizer of f1, . . . , fn if it has the property that an arbitrary arrow h : C ‚àí‚ÜíA factors
uniquely through j if and only if f1 ‚ó¶h = ¬∑ ¬∑ ¬∑ = fn ‚ó¶h. Having equalizers of parallel pairs implies having
equalizers of all Ô¨Ånite lists,
8.1.7 Regular monomorphisms
A monomorphism e : S ‚àí‚ÜíT in a category is regular if e is an
equalizer of a pair of arrows.
8.1.8 Proposition
An arrow in a category that is both an epimorphism and a regular monomorphism
is an isomorphism.
Proof. Let f : A ‚àí‚ÜíB be both an epimorphism and an equalizer of g, h : B ‚àí‚ÜíC. Since g ‚ó¶f = h ‚ó¶f
and f is epi, g = h. Then g ‚ó¶idB = h ‚ó¶idB so there is a k : B ‚àí‚ÜíA such that f
‚ó¶k = idB. But then
f ‚ó¶k ‚ó¶f = f = f ‚ó¶idA. But f being mono can be cancelled from the left to conclude that k ‚ó¶f = idA.
8.1.9 Proposition
Every monomorphism in Set is regular.
Proof. A monomorphism in Set is an injective function (see Theorem 3.3.3), so let f : A ‚àí‚ÜíB be an
injective function. Let C be the set of all pairs
{(b, i) | b ‚ààB, i = 0, 1}
and impose an equivalence relation on these pairs forcing (b, 0) = (b, 1) if and only if there is an a ‚ààA
with f(a) = b (and not forcing (b, i) = (c, j) if b and c are distinct). Since f is injective, if such an a
exists, there is only one. Let g : B ‚àí‚ÜíC by g(b) = (b, 0) and h : B ‚àí‚ÜíC by h(b) = (b, 1). Then clearly
g(b) = h(b) if and only if there is an a ‚ààA with f(a) = b. Now let k : D ‚àí‚ÜíB with g ‚ó¶k = h ‚ó¶k. It must
be that for all x ‚ààD, there is an a ‚ààA, and only one, such that k(x) = f(a). If we let l(x) = a, then
l : D ‚àí‚ÜíA is the unique arrow with f ‚ó¶l = k.
In contrast, not every monomorphism in Cat is regular. An example is given in [Barr and Wells,
1999], Section 9.1.
8.2 The general concept of limit
Products and equalizers are both examples of the general concept of limit.

84
Limits and colimits
8.2.1 DeÔ¨Ånition
Let G be a graph and C be a category. Let D : G ‚àí‚ÜíC be a diagram in C with
shape G . A cone with base D is an object C of C together with a family {pa} of arrows of C indexed
by the nodes of G , such that pa : C ‚àí‚ÜíDa for each node a of G . The arrow pa is the component of the
cone at a.
The cone is commutative if for any arrow s : a ‚àí‚Üíb of G , the diagram
Da
Db
-
Ds
C
pa    	
pb
@
@@
R
commutes. Note: The diagram D is not assumed to commute.
Such a diagram will also be termed a commutative cone over D (or to D or with base D) with
vertex C. We will write it as {pa} : C ‚àí‚ÜíD or simply p : C ‚àí‚ÜíD. It is clear that if p : C ‚àí‚ÜíD is a cone
over D and f : C‚Ä≤ ‚àí‚ÜíC is an arrow in C , then there is a cone p ‚ó¶f : C‚Ä≤ ‚àí‚ÜíD whose component at a
is pa ‚ó¶f. Moreover p ‚ó¶f is commutative if p is. Note that a cone over a discrete diagram (see 6.1.3) is
vacuously commutative.
8.2.2 DeÔ¨Ånition
If p‚Ä≤ : C‚Ä≤ ‚àí‚ÜíD and p : C ‚àí‚ÜíD are cones, a morphism from p‚Ä≤ to p is an arrow
f : C‚Ä≤ ‚àí‚ÜíC such that for each node a of G , the diagram
C‚Ä≤
C
-
f
Da
p‚Ä≤
a@
@@
R
pa
   	
commutes.
8.2.3 DeÔ¨Ånition
A commutative cone over the diagram D is called universal if every other commu-
tative cone over the same diagram has a unique arrow to it. A universal cone, if such exists, is called a
limit of the diagram D.
8.2.4
It is worth spelling out in some detail the meaning of a limit. To say that p : C ‚àí‚ÜíD is a limit
means that there is given a family pa : C ‚àí‚ÜíDa, indexed by the nodes of G , for which
L‚Äì1 Whenever s : a ‚àí‚Üíb is an arrow of G , then Ds ‚ó¶pa = pb.
L‚Äì2 If p‚Ä≤ : C‚Ä≤ ‚àí‚ÜíD is any other such family with the property that Ds ‚ó¶p‚Ä≤
a = p‚Ä≤
b for every s : a ‚àí‚Üíb in
G , then there is one and only one arrow f : C‚Ä≤ ‚àí‚ÜíC such that for each node a of G , pa ‚ó¶f = p‚Ä≤
a.
8.2.5 Examples
A limit cone over a Ô¨Ånite discrete diagram is a product cone: here, L‚Äì1 and the
commutativity condition Ds ‚ó¶p‚Ä≤
a = p‚Ä≤
b in L‚Äì2 are vacuous.
Equalizers are also limits. Let f, g : A ‚àí‚ÜíB be parallel arrows in a category. An equalizer e : E ‚àí‚ÜíA
is part of a cone
A
B
E
e    	
u
@
@@
R
-
f
-
g
(8.1)
where u = f ‚ó¶e = g ‚ó¶e. This cone is commutative, and it is a limit cone if and only if e is an equalizer
of f and g. Since u is determined uniquely by f and e (or by g and e), it was not necessary to mention
it in DeÔ¨Ånition 8.1.2.

8.2 The general concept of limit
85
8.2.6 Equivalent deÔ¨Ånitions of limit
There are two more equivalent ways to deÔ¨Åne limits. Let
D : G ‚àí‚ÜíC be a diagram. We deÔ¨Åne the category cone(D) as follows. An object of this category is a
commutative cone {pi : C ‚àí‚ÜíDi} and an arrow is a morphism of cones (DeÔ¨Ånition 8.2.2). It is evident
that the identity is a morphism and that the composite of two morphisms is another one. A terminal
object in cone(D), if one exists, is a commutative cone over D to which every other commutative cone
over D has a unique morphism. Thus we have shown that the existence of a limit is equivalent to the
existence of a terminal object of cone(D).
The second equivalent construction of limits associates to D a functor we call cone(‚àí, D) : C op
‚àí‚ÜíSet. For an object C of C , cone(C, D) is the set of commutative cones p : C ‚àí‚ÜíD. If f : C‚Ä≤ ‚àí‚ÜíC,
cone(f,D) : cone(C,D) ‚àí‚Üícone(C‚Ä≤,D) is deÔ¨Åned by cone(f,D)(p) = p ‚ó¶f. It is straightforward to verify
that this is a functor. A universal element of this functor is an object C and an element p ‚ààcone(C, D)
such that for any C‚Ä≤ and any element p‚Ä≤ ‚ààcone(C‚Ä≤, D) there is a unique arrow f : C‚Ä≤ ‚àí‚ÜíC such that
p ‚ó¶f = p‚Ä≤. But this is just the deÔ¨Ånition of a limit cone. (Compare the proof of Proposition 8.1.4.)
We have now sketched the proof of the following.
8.2.7 Theorem
The following three are equivalent for a diagram D in a category C :
(i) a limit of D;
(ii) a terminal object of cone(D);
(iii) a universal element of the functor cone(‚àí, D).
In particular, one can see products and equalizers as terminal objects or as universal elements. One
immediate consequence of this, in light of 5.7.17, is that a limit of a diagram is characterized uniquely
up to a unique isomorphism in the same way that a product is.
8.2.8 Theorem
Let D be a diagram and p : C ‚àí‚ÜíD and p‚Ä≤ : C‚Ä≤ ‚àí‚ÜíD limits. Then there is a unique
arrow i : C ‚àí‚ÜíC‚Ä≤ such that for every node a of the shape graph of D, p‚Ä≤
a ‚ó¶i = pa and i is an isomorphism.
8.2.9 DeÔ¨Ånition
A category is said to have all limits or to be complete if every diagram has a
limit. It is said to have all Ô¨Ånite limits or to be Ô¨Ånitely complete if every diagram whose domain is
a Ô¨Ånite graph has a limit.
The following theorem gives a useful criterion for the existence of all limits or all Ô¨Ånite limits. Another
way of getting all Ô¨Ånite limits is given by Proposition 8.3.7.
8.2.10 Theorem
Suppose every set (respectively, every Ô¨Ånite set) of objects of C has a product and
every parallel pair of arrows has an equalizer. Then every diagram (respectively, every Ô¨Ånite diagram) in
C has a limit.
The proof is omitted.
8.2.11 Corollary
A category C with the following properties
(i) C has a terminal object;
(ii) every pair of objects has a product; and
(iii) every parallel pair of arrows has an equalizer
has all Ô¨Ånite limits.
8.2.12 DeÔ¨Ånition
A functor F : C ‚àí‚ÜíD preserves limits if it takes every limit cone in C to a limit
cone in D. It preserves Ô¨Ånite limits if it takes every limit cone over a graph with a Ô¨Ånite diagram in
C to a limit cone in D.
It follows from Corollary 8.2.11 that a functor that preserves terminal objects, products of pairs of
objects, and equalizers of parallel pairs of arrows preserves all Ô¨Ånite limits.

86
Limits and colimits
8.3 Pullbacks
Here is another example of a Ô¨Ånite limit that will be important to us. Consider an object P and arrows
p1 : P ‚àí‚ÜíA and p2 : P ‚àí‚ÜíB such that the diagram
B
C
-
g
P
A
-
p1
?
p2
?
f
(8.2)
commutes. This does not appear directly to be a cone, because there is no arrow from the vertex P to
C. It is understood to be a commutative cone with the arrow from P to C being the composite f ‚ó¶p1,
which by deÔ¨Ånition is the same as the composite g ‚ó¶p2. It is common to omit such forced arrows in a
cone. (Compare the discussion after Diagram (8.1).) It is more cone-like if we redraw the diagram as
A
C
-
f
B

g
P
p1
       	
?
f ‚ó¶p1 = g ‚ó¶p2
p2
@
@
@
@
@
@
@
R
However, the square shape of (8.2) is standard.
If this commutative cone is universal, then we say that P together with the arrows p1 and p2 is a
pullback or Ô¨Åber product of the pair. We also say that p2 is the pullback of f along g, and that (8.2)
is a pullback diagram. We often write P = A √óC B, although this notation omits the arrows which
are as important as the object C.
8.3.1 Example
In Set, if f : S ‚àí‚ÜíT and g : U ‚àí‚ÜíT are functions, then the pullback
U
T
-
g
P
S
-
p1
?
p2
?
f
(8.3)
is constructed by setting
P = {(s, u) | f(s) = g(u)}
with p1(s, u) = s and p2(s, u) = u.
In one way this example is characteristic of pullbacks in any category with products: in any such
category, P is a subobject of S √ó U.
8.3.2 Example
The inverse image of a function is a special case of a pullback. Suppose g : S ‚àí‚ÜíT
is a set function and A ‚äÜT. Let i : A ‚àí‚ÜíT be the inclusion. Let g‚àí1(A) = {x ‚ààS | g(x) ‚ààA} be the
inverse image of A, j be its inclusion in S, and h be the restriction of g to g‚àí1(A). Then the following
is a pullback diagram.
S
T
-
g
g‚àí1(A)
A
-
h
?
j
?
i
(8.4)

8.3 Pullbacks
87
Observe that Example 8.3.1 gives a general construction for pullbacks in sets, and the present example
gives a construction for a special type of pullback, but this construction is not a special case of the
construction in 8.3.1. By Theorem 8.2.8, there must be a unique function u : {(s,a) | g(s) = a} ‚àí‚Üíg‚àí1(A)
for which g(j(u(s, a))) = i(h(u(s, a))). By the deÔ¨Ånitions of the functions involved, u(s, a) must be s.
The reader may wish to know the origin of the term ‚ÄòÔ¨Åber product‚Äô. Consider a function f : S ‚àí‚ÜíT. Of
the many ways to think of a function, one is as determining a partition of S indexed by the elements of T.
(See 2.6.12.) For t ‚ààT, let
St = f ‚àí1(t) = {s ‚ààS | f(s) = t}
This is a family of disjoint subsets of S (some of which may be empty) whose union is all of S. This is
sometimes described as a Ô¨Åbration of S and St is called the Ô¨Åber over t. Now if S ‚àí‚ÜíT and U ‚àí‚ÜíT are
two arrows and S √óT U is a pullback, then it is not hard to see that
S √óT U =
[
{St √ó Ut | t ‚ààT}
In other words, S √óT U is the Ô¨Åbered set whose Ô¨Åber over any t ‚ààT is the product of the Ô¨Åbers. This is
the origin of the term and of the notation. We will not use the term in these notes, but the notation has
become standard and is too useful to abandon. Fibrations can be constructed for categories as well as sets;
they are considered in Chapter 12 of [Barr and Wells, 1999].
Pullbacks can be used to characterize monomorphisms in a category.
8.3.3 Theorem
These three conditions are equivalent for any arrow f : A ‚àí‚ÜíB in a category C :
(a) f is monic.
(b) The diagram
A
B
-
f
A

f
A
id
    	
?
f
id
@
@
@@
R
is a limit cone.
(c) There is an object P and an arrow g : P ‚àí‚ÜíA for which
A
B
-
f
A

f
P
g
    	
?
f ‚ó¶g
g
@
@
@@
R
is a limit cone.
(The operative condition in (c) is that the same arrow g appears on both slant lines.)
Another connection between pullbacks and monomorphisms is given by the following.
8.3.4 Proposition
In Diagram (8.2), if the arrow f is monic, then so is p2.
This proposition is summed up by saying, ‚ÄòA pullback of a monic is a monic.‚Äô
8.3.5 Weakest precondition as pullback
A widely used approach to program veriÔ¨Åcation is to
attach preconditions and postconditions to program fragments. An example is
1.
{X < 3}
2.
X := X + 1;
3.
{X < 24}
(8.5)
where X is an integer variable.

88
Limits and colimits
Statement 1 is called a precondition and statement 3 is a postcondition. The whole expression (8.5)
is an assertion about the program: if the precondition is true before the program fragment is executed,
the postcondition must be true afterward.
Clearly (8.5) is correct but a stronger assertion can be made. For the given postcondition, the weakest
possible precondition is {X < 23}. In a very general setting, there is a weakest precondition for every
postcondition.
This can be placed in a categorical setting. Let D be the set of possible inputs and E be the set
of possible outputs. Then the program fragment, provided it is deterministic and terminating, can be
viewed as an arrow f : D ‚àí‚ÜíE. Any condition C on a set X can be identiÔ¨Åed with the subset X0 = {x | x
satisÔ¨Åes C}. In particular, the postcondition is a subset S ‚äÜE and the weakest precondition for that
postcondition is the inverse image f ‚àí1(S), which is the unique subobject of D for which
S
E
-
-
f ‚àí1(S)
D
-
-
?
?
is a pullback. In the example, f(x) = x + 1, S = {x | x < 24} and f ‚àí1(S) = {x | x + 1 < 24} = {x | x <
23}.
This is easily checked in the case of Set and is a plausible point of view for other categories repre-
senting data and program fragments.
In the general case, one would expect that an assertion would be some special kind of subobject.
For example, Manes [1986] requires them to be ‚Äòcomplemented‚Äô and Wagner [1987] requires them to be
regular (see 8.1.7). Naturally, if one requires that assertions be subobjects with a certain property, one
would want to work in a category in which pullbacks of such subobjects also had the property. In a
topos (toposes will be discussed in Chapter 11), for example, pullbacks of complemented subobjects are
complemented, and all monomorphisms are regular.
8.3.6 Constructing all Ô¨Ånite limits revisited
Corollary 8.2.11 described a class of limits whose
existence guarantees the existence of all Ô¨Ånite limits. A similar construction is possible for pullbacks.
8.3.7 Proposition
A category that has a terminal object and all pullbacks has all Ô¨Ånite limits.
8.4 Coequalizers
In 8.1.2 we introduced the notion of equalizer. The dual notion is called coequalizer. Explicitly, consider
f, g : A ‚àí‚Üí
‚àí‚ÜíB. An arrow h : B ‚àí‚ÜíC is called a coequalizer of f and g provided h ‚ó¶f = h ‚ó¶g and for
any arrow k : B ‚àí‚ÜíD for which k ‚ó¶f = k ‚ó¶g, there is a unique arrow l : C ‚àí‚ÜíD such that l ‚ó¶h = k.
The way to think about the coequalizer of f and g is as the quotient object made by forcing f and
g to be equal. In the category of sets, this observation becomes the construction that follows.
8.4.1 Coequalizers in Set
Let f,g : S ‚àí‚Üí
‚àí‚ÜíT be a pair of arrows in the category of sets. The conditions
a coequalizer h : T ‚àí‚ÜíU must satisfy are that h ‚ó¶f = h ‚ó¶g and that given any arrow k : T ‚àí‚ÜíV , the
equation k ‚ó¶f = k ‚ó¶g implies the existence of a unique arrow l : U ‚àí‚ÜíV such that l ‚ó¶h = k. (If such an
arrow l exists, then necessarily k ‚ó¶f = k ‚ó¶g.)
The pair f and g determine a relation R ‚äÜT √ó T which consists of
{(f(s), g(s)) | s ‚ààS}
The equation k ‚ó¶f = k ‚ó¶g is equivalent to the statement that k(t1) = k(t2) for all (t1, t2) ‚ààR.
In general R is not an equivalence relation, but it can be completed to one by forming the reÔ¨Çexive,
symmetric and transitive closures of R in that order. The reÔ¨Çexive, symmetric closure is the union
R1 = R ‚à™‚àÜ‚à™Rop where ‚àÜ= {(t, t) | t ‚ààT} and Rop = {(t2, t1) | (t1, t2) ‚ààR}. If we inductively deÔ¨Åne
Ri+1 to be the set

8.5 Cocones
89
{(t1, t2) | ‚àÉt ‚ààT((t1, t) ‚ààR1 and (t, t2) ‚ààRi)}
for each i ‚ààN and deÔ¨Åne eR = S Rn, then eR is the transitive closure of R1 and is the least equivalence
relation containing R.
When S and T are Ô¨Ånite, the least equivalence relation of the previous paragraph can be computed
eÔ¨Éciently by Warshall‚Äôs Algorithm ([Sedgewick, 1983], p. 425).
Let U be the set of equivalence classes modulo the equivalence relation eR and let h : T ‚àí‚ÜíU be the
function that sends an element of T to the class that contains that element.
8.4.2 Proposition
The arrow h is a coequalizer of f and g.
Proof. Since R ‚äÜeR, the fact that h(t1) = h(t2) for all (t1, t2) ‚ààeR implies, in particular, that the
same equation is satisÔ¨Åed for all (t1, t2) ‚ààR; this means that for all s ‚ààS, h(f(s)) = h(g(s)), so that
h ‚ó¶f = h ‚ó¶g.
Now let k : T ‚àí‚ÜíV satisfy k ‚ó¶f = k ‚ó¶g. We claim that for (t1, t2) ‚ààeR, k(t1) = k(t2). In fact, this
is true for (t1, t2) ‚ààR. It is certainly true for t1 = t2, i.e. (t1, t2) ‚àà‚àÜimplies that k(t1) = k(t2). Since
k(t1) = k(t2) implies that k(t2) = k(t1), we now know that the assertion is true for (t1, t2) ‚ààR1. Since
k(t1) = k(t2) and k(t2) = k(t3) imply k(t1) = k(t3), one may show by induction that the assertion is true
for all the Rn and hence for eR. This shows that k is constant on equivalence classes and hence induces
a function l : U ‚àí‚ÜíV such that l ‚ó¶h = k. Since h is surjective, l is unique.
Sums and coequalizers are used in [Rydeheard and Burstall, 1985] to provide a theoretical basis
for the theory of uniÔ¨Åcation used in logic programming. See also [Barr and Wells, 1999], Chapter 9,
[Rydeheard and Burstall, 1986] and [Goguen, 1988].
8.4.3 Regular epimorphisms
In Proposition 8.1.5, it is asserted that all equalizers are monomorph-
isms. The dual is of course also true; all coequalizers are epimorphisms. The converse is not true; not
every epimorphism is a coequalizer of some pair of arrows. For example, in the category of monoids,
the inclusion of the nonnegative integers into the set of all integers is an epimorphism but is not the
coequalizer of any pair of arrows. Those epimorphisms that are the coequalizer of some pair of arrows
into their domain are special and this is marked by giving them a special name: they are called regular
epimorphisms.
In the category of sets, every epimorphism is regular It follows that in the category of sets, a pullback
of a regular epi is regular. In contrast to this, let N denote the monoid of natural numbers on addition and
Z the monoid of integers on addition. Then the inclusion function is an epimorphism (in the category of
monoids) which is not regular. (But every surjective epimorphism in the category of monoids is regular.)
A category is called a regular category if it has Ô¨Ånite limits, if every parallel pair of arrows has
a coequalizer, and if the arrow opposite a regular epimorphism in a pullback diagram is a regular
epimorphism. A functor between regular categories is called a regular functor if it preserves Ô¨Ånite
limits and regular epis.
It is an old theorem (stated in diÔ¨Äerent language) that all categories of models of FP sketches, in other
words, all varieties of multisorted algebraic structures, are regular ([Barr and Wells, 1985], Theorem 1 of
Section 8.4). Because of such examples, regular categories have seen considerable theoretical study, and
regular epimorphisms have played a larger role in category theory than regular monos have.
8.5 Cocones
Just as there is a general notion of limit of which products and equalizers are special cases, so there is a
general notion of colimit.
8.5.1 DeÔ¨Ånition
A cocone is a cone in the dual graph. Spelling the deÔ¨Ånition out, it is a diagram
D : G0 ‚àí‚ÜíG , a node g of G together with a family ua : Da ‚àí‚Üíg of arrows indexed by the objects of G0.
The diagram is called the base of the cocone. If the diagram is discrete, it is called a discrete cocone.
A cocone in a category is called commutative if it satisÔ¨Åes the dual condition to that of commutative
cone. Explicitly, if the diagram is D : G ‚àí‚ÜíC and the cone is {ua : Da ‚àí‚ÜíC | a ‚ààOb(G )}, then what

90
Limits and colimits
is required is that for each arrow s : a ‚àí‚Üíb of G , ub ‚ó¶Ds = ua. The commutative cocone is called a
colimit cocone if it has a unique arrow to every other commutative cocone with the same base.
8.5.2 Cocompleteness
A category has all colimits or is cocomplete if every diagram in the cat-
egory has a colimit. It has Ô¨Ånite colimits or is Ô¨Ånitely cocomplete if every diagram with a Ô¨Ånite
graph has a colimit.
Categories of algebraic structures are complete and cocomplete. If we disallowed the empty semigroup
(see 3.2.1) we would have to say that the category of semigroups is ‚Äòcomplete and cocomplete except
that it does not have an initial object‚Äô. We would also have to say that the intersection of any set of
subsemigroups of a semigroup is either a subsemigroup or empty.
8.5.3 Pushouts
For example, dual to the notion of pullback is that of pushout. In detail, a commu-
tative square
B
Q
-
q2
C
A
-
f
?
g
?
q1
(8.6)
is called a pushout if for any object R and any pair of arrows r1 : A ‚àí‚ÜíR and r2 : B ‚àí‚ÜíR for which
r1 ‚ó¶f = r2 ‚ó¶g there is a unique arrow r : Q ‚àí‚ÜíR such that r ‚ó¶qi = ri, i = 1, 2.
8.5.4 Pushouts as amalgamations
If the eÔ¨Äect of coequalizers is to force identiÔ¨Åcations, that of
pushouts is to form what are called amalgamated sums. We illustrate this with examples.
First, consider the case of a set S and three subsets S0, S1 and S2 with S0 = S1 ‚à©S2 and S = S1 ‚à™S2.
Then the diagram
S2
S
-
S0
S1
-
?
?
with all arrows inclusion, is a pushout. (It is a pullback as well; such diagrams are often referred to
as Doolittle diagrams.) The deÔ¨Ånition of pushout translates to the obvious fact that if one is given
functions f1 : S1 ‚àí‚ÜíT and f2 : S2 ‚àí‚ÜíT and f1|S0 = f2|S0, then there is a unique function f : S ‚àí‚ÜíT
with f|S1 = f1 and f|S2 = f2.
Now consider a slightly more general situation. We begin with sets S0, S1 and S2 and functions
g1 : S0 ‚àí‚ÜíS1 and g2 : S0 ‚àí‚ÜíS2. If g1 and g2 are injections, then, up to isomorphism, this may be viewed
as the same as the previous example. Of course, one cannot then form the union of S1 and S2, but rather
Ô¨Årst the disjoint sum and then, for s ‚ààS0, identify the element g1(s) ‚ààS1 with g2(s) ‚ààS2. In this case,
the pushout is called an amalgamated sum of S1 and S2.
More generally, the gi might not be injective and then the amalgamation might identify two elements
of S1 or of S2, but the basic idea is the same; pushouts are the way you identify part of one object with
a part of another.
8.5.5 Equations, equalizers and coequalizers
One way of thinking about an equalizer is as the
largest subobject on which an equation or set of equations is true. A coequalizer, by contrast, is the least
destructive identiÔ¨Åcation necessary to force an equation to be true on the equivalence classes.
Here is an instructive example. There are two ways of deÔ¨Åning the rational numbers. They both begin
with the set Z √ó N+ of pairs of integers (a, b) for which b > 0. For the purpose of this illustration, we
will write (a/b) instead of (a, b). In the Ô¨Årst, more familiar, construction, we identify (a/b) with (c/d)
when a ‚àód = b ‚àóc. One way of describing this is as the coequalizer of two arrows
T ‚àí‚Üí
‚àí‚ÜíZ √ó N+

8.5 Cocones
91
where T is the set of all (a, b, c, d) ‚ààZ √ó N+ √ó Z √ó N+ such that a ‚àód = b ‚àóc and the Ô¨Årst arrow sends
(a, b, c, d) to (a/b) while the second sends it to (c/d). The eÔ¨Äect of the coequalizer is to identify (a/b)
with (c/d) when a ‚àód = b ‚àóc.
The second way to deÔ¨Åne the rationals is the set of pairs that are relatively prime (that is, in lowest
terms). This can be realized as an equalizer as follows. Let gcd : Z√óN+ ‚àí‚ÜíN+ take a pair of numbers to
their positive greatest common divisor. Let 1 ‚ó¶‚ü®‚ü©: Z √ó N+ ‚àí‚ÜíN+ denote the function that is constantly
1. Then an equalizer of gcd and 1 ‚ó¶‚ü®‚ü©is exactly the set of relatively prime pairs.

9. Adjoints
Adjoints are about the most important idea in category theory, except perhaps for the closely related
notion of representable functors. Many constructions made earlier in these notes are examples of adjoints,
as we will describe. Moreover, toposes are most conveniently described in terms of adjoints. Section 9.1
revisits the concept of free monoids, describing them in a way which suggests the general deÔ¨Ånition of
adjoint. Adjoints are described and some basic properties developed in Sections 9.2 and 9.3.
More detail concerning adjoints can be found in [Barr and Wells, 1985] and [Mac Lane, 1971].
Diers [1980a], [1980b] describes a generalization which includes the initial families of Ô¨Ånite-discrete
sketches. Hagino [1987a], [1987b] has a general approach to type constructors for functional programming
languages based on adjoints (see also [Chen and Cockett, 1989]).
9.1 Free monoids
In 4.1.15, we gave the universal property of the free monoid. We now state it more carefully than we did
there, paying closer attention to the categories involved. Note that when we speak of a subset of a monoid,
we are mixing two things. A monoid is not just a set and most of its subsets are not submonoids. To
describe a monoid, you must give three data: the set of elements, the operation and the identity element.
From this point of view the phrase ‚Äòsubset of a monoid‚Äô does not make sense. It is actually a subset of the
underlying set of the monoid. Insistence on this is not pointless pedantry; it is the key to understanding
the situation.
Let Mon denote the category of monoids and let U : Mon ‚àí‚ÜíSet denote the underlying set functor.
We deÔ¨Åne a monoid M to be a triple (UM, ¬∑, 1), where UM is a set called the underlying set of M, ¬∑
is a binary operation on UM and 1 ‚ààUM is the identity element for that operation. A homomorphism
from a monoid M to a monoid N is a function f : UM ‚àí‚ÜíUN which preserves the operation and the
identity element. The underlying functor is deÔ¨Åned on homomorphisms by Uf = f.
9.1.1 Characterization of the free monoid
Given a set X, the free monoid F(X) = (X‚àó, ¬∑, ‚ü®‚ü©) is
characterized by the property given in the following proposition; the property is called the universal
mapping property of the free monoid. In the proposition, Œ∑X : X ‚àí‚ÜíX‚àó= UF(X) takes x ‚ààX to
the string ‚ü®x‚ü©of length 1. We systematically distinguish the free monoid F(X) from its underlying set,
the Kleene closure X‚àó= U(F(X)).
9.1.2 Proposition
Let X be a set. For any monoid M and any function u : X ‚àí‚ÜíU(M), there is a
unique monoid homomorphism g : F(X) ‚àí‚ÜíM such that u = Ug ‚ó¶Œ∑X.
Proof. DeÔ¨Åne g(‚ü®‚ü©) to be the identity element of M, g(‚ü®x‚ü©) = u(x) for x ‚ààX, and g(‚ü®x1 ¬∑ ¬∑ ¬∑ xn‚ü©) to be
the product u(x1) ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ u(xn) in M. That makes g a monoid homomorphism and u = Ug ‚ó¶Œ∑X.
This proposition says Œ∑X is a universal element for the functor Hom(X, U‚àí) that takes a monoid
M to Hom(X, U(M)) and a monoid homomorphism f : M ‚àí‚ÜíN to Hom(X, U(f)) : Hom(X, U(M))
‚àí‚ÜíHom(X, U(N)). It follows that the universal mapping property characterizes the free monoid up to a
unique isomorphism. Precisely, let X be a set and Œ≥ : X ‚àí‚ÜíU(E) a function to the underlying set of some
monoid E with the property that if u : X ‚àí‚ÜíU(M), where M is any monoid, there is a unique monoid
homomorphism f : E ‚àí‚ÜíM such that u = U(f) ‚ó¶Œ≥. We now show that there is a unique isomorphism
œÜ : E ‚àí‚ÜíF(X) for which
U(E)
U(F(X))
-
U(œÜ)
X
Œ≥
    	
Œ∑X
@
@
@@
R
commutes. As we have noted above, Œ∑X is a universal element of the functor Hom(X, U(‚àí)). The
assumption on Œ≥ says that it is also a universal element for the same functor. Now Corollary 5.7.17
92

9.1 Free monoids
93
says there is a unique isomorphism œÜ : E ‚àí‚ÜíF(X) for which Hom(X, U(œÜ))(Œ≥) = Œ∑X. The result follows
because
Hom(X, U(œÜ))(Œ≥) = U(œÜ) ‚ó¶Œ≥
by deÔ¨Ånition.
9.1.3 The free monoid functor
Each set X generates a free monoid F(X). In 4.1.13, we extended
this to a functor F : Set ‚àí‚ÜíMon. In this section, we will prove this (as part of the proof of Propo-
sition 9.1.4 below) using only the universal mapping property of free monoids; thus the argument will
work in complete generality.
Let Œ∑Y denote the arrow from Y into Y ‚àó= UFY described in 9.1.1 and let f : X ‚àí‚ÜíY be a function.
Then Œ∑Y
‚ó¶f : X ‚àí‚ÜíY ‚àóis a function from X into the set underlying a monoid. The universal property
of F(X) gives a unique monoid homomorphism F(f) : F(X) ‚àí‚ÜíF(Y ) such that if f ‚àó= UF(f), then
X‚àó
Y ‚àó
-
f ‚àó
X
Y
-
f
?
Œ∑X
?
Œ∑Y
(9.1)
commutes.
9.1.4 Proposition
F : Set ‚àí‚ÜíMon is a functor and, for any set X, Œ∑X is the component at X of a
natural transformation Œ∑ : idSet ‚àí‚ÜíU ‚ó¶F.
Proof. Once F is shown to be a functor, that Œ∑ is a natural transformation will follow from Diagram (9.1).
First note that if id : X ‚àí‚ÜíX is the identity, then F(id) is the unique arrow h : F(X) ‚àí‚ÜíF(X) such
that
X‚àó
X‚àó
-
Uh
X
X
-
id
?
Œ∑X
?
Œ∑X
commutes. But if we replace h in the diagram above by idF X, the diagram still commutes. The uniqueness
property of the free monoid implies that h = idF X.
Similarly, if g : Y ‚àí‚ÜíZ is a function, the commutativity of both squares in
X‚àó
Y ‚àó
-
f ‚àó
X
Y
-
f
?
Œ∑X
?
Œ∑Y
Y ‚àó
Z‚àó
-
g‚àó
Y
Z
-
g
?
Œ∑Y
?
Œ∑Z
implies that
X‚àó
Z‚àó
-
g‚àó‚ó¶f ‚àó
X
Z
-
g ‚ó¶f
?
Œ∑X
?
Œ∑Z
commutes. But g‚àó‚ó¶f ‚àó= UF(g) ‚ó¶UF(f) = U(F(g) ‚ó¶F(f)) since U is a functor. This means that the
arrow F(g) ‚ó¶F(f) satisÔ¨Åes the same equation that characterizes F(g ‚ó¶f) uniquely and hence that they
are equal. This shows that F is a functor and that Œ∑ is a natural transformation.

94
Adjoints
Another example of functors F and U satisfying this is the free category given by a graph as described
in 2.6.16. This very same proof shows that the free category construction is really the object part of a
functor.
9.2 Adjoints
The relationship between the free monoid functor and the underlying set functor is an example of a very
general situation, an adjunction, deÔ¨Åned below.
In this section, we have several notational shortcuts to prevent clutter of parentheses and composition
circles. This notation is quite standard in the literature on adjoints. For example, an expression UFUA
is shorthand for (U ‚ó¶F
‚ó¶U)(A), which is the same as U(F(U(A))).
9.2.1 DeÔ¨Ånition
Let A and B be categories. If F : A ‚àí‚ÜíB and U : B ‚àí‚ÜíA are functors, we say
that F is left adjoint to U and U is right adjoint to F provided there is a natural transformation
Œ∑ : id ‚àí‚ÜíUF such that for any objects A of A and B of B and any arrow f : A ‚àí‚ÜíUB, there is a unique
arrow g : FA ‚àí‚ÜíB such that
A
UFA
-
Œ∑A
f@
@@
R
UB
?
Ug
(9.2)
commutes.
This deÔ¨Ånition asserts that there is a functional way to convert any arrow f : A ‚àí‚ÜíUB to an arrow
g : FA ‚àí‚ÜíB in such a way that g solves the equation f = U(?) ‚ó¶Œ∑A, and that the solution is unique.
The property of Œ∑ given in the last sentence of DeÔ¨Ånition 9.2.1 is called its universal mapping
property. The existence of the unique arrow g : FA ‚àí‚ÜíB such that f = Ug ‚ó¶Œ∑A is the map-lifting
property of Section 4.1.15. Just as in the discussion after Proposition 9.1.2, for each object A, the arrow
Œ∑A is a universal element for the functor Hom(A, U(‚àí)).
It is customary to write F
U to denote the situation described in the deÔ¨Ånition. The data (F, U, Œ∑)
constitute an adjunction. The transformation Œ∑ is called the unit of the adjunction.
In some texts the adjunction is written as a rule of inference, like this:
A ‚àí‚ÜíUB
FA ‚àí‚ÜíB
(9.3)
The deÔ¨Ånition appears to be asymmetric in F and U. This is remedied in the next proposition, whose
proof is deferred to the next section, after the proof of Theorem 9.3.2.
9.2.2 Proposition
Suppose F : A ‚àí‚ÜíB and U : B ‚àí‚ÜíA are functors such that F
U. Then there
is a natural transformation œµ : FU ‚àí‚ÜíidB such that for any g : FA ‚àí‚ÜíB, there is a unique arrow f : A
‚àí‚ÜíUB such that
FA
B
-
g
Ff
   
FUB
?
œµB
(9.4)
The transformation œµ is called the counit of the adjunction.
It is an immediate consequence of categorical duality that this proposition is reversible and the
adjunction is equivalent to the existence of either natural transformation Œ∑ or œµ with its appropriate
universal mapping property.

9.2 Adjoints
95
9.2.3 Examples of adjoints
We have of course the example of free monoids that introduced this
chapter. In general, let C be a category of sets with structure and functions which preserve the structure,
and let U : C ‚àí‚ÜíSet be the underlying set functor. If U has a left adjoint F and S is a set, then F(S)
is the free structure on S. This description Ô¨Åts structures you may know about, such as free groups,
free Abelian groups and free rings.
We now give three related examples that illustrate how widespread adjoints are.
9.2.4 Example
Let C be a category. Consider the category C √ó C which has as objects pairs of
objects (A, B) of C and in which an arrow (A, B) ‚àí‚Üí(A‚Ä≤, B‚Ä≤) is a pair (f, g) of arrows f : A ‚àí‚ÜíA‚Ä≤ and
g : B ‚àí‚ÜíB‚Ä≤. There is a functor ‚àÜ: C ‚àí‚ÜíC √ó C given by ‚àÜ(A) = (A, A) and ‚àÜ(f) = (f, f). Let us see
what a right adjoint to this functor is.
Assuming there is a right adjoint Œ† to ‚àÜ, there should be an arrow we call
‚ü®p1, p2‚ü©: ‚àÜŒ†(A, B) = (Œ†(A, B), Œ†(A, B)) ‚àí‚Üí(A, B)
(this is the counit of the adjunction) with the following universal property:
PP
For any object C of C and any arrow ‚ü®q1, q2‚ü©: ‚àÜC = (C, C) ‚àí‚Üí(A, B) there is a unique arrow
q : C ‚àí‚ÜíŒ†(A, B) such that
(C, C)
(Œ†(A, B), Œ†(A, B))
-
‚ü®q, q‚ü©
‚ü®q1, q2‚ü©
@
@
@
@
@
@
@
R
(A, B)
?
‚ü®p1, p2‚ü©
commutes.
A diagram in a product category commutes if and only if each component does. Breaking the triangle
into components the adjunction asserts the existence of a unique map q : C ‚àí‚ÜíŒ†(A, B) such that each
of the triangles
C
Œ†(A, B)
-
q
q1
@
@
@@
R
A
?
p1
C
Œ†(A, B)
-
q
q2
@
@
@@
R
B
?
p2
commutes. If you write A√óB instead of Œ†(A,B) you will recover the categorical deÔ¨Ånition of the product.
Thus a right adjoint to ‚àÜis just a functor Œ† : C √óC ‚àí‚ÜíC that chooses a product for each pair of objects
of C . Such a functor Œ† is called a binary product functor.
9.2.5 Example
Now let us suppose we are given a binary product functor Œ†. We can Ô¨Åx an object A
of C and consider the functor denoted ‚àí√ó A : C ‚àí‚ÜíC whose value at an object B is the object B √ó A
and at an arrow f : B ‚àí‚ÜíC is the arrow f √ó idA : B √ó A ‚àí‚ÜíC √ó A (see 6.2.17).
A right adjoint to the functor ‚àí√ó A, if one exists, can be described as follows. Denote the value at
C of this adjoint by RA(C). Then there is an arrow e : RA(C) √ó A ‚àí‚ÜíC with the universal property
that for any arrow f : B √ó A ‚àí‚ÜíC, there is a unique arrow we may call Œªf : B ‚àí‚ÜíRA(C) such that
e ‚ó¶(Œªf √ó A) = f. But this is precisely the universal property that describes the exponential [A ‚àí‚ÜíC]
(see 7.1.3). The counit e is the arrow eval deÔ¨Åned there. The essential uniqueness of adjoints (see 9.3.4
below) implies that this adjunction property determines the exponential, if it exists, up to isomorphism.
Thus the two main deÔ¨Åning properties deÔ¨Åning cartesian closed categories, namely the existence of
binary products and the existence of exponentials, can be (and commonly are) described in terms of
adjoints.

96
Adjoints
9.2.6 Example
We can describe the functor ‚àí√óA of 9.2.5 in a slightly diÔ¨Äerent way. For a category C
and object A of C we described the slice category C /A in 2.6.10 and functor UA : C /A ‚àí‚ÜíC in 4.1.12.
If UA has a right adjoint PA : C ‚àí‚ÜíC /A, then PA must associate to each object C of C an object
œÜAC = PA(C) : TAC ‚àí‚ÜíA of C /A and an arrow (the counit) œµAC : TAC ‚àí‚ÜíC. This object and arrow
must have the universal mapping property that for any other object f : B ‚àí‚ÜíA of C /A, and any arrow
g : B ‚àí‚ÜíC there is a unique arrow h : B ‚àí‚ÜíTAC such that
B
TAC
-
h
A
f
@
@
@@
R
œÜAC
    	
B
TAC
-
h
C
g
@
@
@@
R
œµAC
    	
commute. The left triangle must commute in order to have an arrow in C /A and the right hand triangle
must commute for its universal mapping property. It is evident from this description that TAC is C √ó A
and œµAC and œÜAC are the Ô¨Årst and second projections. Thus PA(C) is the object p2 : C √ó A ‚àí‚ÜíA of
C /A.
9.2.7 Example
For any set A with other than one element, the functor ‚àí√ó A : Set ‚àí‚ÜíSet deÔ¨Åned
in 9.2.5 does not have a left adjoint in Set. For if it has a left adjoint F, then by deÔ¨Ånition of left
adjoint there is for any set X an arrow Œ∑X : X ‚àí‚ÜíFX √óA with the property that for any function f : X
‚àí‚ÜíY √ó A there is a unique function g : FX ‚àí‚ÜíY for which (g √ó A) ‚ó¶Œ∑X = f. Now take Y = 1, the
terminal object (any one element set). There is only one function g : FX ‚àí‚Üí1, so there can be only one
function f : X ‚àí‚Üí1√óA ‚àº= A. If A has more than one element and X is non-empty, this is a contradiction.
9.2.8 Adjoints to the inverse image functor
Here is another example of an adjoint. If S is a set,
the set of subsets of S is a poset ordered by inclusion. This becomes a category in the usual way. That is,
if S0 and S1 are subsets of S, then there is exactly one arrow S0 ‚àí‚ÜíS1 if and only if S0 ‚äÜS1. You should
not view this arrow as representing a function, but just a formal arrow that represents the inclusion. We
will call this category Sub(S).
If f : S ‚àí‚ÜíT is a function, then with any subset T0 ‚äÜT, we get a subset, denoted
f ‚àí1(T0) = {s ‚ààS | f(s) ‚ààT0}
which is called the inverse image under f of T0. If T0 ‚äÜT1, then f ‚àí1(T0) ‚äÜf ‚àí1(T1). This means that
f ‚àí1 is a functor from Sub(T) ‚àí‚ÜíSub(S). This functor turns out to have both left and right adjoints.
The left adjoint is a familiar one (to mathematicians at least), the so-called direct image. For
S0 ‚äÜS, let
f‚àó(S0) = {f(s) | s ‚ààS0}
Then f‚àó(S0) ‚äÜT0 if and only if S0 ‚äÜf ‚àí1(T0), which is just the statement that the direct image is left
adjoint to the inverse image.
The right adjoint of the inverse image is usually denoted f! and is deÔ¨Åned by saying that t ‚ààf!(S0)
if and only if f ‚àí1({t}) ‚äÜS0. Another way of saying this is that every element of the inverse image of t
is in S0, while t ‚ààf‚àó(S) if and only if some element of the inverse image of t is in S0.
We discussed these constructions in 4.1.19 and 4.1.20 for Set.
9.2.9 Adjoints in posets
Example 9.2.8 is a special case of an adjunction between ordered or even
preordered sets. Let P and Q be preordered sets, that is categories in which there is at most one arrow
between any pair of objects. We will use ‚â§for the preorder relation, and the reader may Ô¨Ånd it more
natural to think of this relation as a partial ordering (antisymmetric as well as reÔ¨Çexive and transitive).
If f : P ‚àí‚ÜíQ and u : Q ‚àí‚ÜíP are functors, that is, order preserving functions, then f
u means, when
translated into poset language (where uniqueness is not a consideration, since there is at most one arrow
between any two objects), that
x ‚â§(u ‚ó¶f)(x) for all x ‚ààX
(9.5)
and
x ‚â§u(y) implies f(x) ‚â§y
(9.6)

9.3 Further topics on adjoints
97
for all x ‚ààX and y ‚ààY . We claim that these two conditions together are equivalent to the condition
f(x) ‚â§y if and only if x ‚â§u(y)
(9.7)
In fact, assuming (9.5) and (9.6), then if f(x) ‚â§y, we have x ‚â§(u ‚ó¶f)(x) ‚â§u(y); condition (9.7) follows
from this and (9.6). Conversely if (9.7) holds, then (9.6) is immediate and f(x) ‚â§f(x) implies that
x ‚â§(u ‚ó¶f)(x). This is a special case of the Hom set adjunction of the next section (Theorem 9.3.2).
A very common situation involves a pair of contravariant, that is order reversing, functors. In that
case, we can dualize either P or Q. Suppose we do the former. Then we have a pair of functors f : P op
‚àí‚ÜíQ and u : Q ‚àí‚ÜíP op. If f
u, then, translating this condition back to P, we see that f(x) ‚â§y if and
only if u(y) ‚â§x. Such a pair of contravariant functors is often called a Galois connection between P
and Q, named after the Ô¨Årst one produced by Galois.
If you know Galois theory of Ô¨Åelds, then you know that E is a Galois extension of F, then there is a one-one
order reversing correspondence between subÔ¨Åelds of E that include F and subgroups of the Galois group of
E over F. This particular Galois correspondence is an equivalence and some people prefer to restrict the
use of the term ‚ÄòGalois connection‚Äô to the case of equivalence, while others use it as we have and call the
other a Galois equivalence.
9.2.10 Example
Let R and Z denote the ordered sets of real numbers and integers, respectively,
considered as categories. Then the left adjoint to the inclusion Z ‚äÜR is the ceiling function and the right
adjoint is the Ô¨Çoor function.
9.3 Further topics on adjoints
9.3.1 Hom set adjointness
There is an alternative formulation of adjointness which is often found
in the categorical literature.
9.3.2 Theorem
If A and B are categories and U : B ‚àí‚ÜíA and F : A ‚àí‚ÜíB are functors, then
F
U if and only if Hom(F‚àí, ‚àí) and Hom(‚àí, U‚àí) are naturally isomorphic as functors A op √ó B
‚àí‚ÜíSet.
Proof. Let F
U, and let A and B be objects of A and B respectively. DeÔ¨Åne Œ≤A,B : Hom(FA, B)
‚àí‚ÜíHom(A, UB) by Œ≤A,B(g) = Ug
‚ó¶Œ∑A, and Œ≥A,B : Hom(A, UB) ‚àí‚ÜíHom(FA, B) by requiring that
Œ≥A,B(f) be the unique arrow g such that f = Ug ‚ó¶Œ∑A given by DeÔ¨Ånition 9.2.1. Then Œ≥A,B(Œ≤A,B(g)) = g
by the uniqueness requirement of DeÔ¨Ånition 9.2.1, and Œ≤A,B(Œ≥A,B(f)) = f by deÔ¨Ånition of Œ≤A,B and
Œ≥A,B. Thus Œ≤A,B is an isomorphism with inverse Œ≥A,B. The proof of naturality is omitted.
To go in the other direction, suppose we have the natural isomorphism. Then let A be an arbitrary
object of A and B = FA. We then get Hom(FA, FA) ‚àº= Hom(A, UFA). Let Œ∑A ‚ààHom(A, UFA) be
the arrow that corresponds under the isomorphism to the identity arrow of FA. Now for an arrow
f : A ‚àí‚ÜíUB, that is f ‚ààHom(A, UB), let g ‚ààHom(FA, B) be the arrow that corresponds under the
isomorphism. Naturality of the isomorphism implies that we have a commutative diagram
Hom(FA, B)
Hom(A, UB)
-
‚àº=
Hom(FA, FA)
Hom(A, UFA)
-
‚àº=
?
Hom(FA, g)
?
Hom(A, Ug)
If we follow the identity arrow of FA around the clockwise direction, we get Ô¨Årst the arrow Œ∑A by
deÔ¨Ånition, and then Hom(A, Ug)(Œ∑A) = Ug ‚ó¶Œ∑A. In the other direction, we get Hom(FA, g)(id) = g ‚ó¶
id = g and that corresponds under the isomorphism to f. Thus we conclude that f = Ug ‚ó¶Œ∑A. As for
the uniqueness, if f = Uh ‚ó¶Œ∑A, then both g and h correspond to f under the isomorphism, so g = h.

98
Adjoints
9.3.3 Proof of Proposition 9.2.2
The hypotheses of the above theorem are symmetric in F and U
and therefore the conclusion must be too. Thus categorical duality implies the existence of œµ and the
requisite universal mapping property.
9.3.4 Uniqueness of adjoints
If U : B ‚àí‚ÜíA is a functor, then a left adjoint to U, if one exists, is
unique up to natural isomorphism. The reason is that if both F and F ‚Ä≤ are left adjoint to U, then for
any object A of A , the Hom functors HomB(FA, ‚àí) and HomB(F ‚Ä≤A, ‚àí) are each naturally isomorphic
to HomA (A, U‚àí) and hence to each other. It follows from the Yoneda embedding, Theorem 5.7.6, that
FA ‚àº= F ‚Ä≤A. The naturality of the latter isomorphism follows from the next theorem.
9.3.5 Theorem
Let A and B be categories and U : B ‚àí‚ÜíA be a functor. Suppose for each object A
of A there is an object FA of B such that HomB(FA, ‚àí) is naturally equivalent to HomA (A, U‚àí) as
a functor from B to Set. Then the deÔ¨Ånition of F on objects can be extended to arrows in such a way
that F becomes a functor and is left adjoint to U.
This theorem is called the Pointwise Adjointness Theorem. Its proof generalizes the argument
of 9.1.3 but we omit the details. They can be found in [Barr and Wells, 1985], Section 1.9, Theorem
1, page 52. There is a detailed, general discussion of many equivalent deÔ¨Ånitions of adjunction in [Mac
Lane, 1971], Chapter IV.
One application of this theorem is in showing that the deÔ¨Ånition of cartesian closed categories given in
Chapter 7 is equivalent to the assumptions that the functors ‚àÜof 9.2.3 and ‚àí√ó A of 9.2.5 have adjoints.
In each case, the deÔ¨Ånition given in Chapter 7 can be input to the Pointwise Adjointness Theorem and
the output is the adjoint described in the previous section.
This theorem has a simple formulation in terms of the universal elements of Section 5.7, as follows.
9.3.6 Proposition
A functor U : B ‚àí‚ÜíA has a left adjoint if and only if for each object A of A ,
the functor Hom(A, U‚àí) : B ‚àí‚ÜíSet has a universal element.
If b : A ‚àí‚ÜíUB is the universal element, then FA = B and b : A ‚àí‚ÜíUB = UFA is the component at
A of the natural transformation Œ∑ that appears in 9.2.1.
As an example of how this proposition can be used, one can use it to deduce from Proposition 9.1.2
that X 7‚ÜíF(X) is the object map of a left adjoint to the underlying functor U : Mon ‚àí‚ÜíSet. Of course,
we proved this directly in 9.1.3.
9.3.7 Theorem
Let F : A ‚àí‚ÜíB be left adjoint to U : B ‚àí‚ÜíA . Then U preserves limits and F
preserves colimits.
Proof. We sketch the proof that U preserves limits; the details are easy, but the notation is slightly
unpleasant. Recall the deÔ¨Ånition of the cone functor cone(‚àí, D) : C op ‚àí‚ÜíSet from 8.2.6. Then we have,
for a diagram D : I ‚àí‚ÜíB with limit given by a cone V ‚àí‚ÜíD, the following equivalences of contravariant
functors:
cone(‚àí, UD) ‚àº= cone(F‚àí, D) ‚àº= Hom(F‚àí, V ) ‚àº= Hom(‚àí, UV )
which shows that UV is a limit of UD. The Ô¨Årst isomorphism in that equation should be veriÔ¨Åed, since
we extended the isomorphism of Theorem 9.3.2 from the hom functor to the cone functor, but that
veriÔ¨Åcation is straightforward. The second isomorphism follows from the fact that the cone V ‚àí‚ÜíD is a
universal element of cone(‚àí, D), so that cone(‚àí, D) ‚àº= Hom(‚àí, V ). The third isomorphism follows from
Theorem 9.3.2.
The interesting question is the extent to which the converse is true. The basic fact is that the converse
is false. First, the category B may not have enough limits for the condition to be meaningful. The really
interesting case is the one in which every (small) diagram in B has a limit. Even in that case, there is
still what can basically be described as a size problem. To go into this in more detail is beyond the scope
of these notes. The best result is Freyd‚Äôs Adjoint Functor Theorem. See [Barr and Wells, 1985], Section
1.9, Theorem 3, page 54 or [Mac Lane, 1971], Section V.6. Another reference for the Adjoint Functor
Theorem (with a diÔ¨Äerent point of view) is [Freyd and Scedrov, 1990], pages 144‚Äì146.

10. Triples
A triple is a structure which abstracts the idea of adjunction; part of the structure is an endofunctor.
Triples have turned out to be an important technical tool in category theory. Section 10.1 deÔ¨Ånes triples
and gives some of their basic properties. In Section 10.2 we develop the idea of an algebra for a triple;
it is an algebra for the endofunctor part of the triple with certain properties.
10.1 Triples
We now describe a structure based on an endofunctor which has turned out to be an important technical
tool in studying toposes and related topics. It is an abstraction of the concept of adjoint and in a sense
an abstraction of universal algebra (see the remarks in Ô¨Åne print at the end of 10.2.3 below).
10.1.1 Algebras for an endofunctor
Let A be a category and R : A ‚àí‚ÜíA be an endofunctor. An
R-algebra is a pair (A, a) where a : RA ‚àí‚ÜíA is an arrow of A . A homomorphism between R-algebras
(A, a) and (B, b) is an arrow f : A ‚àí‚ÜíB of A such that
RB
B
-
b
RA
A
-
a
?
Rf
?
f
commutes. This construction gives a category (R : A ) of R-algebras.
10.1.2 DeÔ¨Ånition
A triple T = (T, Œ∑, ¬µ) on a category A consists of a functor T : A ‚àí‚ÜíA , together
with two natural transformations Œ∑ : id ‚àí‚ÜíT and ¬µ : T 2 ‚àí‚ÜíT for which the following diagrams commute.
T
=
@
@
@@
R
T
T 2
-
Œ∑T
T
TŒ∑
?
¬µ
=
    	
T 2
T
-
¬µ
T 3
T 2
-
T¬µ
?
¬µT
?
¬µ
(10.1)
Here, Œ∑T and TŒ∑ are deÔ¨Åned as in 5.6.3 and 5.6.4.
The transformation Œ∑ is the unit of the triple and ¬µ is the multiplication. The left diagram consti-
tutes the (left and right) unitary identities and the right one the associative identity. The reason
for these names comes from the analogy between triples and monoids. This will be made clear in 10.1.5.
Another widely used name for triple is ‚Äòmonad‚Äô. However, they have nothing to do with the monads
of Robinson‚Äôs theory of inÔ¨Ånitesimals.
10.1.3 The triple arising from an adjoint pair
An adjoint pair gives rise to a triple on the domain
of the left adjoint.
10.1.4 Proposition
Let U : B ‚àí‚ÜíA and F : A ‚àí‚ÜíB be functors such that F
U with Œ∑ : id
‚àí‚ÜíUF and œµ : FU ‚àí‚Üíid the unit and counit, respectively. Then (UF, Œ∑, UœµF) is a triple on A .
Note that UœµF : UFUF ‚àí‚ÜíUF, as required for the multiplication of a triple with functor UF.
Conversely, every triple arises in that way out of some (generally many) adjoint pair. See Section 10.2
for two ways of constructing such adjoints.
99

100
Triples
10.1.5 Representation triples
Let M be a monoid. The representation triple T = (T, Œ∑, ¬µ) on the
category of sets is given by letting T(S) = M √ó S for a set S. Œ∑S : S ‚àí‚ÜíT(S) = M √ó S takes an element
s ‚ààS to the pair (1, s). We deÔ¨Åne ¬µS by (¬µS)(m1, m2, s) = (m1m2, s) for s ‚ààS, m1, m2 ‚ààM. Thus the
unit and multiplication of the triple arise directly from that of the monoid. The unitary and associativity
equations can easily be shown to follow from the corresponding equations for the monoid.
The standard way of getting this triple from an adjoint pair is by using the underlying and free functors
on M-sets (see 4.2.1). If S and T are M-sets, then a function f : S ‚àí‚ÜíT is said to be M-equivariant if
f(ms) = mf(s) for m ‚ààM, s ‚ààS. For a Ô¨Åxed monoid M, the M-sets and the M-equivariant functions
form a category, called the category of M-sets.
The free M-set generated by the set S is the set M √ó S with action given by m‚Ä≤(m, s) = (m‚Ä≤m, s).
Using Theorem 9.3.5, one can show immediately that this determines a functor left adjoint to the
underlying set functor on the category of M-sets. The triple associated to this adjoint pair is the one
described above.
10.1.6 The Kleene triple
Let T : Set ‚àí‚ÜíSet be the functor which takes a set A to the Kleene closure
A‚àóand a function f : A ‚àí‚ÜíB to the function f ‚àó: A‚àó‚àí‚ÜíB‚àódeÔ¨Åned in Section 2.5.7. Let Œ∑A : A ‚àí‚ÜíA‚àó
take an element a to the one-element string (a), and let ¬µA : A‚àó‚àó‚àí‚ÜíA‚àótake a string (s1, s2, . . . , sk)
of strings to the concatenated string s1s2 ¬∑ ¬∑ ¬∑ sn in A‚àóobtained in eÔ¨Äect by erasing inner brackets: thus
((a, b), (c, d, e), (), (a, a)) goes to
(a, b)(c, d, e)()(a, a) = (a, b, c, d, e, a, a)
In particular, ¬µA((a, b)) = (a, b). Then Œ∑ : id ‚àí‚ÜíT and ¬µ : T
‚ó¶T ‚àí‚ÜíT are natural transformations, and
(T, Œ∑, ¬µ) is a triple.
10.1.7 Cotriples
A cotriple G = (G,œµ,Œ¥) in a category A is a triple in A op. Thus G is an endofunctor
of A and œµ : G ‚àí‚Üíid and Œ¥ : G ‚àí‚ÜíG2 are natural transformations such that
G
G2

œµG
G
-
Gœµ
G
=
    	
?
Œ¥
=
@
@
@@
R
G2
G3
-
GŒ¥
G
G2
-
Œ¥
?
Œ¥
?
Œ¥G
(10.2)
Cotriples are used in Chapter 12.
10.2 Factorizations of a triple
10.2.1 The Kleisli category for a triple
Let T = (T, Œ∑, ¬µ) be a triple on C . We describe here a
construction which exhibits the triple as coming from an adjoint. This construction, which is due to
Kleisli [1965], has proven to be quite useful in theoretical computer science.
We deÔ¨Åne a category K = K (T) which has the same objects as C . If A and B are objects of C ,
then an arrow in K from A to B is an arrow A ‚àí‚ÜíTB in C . The composition of arrows is as follows. If
f : A ‚àí‚ÜíTB and g : B ‚àí‚ÜíTC are arrows in C , we let their composite in K be the following composite
in C :
A
f
‚àí‚àí‚ÜíTB
Tg
‚àí‚àí‚àí‚ÜíT 2C
¬µC
‚àí‚àí‚àí‚ÜíTC
The identity of the object A is the arrow Œ∑A : A ‚àí‚ÜíTA. It can be shown that this deÔ¨Ånes a category.
Moreover, there are functors U : K (T) ‚àí‚ÜíC and F : C ‚àí‚ÜíK (T) deÔ¨Åned by UA = TA and Uf = ¬µB ‚ó¶
Tf, where B is the codomain of f, and FA = A and for g : A ‚àí‚ÜíB, Fg = Tg ‚ó¶Œ∑A. Then F is left
adjoint to U and T = U ‚ó¶F.

10.2 Factorizations of a triple
101
10.2.2 Eilenberg‚ÄìMoore algebras
Here is a second way, due to Eilenberg and Moore [1965] of
factoring every triple as an adjoint pair of functors. In mathematics, this construction has been much
more interesting than the Kleisli construction, but in computer science it has been quite the opposite.
Let T = (T, Œ∑, ¬µ) be a triple on A . A T-algebra (A, a) is called a T-algebra if the following two
diagrams commute:
TA
A
-
a
T 2A
TA
-
¬µA
?
Ta
?
a
A
TA
-
Œ∑A
=
@
@
@@
R
A
?
a
An arrow (homomorphism) between T-algebras is the same as an arrow between the corresponding T-
algebras. With these deÔ¨Ånitions, the T-algebras form a category traditionally denoted A T and called
the category of T-algebras.
There is an obvious underlying functor U : A T ‚àí‚ÜíA with U(A, a) = A and Uf = f. This latter
makes sense because an arrow of A T is an arrow of A with special properties. There is also a functor
F : A ‚àí‚ÜíA T given by FA = (TA, ¬µA) and Ff = Tf. Some details have to be checked; these are
included in the following.
10.2.3 Proposition
The function F above is a functor left adjoint to U. The triple associated to the
adjoint pair F
U is precisely T.
By a theorem of Linton‚Äôs, every equationally deÔ¨Åned category of one-sorted algebraic structures is in fact
equivalent to the category of Eilenberg‚ÄìMoore algebras for some triple in Set ([Barr and Wells, 1985],
Theorem 5 of Section 4.3). In fact, the converse is true if inÔ¨Ånitary operations are allowed (but then a
hypothesis has to be added on the direct part of the theorem that there is only a set of operations of any
given arity).
10.2.4 Example
Let (T, Œ∑, u) be the triple in Set deÔ¨Åned in 10.1.6. An algebra for this triple is a
monoid: speciÔ¨Åcally, if Œ± : T(A) ‚àí‚ÜíA is an algebra, then the deÔ¨Ånition ab = Œ±(a, b) makes A a monoid,
and up to isomorphisms every monoid arises this way. Moreover, algebra homomorphisms are monoid
homomorphisms, and every monoid homomorphism arises this way. The proof requires lengthy but not
diÔ¨Écult veriÔ¨Åcations.
10.2.5 The Kleisli category and free algebras
The Kleisli category of a triple T = (T, Œ∑, ¬µ) is
equivalent to the full subcategory of free T-algebras. Its deÔ¨Ånition makes it clear that the arrows are
substitutions.
As an example, consider the list triple of 10.1.6. An arrow f : A ‚àí‚ÜíB (here A and B are sets) of
the Kleisli category is a set function A ‚àí‚ÜíTB, so that it associates a string of elements of B to each
element of A. Suppose A = {a, b} and B = {c, d, e}, and that f(a) = cddc and f(b) = ec. Then Tf : TA
‚àí‚ÜíTTB takes, for example, the string abba to (cddc)(ec)(ec)(cddc), the result of substituting cddc for a
and ec for b in abba. Then ¬µ takes that string to cddcececcddc. It is instructive in this situation to think
of ¬µ as carrying out a computation. In this case the computation is carried out using the (only) monoid
operation, since in fact the algebras for this triple are monoids. Thus one can think of the objects of
the Kleisli category as computations. This is more compelling if one uses a triple arising from algebraic
structures such as rings that abstract some of the properties of numerical addition and multiplication;
then the objects of the free algebra are polynomial expressions and ¬µ evaluates the polynomial.
An important idea for developing this point of view is the notion of ‚Äòstrong monad‚Äô [Kock, 1972],
which has been developed by Moggi [1989, 1991b] and others [Cockett and Spencer, 1992], [Mulry, 1992].
Other applications of triples (monads) in computing science can be found in the survey [Rydeheard and
Burstall, 1985], as well as [Moggi, 1991a], [Power, 1990], [Wadler, 1989], [L¬®uth and Ghani, 1997] andAdded
ref-
er-
ence
to
[L¬®uth
and
Ghani,
1997]
[Wadler, 1992] (the latter has many references to the literature).

11. Toposes
A topos is a cartesian closed category with some extra structure which produces an object of subob-
jects for each object. This structure makes toposes more like the category of sets than cartesian closed
categories generally are.
Toposes, and certain subcategories of toposes, have proved attractive for the purpose of modeling
computation. A particular reason for this is that in a topos, a subobject of an object need not have
a complement. One of the fundamental facts of computation is that it may be possible to list the
elements of a subset eÔ¨Äectively, but not the elements of its complement (see [Lewis and Papadimitriou,
1981], Theorems 6.1.3 and 6.1.4.). Sets which cannot be listed eÔ¨Äectively do not exist for computational
purposes, and toposes provide a universe of objects and functions which has many nice set-like properties
but which does not force complements to exist. One speciÔ¨Åc subcategory of a topos, the category of
modest sets, has been of particular interest in the semantics of programming languages (see [Barr and
Wells, 1999], Chapter 15).
Toposes have interested mathematicians for other reasons. They are an abstraction of the concept of
sheaf, which is important in pure mathematics. They allow the interpretation of second-order statements
in the category in an extension of the language associated to cartesian closed categories in Chapter 7. This
fact has resulted in toposes being proposed as an alternative to the category of sets for the foundations
of mathematics. Toposes can also be interpreted as categories of sets with an internal system of truth
values more general than the familiar two-valued system of classical logic; this allows an object in a topos
to be thought of as a variable or time-dependent set, or as a set with various degrees of membership. In
particular, most ways of deÔ¨Åning the category of fuzzy sets lead to a category which can be embedded
in a topos (see [Barr, 1986]).
Basic toposes are [Johnstone, 1977], [Barr and Wells, 1985], [Lambek and Scott, 1986], [Bell, 1988],
[McLarty, 1992], [Mac Lane and Moerdijk, 1992]. None of these are aimed at applications to computer
science. The most accessible introduction to the language and logic associated to a topos is perhaps
that of [McLarty, 1992], Chapter 12. Other discussions of the language and the relation with logic are
in [Makkai and Reyes, 1977], [Fourman, 1977], [Fourman and Vickers, 1986], [Boileau and Joyal, 1981].
The texts [Makkai and Reyes, 1977] and [Freyd and Scedrov, 1990] discuss toposes and also more general
classes of categories that have a rich logical structure. The use of toposes speciÔ¨Åcally for semantics is
discussed in [Hyland, 1982], [Hyland and Pitts, 1989], [Vickers, 1992].
11.1 DeÔ¨Ånition of topos
11.1.1 The subobject functor
Recall from 3.3.12 that if C is an object of a category, a subobject
of C is an equivalence class of monomorphisms C0 )‚àí‚ÜíC where f0 : C0 )‚àí‚ÜíC is equivalent to f1 : C1
)‚àí‚ÜíC if and only if there are arrows (necessarily isomorphisms) g : C0 ‚àí‚ÜíC1 and h : C1 ‚àí‚ÜíC0 such that
f1 ‚ó¶g = f0 and f0 ‚ó¶h = f1.
Assuming the ambient category C has pullbacks, the ‚Äòset of subobjects‚Äô function is the object function
of a functor Sub : C op ‚àí‚ÜíSet: precisely, for an object C, Sub(C) is the set of subobjects of C. We must
deÔ¨Åne Sub on arrows.
If k : C‚Ä≤ ‚àí‚ÜíC is an arrow and if f0 : C0 )‚àí‚ÜíC represents a subobject of C, then in a pullback
C‚Ä≤
C
-
k
C‚Ä≤
0
C0
-
k0
?
?
f ‚Ä≤
0
?
?
f0
(11.1)
the arrow f ‚Ä≤
0 is also a monomorphism (see 8.3.4).
It is left as an exercise to prove, using the universal mapping property of pullbacks, that if the
monomorphism f0 : C0 )‚àí‚ÜíC is equivalent to f1 : C1 )‚àí‚ÜíC, then the pullbacks f ‚Ä≤
0 : C‚Ä≤
0 )‚àí‚ÜíC‚Ä≤ and f ‚Ä≤
1 : C‚Ä≤
1
102

11.1 DeÔ¨Ånition of topos
103
)‚àí‚ÜíC‚Ä≤ are also equivalent. Thus not only is a pullback of a monomorphism a monomorphism, but also
a pullback of a subobject is a subobject.
Thus we can deÔ¨Åne, for an arrow k as above,
Sub(k) : Sub(C) ‚àí‚ÜíSub(C‚Ä≤)
to be the function that sends the equivalence class containing f0 to the equivalence class containing the
pullback f ‚Ä≤
0.
To show that this is a functor, we must show that the identity arrow induces the identity arrow on
subobjects (exercise) and that if k‚Ä≤ : C‚Ä≤‚Ä≤ ‚àí‚ÜíC‚Ä≤, then the diagram
Sub(C)
Sub(C‚Ä≤)
-
Sub(k)
Sub(k ‚ó¶k‚Ä≤)
@
@
@
@
@
@
@
R
Sub(C‚Ä≤‚Ä≤)
?
Sub(k‚Ä≤)
commutes. But the commutativity of this diagram at the subobject represented by f0 is equivalent to
the outer rectangle of the diagram
C‚Ä≤‚Ä≤
C‚Ä≤
-
-
k‚Ä≤
C‚Ä≤‚Ä≤
0
C‚Ä≤
0
-
-
k‚Ä≤
0
?
f ‚Ä≤‚Ä≤
0
?
f ‚Ä≤
0
C
-
-
k
C0
-
-
k0
?
f0
being a pullback when the two smaller squares are, which is easily veriÔ¨Åed.
11.1.2 DeÔ¨Ånition
A topos is a category which
TOP‚Äì1 has Ô¨Ånite limits;
TOP‚Äì2 is cartesian closed;
TOP‚Äì3 has a representable subobject functor.
We know that a functor is representable if and only if it has a universal element (see 5.7.12). A
universal element of the subobject functor is an object, usually called ‚Ñ¶, and a subobject ‚Ñ¶0 ‚äÜ‚Ñ¶such
that for any object A and subobject A0 ‚äÜA, there is a unique arrow œá : A ‚àí‚Üí‚Ñ¶such that there is a
pullback
‚Ñ¶0
‚Ñ¶
-
-
A0
A
-
-
?
?
œá
It can be proved that ‚Ñ¶0 is the terminal object and the left arrow is the unique arrow from A0 ([Barr
and Wells, 1985], Proposition 4 of Section 2.3).
The object ‚Ñ¶is called the subobject classiÔ¨Åer and the arrow from ‚Ñ¶0 = 1 ‚àí‚Üí‚Ñ¶is usually denoted
true. The arrow œá corresponding to a subobject is called the characteristic arrow of the subobject.
The fact that the subobject functor is represented by ‚Ñ¶means precisely that there is a natural
isomorphism
œÜ : Sub(‚àí) ‚àí‚ÜíHom(‚àí, ‚Ñ¶)
which takes a subobject to its characteristic function.

104
Toposes
11.1.3 Example
The category of sets is a topos. It was shown in 7.1.9 that sets are a cartesian closed
category. A two-element set, which we call 2, is a subobject classiÔ¨Åer. In fact, call the two elements true
and false. Given a set S and subset S0 ‚äÜS, deÔ¨Åne the characteristic function œá : S ‚àí‚Üí{true, false} by
œá(x) =
 true
if x ‚ààS0
false
if x /‚ààS0
Then the following square (where the top arrow is inclusion) is a pullback:
1
2
-
true
S0
S
-
-
?
?
œá
Thus 2 is a subobject classiÔ¨Åer.
11.2 Properties of toposes
We list here some of the properties of toposes, without proof.
11.2.1
In the Ô¨Årst place, a topos is not only cartesian closed, it is ‚Äúlocally cartesian closed‚Äù (meaning
that every slice is cartesian closed ‚Äî this is described in detail in [Barr and Wells, 1999], Section 13.4).
This is Corollary 1.43, p. 36 of [Johnstone, 1977], Corollary 7, p. 182 of [Barr and Wells, 1985] or
section 17.2 of [McLarty, 1992].
11.2.2 Power objects
In any topos, the object [A ‚àí‚Üí‚Ñ¶] has the property that
Hom(B, [A ‚àí‚Üí‚Ñ¶]) ‚àº= Hom(A √ó B, ‚Ñ¶) ‚àº= Sub(A √ó B)
(11.2)
These isomorphisms are natural when the functors are regarded as functors of either A or of B. (One of
them appears, for Set, in Example 5.3.8.) The object [A ‚àí‚Üí‚Ñ¶] is often called the power object of A
and denoted PA. It is the topos theoretic version of the powerset of a set. Theorem 1 of Section 5.4 of
[Barr and Wells, 1985] implies that a category with Ô¨Ånite limits is a topos if for each object A there is a
power object that satisÔ¨Åes (11.2).
The inverse image and universal image constructions in 9.2.8 for the powerset of a set can be made
on [A ‚àí‚Üí‚Ñ¶] for any object A in a topos. The left and right adjoints of the pullback functors (they exist
because any topos is locally cartesian closed) are related to these images via the diagram in [Johnstone,
1977], Proposition 5.29; this diagram is called the ‚Äòdoctrinal diagram‚Äô and is the basis for introducing
elementary (Ô¨Årst order) logic into a topos.
11.2.3 EÔ¨Äective equivalence relations
Let d, e : E ‚àí‚Üí
‚àí‚ÜíA be two arrows in a category. For any
object B we have a single function
‚ü®Hom(B, d), Hom(B, e)‚ü©: Hom(B, E) ‚àí‚ÜíHom(B, A) √ó Hom(B, A)
which sends f to the pair (d ‚ó¶f,e ‚ó¶f). If this function is, for each object B, an isomorphism of Hom(B,E)
with an equivalence relation on the set Hom(B, A), then we say that E is an equivalence relation on
the object A. This means that the image of ‚ü®Hom(B, d), Hom(B, e)‚ü©is actually an equivalence relation
on Hom(B, A).
This can be thought of as embodying two separate conditions. In the Ô¨Årst place, the function
‚ü®Hom(B,d),Hom(B,e)‚ü©must be an injection, because we are supposing that it maps Hom(B,E) isomor-
phically to a subset of Hom(B, A) √ó Hom(B, A). Secondly, that subset must satisfy the usual reÔ¨Çexivity,
symmetry and transitivity conditions of equivalence relations.

11.2 Properties of toposes
105
11.2.4 Kernel pairs
Here is one case in which this condition is automatic. If g : A ‚àí‚ÜíC is an arrow,
the pullback of the square
A
C
-
g
E
A
-
d
?
e
?
g
is called a kernel pair of g. Notation: we will write that
E
d
‚àí‚àí‚Üí
‚àí‚àí‚Üí
e
A
g
‚àí‚àí‚ÜíC
is a kernel pair. For an object B of C , the deÔ¨Ånition of this limit is that there is a one to one correspon-
dence between arrows B ‚àí‚ÜíE and pairs of arrows (h, k) from B to A such that g ‚ó¶h = g ‚ó¶k and that
the correspondence is got by composing an arrow from B to E with d and e, resp. To put it in other
words, Hom(B, E) is isomorphic to
{(h, k) ‚ààHom(B, A) √ó Hom(B, A) | g ‚ó¶h = g ‚ó¶k}
which is an equivalence relation.
11.2.5
Suppose that E ‚àí‚Üí
‚àí‚ÜíA describes an equivalence relation. We say that the equivalence relation
is eÔ¨Äective if it is a kernel pair of some arrow from A. We say that a category has eÔ¨Äective equiva-
lence relations if every equivalence relation is eÔ¨Äective. We give the following without proof. The
interested reader may Ô¨Ånd the proof in [Barr and Wells, 1985] Theorem 7 of Section 2.3, [Johnstone,
1977], Proposition 1.23, p. 27, or [McLarty, 1992], Section 16.7.
11.2.6 Theorem
In a topos, every equivalence relation is eÔ¨Äective.
11.2.7 Example
Equivalence relations in the categories Set and Mon are eÔ¨Äective. An equivalence
relation in Set is simply an equivalence relation, and the class map to the quotient set is a function
that has the equivalence relation as kernel pair. An equivalence relation on a monoid M in Mon is a
congruence relation on M; it is eÔ¨Äective because a monoid multiplication can be deÔ¨Åned on the quotient
set of the congruence relation that makes the quotient map a homomorphism.
There are many categories which lack eÔ¨Äective equivalence relations. One is the category of partially
ordered sets and monotone maps. Here is a simple example. Let C be a two-element chain x < y. Consider
the subset E of C √ó C consisting of all four pairs (x, x), (x, y), (y, x) and (y, y). The only ordering is
that (x, x) ‚â§(y, y). Then E is an equivalence relation, but is not the kernel pair of any arrow out of
C. The least kernel pair that includes E has the same elements as E, but has the additional orderings
(x, x) ‚â§(x, y) ‚â§(y, y) and (x, x) ‚â§(y, x) ‚â§(y, y).
Other important properties of toposes are contained in the following.
11.2.8 Theorem
Let E be a topos.
(a) E has Ô¨Ånite colimits.
(b) E has Ô¨Ånite disjoint and universal sums.
(c) Every epi in E is regular, and E is a regular category.
An early proof of the fact that a topos has Ô¨Ånite colimits ([Mikkelson, 1976]) mimicked the construction in
sets. For example, the coequalizer of two arrows was constructed as a set of subsets, which can be identiÔ¨Åed
as the set of equivalence classes mod the equivalence relation generated by the two arrows. However, the
argument is diÔ¨Écult. The modern proof (due to Par¬¥e) is much easier, but it involves some legerdemain with
triples and it is hard to see what it is actually doing. See [Barr and Wells, 1985], Corollary 2 of 5.1 for the
latter proof. The rest is found in 5.5 of the same source.

106
Toposes
11.2.9 The initial topos
There is an Ô¨Ånite-limit theory whose models are toposes. (See [Barr and
Wells, 1985], Section 4.4. In that book, FL theories are called LE theories.) It follows that there is an
initial model of the topos axioms. This topos lacks a natural numbers object. It might be an interesting
model for a rigidly Ô¨Ånitistic model of computation, but would not allow the modeling of such things as
recursion.
The phrase ‚Äòinitial topos‚Äô is usually reserved for the initial model of the axioms for toposes with a
natural numbers object (See Section 5.5 of [Barr and Wells, 1999]). This category provides an interesting
model for computation. The arrows from N to N in that category are, not surprisingly, the total recursive
functions. In fact, all partial recursive functions are modeled in there as well, but as partial arrows, which
we now describe.
11.2.10 Partial arrows
In 2.1.13 we discussed partial functions between sets. This concept can be
extended to any category. Let A and B be objects. A partial arrow A to B consists of a subobject A0 ‚äÜA
and an arrow f : A0 ‚àí‚ÜíB. This deÔ¨Ånes the partial arrow f in terms of a particular representative A0
‚àí‚ÜíA of the subobject, but given any other representative A‚Ä≤
0 ‚àí‚ÜíA, there is a unique arrow from A‚Ä≤
0 to
A0 commuting with the inclusions which determines an arrow from A‚Ä≤
0 to B by composition with f. The
subobject determined by A0 is called the domain of the partial arrow. If g : A1 ‚àí‚ÜíB is another partial
arrow on A we say the f ‚â§g if A0 ‚äÜA1 and the restriction of g to A0 is f. If we let i : A0 ‚àí‚ÜíA1 denote
the inclusion arrow, then the second condition means simply that g ‚ó¶i = f. We will say that f and g are
the same partial arrow if both f ‚â§g and g ‚â§f. This means that the domains of f and g are the same
subobject of A and that f and g are equal on that domain.
We say that partial arrows to B are representable if there is an object eB and an embedding B
)‚àí‚ÜíeB such that there is a one to one correspondence between arrows A ‚àí‚ÜíeB and partial arrows A to
B, the correspondence given by pulling back:
B
eB
-
A0
A
-
?
?
In a topos, the arrow true: 1 ‚àí‚Üí‚Ñ¶represents partial functions to 1. The reason is that since each object
has a unique arrow to 1, a partial arrow from A to 1 is equivalent to a subobject of A.
11.2.11 Theorem
In a topos, partial arrows into any object are representable.
See [Johnstone, 1977], Section 1.26 or [McLarty, 1992], Section 17.1 for the proof.
11.3 Presheaves
11.3.1 DeÔ¨Ånition
Let C be a category. A functor E : C op ‚àí‚ÜíSet is called a presheaf on C . Thus a
presheaf on C is a contravariant functor. The presheaves on C with natural transformations as arrows
forms a category denoted Psh(C ).
We considered presheaves as actions in Section 3.2. They occur in other guises in the categorical and
computer science literature, too. For example, a functor F : A ‚àí‚ÜíSet, where A is a set treated as a
discrete category, is a ‚Äòbag‚Äô of elements of A. If a ‚ààA, the set F(a) denotes the multiplicity to which a
occurs in A. See [Taylor, 1989] for an application in computing science.
11.3.2 Proposition
The category of presheaves on a category C form a topos.
The proof may be found in [Barr and Wells, 1985] Section 2.1, Theorem 4. That proof uses a diÔ¨Äerent,
but equivalent, deÔ¨Ånition of topos.

11.4 Sheaves
107
11.3.3 Example
Consider the category we will denote by 0 ‚àí‚Üí
‚àí‚Üí1. It has two objects and four arrows,
two being the identities. A contravariant set-valued functor on this category is a pair of objects G0 and
G1 and a pair of arrows we will call source, target : G1 ‚àí‚ÜíG0. The two identities are sent to identities.
Thus the category of presheaves on this category is the category of graphs, which is thereby a topos.
We described the exponential object for graphs in 7.1.12. It is instructive to see what the subobject
classiÔ¨Åer is. We have to Ô¨Ånd a graph ‚Ñ¶and an arrow true : 1 ‚àí‚Üí‚Ñ¶such that for any graph G and
subgraph G0 ‚äÜG , there is a unique graph homomorphism œá : G ‚àí‚Üí‚Ñ¶such that the diagram
1
‚Ñ¶
-
true
G0
G
-
-
?
?
œá
commutes.
We deÔ¨Åne the graph ‚Ñ¶as follows. It has Ô¨Åve arrows we will call ‚Äòall‚Äô, ‚Äòsource‚Äô, ‚Äòtarget‚Äô, ‚Äòboth‚Äô and
‚Äòneither‚Äô. The reason for these names should become clear shortly. It has two nodes we will call ‚Äòin‚Äô and
‚Äòout‚Äô. The arrows ‚Äòall‚Äô and ‚Äòboth‚Äô go from ‚Äòin‚Äô to itself, ‚Äòneither‚Äô goes from ‚Äòout‚Äô to itself. The arrow
‚Äòsource‚Äô goes from ‚Äòin‚Äô to ‚Äòout‚Äô and ‚Äòtarget‚Äô from ‚Äòout‚Äô to ‚Äòin‚Äô. The terminal graph, which has one arrow
and one node, is embedded by the function true that takes the arrow to ‚Äòall‚Äô and the node to ‚Äòin‚Äô.
Now given a graph G and a subgraph G0 we deÔ¨Åne a function œá : G ‚àí‚Üí‚Ñ¶as follows. For a node n
of G , œá(n) is ‚Äòin‚Äô or ‚Äòout‚Äô, according to whether n is in G0 or not. For an arrow a, we let œá(a) be ‚Äòall‚Äô if
a ‚ààG0 (whence its source and target are as well). If not, there are several possibilities. If the source but
not the target of a belongs to G0, then œá(a) =‚Äòsource‚Äô. Similarly, if the target but not the source is in
G0, it goes to ‚Äòtarget‚Äô. If both the source and target are in it, then œá(a) =‚Äòboth‚Äô and if neither is, then
it goes to ‚Äòneither‚Äô.
11.4 Sheaves
The general deÔ¨Ånition of sheaves requires a structure on the category called a Grothendieck topology.
The most accessible and detailed discussion of Grothendieck topologies is that of [Mac Lane and Moerdijk,
1992]. Here we will discuss the special case of sheaves in which the category is a partial order.
11.4.1
Let P be a partially ordered set. From the preceding section, a presheaf E on P assigns to
each element x ‚ààP a set E(x) and whenever x ‚â§y assigns a function we will denote E(x, y) : E(y)
‚àí‚ÜíE(x) (note the order; x precedes y, but the arrow is from E(y) to E(x)). This is subject to two
conditions. First, that E(x, x) be the identity function on E(x) and second that when x ‚â§y ‚â§z, that
E(x, y) ‚ó¶E(y, z) = E(x, z). The arrows E(x, y) are called restriction functions.
11.4.2 Heyting algebras
We make the following supposition about P.
HA‚Äì1 There is a top element, denoted 1, in P.
HA‚Äì2 Each pair of elements x, y ‚ààP has an inÔ¨Åmum, denoted x ‚àßy.
HA‚Äì3 Every subset {xi} of elements of P has a supremum, denoted W xi.
HA‚Äì4 For every element x ‚ààP and every subset {xi} ‚äÜP, x ‚àß(W xi) = W(x ‚àßxi).
A poset that satisÔ¨Åes these conditions is called a complete Heyting algebra. Complete Heyting
algebras have an operation corresponding to implication: Let H be a complete Heyting algebra. DeÔ¨Åne
the binary operation ‚áí: H √ó H ‚àí‚ÜíH by requiring that a ‚áíb is the join of all elements c for which
a ‚àßc ‚â§b. Then a ‚àßc ‚â§b if and only if c ‚â§a ‚áíb. When H is regarded as a category in the usual way,
it is cartesian closed with ‚áías internal hom.

108
Toposes
11.4.3
If {xi} is a subset with supremum x, and E is a presheaf, there is given a restriction function
ei : E(x) ‚àí‚ÜíE(xi) for each i. The universal property of product gives a unique function e : E(x) ‚àí‚Üí
Q
i E(xi) such that pi ‚ó¶e = ei. In addition, for each pair of indices i and j, there are functions cij : E(xi)
‚àí‚ÜíE(xi ‚àßxj) and dij : E(xj) ‚àí‚ÜíE(xi ‚àßxj) induced by the relations xi ‚â•xi ‚àßxj and xj ‚â•xi ‚àßxj. This
gives two functions c, d : Q
i E(xi) ‚àí‚ÜíQ
ij E(xi ‚àßxj) such that
E(xi)
E(xi ‚àßxj)
-
cij
Q
i E(xi)
Q
ij E(xi ‚àßxj)
-
c
?
pi
?
pij
and
E(xi)
E(xi ‚àßxj)
-
dij
Q
i E(xi)
Q
ij E(xi ‚àßxj)
-
d
?
pi
?
pij
commute.
11.4.4 DeÔ¨Ånition
A presheaf is called a sheaf if it satisÔ¨Åes the following additional condition:
x =
_
xi
implies
E(x)
e
‚àí‚Üí
Y
i
E(xi)
c
‚àí‚àí‚Üí
‚àí‚àí‚Üí
d
Y
ij
E(xi ‚àßxj)
is an equalizer.
11.4.5 Theorem
The category of sheaves on a Heyting algebra is a topos.
As a matter of fact, the category of sheaves for any Grothendieck topology is a topos (see any of the
texts [Johnstone, 1977], [Barr and Wells, 1985], [Mac Lane and Moerdijk, 1992], [McLarty, 1992]).
11.4.6 Constant sheaves
A presheaf E is called constant if for all x ‚ààP, E(x) is always the same
set and for all x ‚â§y, the function E(y, x) is the identity function on that set.
The constant presheaf at a one-element set is always a sheaf. This is because the sheaf condition
comes down to a diagram
1 ‚àí‚Üí1 ‚àí‚Üí
‚àí‚Üí1
which is certainly an equalizer. No constant presheaf whose value is a set with other than one element
can be a sheaf. In fact, the 0 (bottom) element of P is the supremum of the empty set and the product
of the empty set of sets is a one-element set (see 6.3.6). Hence the sheaf condition on a presheaf E is
that
E(0) ‚àí‚Üí
Y
‚àÖ
‚àí‚Üí
‚àí‚Üí
Y
‚àÖ
which is
E(0) ‚àí‚Üí1 ‚àí‚Üí
‚àí‚Üí1
and this is an equalizer if and only if E(0) = 1.

11.4 Sheaves
109
11.4.7
A presheaf is said to be nearly constant if whenever 0 < x ‚â§y in P, the restriction E(y)
‚àí‚ÜíE(x) is an isomorphism. It is interesting to inquire when a nearly constant presheaf is a sheaf. It
turns out that every nearly constant presheaf over P is a sheaf over P if and only if the meet of two
nonzero elements of P is nonzero.
To see this, suppose E is a nearly constant presheaf whose value at any x Ã∏= 0 is S and that x = W xi.
In the diagram
E(x) ‚àí‚Üí
Y
E(xi) ‚àí‚Üí
‚àí‚Üí
Y
E(xi ‚àßxj)
every term in which xi = 0 contributes nothing to the product since 1 √ó Y ‚àº= Y . An element of the
product is a string {si} such that si ‚ààS. The condition of being an element of the equalizer is the
condition that the image of si under the induced function E(xi) ‚àí‚ÜíE(xi ‚àßxj) is the same as the image
of sj under E(xj) ‚àí‚ÜíE(xi ‚àßxj). But in a nearly constant sheaf, all these sets are the same and all the
functions are the identity, so this condition is simply that si = sj. But this means that an element of the
equalizer must be the same in every coordinate, hence that diagram is an equalizer.
11.4.8 Interpretation of sheaves
Let E be a sheaf on P. The reader will want to know how E is to
be interpreted. Start by thinking of P as an algebra of truth values. Whereas propositions (assertions) in
ordinary logic are either true or false (so that ordinary logic is often called 2-valued), in P-valued logic,
the truth of an assertion is an element of P. In the next section, we will use this idea to discuss time
sheaves in which propositions can be true at some times and not at others. If p is some proposition, let
us write [[p]] to denote the element of P that is the truth value.
A sheaf E is a set in this logic. For x ‚ààP, the (ordinary) set E(x) could, as a Ô¨Årst approximation, be
thought of as the set of all entities a for which [[a ‚ààE]] is at least x. If y < x, then [[a ‚ààE]] ‚â•x implies
that [[a ‚ààE]] ‚â•y so that E(x) ‚äÜE(y). This is only a Ô¨Årst approximation and what we have described
is actually a P-valued fuzzy set (see Section 15.6 of [Barr and Wells, 1999]). The reason is that equality
is also a predicate and it may happen, for example, that [[a = b]] could lie between x and y so that the
entities a and b are not discernably equal at level x, but are equal at level y. The result is that rather
than an inclusion, we have a restriction function E(x) ‚àí‚ÜíE(y) for y ‚â§x.
11.4.9 Time sheaves, I
Here is a good example of a topos in which one can see that the restriction
arrows should not be expected to be injective. Consider the partially ordered set whose elements are
intervals on the real line with inclusion as ordering. It is helpful to think of these as time intervals.
Now consider any deÔ¨Ånition of a naive set. Some possible deÔ¨Ånitions will be time invariant, such as
the set of mathematical statements about, say, natural numbers, that are true. Others of these ‚Äòsets‚Äô
change with time; one example might be the set of all books that are currently in print; another the
set of statements currently known to be true about the natural numbers. These may conveniently be
thought of as the presheaves whose value on some time interval is the set of books that were in print
over the entire interval and the set of statements about natural numbers known to be true during that
entire interval. The restriction to a subinterval is simply the inclusion of the set of books in print over
the whole interval to that (larger) set of those in print over that subinterval or the restriction of the
knowledge from the interval to the subinterval. In this example, the restrictions are injective.
Instead of books in print, we could take the example of businesses in operation. Because of the
possibility of merger, divestment and the like, two businesses which are actually distinct over a large
interval might coincide over a smaller subinterval. Thus for this example of a ‚Äúset‚Äù, the restriction
function is not injective in general.
Another situation in which the restriction functions are not necessarily injective arises from the set
of variables in a block-structured programming language. The presheaf is this: the set for a certain time
interval during the running of the program is the quotient of the set of variables which exist over the
whole time interval, modulo the equivalence relation that identiÔ¨Åes two variables in an interval if they
should happen to have the same value over the whole interval. Two variables may not be equivalent over
a large interval, whereas they may be equivalent over a smaller one; in that case the restriction function
would not be injective.
In general, any property describes the set of all entities that have that property over the entire
interval. The restriction to a subinterval arises out of the observation that any entity that possesses a
property over an interval possesses it over any subinterval.

110
Toposes
The sheaf condition in this case reduces to this: if the interval I is a union of subintervals Ik (where
k ranges over an index set which need not be countable) and an entity possesses that property over
every one of the subintervals Ik, then it does over the whole interval. This condition puts a deÔ¨Ånite
restriction on the kinds of properties that can be used. For example, the property of being grue, that is
blue over the Ô¨Årst half of the interval and green on the second half, is not allowed. The properties that
are allowed are what might be called local, that is true when they are true in each suÔ¨Éciently small
interval surrounding the point in time. This statement is essentially a tautology, but it does give an idea
of what the sheaf condition means.
11.4.10 Time sheaves, II
Here is another topos, rather diÔ¨Äerent from the one above, that might also
be considered to be time sheaves. Unlike the one above which is symmetric to forward and reverse time,
this one deÔ¨Ånitely depends on which way time is Ô¨Çowing. This is not to say that one is better or worse,
but they are diÔ¨Äerent and have diÔ¨Äerent purposes. In this one, the elements of the Heyting algebra are
the times themselves. In other words, we are looking at time indexed sets, as opposed to sets indexed by
time intervals.
We order this set by the reverse of the usual order. So a presheaf in this model is a family {X(t)} of
sets, t a real number, together with functions f(s,t) : X(t) ‚àí‚ÜíX(s) for t ‚â§s, subject to the condition that
f(t, t) is the identity and f(r, s) ‚ó¶f(s, t) = f(r, t) for t ‚â§s ‚â§r. The sheaf condition of DeÔ¨Ånition 11.4.4
is a bit technical, but can easily be understood in the special case of a presheaf all of whose transition
arrows f(s, t) are inclusions. In that case, the condition is that when t = V ti (so that t is the greatest
lower bound of the ti), then X(t) = T X(ti).
An example, which might be thought typical, of such a sheaf might be described as the ‚Äòsheaf of states
of knowledge‚Äô. At each time t we let X(t) denote the set of all things known to the human race. On the
hypothesis (which might be disputed) that knowledge is not lost, we have a function X(t) ‚àí‚ÜíX(s) for
t ‚â§s. In common parlance, we might consider this function to be an inclusion, or at least injective, but
it is possible to modify it in various ways that will render it not so. We might introduce an equivalence
relation on knowledge, so that two bits of knowledge might be considered the same. In that case, if at
some future time we discover two bits of knowledge the same, then bits not equal at one time become
equal at a later time and the transition arrow is not injective.
For example, consider our knowledge of the set of complex numbers. There was a time in our history
when all the numbers e, i, œÄ and ‚àí1 were all known, but it was not known that eiœÄ = ‚àí1. In that case,
the number eiœÄ and ‚àí1 were known separately, but not the fact that they were equal. See [Barr, McLarty
and Wells, 1985]. The sheaf condition is this: if {ti} is a set of times and t is their inÔ¨Åmum, then anything
known at time ti for every i is known at time t.

12. Categories with
monoidal structure
Many of the categories that arise in computer science (and elsewhere) have a binary operation on objects
and arrows. This operation is rarely actually associative, but is usually assumed associative up to natural
isomorphism and subject to certain coherence laws as we will explain. We also suppose there is a unit
object, which is not actually a unit, but is so up to a natural coherent isomorphism. Since the associativity
and existence of a unit characterize monoids, these categories are called monoidal.
This chapter may be read immediately after Chapter 9.
12.1 Closed monoidal categories
12.1.1 DeÔ¨Ånition
A monoidal category is a category C equipped with an object ‚ä§and a functor
‚äó: C √óC ‚àí‚ÜíC . We use inÔ¨Åx notation so that the value at (A,B) is written A‚äóB. A monoidal category
must have, in addition, the natural isomorphisms a, r and l for all objects A, B and C listed in MC‚Äì1
through MC‚Äì3 below, and these must make Diagrams MC‚Äì5 and MC‚Äì6 commute. The category is a
symmetric monoidal category if in addition it has the natural isomorphism SMC‚Äì4 and the diagrams
SMC‚Äì7 through SMC‚Äì9 commute.
MC‚Äì1 a(A, B, C) : A ‚äó(B ‚äóC) ‚àí‚Üí(A ‚äóB) ‚äóC;
MC‚Äì2 rA : A ‚äó‚ä§‚àí‚ÜíA;
MC‚Äì3 lA : ‚ä§‚äóA ‚àí‚ÜíA.
SMC‚Äì4 s(A, B) : A ‚äóB ‚àí‚ÜíB ‚äóA.
MC‚Äì5
A ‚äó(‚ä§‚äóB)
(A ‚äó‚ä§) ‚äóB
-
a(A, ‚ä§, B)
A ‚äóB
A ‚äól(B)
@
@
@
@
@
R
r(A) ‚äóB
     	
MC‚Äì6
A ‚äó((B ‚äóC) ‚äóD)
(A ‚äóB) ‚äó(C ‚äóD)
A ‚äó(B ‚äó(C ‚äóD))
A ‚äóa(B, C, D)
       	
a(A, B, C ‚äóD)
@
@
@
@
@
@@
R
(A ‚äó(B ‚äóC)) ‚äóD
((A ‚äóB) ‚äóC) ‚äóD
-
a(A, B, C) ‚äóD
?
a(A, B ‚äóC, D)
?
a(A ‚äóB, C, D)
SMC‚Äì7
A ‚äóB
B ‚äóA
-
s(A, B)
A ‚äóB
id
@
@
@@
R
s(B, A)
    	
111

112
Categories with monoidal structure
SMC‚Äì8
A ‚äó‚ä§
‚ä§‚äóA
-
s(A, ‚ä§)
A
r(A)
@
@
@@
R
l(A)
    	
SMC‚Äì9
A ‚äó(C ‚äóB)
C ‚äó(A ‚äóB)
A ‚äó(B ‚äóC)
(A ‚äóB) ‚äóC
-
a(A, B, C)
?
A ‚äós(B, C)
?
s(A ‚äóB, C)
(A ‚äóC) ‚äóB
(C ‚äóA) ‚äóB
-
s(A, C) ‚äóB
?
a(A, C, B)
?
a(C, A, B)
Each of the diagrams listed above asserts the commutativity of a diagram formed by composing
isomorphisms built from instances of ‚äó, a, r and l (and s in the symmetric case). These diagrams are
chosen to be the axioms because assuming that they commute implies that any two parallel isomorphisms,
provided that they are constructed from ‚äó, a, r and l and s using ‚äóand composition, are the same. A
precise statement of this fact is in Chapter VII.2 of [Mac Lane, 1971].
In any monoidal category C , there is a functor A ‚äó‚àí: C ‚àí‚ÜíC that takes B to A ‚äóB and f : B
‚àí‚ÜíC to A ‚äóf : A ‚äóB ‚àí‚ÜíA ‚äóC.
12.1.2 DeÔ¨Ånition
A monoidal category C is said to be closed if for each object A of C , the functor
A ‚äó‚àíhas a right adjoint.
If we denote the value at C of the right adjoint by A ‚àí‚ó¶C (A appears as a parameter since this is
deÔ¨Åned for each object A), then the deÔ¨Åning condition is an isomorphism, natural in B and C,
Hom(A ‚äóB, C)
‚àº=
‚àí‚àí‚ÜíHom(B, A ‚àí‚ó¶C)
(12.1)
In the symmetric case, it follows that
Hom(A ‚äóB, C) ‚àº= Hom(A, B ‚àí‚ó¶C)
In general, the latter isomorphism fails in the non-symmetric case; there we may want to suppose that
there is, for each B a functor C 7‚ÜíC ‚ó¶‚àíB such that Hom(A ‚äóB, C) ‚àº= Hom(A, C ‚ó¶‚àíB). We will not
explore this point further, but will suppose from now on that our monoidal structure is symmetric.
12.1.3 Example
A category that has Ô¨Ånite products is automatically a symmetric monoidal category,
using the categorical product for ‚äóand the terminal object for ‚ä§. The various isomorphisms can be
constructed using the universal mapping property of products. For example, a(A,B,C) : A√ó(B √óC) ‚àí‚Üí
(A √ó B) √ó C is the map that is denoted ‚ü®‚ü®proj1, proj1 ‚ó¶proj2‚ü©, proj2 ‚ó¶proj2‚ü©(see 6.2.9 for an explanation
of this notation). The coherence is also automatic, essentially because of the uniqueness of the universal
mappings. In Diagram MC‚Äì6, for example, both paths give the map
‚ü®‚ü®‚ü®p1, p1 ‚ó¶p2‚ü©, p1 ‚ó¶p2 ‚ó¶p2‚ü©, p2 ‚ó¶p2 ‚ó¶p2‚ü©: A √ó (B √ó (C √ó D))
‚àí‚Üí((A √ó B) √ó C) √ó D
where we have written p instead of proj.
Cartesian closed categories are, of course, just monoidal closed categories in which the product is the
cartesian product. Thus any cartesian closed category is monoidal closed, but there are many others.

12.1 Closed monoidal categories
113
A category with Ô¨Ånite sums is also monoidal, using the sum for ‚äóand the initial object for ‚ä§. The
veriÔ¨Åcation is essentially the same as for the case of products. Set (and many other categories with both
products and sums) is therefore an example of a category with two inequivalent monoidal structures on
it.
12.1.4 Example
In 2.1.14, we constructed the category Rel of relations, whose objects are sets S,
T, . . . , and in which an arrow S ‚àí‚ÜíT is a subset Œ± ‚äÜS √ó T. The cartesian product of sets is not
the product in this category ‚Äì the disjoint sum is both sum and product ‚Äì but it is a functor of two
variables, that is a monoidal structure on Rel. We will denote it S ‚äóT to avoid confusion with the
categorical product. An arrow S ‚äóT ‚àí‚ÜíU in this category is a subset of (S ‚äóT) ‚äóU ‚àº= T ‚äó(S ‚äóU).
Thus Hom(S ‚äóT, U) ‚àº= Hom(T, S ‚äóU). Thus Rel is a closed monoidal category with S ‚àí‚ó¶T = S ‚äóT.
Observe that this is an example of a closed monoidal category in which A ‚àí‚ó¶B is not a structure
built on Hom(A, B): A ‚àí‚ó¶B = A ‚äóB is the cartesian product (in Set, not Rel!) of A and B, whereas
Hom(A, B) is the powerset of that cartesian product.
We return to this example in Example 12.3.3.
12.1.5 Subsets of a monoid
Here is an example that is a poset viewed as a category. Let M be
a monoid and C denote the category whose objects are the subsets of M with inclusions as the only
morphisms. If A and B are subsets of M, let A ‚äóB = {ab | a ‚ààA and b ‚ààB}. DeÔ¨Åne A ‚àí‚ó¶C = {b ‚àà
M | ab ‚ààC for all a ‚ààA}. Then it is easy to verify that A ‚äóB ‚äÜC if and only if B ‚äÜA ‚àí‚ó¶C. If we
deÔ¨Åne C ‚ó¶‚àíB = {a ‚ààM | ab ‚ààC for all b ‚ààB}, it is equally easy to see that A ‚äóB ‚äÜC if and only if
A ‚äÜC ‚ó¶‚àíB.
12.1.6 Sup semilattices
Another example is the category of sup semilattices, (see 6.4.6), which
also illustrates another principle, that it is often much easier to give an explicit description of the ‚àí‚ó¶
operation than of the ‚äó. If K and L are sup semilattices, then K ‚àí‚ó¶L is deÔ¨Åned to be the set of all
sup-semilattice homomorphisms from K to L. If f and g are such homomorphisms, then their sup is
deÔ¨Åned by (f ‚à®g)(x) = f(x) ‚à®g(x). The bottom element is the constant function at the bottom element
of L. It is easily seen that with these deÔ¨Ånitions K ‚àí‚ó¶L is a sup semilattice.
To get the monoidal structure, we will construct the left adjoint to the functor K ‚àí‚ó¶‚àí. The existence
of the left adjoint also follows from the adjoint functor theorem (references to this are given after
Theorem 9.3.7).
First, form the free sup semilattice generated by K √óL. It has elements of the form (x1,y1)‚à®(x2,y2)‚à®
¬∑ ¬∑ ¬∑ ‚à®(xn, yn) with x1, x2, . . . , xn ‚ààK and y1, y2, . . . , yn ‚ààL. These speciÔ¨Åcally include the empty sup
0. We then form the quotient semilattice gotten by all identiÔ¨Åcations of the form (x1, y) ‚à®(x2, y) =
(x1 ‚à®x2, y) and (x, y1) ‚à®(x, y2) = (x, y1 ‚à®y2). In addition, we must identify the bottom element of the
semilattice, which is the empty sup, with (x, 0) for any x ‚ààK and with (0, y) for any y ‚ààL These
identiÔ¨Åcations have to be made compatible with the semilattice structure so that whenever two elements
are identiÔ¨Åed, their joins with any third element are also identiÔ¨Åed.
It is instructive to see why any (x, 0) has to be identiÔ¨Åed with 0. First, let us denote the image of
(x, y) in K ‚äóL by x ‚äóy. Not every element of K ‚äóL has the form x ‚äóy, but it is generated by such
elements. The isomorphism Hom(K ‚äóL,M) ‚àº= Hom(L,K ‚àí‚ó¶M) can be described as follows. If f : K ‚äóL
‚àí‚ÜíM corresponds to ef : L ‚àí‚ÜíK ‚àí‚ó¶M, then for y ‚ààL, ef(y) : K ‚àí‚ÜíM is deÔ¨Åned by ef(y)(x) = f(x ‚äóy).
In particular, ef(0) is required to be the 0 homomorphism, in order to be a homomorphism of sup
semilattices. Thus f(x ‚äó0) = ef(0)(x) = 0. In particular, take M = K ‚äóL and choose f = id to conclude
that x ‚äó0 = 0. A similar argument will show that 0 ‚äóy = 0 as well, but in fact, it is not hard to show
symmetry of ‚äódirectly.
The crucial property of sup semilattices exploited here is that sup semilattices are determined by operations,
‚à®and 0 that are homomorphisms of the sup semilattice structure. Thus when L is a sup semilattice, ‚à®: L√óL
‚àí‚ÜíL is not just a function but a semilattice homomorphism. It is fairly uncommon for an equational theory
to have the property that its operations are homomorphisms of the theory, but when it does, constructions
analogous to the above will always give a monoidal closed structure.
Many other examples of closed monoidal categories are given in [Mac Lane, 1971]. Applications are
discussed in [Asperti and Longo, 1991], [Corradini and Asperti, 1993], [Marti Oliet and Meseguer, 1991]
and [Bartha, 1992].

114
Categories with monoidal structure
12.2 Properties of A ‚àí‚ó¶C
Monoidal closed categories exemplify one of the earliest perceptions of category theory, that a category
is quite special if the set of arrows between any two objects is, in some natural way, also an object of the
category. Thus, although it is much commoner to have some kind (or many kinds) of monoidal structure
on a category than to have a closed structure, it is usually easier to deÔ¨Åne the closed structure, when it
exists. This is well illustrated in the example of semilattices given in 12.1.6.
12.2.1 The internal hom
Another aspect of this perception is that A‚àí‚ó¶C is called the internal hom
of A to C and indeed it has properties similar to those of the ‚Äòexternal‚Äô (that is the set-valued) hom functor
Hom(A, C). For example, for each C, A 7‚ÜíA ‚àí‚ó¶C is also functorial in A, albeit contravariantly. (For
each A, C 7‚ÜíA ‚àí‚ó¶C is a functor in C by deÔ¨Ånition.) This means that there is a natural way of deÔ¨Åning,
for each map f : A‚Ä≤ ‚àí‚ÜíA a map f ‚àí‚ó¶C : A ‚àí‚ó¶C ‚àí‚ÜíA‚Ä≤ ‚àí‚ó¶C in such a way that the isomorphism (12.1)
is natural in all three arguments. This generalizes Proposition 7.2.1.
Another aspect is illustrated by the following, which internalizes the adjunction. It is a generalization
of isomorphism (7.1) and Proposition 7.2.2.
12.2.2 Proposition
In any monoidal closed category, there is a natural equivalence (of functors of
three variables)
(A ‚äóB) ‚àí‚ó¶C ‚àº= B ‚àí‚ó¶(A ‚àí‚ó¶C)
Proof. The proof uses the Yoneda Lemma (Theorem 5.7.6 of Chapter 5) and the associativity isomorph-
ism. At this point, we conÔ¨Åne ourselves to constructing the isomorphism. We have, for any object D,
Hom(D, (A ‚äóB) ‚àí‚ó¶C) ‚àº= Hom((A ‚äóB) ‚äóD, C)
‚àº= Hom(A ‚äó(B ‚äóD), C)
‚àº= Hom(B ‚äóD, A ‚àí‚ó¶C)
‚àº= Hom(D, B ‚àí‚ó¶(A ‚àí‚ó¶C))
Each of these isomorphisms is easily seen to be natural in D and thus we conclude from the Yoneda
Lemma that (A ‚äóB) ‚àí‚ó¶C ‚àº= A ‚àí‚ó¶(B ‚àí‚ó¶C).
12.2.3 Example
Let M be a commutative monoid. Recall from 4.2.1 that an M-action is a set S
together with a function Œ± : M √ó S ‚àí‚ÜíS subject to certain conditions. We generally denote Œ±(m, s)
by ms and never mention Œ± explicitly. Suppose from now on that M is commutative. If S and T are
M-actions, then there are two functions M √óS √óT ‚àí‚ÜíS √óT, one taking (m,s,t) to (ms,t) and the other
taking that element to (s, mt). The coequalizer of these two maps is denoted S ‚äóM T or simply S ‚äóT
if M is understood Ô¨Åxed. If we denote the class containing (s, t) by s ‚äót, then S ‚äóT can be thought
of as consisting of elements s ‚äót, s ‚ààS and t ‚ààT, subject to the relation that ms ‚äót = s ‚äómt for
m ‚ààM. It is left as an exercise to show that this gives a monoidal structure on M-act with unit action
the multiplication of M on itself. It is also a closed structure, given by deÔ¨Åning S ‚àí‚ó¶T to be the set of
equivariant maps S to T with mf deÔ¨Åned by (mf)(s) = m(f(s)) = f(ms), the latter equality from the
fact that f is equivariant.
12.2.4 Evaluation and composition
There are certain derived morphisms in a monoidal closed
category, using the adjunction. For any objects A and B, the identity A ‚àí‚ó¶B ‚àí‚ÜíA ‚àí‚ó¶B corresponds to
an arrow e(A, B) : A ‚äó(A ‚àí‚ó¶B) ‚àí‚ÜíA called evaluation since it internalizes the evaluation map. This
is natural in A and B. We can then derive an arrow c(A, B, C) deÔ¨Åned as the map (A ‚àí‚ó¶B) ‚äó(B ‚àí‚ó¶C)
‚àí‚ÜíA ‚àí‚ó¶C that corresponds under the adjointness to the map
A ‚äó(A ‚àí‚ó¶B) ‚äó(B ‚àí‚ó¶C)
e(A, B) ‚äóid
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíB ‚äó(B ‚àí‚ó¶C)
e(B, C)
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíC
The arrow c(A, B, C), which is also natural in all three variables, internalizes the composition arrow.

12.3 ‚àó-autonomous categories
115
12.2.5 Cotriples in closed monoidal categories
Let G = (G, œµ, Œ¥) be a cotriple on C . The Kleisli
category (often called the co-Kleisli category) K = K (G) has the same objects as C and the hom sets
are deÔ¨Åned by K (A, B) = C (GA, B). The composite of f : GA ‚àí‚ÜíB and g : GB ‚àí‚ÜíC is g ‚ó¶Gf
‚ó¶Œ¥A.
This is the dual construction to the Kleisli category of a triple and the veriÔ¨Åcations are the same.
Note that we are using the name of the category to denote the hom sets. This notation is especially useful
when we are dealing with two categories that have the same objects.
One of the most important properties of the Kleisli category of a cotriple is the following. It is used
to construct models of classical logic inside linear logic.
12.2.6 Theorem
Suppose G = (G, œµ, Œ¥) is a cotriple on a symmetric monoidal closed category C with
the property that for all objects A and B of C , there are natural isomorphisms between the two variable
functors G(‚àí√ó ‚àí) ‚àº= G ‚àí‚äóG‚àí. Then the Kleisli category for the cotriple is cartesian closed.
Proof. Let K denote the Kleisli category. Then we have, for any objects A, B and C of C (and therefore
of K ),
K (A, B √ó C) ‚àº= C (GA, B √ó C) ‚àº= C (GA, B) √ó C (GA, C)
‚àº= K (A, B) √ó K (A, C)
This isomorphism is clearly natural in A, which shows that, in K , B √ó C is a product of B and C. (The
same argument would work for any limit.) Then we have, again for any objects A, B and C of C ,
K (A √ó B, C) ‚àº= C (G(A √ó B), C) ‚àº= C (GA ‚äóGB, C)
‚àº= C (GB, GA ‚àí‚ó¶C) ‚àº= K (B, GA ‚àí‚ó¶C)
so that the functor GA ‚àí‚ó¶‚àíis right adjoint to A √ó ‚àíin K .
12.3 ‚àó-autonomous categories
12.3.1 DeÔ¨Ånition
Let C be a symmetric monoidal closed category. A functor (‚àí)‚àó: C op ‚àí‚ÜíC is a
duality functor if there is an isomorphism d(A, B) : A ‚àí‚ó¶B
‚àº=
‚àí‚àí‚ÜíB‚àó‚àí‚ó¶A‚àó, natural in A and B, such
that for all objects A, B and C,
(B‚àó‚àí‚ó¶A‚àó) ‚äó(C‚àó‚àí‚ó¶B‚àó)
C‚àó‚àí‚ó¶A‚àó
-
c(C‚àó, B‚àó, A‚àó) ‚ó¶s
(A ‚àí‚ó¶B) ‚äó(B ‚àí‚ó¶C)
A ‚àí‚ó¶C
-
c(A, B, C)
?
d(A, B) ‚äód(B, C)
?
d(A, C)
commutes. In the bottom arrow, s = s(B‚àó‚àí‚ó¶A‚àó, C‚àó‚àí‚ó¶B‚àó). A ‚àó-autonomous category is a symmetric
monoidal closed category with a given duality functor.
The discussion of ‚àó-autonomous categories in this section omits many details. The basic theory is
in [Barr, 1979]. More recent developments are given in [Barr, 1996a] and [Barr, 1995]. ‚àó-autonomous
categories form a model of linear logic [Barr, 1991], which has become important in modeling of parallel
processes and is closely related to Petri nets and event structures. A good introduction, with references,
to linear logic, is Yves Lafont‚Äôs Appendix B of [Girard, Taylor and Lafont, 1989]. The connection between
‚àó-autonomous categories and linear logic is described in [Asperti and Longo, 1991], sections 4.4 and 5.5,
and ‚àó-autonomous categories are used in modelling processes in [Pavlovi¬¥c and Abramsky, 1997].
Reference
to
[Pavlovi¬¥c
and
Abram-
sky,
1997]
added

116
Categories with monoidal structure
12.3.2 Properties of ‚àó-autonomous categories
There is much redundancy in the data specifying
a ‚àó-autonomous category. Given the duality, it is not hard to show that the ‚äóand ‚àí‚ó¶are related by the
equations:
A ‚äóB ‚àº= (A ‚àí‚ó¶B‚àó)‚àó
A ‚àí‚ó¶B ‚àº= (A ‚äóB‚àó)‚àó
so that only the (‚àí)‚àóand either ‚àí‚ó¶or ‚äóneed be given explicitly. Of course, various isomorphisms, maps
and coherences must still be given. The details can be found (for the not necessarily symmetric case)
in [Barr, 1995]. It turns out that it is usually most convenient to describe the ‚àí‚ó¶, since when the objects
are structured sets, A ‚àí‚ó¶B usually turns out to be the set of structure preserving functions of A ‚àí‚ÜíB,
equipped with a certain structure itself.
There is a second monoidal structure in a ‚àó-autonomous category, which we will denote by ‚äï, deÔ¨Åned
by A ‚äïB = (A‚àó‚äóB‚àó)‚àó. The unit for this monoidal structure is ‚ä§‚àó, which we will denote ‚ä•, since
A ‚äï‚ä•= (A‚àó‚äó‚ä•‚àó)‚àó‚àº= (A‚àó‚äó‚ä§)‚àó‚àº= A
‚àó‚àó‚àº= A. Since A‚àó‚äïC ‚àº= A ‚àí‚ó¶C, there is a one-one correspondence
between arrows A ‚äóB ‚àí‚ÜíC and arrows B ‚àí‚ÜíA‚àó‚äïC. This should be thought of as being analogous to
the equivalence between the logical statements a ‚àßb ‚áíc and b ‚áí¬¨a ‚à®c.
It is also possible to describe a ‚àó-autonomous category in terms of a symmetric closed monoidal
category with an object ‚ä•subject to the condition that for every A, the map A ‚àí‚Üí((A ‚àí‚ó¶‚ä•) ‚àí‚ó¶‚ä•) that
corresponds under the adjunction to
(A ‚àí‚ó¶‚ä•) ‚äóA
s(A ‚àí‚ó¶‚ä•, A)
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíA ‚äó(A ‚àí‚ó¶‚ä•)
e(A, ‚ä•)
‚àí‚àí‚àí‚àí‚àí‚àí‚Üí‚ä•
is an isomorphism. The reason is that we have
A‚àó‚àº= ‚ä§‚àí‚ó¶A‚àó‚àº= A ‚àí‚ó¶‚ä§‚àó‚àº= A ‚àí‚ó¶‚ä•
which shows that the duality is determined by ‚àí‚ó¶and ‚ä•. We say that ‚ä•is the dualizing object for
the duality. It is clearly determined up to isomorphism as the dual of ‚ä§.
However, one of the most important ways (for computing science) of constructing ‚àó-autonomous
categories does not work this way in that the ‚àí‚ó¶and ‚äóare constructed together. That is the so-called
Chu construction, described in 12.5 below. We Ô¨Årst present a familiar example.
12.3.3 Example
The category Rel of sets and relations is a ‚àó-autonomous category. We saw that
it was closed monoidal in Example 12.1.4. Since Hom(S, T) ‚àº= Hom(T, S) (both being the powerset of
the cartesian product of S and T), it follows that we have a duality by letting S‚àó= S. This gives a
‚àó-autonomous category. In fact, it is an example of what is called a compact ‚àó-autonomous category,
that is one in which A ‚àí‚ó¶B ‚àº= A‚àó‚äóB.
12.4 Factorization systems
It is a familiar fact that every function in the category of sets can be factored as an epimorphism
(surjection) followed by a monomorphism (injection). Similarly, every homomorphism in the category
of abelian groups can be factored as an epimorphism followed by a monomorphism. The properties of
these factorizations were abstracted early in the days of category theory, where they were known as
bicategory structures. Under the name factorization system, they have a number of uses in category
theory. We deÔ¨Åne them here because they are needed to state the main theorem on the Chu construction
(Theorem 12.5.2).
12.4.1 DeÔ¨Ånition
A factorization system in a category C consists of two subclasses E and M of
the arrows of C subject to the conditions
FS‚Äî-1 If I is the class of isomorphisms, then M
‚ó¶I ‚äÜM and I
‚ó¶E ‚äÜE .
FS‚Äî-2 Every arrow f in C factors as f = m ‚ó¶e with m ‚ààM and e ‚ààE .

12.5 The Chu construction
117
FS‚Äî-3 In any commutative square
C
D
-
-
m
A
B
-
-
e
?
f
?
g
with e ‚ààE and m ‚ààM , there is a unique h : B ‚àí‚ÜíC such that h ‚ó¶e = f and m ‚ó¶h = g.
The last condition is referred to as the ‚Äúdiagonal Ô¨Åll-in‚Äù. If (as is the case in many examples) eitherRemoved
‚ÄúOb-
serve
that‚Äù
every arrow in M is monic or every arrow in E is epic, then the uniqueness requirement in this condition
may be omitted.
12.4.2 Example
In Set, the class E of epimorphisms and the class M of monomorphisms constitute a
factorization system. In many categories of algebraic structures (including monoids), the class E of regular
epimorphisms (deÔ¨Åned in Section 8.4.3) and the class M of monomorphisms constitute a factorization
system. In the category of monoids and monoid homomorphisms, the class of all epis and all monos is
not a factorization system.
The theory of factorization systems is developed in [Barr and Wells, 1999] and in [Borceux, 1994].
12.5 The Chu construction
Chu [1978, 1979] describes a construction that begins with a symmetric monoidal closed category and an
object in it to use as dualizing object. He constructs from this a ‚àó-autonomous category that is closely
related to the original category and has the chosen object as dualizing object. There is a non-symmetric
version of this construction, but it is much more complicated [Barr, 1995], see also [Barr, 1996b].
Suppose that V is a symmetric monoidal closed category and let D denote a Ô¨Åxed object of V . We
deÔ¨Åne a category A that has as objects triples (V, V ‚Ä≤, ‚ü®‚àí, ‚àí‚ü©) where V and V ‚Ä≤ are objects of V and
‚ü®‚àí, ‚àí‚ü©: V ‚äóV ‚Ä≤ ‚àí‚ÜíD is an arrow of V . We call ‚ü®‚àí, ‚àí‚ü©a pairing and we usually omit it in the notation,
writing (V, V ‚Ä≤) for an object of A . This notation means we have in mind a pairing from V ‚äóV ‚Ä≤ to D, and
moreover this pairing will always be denoted ‚ü®‚àí, ‚àí‚ü©. An arrow (f, f ‚Ä≤) : (V, V ‚Ä≤) ‚àí‚Üí(W, W ‚Ä≤) of A consists
of a pair of arrows f : V ‚àí‚ÜíW and f ‚Ä≤ : W ‚Ä≤ ‚àí‚ÜíV ‚Ä≤ (note the direction of the second arrow) such that
V ‚äóV ‚Ä≤
D
-
‚ü®‚àí, ‚àí‚ü©
V ‚äóW ‚Ä≤
W ‚äóW ‚Ä≤
-
f ‚äóW ‚Ä≤
?
V ‚äóf ‚Ä≤
?
‚ü®‚àí, ‚àí‚ü©
commutes. This says that the arrows (V, V ‚Ä≤) ‚àí‚Üí(W, W ‚Ä≤) consist of all pairs
(f, f ‚Ä≤) ‚ààHom(V, V ‚Ä≤) √ó Hom(W ‚Ä≤, W)
that give the same element of Hom(V ‚äóW ‚Ä≤, D) or that
Hom(W ‚Ä≤, V ‚Ä≤)
Hom(V ‚äóW ‚Ä≤, D)
-
Hom((V, V ‚Ä≤), (W, W ‚Ä≤))
Hom(V, W)
-
?
?
is a pullback. This observation is the key to the construction of the monoidal closed structure in A .

118
Categories with monoidal structure
The next step in the construction is to make the set of arrows into an object of V . We deÔ¨Åne
V ((V, V ‚Ä≤), (W, W ‚Ä≤)) so that
W ‚Ä≤ ‚àí‚ó¶V ‚Ä≤
(V ‚äóW ‚Ä≤) ‚àí‚ó¶D
-
V ((V, V ‚Ä≤), (W, W ‚Ä≤))
V ‚àí‚ó¶W
-
?
?
is a pullback. Here the arrow on the right side is described as follows. The arrow ‚ü®‚àí, ‚àí‚ü©: W ‚äóW ‚Ä≤
‚àí‚ÜíD corresponds to an arrow W ‚àí‚ÜíW ‚Ä≤ ‚àí‚ó¶D (the symmetry is involved here too) and then we have a
composite arrow
V ‚àí‚ó¶W ‚àí‚ÜíV ‚àí‚ó¶(W ‚Ä≤ ‚àí‚ó¶D)
‚àº=
‚àí‚àí‚Üí(V ‚äóW ‚Ä≤) ‚àí‚ó¶D
The lower arrow in the diagram is similar.
If (V, V ‚Ä≤) is an object of A , then so is (V ‚Ä≤, V ) using V ‚Ä≤ ‚äóV
s(V ‚Ä≤, V )
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíV ‚äóV ‚Ä≤
‚ü®‚àí, ‚àí‚ü©
‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíD. We
denote it by (V, V ‚Ä≤)‚àó. It is clear that
Hom((V, V ‚Ä≤), (W, W ‚Ä≤)) ‚àº= Hom((W, W ‚Ä≤)‚àó, (V, V ‚Ä≤)‚àó)
so that (‚àí)‚àóis a duality on A . Now we can give the main deÔ¨Ånitions. We let
(V, V ‚Ä≤) ‚àí‚ó¶(W, W ‚Ä≤) = (V ((V, V ‚Ä≤), (W, W ‚Ä≤)), V ‚äóW ‚Ä≤)
(V, V ‚Ä≤) ‚äó(W, W ‚Ä≤) = (V ‚äóW, V ((V, V ‚Ä≤), (W, W ‚Ä≤)‚àó))
12.5.1 Separated and extensional Chu objects
Suppose that E /M is a factorization system on
V . Then we say that the Chu object (V, V ‚Ä≤) is M -separated if the arrow V ‚àí‚ÜíV ‚Ä≤ ‚àí‚ó¶D belongs to M
and is M -extensional if the arrow V ‚Ä≤ ‚àí‚ÜíV ‚àí‚ó¶D belongs to M . When the M remains Ô¨Åxed, we often
omit it and speak of separated and extensional objects.
The reason for these names is this. We often think of a pair (V, V ‚Ä≤) as consisting of an object and a set
of descriptions of scalar-valued functions on it. Separability is the existence of enough such descriptions in V ‚Ä≤
to distinguish (or separate) the elements of V , while extensionality is the word used to name the property of
functions that two are equal if their values on all elements of their domain are equal. Functions have this property,
but programs for computing them do not necessarily.
We denote the full subcategories of separated objects by Chus = Chus(V , D) and of extensional
objects by Chue = Chue(V , D). We follow Vaughan Pratt in denoting the full subcategory of objects
that are both separated and extensional by chu = chu(V , D). Since Chus is evidently the dual of Chue,
it is immediate that chu is self-dual. It is useful to ask if chu is also ‚àó-autonomous.
We also consider the following two conditions on factorization systems.
FC‚Äì1 Every arrow in E is an epimorphism;
FC‚Äì2 if m ‚ààM , then for any object A of V , the induced A ‚àí‚ó¶m is in M .
The following theorem gives conditions under which the separated, extensional objects in Chu(V , D)
form a *-autonomous category.
12.5.2 Theorem
Suppose the category V has pullbacks and E /M is a factorization system that satis-
Ô¨Åes FC‚Äì1 and FC‚Äì2. Then for any object D, the category chu(V ,D) of M -separated, and M -extensional
objects of Chu is ‚àó-autonomous.
The proof is given in [Barr and Wells, 1999], Chapter 16.

12.5 The Chu construction
119
12.5.3 Examples
The Ô¨Årst example is Chu(Set, 2). An object is simply a pair (S,S‚Ä≤) of sets, together
with a function S √ó S‚Ä≤ ‚àí‚Üí2. Equivalently, it is a subset of S √ó S‚Ä≤, otherwise known as a relation between
S and S‚Ä≤. The extensional objects are those for which S‚Ä≤ is, up to isomorphism, a set of subsets of S
and then ‚ü®s, s‚Ä≤‚ü©= 1 if s ‚ààs‚Ä≤ and 0 otherwise. The separated ones are those for which, given s1, s2 ‚ààS,
there is at least one s‚Ä≤ ‚ààS‚Ä≤ with either s1 ‚ààs‚Ä≤ and s2 /‚ààs‚Ä≤ or vice versa. A set together with a set of
subsets is the beginnings of a topological space and the separation condition is the same as that of a T1
topological space. This example has been intensively studied by Vaughan Pratt and his students.
A second example is given by taking V to be the category of vector spaces over a Ô¨Åeld F. The
category of Ô¨Ånite dimensional vector spaces is already a ‚àó-autonomous category with the set of linear
transformations between two spaces as internal hom and the usual vector space dual as the duality
operator. It is easily seen to be a ‚àó-autonomous subcategory of Chu(V , F). It is also a ‚àó-autonomous
subcategory of the separated extensional subcategory chu(V , F). There is one distinctive feature of the
separated extensional subcategory worth noting. In that case (and so far as is known only in that case),
the tensor product and internal hom of separated extensional objects is already separated and extensional
and there is no reason to apply the reÔ¨Çector and coreÔ¨Çector, respectively (see [Barr, 1996c]).

Bibliography
At the end of each entry, the pages on which that entry is cited are listed in parentheses.
Ad¬¥amek, J. and J. RosiÀácky (1994). Locally Presentable and Accessible Categories. Cambridge University Press.
Asperti, A. and G. Longo (1991). Categories, Types and Structures. The MIT Press.
Backhouse, R., M. Bijsterveld, R. van Geldrop, and J. van der Woude (1995). ‚ÄòCategorical Ô¨Åxed point calculus‚Äô.
In Pitt et al. [1995], pages 159‚Äì179.
Backus, J. (1981). ‚ÄòThe algebra of functional programs: Function level reasoning, linear equations, and extended
deÔ¨Ånitions‚Äô.
In Formalization of Programming Concepts, J. Diaz and I. Ramos, editors, volume 107 of
Lecture Notes in Computer Science. Springer-Verlag.
Backus, J. (1981). ‚ÄòIs computer science based on the wrong fundamental concept of program?‚Äô. In Algorithmic
Languages, J. W. deBakker and J. C. van Vliet, editors. North-Holland.
Barendregt, H. (1984). The Lambda Calculus ‚Äì its Syntax and Semantics. North-Holland.
Barr, M. (1979). *-Autonomous Categories, volume 752 of Lecture Notes in Mathematics. Springer-Verlag.
Barr, M. (1986). ‚ÄòFuzzy sets and topos theory‚Äô. Canadian Math. Bull., volume 24, pages 501‚Äì508.
Barr, M. (1990). ‚ÄòFixed points in cartesian closed categories‚Äô. Theoretical Computer Science, volume 70, pages
65‚Äì72.
Barr, M. (1991).
‚Äò‚àó-autonomous categories and linear logic‚Äô.
Mathematical Structures in Computer Science,
volume 1, pages 159‚Äì178.
Barr, M. (1995). ‚ÄòNon-symmetric *-autonomous categories‚Äô. Theoretical Computer Science, volume 139, pages
115‚Äì130.
Barr, M. (1996). ‚Äò‚àó-autonomous categories, revisited‚Äô. Journal of Pure and Applied Algebra, volume 111, pages
1‚Äì20.
Barr, M. (1996). ‚ÄòThe Chu construction‚Äô. Theory and Applications of Categories, volume 2, pages 17‚Äì35.
Barr, M. (1996). ‚ÄòSeparability of tensor in Chu categories of vector spaces‚Äô. Mathematical Structures in Computer
Science, volume 6, pages 213‚Äì217.
Barr, M., C. McLarty, and C. Wells (1985). ‚ÄòVariable set theory‚Äô. Technical report, McGill University.
Barr, M. and C. Wells (1985). Toposes, Triples and Theories, volume 278 of Grundlehren der mathematischen
Wissenschaften. Springer-Verlag, New York. A list of corrections and additions is maintained in [Barr and
Wells, 1993].
Barr, M. and C. Wells (1993). ‚ÄòCorrections to Toposes, Triples and Theories‚Äô. Available by anonymous FTP
from triples.math.mcgill.ca in directory pub/barr and by web browser from http://www.cwru.edu/
artsci/math/wells/pub/wellspub.html. Corrections and additions to [Barr and Wells, 1985].
Barr, M. and C. Wells (1999). Category Theory for Computing Science, third edition. Les publications Centre
de recherches math¬¥ematiques.
Bartha, M. (1992). ‚ÄòAn algebraic model of synchronous systems‚Äô. Information and Computation, volume 97,
pages 1‚Äì31.
Bell, J. L. (1988). Toposes and Local Set Theories: An Introduction. Oxford Logic Guides. Oxford University
Press.
Bergman, C. and J. Berman (1998). ‚ÄòAlgorithms for categorical equivalence‚Äô. Mathematical Structures in Com-
puter Science, volume 8, pages 1‚Äì16.
Bird, R. S. (1986). ‚ÄòAn introduction to the theory of lists‚Äô. In Logic of Programming and Calculi of Discrete
Designs, M. Broy, editor, pages 5‚Äì42. Springer-Verlag.
Boileau, A. and A. Joyal (1981). ‚ÄòLa logique des topos‚Äô. Symbolic Logic, volume 46, pages 6‚Äì16.
Borceux, F. (1994). Handbook of Categorical Algebra I, II and III. Cambridge University Press.
Chen, H. G. and J. R. B. Cockett (1989). ‚ÄòCategorical combinators‚Äô. Technical report, University of Calgary.
Chu, P.-H. (1978). ‚ÄòConstructing *-autonomous categories‚Äô. Master‚Äôs thesis, McGill University.
Chu, P.-H. (1979). ‚ÄòConstructing *-autonomous categories‚Äô. Appendix to [Barr, 1979].
Cockett, J. R. B. (1989). ‚ÄòOn the decidability of objects in a locos‚Äô. In Categories in Computer Science and
Logic, J. W. Gray and A. Scedrov, editors, volume 92 of Contemporary Mathematics. American Mathe-
matical Society.
Cockett, J. R. B. (1993). ‚ÄòIntroduction to distributive categories‚Äô. Mathematical Structures in Computer Science,
volume 3, pages 277‚Äì307.
Cockett, J. R. B. and D. Spencer (1992). ‚ÄòStrong categorical datatypes i‚Äô. In Category Theory 1991, R. Seely,
editor. American Mathematical Society.
120

Bibliography
121
Corradini, A. and A. Asperti (1993). ‚ÄòA categorical model for logic programs: Indexed monoidal categories‚Äô. In
Semantics: Foundations and Applications (Beekbergen, 1992), volume 666 of Lecture Notes in Computer
Science, pages 110‚Äì137. Springer-Verlag.
Cousineau, G., P.-L. Curien, and M. Mauny (1985). ‚ÄòThe categorical abstract machine‚Äô. In Functional Program-
ming Languages and Computer Architecture, volume 201 of Lecture Notes in Computer Science. Springer-
Verlag.
Crole, R. L. (1994). Categories for Types. Cambridge University Press.
Curien, P.-L. (1986). Categorical Combinators, Sequential Algorithms and Functional Programming. Wiley.
Davey, B. A. and H. A. Priestley (1990). Introduction to Lattices and Order. Cambridge University Press.
Diers, Y. (1980). ‚ÄòCat¬¥egories localement multipr¬¥esentables‚Äô. Arch. Math., volume 34, pages 344‚Äì356.
Diers, Y. (1980). ‚ÄòQuelques constructions de cat¬¥egories localement multipr¬¥esentables‚Äô. Ann. Sci. Math. Qu¬¥ebec,
volume 4, pages 79‚Äì101.
Dybjer, P. (1986). ‚ÄòCategory theory and programming language semantics: an overview‚Äô. In Category Theory
and Computer Programming, D. Pitt, S. Abramsky, A. Poign¬¥e, and D. Rydeheard, editors, volume 240 of
Lecture Notes in Computer Science, pages 165‚Äì181. Springer-Verlag.
Dybkjaer, H. and A. Melton (1993). ‚ÄòComparing Hagino‚Äôs categorical programming language and typed lambda-
calculi‚Äô. Theoretical Computer Science, volume 111, pages 145‚Äì189.
Ehrig, H., H. Herrlich, H. J. Kreowski, and G. Preuss, editors (1988). Categorical Methods in Computer Science,
volume 393 of Lecture Notes in Computer Science. Springer-Verlag.
Eilenberg, S. (1976). Automata, Languages and Machines, Vol. B. Academic Press.
Eilenberg, S. and J. C. Moore (1965). ‚ÄòAdjoint functors and triples‚Äô. Illinois J. Math., volume 9, pages 381‚Äì398.
Fokkinga, M. M. (1992). ‚ÄòCalculate categorically!‚Äô. Formal Aspects of Computing, volume 4.
Fourman, M. (1977).
‚ÄòThe logic of topoi‚Äô.
In Handbook of Mathematical Logic, J. Barwise, editor. North-
Holland.
Fourman, M., P. Johnstone, and A. Pitts (1992). Applications of Categories in Computer Science, volume 177
of London Mathematical Society Lecture Notes Series. Cambridge University Press.
Fourman, M. and S. Vickers (1986). ‚ÄòTheories as categories‚Äô. In Category Theory and Computer Programming,
D. Pitt, S. Abramsky, A. Poign¬¥e, and D. Rydeheard, editors, volume 240 of Lecture Notes in Computer
Science, pages 434‚Äì448. Springer-Verlag.
Freyd, P. and A. Scedrov (1990).
Categories, Allegories, volume 39 of North-Holland Mathematical Library.
North-Holland.
Girard, J.-Y., P. Taylor, and Y. Lafont (1989). Proofs and Types. Cambridge University Press.
Goguen, J. A. (1988). ‚ÄòWhat is uniÔ¨Åcation? A categorical view of substitution, equation and solution‚Äô. Technical
Report CSLI‚Äì88‚Äì124, Center for the Study of Language and Information.
Goguen, J. A. (1991). ‚ÄòA categorical manifesto‚Äô. Mathematical Structures in Computer Science, volume 1, pages
49‚Äì68.
Gray, J. W. and A. Scedrov (1989). Categories in Computer Science and Logic, volume 92 of Contemporary
Mathematics. American Mathematical Society.
Gunter, C. (1992). Semantics of Programming Languages. The MIT Press.
Hagino, T. (1987). A categorical programming language. PhD thesis, University of Edinburgh.
Hagino, T. (1987).
‚ÄòA typed lambda calculus with categorical type constructors‚Äô.
In Category Theory and
Computer Science, D. Pitt, A. Poign¬¥e, and D. Rydeheard, editors, volume 283 of Lecture Notes in Compu-
ter Science, pages 140‚Äì157. Springer-Verlag.
Halmos, P. (1960). Naive Set Theory. Van Nostrand.
Hindley, J. R. and J. P. Seldin (1986).
Introduction to Combinators and Œª-Calculus.
Cambridge University
Press.
Huet, G. (1986). ‚ÄòCartesian closed categories and lambda-calculus‚Äô. In Combinators and Functional Programming
Languages, G. Cousineau, P.-L. Curien, and B. Robinet, editors, volume 242 of Lecture Notes in Computer
Science. Springer-Verlag.
Huwig, H. and A. Poign¬¥e (1990). ‚ÄòA note on inconsistencies caused by Ô¨Åxpoints in a cartesian closed category‚Äô.
Theoretical Computer Science, volume 73, pages 101‚Äì112.
Hyland, J. M. E. (1982). ‚ÄòThe eÔ¨Äective topos‚Äô. In The L. E. J. Brouwer Centenary Symposium, pages 165‚Äì216.
North-Holland.
Hyland, J. M. E. and A. Pitts (1989). ‚ÄòThe theory of constructions: Categorical semantics and topos-theoretic
models‚Äô. In Categories in Computer Science and Logic, J. W. Gray and A. Scedrov, editors, volume 92 of
Contemporary Mathematics, pages 137‚Äì199. American Mathematical Society.
Jacobson, N. (1974). Basic Algebra I. W. H. Freeman.
Johnstone, P. T. (1977). Topos Theory. Academic Press.
Kleisli, H. (1965). ‚ÄòEvery standard construction is induced by a pair of adjoint functors‚Äô. Proc. Amer. Math.
Soc., volume 16, pages 544‚Äì546.
Kock, A. (1972). ‚ÄòStrong functors and monoidal monads‚Äô. Archiv der Mathematik, volume 20, pages 113‚Äì120.

122
Bibliography
Lallement, G. (1979). Semigroups and Combinatorial Applications. Wiley.
Lambek, J. (1986).
‚ÄòCartesian closed categories and typed lambda-calculi‚Äô.
In Combinators and Functional
Programming Languages, G. Cousineau, P.-L. Curien, and B. Robinet, editors, volume 242 of Lecture Notes
in Computer Science, pages 136‚Äì175. Springer-Verlag.
Lambek, J. and P. Scott (1984). ‚ÄòAspects of higher order categorical logic‚Äô. In Mathematical Applications of
Category Theory, J. W. Gray, editor, volume 30 of Contemporary Mathematics, pages 145‚Äì174. American
Mathematical Society.
Lambek, J. and P. Scott (1986). Introduction to Higher Order Categorical Logic, volume 7 of Cambridge Studies
in Advanced Mathematics. Cambridge University Press.
Lawvere, F. W. (1963). Functorial Semantics of Algebraic Theories. PhD thesis, Columbia University.
Lawvere, F. W. (1966). ‚ÄòThe category of categories as a foundation for mathematics‚Äô. In Proceedings of the
Conference on Categorical Algebra, La Jolla 1965. Springer-Verlag.
Lewis, H. R. and C. H. Papadimitriou (1981). Elements of the Theory of Computation. Prentice-Hall.
Linton, F. E. J. (1969). ‚ÄòApplied functorial semantics‚Äô. In Seminar on Triples and Categorical Homology Theory,
volume 80 of Lecture Notes in Mathematics, pages 53‚Äì74. Springer-Verlag.
Linton, F. E. J. (1969). ‚ÄòAn outline of functorial semantics‚Äô. In Seminar on Triples and Categorical Homology
Theory, volume 80 of Lecture Notes in Mathematics, pages 7‚Äì52. Springer-Verlag.
L¬®uth, C. and N. Ghani (1997). ‚ÄòMonads and modular term rewriting‚Äô. In Moggi and Rosolini [1997], pages
69‚Äì86.
Mac Lane, S. (1971). Categories for the Working Mathematician, volume 5 of Graduate Texts in Mathematics.
Springer-Verlag.
Mac Lane, S. and I. Moerdijk (1992). Sheaves in Geometry and Logic. Universitext. Springer-Verlag.
Main, M., A. Melton, M. Mislove, and D. Schmidt, editors (1988). Mathematical Foundations of Programming
Language Semantics, volume 298 of Lecture Notes in Computer Science. Springer-Verlag.
Makkai, M. and R. Par¬¥e (1990). Accessible Categories: the Foundations of Categorical Model Theory, volume 104
of Contemporary Mathematics. American Mathematical Society.
Makkai, M. and G. Reyes (1977). First Order Categorical Logic, volume 611 of Lecture Notes in Mathematics.
Springer-Verlag.
Manes, E. G. (1986).
‚ÄòWeakest preconditions: Categorial insights‚Äô.
In Category Theory and Computer Pro-
gramming, D. Pitt, S. Abramsky, A. Poign¬¥e, and D. Rydeheard, editors, volume 240 of Lecture Notes in
Computer Science, pages 182‚Äì197. Springer-Verlag.
Manes, E. G. and M. Arbib (1986). Algebraic Approaches to Program Semantics. Springer-Verlag.
Marti Oliet, N. and J. Meseguer (1991). ‚ÄòFrom Petri nets to linear logic through categories: a survey‚Äô. Interna-
tional Journal of Foundations of Computer Science, volume 2, pages 297‚Äì399.
McLarty, C. (1989). ‚ÄòNotes toward a new philosophy of logic‚Äô. Technical report, Case Western Reserve Univer-
sity.
McLarty, C. (1992). Elementary Categories, Elementary Toposes, volume 21 of Oxford Logic Guides. Clarendon
Press.
Mikkelson, C. J. (1976). Lattice Theoretic and Logical Aspects of Elementary Topoi, volume 25 of Aarhus Uni-
versity Various Publications Series. Aarhus University.
Mitchell, J. C. and P. J. Scott (1989). ‚ÄòTyped lambda calculus and cartesian closed categories‚Äô. In Categories in
Computer Science and Logic, J. W. Gray and A. Scedrov, editors, volume 92 of Contemporary Mathematics,
pages 301‚Äì316. American Mathematical Society.
Moggi, E. (1989). ‚ÄòComputational lambda-calculus and monads‚Äô. In Proceedings of the Fourth Annual Symposium
on Logic in Computer Science, pages 14‚Äì23. IEEE.
Moggi, E. (1991). ‚ÄòA category-theoretic account of program modules‚Äô. Mathematical Structures in Computer
Science, volume 1, pages 103‚Äì139.
Moggi, E. (1991). ‚ÄòNotions of computation and monads‚Äô. Information and Control, volume 93, pages 155‚Äì92.
Moggi, E. and G. Rosolini, editors (1997). Category Theory and Computer Science, 7th International Conference.
Springer-Verlag.
Mulry, P. S. (1992). ‚ÄòStrong monads, algebras and Ô¨Åxed points‚Äô. In Applications of Categories in Computer
Science, volume 177 of London Mathematical Society Lecture Notes Series. Cambridge University Press.
Pavlovi¬¥c, D. and S. Abramsky (1997). ‚ÄòSpecifying interaction categories‚Äô. In Moggi and Rosolini [1997], pages
147‚Äì158.
Pierce, B. (1991). Basic Category Theory for Computer Scientists. The MIT Press.
Pitt, D. (1986). ‚ÄòCategories‚Äô. In Category Theory and Computer Programming, D. Pitt, S. Abramsky, A. Poign¬¥e,
and D. Rydeheard, editors, volume 240 of Lecture Notes in Computer Science, pages 6‚Äì15. Springer-
Verlag.
Pitt, D., S. Abramsky, A. Poign¬¥e, and D. Rydeheard, editors (1986). Category Theory and Computer Program-
ming, volume 240 of Lecture Notes in Computer Science. Springer-Verlag.

Bibliography
123
Pitt, D., P.-L. Curien, S. Abramsky, A. M. Pitts, A. Poign¬¥e, and D. E. Rydeheard, editors (1991). Category
Theory and Computer Science (Paris, 1991), volume 530 of Lecture Notes in Computer Science. Springer-
Verlag.
Pitt, D., A. Poign¬¥e, and D. Rydeheard, editors (1987). Category Theory and Computer Science, volume 283 of
Lecture Notes in Computer Science. Springer-Verlag.
Pitt, D., D. Rydeheard, P. Dybjer, A. Pitts, and A. Poign¬¥e, editors (1989). Category Theory and Computer
Science, volume 389 of Lecture Notes in Computer Science. Springer-Verlag.
Pitt, D., D. E. Rydeheard, and P. Johnstone, editors (1995).
Category Theory and Computer Science, 6th
International Conference. Springer-Verlag.
Poign¬¥e, A. (1986). ‚ÄòElements of categorical reasoning: Products and coproducts and some other (co-)limits‚Äô. In
Category Theory and Computer Programming, D. Pitt, S. Abramsky, A. Poign¬¥e, and D. Rydeheard, editors,
volume 240 of Lecture Notes in Computer Science, pages 16‚Äì42. Springer-Verlag.
Power, A. J. (1990). ‚ÄòAn algebraic formulation for data reÔ¨Ånement‚Äô. In Mathematical Foundations of Programming
Semantics, M. Main, A. Melton, M. Mislove, and D. Schmidt, editors, volume 442 of Lecture Notes in Com-
puter Science, pages 402‚Äì417. Springer-Verlag.
Reynolds, J. C. (1980). ‚ÄòUsing category theory to design implicit conversions and generic operators‚Äô. In Proceed-
ings of the Aarhus Workshop on Semantics-Directed Compiler Generation, N. D. Jones, editor, volume 94
of Lecture Notes in Computer Science. Springer-Verlag.
Rydeheard, D. E. and R. M. Burstall (1985). ‚ÄòMonads and theories: A survey for computation‚Äô. In Algebraic
Methods in Semantics, M. Nivat and J. C. Reynolds, editors. Cambridge University Press.
Rydeheard, D. E. and R. M. Burstall (1986). ‚ÄòA categorical uniÔ¨Åcation algorithm‚Äô. In Category Theory and
Computer Programming, D. Pitt, S. Abramsky, A. Poign¬¥e, and D. Rydeheard, editors, volume 240 of Lec-
ture Notes in Computer Science, pages 493‚Äì505. Springer-Verlag.
Rydeheard, D. E. and R. M. Burstall (1988). Computational Category Theory. International Series in Computer
Science. Prentice Hall.
Scott, D. (1972). ‚ÄòContinuous lattices‚Äô. In Toposes, Algebraic Geometry and Logic, F. W. Lawvere, editor, volume
274 of Lecture Notes in Mathematics, pages 97‚Äì136. Springer-Verlag.
Scott, D. (1982). ‚ÄòDomains for denotational semantics‚Äô. In Automata, Languages and Programming, M. Nielson
and E. M. Schmidt, editors, volume 140 of Lecture Notes in Computer Science, pages 577‚Äì613. Springer-
Verlag.
Sedgewick, R. (1983). Algorithms. Addison-Wesley.
Seely, R., editor (1992). Category Theory 1991, volume 13 of Canadian Mathematical Society Conference Pro-
ceedings. American Mathematical Society.
Smyth, M. B. (1983). ‚ÄòThe largest cartesian closed category of domains‚Äô. Theoretical Computer Science, vol-
ume 27.
Spivey, M. (1989). ‚ÄòA categorical approach to the theory of lists‚Äô. In Mathematics of Program Construction,
J. L. A. Van de Snepscheut, editor, volume 375 of Lecture Notes in Computer Science, pages 399‚Äì408.
Springer-Verlag.
Taylor, P. (1989). ‚ÄòQuantitative domains, groupoids and linear logic‚Äô. In Category Theory and Computer Science,
D. Pitt, D. Rydeheard, P. Dybjer, A. Pitts, and A. Poign¬¥e, editors, volume 389 of Lecture Notes in Computer
Science. Springer-Verlag.
Tennent, R. D. (1986). ‚ÄòFunctor category semantics of programming languages and logics‚Äô. In Category Theory
and Computer Programming (Guildford, 1985), D. Pitt, S. Abramsky, A. Poign¬¥e, and D. Rydeheard, editors,
volume 240 of Lecture Notes in Computer Science, pages 206‚Äì224. Springer-Verlag.
Vickers, S. (1992).
‚ÄòGeometric theories and databases‚Äô.
In Applications of Categories in Computer Science
(Durham, 1991), volume 177 of London Mathematical Society Lecture Notes Series, pages 288‚Äì314. Cam-
bridge University Press.
Wadler, P. (1989). ‚ÄòTheorems for free!‚Äô. In Fourth ACM Symposium on Functional Programming Languages and
Computer Architecture, pages 347‚Äì359. Association for Computing Machinery.
Wadler, P. (1992). ‚ÄòComprehending monads‚Äô. Mathematical Structures in Computer Science, volume 2, pages
461‚Äì493.
Wagner, E. G. (1986). ‚ÄòAlgebraic theories, data types and control constructs‚Äô. Fundamenta Informatica, volume 9,
pages 343‚Äì370.
Wagner, E. G. (1986). ‚ÄòCategories, data types and imperative languages‚Äô. In Category Theory and Computer
Programming, D. Pitt, S. Abramsky, A. Poign¬¥e, and D. Rydeheard, editors, volume 240 of Lecture Notes
in Computer Science, pages 143‚Äì162. Springer-Verlag.
Wagner, E. G. (1987). ‚ÄòA categorical treatment of pre- and post conditions‚Äô. Theoretical Computer Science,
volume 53.
Walters, R. F. C. (1991). Categories and Computer Science. Cambridge University Press.
Walters, R. F. C. (1992). ‚ÄòAn imperative language based on distributive categories‚Äô. Mathematical Structures in
Computer Science, volume 2, pages 249‚Äì256.

124
Bibliography
Williams, J. H. (1982). ‚ÄòNotes on the fp style of functional programming‚Äô. In Functional Programming and its
Applications, P. H. Darlington, J. and D. Turner, editors. Cambridge University Press.

Index
abuse of notation, 9
acceptor states, 31
action, 30, 31
adjoint, 94, 99
adjunction, 94
algebraic structure, 11, 90
all colimits, 90
all Ô¨Ånite colimits, 90
all Ô¨Ånite limits, 85
all limits, 85
alphabet, 31
amalgamated sum, 90
antisymmetric, 9
application, 3
apply, 48
arrow category, 44
arrow of a category, 4
arrow of a graph, 1
assertion, 88
associative, 5, 40
associative identity (of a triple), 99
automorphism, 17
‚àó-autonomous category, 115
base (of a cocone), 89
base (of a cone), 55
bicategory, 116
binary discrete cocone, 69
binary operation, 59
binary product functor, 95
binary products, 64, 66
binary relation, 9
Boolean algebra, 75
bound (variable), 79
canonical binary products, 66
canonical Ô¨Ånite products, 67
canonical injection, 69
cartesian category, 67
cartesian closed, 103
cartesian closed category, 73, 95, 98, 112
cartesian product, 55
cartesian product of arrows, 62
cartesian square, 59
Cat, 26
category, 4
category determined by a monoid, 10
category determined by a poset, 9, 18
category of Ô¨Ånite sets, 6
category of graphs, 11
category of models, 44
category of monoids, 11
category of posets, 11
category of semigroups, 11, 18
category of sets, 6, 18, 19, 21, 24, 74, 88, 89, 100,
104
category of sets and partial functions, 6, 70
category of sets and relations, 6, 70, 113, 116
characteristic arrow, 103
chase a diagram, 40
Chu construction, 117
closed (term), 79
closed (under a binary operation), 10
closed monoidal category, 112, 113
cocomplete, 90
cocone, 89
codomain, 1
coequalizer, 88
colimit, 90, 98, 105
commutative cocone, 89
commutative cone, 84
commutative diagram, 38
commutative semigroup, 9
commutes (of a diagram), 38
compact ‚àó-autonomous category, 116
complete, 76, 85
complete Heyting algebra, 107
component (of a cone), 84
component (of a natural transformation), 43
composable pair, 4
composite, 4, 43
composition, 4
cone, 55, 65, 84
conjunction calculus, 72
connected, 49
connected component, 49
constant, 19, 108
contravariant functor, 29
contravariant hom functor, 30
coordinate projections, 55
coproduct, 69
cotriple, 100, 115
counit, 94
covariant, 29
covariant hom functor, 29, 68
CPO, 76
curry, 73
deduction system, 71, 77
diagonal, 6
diagram, 37
direct image, 29, 96
discrete cocone, 89
disjoint sum, 105
125

126
Index
distributive category, 72
domain, 1
domain of a partial arrow, 106
Doolittle diagrams, 90
dual concept, 15
dual notion, 15
dual of a category, 14, 29
duality functor, 115
dualizing object, 116
eÔ¨Äective equivalence relation, 105
element-free, 25
empty list, 10
empty path, 4
empty semigroup, 9, 90
endoarrow, 1
endomorphism, 1, 17
epimorphism, 22, 83, 89, 117
equalize, 82
equalizer, 82
equation, 7
equivalence of categories, 35
equivalence relation, 88, 104
equivariant map, 31
essentially, 45
evaluation map, 114
existential image, 29
exponential object, 74
external (pair of arrows), 62
factorization system, 116, 118
factors through, 21
faithful functor, 33
family of sets, 15
Ô¨Åber product, 86
Fin, 6, 13, 15
Ô¨Ånal states, 31
Ô¨Ånite product, 67
Ô¨Ånite state machine, 30, 31
Ô¨Ånitely cocomplete, 90
Ô¨Ånitely complete, 85
Ô¨Årst projection, 27
Ô¨Çatten, 48
fold, 48
forgetful functor, 27
formula, 71
free, 79, 95
free M-set, 100
free category, 16, 28
free monoid, 10, 12, 92
free monoid functor, 28
full functor, 33
full subcategory, 14
functional programming language, 67, 71, 76
functor, 26, 31, 32
functor category, 63
G0, 1
global element, 19, 20
graph, 1, 11, 43, 107
graph of sets and functions, 1
GRF, 11
Grf, 11
Grothendieck topology, 107
group, 18
hom functor, 29, 30, 51, 68, 77
hom set, 5, 24
homomorphism of graphs, 2, 11, 40
homomorphism of monoids, 11, 26, 47
homomorphism of semigroups, 11
homomorphism of sup semilattices, 70
homomorphism of u-structures, 42
identity, 4
identity element, 9
identity function, 11
identity homomorphism, 2
inclusion, 69
inclusion function, 11
indexed function, 15
induced natural transformation, 51
inf semilattice, 70
inÔ¨Åmum, 57
initial object, 18, 20, 21
initial topos, 106
injective, 19
integer, 10
internal, 62
internal hom functor, 77
internal language, 81
inverse, 17
inverse function, 29
inverse image, 29, 86, 96
invertible, 17
isomorphism, 17, 83
isomorphism of semigroups, 12
kernel pair, 105
Kleene closure, 10, 12, 47, 92
Kleisli category, 100, 101, 115
Œª-calculus, 79
large, 1, 5
lattice, 70
least upper bound, 70
left adjoint, 94
left cancellable, 20
left inverse, 23
limit, 84, 98
linear logic, 115
list, 10, 47
locally cartesian closed, 104
locally small, 5
lower semilattice, 70
M-equivariant, 100
M -extensional, 118
M -separated, 118
M-set, 30
map lifting property, 28
Mod, 44
model of a graph, 42, 43

Index
127
Mon, 11
monic, 19
mono, 19
monoid, 9, 11, 14, 30, 34, 47, 100, 101, 113, 117
monoid homomorphism, 11, 47
monoidal category, 111
monomorphism, 19, 83, 87, 117
monotone function, 11, 70
morphism of cones, 84
multiplication of a triple, 99
N, 2
n-ary product, 65
natural equivalence, 44
natural isomorphism, 44
natural numbers, 10
natural transformation, 43, 46, 52
naturality condition, 43
nearly constant presheaf, 109
node, 1
nullary product, 66
object of a category, 4
object of a graph, 1
objectwise products, 64
opposite of a category, 14, 29
ordered set, 9, 96
parallel pair, 82, 89
partial arrow, 106
partial arrows representable, 106
partial function, 6, 14
paste diagrams, 40
path, 4
path category, 16
Pfn, 6, 70
Pointwise Adjointness Theorem, 98
pointwise products, 64
poset, 9, 11, 12, 57, 96
postcondition, 88
power object, 104
powerset, 96, 104
powerset functor, 29
precondition, 88
preordered set, 9, 96
preserve a property, 33
preserve limits, 85
preserved by isomorphisms, 18
preserves canonical products, 67
preserves the product, 67
presheaf, 106
product, 14, 55, 65, 71, 95
product category, 27, 30
product cone, 55
product diagram, 55
programming language, 7, 67, 71, 76, 109
projection, 55
proof, 71
proper subobject, 21
pseudo-inverse, 35
pullback, 86
pullback diagram, 86
pushout, 90
R-algebra, 99
rational numbers, 90
recognized, 31
recognizer, 31
record type, 67
recursive function, 106
reduce, 48
reÔ¨Çect, 34
reÔ¨Çexive, 9
regular category, 89, 105
regular epimorphism, 89, 105
regular functor, 89
regular monomorphism, 83
Rel, 6, 70, 113, 116
relation, 6, 47
remainder, 13
representable functor, 51, 68
representative functor, 36
representative subcategory, 18
represents, 51, 62
restriction functions, 107
right adjoint, 94
right inverse, 23
rules of inference, 71
S-indexed set, 15, 28
Sem, 11
semantics, 76, 102
semigroup, 9, 11, 14, 18, 56
semigroup homomorphism, 11
semilattice, 70, 113
Set, 6
set-valued functor, 30, 51, 53, 106
shape graph, 37
sheaf, 108
simple graph, 1
singleton set, 2
slice category, 15, 40, 96
small, 5
source, 1
speciÔ¨Åcation, 55
‚àó-autonomous category, 115
start state, 31
state space, 30
state transition system, 30
strictly monotone, 11
string, 10
subcategory, 13, 27
subfunctor, 47
submonoid, 10
subobject, 21, 102
subobject classiÔ¨Åer, 103
subobject functor, 102, 103
substitutable, 79
sum, 69, 70
sum cocone, 69
sup semilattice, 70, 113
supremum, 70

128
Index
surjective, 23
switch map, 61
symmetric monoidal category, 111
target, 1
terminal object, 18
ternary product diagram, 65
topos, 103
transducer, 31
transitions, 30
transitive, 9
triple, 99
true (from 1 to ‚Ñ¶), 103
two-variable hom functor, 30
type, 15
type conversion, 22
typed Œª-calculus, 79
typed function, 15
typed set, 15
u-structure, 42
unary operation, 42
unary product, 66
underlying functor, 27
underlying set, 9, 42, 92
undirected path, 49
unit of a triple, 99
unit of an adjunction, 94
unitary identities (of a triple), 99
universal cone, 84
universal element, 53
universal image, 104
universal mapping property, 28, 56, 92, 94
universal sum, 105
upper semilattice, 70
variable element, 19, 25
variable set, 32
weakest precondition, 87
wide, 14
Yoneda embedding, 51, 78
Yoneda functor, 51
Yoneda Lemma, 53
Zk, 13

