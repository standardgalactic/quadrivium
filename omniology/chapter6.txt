Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML.............................................. 1
6.1. Why Use Client-Side Scripting?.......................................................................................................................................... 1
6.2. Working with the DOM........................................................................................................................................................ 2
6.3. XSLT Processing with JavaScript....................................................................................................................................... 6
6.4. Our CMS Project............................................................................................................................................................... 19
6.5. Summary........................................................................................................................................................................... 24
Chapter 6. Manipulating XML with JavaScript/DHTML
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
This PDF is exclusively for your use in accordance with the Safari Terms of Service. No part of it may be reproduced or transmitted in any form by any means without the prior
written permission for reprints and excerpts from the publisher. Redistribution or other use that violates the fair use priviledge under U.S. copyright laws (see 17 USC107) or that
otherwise violates the Safari Terms of Service is strictly prohibited.

Chapter 6. Manipulating XML with JavaScript/
DHTML
640
In  this chapter, we're going to learn how to manipulate XML data within your visitors' browsers
with JavaScript and DHTML. Along the way, you'll be introduced to the Document Object Model
(DOM).
1334027
Learning how to work with client-side tools and XML can be a very valuable bridge to success in
future projects. Combined with knowledge of server-side XML processing, client-side skills can
give you quite an edge in a complex project.
1334027
6.1. Why Use Client-Side Scripting?
661753
At first glance, it seems pretty silly to process XML data on the client side when such powerful
languages as PHP, ASP.NET, Java, and Perl exist to handle processing on the back end. But, if
you've been around the world of Web development for any length of time, you'll know that there
are circumstances in which it makes sense to handle things on the server side, and other conditions
that suit processing on the client side.
1334027
Processing data on the client side can help relieve server load and give the visitor a better, more
responsive experience of your site. For example, the use of server-side programming to perform a
task as simple as sorting a column in a table, or formatting some data, is unnecessary; it also forces
the user to wait longer than they should have to for such trivial operations. Client-side processing
of XML data can be a big help in situations like this.
1334027
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 1
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.
Copyright Safari Books Online #672274

6.2. Working with the DOM
661753
What is the DOM? It's the Document Object Model, a W3C Standard that allows you, the
programmer, to put together a document dynamically, and to navigate and manipulate its structure
and content.
1334027
In this chapter, we're going to spend some time on the DOM. Consider this discussion a precursor
to Chapter 7, where we'll get into more detail with PHP's SimpleXML library, and discuss DOM
and SAX, two alternate approaches to processing XML documents. There's a lot to cover, so buckle
your seat belts and get ready!
1334027
6.2.1. Loading Documents into Memory
672274
Earlier , we mentioned that most programming languages that interface with XML use an XML
parser to load XML documents into memory. Once they're loaded, information in the documents
can be retrieved and manipulated through the Document Object Model (DOM).
1334027
You can visualize the DOM's structure as a tree of nodes . The root of the tree is a Document node,
which has one or more child nodes that branch off from this trunk. Each of these child nodes may
in turn contain child nodes of their own, and so on.
1334027
Every node in the document offers some standardized functionality, described by the DOM standard
as the Node interface. The DOM standard supports roughly a dozen node types, each of which
contains specialized functionality on top of the standard Node interface. The Document is one such
node type. Element, Attr, and Text are others.
1334027
There are two useful methods by which we can load a DOM representation of an existing XML
document on the client side. The first is to load XML code from an existing file; the second is to
create the code as a JavaScript string and load it into the parser that way. A third method involves
creating what's called an XML Data Island directly inline with the HTML content, but, as this
method works only in Internet Explorer, we won't cover it here.
1334027
We'll examine both of the common methods in a moment, but first we need to learn how to
instantiate an XML parser.
1334027
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 2
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

6.2.2.1. Using the XML Parser
661753
To   manipulate or traverse an XML document in Internet Explorer, we first have to instantiate the
Microsoft XMLDOM parser. In Internet Explorer 5.0 and above, we can instantiate the parser using
JavaScript:
1334027
clientside-ie.html (excerpt)
<script type="text/javascript">
var xml = new ActiveXObject("Microsoft.XMLDOM");
…
</script>
Note: Although we will eventually implement a cross-browser solution for manipulating XML data on the
client side, let's start with an Internet Explorer-only solution for simplicity.
Once the parser is instantiated, we can load a file into it using a series of commands. In this example,
we load a file named menu.xml  into the parser.
1334027
clientside-ie.html (excerpt)
<script language="JavaScript">
var xml = new ActiveXObject("Microsoft.XMLDOM");
xml.async = false;
xml.load("menu.xml");
…
</script>
Note: Setting the async property of the xml variable to false ensures that the parser will wait until the
document is fully loaded before it does anything else.
Here's the XML file we'll use for the examples that follow in this section:
1334027
menu.xml
<?xml version="1.0" encoding="iso-8859-1"?>
<menu>
  <meal>
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 3
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

    <title>Buddha's Delight</title>
    <desc>A feast for the senses!</desc>
    <price>$4.95</price>
  </meal>
</menu>
If it's more suitable for your application, you can instead create a string variable to hold the XML
data, then feed it directly to the parser. Notice that to do this, you must use the loadXML method
instead of the  load method:
1334027
clientsidestring-ie.html (excerpt)
<script type="text/javascript">
var xmlcode = '<?xml version="1.0" encoding="iso-8859-1"?>';
xmlcode += '<menu><meal>';
xmlcode += '<title>Buddha\'s Delight</title>';
xmlcode += '<desc>A feast for the senses!</desc>';
xmlcode += '<price>$4.95</price>';
xmlcode += '</meal></menu>';
var xml = new ActiveXObject("Microsoft.XMLDOM");
xml.async = false;
xml.loadXML(xmlcode);
…
</script>
6.2.2. Accessing Different parts of the Document
672274
Now that we've successfully loaded a DOM representation of an XML document, we can access
the information it contains in a variety of ways. In theory, the properties and methods used to do
this are specified by the W3C DOM Recommendations  , but in practice different browsers
(especially Internet Explorer) have defined their own interfaces, sometimes rather loosely inspired
by the standard.
1334027
When the parser loads an XML document, what it gives you in return is a reference to the document
itself. From this, you can get a reference to the root element in the document (in our example, the
<menu> element) with the property name documentElement. The children of that element are in
turn accessible through the childNodes property.
1334027
clientside-ie.html (excerpt)
var nodes = xml.documentElement.childNodes;
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 4
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

The childNodes property, and thus the nodes variable in this example, contains a NodeList . In
accordance with the DOM standard, you can access the elements of a NodeList by passing a
numerical index to the item method, with 0 corresponding to the first node in the list. In this example,
therefore, nodes.item(0) would return a reference to the first child element of the <menu>
element—the <meal> element.
1334027
The DOM standard calls for nodes to support a textContent property, which would return all of the
text contained by a given element and all of its descendants. Internet Explorer doesn't support this
property, but it does support a nonstandard text property that does the same thing. We can use this
property to print out all of the text contained in the first <meal> element in the document:
1334027
clientside-ie.html (excerpt)
document.write(nodes.item(0).text);
The result should look something like this:
1334027
Buddha's Delight A feast for the senses! $4.95
What if we wanted to print out only the text in the <title> element of the first meal? To do this,
we'd need to modify our JavaScript slightly:
1334027
var nodes = xml.documentElement.childNodes.item(0).childNodes;
document.write(nodes.item(0).text);
When we run the code now, the text "Buddha's Delight" is displayed in the browser window.
1334027
Note:   Internet Explorer (and indeed many other DOM implementations) lets you treat NodeLists as arrays
to simplify the code you use to work with them. In this example, you could use array syntax to access nodes
instead of the item method :
This method of accessing text values within an XML file by numerical index is useful, but it can
get a little cumbersome. Fortunately, there is another way to approach the problem.
1334027
6.2.3.2. Accessing XML Elements by Name
661753
You can use the   getElementsByTagName method to retrieve a list of nodes of a given type from
your document. This method retrieves all elements of the specified name that occur under the node
on which the method is called. For example, to print "Buddha's Delight" from our sample menu
document, you could write the following code:
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 5
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

1334027
clientside-bytagname-ie.html (excerpt)
document.write(xml.getElementsByTagName("title").item(0).text);
With a larger menu document, you could pick up all the titles and display each as an HTML header
with this code:
1334027
var titles = xml.getElementsByTagName("title");
for (var i = 0; i < titles.length; i++) {
  document.write("<h1>" + titles.item(i).text + "</h1>");
}
6.3. XSLT Processing with JavaScript
661753
In this    section, we'll create a simple XML file and a simple XSLT file. Then, we'll use JavaScript
on Internet Explorer to process the two together and print out some results.
1334027
Note: Again, this first example will work only on Internet Explorer! We'll look at cross-browser compatible
methods later in this chapter.
Ready to go? Here's the very simple XML file:
1334027
test.xml
<?xml version="1.0" encoding="iso-8859-1"?>
<body>
<header>This is a simple headline</header>
<para>Some random text. Notice that in our XML source, we aren't
  pointing to a specific XSLT file.</para>
</body>
One thing you should notice right away is that we haven't used a <xml-stylesheet> processing
instruction in this file. But, before we get into all that, let's create the style sheet for this XML file.
1334027
test.xsl
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 6
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns="http://www.w3.org/1999/xhtml">
  <xsl:output method="xml" indent="yes" omit-xml-declaration="yes"
      media-type="application/xhtml+xml" encoding="iso-8859-1"
      doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"
      doctype-system=
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"/>
  <xsl:template match="body">
    <html>
      <head>
        <title>Processing XML/XSLT with JavaScript</title>
        <meta http-equiv="content-type"
            content="application/xhtml+xml; charset=iso-8859-1"/>
      </head>
      <body>
        <xsl:apply-templates/>
      </body>
    </html>
  </xsl:template>
  <xsl:template match="header">
    <h1><xsl:apply-templates/></h1>
  </xsl:template>
  <xsl:template match="para">
    <p><xsl:apply-templates/></p>
  </xsl:template>
</xsl:stylesheet>
Now, let's build a Web page to perform the transformation. This file will contain mostly JavaScript
code that will load the XML and XSLT files into memory, process them, and display the results.
Let's take a look at what that looks like. Then, we'll walk through it line by line:
1334027
jsTest-ie.html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Processing XML/XSLT with JavaScript</title>
<meta http-equiv="Content-Type"
    content="text/html; charset=iso-8859-1" />
<script type="text/javascript">
var xml = new ActiveXObject("Microsoft.XMLDOM");
xml.async = false;
xml.load("test.xml");
var xsl = new ActiveXObject("Microsoft.XMLDOM");
xsl.async = false;
xsl.load("test.xsl");
window.onload = function() {
  document.write(xml.transformNode(xsl));
}
</script>
</head>
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 7
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

<body>
</body>
</html>
Inside the <script>    tag, the code creates an instance of the Microsoft XML parser (XMLDOM)
and loads our XML file (test.xml) into memory. This part should be extremely familiar to you—
we learned to do this earlier, in our introduction to the DOM.
1334027
jsTest-ie.html (excerpt)
var xml = new ActiveXObject("Microsoft.XMLDOM");
xml.async = false;
xml.load("test.xml");
The second snippet of code creates another instance of XMLDOM and loads our XSLT file
(test.xsl) into memory. Since XSLT files are formatted as XML, you can load them just as you
would any other XML file:
1334027
jsTest-ie.html (excerpt)
var xsl = new ActiveXObject("Microsoft.XMLDOM");
xsl.async = false;
xsl.load("test.xsl");
The remainder of the code waits until the document finishes loading, then transforms the XML
document using the XSL style sheet, and replaces the page with the results of the transformation.
1334027
jsTest-ie.html (excerpt)
window.onload = function() {
  document.write(xml.transformNode(xsl));
}
Here, we've used Internet Explorer's  transformNode method, which takes as its argument the object
that holds the XSL file. Because we're wrapping this operation inside a call to document.write , the
entire expression forms a fairly concise command that says, in effect: "take our XSLT and apply it
to our XML document, then display the resulting document."
1334027
Figure 6-1 shows how our work appears in Internet Explorer.
1334027
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 8
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Figure 6-1. Using JavaScript to transform XML in IE.
Now, try to look at the same file in Firefox  . You'll find that it doesn't display at all. If you use the
built-in JavaScript Console, you'll see a message like that shown in Figure 6-2.
1334027
Figure 6-2. Problems arising with Firefox.
This is because Firefox (and other Mozilla-based browsers) cannot identify the ActiveXObject that
we're attempting to create on line 10. We need to make some changes to our script so that it works
across browsers .
1334027
6.3.1. Making our Test Script Cross-Browser Compatible
672274
Now  we know that we have to make our little script work in both IE and Mozilla-based browsers
like Firefox. Each type of browser handles XML loading in a different fashion, so any script that
will work on both will have to do some browser detection and respond accordingly.
1334027
The hard way to do this is to learn from scratch how to load XML in Firefox and Internet Explorer,
and do all the necessary browser detection yourself. A better way is to open your Web browser,
and download the latest copy of the Sarissa JavaScript XML library.[1] The package comes with a
number of JavaScript (.js) files, and various documentation files.
1334027
[1] This book was written and tested with Sarissa 0.9.6, the latest version as of this writing. As the library is still under development, some changes may have been made to the API by
the time you read this.
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 9
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Basically, Sarissa makes it possible for you to use a single API to make your JavaScript XML
handling work in both types of browser. It's a huge time-saver! It works fairly reliably on Internet
Explorer 5.5 and above, Firefox 1.0 and above, Netscape 6 and above, and Mozilla 1.6 and above.
[2]
1334027
[2] Many of its features also work in Safari browsers, but XSLT transformations, sadly, are not among them.
This example uses Sarissa to achieve what we did in the last section:
1334027
jsTest-ie2.html (excerpt)
<script type="text/javascript" src="sarissa/sarissa.js"></script>
<script type="text/javascript">
var xml = Sarissa.getDomDocument();
xml.async = false;
xml.load("test.xml");
var xsl = Sarissa.getDomDocument();
xsl.async = false;
xsl.load("test.xsl");
window.onload = function() {
  var xslt = new XSLTProcessor();
  xslt.importStylesheet(xsl);
  var out = xslt.transformToDocument(xml);
  document.write(Sarissa.serialize(out));
};
</script>
This code should print the transformed XML to the page for display. Let's look at the differences
between this and the Internet Explorer-specific code of the previous example.
1334027
First, we must use the Sarissa class' getDomDocument method to create XML documents in
memory:
1334027
jsTest-ie2.html (excerpt)
var xml = Sarissa.getDomDocument();
We must also use a class called XSLTProcessor to perform the style sheet transformation. After
creating the object, we load our style sheet's DOM representation using importStylesheet :
1334027
jsTest-ie2.html (excerpt)
  var xslt = new XSLTProcessor();
  xslt.importStylesheet(xsl);
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 10
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Now, whereas Internet Explorer lets us transform our document directly to an XML string, most
other browsers (and therefore Sarissa) only support transforming to a DOM representation of the
output document. We must then use the Sarissa class' serialize method to convert it to a string for
output:
1334027
jsTest-ie2.html (excerpt)
  var out = xslt.transformToDocument(xml);
  document.write(Sarissa.serialize(out));
Now, if you test this new script in Internet Explorer, you'll see that it produces the same output as
the browser-specific example. Unfortunately, as Figure 6-3 illustrates, we run into a bit of a glitch
when we test the script in Firefox  and other Mozilla browsers.[3]
1334027
[3] This issue was fixed with the release of Firefox 1.5 (after this book first went to print), where the example should work perfectly. If you need to support users running older browsers
like Firefox 1.0, read on for the work-around; otherwise, feel free to skip to the next section.
What's going on here? If you use JavaScript's alert  function to display the XML code of the output
document, you'll see the code in Figure 6-4. While this is a perfectly valid XHTML document, a
namespace prefix  of a0 has been used for the XHTML tags, instead of allowing XHTML to be
the default namespace in the document. As a result, the built-in CSS style rules that the browser
uses to apply basic styling to HTML documents do not match any of the tags, and you get unstyled
output.
1334027
Figure 6-3. Firefox displaying the XHTML without styling due to a serialization glitch.
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 11
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Figure 6-4. A namespace prefix added to the document.
This namespace prefix is an annoying product of Firefox's built-in XML serialization functionality
—there is no practical way to get rid of it, short of removing the namespace declaration at the top
of the test.xsl style sheet; unfortunately, that trips up the XSLT processor in Internet Explorer,
causing the transformation there to fail completely.
1334027
The best workaround I can suggest is messy, and requires you to work around a couple more browser
limitations, but it works. Since we have the transformed document as a DOM representation in
memory, we can use DOM methods to extract the element(s) we require from the transformed
document and insert them into our existing document. Here's the code:
1334027
jsTest.html (excerpt)
window.onload = function() {
  var xslt = new XSLTProcessor();
  xslt.importStylesheet(xsl);
  var out = xslt.transformToDocument(xml);
  var docBody = document.getElementsByTagName('body').item(0);
  var outBody = out.documentElement.childNodes.item(1);
  // Clear the current document body
  while (docBody.hasChildNodes()) {
    docBody.removeChild(docBody.firstChild);
  }
  // Refill it with the 'out' document body's children
  for (var i = 0; i < outBody.childNodes.length; i++) {
    var node = outBody.childNodes.item(i);
    node = document.importNode(node, true);
    docBody.appendChild(node);
  }
};
Let's step through this somewhat convoluted solution, as it contains a couple of method calls with
which you are probably not yet familiar.
1334027
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 12
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Once the transformation has occurred, the first thing our script does is obtain DOM references to
the <body> elements of both the currently-displayed document, and the document that resulted
from the transformation:
1334027
jsTest.html (excerpt)
  var docBody = document.getElementsByTagName('body').item(0);
  var outBody = out.documentElement.childNodes.item(1);
You'll notice that while the method we've used to get the displayed document's <body> is quite
straightforward (look for the first <body> element in the document), we use a more roundabout
way of getting the <body> of the transformation output (getting the second child of the document's
root element). A bug or limitation of Internet Explorer's  XML support prevents us from accessing
tags by name in the result of an XSLT transformation, so this alternative approach is needed.
1334027
Our next task is to empty out the <body> of our displayed document, by deleting all of its child
nodes (be they text, elements, or anything else):
1334027
jsTest.html (excerpt)
  // Clear the current document body
  while (docBody.hasChildNodes()) {
    docBody.removeChild(docBody.firstChild);
  }
The methods and properties used here, though new, are part of the DOM standard and are relatively
self-explanatory. hasChildNodes returns true if the element has any child nodes; removeChild
removes a child node from the element; and the firstChild property is equivalent to
childNodes.item(0).
1334027
With the <body> of the displayed document now empty, we can fill it with nodes from our
transformation output document:
1334027
jsTest.html (excerpt)
  // Refill it with the 'out' document body's children
  for (var i = 0; i < outBody.childNodes.length; i++) {
    var node = outBody.childNodes.item(i);
    node = document.importNode(node, true);
    docBody.appendChild(node);
  }
This code is a little less self-explanatory, but is equally straightforward. The for loop iterates through
each of the child nodes of the <body> of the transformation output document, using the length
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 13
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

property of the childNodes collection to get the number of these nodes. We use the importNode
method of the currently-displayed document to create copies of each of these nodes (including their
contents, as indicated by the true second argument) for use in that document. Those nodes are
then added to the currently-displayed document's <body> element using the appendChild method.
1334027
The result of this process is that the contents of the transformed document are added to and displayed
as part of the existing page, as shown in Figure 6-5. This solution is effective so long as you didn't
need to display the document title, or anything else inside the <head> element of the transformation
output.
1334027
Figure 6-5. The XSLT output is correctly displayed in Firefox (at last).
Why not just use similar techniques to replace the entire displayed document, rather than just the
contents of the <body>? A limitation of Internet Explorer's DOM implementation actually
prevents this, once again. Internet Explorer uses completely different DOM libraries to work with
documents displayed in the browser and to perform XSLT transformations of documents in
memory. These two libraries were not designed to work together. The Sarissa library makes a valiant
attempt at overcoming this limitation, but the importNode method that is used here to copy nodes
from the transformed document to the displayed document will only work on elements that are
allowed within the <body> of an HTML document, thus forcing us to approach the problem as
we did.
1334027
Thankfully, you'll rarely need to perform an XSLT transformation on the client side to produce a
full HTML document for display. More often, you'll use XSLT to generate a small document
fragment, in which case the technique shown here of inserting the result using the DOM is
completely appropriate, not an inconvenient alternative.
1334027
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 14
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

6.3.2. Creating Dynamic Navigation
672274
Now   that we understand how to apply style sheets with JavaScript, let's implement something a
little more complicated. Let's extract some XML from a file and use it to build a navigation system
with JavaScript.
1334027
First, let's create a simple file that holds our navigation menu in XML format:
1334027
navmenu.xml
<?xml version="1.0" encoding="iso-8859-1"?>
<menu>
  <item label="home" target="index.html"/>
  <item label="services" target="services.html"/>
  <item label="about us" target="aboutus.html"/>
  <item label="contact us" target="contactus.html"/>
  <item label="kb" target="kb.html"/>
</menu>
Let's create a very simple JavaScript (using the  Sarissa library for cross-browser functionality),
which will load this menu file and display it as a very simple list of HTML links.
1334027
The first thing we need to do is load the Sarissa libraries:
1334027
navmenu.html (excerpt)
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>XML Based Menu</title>
<meta http-equiv="Content-Type"
    content="text/html; charset=iso-8859-1" />
<script type="text/javascript" src="sarissa/sarissa.js"></script>
Next, we'll create a JavaScript function called  initMenu. This function loads our navmenu.xml file,
and pulls all the <item> nodes into the JavaScript nodes variable.
1334027
navmenu.html (excerpt)
<script type="text/javascript">
function initMenu(xmlFile) {
  var xml = Sarissa.getDomDocument();
  xml.async = false;
  xml.load(xmlFile);
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 15
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

  
  var nodes = xml.documentElement.childNodes;
Now we'll use a for loop to look at each <item> in the menu. Since Firefox counts the whitespace
between tags as text nodes, we must ensure each time through the for loop that we're dealing with
an element node. This is accomplished by checking the nodeType  property to see if it equals
Node.ELEMENT_NODE.
1334027
navmenu.html (excerpt)
  for (var i = 0; i <= nodes.length - 1; i++) {
    if (nodes.item(i).nodeType != Node.ELEMENT_NODE) continue;
With that done, we can use the getAttribute method of the element node to grab the <label> and
<target> values as we want:
1334027
navmenu.html (excerpt)
    var output = '<a href="' +
        nodes.item(i).getAttribute('target') + '">' +
        nodes.item(i).getAttribute('label') + '</a><br />';
    document.write(output);
  }
}
</script>
</head>
Finally, let's make that all-important call to  initMenu in the body of the document, passing in the
name of our menu file.
1334027
navmenu.html (excerpt)
<body>
<h1>My Menu</h1>
<script type="text/javascript">
initMenu('navmenu.xml');
</script>
</body>
</html>
Figure 6-6 illustrates the results.
1334027
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 16
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

6.3.3.1. An Alternative Approach
661753
If you're already comfortable with JavaScript, you'll know that there's a much better way of doing
things than to call document.write to print out the items of our menu.
1334027
A more elegant approach is to set aside a container element (typically a <div>   ) with a known
ID. We can then write the contents of that element on-the-fly using our JavaScript code.
1334027
Figure 6-6. A simple menu.
Here's our new HTML:
1334027
navmenu2.html (excerpt)
<body>
<h1>My Menu</h1>
<div id="menudiv"></div>
</body>
</html>
Now, we must go back to our for loop. We use the getElementById  method to select our
<div>, and write our output to that element's innerHTML property.
1334027
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 17
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

navmenu2.html (excerpt)
  var output = '';
  for (var i = 0; i <= nodes.length - 1; i++) {
    if (nodes.item(i).nodeType != Node.ELEMENT_NODE) continue;
    output += '<a href="' + nodes.item(i).getAttribute('target') +
        '">' + nodes.item(i).getAttribute('label') + '</a><br />';
  }
  document.getElementById('menudiv').innerHTML = output;
}
Finally, we set up our  initMenu function to be run when the rest of the document finishes loading:
1334027
navmenu2.html (excerpt)
window.onload = function() {
  initMenu('navmenu.xml');
};
Here's our new code in its entirety:
1334027
navmenu2.html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>XML Based Menu</title>
<meta http-equiv="Content-Type"
    content="text/html; charset=iso-8859-1" />
<script type="text/javascript" src="sarissa/sarissa.js"></script>
<script type="text/javascript">
function initMenu(xmlFile) {
  var xml = Sarissa.getDomDocument();
  xml.async = false;
  xml.load(xmlFile);
  var nodes = xml.documentElement.childNodes;
  var output = '';
  for (var i = 0; i <= nodes.length - 1; i++) {
    if (nodes.item(i).nodeType != Node.ELEMENT_NODE) continue;
    output += '<a href="' + nodes.item(i).getAttribute('target') +
        '">' + nodes.item(i).getAttribute('label') + '</a><br />';
  }
  document.getElementById('menudiv').innerHTML = output;
}
window.onload = function() {
  initMenu('navmenu.xml');
};
</script>
</head>
<body>
<h1>My Menu</h1>
<div id="menudiv"></div>
</body>
</html>
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 18
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Now that we have a function that prints our output to a <div> element, we can reuse this code and
place our menu wherever we need it to appear on the page.
1334027
In the next section, we'll apply this knowledge to our CMS project by creating categories of articles
, then defining a menu system for those categories.
1334027
6.3.3.2. What's the Point of Learning all This?
661753
After reading all this, some of you may still be wondering, "Well, this is pretty silly—I can do all
this with PHP on the server side and not have to worry about how different browsers handle things."
1334027
I have a few answers for that sort of sentiment:
1334027
1. You're exactly right.
2. Don't forget that learning the DOM is a useful tool not only for processing XML data in general, but for fiddling with the structures of
HTML documents. This is a fundamental component of Dynamic HTML (DHTML) node collapsing  , and the better you understand
it, the better you can apply other DHTML techniques.
3. You need to remember that it's sometimes very useful to offload certain kinds of processing to the client. While this particular example
showed a hard-coded navigation menu, it's not difficult to imagine a more customized example that uses data stored in cookies on the
user's machine to create a personalized navigation menu. That kind of work can be left to the client without burdening the server
unnecessarily.
Yes, XML can be seen as a linear sequence of characters and tags, but it can also be seen as a
hierarchical tree structure. Having an understanding of the way XML documents are loaded into
the DOM can only enhance your ability to make wise decisions about which type of server-side
parsing you will use.
1334027
There's nothing inherently magical about XML beside the fact that it provides a standardized
representation of data; in fact, with semantically appropriate tags, it can become information. What
is somewhat magical is the fact that XML structures can be transformed into other entities, such as
DOM object trees, which can themselves be processed, navigated, and changed.  
1334027
6.4. Our CMS Project
661753
Now that we've learned how to use JavaScript to load XML data, and to work with that data, let's
use these newfound skills to add some capabilities to our CMS project.
1334027
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 19
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Note: As I have already mentioned, client-side XML processing is currently not supported in all browsers.
In particular, Safari and Opera browsers do not yet support even the simplest of XSLT transformations. If
you plan to develop a CMS for public consumption, you should therefore steer clear of such techniques until
wider browser support for these features is available. The server-side techniques I'll present in Chapter 7
are more powerful and free of browser incompatibilities.For the sake of example, I'll implement a couple of
minor features of our CMS using client-side XML processing, but for real-world applications you should keep
browser compatibility issues in mind.
Right now, the site can display Web copy, articles, news items, and the like. At some point, though,
you can imagine that the Website will be full of content items. There may be hundreds of articles,
news items, and so on. So many, in fact, that the content items may become a little hard to sift
through.
1334027
What we need to do is add categories to the site. A smart, centralized category listing, and an easy
way to assign content items to categories, can make it easier for visitors to navigate an otherwise
undifferentiated mass of content.
1334027
When I start talking about categorization, most of my friends and colleagues usually roll their eyes
and yearn to leave the room. But, I love to talk about categorization, ontologies, and things like
that. I find them utterly fascinating in all kinds of ways. However, I promise to restrain myself in
this chapter—this isn't a book about categorization, after all.
1334027
The easiest way to go about all this is to jump right in and discuss things as we go along. I'll try to
keep the more esoteric discussions to sidebars, so you can come back to them later if you're in a
hurry right now.
1334027
Here is a category listing for a site devoted to Web development topics:
1334027
categories.xml
<?xml version="1.0" encoding="iso-8859-1"?>
<categories>
  <category label="xml" status="live" id="1"/>
  <category label="php" status="live" id="2"/>
  <category label="asp" status="live" id="3"/>
  <category label="javascript" status="live" id="4"/>
  <category label="perl" status="live" id="5"/>
</categories>
Each category is described by its label, its ID , and its visibility status. The <status> attribute
here is very important, because it allows us to remove from view all articles from any given category
as needed. Giving each category item its own unique ID will also allow us to reference that category
easily in other XML files.
1334027
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 20
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

6.4.1. Assigning Content to Categories
672274
Okay, now that we have a category listing, how do we tell our XML-powered Website which content
items belong to which categories? With the aid of a <categoryid> element that we'll build into
news items, articles, and other content types.
1334027
A sample news document might look like this:
1334027
news101404061004.xml
<?xml version="1.0"?>
<news id="news101404061004">
  <authorid>1</authorid>
  <headline>xml headline 2</headline>
  <categoryid>1</categoryid>
  <url>http://www.myerman.com/</url>
  <description>yeah man!</description>
  <keywords>xml</keywords>
  <status>live</status>
  <pubdate>news101404061004</pubdate>
</news>
Our next step is to use this information in a meaningful way.
1334027
6.4.2. Retrieving Content by Category
672274
Finally, we come to the most complicated part of the process. What we need to do is allow the user
to browse our content by category. When a user clicks on a category, we need to display links to
all the content items that fall under that category.
1334027
To this end, we'll add a new page to our site. First of all, we want to include our all-important header
and navigation elements. Initially, the page should show a list of links—one for each category on
our site—generated dynamically with JavaScript, as we've seen in this chapter. Each of these links
will reload the same page, but with a list of the content items in that category displayed, thanks to
some PHP code.
1334027
Let's do it one piece at a time. First, we initialize our PHP file by including common.inc.php and
loading the Sarissa library:
1334027
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 21
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

cats.php (excerpt)
<?php
include_once 'common.inc.php';
?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Browse by Category</title>
<meta http-equiv="content-type"
    content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="xmlcms.css" type="text/css" />
<script type="text/javascript" src="sarissa/sarissa.js"></script>
                        
The JavaScript that will build the list of categories follows the exact same pattern we saw for the
navigation menu example earlier in this chapter: a function named  initMenu will be called when
the document first loads.
1334027
cats.php (excerpt)
<script type="text/javascript">
function initMenu(xmlFile) {
  var xml = Sarissa.getDomDocument();
  xml.async = false;
  xml.load(xmlFile);
  
  var nodes = xml.documentElement.childNodes;
  var output = '';
  for (var i = 0; i <= nodes.length - 1; i++) {
    if (nodes.item(i).nodeType != Node.ELEMENT_NODE) continue;
    if (nodes.item(i).getAttribute('status') == 'live') {
      output += '<a href="cats.php?catid=' +
          nodes.item(i).getAttribute('id') + '">' +
          nodes.item(i).getAttribute('label') + '</a><br />';
    }
  }
  document.getElementById('menudiv').innerHTML = output;
}
window.onload = function() {
  initMenu('xml/categories.xml');
};
</script>
</head>
The only significant addition (shown in bold here) is an if statement that checks that the
<status> attribute of each category is <live> before displaying it in the list.
1334027
Next, we continue with our familiar boilerplate code for our basic HTML layout, making sure to  
include our top navigation and search sidebar files:
1334027
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 22
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

cats.php (excerpt)
<body>
<?php
include 'navtop.inc.php';
?>
<div id="navSide">
  <?php
  include 'search.inc.php';
  include 'news.inc.php';
  ?>
</div>
The final part is the hardest: we have to fill in the content area of the page. First off, we need a
<div>  element to house the category menu that will be generated by the JavaScript code above:
1334027
cats.php (excerpt)
<div id="mainContent">
  <h1>Browse By Category</h1>
  <div id="menudiv"></div>
  <hr/>
That takes care of letting the user select a category, but once that's done we need to display the
content items in the selected category. That's where the PHP code comes in. Looking for a $_GET
['catid'] value, the script rifles through the xml directory in search of news, article, or Web
copy files, spotting those that have a matching <categoryid> element and a <status> of
live.
1334027
cats.php (excerpt)
  <?php
  if (isset($_GET['catid'])) {
    $handle = opendir($fileDir);
    while (($file = readdir($handle)) !== FALSE) {
      if (is_dir($fileDir . $file)) continue;  
      if (!eregi("^(news|article|webcopy).*\.xml$", $file))
        continue;
      
      $xml = simplexml_load_file($fileDir . $file);
      if ((string)$xml->categoryid == $_GET['catid'] &&
          (string)$xml->status == "live") {
        $id = htmlentities($xml['id']);
        $label = htmlentities($xml->headline);
        echo "<a href=\"innerpage.php?id={$id}\">{$label}</a> ";
      }
    }
  }
  ?>
</div>
</body>
</html>
Our last step is to open our search widget file and add the following line to the bottom of the file:
1334027
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 23
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

search.inc.php (excerpt)
<p><a href="cats.php">Browse by Category</a></p>
Doing this will create a link to cats.php from every page on the site. Figure 6-7 shows what our
cats.php page looks like when someone has clicked on a category listing.  
1334027
6.5. Summary
661753
Now that we've learned how to manipulate XML with JavaScript and DHTML, it's time to turn our
attention to PHP's XML functions. In the next chapter, we'll delve deeper into PHP 5's SimpleXML
functions, as well as some other DOM-related functions. We'll also round out our CMS tool by
creating all the administrative forms we'll need to manage the site.
1334027
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 24
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Figure 6-7. Browsing by category.
Chapter 6. Manipulating XML with JavaScript/DHTML
Page 25
Return to Table of Contents
Chapter 6. Manipulating XML with JavaScript/DHTML
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

