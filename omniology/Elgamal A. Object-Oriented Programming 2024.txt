Object-Oriented 
Programming

Object-Oriented 
Programming
By
Amany Fawzy Elgamal
Cambridge 
Scholars 
Publishing

Object-Oriented Programming
By Amany Fawzy Elgamal
This book first published 2024
Cambridge Scholars Publishing
Lady Stephenson Library, Newcastle upon Tyne, NE6 2PA, UK
British Library Cataloguing in Publication Data
A catalogue record for this book is available from the British Library
Copyright © 2024 by Amany Fawzy Elgamal
All rights for this book reserved. No part of this book may be reproduced, 
stored in a retrieval system, or transmitted, in any form or by any means, 
electronic, mechanical, photocopying, recording or otherwise, without 
the prior permission of the copyright owner.
ISBN (10): 1-5275-6425-8
ISBN (13): 978-1-5275-6425-1

Table of Contents
Chapter On e............................................................................................ 1
Introduction
Chapter Tw o   
6
UML
Chapter Th ree   
43
Object-Oriented Programming Concepts
Chapter Fo ur   
92
Inheritance
Chapter Fi ve   
109
Encapsulation
Chapter Si x   
124
Polymorphism
Bibliography   
150

Chapter One
Introduction
In Structured Programming, a program is comprised of a set of 
instructions. Small programs are generally easy to understand, but larger 
ones, containing hundreds of statements, can be difficult to comprehend 
unless they are divided into smaller parts. Consequently, functions and 
procedures are utilized to make these programs easier to read and 
understand.
The standard approach to designing software systems involves identifying 
the problem, and then developing a set of functions that can accomplish 
the required tasks. If these functions are too complex, they are further 
broken down until they become simple enough to understand. This process 
is known as functional decomposition.
Data is usually stored in a database of some sort, or it might be held in 
memory as global variables.
Consider a simple example: a training center system that stores data about 
students and teachers, and can record information about available courses. 
This system also tracks each student and the courses in which they are 
enrolled. A potential functional design for this system would involve 
writing the following functions:
add_student
enter_for_exam
check_exam_marks
issue_certificate
expel_student

2
Chapter One
Furthermore, a data model is needed to store information about students, 
trainers, exams, and courses, requiring the design of a database schema to 
hold this data, as shown in Figure 1.1.
Figure 1.1: A database schema for a training center system
These functions depend on this data. For instance, the “add_student” 
function will modify the “students” data, and the “issue_certificate” 
function needs to access the student's data to know the details of the 
student who needs the certificate, as well as the exam data. Figure 1.2 
illustrates this data and the functions associated with it, showing the 
dependency lines.
Figure 1.2: Dependency lines between functions and data.

Introduction
3
Problems arise when things become more complex, as the difficulty of 
maintaining the system increases.
For example, if we find that storing a student’s date of birth as a two-digit 
number to represent the year was a bad idea, the simple solution is to 
change the birthdate field in the Students’ table from two to four digits for 
the year number. However, this change may cause unforeseen side effects. 
The data for exams, courses, and tutors all depend on the data in the 
Students’ table, so we may inadvertently disable the add_student, 
enter_for_exams, issue_certificate, and expel_student functions. The 
"add_student" function will certainly not work as it expects the year of 
birth in the form of a two-digit number.
To solve problems facing programmers, such as the one mentioned above, 
the concept of Object-Oriented Programming (OOP) is adopted. Two 
related issues are the absence of any restrictions on functions accessing 
global data in the program, and the lack of a complete connection between 
the functions and data, which is at odds with practical reality.
Consider a store management program. One piece of global data is the 
variable used to store the set of items in the store. Different functions in 
the program access this variable to insert a new item, display existing 
items, or modify an item. In a procedural program, there are usually two 
basic types of data or variables: local and global. Local data is specific to 
each function, accessible and used solely within its function, making it 
hidden inside this function.
In the store program, for example, the Display() function uses local data 
that is completely linked to its function and cannot be modified through 
any other function. If two or more functions share the same data, then this 
data must be global, where any function within the program can access it.
Managing many functions and much public data (variables) can lead to an 
increase in errors resulting from accessing those variables, where one of 
the functions may accidentally modify one of the global variables.
Another issue is the difficulty of understanding the overall structure of the 
program, as well as the challenge of modifying the program. Any change 
in a global variable may require modifying all functions that use this 
variable. In the store program, for example, if we want to change the 
product code from a 5-digit to a 12-digit number, which requires changing 
the data type from short to long, we must modify all functions that use this 

4
Chapter One
variable to handle data of type long instead of short. Thus, separating data 
from functions is problematic, which is inconsistent with practical reality.
In our daily life, we deal with objects such as people, cars, and so on, 
which are not merely functions or data, but entities that contain attributes 
and behaviors.
Attributes are the various elements associated with an object that uniquely 
define it. For example, in the case of people, eye color, height, and job, 
and in the case of cars, horsepower, and the number of doors, are all 
attributes equivalent to data within the program.
Behavior refers to the operations that an entity performs in real life in 
response to certain events. This behavior is equivalent to the function 
inside the program.
Neither data alone nor functions alone are sufficient to represent objects in 
real life as efficiently as desired. The fundamental idea of OOP languages 
is to group the data and functions into a single unit called an object. This 
way, we can effectively model real-world objects in our programs. An 
object-oriented design for the training center system mentioned earlier 
might involve objects for Students, Courses, and Exams, each with its own 
data and functions. The Student object would have data like name and 
birthdate and functions like enroll_in_course(). This encapsulation of data 
and functions into objects leads to more intuitive, maintainable, and 
flexible programs.
In the context of our previous store management program example, each 
item in the store could be represented as an object, with attributes such as 
name, price, and quantity, and methods such as restock() or sell(). The 
item’s code could be changed from a 5-digit to a 12-digit number simply 
by modifying the Item class, without the need to change every function 
that uses this item code.
Thus, in OOP, the data and the operations that can be performed on it are 
combined into a single entity, making it easier to understand how a 
program works. Additionally, OOP provides several benefits such as 
encapsulation, inheritance, and polymorphism that make it easier to 
design, implement, and manage software systems.
A program written in the OOP style differs from a program written in a 
structured style in two ways.

Introduction
5
1- 
Program building unit:
The program written in the structural style has a main programming unit 
and a group of sub-units. The sub-units are called from the main unit. As 
for the program written in the OOP style, the program unit becomes the 
class, which is a template for defining objects.
2- 
Dealing with data:
Where in the structural program, the programmer's effort is focused on the 
program code, that is, the lines of the program that handle the flow of 
operations, while the view of the data is a secondary view. OOP considers 
the data an important part of the program. Thus, we have a library not only 
of functions, but a library of classes that contain data and functions.
In summary, while structured programming is a powerful tool for creating 
simple to moderately complex programs, object-oriented programming 
offers a more flexible and intuitive approach for developing complex 
software systems. However, the best approach depends on the specific 
needs and constraints of the project at hand.
In the rest of this book, we will cover the details of OOP concepts.

Chapter Two
UML
Unified Modeling Language (UML) is a visual modeling language that 
provides developers (working in the field of analysis and design of object- 
oriented systems) with diagrams and methods to visualize, create, and 
document software systems, and to model the organizations that use these 
systems. Note that it is not a way to build or develop systems; it will not 
direct them on what to do first and what to do next. It will not tell you how 
to design the system but it will help you with modeling.
Several participants participate in the development of software systems, 
each with a role, for example:
- 
Analysts
- 
Designers
- 
Programmers
- 
Testers
Each of them is interested in different aspects of the system, and needs a 
different level of detail. For example, the programmer needs to understand 
the design of the system in order to convert it into code. The system 
analyst is concerned with the behavior of the system as a whole.
UML attempts to provide a highly expressive language so that participants 
can take advantage of system diagrams. It has become the approved 
language for modeling software operations after it has been widely 
accepted by those interested in building software. This language provides 
a simplified symbolic means to express various models of software 
through which it is easy for analysts, designers, programmers, and clients 
to communicate with each other and pass information in a concise, unified 
format. This aspect is similar to building schemes in architecture or 
electrical circuit diagrams that can be understood and dealt with among 
workers in the field.
Between 1989 and 1994, there were a large number of software modeling 
languages, each with its own symbols and rules, and each language had 

UML
7
elements similar to the elements of other languages without an integrated 
language that satisfies the software needs. Until the mid-nineties, three 
methodologies appeared. Each methodology has its own strengths and 
these methodologies are:
1. Booch’s methodology is characterized by quality in terms of design 
and implementation. Grady Booch worked extensively on the Ada 
language, and had a major role in the development of Object 
Oriented techniques for the language. Despite the strength of 
Booch’s methodology, the symbols in it were not well accepted.
2. Object Modeling Technique (OMT), which is the best technique in 
analyzing information systems with big data.
3. OOSE (Object Oriented Software Engineering) methodology is a 
powerful tool as a good way to understand the behavior of an entire 
system.
In 1994, Jim Rumbaugh, founder of OMT, left General Electric and joined 
Booch to work for Rational Corp. The purpose of the collaboration was to 
integrate their ideas and pour them into a unified methodology. Then the 
creator of OOSE, Ivar Jacobson, also joined Rational, and his ideas were 
included in the unified methodology called the Unified Modeling Language.
The following table shows the different versions of the language:
Table 2.1
Version
Date
Description
1.1
11-1997
The OMG Object Management Group (OMG™) 
adopts UML 1.1 proposal.
1.3
03-2000
Contains a number of changes to the UML 
metamodeling, semantics, and notation, but 
should be considered a minor upgrade to the 
original proposal.
1.4
09-2001
Mostly “tuning” release but not completely 
upward compatible with the UML 1.3. Addition 
profiles as UML extensions grouped together. 
Updated visibility of features. Stick 
arrowhead in
Interaction diagrams now denote asynchronous 
call. Model element may now have multiple 
stereotypes. Clarified collaborations.
Refined definitions of components and related 
concepts. Artifacts were added to represent 
physical representations of components.

8
Chapter Two
1.5
03-2003
Added actions - executable actions and 
procedures, including their run-time semantics, 
defined the concept of a data flow to carry data 
between actions, etc.
1.4.2
01-2005
This version was accepted as ISO specification 
(standard) ISO/IEC International Organization 
for Standardization (ISO) and the International 
Electro technical Commission (IEC).
2.0
08-2005
New diagrams: object diagrams, package 
diagrams, composite structure diagrams,
interaction overview diagrams, timing diagrams, 
profile diagrams. Collaboration diagrams were 
renamed to communication diagrams. Activity 
diagrams and sequence diagrams were enhanced. 
Activities were redesigned to use a Petri-like 
semantics. Edges can now be contained in 
partitions. Partitions can be hierarchical and 
multidimensional. Explicitly modeled object 
flows are new. Classes have been extended with 
internal structures and ports (composite 
structures). Information flows were added. New 
notation for concurrency and branching using 
combined fragments. Notation and/or semantics 
were updated for components, realization, 
deployments of artifacts. Components can no 
longer be directly deployed to nodes. Artifacts 
should be deployed instead. Implementation has 
been replaced by «manifest». Artifacts can now 
manifest any package able element (not just 
components, as before). It is now possible to 
deploy to nodes with an internal structure. New 
meta classes were added: connector, 
collaboration use, connector end, device, 
deployment specification, execution 
environment, accept event action, send object 
action, structural feature action, value pin, 
activity final, central buffer node, data stores, 
flow final, interruptible regions, loop nodes, 
parameter, port, behavior, behavioral classifier, 
duration, interval, time constraint, combined 
fragment, creation event, destruction event, 
execution event, interaction fragment, 
interaction use, receive signal event, send signal 
event, extension, etc. Integration between 
structural and behavioral models was improved 
with better support for executable models.

UML
9
2.1
04-2006
Minor revision to UML 2.0 - corrections and 
consistency improvements.
2.1.1
02-2007
Minor revision to the UML 2.1
2.1.2
11-2007
Minor revision to the UML 2.1.1
2.2
02-2009
Fixed numerous minor consistency 
problems and added clarifications to 
UML 2.1.2
2.3
05-2010
Minor revision to the UML 2.2, clarified 
associations and association classes, added final 
classifier, updated component diagrams, 
composite structures, actions, etc.
2.4.1
08-2011
The current version of UML, a minor revision to 
UML 2.3, with a few fixes and updates to 
classes; packages - added URI package attribute; 
updated actions; removed creation event, 
execution event, send and receive operation 
events, send and receive signal events, renamed 
destruction event to destruction occurrence 
specification; profiles - changed stereotypes and 
applied stereotypes to have upper-case first letter 
- «Metaclass» and stereotype application.
2.5 FTF - Beta
1
11-2012
From the UML language perspective, 2.5 will be 
a minor revision to UML 2.4.1, while they spent 
many effort simplifying and reorganizing 
specification documents. It seems that this time 
"professors" took over researchers and industry 
practitioners and instead of fixing actual UML 
issues waiting to be resolved for several years, 
they re-wrote UML specifications "to make 
them easier to read". For example, they tried "to 
reduce forward references as much as possible", 
which is an obvious requirement for textbooks 
but not for specifications. There will be no 
separate UML 2.5 Infrastructure document, so 
that the UML 2.5 specification will be a single 
document. Package merge will no longer be used 
within the specification itself. Four UML 
compliance levels (L0, L1, L2, and L3) are to be 
eliminated, as they were not useful in practice. 
UML 2.5 tools will have to support complete 
UML specifications. Information flows, models, 
and templates will no longer be auxiliary UML 
constructs.

10
Chapter Two
2.5 RTF - Beta 
2
09-2013
Work in progress - some fixes, clarifications, 
and explanations added to UML 2.5 FTF - Beta 
1. Updated description for multiplicity and 
multiplicity elements. Clarified definitions of 
aggregation and composition. Finally fixed a 
wrong «instantiate» dependency example for 
Car Factory. Introduced notation for inherited 
members with a caret "A" symbol. Clarified 
feature redefinition and overloading. Moved and 
rephrased definition of qualifiers. Few 
clarifications and fixes for stereotypes, state 
machines, activities. Protocol state machines are 
now denoted using «protocol» instead of 
{protocol}.
Use cases are no longer required to express some 
needs of actors and to be initiated by an actor.
2.5
08-2015
UML was made simple than it was before. Rapid 
functioning and the generation of more effective 
models were introduced. Outdated features were 
eliminated. Models, templates were eliminated 
as auxiliary constructs.
2.5.1
12-2017
The current UML standards call for 13 different 
types of diagrams: class, activity, object, use 
case, sequence, package, state, component, 
communication, composite structure, interaction 
overview, timing, and deployment.
2.1 UML Diagrams
UML consists of a set of diagrams representing the parts of a system. 
These diagrams are divided into two main categories:
1- 
Structure Diagrams, which represent the architectural 
components of the system such as objects, relationships and the 
dependence of system elements on each other.
They include Class Diagram, Object Diagram, Component Diagram, 
Composite Structure Diagram, Package Diagram, and Deployment Diagram.
Class Diagram: A diagram shows the classes within the system and the 
relationships between them.
Package Diagram: It breaks the system down into smaller and easier-to- 
understand parts, and this diagram allows us to model these parts.

UML
11
Component Diagrams: to encode how the system is separated or 
partitioned and how each model depends on the other. It focuses on the 
actual components of the program (files, link libraries, executables, and 
packages) and not on the logical or intellectual separation as in the 
Package Diagrams.
2- 
Behavior Diagrams, which represent the dynamics of the system 
and the interaction between the system’s objects and the changes that 
occur in the system. They include: Use Case diagrams, Activity diagrams, 
State Machine, Communication diagrams, Sequence diagrams, Timing 
diagrams, and Interaction Overview diagrams.
Use Case Diagram: A description of the behavior of the system from the 
user’s point of view. It describes interaction with the outside world; it is 
useful during the analysis and development stages, and helps in 
understanding the requirements.
Collaborative diagrams: to describe how the objects we build collaborate 
and use numbers to show the sequence of messages. Collaborative 
diagrams are also referred to as Communication diagrams in UML.
Sequence Diagram: describes how objects in the system interact over 
time. It displays the time sequence of the objects participating in the 
interaction. It consists of a vertical dimension (time) and a horizontal 
dimension (different object).
State Diagrams: to show the succession of transitions between different 
states of an organism during its life cycle and the events which force it to 
change its state. Activity Diagram: shows a special case where most of 
the states are states and actions and most transitions are triggered by the 
completion of the verbs of the source states. This diagram focuses on 
internal processing-driven flows.
There are different programs to create, document and track these diagrams 
and generate source code for files for several languages, which facilitates 
the programming process, and these programs include: Edraw UML 
Diagram, With Class2000, Rational Rose, Model Maker, and you can 
draw the diagrams through several web sites. You can rely on these 
diagrams in Object Oriented systems, but they are not suitable for some 
applications, such as Networking Projects, Web applications, and database 
design.

12
Chapter Two
2.2 System modeling
When modeling any Object Oriented system, we deal with three main 
parts:
• Functional Model: It is a form that depends on the user's point of 
view and includes use case diagrams.
• Object Model: It is the model that is concerned with the 
architecture of the system and sub-systems using objects and 
attributes, operations and associations. This model includes a class 
diagram.
• Dynamic Model: It is the model that is concerned with the internal 
behavior of a system and includes Sequence Diagrams, Activity 
Diagram, and State Diagram.
2.3 Use Case Diagram
A powerful UML tool, it is a description of a set of interactions between a 
user and a system. By building a set of use case diagrams, we can describe 
the system clearly and concisely. The two main components of a use case 
diagram are the use case and the actor. Use case describes the interaction 
between the user and the system. Use cases are usually described using 
combinations of (verb / noun) - e.g.: ‘pay bills’, ‘update salary’ or ‘create 
an account’. The actor is the role that the user plays in the system, whether 
that user is a human or even another system that the system being modeled 
will interact with.
UML provides simple notation to represent the use case and the actors 
as shown in figure 2.1.
Fig. 2.1 Actor and use case

UML
13
The player will activate or initiate a particular use case. For example, if we 
are developing a banking system, and we have a use case called “withdraw 
cash”, we need customers to be able to withdraw that cash as shown in 
figure 2.2.
Fig. 2.2 withdraw cash use case
For most systems, a single actor can interact with a range of use cases, and 
more than one different actor can activate a single use case. This brings us 
to an integrated use case diagram. For example, a patient calls a doctor’s 
office to book an appointment for an examination as shown in figure 2.3.
Fig. 2.3 Make appointment
Therefore, the person working in the inquiries searches the appointment 
book to search for an empty appointment and set the appointment.
The full schema is shown in figure 2.4. It includes use cases for the 
following:
- Dealing with the patient and making or canceling an appointment 
with the doctor’s schedule organizer.
- Interaction between patient and doctor requesting treatment.
- Dealing with patient to pay the account.

14
Chapter Two
Fig. 2.4 Full Shema
System Boundaries: It is a square that represents the boundaries of the 
interaction between actors and the system, as it groups all use cases 
together in one place.
2.3.1 Relationships in Use Case
1. 
Generalization: means that one is a type of another. It is 
represented as follows in figure 2.5:
Fig. 2.5 Generalization
2. 
Includes: means that one is an evocation of another. It is 
represented as shown in figure 2.6:
Fig. 2.6 Include
3. 
Extend: means that one is a variation of another. It is represented 
as shown in figure 2.7:

UML
15
Fig. 2.7 Extend
The following figure (2.8) shows the use case diagram including these 
relationships.
Fig. 2.8 use case with relationships

16
Chapter Two
The following figure (2.9) represents the use case diagram for part of 
an E Learning system:
Fig 2.9 Use case for E Learning system

UML
17
2.3.2 Purpose of use case
- 
Use cases can provide a structured way to describe user interactions 
with the system, their effectiveness in achieving this goal depend 
on how well they are written and how well they capture user needs.
- 
Use cases are a tool for describing the functionality of the system 
from the perspective of its users, but they do not provide a 
complete specification of the system. There may be other 
requirements or constraints that are not captured in the use cases, 
such as performance requirements, security requirements, or data 
constraints.
- 
They enable communication between customers and developers (as 
long as the scheme is that easy, everyone can understand it).
- 
Use cases guide members of development teams through the 
development processes.
- 
Provide a methodology for planning, and allow us to estimate the 
time needed to complete the work.
- 
Provide the basis for system design and test.
- 
Finally, use cases help in inform user documentation.
Use case diagrams are used in almost all projects, they help to clarify and 
show requirements and project planning. In the preliminary stage of the 
project, most use cases must be defined, and during the project's progress, 
there may be a need to define other use cases.
Note that each use case is associated with at least one of the actors. The 
actor may be a person, another computer system, or an event for whom or 
what will use the system. The actor does not represent these things, but 
represents their roles. This means that when these objects interact with the 
system in multiple ways, one actor does not represent them. For example, 
a person who works in a customer service center by telephone and receives 
orders from the customer must be represented twice as a “Support Staff” 
actor and a “Sales representative” actor.

18
Chapter Two
Figure 2.10 shows an example illustrating the use case diagrams for a 
library system.
Fig. 2.10 Use cases for a library System
2.4 Class diagram
This diagram represents the classes included in the system and 
their relationships. It is referred to as a static diagram because it describes 
the classes with their properties, methods, and their static relationships 
with each other, but it does not display the interactions between them.
Class representation in the Class Diagram
The classes are represented in this diagram as shown in figure 2.11.

UML
19
Class Name
Attribute 1
Attribute 2
Opera tionl()
Opera tion2() 
Op e r ation3 ()
Class
+ Httrl : int
+ attrS : string
+ operation! <p : pooi) : double
# operations^)
Fig. 2.11 Class diagram
A class is represented by a rectangle divided into three parts. The first part 
displays the class name (use the singular form for the class name, which 
expresses a general case such as a student or book). The class name 
indicates the function it performs. The second part includes all the 
attributes (or properties) that characterize our class. The last part contains 
all the methods or operations of the class. Figure 2.12 represents examples 
of class diagrams.
Fig. 2.12 Examples of class diagram

20
Chapter Two
Scope
The following symbols are used to define the scope of attributes or 
methods. These symbols show us the accessibility of the attribute or 
method within the class. They are known as modifiers:
- "+" stands for public.
- "#" stands for protected.
- "-" stands for private.
Public (+): Any element of the class or outside of the class can access this 
member (attributes or operation). Private (-): The member can only be 
accessed within the class itself. Protected access specifier (#): The 
property can only be accessed within the class or from another class that 
inherits this class.
The following example shows a class diagram for a class called 'Vehicle' 
that includes an integer property for the number of vehicles, a string 
property to hold the vehicle type, and two integer properties for the 
vehicle's maximum and minimum speed. Operations or methods of this 
class include a set of functions such as a process to create the vehicle, 
another to destroy it, a process to increase its speed, and another to move 
backwards as shown in Figure 2.13.
#NiimberOfVehicles: integer
description of attributes 
or member data
t
#mark : string
Sspeed maximal: integer 
Sspeed courante : integer
+ Create Vehicle ()
+ Destroy Vehicle 0
+ Start 0
+ Accelerate(rate : integer)
+ Advance ()
+ MoveBack 0
description of methods = 
associate code to data
□
Fig. 2.13 Vehicle class
The accurate description of classes within the system is one of the most 
important skills in the development of Object-Oriented Systems (OOS). 
To perform this task, you can use a technique called Noun Identification

UML
21
Technique (NIT). It uses the System Requirement Specification (SRS) 
document and extracts the nouns and verbs (nouns represent classes and 
verbs express operations or methods). We will introduce this in the 
following example.
In the library system, we can use the following SRS document to define 
the classes in the system.
Books and Journals
The library contains a number of books and journals. The library can 
contain several copies of the same book. Some of the books are for short­
term loans only. All other books may be borrowed by any library member 
for three weeks. Members of the library can normally borrow up to six 
items at a time, but members of staff may borrow up to 12 items at one 
time. Only members of staff may borrow journals. The borrowing system 
must keep track of borrowing duration, enforcing the rules described 
above.
To define the classes in the borrowing system, we can omit the word 
“library” because it is outside the scope of the system’s classes. Also, a 
“short term loan” where it represents an event not a class. The word 
“week” is omitted because it represents a time measuring unit, also “item” 
because it is ambiguous, as it represents a book or newspaper, also “time” 
and “system” because they are outside the scope of the system, as well 
as the word “rules”. Thus, the classes are:
- 
Book
- 
Journal
- 
Copy (of book)
- 
Library member
- 
Member of staff
2.4.1. Relationships between classes
Class diagrams represent classes and the relationships with each other. The 
relationships between classes take one of four types, which are illustrated 
in the following figure (2.14).

22
Chapter Two
Fig. 2.14 Type of relationship
The following figure (2.15) illustrates examples of these relationships.
Fig. 2.15 Examples of relationships
2.4.1.1 Generalization/ inheritance
This relationship is used when two classes are similar with some 
differences. For example, when we have a general class such as employee 
and another class is a special case of this class such as engineer, this 
means that the class of engineer has all the characteristics and operations 
of the employee class and acquires the properties and operations that 
belong to it. In this case, the employee class is the base class, while the 
engineer class is the derived class. This relationship is represented in the 
diagram by an arrow with a triangle head indicating the inherited class and 
its beginning from the inherited class, as shown in figure 2.16.

UML
23
Derived
Fig. 2.16 Generalization
Note: The derived class contains all the properties of the base class 
except the private members.
The following figure (2.17) shows a diagram of a base (main) class 
representing the employee, including two derived classes representing 
managers and programmers. In addition, a manager class is a main class 
from which two classes are derived, namely, the project manager and 
department manager.
Fig. 2.17 Employee base class with two levels of inheritance
The following example shows a main class for graphic objects and then 
deriving two classes for line and circle, as shown in figure 2.18.

24
Chapter Two
Fig. 2.18 graphical class with two sub classes
The following example represents a main class of vehicles, including 
derived classes representing helicopters, wagons, and ships. Note writing 
the name of the main class in italics as shown in figure 2.19, which 
expresses that it is an abstract class, meaning that there are no physical 
objects of this class.
Fig. 2.19 Vehicle class

UML
25
A derived class can inherit more properties and operations from more than 
one parent class, which is called multiple inheritance, as shown in the 
following two figures (2.20 A, 2.20 B).
Fig. 2.20 A
Fig. 2.20 B
2.4.2.2 Association
The second type is called association, and it is the most common 
relationship in the class diagram. The association shows the relationship 
between instances of classes (objects). It is a mechanism that shows how 
to communicate between objects and can be uni- or bi- express how the 
two objects participate in the relationship by sending messages to each 
other.
In UML, a line connecting the two classes represents this association, and 
the number of objects participating in this association from both ends 
[min.max] is placed at the end of the line connecting the two objects.
For example, the order class is related to the customer class, and the 
multiplicity of the association denotes the number of objects that can 
participate in this relationship. For example, an order object can only be 

26
Chapter Two
associated with one customer, but a consumer can be associated with many 
orders.
Multiplicity between classes can take one of the following figures 
(2.21).
Fig. 2.21 Multiplicity between classes
The link between the two classes has a significant name, such as “drives” 
in the previous figure. The numbers at both ends of the link describe the 
multiplicity. In this example, we are saying, “every manager drives one 
company car”, and (in the opposite direction) “every company car is 
driven by one manager”. Figure 2.22 represents multiplicity between 
Manager class and Staff Member class.
Figure 2.22 multiplicity between Manager class and Staff Member class
In the previous figure, we find that “each Manager manages 1 or more 
Staff Member”; and (opposite), “each Staff Member is managed by one

UML
27
Manager.” The following figure (2.23) shows a simple and complete 
diagram of this relationship.
Fig. 2.23 complete diagram
With the example of the library system previously explained, we could 
design the initial diagram for the classes of this system as shown in figure 
2.24.
Fig. 2.24 Library system

28
Chapter Two
2.4.2.3 Aggregations
It is a special type of relationship between objects and connects two 
classes called a “whole-part”. The idea is that one object can be built from 
(collected from) other objects. It describes how the group that plays the 
role of a whole takes part with a number of classes that are in the role of 
part. This relationship is represented by a line ending in a blank diamond, 
indicating the group that participates in the role of the whole, as the 
following examples where the car and the wheel are associated with this 
relationship, also a company with a department as shown in figure 2.25.
Fig. 2.25 Aggregation
The following figure shows another example of this type of relation. The 
CPU, video card, and graphics card are all parts of a computer as shown in 
figure 2.26. If we remove part of the computer’s components, it will 
remain a computer.
Fig. 2.26 Computer with its components

UML
29
2.4.2.4 Composition
The fourth type of relationship is composition, which is a special case of 
aggregation. It is stronger than aggregation, in the sense that the 
relationship dictates that the whole does not exist without the parts. This 
strong relationship means that the group participating in the part does not 
exist alone, but rather within the other class participating in the whole role. 
In the previous example, if we eliminated the presence of the video card, 
the computer would still be a computer. On the other hand, a book is not a 
book without its pages. This relationship is represented by a line at the end 
of a solid rhombus, as shown in figure 2.27.
Fig. 2.27 Composition
The aggregation relationship is a relationship between the part and the 
whole. The life cycle of the part is independent of the life cycle of the 
whole (the part can be seen apart from the whole). The composition 
relationship is also a relationship between the part and the whole, but it is 
stronger as the life cycle of the part dep ends on the life cycle of the whole 
(the part cannot be seen far from the whole).
2.5 Cooperation Diagram
The system’s elements work together to implement its goals. Collaboration 
diagrams show collaboration between objects and the order of messages 
that pass between them, objects are listed as icons, arrows indicate 
messages passed between them, and numbers are used to show the 
sequence of messages. The numbers following the message are called 
sequence numbers, and those sequence names show the sequence of 
messages as they pass between objects. There are many forms of sequence 
numbering in the simpler UML, the simplest of which uses the numbering 
in the formula 1, 2, 3... The detailed numbering uses the formula 1, 1.1, 
1.2, 1.2.1. The object is coded as shown in figure 2.28.

30
Chapter Two
Fig. 2.28 Object in collaboration diagram
Note:
- 
The object’s names appear after colons (: ).
- 
To communicate objects with another, connect them with a line.
- 
To pass parameter of the message, include it in brackets.
Figure 2.29 shows an example of a collaboration diagram for library 
objects.
Fig. 2.29 collaboration diagram for library objects
2.6 Sequence diagram
It aims to describe the interactions between system objects over time. It 
shows the sequence performed and the exchange of messages between 
different objects at a specific time. This diagram confirms the order and 
the time when the messages are sent. It expresses the objects with vertical 
and intermittent lines, on top of which are the name of the object, as well 

UML
31
as the time axis that increases from top to bottom, and expresses the 
messages sent from one object to another with an arrow bearing the name 
and parameters of the process. Messages are represented by a box on the 
side of the requested object.
In fact, the sequence diagram directly related to the cooperation diagram 
and displays the same information, but in a slightly different way. The 
dotted lines indicate time, so what we are seeing here is a description of 
how the objects in our system interact through time. The symbols shown 
in figure 2.30 are used in the sequence diagram.
Fig. 2.30 Symbols in sequence diagram
The following figure (2.31) shows an example of this diagram in the 
student registration system for courses.
Fig. 2.31 Registration sequence
Another example of a sequence diagram in the library system is 
shown in figure 2.32.

32
Chapter Two
Fig. 2.32 Sequence in Library
Figure 2.33 shows another example of a sequence diagram 
representing a student's entry into an educational system

UML
33
Name, Password
Login (name, pass)
GUI
Log in
DataBase
IsValld = In Data base (name)
[isValid != true]
report Error Messsge 
1
[else]
Display 1 ng-ln 1 
use
userType =
■“I isUserOrAdmin(name,pass) p
m>e 
"
[userlype == Admin]
display Administrator 
Interface
<------------------ 1
[user Type ■» Leainei]
display Learner Interface
<-----
Fig. 2.33 Student’s entry sequence

34
Chapter Two
2.7 State diagram
A state diagram represents the state of the object and its changes over 
time. Each state diagram begins with a symbol representing the starting 
state and ends with an end state symbol. The basic graphic elements of 
state diagrams are: a rectangle with circular corners representing the state 
of the object, arrows indicating the transition to the next state (change 
from one state to another). In the activity section, a symbol showing the 
activities performed by the object when it is in this state as shown in figure 
2.34.
Fig. 2.34 State diagram symbols
State diagrams include the initial state of the object, which is the state that 
the object is in when it is created. After the initial state, states of change 
begin. Conditions based on activities can determine what the next state is 
as shown in figure 2.35.
Fig. 2.35 changing states
Figure 2.36 represents a state diagram of a request object. When the object 
enters the check state, it performs the “check items” activity. After the 

UML
35
activity is completed, the object moves to the next state which depends on 
the conditions: if all items are available, the request is sent (Dispatched); 
however, if an item is not available, the request is (canceled). When the 
object transition to the Dispatching state, the “initiate delivery” activity is 
executed. After this activity is completed, the object moves to the 
Delivered state.
Fig. 2.36 State diagram of a request object
2.8 Activity diagram
It describes the workflow behavior of a system. Activity diagrams are 
similar to state diagrams because activities are in a state of doing 
something. Activity diagrams depict the sequence of activities performed 
and can show parallel or conditional activities. These diagrams show the 
flow of activities through the system typically read from top to bottom. 
Branches and forks describe parallel conditions and activities. A fork 
indicates simultaneous occurrence of multiple activities, while a branch 
describes which activities will be executed based on specific conditions. 
All branches eventually lead to a merge, indicating the end of the 
conditional action initiated by the branching. After merging, parallel 
activities must be joined before transitioning to the final activity state.
The following diagram shows a fork after activity1 indicating that both 
activity2 and activity3 occur at the same time. After activity2, there is a 
branch; the branch describes which activities will take their place 
(activity4 or activity5). All the branches at some point are followed by a 
merge to indicate the end of the conditional action. After merging, all 
parallel activities must be grouped by a join before moving to the final 
activity state as shown in figure 2.37.

36
Chapter Two
Fig. 2.37 Activity diagram
In the following figure (2.38), the diagram shows the activities for 
processing an order, and the diagram shows the flow of actions in the 
workflow of the system. Once the order is received, the activities are 
divided into two parallel groups of activities. One side is to fill the order, 
while the second side deals with the invoice. In the filling side, the 
delivery method is specified according to condition, it is either overnight 
or regular delivery. In the end, parallel activities are grouped.

UML
37
Fig. 2.38 activities for processing an order
Figure 2.39 illustrates the learner’s activities in an educational system.

38
Chapter Two
Fig 2.39 Learner’s activities in an educational system.

UML
39
Figure 2.40 illustrates the teacher’s activities in an educational system.
Fig. 2.40 Teacher’s activities in an educational system.

40
Chapter Two
2.9 CRC Card
In the next section, we introduce a method for ensuring design, fit and 
quality. It is called CRC cards (Class Responsibilities, Collaborations). 
This method was proposed by Kent Beck and Ward Cunningham in 1989 
at the OO Conference OOPSLA'89 to aid programmers in a non-object- 
related language. Although CRC cards are not a component of UML, it is 
a good way to write down the name of the class and then define the 
responsibilities on the left and the shares on the right as shown in figure 
2.41.
Need for
Attribute 
operation
What the 
class 
knows
Or 
does
Other classes 
needed to 
fulfill class a 
responsibility
Class name
Responsibility
Fig 2.41 CRC Card

UML
41
Figure 2.42 shows an example of this card in the library system
Library Member
Responsibilities
Collaborators
Maintain data about copies currently borrowed 
Met requests to borrow and return copies
Copy
Copy
Responsibilities
Collaborators
Maintain data about a particular copy of book 
Inform corresponding book when borrowed and 
returned
Book
Fig. 2.42 CRC card in the library system
Book
Responsibilities
Collaborators
Maintain data about one book
Know whether there are borrow able copies
Copy

42
Chapter Two
2.10 UML Tools
In the next section, we introduce websites to some tools used to model 
UML diagrams.
- https://nulab.com/cacoo/examples/uml-diagram-tool
- https://www.lucidchart.com/pages/landing/uml-diagram-software
Free UML Tools
Rational Rose trial for one month
- http://www.rational.com/products/rose/index.jsp
Argo UML open source project
- http://www.agrouml.tigris.org
Dia
- http://hans.breuer.org/dia/
Ensure that the tools you use to create the UML diagram support the 
language that you will use to develop the system. This process is known as 
forward engineering. In addition, it supports the so-called reverse 
engineering, which is to write the code in your programming language, 
and then the diagram is created for the classes you created. Figure 2.43 
shows the process of combining the two methods into one, known as 
Round-trip Engineering.
Kon n<l -1 l ip l<nt;i neei iiit;
Fig. 2.43 Round-trip engineering

Chapter Three
Object-Oriented Programming Concepts
Object Oriented Programming OOP is a programming philosophy in 
which the program is divided into units that we call (classes). When we 
need to use class, we make an instance called object, whose methods and 
properties can be used without the need to know how to write the class 
code (you can drive the car efficiently without even knowing what the 
internal mechanisms of the car is). Each object is the packaging of data 
(variables and constants), functions, and user interfaces together into units 
that run within an active program.
It is distinguished from traditional programming by a number of 
advantages that make building, maintaining, modifying, and reusing 
programs easier.
Disadvantages of traditional programming:
1- Difficulty of separating data from operations.
2- Creating solutions and not reusing them.
3- Absence of any restrictions on the access of functions to general 
data in a program.
4- Lack of direct correlation between functions and data, which often 
contradicts practical software development scenarios.
.3.1 Advantages of object-oriented programming
Generally, OOP is organized into a set of objects where the object contains 
attributes, fields (instance data) that represent the state of the object, and 
methods that represent the behavior of the object. OOP can be viewed as a 
method of linking data to the functions that you work on within a specific 
object so that data can be dealt with through functions of that object only. 
With this method, objects can be considered hidden and encapsulated. By 
encapsulating object data, we can ensure that data is not tampered with 
and reduce the time to identify the errors (debugging time). In addition, the 
following features are advantages of OOP:

44
Chapter Three
• Simplicity: Because software objects are models of real objects in 
the application field, the complexity of the program decreases and 
the program structure becomes clear and simple.
• Individual construction: Each class is an independent entity that 
operates internally independently of other parts of the system.
• Modification possibility: It is easy to make some small changes in 
the representation of data or in the procedures used in a program. 
Changes that occur in an object do not affect any other part of the 
system provided that the external behavior of the object is 
maintained.
• Expandability: Adding new properties or responding to changing 
operating environments can only require adding some modifications 
to existing ones.
• Flexibility: Any program can be very flexible in accommodating 
different situations because it can change the models of interaction 
between objects without modifying the objects.
• Maintainability: Each object can be maintained separately, which 
makes identifying and fixing problems easy.
• Possibility of reuse: Objects can be reused in different programs. 
For example, an object can be used to build tables in any program 
that needs tables of any kind. Thus, programs can be built from 
prefabricated components and tested in a fraction of the time 
required to build new programs from scratch.
One of the first languages to implement this concept is JAVA, as well as C 
# being one of the languages that adhere to the concept of OOP. VB.NET 
has increased its interest in it, and it is considered one of the important 
modifications that increased the power of Visual Basic (VB).
3.2 Class
The set of objects that share properties and operations is called a class. The 
class is the template through which objects are created (as a special 
instance of it). Each object has the same structure and behavior as the class 
from which it is created.
We can approach the idea of dealing with classes by contemplating the 
nature of people. Each person has attributes that distinguish him from 
others, such as name, color, gender, job, and social status. There is no 
doubt that the definition of the class does not lead to the creation of an 
object, but only defines the characteristics and behavior of this object, 

Object-Oriented Programming Concepts
45
which makes us call the object as “it is a state of the class”. You can create 
any number of objects that are known as instances of the class. For 
example, after defining the employee class, we can create an object for an 
employee.
Through classes, we can define properties, methods, fields, and events for 
objects. For example, a man is a category that has characteristics 
(attributes) such as name, age, height, weight, and so on, and also has 
functions (verbs) such as reading and moving. Note that we did not specify 
values, so we needed the objects. There is a human named Ahmed, who is 
30 years old and has a specific weight and height. That is, an object is an 
instance of a class in which specific data is specified for this object.
That is, the general properties are defined in classes, so we do not need to 
have more than one definition of the class, but we need to have more than 
one object and each object has the main class’s members.
3 .2.1. Class definition
Defining a class does not create any object, but rather defines the 
properties and functions within the objects that will be created as an 
instance of that class. The definition of a class is a description of the 
properties and functions (members). The class’s objects share properties 
and operations. Defining a class named “robot” enables us to create an 
object called robot1, then we say that robot1 is an instance of robot.
• A class consists of attributes and functions:
- Attributes, which are data or member variables such as (size, 
shape, color, body, etc.).
- Behavior or function, which is a member function, and 
sometimes called member methods, such as walking for people 
or turn on/off for radios.
In the following sections, we will introduce some details about how to 
create new classes.
The general form of defining classes may differ according to the 
programming language, and it is as follows:

46
Chapter Three
Class classname{
Type instance-variable1;
Type instance-variable2;
//....
Type instance-variable n;
Type function 1(parameter-list){ 
//body of function
}
Type function name (parameter-list){ 
//body of function 
}}
vb.net
Class classname
End class
C#
Class classname 
{
2
Python
Class classname:
New classes can be declared either within another class, or within a 
module. In the following example, a class called Class1 is created inside 
the model's class in VB.NET.
Public Class Form1
Public Class class1
Sub test ()
MsgBox("First Class")
End Sub
End Class
To create an object of the class we use the following formula:
Object_name as new class_name () 
' VB.NET

Object-Oriented Programming Concepts
47
Class_name object_name = new class_name (); 
// C#
Object_name = class_name () 
# Python
In the following VB.NET and C# code, we have created an object named 
Obj1 of class1.
Private Sub Form1_Click(ByVal sender As Object, ByVal e As
System.EventArgs) Handles Me.Click
Dim Obj1 As New class1
Obj1.test()
End Sub
End Class
C#
public partial class Form1 : Form
{
class class1
{
public void test()
{
MessageBox.Show("First Class");
}
}
private void button1_Click(object sender, EventArgs e)
{
class1 obj1 = new class1();
obj1.test();
}
}
The following example creates class named Employee in Python. The 
class has two attributes (name and age), then instantiate an object named 
emp.
class Employee:
name="Abd elrhman"
age=25
emp= Employee ()
print(emp.name)
print(emp.age)
The output is :

48
Chapter Three
Abd elrhman 
25
It is better to create each new class inside a new file. As an example of 
creating a class in a file within a project (in VB.net, and C#) by choosing 
the “Add Class” command from the “Project” menu, where a dialog box 
appears asking you to enter the name of the new class, then you will find 
this reflected on the “Solution Explorer” window, as shown in figure 3.1.
Fig. 3.1 Solution Explorer windows
3.2.2 Modifiers
• Private
Classes that are declared as private can only be accessed from within the 
context where they are defined (a module, or a class), and cannot be 
accessed from elsewhere. Declaring a new class at the file level using the 
private access specifier triggers an error message, as shown in figure 3.2.

Object-Oriented Programming Concepts
49
Fig. 3.2 Error message
Nested classes cannot be accessed if they are defined as private. For 
instance, when defining an object of a private nested class, an error will 
appear. Here's a VB.NET example demonstrating this point:
Module Module1
Class outer
Private Class Inner
Public name As String
End Class
End Class
Sub Main()
Dim x As New outer.Inner() 'Outer.Inner is not accessible in
this context because it is 'private'
End Sub
End Module
When changing “private” to “public”, the error message disappears, and 
the program executes correctly. Also, note that we can only access the 
inner class from the outer class. The following example illustrates this 
point:

50
Chapter Three
Module Module1
Class outer
Public Class Inner
Public name As String
End Class
End Class
Sub Main()
Dim x As New outer.Inner()
x.name = "Ahmed"
Console.WriteLine(x.name) ' Ahmed
Console.ReadLine()
End Sub
End Module
Here's an equivalent example in C#:
public class outer
{
public class inner
{
public string name;
}
}
static void Main(string[] args)
{
outer.inner obj1 = new outer.inner();
obj1.name = "Ali";
MessageBox.Show(obj1.name);
Console.ReadLine();
}
Fig. 3.3 Program output

Object-Oriented Programming Concepts
51
In nested classes, you can access the members of the outer class from the 
inner class, even if they are private, as shown in the following example:
Module Module1
Class Outer
Private x As Integer
Class Inner
Dim obj As New Outer
Sub MyMethod()
obj.x = 10
Console.WriteLine(obj.x)
End Sub
End Class
End Class
Sub Main()
Dim obj2 As New Outer.Inner
obj2.MyMethod()
Console.ReadLine()
End Sub
End Module
Friend
If you declare a class using the class keyword without specifying its access 
modifier, it defaults to ‘internal’ (in C#) or ‘Friend’ (in VB.NET), which 
makes the class accessible only within the current project. You can define 
a class of type 'internal' (or 'Friend') from anywhere, even if it is nested 
within another class.
Class Outer 
'Friend
Friend Class Inner 
'Friend
End Class
End Class
Sub Main()
Dim x As New Outer.Inner() ' ok
End Sub
C#
internal class outer
{
internal class inner
{

52
Chapter Three
}
}
static void Main(string[] args)
{
outer.inner x = new outer.inner(); //ok
}
However, if you define a class using “internal” (in C#) or "Friend" (in 
VB.NET) within a class at the private level, you can only access it within 
that class. You will not be able to access it from outside of the class, even 
though it's at the friend/internal level.
In the following example, class ‘C’ will not be able to access, outside of 
class ‘B’ even though it is at the friend level:
Class A
Private Class B
Friend Class C
End Class
End Class
End Class
Sub Main()
Dim x As New A.B.C 'A.B is not accessible in this context 
because it is 'private'
End Sub
Note: When defining a class inside another class, you cannot instantiate it 
directly by writing the class name. You need to write the name of the class 
that contains it.
Class A
Class B
End Class
End Class
Sub Main()
' Dim obj As New B 'Type 'B' is not defined
Dim obj As New A.B 'Ok
End Sub
• Public
You can access a public class from outside the current project as well. A 
public class can be accessed from anywhere within the current solution.

Object-Oriented Programming Concepts
53
In addition to "Private", "Friend/internal", and "Public", there are other 
access modifiers that define the visibility of classes. "Protected" and 
"protected friend" will be discussed later, as they relate to an OOP 
principle called Encapsulation.
3.3. Class Members
A class can contain three types of members: Fields (or attributes), 
Methods, and Properties.
Fields
The simplest types of members you can define in classes are fields, which 
are simply variables. But, when declared inside a class, they are referred to 
as fields.
The following class includes three fields only.
Class student 
'VB.NET
Public Number As Integer
Public Gpa As Double
Public Points As Integer
End Class
class Student 
//C#
{
public int Number;
public double Gpa;
public int Points;
}
The class definition creates a new data type. For example, if we have a 
class named "student", "student" is the new data type. At this point, an 
object has not been created, as defining the class does not create an object. 
In other words, declaring a class is only a description of a new type. To 
create an object of this class in VB.NET, the following general syntax is 
used:’’’ VB.Net
Dim Object_name As New class_name()
In C#, the following general syntax is used:
’’’C#

54
Chapter Three
Class_name Object_name = new Class_name();
To create an object of type ‘student’ we use the following statement
Dim stud1 as new student 
'VB
student stud1 = new student (); 
//C#
This creats an object of type ‘student’ and assigning it to a reference 
variable named ‘stud1’, ‘stud1’ is a reference to an object of type 
‘student’.
We can assign values to fields directly during the declaration process, 
which is not very common, as shown in the following example:
Class student
Public ID As Integer = 120
Public Name As String = "Ahmed"
Public Address As String = "Cairo"
End Class
Sub Main()
Dim stud1 As New student
Console.WriteLine(stud1.ID) 
'120
Console.WriteLine(stud1.Name) 
'Ahmed
Console.WriteLine(stud1.Address) 'Cairo
Console.ReadLine()
End Sub
C#
class student
{
public int ID = 120;
public string Name = "Ahmed";
public string Address = "Cairo";
}
static void Main(string[] args)
{
student stud1 = new student();
Console.WriteLine(stud1.ID);
Console.WriteLine(stud1.Name);
Console.WriteLine(stud1.Address);
Console.ReadLine();
}

Object-Oriented Programming Concepts
55
In general, a class object cannot handle private fields from outside the 
class. They can be accessed and assigned values if they are public. This is 
done using the following formula:
Object_refenence_name. instance_variable = value ' VB.NET
Object_refenence_name. instance_variable = value; ' C#
Example: The following code shows how to define a class named student 
that includes three fields: Number, Gpa and Points. It also creates an 
object for this class and refers to it as ‘stud1’.
Public Class student
Public Number As Integer
Public Gpa As Double
Public Points As Integer
End Class
Public Class Form1
Private Sub Button1_Click(ByVal sender As System.Object, ByVal e 
As System.EventArgs) Handles Button1.Click
Dim stud1 As New student
Dim Total As Double
stud1.Number = 1245
stud1.Gpa = 2.4
stud1.Points = 10
Total = stud1.Gpa * stud1.Points
MsgBox("total points of Gpa " & stud1.Gpa & "with points"
& stud1.points & "equal to " & Total)
End Sub
Figure 3.4 shows the output.
Fig. 3.4 Program output

56
Chapter Three
The field can be static or dynamic arrays. When using dynamic arrays, 
ReDim statement (in VB.Net) must be used before assigning values to 
them.
The following example defines a dynamic array field in a class:
'''C#
public class MyClass
{
public int[] DynamicArray;
}
In this example, 'DynamicArray' is a field of type 'int[]', which is an 
integer array. It's considered "dynamic" because its size isn't specified at 
the time of declaration, and can be determined at runtime.
Similarly, for VB.NET:
'''VB
Public Class MyClass
Public DynamicArray() As Integer
End Class
Here, 'DynamicArray' is an integer array whose size is not specified at 
declaration time, making it dynamic.
To instantiate these arrays, you can do the following:
In C#:
MyClass myObject = new MyClass();
myObject.DynamicArray = new int[5];
In VB.NET:
Dim myObject As New MyClass()
ReDim myObject.DynamicArray(4)
In the above examples, the 'DynamicArray' field has been initialized to 
hold 5 integers. The array indices will range from 0 to 4.
VB Example
Class arrayclass
Public x(2) As Integer
Public y() As Integer
End Class

Object-Oriented Programming Concepts
57
Sub Main()
Dim ArrayObject As New arrayclass()
ArrayObject.x(0) = 10
ArrayObject.x(1) = 20
ArrayObject.x(2) = 30
ReDim ArrayObject.y(3)
ArrayObject.y(0) = 100
ArrayObject.y(1) = 200
ArrayObject.y(2) = 300
ArrayObject.y(3) = 400
Console.WriteLine(ArrayObject.x(0)) '10
Console.WriteLine(ArrayObject.y(1)) '200
Console.ReadLine()
End Sub
Example: A program for calculating the amount of zakah, which 
represents 2.5% of the money, in VB.NET
Class arrayclass
Public Money() As Integer = {3400, 4000, 4500, 10000, 7000, 5600,
6000, 8000, 9400, 20000}
Public Function Zakah(ByVal x As Integer) As Double
Dim Final As Double
Final = x * 0.025
Return Final
End Function
End Class
Sub Main()
Dim ArrayObject As New arrayclass()
For i = 0 To UBound(ArrayObject.Money)
Console.WriteLine("Zakat Elmal for : " &
ArrayObject.Money(i) & " is Equal to " &
ArrayObject.Zakah(ArrayObject.Money(i)))
Next
Console.ReadLine()
End Sub
C#
class Arrayclass
{
public int [] Money = { 3400, 4000, 4500, 10000, 7000, 5600, 
6000, 8000, 9400, 20000 };

58
Chapter Three
public double Zakah(double x)
{
double Final;
Final = x * 0.025;
return Final;
}
}
static void Main(string[] args)
{
Arrayclass arrayobject = new Arrayclass();
for (int i = 0; i <= arrayobject.Money.GetUpperBound(0); i++)
{
Console.WriteLine("Zakat Elmal for : " + arrayobject.Money[i] + 
" is equal to" + (arrayobject.Zakah(arrayobject.Money[i])));
}
Console.ReadLine();
}
Figure 3.5 illustrates the running screen.
Fig. 3.5 Running screen
Exercise: Enhance the previous example by including a check for the 
amount of money. If the money does not reach the required quorum, 
display a message stating "There is no zakah". Otherwise, display the 
calculated amount of zakah.
Fields can be protected from tampering by making them read-only using 
the 'readonly' keyword when they are defined. By using the 'readonly' 
keyword, you prevent any assignment of a new value to the field. 
However, the ability to read the field value still remains.

Object-Oriented Programming Concepts
59
Class simpleclass
Public ReadOnly createdDate As Date = Now()
End Class
Sub Main()
Dim obj1 As New simpleclass
Obj1.createdDate = Now() 'Error message
MsgBox(obj1.createdDate)
End Sub
Figure 3.6 shows the error message
Fig. 3.6 Error message
3.4 Methods
Methods are conventional procedures, such as Subs or Functions, that are 
defined within a class. The following code demonstrates the addition of 
the Total() method to the 'Student' class in VB.Net.
class student
Public Number As Integer
Public Gpa As Double
Public Points As Integer
Public Sub Total()
Console.WriteLine("Total= " & Gpa * Points)
End Sub
End Class

60
Chapter Three
The general syntax for calling methods from outside their class via the 
object 
named 
Object_reference_name 
is:
Object_reference_name.method_name(actual parameters) in VB.NET, 
and
Object_reference_name.method_name(actual parameters) in C#.
We can call the previous ‘Total’ method from outside its class, as 
demonstrated in the following code:
Sub Main()
Dim st1 As New student
st1.Number = 2345
st1.Gpa = 2.3
st1.Points = 10
st1.Total()
Console.ReadLine()
End Sub
Figure 3.7 shows the output.
Fig. 3.7 Program output
Modify the employee class (in python) by adding method named 
“welcome” as following:
class Employee:
name="Abd Elrhman"
age=25
def welcome(self):
print("Hello","\t",self.name)
emp= Employee ()
emp.welcome()
NOTE: The “def” keyword is used to define functions. The self-argument 
refers to the object itself. “\t” is used to do whitespace.
The output will be:

Object-Oriented Programming Concepts
61
Hello Abd Elrhman
Modify the employee class by adding a new method that calculates the 
salary, multiplying the number of worked hours by the hourly wage, as 
follows:
class Employee:
name="Abd Elrhman"
age=25
def welcome(self):
print("Hello","\t",self.name)
def salary(self,hours,hourly_wages):
return hours*hourly_wages
emp=Employee()
emp.welcome()
print(emp.salary(15,200))
The output will be:
Hello Abd Elrhman
3000
Example: To calculate the Body Mass Index (BMI). BMI is a 
measurement that assesses a person’s leanness or corpulence by 
considering their height and weight, and is used to estimate the amount of 
body tissue.
Class class1
Function BMI(ByVal height As Single, ByVal weight As
Single) as single
BMI = weight / height A 2
End Function
End Class
Sub Main()
Dim obj1 As New class1
Dim h, w As Single
h = InputBox("what is your height in meter")
w = InputBox("what is your weight in Kg")
MsgBox(obj1.BMI(h, w))
End Sub
Example:
Testing numbers ranging from 1 to 10, where even numbers are squared.
Class squaretest
Public Function squareeven(ByVal x As Integer) As Double

62
Chapter Three
Dim odd As Integer
If x Mod 2 = 0 Then
Return x * x
Else
Return odd
End If
End Function
End Class
Sub Main()
Dim number As New squaretest
Dim i As Integer
For i = 1 To 10
If number.squareeven(i) <> 0 Then
Console.WriteLine("Number " & i & " is an even number with " & 
" square= " & number.squareeven(i))
Else
Console.WriteLine("Number " & i & " is an odd number")
End If
Next
Console.ReadLine()
End Sub
C#
class squaretest
{
public double squareeven (int x)
{
int odd;
if (x % 2 == 0)
return x * x;
else
return odd;
}
}
class Program
{
static void Main(string[] args)
{
squaretest number = new squaretest();
for (int i=1; i<=10;i++)
{

Object-Oriented Programming Concepts
63
if (number.squareeven(i) !=0 )
Console.WriteLine ("Number" + " "+ i + " is an even number with" + " 
" + "square" + number.squareeven(i));
else
Console.WriteLine("Number" +" " + i + " is an odd number");
}
Console.ReadLine();
}
}
Figure 3.8 shows the code output.
Fig. 3.8 Code output
Example to perform simple arithmetic operations:
Module Module1
Class mathoperation
Public result As Double
Sub sum(ByVal firstnumber As Double, ByVal secondnumber As 
Double)
result = firstnumber + secondnumber
Console.WriteLine("The Summtion Result is :" & result)
End Sub
Sub multi(ByVal firstnumber As Double, ByVal secondnumber As 
Double)
result = firstnumber * secondnumber
Console.WriteLine("The Multiplication Result is: " & result)

64
Chapter Three
End Sub
Sub subt(ByVal firstnumber As Double, ByVal secondnumber As 
Double)
result = firstnumber - secondnumber
Console.WriteLine("The Subtraction Result is:" & result)
End Sub
Sub div(ByVal firstnumber As Double, ByVal secondnumber As 
Double
If secondnumber = 0 Then MsgBox("Error: Divide By Zero ") 
result = firstnumber / secondnumber
Console.WriteLine("The Division Result is:" & result)
End Sub
End Class
Sub Main()
Dim obj As New mathoperation
Dim code As Integer
Dim num1, num2 As Double
While True
Console.WriteLine("Please Enter Choise:")
Console.WriteLine("1. Summtion")
Console.WriteLine("2. Multiplication")
Console.WriteLine("3. Subtraction ")
Console.WriteLine("4. Division")
Console.WriteLine("5. Exit (any other value)")
code = Console.ReadLine()
If code <> 1 And code <> 2 And code <> 3 And code <> 4 Then 
Exit While
Console.WriteLine("Please Enter the First Number")
num1 = Console.ReadLine()
Console.WriteLine("Please Enter the Second Number")
num2 = Console.ReadLine()
Select Case code
Case 1
obj.sum(num1, num2)
Case 2
obj.multi(num1, num2)
Case 3
obj.subt(num1, num2)
Case 4
obj.div(num1, num2)
End Select

Object-Oriented Programming Concepts
65
End While
End Sub
End Module
Fig. 3.9 Program output
The following example uses a Windows forms application project to 
perform calculations in C#.
class ArthOperation
{
public double res;
public double mysum(double v1, double v2)
{
res = v1 + v2;
return res;
}
public double subt(double v1, double v2)
{
res = v1 - v2;
return res;
}
public double mult(double v1, double v2)
{
res = v1 * v2;
return res;
}
public double div(double v1, double v2)
{
res = v1 / v2;
return res;
}
}
public partial class Form1 : Form

66
Chapter Three
{
public Form1()
{
InitializeComponent();
}
double z;
ArthOperation mathobj = new ArthOperation();
private void button1_Click(object sender, EventArgs e)
{
z = mathobj.mysum(Convert.ToDouble(textBox1.Text), 
Convert.ToDouble(textBox2.Text));
textBox3.Text = z.ToString();
}
private void button2_Click(object sender, EventArgs e)
{
z = mathobj.subt(Convert.ToDouble(textBox1.Text), 
Convert.ToDouble(textBox2.Text));
textBox3.Text = z.ToString();
}
private void button3_Click(object sender, EventArgs e)
{
z = mathobj.mult(Convert.ToDouble(textBox1.Text), 
Convert.ToDouble(textBox2.Text));
textBox3.Text = z.ToString();
}
private void button4_Click(object sender, EventArgs e)
{
if (Convert.ToDouble(textBox2.Text) == 0)
{
MessageBox.Show("Cannot divided by zero ");
}
else
{
z = mathobj.div(Convert.ToDouble(textBox1.Text), 
Convert.ToDouble(textBox2.Text));
textBox3.Text = z.ToString();
} 
} } }
Figure 3.10 illustrates sample of output.

Object-Oriented Programming Concepts
67
Fig. 3.10 Sample of program output
A program for calculating the net salary of employees in a company with 
deductions for the number of days absent, a 3% deduction from the salary 
for taxes, and a 5% bonus calculated based on the employee’s original 
salary.
Public Class salarycls
Function mainsalary(ByVal salary As Single, ByVal Num_App_Day 
As Integer) As Single
Dim salperday As Single
salperday = salary / 30
Dim discount_salperday As Single
discount_salperday = salperday * Num_App_Day 
mainsalary = salary - discount_salperday
End Function
Function discount(ByVal Des_count As Integer, ByVal salary As 
Single) As Single
Const percentage As Single = 0.03
discount = (salary * percentage) * Des_count
End Function
Function incentive(ByVal incent_count As Int16, ByVal salary As 
Single) As Single
Const percentage As Single = 0.05
incentive = (salary * percentage) * incent_count

68
Chapter Three
End Function
End Class
Public Class Form1
Dim a, b, c, d As Integer
Private Sub Button1_Click(ByVal sender As System.Object, ByVal e
As System.EventArgs) Handles Button1.Click
TextBox1.Text = ""
TextBox2.Text = ""
TextBox3.Text = ""
TextBox4.Text = ""
End Sub
Private Sub Button2_Click(ByVal sender As System.Object, ByVal e 
As System.EventArgs) Handles Button2.Click
Dim obj1 As New salarycls
a = Val(TextBox1.Text)
b = Val(TextBox2.Text)
c = TextBox3.Text
d = TextBox4.Text
Dim x, y, z, net As Integer
x = obj1.mainsalary(a, b)
y = obj1.discount(c, a)
z = obj1.incentive(d, a)
net = x + z - y
TextBox5.Text = net
End Sub
End Class
The following program is used to calculate the square, square root, and 
cube of a number in VB.NET.
Module Module1
Class number
Function square(ByVal num As Integer) As Integer
Return num * num
End Function
Function square_root(ByVal num As Integer) As Integer
Return Math.Sqrt(num)
End Function
Function cube(ByVal num As Integer) As Integer
Return num * num * num
End Function

Object-Oriented Programming Concepts
69
End Class
Sub Main()
Dim obj1 As New number
Dim num As Integer
Console.WriteLine(" Enter the Number")
num = Console.ReadLine()
Console.WriteLine("Square of the Number Is =" & 
obj1.square(num))
Console.WriteLine("Square Root of the Number is =" & 
obj1.square_root(num))
Console.WriteLine("Cube of the Number is =" & obj1.cube(num))
Console.ReadLine()
End Sub
End Module
C#:
class Numbers
{
public double square(double num)
{
return num * num;
}
public double square_root(double num)
{
return Math.Sqrt(num);
}
public double cube(double num)
{
return num * num * num;
}
}
static void Main(string[] args)
{
Numbers obj1 = new Numbers();
double num;
Console.WriteLine(" Enter the Number");
num = Convert.ToDouble (Console.ReadLine());
Console.WriteLine("Square of the Number is =" + 
obj1.square(num));
Console.WriteLine("Square Root of the Number is =" + 
obj1.square_root (num));

70
Chapter Three
Console.WriteLine("Cube of the Number is =" + obj1.cube (num));
Console.ReadLine();
}
Figure 3.11 shows sample of output.
Fig. 3.1 
1 Sample of output
You can use a method to assign values to the properties and fields most 
frequently used in the class, which helps to avoid writing duplicate lines of 
code. You can define this method by assigning values to the most 
frequently used properties and fields in the class as shown below:
Class person
Public name As String
Public age As Integer
Public address As String
Sub SetValues(ByVal personName As String, ByVal personAge As 
Integer, ByVal personAddress As String)
name = PersonName
age = personAge
address = PersonAddress
End Sub
End Class
Instead of assigning the value of each field individually, call this method 
in a single step as following:
Sub Main()
Dim personobject As New person() 
personobject.SetValues("Abdallah", 13, " Mansoura") 
Console.WriteLine("my name is " & personobject.name) 
Console.WriteLine("i'm" & personobject.age & " years old") 
Console.WriteLine("I live in " & personobject.address) 
Console.ReadLine()

Object-Oriented Programming Concepts
71
End Sub
C#:
class person
{
public string name;
public int age;
public string address;
public void Setvalues(string personname, int personage, string 
personaddress)
{
name = personname;
age = personage;
address = personaddress;
}
}
static void Main(string[] args)
{
person personobject = new person();
personobject.Setvalues("Abdallah", 13, " Mansoura");
Console.WriteLine("my name is "+ personobject.name);
Console.WriteLine("i'm " + personobject.age + " years old");
Console.WriteLine("I live in "+ personobject.address);
Console.ReadLine();
}
Figure 3.12 shows sample of output
Fig. 3.1 2 Sample of output

72
Chapter Three
3.5 Properties
Properties combine the characteristics of fields and methods. They allow 
you to assign and retrieve values. Properties are a type of program element 
that encapsulates data and provides access to it. To declare a new property, 
use the keyword ‘property’ followed by the property’s name and data type, 
as shown in the following code:
Class student
Property Address () as string
End property
End class
Two procedures are added to the property. The first procedure is Get, 
which is called when the value of this property is read, and the second 
procedure is Set, which is called when another value is assigned to the 
property. The property is preferably declared as private. The following 
code demonstrates how to use the Address attribute to set the value of the 
studentAddress field:
Class student
Private studentAddress As String
Property Address() As String
Get
Return studentAddress
End Get
The property’s value type must match the value parameter, which is a 
string, and it must be passed along with the value.
Set(ByVal value As String) 
studentAddress = value
End Set
End Property
End Class
Alternatively, properties can be treated similarly to fields, allowing you to 
assign values to them and retrieve their values.
Sub Main()
Dim stud As New student
stud.Address = "cairo-egypt"

Object-Oriented Programming Concepts
73
Console.WriteLine(stud.Address)
Console.ReadLine()
End Sub
Assigning the value 'cairo-egypt' to the Address property triggers the set 
procedure, which receives the parameter value ('cairo-egypt') and assigns 
it to the studentAddress field. When reading the value of the Address 
property, the Get procedure is invoked, which returns the value of the 
studentAddress field using the reserved word 'Return'. Figure 3.13 displays 
the output of the main procedure.
Fig. 3.13 Output of main procedure
To create a read-only property, you simply need to use the 'readonly' 
keyword before the 'property' keyword. In this case, the Set procedure is 
not required, as shown in the following code:
Readonly property studentID() as integer
Get
Return studentID
End Get
End property
Similarly, using the reserved word 'writeonly' with the property makes it a 
write-only property, eliminating the need for the Get procedure in this 
case.
Writeonly property set_student_password () as string
Set (byval value as string)
Student_password=value
End set
End property
Properties can accept parameters similar to methods. You can specify the 
parameters at the beginning of the property definition. If you wish to 
assign or read property values, you need to provide the required 
parameters within parentheses.
Class personclass
Private m_Address(2) As String

74
Chapter Three
Property Address(ByVal index As Integer) As String 
Get
If index >= 0 And index <= UBound(m_Address) Then
Return m_Address(index)
Else
Return “”
End If
End Get
Set(ByVal Value As String)
If index >= 0 And index <= UBound(m_Address) Then 
m_Address(index) = Value
End If
End Set
End Property
End Class
Sub Main()
Dim p1 As New personclass
Dim counter As Integer
P1.Address(0) = "Elsalam street"
P1.Address(1) = "Elnaser street"
P1.Address(2) = "Eltahrir street"
For counter = 0 To 2
Console.WriteLine(p1.Address(counter))
Next
Console.ReadLine()
End Sub
Default Property
Default properties are properties that allow you to assign or read values 
using only the name of their object, without having to specify the name of 
the property. To make a property the default property, use the 'Default' 
keyword.
Default Property Address(ByVal index As Integer) As String
End property

Object-Oriented Programming Concepts
75
When you access the Address property (which has been designated as the 
default property), you can simply mention the name of its object without 
specifying the name of the property.
Class students
Private st_name(2) As String
Default Property name(ByVal index As Integer) As String
Get
If index >= 0 And index <= UBound(st_name) Then
Return st_name(index)
Else
Return ""
End If
End Get
Set(ByVal Value As String)
If index >= 0 And index <= UBound(st_name) Then 
st_name(index) = Value
End If
End Set
End Property
End Class
Module Module1
Sub Main()
Dim stud As New students
Dim counter As Integer
stud(0) = "Abd Elrahman"
stud(1) = "Ahmed"
stud(2) = "Nada"
For counter = 0 To 2
Console.WriteLine(stud.name(counter))
Next
Console.ReadLine()
End Sub
End module
Figure 3.14 shows the output of main procedure.

76
Chapter Three
Fig. 3.14 Output of main procedure
Example.
Public Class computer
Dim varpname, varpspeed, varram, varcdspeed As String
Property processorname() As String
Get
processorname = varpname
End Get
Set(ByVal value As String)
varpname = value
End Set
End Property
Property processorspeed() As String
Get
processorspeed = varpspeed
End Get
Set(ByVal value As String)
varpspeed = value
End Set
End Property
Property ram() As String
Get
ram = varram
End Get
Set(ByVal value As String) 
varram = value
End Set

Object-Oriented Programming Concepts
77
End Property
Property cdspeed() As String
Get
cdspeed = varcdspeed
End Get
Set(ByVal value As String)
varcdspeed = value
End Set
End Property
Public Function recommendation(ByVal pname As String, ByVal pspeed
As String, ByVal vram As String, ByVal vcdspeed As String)
Dim result As String
result = "The Given Specifications:"
result = result & Chr(13) & Chr(10)
result = result & "Processor Name:" & pname
result = result & Chr(13) & Chr(10)
result = result & "Processor Speed:" & pspeed
result = result & Chr(13) & Chr(10)
result = result & "Ram:" & ram
result = result & Chr(13) & Chr(10)
result = result & "CD Speed:" & cdspeed
result = result & Chr(13) & Chr(10)
result = result & "We Recommends Windows XP !!"
result = result & Chr(13) & Chr(10)
result = result & "Happy Working !!"
Return result
End Function
End Class
Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As
System.EventArgs) Handles Button1.Click
Dim objcomp As New computer
objcomp.processorname = TextBox1.Text
objcomp.processorspeed = TextBox2.Text
objcomp.ram = TextBox3.Text
objcomp.cdspeed = TextBox4.Text
'Call the recommendation method
textbox5.Text = objcomp.recommendation(objcomp.processorname, 
objcomp.processorspeed, objcomp.ram, objcomp.cdspeed)
End Sub
Figure 3.15 shows the form at running mode.

78
Chapter Three
Fig. 3.15 Form at running mode
3.6 Objects
Objects are the actual instances of classes where you don't interact with 
classes directly. You can create a new object using the 'new' keyword 
during the instantiation process, as we will explain in the next section.
The following table presents some properties and operations of a group of 
objects.
Table 3.1: Properties and operations of a group of objects.
Object
student
Fruit
Polygon
Attributes
Name 
date of birth 
marks
Color
Taste
Vertices 
border color 
fill color
Methods
Total
Average
Display
Cost
Collect
Draw 
Erase 
move
Another example of classes and objects is a transportation class that 
includes entities like cars, planes, and ships. A clear example can be seen 
in window applications using the Graphic User Interface (GUI). The 
'Properties window' is an object of the window class, and 'Button1' is an 
object of the Button class. All objects belonging to a particular class share 

Object-Oriented Programming Concepts
79
the same attributes and behaviors. When we interact with an individual 
window, we are interacting with an object. However, when we refer to 
windows in general, we are referring to the entire class. Figure 3.16 
displays a sample of objects from the window class.
From the above, it is evident that objects are instances of classes.
To reinforce this, consider that programming languages include built-in 
data types such as 'int,' which represents the integer data type. This allows 
us to define variables of this type by specifying the variable name 
following the 'int' keyword, as shown in the following examples: 
int day;
int count;
Similarly, you can define a group of objects from the same class, just as 
the 'int' data type does not create any variables on its own.
To create an object
Dim object_name As New class_name( ) 
' VB.NET
Class_name object_name=new class_name(); 
// C#
Object_name= class_name() 
# Python
The 'object_name' variable is a reference to an object stored in an area of 
memory called the 'Managed Heap,' which is managed by the .NET 
framework. Its size is 4 bytes, regardless of the class it is created from, as 

80
Chapter Three
it stores the memory address of the object rather than the actual object 
data.
Example: using windows applications
Public Class Robot
Public Sub move()
MsgBox("my name is rockey i have two small feet and light i move 
now")
End Sub
End Class
Public Class Form1
Private Sub Button1_Click(ByVal sender As System.Object, ByVal e
As System.EventArgs) Handles Button1.Click
Dim a As New Robot
a.move()
End Sub
End Class
Figure 3.17 represents the running of the previous code.
Fig. 3.17 Screen of running
You can use a console application project to create the previous robot 
class. From the project menu, select 'Add class' to add a new class to your 
project. Write the name of the class, its properties, and its functions as 
shown below:
Public Class robot
Public name As String
Public weight As Single
Public Sub turn_right()
Console.WriteLine("Turn right")
End Sub
Public Sub turn_left()

Object-Oriented Programming Concepts
81
Console.WriteLine("Turn left")
End Sub
End Class
In the previous example, a class was created to represent a robot, which 
has two properties: name and weight. Additionally, it has two methods: 
one to turn right and the other to turn left. The next step is to create objects 
of this class within the 'Main' subroutine, where we define 'robot1' and 
'robot2' as shown in the following code:
Sub Main()
Dim robot1 As New robot
robot1.name = "Robot number1"
robot1.weight = 125.5
robot1.turn_left()
Console.WriteLine("
Dim robot2 As New robot
*******************************")
robot2.name = "Robot number2" 
robot2.weight = 150 
robot2.turn_right()
Console.ReadLine()
End Sub
Figure 3.18 shows the output.
Fig. 3.18 Output of Sub Main
Note that the object use all or one of the class’ members.
Sub Main()
Dim robot1 As New robot()
robot1.name = "Body"
Console.WriteLine(robot1.name)
robot1.turn_right()
Console.ReadLine()

82
Chapter Three
End Sub
Declaring an object serves two purposes:
1. Declaring a reference using the object's name.
2. Allocating memory for the object and assigning it a reference or 
pointer. This reference is a class variable.
The 'New' keyword is used to create the actual object and reserve an area 
for it in the Managed Heap memory. You can use it while declaring the 
variable (pointer) or when assigning a value to it using the assignment 
operator '='.
Dim TestObject As New TestClass () ' VB.NET
Dim TestObject As TestClass
TestObject = New TestClass
TestClass TestObject=new TestClass (); //C#
The following example illustrates that object variables are essentially 
memory addresses pointing to real objects. In the given example, the 
variables 'st2' and 'st1' actually refer to the same object. Therefore, any 
changes made to this object will be reflected in both 'st1' and 'st2' 
variables.
Class student
Public name As String
Public age As Integer
End Class
Sub Main()
Dim st1 As New student 'New object
Dim st2 As student
St2 = st1
St2.name = "Ahmed Hesham"
St2.age = 10
Console.WriteLine(st1.name)
Console.WriteLine(st2.age)
Console.ReadLine()
End Sub
Figure 3.19 represents output of Main procedure.

Object-Oriented Programming Concepts
83
file:///C:/Documents and Settings/Administrator/Local Settings/A 
ft limed Hesliam 
10
Fig. 3.19 Output of Main procedure
Example:
class dog
{
public int age;
public void adog()
{
if (age < 2)
MessageBox .Show ("dog barks three time per hour"); 
else
MessageBox.Show ("dog barks once time per hour");
}
}
class Program
{
static void Main(string[] args)
{
dog obj1=new dog();
obj1.age=3;
obj1.adog();
Console.ReadLine();
}
}
Figure 3.20 shows the running of Main procedure.
Fig. 3.20 Running of Sub Main.

84
Chapter Three
In the previous example, a class called 'Dog' was created with its own 
properties. Then a value was assigned to an object named 'obj'. By calling 
the 'adog' function, the age is tested using an 'if' statement, and the 
appropriate message is printed. In this case, the message 'dog barks once 
per hour' appears when the age is equal to 3.
The following example is used to calculate the balance of a customer in a 
bank after adding the profits calculated based on a certain interest rate 
entered by the user. First, the user enters the customer’s name, the value of 
their current account, and then the profit percentage.
Public Class Customer
Public name As String
Public Function Balance(ByVal retacc As Double, ByVal retprofit As 
Double) As Double
Dim finalvalue As Double
finalvalue = retacc + retacc * retprofit
Return finalvalue
End Function
End Class
Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As 
System.EventArgs) Handles Button1.Click
Dim cust1 As New Customer
Dim retacc As Double
Dim retprofit As Single
Name = InputBox("Please Enter your Name")
retacc = InputBox("Please Enter your Current Account") '25000 
retprofit = InputBox("Please Enter Profit Ratio") '0.15
MsgBox(" The Balance After Adding Profit Ratio Is" & 
cust1.Balance(retacc, retprofit))
End Sub
Figure 3.21 shows sample of the output.

Object-Oriented Programming Concepts
85
Fig. 3.21 Sample of output
Note: We can use the 'With...End With' structure to speed up access to the 
members of an object without having to type its name. However, please 
note that it is not used in C#.
Public Class car
Public color As String = "blue"
Public body As String = "saloon"
Public motion As String = "vroom!"
Public Function accelerate()
Return motion
End Function
End Class
Sub Main()
Dim obj1 As New car()
With obj1
.color = "red"
.body = "coupe"
Console.Write("color is ")
Console.WriteLine(.color)
Console.Write("body type is ")
Console.WriteLine(.body)
Console.Write("motion is ")
Console.WriteLine(.accelerate())
Console.ReadLine()
End With
End Sub
Figure 3.22 shows output of Main procedure

86
Chapter Three
Fig. 3.22 Output of Sub Main
Initially, the ‘car’ class was defined with initial values for its properties. 
Additionally, a method called ‘accelerate’ was created. Note that when 
defining an object ‘obj1’ of this class, new values are assigned instead of 
the initial values inside the ‘car’ class. Also, note that the object name is 
not repeated due to the use of ‘With...End With’.
3.7 Constructors
Constructors are procedures that control the initialization of an object. The 
‘Sub New()’ is executed once when an object of this class is created. To 
create a constructor for a class, we use the keyword ‘New’ as a procedure 
inside the class and add all the statements we want to execute when 
creating a new object of this class.
We have already mentioned that the ‘Main()’ procedure in the module is 
the procedure that is automatically executed. However, if the ‘New’ 
procedure exists, it will be executed first, as shown in the following 
example:
Module Module1
Sub Main()
MsgBox("module1 sub main")
End Sub
Sub New()
MsgBox("module1 sub new")
End Sub
End Module
Figure 3.2 3 shows the output, where Sub New is executed before sub 
Main.

Object-Oriented Programming Concepts
87
Fig. 3.23 Sub New is executed before Sub Main.
If a new object such as MyObject is created, the Sub New is executed
Dim MyObject As New My_Class()
In the following case, the Sub New procedure will not be executed
Dim TestObject As My_Class
And neither in this case
TestObject2 = My_Object
Example:
Public Class Testclass
Sub New()
Console.WriteLine("IT WILL BE RUN")
End Sub
End Class
Sub Main()
Dim testobject As New Testclass
End Sub
Figure 3.2 4 illustrates the output.
‘ < "C:\Documents and Settings\sc\My DocumentsWisual Studio Projects\ConsoleAppIication8\b.
IT WILL BE
(Press any key to continue
Fig. 3.24 Output screen

88
Chapter Three
Please note that 'Sub New' does not return any value, and if you misspell 
its name ('New'), you define a regular procedure that will not be called 
when creating a new object of the class.
One of the reasons we use constructors is that when creating a new object, 
we can pass initial parameters (parameterized constructor). For example, if 
we want to create a class for subjects where the subject number represents 
the parameter of 'Sub New', so that we can search for the subject data in 
the containing database.
Public Class Course
Sub New(ByVal CourseID As Integer)
'FindCourseInfo(CourseID)
MsgBox(CourseID)
End Sub
End Class
To create a new object and set the initial values, we can use the following 
statement:
Dim TrainingCourse As Course = New Course(100)
Figure 3.25 shows the running screen where the message box contains the 
value of the 'CourseID' parameter."
Fig. 
3.25 Parameterized constructor

Object-Oriented Programming Concepts
89
3.8 Destructors
Destructors in contrast to constructors, a destructor is a special procedure 
that is automatically executed when you have finished using objects and 
want to free them from memory. The primary destructor in the VB.NET 
environment is called ‘Finalize’, and it is invoked when the garbage 
collector frees memory. This may cause a time delay between when the 
object is actually used in the program and when the garbage collector 
starts freeing memory. For example, suppose you want to display a 
goodbye message or beep when you terminate the use of the object.
Class line
Private length As Double ' length of a line
Public Sub New(ByVal len As Double)
MsgBox("object is being created")
length = len
End Sub
Protected Overrides Sub finalize()
MsgBox("GoodBye...!!" & vbNewLine & "now !! object was
terminated." & Now(), MsgBoxStyle.Information)
End Sub
Public Function getlength() As Double
Return length
End Function
End Class
Sub Main()
Dim line As line = New line(6)
MsgBox("length of line" & " " & line.getlength())
End Sub
Code execuation is shown in figure 3.26.

90
Chapter Three
Fig. 3.26 Code execuation
Objects Lifetime
Within the .NET environment, the lifetime of objects is unpredictable, so 
we divide the life of objects into two types: logical life and real life. 
The logical lifetime starts from the moment the object is created until all 
references to that object disappear. The following example demonstrates 
how to create a reference to a new object using the reserved word ‘New’ 
and how to make this single reference disappear by assigning the value 
‘Nothing’ to it:
Dim myObject As New MyClass
'This is where the life of the object begins
myObject = Nothing
'Here ends the object's logical life

Object-Oriented Programming Concepts
91
However, if an object has more than one reference to it, its logical life is 
extended until the object loses its last reference.
Dim myObject1 As New MyClass 
Dim myObject2 As New MyClass 
myObject1 = myObject2 
myObject1 = Nothing 
'The disappearance of a reference does not mean that the logical object has 
expired.
myObject2 = Nothing 'Now the logical object has expired.
The real life of an object is the period during which the object retains its 
data in memory. The real life starts when a new instance of an object is 
created using the 'New' keyword (just like the logical lifetime). However, 
the endpoint of the object's real life is not simply when all references to it 
are gone, but until the garbage collector decides it's time to free memory. 
The 'Finalize' method is then executed, and the object is removed from 
memory.

Chapter Four
Inheritance
Inheritance is one of the main concepts in OOP languages and a 
cornerstone of code reusability. An object can inherit the properties of a 
specific class and extend or add to them without modifying the original 
class, facilitating the reuse of previously created classes. For example, 
there could be a class called 'Vehicle' that includes common characteristics 
of all vehicles, such as name, color, and registration number. The 'Plane' 
class can inherit from the 'Vehicle' class and add specific characteristics of 
a plane. Similarly, the 'Cube' class can inherit from the 'Square' class and 
add additional properties such as depth and volume. In this case, the class 
being inherited from is referred to as the parent class, base class, or super 
class, while the class inheriting from it is called the child class or subclass.
Class Vehicle
NumWheels
NumDoors
Color
Drive()
End class
Class Plane
Inherits Vehicle
End class
By utilizing inheritance, a generic class can be created to define common 
attributes. These specific classes can then inherit from the generic class, 
allowing for the addition of their specific attributes.
Therefore, we can say that the subclass is a specialized or derived class 
from the superclass. The subclass inherits all variables and methods 
defined by the superclass.
For instance, the Student class encompasses various data such as code, 
name, address, phone number, date of birth, and more. It also includes 
functions like student data registration, student data deletion, student data 
modification, and others. When we examine the Teacher class, we observe

Inheritance
93
that it incorporates many data and functions that are members of the Student 
class, along with additional members. Therefore, utilizing the concept of 
inheritance saves us from rewriting and duplicating code for new classes, 
ultimately saving a significant amount of time. Furthermore, this approach 
enables us to leverage pre-existing and thoroughly tested classes.
If we have a class representing a person with properties such as name and 
age, we can derive another class from it (Employee) to inherit the two 
properties from the base class (name, age), along with additional members. 
Figure 4.1 illustrates examples of inheritance.
Fig. 4.1 Examples of inheritance

94
Chapter Four
One important advantage of inheritance is that it allows us to create a 
superclass that defines common attributes for a group of objects, and then 
create any number of subclasses that add their own unique characteristics. 
This allows for faster application development, as we can create a main 
class as a base from which members are inherited without the need to 
obtain the source code. For example, let's imagine that we have created a 
class for vehicles with only two doors, and now we want to use it to 
develop vehicles with four doors.
Public Class Coupe
Inherits Sedan
Overrides Sub BuildDoors()
Doors = Doors + 2
End Sub
End Class
The syntax of declaring a class that inherits from a superclass in Python is 
as follows:
class SuperClass_name:
#body of class
class SubClass_name(SuperClass_name):
#body of class
In VB.Net
Class superclass-name
// body of class
End Class
Class subclass-name
Inherits superclass-name
// body of class
End Class
In C#
Class superclass-name {
// body of class
}
Class subclass-name: superclass-name
{

Inheritance
95
// body of class
}
The following (VB.Net) example demonstrates the creation of a base 
class for geometric shapes and a derived class for the rectangle along 
with finding its area and perimeter.
Module Module1
Class Shape 
' Base class
Protected width As Integer
Protected height As Integer
Public Sub setWidth(ByVal w As Integer) 
width = w
End Sub
Public Sub setHeight(ByVal h As Integer)
height = h
End Sub
End Class
Class Rectangle ' Derived class
Inherits Shape
Public Function getArea() As Integer
Return (width * height)
End Function
Public Function getperimeter() As Integer
Return (width + height) * 2
End Function
End Class
Dim rect As Rectangle = New Rectangle()
Console.WriteLine(" Please enter the width")
rect.setWidth(Console.ReadLine)
Console.WriteLine(" please enter the height")
rect.setHeight(Console.ReadLine)
' Print the area and the perimeter of the object.
Console.WriteLine("Total area:" & rect.getArea())
Console.WriteLine("Total perimeter:" & rect.getperimeter()) 
Console.ReadLine()
End Module

96
Chapter Four
C# :
class shape
{
protected int width;
protected int height;
public void setwidth(int w)
{
width = w;
}
public void setheight(int h)
{
height =h;
}
}
class Rectangle: shape
{
public double getArea()
{
return (width * height);
}
public double getPerimeter()
{
return (width + height) * 2;
}
}
static void Main(string[] args)
{
Rectangle rect = new Rectangle();
Console.WriteLine(" Please enter the width");
rect.setwidth (Convert.ToInt16 ( Console.ReadLine()));
Console.WriteLine(" please enter the height");
rect.setheight(Convert.ToInt16(Console.ReadLine()));
Console.WriteLine("Total Area:" + rect.getArea());
Console.WriteLine("Total Perimeter:" + rect.getPerimeter ());
Console.ReadLine();
}
Figure 4.2 shows sample of the output of main procedure.

Inheritance
97
Fig. 4.2 Sample of the output of main procedure.
Python
#superclass
class shape:
def setwidth(self,w):
self.width=w
def setheight(self,h):
self.height=h
#subclass
class rectangle(shape):
def getarea(self):
return(self.width*self.height)
#create object
rect=rectangle()
rect.setwidth(int(input("Enter rectangle width: "))) 
rect.setheight(int(input("Enter rectangle height: "))) 
print("Rectangle area= " , rect.getarea())
Output:
Enter rectangle width: 3
Enter rectangle height: 4
Rectangle area= 12
The following VB.Net example demonstrates the creation of a base 
class for a circle and a derived class for a spherical body, along with 
finding its diameter and perimeter.
Public Class Circle
Public Radius As Double
Public Function CalculateDiameter() As Double
Return Radius * 2
End Function

98
Chapter Four
Public Function CalculateCircumference() As Double
Return CalculateDiameter() * 3.14159
End Function
End Class
Public Class Sphere
Inherits Circle
Public Sub ShowCharacteristics()
Dim msg As String = ""
' Because Sphere is based on Circle, you can access any public 
member(s) of Circle without qualifying it(them)
Radius = InputBox("Enter the Radius")
msg = " Circle Characteristic " & vbCrLf & "==========" & 
vbCrLf & "Radius:" & Radius & vbCrLf & "Diameter:" & 
CalculateDiameter() & vbCrLf & "Circumference: " &
CalculateCircumference()
MsgBox(msg)
End Sub
End Class
Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As 
System.EventArgs) Handles Button1.Click
Dim ball As New Sphere
ball.ShowCharacteristics()
End Sub
C#
public class Circle
{
public double Radius;
public double CalculateDiameter()
{
return Radius * 2;
}
public double CalculateCircumference()
{
return CalculateDiameter() * 3.14159 ;
}
}
public class Sphere : Circle
{

Inheritance
99
public void ShowCharacteristics()
{
string msg = " ";
Radius =Convert.ToDouble(Interaction.InputBox ("Enter the 
Radius"));
msg= " Circle Characteristic " + "\n" + "==========" + "\n" + "Radius:" 
+ Radius + "\n" + "Diameter:" + CalculateDiameter() + "\n" 
+"Circumference: " + CalculateCircumference();
MessageBox.Show (msg);
}
}
private void button1_Click(object sender, EventArgs e)
{
Sphere ball = new Sphere();
ball.ShowCharacteristics();
}
Figure 4.3 illustrates sample of running.
Fig. 4. 
3 Sample of running

100
Chapter Four
Python
'import math library
import math
'superclass
class circle:
radius=0
def CalculateDiameter(self):
return self.radius*2
def CalculateCircumference(self):
return self.CalculateDiameter()*math.pi
'subclass
class sphere(circle):
def ShowCharacteristics(self):
self.radius=int(input("Enter the radius: "))
print("Radius= " , self.radius)
print("Diameter= " , self.CalculateDiameter())
print("Circumference= " , self.CalculateCircumference())
'create object
ball=sphere()
ball.ShowCharacteristics()
Output
Enter the radius: 3
Radius= 3
Diameter= 6
Circumference= 18.84955592153876
In the following VB.Net example, the Driver subclass includes all the 
members of the Employee superclass, which itself is a subclass of the 
Person superclass. Notice how the keyword 'Inherits' is used to create the 
subclass. The Driver class can access and utilize all the members from 
both the Person and Employee classes.
Public Class Person
Public name As String
Public age As Integer
End Class
Public Class Employee
Inherits Person
Public job As String
Public salary As Double
End Class

Inheritance
101
Public Class Driver 
Inherits Employee 
Public Sub card()
Console.WriteLine(name) 
Console.WriteLine(age) 
Console.WriteLine(job)
Console.WriteLine(salary) 
End Sub
End Class
Sub Main()
Dim obj As New Driver() 
obj.name = "Mohammed " 
obj.age = 35 
obj.job = "Driver" 
obj.salary = 2500 
obj.card()
Console.ReadLine()
End Sub
Figure 4.4 shows the output.
Fig. 4. 4 Output of main procedure
Python
#superclass
class Person():
def _init_(self,name,age):
self.name=name
self.age=age
#subclass_1
class Employee(person):
def _init_emp_(self,job,salary):

102
Chapter Four
self.job=job
self.salary=salary
def details(self):
print("My name: " , self.name)
print("My age: " , self.age)
print("My job: " , self.job)
print("My salary: " , self.salary)
#subclass_2
class Student(Person):
def _init_stud_(self,department,grades):
self.department=department
self.grades=grades
def details(self):
print("My name: " , self.name)
print("My age: " , self.age)
print("My department: " , self.department)
print("My grades: " , self.grades)
#Employee object
emp=Employee()
print("I'm an employee",'\n','.........')
emp._init_('Nada','27')
emp._init_emp_('Engineer',5000)
emp.details()
print('=========================================')
#Student object
stud=Student()
print("I'm a student",'\n','.........')
stud._init_('Abdelrhman',20)
stud._init_stud_('Computer Science','A+')
stud.details()
Output
I'm an employee
My name: Nada
My age: 27
My job: Engineer
My salary: 5000
I'm a student
My name: Abdelrhman

Inheritance
103
My age: 20
My department: Computer Science
My grades: A+
Note: The Employee class inherits from the Person class. If you try to 
define an object of the base class, you will not be able to access the 
members of the derived class, as shown in the following example.
Dim per1 As New Person
per1.name = "ahmed" ' ok
per1.job = "programmer" ' 'job' is not a member of
'ConsoleApplication1.Person'
Console.WriteLine(per1.name)
Console.ReadLine()
End Sub
On the other hand, you can derive the Person class multiple times to define 
another class in the same manner.
Class Person
Public name As String
Public age As Integer
End Class
Class Employee
Inherits Person
Public job As String
Public salary As Double
End Class
Class Student
Inherits Person
Public department As String
Public grades As Integer
End Class
Sub Main()
Dim stud1 As New Student
stud1.name = "Ahmed"
stud1.age = 20
stud1.department = "computer"
stud1.grades = 450
Console.WriteLine(stud1.name) ' Ahmed
Console.WriteLine(stud1.department) ' computer 
Console.ReadLine()

104
Chapter Four
End Sub
C# :
public class person
{
public string name;
public int age;
}
public class Employee : person
{
string job;
public double salary;
}
public class student : person
{
public string department;
public int grades;
}
static void Main(string[] args)
{
student stud1 = new student ();
stud1.name = "Ahmed";
stud1.age = 20;
stud1.department = "computer";
stud1.grades = 450;
Console.WriteLine(stud1.name); //Ahmed
Console.WriteLine(stud1.department); //computer 
Console.ReadLine();
}
Notes:
• One class can inherit members from multiple superclasses, which is 
known as multiple inheritance. However, 
 and C# do not 
support multiple inheritance, while Python does.
VB.Net
• In 
, you can use 'Me' to refer to the current class, and in 
C#, you can use 'this'. Additionally, in 
, you can use 
'MyBase', and in C#, you can use 'base' to refer to the base class 
from which the current class is derived.
VB.NET
VB.NET

Inheritance
105
• The derived class can access all members of the base class if they 
are defined as public or friend. Private members can only be 
accessed within the class itself, as illustrated in the following 
example.
Public Class a
Public i As Integer = 10
Private j As Integer = 20
Protected c As Integer = 100
Public function r()
Return j
End sub
End Class
Public Class b
Inherits a
Public Function m()
Console.WriteLine(i)
Console.WriteLine(c)
Console.WriteLine(j) ‘Error message
End Function
End Class
Note: The derived class can access all members of the base class if the 
members are defined at the public or friend level, which allows us to 
interact with both 'i' and 'c'. However, member 'j' is defined at the private 
level, restricting its accessibility to the base class itself. As a result, an 
error message appears: 'J is not accessible in this context because it is 
private.' . After removing the line:
Console.WriteLine(j)
From the function named 'm', we can proceed with completing the 
program as follows:
Sub Main()
Dim test As New b()
test.m()
Console.WriteLine(test.r())
End Sub
Figure 4.5 shows the output.

106
Chapter Four
Fig. 4.5 Output of main procedure
Note that defining members with 'Dim' instead of 'public' or 'friend' 
will limit the accessibility of the members to only the main class and 
not the derived classes. However, you can access these members 
through a public function included in the superclass. as shown in the 
following example.
Public Class item
Dim price As Double = 20
Dim category As String = "programming"
Public Function queryprice()
Console.WriteLine(price)
Console.WriteLine(category)
End Function
End Class
Public Class book
Inherits item
Dim no_of_pages As Integer = 800
Public Function query_pages()
Console.WriteLine(no_of_pages)
End Function
End Class
Sub Main()
Dim oobject As New book()
oobject.query_pages()
oobject.queryprice()
End Sub
The output is illustrated in figure 4.6.

Inheritance
107
C:\Documents and Setti ngs\gogo\My DocumentsWisual Stud
800
20
programming
Press any key to continue
Fig. 4. 6 Output of main procedure
The Book class is declared as a derived class from the base class called 
Item. It includes a data element representing the number of pages of the 
book ('no_of_pages'), with an initial value of 800, and a function that 
prints this number. Inside the 'Main' subroutine, a new object of the Book 
is created with the name 'oObject'. It can call the 'QueryPrice' function, 
which can interact with the members named 'price' and 'category' since the 
function is within the same class. However, note that you cannot access 
these two members through 'oObject' because they were defined using 
'Dim'.
In the following example, a superclass named ‘Class_a’ and a subclass 
named ‘Class_b’ are created.
Public Class Class_a
Public i, j As Integer
Public sub showij()
Console.Write("i and j")
Console.Write(" ")
Console.Write(i)
Console.Write(" ")
Console.WriteLine(j)
End sub
End Class
Public Class Class_b
Inherits Class_a
Public k As Integer
Public sub showk()
Console.Write("k: ")
Console.WriteLine(k)
End sub
Public sub sum()
Console.Write(" sum of i+j+k ")
Console.WriteLine(i + j + k)
End sub

108
Chapter Four
End Class
Sub Main()
Dim subobj As New Class_b()
subobj.i = 7
subobj.j = 8
subobj.k = 9
Console.WriteLine("contents of superclass and subclass ") 
subobj.showij()
subobj.showk()
subobj.sum()
End Sub
The subclass 'Class_b' can access all the members of the superclass 
'Class_a' because they are defined as 'Public'. The superclass is completely 
independent and can be used by itself. Furthermore, a subclass can serve 
as a superclass for another subclass, as shown previously.

Chapter Five
Encapsulation
Encapsulation is the process of collecting all fields, properties, and 
methods into a single unit (within a single shell) where they can only be 
accessed by the object. Hiding data from the user may protect the object 
from unwanted modifications, which helps to ease the writing and 
maintenance of the program and the debugging of its errors even a long 
time after its creation.
Encapsulation is intended to hide and combine different data and codes 
and present them to the user in the form of a black box. For example, you 
can use the “console.WriteLine” method without needing to know the 
programming code of this method. If we look at the two lines:
Dim CN as new sqlclient.sqlconnection
CN.open
We notice that: the class called sqlconnection is a derived class from a 
parent class called sqlclient. CN is an object of the sqlconnection class. If 
you type CN in the VB.NET editor (the name of the object) and then press 
the (.) sign, all the properties’ name and methods’ name of the 
sqlconnection class will appear, not the codes in which those methods and 
properties were written.
Encapsulation allows control over what is visible to the user of a class 
(properties, methods, and events) and what is not. The visible elements 
perform the intended functions of the class, while the hidden events, 
properties, and methods serve the internal operations.
Another benefit of encapsulation is protecting an object's data from being 
directly altered by another object, preventing data overlap and conflicts. 
This ensures that each object remains independent from others. If changes 
need to be made to an object, they can be handled within that specific 
object.

110
Chapter Five
Implementing encapsulation is inherent when creating a class, but it is not 
complete without the use of modifiers. Modifiers are used to control the 
access to class members. Programmers can determine which methods or 
attributes are accessible to the user of the class and which are not. 
VB.NET and C# provide various modifiers such as Public, Private, 
Friend/Internal, and Protected.
For example, let's consider a class called ‘Job’ that includes a method 
named ‘AssignJob’ (implementing job approval). It is reasonable to have 
another method, such as ‘FindQualifiedEmployee’, to evaluate employee 
qualifications for the job. However, this method should not be visible to 
the user of the class, so it is declared as ‘Private’.
On the other hand, the ‘AssignJob’ method is declared as ‘Public’. Based 
on this setup, users of the Job class will see the ‘AssignJob’ method when 
declaring an object as an instance of the class, while the 
‘FindQualifiedEmployee’ method is only accessible within the class and 
remains hidden from the user.
5.1 Public
To allow access to a member from any part of the project, declare it as 
public. A public member can be accessed and utilized by objects as well as 
any class derived from the class in which the member is defined. As 
shown in the following example, which is used to find the volume of two 
different boxes:
Module Module1
Class Box
Public length As Double ' Length of a box
Public breadth As Double ' Breadth of a box
Public height As Double ' Height of a box
Public Sub set Length (ByVal len As Double)
length = len
End Sub
Public Sub setBreadth(ByVal bre As Double) 
breadth = bre
End Sub
Public Sub setHeight(ByVal hei As Double)
height = hei
End Sub
Public Function getVolume() As Double

Encapsulation
111
Return length * breadth * height
End Function
End Class
Sub Main()
Dim Box1 As New Box
Dim Box2 As New Box
' box 1 specification
Box1.setLength(8)
Box1.setBreadth(9)
Box1.setHeight(7)
'box 2 specification
Box2.setLength(14)
Box2.setBreadth(15)
Box2.setHeight(12)
' volume of box 1
Console.WriteLine("Volume of Box1 is " & Box1.getVolume)
'volume of box 2
Console.WriteLine("Volume of Box2 is " & Box2.getVolume)
Console.ReadLine()
End Sub
End Module
Figure 5.1 shows the output.
Fig. 5.1 Output of Main procedure
5.2 Private
On the other hand, if we want to restrict access to a member only within 
the class in which it is defined, we use the private modifier. Private is used 
to secure values from direct alteration by external code. It's important to 
note that private cannot be used to define a variable within a procedure or 
method. Instead, we use the reserved word Dim, which means private, to 
define private variables inside procedures or methods within the class. The 

112
Chapter Five
following two statements are equal when declaring the num_people 
variable inside the class, in VB.NET.
Dim num_people As Integer
Private num_people As Integer
In the following VB.Net example, the StrName member is defined using 
the private access modifier to prevent direct access. It can only be 
accessed through the procedures in the class.
Class person
Public IntAge As Integer 'public member
Private StrName As String 'private member
Public Sub setname(ByVal name)
StrName = name
End Sub
Public Function getname() As String
Return StrName
End Function
Public Sub displaydata()
Console.WriteLine("age=" & IntAge)
Console.WriteLine("name=" & StrName)
End Sub
End Class
Sub Main()
Dim objperson As New person
objperson.IntAge = 35 ' public member is directly accessed using 
an object
objperson.setname("Semsem") ' member StrName is encapsulated
objperson.displaydata()
Console.ReadLine()
End Sub
C#
class person
{
public int IntAge; // Public Member
private string StrName; // Private Member
public void setname(string name)
{
StrName = name;
}

Encapsulation
113
public string getname() 
{
return StrName;
}
public void displaydata()
{
MessageBox.Show("age=" + " " + IntAge + " " + "name=" + " 
" + StrName);
}
}
static void Main(string[] args)
{
person objperson1 = new person();
objperson1.IntAge = 35; 
// Public member is directly accessed
using an object.
objperson1.setname("Semsem"); // Private member StrName is 
encapsulated
objperson1 .displaydata ();
}
Figure 5.2 shows the output.
Fig. 5.2 Output of Main procedure
Example
Public Class Class_a
Public i As Integer
Private j As Integer
Public Function showij()
Console.Write("i and j")
Console.Write(" ")
Console.Write(i)
Console.Write(" ")
Console.WriteLine(j)

114
Chapter Five
End Function
End Class
Public Class Class1_b
Inherits Class_a
Public k As Integer
Public Function showk()
Console.Write("k: ")
Console.WriteLine(k)
End Function
Public Function sum()
Console.Write(" sum of i+j+k ")
Console.WriteLine(i + j + k)
End Function
End Class
Sub Main()
Dim subobj As New Class1_b()
subobj.i = 7
subobj.j = 8
subobj.k = 9
Console.WriteLine("contents of superclass and subclass ")
subobj.showij()
subobj.showk()
subobj.sum()
End Sub
Figure
The previous code will not compile because the variable ‘j’ is defined as 
‘private’ inside class ‘a’, meaning it can only be accessed within the same 
class, and subclasses cannot access it.
The following example is a program that creates four accounts for four 
customers, as shown in the table below, and calculates their financial dues 
after three years, considering the annual profit rate.
Table 5.1 account and profit for four customers
Account
10000
15000
17500
20000
Profit
0.05
0.15
0.2
0.25

Encapsulation
115
Class company_account
Private account As Double
Private profit As Double
Private years As Integer = 3
Function after_years() As Double
Dim i As Integer
account = InputBox("Please, Enter your account")
profit = InputBox("Please, Enter Profit Rate")
For i = 1 To years
account = account + account * profit
Next
Return account
End Function
End Class
Sub Main()
Dim obj1 As New company_account
Console.WriteLine("Final_account=" & obj1.after_years())
Console.WriteLine("Final_account=" & obj1.after_years())
Console.WriteLine("Final_account=" & obj1.after_years())
Console.WriteLine("Final_account=" & obj1.after_years())
Console.ReadLine()
End Sub
C#:
class company_account
{
private double account;
private double profit;
private int years = 3;
public double after_yaers()
{
account = double.Parse(Console.ReadLine());
profit = double.Parse(Console.ReadLine());
for (int i = 1; i <= years; i++)
{
account = account + account * profit;
}
return account;
}
}

116
Chapter Five
static void Main(string[] args)
{
company_account obj1=new company_account ();
Console.WriteLine("Final_account=" + obj1.after_yaers ());
Console.WriteLine("Final_account=" + obj1.after_yaers());
Console.WriteLine("Final_account=" + obj1.after_yaers());
Console.WriteLine("Final_account=" + obj1.after_yaers());
Console.ReadLine();
}
Figure 5.3 illustrates output.
Fig. 5.3 Output of Main procedure
5.3 Protected
The member is defined as protected if we want to allow access to this 
member within the class where it is defined or in any class that inherits 
from it. Access to this member from outside the class should only be done 
through inheritance, as demonstrated in the following example:
Public Class Employee
Public empName As String
Public empID As Integer = 100
Protected currPay As Single
Protected empAge As Integer
Protected empSSN As String
Protected Shared companyName As String
Sub m()
currPay = 678
MsgBox(currPay)

Encapsulation
117
End Sub
End Class
Class manger
Inherits Employee
Sub n()
MsgBox(empAge)
End Sub
End Class
Note the use of the member empAge inside the procedure 'n' in the class 
'manager', which inherits from the class 'Employee'.
An object cannot directly access members of this type. In Figure 5.4, it is 
shown that an object named 'e' of the class 'Employee' can access the 
members 'empName' and 'empID' because they are declared as public. 
However, for the remaining variables that are defined as protected, direct 
access is not possible.
El Module Modulel
| Sub Main()
Dim el As New Employee 
el.
End $ enip ID
$ lempName 
I
l-Eiid Mod'i ---$ GetType ________________________________________________________________
♦ m
Fig. 5.4 object e handle empName and empID
Example:
Class BaseClass
Protected name As String
End Class
Class DerivedClass
Inherits BaseClass
Sub MyMethod()
Me.name = "Ahmed "
'Error BaseClass.name' is not accessible in this context because it is 
protected
Console.WriteLine(Me.name)
End Sub
End Class

118
Chapter Five
Sub Main()
Dim obj As New DerivedClass
obj.MyMethod()
Console.ReadLine()
End Sub
5.4 Friend/ internal
By using the ‘Friend’ keyword in VB.NET or the ‘internal’ keyword in 
C#, we can define a member that is accessible to all parts of the project. 
All members defined using the ‘friend’ keyword in VB.NET or the 
'internal' keyword in C# can be accessed from outside the class by creating 
an object, as demonstrated in the following example.
Class Testclass
Friend x As Integer
Friend Sub MyMethod()
Console.WriteLine("my number is" & x)
End Sub
End Class
Sub Main()
Dim obj As New Testclass
obj.x = 100
Console.WriteLine(obj.x)
obj.MyMethod()
Console.ReadLine()
End Sub
C#:
class Testclass
{
internal int x ;
internal void MyMethod()
{
Console.WriteLine("my number is" + x);
}
static void Main(string[] args)
{
Testclass obj = new Testclass();
obj.x = 100;
Console.WriteLine(obj.x);

Encapsulation
119
obj.MyMethod();
Console.ReadLine();
}
Figure 5.5 shows the output.
Fig. 5.5 Output of Main procedure
Public Class robot
Private size As String = "Size of robot is medium"
Dim travel As String = "It is travel on sandy"
Public Function s()
Console.WriteLine(size)
Console.WriteLine(" Robot take 40 minutes to drive it self for 
short distance")
Console.WriteLine(travel)
End Function
End Class
Sub Main()
Dim robot1 As New robot()
robot.s()
End Sub
Note that when defining an object of class ‘robot’, we can only access or 
interact with the function named 's' since the members named ‘travel’ and 
‘size’ are only accessible within the class itself, as shown in figure 5.6.

120
Chapter Five
Fig. 5.6 handling public function only
5.5 Access modifiers in Python
Access modifiers in Python control how data can be accessed and from 
where. In Python, variables and methods can have different access levels: 
public, private, or protected. These designations are made using a single 
underscore for protected variables or methods and using double 
underscores for private variables or methods.
Public:
To create a public variable or method, do not use any underscores.
Example
class person():
def __init__(self , name='Nada' , age=30):
self.name=name #public variable
self.age=age #public variable
def details(self):
print("My name: ", self.name)
print("My age: ", self.age)
#person object
per=person()
print(per.name)
print(per.age)
per.name='Noreen'
per.age=8
per.details()

Encapsulation
121
Output
Nada 
30
My name: Noreen
My age: 8
Private:
Private variables and methods are preceded by two underscores
Example
class person():
def __init__(self , name='Nada' , age=30):
self.name=name #public variable 
self.__age=age #private variable
def details(self):
print("My name: ", self.name)
print("My age: ", self.__age)
#person object 
per=person() 
print(per.name) # print (Nada) 
print(per.__age) 
# print (error message)
Output
Nada
Traceback (most recent call last):
File "C:\Users\hp\Desktop\test.py", line 13, in <module> 
print(per.__age) # print (error message)
AttributeError: 'person' object has no attribute '__age'
Try running the following code line: 
per.details()
Output:
My name: Nada
My age: 30
Try running the following code line: 
per.name='Noreen' 
per.__age=8 
per.details()
Output:

122
Chapter Five
My name: Noreen 
My age: 30
Protected:
Protected variables begin with a single underscore 
Example 
#superclass 
class person():
_name='Nada' #protected variable 
_age=30 #protected variable 
def access(self):
print(self._name) 
print(self._age) 
#subclass
class employee(person):
def __init__(self,job='Engineer' , salary=5000): 
self.__job=job 
#private variable
self._salary=salary #protected variable
def details(self):
print("My name: " , self._name) 
print("My age: " , self._age) 
print("My job: " , self.__job)
print("My salary: " , self._salary)#employee object 
emp=employee() 
emp.details()
Output:
My name: Nada
My age: 30
My job: Engineer
My salary: 5000
Try running the following code line: 
print(emp._name) # print (Nada)
Try running the following code line: 
emp.access() #print (Nada , 30) 
Try running the following code line: 
emp._name='Noreen' 
emp._age=8

Encapsulation
123
emp.access()
Output
Noreen 
8
Try running the following code line:
print(emp.__job) 
# print (error message)
Output:
Traceback (most recent call last):
File "C:\Users\hp\Desktop\test.py", line 30, in <module> 
print(emp.__job)#print (error message)
AttributeError: 'employee' object has no attribute '__job'
Try running the following code line:
per=person()
print(per._salary) # print (error message)
Traceback (most recent call last):
File "C:\Users\hp\Desktop\test.py", line 33, in <module> 
print(per._salary)#print (error message)
AttributeError: 'person' object has no attribute '_salary'

Chapter Six
Polymorphism
In this chapter, we will study the third principle of OOP, which is 
polymorphism. Polymorphism allows methods to be executed in different 
ways depending on the situation. For example, in the class of vehicle, the 
vehicle may be a ship, car, or plane. The plane flies, the car moves, and the 
ship sails. With Polymorphism, we can create one function with the name 
“movement” that can perform different actions based on the type of 
vehicle (e.g., sailing for a ship, flying for a plane). Polymorphism means 
the ability of the same procedure to work with different objects, which are 
treated as black boxes. Polymorphism has two forms: overriding and 
overloading.
6.1 Overriding
Overriding occurs when we have a main class with a method, and we want 
to change the implementation of this method in a derived class. We can 
add a new method with the same name in the derived class, and this will 
override the method from the base class. In VB.NET, we use the 
"Overridable" keyword (similar to "virtual" in C#) when defining the 
method in the base class, and then we use the "Overrides" keyword 
(similar to "override" in C#) in the derived class to indicate that we are 
overriding the method. Let's see an example: suppose a main class for 
employees with a function called “Decision”, then we create a derived 
class for managers. Of course, the decision-making steps for managers are 
different, so we can implement a function with the same name inside the 
derived class for managers. When creating a new employee object, the 
original function is called, but when creating a manager object, the new 
function is called. As shown in the following programming codes.
VB.Net
Public Class employee
Public Overridable Function decision ()
MsgBox(" Employee decision ")

Polymorphism
125
End Function
End Class
Class manager
Inherits employee
Public Overrides Function decision()
MsgBox(" Manager decision ")
End Function
End Class
Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As
System.EventArgs) Handles Button1.Click
Dim e1 As New employee
e1.decision()
End Sub
Private Sub Button2_Click(ByVal sender As System.Object, ByVal e
As System.EventArgs) Handles Button2.Click
Dim m1 As New manager
m1.decision()
End Sub
C#:
class Employee
{
public virtual void decision()
{
MessageBox.Show ("Employee Decision");
}
}
class Manager:Employee
{
public override void decision() // public new void decision()
{
MessageBox.Show("Manager Decision");
}
private void button1_Click(object sender, EventArgs e)
{
Employee emp1=new Employee ();
emp1.decision();
}
private void button2_Click(object sender, EventArgs e)

126
Chapter Six
{
Manager managl = new Manager();
manag1.decision();
}
Execute the project and notice the message box displayed by clicking on 
the first key for employees, and the message box shown by clicking on the 
second key for managers as shown in figure 6.1.
Fig. 6.1 Execution of code
Example with Python
class Person():
def welcome(self,name):
print("Hi,I'm a normale person: ", name)
class Employee():
def welcome(self,name):
print("Hi,I'm an employee: ", name)
class Student():
def welcome(self,name):
print("Hi,I'm a student: ", name)
#Person object
per=Person()
per.welcome("Abdelrhman") 
print('=========================================')
#Employee object
emp=Employee()
emp.welcome("Nada")
print('=========================================')
#Student object
stud=Student()
stud.welcome("Noreen")
Output
Hi,I'm a normale person: Abdelrhman

Polymorphism
127
Hi,I'm an Employee: Nada
Hi,I'm a Student: Noreen
Suppose the 'Employee' class contains a method named 'DisplayName' that 
displays the first name and then the last name of the employee. However, 
when deriving the 'Engineer' class from the 'Employee' class, we want to 
modify the behavior of the 'DisplayName' method. In the 'Engineer' class, 
calling the 'DisplayName' method should display the letters '(Eng.)', 
followed by the last name and then the first name. A solution that you will 
implement is to rewrite the DisplayName method in the derived class 
“Engineer”, as in the following example:
Class Employee
Public Firstname As String = "Ahmed"
Public Lastname As String = "Hesham"
Overridable Sub DisplayName()
Console.WriteLine(Me.Firstname & " " & Me.Lastname)
End Sub
End Class
Class Engineer
Inherits Employee
Public Overrides Sub DisplayName()
Console.WriteLine("Eng. " & Me.Lastname & " " & Me.Firstname) 
End Sub
End Class
Sub Main()
Dim Emp1 As New Employee
Dim Eng1 As New Engineer
Emp1.DisplayName()
Eng1.DisplayName()
Console.ReadLine()
End Sub
C#:
namespace ConsoleApplication1
{
class Employee
{
public string Firstname = "Ahmed";
public string Lastname = "Hesham";

128
Chapter Six
virtual public void Displayname()
{
Console.WriteLine(this.Firstname + " " + this.Lastname);
}
}
class Engineer : Employee
{
public override void Displayname()
{
Console.WriteLine("Eng." + this.Lastname + " " + this.Firstname);
}
}
class Program
{
static void Main(string[] args)
{
Employee emp1 = new Employee();
Engineer eng1 = new Engineer();
emp1.Displayname();
eng1.Displayname();
Console.ReadLine();
}
}
}
Figure 6.2 shows the output.
Fig. 6. 2 Output of main procedure
Notes
- The 'overriding' principle is available for methods and properties 
(without fields). It is used to change the implementation of a 
method or a property to another method that is suitable for the 
derived class. To achieve this, you need to use the 'Overridable' 

Polymorphism
129
keyword in VB.Net ('Virtual' in C#) before the method name in the 
base class. Then, in the derived class, whenever you want to 
override a method, use the 'Overrides' reserved word ('Override' in 
C#).
- 
The usage of the word 'Overrides' in the derived class is similar to 
using the word 'Overridable' in the base class, as it allows for re­
driving. If you attempt to derive the 'Employee' class to define a 
new class (e.g., 'Engineer'), you will also be able to override its 
methods using the keyword 'Overrides,' as shown in the following 
 example:
VB.Net
Class Employee
Public Firstname As String = "Ahmed"
Public Lastname As String = "Mohamed"
Overridable Sub DisplayName()
Console.WriteLine(Me.Firstname & " " & Me.Lastname)
End Sub
End Class
Class Engineer
Inherits Employee
Public Overrides Sub DisplayName()
Console.WriteLine("Eng. " & Me.Lastname & " " & Me.Firstname) 
End Sub
End Class
Class Architect
Inherits Engineer
Overrides Sub DisplayName() 'The method can be Overrided for the 
third time
Console.WriteLine("Architect." & Me.Lastname & " " & 
Me.Firstname)
End Sub
End Class
Sub Main()
Dim Emp1 As New Employee
Dim Eng1 As New Engineer
Dim Arch1 As New Architect
Emp1.DisplayName()
Eng1.DisplayName()
Arch1.DisplayName()
Console.ReadLine()
End Sub

130
Chapter Six
C# :
namespace ConsoleApplication1
{
class Employee
{
public string Firstname = "Ahmed";
public string Lastname = "Mohamed";
virtual public void Displayname()
{
Console.WriteLine(this.Firstname + " " + this.Lastname);
}
}
class Engineer : Employee
{
public override void Displayname()
{
Console.WriteLine("Eng." + this.Lastname + " " + this.Firstname);
}
}
class Architect : Engineer
{
public override void Displayname()
{
Console.WriteLine("Architect" + this .Lastname + " " + 
this.Firstname);
}
}
class Program
{
static void Main(string[] args)
{
Employee Emp1 = new Employee();
Engineer Eng1 = new Engineer();
Architect Erc1 = new Architect();
Emp1.Displayname();
Eng1.Displayname();
Erc1.Displayname();
Console.ReadLine();
}

Polymorphism
131
}
}
Figure 6.3 shows the output.
Fig. 6. 
3 Output of main procedure
We conclude from this that using the reserved word “overrides” in the 
derived class is similar to using the reserved word “overridable” in the 
base class. In the previous example, we were able to override the 
“Dispalyname” method of the “Engineer” class. To prevent this from 
happening you can use the Notoverridable reserved word (which 
corresponds to “sealed” in C#).
Class Employee
Public Firstname As String = "Ahmed"
Public Lastname As String = "Mohamed"
Overridable Sub DisplayName()
Console.WriteLine(Me.Firstname & " " & Me.Lastname)
End Sub
End Class
Class Engineer
Inherits Employee
NotOverridable Overrides Sub DisplayName()
‘Prevent derived classes from override this method
Console.WriteLine("Eng. " & Me.Lastname & " " & Me.Firstname) 
End Sub
End Class
Class Architect
Inherits Engineer
Overrides Sub DisplayName()
'Error message
'public Overrides Sub DisplayName()' cannot override 'public Overrides 
NotOverridable Sub DisplayName()' because it is declared 
'NotOverridable'

132
Chapter Six
Console.WriteLine("Architect." & Me.Lastname & " " & 
Me.Firstname)
End Sub
End Class
The following example uses the concept of overriding to create a function 
named “PayEmployee” in the main class to calculate the employee's 
wages given the number of worked hours and the rate of wages. Its 
programming code is changed in the derived class by adding the bonus.
Public Class BaseClass
Overridable Function PayEmployee(ByVal hoursworked As Decimal, 
ByVal payrate As Decimal) As Decimal
PayEmployee = hoursworked * payrate
End Function
End Class
Class derivedclass
Inherits baseclass
Public Overrides Function PayEmployee(ByVal hoursworked As 
Decimal, ByVal payrate As Decimal) As Decimal
Dim Bonus As Decimal
Bonus = InputBox("Enter the Bonus value")
PayEmployee = MyBase.PayEmployee(hoursworked, payrate) * 
Bonus
End Function
End Class
Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As 
System.EventArgs) Handles Button1.Click
Dim obj1 As New BaseClass
Dim obj2 As New derivedclass
Dim hoursworked As Decimal
hoursworked = InputBox("Please Enter the number of working 
hours")
Dim payrate As Decimal
payrate = InputBox("Please Enter the Rate of Pay")
MsgBox("normal pay is: " & obj1.PayEmployee(hoursworked, 
payrate) & " " & "Pay with Bonus is: " & 
obj2.PayEmployee(hoursworked, payrate))
End Sub

Polymorphism
133
C#:
public class BaseClass
{
public virtual decimal PayEmployee(decimal hoursworked, decimal 
payrate)
{
decimal Payment;
Payment = hoursworked * payrate;
return Payment;
}
}
public class Derivedclass : BaseClass
{
public override decimal PayEmployee(decimal hoursworked, decimal 
payrate)
{
decimal Bonus;
Bonus = Decimal.Parse(Interaction.InputBox("Enter the Bonus 
value"));
decimal Payment;
Payment = base.PayEmployee(hoursworked, payrate ) * Bonus; 
return Payment;
}
}
private void button1_Click(object sender, EventArgs e)
{
BaseClass obj1 = new BaseClass();
Derivedclass obj2 = new Derivedclass();
decimal houresworked;
houresworked = Decimal.Parse(Interaction.InputBox("Please Enter 
the number of working hours"));
decimal payrate;
payrate = Decimal.Parse(Interaction.InputBox("Please Enter the 
Rate of Pay"));
MessageBox.Show("Normal 
pay 
is:" 
+
obj1.PayEmployee(houresworked ,payrate )+ " " + "Pay with Bonus is:"+ 
obj2.PayEmployee (houresworked,payrate));
}
The following example uses the concept of overriding to create a function 
called “total” to calculate the total price of sold units given quantity and 
cost, and double the price for foreigners.

134
Chapter Six
Public Class Order
Public Overridable Function total(ByVal cost As Double, ByVal 
quantity As Double) As Double
Return cost * quantity
End Function
End Class
Class foreignorder
Inherits order
Public Overrides Function total(ByVal cost As Double, ByVal quantity 
As Double) As Double
Dim ConversationRate As Double = 2
Return MyBase.total(cost, quantity) * ConversationRate
End Function
End Class
Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As
System.EventArgs) Handles Button1.Click
Dim cost As Double
Dim quantity As Double
cost = InputBox("Please Enter the Cost")
quantity = InputBox("Please Enter the Quantity")
Dim obj1 As New Order
Dim obj2 As New foreignorder
MsgBox("Total Price for Egyptians is: " & obj1.total(cost, quantity)
& vbCrLf & "Total Price for Foreigners is:" & obj2.total(cost, quantity))
End Sub
C#:
class Order
{
public virtual double total(double cost, double quantity)
{
return cost * quantity;
}
}
class foreignorder: Order
{
public override double total(double cost, double quantity)
{
double ConversationRate = 2;
return base.total(cost, quantity) * ConversationRate;

Polymorphism
135
}
}
private void button1_Click(object sender, EventArgs e)
{
double cost;
double quantity;
cost=Double.Parse (Interaction.InputBox("Please Enter the 
Cost"));
quantity = Double.Parse(Interaction.InputBox("Please Enter the 
Quantity"));
Order obj1=new Order();
foreignorder obj2 = new foreignorder();
MessageBox.Show("Total Price for Egyptians is: " + 
obj1.total(cost, quantity) + " \n" + "Total Price for Foreigners is" + 
obj2.total(cost, quantity));
}
Figure 6.4 shows the output.
Fig. 6. 4 Code output
Another example of applying the concept of overriding is when we have a 
purchase invoice for a company that contains the following data: the 
number of units of each item and the unit price. The company’s owner 
deducts a portion of the invoice value based on certain conditions: a 10% 
discount if the value is greater than 2500, a 15% discount if the value is 
greater than 5000, and a 20% discount if the value is greater than 10000. 
Additionally, for foreigners, the price is doubled. We need to write a 
program that reads the given data and calculates the net price (the value of 
the invoice after discount), taking into account the doubling of the price 
for foreigners.

136
Chapter Six
Public Class Bills
Overridable Function net(ByVal unit_price As Double, ByVal 
unit_count As Double) As Double
Dim total, net_price As double
total = unit_count * unit_price
If total > 2500 Then
net_price = total - (total * 0.1)
ElseIf (total > 5000) Then
net_price = total - (total * 0.15)
ElseIf total > 10000 Then
net_price = total - (total * 0.25)
Else
net_price = total
End If
Return net_price
End Function
End Class
Class foreigner
Inherits Bills
Public Overrides Function net(ByVal unit_price As Double, ByVal 
unit_count As Double) As Double
Dim conversationRate As Integer = 2
Return MyBase.net(unit_price, unit_count) * conversationRate
End Function
End Class
Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As
System.EventArgs) Handles Button1.Click
Dim obj1 As New Bills
Dim obj2 As New foreigner
Dim unit_price As Integer
Dim unit_count As Integer
unit_price = InputBox("Please Enter Price of Unit") ' 100
unit_count = InputBox("Please Enter the Number of Units") ' 50
MsgBox("Value of bill is " & obj1.net(unit_price, unit_count) & 
vbCrLf & "Value of bill for foreigner is " & obj2.net(unit_price, 
unit_count))
End Sub
C# :
class Bills
{

Polymorphism
137
public virtual double net(double unit_price, double unit_count)
{
double total;
double net_price;
total = unit_count * unit_price;
if (total > 2500)
net_price = total - (total * 0.1);
else if (total > 5000)
net_price = total - (total * 0.15);
else if (total > 10000)
net_price = total - (total * 0.25);
else
net_price = total;
return net_price;
}
}
class Foreigner : Bills
{
public override double net(double unit_price, double unit_count)
{
int conversationRate = 2;
return base.net(unit_price, unit_count) * conversationRate;
}
}
private void button1_Click(object sender, EventArgs e)
{
Bills obj1 = new Bills();
Foringer obj2 = new Foringer();
Double unit_price;
int unit_count;
unit_price = Double.Parse (Interaction.InputBox ("Please Enter 
Price of Unit")); //100
unit_count =int.Parse (Interaction.InputBox ("Please Enter the 
Number of Units")); //50
MessageBox.Show (" Value of Bill is " + obj1.net(unit_price, 
unit_count) + " \n" + "Value of Bill for forigners is " + obj2.net (unit_price 
,unit_count));
}
Figure 6.5 shows the output.

138
Chapter Six
Fig. 6.5 Code output
6.2 Overloading
Overloading occurs when we have multiple methods with the same name 
but different parameters. This allows a function to perform different tasks 
based on the number, order, or types of parameters it receives. In 
VB.NET, the "Overloads" keyword is optional, but it is recommended to 
use it to make it clear that you are overloading the method. In C#, the 
"Overloads" keyword is not used when redefining methods.
Class simple class
Sub samename()
End sub
Sub samename(byval x as integer)
End sub
subsamename(byval y as string)
End sub
End class
Note: Typing the 'Overloads' reserved word in VB.NET is optional, but it 
becomes mandatory in other procedures if you have used it for the first 
time. It is preferable to use the 'Overloads' reserved word to make it easier 
for the language to determine the specific procedure you want to call. This 
can improve the speed of execution, as shown in the following example:

Polymorphism
139
Public Class bicycle
Overloads Sub cost(ByVal s As Integer)
Console.WriteLine("cost of spike")
Console.WriteLine(s)
End Sub
Overloads Sub cost(ByVal m As Integer, ByVal n As String)
Console.WriteLine("cost of mono")
Console.WriteLine(m & " 
" & n)
End Sub
Overloads Sub cost(ByVal t As Double)
Console.WriteLine("cost of tandem")
Console.WriteLine(t)
End Sub
End Class
Sub Main()
Dim testobject As New bicycle
Dim x As Integer = 400
Dim y As Integer = 600
Dim z As String = "mid"
Dim f As Double = 500.45
testobject.cost(x)
testobject.cost(y, z)
testobject.cost(f)
End Sub
C# :
public class bicycle
{
public void cost (int s)
{
Console.WriteLine("cost of spike");
Console.WriteLine(s);
}
public void cost(int m, string n)
{
Console.WriteLine("cost of mono");
Console.WriteLine(m + " 
" + n);
}
public void cost(double t)
{
Console.WriteLine("cost of tandem");

140
Chapter Six
Console.WriteLine(t);
}
}
class Program
{
static void Main(string[] args)
{
bicycle testobject = new bicycle();
int x = 400;
int y = 600;
string z = "mid";
double f = 500.45;
testobject.cost(x);
testobject.cost(y, z);
testobject.cost(f);
Console.ReadLine();
}
}
Figure 6.6 shows the output.
Fig. 6.6 Output of main procedure
Note: The “overloads” keyword is not used when redefining methods in 
C#.
Example:
public class overloaddemo
{
public void test()
{

Polymorphism
141
Console.WriteLine("no parameters");
}
public void test(int a )
{
Console.WriteLine("a=" + "" + a);
}
public void test(int a, int b)
{
Console.WriteLine("a and b:" + " " + a + " " + b);
}
public void test(double a)
{
Console.WriteLine("double a:" + "" + a);
double d = a * a;
Console.WriteLine("a*a= " + "" + d);
}
}
class Program
{
static void Main(string[] args)
{
overloaddemo box=new overloaddemo ();
box.test();
box.test(10);
box.test(10, 20);
box.test(123.25);
Console.ReadLine();
}
}
The method named “test” has been called four times:
First: with no parameter. Second: with one integer parameter. Third: with 
two integer parameters. Fourth: with one double parameter and returns the 
value of the square of its parameter.
Figure 6. 7 shows the output of main procedure

142
Chapter Six
Fig. 6.7 Output of main procedure
Example:
Public Class over_looood
Sub test()
Console.WriteLine("no parameters")
End Sub
Sub test(ByVal a As Integer, ByVal b As Integer)
Console.WriteLine("a and b:" & " " & a & " " & b)
End Sub
Sub test(ByVal a As Double)
Console.WriteLine("double a:" & "" & a)
End Sub
End Class
Sub Main()
Dim box As New over_looood
Dim i As Integer = 10
box.test()
box.test(10, 20)
box.test(i)
box.test(123.25)
End Sub
Figure 6. 8 shows output of main procedure

Polymorphism
143
Fig. 6.8 Output of main procedure
In the previous example, the method named 'test' with an integer parameter 
was not defined. So when 'test(i)' is called, 'i' is implicitly converted to a 
double and then 'test(double)' is executed. However, if you define 
'test(int)', it will be called instead. This means that if you pass a value that 
doesn't match the parameters of any defined method, a widening 
conversion will be applied to that value, and then the closest method will 
be executed after the conversion. When the compiler fails to find a method 
with parameters that correspond to the provided arguments (even with 
implicit conversion), an error message will appear, as shown in the 
following example.
Example
Class TestClass
Overloads Sub SameName(ByVal X As Integer) 
Console.WriteLine("integer value")
End Sub
Overloads Sub SameName(ByVal X As String) 
Console.WriteLine("string value")
End Sub
End Class
Sub Main()
Dim TestObject As New TestClass()
Dim A As String = "100"
Dim B As Char = "B"
Dim C As Long = 10
TestObject.SameName(CInt(A))
' The first version of the method will be called, not the second 
TestObject.SameName(B) ' string value 
TestObject.SameName(C) ' Error message 
Console.ReadLine()
End Sub

144
Chapter Six
Example:
Public Class calculate
Overloads Sub calculatetax(ByVal x As Integer)
Console.WriteLine("integer function returned" & "
End Sub
Overloads Sub calculatetax(ByVal y As String)
" & x * 10)
Console.WriteLine("integer function returned" & " " & "y * 10" & " " & 
"error")
End Sub
Overloads Sub calculatetax(ByVal z As Double)
Console.WriteLine("integer function returned" & " " & z * 10)
End Sub
End Class
Sub Main()
Dim calc As New calculate
calc.calculatetax(10)
calc.calculatetax("error")
calc.calculatetax(10.5)
End Sub
Figure 6. 9 shows output of main procedure
"C:\Documents and Settings\sc\My DocumentsWisual Studio ProjectsXCons
integer 
function rturned 
100
integer 
function rturned 
y * 10 error
integer 
function rturned 
105
Press any key to continue
Fig. 6.9 Output of main procedure
Class shape
Public Overloads Sub drawline()
Dim i As Integer
Do While i < =10
Console.Write("*")
i = i + 1
Loop
Console.WriteLine("")
End Sub
Public Overloads Sub drawline(ByVal n As Integer)

Polymorphism
145
Dim j As Integer
Do While j <= n
Console.Write("*")
j = j + 1
Loop
Console.WriteLine("")
End Sub
Public Overloads Sub drawline(ByVal n As Integer, ByVal ch As Char)
Dim k As Integer
Do While k <= n
Console.Write(ch)
k = k + 1
Loop
Console.WriteLine()
End Sub
End Class
Sub Main()
Dim obj1 As New shape
obj1.drawline()
obj1.drawline(15)
obj1.drawline(12, "-")
Console.ReadLine()
End Sub
C#:
class shape
{
public void drawline()
{
int i=0;
while (i <= 10)
{
Console.Write("*"); 
i++;
}
Console.WriteLine("");
}
public void drawline(int n) 
{
int j=0;
while (j <= n)

146
Chapter Six
{
Console.Write("*");
j++;
}
Console.WriteLine();
}
public void drawline(int n, char ch)
{
int k=0;
while (k <= n)
{
Console.Write(ch);
k++;
}
Console.WriteLine();
}
}
class Program
{
static void Main(string[] args)
{
shape obj1 = new shape();
obj1.drawline();
obj1.drawline(15);
obj1.drawline(12,'-');
Console.ReadLine();
}
}
Figure 6.10 shows output of main procedure
Fig. 6.10 Output of main procedure

Polymorphism
147
The following example utilizes the concept of overloading to create a 
function for calculating the commission on the sales of a company. The 
function is designed to adapt its calculation based on either the total sales 
alone or the total sales combined with the number of years of service of 
the salesman within the company. In this case, the commission increases 
by 1% for each year of service.
Module Module1
Class class_commission
Dim comm As Double
Overloads Function commission (ByVal sales As Double) As Double 
Select Case sales
Case 0 To 99
comm = sales * 0.08
GoTo 10
Case 100 To 199
comm = sales * 0.15
GoTo 10
Case Is > 200
comm = sales * 0.25
GoTo 10
End Select
10: 
Return comm
End Function
Overloads Function commission (ByVal sales As Double, ByVal 
years As Integer) As Double
Select Case sales
Case 0 To 99
comm = sales * 0.08
Case 100 To 199
comm = sales * 0.15
Case Is > 200
comm = sales * 0.25
End Select
comm = comm + (comm * years / 100)
Return comm
End Function
End Class
Sub Main()
Dim obj1 As New class_ commission
Dim commvalue As Double

148
Chapter Six
Console.WriteLine("Enter the sales value")
commvalue = Console.ReadLine()
Console.WriteLine("the value of commission on sales is " & obj1. 
commission (commvalue))
Console.WriteLine("the value of commission on sales after the 
addition of years of service is " & obj1. commission (commvalue, 5))
Console.ReadLine()
End Sub
End Module
Notes
- 
You can’t overload method by changing the name of sent 
parameters, redefining the following procedure “SamenName()” 
will give an error message:
Sub SameName(ByVal X As String)
End Sub
Sub SameName(ByVal Y As String)
End Sub
- 
You cannot overload procedures by changing the method of 
sending the parameter (either ByRef or ByVal) it will also cause an 
error message:
Sub SameName(ByVal X As String)
End Sub
Sub SameName(ByRef Y As String)
End Sub
- 
You also cannot overload methods by changing the access 
modifier; it will also cause an error message:
Public Sub SameName(ByVal X As String)
End Sub
Friend Sub SameName(ByVal X As String)
End Sub

Polymorphism
149
- 
You cannot overload procedures by changing only the return 
value’s type; it will also cause an error message:
Overloads function myfunction ()as Boolean
End function
Overloads function myfunction () as string
- 
Another case that does not enable you to apply the principle of 
overload, which is when the optional parameter’s type differs. For 
example, overload the following methods will display an error 
message:
Sub SameName(Optional ByVal X As Integer = 0)
End Sub
Sub SameName(Optional ByVal X As String = " ")
End Sub
There must be a difference in non-optional parameters.
- 
Note that overloading does not consider the return type of the 
method; only the parameters are used to differentiate between 
overloaded methods.
- 
Unlike 
 and C#, Python does not support method 
overloading based on the number or types of parameters. In Python, 
only the last definition of a method with a specific name will be 
used, and previous definitions will be overridden.
VB.NET

Bibliography
Anil Sharma. 2008. Object Oriented Analysis and Design. New Delhi: 
Lovely Professional University. Last accessed April 3, 2023.
http://ebooks.lpude.in/computer_application/bca/term_6/DCAP308_O 
BJECT_ORIENTED_ANALYSIS_AND_DESIGN.pdf
Bruce Johnson. 2018. PROFESSIONAL Visual Studio 2017: John Wiley 
& Sons, Inc. Last accessed April 2, 2023.
http://projanco.com/Library/Professional%20Visual%20Studio%20201
7.pdf
Dan Clark. 2013. Beginning C# Object-Oriented Programming: Apress. 
Last accessed April 3, 2023.
https://bedford-computing.co.uk/learning/wp-content/uploads/2015/
10/Beginning-C-Object-Oriented-Programming-2nd-Edition.pdf
Diane Zak. 2017. Microsoft Visual Basic 2015: 6th Edition: Amazon's.
Dusty Phillips. 2015. Python 3 Object-oriented Programming: Packt 
Publishing.
Fabrizio Romano, Benjamin Baka, Dusty Phillips. 2019. Getting Started 
with Python: Packt Publishing.
James Foxall. 2016. Visual Basic 2015 in 24 Hours: Amazon's.
Liew Voon Kiong. 2017. Visual Basic 2017 Made Easy: Independently 
published. Last accessed April 3, 2023.
https://www.vbtutor.net/vb2017/vb2017me_preview.pdf
Meilir Page-Jones. 2000. Fundamentals Of Object-Oriented Design In 
UML. New York: Dorset House Publishing.
Michael H. Goldwasser, David Letscher. 2008. Object-oriented programming 
in Python: Pearson Prentice Hall.
Mike Snell, Lars Powers. 2016. Microsoft Visual Studio 2015: SAMS 
BPB Publications.
Perdita Stevens with Rob Pooley. 2006. Using UML software engineering 
with object and components. Second Edition: Addisen Wesley.
Philip Conrod and Lou Tylee. 2019. Learn Visual Basic. 2019 Kindle 
Edition: Kidware Software.
Simon Kendal. 2019. Object Oriented Programming using C#: BookBoon.
Last accessed April 3, 2023.
https://dl.icdst.org/pdfs/files3/5f1e17b2493aff3f8114ca0f219b1b5a.pdf
Steven F. Lott. 2019. Mastering Object-Oriented Python: Packt Publishing, 
Limited.

Object-Oriented Programming
151
Steven F. Lott, Dusty Phillips. 2021. Python Object-Oriented Programming: 
Packt Publishing.
Svetlin Navok et al.2013. Fundamentals of Computer Programming with 
C#. Bulgaria: Faber Publishing. Last accessed April 1, 2023.
https://introprogramming.info/english-intro-csharp-book/
VB.Net Programming Language Reference, © Copyright 2015 by 
Tutorials Point (I) Pvt. Ltd.

