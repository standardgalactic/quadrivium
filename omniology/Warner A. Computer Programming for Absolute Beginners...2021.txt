
COMPUTER
PROGRAMMING
FOR
ABSOLUTE
BEGINNERS
Learn the Art of Computer
Programming and Start Your Journey
as A Self-Taught Programmer
ANDREW WARNER

Copyright © 2021 by Andrew Warner.
All rights reserved.
No part of this book may be reproduced in any form on by
any electronic or mechanical means, including information
storage and retrieval systems, without permission in writing
from the publisher, except by a reviewer who may quote
brief passages in a review.
ISBN-13 : 9798777184542
Book and cover design : Raphael A.
Printed in the United States of America
First Edition : December 2021
For information on translations, please e-mail :
andrew@aqpub.com, or visit http://www.aqpub.com

DEDICATION
M Y   P A R E N T S
For raising me to believe that anything
is possible
A N D    M Y   W I F E
For making everything possible

CONTENTS
BOOK-I: CODING FOR
ABSOLUTE BEGINNERS
PREFACE
CHAPTER ONE: WHAT IS PROGRAMMING?
Problem 
Solving 
with 
Computer
Programming
Basics of Programming
Introduction to Computer Programming
Elements and Basics of Computer Programming
Environment, Data Types, and Basic Syntax
Programming Variables, Keywords, Operators, and
Decisions
Programming Characters, Arrays, and Strings
Functions and File I/O
The Programming Environment
What is the programming environment?
CHAPTER TWO: JAVA
Overview and Basic Syntax
Java Identifiers and Modifiers
Object, Classes, and Constructors
Classes and Objects

Basic Data Types and Variables
Data Types
Operators, Control Statements and Decision
Making
Operators
Control Statements
Loops
Decision Making
Characters, Strings, Arrays, and Regular
Expressions
Arrays
Regular Expressions
Files and I/O
Object Oriented Java
Inheritance
Polymorphism
Abstraction
Encapsulation
Recursion
Abstract Class and Abstract Methods
Abstract Class
Abstract Method
CHAPTER THREE: SQL AND DATABASE
What is a Database?
Database Management System (DBMS) concepts
Database Environment and Architecture
Types of Databases
Database Syntax, Data Type and Operators

Structured Query Language (SQL)
Advanced SQL
Indexes
SQL Primary and Foreign Key
Constraints and Useful resources
CHAPTER FOUR: C
Introduction and Simple Programs
Starting with C Programming
Header Files
Methods and Variable declaration
Keywords
Data Types and Variables
Variables
Scope of Variables
Loops and Functions
Loops
Functions
Methods to Pass an Argument to a Function
Arrays, Strings, and Linked Lists
Arrays
Strings
Pointers and Structures
Structures
Accessing the Structure Members
Passing Pointers to Structures

C Programming files
Essential Tips to Make C Programming
Easy
CHAPTER FIVE: C++
Basic Syntax
Variables and Data Types
Variables
Data Types
Modifier Types and Storage Classes
Flow Control
If Statement
Switch Case
Go To Statement
Loops and Functions
Loops
Functions
Arrays, Strings, Pointers, and References
Arrays
Strings
Pointers
Object Oriented C++
Classes and Objects
Inheritance and Polymorphism
Access Specifiers
Friend Function, Data Structures, and
Encapsulation

Friend Function
Data Structures
Encapsulation
File Handling
C++ Language Features and Support
CHAPTER SIX: C#
Overview and Basic syntax
Overview
Basic Syntax
Datatypes and Variables
Operators
Functions and Methods
Arrays, Strings, and Structures
Arrays
Strings
Classes and Objects
Creating an Object
Inheritance and Polymorphism
Inheritance
Polymorphism
Function Overloading
Constructors
Exception Handling
Multithreading

File I/O
Advantages of learning C#
CHAPTER SEVEN: PYTHON
Overview and Basic syntax
Features
Variable Types, Basic Operators, and Data
Types
Variable types
Basic Operators
Data Types
Flow Control
Conditional Statements
Functions and Modules
What are Functions?
Object Oriented Python
Regular Expressions
File I/O
Advanced Python
Exception Handling
Tips for Learning Python
CHAPTER EIGHT: HTML
Introduction and Overview
What are Tags?
Description of Tags

Basic Tags and Attributes
Basic Tags
Paragraph
Formatting Tags
Container Tags
Tables, Images, and Frames
Tables
Images
Alignment and Border
Frames
Forms
Designing
Fonts
Meta Tags
Comments
HTML Style Sheets
Layout and Responsiveness
HTML Templates
Helpful Tips for Using HTML
CHAPTER NINE: CSS
What is CSS?
Types of CSS
Inline CSS
Internal CSS
External CSS
Basic Syntax and Inclusion in HTML

Importing CSS file
Colors and Backgrounds
Colors
Background
Formatting and Design
Borders
Margins and Padding
Margin
Padding
Font and Text
Font
Text
Links, Tables and Margins
Links
Tables
Margins
Lists, Icons, and Dropdowns
Lists
Icons
Dropdowns
Layers and Visibility
Layers
Visibility
Layout and Animations
Layout
Animation

How to Effectively Use CSS
CHAPTER TEN: PROGRAMMING ESSENTIALS
Selecting the Programming Language
Tips for Efficient Programming
Strengthen Your Basic Skills
CONCLUSION
BOOK-II: PYTHON FOR
ABSOLUTE BEGINNERS
INTRODUCTION
CHAPTER ONE: PROGRAMMING BASICS
Integral Programming Concepts
Low-Level Languages
High-Level Languages
Interpreters and Compilers
Important Definitions
Brief History of Programming Languages
FORmula TRANslation (FORTRAN)
Pascal
C
Perl
Ruby
Java
Personal Home Page (PHP)
JavaScript
Python

Object-Oriented Programming (OOP)
What Is an Object and How Does OOP Work?
Exercises
CHAPTER TWO: STARTING WITH PYTHON
Python 2.x vs. 3.x
Choosing a Python Environment
Installing and Setting Up Python
Step 1
Step 2
Writing and Running Your First Program
What Is a Module?
Installing Optional External Modules
What Is a Package? What Is Import?
Pip — Your Best Friend
Exercises
CHAPTER THREE: PYTHON BASICS
Building Blocks
Variables
Constants
Statements
Expressions
Operators
Conditionals
Basic Data Types
Numbers
Strings

Taking Input
The input() Function
The raw_input() Function
Loops a.k.a. Iterations
The for loop
The while loop
Lists
Strings
String Slicing Operations
Splitting and Replacing Characters in a String
More Data Structures
Dictionaries
Tuples
Bonus: Sets
Functions
The Concept of Recursion
Classes
Working with Libraries
Debugging
Types of Errors in Python
Syntax Errors
Index Error
Type Error
Name Error
Import Error
Logical Error

Exceptional Handling
Best Debugging Practices
Exercises
CHAPTER FOUR: INTEGRATION WITH PYTHON
Integration With OS: Windows
Get File Path
Working With a Text File
Integration with MS Office
Working with Excel Files
Integration with Java
Integration with MySQL and MS Access
Working with MySQL
Working With MS Access
Exercises
CHAPTER FIVE: WORKING WITH FILES
Excel Spreadsheets
Opening and Closing Spreadsheets
Parsing Data
Alternate Approach
Modifying Spreadsheet Data
Working with PDF and Word Documents
Word Documents
PDF Documents
Working With CSV and JSON Data
Interacting with CSV Files

Interacting With JSON Data
Exercises
CHAPTER SIX: ADVANCED CONCEPTS
Scheduling Tasks
Web Scraping
Manipulating Images
Automating Emails and Text Messages
Email Messages
Text Messages
GUI Automation
Mouse Automation
Keyboard Automation
Exercise
CONCLUSION
Appendices
Appendix A: Answers to Exercises
Appendix B: Differences in Python 3.x
BOOK-III: LINUX FOR
ABSOLUTE BEGINNERS
INTRODUCTION
What to Expect in This Book
Some Essential Terminologies
CHAPTER ONE: WHAT LED TO LINUX?

A Brief History
The Open-Source Concept and Distributions
Who Uses Linux?
CHAPTER TWO: DIVING INTO LINUX
Which Distribution to Select?
Ubuntu
Linux Mint
Red Hat Enterprise Linux (RHEL)
Kali Linux
Fedora
Elementary OS/Zorin/Solus
OpenSuSE
Arch Linux
Downloading and Installing Linux
Familiarizing Yourself with the Interface
Dual Booting Windows 11 and Ubuntu
Linux
Prepare the Windows Operating System For Dual-Boot
Boot from USB Drive.
CHAPTER THREE: NAVIGATING YOUR WAY
THROUGH
Getting Acquainted with the Terminal
File System and Directories: The “What”
and the “How”
Root Directory
The Bin Directory
Dev Directory
The Etcetera Directory

The Libraries
The Lost+Found?
Media and /mnt Directories
The Optional Directory
The Process Directory
The Run Directory
Sbin Directory
Snap Directory
Service Directory
The System Folder
The Temp Folder
The Usr Folder
The Variable Directory
Basic Commands to Remember
Print Working Directory (pwd)
Change Directory (cd)
The “ls” Command
Commands You Might Find Useful
CHAPTER FOUR: TAKING COMMAND OF YOUR
SYSTEM
User and Super User
Changing Ownership
Changing Permissions
Creating Users
Removing Users
Creating Groups
Changing Permissions for Group
Configuring Your System
CHAPTER FIVE: KNOWING YOUR NETWORK
CONFIGS

Network: The Basics
Using Network to Transfer Files
CHAPTER SIX: SHELL, SCRIPTS, AND TOOLS
Basics of Shell Scripts
Knowing When to Use Shell Scripts
CHAPTER 
SEVEN: 
ENHANCING 
YOUR
EXPERIENCE
Getting a Grip on New Commands
What’s Next?
CONCLUSION

BOOK- I
CODING
FOR
ABSOLUTE
BEGINNERS
Master the Basics of Computer
Programming with Python, Java, SQL,
C, C++, C#, HTML, and CSS
ANDREW WARNER

PREFACE
Coding for Absolute Beginners is a complete
and authentic guide for students who are
determined to learn the best programming
approaches, techniques, and methodologies.
As the software industry is updated with the
latest coding languages and tools every day, it
is mandatory to adopt new skills and
technologies to survive in the competitive
market. Reading has always been a vital
resource for students and learners as they can
improve their performance and output by
implementing the latest techniques and
programming methodologies.
This book is a successful programming
manual 
covering 
all 
of 
the 
major
programming languages, syntax, and best
practices that are suitable for both beginners

and professionals. Before entering into the
programming 
world, 
there 
are 
several
important factors that need to be looked at in
order to develop sharp problem solving and
analytical skills. Therefore, this book targets
novice programmers and has been updated
with solutions and answers to almost every
question you might have about Java, SQL, C,
C++, C#, Python, HTML, and CSS.
I always emphasize the acquisition of basic
knowledge and skills. This book will not
make you a programmer in just one hour or
overnight, but it will build a solid foundation
for your programming career. After reading
this 
book, 
your 
basic 
knowledge 
of
programming will increase, as will your
proficiency in any programming language.
Many people have helped me in many ways
in writing this book with their important
feedback and encouragement and correcting
various mistakes. I am eternally grateful to all
of them. Especially, Mr. Steve, my then CS
thesis supervisor at Harvard University. He
knew more than a year ago that I was writing

a programming book. After sending him the
draft of my book in December (2020), his
reply was- "I just have gone through your
book. I have been thinking about writing a
book like this for the last five or six years-
you have done it- I do not need to do it
anymore. thank you."
On a personal level, I have to thank my wife
Rachel and son Aaron for their never-ending
patience and support.
I hope that Coding for Absolute Beginners be
your best friend in your programming journey
and help you become proficient in computer
programming. 
May the source be with you. </>

CHAPTER ONE
WHAT IS PROGRAMMING?
Generally, programming is referred to as a set
of instructions that the computer utilizes to
complete certain tasks. This is also known as
coding. Before delving into an in-depth
discussion, you must be well aware of how
programming works and how the set of
instructions are processed by the computer.
When you are able to follow the correct
approach of writing computer programs, it
can become quite easy to implement
functions, operators, and syntax for any
language. Moreover, programming is a way
to communicate with computers through

binary language for which programmers need
to understand high level and low-level
languages including syntax as well.
In order to solve a problem with a computer,
users are required to present the solution for
the problem through a set of instructions
which can be utilized to execute the program.
As a program is a collection of instructions
that are required to solve a problem,
appropriate statements and functionality must
be added in order to achieve the desired
outcome. For example, if you are given the
task to develop a program to add two integers
(numbers), the set of statements that will
perform the addition operation will be known
as the program. The algorithm for adding two
integers will be expressed through the
statements of a particular computer language
like C++, C, C# or Java. If the program is not
able to execute properly, there might be a
problem with your algorithm or syntax
because the compiler or editor will be unable
to execute the program if there are any type
of errors or syntax mistakes.

Programming can be better learned through
practice and writing code rather than learning
long methodologies or complex techniques.
Although it might seem like a fun activity at
the start, it can also turn out to be time-
consuming and frustrating if you are not
following the correct approach. Furthermore,
this book will make it easier for beginners to
choose the most suitable programming
languages and enter the world of computer
programming without much hassle.
Problem 
Solving 
with
Computer Programming
In essence, a computer program is supposed
to solve a specific problem by following a set
of instructions. People can write a program
by 
following 
multiple 
techniques 
and
approaches. In order to solve a problem, you
need to determine the code flow and fulfill
the requirements step by step to achieve the
desired output. In some cases, your computer
program may not work even after hours of

struggle because of inappropriate syntax or
flow for which you need to focus on the
sequence of instructions and computer
programming language requirements.
Using this example of preparing a wooden
table, you would need to write down the
instructions as follows:
1. Get the most suitable pieces of
wood required to make the table.
2. Get 
the 
essential 
tools 
and
equipment that will be used during
the procedure.
3. Join the pieces and build your table.
4. Polish the end product to make it
look attractive.
When giving such instructions to the
computer, you need to be more specific and
precise because a computer cannot perform
operations on its own. As it is created to
follow instructions, your computer program
should 
always 
follow 
an 
incremental
approach in order to achieve the desired
outcome.

On the topic of the natural language of a
computer, they are unable to understand
human language and therefore, we need to
communicate with the system through
another language called binary code. Binary
code is made up of a series of 1s and 0s and is
the natural communicating language of
computers.  In order to help the computer,
understand 
human 
language, 
we 
use
translators and editors for writing programs.
Translators have the capability to convert the
source code into the machine’s language.
There are multiple types of translators known
as Interpreters, Compilers, and Assemblers.
Interpreters are generally used to interpret
languages which are then processed line by
line to run the final program. Moreover, any
syntax errors or mistakes are also outlined by
the interpreter so the programmer can clear
out the mistakes and execute the program.
With the help of compilers, the source code is
converted 
to 
binary 
code 
through 
a
compilation process and is then executed to
deliver the output. If there are no errors or

mistakes in the source code, all of the lines
are translated and executed at once by the
compiler. Moreover, computer programs are
also 
known 
as 
Apps 
(application 
or
application software) and are tailored to the
environment or platform they are designed to
run on. Apps are differentiated in the
categories of desktop applications and mobile
applications as well.
Basics of Programming
Introduction 
to 
Computer
Programming
Every computer program is a combination of
procedures, processes, and algorithms that
complete the source code. As this process
combination can also be considered a
representation of a software, the process is
referred to as a series of actions to achieve an
output whereas the procedure can be
considered as a series of actions performed in
a specific order. Algorithms are the main
driving force of any program, also known as

an ordered set of steps to solve a certain
program or problem.
There are different high level and low-level
languages that can be used to write a
computer program. Nowadays, programs and
software are generally made by using popular
languages which include C, C++, Java,
Python, HTML, PHP, Ruby, and Perl. These
languages are used to produce computer
programs that are currently being used in
various fields and industries including the
medical, 
engineering, 
communication,
household, and entertainment industries.
Furthermore, computer programs are also
being 
used 
to 
create 
graphics, 
web
applications, and desktop applications as
well.
Elements and Basics of Computer
Programming
Usually, 
computer 
languages 
are 
a
combination of several elements that allow
programmers to achieve an expected output.
These elements include the basic syntax,

programming 
environment, 
data 
types,
keywords, variables, decision making, basic
operators, and functions. Moreover, in order
to perform certain operations within a
program, you need to apply other operations
and use elements including loops, strings,
characters, File I/O, and arrays as well.
There are five different basic elements of
programming that are also considered as the
building blocks of any program. The
elements are known as Input, Output,
Arithmetic, 
Conditional, 
and 
Looping.
Starting with the first element, Input is the
process of getting commands and data into
the computer, whereas the Output element
has the functionality to deliver the results. If
there are any sort of calculations or
operations, the Arithmetic element is used
along with the Conditional statement to test
whether the condition is true or false.
Environment, Data Types, and Basic
Syntax
Environment

In order to run or execute a program, you
must install or setup the required tool and
environment for the language you are using.
Moreover, beginners can also use a text editor
to create computer programs if they find it
difficult 
to 
install 
and 
configure 
the
programming environments on their own. To
execute the programs into binary format, it is
mandatory that you use a compiler because
the computer cannot understand a program
directly if given in the text format.
Moreover, the conversion of text into binary
format is done by the Compiler through
which programmers can run and execute the
program as well. Programming languages
including C, C++, C#, and Java need the
compilation in binary format whereas other
languages such as PHP, Perl, and Python can
be compiled directly as well.
Basic Syntax
To make it easier for beginners, we will be
starting from the grassroots level and write a
“Hello World” program in C++. This sample

program as written below will make it easier
for you to understand and begin writing your
first program.
1
2
3
4
5
6
7
8
#include <iostream>
using namespace std;
int main()
{
cout << "Hello World!";
return 0;
}
The output for this respective Hello World
program is as follows:
Hello World!
Each program that is being written in C++
starts with #include <iostream> and main ()
which is also known as the main function.
The 
program 
is 
then 
continued 
with
functions, characters, loops, strings, or arrays
depending on the requirements. In the
program written above, main () is used as a
function whereas cout is the standard output
stream that is implemented to print “Hello
World!”. At last, return 0; is written as the

exit status of the program which is also
necessary for program execution.
If you are unable to execute the program,
there might be some possible syntax errors or
typing mistakes that are not being processed
by the compiler. As it stops the program from
compiling, small typing errors such as the
omission of a single comma, semi-colon, or
dot are most likely to be the cause. So, if you
are not properly following the syntax as
defined for the programming language, your
program might not compile or execute in this
case.
Data Types
Data types are an important part of various
programming languages and are used when
creating 
computer 
applications. 
As 
it
classifies every object or variable that is
being written in the program, data types tell
the compiler how to use the provided data in
order 
to 
perform 
certain 
operations.
Generally, commonly used data types include
integer, 
real, 
Boolean, 
characters,

alphanumeric 
strings, 
and 
floating-point
numbers.
Briefed details of data types are given as
follows:
Date: 01/04/2015
Integer: 1,52,13424
Boolean: True/False
String: ab, aabb
Void: No data
Long: 5325433253
Floating point number: 5.2341
Short: 0
Syntax
As stated previously, a program is defined as
a collection of elements and attributes that
perform certain operations to deliver a
specific output. With the C++ programming
language, there is a predefined basic syntax
that needs to be followed when writing
programs. Let us briefly look at an overview
of how the basic syntax of the programming
language works.

1. Class: Class is a defined data type and has
its own member functions and data members.
For example: consider the class of a school,
the data members will be teachers, students,
admin staff, etc.
2.  Object: An Object is an instance of a class
that has their own behavior and states. For
example, a car has different colors, models,
specifications, etc.
3.  Methods: Method is referred to as the
behavior and is responsible for the execution
and manipulation of different actions within
the class.
Programming Variables, Keywords,
Operators, and Decisions
Variables are an essential part of a computer
program as they provide computer memory
locations required to store values and data in
a computer program. In order to save a value,
you will have to create variables and assign
them a proper name, store values into the
variables, and retrieve the given values back

from the variables.
To get started with declaring variables, we
will have to write the program as follows:
#include <iostream.h>
int main() {
  int a;
}
The above written program creates a variable
named “a” and is specified by an int
keyword. This means the variable can only
store an int type value and you are not
allowed to define “a” again to store another
type of value in the variable.
To store a value into the variable, just declare
the number that you want to place in “a” after
the declaration of a variable in the program.
Keywords
There are different keywords for every
programming language that are used for
various purposes. Although each language
provides 
a 
complete 
set 
of 
reserved
keywords, there is a common rule that needs

to be followed while using the keywords.
Same as float, int, long, and string, other
keywords that are mostly used in every
programming language are as follows:
Else
Switch
Goto
Static
Case
Break
Enum
For
If
Union
Double
Private
Operators
Operators are the key aspect of any
programming language and are required to
perform 
certain 
operations 
or 
logical
computations. As they are generally used for
mathematical calculations, we can solve

complex 
equations 
by 
using 
various
expressions in the program.
There are two kinds of operators that are
generally used in programming languages:
1. Arithmetic Operators: Operators that are
used to conduct mathematical and arithmetic
operations. For example: +,-,/,--,++,*.
Binary Operators: Operators that
work with other operands such as
+,-,/,*.
Unary Operators: Operators that are
used to work with a single operand.
For example: ++,--.
2.  Relational Operators: These are the most
commonly used operators that tell us whether
one operand is equal to another or not. For
example: ==, <==, <==, >==.
Here is a table detailing basic operators and
their functionality within the program:
Operator
Functionality

+
Addition of two operands
-
Subtraction of two operands
/
Division
*
Multiplication
==
Check 
whether 
the 
two
operands are equal or not
>=
Check if the left operand is
greater than or equal in value as
compared to the right operand
<==
Check if the left operand is less
than or equal in value to the
right operand
Logical Operators are also an essential part of
all programming languages. They are used to
obtain certain decisions in various scenarios.
These operators are AND, OR, and NOT.
They are used to prove true or false
statements as well.
Decisions
Decision making is a process in which the

programmer has to select one option based on
the two or more given conditions. You will
have to test whether the condition is true or
false and present the correct output.
For different programming languages, the
decision-making statements are briefed as
follows:
‘If’ statement
‘Else’ statement
Switch
‘Else if’ statement
Conditional Operator
Programming Characters, Arrays,
and Strings
In programming languages, Char type is used
to store characters and letters. They are also
responsible for storing values and delivering
output whenever the character is called within
the program. You are only allowed to store a
single-digit number or alphabet inside the
single quotes such as &, @, * or +.

The example code for defining characters is
as follows:
Char ch1 = ‘a’.
Arrays
An Array is a data structure that has the
capability to store a sequential number of
elements of the same type and is generally of
a fixed size. As it is comprised of contiguous
memory locations, it is also known as the set
of elements stored under the same name. If
you are writing a program to store 10 integers
in sequence, creating an array of 10 will be
the best possible solution.
This is how an array of a fixed number of
values is declared:
int data[10];
The two popular types of array are known as:
1. One-dimensional arrays.
2. Multi-dimensional arrays.
Accessing arrays

After you are done with the declaration, you
can easily access the elements through
indices. Arrays have 0 in the first index and
the if the size of an array is n, you will have
to use the condition n-1 to access the last
element.
To initialize the array, you can follow the
pattern as follows:
int arr[5] = {1, 2, 3, 4, 5};
Arrays allow the programmers to store data
into individual variables without defining
every variable specifically. Similar to other
data types, arrays are declared by using [ and
] brackets, and once the array has been
declared, you can assign the values. There are
different ways to create, assign, and declare
arrays in a program.
Declaration
In order to declare arrays, you must
remember that array size must be an integer
greater than 0. An array can be declared as
follows:

Type arrayName [ arraySize ];
Initialization
To initialize an array, you can use the
statement mentioned below:
Int Arr[5] = { 23,45,53,64,73}
Strings
String is a data type that is used in
programming languages to represent an array
of characters. To declare and initialize a
string, you need to follow the same structure
as the arrays. There are different techniques
and ways to write strings for every
programming language but the functionality
is the same in each case. A string can also
contain spaces in a phrase such as “ I have
been waiting since 5 pm.”
The example of a string is as follows:
char c[] = "abcdef";
Functions and File I/O
Functions

A function is known as a block of code which
performs a specific task within the program.
There are two types of functions in
programming 
called 
Standard 
Library
Functions and User Defined Functions.
The standard library functions are assigned
the duty of handling major tasks such as I/O
processing, computations, and data handling
whereas the user defined functions are
created by the programmers themselves to
perform specific tasks. Functions are more
like a reusable code that can perform certain
actions and provide better modularity for the
program as well.
To define a function in C programming, you
need to declare a Return Type, Function
Name, Parameter List, and Function Body.
For example:
#include <iostream.h>
void functionName()
int main()
{
   functionName();

}
File I/O
To store and manage computer files such as
images, word documents, plain text, or excel
sheets, we take support from the File
Input/Output operation modes. With File
Input, the approach is used to write any data
into the file whereas the File Output method
is used to display results from a file.
Generally, a file can be opened in different
modes such as Read-Only mode, Write-Only
mode or Read and Write mode.
There are specific functions for every
programming language to open, read, or
create a new file. To open the file, the
recommended function is fopen() and for
closing the file, you can use the fclose()
function.
The 
Programming
Environment
What 
is 
the 
programming

environment?
The 
development 
environment 
is 
a
combination of programming tools and a set
of processes that are used collectively to run
the program. depending on the language in
which you are writing the program, you can
select the best suitable environment and
complete your projects by following the
provided instructions. Because programming
is how we achieve different solutions and
outputs, we can express our ideas in multiple
ways through programming tools and the
environment.
Furthermore, 
compilers 
execute 
the
algorithms in a step-by-step approach and
perform other activities such as selection for
decision-making, sequential processing, and
iteration.
Integrated Development Environment
An Integrated Development Environment is
referred to as a software where the tools and
processes are connected to bring a convenient
interface into the programming environment.

Known as an application, the Integrated
Development 
Environment 
(IDE) 
also
facilitates 
application 
development 
and
provides a graphical user interface (GUI)-
based working approach to the developers.
Modern IDEs can also be used to generate
structure diagrams, flowcharts, and give a
modular approach towards programming.
In order to select an IDE, you can overview
your 
language 
requirements 
and
programming style as well. This can make it
easier for you to finish complex applications
and bring in better results.
Tools and Technologies
There are thousands of software development
tools, IDEs, and technologies that can be used
to create perfect applications, programs, and
software. We have listed and briefed some of
the most effective, easy to use, and state of
the art tools for programmers to develop any
kind of web, desktop, and mobile application.
Here are some of the best tools for beginner
programmers:

NetBeans
NetBeans is an open-source integrated
development environment that can be used as
a tool to develop desktop, web, and mobile
applications. Allowing for an easy and
efficient project management process, the
tool allows developers to write bug-free code
and provides a smart code editing facility as
well. Furthermore, the IDE is best suited for
PHP, C++, and C programming languages.
Cloud9
When it comes to online integrated software
development environment, Cloud9 is surely
one of the best tools to be considered. The
supporting languages include PHP, C, C++,
Python, 
Perl, 
Node.js, 
and 
JavaScript.
Developers can choose an extensive set of
default runners to execute an app and code
faster with the provided suggestions.
Visual Studio
Visual Studio is a supreme Integrated
Development Environment designed and
developed by Microsoft. Supporting a wide

range of platforms, developers can now build,
secure, 
share, 
and 
manage 
software
components without any hassle. Furthermore,
the Automated and Azure deployments allow
you to improve code quality along with the
support of a centralized vision control
system.
Technologies
Learning 
programming 
languages 
and
technologies can be the best way to adapt to
the latest programming approaches and
techniques. Starting with major programming
technologies such as JavaScript, Python,
Java, and C++ can make it quite simple for
beginners to develop a better understanding
of computer programming. Furthermore, each
technology has its own perspectives and
methodologies for which you have to learn
the concepts and approaches in depth.
For 
open-source 
developers, 
Java 
is
considered as the best programming language
due to the Java Virtual Machine (JVM)
paradigm. This allows the software to run on

any system. Beginners can also start
practicing programming from C++ because it
gives access to very low-level system
components and simple methodologies.
Methodologies
Programming Methodology is the process of
analyzing complex problems and planning
the software development process in order to
achieve the best possible solutions. Also
known 
as 
modular 
programming, 
the
software development process is categorized
as follows:
1. Requirement gathering
As this is the first stage in the Software
Development Life Cycle process, it is
performed by experts and professionals who
can easily conduct a feasibility study for the
project. 
The 
outcomes 
and 
technical
approaches are discussed so that the project
can be completed without any issues.
2. Requirement Engineering

The next step is to gather the relevant data
and define requirements that are needed to
get the project done. Usually, we have to
create a Software Requirement Specification
(SRS) document that is comprised of all of
the essential design and development data.
The system analyst has to be clear about
client requirements and needs to give a
detailed briefing to the developers so that
they can write the code accordingly. Usually,
the clients are not able to clearly define their
requirements and give guidelines in general.
3. Designing
After we are done with the requirements
engineering, the next step is to design the
architecture as specified in the Software
Requirements Specification (SRS) document.
At this point, you are required to outline the
design modularity, time constraints, and
product specifications as well.
4. Development
This is the stage from which the developers

will start working on the project by following
the instructions and guidelines from the
project 
manager. 
For 
each 
project
specifically, a programming language is
selected 
after 
extensive 
research 
and
development so that the actual requirements
and functionality of the client can be
completely satisfied.
5. Testing
This stage involves the checking and
inspection of the software by overviewing the
client requirements. By using various test
cases, the product is checked for errors,
mistakes, and areas that need improvements
to make sure that each requirement is
completely satisfied and operational.
6. Deployment
Deployment is the last stage of the SDLC
process. As the product has now passed
through the design, development, and testing
procedures, it is ready to be delivered back to
the client. depending on the business strategy,

the product can also be released in the market
or as per the instructions given by the client.
Front End Technologies
Front-End development is generally referred
to as the development of user interfaces by
the implementation of design, structure, and
animation for web applications. The core
technologies that are used for front-end
development include HTML, CSS, and
JavaScript whereas professional developers
might also use the latest technologies such as
AJAX, AMP, or Angular.
Hyper Text Markup Language (HTML) and
Cascading Style Sheets (CSS) are the basic
building blocks for creating websites and are
also used to enhance the responsiveness of
web pages. HTML, JavaScript, and CSS are
the three primary technologies for front end
development.
Document Editors
To create software documents, presentations,
charts, graphs, or animations, there are
several document editing tools available.

Starting with the most popular tool, you can
install Microsoft Office and edit any type of
document without any hassle. The package
includes Microsoft Word, Microsoft Excel,
Microsoft PowerPoint, Outlook, OneNote,
One Drive Access, and other modules as
well.
Furthermore, Google Docs is yet another
helpful document editing tool which can be
used online to access, update, and create
documents. The tool lets you create sheets,
docs, slides, and forms for which you can
select from a wide range of templates.
CHAPTER TWO

JAVA
Overview and Basic Syntax
Java is a high-level programming language
which was released by Sun Microsystems in
1995. There are unlimited websites and
applications built using Java technology
because it is reliable, easy to use, and faster
compared to other programming languages.
Being 
an 
object-oriented 
programming
language, developers can code, compile,
execute, and test programs much faster.
Furthermore, the applications developed
using 
Java 
are 
adaptable 
to 
multiple
environments and are more secure as well.
The language is made to run on different
platforms including Windows, UNIX, and
Mac OS for which multiple configurations
are provided. Being absolutely platform
independent, J ava is compiled into platform
specific machines and the byte code is then
distributed and interpreted through Java
Virtual Machine (JVM). Moreover, Java byte

code enables high performance and is
designed 
for 
a 
distributed 
internet
environment as well.
Moving on to the basic syntax, Java
programming is generally based on Objects,
Classes, 
Methods, 
Variables, 
Modifiers,
Constructors, and Regular expressions. To
better understand the simple java program,
you can undergo the brief details of each
aspect as follows:
Keywords
Functionality
Class
Used to declare a class
Void
Return type
Public
Access 
modifier 
to
make 
the 
function
visible
Static
Used to create an object
in static method
Main()
Main 
() 
method 
is
placed at the start of the
program
System.out.println()Prints statements on the
console
Before you begin with Java programming,

make sure that you remember that Java is a
case sensitive language and you need to
declare the class names with the first letter in
upper case. Method names should start with a
lowercase letter and the name of the program
file should be exactly the same as the class
name to avoid any problems when executing
the program.
The concepts in Java programming language
include Classes, Objects, Polymorphism,
Inheritance, 
Abstraction, 
Encapsulation,
Instance, Method, and Method passing.
Your first Java program might look like this:
class HelloWorld
{
       
public static void main(string[] args)
       
{
                   
System.out.println ("Your first Java
Program!")
       
}
}
Java Identifiers and Modifiers
Java Identifiers should begin with a letter

from A to Z or a to z because the identifiers
are case sensitive as well. You must
remember that a keyword can never be used
as an identifier and identifiers can have any
combination of characters after the first
character. For example, month, $price, or
_place.
There are two types of modifiers in the Java
programming language. One is known as
Access modifiers whereas the other is called
Non-access 
modifiers. 
Modifiers 
are
generally used to modify methods or classes.
Object, 
Classes, 
and
Constructors
Classes and Objects
Objects are a part of classes and are also
known as instances of classes. A class
represents a set of properties that are common
to all of the objects and is a defined prototype
from which the objects are created. To
declare a class, we will have to include
Modifiers, 
Class 
Name, 
Superclass,

Interfaces, and Body.
Furthermore, everything in Java is associated
with objects and classes that are combined
with methods and attributes as well. Take an
example of a mobile phone in real life, it has
attributes such as color, memory, display, and
weight.
To create a class in Java, you need to follow
the syntax as mentioned below:
Public class NewClass {
Int a = 1;
}
To create object called “newObj”:
Public class NewClass {
       
Int a = 1;
Public static void main (String[] args ) {
       
MyClass NewObj = new NewClass();
       
System.out.println(newObj.x);
       
}
}
Creating an object requires declaration,
instantiation, and initialization. Declaration is

the process of declaring a variable name
along 
with 
an 
object 
type 
whereas
Instantiation is used to create an object with a
new keyword. The program is then continued
by a call to the constructor in order to
initialize the new object.
Basic 
Data 
Types 
and
Variables
In a Java program, the data is stored in
variables and the program at first declares the
variables, reads data onto the variables, and
then executes the provided operations. Once
the process is completed, the variables are
then written once again at a new location.
Variables 
provide 
a 
reserved 
memory
location to store values and the memory is
allocated by the operating system.
Data Types
There are two different data types in Java
programming language known as Primitive
Data Types and Object Data Types. Primitive

data types are classified into 8 categories:
Byte, Short, Int, Long, Float, Double,
Boolean, and Char. Object data types are
created by using the constructors of the
classes and they are also responsible for
accessing objects. The default value of every
available reference variable is set to null and
it can also be used to refer to an object of the
declared type.
Variables
There are three types of variables used in the
Java programming language:
1. Local variables
2. Instance variables
3. Class/Static variables
Local variables
Local variables are generally declared on
constructors and methods. As they are created
with a constructor, access modifiers cannot
be used along with local variables. There is
no default value for local variables.
Instance variables

Instance variables are declared within a class
and it is created whenever an object is
created. They are supposed to hold values
that are referred to by more than one
constructor or method. Access modifiers can
also be given to instance variables.
Operators, 
Control
Statements 
and 
Decision
Making
Operators
The basic operators that are available in the
Java programming language are explained as
follows:
Arithmetic Operators: Arithmetic
operators can be used to perform
mathematical 
calculations 
and
equation 
solving 
within 
the
program. This includes Addition,
Subtraction, 
Multiplication,
Division, Modulus, and Increment
and Decrement functions.

Unary Operators: Postfix: expr++
and 
Prefix 
++expr 
–expr
expressions.
Logical Operators: (A && B) for
false, (A || B) for true and !(A &&
B) for true.
Bitwise Operators: To perform bit-
by-bit operation.
Assignment: =, +=, |=, ^=.
Control Statements
The control statements for the Java language
are 
similar 
to 
that 
of 
other 
major
programming languages such as C or C++.
The conditions are briefed in detail as
follows:
If Else: The if statement is used to check
whether the given condition is true or false.
There are different types of if statements in
the Java programming language which are
called an if statement, if-else statement, if-
else-if ladder, and nested if statement.
Here is a simple Java program to demonstrate
the if statement:
public class Marks {

1
2
3
4
5
6
7
8
9
10
public static void main(String[] args) { 
    int Marks=50;
    if(age<50){
    System.out.print("Your marks are less than 50");
    }
}
}
Output for the above program is: Your marks
are less than 50.
If-else: The statement is used to test the
condition and if the results are true, the If
block is executed and in case of false, the else
statement is executed.
Switch: The Switch statement is used to
execute a single statement from multiple
conditions. The statement can work with data
types including short, int, long, byte, String,
and Long.
Syntax for Switch Statement is given as
follows:
switch(expression){    
case value1:    

//code to be executed;    
break;  //
case value2:    
//code to be executed;    
break;
default:     
code to be executed if all cases are
not matched;   
}    
Loops
There 
are 
three 
kinds 
of 
loops 
in
programming languages that are used in
general.
For loop
While Loop
Do-while Loop
For Loop
For Loop is used to perform iteration in a part
of the program. If the number of iterations is
fixed, you are advised to use For Loop in
your program.

While Loop
While Loop has the characteristics to repeat a
single or group of statements to test whether
the given condition is true or not. It is used
when the number of iterations is not fixed.
Do While Loop
The Do While Loop is used to iterate a part of
a program several times. If the number of
iterations is not fixed, you are required to
execute the program at least once.
There are specific loop control statements
that are required to change the execution into
a 
normal 
sequence. 
The 
two 
control
statements 
used 
in 
Java 
programming
language include:
Break statement: Terminates the
switch or loop to start the next loop.
Continue statement: Allows the loop
to retest its condition and skip the
rest of the body.
Decision Making
The decision-making structure features one or

more conditions that need to be tested under a
given scenario. If the condition is true, the
next statement can be executed whereas the
program would terminate if the given
condition is false. The diagram below
correctly shows how the decision-making
process actually works:
Characters, Strings, Arrays,
and Regular Expressions
Java programming language makes use of
Character wrapper class and offers multiple
static methods for manipulating characters.
To create a character object, you need to
follow the syntax as follows:
Character ch = new Character (‘a’);
The compiler will automatically create a
Character object and if you pass any
primitive char into the method, the compiler
will convert the Char into Character by using
various approaches from the language.
As we have discussed the importance and
functionality of strings before, Java platform
also provides the support from string class.

Programmers can manipulate strings in
multiple ways. The sample code for creating
a string in the Java language is as follows:
public class NewString {
public static void main(String args[]) {
    char[] StudentArray = { 'S', 'T', 'U', 'D', 'E', 'N' , 'T'};
                String StudentString = new String(StudentArray);
                System.out.println( StudentString );
         
}
}
The output for this program is: Student.
Moreover, we can also concatenate strings by
using a simple concatenation approach in
Java programming language as follows:
String1.concat( string2);
To 
create 
a 
string 
object 
in 
Java,
programmers can choose either a literal or
keyword approach.
Arrays
Arrays are a vital part of every programming
language as they allows programmers to
handle and store data into variables. As they
are used to store a large collection of data,

you can also consider an array as a collection
of variables of the same category. To declare
an array, you can follow the simple syntax as
briefed below:
datatype[] arrayRefVar;
Creating an array in Java is simple for which
you can use the following syntax:
arrayRefVar = new datatype[arraySize];
This statement will create an array of the
given size and assign the reference of this
array to the given variable as well. Usually,
the arrays are processed by using for loop or
foreach loop because the elements inside the
array are of the same type and size.
Static 
methods 
for 
sorting, 
searching,
comparing, and filling array elements:
Public 
static 
int
binarySearch(Obkect[ ] a, Object
key)
Public static void fill(int[ ]a, int val)
Public static Boolean equals(long[
]a, long[ ] a2)
Public static void sort(Object[ ] a)
Regular Expressions

Regular expressions is an API that is used to
define string patterns and is also used for
searching, editing, and manipulating text.
Java has predefined java.util.regex package
that consists of a Pattern class, Matcher
Class, and PatternSyntaxException object.
The Pattern class requires the developers to
start with the compile() methods and return a
pattern object as it provides no public
constructors.
For the Matcher class, the matcher object
finds and compares the operations against an
input string in order to obtain a Matcher
object through the Matcher() method. The
PatternSyntaxException is used to indicate an
error or mistake in the regular expression
pattern.
Files and I/O
Java programming language features a built-
in package that is responsible for data input
and output operations. The stream is known
as java.io and supports multiple operations
and functionality to handle data. There are

two general types of streams in Java which
are known as Input Stream and Output
Stream.
Input Stream is used to read data whereas the
Output stream is used for writing data in a
file.
Java language features various I/O data
handling streams that include the following:
Byte Streams
Character Streams
Standard Streams
File Input Stream
File Output Stream
Object Oriented Java
Object Oriented Programming is an approach
that includes the use of classes and objects.
By 
using 
multiple 
concepts 
such 
as
inheritance, polymorphism, Encapsulation
and Abstraction, programmers can develop
java applications and programs.
Inheritance

Inheritance is a feature in Java programming
language that allows it to inherit the features
and properties of another class. This can be
done between the subclass and superclass.
The class whose features are inherited is
called the superclass whereas the class that
inherits the properties of another class is
called as the subclass.
To use Inheritance in Java programming
language, you can follow the syntax as
mentioned below:
Class derived-class extends base-class
{
//methods
}
Polymorphism
The technique of doing a single task in
multiple ways is known as Polymorphism. In
Java programming, we can use method
overriding 
and 
method 
overloading
techniques to achieve polymorphism. It is
essential to know that an object can also be
accessed through a reference variable and
once it has been reassigned to other objects,

the type of reference variable can be used to
determine the method that is to be used to
access the object.
For example:
Public interface School{}
Public class Student{}
Public class John extends Student implements
School{}
In the above case, John is known to be
polymorphic 
because 
it 
has 
multiple
inheritance and we can apply the reference
variable for the same object as well.
Abstraction
An Abstract Class is one which includes an
abstract keyword in its declaration and it can
or might not contain abstract methods. In a
case where a class has an abstract method, it
cannot be instantiated and the programmer
will have to inherit it from another class to
implement the abstract method.
Encapsulation
Encapsulation in Java programming is the

process of wrapping data and methods
together. Generally, the variable of one class
will be hidden from another class and it can
only be accessed through the methods that are
being used in their current class. The
advantages of encapsulation are that a class
could be made read only or write only and it
can also have total control over the data
stored.
Recursion
Recursion is a technique referred to a method
which calls itself within the program. The
recurse() method is called from the main
method and can also be called from the same
recurse() method as well. This process
continues until the given condition is met and
if the case is not satisfied, infinite recursion
occurs.
Here is a simple implementation of recursion
in Java:
class Sample {
static void printFun(int test)
{

   
if (test < 1)
       
return;
   
else {
           System.out.printf("%d ", test);
       
// Statement 2
           printFun(test - 1);
           System.out.printf("%d ", test);
       
return;
   
}
}
public static void main(String[] args)
{
   
int test = 3;
       printFun(test);
}
}
Advantages of recursion
There are several complex programs in which
writing recursive code can deliver several
benefits. As it provides a simple and clean
way to write code, developers can perform

operations of different kinds without any
hassle.
Abstract Class and Abstract
Methods
Abstract Class
In Java programming, an Abstract class is
known as a class which cannot be initiated
and is declared by using the ‘abstract’
keyword.
Here is the syntax for declaring an abstract
class Student in Java:
abstract class Student {
//methods and attributes
}
Remember that we cannot create objects of
an abstract class. Doing so will generate a
compilation error.
Inheritance of Abstract class
Here is a sample Java program illustrating the
inheritance of an abstract class:

abstract class Student {
public void displayInfo() {
  System.out.println("I am a Student");
}
}
class Grade extends Student {
}
class Main {
public static void main(String[] args) {
  Grade G1 = new Grade();
  G1.displayInfo();
}
}
Abstract Method
To create an abstract method in Java, the
same keyword ‘abstract’ is used. The syntax
is defined as follows:
Abstract void moveto();

CHAPTER THREE
SQL AND DATABASE
What is a Database?
A database is a collection of data which can
be accessed, managed, and updated. Before
entering into a brief discussion of database, it
is important that we understand what Data
actually means and how it can be processed.
Data is generally defined as a collection of
records and facts with which we can perform
calculations and apply reasoning to.

To protect, save, deliver, and organize data,
databases are created and the system that
manages the whole process is called a
database management system (DBMS).
Database 
Management 
System
(DBMS) concepts
A Database Management System consists of
multiple programs that allow users to access
the database and handle data through
different processes. As it is generally
designed to control access to the database,
there 
are 
various 
operations 
and
functionalities introduced in the DBMS to
make it more effective, safe, and reliable.
There are 4 different types of DBMS:
1. Relational DBMS
This category of DBMS defines database
relations in the form of tables.
2. Object Oriented Relational DBMS
Object Oriented Relational DBMS allows
data to be stored in the form of objects along

with their attributes.
3. Network DBMS
The Network DBMS features many-to-many
relations and is generally used for complex
database structures.
4. Hierarchical
Hierarchical DBMS follows the parent-child
relationship to store data and has a structure
similar to that of a tree with nodes that are
used to represent various fields.
Database 
Environment 
and
Architecture
The database environment is known as a
collective system of components which are
responsible for data handling, management,
and use of data. As databases are generally
stored in computers, the hardware and
computer peripherals that are used to manage
the whole process also include DBMS tools
such as SQL Server.
The Architecture of a Database or DBMS is

usually classified into three major categories:
Centralized, Decentralized, and Hierarchical.
Database systems can be client-server or
centralized and can also be designed to be
accessed by parallel computer architectures.
The Three-Tier architecture of a DBMS is
defined as follows:
Presentation Tier
Application Tier
Database Tier
Types of Databases
There are different types of databases that are
classified as per their organizational approach
and functionality.
Relational Database
A relational database is where the data is
defined, organized, and accessed in multiple
ways. Being a tabular database, the table
consists of rows and columns which is
managed through Structured Query Language
(SQL).
Distributed Database

The distributed database has its data stored at
multiple sites which are interconnected with
each other through communication links. This
database 
is 
further 
classified 
into
Homogeneous and Heterogeneous categories.
For the homogeneous distributed database
system, the same type of hardware, OS, and
database applications are connected together
whereas for the heterogeneous distributed
database system, the system can be different
for each location and connection.
Cloud Database
The Cloud Database environment is designed
and built to store data in private, public, or
hybrid cloud. Providing better scalability and
greater storage capacity, users can benefit
from high availability. It is the best suitable
option for business applications.
NoSQL Database
NoSQL Database is best suited for large
distributed data and it is conveniently
managed 
through 
relational 
databases.
Furthermore, they are effective for big data
performance issues which cannot be easily

solved by using relational databases.
Object Oriented Database
Object Oriented Database is supported by the
relational database and is based on objects
rather than actions.
End User Database
End User Database is a shared database that
is specifically designed and created for the
end user. As it features a summary of the
whole database, the end user certainly needs
not to worry about the operations that are
being performed at any database level.
Database Syntax, Data Type and
Operators
Standard Query Language (SQL) is used for
storing, manipulating, and retrieving data
within a database. SQL allows database
administrators to perform multiple operations
that are required to manage a database. The
language allows you to execute queries,
retrieve data, insert records, update records,
delete records, create new databases, create

new tables, and set permissions in a database
just by writing simple queries.
There are different versions of SQL and all of
them support major functionalities such as
SELECT, DELETE, INSERT, WHERE, and
UPDATE.
Structured Query Language
(SQL)
SQL is the language that is used for relational
database systems such as MySQL, Sybase,
Oracle, and SQL Server. Being a standard
database language, SQL allows users to
describe the data, access data, and manipulate
the relational database management systems.
Furthermore, users can also create, view, and
drop databases through the Structured Query
Language.
The different components that are included in
this process are Optimization Engines, SQL
Query Engine, Classic Query Engine, and
Query Dispatcher. To perform specific
operations 
in 
a 
relational 
database
management system, we can use the

commands mentioned below:
Command
Description
CREATE
User can create a new table or
an object within the database.
READ
User can read the data stored in
the tables.
UPDATE
Update the tables to modify
records.
DELETE
Delete any record from the
table.
INSERT
Insert a new record into the
table
SELECT
Select specific records from the
tables within the database.
ALTER
Bring 
changes 
within 
a
database object.
DROP
Delete the entire table from the
database.
By using the above operations, we can

perform different operations from the sample
table named ‘Students’ given below:
Student
ID
Student
Name
City
Subject
1
William
New York Mathematics
2
James
California
English
The SQL statement to fetch records from the
above table will have the following syntax:
SELECT * FROM Students;
1.   SQL Queries
In order to perform specific operations with
tables in a database, we are required to use
different queries that are explained as
follows:
Query
Syntax
INSERT
INTO
INSERT 
INTO
table_name(column1,
column2,…)
VALUES (Value1, Value2,…)
UPDATE
UPDATE 
table_name 
SET

column1 = value1, column2 =
value2,..
WHERE condition
DELETE
DELETE FROM table_name
WHERE condition;
ORDER
BY
SELECT column1, ..FROM
table_name
ORDER 
BY
column1,   ASC/DESC;
MIN()
SELECT MIN(column_name)
FROM table_name
WHERE condition;
MAX()
SELECT
MAX(column_name)
FROM table_name
WHERE condition;
WHERE
SELECT column1,..
FROM table_name
WHERE condition;
SQL Joins
Taking the example of relational database

with table A and table B, the table can also be
joined through the SQL JOIN query. The
Venn diagram clearly shows how both of the
tables are joined together to share data:
We will implement various JOIN clause
operations on the example tables ‘Patients’
below:
Table 1:
PatientID
CaseNO
Date
43221
1
9-2-2011
82357
3
8-12-2015
Table 2:
CaseNo
PatientName
City
1
Andrew
Chicago
3
John
LA
To join both tables, we can write the SQL
JOIN statement as follows:
SELECT Patient.PatientID, Case.CaseNo, Date.
FROM Patients
INNER JOIN Patients ON Case. CaseNo = PatientName.Patient ID;

There are four different types of SQL JOIN
queries known as:
INNER JOIN
LEFT OUTER JOIN
RIGHT OUTER JOIN
FULL OUTER JOIN
Inner join
Inner join selects the entire record from Table
A and Table B where the Join condition is
satisfied. The syntax for creating inner join in
SQL is defined as follows:
SELECT column name
FROM table1
INNER JOIN table 2
ON table1.column_name = table2.colmn_name;
Left Join
The Left join selects the entire record from
Table A combined with the records from
Table B where the join condition is satisfied.
Syntax for creating LEFT JOIN in SQL is
defined as follows:
SELECT column name
FROM table1
LEFT JOIN table 2
ON table1.column_name = table2.colmn_name;

Right Join
The Right join select all records from Table B
combined with the records from Table A
where the join condition is satisfied. Syntax
for creating RIGHT JOIN in SQL is defined
as follows:
SELECT column name
FROM table1
RIGHT JOIN table 2
ON table1.column_name = table2.colmn_name;
Full outer Join
The Full outer Join selects all records from
Table A and Table B even if the join
condition is not met. Syntax for creating
FULL JOIN in SQL is defined as follows:
SELECT column name
FROM table1
FULL OUTER JOIN table 2
ON table1.column_name = table2.colmn_name
WHERE condition;
Union Operator
To combine the result of two or mode
SELECT statements, the UNION operator is
used for which each of the column must have
similar data types. Moreover, the columns in

the SELECT statement should be in the same
order for both tables. The syntax for
implementing UNION operator in SQL is
defined as follows:
SELECT column_name FROM table1
UNION
SELECT column name FROM table2;
GROUP BY
The SQL GROUP BY statement can be used
to perform listing or numbering from the
database table. Syntax for using GROUP BY
statement in SQL is defined as follows:
SELECT column_name
FROM table_name
WHERE condition
GROUP BY column_name
ORDER BY column_name;
ORDER BY
The ORDER BY statement in SQL is used to
sort data in ascending or descending order.
Syntax for implementing ORDER BY clause
is defined as follows:
SELECT column_list
FROM table_name
WHERE condition
[ORDER BY column1, column2,] [ASC | DESC];

Advanced SQL
There are several other vital operations and
clauses that can be implemented to perform
complex operations within the database. Here
are some of the key features of advanced
SQL explained in detail:
Indexes
SQL Indexes are used by database search
engines to optimize the process of data
handling. As they are considered as special
lookup tables, an index helps to speed up
WHERE clauses and SELECT queries as
well. To create an Index, we can use the
CREATE INDEX statement along with the
UNIQUE constraint to prevent duplicate
entries.
Syntax for using CREATE Index:
CREATE INDEX index_name ON table_name;
Syntax for using DROP Index
DROP INDEX index_name;
Truncate Table
The TRUNCATE TABLE command is SQL
is implemented to delete complete data from

an existing table.
Basic syntax:
TRUNCATE TABLE table_name;
SQL Primary and Foreign Key
Primary Key
The PRIMARY KEY constraint in SQL is
implemented to uniquely identify each record
in a table. Primary keys should always
contain unique values and do not have any
NULL values. Moreover, one table can only
have one unique primary key which can be
made up of single or multiple columns.
For example, to define PRIMARY KEY on
the ID column when the “Students” table is
created, we can use the following SQL
statement:
CREATE TABLE Students (
ID in NOT NULL,
FirstName varchar (255),
LastName varchar NOT NULL (255),
Marks int,
PRIMARY KEY (ID)
);

Foreign Key
The FOREIGN KEY constraint in SQL is
implemented to link two tables together for
which the FOREIGN KEY in one table refers
to the PRIMARY KEY from the other table.
Syntax for implementing the FOREIGN KEY
constraint on “StudentID” column to create
“Student” table:
CREATE TABLE Student (
StudentID in NOT NULL,
StudentMarks int NOT  NULL,
ClassID int,
PRIMARY KEY (StudentID),
FOREIGN KEY (ClassID) REFERENCES
Students( StudentID)
);
Constraints 
and 
Useful
resources
Constraints are the specific rules that are
implemented on data columns of a table.
Generally, constraints are implemented to
limit the type of data that can be inserted into
a table. Most commonly, this includes NOT

NULL Constraint, DEFAULT Constraint,
UNIQUE 
Constraint, 
PRIMARY 
Key,
FOREIGN Key, CHECK Constraint, and
INDEX.
Furthermore, Integrity constraints can also be
used to avail better consistency and accuracy
of data present in the relational database.
Usually, PRIMARY KEY, FOREIGN KEY,
and UNIQUE Constraints are a part of
Referential Integrity (RI).
In order to improve the performance of SQL
database, there are several important factors
that can be implemented with ease. While
writing a column name, it is advised that
SELECT statement is used rather than the *
delimiter. For example:
SELECT * FROM Students

Furthermore, setting the NOCOUNT ON
statement will reduce the time required for
SQL Server to update rows for INSERT,
DELETE or UPDATE operations

CHAPTER FOUR
C
C programming language was developed at
AT & T’s Bell Laboratories in the USA in
1972. Generally, there are two major
categories of programming languages known
as High Level language and Low-level
Language but C is ranged as a Middle Level
language. The purpose of this language is to
provide low level access to memory and has
also 
given 
syntax 
to 
other 
major
programming languages such as PHP and
Java.

Introduction 
and 
Simple
Programs
Being a structured language, programmers
can create partitioned code blocks and create
business 
applications 
by 
implementing
different 
approaches 
and 
programming
techniques. Moreover, we can also write new
functions and repeat them throughout the
application in the C library.
Starting with C Programming
Writing a C program is simple and easy for
beginners. Starting with the basic program
syntax, we can develop C applications and
programs as follows:
#include <stdio.h>
int main()
{
       
int a = 2;
       
printf("%d",a);
       
return 0;
}

Header Files
The first part of writing a C program is
selection of header files. Generally, a header
file is written with extension .h and also
contains function declarations. To include a
header file, we can follow the syntax as
follows:
#include <string.h>
Examples of C header files:
Header
File
Definition
Stdio.h
Used to define input and output
functions
String.h
Used for string handling
Stddef.h
Defines useful types and macros
Stdlib.h
Defines memory allocation
Stdint.h
Used for defining integer types
Math.h
Used to perform mathematical
functions

Methods 
and 
Variable
declaration
The next part of writing a C program is to
define a method and declare the variables.
Syntax for declaring main method is:
Int main()
{
Syntax for variable declaration is:
Int main()
{
Int z;
}
Program Body:
Int main()
{
Int z;
Printf(:%d, z);
Return 0;
}
To terminate the program, we can use the
return statement: return 0.
Keywords

Keywords are the main driving force of any
programming language and are also known as
reserved words. Although there are several
keywords 
for 
high 
level 
programming
language, only 32 keywords are allowed to be
used in C which are as follows:
Double
Long
Int
Switch
Case
Register
Enum
Typedef
Union
Extern
Const
For
Do
While
Static
Default
Auto
Break
Else
Struct
Float
Short
Char
Return
Void
Continue For
If
signed
Goto
Sizeof
volatile
Data Types and Variables
In the C programming language, data types
are used to define a variable so that storage
can be assigned before it is being used in the
program. The built-in data types of the C
programming language include Float, Int,
Char, and Double. These data types have
modifiers called Short, Long, Signed, and

Unsigned.
Following are the valid numbers, alphabets,
and symbols that are allowed in the C
programming language:
Alphabets: A-Z, a-z.
Symbols: - ~ ‘ ! @ # % ^ & * ( ) _ - + = | \ {
} [ ] : ; " ' < > , . ? /
Digits: 0,1,2,3,4,5….
Variables
To declare the variables in C, we can follow
the program syntax as follows:
#include <stdio.h>
// Variable declaration:
extern int a, b;
extern int c;
int main () {
  /* variable definition: */
  int a, b;
  int c;
  float f;
  /* initialization */
  a = 30;
  b = 20;

  c = a + b;
  printf("value of c : %d \n", c);
  return 0;
}
The output of this program is: 50.
Scope of Variables
The scope of variables in any programming
language is set to allow certain permissions to
the 
variables. 
Generally, 
variables 
are
categorized as Local variables, Global
variables, and Formal parameters.
Local variables are declared within a block
and can be only used by statements that are
written in a specific region of the program.
As they are not known to other functions in
the program, we cannot access local variables
outside the function.
Global variables are usually defined outside a
function and hold their values throughout the
program. It can be accessed and called by any
function within the program. Local variables
need to be initialized by the programmer
whereas the global variables get initialized

automatically.
Loops and Functions
Loops
Loops are an essential part of every
programming 
language 
and 
allow 
the
developers to execute a specific statement
multiple times. There are 4 different types of
loops used in the C programming language
that are briefed as follows:
1. For Loop: Used to execute a statement a
specific number of times and is also
considered to abbreviate the code to handle
loop variable.
2. While Loop: Repeats the given statement
and checks whether the given condition is
true or false. Before executing the loop body,
it checks all of the conditions.
3. Do While Loop: Works the same as the
While loop, however, the Do While Loop
only checks the condition at the end.
4.  Nested Loops: A loop inside a loop is
known as nested loop. It can be a While loop,

Do While loop, or For loop.
To change the execution of loops from the
normal sequence, we can use the Loop
Control statements as well. The Break
Statement exits the loop and transfers
execution to the next statement whereas the
Continue statement causes the loop to skip
the rest of its body and recheck the given
condition.
For transferring control to the labeled
statement, we can use the Go to Statement as
well.
Functions
To define a function in the C programming
language, 
the 
following 
syntax 
is
recommended:
Return type function name( parameter list) {
Function body
}
In a function, the return type is known as the
data type of the function value that is returned
by the function itself whereas the action name
of the function is known as Function Name.
Whenever a function is invoked, we are

required to pass a parameter and its value is
referred to as an argument or actual
parameter. It must be noted that parameters
are not compulsory and a function might also
be executed without any parameters.
Function Body contains multiple statements
and usually defines the actions that are to be
performed within the function. To declare a
Min() function in C, we can use the syntax as
follows:
Int min(int num1, int num 2);
To call a function within the program, we are
required to pass the parameters and function
name. If any value has been returned by the
function, it can be stored as well.
Methods to Pass an Argument
to a Function
Call by Value
The Call by Value method is used to copy the
actual value from an argument to the formal
parameter of the function. The changes that
are made to the parameter have no direct
effect on the argument within the function.

Call by Reference
The Call by reference method is used to copy
the address of an argument to the formal
parameter. Changes made in the parameter
directly affect the argument.
Arrays, Strings, and Linked
Lists
Arrays
An array is a collection of elements that can
store a fixed size sequential data of the same
type. Consisting of contiguous memory
locations, an array can be declared through
the following syntax:
Type arrayName [ arraySize];
Example:
3
5
6
8
10
20
All of the arrays have 0 as the index of their
first element and it is also known as the base
index. Note that the size of an array cannot be
changed after declaration. To initialize an
array in the C language, we can use the

statement as follows:
Int data[50];
To initialize an array, we can use the syntax
as mentioned below:
Int data[10] = {3, 2, 7, 8, 23, 42, 64, 73, 23,
77};
In this array, the index = 0 has value 3
whereas the index 9 has value 77.
Below is an example to find the average of 5
integers using arrays in C programming
language:
#include <stdio.h>
int main()
{
   int avg = 0;
int sum =0;
int x=0;
int num[4];
for (x=0; x<5;x++)
{
       printf("Enter number %d \n", (x+1));
   
scanf("%d", &num[x]);
}
for (x=0; x<5;x++)

{
   
sum = sum+num[x];
}
avg = sum/5;
printf("Average of entered number is: %d", avg);
return 0;
}
2D and 3D arrays
C programming language supports 2D and
3D multi-dimensional arrays as well. To
initialize the two-dimensional arrays, we use
the following syntax:
Int z[2][3] = {
{0, 1,}
{2, 3, 4}
{5,6,9}
};
Or
Int z[2]3] = {0, 1, 2, 3 , 4, 5, 6, 9};
Strings
In C Programming, strings are created by
using a one dimensional array of characters.

The string must be terminated by a null
character also known as “\0”.
To declare a string in C, we can follow the
syntax as mentioned below:
Char str_name[size];
‘str_name’ is used to define the string
whereas the size tells us about the length of
the string.
The below C program is written to declare,
read, and print a string:
#include<stdio.h>
int main()
{
// declaring string
char str[10];
// reading string
   scanf("%s",str);
// print string
   printf("%s",str);
return 0;
}

Pointers and Structures
A pointer is a variable that has a value the
same as the address of another variable in the
program. As it has direct address to the
memory location, we can declare a pointer in
advance and store it at any variable address as
well. The syntax for declaring a pointer
variable is as follows:
Type *var name;
To use pointers, at first, we are required to
define a pointer variable and assign the
address of a variable to the pointer as well.
Next, we can access the value from the
address that is given in the pointer variable.
The whole of this operation is performed with
the help of * unary operator which returns the
value of variable from address defined by the
operand. It must be noted that a normal
variable stores a value whereas the pointer
variable stores the variable address. As value
of the null pointer is 0, the size of any pointer
is 2 byte.
Below is a sample program written by using
Pointers in C language:
#include <stdio.h>

int main()
{
  int *ptr, q;
  q = 100;
  ptr = &q;
 printf("%d", *ptr);
  return 0;
}
Structures
Structure is defined as a collection of
variables and allows the programmers to
combine different data types. Being a user
defined datatype, a structure can be referred
to similar to that of an array but the only
difference between both of them is that an
array can only hold the data of a similar type.
Taking an example of an organization, we
can use structures to manage a record of the
employees as follows:
Name
Employee ID
Designation
Department
Region

The statement for defining structure in C
language is:
struct Employee {
char name[10];
int employee_id;
char designation[50];
char department[50];
char region[100];
};
To initialize the structure at compile time, the
statement is:
Struct Employee = {34,12,52,15,66};
Accessing the Structure Members
In order to access the member structure, we
are required to use the member access
operator. To access the members of a
structure in the C programming language, the
below mentioned type of operators can be
used:
Member operator: (.)
Structure pointer operator: (->)
Sample program for accessing the structure
members:

#include <stdio.h>
struct Distance
{
int feet;
float inch;
} dist1, dist2, sum;
int main()
{
printf("1st distance\n");
printf("Enter feet: ");
   scanf("%d", &dist1.feet);
printf("Enter inch: ");
   scanf("%f", &dist1.inch);
   printf("2nd distance\n");
printf("Enter feet: ");
   scanf("%d", &dist2.feet);
printf("Enter inch: ");
   scanf("%f", &dist2.inch);
sum.feet = dist1.feet + dist2.feet;
sum.inch = dist1.inch + dist2.inch;
while (sum.inch >= 12)
{
   
++sum.feet;
   
sum.inch = sum.inch - 12;
}

printf("Sum of distances = %d\'-%.1f\"", sum.feet,
sum.inch);
return 0;
}
Output:
Passing Pointers to Structures

We can also define pointer to structure in the
C programming language which is done in
the same manner as defining a pointer to
another variable. In order to access the
members of a structure through pointer, the
following syntax can be considered:
Struct_pointer->title;
C Programming files
Programming requires the developers to
handle different requirements and scenarios
by using the most effective approaches. To
perform file handling operations in C
language, we can use the operations as
follows:
·         Fprint(f)
·         Fscanf()
·         Fread()
·         Fwrite()
·         Fseek()
Generally, the entire data is lost when a
program is terminated for which we have to
create a specific file containing all of the
data. It also saves time and lets the

programmer access data from the file by
entering a few commands and transferring the
data from one computer to another through C
language operators.
There are two types of files known as Text
files and Binary files. Text files are .txt files
that can be created by using Notepad and
require minimum effort to write, maintain,
and update the record. Binary files are the
.bin files and they store the data in the binary
form of 0s and 1s. Furthermore, binary files
can store a bigger amount of data compared
to text files.
In the C programming language, we can
create a new file, open an existing file, read
from and write information to a file, and
close a file through simple commands
mentioned in the following table:
Operation
Syntax
Opening a
file
Ptr = fopen(“fileopen”,”mode”)
Closing a
file
Fclose(fptr);

Write 
to
binary file
Fwrite(address_data,size_data,num
pointer_to_file);
Read
from
binary file
Fread(address_data,size_data,num
pointer_to_file);
Write 
to
text file
FILE *fptr;
Fptr = fopen(“File address”,W”);
Read
from text
file
FILE *fptr;
Fptr = fopen(“File address”,R”);
File Seek
Fseek(FILE * stream, long int
whence)
Essential Tips to Make C
Programming Easy
For beginners, it is advised that they always
comment their code by writing vital code
information between /* and */. Commenting
on the major part of your code can also make
it easier to make future changes and improve
the 
functionality 
of 
the 
program.

Furthermore, always use variables to store
data such as int, char, and float because it will
make it simpler for you to perform different
operations and calculations.
C language is simple and fast. With the
availability of pointers, keywords, and
bitwise operators, writing efficient code will
surely not be a problem for beginners.

CHAPTER FIVE
C++
C++ is a free form and intermediate level
programming language that was developed
by Bjarne Stroustrup in 1979. Being an
enhanced version of the C programming
language, C++ has now become the most
used and best suited language for beginners.
The language delivers about 7 different styles
of programming and you can choose the most
suitable style as per your requirements. Being
a statistically typed programming language,
C++ allows the compiler to outline errors or
bugs 
before 
executing 
the 
program.
Moreover, Object Oriented Programming

with C++ makes it convenient to solve
complex problems and extends the usage of
standard libraries as well.
C++ 
is 
the 
world’s 
most 
popular
programming language and is widely used
with Graphical User Interfaces, Operating
Systems and Embedded Systems as well.
Basic Syntax
The basic syntax for C++ programming
language is the same as other languages such
as C. Including various words, symbols,
characters, operations, and expressions, the
programmer must follow a predefined set of
rules to execute the program properly.
Here is the first program we can write to get
started with C++:
#include<iostream>
using namespace std;
int main()
{
cout<<"My First Program in C++";
return 0;
}
Program Output: My First Program in C++.

The details of the program are as follows:
#include<iostream> 
= 
The 
statement
contains 
predefined 
input 
and 
output
functions and informs the compiler to include
the iostream file as well.
Using namespace std; = A statement used to
store the functions, variables, and operations
within the program whereas std is considered
as a namespace name.
Int main() = This is the main function of the
program from where the execution begins. Int
is a return type and indicates to the compiler
to return an integer value for which we also
have to include a return 0 statement at the
end.
Cout << “My First Program in C++” =
Cout is an object that belongs to the iostream
file and is used to display the content.

Return 0; = The statement returns value 0
from main() function and is responsible for
the execution of the main function as well.
Variables and Data Types
Variables
There are different types of variables in C++
programming language. As they are defined
with a specific keyword, we must create a
variable, specify the type, and assign the
value by following the syntax as given below:
Type variable = value;
Types of variables
Int = Used to store integers and
whole 
numbers. 
For 
example,
1,45,6346.
Char = Used to store single
characters. For example, ‘a’ or ‘Z’.
Double = Used to store floating
point numbers. For example, 50.2,
100.2342.
Bool = Used to store value with two

states: True or False.
String = Used to store text. For
example, 
“C++ 
programming
language”.
To declare and assign a value to a variable,
we can follow the syntax as mentioned
below:
Int newNum;
newNum = 50;
Cout << newNum;
Every variable that is being used in C++
should be identified with unique names which
are known as identifiers. To construct
identifiers, names must contain letters, digits,
or underscores and are case sensitive as well.
Data Types
Data types in the C++ programming language
define the type of data that can be stored in a
variable. Generally, the data types in C++ are
classified into three groups: built-in, derived,
and user-defined. The user defined data type
includes structures, union, and enum whereas
the derived data type is based on array,

function, and pointer.
Built-in data types for C++:
Int
Char
Float
Double
Bool
User defined data types:
Union
Enum
Struct
Derived data types:
Function
Array
Pointer
Modifier Types and Storage
Classes
Modifiers in C++ programming language are

used with char, double, and int data types to
change the meaning of base type in order to
meet certain programming conditions. These
modifiers include signed, unsigned, long, and
short.
To define the scope of variables and
functions within a C++ program, we can use
storage classes such as auto, register, extern,
mutable, and static. Auto storage class is
default for all local variables whereas the
static storage class allows the compiler to
store a local variable during the lifetime of
the program and destroy it whenever it goes
out of scope.
The external storage class gives reference of
a global variable and is used when there are
two or more files using the same global
functions or variables. For the mutable
storage 
class, 
only 
class 
objects 
are
considered and they can also be modified by
a constant member function as well.
Flow Control
In C++ programming, control flow is referred

to as the order in which instructions,
functions, and statements are being evaluated
and executed while the program is running.
These statements are executed sequentially
from top to bottom inside the code so that the
program logic is fully satisfied. Programs are
not dependent on a linear sequence of
statements for which C++ provides specific
flow control statements.
Flow control statements in C++:
1.       If else
2.      For loop
3.      Do while loop
4.      Break & Continue
5.      Switch statement
6.      Goto statement
If Statement
In C++ programming, the if statement is used
when there are multiple statements or cases to
be executed within the program. The syntax
for If statement shows that the parenthesis
only gets executed if the given statement is
true else the false statements are ignored

automatically.
if(condition){
statement;
}
Flowchart of If Statement:
Sample program to illustrate the If Statement
in C++:
#include <iostream>
using namespace std;
int main(){
 int marks=80;
 if( marks < 100 ){
    cout<<"Marks are less than 100";
 }
 if(marks > 100){
    cout<<"Marks are greater than 100";
 }
 return 0;
}
Nested If Statement
In C++, a statement within a statement is
known as a Nested If Statement. For
example:
if(condition_1) {

Statement1;
if (condition 2) {
Statement2;
}
}
If Else Statement:
if(condition_1) {
Statement;
else (condition 2) {
Statement;
}
}
Switch Case
A 
Switch 
Case 
statement 
in 
C++
programming is used when there are multiple
conditions given in the program and we are
required to perform operations based on the
provided condition. Break and Continue
operations are also a vital part of the Switch
statement. The syntax for Switch Case in C++
is as follows:
#include <iostream>

using namespace std;
int main(){
  int num=10;
  switch(num+5) {
 
case 1:
       cout<<"Case1: Value is: "<<num<<endl;
 
case 2:
       cout<<"Case2: Value is: "<<num<<endl;
     case 3:
       cout<<"Case3: Value is: "<<num<<endl;
 
default:
       cout<<"Default: Value is: "<<num<<endl;
  }
  return 0;
}
Go To Statement
The go to statement in C++ is used to change
the execution of a program and transfer the
control to another labeled statement within
the same program.
Syntax for go to statement: goto label;
Loops and Functions
Loops

Loop statements in C++ programming
language are implemented to execute a
specific block of code for a certain number of
iterations until it satisfies the provided
condition. As they allow programmers to
perform multiple tasks at a time, a loop
statement executes the first statement in the
function and moves onto the next as required.
Types of Loops
While Loop: Repeats a statement
while the provided condition is true
and rechecks before executing the
loop body.
Do While loop: Checks the condition
while the loop is being executed.
For 
loop: 
Executes 
a 
specific
statement multiple times and manages
the loop variable as well.
Nested Loops: More than one loop
inside another loop.
Loops can be executed through different
control statements such as Break statement,
Continue Statement, and goto statement.

Functions
Functions are responsible for combining
different segments of code and executing
them together to perform the given operation.
Two major types of functions in C++
programming 
language 
include 
Library
Function and User-defined Function. Library
functions are predefined in C++ whereas the
User-defined functions are created by the
programmer themselves.
To define a function, we can use the
following syntax:
Return_type function_name(parameter list) {
Function body
}
Sample code for min() function:
int min(int num1, int num2) { //function declaration
  // local variable declaration
  int result;
  if (num1 < num2)
 
result = num1;
  else
 
result = num2;

  return result;
}
Function Calling
To call a function in C++, we can use the
following methods:
Call by reference.
Call by Value.
Call by Pointer.
Function Overloading
When two or more functions have the same
name but different arguments, the process is
known as overloaded functions. The syntax
for function overloading in C++ is mentioned
as follows:
Void sameFunction(int a);
Int sameFunction(float a0;
Void sameFunction(int a, double b);
Arrays, Strings, Pointers, and
References
Arrays

Arrays are frequently used in programming
languages as they allow us to handle a huge
volume of data of the same type. Generally,
an array is referred to as a collection of data
which holds a fixed number of values.
Syntax for declaring an Array in C++:
datatype arrayName[arraySize];
Initialization:
Int age[5] = {15, 20, 25, 30, 35};
Sample program in C++ to find a sum of 10
numbers using Arrays:
#include <iostream>
using namespace std;
int main()
{
int numbers[10], sum = 0;
cout << "Enter 10 numbers: ";
for (int i = 0; i < 10; ++i)
{
   
cin >> numbers[i];
   
sum += numbers[i];
}
cout << "Sum = " << sum << endl;
return 0;
}

Strings
Strings are referred to as a collection of
characters. In C++ programming, the two
common types of strings used are C-strings
and the standard C++ Library String Class.
The following syntax can be used to define a
string:
Char str[] = “Programming”;
Pointers
A pointer is defined as a variable that has a
value which is considered as the address of
another variable. To use pointers in C++
programming language, we are required to
define a pointer variable and also assign
address of a variable to a pointer. Afterwards,
we can access the value through the address
given in the pointer variable.
The whole of this operation is performed by
using the Unary operator *. The following are
the pointers that are most frequently used in
C++ programming:
Null pointers
Array of pointers

Pointer to pointer
Passing pointers to Functions
Return pointer to Functions
Object Oriented C++
Classes and Objects
Object 
Oriented 
Programming 
in 
C++
language is a simple way to create objects
and perform multiple operations. At first, we
are required to define a class before creating
an object for which the below mentioned
syntax could be used:
class className
{
//data
};
A class can be defined as Public, Private, or
Protected so that the data members could
only be accessed specifically within the
program.
Sample code:
class student
{
private:

   
char  name[20];
   
int   rollNo;
   
int   total;
   
float perc;
public:
   
//member function to get student's details
   void getDetails(void);
   
//member function to print student's details
   
void putDetails(void);
};
Inheritance and Polymorphism
When writing a program to implement
Inheritance, we can consider the concept of
Base class and Derived class in C++. As a
class can be derived from one or more
classes, we can also inherit functions and data
from different base classes as well.
A derived class can access all of the non-
private members of its base class. Along with
inheriting the properties from the base class,
users can also create a new class from an
existing class. The syntax for inheritance in
C++ is defined as follows:
class A   // base class

{
..........
};
class B : access_specifier A   // derived class
{
...........
} ;
Access Specifiers
In C++, the access specifiers are used to
determine the limits for the availability of
class members beyond that class. Private,
Protected and Public are the major access
specifiers that define the accessibility of level
of class members
A private access specifier is used when
creating a class so that the protected and
public data members of the base class
become the private member of the derived
class whereas the private member of base
class still remains private.
In the protected access specifier, the public
and protected data members of the base class
become the protected member of the derived
class. The private member of the base class
still remains inaccessible.

Public Access specifier is used when the
public data members of the base class
become the public member of the derived
class. 
The 
protected 
members 
become
protected in derived class whereas the private
members 
of 
the 
base 
class 
remain
inaccessible.
Syntax for using Access specifiers in C++:
class MyClass {  // class
public:        // Access specifier
// class members
};
Friend 
Function, 
Data
Structures, and Encapsulation
Friend Function
In 
Object 
Oriented 
Programming, 
the
nonmember function is not given access to
private and protected data of an object. To
allow access for private or protected data in
this case, we can use Friend function or
Friend class which allows programmers to
access the private and protected data of a

class.
The function is declared by the keyword
‘Friend’ and should be used within the body
of the class. To declare the friend function in
C++ programming language, we can use the
syntax as mentioned below:
Class class_name
{
Friend 
return_type
function_name(argument);
}
Data Structures
Although Data Structures are required to be
briefed in depth with detail to clear objectives
of this topic, we will be discussing how a
structure is defined and used in C++.
Structure is a user defined datatype which can
be implemented in a program by using the
following syntax:
Struct [structure tag]
{
  
member definition;
}
For example:
struct vehicle {

  
char name[50];
  
char category[100];
  
int model_year;
} vehicle;
For accessing any member within the
structure, we can use the member access
operator (.). Defining pointers to structures is
made simple through data structures for
which we can use the following syntax:
Struct vehicle *struct_pointer;
Encapsulation
The term ‘Encapsulation’ is defined as the
approach to hide sensitive data from users in
programming. To perform encapsulation, we
are required to declare the class variables and
attributes as private and read or modify the
value of a private member through getter and
setter methods. The syntax for accessing
private members is defined as follows:
#include <iostream>
using namespace std;

class Employee {
 private:
// Private attribute
int salary;
 public:
// Setter
void setSalary(int s) {
 
salary = s;
}
// Getter
int getSalary() {
 
return salary;
}
};
int main() {
 Employee myObj;
 myObj.setSalary(50000);
 cout << myObj.getSalary();
 return 0;
}
File Handling
In C++ programming language, we have been

using cin and cout methods to read or write
data within a program. To read and write data
from a file, C++ offers a standard library
known as fstream which includes ofstream,
ifstream, and fstream data types.
To open a file, fstream or ofstream objects
can be used for which the C++ syntax is
defined as follows:
Void 
open(const 
char 
*filename,
ios::openmode mode);
Syntax for closing a file:
void close();
C++ Language Features and
Support
C++ programming language provides rich
library support and Standard Template
Library (STL) functions that can be used to
write code fast. As it is an object-oriented
programming language, we can focus on
objects and perform different types of
operations and implementations without any
hassle. Unlike other major programming
languages, C++ provides pointer support as

well.
Due to its fast, reliable, and secure features,
C++ is widely being used in the development
of Operating Systems, Browsers, Libraries,
Graphics, and Databases. The language is fast
and is well known for its speed and
efficiency. Moreover, C++ also allows
exception handling and supports function
overloading as well.

CHAPTER SIX
C#
Overview and Basic syntax
Overview
C# is a programming language developed by
Microsoft to be used with the .NET
framework. The language is based on the
Object-Oriented programming approach and
has the same basic syntax as in the other

modern programming languages such as C
and C++. C# is developed for Common
Language Infrastructure (CLI) which is
comprised of runtime environment and
executable code. Being easy to learn, C# is
one of the best suited programming languages
for beginners as they can produce efficient
programs and compile on different computer
platforms as well.
In order to run C# applications and programs,
a .NET Framework is required which can be
used to write code for windows applications,
web applications, and web services as well.
The Integrated Development Environment
(IDE) for C# includes Visual Studio, Visual
Web Developer, and Visual C# Express.
Basic Syntax
Based on the object-oriented programming
approach, C# programming is all about
classes and objects. Taking the example of a
student class, it has attributes such as student
name, student ID, class, and grade. Although
the attributes of each student are the same,
each of them has different name, student ID,

class, and grade which are known as object
properties. Generally, a C# program is
comprised of Namespace declaration, Class,
Class methods, attributes, Main method, and
Statements.
Here is a simple program to print “Welcome
to C# programming” in C#:
using System:
 namespace CSharp programming
{
   class Programming
{   
       // Main function
       static void Main(string[] args)
       {
           Console.WriteLine("Welcome to C# programming);
           Console.ReadKey();
       }
   }
}
Details for basic syntax:
Using System: Used to include
System namespace for the program.

Namespace declaration: Collection
of classes within the program.
Class declaration: The class which
contains data and methods to be used
in the program.
Static void Main(): The keyword
static shows that this method can also
be 
accessed 
without 
instantiating
class.
Console.WriteLine(): Method used to
define system namespace.
Console.Readkey(): 
Makes 
the
computer wait for the next command
and also stops the screen from turning
off.
Datatypes and Variables
Data Types are an essential part of any
programming language as they specify the
type of data that is supported in the language.
As they are predefined in C#, datatypes are
separated into three major categories known
as Value data types, Reference data types,
and Pointer data type.

1. Value datatype
The value data type variables are derived
from System.ValueType class and they
contain data in the form of alphabets and
numbers.
Following table shows the value types that
are used in C# programing language:
Data
type
Representation
Default
Value
Range
Byte
8-bit unsigned
integer
0
0 to 255
Decimal
128-bit precise
decimal values
0.0M
(-7.9 x 1
100 to 28
Bool
Boolean value
False
True/Fal
Float
32-bit 
single
floating-point
type
0.0M
-3.4 x 10
Double
0.0D
(+/-)5.0 
10308
Char
16-bit Unicode ‘\0’
U +0000

Character
Int
32-bit 
signed
integer type
0
-2,147,4
2,147,48
Short
16-bit 
signed
integer type
0
-32,768 t
Long
64-bit 
signed
integer type
0L
-9,223,3
to
9,223,37
2. Reference Type
The reference data type stores the reference
to a variable instead of storing the actual data.
By using multiple variables, reference types
can point to a memory location and in case
the memory location is changed by one of the
variables, 
the 
other 
variable 
will
automatically change its value.
3. Object type
Object data type is considered as the base
class for all data types that are used in C#.
Moreover, object types can also be assigned
values of other types, reference types, user
defined types, and value types as well.

4. Pointer data type
Pointer data type contains memory address of
the variable value and has the syntax as
follows:
Type* identifier;
Operators
C# makes use of operators in the same way as
the other major programming languages such
as C and C++. The set of built-in operators
include Arithmetic operators, Relational
operators, 
Bitwise 
operators, 
Logical
operators, Misc operators, and Assignment
operators.
Functions and Methods
In C# programming language, a function
allows the programmers to encapsulate a
specific part of the code and utilize it from
other sections of the code as well. As it stops
the need to rewrite the code, we can access a
function from multiple places and perform
the required operations as well. The functions

in C# are declared by using the following
syntax:
<visibility> 
<return 
type> 
<name>
(<parameters>)
{
<function code>
}
A function that is known as a member
function or a member of a class is also known
as a method in C# programming language.
Generally, there are two methods in C# called
an instance method and a static method.
Functions can return any type of data and
there can be multiple statements executed
such as read, follow, and run.
Sample program by using functions in C#:
using System;
class Return2
{
  static string lastFirst(string firstName, string lastName)
  {
 
string separator = ", ";
 
string result = lastName + separator + firstName;

 
return result;
  }
static void Main()
{
       Console.WriteLine(lastFirst("John", "William"));
       Console.WriteLine(lastFirst("James", "Lewis"));
}
}
Arrays, 
Strings, 
and
Structures
Arrays
An array is used to store a fixed size
collection of elements with the same
datatype. 
Having 
contiguous 
memory
locations, an array can be declared in C#
programming 
language 
by 
using 
the
following syntax:
Datatype[] arrayName;
Initialization:
Int [] age = new age[20]

Sample program to declare and access arrays
in C# programming language:
using System;
namespace ArrayApplication {
  class MyArray {
 
static void Main(string[] args) {
    
int []  n = new int[20]; /* n is an array of 20
integers */
    
int i,j;
    
/* initialize elements of array n */
    
for ( i = 0; i < 20; i++ ) {
       
n[ i ] = i + 100;
    
}
    
/* output each array element's value */
 
   for (j = 0; j < 10; j++ ) {
           Console.WriteLine("Element[{0}] = {1}", j, n[j]);
 
   }
        Console.ReadKey();
 
}
  }
}
Strings
We can create strings in C# programming by

using the keyword System.String. To create a
string 
object, 
we 
can 
adopt 
different
approaches such as assigning a string literal
to a string variable, using the concatenation
operator (+), calling a formatting method to
convert a value, or by using a String class
constructor.
Syntax:
String [ ] sarray={“This”, “Is”, “C#”,
“Programming”};
Classes and Objects
Class is defined as a representation of a type
of object and blueprint for a data type. In C#
programming, the class definition starts with
the keyword class, class name, and class
body. The access specifiers in classes allow
access rules for the members whereas the
default access specifier for a class in C#
program is known as internal. In order to
access class members, we can use the (.)
operator. It also links the name of an object
along with the name of a member.
A class is also considered a reference type

and the variable contains null value after
declaration until we create an instance of the
class by using the new operator. To declare
the class in C#, we can follow the syntax
mentioned below:
Public class Student
{
//properties, methods and structure
}
Sample:
MyClass student = new MyClass();
MyClass student2 = student;
Class including different data members and member
functions
public class Student
{
public int id = 0;
public string name = string.Empty;
 public Student()
{
   
// Constructor Statements
}

public void GetStudentDetails(int uid, string
uname)
{
   
id = uid;
   
uname = name;
   
Console.WriteLine("Id: {0}, Name: {1}", id,
name);
}
   public int Designation { get; set; }
public string Location { get; set; }
}
Creating an Object
In C# programming, an object is entirely
based on class. A class defines a type of
object. It is also known as an instance of a
class and can be created by using the

following syntax:
Student Object1 = new Student();
Once the instance of a class has been created,
the 
object 
reference 
is 
passed 
back
automatically. For example:
Student object2 = new Student();
Student object3 = object2;
The following program shows how an object
is created in C# programming language:
1. using System;
2. 
3. namespace Tutlane
4. {
5. class Program
6. {
7. static void Main(string[] args)
8. {
9. Users user = new Users("Harry Potter", 20);
10. 
         user.GetUserDetails();
11. 
             Console.WriteLine("Press Enter Key to
Exit..");
12. 
             Console.ReadLine();
13. 
      }
14. 
  }

15. 
  public class Users
16. 
  {
17. 
      public string Name { get; set; }
18. 
      public int Age { get; set; }
19. 
      public Users(string name, int age)
20. 
      {
21. 
          Name = name;
22. 
          Age = age;
23. 
      }
24. 
      public void GetUserDetails()
25. 
      {
26. 
             Console.WriteLine("Name: {0}, Age:
{1}", Name, Age);
27. 
      }
28. 
  }
29. 
 }
Inheritance 
and
Polymorphism
Inheritance
Inheritance is a major part of C# as it is an
object-oriented 
programming 
language.
Allowing the programmers to reuse different

classes that require the same functionality,
inheritance works in the same method to that
of a parent and child. Parent is considered as
the base class whereas child is known as the
derived class which inherits all of the
functionality from its parent class.
Syntax:
<access-specifier> class <base_class> {
...
}
class <derived_class> : <base_class> {
...
}
For multilevel inheritance:
public class A
{
// Implementation
}
public class B : A
{
// Implementation
}
public class C : B
{
// Implementation

}
Polymorphism
Polymorphism refers to the technique where
multiple functionality is performed through a
single operation. Static polymorphism is
performed at compile time whereas the
dynamic polymorphism is decided at the run
time.
In 
static 
polymorphism, 
C# 
allows
programmers to implement the following two
approaches:
Function Overloading
Function 
overloading 
provides 
multiple
definitions for the same function name in the
given scope. Moreover, function definition
should differ from each other by types so that
you do not overload function declarations that
have a different return type.
Constructors
In C# programming, a constructor is

automatically called whenever a struct or
class is created. As a class can have multiple
constructors to handle different arguments,
constructors allow the programmers to set
limit instantiation and default values as well.
Syntax for creating constructors:
public class Person
{
  private string last;
  private string first;
 
public Person(string lastName, string firstName)
  {
 
last = lastName;
 
first = firstName;
  }
// Remaining implementation of Person class.
}
The three types of constructors used in C#
programming 
are 
known 
as 
Instance
constructors, Static constructors, and Private
constructors.
Exception Handling
Exceptions are how to transfer control from

one segment of the program to another.
Generally, an exception is considered a
problem that is seen during the execution of a
program. To cater the circumstance, C# gives
multiple 
exception 
handling 
approaches
known as try, catch, throw, and finally.
A try block outlines a block of code for
which the exception is being used whereas
the catch exception allows the programmer to
handle the problem from anywhere in the
program. Throw exception is launched
whenever a problem is faced whereas the
finally exception is used to execute a
provided set of statements.
Syntax for using exception handling in C#
programming language:
public class Person
private string last
private string first;
public Person(string lastName, string firstName)
{
last = lastName;
first = firstName;
}
// Remaining implementation of Person class.
}

Multithreading
In C# programming language, a thread is
considered the execution path for a program
as it defines a specific flow control and is
responsible for defining execution paths as
well. As they are lightweight processes, a
thread can save wastage of CPU cycle and in
return boost efficiency of the program.
There are four main states in the lifecycle of a
thread which include Unstarted State, Ready
State, Not Runnable State, and Dead State.
Threads can be created, managed, and
destroyed by implementing specific C#
methods.
File I/O
C# provides different classes to operate with
the File system and data handling. As these
classes can be used to open files, access files,
access directories, and update existing files,
C# includes a specific File class to perform
all of the I/O operations.
The class names with details are briefed as

follows:
File
File is a static class which provides different
operations including move, delete, create,
open, copy, read, and write.
FileInfo
The FileInfo class performs the same as the
static File class and programmers can read
and write operations by writing the code
manually for a specific file.
Directory
The Directory class is also static and provides
support for creating, deleting, accessing, and
moving subdirectories within a file.
DirectoryInfo
The DirectoryInfo class provides different
instance methods for accessing, deleting,
moving, and creating subdirectories.
Path
The Path static class delivers functionality for
changing the extension of a file, retrieving

extension of a file, and retrieving the absolute
physical path of a specific file.
FileStream Class
The FileStream class in the System,IO
namespace is used to create, write, and close
a specific file through C# programming
language. Syntax for creating a FileStream
class and object is defined as follows:
FileStream 
<object_name> 
= 
new
FileStream( 
<file_name>, 
<FileMode
Enumerator>,
<FileAccess 
Enumerator>, 
<FileShare
Enumerator>);
Advanced file operations in C# include:
·         Reading and Writing into Text Files.
·         Reading and Writing into Binary Files.
·         Manipulating the Windows File System.
Remember that System.IO.Stream is an
abstract class which provides all of the
standard methods required to transfer bytes to
the source. Classes which inherit Stream class
to perform certain read/write operations
include 
FileStream, 
MemoryStream,
BufferedStream, 
NetworkStream,

PipeStream, and CryptoStream.
Advantages of learning C#
C# programming language delivers fast
execution time and provides a structured
approach to solve a specific problem. With
the availability of advanced functions and
built-in 
libraries, 
beginners 
can 
build
different types of applications and programs
without any hassle. As C# is an object-
oriented 
programming 
language, 
the
development and maintenance are simpler
compared to other high-level programming
languages.
Moreover, C# is best suited for creating
robust 
applications 
with 
proper
interoperability. 
To 
start 
with 
C#
programming, learning the basic syntax,
methods 
and 
structures 
is 
immensely
important so that you can develop particular
applications without any hassle. C# language
features built in libraries and functions which
can be used by programmers to make their
development fast and responsive.

CHAPTER SEVEN
PYTHON
Overview and Basic syntax
Python is a renowned programming language
which was developed by Guido van Rossum
in 1991. Being a high level, object oriented,
and interactive scripting language, Python
can be used for system scripting, software
development, 
and 
server 
side 
web
development.

Features
Being an interpreted based language, Python
allows execution of one instruction at a time
and supports extensive number of data types
as well. The programming language is easy to
learn and code because it has few keywords
and a clearly defined syntax. With the
availability of a broad standard library,
Python 
also 
provides 
support 
for 
an
interactive mode which makes it easier for
the developers to test and debug code.
Moreover, the language can be used for GUI
programming and to develop applications that
feature system calls, windows systems, and
libraries. Along with these features, Python
also supports automatic garbage collection
and delivers high-level dynamic data types
and can be integrated with C++, C, Java, and
CORBA. Users can interact with python
interpreter directly to write programs as it
provides low-level modules as well.
Python needs to be installed on your PC and
the source code can be downloaded under the
GNU 
General 
Public 
License 
(GPL).
Different GUI based Python Integrated

Development Environments (IDEs) include
PyCharm, The Python Bundle, Python IDLE,
and Sublime Text. The up to date and current
binaries, 
source 
code, 
news, 
and
documentation can be found at the official
website of Python: https://www.python.org
Variable 
Types, 
Basic
Operators, and Data Types
Variable types
In Python programming, variables are not
required to be declared for reserving a
memory location because the declaration
automatically happens whenever a value is
assigned to the variable. Depending on the
data type of the variable, the interpreter
allocates memory and allow the programmer
to store decimals, characters, or integers.
Below is the syntax for assigning values to
variables in Python programming language:
#!/usr/bin/python
ID = 100      
# An integer assignment

Weight   = 100.0   
# A floating point
name= "William"   
# A string
print ID
print weight
print name
Reserved keywords list for Python:
Del
Else
And
Assert
In
R
From
Continue
If
Finally
Not
P
As
Return
Not
Pass
Yield
B
Except
Import
For
Global
While
p
With
Try
Exec
Or
Is
E
Basic Operators
Python has built in operators such as
Arithmetic operators, Assignment operators,
Logical 
operators, 
Bitwise 
operators,
Comparison operators, and Membership
operators.

The details for Python operators are briefed
in the following table:
Arithmetic
operators
Assignment
Operators
Comparison
Operators
L
O
Addition (+)
Equal (=)
Double
Equal (==)
L
O
o
Subtraction (-) Add 
AND
(+=)
Not Equal to
(<>)
L
A
a
Multiplication
(*)
Subtract
AND (-=)
Greater
Than (>)
L
N
n
Division (/)
Multiply
AND (*=)
Less Than
(<)
Modulus %
Division
AND (/=)
Less 
Than
Equal 
To
(<=)
Floor Division
(//)
Modulus
AND (%=)
Greater
Than Equal

To (>=)
Exponent (**)
Floor
Division
AND (//=)
Data Types
In Python programming language, every
object has its own type and value.
Built in data types for Python:
Numbers include integers, floats,
fractions, and complex numbers as
well. The predefined data types in
Python are int, float, long, and
complex.
Sequences are comprised of strings,
bytes, lists, and tuples.
Boolean holds either true or false.
Dictionaries include key paired values
that are set in an unordered way.
Sets cover unordered container of
values.

Flow Control
Control 
flow 
statements 
allow 
the
programmers to change the flow of program
and perform specific operations as well.
Same as the other high-level programming
languages, the three major control flow
statements used in Python are If, For, and
While. The following diagram shows how the
control flow statements actually work in a
program:
Conditional Statements
If statement
The If statement is a Boolean expression
which shows the result in the form of either
TRUE or FALSE.
If else statement
The If else statement is also a Boolean
expression and it includes an optional else
statement. If the expression shows up as
False, the else statement gets executed.
Nested Statements

A statement within a statement is known as
Nested statement.
Loops
Loops are known as a sequence of
instructions that allow the programmer to
perform specific tasks by implementing
certain conditions. In Python programming,
Loops can be used to execute several
statements or a set of instructions by using
the given control structures.
Types of Loops in Python:
While Loop
While loop is used to repeat a statement or
iteration ‘n’ number of times within the
program. Syntax for using While loop in
Python is:
While expression:
Statement (s)
Sample program:
#!/usr/bin/python
count = 0
while (count < 10):

print 'The count is:', count
count = count + 2
Output:
For Loop
In order to iterate items of any sequence
including a string or list, we can use For
Loop.
Syntax:
For iterating_var in sequence:
Statement(s)
Sample program:
fruits = ["apple", "banana", "cherry"]
for x in fruits:
print(x)
To stop the loop before it has iterated through
all items, we can use the Break statement

whereas the Continue statement can be used
to stop iteration of loop and continue with the
next iteration.
Functions and Modules
What are Functions?
A function is a set of reusable and organized
code that is used to perform specific tasks and
operations within the program. Although
there are several built-in functions available
in 
Python 
programming 
language, 
but
developers can also create their own
functions which are also known as user
defined functions. The syntax for defining a
function in Python is described as follows:
def functionname( parameters ):
"function_docstring"
function_suite
return [expression]
To introduce a function definition, we can use
the keyword ‘def’ which is then continued
with the statements needed for the function
body. The variables that are assigned to a

function generally store their value in the
local symbol table which means the global
variables cannot be assigned any value within
a function unless it is declared as the global
statement.
Calling Functions
Functions in Python programming language
can be called by giving all arguments,
providing an optional argument, or giving the
mandatory argument only. Python functions
maximize 
code 
reusability 
and 
make
programs easier to read and understand.
Following are the statements that are used to
define and use functions in Python:
def : def display(message):
print ('Hi' +  message)
·         Call Expression: myfun ('karl', 'os',
*rest)
·         global : x = 'hello'
def printer():
global x; x='hi'
·         yield : def sq(k)
for I in range(k): yield i**2
·         return : def sum(a, b=2)

return a+b
·         nonlocal : def outer():
a = 'old'
def inner():
nonlocal a; a = 'new'
Modules
Modular programming is the approach to
organize different components or sections of
a program into a system. Making it easier to
understand and implement the code, the
approach binds data and allows programmers
to use it as a reference. In Python, modules
allow programmers to savea source code in
files and rerun them multiple times as they
function as natural programming tools.
There is a huge collection of standard library
modules in Python programming language
which contain more than two hundred
modules. 
Moreover, 
they 
also 
provide
platform-independent support to perform
several programming tasks such as object
persistence, text pattern matching, and
internet scripting as well.
Syntax for import statement in Python:
Import module_name1 [, module_name2

[module_nameN]]
The runtime operational statements to use
‘import’ module are:
1.       Find
2.      Compile
To use the module named as newmodule, we
can call the function as:
Import newmodule
Newmodule.functionname (“Name”)
To import from module in Python, the syntax
is:
def newmodule(name):
 print("Hello, " + name)
person1 = {
 "name": "James",
 "age": 30,
 "country": "Sweden"
}
Object Oriented Python
In object-oriented programming, we are
required to define classes and objects to
perform 
various 
functions 
within 
the
program. Like other major programming

languages such as C++ and C, we can create,
access, and update classes by using the
object-oriented techniques.
To create a student class in Python, the code
is written as follows:
class student:
def __init__(ID, name, class):
self.r = roll
self.n = name
print ((self.n))
# ...  
stud1 = student(1, "James")
stud2 = student(2, "William")
print ("Data successfully stored in variables")
For accessing the object’s variable, dot
operator (.) is used for which the syntax is:
My object_name.variable_name
Inheritance
Inheritance is a useful feature of Object-
Oriented 
Programming 
which 
allows
developers to create a new class to inherit all
of the methods and properties of an existing
class. We can define a new child class or
derived class with the properties of a parent
class or base class by using inheritance
techniques.

The syntax for implementing Inheritance in
Python is defined as follows:
Class BaseClass1
#Body of Base Class
Class DerivedClass(BasaClass1):
#body of derived class
The following program shows Vehicle as a
parent class along with a derived class which
will inherit features of parent class Vehicle
and invoke its functions as well.
class Vehicle:   #parent class
 "Parent Class"
 def __init__(self, price):
self.price = price
 def display(self):
print ('Price = $',self.price)
class Category(Vehicle):   #derived class
  "Child/Derived class"
  def __init__(self, price, name):
Vehicle.__init__(self, price)
self.name = name
  def disp_name(self):
print ('Vehicle = ',self.name)

obj = Category(2000, 'Mercedes')
obj.disp_name()
obj.display()
Output:
Vehicle = Mercedes
Price = $2000
To override any method in the base class, we
can define a new method along with the same
name and parameters in the derived class.
The syntax is as follows:
class A:   #parent class
 "Parent Class"
 def display(self):
print ('This is base class.')
class B(A):   #derived class
  "Child/Derived class"
  def display(self):
print ('This is derived class.')
obj = B()
obj.display()
Regular Expressions
In python programming, regular expressions

are used to extract information from text
including documents, log files, spreadsheets,
or code. Regular expressions are known as
characters in special order that allow
programmers to find relevant sequence or
characters or set of strings by using a
specialized 
syntax. 
Whenever 
regular
expressions 
are 
written 
in 
Python
programming language, we are supposed to
begin raw strings with prefix ‘r’ and other
special meta characters as well.
Match Function
The match() function is used to check
whether the given regular expression matches
a string in Python or not. In case the pattern
does not match, we can use the re.match()
function.
Search Function
This function attempts to search for all of the
possible starting points within the string and
scans through the input string to match any
location. It includes the search() or re.search()
functions.
Split Function
The split function can be applied directly on a
string whereas the re.split() accepts a pattern

which specifies the delimiter.
File I/O
File is a specific location on a disk which is
used to store information and data. As it is
stored in a hard disk, we can also perform
read and write operations by implementing
python 
programming 
methods 
and
techniques. File operation in Python consists
of three major aspects which are open a file,
read or write, and close the file.
Open() is the built-in function in Python
programming language which has two
parameters known as filename and mode. The
following methods can be implemented to
perform different operations in a file:
“r” = Open or read a file.
“w” = Write into a file and create a
new file if it does not exist.
“a” = Open the file for appending and
create a new file if it does not exist.
“x” = Create a new file and return an
error if file is already present.
“t” = Open in text mode.

“b” = Open in binary mode.
“+” = Open file for reading or writing
purpose.
Syntax for implementing these methods:
f = open(“sample.txt”)
f = open(img.jpg, “r”)
To close a file, we can use the f.close()
function.
Reading files in Python
Reading a specific file through Python
programming language is simple for which
we can implement the read(size) method. For
example:
>>> f = open("Sample.txt",'r')
>>> f.read(4)
# read the first 4 data
'This'
>>> f.read(4)
# read the next 4 data
' is '
>>> f.read() 
# read in the rest till end of
file
'my first file\nThis file\ncontains four lines\n'
>>> f.read()
Opening a file on server

To open the file by using the built in open()
function, we can use the following syntax:
f = open(“Samplefile.txt”, “r”)
print)f.read())
For reading a specific line, we can implement
the readline() function:
f = open(“Samplefile.txt”, “r”)
print)f.readline())
Writing into an existing file
The following Python programming syntax
will open the sample file and append content
as well:
f = open("Samplefile.txt", "a")
f.write("Update your content")
f.close()
#open and read the file after the appending:
f = open("Samplefile.txt", "r")
print(f.read())
Creating a file
To create a new file, open() method will be
used which can have Create, Append, or
Write parameters. The syntax for creating a
file in Python is defined as follows:

f = open(“Newfile.txt”, “w”)
Delete a File
To delete an existing file, os.remove()
function should be used with the following
syntax:
import os
os.remove(“Samplefile.txt”)
Syntax to check whether a file exists or not. If
yes, then delete it:
import os
if os.path.exists("Samplefile.txt"):
os.remove("Samplefile.txt")
else:
print("The file does not exist")
Advanced Python
Exception Handling
There are three main methods of exception
handling in Python programming language.
Try, Except, and Finally blocks are used to
handle errors that occur during program
execution.
Try

To generate an exception through try block,
the following syntax can be implemented:
try:
print(x)
except:
print(“An exception occurred”)
If no errors were raised, the sample code is as
follows:
try:
print(“Python”)
except:
print(“An exception occurred”)
else:
print(“No exception occurred”)
Finally
In exception handling, the finally block will
be executed even if the try block has raised
an exception or not. For example:
try:
print(“Python”)
except:
print(“An exception occurred”)
finally:
print(“try exception finished”)

User defined exceptions
Although there are several built-in exceptions
in Python programming language that can be
used to force the program to show an error
when something is wrong, developers can
also create custom exceptions to fulfill their
requirements. To create a new exception, a
new class must be created from Exception
class.
User-defined exceptions can be implemented
in the same way as a normal class because
most of the built-in exceptions are derived
from Exception class.
Tips for Learning Python
Python 
Programming 
language 
is 
best
suitable for programmers who are having
interest in Artificial Intelligence, Machine
Learning, Robotics, or App development.
Before starting with programming itself, it is
compulsory that you are well aware of the
basic Python syntax. Learning the methods,
approaches, and syntax will make it easier for
beginners to start coding and developing any

kind of application on their own.
For beginners, taking small coding exercises
are really beneficial. They can develop sharp
problem-solving skills and utilize their
programming concepts as well. Moreover,
Python programs or applications can also be
contributed to open source from where
beginners can get comments and suggestions
regarding their work.
I have also written a book on Python. Python
for Absolute Beginners  will help you
achieve a solid foundation in Python
programming.

CHAPTER EIGHT
HTML
Introduction and Overview
Hyper Text Markup Language (HTML) is a
standard markup language used to create
websites to display colors, fonts, displays
graphics, media, and images. HTML is
comprised of different tags that can be used
to describe the structure of a web page and
tell the browser to display the content over

the internet.
What are Tags?
Tags give instructions to web browsers
regarding the structure, display, and content
of any web page. As they are defined through
enclosed angle brackets: <>, tags are
comprised of attributes and elements. An
element is an object on a page whereas an
attribute describes the quality or details of
that element. Remember that tags are to be
used in pairs and opening tag <tag> and
closing tags are differentiated by </tag>.
Your first sample HTML web page be
created by using the following tags:
<html>
<head>
<body>
<h1>My First Heading</h1>
<p>My first paragraph</p>
</body>
</html>
Description of Tags
In the above-written HTML document, the

<html> tag encloses the complete HTML
document and is comprised of other major
tags including <head>, <body>, and <p>. The
<head> tag represents the file’s head whereas
the <title> tag is used to show the document’s
header. <body> includes several other tags
that are to be used to create a web page such
as heading <h1> and paragraph <p>.
HTML Tags are not case sensitive but they
should be used in lower case. To define the
version of HTML, we can use the following
tag:
<!DOCTYPE html>
Beginners can run HTML pages by using
Notepad PC and save the file in .html format.
This will allow them to view the webpages in
a browser.
Basic Tags and Attributes
Basic Tags
Each HTML document is supposed to start
with a title, heading, and paragraph. After the
<body> tag, the next major tag to be used is

<h1> or heading tag. depending on your
content requirements, heading tags are
defined with <h1> to <h6>. For example:
Headings:
<html>
<body>
<h1> First heading </h1>
<h2> Second heading </h2>
<h3> Third heading </h3>
<h4> Fourth heading </h4>
<h5> Fifth heading </h5>
<h6> Sixth heading </h6>
</body>
</html>
Output:
Paragraph
For adding content, we need to include

paragraphs in the HTML document. For
example:
<html>
<head>
<h1> heading </h1>
</head>
<body>
<p> First Paragraph </p>
<p> Second Paragraph </p>
</body>
</html>
Output:
heading
First Paragraph
Second Paragraph
To add break between a paragraph, we can
use the line break tag <br>.
Summary Tag
To add summary for the paragraph, the
HTML syntax with Summary tag is defined
as follows:
<details>
<summary>Sample Text</summary>

<p> Web development tutorials</p>
</details>
Span
Span tag is used to color specific part of a
text. For example:
<p> 
Web 
development 
is 
<span
style=”color:red”> interesting </span> to
learn </p>
Select
The select tag is used for selecting one option
from a drop down list. For example:
<select>
<option value="Red">Red</option>
<option value="Blue">Blue</option>
<option value="Green">Green</option>
<option value="White">White</option>
</select>
Thead
The thead tag is used to create a group header
content and is used along with <tbody> and
<tfoot> elements. For example:
<table>
 <thead>
<tr>

 
<th>Course</th>
 
<th>Max Marks</th>
</tr>
 </thead>
 <tbody>
<tr>
 
<td>Web Engineering</td>
 
<td>85</td>
</tr>
<tr>
 
<td>English</td>
 
<td>90</td>
</tr>
 </tbody>
 <tfoot>
<tr>
 
<td>Sum</td>
 
<td>$180</td>
</tr>
 </tfoot>
</table>

Formatting Tags
Texts within an html document can be
formatted to different styles, fonts, and sizes.
The tags to format text, headings, paragraphs,
and tables are as follows:
Bold
Any text that is written between the <b> and
</b> tags is displayed in bold style. For
example:
<p>  <b> Web development </b> is
interesting </p>
Output: Web development is interesting
Italic
Any text that is written between <i> and </i>
is displayed in italic style. For example:
<p> <i> Web development is interesting </i>
</p>
Output: Web development is interesting
Superscript/Subscript
To display content in superscript, we can use
<sup>…</sup> tags whereas <sub> and
</sub> tags are used for adding subscripts.

For example:
<p> This text uses a <sup> superscript
</sup> </p>
Output: The following word uses a superscript
Underline:
Text written between <u> and </u> tag is
underlined
<p> <u> Sample text </u> </p>
Output: Sample text
Insert and Delete tags
To insert, the <ins> and </ins> tags are used,
whereas to delete any text, we can use <del>
and </del> tags.
Link
To add a link within the text, we can use the
following tag:
<p> <a href = “document location”> </a>
</p>
Marquee Tag
<marquee> tag can be used with different
attributes including width, height, direction,
behavior, scrollamount, scrolldelay, loop,

bgcolor, hspace, and vspace.
Demonstration of marquee tag:
<html>
<head>
<title>HTML marquee Tag</title>
</head>
<body>
<marquee>Sample text</marquee>
</body>
</html>
Container Tags
In HTML, the following container tags are
used to format the text:
Opening
Tag
Closing
Tag
Functionality
<p>
</p>
Paragraph
<span>
</span>
To add inline content
within a paragraph
<em>
</em>
Used to give text
emphasis

<ol>
</ol>
Ordered
list(numbers)
<ul>
</ul>
Unordered 
list
(bullets)
<li>
</li>
List item
Tables, Images, and Frames
Tables
Tables are an essential part of any website as
they help us to illustrate and elaborate key
information in a suitable manner. In HTML,
there are predefined tags that can be used to
create and design tables.
Tags for Creating Tables in HTML
To create a table, we can use the following
tag:
<table>…..</table>
Table Rows
Tag for creating table rows:
<tr>…</td>

Table Height
<th>… </th>. The sample attribute for
creating a table to display data is scope =
“row” and “column” as they define whether
the given tag is for row header or column
header.
Table data cell
<td>…</td>. The attributes for table data cell
are colspan = “number” and rowspan =
“number” for which we need to use the tag
along with <th> or <td> elements to span
cells across multiple rows and columns.
Images
Images are an essential part of any website.
As they help us to illustrate the concepts,
services, and information in a better way, it is
quite simple to insert and manage images in
HTML.
Tag for inserting image:
<img src = “Image URL” ../>
<img src = “desktop/images/image1.png” alt
= “Sample Image” />
To set a specific height and width of an
image, the following syntax can be used:

<img src = “desktop/images/image1.png” alt
= “Sample Image” width = “100” height =
“100” />
Videos
To add videos in an HTML web page,
<video> tag can be used with the following
syntax:
<video>
<sourse 
src= 
“Samplevideo.mp4”
type= “video/mp4”> </video>
Alignment and Border
There are three positions to align an image on
a webpage known as Center, Right, and Left.
For this, we can use the align attribute. For
example:
<img src = “desktop/images/image1.png” alt
= “Sample Image” align = “center”/>
For creating image border, the attribute is
border. For example:
<img src = “desktop/images/image1.png” alt
= “Sample Image” border = “4”/>
Frames
In HyperText Markup Language, frames are

added to create multiple sections in the
browser window so that each section can be
loaded with a unique HTML document. To
use frames in a web page, <frameset> tag
should be used instead of <body> tag which
can then be defined with specific rows and
cols attributes.
Sample HTML tags for creating frames:
<html>
<head>
<title>HTML Frames</title>
</head>
<frameset rows = "10%,80%,10%">
<frame 
name 
= 
"top" 
src 
=
"/html/top_frame.htm" />
 <frame name = "main" src =
"/html/main_frame.htm" />
<frame name = "bottom" src =
"/html/bottom_frame.htm" />
<noframes>
<body>Your browser does not support
frames.</body>
</noframes>

</frameset>
</html>
iFrame
To create a nested browsing context, iFrame
tag can be used to add a new HTML
document into an existing one. To create an
iFrame, 
the 
following 
syntax 
can 
be
implemented along with the <iframe> tag:
<iframe 
src=
https://www.samplewebsite.com></iframe>
Complete table of basic HTML tags:
<a>
<abbr>
<acronym>
<address>
<area>
<article>
<aside>
<audio>
<base>
<basefont>
<bdi>
<bdo>
<blockquote>
<body>
<br>
<button>
<caption>
<center>
<cite>
<code>
<colgroup>
<data>
<datalist>
<dd>
<details>
<dfn>
<dialog>
<dir>
<dl>
<dt>
<em>
<embed>
<figcaption>
<figure>
<font>
<footer>

<frame>
<frameset>
<h1> - <h6> <head>
<hr>
<html>
<i>
<iframe>
<input>
<ins>
<kbd>
<label>
<li>
<link>
<main>
<map>
<meta>
<meter>
<nav>
<noframes>
<object>
<ol>
<optgroup>
<option>
<p>
<param>
<picture>
<pre>
<q>
<rp>
<rt>
<ruby>
<samp>
<script>
<section>
<select>
<source>
<span>
<strong>
<sub>
<summary>
<sup>
<svg>
<tbody>
<td>
<template>
<textarea>
<th>
<thead>
<time>
<title>
<track>
<tt>
<u>
<ul>
<video>
<wbr>
Forms
HTML forms are one of the key aspects of
interaction between a website and a user. A

form is created by using widgets such as text
fields, buttons, select boxes, radio buttons,
file select boxes, hidden controls, and
clickable controls. Data collected through
forms is sent to the web server and the web
page can also intercept the data on its own.
Most of the times, widgets are linked with a
label in order to describe their purpose.
Syntax for creating a form in HTML:
<form action = "Script URL" method =
"GET|POST">
form elements like input, buttons etc.
</form>
Input form to take Name and Age from user:
<html>
<head>
<title>My first HTML form</title>
</head>
<body>
<form >
Name: <input type = "text" name =
"Name" />
<br>
Age: <input type = "text" name = "last
name" />

</form>
</body>
</html>
Output:
Text Fields
Text fields in HTML allow users to input text
into the form. The general syntax for creating
text fields is defined as follows:
<input type = “text” type = “text” value =
“text”>
Button controls
There are different ways to submit data into
forms. We can add clickable buttons by using
the following HTML tags:
<input type = "submit" name = "submit"
value = "Submit" />
<input type = "reset" name = “reset” value =
"Reset" />
<input type = "button" name = "button" value
= "button" />

Output:
Select box
To create a dropdown list in HTML forms,
we can use the <select> and <option>
element.
For example:
<html>
<head>
<title>File Upload Box</title>
</head>
<body>
<form>
<label for="Course">Course:
</label>
<select name="Course"
id="course">
<option value="Web
Engineering">Web Engineering</option>
<option
value="Calculus">Calculus</option>
<option value="Data Science">Data
Science</option>

</select>
</form>
</body>
</html>
Output:
Select Box
The Select Box element gives an option to list
down multiple options in HTML form.
For example:
<html>
<head>
<title>Select your course</title>
</head>
<body>
<form>
<select name = "dropdown">
<option 
value 
= 
"Math"
selected>Math</option>
<option 
value 
=

"Physics">Physics</option>
</select>
</form>
</body>
</html>
Output:  
Form Element
Once the HTML form has been completed,
the two attributes Action and Method are
required to store and send form data. Action
contains the address which defines where the
form data will be sent whereas Method can
either be GET or POST as it defines how to
handle form information. The syntax for
creating Form element is defined as follows:
<form action = “/login” method = “POST”>
Designing
In HTML, the default background color for
any webpage is white. To change the

background color, the following tags and
attributes can be used:
<tagname bgcolor = “color value/color
name”>
For example:
<table bgcolor = “green”>
<table bgcolor = “#f1f1f1”>
Fonts
Fonts are an essential part of any website and
enhance the readability of your content. The
<font> tag can be used to give a specific
style, size, and color to the text and its
attributes include size, color, and face.
To set the font size, the tags and attributes
are:
<font size = “14”> Text </font>
Font face tags and attributes:
<font face = “Times New Roman” size =
“14”> Text </font>
Font color
To change the font color, the following
HTML tags and attributes can be used:
<html>

<head>
<title>Setting Font Color</title>
</head>
<body>
<font color = "Blue">This text is
blue</font>
</body>
</html>
Output: This text is blue
Marked text
The text written between <mark> and
</mark> elements is displayed as marked
with yellow.
For example:
<p> This text is marked as <mark> Yellow
</mark> </p>
Output: This text is marked as Yellow.
Meta Tags
In HTML, meta tags can be used to add
metadata into your web pages. The attributes
of meta tags include Name, Content, Scheme,
and http-equiv. We can use <meta> tag to

give a short description about the document
which can also improve search engine
indexing for your web page.
For example:
<html>
<head>
<title>Meta Tags Example</title>
<meta name = "keywords" content =
"HTML, Meta Tags, Metadata" />
<meta name = "description" content =
"Meta Tags." />
<meta name = "revised" content =
"3/7/2019" />
<meta http-equiv = "cookie" content =
"userid = abc;
expires 
= 
Monday, 
08-Sep-19
23:59:59 GMT;" />
</head>
<body>
<p>Welcome to HTML</p>
</body>
</html>

Comments
To place comments in HTML code, the
following syntax can be followed:
<html>
<head>  <!-- Document Header Starts -->
<title>Document title</title>
</head> <!-- Document Header Ends -->
<body>
<p>Document content goes here.....</p>
</body>
</html>
HTML Style Sheets
For further design of HTML documents,
Cascading 
Style 
Sheets 
(CSS) 
are
implemented over the website. They provide
easy, effective, and manageable alternatives
to specify certain attributes for a website. We
will be discussing CSS in full detail in the
next chapter.
Layout and Responsiveness
HTML includes various types of semantic

elements that are used to define different
parts of a web page. These elements include
Header, Container, Section, Article, Aside,
Details, and Footer. Although CSS is the best
approach to design layout of a web page, we
can also complete the procedure through
these HTML elements.
A responsive web design is created by using
HTML 
and 
CSS. 
This 
procedure
automatically resizes and adjusts a website to
make it look suitable on all devices such as
desktop, smartphone, and tablet. For more
details regarding responsiveness, learning
about CSS and Bootstrap language will prove
to be of great advantage.
HTML Templates
HTML website templates are a quick and
easy way to develop a website. As this
template is a pre-built website, developers
can modify and add functionalities as
required. The greatest advantage of using an
HTML template is that developers do not
need to spend hours designing the website

and focus on actual code to meet website
functionality requirements. Moreover, HTML
templates are best suited for those who are
not able to design an attractive website as it
can also be customized as per the given
instructions.
Helpful Tips for Using HTML
Even after we have discussed all of the major
tags, attributes, and functionality of HTML,
there are some other important aspects that
need to be focused on to make your website
more productive and efficient. When using an
opening HTML tag, always write the
corresponding closing tag before you begin
writing the elements and attributes. For
example, <p>…</p>. This will make sure
your HTML pages are working properly on
all browsers and try to style your web pages
through CSS.
After you are done writing the HTML code
for all of the web pages, run the code through
an HTML validator before publishing on the
internet. This activity will disclose any errors

or missing tags in advance so that your
website does not lack functionality when
published online. Moreover, pay attention to
formatting of images or videos because they
are sometimes disrupted when uploaded on
the internet. Specifying the width and height
along with the image tag can help you
overcome this problem.
Although tables are a simple way to lay out
content on the page, you should focus on CSS
rules and build HTML page content through
CSS. Not only this will format your website
in a better way, you can also benefit from
CSS 
positioning 
and 
increase 
the
responsiveness of your website as well.

CHAPTER NINE
CSS
What is CSS?
CSS stands for “Cascading Style Sheet” and
is responsible for controlling the style,
design, and appearance of a web document.
This design language has the capability to
simplify the process of web designing and
also increases the flexibility of a website.
Through CSS, we can change the outlook,
fonts, design, appearance, and format of the

whole 
website 
by 
making 
appropriate
adjustments in the CSS.
Learning CSS is as simple as HTML because
both of the languages are linked together and
have almost the same syntax. Upon using
CSS, we can define a specific style for each
HTML element and apply it to multiple web
pages. Moreover, there is no need to write
HTML tag attributes or elements each time
which makes pages load faster. With CSS, we
can give a better appearance to our web pages
because there is a wider range of attributes
compared to HTML and the style sheets
provide different versions of a website to
display 
perfectly 
on 
desktop 
PCs,
smartphones, and tablets.
Types of CSS
The three main types of CSS are Inline CSS,
Internal CSS, and External CSS.
Inline CSS
Inline 
CSS 
has 
the 
CSS 
property
implemented in a specific section attached

with the element in HTML document. For
example:
<html>
<head>
<title>Inline CSS</title>
</head>
<body>
<p style = "color:Blue; font-size:50px;
font-style:italic; text-align:center;">
Cascading Style sheets
</p>
</body>
</html>
Output:
Internal CSS
Internal CSS is implemented over a single
HTML document to give it a unique style.
Remember that the rule must be implemented
within the HTML file in head section.
Syntax for implementing Internal CSS:
<head>
<title>Internal css</title>

<style>
selector{
Property:value;
}
</style>
</title>
</head>
External CSS
The External CSS has a separate CSS file
which includes only one style property along
with the tag attributes. External CSS file
needs to be linked with the HTML document
by using the Link tag.
Example of External CSS:
body {
background-color:Green;
}
.main {
text-align:center;
}
.GFG {
color:#009900;
font-size:50px;
font-weight:bold;

}
Basic Syntax and Inclusion in
HTML
CSS is made up of several style rules which
are interpreted by the browser and applied
over the web page. Generally, a style rule is
made up of 3 key elements known as
Selector, Property, and Value.
Selector is an HTML tag at which a CSS
style can be applied such as <h1> whereas
Property is an attribute of HTML tag such as
color. Values are assigned to the properties.
The basic syntax for creating CSS style rule
is defined as follows:
Selector {property: value}
Generally, 
inline 
and 
external 
CSS
approaches are used to associate styles with
the HTML document for which the <style>
element is placed inside the <head> and
</head> tags. The syntax for CSS inclusion
in an HTML document is defined as follows:
<html>
  <head>

 
<style type = "text/css" media = "all">
    
body {
           background-color: Grey;
    }
    
h1 {
       
color: White;
           margin-left: 40px;
    
}
 
</style>
  </head>  
  <body>
 
<h1> Sample heading </h1>
 
<p> Sample paragraph </p>
  </body>
</html>
Importing CSS file
To import an external stylesheet, the
following rule can be implemented:
<head>
<@import “URL”;

</head>
Colors and Backgrounds
Colors
In CSS, colors can be defined through names
or values of different kinds. To specify the
color code, the possible formats that can be
used are elaborated as follows:
Name
Syntax
Keyword
Green, Blue, etc.
Hex Code
#RRGGBB
RGB %
Rgb( rrr%, ggg%, bbb%)
RGB
Absolute
Rgb(rrr, ggg, bbb)
Short 
Hex
Code
#RGB
For example, we can set the color of the text
by using the following CSS syntax:
<h1 style= “color: Green;” Cascading Style

Sheets </h1>
Background
There are different properties that can be
considered to define the CSS background of a
website. These properties include Color,
Image, Repeat, Attachment, and Position of
CSS background.
Background Color
To set the background color of a web page,
the following CSS syntax can be used:
body {
background-color: Red;
}
Background Image
Syntax for adding background image:
body {
background-image: url("image.gif");
}
To repeat the image:
body {
background-image:
url(“gradient_image.gif");
}
Background with no repeat:

body {
background-image: url("image_bike.jpg");
background-repeat: no-repeat;
}
Background position
A background image can be set into different
positions such as right, left, center, top, and
bottom. For example:
body {
background-image: url("Image.jpg ");
background-position: center;
}
Formatting and Design
Borders
CSS border property can be used to set a
unique style, color, and width of an element’s
border in an HTML document. Different
styles for creating borders with CSS include
dotted, solid, dashed, groove, double, inset,
outset, hidden, ridge, and none.
Syntax for creating different border styles:
p.dotted {border-style: dotted;}

p.solid {border-style: solid;}
p.dashed {border-style: dashed;}
p.groove {border-style: groove;}
p.double {border-style: double;}
p.inset {border-style: inset;}
p.outset {border-style: outset;}
p.hidden {border-style: hidden;}
p.ridge {border-style: ridge;}
p.none {border-style: none;}
Height and Width
In CSS, height and width properties can be
used to set the height and width of an
element. The syntax for implementing the
height and width property in CSS is defined
as follows:
div {
height: 200px;
width: 50%;
background-color: Green;
}
Margins and Padding
Margin

In CSS, margin property is implemented to
create space around the element. We can set
different margin sizes for every side. Margin
property has different values such as Length,
Width, and Margin, calculated by the
browser.
Syntax:
body
{
margin: size;
}
Padding
CSS paddings can be used to define a border
or create space around the element. There are
different ways to set CSS padding on an
HTML website for individual sides such as
top, right, bottom, and left. Padding has
Length and Width values for which the
following CSS syntax can be implemented:
Body
{
Padding: size;
}

Font and Text
Font
Font property in CSS is used to specify other
font properties and to set the font of a
content. Different font properties in CSS
include font style, font family, font weight,
font variant, font weight, and font size.
Here is the simple CSS syntax for each font
property:
Font style
Live Demo
<html>
<head>
</head>
<body>
<p style = "font-style:calibri;">
This text will be rendered in calibri
style
</p>
</body>
</html>
Font Family

<p style = "font-family: georgia, calibri,
serif;">
Font Variant
<p style = “font-variant: small-caps;”>
Font Weight
<p style = “font-weight:500;”>
Font Size
<p style = "font-size:20px;">
Font size 20 pixels
</p>
<p style = "font-size:small;">
Small font
</p>
<p style = "font-size:large;">
Large font
</p>
Text

Transforming text into different colors,
styles, and indentation is now possible with
CSS text property. These text properties
include:
Text color: Change color of the
text.
Text Alignment: Specify horizontal
or vertical alignment of the text.
Text 
Decoration: 
Outline 
the
decoration of text.
Text 
Transformation: 
Control
capitalization of text.
Text 
Indentation: 
Specify 
the
indentation of first line.
Letter 
Spacing: 
Increase 
or
decrease space between words.
Line Height: Specify line height.
Text Direction: Set direction of
writing.
Word Spacing: Set space between
words.
Text Shadow: Adds shadow effect
on text.
Syntax for CSS text properties:

Text Color:
body
{
color: Red;
}
Text Alignment:
h1 {
text-align: center;
}
h2 {
text-align: left;
}
h3 {
text-align: right;
}
Text Decoration
h1
{
text-decoration:
overline/underline/line-through;
}
Text Transformation
p.uppercase {
text-transform: uppercase;
}

p.lowercase {
text-transform: lowercase;
}
p.capitalize {
text-transform: capitalize;
}
Text Indentation
p
{
Text-indent: 100px;
}
Letter Spacing
h1 {
letter-spacing: 3px;
}
h2 {
letter-spacing: -3px;
}
Line Height
p.small {
line-height: 0.6;
}
p.big {

line-height: 1.6;
}
Text Direction
p
{
direction: rtl;
}
Text Shadow
h1
{
text-shadow: 4px 3px green;
}
Word Spacing
h1 {
word-spacing: 10px;
}
h2 {
word-spacing: -5px;
}
Links, Tables and Margins
Links
There are different CSS properties to

implement hyperlink through CSS. These
properties include :link, :visited, :hover, and
:active. The CSS syntax for implementing
link property is defined as follows:
<style type = "text/css">
a:link {color: #000000}
a:visited {color: #006600}
a:hover {color: #FFCC00}
a:active {color: #FF00CC}
</style>
Tables
Here are the different CSS properties that can
be used to transform and design a HTML
table.
Border collapse
Border spacing
Caption side
Empty Cells
Table Layout
Syntax for creating simple table using CSS:
<html>
<body>
<table class="Table"  border = "1">

<tr>
<th>First Name</th>
<th>Last Name</th>
<th>Marks</th>
</tr>
<tr>
<td>John</td>
<td>Harry</td>
<td>40</td>
</tr>
</table>
</body>
</html>
Output:
Border Collapse
<html>
<head>
<style type = "text/css">
table.one {border-collapse:collapse;}
table.two {border-collapse:separate;}
td.a {
border-style:dotted;

border-width:3px;
border-color:#000000;
padding: 10px;
   }
td.b {
border-style:solid;
border-width:3px;
border-color:#333333;
padding:10px;
}
</style>
</head>
Border Spacing
<html>
  <head>
 
<style type = "text/css">
   
 table.one {
           border-collapse:separate;
           width:400px;
   
    border-spacing:10px;
    
}
     table.two {
           border-collapse:separate;
           width:400px;
           border-spacing:10px 50px;

    
}
     </style>
  </head>
  <body>
 
<table class = "one" border = "1">
    <caption>Separate Border Table with
border-spacing</caption>
        <tr><td> Cell A</td></tr>
        <tr><td> Cell B</td></tr>
 
</table>
 
<br />
     <table class = "two" border = "1">
        <caption>Separate Border Table with border-
spacing</caption>
        <tr><td> Cell A</td></tr>
        <tr><td> Cell B</td></tr>
 
</table>
  </body>
</html>
Output:

Syntax for caption side property:
<head>
 
<style type = "text/css">
    
caption.top {caption-side:top}
        caption.bottom {caption-side:bottom}
    caption.left {caption-side:left}
    
caption.right {caption-side:right}
     </style>
  </head>
Syntax for Empty Sides Property
<head>
 
<style type = "text/css">
    
table.empty {
           width:350px;
           border-collapse:separate;

       
empty-cells:hide;
    
}
    
td.empty {
       
padding:5px;
           border-style:solid;
           border-width:1px;
           border-color:#999999;
    
}
 
</style>
  </head>
Syntax for Table Layout
<head>
 
<style type = "text/css">
    
table.auto {
           table-layout: auto
    
}
    
table.fixed {
           table-layout: fixed
    
}
 
</style>
  </head>
Margins
CSS margin property is used to create a space
or margin around the HTML element. There
are different properties to set an element

margin through CSS such as Margin, Margin-
bottom, 
Margin-top, 
Margin-left, 
and
Margin-right.
Syntax for implementing Margin property:
<p 
style 
= 
"margin-property: 
10px;
border:1px solid black;">
all four margins will be 10px
</p>          
Lists, Icons, and Dropdowns
Lists
There two types of lists used in CSS known
as Ordered lists and Unordered lists. In the
ordered lists, all of the list items are marked
with serial numbers or alphabets whereas in
unordered lists, the list items are generally
marked with bullets. The list value can be
created by using values such as circle,
decimal, 
lower-roman, 
upper-roman,
decimal-leading zeros, lower-alpha, upper-
alpha, and square.
For example:
<html>

<head>
<style>
ul.a
{
list-style-type:square;
}
ol.c
{
list-style-type:lower-alpha;
}
</style>
</head>
<body>
<h2>
CSS ORDERED & UNORDERED LISTS
</h2>
<p>
Unordered lists
</p>
<ul class="a">
<li>one</li>
<li>two</li>
<li>three</li>
</ul>
<ul class="b">
<li>one</li>

<li>two</li>
<li>three</li>
</ul>
<p>
Ordered Lists
</p>
<ol class="c">
<li>one</li>
<li>two</li>
<li>three</li>
</ol>
<ol class="d">
<li>one</li>
<li>two</li>
<li>three</li>
</ol>
</body>
</html>
Output:
CSS ORDERED & UNORDERED LISTS
Unordered lists
●     one
●     two
●     three

●     one
●     two
●     three
Ordered Lists
a.     one
b.     two
c.      three
1.      one
2.     two
3.     three
Icons
By using the icon library from HTML, we
can add different types of icons through CSS
as well. These types of icons include Font
awesome icons, Bootstrap icons, and Google
icons.
Font awesome icons syntax:
<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/fo
awesome/4.7.0/css/font-awesome.min.css">
Bootstrap icons syntax:

<link rel="stylesheet"
href="https://maxcdn.bootstrapcdn.com/bootst
Google icons syntax:
<link rel="stylesheet"
href="https://fonts.googleapis.com/icon?
family=Material+Icons">
Example:
<!DOCTYPE>
<html>
<head>
<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/fo
awesome/4.7.0/css/font-awesome.min.css">
</head>
<body>
<h1>
CSS ICONS
</h1>
<i class="fa fa-cloud" style="font-
size:32px;"></i>
<i class="fa fa-heart" style="font-
size:32px;"></i>
<i 
class="fa 
fa-file" 
style="font-
size:32px;"></i>
<i 
class="fa 
fa-car" 
style="font-

size:32px;"></i>
<i 
class="fa 
fa-bars" 
style="font-
size:32px;"></i>
</body>
</html>
Dropdowns
We can also create dropdown menus through
CSS. Being the same as HTML elements, a
drop down consists of an unordered list and
nested
lists are used to create the drop-down
structure. For example:
<html>
<head>
<title>Dropdown CSS</title>
</head>
<body>
<nav>
<ul>
<li class="Lev-1">

<a href="">List
<ul>
<li><a href="">Page 1</a></li>
<li><a href="">Page 2</a></li>
     <li><a href="">Page 3</a>
</li>
<li><a href="">Page 4</a></li>
</ul>
</li>
</ul>
</nav>
</body>
</html>
Output:
Layers and Visibility
Layers
Through CSS, we can create multiple layers
of various divisions by implementing the z-

index CSS property. For example:
<html>
<head>
</head>
<body>
<div style = "background-color:Blue;
width:300px;
height:100px;
position:relative;
top:10px;
left:80px;
z-index:2">
</div>
<div style = "background-color:Red;
width:300px;
height:100px;
position:relative;
top:-60px;
left:35px;
z-index:1;">
</div>
<div style = "background-color:Black;
width:300px;
height:100px;

position:relative;
top:-220px;
left:120px;
z-index:3;">
</div>
</body>
</html>
Output:
Visibility
The Visibility property in CSS allows us to
hide an element from view mode and this
property can also be used to hide error
messages and to retain text privacy. Visibility
property has predefined values including
Visible, Hidden, and Collapse.
Syntax for implementing Visibility property
in a paragraph through CSS:
<p>
Text visible.
</p>

<p style = "visibility:hidden;">
Text should not be visible.
</p>
Layout and Animations
Layout
The CSS layout techniques are a great way to
take elements contained in a web page and
present them in different layouts. This
technique is generally used to change the
position of elements or a container. Modules
for CSS layout include Normal Flow, the
display property, Flexbox, Grid, Floats,
Positioning, Table Layout, and Multiple
column layout. Remember that all of the
methods of achieving a page layout in CSS
are conducted through the display property.
Animation
CSS animations allow an element to change
style from one to another for which we can
implement multiple properties as well. For
using CSS animations, we are required to

specify some key frames through the
@keyframes rule.
For example:
@keyframes sample {
from {background-color: blue;}
to {background-color: brown;}
}
/* The element to apply the animation to */
div {
width: 100px;
height: 100px;
background-color: blue;
animation-name: example;
animation-duration: 4s;
}
How to Effectively Use CSS
There 
are 
several 
other 
CSS 
custom
properties 
and 
elements 
that 
can 
be
implemented 
to 
improve 
the 
graphics,
display, and attractiveness of a web page.
Although it is critical to learn and implement
all properties of CSS, using a good editor can
help create a perfect website design.

Furthermore, every method used in CSS
should be consistent so that there are no
problems such as misinterpretation.
While writing CSS, you should also avoid
using inline code and place the styles or
attributes only in the external stylesheets.
Checking that your code works on the latest
internet browsers such as Internet Explorer,
Chrome, and Safari can be a great idea so that
you can ensure proper display and formatting
of the web pages. Moreover, CSS code can
also be reused as a template for other projects
and you can recycle the pre-existing code into
new ones as well. Multiple classes can also
be implemented with space separation and we
can benefit from CSS inheritance by applying
specific CSS elements.

CHAPTER TEN
PROGRAMMING ESSENTIALS
Selecting the Programming
Language
As we have thoroughly discussed all of the
major programming languages and their
syntax in detail, beginners can choose the
language which seems easiest to learn and
implement. Although most of the major
programming languages such as C, C++, and
Java have similar syntax, there are several

important aspects that need to be focused on
when writing a program. C and C++ are the
best 
options 
for 
developing 
computer
applications for beginners because they
provide 
an 
in-depth 
understanding 
of
programing and clear concepts as well.
For 
developing 
web 
plugins, 
desktop
applications, or mobile applications, Java
language can be considered because it
provides complete support and functionality.
HTML, CSS, and PHP are the core languages
for website development and can be easily
learned by beginners. As a programmer, one
should never limit themselves to a single
language and try the latest techniques and
implementations.
Multiple computer programming languages
can be used to solve a specific problem. To
make things easier, beginners can look at
their skills and select the programming
language which is most suitable and easy to
implement. Programming is dependent on
several other factors such as usability of
application, 
security, 
compatibility, 
and
response time.

Tips 
for 
Efficient
Programming
Although writing understandable code and
satisfying program requirements are a major
part of computer programming, there are
some essential tips and tricks that can
increase efficiency of the programmer.
Starting with the most vital point to be
considered, 
programmers 
should 
avoid
passing long argument lists to functions and
only try to use int, pointer, or void function
types. Moreover, do not convert chars to
another data type because char variables can
be located anywhere in the RAM.
Furthermore, global variables must never be
initialized with a small function and minimize
the use of mathematical operations with
floating point numbers. This will reduce the
execution time and consume less memory as
well. Global variables and loops can make it
difficult for programmers to handle the
application when the code reaches thousands
of lines and making a slight change will result
in a huge problem.

Writing switch cases, statements, loops, and
try-catch inside a method or function is an
ideal approach. Remember that methods
should also be written inside class and
function definitions. Moreover, structuring
the 
application 
by 
using 
appropriate
structures is a good approach which also
improves coding standards.
Last but not least, version control software
can also be considered in order to improve
application performance and to deliver
updates as well. Although it is an approach
used by professional programmers, tools such
as Mercurial or Git are easy to learn and use
by beginners as well.
While writing your code, avoiding deep
nesting and limit line length because it can
make the code difficult to read.
Strengthen Your Basic Skills
In order to become a good programmer, it is
mandatory that you are aware of all of the
critical and major concepts of computer
programming. 
Knowing 
the 
basics 
in

algorithms and data structures is a great way
to improve your problem-solving skills.
Moreover, writing unit tests is yet another
impeccable approach to boost your thinking
and coding skills. After you are done with
coding, it is recommended that you perform
in depth code review and find any mistakes or
areas of improvement. In return, this activity
will improve application performance and
efficiency as well.
The code must always be simple and
meaningful. 
By 
using 
proper 
naming
conventions, you can replace variables or
methods without any hassle. Remember that
creating a specific folder and file for your
application can deliver great benefits as you
can maintain and debug with ease. Learning
programming fundamentals is the key aspect
of developing strong development and
analytical skills.
Furthermore, try to implement your coding
skills by solving programming exercises and
write simple code. Not only will this boost
your programming skills, but you will also be
able to develop new solutions that are
efficient and effective. Spending time to learn

the basics of programming also makes it
easier to adapt to the latest technologies and
learn new programming methods as well.
Programming can be made interesting by
learning and implementing new methods,
functions, and approaches.

CONCLUSION
“Coding for Absolute Beginners” is designed
and written to provide valuable knowledge,
information, and principles of computer
programming for beginners. This book has
thoroughly covered the major programming
languages and provided the right guidelines
to implement the given concepts and
findings.
Writing a computer code requires the
developers to follow a predefined syntax and
flow. Depending on the project requirements,
one can choose a programming language
which is easy to implement and focus on the
available tools and technologies as well.
Computer programming is comprised of
multiple tasks including writing the source
code, testing, implementing build systems,

methodologies, debugging, and functionality.
After reading this book, I am certain that
novice programmers can develop strong
analytical and thinking skills along with an
in-depth understanding of the given concepts
for each language. This Book has been
written after extensive research, development,
and fact finding so that the correct
information and syntax could be delivered to
the readers. After thoroughly reading and
understanding the provided concepts from
this Book, developing desktop applications,
web applications, or programs in any high-
level language will surely not be a problem.
I hope my valued readers will be able to
learn, 
adapt, 
and 
implement 
computer
programming techniques and develop sharp
coding skills by reading through the chapters
of 
this 
manual. 
Coding 
for 
Absolute
Beginners features all of the major and minor
explanations for each programming language
in a simple and understandable manner.

BOOK- II
PYTHON
FOR
ABSOLUTE
BEGINNERS
A Step-by-Step Guide to Learn Python
Programming from Scratch, with
Practical Coding Examples and
Exercises
ANDREW WARNER

C
INTRODUCTION
omputers have become part and parcel of
everyone’s life. No matter where you are
in the world or what lifestyle you have,
you interact with at least one every day. From
the watch you wear to the blender in your
kitchen, they make a difference in how you
live. And with 5G and smart devices set to
become mainstream in the near future, you
must be tech-savvy just to go about your day.
Simply put, a computer is a machine that has
a set of instructions — a.k.a. program or
software — to do a specific task(s). Without
codes, it is just a piece of junk hardware. The
people 
who 
write 
them 
are 
called
programmers, software developers, or coders.
The medium they use to write these
instructions is known as a programming

language.
Thanks to rapid technological advancements,
the computer already gives a high degree of
freedom to programmers. You have storage
devices in gigabytes and even terabytes now
instead of just a few kilobytes that were
mostly available 30 years ago. Its processing
power has increased tremendously as well.
Computers are amazing at repetitive jobs that
people cannot do. They lack emotions that
tend to cause human error.
All these things have led to the invention of
high-level programming languages. They
have enabled programmers to develop
complex software solutions that can tackle
virtually any task. This has resulted in
automation becoming a part of everyone’s
personal and professional lives.
This book is written for programming
enthusiasts who want to learn how to do it
from 
scratch. 
Even 
though 
modern
programming languages don’t have many of
them, it’s a good idea to understand the
limitations and the basic concepts before
learning a specific language. Also, every field

has its own terminology. If you don’t
familiarize yourself with it from the start, you
may feel challenged when you move to
advanced concepts.
Modern programming languages are very
condensed. What required 100 lines of code
in an older language, for instance, might need
5 lines of codes only using a modern one.
You’ll notice later that the codes here are as
simple as possible even if it takes a little
more line to achieve the goal. There are also
programming techniques available in every
language for shortcuts and code optimization.
Nevertheless, that is not the main purpose of
this book. The goal is to impart basic
concepts of programming and help you learn
Python.
Why Python, you may ask?
Well, for starters, Python is as effective as a
learning language as it is in tackling complex
tasks. It is one of the easiest high-level
modern programming languages to learn. The
syntax is fairly easy to get accustomed to; it’s
powerful 
and 
integrates 
with 
other
programming languages and systems nicely.

On top of that, its capabilities are highly
extendible, thanks to dozens of libraries and
external modules. After you have learned
programming and Python concepts within
this book, you don’t need to switch to another
language in the future to pursue further skills.

A
CHAPTER ONE
PROGRAMMING BASICS
ll programming languages have the same
concepts at the core. Over the years,
though, they have evolved to offer more
power and relieve coders from worrying
about minute details.
The first programming language I learned
was Basic in school. The only thing I got
from it was printing my name ten times on
the screen, but that software intrigued me
enough 
to 
pursue 
programming 
as 
a
profession. The problem was, I made the
mistake of learning a language without
knowing its underlying concepts. It was fine

at first, but as I started to explore advanced
ideas, they became almost impossible to
understand.
To help you avoid the same issue, we will
discuss the basic concepts in this chapter.
Integral 
Programming
Concepts
It 
is 
important 
to 
understand 
how
programming languages differ. Some of them
are suitable for text processing, graphics,
mathematical 
applications, 
or 
general
purposes.
There is no standard classification system for
programming languages. It depends on the
criteria you use to classify them. Here is a
simplified version of that:
Low-Level Languages
During the early 20th century, computers had
limited resources. It was the programmer’s
duty to keep track of resource usage when
writing a program. Computers also had

limited capabilities as they only understood a
small set of instructions. These are some of
the reasons why low-level languages came
into existence.
Machine Language
This is the only language that computers
understand because it comprises the binary
codes that computer hardware uses. During
the machine language era, programming was
not even a distinct field. There were no
standards, and writing programs was a
nightmare. 
Have 
you 
seen 
Margaret
Hamilton’s picture along with the software
that she wrote for the Apollo program that
helped a man land on the moon? If not, do it
and read her story. You’ll understand what I
am trying to say. Later on, programmers were
able to use hexadecimal codes. Still, the
entire process was very complicated.
As a demonstration of how complex and
lengthy the coding process was in machine
language, here’s the binary code conversion
of the two-word phrase “Hello universe!”
01001000 01100101 01101100 01101100

01101111 00100000 01110101 01101110
01101001 01110110 01100101 01110010
01110011    01100101
Assembly Language
Assembly languages were the first ones to
pave the way for problem solving using
computers on a commercial scale. Long
binary codes were replaced with short
alphanumeric codes that were easier to input
and store. Digital input devices like keyboard
became mainstream, so punch cards ended up
being obsolete.
High-Level Languages
All modern programming languages are high-
level. They give you freedom from hardware
considerations 
to 
execute 
a 
program.
Programmers focus on achieving results
while the programming platform does the
resource management, which is not required
in most cases due to the advanced computer
systems that we have nowadays.
Problem-Oriented Language

Programming languages like Java, Perl, and
Python are problem-oriented. They enable
programmers to focus on solving the task at
hand 
and 
forget 
about 
the 
hardware
resources. It’s all about the final product.
coding has become easier and there are so
many resources available that you don’t need
to do everything from scratch. You can pick
ready-made modules and repurpose them to
fit your requirements.
Natural Programming Language
We already have devices that process human
languages on a limited scale and even detect
different voices and accents. Further progress
is happening rapidly in the field of artificial
intelligence (AI) with the objective of giving
human-level intellect and freedom of choice
to computers and enabling them to make
independent decisions. At the heart of this are
the natural programming languages that’ll
allow devices to seamlessly understand
human language. Have you seen a science-
fiction movie about a human-like robot who
lives and participates in the society like the
rest of us? This is where we are headed.

Interpreters and Compilers
In all high-level languages, the programs are
either interpreted or compiled for the
computer to understand what needs to be
done.
In interpreters, each line of code is translated
to machine language and executed as soon as
it’s entered. Interpreter languages are useful
for testing and learning. An example of such
language is Ruby.
In compilers, the entire program is converted
to machine language called object code and
saved for future executions. If the original
program isn’t changed, compiler ignores the
conversion step and executes the object code,
which makes the process faster. This
technique is good for large software that
strain available resources. An example of this
language is C.
Python is basically an interpreter language
but also offers compiler option for large
programs. It highlights the versatility of the
language once again.
Important Definitions

Syntax
Syntax is the set of rules that governs how to
write code in a programming language. Just
like real-life languages, it’s essential to
follow 
the 
specific 
syntax 
to 
avoid
unexpected results.
Algorithms
Writing algorithms is an age-old method of
solving problems in a step-by-step way. It is
loosely 
based 
on 
the 
approach 
that
mathematicians have used to formulate
theorems for centuries. Every professional
programmer writes an algorithm before
writing a program to solve an issue. Here’s a
simple algorithm to make yourself a cheese
omelet:
1. Wake up at 7am.
2. Check 
if 
you 
have 
all 
the
ingredients. If not, go to the corner
store and buy the missing ones.
3. Cut the vegetables, whisk the eggs,
and mix all the ingredients in it
except oil.

4. Heat very little oil in the non-stick
pan and add the batter.
5. Once one side is done, flip and add
a cheese slice.
6. Flip the egg once again after cheese
is melted and cook to set.
7. Enjoy it with bread or as is.
Flowcharts
As the name suggests, it is a method to
record the flow of a solution. It’s a bit
technical 
and 
makes 
more 
sense 
to
programmers because different boxes indicate
various 
programming 
techniques. 
For
example, if the next step in the program flow
is to check a condition that can lead to two
different scenarios, the symbol below is used.
Here is the flowchart for the algorithm I
wrote for making cheese omelet:

Flow of Execution
Also referred to as control flow, this
determines how a programming language
executes a piece of code. For example,
Python executes one line of code from top to

bottom. The flow can be changed using a
loop or conditions. We’ll discuss this in detail
in Chapter 3.
Keywords
Every programming language has some
words that have special meaning. You cannot
use these words apart from the purpose they
have in that specific language. In short, their
usage is reserved.
Mathematics
Mathematics is the branch of science that
basically has no set definition. It is a broad
field that deals with the study of quantity
(arithmetic), 
structure 
(algebra), 
space
(trigonometry), and change (calculus) to
reach solution of known problems. If you are
weak in mathematics, you may struggle with
programming. Many related techniques and
concepts, after all, have been borrowed
straight from this field.
Paradigm
Paradigm is another way to classify a
programming language. It is based upon the

programming 
features 
supported 
by 
a
language. Object-oriented (using objects),
functional (using functions), structured (using
loops and conditionals), and aspect-oriented
(using modules) programming are a few
examples of a paradigm. Many high-level
languages — Python included — support
multiple paradigms.
Integrated Development Environment
(IDE)
It is a computer application that allows
programmers to write, run, and debug their
software codes. Some of them are language-
specific; others work with almost any
language out there. Notepad++ and Sublime
Text are notable examples of IDEs.
Package
Open-source packages are often rebundled by
third-party contributors and released for
public use. They are targeted for specific
applications and usually have specialized
modules added for that purpose.
32-bit and 64-bit Computer Systems

Although 64-bit computer systems were
introduced in 1961, the first home computers
to have this capability came to market in
2000 and didn’t become common until
recently. 
Better 
hardware 
architecture
resulted in cost-effective design of 64-bit
processing units. These systems offer faster
processing and larger memory as compared to
the older 32-bit processing units. It paved the
way for a new era of software products that
were not acutely hampered by memory and
hardware limitations.
Character Encoding
Text is created with characters, and every
language has a different set of characters.
Computers rely on several special character-
encoding sets to support as many characters
as possible.
In the programming world, it’s important to
remember that each character is stored
uniquely in memory. Even if two of them
look the same to humans, they might relay
completely different meanings to a computer
due to the encoding used for them.

Dependency
Every object relies on something to function
properly. For instance, your car depends on
gas to run. You rely on oxygen to live or an
alarm clock to wake up in the morning. Some
dependencies are optional, such as the alarm
clock, but others are compulsory, such as the
oxygen in the air.
Brief History of Programming
Languages
The journey of programming languages is
centuries old. There are evidences of machine
language programs as old as 1843 when Ada
Lovelace wrote a mechanical computer
algorithm. 
Here’s 
a 
brief 
history 
of
programming languages.
FORmula 
TRANslation
(FORTRAN)
FORTRAN is an IBM endeavor that was
launched in the 1950s. Program codes were
written on punch cards and manually fed into

the computers. The effort and finance it
required to code and maintain the computers
and programs at the time meant that the
systems were limited to government agencies
and global enterprises.
Pascal
Developed by Niklaus Wirth during the
1970s, it was based on Algorithmic Language
1960 (ALGOL 60). The purpose of this
language was to teach the best coding
practices to new programmers. It became
famous and widely used commercially until it
was slowly replaced by C language during
the 1980s.
C
Dennis Ritchie created C language in 1972
and was one of the very first general-purpose
languages 
that 
remains 
mainstream. 
It
resulted in the family of programming
languages that includes C++ and Objective C.
Despite being a compiler language, it can
help people hone their programming skills.

Perl
In 1987, Larry Wall of Unisys developed this
language based on C for the sole purpose of
working with text files. It was supposed to be
named Pearl, but that was already taken, so
Larry had to settle with Perl. Now, everyone
would refer to it as a combination of two
languages. It still has many general-purpose
utilizations 
as 
well, 
such 
as 
web
development, network programming, and
system administration. 
Ruby
The only language in the list whose creator is
an Asian, Ruby was designed by Yukirhiro
Matsumoto in 1993. Influenced by Perl and
Basic, Yukihiro created a language that made
programming enjoyable to bring masses into
productive coding. Fun fact: Ruby is very
similar to Python when it comes to syntax.
Java
Java was created by James Gosling of Sun
Microsystems in 1995 and became part of the

company’s Java platform. Despite being
under proprietary licenses, it is the most
extensively used language today. The biggest
reason behind this widespread popularity was
Java platform’s system independence. Sun
Microsystems was taken over by Oracle in
2010, and Java has become their property
since then.
Personal Home Page (PHP)
PHP 
is 
an 
open-source 
programming
language created by Rasmus Lerdorf in 1995
to build websites. Global enterprises usually
stay away from open-source tools, but PHP is
truly an exception. Most website developers
start their career through it. It is used to run
the background processes of a website and
help the website communicate with other
parts of the internet.
JavaScript
Developed by Brendah Eich in 1995,
JavaScript was heavily influenced by Java. It
is the core component of the World Wide
Web along with HTML and CSS. It gives

websites the dynamic edge and is supported
by every browser. Recently, word processors
and PDF documents have started embedding
JavaScript to support rich content as well.
Python
Python is a general-purpose, high-level
language released in 1991 by Guido van
Rossum. It is an interpreted language, though
it also supports compiled system.
Even with so many languages available in the
market, programming was still cumbersome
as languages were machine-oriented. There
was a need for a new version that’s easier to
read so that novice programmers could learn
and code quickly. Thanks to Guido, that
problem was solved.
The main purpose of Python is to enhance
readability, which is evident by the use of
whitespace to separate program lines. There
are many Python environments available
now. Due to it being open source, the Python
community grew very quickly. This led to the
development of an extensive list of external
modules, some of which were later added to

the core language as libraries.
These resources also gave Python the ability
to integrate with other languages seamlessly.
You would be in Python environment but
writing code in Visual Basic, and Python will
execute it straight away. You’ll work on this
in later chapters, but in the future, when you
do the same in any other language, you’ll
understand why Python is so powerful.
Object-Oriented
Programming (OOP)
Up until now, I have been avoiding talking
about arguably the biggest programming
concept conceived in the 20th century. Any
guesses? Yes, you are right! It is object-
oriented programming. Still, let’s discuss it
now before starting to work with Python.
What Is an Object and How Does
OOP Work?
Consider a real-life scenario: you have a dog
named Leo who loves it when you ask him to

hug you. You also know the helpless face that
Leo makes when you ask him to mow the
lawn because you are too tired. He genuinely
wants to help, but it’s beyond his capabilities.
In object-oriented programming, your dog is
an object. You give a command to Leo when
you ask him to hug you, and Leo complies
because he recognizes the command. On the
other hand, if you order a task that he doesn’t
understand, such as mowing the lawn, it leads
to an error.
Objects were created to simplify coding
numerous entities and controlling their
behavior in humongous environments. For
example, if you are developing a game, all
characters are unique instances of the same
object, so they have common characteristics.
This makes it easier to group their actions and
responses. The alternative would have been
to code every character, as well as their
actions and responses separately. Of course,
this is unsustainable when creating big
environments.
Python 
does 
support 
object-oriented
programming. However, depending on what
goal you are trying to accomplish, you may

not do it extensively. As you’ll find out later
in this book, there are other programming
techniques that suit different requirements
better.
How to recognize if you are invoking object-
oriented side of Python, you may ask? You
need to use a command that looks like this:
object.command()
In our previous example, here’s how the
command will appear:
leo.hugme()
The hugme() command is referred to as a
method. It might be unique to the object leo.
There are many integral programming
concepts that every programmer should know
about, irrespective of which languages they
are learning. To avoid repetition, we are
going to scrutinize them when we learn more
about Python later.
Exercises
1. Go to convertbinary.com and get the
binary code for “This is the best
book ever!”

2. Find a text to hexadecimal converter
online and get the hexadecimal code
for “This is the best book ever!”
3. When was Python created?
4. Who 
created 
the 
Pascal
programming language?
5. Is Python a low-level language?
6. Have you seen a punch card ever?
7. Which language was made for
processing text files?
8. Who invented Basic programming
language? (Hint: You might want to
get help from Google for this.)
9. You are going to the Bahamas for
vacation. Write an algorithm for the
entire process.
10. Create a flowchart for
the algorithm that you wrote for
Question 6.

P
CHAPTER TWO
STARTING WITH PYTHON
ython creator Guido van Rossum is also
dubbed as the Benevolent Dictator for
Life (BDFL) because he single-handedly
spearheaded Python’s development from the
start until 2018. Now, he’s a part of a
Steering Council that comprises of five
members. This helped to keep Python
developing in a systematic way even when
many customized versions of it were
launched by different platforms over the
years.
Before Python, only C language had properly
formatted block comments, but it didn’t
support inline comments. The other famous

language at the time, Perl, was famous for
being ugly. Python started the enhanced
readability revolution that many languages
adopted later on. It focused on making
programming language easier to read and
comprehend for humans. It opened doors to
casual programmers who greatly benefited
the programming field in the long-term.
Python also helped with code reusability and
recycling. Instead of programming everything
from 
scratch, 
programmers 
can 
easily
understand others’ work and use them as
reference. The open-source nature of Python
project was immensely useful here, too.
Another 
feature 
that 
greatly 
enhanced
readability was the proper support for both
inline comments and comment blocks.
The 
official 
Python 
website 
is
https://www.python.org/. It contains all the
releases for various operating systems. A
comprehensive 
documentation 
is 
also
available on the website. The community
section has links to Python forums that will
be helpful when you pursue advanced skills.

Python 2.x vs. 3.x
On October 2000, Python 2.0 was released
with many new features that changed the
language to a great extent. The changes
proved to be worthwhile, and the popularity
of the language grew immensely in the
programming community. Python 2.7 is
arguably the best and definitely the most
widely used version of Python to date. It
supported 
integration 
with 
almost 
any
platform but kept the syntax easy to learn.
Python 3.0 was released in 2008, meanwhile,
and it was another major update. They made
sweeping changes to even basic syntax. It
wasn’t entirely backward-compatible, which
drew 
mixed 
opinions 
in 
the 
Python
community. Even though the new version
came with a porting utility that provided
limited extent support in converting 2.x codes
to 3.x, many people stuck with Python 2.7
and still remain loyal to it. Initially, support
for 2.7 version was set to end in 2015 but was
extended to 2020. Even now, it’s evident that
2.7 is not going anywhere.
For the purpose of teaching programming

basics and starting with Python in this book,
we have chosen the 2.7 platform. It is easier
to understand and simpler to code; there is so
much resource material available to develop
skills quickly, too. You can learn Python 3 at
your own pace when you feel comfortable
doing so. You’ll also see that the changes
aren’t too troublesome if you already have a
good grasp on the language.
Choosing 
a 
Python
Environment
In this book, we are going to use Windows 10
operating system as our platform as most
people are familiar with it. The traditional
release for Windows is available for
download from the official Python website,
nicknamed CPython. Several third-party
Python implementations are also available for
32-bit and 64-bit Windows systems, each
offering additional benefits.
Furthermore, we are going to work with
Python 2.7, which was developed by
ActiveState, and complement it with Mark

Hammond’s 
re-packaged 
PythonWin. 
I
would like to say special thanks to Mark
Hammond here for his years of dedication
and hard work without which Python on
Windows might never would have lasted
long.
Why this combination, you may ask? In truth,
the official Python package has a very
lackluster IDE. ActiveState offers extra
libraries while PythonWin has a colorful IDE.
The combination, therefore, makes coding
fun for beginners.
It is useful to know at this point that there are
different free IDEs available for Python like
Notepad++ and Sublime Text 3 that look
quite nice. However, it’s a little complex to
run codes written with them. Once you are
comfortable with Python, you can choose the
implementation and IDE that you feel at
home with.
Installing 
and 
Setting 
Up
Python
This section can prove to be a bit

overwhelming, maybe more than the actual
coding, for the simple fact that it is all new to
you. Don’t worry, there’s no need to hurry.
Read through the steps below at your own
pace.
Step 1
The first step is to find out if you have a 32-
bit or 64-bit computer so that you can install
the correct version of Python. If you already
know what you have, please skip to the next
step.
Click on the Windows icon on the bottom left
corner of your screen.
Type “system” in the white search bar at the
bottom and click on “System Information”
app that shows up.
In the new window, look for “System Type”
and check the value in the column next to it.
It will tell you if you have a 32-bit or 64-bit
system.
Step 2
To get the Windows installer for ActiveState
Python, officially and more famously known

as 
ActivePython, 
go 
to 
this 
link:
https://www.activestate.com/products/activepy
Select the ActivePython 2.7 to get redirected
to the signup page. After creating a free
account, download the 32-bit or 64-bit
Windows installer that’s compatible with
your computer system. It is usually installed
in a Python27 folder in the root directory
C:\Python27\. You can change the installation
path but make sure to note the folder where
you install Python.
An important point to remember here is to
never use spaces when creating a folder or
subfolder that will contain programming files.
Also, you must check the option “Add Python
to Register” — it’ll make future module and
package installations much easier.
After ActivePython is installed, go to this link
to 
download 
PythonWin:
https://github.com/mhammond/pywin32/releas
Download the latest 32-bit or 64-bit installer
for your computer and start the installation.
Make sure that the folder is the same where
you installed ActivePython. If you checked
the option “Add Python to Register” during
ActivePython installation, the folder will be

pre-filled but always guarantee that it’s the
same path where you installed ActivePython.
Once the installation is done, go to the folder
where you installed ActivePython. If you
didn’t change the path during the process, it’ll
be C:\Python27\Lib\site-packages\PythonWin
and find the file PythonWin.exe. Click the
right button on the mouse to launch it and
select “Send to > Desktop (create shortcut).”
Now, you can always start Python straight
from your desktop.
Writing and Running Your
First Program
What Is a Module?
In Python, a module is any file with an
extension ‘.py’ that contains program lines.
You can write your own modules and save
them to run later or call in another one. You
can download and install a third-party module
to extend the capabilities of Python to code
for a specific task.
Once the installation and setup of Python

environment is complete, press the right
button on your mouse twice to open the
PythonWin icon on your desktop. A new
window will appear, similar to this one:
If you accidentally close the “Interactive
Window,” you can reopen it by clicking this
icon:
It’s time to learn about a decades-old
tradition in the programming community. The
first thing that any programmer should learn
to write should always be “Hello, world” in a
programming language. This tradition was set
by Dennis Ritchie and Brian Kernighan when
they did the same while testing the
development of the C language.

It is 2019, though, and programming has
outgrown our world. There are satellites in
outer space that are purely controlled through
automated programs. It is time to accept that
computers and programs have reached places
where no human has ever gone and may
never will. For that reason, it is time to know
how to write “Hello, Universe!” instead.
Type the following line after the >>> prompt
and hit Enter:
print “Hello, Universe!”
Python will run the command and show the
following:
Congratulations, you instructed Python to
follow your command without any mistake!
However, there’s one more thing to learn
here. We are going to save our very first
module so that we can run it later or anytime
we want.
Click on the ‘New’ icon. You’ll see a pop-up
with three options: Python Script, Grep, and

Pychecker. Python Script will be selected by
default; just press the ‘OK’ button without
deselecting it. A new blank window will
open.
 
Copy the following line of code in the blank
window and click on the ‘Save’ icon:
print “Hello, Universe!”
You will see an option to choose folder and
filename when you try to save this module.

Select the folder where you installed Python
preferably and name the file as ‘hello-
universe.py’ accordingly. You can create a
subfolder to keep your own program codes
organized and separate from Python’s default
files. Note that just like folder names, we did
not use space in the filename. Never ever add
spaces in a program filename or folder in any
language even if the documentation says that
the programming language supports spaces it.
It will save you from a lot of trouble and
headaches in the long run.
Bonus: Beware of copying and pasting the
code from sources other than a Python file
with the ‘.py’ extension. It might read the
same, but the characters might have different
encoding. This will lead to the following
error when you try to save such a module:

Once the program is saved, close the window
that now says ‘hello-universe.py’. Then, click
the ‘Run’ icon. You can hit ‘Browse’ to
navigate to the folder where you have saved
‘hello-universe.py’ file. Select the file and
click the ‘Open’ button. The file path will
now be filled in the field besides “Script
File”. You can ignore all other options for
now and click ‘OK’. As soon as you do so,
Python will read and execute the ‘hello-
universe.py’ module.

The Python interpreter “Interactive Window”
will show the following output:
Pay special attention to the log entry at the
bottom that says, “...returned exit code 0”. It
means that the program ran successfully
without any errors. Bravo! You have now
saved and ran your first programming module
in Python without a glitch.
Installing Optional External
Modules
What Is a Package? What Is Import?
Sometimes when third-party contributors
write codes to add special functionality to
Python, they have to break them into several
modules. Those are structured together to

create a package that makes it easier to
distribute. The process of calling a module
that you created — or an external package
you installed — in your program is called
import. Thanks to the open-source nature of
Python project, there hasn’t been any
shortage of contributors over the years. This
gives Python the ability to become extended
through modules and packages to create
solutions for complex tasks.
Pip — Your Best Friend
You can install external packages with the
help of Python’s package manager (and your
best friend), pip. To illustrate how to use it,
we are going to install a package named
Scrapy, one of the most popular packages in
Python to scrape websites. We could have
done this by running the commands in the
PythonWin interpreter “Interactive Window”,
but we are going to use Windows command
prompt to show how easy it is to run Python
commands on an operating system interface.
1. Click the Windows icon at the

bottom left side of you screen.
2. Click the search bar at the bottom
and type “Command Prompt”.
3. Hit the right-click button on the first
option 
and 
select 
“Run 
as
administrator”. A new window will
pop up with a black background.
4. Type the following command and
hit Enter:
python -m pip install scrapy
As soon as you do that, Python will start
downloading and installing the package.
You’ll be able to see a progress bar, as well
as several messages updating you on the
process. In the end, you’ll see a message that
says, “Successfully installed…” You can now
close the window by clicking the X icon on
the top-right corner of the command prompt
window or typing the following command:
exit
Here’s how the entire process looks like if
completed successfully.

Bonus: You can convert Windows command
prompt to Python interpreter environment.
Simply open the Windows command prompt
and type the following command to let
Python take over:
python
The window will look like this after the
execution:

Note that it shows the ActivePython interface
and not the PythonWin IDE interface. To exit
from Python and resume Windows command
prompt interface, type:
exit()
Exercises
1. Are we using Windows- or Linux-
based platform to learn Python?
2. Which Python environment did we
setup in this chapter?
3. Who has contributed to the Python
project for decades to keep it
running on Windows?
4. List down at least three popular
Python 
implementations 
or 
re-
packages.
5. List down at least three popular
IDEs that you can use to write and
debug Python code. The IDEs must

be Python specific.
6. What is the name of the Python’s
package manager?
7. Print 
“Hello, 
Universe!” 
after
converting 
Windows 
command
prompt to Python and then exit.
8. Print your full name on Python’s
“Interactive Window”.
9. Write a module to do the task of Q1.
10. Try installing the famous
external module pywin32 using
Windows command prompt.

I
CHAPTER THREE
PYTHON BASICS
n Chapter 2, we ran a simple command to
make sure everything is perfectly setup. If
you remember, back in chapter 1, we were
discussing programming concepts. It’s time
to learn about them along with Python basics.
Building Blocks
Variables
Consider an empty box in your basement that
you can use to store anything. The basement
is like your computer’s memory and that
empty box is a variable. You can have as

many boxes as you can fit in there, but do not
forget that you need some space for other
stuff as well.
It’s the same with variables. It is known as
such because you can change its value
whenever you want. You can assign data to
variables; the instruction is called assignment
statement. In older programming languages,
you had to first reserve space in memory by
declaring the variable name and it’s type
before you could use it in your program. In
modern languages like Python, you don’t
worry about all those things. Having said
that, it is a good idea to know about the
underlying concepts.
On the Python interpreter, try the following
code. Press Enter after each line.
a = 4
print a
The first line a = 4 is an assignment
statement. The symbol ‘=’ is the assignment
operator. We assigned the integer value of 4
to the variable a. Then, in the second
statement, we instructed Python to print the
value of variable a.
You can use any name for a variable, but you

need to keep certain rules in mind.
1. The first letter of a variable name
must be an alphabet.
2. You 
can 
use 
numbers 
for
subsequent letters in a variable
name.
3. You can use uppercase and lower
alphabets in a variable name.
4. The first letter alphabet can be an
uppercase letter, but it’s inadvisable.
We’ll discuss the reason later.
5. Underscore (_) is the only symbol
that can be used in a variable name.
Do you remember the keywords in chapter 1?
Those are special words that a programming
language reserves for operational purposes
that you can’t use as a variable name. Python
has 31 keywords in total, namely:
1. and
2. as
3. assert
4. break
5. class

6. continue
7. def
8. del
9. elif
10. else
11. except
12. exec
13. finally
14. for
15. from
16. global
17. if
18. import
19. in
20. is
21. lambda
22. not
23. or
24. pass
25. print
26. raise
27. return
28. try
29. while
30. with
31. yield

Here’s an example of declaring and
assigning a string variable.
hell0 = “I am fine, thank you”
Here’s an example of declaring a float
variable.
fltpi = 3.14
This is a string assignment.
fltpistr = “3.14 ”
If you want to type a variable, you can use
the type() method. Enter the following line of
code and see the result in Python interpreter:
type(fltpistr)

The output will indicate that the variable
fltpistr contains a string value.
<type 'str'>
Constants
As the name suggests, constants are data
values that have a fixed meaning and can’t be
changed through programming. For example,
number 21 is a constant. It means that the
number 21 can’t be number 20 or anything
else.
Statements
Every instruction that the Python interpreter
can execute is called a statement. A program
is mostly a sequence of statements. So far, we
have 
seen 
two 
statements: 
print 
and
assignment. As you might have noticed, the
assignment statement doesn’t produce any
output. On the other hand, print statement’s
sole purpose is to output data.
Let’s have a little fun, shall we? Type the
following statements in Python and press
Enter after each line.
num = 123

num = num + 7
print num
Did you get confused by the num = num + 7
statement? How can num be equal to num +
7? Remember, ‘=’ is not an equal sign but an
assignment operator. In Python, the right side
of the operator ‘=’ is calculated first, and the
resultant value is assigned to the variable
name on the left. It is the reason why the
following statement will produce a syntax
error. Give it a try.
13 = numerr
Congratulations! By the way, you have
produced the first syntax error in your
Python’s history. Let’s try one more thing
now.
print 1,22,333
I am pretty sure that you are looking at the
output and wondering, “What’s that?” Here it
is:
Awesome work! You have produced the first
semantic error. You used commas in a way
that even though it is the correct way in real-
life, it produced wrong results because
Python treats commas between numbers in a

completely different way.
Here’s the lesson: If you put commas in
between numbers, Python will think that it is
a list of different comma-separated numbers.
If you want Python to treat it as a single
number, you should remove the commas. So,
the following statement will produce the right
result:
print 122333
End of Statements
Many programming languages use semicolon
(;) to create boundary between two lines of
code. 
This 
helps 
in 
writing 
multiple
statements in one horizontal line. Like Basic,
Python uses a new line (Enter) to separate
statements in line with its philosophy of
enhanced readability. This also means that
Python wants the programmer to keep the
statements shorter even if you have to write a
few extra statements to get the job done.
However, there will be times when your
statement will not fit in one display line no
matter how hard you try. In such situations,
you can use the backslash (\) to tell Python
that the next line is a continuation of the
previous one. For example, below lines of

code is a single valid Python statement. Press
Enter after each line.
>>> brkr = \
... 36 + \
... 143
Notice the three dots that the Python
interpreter adds to show that it’s waiting for
the next part of the statement. You can test if
the statement ran correctly by checking the
value of variable brkr. The returned value
should be 179.
>>> brkr
179
Expressions
Expressions are combinations of constants,
variables, and operators that will return a
result in interpreter mode but will not work
when writing a module. For example, in
“Interactive Window”, input number 5 and
press Enter and Python will print it.
>>> 5
5
When writing a module, if you only write 5,
Python will not output 5 when executing the
module. There are a few expressions that can

work standalone, but that’s to be discussed in
a later topic. For now, remember that
expressions usually appear on the right side
of an assignment statement.
Operators
Operators are special characters that represent
mathematical computations. The data points
which the operator is applied to are known as
operands. The operands can be constants,
variables or expressions. Python supports a
wide range of operators, such as:
Arithmetic Operators
1. Addition (+) - adds the operands
2. Subtraction (-) - subtracts one
operand from the other
3. Multiplication (*) - multiplies all
operands
4. Division (/) - divides one operand
with the other
5. Modulus (%) - divides and returns
the remainder
6. Exponential 
(**) 
- 
calculates
exponential values

Comparative Operators
1. (==) - compare if two operands are
equal
2. (!=) - compare if two operands are
not equal - (<>) is similar
3. (>) - if one operand is greater than
the other - (>=) is greater than or
equal to
4. (<) - if one operand is smaller than
the other - (<=) is less than or equal
to
Logical Operators
1. and - Logical AND - true if both
operands are true
2. or - Logical OR - true if any
operand is true
3. not - Logical NOT - negate the
operation it precedes
Assignment Operator
1. (=) - calculate value of right side
operands and assign to left side

operand
One important rule to remember here is the
order of operation. If an expression has more
than one operator.3, which operation will be
given 
precedence? 
Python 
follows 
the
PEMDAS 
rules 
of 
precedence 
that
mathematics follows.
1. The highest precedence belongs to
Parentheses. You can use them to
change the order of operation the
way you want. Parentheses are
sometimes also used to enhance
readability in a long expression.
2. Exponentiation 
has 
the 
second
highest precedence.
3. Multiplication and Division have
the same precedence.
4. Addition and subtraction have the
same precedence.
In case multiple operators have the same
precedence in an expression, they are
evaluated with respect to the left-to-right rule.
Let’s work with a few examples.

>>> 350 + ( 250 * ( 3 - 1 ) ) + ( 350 * 2 )
1550
>>> 7 % 4
3
>>> mon = 2450
>>> mon * ( mon / mon )
2450
We are going to see some more on these
operators in the exercises.
Conditionals
With conditional statements, operators are
applied on operands to make a decision on
the flow of program execution. The operands
can be a variable, constant, or an expression.
The flow of execution of a program can be
controlled with these statements, commonly
known as control flow.
The if statement
With the if statement, the programmer tells
Python to test a condition. In case the result is
true, execute the statements inside the if
statement. Here’s how you can test a simple
if statement.
>>> n = 179
>>> if n == 188:

After this, Python will start outputting the
three dots when you hit Enter after entering a
statement to indicate that the statements are
inside the if statement block. To get out of the
if statement, press Enter again. The whole
process looks like this on the Python
Interactive Window:
>>> n = 179
>>> if n == 188:
... 
print "That's not right!"
...
>>>
No output? Don’t worry; it is because the
print statement didn’t run. The variable n was
assigned 179; that’s why the condition if n ==
188 turned out of the false. It meant that the
print statement never got executed. The code
block inside the if statement is automatically
indented to the right, so it’s easier to
understand which statements will be executed
in case the if statement condition is true.
Python uses indentation to mark different
blocks of code. If you have read Python
documentation, these blocks are referred to as
suites.
Now, what happens if the condition is

true? Let’s try our last piece of code with a
small modification.
>>> n = 179
>>> if n == 179:
... 
print "That's not right!"
...
"That's not right!"
>>>
This time, we see an output on our screen
because the if condition if n == 179 was true.
The question is, can you run a code block
when the if condition is false? Yes, you can.
Here comes the else clause to the rescue.
>>> xcon = 33
>>> if xcon < 25:
... 
print "xcon is smaller"
... else:
... 
print "xcon is larger"
...
xcon is larger
>>>
The variable xcon is assigned the value of 33.
The if condition is false, which leads to the
statement under else clause to be executed.
There’s another clause elif, which is short for
else if. Here’s an example of that.
>>> xcon = 33
>>> if xcon < 25:

... 
print "xcon is smaller"
... elif xcon > 30:
... 
print "xcon is larger"
... else:
... 
print "couldn't determine"
...
xcon is larger
>>>
You can also nest if statements like this:
>>> ynest = 147
>>> znext = "Test"
>>> if znext == "Test":
... 
if ynest > 200:
... 
print "ynest out of range"
... 
elif ynest < 100:
... 
print "ynest too low"
... 
else:
... 
print "ynest within range"
... else:
... 
print "out of scope"
...
ynest within range
>>>
This results in an output of ynest within
range.
Thanks to the logical operators, you can
combine multiple expressions in if statement.

Let’s look at the example below.
>>> ynest = 147
>>> znext = "Test"
>>> if znext == "Result" and ynest == 147:
... 
print "Both conditions are true"
... else:
... 
print "It's a fail"
...
It's a fail
>>>
In the example above, the znext ==
“Result” was false. It made the entire
expression in the if statement to return false.
Remember, and operator will return false
even if only one of the operands is false. It
resulted in the statement under else to be
executed hence the output of “It’s a fail”.
Bonus: Unlike other popular languages,
Python doesn’t have a switch-case statement.
You can create your own version of switch-
case, but it’s not necessary, so we’ll skip it to
keep things from becoming complicated too
soon. The lesson to remember here is that the
if-else-elif conditional statements are your
only source of control flow in the Python
language.

Basic Data Types
Python supports various data types. Some
of them are described below.
Numbers
Every 
programming 
language 
supports
numbers, and Python is no exception.
Integer
A whole number can be either positive or
negative. Here’s an example.
xint = 100099
Floating point
A number comes with a decimal point.
Below is an example.
yflt = 10.0099
Long integers
It is an exceptionally long number that can
be represented using octal or hexadecimal
notation. This is a little tricky, but take note
the trailing “L” in the sample number below.
zlon = 1278495467868413514541L

Complex
Python 
can 
also 
handle 
imaginary
numbers.
cjimg = (5+9j)
Strings
The alphanumeric combination of characters
that can also include special characters is
known as string. They are easily identifiable
because they are enclosed within double
quotes or sometimes within single quotes.
We’ll look into strings in detail very soon.
Taking Input
In Python 2.7, there are two ways of taking
input from user. Let’s take a look at both of
them.
The input() Function
The input() is actually not used in production
coding because it’s not secure. This function
processes whatever user has entered. If it’s a
statement, it executes the statement. It gives

user access to perform actions that it
shouldn’t have. It is also impossible to get a
string through the input() function. Let’s look
at the alternative.
The raw_input() Function
This function is used to take a string input
from the user. Here’s an example:
>>> username = raw_input("Enter your name: ")
Running this line of code will result in a
popup with the prompt “Enter your name: ”.
The entered value will be saved in the
variable username. However, it raises the
question, “Is there a way to get numbers as
input from the user?” Yes, you can use
raw_input and string to integer conversion.
>>> input10 = raw_input("Enter a number: ")
>>> input10
'4877'
>>> input10_int = int(input10)
>>> input10_int
4877
Loops a.k.a. Iterations
Why were computers invented? The basic

reason is to help humans do things that they
are bad at, especially performing repetitive
tasks. Therefore, loops are the primary
ingredient of all programming languages. It
enables programmers to execute the same
code block as many times as necessary.
Generally speaking, if you know the number
of times a block should be executed, you
should use a for loop. Otherwise, you can use
a while loop.
The for loop
For loop is also called definite loop because
you can only use it if you know the number
of times the loop should execute beforehand.
Before we look at an example, we have to
understand two more concepts.
Iterable
Anything that can be used to iterate over in a
for loop is called an iterable. It can be a range
of numbers, a string, a list of values, or
anything that has multiple values associated
with it.

Iterator
An iterator is an entity that’s assigned a value
from iterable during a loop execution. It can
either be used to keep count of the number of
loops performed or contain the value that’ll
be used in the code block within the for loop.
Sometimes, both are performed.
Here’s an example of a simple for loop.
>>> for i in range(1,10):
... 
print i
...
1
2
3
4
5
6
7
8
9
>>>
A few pointers:
1. range() is a special function that can
be used to iterate over numbers by
defining the lower and upper limits.

2. The loop was broken as soon as the
value of iterator became equal to the
upper limit set in the range(). The
code block inside the loop doesn’t
get run for that instance. So, if we
want to print numbers 1 to 10, we
will have to use range(1,11).
By default, range() uses an increment of 1.
You can control that, but remember that you
can only provide an integer value as an
increment to the range(). Otherwise, you will
get an error.
>>> for i in range(1,11,2):
... 
print i
...
1
3
5
7
9
>>>
You can also not specify the lower for the
range() if you like.
>>> for i in range(12):
... 
print i
...
0

1
2
3
4
5
6
7
8
9
10
>>>
Notice how the numbering starts from 0. But
in this scenario, you cannot give out a custom
increment value. To use a custom increment,
you’ll have to give the lower limit even if it’s
a zero.
>>> for i in range(0,12,2):
... 
print i
...
0
2
4
6
8
10
>>>
Bonus: What happens if you lower limit is
greater than the upper limit. Do we get an
error? Let’s give it a try.

>>> for i in range(12,2):
... 
print i
...
>>>
Surprising, isn’t it? There’s no error, just no
output. That’s because the loop initialized but
got 
terminated 
before 
there 
was 
any
possibility to execute the block inside the for
loop. It gives the impression that the
condition is checked at the start of each
iteration. Otherwise, we would have seen at
least on line of output on the screen.
The while loop
Also known as an indefinite loop for a very
good reason that we’ll check out soon, this
loop is used when you don’t know how many
times a loop should run. Therefore, you use
an expression to check for the specific
condition when the loop iterations must stop.
Here’s a simple example of a while loop.
>>> count = 0
>>> while (count < 3):
... 
print "Universe says hi!"
... 
count = count + 1
...

Universe says hi!
Universe says hi!
Universe says hi!
>>>
A few important things to note:
1. You might be wondering why the
output was printed three times when
we used the condition count < 3.
The reason is that we explicitly set
count = 0 at the start. First iteration
occured when count = 0, then once
for count = 1, and then once more
when count = 2. After that, the loop
execution was broken.
2. You have to explicitly update the
operand of the expression used in
the while loop condition, as well as
inside the loop. count = count + 1 is
doing the exact operation. If you
forget to do that, it’ll result in an
infinite loop because the value of
variable count will always remain
zero and the condition to break the
loop count < 3 will never occur. In
olden days, this would have led to a
system crash. In modern computers,

the system might not crash, but the
program execution will definitely
get stuck and your PythonWin
window will become unresponsive.
You’ll have to force shutdown and
restart PythonWin.
Bonus: After the loop execution, check the
value of the count variable.
>>> count
3
Now, if you try to run the same while loop
without resetting value of count to zero,
Python will stop loop execution right away
because the while condition count < 3 is
false.
In short, be very careful when using a while
loop. It’s understood that certain situations
will leave you without any alternative to
using the while loop, but try to avoid it as
much as you can until you are confident with
your coding skills.
Just like conditional statements, loops can be
nested. You can also use for and while loops
together.

Lists
You cannot perform most string operations
until you learn what a list means. Simply put,
a list is a widely used data structure in
Python. It is an equivalent of arrays in other
programming languages. You can easily
recognize a list because it’s enclosed in
brackets. Let’s look at our first list below.
implist = ['7','coffee','omelette',9,'work']
As you can see, we can combine different
data types inside a list. The position of each
item in a list is called index. The first item
has an index zero. It is important to
remember that their positions are fixed.
Here’s how you can retrieve the first item of
the list.
>>> implist[0]
'7'
You can get the number of items in a list using the len()
function.
>>> len(implist)
5
We can use loops to iterate through a list.
Here’s an example of using a for loop on our
list.
>>> for item in implist:

... 
print item
...
7
coffee
omelette
9
work
Here, we used the associative operator “in” to
get each item from the list. Let’s go a few
steps forward with the print statement to get
output meaningful data.
>>> for item in implist:
... 
print 
"Value:",item,"- 
Type:",type(item),"-
Position:",implist.index(item)
...
Value: 7 - Type: <type 'str'> - Position: 0
Value: coffee - Type: <type 'str'> - Position: 1
Value: omelette - Type: <type 'str'> - Position: 2
Value: 9 - Type: <type 'int'> - Position: 3
Value: work - Type: <type 'str'> - Position: 4
To get the index of each item in the list, we
have used the index() method. 
We can use a negative element to get the last
item.
>>> implist[-1]
'work'
We can also change the value of any item in a
list even if the types of current and new data
don’t match.

>>> implist[3] = "Now it's 8am"
>>> implist
['7', 'coffee', 'omelette', "Now it's 8am", 'work']
We can use lists in conditions to check if a
value is in a list to control flow of execution.
>>> if "sleep" not in implist:
... 
print "where's the fun in that"
...
where's the fun in that
We can also add new items in the list using
the method append(). The new item will be
added at the end of the list.
>>> implist.append("lunch at 11")
>>> implist
['7', 'coffee', 'omelette', "Now it's 8am", 'work', 'lunch at
11']
If you want to add a new item at a specific
index, use the inset() method.
>>> implist.insert(1,"shower")
>>> implist
['7', 'shower', 'coffee', 'omelette', "Now it's 8am", 'work',
'lunch at 11']
The remove() method can be used to get
rid of a specific item.
>>> implist.remove("omelette")
>>> implist
['7', 'shower', 'coffee', "Now it's 8am", 'work', 'lunch at 11']
To remove an item by it’s index, we can
use the pop() method.

>>> implist.pop(3)
"Now it's 8am"
>>> implist
['7', 'shower', 'coffee', 'work', 'lunch at 11']
If no index is provided in pop(), the last item
is popped out of the list.
There are various ways to join two lists. We
are looking at one, the extend() method.
>>> offlist = ["weekend","all fun", "no work", 247]
>>> implist.extend(offlist)
>>> implist
['7', 'shower', 'coffee', 'work', 'lunch at 11', 'weekend', 'all
fun', 'no work', 247]
>>> offlist
['weekend', 'all fun', 'no work', 247]
The extend() method added all items from the
list offlist to the end of implist. Note that the
second list offlist remains the same.
Lastly, you can add a list inside a list.
>>> parentlist = [["this ","is ","awesome"],"3 items", 15,
"characters"]
>>> parentlist[0]
['this ', 'is ', 'awesome']
Strings
We already know what strings are. One of
the biggest edge of Python over other

languages is its robust string manipulation.
Python can process string operations very
efficiently and quickly. You can run loops on,
join, break, or convert a string, and these are
just the highlights of dozens of other things
you can do with strings. Let’s learn some new
tricks today.
>>> streg = "154"
>>> type(streg)
<type 'str'>
You can enclose any data type within double
quotes, and Python will consider it as a string.
Amazing, isn’t it? Now, look at the following
code.
>>> strex = "007"
>>> streg+strex
'154007'
When you try to “add” two strings, Python
concatenates them, and the result is another
string. But for this to happen, both variables
should be string. If you try to “add” a string
with a number, Python will throw a type
error, indicating that the types of two
operands don’t match.
>>> intex = 007
>>> streg+intex
Traceback (most recent call last):

File "<interactive input>", line 1, in
<module>
TypeError: cannot concatenate 'str' and
'int' objects
There’s one possibility, though. If I convert
variable intex to a string, it can then be
concatenated with the string streg. How to
convert an integer to a string, you may ask?
Try this:
>>> str(intex)
'7'
It seems very simple, but there’s a catch.
Notice how the leading zeros have been
removed from the output. This is a drawback
when converting an integer to a string. Don’t
feel 
down 
because 
there’s 
several
workarounds to that. One of them is to use
the zfill() method.
>>> str(intex).zfill(3)
'007'
To summarize, we can concatenate a string
with an integer (as shown below).
>>> streg+str(intex).zfill(3)
'154007'
If you want to know how many characters are
there in a string, you can use the len()
function.

>>> longstr = "This string contains 34 characters"
>>> len(longstr)
34
Strings support sequence protocol. Meaning,
you can sequence through the elements of a
string. This is why we can combine len() with
range() in a for loop to iterate over any string
and access each character. Here’s the sample
code:
>>> for i in range(len(longstr)):
... 
print longstr[i],
...
T h i s   s t r i n g   c o n t a i n s   3 4   c h a r
a c t e r s
A few pointers:
1. We are using longstr[i] that’s like
treating a string as a list of
characters 
and 
accessing 
each
element of the list. We will learn
about lists very soon, but for now,
just keep note of the syntax.
2. We used a trailing comma (,) in the
print 
statement. 
This 
instructs
Python to use a single space
between each output of the print
statement. By default, Python adds a

new line (Enter) after each print
output. That would have made the
output take at least one and a half
page in this book.
There are at least half a dozen =ways to
access each character in a string. For now,
let’s just take a look at one more method.
Again, considering the string as a list of
characters, we can use the associative
operator “in” to iterate through a string.
Here’s an example:
>>> for char in longstr:
... 
print char,
...
T h i s   s t r i n g   c o n t a i n s   3 4   c h
a r a c t e r s
It is definitely a more concise way to get the
same output. One thing to remember here is
that the first character of the string is location
zero. For example, here’s the code to get the
first character of the variable longstr.
>>> longstr[0]
'T'
Considering that, the last character will have
a location that’s one number less than the

len() of the string. Here’s an example:
>>> longstr[len(longstr)-1]
's'
Keeping all the above things in mind, we
can also use a while loop to iterate through
the characters of a string. Here’s the code for
the same string longstr:
>>> i = 0
>>> while i <= len(longstr) - 1:
... 
print longstr[i],
... 
i = i + 1
...
T h i s   s t r i n g   c o n t a i n s   3 4   c h
a r a c t e r s
Note that we didn’t need to place len(longstr)
- 1 within parentheses because it is on the
right side of an expression. It’ll always be
calculated first before getting compared with
the value of variable i. For your own clarity,
you can use parentheses, so the while
statement will look like this, while i <= (
len(longstr) - 1 ):. There will be no difference
in the output.
Also, note the difference between the upper
limit on for and while loops. In the for loop,
we used len(longstr) as is. However, in the

while loop, we used len(longstr) - 1.
String Slicing Operations
We can slice a string to create another string
if we know the starting and ending locations.
The format is pretty straightforward.
string[starting 
location:optional 
stopping
location:optional step]
Let’s apply the operation on our longstr
variable.
>>> longstr[5::]
'string contains 34 characters'
The new string is sliced from the longstr
starting from the location 5. Since we didn’t
provide a stopping location, it slices until it
gets to the end of the string. Just like the
range() function, we can supply an integer
value as a step. By default, the step value is
set to one.
If you provide a negative step value, it tells
Python to sequence through the string in the
reverse direction.
>>> longstr[::-1]
'sretcarahc 43 sniatnoc gnirts sihT'
This can be further used in a for loop to access each
character of a string in reverse direction. Here’s how to do

it:
>>> for char in longstr[::-1]:
... 
print char,
...
s r e t c a r a h c   4 3   s n i a t n o c   g n i r
t s   s i h T
This particular output doesn’t make much
sense, but this trick will come pretty handy
when you are dealing with strings during
advanced programming. 
Splitting and Replacing Characters
in a String
Python 
is 
an 
intelligent 
programming
language. Here’s one example.
 

Do you notice the difference? Python
interpreter recognizes the type of variable and
considers it as an object because we put a dot
(.) in the end. Thus, it shows only the
appropriate methods.
Refresher: Do you remember object-oriented
programming where everything is considered
an object? By using split() and replace()
methods, we are invoking the object-oriented
side of Python. We didn’t have to do
anything special since combining different
programming 
paradigms 
seamlessly 
is
another power of Python.
Let’s focus on the string method split().
>>> longstr.split()
['This', 'string', 'contains', '34', 'characters']
The split() method, as the name suggests,
splits a string in positions where it finds a

whitespace. We can pass a character to split()
method, and it’ll split the string wherever it
finds the character in it. Here’s an example.
>>> longstr.split("a")
['This string cont', 'ins 34 ch', 'r', 'cters']
Cool, right? Nowm, let’s replace some
characters in the longstr variable using the
method replace().
>>> longstr.replace(" ","+")
'This+string+contains+34+characters'
We replaced all the spaces with a plus sign.
Let’s revert the changes.
>>> longstr.replace("+"," ")
'This string contains 34 characters'
Bonus: By default, replace() replaces all the
occurrences of the existing characters with
the desired one. Still, we can control it by
telling Python how many occurrences it
should replace.
>>> longstr.replace(" ","+", 2)
'This+string+contains 34 characters'
Only the first two occurrences of space are
replaced with a plus sign. As you can see, the
occurrences are counted from left to right.
Let’s have one round of fun before we move
to a different topic. We can use replace() to

change any number of congruent characters
with the desired characters.
>>> longstr.replace("contains","has")
'This string has 34 characters'
Have you  ever used the find and replace tool
on a word processor? See how easy it is to
implement using Python.
More Data Structures
Dictionaries
Another powerful resource in Python,
dictionaries are the objects of data structures.
Unlike lists, where every item is referenced
through it’s index, every element has a key in
a dictionary. This means that the elements
inside a dictionary have no fixed positions.
Searching individual elements in a dictionary
is fast as Python doesn’t have to iterate
through the entire list to get to the desired
item. With the help of the key, Python knows
exactly where to look to get the right element
from the dictionary.
On the other hand, there are some similarities

between dictionaries and lists.
1. You can change the contents of a
dictionary because it’s mutable.
2. You can nest a dictionary inside
another dictionary. In fact, one
dictionary can contain an unlimited
number of dictionaries.
You can easily identify a dictionary because
it’s enclosed in curly brackets, which is also
called braces. Let’s create a dictionary of
Major League Soccer (MLS) team names as
the values and their origin cities as the
respective keys.
>>> mlsteams = {
... "Atlanta GA": "Atlanta United FC",
... "Bridgeview IL": "Chicago Fire",
... "Cincinnati OH": "FC Cincinnati",
... "Columbus OH": "Columbus Crew SC",
... "Washington DC": "DC United",
... "Montreal QC": "Montreal Impact",
... "Foxborough MA": "New England Revolution",
... "New York City NY": "New York City FC",
... "Harrison NJ": "New York Red Bulls",
... "Orlando FL": "Orlando City SC",
... "Chester PA": "Philadelphia Union",
... "Toronto ON": "Toronto FC"

... }
We can retrieve any element with its key.
>>> mlsteams["Toronto ON"]
'Toronto FC'
To check the length of a dictionary, we can
use len(). It’ll return the number of key-value
pairs in the dictionary.
>>> len(mlsteams)
12
To get a list of all the keys, we can use the
keys() method.
>>> mlsteams.keys()
['Harrison NJ', 'Orlando FL', 'Atlanta GA', 'Cincinnati
OH', 'Washington DC', 'Foxborough MA', 'Montreal QC',
'Bridgeview IL', 'Toronto ON', 'New York City NY',
'Columbus OH', 'Chester PA']
Similarly, to get a list of all the values, we
can use the values() method.
>>> mlsteams.values()
['New York Red Bulls', 'Orlando City SC', 'Atlanta United
FC', 'FC Cincinnati', 'DC United', 'New England
Revolution', 'Montreal Impact', 'Chicago Fire', 'Toronto
FC', 'New York City FC', 'Columbus Crew SC',
'Philadelphia Union']
We can add a new key-value pair to the
dictionary like this. We will use this
opportunity to add a list as the new value.
>>> mlsteams["Future teams"] = ["Inter Miami
CF","Nashville SC","Austin FC","St. Louis"]

>>> mlsteams
{'Harrison NJ': 'New York Red Bulls', 'Orlando FL':
'Orlando City SC', 'Atlanta GA': 'Atlanta United FC',
'Cincinnati OH': 'FC Cincinnati', 'Washington DC': 'DC
United', 'Foxborough MA': 'New England Revolution',
'Future teams': ['Inter Miami CF', 'Nashville SC', 'Austin
FC', 'St. Louis'], 'Montreal QC': 'Montreal Impact',
'Bridgeview IL': 'Chicago Fire', 'Toronto ON': 'Toronto
FC', 'New York City NY': 'New York City FC', 'Columbus
OH': 'Columbus Crew SC', 'Chester PA': 'Philadelphia
Union'}
Notice that the output key-value pairs are not
in the order in which you entered them at the
time of creating the dictionary.
You can use the key with method pop() to
remove a key-value pair from the dictionary.
>>> mlsteams.pop("Future teams")
['Inter Miami CF', 'Nashville SC', 'Austin FC', 'St. Louis']
>>> mlsteams
{'Harrison NJ': 'New York Red Bulls', 'Orlando FL':
'Orlando City SC', 'Atlanta GA': 'Atlanta United FC',
'Cincinnati OH': 'FC Cincinnati', 'Washington DC': 'DC
United', 'Foxborough MA': 'New England Revolution',
'Montreal QC': 'Montreal Impact', 'Bridgeview IL':
'Chicago Fire', 'Toronto ON': 'Toronto FC', 'New York
City NY': 'New York City FC', 'Columbus OH':
'Columbus Crew SC', 'Chester PA': 'Philadelphia Union'}
There are various ways to loop through the
key-value pairs in a dictionary. We’ll test one
such technique using the associative operator

“in” to output both key and value.
>>> for city in mlsteams:
... 
print "City:",city,"- Team:",mlsteams[city]
...
City: Harrison NJ - Team: New York Red
Bulls
City: Orlando FL - Team: Orlando City
SC
City: Atlanta GA - Team: Atlanta United
FC
City: 
Cincinnati 
OH 
- 
Team: 
FC
Cincinnati
City: Washington DC - Team: DC United
City: Foxborough MA - Team: New
England Revolution
City: Montreal QC - Team: Montreal
Impact
City: Bridgeview IL - Team: Chicago Fire
City: Toronto ON - Team: Toronto FC
City: New York City NY - Team: New
York City FC
City: Columbus OH - Team: Columbus
Crew SC
City: Chester PA - Team: Philadelphia
Union
We can check if a key exists in the dictionary

like this.

>>> if "Carson CA" in mlsteams:
... 
print "defunct team present in the data"
... else:
... 
print "data is clean"
...
data is clean
There are various ways to check if a value is
present in the dictionary. Here’s one of them:
>>> if "New York City FC" in mlsteams.values():
... 
print "going to support NYC FC in MLS this year"
... else:
... 
print "going to stick to NFL this year I guess"
...
going to support NYC FC in MLS this
year
Nesting Dictionaries
It might look a little confusing at the start, but
give it time and process it slowly. You will
eventually see that it’s not toocomplex.
Here’s how you can nest dictionaries.
>>> mlsteamsselect = {
... "Washington DC": {
... 
"team": "DC United",
... 
"joined": 1996
... 
},
... "Bridgeview IL": {

... 
"team": "Chicago Fire",
... 
"joined": 1998
... 
},
... "Toronto ON": {
... 
"team": "Toronto FC",
... 
"joined": 2007
... 
}
... }
Our nested dictionaries aren’t complicated,
so retrieving data doesn’t pose a serious
challenge. After all, we already know the
keys.
>>> mlsteamsselect["Toronto ON"]["team"]
'Toronto FC'
Please note that retrieving values from
nested dictionaries, especially if they are
dynamically updated and the keys can
change, is very complex. We are going to
avoid such an issue right now.
Tuples
As mentioned earlier, Python has borrowed a
lot of concepts from mathematics. In simple
terms, a tuple is an immutable version of lists.
You can identify that tuple items are enclosed

in parentheses. All the methods and functions
that are applicable on a list also apply on
tuples, except for the ones that add or remove
list items.
Here’s our first tuple:
>>> tuplenew = (1,"apple",1,"day","keeps the doctor
away")
>>> tuplenew
(1, 'apple', 1, 'day', 'keeps the doctor
away')
The only new trick to learn here is that
there’s a way to change items in a tuple. We
change the tuple into a list, update items, and
transform the list back to a tuple.
>>> listnew = list(tuplenew)
>>> listnew.pop(0)
1
>>> listnew.insert(0,"one")
>>> tuplenew = tuple(listnew)
>>> tuplenew
('one', 'apple', 1, 'day', 'keeps the doctor
away')
Bonus: Sets
Sets contain items in an unindexed and
unordered way. They are enclosed in curly
brackets, which are also called braces. Be

careful as sets look very similar to a
dictionary, even though they are completely
different. There are no keys in sets. Here's a
simple set.
>>> veggies
set(['asparagus', 'broccoli', 'okra'])
You cannot change items in a set, but you
can add new items or remove existing ones.
>>> veggies.add("beet")
>>> veggies
set(['asparagus', 'beet', 'broccoli', 'okra'])
Here’s an example of adding multiple
items using update():
>>> veggies.update(["eggplant","peas","corn"])
>>> veggies
set(['okra', 
'asparagus', 
'corn', 
'peas',
'eggplant', 'broccoli'])
Bonus: 
Try
veggies.update("potato","spinach") and check
the contents of the veggies set.
To remove an item, we can use remove()
method.
>>> veggies.remove("broccoli")
>>> veggies
set(['okra', 
'asparagus', 
'corn', 
'peas',
'eggplant'])
This works like a charm, but there’s a

problem with remove() method. If the
element to be removed by remove() is not
found in the set, it results in an error. To
avoid that, there’s a discard() method for sets,
too.
>>> veggies.discard("peas")
>>> veggies
set(['okra', 'asparagus', 'corn', 'eggplant'])
When using discard() to remove an element,
no error is raised if the element is not present
in the set.
Functions
In Python, you can name a code block and
call it later with its name for execution. The
code block might work on data that you can
pass to the function during the call. These
data points are known as the parameters of
that function. You can have the function
return the result of the work done or not,
depending on your needs.
Let’s create our first function. Here’s a trick
question for you: Can we use len() to count
the number of digits in an integer value? The
answer is no. Is there a way to do it? Yes,

there are multiple ways to do it, some strain
resources more than others. We are going to
write a function that determines the length of
an integer through a very basic technique.
>>> def cntint(num):
... 
count = 0
... 
while (num>0):
... 
count = count + 1
... 
num = num//10
... 
return count
...
The def keyword is used to tell Python that
we are writing a function. We can use any
name as the function name; it has the same
naming convention as variable names. Our
function will be receiving one input; that’s
why only one parameter num declared. When
the while loop stops execution, the variable
count will contain the number of digits in the
integer that will be passed to the function.
Let’s test our function.
>>> cntint(549684)
6
Let’s do one more experiment.
>>> testint = 9751
>>> cntint(testint)
4

It means that we can pass a variable to a
function, and that variable value will be used
as the function parameter. Now, let’s create a
function that uses two parameters. The new
function will output the multiplication table
of a number up to the times that we want.
>>> def mult_table(num,times):
... 
for i in range(1,times+1):
... 
print num,"x",i,"=",num*i
... 
>>> mult_table(8,10)
8 x 1 = 8
8 x 2 = 16
8 x 3 = 24
8 x 4 = 32
8 x 5 = 40
8 x 6 = 48
8 x 7 = 56
8 x 8 = 64
8 x 9 = 72
8 x 10 = 80
Let’s do something fun.
>>> mult_table("eight",10)
eight x 1 = eight
eight x 2 = eighteight
eight x 3 = eighteighteight
eight x 4 = eighteighteighteight
eight x 5 = eighteighteighteighteight

eight x 6 = eighteighteighteighteighteight
eight 
x 
7 
=
eighteighteighteighteighteighteight
eight 
x 
8 
=
eighteighteighteighteighteighteighteight
eight 
x 
9 
=
eighteighteighteighteighteighteighteighteight
eight 
x 
10 
=
eighteighteighteighteighteighteighteighteighte
That actually worked! It goes to show that
multiplication can be applied on a string.
This is intriguing. Let’s create another
function.
>>> def sum_var(num1,num2):
... 
print num1+num2
...
>>> sum_var(1237,"all good?")
Traceback (most recent call last):
File "<interactive input>", line 1, in
<module>
File "<interactive input>", line 2, in
sum_var
TypeError: unsupported operand type(s)
for +: 'int' and 'str'
All is not good apparently! This highlights

the fact that it is important to create exception
handling when writing functions because
there can be a data type mismatch resulting in
an execution breaking error. Exception
handling is a technique used to take care of
situations when an error can occur. In case an
error happens, execution doesn’t stop, and
you can change the execution flow to follow
an alternate approach.
The Concept of Recursion
In most programming languages, including
Python, a function is allowed to call itself.
This technique is quite useful in certain
situations. However, utmost caution should
be observed since recursion can lead to an
infinite loop if it's not implemented properly.
That can result in a  system crash or at least
in Python process becoming unresponsive.
Classes
Classes are used in Python to create objects.
In real life, when you have to construct an
object, you create a blueprint. Class fulfills

the same purpose for creating objects in
Python. Let’s create our first class.
>>> class firstclass:
... 
x = 789
...
The variable x is called a class property.
Now, using the class, we can create new
objects.
>>> obj1 = firstclass()
>>> obj1.x
789
As you can see, the property of the class has
become a method of the object created with
it. We can add  function as a property to the
class. In fact, there’s a function __init__()
that must be a part of every class you create.
It is used to initialize a class so that it can be
used to declare class properties and values or
any dependencies.
Have you ever played a video game? In most
video games, there are non-player characters
that are only controlled by the computer.
They can have any purpose according to the
requirements of the game. Let’s create a class
for non-player character.
>>> class npcprofile:
... 
def

__init__(instance,type,name,hp,shield,specialmoves):
... 
instance.type = type
... 
instance.name = name
... 
instance.hp = hp
... 
instance.shield = shield
... 
instance.specialmoves = specialmoves
...
The first property instance in the __init__() is
used to denote the title which Python will use
to internally call each object created with the
npcprofile 
class. 
When 
passing 
data,
remember not to pass any data for the first
parameter.
Now, let us use the class to create a foot
soldier object.
>>> npc1 = npcprofile("Grunt","Foot Soldier",50,0,[])
You can check all the values very easily.
Let’s create a final level boss object.
>>> npc2 = npcprofile("Final Level Boss","General
X",500,500,[5,"Hammer Deagle","Double Trouble
AK47","Nevermiss Dragunov","Stunning
Grenade","Rapidfire RPG"])

This boss is going to take some time to get
beaten, for sure.
If you want to update any object property,
you can do something like the example
below.

>>> playerattack = 75
>>> if playerattack > 50:
... 
npc1.hp = 0
...
>>> npc1.hp
0
You can use the del command to delete entire
objects or a specific property.
>>> del npc1.specialmoves
>>> >>> del npc2
Working with Libraries
As mentioned many times in the book
already, Python can be extended to meet
specific project requirements. To highlight
this point, we are going to work with an
external library matplotlib which enables you
to create 2D line charts (also called graphs or
plots) using Python.
Here’s an advantage of choosing PythonWin:
it is pre-packaged with the matplotlib library.
If 
we 
had 
chosen 
another 
Python
environment, we would have to install
matplotlib library with the help of pip. Since
matplotlib is an external library, it’s not

loaded when Python starts. We have to
import it before we can use it. Here is how to
do that:
import matplotlib.pyplot as plt
When you import something, Python searches
for it in the paths registered in its system. If
you want to know which paths Python
searches for looking for the library or
module, here’s the code:
>>> import sys
>>> for eachpath in sys.path:
...    print(eachpath)
...
You’ll get a bunch of paths. If you are
creating your own scripts, place them in one
of these paths so that it’ll be easier to import
them. Still, it’s not necessary as we’ll see
later.
Keep in mind that the process might take a
while. If your Python screen becomes
unresponsive, don’t force-close it. Instead,
give it a minute to return to normal. For our
example, we are only calling the pyplot
collection of functions from the matplotlib
library. These functions can be used to plot a
graph and change various parts of the graph.
Let’s plot our first graph.

>>> plt.plot([1,2,3,4])
[<matplotlib.lines.Line2D 
object 
at
0x000000000B1DFEB8>]
The output confirms that the plot has been
created, as well as where it’s residing in the
memory. Right now, the plot is hidden. We
can make changes to the graph before we tell
Python to show us the graph.
>>> plt.ylabel("Some numbers")
Text(0,0.5,u'Some numbers')
>>> plt.xlabel("Some numbers")
Text(0.5,0,u'Some numbers')
The outputs confirm that the labels for the x
and y axes have been updated. Let’s take a
look at the plot.
>>> plt.show()
A new, small window will pop up on your
screen showing the plot. It should look like
this:

At the bottom-left corner of the window, you
can see a row of buttons, each offering
different functionality. You can resize the
window if you want to look at a bigger plot.
You can also see the custom labels we set for
the x and y axes.
It was a simple straight line plot. We can
create different types of 2D plots. We can
also customize the look of the plot. Let’s look
at another example:
>>> plt.plot([1,2,3,4],'ro')
>>> plt.ylabel("Some numbers")
>>> plt.xlabel("Some numbers")
>>> plt.show()

Here’s the output:
It’s the same plot but instead of a solid blue
line, we are seeing four red dots because we
added the optional string ‘-ro’. The default is
the string ‘-b’ which is for the solid blue line.
We can control the axes limits with the
following statement.
plt.axis([0, 6, 0, 20])
The first two numbers are for x-axis and the
last two for y-axis. Let’s create a script, add
following line of codes, and save it with the
name firstplot.py.
import matplotlib.pyplot as plt
plt.plot([1,2,3,4], [1,4,9,16], 'ro')

plt.axis([0, 6, 0, 20])
plt.show()
Let’s run the script. If you saved the file in
the folder where Python is saved, you can run
the script like this.
>>> import firstplot
To conserve resources, Python only runs
import once for each entity. Subsequent runs
of the command import firstplot will do
nothing. We have an alternative: in Python
2.7, you can use the execfile() function to run
any file as long as you have it’s complete
path. This is also useful if you are saving
your scripts in a folder other than where
Python is installed. One advantage that
execfile() gives us is that we can use it as
many times as we want to run our script. For
example, let’s grab the file path from
Windows.
We see that the path of our file is
D:\Python27\myScripts\. 
You 
will 
use
execfile like this.
>>> execfile('D:/Python27/myScripts/firstplot.py')

Note how all the backward slashes in the path
you got from Windows were replaced by
forward slashes because execfile() doesn’t
recognize backward slashes in a file path.
As soon as you run the script, the plot will
appear on your screen and should look like
this:
As long as this graph is visible, you won’t be
abl e to do anything in the interactive mode.
The 
matplotlib 
offers 
too 
many
functionalities for plotting different data that
it’s impossible to cover here. We used this
example to show how we can import an
external library into Python and work with it.

At this stage, you may be wondering if we
can release imported libraries from memory
to free up some resources. As mentioned
earlier in the case of variables, Python
automatically manages resources to deliver
optimum performance. As soon as Python
recognizes that it doesn’t need to allocate
resources to an external resource, it’ll do as
such. There are certain techniques to force-
remove objects from memory and caches, but
it’s highly unrecommended.
Debugging
Debugging is the process of fixing any errors
that happens during program execution.
Python outputs a traceback, which is its way
of producing all the details about the error to
help you find and fix it. It can contain the line
number and the type of error that has taken
place. Python also highlights the position
where it has encountered the issue with a
caret sign.
In case you have made multiple errors,
Python stops at the first error it stumbles

upon, stops execution, and outputs the
traceback. This is one of the biggest
differences between an interpreter and a
compiler language. In a compiler language
like C, if you make multiple errors, you get
an error report detailing all the errors.
Sometimes, it can be too overwhelming,
especially for new programmers.
Types of Errors in Python
In Python, errors are broadly classified
into two types.
Syntax Errors
Sometimes called parsing errors, syntax
errors happen if you add an extra string or
character or forget to add the required ones.
We have encountered syntax error before.
Let’s recreate a situation that leads to a
syntax error. Enter the following line of code
in the Interactive Mode.
>>> for i in range(0,11):
... 
print "This will produce a syntax error
As soon as you press Enter, you will see

Python produce the following:
We missed the right quotation mark, which
led to the syntax error.
Index Error
If you try to access information from a
collection data structure with an index that
doesn’t have any data, you will get an index
error. Here’s an example:
>>> list1 = ["python","is","cool"]
>>> list1[5]
Traceback (most recent call last):
File "<interactive input>", line 1, in <module>
IndexError: list index out of range
Type Error
This happens if you do an operation on data
that they don’t work with. For example, try to
add an integer and a string.
>>> int1 = 143
>>> str1 + int1
>>> str1 + int1
Traceback (most recent call last):

File "<interactive input>", line 1, in <module>
TypeError: cannot concatenate 'str' and
'int' objects
Fun fact: If you do int1 + str1, you will also
get a type error, but the explanation will be a
little different.
>>> int1 + str1
Traceback (most recent call last):
File "<interactive input>", line 1, in <module>
TypeError: unsupported operand type(s)
for +: 'int' and 'str'
Name Error
If you use an object that you didn’t assign or
declare a value beforehand, Python will
throw a name error.
>>> list1 = ['python', 'is', 'cool']
>>> list2
Traceback (most recent call last):
File "<interactive input>", line 1, in <module>
NameError: name 'list2' is not defined
Import Error
You will see this error if you try to import
something and Python isn’t able to find.
Remember that Python only searches in the

file paths registered with it.
>>> import myownmodule
Traceback (most recent call last):
File "<interactive input>", line 1, in <module>
ImportError: 
No 
module 
named
myownmodule
>>> from math import triangle
Traceback (most recent call last):
File "<interactive input>", line 1, in <module>
ImportError: cannot import name triangle
Again, 
same 
error 
but 
two 
different
descriptions.
There are many other exceptions in Python,
but we are going to limit our discussion to the
types mentioned above.
Logical Error
This error takes place when your problem-
solving logic is flawed. This is the most
difficult to find and fix because everything is
fine for Python. There will be no syntax
errors or exceptions, but the output will not
be 
what 
you 
had 
expected. 
Program
execution will not stop; there will be no
traceback detailing the error either. You will
be on your own. Scary, isn’t it?

Let’s look at an example where a logical error
is happening. We are going to program the
equation but consciously make a logical error
to illustrate a point. Here’s the equation we
are coding: 
import math
x = 100
y = x / 2 * math.pi
print y
When you save and run the script, you will
get:
157.079632679
This is not the correct result. If you use a
calculator, the result should have been 15.91
with a value of 100 for x. Meaning, there’s
something wrong with our script, but Python
didn’t find it.
The reason here is that we made a logical
error. If you look at the expression y = x / 2 *
math.pi closely, you will notice that Python is
following PEDMAS. It means that if there are
multiple operators with the same priority,
Python will work from left to right. It’s
dividing x by 2 and then multiplying the
quotient by the pi value. The correct way is

that 2 should be multiplied with pi before x
gets divided by their product.
To fix this logical error, you should update
the expression with parentheses like below.
Save the script and do a rerun.
y = x / ( 2 * math.pi )
Now, you should see the correct result:
15.9154943092
Exceptional Handling
Except when a syntax error occurs, you can
code to handle all situations that might result
in an error. Here’s how we can do that.
>>> try:
... 
print(varint)
... except:
... 
print "An exception has occured!"
...
An exception has occured!
The code block inside “try” is tested for an
exception. If one happens, the code block
inside the “except” is executed. In this case,
varint wasn’t assigned a value, so it resulted
in an exception that led to the execution of
the code inside “except”.

If you want to execute code if no exception is
raised, use “else” (as seen below).
>>> varint = 100
>>> try:
... 
print(varint)
... except:
... 
print "An exception has occured!"
... else:
... 
print(varint)
...
100
100
This time around, we have assigned a value
to varint. Notice that the code block inside
the “try” also gets executed in case there’s no
exception. This is why we see two output
lines.
We can execute code irrespective of whether
an exception is raised or not by the code
block in “try” as well. We can use “finally”
for that.

>>> x = "I am assigned"
>>> try:
... 
print x
... except:
... 
print "An exception has occured!"
... finally:
... 
print "Hurray! No exception occured."
...
I am assigned
Hurray! No exception occured.
Best Debugging Practices
All the error examples we saw are pretty
straightforward and easy to fix. However, as
you will advance towards creating more
complex 
programming 
techniques, 
you
should know that debugging errors will
become more challenging. It is a good idea to
learn the best practices to avoid making
errors and resolve them if you end up making
some.
Algorithms and Flowcharts
Before you start programming, always write
an algorithm. This helps you think about the
task, the requirements, and the problem-

solving process. This is the stage where you
should be optimizing your approach. Once
you start coding, it will be difficult to change
your approach, and you might make more
mistakes. Creating a flowchart helps you
determine the dependencies of your solution.

Commentation
You should add comments to your code
because you may forget what or why you did
something specific. This helps in catching
bugs later on or if you decide to optimize
your code. It also makes your code derivable
so that it will be easier for another person to
use or build upon it in the future.
Dry Run
This is actually something that many modern
programmers don’t do. It is perhaps because
of the modern debugging tools available now
or because people have stopped handwriting
most stuff. This is a tradition of running the
code on a piece of paper. You go through
your code line by line like an interpreter and
right down all the updates. This is also a good
way of catching bugs but may not be feasible
if your program has hundreds of lines of
code.
Test Unexpected Behavior
If you are creating a solution that other
people will use, you should test your program

with unexpected inputs. For example, if your
program is expecting user to input an integer,
there’s a chance that the user might enter a
float or even a string. Either can break your
code if it doesn’t have proper exception
handling.
Debugging Tools
Python has a standard debugging tool pdb
that you can use for your program. There are
also external tools available out there in case
you are looking for more options. We will
briefly look into the pdb debugging tool, but
let’s update our firstplot.py script first.
import matplotlib.pyplot as plt, pdb
pdb.set_trace()
plt.plot([2,4,6,8], [3,6,9,12], 'ro')
plt.axis([0, 10, 0, 15])
plt.show()
The line where pdb.set_trace() is placed is
where Python pdb debugger will start tracing.
When you run the script now, you’ll see a
small window popping up along with some
information on the Interactive Window.

This small window is where you can pass
commands to the pdb debugger. Here is a list
of some pdb commands that you can use to
debug your script.
1. (s)tep - execute the line where
debugger is currently at
2. (c)ontinue 
- 
execute 
until 
a
breakpoint is encountered (It’ll
execute to the end of script if no
breakpoint is found.)
3. (n)ext - execute until the start of
next line in a function or until the
function returns
Use “n” in the popup to keep executing each
line in your script. It’ll execute each line and
show the next line.
Exercises

1. Write a program that takes input
user’s name and displays it 10 times
on the screen.
2. Write a program that takes string
input from the user and counts the
number of spaces in it.
3. Write a program that takes the user's
state as input and returns the zip
code range for that state. You can
easily find the zip code ranges for
every US state on the internet.
4. Write a program that outputs all the
prime numbers between the number
range inputted by the user.
Write a program that gets three numbers as
input from user and outputs the largest
number.

I
CHAPTER FOUR
INTEGRATION WITH PYTHON
n this chapter, we will briefly look into
Python’s capabilities to interact with
completely different systems. Our goal is to
showcase Python’s flexibility. From here on,
you should start placing codes within files
and executing them because some of them
might not work as expected in Python
interpreter’s Interactive Window.
Integration 
With 
OS:
Windows

Get File Path
You can very easily get the file path where
the python file is currently residing. It takes
only two lines of code (as third line is just the
output).
import os,sys
pathname=os.path.dirname(sys.argv[0])
print pathname
If you try to execute this code in Interactive
Window, you’ll see an empty output. Place
the lines in a file and then save and run it to
view the correct output. The output path will
not contain the actual filename. We have
imported two standard libraries “os” and
“sys” that help us interact with most
Windows 
functions. 
This 
is 
another
advantage of picking PythonWin for coding
Python on Windows.
Working With a Text File
Let’s create a text file with Python and write
“Hello, Universe!” in it.
import os,sys
a=os.path.dirname(sys.argv[0])
link=os.path.join(a,"firstfile.txt")

text=open(link,'w')
text.write("Hello, Universe!")
text.close()
The last line saves the file and is very
necessary; otherwise, the file will remain
open in the background. Now, if we want to
read to file, we can do so as follows:
text=open(link,’r’)
filetext = str(text.read())
print filetext
text.close()
The “r” and “w” arguments in open() tell
Python if we want to open, file, read, or write
data. We can also delete the file with a single
line of code:
os.remove(link)
If the file is open, you’ll get an error. You
won’t be able to delete the file before closing
it.
Integration with MS Office
It’s even easier to interact with applications
running on Windows. In this chapter, we are
going to take advantage of the Windows
applications 
COM 
system 
that 
helps
interacting with Windows application easily.

Working with Excel Files
As an example, for MS Office, we are going
to create an MS Excel workbook, rename the
sheet, put some data on it, save the file, and
exit.
import os, sys                          
import win32com.client as win32
pathname=os.path.dirname(sys.argv[0])
excel=win32.gencache.EnsureDispatch('Excel.Application'
excel.Visible=True
wb=excel.Workbooks.Add()
ws=wb.Worksheets('Sheet1')
ws.Name='Python Created'
ws.Cells(1, 1).Value = "With"
ws.Cells(1, 2).Value = "Python"
ws.Cells(1, 3).Value = "2.7"
raw_input() # This is only to hold the screen
so you can see the excel file. You don’t need
to even enter anything, just click on OK and
program execution will continue
filename = os.path.join(pathname,'firstexcelfile.xlsx')
wb.SaveAs(filename,win32.constants.xlOpenXMLWorkbo
workbook
excel.Application.Quit()
This will place an Excel file in the same
folder where you will save the script file. The

win32com.client enables Python to interact
with 
and 
take 
control 
of 
Windows
applications. This is exclusively available
with 
PythonWin. 
The 
expression
excel.Visible=True keeps the excel workbook
visible; otherwise, everything will run in the
background.
Integration with Java
You can run Java codes within Python with
the help of Py4J external library. For starters,
install the library with pip. Note that you’ll
need Java installed on your system, too.
python -m pip install py4j
Our purpose isn’t to learn Java in this book,
so we are going to look at an example of Java
code here that we’ll later run in Python.
import py4j.GatewayServer;
public class AdditionApplication {
public int addition(int first, int second) {
return first + second;
}
public static void main(String[] args) {

AdditionApplication app = new
AdditionApplication();
// app is now the gateway.entry_point
GatewayServer server = new
GatewayServer(app);
server.start();
}
}
Python will run the Java code and get
variable values to print the output. To run the
above code in Python, here’s the Python
code:
from py4j.java_gateway import JavaGateway
gateway = JavaGateway()                   # connect to the
JVM
random = gateway.jvm.java.util.Random()   # create a
java.util.Random instance
number1 = random.nextInt(10)              # call the
Random.nextInt method
number2 = random.nextInt(10)
print(number1, number2)
addition_app = gateway.entry_point               # get the
AdditionApplication instance
value = addition_app.addition(number1, number2)) # call
the addition method
print(value)
In the second line gateway = JavaGateway(),
the comment says “connect with JVM”, not

“start JVM”. This is an important point. Py4J
doesn’t have the capabilities to start JVM, so
you must do it yourself before using Python
to run Java codes.
Integration with MySQL and
MS Access
Working with MySQL
MySQL is the most popular database
framework for small- and medium-scale
applications. To work with MySQL with
Python, we have to install the external library
mysql-connecter using the pip.
python -m pip install mysql-connector
Once installed, we can start working with a
database.
import mysql.connector as mysql
myfirstdb = mysql.connect(
host="localhost",
user="yourusername",
passwd="yourpassword"
)
print(myfirstdb)

For the “yourusername” and “yourpassword”,
you need to enter the username and password
that you like for the database. The print
statement should output an object, confirming
that 
a 
database 
connection 
has 
been
established.
Password Generation
You can use Python to create secure MD5
hash passwords. By using MD5 hashing, you
can convert a string called key into a hash of
characters that you can use as a password. As
long as you keep the key safe, it’s almost
impossible to crack a MD5 password. Here’s
the code to get a string input from user and
generate a password with it:
import hashlib
getkey = raw_input("Enter your key to generate MD5
password: ")
print hashlib.md5(getkey).hexdigest()
We have used the hashlib library that gives us
the capability to generate a MD5 hash.
Create a Database
To create database, we have to create a cursor
instance that will allow us to execute SQL

commands on our database.
cursor = myfirstdb.cursor()
cursor.execute(“CREATE DATABASE myfirstdb”)
If you want to see the list of databases present
in the system, use the following lines of code:
databaselist = cursor.fetchall()
print databaselist #print the complete list of databases
# if you want to output each database
separately
for database in databaselist:
print database
Create Tables
Database is a collection of data tables. If we
don’t create any tables, there’s no purpose for
a database. Let’s connect to one that we
created and add a table to it.
db = mysql.connect(
host = "localhost",
user = "yourusername",
passwd = "yourpassword",
database = "myfirstdb"
)
cursor = db.cursor()
cursor.execute("CREATE TABLE users (name
VARCHAR(255), user_name VARCHAR(255))")

Now, let’s create a primary key that will help
access each row uniquely, as well as add data
to the table.
cursor.execute("CREATE TABLE users (id INT(11) NOT
NULL AUTO_INCREMENT PRIMARY KEY, name
VARCHAR(255), user_name VARCHAR(255))") #
create primary key to access each row
query = "INSERT INTO users (name, user_name)
VALUES (%s, %s)"
values = ("Anthony", "Martial")
cursor.execute(query, values)
db.commit()
There are many things you can do with a
database using Python.
Working With MS Access
If you work extensively with MS Office
product suite, you may use MS Access for
your projects. Just like MS Excel, it is very
easy to connect and manage a MS Access
database using Python.
Here’s a sample code that connects to MS
Access 
database 
named
“DATA_DUMP.mdb”. The code accesses the
database table “A_BTS” and selects the cell
values in columns “bscId”, “bcdId”,  and

“btsId” where the column cell ID has value
“65213”.
import os, sys
import win32com.client as win32
conn = win32.Dispatch("ADODB.Connection")
pathname=os.path.dirname(sys.argv[0])
filename=os.path.join(pathname,"DATA_DUMP.mdb")
db = r"%s"%filename
DSN="Driver={Microsoft Access Driver
(*.mdb)};DBQ=" + db
conn.Open(DSN)
rs = win32.Dispatch("ADODB.Recordset")
rs.Open( "A_BTS", conn, 1, 3 )
cmd = win32.Dispatch("ADODB.Command")
cmd.ActiveConnection = conn
cell="65213"
cmd.CommandText = "SELECT bscId,bcfId,btsId FROM
A_BTS WHERE cellId=%s;"%cell
(rs, result) = cmd.Execute()
Exercises
1. What is an operating system? Name
a few famous operating systems.
2. Is MS Office the only software suite
that provides spreadsheet and word-

processing applications? Can you
think of any alternatives?
3. Besides MySQL and MS Access,
are there any other platforms that
deal with database management?
4. Take a number input from user and
create a multiplication table of that
up to times 10 and output the table
in a text file.
5. Copy the text file you just created to
the desktop of your computer.
Find any text files in the folder where the
script is and add a random number between
1000 and 9999 at the end of their filename.
For example, multiplicationtable.txt should
become
multiplicationtable_randomnumber.txt.

W
CHAPTER FIVE
WORKING WITH FILES
e have already explored some of the
options in the last chapter. Now, we are
going to look into advanced techniques
for Excel, PDF, and Word files.
Excel Spreadsheets
MS Excel is arguably the most popular
spreadsheet software in the world. Not only
you can perform advanced statistical analysis,
but you can also automate everything with
the help of macro recording. If you know
Visual Basic, you can customize the macros

to gain even more advantage. If you know
Python, though, you don’t need macros or
Visual Basic.
Opening and Closing Spreadsheets
We have already seen how we can open an
MS Excel file if we already know the file
path. We want to enable the user to browse
their computer and select the file that we
should use in our program. To make it
happen, we are going to briefly look into the
Python’s standard library for GUI, the
Tkinter. This may be a difficult name to
pronounce, but it is extremely powerful in
providing 
GUI 
services 
to 
Python
programmers.
Here’s the code that’ll enable the user to
select a file. Then, we can get the file path
from it.
import Tkinter,tkFileDialog
root = Tkinter.Tk()
root.withdraw() #use to hide tkinter window
file =
tkFileDialog.askopenfile(parent=root,initialdir="/",mode='r
a file')
if file != None:

print file.name
If we want to restrict the file type that the
user can open, we can do so by adding type
arguments to the tkFileDialog.askopenfile().
Modify that line for Excel files.
import Tkinter,tkFileDialog
root = Tkinter.Tk()
root.withdraw() #use to hide tkinter window
file =
tkFileDialog.askopenfile(parent=root,initialdir="/",mode='r
a file',filetypes = (("All Excel files","*.xl*"),("All
files","*.*")))
if file != None:
print file.name
Parsing Data
To learn this topic, we are going to use the
file that we have created while learning about
MS Excel in the previous chapter. With the
MS Excel file path, we can now open the file
using the following command:
import win32com.client as win32
excel=win32.gencache.EnsureDispatch('Excel.Application'
excel.Visible=True
wb=excel.Workbooks.Open(file.name)
Alternate Approach

There are different ways to read the data on
an Excel file, which is the first part of the
process 
called 
data 
parsing. 
Broadly
speaking, parsing is the analysis of data
syntax. Since we are using PythonWin, we
can use the available library “xlrd” to read the
Excel file data. Here’s a sample code to open
an Excel file using “xlrd”:
wb = xlrd.open_workbook(file.name)
When you use “xlrd”, you might not be able
to see the changes because the process is
performed in the background. Also, you
might have problems with “.xlsx” files. You
can, however, combine both approaches to
the previous one to view the Excel file and
read the data.
Now, you can access the sheets in the file
through either their name or index.
ws = workbook.sheet_by_name('Sheet1') # get sheet by
title
ws = workbook.sheet_by_index(0) # get sheet by position
Using sheet titles is more reliable because
you can change the position of sheets. To get
the value of the first cell, use the following
statement:
print ws.cell(0, 0).value
Note that the first cell of the excel for xlrd

has row = 0 and column = 0. This is a bit
different than when we used our approach in
the previous chapter (where first cell had an
index of row = 1 and column = 1). You can
easily create a for loop to read all the data
from the Excel file by building upon this
method. One important thing to remember
here is that if you try to use an index that
doesn’t have any set value, you’ll get an
error. For example, the following code will
generate an index error:
print ws.cell(0,3).value
If you look at the file you created previously,
the cell with position row = 0 and column = 3
doesn’t have a set value. The above statement
will result in an error.
The order traceback will look like this:
Traceback (most recent call last):
File "D:\Python27\Lib\site-
packages\PythonWin\pywin\framework\scriptutils.py",
line 326, in RunScript
exec codeObject in __main__.__dict__
File "D:\Python27\myScripts\openandparse.py", line 16,
in <module>
print ws.cell(0,50).value

File "D:\Python27\lib\site-packages\xlrd\sheet.py", line
408, in cell
self._cell_types[rowx][colx],
IndexError: array index out of range
To work around this, we can get the number
of rows and columns in a sheet.
print “number of rows:”,ws.nrows # get number of rows
print “number of columns:”,ws.ncols # get number of
columns
Modifying Spreadsheet Data
We can use another library “xlwt” to write
data in the Excel file. We will have to install
the library using pip.
python -m pip install xlwt
Writing data is a bit easier because you do
not have to worry about any cell’s row and
column. We can use a for loop to update data
on a spreadsheet. Here’s a sample code:
import xlwt
wbw = xlwt.Workbook(encoding="utf-8")
wsw = wbw.add_sheet("Python Created")
wsw.write(0, 0, "Using xlwt to fill a cell")
wbw.save("D:/Python27/myScripts/chapter
5/secondexcelfile.xls")
The xlwt library has one limit, though, as it
can only create MS Excel files with the older

“.xls”. Excel will recognize the file and open
it but in compatibility mode. We can use
some other library to create “.xlsx” files, such
as xlsxwriter, or our initial method to read
Excel files to create “.xlsx”. Let’s try the
latter option to create an Excel file by
assigning the header of “Index” to column A
and populating column A with numbers 2 to
10.
import os, sys
import win32com.client as win32
#create data array
i = 2
data_array = []
while i < 11:
data_array.append(i)
i = i + 1
#write the array to an excel file
excel = win32.Dispatch("Excel.Application")
excel.Visible = True
wb = excel.Workbooks.Add()
ws = wb.Worksheets(1)
ws.Cells(1,1).Value = "Index" # create column header
#single loop, writing a column
for line in data_array:
ws.Cells(line,1).Value = line

pathname=os.path.dirname(sys.argv[0])
filepath=os.path.join(pathname,"secondexcelfile.xlsx")
wb.SaveAs(filepath,win32.constants.xlOpenXMLWorkboo
# cleaning up resources
ws = None
wb = None
excel.Quit()
excel = None
Working with PDF and Word
Documents
Word Documents
Using PythonWin to work with MS Word is
almost similar to using MS Excel. Here’s the
code that starts a MS Word process, creates a
document, adds data to it, and saves it with
the name “firstwordfile.docx” in the same
folder where you would have saved this
script.
import os, sys
import win32com.client as win32
word =
win32.gencache.EnsureDispatch('Word.Application')
doc = word.Documents.Add()

word.Visible = True
RANGE = range(1, 11)
rng = doc.Range(0,0)
rng.InsertAfter('Python Created\r')
for i in RANGE:
rng.InsertAfter('Line %d\r' % i)
rng.InsertAfter("Hello, Universe!\r\r")
pathname=os.path.dirname(sys.argv[0])
filepath=os.path.join(pathname,"firstwordfile.docx")
doc.SaveAs(filepath)
word.Application.Quit()
Opening an existing Word document is easy.
Here’s the complete code:
import Tkinter,tkFileDialog
import win32com.client as win32
import os, sys
root = Tkinter.Tk()
root.withdraw() #use to hide tkinter window
file =
tkFileDialog.askopenfile(parent=root,initialdir="/",mode='r
a file',filetypes = (("All Word files","*.doc*"),("All
files","*.*")))
if file != None:
print file.name
filepath_str = str(file.name)

filepath = filepath_str.replace("/","\\")
print type(filepath)
print filepath
word =
win32.gencache.EnsureDispatch('Word.Application')
word.Visible = True
doc = word.Documents.Open(filepath)
doc.Activate()
docText = doc.Content
doc.Close(0)
word.Application.Quit()
To make things easier, we can install a library
called python-docx using pip.
python -m pip install python-docx
Once installation is done, we can use it to
read data from any Word document. Note that
we can use this library for “.docx” Word files
only.
import Tkinter,tkFileDialog
import docx
root = Tkinter.Tk()
root.withdraw() #use to hide tkinter window
file =
tkFileDialog.askopenfile(parent=root,initialdir="/",mode='r
a file',filetypes = (("All Word files","*.doc*"),("All
files","*.*")))
if file != None:

print file.name
filepath_str = str(file.name)
filepath = filepath_str.replace("/","\\")
print type(filepath)
print filepath
doc = docx.Document(filepath)
print len(doc.paragraphs)
This will give you the number of paragraphs
in the document. If you want to get all the
text in a Word document, here’s a sample
code:
fullText = []
for para in doc.paragraphs:
fullText.append(para.text)
return '\n'.join(fullText)
You can also apply any style available in MS
Word to any part of the document. For
example, let’s try the “Normal” style to the
first paragraph.
doc.paragraphs[0].style = “Normal”
To get an individual sentence in a paragraph
and apply a style to it, here’s a code. Note
that each sentence is referred to as a run.
doc.paragraphs[1].runs[0].underline = True
To save the changes in a new file, use this command:
doc.save("D:/Python27/myScripts/chapter
5/restyledfirstwordfile.docx")

You can also add an image to the end of the
document with the following command:
doc.add_picture('filepath/image.png',
width=docx.shared.Inches(1),
height=docx.shared.Cm(4))
Add the images’ full file path in the first
argument. The width and height arguments
are optional, but you can use them to specify
a certain size. If width and height aren’t
provided, the image will be added in the
default size. Note that in Word, images are
sized in physical units like inches (in) and
centimeters (cm).
To add a page break, use this command:
doc.paragraphs[3].runs[3].add_break(docx.text.WD_BREA
To create line breaks, you just have to add a new
paragraph.
doc.add_paragraph('This is the next paragraph!')
You can also add a heading.
doc.add_heading('Title Heading', 0)
The first argument is the heading text while
the other one defines the heading level which
can go from 0 to 4.
PDF Documents
The Portable Document Format (PDF)
documents are the undeclared standard of

transmitting documents over the internet.
There have been many changes to PDF
documents over the years as they now
support so much more features. To extract
data from a PDF file, we are going to use an
external library called PyPDF2. There are
later versions of this library as well, such as
PyPDF3 and PyPDF4. However, the only
major difference in the later versions is their
support for Python 3+ versions.
This library has one limitation: it only allows
you to extract textual content from the PDF
files. Sometimes, the library will fail to
extract text from a PDF file or the extracted
data might be corrupted.
Let’s install the library.
python -m pip install PyPDF2
Once installed, we can start working with
PDF files. Here is the code to get the number
of pages in a PDF named “example.pdf”:
import PyPDF2
import os, sys
pathname = os.path.dirname(sys.argv[0])
filepath = os.path.join(pathname,"example.pdf")
pdffile = open(filepath,'rb')
readpdf = PyPDF2.PdfFileReader(pdffile)

print readpdf.numPages
For me, the PDF file contained 2 pages, so I
got the same output. We can extract the text
content for a specific with the codes below.
pdfpage = readpdf.getPage(0)
pdfpage.extractText()
Note that the first page has an index 0. So, the
last 
page 
will 
have 
an 
index
readpdf.numPages - 1.
PDF files are sometimes encrypted. We can
check if the file is encrypted with the
following command:
readpdf.isEncrypted
If the output returned is true, you will not be
able to extract text from the file. If you have
the password — let’s say it is “securedpdf”
— you can decrypt the file.
readpdf.decrypt(“securedpdf”)
We can also use PyPDF2 to create PDFs.
However, since you are not able to edit a
PDF, you cannot add text or any media to this
new PDF file. During creation, you can
source content from other PDFs and
performing page operations like rotation,
overlay, and encryption.
import PyPDF2
import os, sys

pathname = os.path.dirname(sys.argv[0])
filepath = os.path.join(pathname,"example.pdf")
filepathnew = os.path.join(pathname,"examplenew.pdf")
pdffile = open(filepath,'rb')
readpdf = PyPDF2.PdfFileReader(pdffile)
writepdf = PyPDF2.PdfFileWriter()
for pagenum in range(0,readpdf.numPages):
pdfpage = readpdf.getPage(pagenum)
writepdf.addPage(pdfpage)
newpdf = open(filepathnew,'wb')
writepdf.write(newpdf)
newpdf.close()
pdffile.close()
The addPage() will only add new pages at the
end of the document. You cannot insert pages
in between others.
You can rotate after getting the page. As an
example, let’s rotate the first page by 90
degrees.
pdfpage = readpdf.getPage(0)
pdfpage.rotateClockwise(90)
PyPDF2 only allows you to rotate a page in
90 degree increments.
You can build upon the above codes to read
pages and content from different PDF fields
and merge them into a single PDF file.

Working With CSV and JSON
Data
This is relatively easy. Python can work with
Comma Separated Values (CSV) files and
(JavaScript Object Notation) JSON files
separately.
Interacting with CSV Files
There is a standard library in Python aptly
named “csv” that enables programmers to
open csv files and parse available data.
Let’s add the following data in a csv file,
name it “familynfriends_bday.csv”, and save
it in a folder where we will save the
following code:
name,relation,birthday month
Samantha Sam,mother,November
Samuel Jones,father,August
Sasha Sam,sister,March
Samuel Jones Jr.,self,June
Here’s the code to read the csv data:
import csv
import os, sys
pathname=os.path.dirname(sys.argv[0])
filepath =

os.path.join(pathname,"familynfriends_bday.csv")
with open(filepath, mode='r') as csv_file:
csv_reader = csv.DictReader(csv_file)
line_count = 0
for row in csv_reader:
if line_count == 0:
print 'Column names are',row.keys()
line_count += 1
print row['name'],"who is my",row['relation'],"has
birthday in",row['birthday month']
line_count += 1
print 'Processed',line_count,"lines"
This will yield the following:
>>> Column names are ['birthday month',
'relation', 'name']
Samantha Sam who is my mother has
birthday in November
Samuel Jones who is my father has
birthday in August
Sasha Sam who is my sister has birthday
in March
Samuel Jones Jr. who is my self has
birthday in June
Processed 5 lines
Each row is read as a dictionary with the keys
taken from the first row and the data from the
relevant row. In a dictionary, the order is lost;

that's why the column names don’t appear in
the first output line. In the sequence, they are
present in the csv file.
To write a csv file, we can create a dictionary
and pass the dictionary content to the csv file.
import csv
import os, sys
pathname=os.path.dirname(sys.argv[0])
filepath = os.path.join(pathname,"friends_bday.csv")
with open(filepath, mode='w') as csv_file:
fieldnames = ['Friend Name', 'How long we have been
friends?', 'Month']
writer = csv.DictWriter(csv_file,
fieldnames=fieldnames)
writer.writeheader()
writer.writerow({'Friend Name': 'John Smith', 'How long
we have been friends?': '9 years', 'Month': 'November'})
writer.writerow({'Friend Name': 'Erica Meyers', 'How
long we have been friends?': '10 months', 'Month':
'January'})
Interacting With JSON Data
JSON has become the main technique of
website data parsing. It evolved from the
Javascript subset that deals with syntax of
objects. With time, it has grown so much that

it now how separately developed standards
that 
are 
completely 
independent 
from
Javascript.
Here’s a sample of JSON data.
{
"firstName": "Michel",
"lastName": "Scott",
"hobbies": ["mentoring", "godfather", "love"],
"age": 40,
"children": [
{
"firstName": "Sam the dog",
"age": 6
},
{
"firstName": "Bob the builder",
"age": 8
}
]
}
Yes, it looks very much like a nested
dictionary, but dealing with JSON cannot be
that simple. Luckily, Python has a built-in
library to read and write JSON.
import json
jsondata = '{"name": "Joshua", "age": 30, "city":
"Boston"}'
pydata = json.loads(jsondata)
print pydata[‘name’]

The JSON object was converted to a Python
dictionary. The above code will produce
“Joshua” when executed.
Whenever you convert JSON to Python or
vice versa, data objects are converted to their
equivalent counterpart. Here’s a table that
shows the conversion pattern.
Python
JSON
Dictionary
Object
List
Array
Tuple
Array
String
String
Integer
Number
Float
Number
True
true
False
false
None
null
To convert Python data to JSON, we can use
the dumps() method. Refer to the following

example.
import json
newpydata = {
“name”: “Trevor”,
“age”: 29,
“married”: True,
“orphan”: False,
“children”: [“Suzie”,”Billy”],
“pets”: None,
“cars”: (
{“model”: “Audi A7”, “year”: 2017},
{“model”: “Dodge Caravan”, “year”: 2015}
)
}
newjsondata = json.dumps(newpydata)
print newjsondata
This will yield the newly converted JSON
data that looks like this:
>>> 
{"name": 
"Trevor", 
"cars":
[{"model": 
"Audi 
A7", 
"year": 
2017},
{"model": "Dodge Caravan", "year": 2015}],
"age": 29, "married": true, "orphan": false,
"pets": null, "children": ["Suzie", "Billy"]}
It might be hard to read, but there are
formatting options when using dumps()
method. For example, we can add an indent

for each line of data.
newjsondata = json.dumps(newpydata, indent=4)
We can also use custom separators and
control the data sorting.
newjsondata = json.dumps(newpydata, indent=4,
separators = (“. ”,” = ”), sort_keys = True)
The output will now look similar to this:
>>> {
"age" = 29.
"cars" = [
{
"model" = "Audi A7".
"year" = 2017
}.
{
"model" = "Dodge Caravan".
"year" = 2015
}
].
"children" = [
"Suzie".
"Billy"
].
"married" = true.
"name" = "Trevor".
"orphan" = false.

"pets" = null
}
Exercises
1. Create 
an 
ordered 
dictionary.
Meaning, 
when 
you 
produce
dictionary content, it should be in
the same order that the key-value
pairs were added to the dictionary.
2. From the user, take the following 10
inputs and create an Excel file and
populate the first row with the titles
below. Then, the second row should
have the user inputs.
a. First Name
b. Last Name
c. Age
d. Zip code
e. Education
f. Driver? Yes/No
g. Height
h. Weight
i. Time spent on cell phone
j. Commute time to work

3. Add a new sheet in the Excel file
created. Rename it as “Extra Sheet”.
4. Reverse all the inputs you gathered
from the user and add it to “Extra
Sheet”.
5. Save the excel file using the “Save
As” option from Tkinter.
6. Create an Excel file with the
extension “.xls” and add the prime
numbers between 0 and 10,000. Use
two columns of the Excel file to
produce the numbers.
7. Manually download the PDF file
from 
the 
URL
http://www.africau.edu/images/defau
and read all the data.
8. Save all the data read from the PDF
file to a MS Word document.
9. Take inputs from user, asking for 20
random numbers, and store in a csv
file. Then, access the CSV file and
find the largest number.
10. Convert 
the 
largest
number to JSON data.

I
CHAPTER SIX
ADVANCED CONCEPTS
f you think that we have been doing
advanced work with Python, you will be
surprised by this chapter. Let’s hear it
again: Python is a very powerful language!
You can perform complex tasks and schedule
them to achieve complete automation.
Scheduling Tasks
Task scheduling is relatively easy on a
Windows system. You can use the “Task
Scheduler” available by default on all
Windows 
installations 
to 
arrange 
the

execution of a Python script you have
programmed.
Click on the Windows logo on the bottom-
left side of your screen and search for “Task
Scheduler”. 
From 
the 
list, 
open 
the
application 
with 
the 
same 
name. 
On
Windows 10, the application will look this:
Click “Create Basic Task”. A new window
named “Create Basic Task Wizard” will pop
up.
Here are short descriptions for your options:

1. Provide 
a 
name 
that 
you’ll
recognize easily later on. You can
also provide a description to help
you remember what the task’s
purpose is. Click “Next”.
2. Now, you can select a trigger. It can
be a specific time or event that
happens in a Windows application
or system. For our example, let’s
choose the first option “Daily”.
3. Pick 6:29pm everyday and today’s
date as starting point. Keep one in
the recur field. Click “Next”.
4. Now, we have to set an action that
Windows should take when the
trigger happens. We will keep the
option “Start a program” selected
because that’s what we want to do.
Click “Next”.

5. Enter the parameters of the program
we want to run. To execute a Python
script, it’s advisable to run the
Python first and then pass the script
as an argument. For example, if you
want 
to 
schedule 
the 
script
D:\myscript.py and the executable
Python 
is 
located 
at
C:\Python27\python.exe, here’s how
you should enter the details.
Now, when you click “Next”, you will see
a summary of the task.

Click on “Finish” and the task will be
scheduled.
This is a very nifty way to automate your
daily activities.
Windows has Batch (.bat) files that are
Windows script files. To schedule a task, an
alternative approach is to create a batch file
and schedule it using the Windows “Task
Scheduler”. In the batch file, we can add
instructions to run the Python script. To
schedule the execution of our D:\myscript.py
file, we can add the following instruction to
the batch file:
C:\Python27\python.exe "D:\myscript.py"
When we started with the Task Scheduler, we
chose the “Create Basic Task” on the first

screen. Below that, there was an option
“Create Task” that offers advanced options to
create the task.
Web Scraping
While learning about Python’s package
manager pip, we installed an external library
called Scrapy. Before we jump into action,
though, let’s talk about web scraping.
In the last decade, data science has started to
affect the life of every human being in the
world. Everything is data. Every action you
take online and sometimes even in real life
are recorded by someone and processed to
sell you something. If you have seen any tech
industry documentary on Discovery or
National Geographic, you may have heard the
phrase “Data is now more valuable than oil.”
I don’t necessarily agree with the notion, but
it might be true. The point for debate is if
people want their actions to be recorded and
analyzed. With service providers doing data
analysis online, it looks like there’s no choice
for the end user.
Nevertheless, data science also helps society

and improves the lives of commoners. You
can find numerous researches based on data
collection and analysis that have led to better
actions. It is already a fact that humans are
habitual species, after all. By analyzing their
past actions, you can form a pattern and
predict their future actions in certain
situations. What’s the limit of that? That’s up
for debate.
The concept of web scraping is that anything
you can or cannot see on a website can be
scraped. Web scraping can be very beneficial
for developing new products that require data
that you don’t have resources to collect. For
example, you want to create a mobile
application that tells farmers daily sunrise
time and synchronize their alarms or maybe
setup reminders.
In the near future, smart homes will become a
reality. You may want to create an
application that pulls the bedroom’s curtains
as the first sun rays come through the
window! For this purpose, it’s not possible to
start collecting data about sun’s movement
yourself. The task will be much easier if you

have access to a weather forecasting service
or NASA’s solar system data. If they post the
relevant information on their website, you
can write a script to crawl it on their website
and extract the required pieces. On the other
side of the spectrum, it’s a very easy tool to
steal copyrighted material from a website.
This is why ethics is very important when it
comes to data science and web scraping.
Let’s start learning web scraping with
Python.
As a first step, we need to setup a project
using Scrapy. Open the command prompt —
yes, the one you use to install Python libraries
— and change directory to where you want
the project files to reside using the cd
command. After that, enter:
scrapy startproject myfirstspider
To scrape data from websites, we need to
create a crawler. It is also called a spider
because it crawls through the required areas
of given website. Since this is our first
scraping 
project, 
we 
have 
named 
it
“myfirstspider”. You can name it anything
you like. In truth, you might want to,

especially if you don’t like spiders! After
running the command, a folder will be
created in the path that you had decided on
before. In our case, the folder name is
“myfirstspider” 
that 
resides 
in
D:\Python27\myScripts\chapter 6\.
Now, 
we 
have 
to 
update 
the 
file
\myfirstspider\myfirstspider\settings.py 
and
create our customized spider inside the
\myfirstspider\myfirstspider\spiders\ folder.
In the settings.py file, we have to make two
changes. 
First, 
uncomment 
the
ITEMS_PIPELINE tuple if it’s commented
out and edit it to look like this:
#Export as CSV Feed
FEED_FORMAT = "csv"
FEED_URI = "reddit.csv"
This is because we are going to save the
scraped data in the reddit.csv file in the
location 
D:\Python27\myScripts\chapter
6\ourfirstscraper\reddit.csv.
Now, in the command prompt, add the
following command to create a customized
spider 
inside 
the
\myfirstspider\myfirstspider\spiders\ 
folder
using a standard template:

scrapy genspider redditbot
www.reddit.com/r/gameofthrones/
The new spider is named redditbot, and we
will be scraping thread titles and image from
the Games of Thrones Reddit page.
If 
you 
open 
the
\myfirstspider\myfirstspider\spiders\redditbot.
file, you’ll see the following:
import scrapy
class RedditbotSpider(scrapy.Spider):
name = ‘redditbot’
allowed_domains 
=
[‘www.reddit.com/r/gameofthrones’]
start_urls 
=
[‘http://www.reddit.com/r/gameofthrones’]
def parse(self, response):
pass
A few pointers:
1. We can give any name of the spider.
For 
now, 
we 
are 
calling 
it
“redditbot”.
2. The allowed_domains is optional.
We are setting access permissions
for the crawler, limiting the domains

it can crawl.
3. The parse function will be called
every 
time 
a 
webpage 
is
successfully crawled.
We have the update the start_urls argument in
the class RedditbotSpider.
start_urls = ['https://www.reddit.com/r/gameofthrones/']
We corrected the URL so that it has the
secured https argument. This is very
important. If a website is secured, you will
not be able to scrape data using the unsecured
http URL. Here’s the code block that you
should paste instead of the default parse
function definition:
def parse(self, response):
#Extracting the content using css selectors
title
=  response.css('h3._eYtD2XCVieq6emjKBH3m::text').ext
images_url =
response.css("img::attr(src)").extract()
#Pass the extracted content row wise
for item in zip(titles,images_url):
#create a dictionary to store the scraped info
scraped_info = {
'title' : item[0],

'images_url': item[1],
}
#yield or give the scraped info to scrapy
yield scraped_info
There are different ways to find required data.
We are going to use the css class values of
html to extract the text content and image
URLs. We are extracting the title and
featured image of all the threads on the Game
of Thrones reddit homepage. With the
extracted data, we create a dictionary and
pass it to scrapy for processing with the yield
statement. Since we have opted for CSS file
output, the extracted data will be present in
the folder we set in the settings.py.
After 
editing 
and 
saving 
the
\myfirstspider\myfirstspider\spiders\redditbot.
file, you can start the crawler by going to the
command prompt and running the following
command:
scrapy crawl redditbot
Make sure you have changed the working
directory in the command prompt to where
you created the redditbot scraper. If you fail
to change the directory, you will get a syntax

error when you try to execute the command
scrapy crawl redditbot.
You will see dozens of lines outputted on the
command prompt as a result of the crawl
command. It might look similar to this:
After the crawl is complete, you can go to the
folder 
D:\Python27\myScripts\chapter
6\ourfirstscraper\ to read the scrapped content
from the reddit.csv file. The csv file output
might look like this:
As you can see, we have the URLs of the
images. The scrapy library also allows direct
download of the images. For that, you need to
add the following lines of code in the

settings.py:
ITEM_PIPELINES = {
'scrapy.pipelines.images.ImagesPipeline': 1
}
IMAGES_STORE = 'folder path where you want to
download the images'
Make sure to remove or comment the CSV
output lines if you want to download the
images. Otherwise, the scraping might not
work as expected.
You can further customize the spider to
scrape large amount of different content. The
biggest advantage of scrapy library is that it
supports multithreading, so you can access
multiple data points simultaneously. This is
very helpful if you are scraping extremely
large sites with tons of data.
There are other scraping libraries available on
Python. One of them is Beautiful Soup,
which is a lot simpler to work with than
Scrapy. However, it’s not suitable to work on
large projects as it cannot access multiple
content at the same time. Scraping one image
from a website is a piece of cake, but to
scrape 100 images, you’ll need to access each
image individually.

Manipulating Images
There is a reason why we were focusing on
image scraping in the previous section.
Python is very savvy with image processing,
you see. For a common user, when we say
image 
processing, 
it 
means 
resizing,
cropping, rotating, or applying different color
filters. Such tasks are quite easy to do with
Python. But before we dive into action, we
have to learn a few basic concepts.
Images are a 2D collection of pixels. Each
pixel contains either the color value that
should cover that area. An iPhone X camera
in standard mode, for instance, takes a picture
that has 4032 pixels in width and 3024 pixels
in height. That’s a lot of pixels stacked
together. No matter how large an image is, it
can be represented by a mathematical matrix.
Furthermore, 
there 
are 
a 
number 
of
mathematical operations that you can perform
on a matrix. Armed with this knowledge, let’s
start working with image manipulation.
We need the pillow and numpy libraries,
which are all included in PythonWin.

import os, sys
from PIL import Image
import numpy as np
pathname=os.path.dirname(sys.argv[0])
filepath = os.path.join(pathname,"test.jpg")
image = PIL.Image.open(filepath)
image.show()
The above code will open the test.jpg image
in the default application on Windows. The
image has a resolution of 4961 x 3594 and a
size of 4.07MB. Let’s resize the image to a
smaller resolution. By the way, you can also
check the image resolution on Python this
way:
print image.size
Let’s resize image to a square 300 x 300 size.

resized_image = image.resize((300,300))
resized_image.show()
Note how the width and height is given in a
tuple. Here’s the output.
As you can see the resized image doesn’t
have the aspect ratio of the original image.
Let’s create a solution for this problem.
basewidth = 300
wpercent = (basewidth/float(image.size[0]))
hsize = int((float(image.size[1])*float(wpercent)))
resized_image = image.resize((basewidth,hsize),
Image.ANTIALIAS)
resized_image.show()
Here’s the output:

We are using the width = 300 as our
reference point and calculating the required
height to keep the aspect ratio. The
Image.ANTIALIAS is a filter that makes the
image look not grainy upon a resize to a
smaller size. Let’s now see how we can crop
the image.
resized_image = image.crop((2644,1540,3220,1856))
We supply a tuple of left, top, right and
bottom coordinates again. The output looks
like this:

We can also do a mathematical trick that will
help us crop the horizontally and vertically
aligned central part of the image. Here’s the
code to do that:
width, height = image.size
left = width/4
top = height/4
right = 3 * width / 4
bottom = 3 * height / 4
resized_image = image.crop((top,left,right,bottom))
This is the output:
We can rotate the image by a single
method.
resized_image = image.rotate(315)
Here’s the output:

Remember when we said that an image is just
a large matrix of pixels? We are going to use
that idea to change colors of the image. Let’s
check the image for some information with
the following command:
img_array = np.array(image)
print img_array.shape
The output for our image is:
(3594L, 4961L, 3L)
The first two numbers are the resolution of
the image. The third number, 3L, denotes the
color scheme of the image. To convert the
image to grayscale, we just need to update the
3L to L. Here’s the code and output for that:
resized_image = image.convert("L")

Let’s convert the image to black and white.
There are different algorithms available
online that you can use for this, but we are
going with the most simple solution.
Specifically, we will take the grayscale image
and use a value of 100 as our threshold. For
all pixel values greater than 100, we are
going to reset them to 255, while all other
values will be rest to zero. Note that 255
means white and zero means black. Here’s
the code to do that:
threshold = 100
gray_image = image.convert("L")
img_array = np.array(gray_image)
for i in range(0, len(img_array)):
for j in range(0, len(img_array[i])):

if img_array[i][j] >= threshold:
img_array[i][j] = 255
else:
img_array[i][j] = 0
bw_image = PIL.Image.fromarray(img_array)
bw_image.show()
Depending upon how large your image is,
this process can take a while. Here’s the
output. Cool, right?
Automating Emails and Text
Messages
Email Messages

To send emails with Python, we will need to
sign up with an email service like Gmail. For
testing purposes, we can create a local Simple
Mail Transfer Protocol (SMTP) server but not
use it to send emails.
To set up a Gmail account, go to gmail.com
and sign up with an email ID. It is advisable
to create a separate ID even if you have a
Gmail account because we’ll have to lower
security level on this account for it to work
with Python. (Read: It would be vulnerable to
hacking.) During account setup, don’t choose
the two-step verification option. Once it is
ready, go to Account Security settings and
turn on the “Allow less secure apps” option.
With the Gmail account setup, we need to
choose a Python library that’ll be able to use
that account to send emails. We are going to
use the SMPT_SSL() module of the standard
smtplib library to create a secure connection
with Gmail and send an email. Here’s the
code that you need:
import smtplib, ssl
port = 465  # For SSL
smtp_server = "smtp.gmail.com"

password = input("Type your password and press enter: ")
# Create a secure SSL context
context = ssl.create_default_context()
# Email body
sender_email = "new_id@gmail.com" # gmail address
you signed up
receiver_email = "xyz@gmail.com" # receiver's address
message = """\
Subject: Hi there
This message is sent from Python."""
with smtplib.SMTP_SSL(smtp_server, port,
context=context) as server:
server.login(sender_email, password)
server.sendmail(sender_email, receiver_email,
message)
This is a good example to send a plain text
email.
Meanwhile, to send an html formatted email,
we’ll have to make use of standard mime
libraries available in Python. Note that
formatted html emails are sometimes blocked
by email clients, so it’s a good idea to
combine plain text and html parts in one
email. We are going to follow this practice in
our example.

import smtplib, ssl
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
port = 465  # For SSL
smtp_server = "smtp.gmail.com"
password = input("Type your password and press enter:")
sender_email = "new_id@gmail.com" # gmail address
you signed up
receiver_email = "xyz@gmail.com" # receiver's address
message = MIMEMultipart("alternative")
message["Subject"] = "Testing multipart email sending"
message["From"] = sender_email
message["To"] = receiver_email
# Email body with plain text and formatted html parts
text = """\
Hi,
I hope you are doing well."""
html = """\
<html>
<body>
<p>Hi,<br>
How are you?<br>
I hope you are doing well!
</p>
</body>
</html>
"""

# Convert email body parts to MIME objects
part1 = MIMEText(text, "plain")
part2 = MIMEText(html, "html")
# Join MIME objects to create MIME message
message.attach(part1)
message.attach(part2)
# Create secure connection with server and send email
context = ssl.create_default_context()
with smtplib.SMTP_SSL(smtp_server, port,
context=context) as server:
server.login(sender_email, password)
server.sendmail(
sender_email, receiver_email, message.as_string()
)
One last thing we are going to look at is how
to send attachments. These are the extra lines
that you’ll have to add an attachment. In this
example, we are sending a PDF file as an
attachment.
# Open PDF file in binary mode
with open(filename, "rb") as attachment:
# Add file as application/octet-stream
part = MIMEBase("application", "octet-stream")
part.set_payload(attachment.read())
# Encode file in ASCII characters to send by email
encoders.encode_base64(part)

# Add header as key/value pair to attachment part
part.add_header(
"Content-Disposition",
f"attachment; filename= {filename}",
)
# Add attachment to MIME message
message.attach(part)
This template can be further enhanced to send
emails to multiple addresses. It is important
to note that the free Gmail server in use has
limits on sending and receiving emails over
certain periods of time. It might be a good
idea to use sleep() to create delays in sending
emails. Also, Task Scheduling can be used to
send a fixed amount of emails every day.
Text Messages
To send text messages, you’ll need to get a
third-party subscription to use their network
gateway. Twilio is one of the most popular
online services that can integrate with Python
quickly. After getting a Twilio subscription
and 
receiving 
the 
account 
ID 
and
authorization token, we can start by installing
the Twilio library in Python.
python -m pip install twilio

Sending a message is very easy, thanks to
Twilio’s awesome API. Here’s a sample
code:
from twilio.rest import Client
account_sid =
'ACXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
auth_token = 'your_auth_token'
client = Client(account_sid, auth_token)
message = client.messages \
.create(
body="Hello, Universe!",
from_='your_number',
to='receiver_number'
)
print(message.sid)
Change the account_sid and auth_token
values from the values in your Twilio
account. Also, alter the “from” number to the
one bought from Twilio. Add the number you
want to send the text to in the “to”. Save the
code with the name “send_sms.py”. After
executing the code, the message will be sent
right away and delivered in a few minutes.
GUI Automation

We have already seen many GUI elements in
previous chapters. Taking input and asking
users for files and folders by selection has
been a good practice. What if we can take
control of the input devices and have them
interact with GUI elements automatically? It
can help us do trivial tasks, such as filling out
forms or accepting ToS on websites.
We can use the external library pyautogui for
this. On Windows, we will not need any other
library, so let’s install this particular library
and start working with it.
python -m pip install pyautogui
Word of caution: Letting Python take control
of the mouse and keyboard means you are
forfeiting your control over them. In case
your code is buggy, you might lose control
indefinitely. Then, it’ll be very hard to shut
down the program execution due to not
having any input. Even if your coding isn’t
faulty, Python can use the input devices faster
than the application it’s interacting with. It’s
very important to plan for contingencies in
such situations. For instance, you can pull
your desktop’s power cord or perform hard

shutdown on the laptop whenever you want,
but the damage might already be done by
then.
The good thing about pyautogui is that it has
built-in pause and failsafe features. The
failsafe is activated when the mouse moves to
the upper-left corner of the screen. You can
turn on the failsafe and set the pause value to
number of seconds before you start working.
import pyautogui
pyautogui.FAILSAFE = True
pyautogui.PAUSE = 1
Now, let’s see what’s the current screen
resolution is to know your playing field size.
pyautogui.size()
Once you have the screen size, you can start
moving your mouse.
Mouse Automation
for i in range(10):
pyautogui.moveTo(100, 100, duration=0.25)
pyautogui.moveTo(200, 100, duration=0.25)
pyautogui.moveTo(200, 200, duration=0.25)
pyautogui.moveTo(100, 200, duration=0.25)
This will move the mouse in a square pattern

in the clockwise direction. Each movement
will happen in 0.25 seconds as set in the
moveTo() method. In the above example, the
pixel coordinates given are fixed. You can
also move the mouse relative to its current
position.
pyautogui.moveRel(100, 100, duration=0.25)
To get the current mouse position, use the following:
pyautogui.position()
Now, to have the mouse click, we can use the method
click().
pyautogui.click(10, 5)
The coordinates provided to the click()
method are real, not relative. This is a full
click, which means pressing and releasing of
the 
mouse 
button. 
You 
can 
use
pyautogui.mouseDown() 
and
pyautogui,mouseUp() for  specific mouse
button actions. The pyautogui.doubleClick()
offers even more as it’ll perform a double
click with the left mouse button. You can
automate 
a 
right 
click 
with
pyautogui.rightClick() and a middle button
click with pyautogui.middleClick().
To 
perform 
dragging, 
you 
can 
use
pyautogui,dragTo() and pyautogui.dragRel(),
which have similar functions to moveTo()

and moveRel(). However, this time, the
mouse button will remain clicked during the
cursor 
movement. 
To 
automate 
the
mousewheel to perform scrolling, there’s the
scroll() that takes an integer value as a unit of
how much screen should move up (positive
value) or down (negative value). The integer
values will behave differently on different
screen sizes and operating systems. Scrolling
will begin from the current cursor location.
Furthermore, you can even take a screenshot
with pyautogui.
img_screen = pyautogui.screenshot()
Keyboard Automation
The pyautogui.typewrite() can be used to
virtually press keys on the keyboard. The
result will depend on the application currently
active. You can pass any string value to
typewrite(), and it’ll be typed in the current
window by automating keypresses. We can
add a delay so that every letter in the given
string will be typed after a pause of specified
duration.
pyautogui.typewrite(“Hello, Universe!”, 0.25)
To press keys that are not letter, such as

Enter, there are special strings denoted that
makes it easier to automate their keypress.
For example, the Enter button has string
“enter”. Likewise, Escape key has “esc”, and
“right” is for Right Arrow key. Here’s a table
to show all the strings assigned to different
keypresses.
Key String
Me
'a', 'b', 'c', 'A', 'B', 'C', '1', '2', '3', '!',
'@', '#', and so on
keys 
charac
'enter' (or 'return'or '\n')
ENTE
‘esc’
ESC k
‘shiftleft’, ‘shiftright’
Left 
SHIFT
‘altleft’,’altright’
Left 
ALT k
‘ctrlleft’,’ctrlright’
Lef
CTRL
‘tab’ or ‘\t’
TA
‘backspace’,’delete’
BA

and 
keys
‘pageup’,’pagedown’
PA
PAGE
keys
‘home’,’end’
HO
END k
‘up’,’down’,’left’,’right’
AR
‘f1’,’f2’,’f3’ and so on...
F1 
‘volumeup’,’volumedown’,’mute’
VO
contro
(Your 
might 
keys, 
system
be 
recogn
comm
‘pause’
PA
‘capslock’,’numlock’,’scrolllock’
LO

‘insert’
INS
INS ke
‘printscreen’
PR
SCRE
PRTSC
‘winleft’,’winright’
Lef
WIN 
(Wind
We can also type special characters. The
following code will have a dollar sign ($)
typed on the screen automatically.
pyautogui.keyDown('shift')
pyautogui.press('4')
pyautogui.keyUp('shift')
To perform actions like “copy” (where you
have to press CTRL and C keys together),
you 
can 
have 
the 
following 
shortcut
approach:
pyautogui.hotkey('ctrl',’c’)
Exercise
Create a Python script that scrapes one quote
from http://quotes.toscrape.com/.

T
CONCLUSION
hank you for finishing this book. It has
been quite a journey. I hope you are now
prepared to take on more challenging
tasks with Python. The purpose of this book
was to build the basics and spark the curiosity
by giving you a glimpse into the strengths of
Python.
Once you have developed good skills with
Python 2.7, learning Python 3.0+ will be a
breeze. There are not many changes, and
Appendix B will help you get started on it.

APPENDICES
Appendix 
A: 
Answers 
to
Exercises
Chapter 1
A1. 
01010100 
01101000 
01101001
01110011 00100000 01101001 01110011
00100000 01110100 01101000 01100101
00100000 01100010 01100101 01110011
01110100 00100000 01100010 01101111
01101111 01101011 00100000 01100101
01110110 01100101 01110010 00100001
A2. 54 68 69 73 20 69 73 20 74 68 65 20

62 65 73 74 20 62 6f 6f 6b 20 65 76 65 72 21
A3. Python was created in the year 1991.
A4. Niklaus Wirth developed Pascal.
A5. No, Python is a modern high-level
language.
A6. Data was punched as a hole onto the
card. The presence and absence of a hole was
interpreted by computers to read information
from a punch card.
A7. Perl was invented to process text files
efficiently.
A8. Basic was designed by John G.
Kemeny and Thomas E. Kurtz.
A9. The algorithm for the Bahamas
vacation goes like this:
1. Start with financial planning.
2. Get extended leave approved from
your work.
3. Research online for the vacation
package that fits the budget and
book it, but choose to pay later.
4. Call local travel agencies and haggle
for better prices.

5. If you are successful in step 2, book
with the local agency or finalize
online booking payment.
6. Surprise 
the 
family 
with 
the
vacation announcement.
7. Start the preparation by going
shopping. Make sure not to go over
budget.
8. Enjoy the vacation with your loved
ones.
A10. Here is the flowchart for the
Bahamas vacation:

Chapter 2
A1. We are using Windows operating
system based platform to learn Python in this
book.
A2. We are using the most famous
ActivePython 2.7 from ActiveState and

getting extra benefits by adding Mark
Hammond’s (PythonWin) to it.
A3. 
Without 
Mark 
Hammond’s
contributions over the years, it would never
have been possible for Python to thrive on
Windows platform.
A4. ActiveState ActivePython, PyCharm,
and PyPy
A5. Spyder, Thonny, and PyCharm
A6. Python’s package manager is called
pip.
A7. print “Hello, Universe!”
A8. print “Andrew Warner!”
Note: You should use your own name in
place of Andrew Warner.

A9. Follow the instructions in Chapter 2
under the subheading “What Is a Module?” to
create, save, and run a module. You can name
the file as “my-name.py”. There will only be
a single line of code. (Note: You should use
your own name in place of Andrew Warner.)
print “Andrew Warner!”
A10. By installing Mark Hammond’s
PythonWin, we have already setup the
pywin32 package that provides useful tools to
perform various tasks on Windows.
Chapter 3
A1.
urname = raw_input("Please enter your
name: ")
for i in range(1,11):
print "%d- %s" % (i, urname)

A2.
getstring = raw_input("Please enter a
sentence: ")
space = " "
count = getstring.count(space)
print "Here is your sentence: "+getstring
print "The number of spaces in your given
sentence is: %d" % count
A3.
zipcoderange = {
"AK" : ["99501-99950"],
"AL" : ["35004-36925"],
"AR" : ["71601-72959", "75502-75502"],
"AZ" : ["85001-86556"],
"CA" : ["90001-96162"],
"CO" : ["80001-81658"],
"CT" : ["6001-6389", "6401-6928"],
"DC" : ["20001-20039", "20042-20599",
"20799-20799"],
"DE" : ["19701-19980"],
"FL" : ["32004-34997"],
"GA" : ["30001-31999", "39901-39901"],

"HI" : ["96701-96898"],
"IA" : ["50001-52809", "68119-68120"],
"ID" : ["83201-83876"],
"IL" : ["60001-62999"],
"IN" : ["46001-47997"],
"KS" : ["66002-67954"],
"KY" : ["40003-42788"],
"LA" : ["70001-71232", "71234-71497"],
"MA" : ["1001-2791", "5501-5544"],
"MD" : ["20331-20331", "20335-20797",
"20812-21930"],
"ME" : ["3901-4992"],
"MI" : ["48001-49971"],
"MN" : ["55001-56763"],
"MO" : ["63001-65899"],
"MS" : ["38601-39776"],
"MS" : ["71233-71233"],
"MT" : ["59001-59937"],
"NC" : ["27006-28909"],
"ND" : ["58001-58856"],
"NE" : ["68001-68118", "68122-69367"],
"NH" : ["3031-3897"],
"NJ" : ["7001-8989"],
"NM" : ["87001-88441"],

"NV" : ["88901-89883"],
"NY" : ["6390-6390", "10001-14975"],
"OH" : ["43001-45999"],
"OK" : ["73001-73199", "73401-74966"],
"OR" : ["97001-97920"],
"PA" : ["15001-19640"],
"PR" : ["0-0"],
"RI" : ["2801-2940"],
"SC" : ["29001-29948"],
"SD" : ["57001-57799"],
"TN" : ["37010-38589"],
"TX" : ["73301-73301", "75001-75501",
"75503-79999", "88510-88589"],
"UT" : ["84001-84784"],
"VA" : ["20040-20041", "20040-20167",
"20042-20042", "22001-24658"],
"VT" : ["5001-5495", "5601-5907"],
"WA" : ["98001-99403"],
"WI" : ["53001-54990"],
"WV" : ["24701-26886"],
"WY" : ["82001-83128"]
}
userzip = raw_input("Please enter your
state two digit code (ST): ")

userziprange = zipcoderange[userzip]
for i in userziprange:
print "Zip range for %s state: %s" %
(userzip , i)
A4.
numstr1 = raw_input("Enter the range start
number (lower limit): ")
numstr2 = raw_input("Enter the range end
number (upper limit): ")
num1 = int(numstr1)
num2 = int(numstr2)
print "Between %s and %s, the prime
numbers are: " % (numstr1, numstr2)
for num in range(num1, num2+1):
if num > 1:
for i in range(2,num):
if (num % i) == 0:
break
else:
print num
A5.

list = []
for i in range(0,3):
numstr = raw_input("Please enter a
number: ")
num = int(numstr)
list.append(num)
print "The largest number you entered
was:",max(list)
Chapter 4
A1. Operating system is a software that
provides core functionality to a computer. It
controls all the hardware parts and manages
the resources real-time. It also executes the
applications user wants to run on the
computer. Windows, Mac OS, and Linux are
a few famous operating systems.
A2. No, MS Office is not the only
software suite with spreadsheet and word-
processing applications. Google provides an
online service that has Sheets and Docs as
well.

A3. Oracle is a database management
software developed by Oracle Corporation. It
is a proprietary technology that is used by
giant corporations to handle their data.
A4.
import os,sys
num = int(raw_input("Please enter a
positive integer number: "))
multtable = []
for i in range(1,11):
table_row = str(num)+" x "+str(i)+" =
"+str(num*i)
multtable.append(table_row)
a=os.path.dirname(sys.argv[0])
link=os.path.join(a,"multiplicationtable.txt")
text=open(link,'w')
text.write("Multiplication table of
"+str(num)+'\n\n')
for item in multtable:
text.write(item+'\n')

text.close()
A5.
import os
os.system('copy multiplicationtable.txt
C:\Users\andrew\Desktop\multiplicationtabl
A6.
import os,sys
import random
pathname=os.path.dirname(sys.argv[0])
textfiles=dict()
for name in os.listdir(pathname):
path=os.path.join(pathname,name)
if os.path.isfile(path):
splitting=os.path.splitext(name)
if splitting[1]==".txt":
textfiles[splitting[0]]=None
for item in textfiles:
randomnum =
str(random.randint(1001,10000))
src = os.path.join(pathname,item+".txt")
dest =

os.path.join(pathname,item+"_"+randomnum
#print dest
os.rename(src, dest)
Chapter 5
A1.
from collections import OrderedDict
oDict = OrderedDict()
oDict['one'] = 1
oDict['two'] = 2
oDict['three'] = 3
oDict['four'] = 4
for key, value in oDict.items():
print key, value
A2.
import os, sys
import win32com.client as win32
from collections import OrderedDict
userdata = OrderedDict()
data_headers = ['First Name', 'Last Name',
'Age', 'Zip', 'Education', 'Driver Status?

(Yes/No)', 'Height', 'Weight', 'Avg Time
Spent on Cell Phone Daily', 'Commute Time
to Work']
for i in data_headers:
userdata[i] = raw_input("Please Enter
Your "+i+":")
#write the data to an excel file
excel 
=
win32.Dispatch("Excel.Application")
excel.Visible = True
wb = excel.Workbooks.Add()
ws = wb.Sheets.Add()
ws.Name = "Python Created"
#single loop, writing a column
for i in range(0, len(data_headers)):
j = i + 1
ws.Cells(1,j).Value = data_headers[i]
ws.Cells(2,j).Value 
=
userdata[data_headers[i]]
pathname=os.path.dirname(sys.argv[0])

filepath=os.path.join(pathname,"populatede
wb.SaveAs(filepath)
wb.Close()
excel.Application.Quit()
A3.
import os, sys, time
import win32com.client as win32
pathname=os.path.dirname(sys.argv[0])
excel=win32.gencache.EnsureDispatch('Ex
excel.Visible = True
filepath=os.path.join(pathname,"populatede
wb=excel.Workbooks.Open(filepath)
ws=wb.Worksheets('Sheet1')
ws.Name = "Extra Sheet"
wb.SaveAs(filepath)
wb.Close()
excel.Application.Quit()
A4.
import os, sys
import win32com.client as win32
#write the data to an excel file

excel 
=
win32.Dispatch("Excel.Application")
excel.Visible = True
wb=excel.Workbooks.Open(filepath)
ws=wb.Worksheets('Python Created')
wsnew=wb.Worksheets('Extra Sheet')
j = 10
for i in range(1,11):
wsnew.Cells(1,i).Value 
=
ws.Cells(1,j).Value
wsnew.Cells(2,i).Value 
=
ws.Cells(2,j).Value
j = j - 1
A5.
root = Tkinter.Tk()
root.withdraw() #use to hide tkinter window
file 
=
tkFileDialog.asksaveasfilename(parent=root,in
= 
(("Excel 
file","*.xlsx"),("Excel 
old
file","*.xls")))
filepathnew = file.replace("/","\\")
wb.SaveAs(filepathnew)
wb.Close()

excel.Application.Quit()
A6.
import os, sys
import win32com.client as win32
excel = win32.Dispatch("Excel.Application")
excel.Visible = True
wb=excel.Workbooks.Add()
ws=wb.Worksheets('Sheet1')
ws.Name = "Python Created"
ws.Cells(1,1).Value = "List of prime numbers
between 0 and 10000"
j = 2
for num in range(0, 10000+1):
if num > 1:
for i in range(2,num):
if (num % i) == 0:
break
else:
ws.Cells(j,1).Value = num
j = j + 1
pathname=os.path.dirname(sys.argv[0])
filepath=os.path.join(pathname,"primenumber
wb.SaveAs(filepath)

wb.Close()
excel.Application.Quit()
A7.
import PyPDF2
import os, sys
pathname = os.path.dirname(sys.argv[0])
filepath 
=
os.path.join(pathname,"sample.pdf")
pdffile = open(filepath,'rb')
readpdf = PyPDF2.PdfFileReader(pdffile)
pagenum = readpdf.numPages
for i in range(pagenum):
pdfpage = readpdf.getPage(i)
print "Page #",i+1
print pdfpage.extractText()
A8.
import PyPDF2
import os, sys
import win32com.client as win32
pathname = os.path.dirname(sys.argv[0])
filepath 
=
os.path.join(pathname,"sample.pdf")
pdfdata = []

pdffile = open(filepath,'rb')
readpdf = PyPDF2.PdfFileReader(pdffile)
pagenum = readpdf.numPages
word 
=
win32.gencache.EnsureDispatch('Word.Applic
doc = word.Documents.Add()
word.Visible = True
for i in range(pagenum):
pdfpage = readpdf.getPage(i)
print "Page #",i+1
pdfdata.append(pdfpage.extractText())
rng = doc.Range(0,0)
for dataread in pdfdata:
str = dataread+"\r"
rng.InsertAfter(str)
pathname=os.path.dirname(sys.argv[0])
filepath=os.path.join(pathname,"readsamplepd
doc.SaveAs(filepath)
word.Application.Quit()
A9.
import csv
import os, sys

pathname=os.path.dirname(sys.argv[0])
filepath 
=
os.path.join(pathname,"largest_number.csv")
with open(filepath, mode='w') as csv_file:
fieldnames = ['Number 1', 'Number 2',
'Number 3', 'Number 4', 'Number 5', 'Number
6', 'Number 7', 'Number 8', 'Number 9',
'Number 10', 'Number 11', 'Number 12',
'Number 13', 'Number 14', 'Number 15',
'Number 16', 'Number 17', 'Number 18',
'Number 19', 'Number 20']
datadict = {}
for i in range (1,21):
strrrr = "Number "+str(i)
datadict[strrrr] = int(raw_input("Please
enter a number: "))
writer 
= 
csv.DictWriter(csv_file,
fieldnames=fieldnames)
writer.writeheader()
writer.writerow(datadict)
dataset = []
with open(filepath, mode='r') as csv_file:
csv_reader = csv.DictReader(csv_file)

for row in csv_reader:
for i in row.values():
dataset.append(int(i))
print max(dataset)
A10.
import json
jsondata = json.dumps(max(dataset))

Chapter 6
A1. Here’s the crawler code.
# -*- coding: utf-8 -*-
import scrapy
class QuotescraperSpider(scrapy.Spider):
name = 'quotescraper'
allowed_domains = ['quotes.toscrape.com']
start_urls = ['http://quotes.toscrape.com/']
def parse(self, response):
quotes = response.css(".quote .text::text").extract()
author = response.css(".quote .author::text").extract()
for item in zip(quotes,author):
scraped_info = {
"quotes":item[0],
"author":item[1],
}
yield scraped_info

Appendix B: Differences in
Python 3.x
Print Statement
In Python 2.7, the print statement looks like
this:
print “Hello, Universe!”
In Python 3.0+, the print statement must be
similar to the one below. Yes, it looks more
like C and also supports many similar
operators.
print(“Hello, Universe!”)
Actually, 
Python 
2.7 
also 
supports
parentheses but only as an option.
Input Statement
There’s no raw_input() in Python 3.0+. It has
been 
discarded 
and 
input() 
has 
been
reinvented to support all input functionalities.
input(“Please enter your name: ”)
Future Module
You can make your Python 2.7 code to run in
Python 3.0+ by using the future() module.

from future import print
Integer Division
In Python 2.7, integers divided by integers
will always result in an integer.
>>> 3/2
1
Dividing integer with integer might return a
float in Python 3.0+, though.
>>> 3/2
1.5
Unicode
Python 2.7 supports ASCII, str(), and
unicode(), but there was no byte type.
In Python 3.0+, there are two byte classes, as
well as Unicode (UTF-8) string.
Xrange
In Python 2.7, xrange() was popularly used in
for loops that only had one-time iterations. It
was faster, but in situations where iterations
had to be repeated multiple times, range()
was better.
In Python 3, there’s no xrange(). Instead,
range() has the benefits of xrange().

Comparing Unordered Types
Comparing unordered types shouldn’t have
been allowed. In Python 2.7, it would have
returned false, which was incorrect. This has
been fixed in Python 3.0+.
Dictionary Ordering
In Python 2.7, dictionary key-pairs are
randomly stored. To create an ordered
dictionary in Python 2.7, we have to use the
OrderedDict() module.
In Python 3.0+, the key-pair order will
remain in the same order as they are added to
the dictionary.
Values Inside For Loop Don’t Leak
In Python 2.7, if you use a variable as
iterator, 
its 
previous 
value 
will 
be
overwritten.
i = 2
for i in range(100,200):
pass
print i
This would result in 199 as output. In Python

3.0+, however, it would result in an output of
2.
There are more differences between Python
2.7 and Python 3.0. Take your time in
learning the changes and make the switch
when you feel comfortable

BOOK- III
LINUX
FOR
ABSOLUTE
BEGINNERS
An Introduction to the Linux Operating
System, Including Commands, Editors,
and Shell Programming
ANDREW WARNER

F
INTRODUCTION
or 
any 
software-related 
professional,
Linux has served as an epitome of
accessibility, creativity, and freedom. Linux
has been hailed as one of the all-time greats
in our era. It is an operating system that has
revolutionized the world with its dynamic
nature, the sheer number of distributions (also
referred to as “distros”), and the security that
it brings to the table. With success stories
emerging from all across the globe, this

operating system continues to dominate the
industry 
with 
its 
high 
standards 
and
immaculate functionality.
Linux has been making the headlines, and
there is every reason why that is the case.
With products and services like Android and
the entire Macintosh operating system (OS),
which derive their existence from Linux, the
operating system has cemented itself as the
market leader.
With hundreds of thousands of professionals
learning Linux, it makes more sense than ever
to get yourself acquainted with it as well, and
that is exactly what this book is all about.
What to Expect in This Book
Fortunately, you do not need to be a high-end
programmer or an expert at coding to get the

most out of this book. If anything, this book
is aimed for people who have no idea what
Linux is, how it functions, and who should
use this incredible operating system.
The book is written to ensure all complexities
and advanced terminologies are kept to the
minimum so that it is easily understood by
the readers. The better the understanding, the
better your command will be over the new
operating system you are about to operate.
The book should serve as a good starting
point for those willing to embark on a journey
to the open-source operating systems and
familiarize 
themselves 
with 
basic
functionalities, commands, and essential. The
book will also reflect on topics like
networking, scripts, and applications, with
hopes that the readers would find themselves

comfortable 
tackling 
instructions 
and
guidance to enhance their experiences.
The book covers essentials that are necessary
for every beginner to understand in order to
operate the OS successfully and maximize
productivity. Whether you desire to use
Linux 
for 
entertainment 
purposes 
or
professional ones, the book will enable you to
learn, 
understand, 
and 
execute 
basic
commands at will, configure your system,
personalize your user environment, and if
needed, dive into some advanced Linux
wizardry.
Some Essential Terminologies
While all efforts have been poured in to
maintain 
a 
simple, 
friendly 
approach
throughout the journey, some significant
words and terminologies will still be used.

These will most likely be used throughout the
book to either elaborate processes or provide
an explanation. Without these, it is virtually
impossible to proceed. To give you a bit of a
warm-up 
exercise 
and 
get 
your
comprehensive skills flowing, here are a few
most commonly used terms:
Command line interface (CLI). It is a text-
based interface that allows a user to navigate
through the computer/network, move files,
and execute commands.
Flavors. Although some may find this
unusual, the term “flavor” is used to describe
the variants or distributions of Linux. The
next time you hear or read this, you would
now know what it refers to.
Kernel. This is essentially the heart and soul
of any operating system. The entire OS,

memory management, task management,
processes, and data management relies on a
kernel.
Operating system (OS). The software that
communicates between the machine or
hardware and allows programs to function.
Think Windows, Mac OS, Android for
phones, etc.
Shell. It is literally like a virtual shell that
wraps itself around other programs and runs
it. It is where you type in your commands,
and the action is then carried out for you. If it
sounds familiar, it is because some use this
interchangeably with CLI.
Unix. This is the mother of Linux. That is
indeed a fact and not just a fancy way of
putting it (more of that in chapter 1).
With these mentioned, we are all set to dive

into the world of Linux, and since it is a start
we are focusing on, it is important to take a
trip back memory lane and find out just how
Linux came into existence in the first place.
Surely, something must have happened which
forced someone to think outside the box and
eventually come up with a solution that
continues to be used today.

S
CHAPTER ONE
WHAT LED TO LINUX?
o you have just started on a new journey,
and immediately you are being taken back
into the pages of history. You might be
wondering why. There is a perfectly good
explanation for this, which will become clear
by the end of this chapter.
We know we are about to learn something
called Linux, a rival for Windows and Mac
OS that apparently most people have never

heard of. This shy but extremely efficient
operating system has drawn quite a lot of
attention from the world. It stands as one of
the all-time greats and continues to serve
almost everyone whether they know about it
or not.
If you are an Android user, you are already
familiar with the file system that Linux uses.
You may have heard of users and super users,
accessible through a method called rooting.
These are exactly what you can expect to
come across in Linux.
In order to fully understand certain concepts
and why Linux came into use, let us sit back
and rewind the clock quite a lot.
A Brief History
We find ourselves somewhere between 1991

and 1994. A guy named Linus Torvalds
started a project where his motive was to
create his own operating system. Using Unix
as building blocks, the entire operating
system was made from scratch. This is
something you might want to remember as
there are quite a few sources where Unix is
hailed as the mother of Linux.
Obviously, those who have seen Unix would
know that Linux uses commands that are
quite similar to those seen in Unix. This
naturally led people to believe that Linux is
just another version of Unix. As mentioned
earlier, it is not at all the case since both of
these are different. Both operating systems
are independent and serve different purposes.
With that sorted, we can now proceed to find
out what brought Mr. Torvalds to create an

OS from the ground up.
Before Linux ever became a success that it is
today, there still existed other operating
systems. In order for people to gain access
and use them, they needed to pay quite a bit.
This was obviously a problem for a lot of
software 
engineers 
and 
developers.
Obviously, the world was not yet introduced
to sources like we have today, which have
eased the process of writing hundreds of lines
of codes and develop software, upgrade them,
or modify them. It took quite a lot of time,
and it cost quite a lot of money. Not exactly
the ideal situation for anyone to find
themselves in.
Mr. Torvalds realized that in order for
software engineers to continue thriving, they
needed an operating system, and the then-

available options were quite costly. Right
about this moment, an idea came forth — an
epiphany that would change quite a lot of
things for years to come. Mr. Linus decided
to do the unthinkable and create an operating
system, right from zero, and make it a true
open-source operating system.
This opened a floodgate to possibilities for
programmers across the globe. Now, they had
something that was not only free but
unprecedented access to the actual source
code. To make things better, they could now
manipulate, modify, alter, or change the code
to their liking and come up with their own
version of Linux. Sure enough, this caught on
rather quickly. The result was a success
beyond comprehension. With thousands of
variants coming up, some started gaining

more popularity. If you have ever heard of
Ubuntu, it is a prime example of what we are
on about here. It is termed as a flavor or a
distro, and it is arguably the most popular one
there is.
While this all sounds revolutionary, there is
one piece of information that needs to be
addressed before we can move on toward
getting our first taste at Linux itself.
The 
Open-Source 
Concept 
and
Distributions
Earlier, we got a little insight into what Mr.
Linus was aiming to do — the open-source
OS. What exactly does open-source mean?
While many might not be interested at first to
learn more about this concept, it is vital in
order to understand how Linux works and

how the brilliant array of distros came into
existence.
Every software that you can find has been
designed with what is called source code. It is
essentially a blueprint of the entire software.
It tells the software how to function and what
to do should a user interact with it. The
finished version of the entire coding process
is software that users get access to and use.
With that said, however, the software may or
may not come with public access to the
source code itself.
If the software is sold as proprietary software,
the users will have no access to the original
source code. There is no way for ordinary
users to gain access to these codes to change
or modify any of the values. This is termed as
a closed source.

On the contrary, there are software systems
that allow users to gain full access to the
original source code. Moreover, the users can
play with these and modify values at their
own will. The result would obviously be
different from the original product, and what
you would end up would effectively be a new
version.
Remember when we said Linux borrowed a
concept pre-dating its own existence? The
first-ever software to provide users with
source code was the A-2 system, developed
by the UNIVAC division of Remington
Rand. This was back in 1953. This was the
very first time, when customers and end-users
had access to the actual source code along
with the software. Unfortunately, the new
concept was brought down by various giants

at that time who started to increase the prices
of the software packages and discontinued the
idea of sharing their source codes.
Bothered by the “ethically wrong” practice, a
person named Richard Stallman came up with
the GNU project in 1983. This initiative
revived the concept of sharing information
and source code publicly and, unsurprisingly,
got quite a bit of attention from fellow
software and programming enthusiasts. The
aim was to create a Unix-like computer
operating system that was composed of free
software. He also initiated a “free software
movement,” which later on became as the
Free Software Foundation.
The GNU project brought fort certain
development tools, some of which Linus
Torvalds used to engineer Linux. This is the

reason why you may find quite a bit of
controversy online about the name. While
some suggest it should be named as
GNU/Linux, owing to the fact that the
concept of free and open-source was used as
the project had intended, there are those who
simply call it Linux as it was built from the
ground up. Whatever name you choose to
stick with, the end result is nothing short of
brilliance.
Now, open-source means that everyone in the
world has access and the chance to modify
codes with ease. All it takes is a bit of
understanding of how codes work, and you
can come up with your own version of the
OS. No other name comes to mind to
showcase the sheer number of variations or
distros such as Linux. Ubuntu, Mint, Arch

Linux, Fedora, Kali — these are just some of
the names that have caught the attention of
the world. Each one of them is slightly
different. Some are designed for machines
with the lowest specifications, while others
are designed to be more appealing in terms of
design and functionality. There is something
for just about everyone out there.
All of the distros mentioned above are just
some names you should know for now. We
will discuss these in chapter 2, where you
will get to know each one of the major distros
better. You will also learn the purpose of
each one of them and the kind of people or
professionals who use them. The more
attention you pay to the fine details, the easier
it will be for you to understand and analyze
your own goals more clearly.

If you are someone who may have just
thought, “Why can’t they have just one
version for everyone like Windows or Mac?”
you are not the only one thinking so.
However, having an active community,
hundreds of thousands of pair of eyes
constantly upgrading the codes, you will
eventually understand that these distributions
are effective and work far better than most of
the proprietary operating systems available in
the market. That is a great advantage of open-
source OS, which is unrivaled by the
opposition.
There is one thing that should be understood
clearly. Open-source does not mean that the
software or the license would be free of cost.
Yes, you may find most of the flavors of
Linux for free, but you should always ensure

that you fully understand the limitations of
the licensing. There are certain variants
where you may not be allowed to use a
specific kind of Linux distro for commercial
purposes. Doing so would either violate the
terms of licensing or have you pay a hefty
fee. 
Moreover, 
open-source 
does 
not
necessarily allow you to modify the codes
every time. With Linux, most of the existing
variants encourage users to modify the Linux
kernel but always ensure you keep an eye out
for details. With that said, let us now look at a
few examples to understand just how
important and cost-effective Linux is.
Who Uses Linux?
The answer to this might not be so simple.
Surely, you may have thought of software
engineers and programmers, but the use of

Linux is not limited to just these groups of
people. Linux is widely used by almost
everyone these days.
Yes, programmers and software professionals
certainly do use Linux. It is their heaven,
their playground, and their field of expertise.
However, owing to the open-source nature of
the entire OS, there are versions that have
been created to cater to a larger scale of
audience. To give you a better idea, here are a
few examples to further highlight the various
users you can expect in the world of Linux:
1. Governments: Surprised? There is a
perfectly 
good 
explanation 
for 
this.
Governments are under constant pressure to
maintain their expenses and limit them to the
lowest numbers possible. This ensures they
save enough to utilize the massive amount

elsewhere. Imagine the entire parliament —
the local governments, the mayor officers,
and everyone related to the government —
using proprietary software such as Windows.
Can you imagine the cost they would have to
bear just to install a genuine copy on each
system? 
Linux 
allows 
them 
to 
have
unimaginable savings and offers them far
more security than any other operating
system. Quite a win-win scenario, don’t you
think?
2. Businesses: Sure enough, every major
business organization ensures they protect
their valuable data and have a network that is
flawless and operates fluidly. This is
something where Linux shines in a class of its
own. Add to this the fact that Linux saves
them a chunk of money, and there remains no

reason 
why 
large 
corporations 
and
organizations would not use Linux and go for
something else instead.
3. Major institutions: We are not just
referring to schools or universities; we are
talking of institutions such as NASA. With
such giants relying on Linux distros, there is
little to question the credibility and reliability
of this operating system.
We did mention earlier that there is
something for just about anyone when it
comes to Linux. With various distributions
emerging almost every other day, there is no
greater example to suggest how well the
open-source concept works and what is it
capable of.
From this point on, we shall be focusing more
toward you, an individual user. Although

there will be references to enterprise setups,
networking, and security used on a massive
scale, our primary objective would be to get
you to speed with the basics. As a beginner, it
would 
be 
unfair 
and 
probably 
too
complicated for you to understand and master
Linux just by the end of this book. It is
recommended that you seek guidance and
resources to gain further in-depth knowledge
on specific aspects. This book, however, will
serve you as a foundation upon which you
can build your Linux journey on.

W
CHAPTER TWO
DIVING INTO LINUX
ell done! You now know Mr. Torvalds,
the founder and creator of Linux, the
history behind its creation, and the one that
Linux continues to make every single day.
You picked up a few terms along the way as
well, such as kernel, source code, open-
source. All of that is important, so do pat
yourself on the back there.
Every Linux user has a certain purpose for

which they use this OS. What about you?
What exactly is it that drove you to consider
Linux as your primary OS? What is the
objective you aim to seek and accomplish by
becoming a Linux user?
These questions aren’t posed to test you; they
are something you should ask yourself and
come up with an answer. Why? Your answer
will decide which direction you go to. Just as
we learned earlier, the original Linux, the one
that our friend Mr. Linus came up with, has
been modified into thousands of variants.
Each one of them serves a different purpose
and has certain unique components to offer.
Depending on what you answer is, you will
then proceed to choose your flavor.
Quite a few people make a grave mistake and
immediately rush to websites to grab a copy

of the distro that is “famous.” It is only after
installation that they realize it has nothing to
offer that is considered usable.
If you have no idea about where a good
starting point would be, you can go for
Ubuntu. Once you start getting the hang of
things, you can opt for a different distro and
use that to accomplish your purpose.
Which Distribution to Select?
This is where the efforts have been to
minimize details and aim straight for the
target, helping you select your distro.
Remember, if you aren’t too sure yet, there is
no need to panic. Simply grab a copy of
Ubuntu, and most of the things explained in
this book should apply for all Ubuntu users.
To break things down, here is a list of some

popular versions and the purpose they seem
to serve best:
Ubuntu
This distribution is perhaps the most famous
one out there. It is suited to those who are just
beginning their journey into the world of line
user interface (LUI), command lines, and all
Linux-related tools and operations. It is yet
another open-source distribution based on
Debian distribution (yet another distribution
of Linux). The word Ubuntu (pronounced as
oo-boon-too) means “humanity to others.”
This specific distribution has garnered quite a
lot of attention as it is available for free. It is
meant for personal computers (PCs) and for
more advanced purposes on servers as well.
This comprises of standard Linux desktop
applications, a fluid graphical user interface

(GUI), and is better in terms of performance
as compared to Windows 8 versions or 10.
What makes it incredibly easy to use is
something called GNOME (GNU network
object model environment). This is employed
to make life easier for folks who have no clue
about programming. To make things more
interesting, even Ubuntu has several variants,
some of which are listed below:
Xubuntu: For machines that
do 
not 
boast 
high-end
specifications
Edubuntu: You guessed it
right, it is for educational
institutes
JeOS (Just Enough OS):
Extremely 
lightweight 
for

virtual appliances
Ubuntu Studio: Designed for
multimedia applications
Linux Mint
Quite a flavor this one, and for all the right
reasons too. It is light and can work even on
the 
lowest 
of 
specifications. 
With 
a
minimalistic GUI, the OS will run smooth
and should pose no problems in terms of
performance.
Red Hat Enterprise Linux (RHEL)
Now this is a tricky one. It is known to be a
top 
choice 
for 
business 
organizations,
enterprises, and even government agencies.
Known for its functionality for desktop and
server versions, it stands out from thousands

of distros and has one of the most active
communities in the Linux distro lineup. If
you are someone who is thinking to learn
Linux and use it for large-scale business
purposes, servers for organizations, or
government, this should be your eventual
goal. Remember, we are learning the basics
first.
Kali Linux
If you have ever heard of ethical hacking, this
is the platform where it all happens — a
white-hat solution for ethical hackers. The
purpose of Kali Linux is to analyze the
security measures in place, beef up security,
and allow ethical hackers and cybersecurity
experts to use tools for maximum benefits. It
is another Debian-based distribution that was
designed to test the security of servers,

websites, and so on. If you aim to seek a
career in white-hat, ethical hacking, you
should aim for this one after you have got the
hang of some essential commands.
Fedora
This is known for being a distro that gives its
users all the latest features while being highly
customizable. This distro of Linux is backed
by Red Hat. It is among the most popular
distros of Linux out there. It is constantly
rolling out new software, features, and
updates.
Elementary OS/Zorin/Solus
This is perhaps the most appealing in terms of
looks and feel. This version of Linux uses
Pantheon desktop environment, which makes
it look like a better version of Mac OS.

However, there is a downside to this one. If
you are looking for an OS that packs a few
preinstalled applications, this is probably not
the one you might fancy.
If you like distros which have a common look
and feel to Windows or Mac, or perhaps just
something with a really polished, but familiar
look and feel, also be sure to check out Zorin,
Solus, and Deepin. These distributions are
highly customized to give experiences unlike
other distributions. For example, Solus has its
own window manager called Budgie, and it
was built completely from scratch, not
derived from Ubuntu or Fedora.
OpenSuSE
SuSE was originally based on Red Hat Linux
and therefore shares the same RPM based

package management system, but over the
years it has changed itself enough to make it
clearly a distribution in its own right. It’s
YAST configuration management system
makes configuration of services a breeze.
The completely free version of SuSE is called
OpenSuSE. OpenSuSE has a lot of interesting
features including a ‘bleeding-edge’ software
package system called Tumbleweed. There
are a lot of Developer tools baked in too,
openQA is built for automated software
testing, while Kiwi creates Linux images for
deployment on real hardware. OpenSUSE
uses the KDE desktop by default.
Arch Linux
Arch Linux, unlike most, is not derived from
a parent Linux distribution like Red Hat or

Debian. It stands alone and is revered by
geeks for being a blazing fast distro because
it is based on a simple (yet solid) base.
Everything else can be added through its
pacman packaging system.
There is no rush for you to decide. You can
take your time or just go for Ubuntu. Once
you are set, it is time to start creating space
and downloading your very own copy of
Linux.
Downloading and Installing
Linux
Follow this simple step-by-step guide, and
you will be operating your very own copy of
Ubuntu on what is called a virtual machine in
no time.

Step 
1: 
Downloading 
virtualization
software
For the virtualization, we will download
VirtualBox.
Open your browser and head on over
to www.virtualbox.org. Immediately, you
will be presented by quite a big button that
says “Download.” Currently, as of June 2021,
the button says “Download VirtualBox
6.1.22” This might change should a new
version come out by the time you read this.
After you click on the download button, you
will be taken to a page where you will be able
to select from a bunch of options. Choose the
host version for your current OS.
Once done, open the downloaded file and
scroll through the installation prompt as you
would normally do on any other software

installation. Should you wish to customize
anything, such as change the destination
folder for the installation or add/remove
quick launch button, feel free to do so. Once
all set, click on “Next,” and the installation
should begin.
Step 2: Downloading your copy of Linux
Quick question! Which Linux flavor did we
talk about using the most for this book?
If your answer is Ubuntu, well done! You
followed the directions to perfection. Head on
over to www.ubuntu.com to get the process
started.
Right at the top, you should be able to see an
option that says “Download.” Click on that
and stop!
You may see the long-term support (LTS)
version, but we are not interested in those at

this point in time. Let’s go ahead and click on
the current non-LTS version. Right now, we
have 21.04, which is also called as Hirsute
Hippo. Funny name? Most certainly!
Go ahead and download the .ISO image onto
your computer. It may take a while, so feel
free to kill some time. Once we are all set, let
us begin the third step.
Step 3: Installation
We have already installed the VirtualBox,
and now we have the .ISO image of the
Ubuntu. Now, it is time to launch VirtualBox.
Once the application loads, click on the blue
raggedy circle that says “New.”
Let us name the new virtual machine (VM) as
Ubuntu. Select the target folder to you
choosing or leave it as it is — it really doesn’t
matter. The default type should show as

Linux, but if it doesn’t, ensure that you use
the drop-down menu and select Linux as your
type. The version should be Ubuntu_64 (most
of the machines would run that).
Now, click on “Next,” and you will be asked
to allocate the memory size. Remember, the
more memory the VM has, the better it can
run and operate. Let’s stick to 50% of your
memory at most. You can allocate a smaller
size if you have lesser memory available, but
do not go below the recommended size. Once
you are happy with your selection, it is then
time to take yet another decision.
The system will now ask you if you would
like to set up a virtual hard disk. The
recommended size is 25.0 GB. You can either
stick to that or increase/decrease per your
desire. Ensure that you leave the black

selection dot on “Create a virtual hard disk
now.” We do not wish to go into the advance
setups right now. Click on “Next,” leave the
current selection on Virtual Disk Image
(VDI), and move ahead.
Here, you will have the option of either going
for a dynamically allocated disk size or a
fixed-sized disk. While you can leave the
setting 
at 
the 
default 
selection 
(i.e.,
dynamically 
allocated 
disk), 
it 
is
recommended that you should change it to a
fixed-size setting. “Why?” we hear you ask.
Let’s come up with an answer that is short
and concise.
Having a fixed-sized disk allows the VM to
work within that allocated space. This does
take a little time, and you might have to wait
for a bit. Having a dynamically allocated disk

is quick, but it is where things can go bad in
terms of performance. There is no specific
place on the disk that will be allocated to
write on. The data will be all over the disk,
and this can cause quite a lot of problems for
your 
machine’s 
performance 
and
functionality.
With that said, click on the fixed-sized option
and click on “Next.” Allocate the size of the
disk or use the recommended size that is
displayed in bold letters. Click “Next,” and
sit back and relax as the system will now
create a virtual disk image (VDI). This should
take anywhere between five and ten minutes,
depending on the performance of your
machine and the space that you have
allocated for the VDI.
Now, you are just moments away from

launching Linux for the first time. Click on
the big green arrow pointing right that says
“Start.”
Not exactly what you were expecting, right?
That is because we haven’t yet loaded the
.ISO image file we downloaded from Ubuntu.
Click on the folder with a green arrow next to
the empty field. Browse to the location where
the Ubuntu file was downloaded and choose
that. Now, click on start.
Step 4: Setting up Ubuntu
At last! We have lifted off. In a few
moments, you will see the welcome screen
for Ubuntu setup and installation. There is
absolutely nothing to be worried about now.
We have gone through the tricky bits already.
All you need now is to set it up as you please
and move on. Most of the settings have

already been chosen for you.
Start off by clicking “Install Ubuntu” and
continue clicking “Next.” You will come
across a specific screen where it asks whether
you would like to erase and install. Simply
click “Next.” We have already allocated the
unused space for that. There is essentially
nothing that you will end up losing.
With that said, the installation will begin
shortly. This is going to take some time as
you have dedicated a part of your hardware’s
specification for the VM. After successful
installation, the system should reboot, and
you should be welcomed by the Ubuntu sign
and a sign-in screen. Log in using the
password that you may have set earlier in the
installation, and voila! We are through!
If you are running a Windows 10, you might

see the following error:
Failed to open a session for the virtual
machine Tux 3
VT-x features locked or unavailable in MSR
(VERR_VMX_MSR_LOCKED_OR_DISABL
Details
Result Code:
E_FAIL (0x80004005)
Component:
Console
Interface:
IConsole 
{db7ab4ca-2a3f-4183-9243-
c1208da92392}
In this case, you will need to shut down your
computer, restart, and enter BIOS settings.
From there, you will need to enable
“Virtualization” option. That should do the
trick for you, and you should now have no
trouble running Linux using a VM.
If you run into more trouble, you should have

no problem in locating a solution as there are
hundreds of forums where people provide
viable solutions to most of the problems.
This then ends the arduously long installation
process and thus paves the way for us to dive
into what really matters — Linux!
Familiarizing 
Yourself 
with 
the
Interface
Now it is time to start playing around with
the GUI, the desktop, and the various and
rather interesting-looking applications that
are pre-installed and ready to take you by
surprise. I’m not saying that the surprise
might necessarily be pleasant at first;
however, once you get the hang of things, it
should all make sense then. So without
keeping you waiting for perhaps yet another

chapter, let us embark on this little expedition
of ours and start exploring the environment of
Ubuntu 21.04 “Hirsute Hippo” a little.
The desktop holds most of the important
aspects, such as your dock (left side), where
all the pinned or active apps float. For our
Mac OS friends, this might seem a little too
familiar.
You have the top panel, which shows your
clock, a few indicators, and a user menu. The
user menu is where you can turn your OS off
or restart it or access user settings and other
functions that will be useful.
Using the user menu, you can access system
settings by clicking on the bottom left icon
that looks loosely like a cogwheel. Here, you
can configure settings to your liking and
ensure everything looks and feels the way

you prefer. It is essential that you do the
necessary changes to make yourself more
comfortable with the placement of the dock,
the app tray, and so on. This all combines to
deliver you a desktop that looks good and
functions accordingly.
All the above that we have discussed so far is
regarding the desktop GUI. This is called a
user environment. The Ubuntu 21.04 “Hirsute
Hippo” uses a GNOME 3.32 environment.
Various 
distros 
have 
various 
desktop
environments. You can find out a lot more
about each environment on the websites of
their specific flavors and distros.
Navigating around the new Ubuntu should be
quite easy, even if it is your first time. Use
the “Windows” key to bring up the main
application menu. It is probably worth noting

that this key is referred to as the super key. If
you are thinking of making Linux your
primary OS, you might find it helpful to start
memorizing common names of keys so that
you do not feel lost or overwhelmed when
things like super key, super user, or root are
being discussed. We will discuss quite a few
here, but for more detailed information, check
with the Ubuntu community, and you should
be able to find most of the information there
easily.
Double-clicking the folder with your name
will allow you access to the files and the
directories of this user. There, you would be
able to see your folders for downloads,
music, and pictures. In the left pane of the
window, you should have quick access
buttons just like you would find in a Mac OS

or Windows. Use these to quickly switch
from one folder or directory to another.
The new Ubuntu version now allows you to
mark any folder as your favorite. This saves
us quite a lot of time in case we are to use
that destination quite often. Simply right-
click on the said folder and choose “Star.”
There you have it. Now, you can access this
folder almost instantly by a single click.
Please note that this may not work on all
folders.
Right now, the entire system is rather vacant.
We haven’t done anything as of yet.
However, with time, you may start creating
text files or downloading music, movies, and
games. You might even work on software or
create programs and save them in an
important location. Use the star method, and

you should save yourself quite a lot of
clicking in the future.
Ubuntu allows extensive customization, and
there are tons of themes, icon packs, and
almost everything that you wish to change or
customize. You can search throughout the
internet or visit www.gnome-look.org to
change the feel of the desktop.
Installing themes is easy. However, for full
customization control, you should download
the GNOME tweak tool. It is free and is
available in the Ubuntu software center.
There is another way you can get that without
actually searching for it in the software
center. With just a snippet of command, it
will be done for you. This is the power of
Linux; it will get the job done for you. All
you need is to command it what you wish for.

We will discuss this when we learn more
about the terminal in the coming chapter.
Dual Booting Windows 11 and
Ubuntu Linux
At first, you need to download Ubuntu 20.04
LTS ISO from the official website of Ubuntu.
Download Ubuntu 20.04 LTS ISO
Now Create a Live USB With Ubuntu 20.04
LTS.
You can easily create a bootable USB drive
with the help of popular tools like Rufus or
Unetbootin.
Prepare the Windows Operating
System For Dual-Boot
In this step, you need to create unallocated
space for Ubuntu installation. If you don’t
have any unallocated space in your system.
You can delete one of your available
partitions and create enough available space

for Ubuntu. We suggest you have 100 GB of
unallocated space for the Ubuntu installation.
Meanwhile, Ubuntu 20.04 requires 25GB of
disk space for the installation.
Now, you need to boot your system from
Ubuntu 20.04 LTS bootable USB drive.
Boot from USB Drive.
You might need to access your BIOS setting
to change the boot sequence on BIOS/UEFI
to boot a system from DVD/USB. If you are
booting in the UEFI system then select
Ubuntu from the GRUB menu and then press
Enter.
After a while, you will see a welcome screen
where you will get the option of installing
Ubuntu or trying it. Click on the Install
Ubuntu button and you will see the next
windows where you can select the keyboard
setting. Choose the Keyboard and then click
Continue to proceed further.
Now, you will see the screen from where you
can choose the type of installation. You can

go either with Minimal Installation or Normal
installation. You can have also the option of
installing system updates and third-party
software during OS installation.
Now you will see the most important part of
the Ubuntu installation alongside Windows
11 and this one is Disk selection or disk
partitioning.
If you are in UEFI System you will see the
following three option:
Install Ubuntu alongside Windows
Boot Manager
Erase disk and install Ubuntu
Something else
If you are in the Legacy system, then you will
see something like this:
Install Ubuntu Alongside Windows
10
Erase disk and install Ubuntu
Something else
In either case, go with the something else
option. Here you can create partitions

manually with the size you want. We will
create 
the 
following 
partition 
in 
the
unallocated space:
/boot – 10GB (Optional for legacy
bios system )
/home – 30GB
swap – 8GB
/ – Remaining space in your
unallocated partition.
When finished, hit the Install Now button in
order to apply changes to the disk and start
the installation process of Ubuntu 20.04 LTS
alongside Windows 11.
On the next screen select your physical
location from the map and then click
Continue to move ahead.
Now, On the next screen, you need to
configure your username and password for
your 
administrative 
sudo 
account 
and
Continue to finalize the complete installation
of the Ubuntu20.04 LTS alongside Windows
11. It might take up to 30 minutes to
complete. 
Once 
Ubuntu 
20.04 
LTS

I
installation is complete, click Restart Now to
reboot the machine. After rebooting your
system, you will see the Grub menu, where
you will see both Ubuntu 20.04 LTS and
Microsoft Windows 11. From here, you can
select the operating system of your choice
and use it.
CHAPTER THREE
NAVIGATING YOUR WAY
THROUGH
n the previous chapter, we walked through
the various distros and who uses them. We
ended the chapter with successfully having
Linux downloaded and installed. To serve as

a bit of a reminder to everyone, we will be
discussing Ubuntu more as it is the pinnacle
for those who are just starting their journey
into the crazy world of Linux.
Picking up right where we left off, the virtual
box is successfully running Ubuntu, and we
have made it through to the desktop.
Gorgeous, isn’t it? Colorful, dynamic, and
already seems fluid. Provided that you gave
enough room for VirtualBox to breathe, you
should not experience much lag. There will
be steps that we will need to take in order to
correct the maximum screen resolution and
improve the smoothness of the operation.
The desktop holds most of the important
aspects, such as your dock (left side), where
all the pinned or active apps float. You have
the top panel that shows your clock, a few

indicators, and a user menu. The user menu is
where you can turn your OS off or restart it
and access user settings and other functions
that will be useful.
This GUI you see before you is called a user
environment. The Ubuntu 21.04 “Hirsute
Hippo” uses a GNOME 3.32 environment.
Various 
distros 
have 
various 
desktop
environments. We can get into those, but
since we already have Ubuntu installed, let’s
not discuss that right now.
Once you have played around a bit with the
environment and the icons, you can now
begin to take a first look at the beating heart
of every Linux flavor out there — the
terminal.
Getting Acquainted with the

Terminal
The terminal, sometimes referred to as the
command-line interface (CLI), is where all
the magic happens. While the graphical user
interface (GUI) allows the user to use
graphics and interact with icons and folders,
the terminal takes a different approach, which
is called the line user interface (LUI).
In the terminal, you do not have any graphics
except for lines of code. Learning how to
command and use the terminal is what you
should aim for. This is what will truly allow
you to utilize the true power of the Linux OS.
Before we proceed ahead, it is probably wise
to add a plugin to our VM to maximize the
screen resolution and allow Ubuntu to
function a little more fluidly and smoothly.
Remember, we are currently providing this

VM of ours a fraction of the true potential of
our machine. Do not expect it to work
immaculately just yet.
Let’s get our hands greasy here and work
with the terminal for the first time. We will
use a certain command to add guest plugins.
You do not need to run a setup manually,
scroll through options, or do any of that. The
terminal does it all for you with simple
commands. We will be discussing commands
in details later on, but to serve you with an
idea of how exquisite and flawless the
terminal is, let’s get into it right away.
Double-click on the home folder. Now,
within the home folder, click on the disc
image on the left pane to open the contents of
the virtual disc. Right-click on the empty
space within the disc folder and choose

“Open in terminal.” We are trying to run a
file named AddLinuxAdditions within the
disc image. This file has a .run extension.
Files with these extensions can be run
directly from the terminal.
You should now have the terminal opened.
See the colored alphabets and digits? Those
are indicating your location right now. If you
have used DOS prompt, this might make
some sense.
Start from the left side. You are shown the
point where the main directory started
followed by the forward slash (/). Following
that is the sub-directory and so on. The
naming should end with your virtual disc
name to indicate whatever you are about to
do is going to be within this directory.
Now enter the following command after the $

sign:
./AddLinuxAdditions.run
Hit Enter. See how it says you need
administrative privileges? In the world of
Linux, there is what we call a super user. This
is essentially the same as an administrator in
Windows. Now enter the following command
to allow these privileges to the command:
sudo ./AddLinuxAdditions.run
You will be asked for your password for
verification. Provide the required information
and hit Enter. Moments later, the installation
will be complete, and you will see quite a bit
of difference in screen resolution and
performance. For optimum results, go to the
top right side of the desktop, access the user
menu by clicking on the drop-down menu
icon, and restart your Ubuntu.

Now, your desktop would look and feel a lot
more 
spacious 
and 
appealing. 
The
performance will improve quite a bit as well.
This is the time when you can now start
moving around icons, checking out the
Ubuntu software store, and customizing all
that you wish for.
Remember we mentioned about discussing
the terminal later on? Well, here we are. We
have just used a terminal to do something for
us; now, we shall see how easy and efficient
the terminal is.
We will be trying to download a tool called
GNOME tweak tool and install it. We will go
through the process and see how long it takes
to get this simple task done. This should be
your first look into the true power of the
terminal and why the computer geeks rely so

much on it.
Let us call this scenario “A.” We will use the
traditional GUI to browse around the
software store and search for this tool to
download and install the same.
First, 
go 
to 
your 
dock 
of
applications/software. Click on the Ubuntu
Software icon. That would be the orange one
with an “A” in it. Once the software store
screen loads up, click on the magnifying glass
to initiate a search and type in “GNOME
Tweak.” You should then be able to find the
tool. Simply click that and click on Install.
Simple, right? Perhaps it did not consume
much time at all. Let’s compare to the
scenario “B” now.
Right-click anywhere on the desktop and
click open in terminal. Alternatively, you can

use a keyboard shortcut Ctrl+Alt+T to bring
up the terminal shell. Enter the following
command:
sudo apt-get install gnome-tweak-tool
Enter your password for verification and hit
Enter. You would be asked if you are happy
to proceed with the installation. Type “Y” for
yes and hit Enter. That is it! Much quicker,
much more effective. You never had to
change any screens or browse through a
number of pages to get to your application.
We will be learning quite a lot of commands,
so if these do not make much sense right
now, don’t be worried. We will get into the
details soon.
The terminal talks to the machine and to the
user using these set of codes. To an ordinary
user, this may seem overwhelming, but to any

experienced professional, each string of text
conveys a certain message. Whether you are
trying to compute or access certain files and
folders, you need to use the language that the
terminal can understand and operate on.
Mr. Linus, our dear friend who invented
Linux, was a man who possibly introduced
the concept of working smart instead of
working hard. He never wanted to work
much, and the same is perfectly replicated in
the terminal. The terminal will do all the hard
work for you and provide you with the end
result directly.
If you advance your way through and learn
Python and other languages, you would be
able to extract most out of the terminal while
doing minimum work yourself.
Imagine, you have to compile data that

involves quite a bit of research. If you are a
Python user, you will only need to create a
script and feed it to the terminal. The terminal
will then initiate the research, gather relevant
data, 
and 
compile 
it 
in 
a
word/PDF/spreadsheet file for you at your
chosen location.
The leading tech-related industries are using
Linux to provide them with cutting-edge
solutions and to maximize their productivity
far and beyond. All of that is made possible
owing to this simple LUI that does so much
in so little effort.
File System and Directories:
The “What” and the “How”
The world of Linux is slightly different from

the more popular Windows and Mac
operating systems. It is necessary that you
understand how everything works here, how
the file system works, and how you can
create new directories and pathways for your
data files.
In order to fully understand, ensure that you
are at the desktop of your Ubuntu and follow
the guidelines here to make the most out of it.
Practice 
makes 
anyone 
perfect. 
Going
through 
the 
pages 
without 
actually
experiencing any of it might defeat the
purpose of the entire book and the effort it
took to make it.
Root Directory
From the desktop, open your home folder that
has your login name on it. Once opened, go
ahead and press Ctrl+T to open a new tab. In

the new tab, in the left pane, go down to the
plus sign where it says other locations. Click
on that to access two more locations that are
not shown directly on the pane or on the
desktop. Click on the computer icon to access
it. What you should be able to see now are
two tabs. Although you do not need to do this
every time, we are only doing this to ensure
everyone understands the difference.
One tab should be named as “Home” while
the other should have no name. This is
because the other is the root directory or the
parent directory. It is marked with the
forward slash (/). This is the highest directory
in the system, and whatever takes place will
happen within it.
Your second tab is Home. It is represented as
“/Home.” This is where our user directory

lies. To view the full address, you can always
hover your mouse on the left pane over
directories to get these details.
Similarly, the “usr” is /usr directory in the
root tab. This is used by the system itself for
quite a lot of things.
Here, we should also stress on terms called
absolute path and relative path.
An absolute path is a path that begins with a
forward slash and descends all the way
through. For example, in the above case, we
used the root directory, entered a sub-
directory called usr, followed by a folder
named “Example Folder.” Our target folder
lies inside this and is named as “Target
folder.” The absolute path for this would be
as follows:
cd /usr/Example Folder/Target folder

It is not necessary that paths are always
absolute in nature. Suppose you are deep into
the root directory and its sub-directories. The
path would be quite long and hard to
remember. To make things simple, you can
simply type in the command to change the
directory, and without using the forward
slash, just type in the name of a folder that is
within the working directory.
As an example, let us take the one we just
used to describe absolute path. Let us assume
we are within the Example Folder directory
and now we wish to go to Target folder. To
do this, you will only need to type the
command to change directory (cd), followed
by the name of the sub-directory:
cd Target folder
This is called a relative path as it is only

relative to the working directory.
You will come across these quite often,
which is why it is best to note these for future
purposes. With that said, let us now move on
to other important directories apart from the
root directory.
The Bin Directory
This is perhaps one of the most important
directories in the system. While there may be
various bin and sbin directories in the system
itself, we are referring specifically to the /bin
directory, which resides directly under the
root. This is where you find all the binary
files that the system uses in order to carry out
all the functions and tasks accordingly.
For users, there are other directories to use
which are mentioned down the line.

Spell them right!
Capitalization is quite a significant deal in the
world of Linux and the filesystem it
possesses. While naming any directory that
you end up creating or even if you are
renaming a file, be sure to know the exact
name with the right order of capitalization.
Linux treats every letter as a different
character. This is crucial to remember as
quite often people tend to forget this and run
all over the place, worrying why their
perfectly good file is not functioning in the
terminal. If you are trying to access a
directory called “Home,” you need to type in
the command followed by the exact order of
capitalization. Get it wrong, and Linux will
not identify your request.
It is now time to look at some other important

directories. Some of these are best left alone
as they perform crucial functions and may
end up causing problems should you rename,
edit, or even remove any of them.
Steer clear of “Boot.”
While most of these folders or directories can
be explored at your own will, there is one that
you should strictly refrain from unless you
are an expert user. This is the folder called
Boot in the root directory (computer). This
contains everything that is crucial and
important for your operating system to boot.
This is the home for your boot loader. Do
anything here, and you might find yourself in
all kinds of trouble.
Dev Directory
This is the directory where all your devices

live. Since Linux does draw some inspiration
from the age-old Unix system, there are some
similar concepts you may find. The most
prominent one is their approach to the
filesystem, where everything is treated as a
file and nothing more.
This is where you will find everything related
to hardware, including the hard drive, the
partitions, mouse, keyboards, etc. For all
applications and drivers, this is the folder to
access. You can still look around, but try not
to modify or change anything here unless you
know what you are doing.
The Etcetera Directory
Quite literally! This directory is named as
“etc.” While there is still quite a bit of
confusion with the name, the co-creator of
Linux has confirmed this was indeed termed

as etcetera, so we will continue to call it just
that.
This directory is responsible for holding all
the system-wide configuration files. This
means that any application or software that is
available for all the users will have its
configurations stored here. We will discuss
these in more detail later on.
The Libraries
Every Linux system has libraries that are
used by various applications to carry out
numerous tasks and functions. In our case, we
will most likely be able to see four folders
here named as lib, lib32, lib64, and libx32.
Again, not something we should be fiddling
with unless we are 100 percent sure of what
we are doing.

The Lost+Found?
It could have been named something else, but
Linux has this directory in place to keep files
that have either been damaged or lost during
a process (e.g., abrupt shutdown).
Media and /mnt Directories
Simply put, these are the places where we
will be able to locate any other drives that we
may have mounted in Linux. These will
include any floppy disks (not like we use
them anymore, but it is always good to
know), CD drives, USB mass storage,
network drive, etc.
The Optional Directory
Named as the “opt,” the optional folder
consists of software manually installed by

third parties. There may be some software
packages that end up being installed in this
directory.
If you are a software engineer and you have
created a software yourself, you can use this
directory to install your very own software as
well.
The Process Directory
“Proc” directory is where files containing
information about the system processes and
resources are located. This will be quite
useful for developers and programmers.
The Run Directory
This one is quite interesting. Whenever you
are working on your system, this folder starts
getting crowded. However, when you shut
your system down, this directory goes blank

immediately. 
It 
does 
not 
store 
files
permanently and only houses those that are
using the system memory or RAM.
The files in this directory store runtime
information for processes that begin the
moment 
you 
start 
the 
machine. 
The
information may be useful, but it is only
available as long as the system is running.
Sbin Directory
Quite like the bin directory in the root folder,
sbin is only accessible by the super user as it
requires administrative privileges.
Snap Directory
This is Ubuntu’s favorite directory. This is
where all the snap packages reside for the use
of Ubuntu. These are applications but
function quite different from your ordinary

applications.
Service Directory
The “srv” directory is the directory that
contains all the service data. This should
currently be empty, and there is a very good
reason for that. The srv directory only comes
into play when you decide to run a server and
wish to share files with external users. Those
files will be placed within this directory for
external users to gain access.
The System Folder
The “sys” folder is the medium to interact
with the kernel itself. Just like the run
directory, this creates files when the system
boots up and does not directly write it on the
disk.

The Temp Folder
As the name implies, it is a temporary
directory that stores temporary files for the
user in case the system crashes. This will then
search to find the last temporarily saved entry
and provide the user something to continue
with.
Again, just like the run and the “sys”
directories, this folder also deletes most of the
files within it every time the system is shut
down.
The Usr Folder
Just like the bin directory, where files are
used only by the system itself, the usr
directory is where applications or files used
by the user and system administrator are
installed.

The Variable Directory
The var directory only holds files and
directories that may expand in size. This
could be various kinds of information, such
as system crash logs, which may populate
over time.
These are the kind of directories you will find
and probably even use one day down the line.
However, there are some other things to
notice here.
Viewing hidden files and folders:
If you go back to your home directory and hit
Ctrl+H, you will see quite a lot of hidden
files that were initially not visible. In
Windows, they appear in a translucent
manner to differentiate between a file that is
visible from the one that isn’t. In Linux,

things are different yet again.
Any file that begins with a period is meant to
be hidden. After you use the above command,
you will be able to see many of these.
Even in the terminal, if you use a command
to list the files and folders within the working
directory, you will only be shown the ones
that are not supposed to be hidden. In order to
view all the files, you will need to use the
command below:
ls -a
Enter that, and you will be able to see all the
files and folders, including any that you may
have created on your own.
Creating a folder is exactly like you would
normally do in Windows or Mac OS. Simply
right-click on an empty space and choose
“New Folder” to create one right away.

Depending on the location where it is created,
it will now be a sub-directory of its parent
directory.
Now that we have a fair idea about how the
filesystem 
in 
Linux 
works, 
how 
the
directories are accessed through the GUI, let
us now step deeper into matters and move
past the graphical world. Let us now stroll
through the world of LUI.
Basic 
Commands 
to
Remember
There are just so many commands that we
can go through, but hopefully, our aim is to
remain true to the task at hand and explore
the essential commands that will serve us
every single time we use Linux and the

incredible CLI.
For best results and quicker understanding,
keep practicing as you read. This helps in
learning faster and understanding things more
effectively.
If you don’t remember how to access the
terminal, you can simply right-click on any
empty space and choose open in terminal or
just punch in Ctrl+Alt+T, and that should
bring up the terminal for you.
Commands that you use are normally
followed by what is called as an argument.
For example, in the case of changing
directories, the “cd” is the command, while
what follows is the argument. There will be
some commands where you may not need to
use arguments. We shall discover that now.
Print Working Directory (pwd)

It shows you the current directory you are
working on. This is quite a useful command
if you are lost within the depths of
directories. This command requires no
argument.
Change Directory (cd)
Use this command to change from one
directory to another. Remember, use relative
path if you are aiming to go to a sub-directory
or use an absolute path if you wish to go
elsewhere.
For “cd” command, there are a few other
things you can use:
cd
This takes you to your home directory
(no arguments).
cd ..
This takes you to the parent directory.
cd /
This takes you to the root directory.

cd ./
The period slash denotes “current
directory.”
cd ../ This goes up to the parent directory
and into the next selected one.
cd ~
Type this in, and you will be back in
your home directory.
cd ~/ This accesses directory named after
slash within the home directory.
The “ls” Command
This is quite a useful command. We are
pretty excited to start navigating in and out of
the directories. However, you might run into
places where you are not too sure if it
contains any files or folders to browse. Since
this is a line user interface, there are no
graphics to show what we can find within a
directory that we seem to have gone into.

However, there is a way you can find that out
as well.
To check the contents of the directory you are
currently working on, simply type the
following:
ls
The terminal should now provide you with a
list of directories, files, and any other
material that may be placed there, such as
pictures 
and 
graphics. 
These 
will 
be
presented in alphabetical order. However, this
command is quite extensive. Let us explore
some more commands of “ls.”
ls -r
This may not seem very useful at first, but
rest assured, it might come in handy. This
command acts almost the same as the simple
“ls” command. The only difference is that the
listing here would be in reverse alphabetical

order. Quite nifty in case you have a lot of
files and need to access one that starts with
the letter U.
Suppose you have a number of files and wish
to find out determine what file permissions
you have. It is not necessary that you can edit
all the files, read them, or access them. In
order to find out just that, you can use the
following command:
ls -l
You are now effectively ordering the terminal
to view all the files with details like the
owner of the file and the location, but we are
more interested in a bunch of symbols and
letters that form up the first ten characters of
the line from the left. This is a typical
example to explain to you better:
drwxr-xr-x 3 exampletest exampletest 4096
Sep 01 12:00 Desktop

Using the ls -l command, we have now
stumbled upon valuable information about all
the directories and files within our current
location and can now see the permissions
each one of them has.
The first character shows the file
type. This could be “d” for
directory, “l” for link, “p” for named
pipe, “c” for character device, - for
file and “b” for block device.
The second to fourth characters
provide 
information 
regarding
permission to read, write, and
execute said file or folder for the
owner.
The fifth to seventh characters
provide 
information 
regarding

permission to read, write, and
execute said file or folder for the
file’s group.
The eighth to tenth characters
provide 
information 
regarding
permission to read, write, and
execute said file or folder for all
other users.
Now, try to decipher our example above and
find out what permissions we have. You can
also use the ls -l command to view your own
directories and find out a lot more. With that
said, let us move ahead to yet another useful
ls command.
You might be wondering, “Do I always have
to take so much time to decipher the file
type?”
Quite a valid question, but no! The terminal

has you covered for that. If you are not too
sure or you may tend to forget that “d” stands
for directory and the dash for files, we have
yet another command that can organize all
the content of the working directory into a
file type.
ls -p
This command will now present all the files
and folders with either their names and
extension or a forward slash. The ones with
the extensions are the files while the ones
with the forward slashes are your directories.
Quite easy, isn’t it? When you are all set, go
ahead and type in the following command:
ls -l samplefile
ls -ld sampledirectory
The first example here shows you the
permissions of a specific file. The second

example does the same, but instead of a file,
we now get information about the folder or
directory we have chosen. The “samplefile”
and “sampledirectory” are just for illustration
purposes only. In your case, choose any
folder or file that you wish to use here.
Having this information at hand can help you
quite a lot. There will come a time when you
may need to find out the permissions that
have been granted to the owner, the group, or
any other user on the system. You should
know how to find this information out,
decipher it, and modify it if needed to further
strengthen the security of these files and
directories from prying eyes.
What if you wish to base the listing on file
size? Well, we do have a command for that
too:

ls -s
This will sort everything and list the files and
folders according to their sizes. Now let us
take a step further in listing command and
change the scenario a bit.
Let us suppose we just feel a little too lazy to
go to a specific directory and then run the
listing command there. Is there a way we can
find out the contents of that targeted directory
without going there? Fortunately, yes!
Regardless of what your working directory is,
you can use the command below and get a list
of all the files and folders available within a
said directory. In this case, we are targeting
the /usr/share/applications:
ls /usr/share/applications
This will provide us with a list of the content
present within the above directory, even if we

are in the desktop working directory.
However, you may have noticed one thing —
it all seems a little clustered. Too little space
and too much to read. Let us take care of that
with a quick command:
clear
Now, the terminal has room to breathe and
looks better. Don’t worry, none of the entries
have been removed as you can still access
them by scrolling up. Quite a lot of people
tend to get worried at the first time.
Finally, a bonus listing command for
everyone. If you wish to get access to all the
possible “ls” commands, simply type in the
following command at any time, and you will
be presented with all the possible ls
commands and arguments along with their
description:

ls --help
With that said, it is time to say goodbye to the
listing commands and move forward and look
at some other essential commands that you
should 
know. 
There 
are 
hundreds 
of
thousands of commands for you to get into
and explore; however, we are trying to list
only those that form the foundation and
provide you with basic knowledge. How you
wish to master further commands is up to
you.
Not that far back, we came across another
command that seemed a little different to
most of what we have discussed here. If you
have forgotten, the command in question is as
follows:
sudo apt-get install gnome-tweak-tool
We know now that “sudo” is what grants

administrative privileges to the user in order
to execute said commands on the terminal.
What about the “apt-get” and “install”? This
is the package manager for Ubuntu and
Debian-based 
distribution. 
It 
is 
called
Aptitude.
The apt-get is an application that is
responsible 
for 
installing 
or 
removing
software and application via the CLI on
Linux. This is both quick and secure and
allows you to take complete control of the
installation.
The apt-get command is followed by an
action. In the above case, we used “install” as
our action. Should you wish to remove a
program, you can use replace the action with
“remove.”
Following the action is the name of the

application. These application packages and
indexes are stored within the Ubuntu
repositories that the terminal accesses. Before
executing a command, always ensure you
know what application you wish to acquire as
you will need to use the exact name and
capitalization for the command to work
properly.
You can use the example below to download
a simple text editor called the Bluefish.
sudo apt-get install bluefish
You 
will 
be 
asked 
for 
a 
password.
Remember, when typing your password, the
terminal will not show any dots or asterisks.
Once done, hit Enter, and you will be asked
whether 
you 
would 
like 
to 
continue
downloading and installing the desired
package. Type in “Y” and hit Enter to

continue. Eventually, you should now have
the Bluefish installed in your system.
Since this is an example and we do not need
the Bluefish for any part of this book, let us
go ahead and check out the command to
uninstall this program.
Open your terminal and type in the following
command to uninstall the program:
sudo apt-get remove bluefish
After the friendly “yes or no” selection, the
Bluefish will be removed for you. It is that
easy.
What if you wish to install a great program
you found in your friend’s machine? You
think, “Sure, I will use the apt-get and have
this program installed right away.”
You get home, all excited, log in to your
Ubuntu, open the terminal, and halfway

through, you realize you forgot the name of
the application. You can do a search using the
“apt-cache” command in the following way:
apt-cache search gimp
You should now see a crowded terminal, with
numerous entries and file types. Search
through the same, and you should come
across one that says program in the end.
These are the ones that you can install using
apt-get install command. Alternatively, you
can rely on the Ubuntu software store and
locate your applications or software that you
wish to download and install.
There are instances where you may have
applications 
that 
were 
pre-installed 
or
manually installed but are nowhere to be
found. Before downloading and perhaps even
rewriting the files, it is best to check if the

said application exists on your system or not
using the terminal. To do that, follow the
command below:
apt-cache policy gimp
Here, the action has now changed from
install/remove to policy followed by the name
of the application. Assuming that we have
downloaded 
and 
installed 
the 
photo
manipulator software called Gimp from the
previous example, the result will look
something like this:
gimp:
Installed: 2.10.8-2
Candidate: 2.10.8-2
Version table:
*** 2.10.8-2 500
This confirms that there is a version installed
on our system. It also shows which version

currently resides within the repository. Both
of these versions match each other, which
reassures us that we are running the latest
version.
To run another test of this command, we
initially downloaded Bluefish and then
uninstalled the same. Let us see what the
terminal has to tell us regarding that:
apt-cache policy bluefish
bluefish:
Installed: (none)
Candidate: 2.2.10-1
Version table:
2.2.10-1 500
The result is now telling the user that they do
not have the Bluefish installed on the system
— quite a useful command to remember
when you are managing various networks and

machines as an administrator. You can
always run these commands to find out if a
machine 
has 
certain 
programs 
and
applications installed within them that may be
necessary.
Suppose you do not wish to use the repository
or you just stumbled upon a website where
you found an application that is available to
download. You want to install that. Again,
there are two methods — the GUI and the
terminal. The former would require you to
download the installer. After downloading is
done, you will need to browse through the
directories, access the software, and then
launch the graphical installer. It will then
continue through steps asking all the
questions and asking you to agree to this or
that. Eventually, you will be able to have it

installed and ready for use.
We are not focusing on this case at the
moment. We are more interested in mastering
the commands and wish to install the same
using the terminal. For this example, we will
use Google Chrome as our browser, which
we need to download and install.
Open up the pre-installed Firefox browser
from 
the 
app 
drawer/dock. 
Go 
to
chrome.google.com to download the installer.
Choose the Debian/Ubuntu version as we are
using just that. Click on save, and let it
download.
Now open your terminal and use the “cd”
command to access the Downloads directory.
cd ~/Downloads
Use the “ls” command, and you should now
be able to see a red-colored entry here. This is

the file we wish to execute and install through
the terminal. In order to do that, type in the
following command:
sudo 
dpkg 
-i 
./google-chrome-
stable_current_amd64.deb
If you are slightly overwhelmed by what just
happened here, let us explain. We already
know the first command. What follows that is
dpkg, which essentially means Debian
package. Remember, Ubuntu is a flavor of
the Debian distro, so we will normally find
the word Debian linked quite a lot. Following
the dpkg is the action. In this case, we used -i,
which tells the terminal we wish to install this
package.
Next, you guessed it, we have specified the
location of this package file that was
downloaded. Since we were already in the

Downloads 
directory, 
we 
used 
the 
./
command to tell the terminal we need
something from within the directory. If we
were in any other folder, we would need to
use a path leading to the file. Lastly, it is the
name of the package, followed by its
extension.
Once done with the installation, you can
directly open chrome from the terminal by
typing in “google-chrome” and hitting Enter.
The use of commands is always a daunting
task at first. However, with sufficient
practice, everyone can get the hang of things
and can find this to be far more efficient and
effective than relying on graphical user
interfaces. While you can find many
examples of how effective and time-saving
the LUI method is, nothing provides the

finest example of its true efficient nature than
the command we use to update all the
applications and software within our Ubuntu.
Can you imagine how many individual
upgrades you would need to download and
install in Windows or Mac OS? The ones that
are related to your OS might be queued up,
but the software and applications will need to
be updated manually and separately.
Linux does things much easier. With a single
command, Linux will automatically upgrade
any packages that are outdated or have newer
versions available in the repository. Let us go
ahead and see how this can be done and how
quick it is. Open your terminal and type in the
following command:
sudo apt-get upgrade
The system will run through the packages and

locate the ones that are installed within it and
require an upgrade. You will be asked
whether you are happy to proceed with the
upgrade. Simply type in “Y” and hit Enter.
That is literally it.
Commands You Might Find
Useful
Here, we will briefly look through some
commands that can and will be used at some
point in time. It is generally a good idea to
have a look through these and understand
what each one of them does.
cp — This stands for “copy.” This command
copies one file into the other. You can also
copy multiple files by using the format
below. Replace file1, file2 with the names of

the files you wish to copy, along with the
name of the directory where you wish to copy
(shown here as target):
cp file1 file2 … fileN target
mv — Most likely, you have already guessed
it. This command moves the files.
touch — This command creates a quick file
for you.
cat — This command also allows you to
create your files. To create a file, simply type
in the command in the following manner:
cat > sample.txt
You will now be able to type in whatever you
wish to include within the file. If the file
“sample.txt” does not exist, the command
will create it for you. Once done, press
Ctrl+D to save and close.
rm — This command removes a file. This

deletes the file permanently.
echo — This friendly command prints
whatever the argument is on standard output.
mkdir — Use this command to make a new
directory within the working directory.
rmdir — Use this command to remove/delete
a directory. This command will only work if
the directory is vacant. If it has files, the
command will fail. However, should you still
wish to remove the directory and everything
within it, you can put in the following
command:
rmdir -rf (directory name)
less — This command is rather useful when
you are to view a directory or a file that has a
lot of text information and can leave you with
hundreds of lines to read from. Use this
command 
in 
the 
format 
of 
less,

/directory/sub-directory/file, and now you
will be presented with the information one
full screen at a time. Pressing the Space key
will advance to the next page, while pressing
the B key will go back a page. When done,
press the Q key to quit.
file — This command shows what kind of a
file the targeted file is.
passwd — This command allows you to
change your password.
diff — This command lets you see the
difference between the two files.
We can go on and on about commands and
explain every one of them to you. However,
there is a concept that you need to fully
understand prior to proceeding ahead with
more commands. We will now be looking
into the world of users and super users, who

they are, and what they do. We will also be
looking at ways to configure our system for
optimum productivity. Lastly, we will have a
bit of light shed on what user processes and
resources are.
In the meantime, you can go ahead and play
with most of these commands to get a good
grip. You will need all your understanding in
order to move forward from this point.

T
CHAPTER FOUR
TAKING COMMAND OF YOUR
SYSTEM
hings have started looking interesting. We
now have our first experience with the
line interface. We have used quite a few
commands to get things moving and have
already downloaded, installed, and even
deleted some files and applications.
The world of Linux has just started to unfold

for you. With each passing day, you will be
picking up new commands and learn to go
deeper into the coding world. Soon, you will
realize just why Linux is considered secure
and efficient compared to its counterparts.
While this stage may be a bit far off for the
absolute beginners, practice is something that
can assure you a path to success.
As a reminder, the ever-active community of
Ubuntu is always willing to help everyone
out. Should you ever run into a problem and
are not too sure what needs to be done,
always 
seek 
help 
prior 
to 
executing
commands or moving files.
Moving forward, we have now learned the
simple theories and even had our first taste of
the terminal and what it can do. Now, it is
time to take over the driving seat, control the

steering wheel, and drive. It’s quite a scary
way to put it, but it is a fact.
This does not mean that we will leave you
stranded; what we meant is to ensure that you
are able to steer clear of trouble and carry out
tasks on your will, create things, delete them,
move them about, alter permissions and
access to others. This is what you will be
focusing on within this chapter, starting with
something that has been with us since the
beginning of this book.
User and Super User
While all of that was going on, you may have
noticed the excess use of the term “sudo.”
Needless to say, this is no ordinary term as it
allows 
administrative 
privileges. 
The
question here is “Why?”

The term “sudo” is “super-user do.” This tells
the terminal that a super user has the reigns
and the terminal should now follow exactly
what the super user commands.
A person who has limited accessibility and
permissions is termed as a user. In our case,
we are both a user and a super user. When we
are browsing in our home directories,
downloading music and pictures, and storing
them there, we are acting as a user. However,
the minute we issue some high-level
commands that need authorization, we
become the super user. The super user (SU)
has access throughout the system. The SU
can decide what file needs to be kept,
changed, modified, or even deleted. The SU
has the right to allow access to some while
restricting accessing or even blocking others

completely.
Being a super user is fun, but it comes with
responsibilities. In order to make the most out
of this privilege, ensure that you understand
the concepts correctly as any error on your
part can end up harming the entire system and
even the network that you may manage. That
would be catastrophic and would bring forth
consequences no one would like to see.
Let us also look at a basic example that was
discussed before to give you an idea of the
privileges the SU has over a regular user.
drwxr-xr-x 3 exampletest exampletest 4096
Sep 01 12:00 Desktop
Remember this? We learned how to crack the
code of all the characters on the left. If you
still remember, let us now look at some
differences here.

This directory (in this case the Desktop) is
readable, writable, and executable by the root
user. The root user is also called as the super
user. Then a group (a regular user/users) can
only read this file and execute it but not
modify it in any way. This means that they
cannot alter any text, code, or even move or
remove the file. The last three are for all other
users who may be connected through a
network. They can also read the file and
execute the same but not alter it in any way.
Now, should the SU decide that this file is
safe to be shared and transfer the complete
ownership to some other group or decide that
users must have permission to edit the same,
he or she can actually change the permissions
quite easily. Let us first look at how
ownership can be changed.

Changing Ownership
We will use the sample.txt we created earlier
on as an example. Open the terminal and
browse to the directory where the file is
located. Now use the following command,
and you should see something like this:
ls -l ./sample.txt
-rw-r—r-- 1
From our previous encounter with such
coding, we know what these are. However,
this time, we intend to change these.
Do you see how the owner of the file has
access to read and write while others can only
read? We will need to change that so that
others can pour in their input to populate the
data, file, or even source code (if it was that).
To edit most of the text files, we normally use
simple text editors. With our Ubuntu, we

have a built-in text editor called the Nano.
We will use that to see whether we have the
capability to access, read, and write this file.
On the command terminal, head over to the
directory where the sample.txt lives. Now
type in the following command:
nano sample.txt
This will open up the Nano text editor. You
can edit any text file here as long as you have
the access and permission to do so. Currently,
you should have no problem in editing the
file, adding values, or changing them. You
can then press Ctrl+O and hit Enter to save
the file. To quit, press Ctrl+X.
Now, this went on rather easily and without
any challenges. What if we had a file created
in a place where we normally would not gain
access? Let us see how that turns out.

Let us open the terminal and try to create the
sample2.txt file using the cat command and
the > operator. You will face an error that
should say “Permission denied.”
Now, use another way to create the file using
the Nano editor. This time, while being
within the /etc directory, type in the following
command:
nano sample2.txt
You should now be within the Nano text
editor. However, when you try to save your
work, you will meet an error where you will
be reminded that you do not have permission
to do that. Use the Ctrl+X to quit.
Now, use the following command and see
what happens this time around:
sudo nano sample2.txt
Not only will you be able to write a text file,

but you will also now be able to save it
easily.
You can view the same by using the ls
command, and you should have no problem is
spotting the file within the list of others.
Use the ls -l command followed by the file
name to bring up the permission status. You
should now see something like this:
-rw-r--r-- 1 abcd efgh 4096 Jul 19 14:45
sample2.txt
We wish for this file to be shared with the
other two groups. For that, the permission for
the latter two groups should match that of the
owner. To do that, we will have to change the
ownership of the file.
We use the following command to do this:
sudo chown user:group (file)
Here, the user is “abcd,” as seen in the

previous example. Following that is the group
“efgh.” So to put the command right, you will
replace user with abcd and share it with the
group efgh. Lastly, enter the full filename and
hit Enter. This will change the ownership of
the file.
This allows the new owner to be able to
change, modify, and replace the contents of
the file without any special permission.
However, we cannot do this for every single
file unless absolutely essential. There must be
an easier way to allow others to see it.
Changing Permissions
Fortunately, there is, and it is quite easy as it
turns out. Use the following command to
change the permissions set by default on the
sample2.txt:
sudo 
chmod 
(permission1)(permission2)

(permission3) (filename)
6 – This indicates that the user/group/others
have read and write access.
4 – This indicates that the user/group/others
have only read access.
Currently, the sample2.txt file has 6, 4, and 4
settings. Now, we need to change that to 6, 6,
and 4. This implies that we want the owner
and group users to have “read and write”
access while others only have read access. To
do that, use the above format as indicated
below:
sudo chmod 664 sample2.txt
As soon as you hit Enter, the system will
immediately change the permissions as
directed by you, the super user. To verify the
same, use the ls -l ./sample2.txt command.
The sample2.txt has now served its purpose.

Go ahead and remove the file using the
commands we had looked upon in the last
chapter. Once done, let us proceed to some
more important aspects.
Creating Users
As the administrator, the owner, or even a
super user, you might be required to create a
user account within the system for login
purposes and to be able to carry out various
tasks and work within said login. How would
you do that?
Naturally, there are two ways we can do this.
Let us look at both these options and see how
each one of them works.
1. Using a graphical user interface (GUI).
This is perhaps the easiest way you can do
this. To create a user, go to the top right end
of the screen and access the user settings.

Click on the settings icon and select details
located at the bottom of the list. Now choose
users, and you should be able to view your
own settings. In order to add a user, you will
first need to use the root password. The root
password is the same that you used at the
time of installation. Click on unlock, enter the
password, and now you should be able to
create a user with ease. You can also choose
whether you would like to create a regular
user or a user with administrative privileges.
2. Using the line user interface (LUI). For
this, we need administrative privileges for the
commands to work. Go ahead and bring up
your terminal. Use the following command to
create a new user:
sudo adduser (name)
You will be asked for your password for

verification purposes. Once done, you should
now be asked to input a new password for the
new 
account. 
Choose 
your 
password
accordingly, fill out the information that will
be asked or simply hit Enter to skip each one
of them. Lastly, type “Y” when the prompt
asks. That should be that, and now your
system has a new standard user.
If at any point you wish to switch user, you
do not have to do the long and rather boring
task of logging out of the system, switching
accounts, and logging back in. Using the
terminal, all you need to do is type in the
following command followed by the name of
the account that you wish to change to.
su(name)
You may be asked for a password for the
account you wish to switch to. Be sure to

have that ready.
The SU command simply means “Switch
User.” Like we learned earlier, it is a lot
easier to do things through the terminal.
Creating a user or switching to another is
done within a matter of seconds. All it takes
is a bit of practice, and you should soon be
switching accounts, creating new ones, and
managing the entire system on your own.
Now that you have changed accounts, try
using the sudo nano command and create a
file named sample3.txt. You will be asked for
your user password, and then immediately,
you will meet this:
(name) is not in the sudoers file.
Quite an odd-looking error, isn’t it?
What the prompt is trying to say here is that
this user is not added as a sudo user.

If you wish to do this, it is quite easy. Just
enter the command in the following manner,
and the selected user will be added to the list
of sudo users.
sudo adduser (name) sudo
Now, this new user is a sudo user as well.
Now try to switch over to the newly created
account, put in your password, and then try to
see if you can create a new file using either
the “touch” or the “nano” command.
Removing Users
We have learned how to create users, but
what if there are just too many of them? What
if someone has decided to leave and his or
her credentials are still on the system? How
do you remove those?
Again, we will resort to both the GUI and the
LUI methods. We do this to ensure everyone

gets an idea of how things are done within the
thrilling world of Linux. Whatever suits you
best later on is yours to decide.
First, we use the graphical user interface:
1. Go to the user menu on the top right
side of the screen.
2. Click on Settings.
3. Select Details (the last option).
4. Click on users.
5. Click the unlock button.
6. Enter the root password.
7. Use the red button named “Remove
user.”
8. Decide whether you would like to
keep the files or delete them. Once
done, click the appropriate choice.

And that is it!
When you delete a user, you can delete the
user settings, but if you believe the files could
still be useful, ensure that you keep the files
created by this user saved and accessible. The
user, once deleted, will no longer have access
to the system or his or her created files.
Now, let us take another look at this using the
line user interface (LUI) method.
1. Open the terminal.
2. Type in: sudo deluser (username).
3. Hit Enter, and that is it!
Changing Passwords for Users
This is rather easily done on the graphical
user interface. However, we will only be
focusing on the terminal here and how we can

use it to change the password. In order to do
that, punch in the following command:
sudo passwd (username)
You can change any account’s password
without logging into these as long as you are
the super-user/root user.
Creating Groups
We initially touched upon the term “group”
when we were doing the permissions. We did
not dive deeper to know what exactly is a
group. Let us shed some light on this now as
it is relevant to both the topic at hand and to
you, the Linux user.
For every file or directory, permissions are
set out for owner, group, and others in that
specific order. If you recall from our previous
file permission exercise, you would see that

normally the owner gets the permissions right
away while others need to be modified to
taste.
A group is literally where a few users are
found. For example, you may have a file that
is relevant to the IT group. This group will
have users who have everything to do with
IT. Instead of assigning permissions to read
and write to individual users, you can simply
create a group and add the relevant users to
this group. Now, when you share your file to
the group, everyone within it will have
access.
To create a new group, simply type in the
following command:
sudo groupadd (groupname)
Changing Permissions for Group
Now we have created a group, let us now

share a file with it for read and write
accessibility. Below is an example for you to
see and try to figure out what was done.
Don’t worry, all of these commands are
already covered by us.
touch file123
mkdir test123
mv file123 test123
cd test123
ls -l
Did you figure out what we did there? If you
haven’t, let us explain.
We started out with the “touch” command to
create a file named “file123.” We followed
by creating a directory using the make-
directory (mkdir) command, and we named it
“test123.” We then moved the file using the
“mv” command into the directory we created.

Lastly, we entered the newly created
directory and used the listing command
(long) to show us the permissions, owner, and
group information.
Yet again, the mighty terminal saves us time.
Imagine doing that without the terminal. It
would have taken a little longer to pull all
that off. Anyways, enough with praising the
terminal; let us move forward.
As a test, let us wait here while you change
the ownership to “group” to give them read
and write permissions by using the “chown”
commands. A tip: if it doesn’t go smoothly,
use the sudo command!
All done? Bravo! You have just changed the
ownership of the file and provided the group
with the required permission.
“But we don’t have a user added to the group

yet.”
Right you are! That is why our next step is to
ensure we learn how to add users to our
newly created group. For the sake of an
example, let us call this group “learners.”
Use the following command to add the user
within this group:
sudo adduser (username) learners
If you switch to the username you just added
to the group and try to access “file123,” you
will also be able to access it without any
issues. The reason why that happened is that
we have allowed the entire group to have
ownership over the file and have the
necessary permissions to view and edit them.
Now, since your new user is a part of this
group, the user will have similar access as
well.

To verify, use the Nano command without the
sudo, and you should now be able to write the
file and edit the same as you please.
This is something that can be seen in effect
throughout major organizations and industries
where thousands of employees and managers
are added into groups and provided uniform
access to files and directories that serve them
some purpose.
We will also be looking at some other
commands and examples further on. For now,
let us get a little deeper into system
configuration — what it is, why we need to
configure the system, and what can it do for
us in return. These are some of the questions
that you should be able to answer at a
beginner level. For advanced usage of the
system and its configurations, you can refer

to great books and browse through the Ask
Ubuntu community for further guidance.
Configuring Your System
We now have good knowledge about who
super users are, what they do, and how they
can add and remove files, users, and so on.
The most important aspect for a super user is
to ensure that the system is configured
properly. This means from the tiniest details,
such as the time, all the way to maintaining
the server and carrying out the necessary
tasks. As the main user, you will have the
right to type in a few commands that should
immediately alert every user on that machine
or server that the entire system is about to be
brought to a halt or will not be available.
During this time, only you will have access to

the files, directories, and all. This method
allows you to carry out updates, change files,
upgrade the system, or carry out any
maintenance work.
While all that is true, why did we mention
time? Every user on the server or the machine
will be following a single time as set by the
main user. It is imperative that every user
follows the same as this makes logging
easier.
If you run a large organization where users
will have to sign in using thumb impressions
or where they need to type in their passwords,
modify files, create new ones, or even
move/delete them, you must be able to know
exactly when the action was carried out. The
entire information will be available in the log
files for you or the concerned person to see.

Having multiple times will only cause
confusion, which is why a uniform time is
followed by everyone. However, before all
that, let us fix the time of our own machine.
Before you jump in and decide to use the
GUI and set the clock to the time that is near
to being accurate, it is best to understand one
thing — adjusting time through this method
will never be 100% accurate. You need
something else to help you out in order to set
the system’s time accurately.
Every kernel maintains its very own system
clock. This is the same clock that you can
access by using the “date” command. Go
ahead and type in the command in your
terminal and hit Enter.
You will be provided with the complete date,
time, and the time zone. However, some of

you may have noticed something off here.
The time shown within the terminal as output
is different from the one being shown in
Windows. The bigger the difference in
minutes, the worse the issue can get for you.
The good news is, we are just beginners
learning to perfect our command over the
system. We are using a VM, so having a
slight difference is okay. But what if we were
using Linux as our primary system? How
could we correct the time then?
It is one thing to have a minute or two worth
of difference, but even that can cost you quite
a bit of confusion if you are dealing with log
files with thousands of entries. Imagine how
bad it would be if you have a ten-minute
difference or more. For the sake of
discussion, if you were using Linux as your

primary OS, you would need to resort to the
following command:
hwclock –hctosys –utc
For VM users, this may return with an error!
This effectively resets the system clock to the
universal coordinated time and saves you
from the worries of adjusting time every now
and then for time zones, daylight savings, and
so on. To answer a burning question “What is
a practical example of where having
synchronized time would help us?” here is a
scenario.
Let us suppose that at exactly quarter past
noon tomorrow, we need to upgrade the
system completely. We need to ensure no one
is using the servers or the machines at that
specific time. How can we do that?
There is always email, but the fact of the

matter is that not everyone follows these
instructions. We need something that is more
prominent and cannot be missed by anyone.
Luckily, Linux provides us with a way to do
just that.
Look at the command below and try to figure
out what just happens when you, as a super-
user or an administrator, type this in and hit
Enter:
sudo 
shutdown 
-h 
+5 
“scheduled
maintenance”
You are informing the terminal that you, the
administrator, wish to shut down the system
by bringing it to a halt (h) after five minutes
(+5). The message that everyone will be
displayed will be the string shows between
the quotation marks. This way, every single
user will get the message accordingly, and

precisely five minutes later, the system will
no longer be accessible by anyone except
you.
You can provide an absolute time as well in
the form of hours and minutes. For example,
if you know the maintenance would begin at
12:15, simply use 12:15 instead. If the system
requires urgent attention, you can use “now,”
which will immediately shut the system down
for everyone.
Now, the system will be in a single-user
mode where you will be the only user logged
in through the system console. Every non-
essential service will be turned off. You can
carry out the task to ensure maintenance work
is done. Once all set, press Ctrl+D, and you
should have the system turn back to multi-
user mode.

There are a few useful commands you can
use instead of the -h or the halt method.
-r
This reboots the system.
-k We are not joking when we say this
means 
“kidding.” 
This 
command
broadcasts a message to inform other
users of scheduled maintenance. It
doesn’t really perform a shutdown.
-c
If you wish to cancel a shutdown, this is
your command to go to.
We will cover more about networking and
how to make use of the available commands
and tools to ensure the work is carried out
where every other machine is in sync with the
server and acts accordingly.
Apart from carrying out maintenance, you
may also encounter issues with the system.
You were off duty or away from the system,

and the system crashed for an unknown
reason. You come back and are taken by
surprise at the state of affairs. The first
question to pop up would be “What
happened?”
If you are someone who has no idea where to
begin, the system logger is your best starting
point. The system logger is what keeps track
of everything that happens in the entire
system. It creates a log file that can be
accessed at any time to understand where
things may have gone wrong.
The syslog file can be found under /var/log
directory. Execute the file, and you should be
able to find out all the relevant details
accordingly 
with 
timestamps, 
events,
responses, errors, reasons, etc.
For all system administrators, these files are

important and must be used whenever needed
in order to resolve issues accordingly.
Without these files, it is virtually impossible
to find out the root of the problem and take
appropriate actions. These files save you
time, effort, and in rare cases, quite a lot of
embarrassment. It would certainly be a shock
to all if you end up performing all the known
commands to rectify a problem that isn’t
there to begin with and someone accesses this
file to reveal that the problem was just a
simple misplaced file.
As someone who will be looking to configure
systems in the future, you will be required to
install, upgrade, update, or even remove files
or applications. We already know how we
can do that. In fact, we did some exercise
with the apt-get, apt-cache, and other

commands. With that said, not all file formats
are supported by all distros. There are some
that stand out and hence are exclusive to
certain types of Linux distros. Let us have a
brief look over some of them to get an idea.
1. .rpm files — These installation
packages are mainly supported by
Fedora, Red Hat, CentOS, along
with some other distributions. These
are not supported by Debian-based
flavors such as Ubuntu. These files
use 
separate 
commands 
called
“yum,” “rpm,” and “dnf.”
2. .deb files — These are Debian
package files and are supported
across all Debian-based flavors,
including Ubuntu. We have already

seen that these are installed by the
“apt-get” and “dpkg” commands.
3. .tar.gz and .tar.bz2 files — These
are 
quite 
different 
and 
are
essentially compressed tar files.
These are not directly installable as
they have various files and folders
within them, compressed using gzip
(.gz) and/or bzip2 (.bz2). Unlike the
previous two files, these require
quite a few steps in order to be
installed.
Although it is virtually impossible to install
the wrong kind of file on Linux these days,
owing to the modern installers on board, it is
still good to know which files belong where.
System configuration is quite a hectic task to
carry out. Rest assured, it is only the first

time that you may feel a strain. Once most of
the things are in place, you will no longer be
feeling the pressure of keeping everything
aligned and updated. Most of the tasks will be
done for you. On the off chance that things
end up going wrong, you can always consult
the log files.
The great thing about having an open-source
operating system is that every user within the
community can help you out easily with the
issue, and you can end up mastering quite a
lot of codes and essentials throughout your
Linux journey. Know just about enough, and
you can be quite a successful system
administrator.
User Resources and Processes
Before we get into the world of resource
allocation, processes, and tools that allow us

to look deeper into these, let us imagine a
scenario. We have the best machine that
money can buy, and it is equipped with top-
notch specifications. It has the best RAM, the
finest CPUs, the ultimate graphics card, and
all that you can dream of having in a truly
powerful computer. One fine day, you initiate
a process, and immediately the system grinds
to a halt or starts to slow down to a crawl.
Can you imagine the frustration you will go
through? Despite the best specs, your PC is
unable to carry out operations properly, and
you have no idea why. It is enough of an
ordeal to push any computer user over the
edge.
In order for us to understand why this often
happens to the best of the machines, we need
to dig a little deeper into how processes work

and how the resources are utilized for the
users.
The three core resources a system has are the
CPU itself, the memory it has, and the I/O.
Take any of these out of the equation, and the
system isn’t going to work all that great.
These are classified as hardware resources.
The kernel, on the other hand, is responsible
for distributing all of the available resources
to the processes without bias. Ironically, the
kernel itself is a software resource that helps
processes to carry out various tasks that the
user requires them to do.
The relationship between the kernel and the
hardware resources, if disturbed or severed,
would end in system failure. The system will
have the resources but no medium to allow
programs to use it. It would just be a glass of

water on top of a table with no one to drink
from it.
The 
art 
behind 
successful 
resource
management is to use a tool that can provide
you with the required information in real-
time. There are many programs and tasks that
may not take a lot of resources, but there will
be some that require quite a chunk of the
available resources. And since the kernel is
not biased, the kernel will distribute such
programs the required resource.
To find out just what is using your resources,
how much of your resources are being used,
and for how long the processes have been
active, we use a command called “top.” Go
ahead and type the command on your
terminal and see what happens.
Windows users might recall the use of the

Task Manager tool. This is the Linux’s
equivalent to that.
The screen is immediately crowded with
many numbers, names, facts, and figures.
While you may have thought you had enough
power, this tool will now show you just
where all those resources are being used. Let
us look at each of these items and learn what
they correspond to.
PID
This is the process ID. Every single
process that is listed or may be added
later on has a special identification
number. Through these, you can
learn how to manage processes more
effectively once you master the tools.
USER This simply tells you which user is
using the said process.
PR
This tab shows the priority of the

task that is being run. If any task
shows “rt” in this field, it denotes a
real-time scheduling priority.
NI
This stands for (and we are not
making things up) “nice” value of
the task in question. If this is in a
negative number, the task gets a
higher priority. If this is in a positive
number, the task gets a lower
priority.
VIRT This shows the virtual memory size
that is being used by the said task.
RES
This shows the physical memory that
is being used by the task (non-
swapped).
SHR
This shows how much shared
memory is available for a task.
S
This shows the process status. This

field has further options, which are
as follows:
-D – uninterruptible sleep
-R – running
-S – sleeping
-T – stopped by job control
signal
-t – stopped by debugger
during a trace (remember,
capitalization matters)
-I – idle (formerly Zombie)
%CPU – shows how much
of the CPU in percentage a
process is using
%MEM – shows how much
of the memory is being used
by a task
TIME+ – shows how long

has a task been running for
COMMAND – shows what
command a user can use to
access the task
All of these can serve you with a handful of
information that might be essential to manage
the system better.
Resources are limited by nature. Using them
by tasks or processes that are unneeded
would only slow others down. As a system
administrator, we aim to keep as many of
these resources available to users as possible.
To end or kill a task or a process, use the
“kill” command followed by the PID of the
process. You can also get more information
about kill commands by typing “kill --help.”
To exit the “top” command session, use

Ctrl+C.
There is another command that you can use to
bring up all the processes and some
information about their resource utilization. It
is called the “ps aux” command. However,
unlike the previously used “top” command,
this command will not show the data in real-
time. It will only grab the figures available at
the time of the execution of this command.
Apart from the above commands, there are
tools that are designed to provide you even
greater insights on how your resources are
being used. Let us look at one of these
examples.
Firstly, we will need to have this tool
installed in our system. The tool is called
ATop. Type in the following command in the
terminal to install the tool:

sudo apt-get install atop
This will install this fabulous tool in our
system that will allow us finer details about
the processes and their usage of resources and
memory. Whether you are an individual user
or maintaining a group of users, resources are
precious, and they must be monitored on a
regular basis to ensure processes are running
smoothly. If a process is consuming an
alarmingly high capacity of resources, it is
best to kill the process and reacquire the
resources for other processes.
You can get to learn quite a lot more about
this tool by using the “man” command in the
following manner:
man atop
This will show you the complete manual for
the ATop tool. It will provide you all the

known 
and 
used 
commands 
and 
the
description for each one of them. It is quite a
handy guide to have.
To quit the manual, simply type in “q.”
To access the tool, type the following
command to bring up the monitoring tool:
atop
You should now be able to see a list of things
that were otherwise not shown by the “top” or
the “ps aux” counterparts. This makes
decision-making a lot easier for the users and
for the administrators.
To gain further insights, you can use the
manual to find out the relevant commands or
use the man -h command to get access to
more commands.
The ATop tool has been generally the go-to
tool for most programmers, users, and

administrators as this tool allows an extensive
range of information that otherwise might be
quite hard to access. If you are looking to find
out how many resources a particular program
uses, the other counterparts may or may not
tell you that, but the ATop will provide you
with a complete list of the processes and
resources that a specific program is using.
Such tools greatly allow you to monitor your
resources, 
understand 
your 
system’s
performance on a better level, and allows you
to take control of the resource allocation.
While it is the kernel’s job to automatically
assign and allocate resources to the processes,
you can still jump in and halt or even kill the
process that may be taking an unnecessarily
high number of available resources to save
the performance of the system.

The Ubuntu store and repository hold many
great tools. You can find out more about
these on the internet in case you are not
comfortable 
using 
the 
ATop 
resource
monitoring tool. However, not all tools would
be able to deliver your desired results, which
is why the ATop tool is highly recommended.
While the above is only monitoring the CPU
and the memory, except for ATop, you might
at times wish to monitor the I/O levels of the
computer. To do that, you need to first install
“sysstat” tool. We already know how we can
do that. Once done, you can use the following
command:
iostat
This command allows you to have a look
inside the system and see the general I/O stats
at any given point. You can run this

command without an option, and the
command will show you the necessary
information. However, should you wish to go
deeper, you can always check out the manual
of “iostat” command by using the “man”
prefix.
These 
tools 
allow 
a 
user 
complete
accessibility to information that will serve
them with insights. Using these stats, we can
manage our systems far more effectively than
just trying to add RAM modules, trying to
invest a large chunk of money into a new,
upgraded machine. The machine specs do
matter, but there are always certain processes
that, if left unattended, will bring down even
the fastest machine on earth.
A successful organization will ensure that
their IT department assure smooth sailing for

all the computer users. A successful system
administrator will use all these tools,
understand exactly what needs to be done,
and utilize the resources accordingly. The
administrator will also ensure that any
harmful or unnecessary process is killed and
that user resources are always available for
the users and their processes. System
configuration and management is quite a vast
topic and cannot be covered in just a chapter
or two. Our efforts have been to ensure only
the basics are provided to allow users to start
exploring the system and develop a basic
understanding of how processes work, how
the resources are utilized by the kernel, etc.
With that said, we now change pace and go
up a notch by looking into a more technical
field of networking in the next chapter.

I
CHAPTER FIVE
KNOWING YOUR NETWORK
CONFIGURATIONS
n this chapter, we will be looking into the
basics of networking. We will learn how to
effectively transfer files from one end of the
network to the other and learn about some
network applications that you can use to
further add to productivity.
Before we jump into the world of networking,

it is essential to understand that networking is
quite a vast topic in its own right. There is no
denying the fact that networking requires
extensive knowledge in order to fully
comprehend the concepts, processes, and
every tiny detail there is. With that said, we
will try to remain to the basics and cover only
the aspects that are absolutely essential for
everyone to know and learn.
The objective is to provide a user with
enough knowledge to have a look around in
the network and be able to explore the
environment and manage a small network on
their own. This would include all that we are
aiming to learn within this chapter. For more
advanced material and references, you always
have the friendly Ubuntu community to help
you with virtually any Linux-related problem

you may run into. There are many other
mediums through which you can find a lot of
information on networking, but almost all of
them will require you to have some basic
understanding 
of 
certain 
concepts 
and
procedures in order to make the most out of
the opportunity.
Let us start with the chapter and look just
what networking is and how it functions.
Network: The Basics
Not so long ago, the internet was seen as
magic by quite a few people. Those who
never had any idea about how the internet
works were left in amazed states. Type in
anything, and magically, you would be
provided with results that apparently answer
the query. With the passage of time,
awareness came in and filled the void. Now,

most of the people who may not even be
linked to networking remotely know about
servers, the internet protocol addresses, and
routers. Truth be told, these are quite
important aspects of a network or even
networking itself. This is a good start, but we
need to learn a little more than just routers
and servers. We need to know what keeps
them alive, how they are managed, how they
are upgraded, etc. in order to be a successful
network administrator. While we may not
cover all of it in just a chapter, we do
certainly encourage the beginners to seek out
more information on other books and
mediums on networking. It can provide you
with a wealth of knowledge and equally good
opportunities to seek a promising career.
In order for us to understand network and

networking, we must forget Linux for now.
Why? Some of these concepts are quite basic
but apply exactly the same to every OS. We
need to ensure we first create a good
understanding, after which we can bring that
knowledge and apply it in Linux.
What we need is a bit of an insight on what is
networking in general. To serve you with
one, let us take you, the reader, as an
example. Right now, you are connected to a
computerized device, using it to either read or
watch a video of your choice. In either way,
both of these require you to access the
internet. The internet is where you can find
billions of pages, full of information that may
be of some use to someone somewhere
around the world. Certain things are at play
here that understand what you are searching

for, and then these little components fetch the
required information for you and present it
before you in text or pictures or even videos.
Let us look a little deeper here and try to find
out 
just 
what 
invisible 
elements 
are
functioning here to ensure we are able to
access 
the 
internet 
and 
acquire 
the
information we need successfully.
Your computer or computerized device is
connected to a modem/router. The router is
what connects you with your internet service
provider (ISP). The internet isn’t with your
ISP as they, too, have various devices that are
connected to the actual internet. Remember
this mapping for now as this will help you
clarify how things work in greater details.
Let us assume that you wish to access your
favorite search engine. You open your

browser and type in the web address of this
search engine. The data is forwarded to your
router by your browser. The router then sends
this information to your ISP. Once your ISP
receives this information, it uses that and
routes it through a domain name system
(DNS) server. This server analyzes the string
(text) that you had sent from your machine
and matches it with the records and then
serves the appropriate content, page, or video
to your machine’s screen.
The interesting thing to note here is that these
giant servers, DNS servers, routers, they do
not understand the same language we do. All
of the information that we send out is
converted into ones and zeros, which the
machines will easily understand. When the
same information is presented to our screens,

it is converted into characters and alphabets
that will make sense to us.
Suppose you wish to type in the web address
of 
Google. 
To 
us, 
it 
would
be www.google.com, but to the internet, it
would be completely different.
All these machines work in a connected
manner, where each of them relies on each
other to receive, understand, locate, and
produce queries pushed or demanded by the
end-user. There are thousands of DNS servers
and private servers set up across the world
that help regulate the flow of information for
everyone across the globe. They are not
identified with names; instead, they have
addresses. These are often termed as internet
protocol (IP) addresses. Each server, each
machine, has a unique address. This is what

allows networks and DNS servers to identify
each other more easily.
When we search the internet for something,
we normally provide the internet with a
domain name for a website. The DNS then
identifies the domain name, checks with its
records to find out which IP address such
requests are to be directed to, and points you
in the right direction by taking you to the
desired web address or domain that you had
intended. This is located within a web server
that receives your request and other related
information about you or your system and the
specific 
content 
you 
are 
trying 
to
view/access. Finally, the page loads up, and
you are able to view what you wanted. The
magic here is that the entire process (the
sending of the request and receiving of

results) takes merely a second or so. This is
the world of networking that makes all of this
happen flawlessly.
Therefore, from the above, we can see that a
network is essentially a virtual linkage where
various computers, devices, routers, and
servers are connected. Networking then is
just a matter of transferring data from one
point to the other per requests.
You can essentially have a network as small
as you like, which would only comprise of
you and probably other users within your
house. This is called a local network. This is
where you or the users within your house
connected to the router, which accesses the
internet and fetches the required information
as we discussed earlier. The problem here is
that with an increasing number of people, IP

addresses are running out. How? Let us
explain that a little more.
IP addresses are in the format as shown
below:
1.1.1.1
The maximum range that this format can
support is 255.255.255.255. While the
combinations are extremely high, they are not
high enough to support every machine that is
connected to the internet. For well over a
decade, the internet has been struggling as it
has been, constantly running out of IP
addresses. Various solutions have come forth
to ensure this doesn’t happen again.
Let us get back to the example of us and our
little home here. Say we have about four
devices connected to the router. The home-
based router normally would provide you

with such IPs:
192.168.0.1
192.168.0.2
192.168.0.3
192.168.0.4
This may seem fine; the fact is that the ISP
has only provided us with a single IP, and
none of these match that. That address is the
ISP address and will completely differ from
our router’s IP address. This means that these
four IP addresses would still appear as one to
the ISP and to the internet. Can you see the
confusion this would cause? You decide to
browse to Google, your brother decides to
browse to Yahoo, while two more people
within your house connect to other webpages.
The internet will provide your ISP the result,
which will be pushed to the router, and

everyone would end up opening the same
page.
To ensure that doesn’t happen, we have what
is called a network address translation (NAT)
in place. This is what keeps the router from
mixing up IP addresses and translates each
request from those specific IPs and vice
versa. The router will hold a single IP
address, and the connected devices will be
provided NAT addresses that will help the
router keep track of all devices and requests.
Hopefully, you were able to digest all that to
understand what a network is, what the IP
address is, and how they function. Time has
come to visit the terminal once again.
Go ahead and launch your terminal. We will
now go through some network commands
that will prove rather useful for you.

The first thing we are about to learn and type
might be somewhat familiar, especially if we
have any computer users with a history of
gaming. It is called the ping command. This
command is essentially to check whether or
not you can acquire a successful response
from a server or a domain. This command is
essential if you are unable to access or reach
a specific website. You can run this command
to analyze if the browser has stopped
functioning or if the entire network has gone
down.
To run a ping command, type in the
following command:
ping (address)
To illustrate the response, we have used the
ping command and used google.com as our
address. Once you hit Enter, you can see

results such as these:
PING google.com (216.58.207.110) 56(84)
bytes of data.
64 
bytes 
from 
app 
(216.58.207.110):
icmp_seq=1 ttl=51 time=24.0 ms
64 
bytes 
from 
app 
(216.58.207.110):
icmp_seq=2 ttl=51 time=39.2 ms
64 
bytes 
from 
app 
(216.58.207.110):
icmp_seq=3 ttl=51 time=28.9 ms
64 
bytes 
from 
app 
(216.58.207.110):
icmp_seq=4 ttl=51 time=43.6 ms
64 
bytes 
from 
app 
(216.58.207.110):
icmp_seq=5 ttl=51 time=24.4 ms
64 
bytes 
from 
app 
(216.58.207.110):
icmp_seq=7 ttl=51 time=26.3 ms
^C
--- google.com ping statistics ---
7 packets transmitted, 6 received, 14.2857%

packet loss, time 45ms
rtt 
min/avg/max/mdev 
=
24.014/31.065/43.569/7.577 ms
You can always stop the process by pressing
Ctrl+C.
The above shows the response time for each
sequence. The statistics below show the
number of packets transmitted, received, and
lost (%), as well as the time and so on. This
information is vital to have on hand when you
run into potential network-related problems.
Too much time or delay in response can
cause issues and delay data and information
flow. Remember when we mentioned about
the gamers, they experience lags if the server
response time is high? What this means is
that they may see their character running
straight through, but owing to the server

delay time, they have yet to find out that
someone already took their character out.
When the signal is received back again,
everything happens immediately, and the
gamer has no idea what just happened.
Ping is just a simple command to get you in
on what a network is and how steadily it
connects to the server in question. We will be
discussing 
some 
essential 
network
applications and tools in the “Network
Applications” section. In the meantime, let us
delve deeper into the network and learn how
to start transferring files and data.
Using Network to Transfer Files
This might not be as hard as you might
imagine. All it takes is a bit of practice and a
little eye out for details.
We have established an understanding of

what a network is and how to identify
machines that are connected to the said
network. We use their IP addresses unless
they have specific domain names, in which
case, we will use those instead. Now we wish
to start moving data back and forth. We have
quite a lot of files that need to be transferred
and quite a few that we require from the
remote servers or locations.
We start things off by learning a simple
command that allows us to copy a file from
our local system to a remote system. Let us
assume that the remote machine has a user
account named user1@abc.def.com and we
wish to send a file named as “sample4.” In
order to do that, we will need to use the
command called “scp.” To execute this, open
the terminal in the location where the file is

and then type the command like this:
scp sample4 user1@abc.def.com:
If you recall, just moments ago, we
mentioned you need to keep an eye out for
details. See the colon (:) in the end? That is
not a typographical error. That is done on
purpose. If you miss this out, you will end up
creating a copy of a file named as
user1@abc.def.com, which kind of defeats
the purpose of the entire exercise. If you do
the command correctly, you will see a
confirmation for that.
This is one of the most basic commands used
in the world of Linux. While there are quite a
few commands out there, which we will
mention here for reference purposes, the
“scp” is rather easy to use and understand.
Now let us try that the other way around.

scp user1@abc.def.com:sample4 .
Now, we used the same command but
changed the order. Let us try to see what
happened here by first understanding the
syntax of this command.
scp source_file destination_file
As we see here, the source file this time was
in the remote computer/server. We wanted a
file named sample4 to be copied securely into
our system (destination file). After the colon,
we specified the file we wanted and then used
a period (.), which indicated a local machine
— i.e., your machine. After you press Enter,
you will have that file copied in your system.
You can also rename the source file and place
it into a directory of your choosing by doing
this:
scp 
sample4

user1@abc.def.com:.test/sample5
This will effectively rename the file to
sample5 and place it within the local “test”
directory. You can specify a path, and the rest
will be done for you.
To get a full spectrum of the scp command,
have a look at the manual by using the man
command.
This command is good if you have a few
files, but what if you wish to transfer a whole
bunch of files or maybe the complete
directory? For that, we use another command
called the “rsync” command.
This command has multiple uses and can be
used to move or copy (mirror) data and files
across a single machine or the entire network.
The command is terrific for the purpose of
backing up your data on remote machines or

servers. To use the command, you need to
follow the syntax below:
rsync [options] source destination
With over 50 options, you can easily and
securely copy the entire directories or the
content of the said directory across a single
machine or the network itself. You might be
asked for administrative permission in order
to do that as this uses SSH to secure the entire
connection 
and 
prevents 
anyone 
from
“listening.” That is just another word to
suggest 
someone 
is 
monitoring 
your
activities.
There are far too many tools and applications
that have come forth in recent times. Whether
you decide to use the LUI as a medium of
data transfer or GUI, you have your options
with you. Be sure that you always use reliable

sources 
and 
monitor 
activities 
and
connections on a regular basis to ensure
safety for your data and for the network itself.
Network Applications
There are quite a few commands and
diagnostic tools that can help you out on your
journey as a network specialist or even as a
secure home user. Knowing these is essential
and can protect you from quite a lot of
suspicious connections and hackers. These
tools will also allow you to indulge deeper
and create a better understanding of how the
network operates and how other devices act
when they are a part of the network. For now,
let us proceed in getting ourselves acquainted
with some important tools.
Let us clear the terminal by using the clear
command and use an important command

you should know as a part of your basic
learning. It is called the “ifconfig.”
Windows users who may have used a
command on their command prompt called
“ipconfig” would find this familiar.
Go ahead and type in “ifconfig.” You will
now be presented with quite a populated
screen, full of information. This is your
network information and shows exactly how
the network is configured.
Note: For users who may face error, you
might need to install net-tools. The command
for that is “sudo apt install net-tools.”
The information that you see here would
allow you to take a closer look into how some
of your network settings are. These will
include your ethernet settings, your wireless
settings, and information about your localhost

as well. Some of these are quite useful pieces
of information and can come in handy should
the situation call for it.
Most of the information displayed is easy to
understand, but if you find any of the terms or
columns hard to read, you can always rely on
trusty old Ubuntu community to acquire
further insights.
Next stop, we will be looking at the
command called the “tcpdump.” This is
basically a packet sniffer — literally! It
analyzes all the packets that come in or go
out of your system. Why do we need this?
We will learn that soon enough.
In order for us to have this, go ahead and
install “tcpdump” by typing in the following
command:
sudo apt-get install tcpdump

Once installed, go ahead and run the tool by
typing this (requires sudo):
sudo tcpdump
Don’t be alarmed if you are not getting
anything as of yet. Just open a browser
window and go to any website of your
choice. As soon as you press Enter on the
browser, switch your window and come back
to the terminal. Your terminal screen will
now start an endless process of sniffing all
the packets that are leaving or entering your
system. You will need to bring this to a halt
by pressing Ctrl+C.
The problem with this command is that it
never ends if you have a few network-based
activities running in the background. What
you can do, however, is to limit the data
sniffing. Suppose you only want to capture a

set number of packets (let’s say 20), you can
slightly change the command to do exactly
that.
sudo tcpdump -c 20
The command will execute the moment you
hit Enter and will capture the next 20 packets
sent out or received. We use the “tcpdump”
command to find out where these packets are
being sent to and where are they being
received. In our example, you will notice that
an outgoing packet will have your IP address,
the domain, and the address, while the
opposite will show accordingly.
This command is essential to analyze data
and can track down any unknown addresses
where information might be leaking to or
coming from. Such suspicious addresses or
domains can then be clocked accordingly to

ensure the safety of the system and the
network itself. The command also allows you
to see the packets that are being sent out and
received by a specific interface that is
connected on your network.
Suppose you have a wireless router on your
network and you wish to check the kind of
activity that is taking place through it. You
can do that simply by typing in the following
command.
sudo tcpdump -c (number of packets) -i
(device name)
This will start collecting results for the said
device and capture the number of packets you
have set — quite a sneaky way to check on
what your co-workers or colleagues are
doing.
Similarly, you can also use the same

command to check up on your ports or have
the packets shown in ASCII format or even
hex format. The application for this tool is
vast. You can always check the manual of
this tool by typing in “man tcpdump” to get
the complete options you have available with
this command.
Before we go ahead and get into the basics of
moving files and folders across the network,
there is one more command you might find
useful to determine who is connected to your
network. It is called the “netstat” command,
and it can provide you with a great helping
hand in order to find out if someone is hidden
yet connected to your network. To do this,
type in the command in your terminal with
the following option:
netstat -nr

Instead of showing domains, you will now be
provided with the IP addresses and the IP
routing table. You can also check the network
interface statistics by using the command
below:
netstat -i
This now shows us the usage of all of the
devices. You can find out how many packets
are being sent out or being received by
individual devices.
Lastly, you can find out what active sockets
are being used currently by your network, and
to do that, you need to use another netstat
command with a -ta option. This will list out
active sockets with their address (local and
foreign), their state, and some other useful
information. This kind of information can be
vital for anyone who is looking after the

security of the entire network.
The netstat command is used to monitor the
active connections with your network and
helps you in blocking any unwanted or
suspicious connections that may provide an
entry for hackers and malware. You can also
keep track of all the packets that are being
sent and received. This command is always a
go-to command for most of the network and
system administrators.
While 
your 
network 
is 
engaged 
and
connected to various devices, all trying to
access it and acquire or provide information,
something needs to step it to keep an eye on
the security here. This is where the Secure
Shell (SSH) comes into play.
Before SSH came along, there was Telnet.
This was initially seen as a revolution where

a person could access another remote
machine without being there physically. This
caught the attention of all kinds of people,
including some prying eyes too. Soon
enough, people realized that these methods
were not secure and anyone could practically
“eavesdrop” on their exchange.
The SSH does what Telnet failed to do so; it
encrypts all of your data of the session. It also
allows clients of any operating system a
secure way to transfer their files and folders
without worrying about prying eyes in the
middle. Understanding SSH is not a day’s job
or even that of a book. There is quite a lot of
material available out there for those who
wish to acquire more information about
cryptography, SSH, and SSHD. These are on
an advanced level and hence would not suit

the beginners at this point in time.
It takes time and practice to get the hang of
things in the world of Linux, but once you
start to understand how things work, you will
soon be surfing over issues as if they mean
nothing. It is probably a good idea to get used
to the fact that the LUI is your best friend
here. Quite a lot of people might find this
shift from GUI to LUI a bit daunting, but rest
assured, it is a move that will only cement
your position as a successful system
administrator and a super user.

L
CHAPTER SIX
SHELL, SCRIPTS, AND TOOLS
inux is meant to be used for security
purposes. It is known to offer security of
the finest level with various distros and
flavors that it rolls out. It is then of no
surprise that Linux is being used in
government and military installations. This
shows just how flawless its security is.
On the other hand, Linux is also used as a
popular 
choice 
by 
programmers 
and

developers alike. This is mainly because of
the security but also because it offers them an
effective platform where they can create
flawless applications and carry out tons of
work in the least amount of time. One fine
example of how you can save time and
accomplish a lot is shell script.
Shell scripts are also called as Bourne scripts.
These are files in which you provide the shell
a series of command to run. Now, you might
be wondering, how is it any different than us
entering commands in the terminal?
Basics of Shell Scripts
Shell scripts are somewhat of a playground
for programmers. You can quite literally
create small programs within it and use as
many commands as you like. Let us look at
an example of how these scripts are created.

1. Open your terminal window.
2. Create a directory on your desktop
(optional).
3. In the directory, create a file using the
touch command.
4. Ensure that you name the file with a .sh
extension.
5. Use sudo nano command to access the
newly created file.
6. Start the script as under:
#!/bin/sh
7. You will now need to write some codes
and use echo and ls, for example.
8. Save the file.
9. Close and then execute the file using bash
(filename.sh).
You will now see the entire thing carried out
for you. Shell scripts save you quite a lot of

time and provide you with a very effective
and efficient way to get desired results
without wasting time and energy.
The shell script always starts with the
shebang (#!) sign. If you did not get through
to the script creation part the last time, let us
create two dummy scripts to further practice
and understand shell scripts.
1. Let us create a new file named
“sample6.sh.” Be sure to use the .sh in the
end. Save it and now use the nano editor to
access the same.
2. Always start your script with the shebang
sign followed by /bin/sh. You can then add
the listing command. You script should now
look like this:
#!/bin/sh
ls

3. Now you should save the script and close
it.
4. Use the command “bash sample6.sh” and
hit Enter.
You just executed a script. Now let us add in
another command. We want to view the
working directory we are in and then get the
listing for that directory. To do that, your
script should look like this:
#!/bin/sh
pwd
ls
All set? Save it, and now it is time to execute
the same. As soon as you do, you will see just
how quickly the entire thing was executed.
That is the power of shell script.
There are certain rules and methods that you
may have to learn in more details in order to

truly draw benefits from the shell script.
These include learning the use of literals,
single and double quotation marks, variables,
etc. It is also advised that while these scripts
are powerful, you are still better off using
advanced languages like Python and C to
carry out complex operations.
Knowing When to Use Shell Scripts
We did mention above that the shell scripts
are rather useful but are limited in terms of
functionality. It is able to carry out most of
the less-complex jobs without worries. Yes, it
may at times be frustrating if you did not use
the right literal or the correct quotation mark;
however, their power cannot be ignored
because they truly help users achieve quite a
lot in very little time.
If we were to enter ten commands, as an

example, we will never be able to do that in a
single go. We will have to type in a
command, hit Enter, wait for it to finish, and
then start typing another and continue till the
tenth command ends. To add insult to injury,
we might even need to repeat this process a
few times in order to achieve something. If
only there was a way we could command the
system to do this for us instead of us typing
the commands every single time or even
using the up-arrow key again and again.
This is where the shell script comes in. This
is something that the programmer would love
to use every now and then. Shell scripts can
be made to carry out various commands at
once. In the previous paragraph, we discussed
ten commands and the arduously long time it
would take to accomplish them. Shell scripts

can do these for you in an instant. All you
need to do is to type in the script.
For users who are looking to work in the field
of automation, they have their work cut out
for them. They will be playing in the field by
repeating large operations and tasks over and
over again to achieve the desired results.
Imagine going through hours and days of
carrying out the same commands. The
prospect does seem tedious. The shell script
will be their knight in shining armor. Doing
all those tasks in far less time imaginable
would only allow them to do other tasks and
boost their productivity.
Other common uses of shell scripts are as
follows:
Automating computer maintenance
aspects

Application installation packages
Automating setting and running
commercial apps
Application startup scripts
Learning the scripting language and applying
the same would result in maximum efficiency
and minimum effort. This is possibly the
most popular reason why these scripts are
constantly used.
Choosing Your Development Tools
Linux comes with one of the most
sophisticated development tools. Some of
them are pre-installed, while quite a few are
available for users to access. Whether you are
trying to be a software developer or an image
editor, there is something you will surely find
within the world of Linux that would suit

your fancy. Perhaps a quick and brief
overview of these tools would get the
curiosity up and running!
C Compiler
For those of you who may not know what C
is, except for it being an alphabet, it is a
language that gained immense popularity for
its functionality. C later gave way to so many
languages, applications, and software that are
being used even today. Even most of the
Linux distros have their source codes written
in C or C++.
Okay, that was a brief introduction about C.
What on earth is a compiler? You see, the
computer does not understand any other
language apart from ones and zeroes. The
compiler is what translates all that we write
into the computer into these digits and

explains it to the machine. Now the C source
compiler is what compiles the source code,
written in C language, and converts it to
binary digits so that the system may
understand.
This tool is quite a popular option with
programmers who work on C or C++
languages. This is easy and free to use and
allows quick and effective results. If you have
been following the instructions and installed
Ubuntu 21.04, you have a pre-installed C and
C++ compiler called the “gcc.” For more
information, check out the gcc manual (man
gcc).
Python
When 
we 
speak 
about 
programming
languages, we just cannot overlook the ever-
rising language of Python. This language had

garnered attention from the world at quite an
impressive rate. Known for its dynamics, its
ability 
to 
solve 
complex 
problems,
multithreading, and so much more, Linux has
its support for Python. For developers, you
can resort to a tool under the same name
“python.” You can check out the manual for
all the guidelines and options that you can use
for this language.
Debugger
Essential, important, and frankly quite useful.
If you are running an application or a
program and it crashes, you may want to run
a pre-installed debugger that helps you see
what the program was doing when it crashed.
This kind of information can greatly help us
in analyzing programs and re-writing codes,
if needed.

To access the debugger, you can type in
“gbd.” Alternatively, you can go through its
manual or seek further help online.
Linux continues to provide programmers of
various languages with development tools
and continues to help these professionals with
top-notch solutions. If you wish to pursue a
career in programming, Linux is the platform
for you, and its community is all the help you
will ever need to get the right development
tools.

T
CHAPTER SEVEN
ENHANCING YOUR EXPERIENCE
his has been quite a journey. We started
off with practically no knowledge about
what Linux is, who Mr. Torvalds was, and
what his contribution was to the world. Look
where we stand now — packed with enough
knowledge to start playing around with
Ubuntu, changing the dynamics of the
environment, tweaking things with tools,
using terminals, etc. Quite an impressive

progress in such a short span of time.
Linux, despite its root coming from the days
of Mr. Linus, continues to grow, and along
with it comes new commands. While we still
cannot list down all of these, we will now
check out some commands that would have
been slightly tougher to understand had we
seen them first. These commands aim to
further enhance your experience and ease
matters for you wherever possible.
Getting a Grip on New Commands
Find Command
As the name implies, this command is meant
to search for specific files or a group of files
with a specific extension. It can also perform
searches as per the options and arguments.
Suppose you have hundreds of files in a

directory and you only remember a file by its
extension, which was .txt. You cannot recall
the name. Use this to narrow down the results
and find the file you need. To do that, open
the terminal in the directory you wish to
search for and type in the following
command:
find . -type f -name “*.txt”
As soon as you hit Enter, all the files with the
.txt extension will be displayed before you as
a result. If you remove the * sign, the
terminal will only search for a file that is
named as .php instead of treating it as an
extension.
Note that if the file you are trying to find has
.TXT, it will not be shown within the search
result. The reason for that is the case-
sensitive nature of things in Linux. However,

there is a slight modification you can do to
the command that will then overlook case-
sensitivity and produce the results you need.
To do that, you simply need to replace -name
with -iname. Now, you will see files with
extensions .TXT, .Txt, .TXt, .txt, pretty much
all combinations you can think of.
The find command can locate files with
extensions, names, types, permissions, and
even sizes. You can browse through the vast
and practical uses of this command by
consulting the manual of this command.
Remember, when you are lost, “man”
command is your friend.
GREP Command
While we learned about the find command,
which helps us find files, the grep command
finds specifics within files.

Suppose you are looking for a file that
contains certain information or keywords and
you have no idea where it is located, you can
rely on the grep command to do the job for
you. In order to execute this command, do the
following on your terminal:
grep “keyword” (filename.ext)
Replace the keyword with the actual word
you are looking for. You can add as many
filenames as you wish. The grep command
will include them within the search result.
The result will then highlight the text, where
it is found, and provide you with the
information as to which file contains the said
keyword. Again, if you wish to overlook the
case-sensitive cases, use the -i option before
the quotation mark. You can even use -n to
find out which line number of which file

contains the string you are searching for.
For even more powerful results, you can add
both grep and find commands to bring a new
level of efficiency to your search results.
MAN Command
This might have already made sense by now,
but if for some reason, you still did not get
the concept, don’t worry. If you have a tool
and you cannot find the manual for it, simply
type “man” before the command name, and
you will immediately be shown the complete
manual.
We have used this quite a few times, and it is
something that truly helps you out of sticky
situations.
What’s Next?
Now that you have enough information and

knowledge to get started, you should now
gain further knowledge into specific fields
that might interest you.
Some of you may be interested in pursuing a
career as a software developer. Some may be
interested in becoming a successful system
administrator, while some may even wish to
enter the world of ethical, white-hat hacking
— the possibilities are endless. All of them,
however, start from here.
We would highly recommend you to practice
and keep yourself up to date with Linux
news. Learn newer commands and resort to
tutorials, instructions, and books to gain
deeper knowledge. This book was intended to
serve as a platform for beginners. We do
certainly hope that by now you are equipped
with sufficient knowledge to start making

some life-changing decisions that may
involve Linux.
Future 
of 
Linux: 
Promising 
or
Otherwise?
Linux, owing to the reason that it is an open-
source OS, has come far. By no means do we
imply that its time has come to an end. In
fact, with an ever-increasing awareness of
Linux, we are sure to witness its true rise to
the top very soon.
If you are thinking about the future prospects,
Linux certainly holds a promising future and,
unlike its counterparts, allows a vast array of
options and endless opportunities for those
who seek them out.
You are only limited by your imagination —
use it well and use it wisely!

A
CONCLUSION
ll efforts have been put in to ensure that
this book serves as a good starting point
for people who wish to embark on a journey
into the world of programming. With its
phenomenal 
success, 
an 
ever-increasing
demand and presence, learning computer
programming is only half the battle.
The aim was to provide information with
practical usage while maintaining good

readability. To all the new programmers,
good luck!

